void *std::allocate_shared[abi:ne180100]<TNWNode,std::allocator<TNWNode>,TNWNode&,void>@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  void *v4;
  void *result;

  v4 = operator new(0x58uLL);
  result = std::__shared_ptr_emplace<TNWNode>::__shared_ptr_emplace[abi:ne180100]<TNWNode&,std::allocator<TNWNode>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1D34C7A54(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<TNWNode>::__shared_ptr_emplace[abi:ne180100]<TNWNode&,std::allocator<TNWNode>,0>(void *a1, uint64_t a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2ABB390;
  TNWNode::TNWNode((uint64_t)(a1 + 3), a2);
  return a1;
}

void sub_1D34C7AB0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<TNWNode>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB390;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TNWNode>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB390;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

const void **std::__shared_ptr_emplace<TNWNode>::__on_zero_shared(uint64_t a1)
{
  return std::__destroy_at[abi:ne180100]<TNWNode,0>(a1 + 24);
}

uint64_t TNWNode::TNWNode(uint64_t a1, uint64_t a2)
{
  v4 = *(const void **)a2;
  *(void *)a1 = *(void *)a2;
  if (v4) {
    CFRetain(v4);
  }
  *(void *)(a1 + 8) = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)(a1 + 8), *(TString **)(a2 + 8));
  *(void *)(a1 + 16) = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)(a1 + 16), *(TString **)(a2 + 16));
  *(void *)(a1 + 24) = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)(a1 + 24), *(TString **)(a2 + 24));
  *(void *)(a1 + 32) = *(id *)(a2 + 32);
  *(void *)(a1 + 40) = *(id *)(a2 + 40);
  int v5 = *(_DWORD *)(a2 + 55);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(_DWORD *)(a1 + 55) = v5;
  return a1;
}

void sub_1D34C7C10(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  TRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void sub_1D34C7C54()
{
}

const void **std::__destroy_at[abi:ne180100]<TNWNode,0>(uint64_t a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 24));
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 16));
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 8));
  return TRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TRef((const void **)a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<objc_object  {objcproto16ISIconDecoration}*>>::NSForwardIterator<objc_object  {objcproto16ISIconDecoration}*>::NSForwardIterator(uint64_t a1, uint64_t a2)
{
  id v4 = *(id *)a2;
  *(void *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  int v5 = (void *)(a1 + 112);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 120) = -1;
  v6 = (uint64_t *)(a1 + 120);
  *(void *)(a1 + 128) = -1;
  if (v4 && [v4 count] && (uint64_t v7 = *(void *)(a2 + 128), v7 < objc_msgSend(*(id *)a1, "count")))
  {
    uint64_t v8 = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(void *)(a1 + 112) = v8;
    *(void *)(a1 + 104) = **(void **)(a1 + 24);
    uint64_t *v6 = 0;
    *(void *)(a1 + 128) = 0;
    uint64_t v9 = *(void *)(a2 + 128);
    if (v9 >= v8)
    {
      if (v9 >= 1)
      {
        uint64_t v11 = 0;
        uint64_t v12 = 0;
        do
        {
          if (v11 >= *v5 - 1)
          {
            *int v5 = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
            uint64_t v11 = -1;
            uint64_t *v6 = -1;
          }
          if (*(void *)(a1 + 104) != **(void **)(a1 + 24))
          {
            objc_enumerationMutation(*(id *)a1);
            uint64_t v11 = *v6;
          }
          uint64_t v13 = *(void *)(a1 + 128) + 1;
          *(void *)(a1 + 120) = ++v11;
          *(void *)(a1 + 128) = v13;
          ++v12;
        }
        while (*(void *)(a2 + 128) > v12);
      }
    }
    else
    {
      *(void *)(a1 + 120) = *(void *)(a2 + 120);
      *(void *)(a1 + 128) = v9;
    }
  }
  else
  {
    *(_OWORD *)v6 = *(_OWORD *)(a2 + 120);
  }
  return a1;
}

void sub_1D34C7E28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<objc_object  {objcproto16ISIconDecoration}*>>::NSForwardIterator<objc_object  {objcproto16ISIconDecoration}*>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 128) = -1;
  if (v3 && [v3 count])
  {
    *(void *)(a1 + 112) = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(void *)(a1 + 104) = **(void **)(a1 + 24);
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
  }
  else
  {
    *(void *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1D34C7EEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<objc_object  {objcproto16ISIconDecoration}*>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  *(void *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 128) = -1;
  *(void *)(a1 + 128) = [v4 count];

  return a1;
}

void sub_1D34C7F6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::vector<TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<TNodePtr>::__vallocate[abi:ne180100](a1, a2);
    id v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1D34C7FF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void std::vector<TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  v1 = *a1;
  v2 = (const void **)**a1;
  if (v2)
  {
    id v4 = (const void **)v1[1];
    int v5 = v2;
    if (v4 != v2)
    {
      do
        id v4 = TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(v4 - 1);
      while (v4 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

CFTypeRef *std::pair<TString,TString>::pair[abi:ne180100]<TString,TString,0>(CFTypeRef *a1, CFTypeRef *a2, CFTypeRef *a3)
{
  *a1 = *a2;
  *a2 = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, &stru_1F2ABD380);
  a1[1] = *a3;
  *a3 = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a3, &stru_1F2ABD380);
  return a1;
}

TString *std::pair<TString,TString>::pair[abi:ne180100]<NSString * {__strong},NSString * {__strong},0>(TString *a1, id *a2, id *a3)
{
  int v5 = (TString *)*a2;
  a1->fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a1, v5);

  v6 = (TString *)*a3;
  a1[1].fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a1 + 1, v6);

  return a1;
}

void sub_1D34C8190(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

TString *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<TString,TString>>,std::pair<TString,TString> const*,std::pair<TString,TString> const*,std::pair<TString,TString>*>(uint64_t a1, TString **a2, TString **a3, TString *a4)
{
  id v4 = a4;
  v10 = a4;
  uint64_t v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      std::pair<TString,TString>::pair[abi:ne180100](v4, v6);
      v6 += 2;
      id v4 = v11 + 2;
      v11 += 2;
    }
    while (v6 != a3);
  }
  char v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TString,TString>>,std::pair<TString,TString>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_1D34C826C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

TString *std::pair<TString,TString>::pair[abi:ne180100](TString *a1, TString **a2)
{
  a1->fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a1, *a2);
  a1[1].fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a1 + 1, a2[1]);
  return a1;
}

void sub_1D34C82EC(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TString,TString>>,std::pair<TString,TString>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TString,TString>>,std::pair<TString,TString>*>::operator()[abi:ne180100]((const void **)a1);
  }
  return a1;
}

const void **std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TString,TString>>,std::pair<TString,TString>*>::operator()[abi:ne180100](const void **result)
{
  v1 = *(const void ***)result[2];
  v2 = *(const void ***)result[1];
  if (v1 != v2)
  {
    do
    {
      id v3 = v1 - 2;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1 - 1);
      result = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3);
      v1 = v3;
    }
    while (v3 != v2);
  }
  return result;
}

void std::vector<std::pair<TString,TString>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  v2 = *a1;
  if (*v2)
  {
    std::vector<std::pair<TString,TString>>::__base_destruct_at_end[abi:ne180100]((const void **)v2, (const void **)*v2);
    id v3 = **a1;
    operator delete(v3);
  }
}

const void **std::vector<std::pair<TString,TString>>::__base_destruct_at_end[abi:ne180100](const void **result, const void **a2)
{
  id v3 = result;
  id v4 = (const void **)result[1];
  if (v4 != a2)
  {
    do
    {
      int v5 = v4 - 2;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v4 - 1);
      result = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v5);
      id v4 = v5;
    }
    while (v5 != a2);
  }
  v3[1] = a2;
  return result;
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPTag *>>::NSForwardIterator<NSArray<FPTag *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 128) = -1;
  if (v3 && [v3 count])
  {
    *(void *)(a1 + 112) = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(void *)(a1 + 104) = **(void **)(a1 + 24);
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
  }
  else
  {
    *(void *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1D34C84F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPTag *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  *(void *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 128) = -1;
  *(void *)(a1 + 128) = [v4 count];

  return a1;
}

void sub_1D34C8578(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

Class initSYDocumentAttributes(void)
{
  if (SynapseLibrary(void)::frameworkLibrary
    || (SynapseLibrary(void)::frameworkLibrary = (uint64_t)dlopen("/System/Library/PrivateFrameworks/Synapse.framework/Synapse", 2)) != 0)
  {
    Class Class = objc_getClass("SYDocumentAttributes");
    classSYDocumentAttributes = (uint64_t)Class;
    getSYDocumentAttributesClass Class = (uint64_t (*)(void))SYDocumentAttributesFunction;
  }
  else
  {
    Class Class = (Class)classSYDocumentAttributes;
  }
  return Class;
}

id SYDocumentAttributesFunction(void)
{
  return (id)classSYDocumentAttributes;
}

uint64_t **std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::find<NSString * {__strong}>(void *a1, id *a2)
{
  unint64_t v4 = [*a2 hash];
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v9 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v9 = v4 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v9 = (*(void *)&v5 - 1) & v4;
  }
  v10 = *(uint64_t ****)(*a1 + 8 * v9);
  if (!v10) {
    return 0;
  }
  uint64_t v11 = *v10;
  if (*v10)
  {
    uint64_t v12 = (uint64_t)(a1 + 4);
    do
    {
      unint64_t v13 = (unint64_t)v11[1];
      if (v13 == v6)
      {
        if (std::equal_to<NSString * {__strong}>::operator()(v12, v11[2], *a2)) {
          return v11;
        }
      }
      else
      {
        if (v8 > 1)
        {
          if (v13 >= *(void *)&v5) {
            v13 %= *(void *)&v5;
          }
        }
        else
        {
          v13 &= *(void *)&v5 - 1;
        }
        if (v13 != v9) {
          return 0;
        }
      }
      uint64_t v11 = (uint64_t **)*v11;
    }
    while (v11);
  }
  return v11;
}

uint64_t std::equal_to<NSString * {__strong}>::operator()(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  if (v4 == v5) {
    uint64_t v6 = 1;
  }
  else {
    uint64_t v6 = [v4 isEqualToString:v5];
  }

  return v6;
}

void sub_1D34C8818(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::__emplace_unique_key_args<NSString * {__strong},std::piecewise_construct_t const&,std::tuple<NSString * const {__strong}&>,std::tuple<>>(uint64_t a1, id *a2, uint64_t a3, id **a4)
{
  unint64_t v8 = [*a2 hash];
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = v8;
      if (v8 >= v10) {
        unint64_t v4 = v8 % v10;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v8;
    }
    unint64_t v13 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v13)
    {
      for (i = *v13; i; i = *(void **)i)
      {
        unint64_t v15 = *((void *)i + 1);
        if (v15 == v9)
        {
          if (std::equal_to<NSString * {__strong}>::operator()(a1 + 32, *((void **)i + 2), *a2)) {
            return i;
          }
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v4) {
            break;
          }
        }
      }
    }
  }
  v16 = (void *)(a1 + 16);
  i = operator new(0x20uLL);
  *(void *)i = 0;
  *((void *)i + 1) = v9;
  *((void *)i + 2) = **a4;
  *((void *)i + 3) = 0;
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v10 || (float)(v18 * (float)v10) < v17)
  {
    BOOL v19 = 1;
    if (v10 >= 3) {
      BOOL v19 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v10);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v22);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
      else {
        unint64_t v4 = v9;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
  }
  uint64_t v23 = *(void *)a1;
  v24 = *(void **)(*(void *)a1 + 8 * v4);
  if (v24)
  {
    *(void *)i = *v24;
LABEL_38:
    void *v24 = i;
    goto LABEL_39;
  }
  *(void *)i = *v16;
  void *v16 = i;
  *(void *)(v23 + 8 * v4) = v16;
  if (*(void *)i)
  {
    unint64_t v25 = *(void *)(*(void *)i + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v25 >= v10) {
        v25 %= v10;
      }
    }
    else
    {
      v25 &= v10 - 1;
    }
    v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1D34C8A80(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,void *>>>::operator()[abi:ne180100](v2, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,void *>>>::operator()[abi:ne180100](uint64_t a1, id *a2)
{
  if (*(unsigned char *)(a1 + 8))
  {
  }
  else if (!a2)
  {
    return;
  }
  operator delete(a2);
}

uint64_t std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::__deallocate_node(a1, *(id **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::__deallocate_node(uint64_t a1, id *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      id v3 = (id *)*v2;

      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::clear(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::__deallocate_node(a1, *(id **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

void std::__hash_table<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::hash<NSString * {__strong}>,std::equal_to<NSString * {__strong}>,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,std::equal_to<NSString * {__strong}>,std::hash<NSString * {__strong}>,true>,std::allocator<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>>>::swap(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  id v5 = *(void **)a2;
  *(void *)a2 = 0;
  uint64_t v6 = *(void **)a1;
  *(void *)a1 = v5;
  if (v6) {
    operator delete(v6);
  }
  uint8x8_t v7 = *(void **)a2;
  *(void *)a2 = v4;
  if (v7) {
    operator delete(v7);
  }
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v10 = *(void *)(a2 + 16);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = v9;
  uint64_t v11 = *(void *)(a1 + 24);
  uint64_t v12 = *(void *)(a2 + 24);
  *(void *)(a1 + 16) = v10;
  *(void *)(a1 + 24) = v12;
  *(void *)(a2 + 16) = v8;
  *(void *)(a2 + 24) = v11;
  int v13 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a2 + 32) = v13;
  if (*(void *)(a1 + 24))
  {
    unint64_t v14 = *(void *)(a1 + 8);
    unint64_t v15 = *(void *)(*(void *)(a1 + 16) + 8);
    if ((v14 & (v14 - 1)) != 0)
    {
      if (v15 >= v14) {
        v15 %= v14;
      }
    }
    else
    {
      v15 &= v14 - 1;
    }
    *(void *)(*(void *)a1 + 8 * v15) = a1 + 16;
  }
  if (v11)
  {
    unint64_t v16 = *(void *)(a2 + 8);
    unint64_t v17 = *(void *)(*(void *)(a2 + 16) + 8);
    if ((v16 & (v16 - 1)) != 0)
    {
      if (v17 >= v16) {
        v17 %= v16;
      }
    }
    else
    {
      v17 &= v16 - 1;
    }
    *(void *)(*(void *)a2 + 8 * v17) = a2 + 16;
  }
}

TString *TVersionData::TVersionData(TString *a1, TString **a2)
{
  a1->fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a1, *a2);
  a1[1].fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a1 + 1, a2[1]);
  a1[2].fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a1 + 2, a2[2]);
  a1[3].fString.fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a1 + 3, a2[3]);
  return a1;
}

void sub_1D34C8D98(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void *std::__function::__value_func<void ()(FPItem *,NSError *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::allocate_shared[abi:ne180100]<TNWNode,std::allocator<TNWNode>,__SFNode *&,void>@<X0>(void *a1@<X1>, void *a2@<X8>)
{
  unint64_t v4 = operator new(0x58uLL);
  result = std::__shared_ptr_emplace<TNWNode>::__shared_ptr_emplace[abi:ne180100]<__SFNode *&,std::allocator<TNWNode>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1D34C8EB4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<TNWNode>::__shared_ptr_emplace[abi:ne180100]<__SFNode *&,std::allocator<TNWNode>,0>(void *a1, void *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2ABB390;
  TNWNode::TNWNode(a1 + 3, *a2);
  return a1;
}

void sub_1D34C8F14(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,TFSInfo const&,void>@<X0>(const TFSInfo *a1@<X1>, void *a2@<X8>)
{
  unint64_t v4 = (char *)operator new(0x98uLL);
  uint64_t result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<TFSInfo const&,std::allocator<TFSInfo>,0>((uint64_t)v4, a1);
  *a2 = v4 + 24;
  a2[1] = v4;
  return result;
}

void sub_1D34C8F70(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<TFSInfo const&,std::allocator<TFSInfo>,0>(uint64_t a1, const TFSInfo *a2)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1F2ABB358;
  TFSInfo::TFSInfo((TFSInfo *)(a1 + 24), a2);
  return a1;
}

void sub_1D34C8FCC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

const void **TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void std::__shared_ptr_emplace<NSURL * {__strong}>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB4E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<NSURL * {__strong}>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB4E0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

void std::__shared_ptr_emplace<NSURL * {__strong}>::__on_zero_shared(uint64_t a1)
{
}

uint64_t *TPropertyReference::As<double>(uint64_t *result, uint64_t **a2)
{
  int v2 = *((_DWORD *)result + 2);
  switch((char)v2)
  {
    case 0:
      if (v2) {
        goto LABEL_43;
      }
      uint64_t result = *a2;
      break;
    case 1:
      if (v2 != 1) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 2:
      if (v2 != 2) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 3:
      if (v2 != 3) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 4:
      if (v2 != 4) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 5:
      if (v2 != 5) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 6:
      if (v2 != 6) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 7:
      if (v2 != 7) {
        goto LABEL_43;
      }
      uint64_t result = *(uint64_t **)*result;
      break;
    case 8:
      if (v2 != 8) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 9:
      goto LABEL_41;
    case 10:
      if (v2 != 10) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 11:
      if (v2 != 11) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 12:
      if (v2 != 12) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 13:
      if (v2 != 13) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 14:
      if (v2 != 14) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 15:
      if (v2 != 15) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 16:
      if (v2 != 16) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 17:
      if (v2 != 17) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 18:
      if (v2 != 18) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 19:
      if (v2 != 19) {
        goto LABEL_43;
      }
      uint64_t result = TPropertyValue::As<double>((uint64_t *)*result, a2);
      break;
    case 20:
      if (v2 == 20) {
        goto LABEL_41;
      }
      goto LABEL_43;
    case 21:
      if (v2 != 21) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 22:
      if (v2 != 22) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 23:
      if (v2 != 23) {
LABEL_43:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_41:
      uint64_t result = *a2;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t *TPropertyValue::As<double>(uint64_t *result, uint64_t **a2)
{
  int v2 = *((_DWORD *)result + 4);
  switch((char)v2)
  {
    case 0:
      if (v2) {
        goto LABEL_23;
      }
      uint64_t result = *a2;
      break;
    case 1:
      if (v2 != 1) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 2:
      if (v2 != 2) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 3:
      if (v2 != 3) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 4:
      if (v2 != 4) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 5:
      if (v2 != 5) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 6:
      if (v2 != 6) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 7:
      if (v2 != 7) {
        goto LABEL_23;
      }
      uint64_t result = (uint64_t *)*result;
      break;
    case 8:
      if (v2 == 8) {
        goto LABEL_19;
      }
      goto LABEL_23;
    case 9:
      goto LABEL_19;
    case 10:
      if (v2 != 10) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 11:
      if (v2 != 11) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 12:
      if (v2 != 12) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 13:
      if (v2 != 13) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 14:
      if (v2 != 14) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 15:
      if (v2 != 15) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 16:
      if (v2 != 16) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 17:
      if (v2 != 17) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 18:
      if (v2 != 18) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 19:
      if (v2 != 19) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 20:
      if (v2 != 20) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 21:
      if (v2 != 21) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 22:
      if (v2 != 22) {
        goto LABEL_23;
      }
      goto LABEL_19;
    case 23:
      if (v2 != 23) {
LABEL_23:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_19:
      uint64_t result = *a2;
      break;
    default:
      return result;
  }
  return result;
}

unint64_t TPropertyReference::As<unsigned int>(unint64_t a1, unsigned int *a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 0:
      if (v2) {
        goto LABEL_47;
      }
      LODWORD(a1) = *a2;
      unint64_t v3 = 0xFFFFE07800000000;
      return v3 | a1;
    case 1:
      if (v2 != 1) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 2:
      if (v2 != 2) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 3:
      if (v2 != 3) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 4:
      if (v2 != 4) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 5:
      if (v2 != 5) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 6:
      if (v2 != 6) {
        goto LABEL_47;
      }
      goto LABEL_42;
    case 7:
      if (v2 != 7) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 8:
      if (v2 != 8) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 9:
      goto LABEL_44;
    case 10:
      if (v2 != 10) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 11:
      if (v2 != 11) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 12:
      if (v2 != 12) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 13:
      if (v2 != 13) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 14:
      if (v2 != 14) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 15:
      if (v2 != 15) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 16:
      if (v2 != 16) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 17:
      if (v2 != 17) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 18:
      if (v2 != 18) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 19:
      if (v2 != 19) {
        goto LABEL_47;
      }
      a1 = TPropertyValue::As<unsigned int>(*(unsigned int **)a1, a2);
      unint64_t v3 = a1 & 0xFFFFFFFF00000000;
      return v3 | a1;
    case 20:
      if (v2 != 20) {
        goto LABEL_47;
      }
LABEL_42:
      unint64_t v3 = 0;
      LODWORD(a1) = **(_DWORD **)a1;
      break;
    case 21:
      if (v2 == 21) {
        goto LABEL_44;
      }
      goto LABEL_47;
    case 22:
      if (v2 != 22) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 23:
      if (v2 != 23) {
LABEL_47:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_44:
      unint64_t v3 = 0xFFFFE08E00000000;
      LODWORD(a1) = *a2;
      break;
    default:
      unint64_t v3 = 0xFFFFFFFF00000000;
      break;
  }
  return v3 | a1;
}

unint64_t TPropertyValue::As<unsigned int>(unsigned int *a1, unsigned int *a2)
{
  unsigned int v2 = a1[4];
  unsigned int v3 = v2;
  switch((char)v2)
  {
    case 0:
      if (v2) {
        goto LABEL_47;
      }
      unsigned int v3 = *a2;
      unint64_t v4 = 0xFFFFE07800000000;
      return v4 | v3;
    case 1:
      if (v2 != 1) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 2:
      if (v2 != 2) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 3:
      if (v2 != 3) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 4:
      if (v2 != 4) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 5:
      if (v2 != 5) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 6:
      if (v2 != 6) {
        goto LABEL_47;
      }
      goto LABEL_42;
    case 7:
      if (v2 != 7) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 8:
      if (v2 != 8) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 9:
      goto LABEL_44;
    case 10:
      if (v2 != 10) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 11:
      if (v2 != 11) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 12:
      if (v2 != 12) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 13:
      if (v2 != 13) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 14:
      if (v2 != 14) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 15:
      if (v2 != 15) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 16:
      if (v2 != 16) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 17:
      if (v2 != 17) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 18:
      if (v2 != 18) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 19:
      if (v2 != 19) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 20:
      if (v2 != 20) {
        goto LABEL_47;
      }
LABEL_42:
      unint64_t v4 = 0;
      unsigned int v3 = *a1;
      break;
    case 21:
      if (v2 == 21) {
        goto LABEL_44;
      }
      goto LABEL_47;
    case 22:
      if (v2 != 22) {
        goto LABEL_47;
      }
      goto LABEL_44;
    case 23:
      if (v2 != 23) {
LABEL_47:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_44:
      unint64_t v4 = 0xFFFFE08E00000000;
      unsigned int v3 = *a2;
      break;
    default:
      unint64_t v4 = 0xFFFFFFFF00000000;
      break;
  }
  return v4 | v3;
}

unint64_t TPropertyReference::As<BOOL>(unint64_t a1, unsigned __int8 *a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 0:
      if (v2) {
        goto LABEL_47;
      }
      uint64_t v3 = 0xE07800000000;
      goto LABEL_44;
    case 1:
      if (v2 != 1) {
        goto LABEL_47;
      }
      unint64_t v4 = 0;
      LODWORD(a1) = **(unsigned __int8 **)a1;
      return v4 | a1;
    case 2:
      if (v2 != 2) {
        goto LABEL_47;
      }
      goto LABEL_43;
    case 3:
      if (v2 != 3) {
        goto LABEL_47;
      }
      goto LABEL_43;
    case 4:
      if (v2 != 4) {
        goto LABEL_47;
      }
      goto LABEL_43;
    case 5:
      if (v2 != 5) {
        goto LABEL_47;
      }
      goto LABEL_43;
    case 6:
      if (v2 != 6) {
        goto LABEL_47;
      }
      goto LABEL_43;
    case 7:
      if (v2 != 7) {
        goto LABEL_47;
      }
      goto LABEL_43;
    case 8:
      if (v2 != 8) {
        goto LABEL_47;
      }
      goto LABEL_43;
    case 9:
      unint64_t v4 = 0xFFFFE08E00000000;
      LODWORD(a1) = *a2;
      return v4 | a1;
    case 10:
      if (v2 != 10) {
        goto LABEL_47;
      }
      goto LABEL_43;
    case 11:
      if (v2 != 11) {
        goto LABEL_47;
      }
      goto LABEL_43;
    case 12:
      if (v2 != 12) {
        goto LABEL_47;
      }
      goto LABEL_43;
    case 13:
      if (v2 != 13) {
        goto LABEL_47;
      }
      goto LABEL_43;
    case 14:
      if (v2 != 14) {
        goto LABEL_47;
      }
      goto LABEL_43;
    case 15:
      if (v2 != 15) {
        goto LABEL_47;
      }
      goto LABEL_43;
    case 16:
      if (v2 != 16) {
        goto LABEL_47;
      }
      goto LABEL_43;
    case 17:
      if (v2 != 17) {
        goto LABEL_47;
      }
      goto LABEL_43;
    case 18:
      if (v2 != 18) {
        goto LABEL_47;
      }
      goto LABEL_43;
    case 19:
      if (v2 != 19) {
        goto LABEL_47;
      }
      a1 = TPropertyValue::As<BOOL>(*(unsigned __int8 **)a1, a2);
      unint64_t v4 = a1 & 0xFFFFFFFF00000000;
      return v4 | a1;
    case 20:
      if (v2 == 20) {
        goto LABEL_43;
      }
      goto LABEL_47;
    case 21:
      if (v2 != 21) {
        goto LABEL_47;
      }
      goto LABEL_43;
    case 22:
      if (v2 != 22) {
        goto LABEL_47;
      }
      goto LABEL_43;
    case 23:
      if (v2 != 23) {
LABEL_47:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_43:
      uint64_t v3 = 0xE08E00000000;
LABEL_44:
      unint64_t v4 = v3 & 0xFFFFFFFFFFFFLL | 0xFFFF000000000000;
      LODWORD(a1) = *a2 | v4;
      break;
    default:
      LODWORD(a1) = 0;
      unint64_t v4 = 0xFFFFFFFF00000000;
      break;
  }
  return v4 | a1;
}

unint64_t TPropertyValue::As<BOOL>(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2 = *((_DWORD *)a1 + 4);
  switch((char)v2)
  {
    case 0:
      if (v2) {
        goto LABEL_12;
      }
      uint64_t v3 = 0xE07800000000;
      goto LABEL_9;
    case 1:
      if (v2 != 1) {
        goto LABEL_12;
      }
      unint64_t v5 = 0;
      unsigned int v4 = *a1;
      return v5 | v4;
    case 2:
      if (v2 == 2) {
        goto LABEL_8;
      }
      goto LABEL_12;
    case 3:
      if (v2 != 3) {
        goto LABEL_12;
      }
      goto LABEL_8;
    case 4:
      if (v2 != 4) {
        goto LABEL_12;
      }
      goto LABEL_8;
    case 5:
      if (v2 != 5) {
        goto LABEL_12;
      }
      goto LABEL_8;
    case 6:
      if (v2 != 6) {
        goto LABEL_12;
      }
      goto LABEL_8;
    case 7:
      if (v2 != 7) {
        goto LABEL_12;
      }
      goto LABEL_8;
    case 8:
      if (v2 != 8) {
        goto LABEL_12;
      }
      goto LABEL_8;
    case 9:
      unint64_t v5 = 0xFFFFE08E00000000;
      unsigned int v4 = *a2;
      return v5 | v4;
    case 10:
      if (v2 != 10) {
        goto LABEL_12;
      }
      goto LABEL_8;
    case 11:
      if (v2 != 11) {
        goto LABEL_12;
      }
      goto LABEL_8;
    case 12:
      if (v2 != 12) {
        goto LABEL_12;
      }
      goto LABEL_8;
    case 13:
      if (v2 != 13) {
        goto LABEL_12;
      }
      goto LABEL_8;
    case 14:
      if (v2 != 14) {
        goto LABEL_12;
      }
      goto LABEL_8;
    case 15:
      if (v2 != 15) {
        goto LABEL_12;
      }
      goto LABEL_8;
    case 16:
      if (v2 != 16) {
        goto LABEL_12;
      }
      goto LABEL_8;
    case 17:
      if (v2 != 17) {
        goto LABEL_12;
      }
      goto LABEL_8;
    case 18:
      if (v2 != 18) {
        goto LABEL_12;
      }
      goto LABEL_8;
    case 19:
      if (v2 != 19) {
        goto LABEL_12;
      }
      goto LABEL_8;
    case 20:
      if (v2 != 20) {
        goto LABEL_12;
      }
      goto LABEL_8;
    case 21:
      if (v2 != 21) {
        goto LABEL_12;
      }
      goto LABEL_8;
    case 22:
      if (v2 != 22) {
        goto LABEL_12;
      }
      goto LABEL_8;
    case 23:
      if (v2 != 23) {
LABEL_12:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_8:
      uint64_t v3 = 0xE08E00000000;
LABEL_9:
      unint64_t v5 = v3 & 0xFFFFFFFFFFFFLL | 0xFFFF000000000000;
      unsigned int v4 = *a2 | v5;
      break;
    default:
      unsigned int v4 = 0;
      unint64_t v5 = 0xFFFFFFFF00000000;
      break;
  }
  return v5 | v4;
}

unint64_t TPropertyReference::As<int>(unint64_t a1, unsigned int *a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 0:
      if (v2) {
        goto LABEL_50;
      }
      LODWORD(a1) = *a2;
      unint64_t v3 = 0xFFFFE07800000000;
      return v3 | a1;
    case 1:
      if (v2 != 1) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 2:
      if (v2 != 2) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 3:
      if (v2 != 3) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 4:
      if (v2 != 4) {
        goto LABEL_50;
      }
      goto LABEL_46;
    case 5:
      if (v2 != 5) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 6:
      if (v2 != 6) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 7:
      if (v2 != 7) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 8:
      if (v2 != 8) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 9:
      goto LABEL_48;
    case 10:
      if (v2 != 10) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 11:
      if (v2 != 11) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 12:
      if (v2 != 12) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 13:
      if (v2 != 13) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 14:
      if (v2 != 14) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 15:
      if (v2 != 15) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 16:
      if (v2 != 16) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 17:
      if (v2 != 17) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 18:
      if (v2 != 18) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 19:
      if (v2 != 19) {
        goto LABEL_50;
      }
      a1 = TPropertyValue::As<int>(*(unsigned int **)a1, a2);
      unint64_t v3 = a1 & 0xFFFFFFFF00000000;
      return v3 | a1;
    case 20:
      if (v2 != 20) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 21:
      if (v2 != 21) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 22:
      if (v2 != 22) {
        goto LABEL_50;
      }
LABEL_46:
      unint64_t v3 = 0;
      LODWORD(a1) = **(_DWORD **)a1;
      break;
    case 23:
      if (v2 != 23) {
LABEL_50:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_48:
      unint64_t v3 = 0xFFFFE08E00000000;
      LODWORD(a1) = *a2;
      break;
    default:
      unint64_t v3 = 0xFFFFFFFF00000000;
      break;
  }
  return v3 | a1;
}

unint64_t TPropertyReference::As<short>(unint64_t a1, unsigned __int16 *a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 0:
      if (v2) {
        goto LABEL_50;
      }
      LODWORD(a1) = *a2;
      unint64_t v3 = 0xFFFFE07800000000;
      return v3 | a1;
    case 1:
      if (v2 != 1) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 2:
      if (v2 != 2) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 3:
      if (v2 != 3) {
        goto LABEL_50;
      }
      goto LABEL_46;
    case 4:
      if (v2 != 4) {
        goto LABEL_50;
      }
      goto LABEL_46;
    case 5:
      if (v2 != 5) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 6:
      if (v2 != 6) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 7:
      if (v2 != 7) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 8:
      if (v2 != 8) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 9:
      goto LABEL_48;
    case 10:
      if (v2 != 10) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 11:
      if (v2 != 11) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 12:
      if (v2 != 12) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 13:
      if (v2 != 13) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 14:
      if (v2 != 14) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 15:
      if (v2 != 15) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 16:
      if (v2 != 16) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 17:
      if (v2 != 17) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 18:
      if (v2 != 18) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 19:
      if (v2 != 19) {
        goto LABEL_50;
      }
      a1 = TPropertyValue::As<short>(*(unsigned __int16 **)a1, a2);
      unint64_t v3 = a1 & 0xFFFFFFFF00000000;
      return v3 | a1;
    case 20:
      if (v2 != 20) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 21:
      if (v2 != 21) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 22:
      if (v2 != 22) {
        goto LABEL_50;
      }
LABEL_46:
      unint64_t v3 = 0;
      LODWORD(a1) = **(unsigned __int16 **)a1;
      break;
    case 23:
      if (v2 != 23) {
LABEL_50:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_48:
      unint64_t v3 = 0xFFFFE08E00000000;
      LODWORD(a1) = *a2;
      break;
    default:
      unint64_t v3 = 0xFFFFFFFF00000000;
      break;
  }
  return v3 | a1;
}

unint64_t TPropertyValue::As<short>(unsigned __int16 *a1, unsigned __int16 *a2)
{
  int v2 = *((_DWORD *)a1 + 4);
  unsigned int v3 = v2;
  switch((char)v2)
  {
    case 0:
      if (v2) {
        goto LABEL_50;
      }
      unsigned int v3 = *a2;
      unint64_t v4 = 0xFFFFE07800000000;
      return v4 | v3;
    case 1:
      if (v2 != 1) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 2:
      if (v2 != 2) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 3:
      if (v2 != 3) {
        goto LABEL_50;
      }
      goto LABEL_46;
    case 4:
      if (v2 != 4) {
        goto LABEL_50;
      }
      goto LABEL_46;
    case 5:
      if (v2 != 5) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 6:
      if (v2 != 6) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 7:
      if (v2 != 7) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 8:
      if (v2 != 8) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 9:
      goto LABEL_48;
    case 10:
      if (v2 != 10) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 11:
      if (v2 != 11) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 12:
      if (v2 != 12) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 13:
      if (v2 != 13) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 14:
      if (v2 != 14) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 15:
      if (v2 != 15) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 16:
      if (v2 != 16) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 17:
      if (v2 != 17) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 18:
      if (v2 != 18) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 19:
      if (v2 != 19) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 20:
      if (v2 != 20) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 21:
      if (v2 != 21) {
        goto LABEL_50;
      }
      goto LABEL_48;
    case 22:
      if (v2 != 22) {
        goto LABEL_50;
      }
LABEL_46:
      unint64_t v4 = 0;
      unsigned int v3 = *a1;
      break;
    case 23:
      if (v2 != 23) {
LABEL_50:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_48:
      unint64_t v4 = 0xFFFFE08E00000000;
      unsigned int v3 = *a2;
      break;
    default:
      unint64_t v4 = 0xFFFFFFFF00000000;
      break;
  }
  return v4 | v3;
}

uint64_t TPropertyValue::SetAs<ISIcon * {__strong}>(id *location, id *a2)
{
  int v2 = *((_DWORD *)location + 4);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},ISIcon * const {__strong}&>((uint64_t)location, location, a2);
      return 0;
    case 1:
      if (v2 != 1) {
        goto LABEL_33;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_33;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_33;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_33;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_33;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_33;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_33;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_33;
      }
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_33;
      }
      objc_storeStrong(location, *a2);
      return 0;
    case 11:
      if (v2 != 11) {
        goto LABEL_33;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_33;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_33;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_33;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_33;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_33;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_33;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_33;
      }
      return 4294959246;
    case 19:
      if (v2 == 19) {
        return 4294959246;
      }
      goto LABEL_33;
    case 20:
      if (v2 != 20) {
        goto LABEL_33;
      }
      return 4294959246;
    case 21:
      if (v2 != 21) {
        goto LABEL_33;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_33;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_33:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

void std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},ISIcon * const {__strong}&>(uint64_t a1, id *location, id *a3)
{
  if (*(_DWORD *)(a1 + 16) == 10) {
    objc_storeStrong(location, *a3);
  }
  else {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,ISIcon * const {__strong}&>(a1, a3);
  }
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,ISIcon * const {__strong}&>(uint64_t a1, id *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))off_1F2ABCF10[v4])(&v6, a1);
  }
  *(_DWORD *)(a1 + 16) = -1;
  *(void *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 10;
  return a1;
}

uint64_t TPropertyValue::SetAs<IFSymbol * {__strong}>(id *location, id *a2)
{
  int v2 = *((_DWORD *)location + 4);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},IFSymbol * const {__strong}&>((uint64_t)location, location, a2);
      return 0;
    case 1:
      if (v2 != 1) {
        goto LABEL_33;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_33;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_33;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_33;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_33;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_33;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_33;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_33;
      }
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_33;
      }
      objc_storeStrong(location, *a2);
      return 0;
    case 11:
      if (v2 != 11) {
        goto LABEL_33;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_33;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_33;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_33;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_33;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_33;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_33;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_33;
      }
      return 4294959246;
    case 19:
      if (v2 == 19) {
        return 4294959246;
      }
      goto LABEL_33;
    case 20:
      if (v2 != 20) {
        goto LABEL_33;
      }
      return 4294959246;
    case 21:
      if (v2 != 21) {
        goto LABEL_33;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_33;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_33:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

void std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},IFSymbol * const {__strong}&>(uint64_t a1, id *location, id *a3)
{
  if (*(_DWORD *)(a1 + 16) == 10) {
    objc_storeStrong(location, *a3);
  }
  else {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,IFSymbol * const {__strong}&>(a1, a3);
  }
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,IFSymbol * const {__strong}&>(uint64_t a1, id *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))off_1F2ABCF10[v4])(&v6, a1);
  }
  *(_DWORD *)(a1 + 16) = -1;
  *(void *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 10;
  return a1;
}

const void **TAutoRef<__CFBundle *,TRetainReleasePolicy<__CFBundle *>>::~TAutoRef(const void **a1)
{
  int v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **TAutoRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TAutoRef(const void **a1)
{
  int v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **TRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TRef(const void **a1)
{
  int v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **TAutoRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TAutoRef(const void **a1)
{
  int v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

_OWORD *std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::__emplace_unique_key_args<std::pair<__SFBrowser *,__SFNode *>,std::piecewise_construct_t const&,std::tuple<std::pair<__SFBrowser *,__SFNode *>&&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, _OWORD **a4)
{
  char v6 = (void **)std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::__find_equal<std::pair<__SFBrowser *,__SFNode *>>((uint64_t)a1, &v10, a2);
  uint8x8_t v7 = *v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    uint8x8_t v7 = operator new(0x38uLL);
    v7[2] = **a4;
    *((_DWORD *)v7 + 12) = 0;
    std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__insert_node_at(a1, v10, v8, (uint64_t *)v7);
  }
  return v7;
}

void *std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::__find_equal<std::pair<__SFBrowser *,__SFNode *>>(uint64_t a1, void *a2, unint64_t *a3)
{
  unint64_t v5 = *(void **)(a1 + 8);
  uint64_t result = (void *)(a1 + 8);
  uint64_t v4 = v5;
  if (v5)
  {
    unint64_t v6 = *a3;
    unint64_t v7 = a3[1];
    while (1)
    {
      uint64_t v8 = v4;
      unint64_t v9 = v4[4];
      if (v6 == v9)
      {
        unint64_t v11 = v8[5];
        if (v7 < v11) {
          goto LABEL_11;
        }
        BOOL v12 = v11 == v7;
        if (v11 >= v7) {
          char v13 = 1;
        }
        else {
          char v13 = -1;
        }
        if (v12) {
          char v13 = 0;
        }
        if ((v13 & 0x80) == 0) {
          goto LABEL_22;
        }
LABEL_19:
        uint64_t result = v8 + 1;
        uint64_t v4 = (void *)v8[1];
        if (!v4) {
          goto LABEL_22;
        }
      }
      else
      {
        if (v6 >= v9)
        {
          if (v9 >= v6) {
            char v10 = 1;
          }
          else {
            char v10 = -1;
          }
          if ((v10 & 0x80) == 0) {
            goto LABEL_22;
          }
          goto LABEL_19;
        }
LABEL_11:
        uint64_t v4 = (void *)*v8;
        uint64_t result = v8;
        if (!*v8) {
          goto LABEL_22;
        }
      }
    }
  }
  uint64_t v8 = result;
LABEL_22:
  *a2 = v8;
  return result;
}

void *std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::find<std::pair<__SFBrowser *,__SFNode *>>(uint64_t a1, unint64_t *a2)
{
  unsigned int v3 = (void *)(a1 + 8);
  uint64_t result = std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::__lower_bound<std::pair<__SFBrowser *,__SFNode *>>(a1, a2, *(void **)(a1 + 8), (void *)(a1 + 8));
  if (v3 == result) {
    return v3;
  }
  unint64_t v5 = result[4];
  if (*a2 >= v5) {
    char v6 = 1;
  }
  else {
    char v6 = -1;
  }
  if (*a2 != v5)
  {
    if ((v6 & 0x80) == 0) {
      return result;
    }
    return v3;
  }
  unint64_t v7 = a2[1];
  unint64_t v8 = result[5];
  BOOL v9 = v7 >= v8;
  BOOL v10 = v7 == v8;
  char v11 = -1;
  if (v9) {
    char v11 = 1;
  }
  if (v10) {
    char v11 = 0;
  }
  if (v11 < 0) {
    return v3;
  }
  return result;
}

void *std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::__lower_bound<std::pair<__SFBrowser *,__SFNode *>>(uint64_t a1, unint64_t *a2, void *a3, void *a4)
{
  uint64_t result = a4;
  if (a3)
  {
    unint64_t v5 = *a2;
    unint64_t v6 = a2[1];
    do
    {
      unint64_t v7 = a3[4];
      BOOL v8 = v7 == v5;
      if (v7 >= v5) {
        char v9 = 1;
      }
      else {
        char v9 = -1;
      }
      if (v8)
      {
        unint64_t v10 = a3[5];
        BOOL v11 = v10 == v6;
        char v9 = v10 >= v6 ? 1 : -1;
        if (v11) {
          char v9 = 0;
        }
      }
      BOOL v12 = (v9 & 0x80) == 0;
      if (v9 < 0) {
        char v13 = a3 + 1;
      }
      else {
        char v13 = a3;
      }
      if (v12) {
        uint64_t result = a3;
      }
      a3 = (void *)*v13;
    }
    while (*v13);
  }
  return result;
}

void *std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType &,__SFNode *&,void>@<X0>(char *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  unint64_t v6 = operator new(0x98uLL);
  uint64_t result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType &,__SFNode *&,std::allocator<TFSInfo>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1D34CA9C0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType &,__SFNode *&,std::allocator<TFSInfo>,0>(void *a1, char *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2ABB358;
  TFSInfo::TFSInfo((uint64_t)(a1 + 3), *a2, *a3);
  return a1;
}

void sub_1D34CAA24(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t *TPropertyReference::As<__CFArray const*>(uint64_t *result, uint64_t **a2)
{
  int v2 = *((_DWORD *)result + 2);
  switch((char)v2)
  {
    case 0:
      if (v2) {
        goto LABEL_43;
      }
      uint64_t result = *a2;
      break;
    case 1:
      if (v2 != 1) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 2:
      if (v2 != 2) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 3:
      if (v2 != 3) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 4:
      if (v2 != 4) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 5:
      if (v2 != 5) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 6:
      if (v2 != 6) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 7:
      if (v2 != 7) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 8:
      if (v2 != 8) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 9:
      goto LABEL_41;
    case 10:
      if (v2 != 10) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 11:
      if (v2 != 11) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 12:
      if (v2 != 12) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 13:
      if (v2 != 13) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 14:
      if (v2 != 14) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 15:
      if (v2 != 15) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 16:
      if (v2 != 16) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 17:
      if (v2 != 17) {
        goto LABEL_43;
      }
      uint64_t result = *(uint64_t **)*result;
      break;
    case 18:
      if (v2 != 18) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 19:
      if (v2 != 19) {
        goto LABEL_43;
      }
      uint64_t result = TPropertyValue::As<__CFArray const*>((uint64_t *)*result, a2);
      break;
    case 20:
      if (v2 == 20) {
        goto LABEL_41;
      }
      goto LABEL_43;
    case 21:
      if (v2 != 21) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 22:
      if (v2 != 22) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 23:
      if (v2 != 23) {
LABEL_43:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_41:
      uint64_t result = *a2;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t *TPropertyValue::As<__CFArray const*>(uint64_t *result, uint64_t **a2)
{
  int v2 = *((_DWORD *)result + 4);
  switch((char)v2)
  {
    case 0:
      if (v2) {
        goto LABEL_37;
      }
      uint64_t result = *a2;
      break;
    case 1:
      if (v2 != 1) {
        goto LABEL_37;
      }
      goto LABEL_39;
    case 2:
      if (v2 != 2) {
        goto LABEL_37;
      }
      goto LABEL_39;
    case 3:
      if (v2 != 3) {
        goto LABEL_37;
      }
      goto LABEL_39;
    case 4:
      if (v2 != 4) {
        goto LABEL_37;
      }
      goto LABEL_39;
    case 5:
      if (v2 != 5) {
        goto LABEL_37;
      }
      goto LABEL_39;
    case 6:
      if (v2 != 6) {
        goto LABEL_37;
      }
      goto LABEL_39;
    case 7:
      if (v2 != 7) {
        goto LABEL_37;
      }
      goto LABEL_39;
    case 8:
      if (v2 != 8) {
        goto LABEL_37;
      }
      goto LABEL_39;
    case 9:
      goto LABEL_39;
    case 10:
      if (v2 != 10) {
        goto LABEL_37;
      }
      goto LABEL_39;
    case 11:
      if (v2 != 11) {
        goto LABEL_37;
      }
      goto LABEL_39;
    case 12:
      if (v2 != 12) {
        goto LABEL_37;
      }
      goto LABEL_39;
    case 13:
      if (v2 != 13) {
        goto LABEL_37;
      }
      goto LABEL_39;
    case 14:
      if (v2 != 14) {
        goto LABEL_37;
      }
      goto LABEL_39;
    case 15:
      if (v2 != 15) {
        goto LABEL_37;
      }
      goto LABEL_39;
    case 16:
      if (v2 != 16) {
        goto LABEL_37;
      }
      goto LABEL_39;
    case 17:
      if (v2 != 17) {
        goto LABEL_37;
      }
      uint64_t result = (uint64_t *)*result;
      break;
    case 18:
      if (v2 != 18) {
        goto LABEL_37;
      }
      goto LABEL_39;
    case 19:
      if (v2 == 19) {
        goto LABEL_39;
      }
      goto LABEL_37;
    case 20:
      if (v2 != 20) {
        goto LABEL_37;
      }
      goto LABEL_39;
    case 21:
      if (v2 != 21) {
        goto LABEL_37;
      }
      goto LABEL_39;
    case 22:
      if (v2 != 22) {
        goto LABEL_37;
      }
      goto LABEL_39;
    case 23:
      if (v2 != 23) {
LABEL_37:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_39:
      uint64_t result = *a2;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t TPropertyValue::SetAs<NSPersonNameComponents * {__strong}>(id *location, id *a2)
{
  int v2 = *((_DWORD *)location + 4);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},NSPersonNameComponents * const {__strong}&>((uint64_t)location, location, a2);
      return 0;
    case 1:
      if (v2 != 1) {
        goto LABEL_33;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_33;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_33;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_33;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_33;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_33;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_33;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_33;
      }
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_33;
      }
      objc_storeStrong(location, *a2);
      return 0;
    case 11:
      if (v2 != 11) {
        goto LABEL_33;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_33;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_33;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_33;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_33;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_33;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_33;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_33;
      }
      return 4294959246;
    case 19:
      if (v2 == 19) {
        return 4294959246;
      }
      goto LABEL_33;
    case 20:
      if (v2 != 20) {
        goto LABEL_33;
      }
      return 4294959246;
    case 21:
      if (v2 != 21) {
        goto LABEL_33;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_33;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_33:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

void std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},NSPersonNameComponents * const {__strong}&>(uint64_t a1, id *location, id *a3)
{
  if (*(_DWORD *)(a1 + 16) == 10) {
    objc_storeStrong(location, *a3);
  }
  else {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,NSPersonNameComponents * const {__strong}&>(a1, a3);
  }
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,NSPersonNameComponents * const {__strong}&>(uint64_t a1, id *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))off_1F2ABCF10[v4])(&v6, a1);
  }
  *(_DWORD *)(a1 + 16) = -1;
  *(void *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 10;
  return a1;
}

uint64_t TPropertyValue::SetAs<__CFArray const*>(uint64_t a1, CFTypeRef *a2)
{
  int v2 = *(_DWORD *)(a1 + 16);
  switch((char)v2)
  {
    case 0:
      CFTypeRef v4 = *a2;
      char v6 = v4;
      if (v4) {
        CFRetain(v4);
      }
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<17ul,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>>(a1, (const void **)a1, &v6);
      TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef(&v6);
      return 0;
    case 1:
      if (v2 != 1) {
        goto LABEL_39;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_39;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_39;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_39;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_39;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_39;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_39;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_39;
      }
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_39;
      }
      return 4294959246;
    case 11:
      if (v2 != 11) {
        goto LABEL_39;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_39;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_39;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_39;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_39;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_39;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_39;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a1, *a2);
      return 0;
    case 18:
      if (v2 != 18) {
        goto LABEL_39;
      }
      return 4294959246;
    case 19:
      if (v2 == 19) {
        return 4294959246;
      }
      goto LABEL_39;
    case 20:
      if (v2 != 20) {
        goto LABEL_39;
      }
      return 4294959246;
    case 21:
      if (v2 != 21) {
        goto LABEL_39;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_39;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_39:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPItemDecoration *>>::NSForwardIterator<NSArray<FPItemDecoration *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3 = a2;
  CFTypeRef v4 = v3;
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 128) = -1;
  if (v3 && [v3 count])
  {
    *(void *)(a1 + 112) = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(void *)(a1 + 104) = **(void **)(a1 + 24);
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
  }
  else
  {
    *(void *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1D34CB318(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPItemDecoration *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  *(void *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 128) = -1;
  *(void *)(a1 + 128) = [v4 count];

  return a1;
}

void sub_1D34CB398(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void **TACLRef<char *>::~TACLRef(void **a1)
{
  int v2 = *a1;
  if (v2)
  {
    acl_free(v2);
    *a1 = 0;
  }
  return a1;
}

uint64_t TPropertyValue::SetAs<__CFString const*>(TString *this, CFTypeRef *a2)
{
  int fRef = (int)this[2].fString.fRef;
  switch((char)fRef)
  {
    case 0:
      CFTypeRef v4 = *a2;
      unint64_t v7 = v4;
      if (v4) {
        CFRetain(v4);
      }
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<12ul,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>>((uint64_t)this, (const void **)&this->fString.fRef, &v7);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v7);
      return 0;
    case 1:
      if (fRef != 1) {
        goto LABEL_24;
      }
      return 4294959246;
    case 2:
      if (fRef != 2) {
        goto LABEL_24;
      }
      return 4294959246;
    case 3:
      if (fRef != 3) {
        goto LABEL_24;
      }
      return 4294959246;
    case 4:
      if (fRef != 4) {
        goto LABEL_24;
      }
      return 4294959246;
    case 5:
      if (fRef != 5) {
        goto LABEL_24;
      }
      return 4294959246;
    case 6:
      if (fRef != 6) {
        goto LABEL_24;
      }
      return 4294959246;
    case 7:
      if (fRef != 7) {
        goto LABEL_24;
      }
      return 4294959246;
    case 8:
      if (fRef != 8) {
        goto LABEL_24;
      }
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (fRef != 10) {
        goto LABEL_24;
      }
      return 4294959246;
    case 11:
      if (fRef != 11) {
        goto LABEL_24;
      }
      unint64_t v5 = (TString *)*a2;
      if ((TString *)this->fString.fRef != v5) {
        TString::SetStringRefAsImmutable(this, v5);
      }
      return 0;
    case 12:
      if (fRef != 12) {
        goto LABEL_24;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&this->fString.fRef, *a2);
      return 0;
    case 13:
      if (fRef != 13) {
        goto LABEL_24;
      }
      return 4294959246;
    case 14:
      if (fRef == 14) {
        return 4294959246;
      }
      goto LABEL_24;
    case 15:
      if (fRef != 15) {
        goto LABEL_24;
      }
      return 4294959246;
    case 16:
      if (fRef != 16) {
        goto LABEL_24;
      }
      return 4294959246;
    case 17:
      if (fRef != 17) {
        goto LABEL_24;
      }
      return 4294959246;
    case 18:
      if (fRef != 18) {
        goto LABEL_24;
      }
      return 4294959246;
    case 19:
      if (fRef != 19) {
        goto LABEL_24;
      }
      return 4294959246;
    case 20:
      if (fRef != 20) {
        goto LABEL_24;
      }
      return 4294959246;
    case 21:
      if (fRef != 21) {
        goto LABEL_24;
      }
      return 4294959246;
    case 22:
      if (fRef != 22) {
        goto LABEL_24;
      }
      return 4294959246;
    case 23:
      if (fRef != 23) {
LABEL_24:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

uint64_t TPropertyValue::SetAs<UTType * {__strong}>(id *location, id *a2)
{
  int v2 = *((_DWORD *)location + 4);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},UTType * const {__strong}&>((uint64_t)location, location, a2);
      return 0;
    case 1:
      if (v2 != 1) {
        goto LABEL_33;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_33;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_33;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_33;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_33;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_33;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_33;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_33;
      }
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_33;
      }
      objc_storeStrong(location, *a2);
      return 0;
    case 11:
      if (v2 != 11) {
        goto LABEL_33;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_33;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_33;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_33;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_33;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_33;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_33;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_33;
      }
      return 4294959246;
    case 19:
      if (v2 == 19) {
        return 4294959246;
      }
      goto LABEL_33;
    case 20:
      if (v2 != 20) {
        goto LABEL_33;
      }
      return 4294959246;
    case 21:
      if (v2 != 21) {
        goto LABEL_33;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_33;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_33:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

void std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},UTType * const {__strong}&>(uint64_t a1, id *location, id *a3)
{
  if (*(_DWORD *)(a1 + 16) == 10) {
    objc_storeStrong(location, *a3);
  }
  else {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,UTType * const {__strong}&>(a1, a3);
  }
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,UTType * const {__strong}&>(uint64_t a1, id *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))off_1F2ABCF10[v4])(&v6, a1);
  }
  *(_DWORD *)(a1 + 16) = -1;
  *(void *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 10;
  return a1;
}

uint64_t TPropertyValue::SetAs<SYDocumentAttributes * {__strong}>(id *location, id *a2)
{
  int v2 = *((_DWORD *)location + 4);
  switch((char)v2)
  {
    case 0:
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},SYDocumentAttributes * const {__strong}&>((uint64_t)location, location, a2);
      return 0;
    case 1:
      if (v2 != 1) {
        goto LABEL_33;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_33;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_33;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_33;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_33;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_33;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_33;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_33;
      }
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_33;
      }
      objc_storeStrong(location, *a2);
      return 0;
    case 11:
      if (v2 != 11) {
        goto LABEL_33;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_33;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_33;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_33;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_33;
      }
      return 4294959246;
    case 16:
      if (v2 != 16) {
        goto LABEL_33;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_33;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_33;
      }
      return 4294959246;
    case 19:
      if (v2 == 19) {
        return 4294959246;
      }
      goto LABEL_33;
    case 20:
      if (v2 != 20) {
        goto LABEL_33;
      }
      return 4294959246;
    case 21:
      if (v2 != 21) {
        goto LABEL_33;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_33;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_33:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

void std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<10ul,NSObject * {__strong},SYDocumentAttributes * const {__strong}&>(uint64_t a1, id *location, id *a3)
{
  if (*(_DWORD *)(a1 + 16) == 10) {
    objc_storeStrong(location, *a3);
  }
  else {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,SYDocumentAttributes * const {__strong}&>(a1, a3);
  }
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__emplace[abi:ne180100]<10ul,SYDocumentAttributes * const {__strong}&>(uint64_t a1, id *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))off_1F2ABCF10[v4])(&v6, a1);
  }
  *(_DWORD *)(a1 + 16) = -1;
  *(void *)a1 = *a2;
  *(_DWORD *)(a1 + 16) = 10;
  return a1;
}

void sub_1D34CBB70(_Unwind_Exception *a1)
{
}

void sub_1D34CBC20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  objc_sync_exit(v11);

  _Unwind_Resume(a1);
}

void sub_1D34CBD94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34CBEEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id ErrorWithOSStatus(int a1, NSString *a2)
{
  v9[1] = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if (v3)
    {
      uint64_t v8 = *MEMORY[0x1E4F28568];
      v9[0] = v3;
      unint64_t v5 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v9 forKeys:&v8 count:1];
    }
    else
    {
      unint64_t v5 = 0;
    }
    char v6 = [MEMORY[0x1E4F28C58] errorWithDomain:*MEMORY[0x1E4F28760] code:a1 userInfo:v5];
  }
  else
  {
    char v6 = 0;
  }

  return v6;
}

void sub_1D34CC018(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN19TFSInfoSynchronizer13FetchChildrenEbb12LSProperties_block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) cancel];
}

id __copy_helper_block_ea8_32c65_ZTSKZN19TFSInfoSynchronizer13FetchChildrenEbb12LSPropertiesE3__0(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a2 + 32);
  *(void *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c65_ZTSKZN19TFSInfoSynchronizer13FetchChildrenEbb12LSPropertiesE3__0(uint64_t a1)
{
}

void TFSIterator::~TFSIterator(const void **this)
{
  TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef(this + 3);
  TRef<__CFURLEnumerator const*,TRetainReleasePolicy<__CFURLEnumerator const*>>::~TRef(this + 1);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(this);
}

void **std::vector<std::shared_ptr<TFSInfo>>::push_back[abi:ne180100](uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  id result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    v18[4] = result;
    unint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>((uint64_t)result, v13);
    unint64_t v15 = &v14[16 * v10];
    v18[0] = v14;
    v18[1] = v15;
    v18[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)unint64_t v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    v18[2] = v15 + 16;
    std::vector<std::shared_ptr<TFSInfo>>::__swap_out_circular_buffer(a1, v18);
    char v9 = (void *)a1[1];
    id result = std::__split_buffer<std::shared_ptr<TCFURLInfo>>::~__split_buffer(v18);
  }
  else
  {
    *unint64_t v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    char v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_1D34CC1C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::shared_ptr<TCFURLInfo>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void **std::vector<std::shared_ptr<TFSInfo>>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  id result = (void **)(a1 + 2);
  if (a2 > (v4 - *a1) >> 4)
  {
    if (a2 >> 60) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>((uint64_t)result, a2);
    v7[1] = (char *)v7[0] + v5;
    v7[2] = (char *)v7[0] + v5;
    v7[3] = (char *)v7[0] + 16 * v6;
    std::vector<std::shared_ptr<TFSInfo>>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<std::shared_ptr<TCFURLInfo>>::~__split_buffer(v7);
  }
  return result;
}

void sub_1D34CC25C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::shared_ptr<TCFURLInfo>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void *std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,std::shared_ptr<TFSInfo> &,char (&)[1024],char (&)[1024],fsid &,unsigned long long &,BOOL &,BOOL &,BOOL &,void>@<X0>(os_unfair_lock_s **a1@<X1>, const char *a2@<X2>, char *a3@<X3>, uint64_t *a4@<X4>, uint64_t *a5@<X5>, unsigned __int8 *a6@<X6>, unsigned __int8 *a7@<X7>, void *a8@<X8>, char *a9)
{
  long long v17 = operator new(0x98uLL);
  id result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<TFSInfo> &,char (&)[1024],char (&)[1024],fsid &,unsigned long long &,BOOL &,BOOL &,BOOL &,std::allocator<TFSInfo>,0>(v17, a1, a2, a3, a4, a5, a6, a7, a9);
  *a8 = v17 + 3;
  a8[1] = v17;
  return result;
}

void sub_1D34CC310(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<TFSInfo> &,char (&)[1024],char (&)[1024],fsid &,unsigned long long &,BOOL &,BOOL &,BOOL &,std::allocator<TFSInfo>,0>(void *a1, os_unfair_lock_s **a2, const char *a3, char *a4, uint64_t *a5, uint64_t *a6, unsigned __int8 *a7, unsigned __int8 *a8, char *a9)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2ABB358;
  TFSInfo::TFSInfo((uint64_t)(a1 + 3), a2, a3, a4, *a5, *a6, *a7, *a8, *a9);
  return a1;
}

void sub_1D34CC390(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void *std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType const&,__SFNode *&,void>@<X0>(char *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x98uLL);
  id result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType const&,__SFNode *&,std::allocator<TFSInfo>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1D34CC3F4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType const&,__SFNode *&,std::allocator<TFSInfo>,0>(void *a1, char *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2ABB358;
  TFSInfo::TFSInfo((uint64_t)(a1 + 3), *a2, *a3);
  return a1;
}

void sub_1D34CC458(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1D34CC750(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49)
{
  if (v50) {
    operator delete(v50);
  }

  _Unwind_Resume(a1);
}

uint64_t std::distance[abi:ne180100]<IDContainerIteratorAdaptor<NSArray<FINode *>>>(uint64_t a1, uint64_t a2)
{
  IDContainerIteratorAdaptor<NSArray<FINode *>>::NSForwardIterator<NSArray<FINode *>>::NSForwardIterator((uint64_t)&obj, a1);
  IDContainerIteratorAdaptor<NSArray<FINode *>>::NSForwardIterator<NSArray<FINode *>>::NSForwardIterator((uint64_t)v7, a2);
  uint64_t v3 = 0;
  while (obj != (id)v7[0] || v13 != v7[16])
  {
    uint64_t v4 = v12;
    if (v12 >= v11 - 1)
    {
      uint64_t v5 = [obj countByEnumeratingWithState:v9 objects:v10 count:4];
      uint64_t v4 = -1;
      uint64_t v11 = v5;
      uint64_t v12 = -1;
    }
    if (v10[4] != *(void *)v9[2])
    {
      objc_enumerationMutation(obj);
      uint64_t v4 = v12;
    }
    uint64_t v12 = v4 + 1;
    ++v13;
    ++v3;
  }

  return v3;
}

void sub_1D34CC8C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  _Unwind_Resume(a1);
}

double type_traits_extras::CopyAsHelper<std::vector<long long>>::MakeWithCapacity@<D0>(unint64_t a1@<X0>, uint64_t a2@<X8>)
{
  long long v4 = 0uLL;
  uint64_t v5 = 0;
  std::vector<long long>::reserve((void **)&v4, a1);
  double result = *(double *)&v4;
  *(_OWORD *)a2 = v4;
  *(void *)(a2 + 16) = v5;
  return result;
}

void sub_1D34CC938(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FINode *>>::NSForwardIterator<NSArray<FINode *>>::NSForwardIterator(uint64_t a1, uint64_t a2)
{
  id v4 = *(id *)a2;
  *(void *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  uint64_t v5 = (void *)(a1 + 112);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 120) = -1;
  uint64_t v6 = (uint64_t *)(a1 + 120);
  *(void *)(a1 + 128) = -1;
  if (v4 && [v4 count] && (uint64_t v7 = *(void *)(a2 + 128), v7 < objc_msgSend(*(id *)a1, "count")))
  {
    uint64_t v8 = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(void *)(a1 + 112) = v8;
    *(void *)(a1 + 104) = **(void **)(a1 + 24);
    uint64_t *v6 = 0;
    *(void *)(a1 + 128) = 0;
    uint64_t v9 = *(void *)(a2 + 128);
    if (v9 >= v8)
    {
      if (v9 >= 1)
      {
        uint64_t v11 = 0;
        uint64_t v12 = 0;
        do
        {
          if (v11 >= *v5 - 1)
          {
            *uint64_t v5 = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
            uint64_t v11 = -1;
            uint64_t *v6 = -1;
          }
          if (*(void *)(a1 + 104) != **(void **)(a1 + 24))
          {
            objc_enumerationMutation(*(id *)a1);
            uint64_t v11 = *v6;
          }
          uint64_t v13 = *(void *)(a1 + 128) + 1;
          *(void *)(a1 + 120) = ++v11;
          *(void *)(a1 + 128) = v13;
          ++v12;
        }
        while (*(void *)(a2 + 128) > v12);
      }
    }
    else
    {
      *(void *)(a1 + 120) = *(void *)(a2 + 120);
      *(void *)(a1 + 128) = v9;
    }
  }
  else
  {
    *(_OWORD *)uint64_t v6 = *(_OWORD *)(a2 + 120);
  }
  return a1;
}

void sub_1D34CCAC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FINode *>>::NSForwardIterator<NSArray<FINode *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 128) = -1;
  if (v3 && [v3 count])
  {
    *(void *)(a1 + 112) = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(void *)(a1 + 104) = **(void **)(a1 + 24);
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
  }
  else
  {
    *(void *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1D34CCB88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FINode *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  *(void *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 128) = -1;
  *(void *)(a1 + 128) = [v4 count];

  return a1;
}

void sub_1D34CCC08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::vector<long long>::reserve(void **a1, unint64_t a2)
{
  id v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v3, a2);
    uint64_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    uint64_t v9 = &v6[8 * v8];
    uint64_t v10 = (char *)*a1;
    uint64_t v11 = (char *)a1[1];
    uint64_t v12 = v7;
    if (v11 != *a1)
    {
      uint64_t v12 = v7;
      do
      {
        uint64_t v13 = *((void *)v11 - 1);
        v11 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

uint64_t *std::back_insert_iterator<std::vector<long long>>::operator=[abi:ne180100](uint64_t *a1, void *a2)
{
  uint64_t v4 = *a1;
  int64_t v5 = *(void **)(*a1 + 8);
  uint64_t v6 = (void *)(*a1 + 16);
  if ((unint64_t)v5 >= *v6)
  {
    uint64_t v8 = *(void **)v4;
    uint64_t v9 = ((uint64_t)v5 - *(void *)v4) >> 3;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = *v6 - (void)v8;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)v6, v12);
      uint64_t v8 = *(void **)v4;
      int64_t v5 = *(void **)(v4 + 8);
    }
    else
    {
      uint64_t v13 = 0;
    }
    unint64_t v14 = &v13[8 * v9];
    unint64_t v15 = &v13[8 * v12];
    *(void *)unint64_t v14 = *a2;
    uint64_t v7 = v14 + 8;
    while (v5 != v8)
    {
      uint64_t v16 = *--v5;
      *((void *)v14 - 1) = v16;
      v14 -= 8;
    }
    *(void *)uint64_t v4 = v14;
    *(void *)(v4 + 8) = v7;
    *(void *)(v4 + 16) = v15;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *int64_t v5 = *a2;
    uint64_t v7 = v5 + 1;
  }
  *(void *)(v4 + 8) = v7;
  return a1;
}

uint64_t TConditionVariable::WaitWithTimeout(TConditionVariable *this, std::mutex *a2, uint64_t a3)
{
  ++*((_DWORD *)this + 16);
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v7 = std::chrono::steady_clock::now().__d_.__rep_ + 1000 * a3;
  while (*((_DWORD *)this + 16))
  {
    if (std::condition_variable_any::wait_until<std::mutex,std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>((uint64_t)this, a2, &v7))
    {
      int v5 = *((_DWORD *)this + 16);
      if (v5)
      {
        *((_DWORD *)this + 16) = v5 - 1;
        return 1;
      }
      return 0;
    }
  }
  return 0;
}

void TConditionVariable::Wait(TConditionVariable *this, std::mutex *a2)
{
  int v2 = *((_DWORD *)this + 16);
  *((_DWORD *)this + 16) = v2 + 1;
  if (v2 != -1)
  {
    do
      std::condition_variable_any::wait<std::mutex>((uint64_t)this, a2);
    while (*((_DWORD *)this + 16));
  }
}

BOOL std::condition_variable_any::wait_until<std::mutex,std::chrono::steady_clock,std::chrono::duration<long long,std::ratio<1l,1000000000l>>>(uint64_t a1, std::mutex *a2, std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep *a3)
{
  uint64_t v6 = *(std::mutex **)(a1 + 48);
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v7 = *(std::__shared_weak_count **)(a1 + 56);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v15.__m_ = v6;
  v15.__owns_ = 1;
  std::mutex::lock(v6);
  std::mutex::unlock(a2);
  if (*a3 <= std::chrono::steady_clock::now().__d_.__rep_)
  {
    BOOL v12 = 1;
    goto LABEL_19;
  }
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v8 = *a3;
  v9.__d_.__rep_ = v8 - std::chrono::steady_clock::now().__d_.__rep_;
  if (v9.__d_.__rep_ >= 1)
  {
    std::chrono::steady_clock::now();
    v10.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
    if (v10.__d_.__rep_)
    {
      if (v10.__d_.__rep_ < 1)
      {
        if ((unint64_t)v10.__d_.__rep_ < 0xFFDF3B645A1CAC09)
        {
          std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v11 = 0x8000000000000000;
          goto LABEL_16;
        }
      }
      else if ((unint64_t)v10.__d_.__rep_ > 0x20C49BA5E353F7)
      {
        std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v11 = 0x7FFFFFFFFFFFFFFFLL;
        goto LABEL_14;
      }
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v11 = 1000 * v10.__d_.__rep_;
    }
    else
    {
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v11 = 0;
    }
LABEL_14:
    if (v11 > (v9.__d_.__rep_ ^ 0x7FFFFFFFFFFFFFFFLL))
    {
      v13.__d_.__rep_ = 0x7FFFFFFFFFFFFFFFLL;
LABEL_17:
      std::condition_variable::__do_timed_wait((std::condition_variable *)a1, &v15, v13);
      std::chrono::steady_clock::now();
      goto LABEL_18;
    }
LABEL_16:
    v13.__d_.__rep_ = v11 + v9.__d_.__rep_;
    goto LABEL_17;
  }
LABEL_18:
  BOOL v12 = std::chrono::steady_clock::now().__d_.__rep_ >= *a3;
LABEL_19:
  std::unique_lock<std::mutex>::unlock(&v15);
  std::mutex::lock(a2);
  if (v15.__owns_) {
    std::mutex::unlock(v15.__m_);
  }
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  return v12;
}

void sub_1D34CCFFC(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void std::unique_lock<std::mutex>::unlock(std::unique_lock<std::mutex> *this)
{
  if (this->__owns_)
  {
    std::mutex::unlock(this->__m_);
    this->__owns_ = 0;
  }
  else
  {
    std::__throw_system_error(1, "unique_lock::unlock: not locked");
    std::condition_variable_any::wait<std::mutex>();
  }
}

void std::condition_variable_any::wait<std::mutex>(uint64_t a1, std::mutex *a2)
{
  uint64_t v4 = *(std::mutex **)(a1 + 48);
  int v5 = *(std::__shared_weak_count **)(a1 + 56);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v6.__m_ = v4;
  v6.__owns_ = 1;
  std::mutex::lock(v4);
  std::mutex::unlock(a2);
  std::condition_variable::wait((std::condition_variable *)a1, &v6);
  std::unique_lock<std::mutex>::unlock(&v6);
  std::mutex::lock(a2);
  if (v6.__owns_) {
    std::mutex::unlock(v6.__m_);
  }
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
}

void sub_1D34CD0FC(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1D34CD428(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
}

void sub_1D34CD5C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1D34CD6FC(_Unwind_Exception *a1)
{
  std::unique_lock<std::mutex> v6 = v4;

  _Unwind_Resume(a1);
}

void sub_1D34CD75C()
{
}

void TString::SetFromUniChars(TString *this, const unsigned __int16 *a2, CFIndex a3)
{
  uint64_t v4 = (__CFString *)CFStringCreateWithCharacters((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, a3);
  if (this->fString.fRef) {
    CFRelease(this->fString.fRef);
  }
  this->fString.int fRef = v4;
}

CFIndex TString::IndexOf(TString *this, const TString *a2)
{
  return TString::IndexOf(this, a2, 0);
}

CFIndex TString::IndexOf(TString *this, const TString *a2, CFIndex a3)
{
  if (a3 < 0) {
    return -1;
  }
  if (CFStringGetLength(this->fString.fRef) <= a3 || !CFStringGetLength(a2->fString.fRef)) {
    return -1;
  }
  int fRef = this->fString.fRef;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v7 = RetainCF<__CFString const*>((const void **)&a2->fString.fRef);
  if (v7)
  {
    CFTypeRef v8 = CFAutorelease(v7);
    CFStringRef v9 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v8);
  }
  else
  {
    CFStringRef v9 = 0;
  }
  v12.length = CFStringGetLength(this->fString.fRef) - a3;
  v12.location = a3;
  if (CFStringFindWithOptions(fRef, v9, v12, 0, &v11)) {
    return v11.location;
  }
  else {
    return -1;
  }
}

BOOL TString::operator<(CFStringRef *a1, CFStringRef *a2)
{
  CFIndex Length = CFStringGetLength(*a1);
  CFIndex v5 = CFStringGetLength(*a2);
  if (Length != v5) {
    return Length < v5;
  }
  if (Length) {
    return CFStringCompare(*a1, *a2, 0) == kCFCompareLessThan;
  }
  return 0;
}

void TString::SetLength(TString *this, CFIndex a2)
{
  if (a2)
  {
    CFIndex v3 = a2;
    CFIndex Length = CFStringGetLength(this->fString.fRef);
    if (Length <= v3) {
      uint64_t v5 = v3;
    }
    else {
      uint64_t v5 = Length;
    }
    std::vector<unsigned short>::vector(buffer, v5);
    int fRef = this->fString.fRef;
    CFIndex v7 = CFStringGetLength(this->fString.fRef);
    if (v7 >= v3) {
      v8.length = v3;
    }
    else {
      v8.length = v7;
    }
    v8.location = 0;
    CFStringGetCharacters(fRef, v8, buffer[0]);
    if (v3 >= 1 && (buffer[0][v3 - 1] & 0xFC00) == 0xD800) {
      --v3;
    }
    TString::SetFromUniChars(this, buffer[0], v3);
    if (buffer[0])
    {
      buffer[1] = buffer[0];
      operator delete(buffer[0]);
    }
  }
  else
  {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)&this->fString.fRef, &stru_1F2ABD380);
  }
}

void sub_1D34CD9C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void TString::SubString(TString *this@<X0>, const _NSRange *a2@<X1>, TString *a3@<X8>)
{
}

void TString::Str(TString *this@<X0>, void *a2@<X8>)
{
  CFIndex v3 = objc_retainAutorelease(this->fString.fRef);
  std::string::basic_string[abi:ne180100]<0>(a2, (char *)[(__CFString *)v3 UTF8String]);
}

void sub_1D34CDA54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void *std::vector<unsigned short>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned short>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 2 * a2);
    a1[1] = &v4[2 * a2];
  }
  return a1;
}

void sub_1D34CDAC4(_Unwind_Exception *exception_object)
{
  CFIndex v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned short>::__vallocate[abi:ne180100](void *a1, uint64_t a2)
{
  if (a2 < 0) {
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  }
  double result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[2 * v4];
  return result;
}

void NodeContextClose()
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  TString::TString(&v16, "DS Context");
  TString::TString(&v15, "Close");
  uint64_t v1 = StSignpostMacroHelper::GetOrCreateFinderLog(&v16, v0);
  ISignpostInterval::ISignpostInterval((uint64_t)&v18, v1);

  os_signpost_id_t SignpostID = ISignpostInterval::MakeSignpostID((ISignpostInterval *)&v18, 0);
  v20[0] = &unk_1F2AB9690;
  v20[3] = v20;
  v20[4] = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  std::mutex::lock(&v18);
  os_signpost_id_t v17 = SignpostID;
  *(void *)buf = &unk_1F2AB9950;
  size_t v22 = (std::__shared_weak_count *)&v17;
  uint64_t v23 = buf;
  ISignpostInterval::BeginPriv((uint64_t)&v18, SignpostID, (uint64_t)buf);
  std::__function::__value_func<void ()(NSObject  {objcproto9OS_os_log}*)>::~__value_func[abi:ne180100](buf);
  std::mutex::unlock(&v18);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v16.fString.fRef);
  v14[0] = MEMORY[0x1E4F143A8];
  v14[1] = 3321888768;
  v14[2] = __NodeContextClose_block_invoke;
  v14[3] = &__block_descriptor_33_ea8_32c29_ZTSKZ16NodeContextCloseE3__2_e5_v8__0l;
  if (NodeContextClose::onceToken != -1) {
    dispatch_once(&NodeContextClose::onceToken, v14);
  }
  ContextMutex();
  TDSMutex::lock(&ContextMutex(void)::mutex);
  BOOL v2 = sContextOpenCount == 1;
  if (sContextOpenCount-- <= 1)
  {
    if (v2)
    {
      std::mutex::lock(&gNodeContextCloseAsyncSignpostLock);
      _ZNSt3__115allocate_sharedB8ne180100I50AutoSignpostInterval_General_NodeContextCloseAsyncNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(buf);
      uint64_t v4 = *(void *)buf;
      uint64_t v5 = v22;
      *(void *)buf = 0;
      size_t v22 = 0;
      gNodeContextCloseAsyncSignpost = v4;
      std::unique_lock<std::mutex> v6 = (std::__shared_weak_count *)gNodeContextCloseAsyncSignpost;
      gNodeContextCloseAsyncSignpost = (uint64_t)v5;
      if (v6)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v6);
        if (v22) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v22);
        }
      }
      std::mutex::unlock(&gNodeContextCloseAsyncSignpostLock);
      CFIndex v7 = (TSystemNotificationTask *)TFSInfo::MarkAsUsed((TFSInfo *)1);
      TSystemNotificationTask::FinalizeSystemNotificationTask(v7);
      TNode::Finalize((void *)gNodeContextCloseAsyncGroup);
      CFRange v8 = gNodeContextCloseAsyncGroup;
      CFStringRef v9 = dispatch_get_global_queue(0, 0);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3321888768;
      block[2] = __NodeContextClose_block_invoke_7;
      block[3] = &__block_descriptor_33_ea8_32c29_ZTSKZ16NodeContextCloseE3__3_e5_v8__0l;
      dispatch_group_notify(v8, v9, block);

      std::chrono::system_clock::time_point v10 = LogObj(5);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1D343E000, v10, OS_LOG_TYPE_DEFAULT, "DS Closed", buf, 2u);
      }
    }
    else
    {
      CFRange v11 = LogObj(5);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1D343E000, v11, OS_LOG_TYPE_ERROR, "Imbalanced # of calls to NodeContextOpen/NodeContextClose", buf, 2u);
      }

      sContextOpenCount = 0;
    }
  }
  TDSMutex::unlock(&ContextMutex(void)::mutex);
  StSignpostMacroHelper::~StSignpostMacroHelper((StSignpostMacroHelper *)&v18);
}

void sub_1D34CDE7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, std::mutex *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
}

void __NodeContextClose_block_invoke()
{
  dispatch_group_t v0 = dispatch_group_create();
  uint64_t v1 = (void *)gNodeContextCloseAsyncGroup;
  gNodeContextCloseAsyncGroup = (uint64_t)v0;
}

void __NodeContextClose_block_invoke_7()
{
  std::mutex::lock(&gNodeContextCloseAsyncSignpostLock);
  gNodeContextCloseAsyncSignpost = 0;
  dispatch_group_t v0 = (std::__shared_weak_count *)gNodeContextCloseAsyncSignpost;
  gNodeContextCloseAsyncSignpost = 0;
  if (v0) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v0);
  }
  std::mutex::unlock(&gNodeContextCloseAsyncSignpostLock);
}

TNode *GetNodeProperty(TNode *a1, OpaqueNodeRef *a2, TPropertyReference *a3, TNodeRequest *a4, unsigned int a5)
{
  uint64_t v7 = (uint64_t)a2;
  TString v16 = a4;
  uint64_t v8 = TNode::NodeFromNodeRef(a1, a2);
  double result = (TNode *)TNode::WeakValidate((TNode *)v8, v9);
  if (!result)
  {
    if (v7 == 1684955501)
    {
      CFRange v11 = (os_unfair_lock_s *)TNode::InfoLock(result);
      os_unfair_lock_lock(v11);
      uint64_t v13 = *(void *)(v8 + 16);
      CFRange v12 = *(std::__shared_weak_count **)(v8 + 24);
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v11);
      unint64_t v14 = (os_unfair_lock_s *)(v13 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v13 + 100));
      unint64_t v15 = *(unsigned int *)(v13 + 115) | ((unint64_t)*(unsigned __int16 *)(v13 + 119) << 32);
      os_unfair_lock_unlock(v14);
      if (v12) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v12);
      }
      uint64_t v7 = 1684955501;
      if ((v15 & 0x100000000) != 0) {
        uint64_t v7 = 1886282093;
      }
    }
    return (TNode *)TNode::GetProperty(v8, v7, a3, &v16, a5);
  }
  return result;
}

TNode *SetNodeProperty(TNode *a1, OpaqueNodeRef *a2, const TPropertyReference *a3, __CFString *a4, uint64_t a5)
{
  int v7 = (int)a2;
  unint64_t v14 = a4;
  uint64_t v8 = (TNode *)TNode::NodeFromNodeRef(a1, a2);
  uint64_t v10 = (uint64_t)v8;
  if (v7 == 1769370466)
  {
    double result = (TNode *)TNode::WeakValidate(v8, v9);
    if (result) {
      return result;
    }
  }
  else
  {
    double result = (TNode *)TNode::Validate(v8, v9);
    if (result) {
      return result;
    }
  }
  TNode::GetSuperRootNode((uint64_t *)&v13, result);
  uint64_t v12 = TNodeFromFINode(v13);

  if (v10 == v12) {
    return 0;
  }
  else {
    return (TNode *)TNode::SetProperty(v10, v7, a3, &v14, 1, a5);
  }
}

void sub_1D34CE194(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

uint64_t NodeIteratorSize(uint64_t result)
{
  if (result) {
    return (*(void *)(result + 24) - *(void *)(result + 16)) >> 3;
  }
  return result;
}

void NodeDisposeNotifier(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = a1;
  uint64_t v1 = NodeChangeNotifierRegistry();
  CFIndex v3 = v2;
  std::mutex::lock(v2);
  uint64_t v4 = std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::find<OpaqueEventNotifier *>(v1, &v6);
  if (v4)
  {
    std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::erase(v1, v4);
  }
  else
  {
    uint64_t v5 = LogObj(5);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134349056;
      uint64_t v8 = v6;
      _os_log_impl(&dword_1D343E000, v5, OS_LOG_TYPE_ERROR, "Calling RemoveFromNodeChangeNotifierRegistry on a notifier not being tracked: %{public}p", buf, 0xCu);
    }
  }
  std::mutex::unlock(v3);
}

void sub_1D34CE30C(_Unwind_Exception *exception_object)
{
}

uint64_t NodeUnregisterChangeNotification(TNode *a1, OpaqueNodeRef *a2, uint64_t a3)
{
  if (!a2) {
    return 4294959224;
  }
  uint64_t v6 = (TNode *)TNode::NodeFromNodeRef(a1, a2);
  uint64_t v8 = TNode::WeakValidate(v6, v7);
  if (!v8)
  {
    [(TNode *)a1 unregisteringChangeNotification:a3];
    ClientNotifierFromNodeNotifier((OpaqueEventNotifier *)a2, &v11);
    if (v11)
    {
      TNodePtr::TNodePtr(&v10, v6);
      uint64_t v8 = TNode::UnregisterChangeNotification((uint64_t)v6, (uint64_t)&v11, &v10.fFINode, a3);
    }
    else
    {
      uint64_t v8 = 4294959224;
    }
    if (v12) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v12);
    }
  }
  return v8;
}

void sub_1D34CE3F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(a1);
}

uint64_t _NodeSizingV2(const __CFURL *a1, const __CFURL *a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  if (!a1 || !a5 || *a5) {
    return 4294959224;
  }
  _ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v32);
  if (a2) {
    CFURLRef v11 = a2;
  }
  else {
    CFURLRef v11 = a1;
  }
  TCFURLInfo::Initialize(v32, v11, 1, 1);
  TCFURLInfo::GetVolumeInfoRecord((CFURLRef *)v32, v34);
  uint64_t v12 = v34[1];
  _ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v30);
  CFIndex v5 = TCFURLInfo::Initialize(v30, a1, 1, 1);
  if (!v5)
  {
    uint64_t v24 = 0;
    __int16 v25 = 0;
    __int16 v19 = 0;
    char v20 = 0;
    long long v21 = 0u;
    long long v22 = 0u;
    memset(v23, 0, sizeof(v23));
    int v28 = 0;
    char v29 = 1;
    unint64_t v14 = v30;
    uint64_t v13 = v31;
    if (v31) {
      atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v18[0] = v14;
    v18[1] = v13;
    TString v16 = v32;
    unint64_t v15 = v33;
    if (v33) {
      atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v18[2] = v16;
    v18[3] = v15;
    v18[4] = v12;
    long long v26 = *(_OWORD *)(a3 + 8);
    uint64_t v27 = a4;
    LOBYTE(v19) = (v34[0] & 0x20) != 0;
    HIBYTE(v19) = 0;
    if (geteuid()) {
      BYTE2(v28) = 1;
    }
    TOperationSizer::TOperationSizer((TOperationSizer *)v17, (const TOperationSizer::TOperationSizerParams *)v18);
    TOperationSizer::ComputeSize((TOperationSizer *)v17);
  }
  if (v31) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v31);
  }
  if (v33) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v33);
  }
  return v5;
}

void sub_1D34CE604(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,id a56)
{
  TOperationSizer::~TOperationSizer((TOperationSizer *)&a9);
  TOperationSizer::TOperationSizerParams::~TOperationSizerParams(&a56);
  v58 = *(std::__shared_weak_count **)(v56 - 112);
  if (v58) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v58);
  }
  v59 = *(std::__shared_weak_count **)(v56 - 96);
  if (v59) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v59);
  }
  _Unwind_Resume(a1);
}

void TOperationSizer::TOperationSizerParams::~TOperationSizerParams(id *this)
{
  BOOL v2 = (std::__shared_weak_count *)this[3];
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  CFIndex v3 = (std::__shared_weak_count *)this[1];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
}

void ISignpostInterval::~ISignpostInterval(id *this)
{
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)(this + 9));

  std::mutex::~mutex((std::mutex *)this);
}

void AutoSignpostInterval_General_NodeContextCloseAsync::Event<char [47]>(uint64_t a1, uint64_t a2)
{
  v5[4] = *MEMORY[0x1E4F143B8];
  std::mutex::lock((std::mutex *)a1);
  uint64_t v4 = *(void *)(a1 + 112);
  v5[0] = &unk_1F2ABCFE0;
  v5[1] = a1;
  v5[2] = a2;
  v5[3] = v5;
  ISignpostInterval::EventPriv(a1, v4, (uint64_t)v5);
  std::__function::__value_func<void ()(NSObject  {objcproto9OS_os_log}*)>::~__value_func[abi:ne180100](v5);
  std::mutex::unlock((std::mutex *)a1);
}

void sub_1D34CE788(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(NSObject  {objcproto9OS_os_log}*)>::~__value_func[abi:ne180100]((uint64_t *)va);
  std::mutex::unlock(v2);
  _Unwind_Resume(a1);
}

void std::__function::__func<void AutoSignpostInterval_General_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<void AutoSignpostInterval_General_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::~__func()
{
}

__n128 std::__function::__func<void AutoSignpostInterval_General_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<void AutoSignpostInterval_General_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t a1)
{
  BOOL v2 = (char *)operator new(0x18uLL);
  *(void *)BOOL v2 = &unk_1F2ABCFE0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<void AutoSignpostInterval_General_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<void AutoSignpostInterval_General_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F2ABCFE0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<void AutoSignpostInterval_General_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<void AutoSignpostInterval_General_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(uint64_t a1, void **a2)
{
}

uint64_t std::__function::__func<void AutoSignpostInterval_General_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<void AutoSignpostInterval_General_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void AutoSignpostInterval_General_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<void AutoSignpostInterval_General_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target_type()
{
}

void AutoSignpostInterval_General_NodeContextCloseAsync::Event<char [47]>(char [47] const&)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}::operator()(uint64_t *a1, void *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  uint64_t v4 = *a1;
  CFIndex v5 = v3;
  uint64_t v6 = v5;
  os_signpost_id_t v7 = *(void *)(v4 + 112);
  if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v5))
  {
    *(void *)&long long v10 = a1[1];
    *((void *)&v10 + 1) = strlen((const char *)v10);
    FormatDetails(&v10, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v12 = p_p;
    _os_signpost_emit_with_name_impl(&dword_1D343E000, v6, OS_SIGNPOST_EVENT, v7, "NodeContextCloseAsync", "%{public}s", buf, 0xCu);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1D34CE9A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::erase(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::remove(a1, a2, (uint64_t)&__p);
  id v3 = __p;
  std::string __p = 0;
  if (v3) {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,void *>>>::operator()[abi:ne180100]((uint64_t)&v6, v3);
  }
  return v2;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,NSObject  {objcproto9OS_os_log}* {__strong}>,void *>>>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 8))
  {

    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a2 + 16));
  }
  else if (!a2)
  {
    return;
  }
  operator delete((void *)a2);
}

void std::__function::__func<_NodeContextOpenExtended::$_1,std::allocator<_NodeContextOpenExtended::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::~__func()
{
}

void *std::__function::__func<_NodeContextOpenExtended::$_1,std::allocator<_NodeContextOpenExtended::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1F2AB96E8;
  return result;
}

void std::__function::__func<_NodeContextOpenExtended::$_1,std::allocator<_NodeContextOpenExtended::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2AB96E8;
}

uint64_t std::__function::__func<_NodeContextOpenExtended::$_1,std::allocator<_NodeContextOpenExtended::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

void *std::__function::__func<_NodeContextOpenExtended::$_1,std::allocator<_NodeContextOpenExtended::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::target_type()
{
}

void std::__function::__func<_NodeContextOpenExtended::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<_NodeContextOpenExtended::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::~__func()
{
}

void *std::__function::__func<_NodeContextOpenExtended::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<_NodeContextOpenExtended::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1F2AB9A58;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<_NodeContextOpenExtended::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<_NodeContextOpenExtended::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F2AB9A58;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<_NodeContextOpenExtended::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<_NodeContextOpenExtended::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<_NodeContextOpenExtended::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<_NodeContextOpenExtended::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target_type()
{
}

void std::__function::__func<_NodeContextOpenExtended::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<_NodeContextOpenExtended::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::~__func()
{
}

void *std::__function::__func<_NodeContextOpenExtended::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<_NodeContextOpenExtended::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1F2AB9A00;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<_NodeContextOpenExtended::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<_NodeContextOpenExtended::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F2AB9A00;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<_NodeContextOpenExtended::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<_NodeContextOpenExtended::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<_NodeContextOpenExtended::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<_NodeContextOpenExtended::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target_type()
{
}

void std::__function::__func<NodeContextOpen::$_1,std::allocator<NodeContextOpen::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::~__func()
{
}

void *std::__function::__func<NodeContextOpen::$_1,std::allocator<NodeContextOpen::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1F2AB9638;
  return result;
}

void std::__function::__func<NodeContextOpen::$_1,std::allocator<NodeContextOpen::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2AB9638;
}

uint64_t std::__function::__func<NodeContextOpen::$_1,std::allocator<NodeContextOpen::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

void *std::__function::__func<NodeContextOpen::$_1,std::allocator<NodeContextOpen::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::target_type()
{
}

void std::__function::__func<NodeContextOpen::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextOpen::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::~__func()
{
}

void *std::__function::__func<NodeContextOpen::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextOpen::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1F2AB98F8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<NodeContextOpen::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextOpen::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F2AB98F8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<NodeContextOpen::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextOpen::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<NodeContextOpen::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextOpen::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target_type()
{
}

void std::__function::__func<NodeContextOpen::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextOpen::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::~__func()
{
}

void *std::__function::__func<NodeContextOpen::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextOpen::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1F2AB98A0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<NodeContextOpen::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextOpen::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F2AB98A0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<NodeContextOpen::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextOpen::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<NodeContextOpen::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextOpen::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target_type()
{
}

void std::__function::__func<NodeContextClose::$_1,std::allocator<NodeContextClose::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::~__func()
{
}

void *std::__function::__func<NodeContextClose::$_1,std::allocator<NodeContextClose::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1F2AB9690;
  return result;
}

void std::__function::__func<NodeContextClose::$_1,std::allocator<NodeContextClose::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2AB9690;
}

void *std::__function::__func<NodeContextClose::$_1,std::allocator<NodeContextClose::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::operator()(uint64_t a1, uint64_t *a2, unint64_t *a3)
{
  v6[4] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a2;
  unint64_t v5 = *a3;
  v6[0] = &unk_1F2AB99A8;
  v6[1] = &v5;
  v6[3] = v6;
  ISignpostInterval::EndPriv(v3, v5, (uint64_t)v6);
  return std::__function::__value_func<void ()(NSObject  {objcproto9OS_os_log}*)>::~__value_func[abi:ne180100](v6);
}

void sub_1D34CF04C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(NSObject  {objcproto9OS_os_log}*)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<NodeContextClose::$_1,std::allocator<NodeContextClose::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

void *std::__function::__func<NodeContextClose::$_1,std::allocator<NodeContextClose::$_1>,void ()(StSignpostMacroHelper *,unsigned long long)>::target_type()
{
}

void std::__function::__func<NodeContextClose::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextClose::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::~__func()
{
}

void *std::__function::__func<NodeContextClose::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextClose::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1F2AB99A8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<NodeContextClose::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextClose::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F2AB99A8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<NodeContextClose::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextClose::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(uint64_t a1, id *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = v3;
  os_signpost_id_t v5 = **(void **)(a1 + 8);
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v3))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_signpost_emit_with_name_impl(&dword_1D343E000, v4, OS_SIGNPOST_INTERVAL_END, v5, "Close", "End", v6, 2u);
  }
}

uint64_t std::__function::__func<NodeContextClose::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextClose::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<NodeContextClose::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextClose::$_1::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target_type()
{
}

void std::__function::__func<NodeContextClose::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextClose::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::~__func()
{
}

void *std::__function::__func<NodeContextClose::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextClose::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1F2AB9950;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<NodeContextClose::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextClose::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F2AB9950;
  a2[1] = v2;
  return result;
}

void std::__function::__func<NodeContextClose::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextClose::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(uint64_t a1, id *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = v3;
  os_signpost_id_t v5 = **(void **)(a1 + 8);
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v3))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_signpost_emit_with_name_impl(&dword_1D343E000, v4, OS_SIGNPOST_INTERVAL_BEGIN, v5, "Close", "Begin", v6, 2u);
  }
}

uint64_t std::__function::__func<NodeContextClose::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextClose::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<NodeContextClose::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<NodeContextClose::$_0::operator() const(StSignpostMacroHelper *,unsigned long long)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target_type()
{
}

void *_ZNSt3__115allocate_sharedB8ne180100I50AutoSignpostInterval_General_NodeContextCloseAsyncNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(void *a1@<X8>)
{
  uint64_t v2 = operator new(0x90uLL);
  __n128 result = _ZNSt3__120__shared_ptr_emplaceI50AutoSignpostInterval_General_NodeContextCloseAsyncNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1D34CF3BC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *_ZNSt3__120__shared_ptr_emplaceI50AutoSignpostInterval_General_NodeContextCloseAsyncNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2ABD060;
  AutoSignpostInterval_General_NodeContextCloseAsync::AutoSignpostInterval_General_NodeContextCloseAsync((AutoSignpostInterval_General_NodeContextCloseAsync *)(a1 + 3), 0);
  return a1;
}

void sub_1D34CF41C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<AutoSignpostInterval_General_NodeContextCloseAsync>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABD060;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<AutoSignpostInterval_General_NodeContextCloseAsync>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABD060;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

void std::__shared_ptr_emplace<AutoSignpostInterval_General_NodeContextCloseAsync>::__on_zero_shared(uint64_t a1)
{
}

void AutoSignpostInterval_General_NodeContextCloseAsync::AutoSignpostInterval_General_NodeContextCloseAsync(AutoSignpostInterval_General_NodeContextCloseAsync *this, void *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = LogObj(5);
  TString::TString(&v6, "NodeContextCloseAsync");
  ISignpostInterval::ISignpostInterval((uint64_t)this, v4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v6.fString.fRef);

  *((void *)this + 14) = ISignpostInterval::MakeSignpostID(this, a2);
  std::mutex::lock((std::mutex *)this);
  unint64_t v5 = *((void *)this + 14);
  v6.fString.int fRef = (__CFString *)&unk_1F2ABD0B0;
  os_signpost_id_t v7 = this;
  uint64_t v8 = &v6;
  ISignpostInterval::BeginPriv((uint64_t)this, v5, (uint64_t)&v6);
  std::__function::__value_func<void ()(NSObject  {objcproto9OS_os_log}*)>::~__value_func[abi:ne180100](&v6);
  std::mutex::unlock((std::mutex *)this);
}

void sub_1D34CF5AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(NSObject  {objcproto9OS_os_log}*)>::~__value_func[abi:ne180100]((uint64_t *)va);
  std::mutex::unlock(v2);
  ISignpostInterval::~ISignpostInterval((id *)v2);
  _Unwind_Resume(a1);
}

void std::__function::__func<AutoSignpostInterval_General_NodeContextCloseAsync::AutoSignpostInterval_General_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<AutoSignpostInterval_General_NodeContextCloseAsync::AutoSignpostInterval_General_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::~__func()
{
}

void *std::__function::__func<AutoSignpostInterval_General_NodeContextCloseAsync::AutoSignpostInterval_General_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<AutoSignpostInterval_General_NodeContextCloseAsync::AutoSignpostInterval_General_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1F2ABD0B0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<AutoSignpostInterval_General_NodeContextCloseAsync::AutoSignpostInterval_General_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<AutoSignpostInterval_General_NodeContextCloseAsync::AutoSignpostInterval_General_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F2ABD0B0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<AutoSignpostInterval_General_NodeContextCloseAsync::AutoSignpostInterval_General_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<AutoSignpostInterval_General_NodeContextCloseAsync::AutoSignpostInterval_General_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(uint64_t a1, id *a2)
{
  std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<AutoSignpostInterval_General_NodeContextCloseAsync::AutoSignpostInterval_General_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1} &,NSObject  {objcproto9OS_os_log}* {__strong}>((uint64_t *)(a1 + 8), a2);
}

uint64_t std::__function::__func<AutoSignpostInterval_General_NodeContextCloseAsync::AutoSignpostInterval_General_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<AutoSignpostInterval_General_NodeContextCloseAsync::AutoSignpostInterval_General_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<AutoSignpostInterval_General_NodeContextCloseAsync::AutoSignpostInterval_General_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<AutoSignpostInterval_General_NodeContextCloseAsync::AutoSignpostInterval_General_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target_type()
{
}

void std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<AutoSignpostInterval_General_NodeContextCloseAsync::AutoSignpostInterval_General_NodeContextCloseAsync(void *)::{lambda(NSObject  {objcproto9OS_os_log}*)#1} &,NSObject  {objcproto9OS_os_log}* {__strong}>(uint64_t *a1, id *a2)
{
  id v3 = *a2;
  uint64_t v4 = *a1;
  unint64_t v5 = v3;
  TString v6 = v5;
  os_signpost_id_t v7 = *(void *)(v4 + 112);
  if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v5))
  {
    *(_WORD *)uint64_t v8 = 0;
    _os_signpost_emit_with_name_impl(&dword_1D343E000, v6, OS_SIGNPOST_INTERVAL_BEGIN, v7, "NodeContextCloseAsync", "Begin", v8, 2u);
  }
}

void AutoSignpostInterval_General_NodeContextCloseAsync::~AutoSignpostInterval_General_NodeContextCloseAsync(AutoSignpostInterval_General_NodeContextCloseAsync *this)
{
  v3[4] = *MEMORY[0x1E4F143B8];
  std::mutex::lock((std::mutex *)this);
  v3[0] = *((void *)this + 14);
  if (std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::find<unsigned long long>((void *)this + 9, v3))
  {
    unint64_t v2 = *((void *)this + 14);
    v3[0] = (unint64_t)&unk_1F2ABD130;
    v3[1] = (unint64_t)this;
    v3[3] = (unint64_t)v3;
    ISignpostInterval::EndPriv((uint64_t)this, v2, (uint64_t)v3);
    std::__function::__value_func<void ()(NSObject  {objcproto9OS_os_log}*)>::~__value_func[abi:ne180100](v3);
  }
  std::mutex::unlock((std::mutex *)this);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)this + 72);

  std::mutex::~mutex((std::mutex *)this);
}

void sub_1D34CF84C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

void std::__function::__func<AutoSignpostInterval_General_NodeContextCloseAsync::~AutoSignpostInterval_General_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<AutoSignpostInterval_General_NodeContextCloseAsync::~AutoSignpostInterval_General_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::~__func()
{
}

void *std::__function::__func<AutoSignpostInterval_General_NodeContextCloseAsync::~AutoSignpostInterval_General_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<AutoSignpostInterval_General_NodeContextCloseAsync::~AutoSignpostInterval_General_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1F2ABD130;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<AutoSignpostInterval_General_NodeContextCloseAsync::~AutoSignpostInterval_General_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<AutoSignpostInterval_General_NodeContextCloseAsync::~AutoSignpostInterval_General_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F2ABD130;
  a2[1] = v2;
  return result;
}

void std::__function::__func<AutoSignpostInterval_General_NodeContextCloseAsync::~AutoSignpostInterval_General_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<AutoSignpostInterval_General_NodeContextCloseAsync::~AutoSignpostInterval_General_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(uint64_t a1, id *a2)
{
  std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<AutoSignpostInterval_General_NodeContextCloseAsync::~AutoSignpostInterval_General_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1} &,NSObject  {objcproto9OS_os_log}* {__strong}>((uint64_t *)(a1 + 8), a2);
}

uint64_t std::__function::__func<AutoSignpostInterval_General_NodeContextCloseAsync::~AutoSignpostInterval_General_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<AutoSignpostInterval_General_NodeContextCloseAsync::~AutoSignpostInterval_General_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<AutoSignpostInterval_General_NodeContextCloseAsync::~AutoSignpostInterval_General_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1},std::allocator<AutoSignpostInterval_General_NodeContextCloseAsync::~AutoSignpostInterval_General_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1}>,void ()(NSObject  {objcproto9OS_os_log}*)>::target_type()
{
}

void std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<AutoSignpostInterval_General_NodeContextCloseAsync::~AutoSignpostInterval_General_NodeContextCloseAsync()::{lambda(NSObject  {objcproto9OS_os_log}*)#1} &,NSObject  {objcproto9OS_os_log}* {__strong}>(uint64_t *a1, id *a2)
{
  id v3 = *a2;
  uint64_t v4 = *a1;
  unint64_t v5 = v3;
  TString v6 = v5;
  os_signpost_id_t v7 = *(void *)(v4 + 112);
  if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v5))
  {
    *(_WORD *)uint64_t v8 = 0;
    _os_signpost_emit_with_name_impl(&dword_1D343E000, v6, OS_SIGNPOST_INTERVAL_END, v7, "NodeContextCloseAsync", "End", v8, 2u);
  }
}

void *std::allocate_shared[abi:ne180100]<TNodeTask,std::allocator<TNodeTask>,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,void>@<X0>(void *a1@<X8>)
{
  uint64_t v2 = operator new(0x50uLL);
  __n128 result = std::__shared_ptr_emplace<TNodeTask>::__shared_ptr_emplace[abi:ne180100]<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,std::allocator<TNodeTask>,0>(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1D34CFA14(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<TNodeTask>::__shared_ptr_emplace[abi:ne180100]<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,std::allocator<TNodeTask>,0>(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2ABB3C8;
  TNodeTask::TNodeTask(a1 + 3);
  return a1;
}

void sub_1D34CFA70(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<TNodeTask>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB3C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TNodeTask>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB3C8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

uint64_t TPropertyValue::TPropertyValue<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>(uint64_t a1, const void **a2)
{
  *(_DWORD *)(a1 + 16) = 0;
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<16ul,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>> const&>(a1, (CFTypeRef *)a1, a2);
  return a1;
}

void sub_1D34CFB2C(_Unwind_Exception *a1)
{
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::~__dtor(v1);
  _Unwind_Resume(a1);
}

uint64_t TPropertyValue::TPropertyValue<TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>>(uint64_t a1, const void **a2)
{
  *(_DWORD *)(a1 + 16) = 0;
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<14ul,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>> const&>(a1, (CFTypeRef *)a1, a2);
  return a1;
}

void sub_1D34CFB74(_Unwind_Exception *a1)
{
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>,(std::__variant_detail::_Trait)1>::~__dtor(v1);
  _Unwind_Resume(a1);
}

id CopyDeep(NSArray *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = CopyDeepCommon(v1, 0);
    uint64_t v4 = (void *)[objc_alloc(MEMORY[0x1E4F1C978]) initWithArray:v3];
  }
  else
  {
    uint64_t v4 = 0;
  }

  return v4;
}

void sub_1D34CFC08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id CopyDeepCommon(NSArray *a1, BOOL a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  uint64_t v4 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1CA48]), "initWithCapacity:", -[NSArray count](v3, "count"));
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  unint64_t v5 = v3;
  uint64_t v6 = [(NSArray *)v5 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v6)
  {
    uint64_t v7 = *(void *)v12;
    do
    {
      for (uint64_t i = 0; i != v6; ++i)
      {
        if (*(void *)v12 != v7) {
          objc_enumerationMutation(v5);
        }
        uint64_t v9 = CopyDeepHelper(*(NSObject **)(*((void *)&v11 + 1) + 8 * i), a2);
        objc_msgSend(v4, "addObject:", v9, (void)v11);
      }
      uint64_t v6 = [(NSArray *)v5 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }
    while (v6);
  }

  return v4;
}

void sub_1D34CFD84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id MutableCopyDeep(NSArray *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = CopyDeepCommon(v1, 1);
  }
  else
  {
    id v3 = 0;
  }

  return v3;
}

void sub_1D34CFE20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ISignpostInterval::EventPriv(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = *(NSObject **)(a1 + 64);
  BOOL v6 = os_signpost_enabled(v5);
  if (a2 && v6)
  {
    std::function<void ()(NSObject  {objcproto9OS_os_log}*)>::operator()(a3, v5);
  }
}

TString *TGlobalNodes::ComputerName@<X0>(TString *a1@<X8>)
{
  return TString::TString(a1, "Computer", 8uLL);
}

__n128 __copy_helper_block_ea8_32c37_ZTSKZN12TGlobalNodes8BootNodeEvE3__0(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[2];
  a1[2] = result;
  return result;
}

id TGlobalNodes::DataSeparatedICloudLibrariesContainerNode@<X0>(void *a1@<X8>)
{
  if (TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce != -1) {
    dispatch_once(&TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce, &__block_literal_global_5);
  }
  uint64_t v3 = TGlobalNodes::gGlobalNodes;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN12TGlobalNodes41DataSeparatedICloudLibrariesContainerNodeEv_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = TGlobalNodes::gGlobalNodes;
  if (TGlobalNodes::DataSeparatedICloudLibrariesContainerNode(void)::onceToken != -1) {
    dispatch_once(&TGlobalNodes::DataSeparatedICloudLibrariesContainerNode(void)::onceToken, block);
  }
  id result = *(id *)(v3 + 88);
  *a1 = result;
  return result;
}

void ___ZN12TGlobalNodes41DataSeparatedICloudLibrariesContainerNodeEv_block_invoke(uint64_t a1)
{
  TFSVolumeInfo::GetVolumeInfoFor(0x18u, &v9);
  TNodePtr::TNodePtr(&v7, 0);
  uint64_t v2 = *(std::__shared_weak_count **)(v9 + 64);
  uint64_t v5 = *(void *)(v9 + 56);
  BOOL v6 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  TNode::CreateNode((uint64_t)&v7, (uint64_t)&v5, (uint64_t)&v3, (TNodePtr *)&obj);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }

  objc_storeStrong((id *)(*(void *)(a1 + 32) + 88), obj);
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
}

void sub_1D34D0040(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, void *a13)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }

  unint64_t v15 = *(std::__shared_weak_count **)(v13 - 24);
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  }
  _Unwind_Resume(a1);
}

void TGlobalNodes::NetworkNearbyNode(void *a1@<X8>)
{
  std::mutex::lock(&GlobalNodesMutex(void)::globalNodesMutex);
  if (TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce != -1) {
    dispatch_once(&TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce, &__block_literal_global_5);
  }
  uint64_t v3 = (id *)(TGlobalNodes::gGlobalNodes + 56);
  if (!TNodeFromFINode(*(FINode **)(TGlobalNodes::gGlobalNodes + 56)))
  {
    TFSVolumeInfo::GetVolumeInfoFor(&v11, 31);
    TNodePtr::TNodePtr(&v9, 0);
    uint64_t v4 = *(std::__shared_weak_count **)(v11 + 64);
    uint64_t v7 = *(void *)(v11 + 56);
    uint64_t v8 = v4;
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v5 = 0;
    BOOL v6 = 0;
    TNode::CreateNode(&obj, &v9, &v7, &v5);
    if (v6) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v6);
    }
    if (v8) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    }

    objc_storeStrong(v3, obj);
    if (v12) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v12);
    }
  }
  *a1 = *v3;
  std::mutex::unlock(&GlobalNodesMutex(void)::globalNodesMutex);
}

void sub_1D34D0194(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, void *a13)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }

  unint64_t v15 = *(std::__shared_weak_count **)(v13 - 24);
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  }
  std::mutex::unlock(&GlobalNodesMutex(void)::globalNodesMutex);
  _Unwind_Resume(a1);
}

void TGlobalNodes::AirDropNode(void *a1@<X8>)
{
  std::mutex::lock(&GlobalNodesMutex(void)::globalNodesMutex);
  if (TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce != -1) {
    dispatch_once(&TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce, &__block_literal_global_5);
  }
  uint64_t v3 = (id *)(TGlobalNodes::gGlobalNodes + 64);
  if (!TNodeFromFINode(*(FINode **)(TGlobalNodes::gGlobalNodes + 64)))
  {
    TFSVolumeInfo::GetVolumeInfoFor(&v11, 33);
    TNodePtr::TNodePtr(&v9, 0);
    uint64_t v4 = *(std::__shared_weak_count **)(v11 + 64);
    uint64_t v7 = *(void *)(v11 + 56);
    uint64_t v8 = v4;
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v5 = 0;
    BOOL v6 = 0;
    TNode::CreateNode(&obj, &v9, &v7, &v5);
    if (v6) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v6);
    }
    if (v8) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    }

    objc_storeStrong(v3, obj);
    if (v12) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v12);
    }
  }
  *a1 = *v3;
  std::mutex::unlock(&GlobalNodesMutex(void)::globalNodesMutex);
}

void sub_1D34D0300(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, void *a13)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }

  unint64_t v15 = *(std::__shared_weak_count **)(v13 - 24);
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  }
  std::mutex::unlock(&GlobalNodesMutex(void)::globalNodesMutex);
  _Unwind_Resume(a1);
}

void TGlobalNodes::NetworkSidebarNode(void *a1@<X8>)
{
  std::mutex::lock(&GlobalNodesMutex(void)::globalNodesMutex);
  if (TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce != -1) {
    dispatch_once(&TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce, &__block_literal_global_5);
  }
  uint64_t v3 = (id *)(TGlobalNodes::gGlobalNodes + 72);
  if (!TNodeFromFINode(*(FINode **)(TGlobalNodes::gGlobalNodes + 72)))
  {
    TFSVolumeInfo::GetVolumeInfoFor(&v11, 32);
    TNodePtr::TNodePtr(&v9, 0);
    uint64_t v4 = *(std::__shared_weak_count **)(v11 + 64);
    uint64_t v7 = *(void *)(v11 + 56);
    uint64_t v8 = v4;
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v5 = 0;
    BOOL v6 = 0;
    TNode::CreateNode(&obj, &v9, &v7, &v5);
    if (v6) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v6);
    }
    if (v8) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    }

    objc_storeStrong(v3, obj);
    if (v12) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v12);
    }
  }
  *a1 = *v3;
  std::mutex::unlock(&GlobalNodesMutex(void)::globalNodesMutex);
}

void sub_1D34D046C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, void *a13)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }

  unint64_t v15 = *(std::__shared_weak_count **)(v13 - 24);
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  }
  std::mutex::unlock(&GlobalNodesMutex(void)::globalNodesMutex);
  _Unwind_Resume(a1);
}

uint64_t TGlobalNodes::IsNetworkNode(TGlobalNodes *this, FINode **a2, const TNodePtr *a3)
{
  int v4 = (int)this;
  if (TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce != -1) {
    dispatch_once(&TGlobalNodes::GlobalNodes(void)::gGlobalNodesOnce, &__block_literal_global_5);
  }
  uint64_t v5 = TGlobalNodes::gGlobalNodes;
  if (!TGlobalNodes::gGlobalNodes) {
    return 0;
  }
  uint64_t result = TNodeFromFINode(*a2);
  if (!result) {
    return result;
  }
  if (v4 == 1836348013)
  {
    uint64_t v7 = (FINode **)(v5 + 64);
    goto LABEL_12;
  }
  if (v4 == 1853125474)
  {
    uint64_t v7 = (FINode **)(v5 + 72);
    goto LABEL_12;
  }
  if (v4 != 1853126507) {
    return 0;
  }
  uint64_t v7 = (FINode **)(v5 + 56);
LABEL_12:
  uint64_t v8 = TNodeFromFINode(*v7);
  return v8 == TNodeFromFINode(*a2);
}

void TGlobalNodes::FinalizeGlobalNode(FINode **this, const TNodePtr *a2)
{
  uint64_t v3 = (void *)MEMORY[0x1D9436D80](this, a2);
  int v4 = (TNodeEvent *)TNodeFromFINode(*this);
  TNode::UnRegisterForInternalNotifications(v4, this, 3);
  uint64_t v5 = (TNode *)TNodeFromFINode(*this);
  TNode::RemoveAllChildren(v5, 0, 0);
  BOOL v6 = (TNode *)TNodeFromFINode(*this);
  TNode::RemoveSelf(v6, 0);
}

void TGlobalNodes::FinalizeNodes(void *a1)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  std::mutex::lock(&GlobalNodesMutex(void)::globalNodesMutex);
  if (TGlobalNodes::gGlobalNodes)
  {
    uint64_t v2 = v1;
    uint64_t v24 = v2;
    TGlobalNodes::FinalizeNodes(NSObject  {objcproto17OS_dispatch_group}*)::$_3::operator()(&v24, (id *)TGlobalNodes::gGlobalNodes, 3, 0);
    v29.fFINode = (FINode *)*(id *)(TGlobalNodes::gGlobalNodes + 88);
    uint64_t v3 = 0;
    id v30 = *(id *)(TGlobalNodes::gGlobalNodes + 80);
    do
    {
      int v4 = &(&v29.fFINode)[v3];
      if (TNodeFromFINode((&v29.fFINode)[v3]))
      {
        uint64_t v5 = (TNode *)TNodeFromFINode(*v4);
        TNode::UnRegisterForUbiquityAttributes(v5);
        atomic_store(0, (unsigned __int16 *)(TNodeFromFINode(*v4) + 80));
        BOOL v6 = (TNode *)TNodeFromFINode(*v4);
        TNode::GetVolumeInfo(v6, &v21);
        TFSVolumeInfo::GetVolumeSyncThread(v21, &v25);
        uint64_t v7 = NodeEventRefFromNodeEvent((id *)v25);
        if (v26) {
          std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v26);
        }
        if (v22) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v22);
        }
        TGlobalNodes::FinalizeNodes(NSObject  {objcproto17OS_dispatch_group}*)::$_3::operator()(&v24, (id *)&(&v29.fFINode)[v3], 0, v7);
      }
      ++v3;
    }
    while (v3 != 2);
    for (uint64_t i = 1; i != -1; --i)

    v29.fFINode = (FINode *)(TGlobalNodes::gGlobalNodes + 56);
    __int16 v25 = (TFSVolumeInfo **)MEMORY[0x1E4F143A8];
    uint64_t v26 = 3321888768;
    uint64_t v27 = ___ZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__0cvU13block_pointerFvvEEv_block_invoke;
    int v28 = &__block_descriptor_33_ea8_32c83_ZTSKZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectE3__0_e5_v8__0l;
    id v9 = (id)MEMORY[0x1D9436FC0](&v25);
    id v30 = (id)MEMORY[0x1D9436FC0](v9);
    uint64_t v31 = TGlobalNodes::gGlobalNodes + 64;
    __int16 v25 = (TFSVolumeInfo **)MEMORY[0x1E4F143A8];
    uint64_t v26 = 3321888768;
    uint64_t v27 = ___ZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__1cvU13block_pointerFvvEEv_block_invoke;
    int v28 = &__block_descriptor_33_ea8_32c83_ZTSKZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectE3__1_e5_v8__0l;
    id v10 = (id)MEMORY[0x1D9436FC0](&v25);
    uint64_t v32 = MEMORY[0x1D9436FC0](v10);
    uint64_t v33 = TGlobalNodes::gGlobalNodes + 72;
    __int16 v25 = (TFSVolumeInfo **)MEMORY[0x1E4F143A8];
    uint64_t v26 = 3321888768;
    uint64_t v27 = ___ZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__2cvU13block_pointerFvvEEv_block_invoke;
    int v28 = &__block_descriptor_33_ea8_32c83_ZTSKZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectE3__2_e5_v8__0l;
    id v11 = (id)MEMORY[0x1D9436FC0](&v25);
    uint64_t v34 = MEMORY[0x1D9436FC0](v11);
    long long v22 = 0;
    uint64_t v23 = 0;
    long long v21 = 0;
    __int16 v25 = &v21;
    LOBYTE(v26) = 0;
    long long v12 = (char *)operator new(0x30uLL);
    uint64_t v13 = 0;
    long long v21 = (TFSVolumeInfo *)v12;
    long long v22 = (std::__shared_weak_count *)v12;
    uint64_t v23 = v12 + 48;
    do
    {
      uint64_t v14 = *(uint64_t *)((char *)&v29 + v13 + 8);
      *(TNodePtr *)&v12[v13] = *(TNodePtr *)((char *)&v29 + v13);
      *(void *)&v12[v13 + 8] = MEMORY[0x1D9436FC0](v14);
      v13 += 16;
    }
    while (v13 != 48);
    long long v22 = (std::__shared_weak_count *)(v12 + 48);
    for (uint64_t j = 5; j != -1; j -= 2)

    os_signpost_id_t v17 = v21;
    std::mutex v18 = v22;
    while (v17 != (TFSVolumeInfo *)v18)
    {
      __int16 v19 = *(FINode ***)v17;
      uint64_t v16 = (TFSVolumeInfo *)TNodeFromFINode(**(FINode ***)v17);
      if (v16)
      {
        (*(void (**)(void))(*((void *)v17 + 1) + 16))();
        TNodePtr::TNodePtr(&v25, (id *)v19);
        TNodePtr::TNodePtr(&v29, 0);
        TNodePtr::operator=((void **)v19, (void **)&v29.fFINode);

        TGlobalNodes::FinalizeGlobalNode((FINode **)&v25, v20);
      }
      os_signpost_id_t v17 = (TFSVolumeInfo *)((char *)v17 + 16);
    }
    TFSVolumeInfo::GarbageCollect(v16);
    v29.fFINode = (FINode *)&v21;
    std::vector<std::pair<std::reference_wrapper<TNodePtr>,void({block_pointer} {__strong})(void)>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v29);
  }
  std::mutex::unlock(&GlobalNodesMutex(void)::globalNodesMutex);
}

void sub_1D34D09D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char *a20)
{
  a20 = &a11;
  std::vector<std::pair<std::reference_wrapper<TNodePtr>,void({block_pointer} {__strong})(void)>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a20);

  std::mutex::unlock(&GlobalNodesMutex(void)::globalNodesMutex);
  _Unwind_Resume(a1);
}

void TGlobalNodes::FinalizeNodes(NSObject  {objcproto17OS_dispatch_group}*)::$_3::operator()(NSObject **a1, id *a2, int a3, void *a4)
{
  uint64_t v7 = a4;
  if (TNodeFromFINode((FINode *)*a2))
  {
    if (!v7)
    {
      uint64_t v7 = dispatch_get_global_queue(0, 0);
    }
    uint64_t v8 = *a1;
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 3321888768;
    v10[2] = ___ZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__3clERK8TNodePtr24RemoveAllChildrenOptionsPU28objcproto17OS_dispatch_queueS0__block_invoke;
    v10[3] = &__block_descriptor_48_ea8_32c167_ZTSKZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__3clERK8TNodePtr24RemoveAllChildrenOptionsPU28objcproto17OS_dispatch_queueS0_EUlvE__e5_v8__0l;
    id v11 = *a2;
    int v12 = a3;
    id v9 = v11;
    dispatch_group_async(v8, v7, v10);
  }
}

void sub_1D34D0B98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__3clERK8TNodePtr24RemoveAllChildrenOptionsPU28objcproto17OS_dispatch_queueS0__block_invoke(uint64_t a1)
{
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3321888768;
  v5[2] = ___ZZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__3clERK8TNodePtr24RemoveAllChildrenOptionsPU28objcproto17OS_dispatch_queueS0_ENKUlvE_clEv_block_invoke;
  v5[3] = &__block_descriptor_48_ea8_32c180_ZTSKZZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__3clERK8TNodePtr24RemoveAllChildrenOptionsPU28objcproto17OS_dispatch_queueS0_ENKUlvE_clEvEUlvE__e5_v8__0l;
  id v2 = *(id *)(a1 + 32);
  int v3 = *(_DWORD *)(a1 + 40);
  id v4 = v2;
  id v6 = v4;
  int v7 = v3;
  ExceptionSafeBlock(v5);
}

void sub_1D34D0C44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c167_ZTSKZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__3clERK8TNodePtr24RemoveAllChildrenOptionsPU28objcproto17OS_dispatch_queueS0_EUlvE_(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a2 + 32);
  *(void *)(a1 + 32) = result;
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  return result;
}

void __destroy_helper_block_ea8_32c167_ZTSKZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__3clERK8TNodePtr24RemoveAllChildrenOptionsPU28objcproto17OS_dispatch_queueS0_EUlvE_(uint64_t a1)
{
}

void ___ZZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__3clERK8TNodePtr24RemoveAllChildrenOptionsPU28objcproto17OS_dispatch_queueS0_ENKUlvE_clEv_block_invoke(uint64_t a1)
{
  id v2 = (FINode **)(a1 + 32);
  memset(v9, 0, sizeof(v9));
  TNode::StPopulating::StPopulating((TNode::StPopulating *)v8, (const TNodePtr *)(a1 + 32), 0);
  int v3 = (TNode *)TNodeFromFINode(*v2);
  int v4 = TNode::ChildRegistrationCount(v3);
  uint64_t v5 = *(void *)(TNodeFromFINode(*v2) + 56);
  if (v5) {
    id v6 = (void ***)(v5 + 64);
  }
  else {
    id v6 = (void ***)&TNode::GetChildren(void)const::sEmptyList;
  }
  if (v9 != (uint64_t *)v6) {
    std::vector<TNodePtr>::__assign_with_size[abi:ne180100]<TNodePtr*,TNodePtr*>((uint64_t)v9, *v6, v6[1], v6[1] - *v6);
  }
  uint64_t v7 = TNodeFromFINode(*v2);
  TChildrenList::Clear(*(TChildrenList **)(v7 + 56));
  TNode::StPopulating::~StPopulating((TNode::StPopulating *)v8);
  TNode::RemoveChildrenDeep(v9, *(_DWORD *)(a1 + 40), v4 == 0, 0);
  v8[0] = (void **)v9;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](v8);
}

void sub_1D34D0D7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, char a12)
{
  a9 = (void **)&a12;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c180_ZTSKZZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__3clERK8TNodePtr24RemoveAllChildrenOptionsPU28objcproto17OS_dispatch_queueS0_ENKUlvE_clEvEUlvE_(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a2 + 32);
  *(void *)(a1 + 32) = result;
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  return result;
}

void __destroy_helper_block_ea8_32c180_ZTSKZZZN12TGlobalNodes13FinalizeNodesEPU28objcproto17OS_dispatch_group8NSObjectENK3__3clERK8TNodePtr24RemoveAllChildrenOptionsPU28objcproto17OS_dispatch_queueS0_ENKUlvE_clEvEUlvE_(uint64_t a1)
{
}

void std::vector<std::pair<std::reference_wrapper<TNodePtr>,void({block_pointer} {__strong})(void)>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  id v1 = *a1;
  id v2 = (id *)**a1;
  if (v2)
  {
    int v4 = (id *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        id v6 = v4 - 2;

        int v4 = v6;
      }
      while (v6 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__optional_destruct_base<TString,false>::__optional_destruct_base[abi:ne180100]<TString>(uint64_t a1, CFTypeRef *a2)
{
  *(void *)a1 = *a2;
  *a2 = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, &stru_1F2ABD380);
  *(unsigned char *)(a1 + 8) = 1;
  return a1;
}

uint64_t *AppNapNodeSet(void)
{
  {
    qword_1EA6AC278 = 0;
    qword_1EA6AC270 = 0;
    AppNapNodeSet(void)::sAppNappSet = (uint64_t)&qword_1EA6AC270;
  }
  return &AppNapNodeSet(void)::sAppNappSet;
}

uint64_t TNode::FirmlinkParents(TNode *this)
{
  {
    operator new();
  }
  return TNode::FirmlinkParents(void)::map;
}

void sub_1D34D0FC0(_Unwind_Exception *a1)
{
}

void TNode::AddToAppNapCache(TNode *this)
{
  AppNapNodeSet();
  TNodePtr::TNodePtr(&v2, this);
  std::__tree<TNodePtr>::__emplace_unique_key_args<TNodePtr,TNodePtr>((uint64_t **)&AppNapNodeSet(void)::sAppNappSet, &v2.fFINode, (id *)&v2.fFINode);
}

void sub_1D34D102C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

unint64_t TNode::IsVolume(TNode *this)
{
  TNodePtr v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v4 = *((void *)this + 2);
  int v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  uint64_t v5 = (os_unfair_lock_s *)(v4 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  unint64_t v6 = *(unsigned int *)(v4 + 115) | ((unint64_t)*(unsigned __int16 *)(v4 + 119) << 32);
  os_unfair_lock_unlock(v5);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  return (v6 >> 8) & 1;
}

id TNode::CopyInlineProgress(TNode *this)
{
  TNodePtr v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  int v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  v9.fFINode = 0;
  uint64_t v10 = 0;
  int v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  int v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  v17[0] = 0;
  *(void *)((char *)v17 + 7) = 0;
  std::mutex v18 = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  long long v19 = 0u;
  long long v20 = 0u;
  TNodePtr::TNodePtr(&v8, this);
  int Progress = TProgressMap::GetProgress((TProgressMap *)&v8, &v9, v4);

  if (Progress) {
    id ProgressDictionary = TProgressInfo::CreateProgressDictionary((TProgressInfo *)&v9);
  }
  else {
    id ProgressDictionary = 0;
  }

  if (*((void *)&v19 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v19 + 1));
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v18);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  return ProgressDictionary;
}

void sub_1D34D11C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TProgressInfo::~TProgressInfo((TProgressInfo *)va);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  _Unwind_Resume(a1);
}

uint64_t TempProperties(void)
{
  {
    operator new();
  }
  return TempProperties(void)::sTempProperties;
}

void sub_1D34D1280(_Unwind_Exception *a1)
{
}

void TempPropertiesLock(void)
{
  {
    TempPropertiesLock(void)::sTempPropertiesLock = 0;
  }
}

uint64_t TNode::IsVisible(TNode *this)
{
  id v1 = this;
  TNodePtr v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v4 = *((void *)v1 + 2);
  int v3 = (std::__shared_weak_count *)*((void *)v1 + 3);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  int v5 = *(_DWORD *)(v4 + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 100));
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  if ((v5 & 1) == 0) {
    goto LABEL_21;
  }
  uint64_t v7 = (os_unfair_lock_s *)TNode::InfoLock(v6);
  os_unfair_lock_lock(v7);
  TNodePtr v9 = (TFSInfo *)*((void *)v1 + 2);
  TNodePtr v8 = (std::__shared_weak_count *)*((void *)v1 + 3);
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v7);
  int IsRootItem = TFSInfo::IsRootItem(v9);
  char v11 = IsRootItem;
  if (v8)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    if ((v11 & 1) == 0) {
      goto LABEL_21;
    }
  }
  else if (!IsRootItem)
  {
LABEL_21:
    LOBYTE(v1) = v5 & 1;
    return v1 & 1;
  }
  TNode::GetVolumeInfo(v1, &v19);
  uint64_t v13 = v19;
  if (v19)
  {
    int v14 = (os_unfair_lock_s *)TNode::InfoLock(v12);
    os_unfair_lock_lock(v14);
    uint64_t v16 = (TFSInfo *)*((void *)v1 + 2);
    uint64_t v15 = (std::__shared_weak_count *)*((void *)v1 + 3);
    if (v15) {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v14);
    TFSInfo::Name(v16, &v18);
    if (v15) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v15);
    }
    LOBYTE(v1) = !TFSVolumeInfo::IsHiddenFile(v13, &v18);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v18.fString.fRef);
  }
  if (v20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v20);
  }
  if (!v13) {
    goto LABEL_21;
  }
  return v1 & 1;
}

void sub_1D34D1458(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, const void *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(a1);
}

uint64_t TPropertyReference::SetAs<DSBladeRunnerFlags>(uint64_t a1, _DWORD *a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 2:
      if (v2 != 2) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 3:
      if (v2 != 3) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 4:
      if (v2 != 4) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 5:
      if (v2 != 5) {
        goto LABEL_50;
      }
      uint64_t result = 0;
      **(void **)a1 = *a2;
      break;
    case 6:
      if (v2 != 6) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 7:
      if (v2 != 7) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 8:
      if (v2 != 8) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 9:
      if (v2 != 9) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 10:
      if (v2 != 10) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 11:
      if (v2 != 11) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 12:
      if (v2 != 12) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 13:
      if (v2 != 13) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 14:
      if (v2 != 14) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 15:
      if (v2 != 15) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 16:
      if (v2 != 16) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 17:
      if (v2 != 17) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 18:
      if (v2 != 18) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 19:
      if (v2 != 19) {
        goto LABEL_50;
      }
      int v5 = *(void **)a1;
      uint64_t result = TPropertyValue::SetAs<DSBladeRunnerFlags>(v5, a2);
      break;
    case 20:
      if (v2 != 20) {
        goto LABEL_50;
      }
      goto LABEL_47;
    case 21:
      if (v2 != 21) {
        goto LABEL_50;
      }
      goto LABEL_49;
    case 22:
      if (v2 == 22) {
        goto LABEL_47;
      }
      goto LABEL_50;
    case 23:
      if (v2 != 23) {
LABEL_50:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_49:
      uint64_t result = 0;
      **(_DWORD **)a1 = *a2;
      break;
    default:
LABEL_47:
      uint64_t result = 4294959246;
      break;
  }
  return result;
}

void TNode::SetVolumeInfo(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v4);
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 8);
  *(void *)a1 = v6;
  *(void *)(a1 + 8) = v5;
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  os_unfair_lock_unlock(v4);
}

BOOL TNode::SynchingSuspended(TNode *this)
{
  int v2 = (os_unfair_lock_s *)TNode::OperationLockLock(this);
  os_unfair_lock_lock(v2);
  int v3 = (os_unfair_lock_s *)*((void *)this + 5);
  if (v3)
  {
    os_unfair_lock_lock(*((os_unfair_lock_t *)this + 5));
    BOOL v4 = v3[5]._os_unfair_lock_opaque != 0;
    os_unfair_lock_unlock(v3);
  }
  else
  {
    BOOL v4 = 0;
  }
  os_unfair_lock_unlock(v2);
  return v4;
}

uint64_t TNode::SetComputerName(TNode *this, const TString *a2)
{
  BOOL v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  uint64_t v6 = (TFSInfo *)*((void *)this + 2);
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v4);
  SlashesToColons(a2, &v9);
  TFSInfo::Rename(v6, &v9, 0, (uint64_t)&v10);
  uint64_t v7 = v11;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v10.fFINode);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v9.fString.fRef);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  TNodePtr::TNodePtr(&v10, this);
  TNode::SendNotification(this, 2, (id *)&v10.fFINode, 1886282093, 0);

  return v7;
}

void sub_1D34D1854(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void TNode::Finalize(void *a1)
{
  id v2 = a1;
  AppNapNodeSet();
  std::__tree<TNodePtr>::destroy((uint64_t)&AppNapNodeSet(void)::sAppNappSet, (void *)qword_1EA6AC270);
  AppNapNodeSet(void)::sAppNappSet = (uint64_t)&qword_1EA6AC270;
  qword_1EA6AC278 = 0;
  qword_1EA6AC270 = 0;
  TGlobalNodes::FinalizeNodes(v2);
  TNode::FinalizeNWMaps((TNode *)+[FIPresentationNodeMap finalize]);
  TFSInfo::Finalize(v1);
}

void sub_1D34D1910(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void TNode::FinalizeNWMaps(TNode *this)
{
  NWMapSpinlock();
  os_unfair_lock_lock((os_unfair_lock_t)&NWMapSpinlock(void)::sNWMapSpinlock);
  if (gNWSidebarNodeMap)
  {
    uint64_t v1 = std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::~__hash_table(gNWSidebarNodeMap);
    MEMORY[0x1D9436740](v1, 0x10A0C408EF24B1CLL);
  }
  gNWSidebarNodeMap = 0;
  if (gAirDropNodeMap)
  {
    uint64_t v2 = std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::~__hash_table(gAirDropNodeMap);
    MEMORY[0x1D9436740](v2, 0x10A0C408EF24B1CLL);
  }
  gAirDropNodeMap = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)&NWMapSpinlock(void)::sNWMapSpinlock);
}

uint64_t TNode::IsNetworkNode(TNode *this, TGlobalNodes *a2)
{
  TNodePtr::TNodePtr(&v6, this);
  uint64_t IsNetworkNode = TGlobalNodes::IsNetworkNode(a2, &v6.fFINode, v3);

  return IsNetworkNode;
}

void sub_1D34D1A08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void TNode::GetNetworkNode(TNode *this@<X0>, void **a2@<X8>)
{
  *a2 = 0;
  switch(this)
  {
    case 0x6D74726D:
      TGlobalNodes::AirDropNode(&v3);
      break;
    case 0x6E747362:
      TGlobalNodes::NetworkSidebarNode(&v3);
      break;
    case 0x6E74776B:
      TGlobalNodes::NetworkNearbyNode(&v3);
      break;
    default:
      return;
  }
  TNodePtr::operator=(a2, &v3);
}

void sub_1D34D1AAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void TNode::ComputerNameChangedCallback(TNode *this, const __SCDynamicStore *a2, const __CFArray *a3, void *a4)
{
  TGlobalNodes::RootNode((uint64_t *)&v6);
  BOOL v4 = (const TNode *)TNodeFromFINode(v6);
  memset(&v5, 0, sizeof(v5));
  TNode::RequestInternalTask(v4, 1023, &v5, 0);
  TPropertyValue::~TPropertyValue(&v5);
}

void sub_1D34D1B24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void TNode::HandleSyncComputerName(TNode *this)
{
  TGlobalNodes::RootNode((uint64_t *)&v9, (TGlobalNodes *)this);
  TGlobalNodes::ComputerName(&v8);
  uint64_t v1 = TNodeFromFINode(v9);
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v1);
  os_unfair_lock_lock(v2);
  BOOL v4 = *(TFSInfo **)(v1 + 16);
  int v3 = *(std::__shared_weak_count **)(v1 + 24);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  TFSInfo::Name(v4, &v7);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  int v5 = CFEqual(v7.fString.fRef, v8.fString.fRef);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7.fString.fRef);
  if (!v5)
  {
    TNodePtr v6 = (TNode *)TNodeFromFINode(v9);
    TNode::SetComputerName(v6, &v8);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v8.fString.fRef);
}

void sub_1D34D1C08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const void *a11, id a12)
{
  _Unwind_Resume(a1);
}

BOOL TNode::VolumeHasNoVolumeSizes(TNode *this)
{
  TNode::GetVolumeInfo(this, &v3);
  int v1 = *(unsigned __int8 *)(v3 + 115);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return v1 != 0;
}

BOOL TNode::VolumeIsReadOnly(TNode *this)
{
  TNode::GetVolumeInfo(this, &v3);
  int v1 = *(unsigned __int8 *)(v3 + 104);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return v1 != 0;
}

BOOL TNode::VolumeSupportsACLs(TNode *this)
{
  TNode::GetVolumeInfo(this, &v3);
  int v1 = *(unsigned __int8 *)(v3 + 118);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return v1 != 0;
}

__CFURL *TNode::CopyURL(TNode *this)
{
  uint64_t v2 = 0;
  TNode::CopyURL(this, &v2);
  return v2;
}

uint64_t TPropertyValue::TPropertyValue<__CFURL const*>(uint64_t a1, const void **a2)
{
  uint64_t v3 = *a2;
  int v5 = v3;
  if (v3) {
    CFRetain(v3);
  }
  TPropertyValue::TPropertyValue<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>(a1, &v5);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v5);
  return a1;
}

void sub_1D34D1DA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TNode::GetVolume(TNode *this@<X0>, TNodePtr *a2@<X8>)
{
  TGlobalNodes::RootNode((uint64_t *)&v6, (TGlobalNodes *)this);
  uint64_t v5 = TNodeFromFINode(v6);
  TChildrenList::FindDisplayName(*(TChildrenList **)(v5 + 56), (const TString *)this, a2);
}

void sub_1D34D1E08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void TNode::FindFPv2Child(TNode *this@<X0>, FPItem *a2@<X1>, TNodePtr *a3@<X8>)
{
  uint64_t v5 = a2;
  TNodePtr v6 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v5);
  os_unfair_lock_lock(v6);
  uint64_t v8 = *((void *)this + 2);
  TString v7 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v6);
  TString v9 = (os_unfair_lock_s *)(v8 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v8 + 100));
  int v10 = *(_DWORD *)(v8 + 115);
  os_unfair_lock_unlock(v9);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  if (!v5 || (v10 & 0x20) == 0) {
    goto LABEL_22;
  }
  uint64_t v12 = (os_unfair_lock_s *)TNode::InfoLock(v11);
  os_unfair_lock_lock(v12);
  int v14 = (TFSInfo *)*((void *)this + 2);
  uint64_t v13 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v12);
  IsFPuint64_t v2 = TFSInfo::IsFPv2(v14, 1);
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
  if (IsFPv2)
  {
    a3->fFINode = 0;
    TNodePtr::TNodePtr(&v19, this);
    TNode::StPopulating::StPopulating((TNode::StPopulating *)&v20, &v19, 0);

    uint64_t v16 = (TChildrenList *)*((void *)this + 7);
    if (v16)
    {
      TChildrenList::FindByFPItem(v16, v5, &v19);
      TNodePtr::operator=((void **)&a3->fFINode, (void **)&v19.fFINode);
    }
    TNode::StPopulating::~StPopulating((FINode **)&v20);
    if (!TNodeFromFINode(a3->fFINode))
    {
      _ZNSt3__115allocate_sharedB8ne180100I7TFSInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v20);
      if (!TFSInfo::Initialize(v20, v5, 0))
      {
        os_signpost_id_t v17 = v20;
        TString v18 = v21;
        if (v21) {
          atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        TNode::FindOrCreateChild(this, &v17, &v19);
        TNodePtr::operator=((void **)&a3->fFINode, (void **)&v19.fFINode);

        if (v18) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v18);
        }
      }
      if (v21) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v21);
      }
    }
  }
  else
  {
LABEL_22:
    TNodePtr::TNodePtr(a3, 0);
  }
}

void sub_1D34D1FF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (a13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a13);
  }

  _Unwind_Resume(a1);
}

uint64_t TNode::CopyPathToCBuffer(TNode *this, char *a2, CFIndex a3)
{
  TNode::GetPath(this, (uint64_t)&cf);
  uint64_t v5 = v11;
  if (!v11)
  {
    CFStringRef v6 = (const __CFString *)cf;
    if (cf)
    {
      CFTypeRef v7 = CFRetain(cf);
      CFStringRef v6 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v7);
      if (v6)
      {
        CFTypeRef v8 = CFAutorelease(v6);
        CFStringRef v6 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v8);
      }
    }
    if (CFStringGetCString(v6, a2, a3, 0x8000100u)) {
      uint64_t v5 = v11;
    }
    else {
      uint64_t v5 = 4294959236;
    }
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  return v5;
}

void sub_1D34D2110(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void TNode::DisplayName(TNode *this@<X0>, TString *a2@<X8>)
{
  BOOL v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  CFStringRef v6 = (TFSInfo *)*((void *)this + 2);
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v4);
  TFSInfo::DisplayName(v6, a2);
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
}

void sub_1D34D21AC(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL TNode::IsAlias(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  BOOL v4 = (TFSInfo *)*((void *)this + 2);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  BOOL IsAlias = TFSInfo::IsAlias(v4);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  return IsAlias;
}

void sub_1D34D2230(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

TString **StDefer<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_0,(void *)0>::~StDefer(TString **a1)
{
  std::mutex::lock(&TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::gReentranceGuardLock);
  uint64_t v2 = (uint64_t *)std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::find<TString>(&TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::gReentranceGuard, *a1);
  if (v2)
  {
    pthread_t v4 = pthread_self();
    std::__hash_table<_opaque_pthread_t *,std::hash<_opaque_pthread_t *>,std::equal_to<_opaque_pthread_t *>,std::allocator<_opaque_pthread_t *>>::__erase_unique<_opaque_pthread_t *>(v2 + 3, &v4);
    if (!v2[6]) {
      std::__hash_table<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>>>::erase(&TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::gReentranceGuard, v2);
    }
  }
  std::mutex::unlock(&TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::gReentranceGuardLock);
  return a1;
}

void sub_1D34D22D4(void *a1)
{
}

void TNode::RootFPItemForDomainWithTimeout(void *a1@<X0>, double *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  v16[1] = *MEMORY[0x1E4F143B8];
  id v7 = a1;
  CFTypeRef v8 = v7;
  if (v7)
  {
    v16[0] = v7;
    TString v9 = [MEMORY[0x1E4F1C978] arrayWithObjects:v16 count:1];
    std::__function::__value_func<void ()(FPItem *,NSError *)>::__value_func[abi:ne180100]((uint64_t)v13, a3);
    uint64_t v15 = 0;
    int v10 = operator new(0x28uLL);
    void *v10 = &unk_1F2ABACE8;
    std::__function::__value_func<void ()(FPItem *,NSError *)>::__value_func[abi:ne180100]((uint64_t)(v10 + 1), (uint64_t)v13);
    uint64_t v15 = v10;
    TNode::RootFPItemsForDomainsWithTimeout(v9, a2, (uint64_t)v14, (uint64_t)v12);
    std::__function::__value_func<void ()(FPProviderDomain *,FPItem *,NSError *)>::~__value_func[abi:ne180100](v14);
    std::__function::__value_func<void ()(FPItem *,NSError *)>::~__value_func[abi:ne180100](v13);

    uint64_t v11 = v12[0];
    *a4 = *(id *)v12[0];
    a4[1] = *(id *)(v11 + 8);
    v14[0] = (void **)v12;
    std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](v14);
  }
  else
  {
    std::function<void ()(FPItem *,NSError *)>::operator()(a3, 0, 0);
    *a4 = 0;
    a4[1] = 0;
  }
}

void sub_1D34D2444(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void TNode::ClearAliasTarget(TNode *this, int a2)
{
  TNodePtr::TNodePtr(&v4, 0);
  TNode::SetAliasTarget(this, &v4, a2);
}

void sub_1D34D24EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void TNode::SetUnresolvedTarget(TNode *this)
{
  TNode::GetAliasTarget(this, &v15);
  int fRef = v15.fString.fRef;
  uint64_t v3 = TNodeFromFINode((FINode *)v15.fString.fRef);

  if (v3) {
    return;
  }
  *(_WORD *)int v14 = 0;
  v15.fString.int fRef = &stru_1F2ABD380;
  TNodePtr v4 = (TNode *)CFRetain(&stru_1F2ABD380);
  uint64_t v5 = (os_unfair_lock_s *)TNode::InfoLock(v4);
  os_unfair_lock_lock(v5);
  uint64_t v7 = *((void *)this + 2);
  CFStringRef v6 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v5);
  unsigned int v8 = *(unsigned __int8 *)(v7 + 112);
  if (v8 > 0x11)
  {
    if (v8 != 18 && v8 != 35) {
      goto LABEL_12;
    }
  }
  else if (*(unsigned char *)(v7 + 112))
  {
    if (v8 == 7)
    {
      TNode::DisplayName(this, (TString *)&cf);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v15.fString.fRef, &cf);
      CFRetain(&stru_1F2ABD380);
      CFTypeRef v9 = cf;
      if (cf) {
        goto LABEL_13;
      }
      goto LABEL_14;
    }
LABEL_12:
    TNode::DisplayName(this, (TString *)&cf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v15.fString.fRef, &cf);
    CFRetain(&stru_1F2ABD380);
    CFTypeRef v9 = cf;
    if (cf) {
LABEL_13:
    }
      CFRelease(v9);
LABEL_14:
    CFTypeRef cf = &stru_1F2ABD380;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    goto LABEL_15;
  }
  TFSInfo::GetAliasInfoFrom((TFSInfo *)v7, &v14[1], v14, 0, &v15);
LABEL_15:
  int v12 = 0;
  int IsContainer = TNode::AliasIsContainer(this);
  if (v14[0]) {
    int v11 = 1;
  }
  else {
    int v11 = IsContainer;
  }
  if (v11 == 1) {
    LOBYTE(v12) = 1;
  }
  if (v14[1]) {
    BYTE1(v12) = 1;
  }
  TNode::GetUnresolvedNode(&v15, (unsigned __int8 *)&v12, &cf);
  TNode::SetAliasTarget(this, (const TNodePtr *)&cf, 1);

  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
}

void sub_1D34D26B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t TNode::RequestTask(uint64_t a1, int a2, int a3, TPropertyValue *a4, uint64_t *a5, int a6)
{
  int v12 = a2;
  if (a2 == 1)
  {
    uint64_t v13 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
    os_unfair_lock_lock(v13);
    uint64_t v15 = *(void *)(a1 + 16);
    int v14 = *(std::__shared_weak_count **)(a1 + 24);
    if (v14) {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v13);
    uint64_t v16 = (os_unfair_lock_s *)(v15 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v15 + 100));
    int v17 = *(_DWORD *)(v15 + 115);
    os_unfair_lock_unlock(v16);
    if (v14) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v14);
    }
    int v12 = 1;
    if ((v17 & 0x20) != 0)
    {
      if (a3 > 1819240306)
      {
        if (a3 != 1885895027)
        {
          int v18 = 1819240307;
LABEL_12:
          if (a3 != v18) {
            goto LABEL_14;
          }
        }
      }
      else if (a3 != 1667330145)
      {
        int v18 = 1718776688;
        goto LABEL_12;
      }
      int v12 = 102;
    }
  }
LABEL_14:
  TNodePtr v19 = *(FINode **)(*a5 + 24);
  v22.fFINode = v19;
  if (v19) {
    TDSNotifier::AddPtrReference((TDSNotifier *)v19);
  }
  std::allocate_shared[abi:ne180100]<TNodeTask,std::allocator<TNodeTask>,TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>,void>(&v23);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)&v22);
  TNodeRequest::SetTask(*a5, &v23);
  uint64_t v20 = v23;
  TNodePtr::TNodePtr(&v22, (const TNode *)a1);
  TNodeTask::SetRequest(v20, (id *)&v22.fFINode, v12, a3, a4, a6);

  if (a2 == 102) {
    TNode::PostFolderSizingTaskRequest(a1, (uint64_t)&v23, 0);
  }
  else {
    TNode::PostNodeTaskRequest(a1, &v23);
  }
  if (v24) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v24);
  }
  return 4294959222;
}

void sub_1D34D28CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  _Unwind_Resume(a1);
}

void TNode::GetUnresolvedNode(const TString *a1@<X0>, unsigned __int8 *a2@<X1>, void *a3@<X8>)
{
  LOBYTE(v6.fFINode) = 16;
  std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType,TString const&,TCatalogInfo const&,void>((char *)&v6, a1, a2, &v7);
  TNodePtr::TNodePtr(&v6, 0);
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  TNode::CreateNode(a3, &v6, &v7, &v4);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }

  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
}

void sub_1D34D2994(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }

  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(a1);
}

uint64_t TNode::OpenScreenShareSync(uint64_t a1)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  uint64_t v5 = (os_unfair_lock_s *)TNode::InfoLock(v4);
  os_unfair_lock_lock(v5);
  TNodePtr v6 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v6)
  {
    os_unfair_lock_unlock(v5);
    if (!v3) {
      return 4294959224;
    }
    goto LABEL_5;
  }
  atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  os_unfair_lock_unlock(v5);
  std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  if (v3) {
LABEL_5:
  }
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  return 4294959224;
}

void sub_1D34D2A68(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TNode::IsNetworkNeighborhood(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v2);
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  else
  {
    os_unfair_lock_unlock(v2);
  }
  return 0;
}

uint64_t TNode::OpenServerSync(uint64_t a1)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v2);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v2);
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  else
  {
    os_unfair_lock_unlock(v2);
  }
  uint64_t v5 = (os_unfair_lock_s *)TNode::InfoLock(v4);
  os_unfair_lock_lock(v5);
  TNodePtr v6 = *(std::__shared_weak_count **)(a1 + 24);
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v5);
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  else
  {
    os_unfair_lock_unlock(v5);
  }
  return 4294959224;
}

void TNode::CloseNodeBrowserIfNecessary(TNode *this, int a2)
{
  uint64_t NotifierList = TNode::GetNotifierList(this);
  uint64_t v6 = *(void *)(NotifierList + 24);
  uint64_t v5 = *(std::__shared_weak_count **)(NotifierList + 32);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_lock((os_unfair_lock_t)v6);
  int v7 = *(unsigned __int8 *)(v6 + 5);
  os_unfair_lock_unlock((os_unfair_lock_t)v6);
  if (v7)
  {
    CFTypeRef v9 = (os_unfair_lock_s *)TNode::InfoLock(v8);
    os_unfair_lock_lock(v9);
    int v10 = (std::__shared_weak_count *)*((void *)this + 3);
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      os_unfair_lock_unlock(v9);
      std::__shared_weak_count::__release_shared[abi:ne180100](v10);
    }
    else
    {
      os_unfair_lock_unlock(v9);
    }
    uint64_t v16 = 0;
    int v12 = (os_unfair_lock_s *)TNode::InfoLock(v11);
    os_unfair_lock_lock(v12);
    int v14 = (TFSInfo *)*((void *)this + 2);
    uint64_t v13 = (std::__shared_weak_count *)*((void *)this + 3);
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v12);
    v15[0] = TFSInfo::CopySFBrowserRef(v14);
    TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::operator=<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>((const void **)&v16, v15);
    TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(v15);
    if (v13) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v13);
    }
    LOBYTE(v15[0]) = 0;
    TFSInfo::BrowserCloseNode(v16, 0, (BOOL *)v15);
    os_unfair_lock_lock((os_unfair_lock_t)v6);
    *(unsigned char *)(v6 + 5) = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)v6);
    atomic_fetch_and((atomic_ushort *volatile)this + 40, 0xFFF7u);
    atomic_fetch_and((atomic_ushort *volatile)this + 40, 0xFFEFu);
    if (a2)
    {
      memset(v15, 0, sizeof(v15));
      TNode::RemoveAllChildren(this, 0, (TNodeEventPtrs *)v15);
      TNodeEventPtrs::SendNotifications((id **)v15);
      int v17 = v15;
      std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v17);
    }
    else
    {
      TNode::RemoveAllChildren(this, 0, 0);
    }
    TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef((const void **)&v16);
  }
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
}

void sub_1D34D2D28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef((const void **)va);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  _Unwind_Resume(a1);
}

void sub_1D34D2D78()
{
  if (!v0) {
    JUMPOUT(0x1D34D2D70);
  }
  JUMPOUT(0x1D34D2D68);
}

uint64_t ExternalRegistration::IsNetworkOpened(os_unfair_lock_s *this)
{
  os_unfair_lock_lock(this);
  uint64_t v2 = BYTE1(this[1]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(this);
  return v2;
}

const void **TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::operator=<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>(const void **a1, const void **a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *a1;
    if (*a1) {
      CFRelease(v4);
    }
    *a1 = *a2;
    *a2 = 0;
  }
  return a1;
}

BOOL TNode::RemoveAllChildren(TNode *a1, char a2, TNodeEventPtrs *a3)
{
  char v3 = atomic_load((unsigned __int16 *)a1 + 40);
  if ((v3 & 2) != 0) {
    return 0;
  }
  TNodePtr::TNodePtr(&v14, a1);
  TNode::StPopulating::StPopulating((TNode::StPopulating *)v17, &v14, 0);

  int v7 = TNode::ChildRegistrationCount(a1);
  uint64_t v8 = *((void *)a1 + 7);
  if (v8) {
    CFTypeRef v9 = (void ***)(v8 + 64);
  }
  else {
    CFTypeRef v9 = (void ***)&TNode::GetChildren(void)const::sEmptyList;
  }
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  v14.fFINode = 0;
  std::vector<TNodePtr>::__init_with_size[abi:ne180100]<TNodePtr*,TNodePtr*>((char *)&v14, *v9, v9[1], v9[1] - *v9);
  TNode::RemoveChildrenDeep((uint64_t *)&v14, a2, v7 == 0, a3);
  uint64_t v10 = *((void *)a1 + 7);
  if (v10) {
    int v11 = (void *)(v10 + 64);
  }
  else {
    int v11 = &TNode::GetChildren(void)const::sEmptyList;
  }
  BOOL v12 = *v11 == v11[1];
  int v18 = &v14;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v18);
  TNode::StPopulating::~StPopulating(v17);
  return v12;
}

void sub_1D34D2F0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, FINode *);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)va1);
  TNode::StPopulating::~StPopulating((FINode **)va);
  _Unwind_Resume(a1);
}

void TNode::AddNWNode(int a1, uint64_t a2, FINode **a3)
{
  uint64_t v9 = a2;
  NWMapSpinlock();
  os_unfair_lock_lock((os_unfair_lock_t)&NWMapSpinlock(void)::sNWMapSpinlock);
  NWNodeMap = (void *)TNode::GetNWNodeMap(a1);
  if (!std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::find<__SFNode *>(NWNodeMap, &v9))
  {
    TNode::GetNetworkNode((TNode *)0x6E74776B, (void **)&v8);
    uint64_t v6 = TNodeFromFINode(*a3);
    if (v6 != TNodeFromFINode(v8))
    {
      uint64_t v10 = &v9;
      int v7 = (id *)std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::__emplace_unique_key_args<__SFNode *,std::piecewise_construct_t const&,std::tuple<__SFNode * const&>,std::tuple<>>((uint64_t)NWNodeMap, &v9, (uint64_t)&std::piecewise_construct, &v10);
      objc_storeStrong(v7 + 3, *a3);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&NWMapSpinlock(void)::sNWMapSpinlock);
}

void sub_1D34D3018(_Unwind_Exception *a1)
{
}

uint64_t TNode::AddServerToSidebarSync(uint64_t a1)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v2);
  char v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v2);
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  else
  {
    os_unfair_lock_unlock(v2);
  }
  return 4294959224;
}

uint64_t TNode::CopyEnumeratorError(uint64_t a1, void **a2)
{
  int v4 = TNode::VirtualType((TNode *)a1);
  if (v4 != 27 && v4) {
    return 4294959224;
  }
  uint64_t v5 = *(TChildrenList **)(a1 + 56);
  if (!v5) {
    return 4294959224;
  }
  uint64_t v6 = TChildrenList::GetCollectionStatusObserver(v5);
  uint64_t v7 = [v6 fpError];
  uint64_t v8 = *a2;
  *a2 = (void *)v7;

  return 0;
}

void sub_1D34D3114(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void TNode::PostFolderSizingTaskRequest(uint64_t a1, uint64_t a2, int a3)
{
  BOOL IsContextOpen = TNode::IsContextOpen((TNode *)a1);
  if (IsContextOpen)
  {
    uint64_t v7 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsContextOpen);
    os_unfair_lock_lock(v7);
    uint64_t v9 = *(void *)(a1 + 16);
    uint64_t v8 = *(std::__shared_weak_count **)(a1 + 24);
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v7);
    uint64_t v10 = (os_unfair_lock_s *)(v9 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v9 + 100));
    int v11 = *(_DWORD *)(v9 + 115);
    os_unfair_lock_unlock(v10);
    if (v8) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    }
    if ((v11 & 0x20) != 0) {
      goto LABEL_12;
    }
    uint64_t v13 = (os_unfair_lock_s *)TNode::InfoLock(v12);
    os_unfair_lock_lock(v13);
    uint64_t v15 = *(TFSInfo **)(a1 + 16);
    TNodePtr v14 = *(std::__shared_weak_count **)(a1 + 24);
    if (v14) {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v13);
    BOOL IsAlias = TFSInfo::IsAlias(v15);
    if (v14) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v14);
    }
    if (IsAlias)
    {
LABEL_12:
      TNode::GetVolumeInfo((TNode *)a1, &v19);
      if (v19 && ((atomic_fetch_or((atomic_ushort *volatile)(a1 + 80), 0x40u) & 0x40) == 0 || a3))
      {
        TFSVolumeInfo::GetFolderSizingThread(v19, &v17);
        if (v17) {
          TFolderSizingThread::PostFolderSizingTaskRequest((uint64_t)&v17, a2);
        }
        if (v18) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v18);
        }
      }
      if (v20) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v20);
      }
    }
  }
}

void sub_1D34D3268(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

unint64_t TNode::IsSymlink(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v4 = *((void *)this + 2);
  char v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  uint64_t v5 = (os_unfair_lock_s *)(v4 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  unint64_t v6 = *(unsigned int *)(v4 + 115) | ((unint64_t)*(unsigned __int16 *)(v4 + 119) << 32);
  os_unfair_lock_unlock(v5);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  return (v6 >> 6) & 1;
}

void ___ZNK5TNode16AliasIsContainerEv_block_invoke(uint64_t a1)
{
  v1[0] = MEMORY[0x1E4F143A8];
  v1[1] = 3221225472;
  v1[2] = ___ZNK5TNode16AliasIsContainerEv_block_invoke_2;
  v1[3] = &unk_1E698FD98;
  id v2 = *(id *)(a1 + 32);
  ExceptionSafeBlock(v1);
}

void sub_1D34D33A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZNK5TNode16AliasIsContainerEv_block_invoke_2(uint64_t a1)
{
  TNodeFromFINode(*(FINode **)(a1 + 32));
  uint64_t v1 = 0;
  uint64_t v2 = 0;
  TNodeRequest::Make();
}

void sub_1D34D3440(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, TNodeRequest *a12)
{
}

uint64_t TNode::UpdateSizeInfo(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v4 = *((void *)this + 2);
  char v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  uint64_t v5 = (os_unfair_lock_s *)(v4 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  int v6 = *(_DWORD *)(v4 + 115);
  os_unfair_lock_unlock(v5);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  if ((v6 & 0x20) == 0) {
    return 0;
  }
  uint64_t v16 = this;
  uint64_t v9 = (os_unfair_lock_s *)TNode::ParentLock(v7);
  os_unfair_lock_lock(v9);
  TNodePtr::TNodePtr(&v15, *((const TNode **)this + 6));
  os_unfair_lock_unlock(v9);
  uint64_t v14 = 0;
  std::allocate_shared[abi:ne180100]<TFSInfoSizer,std::allocator<TFSInfoSizer>,TNode *,TNodePtr,decltype(nullptr),void>(&v16, (uint64_t)&v15, &v17);

  uint64_t v10 = v17;
  uint64_t v12 = v17;
  uint64_t v13 = v18;
  if (v18) {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  TFSInfoSizer::SizeFolder(v10, (uint64_t)&v12);
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
  uint64_t v8 = *(unsigned int *)(v17 + 64);
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }
  return v8;
}

void sub_1D34D358C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (a15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TNode::UpdatePropertySynchronous(TNode *this, int a2, char a3, int a4)
{
  int v69 = a2;
  v67 = 0;
  uint64_t v68 = 0;
  v66 = (uint64_t *)&v67;
  if (a2 <= 1819240306)
  {
    if (a2 <= 1717793395)
    {
      if (a2 <= 1667851117)
      {
        if (a2 == 1634952036 || a2 == 1634956409) {
          goto LABEL_76;
        }
        int v13 = 1667330145;
LABEL_50:
        if (a2 != v13) {
          goto LABEL_116;
        }
        TNode::RecalculateFreeSpaceAndCapacity(this, 1);
        goto LABEL_127;
      }
      if (a2 <= 1684893816)
      {
        if (a2 == 1667851118) {
          goto LABEL_76;
        }
        int v14 = 1668313715;
        goto LABEL_81;
      }
      if (a2 == 1684893817)
      {
        v45 = (os_unfair_lock_s *)TNode::InfoLock(this);
        os_unfair_lock_lock(v45);
        v46 = (TFSInfo *)*((void *)this + 2);
        uint64_t Property = *((void *)this + 3);
        if (Property) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(Property + 8), 1uLL, memory_order_relaxed);
        }
        os_unfair_lock_unlock(v45);
        uint64_t v47 = TFSInfo::ApplicationDMFPolicy(v46);
        if (v47 != TFSInfo::FetchApplicationDMFPolicy(v46))
        {
          LODWORD(v59) = 1684893817;
          std::__tree<Property>::__emplace_unique_key_args<Property,Property>(&v66, (unsigned int *)&v59, &v59);
        }
        if (!Property) {
          goto LABEL_128;
        }
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)Property);
        goto LABEL_127;
      }
      int v15 = 1684955501;
    }
    else if (a2 > 1752392561)
    {
      if (a2 <= 1802072171)
      {
        if (a2 == 1752392562) {
          goto LABEL_76;
        }
        if (a2 != 1769170540) {
          goto LABEL_116;
        }
        uint64_t v16 = (os_unfair_lock_s *)TNode::InfoLock(this);
        os_unfair_lock_lock(v16);
        uint64_t v18 = *((void *)this + 2);
        uint64_t v17 = (std::__shared_weak_count *)*((void *)this + 3);
        if (v17) {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        os_unfair_lock_unlock(v16);
        TNodePtr v19 = (os_unfair_lock_s *)(v18 + 100);
        os_unfair_lock_lock((os_unfair_lock_t)(v18 + 100));
        int v20 = *(_DWORD *)(v18 + 115);
        os_unfair_lock_unlock(v19);
        if (v17) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v17);
        }
        if ((v20 & 0x40) != 0)
        {
          TNode::GetAliasTarget(this, &v59);
          long long v21 = v59;
          uint64_t v22 = TNodeFromFINode(v59);

          if (!v22)
          {
            v59 = 0;
            v62.fFINode = 0;
            uint64_t Property = TNode::FollowAlias(this, (TNodePtr *)&v59, (TNodeRequest **)&v62, 8);
            if (!Property) {
              std::__tree<Property>::__emplace_unique_key_args<Property,Property>(&v66, (unsigned int *)&v69, &v69);
            }
            uint64_t v23 = v59;
            goto LABEL_63;
          }
        }
        goto LABEL_127;
      }
      if (a2 == 1802072172) {
        goto LABEL_99;
      }
      int v15 = 1818321516;
    }
    else
    {
      if (a2 <= 1718903155)
      {
        if (a2 == 1717793396) {
          goto LABEL_76;
        }
        int v13 = 1718776688;
        goto LABEL_50;
      }
      if (a2 == 1718903156)
      {
        v62.fFINode = 0;
        LODWORD(v60) = 17;
        v59 = (FINode *)&v62;
        uint64_t Property = TNode::GetProperty((uint64_t)this, 1718903156, (uint64_t)&v59, 0);
        TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)&v62.fFINode);
        goto LABEL_128;
      }
      int v15 = 1751480436;
    }
LABEL_75:
    if (a2 != v15) {
      goto LABEL_116;
    }
    goto LABEL_76;
  }
  if (a2 > 1886613603)
  {
    if (a2 <= 1970497393)
    {
      if (a2 <= 1937340017)
      {
        if (a2 == 1886613604) {
          goto LABEL_76;
        }
        int v14 = 1936225906;
        goto LABEL_81;
      }
      if (a2 == 1937340018) {
        goto LABEL_82;
      }
      if (a2 != 1969385844) {
        goto LABEL_116;
      }
LABEL_127:
      uint64_t Property = 0;
      goto LABEL_128;
    }
    if (a2 <= 1970566255)
    {
      if (a2 == 1970497394) {
        goto LABEL_76;
      }
      if (a2 != 1970563428) {
        goto LABEL_116;
      }
LABEL_99:
      v44 = (__CFString **)MEMORY[0x1E4F1D778];
      if (a2 != 1970563428) {
        v44 = (__CFString **)MEMORY[0x1E4F1D720];
      }
      goto LABEL_110;
    }
    if (a2 == 1970566256)
    {
      v44 = (__CFString **)MEMORY[0x1E4F1C538];
LABEL_110:
      v48 = *v44;
      v49 = (os_unfair_lock_s *)TNode::InfoLock(this);
      os_unfair_lock_lock(v49);
      v51 = (TFSInfo *)*((void *)this + 2);
      v50 = (std::__shared_weak_count *)*((void *)this + 3);
      if (v50) {
        atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v49);
      uint64_t Property = TFSInfo::RefreshUTTypeProperty(v51, v48);
      if (v50) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v50);
      }
      if (!Property) {
        goto LABEL_128;
      }
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(&v66, (unsigned int *)&v69, &v69);
      goto LABEL_127;
    }
    int v14 = 1986359923;
LABEL_81:
    if (a2 != v14) {
      goto LABEL_116;
    }
LABEL_82:
    int v28 = (os_unfair_lock_s *)TNode::InfoLock(this);
    os_unfair_lock_lock(v28);
    id v30 = (TFSInfo *)*((void *)this + 2);
    TNodePtr v29 = (std::__shared_weak_count *)*((void *)this + 3);
    if (v29) {
      atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v28);
    TFSInfo::CopyFSInfo(v30, (uint64_t *)&v59);
    if (v29) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v29);
    }
    uint64_t v31 = v59;
    uint64_t v32 = (os_unfair_lock_s *)&v59[12].super.isa + 1;
    os_unfair_lock_lock((os_unfair_lock_t)&v59[12].super.isa + 1);
    int v33 = *(_DWORD *)((char *)&v31[14].super.isa + 3);
    uint64_t v31 = (FINode *)((char *)v31 + 115);
    __int16 v34 = WORD2(v31->super.isa);
    LODWORD(v31->super.isa) = v33 & 0xDFFFFFFF;
    WORD2(v31->super.isa) = v34;
    os_unfair_lock_unlock(v32);
    uint64_t Property = TFSInfo::FetchVersionMetaData((uint64_t)v59);
    uint64_t v35 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)Property);
    os_unfair_lock_lock(v35);
    v37 = (TString **)*((void *)this + 2);
    v36 = (std::__shared_weak_count *)*((void *)this + 3);
    if (v36) {
      atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v35);
    TFSInfo::SynchronizeVersionsForce(v37, (uint64_t *)&v59, &v66);
    if (v36) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v36);
    }
    if (a4) {
      std::__tree<Property>::__emplace_unique_key_args<Property,Property>(&v66, (unsigned int *)&v69, &v69);
    }
    uint64_t v12 = v60;
    if (v60) {
      goto LABEL_93;
    }
    goto LABEL_128;
  }
  if (a2 > 1870098033)
  {
    if (a2 > 1885895026)
    {
      if (a2 == 1885895027) {
        goto LABEL_94;
      }
      int v15 = 1886549619;
    }
    else
    {
      if (a2 == 1870098034) {
        goto LABEL_76;
      }
      int v15 = 1883333732;
    }
    goto LABEL_75;
  }
  if (a2 > 1836016739)
  {
    if (a2 != 1836016740)
    {
      if (a2 != 1869769063) {
        goto LABEL_116;
      }
      v65 = 0;
      LODWORD(v60) = 10;
      v59 = (FINode *)&v65;
      char v64 = 0;
      uint64_t v24 = (os_unfair_lock_s *)TNode::InfoLock(this);
      char v25 = a3 & 0x7D;
      os_unfair_lock_lock(v24);
      uint64_t v27 = *((void *)this + 2);
      uint64_t v26 = (std::__shared_weak_count *)*((void *)this + 3);
      if (v26) {
        atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v24);
      v62.fFINode = 0;
      v63 = 0;
      uint64_t Property = TFSInfo::GetOriginatorInfo(v27, (uint64_t)&v59, (uint64_t)&v62, v25, &v64);
      if (v63) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v63);
      }
      if (v64)
      {
        LODWORD(v62.fFINode) = 1869769063;
        std::__tree<Property>::__emplace_unique_key_args<Property,Property>(&v66, (unsigned int *)&v62, &v62);
      }
      if (v26) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v26);
      }
      uint64_t v23 = v65;
LABEL_63:

      goto LABEL_128;
    }
LABEL_76:
    if (!TNode::LowLevelIsLockFile(this)) {
      TNode::HandleSync((uint64_t)this, 0x10080000u);
    }
    uint64_t Property = 4294959239;
    goto LABEL_128;
  }
  if (a2 == 1819240307)
  {
LABEL_94:
    v38 = (os_unfair_lock_s *)TNode::InfoLock(this);
    os_unfair_lock_lock(v38);
    uint64_t v40 = *((void *)this + 2);
    v39 = (std::__shared_weak_count *)*((void *)this + 3);
    if (v39) {
      atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v38);
    v41 = (os_unfair_lock_s *)(v40 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v40 + 100));
    int v42 = *(_DWORD *)(v40 + 115);
    os_unfair_lock_unlock(v41);
    if ((v42 & 0x2000000) != 0)
    {
      CFIndex IsLockFile = TNode::LowLevelIsLockFile(this);
      char v52 = IsLockFile;
      if (v39) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v39);
      }
      if ((v52 & 1) == 0) {
        CFIndex IsLockFile = TNode::HandleSync((uint64_t)this, 0x10080000u);
      }
    }
    else if (v39)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v39);
    }
    v53 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsLockFile);
    os_unfair_lock_lock(v53);
    uint64_t v55 = *((void *)this + 2);
    v54 = (std::__shared_weak_count *)*((void *)this + 3);
    if (v54) {
      atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v53);
    uint64_t v56 = (os_unfair_lock_s *)(v55 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v55 + 100));
    int v57 = *(_DWORD *)(v55 + 115);
    os_unfair_lock_unlock(v56);
    if (v54) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v54);
    }
    if ((v57 & 0x20) != 0) {
      TNode::UpdateSizeInfo(this);
    }
    goto LABEL_127;
  }
  if (a2 != 1819632756)
  {
LABEL_116:
    uint64_t Property = 4294959245;
    goto LABEL_128;
  }
  v65 = 0;
  LODWORD(v60) = 7;
  v59 = (FINode *)&v65;
  char v64 = 0;
  uint64_t v7 = (os_unfair_lock_s *)TNode::InfoLock(this);
  char v8 = a3 & 0x7D;
  os_unfair_lock_lock(v7);
  uint64_t v10 = *((void *)this + 2);
  uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v7);
  v62.fFINode = 0;
  v63 = 0;
  uint64_t Property = TFSInfo::GetLastUsedDate(v10, (uint64_t)&v59, (uint64_t)&v62, v8, &v64);
  if (v63) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v63);
  }
  if (v64) {
    std::__tree<Property>::__emplace_unique_key_args<Property,Property>(&v66, (unsigned int *)&v69, &v69);
  }
  if (v9)
  {
    uint64_t v12 = v9;
LABEL_93:
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
LABEL_128:
  if (v68)
  {
    v59 = 0;
    v60 = 0;
    uint64_t v61 = 0;
    TNodePtr::TNodePtr(&v62, this);
    TNodeEventPtrs::AddPropertyChanges((TNodeEventPtrs *)&v59, &v62, &v66);

    TNodeEventPtrs::SendNotifications((id **)&v59);
    v62.fFINode = (FINode *)&v59;
    std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v62);
  }
  std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::destroy((uint64_t)&v66, v67);
  return Property;
}

void sub_1D34D3E80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, void *a18)
{
  std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::destroy((uint64_t)&a17, a18);
  _Unwind_Resume(a1);
}

void TNode::RecalculateFreeSpaceAndCapacity(TNode *this, int a2)
{
  TNode::GetVolumeInfo(this, &v4);
  if (v4) {
    TFSVolumeInfo::RecalculateFreeSpaceAndCapacity(v4, a2);
  }
  char v3 = v5;
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
}

void sub_1D34D401C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TNode::SetProperty(uint64_t a1, int a2, const TPropertyReference *a3, __CFString **a4, int a5, uint64_t a6)
{
  uint64_t v9 = *a4;
  if (*a4)
  {
    v42.fString.int fRef = *a4;
    TNodeRequest::AddPtrReference((TNodeRequest *)v9);
    TPropertyValue::TPropertyValue(&v41, a3);
    TNode::RequestTask(a1, 2, a2, &v41, (uint64_t *)&v42, 0);
    TPropertyValue::~TPropertyValue(&v41);
    TRef<TNodeRequest *,TRetainReleasePolicy<TNodeRequest *>>::~TRef((TNodeRequest **)&v42);
    unsigned int v10 = 0;
LABEL_3:
    if (a2 == 1634758244) {
      TNode::AddToAppNapCache((TNode *)a1);
    }
    goto LABEL_28;
  }
  if (a2 <= 1869769062)
  {
    if (a2 == 1718903156 || a2 == 1718904684)
    {
      uint64_t v12 = (os_unfair_lock_s *)TNode::InfoLock(0);
      os_unfair_lock_lock(v12);
      uint64_t v14 = *(void *)(a1 + 16);
      int v13 = *(std::__shared_weak_count **)(a1 + 24);
      if (v13) {
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v12);
      TNode::GetVolumeInfo((TNode *)a1, &v41);
      unsigned int v10 = TFSInfo::SetProperty(v14, a2, (uint64_t)a3, (uint64_t)&v41, 0x10000000);
      if (v41.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer) {
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v41.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer);
      }
      if (!v13) {
        goto LABEL_28;
      }
      int v15 = v13;
      goto LABEL_27;
    }
    goto LABEL_35;
  }
  if (a2 != 1869769063)
  {
    if (a2 != 1886282093) {
      goto LABEL_35;
    }
    uint64_t v16 = (os_unfair_lock_s *)TNode::InfoLock(0);
    os_unfair_lock_lock(v16);
    uint64_t v18 = *(void *)(a1 + 16);
    uint64_t v17 = *(std::__shared_weak_count **)(a1 + 24);
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
      os_unfair_lock_unlock(v16);
      int v19 = *(unsigned __int8 *)(v18 + 112);
      std::__shared_weak_count::__release_shared[abi:ne180100](v17);
      if (!v19) {
        goto LABEL_35;
      }
    }
    else
    {
      os_unfair_lock_unlock(v16);
      if (!*(unsigned char *)(v18 + 112)) {
        goto LABEL_35;
      }
    }
    char v25 = FIDSNodeFromTNode((TNode *)a1);
    objc_opt_class();
    isKindOfClass Class = objc_opt_isKindOfClass();

    if (isKindOfClass)
    {
      v41.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value = 0;
      uint64_t v27 = TPropertyReference::As<__CFString const*>((const void **)a3, (void **)&v41);
      if (v28) {
        return 4294967246;
      }
      v38 = (TString *)v27;
      TNode::GetFSInfo((TNode *)a1, &v41);
      value = (TFSInfo *)v41.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value;
      TString::TString(&v42, v38);
      TFSInfo::SetItemName(value, &v42);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v42.fString.fRef);
      if (v41.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer) {
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v41.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer);
      }
      TNode::GetFSInfo((TNode *)a1, &v41);
      uint64_t v40 = (TFSInfo *)v41.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value;
      TString::TString(&v42, v38);
      TFSInfo::SetDisplayName(v40, &v42);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v42.fString.fRef);
      if (v41.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer) {
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v41.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer);
      }
      return 0;
    }
LABEL_35:
    TNodePtr v29 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v9);
    os_unfair_lock_lock(v29);
    uint64_t v31 = *(void *)(a1 + 16);
    id v30 = *(std::__shared_weak_count **)(a1 + 24);
    if (v30) {
      atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v29);
    TNode::GetVolumeInfo((TNode *)a1, &v41);
    unsigned int v10 = TFSInfo::SetProperty(v31, a2, (uint64_t)a3, (uint64_t)&v41, 0x10000000);
    buffer = v41.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer;
    if (v41.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer) {
      std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v41.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer);
    }
    if (v30) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v30);
    }
    if (a2 != 1768124270 || !a5 || v10) {
      goto LABEL_3;
    }
    int v33 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)buffer);
    os_unfair_lock_lock(v33);
    uint64_t v35 = *(TFSInfo **)(a1 + 16);
    __int16 v34 = *(std::__shared_weak_count **)(a1 + 24);
    if (v34) {
      atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v33);
    BOOL IsBootVolume = TFSInfo::IsBootVolume(v35);
    BOOL v37 = IsBootVolume;
    if (v34)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v34);
      if (!v37) {
        return 0;
      }
    }
    else if (!IsBootVolume)
    {
      return 0;
    }
    TNode::HandleSync(a1, 0x10080000u);
    TNodePtr::TNodePtr((TNodePtr *)&v41, (const TNode *)a1);
    TNode::SendNotification((const TNode *)a1, 2, (id *)&v41, 1768124270, 0);

    return 0;
  }
  long long v21 = (os_unfair_lock_s *)TNode::InfoLock(0);
  os_unfair_lock_lock(v21);
  uint64_t v23 = *(void *)(a1 + 16);
  uint64_t v22 = *(std::__shared_weak_count **)(a1 + 24);
  if (v22) {
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v21);
  TNode::GetVolumeInfo((TNode *)a1, &v41);
  unsigned int v10 = TFSInfo::SetProperty(v23, 0x6F726967u, (uint64_t)a3, (uint64_t)&v41, a6);
  if (v41.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v41.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.buffer);
  }
  if (!v10)
  {
    TNodePtr::TNodePtr((TNodePtr *)&v41, (const TNode *)a1);
    TNode::SendNotification((const TNode *)a1, 2, (id *)&v41, 1869769063, 0);
  }
  if (!v22) {
    goto LABEL_28;
  }
  int v15 = v22;
LABEL_27:
  std::__shared_weak_count::__release_shared[abi:ne180100](v15);
LABEL_28:
  if (v10 == -8057) {
    return 0;
  }
  else {
    return v10;
  }
}

void sub_1D34D447C(_Unwind_Exception *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, ...)
{
  va_start(va, a4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  if (a3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a3);
  }
  _Unwind_Resume(a1);
}

uint64_t TNode::VolumeIs(uint64_t a1, int *a2)
{
  uint64_t v4 = (TNode *)TNode::VirtualType((TNode *)a1);
  switch((int)v4)
  {
    case 23:
    case 24:
    case 25:
      uint64_t v5 = 0;
      int v6 = *a2;
      int v7 = 25;
      goto LABEL_4;
    case 26:
    case 29:
      uint64_t v5 = 0;
      int v8 = *a2 & 0x18;
      goto LABEL_19;
    case 27:
    case 28:
      uint64_t v5 = 0;
      int v6 = *a2;
      int v7 = 9;
LABEL_4:
      int v8 = v6 & v7;
      goto LABEL_19;
    default:
      int v9 = *a2 & 0xB9;
      unsigned int v10 = (os_unfair_lock_s *)TNode::InfoLock(v4);
      os_unfair_lock_lock(v10);
      uint64_t v12 = *(void *)(a1 + 16);
      int v11 = *(std::__shared_weak_count **)(a1 + 24);
      if (v11)
      {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        os_unfair_lock_unlock(v10);
        int v13 = *(unsigned __int8 *)(v12 + 112);
        std::__shared_weak_count::__release_shared[abi:ne180100](v11);
      }
      else
      {
        os_unfair_lock_unlock(v10);
        int v13 = *(unsigned __int8 *)(v12 + 112);
      }
      if (v13) {
        BOOL v15 = v9 == 0;
      }
      else {
        BOOL v15 = 1;
      }
      if (!v15) {
        goto LABEL_18;
      }
      uint64_t v16 = (os_unfair_lock_s *)TNode::InfoLock(v14);
      os_unfair_lock_lock(v16);
      uint64_t v18 = *(void *)(a1 + 16);
      uint64_t v17 = *(std::__shared_weak_count **)(a1 + 24);
      if (v17)
      {
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        os_unfair_lock_unlock(v16);
        int v19 = *(unsigned __int8 *)(v18 + 112);
        std::__shared_weak_count::__release_shared[abi:ne180100](v17);
      }
      else
      {
        os_unfair_lock_unlock(v16);
        int v19 = *(unsigned __int8 *)(v18 + 112);
      }
      if (v19 == 16)
      {
LABEL_18:
        int v8 = 0;
        uint64_t v5 = 4294959224;
LABEL_19:
        *a2 = v8;
        return v5;
      }
      int v22 = *a2;
      if (*a2)
      {
        uint64_t IsLocalVolume = TNode::IsLocalVolume((TNode *)a1);
        int v8 = IsLocalVolume;
        int v22 = *a2;
      }
      else
      {
        int v8 = 0;
      }
      if ((v22 & 2) != 0)
      {
        uint64_t IsLocalVolume = TNode::IsEjectable((TNode *)a1);
        if (IsLocalVolume) {
          v8 |= 2u;
        }
        int v22 = *a2;
        if ((*a2 & 8) == 0)
        {
LABEL_26:
          if ((v22 & 0x10) == 0) {
            goto LABEL_27;
          }
          goto LABEL_36;
        }
      }
      else if ((v22 & 8) == 0)
      {
        goto LABEL_26;
      }
      uint64_t IsLocalVolume = TNode::VolumeHasNoVolumeSizes((TNode *)a1);
      if (IsLocalVolume) {
        v8 |= 8u;
      }
      int v22 = *a2;
      if ((*a2 & 0x10) == 0)
      {
LABEL_27:
        if ((v22 & 0x20) == 0) {
          goto LABEL_28;
        }
        goto LABEL_39;
      }
LABEL_36:
      uint64_t IsLocalVolume = TNode::VolumeIsReadOnly((TNode *)a1);
      if (IsLocalVolume) {
        v8 |= 0x10u;
      }
      int v22 = *a2;
      if ((*a2 & 0x20) == 0)
      {
LABEL_28:
        if ((v22 & 0x400) == 0) {
          goto LABEL_47;
        }
        goto LABEL_42;
      }
LABEL_39:
      uint64_t IsLocalVolume = TNode::VolumeSupportsACLs((TNode *)a1);
      if (IsLocalVolume) {
        v8 |= 0x20u;
      }
      if ((*a2 & 0x400) == 0) {
        goto LABEL_47;
      }
LABEL_42:
      uint64_t v23 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)IsLocalVolume);
      os_unfair_lock_lock(v23);
      char v25 = *(TFSInfo **)(a1 + 16);
      uint64_t v24 = *(std::__shared_weak_count **)(a1 + 24);
      if (v24) {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v23);
      BOOL IsBootVolume = TFSInfo::IsBootVolume(v25);
      BOOL v27 = IsBootVolume;
      if (v24)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v24);
        if (!v27) {
          goto LABEL_47;
        }
        goto LABEL_46;
      }
      if (IsBootVolume) {
LABEL_46:
      }
        v8 |= 0x400u;
LABEL_47:
      TNode::GetVolumeInfo((TNode *)a1, &v32);
      int v28 = v32;
      int v29 = *a2;
      BOOL v30 = (*a2 & 0x3BDB80) != 0 && v32 == 0;
      int v31 = !v30;
      if (v30)
      {
        uint64_t v5 = 0;
        goto LABEL_99;
      }
      if ((v29 & 0x80) != 0 && (*((unsigned char *)v32 + 126) || *((unsigned char *)v32 + 107) && !*((unsigned char *)v32 + 129))) {
        v8 |= 0x80u;
      }
      if ((v29 & 0x100) == 0)
      {
        if ((v29 & 0x200) == 0) {
          goto LABEL_59;
        }
LABEL_65:
        if (!*((unsigned char *)v32 + 117)) {
          v8 |= 0x200u;
        }
        if ((v29 & 0x4000) == 0) {
          goto LABEL_60;
        }
        goto LABEL_68;
      }
      if (!*((unsigned char *)v32 + 114)) {
        v8 |= 0x100u;
      }
      if ((v29 & 0x200) != 0) {
        goto LABEL_65;
      }
LABEL_59:
      if ((v29 & 0x4000) == 0)
      {
LABEL_60:
        uint64_t v5 = 0;
        goto LABEL_73;
      }
LABEL_68:
      if (*((unsigned char *)v32 + 119)) {
        uint64_t v5 = 0;
      }
      else {
        uint64_t v5 = 4294959224;
      }
      if (*((unsigned char *)v32 + 130)) {
        v8 |= 0x4000u;
      }
LABEL_73:
      if ((v29 & 0x200000) != 0)
      {
        if (IsRunningInFinder()) {
          v8 |= 0x200000u;
        }
        int v29 = *a2;
      }
      if ((v29 & 0x400000) != 0 && *((unsigned char *)v28 + 119)) {
        v8 |= 0x400000u;
      }
      if ((v29 & 0x8000) != 0)
      {
        if (TFSVolumeInfo::VolumeSupportsUNIXPermissions(v28)) {
          v8 |= 0x8000u;
        }
        int v29 = *a2;
      }
      if ((v29 & 0x10000) != 0)
      {
        if (TFSVolumeInfo::VolumeSupportsAFPPermissions(v28)) {
          v8 |= 0x10000u;
        }
        int v29 = *a2;
      }
      if ((v29 & 0x20000) != 0)
      {
        if (TFSVolumeInfo::VolumeSupportsIgnoreOwnership(v28)) {
          v8 |= 0x20000u;
        }
        int v29 = *a2;
      }
      if ((v29 & 0x80000) != 0)
      {
        if (TFSVolumeInfo::VolumeShouldShowCapacity(v28)) {
          v8 |= 0x80000u;
        }
        int v29 = *a2;
      }
      if ((v29 & 0x100000) != 0 && TFSVolumeInfo::VolumeAllowPermissionChanges(v28)) {
        v8 |= 0x100000u;
      }
LABEL_99:
      if (v33) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v33);
      }
      if (v31) {
        goto LABEL_19;
      }
      return 4294959224;
  }
}

void sub_1D34D4940(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TNode::IsLocalVolume(TNode *this)
{
  TNode::GetVolumeInfo(this, &v4);
  uint64_t v2 = v4;
  if (v4) {
    BOOL v1 = *(unsigned char *)(v4 + 107) != 0;
  }
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  return (v2 == 0) | v1;
}

uint64_t TNode::IsEjectable(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  char v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  TNode::GetVolumeInfo(this, &v6);
  uint64_t v4 = IsRunningInFinder();
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  return v4;
}

void sub_1D34D4A74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  _Unwind_Resume(exception_object);
}

void TNode::TrashPathForNode(TNode *this@<X0>, unsigned char *a2@<X8>)
{
  TNode::GetVolumeInfo(this, &v18);
  int v4 = *(unsigned __int8 *)(v18 + 122);
  if (!(*(unsigned char *)(v18 + 107) | v4))
  {
    *a2 = 0;
    a2[8] = 0;
    goto LABEL_18;
  }
  int v5 = UseFileProviderFramework() ^ 1;
  if (!v4) {
    LOBYTE(v5) = 1;
  }
  if (v5) {
    goto LABEL_12;
  }
  uint64_t v6 = TNode::GetFIProvider(this);
  if (![v6 supportsSyncingTrash])
  {

LABEL_12:
    TFSVolumeInfo::TrashPath(*(TFSVolumeInfo **)this, 0, (TString *)&theString);
    if (CFStringGetLength(theString))
    {
      std::__optional_destruct_base<TString,false>::__optional_destruct_base[abi:ne180100]<TString>((uint64_t)a2, (CFTypeRef *)&theString);
    }
    else
    {
      *a2 = 0;
      a2[8] = 0;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
    goto LABEL_18;
  }
  int v7 = [v6 rootURL];
  int v8 = [v7 path];
  CFStringRef theString = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)&theString, v8);

  if (CFStringGetLength(theString))
  {
    CFStringRef v9 = theString;
    CFTypeRef cf = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v9);
    if (&stru_1F2ABD380) {
      CFRelease(&stru_1F2ABD380);
    }
    CFTypeRef cf = MutableCopy;
    TString::Append((TString *)&cf, (const __CFString *)(unsigned __int16)TPathName::kPOSIXPathNameSeparator);
    v14.fString.int fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(&v14, (TString *)@".Trash");
    CFStringRef v12 = (const __CFString *)cf;
    v16.fString.int fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    int v13 = CFStringCreateMutableCopy(v10, 0, v12);
    CFRelease(&stru_1F2ABD380);
    v16.fString.int fRef = v13;
    TString::Append(&v16, &v14);
    std::__optional_destruct_base<TString,false>::__optional_destruct_base[abi:ne180100]<TString>((uint64_t)a2, (CFTypeRef *)&v16.fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v16.fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v14.fString.fRef);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  }
  else
  {
    *a2 = 0;
    a2[8] = 0;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);

LABEL_18:
  if (v19) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v19);
  }
}

void sub_1D34D4CD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10, const void *a11, const void *a12, uint64_t a13, std::__shared_weak_count *a14)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a11);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a12);

  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(a1);
}

uint64_t TNode::ChildRegistrationCount(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  char v3 = (unsigned int *)*((void *)this + 9);
  if (v3) {
    uint64_t v4 = atomic_load(v3);
  }
  else {
    uint64_t v4 = 0;
  }
  os_unfair_lock_unlock(v2);
  return v4;
}

uint64_t TNode::UnregisterChangeNotification(uint64_t a1, uint64_t a2, FINode **a3, uint64_t a4)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  StRegistrationLock::StRegistrationLock((StRegistrationLock *)&v56);
  if ((a4 & 0x40) != 0
    && atomic_fetch_add((atomic_uint *volatile)(TNode::GetNotifierList((TNode *)a1) + 16), 0xFFFFFFFF) == 1)
  {
    memset(&buf, 0, sizeof(buf));
    TNode::RequestInternalTask((const TNode *)a1, 1020, &buf, 0);
    TPropertyValue::~TPropertyValue(&buf);
  }
  TNode::FindRegistration((TNode *)a1, a2, a3, &v55);
  if (v55)
  {
    if ((a4 & 2) != 0)
    {
      int v8 = atomic_load((unsigned int *)v55 + 11);
      if (v8 < 1)
      {
        a4 = a4 & 0xFFFFFFFD;
      }
      else
      {
        atomic_fetch_add((atomic_uint *volatile)v55 + 11, 0xFFFFFFFF);
        int add = atomic_fetch_add((atomic_uint *volatile)TNode::GetNotifierList((TNode *)a1), 0xFFFFFFFF);
        unsigned int v10 = add - 1;
        if (add <= 0)
        {
          int v11 = LogObj(5);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          {
            buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__head.__value = 67109120;
            buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.length = v10;
            _os_log_impl(&dword_1D343E000, v11, OS_LOG_TYPE_ERROR, "Incorrect childRegistrations when decrementing: %d", (uint8_t *)&buf, 8u);
          }
        }
        else if (add == 1)
        {
          memset(&buf, 0, sizeof(buf));
          TNode::RequestInternalTask((const TNode *)a1, 1019, &buf, 0);
          TPropertyValue::~TPropertyValue(&buf);
        }
      }
    }
    if ((a4 & 4) != 0)
    {
      --*((_DWORD *)v55 + 12);
      int v12 = atomic_fetch_add((atomic_uint *volatile)(TNode::GetNotifierList((TNode *)a1) + 4), 0xFFFFFFFF);
      unsigned int v13 = v12 - 1;
      if (v12 <= 0)
      {
        uint64_t v23 = LogObj(5);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__head.__value = 67109120;
          buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.length = v13;
          _os_log_impl(&dword_1D343E000, v23, OS_LOG_TYPE_ERROR, "Incorrect deepChildRegistrations when decrementing: %d", (uint8_t *)&buf, 8u);
        }
      }
      else if (v12 == 1)
      {
        TNode::GetPath(a1, 1, (uint64_t)&buf);
        TString::TString(&v54, "", 0);
        fstd::optional_err<TString,int>::value_or<TString>((uint64_t)&buf, (CFTypeRef *)&v54.fString.fRef, (TString *)&v52);
        TSystemNotificationTask::StopObservingDirectory((TString **)&v52, (const TString *)1);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v52);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v54.fString.fRef);
        TNode::GetVolumeInfo((TNode *)a1, &v52);
        TNodePtr::TNodePtr((TNodePtr *)&v54, (const TNode *)a1);
        TString v14 = TFSVolumeInfo::GetSynchingGCDQueue(v52);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 3321888768;
        block[2] = ___ZN5TNode28UnregisterChangeNotificationERKNSt3__110shared_ptrI21TClientChangeNotifierEERK8TNodePtr23NodeNotificationOptions_block_invoke;
        block[3] = &__block_descriptor_40_ea8_32c132_ZTSKZN5TNode28UnregisterChangeNotificationERKNSt3__110shared_ptrI21TClientChangeNotifierEERK8TNodePtr23NodeNotificationOptionsE3__0_e5_v8__0l;
        BOOL v15 = v54.fString.fRef;
        v51 = v15;
        dispatch_async(v14, block);

        uint64_t v17 = (os_unfair_lock_s *)TNode::ParentLock(v16);
        os_unfair_lock_lock(v17);
        TNodePtr::TNodePtr(&v49, *(const TNode **)(a1 + 48));
        os_unfair_lock_unlock(v17);
        uint64_t v18 = (TNode *)TNodeFromFINode(v49.fFINode);
        if (v18)
        {
          int v19 = (os_unfair_lock_s *)TNode::ParentLock(v18);
          os_unfair_lock_lock(v19);
          TNodePtr::TNodePtr((TNodePtr *)&v48, *(const TNode **)(a1 + 48));
          os_unfair_lock_unlock(v19);
          int v20 = (TNode *)TNodeFromFINode(v48);
          signed int v21 = atomic_load((unsigned int *)(TNode::GetNotifierList(v20) + 4));
          LODWORD(v19) = v21 > 0;

          if (!v19) {
            goto LABEL_48;
          }
        }
        else
        {
        }
        BOOL v37 = (os_unfair_lock_s *)TNode::InfoLock(v22);
        os_unfair_lock_lock(v37);
        uint64_t v39 = *(void *)(a1 + 16);
        v38 = *(std::__shared_weak_count **)(a1 + 24);
        if (v38)
        {
          atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
          os_unfair_lock_unlock(v37);
          uint64_t v40 = (os_unfair_lock_s *)(v39 + 100);
          os_unfair_lock_lock((os_unfair_lock_t)(v39 + 100));
          int v42 = *(_DWORD *)(v39 + 115);
          uint64_t v41 = v39 + 115;
          __int16 v43 = *(_WORD *)(v41 + 4);
          *(_DWORD *)uint64_t v41 = v42 & 0xF7FFFFFF;
          *(_WORD *)(v41 + 4) = v43;
          os_unfair_lock_unlock(v40);
          std::__shared_weak_count::__release_shared[abi:ne180100](v38);
        }
        else
        {
          os_unfair_lock_unlock(v37);
          v44 = (os_unfair_lock_s *)(v39 + 100);
          os_unfair_lock_lock((os_unfair_lock_t)(v39 + 100));
          int v46 = *(_DWORD *)(v39 + 115);
          uint64_t v45 = v39 + 115;
          __int16 v47 = *(_WORD *)(v45 + 4);
          *(_DWORD *)uint64_t v45 = v46 & 0xF7FFFFFF;
          *(_WORD *)(v45 + 4) = v47;
          os_unfair_lock_unlock(v44);
        }
LABEL_48:

        if (v53) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v53);
        }
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&buf);
        if ((a4 & 8) == 0) {
          goto LABEL_29;
        }
        goto LABEL_24;
      }
    }
    if ((a4 & 8) == 0)
    {
LABEL_29:
      if ((a4 & 0x10) != 0)
      {
        --*((_DWORD *)v55 + 14);
        int v26 = atomic_fetch_add((atomic_uint *volatile)(TNode::GetNotifierList((TNode *)a1) + 12), 0xFFFFFFFF);
        unsigned int v27 = v26 - 1;
        if (v26 <= 0)
        {
          int v28 = LogObj(4);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          {
            buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__head.__value = 67109120;
            buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.length = v27;
            _os_log_impl(&dword_1D343E000, v28, OS_LOG_TYPE_ERROR, "Incorrect ubiquityRegistrations when decrementing: %d", (uint8_t *)&buf, 8u);
          }
        }
        else if (v26 == 1)
        {
          TNode::SetShouldSyncUbiquityAttributes((TNode *)a1, 0);
        }
      }
      int v29 = v55;
      if (a4)
      {
        BOOL v30 = (FINode *)*((id *)v55 + 2);
        uint64_t v31 = TNodeFromFINode(v30);
        uint64_t v32 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v31);
        os_unfair_lock_lock(v32);
        TNodePtr::TNodePtr((TNodePtr *)&buf, *(const TNode **)(v31 + 48));
        os_unfair_lock_unlock(v32);

        if (TNodeFromFINode((FINode *)buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value))
        {
          int v33 = *(TChildrenList **)(TNodeFromFINode((FINode *)buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value)
                                  + 56);
          if (v33) {
            TChildrenList::DecrementRegisteredChildrenCount(v33);
          }
        }

        int v29 = v55;
      }
      BOOL v34 = TDSNotifier::DecrementRegistrationCountForOptions((uint64_t)v29, a4);
      TNodePtr::TNodePtr((TNodePtr *)&buf, (const TNode *)a1);

      if (v34)
      {
        uint64_t NotifierList = TNode::GetNotifierList((TNode *)a1);
        TNotifierList::RemoveNotifier(NotifierList, &v55);
      }
      goto LABEL_43;
    }
LABEL_24:
    int v24 = atomic_fetch_add((atomic_uint *volatile)(TNode::GetNotifierList((TNode *)a1) + 8), 0xFFFFFFFF);
    if (v24 <= 0)
    {
      char v25 = LogObj(5);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__head.__value = 67109120;
        buf.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__tail.__head.__value.length = v24 - 1;
        _os_log_impl(&dword_1D343E000, v25, OS_LOG_TYPE_ERROR, "Incorrect spotlightRegistrations when decrementing: %d", (uint8_t *)&buf, 8u);
      }
    }
    --*((_DWORD *)v55 + 13);
    atomic_load((unsigned int *)(TNode::GetNotifierList((TNode *)a1) + 8));
    goto LABEL_29;
  }
LABEL_43:
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v55);
  StRegistrationLock::~StRegistrationLock((StRegistrationLock *)&v56);
  return 0;
}

void sub_1D34D5428(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, char a16, std::__shared_weak_count *a17, void *a18, TDSNotifier *a19)
{
  os_unfair_lock_unlock(v19);

  if (a17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a17);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(v20 - 80));
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&a19);
  StRegistrationLock::~StRegistrationLock((StRegistrationLock *)(v20 - 81));
  _Unwind_Resume(a1);
}

void fstd::optional_err<TString,int>::value_or<TString>(uint64_t a1@<X0>, CFTypeRef *a2@<X1>, TString *a3@<X8>)
{
  if (*(_DWORD *)(a1 + 8))
  {
    a3->fString.int fRef = (__CFString *)*a2;
    *a2 = 0;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(a2, &stru_1F2ABD380);
  }
  else
  {
    a3->fString.int fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(a3, *(TString **)a1);
  }
}

void sub_1D34D55CC(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void ___ZN5TNode28UnregisterChangeNotificationERKNSt3__110shared_ptrI21TClientChangeNotifierEERK8TNodePtr23NodeNotificationOptions_block_invoke(uint64_t a1)
{
  v1[0] = MEMORY[0x1E4F143A8];
  v1[1] = 3321888768;
  v1[2] = ___ZZN5TNode28UnregisterChangeNotificationERKNSt3__110shared_ptrI21TClientChangeNotifierEERK8TNodePtr23NodeNotificationOptionsENK3__0clEv_block_invoke;
  v1[3] = &__block_descriptor_40_ea8_32c13_ZTS8TNodePtr_e5_v8__0l;
  id v2 = *(id *)(a1 + 32);
  ExceptionSafeBlock(v1);
}

void sub_1D34D5668(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c132_ZTSKZN5TNode28UnregisterChangeNotificationERKNSt3__110shared_ptrI21TClientChangeNotifierEERK8TNodePtr23NodeNotificationOptionsE3__0(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a2 + 32);
  *(void *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c132_ZTSKZN5TNode28UnregisterChangeNotificationERKNSt3__110shared_ptrI21TClientChangeNotifierEERK8TNodePtr23NodeNotificationOptionsE3__0(uint64_t a1)
{
}

void TNode::SetShouldSyncUbiquityAttributes(TNode *this, int a2)
{
  uint64_t v4 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v4);
  uint64_t v6 = *((void *)this + 2);
  int v5 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v4);
    int v7 = *(unsigned __int8 *)(v6 + 112);
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
    if (v7) {
      return;
    }
  }
  else
  {
    os_unfair_lock_unlock(v4);
    if (*(unsigned char *)(v6 + 112)) {
      return;
    }
  }
  unsigned __int16 v8 = atomic_load((unsigned __int16 *)this + 40);
  if (a2 != (unsigned __int16)(v8 & 0x400) >> 10)
  {
    CFStringRef v9 = (atomic_ushort *)((char *)this + 80);
    if (a2) {
      atomic_fetch_or(v9, 0x400u);
    }
    else {
      atomic_fetch_and(v9, 0xFBFFu);
    }
    {
      {
        TNode::SetShouldSyncUbiquityAttributes(BOOL)::sBladeRunnerRegistration = (uint64_t)dispatch_queue_create("iCloudRegistration", 0);
      }
    }
    TNodePtr::TNodePtr(&v15, this);
    unsigned int v10 = TNode::SetShouldSyncUbiquityAttributes(BOOL)::sBladeRunnerRegistration;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3321888768;
    block[2] = ___ZN5TNode31SetShouldSyncUbiquityAttributesEb_block_invoke;
    block[3] = &__block_descriptor_48_ea8_32c53_ZTSKZN5TNode31SetShouldSyncUbiquityAttributesEbE3__0_e5_v8__0l;
    unsigned int v13 = v15.fFINode;
    char v14 = a2;
    int v11 = v13;
    dispatch_async(v10, block);
  }
}

void TNotifierList::RemoveNotifier(uint64_t a1, TDSNotifier **a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 64);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  uint64_t v6 = *(TDSNotifier ***)(a1 + 40);
  int v5 = *(TDSNotifier ***)(a1 + 48);
  if (v6 != v5)
  {
    while (*v6 != *a2)
    {
      if (++v6 == v5)
      {
        uint64_t v6 = *(TDSNotifier ***)(a1 + 48);
        break;
      }
    }
  }
  if (v6 != v5)
  {
    if (v6 + 1 == v5)
    {
      int v7 = v6;
    }
    else
    {
      int v7 = v6;
      do
      {
        TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::operator=<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>(v6, v6 + 1);
        ++v7;
        unsigned __int16 v8 = v6 + 2;
        ++v6;
      }
      while (v8 != v5);
      int v5 = *(TDSNotifier ***)(a1 + 48);
    }
    while (v5 != v7)
      TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(--v5);
    *(void *)(a1 + 48) = v7;
  }
  os_unfair_lock_unlock(v4);
}

BOOL RemovePrefix(const TString *a1, TString *this)
{
  BOOL v4 = TString::BeginsWith(this, a1);
  if (v4)
  {
    CFIndex Length = CFStringGetLength(a1->fString.fRef);
    TString::SubStringFrom(this, Length, (TString *)&cf);
    if (&cf != (CFTypeRef *)this)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&this->fString.fRef, &cf);
      CFRetain(&stru_1F2ABD380);
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef cf = &stru_1F2ABD380;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  }
  return v4;
}

void *TNode::RecursiveChildrenAndSelf@<X0>(TNode *this@<X0>, char a2@<W1>, void *a3@<X8>)
{
  v8[4] = *MEMORY[0x1E4F143B8];
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  uint64_t v6 = operator new(0x20uLL);
  *(void *)uint64_t v6 = &unk_1F2ABAD40;
  v6[8] = a2;
  *((void *)v6 + 2) = a3;
  *((void *)v6 + 3) = v8;
  void v8[3] = v6;
  std::function<void ()(TNode const*)>::operator()((uint64_t)v8, (uint64_t)this);
  return std::__function::__value_func<void ()(TNode const*)>::~__value_func[abi:ne180100](v8);
}

void sub_1D34D5A78(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(TNode const*)>::~__value_func[abi:ne180100]((void ***)va);
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t std::function<void ()(TNode const*)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v4);
}

void TNode::RecursiveSyncOfObserveNodes(TNode *this)
{
  TNode::RecursiveChildrenAndSelf(this, 1, v5);
  BOOL v1 = (id *)v5[0];
  uint64_t v2 = (id *)v5[1];
  while (v1 != v2)
  {
    char v3 = (FINode *)*v1;
    uint64_t v4 = (const TNode *)TNodeFromFINode(v3);
    TNode::RequestSynchronize(v4, 0x1000000);

    ++v1;
  }
  uint64_t v6 = (void **)v5;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&v6);
}

void sub_1D34D5B6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

BOOL TNode::FSNotificationsSupported(TNode *this)
{
  TNode::GetVolumeInfo(this, &v3);
  BOOL v1 = !v3[107] && v3[126] || v3[129] != 0;
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return TNode::gKQueueRegistrationCount < 128 && v1;
}

void TNode::SubscribeForFSNotification(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v4 = *((void *)this + 2);
  char v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  int v5 = (os_unfair_lock_s *)(v4 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  int v6 = *(_DWORD *)(v4 + 115);
  os_unfair_lock_unlock(v5);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  if ((v6 & 0x20) != 0)
  {
    int v7 = (TChildrenList *)*((void *)this + 7);
    TChildrenList::SubscribeWithKQueue(v7);
  }
}

id TNode::FPItemsCollection(TNode *this, FPItem *a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  char v3 = a2;
  int v4 = TNode::VirtualType(this);
  if (v4 == 27)
  {
    int v5 = TNode::GetFIProvider(this);
    int v6 = [v5 domain];

    if (v6)
    {
      int v7 = FPItemManagerInstance();
      unsigned __int16 v8 = [v7 rootCollectionForProviderDomain:v6];
    }
    else
    {
      unsigned __int16 v8 = 0;
    }

    goto LABEL_27;
  }
  CFStringRef v9 = FPItemManagerInstance();
  char v10 = objc_opt_respondsToSelector();

  if ((v10 & 1) == 0) {
    goto LABEL_26;
  }
  int v12 = (os_unfair_lock_s *)TNode::InfoLock(v11);
  os_unfair_lock_lock(v12);
  char v14 = (TFSInfo *)*((void *)this + 2);
  unsigned int v13 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v12);
  TFSInfo::Name(v14, (TString *)buf);
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
  uint64_t v15 = operator==((void **)buf, @".Trash");
  if ((v15 & 1) == 0)
  {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);
    goto LABEL_26;
  }
  TString v16 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v15);
  os_unfair_lock_lock(v16);
  TNodePtr::TNodePtr(&v37, *((const TNode **)this + 6));
  os_unfair_lock_unlock(v16);
  LOBYTE(v16) = TNodeFromFINode(v37.fFINode) == 0;

  uint64_t v17 = TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);
  if (v16)
  {
LABEL_26:
    unsigned __int16 v8 = 0;
    goto LABEL_27;
  }
  uint64_t v18 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v17);
  os_unfair_lock_lock(v18);
  TNodePtr::TNodePtr((TNodePtr *)buf, *((const TNode **)this + 6));
  os_unfair_lock_unlock(v18);
  uint64_t v19 = TNodeFromFINode(*(FINode **)buf);
  uint64_t v20 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v19);
  os_unfair_lock_lock(v20);
  int v22 = *(TFSInfo **)(v19 + 16);
  signed int v21 = *(std::__shared_weak_count **)(v19 + 24);
  if (v21) {
    atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v20);
  uint64_t v23 = TFSInfo::GetFPItem(v22);
  if (v21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v21);
  }

  if (v23
    && ([v23 itemIdentifier],
        int v24 = objc_claimAutoreleasedReturnValue(),
        NS_FileProviderRootContainerItemIdentifier(),
        char v25 = objc_claimAutoreleasedReturnValue(),
        int v26 = [v24 isEqualToString:v25],
        v25,
        v24,
        v26))
  {
    CFURLRef v27 = [v23 fileURL];
    int v28 = FIProviderDomainForURL(v27);
    int v29 = [v28 domain];

    if (!v29
      || (FPItemManagerInstance(),
          BOOL v30 = objc_claimAutoreleasedReturnValue(),
          [v30 trashCollectionForProviderDomain:v29],
          unsigned __int16 v8 = objc_claimAutoreleasedReturnValue(),
          v30,
          !v8))
    {
      uint64_t v31 = LogObj(4);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v32 = [v23 fileURL];
        int v33 = SanitizedURL(v32);
        *(_DWORD *)TPropertyValue buf = 138543362;
        *(void *)&uint8_t buf[4] = v33;
        _os_log_impl(&dword_1D343E000, v31, OS_LOG_TYPE_DEFAULT, "Could not create trash collection for %{public}@", buf, 0xCu);
      }
      unsigned __int16 v8 = 0;
    }
  }
  else
  {
    unsigned __int16 v8 = 0;
  }

LABEL_27:
  if (v3 && !v8)
  {
    BOOL v34 = FPItemManagerInstance();
    unsigned __int16 v8 = [v34 collectionForFolderItem:v3];
  }
  [v8 setShowHiddenFiles:1];
  if (!v8)
  {
    uint64_t v35 = LogObj(4);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)TPropertyValue buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v4;
      *(_WORD *)&uint8_t buf[8] = 2114;
      *(void *)&buf[10] = v3;
      _os_log_impl(&dword_1D343E000, v35, OS_LOG_TYPE_DEFAULT, "Could not create collection for %d (%{public}@)", buf, 0x12u);
    }
  }
  return v8;
}

void sub_1D34D6094(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TNode::SetInitialPopulationDeferred(TNode *this)
{
  return (atomic_fetch_or((atomic_ushort *volatile)this + 40, 0x20u) >> 5) & 1;
}

CFIndex ___ZN5TNode22DoExternalRegistrationERK4TRefIP11TDSNotifier20TRetainReleasePolicyIS2_EEb_block_invoke(uint64_t a1)
{
  CFIndex result = TNodeFromFINode(*(FINode **)(a1 + 32));
  if ((atomic_fetch_and((atomic_ushort *volatile)(result + 80), 0xFFDFu) & 0x20) != 0)
  {
    uint64_t v3 = TNodeFromFINode(*(FINode **)(a1 + 32));
    return TNode::HandleSync(v3, 0x1400000u);
  }
  return result;
}

id __copy_helper_block_ea8_32c94_ZTSKZN5TNode22DoExternalRegistrationERK4TRefIP11TDSNotifier20TRetainReleasePolicyIS2_EEbE3__0(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a2 + 32);
  *(void *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c94_ZTSKZN5TNode22DoExternalRegistrationERK4TRefIP11TDSNotifier20TRetainReleasePolicyIS2_EEbE3__0(uint64_t a1)
{
}

uint64_t TNode::ClearInitialPopulationDeferred(TNode *this)
{
  return (atomic_fetch_and((atomic_ushort *volatile)this + 40, 0xFFDFu) >> 5) & 1;
}

const void **TNode::ExternalUnRegistrationProper(uint64_t a1, int a2, uint64_t a3)
{
  int v6 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v6);
  unsigned __int16 v8 = *(TFSInfo **)(a1 + 16);
  int v7 = *(std::__shared_weak_count **)(a1 + 24);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v6);
  CFStringRef v9 = TFSInfo::CopySFBrowserRef(v8);
  char v14 = v9;
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  if (v9)
  {
    TNode::CloseNodeBrowserIfNecessary((TNode *)a1, 1);
    int v11 = (os_unfair_lock_s *)TNode::InfoLock(v10);
    os_unfair_lock_lock(v11);
    int v12 = *(std::__shared_weak_count **)(a1 + 24);
    if (v12)
    {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      os_unfair_lock_unlock(v11);
      std::__shared_weak_count::__release_shared[abi:ne180100](v12);
    }
    else
    {
      os_unfair_lock_unlock(v11);
    }
    TNode::RemoveNWNode(a2, a3);
  }
  return TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef(&v14);
}

void sub_1D34D638C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TNode::RemoveNWNode(int a1, uint64_t a2)
{
  uint64_t v5 = a2;
  NWMapSpinlock();
  os_unfair_lock_lock((os_unfair_lock_t)&NWMapSpinlock(void)::sNWMapSpinlock);
  NWNodeMap = (void *)TNode::GetNWNodeMap(a1);
  int v4 = std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::find<__SFNode *>(NWNodeMap, &v5);
  if (v4) {
    std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::erase(NWNodeMap, v4);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&NWMapSpinlock(void)::sNWMapSpinlock);
}

void sub_1D34D6424(_Unwind_Exception *a1)
{
}

void TNode::DoExternalUnRegistration(TNode *this)
{
  uint64_t NotifierList = TNode::GetNotifierList(this);
  uint64_t v4 = *(void *)(NotifierList + 24);
  uint64_t v3 = *(std::__shared_weak_count **)(NotifierList + 32);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_lock((os_unfair_lock_t)v4);
  int v5 = *(unsigned __int8 *)(v4 + 4);
  os_unfair_lock_unlock((os_unfair_lock_t)v4);
  if (v5)
  {
    TNode::UnsubscribeForFSNotification(this);
    os_unfair_lock_lock((os_unfair_lock_t)v4);
    *(unsigned char *)(v4 + 4) = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)v4);
  }
  int v6 = TNode::VirtualType(this);
  os_unfair_lock_lock((os_unfair_lock_t)v4);
  int v7 = *(unsigned __int8 *)(v4 + 5);
  os_unfair_lock_unlock((os_unfair_lock_t)v4);
  if (v7)
  {
    v30.fFINode = 0;
    if (TNode::IsNetworkNode(this, (TGlobalNodes *)0x6E747362))
    {
      TGlobalNodes::NetworkSidebarNode(&v29);

      CFStringRef v9 = (FINode *)TFSInfo::CopyNetworkSidebarBrowserRef(v8);
    }
    else if (TNode::IsNetworkNode(this, (TGlobalNodes *)0x6E74776B))
    {
      TGlobalNodes::NetworkNearbyNode(&v28);

      CFStringRef v9 = (FINode *)TFSInfo::CopyNetworkNearbyBrowserRef(v12);
    }
    else
    {
      uint64_t IsNetworkNode = (TNode *)TNode::IsNetworkNode(this, (TGlobalNodes *)0x6D74726D);
      if (!IsNetworkNode)
      {
        uint64_t v18 = (os_unfair_lock_s *)TNode::InfoLock(IsNetworkNode);
        os_unfair_lock_lock(v18);
        uint64_t v19 = (std::__shared_weak_count *)*((void *)this + 3);
        if (v19)
        {
          atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
          os_unfair_lock_unlock(v18);
          std::__shared_weak_count::__release_shared[abi:ne180100](v19);
        }
        else
        {
          os_unfair_lock_unlock(v18);
        }
        IsNetworkNeighborhood = (TNode *)TNode::IsNetworkNeighborhood(this);
        if (IsNetworkNeighborhood)
        {
          signed int v21 = (os_unfair_lock_s *)TNode::InfoLock(IsNetworkNeighborhood);
          os_unfair_lock_lock(v21);
          uint64_t v23 = (TFSInfo *)*((void *)this + 2);
          int v22 = (std::__shared_weak_count *)*((void *)this + 3);
          if (v22) {
            atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          os_unfair_lock_unlock(v21);
          int v24 = (FINode *)TFSInfo::CopySFBrowserRef(v23);
          v30.fFINode = v24;
          if (v22) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v22);
          }
          char v25 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v24);
          os_unfair_lock_lock(v25);
          int v26 = (std::__shared_weak_count *)*((void *)this + 3);
          if (v26)
          {
            atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
            os_unfair_lock_unlock(v25);
            std::__shared_weak_count::__release_shared[abi:ne180100](v26);
          }
          else
          {
            os_unfair_lock_unlock(v25);
          }
        }
        uint64_t RootNode = 0;
        goto LABEL_21;
      }
      TGlobalNodes::AirDropNode(&v27);

      CFStringRef v9 = (FINode *)TFSInfo::CopyAirDropBrowserRef(v14);
    }
    v30.fFINode = v9;
    if (!v9)
    {
LABEL_23:
      TAutoRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TAutoRef((const void **)&v30.fFINode);
LABEL_24:
      if (!v3) {
        return;
      }
      goto LABEL_25;
    }
    uint64_t RootNode = SFBrowserGetRootNode();
LABEL_21:
    if (v30.fFINode)
    {
      int v16 = TNode::VirtualType(this);
      TNode::ExternalUnRegistrationProper((uint64_t)this, v16, RootNode);
    }
    goto LABEL_23;
  }
  if (v6 == 26)
  {
    os_unfair_lock_lock((os_unfair_lock_t)v4);
    id v10 = *(id *)(v4 + 8);
    os_unfair_lock_unlock((os_unfair_lock_t)v4);
    if (v10)
    {
      [v10 stopObserving];
      os_unfair_lock_lock((os_unfair_lock_t)v4);
      int v11 = *(void **)(v4 + 8);
      *(void *)(v4 + 8) = 0;

      os_unfair_lock_unlock((os_unfair_lock_t)v4);
    }

    if (!v3) {
      return;
    }
LABEL_25:
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    return;
  }
  if (TNode::IsFPv2(this, 1))
  {
    TChildrenList::StopCollectionStatusObserver(*((TChildrenList **)this + 7));
    goto LABEL_24;
  }
  TNodePtr::TNodePtr(&v30, this);
  TProgressMap::RemoveSubscriberForExternalProgress(&v30, v17);

  if (v3) {
    goto LABEL_25;
  }
}

void sub_1D34D6724(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  TAutoRef<__SFBrowser *,TRetainReleasePolicy<__SFBrowser *>>::~TAutoRef((const void **)va);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  _Unwind_Resume(a1);
}

void TNode::UnsubscribeForFSNotification(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v4 = *((void *)this + 2);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  int v5 = (os_unfair_lock_s *)(v4 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  int v6 = *(_DWORD *)(v4 + 115);
  os_unfair_lock_unlock(v5);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  if ((v6 & 0x20) != 0)
  {
    int v7 = (TChildrenList *)*((void *)this + 7);
    TChildrenList::UnsubscribeWithKQueue(v7);
  }
}

void TNode::RemoveSelf(TNode *this, TNodeEventPtrs *a2)
{
  uint64_t v4 = (os_unfair_lock_s *)TNode::ParentLock(this);
  os_unfair_lock_lock(v4);
  TNodePtr::TNodePtr(&v51, *((const TNode **)this + 6));
  os_unfair_lock_unlock(v4);
  int v5 = (TNode *)TNode::StPopulating::StPopulating((TNode::StPopulating *)v50, &v51, 0);
  int v6 = (os_unfair_lock_s *)TNode::InfoLock(v5);
  os_unfair_lock_lock(v6);
  uint64_t v8 = *((void *)this + 2);
  int v7 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v6);
  os_unfair_lock_lock((os_unfair_lock_t)(v8 + 100));
  unint64_t v9 = *(unsigned int *)(v8 + 115) | ((unint64_t)*(unsigned __int16 *)(v8 + 119) << 32);
  os_unfair_lock_unlock((os_unfair_lock_t)(v8 + 100));
  if ((v9 & 0x100000000) == 0)
  {
    TNodePtr::TNodePtr(&v49, this);

    int v11 = (os_unfair_lock_s *)TNode::InfoLock(v10);
    os_unfair_lock_lock(v11);
    unsigned int v13 = (TFSInfo *)*((void *)this + 2);
    int v12 = (std::__shared_weak_count *)*((void *)this + 3);
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v11);
    BOOL IsAlias = TFSInfo::IsAlias(v13);
    if (v12) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v12);
    }
    if (IsAlias) {
      TNode::ClearAliasTarget(this, 0);
    }
    TNodePtr::TNodePtr(&v49, 0);
    int v16 = (os_unfair_lock_s *)TNode::ParentLock(v15);
    os_unfair_lock_lock(v16);
    *((void *)this + 6) = TNodeFromFINode(v49.fFINode);
    os_unfair_lock_unlock(v16);

    os_unfair_lock_lock((os_unfair_lock_t)(v8 + 100));
    LODWORD(v16) = *(_DWORD *)(v8 + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)(v8 + 100));
    if ((v16 & 4) != 0) {
      TDeviceManagementMonitor::UnRegisterApp(this, v18);
    }
    uint64_t v19 = (os_unfair_lock_s *)TNode::InfoLock(v17);
    os_unfair_lock_lock(v19);
    uint64_t v21 = *((void *)this + 2);
    uint64_t v20 = (std::__shared_weak_count *)*((void *)this + 3);
    if (v20) {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v19);
    if (!*(unsigned char *)(v21 + 112))
    {
      int v22 = (os_unfair_lock_s *)(v21 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v21 + 100));
      unsigned int v24 = *(_DWORD *)(v21 + 115);
      uint64_t v23 = v21 + 115;
      unint64_t v25 = v24 | ((unint64_t)*(unsigned __int16 *)(v23 + 4) << 32) | 0x100000000;
      *(_DWORD *)uint64_t v23 = v24;
      *(_WORD *)(v23 + 4) = WORD2(v25);
      os_unfair_lock_unlock(v22);
    }
    if (v20) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v20);
    }
    if (TNodeFromFINode(v51.fFINode))
    {
      TNodePtr::TNodePtr(&v49, this);
      int v26 = +[FIPresentationNodeMap shared];
      id v27 = FINodeFromTNode(this);
      [v26 unregisterAllForPresentationNode:v27];

      id v29 = (TNode *)TGlobalNodes::RootNode((uint64_t *)&v48, v28);
      TNodePtr v30 = (os_unfair_lock_s *)TNode::InfoLock(v29);
      os_unfair_lock_lock(v30);
      uint64_t v32 = *((void *)this + 2);
      uint64_t v31 = (std::__shared_weak_count *)*((void *)this + 3);
      if (v31) {
        atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v30);
      int v33 = (os_unfair_lock_s *)(v32 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v32 + 100));
      int v34 = *(_DWORD *)(v32 + 115);
      os_unfair_lock_unlock(v33);
      if (v31) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v31);
      }
      if ((v34 & 0x100) != 0)
      {
        uint64_t v35 = TNodeFromFINode(v51.fFINode);
        if (v35 != TNodeFromFINode(v48))
        {
          {
            uint64_t v41 = dispatch_get_global_queue(-32768, 0);
            TNode::RemoveSelf(TNodeEventPtrs *)::sRemoveVolumeQueue = (uint64_t)dispatch_queue_create_with_target_V2("RemoveVolumeQueue", 0, v41);
          }
          TNodePtr::TNodePtr(&v47, this);
          v36 = TNode::RemoveSelf(TNodeEventPtrs *)::sRemoveVolumeQueue;
          block[0] = MEMORY[0x1E4F143A8];
          block[1] = 3321888768;
          block[2] = ___ZN5TNode10RemoveSelfEP14TNodeEventPtrs_block_invoke;
          block[3] = &__block_descriptor_48_ea8_32c48_ZTSKZN5TNode10RemoveSelfEP14TNodeEventPtrsE3__0_e5_v8__0l;
          uint64_t v45 = v47.fFINode;
          BOOL v46 = a2 != 0;
          TNodePtr v37 = v45;
          dispatch_async(v36, block);
        }
      }
      uint64_t v38 = TNodeFromFINode(v51.fFINode);
      TNodePtr::TNodePtr(&v47, this);
      BOOL v39 = TChildrenList::RemoveChild(*(TChildrenList **)(v38 + 56), &v47);

      if (a2) {
        BOOL v40 = v39;
      }
      else {
        BOOL v40 = 0;
      }
      if (v40)
      {
        TNodePtr::TNodePtr(&v43, this);
        TNodeEvent::CreateNodeEvent(4, (id *)&v43.fFINode, 0, &v47);
        TNodeEventPtrs::AddEvent(a2, &v51, (id *)&v47.fFINode);
        TNodeEventPtr::~TNodeEventPtr((id *)&v47.fFINode);

        TNodePtr::TNodePtr(&v47, this);
        TNodePtr::TNodePtr(&v42, this);
        TNodeEvent::CreateNodeEvent(1, (id *)&v42.fFINode, 0, &v43);
        TNodeEventPtrs::AddEvent(a2, &v47, (id *)&v43.fFINode);
        TNodeEventPtr::~TNodeEventPtr((id *)&v43.fFINode);
      }
    }
  }
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  TNode::StPopulating::~StPopulating(v50);
}

void sub_1D34D6CE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, ...)
{
  va_start(va, a13);

  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
  TNode::StPopulating::~StPopulating((FINode **)va);

  _Unwind_Resume(a1);
}

void ___ZN5TNode10RemoveSelfEP14TNodeEventPtrs_block_invoke(uint64_t a1)
{
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 3321888768;
  v2[2] = ___ZZN5TNode10RemoveSelfEP14TNodeEventPtrsENK3__0clEv_block_invoke;
  v2[3] = &__block_descriptor_41_ea8_32c13_ZTS8TNodePtr_e5_v8__0l;
  id v3 = *(id *)(a1 + 32);
  char v4 = *(unsigned char *)(a1 + 40);
  ExceptionSafeBlock(v2);
}

void sub_1D34D6E94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c48_ZTSKZN5TNode10RemoveSelfEP14TNodeEventPtrsE3__0(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a2 + 32);
  *(void *)(a1 + 32) = result;
  *(unsigned char *)(a1 + 40) = *(unsigned char *)(a2 + 40);
  return result;
}

void __destroy_helper_block_ea8_32c48_ZTSKZN5TNode10RemoveSelfEP14TNodeEventPtrsE3__0(uint64_t a1)
{
}

void TNode::SendNotifications(TNode *a1, void *a2)
{
  uint64_t v2 = a2 + 1;
  id v3 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      int v5 = *((_DWORD *)v3 + 7);
      TNodePtr::TNodePtr(&v9, a1);
      TNode::SendNotification(a1, 2, (id *)&v9.fFINode, v5, 0);

      int v6 = (void *)v3[1];
      if (v6)
      {
        do
        {
          int v7 = v6;
          int v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          int v7 = (void *)v3[2];
          BOOL v8 = *v7 == (void)v3;
          id v3 = v7;
        }
        while (!v8);
      }
      id v3 = v7;
    }
    while (v7 != v2);
  }
}

void sub_1D34D6F90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

__CFString *TString::AsNSString(TString *this)
{
  BOOL v1 = this->fString.fRef;
  return v1;
}

void TNode::DetachFPItemsMetadata(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  char v4 = (TFSInfo *)*((void *)this + 2);
  id v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  TFSInfo::UpdateFileProvider(v4, 0);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  TNode::RecursiveChildrenAndSelf(this, 0, v9);
  int v5 = (id *)v9[0];
  int v6 = (id *)v9[1];
  while (v5 != v6)
  {
    int v7 = (FINode *)*v5;
    BOOL v8 = (TNode *)TNodeFromFINode(v7);
    TNode::ClearFPItems(v8);

    ++v5;
  }
  id v10 = (void **)v9;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&v10);
}

void sub_1D34D7094(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
  _Unwind_Resume(exception_object);
}

void TNode::Remove(TNode *this, char a2, TNodeEventPtrs *a3)
{
  int v6 = (os_unfair_lock_s *)TNode::ParentLock(this);
  os_unfair_lock_lock(v6);
  TNodePtr::TNodePtr(&v7, *((const TNode **)this + 6));
  os_unfair_lock_unlock(v6);
  TNode::StPopulating::StPopulating((TNode::StPopulating *)v8, &v7, 0);

  if (*((void *)this + 7)) {
    TNode::RemoveAllChildren(this, a2, a3);
  }
  TNode::RemoveSelf(this, a3);
  TNode::StPopulating::~StPopulating(v8);
}

void sub_1D34D7164(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TNode::StPopulating::~StPopulating((FINode **)va);
  _Unwind_Resume(a1);
}

void TNode::RestartObservingCollection(TNode *this)
{
  TNode::GetVolumeInfo(this, &v4);
  uint64_t v2 = TFSVolumeInfo::GetSynchingGCDQueue(v4);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3321888768;
  block[2] = ___ZN5TNode26RestartObservingCollectionEv_block_invoke;
  block[3] = &__block_descriptor_40_ea8_32c48_ZTSKZN5TNode26RestartObservingCollectionEvE3__0_e5_v8__0l;
  void block[4] = this;
  dispatch_sync(v2, block);

  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
}

void sub_1D34D723C(_Unwind_Exception *exception_object)
{
  id v3 = *(std::__shared_weak_count **)(v1 - 24);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN5TNode26RestartObservingCollectionEv_block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  if (TChildrenList::StopCollectionStatusObserver(*(TChildrenList **)(v1 + 56)))
  {
    TNodePtr::TNodePtr((TNodePtr *)buf, (const TNode *)v1);
    uint64_t v9 = 0x4014000000000000;
    TNode::UpdateFPItemIfNeeded((id *)buf, (double *)&v9, 1, 1u, 1u, &v10);
    if (v11) {
      int fRef = v10.fString.fRef;
    }
    else {
      int fRef = 0;
    }
    if (v11) {
      id v3 = 0;
    }
    else {
      id v3 = v10.fString.fRef;
    }

    if (v3) {
      TNode::FPItemsCollection((TNode *)v1, (FPItem *)v3);
    }
    else {
    char v4 = TNode::FPItemsCollectionFromURL((TNode *)v1);
    }
    if (v4)
    {
      uint64_t v5 = *(void *)(v1 + 56);
      TNodePtr::TNodePtr((TNodePtr *)buf, (const TNode *)v1);
      TNode::GetVolumeInfo((TNode *)v1, &v10);
      int v6 = TFSVolumeInfo::GetSynchingGCDQueue((TFSVolumeInfo *)v10.fString.fRef);
      TChildrenList::StartCollectionStatusObserver(v5, v4, (uint64_t)buf, v6, 1);

      if (v11) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v11);
      }
    }
    else
    {
      TNodePtr v7 = LogObj(4);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        TNode::GetPath(v1, 1, (uint64_t)&v10);
        BOOL v8 = SanitizedPath(&v10);
        *(_DWORD *)TPropertyValue buf = 138543362;
        *(void *)&uint8_t buf[4] = v8;
        _os_log_impl(&dword_1D343E000, v7, OS_LOG_TYPE_ERROR, "Restart observing failed, no collection found for node %{public}@", buf, 0xCu);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v10.fString.fRef);
      }
    }
  }
}

void sub_1D34D7424(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c48_ZTSKZN5TNode26RestartObservingCollectionEvE3__0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32) = *(void *)(a2 + 32);
  return result;
}

void TNode::RestartCollections(TNode *this, int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  char v4 = LogObj(4);
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v5)
    {
      TNode::GetPath((uint64_t)this, 1, (uint64_t)&v12);
      int v6 = SanitizedPath(&v12);
      *(_DWORD *)TPropertyValue buf = 138543362;
      *(void *)&uint8_t buf[4] = v6;
      _os_log_impl(&dword_1D343E000, v4, OS_LOG_TYPE_DEFAULT, "Recursively restarting collections for %{public}@", buf, 0xCu);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v12.fString.fRef);
    }
    TNode::RecursiveChildrenAndSelf(this, 1, &v12);
    int fRef = v12.fString.fRef;
    BOOL v8 = v13;
    while (fRef != v8)
    {
      uint64_t v9 = fRef->isa;
      TString v10 = (TNode *)TNodeFromFINode(v9);
      TNode::RestartObservingCollection(v10);

      int fRef = (__CFString *)((char *)fRef + 8);
    }
    *(void *)TPropertyValue buf = &v12;
    std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  }
  else
  {
    if (v5)
    {
      TNode::GetPath((uint64_t)this, 1, (uint64_t)&v12);
      int v11 = SanitizedPath(&v12);
      *(_DWORD *)TPropertyValue buf = 138543362;
      *(void *)&uint8_t buf[4] = v11;
      _os_log_impl(&dword_1D343E000, v4, OS_LOG_TYPE_DEFAULT, "Restarting collection for %{public}@", buf, 0xCu);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v12.fString.fRef);
    }
    TNode::RestartObservingCollection(this);
  }
}

void sub_1D34D7668(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

void TNode::ClearFPItems(TNode *this)
{
  if (!TNode::IsFPv2(this, 1))
  {
    memset(v6, 0, sizeof(v6));
    TNode::CopyChildren(this, (uint64_t)v5);
    uint64_t v2 = v5[0];
    id v3 = v5[1];
    uint64_t v9 = v6;
    while (v2 != v3)
    {
      char v4 = (void **)*v2;
      TNodePtr v7 = (void ***)v4;
      id v8 = 0;
      std::back_insert_iterator<std::vector<std::pair<TNodePtr,FPItem * {__strong}>>>::operator=[abi:ne180100]((uint64_t **)&v9, (uint64_t)&v7);

      ++v2;
    }
    TNodePtr v7 = v5;
    std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v7);
    TNode::AttachFPItemsMetadata(v6, 0, 1);
    TChildrenList::StopCollectionStatusObserver(*((TChildrenList **)this + 7));
    v5[0] = (void **)v6;
    std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](v5);
  }
}

void sub_1D34D77A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, char a13)
{
  a10 = (void **)&a13;
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

void TNode::UpdateFPItemsMetadata(uint64_t a1, void ***a2)
{
  if (*a2 != a2[1])
  {
    char v4 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
    os_unfair_lock_lock(v4);
    uint64_t v6 = *(void *)(a1 + 16);
    BOOL v5 = *(std::__shared_weak_count **)(a1 + 24);
    if (v5)
    {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
      os_unfair_lock_unlock(v4);
      int v7 = *(unsigned __int8 *)(v6 + 112);
      std::__shared_weak_count::__release_shared[abi:ne180100](v5);
      if (v7) {
        return;
      }
    }
    else
    {
      os_unfair_lock_unlock(v4);
      if (*(unsigned char *)(v6 + 112)) {
        return;
      }
    }
    if (FPProviderDomainClass() && UseFileProviderFramework())
    {
      id v8 = TChildrenList::GetCollectionStatusObserver(*(TChildrenList **)(a1 + 56));
      if (v8
        || (TNode::GetFIProvider((TNode *)a1), uint64_t v9 = objc_claimAutoreleasedReturnValue(), v9, v9))
      {
        TNode::GetVolumeInfo((TNode *)a1, &v18);
        TString v10 = TFSVolumeInfo::GetSynchingGCDQueue(v18);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 3321888768;
        block[2] = ___ZN5TNode21UpdateFPItemsMetadataERKNSt3__16vectorI8TNodePtrNS0_9allocatorIS2_EEEE_block_invoke;
        block[3] = &__block_descriptor_64_ea8_32c90_ZTSKZN5TNode21UpdateFPItemsMetadataERKNSt3__16vectorI8TNodePtrNS0_9allocatorIS2_EEEEE3__0_e5_v8__0l;
        int v11 = v8;
        TString v12 = 0;
        uint64_t v13 = 0;
        uint64_t v14 = 0;
        std::vector<TNodePtr>::__init_with_size[abi:ne180100]<TNodePtr*,TNodePtr*>((char *)&v12, *a2, a2[1], a2[1] - *a2);
        int v16 = v11;
        memset(v17, 0, sizeof(v17));
        std::vector<TNodePtr>::__init_with_size[abi:ne180100]<TNodePtr*,TNodePtr*>((char *)v17, v12, v13, v13 - v12);
        dispatch_async(v10, block);
        uint64_t v20 = &v12;
        std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v20);

        if (v19) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v19);
        }
        int v11 = (void **)v17;
        std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&v11);
      }
    }
  }
}

void sub_1D34D79B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN5TNode21UpdateFPItemsMetadataERKNSt3__16vectorI8TNodePtrNS0_9allocatorIS2_EEEE_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = (FINode ***)(a1 + 40);
  if (v2)
  {
    [v2 updateNodesFPItemsFromCollection:v3];
  }
  else
  {
    uint64_t v4 = 0x4024000000000000;
    TNode::UpdateFPItemsIfNeeded(v3, (double *)&v4, 1, 1u, 1u, v5);
    uint64_t v6 = (void **)v5;
    std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](&v6);
  }
}

char *__copy_helper_block_ea8_32c90_ZTSKZN5TNode21UpdateFPItemsMetadataERKNSt3__16vectorI8TNodePtrNS0_9allocatorIS2_EEEEE3__0(uint64_t a1, uint64_t a2)
{
  id v4 = *(id *)(a2 + 32);
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 32) = v4;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  return std::vector<TNodePtr>::__init_with_size[abi:ne180100]<TNodePtr*,TNodePtr*>((char *)(a1 + 40), *(void ***)(a2 + 40), *(void ***)(a2 + 48), (uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 3);
}

void sub_1D34D7AE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_32c90_ZTSKZN5TNode21UpdateFPItemsMetadataERKNSt3__16vectorI8TNodePtrNS0_9allocatorIS2_EEEEE3__0(uint64_t a1)
{
  uint64_t v2 = (void **)(a1 + 40);
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&v2);
}

id *TNode::UpdateFPItemsMetadata(std::vector<TNodePtr> const&)::$_0::~$_0(id *a1)
{
  id v3 = a1 + 1;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&v3);

  return a1;
}

void TNode::Synchronize(uint64_t a1, void *a2, int a3)
{
  if ((a3 & 0x10000) != 0) {
    unsigned int v4 = 268959744;
  }
  else {
    unsigned int v4 = 285212672;
  }
  if (*a2)
  {
LABEL_7:
    TNode::RequestSynchronize((const TNode *)a1, 0);
    return;
  }
  BOOL v5 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)a1);
  os_unfair_lock_lock(v5);
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 24);
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v5);
    int v8 = *(unsigned __int8 *)(v7 + 112);
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
    if (v8) {
      goto LABEL_7;
    }
  }
  else
  {
    os_unfair_lock_unlock(v5);
    if (*(unsigned char *)(v7 + 112)) {
      goto LABEL_7;
    }
  }
  TNode::HandleSync(a1, v4);
}

void TNode::FPItemFromURLWithTimeout(const void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a1 && (FPItemManagerInstance(), uint64_t v6 = objc_claimAutoreleasedReturnValue(), v6, v6))
  {
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D510]);
    CFArrayAppendValue(Mutable, a1);
    CFArrayRef v7 = Mutable;
    std::__function::__value_func<void ()(FPItem *,NSError *)>::__value_func[abi:ne180100]((uint64_t)v14, a2);
    int v16 = 0;
    int v8 = operator new(0x28uLL);
    *int v8 = &unk_1F2ABD1E0;
    std::__function::__value_func<void ()(FPItem *,NSError *)>::__value_func[abi:ne180100]((uint64_t)(v8 + 1), (uint64_t)v14);
    int v16 = v8;
    TNode::FPItemsFromURLsWithTimeout(v7, (uint64_t)v15, (uint64_t)v12);
    std::__function::__value_func<void ()(__CFURL const*,FPItem *,NSError *)>::~__value_func[abi:ne180100](v15);
    std::__function::__value_func<void ()(FPItem *,NSError *)>::~__value_func[abi:ne180100](v14);
    uint64_t v9 = v12[0];
    if (v12[0] == v12[1])
    {
      id v10 = 0;
      id v11 = 0;
    }
    else
    {
      id v10 = *(id *)v12[0];
      id v11 = *(id *)(v9 + 8);
    }
    *a3 = v10;
    a3[1] = v11;
    v15[0] = (void **)v12;
    std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](v15);
    TAutoRef<__CFArray *,TRetainReleasePolicy<__CFArray *>>::~TAutoRef((const void **)&Mutable);
  }
  else
  {
    if (*(void *)(a2 + 24)) {
      std::function<void ()(FPItem *,NSError *)>::operator()(a2, 0, 0);
    }
    *a3 = 0;
    a3[1] = 0;
  }
}

void sub_1D34D7DC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va2, a5);
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, const void *);
  va_copy(va2, va1);
  uint64_t v8 = va_arg(va2, void);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  std::__function::__value_func<void ()(__CFURL const*,FPItem *,NSError *)>::~__value_func[abi:ne180100]((uint64_t *)va2);
  std::__function::__value_func<void ()(FPItem *,NSError *)>::~__value_func[abi:ne180100]((uint64_t *)va1);
  TAutoRef<__CFArray *,TRetainReleasePolicy<__CFArray *>>::~TAutoRef((const void **)va);
  _Unwind_Resume(a1);
}

void std::function<void ()(FPItem *,NSError *)>::operator()(uint64_t a1, void *a2, void *a3)
{
  id v7 = a2;
  id v6 = a3;
  uint64_t v5 = *(void *)(a1 + 24);
  if (!v5) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(uint64_t, id *, id *))(*(void *)v5 + 48))(v5, &v7, &v6);
}

void sub_1D34D7E98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>::~tuple(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  if (*(unsigned char *)(a1 + 24)) {

  }
  if (*(unsigned char *)(a1 + 8)) {
  return a1;
  }
}

uint64_t TNode::FPItemsFromURLsWithTimeout(__CFArray const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(__CFURL const*,FPItem *,NSError *)> const&)::$_1::~$_1(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  id v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  return a1;
}

void std::function<void ()(FPProviderDomain *,FPItem *,NSError *)>::operator()(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v10 = a2;
  id v9 = a3;
  id v8 = a4;
  uint64_t v7 = *(void *)(a1 + 24);
  if (!v7) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(uint64_t, id *, id *, id *))(*(void *)v7 + 48))(v7, &v10, &v9, &v8);
}

void sub_1D34D7FE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

uint64_t TNode::RootFPItemsForDomainsWithTimeout(NSArray<FPProviderDomain *> *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPProviderDomain *,FPItem *,NSError *)> const&)::$_1::~$_1(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  id v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  std::__function::__value_func<void ()(FPProviderDomain *,FPItem *,NSError *)>::~__value_func[abi:ne180100]((void *)(a1 + 16));

  return a1;
}

uint64_t TNode::RootFPItemsForDomainsWithTimeout(NSArray<FPProviderDomain *> *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPProviderDomain *,FPItem *,NSError *)> const&)::$_0::~$_0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  id v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }

  return a1;
}

void TNode::RootNodeForFPDomain(TNode *this@<X0>, const TString *a2@<X1>, TNodePtr *a3@<X8>)
{
  int v3 = (int)a2;
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  if ((UseFileProviderFramework() & 1) != 0 && FPProviderDomainClass())
  {
    CFIndex Length = CFStringGetLength(*(CFStringRef *)this);
    TGlobalNodes::AllProvidersNode(&v72);
    id v6 = (TNode *)TNodeFromFINode(v72.fFINode);
    if (TNode::IsPopulated(v6))
    {
LABEL_37:
      long long buf = 0uLL;
      v76 = 0;
      TNode::StPopulating::StPopulating((TNode::StPopulating *)v73, &v72, 0);
      uint64_t v26 = *(void *)(TNodeFromFINode(v72.fFINode) + 56);
      if (v26) {
        id v27 = (void ***)(v26 + 64);
      }
      else {
        id v27 = (void ***)&TNode::GetChildren(void)const::sEmptyList;
      }
      if (&buf != (long long *)v27) {
        std::vector<TNodePtr>::__assign_with_size[abi:ne180100]<TNodePtr*,TNodePtr*>((uint64_t)&buf, *v27, v27[1], v27[1] - *v27);
      }
      TNode::StPopulating::~StPopulating((FINode **)v73);
      id v63 = 0;
      id v28 = (FINode **)*((void *)&buf + 1);
      id v29 = (FINode **)buf;
      if ((void)buf == *((void *)&buf + 1)) {
        goto LABEL_57;
      }
      do
      {
        TNodePtr v30 = (TNode *)TNodeFromFINode(*v29);
        uint64_t v31 = TNode::GetFIProvider(v30);
        uint64_t v32 = [v31 domain];
        if (v32
          && ([v31 domain],
              int v33 = (FPProviderDomain *)objc_claimAutoreleasedReturnValue(),
              int v34 = IsDefaultFPDomain(v33),
              v33,
              v32,
              v34))
        {
        }
        else if (Length)
        {
          uint64_t v35 = [v31 identifier];
          *(void *)v74 = &stru_1F2ABD380;
          CFRetain(&stru_1F2ABD380);
          TString::SetStringRefAsImmutable((TString *)v74, v35);

          BOOL v36 = CFEqual(*(CFTypeRef *)v74, *(CFTypeRef *)this) == 0;
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)v74);

          if (!v36) {
            goto LABEL_55;
          }
        }
        else
        {
          if (v3) {
            char v37 = [v31 isDataSeparatedDomain];
          }
          else {
            char v37 = [v31 isMainiCloudDriveDomain];
          }
          char v38 = v37;

          if (v38) {
            goto LABEL_55;
          }
        }
        ++v29;
      }
      while (v29 != v28);
      id v29 = v28;
LABEL_55:
      if (v29 == *((FINode ***)&buf + 1))
      {
LABEL_57:
        char v39 = 0;
        v73[0] = 0;
      }
      else
      {
        *(void *)v73 = *v29;
        char v39 = 1;
      }
      v73[8] = v39;
      std::optional<TNodePtr>::value_or[abi:ne180100]<decltype(nullptr) const&>((uint64_t)v73, &v65);
      if (v73[8]) {

      }
      if (!Length && TNodeFromFINode(v65.fFINode))
      {
        BOOL v40 = LogObj(4);
        if (os_log_type_enabled(v40, OS_LOG_TYPE_INFO))
        {
          if (v3) {
            uint64_t v41 = "Enterprise";
          }
          else {
            uint64_t v41 = "";
          }
          TNodePtr v42 = (TNode *)TNodeFromFINode(v65.fFINode);
          TNodePtr v43 = TNode::GetFIProvider(v42);
          v44 = [v43 identifier];
          *(_DWORD *)v73 = 136446466;
          *(void *)&v73[4] = v41;
          *(_WORD *)&v73[12] = 2114;
          *(void *)&v73[14] = v44;
          _os_log_impl(&dword_1D343E000, v40, OS_LOG_TYPE_INFO, "FPProvider for %{public}s iCloud Drive is %{public}@", v73, 0x16u);
        }
      }
      if (TNodeFromFINode(v65.fFINode))
      {
        uint64_t v45 = (TNode *)TNodeFromFINode(v65.fFINode);
        BOOL v46 = TNode::GetFIProvider(v45);
        int v47 = [v46 supportsEnumeration];

        if (v47)
        {
          v48 = (TNode *)TNodeFromFINode(v65.fFINode);
          TNodePtr v49 = TNode::GetFIProvider(v48);
          v50 = [v49 domain];
          char v51 = [v50 isEnabled];

          if (v51)
          {
            TNodePtr::TNodePtr(a3, (id *)&v65.fFINode);
          }
          else
          {
            *(void *)v74 = 0;
            char v56 = [v49 rootURL];
            if (v56)
            {
              if ([v49 isiCloudDriveProvider])
              {
                uint64_t v57 = [v56 URLByAppendingPathComponent:@"com~apple~CloudDocs" isDirectory:1];

                char v56 = (void *)v57;
              }
              *(void *)v73 = v56;
              TNode::GetNodeFromURL(v73, v74, 0);
              TNodePtr::TNodePtr(a3, (id *)v74);
            }
            else
            {
              uint64_t v58 = LogObj(4);
              if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
              {
                v59 = (TNode *)TNodeFromFINode(v65.fFINode);
                v60 = TNode::GetFIProvider(v59);
                *(_DWORD *)v73 = 138543362;
                *(void *)&v73[4] = v60;
                _os_log_impl(&dword_1D343E000, v58, OS_LOG_TYPE_ERROR, "FPProvider storageURLs is empty for %{public}@", v73, 0xCu);
              }
              TNodePtr::TNodePtr(a3, 0);
            }
          }
          goto LABEL_91;
        }
      }
      if (Length)
      {
        char v52 = LogObj(4);
        if (os_log_type_enabled(v52, OS_LOG_TYPE_INFO))
        {
          id v53 = *(id *)this;
          *(_DWORD *)v73 = 138543362;
          *(void *)&v73[4] = v53;
          id v54 = v53;
          _os_log_impl(&dword_1D343E000, v52, OS_LOG_TYPE_INFO, "Could not find a provider for %{public}@ ", v73, 0xCu);
        }
        goto LABEL_85;
      }
      if (v3)
      {
        char v52 = LogObj(4);
        if (os_log_type_enabled(v52, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)v73 = 0;
          uint64_t v55 = "Could not find a provider which is isDataSeparatedDomain";
LABEL_84:
          _os_log_impl(&dword_1D343E000, v52, OS_LOG_TYPE_INFO, v55, v73, 2u);
        }
      }
      else
      {
        char v52 = LogObj(4);
        if (os_log_type_enabled(v52, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)v73 = 0;
          uint64_t v55 = "Could not find a provider which is isMainiCloudDriveDomain";
          goto LABEL_84;
        }
      }
LABEL_85:

      TNodePtr::TNodePtr(a3, 0);
LABEL_91:

      *(void *)v73 = &buf;
      std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)v73);

      return;
    }
    if (Length)
    {
      uint64_t v7 = LogObj(4);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        LOWORD(buf) = 0;
        id v8 = "Providers not yet loaded perform manual lookup for other";
        id v9 = v7;
        uint32_t v10 = 2;
LABEL_14:
        _os_log_impl(&dword_1D343E000, v9, OS_LOG_TYPE_INFO, v8, (uint8_t *)&buf, v10);
      }
    }
    else
    {
      uint64_t v7 = LogObj(4);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        uint64_t v11 = "Main";
        if (v3) {
          uint64_t v11 = "DataSeparated";
        }
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = v11;
        id v8 = "Providers not loaded perform manual lookup for %{public}s iCloud";
        id v9 = v7;
        uint32_t v10 = 12;
        goto LABEL_14;
      }
    }

    uint64_t v12 = (std::__shared_weak_count *)operator new(0x20uLL);
    v12->__shared_owners_ = 0;
    v12->__shared_weak_owners_ = 0;
    v12->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB470;
    v12[1].__vftable = 0;
    dispatch_semaphore_t v61 = dispatch_semaphore_create(0);
    uint64_t v13 = (void *)FPProviderDomainClass();
    v67[0] = MEMORY[0x1E4F143A8];
    v67[1] = 3321888768;
    v67[2] = ___ZN5TNode19RootNodeForFPDomainERK7TStringb_block_invoke;
    v67[3] = &__block_descriptor_72_ea8_32c51_ZTSKZN5TNode19RootNodeForFPDomainERK7TStringbE3__1_e34_v24__0__NSDictionary_8__NSError_16l;
    *(void *)&long long buf = v12 + 1;
    *((void *)&buf + 1) = v12;
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v14 = v61;
    v76 = v14;
    v77.fString.int fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(&v77, *(TString **)this);
    char v78 = v3;
    long long v68 = buf;
    if (*((void *)&buf + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&buf + 1) + 8), 1uLL, memory_order_relaxed);
    }
    int v69 = v76;
    v70.fString.int fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(&v70, (TString *)v77.fString.fRef);
    char v71 = v78;
    uint64_t v15 = objc_msgSend(v13, "beginMonitoringProviderDomainChangesWithHandler:", v67, &v68, v61);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v77.fString.fRef);

    if (*((void *)&buf + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&buf + 1));
    }
    dispatch_time_t v16 = dispatch_time(0, 10000000000);
    intptr_t v17 = dispatch_semaphore_wait(v14, v16);
    [(id)FPProviderDomainClass() endMonitoringProviderDomainChanges:v15];
    uint64_t v18 = v12[1].__vftable;
    uint64_t v19 = v18;
    if (v17 || !v18)
    {
      if (v17)
      {
        unint64_t v25 = LogObj(4);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf) = 0;
          _os_log_impl(&dword_1D343E000, v25, OS_LOG_TYPE_ERROR, "Manual lookup of provider timed out", (uint8_t *)&buf, 2u);
        }
      }
    }
    else
    {
      uint64_t v20 = [(std::__shared_weak_count_vtbl *)v18 storageURLs];
      BOOL v21 = [v20 count] == 0;

      if (!v21)
      {
        v66 = +[FIProviderDomain providerDomainForDomain:v19];
        *(void *)&long long buf = 0;
        LOBYTE(v65.fFINode) = 1;
        std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FIProviderDomain * {__strong},decltype(nullptr),BOOL,void>(&v66, (uint64_t)&buf, (unsigned __int8 *)&v65, v73);

        long long buf = 0uLL;
        TNode::CreateNode(&v65, &v72, v73, &buf);
        if (*((void *)&buf + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&buf + 1));
        }
        TNode::StPopulating::StPopulating((TNode::StPopulating *)&buf, &v72, 0);
        BOOL v64 = 0;
        uint64_t v22 = TNodeFromFINode(v72.fFINode);
        TChildrenList::AddNewChild(*(TChildrenList **)(v22 + 56), &v65, &v64, &v63);
        if (v64)
        {
          uint64_t v23 = (const TNode *)TNodeFromFINode(v72.fFINode);
          TNode::SendNotification(v23, 3, &v63, 0, 0);
        }
        unsigned int v24 = LogObj(4);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)v74 = 138543362;
          *(void *)&v74[4] = v19;
          _os_log_impl(&dword_1D343E000, v24, OS_LOG_TYPE_INFO, "Found provider from manual lookup %{public}@", v74, 0xCu);
        }

        TNode::StPopulating::~StPopulating((FINode **)&buf);
        if (*(void *)&v73[8]) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v73[8]);
        }
      }
    }

    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v70.fString.fRef);
    if (*((void *)&v68 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v68 + 1));
    }

    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
    goto LABEL_37;
  }
  TNodePtr::TNodePtr(a3, 0);
}

void sub_1D34D8AA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  *(void *)(v28 - 160) = v28 - 144;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)(v28 - 160));

  _Unwind_Resume(a1);
}

void ___ZN5TNode19RootNodeForFPDomainERK7TStringb_block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  id v7 = v5;
  id v8 = v6;
  if (v8)
  {
    id v9 = LogObj(4);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      id v29 = v8;
      _os_log_impl(&dword_1D343E000, v9, OS_LOG_TYPE_ERROR, "Failed to begin local provider lookup with error %{public}@", buf, 0xCu);
    }

    goto LABEL_24;
  }
  if (CFStringGetLength(*(CFStringRef *)(a1 + 56)))
  {
    id v10 = *(id *)(a1 + 56);
    uint64_t v11 = [v7 objectForKeyedSubscript:v10];
    uint64_t v12 = *(void ***)(a1 + 32);
    uint64_t v13 = *v12;
    *uint64_t v12 = (void *)v11;

    goto LABEL_24;
  }
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  uint64_t v14 = objc_msgSend(v7, "allValues", 0);
  uint64_t v15 = [v14 countByEnumeratingWithState:&v22 objects:buf count:16];
  if (!v15) {
    goto LABEL_18;
  }
  uint64_t v16 = *(void *)v23;
  while (2)
  {
    for (uint64_t i = 0; i != v15; ++i)
    {
      if (*(void *)v23 != v16) {
        objc_enumerationMutation(v14);
      }
      uint64_t v18 = *(void **)(*((void *)&v22 + 1) + 8 * i);
      if (*(unsigned char *)(a1 + 64))
      {
        if ([*(id *)(*((void *)&v22 + 1) + 8 * i) isDataSeparatedDomain])
        {
          objc_storeStrong(*(id **)(a1 + 32), v18);
          uint64_t v19 = LogObj(4);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
          {
            uint64_t v20 = [v18 identifier];
            *(_DWORD *)uint64_t v26 = 138543362;
            id v27 = v20;
            _os_log_impl(&dword_1D343E000, v19, OS_LOG_TYPE_INFO, "FPProvider for Enterprise iCloud Drive is %{public}@", v26, 0xCu);
          }
          goto LABEL_23;
        }
        if (*(unsigned char *)(a1 + 64)) {
          continue;
        }
      }
      if ([v18 isMainiCloudDriveDomain])
      {
        objc_storeStrong(*(id **)(a1 + 32), v18);
        uint64_t v19 = LogObj(4);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
        {
          BOOL v21 = [v18 identifier];
          *(_DWORD *)uint64_t v26 = 138543362;
          id v27 = v21;
          _os_log_impl(&dword_1D343E000, v19, OS_LOG_TYPE_INFO, "FPProvider for iCloud Drive is %{public}@", v26, 0xCu);
        }
LABEL_23:

        goto LABEL_24;
      }
    }
    uint64_t v15 = [v14 countByEnumeratingWithState:&v22 objects:buf count:16];
    if (v15) {
      continue;
    }
    break;
  }
LABEL_18:

LABEL_24:
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 48));
}

void sub_1D34D9024(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __copy_helper_block_ea8_32c51_ZTSKZN5TNode19RootNodeForFPDomainERK7TStringbE3__1(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  id v5 = *(id *)(a2 + 48);
  *(void *)(a1 + 56) = &stru_1F2ABD380;
  *(void *)(a1 + 48) = v5;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)(a1 + 56), *(TString **)(a2 + 56));
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(a2 + 64);
}

void sub_1D34D910C(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);

  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 40);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_32c51_ZTSKZN5TNode19RootNodeForFPDomainERK7TStringbE3__1(uint64_t a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 56));

  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

uint64_t TNode::RootNodeForFPDomain(TString const&,BOOL)::$_1::~$_1(uint64_t a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 24));

  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  return a1;
}

void TNode::NodeForDomainAndItemID(TNode *this@<X0>, const TString *a2@<X1>, TNodePtr *a3@<X8>)
{
  TNode::RootNodeForFPDomain(this, 0, (TNodePtr *)&v27);
  if (CFStringGetLength(a2->fString.fRef)
    && TNodeFromFINode(v27)
    && (NS_FileProviderRootContainerItemIdentifier(),
        id v6 = objc_claimAutoreleasedReturnValue(),
        int v7 = operator==((void **)&a2->fString.fRef, v6),
        v6,
        !v7))
  {
    id v8 = (TNode *)TNodeFromFINode(v27);
    id v9 = TNode::GetFIProvider(v8);
    id v10 = [v9 domain];
    char v11 = [v10 isEnabled];

    if (v11)
    {
      uint64_t v12 = v27;
      uint64_t v13 = (TNode *)TNodeFromFINode(v12);
      uint64_t v14 = TNode::GetFIProvider(v13);
      uint64_t v15 = [v14 identifier];
      v28.fString.int fRef = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      TString::SetStringRefAsImmutable(&v28, v15);

      uint64_t v16 = FPItemManagerInstance();

      if (v16)
      {
        dispatch_semaphore_t v26 = dispatch_semaphore_create(0);
        intptr_t v17 = (std::__shared_weak_count *)operator new(0x20uLL);
        v17->__shared_owners_ = 0;
        v17->__shared_weak_owners_ = 0;
        v17->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB518;
        v17[1].__vftable = 0;
        id v18 = objc_alloc(MEMORY[0x1E4F25D30]);
        uint64_t v19 = (void *)[v18 initWithProviderDomainID:v28.fString.fRef itemIdentifier:a2->fString.fRef];
        uint64_t v20 = FPItemManagerInstance();
        v32[0] = MEMORY[0x1E4F143A8];
        v32[1] = 3321888768;
        v32[2] = ___ZL23FPItemForProviderWithIDRK7TStringS1__block_invoke;
        v32[3] = &__block_descriptor_56_ea8_32c50_ZTSKZL23FPItemForProviderWithIDRK7TStringS1_E3__0_e28_v24__0__FPItem_8__NSError_16l;
        id v29 = v17 + 1;
        uint64_t v30 = v17;
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        BOOL v21 = v26;
        uint64_t v31 = v21;
        v32[4] = v17 + 1;
        int v33 = v17;
        atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        long long v22 = v21;
        int v34 = v22;
        [v20 fetchItemForItemID:v19 completionHandler:v32];

        std::__shared_weak_count::__release_shared[abi:ne180100](v17);
        dispatch_semaphore_wait(v22, 0xFFFFFFFFFFFFFFFFLL);
        long long v23 = v17[1].__vftable;

        if (v33) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v33);
        }

        std::__shared_weak_count::__release_shared[abi:ne180100](v17);
      }
      else
      {
        long long v23 = 0;
      }
      long long v24 = v12;
      v32[0] = v24;
      v25.fFINode = (FINode *)v32;
      NodeForProviderWithFPItem(v25, v23, a3);

      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v28.fString.fRef);
    }
    else
    {
      TNodePtr::TNodePtr(a3, 0);
    }
  }
  else
  {
    TNodePtr::TNodePtr(a3, (id *)&v27);
  }
}

void sub_1D34D9494(_Unwind_Exception *a1, uint64_t a2, void *a3, void *a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  char v11 = va_arg(va1, const void *);
  FPItemForProviderWithID(TString const&,TString const&)::$_0::~$_0(v9);
  FPItemForProviderWithID(TString const&,TString const&)::$_0::~$_0((uint64_t)va1);

  std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

void NodeForProviderWithFPItem(TNodePtr a1@<0:X0>, FPItem *a2@<X1>, TNodePtr *a3@<X8>)
{
  id v21 = (id)*MEMORY[0x1E4F143B8];
  id v5 = a2;
  if (v5
    && TNodeFromFINode((FINode *)a1.fFINode->super.isa)
    && (FPItemManagerInstance(), id v6 = objc_claimAutoreleasedReturnValue(), v6, v6)
    && ([(FPItem *)v5 fileURL], int v7 = objc_claimAutoreleasedReturnValue(), v7, v7))
  {
    a3->fFINode = 0;
    id v8 = [(FPItem *)v5 fileURL];
    uint64_t v14 = v8;
    TNode::GetNodeFromURL(&v14, a3, 0);

    if (TNodeFromFINode(a3->fFINode))
    {
      uint64_t v9 = TNodeFromFINode(a3->fFINode);
      id v10 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v9);
      os_unfair_lock_lock(v10);
      uint64_t v12 = *(TFSInfo **)(v9 + 16);
      char v11 = *(std::__shared_weak_count **)(v9 + 24);
      if (v11) {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v10);
      uint64_t v13 = TFSInfo::GetFPItem(v12);
      if (v11) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v11);
      }

      if (!v13)
      {
        uint64_t v19 = a3->fFINode;
        uint64_t v20 = v5;
        uint64_t v15 = 0;
        uint64_t v16 = 0;
        uint64_t v14 = 0;
        intptr_t v17 = (void **)&v14;
        char v18 = 0;
        uint64_t v14 = operator new(0x10uLL);
        uint64_t v15 = v14;
        uint64_t v16 = v14 + 2;
        uint64_t v15 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}>*>((uint64_t)&v16, (id *)&v19, &v21, v14);
        TNode::AttachFPItemsMetadata(&v14, 1, 1);
        intptr_t v17 = (void **)&v14;
        std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](&v17);
      }
    }
  }
  else
  {
    TNodePtr::TNodePtr(a3, 0);
  }
}

void sub_1D34D9730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, uint64_t a13, id a14, id a15)
{
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](&a12);

  _Unwind_Resume(a1);
}

const void **TNode::FPItemNodeFromObjectID@<X0>(TNode *this@<X0>, TNodePtr *a2@<X8>)
{
  v13.fString.int fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  v12.fString.int fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::TString((TString *)&cf, "/");
  CFIndex v5 = TString::IndexOf((TString *)this, (const TString *)&cf, 0);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
  if (v5 < 0)
  {
    if (&v13 != (TString *)this) {
      TString::SetStringRefAsImmutable(&v13, *(TString **)this);
    }
  }
  else if (v5)
  {
    TString::SubString((TString *)this, 0, v5, (TString *)&cf);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v13.fString.fRef, &cf);
    CFRetain(&stru_1F2ABD380);
    if (cf) {
      CFRelease(cf);
    }
    CFTypeRef cf = &stru_1F2ABD380;
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    if (v5 < CFStringGetLength(*(CFStringRef *)this) - 1)
    {
      TString::SubStringFrom((TString *)this, v5 + 1, (TString *)&cf);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)&v12.fString.fRef, &cf);
      CFRetain(&stru_1F2ABD380);
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef cf = &stru_1F2ABD380;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    }
  }
  id v6 = v13.fString.fRef;
  int v7 = [(__CFString *)v6 stringByRemovingPercentEncoding];
  if ((TString *)v13.fString.fRef != v7) {
    TString::SetStringRefAsImmutable(&v13, v7);
  }

  id v8 = v12.fString.fRef;
  uint64_t v9 = [(__CFString *)v8 stringByRemovingPercentEncoding];
  if ((TString *)v12.fString.fRef != v9) {
    TString::SetStringRefAsImmutable(&v12, v9);
  }

  TNode::NodeForDomainAndItemID((TNode *)&v13, &v12, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v12.fString.fRef);
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v13.fString.fRef);
}

void sub_1D34D99A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  _Unwind_Resume(a1);
}

void TNode::ResolveBRContainer(TNode *this)
{
  if (ICloudDriveFPFSEnabled())
  {
    TNode::CFURL(this, &v14);
    uint64_t v2 = v14.fFINode;
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v14.fFINode);
  }
  else
  {
    uint64_t v2 = 0;
  }
  TNodePtr::TNodePtr(&v14, this);
  fFINode = v14.fFINode;
  if (v2)
  {
    v13.fFINode = v2;
    v14.fFINode = 0;
    TNode::GetNodeFromURL((CFURLRef *)&v13, &v14, 0);
    if (TNodeFromFINode(v14.fFINode))
    {
      uint64_t v4 = +[FIPresentationNodeMap shared];
      CFIndex v5 = [v4 presentationNodeForKeyNode:v14.fFINode];
      objc_cast<FIDSNode,FINode * {__strong}>(v5);
      id v6 = (FINode *)objc_claimAutoreleasedReturnValue();

      if (v6 && v6 != fFINode)
      {

        uint64_t v7 = 1;
        goto LABEL_13;
      }
      if (v6)
      {
LABEL_17:

        goto LABEL_18;
      }
    }
    uint64_t v7 = 0;
LABEL_13:
    TNode::SetAliasTarget(this, &v14, 0);
    if (fFINode && TNodeFromFINode(v14.fFINode))
    {
      uint64_t v9 = +[FIPresentationNodeMap shared];
      [v9 registerPresentationNode:fFINode forNode:v14.fFINode clearOlderKeyNodes:v7];

      uint64_t v10 = TNodeFromFINode(v14.fFINode);
      char v11 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v10);
      os_unfair_lock_lock(v11);
      TNodePtr::TNodePtr(&v13, *(const TNode **)(v10 + 48));
      os_unfair_lock_unlock(v11);
      TString v12 = +[FIPresentationNodeMap shared];
      [v12 registerPresentationNode:fFINode forNode:v13.fFINode];
    }
    id v6 = 0;
    goto LABEL_17;
  }
  TNode::ClearAliasTarget(this, 0);
  if (fFINode)
  {
    id v8 = +[FIPresentationNodeMap shared];
    [v8 unregisterAllForPresentationNode:fFINode];
  }
LABEL_18:
}

void sub_1D34D9BEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void ___ZN5TNode11AddNewChildERK8TNodePtrRbbb_block_invoke(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (TNode *)TNodeFromFINode(*(FINode **)(a1 + 32));
  TNode::AttachCreateFPItemIfNeeded(v2, 1u);
  uint64_t v3 = TNodeFromFINode(*(FINode **)(a1 + 32));
  uint64_t v4 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v3);
  os_unfair_lock_lock(v4);
  id v6 = *(TFSInfo **)(v3 + 16);
  CFIndex v5 = *(std::__shared_weak_count **)(v3 + 24);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v4);
  uint64_t v7 = TFSInfo::GetFPItem(v6);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }

  if (v7)
  {
    id v8 = LogObj(4);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = TNodeFromFINode(*(FINode **)(a1 + 32));
      uint64_t v10 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v9);
      os_unfair_lock_lock(v10);
      TString v12 = *(TFSInfo **)(v9 + 16);
      char v11 = *(std::__shared_weak_count **)(v9 + 24);
      if (v11) {
        atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v10);
      TNodePtr v13 = TFSInfo::GetFPItem(v12);
      if (v11) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v11);
      }
      int v14 = 138543362;
      uint64_t v15 = v13;
      _os_log_impl(&dword_1D343E000, v8, OS_LOG_TYPE_DEFAULT, "FPItem found asynchronously %{public}@", (uint8_t *)&v14, 0xCu);
    }
  }
}

void sub_1D34D9DEC(_Unwind_Exception *a1)
{
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }

  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c47_ZTSKZN5TNode11AddNewChildERK8TNodePtrRbbbE3__0(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a2 + 32);
  *(void *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c47_ZTSKZN5TNode11AddNewChildERK8TNodePtrRbbbE3__0(uint64_t a1)
{
}

void ___ZN5TNode31SetShouldSyncUbiquityAttributesEb_block_invoke(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 40);
  uint64_t v2 = TNodeFromFINode(*(FINode **)(a1 + 32));
  if (v1)
  {
    TNode::RegisterForUbiquityAttributes((TNode *)v2);
  }
  else
  {
    uint64_t v3 = *(TChildrenList **)(v2 + 56);
    if (v3)
    {
      TChildrenList::ClearCollectionStatusObserver(v3);
    }
  }
}

id __copy_helper_block_ea8_32c53_ZTSKZN5TNode31SetShouldSyncUbiquityAttributesEbE3__0(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a2 + 32);
  *(void *)(a1 + 32) = result;
  *(unsigned char *)(a1 + 40) = *(unsigned char *)(a2 + 40);
  return result;
}

void __destroy_helper_block_ea8_32c53_ZTSKZN5TNode31SetShouldSyncUbiquityAttributesEbE3__0(uint64_t a1)
{
}

void TNode::RegisterForUbiquityAttributes(TNode *this)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v4 = *((void *)this + 2);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v2);
    int v5 = *(unsigned __int8 *)(v4 + 112);
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    if (v5) {
      return;
    }
  }
  else
  {
    os_unfair_lock_unlock(v2);
    if (*(unsigned char *)(v4 + 112)) {
      return;
    }
  }
  if (*((void *)this + 7))
  {
    id v6 = (TNode *)UseFileProviderFramework();
    if (v6)
    {
      uint64_t v7 = (os_unfair_lock_s *)TNode::InfoLock(v6);
      os_unfair_lock_lock(v7);
      uint64_t v9 = (TFSInfo *)*((void *)this + 2);
      id v8 = (std::__shared_weak_count *)*((void *)this + 3);
      if (v8) {
        atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v7);
      uint64_t v10 = TFSInfo::GetFPItem(v9);
      if (v8) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v8);
      }
      if (v10)
      {
        TNodePtr::TNodePtr(&v22, this);
        id v11 = v10;
        int fRef = 0;
        p_data = 0;
        v19.fString.int fRef = 0;
        id v23 = v11;
        *(void *)long long buf = &v19;
        uint8_t buf[8] = 0;
        v19.fString.int fRef = (__CFString *)operator new(0x10uLL);
        int fRef = v19.fString.fRef;
        p_data = &v19.fString.fRef->data;
        int fRef = (__CFString *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}>*>((uint64_t)&p_data, (id *)&v22.fFINode, (id *)buf, v19.fString.fRef);
        TNode::AttachFPItemsMetadata(&v19, 1, 1);
        *(void *)long long buf = &v19;
        std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);

        TString v12 = TNode::FPItemsCollection(this, (FPItem *)v11);

        if (v12)
        {
LABEL_13:
          uint64_t v13 = *((void *)this + 7);
          TNodePtr::TNodePtr((TNodePtr *)buf, this);
          TNode::GetVolumeInfo(this, &v19);
          int v14 = TFSVolumeInfo::GetSynchingGCDQueue((TFSVolumeInfo *)v19.fString.fRef);
          TChildrenList::StartCollectionStatusObserver(v13, v12, (uint64_t)buf, v14, 0);

          if (fRef) {
            std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)fRef);
          }

LABEL_22:
          return;
        }
      }
      else
      {
        uint64_t v15 = LogObj(4);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
        {
          TNode::GetPath((uint64_t)this, 1, (uint64_t)&v19);
          uint64_t v16 = SanitizedPath(&v19);
          *(_DWORD *)long long buf = 138543362;
          *(void *)&uint8_t buf[4] = v16;
          _os_log_impl(&dword_1D343E000, v15, OS_LOG_TYPE_INFO, "Attempting to observe fpitem collection via URL %{public}@", buf, 0xCu);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v19.fString.fRef);
        }
        TString v12 = TNode::FPItemsCollectionFromURL(this);
        if (v12) {
          goto LABEL_13;
        }
      }
      intptr_t v17 = LogObj(4);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        TNode::GetPath((uint64_t)this, 1, (uint64_t)&v19);
        char v18 = SanitizedPath(&v19);
        *(_DWORD *)long long buf = 138543362;
        *(void *)&uint8_t buf[4] = v18;
        _os_log_impl(&dword_1D343E000, v17, OS_LOG_TYPE_ERROR, "No collection found for node %{public}@", buf, 0xCu);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v19.fString.fRef);
      }
      goto LABEL_22;
    }
  }
}

void sub_1D34DA23C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

void TNode::UnRegisterForUbiquityAttributes(TNode *this)
{
  int v1 = (TChildrenList *)*((void *)this + 7);
  if (v1) {
    TChildrenList::ClearCollectionStatusObserver(v1);
  }
}

uint64_t TNode::SetPrefetchPropertiesOnSync(TNode *this)
{
  uint64_t v3 = *(TFSVolumeInfo **)this;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v3)
  {
    uint64_t v5 = 0;
    if (!v2) {
      return v5;
    }
    goto LABEL_12;
  }
  StRegistrationLock::StRegistrationLock((StRegistrationLock *)&v8);
  BOOL v4 = TFSVolumeInfo::ShouldUseReadDir(v3) && TNode::ShouldUseReadDir(this);
  atomic_fetch_or((atomic_ushort *volatile)this + 40, 0x800u);
  BOOL Dir = TFSVolumeInfo::ShouldUseReadDir(v3);
  if (Dir) {
    BOOL Dir = TNode::ShouldUseReadDir(this);
  }
  uint64_t v5 = v4 ^ Dir;
  StRegistrationLock::~StRegistrationLock((StRegistrationLock *)&v8);
  if (v2) {
LABEL_12:
  }
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  return v5;
}

void sub_1D34DA3E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
  _Unwind_Resume(exception_object);
}

BOOL TNode::ShouldUseReadDir(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v4 = *((void *)this + 2);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v2);
    int v5 = *(unsigned __int8 *)(v4 + 112);
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    if (v5) {
      return 0;
    }
  }
  else
  {
    os_unfair_lock_unlock(v2);
    if (*(unsigned char *)(v4 + 112)) {
      return 0;
    }
  }
  unsigned __int16 v6 = atomic_load((unsigned __int16 *)this + 40);
  if ((v6 & 0x800) == 0)
  {
    uint64_t IsLocalVolume = (TGlobalNodes *)TNode::IsLocalVolume(this);
    if ((IsLocalVolume & 1) == 0)
    {
      TGlobalNodes::BootNode((uint64_t *)&v10, IsLocalVolume);
      BOOL v8 = TNodeFromFINode(v10) != (void)this;

      return v8;
    }
  }
  return 0;
}

void sub_1D34DA4D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t std::pair<TNodePtr,std::shared_ptr<TFSInfo>>::~pair(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }

  return a1;
}

uint64_t std::vector<TNodePtr>::push_back[abi:ne180100](uint64_t a1, id *a2)
{
  unint64_t v6 = *(void *)(a1 + 16);
  uint64_t v4 = a1 + 16;
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    uint64_t v10 = (uint64_t)(v7 - *(void *)a1) >> 3;
    if ((unint64_t)(v10 + 1) >> 61) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v5 - *(void *)a1;
    uint64_t v12 = v11 >> 2;
    if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
      uint64_t v12 = v10 + 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v12;
    }
    uint64_t v19 = v4;
    if (v13) {
      int v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v4, v13);
    }
    else {
      int v14 = 0;
    }
    uint64_t v15 = v14;
    uint64_t v16 = &v14[8 * v10];
    char v18 = &v14[8 * v13];
    TNodePtr::TNodePtr(v16, a2);
    intptr_t v17 = v16 + 8;
    std::vector<TNodePtr>::__swap_out_circular_buffer((id **)a1, &v15);
    unint64_t v9 = *(void *)(a1 + 8);
    uint64_t result = std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)&v15);
  }
  else
  {
    uint64_t result = (uint64_t)TNodePtr::TNodePtr(*(void **)(v4 - 8), a2);
    unint64_t v9 = v7 + 8;
    *(void *)(a1 + 8) = v7 + 8;
  }
  *(void *)(a1 + 8) = v9;
  return result;
}

void sub_1D34DA60C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void TFSInfoSynchronizer::~TFSInfoSynchronizer(TFSInfoSynchronizer *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }

  uint64_t v3 = (void **)this;
  std::vector<std::shared_ptr<TCFURLInfoList>>::__destroy_vector::operator()[abi:ne180100](&v3);
}

void TNode::RemoveChildrenDeep(uint64_t *a1, char a2, int a3, TNodeEventPtrs *a4)
{
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  if (v5 != *a1)
  {
    if ((a2 & 2) == 0) {
      a3 = 1;
    }
    uint64_t v8 = a1[1];
    do
    {
      unint64_t v9 = *(FINode **)(v8 - 8);
      v8 -= 8;
      uint64_t v10 = TNodeFromFINode(v9);
      uint64_t v11 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v10);
      os_unfair_lock_lock(v11);
      uint64_t v13 = *(void *)(v10 + 16);
      uint64_t v12 = *(std::__shared_weak_count **)(v10 + 24);
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v11);
      int v14 = (os_unfair_lock_s *)(v13 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v13 + 100));
      uint64_t v15 = *(unsigned __int16 *)(v13 + 119);
      uint64_t v16 = *(unsigned int *)(v13 + 115);
      os_unfair_lock_unlock(v14);
      if (v12) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v12);
      }
      if (((v16 | (v15 << 32)) & 0x100000000) != 0) {
        goto LABEL_28;
      }
      uint64_t v17 = TNodeFromFINode(*(FINode **)(v5 - 8));
      char v18 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v17);
      os_unfair_lock_lock(v18);
      uint64_t v20 = *(void *)(v17 + 16);
      uint64_t v19 = *(std::__shared_weak_count **)(v17 + 24);
      if (v19) {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v18);
      id v21 = (os_unfair_lock_s *)(v20 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v20 + 100));
      int v22 = *(_DWORD *)(v20 + 115);
      os_unfair_lock_unlock(v21);
      if (v19) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v19);
      }
      if ((v22 & 4) != 0)
      {
        id v23 = (TNode *)TNodeFromFINode(*(FINode **)(v5 - 8));
        TDeviceManagementMonitor::UnRegisterApp(v23, v24);
      }
      uint64_t v25 = TNodeFromFINode(*(FINode **)(v5 - 8));
      dispatch_semaphore_t v26 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v25);
      os_unfair_lock_lock(v26);
      uint64_t v28 = *(void *)(v25 + 16);
      id v27 = *(std::__shared_weak_count **)(v25 + 24);
      if (v27) {
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v26);
      id v29 = (os_unfair_lock_s *)(v28 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v28 + 100));
      int v30 = *(_DWORD *)(v28 + 115);
      os_unfair_lock_unlock(v29);
      if (v27) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v27);
      }
      if ((v30 & 0x20) != 0)
      {
        uint64_t v31 = (TNode *)TNodeFromFINode(*(FINode **)(v5 - 8));
        if ((a3 & TNode::RemoveAllChildren(v31)) == 1)
        {
LABEL_25:
          if (a2) {
            TNodeFromFINode(*(FINode **)(v5 - 8));
          }
          uint64_t v32 = (TNode *)TNodeFromFINode(*(FINode **)(v5 - 8));
          TNode::RemoveSelf(v32, a4);
        }
      }
      else if (a3)
      {
        goto LABEL_25;
      }
LABEL_28:
      uint64_t v5 = v8;
    }
    while (v8 != v4);
  }
}

unint64_t TNode::UserCanRead(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v4 = *((void *)this + 2);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  uint64_t v5 = (os_unfair_lock_s *)(v4 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  unint64_t v6 = *(unsigned int *)(v4 + 115) | ((unint64_t)*(unsigned __int16 *)(v4 + 119) << 32);
  os_unfair_lock_unlock(v5);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  return (v6 >> 12) & 1;
}

unint64_t TFSInfo::UserCanWrite(TFSInfo *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  unint64_t v3 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 13) & 1;
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t TNode::IsSticky(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v4 = *((void *)this + 2);
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  uint64_t v5 = (os_unfair_lock_s *)(v4 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  int v6 = *(_DWORD *)(v4 + 115);
  os_unfair_lock_unlock(v5);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  if ((v6 & 0x20) == 0) {
    return 0;
  }
  unint64_t v9 = (os_unfair_lock_s *)TNode::InfoLock(v7);
  os_unfair_lock_lock(v9);
  uint64_t v11 = (TFSInfo *)*((void *)this + 2);
  uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v9);
  uint64_t v8 = (TFSInfo::GetMode(v11) >> 9) & 1;
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  return v8;
}

void sub_1D34DA9DC(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL TNode::UserCanChangePermissions(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  BOOL IsRoot = TFSInfo::UserIsRoot(v4);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  BOOL IsOwner = TNode::UserIsOwner(this);
  if (!IsRoot) {
    return IsOwner;
  }
  TNode::GetVolumeInfo(this, &v9);
  BOOL v7 = *(unsigned char *)(v9 + 107) != 0;
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  return v7;
}

void sub_1D34DAA9C(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL TNode::UserIsOwner(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v4 = *((void *)this + 2);
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v2);
    int v5 = *(unsigned __int8 *)(v4 + 112);
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    if (v5) {
      return 1;
    }
  }
  else
  {
    os_unfair_lock_unlock(v2);
    if (*(unsigned char *)(v4 + 112)) {
      return 1;
    }
  }
  uint64_t v8 = (os_unfair_lock_s *)TNode::InfoLock(v6);
  os_unfair_lock_lock(v8);
  uint64_t v10 = (TFSInfo *)*((void *)this + 2);
  uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v8);
  BOOL IsOwner = TFSInfo::UserIsOwner(v10);
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
  return IsOwner;
}

void sub_1D34DAB70(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

unint64_t TNode::UserCanListContent(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v4 = *((void *)this + 2);
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3)
  {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v2);
    int v5 = *(unsigned __int8 *)(v4 + 112);
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  else
  {
    os_unfair_lock_unlock(v2);
    int v5 = *(unsigned __int8 *)(v4 + 112);
  }
  BOOL v7 = (os_unfair_lock_s *)TNode::InfoLock(v6);
  os_unfair_lock_lock(v7);
  uint64_t v9 = *((void *)this + 2);
  uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 3);
  if (!v5)
  {
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v7);
    uint64_t v13 = (os_unfair_lock_s *)(v9 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v9 + 100));
    int v14 = *(_DWORD *)(v9 + 115);
    os_unfair_lock_unlock(v13);
    if (v8) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    }
    if ((v14 & 0x20) == 0) {
      return 0;
    }
    uint64_t v17 = (os_unfair_lock_s *)TNode::InfoLock(v15);
    os_unfair_lock_lock(v17);
    uint64_t v19 = *((void *)this + 2);
    char v18 = (std::__shared_weak_count *)*((void *)this + 3);
    if (v18) {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v17);
    os_unfair_lock_lock((os_unfair_lock_t)(v19 + 100));
    unint64_t v16 = ((unint64_t)*(unsigned int *)(v19 + 115) >> 14) & 1;
    os_unfair_lock_unlock((os_unfair_lock_t)(v19 + 100));
    if (v18) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v18);
    }
    return v16;
  }
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v7);
  uint64_t v10 = (os_unfair_lock_s *)(v9 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v9 + 100));
  int v11 = *(_DWORD *)(v9 + 115);
  os_unfair_lock_unlock(v10);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  if ((v11 & 0x20) != 0) {
    return 1;
  }
  return TNode::AliasIsContainer(this);
}

void ___ZNK5TNode23FetchExtendedUserAccessEv_block_invoke(uint64_t a1)
{
  int v2 = TFSInfo::SetExtendedUserAccess(*(TFSInfo **)(a1 + 40));
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
  if (v2)
  {
    unint64_t v3 = (const TNode *)TNodeFromFINode(*(FINode **)(a1 + 56));
    TNode::SendNotification(v3, 2, (id *)(a1 + 56), 1970495843, 0);
  }
}

id __copy_helper_block_ea8_40c34_ZTSNSt3__110shared_ptrI7TFSInfoEE56c13_ZTS8TNodePtr(void *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 48);
  a1[5] = *(void *)(a2 + 40);
  a1[6] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  id result = *(id *)(a2 + 56);
  a1[7] = result;
  return result;
}

void __destroy_helper_block_ea8_40c34_ZTSNSt3__110shared_ptrI7TFSInfoEE56c13_ZTS8TNodePtr(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

unint64_t TNode::UserCanDelete(TNode *this)
{
  ExtendedUserAccess = (TNode *)TNode::FetchExtendedUserAccess(this);
  if (!ExtendedUserAccess) {
    return 1;
  }
  uint64_t v3 = (os_unfair_lock_s *)TNode::InfoLock(ExtendedUserAccess);
  os_unfair_lock_lock(v3);
  uint64_t v5 = *((void *)this + 2);
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v3);
  os_unfair_lock_lock((os_unfair_lock_t)(v5 + 100));
  unint64_t v6 = ((unint64_t)*(unsigned int *)(v5 + 115) >> 22) & 1;
  os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 100));
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return v6;
}

unint64_t TNode::UserCanDeleteChild(TNode *this)
{
  ExtendedUserAccess = (TNode *)TNode::FetchExtendedUserAccess(this);
  if (!ExtendedUserAccess) {
    return 1;
  }
  uint64_t v3 = (os_unfair_lock_s *)TNode::InfoLock(ExtendedUserAccess);
  os_unfair_lock_lock(v3);
  uint64_t v5 = *((void *)this + 2);
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v3);
  os_unfair_lock_lock((os_unfair_lock_t)(v5 + 100));
  unint64_t v6 = ((unint64_t)*(unsigned int *)(v5 + 115) >> 23) & 1;
  os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 100));
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return v6;
}

unint64_t TFSInfo::UserCanAddDeleteChild(TFSInfo *this)
{
  int v2 = (os_unfair_lock_s *)((char *)this + 100);
  os_unfair_lock_lock((os_unfair_lock_t)this + 25);
  unint64_t v3 = ((unint64_t)*(unsigned int *)((char *)this + 115) >> 23) & 1;
  os_unfair_lock_unlock(v2);
  return v3;
}

void TNode::UnRegisterForInternalNotifications(TNodeEvent *a1, FINode **a2, uint64_t a3)
{
  TNodeEvent::GetInternalClientNotifier(a1, &v6);
  TNode::UnregisterChangeNotification((uint64_t)a1, (uint64_t)&v6, a2, a3);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
}

void sub_1D34DAFE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TNode::KQueue(TNode *this)
{
  KQueueLock();
  os_unfair_lock_lock((os_unfair_lock_t)&KQueueLock(void)::gkQueueLock);
  uint64_t v1 = TNode::gKQueue;
  os_unfair_lock_unlock((os_unfair_lock_t)&KQueueLock(void)::gkQueueLock);
  return v1;
}

void KQueueLock(void)
{
  {
    KQueueLock(void)::gkQueueLock = 0;
  }
}

void TNode::AddkQueueNotification(TNode *this)
{
  KQueueLock();
  os_unfair_lock_lock((os_unfair_lock_t)&KQueueLock(void)::gkQueueLock);
  if (!TNode::gKQueueRegistrationCount++) {
    TNode::gKQueue = kqueue();
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&KQueueLock(void)::gkQueueLock);
}

void sub_1D34DB100(_Unwind_Exception *a1)
{
}

void TNode::RemovekQueueNotification(TNode *this)
{
  KQueueLock();
  os_unfair_lock_lock((os_unfair_lock_t)&KQueueLock(void)::gkQueueLock);
  if (!--TNode::gKQueueRegistrationCount)
  {
    close(TNode::gKQueue);
    TNode::gKQueue = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&KQueueLock(void)::gkQueueLock);
}

void sub_1D34DB180(_Unwind_Exception *a1)
{
}

uint64_t TNode::AdjustedResizeQuanta(TNode *this)
{
  int v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v4 = *((void *)this + 2);
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  uint64_t v5 = (os_unfair_lock_s *)(v4 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v4 + 100));
  int v6 = *(_DWORD *)(v4 + 115);
  os_unfair_lock_unlock(v5);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  if ((v6 & 0x100) != 0) {
    return 2000000;
  }
  uint64_t v8 = (os_unfair_lock_s *)TNode::InfoLock(v7);
  os_unfair_lock_lock(v8);
  uint64_t v10 = *((void *)this + 2);
  uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v8);
  int v11 = (os_unfair_lock_s *)(v10 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v10 + 100));
  int v12 = *(_DWORD *)(v10 + 115);
  os_unfair_lock_unlock(v11);
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
  if ((v12 & 0x20) == 0) {
    return 5000000;
  }
  uint64_t LastResizeDuration = TChildrenList::GetLastResizeDuration(*((TChildrenList **)this + 7));
  if ((unint64_t)(5 * LastResizeDuration) >= 0x4C4B40) {
    return 5000000;
  }
  else {
    return 5 * LastResizeDuration;
  }
}

void TNode::SetTimerToDispatchResizeRequest(id **a1, uint64_t a2)
{
  if (*a1)
  {
    uint64_t v4 = (FINode *)**a1;
    if (TNodeFromFINode(v4))
    {
      uint64_t v5 = (TNode *)TNodeFromFINode(v4);
      TNode::GetVolumeInfo(v5, &v8);
      if (v8)
      {
        TFSVolumeInfo::GetFolderSizingThread(v8, &v6);
        if (v6) {
          TFolderSizingThread::SetTimerToDispatchResizeRequest(&v6, (uint64_t *)a1, a2);
        }
        if (v7) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v7);
        }
      }
      if (v9) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v9);
      }
    }
  }
}

void sub_1D34DB348(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }

  _Unwind_Resume(a1);
}

void TNode::DispatchResizeRequestNow(id **a1)
{
  if (TNode::IsContextOpen((TNode *)a1))
  {
    unint64_t v3 = (FINode *)**a1;
    uint64_t v2 = TNodeFromFINode(v3);
    TNode::PostFolderSizingTaskRequest(v2, a1, 1);
  }
}

void sub_1D34DB3F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id TNode::FPItemsCollectionFromURL(TNode *this)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = TNode::GetFIProvider(this);
  if (!v2)
  {
    unint64_t v3 = LogObj(4);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
    {
      TNode::GetPath((uint64_t)this, 1, (uint64_t)v29);
      uint64_t v4 = SanitizedPath(v29);
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v4;
      _os_log_impl(&dword_1D343E000, v3, OS_LOG_TYPE_INFO, "No provider found for collection, looking up by url %{public}@", buf, 0xCu);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v29[0].fString.fRef);
    }
    TNode::CFURL(this, v29);
    uint64_t v2 = +[FIProviderDomain providerDomainForURL:v29[0].fString.fRef cachePolicy:3 error:0];
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v29[0].fString.fRef);
  }
  TNode::CFURL(this, v29);
  uint64_t v5 = v29[0].fString.fRef;
  uint64_t v6 = [(__CFString *)v5 URLByStandardizingPath];

  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v29[0].fString.fRef);
  BOOL v7 = FPItemManagerInstance();
  id v26 = 0;
  uint64_t v8 = (void *)[v7 newCollectionWithItemAtURL:v6 error:&v26];
  uint64_t v9 = (__CFString *)v26;

  if (!v8 && v2)
  {
    uint64_t v10 = LogObj(4);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      SanitizedURL(v6);
      int v11 = (__CFString *)objc_claimAutoreleasedReturnValue();
      LODWORD(v29[0].fString.fRef) = 138543362;
      *(__CFString **)((char *)&v29[0].fString.fRef + 4) = v11;
      _os_log_impl(&dword_1D343E000, v10, OS_LOG_TYPE_DEFAULT, "Collection not found by url, Attempting fetch of FPItem for %{public}@", (uint8_t *)v29, 0xCu);
    }
    v29[3].fString.int fRef = 0;
    TNode::FPItemFromURLWithTimeout(v6, (uint64_t)v29, &v24);
    std::__function::__value_func<void ()(FPItem *,NSError *)>::~__value_func[abi:ne180100](v29);
    id v12 = v24;
    if (v24)
    {
      uint64_t v13 = (__CFString *)v24;
      int v14 = LogObj(4);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(v29[0].fString.fRef) = 138543362;
        *(__CFString **)((char *)&v29[0].fString.fRef + 4) = v13;
        _os_log_impl(&dword_1D343E000, v14, OS_LOG_TYPE_DEFAULT, "Found FPItem %{public}@", (uint8_t *)v29, 0xCu);
      }

      TNodePtr::TNodePtr(&v23, this);
      TNodePtr::TNodePtr(&v27, (id *)&v23.fFINode);
      uint64_t v15 = v13;
      uint64_t v28 = v15;
      memset(v29, 0, 24);
      *(void *)long long buf = v29;
      uint8_t buf[8] = 0;
      v29[0].fString.int fRef = (__CFString *)operator new(0x10uLL);
      v29[1] = v29[0];
      v29[2].fString.int fRef = (__CFString *)&v29[0].fString.fRef->data;
      v29[1].fString.int fRef = (__CFString *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}>*>((uint64_t)&v29[2], &v27, (id *)&v29[0].fString.fRef, &v29[0].fString.fRef->isa);
      TNode::AttachFPItemsMetadata(v29, 1, 1);
      *(void *)long long buf = v29;
      std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);

      uint64_t v8 = TNode::FPItemsCollection(this, (FPItem *)v15);
      if (v8)
      {
        unint64_t v16 = LogObj(4);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(v29[0].fString.fRef) = 138543362;
          *(__CFString **)((char *)&v29[0].fString.fRef + 4) = v15;
          _os_log_impl(&dword_1D343E000, v16, OS_LOG_TYPE_DEFAULT, "Found collection after lookup of FPItem %{public}@", (uint8_t *)v29, 0xCu);
        }
      }
    }
    else
    {
      LogObj(4);
      uint64_t v15 = (__CFString *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_ERROR))
      {
        SanitizedURL(v6);
        uint64_t v17 = (__CFString *)objc_claimAutoreleasedReturnValue();
        char v18 = (__CFString *)v25;
        LODWORD(v29[0].fString.fRef) = 138543618;
        *(__CFString **)((char *)&v29[0].fString.fRef + 4) = v17;
        WORD2(v29[1].fString.fRef) = 2114;
        *(__CFString **)((char *)&v29[1].fString.fRef + 6) = v18;
        _os_log_impl(&dword_1D343E000, (os_log_t)v15, OS_LOG_TYPE_ERROR, "Unable to find FPItem for URL '%{public}@' state of folder may be stale. %{public}@", (uint8_t *)v29, 0x16u);
      }
      uint64_t v8 = 0;
    }
  }
  if (v8)
  {
    [v8 setShowHiddenFiles:1];
    id v19 = v8;
  }
  else if (v9 && [(__CFString *)v9 code] != 22)
  {
    id v21 = LogObj(4);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      SanitizedURL(v6);
      int v22 = (__CFString *)objc_claimAutoreleasedReturnValue();
      LODWORD(v29[0].fString.fRef) = 138543618;
      *(__CFString **)((char *)&v29[0].fString.fRef + 4) = v22;
      WORD2(v29[1].fString.fRef) = 2114;
      *(__CFString **)((char *)&v29[1].fString.fRef + 6) = v9;
      _os_log_impl(&dword_1D343E000, v21, OS_LOG_TYPE_ERROR, "Unable to load collection for url %{public}@ with error: %{public}@", (uint8_t *)v29, 0x16u);
    }
  }

  return v8;
}

void sub_1D34DB904(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id *std::pair<TNodePtr,FPItem * {__strong}>::~pair(id *a1)
{
  return a1;
}

uint64_t TNode::GetNodeFromBookmarkData(uint64_t *a1, void **a2, char a3)
{
  TNodePtr::TNodePtr(&v13, 0);
  TNodePtr::operator=(a2, (void **)&v13.fFINode);

  uint64_t v6 = *a1;
  if (*a1)
  {
    v13.fFINode = 0;
    BOOL v7 = (const void *)MEMORY[0x1D9435EF0](*MEMORY[0x1E4F1CF80], v6, ((a3 & 3) << 8) ^ 0x100u, 0, 0, 0, &v13);
    id v12 = v7;
    if (v13.fFINode)
    {
      CFIndex NodeFromURL = TCFURLInfo::TranslateCFError((TCFURLInfo *)v13.fFINode, v8);
      if (NodeFromURL)
      {
LABEL_9:
        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v12);
        TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)&v13.fFINode);
        return NodeFromURL;
      }
      BOOL v7 = v12;
    }
    else if (!v7)
    {
      CFIndex NodeFromURL = 4294959232;
      goto LABEL_9;
    }
    int v11 = v7;
    CFIndex NodeFromURL = TNode::GetNodeFromURL(&v11, a2, 0);
    goto LABEL_9;
  }
  return 4294959236;
}

void sub_1D34DBB5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, const void *);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va);
  TAutoRef<__CFError *,TRetainReleasePolicy<__CFError *>>::~TAutoRef((const void **)va1);
  _Unwind_Resume(a1);
}

BOOL TNode::EqualDisplayName(TNode *this, const TString *a2)
{
  TNode::DisplayName(this, (TString *)&cf1);
  BOOL v3 = CFEqual(cf1, a2->fString.fRef) != 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
  return v3;
}

void sub_1D34DBBD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TNode::MarkAsUsed(TNode *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v2);
  uint64_t v4 = (TFSInfo *)*((void *)this + 2);
  BOOL v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v2);
  TFSInfo::MarkAsUsed(v4);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
}

void sub_1D34DBC68(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void TNode::AddVolumeToSuperRoot(TNode *this, TNodePtr *a2)
{
  TGlobalNodes::RootNode((uint64_t *)&v8, (TGlobalNodes *)this);
  BOOL v7 = 0;
  TNode::StPopulating::StPopulating((TNode::StPopulating *)v6, &v8, 0);
  BOOL v3 = (TNode *)TNodeFromFINode(v8.fFINode);
  TNode::AddNewChild((uint64_t *)&v5, v3, (const TNodePtr *)this, &v7, 0, 1);
  TNodePtr::operator=((void **)this, &v5);

  TNode::StPopulating::~StPopulating(v6);
  if (v7)
  {
    uint64_t v4 = (const TNode *)TNodeFromFINode(v8.fFINode);
    TNode::SendNotification(v4, 3, (id *)this, 0, 0);
  }
}

void sub_1D34DBD2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TNode::AddVolume(TCFURLInfo *a1, char a2, void **a3)
{
  TNodePtr::TNodePtr(&v47, 0);
  TNodePtr::operator=(a3, (void **)&v47.fFINode);

  TGlobalNodes::RootNode((uint64_t *)&v49, v6);
  v47.fFINode = 0;
  v48 = 0;
  uint64_t v7 = TFSVolumeInfo::AddVolume(a1, a2, (uint64_t *)&v47);
  uint64_t v8 = v7;
  if (v7 && v7 != -8057)
  {
    TNodePtr::TNodePtr(&v46, 0);
    TNodePtr::operator=(a3, (void **)&v46.fFINode);
  }
  else
  {
    Class isa = v47.fFINode[7].super.isa;
    uint64_t v9 = (std::__shared_weak_count *)v47.fFINode[8].super.isa;
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (!isa)
    {
LABEL_12:
      if (!v9) {
        goto LABEL_15;
      }
      goto LABEL_13;
    }
    os_unfair_lock_lock((os_unfair_lock_t)isa + 25);
    int v11 = (FINode *)*((void *)isa + 2);
    v45.fFINode = v11;
    if (v11) {
      CFRetain(v11);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)isa + 25);
    v46.fFINode = v45.fFINode;
    int NodeFromURL = TNode::GetNodeFromURL(&v46, a3, 0);
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v45.fFINode);
    if (NodeFromURL)
    {
      TNodePtr::TNodePtr(&v46, 0);
      TNodePtr::operator=(a3, (void **)&v46.fFINode);
LABEL_10:

LABEL_11:
      TNodePtr::TNodePtr(&v46, 0);
      TNodePtr::operator=(a3, (void **)&v46.fFINode);

      uint64_t v8 = 4294967253;
      goto LABEL_12;
    }
    uint64_t v14 = TNodeFromFINode((FINode *)*a3);
    uint64_t v15 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v14);
    os_unfair_lock_lock(v15);
    TNodePtr::TNodePtr(&v46, *(const TNode **)(v14 + 48));
    os_unfair_lock_unlock(v15);
    if (TNodeFromFINode(v46.fFINode))
    {
      unint64_t v16 = (TNode *)TNodeFromFINode(v46.fFINode);
      TNode::SetPrefetchPropertiesOnSync(v16);
    }
    uint64_t v17 = TNodeFromFINode((FINode *)*a3);
    char v18 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v17);
    os_unfair_lock_lock(v18);
    uint64_t v20 = *(void *)(v17 + 16);
    id v19 = *(std::__shared_weak_count **)(v17 + 24);
    if (v19) {
      atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v18);
    id v21 = (os_unfair_lock_s *)(v20 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v20 + 100));
    int v22 = *(_DWORD *)(v20 + 115);
    os_unfair_lock_unlock(v21);
    if (v19) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v19);
    }
    if ((v22 & 0x100) == 0)
    {
      int v23 = 10;
      do
      {
        uint64_t v24 = TNodeFromFINode((FINode *)*a3);
        id v25 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v24);
        os_unfair_lock_lock(v25);
        TNodePtr::TNodePtr(&v45, *(const TNode **)(v24 + 48));
        os_unfair_lock_unlock(v25);
        TNodePtr::operator=((void **)&v46.fFINode, (void **)&v45.fFINode);

        if (TNodeFromFINode(v46.fFINode))
        {
          id v26 = (TNode *)TNodeFromFINode(v46.fFINode);
          TNode::SetPrefetchPropertiesOnSync(v26);
          uint64_t v27 = TNodeFromFINode(v46.fFINode);
          TNode::HandleSync(v27, 0x11000000u);
        }
        usleep(0x186A0u);
        os_unfair_lock_lock((os_unfair_lock_t)isa + 25);
        uint64_t v28 = (FINode *)*((void *)isa + 2);
        v44 = v28;
        if (v28) {
          CFRetain(v28);
        }
        os_unfair_lock_unlock((os_unfair_lock_t)isa + 25);
        v45.fFINode = v44;
        int v29 = TNode::GetNodeFromURL(&v45, a3, 0);
        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v44);
        if (v29) {
          goto LABEL_10;
        }
        uint64_t v30 = TNodeFromFINode((FINode *)*a3);
        uint64_t v31 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v30);
        os_unfair_lock_lock(v31);
        uint64_t v33 = *(void *)(v30 + 16);
        uint64_t v32 = *(std::__shared_weak_count **)(v30 + 24);
        if (v32) {
          atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        os_unfair_lock_unlock(v31);
        int v34 = (os_unfair_lock_s *)(v33 + 100);
        os_unfair_lock_lock((os_unfair_lock_t)(v33 + 100));
        int v35 = *(_DWORD *)(v33 + 115);
        os_unfair_lock_unlock(v34);
        if (v32) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v32);
        }
        BOOL v36 = v23-- != 0;
      }
      while ((v35 & 0x100) == 0 && v23 != 0 && v36);
    }

    if (!TNodeFromFINode((FINode *)*a3)) {
      goto LABEL_11;
    }
    uint64_t v37 = TNodeFromFINode((FINode *)*a3);
    char v38 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v37);
    os_unfair_lock_lock(v38);
    uint64_t v40 = *(void *)(v37 + 16);
    char v39 = *(std::__shared_weak_count **)(v37 + 24);
    if (v39) {
      atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v38);
    uint64_t v41 = (os_unfair_lock_s *)(v40 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v40 + 100));
    int v42 = *(_DWORD *)(v40 + 115);
    os_unfair_lock_unlock(v41);
    if (v39) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v39);
    }
    if ((v42 & 0x100) == 0) {
      goto LABEL_11;
    }
    uint64_t v43 = TNodeFromFINode((FINode *)*a3);
    TNode::SetVolumeInfo(v43, (uint64_t *)&v47);
    uint64_t v8 = 0;
    if (v9) {
LABEL_13:
    }
      std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
LABEL_15:
  if (v48) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v48);
  }

  return v8;
}

void sub_1D34DC150(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, void *a14)
{
  os_unfair_lock_unlock(v15);
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  }
  if (a13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a13);
  }

  _Unwind_Resume(a1);
}

uint64_t TNode::RemoveVolume(const void **a1)
{
  uint64_t v1 = *a1;
  int v11 = v1;
  if (v1) {
    CFRetain(v1);
  }
  TNode::GetVolumeNode((TGlobalNodes *)&v11, (TNodePtr *)&v12);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v11);
  if (TNodeFromFINode(v12)
    && (uint64_t v2 = TNodeFromFINode(v12),
        BOOL v3 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v2),
        os_unfair_lock_lock(v3),
        TNodePtr::TNodePtr(&v10, *(const TNode **)(v2 + 48)),
        os_unfair_lock_unlock(v3),
        uint64_t v4 = TNodeFromFINode(v10.fFINode),
        v10.fFINode,
        v4))
  {
    uint64_t v5 = TNodeFromFINode(v12);
    uint64_t v6 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v5);
    os_unfair_lock_lock(v6);
    TNodePtr::TNodePtr(&v10, *(const TNode **)(v5 + 48));
    os_unfair_lock_unlock(v6);
    uint64_t v7 = TNodeFromFINode(v10.fFINode);
    TNode::HandleSync(v7, 0x1000000u);

    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v8 = 4294959240;
  }

  return v8;
}

void sub_1D34DC300(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, void *a12)
{
  TNodePtr v13 = v12;
  os_unfair_lock_unlock(v13);

  _Unwind_Resume(a1);
}

void TNode::HandleFolderSizingRequests(id **a1)
{
  uint64_t v20 = (FINode *)**a1;
  if (TNode::IsContextOpen((TNode *)v20))
  {
    uint64_t v2 = TNodeFromFINode(v20);
    BOOL v3 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v2);
    os_unfair_lock_lock(v3);
    uint64_t v5 = *(void *)(v2 + 16);
    uint64_t v4 = *(std::__shared_weak_count **)(v2 + 24);
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v3);
    uint64_t v6 = (os_unfair_lock_s *)(v5 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v5 + 100));
    int v7 = *(_DWORD *)(v5 + 115);
    os_unfair_lock_unlock(v6);
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    }
    if ((v7 & 0x20) != 0)
    {
      uint64_t v9 = TTime::MicrosecondsSinceStartup(v8);
      uint64_t v10 = TNodeFromFINode(v20);
      int v11 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v10);
      os_unfair_lock_lock(v11);
      id v12 = *(std::__shared_weak_count **)(v10 + 24);
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v11);
      TNodePtr v13 = (TNode *)TNodeFromFINode(v20);
      uint64_t v14 = TNode::AdjustedResizeQuanta(v13);
      uint64_t v15 = TNodeFromFINode(v20);
      uint64_t v16 = TChildrenList::LastResizeTime(*(TChildrenList **)(v15 + 56)) + v14;
      if (v9 >= v16
        && (uint64_t v17 = (TNode *)TNodeFromFINode(v20), TNode::IsSynchingAppropriate(v17))
        && (int v18 = atomic_load((unsigned int *)(*(void *)(TNodeFromFINode(v20) + 56) + 196)), v18 <= 1))
      {
        TNode::HandleFolderSizingRequest(a1);
      }
      else
      {
        if (v9 >= v16) {
          uint64_t v19 = v9 + 2000000;
        }
        else {
          uint64_t v19 = v16;
        }
        TNode::SetTimerToDispatchResizeRequest(a1, v19);
      }
      if (v12) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v12);
      }
    }
  }
}

void sub_1D34DC4DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void TNode::HandleFolderSizingRequest(id **a1)
{
  uint64_t v2 = (FINode *)**a1;
  char v38 = v2;
  if (TNodeFromFINode(v2))
  {
    atomic_fetch_and((atomic_ushort *volatile)(TNodeFromFINode(v2) + 80), 0xFFBFu);
    if (*((_DWORD *)*a1 + 13) != 1003)
    {
      TNodeTask::SetRequestStatus((TNodeTask *)*a1, 1002);
      BOOL v3 = v38;
      uint64_t v4 = TNodeFromFINode(v38);
      uint64_t v5 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v4);
      os_unfair_lock_lock(v5);
      uint64_t v7 = *(void *)(v4 + 16);
      uint64_t v6 = *(std::__shared_weak_count **)(v4 + 24);
      if (v6) {
        atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v5);
      uint64_t v8 = (os_unfair_lock_s *)(v7 + 100);
      os_unfair_lock_lock((os_unfair_lock_t)(v7 + 100));
      int v9 = *(_DWORD *)(v7 + 115);
      os_unfair_lock_unlock(v8);
      if (v6) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v6);
      }
      if ((v9 & 0x20) != 0)
      {
        uint64_t v10 = TNodeFromFINode(v38);
        int v11 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v10);
        os_unfair_lock_lock(v11);
        uint64_t v13 = *(void *)(v10 + 16);
        id v12 = *(std::__shared_weak_count **)(v10 + 24);
        if (v12) {
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        os_unfair_lock_unlock(v11);
        uint64_t v14 = (os_unfair_lock_s *)(v13 + 100);
        os_unfair_lock_lock((os_unfair_lock_t)(v13 + 100));
        int v15 = *(_DWORD *)(v13 + 115);
        os_unfair_lock_unlock(v14);
        if (v12) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v12);
        }
        if ((v15 & 0x100) != 0)
        {
          int v22 = (TNode *)TNodeFromFINode(v38);
          TNode::RecalculateFreeSpaceAndCapacity(v22, 1);
          int v23 = (TNode *)TNodeFromFINode(v38);
          TNode::SetSizesAreValid(v23, 1);
          goto LABEL_27;
        }
        uint64_t v16 = (TNode *)TNodeFromFINode(v38);
        if (!TNode::SynchingSuspended(v16))
        {
          uint64_t v17 = TNodeFromFINode(v38);
          int v18 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v17);
          os_unfair_lock_lock(v18);
          TNodePtr::TNodePtr(&v35, *(const TNode **)(v17 + 48));
          os_unfair_lock_unlock(v18);
          if (TNodeFromFINode(v35.fFINode))
          {
            uint64_t v19 = TNodeFromFINode(v3);
            uint64_t v20 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v19);
            os_unfair_lock_lock(v20);
            TNodePtr::TNodePtr(&v37, *(const TNode **)(v19 + 48));
            os_unfair_lock_unlock(v20);
            id v21 = (TNode *)TNodeFromFINode(v37.fFINode);
            LODWORD(v19) = atomic_load((unsigned int *)(TNode::GetNotifierList(v21) + 4));

            BOOL v3 = v38;
            if ((int)v19 > 0)
            {
LABEL_21:
              uint64_t v27 = (TTime *)TNodeFromFINode(v3);
              uint64_t v28 = (TChildrenList *)*((void *)v27 + 7);
              uint64_t v29 = TTime::MicrosecondsSinceStartup(v27);
              TChildrenList::SetLastResizeTime(v28, v29);
              uint64_t v30 = TNodeFromFINode(v3);
              uint64_t v31 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v30);
              os_unfair_lock_lock(v31);
              TNodePtr::TNodePtr(&v37, *(const TNode **)(v30 + 48));
              os_unfair_lock_unlock(v31);
              std::allocate_shared[abi:ne180100]<TFSInfoSizer,std::allocator<TFSInfoSizer>,TNodePtr &,TNodePtr,std::shared_ptr<TNodeTask> const&,void>((uint64_t)&v38, (uint64_t)&v37, (uint64_t)a1, &v35);

              fFINode = v35.fFINode;
              uint64_t v33 = v35.fFINode;
              int v34 = v36;
              if (v36) {
                atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              TFSInfoSizer::SizeFolder((uint64_t)fFINode, (uint64_t)&v33);
              if (v34) {
                std::__shared_weak_count::__release_shared[abi:ne180100](v34);
              }
              if (v36) {
                std::__shared_weak_count::__release_shared[abi:ne180100](v36);
              }
              goto LABEL_27;
            }
          }
          else
          {
          }
          uint64_t v24 = (TNode *)TNodeFromFINode(v3);
          int v25 = atomic_load((unsigned int *)(TNode::GetNotifierList(v24) + 4));
          BOOL v3 = v38;
          if (v25 <= 0)
          {
            uint64_t v26 = TNodeFromFINode(v38);
            if (!TNode::IsDeferredForSymlink(v26, (uint64_t (*)(void *))TFSInfo::IsPackage, 0))goto LABEL_27; {
          }
            }
          goto LABEL_21;
        }
      }
    }
  }
LABEL_27:
}

void sub_1D34DC82C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15)
{
  os_unfair_lock_unlock(v15);

  _Unwind_Resume(a1);
}

uint64_t TNode::GetCachedPackageSize(TNode *this)
{
  return -2;
}

uint64_t TNode::SizingGeneration(TNode *this)
{
  SizingGenerationMutex();
  TDSMutex::lock(&SizingGenerationMutex(void)::sMutex);
  uint64_t v2 = *((void *)this + 7);
  if (v2) {
    uint64_t v3 = *(unsigned int *)(v2 + 180);
  }
  else {
    uint64_t v3 = 0;
  }
  TDSMutex::unlock(&SizingGenerationMutex(void)::sMutex);
  return v3;
}

void SizingGenerationMutex(void)
{
  {
    TDSMutex::TDSMutex(&SizingGenerationMutex(void)::sMutex, 0);
  }
}

void sub_1D34DC99C(_Unwind_Exception *a1)
{
}

void TNode::SetSizeProperties(TNode *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  uint64_t v31 = (uint64_t *)&v32;
  SizingGenerationMutex();
  id v12 = (TNode *)TDSMutex::lock(&SizingGenerationMutex(void)::sMutex);
  uint64_t v13 = *((void *)this + 7);
  if (v13)
  {
    int v14 = *(_DWORD *)(v13 + 180);
    if (a6 < 0 || v14 <= a6)
    {
      *(_DWORD *)(v13 + 180) = v14 + 1;
      int v15 = (os_unfair_lock_s *)TNode::InfoLock(v12);
      os_unfair_lock_lock(v15);
      uint64_t v17 = *((void *)this + 2);
      uint64_t v16 = (std::__shared_weak_count *)*((void *)this + 3);
      if (v16) {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v15);
      int v18 = (os_unfair_lock_s *)(v17 + 96);
      os_unfair_lock_lock((os_unfair_lock_t)(v17 + 96));
      uint64_t v19 = *(os_unfair_lock_s **)(v17 + 80);
      if (v19)
      {
        TFSInfoOverflow::FolderSizeRecord(v19, (uint64_t)v34);
        if (v35) {
          uint64_t v20 = v34[3];
        }
        else {
          uint64_t v20 = -1;
        }
      }
      else
      {
        uint64_t v20 = -1;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(v17 + 96));
      if (v20 != a5)
      {
        LODWORD(v34[0]) = 1685480308;
        std::__tree<Property>::__emplace_unique_key_args<Property,Property>(&v31, (unsigned int *)v34, v34);
      }
      os_unfair_lock_lock((os_unfair_lock_t)(v17 + 96));
      id v21 = *(os_unfair_lock_s **)(v17 + 80);
      if (v21)
      {
        TFSInfoOverflow::FolderSizeRecord(v21, (uint64_t)v34);
        if (v35) {
          uint64_t v22 = v34[2];
        }
        else {
          uint64_t v22 = -1;
        }
      }
      else
      {
        uint64_t v22 = -1;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(v17 + 96));
      if (v22 != a4)
      {
        LODWORD(v34[0]) = 1684237940;
        std::__tree<Property>::__emplace_unique_key_args<Property,Property>(&v31, (unsigned int *)v34, v34);
      }
      os_unfair_lock_lock((os_unfair_lock_t)(v17 + 96));
      int v23 = *(os_unfair_lock_s **)(v17 + 80);
      if (v23)
      {
        TFSInfoOverflow::FolderSizeRecord(v23, (uint64_t)v34);
        if (v35) {
          uint64_t v24 = v34[1];
        }
        else {
          uint64_t v24 = -1;
        }
      }
      else
      {
        uint64_t v24 = -1;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(v17 + 96));
      if (v24 != a3)
      {
        LODWORD(v34[0]) = 1885895027;
        std::__tree<Property>::__emplace_unique_key_args<Property,Property>(&v31, (unsigned int *)v34, v34);
      }
      os_unfair_lock_lock((os_unfair_lock_t)(v17 + 96));
      int v25 = *(os_unfair_lock_s **)(v17 + 80);
      if (v25 && (TFSInfoOverflow::FolderSizeRecord(v25, (uint64_t)v34), v35)) {
        uint64_t v26 = v34[0];
      }
      else {
        uint64_t v26 = -1;
      }
      os_unfair_lock_unlock(v18);
      if (v26 != a2)
      {
        LODWORD(v34[0]) = 1819240307;
        std::__tree<Property>::__emplace_unique_key_args<Property,Property>(&v31, (unsigned int *)v34, v34);
      }
      if (v33) {
        operator new();
      }
      TNode::SetSizesAreValid(this, 1);
      uint64_t v28 = (os_unfair_lock_s *)TNode::InfoLock(v27);
      os_unfair_lock_lock(v28);
      uint64_t v30 = *((void *)this + 2);
      uint64_t v29 = (std::__shared_weak_count *)*((void *)this + 3);
      if (v29)
      {
        atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
        os_unfair_lock_unlock(v28);
        os_unfair_lock_lock((os_unfair_lock_t)(v30 + 100));
        *(_DWORD *)(v30 + 115) |= 0x8000000u;
        os_unfair_lock_unlock((os_unfair_lock_t)(v30 + 100));
        std::__shared_weak_count::__release_shared[abi:ne180100](v29);
        if (!v16)
        {
LABEL_39:
          TDSMutex::unlock(&SizingGenerationMutex(void)::sMutex);
          TNode::SendNotifications(this, &v31);
          goto LABEL_40;
        }
      }
      else
      {
        os_unfair_lock_unlock(v28);
        os_unfair_lock_lock((os_unfair_lock_t)(v30 + 100));
        *(_DWORD *)(v30 + 115) |= 0x8000000u;
        os_unfair_lock_unlock((os_unfair_lock_t)(v30 + 100));
        if (!v16) {
          goto LABEL_39;
        }
      }
      std::__shared_weak_count::__release_shared[abi:ne180100](v16);
      goto LABEL_39;
    }
  }
  TDSMutex::unlock(&SizingGenerationMutex(void)::sMutex);
LABEL_40:
  std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::destroy((uint64_t)&v31, v32);
}

void sub_1D34DCD50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  TDSMutex::unlock(&SizingGenerationMutex(void)::sMutex);
  std::__tree<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::__map_value_compare<std::pair<__SFBrowser *,__SFNode *>,std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>,std::less<std::pair<__SFBrowser *,__SFNode *>>,true>,std::allocator<std::__value_type<std::pair<__SFBrowser *,__SFNode *>,int>>>::destroy((uint64_t)&a9, a10);
  _Unwind_Resume(a1);
}

uint64_t ___ZNK5TNode19PostNodeTaskRequestERKNSt3__110shared_ptrI9TNodeTaskEE_block_invoke(uint64_t a1)
{
  return TNode::HandleVolumeAdded(a1 + 32, *(_DWORD *)(a1 + 48) == 1024);
}

uint64_t __copy_helper_block_ea8_32c75_ZTSKZNK5TNode19PostNodeTaskRequestERKNSt3__110shared_ptrI9TNodeTaskEEE3__0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 48);
  return result;
}

void __destroy_helper_block_ea8_32c75_ZTSKZNK5TNode19PostNodeTaskRequestERKNSt3__110shared_ptrI9TNodeTaskEEE3__0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

uint64_t TNode::HandleFetchProperty(uint64_t a1, FINode **a2)
{
  uint64_t v3 = *(unsigned int *)(*(void *)a1 + 20);
  uint64_t v4 = (unsigned int *)(*(void *)a1 + 24);
  v13.fData.__impl_.__data.__tail.__tail.__tail.__tail.__head.__value = 0;
  unsigned int v5 = TPropertyValue::As<NodeRequestOptions>(v4, (unsigned int *)&v13) & 0xFFFFFFFD;
  uint64_t v6 = (TNode *)TNodeFromFINode(*a2);
  TNode::UpdatePropertySynchronous(v6, v3, v5, 1);
  uint64_t Property = 0;
  if (v3 != 1718903156)
  {
    v13.fData.__impl_.__index = 0;
    int v12 = 19;
    int v11 = &v13;
    uint64_t v8 = TNodeFromFINode(*a2);
    uint64_t v10 = 0;
    uint64_t Property = TNode::GetProperty(v8, v3, (TPropertyReference *)&v11, &v10, v5);
    TPropertyValue::~TPropertyValue(&v13);
  }
  return Property;
}

void sub_1D34DCFD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, TPropertyValue *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

uint64_t TNode::HandleStoreProperty(uint64_t a1, FINode **a2)
{
  uint64_t v3 = *(void *)a1 + 24;
  uint64_t v4 = TNodeFromFINode(*a2);
  int v5 = *(_DWORD *)(*(void *)a1 + 20);
  int v9 = 19;
  uint64_t v7 = 0;
  uint64_t v8 = v3;
  return TNode::SetProperty(v4, v5, (const TPropertyReference *)&v8, &v7, 1, 0);
}

uint64_t TNode::HandleResolveAlias(id **a1, FINode **a2)
{
  id obj = 0;
  uint64_t v4 = (unsigned int *)(*a1 + 3);
  LODWORD(v11) = 0;
  int v5 = TPropertyValue::As<NodeRequestOptions>(v4, (unsigned int *)&v11);
  uint64_t v6 = (TNode *)TNodeFromFINode(*a2);
  int v11 = 0;
  LODWORD(v7) = TNode::FollowAlias(v6, (TNodePtr *)&obj, &v11, v5 & 0xFFFF7FFF);
  if (TNodeFromFINode((FINode *)obj)) {
    uint64_t v7 = v7;
  }
  else {
    uint64_t v7 = 4294959232;
  }
  if (!v7) {
    objc_storeStrong(*a1, obj);
  }
  uint64_t v8 = (const TNode *)TNodeFromFINode(*a2);
  if (v7) {
    int v9 = 24;
  }
  else {
    int v9 = 21;
  }
  TNode::SendNotification(v8, v9, (id *)a2, 0, v7);

  return v7;
}

void sub_1D34DD110(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

CFIndex TNode::HandleFetchBookmarkData(uint64_t *a1, TNodePtr *a2)
{
  uint64_t v19 = 0;
  uint64_t v4 = TNodeFromFINode(a2->fFINode);
  int v5 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v4);
  os_unfair_lock_lock(v5);
  uint64_t v7 = *(TFSInfo **)(v4 + 16);
  uint64_t v6 = *(std::__shared_weak_count **)(v4 + 24);
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v5);
  CFIndex v8 = TFSInfo::CopyBookmarkDataTo(v7, &v19);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  if (v8) {
    BOOL v9 = 1;
  }
  else {
    BOOL v9 = v19 == 0;
  }
  if (v9)
  {
    memset(&v17, 0, sizeof(v17));
    uint64_t v16 = 0;
    TNodeEvent::CreateNodeEvent(25, (id *)&a2->fFINode, 0, &v17, a1, &v16, &v18);
    TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v16);
    TPropertyValue::~TPropertyValue(&v17);
    uint64_t v10 = (TNodeEvent *)TNodeEventPtr::operator->(&v18);
    int v12 = v14;
    TNodeEvent::NotifyNode(v14, v10, a2, 1);
  }
  else
  {
    TNodeFromFINode(a2->fFINode);
    TPropertyValue::TPropertyValue<__CFData const*>((uint64_t)&v17, (const void **)&v19);
    uint64_t v16 = 0;
    TNodeEvent::CreateNodeEvent(25, (id *)&a2->fFINode, 0, &v17, a1, &v16, &v18);
    TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v16);
    TPropertyValue::~TPropertyValue(&v17);
    int v11 = (TNodeEvent *)TNodeEventPtr::operator->(&v18);
    int v12 = v15;
    TNodeEvent::NotifyNode(v15, v11, a2, 1);
  }
  v17.fData.__impl_.__data.__tail.__tail.__tail.__tail.__tail.__head.__value = (int64_t)v12;
  std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v17);
  TNodeEventPtr::~TNodeEventPtr(&v18);
  TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef((const void **)&v19);
  return v8;
}

void sub_1D34DD2B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7, TPropertyValue *a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, TDSNotifier *a15, uint64_t a16)
{
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&a15);
  TPropertyValue::~TPropertyValue((TPropertyValue *)&a16);
  TAutoRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TAutoRef((const void **)(v16 - 56));
  _Unwind_Resume(a1);
}

uint64_t TNode::HandleFetchNodeRequest(id **a1)
{
  id obj = 0;
  v15.fString.int fRef = 0;
  uint64_t v2 = (TString *)TPropertyValue::As<__CFString const*>((const void **)*a1 + 3, (void **)&v15.fString.fRef);
  uint64_t v3 = (uint64_t *)(*a1 + 3);
  v15.fString.int fRef = 0;
  uint64_t v4 = TPropertyValue::As<__CFURL const*>(v3, (uint64_t **)&v15);
  TPropertyValue v13 = v4;
  int v5 = (uint64_t *)(*a1 + 3);
  v15.fString.int fRef = 0;
  uint64_t v6 = TPropertyValue::As<__CFData const*>(v5, (uint64_t **)&v15);
  int v12 = v6;
  uint64_t v7 = *a1;
  if (v2)
  {
    v15.fString.int fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(&v15, v2);
    uint64_t NodeFromPath = TNode::GetNodeFromPath(&v15);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
    if (!NodeFromPath) {
      goto LABEL_9;
    }
  }
  else
  {
    if (v4)
    {
      uint64_t NodeFromURL = TNode::GetNodeFromURL(&v13, &obj, *((unsigned int *)*a1 + 12));
    }
    else
    {
      if (!v6)
      {
        id v10 = 0;
        goto LABEL_10;
      }
      uint64_t NodeFromURL = TNode::GetNodeFromBookmarkData((uint64_t *)&v12, &obj, *((_DWORD *)*a1 + 12));
    }
    uint64_t NodeFromPath = NodeFromURL;
    if (!NodeFromURL)
    {
LABEL_9:
      uint64_t v7 = *a1;
      id v10 = obj;
LABEL_10:
      objc_storeStrong(v7, v10);
      uint64_t NodeFromPath = 0;
    }
  }

  return NodeFromPath;
}

void sub_1D34DD434(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

uint64_t TNode::HandleDisconnectShareRequest(uint64_t a1, FINode **a2)
{
  uint64_t v3 = TNodeFromFINode(*a2);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = TNode::OpenServerSync(v3);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return v5;
}

void sub_1D34DD4C8(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TNode::HandleAddServerToSidebarRequest(uint64_t a1, FINode **a2)
{
  uint64_t v3 = TNodeFromFINode(*a2);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = TNode::AddServerToSidebarSync(v3);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return v5;
}

void sub_1D34DD534(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TNode::HandleRemoveServerFromSidebarRequest(uint64_t a1, FINode **a2)
{
  uint64_t v3 = TNodeFromFINode(*a2);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = TNode::AddServerToSidebarSync(v3);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return v5;
}

void sub_1D34DD5A0(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TNode::HandleOpenScreenShareRequest(uint64_t a1, FINode **a2)
{
  uint64_t v3 = TNodeFromFINode(*a2);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = TNode::OpenScreenShareSync(v3);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return v5;
}

void sub_1D34DD60C(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TNode::HandleOpenServerRequest(uint64_t a1, FINode **a2)
{
  uint64_t v3 = TNodeFromFINode(*a2);
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = TNode::OpenServerSync(v3);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return v5;
}

void sub_1D34DD678(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void TNode::HandleFPProviderError(uint64_t a1, FINode **a2)
{
  uint64_t v3 = (const TNode *)TNodeFromFINode(*a2);
  TNode::SendNotification(v3, 2, (id *)a2, 1969385844, 0);
}

uint64_t TNode::HandleVolumeAdded(uint64_t a1, int a2)
{
  BOOL v9 = 0;
  id v10 = 0;
  uint64_t v3 = TPropertyValue::As<__CFURL const*>((uint64_t *)(*(void *)a1 + 24), (uint64_t **)&v10);
  if (v3)
  {
    uint64_t v5 = TNode::AddVolume((TCFURLInfo *)v3, 0, &v9);
    if (!v5)
    {
      TNode::AddVolumeToSuperRoot((TNode *)&v9, v4);
      if (a2)
      {
        TGlobalNodes::RootNode((uint64_t *)&v10, v6);
        uint64_t v7 = (const TNode *)TNodeFromFINode(v10);
        TNode::SendNotification(v7, 10, &v9, 0, 0);
      }
      uint64_t v5 = 0;
    }
  }
  else
  {
    uint64_t v5 = 4294967253;
  }

  return v5;
}

void sub_1D34DD780(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

uint64_t TNode::HandleMarkAsUsed(uint64_t a1, FINode **a2)
{
  uint64_t v3 = TNodeFromFINode(*a2);
  uint64_t v4 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v3);
  os_unfair_lock_lock(v4);
  uint64_t v6 = *(void *)(v3 + 16);
  uint64_t v5 = *(std::__shared_weak_count **)(v3 + 24);
  if (!v5)
  {
    os_unfair_lock_unlock(v4);
    if (*(unsigned char *)(v6 + 112)) {
      return 0;
    }
    goto LABEL_3;
  }
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  os_unfair_lock_unlock(v4);
  int v7 = *(unsigned __int8 *)(v6 + 112);
  std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  if (!v7)
  {
LABEL_3:
    CFIndex v8 = (TNode *)TNodeFromFINode(*a2);
    TNode::MarkAsUsed(v8);
  }
  return 0;
}

uint64_t TNode::HandleSubscribeWithKQueue(uint64_t a1, FINode **a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  TPropertyValue v13 = 0;
  uint64_t v2 = (TNode *)TNodeFromFINode(*a2);
  *(void *)int v14 = 0;
  uint64_t v3 = TNode::FollowAlias(v2, (TNodePtr *)&v13, (TNodeRequest **)v14, 8);
  if (!v3)
  {
    if (TNodeFromFINode(v13)
      && (v4 = TNodeFromFINode(v13), (uint64_t v5 = *(TChildrenList **)(v4 + 56)) != 0)
      && !TChildrenList::IncrementSubscriptionCount(*(TChildrenList **)(v4 + 56)))
    {
      int v7 = (TNode *)TNodeFromFINode(v13);
      uint64_t v3 = TNode::CopyPathToCBuffer(v7, v14, 1024);
      if (!v3)
      {
        int v8 = open(v14, 0x8000, 0);
        if (v8 >= 1)
        {
          BOOL v9 = (TNode *)TChildrenList::SetSubscriptionFileDescriptor(v5, v8);
          TNode::AddkQueueNotification(v9);
          changelist.ident = v8;
          *(void *)&changelist.filter = 0x2B0025FFFCLL;
          changelist.data = 0;
          changelist.udata = (void *)TNodeFromFINode(v13);
          timeout.tv_sec = 0;
          timeout.tv_nsec = 0;
          int v10 = TNode::KQueue((TNode *)changelist.udata);
          kevent(v10, &changelist, 1, 0, 0, &timeout);
        }
      }
    }
    else
    {
      uint64_t v3 = 0;
    }
  }

  return v3;
}

void sub_1D34DD984(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

uint64_t TNode::HandleUnsubscribeWithKQueue(uint64_t a1, FINode **a2)
{
  v13.fFINode = 0;
  uint64_t v2 = (TNode *)TNodeFromFINode(*a2);
  changelist.ident = 0;
  uint64_t v3 = TNode::FollowAlias(v2, &v13, (TNodeRequest **)&changelist, 8);
  if (!v3)
  {
    if (TNodeFromFINode(v13.fFINode))
    {
      uint64_t v5 = TNodeFromFINode(v13.fFINode);
      uint64_t v6 = *(TChildrenList **)(v5 + 56);
      if (v6)
      {
        if (TChildrenList::DecrementSubscriptionCount(*(TChildrenList **)(v5 + 56)) == 1)
        {
          int SubscriptionFileDescriptor = TChildrenList::GetSubscriptionFileDescriptor(v6);
          if (SubscriptionFileDescriptor >= 1)
          {
            int v8 = (TNode *)TChildrenList::SetSubscriptionFileDescriptor(v6, 0);
            timeout.tv_nsec = 0;
            changelist.ident = SubscriptionFileDescriptor;
            *(_DWORD *)&changelist.filter = 196604;
            memset(&changelist.fflags, 0, 20);
            timeout.tv_sec = 0;
            int v9 = TNode::KQueue(v8);
            kevent(v9, &changelist, 1, 0, 0, &timeout);
            int v10 = (TNode *)close(SubscriptionFileDescriptor);
            TNode::RemovekQueueNotification(v10);
          }
        }
      }
    }
  }

  return v3;
}

void sub_1D34DDAB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TNode::HandleVolumeDeleted(uint64_t a1, FINode **a2)
{
  uint64_t v2 = TNodeFromFINode(*a2);
  uint64_t v3 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v2);
  os_unfair_lock_lock(v3);
  uint64_t v5 = *(TFSInfo **)(v2 + 16);
  uint64_t v4 = *(std::__shared_weak_count **)(v2 + 24);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v3);
  TFSInfo::GetVolumeID(v5, &v8);
  uint64_t v6 = TNode::RemoveVolume(&v8);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v8);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return v6;
}

void sub_1D34DDB68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)va);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  _Unwind_Resume(a1);
}

uint64_t TNode::HandleRegisterInternalNotificationTask(uint64_t a1, FINode **a2)
{
  if (TNodeFromFINode(*a2))
  {
    uint64_t v3 = TNodeFromFINode(*a2);
    TNode::RegisterForInternalNotifications(v3, a2, 3);
  }
  return 0;
}

uint64_t TPropertyValue::TPropertyValue<__CFData const*>(uint64_t a1, const void **a2)
{
  uint64_t v3 = *a2;
  uint64_t v5 = v3;
  if (v3) {
    CFRetain(v3);
  }
  TPropertyValue::TPropertyValue<TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>>(a1, &v5);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v5);
  return a1;
}

void sub_1D34DDC24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TNode::InlineProgressCancel(TNode *this)
{
  TNodePtr::TNodePtr(&v1, this);
  TProgressMap::CancelProgress((TProgressMap *)&v1, (const TNodePtr *)1);
}

void sub_1D34DDC7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

int *NWMapSpinlock(void)
{
  {
    NWMapSpinlock(void)::sNWMapSpinlock = 0;
  }
  return &NWMapSpinlock(void)::sNWMapSpinlock;
}

uint64_t TNode::GetNWNodeMap(int a1)
{
  if ((a1 - 31) >= 2)
  {
    if (a1 != 33) {
      abort();
    }
    uint64_t result = gAirDropNodeMap;
    if (!gAirDropNodeMap) {
      operator new();
    }
  }
  else
  {
    uint64_t result = gNWSidebarNodeMap;
    if (!gNWSidebarNodeMap) {
      operator new();
    }
  }
  return result;
}

void TNode::GetNWNode(int a1@<W0>, uint64_t a2@<X1>, TNodePtr *a3@<X8>)
{
  uint64_t v7 = a2;
  NWMapSpinlock();
  os_unfair_lock_lock((os_unfair_lock_t)&NWMapSpinlock(void)::sNWMapSpinlock);
  NWNodeMap = (void *)TNode::GetNWNodeMap(a1);
  uint64_t v6 = std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::find<__SFNode *>(NWNodeMap, &v7);
  if (v6) {
    a3->fFINode = (FINode *)(id)v6[3];
  }
  else {
    TNodePtr::TNodePtr(a3, 0);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&NWMapSpinlock(void)::sNWMapSpinlock);
}

void sub_1D34DDE08(_Unwind_Exception *a1)
{
}

uint64_t std::pair<TTempProperties,BOOL>::pair[abi:ne180100]<TTempProperties&,BOOL,0>(uint64_t a1, long long *a2, unsigned char *a3)
{
  long long v6 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v6;
  *(void *)(a1 + 24) = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)(a1 + 24), *((TString **)a2 + 3));
  *(void *)(a1 + 32) = *((id *)a2 + 4);
  *(unsigned char *)(a1 + 40) = *a3;
  return a1;
}

void sub_1D34DDE9C(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

uint64_t std::pair<TTempProperties,BOOL>::pair[abi:ne180100]<true,0>(uint64_t a1, long long *a2, unsigned char *a3)
{
  long long v6 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v6;
  *(void *)(a1 + 24) = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)(a1 + 24), *((TString **)a2 + 3));
  *(void *)(a1 + 32) = *((id *)a2 + 4);
  *(unsigned char *)(a1 + 40) = *a3;
  return a1;
}

void sub_1D34DDF28(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void StFirstPopulationLock::StFirstPopulationLock(StFirstPopulationLock *this, TNodePtr a2)
{
  uint64_t v4 = a2.fFINode->super.isa;
  *(void *)this = v4;
  uint64_t v5 = (os_unfair_lock_s *)StFirstPopulationLock::MapLock(v4);
  os_unfair_lock_lock(v5);
  if (!StFirstPopulationLock::sMutexes) {
    operator new();
  }
  fFINode = a2.fFINode;
  long long v6 = std::__hash_table<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::__unordered_map_hasher<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::hash<TNodePtr>,std::equal_to<TNodePtr>,true>,std::__unordered_map_equal<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::equal_to<TNodePtr>,std::hash<TNodePtr>,true>,std::allocator<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>>>::__emplace_unique_key_args<TNodePtr,std::piecewise_construct_t const&,std::tuple<TNodePtr const&>,std::tuple<>>(StFirstPopulationLock::sMutexes, (FINode **)a2.fFINode, (uint64_t)&std::piecewise_construct, (id **)&fFINode);
  ++*((_DWORD *)v6 + 6);
  uint64_t v7 = (std::mutex *)(v6 + 32);
  os_unfair_lock_unlock(v5);
  std::mutex::lock(v7);
}

void sub_1D34DE000(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v2);

  _Unwind_Resume(a1);
}

int *StFirstPopulationLock::MapLock(StFirstPopulationLock *this)
{
  {
    StFirstPopulationLock::MapLock(void)::sMapLock = 0;
  }
  return &StFirstPopulationLock::MapLock(void)::sMapLock;
}

char *std::__hash_table<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::__unordered_map_hasher<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::hash<TNodePtr>,std::equal_to<TNodePtr>,true>,std::__unordered_map_equal<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::equal_to<TNodePtr>,std::hash<TNodePtr>,true>,std::allocator<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>>>::__emplace_unique_key_args<TNodePtr,std::piecewise_construct_t const&,std::tuple<TNodePtr const&>,std::tuple<>>(uint64_t a1, FINode **a2, uint64_t a3, id **a4)
{
  unint64_t v7 = (unint64_t)*a2 >> 2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v4 = (unint64_t)*a2 >> 2;
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    int v12 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v12)
    {
      TNodePtr v13 = (char *)*v12;
      if (*v12)
      {
        do
        {
          unint64_t v14 = *((void *)v13 + 1);
          if (v14 == v7)
          {
            uint64_t v15 = TNodeFromFINode(*((FINode **)v13 + 2));
            if (v15 == TNodeFromFINode(*a2)) {
              return v13;
            }
          }
          else
          {
            if (v11 > 1)
            {
              if (v14 >= v8) {
                v14 %= v8;
              }
            }
            else
            {
              v14 &= v8 - 1;
            }
            if (v14 != v4) {
              break;
            }
          }
          TNodePtr v13 = *(char **)v13;
        }
        while (v13);
      }
    }
  }
  uint64_t v16 = (void *)(a1 + 16);
  TNodePtr v13 = (char *)operator new(0x60uLL);
  *(void *)TNodePtr v13 = 0;
  *((void *)v13 + 1) = v7;
  *((void *)v13 + 2) = **a4;
  *((_DWORD *)v13 + 6) = 0;
  *((void *)v13 + 4) = 850045863;
  *(_OWORD *)(v13 + 40) = 0u;
  *(_OWORD *)(v13 + 56) = 0u;
  *(_OWORD *)(v13 + 72) = 0u;
  *((void *)v13 + 11) = 0;
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v8 || (float)(v18 * (float)v8) < v17)
  {
    BOOL v19 = 1;
    if (v8 >= 3) {
      BOOL v19 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v8);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v22);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v23 = *(void *)a1;
  uint64_t v24 = *(void **)(*(void *)a1 + 8 * v4);
  if (v24)
  {
    *(void *)TNodePtr v13 = *v24;
LABEL_38:
    void *v24 = v13;
    goto LABEL_39;
  }
  *(void *)TNodePtr v13 = *v16;
  void *v16 = v13;
  *(void *)(v23 + 8 * v4) = v16;
  if (*(void *)v13)
  {
    unint64_t v25 = *(void *)(*(void *)v13 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v25 >= v8) {
        v25 %= v8;
      }
    }
    else
    {
      v25 &= v8 - 1;
    }
    uint64_t v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v13;
}

void sub_1D34DE2F8(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,void *>>>::operator()[abi:ne180100](v2, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,void *>>>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 8))
  {
    std::mutex::~mutex((std::mutex *)(a2 + 32));
  }
  else if (!a2)
  {
    return;
  }
  operator delete((void *)a2);
}

void StFirstPopulationLock::~StFirstPopulationLock(StFirstPopulationLock *this)
{
  uint64_t v2 = (os_unfair_lock_s *)StFirstPopulationLock::MapLock(this);
  os_unfair_lock_lock(v2);
  unint64_t v8 = (id *)this;
  uint64_t v3 = (std::mutex *)(std::__hash_table<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::__unordered_map_hasher<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::hash<TNodePtr>,std::equal_to<TNodePtr>,true>,std::__unordered_map_equal<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::equal_to<TNodePtr>,std::hash<TNodePtr>,true>,std::allocator<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>>>::__emplace_unique_key_args<TNodePtr,std::piecewise_construct_t const&,std::tuple<TNodePtr const&>,std::tuple<>>(StFirstPopulationLock::sMutexes, (FINode **)this, (uint64_t)&std::piecewise_construct, &v8)+ 32);
  os_unfair_lock_unlock(v2);
  std::mutex::unlock(v3);
  uint64_t v5 = (os_unfair_lock_s *)StFirstPopulationLock::MapLock(v4);
  os_unfair_lock_lock(v5);
  unint64_t v8 = (id *)this;
  long long v6 = std::__hash_table<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::__unordered_map_hasher<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::hash<TNodePtr>,std::equal_to<TNodePtr>,true>,std::__unordered_map_equal<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::equal_to<TNodePtr>,std::hash<TNodePtr>,true>,std::allocator<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>>>::__emplace_unique_key_args<TNodePtr,std::piecewise_construct_t const&,std::tuple<TNodePtr const&>,std::tuple<>>(StFirstPopulationLock::sMutexes, (FINode **)this, (uint64_t)&std::piecewise_construct, &v8);
  int v7 = *((_DWORD *)v6 + 6) - 1;
  *((_DWORD *)v6 + 6) = v7;
  if (!v7) {
    std::__hash_table<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::__unordered_map_hasher<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::hash<TNodePtr>,std::equal_to<TNodePtr>,true>,std::__unordered_map_equal<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::equal_to<TNodePtr>,std::hash<TNodePtr>,true>,std::allocator<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>>>::__erase_unique<TNodePtr>((void *)StFirstPopulationLock::sMutexes, (FINode **)this);
  }
  os_unfair_lock_unlock(v5);
}

uint64_t *std::__hash_table<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::__unordered_map_hasher<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::hash<TNodePtr>,std::equal_to<TNodePtr>,true>,std::__unordered_map_equal<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::equal_to<TNodePtr>,std::hash<TNodePtr>,true>,std::allocator<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>>>::__erase_unique<TNodePtr>(void *a1, FINode **a2)
{
  uint64_t result = (uint64_t *)std::__hash_table<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::__unordered_map_hasher<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::hash<TNodePtr>,std::equal_to<TNodePtr>,true>,std::__unordered_map_equal<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::equal_to<TNodePtr>,std::hash<TNodePtr>,true>,std::allocator<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>>>::find<TNodePtr>(a1, a2);
  if (result)
  {
    std::__hash_table<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::__unordered_map_hasher<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::hash<TNodePtr>,std::equal_to<TNodePtr>,true>,std::__unordered_map_equal<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::equal_to<TNodePtr>,std::hash<TNodePtr>,true>,std::allocator<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>>>::erase(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

uint64_t **std::__hash_table<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::__unordered_map_hasher<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::hash<TNodePtr>,std::equal_to<TNodePtr>,true>,std::__unordered_map_equal<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::equal_to<TNodePtr>,std::hash<TNodePtr>,true>,std::allocator<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>>>::find<TNodePtr>(void *a1, FINode **a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v4 = (unint64_t)*a2 >> 2;
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v2);
  v5.i16[0] = vaddlv_u8(v5);
  unint64_t v6 = v5.u32[0];
  if (v5.u32[0] > 1uLL)
  {
    unint64_t v7 = (unint64_t)*a2 >> 2;
    if (v4 >= *(void *)&v2) {
      unint64_t v7 = v4 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = (*(void *)&v2 - 1) & v4;
  }
  unint64_t v8 = *(uint64_t ****)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  for (uint64_t i = *v8; i; uint64_t i = (uint64_t **)*i)
  {
    unint64_t v10 = (unint64_t)i[1];
    if (v10 == v4)
    {
      uint64_t v11 = TNodeFromFINode((FINode *)i[2]);
      if (v11 == TNodeFromFINode(*a2)) {
        return i;
      }
    }
    else
    {
      if (v6 > 1)
      {
        if (v10 >= *(void *)&v2) {
          v10 %= *(void *)&v2;
        }
      }
      else
      {
        v10 &= *(void *)&v2 - 1;
      }
      if (v10 != v7) {
        return 0;
      }
    }
  }
  return i;
}

uint64_t std::__hash_table<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::__unordered_map_hasher<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::hash<TNodePtr>,std::equal_to<TNodePtr>,true>,std::__unordered_map_equal<TNodePtr,std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,std::equal_to<TNodePtr>,std::hash<TNodePtr>,true>,std::allocator<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>>>::erase(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::remove(a1, a2, (uint64_t)&v5);
  uint64_t v3 = v5;
  uint64_t v5 = 0;
  if (v3) {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TNodePtr,std::pair<int,std::mutex>>,void *>>>::operator()[abi:ne180100]((uint64_t)&v6, v3);
  }
  return v2;
}

void ___ZZN5TNode28UnregisterChangeNotificationERKNSt3__110shared_ptrI21TClientChangeNotifierEERK8TNodePtr23NodeNotificationOptionsENK3__0clEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(TChildrenList **)(TNodeFromFINode(*(FINode **)(a1 + 32)) + 56);
  TChildrenList::ClearSizesFetchedForUnobservedNodes(v1);
}

id __copy_helper_block_ea8_32c13_ZTS8TNodePtr(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a2 + 32);
  *(void *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c13_ZTS8TNodePtr(uint64_t a1)
{
}

void ___ZZN5TNode10RemoveSelfEP14TNodeEventPtrsENK3__0clEv_block_invoke(uint64_t a1)
{
  TGlobalNodes::RootNode((uint64_t *)&v5, (TGlobalNodes *)a1);
  TNode::StPopulating::StPopulating((TNode::StPopulating *)v4, &v5, 0);
  uint64_t v2 = TNodeFromFINode(v5.fFINode);
  if (TChildrenList::RemoveChild(*(TChildrenList **)(v2 + 56), (const TNodePtr *)(a1 + 32)) && *(unsigned char *)(a1 + 40))
  {
    uint64_t v3 = (const TNode *)TNodeFromFINode(v5.fFINode);
    TNode::SendNotification(v3, 4, (id *)(a1 + 32), 0, 0);
  }
  TNode::StPopulating::~StPopulating(v4);
}

void sub_1D34DE6C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

uint64_t **std::back_insert_iterator<std::vector<std::pair<TNodePtr,FPItem * {__strong}>>>::operator=[abi:ne180100](uint64_t **a1, uint64_t a2)
{
  unint64_t v4 = *a1;
  TNodePtr v5 = (void *)(*a1)[1];
  if ((unint64_t)v5 >= v4[2])
  {
    uint64_t v8 = std::vector<std::pair<TNodePtr,FPItem * {__strong}>>::__push_back_slow_path<std::pair<TNodePtr,FPItem * {__strong}>>(v4, a2);
  }
  else
  {
    uint64_t v6 = TNodePtr::TNodePtr(v5, (id *)a2);
    uint64_t v7 = *(void *)(a2 + 8);
    *(void *)(a2 + 8) = 0;
    v6[1] = v7;
    uint64_t v8 = (uint64_t)(v6 + 2);
  }
  v4[1] = v8;
  return a1;
}

uint64_t std::vector<std::pair<TNodePtr,FPItem * {__strong}>>::__push_back_slow_path<std::pair<TNodePtr,FPItem * {__strong}>>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (a1[1] - *a1) >> 4;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 60) {
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2] - v3;
  if (v8 >> 3 > v5) {
    unint64_t v5 = v8 >> 3;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v9 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  v15[4] = a1 + 2;
  if (v9) {
    unint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>(v7, v9);
  }
  else {
    unint64_t v10 = 0;
  }
  uint64_t v11 = &v10[16 * v4];
  v15[0] = v10;
  v15[1] = v11;
  v15[3] = &v10[16 * v9];
  TNodePtr::TNodePtr(v11, (id *)a2);
  uint64_t v12 = *(void *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  *((void *)v11 + 1) = v12;
  v15[2] = v11 + 16;
  std::vector<std::pair<TNodePtr,FPItem * {__strong}>>::__swap_out_circular_buffer(a1, v15);
  uint64_t v13 = a1[1];
  std::__split_buffer<std::pair<TNodePtr,FPItem * {__strong}>>::~__split_buffer((uint64_t)v15);
  return v13;
}

void sub_1D34DE82C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::pair<TNodePtr,FPItem * {__strong}>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::pair<TNodePtr,FPItem * {__strong}>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  char v14 = 0;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v9 = a3;
    do
    {
      TNodePtr::TNodePtr((void *)(v7 - 16), (id *)(v9 - 16));
      uint64_t v10 = *(void *)(v9 - 8);
      *(void *)(v9 - 8) = 0;
      *(void *)(v7 - 8) = v10;
      uint64_t v7 = *((void *)&v16 + 1) - 16;
      *((void *)&v16 + 1) -= 16;
      v9 -= 16;
    }
    while (v9 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = (uint64_t *)a1[2];
  uint64_t v3 = *v1;
  uint64_t v2 = v1[1];
  uint64_t v14 = v3;
  uint64_t v15 = v2;
  uint64_t v16 = v3;
  uint64_t v17 = v2;
  uint64_t v4 = *a1;
  uint64_t v5 = (uint64_t *)a1[1];
  uint64_t v7 = *v5;
  uint64_t v6 = v5[1];
  uint64_t v9 = v7;
  uint64_t v10 = v6;
  uint64_t v11 = v7;
  uint64_t v12 = v6;
  std::__allocator_destroy[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::reverse_iterator<std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>,std::reverse_iterator<std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>>(v4, (uint64_t)v13, (uint64_t)v8);
}

void std::__allocator_destroy[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::reverse_iterator<std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>,std::reverse_iterator<std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  for (uint64_t i = *(id **)(a2 + 32); i != *(id **)(a3 + 32); *(void *)(a2 + 32) = i)
  {

    uint64_t i = (id *)(*(void *)(a2 + 32) + 16);
  }
}

uint64_t std::__tree<Property>::__erase_unique<Property>(uint64_t a1, unsigned int *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  unsigned int v3 = *a2;
  uint64_t v4 = a1 + 8;
  do
  {
    unsigned int v5 = *(_DWORD *)(v2 + 28);
    BOOL v6 = v5 >= v3;
    if (v5 >= v3) {
      uint64_t v7 = (uint64_t *)v2;
    }
    else {
      uint64_t v7 = (uint64_t *)(v2 + 8);
    }
    if (v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 8 || v3 < *(_DWORD *)(v4 + 28)) {
    return 0;
  }
  std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__remove_node_pointer((uint64_t **)a1, (uint64_t *)v4);
  operator delete((void *)v4);
  return 1;
}

void std::optional<TNodePtr>::value_or[abi:ne180100]<decltype(nullptr) const&>(uint64_t a1@<X0>, TNodePtr *a2@<X8>)
{
  if (*(unsigned char *)(a1 + 8)) {
    TNodePtr::TNodePtr(a2, (id *)a1);
  }
  else {
    TNodePtr::TNodePtr(a2, 0);
  }
}

void ___ZL23FPItemForProviderWithIDRK7TStringS1__block_invoke(uint64_t a1, void *a2, uint64_t a3)
{
  id v6 = a2;
  if (!a3) {
    objc_storeStrong(*(id **)(a1 + 32), a2);
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 48));
}

id __copy_helper_block_ea8_32c50_ZTSKZL23FPItemForProviderWithIDRK7TStringS1_E3__0(void *a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 40);
  a1[4] = *(void *)(a2 + 32);
  a1[5] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  id result = *(id *)(a2 + 48);
  a1[6] = result;
  return result;
}

void __destroy_helper_block_ea8_32c50_ZTSKZL23FPItemForProviderWithIDRK7TStringS1_E3__0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

uint64_t FPItemForProviderWithID(TString const&,TString const&)::$_0::~$_0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  return a1;
}

void std::__shared_ptr_emplace<FPItem * {__strong}>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB518;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<FPItem * {__strong}>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB518;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

void std::__shared_ptr_emplace<FPItem * {__strong}>::__on_zero_shared(uint64_t a1)
{
}

void std::__allocator_destroy[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>,std::reverse_iterator<std::pair<TNodePtr,FPItem * {__strong}>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3 != a5)
  {
    uint64_t v6 = a3;
    do
    {

      uint64_t v7 = *(void **)(v6 - 16);
      v6 -= 16;
    }
    while (v6 != a5);
  }
}

void TFSInfoOverflow::SetFolderSizeRecord(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 72);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 72));
  uint64_t v5 = *a2;
  *a2 = 0;
  uint64_t v6 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = v5;
  if (v6) {
    MEMORY[0x1D9436740](v6, 0x1000C40E0EAB150);
  }
  os_unfair_lock_unlock(v4);
}

uint64_t *TPropertyValue::As<__CFURL const*>(uint64_t *result, uint64_t **a2)
{
  int v2 = *((_DWORD *)result + 4);
  switch((char)v2)
  {
    case 0:
      if (v2) {
        goto LABEL_35;
      }
      id result = *a2;
      break;
    case 1:
      if (v2 != 1) {
        goto LABEL_35;
      }
      goto LABEL_39;
    case 2:
      if (v2 != 2) {
        goto LABEL_35;
      }
      goto LABEL_39;
    case 3:
      if (v2 != 3) {
        goto LABEL_35;
      }
      goto LABEL_39;
    case 4:
      if (v2 != 4) {
        goto LABEL_35;
      }
      goto LABEL_39;
    case 5:
      if (v2 != 5) {
        goto LABEL_35;
      }
      goto LABEL_39;
    case 6:
      if (v2 != 6) {
        goto LABEL_35;
      }
      goto LABEL_39;
    case 7:
      if (v2 != 7) {
        goto LABEL_35;
      }
      goto LABEL_39;
    case 8:
      if (v2 != 8) {
        goto LABEL_35;
      }
      goto LABEL_39;
    case 9:
      goto LABEL_39;
    case 10:
      if (v2 != 10) {
        goto LABEL_35;
      }
      goto LABEL_39;
    case 11:
      if (v2 != 11) {
        goto LABEL_35;
      }
      goto LABEL_39;
    case 12:
      if (v2 != 12) {
        goto LABEL_35;
      }
      goto LABEL_39;
    case 13:
      if (v2 != 13) {
        goto LABEL_35;
      }
      goto LABEL_39;
    case 14:
      if (v2 != 14) {
        goto LABEL_35;
      }
      goto LABEL_39;
    case 15:
      if (v2 != 15) {
        goto LABEL_35;
      }
      goto LABEL_39;
    case 16:
      if (v2 != 16) {
        goto LABEL_35;
      }
      id result = (uint64_t *)*result;
      break;
    case 17:
      if (v2 != 17) {
        goto LABEL_35;
      }
      goto LABEL_39;
    case 18:
      if (v2 != 18) {
        goto LABEL_35;
      }
      goto LABEL_39;
    case 19:
      if (v2 == 19) {
        goto LABEL_39;
      }
      goto LABEL_35;
    case 20:
      if (v2 != 20) {
        goto LABEL_35;
      }
      goto LABEL_39;
    case 21:
      if (v2 != 21) {
        goto LABEL_35;
      }
      goto LABEL_39;
    case 22:
      if (v2 != 22) {
        goto LABEL_35;
      }
      goto LABEL_39;
    case 23:
      if (v2 != 23) {
LABEL_35:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_39:
      id result = *a2;
      break;
    default:
      return result;
  }
  return result;
}

const void **TPropertyValue::As<__CFString const*>(const void **result, void **a2)
{
  int v2 = *((_DWORD *)result + 4);
  switch((char)v2)
  {
    case 0:
      if (v2) {
        goto LABEL_27;
      }
      id result = (const void **)*a2;
      break;
    case 1:
      if (v2 != 1) {
        goto LABEL_27;
      }
      goto LABEL_39;
    case 2:
      if (v2 != 2) {
        goto LABEL_27;
      }
      goto LABEL_39;
    case 3:
      if (v2 != 3) {
        goto LABEL_27;
      }
      goto LABEL_39;
    case 4:
      if (v2 != 4) {
        goto LABEL_27;
      }
      goto LABEL_39;
    case 5:
      if (v2 != 5) {
        goto LABEL_27;
      }
      goto LABEL_39;
    case 6:
      if (v2 != 6) {
        goto LABEL_27;
      }
      goto LABEL_39;
    case 7:
      if (v2 != 7) {
        goto LABEL_27;
      }
      goto LABEL_39;
    case 8:
      if (v2 != 8) {
        goto LABEL_27;
      }
      goto LABEL_39;
    case 9:
      goto LABEL_39;
    case 10:
      if (v2 != 10) {
        goto LABEL_27;
      }
      goto LABEL_39;
    case 11:
      if (v2 != 11) {
        goto LABEL_27;
      }
      id result = (const void **)AsPriv<__CFString const*,TString>(result);
      break;
    case 12:
      if (v2 != 12) {
        goto LABEL_27;
      }
      id result = (const void **)*result;
      break;
    case 13:
      if (v2 != 13) {
        goto LABEL_27;
      }
      goto LABEL_39;
    case 14:
      if (v2 != 14) {
        goto LABEL_27;
      }
      goto LABEL_39;
    case 15:
      if (v2 != 15) {
        goto LABEL_27;
      }
      goto LABEL_39;
    case 16:
      if (v2 != 16) {
        goto LABEL_27;
      }
      goto LABEL_39;
    case 17:
      if (v2 != 17) {
        goto LABEL_27;
      }
      goto LABEL_39;
    case 18:
      if (v2 != 18) {
        goto LABEL_27;
      }
      goto LABEL_39;
    case 19:
      if (v2 == 19) {
        goto LABEL_39;
      }
      goto LABEL_27;
    case 20:
      if (v2 != 20) {
        goto LABEL_27;
      }
      goto LABEL_39;
    case 21:
      if (v2 != 21) {
        goto LABEL_27;
      }
      goto LABEL_39;
    case 22:
      if (v2 != 22) {
        goto LABEL_27;
      }
      goto LABEL_39;
    case 23:
      if (v2 != 23) {
LABEL_27:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_39:
      id result = (const void **)*a2;
      break;
    default:
      return result;
  }
  return result;
}

const void *AsPriv<__CFString const*,TString>(const void **a1)
{
  id result = RetainCF<__CFString const*>(a1);
  if (result)
  {
    CFTypeRef v2 = CFAutorelease(result);
    return static_cf_cast<__CFString const*,void const*>(v2);
  }
  return result;
}

id __copy_helper_block_ea8_32c127_ZTSKZZN5TNode29SetTimerToDispatchSyncRequestERKNSt3__110shared_ptrI17TVolumeSyncThreadEEy18NodeRequestOptionsENK3__0clEvEUlvE_(void *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 40);
  a1[4] = *(void *)(a2 + 32);
  a1[5] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  a1[6] = *(id *)(a2 + 48);
  id result = *(id *)(a2 + 56);
  a1[7] = result;
  a1[8] = *(void *)(a2 + 64);
  return result;
}

void __destroy_helper_block_ea8_32c127_ZTSKZZN5TNode29SetTimerToDispatchSyncRequestERKNSt3__110shared_ptrI17TVolumeSyncThreadEEy18NodeRequestOptionsENK3__0clEvEUlvE_(uint64_t a1)
{
  CFTypeRef v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

uint64_t std::__tree<TNodePtr>::__erase_unique<TNodePtr>(uint64_t **a1, FINode **a2)
{
  uint64_t v3 = std::__tree<TNodePtr>::find<TNodePtr>((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3) {
    return 0;
  }
  std::__tree<TNodePtr>::erase(a1, v3);
  return 1;
}

uint64_t std::__tree<TNodePtr>::find<TNodePtr>(uint64_t a1, FINode **a2)
{
  uint64_t v3 = a1 + 8;
  uint64_t v4 = std::__tree<TNodePtr>::__lower_bound<TNodePtr>(a1, a2, *(void *)(a1 + 8), a1 + 8);
  if (v3 == v4) {
    return v3;
  }
  uint64_t v5 = v4;
  unint64_t v6 = TNodeFromFINode(*a2);
  if (v6 < TNodeFromFINode(*(FINode **)(v5 + 32))) {
    return v3;
  }
  return v5;
}

uint64_t *std::__tree<TNodePtr>::erase(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__remove_node_pointer(a1, (uint64_t *)a2);

  operator delete((void *)a2);
  return v3;
}

uint64_t std::__tree<TNodePtr>::__lower_bound<TNodePtr>(uint64_t a1, FINode **a2, uint64_t a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t v5 = a3;
    do
    {
      unint64_t v7 = TNodeFromFINode(*(FINode **)(v5 + 32));
      unint64_t v8 = TNodeFromFINode(*a2);
      uint64_t v9 = (uint64_t *)(v5 + 8);
      if (v7 >= v8)
      {
        uint64_t v9 = (uint64_t *)v5;
        a4 = v5;
      }
      uint64_t v5 = *v9;
    }
    while (*v9);
  }
  return a4;
}

uint64_t *std::__tree<TNodePtr>::__emplace_unique_key_args<TNodePtr,TNodePtr>(uint64_t **a1, FINode **a2, id *a3)
{
  uint64_t v5 = std::__tree<TNodePtr>::__find_equal<TNodePtr>((uint64_t)a1, &v9, a2);
  unint64_t v6 = (uint64_t *)*v5;
  if (!*v5)
  {
    unint64_t v7 = (uint64_t **)v5;
    unint64_t v6 = (uint64_t *)operator new(0x28uLL);
    TNodePtr::TNodePtr(v6 + 4, a3);
    std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__insert_node_at(a1, v9, v7, v6);
  }
  return v6;
}

uint64_t *std::__tree<TNodePtr>::__find_equal<TNodePtr>(uint64_t a1, void *a2, FINode **a3)
{
  uint64_t v5 = (uint64_t *)(a1 + 8);
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        unint64_t v7 = v4;
        unint64_t v8 = TNodeFromFINode(*a3);
        if (v8 >= TNodeFromFINode((FINode *)v7[4])) {
          break;
        }
        uint64_t v4 = (uint64_t *)*v7;
        uint64_t v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      unint64_t v9 = TNodeFromFINode((FINode *)v7[4]);
      if (v9 >= TNodeFromFINode(*a3)) {
        break;
      }
      uint64_t v5 = v7 + 1;
      uint64_t v4 = (uint64_t *)v7[1];
    }
    while (v4);
  }
  else
  {
    unint64_t v7 = (uint64_t *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

uint64_t TPropertyReference::SetAs<__CFDictionary const*>(uint64_t a1, id *a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  switch((char)v2)
  {
    case 1:
      if (v2 != 1) {
        goto LABEL_46;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_46;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_46;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_46;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_46;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_46;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_46;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_46;
      }
      return 4294959246;
    case 9:
      if (v2 != 9) {
        goto LABEL_46;
      }
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_46;
      }
      SetAsPriv<__CFDictionary const*,NSObject * {__strong}>(a2, *(id **)a1);
      return 0;
    case 11:
      if (v2 != 11) {
        goto LABEL_46;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_46;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_46;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_46;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_46;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=(*(CFTypeRef **)a1, *a2);
      return 0;
    case 16:
      if (v2 != 16) {
        goto LABEL_46;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_46;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_46;
      }
      return 4294959246;
    case 19:
      if (v2 != 19) {
        goto LABEL_46;
      }
      uint64_t v4 = *(id **)a1;
      return TPropertyValue::SetAs<__CFDictionary const*>(v4, a2);
    case 20:
      if (v2 == 20) {
        return 4294959246;
      }
      goto LABEL_46;
    case 21:
      if (v2 != 21) {
        goto LABEL_46;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_46;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_46:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 4294959246;
  }
}

void SetAsPriv<__CFDictionary const*,NSObject * {__strong}>(id *a1, id *location)
{
}

uint64_t TPropertyValue::SetAs<__CFDictionary const*>(id *location, id *a2)
{
  int v2 = *((_DWORD *)location + 4);
  switch((char)v2)
  {
    case 0:
      id v4 = *a2;
      unint64_t v6 = v4;
      if (v4) {
        CFRetain(v4);
      }
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,BOOL,unsigned char,short,int,long long,unsigned int,double,Point,Blob,NSObject * {__strong},TString,TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>,TRef<__CFNumber const*,TRetainReleasePolicy<__CFNumber const*>>,TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>,TRef<__CFFileSecurity *,TRetainReleasePolicy<__CFFileSecurity *>>,TRef<TReferenceCounted *,TRetainReleasePolicy<TReferenceCounted *>>,Property,NodeRequestOptions,NodeDSStoreStatus,DSBladeRunnerFlags>>::__assign_alt[abi:ne180100]<15ul,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>,TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>>((uint64_t)location, (const void **)location, &v6);
      TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TRef(&v6);
      return 0;
    case 1:
      if (v2 != 1) {
        goto LABEL_35;
      }
      return 4294959246;
    case 2:
      if (v2 != 2) {
        goto LABEL_35;
      }
      return 4294959246;
    case 3:
      if (v2 != 3) {
        goto LABEL_35;
      }
      return 4294959246;
    case 4:
      if (v2 != 4) {
        goto LABEL_35;
      }
      return 4294959246;
    case 5:
      if (v2 != 5) {
        goto LABEL_35;
      }
      return 4294959246;
    case 6:
      if (v2 != 6) {
        goto LABEL_35;
      }
      return 4294959246;
    case 7:
      if (v2 != 7) {
        goto LABEL_35;
      }
      return 4294959246;
    case 8:
      if (v2 != 8) {
        goto LABEL_35;
      }
      return 4294959246;
    case 9:
      return 4294959246;
    case 10:
      if (v2 != 10) {
        goto LABEL_35;
      }
      SetAsPriv<__CFDictionary const*,NSObject * {__strong}>(a2, location);
      return 0;
    case 11:
      if (v2 != 11) {
        goto LABEL_35;
      }
      return 4294959246;
    case 12:
      if (v2 != 12) {
        goto LABEL_35;
      }
      return 4294959246;
    case 13:
      if (v2 != 13) {
        goto LABEL_35;
      }
      return 4294959246;
    case 14:
      if (v2 != 14) {
        goto LABEL_35;
      }
      return 4294959246;
    case 15:
      if (v2 != 15) {
        goto LABEL_35;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)location, *a2);
      return 0;
    case 16:
      if (v2 != 16) {
        goto LABEL_35;
      }
      return 4294959246;
    case 17:
      if (v2 != 17) {
        goto LABEL_35;
      }
      return 4294959246;
    case 18:
      if (v2 != 18) {
        goto LABEL_35;
      }
      return 4294959246;
    case 19:
      if (v2 == 19) {
        return 4294959246;
      }
      goto LABEL_35;
    case 20:
      if (v2 != 20) {
        goto LABEL_35;
      }
      return 4294959246;
    case 21:
      if (v2 != 21) {
        goto LABEL_35;
      }
      return 4294959246;
    case 22:
      if (v2 != 22) {
        goto LABEL_35;
      }
      return 4294959246;
    case 23:
      if (v2 != 23) {
LABEL_35:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
      return 4294959246;
    default:
      return 0;
  }
}

void std::__tree<TNodePtr>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<TNodePtr>::destroy(a1, *a2);
    std::__tree<TNodePtr>::destroy(a1, a2[1]);

    operator delete(a2);
  }
}

void std::default_delete<TNotifierList>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    id v4 = (void **)(a2 + 40);
    std::vector<TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>>::__destroy_vector::operator()[abi:ne180100](&v4);
    uint64_t v3 = *(std::__shared_weak_count **)(a2 + 32);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
    MEMORY[0x1D9436740](a2, 0x1020C40F61775ADLL);
  }
}

void *std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType &,TAutoRef<__SFNode *,TRetainReleasePolicy<__SFNode *>> &,void>@<X0>(char *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  unint64_t v6 = operator new(0x98uLL);
  id result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType &,TAutoRef<__SFNode *,TRetainReleasePolicy<__SFNode *>> &,std::allocator<TFSInfo>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1D34DF9D0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType &,TAutoRef<__SFNode *,TRetainReleasePolicy<__SFNode *>> &,std::allocator<TFSInfo>,0>(void *a1, char *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2ABB358;
  TFSInfo::TFSInfo((uint64_t)(a1 + 3), *a2, *a3);
  return a1;
}

void sub_1D34DFA34(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t **std::__hash_table<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>>>::__emplace_unique_key_args<TString,std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>(uint64_t a1, TString *this, uint64_t a3, TString ***a4)
{
  unint64_t v8 = FowlerNollVoHash::hash(this, this);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = v8;
      if (v8 >= v10) {
        unint64_t v4 = v8 % v10;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v8;
    }
    uint64_t v13 = *(uint64_t ****)(*(void *)a1 + 8 * v4);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = (uint64_t **)*i)
      {
        unint64_t v15 = (unint64_t)i[1];
        if (v15 == v9)
        {
          if (CFEqual(i[2], this->fString.fRef)) {
            return i;
          }
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v4) {
            break;
          }
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>(a1, v9, a4, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
      else {
        unint64_t v4 = v9;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
  }
  size_t v22 = *(void **)(*(void *)a1 + 8 * v4);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    *size_t v22 = v25[0];
  }
  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }
  uint64_t i = (uint64_t **)v25[0];
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1D34DFCA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void **__p, uint64_t a11)
{
  if (__p) {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,void *>>>::operator()[abi:ne180100]((uint64_t)&a11, __p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__hash_table<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, TString ***a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x40uLL);
  *(void *)(a4 + 8) = v7;
  *(void *)a4 = v8;
  *(unsigned char *)(a4 + 16) = 0;
  *unint64_t v8 = 0;
  v8[1] = a2;
  uint64_t result = std::pair<TString const,std::unordered_set<_opaque_pthread_t *>>::pair[abi:ne180100]<TString const&>((uint64_t)(v8 + 2), *a3);
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_1D34DFD38(_Unwind_Exception *a1)
{
  void *v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

uint64_t std::pair<TString const,std::unordered_set<_opaque_pthread_t *>>::pair[abi:ne180100]<TString const&>(uint64_t a1, TString **a2)
{
  *(void *)a1 = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)a1, *a2);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_DWORD *)(a1 + 40) = 1065353216;
  return a1;
}

void sub_1D34DFDAC(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,void *>>>::operator()[abi:ne180100](uint64_t a1, const void **__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)(__p + 3));
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(__p + 2);
  }
  if (__p)
  {
    operator delete(__p);
  }
}

void *std::__hash_table<_opaque_pthread_t *,std::hash<_opaque_pthread_t *>,std::equal_to<_opaque_pthread_t *>,std::allocator<_opaque_pthread_t *>>::__emplace_unique_key_args<_opaque_pthread_t *,_opaque_pthread_t *>(uint64_t a1, void *a2, void *a3)
{
  unint64_t v6 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v6 >> 47) ^ v6);
  unint64_t v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
    }
    else
    {
      unint64_t v3 = v8 & (v9 - 1);
    }
    uint8x8_t v11 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v11)
    {
      for (uint64_t i = *v11; i; uint64_t i = (void *)*i)
      {
        unint64_t v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2) {
            return i;
          }
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = operator new(0x18uLL);
  void *i = 0;
  i[1] = v8;
  i[2] = *a3;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    BOOL v16 = 1;
    if (v9 >= 3) {
      BOOL v16 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v9);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v19);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v20 = *(void *)a1;
  size_t v21 = *(void **)(*(void *)a1 + 8 * v3);
  if (v21)
  {
    void *i = *v21;
LABEL_38:
    *size_t v21 = i;
    goto LABEL_39;
  }
  void *i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v20 + 8 * v3) = a1 + 16;
  if (*i)
  {
    unint64_t v22 = *(void *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v22 >= v9) {
        v22 %= v9;
      }
    }
    else
    {
      v22 &= v9 - 1;
    }
    size_t v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1D34E0060(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<_opaque_pthread_t *,std::hash<_opaque_pthread_t *>,std::equal_to<_opaque_pthread_t *>,std::allocator<_opaque_pthread_t *>>::__erase_unique<_opaque_pthread_t *>(void *a1, void *a2)
{
  uint64_t result = std::__hash_table<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::__unordered_map_hasher<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::hash<OpaqueEventNotifier *>,std::equal_to<OpaqueEventNotifier *>,true>,std::__unordered_map_equal<OpaqueEventNotifier *,std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>,std::equal_to<OpaqueEventNotifier *>,std::hash<OpaqueEventNotifier *>,true>,std::allocator<std::__hash_value_type<OpaqueEventNotifier *,std::shared_ptr<TClientChangeNotifier>>>>::find<OpaqueEventNotifier *>(a1, a2);
  if (result)
  {
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::erase(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>>>::erase(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::remove(a1, a2, (uint64_t)&__p);
  unint64_t v3 = (const void **)__p;
  std::string __p = 0;
  if (v3) {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,std::unordered_set<_opaque_pthread_t *>>,void *>>>::operator()[abi:ne180100]((uint64_t)&v6, v3);
  }
  return v2;
}

uint64_t std::__function::__func<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1,std::allocator<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1>,void ()(FPItem *,NSError *)>::~__func(uint64_t a1)
{
  return a1;
}

void std::__function::__func<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1,std::allocator<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1>,void ()(FPItem *,NSError *)>::~__func(uint64_t a1)
{
  objc_destroyWeak((id *)(a1 + 8));
  JUMPOUT(0x1D9436740);
}

id *std::__function::__func<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1,std::allocator<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1>,void ()(FPItem *,NSError *)>::__clone(uint64_t a1)
{
  uint64_t v1 = (id *)(a1 + 8);
  uint64_t v2 = (id *)operator new(0x10uLL);
  id *v2 = &unk_1F2AB9848;
  objc_copyWeak(v2 + 1, v1);
  return v2;
}

void std::__function::__func<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1,std::allocator<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1>,void ()(FPItem *,NSError *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F2AB9848;
  objc_copyWeak((id *)(a2 + 8), (id *)(a1 + 8));
}

void std::__function::__func<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1,std::allocator<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1>,void ()(FPItem *,NSError *)>::destroy(uint64_t a1)
{
}

void std::__function::__func<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1,std::allocator<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1>,void ()(FPItem *,NSError *)>::destroy_deallocate(id *a1)
{
  objc_destroyWeak(a1 + 1);
  operator delete(a1);
}

void std::__function::__func<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1,std::allocator<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1>,void ()(FPItem *,NSError *)>::operator()(uint64_t a1, id *a2)
{
  id v13 = (id)*MEMORY[0x1E4F143B8];
  uint64_t v2 = (id *)(a1 + 8);
  id v3 = *a2;
  WeakRetained = (FINode *)objc_loadWeakRetained(v2);
  uint64_t v5 = (const TNode *)TNodeFromFINode(WeakRetained);
  if (v5)
  {
    TNodePtr::TNodePtr(&v11, v5);
    id v12 = v3;
    unint64_t v7 = 0;
    unint64_t v8 = 0;
    uint64_t v6 = 0;
    unint64_t v9 = &v6;
    char v10 = 0;
    uint64_t v6 = (id *)operator new(0x10uLL);
    unint64_t v7 = v6;
    unint64_t v8 = v6 + 2;
    unint64_t v7 = (id *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}>*>((uint64_t)&v8, (id *)&v11.fFINode, &v13, v6);
    TNode::AttachFPItemsMetadata(&v6, 0, 1);
    unint64_t v9 = &v6;
    std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v9);
  }
}

void sub_1D34E0344(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, uint64_t a13, id a14, id a15)
{
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](&a12);

  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1,std::allocator<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1>,void ()(FPItem *,NSError *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1,std::allocator<TNode::ProviderNodeForProviderDomain(FIProviderDomain *,NodeRequestOptions)::$_1>,void ()(FPItem *,NSError *)>::target_type()
{
}

void *std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FSInfoVirtualType,TString const&,TCatalogInfo const&,void>@<X0>(char *a1@<X1>, const TString *a2@<X2>, unsigned __int8 *a3@<X3>, void *a4@<X8>)
{
  unint64_t v8 = operator new(0x98uLL);
  uint64_t result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType,TString const&,TCatalogInfo const&,std::allocator<TFSInfo>,0>(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_1D34E044C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FSInfoVirtualType,TString const&,TCatalogInfo const&,std::allocator<TFSInfo>,0>(void *a1, char *a2, const TString *a3, unsigned __int8 *a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2ABB358;
  TFSInfo::TFSInfo((uint64_t)(a1 + 3), *a2, a3, a4);
  return a1;
}

void sub_1D34E04AC(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FIProviderDomain * {__strong}&,FPItem * {__strong}&,BOOL,void>@<X0>(FIProviderDomain **a1@<X1>, FPItem **a2@<X2>, unsigned __int8 *a3@<X3>, void *a4@<X8>)
{
  unint64_t v8 = (char *)operator new(0x98uLL);
  uint64_t result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FIProviderDomain * {__strong}&,FPItem * {__strong}&,BOOL,std::allocator<TFSInfo>,0>((uint64_t)v8, a1, a2, a3);
  *a4 = v8 + 24;
  a4[1] = v8;
  return result;
}

void sub_1D34E0520(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FIProviderDomain * {__strong}&,FPItem * {__strong}&,BOOL,std::allocator<TFSInfo>,0>(uint64_t a1, FIProviderDomain **a2, FPItem **a3, unsigned __int8 *a4)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1F2ABB358;
  TFSInfo::TFSInfo((TFSInfo *)(a1 + 24), *a2, *a3, *a4);
  return a1;
}

void sub_1D34E0588(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void *std::allocate_shared[abi:ne180100]<TFSInfoSizer,std::allocator<TFSInfoSizer>,TNode *,TNodePtr,decltype(nullptr),void>@<X0>(const TNode **a1@<X1>, uint64_t a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x80uLL);
  uint64_t result = std::__shared_ptr_emplace<TFSInfoSizer>::__shared_ptr_emplace[abi:ne180100]<TNode *,TNodePtr,decltype(nullptr),std::allocator<TFSInfoSizer>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1D34E05FC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<TFSInfoSizer>::__shared_ptr_emplace[abi:ne180100]<TNode *,TNodePtr,decltype(nullptr),std::allocator<TFSInfoSizer>,0>(void *a1, const TNode **a2, uint64_t a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2ABB128;
  std::construct_at[abi:ne180100]<TFSInfoSizer,TNode *,TNodePtr,decltype(nullptr),TFSInfoSizer*>((uint64_t)(a1 + 3), a2, a3);
  return a1;
}

void sub_1D34E0658(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<TFSInfoSizer>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB128;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TFSInfoSizer>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB128;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

void std::__shared_ptr_emplace<TFSInfoSizer>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::construct_at[abi:ne180100]<TFSInfoSizer,TNode *,TNodePtr,decltype(nullptr),TFSInfoSizer*>(uint64_t a1, const TNode **a2, uint64_t a3)
{
  TNodePtr::TNodePtr(&v8, *a2);
  uint64_t v6 = 0;
  unint64_t v7 = 0;
  TFSInfoSizer::TFSInfoSizer(a1, &v8, a3, &v6, 0);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }

  return a1;
}

void sub_1D34E0758(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *a12)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }

  _Unwind_Resume(a1);
}

void std::__destroy_at[abi:ne180100]<TFSInfoSizer,0>(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }

  id v3 = *(void **)a1;
}

const void **TPropertyReference::As<__CFString const*>(const void **result, void **a2)
{
  int v2 = *((_DWORD *)result + 2);
  id v3 = (const void **)a2;
  switch((char)v2)
  {
    case 0:
      if (v2) {
        goto LABEL_43;
      }
      return (const void **)*a2;
    case 1:
      if (v2 != 1) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 2:
      if (v2 != 2) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 3:
      if (v2 != 3) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 4:
      if (v2 != 4) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 5:
      if (v2 != 5) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 6:
      if (v2 != 6) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 7:
      if (v2 != 7) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 8:
      if (v2 != 8) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 9:
      goto LABEL_41;
    case 10:
      if (v2 != 10) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 11:
      if (v2 != 11) {
        goto LABEL_43;
      }
      return (const void **)AsPriv<__CFString const*,TString>((const void **)*result);
    case 12:
      if (v2 != 12) {
        goto LABEL_43;
      }
      id v3 = (const void **)*result;
      goto LABEL_41;
    case 13:
      if (v2 != 13) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 14:
      if (v2 != 14) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 15:
      if (v2 != 15) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 16:
      if (v2 != 16) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 17:
      if (v2 != 17) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 18:
      if (v2 != 18) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 19:
      if (v2 != 19) {
        goto LABEL_43;
      }
      return TPropertyValue::As<__CFString const*>((const void **)*result, a2);
    case 20:
      if (v2 == 20) {
        goto LABEL_41;
      }
      goto LABEL_43;
    case 21:
      if (v2 != 21) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 22:
      if (v2 != 22) {
        goto LABEL_43;
      }
      goto LABEL_41;
    case 23:
      if (v2 != 23) {
LABEL_43:
      }
        std::__throw_bad_variant_access[abi:ne180100]();
LABEL_41:
      uint64_t result = (const void **)*v3;
      break;
    default:
      return result;
  }
  return result;
}

void std::__shared_ptr_emplace<ExternalRegistration>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB2B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<ExternalRegistration>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB2B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

void std::__shared_ptr_emplace<ExternalRegistration>::__on_zero_shared(uint64_t a1)
{
}

void std::__function::__func<TNode::RecursiveChildrenAndSelf(BOOL)::$_0,std::allocator<TNode::RecursiveChildrenAndSelf(BOOL)::$_0>,void ()(TNode const*)>::~__func()
{
}

__n128 std::__function::__func<TNode::RecursiveChildrenAndSelf(BOOL)::$_0,std::allocator<TNode::RecursiveChildrenAndSelf(BOOL)::$_0>,void ()(TNode const*)>::__clone(uint64_t a1)
{
  int v2 = (char *)operator new(0x20uLL);
  *(void *)int v2 = &unk_1F2ABAD40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<TNode::RecursiveChildrenAndSelf(BOOL)::$_0,std::allocator<TNode::RecursiveChildrenAndSelf(BOOL)::$_0>,void ()(TNode const*)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F2ABAD40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<TNode::RecursiveChildrenAndSelf(BOOL)::$_0,std::allocator<TNode::RecursiveChildrenAndSelf(BOOL)::$_0>,void ()(TNode const*)>::operator()(uint64_t a1, const TNode **a2)
{
  TNodePtr::TNodePtr(&v17, *a2);
  if (!*(unsigned char *)(a1 + 8)
    || (v3 = (TNode *)TNodeFromFINode(v17.fFINode), int v4 = atomic_load((unsigned int *)TNode::GetNotifierList(v3)),
                                                    v4 >= 1))
  {
    std::vector<TNodePtr>::push_back[abi:ne180100](*(void *)(a1 + 16), (id *)&v17.fFINode);
  }
  uint64_t v5 = (TNode *)TNodeFromFINode(v17.fFINode);
  TNode::CopyChildren(v5, (uint64_t)&v18);
  uint64_t v6 = v18;
  for (uint64_t i = v19; v6 != i; ++v6)
  {
    TNodePtr v8 = (FINode *)*v6;
    uint64_t v9 = TNodeFromFINode(v8);
    char v10 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v9);
    os_unfair_lock_lock(v10);
    uint64_t v12 = *(void *)(v9 + 16);
    TNodePtr v11 = *(std::__shared_weak_count **)(v9 + 24);
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v10);
    id v13 = (os_unfair_lock_s *)(v12 + 100);
    os_unfair_lock_lock((os_unfair_lock_t)(v12 + 100));
    int v14 = *(_DWORD *)(v12 + 115);
    os_unfair_lock_unlock(v13);
    if (v11) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v11);
    }
    if ((v14 & 0x20) != 0)
    {
      uint64_t v15 = *(void *)(a1 + 24);
      uint64_t v16 = TNodeFromFINode(v8);
      std::function<void ()(TNode const*)>::operator()(v15, v16);
    }
  }
  uint64_t v20 = &v18;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v20);
}

void sub_1D34E0C20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<TNode::RecursiveChildrenAndSelf(BOOL)::$_0,std::allocator<TNode::RecursiveChildrenAndSelf(BOOL)::$_0>,void ()(TNode const*)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

void *std::__function::__func<TNode::RecursiveChildrenAndSelf(BOOL)::$_0,std::allocator<TNode::RecursiveChildrenAndSelf(BOOL)::$_0>,void ()(TNode const*)>::target_type()
{
}

void *std::__function::__value_func<void ()(TNode const*)>::~__value_func[abi:ne180100](void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__hash_table<std::__hash_value_type<TNodePtr,TNodePtr>,std::__unordered_map_hasher<TNodePtr,std::__hash_value_type<TNodePtr,TNodePtr>,std::hash<TNodePtr>,std::equal_to<TNodePtr>,true>,std::__unordered_map_equal<TNodePtr,std::__hash_value_type<TNodePtr,TNodePtr>,std::equal_to<TNodePtr>,std::hash<TNodePtr>,true>,std::allocator<std::__hash_value_type<TNodePtr,TNodePtr>>>::__emplace_unique_key_args<TNodePtr,std::piecewise_construct_t const&,std::tuple<TNodePtr&&>,std::tuple<>>(uint64_t a1, FINode **a2, uint64_t a3, id **a4)
{
  unint64_t v7 = (unint64_t)*a2 >> 2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v4 = (unint64_t)*a2 >> 2;
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    uint64_t v12 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = *(void **)i)
      {
        unint64_t v14 = *((void *)i + 1);
        if (v14 == v7)
        {
          uint64_t v15 = TNodeFromFINode(*((FINode **)i + 2));
          if (v15 == TNodeFromFINode(*a2)) {
            return i;
          }
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v8) {
              v14 %= v8;
            }
          }
          else
          {
            v14 &= v8 - 1;
          }
          if (v14 != v4) {
            break;
          }
        }
      }
    }
  }
  uint64_t v16 = (void *)(a1 + 16);
  uint64_t i = operator new(0x20uLL);
  *(void *)uint64_t i = 0;
  *((void *)i + 1) = v7;
  TNodePtr::TNodePtr((void *)i + 2, *a4);
  *((void *)i + 3) = 0;
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v8 || (float)(v18 * (float)v8) < v17)
  {
    BOOL v19 = 1;
    if (v8 >= 3) {
      BOOL v19 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v8);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v22);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v23 = *(void *)a1;
  uint64_t v24 = *(void **)(*(void *)a1 + 8 * v4);
  if (v24)
  {
    *(void *)uint64_t i = *v24;
LABEL_38:
    void *v24 = i;
    goto LABEL_39;
  }
  *(void *)uint64_t i = *v16;
  void *v16 = i;
  *(void *)(v23 + 8 * v4) = v16;
  if (*(void *)i)
  {
    unint64_t v25 = *(void *)(*(void *)i + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v25 >= v8) {
        v25 %= v8;
      }
    }
    else
    {
      v25 &= v8 - 1;
    }
    uint64_t v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1D34E0F70(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<NSString * {__strong},UTType * {__strong}>,void *>>>::operator()[abi:ne180100](v2, v1);
  _Unwind_Resume(a1);
}

uint64_t **std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<FPProviderDomain * {__strong},std::piecewise_construct_t const&,std::tuple<FPProviderDomain * const {__strong}&>,std::tuple<>>(uint64_t a1, id *a2, uint64_t a3, id **a4)
{
  unint64_t v8 = [*a2 hash];
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = v8;
      if (v8 >= v10) {
        unint64_t v4 = v8 % v10;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v8;
    }
    id v13 = *(uint64_t ****)(*(void *)a1 + 8 * v4);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = (uint64_t **)*i)
      {
        unint64_t v15 = (unint64_t)i[1];
        if (v15 == v9)
        {
          if (std::equal_to<FPProviderDomain * {__strong}>::operator()(a1 + 32, i[2], *a2)) {
            return i;
          }
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v4) {
            break;
          }
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<FPProviderDomain * const {__strong}&>,std::tuple<>>(a1, v9, a4, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
      else {
        unint64_t v4 = v9;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
  }
  size_t v22 = *(void **)(*(void *)a1 + 8 * v4);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    *size_t v22 = v25[0];
  }
  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }
  uint64_t i = (uint64_t **)v25[0];
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1D34E11F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id *a12, uint64_t a13)
{
  if (a12) {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,void *>>>::operator()[abi:ne180100]((uint64_t)&a13, a12);
  }
  _Unwind_Resume(exception_object);
}

id std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<FPProviderDomain * const {__strong}&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, id **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x28uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *unint64_t v8 = 0;
  v8[1] = a2;
  id result = **a3;
  void v8[3] = 0;
  v8[4] = 0;
  v8[2] = result;
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,void *>>>::operator()[abi:ne180100](uint64_t a1, id *a2)
{
  if (*(unsigned char *)(a1 + 8))
  {
    objc_destroyWeak(a2 + 3);
  }
  else if (!a2)
  {
    return;
  }
  operator delete(a2);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,void *>>>::operator()[abi:ne180100](uint64_t a1, void *__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    objc_destroyWeak((id *)__p + 3);
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)__p + 2);
  }
  if (__p)
  {
    operator delete(__p);
  }
}

uint64_t **std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<FPProviderDomain * {__strong},std::pair<FPProviderDomain * const {__strong},std::pair<FINode * {__weak},unsigned long>> const&>(uint64_t a1, id *a2, uint64_t a3)
{
  unint64_t v7 = [*a2 hash];
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v9) {
        unint64_t v3 = v7 % v9;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v7;
    }
    unint64_t v12 = *(uint64_t ****)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = (uint64_t **)*i)
      {
        unint64_t v14 = (unint64_t)i[1];
        if (v14 == v8)
        {
          if (std::equal_to<FPProviderDomain * {__strong}>::operator()(a1 + 32, i[2], *a2)) {
            return i;
          }
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9) {
              v14 %= v9;
            }
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v3) {
            break;
          }
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__construct_node_hash<std::pair<FPProviderDomain * const {__strong},std::pair<FINode * {__weak},unsigned long>> const&>(a1, v8, a3, (uint64_t)v24);
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 32);
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    BOOL v17 = 1;
    if (v9 >= 3) {
      BOOL v17 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v9);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v20);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  size_t v21 = *(void **)(*(void *)a1 + 8 * v3);
  if (v21)
  {
    *(void *)v24[0] = *v21;
    *size_t v21 = v24[0];
  }
  else
  {
    *(void *)v24[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v24[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v24[0])
    {
      unint64_t v22 = *(void *)(*(void *)v24[0] + 8);
      if ((v9 & (v9 - 1)) != 0)
      {
        if (v22 >= v9) {
          v22 %= v9;
        }
      }
      else
      {
        v22 &= v9 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v22) = v24[0];
    }
  }
  uint64_t i = (uint64_t **)v24[0];
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1D34E1594(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id *a10, uint64_t a11)
{
  if (a10) {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,void *>>>::operator()[abi:ne180100]((uint64_t)&a11, a10);
  }
  _Unwind_Resume(exception_object);
}

void std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__construct_node_hash<std::pair<FPProviderDomain * const {__strong},std::pair<FINode * {__weak},unsigned long>> const&>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x28uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(void *)unint64_t v8 = 0;
  *((void *)v8 + 1) = a2;
  *((void *)v8 + 2) = *(id *)a3;
  objc_copyWeak((id *)v8 + 3, (id *)(a3 + 8));
  *((void *)v8 + 4) = *(void *)(a3 + 16);
  *(unsigned char *)(a4 + 16) = 1;
}

void *std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3>,void ()(FPProviderDomain *,FPItem *,NSError *)>::~__func(void *a1)
{
  *a1 = &unk_1F2ABAC38;
  std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table((uint64_t)(a1 + 1));
  return a1;
}

void std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3>,void ()(FPProviderDomain *,FPItem *,NSError *)>::~__func(void *a1)
{
  *a1 = &unk_1F2ABAC38;
  std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table((uint64_t)(a1 + 1));
  JUMPOUT(0x1D9436740);
}

_WORD *std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3>,void ()(FPProviderDomain *,FPItem *,NSError *)>::__clone(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  unint64_t v3 = operator new(0x38uLL);
  *(void *)unint64_t v3 = &unk_1F2ABAC38;
  std::unordered_map<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>::unordered_map((uint64_t)(v3 + 4), v2);
  v3[24] = *(_WORD *)(a1 + 48);
  *((unsigned char *)v3 + 50) = *(unsigned char *)(a1 + 50);
  return v3;
}

void sub_1D34E1748(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3>,void ()(FPProviderDomain *,FPItem *,NSError *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F2ABAC38;
  uint64_t result = std::unordered_map<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>::unordered_map(a2 + 8, a1 + 8);
  __int16 v5 = *(_WORD *)(a1 + 48);
  *(unsigned char *)(a2 + 50) = *(unsigned char *)(a1 + 50);
  *(_WORD *)(a2 + 48) = v5;
  return result;
}

uint64_t std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3>,void ()(FPProviderDomain *,FPItem *,NSError *)>::destroy(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table(a1 + 8);
}

void std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3>,void ()(FPProviderDomain *,FPItem *,NSError *)>::operator()(unsigned char *a1, id *a2, void **a3, void **a4)
{
  id v24 = (id)*MEMORY[0x1E4F143B8];
  uint64_t v5 = (uint64_t)(a1 + 8);
  uint64_t v6 = *a3;
  uint64_t v7 = *a4;
  id v19 = *a2;
  id v8 = v6;
  id v9 = v7;
  float v16 = &v19;
  uint8x8_t v10 = std::__hash_table<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::hash<FPProviderDomain * {__strong}>,std::equal_to<FPProviderDomain * {__strong}>,true>,std::__unordered_map_equal<FPProviderDomain * {__strong},std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>,std::equal_to<FPProviderDomain * {__strong}>,std::hash<FPProviderDomain * {__strong}>,true>,std::allocator<std::__hash_value_type<FPProviderDomain * {__strong},std::pair<FINode * {__weak},unsigned long>>>>::__emplace_unique_key_args<FPProviderDomain * {__strong},std::piecewise_construct_t const&,std::tuple<FPProviderDomain * const {__strong}&>,std::tuple<>>(v5, &v19, (uint64_t)&std::piecewise_construct, &v16);
  WeakRetained = (FINode *)objc_loadWeakRetained((id *)v10 + 3);
  unint64_t v12 = WeakRetained;
  if (WeakRetained)
  {
    id v13 = [(FINode *)WeakRetained fpItem];
    if (v13 == v8)
    {
    }
    else
    {
      BOOL v14 = a1[48] == 0;

      if (!v14)
      {
        float v15 = (const TNode *)TNodeFromFINode(v12);
        TNodePtr::TNodePtr(&v22, v15);
        id v23 = v8;
        BOOL v17 = 0;
        unint64_t v18 = 0;
        float v16 = 0;
        size_t v20 = &v16;
        char v21 = 0;
        float v16 = (id *)operator new(0x10uLL);
        BOOL v17 = v16;
        unint64_t v18 = v16 + 2;
        BOOL v17 = (id *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<TNodePtr,FPItem * {__strong}>>,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}> const*,std::pair<TNodePtr,FPItem * {__strong}>*>((uint64_t)&v18, (id *)&v22.fFINode, &v24, v16);
        TNode::AttachFPItemsMetadata(&v16, a1[49], a1[50]);
        size_t v20 = &v16;
        std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v20);
      }
    }
  }
}

void sub_1D34E1958(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void **a14, uint64_t a15, id a16, id a17)
{
  std::vector<fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>::__destroy_vector::operator()[abi:ne180100](&a14);

  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3>,void ()(FPProviderDomain *,FPItem *,NSError *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_3>,void ()(FPProviderDomain *,FPItem *,NSError *)>::target_type()
{
}

void *std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5>,void ()(__CFURL const*,FPItem *,NSError *)>::~__func(void *a1)
{
  *a1 = &unk_1F2ABAC90;
  std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table((uint64_t)(a1 + 1));
  return a1;
}

void std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5>,void ()(__CFURL const*,FPItem *,NSError *)>::~__func(void *a1)
{
  *a1 = &unk_1F2ABAC90;
  std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table((uint64_t)(a1 + 1));
  JUMPOUT(0x1D9436740);
}

uint64_t std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5>,void ()(__CFURL const*,FPItem *,NSError *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F2ABAC90;
  uint64_t result = std::unordered_map<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>::unordered_map(a2 + 8, a1 + 8);
  __int16 v5 = *(_WORD *)(a1 + 48);
  *(unsigned char *)(a2 + 50) = *(unsigned char *)(a1 + 50);
  *(_WORD *)(a2 + 48) = v5;
  return result;
}

uint64_t std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5>,void ()(__CFURL const*,FPItem *,NSError *)>::destroy(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::__unordered_map_hasher<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::__unordered_map_equal<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>,std::equal_to<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,std::hash<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>>,true>,std::allocator<std::__hash_value_type<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::pair<FINode * {__weak},unsigned long>>>>::~__hash_table(a1 + 8);
}

uint64_t std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5>,void ()(__CFURL const*,FPItem *,NSError *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5,std::allocator<TNode::UpdateFPItemsIfNeeded(std::vector<TNodePtr> const&,std::chrono::duration<double,std::ratio<1l,1l>> const&,BOOL,BOOL,BOOL)::$_5>,void ()(__CFURL const*,FPItem *,NSError *)>::target_type()
{
}

uint64_t std::__function::__value_func<void ()(FPItem *,NSError *)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__func<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(__CFURL const*,FPItem *,NSError *)>::~__func(void *a1)
{
  *a1 = &unk_1F2ABD1E0;
  std::__function::__value_func<void ()(FPItem *,NSError *)>::~__value_func[abi:ne180100](a1 + 1);
  return a1;
}

void std::__function::__func<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(__CFURL const*,FPItem *,NSError *)>::~__func(void *a1)
{
  *a1 = &unk_1F2ABD1E0;
  std::__function::__value_func<void ()(FPItem *,NSError *)>::~__value_func[abi:ne180100](a1 + 1);
  JUMPOUT(0x1D9436740);
}

void *std::__function::__func<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(__CFURL const*,FPItem *,NSError *)>::__clone(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = &unk_1F2ABD1E0;
  std::__function::__value_func<void ()(FPItem *,NSError *)>::__value_func[abi:ne180100]((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1D34E1CFC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(__CFURL const*,FPItem *,NSError *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2ABD1E0;
  return std::__function::__value_func<void ()(FPItem *,NSError *)>::__value_func[abi:ne180100]((uint64_t)(a2 + 1), a1 + 8);
}

void *std::__function::__func<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(__CFURL const*,FPItem *,NSError *)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(FPItem *,NSError *)>::~__value_func[abi:ne180100]((void *)(a1 + 8));
}

void std::__function::__func<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(__CFURL const*,FPItem *,NSError *)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(FPItem *,NSError *)>::~__value_func[abi:ne180100](a1 + 1);
  operator delete(a1);
}

void std::__function::__func<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(__CFURL const*,FPItem *,NSError *)>::operator()(uint64_t a1, uint64_t a2, id *a3, void **a4)
{
  __int16 v5 = *a4;
  id v7 = *a3;
  id v6 = v5;
  if (*(void *)(a1 + 32)) {
    std::function<void ()(FPItem *,NSError *)>::operator()(a1 + 8, v7, v6);
  }
}

void sub_1D34E1DF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(__CFURL const*,FPItem *,NSError *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::FPItemFromURLWithTimeout(__CFURL const*,std::chrono::duration<double,std::ratio<1l,1l>>,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(__CFURL const*,FPItem *,NSError *)>::target_type()
{
}

void std::__shared_ptr_emplace<std::unordered_map<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2AB9AB0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::unordered_map<TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>,std::tuple<std::optional<FPItem * {__strong}>,std::optional<NSError * {__strong}>,std::shared_ptr<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2AB9AB0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

void std::__shared_ptr_emplace<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2AB9AE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::function<void ()(__CFURL const*,FPItem *,NSError *)>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2AB9AE8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

void *std::__function::__func<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(FPProviderDomain *,FPItem *,NSError *)>::~__func(void *a1)
{
  *a1 = &unk_1F2ABACE8;
  std::__function::__value_func<void ()(FPItem *,NSError *)>::~__value_func[abi:ne180100](a1 + 1);
  return a1;
}

void std::__function::__func<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(FPProviderDomain *,FPItem *,NSError *)>::~__func(void *a1)
{
  *a1 = &unk_1F2ABACE8;
  std::__function::__value_func<void ()(FPItem *,NSError *)>::~__value_func[abi:ne180100](a1 + 1);
  JUMPOUT(0x1D9436740);
}

void *std::__function::__func<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(FPProviderDomain *,FPItem *,NSError *)>::__clone(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x28uLL);
  void *v2 = &unk_1F2ABACE8;
  std::__function::__value_func<void ()(FPItem *,NSError *)>::__value_func[abi:ne180100]((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1D34E2038(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(FPProviderDomain *,FPItem *,NSError *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2ABACE8;
  return std::__function::__value_func<void ()(FPItem *,NSError *)>::__value_func[abi:ne180100]((uint64_t)(a2 + 1), a1 + 8);
}

void *std::__function::__func<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(FPProviderDomain *,FPItem *,NSError *)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(FPItem *,NSError *)>::~__value_func[abi:ne180100]((void *)(a1 + 8));
}

void std::__function::__func<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(FPProviderDomain *,FPItem *,NSError *)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(FPItem *,NSError *)>::~__value_func[abi:ne180100](a1 + 1);
  operator delete(a1);
}

void std::__function::__func<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(FPProviderDomain *,FPItem *,NSError *)>::operator()(uint64_t a1, uint64_t a2, id *a3, void **a4)
{
  __int16 v5 = *a4;
  id v7 = *a3;
  id v6 = v5;
  if (*(void *)(a1 + 32)) {
    std::function<void ()(FPItem *,NSError *)>::operator()(a1 + 8, v7, v6);
  }
}

void sub_1D34E212C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(FPProviderDomain *,FPItem *,NSError *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0,std::allocator<TNode::RootFPItemForDomainWithTimeout(FPProviderDomain *,std::chrono::duration<double,std::ratio<1l,1l>> const&,std::function<void ()(FPItem *,NSError *)> const&)::$_0>,void ()(FPProviderDomain *,FPItem *,NSError *)>::target_type()
{
}

void std::__shared_ptr_emplace<std::unordered_map<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB400;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::unordered_map<FPProviderDomain * {__strong},fstd::optional_err<FPItem * {__strong},NSError * {__strong}>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB400;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

void FormatDetails<std::chrono::duration<double,std::ratio<1l,1l>>,FPProviderDomain * {__strong}>(long long *a1@<X0>, double *a2@<X1>, void **a3@<X2>, std::string *a4@<X8>)
{
  memset(&__p, 0, sizeof(__p));
  long long v12 = *a1;
  do
  {
    unint64_t v7 = FormatOneDetails<std::chrono::duration<double,std::ratio<1l,1l>>>((const std::string::value_type **)&v12, &__p, a2);
    if (v7)
    {
      *((unsigned char *)&a4->__r_.__value_.__s + 23) = 0;
      a4->__r_.__value_.__s.__data_[0] = 0;
      goto LABEL_13;
    }
  }
  while (HIDWORD(v7) == 7);
  FormatDetails<FPProviderDomain * {__strong}>(&v12, a3, &v11);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  uint8x8_t v10 = std::string::insert(&v11, 0, (const std::string::value_type *)p_p, size);
  *a4 = *v10;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v11.__r_.__value_.__l.__data_);
  }
LABEL_13:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1D34E22E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  _Unwind_Resume(exception_object);
}

uint64_t FormatOneDetails<std::chrono::duration<double,std::ratio<1l,1l>>>(const std::string::value_type **a1, std::string *this, double *a3)
{
  uint64_t v3 = a1[1];
  if (v3)
  {
    unint64_t v7 = *a1;
    id v8 = (unsigned __int8 *)&v3[(void)*a1];
    uint64_t v9 = 1;
    uint8x8_t v10 = (unsigned __int8 *)*a1;
    while (2)
    {
      for (uint64_t i = 0; i != 3; ++i)
      {
        if (*v10 == asc_1D3522C21[i])
        {
          uint64_t v12 = 0;
          uint64_t v9 = 1;
          if (v10 != v8)
          {
            unint64_t v13 = v10 - (unsigned __int8 *)v7;
            if (v10 - (unsigned __int8 *)v7 != -1)
            {
              std::string::append(this, v7, v10 - (unsigned __int8 *)v7);
              BOOL v14 = a1[1];
              BOOL v15 = (unint64_t)v14 >= v13;
              float v16 = &v14[-v13];
              if (!v15) {
LABEL_93:
              }
                std::__throw_out_of_range[abi:ne180100]("string_view::substr");
              *a1 += v13;
              a1[1] = v16;
              ParseFormat(a1, (uint64_t)&v48);
              size_t v17 = v49;
              if (v49)
              {
                switch(v50)
                {
                  case 1u:
                  case 2u:
                  case 3u:
                    goto LABEL_90;
                  case 4u:
                    if (v49 > 0x7FFFFFFFFFFFFFF7) {
                      goto LABEL_94;
                    }
                    unint64_t v18 = v48;
                    if (v49 >= 0x17)
                    {
                      uint64_t v26 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((v49 | 7) != 0x17) {
                        uint64_t v26 = v49 | 7;
                      }
                      uint64_t v27 = v26 + 1;
                      p_dst = operator new(v26 + 1);
                      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
                      __dst.__r_.__value_.__r.__words[2] = v27 | 0x8000000000000000;
                    }
                    else
                    {
                      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v49;
                      p_dst = &__dst;
                    }
                    memmove(p_dst, v18, v17);
                    *((unsigned char *)p_dst + v17) = 0;
                    std::string::basic_string[abi:ne180100]<0>(&__p, "??? (hex)");
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      p_p = &__p;
                    }
                    else {
                      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                    }
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type size = __p.__r_.__value_.__l.__size_;
                    }
                    goto LABEL_56;
                  case 5u:
                    std::to_string(&__dst, *a3);
                    RedactForPrivacy((uint64_t *)&v48, (uint64_t)&__dst, &__p);
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      p_p = &__p;
                    }
                    else {
                      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                    }
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type size = __p.__r_.__value_.__l.__size_;
                    }
                    goto LABEL_56;
                  case 6u:
                    std::to_string(&__dst, *a3);
                    RedactForPrivacy((uint64_t *)&v48, (uint64_t)&__dst, &__p);
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      p_p = &__p;
                    }
                    else {
                      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                    }
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type size = __p.__r_.__value_.__l.__size_;
                    }
                    goto LABEL_56;
                  case 7u:
                    DeEscapeFormatFragment((uint64_t)&v48, &__p);
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      id v24 = &__p;
                    }
                    else {
                      id v24 = (std::string *)__p.__r_.__value_.__r.__words[0];
                    }
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type v25 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type v25 = __p.__r_.__value_.__l.__size_;
                    }
                    std::string::append(this, (const std::string::value_type *)v24, v25);
                    goto LABEL_87;
                  case 8u:
                    if (v49 > 0x7FFFFFFFFFFFFFF7) {
LABEL_94:
                    }
                      std::string::__throw_length_error[abi:ne180100]();
                    TNodePtr v22 = v48;
                    if (v49 >= 0x17)
                    {
                      uint64_t v29 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((v49 | 7) != 0x17) {
                        uint64_t v29 = v49 | 7;
                      }
                      uint64_t v30 = v29 + 1;
                      id v23 = operator new(v29 + 1);
                      __dst.__r_.__value_.__l.__size_ = v17;
                      __dst.__r_.__value_.__r.__words[2] = v30 | 0x8000000000000000;
                      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v23;
                    }
                    else
                    {
                      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v49;
                      id v23 = &__dst;
                    }
                    memmove(v23, v22, v17);
                    *((unsigned char *)v23 + v17) = 0;
                    ExtractEmbeddedFormat(&__dst, &__p);
                    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__dst.__r_.__value_.__l.__data_);
                    }
                    std::string::size_type v31 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    uint64_t v32 = &__p;
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                    {
                      std::string::size_type v31 = __p.__r_.__value_.__l.__size_;
                      uint64_t v32 = (std::string *)__p.__r_.__value_.__r.__words[0];
                    }
                    v45.__r_.__value_.__r.__words[0] = (std::string::size_type)v32;
                    v45.__r_.__value_.__l.__size_ = v31;
                    FormatDetails<std::chrono::duration<double,std::ratio<1l,1l>>>((long long *)&v45, &__dst);
                    uint64_t v33 = (void *)v49;
                    if (v49 > 0x7FFFFFFFFFFFFFF7) {
                      std::string::__throw_length_error[abi:ne180100]();
                    }
                    int v34 = v48;
                    if (v49 >= 0x17)
                    {
                      uint64_t v36 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((v49 | 7) != 0x17) {
                        uint64_t v36 = v49 | 7;
                      }
                      uint64_t v37 = v36 + 1;
                      char v35 = operator new(v36 + 1);
                      v43[1] = v33;
                      unint64_t v44 = v37 | 0x8000000000000000;
                      v43[0] = v35;
                    }
                    else
                    {
                      HIBYTE(v44) = v49;
                      char v35 = v43;
                      if (!v49) {
                        goto LABEL_75;
                      }
                    }
                    memmove(v35, v34, (size_t)v33);
LABEL_75:
                    *((unsigned char *)v33 + (void)v35) = 0;
                    ExtendedFormatAdaptor((char *)v43, (uint64_t)&__dst, &v45);
                    if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      char v38 = &v45;
                    }
                    else {
                      char v38 = (std::string *)v45.__r_.__value_.__r.__words[0];
                    }
                    if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type v39 = HIBYTE(v45.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type v39 = v45.__r_.__value_.__l.__size_;
                    }
                    std::string::append(this, (const std::string::value_type *)v38, v39);
                    if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(v45.__r_.__value_.__l.__data_);
                    }
                    if (SHIBYTE(v44) < 0) {
                      operator delete(v43[0]);
                    }
                    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__dst.__r_.__value_.__l.__data_);
                    }
LABEL_87:
                    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                    {
                      uint64_t v28 = (void *)__p.__r_.__value_.__r.__words[0];
LABEL_89:
                      operator delete(v28);
                    }
LABEL_90:
                    uint64_t v40 = a1[1];
                    uint64_t v41 = &v40[-v49];
                    if ((unint64_t)v40 < v49) {
                      goto LABEL_93;
                    }
                    uint64_t v9 = 0;
                    *a1 += v49;
                    a1[1] = v41;
                    uint64_t v12 = v50;
                    break;
                  default:
                    std::to_string(&__dst, *a3);
                    RedactForPrivacy((uint64_t *)&v48, (uint64_t)&__dst, &__p);
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      p_p = &__p;
                    }
                    else {
                      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                    }
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type size = __p.__r_.__value_.__l.__size_;
                    }
LABEL_56:
                    std::string::append(this, (const std::string::value_type *)p_p, size);
                    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__p.__r_.__value_.__l.__data_);
                    }
                    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                      goto LABEL_90;
                    }
                    uint64_t v28 = (void *)__dst.__r_.__value_.__r.__words[0];
                    goto LABEL_89;
                }
              }
              else
              {
                uint64_t v12 = 0;
                uint64_t v9 = 2;
              }
            }
          }
          return v9 | (v12 << 32);
        }
      }
      if (++v10 != v8) {
        continue;
      }
      break;
    }
    uint64_t v12 = 0;
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t v9 = 1;
  }
  return v9 | (v12 << 32);
}

void sub_1D34E27F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  _Unwind_Resume(exception_object);
}

void FormatDetails<FPProviderDomain * {__strong}>(long long *a1@<X0>, void **a2@<X1>, std::string *a3@<X8>)
{
  memset(&v11, 0, sizeof(v11));
  long long v10 = *a1;
  do
  {
    unint64_t v5 = FormatOneDetails<FPProviderDomain * {__strong}>((const std::string::value_type **)&v10, &v11, a2);
    if (v5)
    {
      *((unsigned char *)&a3->__r_.__value_.__s + 23) = 0;
      a3->__r_.__value_.__s.__data_[0] = 0;
      goto LABEL_13;
    }
  }
  while (HIDWORD(v5) == 7);
  FormatDetails(&v10, &v9);
  if ((v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    id v6 = &v11;
  }
  else {
    id v6 = (std::string *)v11.__r_.__value_.__r.__words[0];
  }
  if ((v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v11.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v11.__r_.__value_.__l.__size_;
  }
  id v8 = std::string::insert(&v9, 0, (const std::string::value_type *)v6, size);
  *a3 = *v8;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
LABEL_13:
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v11.__r_.__value_.__l.__data_);
  }
}

void sub_1D34E299C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v15 - 17) < 0) {
    operator delete(*(void **)(v15 - 40));
  }
  _Unwind_Resume(exception_object);
}

void FormatDetails<std::chrono::duration<double,std::ratio<1l,1l>>>(long long *a1@<X0>, std::string *a2@<X8>)
{
  memset(&v9, 0, sizeof(v9));
  long long v8 = *a1;
  do
  {
    unint64_t v3 = FormatOneDetails<std::chrono::duration<double,std::ratio<1l,1l>>>((int)&v8, &v9);
    if (v3)
    {
      *((unsigned char *)&a2->__r_.__value_.__s + 23) = 0;
      a2->__r_.__value_.__s.__data_[0] = 0;
      goto LABEL_13;
    }
  }
  while (HIDWORD(v3) == 7);
  FormatDetails(&v8, &v7);
  if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v4 = &v9;
  }
  else {
    unint64_t v4 = (std::string *)v9.__r_.__value_.__r.__words[0];
  }
  if ((v9.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v9.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v9.__r_.__value_.__l.__size_;
  }
  id v6 = std::string::insert(&v7, 0, (const std::string::value_type *)v4, size);
  *a2 = *v6;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v7.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v7.__r_.__value_.__l.__data_);
  }
LABEL_13:
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
}

void sub_1D34E2AA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v15 - 17) < 0) {
    operator delete(*(void **)(v15 - 40));
  }
  _Unwind_Resume(exception_object);
}

uint64_t FormatOneDetails<FPProviderDomain * {__strong}>(const std::string::value_type **a1, std::string *this, void **a3)
{
  unint64_t v3 = a1[1];
  if (v3)
  {
    std::string v7 = *a1;
    long long v8 = (unsigned __int8 *)&v3[(void)*a1];
    uint64_t v9 = 1;
    long long v10 = (unsigned __int8 *)*a1;
    while (2)
    {
      for (uint64_t i = 0; i != 3; ++i)
      {
        if (*v10 == asc_1D3522C21[i])
        {
          uint64_t v12 = 0;
          uint64_t v9 = 1;
          if (v10 != v8)
          {
            unint64_t v13 = v10 - (unsigned __int8 *)v7;
            if (v10 - (unsigned __int8 *)v7 != -1)
            {
              std::string::append(this, v7, v10 - (unsigned __int8 *)v7);
              BOOL v14 = a1[1];
              BOOL v15 = (unint64_t)v14 >= v13;
              float v16 = &v14[-v13];
              if (!v15) {
LABEL_93:
              }
                std::__throw_out_of_range[abi:ne180100]("string_view::substr");
              *a1 += v13;
              a1[1] = v16;
              ParseFormat(a1, (uint64_t)&v48);
              std::string::size_type v17 = v49;
              if (v49)
              {
                switch(v50)
                {
                  case 1u:
                  case 2u:
                  case 3u:
                    goto LABEL_90;
                  case 4u:
                    if (v49 > 0x7FFFFFFFFFFFFFF7) {
                      goto LABEL_94;
                    }
                    unint64_t v18 = v48;
                    if (v49 >= 0x17)
                    {
                      uint64_t v26 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((v49 | 7) != 0x17) {
                        uint64_t v26 = v49 | 7;
                      }
                      uint64_t v27 = v26 + 1;
                      p_dst = (std::string *)operator new(v26 + 1);
                      __dst.__r_.__value_.__l.__size_ = v17;
                      __dst.__r_.__value_.__r.__words[2] = v27 | 0x8000000000000000;
                      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
                    }
                    else
                    {
                      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v49;
                      p_dst = &__dst;
                    }
                    memmove(p_dst, v18, v17);
                    p_dst->__r_.__value_.__s.__data_[v17] = 0;
                    HexDescriptionPrinterGlue<FPProviderDomain * {__strong},void>::dump((uint64_t)&__dst, a3, &__p);
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      p_p = &__p;
                    }
                    else {
                      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                    }
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type size = __p.__r_.__value_.__l.__size_;
                    }
                    goto LABEL_56;
                  case 5u:
                    Description<FPProviderDomain * {__strong}>(a3, &__dst);
                    RedactForPrivacy((uint64_t *)&v48, (uint64_t)&__dst, &__p);
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      p_p = &__p;
                    }
                    else {
                      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                    }
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type size = __p.__r_.__value_.__l.__size_;
                    }
                    goto LABEL_56;
                  case 6u:
                    Description<FPProviderDomain * {__strong}>(a3, &__dst);
                    RedactForPrivacy((uint64_t *)&v48, (uint64_t)&__dst, &__p);
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      p_p = &__p;
                    }
                    else {
                      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                    }
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type size = __p.__r_.__value_.__l.__size_;
                    }
                    goto LABEL_56;
                  case 7u:
                    DeEscapeFormatFragment((uint64_t)&v48, &__p);
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      id v24 = &__p;
                    }
                    else {
                      id v24 = (std::string *)__p.__r_.__value_.__r.__words[0];
                    }
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type v25 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type v25 = __p.__r_.__value_.__l.__size_;
                    }
                    std::string::append(this, (const std::string::value_type *)v24, v25);
                    goto LABEL_87;
                  case 8u:
                    if (v49 > 0x7FFFFFFFFFFFFFF7) {
LABEL_94:
                    }
                      std::string::__throw_length_error[abi:ne180100]();
                    TNodePtr v22 = v48;
                    if (v49 >= 0x17)
                    {
                      uint64_t v29 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((v49 | 7) != 0x17) {
                        uint64_t v29 = v49 | 7;
                      }
                      uint64_t v30 = v29 + 1;
                      id v23 = (std::string *)operator new(v29 + 1);
                      __dst.__r_.__value_.__l.__size_ = v17;
                      __dst.__r_.__value_.__r.__words[2] = v30 | 0x8000000000000000;
                      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v23;
                    }
                    else
                    {
                      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v49;
                      id v23 = &__dst;
                    }
                    memmove(v23, v22, v17);
                    v23->__r_.__value_.__s.__data_[v17] = 0;
                    ExtractEmbeddedFormat(&__dst, &__p);
                    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__dst.__r_.__value_.__l.__data_);
                    }
                    std::string::size_type v31 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    uint64_t v32 = &__p;
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                    {
                      std::string::size_type v31 = __p.__r_.__value_.__l.__size_;
                      uint64_t v32 = (std::string *)__p.__r_.__value_.__r.__words[0];
                    }
                    v45.__r_.__value_.__r.__words[0] = (std::string::size_type)v32;
                    v45.__r_.__value_.__l.__size_ = v31;
                    FormatDetails<FPProviderDomain * {__strong}>(&__dst, &v45, a3);
                    uint64_t v33 = (void *)v49;
                    if (v49 > 0x7FFFFFFFFFFFFFF7) {
                      std::string::__throw_length_error[abi:ne180100]();
                    }
                    int v34 = v48;
                    if (v49 >= 0x17)
                    {
                      uint64_t v36 = (v49 & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((v49 | 7) != 0x17) {
                        uint64_t v36 = v49 | 7;
                      }
                      uint64_t v37 = v36 + 1;
                      char v35 = operator new(v36 + 1);
                      v43[1] = v33;
                      unint64_t v44 = v37 | 0x8000000000000000;
                      v43[0] = v35;
                    }
                    else
                    {
                      HIBYTE(v44) = v49;
                      char v35 = v43;
                      if (!v49) {
                        goto LABEL_75;
                      }
                    }
                    memmove(v35, v34, (size_t)v33);
LABEL_75:
                    *((unsigned char *)v33 + (void)v35) = 0;
                    ExtendedFormatAdaptor((char *)v43, (uint64_t)&__dst, &v45);
                    if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      char v38 = &v45;
                    }
                    else {
                      char v38 = (std::string *)v45.__r_.__value_.__r.__words[0];
                    }
                    if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type v39 = HIBYTE(v45.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type v39 = v45.__r_.__value_.__l.__size_;
                    }
                    std::string::append(this, (const std::string::value_type *)v38, v39);
                    if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(v45.__r_.__value_.__l.__data_);
                    }
                    if (SHIBYTE(v44) < 0) {
                      operator delete(v43[0]);
                    }
                    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__dst.__r_.__value_.__l.__data_);
                    }
LABEL_87:
                    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                    {
                      uint64_t v28 = (void *)__p.__r_.__value_.__r.__words[0];
LABEL_89:
                      operator delete(v28);
                    }
LABEL_90:
                    uint64_t v40 = a1[1];
                    uint64_t v41 = &v40[-v49];
                    if ((unint64_t)v40 < v49) {
                      goto LABEL_93;
                    }
                    uint64_t v9 = 0;
                    *a1 += v49;
                    a1[1] = v41;
                    uint64_t v12 = v50;
                    break;
                  default:
                    Description<FPProviderDomain * {__strong}>(a3, &__dst);
                    RedactForPrivacy((uint64_t *)&v48, (uint64_t)&__dst, &__p);
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      p_p = &__p;
                    }
                    else {
                      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                    }
                    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type size = __p.__r_.__value_.__l.__size_;
                    }
LABEL_56:
                    std::string::append(this, (const std::string::value_type *)p_p, size);
                    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__p.__r_.__value_.__l.__data_);
                    }
                    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                      goto LABEL_90;
                    }
                    uint64_t v28 = (void *)__dst.__r_.__value_.__r.__words[0];
                    goto LABEL_89;
                }
              }
              else
              {
                uint64_t v12 = 0;
                uint64_t v9 = 2;
              }
            }
          }
          return v9 | (v12 << 32);
        }
      }
      if (++v10 != v8) {
        continue;
      }
      break;
    }
    uint64_t v12 = 0;
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t v9 = 1;
  }
  return v9 | (v12 << 32);
}

void sub_1D34E2FB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  _Unwind_Resume(exception_object);
}

void *HexDescriptionPrinterGlue<FPProviderDomain * {__strong},void>::dump@<X0>(uint64_t a1@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  v14[19] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(unsigned __int8 *)(a1 + 23);
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *(void *)(a1 + 8);
  }
  if (v5)
  {
    WidenHexFormatStringSpecifierToLongLong((char *)a1, (uint64_t)__p);
    if (v9 >= 0) {
      snprintf(__str, 0x64uLL, (const char *)__p, *a2);
    }
    else {
      snprintf(__str, 0x64uLL, (const char *)__p[0], *a2);
    }
    if (v9 < 0) {
      operator delete(__p[0]);
    }
    return std::string::basic_string[abi:ne180100]<0>(a3, __str);
  }
  else
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)__str);
    *(_DWORD *)((char *)v12 + *(void *)(v11 - 24)) = *(_DWORD *)((unsigned char *)v12 + *(void *)(v11 - 24)) & 0xFFFFFFB5 | 8;
    std::ostream::operator<<();
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v12, a3);
    *(void *)__str = *MEMORY[0x1E4FBA408];
    uint64_t v7 = *(void *)(MEMORY[0x1E4FBA408] + 72);
    *(void *)&__str[*(void *)(*(void *)__str - 24)] = *(void *)(MEMORY[0x1E4FBA408] + 64);
    uint64_t v11 = v7;
    v12[0] = MEMORY[0x1E4FBA470] + 16;
    if (v13 < 0) {
      operator delete((void *)v12[8]);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    return (void *)MEMORY[0x1D94366B0](v14);
  }
}

void sub_1D34E32C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void *Description<FPProviderDomain * {__strong}>@<X0>(void **a1@<X0>, void *a2@<X8>)
{
  unint64_t v3 = *a1;
  if (v3)
  {
    id v4 = [v3 description];
    uint64_t v5 = [v4 UTF8String];

    if (v5) {
      id v6 = (char *)v5;
    }
    else {
      id v6 = "<nil>";
    }
  }
  else
  {
    id v6 = "0x0";
  }
  return std::string::basic_string[abi:ne180100]<0>(a2, v6);
}

void sub_1D34E3358(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<std::tuple<FPProviderDomain * {__strong}>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB470;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::tuple<FPProviderDomain * {__strong}>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB470;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

void std::__shared_ptr_emplace<std::tuple<FPProviderDomain * {__strong}>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::allocate_shared[abi:ne180100]<TFSInfo,std::allocator<TFSInfo>,FIProviderDomain * {__strong},decltype(nullptr),BOOL,void>@<X0>(FIProviderDomain **a1@<X1>, uint64_t a2@<X2>, unsigned __int8 *a3@<X3>, void *a4@<X8>)
{
  long long v8 = (char *)operator new(0x98uLL);
  uint64_t result = std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FIProviderDomain * {__strong},decltype(nullptr),BOOL,std::allocator<TFSInfo>,0>((uint64_t)v8, a1, a2, a3);
  *a4 = v8 + 24;
  a4[1] = v8;
  return result;
}

void sub_1D34E3448(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<TFSInfo>::__shared_ptr_emplace[abi:ne180100]<FIProviderDomain * {__strong},decltype(nullptr),BOOL,std::allocator<TFSInfo>,0>(uint64_t a1, FIProviderDomain **a2, uint64_t a3, unsigned __int8 *a4)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1F2ABB358;
  TFSInfo::TFSInfo((TFSInfo *)(a1 + 24), *a2, 0, *a4);
  return a1;
}

void sub_1D34E34B0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<std::vector<TNodePtr>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB4A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::vector<TNodePtr>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB4A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

void *std::allocate_shared[abi:ne180100]<TFSInfoSizer,std::allocator<TFSInfoSizer>,TNodePtr &,TNodePtr,std::shared_ptr<TNodeTask> const&,void>@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, void *a4@<X8>)
{
  long long v8 = operator new(0x80uLL);
  uint64_t result = std::__shared_ptr_emplace<TFSInfoSizer>::__shared_ptr_emplace[abi:ne180100]<TNodePtr &,TNodePtr,std::shared_ptr<TNodeTask> const&,std::allocator<TFSInfoSizer>,0>(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_1D34E3598(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<TFSInfoSizer>::__shared_ptr_emplace[abi:ne180100]<TNodePtr &,TNodePtr,std::shared_ptr<TNodeTask> const&,std::allocator<TFSInfoSizer>,0>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2ABB128;
  TFSInfoSizer::TFSInfoSizer(a1 + 3, a2, a3, a4, 0);
  return a1;
}

void sub_1D34E35F8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::find<__SFNode *>(void *a1, void *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2 >> 2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    uint64_t v5 = *a2 >> 2;
    if (v3 >= *(void *)&v2) {
      uint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    uint64_t v5 = (*(void *)&v2 - 1) & v3;
  }
  id v6 = *(void **)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  uint64_t result = (void *)*v6;
  if (*v6)
  {
    do
    {
      unint64_t v8 = result[1];
      if (v8 == v3)
      {
        if (result[2] == *a2) {
          return result;
        }
      }
      else
      {
        if (v4.u32[0] > 1uLL)
        {
          if (v8 >= *(void *)&v2) {
            v8 %= *(void *)&v2;
          }
        }
        else
        {
          v8 &= *(void *)&v2 - 1;
        }
        if (v8 != v5) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::__emplace_unique_key_args<__SFNode *,std::piecewise_construct_t const&,std::tuple<__SFNode * const&>,std::tuple<>>(uint64_t a1, void *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = *a2 >> 2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      uint64_t v4 = *a2 >> 2;
      if (v7 >= v8) {
        uint64_t v4 = v7 % v8;
      }
    }
    else
    {
      uint64_t v4 = (v8 - 1) & v7;
    }
    long long v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      for (uint64_t i = *v10; i; uint64_t i = (void *)*i)
      {
        unint64_t v12 = i[1];
        if (v12 == v7)
        {
          if (i[2] == *a2) {
            return i;
          }
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
          }
          else
          {
            v12 &= v8 - 1;
          }
          if (v12 != v4) {
            break;
          }
        }
      }
    }
  }
  char v13 = (void *)(a1 + 16);
  uint64_t i = operator new(0x20uLL);
  void *i = 0;
  i[1] = v7;
  i[2] = **a4;
  i[3] = 0;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    BOOL v16 = 1;
    if (v8 >= 3) {
      BOOL v16 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v8);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v19);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        uint64_t v4 = v7 % v8;
      }
      else {
        uint64_t v4 = v7;
      }
    }
    else
    {
      uint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v20 = *(void *)a1;
  char v21 = *(void **)(*(void *)a1 + 8 * v4);
  if (v21)
  {
    void *i = *v21;
LABEL_38:
    *char v21 = i;
    goto LABEL_39;
  }
  void *i = *v13;
  *char v13 = i;
  *(void *)(v20 + 8 * v4) = v13;
  if (*i)
  {
    unint64_t v22 = *(void *)(*i + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8) {
        v22 %= v8;
      }
    }
    else
    {
      v22 &= v8 - 1;
    }
    char v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1D34E3958(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<__SFNode *,TNodePtr>,void *>>>::operator()[abi:ne180100](v2, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<__SFNode *,TNodePtr>,void *>>>::operator()[abi:ne180100](uint64_t a1, id *a2)
{
  if (*(unsigned char *)(a1 + 8))
  {
  }
  else if (!a2)
  {
    return;
  }
  operator delete(a2);
}

uint64_t std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::erase(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::remove(a1, a2, (uint64_t)&__p);
  unint64_t v3 = (id *)__p;
  std::string __p = 0;
  if (v3)
  {
    if (v6) {

    }
    operator delete(v3);
  }
  return v2;
}

uint64_t std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::__deallocate_node(a1, *(id **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<__SFNode *,TNodePtr>,std::__unordered_map_hasher<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,TNWNodeHasher,std::equal_to<__SFNode *>,true>,std::__unordered_map_equal<__SFNode *,std::__hash_value_type<__SFNode *,TNodePtr>,std::equal_to<__SFNode *>,TNWNodeHasher,true>,std::allocator<std::__hash_value_type<__SFNode *,TNodePtr>>>::__deallocate_node(uint64_t a1, id *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      unint64_t v3 = (id *)*v2;

      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void TChildrenList::SubscribeWithKQueue(TChildrenList *this)
{
  uint64_t v1 = *((void *)this + 12);
  memset(&v2, 0, sizeof(v2));
  TNode::RequestInternalTask(v1, 1008, &v2, 0);
  TPropertyValue::~TPropertyValue(&v2);
}

void sub_1D34E3AEC(_Unwind_Exception *a1, TPropertyValue *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void TChildrenList::UnsubscribeWithKQueue(TChildrenList *this)
{
  uint64_t v1 = *((void *)this + 12);
  memset(&v2, 0, sizeof(v2));
  TNode::RequestInternalTask(v1, 1009, &v2, 0);
  TPropertyValue::~TPropertyValue(&v2);
}

void sub_1D34E3B48(_Unwind_Exception *a1, TPropertyValue *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

uint64_t TChildrenList::GetLastResizeDuration(TChildrenList *this)
{
  return *((void *)this + 17);
}

TChildrenList *TChildrenList::SetLastResizeDuration(TChildrenList *this, uint64_t a2)
{
  *((void *)this + 17) = a2;
  return this;
}

uint64_t TChildrenList::GetSubscriptionFileDescriptor(TChildrenList *this)
{
  return *((unsigned int *)this + 44);
}

TChildrenList *TChildrenList::SetSubscriptionFileDescriptor(TChildrenList *this, int a2)
{
  *((_DWORD *)this + 44) = a2;
  return this;
}

uint64_t TChildrenList::IncrementSubscriptionCount(TChildrenList *this)
{
  return atomic_fetch_add((atomic_uint *volatile)this + 47, 1u);
}

uint64_t TChildrenList::DecrementSubscriptionCount(TChildrenList *this)
{
  return atomic_fetch_add((atomic_uint *volatile)this + 47, 0xFFFFFFFF);
}

TChildrenList *TChildrenList::DecrementRegisteredChildrenCount(TChildrenList *this)
{
  return this;
}

uint64_t TChildrenList::LastResizeTime(TChildrenList *this)
{
  return *((void *)this + 16);
}

TChildrenList *TChildrenList::SetLastResizeTime(TChildrenList *this, uint64_t a2)
{
  *((void *)this + 16) = a2;
  return this;
}

void TChildrenList::SetNSProgressSubscriber(TChildrenList *this, objc_object *a2)
{
  uint64_t v4 = a2;
  TDSMutex::lock((TDSMutex *)this);
  objc_storeStrong((id *)this + 21, a2);
  TDSMutex::unlock((TDSMutex *)this);
}

void sub_1D34E3C24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id TChildrenList::NSProgressSubscriber(TChildrenList *this)
{
  TDSMutex::lock((TDSMutex *)this);
  id v2 = *((id *)this + 21);
  TDSMutex::unlock((TDSMutex *)this);
  return v2;
}

unint64_t TChildrenList::ChildrenCount(TChildrenList *this)
{
  return atomic_load((unint64_t *)this + 20);
}

BOOL TChildrenList::RemoveChildren(uint64_t a1, FINode ***a2, uint64_t a3)
{
  uint64_t v3 = a1 + 64;
  if (*(void *)(a1 + 64) == *(void *)(a1 + 72)) {
    return 0;
  }
  char v6 = *a2;
  unint64_t v7 = a2[1];
  if (v6 == v7) {
    return 0;
  }
  std::unordered_set<TNodePtr>::unordered_set<std::__wrap_iter<TNodePtr const*>>((uint64_t)v26, v6, v7);
  std::vector<TNodePtr>::reserve(a3, v26[3]);
  uint8x8_t v9 = *(FINode ***)(a1 + 64);
  long long v10 = *(FINode ***)(a1 + 72);
  int64_t v24 = (char *)v10 - (char *)v9;
  if (v10 == v9)
  {
LABEL_7:
    uint64_t v12 = 0;
  }
  else
  {
    unint64_t v11 = 1;
    while (!std::__hash_table<TNodePtr,std::hash<TNodePtr>,std::equal_to<TNodePtr>,std::allocator<TNodePtr>>::find<TNodePtr>(v26, v9))
    {
      ++v9;
      ++v11;
      if (v9 == v10) {
        goto LABEL_7;
      }
    }
    uint64_t v16 = TNodeFromFINode(*v9);
    uint64_t v17 = *(void *)(a1 + 96);
    unint64_t v18 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v16);
    uint64_t v25 = a3;
    os_unfair_lock_lock(v18);
    if (*(void *)(v16 + 48) == v17) {
      *(void *)(v16 + 48) = 0;
    }
    os_unfair_lock_unlock(v18);
    uint64_t v12 = v11 - 1 < *(void *)(a1 + 152);
    std::vector<TNodePtr>::push_back[abi:ne180100](a3, (id *)v9);
    if (v9 != v10)
    {
      for (uint64_t i = v9 + 1; i != v10; ++i)
      {
        if (std::__hash_table<TNodePtr,std::hash<TNodePtr>,std::equal_to<TNodePtr>,std::allocator<TNodePtr>>::find<TNodePtr>(v26, i))
        {
          uint64_t v20 = TNodeFromFINode(*i);
          uint64_t v21 = *(void *)(a1 + 96);
          unint64_t v22 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v20);
          os_unfair_lock_lock(v22);
          if (*(void *)(v20 + 48) == v21) {
            *(void *)(v20 + 48) = 0;
          }
          os_unfair_lock_unlock(v22);
          unint64_t v23 = *(void *)(a1 + 152);
          std::vector<TNodePtr>::push_back[abi:ne180100](v25, (id *)i);
          if (v11 < v23) {
            ++v12;
          }
        }
        else
        {
          TNodePtr::operator=((void **)v9++, (void **)i);
        }
        ++v11;
      }
      goto LABEL_9;
    }
  }
  uint8x8_t v9 = v10;
LABEL_9:
  std::vector<TNodePtr>::erase(v3, (void **)v9, *(void ***)(a1 + 72));
  *(void *)(a1 + 152) -= v12;
  uint64_t v13 = *(void *)(a1 + 72) - *(void *)(a1 + 64);
  BOOL v14 = v24 != v13;
  if (v24 != v13)
  {
    atomic_store(v13 >> 3, (unint64_t *)(a1 + 160));
    ++*(_DWORD *)(a1 + 184);
  }
  std::__hash_table<TNodePtr,std::hash<TNodePtr>,std::equal_to<TNodePtr>,std::allocator<TNodePtr>>::~__hash_table((uint64_t)v26);
  return v14;
}

void sub_1D34E3E98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__hash_table<TNodePtr,std::hash<TNodePtr>,std::equal_to<TNodePtr>,std::allocator<TNodePtr>>::~__hash_table((uint64_t)va);
  _Unwind_Resume(a1);
}

void **std::vector<TNodePtr>::erase(uint64_t a1, void **a2, void **a3)
{
  if (a2 != a3)
  {
    uint64_t v5 = a3;
    char v6 = *(void ***)(a1 + 8);
    if (a3 == v6)
    {
      unint64_t v8 = a2;
    }
    else
    {
      uint64_t v7 = a3 - a2;
      unint64_t v8 = a2;
      do
      {
        TNodePtr::operator=(v8, &v8[v7]);
        ++v8;
      }
      while (&v8[v7] != v6);
      uint64_t v5 = *(void ***)(a1 + 8);
    }
    while (v5 != v8)
    {
      uint8x8_t v9 = *--v5;
    }
    *(void *)(a1 + 8) = v8;
  }
  return a2;
}

BOOL TChildrenList::RemoveChild(TChildrenList *this, const TNodePtr *a2)
{
  memset(v11, 0, sizeof(v11));
  uint64_t v3 = a2->fFINode;
  uint8x8_t v9 = 0;
  long long v10 = 0;
  unint64_t v8 = 0;
  uint64_t v12 = &v8;
  char v13 = 0;
  uint64_t v4 = (void **)operator new(8uLL);
  unint64_t v8 = v4;
  uint8x8_t v9 = v4;
  long long v10 = v4 + 1;
  uint64_t v5 = v3;
  objc_object *v4 = v5;
  uint8x8_t v9 = v4 + 1;
  BOOL v6 = TChildrenList::RemoveChildren((uint64_t)this, (FINode ***)&v8, (uint64_t)v11);
  uint64_t v12 = &v8;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100]((void ***)&v12);

  unint64_t v8 = (void **)v11;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&v8);
  return v6;
}

void sub_1D34E4020(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, void **a15)
{
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&a15);

  a9 = (void **)&a12;
  std::vector<TNodePtr>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void TChildrenList::Clear(TChildrenList *this)
{
  TChildrenList::DetachChildren(this);
  uint64_t v2 = *((void *)this + 8);
  for (uint64_t i = *((void *)this + 9); i != v2; i -= 8)
  {
    uint64_t v4 = *(void **)(i - 8);
  }
  *((void *)this + 9) = v2;
  *((void *)this + 19) = 0;
}

TChildrenList *TChildrenList::InvalidateSortOrder(TChildrenList *this)
{
  *((void *)this + 19) = 0;
  return this;
}

id *std::vector<TNodePtr>::insert(uint64_t a1, id *a2, id *a3)
{
  uint64_t v4 = a2;
  unint64_t v6 = *(void *)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if (v6 >= v7)
  {
    uint8x8_t v9 = *(id **)a1;
    unint64_t v10 = ((uint64_t)(v6 - *(void *)a1) >> 3) + 1;
    if (v10 >> 61) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = (char *)a2 - (char *)v9;
    uint64_t v12 = a2 - v9;
    uint64_t v13 = v7 - (void)v9;
    if (v13 >> 2 > v10) {
      unint64_t v10 = v13 >> 2;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v10;
    }
    uint64_t v39 = a1 + 16;
    if (v14) {
      float v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(a1 + 16, v14);
    }
    else {
      float v15 = 0;
    }
    uint64_t v16 = (id *)&v15[8 * v12];
    char v35 = v15;
    uint64_t v36 = v16;
    uint64_t v37 = (char *)v16;
    char v38 = &v15[8 * v14];
    if (v12 == v14)
    {
      if (v11 < 1)
      {
        if (v9 == v4) {
          unint64_t v18 = 1;
        }
        else {
          unint64_t v18 = v11 >> 2;
        }
        v40[4] = v8;
        size_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v8, v18);
        uint64_t v21 = v19;
        unint64_t v22 = &v19[8 * (v18 >> 2)];
        unint64_t v23 = &v19[8 * v20];
        int64_t v24 = v36;
        uint64_t v25 = v36;
        uint64_t v26 = v22;
        uint64_t v27 = v37 - (char *)v36;
        if (v37 != (char *)v36)
        {
          int v34 = &v19[8 * v20];
          uint64_t v26 = &v22[v27 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v28 = 8 * (v27 >> 3);
          uint64_t v29 = &v19[8 * (v18 >> 2)];
          uint64_t v30 = v36;
          do
          {
            uint64_t v29 = (char *)(TNodePtr::TNodePtr(v29, v30++) + 1);
            v28 -= 8;
          }
          while (v28);
          uint64_t v25 = (id *)v37;
          unint64_t v23 = v34;
        }
        std::string::size_type v31 = v35;
        uint64_t v32 = v38;
        char v35 = v21;
        uint64_t v36 = (id *)v22;
        v40[0] = v31;
        v40[1] = v24;
        uint64_t v37 = v26;
        char v38 = v23;
        v40[2] = v25;
        v40[3] = v32;
        std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)v40);
        uint64_t v16 = (id *)v26;
      }
      else
      {
        unint64_t v17 = v12 + 2;
        if (v12 >= -1) {
          unint64_t v17 = v12 + 1;
        }
        v16 -= v17 >> 1;
        uint64_t v36 = v16;
        uint64_t v37 = (char *)v16;
      }
    }
    id *v16 = *a3;
    v37 += 8;
    uint64_t v4 = std::vector<TNodePtr>::__swap_out_circular_buffer((id **)a1, &v35, v4);
    std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)&v35);
  }
  else if (a2 == (id *)v6)
  {
    *a2 = *a3;
    *(void *)(a1 + 8) = v4 + 1;
  }
  else
  {
    std::vector<TNodePtr>::__move_range(a1, (uint64_t)a2, v6, (uint64_t)(a2 + 1));
    if (v4 <= a3) {
      a3 += *(void *)(a1 + 8) > (unint64_t)a3;
    }
    objc_storeStrong(v4, *a3);
  }
  return v4;
}

void sub_1D34E42D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void TChildrenList::FindByFPItem(TChildrenList *this@<X0>, FPItem *a2@<X1>, TNodePtr *a3@<X8>)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a2;
  unint64_t v6 = v5;
  unint64_t v7 = v5;
  if (v5)
  {
    uint64_t v26 = a3;
    uint64_t v25 = v5;
    uint64_t v8 = v25;
    unint64_t v10 = (FINode **)*((void *)this + 8);
    uint8x8_t v9 = (FINode **)*((void *)this + 9);
    uint64_t v27 = this;
    uint64_t v11 = v8;
    if (v10 != v9)
    {
      while (1)
      {
        uint64_t v12 = TNodeFromFINode(*v10);
        uint64_t v13 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v12);
        os_unfair_lock_lock(v13);
        float v15 = *(TFSInfo **)(v12 + 16);
        unint64_t v14 = *(std::__shared_weak_count **)(v12 + 24);
        if (v14) {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        os_unfair_lock_unlock(v13);
        unint64_t v6 = v7;
        uint64_t v16 = TFSInfo::GetFPItem(v15);
        if (v14) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v14);
        }
        if (objc_msgSend(v16, "isEqualToItem:", v11, v25, v26)) {
          break;
        }
        unint64_t v17 = [(FPItem *)v11 formerIdentifier];
        unint64_t v18 = [v16 itemIdentifier];
        if ([v17 isEqualToString:v18])
        {
          size_t v19 = [(FPItem *)v11 providerDomainID];
          uint64_t v20 = [v16 providerDomainID];
          int v21 = [v19 isEqualToString:v20];

          if (v21)
          {
            unint64_t v22 = LogObj(4);
            BOOL v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG);
            unint64_t v6 = v7;
            if (v23)
            {
              *(_DWORD *)long long buf = 138543618;
              std::string::size_type v31 = v25;
              __int16 v32 = 2114;
              uint64_t v33 = v16;
              _os_log_impl(&dword_1D343E000, v22, OS_LOG_TYPE_DEBUG, "Found new item matching to stitched childItem\n%{public}@\n%{public}@", buf, 0x16u);
            }

            break;
          }
        }
        else
        {
        }
        if (++v10 == v9)
        {
          unint64_t v10 = v9;
          unint64_t v6 = v7;
          goto LABEL_19;
        }
      }
    }
LABEL_19:

    if (v10 == *((FINode ***)v27 + 9))
    {
      char v24 = 0;
      LOBYTE(v28) = 0;
    }
    else
    {
      uint64_t v28 = *v10;
      char v24 = 1;
    }
    char v29 = v24;

    std::optional<TNodePtr>::value_or[abi:ne180100]<decltype(nullptr) const&>((uint64_t)&v28, v26);
    if (v29) {
  }
    }
  else
  {
    TNodePtr::TNodePtr(a3, 0);
  }
}

void sub_1D34E4584(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void TChildrenList::FindByFileIdentifier(TChildrenList *this@<X0>, uint64_t a2@<X1>, TNodePtr *a3@<X8>)
{
  uint64_t v4 = (FINode **)*((void *)this + 8);
  uint64_t v5 = (FINode **)*((void *)this + 9);
  if (v4 == v5) {
    goto LABEL_11;
  }
  while (1)
  {
    uint64_t v8 = TNodeFromFINode(*v4);
    uint8x8_t v9 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v8);
    os_unfair_lock_lock(v9);
    uint64_t v11 = *(TFSInfo **)(v8 + 16);
    unint64_t v10 = *(std::__shared_weak_count **)(v8 + 24);
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v9);
    uint64_t ObjectIdentifier = TFSInfo::GetObjectIdentifier(v11);
    if (v10) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v10);
    }
    if (ObjectIdentifier == a2) {
      break;
    }
    if (++v4 == v5)
    {
      uint64_t v4 = v5;
      break;
    }
  }
  if (v4 == *((FINode ***)this + 9))
  {
LABEL_11:
    char v13 = 0;
    LOBYTE(v14) = 0;
  }
  else
  {
    unint64_t v14 = *v4;
    char v13 = 1;
  }
  char v15 = v13;
  std::optional<TNodePtr>::value_or[abi:ne180100]<decltype(nullptr) const&>((uint64_t)&v14, a3);
  if (v15) {
}
  }

void sub_1D34E4730(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, char a12)
{
  if (a12) {

  }
  _Unwind_Resume(exception_object);
}

void TChildrenList::FindNodeMatchingFPItem(TChildrenList *this@<X0>, FPItem *a2@<X1>, TNodePtr *a3@<X8>)
{
  uint64_t v5 = a2;
  if (!TNode::IsFPv2(*((TNode **)this + 12), 1))
  {
    unint64_t v6 = [(FPItem *)v5 filename];
    v20.fString.int fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(&v20, v6);

    SlashesToColons(&v20, &v21);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v20.fString.fRef);

    TChildrenList::Find(this, &v21, (TNodePtr *)&v20);
    if (!TNodeFromFINode((FINode *)v20.fString.fRef)) {
      goto LABEL_11;
    }
    uint64_t v7 = TNodeFromFINode((FINode *)v20.fString.fRef);
    uint64_t v8 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v7);
    os_unfair_lock_lock(v8);
    unint64_t v10 = *(TFSInfo **)(v7 + 16);
    uint8x8_t v9 = *(std::__shared_weak_count **)(v7 + 24);
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v8);
    uint64_t ObjectIdentifier = TFSInfo::GetObjectIdentifier(v10);
    if (v9) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v9);
    }
    uint64_t v12 = [(FPItem *)v5 fileID];
    if (v12 == ObjectIdentifier)
    {
      TNodePtr::TNodePtr(a3, (id *)&v20.fString.fRef);
LABEL_12:

      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v21.fString.fRef);
      goto LABEL_13;
    }
    if (v12)
    {
LABEL_11:
      TChildrenList::FindByFileIdentifier(this, [(FPItem *)v5 fileID], a3);
      goto LABEL_12;
    }
    char v13 = [(__CFString *)v20.fString.fRef fiDomain];
    unint64_t v14 = [v13 identifier];

    char v15 = v14;
    v19.fString.int fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(&v19, v15);

    if (IsLocalStorageDomainID(&v19))
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v19.fString.fRef);
    }
    else
    {
      uint64_t v16 = v15;
      v18.fString.int fRef = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      TString::SetStringRefAsImmutable(&v18, v16);

      BOOL v17 = IsExternalDeviceDomainID(&v18);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v18.fString.fRef);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v19.fString.fRef);
      if (!v17)
      {

        goto LABEL_11;
      }
    }
    TNodePtr::TNodePtr(a3, (id *)&v20.fString.fRef);

    goto LABEL_12;
  }
  TChildrenList::FindByFPItem(this, v5, a3);
LABEL_13:
}

void sub_1D34E49AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10, id a11, const void *a12)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a12);
  _Unwind_Resume(a1);
}

void TChildrenList::FindDisplayName(TChildrenList *this@<X0>, const TString *a2@<X1>, TNodePtr *a3@<X8>)
{
  TNodePtr::TNodePtr(&v11, *((const TNode **)this + 12));
  TNode::StPopulating::StPopulating((TNode::StPopulating *)v12, &v11, 0);

  uint64_t v7 = (FINode **)*((void *)this + 8);
  unint64_t v6 = (FINode **)*((void *)this + 9);
  if (v7 == v6) {
    goto LABEL_8;
  }
  do
  {
    uint64_t v8 = (TNode *)TNodeFromFINode(*v7);
    BOOL v9 = TNode::EqualDisplayName(v8, a2);
    v7 += !v9;
    char v10 = v7 == v6 || v9;
  }
  while ((v10 & 1) == 0);
  if (v7 == v6) {
LABEL_8:
  }
    TNodePtr::TNodePtr(a3, 0);
  else {
    a3->fFINode = *v7;
  }
  TNode::StPopulating::~StPopulating((TNode::StPopulating *)v12);
}

void sub_1D34E4B54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TNode::StPopulating::~StPopulating((TNode::StPopulating *)va);
  _Unwind_Resume(a1);
}

void TChildrenList::ClearSizesFetchedForUnobservedNodes(TChildrenList *this)
{
  TNodePtr::TNodePtr(&v17, *((const TNode **)this + 12));
  TNode::StPopulating::StPopulating((TNode::StPopulating *)v18, &v17, 0);

  for (uint64_t i = (FINode **)*((void *)this + 8); i != *((FINode ***)this + 9); ++i)
  {
    uint64_t v3 = (TNode *)TNodeFromFINode(*i);
    if (!atomic_load((unsigned int *)(TNode::GetNotifierList(v3) + 4)))
    {
      uint64_t v5 = TNodeFromFINode(*i);
      unint64_t v6 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v5);
      os_unfair_lock_lock(v6);
      uint64_t v8 = *(void *)(v5 + 16);
      uint64_t v7 = *(std::__shared_weak_count **)(v5 + 24);
      if (v7)
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        os_unfair_lock_unlock(v6);
        BOOL v9 = (os_unfair_lock_s *)(v8 + 100);
        os_unfair_lock_lock((os_unfair_lock_t)(v8 + 100));
        int v11 = *(_DWORD *)(v8 + 115);
        uint64_t v10 = v8 + 115;
        __int16 v12 = *(_WORD *)(v10 + 4);
        *(_DWORD *)uint64_t v10 = v11 & 0xF7FFFFFF;
        *(_WORD *)(v10 + 4) = v12;
        os_unfair_lock_unlock(v9);
        std::__shared_weak_count::__release_shared[abi:ne180100](v7);
      }
      else
      {
        os_unfair_lock_unlock(v6);
        char v13 = (os_unfair_lock_s *)(v8 + 100);
        os_unfair_lock_lock((os_unfair_lock_t)(v8 + 100));
        int v15 = *(_DWORD *)(v8 + 115);
        uint64_t v14 = v8 + 115;
        __int16 v16 = *(_WORD *)(v14 + 4);
        *(_DWORD *)uint64_t v14 = v15 & 0xF7FFFFFF;
        *(_WORD *)(v14 + 4) = v16;
        os_unfair_lock_unlock(v13);
      }
    }
  }
  TNode::StPopulating::~StPopulating((TNode::StPopulating *)v18);
}

void sub_1D34E4CBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void TChildrenList::StartCollectionStatusObserver(uint64_t a1, void *a2, uint64_t a3, void *a4, int a5)
{
  id v14 = a2;
  BOOL v9 = a4;
  uint64_t v10 = (os_unfair_lock_s *)TChildrenList::InternalLock(v9);
  os_unfair_lock_lock(v10);
  int v11 = *(void **)(a1 + 104);
  if (!a5)
  {
    if (!v11)
    {
      uint64_t v12 = objc_opt_new();
      char v13 = *(void **)(a1 + 104);
      *(void *)(a1 + 104) = v12;

LABEL_8:
      [*(id *)(a1 + 104) startObserving:v14 forParent:a3 withQueue:v9];
      goto LABEL_9;
    }
LABEL_5:
    [v11 stopObserving];
    if (a5) {
      [*(id *)(a1 + 104) resetError];
    }
    goto LABEL_8;
  }
  if (v11) {
    goto LABEL_5;
  }
LABEL_9:
  os_unfair_lock_unlock(v10);
}

void sub_1D34E4DB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

BOOL TChildrenList::StopCollectionStatusObserver(TChildrenList *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TChildrenList::InternalLock(this);
  os_unfair_lock_lock(v2);
  [*((id *)this + 13) stopObserving];
  BOOL v3 = *((void *)this + 13) != 0;
  os_unfair_lock_unlock(v2);
  return v3;
}

void sub_1D34E4E2C(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void TChildrenList::ClearCollectionStatusObserver(TChildrenList *this)
{
  uint64_t v2 = (os_unfair_lock_s *)TChildrenList::InternalLock(this);
  os_unfair_lock_lock(v2);
  [*((id *)this + 13) stopObserving];
  BOOL v3 = (void *)*((void *)this + 13);
  *((void *)this + 13) = 0;

  os_unfair_lock_unlock(v2);
}

void sub_1D34E4E94(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void **std::vector<TNodePtr>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = v7 - a4;
  BOOL v9 = (id *)(a2 + v7 - a4);
  if ((unint64_t)v9 >= a3)
  {
    uint64_t result = *(void ***)(a1 + 8);
  }
  else
  {
    uint64_t result = *(void ***)(a1 + 8);
    do
    {
      uint64_t v12 = TNodePtr::TNodePtr(result, v9++);
      uint64_t result = (void **)(v12 + 1);
    }
    while ((unint64_t)v9 < a3);
  }
  *(void *)(a1 + 8) = result;
  if (v7 != a4)
  {
    char v13 = (void **)(v7 - 8);
    uint64_t v14 = 8 * (v8 >> 3);
    uint64_t v15 = a2 - 8;
    do
    {
      uint64_t result = TNodePtr::operator=(v13--, (void **)(v15 + v14));
      v14 -= 8;
    }
    while (v14);
  }
  return result;
}

id *std::vector<TNodePtr>::__swap_out_circular_buffer(id **a1, void *a2, id *a3)
{
  BOOL v3 = a3;
  unint64_t v6 = (id *)a2[1];
  uint64_t v7 = *a1;
  uint64_t v8 = v6;
  if (v7 != a3)
  {
    uint64_t v8 = (id *)a2[1];
    BOOL v9 = a3;
    do
      uint64_t v8 = (id *)TNodePtr::TNodePtr(v8 - 1, --v9);
    while (v9 != v7);
  }
  a2[1] = v8;
  uint64_t v10 = a1[1];
  int v11 = (void *)a2[2];
  if (v10 != v3)
  {
    do
      TNodePtr::TNodePtr(v11++, v3++);
    while (v3 != v10);
    uint64_t v8 = (id *)a2[1];
  }
  a2[2] = v11;
  uint64_t v12 = *a1;
  *a1 = v8;
  a2[1] = v12;
  char v13 = a1[1];
  a1[1] = (id *)a2[2];
  a2[2] = v13;
  uint64_t v14 = a1[2];
  a1[2] = (id *)a2[3];
  a2[3] = v14;
  *a2 = a2[1];
  return v6;
}

uint64_t **std::__hash_table<TNodePtr,std::hash<TNodePtr>,std::equal_to<TNodePtr>,std::allocator<TNodePtr>>::find<TNodePtr>(void *a1, FINode **a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v4 = (unint64_t)*a2 >> 2;
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v2);
  v5.i16[0] = vaddlv_u8(v5);
  unint64_t v6 = v5.u32[0];
  if (v5.u32[0] > 1uLL)
  {
    unint64_t v7 = (unint64_t)*a2 >> 2;
    if (v4 >= *(void *)&v2) {
      unint64_t v7 = v4 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = (*(void *)&v2 - 1) & v4;
  }
  uint64_t v8 = *(uint64_t ****)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  for (uint64_t i = *v8; i; uint64_t i = (uint64_t **)*i)
  {
    unint64_t v10 = (unint64_t)i[1];
    if (v4 == v10)
    {
      uint64_t v11 = TNodeFromFINode((FINode *)i[2]);
      if (v11 == TNodeFromFINode(*a2)) {
        return i;
      }
    }
    else
    {
      if (v6 > 1)
      {
        if (v10 >= *(void *)&v2) {
          v10 %= *(void *)&v2;
        }
      }
      else
      {
        v10 &= *(void *)&v2 - 1;
      }
      if (v10 != v7) {
        return 0;
      }
    }
  }
  return i;
}

void std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *,0>(id *a1, void **a2, void **a3, void **a4, void **a5)
{
  char v13 = (FINode **)a2;
  uint64_t v14 = a1;
  uint64_t v11 = (FINode **)a4;
  uint64_t v12 = (FINode **)a3;
  unint64_t v10 = a5;
  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(a1, a2, a3, a4);
  if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)a5, (FINode **)a4))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>((id **)&v11, &v10);
    if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()(v11, (FINode **)a3))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>((id **)&v12, (void ***)&v11);
      if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()(v12, (FINode **)a2))
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>((id **)&v13, (void ***)&v12);
        if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()(v13, (FINode **)a1)) {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>(&v14, (void ***)&v13);
        }
      }
    }
  }
}

uint64_t std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(id *a1, void **a2)
{
  int8x8_t v2 = a2;
  uint64_t v11 = a2;
  uint64_t v12 = a1;
  BOOL v4 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v4;
    case 2:
      uint64_t v11 = a2 - 1;
      if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)a2 - 1, (FINode **)a1)) {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>(&v12, &v11);
      }
      return v4;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(a1, a1 + 1, a2 - 1);
      return v4;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(a1, a1 + 1, a1 + 2, a2 - 1);
      return v4;
    case 5:
      std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return v4;
    default:
      uint8x8_t v5 = a1 + 2;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(a1, a1 + 1, a1 + 2);
      unint64_t v6 = (FINode **)(a1 + 3);
      if (v6 == (FINode **)v2) {
        return 1;
      }
      int v7 = 0;
      break;
  }
  while (!TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()(v6, (FINode **)v5))
  {
LABEL_12:
    uint8x8_t v5 = (id *)v6++;
    if (v6 == (FINode **)v2) {
      return 1;
    }
  }
  TNodePtr::TNodePtr(&v10, (id *)v6);
  do
  {
    uint64_t v8 = v5;
    TNodePtr::operator=(v5 + 1, v5);
    if (v5 == v12) {
      break;
    }
    --v5;
  }
  while (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)&v10, (FINode **)v8 - 1));
  TNodePtr::operator=(v8, &v10);
  if (++v7 != 8)
  {

    int8x8_t v2 = v11;
    goto LABEL_12;
  }
  BOOL v4 = v6 + 1 == (FINode **)v11;

  return v4;
}

void sub_1D34E53B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(id *a1, void **a2, void **a3, void **a4)
{
  unint64_t v10 = (FINode **)a2;
  uint64_t v11 = a1;
  uint64_t v8 = a4;
  BOOL v9 = (FINode **)a3;
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,TChildrenList::SortListIfNeeded(unsigned long)::$_0 &,TNodePtr *>(a1, a2, a3);
  if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()((FINode **)a4, (FINode **)a3))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>((id **)&v9, &v8);
    if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()(v9, (FINode **)a2))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>((id **)&v10, (void ***)&v9);
      if (TChildrenList::SortListIfNeeded(unsigned long)::$_0::operator()(v10, (FINode **)a1)) {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:ne180100]<TNodePtr *&,TNodePtr *&>(&v11, (void ***)&v10);
      }
    }
  }
}

uint64_t std::unordered_set<TNodePtr>::unordered_set<std::__wrap_iter<TNodePtr const*>>(uint64_t a1, FINode **a2, FINode **a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a2 != a3)
  {
    uint8x8_t v5 = a2;
    do
    {
      std::__hash_table<TNodePtr,std::hash<TNodePtr>,std::equal_to<TNodePtr>,std::allocator<TNodePtr>>::__emplace_unique_key_args<TNodePtr,TNodePtr const&>(a1, v5, (id *)v5);
      ++v5;
    }
    while (v5 != a3);
  }
  return a1;
}

void sub_1D34E54E8(_Unwind_Exception *a1)
{
  std::__hash_table<TNodePtr,std::hash<TNodePtr>,std::equal_to<TNodePtr>,std::allocator<TNodePtr>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<TNodePtr,std::hash<TNodePtr>,std::equal_to<TNodePtr>,std::allocator<TNodePtr>>::__emplace_unique_key_args<TNodePtr,TNodePtr const&>(uint64_t a1, FINode **a2, id *a3)
{
  unint64_t v6 = (unint64_t)*a2 >> 2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v9.i16[0] = vaddlv_u8(v9);
    unint64_t v10 = v9.u32[0];
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v3 = (unint64_t)*a2 >> 2;
      if (v6 >= v7) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    uint64_t v11 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v11)
    {
      for (uint64_t i = *v11; i; uint64_t i = *(void **)i)
      {
        unint64_t v13 = *((void *)i + 1);
        if (v13 == v6)
        {
          uint64_t v14 = TNodeFromFINode(*((FINode **)i + 2));
          if (v14 == TNodeFromFINode(*a2)) {
            return i;
          }
        }
        else
        {
          if (v10 > 1)
          {
            if (v13 >= v7) {
              v13 %= v7;
            }
          }
          else
          {
            v13 &= v7 - 1;
          }
          if (v13 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t v15 = (void *)(a1 + 16);
  uint64_t i = operator new(0x18uLL);
  *(void *)uint64_t i = 0;
  *((void *)i + 1) = v6;
  *((void *)i + 2) = *a3;
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (!v7 || (float)(v17 * (float)v7) < v16)
  {
    BOOL v18 = 1;
    if (v7 >= 3) {
      BOOL v18 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v7);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v21);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v22 = *(void *)a1;
  BOOL v23 = *(void **)(*(void *)a1 + 8 * v3);
  if (v23)
  {
    *(void *)uint64_t i = *v23;
LABEL_38:
    *BOOL v23 = i;
    goto LABEL_39;
  }
  *(void *)uint64_t i = *v15;
  *uint64_t v15 = i;
  *(void *)(v22 + 8 * v3) = v15;
  if (*(void *)i)
  {
    unint64_t v24 = *(void *)(*(void *)i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    BOOL v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1D34E574C(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<TNodePtr,void *>>>::operator()[abi:ne180100](v2, v1);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<TNodePtr,void *>>>::operator()[abi:ne180100](uint64_t a1, id *a2)
{
  if (*(unsigned char *)(a1 + 8))
  {
  }
  else if (!a2)
  {
    return;
  }
  operator delete(a2);
}

void __destroy_helper_block_ea8_32c62_ZTSKZ49__FINodeObserver_observerForFINode_withObserver__E3__2(uint64_t a1)
{
  uint64_t v1 = (id *)(a1 + 32);
  objc_destroyWeak((id *)(a1 + 40));
  objc_destroyWeak(v1);
}

void sub_1D34E59D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  _Unwind_Resume(a1);
}

void sub_1D34E5A88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void __copy_helper_block_ea8_32c60_ZTSKZ47__FINodeObserver_observerForProxy_subjectNode__E3__4(uint64_t a1, uint64_t a2)
{
}

void __destroy_helper_block_ea8_32c60_ZTSKZ47__FINodeObserver_observerForProxy_subjectNode__E3__4(uint64_t a1)
{
}

void sub_1D34E5C28(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);

  _Unwind_Resume(a1);
}

void sub_1D34E5D18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  unint64_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)FINodeObserver;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1D34E5F08(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va4, a2);
  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint8x8_t v5 = va_arg(va1, const void *);
  va_copy(va2, va1);
  unint64_t v7 = va_arg(va2, const void *);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v10 = va_arg(va2, void);
  va_copy(va3, va2);
  uint64_t v11 = va_arg(va3, const void *);
  va_copy(va4, va3);
  unint64_t v13 = va_arg(va4, const void *);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va2);

  _Unwind_Resume(a1);
}

void NodeObservedOptionsCountRegistry::StoppedObserving(void *a1, uint64_t a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  id v26 = a1;
  std::mutex::lock(&NodeObservedOptionsCountRegistry::gRegistryLock);
  if (NodeObservedOptionsCountRegistry::gRegistry)
  {
    unint64_t v3 = std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::find<FINode * {__strong}>((void *)NodeObservedOptionsCountRegistry::gRegistry, &v26);
    if (v3)
    {
      if (a2)
      {
        int v4 = 1;
        uint64_t v5 = a2;
        do
        {
          if ((v4 & ~v5) == 0) {
            break;
          }
          uint64_t v5 = v5 & ~v4;
          v4 *= 2;
        }
        while (v5);
      }
      else
      {
        uint64_t v5 = 0;
        int v4 = 1;
      }
      unint64_t end_iter = bitmask_enum_iterator<NodeNotificationOptions>::make_end_iter(a2);
      int v10 = end_iter;
      int v12 = v11;
      uint64_t v13 = 0;
      uint64_t v25 = (uint64_t *)v3;
      uint64_t v14 = v3 + 3;
      unint64_t v15 = a2 | (unint64_t)(v5 << 32);
      unint64_t v16 = HIDWORD(end_iter);
LABEL_16:
      BOOL v18 = HIDWORD(v15) != v16 || v4 != v12;
      while (v15 != v10 || v18)
      {
        *(_DWORD *)long long buf = v4 & HIDWORD(v15);
        unint64_t v20 = std::__hash_table<TPropertyRecord,std::hash<TPropertyRecord>,std::equal_to<TPropertyRecord>,std::allocator<TPropertyRecord>>::find<TPropertyRecord>(v14, (unsigned int *)buf);
        if (v20)
        {
          uint64_t v21 = v20[3] - 1;
          v20[3] = v21;
          if (!v21) {
            std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::erase(v14, v20);
          }
          if (HIDWORD(v15))
          {
LABEL_32:
            unsigned int v22 = HIDWORD(v15) & ~v4;
            unint64_t v15 = v15 | ((unint64_t)v22 << 32);
            for (v4 *= 2; v22; v4 *= 2)
            {
              if ((v4 & ~v22) == 0) {
                break;
              }
              v22 &= ~v4;
              unint64_t v15 = v15 | ((unint64_t)v22 << 32);
            }
            goto LABEL_16;
          }
        }
        else
        {
          uint64_t v13 = *(_DWORD *)buf | v13;
          if (HIDWORD(v15)) {
            goto LABEL_32;
          }
        }
      }
      if (v13)
      {
        BOOL v23 = LogObj(5);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          unint64_t v24 = ShortDescription(v13);
          *(_DWORD *)long long buf = 138543618;
          id v28 = v24;
          __int16 v29 = 2114;
          id v30 = v26;
          _os_log_impl(&dword_1D343E000, v23, OS_LOG_TYPE_ERROR, "Unbalanced observing of '%{public}@' changes on %{public}@", buf, 0x16u);
        }
      }
      if (!v25[6]) {
        std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::erase((void *)NodeObservedOptionsCountRegistry::gRegistry, v25);
      }
      if (!*(void *)(NodeObservedOptionsCountRegistry::gRegistry + 24)) {
        std::unique_ptr<NodeObservedOptionsCountRegistry>::reset[abi:ne180100](&NodeObservedOptionsCountRegistry::gRegistry, 0);
      }
    }
    else
    {
      uint64_t v8 = LogObj(5);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        id v28 = v26;
        _os_log_impl(&dword_1D343E000, v8, OS_LOG_TYPE_ERROR, "Calling StoppedObserving on a node not being observed: %{public}@", buf, 0xCu);
      }
    }
  }
  else
  {
    unint64_t v6 = LogObj(5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      unint64_t v7 = ShortDescription(a2);
      *(_DWORD *)long long buf = 138543618;
      id v28 = v7;
      __int16 v29 = 2114;
      id v30 = v26;
      _os_log_impl(&dword_1D343E000, v6, OS_LOG_TYPE_ERROR, "Unbalanced observing of '%{public}@' changes on %{public}@. Registry is nil.", buf, 0x16u);
    }
  }
  std::mutex::unlock(&NodeObservedOptionsCountRegistry::gRegistryLock);
}

void sub_1D34E6320(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  std::mutex::unlock(&NodeObservedOptionsCountRegistry::gRegistryLock);
  _Unwind_Resume(a1);
}

NodeObservedOptionsCountRegistry *NodeObservedOptionsCountRegistry::AllObservedOptions(NodeObservedOptionsCountRegistry *this, FINode *a2)
{
  uint64_t v2 = this;
  id v6 = v2;
  if (v2)
  {
    std::mutex::lock(&NodeObservedOptionsCountRegistry::gRegistryLock);
    if (NodeObservedOptionsCountRegistry::gRegistry
      && (v3 = std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::find<FINode * {__strong}>((void *)NodeObservedOptionsCountRegistry::gRegistry, &v6)) != 0&& (int v4 = v3[5]) != 0)
    {
      LODWORD(v2) = 0;
      do
      {
        uint64_t v2 = (NodeObservedOptionsCountRegistry *)(*((_DWORD *)v4 + 4) | v2);
        int v4 = (uint64_t *)*v4;
      }
      while (v4);
    }
    else
    {
      uint64_t v2 = 0;
    }
    std::mutex::unlock(&NodeObservedOptionsCountRegistry::gRegistryLock);
  }
  return v2;
}

void sub_1D34E6414(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::__deallocate_node(a1, *(id **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::__deallocate_node(uint64_t a1, id *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      unint64_t v3 = (id *)*v2;
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)(v2 + 3));

      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,void *>>>::operator()[abi:ne180100](uint64_t a1, id *a2)
{
  if (*(unsigned char *)(a1 + 8))
  {
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)(a2 + 3));
  }
  else if (!a2)
  {
    return;
  }
  operator delete(a2);
}

uint64_t **std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::find<FINode * {__strong}>(void *a1, id *a2)
{
  unint64_t v4 = [*a2 hash];
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v9 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v9 = v4 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v9 = (*(void *)&v5 - 1) & v4;
  }
  int v10 = *(uint64_t ****)(*a1 + 8 * v9);
  if (!v10) {
    return 0;
  }
  int v11 = *v10;
  if (*v10)
  {
    uint64_t v12 = (uint64_t)(a1 + 4);
    do
    {
      unint64_t v13 = (unint64_t)v11[1];
      if (v13 == v6)
      {
        if (std::equal_to<FINode * {__strong}>::operator()(v12, v11[2], *a2)) {
          return v11;
        }
      }
      else
      {
        if (v8 > 1)
        {
          if (v13 >= *(void *)&v5) {
            v13 %= *(void *)&v5;
          }
        }
        else
        {
          v13 &= *(void *)&v5 - 1;
        }
        if (v13 != v9) {
          return 0;
        }
      }
      int v11 = (uint64_t **)*v11;
    }
    while (v11);
  }
  return v11;
}

uint64_t std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::erase(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::remove(a1, a2, (uint64_t)&v5);
  unint64_t v3 = v5;
  int8x8_t v5 = 0;
  if (v3) {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,void *>>>::operator()[abi:ne180100]((uint64_t)&v6, v3);
  }
  return v2;
}

void FIProviderDomainFetcher::FIProviderDomainFetcher(FIProviderDomainFetcher *this)
{
  *(void *)this = 850045863;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((void *)this + 7) = 0;
  uint64_t v2 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  *((void *)this + 8) = dispatch_queue_create("DomainFetcher", v2);

  *((void *)this + 9) = objc_alloc_init(MEMORY[0x1E4F1CA70]);
  *((unsigned char *)this + 80) = 0;
  *((void *)this + 11) = dispatch_semaphore_create(0);
}

void sub_1D34E6704(_Unwind_Exception *a1)
{
  std::mutex::~mutex((std::mutex *)v1);
  _Unwind_Resume(a1);
}

void FIProviderDomainFetcher::Start(FIProviderDomainFetcher *this)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  dispatch_assert_queue_V2(*((dispatch_queue_t *)this + 8));
  std::mutex::lock((std::mutex *)this);
  uint64_t v2 = [*((id *)this + 9) firstObject];
  std::mutex::unlock((std::mutex *)this);
  if (v2)
  {
    *(void *)&long long v3 = 138543618;
    long long v14 = v3;
    do
    {
      unint64_t v4 = LogObj(4);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        int8x8_t v5 = [v2 domainID];
        *(_DWORD *)long long buf = 138412290;
        float v17 = v5;
        _os_log_impl(&dword_1D343E000, v4, OS_LOG_TYPE_DEFAULT, "Looking up domain for id '%@'", buf, 0xCu);
      }
      uint64_t v6 = (void *)FPProviderDomainClass();
      uint8x8_t v7 = [v2 domainID];
      uint64_t v8 = [v2 cachePolicy];
      id v15 = 0;
      unint64_t v9 = [v6 providerDomainWithID:v7 cachePolicy:v8 error:&v15];
      id v10 = v15;

      if (!v9)
      {
        int v11 = LogObj(4);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          uint64_t v12 = [v2 domainID];
          *(_DWORD *)long long buf = v14;
          float v17 = v12;
          __int16 v18 = 2114;
          id v19 = v10;
          _os_log_impl(&dword_1D343E000, v11, OS_LOG_TYPE_ERROR, "Failed to find domain for %{public}@ with error: %{public}@", buf, 0x16u);
        }
      }
      std::mutex::lock((std::mutex *)this);
      [v2 setAsyncFetchedDomain:v9];
      [v2 setAsyncError:v10];
      [*((id *)this + 9) removeObject:v2];
      [v2 setAsyncResultAvailable:1];
      dispatch_semaphore_signal(*((dispatch_semaphore_t *)this + 11));
      if (v9) {
        *((unsigned char *)this + 80) = 1;
      }
      uint64_t v13 = objc_msgSend(*((id *)this + 9), "firstObject", v14);

      std::mutex::unlock((std::mutex *)this);
      uint64_t v2 = (void *)v13;
    }
    while (v13);
  }
}

void sub_1D34E6980(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t FIProviderDomainFetcher::Queue(id *this, FIProviderDomain *a2)
{
  long long v3 = a2;
  uint64_t v4 = [this[9] count];
  [this[9] addObject:v3];
  if (!v4)
  {
    int8x8_t v5 = this[8];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3321888768;
    block[2] = ___ZN23FIProviderDomainFetcher5QueueEP16FIProviderDomain_block_invoke;
    block[3] = &__block_descriptor_40_ea8_32c63_ZTSKZN23FIProviderDomainFetcher5QueueEP16FIProviderDomainE3__0_e5_v8__0l;
    void block[4] = this;
    dispatch_async(v5, block);
  }

  return 0;
}

void sub_1D34E6AA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN23FIProviderDomainFetcher5QueueEP16FIProviderDomain_block_invoke(uint64_t a1)
{
}

uint64_t __copy_helper_block_ea8_32c63_ZTSKZN23FIProviderDomainFetcher5QueueEP16FIProviderDomainE3__0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32) = *(void *)(a2 + 32);
  return result;
}

id FIProviderDomainFetcher::FindQueuedDomain(FIProviderDomainFetcher *this, NSString *a2)
{
  long long v3 = a2;
  uint64_t v4 = (void *)*((void *)this + 9);
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3321888768;
  void v9[2] = ___ZN23FIProviderDomainFetcher16FindQueuedDomainEP8NSString_block_invoke;
  void v9[3] = &__block_descriptor_40_ea8_32c66_ZTSKZN23FIProviderDomainFetcher16FindQueuedDomainEP8NSStringE3__0_e33_B32__0__FIProviderDomain_8Q16_B24l;
  int8x8_t v5 = v3;
  id v10 = v5;
  uint64_t v6 = [v4 indexOfObjectPassingTest:v9];
  if (v6 == 0x7FFFFFFFFFFFFFFFLL)
  {
    uint8x8_t v7 = 0;
  }
  else
  {
    uint8x8_t v7 = [*((id *)this + 9) objectAtIndexedSubscript:v6];
  }

  return v7;
}

void sub_1D34E6BA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN23FIProviderDomainFetcher16FindQueuedDomainEP8NSString_block_invoke(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v6 = [a2 domainID];
  uint64_t v7 = [v6 isEqual:*(void *)(a1 + 32)];

  if (v7) {
    *a4 = 1;
  }
  return v7;
}

void sub_1D34E6C20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c66_ZTSKZN23FIProviderDomainFetcher16FindQueuedDomainEP8NSStringE3__0(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a2 + 32);
  *(void *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c66_ZTSKZN23FIProviderDomainFetcher16FindQueuedDomainEP8NSStringE3__0(uint64_t a1)
{
}

FIProviderDomain *FIProviderDomainFetcher::FetchDomainForID(uint64_t a1, void *a2, uint64_t a3, void *a4, void **a5)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  id v9 = a2;
  id v10 = a4;
  if ((UseFileProviderFramework() & 1) == 0)
  {
    unint64_t v16 = 0;
    goto LABEL_16;
  }
  std::mutex::lock((std::mutex *)a1);
  if (*(unsigned char *)(a1 + 80))
  {
    std::mutex::unlock((std::mutex *)a1);
LABEL_4:
    int v11 = [(id)FPProviderDomainClass() providerDomainWithID:v9 cachePolicy:a3 error:a5];
    if (a5 && *a5)
    {
      uint64_t v12 = LogObj(4);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        uint64_t v13 = (TString *)v9;
        v34.fString.int fRef = &stru_1F2ABD380;
        CFRetain(&stru_1F2ABD380);
        TString::SetStringRefAsImmutable(&v34, v13);

        long long v14 = SanitizedStr(&v34);
        id v15 = *a5;
        *(_DWORD *)long long buf = 138412546;
        id v36 = v14;
        __int16 v37 = 2114;
        char v38 = v15;
        _os_log_impl(&dword_1D343E000, v12, OS_LOG_TYPE_ERROR, "Error fetching domainID '%@': %{public}@", buf, 0x16u);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v34.fString.fRef);
      }
    }
    if (v11) {
      unint64_t v16 = [[FIProviderDomain alloc] initWithDomain:v11];
    }
    else {
      unint64_t v16 = 0;
    }

    goto LABEL_16;
  }
  FIProviderDomainFetcher::FindQueuedDomain((FIProviderDomainFetcher *)a1, (NSString *)v9);
  unint64_t v16 = (FIProviderDomain *)objc_claimAutoreleasedReturnValue();
  if (v16)
  {
    std::mutex::unlock((std::mutex *)a1);
    goto LABEL_16;
  }
  __int16 v18 = [FIProviderDomain alloc];
  id v19 = [v10 URLByStandardizingPath];
  uint64_t v20 = [(FIProviderDomain *)v18 initWithDomainID:v9 cachePolicy:a3 rootURL:v19 domain:0];

  id v21 = (id)FIProviderDomainFetcher::Queue((id *)a1, v20);
  std::mutex::unlock((std::mutex *)a1);
  if (!v20) {
    goto LABEL_4;
  }
  unsigned int v22 = LogObj(4);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_1D343E000, v22, OS_LOG_TYPE_DEFAULT, "Waiting for first domain result", buf, 2u);
  }

  BOOL v23 = *(NSObject **)(a1 + 88);
  dispatch_time_t v24 = dispatch_time(0, 1000000000);
  if (dispatch_semaphore_wait(v23, v24))
  {
    uint64_t v25 = LogObj(4);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      id v26 = (TString *)v9;
      v34.fString.int fRef = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      TString::SetStringRefAsImmutable(&v34, v26);

      uint64_t v27 = SanitizedStr(&v34);
      *(_DWORD *)long long buf = 138543362;
      id v36 = v27;
      _os_log_impl(&dword_1D343E000, v25, OS_LOG_TYPE_ERROR, "Domain fetch for providerDomainID timed out: %{public}@", buf, 0xCu);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v34.fString.fRef);
    }
  }
  else
  {
    uint64_t v25 = LogObj(4);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      id v28 = (TString *)v9;
      v34.fString.int fRef = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      TString::SetStringRefAsImmutable(&v34, v28);

      __int16 v29 = SanitizedStr(&v34);
      *(_DWORD *)long long buf = 138543362;
      id v36 = v29;
      _os_log_impl(&dword_1D343E000, v25, OS_LOG_TYPE_DEFAULT, "Domain fetch for providerDomainID finished before timeout: %{public}@", buf, 0xCu);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v34.fString.fRef);
    }
  }

  if (![(FIProviderDomain *)v20 asyncResultAvailable])
  {
LABEL_35:
    unint64_t v16 = v20;
    goto LABEL_16;
  }
  id v30 = [(FIProviderDomain *)v20 asyncFetchedDomain];
  if (!v30)
  {
    __int16 v32 = LogObj(4);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      uint64_t v33 = [(FIProviderDomain *)v20 asyncError];
      *(_DWORD *)long long buf = 138543618;
      id v36 = v9;
      __int16 v37 = 2114;
      char v38 = v33;
      _os_log_impl(&dword_1D343E000, v32, OS_LOG_TYPE_ERROR, "Waited and received no domain for %{public}@ error: %{public}@", buf, 0x16u);
    }
    goto LABEL_35;
  }
  uint64_t v31 = LogObj(4);
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138543362;
    id v36 = v30;
    _os_log_impl(&dword_1D343E000, v31, OS_LOG_TYPE_DEFAULT, "Waited and received result for domain: %{public}@", buf, 0xCu);
  }

  unint64_t v16 = [[FIProviderDomain alloc] initWithDomain:v30];
LABEL_16:

  return v16;
}

void sub_1D34E7194(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

FIProviderDomain *FIProviderDomainFetcher::FetchDomainForURL(std::mutex *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  id v9 = a2;
  std::mutex::lock(a1);
  int v10 = a1[1].__m_.__opaque[8];
  std::mutex::unlock(a1);
  if (v10)
  {
    int v11 = [(id)FPProviderDomainClass() providerDomainForURL:v9 error:a5];
    if (v11)
    {
      uint64_t v12 = [[FIProviderDomain alloc] initWithDomain:v11];
LABEL_9:
      long long v14 = v12;
      goto LABEL_11;
    }
  }
  else
  {
    int v11 = objc_msgSend(v9, "fp_fpfsProviderDomainID:", a3);
    if (v11)
    {
      if (a3) {
        uint64_t v13 = 0;
      }
      else {
        uint64_t v13 = v9;
      }
      FIProviderDomainFetcher::FetchDomainForID((uint64_t)a1, v11, a4, v13, 0);
      uint64_t v12 = (FIProviderDomain *)objc_claimAutoreleasedReturnValue();
      goto LABEL_9;
    }
  }
  long long v14 = 0;
LABEL_11:

  return v14;
}

void sub_1D34E73EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t FIProviderDomainFetcher::Singleton(FIProviderDomainFetcher *this)
{
  {
    operator new();
  }
  return FIProviderDomainFetcher::Singleton(void)::fetcher;
}

void sub_1D34E748C(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v1, 0x1080C405B080FE4);
  _Unwind_Resume(a1);
}

void sub_1D34E754C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id objc_cast<FIProviderDomain,objc_object * {__strong}>(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v2 = a1;
  }
  else {
    id v2 = 0;
  }
  return v2;
}

void sub_1D34E768C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34E7750(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1D34E7820(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1D34E78C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1D34E7968(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1D34E7AE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34E7B70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34E7D18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34E7DE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34E7E5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34E7ED8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void FSInfoVirtualTypeToString(TString *a1@<X0>, TString *a2@<X8>)
{
  if a1 < 0x24 && ((0xFFFFF18FFuLL >> (char)a1))
  {
    uint64_t v4 = off_1E69900D8[(char)a1];
    TString::TString(a2, v4);
  }
  else
  {
    long long v3 = TString::KEmptyString(a1);
    a2->fString.int fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(a2, (TString *)*v3);
  }
}

void sub_1D34E7FB4(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

uint64_t StringToFSInfoVirtualType(const TString *a1)
{
  CFTypeRef cf1 = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)&cf1, 0);
  TString::SetFromUTF8((TString *)&cf1, (const UInt8 *)"kNonVirtual", 11);
  if (CFEqual(cf1, a1->fString.fRef))
  {
    unsigned __int8 v2 = 0;
  }
  else
  {
    TString::SetStringRefAsImmutable((TString *)&cf1, 0);
    TString::SetFromUTF8((TString *)&cf1, (const UInt8 *)"kComputer", 9);
    if (CFEqual(cf1, a1->fString.fRef))
    {
      unsigned __int8 v2 = 1;
    }
    else
    {
      TString::SetStringRefAsImmutable((TString *)&cf1, 0);
      TString::SetFromUTF8((TString *)&cf1, (const UInt8 *)"kVirtualFolder", 14);
      if (CFEqual(cf1, a1->fString.fRef))
      {
        unsigned __int8 v2 = 2;
      }
      else
      {
        TString::SetStringRefAsImmutable((TString *)&cf1, 0);
        TString::SetFromUTF8((TString *)&cf1, (const UInt8 *)"kVirtualAlias", 13);
        if (CFEqual(cf1, a1->fString.fRef))
        {
          unsigned __int8 v2 = 3;
        }
        else
        {
          TString::SetStringRefAsImmutable((TString *)&cf1, 0);
          TString::SetFromUTF8((TString *)&cf1, (const UInt8 *)"kVirtualDocument", 16);
          if (CFEqual(cf1, a1->fString.fRef))
          {
            unsigned __int8 v2 = 4;
          }
          else
          {
            TString::SetStringRefAsImmutable((TString *)&cf1, 0);
            TString::SetFromUTF8((TString *)&cf1, (const UInt8 *)"kQueryAlias", 11);
            if (CFEqual(cf1, a1->fString.fRef))
            {
              unsigned __int8 v2 = 5;
            }
            else
            {
              TString::operator=((TString *)&cf1, "kQueryHitsContainer");
              if (CFEqual(cf1, a1->fString.fRef))
              {
                unsigned __int8 v2 = 6;
              }
              else
              {
                TString::operator=((TString *)&cf1, "kQueryHit");
                if (CFEqual(cf1, a1->fString.fRef))
                {
                  unsigned __int8 v2 = 7;
                }
                else
                {
                  TString::operator=((TString *)&cf1, "kDesktop");
                  if (CFEqual(cf1, a1->fString.fRef))
                  {
                    unsigned __int8 v2 = 11;
                  }
                  else
                  {
                    TString::operator=((TString *)&cf1, "kTrash");
                    if (CFEqual(cf1, a1->fString.fRef))
                    {
                      unsigned __int8 v2 = 12;
                    }
                    else
                    {
                      TString::operator=((TString *)&cf1, "kUnresolvedAlias");
                      if (CFEqual(cf1, a1->fString.fRef))
                      {
                        unsigned __int8 v2 = 16;
                      }
                      else
                      {
                        TString::operator=((TString *)&cf1, "kDevices");
                        if (CFEqual(cf1, a1->fString.fRef))
                        {
                          unsigned __int8 v2 = 17;
                        }
                        else
                        {
                          TString::operator=((TString *)&cf1, "kPlaces");
                          if (CFEqual(cf1, a1->fString.fRef))
                          {
                            unsigned __int8 v2 = 18;
                          }
                          else
                          {
                            TString::operator=((TString *)&cf1, "kSavedSearches");
                            if (CFEqual(cf1, a1->fString.fRef))
                            {
                              unsigned __int8 v2 = 19;
                            }
                            else
                            {
                              TString::operator=((TString *)&cf1, "kPublishedFolders");
                              if (CFEqual(cf1, a1->fString.fRef))
                              {
                                unsigned __int8 v2 = 20;
                              }
                              else
                              {
                                TString::operator=((TString *)&cf1, "kTags");
                                if (CFEqual(cf1, a1->fString.fRef))
                                {
                                  unsigned __int8 v2 = 21;
                                }
                                else
                                {
                                  TString::operator=((TString *)&cf1, "kAllTags");
                                  if (CFEqual(cf1, a1->fString.fRef))
                                  {
                                    unsigned __int8 v2 = 22;
                                  }
                                  else
                                  {
                                    TString::operator=((TString *)&cf1, "kAllCloudLibs");
                                    if (CFEqual(cf1, a1->fString.fRef))
                                    {
                                      unsigned __int8 v2 = 23;
                                    }
                                    else
                                    {
                                      TString::operator=((TString *)&cf1, "kAllDataSeparatedCloudLibs");
                                      if (CFEqual(cf1, a1->fString.fRef))
                                      {
                                        unsigned __int8 v2 = 24;
                                      }
                                      else
                                      {
                                        TString::operator=((TString *)&cf1, "kCloudLib");
                                        if (CFEqual(cf1, a1->fString.fRef))
                                        {
                                          unsigned __int8 v2 = 25;
                                        }
                                        else
                                        {
                                          TString::operator=((TString *)&cf1, "kAllFPProviders");
                                          if (CFEqual(cf1, a1->fString.fRef))
                                          {
                                            unsigned __int8 v2 = 26;
                                          }
                                          else
                                          {
                                            TString::operator=((TString *)&cf1, "kFPProvider");
                                            if (CFEqual(cf1, a1->fString.fRef))
                                            {
                                              unsigned __int8 v2 = 27;
                                            }
                                            else
                                            {
                                              TString::operator=((TString *)&cf1, "kFPv2Item");
                                              if (CFEqual(cf1, a1->fString.fRef))
                                              {
                                                unsigned __int8 v2 = 28;
                                              }
                                              else
                                              {
                                                TString::operator=((TString *)&cf1, "kITunesDevicesContainer");
                                                if (CFEqual(cf1, a1->fString.fRef))
                                                {
                                                  unsigned __int8 v2 = 29;
                                                }
                                                else
                                                {
                                                  TString::operator=((TString *)&cf1, "kITunesDevice");
                                                  if (CFEqual(cf1, a1->fString.fRef))
                                                  {
                                                    unsigned __int8 v2 = 30;
                                                  }
                                                  else
                                                  {
                                                    TString::operator=((TString *)&cf1, "kNetworkNearby");
                                                    if (CFEqual(cf1, a1->fString.fRef))
                                                    {
                                                      unsigned __int8 v2 = 31;
                                                    }
                                                    else
                                                    {
                                                      TString::operator=((TString *)&cf1, "kNetworkSidebar");
                                                      if (CFEqual(cf1, a1->fString.fRef))
                                                      {
                                                        unsigned __int8 v2 = 32;
                                                      }
                                                      else
                                                      {
                                                        TString::operator=((TString *)&cf1, "kAirDrop");
                                                        if (CFEqual(cf1, a1->fString.fRef))
                                                        {
                                                          unsigned __int8 v2 = 33;
                                                        }
                                                        else
                                                        {
                                                          TString::operator=((TString *)&cf1, "kRecentDocuments");
                                                          if (CFEqual(cf1, a1->fString.fRef))
                                                          {
                                                            unsigned __int8 v2 = 34;
                                                          }
                                                          else
                                                          {
                                                            TString::operator=((TString *)&cf1, "kICloudContainer");
                                                            if (CFEqual(cf1, a1->fString.fRef)) {
                                                              unsigned __int8 v2 = 35;
                                                            }
                                                            else {
                                                              unsigned __int8 v2 = -1;
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
  return v2;
}

void sub_1D34E851C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TReplicaRegistry::Remove(TReplicaRegistry *this, FINode *a2)
{
  long long v3 = a2;
  uint64_t v4 = [(FINode *)v3 original];
  unint64_t v5 = [v4 nodeRef];

  unint64_t v17 = v5;
  uint64_t v6 = (void *)*((void *)this + 1);
  if (v6)
  {
    uint64_t v7 = (void *)((char *)this + 8);
    do
    {
      unint64_t v8 = v6[4];
      BOOL v9 = v8 >= v5;
      if (v8 >= v5) {
        int v10 = v6;
      }
      else {
        int v10 = v6 + 1;
      }
      if (v9) {
        uint64_t v7 = v6;
      }
      uint64_t v6 = (void *)*v10;
    }
    while (*v10);
    if (v7 != (void *)((char *)this + 8) && v5 >= v7[4])
    {
      int v11 = (OpaqueNodeRef **)v7[5];
      if (v11 != (OpaqueNodeRef **)v7[6])
      {
        uint64_t v12 = -(uint64_t)v11;
        while (1)
        {
          uint64_t v13 = *v11;
          if (v13 == [(FINode *)v3 nodeRef]) {
            break;
          }
          v11 += 2;
          v12 -= 16;
          if (v11 == (OpaqueNodeRef **)v7[6]) {
            goto LABEL_20;
          }
        }
        uint64_t v14 = -v12;
        id v15 = (const void *)(16 - v12);
        size_t v16 = v7[6] - (16 - v12);
        if (v16) {
          memmove((void *)v14, v15, v16);
        }
        int v11 = (OpaqueNodeRef **)(v14 + v16);
        v7[6] = v11;
      }
LABEL_20:
      if ((OpaqueNodeRef **)v7[5] == v11) {
        std::__tree<std::__value_type<OpaqueNodeRef *,std::vector<TReplicaRegistry::ReplicaEntry>>,std::__map_value_compare<OpaqueNodeRef *,std::__value_type<OpaqueNodeRef *,std::vector<TReplicaRegistry::ReplicaEntry>>,std::less<OpaqueNodeRef *>,true>,std::allocator<std::__value_type<OpaqueNodeRef *,std::vector<TReplicaRegistry::ReplicaEntry>>>>::__erase_unique<OpaqueNodeRef *>((uint64_t)this, &v17);
      }
    }
  }
}

void sub_1D34E8650(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id TReplicaRegistry::CopyReplicaFINodes(TReplicaRegistry *this, OpaqueNodeRef *a2)
{
  uint64_t v4 = (void *)*((void *)this + 1);
  unsigned __int8 v2 = (char *)this + 8;
  long long v3 = v4;
  if (!v4) {
    goto LABEL_12;
  }
  unint64_t v5 = v2;
  do
  {
    unint64_t v6 = v3[4];
    BOOL v7 = v6 >= (unint64_t)a2;
    if (v6 >= (unint64_t)a2) {
      unint64_t v8 = v3;
    }
    else {
      unint64_t v8 = v3 + 1;
    }
    if (v7) {
      unint64_t v5 = (char *)v3;
    }
    long long v3 = (void *)*v8;
  }
  while (*v8);
  if (v5 != v2 && *((void *)v5 + 4) <= (unint64_t)a2)
  {
    BOOL v9 = (void *)[objc_alloc(MEMORY[0x1E4F1CA48]) initWithCapacity:(uint64_t)(*((void *)v5 + 6) - *((void *)v5 + 5)) >> 4];
    int v11 = (void *)*((void *)v5 + 5);
    for (uint64_t i = (void *)*((void *)v5 + 6); v11 != i; v11 += 2)
    {
      uint64_t v13 = +[FINode nodeFromNodeRef:*v11];
      [v9 addObject:v13];
    }
  }
  else
  {
LABEL_12:
    BOOL v9 = 0;
  }
  return v9;
}

void sub_1D34E8758(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34E87D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34E882C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  int v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)FIReplicaNode;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void TReplicaRegistry::RemoveReplica(TReplicaRegistry *this, FINode *a2)
{
  long long v3 = this;
  Mutex = (TDSMutex *)TReplicaRegistry::GetMutex(v3);
  TDSMutex::lock(Mutex);
  if (TReplicaRegistry::gReplicaRegistry) {
    TReplicaRegistry::Remove((TReplicaRegistry *)TReplicaRegistry::gReplicaRegistry, (FINode *)v3);
  }
  TDSMutex::unlock(Mutex);
}

void sub_1D34E88C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  TDSMutex::unlock(v10);

  _Unwind_Resume(a1);
}

void sub_1D34E8998(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34E8AB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__tree<std::__value_type<OpaqueNodeRef *,std::vector<TReplicaRegistry::ReplicaEntry>>,std::__map_value_compare<OpaqueNodeRef *,std::__value_type<OpaqueNodeRef *,std::vector<TReplicaRegistry::ReplicaEntry>>,std::less<OpaqueNodeRef *>,true>,std::allocator<std::__value_type<OpaqueNodeRef *,std::vector<TReplicaRegistry::ReplicaEntry>>>>::__erase_unique<OpaqueNodeRef *>(uint64_t a1, unint64_t *a2)
{
  unsigned __int8 v2 = *(void **)(a1 + 8);
  if (!v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint64_t v4 = (uint64_t *)(a1 + 8);
  do
  {
    unint64_t v5 = v2[4];
    BOOL v6 = v5 >= v3;
    if (v5 >= v3) {
      BOOL v7 = v2;
    }
    else {
      BOOL v7 = v2 + 1;
    }
    if (v6) {
      uint64_t v4 = v2;
    }
    unsigned __int8 v2 = (void *)*v7;
  }
  while (*v7);
  if (v4 == (uint64_t *)(a1 + 8) || v3 < v4[4]) {
    return 0;
  }
  std::__tree<std::__value_type<OpaqueNodeRef *,std::vector<TReplicaRegistry::ReplicaEntry>>,std::__map_value_compare<OpaqueNodeRef *,std::__value_type<OpaqueNodeRef *,std::vector<TReplicaRegistry::ReplicaEntry>>,std::less<OpaqueNodeRef *>,true>,std::allocator<std::__value_type<OpaqueNodeRef *,std::vector<TReplicaRegistry::ReplicaEntry>>>>::erase((uint64_t **)a1, v4);
  return 1;
}

uint64_t *std::__tree<std::__value_type<OpaqueNodeRef *,std::vector<TReplicaRegistry::ReplicaEntry>>,std::__map_value_compare<OpaqueNodeRef *,std::__value_type<OpaqueNodeRef *,std::vector<TReplicaRegistry::ReplicaEntry>>,std::less<OpaqueNodeRef *>,true>,std::allocator<std::__value_type<OpaqueNodeRef *,std::vector<TReplicaRegistry::ReplicaEntry>>>>::erase(uint64_t **a1, uint64_t *a2)
{
  unint64_t v3 = std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__remove_node_pointer(a1, a2);
  uint64_t v4 = (void *)a2[5];
  if (v4)
  {
    a2[6] = (uint64_t)v4;
    operator delete(v4);
  }
  operator delete(a2);
  return v3;
}

uint64_t DSDebugStateString()
{
  return 0;
}

void TClientChangeNotifier::~TClientChangeNotifier(uint64_t (**this)(void))
{
  uint64_t v1 = (TClientChangeNotifier *)this;
  unsigned __int8 v2 = this[4];
  if (v2)
  {
    this = (uint64_t (**)(void))this[2];
    if (this) {
      this = (uint64_t (**)(void))v2();
    }
  }
  RegistrationLock = (TDSMutex *)TDSNotifier::GetRegistrationLock((TDSNotifier *)this);
  TDSMutex::lock(RegistrationLock);
  uint64_t v4 = (TClientChangeNotifier **)TClientChangeNotifier::GetClientNotifierList(void)::gClientNotifierList;
  uint64_t v5 = qword_1EA6AC3B0;
  while (1)
  {
    if (v4 == (TClientChangeNotifier **)v5)
    {
      uint64_t v4 = (TClientChangeNotifier **)v5;
      goto LABEL_12;
    }
    BOOL v6 = (std::__shared_weak_count *)v4[1];
    if (!v6) {
      break;
    }
    BOOL v7 = std::__shared_weak_count::lock(v6);
    if (!v7) {
      break;
    }
    unint64_t v8 = *v4;
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
    if (!v8 || v8 == v1) {
      break;
    }
    v4 += 2;
  }
  if (v4 != (TClientChangeNotifier **)v5)
  {
    for (uint64_t i = v4 + 2; i != (TClientChangeNotifier **)v5; i += 2)
    {
      int v11 = (std::__shared_weak_count *)i[1];
      if (v11)
      {
        uint64_t v12 = std::__shared_weak_count::lock(v11);
        if (v12)
        {
          uint64_t v13 = *i;
          std::__shared_weak_count::__release_shared[abi:ne180100](v12);
          if (v13)
          {
            if (v13 != v1)
            {
              long long v14 = *(_OWORD *)i;
              void *i = 0;
              i[1] = 0;
              id v15 = (std::__shared_weak_count *)v4[1];
              *(_OWORD *)uint64_t v4 = v14;
              if (v15) {
                std::__shared_weak_count::__release_weak(v15);
              }
              v4 += 2;
            }
          }
        }
      }
    }
  }
LABEL_12:
  std::vector<std::weak_ptr<TClientChangeNotifier>>::erase((uint64_t)&TClientChangeNotifier::GetClientNotifierList(void)::gClientNotifierList, (uint64_t)v4, (long long *)qword_1EA6AC3B0);
  StRegistrationLock::~StRegistrationLock((TDSNotifier *)&v16);
  std::__function::__value_func<void ()(FINodeEvent *)>::~__value_func[abi:ne180100]((void *)v1 + 11);
  std::__function::__value_func<void ()(OpaqueEventQueue *)>::~__value_func[abi:ne180100]((void *)v1 + 7);

  BOOL v9 = (std::__shared_weak_count *)*((void *)v1 + 1);
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }
}

TDSNotifier **ReleaseNotifier(TDSNotifier *a1)
{
  unsigned __int8 v2 = a1;
  return TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v2);
}

TDSNotifier **TDSNotifier::HandleDeferredTickleOnMainRunLoop(TDSNotifier *this, __CFRunLoopTimer *a2, void *a3)
{
  BOOL v7 = (TDSNotifier *)a2;
  if (a2)
  {
    TRefCount::Retain<int>((unsigned int *)a2 + 9);
    TDSNotifier::HandleDeferredTickle((TDSNotifier *)a2);
  }
  Main = CFRunLoopGetMain();
  CFRunLoopRemoveTimer(Main, (CFRunLoopTimerRef)this, (CFRunLoopMode)*MEMORY[0x1E4F1D410]);
  return TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&v7);
}

void sub_1D34E8D50(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef((TDSNotifier **)va);
  _Unwind_Resume(a1);
}

void ___ZN21TClientChangeNotifier6WakeUpEv_block_invoke(uint64_t a1)
{
}

uint64_t __copy_helper_block_ea8_32c44_ZTSKZN21TClientChangeNotifier6WakeUpEvE3__0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_ea8_32c44_ZTSKZN21TClientChangeNotifier6WakeUpEvE3__0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

BOOL TDSNotifier::DecrementRegistrationCountForOptions(uint64_t a1, uint64_t a2)
{
  int v3 = TDSNotifier::CountForOptions(a2);
  return atomic_fetch_add((atomic_uint *volatile)(a1 + 40), -v3) == v3;
}

void __destroy_helper_block_ea8_32c50_ZTSKZ37__DSProvidersObserver_startObserving_E3__6(uint64_t a1)
{
}

void sub_1D34E8F28(_Unwind_Exception *a1)
{
  objc_sync_exit(v2);

  _Unwind_Resume(a1);
}

void sub_1D34E95A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  std::mutex::unlock(v28);

  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c74_ZTSKZ61__DSFPItemStatusObserver_startObserving_forParent_withQueue__E3__9(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a2 + 32);
  *(void *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c74_ZTSKZ61__DSFPItemStatusObserver_startObserving_forParent_withQueue__E3__9(uint64_t a1)
{
}

void sub_1D34E97AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __copy_helper_block_ea8_32c75_ZTSKZ61__DSFPItemStatusObserver_startObserving_forParent_withQueue__E4__10(uint64_t a1, uint64_t a2)
{
}

void __destroy_helper_block_ea8_32c75_ZTSKZ61__DSFPItemStatusObserver_startObserving_forParent_withQueue__E4__10(uint64_t a1)
{
}

id objc_cast<FPExtensionCollection,FPItemCollection * {__strong}>(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v2 = a1;
  }
  else {
    id v2 = 0;
  }
  return v2;
}

void sub_1D34E9A58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  std::mutex::unlock(v21);
  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c53_ZTSKZ39__DSFPItemStatusObserver_stopObserving_E4__11(uint64_t a1, uint64_t a2)
{
  id result = *(id *)(a2 + 32);
  *(void *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_ea8_32c53_ZTSKZ39__DSFPItemStatusObserver_stopObserving_E4__11(uint64_t a1)
{
}

void sub_1D34E9FB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  _Unwind_Resume(a1);
}

void sub_1D34EA378(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,id a30)
{
  TNode::StPopulating::~StPopulating((TNode::StPopulating *)&a10);
  _Unwind_Resume(a1);
}

void sub_1D34EA650(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34EA8C0(_Unwind_Exception *a1, char a2, TPropertyValue *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  TPropertyValue::~TPropertyValue((TPropertyValue *)&a11);

  _Unwind_Resume(a1);
}

void sub_1D34EAAF8(_Unwind_Exception *a1, char a2, TPropertyValue *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  TPropertyValue::~TPropertyValue((TPropertyValue *)&a11);

  _Unwind_Resume(a1);
}

void sub_1D34EABFC(_Unwind_Exception *a1, TPropertyValue *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_1D34EAE28(_Unwind_Exception *a1, char a2, TPropertyValue *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  TPropertyValue::~TPropertyValue((TPropertyValue *)&a11);

  _Unwind_Resume(a1);
}

void sub_1D34EB0C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  TPropertyValue::~TPropertyValue((TPropertyValue *)&a9);

  _Unwind_Resume(a1);
}

void sub_1D34EB1B8(_Unwind_Exception *a1, TPropertyValue *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::weak_ptr<TClientChangeNotifier>>,std::reverse_iterator<std::weak_ptr<TClientChangeNotifier>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    int v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      std::__shared_weak_count::__release_weak(v3);
    }
    v1 += 16;
  }
}

uint64_t std::vector<std::weak_ptr<TClientChangeNotifier>>::erase(uint64_t a1, uint64_t a2, long long *a3)
{
  if ((long long *)a2 != a3)
  {
    std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::weak_ptr<TClientChangeNotifier> *,std::weak_ptr<TClientChangeNotifier> *,std::weak_ptr<TClientChangeNotifier> *>((uint64_t)&v10, a3, *(long long **)(a1 + 8), a2);
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)(a1 + 8);
    if (v7 != v5)
    {
      do
      {
        unint64_t v8 = *(std::__shared_weak_count **)(v7 - 8);
        if (v8) {
          std::__shared_weak_count::__release_weak(v8);
        }
        v7 -= 16;
      }
      while (v7 != v6);
    }
    *(void *)(a1 + 8) = v6;
  }
  return a2;
}

long long *std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::weak_ptr<TClientChangeNotifier> *,std::weak_ptr<TClientChangeNotifier> *,std::weak_ptr<TClientChangeNotifier> *>(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      long long v7 = *v5;
      *(void *)uint64_t v5 = 0;
      *((void *)v5 + 1) = 0;
      unint64_t v8 = *(std::__shared_weak_count **)(a4 + 8);
      *(_OWORD *)a4 = v7;
      if (v8) {
        std::__shared_weak_count::__release_weak(v8);
      }
      ++v5;
      a4 += 16;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

uint64_t __copy_helper_block_ea8_32c57_ZTSKZZN21TClientChangeNotifier6WakeUpEvENK3__1clEvEUlvE_(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_ea8_32c57_ZTSKZZN21TClientChangeNotifier6WakeUpEvENK3__1clEvEUlvE_(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void std::__shared_ptr_emplace<std::shared_ptr<TClientChangeNotifier> MakeShared<TClientChangeNotifier,NodeClientContext &,OpaqueEventQueue *&,void (*&)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,void({block_pointer} {__strong}&)(FINodeEvent *),__CFString const*&>(NodeClientContext &,OpaqueEventQueue *&,void (*&)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,void({block_pointer} {__strong}&)(FINodeEvent *),__CFString const*&)::MakeInstanceEnabler,std::allocator<std::allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2AB9B20;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::shared_ptr<TClientChangeNotifier> MakeShared<TClientChangeNotifier,NodeClientContext &,OpaqueEventQueue *&,void (*&)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,void({block_pointer} {__strong}&)(FINodeEvent *),__CFString const*&>(NodeClientContext &,OpaqueEventQueue *&,void (*&)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,void({block_pointer} {__strong}&)(FINodeEvent *),__CFString const*&)::MakeInstanceEnabler,std::allocator<std::allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2AB9B20;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

void std::__shared_ptr_emplace<std::shared_ptr<TClientChangeNotifier> MakeShared<TClientChangeNotifier,NodeClientContext &,OpaqueEventQueue *&,void (*&)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,void({block_pointer} {__strong}&)(FINodeEvent *),__CFString const*&>(NodeClientContext &,OpaqueEventQueue *&,void (*&)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}* {__strong}&,void({block_pointer} {__strong}&)(FINodeEvent *),__CFString const*&)::MakeInstanceEnabler,std::allocator<std::allocator>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__function::__func<void({block_pointer} {__strong})(FINodeEvent *),std::allocator<void({block_pointer} {__strong})(FINodeEvent *)>,void ()(FINodeEvent *)>::~__func(uint64_t a1)
{
  return a1;
}

void std::__function::__func<void({block_pointer} {__strong})(FINodeEvent *),std::allocator<void({block_pointer} {__strong})(FINodeEvent *)>,void ()(FINodeEvent *)>::~__func(uint64_t a1)
{
  JUMPOUT(0x1D9436740);
}

uint64_t std::__function::__func<void({block_pointer} {__strong})(FINodeEvent *),std::allocator<void({block_pointer} {__strong})(FINodeEvent *)>,void ()(FINodeEvent *)>::__clone()
{
  return 0;
}

uint64_t std::__function::__func<void({block_pointer} {__strong})(FINodeEvent *),std::allocator<void({block_pointer} {__strong})(FINodeEvent *)>,void ()(FINodeEvent *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2ABAA80;
  uint64_t result = MEMORY[0x1D9436FC0](*(void *)(a1 + 8));
  a2[1] = result;
  return result;
}

void std::__function::__func<void({block_pointer} {__strong})(FINodeEvent *),std::allocator<void({block_pointer} {__strong})(FINodeEvent *)>,void ()(FINodeEvent *)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = 0;
}

uint64_t std::__function::__func<void({block_pointer} {__strong})(FINodeEvent *),std::allocator<void({block_pointer} {__strong})(FINodeEvent *)>,void ()(FINodeEvent *)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

void *std::__function::__func<void({block_pointer} {__strong})(FINodeEvent *),std::allocator<void({block_pointer} {__strong})(FINodeEvent *)>,void ()(FINodeEvent *)>::target_type()
{
}

void *std::__function::__value_func<void ()(FINodeEvent *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_0,std::allocator<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_0>,void ()(OpaqueEventQueue *)>::~__func()
{
}

void *std::__function::__func<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_0,std::allocator<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_0>,void ()(OpaqueEventQueue *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1F2AB9798;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_0,std::allocator<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_0>,void ()(OpaqueEventQueue *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_0,std::allocator<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_0>,void ()(OpaqueEventQueue *)>::target_type()
{
}

void std::__function::__func<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_1,std::allocator<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_1>,void ()(OpaqueEventQueue *)>::~__func()
{
}

void *std::__function::__func<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_1,std::allocator<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_1>,void ()(OpaqueEventQueue *)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1F2AB97F0;
  return result;
}

uint64_t std::__function::__func<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_1,std::allocator<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_1>,void ()(OpaqueEventQueue *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_1,std::allocator<TClientChangeNotifier::TClientChangeNotifier(std::vector<std::function<void ()(void)>> &,NodeClientContext,OpaqueEventQueue *,void (*)(OpaqueEventQueue *),NSObject  {objcproto17OS_dispatch_queue}*,void({block_pointer})(FINodeEvent *),__CFString const*)::$_1>,void ()(OpaqueEventQueue *)>::target_type()
{
}

const void **TAutoRef<__CFRunLoopTimer *,CFRetainReleasePolicy>::~TAutoRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void std::__throw_bad_weak_ptr[abi:ne180100]()
{
  exception = __cxa_allocate_exception(8uLL);
  void *exception = MEMORY[0x1E4FBA438] + 16;
  __cxa_throw(exception, MEMORY[0x1E4FBA2E0], MEMORY[0x1E4FBA208]);
}

void std::__function::__func<TReferenceCounted::TReferenceCounted<TDSNotifier *>(RefCountedType,TDSNotifier *)::{lambda(void *)#1},std::allocator<TReferenceCounted::TReferenceCounted<TDSNotifier *>(RefCountedType,TDSNotifier *)::{lambda(void *)#1}>,void ()(void *)>::~__func()
{
}

void *std::__function::__func<TReferenceCounted::TReferenceCounted<TDSNotifier *>(RefCountedType,TDSNotifier *)::{lambda(void *)#1},std::allocator<TReferenceCounted::TReferenceCounted<TDSNotifier *>(RefCountedType,TDSNotifier *)::{lambda(void *)#1}>,void ()(void *)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1F2ABABE0;
  return result;
}

void std::__function::__func<TReferenceCounted::TReferenceCounted<TDSNotifier *>(RefCountedType,TDSNotifier *)::{lambda(void *)#1},std::allocator<TReferenceCounted::TReferenceCounted<TDSNotifier *>(RefCountedType,TDSNotifier *)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F2ABABE0;
}

uint64_t std::__function::__func<TReferenceCounted::TReferenceCounted<TDSNotifier *>(RefCountedType,TDSNotifier *)::{lambda(void *)#1},std::allocator<TReferenceCounted::TReferenceCounted<TDSNotifier *>(RefCountedType,TDSNotifier *)::{lambda(void *)#1}>,void ()(void *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<TReferenceCounted::TReferenceCounted<TDSNotifier *>(RefCountedType,TDSNotifier *)::{lambda(void *)#1},std::allocator<TReferenceCounted::TReferenceCounted<TDSNotifier *>(RefCountedType,TDSNotifier *)::{lambda(void *)#1}>,void ()(void *)>::target_type()
{
}

void sub_1D34EB980(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34EBC40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1D34EBDA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34EBF88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29)
{
  objc_sync_exit(v29);
  _Unwind_Resume(a1);
}

void sub_1D34EC2F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id a13, void *a14, uint64_t a15, id a16)
{
  objc_sync_exit(v19);

  TNodeEventPtr::~TNodeEventPtr(&a13);
  TNodeEventPtr::~TNodeEventPtr(v17);

  TNodeEventPtr::~TNodeEventPtr(&a16);
  _Unwind_Resume(a1);
}

void sub_1D34EC4E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, TDSNotifier *a11, uint64_t a12, std::__shared_weak_count *a13)
{
  if (a13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a13);
  }
  TRef<TDSNotifier *,TRetainReleasePolicy<TDSNotifier *>>::~TRef(&a11);
  _Unwind_Resume(a1);
}

void sub_1D34EC658(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::__hash_table<FINode * {__strong},std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,std::allocator<FINode * {__strong}>>::__emplace_unique_key_args<FINode * {__strong},FINode * {__strong}>(uint64_t a1, id *a2, uint64_t *a3)
{
  unint64_t v7 = [*a2 hash];
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v9) {
        unint64_t v3 = v7 % v9;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v7;
    }
    uint64_t v12 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = *(void **)i)
      {
        unint64_t v14 = *((void *)i + 1);
        if (v14 == v8)
        {
          if (std::equal_to<FINode * {__strong}>::operator()(a1 + 32, *((void **)i + 2), *a2)) {
            return i;
          }
        }
        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9) {
              v14 %= v9;
            }
          }
          else
          {
            v14 &= v9 - 1;
          }
          if (v14 != v3) {
            break;
          }
        }
      }
    }
  }
  id v15 = (void *)(a1 + 16);
  uint64_t i = operator new(0x18uLL);
  *(void *)uint64_t i = 0;
  *((void *)i + 1) = v8;
  uint64_t v16 = *a3;
  *a3 = 0;
  *((void *)i + 2) = v16;
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v9 || (float)(v18 * (float)v9) < v17)
  {
    BOOL v19 = 1;
    if (v9 >= 3) {
      BOOL v19 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v9);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v22);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v23 = *(void *)a1;
  dispatch_time_t v24 = *(void **)(*(void *)a1 + 8 * v3);
  if (v24)
  {
    *(void *)uint64_t i = *v24;
LABEL_38:
    void *v24 = i;
    goto LABEL_39;
  }
  *(void *)uint64_t i = *v15;
  *id v15 = i;
  *(void *)(v23 + 8 * v3) = v15;
  if (*(void *)i)
  {
    unint64_t v25 = *(void *)(*(void *)i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v25 >= v9) {
        v25 %= v9;
      }
    }
    else
    {
      v25 &= v9 - 1;
    }
    dispatch_time_t v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1D34EC8E4(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<TNodePtr,void *>>>::operator()[abi:ne180100](v2, v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<FINode * {__strong},std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,std::allocator<FINode * {__strong}>>::clear(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    std::__hash_table<TNodePtr,std::hash<TNodePtr>,std::equal_to<TNodePtr>,std::allocator<TNodePtr>>::__deallocate_node(a1, *(id **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

uint64_t *std::__hash_table<FINode * {__strong},std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,std::allocator<FINode * {__strong}>>::__erase_unique<FINode * {__strong}>(void *a1, id *a2)
{
  uint64_t result = (uint64_t *)std::__hash_table<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::__unordered_map_hasher<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,true>,std::__unordered_map_equal<FINode * {__strong},std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>,std::equal_to<FINode * {__strong}>,std::hash<FINode * {__strong}>,true>,std::allocator<std::__hash_value_type<FINode * {__strong},std::unordered_map<NodeNotificationOptions,unsigned long>>>>::find<FINode * {__strong}>(a1, a2);
  if (result)
  {
    std::__hash_table<FINode * {__strong},std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,std::allocator<FINode * {__strong}>>::erase(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

uint64_t std::__hash_table<FINode * {__strong},std::hash<FINode * {__strong}>,std::equal_to<FINode * {__strong}>,std::allocator<FINode * {__strong}>>::erase(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::remove(a1, a2, (uint64_t)&__p);
  unint64_t v3 = (id *)__p;
  std::string __p = 0;
  if (v3)
  {
    if (v6) {

    }
    operator delete(v3);
  }
  return v2;
}

uint64_t TNWNode::TNWNode(uint64_t a1, CFTypeRef cf)
{
  *(void *)a1 = cf;
  if (cf) {
    CFRetain(cf);
  }
  CFSetRef v3 = (const __CFSet *)SFNodeCopyKindString();
  CFSetRef theSet = v3;
  *(void *)(a1 + 8) = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)(a1 + 8), (TString *)v3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theSet);
  *(void *)(a1 + 16) = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  CFSetRef v4 = (const __CFSet *)SFNodeCopySecondaryName();
  CFSetRef theSet = v4;
  *(void *)(a1 + 24) = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)(a1 + 24), (TString *)v4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theSet);
  uint64_t v5 = (NSString *)SFNodeCopyTypeIdentifier();
  *(void *)(a1 + 32) = TypeForUTI(v5);

  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = SFNodeGetPriority();
  *(unsigned char *)(a1 + 56) = SFNodeGetConnectionState();
  *(_WORD *)(a1 + 57) &= 0xFFFCu;
  *(_WORD *)(a1 + 57) = *(_WORD *)(a1 + 57) & 0xFFFB | (4 * (SFNodeIsServer() != 0));
  *(_WORD *)(a1 + 57) = *(_WORD *)(a1 + 57) & 0xFFF7 | (8 * (SFNodeIsSharePoint() != 0));
  *(_WORD *)(a1 + 57) = *(_WORD *)(a1 + 57) & 0xFFEF | (16 * (SFNodeSupportsFileSharing() != 0));
  *(_WORD *)(a1 + 57) = *(_WORD *)(a1 + 57) & 0xFFDF | (32 * (SFNodeSupportsScreenSharing() != 0));
  *(_WORD *)(a1 + 57) = *(_WORD *)(a1 + 57) & 0xFFBF | ((SFNodeIsMounted() != 0) << 6);
  *(_WORD *)(a1 + 57) = *(_WORD *)(a1 + 57) & 0xF87F | ((SFNodeIsContainer() != 0) << 7);
  CFSetRef v6 = (const __CFSet *)SFNodeCopyKinds();
  CFSetRef theSet = v6;
  if (v6)
  {
    *(_WORD *)(a1 + 57) = *(_WORD *)(a1 + 57) & 0xFFFE | (CFSetContainsValue(v6, (const void *)*MEMORY[0x1E4F9F758]) != 0);
    *(_WORD *)(a1 + 57) = *(_WORD *)(a1 + 57) & 0xFEFF | ((CFSetContainsValue(theSet, (const void *)*MEMORY[0x1E4F9F750]) != 0) << 8);
    *(_WORD *)(a1 + 57) = *(_WORD *)(a1 + 57) & 0xFDFF | ((CFSetContainsValue(theSet, (const void *)*MEMORY[0x1E4F9F748]) != 0) << 9);
  }
  TRef<__CFSet const*,TRetainReleasePolicy<__CFSet const*>>::~TRef((const void **)&theSet);
  int IsNeighborhood = SFNodeIsNeighborhood();
  __int16 v8 = *(_WORD *)(a1 + 57);
  if (IsNeighborhood | v8 & 0x100) {
    __int16 v9 = 2;
  }
  else {
    __int16 v9 = HIBYTE(*(_WORD *)(a1 + 57)) & 2;
  }
  *(_WORD *)(a1 + 57) = v8 & 0xFFFD | v9;
  if ((v8 & 4) != 0)
  {
    CFSetRef v10 = (const __CFSet *)SFNodeCopyUserName();
    CFSetRef theSet = v10;
    if (*(const __CFSet **)(a1 + 16) != v10) {
      TString::SetStringRefAsImmutable((TString *)(a1 + 16), (TString *)v10);
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theSet);
  }
  return a1;
}

void sub_1D34ECCC4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v5);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v3);
  TRef<__SFNode *,TRetainReleasePolicy<__SFNode *>>::~TRef((const void **)v2);
  _Unwind_Resume(a1);
}

const void **TRef<__CFSet const*,TRetainReleasePolicy<__CFSet const*>>::~TRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

id CopyDeep(NSDictionary *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    CFSetRef v3 = CopyDeepCommon(v1, 0);
    CFSetRef v4 = (void *)[objc_alloc(MEMORY[0x1E4F1C9E8]) initWithDictionary:v3];
  }
  else
  {
    CFSetRef v4 = 0;
  }

  return v4;
}

void sub_1D34ECE44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id CopyDeepCommon(NSDictionary *a1, int a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  CFSetRef v3 = a1;
  CFSetRef v4 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1CA60]), "initWithCapacity:", -[NSDictionary count](v3, "count"));
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  uint64_t v5 = [(NSDictionary *)v3 allKeys];
  uint64_t v6 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v6)
  {
    uint64_t v7 = *(void *)v14;
    do
    {
      for (uint64_t i = 0; i != v6; ++i)
      {
        if (*(void *)v14 != v7) {
          objc_enumerationMutation(v5);
        }
        uint64_t v9 = *(void *)(*((void *)&v13 + 1) + 8 * i);
        CFSetRef v10 = [(NSDictionary *)v3 objectForKeyedSubscript:v9];
        unint64_t v11 = CopyDeepHelper(v10, a2);

        [v4 setObject:v11 forKeyedSubscript:v9];
      }
      uint64_t v6 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
    }
    while (v6);
  }

  return v4;
}

void sub_1D34ECFE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id MutableCopyDeep(NSDictionary *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    CFSetRef v3 = CopyDeepCommon(v1, 1);
  }
  else
  {
    CFSetRef v3 = 0;
  }

  return v3;
}

void sub_1D34ED094(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void TFSVolumeInfo::RecalculateFreeSpaceAndCapacity(TFSVolumeInfo *this, int a2)
{
  v27[2] = *MEMORY[0x1E4F143B8];
  if (!*((unsigned char *)this + 123) && !*((unsigned char *)this + 128))
  {
    CFSetRef v4 = (TFSInfo *)*((void *)this + 7);
    uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 8);
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v4) {
      CFURLRef CFURLRef = TFSInfo::CreateCFURLRef(v4);
    }
    else {
      CFURLRef CFURLRef = 0;
    }
    CFURLRef url = CFURLRef;
    os_unfair_lock_lock((os_unfair_lock_t)this + 78);
    uint64_t v7 = *((void *)this + 18);
    uint64_t v8 = *((void *)this + 19);
    uint64_t v24 = v8;
    uint64_t valuePtr = v7;
    uint64_t v9 = *((void *)this + 20);
    uint64_t v10 = *((void *)this + 21);
    int v11 = *((unsigned __int8 *)this + 115);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 78);
    if (v11)
    {
      uint64_t v9 = 0;
      uint64_t v10 = -2;
      uint64_t v24 = -2;
      uint64_t valuePtr = -2;
    }
    else if (CFURLRef)
    {
      uint64_t v21 = v8;
      uint64_t v12 = (void *)*MEMORY[0x1E4F1D968];
      CFURLClearResourcePropertyCacheForKey(CFURLRef, (CFStringRef)*MEMORY[0x1E4F1D968]);
      long long v13 = (void *)*MEMORY[0x1E4F1D828];
      CFURLClearResourcePropertyCacheForKey(url, (CFStringRef)*MEMORY[0x1E4F1D828]);
      id v14 = v12;
      v27[0] = v14;
      id v15 = v13;
      v27[1] = v15;
      CFArrayRef v16 = [MEMORY[0x1E4F1C978] arrayWithObjects:v27 count:2];
      CFDictionaryRef v17 = CFURLCopyResourcePropertiesForKeys(url, v16, 0);
      CFDictionaryRef theDict = v17;

      uint64_t v18 = v21;
      if (v17)
      {
        CFIndex Count = CFDictionaryGetCount(v17);
        if (Count >= 1)
        {
          if (a2 && v9 < 0)
          {
            if (TFSVolumeInfo::gFullEnvironment && *((unsigned char *)this + 107) && !*((unsigned char *)this + 114))
            {
              TFSVolumeInfo::UpdateReusableSpaceOnVolumes((TFSVolumeInfo *)Count);
              os_unfair_lock_lock((os_unfair_lock_t)this + 78);
              uint64_t v9 = *((void *)this + 20);
              os_unfair_lock_unlock((os_unfair_lock_t)this + 78);
            }
            else
            {
              uint64_t v9 = 0;
            }
          }
          value = 0;
          if (CFDictionaryGetValueIfPresent(theDict, v14, (const void **)&value)) {
            CFNumberGetValue((CFNumberRef)value, kCFNumberSInt64Type, &valuePtr);
          }
          if (CFDictionaryGetValueIfPresent(theDict, v15, (const void **)&value))
          {
            CFNumberGetValue((CFNumberRef)value, kCFNumberSInt64Type, &v24);
            uint64_t v18 = v24;
          }
          if ((valuePtr | v18) >= 0) {
            uint64_t v10 = valuePtr - v18;
          }
          else {
            uint64_t v10 = -2;
          }
          TFSVolumeInfo::GetReclaimableSpace(this);
        }
      }
      TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef((const void **)&theDict);
    }
    os_unfair_lock_lock((os_unfair_lock_t)this + 78);
    uint64_t v20 = v24;
    *((void *)this + 18) = valuePtr;
    *((void *)this + 19) = v20;
    *((void *)this + 20) = v9;
    *((void *)this + 21) = v10;
    *((unsigned char *)this + 131) = 1;
    os_unfair_lock_unlock((os_unfair_lock_t)this + 78);
    TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&url);
    if (v5) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v5);
    }
  }
}

void sub_1D34ED330(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v6 = va_arg(va1, const void *);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef((const void **)va);
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)va1);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  _Unwind_Resume(a1);
}

id TFSVolumeInfo::GetSynchingGCDQueue(TFSVolumeInfo *this)
{
  return NodeEventRefFromNodeEvent(*((id **)this + 40));
}

TFSVolumeInfo *TFSVolumeInfo::GetPropertyUpdateThread@<X0>(TFSVolumeInfo *this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *((void *)this + 43);
  *a2 = *((void *)this + 42);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

TFSVolumeInfo *TFSVolumeInfo::GetFolderSizingThread@<X0>(TFSVolumeInfo *this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *((void *)this + 45);
  *a2 = *((void *)this + 44);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

void TFSVolumeInfo::UpdateIterationPerfData(TFSVolumeInfo *this, const TString *a2, double a3, int a4, uint64_t a5)
{
  int v7 = (int)a2;
  PerfCountersSpinlock();
  os_unfair_lock_lock((os_unfair_lock_t)&PerfCountersSpinlock(void)::sPerfCountersSpinlock);
  uint64_t v10 = (void *)sPerfCounters;
  if (!sPerfCounters)
  {
    uint64_t v11 = objc_opt_new();
    uint64_t v12 = (void *)sPerfCounters;
    sPerfCounters = v11;

    uint64_t v10 = (void *)sPerfCounters;
  }
  long long v13 = [v10 objectForKeyedSubscript:*(id *)this];
  if (!v13)
  {
    id v14 = [MEMORY[0x1E4F1CA60] dictionary];
    [v14 setObject:&unk_1F2AC3860 forKeyedSubscript:@"iterationCount"];
    [ (id) sPerfCounters setObject:v14 forKeyedSubscript:*(id *)this];
    long long v13 = v14;
  }
  id v15 = NSNumber;
  CFArrayRef v16 = [v13 objectForKeyedSubscript:@"iterationCount"];
  CFDictionaryRef v17 = objc_cast<NSNumber,objc_object * {__strong}>(v16);
  uint64_t v18 = objc_msgSend(v15, "numberWithLong:", objc_msgSend(v17, "longValue") + 1);
  [v13 setObject:v18 forKeyedSubscript:@"iterationCount"];

  BOOL v19 = [NSNumber numberWithDouble:a3];
  [v13 setObject:v19 forKeyedSubscript:@"duration"];

  if (v7) {
    uint64_t v20 = &unk_1F2AC3878;
  }
  else {
    uint64_t v20 = &unk_1F2AC3860;
  }
  [v13 setObject:v20 forKeyedSubscript:@"shouldHaveUsedReaddir"];
  if (a4) {
    uint64_t v21 = &unk_1F2AC3878;
  }
  else {
    uint64_t v21 = &unk_1F2AC3860;
  }
  [v13 setObject:v21 forKeyedSubscript:@"didUseReaddir"];
  size_t v22 = [NSNumber numberWithUnsignedLong:a5];
  [v13 setObject:v22 forKeyedSubscript:@"numberOfItems"];

  os_unfair_lock_unlock((os_unfair_lock_t)&PerfCountersSpinlock(void)::sPerfCountersSpinlock);
}

void sub_1D34ED5DC(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&PerfCountersSpinlock(void)::sPerfCountersSpinlock);
  _Unwind_Resume(a1);
}

void PerfCountersSpinlock(void)
{
  {
    PerfCountersSpinlock(void)::sPerfCountersSpinlock = 0;
  }
}

id objc_cast<NSNumber,objc_object * {__strong}>(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v2 = a1;
  }
  else {
    id v2 = 0;
  }
  return v2;
}

void TFSVolumeInfo::TrashPath(TFSVolumeInfo *this@<X0>, uint64_t a2@<X1>, TString *a3@<X8>)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (os_unfair_lock_s *)((char *)this + 312);
  os_unfair_lock_lock((os_unfair_lock_t)this + 78);
  int v7 = (TString **)((char *)this + 400);
  if (*((unsigned char *)this + 408))
  {
    a3->fString.int fRef = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable(a3, *v7);
    os_unfair_lock_unlock(v6);
  }
  else
  {
    os_unfair_lock_unlock(v6);
    TFSVolumeInfo::GetMountPoint(this, &v42);
    *(void *)long long buf = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable((TString *)buf, (TString *)@"/System/Volumes/Update/");
    BOOL v8 = TString::BeginsWith(&v42, (const TString *)buf);
    uint64_t v9 = (TString *)TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf);
    if (v8
      || (TString::TString((TString *)buf, "/private/var/mobile", 0x13uLL),
          int v11 = CFEqual(v42.fString.fRef, *(CFTypeRef *)buf),
          uint64_t v9 = (TString *)TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)buf),
          v11))
    {
      uint64_t v10 = TString::KEmptyString(v9);
      a3->fString.int fRef = &stru_1F2ABD380;
      CFRetain(&stru_1F2ABD380);
      TString::SetStringRefAsImmutable(a3, (TString *)*v10);
    }
    else
    {
      uint64_t v12 = *((void *)this + 7);
      if (!v12) {
        goto LABEL_13;
      }
      os_unfair_lock_lock((os_unfair_lock_t)(v12 + 100));
      long long v13 = *(const void **)(v12 + 16);
      *(void *)long long buf = v13;
      if (v13) {
        CFRetain(v13);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(v12 + 100));
      id v14 = (NSURL *)*(id *)buf;
      TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)buf);
      id v36 = v14;
      if (v14)
      {
        id v15 = [MEMORY[0x1E4F28CB8] defaultManager];
        id v41 = 0;
        __int16 v37 = [v15 URLForDirectory:102 inDomain:2 appropriateForURL:v36 create:a2 error:&v41];
        id v16 = v41;

        int v17 = 1;
        uint64_t v18 = v16;
      }
      else
      {
LABEL_13:
        id v36 = 0;
        __int16 v37 = 0;
        uint64_t v18 = 0;
        int v17 = 0;
      }
      uint64_t v39 = v18;
      BOOL v19 = [v18 userInfo];
      uint64_t v20 = [v19 objectForKeyedSubscript:*MEMORY[0x1E4F28A50]];
      char v38 = objc_cast<NSError,objc_object * {__strong}>(v20);

      uint64_t v21 = [v38 domain];
      BOOL v22 = v21 == (void *)*MEMORY[0x1E4F28798] && [v38 code] == 30;

      uint64_t v23 = [v39 domain];
      BOOL v24 = v23 == (void *)*MEMORY[0x1E4F281F8] && [v39 code] == 3328;

      int v26 = v17 ^ 1;
      if (!v39) {
        int v26 = 1;
      }
      if (((v26 | (v22 || v24)) & 1) == 0)
      {
        uint64_t v27 = LogObj(5);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          uint64_t v28 = SanitizedURL(v36);
          __int16 v29 = (void *)v28;
          id v30 = "get";
          *(_DWORD *)long long buf = 136446722;
          if (a2) {
            id v30 = "create";
          }
          *(void *)&uint8_t buf[4] = v30;
          __int16 v44 = 2114;
          uint64_t v45 = v28;
          __int16 v46 = 2114;
          TNodePtr v47 = v39;
          _os_log_impl(&dword_1D343E000, v27, OS_LOG_TYPE_ERROR, "Failed to %{public}s trash on volume: %{public}@. error: %{public}@", buf, 0x20u);
        }
      }
      if (v37) {
        int v31 = 1;
      }
      else {
        int v31 = a2;
      }
      if ((v31 | v22) == 1)
      {
        os_unfair_lock_lock(v6);
        id v40 = [v37 path];
        std::optional<TString>::operator=[abi:ne180100]<NSString * {__strong},void>((uint64_t)this + 400, &v40);

        if (!v39)
        {
          __int16 v32 = LogObj(5);
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
          {
            if (a2) {
              uint64_t v33 = "Created";
            }
            else {
              uint64_t v33 = "Found";
            }
            if (!*((unsigned char *)this + 408)) {
              std::__throw_bad_optional_access[abi:ne180100]();
            }
            TString v34 = SanitizedPath((TString *)this + 50);
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = v33;
            __int16 v44 = 2114;
            uint64_t v45 = (uint64_t)v34;
            _os_log_impl(&dword_1D343E000, v32, OS_LOG_TYPE_DEBUG, "%{public}s volume trash: %{public}@", buf, 0x16u);
          }
        }
        if (!*((unsigned char *)this + 408)) {
          std::__throw_bad_optional_access[abi:ne180100]();
        }
        a3->fString.int fRef = &stru_1F2ABD380;
        CFRetain(&stru_1F2ABD380);
        TString::SetStringRefAsImmutable(a3, *v7);
        os_unfair_lock_unlock(v6);
      }
      else
      {
        char v35 = TString::KEmptyString(v25);
        a3->fString.int fRef = &stru_1F2ABD380;
        CFRetain(&stru_1F2ABD380);
        TString::SetStringRefAsImmutable(a3, (TString *)*v35);
      }
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v42.fString.fRef);
  }
}

void sub_1D34EDC38(_Unwind_Exception *a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);

  os_unfair_lock_unlock(v9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void TFSVolumeInfo::GetMountPoint(TFSVolumeInfo *this@<X0>, TString *a2@<X8>)
{
  CFSetRef v4 = (os_unfair_lock_s *)((char *)this + 312);
  os_unfair_lock_lock((os_unfair_lock_t)this + 78);
  a2->fString.int fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a2, *((TString **)this + 11));
  os_unfair_lock_unlock(v4);
}

void sub_1D34EDDFC(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t std::optional<TString>::operator=[abi:ne180100]<NSString * {__strong},void>(uint64_t a1, id *a2)
{
  if (*(unsigned char *)(a1 + 8))
  {
    CFSetRef v3 = (TString *)*a2;
    if (*(TString **)a1 != v3) {
      TString::SetStringRefAsImmutable((TString *)a1, v3);
    }
  }
  else
  {
    std::construct_at[abi:ne180100]<TString,NSString * {__strong},TString*>((TString *)a1, a2);
    *(unsigned char *)(a1 + 8) = 1;
  }
  return a1;
}

void sub_1D34EDE88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

FILE *ReadHiddenList(uint64_t a1, char *__filename)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t result = fopen(__filename, "r");
  if (result)
  {
    CFSetRef v4 = result;
    while (fgets(__s, 765, v4))
    {
      uint64_t v5 = &__s[strspn(__s, " \t")];
      size_t v6 = strcspn(v5, "\n\r\f");
      TString::TString(&v7, v5, v6);
      std::vector<TString>::push_back[abi:ne180100](a1, (TString **)&v7);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v7.fString.fRef);
    }
    return (FILE *)fclose(v4);
  }
  return result;
}

void sub_1D34EDFA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

BOOL TFSVolumeInfo::IsHiddenFile(TFSVolumeInfo *this, const TString *a2)
{
  if (!TFSVolumeInfo::MayHaveHiddenList(this)) {
    return 0;
  }
  CFSetRef v4 = (TDSMutex *)((char *)this + 224);
  TDSMutex::lock((TDSMutex *)((char *)this + 224));
  uint64_t v5 = *((void *)this + 24);
  uint64_t v6 = *((void *)this + 25);
  if (v5 == v6)
  {
    BOOL v9 = 0;
  }
  else
  {
    uint64_t v7 = v5 + 8;
    do
    {
      int v8 = CFEqual(a2->fString.fRef, *(CFTypeRef *)(v7 - 8));
      BOOL v9 = v8 != 0;
      if (v8) {
        BOOL v10 = 1;
      }
      else {
        BOOL v10 = v7 == v6;
      }
      v7 += 8;
    }
    while (!v10);
  }
  TDSMutex::unlock(v4);
  return v9;
}

void sub_1D34EE058(_Unwind_Exception *a1)
{
  TDSMutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSVolumeInfo::GetVolumeFormat(TFSVolumeInfo *this)
{
  return *((__int16 *)this + 36);
}

uint64_t TFSVolumeInfo::VolumeSupportsUNIXPermissions(TFSVolumeInfo *this)
{
  return (*((_DWORD *)this + 18) < 0x15u) & (0x18003Cu >> *((_DWORD *)this + 18));
}

BOOL TFSVolumeInfo::VolumeSupportsAFPPermissions(TFSVolumeInfo *this)
{
  return *((_DWORD *)this + 18) == 13;
}

uint64_t TFSVolumeInfo::VolumeSupportsIgnoreOwnership(TFSVolumeInfo *this)
{
  return (*((_DWORD *)this + 18) < 0x15u) & (0x10000Cu >> *((_DWORD *)this + 18));
}

BOOL TFSVolumeInfo::VolumeShouldShowCapacity(TFSVolumeInfo *this)
{
  return (*((_DWORD *)this + 18) & 0xFFFFFFF7) != 6;
}

uint64_t TFSVolumeInfo::VolumeAllowPermissionChanges(TFSVolumeInfo *this)
{
  return *((unsigned __int8 *)this + 137);
}

const void **TFSVolumeInfo::VolumeFormatString@<X0>(TFSVolumeInfo *this@<X0>, const void **a2@<X8>)
{
  *a2 = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TFSVolumeInfo::GetMountPoint(this, (TString *)&theString);
  if (CFStringGetLength(theString) >= 1)
  {
    if (theString && (v4 = CFRetain(theString), (uint64_t v5 = static_cf_cast<__CFString const*,void const*>(v4)) != 0))
    {
      CFTypeRef v6 = CFAutorelease(v5);
      CFStringRef v7 = (const __CFString *)static_cf_cast<__CFString const*,void const*>(v6);
    }
    else
    {
      CFStringRef v7 = 0;
    }
    CFURLRef v8 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v7, kCFURLPOSIXPathStyle, 1u);
    CFTypeRef v11 = v8;
    if (v8)
    {
      TCFURLInfo::StringProperty(v8, (const __CFString *)*MEMORY[0x1E4F1D890], (TString *)&cf);
      if (&cf != a2)
      {
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &cf);
        CFRetain(&stru_1F2ABD380);
        if (cf) {
          CFRelease(cf);
        }
        CFTypeRef cf = &stru_1F2ABD380;
      }
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf);
    }
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v11);
  }
  if (!CFStringGetLength((CFStringRef)*a2))
  {
    TString::TString((TString *)&v11, "?", 1uLL);
    if (&v11 != a2)
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>(a2, &v11);
      CFRetain(&stru_1F2ABD380);
      if (v11) {
        CFRelease(v11);
      }
      CFTypeRef v11 = &stru_1F2ABD380;
    }
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v11);
  }
  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
}

void sub_1D34EE24C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v4);
  _Unwind_Resume(a1);
}

BOOL TFSVolumeInfo::VolumeFormatFetched(TFSVolumeInfo *this)
{
  id v2 = (os_unfair_lock_s *)((char *)this + 312);
  os_unfair_lock_lock((os_unfair_lock_t)this + 78);
  BOOL v3 = CFStringGetLength(*((CFStringRef *)this + 12)) > 0;
  os_unfair_lock_unlock(v2);
  return v3;
}

void sub_1D34EE2D4(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void TFSVolumeInfo::GetVolumeFormatString(TFSVolumeInfo *this@<X0>, TString *a2@<X8>)
{
  if (!TFSVolumeInfo::VolumeFormatFetched(this))
  {
    TFSVolumeInfo::VolumeFormatString(this, (const void **)&v4);
    os_unfair_lock_lock((os_unfair_lock_t)this + 78);
    if ((__CFString **)((char *)this + 96) != &v4) {
      TString::SetStringRefAsImmutable((TString *)this + 12, (TString *)v4);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)this + 78);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v4);
  }
  a2->fString.int fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a2, *((TString **)this + 12));
}

void sub_1D34EE380(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10)
{
  os_unfair_lock_unlock(v10);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);
  _Unwind_Resume(a1);
}

void TFSVolumeInfo::GetUUID(TFSVolumeInfo *this@<X0>, TString *a2@<X8>)
{
  a2->fString.int fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a2, *((TString **)this + 49));
}

void sub_1D34EE3E8(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

uint64_t TFSVolumeInfo::ReusableSpaceOnVolume(TFSVolumeInfo *this)
{
  v18[2] = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 48) || !*((unsigned char *)this + 107)) {
    return 0;
  }
  uint64_t v3 = *((void *)this + 7);
  id v2 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  CFTypeRef v4 = (os_unfair_lock_s *)(v3 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v3 + 100));
  uint64_t v5 = *(const void **)(v3 + 16);
  id v16 = v5;
  if (v5) {
    CFRetain(v5);
  }
  os_unfair_lock_unlock(v4);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  uint64_t valuePtr = 0;
  CFTypeRef v6 = (__CFString *)CFURLCopyFileSystemPath((CFURLRef)v5, kCFURLPOSIXPathStyle);
  id v14 = v6;
  if (v6)
  {
    v17[0] = @"CACHE_DELETE_VOLUME";
    CFStringRef v7 = v6;
    v17[1] = @"CACHE_DELETE_URGENCY";
    v18[0] = v7;
    v18[1] = &unk_1F2AC3890;
    CFURLRef v8 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v18 forKeys:v17 count:2];

    BOOL v9 = (const void *)CacheDeleteCopyPurgeableSpaceWithInfo();
    long long v13 = v9;
    if (v9)
    {
      Value = CFDictionaryGetValue((CFDictionaryRef)v9, @"CACHE_DELETE_AMOUNT");
      CFNumberRef v11 = (const __CFNumber *)static_cf_cast<__CFString const*,void const*>(Value);
      if (v11)
      {
        if (!CFNumberGetValue(v11, kCFNumberLongLongType, &valuePtr)) {
          uint64_t valuePtr = 0;
        }
      }
    }
    TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TRef(&v13);

    uint64_t v1 = valuePtr;
  }
  else
  {
    uint64_t v1 = 0;
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v14);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef(&v16);
  return v1;
}

void sub_1D34EE580(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v5 = va_arg(va1, const void *);
  uint64_t v7 = va_arg(va1, void);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)va1);
  _Unwind_Resume(a1);
}

const void **TFSVolumeInfo::UpdateReusableSpaceOnVolumes(TFSVolumeInfo *this)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  TNodePtr v65 = (void *)CacheDeleteCopyPurgeableSpaceWithInfo();
  [v65 objectForKey:@"CACHE_DELETE_PURGEABLE_BY_CONTAINER"];
  memset(v63, 0, sizeof(v63));
  int v64 = 1065353216;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  v44 = long long v62 = 0u;
  uint64_t v1 = [v44 allKeys];
  id obj = v1;
  uint64_t v2 = [v1 countByEnumeratingWithState:&v59 objects:v71 count:16];
  if (v2)
  {
    uint64_t v43 = *(void *)v60;
    do
    {
      uint64_t v45 = v2;
      for (uint64_t i = 0; i != v45; ++i)
      {
        if (*(void *)v60 != v43) {
          objc_enumerationMutation(obj);
        }
        CFTypeRef v4 = *(void **)(*((void *)&v59 + 1) + 8 * i);
        uint64_t v5 = [v44 objectForKey:v4];
        long long v57 = 0u;
        long long v58 = 0u;
        long long v55 = 0u;
        long long v56 = 0u;
        __int16 v46 = v5;
        CFTypeRef v6 = [v5 allValues];
        uint64_t v7 = 0;
        uint64_t v8 = [v6 countByEnumeratingWithState:&v55 objects:v70 count:16];
        if (v8)
        {
          uint64_t v9 = *(void *)v56;
          do
          {
            for (uint64_t j = 0; j != v8; ++j)
            {
              if (*(void *)v56 != v9) {
                objc_enumerationMutation(v6);
              }
              CFNumberRef v11 = [*(id *)(*((void *)&v55 + 1) + 8 * j) objectForKey:@"CACHE_DELETE_SHARED_PURGEABLE"];
              uint64_t v12 = [v11 longLongValue];

              uint64_t v7 = (uint64_t *)((char *)v7 + v12);
            }
            uint64_t v8 = [v6 countByEnumeratingWithState:&v55 objects:v70 count:16];
          }
          while (v8);
        }

        long long v13 = v4;
        v49.fString.int fRef = &stru_1F2ABD380;
        CFRetain(&stru_1F2ABD380);
        TString::SetStringRefAsImmutable(&v49, v13);

        if (operator==((CFTypeRef *)&v49.fString.fRef, "unknown container"))
        {
          TString::SetStringRefAsImmutable(&v49, 0);
          TString::SetFromUTF8(&v49, (const UInt8 *)"disk1", 5);
        }
        v66 = (FINode *)&v49;
        std::__hash_table<std::__hash_value_type<TString,long long>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,long long>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,long long>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,long long>>>::__emplace_unique_key_args<TString,std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>((uint64_t)v63, &v49, (uint64_t)&std::piecewise_construct, (TString ***)&v66)[3] = v7;
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v49.fString.fRef);
      }
      uint64_t v1 = obj;
      uint64_t v2 = [obj countByEnumeratingWithState:&v59 objects:v71 count:16];
    }
    while (v2);
  }

  long long v53 = 0uLL;
  v54[0] = 0;
  uint64_t VolumeMap = GetVolumeMap();
  VolumeInfoLock();
  os_unfair_lock_lock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
  for (k = *(uint64_t **)(VolumeMap + 16); k; k = (uint64_t *)*k)
  {
    id v16 = (__CFString *)k[2];
    v49.fString.int fRef = v16;
    if (v16) {
      CFRetain(v16);
    }
    char v50 = *((unsigned char *)k + 24);
    int v17 = (std::__shared_weak_count *)k[5];
    uint64_t v51 = k[4];
    char v52 = v17;
    if (v17)
    {
      atomic_fetch_add_explicit(&v17->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      if (v52)
      {
        uint64_t v18 = std::__shared_weak_count::lock(v52);
        if (v18)
        {
          BOOL v19 = v18;
          uint64_t v20 = v51;
          if (v51)
          {
            if (CFStringGetLength(*(CFStringRef *)(v51 + 80)))
            {
              v66 = (FINode *)(v20 + 80);
              uint64_t v21 = std::__hash_table<std::__hash_value_type<TString,long long>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,long long>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,long long>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,long long>>>::__emplace_unique_key_args<TString,std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>((uint64_t)v63, (TString *)(v20 + 80), (uint64_t)&std::piecewise_construct, (TString ***)&v66)[3];
            }
            else
            {
              uint64_t v21 = (uint64_t *)TFSVolumeInfo::ReusableSpaceOnVolume((TFSVolumeInfo *)v20);
            }
            if (v21 != *(uint64_t **)(v20 + 160))
            {
              BOOL v22 = *(const void **)(v20 + 40);
              uint64_t v48 = v22;
              if (v22) {
                CFRetain(v22);
              }
              uint64_t v23 = (void *)*((void *)&v53 + 1);
              if (*((void *)&v53 + 1) >= v54[0])
              {
                unint64_t v25 = (void *)v53;
                uint64_t v26 = (uint64_t)(*((void *)&v53 + 1) - v53) >> 3;
                unint64_t v27 = v26 + 1;
                if ((unint64_t)(v26 + 1) >> 61) {
                  std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
                }
                uint64_t v28 = v54[0] - v53;
                if ((uint64_t)(v54[0] - v53) >> 2 > v27) {
                  unint64_t v27 = v28 >> 2;
                }
                if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v29 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v29 = v27;
                }
                int v69 = v54;
                if (v29)
                {
                  id v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)v54, v29);
                  uint64_t v23 = (void *)*((void *)&v53 + 1);
                  unint64_t v25 = (void *)v53;
                }
                else
                {
                  id v30 = 0;
                }
                int v31 = &v30[8 * v26];
                __int16 v32 = &v30[8 * v29];
                long long v68 = v32;
                *(void *)int v31 = v48;
                uint64_t v48 = 0;
                *((void *)&v67 + 1) = v31 + 8;
                if (v23 == v25)
                {
                  BOOL v24 = v31 + 8;
                }
                else
                {
                  do
                  {
                    uint64_t v33 = *--v23;
                    *((void *)v31 - 1) = v33;
                    v31 -= 8;
                    *uint64_t v23 = 0;
                  }
                  while (v23 != v25);
                  BOOL v24 = (void *)*((void *)&v67 + 1);
                  __int16 v32 = v68;
                }
                long long v34 = v53;
                *(void *)&long long v53 = v31;
                *((void *)&v53 + 1) = v24;
                long long v67 = v34;
                char v35 = (char *)v54[0];
                v54[0] = v32;
                long long v68 = v35;
                v66 = (FINode *)v34;
                std::__split_buffer<ROSPVolumeID>::~__split_buffer((uint64_t)&v66);
              }
              else
              {
                **((void **)&v53 + 1) = v48;
                BOOL v24 = v23 + 1;
                uint64_t v48 = 0;
              }
              *((void *)&v53 + 1) = v24;
              TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v48);
              os_unfair_lock_lock((os_unfair_lock_t)(v20 + 312));
              *(void *)(v20 + 160) = v21;
              os_unfair_lock_unlock((os_unfair_lock_t)(v20 + 312));
            }
          }
          std::__shared_weak_count::__release_shared[abi:ne180100](v19);
        }
        if (v52) {
          std::__shared_weak_count::__release_weak(v52);
        }
      }
    }
    TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)&v49.fString.fRef);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
  __int16 v37 = (const void **)*((void *)&v53 + 1);
  for (m = (const void **)v53; m != v37; ++m)
  {
    char v38 = *m;
    TNodePtr v47 = v38;
    if (v38) {
      CFRetain(v38);
    }
    TNode::GetVolumeNode((TGlobalNodes *)&v47, (TNodePtr *)&v66);
    TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&v47);
    if (TNodeFromFINode(v66))
    {
      uint64_t v39 = (const TNode *)TNodeFromFINode(v66);
      TNode::SendNotification(v39, 2, (id *)&v66, 1919251312, 0);
      id v40 = (const TNode *)TNodeFromFINode(v66);
      TNode::SendNotification(v40, 2, (id *)&v66, 1718776688, 0);
    }
  }
  v66 = (FINode *)&v53;
  std::vector<ROSPVolumeID>::__destroy_vector::operator()[abi:ne180100]((void ***)&v66);
  std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::~__hash_table((uint64_t)v63);

  return TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef((const void **)&v65);
}

void sub_1D34EEB58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, const void *a16, void **a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,const void *a47)
{
  TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(&a16);
  std::__shared_weak_count::__release_shared[abi:ne180100](v47);
  std::pair<VolumeKey const,std::weak_ptr<TFSVolumeInfo>>::~pair((uint64_t)&a17);
  os_unfair_lock_unlock((os_unfair_lock_t)&VolumeInfoLock(void)::sVolumeInfoLock);
  a17 = (void **)&a21;
  std::vector<ROSPVolumeID>::__destroy_vector::operator()[abi:ne180100](&a17);
  std::__hash_table<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>>>::~__hash_table((uint64_t)&a41);

  TAutoRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TAutoRef(&a47);
  _Unwind_Resume(a1);
}

const void **std::pair<VolumeKey const,std::weak_ptr<TFSVolumeInfo>>::~pair(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)a1);
}

uint64_t TFSVolumeInfo::GetReclaimableSpace(TFSVolumeInfo *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 312);
  os_unfair_lock_lock((os_unfair_lock_t)this + 78);
  uint64_t v3 = *((void *)this + 20) & ~(*((uint64_t *)this + 20) >> 63);
  os_unfair_lock_unlock(v2);
  return v3;
}

BOOL TFSVolumeInfo::SpaceAndCapacityAreUpToDate(TFSVolumeInfo *this, int a2)
{
  CFTypeRef v4 = (os_unfair_lock_s *)((char *)this + 312);
  os_unfair_lock_lock((os_unfair_lock_t)this + 78);
  BOOL v5 = *((unsigned char *)this + 131) != 0;
  if (*((unsigned char *)this + 131)) {
    BOOL v6 = a2 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6) {
    BOOL v5 = *((void *)this + 20) >= 0;
  }
  os_unfair_lock_unlock(v4);
  return v5;
}

uint64_t TFSVolumeInfo::VolumeSize(TFSVolumeInfo *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 312);
  os_unfair_lock_lock((os_unfair_lock_t)this + 78);
  uint64_t v3 = *((void *)this + 21);
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t TFSVolumeInfo::GetCapacity(TFSVolumeInfo *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 312);
  os_unfair_lock_lock((os_unfair_lock_t)this + 78);
  uint64_t v3 = *((void *)this + 18);
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t TFSVolumeInfo::GetFreeSpace(TFSVolumeInfo *this)
{
  uint64_t v2 = (os_unfair_lock_s *)((char *)this + 312);
  os_unfair_lock_lock((os_unfair_lock_t)this + 78);
  uint64_t v3 = *((void *)this + 19);
  os_unfair_lock_unlock(v2);
  return v3;
}

TString *TString::operator+@<X0>(const __CFString **a1@<X0>, const TString *a2@<X1>, TString *a3@<X8>)
{
  CFStringRef v5 = *a1;
  a3->fString.int fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  CFMutableStringRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v5);
  if (a3->fString.fRef) {
    CFRelease(a3->fString.fRef);
  }
  a3->fString.int fRef = MutableCopy;
  return TString::Append(a3, a2);
}

void sub_1D34EEE98(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void std::__throw_bad_optional_access[abi:ne180100]()
{
  exception = __cxa_allocate_exception(8uLL);
  void *exception = MEMORY[0x1E4FBA4F8] + 16;
  __cxa_throw(exception, MEMORY[0x1E4FBA348], MEMORY[0x1E4FBA1F0]);
}

TString *std::construct_at[abi:ne180100]<TString,NSString * {__strong},TString*>(TString *a1, id *a2)
{
  uint64_t v3 = (TString *)*a2;
  a1->fString.int fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a1, v3);

  return a1;
}

void sub_1D34EEF5C(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v2);

  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<ROSPVolumeID>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef((const void **)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::vector<ROSPVolumeID>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (const void **)**a1;
  if (v2)
  {
    CFTypeRef v4 = (const void **)v1[1];
    CFStringRef v5 = v2;
    if (v4 != v2)
    {
      do
        CFTypeRef v4 = TRef<__CFData const*,TRetainReleasePolicy<__CFData const*>>::~TRef(v4 - 1);
      while (v4 != v2);
      CFStringRef v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__shared_ptr_emplace<TVolumeSyncThread>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB208;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TVolumeSyncThread>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB208;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

void std::__shared_ptr_emplace<TFolderSizingThread>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB278;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TFolderSizingThread>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB278;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

uint64_t **std::__hash_table<std::__hash_value_type<TString,long long>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,long long>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,long long>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,long long>>>::__emplace_unique_key_args<TString,std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>(uint64_t a1, TString *this, uint64_t a3, TString ***a4)
{
  unint64_t v8 = FowlerNollVoHash::hash(this, this);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = v8;
      if (v8 >= v10) {
        unint64_t v4 = v8 % v10;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v8;
    }
    long long v13 = *(uint64_t ****)(*(void *)a1 + 8 * v4);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = (uint64_t **)*i)
      {
        unint64_t v15 = (unint64_t)i[1];
        if (v15 == v9)
        {
          if (CFEqual(i[2], this->fString.fRef)) {
            return i;
          }
        }
        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }
          else
          {
            v15 &= v10 - 1;
          }
          if (v15 != v4) {
            break;
          }
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<TString,long long>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,long long>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,long long>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,long long>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>(a1, (__CFString *)v9, a4, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<TBlockingEventQueue>>>>::__rehash<true>(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
      else {
        unint64_t v4 = v9;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
  }
  BOOL v22 = *(void **)(*(void *)a1 + 8 * v4);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    *BOOL v22 = v25[0];
  }
  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }
      else
      {
        v23 &= v10 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }
  uint64_t i = (uint64_t **)v25[0];
  v25[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>>>>::reset[abi:ne180100]((uint64_t)v25, 0);
  return i;
}

void sub_1D34EF3AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

TString *std::__hash_table<std::__hash_value_type<TString,long long>,std::__unordered_map_hasher<TString,std::__hash_value_type<TString,long long>,std::hash<TString>,std::equal_to<TString>,true>,std::__unordered_map_equal<TString,std::__hash_value_type<TString,long long>,std::equal_to<TString>,std::hash<TString>,true>,std::allocator<std::__hash_value_type<TString,long long>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<TString const&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, __CFString *a2@<X1>, TString ***a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = (TString *)operator new(0x20uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  v8->fString.int fRef = 0;
  v8[1].fString.int fRef = a2;
  uint64_t result = std::pair<TString const,long long>::pair[abi:ne180100]<TString const&>(v8 + 2, *a3);
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_1D34EF41C(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<TString,TBusyFolders::TSpecialFolderStream>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

TString *std::pair<TString const,long long>::pair[abi:ne180100]<TString const&>(TString *a1, TString **a2)
{
  a1->fString.int fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable(a1, *a2);
  a1[1].fString.int fRef = 0;
  return a1;
}

void sub_1D34EF47C(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<TFSVolumeInfo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB160;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TFSVolumeInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB160;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

uint64_t TFSInfoSizer::TFSInfoSizer(uint64_t a1, id *a2, id *a3, uint64_t *a4, uint64_t a5)
{
  unint64_t v9 = (id *)(a1 + 8);
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 72) = 0;
  *(unsigned char *)(a1 + 96) = 0;
  objc_storeStrong((id *)a1, *a2);
  objc_storeStrong(v9, *a3);
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  uint64_t v11 = *a4;
  uint64_t v10 = a4[1];
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v12 = *(std::__shared_weak_count **)(a1 + 80);
  *(void *)(a1 + 72) = v11;
  *(void *)(a1 + 80) = v10;
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
  *(void *)(a1 + 88) = a5;
  *(unsigned char *)(a1 + 96) = 0;
  return a1;
}

void TFSInfoSizerCompanion::~TFSInfoSizerCompanion(id *this)
{
  *this = &unk_1F2ABA9D8;

  uint64_t v2 = this + 2;
  std::vector<TFSInfoSizerCompanion::TFolderStatistics>::__destroy_vector::operator()[abi:ne180100](&v2);
}

{
  void **v2;

  *this = &unk_1F2ABA9D8;

  uint64_t v2 = this + 2;
  std::vector<TFSInfoSizerCompanion::TFolderStatistics>::__destroy_vector::operator()[abi:ne180100](&v2);
  MEMORY[0x1D9436740](this, 0xA1C409A6BAFF5);
}

uint64_t TFSInfoSizerCompanion::NewIteration(uint64_t a1, CFIndex *a2)
{
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = *(void *)(a1 + 24);
  unint64_t v4 = (uint64_t *)(a1 + 16);
  id v45 = 0;
  if (v5 == v6)
  {
    id v10 = *(id *)(a1 + 40);
    id v45 = v10;
  }
  else
  {
    uint64_t v7 = (FINode *)*(id *)(v6 - 64);
    if (TNodeFromFINode(v7))
    {
      CFIndex v8 = *a2;
      TCFURLInfo::CheckPrefetchState(*a2, 1);
      if ((*(_WORD *)(v8 + 76) & 4) != 0)
      {
        uint64_t v11 = (TNode *)TNodeFromFINode(v7);
        TCFURLInfo::Name((TCFURLInfo *)*a2, &v44);
        TNode::FindChild(v11, (TNode *)&v44, 0, 0, (void **)&v40);
      }
      else
      {
        unint64_t v9 = (TNode *)TNodeFromFINode(v7);
        TCFURLInfo::Name((TCFURLInfo *)*a2, &v44);
        TNode::FindChildButDontSynchronize(v9, (TNode *)&v44, (void **)&v40);
      }
      TNodePtr::operator=(&v45, (void **)&v40);

      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v44.fString.fRef);
    }

    id v10 = v45;
  }
  unint64_t v12 = *(void **)(a1 + 8);
  uint64_t v14 = v12[11];
  uint64_t v13 = v12[12];
  uint64_t v15 = v12[13];
  uint64_t v16 = v12[16];
  id v40 = (char *)v10;
  uint64_t v17 = TNodeFromFINode((FINode *)v45);
  if (v17)
  {
    BOOL v18 = (TNode *)TNodeFromFINode((FINode *)v45);
    LODWORD(v17) = TNode::SizingGeneration(v18);
  }
  *(_DWORD *)id v41 = v17;
  v41[4] = 0;
  *(void *)&v41[8] = v15;
  *(void *)&v41[16] = v16;
  *(void *)&v41[24] = v13;
  uint64_t v42 = v14;
  CFIndex v19 = a2[1];
  *(void *)&long long v43 = *a2;
  *((void *)&v43 + 1) = v19;
  if (v19) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v20 = *(void **)(a1 + 24);
  if ((unint64_t)v20 >= *(void *)(a1 + 32))
  {
    uint64_t v24 = std::vector<TFSInfoSizerCompanion::TFolderStatistics>::__push_back_slow_path<TFSInfoSizerCompanion::TFolderStatistics>(v4, (uint64_t)&v40);
    unint64_t v25 = (std::__shared_weak_count *)*((void *)&v43 + 1);
    *(void *)(a1 + 24) = v24;
    if (v25) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v25);
    }
  }
  else
  {
    size_t v21 = TNodePtr::TNodePtr(v20, (id *)&v40);
    long long v22 = *(_OWORD *)v41;
    long long v23 = *(_OWORD *)&v41[16];
    v21[5] = v42;
    *(_OWORD *)(v21 + 3) = v23;
    *(_OWORD *)(v21 + 1) = v22;
    *((_OWORD *)v21 + 3) = v43;
    long long v43 = 0uLL;
    *(void *)(a1 + 24) = v21 + 8;
  }

  if (v5 == v6 || !TNodeFromFINode((FINode *)v45))
  {
    uint64_t v33 = 0;
  }
  else
  {
    uint64_t v26 = TNodeFromFINode((FINode *)v45);
    unint64_t v27 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v26);
    os_unfair_lock_lock(v27);
    unint64_t v29 = *(TFSInfo **)(v26 + 16);
    uint64_t v28 = *(std::__shared_weak_count **)(v26 + 24);
    if (v28) {
      atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    os_unfair_lock_unlock(v27);
    TFSInfo::FolderStats(v29, &v40);
    if (v41[24])
    {
      uint64_t v30 = *(void *)(a1 + 8);
      uint64_t v31 = *(void *)v41;
      __int16 v32 = &v40[*(void *)(v30 + 104)];
      *(int64x2_t *)(v30 + 88) = vaddq_s64(*(int64x2_t *)(v30 + 88), (int64x2_t)vextq_s8(*(int8x16_t *)&v41[8], *(int8x16_t *)&v41[8], 8uLL));
      *(void *)(v30 + 104) = v32;
      *(void *)(v30 + 128) += v31;
      uint64_t v33 = 1;
    }
    else
    {
      uint64_t v34 = TNodeFromFINode((FINode *)v45);
      if (TNode::IsDeferredForSymlink(v34, (uint64_t (*)(void *))TFSInfo::IsPackage, 0))
      {
        char v35 = (TNode *)TNodeFromFINode((FINode *)v45);
        uint64_t CachedPackageSize = TNode::GetCachedPackageSize(v35);
        uint64_t v33 = 0;
        if (CachedPackageSize != -2 && v37 != -2)
        {
          uint64_t v38 = *(void *)(a1 + 8);
          *(void *)(v38 + 104) += CachedPackageSize;
          *(void *)(v38 + 128) += v37;
          uint64_t v33 = 1;
          *(int64x2_t *)(v38 + 88) = vaddq_s64(*(int64x2_t *)(v38 + 88), vdupq_n_s64(1uLL));
        }
      }
      else
      {
        uint64_t v33 = 0;
      }
    }
    if (v28) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v28);
    }
  }

  return v33;
}

void sub_1D34EF9B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  if (v18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v18);
  }

  _Unwind_Resume(a1);
}

void TFSInfoSizerCompanion::TFolderStatistics::~TFolderStatistics(TFSInfoSizerCompanion::TFolderStatistics *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
}

void TFSInfoSizerCompanion::FinishIteration(TFSInfoSizerCompanion *this, char a2)
{
  uint64_t v4 = *((void *)this + 3);
  uint64_t v5 = (FINode *)*(id *)(v4 - 64);
  v33[1] = v5;
  uint64_t v6 = *(void *)(v4 - 24);
  long long v7 = *(_OWORD *)(v4 - 56);
  long long v35 = *(_OWORD *)(v4 - 40);
  long long v34 = v7;
  uint64_t v36 = v6;
  CFIndex v8 = *(FINode ***)(v4 - 16);
  uint64_t v37 = v8;
  unint64_t v9 = *(std::__shared_weak_count **)(v4 - 8);
  uint64_t v38 = v9;
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v10 = *((void *)this + 3) - 64;
    std::__destroy_at[abi:ne180100]<TFSInfoSizerCompanion::TFolderStatistics,0>(v10);
    *((void *)this + 3) = v10;
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    uint64_t v11 = *((void *)this + 3) - 64;
    std::__destroy_at[abi:ne180100]<TFSInfoSizerCompanion::TFolderStatistics,0>(v11);
    *((void *)this + 3) = v11;
  }
  unint64_t v12 = v5;
  v33[0] = v12;
  int v13 = v34;
  if (TNodeFromFINode(v12))
  {
    uint64_t v14 = *v8;
    uint64_t v15 = (TNode *)TNodeFromFINode(v33[0]);
    TNode::CFURL(v15, &v32);
    LOBYTE(v14) = IsEqual(v14, v32.fFINode);
    TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v32.fFINode);
    if ((v14 & 1) == 0)
    {
      TNodePtr::TNodePtr(&v32, 0);
      TNodePtr::operator=((void **)v33, (void **)&v32.fFINode);
    }
  }
  if ((a2 & 1) == 0)
  {
    uint64_t v16 = v36;
    uint64_t v17 = v35;
    BOOL v18 = (void *)*((void *)this + 1);
    uint64_t v30 = v18[11];
    uint64_t v31 = *((void *)&v34 + 1);
    uint64_t v28 = v18[16];
    uint64_t v29 = v18[13];
    uint64_t v19 = v18[12] - *((void *)&v35 + 1);
    if (!TNodeFromFINode(v33[0]) && (v19 > 1000 || *((void *)this + 3) - *((void *)this + 2) <= 0xBFuLL))
    {
      v32.fFINode = *v8;
      TNode::GetNodeFromURL((CFURLRef *)&v32, (TNodePtr *)v33, 0);
    }
    if (TNodeFromFINode(v33[0]))
    {
      uint64_t v20 = TNodeFromFINode(v33[0]);
      size_t v21 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v20);
      uint64_t v22 = v16;
      os_unfair_lock_lock(v21);
      uint64_t v24 = *(void *)(v20 + 16);
      long long v23 = *(std::__shared_weak_count **)(v20 + 24);
      if (v23) {
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v21);
      os_unfair_lock_lock((os_unfair_lock_t)(v24 + 100));
      int v25 = *(_DWORD *)(v24 + 115);
      os_unfair_lock_unlock((os_unfair_lock_t)(v24 + 100));
      if ((v25 & 0x2000000) != 0
        || (os_unfair_lock_lock((os_unfair_lock_t)(v24 + 100)),
            int v26 = *(_DWORD *)(v24 + 115),
            os_unfair_lock_unlock((os_unfair_lock_t)(v24 + 100)),
            (v26 & 0x10000000) == 0)
        && *(unsigned char *)(v24 + 112) != 7)
      {
        unint64_t v27 = (TNode *)TNodeFromFINode(v33[0]);
        TNode::SetSizeProperties(v27, v29 - v31, v28 - v17, v19, v30 - v22, v13);
      }
      if (v23) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v23);
      }
    }
  }

  if (v9)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
}

void sub_1D34EFD08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, ...)
{
  va_start(va, a9);

  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
  TFSInfoSizerCompanion::TFolderStatistics::~TFolderStatistics((TFSInfoSizerCompanion::TFolderStatistics *)va);
  _Unwind_Resume(a1);
}

uint64_t TFSInfoSizerCompanion::SetContainsDatalessFolders(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 16);
  for (uint64_t i = *(void *)(this + 24); i != v1; i -= 64)
  {
    if (*(unsigned char *)(i - 52)) {
      break;
    }
    *(unsigned char *)(i - 52) = 1;
  }
  return this;
}

BOOL TFSInfoSizer::ShouldCancel(id *this, void *a2)
{
  return !this || TFSInfoSizer::IsCanceled(this);
}

BOOL TFSInfoSizer::IsCanceled(id *this)
{
  uint64_t v2 = (FINode *)*this;
  uint64_t v3 = (FINode *)this[1];
  if (!TNodeFromFINode(v2)) {
    goto LABEL_7;
  }
  uint64_t v4 = TNodeFromFINode(v2);
  uint64_t v5 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v4);
  os_unfair_lock_lock(v5);
  uint64_t v7 = *(void *)(v4 + 16);
  uint64_t v6 = *(std::__shared_weak_count **)(v4 + 24);
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v5);
  CFIndex v8 = (os_unfair_lock_s *)(v7 + 100);
  os_unfair_lock_lock((os_unfair_lock_t)(v7 + 100));
  int v9 = *(_DWORD *)(v7 + 115);
  os_unfair_lock_unlock(v8);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  if ((v9 & 2) != 0)
  {
    if (this[9])
    {
      if (TNodeFromFINode(v3))
      {
        unint64_t v12 = (TNode *)TNodeFromFINode(v3);
        if (!atomic_load((unsigned int *)TNode::GetNotifierList(v12)))
        {
          if (!TNodeFromFINode(v2)) {
            goto LABEL_9;
          }
          uint64_t v14 = (TNode *)TNodeFromFINode(v2);
          uint64_t NotifierList = TNode::GetNotifierList(v14);
          uint64_t v16 = (os_unfair_lock_s *)(NotifierList + 64);
          os_unfair_lock_lock((os_unfair_lock_t)(NotifierList + 64));
          uint64_t v18 = *(void *)(NotifierList + 40);
          uint64_t v17 = *(void *)(NotifierList + 48);
          os_unfair_lock_unlock(v16);
          if (v18 == v17) {
            goto LABEL_9;
          }
        }
      }
    }
  }
  else
  {
LABEL_7:
    uint64_t v10 = this[9];
    if (v10)
    {
      if (v10[13] == 1003
        || TNodeFromFINode(v2)
        && (uint64_t v19 = (TNode *)TNodeFromFINode(v2),
            (unsigned int v20 = atomic_load((unsigned int *)(TNode::GetNotifierList(v19) + 4))) == 0)
        && (!TNodeFromFINode(v3)
         || (long long v23 = (TNode *)TNodeFromFINode(v3),
             (unsigned int v24 = atomic_load((unsigned int *)(TNode::GetNotifierList(v23) + 4))) == 0)))
      {
LABEL_9:
        BOOL v11 = 1;
        goto LABEL_22;
      }
    }
  }
  if (TNodeFromFINode(v2))
  {
    size_t v21 = (TNode *)TNodeFromFINode(v2);
    TNode::GetVolumeInfo(v21, &v25);
    BOOL v11 = *(unsigned char *)(v25 + 123) != 0;
    if (v26) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v26);
    }
  }
  else
  {
    BOOL v11 = 0;
  }
LABEL_22:

  return v11;
}

void sub_1D34EFF84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void TFSInfoSizer::SizeFolder(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = TNodeFromFINode(*(FINode **)a1);
  uint64_t v5 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v4);
  os_unfair_lock_lock(v5);
  uint64_t v7 = *(void *)(v4 + 16);
  uint64_t v6 = *(std::__shared_weak_count **)(v4 + 24);
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v5);
    int v8 = *(unsigned __int8 *)(v7 + 112);
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
    if (v8) {
      return;
    }
  }
  else
  {
    os_unfair_lock_unlock(v5);
    if (*(unsigned char *)(v7 + 112)) {
      return;
    }
  }
  uint64_t v9 = TNodeFromFINode(*(FINode **)a1);
  uint64_t v10 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v9);
  os_unfair_lock_lock(v10);
  uint64_t v12 = *(void *)(v9 + 16);
  BOOL v11 = *(std::__shared_weak_count **)(v9 + 24);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  os_unfair_lock_unlock(v10);
  os_unfair_lock_lock((os_unfair_lock_t)(v12 + 100));
  int v13 = *(_DWORD *)(v12 + 115);
  os_unfair_lock_unlock((os_unfair_lock_t)(v12 + 100));
  if ((v13 & 0x20) != 0)
  {
    uint64_t v14 = (TNode *)TNodeFromFINode(*(FINode **)a1);
    *(_DWORD *)(a1 + 48) = TNode::SizingGeneration(v14);
    if ((TFSInfo::IsDataless((TFSInfo *)v12, v15, v16) & 1) == 0)
    {
      os_unfair_lock_lock((os_unfair_lock_t)(v12 + 100));
      unint64_t v17 = *(unsigned int *)(v12 + 115) | ((unint64_t)*(unsigned __int16 *)(v12 + 119) << 32);
      os_unfair_lock_unlock((os_unfair_lock_t)(v12 + 100));
      if ((v17 & 0x400000000) == 0)
      {
        os_unfair_lock_lock((os_unfair_lock_t)(v12 + 100));
        CFURLRef v18 = *(const __CFURL **)(v12 + 16);
        CFURLRef v51 = v18;
        if (v18)
        {
          CFRetain(v18);
          os_unfair_lock_unlock((os_unfair_lock_t)(v12 + 100));
          _ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v49);
          if (!TCFURLInfo::Initialize(v49, v51, 1, 0)
            && !TCFURLInfo::GetVolumeInfoRecord((CFURLRef *)v49, v48))
          {
            uint64_t v19 = v48[1];
            v47[1] = 0;
            v47[2] = 0;
            v47[0] = a1;
            std::allocate_shared[abi:ne180100]<TFSInfoSizerCompanion,std::allocator<TFSInfoSizerCompanion>,TNodePtr &,void>((id *)a1, &v45);
            uint64_t v38 = 0;
            __int16 v39 = 0;
            memset(v37, 0, 43);
            memset(&v37[3], 0, 59);
            id v41 = 0;
            uint64_t v42 = 0;
            uint64_t v40 = 0;
            int v43 = 0;
            char v44 = 1;
            unsigned int v20 = v49;
            size_t v21 = v50;
            if (v50)
            {
              atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
              uint64_t v22 = (std::__shared_weak_count *)*((void *)&v37[0] + 1);
              *(void *)&v37[0] = v20;
              *((void *)&v37[0] + 1) = v21;
              if (v22)
              {
                std::__shared_weak_count::__release_shared[abi:ne180100](v22);
                unsigned int v20 = v49;
              }
            }
            else
            {
              v37[0] = (unint64_t)v49;
            }
            long long v23 = v50;
            if (v50) {
              atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            unsigned int v24 = (std::__shared_weak_count *)*((void *)&v37[1] + 1);
            *(void *)&v37[1] = v20;
            *((void *)&v37[1] + 1) = v23;
            if (v24) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v24);
            }
            *(void *)&v37[2] = v19;
            id v41 = TFSInfoSizer::ShouldCancel;
            uint64_t v42 = v47;
            BYTE2(v43) = 1;
            if (IsRunningInFinder())
            {
              LOBYTE(v25) = 1;
            }
            else
            {
              int v26 = v49;
              TCFURLInfo::CheckPrefetchState((CFIndex)v49, 1);
              int v25 = (WORD2(v26[9].fString.fRef) >> 2) & 1;
            }
            BYTE8(v37[2]) = v25;
            BYTE9(v37[2]) = v25;
            std::allocate_shared[abi:ne180100]<TOperationSizer,std::allocator<TOperationSizer>,TOperationSizer::TOperationSizerParams &,void>((const TOperationSizer::TOperationSizerParams *)v37, &v35);
            unint64_t v27 = (TNode *)TNodeFromFINode(*(FINode **)a1);
            IsSynchingAppropriate = (std::__shared_weak_count *)TNode::IsSynchingAppropriate(v27);
            if (BYTE8(v37[2])) {
              int v29 = 0;
            }
            else {
              int v29 = (int)IsSynchingAppropriate;
            }
            if (v29 == 1)
            {
              uint64_t v30 = v35;
              uint64_t v31 = v45;
              TNodePtr v32 = v46;
              if (v46)
              {
                atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
                atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              IsSynchingAppropriate = (std::__shared_weak_count *)*((void *)v30 + 46);
              *((void *)v30 + 45) = v31;
              *((void *)v30 + 46) = v32;
              if (IsSynchingAppropriate) {
                std::__shared_weak_count::__release_shared[abi:ne180100](IsSynchingAppropriate);
              }
              if (v32) {
                std::__shared_weak_count::__release_shared[abi:ne180100](v32);
              }
            }
            *(void *)(v45 + 8) = v35;
            *(void *)(a1 + 56) = TTime::MicrosecondsSinceStartup((TTime *)IsSynchingAppropriate);
            if (v36) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v36 + 8), 1uLL, memory_order_relaxed);
            }
            id v33 = *(id *)a1;
            uint64_t v34 = *(void *)(a2 + 8);
            if (v34) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v34 + 8), 1uLL, memory_order_relaxed);
            }
            TOperationSizer::ComputeSizeWithTimeout(v35);
          }
          if (v50) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v50);
          }
        }
        else
        {
          os_unfair_lock_unlock((os_unfair_lock_t)(v12 + 100));
        }
        TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)&v51);
      }
    }
  }
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  }
}

void sub_1D34F04BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,std::__shared_weak_count *a35,uint64_t a36,uint64_t a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,std::__shared_weak_count *a44,id a45)
{
  if (a35) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a35);
  }
  TFSInfoSizer::SizeFolder(std::shared_ptr<TFSInfoSizer>,unsigned long long)::$_0::~$_0((uint64_t)&a38);
  if (a44) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a44);
  }
  TOperationSizer::TOperationSizerParams::~TOperationSizerParams(&a45);
  uint64_t v48 = *(std::__shared_weak_count **)(v46 - 144);
  if (v48) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v48);
  }
  TString v49 = *(std::__shared_weak_count **)(v46 - 80);
  if (v49) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v49);
  }
  TRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TRef((const void **)(v46 - 72));
  if (v45) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v45);
  }
  _Unwind_Resume(a1);
}

TChildrenList *___ZN12TFSInfoSizer10SizeFolderENSt3__110shared_ptrIS_EEy_block_invoke(uint64_t a1)
{
  uint64_t v2 = (TTime *)TNodeFromFINode(**(FINode ***)(a1 + 48));
  atomic_fetch_add((atomic_uint *volatile)(*((void *)v2 + 7) + 196), 0xFFFFFFFF);
  uint64_t v3 = TTime::MicrosecondsSinceStartup(v2);
  uint64_t v4 = (TTime *)TOperationSizer::ResumeSizing(*(TOperationSizer **)(a1 + 32), 0);
  uint64_t result = (TChildrenList *)TTime::MicrosecondsSinceStartup(v4);
  uint64_t v6 = *(void *)(a1 + 104);
  int v7 = *(_DWORD *)(*(void *)(a1 + 64) + 40);
  *(_DWORD *)(*(void *)(a1 + 88) + 64) = v7;
  if (!v7)
  {
    uint64_t v8 = (uint64_t)result + v6 - v3;
    uint64_t v9 = (TNode *)TNodeFromFINode(*(FINode **)(a1 + 80));
    TNode::SetSizeProperties(v9, *(void *)(*(void *)(a1 + 64) + 104), *(void *)(*(void *)(a1 + 64) + 128), *(void *)(*(void *)(a1 + 64) + 96), *(void *)(*(void *)(a1 + 64) + 88), *(_DWORD *)(*(void *)(a1 + 88) + 48));
    uint64_t v10 = *(TChildrenList **)(TNodeFromFINode(*(FINode **)(a1 + 80)) + 56);
    return TChildrenList::SetLastResizeDuration(v10, v8);
  }
  return result;
}

id __copy_helper_block_ea8_32c64_ZTSKZN12TFSInfoSizer10SizeFolderENSt3__110shared_ptrIS_EEyE3__1(void *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 40);
  a1[4] = *(void *)(a2 + 32);
  a1[5] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(a2 + 56);
  a1[6] = *(void *)(a2 + 48);
  a1[7] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(void *)(a2 + 72);
  a1[8] = *(void *)(a2 + 64);
  a1[9] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  id result = *(id *)(a2 + 80);
  uint64_t v9 = *(void *)(a2 + 88);
  uint64_t v8 = *(void *)(a2 + 96);
  a1[10] = result;
  a1[11] = v9;
  a1[12] = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  a1[13] = *(void *)(a2 + 104);
  return result;
}

void *TFSInfoSizer::SizeFolder(std::shared_ptr<TFSInfoSizer>,unsigned long long)::$_1::$_1(void *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *a1 = *(void *)a2;
  a1[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *(void *)(a2 + 24);
  a1[2] = *(void *)(a2 + 16);
  a1[3] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(void *)(a2 + 40);
  a1[4] = *(void *)(a2 + 32);
  a1[5] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  id v7 = *(id *)(a2 + 48);
  uint64_t v9 = *(void *)(a2 + 56);
  uint64_t v8 = *(void *)(a2 + 64);
  a1[6] = v7;
  a1[7] = v9;
  a1[8] = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  a1[9] = *(void *)(a2 + 72);
  return a1;
}

void __destroy_helper_block_ea8_32c64_ZTSKZN12TFSInfoSizer10SizeFolderENSt3__110shared_ptrIS_EEyE3__1(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 96);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }

  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 40);
  if (v5)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
}

uint64_t TFSInfoSizer::SizeFolder(std::shared_ptr<TFSInfoSizer>,unsigned long long)::$_1::~$_1(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }

  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 24);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 8);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  return a1;
}

TChildrenList *TFSInfoSizer::SizeFolder(std::shared_ptr<TFSInfoSizer>,unsigned long long)::$_0::operator()(TChildrenList *result, int a2, uint64_t a3)
{
  int v3 = *(_DWORD *)(*(void *)result + 40);
  *(_DWORD *)(*((void *)result + 3) + 64) = v3;
  if (!v3)
  {
    uint64_t v6 = (FINode **)result;
    id v7 = (TNode *)TNodeFromFINode(*((FINode **)result + 2));
    if (a2) {
      int isa = (int)v6[3][6].super.isa;
    }
    else {
      int isa = -1;
    }
    TNode::SetSizeProperties(v7, (uint64_t)(*v6)[13].super.isa, (uint64_t)(*v6)[16].super.isa, (uint64_t)(*v6)[12].super.isa, (uint64_t)(*v6)[11].super.isa, isa);
    uint64_t v9 = *(TChildrenList **)(TNodeFromFINode(v6[2]) + 56);
    return TChildrenList::SetLastResizeDuration(v9, a3);
  }
  return result;
}

uint64_t TFSInfoSizer::SizeFolder(std::shared_ptr<TFSInfoSizer>,unsigned long long)::$_0::~$_0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }

  int v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  return a1;
}

void std::vector<TFSInfoSizerCompanion::TFolderStatistics>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 64;
        std::__destroy_at[abi:ne180100]<TFSInfoSizerCompanion::TFolderStatistics,0>(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:ne180100]<TFSInfoSizerCompanion::TFolderStatistics,0>(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  int v3 = *(void **)a1;
}

uint64_t std::vector<TFSInfoSizerCompanion::TFolderStatistics>::__push_back_slow_path<TFSInfoSizerCompanion::TFolderStatistics>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (a1[1] - *a1) >> 6;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 58) {
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2] - v3;
  if (v8 >> 5 > v5) {
    unint64_t v5 = v8 >> 5;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFC0) {
    unint64_t v9 = 0x3FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  v16[4] = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TFSInfoSizerCompanion::TFolderStatistics>>(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  BOOL v11 = &v10[64 * v4];
  v16[0] = v10;
  v16[1] = v11;
  v16[3] = &v10[64 * v9];
  TNodePtr::TNodePtr(v11, (id *)a2);
  long long v12 = *(_OWORD *)(a2 + 8);
  long long v13 = *(_OWORD *)(a2 + 24);
  *((void *)v11 + 5) = *(void *)(a2 + 40);
  *(_OWORD *)(v11 + 24) = v13;
  *(_OWORD *)(v11 + 8) = v12;
  *((_OWORD *)v11 + 3) = *(_OWORD *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  void v16[2] = v11 + 64;
  std::vector<TFSInfoSizerCompanion::TFolderStatistics>::__swap_out_circular_buffer(a1, v16);
  uint64_t v14 = a1[1];
  std::__split_buffer<TFSInfoSizerCompanion::TFolderStatistics>::~__split_buffer((uint64_t)v16);
  return v14;
}

void sub_1D34F0ADC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TFSInfoSizerCompanion::TFolderStatistics>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<TFSInfoSizerCompanion::TFolderStatistics>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v3 = result;
  uint64_t v5 = *result;
  uint64_t v4 = result[1];
  uint64_t v6 = a2[1];
  if (v4 != *result)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = v6 + v7;
      uint64_t v9 = v4 + v7;
      id result = TNodePtr::TNodePtr((void *)(v6 + v7 - 64), (id *)(v4 + v7 - 64));
      long long v10 = *(_OWORD *)(v4 + v7 - 56);
      long long v11 = *(_OWORD *)(v4 + v7 - 40);
      *(void *)(v8 - 24) = *(void *)(v4 + v7 - 24);
      *(_OWORD *)(v8 - 40) = v11;
      *(_OWORD *)(v8 - 56) = v10;
      *(_OWORD *)(v8 - 16) = *(_OWORD *)(v4 + v7 - 16);
      *(void *)(v9 - 16) = 0;
      *(void *)(v9 - 8) = 0;
      v7 -= 64;
    }
    while (v4 + v7 != v5);
    v6 += v7;
  }
  a2[1] = v6;
  uint64_t v12 = *v3;
  *uint64_t v3 = v6;
  a2[1] = v12;
  uint64_t v13 = v3[1];
  v3[1] = a2[2];
  a2[2] = v13;
  uint64_t v14 = v3[2];
  v3[2] = a2[3];
  a2[3] = v14;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<TFSInfoSizerCompanion::TFolderStatistics>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 58) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(a2 << 6);
}

uint64_t std::__split_buffer<TFSInfoSizerCompanion::TFolderStatistics>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 64;
    std::__destroy_at[abi:ne180100]<TFSInfoSizerCompanion::TFolderStatistics,0>(i - 64);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

id std::allocate_shared[abi:ne180100]<TFSInfoSizerCompanion,std::allocator<TFSInfoSizerCompanion>,TNodePtr &,void>@<X0>(id *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x48uLL);
  v4[1] = 0;
  v4[2] = 0;
  void *v4 = &unk_1F2ABB2E8;
  v4[3] = &unk_1F2ABA9D8;
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  id result = *a1;
  v4[8] = result;
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void std::__shared_ptr_emplace<TFSInfoSizerCompanion>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB2E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TFSInfoSizerCompanion>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB2E8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

uint64_t std::__shared_ptr_emplace<TFSInfoSizerCompanion>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 32))();
}

void *std::allocate_shared[abi:ne180100]<TOperationSizer,std::allocator<TOperationSizer>,TOperationSizer::TOperationSizerParams &,void>@<X0>(const TOperationSizer::TOperationSizerParams *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x190uLL);
  id result = std::__shared_ptr_emplace<TOperationSizer>::__shared_ptr_emplace[abi:ne180100]<TOperationSizer::TOperationSizerParams &,std::allocator<TOperationSizer>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1D34F0DC0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<TOperationSizer>::__shared_ptr_emplace[abi:ne180100]<TOperationSizer::TOperationSizerParams &,std::allocator<TOperationSizer>,0>(void *a1, const TOperationSizer::TOperationSizerParams *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F2ABB1D0;
  TOperationSizer::TOperationSizer((TOperationSizer *)(a1 + 3), a2);
  return a1;
}

void sub_1D34F0E1C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<TOperationSizer>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB1D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<TOperationSizer>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABB1D0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

void std::__shared_ptr_emplace<TOperationSizer>::__on_zero_shared(uint64_t a1)
{
}

uint64_t ScreenTimeApps(void)
{
  {
    operator new();
  }
  return ScreenTimeApps(void)::sScreenTimeAppNodes;
}

void sub_1D34F0F30(_Unwind_Exception *a1)
{
}

uint64_t TDeviceManagementMonitor::Instance(TDeviceManagementMonitor *this)
{
  {
    operator new();
  }
  return TDeviceManagementMonitor::Instance(void)::monitor;
}

void sub_1D34F0FC0(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v1, 0x80C40B8603338);
  _Unwind_Resume(a1);
}

void TDeviceManagementMonitor::TDeviceManagementMonitor(TDeviceManagementMonitor *this)
{
  *(void *)this = 0;
  id v2 = objc_alloc((Class)getDMFApplicationPolicyMonitorClass());
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3321888768;
  v5[2] = ___ZN24TDeviceManagementMonitorC2Ev_block_invoke;
  uint64_t v5[3] = &__block_descriptor_33_ea8_32c42_ZTSKZN24TDeviceManagementMonitorC1EvE3__0_e5_v8__0l;
  uint64_t v3 = [v2 initWithPolicyChangeHandler:v5];
  uint64_t v4 = *(void **)this;
  *(void *)this = v3;
}

void sub_1D34F1090(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN24TDeviceManagementMonitorC2Ev_block_invoke()
{
}

void TDeviceManagementMonitor::AddNode(TDeviceManagementMonitor *this, TNode *a2)
{
  DeviceManagementLock();
  os_unfair_lock_lock((os_unfair_lock_t)&DeviceManagementLock(void)::sDeviceManagementLock);
  uint64_t v3 = (uint64_t **)ScreenTimeApps();
  TNodePtr::TNodePtr(&v4, a2);
  std::__tree<TNodePtr>::__emplace_unique_key_args<TNodePtr,TNodePtr>(v3, &v4.fFINode, (id *)&v4.fFINode);

  os_unfair_lock_unlock((os_unfair_lock_t)&DeviceManagementLock(void)::sDeviceManagementLock);
}

void sub_1D34F1128(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&DeviceManagementLock(void)::sDeviceManagementLock);
  _Unwind_Resume(a1);
}

void DeviceManagementLock(void)
{
  {
    DeviceManagementLock(void)::sDeviceManagementLock = 0;
  }
}

void TDeviceManagementMonitor::RegisterApp(TNode *this, TNode *a2)
{
  uint64_t v3 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v3);
  uint64_t v5 = *((void *)this + 2);
  TNodePtr v4 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v3);
    int v6 = *(unsigned __int8 *)(v5 + 112);
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  else
  {
    os_unfair_lock_unlock(v3);
    int v6 = *(unsigned __int8 *)(v5 + 112);
  }
  if (v6 != 7)
  {
    uint64_t v8 = (TDeviceManagementMonitor *)TDeviceManagementMonitor::Instance(v7);
    TDeviceManagementMonitor::AddNode(v8, this);
  }
}

void TDeviceManagementMonitor::RemoveNode(TDeviceManagementMonitor *this, TNode *a2)
{
  DeviceManagementLock();
  os_unfair_lock_lock((os_unfair_lock_t)&DeviceManagementLock(void)::sDeviceManagementLock);
  uint64_t v3 = (uint64_t **)ScreenTimeApps();
  TNodePtr::TNodePtr(&v4, a2);
  std::__tree<TNodePtr>::__erase_unique<TNodePtr>(v3, &v4.fFINode);

  os_unfair_lock_unlock((os_unfair_lock_t)&DeviceManagementLock(void)::sDeviceManagementLock);
}

void sub_1D34F12B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&DeviceManagementLock(void)::sDeviceManagementLock);
  _Unwind_Resume(a1);
}

void TDeviceManagementMonitor::UnRegisterApp(TNode *this, TNode *a2)
{
  uint64_t v3 = (os_unfair_lock_s *)TNode::InfoLock(this);
  os_unfair_lock_lock(v3);
  uint64_t v5 = *((void *)this + 2);
  TNodePtr v4 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v4)
  {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    os_unfair_lock_unlock(v3);
    int v6 = *(unsigned __int8 *)(v5 + 112);
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  else
  {
    os_unfair_lock_unlock(v3);
    int v6 = *(unsigned __int8 *)(v5 + 112);
  }
  if (v6 != 7)
  {
    uint64_t v8 = (TDeviceManagementMonitor *)TDeviceManagementMonitor::Instance(v7);
    TDeviceManagementMonitor::RemoveNode(v8, this);
  }
}

void ___ZN24TDeviceManagementMonitor19PolicyChangeHandlerEv_block_invoke()
{
  v13[0] = 0;
  v13[1] = 0;
  uint64_t v12 = (uint64_t *)v13;
  DeviceManagementLock();
  os_unfair_lock_lock((os_unfair_lock_t)&DeviceManagementLock(void)::sDeviceManagementLock);
  uint64_t v0 = ScreenTimeApps();
  if (&v12 != (uint64_t **)v0) {
    std::__tree<TNodePtr>::__assign_multi<std::__tree_const_iterator<TNodePtr,std::__tree_node<TNodePtr,void *> *,long>>(&v12, *(id **)v0, (id *)(v0 + 8));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&DeviceManagementLock(void)::sDeviceManagementLock);
  uint64_t v1 = v12;
  if (v12 != (uint64_t *)v13)
  {
    do
    {
      long long v11 = (FINode *)(id)v1[4];
      uint64_t v2 = TNodeFromFINode(v11);
      uint64_t v3 = (os_unfair_lock_s *)TNode::InfoLock((TNode *)v2);
      os_unfair_lock_lock(v3);
      uint64_t v5 = *(TFSInfo **)(v2 + 16);
      TNodePtr v4 = *(std::__shared_weak_count **)(v2 + 24);
      if (v4) {
        atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      os_unfair_lock_unlock(v3);
      uint64_t v6 = TFSInfo::ApplicationDMFPolicy(v5);
      if (v6 != TFSInfo::FetchApplicationDMFPolicy(v5))
      {
        uint64_t v7 = (const TNode *)TNodeFromFINode(v11);
        TNode::SendNotification(v7, 2, (id *)&v11, 1684893817, 0);
      }
      if (v4) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v4);
      }

      uint64_t v8 = (uint64_t *)v1[1];
      if (v8)
      {
        do
        {
          uint64_t v9 = v8;
          uint64_t v8 = (uint64_t *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v9 = (uint64_t *)v1[2];
          BOOL v10 = *v9 == (void)v1;
          uint64_t v1 = v9;
        }
        while (!v10);
      }
      uint64_t v1 = v9;
    }
    while (v9 != (uint64_t *)v13);
  }
  std::__tree<TNodePtr>::destroy((uint64_t)&v12, v13[0]);
}

void sub_1D34F14D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

Class initDMFApplicationPolicyMonitor(void)
{
  if (DeviceManagementLibrary(void)::frameworkLibrary
    || (DeviceManagementLibrary(void)::frameworkLibrary = (uint64_t)dlopen("/System/Library/PrivateFrameworks/DeviceManagement.framework/DeviceManagement", 2)) != 0)
  {
    Class Class = objc_getClass("DMFApplicationPolicyMonitor");
    classDMFApplicationPolicyMonitor = (uint64_t)Class;
    getDMFApplicationPolicyMonitorClass Class = (uint64_t (*)(void))DMFApplicationPolicyMonitorFunction;
  }
  else
  {
    Class Class = (Class)classDMFApplicationPolicyMonitor;
  }
  return Class;
}

id DMFApplicationPolicyMonitorFunction(void)
{
  return (id)classDMFApplicationPolicyMonitor;
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<TNodePtr,void *>>>::operator()[abi:ne180100](uint64_t a1, id *a2)
{
  if (*(unsigned char *)(a1 + 8))
  {
  }
  else if (!a2)
  {
    return;
  }
  operator delete(a2);
}

uint64_t **std::__tree<TNodePtr>::__assign_multi<std::__tree_const_iterator<TNodePtr,std::__tree_node<TNodePtr,void *> *,long>>(uint64_t **result, id *a2, id *a3)
{
  uint64_t v5 = result;
  if (result[2])
  {
    uint64_t v6 = *result;
    uint64_t v7 = result[1];
    void *result = (uint64_t *)(result + 1);
    v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1]) {
      uint64_t v8 = (uint64_t *)v6[1];
    }
    else {
      uint64_t v8 = v6;
    }
    uint64_t v15 = result;
    CFStringRef v16 = v8;
    unint64_t v17 = (FINode **)v8;
    if (v8)
    {
      CFStringRef v16 = std::__tree<TNodePtr>::_DetachedTreeCache::__detach_next((uint64_t)v8);
      if (a2 != a3)
      {
        uint64_t v9 = a2;
        do
        {
          objc_storeStrong((id *)v8 + 4, v9[4]);
          leaf_high = std::__tree<TNodePtr>::__find_leaf_high((uint64_t)v5, &v18, v17 + 4);
          std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__insert_node_at(v5, v18, (uint64_t **)leaf_high, (uint64_t *)v17);
          unint64_t v17 = (FINode **)v16;
          if (v16) {
            CFStringRef v16 = std::__tree<TNodePtr>::_DetachedTreeCache::__detach_next((uint64_t)v16);
          }
          long long v11 = (id *)v9[1];
          if (v11)
          {
            do
            {
              a2 = v11;
              long long v11 = (id *)*v11;
            }
            while (v11);
          }
          else
          {
            do
            {
              a2 = (id *)v9[2];
              BOOL v12 = *a2 == v9;
              uint64_t v9 = a2;
            }
            while (!v12);
          }
          uint64_t v8 = (uint64_t *)v17;
          if (v17) {
            BOOL v12 = a2 == a3;
          }
          else {
            BOOL v12 = 1;
          }
          uint64_t v9 = a2;
        }
        while (!v12);
      }
    }
    id result = (uint64_t **)std::__tree<TNodePtr>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100]((uint64_t)&v15);
  }
  if (a2 != a3)
  {
    do
    {
      id result = (uint64_t **)std::__tree<TNodePtr>::__emplace_multi<TNodePtr const&>(v5, a2 + 4);
      uint64_t v13 = (id *)a2[1];
      if (v13)
      {
        do
        {
          uint64_t v14 = v13;
          uint64_t v13 = (id *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          uint64_t v14 = (id *)a2[2];
          BOOL v12 = *v14 == a2;
          a2 = v14;
        }
        while (!v12);
      }
      a2 = v14;
    }
    while (v14 != a3);
  }
  return result;
}

void sub_1D34F1778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *std::__tree<TNodePtr>::__find_leaf_high(uint64_t a1, void *a2, FINode **a3)
{
  uint64_t v5 = (uint64_t *)(a1 + 8);
  TNodePtr v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v5 = v4;
        unint64_t v7 = TNodeFromFINode(*a3);
        if (v7 >= TNodeFromFINode((FINode *)v5[4])) {
          break;
        }
        TNodePtr v4 = (uint64_t *)*v5;
        id result = v5;
        if (!*v5) {
          goto LABEL_8;
        }
      }
      TNodePtr v4 = (uint64_t *)v5[1];
    }
    while (v4);
    id result = v5 + 1;
  }
  else
  {
    id result = (uint64_t *)(a1 + 8);
  }
LABEL_8:
  *a2 = v5;
  return result;
}

void *std::__tree<TNodePtr>::_DetachedTreeCache::__detach_next(uint64_t a1)
{
  id result = *(void **)(a1 + 16);
  if (result)
  {
    uint64_t v3 = (void *)*result;
    if (*result == a1)
    {
      void *result = 0;
      while (1)
      {
        TNodePtr v4 = (void *)result[1];
        if (!v4) {
          break;
        }
        do
        {
          id result = v4;
          TNodePtr v4 = (void *)*v4;
        }
        while (v4);
      }
    }
    else
    {
      for (result[1] = 0; v3; uint64_t v3 = (void *)result[1])
      {
        do
        {
          id result = v3;
          uint64_t v3 = (void *)*v3;
        }
        while (v3);
      }
    }
  }
  return result;
}

uint64_t std::__tree<TNodePtr>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100](uint64_t a1)
{
  std::__tree<TNodePtr>::destroy(*(void *)a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    std::__tree<TNodePtr>::destroy(*(void *)a1, v2);
  }
  return a1;
}

void *std::__tree<TNodePtr>::__emplace_multi<TNodePtr const&>(uint64_t **a1, id *a2)
{
  uint64_t v4 = (uint64_t)(a1 + 1);
  uint64_t v5 = operator new(0x28uLL);
  v8[2] = v4;
  *((void *)v5 + 4) = *a2;
  char v9 = 1;
  leaf_high = std::__tree<TNodePtr>::__find_leaf_high((uint64_t)a1, v8, (FINode **)v5 + 4);
  std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__insert_node_at(a1, v8[0], (uint64_t **)leaf_high, (uint64_t *)v5);
  return v5;
}

void sub_1D34F194C(_Unwind_Exception *a1)
{
  std::__tree_node_destructor<std::allocator<std::__tree_node<TNodePtr,void *>>>::operator()[abi:ne180100](v2, v1);
  _Unwind_Resume(a1);
}

void sub_1D34F1A18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34F1AD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34F1BF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34F1F54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28)
{
  _Unwind_Resume(a1);
}

void sub_1D34F2040(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34F210C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char ***std::back_insert_iterator<std::vector<NSObject  {objcproto14FINodeIterator}* {__strong}>>::operator=[abi:ne180100](char ***a1, uint64_t *a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = (*a1)[1];
  uint64_t v6 = *a1;
  unint64_t v9 = (unint64_t)v6[2];
  uint64_t v7 = (uint64_t)(v6 + 2);
  unint64_t v8 = v9;
  if ((unint64_t)v5 >= v9)
  {
    uint64_t v12 = (v5 - *v4) >> 3;
    if ((unint64_t)(v12 + 1) >> 61) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v13 = v8 - (void)*v4;
    uint64_t v14 = v13 >> 2;
    if (v13 >> 2 <= (unint64_t)(v12 + 1)) {
      uint64_t v14 = v12 + 1;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v14;
    }
    uint64_t v29 = v7;
    if (v15) {
      CFStringRef v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v7, v15);
    }
    else {
      CFStringRef v16 = 0;
    }
    unint64_t v17 = &v16[8 * v12];
    uint64_t v18 = &v16[8 * v15];
    uint64_t v28 = v18;
    uint64_t v19 = *a2;
    *a2 = 0;
    *(void *)unint64_t v17 = v19;
    long long v11 = v17 + 8;
    unint64_t v27 = v17 + 8;
    size_t v21 = *v4;
    unsigned int v20 = v4[1];
    if (v20 == *v4)
    {
      long long v23 = v4[1];
    }
    else
    {
      do
      {
        uint64_t v22 = *((void *)v20 - 1);
        v20 -= 8;
        *(void *)unsigned int v20 = 0;
        *((void *)v17 - 1) = v22;
        v17 -= 8;
      }
      while (v20 != v21);
      long long v23 = *v4;
      unsigned int v20 = v4[1];
      long long v11 = v27;
      uint64_t v18 = v28;
    }
    void *v4 = v17;
    v26[0] = v23;
    v26[1] = v23;
    v4[1] = v11;
    unint64_t v27 = v20;
    unsigned int v24 = v4[2];
    v4[2] = v18;
    uint64_t v28 = v24;
    std::__split_buffer<TNodePtr>::~__split_buffer((uint64_t)v26);
  }
  else
  {
    uint64_t v10 = *a2;
    *a2 = 0;
    *(void *)uint64_t v5 = v10;
    long long v11 = v5 + 8;
  }
  v4[1] = v11;
  return a1;
}

uint64_t TPathName::AsOldStyleFullPath(TPathName *this, const TString *a2, TString *a3)
{
  return 0;
}

uint64_t TPathName::FullPath(TPathName *this, const TString *a2, TString *a3, const __CFString *a4)
{
  v20.fString.int fRef = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  unint64_t v8 = *((void *)this + 4);
  uint64_t v9 = *((void *)this + 1);
  uint64_t v10 = (void *)(v9 + 8 * (v8 >> 9));
  if (*((void *)this + 2) == v9)
  {
    if (a4 != 58) {
      goto LABEL_24;
    }
    long long v11 = 0;
    uint64_t v12 = 0;
    goto LABEL_10;
  }
  long long v11 = (const TString *)(*v10 + 8 * (*((void *)this + 4) & 0x1FFLL));
  uint64_t v12 = *(void *)(v9 + (((*((void *)this + 5) + v8) >> 6) & 0x3FFFFFFFFFFFFF8))
      + 8 * ((*((void *)this + 5) + v8) & 0x1FF);
  if (a4 == 58)
  {
    if (v11 != (const TString *)v12)
    {
      TPathName::VolumesDirectory((TString *)&cf1);
      int v13 = CFEqual(cf1, v11->fString.fRef);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
      if (v13)
      {
        if ((const TString *)((char *)++v11 - *v10) == (const TString *)4096)
        {
          uint64_t v14 = (const TString *)v10[1];
          ++v10;
          long long v11 = v14;
        }
        int v15 = 1;
        goto LABEL_14;
      }
    }
LABEL_10:
    if (&v20 != a2) {
      TString::SetStringRefAsImmutable(&v20, (TString *)a2->fString.fRef);
    }
    char v16 = 0;
    int v15 = 1;
    goto LABEL_23;
  }
  int v15 = 0;
LABEL_14:
  char v16 = 1;
LABEL_23:
  while (v11 != (const TString *)v12)
  {
    if ((v16 & 1) == 0) {
      TString::Append(&v20, a4);
    }
    if (v15)
    {
      ColonsToSlashes(v11, (TString *)&cf1);
      TString::Append(&v20, (const TString *)&cf1);
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&cf1);
    }
    else
    {
      TString::Append(&v20, v11);
    }
    if ((const TString *)((char *)++v11 - *v10) == (const TString *)4096)
    {
      unint64_t v17 = (const TString *)v10[1];
      ++v10;
      long long v11 = v17;
    }
    char v16 = 0;
  }
LABEL_24:
  if (&v20 != a3) {
    TString::SetStringRefAsImmutable(a3, (TString *)v20.fString.fRef);
  }
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v20.fString.fRef);
  return 0;
}

void sub_1D34F2500(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

void TNodeRequest::SetTask(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = a2[1];
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 16);
  *(void *)(a1 + 8) = v3;
  *(void *)(a1 + 16) = v2;
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
}

id __copy_helper_block_ea8_32c13_ZTS8TNodePtr40c47_ZTSRKNSt3__110shared_ptrI17TVolumeSyncThreadEE56c38_ZTSRKNSt3__110shared_ptrI9TNodeTaskEE(void *a1, uint64_t a2)
{
  id result = *(id *)(a2 + 32);
  uint64_t v6 = *(void *)(a2 + 40);
  uint64_t v5 = *(void *)(a2 + 48);
  a1[4] = result;
  a1[5] = v6;
  a1[6] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *(void *)(a2 + 64);
  a1[7] = *(void *)(a2 + 56);
  a1[8] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_ea8_32c13_ZTS8TNodePtr40c47_ZTSRKNSt3__110shared_ptrI17TVolumeSyncThreadEE56c38_ZTSRKNSt3__110shared_ptrI9TNodeTaskEE(uint64_t a1)
{
}

id CopyDeep(NSSet *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = CopyDeepCommon(v1, 0);
    uint64_t v4 = (void *)[objc_alloc(MEMORY[0x1E4F1CAD0]) initWithSet:v3];
  }
  else
  {
    uint64_t v4 = 0;
  }

  return v4;
}

void sub_1D34F264C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id CopyDeepCommon(NSSet *a1, BOOL a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  uint64_t v4 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1CA80]), "initWithCapacity:", -[NSSet count](v3, "count"));
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  uint64_t v5 = v3;
  uint64_t v6 = [(NSSet *)v5 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v6)
  {
    uint64_t v7 = *(void *)v12;
    do
    {
      for (uint64_t i = 0; i != v6; ++i)
      {
        if (*(void *)v12 != v7) {
          objc_enumerationMutation(v5);
        }
        uint64_t v9 = CopyDeepHelper(*(NSObject **)(*((void *)&v11 + 1) + 8 * i), a2);
        objc_msgSend(v4, "addObject:", v9, (void)v11);
      }
      uint64_t v6 = [(NSSet *)v5 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }
    while (v6);
  }

  return v4;
}

void sub_1D34F27C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id MutableCopyDeep(NSSet *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = CopyDeepCommon(v1, 1);
  }
  else
  {
    uint64_t v3 = 0;
  }

  return v3;
}

void sub_1D34F2864(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id NewFileCoordinator(void)
{
  uint64_t v0 = objc_opt_new();
  [v0 setPurposeIdentifier:@"com.apple.desktopservices.copyengine"];
  return v0;
}

void sub_1D34F28C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CoordinationRecordingLock(void)
{
  {
    CoordinationRecordingLock(void)::gCoordinationRecordingLock = 0;
  }
}

void TFileCoordinationRecord::TFileCoordinationRecord(TFileCoordinationRecord *this, NSFileCoordinator *a2)
{
  uint64_t v3 = a2;
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = v3;
  *((unsigned char *)this + 36) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_DWORD *)this + 10) = 0;
}

void TFileCoordinationRecord::~TFileCoordinationRecord(TFileCoordinationRecord *this)
{
  uint64_t v2 = *(void *)this;
  if (v2) {
    (*(void (**)(void))(v2 + 16))();
  }
  if (*((unsigned char *)this + 36))
  {
    CoordinationRecordingLock();
    os_unfair_lock_lock((os_unfair_lock_t)&CoordinationRecordingLock(void)::gCoordinationRecordingLock);
    uint64_t v5 = (_DWORD *)((char *)this + 32);
    uint64_t v3 = std::__tree<std::__value_type<int,NSMutableSet * {__strong}>,std::__map_value_compare<int,std::__value_type<int,NSMutableSet * {__strong}>,std::less<int>,true>,std::allocator<std::__value_type<int,NSMutableSet * {__strong}>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t **)gPendingCoordinations, (int *)this + 8, (uint64_t)&std::piecewise_construct, &v5)[5];
    [v3 removeObject:*((void *)this + 3)];
    if (![v3 count]) {
      std::__tree<std::__value_type<int,NSMutableSet * {__strong}>,std::__map_value_compare<int,std::__value_type<int,NSMutableSet * {__strong}>,std::less<int>,true>,std::allocator<std::__value_type<int,NSMutableSet * {__strong}>>>::__erase_unique<int>(gPendingCoordinations, (int *)this + 8);
    }

    os_unfair_lock_unlock((os_unfair_lock_t)&CoordinationRecordingLock(void)::gCoordinationRecordingLock);
  }

  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
}

const void **TFileCoordinationRecord::CoordinateReading@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, TString **a4@<X8>)
{
  uint64_t v9 = *(id **)a2;
  uint64_t v8 = *(void *)(a2 + 8);
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 16);
  *(void *)(a1 + 8) = v9;
  *(void *)(a1 + 16) = v8;
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  long long v14 = (__CFURL *)TFileCoordinationRecord::CopyURLForCoordinatedReading(a1, (id **)a2, a3);
  if (v14 != **(__CFURL ***)a2)
  {
    _ZNSt3__115allocate_sharedB8ne180100I10TCFURLInfoNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(a4);
    if (!TCFURLInfo::Initialize(*a4, v14, 1, 1)) {
      return TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&v14);
    }
    long long v11 = (std::__shared_weak_count *)a4[1];
    if (v11) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v11);
    }
  }
  uint64_t v12 = *(void *)(a2 + 8);
  *a4 = *(TString **)a2;
  a4[1] = (TString *)v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  return TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef((const void **)&v14);
}

void sub_1D34F2B24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  long long v11 = *(std::__shared_weak_count **)(v9 + 8);
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v11);
  }
  TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef(&a9);
  _Unwind_Resume(a1);
}

id TFileCoordinationRecord::CopyURLForCoordinatedReading(uint64_t a1, id **a2, int a3)
{
  id v6 = **a2;
  uint64_t v7 = (void *)[v6 copy];
  id v33 = v7;
  uint64_t v8 = *a2;
  TCFURLInfo::CheckPrefetchState((CFIndex)v8, 1);
  if (((*((unsigned __int16 *)v8 + 38) | (*((unsigned __int8 *)v8 + 78) << 16)) & 0x40000) != 0)
  {
    uint64_t v9 = (void *)_CFURLCopyLogicalURLOfPromiseAtURL();
    TNodePtr v32 = v9;
    if (v9)
    {
      id v10 = v9;

      id v6 = v10;
    }
    if (a3)
    {
      long long v11 = [MEMORY[0x1E4F28CB8] defaultManager];
      uint64_t v12 = [v6 path];
      char v13 = [v11 fileExistsAtPath:v12];

      if (v13)
      {
        id v14 = v7;
        TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef(&v32);
        id v15 = v14;
        goto LABEL_20;
      }
    }
    TAutoRef<__CFURL const*,TRetainReleasePolicy<__CFURL const*>>::~TAutoRef(&v32);
  }
  LOBYTE(v32) = 0;
  if (a3)
  {
    uint64_t v16 = 262145;
    if (objc_opt_respondsToSelector())
    {
      unint64_t v17 = [MEMORY[0x1E4F28CA0] _nextClaimIdentifier];
      uint64_t v18 = dispatch_get_global_queue(0, 0);
      uint64_t v19 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, v18);

      id v20 = *(id *)(a1 + 24);
      handler[0] = MEMORY[0x1E4F143A8];
      handler[1] = 3221225472;
      handler[2] = ___ZN23TFileCoordinationRecord28CopyURLForCoordinatedReadingERKNSt3__110shared_ptrI10TCFURLInfoEEb_block_invoke;
      handler[3] = &unk_1E6990290;
      id v30 = v20;
      id v31 = v17;
      id v21 = v17;
      id v22 = v20;
      dispatch_source_set_event_handler(v19, handler);
      dispatch_time_t v23 = dispatch_time(0, 10000000000);
      dispatch_source_set_timer(v19, v23, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
      dispatch_resume(v19);
    }
    else
    {
      uint64_t v19 = 0;
    }
  }
  else
  {
    uint64_t v19 = 0;
    uint64_t v16 = 1;
  }
  unsigned int v24 = *(void **)(a1 + 24);
  v27[6] = a1;
  id v28 = 0;
  v27[0] = MEMORY[0x1E4F143A8];
  v27[1] = 3321888768;
  v27[2] = ___ZN23TFileCoordinationRecord28CopyURLForCoordinatedReadingERKNSt3__110shared_ptrI10TCFURLInfoEEb_block_invoke_2;
  void v27[3] = &__block_descriptor_56_ea8_32c105_ZTSKZN23TFileCoordinationRecord28CopyURLForCoordinatedReadingERKNSt3__110shared_ptrI10TCFURLInfoEEbE3__0_e24_v24__0__NSURL_8___v___16l;
  v27[4] = &v33;
  v27[5] = &v32;
  [v24 _coordinateReadingItemAtURL:v6 options:v16 error:&v28 byAccessor:v27];
  id v25 = v28;
  if (v19) {
    dispatch_source_cancel(v19);
  }
  if (!(_BYTE)v32)
  {
    if (a3) {
      [v25 code];
    }
    *(_DWORD *)(a1 + 40) = -8095;
  }
  id v15 = v33;

  id v14 = v33;
LABEL_20:

  return v15;
}

void sub_1D34F2E58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN23TFileCoordinationRecord28CopyURLForCoordinatedReadingERKNSt3__110shared_ptrI10TCFURLInfoEEb_block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) _cancelClaimWithIdentifier:*(void *)(a1 + 40)];
}

void ___ZN23TFileCoordinationRecord28CopyURLForCoordinatedReadingERKNSt3__110shared_ptrI10TCFURLInfoEEb_block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v14 = v5;
  id v7 = v6;
  uint64_t v8 = *(void ***)(a1 + 48);
  if (v14)
  {
    uint64_t v9 = [v14 copy];
    id v10 = *(void ***)(a1 + 32);
    long long v11 = *v10;
    std::__shared_weak_count *v10 = (void *)v9;
  }
  uint64_t v12 = [v7 copy];
  char v13 = *v8;
  *uint64_t v8 = (void *)v12;

  **(unsigned char **)(a1 + 40) = 1;
}

void sub_1D34F2F94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

__n128 __copy_helper_block_ea8_32c105_ZTSKZN23TFileCoordinationRecord28CopyURLForCoordinatedReadingERKNSt3__110shared_ptrI10TCFURLInfoEEbE3__0(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[2];
  a1[3].n128_u64[0] = a2[3].n128_u64[0];
  a1[2] = result;
  return result;
}

uint64_t **std::__tree<std::__value_type<int,NSMutableSet * {__strong}>,std::__map_value_compare<int,std::__value_type<int,NSMutableSet * {__strong}>,std::less<int>,true>,std::allocator<std::__value_type<int,NSMutableSet * {__strong}>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  id v7 = a1 + 1;
  id v6 = a1[1];
  if (v6)
  {
    int v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        id v6 = *v9;
        id v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      id v6 = v9[1];
      if (!v6)
      {
        id v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    long long v11 = operator new(0x30uLL);
    v11[8] = **a4;
    *((void *)v11 + 5) = 0;
    std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__insert_node_at(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t std::__tree<std::__value_type<int,NSMutableSet * {__strong}>,std::__map_value_compare<int,std::__value_type<int,NSMutableSet * {__strong}>,std::less<int>,true>,std::allocator<std::__value_type<int,NSMutableSet * {__strong}>>>::__erase_unique<int>(uint64_t a1, int *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  int v3 = *a2;
  uint64_t v4 = a1 + 8;
  do
  {
    int v5 = *(_DWORD *)(v2 + 32);
    BOOL v6 = v5 < v3;
    if (v5 >= v3) {
      id v7 = (uint64_t *)v2;
    }
    else {
      id v7 = (uint64_t *)(v2 + 8);
    }
    if (!v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 8 || v3 < *(_DWORD *)(v4 + 32)) {
    return 0;
  }
  std::__tree<std::__value_type<int,NSMutableSet * {__strong}>,std::__map_value_compare<int,std::__value_type<int,NSMutableSet * {__strong}>,std::less<int>,true>,std::allocator<std::__value_type<int,NSMutableSet * {__strong}>>>::erase((uint64_t **)a1, v4);
  return 1;
}

uint64_t *std::__tree<std::__value_type<int,NSMutableSet * {__strong}>,std::__map_value_compare<int,std::__value_type<int,NSMutableSet * {__strong}>,std::less<int>,true>,std::allocator<std::__value_type<int,NSMutableSet * {__strong}>>>::erase(uint64_t **a1, uint64_t a2)
{
  int v3 = std::__tree<std::__value_type<TString,TProgressInfo>,std::__map_value_compare<TString,std::__value_type<TString,TProgressInfo>,std::less<TString>,true>,std::allocator<std::__value_type<TString,TProgressInfo>>>::__remove_node_pointer(a1, (uint64_t *)a2);

  operator delete((void *)a2);
  return v3;
}

void TFolderSizingThread::SetTimerToDispatchResizeRequest(void *a1, uint64_t *a2, uint64_t a3)
{
  dispatch_source_t v6 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, *(dispatch_queue_t *)(*a1 + 8));
  handler[0] = MEMORY[0x1E4F143A8];
  handler[1] = 3321888768;
  handler[2] = ___ZN19TFolderSizingThread31SetTimerToDispatchResizeRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEEy_block_invoke;
  handler[3] = &__block_descriptor_72_ea8_32c113_ZTSKZN19TFolderSizingThread31SetTimerToDispatchResizeRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEEyE3__0_e5_v8__0l;
  uint64_t v8 = *a1;
  id v7 = (std::__shared_weak_count *)a1[1];
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = v6;
  int v10 = v9;
  uint64_t v11 = *a2;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  void handler[4] = v8;
  unint64_t v17 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v18 = v9;
  uint64_t v19 = v11;
  id v20 = v12;
  if (v12)
  {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    dispatch_source_set_event_handler(v9, handler);
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
  else
  {
    dispatch_source_set_event_handler(v9, handler);
  }
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  uint64_t v14 = TTime::MicrosecondsSinceStartup(v13);
  dispatch_time_t v15 = dispatch_time(0, 1000 * (a3 - v14));
  dispatch_source_set_timer(v10, v15, 0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_resume(v10);
  if (v20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v20);
  }

  if (v17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v17);
  }
}

void sub_1D34F32BC(_Unwind_Exception *a1)
{
  TFSInfoSizer::SizeFolder(std::shared_ptr<TFSInfoSizer>,unsigned long long)::$_0::~$_0(v2);

  _Unwind_Resume(a1);
}

void ___ZN19TFolderSizingThread31SetTimerToDispatchResizeRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEEy_block_invoke(uint64_t a1)
{
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3321888768;
  v3[2] = ___ZZN19TFolderSizingThread31SetTimerToDispatchResizeRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEEyENK3__0clEv_block_invoke;
  v3[3] = &__block_descriptor_48_ea8_32c38_ZTSRKNSt3__110shared_ptrI9TNodeTaskEE_e5_v8__0l;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  v3[4] = *(void *)(a1 + 56);
  uint64_t v4 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  ExceptionSafeBlock(v3);
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 48));
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
}

void sub_1D34F3374(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(exception_object);
}

id __copy_helper_block_ea8_32c113_ZTSKZN19TFolderSizingThread31SetTimerToDispatchResizeRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEEyE3__0(void *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 40);
  a1[4] = *(void *)(a2 + 32);
  a1[5] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  id result = *(id *)(a2 + 48);
  uint64_t v7 = *(void *)(a2 + 56);
  uint64_t v6 = *(void *)(a2 + 64);
  a1[6] = result;
  a1[7] = v7;
  a1[8] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_ea8_32c113_ZTSKZN19TFolderSizingThread31SetTimerToDispatchResizeRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEEyE3__0(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 64);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }

  int v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
}

void TFolderSizingThread::PostFolderSizingTaskRequest(uint64_t a1, uint64_t a2)
{
  id v4 = **(id **)a2;
  int v5 = *(NSObject **)(*(void *)a1 + 8);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3321888768;
  v8[2] = ___ZN19TFolderSizingThread27PostFolderSizingTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEE_block_invoke;
  uint64_t v8[3] = &__block_descriptor_48_ea8_32c108_ZTSKZN19TFolderSizingThread27PostFolderSizingTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEEE3__0_e5_v8__0l;
  uint64_t v6 = *(id **)a2;
  uint64_t v7 = *(std::__shared_weak_count **)(a2 + 8);
  if (v7)
  {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v9 = v6;
    int v10 = v7;
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    dispatch_async(v5, v8);
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  else
  {
    uint64_t v9 = v6;
    int v10 = 0;
    dispatch_async(v5, v8);
  }
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
}

void ___ZN19TFolderSizingThread27PostFolderSizingTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEE_block_invoke(uint64_t a1)
{
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 3321888768;
  v2[2] = ___ZZN19TFolderSizingThread27PostFolderSizingTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEEENK3__0clEv_block_invoke;
  v2[3] = &__block_descriptor_48_ea8_32c38_ZTSRKNSt3__110shared_ptrI9TNodeTaskEE_e5_v8__0l;
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  void v2[4] = *(void *)(a1 + 32);
  int v3 = v1;
  if (v1) {
    atomic_fetch_add_explicit(&v1->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  ExceptionSafeBlock(v2);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
}

void sub_1D34F35B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t __copy_helper_block_ea8_32c108_ZTSKZN19TFolderSizingThread27PostFolderSizingTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEEE3__0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_ea8_32c108_ZTSKZN19TFolderSizingThread27PostFolderSizingTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEEE3__0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

void ___ZZN19TFolderSizingThread31SetTimerToDispatchResizeRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEEyENK3__0clEv_block_invoke(uint64_t a1)
{
}

uint64_t __copy_helper_block_ea8_32c38_ZTSRKNSt3__110shared_ptrI9TNodeTaskEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void ___ZZN19TFolderSizingThread27PostFolderSizingTaskRequestERKNSt3__110shared_ptrIS_EERKNS1_I9TNodeTaskEEENK3__0clEv_block_invoke(uint64_t a1)
{
}

void sub_1D34F3690(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34F3A8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34F3B84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34F3C20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34F3C90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34F3D90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  TNodeEventPtr::~TNodeEventPtr((id *)va);
  _Unwind_Resume(a1);
}

const void **GetDocumentContainerInfo@<X0>(unsigned char *a1@<X8>)
{
  identifier = (const char *)container_get_identifier();
  TString::TString(&v20, identifier);
  int v3 = [MEMORY[0x1E4F223C8] bundleRecordWithApplicationIdentifier:v20.fString.fRef error:0];
  id v4 = [v3 URL];

  if (v4)
  {
    int v5 = [v3 URL];
    uint64_t v6 = [v5 URLByAppendingPathComponent:@"Info.plist" isDirectory:0];
    v18[0] = 0;
    uint64_t v7 = [MEMORY[0x1E4F1C9B8] dataWithContentsOfURL:v6 options:2 error:v18];
    uint64_t v8 = (id)v18[0];
    uint64_t v9 = v8;
    if (v7)
    {
      id v21 = 0;
      int v10 = [MEMORY[0x1E4F28F98] propertyListWithData:v7 options:0 format:0 error:&v21];
      id v11 = v21;

      uint64_t v12 = objc_cast<NSDictionary,objc_object * {__strong}>(v10);

      if (v12)
      {
        id v13 = v12;
        int v14 = 0;
      }
      else
      {
        int v14 = [v11 code];
      }
    }
    else
    {
      int v14 = [v8 code];
      uint64_t v12 = 0;
      id v11 = v9;
    }

    if (!v14)
    {
      dispatch_time_t v15 = [v12 objectForKeyedSubscript:@"NSUbiquitousContainers"];
      uint64_t v16 = objc_cast<NSDictionary,objc_object * {__strong}>(v15);

      LOBYTE(v21) = 0;
      v19[0] = MEMORY[0x1E4F143A8];
      v19[1] = 3321888768;
      v19[2] = ___ZL24GetDocumentContainerInfoP18container_object_s_block_invoke;
      v19[3] = &__block_descriptor_40_ea8_32c59_ZTSKZL24GetDocumentContainerInfoP18container_object_sE3__0_e15_v32__0_8_16_B24l;
      v19[4] = &v21;
      [v16 enumerateKeysAndObjectsUsingBlock:v19];
      std::pair<TString,BOOL>::pair[abi:ne180100]<TString const&,BOOL &,0>((uint64_t)v18, (TString **)&v20, &v21);
      std::pair<TString,BOOL>::pair[abi:ne180100]((uint64_t)a1, (uint64_t)v18);
      a1[16] = 1;
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v18);

      goto LABEL_12;
    }
  }
  *a1 = 0;
  a1[16] = 0;
LABEL_12:

  return TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v20.fString.fRef);
}

void sub_1D34F403C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1D34F40C4()
{
}

BOOL TContainerFetcher::IsVisible(unsigned char *a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (!*a1 || !a1[1])
  {
    if (![v3 count]) {
      goto LABEL_10;
    }
    if (!*a1)
    {
      uint64_t v6 = [v4 objectForKeyedSubscript:*MEMORY[0x1E4F1C648]];
      uint64_t v7 = objc_cast<NSNumber,objc_object * {__strong}>(v6);

      char v8 = [v7 BOOLValue];
      char v9 = v7 ? v8 : 1;

      if (v9)
      {
LABEL_10:
        BOOL v5 = 0;
        goto LABEL_18;
      }
    }
    int v10 = [v4 objectForKeyedSubscript:*MEMORY[0x1E4F1C6E8]];
    objc_cast<NSString,objc_object * {__strong}>(v10);
    id v11 = (TString *)(id)objc_claimAutoreleasedReturnValue();
    CFStringRef theString = &stru_1F2ABD380;
    CFRetain(&stru_1F2ABD380);
    TString::SetStringRefAsImmutable((TString *)&theString, v11);

    CFIndex Length = (TCFURLInfo *)CFStringGetLength(theString);
    if (Length)
    {
      if (!*a1)
      {
        TString::TString(&v15, ".", 1uLL);
        BOOL v5 = !TString::BeginsWith((TString *)&theString, &v15);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v15.fString.fRef);
        goto LABEL_17;
      }
      PropertyStoreName = TCFURLInfo::GetPropertyStoreName(Length);
      if (!CFEqual(theString, (CFTypeRef)*PropertyStoreName))
      {
        BOOL v5 = !operator==((CFTypeRef *)&theString, ".localized");
        goto LABEL_17;
      }
    }
    BOOL v5 = 0;
LABEL_17:
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&theString);
    goto LABEL_18;
  }
  BOOL v5 = 1;
LABEL_18:

  return v5;
}

void sub_1D34F4260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a10);

  _Unwind_Resume(a1);
}

void TContainerFetcher::FetchContainers(TContainerFetcher *this@<X0>, void *a2@<X8>)
{
  v49[1] = *MEMORY[0x1E4F143B8];
  long long v28 = 0uLL;
  uint64_t v29 = 0;
  id v27 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  id v26 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
  uint64_t v3 = *MEMORY[0x1E4F1C628];
  uint64_t v4 = *MEMORY[0x1E4F1C680];
  v36[0] = *MEMORY[0x1E4F1C628];
  v36[1] = v4;
  uint64_t v5 = *MEMORY[0x1E4F1C700];
  v36[2] = *MEMORY[0x1E4F1C610];
  v36[3] = v5;
  uint64_t v6 = [MEMORY[0x1E4F1C978] arrayWithObjects:v36 count:4];
  id v25 = v6;
  if (!*(unsigned char *)this)
  {
    uint64_t v7 = *MEMORY[0x1E4F1C6E8];
    v35[0] = *MEMORY[0x1E4F1C648];
    v35[1] = v7;
    char v8 = [MEMORY[0x1E4F1C978] arrayWithObjects:v35 count:2];
    id v25 = [v6 arrayByAddingObjectsFromArray:v8];
  }
  container_query_create();
  container_query_set_class();
  container_query_set_include_other_owners();
  container_query_set_persona_unique_string();
  container_query_operation_set_flags();
  uint64_t count_results = container_query_count_results();
  if (count_results < 0)
  {
    if (container_query_get_last_error())
    {
      int v10 = (void *)container_error_copy_unlocalized_description();
      if (v10)
      {
        id v11 = LogObj(5);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = v10;
          _os_log_impl(&dword_1D343E000, v11, OS_LOG_TYPE_ERROR, "Container query failed %{public}s", buf, 0xCu);
        }

        free(v10);
      }
    }
    else
    {
      uint64_t v12 = LogObj(5);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 134217984;
        *(void *)&uint8_t buf[4] = count_results;
        _os_log_impl(&dword_1D343E000, v12, OS_LOG_TYPE_ERROR, "Container query failed %ld", buf, 0xCu);
      }
    }
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  else
  {
    container_query_iterate_results_sync();
  }
  container_query_free();
  if ((count_results & 0x8000000000000000) == 0)
  {
    id v23 = v27;
    IDContainerIteratorAdaptor<NSArray<NSURL *>>::NSForwardIterator<NSArray<NSURL *>>::NSForwardIterator((uint64_t)buf, v23);
    IDContainerIteratorAdaptor<NSArray<NSURL *>>::IDContainerIteratorAdaptor((uint64_t)v30, -1, v23);
    while (1)
    {
      if (*(void *)buf == v30[0] && v43 == v30[16])
      {

        *(_OWORD *)a2 = v28;
        a2[2] = v29;
        uint64_t v29 = 0;
        long long v28 = 0uLL;
        break;
      }
      id v13 = *(id *)(v38 + 8 * v42);
      int v14 = [v13 URLByAppendingPathComponent:@"Documents/" isDirectory:1];
      v49[0] = v3;
      TString v15 = [MEMORY[0x1E4F1C978] arrayWithObjects:v49 count:1];
      uint64_t v16 = [v14 resourceValuesForKeys:v15 error:0];
      unint64_t v17 = [v16 objectForKeyedSubscript:v3];

      if (v17)
      {
        id obj = 0;
        *(void *)&long long v44 = v13;
        if (!TNode::GetNodeFromURL((CFURLRef *)&v44, (TNodePtr *)&obj, 0)
          && TNodeFromFINode((FINode *)obj))
        {
          long long v44 = 0uLL;
          v45.fString.int fRef = &stru_1F2ABD380;
          CFRetain(&stru_1F2ABD380);
          uint64_t v46 = &stru_1F2ABD380;
          CFRetain(&stru_1F2ABD380);
          id v47 = 0;
          char v48 = 0;
          objc_storeStrong((id *)&v44, obj);
          TNodePtr::TNodePtr(&v33, 0);
          TNodePtr::operator=((void **)&v44 + 1, (void **)&v33.fFINode);

          id v22 = [v26 objectForKeyedSubscript:v13];
          if ((TString *)v45.fString.fRef != v22) {
            TString::SetStringRefAsImmutable(&v45, v22);
          }

          std::__optional_destruct_base<TAppContainerInfo,false>::__optional_destruct_base[abi:ne180100]<TAppContainerInfo>((uint64_t)v31, (uint64_t)&v44);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v46);
          TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v45.fString.fRef);

          goto LABEL_24;
        }
      }
      uint64_t v18 = LogObj(5);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        uint64_t v19 = [v13 lastPathComponent];
        LODWORD(v44) = 138412290;
        *(void *)((char *)&v44 + 4) = v19;
        _os_log_impl(&dword_1D343E000, v18, OS_LOG_TYPE_ERROR, "Failed to create node for container %@", (uint8_t *)&v44, 0xCu);
      }
      v31[0] = 0;
      char v32 = 0;
LABEL_24:

      if (v32) {
        std::vector<TAppContainerInfo>::push_back[abi:ne180100]((uint64_t *)&v28, (uint64_t)v31);
      }
      std::__optional_destruct_base<TAppContainerInfo,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v31);
      uint64_t v20 = v42;
      if (v42 >= v41 - 1)
      {
        uint64_t v21 = [*(id *)buf countByEnumeratingWithState:&buf[8] objects:v40 count:4];
        uint64_t v20 = -1;
        uint64_t v41 = v21;
        uint64_t v42 = -1;
      }
      if (v40[4] != *v39)
      {
        objc_enumerationMutation(*(id *)buf);
        uint64_t v20 = v42;
      }
      ++v43;
      uint64_t v42 = v20 + 1;
    }
  }

  *(void *)long long buf = &v28;
  std::vector<TAppContainerInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
}

void sub_1D34F493C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,void *a27,void *a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,void **a50)
{
  a50 = (void **)&a29;
  std::vector<TAppContainerInfo>::__destroy_vector::operator()[abi:ne180100](&a50);
  _Unwind_Resume(a1);
}

uint64_t ___ZNK17TContainerFetcher15FetchContainersEv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(unsigned char **)(a1 + 56);
  path = (const char *)container_get_path();
  TString::TString(&v24, path);
  uint64_t v4 = [MEMORY[0x1E4F1CB10] fileURLWithPath:v24.fString.fRef isDirectory:1];
  uint64_t v5 = (void *)MEMORY[0x1E4F1CB10];
  uint64_t v6 = [(__CFString *)v24.fString.fRef stringByAppendingPathComponent:@"Documents"];
  uint64_t v7 = [v5 fileURLWithPath:v6 isDirectory:1];

  char v8 = [v4 resourceValuesForKeys:**(void **)(a1 + 40) error:0];
  if (!v8 || !TContainerFetcher::IsVisible(v2, v8)) {
    goto LABEL_7;
  }
  uint64_t v9 = *MEMORY[0x1E4F1C628];
  int v10 = [v8 objectForKeyedSubscript:*MEMORY[0x1E4F1C628]];
  id v11 = objc_cast<NSNumber,objc_object * {__strong}>(v10);
  if (([v11 BOOLValue] & 1) == 0)
  {
LABEL_6:

LABEL_7:
    goto LABEL_8;
  }
  uint64_t v19 = [v8 objectForKeyedSubscript:*MEMORY[0x1E4F1C680]];
  uint64_t v12 = objc_cast<NSNumber,objc_object * {__strong}>(v19);
  if ([v12 BOOLValue])
  {

    goto LABEL_6;
  }
  uint64_t v18 = [v8 objectForKeyedSubscript:*MEMORY[0x1E4F1C610]];
  int v14 = objc_cast<NSNumber,objc_object * {__strong}>(v18);
  char v17 = [v14 BOOLValue];

  if (v17) {
    goto LABEL_8;
  }
  id v23 = 0;
  int v15 = [v7 getResourceValue:&v23 forKey:v9 error:0];
  id v16 = v23;
  char v8 = v16;
  if (!v15 || ([v16 BOOLValue] & 1) == 0) {
    goto LABEL_7;
  }

  GetDocumentContainerInfo(&v20);
  if (v22)
  {
    if (!v21
      || ([**(id **)(a1 + 48) setObject:v20 forKeyedSubscript:v4],
          [**(id **)(a1 + 32) addObject:v4],
          v22))
    {
      TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&v20);
    }
  }
LABEL_8:

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v24.fString.fRef);
  return 1;
}

void sub_1D34F4D34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v7 = va_arg(va1, const void *);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  if ((_BYTE)v10) {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  }

  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_1D34F4DE4()
{
}

__n128 __copy_helper_block_ea8_32c51_ZTSKZNK17TContainerFetcher15FetchContainersEvE3__1(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 32);
  long long v3 = *(_OWORD *)(a2 + 48);
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v3;
  return result;
}

BOOL TContainerFetcher::DirectoryHasVisibleContent(TContainerFetcher *this, const TNodePtr *a2)
{
  if (!TNodeFromFINode(a2->fFINode)) {
    return 0;
  }
  uint64_t v4 = (TNode *)TNodeFromFINode(a2->fFINode);
  uint64_t v5 = (NSURL *)TNode::CopyURL(v4);
  BOOL HasVisibleContent = TContainerFetcher::DirectoryHasVisibleContent(this, v5);

  return HasVisibleContent;
}

void sub_1D34F4E58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL TContainerFetcher::DirectoryHasVisibleContent(TContainerFetcher *this, NSURL *a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  long long v3 = a2;
  if (v3)
  {
    if (!*((void *)this + 1))
    {
      if (*(unsigned char *)this)
      {
        if (*((unsigned char *)this + 1))
        {
          *((void *)this + 1) = MEMORY[0x1E4F1CBF0];
        }
        else
        {
          uint64_t v26 = *MEMORY[0x1E4F1C6E8];
          uint64_t v21 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v26 count:1];
          char v22 = (void *)*((void *)this + 1);
          *((void *)this + 1) = v21;
        }
      }
      else
      {
        uint64_t v18 = *MEMORY[0x1E4F1C6E8];
        v25[0] = *MEMORY[0x1E4F1C648];
        v25[1] = v18;
        uint64_t v19 = [MEMORY[0x1E4F1C978] arrayWithObjects:v25 count:2];
        uint64_t v20 = (void *)*((void *)this + 1);
        *((void *)this + 1) = v19;
      }
    }
    uint64_t v4 = [MEMORY[0x1E4F28CB8] defaultManager];
    uint64_t v5 = *((void *)this + 1);
    id v23 = 0;
    uint64_t v6 = [v4 contentsOfDirectoryAtURL:v3 includingPropertiesForKeys:v5 options:0 error:&v23];
    id v7 = v23;

    if (!v6)
    {
      char v8 = LogObj(5);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        uint64_t v9 = SanitizedURL(v3);
        *(_DWORD *)long long buf = 138543618;
        *(void *)&uint8_t buf[4] = v9;
        __int16 v28 = 2114;
        *(void *)uint64_t v29 = v7;
        _os_log_impl(&dword_1D343E000, v8, OS_LOG_TYPE_ERROR, "Got Error trying to get content of %{public}@, %{public}@", buf, 0x16u);
      }
    }
    if (*(unsigned char *)this && *((unsigned char *)this + 1))
    {
      BOOL v10 = [v6 count] != 0;
    }
    else
    {
      IDContainerIteratorAdaptor<NSArray<NSURL *>>::NSForwardIterator<NSArray<NSURL *>>::NSForwardIterator((uint64_t)buf, v6);
      IDContainerIteratorAdaptor<NSArray<NSURL *>>::IDContainerIteratorAdaptor((uint64_t)v24, -1, v6);
      while (1)
      {
        uint64_t v11 = *(void **)buf;
        if (*(void *)buf == v24[0] && v34 == v24[16]) {
          break;
        }
        id v12 = *(id *)(*(void *)&v29[2] + 8 * v33);
        id v13 = [v12 resourceValuesForKeys:*((void *)this + 1) error:0];
        BOOL IsVisible = TContainerFetcher::IsVisible(this, v13);

        if (IsVisible)
        {
          BOOL v10 = 1;
          uint64_t v11 = (void *)v24[0];
          goto LABEL_25;
        }
        uint64_t v15 = v33;
        if (v33 >= v32 - 1)
        {
          uint64_t v16 = [*(id *)buf countByEnumeratingWithState:&buf[8] objects:v31 count:4];
          uint64_t v15 = -1;
          uint64_t v32 = v16;
          uint64_t v33 = -1;
        }
        if (v31[4] != *v30)
        {
          objc_enumerationMutation(*(id *)buf);
          uint64_t v15 = v33;
        }
        uint64_t v33 = v15 + 1;
        ++v34;
      }
      BOOL v10 = 0;
LABEL_25:
    }
  }
  else
  {
    BOOL v10 = 0;
  }

  return v10;
}

void sub_1D34F5194(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t TContainerFetcher::FetchContainersAndDocumentsFolders@<X0>(TContainerFetcher *this@<X0>, uint64_t *a2@<X8>)
{
  TContainerFetcher::FetchContainers(this, a2);
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  v8[0] = this;
  while (1)
  {
    if (v4 == v5)
    {
      uint64_t v4 = v5;
      return std::vector<TAppContainerInfo>::erase((uint64_t)a2, v4, a2[1]);
    }
    if (TContainerFetcher::FetchContainersAndDocumentsFolders(void)const::$_0::operator()(v8, v4)) {
      break;
    }
    v4 += 48;
  }
  if (v4 != v5)
  {
    for (uint64_t i = v4 + 48; i != v5; i += 48)
    {
      if ((TContainerFetcher::FetchContainersAndDocumentsFolders(void)const::$_0::operator()(v8, i) & 1) == 0)
      {
        TAppContainerInfo::operator=(v4, i);
        v4 += 48;
      }
    }
  }
  return std::vector<TAppContainerInfo>::erase((uint64_t)a2, v4, a2[1]);
}

void sub_1D34F52C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<TAppContainerInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void VolumeIdentifierForURL(NSURL *a1@<X0>, void *a2@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  long long v3 = a1;
  id v10 = 0;
  uint64_t v4 = *MEMORY[0x1E4F1C820];
  id v9 = 0;
  BOOL v5 = [(NSURL *)v3 getResourceValue:&v10 forKey:v4 error:&v9];
  id v6 = v10;
  id v7 = v9;
  if (v5)
  {
    *a2 = v6;
    a2[1] = 0;
  }
  else
  {
    char v8 = LogObj(7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412546;
      id v12 = v3;
      __int16 v13 = 2112;
      id v14 = v7;
      _os_log_impl(&dword_1D343E000, v8, OS_LOG_TYPE_ERROR, "Failed to get volume identifier for %@: %@", buf, 0x16u);
    }

    *a2 = 0;
    a2[1] = v7;
  }
}

void sub_1D34F5414(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IsEDSWithSeparatePersonaAndVolume(FPAppMetadata *a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  if ([(FPAppMetadata *)v1 isManaged])
  {
    uint64_t v2 = [(FPAppMetadata *)v1 documentsURL];
    VolumeIdentifierForURL(v2, &v8);
    if (*((void *)&v8 + 1)) {
      long long v3 = (void *)v8;
    }
    else {
      long long v3 = 0;
    }
    if (*((void *)&v8 + 1)) {
      uint64_t v4 = 0;
    }
    else {
      uint64_t v4 = (void *)v8;
    }

    if (v4)
    {
      {
        IsEDSWithSeparatePersonaAndVolume(FPAppMetadata *)::homeVolumeIdentifier = IsEDSWithSeparatePersonaAndVolume(FPAppMetadata *)::$_0::operator()();
      }
      if (IsEDSWithSeparatePersonaAndVolume(FPAppMetadata *)::homeVolumeIdentifier)
      {
        uint64_t v5 = objc_msgSend(v4, "isEqual:") ^ 1;
LABEL_17:

        goto LABEL_18;
      }
    }
    else
    {
      id v6 = LogObj(7);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v8) = 138412290;
        *(void *)((char *)&v8 + 4) = v1;
        _os_log_impl(&dword_1D343E000, v6, OS_LOG_TYPE_ERROR, "Could not fetch volume for managed app: %@", (uint8_t *)&v8, 0xCu);
      }
    }
    uint64_t v5 = 0;
    goto LABEL_17;
  }
  uint64_t v5 = 0;
LABEL_18:

  return v5;
}

void sub_1D34F55A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id IsEDSWithSeparatePersonaAndVolume(FPAppMetadata *)::$_0::operator()()
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  id v0 = objc_alloc(MEMORY[0x1E4F1CB10]);
  uint64_t v1 = NSHomeDirectory();
  uint64_t v2 = (NSURL *)[v0 initFileURLWithPath:v1 isDirectory:1];

  VolumeIdentifierForURL(v2, &v7);
  if (*((void *)&v7 + 1)) {
    long long v3 = (void *)v7;
  }
  else {
    long long v3 = 0;
  }
  if (*((void *)&v7 + 1)) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = (void *)v7;
  }

  if (!v4)
  {
    uint64_t v5 = LogObj(7);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v7) = 138412290;
      *(void *)((char *)&v7 + 4) = v2;
      _os_log_impl(&dword_1D343E000, v5, OS_LOG_TYPE_ERROR, "Could not fetch volume for user home: %@", (uint8_t *)&v7, 0xCu);
    }
  }
  return v4;
}

void sub_1D34F570C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void TContainerFetcher::FetchContainersAndDocumentsFolders(TContainerFetcher *a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  id v16 = a2;
  IDContainerIteratorAdaptor<NSArray<FPAppMetadata *>>::NSForwardIterator<NSArray<FPAppMetadata *>>::NSForwardIterator((uint64_t)v20, v16);
  IDContainerIteratorAdaptor<NSArray<FPAppMetadata *>>::IDContainerIteratorAdaptor((uint64_t)v19, -1, v16);
  unint64_t v4 = std::distance[abi:ne180100]<IDContainerIteratorAdaptor<NSArray<FPAppMetadata *>>>((uint64_t)v20, (uint64_t)v19);

  type_traits_extras::CopyAsHelper<std::vector<TAppContainerInfo>>::MakeWithCapacity(v4, (uint64_t)&v17);
  IDContainerIteratorAdaptor<NSArray<FPAppMetadata *>>::NSForwardIterator<NSArray<FPAppMetadata *>>::NSForwardIterator((uint64_t)&obj, v16);
  IDContainerIteratorAdaptor<NSArray<FPAppMetadata *>>::IDContainerIteratorAdaptor((uint64_t)v21, -1, v16);
  while (obj != (id)v21[0] || v27 != v21[16])
  {
    id v5 = *(id *)(v23[1] + 8 * v26);
    if (IsEDSWithSeparatePersonaAndVolume((FPAppMetadata *)v5))
    {
      id v6 = LogObj(7);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf) = 138543362;
        *(void *)((char *)&buf + 4) = v5;
        _os_log_impl(&dword_1D343E000, v6, OS_LOG_TYPE_DEBUG, "Ignoring local app library because EDS does not support Local Storage App Libraries: %{public}@", (uint8_t *)&buf, 0xCu);
      }

      v28[0] = 0;
      char v29 = 0;
    }
    else
    {
      v31.fFINode = 0;
      long long v7 = [v5 documentsURL];
      *(void *)&long long buf = v7;
      BOOL v8 = TNode::GetNodeFromURL((CFURLRef *)&buf, &v31, 0) == 0;

      if (v8)
      {
        uint64_t v9 = TNodeFromFINode(v31.fFINode);
        id v10 = (os_unfair_lock_s *)TNode::ParentLock((TNode *)v9);
        os_unfair_lock_lock(v10);
        TNodePtr::TNodePtr(&v30, *(const TNode **)(v9 + 48));
        os_unfair_lock_unlock(v10);
        *(void *)&long long buf = v30.fFINode;
        *((void *)&buf + 1) = v31.fFINode;
        uint64_t v11 = [v5 bundleID];
        v33.fString.int fRef = &stru_1F2ABD380;
        CFRetain(&stru_1F2ABD380);
        TString::SetStringRefAsImmutable(&v33, v11);

        id v12 = [v5 displayName];
        v34.fString.int fRef = &stru_1F2ABD380;
        CFRetain(&stru_1F2ABD380);
        TString::SetStringRefAsImmutable(&v34, v12);

        id v35 = v5;
        char v36 = 0;

        if (TContainerFetcher::DirectoryHasVisibleContent(a1, &v31)) {
          char v36 = 1;
        }
        std::__optional_destruct_base<TAppContainerInfo,false>::__optional_destruct_base[abi:ne180100]<TAppContainerInfo>((uint64_t)v28, (uint64_t)&buf);

        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v34.fString.fRef);
        TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v33.fString.fRef);
      }
      else
      {
        v28[0] = 0;
        char v29 = 0;
      }
    }
    if (v29) {
      std::vector<TAppContainerInfo>::push_back[abi:ne180100]((uint64_t *)&v17, (uint64_t)v28);
    }
    std::__optional_destruct_base<TAppContainerInfo,false>::~__optional_destruct_base[abi:ne180100]((uint64_t)v28);
    uint64_t v13 = v26;
    if (v26 >= v25 - 1)
    {
      uint64_t v14 = [obj countByEnumeratingWithState:v23 objects:v24 count:4];
      uint64_t v13 = -1;
      uint64_t v25 = v14;
      uint64_t v26 = -1;
    }
    if (v24[4] != *(void *)v23[2])
    {
      objc_enumerationMutation(obj);
      uint64_t v13 = v26;
    }
    ++v27;
    uint64_t v26 = v13 + 1;
  }

  *(_OWORD *)a3 = v17;
  *(void *)(a3 + 16) = v18;
  long long v17 = 0uLL;
  uint64_t v18 = 0;
  id obj = &v17;
  std::vector<TAppContainerInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&obj);
}

void sub_1D34F5B28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  *(void *)(v67 - 216) = &a13;
  std::vector<TAppContainerInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)(v67 - 216));

  _Unwind_Resume(a1);
}

id objc_cast<NSDictionary,objc_object * {__strong}>(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v2 = a1;
  }
  else {
    id v2 = 0;
  }
  return v2;
}

void ___ZL24GetDocumentContainerInfoP18container_object_s_block_invoke(uint64_t a1, uint64_t a2, void *a3, unsigned char *a4)
{
  objc_cast<NSDictionary,objc_object * {__strong}>(a3);
  id v9 = (id)objc_claimAutoreleasedReturnValue();
  id v6 = [v9 objectForKeyedSubscript:@"NSUbiquitousContainerIsDocumentScopePublic"];
  long long v7 = objc_cast<NSNumber,objc_object * {__strong}>(v6);
  int v8 = [v7 BOOLValue];

  if (v8)
  {
    **(unsigned char **)(a1 + 32) = 1;
    *a4 = 1;
  }
}

void sub_1D34F5D74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_32c59_ZTSKZL24GetDocumentContainerInfoP18container_object_sE3__0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32) = *(void *)(a2 + 32);
  return result;
}

uint64_t std::pair<TString,BOOL>::pair[abi:ne180100]<TString const&,BOOL &,0>(uint64_t a1, TString **a2, unsigned char *a3)
{
  *(void *)a1 = &stru_1F2ABD380;
  CFRetain(&stru_1F2ABD380);
  TString::SetStringRefAsImmutable((TString *)a1, *a2);
  *(unsigned char *)(a1 + 8) = *a3;
  return a1;
}

void sub_1D34F5E04(_Unwind_Exception *a1)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(v1);
  _Unwind_Resume(a1);
}

uint64_t std::pair<TString,BOOL>::pair[abi:ne180100](uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(void *)a2 = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)a2, &stru_1F2ABD380);
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  return a1;
}

void TAppContainerInfo::~TAppContainerInfo(TAppContainerInfo *this)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 3);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)this + 2);
}

uint64_t std::__optional_destruct_base<TAppContainerInfo,false>::__optional_destruct_base[abi:ne180100]<TAppContainerInfo>(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = TNodePtr::TNodePtr((void *)a1, (id *)a2);
  TNodePtr::TNodePtr(v4 + 1, (id *)(a2 + 8));
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(a2 + 16), &stru_1F2ABD380);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(a2 + 24), &stru_1F2ABD380);
  uint64_t v5 = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  *(void *)(a1 + 32) = v5;
  *(unsigned char *)(a1 + 40) = *(unsigned char *)(a2 + 40);
  *(unsigned char *)(a1 + 48) = 1;
  return a1;
}

uint64_t std::vector<TAppContainerInfo>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - *a1) >> 4);
    if (v10 + 1 > 0x555555555555555) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 4);
    uint64_t v12 = 2 * v11;
    if (2 * v11 <= v10 + 1) {
      uint64_t v12 = v10 + 1;
    }
    if (v11 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v13 = 0x555555555555555;
    }
    else {
      unint64_t v13 = v12;
    }
    uint64_t v19 = v4;
    if (v13) {
      uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TAppContainerInfo>>(v4, v13);
    }
    else {
      uint64_t v14 = 0;
    }
    uint64_t v15 = v14;
    id v16 = &v14[48 * v10];
    uint64_t v18 = &v14[48 * v13];
    std::construct_at[abi:ne180100]<TAppContainerInfo,TAppContainerInfo,TAppContainerInfo*>((uint64_t)v16, a2);
    long long v17 = v16 + 48;
    std::vector<TAppContainerInfo>::__swap_out_circular_buffer(a1, &v15);
    uint64_t v9 = a1[1];
    uint64_t result = std::__split_buffer<TAppContainerInfo>::~__split_buffer((uint64_t)&v15);
  }
  else
  {
    uint64_t result = std::construct_at[abi:ne180100]<TAppContainerInfo,TAppContainerInfo,TAppContainerInfo*>(*(void *)(v4 - 8), a2);
    uint64_t v9 = v7 + 48;
    a1[1] = v7 + 48;
  }
  a1[1] = v9;
  return result;
}

void sub_1D34F6058(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TAppContainerInfo>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::construct_at[abi:ne180100]<TAppContainerInfo,TAppContainerInfo,TAppContainerInfo*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = TNodePtr::TNodePtr((void *)a1, (id *)a2);
  TNodePtr::TNodePtr(v4 + 1, (id *)(a2 + 8));
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(a2 + 16), &stru_1F2ABD380);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(a2 + 24), &stru_1F2ABD380);
  uint64_t v5 = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  *(void *)(a1 + 32) = v5;
  *(unsigned char *)(a1 + 40) = *(unsigned char *)(a2 + 40);
  return a1;
}

uint64_t *std::vector<TAppContainerInfo>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  long long v3 = result;
  uint64_t v5 = *result;
  uint64_t v4 = result[1];
  uint64_t v6 = a2[1];
  while (v4 != v5)
  {
    v6 -= 48;
    v4 -= 48;
    uint64_t result = (uint64_t *)std::construct_at[abi:ne180100]<TAppContainerInfo,TAppContainerInfo,TAppContainerInfo*>(v6, v4);
  }
  a2[1] = v6;
  uint64_t v7 = *v3;
  *long long v3 = v6;
  a2[1] = v7;
  uint64_t v8 = v3[1];
  v3[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = v3[2];
  v3[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<TAppContainerInfo>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(48 * a2);
}

uint64_t std::__split_buffer<TAppContainerInfo>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 48;
    std::__destroy_at[abi:ne180100]<TAppContainerInfo,0>(i - 48);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__optional_destruct_base<TAppContainerInfo,false>::~__optional_destruct_base[abi:ne180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48))
  {

    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 24));
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)(a1 + 16));
  }
  return a1;
}

uint64_t std::vector<TAppContainerInfo>::erase(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,TAppContainerInfo *,TAppContainerInfo *,TAppContainerInfo *,0>(a3, *(void *)(a1 + 8), a2);
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)(a1 + 8);
    if (v7 != v5)
    {
      do
      {
        v7 -= 48;
        std::__destroy_at[abi:ne180100]<TAppContainerInfo,0>(v7);
      }
      while (v7 != v6);
    }
    *(void *)(a1 + 8) = v6;
  }
  return a2;
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,TAppContainerInfo *,TAppContainerInfo *,TAppContainerInfo *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a1 != a2)
  {
    do
    {
      TAppContainerInfo::operator=(a3, v4);
      v4 += 48;
      a3 += 48;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

uint64_t TAppContainerInfo::operator=(uint64_t a1, uint64_t a2)
{
  TNodePtr::operator=((void **)a1, (void **)a2);
  TNodePtr::operator=((void **)(a1 + 8), (void **)(a2 + 8));
  if (a1 != a2)
  {
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)(a1 + 16), (const void **)(a2 + 16));
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(a2 + 16), &stru_1F2ABD380);
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=<__CFString const*,TRetainReleasePolicy<__CFString const*>>((const void **)(a1 + 24), (const void **)(a2 + 24));
    TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::operator=((CFTypeRef *)(a2 + 24), &stru_1F2ABD380);
  }
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  uint64_t v5 = *(void **)(a1 + 32);
  *(void *)(a1 + 32) = v4;

  *(unsigned char *)(a1 + 40) = *(unsigned char *)(a2 + 40);
  return a1;
}

uint64_t TContainerFetcher::FetchContainersAndDocumentsFolders(void)const::$_0::operator()(TContainerFetcher **a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (TNode *)TNodeFromFINode(*(FINode **)a2);
  TString::TString(&v8, "Documents", 9uLL);
  TNode::FindChild(v4, (TNode *)&v8, 0, 0, &obj);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)&v8.fString.fRef);
  if (TNodeFromFINode((FINode *)obj))
  {
    objc_storeStrong((id *)(a2 + 8), obj);
    BOOL HasVisibleContent = TContainerFetcher::DirectoryHasVisibleContent(v3, (const TNodePtr *)&obj);
    if (HasVisibleContent) {
      *(unsigned char *)(a2 + 40) = 1;
    }
    uint64_t v6 = !HasVisibleContent;
  }
  else
  {
    uint64_t v6 = 1;
  }

  return v6;
}

void sub_1D34F64B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t std::distance[abi:ne180100]<IDContainerIteratorAdaptor<NSArray<FPAppMetadata *>>>(uint64_t a1, uint64_t a2)
{
  IDContainerIteratorAdaptor<NSArray<FPAppMetadata *>>::NSForwardIterator<NSArray<FPAppMetadata *>>::NSForwardIterator((uint64_t)&obj, a1);
  IDContainerIteratorAdaptor<NSArray<FPAppMetadata *>>::NSForwardIterator<NSArray<FPAppMetadata *>>::NSForwardIterator((uint64_t)v7, a2);
  uint64_t v3 = 0;
  while (obj != (id)v7[0] || v13 != v7[16])
  {
    uint64_t v4 = v12;
    if (v12 >= v11 - 1)
    {
      uint64_t v5 = [obj countByEnumeratingWithState:v9 objects:v10 count:4];
      uint64_t v4 = -1;
      uint64_t v11 = v5;
      uint64_t v12 = -1;
    }
    if (v10[4] != *(void *)v9[2])
    {
      objc_enumerationMutation(obj);
      uint64_t v4 = v12;
    }
    uint64_t v12 = v4 + 1;
    ++v13;
    ++v3;
  }

  return v3;
}

void sub_1D34F65C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  _Unwind_Resume(a1);
}

void type_traits_extras::CopyAsHelper<std::vector<TAppContainerInfo>>::MakeWithCapacity(unint64_t a1@<X0>, uint64_t a2@<X8>)
{
  long long v3 = 0uLL;
  uint64_t v4 = 0;
  std::vector<TAppContainerInfo>::reserve((uint64_t *)&v3, a1);
  *(_OWORD *)a2 = v3;
  *(void *)(a2 + 16) = v4;
  uint64_t v4 = 0;
  long long v3 = 0uLL;
  uint64_t v5 = (void **)&v3;
  std::vector<TAppContainerInfo>::__destroy_vector::operator()[abi:ne180100](&v5);
}

void sub_1D34F664C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::vector<TAppContainerInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPAppMetadata *>>::NSForwardIterator<NSArray<FPAppMetadata *>>::NSForwardIterator(uint64_t a1, uint64_t a2)
{
  id v4 = *(id *)a2;
  *(void *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  uint64_t v5 = (void *)(a1 + 112);
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 120) = -1;
  uint64_t v6 = (uint64_t *)(a1 + 120);
  *(void *)(a1 + 128) = -1;
  if (v4 && [v4 count] && (uint64_t v7 = *(void *)(a2 + 128), v7 < objc_msgSend(*(id *)a1, "count")))
  {
    uint64_t v8 = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(void *)(a1 + 112) = v8;
    *(void *)(a1 + 104) = **(void **)(a1 + 24);
    uint64_t *v6 = 0;
    *(void *)(a1 + 128) = 0;
    uint64_t v9 = *(void *)(a2 + 128);
    if (v9 >= v8)
    {
      if (v9 >= 1)
      {
        uint64_t v11 = 0;
        uint64_t v12 = 0;
        do
        {
          if (v11 >= *v5 - 1)
          {
            *uint64_t v5 = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
            uint64_t v11 = -1;
            uint64_t *v6 = -1;
          }
          if (*(void *)(a1 + 104) != **(void **)(a1 + 24))
          {
            objc_enumerationMutation(*(id *)a1);
            uint64_t v11 = *v6;
          }
          uint64_t v13 = *(void *)(a1 + 128) + 1;
          *(void *)(a1 + 120) = ++v11;
          *(void *)(a1 + 128) = v13;
          ++v12;
        }
        while (*(void *)(a2 + 128) > v12);
      }
    }
    else
    {
      *(void *)(a1 + 120) = *(void *)(a2 + 120);
      *(void *)(a1 + 128) = v9;
    }
  }
  else
  {
    *(_OWORD *)uint64_t v6 = *(_OWORD *)(a2 + 120);
  }
  return a1;
}

void sub_1D34F67D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPAppMetadata *>>::NSForwardIterator<NSArray<FPAppMetadata *>>::NSForwardIterator(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 128) = -1;
  if (v3 && [v3 count])
  {
    *(void *)(a1 + 112) = [*(id *)a1 countByEnumeratingWithState:a1 + 8 objects:a1 + 72 count:4];
    *(void *)(a1 + 104) = **(void **)(a1 + 24);
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
  }
  else
  {
    *(void *)(a1 + 128) = 0;
  }

  return a1;
}

void sub_1D34F6898(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IDContainerIteratorAdaptor<NSArray<FPAppMetadata *>>::IDContainerIteratorAdaptor(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  *(void *)a1 = v4;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 120) = -1;
  *(void *)(a1 + 128) = -1;
  *(void *)(a1 + 128) = [v4 count];

  return a1;
}

void sub_1D34F6918(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::vector<TAppContainerInfo>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 4) < a2)
  {
    if (a2 >= 0x555555555555556) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<TAppContainerInfo>>(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 48 * v6;
    std::vector<TAppContainerInfo>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<TAppContainerInfo>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_1D34F69D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<TAppContainerInfo>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1D34F6A50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1D34F6BDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, id a10)
{
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef(&a9);
  _Unwind_Resume(a1);
}

void sub_1D34F6CE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34F6DC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34F7064(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, void *a5, ...)
{
  va_start(va, a5);
  +[FIDSNode_FPv2 makeWithCoder:]::$_0::~$_0(a4);
  +[FIDSNode_FPv2 makeWithCoder:]::$_0::~$_0((uint64_t)va);
  std::__shared_weak_count::__release_shared[abi:ne180100](v7);

  _Unwind_Resume(a1);
}

void sub_1D34F720C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id __copy_helper_block_ea8_32c44_ZTSKZ31__FIDSNode_FPv2_makeWithCoder__E3__0(void *a1, uint64_t a2)
{
  id v4 = *(id *)(a2 + 32);
  uint64_t v6 = *(void *)(a2 + 40);
  uint64_t v5 = *(void *)(a2 + 48);
  a1[4] = v4;
  a1[5] = v6;
  a1[6] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  a1[7] = *(id *)(a2 + 56);
  id result = *(id *)(a2 + 64);
  a1[8] = result;
  return result;
}

void __destroy_helper_block_ea8_32c44_ZTSKZ31__FIDSNode_FPv2_makeWithCoder__E3__0(uint64_t a1)
{
  id v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  id v3 = *(void **)(a1 + 32);
}

void sub_1D34F73D8(_Unwind_Exception *a1)
{
  id v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1D34F7444(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34F748C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34F76A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34F79AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);

  objc_sync_exit(v13);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);

  _Unwind_Resume(a1);
}

void sub_1D34F7B7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34F7E98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  id v4 = v3;

  TProgressInfo::~TProgressInfo((TProgressInfo *)va);
  _Unwind_Resume(a1);
}

void sub_1D34F8068(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  TProgressInfo::~TProgressInfo((TProgressInfo *)va);
  _Unwind_Resume(a1);
}

void sub_1D34F8194(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1D34F8200(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1D34F82EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, TNodeRequest *a9)
{
}

void sub_1D34F83D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, TNodeRequest *a9)
{
}

void sub_1D34F86F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

id objc_cast<NSData,objc_object * {__strong}>(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v2 = a1;
  }
  else {
    id v2 = 0;
  }
  return v2;
}

void sub_1D34F8980(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

id objc_cast<UTType,NSObject * {__strong}>(void *a1)
{
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v2 = a1;
  }
  else {
    id v2 = 0;
  }
  return v2;
}

void sub_1D34F8B0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  TRef<__CFDictionary const*,TRetainReleasePolicy<__CFDictionary const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1D34F8BF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, TNodeRequest *a9)
{
}

void sub_1D34F8DA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1D34F8FFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1D34F9118(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, TNodeRequest *a9)
{
}

void sub_1D34F921C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  TRef<__CFString const*,TRetainReleasePolicy<__CFString const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1D34F9340(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  TRef<__CFArray const*,TRetainReleasePolicy<__CFArray const*>>::~TRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_1D34F9434(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, TNodeRequest *a9)
{
}

void sub_1D34F95B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1D34F9730(_Unwind_Exception *a1, TPropertyValue *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_1D34F97AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, TNodeRequest *a9)
{
}

void sub_1D34F98A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id a13, void **a14)
{
  a14 = (void **)&a10;
  std::vector<std::pair<TNodePtr,TNodeEventPtr>>::__destroy_vector::operator()[abi:ne180100](&a14);
  TNodeEventPtr::~TNodeEventPtr(&a13);

  _Unwind_Resume(a1);
}

void sub_1D34F9A08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id a15, void **a16)
{
  a16 = (void **)&a10;
  std::vector<TAppContainerInfo>::__destroy_vector::operator()[abi:ne180100](&a16);

  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<FIDSNode_FPv2 * {__strong}>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABD2C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<FIDSNode_FPv2 * {__strong}>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2ABD2C0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

void std::__shared_ptr_emplace<FIDSNode_FPv2 * {__strong}>::__on_zero_shared(uint64_t a1)
{
}

void RedactForPrivacy(uint64_t *a1@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  if (IsRedactionEnabled() && std::string_view::find[abi:ne180100](a1, "%{public}", 9, 0))
  {
    std::string::basic_string[abi:ne180100]<0>(a3, "<private>");
  }
  else if (*(char *)(a2 + 23) < 0)
  {
    uint64_t v6 = *(const std::string::value_type **)a2;
    std::string::size_type v7 = *(void *)(a2 + 8);
    std::string::__init_copy_ctor_external(a3, v6, v7);
  }
  else
  {
    *(_OWORD *)&a3->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    a3->__r_.__value_.__r.__words[2] = *(void *)(a2 + 16);
  }
}

void FormatDetails(long long *a1@<X0>, std::string *a2@<X8>)
{
  memset(&v57, 0, sizeof(v57));
  long long v56 = *a1;
  *((unsigned char *)&__src.__r_.__value_.__s + 23) = 3;
  LODWORD(__src.__r_.__value_.__l.__data_) = 8223525;
  std::string::size_type v4 = *((void *)&v56 + 1);
  id v3 = (const std::string::value_type *)v56;
  if (!*((void *)&v56 + 1)) {
    goto LABEL_53;
  }
  while (2)
  {
    uint64_t v5 = (unsigned __int8 *)&v3[v4];
    uint64_t v6 = v3;
LABEL_3:
    uint64_t v7 = 0;
    while (*(unsigned __int8 *)v6 != __src.__r_.__value_.__s.__data_[v7])
    {
      if (++v7 == 3)
      {
        if (++v6 != (const std::string::value_type *)v5) {
          goto LABEL_3;
        }
        goto LABEL_53;
      }
    }
    if (v6 == (const std::string::value_type *)v5) {
      goto LABEL_53;
    }
    unint64_t v8 = v6 - v3;
    if (v6 - v3 == -1) {
      goto LABEL_53;
    }
    std::string::append(&v57, v3, v6 - v3);
    if (*((void *)&v56 + 1) < v8) {
      std::__throw_out_of_range[abi:ne180100]("string_view::substr");
    }
    *(void *)&long long v56 = v56 + v8;
    *((void *)&v56 + 1) -= v8;
    ParseFormat(&v56, (uint64_t)&__src);
    size_t size = __src.__r_.__value_.__l.__size_;
    if (__src.__r_.__value_.__l.__size_)
    {
      if (LODWORD(__src.__r_.__value_.__r.__words[2]) == 7)
      {
        DeEscapeFormatFragment((uint64_t)&__src, &__p);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v11 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v11 = __p.__r_.__value_.__l.__size_;
        }
        std::string::append(&v57, (const std::string::value_type *)p_p, v11);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          uint64_t v12 = (void *)__p.__r_.__value_.__r.__words[0];
LABEL_50:
          operator delete(v12);
        }
      }
      else
      {
        v52.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x20uLL);
        *(_OWORD *)&v52.__r_.__value_.__r.__words[1] = xmmword_1D350D010;
        strcpy(v52.__r_.__value_.__l.__data_, "(extra format specifier '");
        if (size > 0x7FFFFFFFFFFFFFF7) {
          std::string::__throw_length_error[abi:ne180100]();
        }
        uint64_t v13 = (const void *)__src.__r_.__value_.__r.__words[0];
        if (size >= 0x17)
        {
          uint64_t v15 = (size & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((size | 7) != 0x17) {
            uint64_t v15 = size | 7;
          }
          uint64_t v16 = v15 + 1;
          p_dst = (void **)operator new(v15 + 1);
          size_t v50 = size;
          int64_t v51 = v16 | 0x8000000000000000;
          std::string __dst = p_dst;
        }
        else
        {
          HIBYTE(v51) = size;
          p_dst = (void **)&__dst;
        }
        memmove(p_dst, v13, size);
        *((unsigned char *)p_dst + size) = 0;
        if (v51 >= 0) {
          long long v17 = (const std::string::value_type *)&__dst;
        }
        else {
          long long v17 = (const std::string::value_type *)__dst;
        }
        if (v51 >= 0) {
          std::string::size_type v18 = HIBYTE(v51);
        }
        else {
          std::string::size_type v18 = v50;
        }
        uint64_t v19 = std::string::append(&v52, v17, v18);
        long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
        v53.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v20;
        v19->__r_.__value_.__l.__size_ = 0;
        v19->__r_.__value_.__r.__words[2] = 0;
        v19->__r_.__value_.__r.__words[0] = 0;
        char v48 = 2;
        strcpy(__s, "')");
        uint64_t v21 = std::string::append(&v53, __s, 2uLL);
        long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v22;
        v21->__r_.__value_.__l.__size_ = 0;
        v21->__r_.__value_.__r.__words[2] = 0;
        v21->__r_.__value_.__r.__words[0] = 0;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          id v23 = &__p;
        }
        else {
          id v23 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v24 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v24 = __p.__r_.__value_.__l.__size_;
        }
        std::string::append(&v57, (const std::string::value_type *)v23, v24);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if (v48 < 0) {
          operator delete(*(void **)__s);
        }
        if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v53.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v51) < 0) {
          operator delete(__dst);
        }
        if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
        {
          uint64_t v12 = (void *)v52.__r_.__value_.__r.__words[0];
          goto LABEL_50;
        }
      }
      uint64_t v25 = *((void *)&v56 + 1);
      if (*((void *)&v56 + 1) < __src.__r_.__value_.__l.__size_) {
        std::__throw_out_of_range[abi:ne180100]("string_view::substr");
      }
      id v3 = (const std::string::value_type *)(v56 + __src.__r_.__value_.__l.__size_);
      *((unsigned char *)&__src.__r_.__value_.__s + 23) = 3;
      LODWORD(__src.__r_.__value_.__l.__data_) = 8223525;
      std::string::size_type v4 = *((void *)&v56 + 1) - __src.__r_.__value_.__l.__size_;
      *(void *)&long long v56 = v56 + __src.__r_.__value_.__l.__size_;
      *((void *)&v56 + 1) -= __src.__r_.__value_.__l.__size_;
      if (v25 != __src.__r_.__value_.__l.__size_) {
        continue;
      }
LABEL_53:
      if (v4 > 0x7FFFFFFFFFFFFFF7) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      if (v4 >= 0x17)
      {
        uint64_t v27 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v4 | 7) != 0x17) {
          uint64_t v27 = v4 | 7;
        }
        uint64_t v28 = v27 + 1;
        p_src = (std::string *)operator new(v27 + 1);
        __src.__r_.__value_.__l.__size_ = v4;
        __src.__r_.__value_.__r.__words[2] = v28 | 0x8000000000000000;
        __src.__r_.__value_.__r.__words[0] = (std::string::size_type)p_src;
      }
      else
      {
        *((unsigned char *)&__src.__r_.__value_.__s + 23) = v4;
        p_src = &__src;
        if (!v4)
        {
LABEL_61:
          p_src->__r_.__value_.__s.__data_[v4] = 0;
          if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            char v29 = &v57;
          }
          else {
            char v29 = (std::string *)v57.__r_.__value_.__r.__words[0];
          }
          if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v30 = HIBYTE(v57.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v30 = v57.__r_.__value_.__l.__size_;
          }
          TNodePtr v31 = std::string::insert(&__src, 0, (const std::string::value_type *)v29, v30);
          *a2 = *v31;
          v31->__r_.__value_.__l.__size_ = 0;
          v31->__r_.__value_.__r.__words[2] = 0;
          v31->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0)
          {
            uint64_t v32 = (void *)__src.__r_.__value_.__r.__words[0];
LABEL_69:
            operator delete(v32);
          }
          goto LABEL_70;
        }
      }
      memmove(p_src, v3, v4);
      goto LABEL_61;
    }
    break;
  }
  v52.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x28uLL);
  *(_OWORD *)&v52.__r_.__value_.__r.__words[1] = xmmword_1D350D020;
  strcpy(v52.__r_.__value_.__l.__data_, "(invalid & extra format specifier: '");
  if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    TString v33 = &v57;
  }
  else {
    TString v33 = (std::string *)v57.__r_.__value_.__r.__words[0];
  }
  if ((v57.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v34 = HIBYTE(v57.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v34 = v57.__r_.__value_.__l.__size_;
  }
  id v35 = std::string::insert(&v52, 0, (const std::string::value_type *)v33, v34);
  long long v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  v53.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v36;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  size_t v37 = *((void *)&v56 + 1);
  if (*((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint64_t v38 = (const void *)v56;
  if (*((void *)&v56 + 1) >= 0x17uLL)
  {
    uint64_t v40 = (*((void *)&v56 + 1) & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((*((void *)&v56 + 1) | 7) != 0x17) {
      uint64_t v40 = *((void *)&v56 + 1) | 7;
    }
    uint64_t v41 = v40 + 1;
    __int16 v39 = (void **)operator new(v40 + 1);
    size_t v50 = v37;
    int64_t v51 = v41 | 0x8000000000000000;
    std::string __dst = v39;
    goto LABEL_86;
  }
  HIBYTE(v51) = BYTE8(v56);
  __int16 v39 = (void **)&__dst;
  if (*((void *)&v56 + 1)) {
LABEL_86:
  }
    memmove(v39, v38, v37);
  *((unsigned char *)v39 + v37) = 0;
  if (v51 >= 0) {
    uint64_t v42 = (const std::string::value_type *)&__dst;
  }
  else {
    uint64_t v42 = (const std::string::value_type *)__dst;
  }
  if (v51 >= 0) {
    std::string::size_type v43 = HIBYTE(v51);
  }
  else {
    std::string::size_type v43 = v50;
  }
  long long v44 = std::string::append(&v53, v42, v43);
  long long v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
  __p.__r_.__value_.__r.__words[2] = v44->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v45;
  v44->__r_.__value_.__l.__size_ = 0;
  v44->__r_.__value_.__r.__words[2] = 0;
  v44->__r_.__value_.__r.__words[0] = 0;
  char v48 = 2;
  strcpy(__s, "')");
  uint64_t v46 = std::string::append(&__p, __s, 2uLL);
  *a2 = *v46;
  v46->__r_.__value_.__l.__size_ = 0;
  v46->__r_.__value_.__r.__words[2] = 0;
  v46->__r_.__value_.__r.__words[0] = 0;
  if (v48 < 0) {
    operator delete(*(void **)__s);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v51) < 0) {
    operator delete(__dst);
  }
  if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v53.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
  {
    uint64_t v32 = (void *)v52.__r_.__value_.__r.__words[0];
    goto LABEL_69;
  }
LABEL_70:
  if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v57.__r_.__value_.__l.__data_);
  }
}

void sub_1D34FA15C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,int a45,__int16 a46,char a47,char a48)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (*(char *)(v48 - 89) < 0) {
    operator delete(*(void **)(v48 - 112));
  }
  _Unwind_Resume(exception_object);
}

void ParseFormat(void *a1@<X0>, uint64_t a2@<X8>)
{
  if (std::string_view::starts_with[abi:ne180100](a1, "%s", 2uLL)
    || std::string_view::starts_with[abi:ne180100](a1, "%@", 2uLL))
  {
    *(void *)a2 = *a1;
    *(void *)(a2 + 8) = 2;
    *(_DWORD *)(a2 + 16) = 0;
    return;
  }
  if (std::string_view::starts_with[abi:ne180100](a1, "%x", 2uLL)
    || std::string_view::starts_with[abi:ne180100](a1, "%p", 2uLL))
  {
    *(void *)a2 = *a1;
    *(void *)(a2 + 8) = 2;
    int v4 = 4;
LABEL_7:
    *(_DWORD *)(a2 + 16) = v4;
    return;
  }
  if (std::string_view::starts_with[abi:ne180100](a1, "%d", 2uLL))
  {
    *(void *)a2 = *a1;
    *(void *)(a2 + 8) = 2;
    *(_DWORD *)(a2 + 16) = 2;
    return;
  }
  if (std::string_view::starts_with[abi:ne180100](a1, "%f", 2uLL))
  {
    *(void *)a2 = *a1;
    *(void *)(a2 + 8) = 2;
    int v4 = 1;
    goto LABEL_7;
  }
  if (std::string_view::starts_with[abi:ne180100](a1, "%-@", 3uLL))
  {
    *(void *)a2 = *a1;
    *(void *)(a2 + 8) = 3;
LABEL_20:
    int v4 = 5;
    goto LABEL_7;
  }
  if (std::string_view::starts_with[abi:ne180100](a1, "%{public}-@", 0xBuLL))
  {
    uint64_t v5 = 11;
    *(void *)a2 = "%{public}-@";
LABEL_19:
    *(void *)(a2 + 8) = v5;
    goto LABEL_20;
  }
  if (std::string_view::starts_with[abi:ne180100](a1, "%{private}-@", 0xCuLL))
  {
    uint64_t v5 = 12;
    *(void *)a2 = "%{private}-@";
    goto LABEL_19;
  }
  if (std::string_view::starts_with[abi:ne180100](a1, "%l@", 3uLL))
  {
    uint64_t v6 = 3;
    *(void *)a2 = "%-@";
LABEL_27:
    *(void *)(a2 + 8) = v6;
    int v4 = 6;
    goto LABEL_7;
  }
  if (std::string_view::starts_with[abi:ne180100](a1, "%{public}l@", 0xBuLL))
  {
    uint64_t v6 = 11;
    *(void *)a2 = "%{public}-@";
    goto LABEL_27;
  }
  if (std::string_view::starts_with[abi:ne180100](a1, "%{private}l@", 0xCuLL))
  {
    uint64_t v6 = 12;
    *(void *)a2 = "%{private}-@";
    goto LABEL_27;
  }
  if (std::string_view::starts_with[abi:ne180100](a1, "%%", 2uLL)
    || std::string_view::starts_with[abi:ne180100](a1, "{{", 2uLL)
    || std::string_view::starts_with[abi:ne180100](a1, "}}", 2uLL))
  {
    *(void *)a2 = *a1;
    *(void *)(a2 + 8) = 2;
    int v4 = 7;
    goto LABEL_7;
  }
  memset(&v38.__prefix_, 0, 17);
  memset(&v38.__suffix_, 0, 17);
  v38.__ready_ = 0;
  v38.__position_start_ = 0;
  memset(&v38, 0, 41);
  {
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((std::regex_traits<char> *)&ParseFormat(std::string_view const&)::extendedFormatPattern, "([{][^{}]*[}])(.|\\n)*", 0);
  }
  if (std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)&ParseFormat(std::string_view const&)::extendedFormatPattern, (char *)*a1, (char *)(*a1 + a1[1]), &v38, 4160))
  {
    if (!v38.__suffix_.matched)
    {
      uint64_t v7 = *a1;
      if (0xAAAAAAAAAAAAAAABLL * (((char *)v38.__matches_.__end_ - (char *)v38.__matches_.__begin_) >> 3) <= 1) {
        p_unmatched = &v38.__unmatched_;
      }
      else {
        p_unmatched = v38.__matches_.__begin_ + 1;
      }
      std::sub_match<char const*>::str[abi:ne180100](p_unmatched, &__p);
      unsigned __int8 v9 = v37;
      if ((char)v37 < 0)
      {
        id v23 = __p;
        uint64_t v24 = v36;
        *(void *)a2 = v7;
        *(void *)(a2 + 8) = v24;
        int v25 = 8;
        goto LABEL_103;
      }
      *(void *)a2 = v7;
      *(void *)(a2 + 8) = v9;
      int v10 = 8;
      goto LABEL_81;
    }
    v38.__matches_.__end_ = v38.__matches_.__begin_;
  }
  {
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((std::regex_traits<char> *)&ParseFormat(std::string_view const&)::hexFormatPattern, "(%([{](public|private)[}])?[+\\- #0]?[0-9]*(hh|h|ll|l|j|z|t)?[xXp])(.|\\n)*", 0);
  }
  if (std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)&ParseFormat(std::string_view const&)::hexFormatPattern, (char *)*a1, (char *)(*a1 + a1[1]), &v38, 4160))
  {
    if (!v38.__suffix_.matched)
    {
      uint64_t v11 = *a1;
      if (0xAAAAAAAAAAAAAAABLL * (((char *)v38.__matches_.__end_ - (char *)v38.__matches_.__begin_) >> 3) <= 1) {
        uint64_t v12 = &v38.__unmatched_;
      }
      else {
        uint64_t v12 = v38.__matches_.__begin_ + 1;
      }
      std::sub_match<char const*>::str[abi:ne180100](v12, &__p);
      unsigned __int8 v13 = v37;
      if ((char)v37 < 0)
      {
        id v23 = __p;
        uint64_t v30 = v36;
        *(void *)a2 = v11;
        *(void *)(a2 + 8) = v30;
        int v25 = 4;
        goto LABEL_103;
      }
      *(void *)a2 = v11;
      *(void *)(a2 + 8) = v13;
      int v10 = 4;
      goto LABEL_81;
    }
    v38.__matches_.__end_ = v38.__matches_.__begin_;
  }
  {
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((std::regex_traits<char> *)&ParseFormat(std::string_view const&)::floatFormatPattern, "(%([{](public|private)[}])?[+\\- #0]?(([0-9]+)|[\\\\*])?(\\.(([0-9]+)|[\\*]))?(hh|h|ll|l|j|z|t|L)?[fFeEgGaA])(.|\\n)*", 0);
  }
  if (std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)&ParseFormat(std::string_view const&)::floatFormatPattern, (char *)*a1, (char *)(*a1 + a1[1]), &v38, 4160))
  {
    if (!v38.__suffix_.matched)
    {
      uint64_t v14 = *a1;
      if (0xAAAAAAAAAAAAAAABLL * (((char *)v38.__matches_.__end_ - (char *)v38.__matches_.__begin_) >> 3) <= 1) {
        uint64_t v15 = &v38.__unmatched_;
      }
      else {
        uint64_t v15 = v38.__matches_.__begin_ + 1;
      }
      std::sub_match<char const*>::str[abi:ne180100](v15, &__p);
      unsigned __int8 v16 = v37;
      if ((char)v37 < 0)
      {
        id v23 = __p;
        uint64_t v31 = v36;
        *(void *)a2 = v14;
        *(void *)(a2 + 8) = v31;
        int v25 = 1;
        goto LABEL_103;
      }
      *(void *)a2 = v14;
      *(void *)(a2 + 8) = v16;
      int v10 = 1;
      goto LABEL_81;
    }
    v38.__matches_.__end_ = v38.__matches_.__begin_;
  }
  {
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((std::regex_traits<char> *)&ParseFormat(std::string_view const&)::integralFormatPattern, "(%([{](public|private)[}])?[+\\- #0]?(([0-9]+)|[\\\\*])?(\\.(([0-9]+)|[\\*]))?(hh|h|ll|l|j|z|t|L)?[diu])(.|\\n)*", 0);
  }
  if (std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)&ParseFormat(std::string_view const&)::integralFormatPattern, (char *)*a1, (char *)(*a1 + a1[1]), &v38, 4160))
  {
    if (v38.__suffix_.matched)
    {
      v38.__matches_.__end_ = v38.__matches_.__begin_;
      goto LABEL_48;
    }
    uint64_t v17 = *a1;
    if (0xAAAAAAAAAAAAAAABLL * (((char *)v38.__matches_.__end_ - (char *)v38.__matches_.__begin_) >> 3) <= 1) {
      std::string::size_type v18 = &v38.__unmatched_;
    }
    else {
      std::string::size_type v18 = v38.__matches_.__begin_ + 1;
    }
    std::sub_match<char const*>::str[abi:ne180100](v18, &__p);
    unsigned __int8 v19 = v37;
    if ((char)v37 < 0)
    {
      id v23 = __p;
      uint64_t v32 = v36;
      *(void *)a2 = v17;
      *(void *)(a2 + 8) = v32;
      int v25 = 2;
      goto LABEL_103;
    }
    *(void *)a2 = v17;
    *(void *)(a2 + 8) = v19;
    int v10 = 2;
LABEL_81:
    *(_DWORD *)(a2 + 16) = v10;
    goto LABEL_105;
  }
LABEL_48:
  {
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((std::regex_traits<char> *)&ParseFormat(std::string_view const&)::altIntegralFormatPattern, "(%([{](public|private)[}])?[+\\- #0]?(([0-9]+)|[\\\\*])?(\\.(([0-9]+)|[\\*]))?(hh|h|ll|l|j|z|t|L)?[oc])(.|\\n)*", 0);
  }
  if (!std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)&ParseFormat(std::string_view const&)::altIntegralFormatPattern, (char *)*a1, (char *)(*a1 + a1[1]), &v38, 4160))goto LABEL_52; {
  if (!v38.__suffix_.matched)
  }
  {
    uint64_t v20 = *a1;
    if (0xAAAAAAAAAAAAAAABLL * (((char *)v38.__matches_.__end_ - (char *)v38.__matches_.__begin_) >> 3) <= 1) {
      uint64_t v21 = &v38.__unmatched_;
    }
    else {
      uint64_t v21 = v38.__matches_.__begin_ + 1;
    }
    std::sub_match<char const*>::str[abi:ne180100](v21, &__p);
    unsigned __int8 v22 = v37;
    if (((char)v37 & 0x80000000) == 0)
    {
      *(void *)a2 = v20;
      *(void *)(a2 + 8) = v22;
      int v10 = 3;
      goto LABEL_81;
    }
    id v23 = __p;
    uint64_t v33 = v36;
    *(void *)a2 = v20;
    *(void *)(a2 + 8) = v33;
    int v25 = 3;
LABEL_103:
    *(_DWORD *)(a2 + 16) = v25;
    goto LABEL_104;
  }
  v38.__matches_.__end_ = v38.__matches_.__begin_;
LABEL_52:
  {
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((std::regex_traits<char> *)&ParseFormat(std::string_view const&)::restrictedStringPattern, "%[0-9]*\\.[0-9]+s", 0);
  }
  if (std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)&ParseFormat(std::string_view const&)::restrictedStringPattern, (char *)*a1, (char *)(*a1 + a1[1]), &v38, 4160))
  {
    if (v38.__suffix_.matched)
    {
      v38.__matches_.__end_ = v38.__matches_.__begin_;
    }
    else
    {
      std::match_results<char const*>::str[abi:ne180100](&v38, 0, &__p);
      if ((v37 & 0x80u) == 0) {
        p_p = (const char *)&__p;
      }
      else {
        p_p = (const char *)__p;
      }
      printf("ASSERT: Invalid format specifier '%s'\n", p_p);
      if ((char)v37 < 0) {
        operator delete(__p);
      }
    }
  }
  {
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((std::regex_traits<char> *)&ParseFormat(std::string_view const&)::formatPattern, "(%([{](public|private)[}])?[+\\- #0]?(([0-9]+)|[\\\\*])?(\\.(([0-9]+)|[\\*]))?(hh|h|ll|l|j|z|t|L)?[diuoxXfFeEgGaAcspn@])(.|\\n)*", 0);
  }
  if (!std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)&ParseFormat(std::string_view const&)::formatPattern, (char *)*a1, (char *)(*a1 + a1[1]), &v38, 4160))goto LABEL_92; {
  if (v38.__suffix_.matched)
  }
  {
    v38.__matches_.__end_ = v38.__matches_.__begin_;
LABEL_92:
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
LABEL_93:
    *(_DWORD *)(a2 + 16) = 0;
    goto LABEL_105;
  }
  uint64_t v27 = *a1;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)v38.__matches_.__end_ - (char *)v38.__matches_.__begin_) >> 3) <= 1) {
    uint64_t v28 = &v38.__unmatched_;
  }
  else {
    uint64_t v28 = v38.__matches_.__begin_ + 1;
  }
  std::sub_match<char const*>::str[abi:ne180100](v28, &__p);
  unsigned __int8 v29 = v37;
  if (((char)v37 & 0x80000000) == 0)
  {
    *(void *)a2 = v27;
    *(void *)(a2 + 8) = v29;
    goto LABEL_93;
  }
  id v23 = __p;
  uint64_t v34 = v36;
  *(void *)a2 = v27;
  *(void *)(a2 + 8) = v34;
  *(_DWORD *)(a2 + 16) = 0;
LABEL_104:
  operator delete(v23);
LABEL_105:
  if (v38.__matches_.__begin_)
  {
    v38.__matches_.__end_ = v38.__matches_.__begin_;
    operator delete(v38.__matches_.__begin_);
  }
}

void sub_1D34FAB0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void DeEscapeFormatFragment(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  size_t v3 = *(void *)(a1 + 8);
  if (v3 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  int v4 = *(const void **)a1;
  if (v3 >= 0x17)
  {
    uint64_t v6 = (v3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v3 | 7) != 0x17) {
      uint64_t v6 = v3 | 7;
    }
    uint64_t v7 = v6 + 1;
    uint64_t v5 = operator new(v6 + 1);
    a2->__r_.__value_.__l.__size_ = v3;
    a2->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    a2->__r_.__value_.__r.__words[0] = (std::string::size_type)v5;
    goto LABEL_8;
  }
  *((unsigned char *)&a2->__r_.__value_.__s + 23) = v3;
  uint64_t v5 = a2;
  if (v3) {
LABEL_8:
  }
    memmove(v5, v4, v3);
  *((unsigned char *)v5 + v3) = 0;
  char v11 = 2;
  strcpy(__s, "%%");
  char v9 = 1;
  LOWORD(__p[0]) = 37;
  ReplaceAll(a2, __s, 2uLL, (const std::string::value_type *)__p, 1uLL);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  if (v11 < 0) {
    operator delete(*(void **)__s);
  }
  char v11 = 2;
  strcpy(__s, "{{");
  char v9 = 1;
  LOWORD(__p[0]) = 123;
  ReplaceAll(a2, __s, 2uLL, (const std::string::value_type *)__p, 1uLL);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  if (v11 < 0) {
    operator delete(*(void **)__s);
  }
  char v11 = 2;
  strcpy(__s, "}}");
  char v9 = 1;
  LOWORD(__p[0]) = 125;
  ReplaceAll(a2, __s, 2uLL, (const std::string::value_type *)__p, 1uLL);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  if (v11 < 0) {
    operator delete(*(void **)__s);
  }
}

void sub_1D34FAD7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (*(char *)(v20 + 23) < 0) {
    operator delete(*(void **)v20);
  }
  _Unwind_Resume(exception_object);
}

BOOL std::string_view::starts_with[abi:ne180100](void *a1, void *__s2, size_t a3)
{
  return a1[1] >= a3 && std::string_view::compare[abi:ne180100](a1, 0, a3, __s2, a3) == 0;
}

void *std::sub_match<char const*>::str[abi:ne180100]@<X0>(void *result@<X0>, void *a2@<X8>)
{
  if (*((unsigned char *)result + 16)) {
    return std::string::__init_with_size[abi:ne180100]<char *,char *>(a2, (char *)*result, (char *)result[1], result[1] - *result);
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return result;
}

void *std::match_results<char const*>::str[abi:ne180100]@<X0>(void *result@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(result[1] - *result) >> 3) <= a2) {
    uint64_t v3 = (uint64_t)(result + 3);
  }
  else {
    uint64_t v3 = *result + 24 * a2;
  }
  if (*(unsigned char *)(v3 + 16)) {
    return std::string::__init_with_size[abi:ne180100]<char *,char *>(a3, *(char **)v3, *(char **)(v3 + 8), *(void *)(v3 + 8) - *(void *)v3);
  }
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  return result;
}

double ReplaceAll(std::string *this, std::string::value_type *__s, std::string::size_type __n, const std::string::value_type *a4, std::string::size_type a5)
{
  if (__n != a5 && SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0 && this->__r_.__value_.__l.__size_ > 0x3E8)
  {
    std::string::size_type v10 = std::string::find(this, __s, 0, __n);
    if (v10 == -1) {
      return result;
    }
    std::string::size_type v12 = v10;
    memset(&v23, 0, sizeof(v23));
    if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = this->__r_.__value_.__l.__size_;
    }
    std::string::reserve(&v23, size);
    std::string::size_type v14 = 0;
    while (1)
    {
      if (v12 != v14)
      {
        std::string::basic_string(&v22, this, v14, v12 - v14, (std::allocator<char> *)&v24);
        uint64_t v15 = (v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? &v22
            : (std::string *)v22.__r_.__value_.__r.__words[0];
        std::string::size_type v16 = (v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? HIBYTE(v22.__r_.__value_.__r.__words[2])
            : v22.__r_.__value_.__l.__size_;
        std::string::append(&v23, (const std::string::value_type *)v15, v16);
        if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
          break;
        }
      }
      if (a5) {
        goto LABEL_18;
      }
LABEL_19:
      std::string::size_type v14 = v12 + __n;
      std::string::size_type v12 = std::string::find(this, __s, v12 + __n, __n);
      if (v12 == -1)
      {
        std::string::size_type v19 = HIBYTE(this->__r_.__value_.__r.__words[2]);
        if ((v19 & 0x80u) != 0) {
          std::string::size_type v19 = this->__r_.__value_.__l.__size_;
        }
        std::string::basic_string(&v22, this, v14, v19 - v14, (std::allocator<char> *)&v24);
        if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v20 = &v22;
        }
        else {
          uint64_t v20 = (std::string *)v22.__r_.__value_.__r.__words[0];
        }
        if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v21 = HIBYTE(v22.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v21 = v22.__r_.__value_.__l.__size_;
        }
        std::string::append(&v23, (const std::string::value_type *)v20, v21);
        if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v22.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0) {
          operator delete(this->__r_.__value_.__l.__data_);
        }
        double result = *(double *)&v23.__r_.__value_.__l.__data_;
        *this = v23;
        return result;
      }
    }
    operator delete(v22.__r_.__value_.__l.__data_);
    if (!a5) {
      goto LABEL_19;
    }
LABEL_18:
    std::string::append(&v23, a4, a5);
    goto LABEL_19;
  }
  std::string::size_type v17 = std::string::find(this, __s, 0, __n);
  if (v17 != -1)
  {
    for (std::string::size_type i = v17; i != -1; std::string::size_type i = std::string::find(this, __s, i + a5, __n))
      std::string::replace(this, i, __n, a4, a5);
  }
  return result;
}

void sub_1D34FB09C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void ExtractEmbeddedFormat(std::string *__str@<X0>, void *a2@<X8>)
{
  std::string::basic_string(&v18, __str, 1uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)v17);
  std::string::size_type size = HIBYTE(v18.__r_.__value_.__r.__words[2]);
  if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v5 = &v18;
  }
  else {
    uint64_t v5 = (std::string *)v18.__r_.__value_.__r.__words[0];
  }
  if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v18.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    uint64_t v6 = (unsigned __int8 *)v5 + size;
    uint64_t v7 = v5;
LABEL_8:
    uint64_t v8 = 0;
    while (v7->__r_.__value_.__s.__data_[0] != asc_1D3522C21[v8])
    {
      if (++v8 == 3)
      {
        uint64_t v7 = (std::string *)((char *)v7 + 1);
        if (v7 != (std::string *)v6) {
          goto LABEL_8;
        }
        uint64_t v7 = (std::string *)v6;
        break;
      }
    }
    int64_t v9 = (char *)v7 - (char *)v5;
    if (v7 == (std::string *)v6) {
      int64_t v10 = 0;
    }
    else {
      int64_t v10 = v9 + 1;
    }
    if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_17;
    }
  }
  else
  {
    int64_t v10 = 0;
    if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
LABEL_17:
    }
      operator delete(v18.__r_.__value_.__l.__data_);
  }
  if ((__str->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v11 = __str;
  }
  else {
    char v11 = (std::string *)__str->__r_.__value_.__r.__words[0];
  }
  v17[0] = (char *)v11 + v10;
  v17[1] = strlen((const char *)v11 + v10);
  ParseFormat(v17, (uint64_t)&v18);
  size_t v12 = v18.__r_.__value_.__l.__size_;
  if (v18.__r_.__value_.__l.__size_ >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  unsigned __int8 v13 = (const void *)v18.__r_.__value_.__r.__words[0];
  if (v18.__r_.__value_.__l.__size_ >= 0x17)
  {
    std::string::size_type v14 = (v18.__r_.__value_.__l.__size_ & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v18.__r_.__value_.__l.__size_ | 7) != 0x17) {
      std::string::size_type v14 = v18.__r_.__value_.__l.__size_ | 7;
    }
    std::string::size_type v15 = v14 + 1;
    std::string::size_type v16 = operator new(v14 + 1);
    a2[1] = v12;
    a2[2] = v15 | 0x8000000000000000;
    *a2 = v16;
    a2 = v16;
  }
  else
  {
    *((unsigned char *)a2 + 23) = v18.__r_.__value_.__s.__data_[8];
    if (!v12) {
      goto LABEL_29;
    }
  }
  memmove(a2, v13, v12);
LABEL_29:
  *((unsigned char *)a2 + v12) = 0;
}

void PrependEachLine(const void **a1@<X0>, const void **a2@<X1>, std::string *a3@<X8>)
{
  std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a2, a1, (uint64_t)a3);
  std::operator+<char>();
  if ((v7 & 0x80u) == 0) {
    int v4 = __p;
  }
  else {
    int v4 = (void **)__p[0];
  }
  if ((v7 & 0x80u) == 0) {
    std::string::size_type v5 = v7;
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  ReplaceAll(a3, "\n", 1uLL, (const std::string::value_type *)v4, v5);
  if ((char)v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1D34FB2E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v15 + 23) < 0) {
    operator delete(*(void **)v15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>@<X0>(const void **a1@<X0>, const void **a2@<X1>, uint64_t a3@<X8>)
{
  if (*((char *)a1 + 23) >= 0) {
    size_t v5 = *((unsigned __int8 *)a1 + 23);
  }
  else {
    size_t v5 = (size_t)a1[1];
  }
  if (*((char *)a2 + 23) >= 0) {
    size_t v6 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v6 = (size_t)a2[1];
  }
  uint64_t result = std::string::basic_string[abi:ne180100](a3, v6 + v5);
  if (*(char *)(result + 23) >= 0) {
    uint64_t v8 = (char *)result;
  }
  else {
    uint64_t v8 = *(char **)result;
  }
  if (v5)
  {
    if (*((char *)a1 + 23) >= 0) {
      int64_t v9 = a1;
    }
    else {
      int64_t v9 = *a1;
    }
    uint64_t result = (uint64_t)memmove(v8, v9, v5);
  }
  int64_t v10 = &v8[v5];
  if (v6)
  {
    if (*((char *)a2 + 23) >= 0) {
      char v11 = a2;
    }
    else {
      char v11 = *a2;
    }
    uint64_t result = (uint64_t)memmove(v10, v11, v6);
  }
  v10[v6] = 0;
  return result;
}

void AppendEachLine(const void **a1@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a1, (const void **)a2, (uint64_t)a3);
  if (*(char *)(a2 + 23) >= 0) {
    size_t v5 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    size_t v5 = *(void *)(a2 + 8);
  }
  size_t v6 = __p;
  std::string::basic_string[abi:ne180100]((uint64_t)__p, v5 + 1);
  if ((v11 & 0x80u) != 0) {
    size_t v6 = (void **)__p[0];
  }
  if (v5)
  {
    if (*(char *)(a2 + 23) >= 0) {
      unsigned __int8 v7 = (const void *)a2;
    }
    else {
      unsigned __int8 v7 = *(const void **)a2;
    }
    memmove(v6, v7, v5);
  }
  *(_WORD *)((char *)v6 + v5) = 10;
  if ((v11 & 0x80u) == 0) {
    uint64_t v8 = __p;
  }
  else {
    uint64_t v8 = (void **)__p[0];
  }
  if ((v11 & 0x80u) == 0) {
    std::string::size_type v9 = v11;
  }
  else {
    std::string::size_type v9 = (std::string::size_type)__p[1];
  }
  ReplaceAll(a3, "\n", 1uLL, (const std::string::value_type *)v8, v9);
  if ((char)v11 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1D34FB4B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v14 + 23) < 0) {
    operator delete(*(void **)v14);
  }
  _Unwind_Resume(exception_object);
}

void ExtendedFormatPrefixAndPostfix(char *a1@<X0>, uint64_t a2@<X8>)
{
  v34[6] = 0;
  v34[7] = 0;
  char v35 = 0;
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  char v38 = 0;
  char v39 = 0;
  memset(v34, 0, 41);
  uint64_t v40 = 0;
  {
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((std::regex_traits<char> *)&ExtendedFormatPrefixAndPostfix(std::string const&)::extendedFormatPattern, "[{]([^{}%]*:)?([^}%]*)[%}](.|\\n)*", 0);
  }
  uint64_t v4 = a1[23];
  if ((v4 & 0x80u) == 0) {
    size_t v5 = a1;
  }
  else {
    size_t v5 = *(char **)a1;
  }
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a1 + 1);
  }
  if (!std::regex_match[abi:ne180100]<std::__wrap_iter<char const*>,std::allocator<std::sub_match<std::__wrap_iter<char const*>>>,char,std::regex_traits<char>>(v5, &v5[v4], (uint64_t)v34, (uint64_t)&ExtendedFormatPrefixAndPostfix(std::string const&)::extendedFormatPattern, 0))
  {
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)a2 = 0u;
    goto LABEL_45;
  }
  size_t v6 = (void **)v34[0];
  unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * (((char *)v34[1] - (char *)v34[0]) >> 3);
  uint64_t v8 = (void **)((char *)v34[0] + 64);
  if (v7 <= 2) {
    uint64_t v8 = &v34[5];
  }
  if (*(unsigned char *)v8)
  {
    BOOL v9 = v7 > 2;
    if (v7 <= 2) {
      int64_t v10 = (char **)&v34[3];
    }
    else {
      int64_t v10 = (char **)((char *)v34[0] + 48);
    }
    unsigned __int8 v11 = (char **)((char *)v34[0] + 56);
    if (!v9) {
      unsigned __int8 v11 = (char **)&v34[4];
    }
    std::string::__init_with_size[abi:ne180100]<char *,char *>(&v32, *v10, *v11, *v11 - *v10);
    size_t v6 = (void **)v34[0];
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * (((char *)v34[1] - (char *)v34[0]) >> 3);
  }
  else
  {
    long long v32 = 0uLL;
    uint64_t v33 = 0;
  }
  size_t v12 = v6 + 6;
  if (v7 <= 2) {
    size_t v12 = &v34[3];
  }
  unsigned __int8 v13 = *v12;
  uint64_t v14 = v6 + 8;
  if (v7 <= 2) {
    uint64_t v14 = &v34[5];
  }
  if (*(unsigned char *)v14)
  {
    uint64_t v15 = v6 + 7;
    if (v7 <= 2) {
      uint64_t v15 = &v34[4];
    }
    std::string::size_type v16 = (char *)((unsigned char *)*v15 - v13);
  }
  else
  {
    std::string::size_type v16 = 0;
  }
  std::string::size_type v17 = &v13[(void)v16 - v40];
  if (a1[23] >= 0) {
    std::string v18 = a1;
  }
  else {
    std::string v18 = *(char **)a1;
  }
  __p.__matches_.__begin_ = (std::vector<std::csub_match>::pointer)&v17[(void)v18];
  __p.__matches_.__end_ = (std::vector<std::csub_match>::pointer)strlen(&v17[(void)v18]);
  ParseFormat(&__p, (uint64_t)v30);
  uint64_t v19 = v31;
  if (v31)
  {
    memset(&__p.__prefix_, 0, 17);
    memset(&__p.__suffix_, 0, 17);
    __p.__ready_ = 0;
    __p.__position_start_ = 0;
    memset(&__p, 0, 41);
    {
      std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((std::regex_traits<char> *)&ExtendedFormatPrefixAndPostfix(std::string const&)::extendedFormatPostfix, "([^}]*)[}](.|\\n)*", 0);
    }
    uint64_t v20 = &v17[v19];
    if (a1[23] >= 0) {
      std::string::size_type v21 = a1;
    }
    else {
      std::string::size_type v21 = *(char **)a1;
    }
    std::string v22 = &v20[(void)v21];
    size_t v23 = strlen(&v20[(void)v21]);
    if (std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)&ExtendedFormatPrefixAndPostfix(std::string const&)::extendedFormatPostfix, v22, &v22[v23], &__p, 4160))
    {
      if (!__p.__suffix_.matched)
      {
        std::vector<std::csub_match>::pointer begin = __p.__matches_.__begin_;
        unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * (((char *)__p.__matches_.__end_ - (char *)__p.__matches_.__begin_) >> 3);
        if (v25 <= 1) {
          std::vector<std::csub_match>::pointer p_p = (std::vector<std::csub_match>::pointer)&__p;
        }
        else {
          std::vector<std::csub_match>::pointer p_p = __p.__matches_.__begin_;
        }
        if (p_p[1].matched)
        {
          if (v25 <= 1) {
            std::vector<std::csub_match>::pointer begin = (std::vector<std::csub_match>::pointer)&__p;
          }
          std::string::__init_with_size[abi:ne180100]<char *,char *>(&v27, (char *)begin[1].first, (char *)begin[1].second, begin[1].second - begin[1].first);
        }
        else
        {
          long long v27 = 0uLL;
          uint64_t v28 = 0;
        }
        std::pair<std::string,std::string>::pair[abi:ne180100]<std::string&,std::string&,0>((std::string *)a2, &v32, &v27);
        if (SHIBYTE(v28) < 0) {
          operator delete((void *)v27);
        }
        goto LABEL_40;
      }
      __p.__matches_.__end_ = __p.__matches_.__begin_;
    }
    std::pair<std::string,std::string>::pair[abi:ne180100]<std::string&,char const(&)[1],0>((std::string *)a2, &v32, "");
LABEL_40:
    if (__p.__matches_.__begin_)
    {
      __p.__matches_.__end_ = __p.__matches_.__begin_;
      operator delete(__p.__matches_.__begin_);
    }
    goto LABEL_43;
  }
  std::pair<std::string,std::string>::pair[abi:ne180100]<std::string&,char const(&)[1],0>((std::string *)a2, &v32, "");
LABEL_43:
  if (SHIBYTE(v33) < 0) {
    operator delete((void *)v32);
  }
LABEL_45:
  if (v34[0])
  {
    v34[1] = v34[0];
    operator delete(v34[0]);
  }
}

void sub_1D34FB874(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (__p) {
    operator delete(__p);
  }
  if (a38 < 0) {
    operator delete(a33);
  }
  uint64_t v40 = *(void **)(v38 - 160);
  if (v40)
  {
    *(void *)(v38 - 152) = v40;
    operator delete(v40);
  }
  _Unwind_Resume(a1);
}

void ExtendedFormatAdaptor(char *a1@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  ExtendedFormatPrefixAndPostfix(a1, (uint64_t)v8);
  unint64_t v5 = v9;
  if ((v9 & 0x80u) != 0) {
    unint64_t v5 = (unint64_t)v8[1];
  }
  if (v5) {
    goto LABEL_7;
  }
  unint64_t v6 = v11;
  if ((v11 & 0x80u) != 0) {
    unint64_t v6 = (unint64_t)v10[1];
  }
  if (v6)
  {
LABEL_7:
    PrependEachLine((const void **)a2, (const void **)v8, &__p);
    AppendEachLine((const void **)&__p.__r_.__value_.__l.__data_, (uint64_t)v10, a3);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  else if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(a3, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&a3->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    a3->__r_.__value_.__r.__words[2] = *(void *)(a2 + 16);
  }
  if ((char)v11 < 0) {
    operator delete(v10[0]);
  }
  if ((char)v9 < 0) {
    operator delete(v8[0]);
  }
}

void sub_1D34FB9F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
}

uint64_t std::pair<std::string,std::string>::~pair(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void WidenHexFormatStringSpecifierToLongLong(char *__s1@<X0>, uint64_t a2@<X8>)
{
  if ((__s1[23] & 0x80000000) == 0)
  {
    uint64_t v4 = __s1;
    if (*(_WORD *)__s1 != 30757) {
      goto LABEL_3;
    }
LABEL_17:
    *(unsigned char *)(a2 + 23) = 4;
    strcpy((char *)a2, "%llx");
    return;
  }
  uint64_t v4 = *(const char **)__s1;
  if (!strncmp(*(const char **)__s1, "%x", 2uLL)) {
    goto LABEL_17;
  }
LABEL_3:
  if (!strncmp(v4, "%p", 2uLL))
  {
    *(unsigned char *)(a2 + 23) = 2;
    strcpy((char *)a2, "%p");
  }
  else
  {
    {
      std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((std::regex_traits<char> *)&WidenHexFormatStringSpecifierToLongLong(std::string const&)::hexFormatPattern, "(%)([+\\- #0]?[0-9]*)(hh|h|ll|l|j|z|t)?([xXp])(.|\\n)*", 0);
    }
    v44[6] = 0;
    v44[7] = 0;
    char v45 = 0;
    uint64_t v46 = 0;
    uint64_t v47 = 0;
    char v48 = 0;
    char v49 = 0;
    uint64_t v50 = 0;
    memset(v44, 0, 41);
    uint64_t v5 = __s1[23];
    if ((v5 & 0x80u) == 0) {
      unint64_t v6 = __s1;
    }
    else {
      unint64_t v6 = *(char **)__s1;
    }
    if ((v5 & 0x80u) != 0) {
      uint64_t v5 = *((void *)__s1 + 1);
    }
    if (std::regex_match[abi:ne180100]<std::__wrap_iter<char const*>,std::allocator<std::sub_match<std::__wrap_iter<char const*>>>,char,std::regex_traits<char>>(v6, &v6[v5], (uint64_t)v44, (uint64_t)&WidenHexFormatStringSpecifierToLongLong(std::string const&)::hexFormatPattern, 0))
    {
      unint64_t v7 = (char *)v44[0];
      unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (((char *)v44[1] - (char *)v44[0]) >> 3);
      if (v8 <= 1) {
        unsigned __int8 v9 = v44;
      }
      else {
        unsigned __int8 v9 = (void **)v44[0];
      }
      if (*((unsigned char *)v9 + 40))
      {
        std::string::__init_with_size[abi:ne180100]<char *,char *>(&v41, (char *)v9[3], (char *)v9[4], (unsigned char *)v9[4] - (unsigned char *)v9[3]);
        unint64_t v7 = (char *)v44[0];
        unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (((char *)v44[1] - (char *)v44[0]) >> 3);
      }
      else
      {
        memset(&v41, 0, sizeof(v41));
      }
      int64_t v10 = (void **)(v7 + 64);
      if (v8 <= 2) {
        int64_t v10 = &v44[5];
      }
      unsigned int v11 = *(unsigned __int8 *)v10;
      if (v11)
      {
        BOOL v12 = v8 > 2;
        if (v8 <= 2) {
          unsigned __int8 v13 = (char **)&v44[3];
        }
        else {
          unsigned __int8 v13 = (char **)(v7 + 48);
        }
        uint64_t v14 = (char **)(v7 + 56);
        if (!v12) {
          uint64_t v14 = (char **)&v44[4];
        }
        std::string::__init_with_size[abi:ne180100]<char *,char *>(&v38, *v13, *v14, *v14 - *v13);
        unsigned int v11 = HIBYTE(v40);
        uint64_t v15 = (void **)v38;
        std::string::size_type v16 = v39;
      }
      else
      {
        std::string::size_type v16 = 0;
        uint64_t v15 = 0;
        uint64_t v38 = 0;
        std::string::size_type v39 = 0;
        uint64_t v40 = 0;
      }
      if ((v11 & 0x80u) == 0) {
        std::string::size_type v17 = &v38;
      }
      else {
        std::string::size_type v17 = v15;
      }
      if ((v11 & 0x80u) == 0) {
        std::string::size_type v18 = v11;
      }
      else {
        std::string::size_type v18 = v16;
      }
      uint64_t v19 = std::string::append(&v41, (const std::string::value_type *)v17, v18);
      long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
      v42.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v20;
      v19->__r_.__value_.__l.__size_ = 0;
      v19->__r_.__value_.__r.__words[2] = 0;
      v19->__r_.__value_.__r.__words[0] = 0;
      std::string::size_type v21 = std::string::append(&v42, "ll", 2uLL);
      long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
      v43.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v22;
      v21->__r_.__value_.__l.__size_ = 0;
      v21->__r_.__value_.__r.__words[2] = 0;
      v21->__r_.__value_.__r.__words[0] = 0;
      unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * (((char *)v44[1] - (char *)v44[0]) >> 3);
      char v24 = (void **)((char *)v44[0] + 112);
      if (v23 <= 4) {
        char v24 = &v44[5];
      }
      unsigned int v25 = *(unsigned __int8 *)v24;
      if (v25)
      {
        BOOL v26 = v23 > 4;
        if (v23 <= 4) {
          long long v27 = (char **)&v44[3];
        }
        else {
          long long v27 = (char **)((char *)v44[0] + 96);
        }
        uint64_t v28 = (char **)((char *)v44[0] + 104);
        if (!v26) {
          uint64_t v28 = (char **)&v44[4];
        }
        std::string::__init_with_size[abi:ne180100]<char *,char *>(&__p, *v27, *v28, *v28 - *v27);
        unsigned int v25 = HIBYTE(v37);
        unsigned __int8 v29 = (void **)__p;
        std::string::size_type v30 = v36;
      }
      else
      {
        std::string::size_type v30 = 0;
        unsigned __int8 v29 = 0;
        std::string __p = 0;
        std::string::size_type v36 = 0;
        uint64_t v37 = 0;
      }
      if ((v25 & 0x80u) == 0) {
        std::vector<std::csub_match>::pointer p_p = &__p;
      }
      else {
        std::vector<std::csub_match>::pointer p_p = v29;
      }
      if ((v25 & 0x80u) == 0) {
        std::string::size_type v32 = v25;
      }
      else {
        std::string::size_type v32 = v30;
      }
      uint64_t v33 = std::string::append(&v43, (const std::string::value_type *)p_p, v32);
      long long v34 = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
      *(void *)(a2 + 16) = *((void *)&v33->__r_.__value_.__l + 2);
      *(_OWORD *)a2 = v34;
      v33->__r_.__value_.__l.__size_ = 0;
      v33->__r_.__value_.__r.__words[2] = 0;
      v33->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v37) < 0) {
        operator delete(__p);
      }
      if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v43.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v42.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v40) < 0) {
        operator delete(v38);
      }
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v41.__r_.__value_.__l.__data_);
      }
    }
    else if (__s1[23] < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)a2, *(const std::string::value_type **)__s1, *((void *)__s1 + 1));
    }
    else
    {
      *(_OWORD *)a2 = *(_OWORD *)__s1;
      *(void *)(a2 + 16) = *((void *)__s1 + 2);
    }
    if (v44[0])
    {
      v44[1] = v44[0];
      operator delete(v44[0]);
    }
  }
}

void sub_1D34FBE38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43)
{
}

void OSTypeAsString(unsigned int a1@<W0>, std::string *a2@<X8>)
{
  uint64_t v3 = 0;
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  unsigned int v6 = bswap32(a1);
  do
  {
    unint64_t v4 = *((unsigned __int8 *)&v6 + v3);
    if (v4 == 37)
    {
      std::string::value_type v5 = 37;
      std::string::push_back(a2, 37);
    }
    else
    {
      std::string::value_type v5 = *((unsigned char *)&v6 + v3);
      if ((char)v4 <= 32)
      {
        std::string::push_back(a2, 37);
        std::string::push_back(a2, OSTypeAsString::digits[v4 >> 4]);
        std::string::value_type v5 = OSTypeAsString::digits[v4 & 0xF];
      }
    }
    std::string::push_back(a2, v5);
    ++v3;
  }
  while (v3 != 4);
}

void sub_1D34FBFA4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::string_view::find[abi:ne180100](uint64_t *a1, char *a2, int64_t a3, unint64_t a4)
{
  unint64_t v4 = a1[1];
  if (v4 < a4) {
    return -1;
  }
  if (a3)
  {
    uint64_t v6 = *a1;
    unint64_t v7 = (void *)(*a1 + a4);
    unint64_t v8 = (char *)(v6 + v4);
    uint64_t v9 = v6 + v4 - (void)v7;
    if (v9 >= a3)
    {
      int v13 = *a2;
      do
      {
        uint64_t v14 = v9 - a3;
        if (v14 == -1) {
          break;
        }
        uint64_t v15 = (char *)memchr(v7, v13, v14 + 1);
        if (!v15) {
          break;
        }
        int64_t v10 = v15;
        if (!memcmp(v15, a2, a3)) {
          goto LABEL_6;
        }
        unint64_t v7 = v10 + 1;
        uint64_t v9 = v8 - (v10 + 1);
      }
      while (v9 >= a3);
    }
    int64_t v10 = v8;
LABEL_6:
    if (v10 == v8) {
      return -1;
    }
    else {
      return (uint64_t)&v10[-v6];
    }
  }
  return a4;
}

uint64_t std::string::basic_string[abi:ne180100](uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (a2 > 0x16)
  {
    uint64_t v4 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17) {
      uint64_t v4 = a2 | 7;
    }
    uint64_t v5 = v4 + 1;
    uint64_t v6 = operator new(v4 + 1);
    *(void *)(a1 + 8) = a2;
    *(void *)(a1 + 16) = v5 | 0x8000000000000000;
    *(void *)a1 = v6;
  }
  else
  {
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    *(unsigned char *)(a1 + 23) = a2;
  }
  return a1;
}

std::string *std::pair<std::string,std::string>::pair[abi:ne180100]<std::string&,char const(&)[1],0>(std::string *this, long long *a2, char *__s)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  std::string::basic_string[abi:ne180100]<0>(this[1].__r_.__value_.__r.__words, __s);
  return this;
}

void sub_1D34FC164(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

std::string *std::pair<std::string,std::string>::pair[abi:ne180100]<std::string&,std::string&,0>(std::string *this, long long *a2, long long *a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  uint64_t v6 = this + 1;
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v7 = *a3;
    this[1].__r_.__value_.__r.__words[2] = *((void *)a3 + 2);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  return this;
}

void sub_1D34FC1FC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100](std::regex_traits<char> *a1, const char *a2, int a3)
{
  long long v5 = std::regex_traits<char>::regex_traits(a1);
  LODWORD(v5[1].__loc_.__locale_) = a3;
  *(_OWORD *)((char *)&v5[1].__loc_.__locale_ + 4) = 0u;
  *(_OWORD *)((char *)&v5[1].__col_ + 4) = 0u;
  HIDWORD(v5[2].__ct_) = 0;
  strlen(a2);
  std::basic_regex<char,std::regex_traits<char>>::__parse<char const*>();
}

void sub_1D34FC290(_Unwind_Exception *a1)
{
  locale = (std::__shared_weak_count *)v1[6].__locale_;
  if (locale) {
    std::__shared_weak_count::__release_shared[abi:ne180100](locale);
  }
  std::locale::~locale(v1);
  _Unwind_Resume(a1);
}

std::regex_traits<char> *__cdecl std::regex_traits<char>::regex_traits(std::regex_traits<char> *this)
{
  id v2 = (const std::locale *)MEMORY[0x1D9436660]();
  this->__ct_ = (const std::ctype<char> *)std::locale::use_facet(v2, MEMORY[0x1E4FBA258]);
  this->__col_ = (const std::collate<char> *)std::locale::use_facet(&this->__loc_, MEMORY[0x1E4FBA280]);
  return this;
}

void sub_1D34FC2FC(_Unwind_Exception *a1)
{
  std::locale::~locale(v1);
  _Unwind_Resume(a1);
}

void std::basic_regex<char,std::regex_traits<char>>::__parse<char const*>()
{
}

void sub_1D34FC4D0(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)17>()
{
  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D9436450](exception, 17);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_1D34FC548(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::shared_ptr<std::__empty_state<char>>::reset[abi:ne180100]<std::__empty_state<char>,void>(uint64_t a1, uint64_t a2)
{
  std::shared_ptr<std::__empty_state<char>>::shared_ptr[abi:ne180100]<std::__empty_state<char>,void>(&v2, a2);
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_ecma_exp<char const*>(std::basic_regex<char> *a1, unsigned __int8 *a2, char *a3)
{
  end = a1->__end_;
  long long v7 = a2;
  do
  {
    unint64_t v8 = v7;
    long long v7 = std::basic_regex<char,std::regex_traits<char>>::__parse_term<char const*>(a1, (char *)v7, a3);
  }
  while (v7 != v8);
  if (v8 == a2) {
    operator new();
  }
  while (v8 != (unsigned __int8 *)a3)
  {
    if (*v8 != 124) {
      return (char *)v8;
    }
    uint64_t v9 = a1->__end_;
    int64_t v10 = v8 + 1;
    unsigned int v11 = v8 + 1;
    do
    {
      unint64_t v8 = v11;
      unsigned int v11 = std::basic_regex<char,std::regex_traits<char>>::__parse_term<char const*>(a1, (char *)v11, a3);
    }
    while (v11 != v8);
    if (v8 == v10) {
      operator new();
    }
    std::basic_regex<char,std::regex_traits<char>>::__push_alternation(a1, end, v9);
  }
  return a3;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_basic_reg_exp<char const*>(std::basic_regex<char> *this, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t v3 = a2;
  if (a2 == a3) {
    return (char *)a2;
  }
  uint64_t v4 = (char *)a3;
  if (*a2 == 94)
  {
    std::basic_regex<char,std::regex_traits<char>>::__push_l_anchor(this);
    ++v3;
  }
  if (v3 != (unsigned __int8 *)v4)
  {
    do
    {
      uint64_t v6 = v3;
      uint64_t v3 = std::basic_regex<char,std::regex_traits<char>>::__parse_simple_RE<char const*>(this, (char *)v3, v4);
    }
    while (v3 != v6);
    if (v6 != (unsigned __int8 *)v4)
    {
      if (v6 + 1 != (unsigned __int8 *)v4 || *v6 != 36) {
        std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)15>();
      }
      std::basic_regex<char,std::regex_traits<char>>::__push_r_anchor(this);
    }
  }
  return v4;
}

std::basic_regex<char> *std::basic_regex<char,std::regex_traits<char>>::__parse_extended_reg_exp<char const*>(std::basic_regex<char> *a1, std::basic_regex<char> *a2, std::basic_regex<char> *a3)
{
  uint64_t v3 = a3;
  end = a1->__end_;
  long long v7 = std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_branch<char const*>(a1, a2, a3);
  if (v7 == (unsigned __int8 *)a2) {
LABEL_9:
  }
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)15>();
  unint64_t v8 = v7;
  while (v8 != (unsigned __int8 *)v3)
  {
    if (*v8 != 124) {
      return (std::basic_regex<char> *)v8;
    }
    uint64_t v9 = a1->__end_;
    int64_t v10 = std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_branch<char const*>(a1, (std::basic_regex<char> *)(v8 + 1), v3);
    if (v10 == v8 + 1) {
      goto LABEL_9;
    }
    unint64_t v8 = v10;
    std::basic_regex<char,std::regex_traits<char>>::__push_alternation(a1, end, v9);
  }
  return v3;
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_grep<char const*>(std::basic_regex<char> *a1, unsigned __int8 *__s, unsigned __int8 *a3)
{
  end = a1->__end_;
  long long v7 = (unsigned __int8 *)memchr(__s, 10, a3 - __s);
  if (v7) {
    unint64_t v8 = v7;
  }
  else {
    unint64_t v8 = a3;
  }
  if (v8 == __s) {
    operator new();
  }
  std::basic_regex<char,std::regex_traits<char>>::__parse_basic_reg_exp<char const*>(a1, __s, v8);
  while (1)
  {
    unsigned int v11 = v8 == a3 ? v8 : v8 + 1;
    if (v11 == a3) {
      break;
    }
    uint64_t v9 = (unsigned __int8 *)memchr(v11, 10, a3 - v11);
    if (v9) {
      unint64_t v8 = v9;
    }
    else {
      unint64_t v8 = a3;
    }
    int64_t v10 = a1->__end_;
    if (v8 == v11) {
      operator new();
    }
    std::basic_regex<char,std::regex_traits<char>>::__parse_basic_reg_exp<char const*>(a1, v11, v8);
    std::basic_regex<char,std::regex_traits<char>>::__push_alternation(a1, end, v10);
  }
  return a3;
}

std::basic_regex<char> *std::basic_regex<char,std::regex_traits<char>>::__parse_egrep<char const*>(std::basic_regex<char> *a1, std::basic_regex<char> *__s, std::basic_regex<char> *a3)
{
  end = a1->__end_;
  long long v7 = (std::basic_regex<char> *)memchr(__s, 10, (char *)a3 - (char *)__s);
  if (v7) {
    unint64_t v8 = v7;
  }
  else {
    unint64_t v8 = a3;
  }
  if (v8 == __s) {
    operator new();
  }
  std::basic_regex<char,std::regex_traits<char>>::__parse_extended_reg_exp<char const*>(a1, __s, v8);
  while (1)
  {
    unsigned int v11 = v8 == a3 ? v8 : (std::basic_regex<char> *)((char *)&v8->__traits_.__loc_.__locale_ + 1);
    if (v11 == a3) {
      break;
    }
    uint64_t v9 = (std::basic_regex<char> *)memchr(v11, 10, (char *)a3 - (char *)v11);
    if (v9) {
      unint64_t v8 = v9;
    }
    else {
      unint64_t v8 = a3;
    }
    int64_t v10 = a1->__end_;
    if (v8 == v11) {
      operator new();
    }
    std::basic_regex<char,std::regex_traits<char>>::__parse_extended_reg_exp<char const*>(a1, v11, v8);
    std::basic_regex<char,std::regex_traits<char>>::__push_alternation(a1, end, v10);
  }
  return a3;
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)14>()
{
  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D9436450](exception, 14);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_1D34FCB6C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__end_state<char>::~__end_state()
{
}

void std::__end_state<char>::__exec(uint64_t a1, _DWORD *a2)
{
  *a2 = -1000;
}

void std::shared_ptr<std::__empty_state<char>>::shared_ptr[abi:ne180100]<std::__empty_state<char>,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1D34FCC14(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<std::__empty_state<char>>::shared_ptr[abi:ne180100]<std::__empty_state<char>,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<std::__empty_state<char> *,std::shared_ptr<std::__empty_state<char>>::__shared_ptr_default_delete<std::__empty_state<char>,std::__empty_state<char>>,std::allocator<std::__empty_state<char>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1D9436740);
}

uint64_t std::__shared_ptr_pointer<std::__empty_state<char> *,std::shared_ptr<std::__empty_state<char>>::__shared_ptr_default_delete<std::__empty_state<char>,std::__empty_state<char>>,std::allocator<std::__empty_state<char>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<std::__empty_state<char> *,std::shared_ptr<std::__empty_state<char>>::__shared_ptr_default_delete<std::__empty_state<char>,std::__empty_state<char>>,std::allocator<std::__empty_state<char>>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void (__cdecl ***std::__empty_state<char>::~__empty_state(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  long long v2 = a1[1];
  if (v2) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  }
  return a1;
}

void std::__empty_state<char>::~__empty_state(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  uint64_t v1 = a1[1];
  if (v1) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v1 + 1))(v1);
  }
  JUMPOUT(0x1D9436740);
}

void std::__empty_state<char>::__exec(const std::__empty_state<char> *this, std::__empty_state<char>::__state *a2)
{
  a2->__do_ = -994;
  a2->__node_ = this->__first_;
}

void std::__owns_one_state<char>::~__owns_one_state(std::__owns_one_state<char> *this)
{
  first = this->__first_;
  if (first) {
    ((void (*)(std::__node<char> *))first->~__node_0)(first);
  }
}

{
  std::__node<char> *first;
  uint64_t vars8;

  first = this->__first_;
  if (first) {
    ((void (*)(std::__node<char> *))first->~__node_0)(first);
  }
  JUMPOUT(0x1D9436740);
}

void std::basic_regex<char,std::regex_traits<char>>::__push_alternation(std::basic_regex<char> *this, std::__owns_one_state<char> *__sa, std::__owns_one_state<char> *__sb)
{
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_term<char const*>(std::basic_regex<char> *a1, char *a2, char *a3)
{
  uint64_t result = (unsigned __int8 *)std::basic_regex<char,std::regex_traits<char>>::__parse_assertion<char const*>(a1, a2, a3);
  if (result == (unsigned __int8 *)a2)
  {
    end = a1->__end_;
    unsigned int marked_count = a1->__marked_count_;
    uint64_t v9 = std::basic_regex<char,std::regex_traits<char>>::__parse_atom<char const*>(a1, a2, a3);
    uint64_t result = (unsigned __int8 *)a2;
    if (v9 != (unsigned __int8 *)a2)
    {
      size_t v10 = a1->__marked_count_ + 1;
      return std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_dupl_symbol<char const*>((uint64_t)a1, v9, (unsigned __int8 *)a3, end, marked_count + 1, v10);
    }
  }
  return result;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_assertion<char const*>(std::basic_regex<char> *this, char *a2, char *a3)
{
  uint64_t v3 = a2;
  if (a2 == a3) {
    return v3;
  }
  int v6 = *a2;
  if (v6 <= 91)
  {
    if (v6 != 36)
    {
      BOOL v8 = v6 == 40;
      long long v7 = a2 + 1;
      BOOL v8 = !v8 || v7 == a3;
      if (!v8)
      {
        BOOL v8 = *v7 == 63;
        uint64_t v9 = a2 + 2;
        if (v8 && v9 != a3)
        {
          int v11 = *v9;
          if (v11 == 33)
          {
            std::regex_traits<char>::regex_traits(&v18.__traits_);
            memset(&v18.__flags_, 0, 40);
            v18.__flags_ = this->__flags_;
            BOOL v12 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse<char const*>(&v18, v3 + 3, a3);
            unsigned int marked_count = v18.__marked_count_;
            std::basic_regex<char,std::regex_traits<char>>::__push_lookahead(this, &v18, 1, this->__marked_count_);
            this->__marked_count_ += marked_count;
            if (v12 == a3 || *v12 != 41) {
              std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)6>();
            }
            goto LABEL_31;
          }
          if (v11 == 61)
          {
            std::regex_traits<char>::regex_traits(&v18.__traits_);
            memset(&v18.__flags_, 0, 40);
            v18.__flags_ = this->__flags_;
            BOOL v12 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse<char const*>(&v18, v3 + 3, a3);
            unsigned int v13 = v18.__marked_count_;
            std::basic_regex<char,std::regex_traits<char>>::__push_lookahead(this, &v18, 0, this->__marked_count_);
            this->__marked_count_ += v13;
            if (v12 == a3 || *v12 != 41) {
              std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)6>();
            }
LABEL_31:
            uint64_t v3 = v12 + 1;
            std::basic_regex<char,std::regex_traits<char>>::~basic_regex(&v18.__traits_.__loc_);
            return v3;
          }
        }
      }
      return v3;
    }
    std::basic_regex<char,std::regex_traits<char>>::__push_r_anchor(this);
    return ++v3;
  }
  if (v6 != 92)
  {
    if (v6 != 94) {
      return v3;
    }
    std::basic_regex<char,std::regex_traits<char>>::__push_l_anchor(this);
    return ++v3;
  }
  if (a2 + 1 != a3)
  {
    int v15 = a2[1];
    if (v15 == 66)
    {
      BOOL v16 = 1;
    }
    else
    {
      if (v15 != 98) {
        return v3;
      }
      BOOL v16 = 0;
    }
    std::basic_regex<char,std::regex_traits<char>>::__push_word_boundary(this, v16);
    v3 += 2;
  }
  return v3;
}

void sub_1D34FD280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9)
{
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_atom<char const*>(std::basic_regex<char> *this, char *a2, char *a3)
{
  uint64_t v3 = a2;
  if (a2 == a3) {
    return (unsigned __int8 *)v3;
  }
  int v6 = *a2;
  if (v6 <= 62)
  {
    if (v6 != 40)
    {
      if (v6 == 46) {
        operator new();
      }
      if ((v6 - 42) >= 2) {
        goto LABEL_28;
      }
LABEL_34:
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)11>();
    }
    if (a2 + 1 != a3)
    {
      if (a2 + 2 != a3 && a2[1] == 63 && a2[2] == 58)
      {
        p_open_count = &this->__open_count_;
        ++this->__open_count_;
        uint64_t v9 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse_ecma_exp<char const*>(this, a2 + 3, a3);
        if (v9 == a3) {
          goto LABEL_35;
        }
        size_t v10 = v9;
        if (*v9 != 41) {
          goto LABEL_35;
        }
        goto LABEL_25;
      }
      std::basic_regex<char,std::regex_traits<char>>::__push_begin_marked_subexpression(this);
      unsigned int marked_count = this->__marked_count_;
      p_open_count = &this->__open_count_;
      ++this->__open_count_;
      BOOL v12 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse_ecma_exp<char const*>(this, v3 + 1, a3);
      if (v12 != a3)
      {
        size_t v10 = v12;
        if (*v12 == 41)
        {
          std::basic_regex<char,std::regex_traits<char>>::__push_end_marked_subexpression(this, marked_count);
LABEL_25:
          --*p_open_count;
          return (unsigned __int8 *)(v10 + 1);
        }
      }
    }
LABEL_35:
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)6>();
  }
  if (v6 <= 91)
  {
    if (v6 == 91)
    {
      return (unsigned __int8 *)std::basic_regex<char,std::regex_traits<char>>::__parse_bracket_expression<char const*>((uint64_t)this, a2, a3);
    }
    if (v6 == 63) {
      goto LABEL_34;
    }
LABEL_28:
    return std::basic_regex<char,std::regex_traits<char>>::__parse_pattern_character<char const*>(this, a2, a3);
  }
  if (v6 != 92)
  {
    if (v6 == 123) {
      goto LABEL_34;
    }
    goto LABEL_28;
  }
  return std::basic_regex<char,std::regex_traits<char>>::__parse_atom_escape<char const*>(this, (unsigned __int8 *)a2, (unsigned __int8 *)a3);
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_dupl_symbol<char const*>(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, std::__owns_one_state<char> *__s, size_t a5, size_t a6)
{
  if (a2 == a3) {
    return a2;
  }
  unsigned int v6 = a6;
  unsigned int v7 = a5;
  uint64_t v10 = a1;
  int v11 = *(_DWORD *)(a1 + 24) & 0x1F0;
  int v12 = (char)*a2;
  if (v12 > 62)
  {
    if (v12 == 63)
    {
      unsigned int v13 = a2 + 1;
      if (v11) {
        BOOL v20 = 1;
      }
      else {
        BOOL v20 = v13 == a3;
      }
      if (!v20 && *v13 == 63)
      {
        unsigned int v13 = a2 + 2;
        a5 = a5;
        a6 = a6;
        size_t v14 = 0;
        size_t v18 = 1;
        goto LABEL_33;
      }
      a5 = a5;
      a6 = a6;
      size_t v14 = 0;
      size_t v18 = 1;
      goto LABEL_45;
    }
    if (v12 != 123) {
      return a2;
    }
    int v15 = a2 + 1;
    BOOL v16 = std::basic_regex<char,std::regex_traits<char>>::__parse_DUP_COUNT<char const*>(a1, a2 + 1, a3, (int *)&__max);
    if (v16 != v15)
    {
      if (v16 != a3)
      {
        int v17 = (char)*v16;
        if (v17 != 44)
        {
          if (v17 == 125)
          {
            unsigned int v13 = v16 + 1;
            if (!v11 && v13 != a3 && *v13 == 63)
            {
              unsigned int v13 = v16 + 2;
              size_t v14 = (int)__max;
              a5 = v7;
              a6 = v6;
              a1 = v10;
              size_t v18 = (int)__max;
LABEL_33:
              std::string::size_type v21 = __s;
              BOOL v22 = 0;
LABEL_46:
              std::basic_regex<char,std::regex_traits<char>>::__push_loop((std::basic_regex<char> *)a1, v14, v18, v21, a5, a6, v22);
              return v13;
            }
            size_t v14 = (int)__max;
            a5 = v7;
            a6 = v6;
            a1 = v10;
            size_t v18 = (int)__max;
LABEL_45:
            std::string::size_type v21 = __s;
            BOOL v22 = 1;
            goto LABEL_46;
          }
          goto LABEL_58;
        }
        unint64_t v23 = v16 + 1;
        if (v16 + 1 == a3) {
          goto LABEL_58;
        }
        if (*v23 == 125)
        {
          unsigned int v13 = v16 + 2;
          if (!v11 && v13 != a3 && *v13 == 63)
          {
            unsigned int v13 = v16 + 3;
            size_t v14 = (int)__max;
            a5 = v7;
            a6 = v6;
            a1 = v10;
            goto LABEL_26;
          }
          size_t v14 = (int)__max;
          a5 = v7;
          a6 = v6;
          a1 = v10;
LABEL_36:
          size_t v18 = -1;
          goto LABEL_45;
        }
        int v27 = -1;
        unsigned int v25 = std::basic_regex<char,std::regex_traits<char>>::__parse_DUP_COUNT<char const*>(v10, v23, a3, &v27);
        if (v25 != v23 && v25 != a3 && *v25 == 125)
        {
          size_t v18 = v27;
          size_t v14 = (int)__max;
          if (v27 >= (int)__max)
          {
            unsigned int v13 = v25 + 1;
            BOOL v22 = 1;
            if (!v11 && v13 != a3)
            {
              int v26 = v25[1];
              BOOL v22 = v26 != 63;
              if (v26 == 63) {
                unsigned int v13 = v25 + 2;
              }
            }
            a5 = v7;
            a6 = v6;
            a1 = v10;
            std::string::size_type v21 = __s;
            goto LABEL_46;
          }
          goto LABEL_58;
        }
      }
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)7>();
    }
LABEL_58:
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)8>();
  }
  if (v12 == 42)
  {
    unsigned int v13 = a2 + 1;
    if (v11) {
      BOOL v19 = 1;
    }
    else {
      BOOL v19 = v13 == a3;
    }
    if (!v19 && *v13 == 63)
    {
      unsigned int v13 = a2 + 2;
      a5 = a5;
      a6 = a6;
      size_t v14 = 0;
      goto LABEL_26;
    }
    a5 = a5;
    a6 = a6;
    size_t v14 = 0;
    goto LABEL_36;
  }
  if (v12 == 43)
  {
    unsigned int v13 = a2 + 1;
    if (!v11 && v13 != a3 && *v13 == 63)
    {
      unsigned int v13 = a2 + 2;
      a5 = a5;
      a6 = a6;
      size_t v14 = 1;
LABEL_26:
      size_t v18 = -1;
      goto LABEL_33;
    }
    a5 = a5;
    a6 = a6;
    size_t v14 = 1;
    goto LABEL_36;
  }
  return a2;
}

void std::basic_regex<char,std::regex_traits<char>>::__push_l_anchor(std::basic_regex<char> *this)
{
}

void std::basic_regex<char,std::regex_traits<char>>::__push_r_anchor(std::basic_regex<char> *this)
{
}

void std::basic_regex<char,std::regex_traits<char>>::__push_word_boundary(std::basic_regex<char> *this, BOOL a2)
{
}

void std::basic_regex<char,std::regex_traits<char>>::__push_lookahead(std::basic_regex<char> *this, const std::basic_regex<char> *a2, BOOL a3, unsigned int a4)
{
}

void sub_1D34FDA0C(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v1, 0x10E1C4030FC3181);
  _Unwind_Resume(a1);
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)6>()
{
  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D9436450](exception, 6);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_1D34FDA74(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::basic_regex<char,std::regex_traits<char>>::~basic_regex(std::locale *this)
{
  locale = (std::__shared_weak_count *)this[6].__locale_;
  if (locale) {
    std::__shared_weak_count::__release_shared[abi:ne180100](locale);
  }
  std::locale::~locale(this);
}

void (__cdecl ***std::__l_anchor_multiline<char>::~__l_anchor_multiline(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  long long v2 = a1[1];
  if (v2) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  }
  return a1;
}

void std::__l_anchor_multiline<char>::~__l_anchor_multiline(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  uint64_t v1 = a1[1];
  if (v1) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v1 + 1))(v1);
  }
  JUMPOUT(0x1D9436740);
}

uint64_t std::__l_anchor_multiline<char>::__exec(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 92))
  {
    if (*(void *)(a2 + 16) != *(void *)(a2 + 8) || (*(unsigned char *)(a2 + 88) & 1) != 0)
    {
LABEL_12:
      uint64_t v4 = 0;
      *(_DWORD *)a2 = -993;
      goto LABEL_13;
    }
  }
  else
  {
    if (!*(unsigned char *)(result + 16)) {
      goto LABEL_12;
    }
    int v2 = *(unsigned __int8 *)(*(void *)(a2 + 16) - 1);
    if (v2 != 13 && v2 != 10) {
      goto LABEL_12;
    }
  }
  *(_DWORD *)a2 = -994;
  uint64_t v4 = *(void *)(result + 8);
LABEL_13:
  *(void *)(a2 + 80) = v4;
  return result;
}

void (__cdecl ***std::__r_anchor_multiline<char>::~__r_anchor_multiline(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  int v2 = a1[1];
  if (v2) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  }
  return a1;
}

void std::__r_anchor_multiline<char>::~__r_anchor_multiline(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  uint64_t v1 = a1[1];
  if (v1) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v1 + 1))(v1);
  }
  JUMPOUT(0x1D9436740);
}

uint64_t std::__r_anchor_multiline<char>::__exec(uint64_t result, uint64_t a2)
{
  int v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) && (*(unsigned char *)(a2 + 88) & 2) == 0
    || *(unsigned char *)(result + 16) && ((v3 = *v2, v3 != 13) ? (BOOL v4 = v3 == 10) : (BOOL v4 = 1), v4))
  {
    *(_DWORD *)a2 = -994;
    uint64_t v5 = *(void *)(result + 8);
  }
  else
  {
    uint64_t v5 = 0;
    *(_DWORD *)a2 = -993;
  }
  *(void *)(a2 + 80) = v5;
  return result;
}

std::locale *std::__word_boundary<char,std::regex_traits<char>>::~__word_boundary(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_1F2ABAEB8;
  std::locale::~locale(a1 + 2);
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

void std::__word_boundary<char,std::regex_traits<char>>::~__word_boundary(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_1F2ABAEB8;
  std::locale::~locale(a1 + 2);
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  JUMPOUT(0x1D9436740);
}

uint64_t std::__word_boundary<char,std::regex_traits<char>>::__exec(uint64_t result, uint64_t a2)
{
  int v2 = *(unsigned __int8 **)(a2 + 8);
  int v3 = *(unsigned __int8 **)(a2 + 24);
  if (v2 == v3) {
    goto LABEL_17;
  }
  BOOL v4 = *(unsigned __int8 **)(a2 + 16);
  if (v4 == v3)
  {
    if ((*(unsigned char *)(a2 + 88) & 8) == 0)
    {
      uint64_t v6 = *(v3 - 1);
      goto LABEL_13;
    }
LABEL_17:
    int v10 = 0;
    goto LABEL_25;
  }
  if (v4 == v2)
  {
    int v5 = *(_DWORD *)(a2 + 88);
    if ((v5 & 0x80) == 0)
    {
      if ((v5 & 4) == 0)
      {
        uint64_t v6 = *v2;
LABEL_13:
        if (v6 == 95
          || (v6 & 0x80) == 0 && (*(_DWORD *)(*(void *)(*(void *)(result + 24) + 16) + 4 * v6) & 0x500) != 0)
        {
          int v10 = 1;
          goto LABEL_25;
        }
        goto LABEL_17;
      }
      goto LABEL_17;
    }
  }
  uint64_t v7 = *(v4 - 1);
  uint64_t v8 = *v4;
  int v9 = v7 == 95 || (v7 & 0x80) == 0 && (*(_DWORD *)(*(void *)(*(void *)(result + 24) + 16) + 4 * v7) & 0x500) != 0;
  int v11 = v8 == 95
     || (v8 & 0x80) == 0 && (*(_DWORD *)(*(void *)(*(void *)(result + 24) + 16) + 4 * v8) & 0x500) != 0;
  int v10 = v9 != v11;
LABEL_25:
  if (*(unsigned __int8 *)(result + 40) == v10)
  {
    uint64_t v12 = 0;
    int v13 = -993;
  }
  else
  {
    uint64_t v12 = *(void *)(result + 8);
    int v13 = -994;
  }
  *(_DWORD *)a2 = v13;
  *(void *)(a2 + 80) = v12;
  return result;
}

uint64_t std::__lookahead<char,std::regex_traits<char>>::__lookahead[abi:ne180100](uint64_t a1, uint64_t a2, char a3, uint64_t a4, int a5)
{
  *(void *)a1 = &unk_1F2ABADF8;
  *(void *)(a1 + 8) = a4;
  std::locale::locale((std::locale *)(a1 + 16), (const std::locale *)a2);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 24);
  uint64_t v9 = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = *(void *)(a2 + 40);
  *(void *)(a1 + 64) = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 72) = *(void *)(a2 + 56);
  *(_DWORD *)(a1 + 80) = a5;
  *(unsigned char *)(a1 + 84) = a3;
  return a1;
}

void (__cdecl ***std::__lookahead<char,std::regex_traits<char>>::~__lookahead(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  *a1 = (void (__cdecl **)(std::__owns_one_state<char> *__hidden))&unk_1F2ABADF8;
  int v2 = (std::locale *)(a1 + 2);
  int v3 = (std::__shared_weak_count *)a1[8];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  std::locale::~locale(v2);
  BOOL v4 = a1[1];
  if (v4) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v4 + 1))(v4);
  }
  return a1;
}

void std::__lookahead<char,std::regex_traits<char>>::~__lookahead(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  *a1 = (void (__cdecl **)(std::__owns_one_state<char> *__hidden))&unk_1F2ABADF8;
  int v2 = (std::locale *)(a1 + 2);
  int v3 = (std::__shared_weak_count *)a1[8];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  std::locale::~locale(v2);
  BOOL v4 = a1[1];
  if (v4) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v4 + 1))(v4);
  }
  JUMPOUT(0x1D9436740);
}

void std::__lookahead<char,std::regex_traits<char>>::__exec(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  char v21 = 0;
  memset(&v22, 0, 17);
  char v23 = 0;
  uint64_t v24 = 0;
  memset(&__p, 0, sizeof(__p));
  std::vector<std::csub_match>::size_type v4 = (*(_DWORD *)(a1 + 44) + 1);
  uint64_t v5 = *(void *)(a2 + 16);
  v18.first = *(const char **)(a2 + 24);
  v18.second = v18.first;
  v18.matched = 0;
  std::vector<std::sub_match<char const*>>::assign(&__p, v4, &v18);
  uint64_t v19 = v5;
  uint64_t v20 = v5;
  char v21 = 0;
  std::vector<std::csub_match>::value_type v22 = v18;
  uint64_t v24 = v5;
  char v23 = 1;
  uint64_t v6 = *(const char **)(a2 + 16);
  if (*(unsigned char *)(a2 + 92)) {
    BOOL v7 = v6 == *(const char **)(a2 + 8);
  }
  else {
    BOOL v7 = 0;
  }
  char v8 = v7;
  if (*(unsigned __int8 *)(a1 + 84) == std::basic_regex<char,std::regex_traits<char>>::__match_at_start_ecma<std::allocator<std::sub_match<char const*>>>(a1 + 16, v6, *(const char **)(a2 + 24), (uint64_t *)&__p, *(_DWORD *)(a2 + 88) & 0xFBF | 0x40u, v8))
  {
    *(_DWORD *)a2 = -993;
    *(void *)(a2 + 80) = 0;
    std::vector<std::csub_match>::pointer begin = __p.__begin_;
    goto LABEL_13;
  }
  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 80) = *(void *)(a1 + 8);
  std::vector<std::csub_match>::pointer begin = __p.__begin_;
  unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (((char *)__p.__end_ - (char *)__p.__begin_) >> 3);
  if (v10 < 2)
  {
LABEL_13:
    if (!begin) {
      return;
    }
    goto LABEL_14;
  }
  int v11 = 0;
  int v12 = *(_DWORD *)(a1 + 80);
  uint64_t v13 = *(void *)(a2 + 32);
  unint64_t v14 = 1;
  do
  {
    int v15 = &begin[v14];
    uint64_t v16 = v13 + 24 * (v12 + v11);
    *(std::pair<const char *, const char *> *)uint64_t v16 = v15->std::pair<const char *, const char *>;
    *(unsigned char *)(v16 + 16) = v15->matched;
    unint64_t v14 = (v11 + 2);
    ++v11;
  }
  while (v10 > v14);
LABEL_14:
  __p.__end_ = begin;
  operator delete(begin);
}

void sub_1D34FE310(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::match_results<char const*>::__init(std::match_results<const char *> *this, unsigned int __s, const char *__f, const char *__l, BOOL __no_update_pos)
{
  this->__unmatched_.first = __l;
  p_unmatched = &this->__unmatched_;
  this->__unmatched_.second = __l;
  this->__unmatched_.matched = 0;
  std::vector<std::sub_match<char const*>>::assign(&this->__matches_, __s, &this->__unmatched_);
  this->__prefix_.first = __f;
  this->__prefix_.second = __f;
  this->__prefix_.matched = 0;
  this->__suffix_ = *p_unmatched;
  if (!__no_update_pos) {
    this->__position_start_ = __f;
  }
  this->__ready_ = 1;
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__match_at_start_ecma<std::allocator<std::sub_match<char const*>>>(uint64_t a1, const char *a2, const char *a3, uint64_t *a4, int a5, char a6)
{
  long long v44 = 0;
  char v45 = 0;
  unint64_t v46 = 0;
  uint64_t v6 = *(void *)(a1 + 40);
  if (v6)
  {
    __x.first = a3;
    __x.second = a3;
    __x.matched = 0;
    *(_DWORD *)uint64_t v40 = 0;
    memset(&v40[8], 0, 48);
    *(_OWORD *)std::vector<std::csub_match> __p = 0u;
    memset(v42, 0, 21);
    char v45 = (_OWORD *)std::vector<std::__state<char>>::__push_back_slow_path<std::__state<char>>((uint64_t *)&v44, (uint64_t)v40);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (*(void *)&v40[32])
    {
      *(void *)&v40[40] = *(void *)&v40[32];
      operator delete(*(void **)&v40[32]);
    }
    uint64_t v38 = a4;
    uint64_t v13 = v45;
    *((_DWORD *)v45 - 24) = 0;
    *((void *)v13 - 11) = a2;
    *((void *)v13 - 10) = a2;
    *((void *)v13 - 9) = a3;
    std::vector<std::sub_match<char const*>>::resize((std::vector<std::csub_match> *)(v13 - 4), *(unsigned int *)(a1 + 28), &__x);
    std::vector<std::pair<unsigned long,char const*>>::resize((std::vector<std::pair<unsigned long, const char *>> *)((char *)v45 - 40), *(unsigned int *)(a1 + 32));
    unint64_t v14 = v45;
    *((void *)v45 - 2) = v6;
    std::string::size_type v39 = a3;
    signed int v15 = a3 - a2;
    *((_DWORD *)v14 - 2) = a5;
    *((unsigned char *)v14 - 4) = a6;
    unsigned int v16 = 1;
    while (2)
    {
      if ((v16 & 0xFFF) != 0 || (int)(v16 >> 12) < v15)
      {
        std::vector<std::csub_match>::value_type v18 = v14 - 1;
        uint64_t v17 = *((void *)v14 - 2);
        uint64_t v19 = v14 - 6;
        if (v17) {
          (*(void (**)(uint64_t, _OWORD *))(*(void *)v17 + 16))(v17, v14 - 6);
        }
        switch(*(_DWORD *)v19)
        {
          case 0xFFFFFC18:
            uint64_t v20 = (const char *)*((void *)v14 - 10);
            if ((a5 & 0x20) != 0 && v20 == a2 || (a5 & 0x1000) != 0 && v20 != v39) {
              goto LABEL_16;
            }
            uint64_t v29 = *v38;
            *(void *)uint64_t v29 = a2;
            *(void *)(v29 + 8) = v20;
            *(unsigned char *)(v29 + 16) = 1;
            uint64_t v30 = *((void *)v14 - 8);
            uint64_t v31 = *((void *)v14 - 7) - v30;
            if (v31)
            {
              unint64_t v32 = 0xAAAAAAAAAAAAAAABLL * (v31 >> 3);
              uint64_t v33 = (unsigned char *)(v30 + 16);
              unsigned int v34 = 1;
              do
              {
                uint64_t v35 = v29 + 24 * v34;
                *(_OWORD *)uint64_t v35 = *((_OWORD *)v33 - 1);
                char v36 = *v33;
                v33 += 24;
                *(unsigned char *)(v35 + 16) = v36;
              }
              while (v32 > v34++);
            }
            uint64_t v27 = 1;
            goto LABEL_25;
          case 0xFFFFFC1D:
          case 0xFFFFFC1E:
          case 0xFFFFFC21:
            goto LABEL_23;
          case 0xFFFFFC1F:
LABEL_16:
            char v21 = v45 - 6;
            std::__destroy_at[abi:ne180100]<std::__state<char>,0>((void *)v45 - 12);
            char v45 = v21;
            goto LABEL_23;
          case 0xFFFFFC20:
            long long v22 = *(v14 - 5);
            *(_OWORD *)uint64_t v40 = *v19;
            *(_OWORD *)&v40[16] = v22;
            memset(&v40[32], 0, 24);
            std::vector<std::sub_match<char const*>>::__init_with_size[abi:ne180100]<std::sub_match<char const*>*,std::sub_match<char const*>*>(&v40[32], *((long long **)v14 - 8), *((long long **)v14 - 7), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)v14 - 7) - *((void *)v14 - 8)) >> 3));
            __p[0] = 0;
            __p[1] = 0;
            v42[0] = 0;
            std::vector<std::pair<unsigned long,char const*>>::__init_with_size[abi:ne180100]<std::pair<unsigned long,char const*>*,std::pair<unsigned long,char const*>*>((char *)__p, *((long long **)v14 - 5), *((long long **)v14 - 4), (uint64_t)(*((void *)v14 - 4) - *((void *)v14 - 5)) >> 4);
            uint64_t v23 = *v18;
            *(void *)((char *)&v42[1] + 5) = *(void *)((char *)v14 - 11);
            v42[1] = v23;
            (*(void (**)(void, uint64_t, _OWORD *))(*(void *)*v18 + 24))(*v18, 1, v14 - 6);
            (*(void (**)(void, void, unsigned char *))(*(void *)v42[1] + 24))(v42[1], 0, v40);
            uint64_t v24 = v45;
            if ((unint64_t)v45 >= v46)
            {
              char v45 = (_OWORD *)std::vector<std::__state<char>>::__push_back_slow_path<std::__state<char>>((uint64_t *)&v44, (uint64_t)v40);
              if (__p[0])
              {
                __p[1] = __p[0];
                operator delete(__p[0]);
              }
            }
            else
            {
              long long v25 = *(_OWORD *)&v40[16];
              _OWORD *v45 = *(_OWORD *)v40;
              v24[1] = v25;
              *((void *)v24 + 4) = 0;
              *((void *)v24 + 5) = 0;
              *((void *)v24 + 6) = 0;
              *((void *)v24 + 7) = 0;
              v24[2] = *(_OWORD *)&v40[32];
              *((void *)v24 + 6) = *(void *)&v40[48];
              memset(&v40[32], 0, 24);
              *((void *)v24 + 8) = 0;
              *((void *)v24 + 9) = 0;
              *(_OWORD *)((char *)v24 + 56) = *(_OWORD *)__p;
              *((void *)v24 + 9) = v42[0];
              __p[0] = 0;
              __p[1] = 0;
              v42[0] = 0;
              uint64_t v26 = v42[1];
              *(void *)((char *)v24 + 85) = *(void *)((char *)&v42[1] + 5);
              *((void *)v24 + 10) = v26;
              char v45 = v24 + 6;
            }
            if (*(void *)&v40[32])
            {
              *(void *)&v40[40] = *(void *)&v40[32];
              operator delete(*(void **)&v40[32]);
            }
LABEL_23:
            unint64_t v14 = v45;
            ++v16;
            if (v44 == v45) {
              goto LABEL_24;
            }
            continue;
          default:
            std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)16>();
        }
      }
      break;
    }
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)12>();
  }
LABEL_24:
  uint64_t v27 = 0;
LABEL_25:
  *(void *)uint64_t v40 = &v44;
  std::vector<std::__state<char>>::__destroy_vector::operator()[abi:ne180100]((void ***)v40);
  return v27;
}

void sub_1D34FE778(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  std::__state<char>::~__state(&a11);
  a11 = v16 - 112;
  std::vector<std::__state<char>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a11);
  _Unwind_Resume(a1);
}

void std::vector<std::sub_match<char const*>>::assign(std::vector<std::csub_match> *this, std::vector<std::csub_match>::size_type __n, std::vector<std::csub_match>::const_reference __u)
{
  value = this->__end_cap_.__value_;
  std::vector<std::csub_match>::pointer begin = this->__begin_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)begin) >> 3) >= __n)
  {
    std::vector<std::csub_match>::pointer end = this->__end_;
    std::vector<std::csub_match>::size_type v16 = end - begin;
    if (v16 >= __n) {
      std::vector<std::csub_match>::size_type v17 = __n;
    }
    else {
      std::vector<std::csub_match>::size_type v17 = end - begin;
    }
    if (v17)
    {
      std::vector<std::csub_match>::value_type v18 = begin;
      do
      {
        *v18++ = *__u;
        --v17;
      }
      while (v17);
    }
    if (__n <= v16)
    {
      this->__end_ = &begin[__n];
    }
    else
    {
      uint64_t v19 = &end[__n - v16];
      std::vector<std::csub_match>::size_type v20 = 24 * __n - 24 * v16;
      do
      {
        std::pair<const char *, const char *> v21 = __u->std::pair<const char *, const char *>;
        *(void *)&end->matched = *(void *)&__u->matched;
        end->std::pair<const char *, const char *> = v21;
        ++end;
        v20 -= 24;
      }
      while (v20);
      this->__end_ = v19;
    }
  }
  else
  {
    if (begin)
    {
      this->__end_ = begin;
      operator delete(begin);
      value = 0;
      this->__begin_ = 0;
      this->__end_ = 0;
      this->__end_cap_.__value_ = 0;
    }
    if (__n > 0xAAAAAAAAAAAAAAALL) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)value >> 3);
    std::vector<std::csub_match>::size_type v9 = 2 * v8;
    if (2 * v8 <= __n) {
      std::vector<std::csub_match>::size_type v9 = __n;
    }
    if (v8 >= 0x555555555555555) {
      unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v10 = v9;
    }
    std::vector<std::sub_match<char const*>>::__vallocate[abi:ne180100](this, v10);
    std::vector<std::csub_match>::pointer v11 = this->__end_;
    int v12 = &v11[__n];
    std::vector<std::csub_match>::size_type v13 = 24 * __n;
    do
    {
      std::pair<const char *, const char *> v14 = __u->std::pair<const char *, const char *>;
      *(void *)&v11->matched = *(void *)&__u->matched;
      v11->std::pair<const char *, const char *> = v14;
      ++v11;
      v13 -= 24;
    }
    while (v13);
    this->__end_ = v12;
  }
}

char *std::vector<std::sub_match<char const*>>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void *std::__state<char>::~__state(void *a1)
{
  int v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }
  int v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }
  return a1;
}

void std::vector<std::sub_match<char const*>>::resize(std::vector<std::csub_match> *this, std::vector<std::csub_match>::size_type __sz, std::vector<std::csub_match>::const_reference __x)
{
  std::vector<std::csub_match>::size_type v3 = 0xAAAAAAAAAAAAAAABLL * (((char *)this->__end_ - (char *)this->__begin_) >> 3);
  BOOL v4 = __sz >= v3;
  std::vector<std::csub_match>::size_type v5 = __sz - v3;
  if (v5 != 0 && v4)
  {
    std::vector<std::sub_match<char const*>>::__append(this, v5, __x);
  }
  else if (!v4)
  {
    this->__end_ = &this->__begin_[__sz];
  }
}

void std::vector<std::pair<unsigned long,char const*>>::resize(std::vector<std::pair<unsigned long, const char *>> *this, std::vector<std::pair<unsigned long, const char *>>::size_type __sz)
{
  std::vector<std::pair<unsigned long, const char *>>::size_type v2 = this->__end_ - this->__begin_;
  if (__sz <= v2)
  {
    if (__sz < v2) {
      this->__end_ = &this->__begin_[__sz];
    }
  }
  else
  {
    std::vector<std::pair<unsigned long,char const*>>::__append(this, __sz - v2);
  }
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)12>()
{
  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D9436450](exception, 12);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_1D34FEAB8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)16>()
{
  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D9436450](exception, 16);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_1D34FEB10(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::__state<char>>::__push_back_slow_path<std::__state<char>>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 5);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x2AAAAAAAAAAAAAALL) {
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 5);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x155555555555555) {
    unint64_t v9 = 0x2AAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  v16[4] = a1 + 2;
  if (v9) {
    unint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::__state<char>>>(v7, v9);
  }
  else {
    unint64_t v10 = 0;
  }
  std::vector<std::csub_match>::pointer v11 = &v10[96 * v4];
  v16[0] = v10;
  v16[1] = v11;
  v16[3] = &v10[96 * v9];
  long long v12 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)std::vector<std::csub_match>::pointer v11 = *(_OWORD *)a2;
  *((_OWORD *)v11 + 1) = v12;
  *((void *)v11 + 5) = 0;
  *((void *)v11 + 6) = 0;
  *((void *)v11 + 4) = 0;
  *((_OWORD *)v11 + 2) = *(_OWORD *)(a2 + 32);
  *((void *)v11 + 6) = *(void *)(a2 + 48);
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *((void *)v11 + 7) = 0;
  *((void *)v11 + 8) = 0;
  *((void *)v11 + 9) = 0;
  *(_OWORD *)(v11 + 56) = *(_OWORD *)(a2 + 56);
  *((void *)v11 + 9) = *(void *)(a2 + 72);
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  uint64_t v13 = *(void *)(a2 + 80);
  *(void *)(v11 + 85) = *(void *)(a2 + 85);
  *((void *)v11 + 10) = v13;
  void v16[2] = v11 + 96;
  std::vector<std::__state<char>>::__swap_out_circular_buffer(a1, v16);
  uint64_t v14 = a1[1];
  std::__split_buffer<std::__state<char>>::~__split_buffer((uint64_t)v16);
  return v14;
}

void sub_1D34FEC60(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::__state<char>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<std::__state<char>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::__state<char>>,std::reverse_iterator<std::__state<char>*>,std::reverse_iterator<std::__state<char>*>,std::reverse_iterator<std::__state<char>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v4;
  uint64_t v5 = *a1;
  *a1 = v4;
  a2[1] = v5;
  uint64_t v6 = a1[1];
  a1[1] = a2[2];
  a2[2] = v6;
  uint64_t v7 = a1[2];
  a1[2] = a2[3];
  a2[3] = v7;
  *a2 = a2[1];
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::__state<char>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2AAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(96 * a2);
}

__n128 std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::__state<char>>,std::reverse_iterator<std::__state<char>*>,std::reverse_iterator<std::__state<char>*>,std::reverse_iterator<std::__state<char>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = a7 + v7;
      uint64_t v9 = a3 + v7;
      long long v10 = *(_OWORD *)(a3 + v7 - 80);
      *(_OWORD *)(v8 - 96) = *(_OWORD *)(a3 + v7 - 96);
      *(_OWORD *)(v8 - 80) = v10;
      *(void *)(v8 - 56) = 0;
      *(void *)(v8 - 48) = 0;
      *(void *)(v8 - 64) = 0;
      *(_OWORD *)(v8 - 64) = *(_OWORD *)(a3 + v7 - 64);
      *(void *)(v8 - 48) = *(void *)(a3 + v7 - 48);
      *(void *)(v9 - 64) = 0;
      *(void *)(v9 - 56) = 0;
      *(void *)(v9 - 48) = 0;
      *(void *)(v8 - 40) = 0;
      *(void *)(v8 - 32) = 0;
      *(void *)(v8 - 24) = 0;
      __n128 result = *(__n128 *)(a3 + v7 - 40);
      *(__n128 *)(v8 - 40) = result;
      *(void *)(v8 - 24) = *(void *)(a3 + v7 - 24);
      *(void *)(v9 - 40) = 0;
      *(void *)(v9 - 32) = 0;
      *(void *)(v9 - 24) = 0;
      uint64_t v12 = *(void *)(a3 + v7 - 16);
      *(void *)(v8 - 11) = *(void *)(a3 + v7 - 11);
      *(void *)(v8 - 16) = v12;
      v7 -= 96;
    }
    while (a3 + v7 != a5);
  }
  return result;
}

void std::__destroy_at[abi:ne180100]<std::__state<char>,0>(void *a1)
{
  std::vector<std::pair<unsigned long, const char *>>::size_type v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }
}

uint64_t std::__split_buffer<std::__state<char>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 96;
    std::__destroy_at[abi:ne180100]<std::__state<char>,0>((void *)(i - 96));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::vector<std::sub_match<char const*>>::__append(std::vector<std::csub_match> *this, std::vector<std::csub_match>::size_type __n, std::vector<std::csub_match>::const_reference __x)
{
  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  uint64_t v7 = value;
  uint64_t v9 = p_end_cap[-1].__value_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)v9) >> 3) >= __n)
  {
    if (__n)
    {
      signed int v15 = &v9[__n];
      std::vector<std::csub_match>::size_type v16 = 24 * __n;
      do
      {
        std::pair<const char *, const char *> v17 = __x->std::pair<const char *, const char *>;
        *(void *)&v9->matched = *(void *)&__x->matched;
        v9->std::pair<const char *, const char *> = v17;
        ++v9;
        v16 -= 24;
      }
      while (v16);
      uint64_t v9 = v15;
    }
    this->__end_ = v9;
  }
  else
  {
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (((char *)v9 - (char *)this->__begin_) >> 3);
    unint64_t v11 = v10 + __n;
    if (v10 + __n > 0xAAAAAAAAAAAAAAALL) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * (((char *)v7 - (char *)this->__begin_) >> 3);
    if (2 * v12 > v11) {
      unint64_t v11 = 2 * v12;
    }
    if (v12 >= 0x555555555555555) {
      unint64_t v13 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v13) {
      uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)p_end_cap, v13);
    }
    else {
      uint64_t v14 = 0;
    }
    std::vector<std::csub_match>::value_type v18 = (std::sub_match<const char *> *)&v14[24 * v10];
    uint64_t v19 = &v18[__n];
    std::vector<std::csub_match>::size_type v20 = 24 * __n;
    std::pair<const char *, const char *> v21 = v18;
    do
    {
      std::pair<const char *, const char *> v22 = __x->std::pair<const char *, const char *>;
      v21[1].first = *(const char **)&__x->matched;
      *std::pair<const char *, const char *> v21 = v22;
      std::pair<const char *, const char *> v21 = (std::pair<const char *, const char *> *)((char *)v21 + 24);
      v20 -= 24;
    }
    while (v20);
    uint64_t v23 = (std::sub_match<const char *> *)&v14[24 * v13];
    std::vector<std::csub_match>::pointer begin = this->__begin_;
    std::vector<std::csub_match>::pointer end = this->__end_;
    if (end != this->__begin_)
    {
      do
      {
        std::pair<const char *, const char *> v26 = end[-1].std::pair<const char *, const char *>;
        *(void *)&v18[-1].matched = *(void *)&end[-1].matched;
        v18[-1].std::pair<const char *, const char *> = v26;
        --v18;
        --end;
      }
      while (end != begin);
      std::vector<std::csub_match>::pointer end = this->__begin_;
    }
    this->__begin_ = v18;
    this->__end_ = v19;
    this->__end_cap_.__value_ = v23;
    if (end)
    {
      operator delete(end);
    }
  }
}

void std::vector<std::pair<unsigned long,char const*>>::__append(std::vector<std::pair<unsigned long, const char *>> *this, std::vector<std::pair<unsigned long, const char *>>::size_type __n)
{
  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  uint64_t v5 = value;
  uint64_t v7 = p_end_cap[-1].__value_;
  if (__n <= value - v7)
  {
    if (__n)
    {
      bzero(p_end_cap[-1].__value_, 16 * __n);
      v7 += __n;
    }
    this->__end_ = v7;
  }
  else
  {
    uint64_t v8 = (char *)v7 - (char *)this->__begin_;
    unint64_t v9 = __n + (v8 >> 4);
    if (v9 >> 60) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 4;
    uint64_t v11 = (char *)v5 - (char *)this->__begin_;
    if (v11 >> 3 > v9) {
      unint64_t v9 = v11 >> 3;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      unint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<TNodePtr,TNodeEventPtr>>>((uint64_t)p_end_cap, v12);
    }
    else {
      unint64_t v13 = 0;
    }
    uint64_t v14 = (std::pair<unsigned long, const char *> *)&v13[16 * v10];
    signed int v15 = (std::pair<unsigned long, const char *> *)&v13[16 * v12];
    bzero(v14, 16 * __n);
    std::vector<std::csub_match>::size_type v16 = &v14[__n];
    std::vector<std::pair<unsigned long, const char *>>::pointer begin = this->__begin_;
    std::vector<std::csub_match>::pointer end = this->__end_;
    if (end != this->__begin_)
    {
      do
      {
        v14[-1] = end[-1];
        --v14;
        --end;
      }
      while (end != begin);
      std::vector<std::csub_match>::pointer end = this->__begin_;
    }
    this->__begin_ = v14;
    this->__end_ = v16;
    this->__end_cap_.__value_ = v15;
    if (end)
    {
      operator delete(end);
    }
  }
}

char *std::vector<std::sub_match<char const*>>::__init_with_size[abi:ne180100]<std::sub_match<char const*>*,std::sub_match<char const*>*>(char *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<std::sub_match<char const*>>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = *((void *)v6 + 1);
    while (a2 != a3)
    {
      long long v8 = *a2;
      *(void *)(v7 + 16) = *((void *)a2 + 2);
      *(_OWORD *)uint64_t v7 = v8;
      v7 += 24;
      a2 = (long long *)((char *)a2 + 24);
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_1D34FF174(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<std::pair<unsigned long,char const*>>::__init_with_size[abi:ne180100]<std::pair<unsigned long,char const*>*,std::pair<unsigned long,char const*>*>(char *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = std::vector<std::pair<TString,TString>>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (_OWORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      long long v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_1D34FF1E8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<std::__state<char>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  std::vector<std::pair<unsigned long, const char *>>::size_type v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 12;
        std::__destroy_at[abi:ne180100]<std::__state<char>,0>(v4);
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_atom_escape<char const*>(std::basic_regex<char> *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 == a3 || *a2 != 92) {
    return a2;
  }
  uint64_t v5 = a2 + 1;
  if (a2 + 1 == a3) {
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)3>();
  }
  __n128 result = std::basic_regex<char,std::regex_traits<char>>::__parse_decimal_escape<char const*>(a1, a2 + 1, a3);
  if (result == v5)
  {
    __n128 result = (unsigned __int8 *)std::basic_regex<char,std::regex_traits<char>>::__parse_character_class_escape<char const*>(a1, (char *)a2 + 1, (char *)a3);
    if (result == v5)
    {
      __n128 result = std::basic_regex<char,std::regex_traits<char>>::__parse_character_escape<char const*>(a1, a2 + 1, a3, 0);
      if (result == v5) {
        return a2;
      }
    }
  }
  return result;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_bracket_expression<char const*>(uint64_t a1, char *a2, char *a3)
{
  if (a2 != a3 && *a2 == 91)
  {
    if (a2 + 1 == a3) {
      goto LABEL_20;
    }
    uint64_t v5 = a2[1] == 94 ? a2 + 2 : a2 + 1;
    started = std::basic_regex<char,std::regex_traits<char>>::__start_matching_list((std::basic_regex<char> *)a1, a2[1] == 94);
    if (v5 == a3) {
      goto LABEL_20;
    }
    uint64_t v7 = (uint64_t *)started;
    if ((*(_WORD *)(a1 + 24) & 0x1F0) != 0 && *v5 == 93)
    {
      std::__bracket_expression<char,std::regex_traits<char>>::__add_char[abi:ne180100]((uint64_t)started, 93);
      ++v5;
    }
    if (v5 == a3) {
      goto LABEL_20;
    }
    do
    {
      long long v8 = v5;
      uint64_t v5 = std::basic_regex<char,std::regex_traits<char>>::__parse_expression_term<char const*>(a1, v5, a3, v7);
    }
    while (v5 != v8);
    if (v8 == a3) {
      goto LABEL_20;
    }
    if (*v8 == 45)
    {
      std::__bracket_expression<char,std::regex_traits<char>>::__add_char[abi:ne180100]((uint64_t)v7, 45);
      ++v8;
    }
    if (v8 == a3 || *v8 != 93) {
LABEL_20:
    }
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)5>();
    return v8 + 1;
  }
  return a2;
}

void std::basic_regex<char,std::regex_traits<char>>::__push_begin_marked_subexpression(std::basic_regex<char> *this)
{
  if ((this->__flags_ & 2) == 0) {
    operator new();
  }
}

void std::basic_regex<char,std::regex_traits<char>>::__push_end_marked_subexpression(std::basic_regex<char> *this, unsigned int a2)
{
  if ((this->__flags_ & 2) == 0) {
    operator new();
  }
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)11>()
{
  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D9436450](exception, 11);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_1D34FF584(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned char *std::basic_regex<char,std::regex_traits<char>>::__parse_pattern_character<char const*>(std::basic_regex<char> *a1, unsigned char *a2, unsigned char *a3)
{
  uint64_t v3 = a2;
  if (a2 != a3)
  {
    int v4 = (char)*a2;
    BOOL v5 = (v4 - 36) > 0x3A || ((1 << (*a2 - 36)) & 0x7800000080004F1) == 0;
    if (v5 && (v4 - 123) >= 3)
    {
      std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, v4);
      ++v3;
    }
  }
  return v3;
}

void (__cdecl ***std::__match_any_but_newline<char>::~__match_any_but_newline(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  std::vector<std::pair<unsigned long, const char *>>::size_type v2 = a1[1];
  if (v2) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  }
  return a1;
}

void std::__match_any_but_newline<char>::~__match_any_but_newline(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  uint64_t v1 = a1[1];
  if (v1) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v1 + 1))(v1);
  }
  JUMPOUT(0x1D9436740);
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)3>()
{
  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D9436450](exception, 3);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_1D34FF748(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_decimal_escape<char const*>(std::basic_regex<char> *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 == a3) {
    return a2;
  }
  int v4 = *a2;
  unsigned int v5 = v4 - 48;
  if (v4 == 48)
  {
    std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, v5);
    return a2 + 1;
  }
  if ((v4 - 49) > 8) {
    return a2;
  }
  uint64_t v6 = a3;
  uint64_t v7 = a2 + 1;
  if (a2 + 1 != a3)
  {
    while (1)
    {
      int v8 = *v7;
      if ((v8 - 48) > 9) {
        break;
      }
      if (v5 >= 0x19999999) {
        goto LABEL_16;
      }
      ++v7;
      unsigned int v5 = v8 + 10 * v5 - 48;
      if (v7 == a3) {
        goto LABEL_12;
      }
    }
    uint64_t v6 = v7;
LABEL_12:
    if (!v5) {
      goto LABEL_16;
    }
  }
  if (v5 > a1->__marked_count_) {
LABEL_16:
  }
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)4>();
  std::basic_regex<char,std::regex_traits<char>>::__push_back_ref(a1, v5);
  return v6;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_character_class_escape<char const*>(std::basic_regex<char> *a1, char *a2, char *a3)
{
  uint64_t v3 = a2;
  if (a2 == a3) {
    return v3;
  }
  int v4 = *a2;
  if (v4 > 99)
  {
    if (v4 == 119)
    {
      BOOL v5 = 0;
      goto LABEL_15;
    }
    if (v4 == 115)
    {
      BOOL v9 = 0;
      goto LABEL_17;
    }
    if (v4 != 100) {
      return v3;
    }
    BOOL v6 = 0;
LABEL_12:
    started = std::basic_regex<char,std::regex_traits<char>>::__start_matching_list(a1, v6);
    int v8 = started->__mask_ | 0x400;
LABEL_18:
    started->__mask_ = v8;
    goto LABEL_19;
  }
  switch(v4)
  {
    case 'D':
      BOOL v6 = 1;
      goto LABEL_12;
    case 'S':
      BOOL v9 = 1;
LABEL_17:
      started = std::basic_regex<char,std::regex_traits<char>>::__start_matching_list(a1, v9);
      int v8 = started->__mask_ | 0x4000;
      goto LABEL_18;
    case 'W':
      BOOL v5 = 1;
LABEL_15:
      uint64_t v10 = std::basic_regex<char,std::regex_traits<char>>::__start_matching_list(a1, v5);
      v10->__mask_ |= 0x500u;
      std::__bracket_expression<char,std::regex_traits<char>>::__add_char[abi:ne180100]((uint64_t)v10, 95);
LABEL_19:
      ++v3;
      break;
  }
  return v3;
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_character_escape<char const*>(std::basic_regex<char> *a1, unsigned __int8 *a2, unsigned __int8 *a3, uint64_t *a4)
{
  int v4 = a2;
  if (a2 != a3)
  {
    uint64_t v5 = *a2;
    std::basic_regex<char>::value_type v6 = v5;
    if ((char)v5 > 109)
    {
      char v7 = 0;
      switch((char)v5)
      {
        case 'n':
          if (!a4)
          {
            std::basic_regex<char>::value_type v6 = 10;
            goto LABEL_69;
          }
          if (*((char *)a4 + 23) < 0)
          {
            a4[1] = 1;
            a4 = (uint64_t *)*a4;
          }
          else
          {
            *((unsigned char *)a4 + 23) = 1;
          }
          __int16 v18 = 10;
          goto LABEL_81;
        case 'r':
          if (!a4)
          {
            std::basic_regex<char>::value_type v6 = 13;
            goto LABEL_69;
          }
          if (*((char *)a4 + 23) < 0)
          {
            a4[1] = 1;
            a4 = (uint64_t *)*a4;
          }
          else
          {
            *((unsigned char *)a4 + 23) = 1;
          }
          __int16 v18 = 13;
          goto LABEL_81;
        case 't':
          if (!a4)
          {
            std::basic_regex<char>::value_type v6 = 9;
            goto LABEL_69;
          }
          if (*((char *)a4 + 23) < 0)
          {
            a4[1] = 1;
            a4 = (uint64_t *)*a4;
          }
          else
          {
            *((unsigned char *)a4 + 23) = 1;
          }
          __int16 v18 = 9;
          goto LABEL_81;
        case 'u':
          if (v4 + 1 == a3) {
            goto LABEL_91;
          }
          int v8 = v4[1];
          if ((v8 & 0xF8) != 0x30 && (v8 & 0xFE) != 0x38 && (v8 | 0x20u) - 97 >= 6) {
            goto LABEL_91;
          }
          v4 += 2;
          if (v4 == a3) {
            goto LABEL_91;
          }
          int v9 = *v4;
          char v10 = -48;
          if ((v9 & 0xF8) == 0x30 || (v9 & 0xFE) == 0x38) {
            goto LABEL_28;
          }
          v9 |= 0x20u;
          if ((v9 - 97) >= 6) {
            goto LABEL_91;
          }
          char v10 = -87;
LABEL_28:
          char v7 = 16 * (v10 + v9);
LABEL_29:
          if (v4 + 1 == a3) {
            goto LABEL_91;
          }
          int v11 = v4[1];
          char v12 = -48;
          if ((v11 & 0xF8) == 0x30 || (v11 & 0xFE) == 0x38) {
            goto LABEL_34;
          }
          v11 |= 0x20u;
          if ((v11 - 97) >= 6) {
            goto LABEL_91;
          }
          char v12 = -87;
LABEL_34:
          if (v4 + 2 == a3) {
            goto LABEL_91;
          }
          int v13 = v4[2];
          char v14 = -48;
          if ((v13 & 0xF8) == 0x30 || (v13 & 0xFE) == 0x38) {
            goto LABEL_39;
          }
          v13 |= 0x20u;
          if ((v13 - 97) >= 6) {
            goto LABEL_91;
          }
          char v14 = -87;
LABEL_39:
          std::basic_regex<char>::value_type v15 = v14 + v13 + 16 * (v12 + v11 + v7);
          if (a4)
          {
            if (*((char *)a4 + 23) < 0)
            {
              a4[1] = 1;
              a4 = (uint64_t *)*a4;
            }
            else
            {
              *((unsigned char *)a4 + 23) = 1;
            }
            *(unsigned char *)a4 = v15;
            *((unsigned char *)a4 + 1) = 0;
          }
          else
          {
            std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, v15);
          }
          v4 += 3;
          return v4;
        case 'v':
          if (!a4)
          {
            std::basic_regex<char>::value_type v6 = 11;
            goto LABEL_69;
          }
          if (*((char *)a4 + 23) < 0)
          {
            a4[1] = 1;
            a4 = (uint64_t *)*a4;
          }
          else
          {
            *((unsigned char *)a4 + 23) = 1;
          }
          __int16 v18 = 11;
          break;
        case 'x':
          goto LABEL_29;
        default:
          goto LABEL_53;
      }
      goto LABEL_81;
    }
    if ((char)v5 == 48)
    {
      if (a4)
      {
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        *(_WORD *)a4 = 0;
        return ++v4;
      }
      std::basic_regex<char>::value_type v6 = 0;
      goto LABEL_69;
    }
    if ((char)v5 != 99)
    {
      if ((char)v5 == 102)
      {
        if (a4)
        {
          if (*((char *)a4 + 23) < 0)
          {
            a4[1] = 1;
            a4 = (uint64_t *)*a4;
          }
          else
          {
            *((unsigned char *)a4 + 23) = 1;
          }
          __int16 v18 = 12;
LABEL_81:
          *(_WORD *)a4 = v18;
          return ++v4;
        }
        std::basic_regex<char>::value_type v6 = 12;
LABEL_69:
        std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, v6);
        return ++v4;
      }
LABEL_53:
      if ((char)v5 != 95 && ((char)v5 < 0 || (a1->__traits_.__ct_->__tab_[v5] & 0x500) == 0))
      {
        if (a4)
        {
          if (*((char *)a4 + 23) < 0)
          {
            a4[1] = 1;
            a4 = (uint64_t *)*a4;
          }
          else
          {
            *((unsigned char *)a4 + 23) = 1;
          }
          *(unsigned char *)a4 = v5;
          *((unsigned char *)a4 + 1) = 0;
          return ++v4;
        }
        goto LABEL_69;
      }
LABEL_91:
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)3>();
    }
    if (v4 + 1 == a3) {
      goto LABEL_91;
    }
    unsigned __int8 v16 = v4[1];
    if (((v16 & 0xDF) - 65) > 0x19u) {
      goto LABEL_91;
    }
    std::basic_regex<char>::value_type v17 = v16 & 0x1F;
    if (a4)
    {
      if (*((char *)a4 + 23) < 0)
      {
        a4[1] = 1;
        a4 = (uint64_t *)*a4;
      }
      else
      {
        *((unsigned char *)a4 + 23) = 1;
      }
      *(unsigned char *)a4 = v17;
      *((unsigned char *)a4 + 1) = 0;
    }
    else
    {
      std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, v17);
    }
    v4 += 2;
  }
  return v4;
}

void std::basic_regex<char,std::regex_traits<char>>::__push_char(std::basic_regex<char> *this, std::basic_regex<char>::value_type __c)
{
  std::basic_regex<_CharT, _Traits>::flag_type flags = this->__flags_;
  if ((flags & 1) == 0)
  {
    if ((flags & 8) == 0) {
      operator new();
    }
    operator new();
  }
  operator new();
}

void sub_1D34FFE14(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v1, 0x10E1C4010F5D982);
  _Unwind_Resume(a1);
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)4>()
{
  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D9436450](exception, 4);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_1D34FFE7C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::basic_regex<char,std::regex_traits<char>>::__push_back_ref(std::basic_regex<char> *this, int __i)
{
  std::basic_regex<_CharT, _Traits>::flag_type flags = this->__flags_;
  if ((flags & 1) == 0)
  {
    if ((flags & 8) == 0) {
      operator new();
    }
    operator new();
  }
  operator new();
}

uint64_t std::__match_char_icase<char,std::regex_traits<char>>::__match_char_icase[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)a1 = &unk_1F2ABB000;
  *(void *)(a1 + 8) = a4;
  std::locale::locale((std::locale *)(a1 + 16), (const std::locale *)a2);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 8);
  *(unsigned char *)(a1 + 40) = (*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 8) + 40))(*(void *)(a2 + 8), a3);
  return a1;
}

void sub_1D3500054(_Unwind_Exception *a1)
{
  std::locale::~locale(v2);
  uint64_t v4 = (uint64_t)v1[1];
  if (v4) {
    std::shared_ptr<std::__empty_state<char>>::shared_ptr[abi:ne180100]<std::__empty_state<char>,void>(v4);
  }
  _Unwind_Resume(a1);
}

std::locale *std::__match_char_icase<char,std::regex_traits<char>>::~__match_char_icase(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_1F2ABB000;
  std::locale::~locale(a1 + 2);
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

void std::__match_char_icase<char,std::regex_traits<char>>::~__match_char_icase(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_1F2ABB000;
  std::locale::~locale(a1 + 2);
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  JUMPOUT(0x1D9436740);
}

uint64_t std::__match_char_icase<char,std::regex_traits<char>>::__exec(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(char **)(a2 + 16);
  if (v3 == *(char **)(a2 + 24)
    || (uint64_t v4 = result,
        __n128 result = (*(uint64_t (**)(void, void))(**(void **)(result + 24) + 40))(*(void *)(result + 24), *v3), *(unsigned __int8 *)(v4 + 40) != result))
  {
    uint64_t v5 = 0;
    *(_DWORD *)a2 = -993;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    ++*(void *)(a2 + 16);
    uint64_t v5 = *(void *)(v4 + 8);
  }
  *(void *)(a2 + 80) = v5;
  return result;
}

std::locale *std::__match_char_collate<char,std::regex_traits<char>>::~__match_char_collate(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_1F2ABB090;
  std::locale::~locale(a1 + 2);
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

void std::__match_char_collate<char,std::regex_traits<char>>::~__match_char_collate(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_1F2ABB090;
  std::locale::~locale(a1 + 2);
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  JUMPOUT(0x1D9436740);
}

uint64_t std::__match_char_collate<char,std::regex_traits<char>>::__exec(uint64_t result, uint64_t a2)
{
  std::vector<std::pair<unsigned long, const char *>>::size_type v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) || *v2 != *(unsigned __int8 *)(result + 40))
  {
    uint64_t v3 = 0;
    *(_DWORD *)a2 = -993;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    uint64_t v3 = *(void *)(result + 8);
  }
  *(void *)(a2 + 80) = v3;
  return result;
}

void (__cdecl ***std::__match_char<char>::~__match_char(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  std::vector<std::pair<unsigned long, const char *>>::size_type v2 = a1[1];
  if (v2) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  }
  return a1;
}

void std::__match_char<char>::~__match_char(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  uint64_t v1 = a1[1];
  if (v1) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v1 + 1))(v1);
  }
  JUMPOUT(0x1D9436740);
}

uint64_t std::__match_char<char>::__exec(uint64_t result, uint64_t a2)
{
  std::vector<std::pair<unsigned long, const char *>>::size_type v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) || *v2 != *(unsigned __int8 *)(result + 16))
  {
    uint64_t v3 = 0;
    *(_DWORD *)a2 = -993;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    uint64_t v3 = *(void *)(result + 8);
  }
  *(void *)(a2 + 80) = v3;
  return result;
}

std::locale *std::__back_ref_icase<char,std::regex_traits<char>>::~__back_ref_icase(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_1F2ABAEE8;
  std::locale::~locale(a1 + 2);
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

void std::__back_ref_icase<char,std::regex_traits<char>>::~__back_ref_icase(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_1F2ABAEE8;
  std::locale::~locale(a1 + 2);
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  JUMPOUT(0x1D9436740);
}

uint64_t std::__back_ref_icase<char,std::regex_traits<char>>::__exec(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 32) + 24 * (*(_DWORD *)(result + 40) - 1);
  if (*(unsigned char *)(v3 + 16))
  {
    uint64_t v4 = *(void *)(v3 + 8) - *(void *)v3;
    uint64_t v5 = *(void *)(a2 + 16);
    if (*(void *)(a2 + 24) - v5 >= v4)
    {
      uint64_t v7 = result;
      if (v4 < 1)
      {
LABEL_9:
        *(_DWORD *)a2 = -994;
        *(void *)(a2 + 16) = v5 + v4;
        uint64_t v6 = *(void *)(v7 + 8);
        goto LABEL_10;
      }
      uint64_t v8 = 0;
      while (1)
      {
        int v9 = (*(uint64_t (**)(void, void))(**(void **)(v7 + 24) + 40))(*(void *)(v7 + 24), *(char *)(*(void *)v3 + v8));
        __n128 result = (*(uint64_t (**)(void, void))(**(void **)(v7 + 24) + 40))(*(void *)(v7 + 24), *(char *)(*(void *)(a2 + 16) + v8));
        if (v9 != result) {
          break;
        }
        if (v4 == ++v8)
        {
          uint64_t v5 = *(void *)(a2 + 16);
          goto LABEL_9;
        }
      }
    }
  }
  uint64_t v6 = 0;
  *(_DWORD *)a2 = -993;
LABEL_10:
  *(void *)(a2 + 80) = v6;
  return result;
}

std::locale *std::__back_ref_collate<char,std::regex_traits<char>>::~__back_ref_collate(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_1F2ABAFD0;
  std::locale::~locale(a1 + 2);
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  return a1;
}

void std::__back_ref_collate<char,std::regex_traits<char>>::~__back_ref_collate(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)&unk_1F2ABAFD0;
  std::locale::~locale(a1 + 2);
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8))(locale);
  }
  JUMPOUT(0x1D9436740);
}

uint64_t std::__back_ref_collate<char,std::regex_traits<char>>::__exec(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(result + 40) - 1;
  uint64_t v3 = *(void *)(a2 + 32);
  if (*(unsigned char *)(v3 + 24 * v2 + 16))
  {
    uint64_t v4 = (unsigned __int8 **)(v3 + 24 * v2);
    uint64_t v5 = *v4;
    uint64_t v6 = v4[1] - *v4;
    uint64_t v7 = *(void *)(a2 + 16);
    if (*(void *)(a2 + 24) - v7 >= v6)
    {
      if (v6 < 1)
      {
LABEL_8:
        *(_DWORD *)a2 = -994;
        *(void *)(a2 + 16) = v7 + v6;
        uint64_t v8 = *(void *)(result + 8);
        goto LABEL_9;
      }
      int v9 = *(unsigned __int8 **)(a2 + 16);
      uint64_t v10 = v6;
      while (1)
      {
        int v12 = *v5++;
        int v11 = v12;
        int v13 = *v9++;
        if (v11 != v13) {
          break;
        }
        if (!--v10) {
          goto LABEL_8;
        }
      }
    }
  }
  uint64_t v8 = 0;
  *(_DWORD *)a2 = -993;
LABEL_9:
  *(void *)(a2 + 80) = v8;
  return result;
}

void (__cdecl ***std::__back_ref<char>::~__back_ref(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  unsigned int v2 = a1[1];
  if (v2) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  }
  return a1;
}

void std::__back_ref<char>::~__back_ref(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  uint64_t v1 = a1[1];
  if (v1) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v1 + 1))(v1);
  }
  JUMPOUT(0x1D9436740);
}

unsigned int *std::__back_ref<char>::__exec(unsigned int *result, uint64_t a2)
{
  unint64_t v2 = result[4];
  uint64_t v3 = *(void *)(a2 + 32);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a2 + 40) - v3) >> 3) < v2) {
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)4>();
  }
  unsigned int v5 = v2 - 1;
  if (*(unsigned char *)(v3 + 24 * v5 + 16)
    && (uint64_t v6 = result,
        uint64_t v7 = v3 + 24 * v5,
        __n128 result = *(unsigned int **)v7,
        int64_t v8 = *(void *)(v7 + 8) - *(void *)v7,
        uint64_t v9 = *(void *)(a2 + 16),
        *(void *)(a2 + 24) - v9 >= v8)
    && (__n128 result = (unsigned int *)memcmp(result, *(const void **)(a2 + 16), v8), !result))
  {
    *(_DWORD *)a2 = -994;
    *(void *)(a2 + 16) = v9 + v8;
    uint64_t v10 = *((void *)v6 + 1);
  }
  else
  {
    uint64_t v10 = 0;
    *(_DWORD *)a2 = -993;
  }
  *(void *)(a2 + 80) = v10;
  return result;
}

std::__bracket_expression<char, std::regex_traits<char>> *__cdecl std::basic_regex<char,std::regex_traits<char>>::__start_matching_list(std::basic_regex<char> *this, BOOL __negate)
{
}

void sub_1D3500B68(_Unwind_Exception *a1)
{
  MEMORY[0x1D9436740](v1, 0x10F1C4061CF1F02);
  _Unwind_Resume(a1);
}

void std::__bracket_expression<char,std::regex_traits<char>>::__add_char[abi:ne180100](uint64_t a1, uint64_t a2)
{
  char v2 = a2;
  if (*(unsigned char *)(a1 + 169))
  {
    char v2 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a2);
    unsigned int v5 = *(unsigned char **)(a1 + 48);
    unint64_t v4 = *(void *)(a1 + 56);
    if ((unint64_t)v5 >= v4)
    {
      uint64_t v6 = (unint64_t *)(a1 + 40);
      unint64_t v7 = *(void *)(a1 + 40);
      int64_t v8 = &v5[-v7];
      uint64_t v9 = (uint64_t)&v5[-v7 + 1];
      if (v9 >= 0)
      {
        unint64_t v10 = v4 - v7;
        if (2 * v10 > v9) {
          uint64_t v9 = 2 * v10;
        }
        if (v10 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v11 = v9;
        }
        if (v11) {
          int v12 = operator new(v11);
        }
        else {
          int v12 = 0;
        }
        std::vector<std::csub_match>::size_type v20 = &v8[(void)v12];
        std::pair<const char *, const char *> v21 = (char *)v12 + v11;
        v8[(void)v12] = v2;
        uint64_t v19 = (uint64_t)&v8[(void)v12 + 1];
        if (v5 != (unsigned char *)v7)
        {
          std::pair<const char *, const char *> v22 = &v5[~v7];
          do
          {
            char v23 = *--v5;
            (v22--)[(void)v12] = v23;
          }
          while (v5 != (unsigned char *)v7);
LABEL_45:
          unsigned int v5 = (unsigned char *)*v6;
          goto LABEL_47;
        }
        goto LABEL_46;
      }
LABEL_50:
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    goto LABEL_22;
  }
  uint64_t v6 = (unint64_t *)(a1 + 40);
  unsigned int v5 = *(unsigned char **)(a1 + 48);
  unint64_t v13 = *(void *)(a1 + 56);
  if (!*(unsigned char *)(a1 + 170))
  {
    if ((unint64_t)v5 >= v13)
    {
      unint64_t v24 = *v6;
      long long v25 = &v5[-*v6];
      unint64_t v26 = (unint64_t)(v25 + 1);
      if ((uint64_t)(v25 + 1) >= 0)
      {
        unint64_t v27 = v13 - v24;
        if (2 * v27 > v26) {
          unint64_t v26 = 2 * v27;
        }
        if (v27 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v28 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v28 = v26;
        }
        if (v28) {
          int v12 = operator new(v28);
        }
        else {
          int v12 = 0;
        }
        std::vector<std::csub_match>::size_type v20 = &v25[(void)v12];
        std::pair<const char *, const char *> v21 = (char *)v12 + v28;
        v25[(void)v12] = v2;
        uint64_t v19 = (uint64_t)&v25[(void)v12 + 1];
        if (v5 != (unsigned char *)v24)
        {
          uint64_t v31 = &v5[~v24];
          do
          {
            char v32 = *--v5;
            (v31--)[(void)v12] = v32;
          }
          while (v5 != (unsigned char *)v24);
          goto LABEL_45;
        }
        goto LABEL_46;
      }
      goto LABEL_50;
    }
LABEL_22:
    *unsigned int v5 = v2;
    uint64_t v19 = (uint64_t)(v5 + 1);
    goto LABEL_49;
  }
  if ((unint64_t)v5 < v13) {
    goto LABEL_22;
  }
  unint64_t v14 = *v6;
  std::basic_regex<char>::value_type v15 = &v5[-*v6];
  unint64_t v16 = (unint64_t)(v15 + 1);
  if ((uint64_t)(v15 + 1) < 0) {
    goto LABEL_50;
  }
  unint64_t v17 = v13 - v14;
  if (2 * v17 > v16) {
    unint64_t v16 = 2 * v17;
  }
  if (v17 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v18 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v18 = v16;
  }
  if (v18) {
    int v12 = operator new(v18);
  }
  else {
    int v12 = 0;
  }
  std::vector<std::csub_match>::size_type v20 = &v15[(void)v12];
  std::pair<const char *, const char *> v21 = (char *)v12 + v18;
  v15[(void)v12] = v2;
  uint64_t v19 = (uint64_t)&v15[(void)v12 + 1];
  if (v5 != (unsigned char *)v14)
  {
    uint64_t v29 = &v5[~v14];
    do
    {
      char v30 = *--v5;
      (v29--)[(void)v12] = v30;
    }
    while (v5 != (unsigned char *)v14);
    goto LABEL_45;
  }
LABEL_46:
  int v12 = v20;
LABEL_47:
  *(void *)(a1 + 40) = v12;
  *(void *)(a1 + 48) = v19;
  *(void *)(a1 + 56) = v21;
  if (v5) {
    operator delete(v5);
  }
LABEL_49:
  *(void *)(a1 + 48) = v19;
}

uint64_t std::__bracket_expression<char,std::regex_traits<char>>::__bracket_expression[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3, char a4, char a5, char a6)
{
  *(void *)(a1 + 8) = a3;
  size_t v11 = (const std::locale *)(a1 + 16);
  std::locale::locale((std::locale *)(a1 + 16), (const std::locale *)a2);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(unsigned char *)(a1 + 168) = a4;
  *(unsigned char *)(a1 + 169) = a5;
  *(unsigned char *)(a1 + 170) = a6;
  std::locale::locale(&v16, v11);
  std::locale::name(&v17, &v16);
  std::string::size_type size = HIBYTE(v17.__r_.__value_.__r.__words[2]);
  if ((v17.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v17.__r_.__value_.__l.__size_;
  }
  if (size == 1)
  {
    unint64_t v13 = (std::string *)v17.__r_.__value_.__r.__words[0];
    if ((v17.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v13 = &v17;
    }
    BOOL v14 = v13->__r_.__value_.__s.__data_[0] != 67;
    if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_9;
    }
  }
  else
  {
    BOOL v14 = 1;
    if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
LABEL_9:
    }
      operator delete(v17.__r_.__value_.__l.__data_);
  }
  std::locale::~locale(&v16);
  *(unsigned char *)(a1 + 171) = v14;
  return a1;
}

void sub_1D3500F20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  std::locale::~locale((std::locale *)&a9);
  a10 = v10 + 17;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&a10);
  std::basic_regex<char>::value_type v15 = (void *)v10[14];
  if (v15)
  {
    v10[15] = v15;
    operator delete(v15);
  }
  std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a10);
  std::locale v16 = (void *)v10[8];
  if (v16)
  {
    v10[9] = v16;
    operator delete(v16);
  }
  std::string v17 = *v13;
  if (*v13)
  {
    v10[6] = v17;
    operator delete(v17);
  }
  std::locale::~locale(v12);
  void *v10 = v11;
  uint64_t v18 = v10[1];
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  _Unwind_Resume(a1);
}

void std::__bracket_expression<char,std::regex_traits<char>>::~__bracket_expression(std::locale *a1)
{
  std::__bracket_expression<char,std::regex_traits<char>>::~__bracket_expression(a1);
  JUMPOUT(0x1D9436740);
}

void std::__bracket_expression<char,std::regex_traits<char>>::__exec(const std::__bracket_expression<char, std::regex_traits<char>> *this, std::__bracket_expression<char, std::regex_traits<char>>::__state *a2)
{
  current = a2->__current_;
  last = a2->__last_;
  if (current == last)
  {
    uint64_t v18 = 0;
    BOOL negate = this->__negate_;
    goto LABEL_155;
  }
  if (!this->__might_have_digraph_ || current + 1 == last) {
    goto LABEL_27;
  }
  signed __int8 v6 = *current;
  unsigned __int8 v86 = *current;
  signed __int8 v7 = current[1];
  unsigned __int8 v87 = v7;
  if (this->__icase_)
  {
    unsigned __int8 v86 = ((uint64_t (*)(const std::ctype<char> *, void))this->__traits_.__ct_->do_tolower)(this->__traits_.__ct_, v6);
    unsigned __int8 v87 = ((uint64_t (*)(const std::ctype<char> *, void))this->__traits_.__ct_->do_tolower)(this->__traits_.__ct_, v7);
  }
  std::regex_traits<char>::__lookup_collatename<char *>((uint64_t)&this->__traits_, (char *)&v86, (char *)&v88, (uint64_t)&__p);
  if ((v85 & 0x80000000) == 0)
  {
    if (v85) {
      goto LABEL_8;
    }
LABEL_27:
    BOOL negate = 0;
    uint64_t v18 = 1;
    goto LABEL_28;
  }
  size_t v19 = v84;
  operator delete(__p);
  if (!v19) {
    goto LABEL_27;
  }
LABEL_8:
  std::vector<std::pair<char, char>>::pointer begin = this->__digraphs_.__begin_;
  uint64_t v9 = (char *)this->__digraphs_.__end_ - (char *)begin;
  if (v9)
  {
    uint64_t v10 = v9 >> 1;
    if ((unint64_t)(v9 >> 1) <= 1) {
      uint64_t v10 = 1;
    }
    p_second = &begin->second;
    do
    {
      if (v86 == *(p_second - 1) && v87 == *p_second) {
        goto LABEL_152;
      }
      p_second += 2;
      --v10;
    }
    while (v10);
  }
  if (!this->__collate_ || this->__ranges_.__begin_ == this->__ranges_.__end_)
  {
    BOOL negate = 0;
  }
  else
  {
    std::regex_traits<char>::transform<char *>((uint64_t)&this->__traits_, (char *)&v86, (char *)&v88);
    unint64_t v13 = this->__ranges_.__begin_;
    if (this->__ranges_.__end_ == v13)
    {
LABEL_24:
      BOOL negate = 0;
      int v17 = 0;
    }
    else
    {
      uint64_t v14 = 0;
      unint64_t v15 = 0;
      while ((int)(std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v13[v14].first.__r_.__value_.__r.__words, &__p) << 24) > 0xFFFFFF|| (int)(std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&__p, (void **)&this->__ranges_.__begin_[v14].second.__r_.__value_.__l.__data_) << 24) >= 0x1000000)
      {
        ++v15;
        unint64_t v13 = this->__ranges_.__begin_;
        ++v14;
        if (v15 >= 0xAAAAAAAAAAAAAAABLL * (((char *)this->__ranges_.__end_ - (char *)v13) >> 4)) {
          goto LABEL_24;
        }
      }
      BOOL negate = 1;
      int v17 = 5;
    }
    if (v85 < 0) {
      operator delete(__p);
    }
    if (negate) {
      goto LABEL_129;
    }
  }
  if (this->__equivalences_.__begin_ == this->__equivalences_.__end_) {
    goto LABEL_134;
  }
  std::regex_traits<char>::__transform_primary<char *>((uint64_t)&this->__traits_, (char *)&v86, (char *)&v88, (uint64_t)&__p);
  std::vector<std::string>::pointer v54 = this->__equivalences_.__begin_;
  uint64_t v55 = v85;
  int64_t v56 = (char *)this->__equivalences_.__end_ - (char *)v54;
  if (v56)
  {
    uint64_t v57 = 0;
    unint64_t v58 = v56 / 24;
    long long v60 = __p;
    size_t v59 = v84;
    if (v85 >= 0) {
      size_t v61 = v85;
    }
    else {
      size_t v61 = v84;
    }
    if (v58 <= 1) {
      uint64_t v62 = 1;
    }
    else {
      uint64_t v62 = v56 / 24;
    }
    BOOL v63 = 1;
    while (1)
    {
      int v64 = &v54[v57];
      std::string::size_type size = HIBYTE(v64->__r_.__value_.__r.__words[2]);
      int v66 = (char)size;
      if ((size & 0x80u) != 0) {
        std::string::size_type size = v64->__r_.__value_.__l.__size_;
      }
      if (v61 == size)
      {
        if (v66 >= 0) {
          uint64_t v67 = &v54[v57];
        }
        else {
          uint64_t v67 = (std::string *)v64->__r_.__value_.__r.__words[0];
        }
        if ((v55 & 0x80) == 0)
        {
          if (v55)
          {
            std::vector<std::csub_match>::pointer p_p = &__p;
            uint64_t v69 = v55;
            do
            {
              if (*(unsigned __int8 *)p_p != v67->__r_.__value_.__s.__data_[0]) {
                goto LABEL_122;
              }
              std::vector<std::csub_match>::pointer p_p = (void **)((char *)p_p + 1);
              uint64_t v67 = (std::string *)((char *)v67 + 1);
              --v69;
            }
            while (v69);
            BOOL negate = 1;
            int v17 = 5;
            goto LABEL_126;
          }
          BOOL negate = 1;
          if (v63) {
            goto LABEL_154;
          }
LABEL_134:
          if ((char)v86 < 0)
          {
            neg_std::regex_traits<char>::char_class_type mask = this->__neg_mask_;
            goto LABEL_147;
          }
          std::regex_traits<char>::char_class_type mask = this->__mask_;
          tab = this->__traits_.__ct_->__tab_;
          std::ctype_base::mask v73 = tab[v86];
          if ((v73 & mask) == 0 && (v86 != 95 || (mask & 0x80) == 0)
            || (char)v87 < 0
            || (tab[v87] & mask) == 0 && ((mask & 0x80) == 0 || v87 != 95))
          {
            neg_std::regex_traits<char>::char_class_type mask = this->__neg_mask_;
            if ((v73 & neg_mask) != 0 || v86 == 95 && (neg_mask & 0x80) != 0)
            {
LABEL_151:
              int v75 = negate;
              goto LABEL_153;
            }
LABEL_147:
            if (((char)v87 & 0x80000000) == 0)
            {
              if ((this->__traits_.__ct_->__tab_[v87] & neg_mask) != 0) {
                goto LABEL_151;
              }
              int v75 = 1;
              if (v87 == 95 && (neg_mask & 0x80) != 0) {
                goto LABEL_151;
              }
LABEL_153:
              BOOL negate = v75;
LABEL_154:
              uint64_t v18 = 2;
              goto LABEL_155;
            }
          }
LABEL_152:
          int v75 = 1;
          goto LABEL_153;
        }
        unint64_t v80 = v58;
        uint64_t v82 = v55;
        int v70 = memcmp(v60, v67, v59);
        unint64_t v58 = v80;
        uint64_t v55 = v82;
        if (!v70) {
          break;
        }
      }
LABEL_122:
      BOOL v63 = ++v57 < v58;
      if (v57 == v62) {
        goto LABEL_125;
      }
    }
    int v17 = 5;
    BOOL negate = 1;
    goto LABEL_127;
  }
  BOOL v63 = 0;
LABEL_125:
  int v17 = 0;
LABEL_126:
  if ((v55 & 0x80) != 0) {
LABEL_127:
  }
    operator delete(__p);
  if (!v63) {
    goto LABEL_134;
  }
LABEL_129:
  if (v17) {
    goto LABEL_154;
  }
  uint64_t v18 = 2;
LABEL_28:
  unsigned __int8 v20 = *a2->__current_;
  unsigned __int8 v86 = v20;
  if (this->__icase_)
  {
    unsigned __int8 v20 = ((uint64_t (*)(const std::ctype<char> *, void))this->__traits_.__ct_->do_tolower)(this->__traits_.__ct_, (char)v20);
    unsigned __int8 v86 = v20;
  }
  std::vector<char>::pointer v21 = this->__chars_.__begin_;
  unint64_t v22 = this->__chars_.__end_ - v21;
  if (v22)
  {
    if (v22 <= 1) {
      unint64_t v22 = 1;
    }
    while (1)
    {
      int v23 = *v21++;
      if (v23 == v20) {
        break;
      }
      if (!--v22) {
        goto LABEL_35;
      }
    }
LABEL_46:
    BOOL negate = 1;
    goto LABEL_155;
  }
LABEL_35:
  std::regex_traits<char>::char_class_type v24 = this->__neg_mask_;
  if (v24 || this->__neg_chars_.__begin_ != this->__neg_chars_.__end_)
  {
    if ((v20 & 0x80) != 0 || (this->__traits_.__ct_->__tab_[v20] & v24) == 0) {
      int v25 = (v20 == 95) & (v24 >> 7);
    }
    else {
      LOBYTE(v25) = 1;
    }
    std::vector<char>::pointer end = this->__neg_chars_.__end_;
    std::vector<char>::pointer v27 = (std::vector<char>::pointer)memchr(this->__neg_chars_.__begin_, (char)v20, end - this->__neg_chars_.__begin_);
    size_t v28 = v27 ? v27 : end;
    if ((v25 & 1) == 0 && v28 == end) {
      goto LABEL_46;
    }
  }
  std::vector<std::pair<std::string, std::string>>::pointer v29 = this->__ranges_.__begin_;
  std::vector<std::pair<std::string, std::string>>::pointer v30 = this->__ranges_.__end_;
  if (v29 != v30)
  {
    if (this->__collate_)
    {
      std::regex_traits<char>::transform<char *>((uint64_t)&this->__traits_, (char *)&v86, (char *)&v87);
      std::vector<std::pair<std::string, std::string>>::pointer v29 = this->__ranges_.__begin_;
      std::vector<std::pair<std::string, std::string>>::pointer v30 = this->__ranges_.__end_;
    }
    else
    {
      char v85 = 1;
      LOWORD(__p) = v20;
    }
    if (v30 == v29)
    {
LABEL_57:
      char v33 = 0;
    }
    else
    {
      uint64_t v31 = 0;
      unint64_t v32 = 0;
      while ((int)(std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v29[v31].first.__r_.__value_.__r.__words, &__p) << 24) > 0xFFFFFF|| (int)(std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&__p, (void **)&this->__ranges_.__begin_[v31].second.__r_.__value_.__l.__data_) << 24) >= 0x1000000)
      {
        ++v32;
        std::vector<std::pair<std::string, std::string>>::pointer v29 = this->__ranges_.__begin_;
        ++v31;
        if (v32 >= 0xAAAAAAAAAAAAAAABLL * (((char *)this->__ranges_.__end_ - (char *)v29) >> 4)) {
          goto LABEL_57;
        }
      }
      char v33 = 1;
      BOOL negate = 1;
    }
    if (v85 < 0) {
      operator delete(__p);
    }
    if (v33) {
      goto LABEL_155;
    }
  }
  if (this->__equivalences_.__begin_ == this->__equivalences_.__end_) {
    goto LABEL_90;
  }
  std::regex_traits<char>::__transform_primary<char *>((uint64_t)&this->__traits_, (char *)&v86, (char *)&v87, (uint64_t)&__p);
  std::vector<std::string>::pointer v34 = this->__equivalences_.__begin_;
  uint64_t v35 = v85;
  int64_t v36 = (char *)this->__equivalences_.__end_ - (char *)v34;
  if (v36)
  {
    uint64_t v81 = v18;
    uint64_t v37 = 0;
    unint64_t v38 = v36 / 24;
    std::string::size_type v39 = __p;
    size_t v40 = v84;
    if (v85 >= 0) {
      size_t v41 = v85;
    }
    else {
      size_t v41 = v84;
    }
    if (v38 <= 1) {
      uint64_t v42 = 1;
    }
    else {
      uint64_t v42 = v36 / 24;
    }
    BOOL v43 = 1;
    while (1)
    {
      long long v44 = &v34[v37];
      std::string::size_type v45 = HIBYTE(v44->__r_.__value_.__r.__words[2]);
      int v46 = (char)v45;
      if ((v45 & 0x80u) != 0) {
        std::string::size_type v45 = v44->__r_.__value_.__l.__size_;
      }
      if (v41 == v45)
      {
        if (v46 >= 0) {
          uint64_t v47 = &v34[v37];
        }
        else {
          uint64_t v47 = (std::string *)v44->__r_.__value_.__r.__words[0];
        }
        if ((v35 & 0x80) != 0)
        {
          BOOL v79 = negate;
          size_t v50 = v41;
          char v78 = v34;
          int v51 = memcmp(v39, v47, v40);
          std::vector<std::string>::pointer v34 = v78;
          size_t v41 = v50;
          BOOL negate = v79;
          if (!v51)
          {
            BOOL negate = 1;
            uint64_t v18 = v81;
            goto LABEL_88;
          }
        }
        else
        {
          if (!v35)
          {
            BOOL negate = 1;
            uint64_t v18 = v81;
            if (!v43) {
              goto LABEL_90;
            }
            goto LABEL_155;
          }
          char v48 = &__p;
          uint64_t v49 = v35;
          while (*(unsigned __int8 *)v48 == v47->__r_.__value_.__s.__data_[0])
          {
            char v48 = (void **)((char *)v48 + 1);
            uint64_t v47 = (std::string *)((char *)v47 + 1);
            if (!--v49)
            {
              BOOL negate = 1;
              goto LABEL_85;
            }
          }
        }
      }
      BOOL v43 = ++v37 < v38;
      if (v37 == v42)
      {
LABEL_85:
        uint64_t v18 = v81;
        if ((v35 & 0x80) == 0) {
          goto LABEL_89;
        }
        goto LABEL_88;
      }
    }
  }
  BOOL v43 = 0;
  if (v85 < 0) {
LABEL_88:
  }
    operator delete(__p);
LABEL_89:
  if (!v43)
  {
LABEL_90:
    if ((char)v86 < 0) {
      goto LABEL_155;
    }
    std::regex_traits<char>::char_class_type v52 = this->__mask_;
    if ((this->__traits_.__ct_->__tab_[v86] & v52) == 0)
    {
      int v53 = (v52 >> 7) & 1;
      if (v86 != 95) {
        int v53 = 0;
      }
      if (v53 != 1) {
        goto LABEL_155;
      }
    }
    goto LABEL_46;
  }
LABEL_155:
  if (negate == this->__negate_)
  {
    first = 0;
    int v77 = -993;
  }
  else
  {
    a2->__current_ += v18;
    first = this->__first_;
    int v77 = -995;
  }
  a2->__do_ = v77;
  a2->__node_ = first;
}

void std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  char v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    unsigned int v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48;
        std::__destroy_at[abi:ne180100]<std::pair<std::string,std::string>,0>(v4);
      }
      while ((void *)v4 != v2);
      unsigned int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string,std::string>,0>(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    char v2 = *(void **)a1;
    operator delete(v2);
  }
}

std::locale *std::__bracket_expression<char,std::regex_traits<char>>::~__bracket_expression(std::locale *a1)
{
  signed __int8 v7 = a1 + 17;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)&v7);
  locale = a1[14].__locale_;
  if (locale)
  {
    a1[15].__locale_ = locale;
    operator delete(locale);
  }
  signed __int8 v7 = a1 + 11;
  std::vector<std::pair<std::string,std::string>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v7);
  uint64_t v3 = a1[8].__locale_;
  if (v3)
  {
    a1[9].__locale_ = v3;
    operator delete(v3);
  }
  uint64_t v4 = a1[5].__locale_;
  if (v4)
  {
    a1[6].__locale_ = v4;
    operator delete(v4);
  }
  std::locale::~locale(a1 + 2);
  unsigned int v5 = a1[1].__locale_;
  if (v5) {
    (*(void (**)(std::locale::__imp *))(*(void *)v5 + 8))(v5);
  }
  return a1;
}

void std::regex_traits<char>::transform<char *>(uint64_t a1, char *a2, char *a3)
{
  std::string::__init_with_size[abi:ne180100]<char *,char *>(__p, a2, a3, a3 - a2);
  unint64_t v4 = v7;
  if ((v7 & 0x80u) == 0) {
    unsigned int v5 = __p;
  }
  else {
    unsigned int v5 = (void **)__p[0];
  }
  if ((v7 & 0x80u) != 0) {
    unint64_t v4 = (unint64_t)__p[1];
  }
  (*(void (**)(void, void **, char *))(**(void **)(a1 + 16) + 32))(*(void *)(a1 + 16), v5, (char *)v5 + v4);
  if ((char)v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1D3501A24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(void *a1, void **a2)
{
  size_t v2 = *((unsigned __int8 *)a1 + 23);
  size_t v3 = a1[1];
  if ((v2 & 0x80u) != 0)
  {
    a1 = (void *)*a1;
    size_t v2 = v3;
  }
  int v4 = *((char *)a2 + 23);
  if (v4 >= 0) {
    unsigned int v5 = a2;
  }
  else {
    unsigned int v5 = *a2;
  }
  if (v4 >= 0) {
    size_t v6 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v6 = (size_t)a2[1];
  }
  return std::operator<=>[abi:ne180100]<char,std::char_traits<char>>(a1, v2, v5, v6);
}

void std::regex_traits<char>::__lookup_collatename<char *>(uint64_t a1@<X0>, char *a2@<X1>, char *a3@<X2>, uint64_t a4@<X8>)
{
  std::string::__init_with_size[abi:ne180100]<char *,char *>(&__s, a2, a3, a3 - a2);
  *(void *)a4 = 0;
  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!__s.__r_.__value_.__l.__size_) {
      goto LABEL_9;
    }
    p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (!*((unsigned char *)&__s.__r_.__value_.__s + 23)) {
      return;
    }
    p_s = &__s;
  }
  std::__get_collation_name(&v11, (const char *)p_s);
  *(_OWORD *)a4 = *(_OWORD *)&v11.__r_.__value_.__l.__data_;
  unint64_t v7 = v11.__r_.__value_.__r.__words[2];
  *(void *)(a4 + 16) = *((void *)&v11.__r_.__value_.__l + 2);
  unint64_t v8 = HIBYTE(v7);
  if ((v8 & 0x80u) != 0) {
    unint64_t v8 = *(void *)(a4 + 8);
  }
  if (v8) {
    goto LABEL_9;
  }
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__s.__r_.__value_.__l.__size_ >= 3) {
      goto LABEL_9;
    }
  }
  else if (HIBYTE(__s.__r_.__value_.__r.__words[2]) >= 3u)
  {
    return;
  }
  (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 16) + 32))(&v11);
  if (*(char *)(a4 + 23) < 0) {
    operator delete(*(void **)a4);
  }
  *(std::string *)a4 = v11;
  if ((*(char *)(a4 + 23) & 0x80000000) == 0)
  {
    int v9 = *(unsigned __int8 *)(a4 + 23);
    if (v9 != 12 && v9 != 1)
    {
      *(unsigned char *)a4 = 0;
      *(unsigned char *)(a4 + 23) = 0;
      goto LABEL_9;
    }
    goto LABEL_23;
  }
  uint64_t v10 = *(void *)(a4 + 8);
  if (v10 == 1 || v10 == 12)
  {
LABEL_23:
    std::string::operator=((std::string *)a4, &__s);
    goto LABEL_9;
  }
  **(unsigned char **)a4 = 0;
  *(void *)(a4 + 8) = 0;
LABEL_9:
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__s.__r_.__value_.__l.__data_);
  }
}

void sub_1D3501BF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (*(char *)(v17 + 23) < 0) {
    operator delete(*(void **)v17);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::string::__init_with_size[abi:ne180100]<char *,char *>(void *result, char *a2, char *a3, unint64_t a4)
{
  int v4 = result;
  if (a4 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (a4 > 0x16)
  {
    uint64_t v8 = (a4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a4 | 7) != 0x17) {
      uint64_t v8 = a4 | 7;
    }
    uint64_t v9 = v8 + 1;
    __n128 result = operator new(v8 + 1);
    v4[1] = a4;
    v4[2] = v9 | 0x8000000000000000;
    void *v4 = result;
    int v4 = result;
  }
  else
  {
    *((unsigned char *)result + 23) = a4;
  }
  while (a2 != a3)
  {
    char v10 = *a2++;
    *(unsigned char *)int v4 = v10;
    int v4 = (void *)((char *)v4 + 1);
  }
  *(unsigned char *)int v4 = 0;
  return result;
}

uint64_t std::operator<=>[abi:ne180100]<char,std::char_traits<char>>(const void *a1, size_t a2, void *__s2, size_t a4)
{
  if (a4 >= a2) {
    size_t v7 = a2;
  }
  else {
    size_t v7 = a4;
  }
  int v8 = memcmp(a1, __s2, v7);
  if (v8)
  {
    if ((v8 & 0x80000000) == 0) {
      return 1;
    }
  }
  else
  {
    if (a2 == a4) {
      return 0;
    }
    if (a2 >= a4) {
      return 1;
    }
  }
  return 255;
}

void std::regex_traits<char>::__transform_primary<char *>(uint64_t a1@<X0>, char *a2@<X1>, char *a3@<X2>, uint64_t a4@<X8>)
{
  std::string::__init_with_size[abi:ne180100]<char *,char *>(__p, a2, a3, a3 - a2);
  unint64_t v6 = v12;
  if ((v12 & 0x80u) == 0) {
    size_t v7 = __p;
  }
  else {
    size_t v7 = (void **)__p[0];
  }
  if ((v12 & 0x80u) != 0) {
    unint64_t v6 = (unint64_t)__p[1];
  }
  (*(void (**)(void, void **, char *))(**(void **)(a1 + 16) + 32))(*(void *)(a1 + 16), v7, (char *)v7 + v6);
  uint64_t v8 = *(unsigned __int8 *)(a4 + 23);
  int v9 = (char)v8;
  if ((v8 & 0x80u) != 0) {
    uint64_t v8 = *(void *)(a4 + 8);
  }
  if (v8 != 1)
  {
    if (v8 == 12)
    {
      if (v9 >= 0) {
        char v10 = (unsigned char *)a4;
      }
      else {
        char v10 = *(unsigned char **)a4;
      }
      v10[11] = v10[3];
    }
    else if (v9 < 0)
    {
      **(unsigned char **)a4 = 0;
      *(void *)(a4 + 8) = 0;
    }
    else
    {
      *(unsigned char *)a4 = 0;
      *(unsigned char *)(a4 + 23) = 0;
    }
  }
  if ((char)v12 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1D3501E24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)5>()
{
  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D9436450](exception, 5);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_1D3501E84(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_expression_term<char const*>(uint64_t a1, char *a2, char *a3, uint64_t *a4)
{
  int v4 = a2;
  if (a2 == a3) {
    return v4;
  }
  int v5 = *a2;
  if (v5 == 93) {
    return v4;
  }
  uint64_t v6 = (uint64_t)a4;
  unsigned int v9 = 0;
  uint64_t v10 = 0;
  long long v31 = 0uLL;
  uint64_t v32 = 0;
  if (a2 + 1 != a3 && v5 == 91)
  {
    int v11 = a2[1];
    switch(v11)
    {
      case '.':
        int v4 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse_collating_symbol<char const*>(a1, a2 + 2, a3, (uint64_t)&v31);
        unsigned int v9 = HIBYTE(v32);
        uint64_t v10 = *((void *)&v31 + 1);
        break;
      case ':':
        uint64_t v12 = std::basic_regex<char,std::regex_traits<char>>::__parse_character_class<char const*>(a1, a2 + 2, a3, (uint64_t)a4);
        goto LABEL_11;
      case '=':
        uint64_t v12 = std::basic_regex<char,std::regex_traits<char>>::__parse_equivalence_class<char const*>(a1, a2 + 2, a3, a4);
LABEL_11:
        uint64_t v6 = v12;
        char v13 = 0;
        goto LABEL_44;
      default:
        uint64_t v10 = 0;
        unsigned int v9 = 0;
        break;
    }
  }
  int v14 = *(_DWORD *)(a1 + 24) & 0x1F0;
  if ((v9 & 0x80u) == 0) {
    uint64_t v10 = v9;
  }
  if (v10)
  {
    unint64_t v15 = v4;
    goto LABEL_28;
  }
  if ((*(_DWORD *)(a1 + 24) & 0x1B0 | 0x40) == 0x40)
  {
    int v16 = *v4;
    if (v16 == 92)
    {
      uint64_t v17 = v4 + 1;
      if (v14) {
        uint64_t v18 = std::basic_regex<char,std::regex_traits<char>>::__parse_awk_escape<char const*>((std::basic_regex<char> *)a1, v17, a3, (uint64_t *)&v31);
      }
      else {
        uint64_t v18 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse_class_escape<char const*>((std::basic_regex<char> *)a1, (unsigned __int8 *)v17, (unsigned __int8 *)a3, (uint64_t)&v31, v6);
      }
      unint64_t v15 = v18;
      goto LABEL_28;
    }
  }
  else
  {
    LOBYTE(v16) = *v4;
  }
  if ((v9 & 0x80) != 0)
  {
    size_t v19 = (long long *)v31;
    *((void *)&v31 + 1) = 1;
  }
  else
  {
    HIBYTE(v32) = 1;
    size_t v19 = &v31;
  }
  *(unsigned char *)size_t v19 = v16;
  *((unsigned char *)v19 + 1) = 0;
  unint64_t v15 = v4 + 1;
LABEL_28:
  if (v15 == a3
    || (int v20 = *v15, v20 == 93)
    || (std::vector<char>::pointer v21 = v15 + 1, v15 + 1 == a3)
    || v20 != 45
    || *v21 == 93)
  {
    if (SHIBYTE(v32) < 0)
    {
      if (*((void *)&v31 + 1))
      {
        if (*((void *)&v31 + 1) != 1)
        {
          unint64_t v22 = (char *)v31;
LABEL_42:
          std::__bracket_expression<char,std::regex_traits<char>>::__add_digraph[abi:ne180100](v6, *v22, v22[1]);
          goto LABEL_43;
        }
        unint64_t v22 = (char *)v31;
        goto LABEL_40;
      }
    }
    else if (HIBYTE(v32))
    {
      unint64_t v22 = (char *)&v31;
      if (HIBYTE(v32) != 1) {
        goto LABEL_42;
      }
LABEL_40:
      std::__bracket_expression<char,std::regex_traits<char>>::__add_char[abi:ne180100](v6, *v22);
    }
LABEL_43:
    char v13 = 1;
    int v4 = v15;
    goto LABEL_44;
  }
  v29[0] = 0;
  v29[1] = 0;
  uint64_t v30 = 0;
  int v4 = v15 + 2;
  if (v15 + 2 != a3 && *v21 == 91 && *v4 == 46)
  {
    uint64_t v24 = std::basic_regex<char,std::regex_traits<char>>::__parse_collating_symbol<char const*>(a1, v15 + 3, a3, (uint64_t)v29);
LABEL_60:
    int v4 = (char *)v24;
    goto LABEL_61;
  }
  if ((v14 | 0x40) == 0x40)
  {
    LODWORD(v21) = *v21;
    if (v21 == 92)
    {
      if (v14) {
        uint64_t v24 = (uint64_t)std::basic_regex<char,std::regex_traits<char>>::__parse_awk_escape<char const*>((std::basic_regex<char> *)a1, v15 + 2, a3, (uint64_t *)v29);
      }
      else {
        uint64_t v24 = (uint64_t)std::basic_regex<char,std::regex_traits<char>>::__parse_class_escape<char const*>((std::basic_regex<char> *)a1, (unsigned __int8 *)v15 + 2, (unsigned __int8 *)a3, (uint64_t)v29, v6);
      }
      goto LABEL_60;
    }
  }
  else
  {
    LOBYTE(v21) = *v21;
  }
  HIBYTE(v30) = 1;
  LOWORD(v29[0]) = v21;
LABEL_61:
  *(_OWORD *)std::vector<char>::pointer v27 = v31;
  uint64_t v28 = v32;
  uint64_t v32 = 0;
  long long v31 = 0uLL;
  *(_OWORD *)std::vector<std::csub_match> __p = *(_OWORD *)v29;
  uint64_t v26 = v30;
  v29[0] = 0;
  v29[1] = 0;
  uint64_t v30 = 0;
  std::__bracket_expression<char,std::regex_traits<char>>::__add_range[abi:ne180100](v6, (char *)v27, (char *)__p);
  if (SHIBYTE(v26) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v28) < 0) {
    operator delete(v27[0]);
  }
  if (SHIBYTE(v30) < 0) {
    operator delete(v29[0]);
  }
  char v13 = 1;
LABEL_44:
  if (SHIBYTE(v32) < 0) {
    operator delete((void *)v31);
  }
  if (v13) {
    return v4;
  }
  return (char *)v6;
}

void sub_1D350220C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v28 - 49) < 0) {
    operator delete(*(void **)(v28 - 72));
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__parse_equivalence_class<char const*>(uint64_t a1, char *a2, char *a3, uint64_t *a4)
{
  if (a3 - a2 < 2 || a3 - 1 == a2) {
    goto LABEL_33;
  }
  for (uint64_t i = 0; a2[i] != 61 || a2[i + 1] != 93; ++i)
  {
    if (a3 - a2 - 2 == i) {
      goto LABEL_33;
    }
  }
  if (&a2[i] == a3) {
LABEL_33:
  }
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)5>();
  std::regex_traits<char>::__lookup_collatename<char *>(a1, a2, &a2[i], (uint64_t)&v17);
  if (((char)v19 & 0x80000000) == 0)
  {
    uint64_t v8 = v19;
    if (v19)
    {
      unsigned int v9 = (char *)&v17;
      goto LABEL_14;
    }
LABEL_34:
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)1>();
  }
  uint64_t v8 = v18;
  if (!v18) {
    goto LABEL_34;
  }
  unsigned int v9 = (char *)v17;
LABEL_14:
  std::regex_traits<char>::__transform_primary<char *>(a1, v9, &v9[v8], (uint64_t)__p);
  unint64_t v10 = v16;
  if ((v16 & 0x80u) != 0) {
    unint64_t v10 = (unint64_t)__p[1];
  }
  if (v10)
  {
    std::__bracket_expression<char,std::regex_traits<char>>::__add_equivalence[abi:ne180100](a4, (long long *)__p);
  }
  else
  {
    uint64_t v11 = v19;
    if ((v19 & 0x80u) != 0) {
      uint64_t v11 = v18;
    }
    if (v11 == 2)
    {
      char v13 = (char *)&v17;
      if ((v19 & 0x80u) != 0) {
        char v13 = (char *)v17;
      }
      std::__bracket_expression<char,std::regex_traits<char>>::__add_digraph[abi:ne180100]((uint64_t)a4, *v13, v13[1]);
    }
    else
    {
      if (v11 != 1) {
        std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)1>();
      }
      uint64_t v12 = (char *)&v17;
      if ((v19 & 0x80u) != 0) {
        uint64_t v12 = (char *)v17;
      }
      std::__bracket_expression<char,std::regex_traits<char>>::__add_char[abi:ne180100]((uint64_t)a4, *v12);
    }
  }
  if ((char)v16 < 0) {
    operator delete(__p[0]);
  }
  if ((char)v19 < 0) {
    operator delete(v17);
  }
  return (uint64_t)&a2[i + 2];
}

void sub_1D3502414(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__parse_character_class<char const*>(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  if (a3 - a2 < 2 || a3 - 1 == a2) {
    goto LABEL_11;
  }
  for (uint64_t i = 0; a2[i] != 58 || a2[i + 1] != 93; ++i)
  {
    if (a3 - a2 - 2 == i) {
      goto LABEL_11;
    }
  }
  if (&a2[i] == a3) {
LABEL_11:
  }
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)5>();
  int v7 = std::regex_traits<char>::__lookup_classname<char const*>(a1, a2, &a2[i], *(unsigned char *)(a1 + 24) & 1);
  if (!v7) {
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)2>();
  }
  *(_DWORD *)(a4 + 160) |= v7;
  return (uint64_t)&a2[i + 2];
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__parse_collating_symbol<char const*>(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  if (a3 - a2 < 2 || a3 - 1 == a2) {
    goto LABEL_15;
  }
  for (uint64_t i = 0; a2[i] != 46 || a2[i + 1] != 93; ++i)
  {
    if (a3 - a2 - 2 == i) {
      goto LABEL_15;
    }
  }
  if (&a2[i] == a3) {
LABEL_15:
  }
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)5>();
  std::regex_traits<char>::__lookup_collatename<char *>(a1, a2, &a2[i], (uint64_t)&v10);
  if (*(char *)(a4 + 23) < 0) {
    operator delete(*(void **)a4);
  }
  *(_OWORD *)a4 = v10;
  unint64_t v7 = v11;
  *(void *)(a4 + 16) = v11;
  unint64_t v8 = HIBYTE(v7);
  if ((v8 & 0x80u) != 0) {
    unint64_t v8 = *(void *)(a4 + 8);
  }
  if (v8 - 1 >= 2) {
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)1>();
  }
  return (uint64_t)&a2[i + 2];
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_class_escape<char const*>(std::basic_regex<char> *a1, unsigned __int8 *a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5)
{
  if (a2 == a3) {
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)3>();
  }
  int v6 = (char)*a2;
  if (v6 > 97)
  {
    if (v6 > 114)
    {
      if (v6 != 115)
      {
        if (v6 != 119) {
          goto LABEL_25;
        }
        *(_DWORD *)(a5 + 160) |= 0x500u;
        std::__bracket_expression<char,std::regex_traits<char>>::__add_char[abi:ne180100](a5, 95);
        return a2 + 1;
      }
      int v8 = *(_DWORD *)(a5 + 160) | 0x4000;
    }
    else
    {
      if (v6 == 98)
      {
        if (*(char *)(a4 + 23) < 0)
        {
          *(void *)(a4 + 8) = 1;
          a4 = *(void *)a4;
        }
        else
        {
          *(unsigned char *)(a4 + 23) = 1;
        }
        *(_WORD *)a4 = 8;
        return a2 + 1;
      }
      if (v6 != 100) {
        goto LABEL_25;
      }
      int v8 = *(_DWORD *)(a5 + 160) | 0x400;
    }
    *(_DWORD *)(a5 + 160) = v8;
    return a2 + 1;
  }
  if (v6 <= 82)
  {
    if (!*a2)
    {
      if (*(char *)(a4 + 23) < 0)
      {
        *(void *)(a4 + 8) = 1;
        a4 = *(void *)a4;
      }
      else
      {
        *(unsigned char *)(a4 + 23) = 1;
      }
      *(unsigned char *)a4 = 0;
      *(unsigned char *)(a4 + 1) = 0;
      return a2 + 1;
    }
    if (v6 == 68)
    {
      int v7 = *(_DWORD *)(a5 + 164) | 0x400;
LABEL_22:
      *(_DWORD *)(a5 + 164) = v7;
      return a2 + 1;
    }
    goto LABEL_25;
  }
  if (v6 == 83)
  {
    int v7 = *(_DWORD *)(a5 + 164) | 0x4000;
    goto LABEL_22;
  }
  if (v6 == 87)
  {
    *(_DWORD *)(a5 + 164) |= 0x500u;
    std::__bracket_expression<char,std::regex_traits<char>>::__add_neg_char[abi:ne180100](a5, 95);
    return a2 + 1;
  }
LABEL_25:
  return std::basic_regex<char,std::regex_traits<char>>::__parse_character_escape<char const*>(a1, a2, a3, (uint64_t *)a4);
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_awk_escape<char const*>(std::basic_regex<char> *a1, char *a2, char *a3, uint64_t *a4)
{
  if (a2 == a3) {
LABEL_80:
  }
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)3>();
  int v5 = *a2;
  std::basic_regex<char>::value_type v6 = *a2;
  if (v5 > 97)
  {
    switch(*a2)
    {
      case 'n':
        if (!a4)
        {
          std::basic_regex<char>::value_type v7 = 10;
          break;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v13 = 10;
        goto LABEL_77;
      case 'o':
      case 'p':
      case 'q':
      case 's':
      case 'u':
        goto LABEL_25;
      case 'r':
        if (!a4)
        {
          std::basic_regex<char>::value_type v7 = 13;
          break;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v13 = 13;
        goto LABEL_77;
      case 't':
        if (!a4)
        {
          std::basic_regex<char>::value_type v7 = 9;
          break;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v13 = 9;
        goto LABEL_77;
      case 'v':
        if (!a4)
        {
          std::basic_regex<char>::value_type v7 = 11;
          break;
        }
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        __int16 v13 = 11;
        goto LABEL_77;
      default:
        if (v5 == 98)
        {
          if (a4)
          {
            if (*((char *)a4 + 23) < 0)
            {
              a4[1] = 1;
              a4 = (uint64_t *)*a4;
            }
            else
            {
              *((unsigned char *)a4 + 23) = 1;
            }
            __int16 v13 = 8;
            goto LABEL_77;
          }
          std::basic_regex<char>::value_type v7 = 8;
        }
        else
        {
          if (v5 != 102) {
            goto LABEL_25;
          }
          if (a4)
          {
            if (*((char *)a4 + 23) < 0)
            {
              a4[1] = 1;
              a4 = (uint64_t *)*a4;
            }
            else
            {
              *((unsigned char *)a4 + 23) = 1;
            }
            __int16 v13 = 12;
            goto LABEL_77;
          }
          std::basic_regex<char>::value_type v7 = 12;
        }
        break;
    }
LABEL_62:
    std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, v7);
    return a2 + 1;
  }
  if (v5 > 91)
  {
    if (v5 == 92)
    {
LABEL_16:
      if (a4)
      {
        if (*((char *)a4 + 23) < 0)
        {
          a4[1] = 1;
          a4 = (uint64_t *)*a4;
        }
        else
        {
          *((unsigned char *)a4 + 23) = 1;
        }
        *(unsigned char *)a4 = v6;
        *((unsigned char *)a4 + 1) = 0;
        return a2 + 1;
      }
      std::basic_regex<char>::value_type v7 = *a2;
      goto LABEL_62;
    }
    if (v5 != 97) {
      goto LABEL_25;
    }
    if (a4)
    {
      if (*((char *)a4 + 23) < 0)
      {
        a4[1] = 1;
        a4 = (uint64_t *)*a4;
      }
      else
      {
        *((unsigned char *)a4 + 23) = 1;
      }
      __int16 v13 = 7;
LABEL_77:
      *(_WORD *)a4 = v13;
      return a2 + 1;
    }
    std::basic_regex<char>::value_type v7 = 7;
    goto LABEL_62;
  }
  if (v5 == 34 || v5 == 47) {
    goto LABEL_16;
  }
LABEL_25:
  if ((v6 & 0xF8) != 0x30) {
    goto LABEL_80;
  }
  std::basic_regex<char>::value_type v8 = v5 - 48;
  unsigned int v9 = a2 + 1;
  if (a2 + 1 != a3)
  {
    if ((*v9 & 0xF8) != 0x30) {
      goto LABEL_49;
    }
    std::basic_regex<char>::value_type v8 = *v9 + 8 * v8 - 48;
    if (a2 + 2 != a3)
    {
      char v10 = a2[2];
      int v11 = v10 & 0xF8;
      std::basic_regex<char>::value_type v12 = v10 + 8 * v8 - 48;
      if (v11 == 48) {
        unsigned int v9 = a2 + 3;
      }
      else {
        unsigned int v9 = a2 + 2;
      }
      if (v11 == 48) {
        std::basic_regex<char>::value_type v8 = v12;
      }
      goto LABEL_49;
    }
  }
  unsigned int v9 = a3;
LABEL_49:
  if (a4)
  {
    if (*((char *)a4 + 23) < 0)
    {
      a4[1] = 1;
      a4 = (uint64_t *)*a4;
    }
    else
    {
      *((unsigned char *)a4 + 23) = 1;
    }
    *(unsigned char *)a4 = v8;
    *((unsigned char *)a4 + 1) = 0;
  }
  else
  {
    std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, v8);
  }
  return v9;
}

void std::__bracket_expression<char,std::regex_traits<char>>::__add_range[abi:ne180100](uint64_t a1, char *a2, char *a3)
{
  size_t v3 = a3;
  int v4 = a2;
  if (*(unsigned char *)(a1 + 170))
  {
    if (*(unsigned char *)(a1 + 169))
    {
      for (unint64_t i = 0; ; ++i)
      {
        unint64_t v7 = v4[23] < 0 ? *((void *)v4 + 1) : v4[23];
        if (i >= v7) {
          break;
        }
        std::basic_regex<char>::value_type v8 = v4;
        if (v4[23] < 0) {
          std::basic_regex<char>::value_type v8 = *(char **)v4;
        }
        char v9 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v8[i]);
        char v10 = v4;
        if (v4[23] < 0) {
          char v10 = *(char **)v4;
        }
        v10[i] = v9;
      }
      for (unint64_t j = 0; ; ++j)
      {
        unint64_t v12 = v3[23] < 0 ? *((void *)v3 + 1) : v3[23];
        if (j >= v12) {
          break;
        }
        __int16 v13 = v3;
        if (v3[23] < 0) {
          __int16 v13 = *(char **)v3;
        }
        char v14 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v13[j]);
        unint64_t v15 = v3;
        if (v3[23] < 0) {
          unint64_t v15 = *(char **)v3;
        }
        v15[j] = v14;
      }
    }
    else
    {
      for (unint64_t k = 0; ; ++k)
      {
        unint64_t v18 = a2[23] < 0 ? *((void *)a2 + 1) : a2[23];
        if (k >= v18) {
          break;
        }
        unsigned __int8 v19 = a2;
        if (a2[23] < 0) {
          unsigned __int8 v19 = *(char **)a2;
        }
        int v20 = a2;
        if (a2[23] < 0) {
          int v20 = *(char **)a2;
        }
        v20[k] = v19[k];
      }
      for (unint64_t m = 0; ; ++m)
      {
        unint64_t v22 = a3[23] < 0 ? *((void *)a3 + 1) : a3[23];
        if (m >= v22) {
          break;
        }
        int v23 = a3;
        if (a3[23] < 0) {
          int v23 = *(char **)a3;
        }
        uint64_t v24 = a3;
        if (a3[23] < 0) {
          uint64_t v24 = *(char **)a3;
        }
        v24[m] = v23[m];
      }
    }
    if (v4[23] < 0)
    {
      uint64_t v26 = v4;
      int v4 = *(char **)v4;
      uint64_t v25 = *((void *)v26 + 1);
    }
    else
    {
      uint64_t v25 = v4[23];
    }
    std::regex_traits<char>::transform<char *>(a1 + 16, v4, &v4[v25]);
    if (v3[23] < 0)
    {
      uint64_t v28 = v3;
      size_t v3 = *(char **)v3;
      uint64_t v27 = *((void *)v28 + 1);
    }
    else
    {
      uint64_t v27 = v3[23];
    }
    std::regex_traits<char>::transform<char *>(a1 + 16, v3, &v3[v27]);
    *(_OWORD *)size_t v40 = v38;
    uint64_t v41 = v39;
    *(_OWORD *)std::vector<std::csub_match> __p = *(_OWORD *)v36;
    uint64_t v43 = v37;
    std::vector<std::pair<std::string,std::string>>::push_back[abi:ne180100]((char **)(a1 + 88), (long long *)v40);
    if (SHIBYTE(v43) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v41) < 0) {
      operator delete(v40[0]);
    }
  }
  else
  {
    if (a2[23] < 0) {
      uint64_t v16 = *((void *)a2 + 1);
    }
    else {
      uint64_t v16 = a2[23];
    }
    if (v16 != 1 || (a3[23] < 0 ? (uint64_t v29 = *((void *)a3 + 1)) : (uint64_t v29 = a3[23]), v29 != 1)) {
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)9>();
    }
    if (*(unsigned char *)(a1 + 169))
    {
      uint64_t v30 = a2;
      if (a2[23] < 0) {
        uint64_t v30 = *(char **)a2;
      }
      char v31 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), *v30);
      uint64_t v32 = v4;
      if (v4[23] < 0) {
        uint64_t v32 = *(unsigned char **)v4;
      }
      unsigned char *v32 = v31;
      char v33 = v3;
      if (v3[23] < 0) {
        char v33 = *(char **)v3;
      }
      char v34 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), *v33);
      uint64_t v35 = v3;
      if (v3[23] < 0) {
        uint64_t v35 = *(unsigned char **)v3;
      }
      *uint64_t v35 = v34;
    }
    *(_OWORD *)size_t v40 = *(_OWORD *)v4;
    uint64_t v41 = *((void *)v4 + 2);
    *((void *)v4 + 1) = 0;
    *((void *)v4 + 2) = 0;
    *(void *)int v4 = 0;
    *(_OWORD *)std::vector<std::csub_match> __p = *(_OWORD *)v3;
    uint64_t v43 = *((void *)v3 + 2);
    *(void *)size_t v3 = 0;
    *((void *)v3 + 1) = 0;
    *((void *)v3 + 2) = 0;
    std::vector<std::pair<std::string,std::string>>::push_back[abi:ne180100]((char **)(a1 + 88), (long long *)v40);
    if (SHIBYTE(v43) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v41) < 0) {
      operator delete(v40[0]);
    }
  }
}

void sub_1D3502E68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
}

void std::__bracket_expression<char,std::regex_traits<char>>::__add_digraph[abi:ne180100](uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(unsigned char *)(a1 + 169))
  {
    uint64_t v18 = a1 + 128;
    unint64_t v19 = *(void *)(a1 + 128);
    char v10 = (char **)(a1 + 112);
    __int16 v8 = a2 | (unsigned __int16)((_WORD)a3 << 8);
    char v9 = *(_WORD **)(a1 + 120);
    if (*(unsigned char *)(a1 + 170))
    {
      if ((unint64_t)v9 < v19) {
        goto LABEL_24;
      }
      uint64_t v20 = (char *)v9 - *v10;
      if (v20 > -3)
      {
        uint64_t v21 = v20 >> 1;
        unint64_t v22 = v19 - (void)*v10;
        if (v22 <= (v20 >> 1) + 1) {
          unint64_t v23 = v21 + 1;
        }
        else {
          unint64_t v23 = v22;
        }
        if (v22 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v24 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v24 = v23;
        }
        if (v24) {
          uint64_t v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>(v18, v24);
        }
        else {
          uint64_t v25 = 0;
        }
        uint64_t v27 = &v25[2 * v21];
        uint64_t v28 = &v25[2 * v24];
        *(_WORD *)uint64_t v27 = v8;
        uint64_t v26 = v27 + 2;
        long long v38 = *(char **)(a1 + 112);
        uint64_t v29 = *(char **)(a1 + 120);
        if (v29 == v38) {
          goto LABEL_46;
        }
        do
        {
          __int16 v39 = *((_WORD *)v29 - 1);
          v29 -= 2;
          *((_WORD *)v27 - 1) = v39;
          v27 -= 2;
        }
        while (v29 != v38);
        goto LABEL_45;
      }
    }
    else
    {
      if ((unint64_t)v9 < v19) {
        goto LABEL_24;
      }
      uint64_t v32 = (char *)v9 - *v10;
      if (v32 > -3)
      {
        uint64_t v33 = v32 >> 1;
        unint64_t v34 = v19 - (void)*v10;
        if (v34 <= (v32 >> 1) + 1) {
          unint64_t v35 = v33 + 1;
        }
        else {
          unint64_t v35 = v34;
        }
        if (v34 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v36 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v36 = v35;
        }
        if (v36) {
          uint64_t v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>(v18, v36);
        }
        else {
          uint64_t v37 = 0;
        }
        uint64_t v27 = &v37[2 * v33];
        uint64_t v28 = &v37[2 * v36];
        *(_WORD *)uint64_t v27 = v8;
        uint64_t v26 = v27 + 2;
        size_t v40 = *(char **)(a1 + 112);
        uint64_t v29 = *(char **)(a1 + 120);
        if (v29 == v40) {
          goto LABEL_46;
        }
        do
        {
          __int16 v41 = *((_WORD *)v29 - 1);
          v29 -= 2;
          *((_WORD *)v27 - 1) = v41;
          v27 -= 2;
        }
        while (v29 != v40);
        goto LABEL_45;
      }
    }
LABEL_49:
    std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
  }
  unsigned __int8 v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a2);
  __int16 v6 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a3);
  unint64_t v7 = *(void *)(a1 + 128);
  __int16 v8 = v5 | (unsigned __int16)(v6 << 8);
  char v9 = *(_WORD **)(a1 + 120);
  if ((unint64_t)v9 < v7)
  {
LABEL_24:
    *char v9 = v8;
    uint64_t v26 = v9 + 1;
    goto LABEL_48;
  }
  char v10 = (char **)(a1 + 112);
  uint64_t v11 = *(void *)(a1 + 112);
  uint64_t v12 = (uint64_t)v9 - v11;
  if ((uint64_t)v9 - v11 <= -3) {
    goto LABEL_49;
  }
  uint64_t v13 = v12 >> 1;
  unint64_t v14 = v7 - v11;
  if (v14 <= (v12 >> 1) + 1) {
    unint64_t v15 = v13 + 1;
  }
  else {
    unint64_t v15 = v14;
  }
  if (v14 >= 0x7FFFFFFFFFFFFFFELL) {
    uint64_t v16 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v16 = v15;
  }
  if (v16) {
    uint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned short>>(a1 + 128, v16);
  }
  else {
    uint64_t v17 = 0;
  }
  uint64_t v27 = &v17[2 * v13];
  uint64_t v28 = &v17[2 * v16];
  *(_WORD *)uint64_t v27 = v8;
  uint64_t v26 = v27 + 2;
  uint64_t v30 = *(char **)(a1 + 112);
  uint64_t v29 = *(char **)(a1 + 120);
  if (v29 == v30) {
    goto LABEL_46;
  }
  do
  {
    __int16 v31 = *((_WORD *)v29 - 1);
    v29 -= 2;
    *((_WORD *)v27 - 1) = v31;
    v27 -= 2;
  }
  while (v29 != v30);
LABEL_45:
  uint64_t v29 = *v10;
LABEL_46:
  *(void *)(a1 + 112) = v27;
  *(void *)(a1 + 120) = v26;
  *(void *)(a1 + 128) = v28;
  if (v29) {
    operator delete(v29);
  }
LABEL_48:
  *(void *)(a1 + 120) = v26;
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)1>()
{
  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D9436450](exception, 1);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_1D3503154(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__bracket_expression<char,std::regex_traits<char>>::__add_equivalence[abi:ne180100](uint64_t *a1, long long *a2)
{
  size_t v3 = a1 + 17;
  unint64_t v4 = a1[18];
  if (v4 >= a1[19])
  {
    uint64_t result = std::vector<std::string>::__push_back_slow_path<std::string const&>(v3, a2);
  }
  else
  {
    std::vector<std::string>::__construct_one_at_end[abi:ne180100]<std::string const&>((uint64_t)v3, a2);
    uint64_t result = v4 + 24;
  }
  a1[18] = result;
  return result;
}

void std::vector<std::string>::__construct_one_at_end[abi:ne180100]<std::string const&>(uint64_t a1, long long *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(*(std::string **)(a1 + 8), *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *(void *)(v3 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v3 = v4;
  }
  *(void *)(a1 + 8) = v3 + 24;
}

void sub_1D3503204(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)2>()
{
  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D9436450](exception, 2);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_1D3503250(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t std::regex_traits<char>::__lookup_classname<char const*>(uint64_t a1, char *a2, char *a3, BOOL a4)
{
  std::string::__init_with_size[abi:ne180100]<char *,char *>(__p, a2, a3, a3 - a2);
  unint64_t v6 = v12;
  if ((v12 & 0x80u) == 0) {
    unint64_t v7 = __p;
  }
  else {
    unint64_t v7 = (void **)__p[0];
  }
  if ((v12 & 0x80u) != 0) {
    unint64_t v6 = (unint64_t)__p[1];
  }
  (*(void (**)(void, void **, char *))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8), v7, (char *)v7 + v6);
  if ((v12 & 0x80u) == 0) {
    __int16 v8 = __p;
  }
  else {
    __int16 v8 = (void **)__p[0];
  }
  uint64_t classname = std::__get_classname((const char *)v8, a4);
  if ((char)v12 < 0) {
    operator delete(__p[0]);
  }
  return classname;
}

void sub_1D350331C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::__bracket_expression<char,std::regex_traits<char>>::__add_neg_char[abi:ne180100](uint64_t a1, uint64_t a2)
{
  char v2 = a2;
  if (*(unsigned char *)(a1 + 169))
  {
    char v2 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a2);
    unsigned __int8 v5 = *(unsigned char **)(a1 + 72);
    unint64_t v4 = *(void *)(a1 + 80);
    if ((unint64_t)v5 >= v4)
    {
      unint64_t v6 = (unint64_t *)(a1 + 64);
      unint64_t v7 = *(void *)(a1 + 64);
      __int16 v8 = &v5[-v7];
      uint64_t v9 = (uint64_t)&v5[-v7 + 1];
      if (v9 >= 0)
      {
        unint64_t v10 = v4 - v7;
        if (2 * v10 > v9) {
          uint64_t v9 = 2 * v10;
        }
        if (v10 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v11 = v9;
        }
        if (v11) {
          unsigned __int8 v12 = operator new(v11);
        }
        else {
          unsigned __int8 v12 = 0;
        }
        uint64_t v20 = &v8[(void)v12];
        uint64_t v21 = (char *)v12 + v11;
        v8[(void)v12] = v2;
        uint64_t v19 = (uint64_t)&v8[(void)v12 + 1];
        if (v5 != (unsigned char *)v7)
        {
          unint64_t v22 = &v5[~v7];
          do
          {
            char v23 = *--v5;
            (v22--)[(void)v12] = v23;
          }
          while (v5 != (unsigned char *)v7);
LABEL_45:
          unsigned __int8 v5 = (unsigned char *)*v6;
          goto LABEL_47;
        }
        goto LABEL_46;
      }
LABEL_50:
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    goto LABEL_22;
  }
  unint64_t v6 = (unint64_t *)(a1 + 64);
  unsigned __int8 v5 = *(unsigned char **)(a1 + 72);
  unint64_t v13 = *(void *)(a1 + 80);
  if (!*(unsigned char *)(a1 + 170))
  {
    if ((unint64_t)v5 >= v13)
    {
      unint64_t v24 = *v6;
      uint64_t v25 = &v5[-*v6];
      unint64_t v26 = (unint64_t)(v25 + 1);
      if ((uint64_t)(v25 + 1) >= 0)
      {
        unint64_t v27 = v13 - v24;
        if (2 * v27 > v26) {
          unint64_t v26 = 2 * v27;
        }
        if (v27 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v28 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v28 = v26;
        }
        if (v28) {
          unsigned __int8 v12 = operator new(v28);
        }
        else {
          unsigned __int8 v12 = 0;
        }
        uint64_t v20 = &v25[(void)v12];
        uint64_t v21 = (char *)v12 + v28;
        v25[(void)v12] = v2;
        uint64_t v19 = (uint64_t)&v25[(void)v12 + 1];
        if (v5 != (unsigned char *)v24)
        {
          __int16 v31 = &v5[~v24];
          do
          {
            char v32 = *--v5;
            (v31--)[(void)v12] = v32;
          }
          while (v5 != (unsigned char *)v24);
          goto LABEL_45;
        }
        goto LABEL_46;
      }
      goto LABEL_50;
    }
LABEL_22:
    *unsigned __int8 v5 = v2;
    uint64_t v19 = (uint64_t)(v5 + 1);
    goto LABEL_49;
  }
  if ((unint64_t)v5 < v13) {
    goto LABEL_22;
  }
  unint64_t v14 = *v6;
  unint64_t v15 = &v5[-*v6];
  unint64_t v16 = (unint64_t)(v15 + 1);
  if ((uint64_t)(v15 + 1) < 0) {
    goto LABEL_50;
  }
  unint64_t v17 = v13 - v14;
  if (2 * v17 > v16) {
    unint64_t v16 = 2 * v17;
  }
  if (v17 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v18 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v18 = v16;
  }
  if (v18) {
    unsigned __int8 v12 = operator new(v18);
  }
  else {
    unsigned __int8 v12 = 0;
  }
  uint64_t v20 = &v15[(void)v12];
  uint64_t v21 = (char *)v12 + v18;
  v15[(void)v12] = v2;
  uint64_t v19 = (uint64_t)&v15[(void)v12 + 1];
  if (v5 != (unsigned char *)v14)
  {
    uint64_t v29 = &v5[~v14];
    do
    {
      char v30 = *--v5;
      (v29--)[(void)v12] = v30;
    }
    while (v5 != (unsigned char *)v14);
    goto LABEL_45;
  }
LABEL_46:
  unsigned __int8 v12 = v20;
LABEL_47:
  *(void *)(a1 + 64) = v12;
  *(void *)(a1 + 72) = v19;
  *(void *)(a1 + 80) = v21;
  if (v5) {
    operator delete(v5);
  }
LABEL_49:
  *(void *)(a1 + 72) = v19;
}

void std::vector<std::pair<std::string,std::string>>::push_back[abi:ne180100](char **a1, long long *a2)
{
  unint64_t v6 = (unint64_t)a1[2];
  unint64_t v4 = (std::allocator<std::pair<std::string, std::string>> *)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *((void *)v4 - 1);
  if (v7 >= v6)
  {
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - (void)*a1) >> 4);
    unint64_t v12 = v11 + 1;
    if (v11 + 1 > 0x555555555555555) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - (void)*a1) >> 4);
    if (2 * v13 > v12) {
      unint64_t v12 = 2 * v13;
    }
    if (v13 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v14 = 0x555555555555555;
    }
    else {
      unint64_t v14 = v12;
    }
    v26.__end_cap_.__value_ = v4;
    if (v14) {
      unint64_t v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TAppContainerInfo>>((uint64_t)v4, v14);
    }
    else {
      unint64_t v15 = 0;
    }
    unint64_t v16 = &v15[48 * v11];
    long long v17 = *a2;
    *((void *)v16 + 2) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v16 = v17;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    long long v18 = *(long long *)((char *)a2 + 24);
    *((void *)v16 + 5) = *((void *)a2 + 5);
    *(_OWORD *)(v16 + 24) = v18;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 3) = 0;
    uint64_t v20 = *a1;
    unint64_t v19 = (unint64_t)a1[1];
    if ((char *)v19 == *a1)
    {
      int64x2_t v24 = vdupq_n_s64(v19);
      uint64_t v21 = &v15[48 * v11];
    }
    else
    {
      uint64_t v21 = &v15[48 * v11];
      do
      {
        long long v22 = *(_OWORD *)(v19 - 48);
        *((void *)v21 - 4) = *(void *)(v19 - 32);
        *((_OWORD *)v21 - 3) = v22;
        *(void *)(v19 - 40) = 0;
        *(void *)(v19 - 32) = 0;
        *(void *)(v19 - 48) = 0;
        long long v23 = *(_OWORD *)(v19 - 24);
        *((void *)v21 - 1) = *(void *)(v19 - 8);
        *(_OWORD *)(v21 - 24) = v23;
        v21 -= 48;
        *(void *)(v19 - 16) = 0;
        *(void *)(v19 - 8) = 0;
        *(void *)(v19 - 24) = 0;
        v19 -= 48;
      }
      while ((char *)v19 != v20);
      int64x2_t v24 = *(int64x2_t *)a1;
    }
    unint64_t v10 = v16 + 48;
    *a1 = v21;
    a1[1] = v16 + 48;
    *(int64x2_t *)&v26.__begin_ = v24;
    uint64_t v25 = (std::pair<std::string, std::string> *)a1[2];
    a1[2] = &v15[48 * v14];
    v26.__end_cap_.__value_ = v25;
    v26.__first_ = (std::__split_buffer<std::pair<std::string, std::string>>::pointer)v24.i64[0];
    std::__split_buffer<std::pair<std::string,std::string>>::~__split_buffer(&v26);
  }
  else
  {
    long long v8 = *a2;
    *(void *)(v7 + 16) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v7 = v8;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    long long v9 = *(long long *)((char *)a2 + 24);
    *(void *)(v7 + 40) = *((void *)a2 + 5);
    *(_OWORD *)(v7 + 24) = v9;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 3) = 0;
    unint64_t v10 = (char *)(v7 + 48);
  }
  a1[1] = v10;
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)9>()
{
  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D9436450](exception, 9);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_1D350377C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__split_buffer<std::pair<std::string,std::string>>::~__split_buffer(std::__split_buffer<std::pair<std::string, std::string>> *this)
{
  std::__split_buffer<std::pair<std::string, std::string>>::pointer begin = this->__begin_;
  for (std::__split_buffer<std::pair<std::string, std::string>>::pointer i = this->__end_; i != begin; std::__split_buffer<std::pair<std::string, std::string>>::pointer i = this->__end_)
  {
    this->__end_ = i - 1;
    std::__destroy_at[abi:ne180100]<std::pair<std::string,std::string>,0>((uint64_t)&i[-1]);
  }
  if (this->__first_) {
    operator delete(this->__first_);
  }
}

void (__cdecl ***std::__begin_marked_subexpression<char>::~__begin_marked_subexpression(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  char v2 = a1[1];
  if (v2) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  }
  return a1;
}

void std::__begin_marked_subexpression<char>::~__begin_marked_subexpression(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  uint64_t v1 = a1[1];
  if (v1) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v1 + 1))(v1);
  }
  JUMPOUT(0x1D9436740);
}

uint64_t std::__begin_marked_subexpression<char>::__exec(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(void *)(*(void *)(a2 + 32) + 24 * (*(_DWORD *)(result + 16) - 1)) = *(void *)(a2 + 16);
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void (__cdecl ***std::__end_marked_subexpression<char>::~__end_marked_subexpression(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  char v2 = a1[1];
  if (v2) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  }
  return a1;
}

void std::__end_marked_subexpression<char>::~__end_marked_subexpression(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  uint64_t v1 = a1[1];
  if (v1) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v1 + 1))(v1);
  }
  JUMPOUT(0x1D9436740);
}

uint64_t std::__end_marked_subexpression<char>::__exec(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  uint64_t v2 = *(void *)(a2 + 32) + 24 * (*(_DWORD *)(result + 16) - 1);
  *(void *)(v2 + 8) = *(void *)(a2 + 16);
  *(unsigned char *)(v2 + 16) = 1;
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void std::basic_regex<char,std::regex_traits<char>>::__push_loop(std::basic_regex<char> *this, size_t __min, size_t __max, std::__owns_one_state<char> *__s, size_t __mexp_begin, size_t __mexp_end, BOOL __greedy)
{
}

void sub_1D3503B90(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_DUP_COUNT<char const*>(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, int *a4)
{
  if (a2 != a3)
  {
    int v4 = *a2;
    if ((v4 & 0xF8) == 0x30 || (v4 & 0xFE) == 0x38)
    {
      int v5 = v4 - 48;
      *a4 = v5;
      if (++a2 == a3)
      {
        return a3;
      }
      else
      {
        while (1)
        {
          int v6 = *a2;
          if ((v6 & 0xF8) != 0x30 && (v6 & 0xFE) != 0x38) {
            break;
          }
          if (v5 >= 214748364) {
            std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)8>();
          }
          int v5 = v6 + 10 * v5 - 48;
          *a4 = v5;
          if (++a2 == a3) {
            return a3;
          }
        }
      }
    }
  }
  return a2;
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)8>()
{
  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D9436450](exception, 8);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_1D3503CAC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)7>()
{
  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D9436450](exception, 7);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_1D3503D04(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__loop<char>::~__loop(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  std::__owns_two_states<char>::~__owns_two_states(a1);
  JUMPOUT(0x1D9436740);
}

unsigned int *std::__loop<char>::__exec(unsigned int *result, void *a2)
{
  uint64_t v2 = result[10];
  uint64_t v3 = a2[7];
  int v4 = (unint64_t *)(v3 + 16 * v2);
  if (*(_DWORD *)a2 == -991)
  {
    unint64_t v5 = *v4 + 1;
    unint64_t *v4 = v5;
    unint64_t v6 = *((void *)result + 3);
    unint64_t v7 = *((void *)result + 4);
    BOOL v8 = v5 < v7;
    if (v5 < v7 && v5 >= v6)
    {
      uint64_t v10 = *(void *)(v3 + 16 * v2 + 8);
      BOOL v8 = v5 < v7 && v10 != a2[2];
    }
    if (!v8 || v5 < v6)
    {
      *(_DWORD *)a2 = -994;
      if (!v8) {
        goto LABEL_25;
      }
LABEL_22:
      a2[10] = *((void *)result + 1);
      return std::__loop<char>::__init_repeat[abi:ne180100](result, a2);
    }
    goto LABEL_23;
  }
  unint64_t *v4 = 0;
  if (*((void *)result + 4))
  {
    if (*((void *)result + 3))
    {
      *(_DWORD *)a2 = -994;
      goto LABEL_22;
    }
LABEL_23:
    *(_DWORD *)a2 = -992;
    return result;
  }
  *(_DWORD *)a2 = -994;
LABEL_25:
  a2[10] = *((void *)result + 2);
  return result;
}

unsigned int *std::__loop<char>::__exec_split(unsigned int *result, int a2, void *a3)
{
  *(_DWORD *)a3 = -994;
  if (*((unsigned __int8 *)result + 52) == a2)
  {
    a3[10] = *((void *)result + 2);
  }
  else
  {
    a3[10] = *((void *)result + 1);
    return std::__loop<char>::__init_repeat[abi:ne180100](result, a3);
  }
  return result;
}

void std::__owns_two_states<char>::~__owns_two_states(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  std::__owns_two_states<char>::~__owns_two_states(a1);
  JUMPOUT(0x1D9436740);
}

void (__cdecl ***std::__owns_two_states<char>::~__owns_two_states(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  *a1 = (void (__cdecl **)(std::__owns_one_state<char> *__hidden))&unk_1F2ABAF48;
  uint64_t v2 = a1[2];
  if (v2) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  }
  uint64_t v3 = a1[1];
  if (v3) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v3 + 1))(v3);
  }
  return a1;
}

unsigned int *std::__loop<char>::__init_repeat[abi:ne180100](unsigned int *result, void *a2)
{
  unsigned int v2 = result[11];
  *(void *)(a2[7] + 16 * result[10] + 8) = a2[2];
  unsigned int v3 = result[12];
  if (v2 != v3)
  {
    uint64_t v4 = v2 - 1;
    uint64_t v5 = a2[3];
    uint64_t v6 = v3 - 1 - v4;
    uint64_t v7 = a2[4] + 24 * v4 + 8;
    do
    {
      *(void *)(v7 - 8) = v5;
      *(void *)uint64_t v7 = v5;
      *(unsigned char *)(v7 + 8) = 0;
      v7 += 24;
      --v6;
    }
    while (v6);
  }
  return result;
}

void std::__repeat_one_loop<char>::~__repeat_one_loop()
{
}

uint64_t std::__repeat_one_loop<char>::__exec(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -991;
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void std::__alternate<char>::~__alternate(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  std::__owns_two_states<char>::~__owns_two_states(a1);
  JUMPOUT(0x1D9436740);
}

void std::__alternate<char>::__exec(uint64_t a1, _DWORD *a2)
{
  *a2 = -992;
}

uint64_t std::__alternate<char>::__exec_split(uint64_t result, int a2, uint64_t a3)
{
  *(_DWORD *)a3 = -994;
  uint64_t v3 = 8;
  if (a2) {
    uint64_t v3 = 16;
  }
  *(void *)(a3 + 80) = *(void *)(result + v3);
  return result;
}

void std::__empty_non_own_state<char>::~__empty_non_own_state()
{
}

uint64_t std::__empty_non_own_state<char>::__exec(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)15>()
{
  exception = __cxa_allocate_exception(0x18uLL);
  MEMORY[0x1D9436450](exception, 15);
  __cxa_throw(exception, MEMORY[0x1E4FBA2D8], MEMORY[0x1E4FBA200]);
}

void sub_1D3504084(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_simple_RE<char const*>(std::basic_regex<char> *a1, char *a2, char *a3)
{
  if (a2 == a3) {
    return (unsigned __int8 *)a2;
  }
  std::vector<char>::pointer end = a1->__end_;
  unsigned int marked_count = a1->__marked_count_;
  BOOL v8 = (unsigned __int8 *)std::basic_regex<char,std::regex_traits<char>>::__parse_nondupl_RE<char const*>(a1, a2, a3);
  if (v8 == (unsigned __int8 *)a2) {
    return (unsigned __int8 *)a2;
  }
  size_t v9 = a1->__marked_count_ + 1;
  return std::basic_regex<char,std::regex_traits<char>>::__parse_RE_dupl_symbol<char const*>(a1, v8, (unsigned __int8 *)a3, end, marked_count + 1, v9);
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_nondupl_RE<char const*>(std::basic_regex<char> *a1, char *a2, char *a3)
{
  uint64_t v6 = std::basic_regex<char,std::regex_traits<char>>::__parse_one_char_or_coll_elem_RE<char const*>(a1, a2, a3);
  uint64_t v7 = v6;
  if (v6 == a2 && v6 != a3)
  {
    if (a2 + 1 == a3 || *a2 != 92)
    {
      return a2;
    }
    else
    {
      int v8 = a2[1];
      if (v8 == 40)
      {
        uint64_t v9 = (uint64_t)(a2 + 2);
        std::basic_regex<char,std::regex_traits<char>>::__push_begin_marked_subexpression(a1);
        unsigned int marked_count = a1->__marked_count_;
        do
        {
          unint64_t v11 = (char *)v9;
          uint64_t v9 = std::basic_regex<char,std::regex_traits<char>>::__parse_simple_RE<char const*>(a1, v9, a3);
        }
        while ((char *)v9 != v11);
        if (v11 == a3 || v11 + 1 == a3 || *v11 != 92 || v11[1] != 41) {
          std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)6>();
        }
        uint64_t v7 = v11 + 2;
        std::basic_regex<char,std::regex_traits<char>>::__push_end_marked_subexpression(a1, marked_count);
      }
      else
      {
        BOOL v13 = std::basic_regex<char,std::regex_traits<char>>::__test_back_ref(a1, v8);
        uint64_t v14 = 2;
        if (!v13) {
          uint64_t v14 = 0;
        }
        return &a2[v14];
      }
    }
  }
  return v7;
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_RE_dupl_symbol<char const*>(std::basic_regex<char> *this, unsigned __int8 *a2, unsigned __int8 *a3, std::__owns_one_state<char> *__s, size_t __mexp_begin, size_t __mexp_end)
{
  uint64_t v6 = a2;
  if (a2 != a3)
  {
    unsigned int v7 = __mexp_end;
    unsigned int v8 = __mexp_begin;
    int v11 = *a2;
    if (v11 == 42)
    {
      std::basic_regex<char,std::regex_traits<char>>::__push_loop(this, 0, 0xFFFFFFFFFFFFFFFFLL, __s, __mexp_begin, __mexp_end, 1);
      return ++v6;
    }
    if (a2 + 1 != a3 && v11 == 92 && a2[1] == 123)
    {
      BOOL v13 = a2 + 2;
      int v25 = 0;
      uint64_t v14 = std::basic_regex<char,std::regex_traits<char>>::__parse_DUP_COUNT<char const*>((uint64_t)this, a2 + 2, a3, &v25);
      if (v14 == v13) {
        goto LABEL_16;
      }
      if (v14 != a3)
      {
        unint64_t v15 = v14 + 1;
        int v16 = *v14;
        if (v16 == 44)
        {
          int v24 = -1;
          long long v17 = std::basic_regex<char,std::regex_traits<char>>::__parse_DUP_COUNT<char const*>((uint64_t)this, v15, a3, &v24);
          if (v17 != a3 && v17 + 1 != a3 && *v17 == 92 && v17[1] == 125)
          {
            size_t v19 = v24;
            size_t v18 = v25;
            if (v24 == -1)
            {
              size_t v19 = -1;
            }
            else if (v24 < v25)
            {
LABEL_16:
              std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)8>();
            }
            uint64_t v6 = &v17[2 * (v17[1] == 125)];
            size_t v20 = v8;
            size_t v21 = v7;
            long long v22 = this;
LABEL_23:
            std::basic_regex<char,std::regex_traits<char>>::__push_loop(v22, v18, v19, __s, v20, v21, 1);
            return v6;
          }
        }
        else if (v15 != a3 && v16 == 92 && *v15 == 125)
        {
          uint64_t v6 = v14 + 2;
          size_t v18 = v25;
          size_t v20 = v8;
          size_t v21 = v7;
          long long v22 = this;
          size_t v19 = v25;
          goto LABEL_23;
        }
      }
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)7>();
    }
  }
  return v6;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_one_char_or_coll_elem_RE<char const*>(std::basic_regex<char> *this, char *a2, char *a3)
{
  if (a2 == a3)
  {
    uint64_t result = std::basic_regex<char,std::regex_traits<char>>::__parse_QUOTED_CHAR<char const*>(this, a2, a3);
    if (result != a2) {
      return result;
    }
  }
  else
  {
    int v6 = *a2;
    if ((a2 + 1 != a3 || v6 != 36)
      && ((v6 - 46) > 0x2E || ((1 << (v6 - 46)) & 0x600000000001) == 0))
    {
      std::basic_regex<char,std::regex_traits<char>>::__push_char(this, v6);
      return a2 + 1;
    }
    uint64_t result = std::basic_regex<char,std::regex_traits<char>>::__parse_QUOTED_CHAR<char const*>(this, a2, a3);
    if (result != a2) {
      return result;
    }
    if (*a2 == 46) {
      operator new();
    }
  }
  return std::basic_regex<char,std::regex_traits<char>>::__parse_bracket_expression<char const*>((uint64_t)this, a2, a3);
}

unsigned char *std::basic_regex<char,std::regex_traits<char>>::__parse_QUOTED_CHAR<char const*>(std::basic_regex<char> *a1, unsigned char *a2, unsigned char *a3)
{
  uint64_t v3 = a2;
  if (a2 != a3 && a2 + 1 != a3 && *a2 == 92)
  {
    int v4 = (char)a2[1];
    if ((v4 - 36) <= 0x3A && ((1 << (a2[1] - 36)) & 0x580000000000441) != 0)
    {
      std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, v4);
      v3 += 2;
    }
  }
  return v3;
}

void (__cdecl ***std::__match_any<char>::~__match_any(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this)))(std::__owns_one_state<char> *__hidden this)
{
  unsigned int v2 = a1[1];
  if (v2) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  }
  return a1;
}

void std::__match_any<char>::~__match_any(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  uint64_t v1 = a1[1];
  if (v1) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v1 + 1))(v1);
  }
  JUMPOUT(0x1D9436740);
}

uint64_t std::__match_any<char>::__exec(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(unsigned char **)(a2 + 16);
  if (v2 == *(unsigned char **)(a2 + 24) || !*v2)
  {
    uint64_t v3 = 0;
    *(_DWORD *)a2 = -993;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    uint64_t v3 = *(void *)(result + 8);
  }
  *(void *)(a2 + 80) = v3;
  return result;
}

BOOL std::basic_regex<char,std::regex_traits<char>>::__test_back_ref(std::basic_regex<char> *this, char a2)
{
  if ((a2 & 0xF8) != 0x30 && (a2 & 0xFE) != 0x38 || a2 - 49 > 8) {
    return 0;
  }
  if (a2 - 48 > this->__marked_count_) {
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)4>();
  }
  std::basic_regex<char,std::regex_traits<char>>::__push_back_ref(this, a2 - 48);
  return 1;
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_branch<char const*>(std::basic_regex<char> *a1, std::basic_regex<char> *a2, std::basic_regex<char> *a3)
{
  int v6 = std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_expression<char const*>(a1, a2, a3);
  if (v6 == (unsigned __int8 *)a2) {
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)15>();
  }
  do
  {
    unsigned int v7 = v6;
    int v6 = std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_expression<char const*>(a1, (std::basic_regex<char> *)v6, a3);
  }
  while (v6 != v7);
  return v7;
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_expression<char const*>(std::basic_regex<char> *a1, std::basic_regex<char> *a2, std::basic_regex<char> *a3)
{
  std::vector<char>::pointer end = a1->__end_;
  unsigned int marked_count = a1->__marked_count_;
  unsigned int v8 = std::basic_regex<char,std::regex_traits<char>>::__parse_one_char_or_coll_elem_ERE<char const*>(a1, a2, a3);
  uint64_t v9 = (unsigned __int8 *)v8;
  if (v8 != (char *)a2 || v8 == (char *)a3) {
    goto LABEL_12;
  }
  int locale_low = SLOBYTE(a2->__traits_.__loc_.__locale_);
  if (locale_low == 36)
  {
    std::basic_regex<char,std::regex_traits<char>>::__push_r_anchor(a1);
    goto LABEL_8;
  }
  if (locale_low == 40)
  {
    std::basic_regex<char,std::regex_traits<char>>::__push_begin_marked_subexpression(a1);
    unsigned int v11 = a1->__marked_count_;
    ++a1->__open_count_;
    unint64_t v12 = (std::basic_regex<char> *)std::basic_regex<char,std::regex_traits<char>>::__parse_extended_reg_exp<char const*>(a1, (char *)&a2->__traits_.__loc_.__locale_ + 1, a3);
    if (v12 == a3 || (BOOL v13 = v12, LOBYTE(v12->__traits_.__loc_.__locale_) != 41)) {
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)6>();
    }
    std::basic_regex<char,std::regex_traits<char>>::__push_end_marked_subexpression(a1, v11);
    --a1->__open_count_;
    uint64_t v9 = (unsigned __int8 *)&v13->__traits_.__loc_.__locale_ + 1;
LABEL_12:
    if (v9 != (unsigned __int8 *)a2) {
      goto LABEL_13;
    }
    return (unsigned __int8 *)a2;
  }
  if (locale_low != 94) {
    return (unsigned __int8 *)a2;
  }
  std::basic_regex<char,std::regex_traits<char>>::__push_l_anchor(a1);
LABEL_8:
  uint64_t v9 = (unsigned __int8 *)&a2->__traits_.__loc_.__locale_ + 1;
LABEL_13:
  size_t v14 = a1->__marked_count_ + 1;
  return std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_dupl_symbol<char const*>((uint64_t)a1, v9, (unsigned __int8 *)a3, end, marked_count + 1, v14);
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_one_char_or_coll_elem_ERE<char const*>(std::basic_regex<char> *a1, std::basic_regex<char> *a2, std::basic_regex<char> *a3)
{
  uint64_t result = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse_ORD_CHAR_ERE<char const*>(a1, a2, a3);
  if (result == (char *)a2)
  {
    uint64_t result = std::basic_regex<char,std::regex_traits<char>>::__parse_QUOTED_CHAR_ERE<char const*>((uint64_t)a1, a2, a3);
    if (result == (char *)a2)
    {
      if (a2 != a3 && LOBYTE(a2->__traits_.__loc_.__locale_) == 46) {
        operator new();
      }
      return std::basic_regex<char,std::regex_traits<char>>::__parse_bracket_expression<char const*>((uint64_t)a1, (char *)a2, (char *)a3);
    }
  }
  return result;
}

std::basic_regex<char> *std::basic_regex<char,std::regex_traits<char>>::__parse_ORD_CHAR_ERE<char const*>(std::basic_regex<char> *a1, std::basic_regex<char> *this, std::basic_regex<char> *a3)
{
  uint64_t v3 = this;
  if (this != a3)
  {
    int locale_low = SLOBYTE(this->__traits_.__loc_.__locale_);
    uint64_t v5 = (locale_low - 36);
    if (v5 > 0x3A) {
      goto LABEL_8;
    }
    if (((1 << (locale_low - 36)) & 0x5800000080004D1) != 0) {
      return v3;
    }
    if (v5 == 5)
    {
      if (a1->__open_count_) {
        return v3;
      }
    }
    else
    {
LABEL_8:
      if ((locale_low - 123) < 2) {
        return v3;
      }
    }
    std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, (std::basic_regex<char>::value_type)this->__traits_.__loc_.__locale_);
    return (std::basic_regex<char> *)((char *)v3 + 1);
  }
  return v3;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_QUOTED_CHAR_ERE<char const*>(uint64_t a1, std::basic_regex<char> *this, std::basic_regex<char> *a3)
{
  uint64_t v3 = this;
  if (this == a3) {
    return (char *)v3;
  }
  int v4 = (char *)&this->__traits_.__loc_.__locale_ + 1;
  if ((std::basic_regex<char> *)((char *)&v3->__traits_.__loc_.__locale_ + 1) == a3
    || LOBYTE(v3->__traits_.__loc_.__locale_) != 92)
  {
    return (char *)v3;
  }
  int v5 = *v4;
  std::basic_regex<char>::value_type v6 = *v4;
  BOOL v7 = (v5 - 36) > 0x3A || ((1 << (*v4 - 36)) & 0x5800000080004F1) == 0;
  if (!v7 || (v5 - 123) < 3)
  {
    std::basic_regex<char,std::regex_traits<char>>::__push_char((std::basic_regex<char> *)a1, v6);
    return (char *)v3 + 2;
  }
  if ((*(_DWORD *)(a1 + 24) & 0x1F0) != 0x40)
  {
    BOOL v9 = std::basic_regex<char,std::regex_traits<char>>::__test_back_ref((std::basic_regex<char> *)a1, v6);
    uint64_t v10 = 2;
    if (!v9) {
      uint64_t v10 = 0;
    }
    return (char *)v3 + v10;
  }
  return std::basic_regex<char,std::regex_traits<char>>::__parse_awk_escape<char const*>((std::basic_regex<char> *)a1, v4, (char *)a3, 0);
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>(uint64_t a1, char *__f, char *__l, std::match_results<const char *> *this, int a5)
{
  if ((a5 & 0x80) != 0) {
    int v9 = a5 & 0xFFA;
  }
  else {
    int v9 = a5;
  }
  std::match_results<char const*>::__init(this, *(_DWORD *)(a1 + 28) + 1, __f, __l, (unsigned __int16)(v9 & 0x800) >> 11);
  if (std::basic_regex<char,std::regex_traits<char>>::__match_at_start<std::allocator<std::sub_match<char const*>>>(a1, __f, __l, (uint64_t *)this, v9, (v9 & 0x800) == 0))
  {
    if (this->__matches_.__end_ == this->__matches_.__begin_) {
      p_unmatched = &this->__unmatched_;
    }
    else {
      p_unmatched = this->__matches_.__begin_;
    }
LABEL_8:
    first = p_unmatched->first;
    this->__prefix_.second = p_unmatched->first;
    this->__prefix_.matched = this->__prefix_.first != first;
    second = p_unmatched->second;
    this->__suffix_.first = second;
    this->__suffix_.matched = second != this->__suffix_.second;
    return 1;
  }
  if (__f != __l && (v9 & 0x40) == 0)
  {
    int v14 = v9 | 0x80;
    unint64_t v15 = __f + 1;
    if (v15 != __l)
    {
      while (1)
      {
        std::vector<std::sub_match<char const*>>::assign(&this->__matches_, 0xAAAAAAAAAAAAAAABLL * (((char *)this->__matches_.__end_ - (char *)this->__matches_.__begin_) >> 3), &this->__unmatched_);
        int v16 = std::basic_regex<char,std::regex_traits<char>>::__match_at_start<std::allocator<std::sub_match<char const*>>>(a1, v15, __l, (uint64_t *)this, v14, 0);
        std::vector<std::csub_match>::pointer begin = this->__matches_.__begin_;
        std::vector<std::csub_match>::pointer end = this->__matches_.__end_;
        if (v16) {
          break;
        }
        std::vector<std::sub_match<char const*>>::assign(&this->__matches_, 0xAAAAAAAAAAAAAAABLL * (((char *)end - (char *)begin) >> 3), &this->__unmatched_);
        if (++v15 == __l) {
          goto LABEL_14;
        }
      }
      if (end == begin) {
        p_unmatched = &this->__unmatched_;
      }
      else {
        p_unmatched = this->__matches_.__begin_;
      }
      goto LABEL_8;
    }
LABEL_14:
    std::vector<std::sub_match<char const*>>::assign(&this->__matches_, 0xAAAAAAAAAAAAAAABLL * (((char *)this->__matches_.__end_ - (char *)this->__matches_.__begin_) >> 3), &this->__unmatched_);
    if (std::basic_regex<char,std::regex_traits<char>>::__match_at_start<std::allocator<std::sub_match<char const*>>>(a1, __l, __l, (uint64_t *)this, v14, 0))
    {
      if (this->__matches_.__end_ == this->__matches_.__begin_) {
        p_unmatched = &this->__unmatched_;
      }
      else {
        p_unmatched = this->__matches_.__begin_;
      }
      goto LABEL_8;
    }
  }
  uint64_t result = 0;
  this->__matches_.__end_ = this->__matches_.__begin_;
  return result;
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__match_at_start<std::allocator<std::sub_match<char const*>>>(uint64_t a1, const char *a2, const char *a3, uint64_t *a4, int a5, char a6)
{
  if ((*(_WORD *)(a1 + 24) & 0x1F0) == 0) {
    return std::basic_regex<char,std::regex_traits<char>>::__match_at_start_ecma<std::allocator<std::sub_match<char const*>>>(a1, a2, a3, a4, a5, a6);
  }
  if (*(_DWORD *)(a1 + 28)) {
    return std::basic_regex<char,std::regex_traits<char>>::__match_at_start_posix_subs<std::allocator<std::sub_match<char const*>>>(a1, a2, a3, a4, a5, a6);
  }
  return std::basic_regex<char,std::regex_traits<char>>::__match_at_start_posix_nosubs<std::allocator<std::sub_match<char const*>>>(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, a6);
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__match_at_start_posix_nosubs<std::allocator<std::sub_match<char const*>>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, int a5, char a6)
{
  long long v62 = 0u;
  long long v63 = 0u;
  long long v61 = 0u;
  uint64_t v6 = *(void *)(a1 + 40);
  if (v6)
  {
    *(_DWORD *)uint64_t v57 = 0;
    memset(&v57[8], 0, 32);
    long long v58 = 0uLL;
    *(_OWORD *)std::vector<std::csub_match> __p = 0uLL;
    memset(v60, 0, 21);
    std::deque<std::__state<char>>::push_back(&v61, (uint64_t)v57);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    int v51 = a4;
    if (*(void *)&v57[32])
    {
      *(void *)&long long v58 = *(void *)&v57[32];
      operator delete(*(void **)&v57[32]);
    }
    uint64_t v12 = *((void *)&v61 + 1);
    unint64_t v13 = *((void *)&v63 + 1) + v63 - 1;
    unint64_t v14 = v13 / 0x2A;
    uint64_t v15 = *(void *)(*((void *)&v61 + 1) + 8 * (v13 / 0x2A));
    unint64_t v16 = 3 * (v13 % 0x2A);
    uint64_t v17 = v15 + 32 * v16;
    *(_DWORD *)uint64_t v17 = 0;
    *(void *)(v17 + 8) = a2;
    *(void *)(*(void *)(v12 + 8 * v14) + 32 * v16 + 16) = a2;
    *(void *)(*(void *)(v12 + 8 * v14) + 32 * v16 + 24) = a3;
    std::vector<std::pair<unsigned long,char const*>>::resize((std::vector<std::pair<unsigned long, const char *>> *)(*(void *)(v12 + 8 * v14) + 32 * v16 + 56), *(unsigned int *)(a1 + 32));
    char v55 = 0;
    unsigned int v18 = 0;
    uint64_t v53 = 0;
    uint64_t v54 = a2;
    uint64_t v19 = *((void *)&v63 + 1);
    uint64_t v20 = *((void *)&v61 + 1);
    unint64_t v21 = *((void *)&v63 + 1) + v63 - 1;
    unint64_t v22 = v21 / 0x2A;
    unint64_t v23 = 3 * (v21 % 0x2A);
    *(void *)(*(void *)(*((void *)&v61 + 1) + 8 * v22) + 32 * v23 + 80) = v6;
    uint64_t v24 = a3 - a2;
    uint64_t v25 = *(void *)(v20 + 8 * v22) + 32 * v23;
    *(_DWORD *)(v25 + 88) = a5;
    *(unsigned char *)(v25 + 92) = a6;
    uint64_t v52 = a3;
    while (2)
    {
      if ((++v18 & 0xFFF) == 0 && (int)(v18 >> 12) >= (int)v24) {
        std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)12>();
      }
      unint64_t v27 = v19 + v63 - 1;
      uint64_t v28 = *(void *)(*((void *)&v61 + 1) + 8 * (v27 / 0x2A));
      unint64_t v29 = v27 % 0x2A;
      uint64_t v30 = v28 + 96 * (v27 % 0x2A);
      char v32 = (void *)(v30 + 80);
      uint64_t v31 = *(void *)(v30 + 80);
      if (v31) {
        (*(void (**)(uint64_t, unint64_t))(*(void *)v31 + 16))(v31, v28 + 96 * v29);
      }
      switch(*(_DWORD *)v30)
      {
        case 0xFFFFFC18:
          uint64_t v33 = *(void *)(v28 + 96 * v29 + 16);
          BOOL v35 = (a5 & 0x1000) == 0 || v33 == v52;
          BOOL v36 = v33 != v54 || (a5 & 0x20) == 0;
          if (!v36 || !v35) {
            goto LABEL_37;
          }
          uint64_t v37 = v33 - *(void *)(v28 + 96 * v29 + 8);
          uint64_t v38 = v53;
          if ((v55 & (v53 >= v37)) == 0) {
            uint64_t v38 = v37;
          }
          if (v38 != v24)
          {
            uint64_t v53 = v38;
            std::deque<std::__state<char>>::pop_back(&v61);
            char v55 = 1;
            goto LABEL_38;
          }
          __int16 v39 = (void **)*((void *)&v61 + 1);
          uint64_t v40 = v62;
          if ((void)v62 == *((void *)&v61 + 1))
          {
            uint64_t v40 = *((void *)&v61 + 1);
          }
          else
          {
            __int16 v41 = (void *)(*((void *)&v61 + 1) + 8 * ((unint64_t)v63 / 0x2A));
            uint64_t v42 = (void *)(*v41 + 96 * ((unint64_t)v63 % 0x2A));
            unint64_t v43 = *(void *)(*((void *)&v61 + 1) + 8 * ((*((void *)&v63 + 1) + (void)v63) / 0x2AuLL))
                + 96 * ((*((void *)&v63 + 1) + (void)v63) % 0x2AuLL);
            if (v42 != (void *)v43)
            {
              do
              {
                std::__destroy_at[abi:ne180100]<std::__state<char>,0>(v42);
                v42 += 12;
                if ((void *)((char *)v42 - *v41) == (void *)4032)
                {
                  long long v44 = (void *)v41[1];
                  ++v41;
                  uint64_t v42 = v44;
                }
              }
              while (v42 != (void *)v43);
              __int16 v39 = (void **)*((void *)&v61 + 1);
              uint64_t v40 = v62;
            }
          }
          *((void *)&v63 + 1) = 0;
          unint64_t v47 = v40 - (void)v39;
          if (v47 >= 0x11)
          {
            do
            {
              operator delete(*v39);
              __int16 v39 = (void **)(*((void *)&v61 + 1) + 8);
              *((void *)&v61 + 1) = v39;
              unint64_t v47 = v62 - (void)v39;
            }
            while ((void)v62 - (void)v39 > 0x10uLL);
          }
          if (v47 >> 3 == 1)
          {
            uint64_t v48 = 21;
          }
          else
          {
            if (v47 >> 3 != 2) {
              goto LABEL_53;
            }
            uint64_t v48 = 42;
          }
          *(void *)&long long v63 = v48;
LABEL_53:
          char v55 = 1;
          uint64_t v53 = v24;
LABEL_38:
          uint64_t v19 = *((void *)&v63 + 1);
          if (*((void *)&v63 + 1)) {
            continue;
          }
          if (v55)
          {
            uint64_t v49 = *v51;
            *(void *)uint64_t v49 = v54;
            *(void *)(v49 + 8) = v54 + v53;
            uint64_t v6 = 1;
            *(unsigned char *)(v49 + 16) = 1;
          }
          else
          {
            uint64_t v6 = 0;
          }
          break;
        case 0xFFFFFC19:
        case 0xFFFFFC1E:
        case 0xFFFFFC21:
          goto LABEL_38;
        case 0xFFFFFC1D:
          std::deque<std::__state<char>>::push_front((uint64_t)&v61, v28 + 96 * v29);
          goto LABEL_37;
        case 0xFFFFFC1F:
LABEL_37:
          std::deque<std::__state<char>>::pop_back(&v61);
          goto LABEL_38;
        case 0xFFFFFC20:
          long long v45 = *(_OWORD *)(v30 + 16);
          *(_OWORD *)uint64_t v57 = *(_OWORD *)v30;
          *(_OWORD *)&v57[16] = v45;
          long long v58 = 0uLL;
          *(void *)&v57[32] = 0;
          std::vector<std::sub_match<char const*>>::__init_with_size[abi:ne180100]<std::sub_match<char const*>*,std::sub_match<char const*>*>(&v57[32], *(long long **)(v28 + 96 * v29 + 32), *(long long **)(v28 + 96 * v29 + 40), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v28 + 96 * v29 + 40) - *(void *)(v28 + 96 * v29 + 32)) >> 3));
          __p[0] = 0;
          __p[1] = 0;
          v60[0] = 0;
          std::vector<std::pair<unsigned long,char const*>>::__init_with_size[abi:ne180100]<std::pair<unsigned long,char const*>*,std::pair<unsigned long,char const*>*>((char *)__p, *(long long **)(v28 + 96 * v29 + 56), *(long long **)(v28 + 96 * v29 + 64), (uint64_t)(*(void *)(v28 + 96 * v29 + 64) - *(void *)(v28 + 96 * v29 + 56)) >> 4);
          uint64_t v46 = *v32;
          *(void *)((char *)&v60[1] + 5) = *(void *)(v30 + 85);
          v60[1] = v46;
          (*(void (**)(void, uint64_t, unint64_t))(*(void *)*v32 + 24))(*v32, 1, v28 + 96 * v29);
          (*(void (**)(void, void, unsigned char *))(*(void *)v60[1] + 24))(v60[1], 0, v57);
          std::deque<std::__state<char>>::push_back(&v61, (uint64_t)v57);
          if (__p[0])
          {
            __p[1] = __p[0];
            operator delete(__p[0]);
          }
          if (*(void *)&v57[32])
          {
            *(void *)&long long v58 = *(void *)&v57[32];
            operator delete(*(void **)&v57[32]);
          }
          goto LABEL_38;
        default:
          std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)16>();
      }
      break;
    }
  }
  std::deque<std::__state<char>>::~deque[abi:ne180100](&v61);
  return v6;
}

void sub_1D3505244(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__match_at_start_posix_subs<std::allocator<std::sub_match<char const*>>>(uint64_t a1, const char *a2, const char *a3, uint64_t *a4, int a5, char a6)
{
  char v55 = 0;
  int64_t v56 = 0;
  unint64_t v57 = 0;
  *(_DWORD *)uint64_t v52 = 0;
  memset(&v52[8], 0, 32);
  long long v53 = 0u;
  memset(v54, 0, 37);
  uint64_t v6 = *(void *)(a1 + 40);
  if (!v6) {
    goto LABEL_43;
  }
  __x.first = a3;
  __x.second = a3;
  __x.matched = 0;
  *(_DWORD *)uint64_t v48 = 0;
  memset(&v48[8], 0, 48);
  *(_OWORD *)std::vector<std::csub_match> __p = 0uLL;
  memset(v50, 0, 21);
  int64_t v56 = (_OWORD *)std::vector<std::__state<char>>::__push_back_slow_path<std::__state<char>>((uint64_t *)&v55, (uint64_t)v48);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (*(void *)&v48[32])
  {
    *(void *)&v48[40] = *(void *)&v48[32];
    operator delete(*(void **)&v48[32]);
  }
  long long v44 = a4;
  uint64_t v12 = v56;
  *((_DWORD *)v56 - 24) = 0;
  *((void *)v12 - 11) = a2;
  *((void *)v12 - 10) = a2;
  *((void *)v12 - 9) = a3;
  std::vector<std::sub_match<char const*>>::resize((std::vector<std::csub_match> *)(v12 - 4), *(unsigned int *)(a1 + 28), &__x);
  std::vector<std::pair<unsigned long,char const*>>::resize((std::vector<std::pair<unsigned long, const char *>> *)((char *)v56 - 40), *(unsigned int *)(a1 + 32));
  long long v45 = a3;
  uint64_t v46 = 0;
  char v13 = 0;
  unsigned int v14 = 0;
  uint64_t v15 = (const char *)(a3 - a2);
  unint64_t v16 = v56;
  *((void *)v56 - 2) = v6;
  *((_DWORD *)v16 - 2) = a5;
  *((unsigned char *)v16 - 4) = a6;
  do
  {
    BOOL v17 = (++v14 & 0xFFF) != 0 || (int)(v14 >> 12) < (int)v15;
    if (!v17) {
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)12>();
    }
    uint64_t v19 = v16 - 1;
    uint64_t v18 = *((void *)v16 - 2);
    uint64_t v20 = v16 - 6;
    if (v18) {
      (*(void (**)(uint64_t, _OWORD *))(*(void *)v18 + 16))(v18, v16 - 6);
    }
    switch(*(_DWORD *)v20)
    {
      case 0xFFFFFC18:
        unint64_t v21 = (const char *)*((void *)v16 - 10);
        if ((a5 & 0x20) != 0 && v21 == a2 || (a5 & 0x1000) != 0 && v21 != v45) {
          goto LABEL_19;
        }
        char v28 = v13;
        unint64_t v29 = &v21[-*((void *)v16 - 11)];
        uint64_t v30 = v46;
        if ((v28 & ((uint64_t)v46 >= (uint64_t)v29)) == 0)
        {
          long long v31 = *(v16 - 5);
          *(_OWORD *)uint64_t v52 = *(_OWORD *)v20;
          *(_OWORD *)&v52[16] = v31;
          if (v52 != v20)
          {
            std::vector<std::sub_match<char const*>>::__assign_with_size[abi:ne180100]<std::sub_match<char const*>*,std::sub_match<char const*>*>(&v52[32], *((long long **)v16 - 8), *((long long **)v16 - 7), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)v16 - 7) - *((void *)v16 - 8)) >> 3));
            std::vector<std::pair<unsigned long,char const*>>::__assign_with_size[abi:ne180100]<std::pair<unsigned long,char const*>*,std::pair<unsigned long,char const*>*>(v54, *((uint64_t **)v16 - 5), *((uint64_t **)v16 - 4), (uint64_t)(*((void *)v16 - 4) - *((void *)v16 - 5)) >> 4);
          }
          char v32 = (void *)*v19;
          *(void **)((char *)&v54[3] + 5) = *(void **)((char *)v16 - 11);
          v54[3] = v32;
          uint64_t v30 = v29;
        }
        uint64_t v33 = v56;
        if (v30 == v15)
        {
          uint64_t v34 = (uint64_t)v55;
          while (v33 != (void *)v34)
          {
            v33 -= 12;
            std::__destroy_at[abi:ne180100]<std::__state<char>,0>(v33);
          }
          int64_t v56 = (_OWORD *)v34;
          char v13 = 1;
          uint64_t v46 = v15;
        }
        else
        {
          uint64_t v46 = v30;
          BOOL v35 = v56 - 6;
          std::__destroy_at[abi:ne180100]<std::__state<char>,0>((void *)v56 - 12);
          int64_t v56 = v35;
          char v13 = 1;
        }
        break;
      case 0xFFFFFC1D:
      case 0xFFFFFC1E:
      case 0xFFFFFC21:
        break;
      case 0xFFFFFC1F:
LABEL_19:
        unint64_t v22 = v56 - 6;
        std::__destroy_at[abi:ne180100]<std::__state<char>,0>((void *)v56 - 12);
        int64_t v56 = v22;
        break;
      case 0xFFFFFC20:
        long long v23 = *(v16 - 5);
        *(_OWORD *)uint64_t v48 = *(_OWORD *)v20;
        *(_OWORD *)&v48[16] = v23;
        memset(&v48[32], 0, 24);
        std::vector<std::sub_match<char const*>>::__init_with_size[abi:ne180100]<std::sub_match<char const*>*,std::sub_match<char const*>*>(&v48[32], *((long long **)v16 - 8), *((long long **)v16 - 7), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)v16 - 7) - *((void *)v16 - 8)) >> 3));
        __p[0] = 0;
        __p[1] = 0;
        v50[0] = 0;
        std::vector<std::pair<unsigned long,char const*>>::__init_with_size[abi:ne180100]<std::pair<unsigned long,char const*>*,std::pair<unsigned long,char const*>*>((char *)__p, *((long long **)v16 - 5), *((long long **)v16 - 4), (uint64_t)(*((void *)v16 - 4) - *((void *)v16 - 5)) >> 4);
        uint64_t v24 = (void *)*v19;
        *(void *)((char *)&v50[1] + 5) = *(void *)((char *)v16 - 11);
        v50[1] = v24;
        (*(void (**)(void, uint64_t, _OWORD *))(*(void *)*v19 + 24))(*v19, 1, v16 - 6);
        (*(void (**)(void, void, unsigned char *))(*(void *)v50[1] + 24))(v50[1], 0, v48);
        uint64_t v25 = v56;
        if ((unint64_t)v56 >= v57)
        {
          int64_t v56 = (_OWORD *)std::vector<std::__state<char>>::__push_back_slow_path<std::__state<char>>((uint64_t *)&v55, (uint64_t)v48);
          if (__p[0])
          {
            __p[1] = __p[0];
            operator delete(__p[0]);
          }
        }
        else
        {
          long long v26 = *(_OWORD *)&v48[16];
          *int64_t v56 = *(_OWORD *)v48;
          v25[1] = v26;
          *((void *)v25 + 4) = 0;
          *((void *)v25 + 5) = 0;
          *((void *)v25 + 6) = 0;
          *((void *)v25 + 7) = 0;
          void v25[2] = *(_OWORD *)&v48[32];
          *((void *)v25 + 6) = *(void *)&v48[48];
          memset(&v48[32], 0, 24);
          *((void *)v25 + 8) = 0;
          *((void *)v25 + 9) = 0;
          *(_OWORD *)((char *)v25 + 56) = *(_OWORD *)__p;
          *((void *)v25 + 9) = v50[0];
          __p[0] = 0;
          __p[1] = 0;
          v50[0] = 0;
          uint64_t v27 = v50[1];
          *(void *)((char *)v25 + 85) = *(void *)((char *)&v50[1] + 5);
          *((void *)v25 + 10) = v27;
          int64_t v56 = v25 + 6;
        }
        if (*(void *)&v48[32])
        {
          *(void *)&v48[40] = *(void *)&v48[32];
          operator delete(*(void **)&v48[32]);
        }
        break;
      default:
        std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)16>();
    }
    unint64_t v16 = v56;
  }
  while (v55 != v56);
  if (v13)
  {
    uint64_t v36 = *v44;
    *(void *)uint64_t v36 = a2;
    *(void *)(v36 + 8) = &v46[(void)a2];
    *(unsigned char *)(v36 + 16) = 1;
    if ((void)v53 != *(void *)&v52[32])
    {
      unint64_t v37 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v53 - *(void *)&v52[32]) >> 3);
      uint64_t v38 = (unsigned char *)(*(void *)&v52[32] + 16);
      unsigned int v39 = 1;
      do
      {
        uint64_t v40 = v36 + 24 * v39;
        *(_OWORD *)uint64_t v40 = *((_OWORD *)v38 - 1);
        char v41 = *v38;
        v38 += 24;
        *(unsigned char *)(v40 + 16) = v41;
        BOOL v17 = v37 > v39++;
      }
      while (v17);
    }
    uint64_t v42 = 1;
  }
  else
  {
LABEL_43:
    uint64_t v42 = 0;
  }
  if (v54[0])
  {
    v54[1] = v54[0];
    operator delete(v54[0]);
  }
  if (*(void *)&v52[32])
  {
    *(void *)&long long v53 = *(void *)&v52[32];
    operator delete(*(void **)&v52[32]);
  }
  *(void *)uint64_t v52 = &v55;
  std::vector<std::__state<char>>::__destroy_vector::operator()[abi:ne180100]((void ***)v52);
  return v42;
}

void sub_1D35057DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33)
{
  std::__state<char>::~__state(&a17);
  std::__state<char>::~__state(&a33);
  a33 = v33 - 120;
  std::vector<std::__state<char>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a33);
  _Unwind_Resume(a1);
}

__n128 std::deque<std::__state<char>>::push_back(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 42 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    std::deque<std::__state<char>>::__add_back_capacity(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }
  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x2A)) + 96 * (v7 % 0x2A);
  long long v9 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)unint64_t v8 = *(_OWORD *)a2;
  *(_OWORD *)(v8 + 16) = v9;
  *(void *)(v8 + 40) = 0;
  *(void *)(v8 + 48) = 0;
  *(void *)(v8 + 32) = 0;
  *(_OWORD *)(v8 + 32) = *(_OWORD *)(a2 + 32);
  *(void *)(v8 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(v8 + 56) = 0;
  *(void *)(v8 + 64) = 0;
  *(void *)(v8 + 72) = 0;
  __n128 result = *(__n128 *)(a2 + 56);
  *(__n128 *)(v8 + 56) = result;
  *(void *)(v8 + 72) = *(void *)(a2 + 72);
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  uint64_t v11 = *(void *)(a2 + 80);
  *(void *)(v8 + 85) = *(void *)(a2 + 85);
  *(void *)(v8 + 80) = v11;
  ++a1[5];
  return result;
}

uint64_t std::deque<std::__state<char>>::pop_back(void *a1)
{
  unint64_t v2 = a1[5] + a1[4] - 1;
  std::__destroy_at[abi:ne180100]<std::__state<char>,0>((void *)(*(void *)(a1[1] + 8 * (v2 / 0x2A))
                                                                 + 96 * (v2 % 0x2A)));
  --a1[5];
  return std::deque<std::__state<char>>::__maybe_remove_back_spare[abi:ne180100](a1, 1);
}

int64x2_t std::deque<std::__state<char>>::push_front(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 32);
  if (!v4)
  {
    std::deque<std::__state<char>>::__add_front_capacity((void **)a1);
    unint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = (void *)(v5 + 8 * (v4 / 0x2A));
  uint64_t v7 = *v6 + 96 * (v4 % 0x2A);
  if (*(void *)(a1 + 16) == v5) {
    uint64_t v7 = 0;
  }
  if (v7 == *v6) {
    uint64_t v7 = *(v6 - 1) + 4032;
  }
  long long v8 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v7 - 96) = *(_OWORD *)a2;
  *(_OWORD *)(v7 - 80) = v8;
  *(void *)(v7 - 56) = 0;
  *(void *)(v7 - 48) = 0;
  *(void *)(v7 - 64) = 0;
  *(_OWORD *)(v7 - 64) = *(_OWORD *)(a2 + 32);
  *(void *)(v7 - 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(v7 - 40) = 0;
  *(void *)(v7 - 32) = 0;
  *(void *)(v7 - 24) = 0;
  *(_OWORD *)(v7 - 40) = *(_OWORD *)(a2 + 56);
  *(void *)(v7 - 24) = *(void *)(a2 + 72);
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  uint64_t v9 = *(void *)(a2 + 80);
  *(void *)(v7 - 11) = *(void *)(a2 + 85);
  *(void *)(v7 - 16) = v9;
  int64x2_t result = vaddq_s64(*(int64x2_t *)(a1 + 32), (int64x2_t)xmmword_1D350D030);
  *(int64x2_t *)(a1 + 32) = result;
  return result;
}

void std::deque<std::__state<char>>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x2A;
  unint64_t v4 = v2 - 42;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    long long v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)long long v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v5, v33);
      BOOL v35 = &v34[8 * (v33 >> 2)];
      unint64_t v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      long long v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        long long v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        char v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)char v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      uint64_t v9 = (char *)a1[1];
    }
    long long v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0xFC0uLL);
      std::__split_buffer<TNodeEventPtr *>::push_back(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0xFC0uLL);
    std::__split_buffer<TNodeEventPtr *>::push_front((uint64_t)a1, &v54);
    long long v44 = (void *)a1[1];
    long long v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    uint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)(a1 + 3), v46);
      BOOL v35 = &v34[8 * (v46 >> 2)];
      unint64_t v37 = &v34[8 * v47];
      uint64_t v48 = (uint64_t *)a1[1];
      long long v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        long long v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        int v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)int v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      unint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        long long v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  int64_t v56 = a1 + 3;
  *(void *)&long long v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  long long v53 = operator new(0xFC0uLL);
  std::__split_buffer<TNodeEventPtr *>::push_back(&v54, &v53);
  uint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<TNodeEventPtr *>::push_front((uint64_t)&v54, v27);
  }
  unint64_t v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_1D3505DB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t std::deque<std::__state<char>>::__maybe_remove_back_spare[abi:ne180100](void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = 42 * ((v2 - v3) >> 3) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x2A) {
    a2 = 1;
  }
  if (v5 < 0x54) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8;
  }
  return v7 ^ 1u;
}

void std::deque<std::__state<char>>::__add_front_capacity(void **a1)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = a1[2];
  unint64_t v4 = (v3 - v2) >> 3;
  if (v3 == v2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = 42 * v4 - 1;
  }
  uint64_t v6 = (char *)a1[4];
  if (v5 - (unint64_t)&v6[(void)a1[5]] < 0x2A)
  {
    uint64_t v7 = (uint64_t)(a1 + 3);
    long long v8 = a1[3];
    uint64_t v9 = *a1;
    uint64_t v10 = v8 - (unsigned char *)*a1;
    if (v4 >= v10 >> 3)
    {
      if (v8 == v9) {
        unint64_t v11 = 1;
      }
      else {
        unint64_t v11 = v10 >> 2;
      }
      unint64_t v46 = a1 + 3;
      std::vector<std::csub_match> __p = std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>(v7, v11);
      unint64_t v43 = (char *)__p;
      long long v44 = (char *)__p;
      uint64_t v45 = (char *)__p + 8 * v12;
      char v41 = operator new(0xFC0uLL);
      std::__split_buffer<TNodeEventPtr *>::push_back(&__p, &v41);
      uint64_t v13 = (char *)a1[1];
      BOOL v14 = v44;
      if (v13 == a1[2])
      {
        unint64_t v33 = (char *)a1[1];
      }
      else
      {
        do
        {
          if (v14 == v45)
          {
            int64_t v15 = v43 - (unsigned char *)__p;
            if (v43 <= __p)
            {
              if (v14 == __p) {
                unint64_t v23 = 1;
              }
              else {
                unint64_t v23 = (v14 - (unsigned char *)__p) >> 2;
              }
              uint64_t v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<TNodeEventPtr>>((uint64_t)v46, v23);
              uint64_t v26 = v43;
              BOOL v14 = &v24[8 * (v23 >> 2)];
              uint64_t v27 = v44 - v43;
              if (v44 != v43)
              {
                BOOL v14 = &v24[8 * (v23 >> 2) + (v27 & 0xFFFFFFFFFFFFFFF8)];
                uint64_t v28 = 8 * (v27 >> 3);
                unint64_t v29 = &v24[8 * (v23 >> 2)];
                do
                {
                  uint64_t v30 = *(void *)v26;
                  v26 += 8;
                  *(void *)unint64_t v29 = v30;
                  v29 += 8;
                  v28 -= 8;
                }
                while (v28);
              }
              long long v31 = __p;
              std::vector<std::csub_match> __p = v24;
              unint64_t v43 = &v24[8 * (v23 >> 2)];
              long long v44 = v14;
              uint64_t v45 = &v24[8 * v25];
              if (v31)
              {
                operator delete(v31);
                BOOL v14 = v44;
              }
            }
            else
            {
              uint64_t v16 = v15 >> 3;
              BOOL v17 = v15 >> 3 < -1;
              uint64_t v18 = (v15 >> 3) + 2;
              if (v17) {
                uint64_t v19 = v18;
              }
              else {
                uint64_t v19 = v16 + 1;
              }
              int64_t v20 = &v43[-8 * (v19 >> 1)];
              int64_t v21 = v14 - v43;
              if (v14 != v43)
              {
                memmove(&v43[-8 * (v19 >> 1)], v43, v14 - v43);
                BOOL v14 = v43;
              }
              unint64_t v22 = &v14[-8 * (v19 >> 1)];
              BOOL v14 = &v20[v21];
              unint64_t v43 = v22;
              long long v44 = &v20[v21];
            }
          }
          uint64_t v32 = *(void *)v13;
          v13 += 8;
          *(void *)BOOL v14 = v32;
          BOOL v14 = v44 + 8;
          v44 += 8;
        }
        while (v13 != a1[2]);
        unint64_t v33 = (char *)a1[1];
      }
      uint64_t v36 = *a1;
      unint64_t v37 = v43;
      *a1 = __p;
      a1[1] = v37;
      std::vector<std::csub_match> __p = v36;
      unint64_t v43 = v33;
      uint64_t v38 = (char *)a1[3];
      uint64_t v39 = v45;
      a1[2] = v14;
      a1[3] = v39;
      long long v44 = v13;
      uint64_t v45 = v38;
      if (v14 - v37 == 8) {
        uint64_t v40 = 21;
      }
      else {
        uint64_t v40 = (uint64_t)a1[4] + 42;
      }
      a1[4] = (void *)v40;
      if (v13 != v33) {
        long long v44 = &v13[(v33 - v13 + 7) & 0xFFFFFFFFFFFFFFF8];
      }
      if (v36) {
        operator delete(v36);
      }
    }
    else
    {
      if (v2 == v9)
      {
        std::vector<std::csub_match> __p = operator new(0xFC0uLL);
        std::__split_buffer<TNodeEventPtr *>::push_back(a1, &__p);
        uint64_t v34 = a1[2];
        std::vector<std::csub_match> __p = (void *)*(v34 - 1);
        a1[2] = v34 - 1;
      }
      else
      {
        std::vector<std::csub_match> __p = operator new(0xFC0uLL);
      }
      std::__split_buffer<TNodeEventPtr *>::push_front((uint64_t)a1, &__p);
      if ((unsigned char *)a1[2] - (unsigned char *)a1[1] == 8) {
        uint64_t v35 = 21;
      }
      else {
        uint64_t v35 = (uint64_t)a1[4] + 42;
      }
      a1[4] = (void *)v35;
    }
  }
  else
  {
    a1[4] = v6 + 42;
    std::vector<std::csub_match> __p = (void *)*((void *)v3 - 1);
    a1[2] = v3 - 8;
    std::__split_buffer<TNodeEventPtr *>::push_front((uint64_t)a1, &__p);
  }
}

void sub_1D3506144(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  operator delete(v12);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t std::deque<std::__state<char>>::~deque[abi:ne180100](void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  if (v3 == v2)
  {
    unint64_t v4 = a1 + 5;
    uint64_t v3 = (void **)a1[1];
  }
  else
  {
    unint64_t v4 = a1 + 5;
    unint64_t v5 = a1[4];
    uint64_t v6 = &v2[v5 / 0x2A];
    uint64_t v7 = (char *)*v6 + 96 * (v5 % 0x2A);
    unint64_t v8 = (unint64_t)v2[(a1[5] + v5) / 0x2A] + 96 * ((a1[5] + v5) % 0x2A);
    if (v7 != (char *)v8)
    {
      do
      {
        std::__destroy_at[abi:ne180100]<std::__state<char>,0>(v7);
        v7 += 96;
        if (v7 - (unsigned char *)*v6 == 4032)
        {
          uint64_t v9 = (char *)v6[1];
          ++v6;
          uint64_t v7 = v9;
        }
      }
      while (v7 != (char *)v8);
      uint64_t v2 = (void **)a1[1];
      uint64_t v3 = (void **)a1[2];
    }
  }
  void *v4 = 0;
  unint64_t v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v10 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 21;
  }
  else
  {
    if (v11 != 2) {
      goto LABEL_16;
    }
    uint64_t v12 = 42;
  }
  a1[4] = v12;
LABEL_16:
  while (v2 != v3)
  {
    uint64_t v13 = *v2++;
    operator delete(v13);
  }
  return std::__split_buffer<TNodeEventPtr *>::~__split_buffer((uint64_t)a1);
}

char *std::vector<std::sub_match<char const*>>::__assign_with_size[abi:ne180100]<std::sub_match<char const*>*,std::sub_match<char const*>*>(void *a1, long long *a2, long long *a3, unint64_t a4)
{
  uint64_t v6 = a2;
  uint64_t v8 = a1[2];
  int64x2_t result = (char *)*a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - (uint64_t)result) >> 3) >= a4)
  {
    uint64_t v19 = (char *)a1[1];
    BOOL v14 = a1 + 1;
    uint64_t v13 = v19;
    unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((v19 - result) >> 3);
    if (v20 >= a4)
    {
      uint64_t v25 = result;
      if (a2 != a3)
      {
        uint64_t v26 = result;
        do
        {
          *(_OWORD *)uint64_t v26 = *v6;
          v26[16] = *((unsigned char *)v6 + 16);
          v25 += 24;
          uint64_t v6 = (long long *)((char *)v6 + 24);
          v26 += 24;
        }
        while (v6 != a3);
      }
      int64_t v18 = v25 - result;
      uint64_t v13 = result;
    }
    else
    {
      int64_t v21 = (long long *)((char *)a2 + 24 * v20);
      if (v13 != result)
      {
        do
        {
          *(_OWORD *)int64x2_t result = *v6;
          result[16] = *((unsigned char *)v6 + 16);
          uint64_t v6 = (long long *)((char *)v6 + 24);
          result += 24;
        }
        while (v6 != v21);
      }
      unint64_t v22 = v13;
      if (v21 != a3)
      {
        unint64_t v23 = v13;
        do
        {
          long long v24 = *v21;
          *((void *)v23 + 2) = *((void *)v21 + 2);
          *(_OWORD *)unint64_t v23 = v24;
          v23 += 24;
          int64_t v21 = (long long *)((char *)v21 + 24);
          v22 += 24;
        }
        while (v21 != a3);
      }
      int64_t v18 = v22 - v13;
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v11;
    }
    int64x2_t result = std::vector<std::sub_match<char const*>>::__vallocate[abi:ne180100](a1, v12);
    int64_t v15 = (char *)a1[1];
    BOOL v14 = a1 + 1;
    uint64_t v13 = v15;
    uint64_t v16 = v15;
    if (v6 != a3)
    {
      uint64_t v16 = v13;
      do
      {
        long long v17 = *v6;
        *((void *)v16 + 2) = *((void *)v6 + 2);
        *(_OWORD *)uint64_t v16 = v17;
        v16 += 24;
        uint64_t v6 = (long long *)((char *)v6 + 24);
      }
      while (v6 != a3);
    }
    int64_t v18 = v16 - v13;
  }
  *BOOL v14 = &v13[v18];
  return result;
}

char *std::vector<std::pair<unsigned long,char const*>>::__assign_with_size[abi:ne180100]<std::pair<unsigned long,char const*>*,std::pair<unsigned long,char const*>*>(void *a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6 = a2;
  uint64_t v8 = a1[2];
  int64x2_t result = (char *)*a1;
  if (a4 <= (v8 - (uint64_t)result) >> 4)
  {
    int64_t v18 = (char *)a1[1];
    uint64_t v13 = a1 + 1;
    unint64_t v12 = v18;
    unint64_t v19 = (v18 - result) >> 4;
    if (v19 >= a4)
    {
      uint64_t v26 = result;
      if (a2 != a3)
      {
        uint64_t v27 = result;
        do
        {
          uint64_t v28 = *v6;
          uint64_t v29 = v6[1];
          v6 += 2;
          *(void *)uint64_t v27 = v28;
          *((void *)v27 + 1) = v29;
          v27 += 16;
          v26 += 16;
        }
        while (v6 != a3);
      }
      long long v17 = (char *)(v26 - result);
      unint64_t v12 = result;
    }
    else
    {
      unint64_t v20 = (long long *)&a2[2 * v19];
      if (v12 != result)
      {
        do
        {
          uint64_t v21 = *v6;
          uint64_t v22 = v6[1];
          v6 += 2;
          *(void *)int64x2_t result = v21;
          *((void *)result + 1) = v22;
          result += 16;
        }
        while (v6 != (uint64_t *)v20);
      }
      unint64_t v23 = v12;
      if (v20 != (long long *)a3)
      {
        long long v24 = v12;
        do
        {
          long long v25 = *v20++;
          *(_OWORD *)long long v24 = v25;
          v24 += 16;
          v23 += 16;
        }
        while (v20 != (long long *)a3);
      }
      long long v17 = (char *)(v23 - v12);
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 >> 60) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 3;
    if (v8 >> 3 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    int64x2_t result = std::vector<std::pair<TString,TString>>::__vallocate[abi:ne180100](a1, v11);
    BOOL v14 = (char *)a1[1];
    uint64_t v13 = a1 + 1;
    unint64_t v12 = v14;
    int64_t v15 = v14;
    if (v6 != a3)
    {
      int64_t v15 = v12;
      do
      {
        long long v16 = *(_OWORD *)v6;
        v6 += 2;
        *(_OWORD *)int64_t v15 = v16;
        v15 += 16;
      }
      while (v6 != a3);
    }
    long long v17 = (char *)(v15 - v12);
  }
  *uint64_t v13 = &v17[(void)v12];
  return result;
}

uint64_t std::regex_match[abi:ne180100]<std::__wrap_iter<char const*>,std::allocator<std::sub_match<std::__wrap_iter<char const*>>>,char,std::regex_traits<char>>(char *__f, char *__l, uint64_t a3, uint64_t a4, int a5)
{
  __int16 v5 = a5;
  memset(&__p.__prefix_, 0, 17);
  memset(&__p.__suffix_, 0, 17);
  __p.__ready_ = 0;
  __p.__position_start_ = 0;
  memset(&__p, 0, 41);
  int v9 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>(a4, __f, __l, &__p, a5 | 0x1040u);
  std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>((std::vector<std::ssub_match> *)a3, (uint64_t)__f, (std::sub_match<std::__wrap_iter<const char *>> *)__l, (uint64_t *)&__p, (v5 & 0x800) != 0);
  if (__p.__matches_.__begin_)
  {
    __p.__matches_.__end_ = __p.__matches_.__begin_;
    operator delete(__p.__matches_.__begin_);
  }
  if (!v9) {
    return 0;
  }
  if (!*(unsigned char *)(a3 + 88)) {
    return 1;
  }
  uint64_t result = 0;
  *(void *)(a3 + 8) = *(void *)a3;
  return result;
}

void sub_1D35066D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>(std::vector<std::ssub_match> *a1, uint64_t a2, std::sub_match<std::__wrap_iter<const char *>> *a3, uint64_t *a4, char a5)
{
  uint64_t v10 = a4[6];
  std::vector<std::sub_match<std::__wrap_iter<char const*>>>::resize(a1, 0xAAAAAAAAAAAAAAABLL * ((a4[1] - *a4) >> 3));
  std::vector<std::ssub_match>::pointer begin = a1->__begin_;
  if (a1->__end_ != a1->__begin_)
  {
    unint64_t v12 = 0;
    unint64_t v13 = 0;
    uint64_t v15 = *a4;
    uint64_t v14 = a4[1];
    do
    {
      unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v14 - v15) >> 3);
      long long v17 = (void *)(v15 + v12 * 24);
      if (v16 <= v13) {
        int64_t v18 = a4 + 3;
      }
      else {
        int64_t v18 = v17;
      }
      begin[v12].first.__i_ = (std::__wrap_iter<const char *>::iterator_type)(a2 + *v18 - v10);
      if (0xAAAAAAAAAAAAAAABLL * ((a4[1] - *a4) >> 3) <= v13) {
        unint64_t v19 = a4 + 3;
      }
      else {
        unint64_t v19 = (uint64_t *)(*a4 + v12 * 24);
      }
      a1->__begin_[v12].second.__i_ = (std::__wrap_iter<const char *>::iterator_type)(a2 + v19[1] - v10);
      uint64_t v15 = *a4;
      uint64_t v14 = a4[1];
      if (0xAAAAAAAAAAAAAAABLL * ((v14 - *a4) >> 3) <= v13) {
        unint64_t v20 = a4 + 3;
      }
      else {
        unint64_t v20 = (uint64_t *)(*a4 + v12 * 24);
      }
      char v21 = *((unsigned char *)v20 + 16);
      std::vector<std::ssub_match>::pointer begin = a1->__begin_;
      std::vector<std::ssub_match>::pointer end = a1->__end_;
      a1->__begin_[v12].matched = v21;
      ++v13;
      ++v12;
    }
    while (v13 < 0xAAAAAAAAAAAAAAABLL * (((char *)end - (char *)begin) >> 3));
  }
  a1[1].__begin_ = a3;
  a1[1].__end_ = a3;
  LOBYTE(a1[1].__end_cap_.__value_) = 0;
  unint64_t v23 = (std::sub_match<std::__wrap_iter<const char *>> *)(a2 + a4[6] - v10);
  a1[2].__begin_ = v23;
  a1[2].__end_ = (std::vector<std::ssub_match>::pointer)(a2 + a4[7] - v10);
  LOBYTE(a1[2].__end_cap_.__value_) = *((unsigned char *)a4 + 64);
  a1[3].__begin_ = (std::vector<std::ssub_match>::pointer)(a2 + a4[9] - v10);
  a1[3].__end_ = (std::vector<std::ssub_match>::pointer)(a2 + a4[10] - v10);
  LOBYTE(a1[3].__end_cap_.__value_) = *((unsigned char *)a4 + 88);
  if ((a5 & 1) == 0) {
    a1[4].__end_ = v23;
  }
  LOBYTE(a1[4].__begin_) = *((unsigned char *)a4 + 96);
}

void std::vector<std::sub_match<std::__wrap_iter<char const*>>>::resize(std::vector<std::ssub_match> *this, std::vector<std::ssub_match>::size_type __sz)
{
  std::vector<std::ssub_match>::size_type v2 = 0xAAAAAAAAAAAAAAABLL * (((char *)this->__end_ - (char *)this->__begin_) >> 3);
  BOOL v3 = __sz >= v2;
  std::vector<std::ssub_match>::size_type v4 = __sz - v2;
  if (v4 != 0 && v3)
  {
    std::vector<std::sub_match<std::__wrap_iter<char const*>>>::__append(this, v4);
  }
  else if (!v3)
  {
    this->__end_ = &this->__begin_[__sz];
  }
}

void std::vector<std::sub_match<std::__wrap_iter<char const*>>>::__append(std::vector<std::ssub_match> *this, std::vector<std::ssub_match>::size_type __n)
{
  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  __int16 v5 = value;
  uint64_t v7 = p_end_cap[-1].__value_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)v7) >> 3) >= __n)
  {
    if (__n)
    {
      unint64_t v13 = &v7[__n];
      std::vector<std::ssub_match>::size_type v14 = 24 * __n;
      do
      {
        v7->first.__i_ = 0;
        v7->second.__i_ = 0;
        v7->matched = 0;
        ++v7;
        v14 -= 24;
      }
      while (v14);
      uint64_t v7 = v13;
    }
    this->__end_ = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (((char *)v7 - (char *)this->__begin_) >> 3);
    unint64_t v9 = v8 + __n;
    if (v8 + __n > 0xAAAAAAAAAAAAAAALL) {
      std::vector<TNodeEventPtr>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (((char *)v5 - (char *)this->__begin_) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11) {
      unint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)p_end_cap, v11);
    }
    else {
      unint64_t v12 = 0;
    }
    uint64_t v15 = (std::sub_match<std::__wrap_iter<const char *>> *)&v12[24 * v8];
    unint64_t v16 = &v15[__n];
    std::vector<std::ssub_match>::size_type v17 = 24 * __n;
    int64_t v18 = v15;
    do
    {
      v18->first.__i_ = 0;
      v18->second.__i_ = 0;
      v18->matched = 0;
      ++v18;
      v17 -= 24;
    }
    while (v17);
    unint64_t v19 = (std::sub_match<std::__wrap_iter<const char *>> *)&v12[24 * v11];
    std::vector<std::ssub_match>::pointer begin = this->__begin_;
    std::vector<std::ssub_match>::pointer end = this->__end_;
    if (end != this->__begin_)
    {
      do
      {
        std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> v22 = end[-1].std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>>;
        *(void *)&v15[-1].matched = *(void *)&end[-1].matched;
        v15[-1].std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> = v22;
        --v15;
        --end;
      }
      while (end != begin);
      std::vector<std::ssub_match>::pointer end = this->__begin_;
    }
    this->__begin_ = v15;
    this->__end_ = v16;
    this->__end_cap_.__value_ = v19;
    if (end)
    {
      operator delete(end);
    }
  }
}

uint64_t std::shared_ptr<std::__empty_state<char>>::shared_ptr[abi:ne180100]<std::__empty_state<char>,void>(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 8))();
}

uint64_t APFSVolumeRole()
{
  return MEMORY[0x1F4105398]();
}

uint64_t BRGetCloudDocsRootURL()
{
  return MEMORY[0x1F4111D70]();
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  MEMORY[0x1F40D70A8]();
  return result;
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1F40D7190](allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return (CFMutableArrayRef)MEMORY[0x1F40D7198](allocator, capacity, theArray);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1F40D71B8](theArray);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x1F40D71D8]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1F40D71F0](theArray, idx);
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
}

CFTypeRef CFAutorelease(CFTypeRef arg)
{
  return (CFTypeRef)MEMORY[0x1F40D72D8](arg);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x1F40D7420]();
}

CFDictionaryRef CFBundleCopyInfoDictionaryForURL(CFURLRef url)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7478](url);
}

CFStringRef CFBundleCopyLocalizedString(CFBundleRef bundle, CFStringRef key, CFStringRef value, CFStringRef tableName)
{
  return (CFStringRef)MEMORY[0x1F40D74A8](bundle, key, value, tableName);
}

CFBundleRef CFBundleCreate(CFAllocatorRef allocator, CFURLRef bundleURL)
{
  return (CFBundleRef)MEMORY[0x1F40D7528](allocator, bundleURL);
}

CFBundleRef CFBundleGetBundleWithIdentifier(CFStringRef bundleID)
{
  return (CFBundleRef)MEMORY[0x1F40D7538](bundleID);
}

Boolean CFBundleGetPackageInfoInDirectory(CFURLRef url, UInt32 *packageType, UInt32 *packageCreator)
{
  return MEMORY[0x1F40D75B0](url, packageType, packageCreator);
}

CFTypeRef CFBundleGetValueForInfoDictionaryKey(CFBundleRef bundle, CFStringRef key)
{
  return (CFTypeRef)MEMORY[0x1F40D75D0](bundle, key);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x1F40D77E8](allocator, bytes, length);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x1F40D7818](allocator, bytes, length, bytesDeallocator);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1F40D7830](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1F40D7850](theData);
}

CFComparisonResult CFDateCompare(CFDateRef theDate, CFDateRef otherDate, void *context)
{
  return MEMORY[0x1F40D7888](theDate, otherDate, context);
}

CFDateRef CFDateCreate(CFAllocatorRef allocator, CFAbsoluteTime at)
{
  return (CFDateRef)MEMORY[0x1F40D7898](allocator, at);
}

CFAbsoluteTime CFDateGetAbsoluteTime(CFDateRef theDate)
{
  MEMORY[0x1F40D7928](theDate);
  return result;
}

CFTypeID CFDateGetTypeID(void)
{
  return MEMORY[0x1F40D7938]();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7978](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D7998](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1F40D79C0](theDict);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x1F40D7A00]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1F40D7A10](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x1F40D7A18](theDict, key, value);
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1F40D7A68](cf1, cf2);
}

CFDictionaryRef CFErrorCopyUserInfo(CFErrorRef err)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7A90](err);
}

CFIndex CFErrorGetCode(CFErrorRef err)
{
  return MEMORY[0x1F40D7AA8](err);
}

CFErrorDomain CFErrorGetDomain(CFErrorRef err)
{
  return (CFErrorDomain)MEMORY[0x1F40D7AB8](err);
}

Boolean CFFileSecurityCopyAccessControlList(CFFileSecurityRef fileSec, acl_t *accessControlList)
{
  return MEMORY[0x1F40D7B00](fileSec, accessControlList);
}

Boolean CFFileSecurityGetGroup(CFFileSecurityRef fileSec, gid_t *group)
{
  return MEMORY[0x1F40D7B28](fileSec, group);
}

Boolean CFFileSecurityGetMode(CFFileSecurityRef fileSec, mode_t *mode)
{
  return MEMORY[0x1F40D7B30](fileSec, mode);
}

Boolean CFFileSecurityGetOwner(CFFileSecurityRef fileSec, uid_t *owner)
{
  return MEMORY[0x1F40D7B38](fileSec, owner);
}

Boolean CFFileSecuritySetGroup(CFFileSecurityRef fileSec, gid_t group)
{
  return MEMORY[0x1F40D7B48](fileSec, *(void *)&group);
}

Boolean CFFileSecuritySetMode(CFFileSecurityRef fileSec, mode_t mode)
{
  return MEMORY[0x1F40D7B50](fileSec, mode);
}

Boolean CFFileSecuritySetOwner(CFFileSecurityRef fileSec, uid_t owner)
{
  return MEMORY[0x1F40D7B58](fileSec, *(void *)&owner);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1F40D7B80](cf);
}

CFHashCode CFHash(CFTypeRef cf)
{
  return MEMORY[0x1F40D7BA0](cf);
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
}

CFNotificationCenterRef CFNotificationCenterGetDistributedCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1F40D7D18]();
}

void CFNotificationCenterRemoveObserver(CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
}

CFTypeID CFNullGetTypeID(void)
{
  return MEMORY[0x1F40D7D68]();
}

CFNumberType CFNumberGetType(CFNumberRef number)
{
  return MEMORY[0x1F40D7E08](number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1F40D7E10]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1F40D7E20](number, theType, valuePtr);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7EA0](key, applicationID);
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x1F40D7F18](allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7F50](allocator, data, options, format, error);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1F40D8048](cf);
}

void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode)
{
}

CFRunLoopRef CFRunLoopGetMain(void)
{
  return (CFRunLoopRef)MEMORY[0x1F40D80B8]();
}

void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void *block)
{
}

void CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode)
{
}

CFRunLoopTimerRef CFRunLoopTimerCreate(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, CFRunLoopTimerCallBack callout, CFRunLoopTimerContext *context)
{
  return (CFRunLoopTimerRef)MEMORY[0x1F40D8180](allocator, flags, order, callout, context, fireDate, interval);
}

void CFRunLoopWakeUp(CFRunLoopRef rl)
{
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
}

Boolean CFSetContainsValue(CFSetRef theSet, const void *value)
{
  return MEMORY[0x1F40D81F8](theSet, value);
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return (CFMutableSetRef)MEMORY[0x1F40D8210](allocator, capacity, callBacks);
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  return MEMORY[0x1F40D8220](theSet);
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
}

void CFStringAppendCString(CFMutableStringRef theString, const char *cStr, CFStringEncoding encoding)
{
}

void CFStringAppendCharacters(CFMutableStringRef theString, const UniChar *chars, CFIndex numChars)
{
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1F40D8388](theString1, theString2, compareOptions);
}

CFComparisonResult CFStringCompareWithOptions(CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1F40D8390](theString1, theString2, rangeToCompare.location, rangeToCompare.length, compareOptions);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x1F40D83F0](alloc, theString);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x1F40D8410](alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x1F40D8438](alloc, bytes, numBytes, *(void *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8448](alloc, cStr, *(void *)&encoding);
}

CFStringRef CFStringCreateWithCharacters(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars)
{
  return (CFStringRef)MEMORY[0x1F40D8460](alloc, chars, numChars);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1F40D8490](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x1F40D84A8](alloc, str, range.location, range.length);
}

Boolean CFStringFindWithOptions(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x1F40D84E0](theString, stringToFind, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D8510](theString, buffer, bufferSize, *(void *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1F40D8520](theString, *(void *)&encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return MEMORY[0x1F40D8528](theString, idx);
}

void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
{
}

double CFStringGetDoubleValue(CFStringRef str)
{
  MEMORY[0x1F40D8548](str);
  return result;
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x1F40D8578](theString);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1F40D85F0]();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x1F40D8600](theString, prefix);
}

void CFURLClearResourcePropertyCache(CFURLRef url)
{
}

void CFURLClearResourcePropertyCacheForKey(CFURLRef url, CFStringRef key)
{
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return (CFStringRef)MEMORY[0x1F40D8758](anURL, pathStyle);
}

CFStringRef CFURLCopyLastPathComponent(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1F40D8770](url);
}

CFDictionaryRef CFURLCopyResourcePropertiesForKeys(CFURLRef url, CFArrayRef keys, CFErrorRef *error)
{
  return (CFDictionaryRef)MEMORY[0x1F40D87A8](url, keys, error);
}

Boolean CFURLCopyResourcePropertyForKey(CFURLRef url, CFStringRef key, void *propertyValueTypeRefPtr, CFErrorRef *error)
{
  return MEMORY[0x1F40D87B0](url, key, propertyValueTypeRefPtr, error);
}

CFStringRef CFURLCopyScheme(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D87C0](anURL);
}

CFDataRef CFURLCreateBookmarkData(CFAllocatorRef allocator, CFURLRef url, CFURLBookmarkCreationOptions options, CFArrayRef resourcePropertiesToInclude, CFURLRef relativeToURL, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x1F40D87E0](allocator, url, options, resourcePropertiesToInclude, relativeToURL, error);
}

CFDataRef CFURLCreateBookmarkDataFromFile(CFAllocatorRef allocator, CFURLRef fileURL, CFErrorRef *errorRef)
{
  return (CFDataRef)MEMORY[0x1F40D87E8](allocator, fileURL, errorRef);
}

CFURLRef CFURLCreateByResolvingBookmarkData(CFAllocatorRef allocator, CFDataRef bookmark, CFURLBookmarkResolutionOptions options, CFURLRef relativeToURL, CFArrayRef resourcePropertiesToInclude, Boolean *isStale, CFErrorRef *error)
{
  return (CFURLRef)MEMORY[0x1F40D87F0](allocator, bookmark, options, relativeToURL, resourcePropertiesToInclude, isStale, error);
}

CFURLRef CFURLCreateCopyDeletingLastPathComponent(CFAllocatorRef allocator, CFURLRef url)
{
  return (CFURLRef)MEMORY[0x1F40D8808](allocator, url);
}

CFURLRef CFURLCreateFilePathURL(CFAllocatorRef allocator, CFURLRef url, CFErrorRef *error)
{
  return (CFURLRef)MEMORY[0x1F40D8830](allocator, url, error);
}

CFURLRef CFURLCreateFileReferenceURL(CFAllocatorRef allocator, CFURLRef url, CFErrorRef *error)
{
  return (CFURLRef)MEMORY[0x1F40D8838](allocator, url, error);
}

CFURLRef CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D8848](allocator, buffer, bufLen, isDirectory);
}

CFTypeRef CFURLCreateResourcePropertyForKeyFromBookmarkData(CFAllocatorRef allocator, CFStringRef resourcePropertyKey, CFDataRef bookmark)
{
  return (CFTypeRef)MEMORY[0x1F40D8868](allocator, resourcePropertyKey, bookmark);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D88A0](allocator, filePath, pathStyle, isDirectory);
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1F40D88C0](allocator, URLString, baseURL);
}

CFURLEnumeratorRef CFURLEnumeratorCreateForDirectoryURL(CFAllocatorRef alloc, CFURLRef directoryURL, CFURLEnumeratorOptions option, CFArrayRef propertyKeys)
{
  return (CFURLEnumeratorRef)MEMORY[0x1F40D88C8](alloc, directoryURL, option, propertyKeys);
}

CFURLEnumeratorResult CFURLEnumeratorGetNextURL(CFURLEnumeratorRef enumerator, CFURLRef *url, CFErrorRef *error)
{
  return MEMORY[0x1F40D88E0](enumerator, url, error);
}

void CFURLEnumeratorSkipDescendents(CFURLEnumeratorRef enumerator)
{
}

CFURLRef CFURLGetBaseURL(CFURLRef anURL)
{
  return (CFURLRef)MEMORY[0x1F40D88F0](anURL);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1F40D8908](url, resolveAgainstBase, buffer, maxBufLen);
}

CFTypeID CFURLGetTypeID(void)
{
  return MEMORY[0x1F40D8928]();
}

Boolean CFURLIsFileReferenceURL(CFURLRef url)
{
  return MEMORY[0x1F40D8940](url);
}

Boolean CFURLSetResourcePropertiesForKeys(CFURLRef url, CFDictionaryRef keyedPropertyValues, CFErrorRef *error)
{
  return MEMORY[0x1F40D8950](url, keyedPropertyValues, error);
}

Boolean CFURLSetResourcePropertyForKey(CFURLRef url, CFStringRef key, CFTypeRef propertyValue, CFErrorRef *error)
{
  return MEMORY[0x1F40D8958](url, key, propertyValue, error);
}

Boolean CFURLWriteBookmarkDataToFile(CFDataRef bookmarkRef, CFURLRef fileURL, CFURLBookmarkFileCreationOptions options, CFErrorRef *errorRef)
{
  return MEMORY[0x1F40D8978](bookmarkRef, fileURL, options, errorRef);
}

CFUserNotificationRef CFUserNotificationCreate(CFAllocatorRef allocator, CFTimeInterval timeout, CFOptionFlags flags, SInt32 *error, CFDictionaryRef dictionary)
{
  return (CFUserNotificationRef)MEMORY[0x1F40D8A28](allocator, flags, error, dictionary, timeout);
}

SInt32 CFUserNotificationReceiveResponse(CFUserNotificationRef userNotification, CFTimeInterval timeout, CFOptionFlags *responseFlags)
{
  return MEMORY[0x1F40D8A68](userNotification, responseFlags, timeout);
}

uint64_t CacheDeleteCopyPurgeableSpaceWithInfo()
{
  return MEMORY[0x1F410DCB0]();
}

uint64_t CacheDeletePurgeSpaceWithInfo()
{
  return MEMORY[0x1F410DCD8]();
}

uint64_t FPFileMetadataCopyLastUsedDateAtURL()
{
  return MEMORY[0x1F40E0AD8]();
}

uint64_t FPResolveSymlink()
{
  return MEMORY[0x1F40E0BD8]();
}

uint64_t FPURLMightBeInFileProvider()
{
  return MEMORY[0x1F40E0C08]();
}

FSEventStreamRef FSEventStreamCreate(CFAllocatorRef allocator, FSEventStreamCallback callback, FSEventStreamContext *context, CFArrayRef pathsToWatch, FSEventStreamEventId sinceWhen, CFTimeInterval latency, FSEventStreamCreateFlags flags)
{
  return (FSEventStreamRef)MEMORY[0x1F40DEDC0](allocator, callback, context, pathsToWatch, sinceWhen, *(void *)&flags, latency);
}

void FSEventStreamInvalidate(FSEventStreamRef streamRef)
{
}

void FSEventStreamRelease(FSEventStreamRef streamRef)
{
}

void FSEventStreamSetDispatchQueue(FSEventStreamRef streamRef, dispatch_queue_t q)
{
}

Boolean FSEventStreamSetExclusionPaths(FSEventStreamRef streamRef, CFArrayRef pathsToExclude)
{
  return MEMORY[0x1F40DEDF0](streamRef, pathsToExclude);
}

Boolean FSEventStreamStart(FSEventStreamRef streamRef)
{
  return MEMORY[0x1F40DEDF8](streamRef);
}

void FSEventStreamStop(FSEventStreamRef streamRef)
{
}

Class NSClassFromString(NSString *aClassName)
{
  return (Class)MEMORY[0x1F40E7010](aClassName);
}

NSString *NSHomeDirectory(void)
{
  return (NSString *)MEMORY[0x1F40E7110]();
}

void NSLog(NSString *format, ...)
{
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return (NSString *)MEMORY[0x1F40E7280](aClass);
}

NSString *__cdecl NSStringFromSelector(SEL aSelector)
{
  return (NSString *)MEMORY[0x1F40E72B0](aSelector);
}

SCDynamicStoreRef SCDynamicStoreCreate(CFAllocatorRef allocator, CFStringRef name, SCDynamicStoreCallBack callout, SCDynamicStoreContext *context)
{
  return (SCDynamicStoreRef)MEMORY[0x1F4101DB0](allocator, name, callout, context);
}

CFStringRef SCDynamicStoreKeyCreateComputerName(CFAllocatorRef allocator)
{
  return (CFStringRef)MEMORY[0x1F4101DC8](allocator);
}

Boolean SCDynamicStoreSetDispatchQueue(SCDynamicStoreRef store, dispatch_queue_t queue)
{
  return MEMORY[0x1F4101E08](store, queue);
}

Boolean SCDynamicStoreSetNotificationKeys(SCDynamicStoreRef store, CFArrayRef keys, CFArrayRef patterns)
{
  return MEMORY[0x1F4101E18](store, keys, patterns);
}

uint64_t SFBrowserCloseNode()
{
  return MEMORY[0x1F4150228]();
}

uint64_t SFBrowserCopyChildren()
{
  return MEMORY[0x1F4150230]();
}

uint64_t SFBrowserCopyNodeForURL()
{
  return MEMORY[0x1F4150238]();
}

uint64_t SFBrowserCreate()
{
  return MEMORY[0x1F4150240]();
}

uint64_t SFBrowserGetRootNode()
{
  return MEMORY[0x1F4150248]();
}

uint64_t SFBrowserInvalidate()
{
  return MEMORY[0x1F4150250]();
}

uint64_t SFBrowserOpenNode()
{
  return MEMORY[0x1F4150258]();
}

uint64_t SFBrowserSetClient()
{
  return MEMORY[0x1F4150260]();
}

uint64_t SFBrowserSetDispatchQueue()
{
  return MEMORY[0x1F4150268]();
}

uint64_t SFNodeCopyDisplayName()
{
  return MEMORY[0x1F41502A8]();
}

uint64_t SFNodeCopyKindString()
{
  return MEMORY[0x1F41502B0]();
}

uint64_t SFNodeCopyKinds()
{
  return MEMORY[0x1F41502B8]();
}

uint64_t SFNodeCopySecondaryName()
{
  return MEMORY[0x1F41502C0]();
}

uint64_t SFNodeCopyTypeIdentifier()
{
  return MEMORY[0x1F41502C8]();
}

uint64_t SFNodeCopyUserName()
{
  return MEMORY[0x1F41502D0]();
}

uint64_t SFNodeGetConnectionState()
{
  return MEMORY[0x1F41502D8]();
}

uint64_t SFNodeGetPriority()
{
  return MEMORY[0x1F41502E0]();
}

uint64_t SFNodeIsContainer()
{
  return MEMORY[0x1F41502E8]();
}

uint64_t SFNodeIsMounted()
{
  return MEMORY[0x1F41502F0]();
}

uint64_t SFNodeIsNeighborhood()
{
  return MEMORY[0x1F41502F8]();
}

uint64_t SFNodeIsServer()
{
  return MEMORY[0x1F4150300]();
}

uint64_t SFNodeIsSharePoint()
{
  return MEMORY[0x1F4150308]();
}

uint64_t SFNodeSupportsFileSharing()
{
  return MEMORY[0x1F4150310]();
}

uint64_t SFNodeSupportsScreenSharing()
{
  return MEMORY[0x1F4150318]();
}

CFTypeRef SecTaskCopyValueForEntitlement(SecTaskRef task, CFStringRef entitlement, CFErrorRef *error)
{
  return (CFTypeRef)MEMORY[0x1F40F7138](task, entitlement, error);
}

SecTaskRef SecTaskCreateFromSelf(CFAllocatorRef allocator)
{
  return (SecTaskRef)MEMORY[0x1F40F7160](allocator);
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

uint64_t _CFBundleCreateUnique()
{
  return MEMORY[0x1F40D8C30]();
}

uint64_t _CFURLCacheSetAutoFlushingEnabled()
{
  return MEMORY[0x1F40D9200]();
}

uint64_t _CFURLCopyFileURL()
{
  return MEMORY[0x1F40D9240]();
}

uint64_t _CFURLCopyLogicalURLOfPromiseAtURL()
{
  return MEMORY[0x1F40D9260]();
}

uint64_t _CFURLCopyPromiseURLOfLogicalURL()
{
  return MEMORY[0x1F40D9278]();
}

uint64_t _CFURLCopyResourcePropertyForKeyFromCache()
{
  return MEMORY[0x1F40D92A0]();
}

uint64_t _CFURLCopyResourcePropertyValuesAndFlags()
{
  return MEMORY[0x1F40D92A8]();
}

uint64_t _CFURLGetResourcePropertyFlags()
{
  return MEMORY[0x1F40D9338]();
}

uint64_t _CFURLGetVolumePropertyFlags()
{
  return MEMORY[0x1F40D9340]();
}

uint64_t _CFURLIsFileURL()
{
  return MEMORY[0x1F40D9348]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

std::string::size_type std::string::find(const std::string *this, const std::string::value_type *__s, std::string::size_type __pos, std::string::size_type __n)
{
  return MEMORY[0x1F417E378](this, __s, __pos, __n);
}

std::string::size_type std::string::find(const std::string *this, std::string::value_type __c, std::string::size_type __pos)
{
  return MEMORY[0x1F417E380](this, __c, __pos);
}

std::string *__cdecl std::locale::name(std::string *__return_ptr retstr, const std::locale *this)
{
  return (std::string *)MEMORY[0x1F417E400](retstr, this);
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x1F417E408](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x1F417E418](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x1F417E448](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x1F417E530](this);
}

std::regex_error *__cdecl std::regex_error::regex_error(std::regex_error *this, std::regex_constants::error_type __ecode)
{
  return (std::regex_error *)MEMORY[0x1F417E550](this, *(void *)&__ecode);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x1F417E588](__n);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1F417E5C0](this, __s, __n);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1F417E608](this, __pos, __s, __n);
}

std::string *__cdecl std::string::replace(std::string *this, std::string::size_type __pos, std::string::size_type __n1, const std::string::value_type *__s, std::string::size_type __n2)
{
  return (std::string *)MEMORY[0x1F417E628](this, __pos, __n1, __s, __n2);
}

void std::string::reserve(std::string *this, std::string::size_type __requested_capacity)
{
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
}

std::string *__cdecl std::string::basic_string(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n, std::allocator<char> *__a)
{
  return (std::string *)MEMORY[0x1F417E660](this, __str, __pos, __n, __a);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x1F417E670](this, __str);
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x1F417E848]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x1F417E850]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1F417E8A0]();
}

{
  return MEMORY[0x1F417E8A8]();
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x1F417E940]();
}

std::regex_traits<char>::char_class_type std::__get_classname(const char *__s, BOOL __icase)
{
  return MEMORY[0x1F417E960](__s, __icase);
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x1F417E978]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x1F417E980]();
}

void std::condition_variable::notify_all(std::condition_variable *this)
{
}

void std::condition_variable::__do_timed_wait(std::condition_variable *this, std::unique_lock<std::mutex> *__lk, std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> a3)
{
}

void std::condition_variable::wait(std::condition_variable *this, std::unique_lock<std::mutex> *__lk)
{
}

void std::condition_variable::~condition_variable(std::condition_variable *this)
{
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
}

std::__shared_weak_count *__cdecl std::__shared_weak_count::lock(std::__shared_weak_count *this)
{
  return (std::__shared_weak_count *)MEMORY[0x1F417EA90](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
}

std::string *__cdecl std::__get_collation_name(std::string *__return_ptr retstr, const char *__s)
{
  return (std::string *)MEMORY[0x1F417EAA8](retstr, __s);
}

void std::__throw_system_error(int __ev, const char *__what_arg)
{
}

void std::mutex::lock(std::mutex *this)
{
}

void std::mutex::unlock(std::mutex *this)
{
}

void std::mutex::~mutex(std::mutex *this)
{
}

unint64_t std::stoul(const std::string *__str, size_t *__idx, int __base)
{
  return MEMORY[0x1F417EC20](__str, __idx, *(void *)&__base);
}

std::chrono::steady_clock::time_point std::chrono::steady_clock::now(void)
{
  return (std::chrono::steady_clock::time_point)MEMORY[0x1F417EC90]();
}

std::chrono::system_clock::time_point std::chrono::system_clock::now(void)
{
  return (std::chrono::system_clock::time_point)MEMORY[0x1F417ECA0]();
}

std::locale *__cdecl std::locale::locale(std::locale *this, const std::locale *a2)
{
  return (std::locale *)MEMORY[0x1F417ECE0](this, a2);
}

std::locale *__cdecl std::locale::locale(std::locale *this)
{
  return (std::locale *)MEMORY[0x1F417ECE8](this);
}

void std::locale::~locale(std::locale *this)
{
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x1F417EE40]();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, double __val)
{
  return (std::string *)MEMORY[0x1F417EE58](retstr, __val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, int __val)
{
  return (std::string *)MEMORY[0x1F417EE70](retstr, *(void *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unsigned int __val)
{
  return (std::string *)MEMORY[0x1F417EE78](retstr, *(void *)&__val);
}

uint64_t std::operator+<char>()
{
  return MEMORY[0x1F417EEA0]();
}

void std::exception::~exception(std::exception *this)
{
}

void std::terminate(void)
{
}

void operator delete[]()
{
  while (1)
    ;
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void operator new[]()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

uint64_t __CFStringIsMutable()
{
  return MEMORY[0x1F40D95F8]();
}

uint64_t __carbon_delete()
{
  return MEMORY[0x1F40C9B50]();
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1F417EF30](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1F417EF48](a1);
}

void __cxa_end_catch(void)
{
}

void __cxa_free_exception(void *a1)
{
}

void __cxa_guard_abort(__guard *a1)
{
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x1F417EF80](a1);
}

void __cxa_guard_release(__guard *a1)
{
}

void __cxa_rethrow(void)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

int *__error(void)
{
  return (int *)MEMORY[0x1F40C9B88]();
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x1F40C9C28]();
}

uint64_t __strlcpy_chk()
{
  return MEMORY[0x1F40C9CD8]();
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1F40C9CF8](*(void *)&a1);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_signpost_emit_with_name_impl(void *dso, os_log_t log, os_signpost_type_t type, os_signpost_id_t spid, const char *name, const char *format, uint8_t *buf, uint32_t size)
{
}

void abort(void)
{
}

int acl_free(void *obj_p)
{
  return MEMORY[0x1F40CA270](obj_p);
}

char *__cdecl acl_to_text(acl_t acl, ssize_t *len_p)
{
  return (char *)MEMORY[0x1F40CA328](acl, len_p);
}

void bzero(void *a1, size_t a2)
{
}

Ivar class_getInstanceVariable(Class cls, const char *name)
{
  return (Ivar)MEMORY[0x1F4181538](cls, name);
}

int close(int a1)
{
  return MEMORY[0x1F40CB3F8](*(void *)&a1);
}

int closedir(DIR *a1)
{
  return MEMORY[0x1F40CB400](a1);
}

uint64_t container_error_copy_unlocalized_description()
{
  return MEMORY[0x1F40CB5D0]();
}

uint64_t container_get_identifier()
{
  return MEMORY[0x1F40CB640]();
}

uint64_t container_get_path()
{
  return MEMORY[0x1F40CB650]();
}

uint64_t container_query_count_results()
{
  return MEMORY[0x1F40CB718]();
}

uint64_t container_query_create()
{
  return MEMORY[0x1F40CB720]();
}

uint64_t container_query_free()
{
  return MEMORY[0x1F40CB730]();
}

uint64_t container_query_get_last_error()
{
  return MEMORY[0x1F40CB738]();
}

uint64_t container_query_iterate_results_sync()
{
  return MEMORY[0x1F40CB748]();
}

uint64_t container_query_operation_set_flags()
{
  return MEMORY[0x1F40CB750]();
}

uint64_t container_query_set_class()
{
  return MEMORY[0x1F40CB760]();
}

uint64_t container_query_set_include_other_owners()
{
  return MEMORY[0x1F40CB778]();
}

uint64_t container_query_set_persona_unique_string()
{
  return MEMORY[0x1F40CB780]();
}

int copyfile(const char *from, const char *to, copyfile_state_t state, copyfile_flags_t flags)
{
  return MEMORY[0x1F40CB880](from, to, state, *(void *)&flags);
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x1F40CBA60](identifier, flags);
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x1F40CBA88]();
}

void dispatch_group_enter(dispatch_group_t group)
{
}

void dispatch_group_leave(dispatch_group_t group)
{
}

void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x1F40CBAC0](group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x1F40CBBA8](attr, frequency);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1F40CBBC0](label, attr);
}

dispatch_queue_t dispatch_queue_create_with_target_V2(const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return (dispatch_queue_t)MEMORY[0x1F40CBBD0](label, attr, target);
}

void dispatch_resume(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1F40CBC30](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1F40CBC40](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1F40CBC50](dsema, timeout);
}

void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue)
{
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1F40CBC98](type, handle, mask, queue);
}

void dispatch_source_merge_data(dispatch_source_t source, uintptr_t value)
{
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1F40CBD30](when, delta);
}

int dladdr(const void *a1, Dl_info *a2)
{
  return MEMORY[0x1F40CBDA0](a1, a2);
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1F40CBDB8](__path, *(void *)&__mode);
}

int fclose(FILE *a1)
{
  return MEMORY[0x1F40CC050](a1);
}

char *__cdecl fgets(char *a1, int a2, FILE *a3)
{
  return (char *)MEMORY[0x1F40CC100](a1, *(void *)&a2, a3);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1F40CC1C0](__filename, __mode);
}

void free(void *a1)
{
}

int fsctl(const char *a1, unint64_t a2, void *a3, unsigned int a4)
{
  return MEMORY[0x1F40CC288](a1, a2, a3, *(void *)&a4);
}

int getattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return MEMORY[0x1F40CC360](a1, a2, a3, a4, *(void *)&a5);
}

uid_t geteuid(void)
{
  return MEMORY[0x1F40CC3B8]();
}

gid_t getgid(void)
{
  return MEMORY[0x1F40CC3D0]();
}

uid_t getuid(void)
{
  return MEMORY[0x1F40CC570]();
}

ssize_t getxattr(const char *path, const char *name, void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x1F40CC590](path, name, value, size, *(void *)&position, *(void *)&options);
}

ptrdiff_t ivar_getOffset(Ivar v)
{
  return MEMORY[0x1F41815C0](v);
}

int kevent(int kq, const kevent *changelist, int nchanges, kevent *eventlist, int nevents, const timespec *timeout)
{
  return MEMORY[0x1F40CC718](*(void *)&kq, changelist, *(void *)&nchanges, eventlist, *(void *)&nevents, timeout);
}

int kqueue(void)
{
  return MEMORY[0x1F40CC748]();
}

ssize_t listxattr(const char *path, char *namebuff, size_t size, int options)
{
  return MEMORY[0x1F40CC848](path, namebuff, size, *(void *)&options);
}

float log2f(float a1)
{
  MEMORY[0x1F40CC8B0](a1);
  return result;
}

int lstat(const char *a1, stat *a2)
{
  return MEMORY[0x1F40CC900](a1, a2);
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x1F40CC910]();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x1F40CCA60](info);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCD8](__s, *(void *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1F40CCCE8](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCF0](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD10](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD20](__b, *(void *)&__c, __len);
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x1F40CD028](*(void *)&token);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x1F40CD060](name, out_token, queue, handler);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1F4181638](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1F4181648]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1F4181660](a1);
}

{
  MEMORY[0x1F4181668](context);
}

{
  return (void *)MEMORY[0x1F4181670]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1F4181678](a1);
}

id objc_begin_catch(void *exc_buf)
{
  return (id)MEMORY[0x1F4181680](exc_buf);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x1F4181688]();
}

void objc_copyWeak(id *to, id *from)
{
}

void objc_destroyWeak(id *location)
{
}

void objc_end_catch(void)
{
}

void objc_enumerationMutation(id obj)
{
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1F4181728](name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x1F4181748](self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x1F4181758](location, val);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x1F4181780](location);
}

void objc_moveWeak(id *to, id *from)
{
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1F41817A8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1F41817B0]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1F41817B8]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x1F41817C0]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x1F41817C8]();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1F41818B0](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x1F41818B8](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1F41818C0](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1F41818C8](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x1F41818D0](a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x1F4181A18](location, obj);
}

int objc_sync_enter(id obj)
{
  return MEMORY[0x1F4181A28](obj);
}

int objc_sync_exit(id obj)
{
  return MEMORY[0x1F4181A30](obj);
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1F4181A40](a1);
}

const char *__cdecl object_getClassName(id a1)
{
  return (const char *)MEMORY[0x1F4181A60](a1);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1F40CD0E0](a1, *(void *)&a2);
}

DIR *__cdecl opendir(const char *a1)
{
  return (DIR *)MEMORY[0x1F40CD120](a1);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1F40CD360](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1F40CD3B8](oslog, type);
}

BOOL os_signpost_enabled(os_log_t log)
{
  return MEMORY[0x1F40CD550](log);
}

os_signpost_id_t os_signpost_id_generate(os_log_t log)
{
  return MEMORY[0x1F40CD558](log);
}

os_signpost_id_t os_signpost_id_make_with_pointer(os_log_t log, const void *ptr)
{
  return MEMORY[0x1F40CD560](log, ptr);
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

uint64_t os_variant_has_internal_ui()
{
  return MEMORY[0x1F40CD658]();
}

int printf(const char *a1, ...)
{
  return MEMORY[0x1F40CD838](a1);
}

int pthread_main_np(void)
{
  return MEMORY[0x1F40CDA68]();
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA78](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x1F40CDA80](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA88](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x1F40CDA98](a1);
}

int pthread_mutexattr_destroy(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1F40CDAA0](a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1F40CDAA8](a1);
}

int pthread_mutexattr_settype(pthread_mutexattr_t *a1, int a2)
{
  return MEMORY[0x1F40CDAC0](a1, *(void *)&a2);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x1F40CDB30]();
}

dirent *__cdecl readdir(DIR *a1)
{
  return (dirent *)MEMORY[0x1F40CDC60](a1);
}

ssize_t readlink(const char *a1, char *a2, size_t a3)
{
  return MEMORY[0x1F40CDC70](a1, a2, a3);
}

char *__cdecl realpath_DARWIN_EXTSN(const char *a1, char *a2)
{
  return (char *)MEMORY[0x1F40CDC98](a1, a2);
}

int removexattr(const char *path, const char *name, int options)
{
  return MEMORY[0x1F40CDD48](path, name, *(void *)&options);
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
}

int rmdir(const char *a1)
{
  return MEMORY[0x1F40CDD90](a1);
}

int setxattr(const char *path, const char *name, const void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x1F40CDFD8](path, name, value, size, *(void *)&position, *(void *)&options);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1F40CE080](__str, __size, __format);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1F40CE110](a1, a2);
}

int statfs(const char *a1, statfs *a2)
{
  return MEMORY[0x1F40CE118](a1, a2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1F40CE150](__s, *(void *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1F40CE158](__s1, __s2);
}

size_t strcspn(const char *__s, const char *__charset)
{
  return MEMORY[0x1F40CE170](__s, __charset);
}

size_t strlcat(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1F40CE1A8](__dst, __source, __size);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1F40CE1B0](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1F40CE1C8](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1F40CE1F0](__s1, __s2, __n);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1F40CE230](__s, *(void *)&__c);
}

size_t strspn(const char *__s, const char *__charset)
{
  return MEMORY[0x1F40CE250](__s, __charset);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x1F40CE258](__s1, __s2);
}

int unlink(const char *a1)
{
  return MEMORY[0x1F40CE5E0](a1);
}

int unlinkat(int a1, const char *a2, int a3)
{
  return MEMORY[0x1F40CE5E8](*(void *)&a1, a2, *(void *)&a3);
}

int usleep(useconds_t a1)
{
  return MEMORY[0x1F40CE608](*(void *)&a1);
}

void uuid_clear(uuid_t uu)
{
}

char *__cdecl xattr_name_with_flags(const char *a1, xattr_flags_t a2)
{
  return (char *)MEMORY[0x1F40CE950](a1, a2);
}

char *__cdecl xattr_name_without_flags(const char *a1)
{
  return (char *)MEMORY[0x1F40CE958](a1);
}

int xattr_preserve_for_intent(const char *a1, xattr_operation_intent_t a2)
{
  return MEMORY[0x1F40CE960](a1, *(void *)&a2);
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return (xpc_connection_t)MEMORY[0x1F40CEBD0](name, targetq, flags);
}

void xpc_connection_resume(xpc_connection_t connection)
{
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
}

xpc_object_t xpc_connection_send_message_with_reply_sync(xpc_connection_t connection, xpc_object_t message)
{
  return (xpc_object_t)MEMORY[0x1F40CEC68](connection, message);
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x1F40CEE20](keys, values, count);
}

BOOL xpc_dictionary_get_BOOL(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1F40CEE80](xdict, key);
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1F40CEEC8](xdict, key);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return (const char *)MEMORY[0x1F40CEEF0](xdict, key);
}

uint64_t xpc_dictionary_get_uint64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1F40CEEF8](xdict, key);
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
}

void xpc_dictionary_set_data(xpc_object_t xdict, const char *key, const void *bytes, size_t length)
{
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
}

void xpc_dictionary_set_uint64(xpc_object_t xdict, const char *key, uint64_t value)
{
}

void xpc_dictionary_set_uuid(xpc_object_t xdict, const char *key, const unsigned __int8 *uuid)
{
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x1F40CF148](object);
}