uint64_t sub_23C400EBC@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  return static WFContentItem.toolkitTypeIdentifier(context:)(a1, a2);
}

uint64_t sub_23C400ED4(uint64_t a1, uint64_t a2)
{
  static WFContentItem.toolkitTypeDefinition(context:)(a2, a1);
  v3 = *(uint64_t (**)(void))(v2 + 8);
  return sub_23C401D44(v3);
}

uint64_t sub_23C400F74(uint64_t a1, uint64_t a2)
{
  return static WFContentItem.toolkitPredicateTemplates(usage:seen:)(a1, a2);
}

uint64_t sub_23C400F8C()
{
  __swift_instantiateConcreteTypeFromMangledName(&qword_268BA7510);
  uint64_t v0 = swift_allocObject();
  *(_OWORD *)(v0 + 16) = xmmword_23C6F6A90;
  ObjCClassFromMetadata = (void *)swift_getObjCClassFromMetadata();
  uint64_t result = sub_23C4014D8(objc_msgSend(ObjCClassFromMetadata, sel_codableDescription), (SEL *)&selRef_mainBundleIdentifier);
  if (v3)
  {
    *(void *)(v0 + 32) = result;
    *(void *)(v0 + 40) = v3;
    uint64_t result = sub_23C4014D8(objc_msgSend(ObjCClassFromMetadata, sel_codableDescription), (SEL *)&selRef_typeName);
    if (v4)
    {
      *(void *)(v0 + 48) = result;
      *(void *)(v0 + 56) = v4;
      __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F00);
      sub_23C374BD0((unint64_t *)&unk_268BA76A0, (uint64_t *)&unk_268BA6F00);
      uint64_t v5 = sub_23C6D5468();
      swift_bridgeObjectRelease();
      return v5;
    }
  }
  else
  {
    __break(1u);
  }
  __break(1u);
  return result;
}

void sub_23C4010B0(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  id v3 = objc_msgSend(self, sel_toolKitRegistry);
  id v4 = objc_msgSend(v3, sel_actions);

  sub_23C369F80(0, &qword_268BA7750);
  sub_23C3F1340(&qword_268BA7758, &qword_268BA7750);
  uint64_t v5 = sub_23C6D5798();

  if ((v5 & 0xC000000000000001) != 0)
  {
    sub_23C6D5B28();
    sub_23C6D57A8();
    uint64_t v5 = v40;
    uint64_t v39 = v41;
    uint64_t v6 = v42;
    int64_t v7 = v43;
    unint64_t v8 = v44;
  }
  else
  {
    int64_t v7 = 0;
    uint64_t v9 = -1 << *(unsigned char *)(v5 + 32);
    uint64_t v39 = v5 + 56;
    uint64_t v10 = ~v9;
    uint64_t v11 = -v9;
    if (v11 < 64) {
      uint64_t v12 = ~(-1 << v11);
    }
    else {
      uint64_t v12 = -1;
    }
    unint64_t v8 = v12 & *(void *)(v5 + 56);
    uint64_t v6 = v10;
  }
  int64_t v38 = (unint64_t)(v6 + 64) >> 6;
  unint64_t v13 = 0x263F86000uLL;
  if (v5 < 0) {
    goto LABEL_10;
  }
LABEL_8:
  if (v8)
  {
    uint64_t v14 = (v8 - 1) & v8;
    unint64_t v15 = __clz(__rbit64(v8)) | (v7 << 6);
    int64_t v16 = v7;
    goto LABEL_27;
  }
  int64_t v18 = v7 + 1;
  if (__OFADD__(v7, 1))
  {
    __break(1u);
LABEL_46:
    __break(1u);
    return;
  }
  if (v18 >= v38) {
    goto LABEL_37;
  }
  unint64_t v19 = *(void *)(v39 + 8 * v18);
  int64_t v16 = v7 + 1;
  if (!v19)
  {
    int64_t v16 = v7 + 2;
    if (v7 + 2 >= v38) {
      goto LABEL_37;
    }
    unint64_t v19 = *(void *)(v39 + 8 * v16);
    if (!v19)
    {
      int64_t v16 = v7 + 3;
      if (v7 + 3 >= v38) {
        goto LABEL_37;
      }
      unint64_t v19 = *(void *)(v39 + 8 * v16);
      if (!v19)
      {
        int64_t v16 = v7 + 4;
        if (v7 + 4 < v38)
        {
          unint64_t v19 = *(void *)(v39 + 8 * v16);
          if (!v19)
          {
            int64_t v20 = v7 + 5;
            do
            {
              if (v20 >= v38) {
                goto LABEL_37;
              }
              unint64_t v19 = *(void *)(v39 + 8 * v20++);
            }
            while (!v19);
            int64_t v16 = v20 - 1;
          }
          goto LABEL_26;
        }
LABEL_37:
        sub_23C3C743C();
        id v24 = 0;
        v22 = 0;
        goto LABEL_38;
      }
    }
  }
LABEL_26:
  uint64_t v14 = (v19 - 1) & v19;
  unint64_t v15 = __clz(__rbit64(v19)) + (v16 << 6);
LABEL_27:
  id v17 = *(id *)(*(void *)(v5 + 48) + 8 * v15);
  if (!v17) {
    goto LABEL_37;
  }
  while (1)
  {
    self;
    uint64_t v21 = swift_dynamicCastObjCClass();
    if (v21) {
      break;
    }
LABEL_34:

    int64_t v7 = v16;
    unint64_t v8 = v14;
    if ((v5 & 0x8000000000000000) == 0) {
      goto LABEL_8;
    }
LABEL_10:
    if (sub_23C6D5B38())
    {
      swift_unknownObjectRetain();
      swift_dynamicCast();
      id v17 = v45;
      swift_unknownObjectRelease();
      int64_t v16 = v7;
      uint64_t v14 = v8;
      if (v45) {
        continue;
      }
    }
    goto LABEL_37;
  }
  v22 = (void *)v21;
  unint64_t v23 = v13;
  id v24 = v17;
  uint64_t v25 = sub_23C6D5A18();

  uint64_t v26 = *(void *)(v25 + 16);
  if (!v26)
  {
LABEL_33:
    swift_bridgeObjectRelease();

    unint64_t v13 = v23;
    goto LABEL_34;
  }
  uint64_t v27 = 0;
  while (*(void *)(v25 + 8 * v27 + 32) != a1)
  {
    if (v26 == ++v27) {
      goto LABEL_33;
    }
  }
  swift_bridgeObjectRelease();

  sub_23C3C743C();
LABEL_38:
  id v28 = objc_msgSend((id)swift_getObjCClassFromMetadata(), sel_codableDescription);
  uint64_t v29 = sub_23C4014D8(v28, (SEL *)&selRef_mainBundleIdentifier);
  if (!v30) {
    goto LABEL_46;
  }
  uint64_t v31 = v29;
  uint64_t v32 = v30;
  if (v22 && (id v33 = objc_msgSend(v22, sel_displayableAppDescriptor)) != 0)
  {
    uint64_t v34 = sub_23C3F10D4(v33);
    uint64_t v36 = v35;

    if (v36)
    {
      swift_bridgeObjectRelease();
      uint64_t v31 = v34;
      uint64_t v32 = v36;
    }
  }
  else
  {
  }
  *a2 = v31;
  a2[1] = v32;
}

uint64_t sub_23C4014D8(void *a1, SEL *a2)
{
  id v3 = [a1 *a2];

  if (!v3) {
    return 0;
  }
  uint64_t v4 = sub_23C6D5568();

  return v4;
}

unint64_t sub_23C401544()
{
  unint64_t result = qword_268BA76B0;
  if (!qword_268BA76B0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_268BA76B0);
  }
  return result;
}

uint64_t type metadata accessor for ContentItemTypeDefinitionCache(uint64_t a1)
{
  return sub_23C4015E4(a1, (uint64_t *)&unk_268BA76D8);
}

uint64_t sub_23C4015B0()
{
  return sub_23C401624();
}

uint64_t sub_23C4015BC()
{
  return type metadata accessor for ContentItemTypeDefinitionCache(0);
}

uint64_t type metadata accessor for IntentCustomObjectAttributionCache(uint64_t a1)
{
  return sub_23C4015E4(a1, qword_268BA76F8);
}

uint64_t sub_23C4015E4(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *a2;
  if (!*a2) {
    return swift_getSingletonMetadata();
  }
  return result;
}

uint64_t sub_23C401618()
{
  return sub_23C401624();
}

uint64_t sub_23C401624()
{
  return swift_initClassMetadata2();
}

uint64_t sub_23C401660()
{
  return type metadata accessor for IntentCustomObjectAttributionCache(0);
}

unsigned char *_s22ToolKitConversionErrorOwst_0(unsigned char *result, int a2, int a3)
{
  if ((a3 + 1) >= 0x10000) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 1) < 0x100) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2)
  {
    switch(v5)
    {
      case 1:
        *uint64_t result = a2;
        return result;
      case 2:
        *(_WORD *)uint64_t result = a2;
        return result;
      case 3:
        goto LABEL_19;
      case 4:
        *(_DWORD *)uint64_t result = a2;
        return result;
      default:
        return result;
    }
  }
  switch(v5)
  {
    case 1:
      *uint64_t result = 0;
      break;
    case 2:
      *(_WORD *)uint64_t result = 0;
      break;
    case 3:
LABEL_19:
      __break(1u);
      JUMPOUT(0x23C401704);
    case 4:
      *(_DWORD *)uint64_t result = 0;
      break;
    default:
      return result;
  }
  return result;
}

ValueMetadata *_s22ToolKitConversionErrorOMa_0()
{
  return &_s22ToolKitConversionErrorON_0;
}

uint64_t *sub_23C40173C(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  int v5 = *(_DWORD *)(*(void *)(a3 - 8) + 80);
  if ((v5 & 0x20000) != 0)
  {
    uint64_t v11 = *a2;
    *a1 = *a2;
    a1 = (uint64_t *)(v11 + ((v5 + 16) & ~(unint64_t)v5));
    sub_23C6D41B8();
  }
  else
  {
    uint64_t v7 = sub_23C6D4F88();
    (*(void (**)(uint64_t *, uint64_t *, uint64_t))(*(void *)(v7 - 8) + 16))(a1, a2, v7);
    uint64_t v8 = *(int *)(a3 + 20);
    uint64_t v9 = *(void **)((char *)a2 + v8);
    *(uint64_t *)((char *)a1 + v8) = (uint64_t)v9;
    id v10 = v9;
  }
  return a1;
}

void sub_23C40180C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_23C6D4F88();
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v4 - 8) + 8))(a1, v4);
  int v5 = *(void **)(a1 + *(int *)(a2 + 20));
}

uint64_t sub_23C401880(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_23C6D4F88();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 16))(a1, a2, v6);
  uint64_t v7 = *(int *)(a3 + 20);
  uint64_t v8 = *(void **)(a2 + v7);
  *(void *)(a1 + v7) = v8;
  id v9 = v8;
  return a1;
}

uint64_t sub_23C401900(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_23C6D4F88();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 24))(a1, a2, v6);
  uint64_t v7 = *(int *)(a3 + 20);
  uint64_t v8 = *(void **)(a1 + v7);
  id v9 = *(void **)(a2 + v7);
  *(void *)(a1 + v7) = v9;
  id v10 = v9;

  return a1;
}

uint64_t sub_23C401988(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_23C6D4F88();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 32))(a1, a2, v6);
  *(void *)(a1 + *(int *)(a3 + 20)) = *(void *)(a2 + *(int *)(a3 + 20));
  return a1;
}

uint64_t sub_23C401A04(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_23C6D4F88();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 40))(a1, a2, v6);
  uint64_t v7 = *(int *)(a3 + 20);
  uint64_t v8 = *(void **)(a1 + v7);
  *(void *)(a1 + v7) = *(void *)(a2 + v7);

  return a1;
}

uint64_t sub_23C401A88(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x270FA0340](a1, a2, a3, sub_23C401A9C);
}

uint64_t sub_23C401A9C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_23C6D4F88();
  OUTLINED_FUNCTION_2_13();
  if (*(_DWORD *)(v7 + 84) == a2)
  {
    return __swift_getEnumTagSinglePayload(a1, a2, v6);
  }
  else
  {
    unint64_t v9 = *(void *)(a1 + *(int *)(a3 + 20));
    if (v9 >= 0xFFFFFFFF) {
      LODWORD(v9) = -1;
    }
    int v10 = v9 - 1;
    if (v10 < 0) {
      int v10 = -1;
    }
    return (v10 + 1);
  }
}

uint64_t sub_23C401B34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x270FA0580](a1, a2, a3, a4, sub_23C401B48);
}

void sub_23C401B48(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  sub_23C6D4F88();
  OUTLINED_FUNCTION_2_13();
  if (*(_DWORD *)(v9 + 84) == a3)
  {
    __swift_storeEnumTagSinglePayload(a1, a2, a2, v8);
  }
  else
  {
    *(void *)(a1 + *(int *)(a4 + 20)) = a2;
  }
}

uint64_t sub_23C401BD0()
{
  uint64_t result = sub_23C6D4F88();
  if (v1 <= 0x3F)
  {
    swift_initStructMetadata();
    return 0;
  }
  return result;
}

uint64_t sub_23C401C64()
{
  return sub_23C401CAC(&qword_268BA7728, (void (*)(uint64_t))_s8CacheKeyVMa);
}

uint64_t sub_23C401CAC(unint64_t *a1, void (*a2)(uint64_t))
{
  uint64_t result = *a1;
  if (!result)
  {
    a2(255);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

unint64_t sub_23C401CF8()
{
  unint64_t result = qword_268BA7730;
  if (!qword_268BA7730)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_268BA7730);
  }
  return result;
}

uint64_t sub_23C401D44(uint64_t (*a1)(void))
{
  return a1();
}

void sub_23C401D50(uint64_t *a1@<X8>)
{
  sub_23C4010B0(*(void *)(v1 + 24), a1);
}

uint64_t sub_23C401D6C(void *a1)
{
  id v1 = objc_msgSend(a1, sel_assistantDefinedSchemas);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = v1;
  sub_23C369F80(0, (unint64_t *)&unk_26AEED9C0);
  uint64_t v3 = sub_23C6D56A8();

  return v3;
}

uint64_t sub_23C401DDC(void *a1)
{
  id v2 = objc_msgSend(a1, sel_availabilityAnnotations);

  if (!v2) {
    return 0;
  }
  type metadata accessor for LNPlatformName(0);
  sub_23C369F80(0, &qword_26AEED950);
  sub_23C401CAC((unint64_t *)&unk_26AEED908, type metadata accessor for LNPlatformName);
  uint64_t v3 = sub_23C6D5418();

  return v3;
}

uint64_t sub_23C401EA8(uint64_t a1, uint64_t *a2)
{
  __swift_instantiateConcreteTypeFromMangledName(a2);
  OUTLINED_FUNCTION_15();
  OUTLINED_FUNCTION_80();
  v3();
  return a1;
}

uint64_t OUTLINED_FUNCTION_3_12(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t OUTLINED_FUNCTION_4_10()
{
  return swift_dynamicCastMetatype();
}

uint64_t OUTLINED_FUNCTION_5_12(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t OUTLINED_FUNCTION_8_8()
{
  return v0;
}

uint64_t OUTLINED_FUNCTION_12_11()
{
  return 0;
}

id sub_23C401FAC(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v7 = (void *)sub_23C6D5528();
  swift_bridgeObjectRelease();
  if (a4)
  {
    __swift_instantiateConcreteTypeFromMangledName(&qword_268BA62F0);
    uint64_t v8 = (void *)sub_23C6D5408();
    swift_bridgeObjectRelease();
  }
  else
  {
    uint64_t v8 = 0;
  }
  v12.receiver = v4;
  v12.super_class = (Class)type metadata accessor for SleepDeviceAction();
  id v9 = objc_msgSendSuper2(&v12, sel_initWithIdentifier_definition_serializedParameters_, v7, a3, v8);

  id v10 = v9;
  if (v10) {

  }
  return v10;
}

id sub_23C402118()
{
  v2.receiver = v0;
  v2.super_class = (Class)type metadata accessor for SleepDeviceAction();
  return objc_msgSendSuper2(&v2, sel_init);
}

id sub_23C402174()
{
  v2.receiver = v0;
  v2.super_class = (Class)type metadata accessor for SleepDeviceAction();
  return objc_msgSendSuper2(&v2, sel_dealloc);
}

uint64_t type metadata accessor for SleepDeviceAction()
{
  return self;
}

id sub_23C4021D0(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v7 = (void *)sub_23C6D5528();
  swift_bridgeObjectRelease();
  if (a4)
  {
    __swift_instantiateConcreteTypeFromMangledName(&qword_268BA62F0);
    uint64_t v8 = (void *)sub_23C6D5408();
    swift_bridgeObjectRelease();
  }
  else
  {
    uint64_t v8 = 0;
  }
  v12.receiver = v4;
  v12.super_class = (Class)type metadata accessor for DisplaySleepAction();
  id v9 = objc_msgSendSuper2(&v12, sel_initWithIdentifier_definition_serializedParameters_, v7, a3, v8);

  id v10 = v9;
  if (v10) {

  }
  return v10;
}

id sub_23C40233C()
{
  v2.receiver = v0;
  v2.super_class = (Class)type metadata accessor for DisplaySleepAction();
  return objc_msgSendSuper2(&v2, sel_init);
}

id sub_23C402398()
{
  v2.receiver = v0;
  v2.super_class = (Class)type metadata accessor for DisplaySleepAction();
  return objc_msgSendSuper2(&v2, sel_dealloc);
}

uint64_t type metadata accessor for DisplaySleepAction()
{
  return self;
}

uint64_t sub_23C4023F4()
{
  return MEMORY[0x270F86188](0xD000000000000023, 0x800000023C727F10, sub_23C402428, 0);
}

id sub_23C402428()
{
  uint64_t v0 = sub_23C6D45B8();
  MEMORY[0x270FA5388](v0 - 8);
  objc_super v2 = (char *)v38 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v3 = sub_23C6D46E8();
  MEMORY[0x270FA5388](v3 - 8);
  int v5 = (char *)v38 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  v38[0] = sub_23C369F80(0, (unint64_t *)&unk_268BA5C90);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEEE910);
  uint64_t inited = swift_initStackObject();
  uint64_t v7 = (void **)MEMORY[0x263F870A0];
  *(_OWORD *)(inited + 16) = xmmword_23C6F7FC0;
  uint64_t v8 = *v7;
  uint64_t v9 = MEMORY[0x263F8D310];
  *(void *)(inited + 32) = v8;
  *(void *)(inited + 40) = 0xD00000000000001ALL;
  *(void *)(inited + 48) = 0x800000023C722B50;
  id v10 = (void *)*MEMORY[0x263F87110];
  *(void *)(inited + 64) = v9;
  *(void *)(inited + 72) = v10;
  id v11 = v8;
  id v12 = v10;
  uint64_t v13 = sub_23C6D55A8();
  uint64_t v15 = v14;
  uint64_t v16 = sub_23C6D55A8();
  uint64_t v18 = v17;
  sub_23C6D46B8();
  if (qword_268BA5B80 != -1) {
    swift_once();
  }
  id v19 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v20 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v21 = sub_23C41B6F8(v13, v15, v16, v18, 0, 0, (uint64_t)v5, (uint64_t)v2);
  uint64_t v22 = sub_23C369F80(0, (unint64_t *)&unk_268BA5CA0);
  *(void *)(inited + 80) = v21;
  unint64_t v23 = (void *)*MEMORY[0x263F870D8];
  *(void *)(inited + 104) = v22;
  *(void *)(inited + 112) = v23;
  *(void *)(inited + 144) = v9;
  *(void *)(inited + 120) = 1954047316;
  *(void *)(inited + 128) = 0xE400000000000000;
  id v24 = v23;
  *(void *)(inited + 152) = sub_23C6D5528();
  uint64_t v25 = MEMORY[0x263F8D4F8];
  *(void *)(inited + 184) = MEMORY[0x263F8D4F8];
  *(unsigned char *)(inited + 160) = 1;
  *(void *)(inited + 192) = sub_23C6D5528();
  *(void *)(inited + 200) = 0xD000000000000055;
  *(void *)(inited + 208) = 0x800000023C727F70;
  uint64_t v26 = (void *)*MEMORY[0x263F872B0];
  *(void *)(inited + 224) = v9;
  *(void *)(inited + 232) = v26;
  id v27 = v26;
  uint64_t v28 = sub_23C6D5428();
  uint64_t v29 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA5CF8);
  uint64_t v30 = (void **)MEMORY[0x263F87108];
  *(void *)(inited + 240) = v28;
  uint64_t v31 = *v30;
  *(void *)(inited + 264) = v29;
  *(void *)(inited + 272) = v31;
  uint64_t v32 = (void **)MEMORY[0x263F87498];
  *(unsigned char *)(inited + 280) = 1;
  id v33 = *v32;
  *(void *)(inited + 304) = v25;
  *(void *)(inited + 312) = v33;
  *(void *)(inited + 344) = v25;
  *(unsigned char *)(inited + 320) = 1;
  type metadata accessor for Key(0);
  sub_23C37BB64();
  id v34 = v31;
  id v35 = v33;
  uint64_t v36 = sub_23C6D5428();
  return sub_23C41A1C0(v36);
}

uint64_t sub_23C4027C4()
{
  return sub_23C4023F4();
}

uint64_t sub_23C4027EC()
{
  return MEMORY[0x270F86188](0xD000000000000022, 0x800000023C727FE0, sub_23C402820, 0);
}

id sub_23C402820()
{
  uint64_t v275 = sub_23C6D4C28();
  uint64_t v277 = *(void *)(v275 - 8);
  MEMORY[0x270FA5388](v275);
  v274 = (id *)((char *)&v250 - ((v0 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v1 = sub_23C6D45B8();
  MEMORY[0x270FA5388](v1 - 8);
  uint64_t v3 = (char *)&v250 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v4 = sub_23C6D46E8();
  MEMORY[0x270FA5388](v4 - 8);
  uint64_t v6 = (char *)&v250 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v263 = sub_23C369F80(0, (unint64_t *)&unk_268BA5C90);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEEE910);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_23C6F84B0;
  uint64_t v8 = (void *)*MEMORY[0x263F870A0];
  uint64_t v9 = MEMORY[0x263F8D310];
  *(void *)(inited + 32) = *MEMORY[0x263F870A0];
  *(void *)(inited + 40) = 0xD000000000000016;
  id v268 = (id)0xD000000000000016;
  *(void *)(inited + 48) = 0x800000023C728010;
  id v10 = (void *)*MEMORY[0x263F87110];
  *(void *)(inited + 64) = v9;
  *(void *)(inited + 72) = v10;
  id v11 = v8;
  id v12 = v10;
  uint64_t v13 = sub_23C6D55A8();
  uint64_t v15 = v14;
  uint64_t v16 = sub_23C6D55A8();
  uint64_t v18 = v17;
  sub_23C6D46B8();
  if (qword_268BA5B80 != -1) {
    swift_once();
  }
  id v19 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v20 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v21 = sub_23C41B6F8(v13, v15, v16, v18, 0, 0, (uint64_t)v6, (uint64_t)v3);
  uint64_t v22 = sub_23C369F80(0, (unint64_t *)&unk_268BA5CA0);
  uint64_t v279 = v22;
  *(void *)(inited + 80) = v21;
  unint64_t v23 = (void *)*MEMORY[0x263F87190];
  *(void *)(inited + 104) = v22;
  *(void *)(inited + 112) = v23;
  uint64_t v276 = sub_23C369F80(0, (unint64_t *)&unk_268BA6EE0);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CB0);
  uint64_t v24 = swift_initStackObject();
  long long v269 = xmmword_23C6F6A90;
  *(_OWORD *)(v24 + 16) = xmmword_23C6F6A90;
  uint64_t v25 = (void *)*MEMORY[0x263F871A0];
  *(void *)(v24 + 32) = *MEMORY[0x263F871A0];
  id v26 = v23;
  id v27 = v25;
  uint64_t v28 = sub_23C6D55A8();
  uint64_t v30 = v29;
  uint64_t v31 = sub_23C6D55A8();
  uint64_t v33 = v32;
  sub_23C6D46B8();
  id v34 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v35 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v36 = (uint64_t)v6;
  *(void *)(v24 + 40) = sub_23C41B6F8(v28, v30, v31, v33, 0, 0, (uint64_t)v6, (uint64_t)v3);
  v37 = (void *)*MEMORY[0x263F871A8];
  uint64_t v38 = v279;
  *(void *)(v24 + 64) = v279;
  *(void *)(v24 + 72) = v37;
  id v39 = v37;
  uint64_t v278 = sub_23C6D55A8();
  uint64_t v41 = v40;
  uint64_t v42 = sub_23C6D55A8();
  uint64_t v44 = v43;
  sub_23C6D46B8();
  id v45 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v46 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v47 = v36;
  id v48 = sub_23C41B6F8(v278, v41, v42, v44, 0, 0, v36, (uint64_t)v3);
  *(void *)(v24 + 104) = v38;
  *(void *)(v24 + 80) = v48;
  type metadata accessor for DescriptionKey(0);
  sub_23C375C5C((unint64_t *)&unk_268BA6EF0, type metadata accessor for DescriptionKey);
  uint64_t v278 = MEMORY[0x263F8EE58] + 8;
  uint64_t v49 = sub_23C6D5428();
  uint64_t v50 = v276;
  id v51 = sub_23C41A078(v49);
  v52 = (void **)MEMORY[0x263F870D0];
  *(void *)(inited + 120) = v51;
  v53 = *v52;
  *(void *)(inited + 144) = v50;
  *(void *)(inited + 152) = v53;
  *(void *)(inited + 160) = 2036429383;
  *(void *)(inited + 168) = 0xE400000000000000;
  v54 = (void *)*MEMORY[0x263F870E8];
  uint64_t v55 = MEMORY[0x263F8D310];
  *(void *)(inited + 184) = MEMORY[0x263F8D310];
  *(void *)(inited + 192) = v54;
  *(void *)(inited + 200) = 0xD000000000000011;
  *(void *)(inited + 208) = 0x800000023C7280A0;
  v56 = (void *)*MEMORY[0x263F87120];
  *(void *)(inited + 224) = v55;
  *(void *)(inited + 232) = v56;
  id v57 = v53;
  id v58 = v54;
  id v59 = v56;
  uint64_t v60 = sub_23C6D55A8();
  uint64_t v62 = v61;
  uint64_t v63 = sub_23C6D55A8();
  uint64_t v65 = v64;
  sub_23C6D46B8();
  id v66 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v67 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(inited + 240) = sub_23C41B6F8(v60, v62, v63, v65, 0, 0, v47, (uint64_t)v3);
  v68 = (void *)*MEMORY[0x263F872B0];
  *(void *)(inited + 264) = v38;
  *(void *)(inited + 272) = v68;
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CC0);
  uint64_t v69 = swift_initStackObject();
  *(_OWORD *)(v69 + 16) = xmmword_23C6F6A80;
  *(void *)(v69 + 32) = 0x656C7069746C754DLL;
  *(void *)(v69 + 40) = 0xE800000000000000;
  uint64_t v70 = MEMORY[0x263F8D4F8];
  *(unsigned char *)(v69 + 48) = 1;
  *(void *)(v69 + 72) = v70;
  *(void *)(v69 + 80) = 0x614E74757074754FLL;
  *(void *)(v69 + 88) = 0xEA0000000000656DLL;
  id v71 = v68;
  uint64_t v72 = sub_23C6D55A8();
  uint64_t v74 = v73;
  uint64_t v75 = sub_23C6D55A8();
  uint64_t v77 = v76;
  uint64_t v78 = v47;
  sub_23C6D46B8();
  id v79 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  v270 = v3;
  sub_23C6D4598();

  id v80 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v81 = v78;
  *(void *)(v69 + 96) = sub_23C41B6F8(v72, v74, v75, v77, 0, 0, v78, (uint64_t)v3);
  *(void *)(v69 + 120) = v279;
  *(void *)(v69 + 128) = 0x6465726975716552;
  *(void *)(v69 + 136) = 0xE800000000000000;
  *(unsigned char *)(v69 + 144) = 1;
  *(void *)(v69 + 168) = MEMORY[0x263F8D4F8];
  *(void *)(v69 + 176) = 0x7365707954;
  *(void *)(v69 + 184) = 0xE500000000000000;
  uint64_t v262 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F00);
  *(void *)(v69 + 216) = v262;
  *(void *)(v69 + 192) = &unk_26EFFBF68;
  uint64_t v82 = MEMORY[0x263F8D310];
  uint64_t v83 = sub_23C6D5428();
  uint64_t v84 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA5CD0);
  *(void *)(inited + 280) = v83;
  v85 = (void *)*MEMORY[0x263F87130];
  *(void *)(inited + 304) = v84;
  *(void *)(inited + 312) = v85;
  id v250 = (id)__swift_instantiateConcreteTypeFromMangledName(&qword_268BA6C30);
  uint64_t v272 = swift_allocObject();
  *(_OWORD *)(v272 + 16) = xmmword_23C6F8C50;
  uint64_t v276 = sub_23C369F80(0, &qword_268BA5CE0);
  uint64_t v273 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CE8);
  uint64_t v86 = swift_allocObject();
  long long v260 = xmmword_23C6F8480;
  *(_OWORD *)(v86 + 16) = xmmword_23C6F8480;
  v87 = (void *)*MEMORY[0x263F872D8];
  id v88 = v268;
  *(void *)(v86 + 32) = *MEMORY[0x263F872D8];
  *(void *)(v86 + 40) = v88;
  uint64_t v259 = 0x800000023C71F540;
  *(void *)(v86 + 48) = 0x800000023C71F540;
  v89 = (void *)*MEMORY[0x263F872E0];
  *(void *)(v86 + 64) = v82;
  *(void *)(v86 + 72) = v89;
  *(void *)(v86 + 80) = 0x726353206C6C7546;
  *(void *)(v86 + 88) = 0xEB000000006E6565;
  v90 = (void *)*MEMORY[0x263F87318];
  *(void *)(v86 + 104) = v82;
  *(void *)(v86 + 112) = v90;
  uint64_t v271 = swift_allocObject();
  long long v258 = xmmword_23C6F81A0;
  *(_OWORD *)(v271 + 16) = xmmword_23C6F81A0;
  id v91 = v85;
  *(void *)&long long v254 = v87;
  id v253 = v89;
  id v255 = v90;
  uint64_t v92 = sub_23C6D55A8();
  uint64_t v94 = v93;
  uint64_t v95 = sub_23C6D55A8();
  uint64_t v97 = v96;
  sub_23C6D46B8();
  v261 = (void *)inited;
  id v98 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v99 = (uint64_t)v270;
  sub_23C6D4598();

  id v100 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v101 = sub_23C41B6F8(v92, v94, v95, v97, 0, 0, v81, v99);
  uint64_t v102 = v271;
  *(void *)(v271 + 32) = v101;
  uint64_t v103 = sub_23C6D55A8();
  uint64_t v105 = v104;
  uint64_t v106 = sub_23C6D55A8();
  uint64_t v108 = v107;
  uint64_t v109 = v81;
  sub_23C6D46B8();
  id v110 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v111 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v112 = v109;
  *(void *)(v102 + 40) = sub_23C41B6F8(v103, v105, v106, v108, 0, 0, v109, v99);
  uint64_t v280 = v102;
  sub_23C6D56B8();
  uint64_t v113 = v280;
  uint64_t v114 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F10);
  id v257 = (id)v114;
  *(void *)(v86 + 120) = v113;
  v115 = (void *)*MEMORY[0x263F87350];
  *(void *)(v86 + 144) = v114;
  *(void *)(v86 + 152) = v115;
  *(void *)(v86 + 160) = 0xD00000000000001ELL;
  *(void *)(v86 + 168) = 0x800000023C71D7B0;
  v116 = (void *)*MEMORY[0x263F87360];
  uint64_t v117 = MEMORY[0x263F8D310];
  *(void *)(v86 + 184) = MEMORY[0x263F8D310];
  *(void *)(v86 + 192) = v116;
  id v252 = v115;
  id v256 = v116;
  uint64_t v118 = sub_23C6D55A8();
  uint64_t v120 = v119;
  uint64_t v121 = sub_23C6D55A8();
  uint64_t v123 = v122;
  sub_23C6D46B8();
  id v124 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v125 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v86 + 200) = sub_23C41B6F8(v118, v120, v121, v123, 0, 0, v112, v99);
  v126 = (void *)*MEMORY[0x263F873B8];
  *(void *)(v86 + 224) = v279;
  *(void *)(v86 + 232) = v126;
  uint64_t v127 = swift_allocObject();
  *(_OWORD *)(v127 + 16) = xmmword_23C6F77E0;
  v128 = v274;
  void *v274 = 2;
  unsigned int v267 = *MEMORY[0x263F866D0];
  v129 = *(void (**)(void))(v277 + 104);
  v277 += 104;
  v266 = (void (*)(void *, void, uint64_t))v129;
  v129(v128);
  Class v265 = (Class)sub_23C6D4C48();
  id v130 = objc_allocWithZone(v265);
  id v251 = v126;
  *(void *)(v127 + 32) = sub_23C6D4C38();
  uint64_t v280 = v127;
  sub_23C6D56B8();
  uint64_t v131 = v280;
  *(void *)(v86 + 264) = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA60A0);
  *(void *)(v86 + 240) = v131;
  _s3__C3KeyVMa_0(0);
  uint64_t v264 = v132;
  uint64_t v271 = sub_23C375C5C(&qword_26AEEE340, _s3__C3KeyVMa_0);
  uint64_t v133 = sub_23C6D5428();
  id v134 = sub_23C41A0C0(v133);
  *(void *)(v272 + 32) = v134;
  uint64_t v135 = swift_allocObject();
  *(_OWORD *)(v135 + 16) = v260;
  v137 = v253;
  v136 = (void *)v254;
  id v138 = v268;
  *(void *)(v135 + 32) = v254;
  *(void *)(v135 + 40) = v138;
  *(void *)(v135 + 48) = v259;
  *(void *)(v135 + 64) = v117;
  *(void *)(v135 + 72) = v137;
  *(void *)(v135 + 80) = 0x776F646E6957;
  *(void *)(v135 + 88) = 0xE600000000000000;
  *(void *)(v135 + 104) = v117;
  v139 = v255;
  *(void *)(v135 + 112) = v255;
  uint64_t v140 = swift_allocObject();
  *(_OWORD *)(v140 + 16) = v258;
  id v268 = v136;
  *(void *)&long long v260 = v137;
  id v141 = v139;
  uint64_t v142 = sub_23C6D55A8();
  uint64_t v144 = v143;
  uint64_t v145 = sub_23C6D55A8();
  uint64_t v147 = v146;
  uint64_t v148 = v112;
  sub_23C6D46B8();
  id v149 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v150 = (uint64_t)v270;
  sub_23C6D4598();

  id v151 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v152 = v148;
  uint64_t v153 = v148;
  uint64_t v154 = v150;
  *(void *)(v140 + 32) = sub_23C41B6F8(v142, v144, v145, v147, 0, 0, v153, v150);
  uint64_t v155 = sub_23C6D55A8();
  uint64_t v157 = v156;
  uint64_t v158 = sub_23C6D55A8();
  uint64_t v160 = v159;
  uint64_t v161 = v152;
  sub_23C6D46B8();
  id v162 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v163 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v140 + 40) = sub_23C41B6F8(v155, v157, v158, v160, 0, 0, v161, v154);
  uint64_t v280 = v140;
  sub_23C6D56B8();
  *(void *)(v135 + 120) = v280;
  v164 = v256;
  v165 = v252;
  *(void *)(v135 + 144) = v257;
  *(void *)(v135 + 152) = v165;
  *(void *)(v135 + 160) = 0xD00000000000002ELL;
  *(void *)(v135 + 168) = 0x800000023C728270;
  *(void *)(v135 + 184) = MEMORY[0x263F8D310];
  *(void *)(v135 + 192) = v164;
  id v255 = v165;
  id v257 = v164;
  uint64_t v166 = sub_23C6D55A8();
  uint64_t v168 = v167;
  uint64_t v169 = sub_23C6D55A8();
  uint64_t v171 = v170;
  sub_23C6D46B8();
  id v172 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v173 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v174 = v161;
  *(void *)(v135 + 200) = sub_23C41B6F8(v166, v168, v169, v171, 0, 0, v161, v154);
  v175 = v251;
  *(void *)(v135 + 224) = v279;
  *(void *)(v135 + 232) = v175;
  uint64_t v259 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA6860);
  uint64_t v176 = swift_allocObject();
  *(_OWORD *)(v176 + 16) = v269;
  v178 = v274;
  uint64_t v177 = v275;
  void *v274 = 2;
  v266(v178, v267, v177);
  Class v179 = v265;
  id v180 = objc_allocWithZone(v265);
  id v252 = v175;
  uint64_t v181 = sub_23C6D4C38();
  *(void *)(v176 + 56) = v179;
  *(void *)(v176 + 32) = v181;
  uint64_t v182 = MEMORY[0x263F8D310];
  uint64_t v183 = sub_23C6D5428();
  *(void *)&long long v258 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA5CF8);
  *(void *)(v176 + 88) = v258;
  *(void *)(v176 + 64) = v183;
  id v256 = (id)__swift_instantiateConcreteTypeFromMangledName(&qword_268BA6F30);
  *(void *)(v135 + 264) = v256;
  *(void *)(v135 + 240) = v176;
  uint64_t v184 = sub_23C6D5428();
  id v185 = sub_23C41A0C0(v184);
  *(void *)(v272 + 40) = v185;
  uint64_t v186 = swift_allocObject();
  long long v254 = xmmword_23C6F8490;
  *(_OWORD *)(v186 + 16) = xmmword_23C6F8490;
  v187 = v268;
  *(void *)(v186 + 32) = v268;
  *(void *)(v186 + 40) = 0xD000000000000011;
  id v253 = (id)0x800000023C720610;
  *(void *)(v186 + 48) = 0x800000023C720610;
  v188 = (void *)v260;
  *(void *)(v186 + 64) = v182;
  *(void *)(v186 + 72) = v188;
  *(unsigned char *)(v186 + 80) = 0;
  v189 = v255;
  *(void *)(v186 + 104) = MEMORY[0x263F8D4F8];
  *(void *)(v186 + 112) = v189;
  *(void *)(v186 + 120) = 0xD00000000000001FLL;
  *(void *)(v186 + 128) = 0x800000023C7282F0;
  *(void *)(v186 + 144) = v182;
  v190 = v257;
  *(void *)(v186 + 152) = v257;
  id v251 = v187;
  id v250 = v188;
  *(void *)&long long v260 = v189;
  id v268 = v190;
  uint64_t v191 = sub_23C6D55A8();
  uint64_t v193 = v192;
  uint64_t v194 = sub_23C6D55A8();
  uint64_t v196 = v195;
  uint64_t v197 = v174;
  sub_23C6D46B8();
  id v198 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v199 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v200 = v196;
  uint64_t v201 = v197;
  *(void *)(v186 + 160) = sub_23C41B6F8(v191, v193, v194, v200, 0, 0, v197, v154);
  v202 = v252;
  *(void *)(v186 + 184) = v279;
  *(void *)(v186 + 192) = v202;
  uint64_t v203 = swift_allocObject();
  *(_OWORD *)(v203 + 16) = v269;
  v205 = v274;
  uint64_t v204 = v275;
  void *v274 = 2;
  v266(v205, v267, v204);
  Class v206 = v265;
  id v207 = objc_allocWithZone(v265);
  id v208 = v202;
  uint64_t v209 = sub_23C6D4C38();
  *(void *)(v203 + 56) = v206;
  *(void *)(v203 + 32) = v209;
  uint64_t v210 = MEMORY[0x263F8D310];
  uint64_t v211 = sub_23C6D5428();
  *(void *)(v203 + 88) = v258;
  *(void *)(v203 + 64) = v211;
  *(void *)(v186 + 224) = v256;
  *(void *)(v186 + 200) = v203;
  uint64_t v212 = sub_23C6D5428();
  id v213 = sub_23C41A0C0(v212);
  uint64_t v214 = v272;
  *(void *)(v272 + 48) = v213;
  uint64_t v215 = swift_allocObject();
  *(_OWORD *)(v215 + 16) = v254;
  v217 = v250;
  v216 = v251;
  *(void *)(v215 + 32) = v251;
  *(void *)(v215 + 40) = 0xD000000000000011;
  *(void *)(v215 + 48) = v253;
  *(void *)(v215 + 64) = v210;
  *(void *)(v215 + 72) = v217;
  *(unsigned char *)(v215 + 80) = 0;
  v218 = (void *)*MEMORY[0x263F87320];
  uint64_t v219 = MEMORY[0x263F8D4F8];
  *(void *)(v215 + 104) = MEMORY[0x263F8D4F8];
  *(void *)(v215 + 112) = v218;
  *(unsigned char *)(v215 + 120) = 1;
  v220 = (void *)v260;
  *(void *)(v215 + 144) = v219;
  *(void *)(v215 + 152) = v220;
  *(void *)(v215 + 160) = 0xD000000000000030;
  *(void *)(v215 + 168) = 0x800000023C728370;
  *(void *)(v215 + 184) = v210;
  v221 = v268;
  *(void *)(v215 + 192) = v268;
  id v222 = v216;
  id v223 = v217;
  id v224 = v218;
  id v225 = v220;
  id v226 = v221;
  uint64_t v227 = sub_23C6D55A8();
  uint64_t v229 = v228;
  uint64_t v230 = sub_23C6D55A8();
  uint64_t v232 = v231;
  uint64_t v233 = v201;
  sub_23C6D46B8();
  id v234 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v235 = (uint64_t)v270;
  sub_23C6D4598();

  id v236 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v237 = sub_23C41B6F8(v227, v229, v230, v232, 0, 0, v233, v235);
  *(void *)(v215 + 224) = v279;
  *(void *)(v215 + 200) = v237;
  uint64_t v238 = sub_23C6D5428();
  *(void *)(v214 + 56) = sub_23C41A0C0(v238);
  uint64_t v280 = v214;
  sub_23C6D56B8();
  uint64_t v239 = v280;
  uint64_t v240 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F20);
  v241 = v261;
  v261[40] = v239;
  v242 = (void *)*MEMORY[0x263F87208];
  v241[43] = v240;
  v241[44] = v242;
  id v243 = v242;
  uint64_t v244 = sub_23C6D5428();
  uint64_t v245 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA7760);
  v241[45] = v244;
  v246 = (void *)*MEMORY[0x263F873E8];
  v241[48] = v245;
  v241[49] = v246;
  v241[53] = v262;
  v241[50] = &unk_26EFFC100;
  type metadata accessor for Key(0);
  sub_23C375C5C((unint64_t *)&qword_26AEEE8F0, type metadata accessor for Key);
  id v247 = v246;
  uint64_t v248 = sub_23C6D5428();
  return sub_23C41A1C0(v248);
}

uint64_t sub_23C403D70()
{
  return sub_23C4027EC();
}

uint64_t sub_23C403D98()
{
  return MEMORY[0x270F86188](0xD00000000000001FLL, 0x800000023C728450, sub_23C403DCC, 0);
}

id sub_23C403DCC()
{
  uint64_t v0 = sub_23C6D45B8();
  MEMORY[0x270FA5388](v0 - 8);
  uint64_t v2 = (char *)&v458 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v3 = sub_23C6D46E8();
  MEMORY[0x270FA5388](v3 - 8);
  uint64_t v5 = (char *)&v458 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v467 = sub_23C369F80(0, (unint64_t *)&unk_268BA5C90);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEEE910);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_23C6F6A60;
  uint64_t v7 = (void *)*MEMORY[0x263F870A0];
  uint64_t v8 = MEMORY[0x263F8D310];
  *(void *)(inited + 32) = *MEMORY[0x263F870A0];
  *(void *)(inited + 40) = 0xD000000000000012;
  *(void *)(inited + 48) = 0x800000023C728470;
  uint64_t v9 = (void *)*MEMORY[0x263F87110];
  *(void *)(inited + 64) = v8;
  *(void *)(inited + 72) = v9;
  id v10 = v7;
  id v11 = v9;
  uint64_t v12 = sub_23C6D55A8();
  uint64_t v14 = v13;
  uint64_t v15 = sub_23C6D55A8();
  uint64_t v17 = v16;
  sub_23C6D46B8();
  if (qword_268BA5B80 != -1) {
    swift_once();
  }
  id v18 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v19 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v20 = sub_23C41B6F8(v12, v14, v15, v17, 0, 0, (uint64_t)v5, (uint64_t)v2);
  uint64_t v21 = sub_23C369F80(0, (unint64_t *)&unk_268BA5CA0);
  uint64_t v492 = v21;
  *(void *)(inited + 80) = v20;
  uint64_t v22 = (void *)*MEMORY[0x263F87190];
  *(void *)(inited + 104) = v21;
  *(void *)(inited + 112) = v22;
  uint64_t v491 = sub_23C369F80(0, (unint64_t *)&unk_268BA6EE0);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CB0);
  uint64_t v23 = swift_initStackObject();
  *(_OWORD *)(v23 + 16) = xmmword_23C6F6A90;
  uint64_t v24 = (void *)*MEMORY[0x263F87198];
  *(void *)(v23 + 32) = *MEMORY[0x263F87198];
  id v25 = v22;
  id v26 = v24;
  uint64_t v27 = sub_23C6D55A8();
  uint64_t v29 = v28;
  uint64_t v30 = sub_23C6D55A8();
  v482 = (void *)inited;
  uint64_t v32 = v31;
  sub_23C6D46B8();
  id v33 = objc_msgSend((id)qword_268BA7768, (SEL)&selRef_badCoercionErrorForType_);
  sub_23C6D4598();

  id v34 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v23 + 40) = sub_23C41B6F8(v27, v29, v30, v32, 0, 0, (uint64_t)v5, (uint64_t)v2);
  id v35 = (void *)*MEMORY[0x263F871A8];
  uint64_t v36 = (uint64_t)v2;
  uint64_t v37 = (uint64_t)v5;
  uint64_t v38 = v492;
  *(void *)(v23 + 64) = v492;
  *(void *)(v23 + 72) = v35;
  id v39 = v35;
  uint64_t v40 = sub_23C6D55A8();
  uint64_t v42 = v41;
  uint64_t v43 = sub_23C6D55A8();
  uint64_t v45 = v44;
  sub_23C6D46B8();
  id v46 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v480 = v36;
  sub_23C6D4598();

  id v47 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v48 = v37;
  id v49 = sub_23C41B6F8(v40, v42, v43, v45, 0, 0, v37, v36);
  *(void *)(v23 + 104) = v38;
  *(void *)(v23 + 80) = v49;
  type metadata accessor for DescriptionKey(0);
  sub_23C375C5C((unint64_t *)&unk_268BA6EF0, type metadata accessor for DescriptionKey);
  uint64_t v493 = MEMORY[0x263F8EE58] + 8;
  uint64_t v50 = sub_23C6D5428();
  uint64_t v51 = v491;
  id v52 = sub_23C41A078(v50);
  v53 = v482;
  v482[15] = v52;
  v54 = (void *)*MEMORY[0x263F870D0];
  v53[18] = v51;
  v53[19] = v54;
  v53[20] = 1953392980;
  v53[21] = 0xE400000000000000;
  uint64_t v55 = (void *)*MEMORY[0x263F870E8];
  uint64_t v56 = MEMORY[0x263F8D310];
  v53[23] = MEMORY[0x263F8D310];
  v53[24] = v55;
  v53[25] = 0x7261646E656C6163;
  v53[26] = 0xE800000000000000;
  id v57 = (void *)*MEMORY[0x263F870E0];
  v53[28] = v56;
  v53[29] = v57;
  v53[30] = 6579538;
  v53[31] = 0xE300000000000000;
  id v58 = (void *)*MEMORY[0x263F87220];
  v53[33] = v56;
  v53[34] = v58;
  uint64_t v59 = v56;
  uint64_t v60 = v53;
  uint64_t v483 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CC0);
  uint64_t v61 = swift_initStackObject();
  long long v487 = xmmword_23C6F6A80;
  *(_OWORD *)(v61 + 16) = xmmword_23C6F6A80;
  *(void *)(v61 + 32) = 0x656C7069746C754DLL;
  *(void *)(v61 + 40) = 0xE800000000000000;
  uint64_t v62 = MEMORY[0x263F8D4F8];
  *(unsigned char *)(v61 + 48) = 1;
  *(void *)(v61 + 72) = v62;
  strcpy((char *)(v61 + 80), "ParameterKey");
  *(unsigned char *)(v61 + 93) = 0;
  *(_WORD *)(v61 + 94) = -5120;
  *(void *)(v61 + 96) = 0x657461444657;
  *(void *)(v61 + 104) = 0xE600000000000000;
  *(void *)(v61 + 120) = v59;
  *(void *)(v61 + 128) = 0x6465726975716552;
  *(void *)(v61 + 136) = 0xE800000000000000;
  *(unsigned char *)(v61 + 144) = 1;
  *(void *)(v61 + 168) = v62;
  *(void *)(v61 + 176) = 0x7365707954;
  *(void *)(v61 + 184) = 0xE500000000000000;
  uint64_t v484 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F00);
  *(void *)(v61 + 216) = v484;
  *(void *)(v61 + 192) = &unk_26EFFC130;
  id v63 = v54;
  id v64 = v55;
  id v65 = v57;
  id v66 = v58;
  uint64_t v67 = sub_23C6D5428();
  uint64_t v68 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA5CD0);
  uint64_t v491 = v68;
  v60[35] = v67;
  uint64_t v69 = (void *)*MEMORY[0x263F87120];
  v60[38] = v68;
  v60[39] = v69;
  id v70 = v69;
  uint64_t v71 = sub_23C6D55A8();
  uint64_t v73 = v72;
  uint64_t v74 = sub_23C6D55A8();
  uint64_t v76 = v75;
  sub_23C6D46B8();
  id v77 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v78 = v480;
  sub_23C6D4598();

  id v79 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  v60[40] = sub_23C41B6F8(v71, v73, v74, v76, 0, 0, v48, v78);
  id v80 = (void *)*MEMORY[0x263F872B0];
  uint64_t v81 = v492;
  v60[43] = v492;
  v60[44] = v80;
  uint64_t v82 = swift_allocObject();
  *(_OWORD *)(v82 + 16) = v487;
  *(void *)(v82 + 32) = 0x75736F6C63736944;
  *(void *)(v82 + 40) = 0xEF6C6576654C6572;
  *(void *)(v82 + 48) = 0x63696C627550;
  *(void *)(v82 + 56) = 0xE600000000000000;
  *(void *)(v82 + 72) = MEMORY[0x263F8D310];
  *(void *)(v82 + 80) = 0x656C7069746C754DLL;
  *(void *)(v82 + 88) = 0xE800000000000000;
  *(unsigned char *)(v82 + 96) = 1;
  *(void *)(v82 + 120) = MEMORY[0x263F8D4F8];
  *(void *)(v82 + 128) = 0x614E74757074754FLL;
  *(void *)(v82 + 136) = 0xEA0000000000656DLL;
  id v83 = v80;
  uint64_t v84 = sub_23C6D55A8();
  uint64_t v86 = v85;
  uint64_t v87 = sub_23C6D55A8();
  uint64_t v89 = v88;
  uint64_t v90 = v48;
  sub_23C6D46B8();
  id v91 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v92 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v93 = v90;
  *(void *)(v82 + 144) = sub_23C41B6F8(v84, v86, v87, v89, 0, 0, v90, v78);
  *(void *)(v82 + 168) = v81;
  *(void *)(v82 + 176) = 0x7365707954;
  *(void *)(v82 + 216) = v484;
  *(void *)(v82 + 184) = 0xE500000000000000;
  *(void *)(v82 + 192) = &unk_26EFFC160;
  uint64_t v94 = MEMORY[0x263F8D310];
  uint64_t v95 = sub_23C6D5428();
  uint64_t v96 = v482;
  v482[45] = v95;
  uint64_t v97 = (void *)*MEMORY[0x263F87130];
  v96[48] = v491;
  v96[49] = v97;
  id v471 = (id)__swift_instantiateConcreteTypeFromMangledName(&qword_268BA6C30);
  uint64_t v491 = swift_allocObject();
  *(_OWORD *)(v491 + 16) = xmmword_23C6FB0C0;
  uint64_t v490 = sub_23C369F80(0, &qword_268BA5CE0);
  uint64_t v488 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CE8);
  uint64_t v98 = swift_allocObject();
  long long v474 = xmmword_23C6F8480;
  *(_OWORD *)(v98 + 16) = xmmword_23C6F8480;
  uint64_t v99 = (void *)*MEMORY[0x263F872D8];
  v473 = (_OWORD *)0xD000000000000016;
  *(void *)(v98 + 32) = v99;
  *(void *)(v98 + 40) = 0xD000000000000016;
  id v472 = (id)0x800000023C71F540;
  id v100 = (void **)MEMORY[0x263F872E0];
  *(void *)(v98 + 48) = 0x800000023C71F540;
  id v101 = *v100;
  *(void *)(v98 + 64) = v94;
  *(void *)(v98 + 72) = v101;
  *(void *)(v98 + 80) = 0x74726F6853;
  *(void *)(v98 + 88) = 0xE500000000000000;
  uint64_t v102 = (void *)*MEMORY[0x263F87318];
  *(void *)(v98 + 104) = v94;
  *(void *)(v98 + 112) = v102;
  uint64_t v103 = swift_allocObject();
  *(_OWORD *)(v103 + 16) = xmmword_23C6F84A0;
  id v104 = v97;
  id v469 = v99;
  id v464 = v101;
  id v468 = v102;
  uint64_t v105 = sub_23C6D55A8();
  uint64_t v107 = v106;
  uint64_t v108 = sub_23C6D55A8();
  uint64_t v110 = v109;
  uint64_t v111 = v93;
  sub_23C6D46B8();
  id v112 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v113 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v103 + 32) = sub_23C41B6F8(v105, v107, v108, v110, 0, 0, v111, v78);
  uint64_t v114 = sub_23C6D55A8();
  uint64_t v116 = v115;
  uint64_t v117 = sub_23C6D55A8();
  uint64_t v119 = v118;
  sub_23C6D46B8();
  id v120 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v121 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v103 + 40) = sub_23C41B6F8(v114, v116, v117, v119, 0, 0, v111, v78);
  uint64_t v122 = sub_23C6D55A8();
  uint64_t v124 = v123;
  uint64_t v125 = sub_23C6D55A8();
  uint64_t v127 = v126;
  sub_23C6D46B8();
  id v128 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v129 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v103 + 48) = sub_23C41B6F8(v122, v124, v125, v127, 0, 0, v111, v78);
  uint64_t v130 = sub_23C6D55A8();
  uint64_t v132 = v131;
  uint64_t v133 = sub_23C6D55A8();
  uint64_t v135 = v134;
  sub_23C6D46B8();
  id v136 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v137 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v103 + 56) = sub_23C41B6F8(v130, v132, v133, v135, 0, 0, v111, v78);
  uint64_t v489 = v103;
  uint64_t v138 = sub_23C6D55A8();
  uint64_t v140 = v139;
  uint64_t v141 = sub_23C6D55A8();
  uint64_t v143 = v142;
  sub_23C6D46B8();
  id v144 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v145 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v103 + 64) = sub_23C41B6F8(v138, v140, v141, v143, 0, 0, v111, v78);
  uint64_t v146 = sub_23C6D55A8();
  uint64_t v148 = v147;
  uint64_t v149 = sub_23C6D55A8();
  uint64_t v151 = v150;
  sub_23C6D46B8();
  id v152 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v153 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v154 = sub_23C41B6F8(v146, v148, v149, v151, 0, 0, v111, v78);
  uint64_t v155 = v489;
  *(void *)(v489 + 72) = v154;
  uint64_t v156 = sub_23C6D55A8();
  *(void *)&long long v486 = v157;
  uint64_t v158 = sub_23C6D55A8();
  uint64_t v160 = v159;
  sub_23C6D46B8();
  id v161 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v162 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v155 + 80) = sub_23C41B6F8(v156, v486, v158, v160, 0, 0, v111, v78);
  uint64_t v163 = sub_23C6D55A8();
  uint64_t v165 = v164;
  uint64_t v166 = sub_23C6D55A8();
  uint64_t v168 = v167;
  sub_23C6D46B8();
  id v169 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v170 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v171 = v78;
  *(void *)(v155 + 88) = sub_23C41B6F8(v163, v165, v166, v168, 0, 0, v111, v78);
  uint64_t v494 = v155;
  sub_23C6D56B8();
  uint64_t v172 = v494;
  uint64_t v173 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F10);
  id v470 = (id)v173;
  *(void *)(v98 + 120) = v172;
  uint64_t v174 = (void *)*MEMORY[0x263F87350];
  *(void *)(v98 + 144) = v173;
  *(void *)(v98 + 152) = v174;
  unint64_t v479 = 0x800000023C71D7F0;
  *(void *)(v98 + 160) = 0xD000000000000011;
  *(void *)(v98 + 168) = 0x800000023C71D7F0;
  v175 = (void *)*MEMORY[0x263F87360];
  uint64_t v176 = MEMORY[0x263F8D310];
  *(void *)(v98 + 184) = MEMORY[0x263F8D310];
  *(void *)(v98 + 192) = v175;
  id v462 = v174;
  id v463 = v175;
  uint64_t v177 = sub_23C6D55A8();
  uint64_t v179 = v178;
  uint64_t v180 = sub_23C6D55A8();
  uint64_t v182 = v181;
  sub_23C6D46B8();
  id v183 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v184 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v185 = v182;
  uint64_t v186 = v111;
  uint64_t v187 = v111;
  uint64_t v188 = v171;
  *(void *)(v98 + 200) = sub_23C41B6F8(v177, v179, v180, v185, 0, 0, v186, v171);
  v189 = (void *)*MEMORY[0x263F873B8];
  *(void *)(v98 + 224) = v492;
  *(void *)(v98 + 232) = v189;
  uint64_t v478 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA66B0);
  uint64_t v190 = swift_allocObject();
  long long v486 = xmmword_23C6F6A70;
  *(_OWORD *)(v190 + 16) = xmmword_23C6F6A70;
  uint64_t v191 = swift_allocObject();
  long long v466 = xmmword_23C6F6AA0;
  *(_OWORD *)(v191 + 16) = xmmword_23C6F6AA0;
  strcpy((char *)(v191 + 32), "WFParameterKey");
  *(unsigned char *)(v191 + 47) = -18;
  id v465 = (id)0x800000023C728760;
  *(void *)(v191 + 48) = 0xD000000000000011;
  *(void *)(v191 + 56) = 0x800000023C728760;
  *(void *)(v191 + 72) = v176;
  *(void *)(v191 + 80) = 0xD000000000000011;
  unint64_t v477 = 0x800000023C728780;
  *(void *)(v191 + 88) = 0x800000023C728780;
  *(void *)(v191 + 96) = &unk_26EFFC190;
  *(void *)(v191 + 120) = v484;
  *(void *)(v191 + 128) = 0x72756F7365524657;
  *(void *)(v191 + 168) = v176;
  unint64_t v481 = 0xD00000000000001BLL;
  *(void *)(v191 + 136) = 0xEF7373616C436563;
  *(void *)(v191 + 144) = 0xD00000000000001BLL;
  unint64_t v476 = 0x800000023C71D2E0;
  *(void *)(v191 + 152) = 0x800000023C71D2E0;
  id v461 = v189;
  *(void *)(v190 + 32) = sub_23C6D5428();
  uint64_t v475 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA66B8);
  *(void *)(v98 + 264) = v475;
  *(void *)(v98 + 240) = v190;
  _s3__C3KeyVMa_0(0);
  uint64_t v489 = v192;
  uint64_t v485 = sub_23C375C5C(&qword_26AEEE340, _s3__C3KeyVMa_0);
  uint64_t v193 = sub_23C6D5428();
  id v194 = sub_23C41A0C0(v193);
  *(void *)(v491 + 32) = v194;
  uint64_t v195 = swift_allocObject();
  *(_OWORD *)(v195 + 16) = v474;
  uint64_t v197 = v468;
  uint64_t v196 = v469;
  id v198 = v473;
  *(void *)(v195 + 32) = v469;
  *(void *)(v195 + 40) = v198;
  *(void *)(v195 + 48) = v472;
  id v199 = v464;
  *(void *)(v195 + 64) = v176;
  *(void *)(v195 + 72) = v199;
  *(void *)(v195 + 80) = 0x6D756964654DLL;
  *(void *)(v195 + 88) = 0xE600000000000000;
  *(void *)(v195 + 104) = v176;
  *(void *)(v195 + 112) = v197;
  uint64_t v200 = swift_allocObject();
  *(_OWORD *)(v200 + 16) = xmmword_23C6F8470;
  id v460 = v196;
  id v459 = v199;
  id v458 = v197;
  uint64_t v201 = sub_23C6D55A8();
  uint64_t v203 = v202;
  uint64_t v204 = sub_23C6D55A8();
  uint64_t v206 = v205;
  uint64_t v207 = v187;
  sub_23C6D46B8();
  id v208 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v209 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v210 = v207;
  uint64_t v211 = v207;
  uint64_t v212 = v188;
  *(void *)(v200 + 32) = sub_23C41B6F8(v201, v203, v204, v206, 0, 0, v211, v188);
  uint64_t v213 = sub_23C6D55A8();
  uint64_t v215 = v214;
  uint64_t v216 = sub_23C6D55A8();
  uint64_t v218 = v217;
  uint64_t v219 = v210;
  sub_23C6D46B8();
  id v220 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v221 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v200 + 40) = sub_23C41B6F8(v213, v215, v216, v218, 0, 0, v219, v212);
  uint64_t v222 = sub_23C6D55A8();
  uint64_t v224 = v223;
  uint64_t v225 = sub_23C6D55A8();
  uint64_t v227 = v226;
  sub_23C6D46B8();
  id v228 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v229 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v200 + 48) = sub_23C41B6F8(v222, v224, v225, v227, 0, 0, v219, v212);
  uint64_t v494 = v200;
  sub_23C6D56B8();
  *(void *)(v195 + 120) = v494;
  uint64_t v230 = v462;
  uint64_t v231 = v463;
  *(void *)(v195 + 144) = v470;
  *(void *)(v195 + 152) = v230;
  *(void *)(v195 + 160) = 0xD000000000000019;
  *(void *)(v195 + 168) = 0x800000023C728830;
  *(void *)(v195 + 184) = MEMORY[0x263F8D310];
  *(void *)(v195 + 192) = v231;
  id v464 = v230;
  id v463 = v231;
  uint64_t v232 = sub_23C6D55A8();
  uint64_t v234 = v233;
  uint64_t v235 = sub_23C6D55A8();
  uint64_t v237 = v236;
  sub_23C6D46B8();
  id v238 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v239 = v212;
  sub_23C6D4598();

  id v240 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v241 = v219;
  uint64_t v242 = v219;
  uint64_t v243 = v239;
  *(void *)(v195 + 200) = sub_23C41B6F8(v232, v234, v235, v237, 0, 0, v241, v239);
  uint64_t v244 = v461;
  *(void *)(v195 + 224) = v492;
  *(void *)(v195 + 232) = v244;
  id v469 = (id)__swift_instantiateConcreteTypeFromMangledName(&qword_268BA6590);
  uint64_t v245 = swift_allocObject();
  *(_OWORD *)(v245 + 16) = v486;
  id v462 = v244;
  uint64_t v246 = MEMORY[0x263F8D310];
  *(void *)(v245 + 32) = sub_23C6D5428();
  id v468 = (id)__swift_instantiateConcreteTypeFromMangledName(&qword_268BA6598);
  *(void *)(v195 + 264) = v468;
  *(void *)(v195 + 240) = v245;
  uint64_t v247 = sub_23C6D5428();
  id v248 = sub_23C41A0C0(v247);
  *(void *)(v491 + 40) = v248;
  uint64_t v249 = swift_allocObject();
  *(_OWORD *)(v249 + 16) = v474;
  id v251 = v459;
  id v250 = v460;
  id v252 = v473;
  *(void *)(v249 + 32) = v460;
  *(void *)(v249 + 40) = v252;
  *(void *)(v249 + 48) = v472;
  *(void *)(v249 + 64) = v246;
  *(void *)(v249 + 72) = v251;
  *(void *)(v249 + 80) = 0x74726F6853;
  *(void *)(v249 + 88) = 0xE500000000000000;
  *(void *)(v249 + 104) = v246;
  id v253 = v458;
  *(void *)(v249 + 112) = v458;
  v473 = (_OWORD *)swift_allocObject();
  v473[1] = xmmword_23C6FCAB0;
  *(void *)&long long v474 = v250;
  id v254 = v251;
  id v255 = v253;
  uint64_t v256 = sub_23C6D55A8();
  uint64_t v258 = v257;
  uint64_t v259 = sub_23C6D55A8();
  uint64_t v261 = v260;
  sub_23C6D46B8();
  id v262 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v263 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v264 = v261;
  uint64_t v265 = v242;
  id v266 = sub_23C41B6F8(v256, v258, v259, v264, 0, 0, v242, v239);
  unsigned int v267 = v473;
  *((void *)v473 + 4) = v266;
  uint64_t v268 = sub_23C6D55A8();
  uint64_t v270 = v269;
  uint64_t v271 = sub_23C6D55A8();
  uint64_t v273 = v272;
  uint64_t v274 = v265;
  sub_23C6D46B8();
  id v275 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v276 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v277 = v274;
  *((void *)v267 + 5) = sub_23C41B6F8(v268, v270, v271, v273, 0, 0, v274, v243);
  uint64_t v278 = v267;
  uint64_t v279 = sub_23C6D55A8();
  uint64_t v281 = v280;
  uint64_t v282 = sub_23C6D55A8();
  uint64_t v284 = v283;
  uint64_t v285 = v277;
  sub_23C6D46B8();
  id v286 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v287 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v288 = v285;
  *((void *)v278 + 6) = sub_23C41B6F8(v279, v281, v282, v284, 0, 0, v285, v243);
  uint64_t v289 = (uint64_t)v278;
  uint64_t v290 = sub_23C6D55A8();
  uint64_t v292 = v291;
  uint64_t v293 = sub_23C6D55A8();
  uint64_t v295 = v294;
  uint64_t v296 = v288;
  sub_23C6D46B8();
  id v297 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v298 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v289 + 56) = sub_23C41B6F8(v290, v292, v293, v295, 0, 0, v296, v243);
  uint64_t v299 = sub_23C6D55A8();
  uint64_t v301 = v300;
  uint64_t v302 = sub_23C6D55A8();
  uint64_t v304 = v303;
  sub_23C6D46B8();
  id v305 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v306 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v307 = v243;
  *(void *)(v289 + 64) = sub_23C41B6F8(v299, v301, v302, v304, 0, 0, v296, v243);
  uint64_t v494 = v289;
  sub_23C6D56B8();
  *(void *)(v249 + 120) = v494;
  v309 = v463;
  v308 = v464;
  *(void *)(v249 + 144) = v470;
  *(void *)(v249 + 152) = v308;
  *(void *)(v249 + 160) = 0xD000000000000011;
  *(void *)(v249 + 168) = v465;
  *(void *)(v249 + 184) = MEMORY[0x263F8D310];
  *(void *)(v249 + 192) = v309;
  id v471 = v308;
  id v472 = v309;
  uint64_t v310 = sub_23C6D55A8();
  uint64_t v312 = v311;
  uint64_t v313 = sub_23C6D55A8();
  uint64_t v315 = v314;
  uint64_t v316 = v296;
  sub_23C6D46B8();
  id v317 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v318 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v249 + 200) = sub_23C41B6F8(v310, v312, v313, v315, 0, 0, v296, v307);
  v319 = v462;
  *(void *)(v249 + 224) = v492;
  *(void *)(v249 + 232) = v319;
  uint64_t v320 = swift_allocObject();
  *(_OWORD *)(v320 + 16) = v486;
  uint64_t v321 = swift_allocObject();
  *(_OWORD *)(v321 + 16) = v466;
  strcpy((char *)(v321 + 32), "WFParameterKey");
  *(unsigned char *)(v321 + 47) = -18;
  unint64_t v322 = v479;
  *(void *)(v321 + 48) = 0xD000000000000011;
  *(void *)(v321 + 56) = v322;
  uint64_t v323 = MEMORY[0x263F8D310];
  *(void *)(v321 + 72) = MEMORY[0x263F8D310];
  *(void *)(v321 + 80) = 0xD000000000000011;
  *(void *)(v321 + 88) = v477;
  *(void *)(v321 + 96) = &unk_26EFFC270;
  *(void *)(v321 + 120) = v484;
  *(void *)(v321 + 128) = 0x72756F7365524657;
  *(void *)(v321 + 168) = v323;
  *(void *)(v321 + 136) = 0xEF7373616C436563;
  unint64_t v324 = v476;
  *(void *)(v321 + 144) = v481;
  *(void *)(v321 + 152) = v324;
  id v470 = v319;
  *(void *)(v320 + 32) = sub_23C6D5428();
  *(void *)(v249 + 264) = v475;
  *(void *)(v249 + 240) = v320;
  uint64_t v325 = sub_23C6D5428();
  id v326 = sub_23C41A0C0(v325);
  *(void *)(v491 + 48) = v326;
  uint64_t v327 = swift_allocObject();
  *(_OWORD *)(v327 + 16) = v487;
  v328 = (void *)v474;
  *(void *)(v327 + 32) = v474;
  *(void *)(v327 + 40) = 0xD000000000000011;
  *(void *)(v327 + 48) = 0x800000023C720610;
  v329 = v471;
  v330 = v472;
  *(void *)(v327 + 64) = v323;
  *(void *)(v327 + 72) = v329;
  v473 = (_OWORD *)0xD000000000000014;
  *(void *)(v327 + 80) = 0xD000000000000014;
  *(void *)(v327 + 88) = 0x800000023C728970;
  *(void *)(v327 + 104) = v323;
  *(void *)(v327 + 112) = v330;
  *(void *)&long long v466 = v328;
  id v464 = v329;
  id v465 = v330;
  uint64_t v331 = sub_23C6D55A8();
  uint64_t v333 = v332;
  uint64_t v334 = sub_23C6D55A8();
  uint64_t v336 = v335;
  sub_23C6D46B8();
  id v337 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v338 = v480;
  sub_23C6D4598();

  id v339 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v340 = v316;
  *(void *)(v327 + 120) = sub_23C41B6F8(v331, v333, v334, v336, 0, 0, v316, v338);
  uint64_t v341 = v492;
  v342 = v470;
  *(void *)(v327 + 144) = v492;
  *(void *)(v327 + 152) = v342;
  uint64_t v343 = swift_allocObject();
  *(_OWORD *)(v343 + 16) = v486;
  *(void *)&long long v474 = v342;
  uint64_t v344 = MEMORY[0x263F8D310];
  *(void *)(v343 + 32) = sub_23C6D5428();
  *(void *)(v327 + 184) = v468;
  *(void *)(v327 + 160) = v343;
  uint64_t v345 = sub_23C6D5428();
  id v346 = sub_23C41A0C0(v345);
  *(void *)(v491 + 56) = v346;
  uint64_t v347 = swift_allocObject();
  *(_OWORD *)(v347 + 16) = v487;
  v348 = (void *)v466;
  unint64_t v349 = v481;
  *(void *)(v347 + 32) = v466;
  *(void *)(v347 + 40) = v349;
  *(void *)(v347 + 48) = 0x800000023C7289E0;
  v350 = v464;
  *(void *)(v347 + 64) = v344;
  *(void *)(v347 + 72) = v350;
  strcpy((char *)(v347 + 80), "WFDateFormat");
  *(unsigned char *)(v347 + 93) = 0;
  *(_WORD *)(v347 + 94) = -5120;
  *(void *)(v347 + 104) = v344;
  v351 = v465;
  *(void *)(v347 + 112) = v465;
  id v471 = v348;
  id v472 = v350;
  id v470 = v351;
  uint64_t v352 = sub_23C6D55A8();
  uint64_t v354 = v353;
  uint64_t v355 = sub_23C6D55A8();
  uint64_t v357 = v356;
  sub_23C6D46B8();
  id v358 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v359 = v480;
  sub_23C6D4598();

  id v360 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v361 = v354;
  uint64_t v362 = v359;
  *(void *)(v347 + 120) = sub_23C41B6F8(v352, v361, v355, v357, 0, 0, v340, v359);
  v363 = (void *)v474;
  *(void *)(v347 + 144) = v341;
  *(void *)(v347 + 152) = v363;
  uint64_t v364 = swift_allocObject();
  *(_OWORD *)(v364 + 16) = v486;
  *(void *)&long long v474 = v363;
  uint64_t v365 = MEMORY[0x263F8D310];
  *(void *)(v364 + 32) = sub_23C6D5428();
  *(void *)(v347 + 184) = v468;
  *(void *)(v347 + 160) = v364;
  uint64_t v366 = sub_23C6D5428();
  id v367 = sub_23C41A0C0(v366);
  *(void *)(v491 + 64) = v367;
  uint64_t v368 = swift_allocObject();
  *(_OWORD *)(v368 + 16) = xmmword_23C6F8490;
  v369 = v471;
  v370 = v472;
  v371 = v473;
  *(void *)(v368 + 32) = v471;
  *(void *)(v368 + 40) = v371;
  *(void *)(v368 + 48) = 0x800000023C71F920;
  *(void *)(v368 + 64) = v365;
  *(void *)(v368 + 72) = v370;
  *(void *)(v368 + 80) = 0x657461444657;
  *(void *)(v368 + 88) = 0xE600000000000000;
  *(void *)(v368 + 104) = v365;
  v372 = v470;
  *(void *)(v368 + 112) = v470;
  id v471 = v369;
  id v472 = v370;
  v473 = v372;
  uint64_t v373 = sub_23C6D55A8();
  uint64_t v375 = v374;
  uint64_t v376 = sub_23C6D55A8();
  uint64_t v378 = v377;
  sub_23C6D46B8();
  id v379 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v380 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v381 = v378;
  uint64_t v382 = v340;
  *(void *)(v368 + 120) = sub_23C41B6F8(v373, v375, v376, v381, 0, 0, v340, v359);
  v383 = (void *)*MEMORY[0x263F87380];
  uint64_t v384 = v492;
  *(void *)(v368 + 144) = v492;
  *(void *)(v368 + 152) = v383;
  id v385 = v383;
  uint64_t v386 = sub_23C6D55A8();
  uint64_t v388 = v387;
  uint64_t v389 = sub_23C6D55A8();
  uint64_t v391 = v390;
  sub_23C6D46B8();
  id v392 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v393 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v394 = v382;
  *(void *)(v368 + 160) = sub_23C41B6F8(v386, v388, v389, v391, 0, 0, v382, v362);
  v395 = (void *)*MEMORY[0x263F87398];
  *(void *)(v368 + 184) = v384;
  *(void *)(v368 + 192) = v395;
  uint64_t v396 = v384;
  id v397 = v395;
  uint64_t v398 = sub_23C6D55A8();
  uint64_t v400 = v399;
  uint64_t v401 = sub_23C6D55A8();
  uint64_t v403 = v402;
  uint64_t v404 = v394;
  sub_23C6D46B8();
  id v405 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v406 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v407 = v404;
  id v408 = sub_23C41B6F8(v398, v400, v401, v403, 0, 0, v404, v362);
  *(void *)(v368 + 224) = v396;
  *(void *)(v368 + 200) = v408;
  uint64_t v409 = sub_23C6D5428();
  id v410 = sub_23C41A0C0(v409);
  *(void *)(v491 + 72) = v410;
  uint64_t v411 = swift_allocObject();
  *(_OWORD *)(v411 + 16) = v487;
  v412 = v471;
  v413 = v472;
  *(void *)(v411 + 32) = v471;
  *(void *)(v411 + 40) = 0xD000000000000017;
  *(void *)(v411 + 48) = 0x800000023C728AB0;
  uint64_t v414 = MEMORY[0x263F8D310];
  *(void *)(v411 + 64) = MEMORY[0x263F8D310];
  *(void *)(v411 + 72) = v413;
  *(void *)(v411 + 80) = 0x656C61636F4C4657;
  *(void *)(v411 + 88) = 0xE800000000000000;
  v415 = v473;
  *(void *)(v411 + 104) = v414;
  *(void *)(v411 + 112) = v415;
  id v416 = v412;
  id v417 = v413;
  id v418 = v415;
  uint64_t v419 = sub_23C6D55A8();
  uint64_t v421 = v420;
  uint64_t v422 = sub_23C6D55A8();
  uint64_t v424 = v423;
  uint64_t v425 = v407;
  sub_23C6D46B8();
  id v426 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v427 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v411 + 120) = sub_23C41B6F8(v419, v421, v422, v424, 0, 0, v425, v362);
  v428 = (void *)v474;
  *(void *)(v411 + 144) = v492;
  *(void *)(v411 + 152) = v428;
  uint64_t v429 = swift_allocObject();
  *(_OWORD *)(v429 + 16) = v486;
  uint64_t v430 = swift_allocObject();
  *(_OWORD *)(v430 + 16) = v487;
  strcpy((char *)(v430 + 32), "WFParameterKey");
  *(unsigned char *)(v430 + 47) = -18;
  unint64_t v431 = v479;
  *(void *)(v430 + 48) = 0xD000000000000011;
  *(void *)(v430 + 56) = v431;
  *(void *)(v430 + 72) = v414;
  *(void *)(v430 + 80) = 0xD000000000000013;
  *(void *)(v430 + 88) = 0x800000023C71D870;
  *(void *)(v430 + 96) = 15649;
  *(void *)(v430 + 104) = 0xE200000000000000;
  *(void *)(v430 + 120) = v414;
  *(void *)(v430 + 128) = 0xD000000000000011;
  *(void *)(v430 + 136) = v477;
  *(void *)(v430 + 144) = &unk_26EFFC3E0;
  *(void *)(v430 + 168) = v484;
  *(void *)(v430 + 176) = 0x72756F7365524657;
  *(void *)(v430 + 216) = v414;
  *(void *)(v430 + 184) = 0xEF7373616C436563;
  unint64_t v432 = v476;
  *(void *)(v430 + 192) = v481;
  *(void *)(v430 + 200) = v432;
  id v433 = v428;
  *(void *)(v429 + 32) = sub_23C6D5428();
  *(void *)(v411 + 184) = v475;
  *(void *)(v411 + 160) = v429;
  uint64_t v434 = sub_23C6D5428();
  id v435 = sub_23C41A0C0(v434);
  uint64_t v436 = v491;
  *(void *)(v491 + 80) = v435;
  uint64_t v494 = v436;
  sub_23C6D56B8();
  uint64_t v437 = v494;
  uint64_t v438 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F20);
  v439 = v482;
  v482[50] = v437;
  v440 = (void *)*MEMORY[0x263F87128];
  v439[53] = v438;
  v439[54] = v440;
  id v441 = v440;
  uint64_t v442 = sub_23C6D55A8();
  uint64_t v444 = v443;
  uint64_t v445 = sub_23C6D55A8();
  uint64_t v447 = v446;
  sub_23C6D46B8();
  id v448 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v449 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v450 = sub_23C41B6F8(v442, v444, v445, v447, 0, 0, v425, v362);
  id v451 = objc_msgSend(objc_allocWithZone(MEMORY[0x263F86888]), sel_initWithString_, v450);

  uint64_t v452 = sub_23C369F80(0, &qword_268BA5D08);
  v453 = (void **)MEMORY[0x263F87108];
  v439[55] = v451;
  v454 = *v453;
  v439[58] = v452;
  v439[59] = v454;
  v439[63] = MEMORY[0x263F8D4F8];
  *((unsigned char *)v439 + 480) = 1;
  type metadata accessor for Key(0);
  sub_23C375C5C((unint64_t *)&qword_26AEEE8F0, type metadata accessor for Key);
  id v455 = v454;
  uint64_t v456 = sub_23C6D5428();
  return sub_23C41A1C0(v456);
}

uint64_t sub_23C406490()
{
  return sub_23C403D98();
}

uint64_t sub_23C4064B8()
{
  return MEMORY[0x270F86188](0xD000000000000022, 0x800000023C728B50, sub_23C4064EC, 0);
}

id sub_23C4064EC()
{
  uint64_t v0 = sub_23C6D45B8();
  MEMORY[0x270FA5388](v0 - 8);
  uint64_t v2 = (char *)&v178 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v3 = sub_23C6D46E8();
  MEMORY[0x270FA5388](v3 - 8);
  uint64_t v5 = (char *)&v178 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v185 = sub_23C369F80(0, (unint64_t *)&unk_268BA5C90);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEEE910);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_23C6FCAC0;
  uint64_t v7 = (void *)*MEMORY[0x263F870A0];
  uint64_t v8 = MEMORY[0x263F8D310];
  *(void *)(inited + 32) = *MEMORY[0x263F870A0];
  *(void *)(inited + 40) = 0xD000000000000015;
  *(void *)(inited + 48) = 0x800000023C728B80;
  uint64_t v9 = (void *)*MEMORY[0x263F87110];
  *(void *)(inited + 64) = v8;
  *(void *)(inited + 72) = v9;
  id v10 = v7;
  id v11 = v9;
  uint64_t v12 = sub_23C6D55A8();
  uint64_t v14 = v13;
  uint64_t v15 = sub_23C6D55A8();
  uint64_t v17 = v16;
  sub_23C6D46B8();
  if (qword_268BA5B80 != -1) {
    swift_once();
  }
  id v18 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v19 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v20 = sub_23C41B6F8(v12, v14, v15, v17, 0, 0, (uint64_t)v5, (uint64_t)v2);
  uint64_t v21 = sub_23C369F80(0, (unint64_t *)&unk_268BA5CA0);
  *(void *)(inited + 80) = v20;
  uint64_t v22 = (void *)*MEMORY[0x263F87090];
  *(void *)(inited + 104) = v21;
  *(void *)(inited + 112) = v22;
  id v23 = v22;
  uint64_t v24 = sub_23C6D5428();
  uint64_t v25 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA5CF8);
  *(void *)(inited + 120) = v24;
  id v26 = (void *)*MEMORY[0x263F87098];
  *(void *)(inited + 144) = v25;
  *(void *)(inited + 152) = v26;
  id v27 = v26;
  uint64_t v28 = sub_23C6D55A8();
  uint64_t v30 = v29;
  uint64_t v31 = sub_23C6D55A8();
  uint64_t v33 = v32;
  uint64_t v179 = v5;
  sub_23C6D46B8();
  id v34 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v35 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(inited + 160) = sub_23C41B6F8(v28, v30, v31, v33, 0, 0, (uint64_t)v5, (uint64_t)v2);
  uint64_t v36 = (void *)*MEMORY[0x263F87190];
  uint64_t v37 = v21;
  uint64_t v193 = v21;
  *(void *)(inited + 184) = v21;
  *(void *)(inited + 192) = v36;
  *(void *)&long long v192 = sub_23C369F80(0, (unint64_t *)&unk_268BA6EE0);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CB0);
  uint64_t v38 = swift_initStackObject();
  *(_OWORD *)(v38 + 16) = xmmword_23C6F6A70;
  uint64_t v39 = (uint64_t)v2;
  uint64_t v40 = (void *)*MEMORY[0x263F871A8];
  *(void *)(v38 + 32) = *MEMORY[0x263F871A8];
  id v41 = v36;
  id v42 = v40;
  uint64_t v194 = sub_23C6D55A8();
  uint64_t v44 = v43;
  uint64_t v45 = sub_23C6D55A8();
  uint64_t v47 = v46;
  uint64_t v48 = (uint64_t)v179;
  sub_23C6D46B8();
  id v49 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v184 = v39;
  sub_23C6D4598();

  id v50 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v51 = sub_23C41B6F8(v194, v44, v45, v47, 0, 0, v48, v39);
  *(void *)(v38 + 64) = v37;
  *(void *)(v38 + 40) = v51;
  type metadata accessor for DescriptionKey(0);
  sub_23C375C5C((unint64_t *)&unk_268BA6EF0, type metadata accessor for DescriptionKey);
  uint64_t v194 = MEMORY[0x263F8EE58] + 8;
  uint64_t v52 = sub_23C6D5428();
  uint64_t v53 = v192;
  *(void *)(inited + 200) = sub_23C41A078(v52);
  v54 = (void *)*MEMORY[0x263F870D8];
  *(void *)(inited + 224) = v53;
  *(void *)(inited + 232) = v54;
  strcpy((char *)(inited + 240), "TranslateApp");
  *(unsigned char *)(inited + 253) = 0;
  *(_WORD *)(inited + 254) = -5120;
  uint64_t v55 = (void *)*MEMORY[0x263F87220];
  uint64_t v56 = MEMORY[0x263F8D310];
  *(void *)(inited + 264) = MEMORY[0x263F8D310];
  *(void *)(inited + 272) = v55;
  uint64_t v190 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CC0);
  uint64_t v57 = swift_initStackObject();
  long long v192 = xmmword_23C6F6A80;
  *(_OWORD *)(v57 + 16) = xmmword_23C6F6A80;
  uint64_t v58 = v48;
  *(void *)(v57 + 32) = 0x656C7069746C754DLL;
  *(void *)(v57 + 40) = 0xE800000000000000;
  uint64_t v59 = MEMORY[0x263F8D4F8];
  *(unsigned char *)(v57 + 48) = 1;
  *(void *)(v57 + 72) = v59;
  strcpy((char *)(v57 + 80), "ParameterKey");
  *(unsigned char *)(v57 + 93) = 0;
  *(_WORD *)(v57 + 94) = -5120;
  *(void *)(v57 + 96) = 0x547475706E494657;
  *(void *)(v57 + 104) = 0xEB00000000747865;
  *(void *)(v57 + 120) = v56;
  *(void *)(v57 + 128) = 0x6465726975716552;
  *(void *)(v57 + 136) = 0xE800000000000000;
  *(unsigned char *)(v57 + 144) = 1;
  *(void *)(v57 + 168) = v59;
  *(void *)(v57 + 176) = 0x7365707954;
  uint64_t v60 = v59;
  *(void *)(v57 + 184) = 0xE500000000000000;
  uint64_t v189 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F00);
  *(void *)(v57 + 216) = v189;
  *(void *)(v57 + 192) = &unk_26EFFC460;
  id v61 = v54;
  id v62 = v55;
  uint64_t v63 = sub_23C6D5428();
  uint64_t v64 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA5CD0);
  uint64_t v191 = v64;
  *(void *)(inited + 280) = v63;
  id v65 = (void *)*MEMORY[0x263F87228];
  *(void *)(inited + 304) = v64;
  *(void *)(inited + 312) = v65;
  *(unsigned char *)(inited + 320) = 0;
  id v66 = (void *)*MEMORY[0x263F87120];
  *(void *)(inited + 344) = v60;
  *(void *)(inited + 352) = v66;
  id v67 = v65;
  id v68 = v66;
  uint64_t v69 = sub_23C6D55A8();
  uint64_t v71 = v70;
  uint64_t v72 = sub_23C6D55A8();
  uint64_t v74 = v73;
  sub_23C6D46B8();
  id v75 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v76 = v184;
  sub_23C6D4598();

  id v77 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v78 = v74;
  uint64_t v79 = v58;
  *(void *)(inited + 360) = sub_23C41B6F8(v69, v71, v72, v78, 0, 0, v58, v76);
  id v80 = (void *)*MEMORY[0x263F872B0];
  uint64_t v81 = v193;
  *(void *)(inited + 384) = v193;
  *(void *)(inited + 392) = v80;
  uint64_t v82 = swift_allocObject();
  *(_OWORD *)(v82 + 16) = v192;
  *(void *)(v82 + 32) = 0x75736F6C63736944;
  *(void *)(v82 + 40) = 0xEF6C6576654C6572;
  *(void *)(v82 + 48) = 0x63696C627550;
  *(void *)(v82 + 56) = 0xE600000000000000;
  *(void *)(v82 + 72) = MEMORY[0x263F8D310];
  *(void *)(v82 + 80) = 0x656C7069746C754DLL;
  *(void *)(v82 + 88) = 0xE800000000000000;
  *(unsigned char *)(v82 + 96) = 1;
  *(void *)(v82 + 120) = MEMORY[0x263F8D4F8];
  *(void *)(v82 + 128) = 0x614E74757074754FLL;
  *(void *)(v82 + 136) = 0xEA0000000000656DLL;
  id v83 = v80;
  uint64_t v190 = sub_23C6D55A8();
  uint64_t v85 = v84;
  uint64_t v86 = sub_23C6D55A8();
  uint64_t v88 = v87;
  sub_23C6D46B8();
  id v89 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v90 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v91 = v86;
  uint64_t v92 = v76;
  *(void *)(v82 + 144) = sub_23C41B6F8(v190, v85, v91, v88, 0, 0, v79, v76);
  *(void *)(v82 + 168) = v81;
  *(void *)(v82 + 176) = 0x7365707954;
  *(void *)(v82 + 216) = v189;
  *(void *)(v82 + 184) = 0xE500000000000000;
  *(void *)(v82 + 192) = &unk_26EFFC490;
  uint64_t v93 = MEMORY[0x263F8D310];
  *(void *)(inited + 400) = sub_23C6D5428();
  uint64_t v94 = (void *)*MEMORY[0x263F87130];
  *(void *)(inited + 424) = v191;
  *(void *)(inited + 432) = v94;
  __swift_instantiateConcreteTypeFromMangledName(&qword_268BA6C30);
  uint64_t v191 = swift_allocObject();
  *(_OWORD *)(v191 + 16) = xmmword_23C6F8470;
  uint64_t v190 = sub_23C369F80(0, &qword_268BA5CE0);
  uint64_t v188 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CE8);
  uint64_t v95 = swift_allocObject();
  *(_OWORD *)(v95 + 16) = v192;
  uint64_t v96 = (void *)*MEMORY[0x263F872D8];
  *(void *)(v95 + 32) = *MEMORY[0x263F872D8];
  *(void *)(v95 + 40) = 0xD000000000000026;
  id v183 = (id)0x800000023C728CB0;
  *(void *)(v95 + 48) = 0x800000023C728CB0;
  uint64_t v97 = (void *)*MEMORY[0x263F87350];
  uint64_t v98 = v93;
  *(void *)(v95 + 64) = v93;
  *(void *)(v95 + 72) = v97;
  *(void *)(v95 + 80) = 0xD000000000000016;
  *(void *)(v95 + 88) = 0x800000023C728CE0;
  uint64_t v99 = (void *)*MEMORY[0x263F87360];
  *(void *)(v95 + 104) = v98;
  *(void *)(v95 + 112) = v99;
  id v100 = v94;
  id v181 = v96;
  id v180 = v97;
  id v182 = v99;
  uint64_t v101 = sub_23C6D55A8();
  uint64_t v103 = v102;
  uint64_t v104 = sub_23C6D55A8();
  uint64_t v106 = v105;
  sub_23C6D46B8();
  id v107 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v108 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v109 = sub_23C41B6F8(v101, v103, v104, v106, 0, 0, v79, v92);
  *(void *)(v95 + 144) = v193;
  *(void *)(v95 + 120) = v109;
  *(void *)(v95 + 152) = sub_23C6D5528();
  *(void *)(v95 + 184) = MEMORY[0x263F8D4F8];
  *(unsigned char *)(v95 + 160) = 1;
  _s3__C3KeyVMa_0(0);
  uint64_t v187 = v110;
  uint64_t v186 = sub_23C375C5C(&qword_26AEEE340, _s3__C3KeyVMa_0);
  uint64_t v111 = sub_23C6D5428();
  id v112 = sub_23C41A0C0(v111);
  *(void *)(v191 + 32) = v112;
  uint64_t v113 = swift_allocObject();
  *(_OWORD *)(v113 + 16) = xmmword_23C6F6AA0;
  uint64_t v115 = v180;
  uint64_t v114 = v181;
  *(void *)(v113 + 32) = v181;
  *(void *)(v113 + 40) = 0xD000000000000026;
  uint64_t v116 = v182;
  *(void *)(v113 + 48) = v183;
  uint64_t v117 = MEMORY[0x263F8D310];
  *(void *)(v113 + 64) = MEMORY[0x263F8D310];
  *(void *)(v113 + 72) = v115;
  *(void *)(v113 + 80) = 0xD000000000000012;
  *(void *)(v113 + 88) = 0x800000023C728D50;
  *(void *)(v113 + 104) = v117;
  *(void *)(v113 + 112) = v116;
  id v181 = v114;
  id v183 = v115;
  id v182 = v116;
  uint64_t v118 = sub_23C6D55A8();
  uint64_t v120 = v119;
  uint64_t v121 = sub_23C6D55A8();
  uint64_t v123 = v122;
  uint64_t v124 = v79;
  sub_23C6D46B8();
  id v125 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v126 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v127 = sub_23C41B6F8(v118, v120, v121, v123, 0, 0, v124, v92);
  *(void *)(v113 + 144) = v193;
  *(void *)(v113 + 120) = v127;
  uint64_t v128 = sub_23C6D5428();
  id v129 = sub_23C41A0C0(v128);
  *(void *)(v191 + 40) = v129;
  uint64_t v130 = swift_allocObject();
  *(_OWORD *)(v130 + 16) = v192;
  uint64_t v131 = v181;
  *(void *)(v130 + 32) = v181;
  *(void *)(v130 + 40) = 0xD000000000000014;
  *(void *)(v130 + 48) = 0x800000023C71E2F0;
  uint64_t v132 = MEMORY[0x263F8D310];
  uint64_t v134 = v182;
  uint64_t v133 = v183;
  *(void *)(v130 + 64) = MEMORY[0x263F8D310];
  *(void *)(v130 + 72) = v133;
  *(void *)(v130 + 80) = 0x547475706E494657;
  *(void *)(v130 + 88) = 0xEB00000000747865;
  *(void *)(v130 + 104) = v132;
  *(void *)(v130 + 112) = v134;
  id v135 = v131;
  id v136 = v133;
  id v137 = v134;
  uint64_t v138 = sub_23C6D55A8();
  uint64_t v140 = v139;
  uint64_t v141 = sub_23C6D55A8();
  uint64_t v143 = v142;
  uint64_t v144 = v124;
  sub_23C6D46B8();
  id v145 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v146 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v147 = sub_23C41B6F8(v138, v140, v141, v143, 0, 0, v144, v92);
  uint64_t v148 = (void **)MEMORY[0x263F87378];
  *(void *)(v130 + 120) = v147;
  uint64_t v149 = *v148;
  *(void *)(v130 + 144) = v193;
  *(void *)(v130 + 152) = v149;
  *(void *)(v130 + 184) = MEMORY[0x263F8D4F8];
  *(unsigned char *)(v130 + 160) = 1;
  id v150 = v149;
  uint64_t v151 = sub_23C6D5428();
  id v152 = sub_23C41A0C0(v151);
  uint64_t v153 = v191;
  *(void *)(v191 + 48) = v152;
  uint64_t v195 = v153;
  sub_23C6D56B8();
  uint64_t v154 = v195;
  uint64_t v155 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F20);
  *(void *)(inited + 440) = v154;
  uint64_t v156 = (void *)*MEMORY[0x263F87128];
  *(void *)(inited + 464) = v155;
  *(void *)(inited + 472) = v156;
  id v157 = v156;
  uint64_t v158 = sub_23C6D55A8();
  uint64_t v160 = v159;
  uint64_t v161 = sub_23C6D55A8();
  uint64_t v163 = v162;
  sub_23C6D46B8();
  id v164 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v165 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v166 = sub_23C41B6F8(v158, v160, v161, v163, 0, 0, v144, v92);
  id v167 = objc_msgSend(objc_allocWithZone(MEMORY[0x263F86888]), sel_initWithString_, v166);

  uint64_t v168 = sub_23C369F80(0, &qword_268BA5D08);
  *(void *)(inited + 480) = v167;
  id v169 = (void *)*MEMORY[0x263F87140];
  *(void *)(inited + 504) = v168;
  *(void *)(inited + 512) = v169;
  uint64_t v170 = v189;
  *(void *)(inited + 544) = v189;
  *(void *)(inited + 520) = &unk_26EFFC4C0;
  uint64_t v171 = (void *)*MEMORY[0x263F873E8];
  *(void *)(inited + 552) = *MEMORY[0x263F873E8];
  *(void *)(inited + 584) = v170;
  *(void *)(inited + 560) = &unk_26EFFC4F0;
  uint64_t v172 = (void *)*MEMORY[0x263F87108];
  *(void *)(inited + 592) = *MEMORY[0x263F87108];
  *(void *)(inited + 624) = MEMORY[0x263F8D4F8];
  *(unsigned char *)(inited + 600) = 0;
  type metadata accessor for Key(0);
  sub_23C375C5C((unint64_t *)&qword_26AEEE8F0, type metadata accessor for Key);
  id v173 = v169;
  id v174 = v171;
  id v175 = v172;
  uint64_t v176 = sub_23C6D5428();
  return sub_23C41A1C0(v176);
}

uint64_t sub_23C4074E8()
{
  return sub_23C4064B8();
}

uint64_t sub_23C407510()
{
  return MEMORY[0x270F86188](0xD00000000000001ALL, 0x800000023C728E90, sub_23C407544, 0);
}

id sub_23C407544()
{
  uint64_t v92 = sub_23C6D4C28();
  uint64_t v90 = *(void *)(v92 - 8);
  MEMORY[0x270FA5388](v92);
  uint64_t v93 = (uint64_t *)((char *)&v87 - ((v0 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v1 = sub_23C6D45B8();
  MEMORY[0x270FA5388](v1 - 8);
  uint64_t v3 = (char *)&v87 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v4 = sub_23C6D46E8();
  MEMORY[0x270FA5388](v4 - 8);
  uint64_t v6 = (char *)&v87 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v91 = sub_23C369F80(0, (unint64_t *)&unk_268BA5C90);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEEE910);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_23C6F77D0;
  uint64_t v8 = (void *)*MEMORY[0x263F870A0];
  uint64_t v9 = MEMORY[0x263F8D310];
  *(void *)(inited + 32) = *MEMORY[0x263F870A0];
  *(void *)(inited + 40) = 0xD000000000000012;
  *(void *)(inited + 48) = 0x800000023C71E130;
  id v10 = (void *)*MEMORY[0x263F87110];
  *(void *)(inited + 64) = v9;
  *(void *)(inited + 72) = v10;
  id v11 = v8;
  id v12 = v10;
  uint64_t v13 = sub_23C6D55A8();
  uint64_t v15 = v14;
  uint64_t v16 = sub_23C6D55A8();
  uint64_t v18 = v17;
  sub_23C6D46B8();
  if (qword_268BA5B80 != -1) {
    swift_once();
  }
  id v19 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v20 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v21 = sub_23C41B6F8(v13, v15, v16, v18, 0, 0, (uint64_t)v6, (uint64_t)v3);
  uint64_t v22 = sub_23C369F80(0, (unint64_t *)&unk_268BA5CA0);
  uint64_t v94 = v22;
  *(void *)(inited + 80) = v21;
  id v23 = (void *)*MEMORY[0x263F87190];
  *(void *)(inited + 104) = v22;
  *(void *)(inited + 112) = v23;
  uint64_t v87 = sub_23C369F80(0, (unint64_t *)&unk_268BA6EE0);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CB0);
  uint64_t v24 = swift_initStackObject();
  *(_OWORD *)(v24 + 16) = xmmword_23C6F6A70;
  uint64_t v25 = (void *)*MEMORY[0x263F871A8];
  *(void *)(v24 + 32) = *MEMORY[0x263F871A8];
  id v26 = v23;
  id v27 = v25;
  uint64_t v28 = sub_23C6D55A8();
  uint64_t v30 = v29;
  uint64_t v31 = sub_23C6D55A8();
  uint64_t v33 = v32;
  sub_23C6D46B8();
  uint64_t v34 = (uint64_t)v6;
  id v35 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v88 = v3;
  sub_23C6D4598();

  id v36 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v37 = v34;
  id v38 = sub_23C41B6F8(v28, v30, v31, v33, 0, 0, v34, (uint64_t)v3);
  *(void *)(v24 + 64) = v94;
  *(void *)(v24 + 40) = v38;
  type metadata accessor for DescriptionKey(0);
  sub_23C36AF94((unint64_t *)&unk_268BA6EF0, type metadata accessor for DescriptionKey);
  uint64_t v89 = MEMORY[0x263F8EE58] + 8;
  uint64_t v39 = sub_23C6D5428();
  uint64_t v40 = v87;
  *(void *)(inited + 120) = sub_23C41A078(v39);
  id v41 = (void *)*MEMORY[0x263F870B0];
  *(void *)(inited + 144) = v40;
  *(void *)(inited + 152) = v41;
  uint64_t v42 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F00);
  *(void *)(inited + 160) = &unk_26EFFC520;
  uint64_t v43 = (void *)*MEMORY[0x263F870D0];
  *(void *)(inited + 184) = v42;
  *(void *)(inited + 192) = v43;
  *(void *)(inited + 200) = 2036429383;
  *(void *)(inited + 208) = 0xE400000000000000;
  uint64_t v44 = (void *)*MEMORY[0x263F870E8];
  uint64_t v45 = MEMORY[0x263F8D310];
  *(void *)(inited + 224) = MEMORY[0x263F8D310];
  *(void *)(inited + 232) = v44;
  *(void *)(inited + 240) = 0xD000000000000017;
  *(void *)(inited + 248) = 0x800000023C728EF0;
  uint64_t v46 = (void *)*MEMORY[0x263F87120];
  *(void *)(inited + 264) = v45;
  *(void *)(inited + 272) = v46;
  id v47 = v41;
  id v48 = v43;
  id v49 = v44;
  id v50 = v46;
  uint64_t v51 = sub_23C6D55A8();
  uint64_t v53 = v52;
  uint64_t v54 = sub_23C6D55A8();
  uint64_t v56 = v55;
  uint64_t v57 = v37;
  sub_23C6D46B8();
  id v58 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v59 = (uint64_t)v88;
  sub_23C6D4598();

  id v60 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v61 = v57;
  uint64_t v62 = v57;
  uint64_t v63 = v59;
  *(void *)(inited + 280) = sub_23C41B6F8(v51, v53, v54, v56, 0, 0, v62, v59);
  uint64_t v64 = (void *)*MEMORY[0x263F87128];
  *(void *)(inited + 304) = v94;
  *(void *)(inited + 312) = v64;
  id v65 = v64;
  uint64_t v66 = sub_23C6D55A8();
  uint64_t v68 = v67;
  uint64_t v69 = sub_23C6D55A8();
  uint64_t v71 = v70;
  uint64_t v72 = v61;
  sub_23C6D46B8();
  id v73 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v74 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v75 = sub_23C41B6F8(v66, v68, v69, v71, 0, 0, v72, v63);
  id v76 = objc_msgSend(objc_allocWithZone(MEMORY[0x263F86888]), sel_initWithString_, v75);

  uint64_t v77 = sub_23C369F80(0, &qword_268BA5D08);
  *(void *)(inited + 320) = v76;
  uint64_t v78 = (void *)*MEMORY[0x263F873E8];
  *(void *)(inited + 344) = v77;
  *(void *)(inited + 352) = v78;
  __swift_instantiateConcreteTypeFromMangledName(&qword_268BA6C30);
  uint64_t v79 = swift_allocObject();
  *(_OWORD *)(v79 + 16) = xmmword_23C6F77E0;
  uint64_t v80 = v92;
  uint64_t v81 = v93;
  *uint64_t v93 = 2;
  (*(void (**)(void *, void, uint64_t))(v90 + 104))(v81, *MEMORY[0x263F866D0], v80);
  id v82 = objc_allocWithZone((Class)sub_23C6D4C48());
  id v83 = v78;
  *(void *)(v79 + 32) = sub_23C6D4C38();
  uint64_t v95 = v79;
  sub_23C6D56B8();
  uint64_t v84 = v95;
  *(void *)(inited + 384) = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA60A0);
  *(void *)(inited + 360) = v84;
  type metadata accessor for Key(0);
  sub_23C36AF94((unint64_t *)&qword_26AEEE8F0, type metadata accessor for Key);
  uint64_t v85 = sub_23C6D5428();
  return sub_23C41A1C0(v85);
}

uint64_t sub_23C407CF0()
{
  return sub_23C407510();
}

unint64_t StaticString._asString.getter(unint64_t result, uint64_t a2, char a3)
{
  if ((a3 & 1) == 0)
  {
    if (result) {
      return sub_23C6D55A8();
    }
    __break(1u);
  }
  if (HIDWORD(result))
  {
    __break(1u);
LABEL_11:
    __break(1u);
    return sub_23C6D55A8();
  }
  if (result >> 11 == 27) {
    goto LABEL_14;
  }
  if (WORD1(result) > 0x10u) {
    goto LABEL_11;
  }
  if ((result & 0xFFFFFF80) != 0 || result <= 0xFF) {
    return sub_23C6D55A8();
  }
  __break(1u);
LABEL_14:
  __break(1u);
  return result;
}

id static NSBundle._current.getter()
{
  if (qword_268BA5B80 != -1) {
    swift_once();
  }
  uint64_t v0 = (void *)qword_268BA7768;
  return v0;
}

id sub_23C407E84()
{
  _s2__CMa();
  uint64_t ObjCClassFromMetadata = swift_getObjCClassFromMetadata();
  id result = objc_msgSend(self, sel_bundleForClass_, ObjCClassFromMetadata);
  qword_268BA7768 = (uint64_t)result;
  return result;
}

uint64_t _s2__CMa()
{
  return self;
}

uint64_t sub_23C407F00()
{
  return MEMORY[0x270F86188](0xD000000000000021, 0x800000023C728FE0, sub_23C407F34, 0);
}

id sub_23C407F34()
{
  uint64_t v390 = sub_23C6D5268();
  uint64_t v393 = *(void *)(v390 - 8);
  MEMORY[0x270FA5388](v390);
  uint64_t v389 = (char *)&v358 - ((v0 + 15) & 0xFFFFFFFFFFFFFFF0);
  id v385 = (void *)sub_23C6D4C28();
  uint64_t v391 = *(v385 - 1);
  MEMORY[0x270FA5388](v385);
  id v367 = (uint64_t *)((char *)&v358 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v2 = sub_23C6D45B8();
  MEMORY[0x270FA5388](v2 - 8);
  uint64_t v4 = (char *)&v358 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v5 = sub_23C6D46E8();
  MEMORY[0x270FA5388](v5 - 8);
  uint64_t v7 = (char *)&v358 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v369 = sub_23C369F80(0, (unint64_t *)&unk_268BA5C90);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEEE910);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_23C6F8C40;
  uint64_t v9 = (void *)*MEMORY[0x263F870A0];
  uint64_t v10 = MEMORY[0x263F8D310];
  *(void *)(inited + 32) = *MEMORY[0x263F870A0];
  *(void *)(inited + 40) = 0xD000000000000014;
  uint64_t v376 = (objc_class *)0xD000000000000014;
  *(void *)(inited + 48) = 0x800000023C729010;
  id v11 = (void *)*MEMORY[0x263F87110];
  *(void *)(inited + 64) = v10;
  *(void *)(inited + 72) = v11;
  id v12 = (void *)inited;
  id v13 = v9;
  id v14 = v11;
  uint64_t v15 = sub_23C6D55A8();
  uint64_t v17 = v16;
  uint64_t v18 = sub_23C6D55A8();
  uint64_t v20 = v19;
  sub_23C6D46B8();
  if (qword_268BA5B80 != -1) {
    swift_once();
  }
  id v21 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v22 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v23 = sub_23C41B6F8(v15, v17, v18, v20, 0, 0, (uint64_t)v7, (uint64_t)v4);
  uint64_t v24 = sub_23C369F80(0, (unint64_t *)&unk_268BA5CA0);
  v12[10] = v23;
  uint64_t v25 = (void *)*MEMORY[0x263F87098];
  v12[13] = v24;
  v12[14] = v25;
  id v26 = v25;
  uint64_t v27 = sub_23C6D55A8();
  uint64_t v29 = v28;
  uint64_t v30 = sub_23C6D55A8();
  uint64_t v32 = v31;
  sub_23C6D46B8();
  id v33 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v34 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  v12[15] = sub_23C41B6F8(v27, v29, v30, v32, 0, 0, (uint64_t)v7, (uint64_t)v4);
  id v35 = (void *)*MEMORY[0x263F87190];
  uint64_t v402 = v24;
  v12[18] = v24;
  v12[19] = v35;
  uint64_t v399 = sub_23C369F80(0, (unint64_t *)&unk_268BA6EE0);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CB0);
  uint64_t v36 = swift_initStackObject();
  long long v368 = xmmword_23C6F6A70;
  *(_OWORD *)(v36 + 16) = xmmword_23C6F6A70;
  uint64_t v37 = (void *)*MEMORY[0x263F871A8];
  *(void *)(v36 + 32) = *MEMORY[0x263F871A8];
  id v38 = v35;
  id v39 = v37;
  uint64_t v40 = sub_23C6D55A8();
  uint64_t v400 = v41;
  uint64_t v42 = sub_23C6D55A8();
  uint64_t v44 = v43;
  sub_23C6D46B8();
  uint64_t v45 = (uint64_t)v7;
  id v46 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v401 = v4;
  sub_23C6D4598();

  id v47 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v48 = sub_23C41B6F8(v40, v400, v42, v44, 0, 0, v45, (uint64_t)v4);
  *(void *)(v36 + 64) = v24;
  *(void *)(v36 + 40) = v48;
  type metadata accessor for DescriptionKey(0);
  sub_23C375C5C((unint64_t *)&unk_268BA6EF0, type metadata accessor for DescriptionKey);
  uint64_t v400 = MEMORY[0x263F8EE58] + 8;
  uint64_t v49 = sub_23C6D5428();
  uint64_t v50 = v399;
  v12[20] = sub_23C41A078(v49);
  uint64_t v51 = (void *)*MEMORY[0x263F870B0];
  v12[23] = v50;
  v12[24] = v51;
  uint64_t v52 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F00);
  v12[25] = &unk_26EFFC550;
  uint64_t v53 = (void *)*MEMORY[0x263F870D8];
  v12[28] = v52;
  v12[29] = v53;
  uint64_t v54 = v52;
  id v383 = (id)v52;
  v12[30] = 0x657061706C6C6157;
  v12[31] = 0xE900000000000072;
  uint64_t v55 = (void *)*MEMORY[0x263F87220];
  uint64_t v56 = MEMORY[0x263F8D310];
  v12[33] = MEMORY[0x263F8D310];
  v12[34] = v55;
  uint64_t v388 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CC0);
  uint64_t v57 = swift_initStackObject();
  *(_OWORD *)(v57 + 16) = xmmword_23C6F6A80;
  *(void *)(v57 + 32) = 0x656C7069746C754DLL;
  *(void *)(v57 + 40) = 0xE800000000000000;
  uint64_t v58 = MEMORY[0x263F8D4F8];
  *(unsigned char *)(v57 + 48) = 0;
  *(void *)(v57 + 72) = v58;
  strcpy((char *)(v57 + 80), "ParameterKey");
  *(unsigned char *)(v57 + 93) = 0;
  *(_WORD *)(v57 + 94) = -5120;
  *(void *)(v57 + 96) = 0x7475706E494657;
  *(void *)(v57 + 104) = 0xE700000000000000;
  *(void *)(v57 + 120) = v56;
  *(void *)(v57 + 128) = 0x6465726975716552;
  *(void *)(v57 + 136) = 0xE800000000000000;
  *(unsigned char *)(v57 + 144) = 1;
  *(void *)(v57 + 168) = v58;
  *(void *)(v57 + 176) = 0x7365707954;
  *(void *)(v57 + 216) = v54;
  *(void *)(v57 + 184) = 0xE500000000000000;
  *(void *)(v57 + 192) = &unk_26EFFC580;
  id v59 = v51;
  id v60 = v53;
  id v61 = v55;
  uint64_t v62 = sub_23C6D5428();
  uint64_t v63 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA5CD0);
  uint64_t v387 = v63;
  v12[35] = v62;
  uint64_t v64 = (void *)*MEMORY[0x263F87120];
  v12[38] = v63;
  v12[39] = v64;
  id v65 = v64;
  uint64_t v66 = sub_23C6D55A8();
  uint64_t v68 = v67;
  uint64_t v69 = sub_23C6D55A8();
  uint64_t v71 = v70;
  sub_23C6D46B8();
  id v72 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v73 = (uint64_t)v401;
  sub_23C6D4598();

  id v74 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v75 = sub_23C41B6F8(v66, v68, v69, v71, 0, 0, v45, v73);
  uint64_t v384 = v12;
  v12[40] = v75;
  id v76 = (void *)*MEMORY[0x263F872B0];
  uint64_t v77 = v402;
  v12[43] = v402;
  v12[44] = v76;
  uint64_t v78 = swift_allocObject();
  long long v392 = xmmword_23C6F6AA0;
  *(_OWORD *)(v78 + 16) = xmmword_23C6F6AA0;
  *(void *)(v78 + 32) = 0x656C7069746C754DLL;
  *(void *)(v78 + 40) = 0xE800000000000000;
  *(unsigned char *)(v78 + 48) = 0;
  *(void *)(v78 + 72) = MEMORY[0x263F8D4F8];
  *(void *)(v78 + 80) = 0x614E74757074754FLL;
  *(void *)(v78 + 88) = 0xEA0000000000656DLL;
  id v79 = v76;
  uint64_t v80 = sub_23C6D55A8();
  uint64_t v82 = v81;
  uint64_t v83 = sub_23C6D55A8();
  uint64_t v85 = v84;
  uint64_t v86 = v45;
  uint64_t v378 = v45;
  sub_23C6D46B8();
  id v87 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v88 = (uint64_t)v401;
  sub_23C6D4598();

  id v89 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v78 + 96) = sub_23C41B6F8(v80, v82, v83, v85, 0, 0, v86, v88);
  *(void *)(v78 + 120) = v77;
  *(void *)(v78 + 128) = 0x7365707954;
  *(void *)(v78 + 168) = v383;
  *(void *)(v78 + 136) = 0xE500000000000000;
  *(void *)(v78 + 144) = &unk_26EFFC5C0;
  uint64_t v90 = MEMORY[0x263F8D310];
  uint64_t v91 = sub_23C6D5428();
  uint64_t v92 = v384;
  v384[45] = v91;
  uint64_t v93 = (void *)*MEMORY[0x263F87130];
  v92[48] = v387;
  v92[49] = v93;
  uint64_t v394 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA6C30);
  uint64_t v398 = swift_allocObject();
  *(_OWORD *)(v398 + 16) = xmmword_23C6FB0C0;
  uint64_t v395 = sub_23C369F80(0, &qword_268BA5CE0);
  uint64_t v397 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CE8);
  uint64_t v94 = swift_allocObject();
  *(_OWORD *)(v94 + 16) = v392;
  uint64_t v95 = (void *)*MEMORY[0x263F872D8];
  unint64_t v377 = 0xD000000000000019;
  *(void *)(v94 + 32) = v95;
  *(void *)(v94 + 40) = 0xD000000000000019;
  *(void *)(v94 + 48) = 0x800000023C71E930;
  uint64_t v96 = (void *)*MEMORY[0x263F87350];
  uint64_t v97 = v90;
  *(void *)(v94 + 64) = v90;
  *(void *)(v94 + 72) = v96;
  *(void *)(v94 + 80) = 0x7475706E494657;
  *(void *)(v94 + 88) = 0xE700000000000000;
  uint64_t v98 = (void *)*MEMORY[0x263F87360];
  *(void *)(v94 + 104) = v97;
  *(void *)(v94 + 112) = v98;
  id v99 = v93;
  *(void *)&long long v382 = v95;
  *(void *)&long long v380 = v96;
  id v381 = v98;
  uint64_t v100 = sub_23C6D55A8();
  uint64_t v102 = v101;
  uint64_t v103 = sub_23C6D55A8();
  uint64_t v105 = v104;
  uint64_t v106 = v378;
  sub_23C6D46B8();
  id v107 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v108 = (uint64_t)v401;
  sub_23C6D4598();

  id v109 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v110 = sub_23C41B6F8(v100, v102, v103, v105, 0, 0, v106, v108);
  *(void *)(v94 + 144) = v402;
  *(void *)(v94 + 120) = v110;
  _s3__C3KeyVMa_0(0);
  uint64_t v399 = v111;
  uint64_t v396 = sub_23C375C5C(&qword_26AEEE340, _s3__C3KeyVMa_0);
  uint64_t v112 = sub_23C6D5428();
  id v113 = sub_23C41A0C0(v112);
  *(void *)(v398 + 32) = v113;
  uint64_t v114 = swift_allocObject();
  *(_OWORD *)(v114 + 16) = xmmword_23C6F81B0;
  uint64_t v115 = (void *)*MEMORY[0x263F872C0];
  *(void *)(v114 + 32) = *MEMORY[0x263F872C0];
  *(unsigned char *)(v114 + 40) = 1;
  uint64_t v116 = (void *)v382;
  *(void *)(v114 + 64) = MEMORY[0x263F8D4F8];
  *(void *)(v114 + 72) = v116;
  unint64_t v386 = 0xD000000000000016;
  uint64_t v117 = (void **)MEMORY[0x263F872E0];
  *(void *)(v114 + 80) = 0xD000000000000016;
  *(void *)(v114 + 88) = 0x800000023C71F540;
  uint64_t v118 = *v117;
  *(void *)(v114 + 104) = MEMORY[0x263F8D310];
  *(void *)(v114 + 112) = v118;
  *(void *)(v114 + 120) = &unk_26EFFC5F0;
  uint64_t v119 = (void *)*MEMORY[0x263F87318];
  *(void *)(v114 + 144) = v383;
  *(void *)(v114 + 152) = v119;
  uint64_t v120 = swift_allocObject();
  *(_OWORD *)(v120 + 16) = xmmword_23C6F81A0;
  id v121 = v115;
  *(void *)&long long v382 = v116;
  id v383 = v118;
  id v122 = v119;
  uint64_t v123 = sub_23C6D55A8();
  uint64_t v125 = v124;
  uint64_t v126 = sub_23C6D55A8();
  uint64_t v128 = v127;
  uint64_t v129 = v378;
  sub_23C6D46B8();
  id v130 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v131 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v132 = v129;
  uint64_t v133 = v129;
  uint64_t v134 = v108;
  *(void *)(v120 + 32) = sub_23C41B6F8(v123, v125, v126, v128, 0, 0, v133, v108);
  uint64_t v135 = sub_23C6D55A8();
  uint64_t v137 = v136;
  uint64_t v138 = sub_23C6D55A8();
  uint64_t v140 = v139;
  uint64_t v141 = v132;
  sub_23C6D46B8();
  id v142 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v143 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v120 + 40) = sub_23C41B6F8(v135, v137, v138, v140, 0, 0, v141, v134);
  uint64_t v403 = v120;
  sub_23C6D56B8();
  uint64_t v144 = v403;
  uint64_t v145 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F10);
  *(void *)(v114 + 160) = v144;
  id v146 = (void *)v380;
  *(void *)(v114 + 184) = v145;
  *(void *)(v114 + 192) = v146;
  *(void *)(v114 + 200) = 0xD000000000000013;
  *(void *)(v114 + 208) = 0x800000023C71D850;
  id v147 = v381;
  *(void *)(v114 + 224) = MEMORY[0x263F8D310];
  *(void *)(v114 + 232) = v147;
  id v373 = v146;
  id v381 = v147;
  uint64_t v148 = sub_23C6D55A8();
  uint64_t v150 = v149;
  uint64_t v151 = sub_23C6D55A8();
  uint64_t v153 = v152;
  sub_23C6D46B8();
  id v154 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v155 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v156 = v141;
  uint64_t v157 = v141;
  uint64_t v158 = v134;
  *(void *)(v114 + 240) = sub_23C41B6F8(v148, v150, v151, v153, 0, 0, v156, v134);
  uint64_t v159 = (void *)*MEMORY[0x263F873B8];
  *(void *)(v114 + 264) = v402;
  *(void *)(v114 + 272) = v159;
  uint64_t v160 = swift_allocObject();
  long long v372 = xmmword_23C6F77E0;
  *(_OWORD *)(v160 + 16) = xmmword_23C6F77E0;
  uint64_t v161 = v367;
  *id v367 = 2;
  LODWORD(v374) = *MEMORY[0x263F866C8];
  uint64_t v162 = *(objc_class **)(v391 + 104);
  v391 += 104;
  v371 = v162;
  ((void (*)(void *))v162)(v161);
  Class v370 = (Class)sub_23C6D4C48();
  id v163 = objc_allocWithZone(v370);
  id v363 = v159;
  *(void *)(v160 + 32) = sub_23C6D4C38();
  uint64_t v403 = v160;
  sub_23C6D56B8();
  uint64_t v164 = v403;
  *(void *)(v114 + 304) = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA60A0);
  *(void *)(v114 + 280) = v164;
  uint64_t v165 = sub_23C6D5428();
  id v166 = sub_23C41A0C0(v165);
  *(void *)(v398 + 40) = v166;
  uint64_t v167 = swift_allocObject();
  long long v380 = xmmword_23C6F8490;
  *(_OWORD *)(v167 + 16) = xmmword_23C6F8490;
  uint64_t v168 = (void *)v382;
  *(void *)(v167 + 32) = v382;
  *(void *)(v167 + 40) = 0xD000000000000011;
  unint64_t v379 = 0x800000023C720610;
  *(void *)(v167 + 48) = 0x800000023C720610;
  uint64_t v169 = MEMORY[0x263F8D310];
  uint64_t v170 = v383;
  *(void *)(v167 + 64) = MEMORY[0x263F8D310];
  *(void *)(v167 + 72) = v170;
  *(unsigned char *)(v167 + 80) = 1;
  id v171 = v373;
  *(void *)(v167 + 104) = MEMORY[0x263F8D4F8];
  *(void *)(v167 + 112) = v171;
  unint64_t v375 = 0x800000023C7291E0;
  *(void *)(v167 + 120) = v386;
  *(void *)(v167 + 128) = 0x800000023C7291E0;
  uint64_t v172 = v381;
  *(void *)(v167 + 144) = v169;
  *(void *)(v167 + 152) = v172;
  id v366 = v168;
  id v365 = v170;
  id v364 = v171;
  id v373 = v172;
  uint64_t v173 = sub_23C6D55A8();
  uint64_t v175 = v174;
  uint64_t v176 = sub_23C6D55A8();
  uint64_t v178 = v177;
  uint64_t v179 = v157;
  sub_23C6D46B8();
  id v180 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v181 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v182 = v176;
  uint64_t v183 = v179;
  *(void *)(v167 + 160) = sub_23C41B6F8(v173, v175, v182, v178, 0, 0, v179, v158);
  uint64_t v184 = v363;
  *(void *)(v167 + 184) = v402;
  *(void *)(v167 + 192) = v184;
  id v381 = (id)__swift_instantiateConcreteTypeFromMangledName(&qword_268BA6860);
  uint64_t v185 = swift_allocObject();
  long long v382 = xmmword_23C6F6A90;
  *(_OWORD *)(v185 + 16) = xmmword_23C6F6A90;
  *uint64_t v161 = 2;
  ((void (*)(void *, void, void *))v371)(v161, v374, v385);
  Class v186 = v370;
  id v187 = objc_allocWithZone(v370);
  id v359 = v184;
  uint64_t v188 = sub_23C6D4C38();
  *(void *)(v185 + 56) = v186;
  *(void *)(v185 + 32) = v188;
  uint64_t v189 = MEMORY[0x263F8D310];
  uint64_t v190 = sub_23C6D5428();
  uint64_t v374 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA5CF8);
  *(void *)(v185 + 88) = v374;
  *(void *)(v185 + 64) = v190;
  id v383 = (id)__swift_instantiateConcreteTypeFromMangledName(&qword_268BA6F30);
  *(void *)(v167 + 224) = v383;
  *(void *)(v167 + 200) = v185;
  uint64_t v191 = sub_23C6D5428();
  id v192 = sub_23C41A0C0(v191);
  *(void *)(v398 + 48) = v192;
  uint64_t v193 = swift_allocObject();
  *(_OWORD *)(v193 + 16) = v380;
  uint64_t v195 = v365;
  uint64_t v194 = v366;
  *(void *)(v193 + 32) = v366;
  *(void *)(v193 + 40) = 0xD000000000000011;
  *(void *)(v193 + 48) = v379;
  *(void *)(v193 + 64) = v189;
  *(void *)(v193 + 72) = v195;
  *(unsigned char *)(v193 + 80) = 0;
  uint64_t v196 = v364;
  *(void *)(v193 + 104) = MEMORY[0x263F8D4F8];
  *(void *)(v193 + 112) = v196;
  *(void *)(v193 + 120) = 0xD00000000000001ALL;
  *(void *)(v193 + 128) = 0x800000023C729240;
  id v197 = v373;
  *(void *)(v193 + 144) = v189;
  *(void *)(v193 + 152) = v197;
  id v360 = v194;
  id v363 = v195;
  id v361 = v196;
  id v362 = v197;
  uint64_t v198 = sub_23C6D55A8();
  uint64_t v200 = v199;
  uint64_t v201 = sub_23C6D55A8();
  uint64_t v203 = v202;
  uint64_t v204 = v183;
  sub_23C6D46B8();
  id v205 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v206 = (uint64_t)v401;
  sub_23C6D4598();

  id v207 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v193 + 160) = sub_23C41B6F8(v198, v200, v201, v203, 0, 0, v204, v206);
  id v208 = v359;
  *(void *)(v193 + 184) = v402;
  *(void *)(v193 + 192) = v208;
  uint64_t v209 = swift_allocObject();
  *(_OWORD *)(v209 + 16) = v382;
  uint64_t v210 = swift_allocObject();
  *(_OWORD *)(v210 + 16) = v392;
  strcpy((char *)(v210 + 32), "WFParameterKey");
  *(unsigned char *)(v210 + 47) = -18;
  unint64_t v211 = v375;
  *(void *)(v210 + 48) = v386;
  *(void *)(v210 + 56) = v211;
  uint64_t v212 = MEMORY[0x263F8D310];
  *(void *)(v210 + 72) = MEMORY[0x263F8D310];
  *(void *)(v210 + 80) = 0xD000000000000010;
  id v364 = (id)0xD000000000000010;
  id v366 = (id)0x800000023C71D2C0;
  *(void *)(v210 + 88) = 0x800000023C71D2C0;
  *(unsigned char *)(v210 + 96) = 0;
  uint64_t v213 = MEMORY[0x263F8D4F8];
  *(void *)(v210 + 120) = MEMORY[0x263F8D4F8];
  *(void *)(v210 + 128) = 0x72756F7365524657;
  *(void *)(v210 + 168) = v212;
  id v373 = (id)0xD00000000000001BLL;
  *(void *)(v210 + 136) = 0xEF7373616C436563;
  *(void *)(v210 + 144) = 0xD00000000000001BLL;
  id v365 = (id)0x800000023C71D2E0;
  *(void *)(v210 + 152) = 0x800000023C71D2E0;
  id v359 = v208;
  uint64_t v214 = v212;
  uint64_t v215 = sub_23C6D5428();
  *(void *)(v209 + 56) = v387;
  *(void *)(v209 + 32) = v215;
  *uint64_t v161 = 1;
  ((void (*)(void *, void, void *))v371)(v161, *MEMORY[0x263F866D0], v385);
  Class v216 = v370;
  id v217 = objc_allocWithZone(v370);
  uint64_t v218 = sub_23C6D4C38();
  *(void *)(v209 + 88) = v216;
  *(void *)(v209 + 64) = v218;
  *(void *)(v193 + 224) = v383;
  *(void *)(v193 + 200) = v209;
  uint64_t v219 = sub_23C6D5428();
  id v220 = sub_23C41A0C0(v219);
  uint64_t v221 = v398;
  *(void *)(v398 + 56) = v220;
  uint64_t v222 = swift_allocObject();
  *(_OWORD *)(v222 + 16) = xmmword_23C6F8480;
  *(void *)(v222 + 64) = v214;
  uint64_t v223 = v360;
  *(void *)(v222 + 32) = v360;
  *(void *)(v222 + 40) = 0xD000000000000017;
  *(void *)(v222 + 48) = 0x800000023C721EA0;
  Class v370 = v223;
  *(void *)(v222 + 72) = sub_23C6D5528();
  *(unsigned char *)(v222 + 80) = 1;
  uint64_t v224 = v361;
  uint64_t v225 = v362;
  *(void *)(v222 + 104) = v213;
  *(void *)(v222 + 112) = v224;
  *(void *)(v222 + 120) = 0xD000000000000010;
  *(void *)(v222 + 128) = 0x800000023C7292B0;
  *(void *)(v222 + 144) = v214;
  *(void *)(v222 + 152) = v225;
  id v361 = v224;
  id v362 = v225;
  uint64_t v226 = sub_23C6D55A8();
  uint64_t v228 = v227;
  uint64_t v229 = sub_23C6D55A8();
  uint64_t v231 = v230;
  uint64_t v232 = v378;
  sub_23C6D46B8();
  id v233 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v234 = (uint64_t)v401;
  sub_23C6D4598();

  id v235 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v222 + 160) = sub_23C41B6F8(v226, v228, v229, v231, 0, 0, v232, v234);
  uint64_t v236 = v359;
  *(void *)(v222 + 184) = v402;
  *(void *)(v222 + 192) = v236;
  uint64_t v237 = swift_allocObject();
  *(_OWORD *)(v237 + 16) = v372;
  LODWORD(v391) = *MEMORY[0x263F80BD8];
  id v238 = *(void (**)(void))(v393 + 104);
  v393 += 104;
  id v385 = v238;
  v238(v389);
  v371 = (objc_class *)sub_23C6D4CD8();
  id v239 = objc_allocWithZone(v371);
  id v360 = v236;
  *(void *)(v237 + 32) = sub_23C6D4CC8();
  uint64_t v403 = v237;
  sub_23C6D56B8();
  uint64_t v240 = v403;
  id v367 = (void *)__swift_instantiateConcreteTypeFromMangledName(&qword_268BA62B8);
  *(void *)(v222 + 224) = v367;
  *(void *)(v222 + 200) = v240;
  uint64_t v241 = sub_23C6D5528();
  uint64_t v242 = MEMORY[0x263F8D310];
  *(void *)(v222 + 264) = MEMORY[0x263F8D310];
  *(void *)(v222 + 232) = v241;
  strcpy((char *)(v222 + 240), "EligiblePhotos");
  *(unsigned char *)(v222 + 255) = -18;
  uint64_t v243 = sub_23C6D5428();
  *(void *)(v221 + 64) = sub_23C41A0C0(v243);
  uint64_t v244 = swift_allocObject();
  *(_OWORD *)(v244 + 16) = v380;
  Class v245 = v370;
  *(void *)(v244 + 32) = v370;
  *(void *)(v244 + 40) = 0xD000000000000011;
  *(void *)(v244 + 48) = v379;
  uint64_t v246 = v242;
  id v248 = v362;
  uint64_t v247 = v363;
  *(void *)(v244 + 64) = v242;
  *(void *)(v244 + 72) = v247;
  *(unsigned char *)(v244 + 80) = 1;
  uint64_t v249 = v361;
  *(void *)(v244 + 104) = MEMORY[0x263F8D4F8];
  *(void *)(v244 + 112) = v249;
  *(void *)(v244 + 120) = v376;
  *(void *)(v244 + 128) = 0x800000023C7292F0;
  *(void *)(v244 + 144) = v246;
  *(void *)(v244 + 152) = v248;
  uint64_t v376 = v245;
  id v363 = v247;
  id v361 = v249;
  Class v370 = v248;
  uint64_t v250 = sub_23C6D55A8();
  uint64_t v252 = v251;
  uint64_t v253 = sub_23C6D55A8();
  uint64_t v255 = v254;
  sub_23C6D46B8();
  id v256 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v257 = (uint64_t)v401;
  sub_23C6D4598();

  id v258 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v244 + 160) = sub_23C41B6F8(v250, v252, v253, v255, 0, 0, v232, v257);
  uint64_t v259 = v360;
  *(void *)(v244 + 184) = v402;
  *(void *)(v244 + 192) = v259;
  uint64_t v260 = swift_allocObject();
  *(_OWORD *)(v260 + 16) = v372;
  ((void (*)(char *, void, uint64_t))v385)(v389, v391, v390);
  id v261 = objc_allocWithZone(v371);
  *(void *)&long long v372 = v259;
  *(void *)(v260 + 32) = sub_23C6D4CC8();
  uint64_t v403 = v260;
  sub_23C6D56B8();
  uint64_t v262 = v403;
  *(void *)(v244 + 224) = v367;
  *(void *)(v244 + 200) = v262;
  uint64_t v263 = sub_23C6D5428();
  id v264 = sub_23C41A0C0(v263);
  *(void *)(v398 + 72) = v264;
  uint64_t v265 = swift_allocObject();
  *(_OWORD *)(v265 + 16) = v380;
  id v266 = v376;
  *(void *)(v265 + 32) = v376;
  *(void *)(v265 + 40) = 0xD000000000000011;
  *(void *)(v265 + 48) = v379;
  uint64_t v267 = MEMORY[0x263F8D310];
  uint64_t v268 = v363;
  *(void *)(v265 + 64) = MEMORY[0x263F8D310];
  *(void *)(v265 + 72) = v268;
  *(unsigned char *)(v265 + 80) = 1;
  uint64_t v269 = v361;
  *(void *)(v265 + 104) = MEMORY[0x263F8D4F8];
  *(void *)(v265 + 112) = v269;
  *(void *)(v265 + 120) = v377;
  *(void *)(v265 + 128) = 0x800000023C729350;
  Class v270 = v370;
  *(void *)(v265 + 144) = v267;
  *(void *)(v265 + 152) = v270;
  uint64_t v271 = v266;
  id v272 = v268;
  id v273 = v269;
  uint64_t v274 = v270;
  uint64_t v275 = sub_23C6D55A8();
  uint64_t v277 = v276;
  uint64_t v278 = sub_23C6D55A8();
  uint64_t v280 = v279;
  uint64_t v281 = v232;
  sub_23C6D46B8();
  id v282 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v283 = (uint64_t)v401;
  sub_23C6D4598();

  id v284 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v265 + 160) = sub_23C41B6F8(v275, v277, v278, v280, 0, 0, v281, v283);
  uint64_t v285 = (void *)v372;
  *(void *)(v265 + 184) = v402;
  *(void *)(v265 + 192) = v285;
  uint64_t v286 = swift_allocObject();
  *(_OWORD *)(v286 + 16) = v382;
  ((void (*)(char *, void, uint64_t))v385)(v389, v391, v390);
  id v287 = v371;
  id v288 = objc_allocWithZone(v371);
  id v289 = v285;
  uint64_t v290 = sub_23C6D4CC8();
  *(void *)(v286 + 56) = v287;
  *(void *)(v286 + 32) = v290;
  uint64_t v291 = sub_23C6D5428();
  *(void *)(v286 + 88) = v374;
  *(void *)(v286 + 64) = v291;
  *(void *)(v265 + 224) = v383;
  *(void *)(v265 + 200) = v286;
  uint64_t v292 = sub_23C6D5428();
  id v293 = sub_23C41A0C0(v292);
  uint64_t v294 = v398;
  *(void *)(v398 + 80) = v293;
  uint64_t v403 = v294;
  sub_23C6D56B8();
  uint64_t v295 = v403;
  uint64_t v296 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F20);
  id v297 = v384;
  v384[50] = v295;
  id v298 = (void *)*MEMORY[0x263F87128];
  v297[53] = v296;
  v297[54] = v298;
  uint64_t v402 = sub_23C369F80(0, &qword_268BA5D08);
  uint64_t v299 = swift_allocObject();
  *(_OWORD *)(v299 + 16) = xmmword_23C6F8470;
  id v300 = v298;
  uint64_t v301 = sub_23C6D55A8();
  uint64_t v303 = v302;
  uint64_t v304 = sub_23C6D55A8();
  uint64_t v306 = v305;
  uint64_t v307 = v281;
  sub_23C6D46B8();
  id v308 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v309 = (uint64_t)v401;
  sub_23C6D4598();

  id v310 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v311 = sub_23C41B6F8(v301, v303, v304, v306, 0, 0, v307, v309);
  id v312 = objc_allocWithZone(MEMORY[0x263F86890]);
  *(void *)(v299 + 32) = sub_23C412864(0x7475706E494657, 0xE700000000000000, v311);
  uint64_t v313 = sub_23C6D55A8();
  uint64_t v315 = v314;
  uint64_t v316 = sub_23C6D55A8();
  uint64_t v318 = v317;
  sub_23C6D46B8();
  id v319 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v320 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v321 = sub_23C41B6F8(v313, v315, v316, v318, 0, 0, v307, v309);
  id v322 = objc_allocWithZone(MEMORY[0x263F86890]);
  *(void *)(v299 + 40) = sub_23C412864((uint64_t)v373, 0x800000023C7293D0, v321);
  uint64_t v323 = sub_23C6D55A8();
  uint64_t v325 = v324;
  uint64_t v326 = sub_23C6D55A8();
  uint64_t v328 = v327;
  sub_23C6D46B8();
  id v329 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v330 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v331 = sub_23C41B6F8(v323, v325, v326, v328, 0, 0, v307, v309);
  id v332 = objc_allocWithZone(MEMORY[0x263F86890]);
  *(void *)(v299 + 48) = sub_23C412864(0xD00000000000002CLL, 0x800000023C729430, v331);
  uint64_t v403 = v299;
  sub_23C6D56B8();
  uint64_t v333 = v402;
  id v334 = sub_23C411024();
  uint64_t v335 = v384;
  v384[55] = v334;
  uint64_t v336 = (void *)*MEMORY[0x263F87208];
  v335[58] = v333;
  v335[59] = v336;
  id v337 = v336;
  uint64_t v338 = MEMORY[0x263F8D310];
  uint64_t v339 = sub_23C6D5428();
  uint64_t v340 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA7760);
  v335[60] = v339;
  uint64_t v341 = (void *)*MEMORY[0x263F873E8];
  v335[63] = v340;
  v335[64] = v341;
  uint64_t v342 = swift_allocObject();
  *(_OWORD *)(v342 + 16) = v392;
  *(void *)(v342 + 32) = 0xD000000000000025;
  *(void *)(v342 + 40) = 0x800000023C721F50;
  *(void *)(v342 + 88) = v338;
  *(void *)(v342 + 56) = v338;
  *(void *)(v342 + 64) = 0xD000000000000015;
  *(void *)(v342 + 72) = 0x800000023C71D460;
  uint64_t v343 = swift_allocObject();
  *(_OWORD *)(v343 + 16) = v382;
  *(void *)(v343 + 32) = 0xD000000000000011;
  *(void *)(v343 + 40) = 0x800000023C723960;
  __swift_instantiateConcreteTypeFromMangledName(&qword_268BA66B0);
  uint64_t v344 = swift_allocObject();
  *(_OWORD *)(v344 + 16) = v368;
  uint64_t v345 = swift_allocObject();
  *(_OWORD *)(v345 + 16) = v392;
  strcpy((char *)(v345 + 32), "WFParameterKey");
  *(unsigned char *)(v345 + 47) = -18;
  unint64_t v346 = v375;
  *(void *)(v345 + 48) = v386;
  *(void *)(v345 + 56) = v346;
  id v347 = v364;
  *(void *)(v345 + 72) = v338;
  *(void *)(v345 + 80) = v347;
  *(void *)(v345 + 88) = v366;
  *(unsigned char *)(v345 + 96) = 1;
  *(void *)(v345 + 120) = MEMORY[0x263F8D4F8];
  *(void *)(v345 + 128) = 0x72756F7365524657;
  *(void *)(v345 + 168) = v338;
  id v348 = v373;
  *(void *)(v345 + 136) = 0xEF7373616C436563;
  *(void *)(v345 + 144) = v348;
  *(void *)(v345 + 152) = v365;
  id v349 = v341;
  *(void *)(v344 + 32) = sub_23C6D5428();
  uint64_t v350 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA66B8);
  *(void *)(v343 + 48) = v344;
  *(void *)(v343 + 72) = v350;
  *(void *)(v343 + 80) = 0x72756F7365524657;
  *(void *)(v343 + 120) = v338;
  unint64_t v351 = v377;
  *(void *)(v343 + 88) = 0xEF7373616C436563;
  *(void *)(v343 + 96) = v351;
  *(void *)(v343 + 104) = 0x800000023C71D180;
  uint64_t v352 = sub_23C6D5428();
  *(void *)(v342 + 120) = v387;
  *(void *)(v342 + 96) = v352;
  v335[68] = v383;
  v335[65] = v342;
  uint64_t v353 = (void *)*MEMORY[0x263F874D0];
  v335[69] = *MEMORY[0x263F874D0];
  id v354 = v353;
  uint64_t v355 = sub_23C6D5428();
  v335[73] = v374;
  v335[70] = v355;
  type metadata accessor for Key(0);
  sub_23C375C5C((unint64_t *)&qword_26AEEE8F0, type metadata accessor for Key);
  uint64_t v356 = sub_23C6D5428();
  return sub_23C41A1C0(v356);
}

uint64_t sub_23C40A0A0()
{
  return sub_23C407F00();
}

uint64_t sub_23C40A0C8()
{
  return MEMORY[0x270F86188](0xD000000000000018, 0x800000023C7294C0, sub_23C40A0FC, 0);
}

id sub_23C40A0FC()
{
  uint64_t v0 = sub_23C6D45B8();
  MEMORY[0x270FA5388](v0 - 8);
  uint64_t v2 = (char *)&v204 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v3 = sub_23C6D46E8();
  MEMORY[0x270FA5388](v3 - 8);
  uint64_t v5 = (char *)&v204 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v213 = sub_23C369F80(0, (unint64_t *)&unk_268BA5C90);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEEE910);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_23C6F8190;
  uint64_t v7 = (void *)*MEMORY[0x263F870A0];
  uint64_t v8 = MEMORY[0x263F8D310];
  *(void *)(inited + 32) = *MEMORY[0x263F870A0];
  strcpy((char *)(inited + 40), "WFDateAction");
  *(unsigned char *)(inited + 53) = 0;
  *(_WORD *)(inited + 54) = -5120;
  uint64_t v9 = (void *)*MEMORY[0x263F87110];
  *(void *)(inited + 64) = v8;
  *(void *)(inited + 72) = v9;
  id v10 = v7;
  id v11 = v9;
  uint64_t v12 = sub_23C6D55A8();
  uint64_t v14 = v13;
  uint64_t v15 = sub_23C6D55A8();
  uint64_t v17 = v16;
  sub_23C6D46B8();
  if (qword_268BA5B80 != -1) {
    swift_once();
  }
  id v18 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v19 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v20 = sub_23C41B6F8(v12, v14, v15, v17, 0, 0, (uint64_t)v5, (uint64_t)v2);
  uint64_t v21 = sub_23C369F80(0, (unint64_t *)&unk_268BA5CA0);
  uint64_t v219 = v21;
  *(void *)(inited + 80) = v20;
  id v22 = (void *)*MEMORY[0x263F870F8];
  *(void *)(inited + 104) = v21;
  *(void *)(inited + 112) = v22;
  uint64_t v23 = MEMORY[0x263F8D4F8];
  *(unsigned char *)(inited + 120) = 1;
  uint64_t v218 = v2;
  uint64_t v24 = (void *)*MEMORY[0x263F87190];
  *(void *)(inited + 144) = v23;
  *(void *)(inited + 152) = v24;
  *(void *)&long long v216 = sub_23C369F80(0, (unint64_t *)&unk_268BA6EE0);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CB0);
  uint64_t v25 = swift_initStackObject();
  long long v212 = xmmword_23C6F6A70;
  *(_OWORD *)(v25 + 16) = xmmword_23C6F6A70;
  id v26 = v5;
  uint64_t v27 = (void *)*MEMORY[0x263F871A8];
  *(void *)(v25 + 32) = *MEMORY[0x263F871A8];
  id v28 = v22;
  id v29 = v24;
  id v30 = v27;
  uint64_t v31 = sub_23C6D55A8();
  uint64_t v33 = v32;
  uint64_t v34 = sub_23C6D55A8();
  uint64_t v36 = v35;
  uint64_t v37 = (uint64_t)v26;
  sub_23C6D46B8();
  id v38 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v39 = (uint64_t)v218;
  sub_23C6D4598();

  id v40 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v41 = v36;
  uint64_t v42 = v39;
  id v43 = sub_23C41B6F8(v31, v33, v34, v41, 0, 0, v37, v39);
  uint64_t v44 = v219;
  *(void *)(v25 + 64) = v219;
  *(void *)(v25 + 40) = v43;
  type metadata accessor for DescriptionKey(0);
  sub_23C375C5C((unint64_t *)&unk_268BA6EF0, type metadata accessor for DescriptionKey);
  uint64_t v217 = MEMORY[0x263F8EE58] + 8;
  uint64_t v45 = sub_23C6D5428();
  uint64_t v46 = v216;
  *(void *)(inited + 160) = sub_23C41A078(v45);
  id v47 = (void *)*MEMORY[0x263F870D0];
  *(void *)(inited + 184) = v46;
  *(void *)(inited + 192) = v47;
  *(void *)(inited + 200) = 1953392980;
  *(void *)(inited + 208) = 0xE400000000000000;
  id v48 = (void *)*MEMORY[0x263F870E8];
  uint64_t v49 = MEMORY[0x263F8D310];
  *(void *)(inited + 224) = MEMORY[0x263F8D310];
  *(void *)(inited + 232) = v48;
  *(void *)(inited + 240) = 0x7261646E656C6163;
  *(void *)(inited + 248) = 0xE800000000000000;
  uint64_t v50 = (void *)*MEMORY[0x263F870E0];
  *(void *)(inited + 264) = v49;
  *(void *)(inited + 272) = v50;
  *(void *)(inited + 280) = 6579538;
  *(void *)(inited + 288) = 0xE300000000000000;
  uint64_t v51 = (void *)*MEMORY[0x263F87120];
  *(void *)(inited + 304) = v49;
  *(void *)(inited + 312) = v51;
  id v52 = v47;
  id v53 = v48;
  id v54 = v50;
  id v55 = v51;
  uint64_t v56 = sub_23C6D55A8();
  uint64_t v58 = v57;
  uint64_t v59 = sub_23C6D55A8();
  uint64_t v61 = v60;
  uint64_t v204 = v37;
  sub_23C6D46B8();
  id v62 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v63 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v64 = v37;
  uint64_t v65 = v42;
  *(void *)(inited + 320) = sub_23C41B6F8(v56, v58, v59, v61, 0, 0, v64, v42);
  uint64_t v66 = (void *)*MEMORY[0x263F872B0];
  *(void *)(inited + 344) = v44;
  *(void *)(inited + 352) = v66;
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CC0);
  uint64_t v67 = swift_initStackObject();
  *(_OWORD *)(v67 + 16) = xmmword_23C6F6A80;
  *(void *)(v67 + 32) = 0x75736F6C63736944;
  *(void *)(v67 + 40) = 0xEF6C6576654C6572;
  *(void *)(v67 + 48) = 0x63696C627550;
  *(void *)(v67 + 56) = 0xE600000000000000;
  *(void *)(v67 + 72) = MEMORY[0x263F8D310];
  *(void *)(v67 + 80) = 0x656C7069746C754DLL;
  *(void *)(v67 + 88) = 0xE800000000000000;
  *(unsigned char *)(v67 + 96) = 0;
  *(void *)(v67 + 120) = MEMORY[0x263F8D4F8];
  *(void *)(v67 + 128) = 0x614E74757074754FLL;
  *(void *)(v67 + 136) = 0xEA0000000000656DLL;
  id v68 = v66;
  uint64_t v69 = sub_23C6D55A8();
  uint64_t v71 = v70;
  uint64_t v72 = sub_23C6D55A8();
  uint64_t v74 = v73;
  uint64_t v75 = v204;
  sub_23C6D46B8();
  id v76 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v77 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v67 + 144) = sub_23C41B6F8(v69, v71, v72, v74, 0, 0, v75, v65);
  *(void *)(v67 + 168) = v219;
  *(void *)(v67 + 176) = 0x7365707954;
  *(void *)(v67 + 184) = 0xE500000000000000;
  *(void *)(v67 + 216) = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F00);
  *(void *)(v67 + 192) = &unk_26EFFC818;
  uint64_t v78 = MEMORY[0x263F8D310];
  uint64_t v79 = sub_23C6D5428();
  uint64_t v80 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA5CD0);
  *(void *)(inited + 360) = v79;
  uint64_t v81 = (void *)*MEMORY[0x263F87130];
  *(void *)(inited + 384) = v80;
  *(void *)(inited + 392) = v81;
  uint64_t v211 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA6C30);
  uint64_t v215 = swift_allocObject();
  long long v216 = xmmword_23C6F81A0;
  *(_OWORD *)(v215 + 16) = xmmword_23C6F81A0;
  uint64_t v214 = sub_23C369F80(0, &qword_268BA5CE0);
  uint64_t v210 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CE8);
  uint64_t v82 = swift_allocObject();
  *(_OWORD *)(v82 + 16) = xmmword_23C6F8490;
  uint64_t v83 = (void *)*MEMORY[0x263F872D8];
  *(void *)(v82 + 32) = *MEMORY[0x263F872D8];
  *(void *)(v82 + 40) = 0xD000000000000016;
  *(void *)(v82 + 48) = 0x800000023C71F540;
  uint64_t v84 = (void *)*MEMORY[0x263F872E0];
  uint64_t v85 = v78;
  *(void *)(v82 + 64) = v78;
  *(void *)(v82 + 72) = v84;
  strcpy((char *)(v82 + 80), "Current Date");
  *(unsigned char *)(v82 + 93) = 0;
  *(_WORD *)(v82 + 94) = -5120;
  uint64_t v86 = (void *)*MEMORY[0x263F87318];
  *(void *)(v82 + 104) = v85;
  *(void *)(v82 + 112) = v86;
  uint64_t v208 = swift_allocObject();
  *(_OWORD *)(v208 + 16) = v216;
  id v87 = v81;
  id v209 = v83;
  id v88 = v84;
  id v89 = v86;
  uint64_t v90 = sub_23C6D55A8();
  uint64_t v92 = v91;
  uint64_t v93 = sub_23C6D55A8();
  uint64_t v95 = v94;
  sub_23C6D46B8();
  id v96 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v97 = (uint64_t)v218;
  sub_23C6D4598();

  id v98 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v99 = v92;
  uint64_t v100 = v97;
  id v101 = sub_23C41B6F8(v90, v99, v93, v95, 0, 0, v75, v97);
  uint64_t v102 = v208;
  *(void *)(v208 + 32) = v101;
  uint64_t v103 = sub_23C6D55A8();
  uint64_t v207 = v104;
  uint64_t v105 = sub_23C6D55A8();
  uint64_t v107 = v106;
  uint64_t v108 = v75;
  sub_23C6D46B8();
  id v109 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v110 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v102 + 40) = sub_23C41B6F8(v103, v207, v105, v107, 0, 0, v108, v100);
  uint64_t v220 = v102;
  sub_23C6D56B8();
  uint64_t v111 = v220;
  uint64_t v112 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F10);
  *(void *)(v82 + 120) = v111;
  id v113 = (void *)*MEMORY[0x263F87350];
  *(void *)(v82 + 144) = v112;
  *(void *)(v82 + 152) = v113;
  *(void *)(v82 + 160) = 0xD000000000000010;
  *(void *)(v82 + 168) = 0x800000023C71D8C0;
  uint64_t v114 = (void *)*MEMORY[0x263F87360];
  *(void *)(v82 + 184) = MEMORY[0x263F8D310];
  *(void *)(v82 + 192) = v114;
  id v205 = v113;
  id v206 = v114;
  uint64_t v115 = sub_23C6D55A8();
  uint64_t v117 = v116;
  uint64_t v118 = sub_23C6D55A8();
  uint64_t v120 = v119;
  uint64_t v121 = v108;
  sub_23C6D46B8();
  id v122 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v123 = (uint64_t)v218;
  sub_23C6D4598();

  id v124 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v125 = sub_23C41B6F8(v115, v117, v118, v120, 0, 0, v121, v123);
  *(void *)(v82 + 224) = v219;
  *(void *)(v82 + 200) = v125;
  _s3__C3KeyVMa_0(0);
  uint64_t v208 = v126;
  uint64_t v207 = sub_23C375C5C(&qword_26AEEE340, _s3__C3KeyVMa_0);
  uint64_t v127 = sub_23C6D5428();
  id v128 = sub_23C41A0C0(v127);
  *(void *)(v215 + 32) = v128;
  uint64_t v129 = swift_allocObject();
  *(_OWORD *)(v129 + 16) = xmmword_23C6F8480;
  id v130 = v209;
  *(void *)(v129 + 32) = v209;
  *(void *)(v129 + 40) = 0xD000000000000014;
  *(void *)(v129 + 48) = 0x800000023C71F920;
  uint64_t v131 = MEMORY[0x263F8D310];
  uint64_t v132 = v205;
  uint64_t v133 = v206;
  *(void *)(v129 + 64) = MEMORY[0x263F8D310];
  *(void *)(v129 + 72) = v132;
  *(void *)(v129 + 80) = 0xD000000000000010;
  *(void *)(v129 + 88) = 0x800000023C729630;
  *(void *)(v129 + 104) = v131;
  *(void *)(v129 + 112) = v133;
  id v134 = v130;
  id v135 = v132;
  id v136 = v133;
  uint64_t v137 = sub_23C6D55A8();
  uint64_t v139 = v138;
  uint64_t v140 = sub_23C6D55A8();
  uint64_t v142 = v141;
  uint64_t v143 = v121;
  sub_23C6D46B8();
  id v144 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v145 = (uint64_t)v218;
  sub_23C6D4598();

  id v146 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v129 + 120) = sub_23C41B6F8(v137, v139, v140, v142, 0, 0, v143, v145);
  id v147 = (void *)*MEMORY[0x263F87380];
  *(void *)(v129 + 144) = v219;
  *(void *)(v129 + 152) = v147;
  id v148 = v147;
  uint64_t v149 = sub_23C6D55A8();
  uint64_t v151 = v150;
  uint64_t v152 = sub_23C6D55A8();
  uint64_t v154 = v153;
  sub_23C6D46B8();
  id v155 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v156 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v129 + 160) = sub_23C41B6F8(v149, v151, v152, v154, 0, 0, v143, v145);
  uint64_t v157 = (void *)*MEMORY[0x263F873B8];
  *(void *)(v129 + 184) = v219;
  *(void *)(v129 + 192) = v157;
  __swift_instantiateConcreteTypeFromMangledName(&qword_268BA6590);
  uint64_t v158 = swift_allocObject();
  *(_OWORD *)(v158 + 16) = v212;
  id v159 = v157;
  uint64_t v160 = MEMORY[0x263F8D310];
  *(void *)(v158 + 32) = sub_23C6D5428();
  uint64_t v161 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA6598);
  *(void *)(v129 + 200) = v158;
  uint64_t v162 = (void *)*MEMORY[0x263F873D8];
  *(void *)(v129 + 224) = v161;
  *(void *)(v129 + 232) = v162;
  *(void *)(v129 + 264) = v160;
  *(void *)(v129 + 240) = 0x7468676952;
  *(void *)(v129 + 248) = 0xE500000000000000;
  id v163 = v162;
  uint64_t v164 = sub_23C6D5428();
  id v165 = sub_23C41A0C0(v164);
  uint64_t v166 = v215;
  *(void *)(v215 + 40) = v165;
  uint64_t v220 = v166;
  sub_23C6D56B8();
  uint64_t v167 = v220;
  uint64_t v168 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F20);
  *(void *)(inited + 400) = v167;
  uint64_t v169 = (void *)*MEMORY[0x263F87128];
  *(void *)(inited + 424) = v168;
  *(void *)(inited + 432) = v169;
  uint64_t v219 = sub_23C369F80(0, &qword_268BA5D08);
  uint64_t v170 = swift_allocObject();
  *(_OWORD *)(v170 + 16) = v216;
  id v171 = v169;
  uint64_t v172 = sub_23C6D55A8();
  uint64_t v174 = v173;
  uint64_t v175 = sub_23C6D55A8();
  uint64_t v177 = v176;
  sub_23C6D46B8();
  id v178 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v179 = (uint64_t)v218;
  sub_23C6D4598();

  id v180 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v181 = sub_23C41B6F8(v172, v174, v175, v177, 0, 0, v143, v179);
  id v182 = objc_allocWithZone(MEMORY[0x263F86890]);
  *(void *)(v170 + 32) = sub_23C412864(0xD00000000000001ELL, 0x800000023C7296A0, v181);
  uint64_t v183 = sub_23C6D55A8();
  uint64_t v185 = v184;
  uint64_t v186 = sub_23C6D55A8();
  uint64_t v188 = v187;
  sub_23C6D46B8();
  id v189 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v190 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v191 = sub_23C41B6F8(v183, v185, v186, v188, 0, 0, v143, v179);
  id v192 = objc_allocWithZone(MEMORY[0x263F86890]);
  *(void *)(v170 + 40) = sub_23C412864(0xD000000000000031, 0x800000023C7296E0, v191);
  uint64_t v220 = v170;
  sub_23C6D56B8();
  uint64_t v193 = v219;
  id v194 = sub_23C411024();
  uint64_t v195 = (void **)MEMORY[0x263F87108];
  *(void *)(inited + 440) = v194;
  uint64_t v196 = *v195;
  *(void *)(inited + 464) = v193;
  *(void *)(inited + 472) = v196;
  id v197 = (void **)MEMORY[0x263F87498];
  *(unsigned char *)(inited + 480) = 1;
  uint64_t v198 = *v197;
  uint64_t v199 = MEMORY[0x263F8D4F8];
  *(void *)(inited + 504) = MEMORY[0x263F8D4F8];
  *(void *)(inited + 512) = v198;
  *(void *)(inited + 544) = v199;
  *(unsigned char *)(inited + 520) = 1;
  type metadata accessor for Key(0);
  sub_23C375C5C((unint64_t *)&qword_26AEEE8F0, type metadata accessor for Key);
  id v200 = v196;
  id v201 = v198;
  uint64_t v202 = sub_23C6D5428();
  return sub_23C41A1C0(v202);
}

uint64_t sub_23C40B1C8()
{
  return sub_23C40A0C8();
}

uint64_t sub_23C40B1F0()
{
  return MEMORY[0x270F86188](0xD00000000000001DLL, 0x800000023C729760, sub_23C40B224, 0);
}

id sub_23C40B224()
{
  uint64_t v0 = sub_23C6D4C28();
  uint64_t v301 = *(void *)(v0 - 8);
  uint64_t v302 = v0;
  MEMORY[0x270FA5388](v0);
  uint64_t v303 = (uint64_t *)((char *)&v293 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v2 = sub_23C6D45B8();
  MEMORY[0x270FA5388](v2 - 8);
  uint64_t v4 = (char *)&v293 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v5 = sub_23C6D46E8();
  MEMORY[0x270FA5388](v5 - 8);
  uint64_t v7 = (char *)&v293 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v305 = sub_23C369F80(0, (unint64_t *)&unk_268BA5C90);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEEE910);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_23C6F8190;
  uint64_t v9 = (void *)*MEMORY[0x263F870A0];
  *(void *)(inited + 32) = *MEMORY[0x263F870A0];
  sub_23C369F80(0, (unint64_t *)&unk_268BA7770);
  uint64_t ObjCClassFromMetadata = (objc_class *)swift_getObjCClassFromMetadata();
  id v11 = v9;
  uint64_t v12 = NSStringFromClass(ObjCClassFromMetadata);
  uint64_t v13 = sub_23C6D5568();
  uint64_t v15 = v14;

  uint64_t v16 = MEMORY[0x263F8D310];
  *(void *)(inited + 40) = v13;
  *(void *)(inited + 48) = v15;
  uint64_t v17 = (void *)*MEMORY[0x263F87110];
  *(void *)(inited + 64) = v16;
  *(void *)(inited + 72) = v17;
  id v18 = (void *)inited;
  id v19 = v17;
  uint64_t v20 = sub_23C6D55A8();
  uint64_t v22 = v21;
  uint64_t v23 = sub_23C6D55A8();
  uint64_t v25 = v24;
  uint64_t v26 = (uint64_t)v7;
  sub_23C6D46B8();
  if (qword_268BA5B80 != -1) {
    swift_once();
  }
  id v27 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v28 = (uint64_t)v4;
  uint64_t v316 = v4;
  sub_23C6D4598();

  id v29 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v30 = v26;
  id v31 = sub_23C41B6F8(v20, v22, v23, v25, 0, 0, v26, v28);
  uint64_t v32 = sub_23C369F80(0, (unint64_t *)&unk_268BA5CA0);
  uint64_t v318 = v32;
  uint64_t v33 = v18;
  v18[10] = v31;
  uint64_t v34 = (void *)*MEMORY[0x263F87090];
  v18[13] = v32;
  v18[14] = v34;
  id v35 = v34;
  uint64_t v36 = sub_23C6D5428();
  uint64_t v37 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA5CF8);
  uint64_t v304 = v37;
  v18[15] = v36;
  id v38 = (void *)*MEMORY[0x263F87190];
  v18[18] = v37;
  v18[19] = v38;
  uint64_t v314 = sub_23C369F80(0, (unint64_t *)&unk_268BA6EE0);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CB0);
  uint64_t v39 = swift_initStackObject();
  *(_OWORD *)(v39 + 16) = xmmword_23C6F6A90;
  id v40 = (void *)*MEMORY[0x263F871A0];
  *(void *)(v39 + 32) = *MEMORY[0x263F871A0];
  id v41 = v38;
  id v42 = v40;
  uint64_t v43 = sub_23C6D55A8();
  uint64_t v45 = v44;
  uint64_t v46 = sub_23C6D55A8();
  uint64_t v48 = v47;
  sub_23C6D46B8();
  id v49 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v50 = (uint64_t)v316;
  sub_23C6D4598();

  id v51 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v52 = v43;
  uint64_t v53 = v30;
  uint64_t v54 = v50;
  *(void *)(v39 + 40) = sub_23C41B6F8(v52, v45, v46, v48, 0, 0, v30, v50);
  id v55 = (void *)*MEMORY[0x263F871A8];
  uint64_t v56 = v318;
  *(void *)(v39 + 64) = v318;
  *(void *)(v39 + 72) = v55;
  id v57 = v55;
  uint64_t v317 = sub_23C6D55A8();
  uint64_t v59 = v58;
  uint64_t v60 = sub_23C6D55A8();
  uint64_t v62 = v61;
  sub_23C6D46B8();
  id v63 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v64 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v65 = v54;
  id v66 = sub_23C41B6F8(v317, v59, v60, v62, 0, 0, v53, v54);
  *(void *)(v39 + 104) = v56;
  *(void *)(v39 + 80) = v66;
  type metadata accessor for DescriptionKey(0);
  sub_23C375C5C((unint64_t *)&unk_268BA6EF0, type metadata accessor for DescriptionKey);
  uint64_t v317 = MEMORY[0x263F8EE58] + 8;
  uint64_t v67 = sub_23C6D5428();
  uint64_t v68 = v314;
  v33[20] = sub_23C41A078(v67);
  uint64_t v69 = (void *)*MEMORY[0x263F870B0];
  v33[23] = v68;
  v33[24] = v69;
  uint64_t v70 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F00);
  uint64_t v312 = v70;
  uint64_t v71 = (void **)MEMORY[0x263F87228];
  v33[25] = &unk_26EFFC908;
  uint64_t v72 = *v71;
  v33[28] = v70;
  v33[29] = v72;
  uint64_t v73 = MEMORY[0x263F8D4F8];
  *((unsigned char *)v33 + 240) = 0;
  uint64_t v74 = v53;
  uint64_t v75 = (void *)*MEMORY[0x263F87120];
  v33[33] = v73;
  v33[34] = v75;
  id v76 = v69;
  id v77 = v72;
  id v78 = v75;
  uint64_t v79 = sub_23C6D55A8();
  uint64_t v81 = v80;
  uint64_t v82 = sub_23C6D55A8();
  uint64_t v84 = v83;
  sub_23C6D46B8();
  id v85 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v86 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v87 = sub_23C41B6F8(v79, v81, v82, v84, 0, 0, v74, v65);
  uint64_t v315 = v33;
  v33[35] = v87;
  id v88 = (void *)*MEMORY[0x263F872B0];
  uint64_t v89 = v318;
  v33[38] = v318;
  v33[39] = v88;
  id v299 = (id)__swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CC0);
  uint64_t v90 = swift_initStackObject();
  long long v311 = xmmword_23C6F6A80;
  *(_OWORD *)(v90 + 16) = xmmword_23C6F6A80;
  *(void *)(v90 + 32) = 0x656C7069746C754DLL;
  *(void *)(v90 + 40) = 0xE800000000000000;
  *(unsigned char *)(v90 + 48) = 1;
  *(void *)(v90 + 72) = MEMORY[0x263F8D4F8];
  *(void *)(v90 + 80) = 0x614E74757074754FLL;
  *(void *)(v90 + 88) = 0xEA0000000000656DLL;
  id v91 = v88;
  uint64_t v92 = sub_23C6D55A8();
  uint64_t v94 = v93;
  uint64_t v95 = sub_23C6D55A8();
  uint64_t v97 = v96;
  uint64_t v98 = v74;
  sub_23C6D46B8();
  id v99 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v100 = (uint64_t)v316;
  sub_23C6D4598();

  id v101 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v102 = v98;
  *(void *)(v90 + 96) = sub_23C41B6F8(v92, v94, v95, v97, 0, 0, v98, v100);
  *(void *)(v90 + 120) = v89;
  *(void *)(v90 + 128) = 0x6465726975716552;
  *(void *)(v90 + 136) = 0xE800000000000000;
  *(unsigned char *)(v90 + 144) = 1;
  uint64_t v103 = MEMORY[0x263F8D4F8];
  *(void *)(v90 + 168) = MEMORY[0x263F8D4F8];
  *(void *)(v90 + 176) = 0x7365707954;
  *(void *)(v90 + 216) = v312;
  *(void *)(v90 + 184) = 0xE500000000000000;
  *(void *)(v90 + 192) = &unk_26EFFC938;
  uint64_t v104 = MEMORY[0x263F8D310];
  uint64_t v105 = sub_23C6D5428();
  uint64_t v106 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA5CD0);
  uint64_t v107 = v315;
  v315[40] = v105;
  uint64_t v108 = (void *)*MEMORY[0x263F87130];
  v107[43] = v106;
  v107[44] = v108;
  uint64_t v310 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA6C30);
  uint64_t v314 = swift_allocObject();
  *(_OWORD *)(v314 + 16) = xmmword_23C6F8470;
  uint64_t v313 = sub_23C369F80(0, &qword_268BA5CE0);
  uint64_t v307 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CE8);
  uint64_t v109 = swift_allocObject();
  *(_OWORD *)(v109 + 16) = v311;
  id v110 = (void *)*MEMORY[0x263F872D8];
  *(void *)(v109 + 32) = *MEMORY[0x263F872D8];
  *(void *)(v109 + 40) = 0xD000000000000011;
  *(void *)(v109 + 48) = 0x800000023C720610;
  uint64_t v111 = (void *)*MEMORY[0x263F872E0];
  uint64_t v112 = v104;
  *(void *)(v109 + 64) = v104;
  *(void *)(v109 + 72) = v111;
  *(unsigned char *)(v109 + 80) = 1;
  id v113 = (void *)*MEMORY[0x263F87350];
  *(void *)(v109 + 104) = v103;
  *(void *)(v109 + 112) = v113;
  *(void *)&long long v311 = 0x800000023C729840;
  *(void *)(v109 + 120) = 0xD00000000000001ALL;
  *(void *)(v109 + 128) = 0x800000023C729840;
  uint64_t v114 = (void *)*MEMORY[0x263F87360];
  *(void *)(v109 + 144) = v112;
  *(void *)(v109 + 152) = v114;
  id v115 = v108;
  id v297 = v110;
  id v298 = v111;
  id v294 = v113;
  id v300 = v114;
  uint64_t v116 = sub_23C6D55A8();
  uint64_t v118 = v117;
  uint64_t v119 = sub_23C6D55A8();
  uint64_t v121 = v120;
  uint64_t v122 = v102;
  uint64_t v306 = v102;
  sub_23C6D46B8();
  id v123 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v124 = (uint64_t)v316;
  sub_23C6D4598();

  id v125 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v126 = sub_23C41B6F8(v116, v118, v119, v121, 0, 0, v122, v124);
  *(void *)(v109 + 184) = v318;
  *(void *)(v109 + 160) = v126;
  _s3__C3KeyVMa_0(0);
  uint64_t v309 = v127;
  uint64_t v308 = sub_23C375C5C(&qword_26AEEE340, _s3__C3KeyVMa_0);
  uint64_t v128 = sub_23C6D5428();
  id v129 = sub_23C41A0C0(v128);
  *(void *)(v314 + 32) = v129;
  uint64_t v130 = swift_allocObject();
  *(_OWORD *)(v130 + 16) = xmmword_23C6F81B0;
  uint64_t v131 = v297;
  uint64_t v132 = v298;
  *(void *)(v130 + 32) = v297;
  *(void *)(v130 + 40) = 0xD000000000000012;
  *(void *)(v130 + 48) = 0x800000023C721900;
  uint64_t v133 = MEMORY[0x263F8D310];
  *(void *)(v130 + 64) = MEMORY[0x263F8D310];
  *(void *)(v130 + 72) = v132;
  uint64_t v134 = MEMORY[0x263F8D6C8];
  *(void *)(v130 + 80) = 1;
  id v135 = v294;
  *(void *)(v130 + 104) = v134;
  *(void *)(v130 + 112) = v135;
  strcpy((char *)(v130 + 120), "WFPhotoCount");
  *(unsigned char *)(v130 + 133) = 0;
  *(_WORD *)(v130 + 134) = -5120;
  id v136 = (void *)*MEMORY[0x263F873B8];
  *(void *)(v130 + 144) = v133;
  *(void *)(v130 + 152) = v136;
  __swift_instantiateConcreteTypeFromMangledName(&qword_268BA66B0);
  uint64_t v137 = swift_allocObject();
  *(_OWORD *)(v137 + 16) = xmmword_23C6F6A70;
  uint64_t v138 = swift_allocObject();
  *(_OWORD *)(v138 + 16) = xmmword_23C6F6AA0;
  strcpy((char *)(v138 + 32), "WFParameterKey");
  *(unsigned char *)(v138 + 47) = -18;
  uint64_t v139 = v311;
  *(void *)(v138 + 48) = 0xD00000000000001ALL;
  *(void *)(v138 + 56) = v139;
  unint64_t v295 = 0xD000000000000010;
  *(void *)(v138 + 72) = v133;
  *(void *)(v138 + 80) = 0xD000000000000010;
  *(void *)(v138 + 88) = 0x800000023C71D2C0;
  *(unsigned char *)(v138 + 96) = 1;
  *(void *)(v138 + 120) = MEMORY[0x263F8D4F8];
  *(void *)(v138 + 128) = 0x72756F7365524657;
  *(void *)(v138 + 168) = v133;
  *(void *)(v138 + 136) = 0xEF7373616C436563;
  *(void *)(v138 + 144) = 0xD00000000000001BLL;
  *(void *)(v138 + 152) = 0x800000023C71D2E0;
  id v296 = v131;
  id v297 = v132;
  id v298 = v135;
  id v299 = v136;
  *(void *)(v137 + 32) = sub_23C6D5428();
  uint64_t v140 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA66B8);
  *(void *)(v130 + 160) = v137;
  uint64_t v141 = (void *)*MEMORY[0x263F873C0];
  *(void *)(v130 + 184) = v140;
  *(void *)(v130 + 192) = v141;
  id v142 = v141;
  uint64_t v143 = sub_23C6D55A8();
  uint64_t v145 = v144;
  uint64_t v146 = sub_23C6D55A8();
  uint64_t v148 = v147;
  uint64_t v149 = v306;
  sub_23C6D46B8();
  id v150 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v151 = (uint64_t)v316;
  sub_23C6D4598();

  id v152 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v130 + 200) = sub_23C41B6F8(v143, v145, v146, v148, 0, 0, v149, v151);
  uint64_t v153 = (void *)*MEMORY[0x263F873C8];
  *(void *)(v130 + 224) = v318;
  *(void *)(v130 + 232) = v153;
  id v154 = v153;
  uint64_t v155 = sub_23C6D55A8();
  unint64_t v157 = v156;
  uint64_t v323 = 0;
  unint64_t v324 = 0xE000000000000000;
  sub_23C6D5B68();
  uint64_t v323 = v155;
  unint64_t v324 = v157;
  uint64_t v321 = 10;
  unint64_t v322 = 0xE100000000000000;
  uint64_t v319 = 32;
  unint64_t v320 = 0xE100000000000000;
  sub_23C396450();
  uint64_t v158 = sub_23C6D5AA8();
  unint64_t v160 = v159;
  swift_bridgeObjectRelease();
  uint64_t v323 = v158;
  unint64_t v324 = v160;
  sub_23C6D55F8();
  uint64_t v161 = v323;
  uint64_t v162 = v324;
  sub_23C6D46B8();
  id v163 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v164 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v165 = v157;
  uint64_t v166 = v149;
  uint64_t v167 = v151;
  *(void *)(v130 + 240) = sub_23C41B6F8(v161, v162, v155, v165, 0, 0, v166, v151);
  uint64_t v168 = (void *)*MEMORY[0x263F873D0];
  uint64_t v169 = v318;
  *(void *)(v130 + 264) = v318;
  *(void *)(v130 + 272) = v168;
  id v170 = v168;
  uint64_t v171 = sub_23C6D55A8();
  uint64_t v173 = v172;
  uint64_t v174 = sub_23C6D55A8();
  uint64_t v176 = v175;
  uint64_t v177 = v166;
  sub_23C6D46B8();
  id v178 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v179 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v180 = sub_23C41B6F8(v171, v173, v174, v176, 0, 0, v177, v167);
  *(void *)(v130 + 304) = v169;
  *(void *)(v130 + 280) = v180;
  uint64_t v181 = sub_23C6D5428();
  id v182 = sub_23C41A0C0(v181);
  *(void *)(v314 + 40) = v182;
  uint64_t v183 = swift_allocObject();
  *(_OWORD *)(v183 + 16) = xmmword_23C6F8480;
  uint64_t v184 = v296;
  uint64_t v185 = v297;
  *(void *)(v183 + 32) = v296;
  *(void *)(v183 + 40) = 0xD000000000000016;
  *(void *)(v183 + 48) = 0x800000023C71F540;
  uint64_t v186 = MEMORY[0x263F8D310];
  *(void *)(v183 + 64) = MEMORY[0x263F8D310];
  *(void *)(v183 + 72) = v185;
  *(void *)(v183 + 80) = 1801675074;
  *(void *)(v183 + 88) = 0xE400000000000000;
  uint64_t v187 = (void *)*MEMORY[0x263F87318];
  *(void *)(v183 + 104) = v186;
  *(void *)(v183 + 112) = v187;
  uint64_t v188 = swift_allocObject();
  *(_OWORD *)(v188 + 16) = xmmword_23C6F81A0;
  id v189 = v184;
  id v190 = v185;
  id v191 = v187;
  uint64_t v192 = sub_23C6D55A8();
  uint64_t v194 = v193;
  uint64_t v195 = sub_23C6D55A8();
  uint64_t v197 = v196;
  uint64_t v198 = v306;
  sub_23C6D46B8();
  id v199 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v200 = (uint64_t)v316;
  sub_23C6D4598();

  id v201 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v188 + 32) = sub_23C41B6F8(v192, v194, v195, v197, 0, 0, v198, v200);
  uint64_t v202 = sub_23C6D55A8();
  uint64_t v204 = v203;
  uint64_t v205 = sub_23C6D55A8();
  uint64_t v207 = v206;
  sub_23C6D46B8();
  id v208 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v209 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v188 + 40) = sub_23C41B6F8(v202, v204, v205, v207, 0, 0, v198, v200);
  uint64_t v323 = v188;
  sub_23C6D56B8();
  uint64_t v210 = v323;
  uint64_t v211 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F10);
  *(void *)(v183 + 120) = v210;
  long long v212 = v298;
  *(void *)(v183 + 144) = v211;
  *(void *)(v183 + 152) = v212;
  *(void *)(v183 + 160) = 0xD000000000000015;
  *(void *)(v183 + 168) = 0x800000023C729980;
  uint64_t v213 = v300;
  *(void *)(v183 + 184) = MEMORY[0x263F8D310];
  *(void *)(v183 + 192) = v213;
  id v214 = v212;
  id v215 = v213;
  uint64_t v216 = sub_23C6D55A8();
  uint64_t v218 = v217;
  uint64_t v219 = sub_23C6D55A8();
  uint64_t v221 = v220;
  sub_23C6D46B8();
  id v222 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v223 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v183 + 200) = sub_23C41B6F8(v216, v218, v219, v221, 0, 0, v198, v200);
  uint64_t v224 = v299;
  *(void *)(v183 + 224) = v318;
  *(void *)(v183 + 232) = v224;
  uint64_t v225 = swift_allocObject();
  *(_OWORD *)(v225 + 16) = xmmword_23C6F77E0;
  uint64_t v226 = v302;
  uint64_t v227 = v303;
  *uint64_t v303 = 2;
  (*(void (**)(void *, void, uint64_t))(v301 + 104))(v227, *MEMORY[0x263F866C8], v226);
  id v228 = objc_allocWithZone((Class)sub_23C6D4C48());
  id v229 = v224;
  *(void *)(v225 + 32) = sub_23C6D4C38();
  uint64_t v323 = v225;
  sub_23C6D56B8();
  uint64_t v230 = v323;
  *(void *)(v183 + 264) = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA60A0);
  *(void *)(v183 + 240) = v230;
  uint64_t v231 = sub_23C6D5428();
  id v232 = sub_23C41A0C0(v231);
  uint64_t v233 = v314;
  *(void *)(v314 + 48) = v232;
  uint64_t v323 = v233;
  sub_23C6D56B8();
  uint64_t v234 = v323;
  uint64_t v235 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F20);
  uint64_t v236 = v315;
  v315[45] = v234;
  uint64_t v237 = (void *)*MEMORY[0x263F87128];
  v236[48] = v235;
  v236[49] = v237;
  uint64_t v318 = sub_23C369F80(0, &qword_268BA5D08);
  uint64_t v238 = swift_allocObject();
  *(_OWORD *)(v238 + 16) = xmmword_23C6F8C50;
  id v239 = v237;
  uint64_t v240 = sub_23C6D55A8();
  uint64_t v242 = v241;
  uint64_t v243 = sub_23C6D55A8();
  uint64_t v245 = v244;
  sub_23C6D46B8();
  id v246 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v247 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v248 = sub_23C41B6F8(v240, v242, v243, v245, 0, 0, v198, v200);
  id v249 = objc_allocWithZone(MEMORY[0x263F86890]);
  *(void *)(v238 + 32) = sub_23C412864(0xD00000000000001ALL, v311, v248);
  uint64_t v250 = sub_23C6D55A8();
  uint64_t v252 = v251;
  uint64_t v253 = sub_23C6D55A8();
  uint64_t v255 = v254;
  sub_23C6D46B8();
  id v256 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v257 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v258 = sub_23C41B6F8(v250, v252, v253, v255, 0, 0, v198, v200);
  id v259 = objc_allocWithZone(MEMORY[0x263F86890]);
  *(void *)(v238 + 40) = sub_23C412864(0xD000000000000030, 0x800000023C729A00, v258);
  uint64_t v260 = sub_23C6D55A8();
  uint64_t v262 = v261;
  uint64_t v263 = sub_23C6D55A8();
  uint64_t v265 = v264;
  sub_23C6D46B8();
  id v266 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v267 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v268 = sub_23C41B6F8(v260, v262, v263, v265, 0, 0, v198, v200);
  id v269 = objc_allocWithZone(MEMORY[0x263F86890]);
  *(void *)(v238 + 48) = sub_23C412864(0xD00000000000002ALL, 0x800000023C729A70, v268);
  uint64_t v270 = sub_23C6D55A8();
  uint64_t v272 = v271;
  uint64_t v273 = sub_23C6D55A8();
  uint64_t v275 = v274;
  sub_23C6D46B8();
  id v276 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v277 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v278 = sub_23C41B6F8(v270, v272, v273, v275, 0, 0, v198, v200);
  id v279 = objc_allocWithZone(MEMORY[0x263F86890]);
  *(void *)(v238 + 56) = sub_23C412864(0xD000000000000040, 0x800000023C729AC0, v278);
  uint64_t v323 = v238;
  sub_23C6D56B8();
  uint64_t v280 = v318;
  id v281 = sub_23C411024();
  id v282 = (void **)MEMORY[0x263F873E8];
  uint64_t v283 = v315;
  v315[50] = v281;
  id v284 = *v282;
  v283[53] = v280;
  v283[54] = v284;
  v283[55] = &unk_26EFFC968;
  uint64_t v285 = (void *)*MEMORY[0x263F874D0];
  uint64_t v286 = v312;
  v283[58] = v312;
  v283[59] = v285;
  id v287 = v284;
  id v288 = v285;
  v283[60] = sub_23C6D5428();
  id v289 = (void *)*MEMORY[0x263F874D8];
  v283[63] = v304;
  v283[64] = v289;
  v283[68] = v286;
  v283[65] = &unk_26EFFCA08;
  type metadata accessor for Key(0);
  sub_23C375C5C((unint64_t *)&qword_26AEEE8F0, type metadata accessor for Key);
  id v290 = v289;
  uint64_t v291 = sub_23C6D5428();
  return sub_23C41A1C0(v291);
}

uint64_t sub_23C40CA5C()
{
  return sub_23C40B1F0();
}

unint64_t sub_23C40CA88()
{
  unint64_t result = qword_26AEED6A8;
  if (!qword_26AEED6A8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEED6A8);
  }
  return result;
}

unint64_t sub_23C40CAD8()
{
  unint64_t result = qword_26AEED7C8;
  if (!qword_26AEED7C8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEED7C8);
  }
  return result;
}

uint64_t sub_23C40CB24()
{
  return *(void *)(swift_getOpaqueTypeConformance2() + 8);
}

uint64_t sub_23C40CB58()
{
  return swift_getOpaqueTypeConformance2();
}

unint64_t sub_23C40CBA8()
{
  unint64_t result = qword_26AEED7D0;
  if (!qword_26AEED7D0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEED7D0);
  }
  return result;
}

uint64_t sub_23C40CBF4()
{
  uint64_t v0 = sub_23C6D44E8();
  uint64_t v1 = *(void *)(v0 - 8);
  MEMORY[0x270FA5388](v0);
  uint64_t v3 = (char *)&v8 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v4 = sub_23C6D46E8();
  MEMORY[0x270FA5388](v4 - 8);
  uint64_t v5 = sub_23C6D5518();
  MEMORY[0x270FA5388](v5 - 8);
  uint64_t v6 = sub_23C6D4508();
  __swift_allocate_value_buffer(v6, qword_268BB7BD0);
  __swift_project_value_buffer(v6, (uint64_t)qword_268BB7BD0);
  sub_23C6D54A8();
  sub_23C6D46D8();
  (*(void (**)(char *, void, uint64_t))(v1 + 104))(v3, *MEMORY[0x263F06D18], v0);
  return sub_23C6D4518();
}

uint64_t sub_23C40CDEC()
{
  if (qword_268BA5B88 != -1) {
    swift_once();
  }
  uint64_t v0 = sub_23C6D4508();
  return __swift_project_value_buffer(v0, (uint64_t)qword_268BB7BD0);
}

uint64_t sub_23C40CE50()
{
  uint64_t v0 = sub_23C6D4C78();
  uint64_t v1 = *(void *)(v0 - 8);
  MEMORY[0x270FA5388](v0);
  uint64_t v3 = (char *)&v10 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEEE5D8);
  MEMORY[0x270FA5388](v4 - 8);
  uint64_t v6 = (char *)&v10 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_23C6D4CA8();
  uint64_t v7 = sub_23C6D4C98();
  __swift_storeEnumTagSinglePayload((uint64_t)v6, 0, 1, v7);
  (*(void (**)(char *, void, uint64_t))(v1 + 104))(v3, *MEMORY[0x263F86730], v0);
  type metadata accessor for Key(0);
  sub_23C37BB64();
  sub_23C6D5428();
  id v8 = objc_allocWithZone((Class)sub_23C6D4CB8());
  return sub_23C6D4C88();
}

uint64_t sub_23C40D00C(uint64_t a1)
{
  *(void *)(v1 + 16) = a1;
  sub_23C6D5768();
  *(void *)(v1 + 24) = sub_23C6D5758();
  uint64_t v3 = sub_23C6D5718();
  return MEMORY[0x270FA2498](sub_23C40D0A4, v3, v2);
}

uint64_t sub_23C40D0A4()
{
  swift_release();
  id v1 = objc_msgSend(objc_allocWithZone(MEMORY[0x263F297E0]), sel_init);
  id v2 = objc_msgSend(v1, sel_currentDeviceOrientation);

  unint64_t v3 = 0x5040302010006uLL >> (8 * v2);
  if ((unint64_t)v2 >= 7) {
    LOBYTE(v3) = 6;
  }
  *(unsigned char *)(v0 + 32) = v3;
  sub_23C40D334();
  sub_23C6D3F38();
  uint64_t v4 = *(uint64_t (**)(void))(v0 + 8);
  return v4();
}

uint64_t sub_23C40D184@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = sub_23C40CDEC();
  uint64_t v3 = sub_23C6D4508();
  uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v3 - 8) + 16);
  return v4(a1, v2, v3);
}

uint64_t sub_23C40D1F4(uint64_t a1)
{
  uint64_t v3 = (void *)swift_task_alloc();
  *(void *)(v1 + 16) = v3;
  *uint64_t v3 = v1;
  v3[1] = sub_23C37B95C;
  return sub_23C40D00C(a1);
}

uint64_t sub_23C40D290(uint64_t a1)
{
  unint64_t v2 = sub_23C40CBA8();
  return MEMORY[0x270EE0D28](a1, v2);
}

ValueMetadata *type metadata accessor for GetOrientationAction()
{
  return &type metadata for GetOrientationAction;
}

unint64_t sub_23C40D2E0()
{
  unint64_t result = qword_268BA7780;
  if (!qword_268BA7780)
  {
    __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_268BA7788);
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_268BA7780);
  }
  return result;
}

unint64_t sub_23C40D334()
{
  unint64_t result = qword_26AEED7E0;
  if (!qword_26AEED7E0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEED7E0);
  }
  return result;
}

unint64_t Orientation.init(value:)@<X0>(unint64_t result@<X0>, unsigned char *a2@<X8>)
{
  unint64_t v2 = 0x5040302010006uLL >> (8 * result);
  if (result >= 7) {
    LOBYTE(v2) = 6;
  }
  *a2 = v2;
  return result;
}

uint64_t sub_23C40D3AC()
{
  uint64_t v0 = __swift_instantiateConcreteTypeFromMangledName(&qword_26AEEDAD8);
  MEMORY[0x270FA5388](v0 - 8);
  uint64_t v55 = (uint64_t)v45 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEEEBF0);
  MEMORY[0x270FA5388](v2 - 8);
  uint64_t v4 = (char *)v45 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v5 = sub_23C6D46E8();
  MEMORY[0x270FA5388](v5 - 8);
  uint64_t v7 = (char *)v45 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v57 = sub_23C6D44E8();
  uint64_t v60 = *(void *)(v57 - 8);
  MEMORY[0x270FA5388](v57);
  uint64_t v9 = (char *)v45 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = sub_23C6D5518();
  MEMORY[0x270FA5388](v10 - 8);
  uint64_t v59 = sub_23C6D4508();
  MEMORY[0x270FA5388](v59);
  uint64_t v12 = (char *)v45 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  __swift_instantiateConcreteTypeFromMangledName(&qword_268BA77D0);
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA77D8);
  unint64_t v14 = (*(unsigned __int8 *)(*(void *)(v13 - 8) + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(*(void *)(v13 - 8) + 80);
  uint64_t v56 = *(void *)(*(void *)(v13 - 8) + 72);
  uint64_t v15 = swift_allocObject();
  *(_OWORD *)(v15 + 16) = xmmword_23C6F81B0;
  uint64_t v48 = v15;
  uint64_t v16 = (unsigned char *)(v15 + v14);
  uint64_t v58 = v13;
  uint64_t v17 = *(int *)(v13 + 48);
  *uint64_t v16 = 0;
  sub_23C6D54A8();
  if (qword_26AEEDAF8 != -1) {
    swift_once();
  }
  uint64_t v47 = &v16[v17];
  uint64_t v18 = v57;
  uint64_t v19 = __swift_project_value_buffer(v57, (uint64_t)qword_26AEF6630);
  uint64_t v20 = *(void (**)(char *, uint64_t, uint64_t))(v60 + 16);
  v60 += 16;
  uint64_t v53 = v20;
  v20(v9, v19, v18);
  sub_23C6D46D8();
  sub_23C6D4518();
  id v49 = v4;
  __swift_storeEnumTagSinglePayload((uint64_t)v4, 1, 1, v59);
  uint64_t v21 = sub_23C6D4148();
  uint64_t v22 = v55;
  uint64_t v54 = v21;
  __swift_storeEnumTagSinglePayload(v55, 1, 1, v21);
  sub_23C6D4158();
  id v51 = v16;
  uint64_t v47 = &v16[v56 + *(int *)(v58 + 48)];
  v16[v56] = 1;
  sub_23C6D54A8();
  uint64_t v52 = v19;
  uint64_t v50 = v7;
  v53(v9, v19, v18);
  sub_23C6D46D8();
  v45[1] = v12;
  sub_23C6D4518();
  uint64_t v23 = v59;
  __swift_storeEnumTagSinglePayload((uint64_t)v4, 1, 1, v59);
  __swift_storeEnumTagSinglePayload(v22, 1, 1, v21);
  sub_23C6D4158();
  uint64_t v24 = v56;
  uint64_t v25 = &v16[2 * v56];
  uint64_t v26 = v58;
  uint64_t v47 = &v25[*(int *)(v58 + 48)];
  *uint64_t v25 = 2;
  sub_23C6D54A8();
  uint64_t v27 = v19;
  uint64_t v28 = v57;
  id v29 = v53;
  v53(v9, v27, v57);
  sub_23C6D46D8();
  uint64_t v46 = v9;
  sub_23C6D4518();
  __swift_storeEnumTagSinglePayload((uint64_t)v49, 1, 1, v23);
  uint64_t v30 = v54;
  __swift_storeEnumTagSinglePayload(v22, 1, 1, v54);
  sub_23C6D4158();
  id v31 = &v51[3 * v24];
  uint64_t v47 = &v31[*(int *)(v26 + 48)];
  *id v31 = 3;
  sub_23C6D54A8();
  v29(v9, v52, v28);
  sub_23C6D46D8();
  sub_23C6D4518();
  uint64_t v32 = (uint64_t)v49;
  __swift_storeEnumTagSinglePayload((uint64_t)v49, 1, 1, v59);
  __swift_storeEnumTagSinglePayload(v22, 1, 1, v30);
  sub_23C6D4158();
  uint64_t v33 = v51;
  uint64_t v34 = v56;
  id v35 = &v51[4 * v56];
  uint64_t v47 = &v35[*(int *)(v58 + 48)];
  *id v35 = 4;
  sub_23C6D54A8();
  uint64_t v36 = v52;
  uint64_t v37 = v53;
  v53(v9, v52, v57);
  sub_23C6D46D8();
  sub_23C6D4518();
  uint64_t v38 = v59;
  __swift_storeEnumTagSinglePayload(v32, 1, 1, v59);
  __swift_storeEnumTagSinglePayload(v55, 1, 1, v54);
  sub_23C6D4158();
  uint64_t v39 = &v33[5 * v34];
  uint64_t v47 = &v39[*(int *)(v58 + 48)];
  *uint64_t v39 = 5;
  sub_23C6D54A8();
  id v40 = v46;
  uint64_t v41 = v57;
  v37(v46, v36, v57);
  sub_23C6D46D8();
  sub_23C6D4518();
  __swift_storeEnumTagSinglePayload(v32, 1, 1, v38);
  uint64_t v42 = v54;
  uint64_t v43 = v55;
  __swift_storeEnumTagSinglePayload(v55, 1, 1, v54);
  sub_23C6D4158();
  v51[6 * v56] = 6;
  sub_23C6D54A8();
  v37(v40, v52, v41);
  sub_23C6D46D8();
  sub_23C6D4518();
  __swift_storeEnumTagSinglePayload(v32, 1, 1, v59);
  __swift_storeEnumTagSinglePayload(v43, 1, 1, v42);
  sub_23C6D4158();
  sub_23C6D4168();
  sub_23C40E860();
  uint64_t result = sub_23C6D5428();
  qword_268BA7798 = result;
  return result;
}

uint64_t static Orientation.caseDisplayRepresentations.getter()
{
  if (qword_268BA5B90 != -1) {
    swift_once();
  }
  swift_beginAccess();
  return sub_23C6D41A8();
}

uint64_t static Orientation.caseDisplayRepresentations.setter(uint64_t a1)
{
  if (qword_268BA5B90 != -1) {
    swift_once();
  }
  swift_beginAccess();
  qword_268BA7798 = a1;
  return swift_bridgeObjectRelease();
}

uint64_t (*static Orientation.caseDisplayRepresentations.modify())()
{
  if (qword_268BA5B90 != -1) {
    swift_once();
  }
  swift_beginAccess();
  return j_j__swift_endAccess;
}

uint64_t sub_23C40DEF8()
{
  uint64_t v0 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEEEBF0);
  MEMORY[0x270FA5388](v0 - 8);
  uint64_t v2 = &v13[-((v1 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t v3 = sub_23C6D46E8();
  MEMORY[0x270FA5388](v3 - 8);
  uint64_t v4 = sub_23C6D44E8();
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x270FA5388](v4);
  uint64_t v7 = &v13[-((v6 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t v8 = sub_23C6D5518();
  MEMORY[0x270FA5388](v8 - 8);
  uint64_t v9 = sub_23C6D4508();
  MEMORY[0x270FA5388](v9);
  uint64_t v10 = sub_23C6D42D8();
  __swift_allocate_value_buffer(v10, qword_268BA77A0);
  __swift_project_value_buffer(v10, (uint64_t)qword_268BA77A0);
  sub_23C6D54A8();
  if (qword_26AEEDAF8 != -1) {
    swift_once();
  }
  uint64_t v11 = __swift_project_value_buffer(v4, (uint64_t)qword_26AEF6630);
  (*(void (**)(unsigned char *, uint64_t, uint64_t))(v5 + 16))(v7, v11, v4);
  sub_23C6D46D8();
  sub_23C6D4518();
  __swift_storeEnumTagSinglePayload((uint64_t)v2, 1, 1, v9);
  return sub_23C6D42C8();
}

uint64_t static Orientation.typeDisplayRepresentation.getter@<X0>(uint64_t a1@<X8>)
{
  if (qword_268BA5B98 != -1) {
    swift_once();
  }
  uint64_t v2 = sub_23C6D42D8();
  uint64_t v3 = __swift_project_value_buffer(v2, (uint64_t)qword_268BA77A0);
  swift_beginAccess();
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v2 - 8) + 16))(a1, v3, v2);
}

uint64_t static Orientation.typeDisplayRepresentation.setter(uint64_t a1)
{
  if (qword_268BA5B98 != -1) {
    swift_once();
  }
  uint64_t v2 = sub_23C6D42D8();
  uint64_t v3 = __swift_project_value_buffer(v2, (uint64_t)qword_268BA77A0);
  swift_beginAccess();
  uint64_t v4 = *(void *)(v2 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v4 + 24))(v3, a1, v2);
  swift_endAccess();
  return (*(uint64_t (**)(uint64_t, uint64_t))(v4 + 8))(a1, v2);
}

uint64_t (*static Orientation.typeDisplayRepresentation.modify())()
{
  if (qword_268BA5B98 != -1) {
    swift_once();
  }
  uint64_t v0 = sub_23C6D42D8();
  __swift_project_value_buffer(v0, (uint64_t)qword_268BA77A0);
  swift_beginAccess();
  return j__swift_endAccess;
}

ActionKit::Orientation_optional __swiftcall Orientation.init(rawValue:)(Swift::Int rawValue)
{
  char v2 = 7;
  if ((unint64_t)rawValue < 7) {
    char v2 = rawValue;
  }
  *uint64_t v1 = v2;
  return (ActionKit::Orientation_optional)rawValue;
}

void *static Orientation.allCases.getter()
{
  return &unk_26EFFCA38;
}

uint64_t Orientation.rawValue.getter()
{
  return *v0;
}

unint64_t sub_23C40E45C()
{
  unint64_t result = qword_26AEED810;
  if (!qword_26AEED810)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEED810);
  }
  return result;
}

uint64_t sub_23C40E4A8()
{
  return sub_23C416F04();
}

ActionKit::Orientation_optional sub_23C40E4B0(Swift::Int *a1)
{
  return Orientation.init(rawValue:)(*a1);
}

uint64_t sub_23C40E4B8@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = Orientation.rawValue.getter();
  *a1 = result;
  return result;
}

unint64_t sub_23C40E4E4()
{
  unint64_t result = qword_26AEED7D8;
  if (!qword_26AEED7D8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEED7D8);
  }
  return result;
}

unint64_t sub_23C40E534()
{
  unint64_t result = qword_26AEED7F8;
  if (!qword_26AEED7F8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEED7F8);
  }
  return result;
}

unint64_t sub_23C40E584()
{
  unint64_t result = qword_26AEED818;
  if (!qword_26AEED818)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEED818);
  }
  return result;
}

uint64_t sub_23C40E5D0()
{
  return MEMORY[0x263F8D740];
}

unint64_t sub_23C40E5E0()
{
  unint64_t result = qword_26AEED6B0;
  if (!qword_26AEED6B0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEED6B0);
  }
  return result;
}

unint64_t sub_23C40E630()
{
  unint64_t result = qword_26AEED7F0;
  if (!qword_26AEED7F0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEED7F0);
  }
  return result;
}

unint64_t sub_23C40E684()
{
  unint64_t result = qword_26AEED7E8;
  if (!qword_26AEED7E8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEED7E8);
  }
  return result;
}

uint64_t sub_23C40E6D4()
{
  return swift_getOpaqueTypeConformance2();
}

unint64_t sub_23C40E724()
{
  unint64_t result = qword_268BA77B8;
  if (!qword_268BA77B8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_268BA77B8);
  }
  return result;
}

uint64_t sub_23C40E770(uint64_t a1)
{
  unint64_t v2 = sub_23C40E724();
  return MEMORY[0x270EE0C40](a1, v2);
}

unint64_t sub_23C40E7C0()
{
  unint64_t result = qword_26AEED800;
  if (!qword_26AEED800)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEED800);
  }
  return result;
}

unint64_t sub_23C40E810()
{
  unint64_t result = qword_26AEED820;
  if (!qword_26AEED820)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEED820);
  }
  return result;
}

unint64_t sub_23C40E860()
{
  unint64_t result = qword_26AEED808;
  if (!qword_26AEED808)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEED808);
  }
  return result;
}

uint64_t sub_23C40E8B0(uint64_t a1)
{
  unint64_t v2 = sub_23C40E684();
  return MEMORY[0x270EE1C28](a1, v2);
}

unint64_t sub_23C40E900()
{
  unint64_t result = qword_268BA77C0;
  if (!qword_268BA77C0)
  {
    __swift_instantiateConcreteTypeFromMangledNameAbstract(&qword_268BA77C8);
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_268BA77C0);
  }
  return result;
}

void sub_23C40E954(void *a1@<X8>)
{
  *a1 = &unk_26EFFCA38;
}

uint64_t getEnumTagSinglePayload for Orientation(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2)
  {
    int v5 = -1;
    return (v5 + 1);
  }
  if (a2 >= 0xFA)
  {
    if (a2 + 6 >= 0xFFFF00) {
      int v2 = 4;
    }
    else {
      int v2 = 2;
    }
    if ((a2 + 6) >> 8 < 0xFF) {
      int v3 = 1;
    }
    else {
      int v3 = v2;
    }
    if (v3 == 4)
    {
      int v4 = *(_DWORD *)(a1 + 1);
      if (!v4) {
        goto LABEL_17;
      }
    }
    else if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
    }
    else
    {
      int v4 = a1[1];
      if (!a1[1]) {
        goto LABEL_17;
      }
    }
    int v5 = (*a1 | (v4 << 8)) - 7;
    return (v5 + 1);
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 7;
  int v5 = v6 - 7;
  if (!v7) {
    int v5 = -1;
  }
  return (v5 + 1);
}

unsigned char *storeEnumTagSinglePayload for Orientation(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 6 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 6) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFA) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xF9)
  {
    unsigned int v6 = ((a2 - 250) >> 8) + 1;
    *unint64_t result = a2 + 6;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x23C40EAB8);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *unint64_t result = a2 + 6;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for Orientation()
{
  return &type metadata for Orientation;
}

uint64_t sub_23C40EAF0()
{
  return MEMORY[0x270F86188](0xD00000000000001ALL, 0x800000023C7211A0, sub_23C40EB24, 0);
}

id sub_23C40EB24()
{
  uint64_t v0 = sub_23C6D45B8();
  MEMORY[0x270FA5388](v0 - 8);
  int v2 = (char *)&v159 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v3 = sub_23C6D46E8();
  MEMORY[0x270FA5388](v3 - 8);
  uint64_t v5 = (char *)&v159 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v168 = sub_23C369F80(0, (unint64_t *)&unk_268BA5C90);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEEE910);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_23C6F8190;
  BOOL v7 = (void *)*MEMORY[0x263F870A0];
  uint64_t v8 = MEMORY[0x263F8D310];
  *(void *)(inited + 32) = *MEMORY[0x263F870A0];
  *(void *)(inited + 40) = 0xD000000000000011;
  *(void *)(inited + 48) = 0x800000023C727B10;
  uint64_t v9 = (void *)*MEMORY[0x263F87110];
  *(void *)(inited + 64) = v8;
  *(void *)(inited + 72) = v9;
  id v10 = v7;
  id v11 = v9;
  uint64_t v12 = sub_23C6D55A8();
  uint64_t v14 = v13;
  uint64_t v15 = sub_23C6D55A8();
  uint64_t v17 = v16;
  sub_23C6D46B8();
  if (qword_268BA5B80 != -1) {
    swift_once();
  }
  id v18 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v19 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v20 = sub_23C41B6F8(v12, v14, v15, v17, 0, 0, (uint64_t)v5, (uint64_t)v2);
  uint64_t v21 = sub_23C369F80(0, (unint64_t *)&unk_268BA5CA0);
  *(void *)(inited + 80) = v20;
  uint64_t v22 = (void *)*MEMORY[0x263F87090];
  *(void *)(inited + 104) = v21;
  *(void *)(inited + 112) = v22;
  uint64_t v173 = v21;
  id v23 = v22;
  uint64_t v24 = sub_23C6D5428();
  uint64_t v25 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA5CF8);
  uint64_t v166 = v25;
  *(void *)(inited + 120) = v24;
  uint64_t v26 = (void *)*MEMORY[0x263F87098];
  *(void *)(inited + 144) = v25;
  *(void *)(inited + 152) = v26;
  id v27 = v26;
  uint64_t v28 = sub_23C6D55A8();
  uint64_t v30 = v29;
  uint64_t v31 = sub_23C6D55A8();
  uint64_t v33 = v32;
  sub_23C6D46B8();
  id v34 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v169 = v2;
  sub_23C6D4598();

  id v35 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(inited + 160) = sub_23C41B6F8(v28, v30, v31, v33, 0, 0, (uint64_t)v5, (uint64_t)v2);
  uint64_t v36 = (void *)*MEMORY[0x263F87190];
  *(void *)(inited + 184) = v21;
  *(void *)(inited + 192) = v36;
  uint64_t v171 = sub_23C369F80(0, (unint64_t *)&unk_268BA6EE0);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CB0);
  uint64_t v37 = swift_initStackObject();
  *(_OWORD *)(v37 + 16) = xmmword_23C6F6A70;
  uint64_t v38 = (void *)*MEMORY[0x263F871A8];
  *(void *)(v37 + 32) = *MEMORY[0x263F871A8];
  id v39 = v36;
  id v40 = v38;
  uint64_t v41 = sub_23C6D55A8();
  uint64_t v43 = v42;
  uint64_t v44 = sub_23C6D55A8();
  uint64_t v45 = (uint64_t)v5;
  uint64_t v47 = v46;
  uint64_t v161 = v5;
  sub_23C6D46B8();
  id v48 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v49 = (uint64_t)v169;
  sub_23C6D4598();

  id v50 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v51 = sub_23C41B6F8(v41, v43, v44, v47, 0, 0, v45, v49);
  uint64_t v52 = v173;
  *(void *)(v37 + 64) = v173;
  *(void *)(v37 + 40) = v51;
  type metadata accessor for DescriptionKey(0);
  sub_23C375C5C((unint64_t *)&unk_268BA6EF0, type metadata accessor for DescriptionKey);
  uint64_t v172 = MEMORY[0x263F8EE58] + 8;
  uint64_t v53 = sub_23C6D5428();
  uint64_t v54 = v171;
  *(void *)(inited + 200) = sub_23C41A078(v53);
  uint64_t v55 = (void *)*MEMORY[0x263F87220];
  *(void *)(inited + 224) = v54;
  *(void *)(inited + 232) = v55;
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CC0);
  uint64_t v56 = swift_initStackObject();
  *(_OWORD *)(v56 + 16) = xmmword_23C6F6A80;
  *(void *)(v56 + 32) = 0x656C7069746C754DLL;
  *(void *)(v56 + 40) = 0xE800000000000000;
  uint64_t v57 = MEMORY[0x263F8D4F8];
  *(unsigned char *)(v56 + 48) = 0;
  *(void *)(v56 + 72) = v57;
  strcpy((char *)(v56 + 80), "ParameterKey");
  *(unsigned char *)(v56 + 93) = 0;
  *(_WORD *)(v56 + 94) = -5120;
  strcpy((char *)(v56 + 96), "WFCallContact");
  *(_WORD *)(v56 + 110) = -4864;
  uint64_t v58 = MEMORY[0x263F8D310];
  *(void *)(v56 + 120) = MEMORY[0x263F8D310];
  *(void *)(v56 + 128) = 0x6465726975716552;
  *(void *)(v56 + 136) = 0xE800000000000000;
  *(unsigned char *)(v56 + 144) = 1;
  *(void *)(v56 + 168) = v57;
  *(void *)(v56 + 176) = 0x7365707954;
  uint64_t v59 = v57;
  *(void *)(v56 + 184) = 0xE500000000000000;
  uint64_t v167 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F00);
  *(void *)(v56 + 216) = v167;
  *(void *)(v56 + 192) = &unk_26EFFCAA0;
  id v60 = v55;
  uint64_t v61 = sub_23C6D5428();
  uint64_t v62 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA5CD0);
  id v63 = (void **)MEMORY[0x263F87228];
  *(void *)(inited + 240) = v61;
  id v64 = *v63;
  *(void *)(inited + 264) = v62;
  *(void *)(inited + 272) = v64;
  *(void *)(inited + 304) = v59;
  *(unsigned char *)(inited + 280) = 1;
  id v65 = v64;
  *(void *)(inited + 312) = sub_23C6D5528();
  *(void *)(inited + 320) = 0xD000000000000023;
  *(void *)(inited + 328) = 0x800000023C727BB0;
  id v66 = (void *)*MEMORY[0x263F87120];
  *(void *)(inited + 344) = v58;
  *(void *)(inited + 352) = v66;
  id v67 = v66;
  uint64_t v68 = sub_23C6D55A8();
  uint64_t v70 = v69;
  uint64_t v71 = sub_23C6D55A8();
  uint64_t v73 = v72;
  uint64_t v74 = (uint64_t)v161;
  sub_23C6D46B8();
  id v75 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v76 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(inited + 360) = sub_23C41B6F8(v68, v70, v71, v73, 0, 0, v74, v49);
  id v77 = (void *)*MEMORY[0x263F87130];
  *(void *)(inited + 384) = v52;
  *(void *)(inited + 392) = v77;
  __swift_instantiateConcreteTypeFromMangledName(&qword_268BA6C30);
  uint64_t v171 = swift_allocObject();
  *(_OWORD *)(v171 + 16) = xmmword_23C6F81A0;
  uint64_t v170 = sub_23C369F80(0, &qword_268BA5CE0);
  uint64_t v164 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CE8);
  uint64_t v78 = swift_allocObject();
  long long v163 = xmmword_23C6F8480;
  *(_OWORD *)(v78 + 16) = xmmword_23C6F8480;
  uint64_t v79 = (void *)*MEMORY[0x263F872D8];
  *(void *)(v78 + 32) = *MEMORY[0x263F872D8];
  *(void *)(v78 + 40) = 0xD00000000000001ALL;
  *(void *)(v78 + 48) = 0x800000023C727C00;
  uint64_t v80 = (void *)*MEMORY[0x263F872E0];
  uint64_t v81 = MEMORY[0x263F8D310];
  *(void *)(v78 + 64) = MEMORY[0x263F8D310];
  *(void *)(v78 + 72) = v80;
  id v82 = v77;
  id v162 = v79;
  id v83 = v80;
  uint64_t v84 = sub_23C6D5428();
  id v85 = (void **)MEMORY[0x263F87320];
  *(void *)(v78 + 80) = v84;
  id v86 = *v85;
  *(void *)(v78 + 104) = v166;
  *(void *)(v78 + 112) = v86;
  *(void *)(v78 + 144) = MEMORY[0x263F8D4F8];
  *(unsigned char *)(v78 + 120) = 1;
  id v87 = v86;
  *(void *)(v78 + 152) = sub_23C6D5528();
  *(void *)(v78 + 160) = 0xD000000000000011;
  *(void *)(v78 + 168) = 0x800000023C727C20;
  id v88 = (void *)*MEMORY[0x263F87350];
  *(void *)(v78 + 184) = v81;
  *(void *)(v78 + 192) = v88;
  *(void *)(v78 + 200) = 0xD000000000000013;
  *(void *)(v78 + 208) = 0x800000023C727C40;
  uint64_t v89 = (void *)*MEMORY[0x263F87360];
  *(void *)(v78 + 224) = v81;
  *(void *)(v78 + 232) = v89;
  id v160 = v88;
  id v159 = v89;
  uint64_t v90 = sub_23C6D55A8();
  uint64_t v92 = v91;
  uint64_t v93 = sub_23C6D55A8();
  uint64_t v95 = v94;
  uint64_t v96 = v74;
  sub_23C6D46B8();
  id v97 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v98 = (uint64_t)v169;
  sub_23C6D4598();

  id v99 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v100 = v95;
  uint64_t v101 = v96;
  uint64_t v102 = v98;
  id v103 = sub_23C41B6F8(v90, v92, v93, v100, 0, 0, v96, v98);
  *(void *)(v78 + 264) = v173;
  *(void *)(v78 + 240) = v103;
  _s3__C3KeyVMa_0(0);
  uint64_t v166 = v104;
  uint64_t v165 = sub_23C375C5C(&qword_26AEEE340, _s3__C3KeyVMa_0);
  uint64_t v105 = sub_23C6D5428();
  id v106 = sub_23C41A0C0(v105);
  *(void *)(v171 + 32) = v106;
  uint64_t v107 = swift_allocObject();
  *(_OWORD *)(v107 + 16) = v163;
  uint64_t v108 = (void *)*MEMORY[0x263F872C0];
  *(void *)(v107 + 32) = *MEMORY[0x263F872C0];
  *(unsigned char *)(v107 + 40) = 0;
  uint64_t v109 = v162;
  *(void *)(v107 + 64) = MEMORY[0x263F8D4F8];
  *(void *)(v107 + 72) = v109;
  uint64_t v110 = MEMORY[0x263F8D310];
  *(void *)(v107 + 104) = MEMORY[0x263F8D310];
  *(void *)(v107 + 80) = 0xD00000000000001BLL;
  *(void *)(v107 + 88) = 0x800000023C724270;
  id v111 = v108;
  id v112 = v109;
  *(void *)(v107 + 112) = sub_23C6D5528();
  *(void *)(v107 + 120) = 0x73746361746E6F63;
  *(void *)(v107 + 128) = 0xE800000000000000;
  uint64_t v114 = v159;
  id v113 = v160;
  *(void *)(v107 + 144) = v110;
  *(void *)(v107 + 152) = v113;
  strcpy((char *)(v107 + 160), "WFCallContact");
  *(_WORD *)(v107 + 174) = -4864;
  *(void *)(v107 + 184) = v110;
  *(void *)(v107 + 192) = v114;
  id v115 = v113;
  id v116 = v114;
  uint64_t v117 = sub_23C6D55A8();
  uint64_t v119 = v118;
  uint64_t v120 = sub_23C6D55A8();
  uint64_t v122 = v121;
  uint64_t v123 = v101;
  sub_23C6D46B8();
  id v124 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v125 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v107 + 200) = sub_23C41B6F8(v117, v119, v120, v122, 0, 0, v123, v102);
  id v126 = (void *)*MEMORY[0x263F87398];
  uint64_t v127 = v173;
  *(void *)(v107 + 224) = v173;
  *(void *)(v107 + 232) = v126;
  id v128 = v126;
  uint64_t v129 = sub_23C6D55A8();
  uint64_t v164 = v130;
  uint64_t v131 = sub_23C6D55A8();
  uint64_t v133 = v132;
  sub_23C6D46B8();
  id v134 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v135 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v136 = sub_23C41B6F8(v129, v164, v131, v133, 0, 0, v123, v102);
  *(void *)(v107 + 264) = v127;
  *(void *)(v107 + 240) = v136;
  uint64_t v137 = sub_23C6D5428();
  id v138 = sub_23C41A0C0(v137);
  uint64_t v139 = v171;
  *(void *)(v171 + 40) = v138;
  uint64_t v174 = v139;
  sub_23C6D56B8();
  uint64_t v140 = v174;
  uint64_t v141 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F20);
  *(void *)(inited + 400) = v140;
  id v142 = (void *)*MEMORY[0x263F87128];
  *(void *)(inited + 424) = v141;
  *(void *)(inited + 432) = v142;
  id v143 = v142;
  uint64_t v144 = sub_23C6D55A8();
  uint64_t v146 = v145;
  uint64_t v147 = sub_23C6D55A8();
  uint64_t v149 = v148;
  sub_23C6D46B8();
  id v150 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v151 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v152 = sub_23C41B6F8(v144, v146, v147, v149, 0, 0, v123, v102);
  id v153 = objc_msgSend(objc_allocWithZone(MEMORY[0x263F86888]), sel_initWithString_, v152);

  uint64_t v154 = sub_23C369F80(0, &qword_268BA5D08);
  *(void *)(inited + 440) = v153;
  uint64_t v155 = (void *)*MEMORY[0x263F873E8];
  *(void *)(inited + 464) = v154;
  *(void *)(inited + 472) = v155;
  *(void *)(inited + 504) = v167;
  *(void *)(inited + 480) = &unk_26EFFCB20;
  id v156 = v155;
  *(void *)(inited + 512) = sub_23C6D5528();
  *(void *)(inited + 544) = MEMORY[0x263F8D310];
  *(void *)(inited + 520) = 0x656E6F6850;
  *(void *)(inited + 528) = 0xE500000000000000;
  type metadata accessor for Key(0);
  sub_23C375C5C((unint64_t *)&qword_26AEEE8F0, type metadata accessor for Key);
  uint64_t v157 = sub_23C6D5428();
  return sub_23C41A1C0(v157);
}

uint64_t sub_23C40F99C()
{
  return sub_23C40EAF0();
}

uint64_t sub_23C40F9C4()
{
  return MEMORY[0x270F86188](0xD000000000000023, 0x800000023C729D30, sub_23C40F9F8, 0);
}

id sub_23C40F9F8()
{
  uint64_t v0 = sub_23C6D45B8();
  MEMORY[0x270FA5388](v0 - 8);
  int v2 = (char *)&v180 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v3 = sub_23C6D46E8();
  MEMORY[0x270FA5388](v3 - 8);
  uint64_t v5 = (char *)&v180 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v185 = sub_23C369F80(0, (unint64_t *)&unk_268BA5C90);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEEE910);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_23C6F84B0;
  BOOL v7 = (void *)*MEMORY[0x263F870A0];
  uint64_t v8 = MEMORY[0x263F8D310];
  *(void *)(inited + 32) = *MEMORY[0x263F870A0];
  *(void *)(inited + 40) = 0xD000000000000014;
  *(void *)(inited + 48) = 0x800000023C729D60;
  uint64_t v9 = (void *)*MEMORY[0x263F87110];
  *(void *)(inited + 64) = v8;
  *(void *)(inited + 72) = v9;
  id v10 = v7;
  id v11 = v9;
  uint64_t v12 = sub_23C6D55A8();
  uint64_t v14 = v13;
  uint64_t v15 = sub_23C6D55A8();
  uint64_t v17 = v16;
  sub_23C6D46B8();
  if (qword_268BA5B80 != -1) {
    swift_once();
  }
  id v18 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v19 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v20 = sub_23C41B6F8(v12, v14, v15, v17, 0, 0, (uint64_t)v5, (uint64_t)v2);
  uint64_t v21 = sub_23C369F80(0, (unint64_t *)&unk_268BA5CA0);
  uint64_t v188 = v21;
  *(void *)(inited + 80) = v20;
  uint64_t v22 = (void *)*MEMORY[0x263F87190];
  *(void *)(inited + 104) = v21;
  *(void *)(inited + 112) = v22;
  uint64_t v186 = sub_23C369F80(0, (unint64_t *)&unk_268BA6EE0);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CB0);
  uint64_t v23 = swift_initStackObject();
  *(_OWORD *)(v23 + 16) = xmmword_23C6F6AA0;
  uint64_t v24 = (void *)*MEMORY[0x263F87198];
  *(void *)(v23 + 32) = *MEMORY[0x263F87198];
  id v25 = v22;
  id v26 = v24;
  uint64_t v27 = sub_23C6D55A8();
  uint64_t v29 = v28;
  uint64_t v30 = sub_23C6D55A8();
  uint64_t v32 = v31;
  sub_23C6D46B8();
  id v33 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v34 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v35 = v27;
  uint64_t v36 = v5;
  uint64_t v37 = (uint64_t)v2;
  *(void *)(v23 + 40) = sub_23C41B6F8(v35, v29, v30, v32, 0, 0, (uint64_t)v5, (uint64_t)v2);
  uint64_t v38 = (void *)*MEMORY[0x263F871A0];
  uint64_t v39 = v188;
  *(void *)(v23 + 64) = v188;
  *(void *)(v23 + 72) = v38;
  id v40 = v38;
  uint64_t v187 = sub_23C6D55A8();
  uint64_t v42 = v41;
  uint64_t v43 = sub_23C6D55A8();
  uint64_t v45 = v44;
  uint64_t v46 = (uint64_t)v36;
  sub_23C6D46B8();
  id v47 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v48 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v49 = v46;
  uint64_t v50 = v46;
  uint64_t v51 = v37;
  *(void *)(v23 + 80) = sub_23C41B6F8(v187, v42, v43, v45, 0, 0, v50, v37);
  uint64_t v52 = (void *)*MEMORY[0x263F871A8];
  *(void *)(v23 + 104) = v39;
  *(void *)(v23 + 112) = v52;
  id v53 = v52;
  uint64_t v54 = sub_23C6D55A8();
  uint64_t v56 = v55;
  uint64_t v57 = sub_23C6D55A8();
  uint64_t v59 = v58;
  uint64_t v182 = inited;
  uint64_t v60 = v49;
  sub_23C6D46B8();
  id v61 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v62 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v63 = v59;
  uint64_t v64 = v60;
  id v65 = sub_23C41B6F8(v54, v56, v57, v63, 0, 0, v60, v51);
  *(void *)(v23 + 144) = v39;
  *(void *)(v23 + 120) = v65;
  type metadata accessor for DescriptionKey(0);
  sub_23C375C5C((unint64_t *)&unk_268BA6EF0, type metadata accessor for DescriptionKey);
  uint64_t v187 = MEMORY[0x263F8EE58] + 8;
  uint64_t v66 = sub_23C6D5428();
  uint64_t v67 = v186;
  id v68 = sub_23C41A078(v66);
  uint64_t v69 = v182;
  *(void *)(v182 + 120) = v68;
  uint64_t v70 = (void *)*MEMORY[0x263F870D0];
  *(void *)(v69 + 144) = v67;
  *(void *)(v69 + 152) = v70;
  uint64_t v71 = v51;
  *(void *)(v69 + 160) = 0x6E65657247;
  *(void *)(v69 + 168) = 0xE500000000000000;
  uint64_t v72 = (void *)*MEMORY[0x263F870E8];
  uint64_t v73 = MEMORY[0x263F8D310];
  *(void *)(v69 + 184) = MEMORY[0x263F8D310];
  *(void *)(v69 + 192) = v72;
  *(void *)(v69 + 200) = 0x2E79726574746162;
  *(void *)(v69 + 208) = 0xEB00000000303031;
  uint64_t v74 = (void *)*MEMORY[0x263F87120];
  *(void *)(v69 + 224) = v73;
  *(void *)(v69 + 232) = v74;
  id v75 = v70;
  id v76 = v72;
  id v77 = v74;
  uint64_t v78 = sub_23C6D55A8();
  uint64_t v80 = v79;
  uint64_t v81 = sub_23C6D55A8();
  uint64_t v83 = v82;
  uint64_t v84 = v64;
  sub_23C6D46B8();
  id v85 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v86 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v87 = v84;
  *(void *)(v69 + 240) = sub_23C41B6F8(v78, v80, v81, v83, 0, 0, v84, v71);
  id v88 = (void *)*MEMORY[0x263F872B0];
  uint64_t v89 = v188;
  *(void *)(v69 + 264) = v188;
  *(void *)(v69 + 272) = v88;
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CC0);
  uint64_t v90 = swift_initStackObject();
  *(_OWORD *)(v90 + 16) = xmmword_23C6F6A80;
  *(void *)(v90 + 32) = 0x75736F6C63736944;
  *(void *)(v90 + 40) = 0xEF6C6576654C6572;
  *(void *)(v90 + 48) = 0x63696C627550;
  *(void *)(v90 + 56) = 0xE600000000000000;
  *(void *)(v90 + 72) = MEMORY[0x263F8D310];
  *(void *)(v90 + 80) = 0x656C7069746C754DLL;
  *(void *)(v90 + 88) = 0xE800000000000000;
  uint64_t v91 = MEMORY[0x263F8D4F8];
  *(unsigned char *)(v90 + 96) = 0;
  *(void *)(v90 + 120) = v91;
  *(void *)(v90 + 128) = 0x614E74757074754FLL;
  *(void *)(v90 + 136) = 0xEA0000000000656DLL;
  id v92 = v88;
  uint64_t v186 = sub_23C6D55A8();
  uint64_t v94 = v93;
  uint64_t v95 = sub_23C6D55A8();
  uint64_t v97 = v96;
  uint64_t v98 = v87;
  sub_23C6D46B8();
  id v99 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v100 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v101 = v98;
  *(void *)(v90 + 144) = sub_23C41B6F8(v186, v94, v95, v97, 0, 0, v98, v71);
  *(void *)(v90 + 168) = v89;
  *(void *)(v90 + 176) = 0x7365707954;
  *(void *)(v90 + 184) = 0xE500000000000000;
  *(void *)(v90 + 216) = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F00);
  *(void *)(v90 + 192) = &unk_26EFFCB60;
  uint64_t v102 = MEMORY[0x263F8D310];
  uint64_t v103 = sub_23C6D5428();
  uint64_t v104 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA5CD0);
  *(void *)(v69 + 280) = v103;
  uint64_t v105 = (void *)*MEMORY[0x263F87130];
  *(void *)(v69 + 304) = v104;
  *(void *)(v69 + 312) = v105;
  __swift_instantiateConcreteTypeFromMangledName(&qword_268BA6C30);
  uint64_t v184 = swift_allocObject();
  *(_OWORD *)(v184 + 16) = xmmword_23C6F77E0;
  uint64_t v183 = sub_23C369F80(0, &qword_268BA5CE0);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CE8);
  uint64_t v106 = swift_allocObject();
  uint64_t v107 = (void **)MEMORY[0x263F872D8];
  *(_OWORD *)(v106 + 16) = xmmword_23C6F8490;
  uint64_t v108 = *v107;
  *(void *)(v106 + 32) = *v107;
  *(void *)(v106 + 40) = 0xD000000000000016;
  *(void *)(v106 + 48) = 0x800000023C71F540;
  uint64_t v109 = (void *)*MEMORY[0x263F872E0];
  uint64_t v110 = v102;
  *(void *)(v106 + 64) = v102;
  *(void *)(v106 + 72) = v109;
  strcpy((char *)(v106 + 80), "Battery Level");
  *(_WORD *)(v106 + 94) = -4864;
  id v111 = (void *)*MEMORY[0x263F87318];
  *(void *)(v106 + 104) = v110;
  *(void *)(v106 + 112) = v111;
  uint64_t v186 = swift_allocObject();
  *(_OWORD *)(v186 + 16) = xmmword_23C6F8470;
  id v112 = v105;
  id v113 = v108;
  id v114 = v109;
  id v115 = v111;
  uint64_t v116 = sub_23C6D55A8();
  uint64_t v118 = v117;
  uint64_t v119 = sub_23C6D55A8();
  uint64_t v121 = v120;
  sub_23C6D46B8();
  id v122 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v123 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v124 = sub_23C41B6F8(v116, v118, v119, v121, 0, 0, v101, v71);
  uint64_t v125 = v186;
  *(void *)(v186 + 32) = v124;
  uint64_t v126 = sub_23C6D55A8();
  uint64_t v181 = v127;
  uint64_t v128 = sub_23C6D55A8();
  uint64_t v130 = v129;
  sub_23C6D46B8();
  id v131 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v132 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v125 + 40) = sub_23C41B6F8(v126, v181, v128, v130, 0, 0, v101, v71);
  uint64_t v133 = sub_23C6D55A8();
  uint64_t v135 = v134;
  uint64_t v136 = sub_23C6D55A8();
  uint64_t v138 = v137;
  sub_23C6D46B8();
  id v139 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v140 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v141 = sub_23C41B6F8(v133, v135, v136, v138, 0, 0, v101, v71);
  uint64_t v142 = v186;
  *(void *)(v186 + 48) = v141;
  uint64_t v189 = v142;
  sub_23C6D56B8();
  uint64_t v143 = v189;
  uint64_t v144 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F10);
  *(void *)(v106 + 120) = v143;
  uint64_t v145 = (void *)*MEMORY[0x263F87350];
  *(void *)(v106 + 144) = v144;
  *(void *)(v106 + 152) = v145;
  *(void *)(v106 + 160) = 0x7463656A627553;
  *(void *)(v106 + 168) = 0xE700000000000000;
  uint64_t v146 = (void *)*MEMORY[0x263F87360];
  *(void *)(v106 + 184) = MEMORY[0x263F8D310];
  *(void *)(v106 + 192) = v146;
  id v147 = v145;
  id v148 = v146;
  uint64_t v149 = sub_23C6D55A8();
  uint64_t v151 = v150;
  uint64_t v152 = sub_23C6D55A8();
  uint64_t v154 = v153;
  sub_23C6D46B8();
  id v155 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v156 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v157 = sub_23C41B6F8(v149, v151, v152, v154, 0, 0, v101, v71);
  *(void *)(v106 + 224) = v188;
  *(void *)(v106 + 200) = v157;
  _s3__C3KeyVMa_0(0);
  sub_23C375C5C(&qword_26AEEE340, _s3__C3KeyVMa_0);
  uint64_t v158 = sub_23C6D5428();
  id v159 = sub_23C41A0C0(v158);
  uint64_t v160 = v184;
  *(void *)(v184 + 32) = v159;
  uint64_t v189 = v160;
  sub_23C6D56B8();
  uint64_t v161 = v189;
  uint64_t v162 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F20);
  *(void *)(v69 + 320) = v161;
  long long v163 = (void *)*MEMORY[0x263F87128];
  *(void *)(v69 + 344) = v162;
  *(void *)(v69 + 352) = v163;
  id v164 = v163;
  uint64_t v165 = sub_23C6D55A8();
  uint64_t v167 = v166;
  uint64_t v168 = sub_23C6D55A8();
  uint64_t v170 = v169;
  sub_23C6D46B8();
  id v171 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v172 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v173 = sub_23C41B6F8(v165, v167, v168, v170, 0, 0, v101, v71);
  id v174 = objc_msgSend(objc_allocWithZone(MEMORY[0x263F86888]), sel_initWithString_, v173);

  uint64_t v175 = sub_23C369F80(0, &qword_268BA5D08);
  *(void *)(v69 + 360) = v174;
  uint64_t v176 = (void *)*MEMORY[0x263F87498];
  *(void *)(v69 + 384) = v175;
  *(void *)(v69 + 392) = v176;
  *(void *)(v69 + 424) = MEMORY[0x263F8D4F8];
  *(unsigned char *)(v69 + 400) = 1;
  type metadata accessor for Key(0);
  sub_23C375C5C((unint64_t *)&qword_26AEEE8F0, type metadata accessor for Key);
  id v177 = v176;
  uint64_t v178 = sub_23C6D5428();
  return sub_23C41A1C0(v178);
}

uint64_t sub_23C4108A0()
{
  return sub_23C40F9C4();
}

uint64_t sub_23C4108C8()
{
  return MEMORY[0x270F86188](0xD00000000000001ELL, 0x800000023C72A0B0, sub_23C4108FC, 0);
}

id sub_23C4108FC()
{
  uint64_t v0 = sub_23C6D45B8();
  MEMORY[0x270FA5388](v0 - 8);
  int v2 = (char *)v56 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v3 = sub_23C6D46E8();
  MEMORY[0x270FA5388](v3 - 8);
  uint64_t v5 = (char *)v56 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v59 = sub_23C369F80(0, (unint64_t *)&unk_268BA5C90);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEEE910);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_23C6F84B0;
  BOOL v7 = (void *)*MEMORY[0x263F870A0];
  uint64_t v8 = MEMORY[0x263F8D310];
  *(void *)(inited + 32) = *MEMORY[0x263F870A0];
  *(void *)(inited + 40) = 0xD000000000000016;
  *(void *)(inited + 48) = 0x800000023C720E30;
  uint64_t v9 = (void *)*MEMORY[0x263F87110];
  *(void *)(inited + 64) = v8;
  *(void *)(inited + 72) = v9;
  id v10 = v7;
  id v11 = v9;
  uint64_t v12 = sub_23C6D55A8();
  uint64_t v14 = v13;
  uint64_t v15 = sub_23C6D55A8();
  uint64_t v17 = v16;
  sub_23C6D46B8();
  if (qword_268BA5B80 != -1) {
    swift_once();
  }
  id v18 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v19 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v20 = sub_23C41B6F8(v12, v14, v15, v17, 0, 0, (uint64_t)v5, (uint64_t)v2);
  uint64_t v21 = sub_23C369F80(0, (unint64_t *)&unk_268BA5CA0);
  *(void *)(inited + 80) = v20;
  uint64_t v22 = (void *)*MEMORY[0x263F87098];
  *(void *)(inited + 104) = v21;
  *(void *)(inited + 112) = v22;
  id v23 = v22;
  uint64_t v24 = sub_23C6D55A8();
  uint64_t v26 = v25;
  uint64_t v27 = sub_23C6D55A8();
  uint64_t v29 = v28;
  sub_23C6D46B8();
  id v30 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v31 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(inited + 120) = sub_23C41B6F8(v24, v26, v27, v29, 0, 0, (uint64_t)v5, (uint64_t)v2);
  uint64_t v32 = (void *)*MEMORY[0x263F870D8];
  *(void *)(inited + 144) = v21;
  *(void *)(inited + 152) = v32;
  uint64_t v33 = MEMORY[0x263F8D310];
  *(void *)(inited + 184) = MEMORY[0x263F8D310];
  *(void *)(inited + 160) = 1954047316;
  *(void *)(inited + 168) = 0xE400000000000000;
  id v34 = v32;
  *(void *)(inited + 192) = sub_23C6D5528();
  *(void *)(inited + 224) = MEMORY[0x263F8D4F8];
  *(unsigned char *)(inited + 200) = 1;
  *(void *)(inited + 232) = sub_23C6D5528();
  *(void *)(inited + 240) = 0xD00000000000004FLL;
  *(void *)(inited + 248) = 0x800000023C72A0D0;
  uint64_t v35 = (void *)*MEMORY[0x263F872B0];
  *(void *)(inited + 264) = v33;
  *(void *)(inited + 272) = v35;
  id v36 = v35;
  uint64_t v37 = sub_23C6D5428();
  uint64_t v58 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA5CF8);
  *(void *)(inited + 304) = v58;
  *(void *)(inited + 280) = v37;
  *(void *)(inited + 312) = sub_23C6D5528();
  __swift_instantiateConcreteTypeFromMangledName(&qword_268BA5CD8);
  uint64_t v38 = swift_initStackObject();
  long long v57 = xmmword_23C6F6A90;
  *(_OWORD *)(v38 + 16) = xmmword_23C6F6A90;
  *(void *)(v38 + 32) = 0x65536D6F74737563;
  *(void *)(v38 + 40) = 0xEF726F7461726170;
  sub_23C369F80(0, &qword_268BA5CE0);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CE8);
  uint64_t v39 = swift_initStackObject();
  *(_OWORD *)(v39 + 16) = xmmword_23C6F6A70;
  id v40 = (void *)*MEMORY[0x263F87350];
  *(void *)(v39 + 64) = v33;
  *(void *)(v39 + 32) = v40;
  *(void *)(v39 + 40) = 0xD000000000000015;
  *(void *)(v39 + 48) = 0x800000023C720EF0;
  _s3__C3KeyVMa_0(0);
  sub_23C387008(&qword_26AEEE340, _s3__C3KeyVMa_0);
  id v41 = v40;
  v56[1] = MEMORY[0x263F8EE58] + 8;
  uint64_t v42 = sub_23C6D5428();
  *(void *)(v38 + 48) = sub_23C41A0C0(v42);
  *(void *)(v38 + 56) = 0x6F74617261706573;
  *(void *)(v38 + 64) = 0xE900000000000072;
  uint64_t v43 = swift_initStackObject();
  *(_OWORD *)(v43 + 16) = v57;
  uint64_t v44 = (void *)*MEMORY[0x263F87338];
  *(void *)(v43 + 32) = *MEMORY[0x263F87338];
  id v45 = v44;
  *(void *)(v43 + 40) = sub_23C6D5428();
  *(void *)(v43 + 64) = v58;
  *(void *)(v43 + 72) = v41;
  *(void *)(v43 + 104) = v33;
  *(void *)(v43 + 80) = 0x6553747865544657;
  *(void *)(v43 + 88) = 0xEF726F7461726170;
  id v46 = v41;
  uint64_t v47 = sub_23C6D5428();
  *(void *)(v38 + 72) = sub_23C41A0C0(v47);
  uint64_t v48 = sub_23C6D5428();
  uint64_t v49 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA5D00);
  uint64_t v50 = (void **)MEMORY[0x263F87108];
  *(void *)(inited + 320) = v48;
  uint64_t v51 = *v50;
  *(void *)(inited + 344) = v49;
  *(void *)(inited + 352) = v51;
  *(void *)(inited + 384) = MEMORY[0x263F8D4F8];
  *(unsigned char *)(inited + 360) = 1;
  id v52 = v51;
  uint64_t v53 = sub_23C6D5528();
  *(void *)(inited + 424) = v33;
  *(void *)(inited + 392) = v53;
  *(void *)(inited + 400) = 0x74696C7053;
  *(void *)(inited + 408) = 0xE500000000000000;
  type metadata accessor for Key(0);
  sub_23C387008((unint64_t *)&qword_26AEEE8F0, type metadata accessor for Key);
  uint64_t v54 = sub_23C6D5428();
  return sub_23C41A1C0(v54);
}

uint64_t sub_23C410FFC()
{
  return sub_23C4108C8();
}

id sub_23C411024()
{
  id v0 = objc_allocWithZone((Class)swift_getObjCClassFromMetadata());
  sub_23C369F80(0, (unint64_t *)&unk_268BA77E0);
  uint64_t v1 = (void *)sub_23C6D5698();
  swift_bridgeObjectRelease();
  id v2 = objc_msgSend(v0, sel_initWithValues_, v1);

  return v2;
}

uint64_t sub_23C4110AC()
{
  return MEMORY[0x270F86188](0xD00000000000001BLL, 0x800000023C72A130, sub_23C4110E0, 0);
}

id sub_23C4110E0()
{
  uint64_t v0 = sub_23C6D45B8();
  MEMORY[0x270FA5388](v0 - 8);
  id v2 = (char *)&v288 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v3 = sub_23C6D46E8();
  MEMORY[0x270FA5388](v3 - 8);
  uint64_t v5 = (char *)&v288 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v295 = sub_23C369F80(0, (unint64_t *)&unk_268BA5C90);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEEE910);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_23C6F8190;
  BOOL v7 = (void *)*MEMORY[0x263F870A0];
  uint64_t v8 = MEMORY[0x263F8D310];
  *(void *)(inited + 32) = *MEMORY[0x263F870A0];
  strcpy((char *)(inited + 40), "WFSetVPNAction");
  *(unsigned char *)(inited + 55) = -18;
  uint64_t v9 = (void *)*MEMORY[0x263F87110];
  *(void *)(inited + 64) = v8;
  *(void *)(inited + 72) = v9;
  id v10 = v7;
  id v11 = v9;
  uint64_t v12 = sub_23C6D55A8();
  uint64_t v14 = v13;
  uint64_t v15 = sub_23C6D55A8();
  uint64_t v17 = v16;
  uint64_t v18 = (uint64_t)v5;
  sub_23C6D46B8();
  if (qword_268BA5B80 != -1) {
    swift_once();
  }
  id v19 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v20 = (uint64_t)v2;
  sub_23C6D4598();

  id v21 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v22 = v18;
  id v23 = sub_23C41B6F8(v12, v14, v15, v17, 0, 0, v18, v20);
  uint64_t v24 = sub_23C369F80(0, (unint64_t *)&unk_268BA5CA0);
  *(void *)(inited + 80) = v23;
  uint64_t v25 = (void *)*MEMORY[0x263F87090];
  *(void *)(inited + 104) = v24;
  *(void *)(inited + 112) = v25;
  uint64_t v299 = v24;
  id v26 = v25;
  uint64_t v27 = sub_23C6D5428();
  uint64_t v28 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA5CF8);
  *(void *)(inited + 120) = v27;
  uint64_t v29 = (void *)*MEMORY[0x263F87098];
  *(void *)(inited + 144) = v28;
  *(void *)(inited + 152) = v29;
  id v30 = v29;
  uint64_t v31 = sub_23C6D55A8();
  uint64_t v33 = v32;
  uint64_t v34 = sub_23C6D55A8();
  uint64_t v36 = v35;
  sub_23C6D46B8();
  id v37 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v38 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(inited + 160) = sub_23C41B6F8(v31, v33, v34, v36, 0, 0, v22, v20);
  uint64_t v39 = (void *)*MEMORY[0x263F87190];
  *(void *)(inited + 184) = v24;
  *(void *)(inited + 192) = v39;
  uint64_t v302 = sub_23C369F80(0, (unint64_t *)&unk_268BA6EE0);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CB0);
  uint64_t v40 = swift_initStackObject();
  *(_OWORD *)(v40 + 16) = xmmword_23C6F6A90;
  id v41 = (void *)*MEMORY[0x263F87198];
  *(void *)(v40 + 32) = *MEMORY[0x263F87198];
  id v42 = v39;
  id v43 = v41;
  uint64_t v44 = sub_23C6D55A8();
  uint64_t v46 = v45;
  uint64_t v47 = sub_23C6D55A8();
  uint64_t v49 = v48;
  sub_23C6D46B8();
  id v50 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v51 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v52 = v44;
  uint64_t v53 = v22;
  *(void *)(v40 + 40) = sub_23C41B6F8(v52, v46, v47, v49, 0, 0, v22, v20);
  uint64_t v54 = (void *)*MEMORY[0x263F871A8];
  uint64_t v55 = v299;
  *(void *)(v40 + 64) = v299;
  *(void *)(v40 + 72) = v54;
  id v56 = v54;
  uint64_t v57 = sub_23C6D55A8();
  uint64_t v301 = v58;
  uint64_t v59 = sub_23C6D55A8();
  uint64_t v61 = v60;
  sub_23C6D46B8();
  id v62 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v63 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v64 = sub_23C41B6F8(v57, v301, v59, v61, 0, 0, v53, v20);
  uint64_t v65 = v55;
  *(void *)(v40 + 104) = v55;
  *(void *)(v40 + 80) = v64;
  type metadata accessor for DescriptionKey(0);
  sub_23C375C5C((unint64_t *)&unk_268BA6EF0, type metadata accessor for DescriptionKey);
  uint64_t v300 = MEMORY[0x263F8EE58] + 8;
  uint64_t v66 = sub_23C6D5428();
  uint64_t v67 = v302;
  *(void *)(inited + 200) = sub_23C41A078(v66);
  id v68 = (void *)*MEMORY[0x263F870B0];
  *(void *)(inited + 224) = v67;
  *(void *)(inited + 232) = v68;
  uint64_t v69 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F00);
  *(void *)(inited + 240) = &unk_26EFFCCC0;
  uint64_t v70 = (void *)*MEMORY[0x263F870D0];
  *(void *)(inited + 264) = v69;
  *(void *)(inited + 272) = v70;
  *(void *)(inited + 280) = 1702194242;
  *(void *)(inited + 288) = 0xE400000000000000;
  uint64_t v71 = v20;
  uint64_t v72 = inited;
  uint64_t v303 = (void *)inited;
  uint64_t v73 = v53;
  uint64_t v74 = (void *)*MEMORY[0x263F870E8];
  uint64_t v75 = MEMORY[0x263F8D310];
  *(void *)(v72 + 304) = MEMORY[0x263F8D310];
  *(void *)(v72 + 312) = v74;
  *(void *)(v72 + 320) = 0xD000000000000024;
  *(void *)(v72 + 328) = 0x800000023C72A2B0;
  id v76 = (void *)*MEMORY[0x263F87228];
  *(void *)(v72 + 344) = v75;
  *(void *)(v72 + 352) = v76;
  uint64_t v77 = MEMORY[0x263F8D4F8];
  *(unsigned char *)(v72 + 360) = 1;
  uint64_t v78 = (void *)*MEMORY[0x263F87120];
  *(void *)(v72 + 384) = v77;
  *(void *)(v72 + 392) = v78;
  id v79 = v68;
  id v80 = v70;
  id v81 = v74;
  id v82 = v76;
  id v83 = v78;
  uint64_t v84 = sub_23C6D55A8();
  uint64_t v86 = v85;
  uint64_t v87 = sub_23C6D55A8();
  uint64_t v89 = v88;
  sub_23C6D46B8();
  id v90 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v91 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v92 = sub_23C41B6F8(v84, v86, v87, v89, 0, 0, v73, v71);
  uint64_t v93 = v303;
  v303[50] = v92;
  uint64_t v94 = (void *)*MEMORY[0x263F87130];
  v93[53] = v65;
  v93[54] = v94;
  uint64_t v294 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA6C30);
  uint64_t v302 = swift_allocObject();
  *(_OWORD *)(v302 + 16) = xmmword_23C6F8470;
  uint64_t v301 = sub_23C369F80(0, &qword_268BA5CE0);
  uint64_t v298 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CE8);
  uint64_t v95 = swift_initStackObject();
  long long v292 = xmmword_23C6F8490;
  uint64_t v96 = (void **)MEMORY[0x263F872D8];
  *(_OWORD *)(v95 + 16) = xmmword_23C6F8490;
  uint64_t v97 = *v96;
  *(void *)(v95 + 32) = *v96;
  *(void *)(v95 + 40) = 0xD000000000000016;
  *(void *)(v95 + 48) = 0x800000023C71F540;
  uint64_t v98 = (void *)*MEMORY[0x263F872E0];
  uint64_t v99 = MEMORY[0x263F8D310];
  *(void *)(v95 + 64) = MEMORY[0x263F8D310];
  *(void *)(v95 + 72) = v98;
  *(void *)(v95 + 80) = 0x7463656E6E6F43;
  *(void *)(v95 + 88) = 0xE700000000000000;
  id v100 = (void *)*MEMORY[0x263F87318];
  *(void *)(v95 + 104) = v99;
  *(void *)(v95 + 112) = v100;
  uint64_t v101 = swift_allocObject();
  long long v293 = xmmword_23C6FCAB0;
  *(_OWORD *)(v101 + 16) = xmmword_23C6FCAB0;
  id v102 = v94;
  id v290 = v97;
  id v291 = v98;
  id v103 = v100;
  uint64_t v104 = sub_23C6D55A8();
  uint64_t v106 = v105;
  uint64_t v107 = sub_23C6D55A8();
  uint64_t v109 = v108;
  sub_23C6D46B8();
  id v110 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v111 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v101 + 32) = sub_23C41B6F8(v104, v106, v107, v109, 0, 0, v73, v71);
  uint64_t v112 = sub_23C6D55A8();
  uint64_t v114 = v113;
  uint64_t v115 = sub_23C6D55A8();
  uint64_t v117 = v116;
  sub_23C6D46B8();
  id v118 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v119 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v101 + 40) = sub_23C41B6F8(v112, v114, v115, v117, 0, 0, v73, v71);
  uint64_t v120 = sub_23C6D55A8();
  uint64_t v122 = v121;
  uint64_t v123 = sub_23C6D55A8();
  uint64_t v125 = v124;
  sub_23C6D46B8();
  id v126 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v127 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v101 + 48) = sub_23C41B6F8(v120, v122, v123, v125, 0, 0, v73, v71);
  uint64_t v128 = sub_23C6D55A8();
  uint64_t v130 = v129;
  uint64_t v131 = sub_23C6D55A8();
  uint64_t v133 = v132;
  sub_23C6D46B8();
  id v134 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v135 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v101 + 56) = sub_23C41B6F8(v128, v130, v131, v133, 0, 0, v73, v71);
  uint64_t v136 = sub_23C6D55A8();
  uint64_t v138 = v137;
  uint64_t v139 = sub_23C6D55A8();
  uint64_t v141 = v140;
  sub_23C6D46B8();
  id v142 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v143 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v101 + 64) = sub_23C41B6F8(v136, v138, v139, v141, 0, 0, v73, v71);
  uint64_t v304 = v101;
  sub_23C6D56B8();
  uint64_t v144 = v304;
  uint64_t v145 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F10);
  uint64_t v146 = (void **)MEMORY[0x263F87350];
  *(void *)(v95 + 120) = v144;
  id v147 = *v146;
  *(void *)(v95 + 144) = v145;
  *(void *)(v95 + 152) = v147;
  strcpy((char *)(v95 + 160), "WFVPNOperation");
  *(unsigned char *)(v95 + 175) = -18;
  id v148 = (void *)*MEMORY[0x263F87360];
  *(void *)(v95 + 184) = MEMORY[0x263F8D310];
  *(void *)(v95 + 192) = v148;
  id v289 = v147;
  id v149 = v148;
  uint64_t v150 = sub_23C6D55A8();
  uint64_t v152 = v151;
  uint64_t v153 = sub_23C6D55A8();
  uint64_t v155 = v154;
  sub_23C6D46B8();
  id v156 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v157 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v158 = sub_23C41B6F8(v150, v152, v153, v155, 0, 0, v73, v71);
  *(void *)(v95 + 224) = v299;
  *(void *)(v95 + 200) = v158;
  _s3__C3KeyVMa_0(0);
  uint64_t v297 = v159;
  uint64_t v296 = sub_23C375C5C(&qword_26AEEE340, _s3__C3KeyVMa_0);
  uint64_t v160 = sub_23C6D5428();
  id v161 = sub_23C41A0C0(v160);
  *(void *)(v302 + 32) = v161;
  uint64_t v162 = swift_allocObject();
  *(_OWORD *)(v162 + 16) = v292;
  long long v163 = v290;
  id v164 = v291;
  *(void *)(v162 + 32) = v290;
  *(void *)(v162 + 40) = 0xD000000000000011;
  *(void *)(v162 + 48) = 0x800000023C720610;
  uint64_t v165 = MEMORY[0x263F8D310];
  *(void *)(v162 + 64) = MEMORY[0x263F8D310];
  *(void *)(v162 + 72) = v164;
  *(unsigned char *)(v162 + 80) = 1;
  uint64_t v166 = v289;
  *(void *)(v162 + 104) = MEMORY[0x263F8D4F8];
  *(void *)(v162 + 112) = v166;
  *(void *)(v162 + 120) = 0x616D65446E4F4657;
  *(void *)(v162 + 128) = 0xEF65756C6156646ELL;
  *(void *)(v162 + 144) = v165;
  *(void *)(v162 + 152) = v149;
  id v290 = v163;
  id v167 = v164;
  id v291 = v166;
  *(void *)&long long v292 = v149;
  uint64_t v168 = sub_23C6D55A8();
  uint64_t v170 = v169;
  uint64_t v171 = sub_23C6D55A8();
  uint64_t v173 = v172;
  sub_23C6D46B8();
  id v174 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v175 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v162 + 160) = sub_23C41B6F8(v168, v170, v171, v173, 0, 0, v73, v71);
  uint64_t v176 = (void *)*MEMORY[0x263F873B8];
  uint64_t v177 = v299;
  *(void *)(v162 + 184) = v299;
  *(void *)(v162 + 192) = v176;
  __swift_instantiateConcreteTypeFromMangledName(&qword_268BA6590);
  uint64_t v178 = swift_allocObject();
  *(_OWORD *)(v178 + 16) = xmmword_23C6F6A70;
  id v179 = v176;
  uint64_t v180 = MEMORY[0x263F8D310];
  *(void *)(v178 + 32) = sub_23C6D5428();
  *(void *)(v162 + 224) = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA6598);
  *(void *)(v162 + 200) = v178;
  uint64_t v181 = sub_23C6D5428();
  id v182 = sub_23C41A0C0(v181);
  *(void *)(v302 + 40) = v182;
  uint64_t v183 = swift_allocObject();
  uint64_t v184 = (void **)MEMORY[0x263F87308];
  *(_OWORD *)(v183 + 16) = xmmword_23C6F8480;
  uint64_t v185 = *v184;
  *(void *)(v183 + 32) = v185;
  *(unsigned char *)(v183 + 40) = 1;
  uint64_t v186 = v290;
  *(void *)(v183 + 64) = MEMORY[0x263F8D4F8];
  *(void *)(v183 + 72) = v186;
  *(void *)(v183 + 80) = 0xD000000000000014;
  *(void *)(v183 + 88) = 0x800000023C72A470;
  uint64_t v187 = (void *)*MEMORY[0x263F872E8];
  *(void *)(v183 + 104) = v180;
  *(void *)(v183 + 112) = v187;
  id v188 = v185;
  id v189 = v186;
  id v190 = v187;
  uint64_t v191 = sub_23C6D55A8();
  uint64_t v193 = v192;
  uint64_t v194 = sub_23C6D55A8();
  uint64_t v196 = v195;
  sub_23C6D46B8();
  id v197 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v198 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v183 + 120) = sub_23C41B6F8(v191, v193, v194, v196, 0, 0, v73, v71);
  id v199 = v291;
  uint64_t v200 = (void *)v292;
  *(void *)(v183 + 144) = v177;
  *(void *)(v183 + 152) = v199;
  *(void *)(v183 + 160) = 0x4E50564657;
  *(void *)(v183 + 168) = 0xE500000000000000;
  *(void *)(v183 + 184) = MEMORY[0x263F8D310];
  *(void *)(v183 + 192) = v200;
  id v201 = v199;
  id v202 = v200;
  uint64_t v203 = sub_23C6D55A8();
  uint64_t v205 = v204;
  uint64_t v206 = sub_23C6D55A8();
  uint64_t v208 = v207;
  sub_23C6D46B8();
  id v209 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v210 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v183 + 200) = sub_23C41B6F8(v203, v205, v206, v208, 0, 0, v73, v71);
  uint64_t v211 = (void *)*MEMORY[0x263F87398];
  *(void *)(v183 + 224) = v177;
  *(void *)(v183 + 232) = v211;
  id v212 = v211;
  uint64_t v213 = sub_23C6D55A8();
  uint64_t v215 = v214;
  uint64_t v216 = sub_23C6D55A8();
  uint64_t v218 = v217;
  sub_23C6D46B8();
  id v219 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v220 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v221 = sub_23C41B6F8(v213, v215, v216, v218, 0, 0, v73, v71);
  *(void *)(v183 + 264) = v177;
  *(void *)(v183 + 240) = v221;
  uint64_t v222 = sub_23C6D5428();
  id v223 = sub_23C41A0C0(v222);
  uint64_t v224 = v302;
  *(void *)(v302 + 48) = v223;
  uint64_t v304 = v224;
  sub_23C6D56B8();
  uint64_t v225 = v304;
  uint64_t v226 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F20);
  uint64_t v227 = v303;
  v303[55] = v225;
  id v228 = (void *)*MEMORY[0x263F87128];
  v227[58] = v226;
  v227[59] = v228;
  uint64_t v302 = sub_23C369F80(0, &qword_268BA5D08);
  uint64_t v229 = swift_allocObject();
  *(_OWORD *)(v229 + 16) = v293;
  id v230 = v228;
  uint64_t v231 = sub_23C6D55A8();
  uint64_t v233 = v232;
  uint64_t v234 = sub_23C6D55A8();
  uint64_t v236 = v235;
  sub_23C6D46B8();
  id v237 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v238 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v239 = sub_23C41B6F8(v231, v233, v234, v236, 0, 0, v73, v71);
  id v240 = objc_allocWithZone(MEMORY[0x263F86890]);
  *(void *)(v229 + 32) = sub_23C412864(0xD00000000000001DLL, 0x800000023C72A540, v239);
  uint64_t v241 = sub_23C6D55A8();
  uint64_t v243 = v242;
  uint64_t v244 = sub_23C6D55A8();
  uint64_t v246 = v245;
  sub_23C6D46B8();
  id v247 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v248 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v249 = sub_23C41B6F8(v241, v243, v244, v246, 0, 0, v73, v71);
  id v250 = objc_allocWithZone(MEMORY[0x263F86890]);
  *(void *)(v229 + 40) = sub_23C412864(0xD000000000000020, 0x800000023C72A590, v249);
  uint64_t v251 = sub_23C6D55A8();
  uint64_t v253 = v252;
  uint64_t v254 = sub_23C6D55A8();
  uint64_t v256 = v255;
  sub_23C6D46B8();
  id v257 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v258 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v259 = sub_23C41B6F8(v251, v253, v254, v256, 0, 0, v73, v71);
  id v260 = objc_allocWithZone(MEMORY[0x263F86890]);
  *(void *)(v229 + 48) = sub_23C412864(0xD000000000000033, 0x800000023C72A5F0, v259);
  uint64_t v261 = sub_23C6D55A8();
  uint64_t v263 = v262;
  uint64_t v264 = sub_23C6D55A8();
  uint64_t v266 = v265;
  sub_23C6D46B8();
  id v267 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v268 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v269 = sub_23C41B6F8(v261, v263, v264, v266, 0, 0, v73, v71);
  id v270 = objc_allocWithZone(MEMORY[0x263F86890]);
  *(void *)(v229 + 56) = sub_23C412864(0xD000000000000026, 0x800000023C72A670, v269);
  uint64_t v271 = sub_23C6D55A8();
  uint64_t v273 = v272;
  uint64_t v274 = sub_23C6D55A8();
  uint64_t v276 = v275;
  sub_23C6D46B8();
  id v277 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v278 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v279 = sub_23C41B6F8(v271, v273, v274, v276, 0, 0, v73, v71);
  id v280 = objc_allocWithZone(MEMORY[0x263F86890]);
  *(void *)(v229 + 64) = sub_23C412864(0xD00000000000001CLL, 0x800000023C72A6D0, v279);
  uint64_t v304 = v229;
  sub_23C6D56B8();
  uint64_t v281 = v302;
  id v282 = sub_23C411024();
  uint64_t v283 = v303;
  v303[60] = v282;
  id v284 = (void *)*MEMORY[0x263F873E8];
  v283[63] = v281;
  v283[64] = v284;
  v283[68] = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA6F30);
  v283[65] = MEMORY[0x263F8EE78];
  type metadata accessor for Key(0);
  sub_23C375C5C((unint64_t *)&qword_26AEEE8F0, type metadata accessor for Key);
  id v285 = v284;
  uint64_t v286 = sub_23C6D5428();
  return sub_23C41A1C0(v286);
}

uint64_t sub_23C41283C()
{
  return sub_23C4110AC();
}

id sub_23C412864(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = (void *)sub_23C6D5528();
  swift_bridgeObjectRelease();
  id v6 = objc_msgSend(v3, sel_initWithKey_summaryString_, v5, a3);

  return v6;
}

uint64_t CMMotionActivity.isEmpty.getter()
{
  if ((objc_msgSend(v0, sel_stationary) & 1) != 0
    || (objc_msgSend(v0, sel_walking) & 1) != 0
    || (objc_msgSend(v0, sel_running) & 1) != 0
    || (objc_msgSend(v0, sel_cycling) & 1) != 0
    || (objc_msgSend(v0, sel_automotive) & 1) != 0)
  {
    return 0;
  }
  else
  {
    return objc_msgSend(v0, sel_unknown) ^ 1;
  }
}

uint64_t CMMotionActivity.debugString.getter()
{
  objc_msgSend(v0, sel_confidence);
  sub_23C6D5B68();
  sub_23C6D55F8();
  objc_msgSend(v0, sel_unknown);
  OUTLINED_FUNCTION_1_13();
  swift_bridgeObjectRelease();
  sub_23C6D55F8();
  OUTLINED_FUNCTION_2_14((int)objc_msgSend(v0, sel_stationary));
  OUTLINED_FUNCTION_1_13();
  swift_bridgeObjectRelease();
  OUTLINED_FUNCTION_0_10();
  OUTLINED_FUNCTION_2_14((int)objc_msgSend(v0, sel_walking));
  OUTLINED_FUNCTION_1_13();
  swift_bridgeObjectRelease();
  OUTLINED_FUNCTION_0_10();
  OUTLINED_FUNCTION_2_14((int)objc_msgSend(v0, sel_running));
  OUTLINED_FUNCTION_1_13();
  swift_bridgeObjectRelease();
  OUTLINED_FUNCTION_0_10();
  OUTLINED_FUNCTION_2_14((int)objc_msgSend(v0, sel_cycling));
  OUTLINED_FUNCTION_1_13();
  swift_bridgeObjectRelease();
  sub_23C6D55F8();
  OUTLINED_FUNCTION_2_14((int)objc_msgSend(v0, sel_automotive));
  sub_23C6D55F8();
  swift_bridgeObjectRelease();
  sub_23C6D55F8();
  sub_23C6D55F8();
  swift_bridgeObjectRelease();
  return 0;
}

uint64_t sub_23C412C1C(uint64_t a1)
{
  if (a1 < 16) {
    return 0;
  }
  sub_23C6D5B68();
  return 0;
}

uint64_t OUTLINED_FUNCTION_0_10()
{
  return sub_23C6D55F8();
}

uint64_t OUTLINED_FUNCTION_2_14(int a1)
{
  if (a1) {
    return v1;
  }
  else {
    return v2;
  }
}

uint64_t sub_23C412C8C()
{
  return MEMORY[0x270F86188](0xD000000000000017, 0x800000023C72A720, sub_23C412CC0, 0);
}

id sub_23C412CC0()
{
  uint64_t v0 = sub_23C6D45B8();
  MEMORY[0x270FA5388](v0 - 8);
  uint64_t v2 = (char *)v136 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v3 = sub_23C6D46E8();
  MEMORY[0x270FA5388](v3 - 8);
  uint64_t v5 = (char *)v136 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v138 = sub_23C369F80(0, (unint64_t *)&unk_268BA5C90);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEEE910);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_23C6F6A60;
  BOOL v7 = (void *)*MEMORY[0x263F870A0];
  uint64_t v8 = MEMORY[0x263F8D310];
  *(void *)(inited + 32) = *MEMORY[0x263F870A0];
  *(void *)(inited + 40) = 0x7463414C52554657;
  *(void *)(inited + 48) = 0xEB000000006E6F69;
  uint64_t v9 = (void *)*MEMORY[0x263F87110];
  *(void *)(inited + 64) = v8;
  *(void *)(inited + 72) = v9;
  id v10 = v7;
  id v11 = v9;
  uint64_t v12 = sub_23C6D55A8();
  uint64_t v14 = v13;
  uint64_t v15 = sub_23C6D55A8();
  uint64_t v17 = v16;
  sub_23C6D46B8();
  if (qword_268BA5B80 != -1) {
    swift_once();
  }
  id v18 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v19 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v20 = sub_23C41B6F8(v12, v14, v15, v17, 0, 0, (uint64_t)v5, (uint64_t)v2);
  uint64_t v21 = sub_23C369F80(0, (unint64_t *)&unk_268BA5CA0);
  uint64_t v141 = v21;
  *(void *)(inited + 80) = v20;
  uint64_t v22 = (void *)*MEMORY[0x263F870F8];
  *(void *)(inited + 104) = v21;
  *(void *)(inited + 112) = v22;
  uint64_t v23 = MEMORY[0x263F8D4F8];
  *(unsigned char *)(inited + 120) = 1;
  uint64_t v140 = v2;
  uint64_t v24 = (void *)*MEMORY[0x263F87190];
  *(void *)(inited + 144) = v23;
  *(void *)(inited + 152) = v24;
  uint64_t v137 = sub_23C369F80(0, (unint64_t *)&unk_268BA6EE0);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CB0);
  uint64_t v25 = swift_initStackObject();
  *(_OWORD *)(v25 + 16) = xmmword_23C6F6A70;
  id v26 = (void *)*MEMORY[0x263F871A8];
  *(void *)(v25 + 32) = *MEMORY[0x263F871A8];
  id v27 = v22;
  id v28 = v24;
  id v29 = v26;
  uint64_t v30 = sub_23C6D55A8();
  uint64_t v32 = v31;
  uint64_t v33 = sub_23C6D55A8();
  uint64_t v35 = v34;
  sub_23C6D46B8();
  id v36 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v37 = (uint64_t)v140;
  sub_23C6D4598();

  id v38 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v39 = sub_23C41B6F8(v30, v32, v33, v35, 0, 0, (uint64_t)v5, v37);
  *(void *)(v25 + 64) = v141;
  *(void *)(v25 + 40) = v39;
  type metadata accessor for DescriptionKey(0);
  sub_23C375C5C((unint64_t *)&unk_268BA6EF0, type metadata accessor for DescriptionKey);
  uint64_t v139 = MEMORY[0x263F8EE58] + 8;
  uint64_t v40 = sub_23C6D5428();
  uint64_t v41 = v137;
  *(void *)(inited + 160) = sub_23C41A078(v40);
  id v42 = (void *)*MEMORY[0x263F870D0];
  *(void *)(inited + 184) = v41;
  *(void *)(inited + 192) = v42;
  *(void *)(inited + 200) = 1953392980;
  *(void *)(inited + 208) = 0xE400000000000000;
  id v43 = (void *)*MEMORY[0x263F870E8];
  uint64_t v44 = MEMORY[0x263F8D310];
  *(void *)(inited + 224) = MEMORY[0x263F8D310];
  *(void *)(inited + 232) = v43;
  uint64_t v45 = (void **)MEMORY[0x263F870E0];
  *(void *)(inited + 240) = 1802398060;
  *(void *)(inited + 248) = 0xE400000000000000;
  uint64_t v46 = *v45;
  *(void *)(inited + 264) = v44;
  *(void *)(inited + 272) = v46;
  *(void *)(inited + 280) = 1702194242;
  *(void *)(inited + 288) = 0xE400000000000000;
  uint64_t v47 = (void *)*MEMORY[0x263F87120];
  *(void *)(inited + 304) = v44;
  *(void *)(inited + 312) = v47;
  id v48 = v42;
  id v49 = v43;
  id v50 = v46;
  id v51 = v47;
  uint64_t v52 = sub_23C6D55A8();
  uint64_t v54 = v53;
  uint64_t v55 = sub_23C6D55A8();
  uint64_t v57 = v56;
  sub_23C6D46B8();
  id v58 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v59 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(inited + 320) = sub_23C41B6F8(v52, v54, v55, v57, 0, 0, (uint64_t)v5, v37);
  uint64_t v60 = (void *)*MEMORY[0x263F872B0];
  uint64_t v61 = v141;
  *(void *)(inited + 344) = v141;
  *(void *)(inited + 352) = v60;
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CC0);
  uint64_t v62 = swift_initStackObject();
  *(_OWORD *)(v62 + 16) = xmmword_23C6F6A80;
  *(void *)(v62 + 32) = 0x75736F6C63736944;
  *(void *)(v62 + 40) = 0xEF6C6576654C6572;
  *(void *)(v62 + 48) = 0x63696C627550;
  *(void *)(v62 + 56) = 0xE600000000000000;
  *(void *)(v62 + 72) = MEMORY[0x263F8D310];
  *(void *)(v62 + 80) = 0x656C7069746C754DLL;
  *(void *)(v62 + 88) = 0xE800000000000000;
  *(unsigned char *)(v62 + 96) = 1;
  *(void *)(v62 + 120) = MEMORY[0x263F8D4F8];
  *(void *)(v62 + 128) = 0x614E74757074754FLL;
  *(void *)(v62 + 136) = 0xEA0000000000656DLL;
  id v63 = v60;
  uint64_t v137 = sub_23C6D55A8();
  uint64_t v65 = v64;
  uint64_t v66 = sub_23C6D55A8();
  uint64_t v68 = v67;
  sub_23C6D46B8();
  id v69 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v70 = (uint64_t)v140;
  sub_23C6D4598();

  id v71 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v72 = v66;
  uint64_t v73 = (uint64_t)v5;
  *(void *)(v62 + 144) = sub_23C41B6F8(v137, v65, v72, v68, 0, 0, (uint64_t)v5, v70);
  *(void *)(v62 + 168) = v61;
  *(void *)(v62 + 176) = 0x7365707954;
  *(void *)(v62 + 184) = 0xE500000000000000;
  *(void *)(v62 + 216) = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F00);
  *(void *)(v62 + 192) = &unk_26EFFCD70;
  uint64_t v74 = MEMORY[0x263F8D310];
  uint64_t v75 = sub_23C6D5428();
  uint64_t v76 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA5CD0);
  *(void *)(inited + 360) = v75;
  uint64_t v77 = (void *)*MEMORY[0x263F87130];
  *(void *)(inited + 384) = v76;
  *(void *)(inited + 392) = v77;
  __swift_instantiateConcreteTypeFromMangledName(&qword_268BA6C30);
  uint64_t v137 = swift_allocObject();
  *(_OWORD *)(v137 + 16) = xmmword_23C6F77E0;
  v136[1] = sub_23C369F80(0, &qword_268BA5CE0);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CE8);
  uint64_t v78 = swift_allocObject();
  *(_OWORD *)(v78 + 16) = xmmword_23C6F8490;
  id v79 = (void *)*MEMORY[0x263F872C0];
  *(void *)(v78 + 32) = *MEMORY[0x263F872C0];
  *(unsigned char *)(v78 + 40) = 1;
  id v80 = (void *)*MEMORY[0x263F872D8];
  *(void *)(v78 + 64) = MEMORY[0x263F8D4F8];
  *(void *)(v78 + 72) = v80;
  id v81 = (void **)MEMORY[0x263F87350];
  strcpy((char *)(v78 + 80), "WFURLParameter");
  *(unsigned char *)(v78 + 95) = -18;
  id v82 = *v81;
  *(void *)(v78 + 104) = v74;
  *(void *)(v78 + 112) = v82;
  strcpy((char *)(v78 + 120), "WFURLActionURL");
  *(unsigned char *)(v78 + 135) = -18;
  id v83 = (void *)*MEMORY[0x263F87360];
  *(void *)(v78 + 144) = v74;
  *(void *)(v78 + 152) = v83;
  id v84 = v77;
  id v85 = v79;
  id v86 = v80;
  id v87 = v82;
  id v88 = v83;
  uint64_t v89 = sub_23C6D55A8();
  uint64_t v91 = v90;
  uint64_t v92 = sub_23C6D55A8();
  uint64_t v94 = v93;
  sub_23C6D46B8();
  id v95 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v96 = (uint64_t)v140;
  sub_23C6D4598();

  id v97 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v98 = v94;
  uint64_t v99 = v73;
  *(void *)(v78 + 160) = sub_23C41B6F8(v89, v91, v92, v98, 0, 0, v73, v96);
  id v100 = (void *)*MEMORY[0x263F87380];
  uint64_t v101 = v141;
  *(void *)(v78 + 184) = v141;
  *(void *)(v78 + 192) = v100;
  id v102 = v100;
  v136[0] = sub_23C6D55A8();
  uint64_t v104 = v103;
  uint64_t v105 = sub_23C6D55A8();
  uint64_t v107 = v106;
  uint64_t v108 = v99;
  sub_23C6D46B8();
  id v109 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v110 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v111 = v108;
  id v112 = sub_23C41B6F8(v136[0], v104, v105, v107, 0, 0, v108, v96);
  *(void *)(v78 + 224) = v101;
  *(void *)(v78 + 200) = v112;
  _s3__C3KeyVMa_0(0);
  sub_23C375C5C(&qword_26AEEE340, _s3__C3KeyVMa_0);
  uint64_t v113 = sub_23C6D5428();
  id v114 = sub_23C41A0C0(v113);
  uint64_t v115 = v137;
  *(void *)(v137 + 32) = v114;
  uint64_t v142 = v115;
  sub_23C6D56B8();
  uint64_t v116 = v142;
  uint64_t v117 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F20);
  *(void *)(inited + 400) = v116;
  id v118 = (void *)*MEMORY[0x263F87128];
  *(void *)(inited + 424) = v117;
  *(void *)(inited + 432) = v118;
  id v119 = v118;
  uint64_t v120 = sub_23C6D55A8();
  uint64_t v122 = v121;
  uint64_t v123 = sub_23C6D55A8();
  uint64_t v125 = v124;
  sub_23C6D46B8();
  id v126 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v127 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v128 = sub_23C41B6F8(v120, v122, v123, v125, 0, 0, v111, v96);
  id v129 = objc_msgSend(objc_allocWithZone(MEMORY[0x263F86888]), sel_initWithString_, v128);

  uint64_t v130 = sub_23C369F80(0, &qword_268BA5D08);
  uint64_t v131 = (void **)MEMORY[0x263F87108];
  *(void *)(inited + 440) = v129;
  uint64_t v132 = *v131;
  *(void *)(inited + 464) = v130;
  *(void *)(inited + 472) = v132;
  *(void *)(inited + 504) = MEMORY[0x263F8D4F8];
  *(unsigned char *)(inited + 480) = 1;
  type metadata accessor for Key(0);
  sub_23C375C5C((unint64_t *)&qword_26AEEE8F0, type metadata accessor for Key);
  id v133 = v132;
  uint64_t v134 = sub_23C6D5428();
  return sub_23C41A1C0(v134);
}

uint64_t sub_23C41385C()
{
  return sub_23C412C8C();
}

uint64_t sub_23C413884()
{
  return MEMORY[0x270F86188](0xD00000000000002DLL, 0x800000023C72A890, sub_23C4138B8, 0);
}

id sub_23C4138B8()
{
  uint64_t v53 = sub_23C6D4C28();
  uint64_t v51 = *(void *)(v53 - 8);
  MEMORY[0x270FA5388](v53);
  uint64_t v54 = (void *)((char *)&v50 - ((v0 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v1 = sub_23C6D45B8();
  MEMORY[0x270FA5388](v1 - 8);
  uint64_t v3 = (char *)&v50 - ((v2 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v4 = sub_23C6D46E8();
  MEMORY[0x270FA5388](v4 - 8);
  id v6 = (char *)&v50 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v52 = sub_23C369F80(0, (unint64_t *)&unk_268BA5C90);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEEE910);
  uint64_t inited = swift_initStackObject();
  uint64_t v8 = (void **)MEMORY[0x263F870A0];
  *(_OWORD *)(inited + 16) = xmmword_23C6F7FC0;
  uint64_t v9 = *v8;
  uint64_t v10 = MEMORY[0x263F8D310];
  *(void *)(inited + 32) = v9;
  *(void *)(inited + 40) = 0xD00000000000001ALL;
  *(void *)(inited + 48) = 0x800000023C722B50;
  id v11 = (void *)*MEMORY[0x263F87090];
  *(void *)(inited + 64) = v10;
  *(void *)(inited + 72) = v11;
  id v12 = v9;
  id v13 = v11;
  uint64_t v14 = sub_23C6D5428();
  uint64_t v15 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA5CF8);
  *(void *)(inited + 80) = v14;
  uint64_t v16 = (void *)*MEMORY[0x263F87098];
  *(void *)(inited + 104) = v15;
  *(void *)(inited + 112) = v16;
  id v17 = v16;
  uint64_t v18 = sub_23C6D55A8();
  uint64_t v20 = v19;
  uint64_t v21 = sub_23C6D55A8();
  uint64_t v23 = v22;
  sub_23C6D46B8();
  if (qword_268BA5B80 != -1) {
    swift_once();
  }
  id v24 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v25 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v26 = sub_23C41B6F8(v18, v20, v21, v23, 0, 0, (uint64_t)v6, (uint64_t)v3);
  uint64_t v27 = sub_23C369F80(0, (unint64_t *)&unk_268BA5CA0);
  *(void *)(inited + 120) = v26;
  id v28 = (void *)*MEMORY[0x263F870B0];
  *(void *)(inited + 144) = v27;
  *(void *)(inited + 152) = v28;
  uint64_t v29 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F00);
  *(void *)(inited + 160) = &unk_26EFFCDE0;
  uint64_t v30 = (void *)*MEMORY[0x263F870D8];
  *(void *)(inited + 184) = v29;
  *(void *)(inited + 192) = v30;
  *(void *)(inited + 224) = v10;
  *(void *)(inited + 200) = 1769105747;
  *(void *)(inited + 208) = 0xE400000000000000;
  id v31 = v28;
  id v32 = v30;
  uint64_t v33 = sub_23C6D5528();
  *(void *)(inited + 264) = v10;
  *(void *)(inited + 232) = v33;
  *(void *)(inited + 240) = 0xD000000000000060;
  *(void *)(inited + 248) = 0x800000023C72A8E0;
  *(void *)(inited + 272) = sub_23C6D5528();
  __swift_instantiateConcreteTypeFromMangledName(&qword_268BA5CD8);
  uint64_t v34 = swift_initStackObject();
  long long v50 = xmmword_23C6F6A70;
  *(_OWORD *)(v34 + 16) = xmmword_23C6F6A70;
  *(void *)(v34 + 32) = 0x6574617473;
  *(void *)(v34 + 40) = 0xE500000000000000;
  sub_23C369F80(0, &qword_268BA5CE0);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CE8);
  uint64_t v35 = swift_initStackObject();
  *(_OWORD *)(v35 + 16) = v50;
  id v36 = (void *)*MEMORY[0x263F87350];
  *(void *)(v35 + 64) = v10;
  *(void *)(v35 + 32) = v36;
  *(void *)(v35 + 40) = 0x65756C61566E4FLL;
  *(void *)(v35 + 48) = 0xE700000000000000;
  _s3__C3KeyVMa_0(0);
  sub_23C387008(&qword_26AEEE340, _s3__C3KeyVMa_0);
  id v37 = v36;
  uint64_t v38 = sub_23C6D5428();
  *(void *)(v34 + 48) = sub_23C41A0C0(v38);
  uint64_t v39 = sub_23C6D5428();
  uint64_t v40 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA5D00);
  *(void *)(inited + 280) = v39;
  uint64_t v41 = (void *)*MEMORY[0x263F873E8];
  *(void *)(inited + 304) = v40;
  *(void *)(inited + 312) = v41;
  __swift_instantiateConcreteTypeFromMangledName(&qword_268BA6C30);
  uint64_t v42 = swift_allocObject();
  *(_OWORD *)(v42 + 16) = xmmword_23C6F77E0;
  uint64_t v43 = v53;
  uint64_t v44 = v54;
  void *v54 = 2;
  (*(void (**)(void *, void, uint64_t))(v51 + 104))(v44, *MEMORY[0x263F866C8], v43);
  id v45 = objc_allocWithZone((Class)sub_23C6D4C48());
  id v46 = v41;
  *(void *)(v42 + 32) = sub_23C6D4C38();
  uint64_t v55 = v42;
  sub_23C6D56B8();
  uint64_t v47 = v55;
  *(void *)(inited + 344) = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA60A0);
  *(void *)(inited + 320) = v47;
  type metadata accessor for Key(0);
  sub_23C387008((unint64_t *)&qword_26AEEE8F0, type metadata accessor for Key);
  uint64_t v48 = sub_23C6D5428();
  return sub_23C41A1C0(v48);
}

uint64_t sub_23C413EC4()
{
  return sub_23C413884();
}

uint64_t sub_23C413EEC(uint64_t a1, uint64_t a2)
{
  __swift_instantiateConcreteTypeFromMangledName(&qword_268BA7800);
  MEMORY[0x270FA5388]();
  uint64_t v5 = (char *)&v10 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = sub_23C6D5788();
  __swift_storeEnumTagSinglePayload((uint64_t)v5, 1, 1, v6);
  BOOL v7 = (void *)swift_allocObject();
  v7[2] = 0;
  v7[3] = 0;
  v7[4] = a1;
  v7[5] = a2;
  uint64_t v8 = (void *)swift_allocObject();
  v8[2] = 0;
  v8[3] = 0;
  v8[4] = &unk_268BA7810;
  v8[5] = v7;
  sub_23C41589C((uint64_t)v5, (uint64_t)&unk_268BA7820, (uint64_t)v8);
  return swift_release();
}

uint64_t sub_23C413FF0()
{
  OUTLINED_FUNCTION_12();
  v1[2] = v0;
  v1[3] = swift_getObjectType();
  uint64_t v2 = sub_23C6D45B8();
  v1[4] = v2;
  v1[5] = *(void *)(v2 - 8);
  v1[6] = swift_task_alloc();
  sub_23C6D5768();
  v1[7] = sub_23C6D5758();
  uint64_t v4 = sub_23C6D5718();
  v1[8] = v4;
  v1[9] = v3;
  return MEMORY[0x270FA2498](sub_23C4140EC, v4, v3);
}

uint64_t sub_23C4140EC()
{
  OUTLINED_FUNCTION_5_0();
  sub_23C369F80(0, (unint64_t *)&qword_26AEED700);
  uint64_t v1 = sub_23C6D5A08();
  if (v1)
  {
    uint64_t v2 = (void *)v1;
    sub_23C6D5558();
  }
  sub_23C414404(0, 0);
  swift_bridgeObjectRelease();
  uint64_t v3 = (void *)swift_task_alloc();
  *(void *)(v0 + 80) = v3;
  *uint64_t v3 = v0;
  v3[1] = sub_23C414204;
  uint64_t v4 = *(void *)(v0 + 48);
  return sub_23C41456C(v4);
}

uint64_t sub_23C414204()
{
  OUTLINED_FUNCTION_5_0();
  OUTLINED_FUNCTION_1();
  *(void *)(v2 + 88) = v0;
  swift_task_dealloc();
  uint64_t v3 = *(void *)(v1 + 72);
  uint64_t v4 = *(void *)(v1 + 64);
  if (v0) {
    uint64_t v5 = sub_23C41438C;
  }
  else {
    uint64_t v5 = sub_23C414318;
  }
  return MEMORY[0x270FA2498](v5, v4, v3);
}

uint64_t sub_23C414318()
{
  OUTLINED_FUNCTION_5_0();
  swift_release();
  uint64_t v0 = OUTLINED_FUNCTION_31_2();
  v1(v0);
  swift_task_dealloc();
  OUTLINED_FUNCTION_6_0();
  return v2();
}

uint64_t sub_23C41438C()
{
  OUTLINED_FUNCTION_5_0();
  swift_release();
  uint64_t v0 = OUTLINED_FUNCTION_31_2();
  v1(v0);
  swift_task_dealloc();
  OUTLINED_FUNCTION_34();
  return v2();
}

void sub_23C414404(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v4 = self;
    __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA7860);
    uint64_t inited = swift_initStackObject();
    *(_OWORD *)(inited + 16) = xmmword_23C6F6A70;
    *(void *)(inited + 32) = 0x686372616573;
    *(void *)(inited + 40) = 0xE600000000000000;
    *(void *)(inited + 48) = a1;
    *(void *)(inited + 56) = a2;
    sub_23C6D41A8();
    sub_23C6D5428();
    uint64_t v6 = (void *)sub_23C6D5408();
    swift_bridgeObjectRelease();
    id v7 = objc_msgSend(v4, sel_passwordManagerURLWithParameters_, v6);

    sub_23C6D4598();
  }
  else
  {
    id v8 = objc_msgSend(self, sel_passwordManagerURL);
    sub_23C6D4598();
  }
}

uint64_t sub_23C41456C(uint64_t a1)
{
  v1[2] = a1;
  v1[3] = sub_23C6D5768();
  v1[4] = sub_23C6D5758();
  uint64_t v3 = sub_23C6D5718();
  v1[5] = v3;
  v1[6] = v2;
  return MEMORY[0x270FA2498](sub_23C414608, v3, v2);
}

uint64_t sub_23C414608()
{
  OUTLINED_FUNCTION_5_0();
  uint64_t v1 = v0[2];
  uint64_t v2 = sub_23C6D5758();
  v0[7] = v2;
  uint64_t v3 = swift_task_alloc();
  v0[8] = v3;
  *(void *)(v3 + 16) = v1;
  uint64_t v4 = (void *)swift_task_alloc();
  v0[9] = v4;
  *uint64_t v4 = v0;
  v4[1] = sub_23C41470C;
  uint64_t v5 = MEMORY[0x263F8EE60] + 8;
  uint64_t v6 = MEMORY[0x263F8F500];
  return MEMORY[0x270FA2360](v4, v2, v6, 0x284C52556E65706FLL, 0xEB00000000293A5FLL, sub_23C415CE8, v3, v5);
}

uint64_t sub_23C41470C()
{
  OUTLINED_FUNCTION_12();
  OUTLINED_FUNCTION_0();
  uint64_t v3 = v2;
  uint64_t v4 = *v1;
  OUTLINED_FUNCTION_2();
  *uint64_t v5 = v4;
  v3[10] = v0;
  swift_task_dealloc();
  if (v0)
  {
    uint64_t v6 = v3[5];
    uint64_t v7 = v3[6];
    uint64_t v8 = sub_23C414858;
  }
  else
  {
    swift_release();
    swift_task_dealloc();
    uint64_t v6 = v3[5];
    uint64_t v7 = v3[6];
    uint64_t v8 = sub_23C414800;
  }
  return MEMORY[0x270FA2498](v8, v6, v7);
}

uint64_t sub_23C414800()
{
  OUTLINED_FUNCTION_12();
  swift_release();
  OUTLINED_FUNCTION_6_0();
  return v0();
}

uint64_t sub_23C414858()
{
  OUTLINED_FUNCTION_12();
  swift_release();
  swift_release();
  swift_task_dealloc();
  OUTLINED_FUNCTION_34();
  return v0();
}

uint64_t sub_23C414950(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3[3] = a2;
  v3[4] = a3;
  v3[2] = a1;
  sub_23C6D5768();
  v3[5] = sub_23C6D5758();
  uint64_t v5 = sub_23C6D5718();
  return MEMORY[0x270FA2498](sub_23C4149EC, v5, v4);
}

uint64_t sub_23C4149EC()
{
  OUTLINED_FUNCTION_5_0();
  uint64_t v1 = (void *)v0[4];
  uint64_t v3 = (void *)v0[2];
  uint64_t v2 = (const void *)v0[3];
  swift_release();
  v0[6] = _Block_copy(v2);
  id v4 = v3;
  id v5 = v1;
  uint64_t v6 = (void *)swift_task_alloc();
  v0[7] = v6;
  *uint64_t v6 = v0;
  v6[1] = sub_23C414AA4;
  return sub_23C413FF0();
}

uint64_t sub_23C414AA4()
{
  uint64_t v3 = v0;
  OUTLINED_FUNCTION_1();
  uint64_t v5 = v4;
  OUTLINED_FUNCTION_2();
  *uint64_t v6 = v5;
  uint64_t v7 = (void *)v1[4];
  uint64_t v8 = (void *)v1[2];
  uint64_t v9 = *v2;
  *uint64_t v6 = *v2;
  swift_task_dealloc();

  uint64_t v10 = v1[6];
  if (v3)
  {
    id v11 = (void *)sub_23C6D44B8();

    (*(void (**)(uint64_t, void *))(v10 + 16))(v10, v11);
  }
  else
  {
    (*(void (**)(uint64_t, void))(v10 + 16))(v10, 0);
  }
  _Block_release(*(const void **)(v5 + 48));
  id v12 = *(uint64_t (**)(void))(v9 + 8);
  return v12();
}

void sub_23C414C14(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = a1;
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA7850);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = *(void *)(v5 + 64);
  uint64_t v7 = MEMORY[0x270FA5388](v4);
  id v25 = (char *)&v22 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x270FA5388](v7);
  uint64_t v9 = (char *)&v22 - v8;
  uint64_t v10 = sub_23C6D45B8();
  uint64_t v11 = *(void *)(v10 - 8);
  MEMORY[0x270FA5388](v10);
  id v13 = (char *)&v22 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v23 = v13;
  uint64_t v24 = sub_23C369F80(0, &qword_268BA7858);
  (*(void (**)(char *, uint64_t, uint64_t))(v11 + 16))(v13, a2, v10);
  uint64_t v14 = *(void (**)(char *, uint64_t, uint64_t))(v5 + 16);
  v14(v9, a1, v4);
  unint64_t v15 = (*(unsigned __int8 *)(v5 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v5 + 80);
  uint64_t v16 = swift_allocObject();
  id v17 = *(void (**)(unint64_t, char *, uint64_t))(v5 + 32);
  v17(v16 + v15, v9, v4);
  uint64_t v18 = v25;
  v14(v25, v22, v4);
  uint64_t v19 = swift_allocObject();
  v17(v19 + v15, v18, v4);
  id v20 = sub_23C414F7C((uint64_t)v23, 0, 0, 0, 0, sub_23C415CF4, v16, sub_23C415DF0, v19);
  id v21 = objc_msgSend(self, sel_sharedManager);
  objc_msgSend(v21, sel_performRequest_, v20);
}

uint64_t sub_23C414EF8()
{
  return sub_23C6D5738();
}

void *sub_23C414F2C(void *result)
{
  if (result)
  {
    id v1 = result;
    __swift_instantiateConcreteTypeFromMangledName(&qword_268BA7850);
    return (void *)sub_23C6D5728();
  }
  else
  {
    __break(1u);
  }
  return result;
}

id sub_23C414F7C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, void *a8, uint64_t a9)
{
  uint64_t v16 = (void *)sub_23C6D4568();
  if (a5)
  {
    id v17 = (void *)sub_23C6D5528();
    swift_bridgeObjectRelease();
  }
  else
  {
    id v17 = 0;
  }
  if (!a6)
  {
    uint64_t v18 = 0;
    if (!a8) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  id v26 = a6;
  uint64_t v27 = a7;
  uint64_t v22 = MEMORY[0x263EF8330];
  uint64_t v23 = 1107296256;
  uint64_t v24 = sub_23C415264;
  id v25 = &block_descriptor_30_0;
  uint64_t v18 = _Block_copy(&v22);
  swift_release();
  if (a8)
  {
LABEL_6:
    id v26 = a8;
    uint64_t v27 = a9;
    uint64_t v22 = MEMORY[0x263EF8330];
    uint64_t v23 = 1107296256;
    uint64_t v24 = sub_23C4152FC;
    id v25 = &block_descriptor_13;
    a8 = _Block_copy(&v22);
    swift_release();
  }
LABEL_7:
  id v19 = objc_msgSend((id)swift_getObjCClassFromMetadata(), sel_requestWithURL_scheme_userInterface_bundleIdentifier_successHandler_failureHandler_, v16, a2, a3, v17, v18, a8);
  _Block_release(a8);
  _Block_release(v18);

  swift_unknownObjectRelease();
  uint64_t v20 = sub_23C6D45B8();
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v20 - 8) + 8))(a1, v20);
  return v19;
}

id sub_23C415174(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v5 = v4;
  ObjectType = (objc_class *)swift_getObjectType();
  uint64_t v9 = (void *)sub_23C6D5528();
  swift_bridgeObjectRelease();
  if (a4)
  {
    __swift_instantiateConcreteTypeFromMangledName(&qword_268BA62F0);
    uint64_t v10 = (void *)sub_23C6D5408();
    swift_bridgeObjectRelease();
  }
  else
  {
    uint64_t v10 = 0;
  }
  v14.receiver = v5;
  v14.super_class = ObjectType;
  id v11 = objc_msgSendSuper2(&v14, sel_initWithIdentifier_definition_serializedParameters_, v9, a3, v10);

  id v12 = v11;
  if (v12) {

  }
  return v12;
}

uint64_t sub_23C415264(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void (**)(uint64_t, uint64_t))(a1 + 32);
  if (a2) {
    uint64_t v5 = sub_23C6D5418();
  }
  else {
    uint64_t v5 = 0;
  }
  sub_23C6D41B8();
  v4(v5, a3);
  swift_release();
  return swift_bridgeObjectRelease();
}

void sub_23C4152FC(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void (**)(void *))(a1 + 32);
  sub_23C6D41B8();
  id v4 = a2;
  v3(a2);
  swift_release();
}

uint64_t type metadata accessor for WFShowPasswordsAction()
{
  return self;
}

uint64_t sub_23C415444()
{
  _Block_release(*(const void **)(v0 + 24));
  return MEMORY[0x270FA0238](v0, 40, 7);
}

uint64_t sub_23C41548C()
{
  OUTLINED_FUNCTION_5_0();
  uint64_t v1 = v0[2];
  uint64_t v2 = v0[3];
  uint64_t v3 = v0[4];
  uint64_t v4 = swift_task_alloc();
  uint64_t v5 = (void *)OUTLINED_FUNCTION_8_9(v4);
  *uint64_t v5 = v6;
  v5[1] = sub_23C396D5C;
  uint64_t v7 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))((char *)&dword_268BA77F0 + dword_268BA77F0);
  return v7(v1, v2, v3);
}

uint64_t sub_23C415538(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v6 = (uint64_t (*)(void))((char *)a3 + *a3);
  uint64_t v4 = (void *)swift_task_alloc();
  *(void *)(v3 + 16) = v4;
  *uint64_t v4 = v3;
  v4[1] = sub_23C415E64;
  return v6();
}

uint64_t sub_23C415608()
{
  uint64_t v1 = v0[2];
  uint64_t v2 = v0[3];
  uint64_t v3 = (int *)v0[4];
  uint64_t v4 = swift_task_alloc();
  uint64_t v5 = (void *)OUTLINED_FUNCTION_8_9(v4);
  *uint64_t v5 = v6;
  v5[1] = sub_23C415E64;
  uint64_t v7 = (uint64_t (*)(uint64_t, uint64_t, int *))((char *)&dword_268BA7808 + dword_268BA7808);
  return v7(v1, v2, v3);
}

uint64_t sub_23C4156C4(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v7 = (uint64_t (*)(void))((char *)a4 + *a4);
  uint64_t v5 = (void *)swift_task_alloc();
  *(void *)(v4 + 16) = v5;
  *uint64_t v5 = v4;
  v5[1] = sub_23C415E64;
  return v7();
}

uint64_t objectdestroy_3Tm()
{
  swift_unknownObjectRelease();
  swift_release();
  return MEMORY[0x270FA0238](v0, 48, 7);
}

uint64_t sub_23C4157D4(uint64_t a1)
{
  uint64_t v3 = v1[2];
  uint64_t v4 = v1[3];
  uint64_t v5 = (int *)v1[4];
  uint64_t v6 = swift_task_alloc();
  uint64_t v7 = (void *)OUTLINED_FUNCTION_8_9(v6);
  *uint64_t v7 = v8;
  v7[1] = sub_23C415E64;
  uint64_t v9 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, int *))((char *)&dword_268BA7818 + dword_268BA7818);
  return v9(a1, v3, v4, v5);
}

uint64_t sub_23C41589C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_23C6D5788();
  if (__swift_getEnumTagSinglePayload(a1, 1, v6) == 1)
  {
    sub_23C415A04(a1);
  }
  else
  {
    sub_23C6D5778();
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v6 - 8) + 8))(a1, v6);
  }
  if (*(void *)(a3 + 16))
  {
    swift_getObjectType();
    swift_unknownObjectRetain();
    sub_23C6D5718();
    swift_unknownObjectRelease();
  }
  uint64_t v7 = swift_allocObject();
  *(void *)(v7 + 16) = a2;
  *(void *)(v7 + 24) = a3;
  return swift_task_create();
}

uint64_t sub_23C415A04(uint64_t a1)
{
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA7800);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8))(a1, v2);
  return a1;
}

uint64_t sub_23C415A64(uint64_t a1, int *a2)
{
  uint64_t v6 = (uint64_t (*)(uint64_t))((char *)a2 + *a2);
  uint64_t v4 = (void *)swift_task_alloc();
  *(void *)(v2 + 16) = v4;
  *uint64_t v4 = v2;
  v4[1] = sub_23C415B40;
  return v6(a1);
}

uint64_t sub_23C415B40()
{
  OUTLINED_FUNCTION_12();
  OUTLINED_FUNCTION_0();
  uint64_t v1 = *v0;
  OUTLINED_FUNCTION_2();
  *uint64_t v2 = v1;
  swift_task_dealloc();
  OUTLINED_FUNCTION_6_0();
  return v3();
}

uint64_t sub_23C415C00()
{
  swift_release();
  return MEMORY[0x270FA0238](v0, 32, 7);
}

uint64_t sub_23C415C38()
{
  OUTLINED_FUNCTION_5_0();
  uint64_t v2 = v1;
  uint64_t v3 = *(int **)(v0 + 16);
  uint64_t v4 = swift_task_alloc();
  uint64_t v5 = (void *)OUTLINED_FUNCTION_8_9(v4);
  *uint64_t v5 = v6;
  v5[1] = sub_23C396D5C;
  uint64_t v7 = (uint64_t (*)(uint64_t, int *))((char *)&dword_268BA7828 + dword_268BA7828);
  return v7(v2, v3);
}

void sub_23C415CE8(uint64_t a1)
{
  sub_23C414C14(a1, *(void *)(v1 + 16));
}

uint64_t sub_23C415CF4()
{
  uint64_t v0 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA7850);
  OUTLINED_FUNCTION_3_8(v0);
  return sub_23C414EF8();
}

uint64_t objectdestroy_23Tm()
{
  uint64_t v1 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA7850);
  uint64_t v2 = *(void *)(v1 - 8);
  uint64_t v3 = *(unsigned __int8 *)(v2 + 80);
  uint64_t v4 = (v3 + 16) & ~v3;
  uint64_t v5 = v4 + *(void *)(v2 + 64);
  uint64_t v6 = v3 | 7;
  (*(void (**)(uint64_t, uint64_t))(v2 + 8))(v0 + v4, v1);
  return MEMORY[0x270FA0238](v0, v5, v6);
}

void *sub_23C415DF0(void *a1)
{
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA7850);
  OUTLINED_FUNCTION_3_8(v2);
  return sub_23C414F2C(a1);
}

uint64_t block_copy_helper_11(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return sub_23C6D41B8();
}

uint64_t block_destroy_helper_11()
{
  return swift_release();
}

uint64_t OUTLINED_FUNCTION_8_9(uint64_t result)
{
  *(void *)(v1 + 16) = result;
  return result;
}

uint64_t sub_23C415E74()
{
  return MEMORY[0x270F86188](0xD00000000000001ELL, 0x800000023C72A980, sub_23C415EA8, 0);
}

id sub_23C415EA8()
{
  uint64_t v0 = sub_23C6D45B8();
  MEMORY[0x270FA5388](v0 - 8);
  uint64_t v2 = (char *)v132 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v3 = sub_23C6D46E8();
  MEMORY[0x270FA5388](v3 - 8);
  uint64_t v5 = (char *)v132 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v135 = sub_23C369F80(0, (unint64_t *)&unk_268BA5C90);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEEE910);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_23C6F8210;
  uint64_t v7 = (void *)*MEMORY[0x263F870A0];
  uint64_t v8 = MEMORY[0x263F8D310];
  *(void *)(inited + 32) = *MEMORY[0x263F870A0];
  *(void *)(inited + 40) = 0xD000000000000012;
  *(void *)(inited + 48) = 0x800000023C72A9A0;
  uint64_t v9 = (void *)*MEMORY[0x263F87110];
  *(void *)(inited + 64) = v8;
  *(void *)(inited + 72) = v9;
  id v10 = v7;
  id v11 = v9;
  uint64_t v12 = sub_23C6D55A8();
  uint64_t v14 = v13;
  uint64_t v15 = sub_23C6D55A8();
  uint64_t v17 = v16;
  sub_23C6D46B8();
  if (qword_268BA5B80 != -1) {
    swift_once();
  }
  id v18 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v19 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v20 = sub_23C41B6F8(v12, v14, v15, v17, 0, 0, (uint64_t)v5, (uint64_t)v2);
  uint64_t v21 = sub_23C369F80(0, (unint64_t *)&unk_268BA5CA0);
  uint64_t v138 = v21;
  *(void *)(inited + 80) = v20;
  uint64_t v22 = (void *)*MEMORY[0x263F870F8];
  *(void *)(inited + 104) = v21;
  *(void *)(inited + 112) = v22;
  uint64_t v23 = MEMORY[0x263F8D4F8];
  *(unsigned char *)(inited + 120) = 1;
  uint64_t v24 = (void *)*MEMORY[0x263F87190];
  *(void *)(inited + 144) = v23;
  *(void *)(inited + 152) = v24;
  uint64_t v134 = sub_23C369F80(0, (unint64_t *)&unk_268BA6EE0);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CB0);
  uint64_t v25 = swift_initStackObject();
  *(_OWORD *)(v25 + 16) = xmmword_23C6F6A90;
  uint64_t v136 = v2;
  id v26 = v5;
  uint64_t v27 = (void *)*MEMORY[0x263F87198];
  *(void *)(v25 + 32) = *MEMORY[0x263F87198];
  id v28 = v22;
  id v29 = v24;
  id v30 = v27;
  uint64_t v31 = sub_23C6D55A8();
  uint64_t v33 = v32;
  uint64_t v34 = sub_23C6D55A8();
  uint64_t v36 = v35;
  uint64_t v37 = (uint64_t)v26;
  sub_23C6D46B8();
  id v38 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v39 = (uint64_t)v136;
  sub_23C6D4598();

  id v40 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v41 = v37;
  uint64_t v42 = v37;
  uint64_t v43 = v39;
  *(void *)(v25 + 40) = sub_23C41B6F8(v31, v33, v34, v36, 0, 0, v41, v39);
  uint64_t v44 = (void *)*MEMORY[0x263F871A8];
  uint64_t v45 = v138;
  *(void *)(v25 + 64) = v138;
  *(void *)(v25 + 72) = v44;
  id v46 = v44;
  uint64_t v137 = sub_23C6D55A8();
  uint64_t v48 = v47;
  uint64_t v49 = sub_23C6D55A8();
  uint64_t v51 = v50;
  sub_23C6D46B8();
  id v52 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v53 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v54 = v42;
  id v55 = sub_23C41B6F8(v137, v48, v49, v51, 0, 0, v42, v43);
  *(void *)(v25 + 104) = v45;
  *(void *)(v25 + 80) = v55;
  type metadata accessor for DescriptionKey(0);
  sub_23C375C5C((unint64_t *)&unk_268BA6EF0, type metadata accessor for DescriptionKey);
  uint64_t v137 = MEMORY[0x263F8EE58] + 8;
  uint64_t v56 = sub_23C6D5428();
  uint64_t v57 = v134;
  id v58 = sub_23C41A078(v56);
  id v59 = (void **)MEMORY[0x263F870D0];
  *(void *)(inited + 160) = v58;
  uint64_t v60 = *v59;
  *(void *)(inited + 184) = v57;
  *(void *)(inited + 192) = v60;
  *(void *)(inited + 200) = 0x65676E61724FLL;
  *(void *)(inited + 208) = 0xE600000000000000;
  uint64_t v61 = (void *)*MEMORY[0x263F870E8];
  uint64_t v62 = MEMORY[0x263F8D310];
  *(void *)(inited + 224) = MEMORY[0x263F8D310];
  *(void *)(inited + 232) = v61;
  *(void *)(inited + 240) = 0xD000000000000010;
  *(void *)(inited + 248) = 0x800000023C72AA60;
  id v63 = (void *)*MEMORY[0x263F87120];
  *(void *)(inited + 264) = v62;
  *(void *)(inited + 272) = v63;
  id v64 = v60;
  id v65 = v61;
  id v66 = v63;
  uint64_t v67 = sub_23C6D55A8();
  uint64_t v69 = v68;
  uint64_t v70 = sub_23C6D55A8();
  uint64_t v72 = v71;
  uint64_t v73 = v54;
  sub_23C6D46B8();
  id v74 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v75 = (uint64_t)v136;
  sub_23C6D4598();

  id v76 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v77 = v73;
  *(void *)(inited + 280) = sub_23C41B6F8(v67, v69, v70, v72, 0, 0, v73, v75);
  uint64_t v78 = (void *)*MEMORY[0x263F872B0];
  uint64_t v79 = v138;
  *(void *)(inited + 304) = v138;
  *(void *)(inited + 312) = v78;
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CC0);
  uint64_t v80 = swift_initStackObject();
  long long v133 = xmmword_23C6F6A80;
  *(_OWORD *)(v80 + 16) = xmmword_23C6F6A80;
  *(void *)(v80 + 32) = 0x75736F6C63736944;
  *(void *)(v80 + 40) = 0xEF6C6576654C6572;
  *(void *)(v80 + 48) = 0x63696C627550;
  *(void *)(v80 + 56) = 0xE600000000000000;
  *(void *)(v80 + 72) = MEMORY[0x263F8D310];
  *(void *)(v80 + 80) = 0x656C7069746C754DLL;
  *(void *)(v80 + 88) = 0xE800000000000000;
  *(unsigned char *)(v80 + 96) = 0;
  *(void *)(v80 + 120) = MEMORY[0x263F8D4F8];
  *(void *)(v80 + 128) = 0x614E74757074754FLL;
  *(void *)(v80 + 136) = 0xEA0000000000656DLL;
  id v81 = v78;
  uint64_t v134 = sub_23C6D55A8();
  uint64_t v83 = v82;
  uint64_t v84 = sub_23C6D55A8();
  uint64_t v86 = v85;
  uint64_t v87 = v77;
  v132[0] = v77;
  sub_23C6D46B8();
  id v88 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v89 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v90 = v84;
  uint64_t v91 = v75;
  *(void *)(v80 + 144) = sub_23C41B6F8(v134, v83, v90, v86, 0, 0, v87, v75);
  *(void *)(v80 + 168) = v79;
  *(void *)(v80 + 176) = 0x7365707954;
  *(void *)(v80 + 184) = 0xE500000000000000;
  *(void *)(v80 + 216) = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F00);
  *(void *)(v80 + 192) = &unk_26EFFCE10;
  uint64_t v92 = MEMORY[0x263F8D310];
  uint64_t v93 = sub_23C6D5428();
  uint64_t v94 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA5CD0);
  *(void *)(inited + 320) = v93;
  id v95 = (void *)*MEMORY[0x263F87130];
  *(void *)(inited + 344) = v94;
  *(void *)(inited + 352) = v95;
  __swift_instantiateConcreteTypeFromMangledName(&qword_268BA6C30);
  uint64_t v134 = swift_allocObject();
  *(_OWORD *)(v134 + 16) = xmmword_23C6F77E0;
  v132[1] = sub_23C369F80(0, &qword_268BA5CE0);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CE8);
  uint64_t v96 = swift_initStackObject();
  *(_OWORD *)(v96 + 16) = v133;
  id v97 = (void *)*MEMORY[0x263F872F0];
  *(void *)(v96 + 32) = *MEMORY[0x263F872F0];
  uint64_t v98 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA7870);
  *(void *)(v96 + 40) = &unk_26EFFCE40;
  uint64_t v99 = (void *)*MEMORY[0x263F872D8];
  *(void *)(v96 + 64) = v98;
  *(void *)(v96 + 72) = v99;
  *(void *)(v96 + 80) = 0xD000000000000015;
  *(void *)(v96 + 88) = 0x800000023C72AAD0;
  id v100 = (void *)*MEMORY[0x263F87350];
  uint64_t v101 = v92;
  *(void *)(v96 + 104) = v92;
  *(void *)(v96 + 112) = v100;
  *(void *)(v96 + 120) = 0x736D6574494657;
  *(void *)(v96 + 128) = 0xE700000000000000;
  id v102 = (void *)*MEMORY[0x263F87360];
  *(void *)(v96 + 144) = v101;
  *(void *)(v96 + 152) = v102;
  id v103 = v95;
  id v104 = v97;
  id v105 = v99;
  id v106 = v100;
  id v107 = v102;
  uint64_t v108 = sub_23C6D55A8();
  uint64_t v110 = v109;
  uint64_t v111 = sub_23C6D55A8();
  uint64_t v113 = v112;
  uint64_t v114 = v132[0];
  sub_23C6D46B8();
  id v115 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v116 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v117 = sub_23C41B6F8(v108, v110, v111, v113, 0, 0, v114, v91);
  *(void *)(v96 + 184) = v138;
  *(void *)(v96 + 160) = v117;
  _s3__C3KeyVMa_0(0);
  sub_23C375C5C(&qword_26AEEE340, _s3__C3KeyVMa_0);
  uint64_t v118 = sub_23C6D5428();
  id v119 = sub_23C41A0C0(v118);
  uint64_t v120 = v134;
  *(void *)(v134 + 32) = v119;
  uint64_t v139 = v120;
  sub_23C6D56B8();
  uint64_t v121 = v139;
  uint64_t v122 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F20);
  uint64_t v123 = (void **)MEMORY[0x263F87108];
  *(void *)(inited + 360) = v121;
  uint64_t v124 = *v123;
  *(void *)(inited + 384) = v122;
  *(void *)(inited + 392) = v124;
  uint64_t v125 = (void **)MEMORY[0x263F87498];
  *(unsigned char *)(inited + 400) = 1;
  id v126 = *v125;
  uint64_t v127 = MEMORY[0x263F8D4F8];
  *(void *)(inited + 424) = MEMORY[0x263F8D4F8];
  *(void *)(inited + 432) = v126;
  *(void *)(inited + 464) = v127;
  *(unsigned char *)(inited + 440) = 1;
  type metadata accessor for Key(0);
  sub_23C375C5C((unint64_t *)&qword_26AEEE8F0, type metadata accessor for Key);
  id v128 = v124;
  id v129 = v126;
  uint64_t v130 = sub_23C6D5428();
  return sub_23C41A1C0(v130);
}

uint64_t sub_23C41696C()
{
  return sub_23C415E74();
}

uint64_t sub_23C416994()
{
  return sub_23C416D60();
}

uint64_t sub_23C4169A0()
{
  return sub_23C416EA0();
}

uint64_t sub_23C4169AC()
{
  return sub_23C416F84();
}

uint64_t sub_23C4169B8()
{
  return sub_23C6D5DF8();
}

uint64_t sub_23C416A00()
{
  return sub_23C416E3C();
}

uint64_t sub_23C416A20()
{
  return sub_23C416DC8();
}

uint64_t sub_23C416A2C()
{
  sub_23C6D55B8();
  return swift_bridgeObjectRelease();
}

uint64_t sub_23C416AA4()
{
  sub_23C6D55B8();
  return swift_bridgeObjectRelease();
}

uint64_t sub_23C416BCC()
{
  sub_23C6D55B8();
  return swift_bridgeObjectRelease();
}

uint64_t sub_23C416C2C()
{
  sub_23C6D55B8();
  return swift_bridgeObjectRelease();
}

uint64_t sub_23C416CA0()
{
  sub_23C6D55B8();
  return swift_bridgeObjectRelease();
}

uint64_t sub_23C416D00()
{
  sub_23C6D55B8();
  return swift_bridgeObjectRelease();
}

uint64_t sub_23C416D60()
{
  return sub_23C6D5DF8();
}

uint64_t sub_23C416DC8()
{
  return sub_23C6D5DF8();
}

uint64_t sub_23C416E3C()
{
  return sub_23C6D5DF8();
}

uint64_t sub_23C416EA0()
{
  return sub_23C6D5DF8();
}

uint64_t sub_23C416F04()
{
  return sub_23C6D5DF8();
}

uint64_t sub_23C416F48()
{
  return sub_23C6D5DF8();
}

uint64_t sub_23C416F84()
{
  return sub_23C6D5DF8();
}

void sub_23C417000()
{
  OUTLINED_FUNCTION_15_1();
  uint64_t v0 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEEEBF0);
  uint64_t v1 = OUTLINED_FUNCTION_32(v0);
  MEMORY[0x270FA5388](v1);
  sub_23C6D44E8();
  OUTLINED_FUNCTION_0_0();
  MEMORY[0x270FA5388](v2);
  OUTLINED_FUNCTION_10_3();
  uint64_t v3 = sub_23C6D46E8();
  uint64_t v4 = OUTLINED_FUNCTION_32(v3);
  MEMORY[0x270FA5388](v4);
  uint64_t v5 = OUTLINED_FUNCTION_18_1();
  uint64_t v6 = OUTLINED_FUNCTION_32(v5);
  MEMORY[0x270FA5388](v6);
  uint64_t v7 = sub_23C6D4508();
  MEMORY[0x270FA5388](v7);
  OUTLINED_FUNCTION_11_11();
  sub_23C6D46D8();
  OUTLINED_FUNCTION_6_3();
  v8();
  sub_23C6D4518();
  OUTLINED_FUNCTION_31_0();
  __swift_storeEnumTagSinglePayload(v9, v10, v11, v7);
  sub_23C6D42C8();
  OUTLINED_FUNCTION_14_1();
}

void sub_23C417200()
{
  OUTLINED_FUNCTION_15_1();
  uint64_t v1 = __swift_instantiateConcreteTypeFromMangledName(&qword_26AEEDAD8);
  uint64_t v2 = OUTLINED_FUNCTION_32(v1);
  MEMORY[0x270FA5388](v2);
  OUTLINED_FUNCTION_7_2();
  uint64_t v3 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEEEBF0);
  uint64_t v4 = OUTLINED_FUNCTION_32(v3);
  MEMORY[0x270FA5388](v4);
  uint64_t v23 = OUTLINED_FUNCTION_5(v5, v22);
  OUTLINED_FUNCTION_0_0();
  uint64_t v7 = v6;
  MEMORY[0x270FA5388](v8);
  uint64_t v9 = OUTLINED_FUNCTION_19_0();
  uint64_t v10 = OUTLINED_FUNCTION_32(v9);
  MEMORY[0x270FA5388](v10);
  OUTLINED_FUNCTION_17_2();
  uint64_t v11 = sub_23C6D5518();
  uint64_t v12 = OUTLINED_FUNCTION_32(v11);
  MEMORY[0x270FA5388](v12);
  uint64_t v25 = OUTLINED_FUNCTION_13_10();
  MEMORY[0x270FA5388](v25);
  OUTLINED_FUNCTION_2_1();
  __swift_instantiateConcreteTypeFromMangledName(&qword_268BA7910);
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA7918) - 8;
  uint64_t v24 = *(void *)(*(void *)v13 + 72);
  unint64_t v14 = (*(unsigned __int8 *)(*(void *)v13 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(*(void *)v13 + 80);
  uint64_t v26 = swift_allocObject();
  *(_OWORD *)(v26 + 16) = xmmword_23C6F6A90;
  *(unsigned char *)(v26 + v14) = 0;
  sub_23C6D54A8();
  sub_23C6D46D8();
  (*(void (**)(uint64_t, void, uint64_t))(v7 + 104))(v0, *MEMORY[0x263F06D18], v23);
  OUTLINED_FUNCTION_10_4();
  OUTLINED_FUNCTION_7_9();
  OUTLINED_FUNCTION_31_0();
  __swift_storeEnumTagSinglePayload(v15, v16, v17, v25);
  sub_23C6D4148();
  OUTLINED_FUNCTION_27_4();
  sub_23C6D4158();
  *(unsigned char *)(v26 + v14 + v24) = 1;
  sub_23C6D54A8();
  sub_23C6D46D8();
  OUTLINED_FUNCTION_17();
  v18();
  OUTLINED_FUNCTION_10_4();
  OUTLINED_FUNCTION_7_9();
  OUTLINED_FUNCTION_31_0();
  __swift_storeEnumTagSinglePayload(v19, v20, v21, v25);
  OUTLINED_FUNCTION_27_4();
  sub_23C6D4158();
  sub_23C6D4168();
  sub_23C417A74();
  sub_23C6D5428();
  OUTLINED_FUNCTION_14_1();
}

uint64_t sub_23C41755C()
{
  uint64_t v0 = sub_23C6D5CA8();
  swift_bridgeObjectRelease();
  if (v0 == 1) {
    unsigned int v1 = 1;
  }
  else {
    unsigned int v1 = 2;
  }
  if (v0) {
    return v1;
  }
  else {
    return 0;
  }
}

unint64_t sub_23C4175B4()
{
  unint64_t result = qword_26AEEDFB0;
  if (!qword_26AEEDFB0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEEDFB0);
  }
  return result;
}

uint64_t sub_23C417600()
{
  return sub_23C416CA0();
}

uint64_t sub_23C41761C()
{
  return sub_23C416E3C();
}

uint64_t sub_23C417638@<X0>(unsigned char *a1@<X8>)
{
  uint64_t result = sub_23C41755C();
  *a1 = result;
  return result;
}

uint64_t sub_23C417668()
{
  return sub_23C374BD0(&qword_268BA7878, (uint64_t *)&unk_268BA7880);
}

void sub_23C4176A4(void *a1@<X8>)
{
  *a1 = &unk_26EFFCED8;
}

unint64_t sub_23C4176B8()
{
  unint64_t result = qword_26AEEDF70;
  if (!qword_26AEEDF70)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEEDF70);
  }
  return result;
}

unint64_t sub_23C417708()
{
  unint64_t result = qword_26AEEDF98;
  if (!qword_26AEEDF98)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEEDF98);
  }
  return result;
}

unint64_t sub_23C417758()
{
  unint64_t result = qword_26AEEDFB8;
  if (!qword_26AEEDFB8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEEDFB8);
  }
  return result;
}

unint64_t sub_23C4177A8()
{
  unint64_t result = qword_26AEEDF88;
  if (!qword_26AEEDF88)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEEDF88);
  }
  return result;
}

unint64_t sub_23C4177F8()
{
  unint64_t result = qword_26AEEDF90;
  if (!qword_26AEEDF90)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEEDF90);
  }
  return result;
}

unint64_t sub_23C417848()
{
  unint64_t result = qword_26AEEDF78;
  if (!qword_26AEEDF78)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEEDF78);
  }
  return result;
}

unint64_t sub_23C417898()
{
  unint64_t result = qword_26AEEDF80;
  if (!qword_26AEEDF80)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEEDF80);
  }
  return result;
}

uint64_t sub_23C4178E8()
{
  return swift_getOpaqueTypeConformance2();
}

unint64_t sub_23C417938()
{
  unint64_t result = qword_26AEEDB10;
  if (!qword_26AEEDB10)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEEDB10);
  }
  return result;
}

uint64_t sub_23C417984(uint64_t a1)
{
  unint64_t v2 = sub_23C417938();
  return MEMORY[0x270EE0C40](a1, v2);
}

unint64_t sub_23C4179D4()
{
  unint64_t result = qword_26AEEDFA0;
  if (!qword_26AEEDFA0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEEDFA0);
  }
  return result;
}

unint64_t sub_23C417A24()
{
  unint64_t result = qword_26AEEDFC0;
  if (!qword_26AEEDFC0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEEDFC0);
  }
  return result;
}

unint64_t sub_23C417A74()
{
  unint64_t result = qword_26AEEDFA8;
  if (!qword_26AEEDFA8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEEDFA8);
  }
  return result;
}

uint64_t sub_23C417AC4(uint64_t a1)
{
  unint64_t v2 = sub_23C417898();
  return MEMORY[0x270EE1C28](a1, v2);
}

unint64_t sub_23C417B14()
{
  unint64_t result = qword_26AEEDCD0;
  if (!qword_26AEEDCD0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEEDCD0);
  }
  return result;
}

unint64_t sub_23C417B64()
{
  unint64_t result = qword_26AEEDFC8;
  if (!qword_26AEEDFC8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEEDFC8);
  }
  return result;
}

uint64_t sub_23C417BB0()
{
  return swift_getOpaqueTypeConformance2();
}

uint64_t sub_23C417BCC()
{
  return swift_getOpaqueTypeConformance2();
}

uint64_t sub_23C417BE8()
{
  uint64_t v1 = sub_23C6D44E8();
  OUTLINED_FUNCTION_0_0();
  uint64_t v3 = v2;
  MEMORY[0x270FA5388](v4);
  uint64_t v5 = OUTLINED_FUNCTION_19_0();
  uint64_t v6 = OUTLINED_FUNCTION_32(v5);
  MEMORY[0x270FA5388](v6);
  OUTLINED_FUNCTION_8_1();
  uint64_t v7 = sub_23C6D5518();
  uint64_t v8 = OUTLINED_FUNCTION_32(v7);
  MEMORY[0x270FA5388](v8);
  OUTLINED_FUNCTION_9_1();
  sub_23C6D54A8();
  sub_23C6D46D8();
  (*(void (**)(uint64_t, void, uint64_t))(v3 + 104))(v0, *MEMORY[0x263F06D18], v1);
  return sub_23C6D4518();
}

void sub_23C417D40()
{
  OUTLINED_FUNCTION_15_1();
  uint64_t v1 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEEEBF0);
  uint64_t v2 = OUTLINED_FUNCTION_32(v1);
  MEMORY[0x270FA5388](v2);
  uint64_t v4 = OUTLINED_FUNCTION_5(v3, v15);
  OUTLINED_FUNCTION_0_0();
  uint64_t v6 = v5;
  MEMORY[0x270FA5388](v7);
  OUTLINED_FUNCTION_8_1();
  uint64_t v8 = sub_23C6D46E8();
  uint64_t v9 = OUTLINED_FUNCTION_32(v8);
  MEMORY[0x270FA5388](v9);
  uint64_t v10 = OUTLINED_FUNCTION_18_1();
  uint64_t v11 = OUTLINED_FUNCTION_32(v10);
  MEMORY[0x270FA5388](v11);
  OUTLINED_FUNCTION_2_1();
  uint64_t v12 = sub_23C6D4508();
  MEMORY[0x270FA5388](v12);
  OUTLINED_FUNCTION_10_3();
  sub_23C6D54A8();
  sub_23C6D46D8();
  unsigned int v17 = *MEMORY[0x263F06D18];
  uint64_t v16 = *(void (**)(void))(v6 + 104);
  OUTLINED_FUNCTION_6_3();
  v13();
  OUTLINED_FUNCTION_0_5();
  sub_23C6D4518();
  __swift_storeEnumTagSinglePayload(v18, 1, 1, v12);
  __swift_instantiateConcreteTypeFromMangledName(&qword_268BA63E8);
  *(_OWORD *)(swift_allocObject() + 16) = xmmword_23C6FCAC0;
  sub_23C6D54A8();
  sub_23C6D46D8();
  OUTLINED_FUNCTION_6_3();
  v16();
  OUTLINED_FUNCTION_0_5();
  OUTLINED_FUNCTION_3_13();
  sub_23C6D54A8();
  sub_23C6D46D8();
  OUTLINED_FUNCTION_6_3();
  v16();
  OUTLINED_FUNCTION_0_5();
  OUTLINED_FUNCTION_3_13();
  sub_23C6D54A8();
  sub_23C6D46D8();
  OUTLINED_FUNCTION_6_3();
  v16();
  OUTLINED_FUNCTION_0_5();
  OUTLINED_FUNCTION_3_13();
  sub_23C6D54A8();
  sub_23C6D46D8();
  OUTLINED_FUNCTION_6_3();
  v16();
  OUTLINED_FUNCTION_0_5();
  OUTLINED_FUNCTION_3_13();
  sub_23C6D54A8();
  sub_23C6D46D8();
  OUTLINED_FUNCTION_6_3();
  v16();
  OUTLINED_FUNCTION_0_5();
  OUTLINED_FUNCTION_3_13();
  sub_23C6D54A8();
  sub_23C6D46D8();
  OUTLINED_FUNCTION_6_3();
  v16();
  OUTLINED_FUNCTION_0_5();
  OUTLINED_FUNCTION_3_13();
  sub_23C6D54A8();
  sub_23C6D46D8();
  ((void (*)(uint64_t, void, uint64_t))v16)(v0, v17, v4);
  OUTLINED_FUNCTION_0_5();
  OUTLINED_FUNCTION_3_13();
  sub_23C6D54A8();
  sub_23C6D46D8();
  ((void (*)(uint64_t, void, uint64_t))v16)(v0, v17, v4);
  OUTLINED_FUNCTION_0_5();
  OUTLINED_FUNCTION_3_13();
  sub_23C6D54A8();
  sub_23C6D46D8();
  ((void (*)(uint64_t, void, uint64_t))v16)(v0, v17, v4);
  OUTLINED_FUNCTION_0_5();
  OUTLINED_FUNCTION_3_13();
  sub_23C6D54A8();
  sub_23C6D46D8();
  ((void (*)(uint64_t, void, uint64_t))v16)(v0, v17, v4);
  OUTLINED_FUNCTION_0_5();
  OUTLINED_FUNCTION_3_13();
  sub_23C6D54A8();
  sub_23C6D46D8();
  OUTLINED_FUNCTION_6_3();
  v16();
  OUTLINED_FUNCTION_0_5();
  OUTLINED_FUNCTION_3_13();
  sub_23C6D54A8();
  sub_23C6D46D8();
  OUTLINED_FUNCTION_6_3();
  v16();
  OUTLINED_FUNCTION_0_5();
  OUTLINED_FUNCTION_3_13();
  sub_23C6D54A8();
  sub_23C6D46D8();
  OUTLINED_FUNCTION_6_3();
  v16();
  OUTLINED_FUNCTION_0_5();
  OUTLINED_FUNCTION_3_13();
  sub_23C6D54A8();
  sub_23C6D46D8();
  OUTLINED_FUNCTION_6_3();
  v16();
  OUTLINED_FUNCTION_0_5();
  OUTLINED_FUNCTION_3_13();
  sub_23C6D54A8();
  sub_23C6D46D8();
  OUTLINED_FUNCTION_6_3();
  v16();
  OUTLINED_FUNCTION_0_5();
  OUTLINED_FUNCTION_3_13();
  sub_23C6D4088();
  uint64_t v14 = sub_23C6D4078();
  OUTLINED_FUNCTION_10_1(v14);
  OUTLINED_FUNCTION_14_1();
}

uint64_t sub_23C418468()
{
  uint64_t KeyPath = swift_getKeyPath();
  uint64_t v1 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA78A8);
  unint64_t v2 = sub_23C419F08();
  uint64_t v3 = sub_23C374BD0(&qword_268BA78B0, &qword_268BA78A8);
  return MEMORY[0x270EE1E48](KeyPath, sub_23C418524, 0, v1, v2, v3);
}

uint64_t sub_23C418524@<X0>(uint64_t a1@<X8>)
{
  uint64_t v26 = a1;
  uint64_t v1 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA78B8);
  uint64_t v2 = *(void *)(v1 - 8);
  uint64_t v24 = v1;
  uint64_t v25 = v2;
  uint64_t v3 = MEMORY[0x270FA5388](v1);
  uint64_t v22 = (char *)v19 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x270FA5388](v3);
  uint64_t v23 = (char *)v19 - v5;
  uint64_t v21 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA78C0);
  uint64_t v27 = *(void *)(v21 - 8);
  uint64_t v6 = MEMORY[0x270FA5388](v21);
  uint64_t v8 = (char *)v19 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x270FA5388](v6);
  uint64_t v20 = (char *)v19 - v9;
  char v28 = 0;
  uint64_t v10 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA78C8);
  v19[1] = sub_23C419F08();
  sub_23C417848();
  sub_23C374BD0(&qword_268BA78D0, &qword_268BA78C8);
  v19[2] = v10;
  sub_23C6D4378();
  sub_23C374BD0(&qword_268BA78D8, &qword_268BA78C0);
  uint64_t v11 = v21;
  sub_23C6D42F8();
  uint64_t v12 = *(void (**)(char *, uint64_t))(v27 + 8);
  v27 += 8;
  v12(v8, v11);
  uint64_t v13 = v22;
  sub_23C6D43B8();
  sub_23C374BD0(&qword_268BA78E0, &qword_268BA78B8);
  uint64_t v14 = v23;
  uint64_t v15 = v24;
  sub_23C6D42F8();
  uint64_t v16 = *(void (**)(char *, uint64_t))(v25 + 8);
  v16(v13, v15);
  unsigned int v17 = v20;
  sub_23C6D42E8();
  v16(v14, v15);
  return ((uint64_t (*)(char *, uint64_t))v12)(v17, v11);
}

uint64_t sub_23C4188D4@<X0>(uint64_t a1@<X8>)
{
  v13[1] = a1;
  uint64_t v1 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA78E8);
  MEMORY[0x270FA5388](v1 - 8);
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA78F0);
  MEMORY[0x270FA5388](v2);
  uint64_t v3 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA78C8);
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v5 = MEMORY[0x270FA5388](v3);
  uint64_t v7 = (char *)v13 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x270FA5388](v5);
  uint64_t v9 = (char *)v13 - v8;
  sub_23C419F08();
  sub_23C6D4208();
  sub_23C6D41F8();
  swift_getKeyPath();
  __swift_instantiateConcreteTypeFromMangledName(&qword_268BA78F8);
  sub_23C6D41E8();
  swift_release();
  sub_23C6D41F8();
  swift_getKeyPath();
  __swift_instantiateConcreteTypeFromMangledName(&qword_268BA7908);
  sub_23C6D41E8();
  swift_release();
  sub_23C6D41F8();
  swift_getKeyPath();
  __swift_instantiateConcreteTypeFromMangledName(&qword_268BA7900);
  sub_23C6D41E8();
  swift_release();
  sub_23C6D41F8();
  sub_23C6D4228();
  sub_23C6D41C8();
  uint64_t v10 = sub_23C374BD0(&qword_268BA78D0, &qword_268BA78C8);
  MEMORY[0x23ECE2E10](v7, &type metadata for ToggleCellularPlanAction, v3, v10);
  uint64_t v11 = *(void (**)(char *, uint64_t))(v4 + 8);
  v11(v7, v3);
  MEMORY[0x23ECE2E00](v9, &type metadata for ToggleCellularPlanAction, v3, v10);
  return ((uint64_t (*)(char *, uint64_t))v11)(v9, v3);
}

uint64_t sub_23C418C3C@<X0>(uint64_t a1@<X8>)
{
  v13[1] = a1;
  uint64_t v1 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA78E8);
  MEMORY[0x270FA5388](v1 - 8);
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA78F0);
  MEMORY[0x270FA5388](v2);
  uint64_t v3 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA78C8);
  uint64_t v4 = *(void *)(v3 - 8);
  uint64_t v5 = MEMORY[0x270FA5388](v3);
  uint64_t v7 = (char *)v13 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x270FA5388](v5);
  uint64_t v9 = (char *)v13 - v8;
  sub_23C419F08();
  sub_23C6D4208();
  sub_23C6D41F8();
  swift_getKeyPath();
  __swift_instantiateConcreteTypeFromMangledName(&qword_268BA78F8);
  sub_23C6D41E8();
  swift_release();
  sub_23C6D41F8();
  swift_getKeyPath();
  __swift_instantiateConcreteTypeFromMangledName(&qword_268BA7900);
  sub_23C6D41E8();
  swift_release();
  sub_23C6D41F8();
  sub_23C6D4228();
  sub_23C6D41C8();
  uint64_t v10 = sub_23C374BD0(&qword_268BA78D0, &qword_268BA78C8);
  MEMORY[0x23ECE2E10](v7, &type metadata for ToggleCellularPlanAction, v3, v10);
  uint64_t v11 = *(void (**)(char *, uint64_t))(v4 + 8);
  v11(v7, v3);
  MEMORY[0x23ECE2E00](v9, &type metadata for ToggleCellularPlanAction, v3, v10);
  return ((uint64_t (*)(char *, uint64_t))v11)(v9, v3);
}

uint64_t sub_23C418F60()
{
  uint64_t v0 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEEE5D8);
  uint64_t v1 = OUTLINED_FUNCTION_32(v0);
  MEMORY[0x270FA5388](v1);
  OUTLINED_FUNCTION_8_3();
  uint64_t v2 = sub_23C6D4C78();
  OUTLINED_FUNCTION_0_0();
  uint64_t v4 = v3;
  MEMORY[0x270FA5388](v5);
  uint64_t v7 = (uint64_t *)((char *)&v12 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0));
  *uint64_t v7 = sub_23C6D5568();
  v7[1] = v8;
  (*(void (**)(uint64_t *, void, uint64_t))(v4 + 104))(v7, *MEMORY[0x263F86728], v2);
  sub_23C6D4CA8();
  uint64_t v9 = sub_23C6D4C98();
  OUTLINED_FUNCTION_10_1(v9);
  type metadata accessor for Key(0);
  sub_23C37BB64();
  sub_23C6D5428();
  id v10 = objc_allocWithZone((Class)sub_23C6D4CB8());
  return sub_23C6D4C88();
}

uint64_t sub_23C4190E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4[27] = a3;
  v4[28] = a4;
  v4[25] = a1;
  v4[26] = a2;
  uint64_t v5 = sub_23C6D4E58();
  v4[29] = v5;
  v4[30] = *(void *)(v5 - 8);
  v4[31] = swift_task_alloc();
  return MEMORY[0x270FA2498](sub_23C4191D8, 0, 0);
}

uint64_t sub_23C4191D8()
{
  uint64_t v67 = v0;
  v66[1] = *MEMORY[0x263EF8340];
  sub_23C6D3FD8();
  uint64_t v1 = *(void *)(v0 + 96);
  if (v1)
  {
    uint64_t v62 = v0 + 184;
    uint64_t v2 = *(void *)(v0 + 104);
    uint64_t v3 = *(void *)(v0 + 112);
    uint64_t v4 = *(void *)(v0 + 120);
    uint64_t v5 = *(void *)(v0 + 128);
    uint64_t v6 = *(void *)(v0 + 136);
    uint64_t v7 = *(void *)(v0 + 144);
    uint64_t v8 = *(void *)(v0 + 152);
    uint64_t v64 = *(void *)(v0 + 88);
    *(void *)(v0 + 16) = v64;
    *(void *)(v0 + 24) = v1;
    *(void *)(v0 + 32) = v2;
    *(void *)(v0 + 40) = v3;
    *(void *)(v0 + 48) = v4;
    *(void *)(v0 + 56) = v5;
    *(void *)(v0 + 64) = v6;
    *(void *)(v0 + 72) = v7;
    *(void *)(v0 + 80) = v8;
    uint64_t v9 = sub_23C3C8EC8(v0 + 16);
    uint64_t v65 = v1;
    if (v9)
    {
      id v10 = v9;
      uint64_t v63 = v3;
      id v11 = objc_msgSend(objc_allocWithZone((Class)WFCellularPlansManager), sel_init);
      sub_23C6D3FD8();
      if (*(unsigned char *)(v0 + 257))
      {
        unsigned int v12 = objc_msgSend(v10, sel_isActive);
        *(void *)(v0 + 192) = 0;
        unsigned int v13 = objc_msgSend(v11, sel_setPlanStatus_forPlan_error_, v12 ^ 1, v10, v0 + 192);
        uint64_t v14 = *(void **)(v0 + 192);
        if (v13)
        {
LABEL_5:
          id v15 = v14;
          sub_23C6D3F48();

          uint64_t v24 = OUTLINED_FUNCTION_28_4(v16, v17, v18, v19, v20, v21, v22, v23, v51, v52, v53, v55, v57, v59, v5, v8, v62, v63, v64);
          sub_23C39ED0C(v24, v25);
          swift_task_dealloc();
          uint64_t v26 = *(uint64_t (**)(void))(v0 + 8);
          goto LABEL_15;
        }
      }
      else
      {
        sub_23C6D3FD8();
        uint64_t v35 = *(unsigned __int8 *)(v0 + 256);
        *(void *)(v0 + 184) = 0;
        unsigned __int8 v36 = objc_msgSend(v11, sel_setPlanStatus_forPlan_error_, v35, v10, v62);
        uint64_t v14 = *(void **)(v0 + 184);
        if (v36) {
          goto LABEL_5;
        }
      }
      id v37 = v14;
      sub_23C6D44C8();

      swift_willThrow();
      uint64_t v45 = OUTLINED_FUNCTION_28_4(v38, v39, v40, v41, v42, v5, v43, v44, v51, v52, v53, v55, v57, v59, v5, v8, v62, v63, v64);
    }
    else
    {
      sub_23C6D4DF8();
      swift_bridgeObjectRetain_n();
      swift_retain_n();
      swift_retain_n();
      swift_retain_n();
      swift_retain_n();
      swift_retain_n();
      swift_retain_n();
      swift_retain_n();
      char v28 = sub_23C6D4E48();
      os_log_type_t v29 = sub_23C6D58B8();
      BOOL v30 = os_log_type_enabled(v28, v29);
      uint64_t v60 = *(void *)(v0 + 248);
      uint64_t v61 = *(void *)(v0 + 240);
      uint64_t v58 = *(void *)(v0 + 232);
      if (v30)
      {
        os_log_type_t type = v29;
        uint64_t v31 = (uint8_t *)swift_slowAlloc();
        uint64_t v54 = swift_slowAlloc();
        v66[0] = v54;
        *(_DWORD *)uint64_t v31 = 136315138;
        sub_23C6D3F58();
        *(void *)(v0 + 176) = sub_23C3D34EC(*(void *)(v0 + 160), *(void *)(v0 + 168), v66);
        sub_23C6D5A68();
        swift_bridgeObjectRelease();
        uint64_t v32 = v64;
        sub_23C39ED0C(v64, v65);
        uint64_t v33 = OUTLINED_FUNCTION_9_11();
        sub_23C39ED0C(v33, v34);
        _os_log_impl(&dword_23C364000, v28, type, "Could not find cellular plan with matching label %s", v31, 0xCu);
        swift_arrayDestroy();
        MEMORY[0x23ECE6CD0](v54, -1, -1);
        MEMORY[0x23ECE6CD0](v31, -1, -1);
      }
      else
      {
        uint64_t v32 = v64;
        sub_23C39ED0C(v64, v65);
        uint64_t v47 = OUTLINED_FUNCTION_9_11();
        sub_23C39ED0C(v47, v48);
      }
      (*(void (**)(uint64_t, uint64_t))(v61 + 8))(v60, v58);
      sub_23C39ECC0();
      swift_allocError();
      *uint64_t v49 = 0;
      swift_willThrow();
      uint64_t v45 = v32;
      uint64_t v46 = v65;
    }
    sub_23C39ED0C(v45, v46);
  }
  else
  {
    sub_23C39ECC0();
    swift_allocError();
    *uint64_t v27 = 1;
    swift_willThrow();
  }
  swift_task_dealloc();
  uint64_t v26 = *(uint64_t (**)(void))(v0 + 8);
LABEL_15:
  return v26();
}

void sub_23C41971C()
{
  OUTLINED_FUNCTION_15_1();
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&qword_26AEEDC40);
  uint64_t v3 = OUTLINED_FUNCTION_32(v2);
  MEMORY[0x270FA5388](v3);
  OUTLINED_FUNCTION_7_2();
  uint64_t v60 = v4;
  sub_23C6D4238();
  OUTLINED_FUNCTION_0_0();
  uint64_t v67 = v5;
  uint64_t v68 = v6;
  MEMORY[0x270FA5388](v5);
  OUTLINED_FUNCTION_7_2();
  uint64_t v66 = v7;
  uint64_t v8 = __swift_instantiateConcreteTypeFromMangledName(&qword_26AEEDA80);
  uint64_t v9 = OUTLINED_FUNCTION_32(v8);
  uint64_t v10 = MEMORY[0x270FA5388](v9);
  unsigned int v12 = (char *)v54 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x270FA5388](v10);
  uint64_t v14 = (char *)v54 - v13;
  uint64_t v15 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEEEBF0);
  uint64_t v16 = OUTLINED_FUNCTION_32(v15);
  MEMORY[0x270FA5388](v16);
  OUTLINED_FUNCTION_17_2();
  uint64_t v64 = sub_23C6D44E8();
  OUTLINED_FUNCTION_0_0();
  uint64_t v18 = v17;
  MEMORY[0x270FA5388](v19);
  OUTLINED_FUNCTION_7_2();
  uint64_t v21 = v20;
  uint64_t v22 = sub_23C6D46E8();
  uint64_t v23 = OUTLINED_FUNCTION_32(v22);
  MEMORY[0x270FA5388](v23);
  OUTLINED_FUNCTION_8_3();
  uint64_t v24 = sub_23C6D5518();
  uint64_t v25 = OUTLINED_FUNCTION_32(v24);
  MEMORY[0x270FA5388](v25);
  uint64_t v26 = OUTLINED_FUNCTION_13_10();
  uint64_t v58 = v26;
  MEMORY[0x270FA5388](v26);
  OUTLINED_FUNCTION_9_1();
  uint64_t v59 = __swift_instantiateConcreteTypeFromMangledName(&qword_26AEEDAA8);
  sub_23C6D54A8();
  sub_23C6D46D8();
  int v62 = *MEMORY[0x263F06D18];
  uint64_t v27 = *(void (**)(void))(v18 + 104);
  uint64_t v63 = v18 + 104;
  uint64_t v65 = v27;
  uint64_t v57 = v21;
  v27(v21);
  OUTLINED_FUNCTION_4_11();
  OUTLINED_FUNCTION_7_9();
  __swift_storeEnumTagSinglePayload(v1, 1, 1, v26);
  uint64_t v28 = sub_23C6D3F18();
  long long v69 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  uint64_t v73 = 0;
  v54[1] = v14;
  OUTLINED_FUNCTION_24_2((uint64_t)v14);
  OUTLINED_FUNCTION_24_2((uint64_t)v12);
  int v55 = *MEMORY[0x263EFBDC8];
  uint64_t v29 = *(void *)(v68 + 104);
  v68 += 104;
  uint64_t v61 = v29;
  OUTLINED_FUNCTION_17();
  v30();
  sub_23C39EC74();
  v54[0] = v0;
  uint64_t v59 = sub_23C6D4018();
  uint64_t v56 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEED750);
  OUTLINED_FUNCTION_11_11();
  sub_23C6D46D8();
  OUTLINED_FUNCTION_17();
  v31();
  OUTLINED_FUNCTION_4_11();
  OUTLINED_FUNCTION_7_9();
  OUTLINED_FUNCTION_31_0();
  uint64_t v32 = v58;
  __swift_storeEnumTagSinglePayload(v33, v34, v35, v58);
  LOBYTE(v69) = 0;
  uint64_t v36 = OUTLINED_FUNCTION_31_3();
  *(void *)(v37 - 256) = v28;
  __swift_storeEnumTagSinglePayload(v36, v38, v39, v28);
  OUTLINED_FUNCTION_24_2((uint64_t)v12);
  OUTLINED_FUNCTION_17();
  v40();
  sub_23C417938();
  uint64_t v56 = sub_23C6D4008();
  __swift_instantiateConcreteTypeFromMangledName(&qword_26AEEDAD0);
  sub_23C6D54A8();
  sub_23C6D46D8();
  OUTLINED_FUNCTION_17();
  v41();
  OUTLINED_FUNCTION_4_11();
  OUTLINED_FUNCTION_7_9();
  OUTLINED_FUNCTION_31_0();
  __swift_storeEnumTagSinglePayload(v42, v43, v44, v32);
  LOBYTE(v69) = 1;
  sub_23C6D56F8();
  OUTLINED_FUNCTION_31_0();
  __swift_storeEnumTagSinglePayload(v45, v46, v47, v48);
  uint64_t v49 = OUTLINED_FUNCTION_31_3();
  __swift_storeEnumTagSinglePayload(v49, v51, v52, *(void *)(v50 - 256));
  OUTLINED_FUNCTION_17();
  v53();
  sub_23C6D4048();
  OUTLINED_FUNCTION_14_1();
}

uint64_t sub_23C419C98(uint64_t a1)
{
  uint64_t v4 = *v1;
  uint64_t v5 = v1[1];
  uint64_t v6 = v1[2];
  uint64_t v7 = (void *)swift_task_alloc();
  *(void *)(v2 + 16) = v7;
  *uint64_t v7 = v2;
  v7[1] = sub_23C37B95C;
  return sub_23C4190E8(a1, v4, v5, v6);
}

void sub_23C419D4C(void *a1@<X8>)
{
  sub_23C41971C();
  *a1 = v2;
  a1[1] = v3;
  a1[2] = v4;
}

uint64_t sub_23C419D7C(uint64_t a1)
{
  unint64_t v2 = sub_23C419F08();
  return MEMORY[0x270EE0D28](a1, v2);
}

ValueMetadata *type metadata accessor for ToggleCellularPlanAction()
{
  return &type metadata for ToggleCellularPlanAction;
}

unsigned char *storeEnumTagSinglePayload for ToggleCellularPlanAction.ToggleCellularPlanOperation(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 1 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 1) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFF) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFE)
  {
    unsigned int v6 = ((a2 - 255) >> 8) + 1;
    *unint64_t result = a2 + 1;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        JUMPOUT(0x23C419E94);
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          *unint64_t result = a2 + 1;
        break;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for ToggleCellularPlanAction.ToggleCellularPlanOperation()
{
  return &type metadata for ToggleCellularPlanAction.ToggleCellularPlanOperation;
}

uint64_t sub_23C419ECC()
{
  return sub_23C374BD0(&qword_268BA7890, &qword_268BA7898);
}

unint64_t sub_23C419F08()
{
  unint64_t result = qword_26AEEDFD0;
  if (!qword_26AEEDFD0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_26AEEDFD0);
  }
  return result;
}

uint64_t OUTLINED_FUNCTION_3_13()
{
  return sub_23C6D4518();
}

uint64_t OUTLINED_FUNCTION_4_11()
{
  return v0;
}

uint64_t OUTLINED_FUNCTION_7_9()
{
  return sub_23C6D4518();
}

uint64_t OUTLINED_FUNCTION_9_11()
{
  return v0;
}

uint64_t OUTLINED_FUNCTION_13_10()
{
  return sub_23C6D4508();
}

uint64_t OUTLINED_FUNCTION_18_7()
{
  return sub_23C6D5DC8();
}

uint64_t OUTLINED_FUNCTION_24_2(uint64_t a1)
{
  return __swift_storeEnumTagSinglePayload(a1, 1, 1, v1);
}

uint64_t OUTLINED_FUNCTION_26_3()
{
  return sub_23C6D55B8();
}

uint64_t OUTLINED_FUNCTION_28_4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  return a19;
}

uint64_t OUTLINED_FUNCTION_31_3()
{
  return v0;
}

id sub_23C41A078(uint64_t a1)
{
  return sub_23C41A108(a1, type metadata accessor for DescriptionKey, (unint64_t *)&unk_268BA6EF0, type metadata accessor for DescriptionKey);
}

id sub_23C41A0C0(uint64_t a1)
{
  return sub_23C41A108(a1, _s3__C3KeyVMa_0, &qword_26AEEE340, _s3__C3KeyVMa_0);
}

id sub_23C41A108(uint64_t a1, void (*a2)(void), unint64_t *a3, void (*a4)(uint64_t))
{
  id v7 = objc_allocWithZone((Class)swift_getObjCClassFromMetadata());
  a2(0);
  sub_23C375C5C(a3, a4);
  uint64_t v8 = (void *)sub_23C6D5408();
  swift_bridgeObjectRelease();
  id v9 = objc_msgSend(v7, sel_initWithDictionary_, v8);

  return v9;
}

id sub_23C41A1C0(uint64_t a1)
{
  return sub_23C41A108(a1, type metadata accessor for Key, (unint64_t *)&qword_26AEEE8F0, type metadata accessor for Key);
}

uint64_t sub_23C41A208()
{
  return MEMORY[0x270F86188](0xD000000000000019, 0x800000023C72AC40, sub_23C41A23C, 0);
}

id sub_23C41A23C()
{
  uint64_t v0 = sub_23C6D45B8();
  MEMORY[0x270FA5388](v0 - 8);
  uint64_t v2 = (char *)&v251 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v3 = sub_23C6D46E8();
  MEMORY[0x270FA5388](v3 - 8);
  uint64_t v5 = (char *)&v251 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v261 = sub_23C369F80(0, (unint64_t *)&unk_268BA5C90);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_26AEEE910);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_23C6F8190;
  id v7 = (void *)*MEMORY[0x263F870A0];
  uint64_t v8 = MEMORY[0x263F8D310];
  *(void *)(inited + 32) = *MEMORY[0x263F870A0];
  strcpy((char *)(inited + 40), "WFCountAction");
  *(_WORD *)(inited + 54) = -4864;
  id v9 = (void *)*MEMORY[0x263F87110];
  *(void *)(inited + 64) = v8;
  *(void *)(inited + 72) = v9;
  id v10 = v7;
  id v11 = v9;
  uint64_t v12 = sub_23C6D55A8();
  uint64_t v14 = v13;
  uint64_t v15 = sub_23C6D55A8();
  uint64_t v17 = v16;
  uint64_t v18 = (uint64_t)v5;
  sub_23C6D46B8();
  if (qword_268BA5B80 != -1) {
    swift_once();
  }
  id v19 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v20 = (uint64_t)v2;
  sub_23C6D4598();

  id v21 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v22 = v18;
  id v23 = sub_23C41B6F8(v12, v14, v15, v17, 0, 0, v18, v20);
  uint64_t v24 = sub_23C369F80(0, (unint64_t *)&unk_268BA5CA0);
  *(void *)(inited + 80) = v23;
  uint64_t v25 = (void *)*MEMORY[0x263F87098];
  *(void *)(inited + 104) = v24;
  *(void *)(inited + 112) = v25;
  uint64_t v268 = v24;
  id v26 = v25;
  uint64_t v27 = sub_23C6D55A8();
  uint64_t v29 = v28;
  uint64_t v30 = sub_23C6D55A8();
  uint64_t v32 = v31;
  sub_23C6D46B8();
  id v33 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v34 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(inited + 120) = sub_23C41B6F8(v27, v29, v30, v32, 0, 0, v22, v20);
  uint64_t v35 = (void *)*MEMORY[0x263F87190];
  *(void *)(inited + 144) = v24;
  *(void *)(inited + 152) = v35;
  *(void *)&long long v265 = sub_23C369F80(0, (unint64_t *)&unk_268BA6EE0);
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CB0);
  uint64_t v36 = swift_initStackObject();
  *(_OWORD *)(v36 + 16) = xmmword_23C6F6A90;
  uint64_t v37 = (void *)*MEMORY[0x263F87198];
  *(void *)(v36 + 32) = *MEMORY[0x263F87198];
  id v38 = v35;
  id v39 = v37;
  uint64_t v40 = sub_23C6D55A8();
  uint64_t v42 = v41;
  uint64_t v43 = sub_23C6D55A8();
  uint64_t v45 = v44;
  sub_23C6D46B8();
  id v46 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v47 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v48 = v45;
  uint64_t v49 = v22;
  uint64_t v50 = v20;
  *(void *)(v36 + 40) = sub_23C41B6F8(v40, v42, v43, v48, 0, 0, v22, v20);
  uint64_t v51 = (void *)*MEMORY[0x263F871A8];
  uint64_t v52 = v268;
  *(void *)(v36 + 64) = v268;
  *(void *)(v36 + 72) = v51;
  id v53 = v51;
  uint64_t v267 = sub_23C6D55A8();
  uint64_t v55 = v54;
  uint64_t v56 = sub_23C6D55A8();
  uint64_t v58 = v57;
  uint64_t v59 = v49;
  sub_23C6D46B8();
  id v60 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v266 = v50;
  sub_23C6D4598();

  id v61 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v62 = sub_23C41B6F8(v267, v55, v56, v58, 0, 0, v59, v50);
  *(void *)(v36 + 104) = v52;
  *(void *)(v36 + 80) = v62;
  type metadata accessor for DescriptionKey(0);
  sub_23C375C5C((unint64_t *)&unk_268BA6EF0, type metadata accessor for DescriptionKey);
  uint64_t v267 = MEMORY[0x263F8EE58] + 8;
  uint64_t v63 = sub_23C6D5428();
  uint64_t v64 = v265;
  *(void *)(inited + 160) = sub_23C41A108(v63, type metadata accessor for DescriptionKey, (unint64_t *)&unk_268BA6EF0, type metadata accessor for DescriptionKey);
  uint64_t v65 = (void *)*MEMORY[0x263F870D0];
  *(void *)(inited + 184) = v64;
  *(void *)(inited + 192) = v65;
  *(void *)(inited + 200) = 2036429383;
  *(void *)(inited + 208) = 0xE400000000000000;
  uint64_t v66 = (void *)*MEMORY[0x263F870E8];
  uint64_t v67 = MEMORY[0x263F8D310];
  *(void *)(inited + 224) = MEMORY[0x263F8D310];
  *(void *)(inited + 232) = v66;
  *(void *)(inited + 240) = 7173491;
  *(void *)(inited + 248) = 0xE300000000000000;
  uint64_t v68 = (void *)*MEMORY[0x263F87220];
  *(void *)(inited + 264) = v67;
  *(void *)(inited + 272) = v68;
  uint64_t v262 = (_OWORD *)__swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CC0);
  uint64_t v69 = swift_initStackObject();
  long long v265 = xmmword_23C6F6A80;
  *(_OWORD *)(v69 + 16) = xmmword_23C6F6A80;
  uint64_t v70 = v59;
  *(void *)(v69 + 32) = 0x656C7069746C754DLL;
  *(void *)(v69 + 40) = 0xE800000000000000;
  uint64_t v71 = MEMORY[0x263F8D4F8];
  *(unsigned char *)(v69 + 48) = 1;
  *(void *)(v69 + 72) = v71;
  strcpy((char *)(v69 + 80), "ParameterKey");
  *(unsigned char *)(v69 + 93) = 0;
  *(_WORD *)(v69 + 94) = -5120;
  *(void *)(v69 + 96) = 0x7475706E49;
  *(void *)(v69 + 104) = 0xE500000000000000;
  *(void *)(v69 + 120) = v67;
  *(void *)(v69 + 128) = 0x6465726975716552;
  *(void *)(v69 + 136) = 0xE800000000000000;
  *(unsigned char *)(v69 + 144) = 1;
  *(void *)(v69 + 168) = v71;
  *(void *)(v69 + 176) = 0x7365707954;
  *(void *)(v69 + 184) = 0xE500000000000000;
  uint64_t v264 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F00);
  *(void *)(v69 + 216) = v264;
  *(void *)(v69 + 192) = &unk_26EFFCF28;
  id v72 = v65;
  id v73 = v66;
  id v74 = v68;
  uint64_t v75 = sub_23C6D5428();
  uint64_t v76 = __swift_instantiateConcreteTypeFromMangledName(&qword_268BA5CD0);
  uint64_t v263 = v76;
  *(void *)(inited + 280) = v75;
  uint64_t v77 = (void *)*MEMORY[0x263F87118];
  *(void *)(inited + 304) = v76;
  *(void *)(inited + 312) = v77;
  *(unsigned char *)(inited + 320) = 1;
  uint64_t v78 = (void *)*MEMORY[0x263F87120];
  *(void *)(inited + 344) = v71;
  *(void *)(inited + 352) = v78;
  id v79 = v77;
  id v80 = v78;
  uint64_t v81 = sub_23C6D55A8();
  uint64_t v83 = v82;
  uint64_t v84 = sub_23C6D55A8();
  uint64_t v86 = v85;
  sub_23C6D46B8();
  id v87 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v88 = v266;
  sub_23C6D4598();

  id v89 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v90 = v84;
  uint64_t v91 = v70;
  *(void *)(inited + 360) = sub_23C41B6F8(v81, v83, v90, v86, 0, 0, v70, v88);
  uint64_t v92 = (void *)*MEMORY[0x263F872B0];
  uint64_t v93 = v268;
  *(void *)(inited + 384) = v268;
  *(void *)(inited + 392) = v92;
  uint64_t v94 = swift_allocObject();
  *(_OWORD *)(v94 + 16) = v265;
  *(void *)(v94 + 32) = 0x75736F6C63736944;
  *(void *)(v94 + 40) = 0xEF6C6576654C6572;
  *(void *)(v94 + 48) = 0x63696C627550;
  *(void *)(v94 + 56) = 0xE600000000000000;
  *(void *)(v94 + 72) = MEMORY[0x263F8D310];
  *(void *)(v94 + 80) = 0x656C7069746C754DLL;
  *(void *)(v94 + 88) = 0xE800000000000000;
  *(unsigned char *)(v94 + 96) = 0;
  *(void *)(v94 + 120) = MEMORY[0x263F8D4F8];
  *(void *)(v94 + 128) = 0x614E74757074754FLL;
  *(void *)(v94 + 136) = 0xEA0000000000656DLL;
  id v95 = v92;
  uint64_t v262 = (_OWORD *)sub_23C6D55A8();
  uint64_t v97 = v96;
  uint64_t v98 = sub_23C6D55A8();
  uint64_t v100 = v99;
  uint64_t v101 = v91;
  uint64_t v251 = v91;
  sub_23C6D46B8();
  id v102 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v103 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  *(void *)(v94 + 144) = sub_23C41B6F8((uint64_t)v262, v97, v98, v100, 0, 0, v101, v88);
  *(void *)(v94 + 168) = v93;
  *(void *)(v94 + 176) = 0x7365707954;
  *(void *)(v94 + 216) = v264;
  *(void *)(v94 + 184) = 0xE500000000000000;
  *(void *)(v94 + 192) = &unk_26EFFCF68;
  uint64_t v104 = MEMORY[0x263F8D310];
  *(void *)(inited + 400) = sub_23C6D5428();
  id v105 = (void *)*MEMORY[0x263F87130];
  *(void *)(inited + 424) = v263;
  *(void *)(inited + 432) = v105;
  __swift_instantiateConcreteTypeFromMangledName(&qword_268BA6C30);
  uint64_t v264 = swift_allocObject();
  *(_OWORD *)(v264 + 16) = xmmword_23C6F81A0;
  uint64_t v263 = sub_23C369F80(0, &qword_268BA5CE0);
  uint64_t v260 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA5CE8);
  uint64_t v106 = swift_allocObject();
  *(_OWORD *)(v106 + 16) = xmmword_23C6F8480;
  id v107 = (void *)*MEMORY[0x263F872D8];
  *(void *)(v106 + 32) = *MEMORY[0x263F872D8];
  *(void *)(v106 + 40) = 0xD000000000000016;
  uint64_t v108 = (void **)MEMORY[0x263F872E0];
  *(void *)(v106 + 48) = 0x800000023C71F540;
  uint64_t v109 = *v108;
  uint64_t v110 = v104;
  *(void *)(v106 + 64) = v104;
  *(void *)(v106 + 72) = v109;
  *(void *)(v106 + 80) = 0x736D657449;
  *(void *)(v106 + 88) = 0xE500000000000000;
  uint64_t v111 = (void *)*MEMORY[0x263F87318];
  *(void *)(v106 + 104) = v110;
  *(void *)(v106 + 112) = v111;
  uint64_t v262 = (_OWORD *)swift_allocObject();
  v262[1] = xmmword_23C6FCAB0;
  id v112 = v105;
  id v259 = v107;
  id v113 = v109;
  id v114 = v111;
  uint64_t v115 = sub_23C6D55A8();
  uint64_t v117 = v116;
  uint64_t v118 = sub_23C6D55A8();
  uint64_t v120 = v119;
  uint64_t v121 = v251;
  sub_23C6D46B8();
  id v122 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v123 = v266;
  sub_23C6D4598();

  id v124 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v258 = inited;
  uint64_t v125 = v123;
  id v126 = sub_23C41B6F8(v115, v117, v118, v120, 0, 0, v121, v123);
  *((void *)v262 + 4) = v126;
  uint64_t v127 = sub_23C6D55A8();
  uint64_t v129 = v128;
  uint64_t v130 = sub_23C6D55A8();
  uint64_t v132 = v131;
  uint64_t v133 = v121;
  sub_23C6D46B8();
  id v134 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v135 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v136 = sub_23C41B6F8(v127, v129, v130, v132, 0, 0, v133, v123);
  uint64_t v137 = v262;
  *((void *)v262 + 5) = v136;
  uint64_t v138 = sub_23C6D55A8();
  uint64_t v140 = v139;
  uint64_t v141 = sub_23C6D55A8();
  uint64_t v143 = v142;
  sub_23C6D46B8();
  id v144 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v145 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  v137[6] = sub_23C41B6F8(v138, v140, v141, v143, 0, 0, v133, v125);
  uint64_t v146 = sub_23C6D55A8();
  uint64_t v148 = v147;
  uint64_t v149 = sub_23C6D55A8();
  uint64_t v151 = v150;
  sub_23C6D46B8();
  id v152 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v153 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v154 = v133;
  id v155 = sub_23C41B6F8(v146, v148, v149, v151, 0, 0, v133, v125);
  id v156 = v137;
  v137[7] = v155;
  uint64_t v157 = sub_23C6D55A8();
  uint64_t v159 = v158;
  uint64_t v160 = sub_23C6D55A8();
  uint64_t v162 = v161;
  uint64_t v163 = v154;
  sub_23C6D46B8();
  id v164 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v165 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  v156[8] = sub_23C41B6F8(v157, v159, v160, v162, 0, 0, v163, v125);
  id v269 = v156;
  sub_23C6D56B8();
  uint64_t v166 = v269;
  uint64_t v167 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F10);
  *(void *)(v106 + 120) = v166;
  uint64_t v168 = (void *)*MEMORY[0x263F87350];
  *(void *)(v106 + 144) = v167;
  *(void *)(v106 + 152) = v168;
  *(void *)(v106 + 160) = 0x54746E756F434657;
  *(void *)(v106 + 168) = 0xEB00000000657079;
  uint64_t v169 = (void *)*MEMORY[0x263F87360];
  *(void *)(v106 + 184) = MEMORY[0x263F8D310];
  *(void *)(v106 + 192) = v169;
  uint64_t v262 = v168;
  id v257 = v169;
  uint64_t v170 = sub_23C6D55A8();
  uint64_t v172 = v171;
  uint64_t v173 = sub_23C6D55A8();
  uint64_t v175 = v174;
  sub_23C6D46B8();
  id v176 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v177 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v178 = v163;
  *(void *)(v106 + 200) = sub_23C41B6F8(v170, v172, v173, v175, 0, 0, v163, v125);
  id v179 = (void *)*MEMORY[0x263F87398];
  uint64_t v180 = v268;
  *(void *)(v106 + 224) = v268;
  *(void *)(v106 + 232) = v179;
  id v181 = v179;
  uint64_t v182 = sub_23C6D55A8();
  uint64_t v184 = v183;
  uint64_t v185 = sub_23C6D55A8();
  uint64_t v187 = v186;
  sub_23C6D46B8();
  id v188 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v189 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v190 = v184;
  uint64_t v191 = v178;
  id v192 = sub_23C41B6F8(v182, v190, v185, v187, 0, 0, v178, v125);
  *(void *)(v106 + 264) = v180;
  *(void *)(v106 + 240) = v192;
  _s3__C3KeyVMa_0(0);
  uint64_t v256 = v193;
  uint64_t v253 = &unk_23C6F7730;
  uint64_t v254 = _s3__C3KeyVMa_0;
  uint64_t v255 = sub_23C375C5C(&qword_26AEEE340, _s3__C3KeyVMa_0);
  uint64_t v194 = sub_23C6D5428();
  uint64_t v252 = _s3__C3KeyVMa_0;
  id v195 = sub_23C41A108(v194, _s3__C3KeyVMa_0, &qword_26AEEE340, _s3__C3KeyVMa_0);
  *(void *)(v264 + 32) = v195;
  uint64_t v196 = swift_allocObject();
  *(_OWORD *)(v196 + 16) = v265;
  id v197 = v259;
  *(void *)(v196 + 32) = v259;
  *(void *)(v196 + 40) = 0xD000000000000019;
  *(void *)(v196 + 48) = 0x800000023C71E930;
  uint64_t v198 = MEMORY[0x263F8D310];
  id v199 = v262;
  *(void *)(v196 + 64) = MEMORY[0x263F8D310];
  *(void *)(v196 + 72) = v199;
  *(void *)(v196 + 80) = 0x7475706E49;
  *(void *)(v196 + 88) = 0xE500000000000000;
  uint64_t v200 = v257;
  *(void *)(v196 + 104) = v198;
  *(void *)(v196 + 112) = v200;
  id v201 = v197;
  id v202 = v199;
  id v203 = v200;
  uint64_t v204 = sub_23C6D55A8();
  uint64_t v206 = v205;
  uint64_t v207 = sub_23C6D55A8();
  uint64_t v209 = v208;
  sub_23C6D46B8();
  id v210 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  uint64_t v211 = v266;
  sub_23C6D4598();

  id v212 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v213 = v191;
  *(void *)(v196 + 120) = sub_23C41B6F8(v204, v206, v207, v209, 0, 0, v191, v211);
  uint64_t v214 = (void *)*MEMORY[0x263F87380];
  uint64_t v215 = v268;
  *(void *)(v196 + 144) = v268;
  *(void *)(v196 + 152) = v214;
  id v216 = v214;
  uint64_t v217 = sub_23C6D55A8();
  uint64_t v219 = v218;
  uint64_t v220 = sub_23C6D55A8();
  uint64_t v222 = v221;
  sub_23C6D46B8();
  id v223 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v224 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  uint64_t v225 = v213;
  id v226 = sub_23C41B6F8(v217, v219, v220, v222, 0, 0, v213, v211);
  *(void *)(v196 + 184) = v215;
  *(void *)(v196 + 160) = v226;
  uint64_t v227 = sub_23C6D5428();
  id v228 = sub_23C41A108(v227, v252, &qword_26AEEE340, v254);
  uint64_t v229 = v264;
  *(void *)(v264 + 40) = v228;
  id v269 = (void *)v229;
  sub_23C6D56B8();
  id v230 = v269;
  uint64_t v231 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_268BA6F20);
  uint64_t v232 = v258;
  *(void *)(v258 + 440) = v230;
  uint64_t v233 = (void *)*MEMORY[0x263F87128];
  *(void *)(v232 + 464) = v231;
  *(void *)(v232 + 472) = v233;
  id v234 = v233;
  uint64_t v235 = sub_23C6D55A8();
  uint64_t v237 = v236;
  uint64_t v238 = sub_23C6D55A8();
  uint64_t v240 = v239;
  sub_23C6D46B8();
  id v241 = objc_msgSend((id)qword_268BA7768, sel_bundleURL);
  sub_23C6D4598();

  id v242 = objc_allocWithZone(MEMORY[0x263F08DB0]);
  id v243 = sub_23C41B6F8(v235, v237, v238, v240, 0, 0, v225, v211);
  id v244 = objc_msgSend(objc_allocWithZone(MEMORY[0x263F86888]), sel_initWithString_, v243);

  uint64_t v245 = sub_23C369F80(0, &qword_268BA5D08);
  uint64_t v246 = (void **)MEMORY[0x263F87108];
  *(void *)(v232 + 480) = v244;
  id v247 = *v246;
  *(void *)(v232 + 504) = v245;
  *(void *)(v232 + 512) = v247;
  *(void *)(v232 + 544) = MEMORY[0x263F8D4F8];
  *(unsigned char *)(v232 + 520) = 1;
  type metadata accessor for Key(0);
  sub_23C375C5C((unint64_t *)&qword_26AEEE8F0, type metadata accessor for Key);
  id v248 = v247;
  uint64_t v249 = sub_23C6D5428();
  return sub_23C41A108(v249, type metadata accessor for Key, (unint64_t *)&qword_26AEEE8F0, type metadata accessor for Key);
}

uint64_t sub_23C41B6D0()
{
  return sub_23C41A208();
}

id sub_23C41B6F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  id v9 = v8;
  uint64_t v14 = (void *)sub_23C6D5528();
  swift_bridgeObjectRelease();
  if (!a4)
  {
    uint64_t v15 = 0;
    if (a6) {
      goto LABEL_3;
    }
LABEL_5:
    uint64_t v16 = 0;
    goto LABEL_6;
  }
  uint64_t v15 = (void *)sub_23C6D5528();
  swift_bridgeObjectRelease();
  if (!a6) {
    goto LABEL_5;
  }
LABEL_3:
  uint64_t v16 = (void *)sub_23C6D5528();
  swift_bridgeObjectRelease();
LABEL_6:
  uint64_t v17 = (void *)sub_23C6D46A8();
  uint64_t v18 = (void *)sub_23C6D4568();
  id v19 = objc_msgSend(v9, sel_initWithKey_defaultValue_table_locale_bundleURL_, v14, v15, v16, v17, v18);

  sub_23C6D45B8();
  OUTLINED_FUNCTION_46_0();
  (*(void (**)(uint64_t))(v20 + 8))(a8);
  sub_23C6D46E8();
  OUTLINED_FUNCTION_46_0();
  (*(void (**)(uint64_t))(v21 + 8))(a7);
  return v19;
}

uint64_t libssh2_sftp_dtor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5 = *a4;
  uint64_t v6 = *(void *)(*a4 + 88);
  if (v6) {
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v6, a1);
  }
  uint64_t v7 = *(void *)(v5 + 192);
  if (v7) {
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v7, a1);
  }
  uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t))(a1 + 24);
  return v8(v5, a1);
}

uint64_t libssh2_sftp_init(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 128) & 4) == 0)
  {
    _libssh2_error(a1, 4294967262, "session not authenticated yet");
    return 0;
  }
  uint64_t v4 = (int *)(a1 + 72892);
  time_t v5 = time(0);
  uint64_t v6 = (_DWORD *)(a1 + 72917);
  while (2)
  {
    unint64_t v31 = 0;
    uint64_t v32 = 0;
    uint64_t v28 = 0;
    unint64_t v29 = 0;
    unint64_t v30 = 0;
    int v7 = *v4;
    uint64_t v2 = *(void *)(a1 + 72896);
    switch(*v4)
    {
      case 0:
        if (v2) {
          libssh2_sftp_init_cold_1();
        }
        *(void *)(a1 + 72896) = 0;
        *uint64_t v4 = 2;
        goto LABEL_10;
      case 2:
LABEL_10:
        uint64_t v8 = _libssh2_channel_open(a1, "session", 7u, 0x200000u, 0x8000u, 0, 0);
        *(void *)(a1 + 72904) = v8;
        if (!v8)
        {
          if (libssh2_session_last_errno(a1) == -37)
          {
            uint64_t v10 = a1;
            uint64_t v11 = 4294967259;
            uint64_t v12 = "Would block starting up channel";
            goto LABEL_41;
          }
          _libssh2_error(a1, 4294967275, "Unable to startup channel");
LABEL_44:
          *uint64_t v4 = 0;
          goto LABEL_53;
        }
        *uint64_t v4 = 3;
LABEL_13:
        int v9 = _libssh2_channel_process_startup(v8, "subsystem", 9uLL, "sftp", 4uLL);
        if (v9)
        {
          if (v9 != -37)
          {
            uint64_t v10 = a1;
            uint64_t v11 = 4294967275;
            uint64_t v17 = "Unable to request SFTP subsystem";
            goto LABEL_51;
          }
          uint64_t v10 = a1;
          uint64_t v11 = 4294967259;
          uint64_t v12 = "Would block to request SFTP subsystem";
LABEL_41:
          _libssh2_error(v10, v11, v12);
          goto LABEL_53;
        }
        *uint64_t v4 = 4;
LABEL_18:
        if (_libssh2_channel_extended_data(*(void *)(a1 + 72904), 1) == -37)
        {
          uint64_t v10 = a1;
          uint64_t v11 = 4294967259;
          uint64_t v12 = "Would block requesting handle extended data";
          goto LABEL_41;
        }
        uint64_t v14 = _libssh2_calloc(a1, 0x168uLL);
        *(void *)(a1 + 72896) = v14;
        if (!v14)
        {
          uint64_t v10 = a1;
          uint64_t v11 = 4294967290;
          uint64_t v17 = "Unable to allocate a new SFTP structure";
          goto LABEL_51;
        }
        uint64_t v2 = (uint64_t)v14;
        *(void *)uint64_t v14 = *(void *)(a1 + 72904);
        v14[2] = 0;
        _libssh2_htonu32((_DWORD *)(a1 + 72912), 5u);
        *(unsigned char *)(a1 + 72916) = 1;
        _libssh2_htonu32(v6, 3u);
        uint64_t v13 = 0;
        *(void *)(a1 + 72928) = 0;
        *uint64_t v4 = 5;
LABEL_22:
        uint64_t v15 = _libssh2_channel_write(*(void *)(a1 + 72904), 0, (const void *)(a1 + 72912 + v13), 9 - v13);
        if (v15 == -37)
        {
          uint64_t v10 = a1;
          uint64_t v11 = 4294967259;
          uint64_t v12 = "Would block sending SSH_FXP_INIT";
          goto LABEL_41;
        }
        if (v15 < 0)
        {
          uint64_t v10 = a1;
          uint64_t v11 = 4294967289;
          uint64_t v17 = "Unable to send SSH_FXP_INIT";
          goto LABEL_51;
        }
        uint64_t v16 = *(void *)(a1 + 72928) + v15;
        *(void *)(a1 + 72928) = v16;
        if (v16 == 9)
        {
          *uint64_t v4 = 6;
          goto LABEL_37;
        }
        int v7 = *v4;
LABEL_34:
        if (v7 == 16)
        {
          if (_libssh2_channel_free(*(void *)(a1 + 72904)) == -37)
          {
            uint64_t v10 = a1;
            uint64_t v11 = 4294967259;
            uint64_t v12 = "Would block closing channel";
            goto LABEL_41;
          }
          *(void *)(a1 + 72904) = 0;
          uint64_t v19 = *(void *)(a1 + 72896);
          if (v19)
          {
            (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v19, a1);
            *(void *)(a1 + 72896) = 0;
          }
          goto LABEL_44;
        }
LABEL_37:
        uint64_t v18 = sftp_packet_require(v2, 2, 0, &v32, &v31, 5uLL);
        if (v18 == -38)
        {
          if (v31) {
            (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v32, a1);
          }
          uint64_t v10 = a1;
          uint64_t v11 = 4294967265;
          uint64_t v17 = "Invalid SSH_FXP_VERSION response";
          goto LABEL_51;
        }
        uint64_t v11 = v18;
        if (v18)
        {
          uint64_t v10 = a1;
          if (v11 == -37)
          {
            uint64_t v12 = "Would block receiving SSH_FXP_VERSION";
            goto LABEL_41;
          }
          uint64_t v17 = "Timeout waiting for response from SFTP subsystem";
LABEL_51:
          _libssh2_error(v10, v11, v17);
          goto LABEL_52;
        }
        uint64_t v20 = v6;
        unint64_t v22 = v31;
        uint64_t v21 = v32;
        uint64_t v28 = v32;
        unint64_t v29 = v32 + 1;
        unint64_t v30 = v31;
        id v23 = (_DWORD *)(v2 + 12);
        if (_libssh2_get_u32(&v28, (_DWORD *)(v2 + 12)))
        {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v32, a1);
          goto LABEL_65;
        }
        if (*v23 >= 4u) {
          *id v23 = 3;
        }
        while (1)
        {
          if (v29 >= v21 + v22)
          {
            (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v32, a1);
            uint64_t v25 = *(void *)v2;
            *(void *)(v25 + 112) = v2;
            *(void *)(v25 + 120) = libssh2_sftp_dtor;
            *(void *)uint64_t v4 = 0;
            *(void *)(a1 + 72900) = 0;
            *(_DWORD *)(a1 + 72908) = 0;
            _libssh2_list_init((void *)(v2 + 48));
            return v2;
          }
          uint64_t v26 = 0;
          uint64_t v27 = 0;
          if (_libssh2_get_string(&v28, &v27, 0)) {
            break;
          }
          if (_libssh2_get_string(&v28, &v26, 0))
          {
            (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v32, a1);
            uint64_t v24 = "Data too short when extracting extdata";
            goto LABEL_64;
          }
        }
        (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v32, a1);
        uint64_t v24 = "Data too short when extracting extname";
LABEL_64:
        _libssh2_error(a1, 4294967258, v24);
LABEL_65:
        uint64_t v6 = v20;
LABEL_52:
        *uint64_t v4 = 16;
LABEL_53:
        if (*(_DWORD *)(a1 + 172)
          && libssh2_session_last_errno(a1) == -37
          && !_libssh2_wait_socket(a1, v5))
        {
          continue;
        }
        return 0;
      case 3:
        uint64_t v8 = *(void *)(a1 + 72904);
        goto LABEL_13;
      case 4:
        goto LABEL_18;
      case 5:
        uint64_t v13 = *(void *)(a1 + 72928);
        goto LABEL_22;
      default:
        goto LABEL_34;
    }
  }
}

uint64_t libssh2_sftp_shutdown(uint64_t *a1)
{
  if (!a1) {
    return 4294967257;
  }
  time_t v2 = time(0);
  do
  {
    uint64_t v3 = *(void *)(*a1 + 104);
    uint64_t v4 = a1[11];
    if (v4)
    {
      (*(void (**)(uint64_t, void))(v3 + 24))(v4, *(void *)(*a1 + 104));
      a1[11] = 0;
    }
    uint64_t v5 = a1[16];
    if (v5)
    {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v5, v3);
      a1[16] = 0;
    }
    uint64_t v6 = a1[24];
    if (v6)
    {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v6, v3);
      a1[24] = 0;
    }
    uint64_t v7 = a1[26];
    if (v7)
    {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v7, v3);
      a1[26] = 0;
    }
    uint64_t v8 = a1[28];
    if (v8)
    {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v8, v3);
      a1[28] = 0;
    }
    uint64_t v9 = a1[30];
    if (v9)
    {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v9, v3);
      a1[30] = 0;
    }
    uint64_t v10 = a1[33];
    if (v10)
    {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v10, v3);
      a1[33] = 0;
    }
    uint64_t v11 = a1[35];
    if (v11)
    {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v11, v3);
      a1[35] = 0;
    }
    uint64_t v12 = a1[37];
    if (v12)
    {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v12, v3);
      a1[37] = 0;
    }
    uint64_t v13 = a1[39];
    if (v13)
    {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v13, v3);
      a1[39] = 0;
    }
    uint64_t v14 = a1[41];
    if (v14)
    {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v14, v3);
      a1[41] = 0;
    }
    uint64_t v15 = a1[43];
    if (v15)
    {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v15, v3);
      a1[43] = 0;
    }
    uint64_t v16 = a1[22];
    if (v16)
    {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v16, v3);
      a1[22] = 0;
    }
    uint64_t v17 = *(void *)(*a1 + 104);
    uint64_t v18 = (uint64_t *)_libssh2_list_first((uint64_t)(a1 + 2));
    uint64_t v19 = (uint64_t *)_libssh2_list_first((uint64_t)(a1 + 4));
    if (v18)
    {
      do
      {
        uint64_t v20 = _libssh2_list_next((uint64_t)v18);
        _libssh2_list_remove(v18);
        (*(void (**)(uint64_t, uint64_t))(v17 + 24))(v18[4], v17);
        (*(void (**)(uint64_t *, uint64_t))(v17 + 24))(v18, v17);
        uint64_t v18 = (uint64_t *)v20;
      }
      while (v20);
    }
    if (v19)
    {
      do
      {
        uint64_t v21 = _libssh2_list_next((uint64_t)v19);
        _libssh2_list_remove(v19);
        (*(void (**)(uint64_t *, uint64_t))(v17 + 24))(v19, v17);
        uint64_t v19 = (uint64_t *)v21;
      }
      while (v21);
    }
    uint64_t result = _libssh2_channel_free(*a1);
    if (result != -37) {
      break;
    }
    uint64_t v23 = *(void *)(*a1 + 104);
    if (!*(_DWORD *)(v23 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(v23, v2);
  }
  while (!result);
  return result;
}

void *libssh2_sftp_open_ex(void *result, const void *a2, unsigned int a3, unsigned int a4, uint64_t a5, int a6)
{
  if (result)
  {
    uint64_t v11 = (uint64_t)result;
    time_t v12 = time(0);
    while (1)
    {
      uint64_t result = sftp_open(v11, a2, a3, a4, a5, a6, 0);
      if (!*(_DWORD *)(*(void *)(*(void *)v11 + 104) + 172) || result != 0) {
        break;
      }
      if (libssh2_session_last_errno(*(void *)(*(void *)v11 + 104)) != -37
        || _libssh2_wait_socket(*(void *)(*(void *)v11 + 104), v12))
      {
        return 0;
      }
    }
  }
  return result;
}

void *sftp_open(uint64_t a1, const void *a2, unint64_t a3, unsigned int a4, uint64_t a5, int a6, uint64_t a7)
{
  uint64_t v9 = *(void *)a1;
  uint64_t v10 = *(void *)(*(void *)a1 + 104);
  memset((char *)v44 + 8, 0, 48);
  uint64_t v43 = 0;
  *(void *)&v44[0] = 4;
  int v11 = *(_DWORD *)(a1 + 120);
  if (v11 != 2)
  {
    if (v11) {
      goto LABEL_25;
    }
    *(_DWORD *)(a1 + 64) = 0;
    if (a7)
    {
      long long v16 = *(_OWORD *)(a7 + 16);
      v44[0] = *(_OWORD *)a7;
      v44[1] = v16;
      v44[2] = *(_OWORD *)(a7 + 32);
      *(void *)&v44[3] = *(void *)(a7 + 48);
    }
    if (a6) {
      int v17 = 0;
    }
    else {
      int v17 = (v44[0] & 0xC) + 8 * (v44[0] & 1) + ((4 * LODWORD(v44[0])) & 8) + 8;
    }
    *(_DWORD *)(a1 + 136) = a3 + v17 + 13;
    *(void *)(a1 + 144) = 0;
    uint64_t v18 = (_DWORD *)(*(uint64_t (**)(void))(v10 + 8))();
    *(void *)(a1 + 128) = v18;
    uint64_t v43 = v18;
    if (!v18)
    {
      uint64_t v26 = "Unable to allocate memory for FXP_OPEN or FXP_OPENDIR packet";
      uint64_t v27 = v10;
      uint64_t v28 = 4294967290;
      goto LABEL_36;
    }
    unsigned int v19 = *(_DWORD *)(a1 + 136) - 4;
    uint64_t v20 = 0x8000;
    if (a6) {
      uint64_t v20 = 0x4000;
    }
    *(void *)&v44[2] = v20 | a5;
    if (a6) {
      char v21 = 11;
    }
    else {
      char v21 = 3;
    }
    _libssh2_store_u32(&v43, v19);
    unint64_t v22 = (char *)v43;
    uint64_t v43 = (_DWORD *)((char *)v43 + 1);
    char *v22 = v21;
    unsigned int v23 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(a1 + 8) = v23 + 1;
    *(_DWORD *)(a1 + 152) = v23;
    _libssh2_store_u32(&v43, v23);
    _libssh2_store_str(&v43, a2, a3);
    if (!a6)
    {
      _libssh2_store_u32(&v43, a4);
      uint64_t v24 = sftp_attr2bin((char *)v43, (uint64_t *)v44);
      uint64_t v43 = (_DWORD *)((char *)v43 + v24);
    }
    *(_DWORD *)(a1 + 120) = 2;
  }
  uint64_t v25 = _libssh2_channel_write(v9, 0, (const void *)(*(void *)(a1 + 128) + *(void *)(a1 + 144)), *(unsigned int *)(a1 + 136) - *(void *)(a1 + 144));
  if (v25 == -37)
  {
    uint64_t v26 = "Would block sending FXP_OPEN or FXP_OPENDIR command";
    uint64_t v27 = v10;
    uint64_t v28 = 4294967259;
LABEL_36:
    _libssh2_error(v27, v28, v26);
    return 0;
  }
  if (v25 < 0)
  {
    _libssh2_error(v10, v25, "Unable to send FXP_OPEN*");
    (*(void (**)(void, uint64_t))(v10 + 24))(*(void *)(a1 + 128), v10);
    unint64_t v30 = 0;
    *(void *)(a1 + 128) = 0;
    *(_DWORD *)(a1 + 120) = 0;
    return v30;
  }
  uint64_t v29 = *(void *)(a1 + 144) + v25;
  *(void *)(a1 + 144) = v29;
  if (v29 == *(_DWORD *)(a1 + 136))
  {
    (*(void (**)(void, uint64_t))(v10 + 24))(*(void *)(a1 + 128), v10);
    *(void *)(a1 + 128) = 0;
    *(_DWORD *)(a1 + 120) = 3;
    goto LABEL_26;
  }
  int v11 = *(_DWORD *)(a1 + 120);
LABEL_25:
  if (v11 != 3) {
    return 0;
  }
LABEL_26:
  uint64_t v41 = 0;
  unint64_t v42 = 0;
  uint64_t v31 = sftp_packet_requirev((void *)a1, (uint64_t)&sftp_open_fopen_responses, *(_DWORD *)(a1 + 152), &v41, &v42, 1uLL);
  if (v31 == -38)
  {
    if (v42) {
      (*(void (**)(uint64_t, uint64_t))(v10 + 24))(v41, v10);
    }
    uint64_t v26 = "Response too small";
    goto LABEL_32;
  }
  uint64_t v28 = v31;
  if (v31 == -37)
  {
    uint64_t v26 = "Would block waiting for status message";
LABEL_35:
    uint64_t v27 = v10;
    goto LABEL_36;
  }
  *(_DWORD *)(a1 + 120) = 0;
  if (v31)
  {
    uint64_t v26 = "Timeout waiting for status message";
    goto LABEL_35;
  }
  if (*(unsigned char *)v41 == 101)
  {
    if (v42 <= 8)
    {
      id v33 = "Too small FXP_STATUS";
LABEL_50:
      _libssh2_error(v10, 4294967265, v33);
      (*(void (**)(uint64_t, uint64_t))(v10 + 24))(v41, v10);
      return 0;
    }
    int v34 = _libssh2_ntohu32((unsigned int *)(v41 + 5));
    *(_DWORD *)(a1 + 64) = v34;
    if (v34)
    {
LABEL_43:
      id v33 = "Failed opening remote file";
      goto LABEL_50;
    }
    (*(void (**)(uint64_t, uint64_t))(v10 + 24))(v41, v10);
    int v35 = sftp_packet_require(a1, 102, *(_DWORD *)(a1 + 152), &v41, &v42, 0xAuLL);
    if (v35 != -38)
    {
      if (v35)
      {
        if (v35 == -37)
        {
          unint64_t v30 = 0;
          *(_DWORD *)(a1 + 120) = 3;
          return v30;
        }
        goto LABEL_43;
      }
      goto LABEL_48;
    }
    if (v42) {
      (*(void (**)(uint64_t, uint64_t))(v10 + 24))(v41, v10);
    }
    uint64_t v26 = "Too small FXP_HANDLE";
LABEL_32:
    uint64_t v27 = v10;
    uint64_t v28 = 4294967265;
    goto LABEL_36;
  }
LABEL_48:
  if (v42 <= 9)
  {
    id v33 = "Too small FXP_HANDLE";
    goto LABEL_50;
  }
  uint64_t v36 = _libssh2_calloc(v10, 0x188uLL);
  unint64_t v30 = v36;
  if (v36)
  {
    *((_DWORD *)v36 + 74) = a6 != 0;
    unsigned int v37 = _libssh2_ntohu32((unsigned int *)(v41 + 5));
    if (v37 >= 0x100) {
      unint64_t v38 = 256;
    }
    else {
      unint64_t v38 = v37;
    }
    uint64_t v39 = v41;
    if (v42 - 9 >= v38) {
      size_t v40 = v38;
    }
    else {
      size_t v40 = v42 - 9;
    }
    v30[36] = v40;
    memcpy(v30 + 4, (const void *)(v39 + 9), v40);
    (*(void (**)(uint64_t, uint64_t))(v10 + 24))(v39, v10);
    _libssh2_list_add((void **)(a1 + 48), v30);
    v30[3] = a1;
    v30[38] = 0;
    v30[39] = 0;
  }
  else
  {
    _libssh2_error(v10, 4294967290, "Unable to allocate new SFTP handle structure");
    (*(void (**)(uint64_t, uint64_t))(v10 + 24))(v41, v10);
  }
  return v30;
}

void *libssh2_sftp_open_ex_r(void *result, const void *a2, unint64_t a3, unsigned int a4, uint64_t a5, int a6, uint64_t a7)
{
  if (result)
  {
    uint64_t v13 = (uint64_t)result;
    time_t v14 = time(0);
    while (1)
    {
      uint64_t result = sftp_open(v13, a2, a3, a4, a5, a6, a7);
      if (!*(_DWORD *)(*(void *)(*(void *)v13 + 104) + 172) || result != 0) {
        break;
      }
      if (libssh2_session_last_errno(*(void *)(*(void *)v13 + 104)) != -37
        || _libssh2_wait_socket(*(void *)(*(void *)v13 + 104), v14))
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t libssh2_sftp_read(uint64_t a1, char *a2, size_t a3)
{
  if (!a1) {
    return -39;
  }
  time_t v57 = time(0);
  uint64_t v5 = 4 * a3;
  if (4 * a3 >= 0x800000) {
    uint64_t v5 = 0x800000;
  }
  unint64_t v55 = v5;
  unsigned int v54 = 8 * v5;
  while (2)
  {
    uint64_t v6 = *(_DWORD **)(a1 + 24);
    uint64_t v7 = *(void *)v6;
    uint64_t v8 = *(void *)(*(void *)v6 + 104);
    int v9 = v6[39];
    if (v9 == 5)
    {
LABEL_44:
      v6[39] = 0;
      uint64_t v33 = _libssh2_list_first(a1 + 376);
      if (v33)
      {
        uint64_t v34 = v33;
        size_t v11 = 0;
        int v35 = a2;
        while (1)
        {
          unint64_t v58 = 0;
          uint64_t v59 = 0;
          if (*(void *)(v34 + 48))
          {
LABEL_67:
            if (v11) {
              goto LABEL_80;
            }
            goto LABEL_68;
          }
          int v36 = sftp_packet_requirev(v6, (uint64_t)&sftp_read_read_responses, *(_DWORD *)(v34 + 56), &v59, &v58, 9uLL);
          if (v36 == -37 && v11 != 0) {
            goto LABEL_80;
          }
          if (v36 == -38)
          {
            if (v58) {
              (*(void (**)(_DWORD *, uint64_t))(v8 + 24))(v59, v8);
            }
            uint64_t v47 = v8;
            uint64_t v48 = "Response too small";
            goto LABEL_69;
          }
          if (v36 < 0)
          {
            size_t v11 = v36;
            int v49 = 5;
            goto LABEL_79;
          }
          int v38 = *(unsigned __int8 *)v59;
          if (v38 != 103) {
            break;
          }
          if (*(void *)(v34 + 24) != *(void *)(a1 + 304))
          {
            uint64_t v47 = v8;
            uint64_t v48 = "Read Packet At Unexpected Offset";
            goto LABEL_69;
          }
          unsigned int v39 = _libssh2_ntohu32((_DWORD *)((char *)v59 + 5));
          unint64_t v40 = v58;
          if (v58 - 9 < v39)
          {
            uint64_t v47 = v8;
            uint64_t v48 = "SFTP Protocol badness";
            goto LABEL_69;
          }
          size_t v41 = v39;
          unint64_t v42 = *(void *)(v34 + 32);
          BOOL v43 = v39 >= v42;
          unint64_t v44 = v39 - v42;
          if (v44 != 0 && v43)
          {
            uint64_t v47 = v8;
            uint64_t v48 = "FXP_READ response too big";
            goto LABEL_69;
          }
          if (v44) {
            *(void *)(a1 + 312) += v44;
          }
          if (v11 + v39 <= a3)
          {
            unint64_t v40 = 0;
            uint64_t v45 = v59;
            v11 += v39;
          }
          else
          {
            *(void *)(a1 + 344) = v11 + v39 - a3;
            size_t v41 = (a3 - v11);
            uint64_t v45 = v59;
            *(void *)(a1 + 328) = v59;
            v11 += v41;
          }
          *(void *)(a1 + 336) = v40;
          memcpy(v35, (char *)v45 + 9, v41);
          *(void *)(a1 + 304) += v41;
          if (!*(void *)(a1 + 336)) {
            (*(void (**)(_DWORD *, uint64_t))(v8 + 24))(v45, v8);
          }
          uint64_t v46 = _libssh2_list_next(v34);
          _libssh2_list_remove((uint64_t *)v34);
          (*(void (**)(uint64_t, uint64_t))(v8 + 24))(v34, v8);
          if (v11 < a3)
          {
            v35 += v41;
            uint64_t v34 = v46;
            if (v46) {
              continue;
            }
          }
          goto LABEL_67;
        }
        if (v38 == 101)
        {
          _libssh2_list_remove((uint64_t *)v34);
          (*(void (**)(uint64_t, uint64_t))(v8 + 24))(v34, v8);
          sftp_packetlist_flush(a1);
          int v50 = _libssh2_ntohu32((_DWORD *)((char *)v59 + 5));
          (*(void (**)(_DWORD *, uint64_t))(v8 + 24))(v59, v8);
          if (v50 == 1)
          {
            *(unsigned char *)(a1 + 352) = 1;
            goto LABEL_80;
          }
          v6[16] = v50;
          uint64_t v47 = v8;
          uint64_t v48 = "SFTP READ error";
        }
        else
        {
          uint64_t v47 = v8;
          uint64_t v48 = "SFTP Protocol badness: unrecognised read request response";
        }
      }
      else
      {
LABEL_68:
        uint64_t v47 = v8;
        uint64_t v48 = "sftp_read() internal error";
      }
LABEL_69:
      int v16 = _libssh2_error(v47, 4294967265, v48);
      goto LABEL_70;
    }
    if (v9 != 3)
    {
      if (v9) {
        libssh2_sftp_read_cold_1();
      }
      v6[16] = 0;
      size_t v10 = *(void *)(a1 + 344);
      if (v10)
      {
        if (v10 >= a3) {
          size_t v11 = a3;
        }
        else {
          size_t v11 = *(void *)(a1 + 344);
        }
        memcpy(a2, (const void *)(*(void *)(a1 + 328) + *(void *)(a1 + 336) - v10), v11);
        uint64_t v12 = *(void *)(a1 + 344);
        *(void *)(a1 + 304) += v11;
        size_t v13 = v12 - v11;
        *(void *)(a1 + 344) = v13;
        if (!v13)
        {
          (*(void (**)(void, uint64_t))(v8 + 24))(*(void *)(a1 + 328), v8);
          *(void *)(a1 + 328) = 0;
        }
        goto LABEL_80;
      }
      if (*(unsigned char *)(a1 + 352)) {
        return 0;
      }
      unint64_t v14 = *(void *)(a1 + 312) - *(void *)(a1 + 304);
      if (v55 >= v14) {
        unint64_t v15 = v55 - v14;
      }
      else {
        unint64_t v15 = 0;
      }
      if (v55 > libssh2_channel_window_read_ex(v7, 0, 0))
      {
        int v16 = _libssh2_channel_receive_window_adjust(*(void *)v6, v54, 1, 0);
        if (v16)
        {
          if (v16 == -37)
          {
            if (*(void *)(a1 + 344)) {
              libssh2_sftp_read_cold_3();
            }
            if (*(unsigned char *)(a1 + 352)) {
              libssh2_sftp_read_cold_2();
            }
            goto LABEL_81;
          }
LABEL_70:
          size_t v11 = v16;
          goto LABEL_80;
        }
      }
      if (v55 > v14)
      {
        do
        {
          unint64_t v17 = a3;
          uint64_t v59 = 0;
          uint64_t v18 = *(void *)(a1 + 288);
          uint64_t v19 = (v18 + 25);
          uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 8))(v19 + 64, v8);
          if (!v20)
          {
            size_t v11 = (int)_libssh2_error(v8, 4294967290, "malloc fail for FXP_WRITE");
            a3 = v17;
            goto LABEL_80;
          }
          uint64_t v21 = v20;
          unint64_t v22 = v17;
          if (v17 <= v15) {
            unsigned int v23 = v15;
          }
          else {
            unsigned int v23 = v17;
          }
          if (v23 >= 0x7530) {
            unint64_t v24 = 30000;
          }
          else {
            unint64_t v24 = v23;
          }
          *(void *)(v20 + 24) = *(void *)(a1 + 312);
          *(void *)(v20 + 32) = v24;
          *(void *)(v20 + 40) = 0;
          *(void *)(v20 + 48) = v19;
          a3 = v22;
          uint64_t v59 = (_DWORD *)(v20 + 60);
          _libssh2_store_u32(&v59, v18 + 21);
          uint64_t v25 = v59;
          uint64_t v59 = (_DWORD *)((char *)v59 + 1);
          *uint64_t v25 = 5;
          unsigned int v26 = v6[2];
          v6[2] = v26 + 1;
          *(_DWORD *)(v21 + 56) = v26;
          _libssh2_store_u32(&v59, v26);
          _libssh2_store_str(&v59, (const void *)(a1 + 32), *(void *)(a1 + 288));
          *(void *)uint64_t v59 = bswap64(*(void *)(a1 + 312));
          v59 += 2;
          *(void *)(a1 + 312) += v24;
          _libssh2_store_u32(&v59, v24);
          _libssh2_list_add((void **)(a1 + 376), (void *)v21);
          BOOL v27 = v15 > v24;
          if (v15 >= v24) {
            v15 -= v24;
          }
          else {
            unint64_t v15 = 0;
          }
        }
        while (v27);
      }
    }
    v6[39] = 0;
    uint64_t v28 = _libssh2_list_first(a1 + 376);
    if (!v28) {
      goto LABEL_44;
    }
    uint64_t v29 = v28;
    while (1)
    {
      while (1)
      {
        unint64_t v30 = *(void *)(v29 + 48);
        if (v30) {
          break;
        }
LABEL_43:
        uint64_t v29 = _libssh2_list_next(v29);
        if (!v29) {
          goto LABEL_44;
        }
      }
      uint64_t v31 = _libssh2_channel_write(v7, 0, (const void *)(v29 + *(void *)(v29 + 40) + 60), v30);
      size_t v11 = v31;
      if (v31 < 0) {
        break;
      }
      uint64_t v32 = *(void *)(v29 + 48) - v31;
      *(void *)(v29 + 40) += v31;
      *(void *)(v29 + 48) = v32;
      if (!v32) {
        goto LABEL_43;
      }
      if (v29 != _libssh2_list_first(a1 + 376)) {
        goto LABEL_44;
      }
    }
    int v49 = 3;
LABEL_79:
    v6[39] = v49;
LABEL_80:
    if (v11 == -37)
    {
LABEL_81:
      uint64_t v51 = *(void *)(**(void **)(a1 + 24) + 104);
      if (!*(_DWORD *)(v51 + 172)) {
        return -37;
      }
      int v52 = _libssh2_wait_socket(v51, v57);
      if (v52) {
        return v52;
      }
      continue;
    }
    return v11;
  }
}

uint64_t libssh2_sftp_readdir_ex(uint64_t a1, void *a2, unint64_t a3, void *a4, unint64_t a5, uint64_t a6)
{
  if (!a1) {
    return 4294967257;
  }
  time_t v12 = time(0);
  while (1)
  {
    uint64_t result = sftp_readdir(a1, a2, a3, a4, a5, a6);
    if (result != -37) {
      break;
    }
    uint64_t v14 = *(void *)(**(void **)(a1 + 24) + 104);
    if (!*(_DWORD *)(v14 + 172)) {
      return -37;
    }
    LODWORD(result) = _libssh2_wait_socket(v14, v12);
    if (result) {
      return result;
    }
  }
  return result;
}

uint64_t sftp_readdir(uint64_t a1, void *a2, unint64_t a3, void *a4, unint64_t a5, uint64_t a6)
{
  uint64_t v11 = *(void *)(a1 + 24);
  uint64_t v12 = *(void *)v11;
  uint64_t v13 = *(void *)(*(void *)v11 + 104);
  uint64_t v51 = 0;
  unint64_t v52 = 0;
  int v14 = *(_DWORD *)(a1 + 288);
  uint64_t v50 = 0;
  int v15 = *(_DWORD *)(v11 + 188);
  if (!v15)
  {
    *(_DWORD *)(v11 + 64) = 0;
    if (!*(_DWORD *)(a1 + 304))
    {
      uint64_t v47 = a6;
      unsigned int v37 = (_DWORD *)(*(uint64_t (**)(void, uint64_t))(v13 + 8))((v14 + 13), v13);
      *(void *)(v11 + 192) = v37;
      uint64_t v51 = v37;
      if (!v37)
      {
        uint64_t v20 = "Unable to allocate memory for FXP_READDIR packet";
        uint64_t v21 = v13;
        uint64_t v19 = 4294967290;
        return (int)_libssh2_error(v21, v19, v20);
      }
      _libssh2_store_u32(&v51, v14 + 9);
      int v38 = v51;
      uint64_t v51 = (_DWORD *)((char *)v51 + 1);
      *int v38 = 12;
      unsigned int v39 = *(_DWORD *)(v11 + 8);
      *(_DWORD *)(v11 + 8) = v39 + 1;
      *(_DWORD *)(v11 + 200) = v39;
      _libssh2_store_u32(&v51, v39);
      _libssh2_store_str(&v51, (const void *)(a1 + 32), *(void *)(a1 + 288));
      *(_DWORD *)(v11 + 188) = 2;
      goto LABEL_3;
    }
    uint64_t v49 = 0;
    memset(v48, 0, sizeof(v48));
    unint64_t v22 = *(void *)(a1 + 328);
    unint64_t v23 = v22 - 4;
    if (v22 >= 4)
    {
      uint64_t v25 = *(unsigned int **)(a1 + 320);
      unsigned int v26 = _libssh2_ntohu32(v25);
      uint64_t v27 = v26;
      if (v26 < a3 && v23 >= v26)
      {
        uint64_t v29 = v25 + 1;
        memcpy(a2, v25 + 1, v26);
        *((unsigned char *)a2 + v27) = 0;
        unint64_t v30 = v23 - v27 - 4;
        if (v23 - v27 >= 4)
        {
          uint64_t v31 = (unsigned int *)((char *)v29 + v27);
          unsigned int v32 = _libssh2_ntohu32(v31);
          unint64_t v33 = v32;
          uint64_t v34 = (char *)(v31 + 1);
          if (a4 && a5 >= 2)
          {
            if (v32 >= a5 || v30 < v32) {
              return -38;
            }
            memcpy(a4, v34, v32);
            *((unsigned char *)a4 + v33) = 0;
          }
          if (v30 >= v33)
          {
            if (a6)
            {
              int v36 = (void *)a6;
              *(void *)(a6 + 48) = 0;
              *(_OWORD *)(a6 + 16) = 0u;
              *(_OWORD *)(a6 + 32) = 0u;
              *(_OWORD *)a6 = 0u;
            }
            else
            {
              int v36 = v48;
            }
            uint64_t v44 = sftp_bin2attr(v36, (uint64_t)&v34[v33], v30 - v33);
            if ((v44 & 0x8000000000000000) == 0)
            {
              *(void *)(a1 + 320) = &v34[v33 + v44];
              *(void *)(a1 + 328) = v30 - v33 - v44;
              int v45 = *(_DWORD *)(a1 + 304) - 1;
              *(_DWORD *)(a1 + 304) = v45;
              if (!v45) {
                (*(void (**)(void, uint64_t))(v13 + 24))(*(void *)(a1 + 312), v13);
              }
              return v27;
            }
          }
        }
      }
    }
    return -38;
  }
  uint64_t v47 = a6;
  if (v15 == 2)
  {
LABEL_3:
    uint64_t v16 = _libssh2_channel_write(v12, 0, *(const void **)(v11 + 192), (v14 + 13));
    if (v16 == -37) {
      return -37;
    }
    uint64_t v17 = v16;
    (*(void (**)(void, uint64_t))(v13 + 24))(*(void *)(v11 + 192), v13);
    *(void *)(v11 + 192) = 0;
    if (v17 != v14 + 13)
    {
      *(_DWORD *)(v11 + 188) = 0;
      uint64_t v20 = "_libssh2_channel_write() failed";
      uint64_t v21 = v13;
      uint64_t v19 = 4294967289;
      return (int)_libssh2_error(v21, v19, v20);
    }
    *(_DWORD *)(v11 + 188) = 3;
  }
  uint64_t v18 = sftp_packet_requirev((void *)v11, (uint64_t)&sftp_readdir_read_responses, *(_DWORD *)(v11 + 200), &v50, &v52, 9uLL);
  if (v18)
  {
    uint64_t v19 = v18;
    if (v18 != -37)
    {
      if (v18 != -38)
      {
        *(_DWORD *)(v11 + 188) = 0;
        uint64_t v20 = "Timeout waiting for status message";
        uint64_t v21 = v13;
        return (int)_libssh2_error(v21, v19, v20);
      }
      if (v52) {
        (*(void (**)(uint64_t, uint64_t))(v13 + 24))(v50, v13);
      }
      uint64_t v20 = "Status message too short";
LABEL_12:
      uint64_t v21 = v13;
      uint64_t v19 = 4294967265;
      return (int)_libssh2_error(v21, v19, v20);
    }
    return -37;
  }
  uint64_t v40 = v50;
  if (*(unsigned char *)v50 == 101)
  {
    int v41 = _libssh2_ntohu32((unsigned int *)(v50 + 5));
    (*(void (**)(uint64_t, uint64_t))(v13 + 24))(v50, v13);
    if (v41 != 1)
    {
      *(_DWORD *)(v11 + 64) = v41;
      *(_DWORD *)(v11 + 188) = 0;
      uint64_t v20 = "SFTP Protocol Error";
      goto LABEL_12;
    }
    uint64_t v27 = 0;
    *(_DWORD *)(v11 + 188) = 0;
  }
  else
  {
    *(_DWORD *)(v11 + 188) = 0;
    int v42 = _libssh2_ntohu32((unsigned int *)(v40 + 5));
    if (v42)
    {
      *(_DWORD *)(a1 + 304) = v42;
      uint64_t v43 = v50 + 9;
      *(void *)(a1 + 312) = v50;
      *(void *)(a1 + 320) = v43;
      *(void *)(a1 + 328) = v52 - 9;
      return sftp_readdir(a1, a2, a3, a4, a5, v47);
    }
    else
    {
      (*(void (**)(uint64_t, uint64_t))(v13 + 24))(v50, v13);
      return 0;
    }
  }
  return v27;
}

uint64_t libssh2_sftp_write(void *a1, uint64_t a2, unint64_t a3)
{
  if (!a1) {
    return -39;
  }
  time_t v4 = time(0);
  int v36 = (void **)(a1 + 47);
  time_t v34 = v4;
  while (1)
  {
    uint64_t v5 = (_DWORD *)a1[3];
    uint64_t v6 = *(void *)v5;
    uint64_t v7 = *(void *)(*(void *)v5 + 104);
    int v38 = 0;
    unint64_t v39 = 0;
    uint64_t v37 = 0;
    if (v5[41] == 3) {
      break;
    }
    v5[16] = 0;
    unint64_t v8 = a1[39] - a1[38] + a1[40];
    v5[41] = 0;
    if (v8 >= a3)
    {
LABEL_14:
      uint64_t v18 = _libssh2_list_first((uint64_t)v36);
      time_t v4 = v34;
      if (v18)
      {
        uint64_t v19 = v18;
        do
        {
          unint64_t v20 = *(void *)(v19 + 48);
          if (v20)
          {
            uint64_t result = _libssh2_channel_write(v6, 0, (const void *)(v19 + *(void *)(v19 + 40) + 60), v20);
            if (result < 0) {
              goto LABEL_43;
            }
            uint64_t v22 = *(void *)(v19 + 48) - result;
            *(void *)(v19 + 40) += result;
            *(void *)(v19 + 48) = v22;
            if (v22) {
              break;
            }
          }
          uint64_t v19 = _libssh2_list_next(v19);
        }
        while (v19);
      }
      break;
    }
    if (a3 >= v8) {
      unint64_t v9 = a3 - v8;
    }
    else {
      unint64_t v9 = 0;
    }
    size_t v10 = (char *)(a2 + v8);
    while (1)
    {
      unint64_t v11 = v9 >= 0x7530 ? 30000 : v9;
      unint64_t v12 = a1[36] + v11;
      uint64_t v13 = (v12 + 25);
      uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 8))(v13 + 64, v7);
      if (!v14) {
        break;
      }
      uint64_t v15 = v14;
      *(void *)(v14 + 32) = v11;
      *(void *)(v14 + 40) = 0;
      *(void *)(v14 + 48) = v13;
      int v38 = (_DWORD *)(v14 + 60);
      _libssh2_store_u32(&v38, v12 + 21);
      uint64_t v16 = v38;
      int v38 = (_DWORD *)((char *)v38 + 1);
      *uint64_t v16 = 6;
      unsigned int v17 = v5[2];
      v5[2] = v17 + 1;
      *(_DWORD *)(v15 + 56) = v17;
      _libssh2_store_u32(&v38, v17);
      _libssh2_store_str(&v38, a1 + 4, a1[36]);
      *(void *)int v38 = bswap64(a1[39]);
      v38 += 2;
      a1[39] += v11;
      _libssh2_store_str(&v38, v10, v11);
      _libssh2_list_add(v36, (void *)v15);
      v10 += v11;
      v9 -= v11;
      if (!v9) {
        goto LABEL_14;
      }
    }
    uint64_t result = (int)_libssh2_error(v7, 4294967290, "malloc fail for FXP_WRITE");
    time_t v4 = v34;
LABEL_43:
    if (result != -37) {
      return result;
    }
LABEL_44:
    uint64_t v32 = *(void *)(*(void *)a1[3] + 104);
    if (!*(_DWORD *)(v32 + 172)) {
      return -37;
    }
    LODWORD(result) = _libssh2_wait_socket(v32, v4);
    if (result) {
      return (int)result;
    }
  }
  v5[41] = 0;
  uint64_t v23 = _libssh2_list_first((uint64_t)v36);
  if (v23)
  {
    uint64_t v24 = v23;
    uint64_t v25 = 0;
    while (1)
    {
      if (*(void *)(v24 + 48) | v25) {
        goto LABEL_29;
      }
      LODWORD(result) = sftp_packet_require((uint64_t)v5, 101, *(_DWORD *)(v24 + 56), &v37, &v39, 9uLL);
      if (result == -38) {
        break;
      }
      if ((result & 0x80000000) != 0)
      {
        if (result == -37)
        {
          v5[41] = 3;
          goto LABEL_44;
        }
        goto LABEL_42;
      }
      int v26 = _libssh2_ntohu32((unsigned int *)(v37 + 5));
      (*(void (**)(uint64_t, uint64_t))(v7 + 24))(v37, v7);
      v5[16] = v26;
      if (v26)
      {
        sftp_packetlist_flush((uint64_t)a1);
        uint64_t v31 = a1[38] - a1[40];
        a1[38] = v31;
        a1[39] = v31;
        a1[40] = 0;
        uint64_t v29 = v7;
        unint64_t v30 = "FXP write failed";
        goto LABEL_41;
      }
      uint64_t v25 = *(void *)(v24 + 32);
      a1[38] += v25;
      uint64_t v27 = _libssh2_list_next(v24);
      _libssh2_list_remove((uint64_t *)v24);
      (*(void (**)(uint64_t, uint64_t))(v7 + 24))(v24, v7);
      uint64_t v24 = v27;
      if (!v27) {
        goto LABEL_29;
      }
    }
    if (v39) {
      (*(void (**)(uint64_t, uint64_t))(v7 + 24))(v37, v7);
    }
    uint64_t v29 = v7;
    unint64_t v30 = "FXP write packet too short";
LABEL_41:
    LODWORD(result) = _libssh2_error(v29, 4294967265, v30);
LABEL_42:
    uint64_t result = (int)result;
    goto LABEL_43;
  }
  uint64_t v25 = 0;
LABEL_29:
  unint64_t v28 = a1[40] + v25;
  if (v28)
  {
    if (v28 >= a3) {
      uint64_t result = a3;
    }
    else {
      uint64_t result = a1[40] + v25;
    }
    a1[40] = v28 - result;
    goto LABEL_43;
  }
  return 0;
}

uint64_t libssh2_sftp_fsync(void *a1)
{
  if (!a1) {
    return 4294967257;
  }
  time_t v2 = time(0);
  while (1)
  {
    uint64_t v3 = a1[3];
    uint64_t v4 = *(void *)v3;
    uint64_t v5 = *(void *)(*(void *)v3 + 104);
    int v6 = *((_DWORD *)a1 + 72);
    uint64_t v23 = 0;
    unint64_t v24 = 0;
    uint64_t v22 = 0;
    int v7 = *(_DWORD *)(v3 + 168);
    if (v7 == 2)
    {
      unint64_t v9 = *(const void **)(v3 + 176);
    }
    else
    {
      if (v7) {
        goto LABEL_15;
      }
      *(_DWORD *)(v3 + 64) = 0;
      unint64_t v8 = (_DWORD *)(*(uint64_t (**)(void, uint64_t))(v5 + 8))((v6 + 34), v5);
      uint64_t v23 = v8;
      if (!v8)
      {
        uint64_t v17 = v5;
        uint64_t v16 = 4294967290;
        uint64_t v18 = "Unable to allocate memory for FXP_EXTENDED packet";
        goto LABEL_26;
      }
      unint64_t v9 = v8;
      _libssh2_store_u32(&v23, v6 + 30);
      size_t v10 = v23;
      uint64_t v23 = (_DWORD *)((char *)v23 + 1);
      *size_t v10 = -56;
      unsigned int v11 = *(_DWORD *)(v3 + 8);
      *(_DWORD *)(v3 + 8) = v11 + 1;
      *(_DWORD *)(v3 + 184) = v11;
      _libssh2_store_u32(&v23, v11);
      _libssh2_store_str(&v23, "fsync@openssh.com", 0x11uLL);
      _libssh2_store_str(&v23, a1 + 4, a1[36]);
      *(_DWORD *)(v3 + 168) = 2;
    }
    unint64_t v12 = _libssh2_channel_write(v4, 0, v9, (v6 + 34));
    if (v12 == -37 || v12 < (v6 + 34))
    {
      *(void *)(v3 + 176) = v9;
      goto LABEL_27;
    }
    unint64_t v14 = v12;
    (*(void (**)(const void *, uint64_t))(v5 + 24))(v9, v5);
    *(void *)(v3 + 176) = 0;
    if ((v14 & 0x8000000000000000) != 0)
    {
      *(_DWORD *)(v3 + 168) = 0;
      uint64_t v17 = v5;
      uint64_t v16 = 4294967289;
      uint64_t v18 = "_libssh2_channel_write() failed";
      goto LABEL_26;
    }
    *(_DWORD *)(v3 + 168) = 3;
LABEL_15:
    uint64_t v15 = sftp_packet_require(v3, 101, *(_DWORD *)(v3 + 184), &v22, &v24, 9uLL);
    if (!v15) {
      break;
    }
    uint64_t v16 = v15;
    if (v15 == -37) {
      goto LABEL_27;
    }
    if (v15 == -38)
    {
      if (v24) {
        (*(void (**)(uint64_t, uint64_t))(v5 + 24))(v22, v5);
      }
      uint64_t v17 = v5;
      uint64_t v16 = 4294967265;
      uint64_t v18 = "SFTP fsync packet too short";
    }
    else
    {
      *(_DWORD *)(v3 + 168) = 0;
      uint64_t v17 = v5;
      uint64_t v18 = "Error waiting for FXP EXTENDED REPLY";
    }
LABEL_26:
    uint64_t result = _libssh2_error(v17, v16, v18);
    if (result != -37) {
      return result;
    }
LABEL_27:
    uint64_t v21 = *(void *)(*(void *)a1[3] + 104);
    if (!*(_DWORD *)(v21 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(v21, v2);
    if (result) {
      return result;
    }
  }
  *(_DWORD *)(v3 + 168) = 0;
  int v19 = _libssh2_ntohu32((unsigned int *)(v22 + 5));
  (*(void (**)(uint64_t, uint64_t))(v5 + 24))(v22, v5);
  if (v19)
  {
    *(_DWORD *)(v3 + 64) = v19;
    uint64_t v17 = v5;
    uint64_t v16 = 4294967265;
    uint64_t v18 = "fsync failed";
    goto LABEL_26;
  }
  return 0;
}

uint64_t libssh2_sftp_fstat_ex(void *a1, uint64_t *a2, int a3)
{
  uint64_t result = 4294967257;
  if (a1 && a2)
  {
    time_t v7 = time(0);
    if (a3) {
      char v8 = 10;
    }
    else {
      char v8 = 8;
    }
    char v31 = v8;
    unint64_t v9 = "Unable to send FXP_FSETSTAT";
    if (!a3) {
      unint64_t v9 = "Unable to send FXP_FSTAT command";
    }
    unint64_t v30 = (char *)v9;
    while (1)
    {
      uint64_t v10 = a1[3];
      uint64_t v11 = *(void *)v10;
      uint64_t v12 = *(void *)(*(void *)v10 + 104);
      unint64_t v34 = 0;
      uint64_t v13 = a3 ? (*a2 & 0xC) + 8 * (*a2 & 1) + ((4 * *a2) & 8) + 4 : 0;
      uint64_t v14 = a1[36] + 13 + v13;
      uint64_t v32 = 0;
      unint64_t v33 = 0;
      int v15 = *(_DWORD *)(v10 + 204);
      if (!v15) {
        break;
      }
      if (v15 == 2)
      {
        unint64_t v16 = v14;
LABEL_19:
        uint64_t v21 = _libssh2_channel_write(v11, 0, *(const void **)(v10 + 208), v16);
        if (v21 == -37) {
          goto LABEL_37;
        }
        uint64_t v22 = v21;
        (*(void (**)(void, uint64_t))(v12 + 24))(*(void *)(v10 + 208), v12);
        *(void *)(v10 + 208) = 0;
        if (v16 != v22)
        {
          *(_DWORD *)(v10 + 204) = 0;
          uint64_t v25 = v12;
          uint64_t v24 = 4294967289;
          int v26 = v30;
          goto LABEL_36;
        }
        *(_DWORD *)(v10 + 204) = 3;
      }
      uint64_t v23 = sftp_packet_requirev((void *)v10, (uint64_t)&sftp_fstat_fstat_responses, *(_DWORD *)(v10 + 216), &v32, &v34, 9uLL);
      if (v23)
      {
        uint64_t v24 = v23;
        if (v23 == -37) {
          goto LABEL_37;
        }
        if (v23 == -38)
        {
          if (v34) {
            (*(void (**)(uint64_t, uint64_t))(v12 + 24))(v32, v12);
          }
          uint64_t v25 = v12;
          uint64_t v24 = 4294967265;
          int v26 = "SFTP fstat packet too short";
        }
        else
        {
          *(_DWORD *)(v10 + 204) = 0;
          uint64_t v25 = v12;
          int v26 = "Timeout waiting for status message";
        }
      }
      else
      {
        *(_DWORD *)(v10 + 204) = 0;
        if (*(unsigned char *)v32 == 101)
        {
          int v27 = _libssh2_ntohu32((unsigned int *)(v32 + 5));
          (*(void (**)(uint64_t, uint64_t))(v12 + 24))(v32, v12);
          if (!v27) {
            return 0;
          }
          *(_DWORD *)(v10 + 64) = v27;
          uint64_t v25 = v12;
          uint64_t v24 = 4294967265;
          int v26 = "SFTP Protocol Error";
        }
        else
        {
          uint64_t v28 = sftp_bin2attr(a2, v32 + 5, v34 - 5);
          (*(void (**)(uint64_t, uint64_t))(v12 + 24))(v32, v12);
          if ((v28 & 0x8000000000000000) == 0) {
            return 0;
          }
          uint64_t v25 = v12;
          uint64_t v24 = 4294967265;
          int v26 = "Attributes too short in SFTP fstat";
        }
      }
LABEL_36:
      uint64_t result = _libssh2_error(v25, v24, v26);
      if (result != -37) {
        return result;
      }
LABEL_37:
      uint64_t v29 = *(void *)(*(void *)a1[3] + 104);
      if (!*(_DWORD *)(v29 + 172)) {
        return 4294967259;
      }
      uint64_t result = _libssh2_wait_socket(v29, v7);
      if (result) {
        return result;
      }
    }
    *(_DWORD *)(v10 + 64) = 0;
    unint64_t v16 = v14;
    uint64_t v17 = (_DWORD *)(*(uint64_t (**)(void, uint64_t))(v12 + 8))(v14, v12);
    *(void *)(v10 + 208) = v17;
    unint64_t v33 = v17;
    if (!v17)
    {
      uint64_t v25 = v12;
      uint64_t v24 = 4294967290;
      int v26 = "Unable to allocate memory for FSTAT/FSETSTAT packet";
      goto LABEL_36;
    }
    _libssh2_store_u32(&v33, v14 - 4);
    uint64_t v18 = (char *)v33;
    unint64_t v33 = (_DWORD *)((char *)v33 + 1);
    *uint64_t v18 = v31;
    unsigned int v19 = *(_DWORD *)(v10 + 8);
    *(_DWORD *)(v10 + 8) = v19 + 1;
    *(_DWORD *)(v10 + 216) = v19;
    _libssh2_store_u32(&v33, v19);
    _libssh2_store_str(&v33, a1 + 4, a1[36]);
    if (a3)
    {
      uint64_t v20 = sftp_attr2bin((char *)v33, a2);
      unint64_t v33 = (_DWORD *)((char *)v33 + v20);
    }
    *(_DWORD *)(v10 + 204) = 2;
    goto LABEL_19;
  }
  return result;
}

uint64_t libssh2_sftp_seek64(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v2 = result;
    if (*(void *)(result + 304) != a2 || *(void *)(result + 312) != a2)
    {
      *(void *)(result + 304) = a2;
      *(void *)(result + 312) = a2;
      uint64_t result = sftp_packetlist_flush(result);
      if (*(void *)(v2 + 344))
      {
        uint64_t result = (*(uint64_t (**)(void))(*(void *)(**(void **)(v2 + 24) + 104) + 24))(*(void *)(v2 + 328));
        *(void *)(v2 + 328) = 0;
        *(void *)(v2 + 336) = 0;
        *(void *)(v2 + 344) = 0;
      }
      *(unsigned char *)(v2 + 352) = 0;
    }
  }
  return result;
}

uint64_t sftp_packetlist_flush(uint64_t a1)
{
  uint64_t v1 = *(void ***)(a1 + 24);
  uint64_t v2 = (*v1)[13];
  uint64_t result = _libssh2_list_first(a1 + 376);
  if (result)
  {
    uint64_t v4 = result;
    do
    {
      uint64_t v10 = 0;
      uint64_t v5 = _libssh2_list_next(v4);
      if (sftp_packet_ask((uint64_t)v1, 101, *(_DWORD *)(v4 + 56), &v10, &v9)
        && sftp_packet_ask((uint64_t)v1, 103, *(_DWORD *)(v4 + 56), &v10, &v9))
      {
        if (*(void *)(v4 + 40))
        {
          int v6 = *(_DWORD *)(v4 + 56);
          uint64_t v7 = (*v1)[13];
          uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 8))(32, v7);
          if (v8)
          {
            *(_DWORD *)(v8 + 24) = v6;
            _libssh2_list_add(v1 + 4, (void *)v8);
          }
          else
          {
            _libssh2_error(v7, 4294967290, "malloc fail for zombie request  ID");
          }
        }
      }
      else
      {
        (*(void (**)(uint64_t, uint64_t))(v2 + 24))(v10, v2);
      }
      _libssh2_list_remove((uint64_t *)v4);
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 24))(v4, v2);
      uint64_t v4 = v5;
    }
    while (v5);
  }
  return result;
}

uint64_t libssh2_sftp_tell(uint64_t result)
{
  if (result) {
    return *(void *)(result + 304);
  }
  return result;
}

uint64_t libssh2_sftp_tell64(uint64_t result)
{
  if (result) {
    return *(void *)(result + 304);
  }
  return result;
}

uint64_t libssh2_sftp_close_handle(uint64_t a1)
{
  if (a1)
  {
    time_t v2 = time(0);
    while (1)
    {
      uint64_t v3 = *(_DWORD **)(a1 + 24);
      uint64_t v4 = *(void *)v3;
      uint64_t v5 = *(void *)(*(void *)v3 + 104);
      uint64_t v25 = 0;
      unint64_t v26 = 0;
      int v6 = *(_DWORD *)(a1 + 288);
      unint64_t v7 = (v6 + 13);
      uint64_t v24 = 0;
      int v8 = *(_DWORD *)(a1 + 360);
      if (v8)
      {
        uint64_t v9 = 0;
      }
      else
      {
        v3[16] = 0;
        uint64_t v10 = (_DWORD *)(*(uint64_t (**)(void, uint64_t))(v5 + 8))((v6 + 13), v5);
        *(void *)(a1 + 368) = v10;
        uint64_t v25 = v10;
        if (v10)
        {
          _libssh2_store_u32(&v25, v6 + 9);
          uint64_t v11 = v25;
          uint64_t v25 = (_DWORD *)((char *)v25 + 1);
          *uint64_t v11 = 4;
          unsigned int v12 = v3[2];
          v3[2] = v12 + 1;
          *(_DWORD *)(a1 + 364) = v12;
          _libssh2_store_u32(&v25, v12);
          _libssh2_store_str(&v25, (const void *)(a1 + 32), *(void *)(a1 + 288));
          uint64_t v9 = 0;
          *(_DWORD *)(a1 + 360) = 2;
LABEL_9:
          uint64_t v13 = _libssh2_channel_write(v4, 0, *(const void **)(a1 + 368), v7);
          if (v13 == -37) {
            goto LABEL_35;
          }
          if (v13 == v7)
          {
            *(_DWORD *)(a1 + 360) = 3;
          }
          else
          {
            *(_DWORD *)(a1 + 360) = 0;
            uint64_t v9 = _libssh2_error(v5, 4294967289, "Unable to send FXP_CLOSE command");
          }
          (*(void (**)(void, uint64_t))(v5 + 24))(*(void *)(a1 + 368), v5);
          *(void *)(a1 + 368) = 0;
          int v8 = *(_DWORD *)(a1 + 360);
          goto LABEL_14;
        }
        *(_DWORD *)(a1 + 360) = 0;
        uint64_t v9 = _libssh2_error(v5, 4294967290, "Unable to allocate memory for FXP_CLOSE packet");
        int v8 = *(_DWORD *)(a1 + 360);
      }
      if (v8 == 2) {
        goto LABEL_9;
      }
      if (v8 != 3) {
        goto LABEL_27;
      }
LABEL_14:
      uint64_t v14 = sftp_packet_require((uint64_t)v3, 101, *(_DWORD *)(a1 + 364), &v24, &v26, 9uLL);
      uint64_t v9 = v14;
      if (v14)
      {
        if (v14 == -37) {
          goto LABEL_35;
        }
        if (v14 == -38)
        {
          if (v26) {
            (*(void (**)(uint64_t, uint64_t))(v5 + 24))(v24, v5);
          }
          uint64_t v24 = 0;
          uint64_t v15 = v5;
          uint64_t v16 = 4294967265;
          uint64_t v17 = "Packet too short in FXP_CLOSE command";
        }
        else
        {
          uint64_t v15 = v5;
          uint64_t v16 = v9;
          uint64_t v17 = "Error waiting for status message";
        }
        _libssh2_error(v15, v16, v17);
      }
      *(_DWORD *)(a1 + 360) = 4;
      if (v24)
      {
        int v18 = _libssh2_ntohu32((unsigned int *)(v24 + 5));
        (*(void (**)(uint64_t, uint64_t))(v5 + 24))(v24, v5);
        if (v18)
        {
          v3[16] = v18;
          *(_DWORD *)(a1 + 360) = 0;
          uint64_t v9 = _libssh2_error(v5, 4294967265, "SFTP Protocol Error");
        }
      }
      else
      {
LABEL_27:
        if (!v9) {
          libssh2_sftp_close_handle_cold_1();
        }
      }
      _libssh2_list_remove((uint64_t *)a1);
      int v19 = *(_DWORD *)(a1 + 296);
      if (v19)
      {
        if (v19 == 1 && *(_DWORD *)(a1 + 304)) {
          (*(void (**)(void, uint64_t))(v5 + 24))(*(void *)(a1 + 312), v5);
        }
      }
      else
      {
        uint64_t v20 = *(void *)(a1 + 328);
        if (v20) {
          (*(void (**)(uint64_t, uint64_t))(v5 + 24))(v20, v5);
        }
      }
      sftp_packetlist_flush(a1);
      v3[39] = 0;
      *(_DWORD *)(a1 + 360) = 0;
      (*(void (**)(uint64_t, uint64_t))(v5 + 24))(a1, v5);
      if (v9 != -37) {
        return v9;
      }
LABEL_35:
      uint64_t v21 = *(void *)(**(void **)(a1 + 24) + 104);
      if (!*(_DWORD *)(v21 + 172)) {
        return 4294967259;
      }
      uint64_t v22 = _libssh2_wait_socket(v21, v2);
      if (v22) {
        return v22;
      }
    }
  }
  return 4294967257;
}

uint64_t libssh2_sftp_unlink_ex(uint64_t a1, const void *a2, unsigned int a3)
{
  if (!a1) {
    return 4294967257;
  }
  time_t v6 = time(0);
  unint64_t v7 = a3;
  unint64_t v8 = a3 + 13;
  unsigned int v9 = a3 + 9;
  while (1)
  {
    uint64_t v10 = *(void *)a1;
    uint64_t v11 = *(void *)(*(void *)a1 + 104);
    unint64_t v26 = 0;
    unint64_t v27 = 0;
    uint64_t v25 = 0;
    int v12 = *(_DWORD *)(a1 + 220);
    if (v12 != 2)
    {
      if (v12) {
        goto LABEL_10;
      }
      *(_DWORD *)(a1 + 64) = 0;
      uint64_t v13 = (_DWORD *)(*(uint64_t (**)(unint64_t, uint64_t))(v11 + 8))(v8, v11);
      *(void *)(a1 + 224) = v13;
      unint64_t v26 = v13;
      if (!v13)
      {
        uint64_t v20 = v11;
        uint64_t v19 = 4294967290;
        uint64_t v21 = "Unable to allocate memory for FXP_REMOVE packet";
        goto LABEL_21;
      }
      _libssh2_store_u32(&v26, v9);
      uint64_t v14 = v26;
      unint64_t v26 = (_DWORD *)((char *)v26 + 1);
      *uint64_t v14 = 13;
      unsigned int v15 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 8) = v15 + 1;
      *(_DWORD *)(a1 + 232) = v15;
      _libssh2_store_u32(&v26, v15);
      _libssh2_store_str(&v26, a2, v7);
      *(_DWORD *)(a1 + 220) = 2;
    }
    uint64_t v16 = _libssh2_channel_write(v10, 0, *(const void **)(a1 + 224), v8);
    if (v16 == -37) {
      goto LABEL_22;
    }
    uint64_t v17 = v16;
    (*(void (**)(void, uint64_t))(v11 + 24))(*(void *)(a1 + 224), v11);
    *(void *)(a1 + 224) = 0;
    if (v17 != v8)
    {
      *(_DWORD *)(a1 + 220) = 0;
      uint64_t v20 = v11;
      uint64_t v19 = 4294967289;
      uint64_t v21 = "Unable to send FXP_REMOVE command";
      goto LABEL_21;
    }
    *(_DWORD *)(a1 + 220) = 3;
LABEL_10:
    uint64_t v18 = sftp_packet_require(a1, 101, *(_DWORD *)(a1 + 232), &v25, &v27, 9uLL);
    if (!v18) {
      break;
    }
    uint64_t v19 = v18;
    if (v18 == -37) {
      goto LABEL_22;
    }
    if (v18 == -38)
    {
      if (v27) {
        (*(void (**)(uint64_t, uint64_t))(v11 + 24))(v25, v11);
      }
      uint64_t v20 = v11;
      uint64_t v19 = 4294967265;
      uint64_t v21 = "SFTP unlink packet too short";
    }
    else
    {
      *(_DWORD *)(a1 + 220) = 0;
      uint64_t v20 = v11;
      uint64_t v21 = "Error waiting for FXP STATUS";
    }
LABEL_21:
    uint64_t result = _libssh2_error(v20, v19, v21);
    if (result != -37) {
      return result;
    }
LABEL_22:
    uint64_t v24 = *(void *)(*(void *)a1 + 104);
    if (!*(_DWORD *)(v24 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(v24, v6);
    if (result) {
      return result;
    }
  }
  *(_DWORD *)(a1 + 220) = 0;
  int v22 = _libssh2_ntohu32((unsigned int *)(v25 + 5));
  (*(void (**)(uint64_t, uint64_t))(v11 + 24))(v25, v11);
  if (v22)
  {
    *(_DWORD *)(a1 + 64) = v22;
    uint64_t v20 = v11;
    uint64_t v19 = 4294967265;
    uint64_t v21 = "SFTP Protocol Error";
    goto LABEL_21;
  }
  return 0;
}

uint64_t libssh2_sftp_rename_ex(uint64_t a1, const void *a2, unsigned int a3, const void *a4, unsigned int a5, unsigned int a6)
{
  if (!a1) {
    return 4294967257;
  }
  time_t v11 = time(0);
  int v12 = a3 + a5 + 17;
  unint64_t v32 = a3;
  unint64_t v13 = a5;
  while (1)
  {
    uint64_t v14 = *(void *)a1;
    uint64_t v15 = *(void *)(*(void *)a1 + 104);
    uint64_t v33 = 0;
    unint64_t v34 = 0;
    unsigned int v16 = *(_DWORD *)(a1 + 12);
    uint64_t v17 = v12 + 4 * (v16 > 4);
    int v18 = *(_DWORD *)(a1 + 236);
    if (v18 != 2)
    {
      if (v18) {
        goto LABEL_14;
      }
      *(_DWORD *)(a1 + 64) = 0;
      if (v16 <= 1)
      {
        uint64_t v19 = v15;
        uint64_t v20 = 4294967265;
        uint64_t v21 = "Server does not support RENAME";
        goto LABEL_29;
      }
      uint64_t v22 = (*(uint64_t (**)(uint64_t, uint64_t))(v15 + 8))(v17, v15);
      *(void *)(a1 + 240) = v22;
      *(void *)(a1 + 248) = v22;
      if (!v22)
      {
        uint64_t v19 = v15;
        uint64_t v20 = 4294967290;
        uint64_t v21 = "Unable to allocate memory for FXP_RENAME packet";
        goto LABEL_29;
      }
      _libssh2_store_u32((_DWORD **)(a1 + 248), v17 - 4);
      uint64_t v23 = *(unsigned char **)(a1 + 248);
      *(void *)(a1 + 248) = v23 + 1;
      *uint64_t v23 = 18;
      unsigned int v24 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 8) = v24 + 1;
      *(_DWORD *)(a1 + 256) = v24;
      _libssh2_store_u32((_DWORD **)(a1 + 248), v24);
      _libssh2_store_str((_DWORD **)(a1 + 248), a2, v32);
      _libssh2_store_str((_DWORD **)(a1 + 248), a4, v13);
      if (*(_DWORD *)(a1 + 12) >= 5u) {
        _libssh2_store_u32((_DWORD **)(a1 + 248), a6);
      }
      *(_DWORD *)(a1 + 236) = 2;
    }
    uint64_t v25 = _libssh2_channel_write(v14, 0, *(const void **)(a1 + 240), *(void *)(a1 + 248) - *(void *)(a1 + 240));
    if (v25 == -37) {
      goto LABEL_30;
    }
    uint64_t v26 = v25;
    (*(void (**)(void, uint64_t))(v15 + 24))(*(void *)(a1 + 240), v15);
    *(void *)(a1 + 240) = 0;
    if (v26 != v17)
    {
      *(_DWORD *)(a1 + 236) = 0;
      uint64_t v19 = v15;
      uint64_t v20 = 4294967289;
      uint64_t v21 = "Unable to send FXP_RENAME command";
      goto LABEL_29;
    }
    *(_DWORD *)(a1 + 236) = 3;
LABEL_14:
    uint64_t v27 = sftp_packet_require(a1, 101, *(_DWORD *)(a1 + 256), &v33, &v34, 9uLL);
    if (!v27) {
      break;
    }
    uint64_t v20 = v27;
    if (v27 == -37) {
      goto LABEL_30;
    }
    if (v27 == -38)
    {
      if (v34) {
        (*(void (**)(uint64_t, uint64_t))(v15 + 24))(v33, v15);
      }
      uint64_t v19 = v15;
      uint64_t v20 = 4294967265;
      uint64_t v21 = "SFTP rename packet too short";
    }
    else
    {
      *(_DWORD *)(a1 + 236) = 0;
      uint64_t v19 = v15;
      uint64_t v21 = "Error waiting for FXP STATUS";
    }
LABEL_29:
    uint64_t result = _libssh2_error(v19, v20, v21);
    if (result != -37) {
      return result;
    }
LABEL_30:
    uint64_t v30 = *(void *)(*(void *)a1 + 104);
    if (!*(_DWORD *)(v30 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(v30, v11);
    if (result) {
      return result;
    }
  }
  *(_DWORD *)(a1 + 236) = 0;
  int v28 = _libssh2_ntohu32((unsigned int *)(v33 + 5));
  (*(void (**)(uint64_t, uint64_t))(v15 + 24))(v33, v15);
  *(_DWORD *)(a1 + 64) = v28;
  if (v28 == 8)
  {
    uint64_t v19 = v15;
    uint64_t v20 = 4294967265;
    uint64_t v21 = "Operation Not Supported";
    goto LABEL_29;
  }
  if (v28 == 11)
  {
    uint64_t v19 = v15;
    uint64_t v20 = 4294967265;
    uint64_t v21 = "File already exists and SSH_FXP_RENAME_OVERWRITE not specified";
    goto LABEL_29;
  }
  if (v28)
  {
    uint64_t v19 = v15;
    uint64_t v20 = 4294967265;
    uint64_t v21 = "SFTP Protocol Error";
    goto LABEL_29;
  }
  return 0;
}

uint64_t libssh2_sftp_fstatvfs(void *a1, unint64_t *a2)
{
  uint64_t result = 4294967257;
  if (a1 && a2)
  {
    time_t v4 = time(0);
    do
    {
      uint64_t v5 = a1[3];
      uint64_t v6 = *(void *)v5;
      uint64_t v7 = *(void *)(*(void *)v5 + 104);
      uint64_t v30 = 0;
      unint64_t v31 = 0;
      int v8 = *((_DWORD *)a1 + 72);
      uint64_t v29 = 0;
      int v9 = *(_DWORD *)(v5 + 260);
      if (v9 == 2)
      {
        time_t v11 = *(const void **)(v5 + 264);
      }
      else
      {
        if (v9) {
          goto LABEL_16;
        }
        *(_DWORD *)(v5 + 64) = 0;
        uint64_t v10 = (_DWORD *)(*(uint64_t (**)(void, uint64_t))(v7 + 8))((v8 + 37), v7);
        uint64_t v30 = v10;
        if (!v10)
        {
          uint64_t v19 = v7;
          uint64_t v18 = 4294967290;
          uint64_t v20 = "Unable to allocate memory for FXP_EXTENDED packet";
          goto LABEL_29;
        }
        time_t v11 = v10;
        _libssh2_store_u32(&v30, v8 + 33);
        int v12 = v30;
        uint64_t v30 = (_DWORD *)((char *)v30 + 1);
        *int v12 = -56;
        unsigned int v13 = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(v5 + 8) = v13 + 1;
        *(_DWORD *)(v5 + 272) = v13;
        _libssh2_store_u32(&v30, v13);
        _libssh2_store_str(&v30, "fstatvfs@openssh.com", 0x14uLL);
        _libssh2_store_str(&v30, a1 + 4, a1[36]);
        *(_DWORD *)(v5 + 260) = 2;
      }
      unint64_t v14 = _libssh2_channel_write(v6, 0, v11, (v8 + 37));
      if (v14 == -37 || v14 < (v8 + 37))
      {
        *(void *)(v5 + 264) = v11;
        goto LABEL_30;
      }
      unint64_t v16 = v14;
      (*(void (**)(const void *, uint64_t))(v7 + 24))(v11, v7);
      *(void *)(v5 + 264) = 0;
      if ((v16 & 0x8000000000000000) != 0)
      {
        *(_DWORD *)(v5 + 260) = 0;
        uint64_t v19 = v7;
        uint64_t v18 = 4294967289;
        uint64_t v20 = "_libssh2_channel_write() failed";
        goto LABEL_29;
      }
      *(_DWORD *)(v5 + 260) = 3;
LABEL_16:
      uint64_t v17 = sftp_packet_requirev((void *)v5, (uint64_t)&sftp_fstatvfs_responses, *(_DWORD *)(v5 + 272), &v29, &v31, 9uLL);
      if (v17)
      {
        uint64_t v18 = v17;
        if (v17 == -37) {
          goto LABEL_30;
        }
        if (v17 == -38)
        {
          if (v31) {
            (*(void (**)(uint64_t, uint64_t))(v7 + 24))(v29, v7);
          }
          uint64_t v19 = v7;
          uint64_t v18 = 4294967265;
          uint64_t v20 = "SFTP rename packet too short";
        }
        else
        {
          *(_DWORD *)(v5 + 260) = 0;
          uint64_t v19 = v7;
          uint64_t v20 = "Error waiting for FXP EXTENDED REPLY";
        }
      }
      else
      {
        uint64_t v21 = v29;
        if (*(unsigned char *)v29 == 101)
        {
          int v22 = _libssh2_ntohu32((unsigned int *)(v29 + 5));
          *(_DWORD *)(v5 + 260) = 0;
          (*(void (**)(uint64_t, uint64_t))(v7 + 24))(v29, v7);
          *(_DWORD *)(v5 + 64) = v22;
          uint64_t v19 = v7;
          uint64_t v18 = 4294967265;
          uint64_t v20 = "SFTP Protocol Error";
        }
        else
        {
          if (v31 > 0x5C)
          {
            *(_DWORD *)(v5 + 260) = 0;
            unint64_t v24 = _libssh2_ntohu64((unint64_t *)(v21 + 5));
            uint64_t v25 = v29;
            *a2 = v24;
            a2[1] = _libssh2_ntohu64((unint64_t *)(v25 + 13));
            a2[2] = _libssh2_ntohu64((unint64_t *)(v29 + 21));
            a2[3] = _libssh2_ntohu64((unint64_t *)(v29 + 29));
            a2[4] = _libssh2_ntohu64((unint64_t *)(v29 + 37));
            a2[5] = _libssh2_ntohu64((unint64_t *)(v29 + 45));
            a2[6] = _libssh2_ntohu64((unint64_t *)(v29 + 53));
            a2[7] = _libssh2_ntohu64((unint64_t *)(v29 + 61));
            a2[8] = _libssh2_ntohu64((unint64_t *)(v29 + 69));
            char v26 = _libssh2_ntohu64((unint64_t *)(v29 + 77));
            unint64_t v27 = _libssh2_ntohu64((unint64_t *)(v29 + 85));
            a2[9] = v26 & 3;
            a2[10] = v27;
            (*(void (**)(uint64_t, uint64_t))(v7 + 24))(v29, v7);
            return 0;
          }
          (*(void (**)(void))(v7 + 24))();
          *(_DWORD *)(v5 + 260) = 0;
          uint64_t v19 = v7;
          uint64_t v18 = 4294967265;
          uint64_t v20 = "SFTP Protocol Error: short response";
        }
      }
LABEL_29:
      uint64_t result = _libssh2_error(v19, v18, v20);
      if (result != -37) {
        return result;
      }
LABEL_30:
      uint64_t v23 = *(void *)(*(void *)a1[3] + 104);
      if (!*(_DWORD *)(v23 + 172)) {
        return 4294967259;
      }
      uint64_t result = _libssh2_wait_socket(v23, v4);
    }
    while (!result);
  }
  return result;
}

uint64_t libssh2_sftp_statvfs(uint64_t a1, const void *a2, unsigned int a3, unint64_t *a4)
{
  uint64_t result = 4294967257;
  if (a1 && a4)
  {
    time_t v8 = time(0);
    unint64_t v9 = a3 + 36;
    unsigned int v10 = a3 + 32;
    unint64_t v11 = a3;
    do
    {
      uint64_t v12 = *(void *)a1;
      uint64_t v13 = *(void *)(*(void *)a1 + 104);
      int v35 = 0;
      unint64_t v36 = 0;
      uint64_t v34 = 0;
      int v14 = *(_DWORD *)(a1 + 276);
      if (v14 == 2)
      {
        unint64_t v16 = *(const void **)(a1 + 280);
      }
      else
      {
        if (v14) {
          goto LABEL_16;
        }
        *(_DWORD *)(a1 + 64) = 0;
        uint64_t v15 = (_DWORD *)(*(uint64_t (**)(unint64_t, uint64_t))(v13 + 8))(v9, v13);
        int v35 = v15;
        if (!v15)
        {
          uint64_t v24 = v13;
          uint64_t v23 = 4294967290;
          uint64_t v25 = "Unable to allocate memory for FXP_EXTENDED packet";
          goto LABEL_29;
        }
        unint64_t v16 = v15;
        _libssh2_store_u32(&v35, v10);
        uint64_t v17 = v35;
        int v35 = (_DWORD *)((char *)v35 + 1);
        *uint64_t v17 = -56;
        unsigned int v18 = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 8) = v18 + 1;
        *(_DWORD *)(a1 + 288) = v18;
        _libssh2_store_u32(&v35, v18);
        _libssh2_store_str(&v35, "statvfs@openssh.com", 0x13uLL);
        _libssh2_store_str(&v35, a2, v11);
        *(_DWORD *)(a1 + 276) = 2;
      }
      unint64_t v19 = _libssh2_channel_write(v12, 0, v16, v9);
      if (v19 == -37 || v19 < v9)
      {
        *(void *)(a1 + 280) = v16;
        goto LABEL_30;
      }
      unint64_t v21 = v19;
      (*(void (**)(const void *, uint64_t))(v13 + 24))(v16, v13);
      *(void *)(a1 + 280) = 0;
      if ((v21 & 0x8000000000000000) != 0)
      {
        *(_DWORD *)(a1 + 276) = 0;
        uint64_t v24 = v13;
        uint64_t v23 = 4294967289;
        uint64_t v25 = "_libssh2_channel_write() failed";
        goto LABEL_29;
      }
      *(_DWORD *)(a1 + 276) = 3;
LABEL_16:
      uint64_t v22 = sftp_packet_requirev((void *)a1, (uint64_t)&sftp_statvfs_responses, *(_DWORD *)(a1 + 288), &v34, &v36, 9uLL);
      if (v22)
      {
        uint64_t v23 = v22;
        if (v22 == -37) {
          goto LABEL_30;
        }
        if (v22 == -38)
        {
          if (v36) {
            (*(void (**)(uint64_t, uint64_t))(v13 + 24))(v34, v13);
          }
          uint64_t v24 = v13;
          uint64_t v23 = 4294967265;
          uint64_t v25 = "SFTP fstat packet too short";
        }
        else
        {
          *(_DWORD *)(a1 + 276) = 0;
          uint64_t v24 = v13;
          uint64_t v25 = "Error waiting for FXP EXTENDED REPLY";
        }
      }
      else
      {
        uint64_t v26 = v34;
        if (*(unsigned char *)v34 == 101)
        {
          int v27 = _libssh2_ntohu32((unsigned int *)(v34 + 5));
          *(_DWORD *)(a1 + 276) = 0;
          (*(void (**)(uint64_t, uint64_t))(v13 + 24))(v34, v13);
          *(_DWORD *)(a1 + 64) = v27;
          uint64_t v24 = v13;
          uint64_t v23 = 4294967265;
          uint64_t v25 = "SFTP Protocol Error";
        }
        else
        {
          if (v36 > 0x5C)
          {
            *(_DWORD *)(a1 + 276) = 0;
            unint64_t v29 = _libssh2_ntohu64((unint64_t *)(v26 + 5));
            uint64_t v30 = v34;
            *a4 = v29;
            a4[1] = _libssh2_ntohu64((unint64_t *)(v30 + 13));
            a4[2] = _libssh2_ntohu64((unint64_t *)(v34 + 21));
            a4[3] = _libssh2_ntohu64((unint64_t *)(v34 + 29));
            a4[4] = _libssh2_ntohu64((unint64_t *)(v34 + 37));
            a4[5] = _libssh2_ntohu64((unint64_t *)(v34 + 45));
            a4[6] = _libssh2_ntohu64((unint64_t *)(v34 + 53));
            a4[7] = _libssh2_ntohu64((unint64_t *)(v34 + 61));
            a4[8] = _libssh2_ntohu64((unint64_t *)(v34 + 69));
            char v31 = _libssh2_ntohu64((unint64_t *)(v34 + 77));
            unint64_t v32 = _libssh2_ntohu64((unint64_t *)(v34 + 85));
            a4[9] = v31 & 3;
            a4[10] = v32;
            (*(void (**)(uint64_t, uint64_t))(v13 + 24))(v34, v13);
            return 0;
          }
          (*(void (**)(void))(v13 + 24))();
          *(_DWORD *)(a1 + 276) = 0;
          uint64_t v24 = v13;
          uint64_t v23 = 4294967265;
          uint64_t v25 = "SFTP Protocol Error: short response";
        }
      }
LABEL_29:
      uint64_t result = _libssh2_error(v24, v23, v25);
      if (result != -37) {
        return result;
      }
LABEL_30:
      uint64_t v28 = *(void *)(*(void *)a1 + 104);
      if (!*(_DWORD *)(v28 + 172)) {
        return 4294967259;
      }
      uint64_t result = _libssh2_wait_socket(v28, v8);
    }
    while (!result);
  }
  return result;
}

uint64_t libssh2_sftp_mkdir_ex(uint64_t a1, const void *a2, unsigned int a3, uint64_t a4)
{
  if (!a1) {
    return 4294967257;
  }
  time_t v7 = time(0);
  while (1)
  {
    uint64_t v8 = *(void *)a1;
    uint64_t v9 = *(void *)(*(void *)a1 + 104);
    uint64_t v33 = 0;
    long long v32 = 0u;
    memset(v31, 0, sizeof(v31));
    unint64_t v30 = 0;
    uint64_t v28 = 0;
    if (a4 == -1)
    {
      int v10 = 0;
    }
    else
    {
      int v10 = 4;
      *(void *)&v31[0] = 4;
      *(void *)&long long v32 = a4 | 0x4000;
    }
    unint64_t v29 = 0;
    unint64_t v11 = a3 + 17 + v10;
    int v12 = *(_DWORD *)(a1 + 292);
    if (v12)
    {
      if (v12 != 2) {
        goto LABEL_15;
      }
      uint64_t v13 = *(const void **)(a1 + 296);
    }
    else
    {
      *(_DWORD *)(a1 + 64) = 0;
      int v14 = (_DWORD *)(*(uint64_t (**)(unint64_t, uint64_t))(v9 + 8))(v11, v9);
      unint64_t v29 = v14;
      if (!v14)
      {
        uint64_t v22 = v9;
        uint64_t v21 = 4294967290;
        uint64_t v23 = "Unable to allocate memory for FXP_MKDIR packet";
        goto LABEL_26;
      }
      uint64_t v13 = v14;
      _libssh2_store_u32(&v29, v11 - 4);
      uint64_t v15 = v29;
      unint64_t v29 = (_DWORD *)((char *)v29 + 1);
      *uint64_t v15 = 14;
      unsigned int v16 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 8) = v16 + 1;
      *(_DWORD *)(a1 + 304) = v16;
      _libssh2_store_u32(&v29, v16);
      _libssh2_store_str(&v29, a2, a3);
      uint64_t v17 = sftp_attr2bin((char *)v29, (uint64_t *)v31);
      unint64_t v29 = (_DWORD *)((char *)v29 + v17);
      *(_DWORD *)(a1 + 292) = 2;
    }
    uint64_t v18 = _libssh2_channel_write(v8, 0, v13, v11);
    if (v18 == -37)
    {
      *(void *)(a1 + 296) = v13;
      goto LABEL_27;
    }
    uint64_t v19 = v18;
    (*(void (**)(const void *, uint64_t))(v9 + 24))(v13, v9);
    if (v19 != v11)
    {
      *(_DWORD *)(a1 + 292) = 0;
      uint64_t v22 = v9;
      uint64_t v21 = 4294967289;
      uint64_t v23 = "_libssh2_channel_write() failed";
      goto LABEL_26;
    }
    *(_DWORD *)(a1 + 292) = 3;
    *(void *)(a1 + 296) = 0;
LABEL_15:
    uint64_t v20 = sftp_packet_require(a1, 101, *(_DWORD *)(a1 + 304), &v28, &v30, 9uLL);
    if (!v20) {
      break;
    }
    uint64_t v21 = v20;
    if (v20 == -37) {
      goto LABEL_27;
    }
    if (v20 == -38)
    {
      if (v30) {
        (*(void (**)(uint64_t, uint64_t))(v9 + 24))(v28, v9);
      }
      uint64_t v22 = v9;
      uint64_t v21 = 4294967265;
      uint64_t v23 = "SFTP mkdir packet too short";
    }
    else
    {
      *(_DWORD *)(a1 + 292) = 0;
      uint64_t v22 = v9;
      uint64_t v23 = "Error waiting for FXP STATUS";
    }
LABEL_26:
    uint64_t result = _libssh2_error(v22, v21, v23);
    if (result != -37) {
      return result;
    }
LABEL_27:
    uint64_t v26 = *(void *)(*(void *)a1 + 104);
    if (!*(_DWORD *)(v26 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(v26, v7);
    if (result) {
      return result;
    }
  }
  *(_DWORD *)(a1 + 292) = 0;
  int v24 = _libssh2_ntohu32((unsigned int *)(v28 + 5));
  (*(void (**)(uint64_t, uint64_t))(v9 + 24))(v28, v9);
  if (v24)
  {
    *(_DWORD *)(a1 + 64) = v24;
    uint64_t v22 = v9;
    uint64_t v21 = 4294967265;
    uint64_t v23 = "SFTP Protocol Error";
    goto LABEL_26;
  }
  return 0;
}

uint64_t libssh2_sftp_rmdir_ex(uint64_t a1, const void *a2, unsigned int a3)
{
  if (!a1) {
    return 4294967257;
  }
  time_t v6 = time(0);
  while (1)
  {
    uint64_t v7 = *(void *)a1;
    uint64_t v8 = *(void *)(*(void *)a1 + 104);
    uint64_t v23 = 0;
    unint64_t v24 = 0;
    uint64_t v22 = 0;
    int v9 = *(_DWORD *)(a1 + 308);
    if (v9 != 2)
    {
      if (v9) {
        goto LABEL_10;
      }
      *(_DWORD *)(a1 + 64) = 0;
      int v10 = (_DWORD *)(*(uint64_t (**)(void, uint64_t))(v8 + 8))(a3 + 13, v8);
      *(void *)(a1 + 312) = v10;
      uint64_t v23 = v10;
      if (!v10)
      {
        uint64_t v17 = v8;
        uint64_t v16 = 4294967290;
        uint64_t v18 = "Unable to allocate memory for FXP_RMDIR packet";
        goto LABEL_21;
      }
      _libssh2_store_u32(&v23, a3 + 9);
      unint64_t v11 = v23;
      uint64_t v23 = (_DWORD *)((char *)v23 + 1);
      *unint64_t v11 = 15;
      unsigned int v12 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 8) = v12 + 1;
      *(_DWORD *)(a1 + 320) = v12;
      _libssh2_store_u32(&v23, v12);
      _libssh2_store_str(&v23, a2, a3);
      *(_DWORD *)(a1 + 308) = 2;
    }
    uint64_t v13 = _libssh2_channel_write(v7, 0, *(const void **)(a1 + 312), a3 + 13);
    if (v13 == -37) {
      goto LABEL_22;
    }
    uint64_t v14 = v13;
    (*(void (**)(void, uint64_t))(v8 + 24))(*(void *)(a1 + 312), v8);
    *(void *)(a1 + 312) = 0;
    if (v14 != a3 + 13)
    {
      *(_DWORD *)(a1 + 308) = 0;
      uint64_t v17 = v8;
      uint64_t v16 = 4294967289;
      uint64_t v18 = "Unable to send FXP_RMDIR command";
      goto LABEL_21;
    }
    *(_DWORD *)(a1 + 308) = 3;
LABEL_10:
    uint64_t v15 = sftp_packet_require(a1, 101, *(_DWORD *)(a1 + 320), &v22, &v24, 9uLL);
    if (!v15) {
      break;
    }
    uint64_t v16 = v15;
    if (v15 == -37) {
      goto LABEL_22;
    }
    if (v15 == -38)
    {
      if (v24) {
        (*(void (**)(uint64_t, uint64_t))(v8 + 24))(v22, v8);
      }
      uint64_t v17 = v8;
      uint64_t v16 = 4294967265;
      uint64_t v18 = "SFTP rmdir packet too short";
    }
    else
    {
      *(_DWORD *)(a1 + 308) = 0;
      uint64_t v17 = v8;
      uint64_t v18 = "Error waiting for FXP STATUS";
    }
LABEL_21:
    uint64_t result = _libssh2_error(v17, v16, v18);
    if (result != -37) {
      return result;
    }
LABEL_22:
    uint64_t v21 = *(void *)(*(void *)a1 + 104);
    if (!*(_DWORD *)(v21 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(v21, v6);
    if (result) {
      return result;
    }
  }
  *(_DWORD *)(a1 + 308) = 0;
  int v19 = _libssh2_ntohu32((unsigned int *)(v22 + 5));
  (*(void (**)(uint64_t, uint64_t))(v8 + 24))(v22, v8);
  if (v19)
  {
    *(_DWORD *)(a1 + 64) = v19;
    uint64_t v17 = v8;
    uint64_t v16 = 4294967265;
    uint64_t v18 = "SFTP Protocol Error";
    goto LABEL_21;
  }
  return 0;
}

uint64_t libssh2_sftp_stat_ex(uint64_t a1, const void *a2, unsigned int a3, int a4, uint64_t a5)
{
  if (!a1) {
    return 4294967257;
  }
  time_t v10 = time(0);
  while (1)
  {
    uint64_t v11 = *(void *)a1;
    uint64_t v12 = *(void *)(*(void *)a1 + 104);
    unint64_t v35 = 0;
    if (a4 == 2) {
      int v13 = (*(_DWORD *)a5 & 0xC) + 8 * (*(_DWORD *)a5 & 1) + ((4 * *(_DWORD *)a5) & 8) + 4;
    }
    else {
      int v13 = 0;
    }
    unint64_t v14 = a3 + 13 + v13;
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    int v15 = *(_DWORD *)(a1 + 324);
    if (v15 != 2)
    {
      if (v15) {
        goto LABEL_22;
      }
      *(_DWORD *)(a1 + 64) = 0;
      uint64_t v16 = (_DWORD *)(*(uint64_t (**)(unint64_t, uint64_t))(v12 + 8))(v14, v12);
      *(void *)(a1 + 328) = v16;
      uint64_t v34 = v16;
      if (!v16)
      {
        uint64_t v18 = v12;
        uint64_t v19 = 4294967290;
        uint64_t v20 = "Unable to allocate memory for FXP_*STAT packet";
        goto LABEL_35;
      }
      _libssh2_store_u32(&v34, v14 - 4);
      if (a4 == 1)
      {
        uint64_t v21 = (char *)v34;
        uint64_t v34 = (_DWORD *)((char *)v34 + 1);
        char v22 = 7;
      }
      else
      {
        if (a4 == 2)
        {
          uint64_t v17 = v34;
          uint64_t v34 = (_DWORD *)((char *)v34 + 1);
          *uint64_t v17 = 9;
LABEL_16:
          unsigned int v23 = *(_DWORD *)(a1 + 8);
          *(_DWORD *)(a1 + 8) = v23 + 1;
          *(_DWORD *)(a1 + 336) = v23;
          _libssh2_store_u32(&v34, v23);
          _libssh2_store_str(&v34, a2, a3);
          if (a4 == 2)
          {
            uint64_t v24 = sftp_attr2bin((char *)v34, (uint64_t *)a5);
            uint64_t v34 = (_DWORD *)((char *)v34 + v24);
          }
          *(_DWORD *)(a1 + 324) = 2;
          goto LABEL_19;
        }
        uint64_t v21 = (char *)v34;
        uint64_t v34 = (_DWORD *)((char *)v34 + 1);
        char v22 = 17;
      }
      *uint64_t v21 = v22;
      goto LABEL_16;
    }
LABEL_19:
    uint64_t v25 = _libssh2_channel_write(v11, 0, *(const void **)(a1 + 328), v14);
    if (v25 == -37) {
      goto LABEL_36;
    }
    uint64_t v26 = v25;
    (*(void (**)(void, uint64_t))(v12 + 24))(*(void *)(a1 + 328), v12);
    *(void *)(a1 + 328) = 0;
    if (v26 != v14)
    {
      *(_DWORD *)(a1 + 324) = 0;
      uint64_t v18 = v12;
      uint64_t v19 = 4294967289;
      uint64_t v20 = "Unable to send STAT/LSTAT/SETSTAT command";
      goto LABEL_35;
    }
    *(_DWORD *)(a1 + 324) = 3;
LABEL_22:
    uint64_t v27 = sftp_packet_requirev((void *)a1, (uint64_t)&sftp_stat_stat_responses, *(_DWORD *)(a1 + 336), &v33, &v35, 9uLL);
    if (!v27) {
      break;
    }
    uint64_t v19 = v27;
    if (v27 == -37) {
      goto LABEL_36;
    }
    if (v27 == -38)
    {
      if (v35) {
        (*(void (**)(uint64_t, uint64_t))(v12 + 24))(v33, v12);
      }
      uint64_t v18 = v12;
      uint64_t v19 = 4294967265;
      uint64_t v20 = "SFTP stat packet too short";
    }
    else
    {
      *(_DWORD *)(a1 + 324) = 0;
      uint64_t v18 = v12;
      uint64_t v20 = "Timeout waiting for status message";
    }
LABEL_35:
    uint64_t result = _libssh2_error(v18, v19, v20);
    if (result != -37) {
      return result;
    }
LABEL_36:
    uint64_t v32 = *(void *)(*(void *)a1 + 104);
    if (!*(_DWORD *)(v32 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(v32, v10);
    if (result) {
      return result;
    }
  }
  *(_DWORD *)(a1 + 324) = 0;
  uint64_t v28 = v33;
  if (*(unsigned char *)v33 != 101)
  {
    *(void *)(a5 + 48) = 0;
    *(_OWORD *)(a5 + 16) = 0u;
    *(_OWORD *)(a5 + 32) = 0u;
    *(_OWORD *)a5 = 0u;
    uint64_t v30 = sftp_bin2attr((void *)a5, v28 + 5, v35 - 5);
    (*(void (**)(uint64_t, uint64_t))(v12 + 24))(v33, v12);
    if ((v30 & 0x8000000000000000) == 0) {
      return 0;
    }
    uint64_t v18 = v12;
    uint64_t v19 = 4294967265;
    uint64_t v20 = "Attributes too short in SFTP fstat";
    goto LABEL_35;
  }
  int v29 = _libssh2_ntohu32((unsigned int *)(v33 + 5));
  (*(void (**)(uint64_t, uint64_t))(v12 + 24))(v33, v12);
  if (v29)
  {
    *(_DWORD *)(a1 + 64) = v29;
    uint64_t v18 = v12;
    uint64_t v19 = 4294967265;
    uint64_t v20 = "SFTP Protocol Error";
    goto LABEL_35;
  }
  *(void *)(a5 + 48) = 0;
  *(_OWORD *)(a5 + 16) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)a5 = 0u;
  return 0;
}

uint64_t libssh2_sftp_symlink_ex(uint64_t a1, const void *a2, unsigned int a3, void *a4, unsigned int a5, int a6)
{
  if (a1)
  {
    time_t v11 = time(0);
    unsigned int v12 = a5 + 4;
    if (a6) {
      unsigned int v12 = 0;
    }
    unsigned int v13 = a3 + v12;
    unint64_t v14 = v13 + 13;
    unsigned int v38 = v13 + 9;
    unint64_t v37 = a3;
    while (1)
    {
      uint64_t v15 = *(void *)a1;
      uint64_t v16 = *(void *)(*(void *)a1 + 104);
      uint64_t v40 = 0;
      unint64_t v41 = 0;
      unint64_t v39 = 0;
      int v17 = *(_DWORD *)(a1 + 340);
      if (v17 != 2)
      {
        if (v17) {
          goto LABEL_23;
        }
        *(_DWORD *)(a1 + 64) = 0;
        if (a6 != 2 && *(_DWORD *)(a1 + 12) <= 2u)
        {
          uint64_t v18 = v16;
          uint64_t v19 = 4294967265;
          uint64_t v20 = "Server does not support SYMLINK or READLINK";
LABEL_34:
          uint64_t v30 = _libssh2_error(v18, v19, v20);
          goto LABEL_35;
        }
        uint64_t v21 = (_DWORD *)(*(uint64_t (**)(unint64_t, uint64_t))(v16 + 8))(v14, v16);
        *(void *)(a1 + 344) = v21;
        uint64_t v40 = v21;
        if (!v21)
        {
          uint64_t v18 = v16;
          uint64_t v19 = 4294967290;
          uint64_t v20 = "Unable to allocate memory for SYMLINK/READLINK/REALPATH packet";
          goto LABEL_34;
        }
        _libssh2_store_u32(&v40, v38);
        if (a6)
        {
          char v22 = (char *)v40;
          uint64_t v40 = (_DWORD *)((char *)v40 + 1);
          if (a6 == 2) {
            char v23 = 16;
          }
          else {
            char v23 = 19;
          }
        }
        else
        {
          char v22 = (char *)v40;
          uint64_t v40 = (_DWORD *)((char *)v40 + 1);
          char v23 = 20;
        }
        char *v22 = v23;
        unsigned int v24 = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 8) = v24 + 1;
        *(_DWORD *)(a1 + 352) = v24;
        _libssh2_store_u32(&v40, v24);
        _libssh2_store_str(&v40, a2, v37);
        if (!a6) {
          _libssh2_store_str(&v40, a4, a5);
        }
        *(_DWORD *)(a1 + 340) = 2;
      }
      uint64_t v25 = _libssh2_channel_write(v15, 0, *(const void **)(a1 + 344), v14);
      if (v25 == -37) {
        goto LABEL_36;
      }
      uint64_t v26 = v25;
      (*(void (**)(void, uint64_t))(v16 + 24))(*(void *)(a1 + 344), v16);
      *(void *)(a1 + 344) = 0;
      if (v26 != v14)
      {
        *(_DWORD *)(a1 + 340) = 0;
        uint64_t v18 = v16;
        uint64_t v19 = 4294967289;
        uint64_t v20 = "Unable to send SYMLINK/READLINK command";
        goto LABEL_34;
      }
      *(_DWORD *)(a1 + 340) = 3;
LABEL_23:
      uint64_t v27 = sftp_packet_requirev((void *)a1, (uint64_t)&sftp_symlink_link_responses, *(_DWORD *)(a1 + 352), &v39, &v41, 9uLL);
      if (v27)
      {
        uint64_t v19 = v27;
        if (v27 == -37) {
          goto LABEL_36;
        }
        if (v27 == -38)
        {
          if (v41) {
            (*(void (**)(unsigned __int8 *, uint64_t))(v16 + 24))(v39, v16);
          }
          uint64_t v18 = v16;
          uint64_t v19 = 4294967265;
          uint64_t v20 = "SFTP symlink packet too short";
        }
        else
        {
          *(_DWORD *)(a1 + 340) = 0;
          uint64_t v18 = v16;
          uint64_t v20 = "Error waiting for status message";
        }
        goto LABEL_34;
      }
      *(_DWORD *)(a1 + 340) = 0;
      int v28 = *v39;
      uint64_t v29 = _libssh2_ntohu32((unsigned int *)(v39 + 5));
      uint64_t v30 = v29;
      if (v28 == 101)
      {
        (*(void (**)(unsigned __int8 *, uint64_t))(v16 + 24))(v39, v16);
        if (!v30) {
          return v30;
        }
        *(_DWORD *)(a1 + 64) = v30;
        uint64_t v18 = v16;
        uint64_t v19 = 4294967265;
        uint64_t v20 = "SFTP Protocol Error";
        goto LABEL_34;
      }
      if (!v29)
      {
        (*(void (**)(unsigned __int8 *, uint64_t))(v16 + 24))(v39, v16);
        uint64_t v18 = v16;
        uint64_t v19 = 4294967265;
        uint64_t v20 = "Invalid READLINK/REALPATH response, no name entries";
        goto LABEL_34;
      }
      if (v41 <= 0xC)
      {
        if (v41) {
          (*(void (**)(unsigned __int8 *, uint64_t))(v16 + 24))(v39, v16);
        }
        uint64_t v18 = v16;
        uint64_t v19 = 4294967265;
        uint64_t v20 = "SFTP stat packet too short";
        goto LABEL_34;
      }
      uint64_t v33 = _libssh2_ntohu32((unsigned int *)(v39 + 9));
      uint64_t v34 = v39;
      if (v33 >= a5)
      {
        uint64_t v30 = 4294967258;
      }
      else
      {
        uint64_t v30 = v33;
        memcpy(a4, v39 + 13, v33);
        *((unsigned char *)a4 + v30) = 0;
      }
      (*(void (**)(unsigned __int8 *, uint64_t))(v16 + 24))(v34, v16);
LABEL_35:
      if (v30 != -37) {
        return v30;
      }
LABEL_36:
      uint64_t v31 = *(void *)(*(void *)a1 + 104);
      if (!*(_DWORD *)(v31 + 172)) {
        return 4294967259;
      }
      uint64_t v32 = _libssh2_wait_socket(v31, v11);
      if (v32) {
        return v32;
      }
    }
  }
  return 4294967257;
}

uint64_t libssh2_sftp_last_error(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 64);
  }
  return result;
}

uint64_t libssh2_sftp_get_channel(uint64_t result)
{
  if (result) {
    return *(void *)result;
  }
  return result;
}

uint64_t sftp_packet_require(uint64_t a1, int a2, int a3, void *a4, unint64_t *a5, unint64_t a6)
{
  uint64_t result = 4294967257;
  if (a4 && a5)
  {
    uint64_t v13 = *(void *)(*(void *)a1 + 104);
    while (sftp_packet_ask(a1, a2, a3, a4, a5))
    {
      if (*(_DWORD *)(v13 + 596)) {
        return 4294967283;
      }
      uint64_t result = sftp_packet_read(a1);
      if ((result & 0x80000000) != 0) {
        return result;
      }
    }
    if (*a5 >= a6) {
      return 0;
    }
    else {
      return 4294967258;
    }
  }
  return result;
}

uint64_t sftp_packet_ask(uint64_t a1, int a2, int a3, void *a4, void *a5)
{
  uint64_t v9 = *(void *)(*(void *)a1 + 104);
  uint64_t v10 = _libssh2_list_first(a1 + 16);
  if (!v10) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v11 = v10;
  while (1)
  {
    unsigned int v12 = *(unsigned __int8 **)(v11 + 32);
    if (*v12 == a2 && (a2 == 2 || *(_DWORD *)(v11 + 24) == a3)) {
      break;
    }
    uint64_t v11 = _libssh2_list_next(v11);
    if (!v11) {
      return 0xFFFFFFFFLL;
    }
  }
  *a4 = v12;
  *a5 = *(void *)(v11 + 40);
  _libssh2_list_remove((uint64_t *)v11);
  (*(void (**)(uint64_t, uint64_t))(v9 + 24))(v11, v9);
  return 0;
}

uint64_t sftp_packet_read(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  uint64_t v3 = *(void *)(*(void *)a1 + 104);
  int v4 = *(_DWORD *)(a1 + 160);
  if (v4 == 4)
  {
    *(_DWORD *)(a1 + 160) = 0;
    uint64_t v5 = *(unsigned __int8 **)(a1 + 88);
    if (v5) {
      goto LABEL_11;
    }
  }
  else if (v4 == 3)
  {
    *(_DWORD *)(a1 + 160) = 0;
    uint64_t v5 = *(unsigned __int8 **)(a1 + 88);
LABEL_4:
    unint64_t v6 = libssh2_channel_window_read_ex(v2, 0, 0);
    unint64_t v7 = *(unsigned int *)(a1 + 96);
    if (v6 < v7)
    {
      int v8 = _libssh2_channel_receive_window_adjust(v2, 2 * (int)v7, 1, 0);
      int v9 = v8 == -37 ? 3 : 0;
      *(_DWORD *)(a1 + 160) = v9;
      if (v8 == -37) {
        return 4294967259;
      }
    }
LABEL_11:
    unint64_t v10 = *(unsigned int *)(a1 + 96);
    unint64_t v11 = *(void *)(a1 + 104);
    while (v11 < v10)
    {
      unint64_t v12 = _libssh2_channel_read(v2, 0, (uint64_t)&v5[v11], v10 - v11);
      if (v12 == -37)
      {
        *(_DWORD *)(a1 + 160) = 4;
        return 4294967259;
      }
      unint64_t v13 = v12;
      if ((v12 & 0x8000000000000000) != 0)
      {
        (*(void (**)(unsigned __int8 *, uint64_t))(v3 + 24))(v5, v3);
        *(void *)(a1 + 88) = 0;
        uint64_t v21 = "Error waiting for SFTP packet";
        uint64_t v22 = v3;
        uint64_t v15 = v13;
        goto LABEL_51;
      }
      unint64_t v11 = *(void *)(a1 + 104) + v12;
      *(void *)(a1 + 104) = v11;
      unint64_t v10 = *(unsigned int *)(a1 + 96);
    }
    *(void *)(a1 + 88) = 0;
    if (v10 >= 5)
    {
      uint64_t v24 = *v5;
      uint64_t v25 = *(void *)(*(void *)a1 + 104);
      if ((v24 - 1) < 0x14 || (v24 - 101) < 5 || (v24 - 200) < 2)
      {
        int v26 = _libssh2_ntohu32((unsigned int *)(v5 + 1));
        if ((*v5 | 2) == 0x67 && find_zombie_request(a1, v26))
        {
          (*(void (**)(unsigned __int8 *, uint64_t))(v25 + 24))(v5, v25);
          uint64_t v27 = *(void *)(*(void *)a1 + 104);
          zombie_request = (uint64_t *)find_zombie_request(a1, v26);
          if (zombie_request)
          {
            uint64_t v29 = zombie_request;
            _libssh2_list_remove(zombie_request);
            (*(void (**)(uint64_t *, uint64_t))(v27 + 24))(v29, v27);
          }
          return v24;
        }
        uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t))(v25 + 8))(48, v25);
        if (v30)
        {
          *(void *)(v30 + 32) = v5;
          *(void *)(v30 + 40) = v10;
          *(_DWORD *)(v30 + 24) = v26;
          _libssh2_list_add((void **)(a1 + 16), (void *)v30);
          return v24;
        }
        uint64_t v32 = "Unable to allocate datablock for SFTP packet";
        uint64_t v33 = v25;
        uint64_t v34 = 4294967290;
      }
      else
      {
        *(_DWORD *)(a1 + 64) = 0;
        uint64_t v32 = "Out of sync with the world";
        uint64_t v33 = v25;
        uint64_t v34 = 4294967265;
      }
      uint64_t v23 = _libssh2_error(v33, v34, v32);
      if (!v23) {
        return v24;
      }
    }
    else
    {
      uint64_t v23 = 4294967255;
    }
    (*(void (**)(unsigned __int8 *, uint64_t))(v3 + 24))(v5, v3);
    return v23;
  }
  unint64_t v14 = _libssh2_channel_read(v2, 0, a1 + 68 + *(void *)(a1 + 80), 9 - *(void *)(a1 + 80));
  if (v14 == -37) {
    return 4294967259;
  }
  uint64_t v15 = v14;
  if ((v14 & 0x8000000000000000) != 0)
  {
    uint64_t v21 = "channel read";
    uint64_t v22 = v3;
    goto LABEL_51;
  }
  unint64_t v16 = *(void *)(a1 + 80) + v14;
  *(void *)(a1 + 80) = v16;
  if (v16 != 9) {
    return 4294967259;
  }
  int v17 = _libssh2_ntohu32((unsigned int *)(a1 + 68));
  int v18 = *(unsigned __int8 *)(a1 + 72);
  *(_DWORD *)(a1 + 96) = v17;
  int v19 = _libssh2_ntohu32((unsigned int *)(a1 + 73));
  unsigned int v20 = *(_DWORD *)(a1 + 96);
  if (v20 <= 0x40000)
  {
    if (v20 <= 4)
    {
      uint64_t v21 = "Invalid SFTP packet size";
      goto LABEL_50;
    }
  }
  else if (!*(_DWORD *)(a1 + 188) || *(_DWORD *)(a1 + 200) != v19 || v18 != 104)
  {
    libssh2_channel_flush_ex(v2, 0);
    *(void *)(a1 + 80) = 0;
    uint64_t v21 = "SFTP packet too large";
    uint64_t v22 = v3;
    uint64_t v15 = 4294967271;
    goto LABEL_51;
  }
  uint64_t v35 = (*(uint64_t (**)(void))(v3 + 8))();
  if (v35)
  {
    uint64_t v5 = (unsigned __int8 *)v35;
    *(void *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = v35;
    *(void *)(a1 + 104) = 5;
    int v36 = *(_DWORD *)(a1 + 72);
    *(unsigned char *)(v35 + 4) = *(unsigned char *)(a1 + 76);
    *(_DWORD *)uint64_t v35 = v36;
    goto LABEL_4;
  }
  uint64_t v21 = "Unable to allocate SFTP packet";
LABEL_50:
  uint64_t v22 = v3;
  uint64_t v15 = 4294967290;
LABEL_51:
  return _libssh2_error(v22, v15, v21);
}

uint64_t find_zombie_request(uint64_t a1, int a2)
{
  for (uint64_t result = _libssh2_list_first(a1 + 32); result; uint64_t result = _libssh2_list_next(result))
  {
    if (*(_DWORD *)(result + 24) == a2) {
      break;
    }
  }
  return result;
}

uint64_t sftp_attr2bin(char *a1, uint64_t *a2)
{
  unint64_t v6 = a1;
  if (a2)
  {
    _libssh2_store_u32((_DWORD **)&v6, *(_DWORD *)a2 & 0xF);
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)unint64_t v6 = bswap64(a2[1]);
      v6 += 8;
      uint64_t v4 = *a2;
      if ((*a2 & 2) == 0)
      {
LABEL_4:
        if ((v4 & 4) == 0) {
          goto LABEL_5;
        }
        goto LABEL_12;
      }
    }
    else if ((v4 & 2) == 0)
    {
      goto LABEL_4;
    }
    _libssh2_store_u32((_DWORD **)&v6, *((_DWORD *)a2 + 4));
    _libssh2_store_u32((_DWORD **)&v6, *((_DWORD *)a2 + 6));
    uint64_t v4 = *a2;
    if ((*a2 & 4) == 0)
    {
LABEL_5:
      if ((v4 & 8) == 0) {
        return v6 - a1;
      }
LABEL_6:
      _libssh2_store_u32((_DWORD **)&v6, *((_DWORD *)a2 + 10));
      _libssh2_store_u32((_DWORD **)&v6, *((_DWORD *)a2 + 12));
      return v6 - a1;
    }
LABEL_12:
    _libssh2_store_u32((_DWORD **)&v6, *((_DWORD *)a2 + 8));
    if ((*a2 & 8) == 0) {
      return v6 - a1;
    }
    goto LABEL_6;
  }
  _libssh2_htonu32(a1, 0);
  return 4;
}

uint64_t sftp_packet_requirev(void *a1, uint64_t a2, int a3, void *a4, unint64_t *a5, unint64_t a6)
{
  uint64_t v6 = 4294967257;
  if (a4 && a5)
  {
    if (!a1[14]) {
      a1[14] = time(0);
    }
    if (*(_DWORD *)(*(void *)(*a1 + 104) + 596))
    {
LABEL_6:
      a1[14] = 0;
      return 4294967283;
    }
    else
    {
      uint64_t v14 = 0;
      char v15 = 1;
      while (sftp_packet_ask((uint64_t)a1, *(unsigned __int8 *)(a2 + v14), a3, a4, a5))
      {
        if (v15)
        {
          uint64_t v14 = 1;
        }
        else
        {
          uint64_t v16 = sftp_packet_read((uint64_t)a1);
          uint64_t v6 = v16;
          if ((v16 & 0x80000000) != 0 && v16 != -37)
          {
            a1[14] = 0;
            return v6;
          }
          if ((int)v16 <= 0)
          {
            uint64_t v17 = *(void *)(*(void *)(*a1 + 104) + 73576);
            if (v17 - time(0) + a1[14] <= 0)
            {
              a1[14] = 0;
              return 4294967287;
            }
            if (v6 == -37) {
              return v6;
            }
          }
          if (*(_DWORD *)(*(void *)(*a1 + 104) + 596)) {
            goto LABEL_6;
          }
          uint64_t v14 = 0;
        }
        v15 ^= 1u;
      }
      a1[14] = 0;
      if (*a5 >= a6) {
        return 0;
      }
      else {
        return 4294967258;
      }
    }
  }
  return v6;
}

uint64_t sftp_bin2attr(void *a1, uint64_t a2, uint64_t a3)
{
  unsigned int v14 = 0;
  uint64_t v15 = a2;
  uint64_t v16 = a2;
  uint64_t v17 = a3;
  if (_libssh2_get_u32(&v15, &v14)) {
    return -38;
  }
  LODWORD(v5) = v14;
  *a1 = v14;
  if (v5)
  {
    if (_libssh2_get_u64((uint64_t)&v15, a1 + 1)) {
      return -38;
    }
    uint64_t v5 = *a1;
  }
  if ((v5 & 2) != 0)
  {
    LODWORD(v12) = 0;
    LODWORD(v11) = 0;
    if (_libssh2_get_u32(&v15, &v12) || _libssh2_get_u32(&v15, &v11)) {
      return -38;
    }
    uint64_t v6 = v11;
    a1[2] = v12;
    a1[3] = v6;
    uint64_t v5 = *a1;
    if ((*a1 & 4) != 0) {
      goto LABEL_9;
    }
  }
  else if ((v5 & 4) != 0)
  {
LABEL_9:
    LODWORD(v12) = 0;
    if (_libssh2_get_u32(&v15, &v12)) {
      return -38;
    }
    a1[4] = v12;
    uint64_t v5 = *a1;
  }
  if ((v5 & 8) != 0)
  {
    LODWORD(v12) = 0;
    LODWORD(v11) = 0;
    if (_libssh2_get_u32(&v15, &v12) || _libssh2_get_u32(&v15, &v11)) {
      return -38;
    }
    uint64_t v7 = v11;
    a1[5] = v12;
    a1[6] = v7;
    if ((*a1 & 0x80000000) == 0) {
      return v16 - v15;
    }
  }
  else if ((v5 & 0x80000000) == 0)
  {
    return v16 - v15;
  }
  unsigned int v13 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  if (!_libssh2_get_u32(&v15, &v13))
  {
    if (v13)
    {
      int v8 = 0;
      while (!_libssh2_get_string(&v15, &v11, &v12)
           && !_libssh2_get_string(&v15, &v9, &v10))
      {
        if (++v8 >= v13) {
          return v16 - v15;
        }
      }
      return -38;
    }
    return v16 - v15;
  }
  return -38;
}

void libssh2_sftp_init_cold_1()
{
}

void libssh2_sftp_read_cold_1()
{
}

void libssh2_sftp_read_cold_2()
{
  __assert_rtn("sftp_read", "sftp.c", 1519, "rc != LIBSSH2_ERROR_EAGAIN || !filep->eof");
}

void libssh2_sftp_read_cold_3()
{
  __assert_rtn("sftp_read", "sftp.c", 1518, "rc != LIBSSH2_ERROR_EAGAIN || !filep->data_left");
}

void libssh2_sftp_close_handle_cold_1()
{
}

char ***libssh2_hostkey_methods()
{
  return hostkey_methods;
}

_DWORD *libssh2_hostkey_hash(_DWORD *a1, int a2)
{
  switch(a2)
  {
    case 3:
      int v2 = a1[72];
      uint64_t v3 = a1 + 64;
      break;
    case 2:
      int v2 = a1[63];
      uint64_t v3 = a1 + 58;
      break;
    case 1:
      int v2 = a1[57];
      uint64_t v3 = a1 + 53;
      break;
    default:
      return 0;
  }
  if (v2) {
    return v3;
  }
  else {
    return 0;
  }
}

void *libssh2_session_hostkey(uint64_t a1, void *a2, int *a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 208);
  if (v3)
  {
    if (a2) {
      *a2 = v3;
    }
    uint64_t result = *(void **)(a1 + 200);
    if (a3)
    {
      if (v3 >= 0xB)
      {
        if (*result == 0x2D68737307000000 && *(void *)((char *)result + 3) == 0x6173722D68737307)
        {
          int v5 = 1;
          goto LABEL_46;
        }
        if (*result == 0x2D68737307000000 && *(void *)((char *)result + 3) == 0x7373642D68737307)
        {
          int v5 = 2;
          goto LABEL_46;
        }
        if (v3 >= 0xF)
        {
          if (*result == 0x2D6873730B000000 && *(void *)((char *)result + 7) == 0x393135353264652DLL)
          {
            int v5 = 6;
            goto LABEL_46;
          }
          if (v3 >= 0x17)
          {
            if (*result == 0x7364636513000000
              && result[1] == 0x6E2D326168732D61
              && *(void *)((char *)result + 15) == 0x363532707473696ELL)
            {
              int v5 = 3;
            }
            else if (*result == 0x7364636513000000 {
                   && result[1] == 0x6E2D326168732D61
            }
                   && *(void *)((char *)result + 15) == 0x343833707473696ELL)
            {
              int v5 = 4;
            }
            else if (*result ^ 0x7364636513000000 | result[1] ^ 0x6E2D326168732D61 | *(void *)((char *)result + 15) ^ 0x313235707473696ELL)
            {
              int v5 = 0;
            }
            else
            {
              int v5 = 5;
            }
            goto LABEL_46;
          }
        }
      }
      int v5 = 0;
LABEL_46:
      *a3 = v5;
    }
  }
  else
  {
    uint64_t result = 0;
    if (a2) {
      *a2 = 0;
    }
  }
  return result;
}

uint64_t hostkey_method_ssh_ecdsa_init(uint64_t a1, uint64_t a2, unint64_t a3, EC_KEY **a4)
{
  uint64_t v22 = 0;
  if (a4 && *a4)
  {
    EC_KEY_free(*a4);
    *a4 = 0;
  }
  if (a3 < 0x27) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v20 = 0;
  __s1 = 0;
  size_t v18 = 0;
  int v19 = 0;
  v16[2] = a3;
  uint64_t v17 = 0;
  v16[0] = a2;
  v16[1] = a2;
  int string = _libssh2_get_string(v16, &__s1, &v17);
  uint64_t result = 0xFFFFFFFFLL;
  if (!string && v17 == 19)
  {
    uint64_t v9 = __s1;
    int v10 = strncmp(__s1, "ecdsa-sha2-nistp256", 0x13uLL);
    if (v10)
    {
      if (!strncmp(v9, "ecdsa-sha2-nistp384", 0x13uLL))
      {
        int v13 = 0;
        int v12 = 715;
        int v11 = 1;
      }
      else
      {
        if (strncmp(v9, "ecdsa-sha2-nistp521", 0x13uLL)) {
          return 0xFFFFFFFFLL;
        }
        int v11 = 0;
        int v12 = 716;
        int v13 = 1;
      }
    }
    else
    {
      int v11 = 0;
      int v13 = 0;
      int v12 = 415;
    }
    int v14 = _libssh2_get_string(v16, &v20, &v17);
    uint64_t result = 0xFFFFFFFFLL;
    if (v14 || v17 != 8) {
      return result;
    }
    if ((v10 || !strncmp(v20, "nistp256", 8uLL))
      && (!v11 || !strncmp(v20, "nistp384", 8uLL))
      && (!v13 || !strncmp(v20, "nistp521", 8uLL))
      && !_libssh2_get_string(v16, &v19, &v18)
      && _libssh2_eob(v16))
    {
      int v15 = _libssh2_ecdsa_curve_name_with_octal_new(&v22, v19, v18, v12);
      if (v15) {
        uint64_t result = 0xFFFFFFFFLL;
      }
      else {
        uint64_t result = 0;
      }
      if (a4)
      {
        if (!v15)
        {
          uint64_t result = 0;
          *a4 = v22;
        }
      }
      return result;
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t hostkey_method_ssh_ecdsa_initPEM(uint64_t a1, char *a2, const char *a3, EC_KEY **a4)
{
  uint64_t v9 = 0;
  if (!a4) {
    return _libssh2_ecdsa_new_private(&v9, a1, a2, a3);
  }
  if (*a4)
  {
    EC_KEY_free(*a4);
    *a4 = 0;
  }
  uint64_t result = _libssh2_ecdsa_new_private(&v9, a1, a2, a3);
  *a4 = v9;
  return result;
}

uint64_t hostkey_method_ssh_ecdsa_initPEMFromMemory(uint64_t a1, void *a2, unint64_t a3, const char *a4, EC_KEY **a5)
{
  int v12 = 0;
  if (a5 && *a5)
  {
    EC_KEY_free(*a5);
    *a5 = 0;
  }
  int v10 = _libssh2_ecdsa_new_private_frommemory(&v12, a1, a2, a3, a4);
  if (v10) {
    uint64_t result = 0xFFFFFFFFLL;
  }
  else {
    uint64_t result = 0;
  }
  if (a5)
  {
    if (!v10)
    {
      uint64_t result = 0;
      *a5 = (EC_KEY *)v12;
    }
  }
  return result;
}

uint64_t hostkey_method_ssh_ecdsa_sig_verify(uint64_t a1, uint64_t a2, unint64_t a3, const void *a4, size_t a5, const EC_KEY **a6)
{
  if (a3 < 0x23) {
    return 0xFFFFFFFFLL;
  }
  v21[5] = v6;
  v21[6] = v7;
  int v11 = *a6;
  unsigned int v20 = 0;
  v21[0] = 0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  unsigned int v15 = 0;
  v14[0] = a2;
  v14[1] = a2;
  v14[2] = a3;
  int string = _libssh2_get_string(v14, &v19, &v16);
  uint64_t result = 0xFFFFFFFFLL;
  if (!string && v16 == 19)
  {
    int u32 = _libssh2_get_u32(v14, &v15);
    uint64_t result = 0xFFFFFFFFLL;
    if (!u32 && v15 >= 8)
    {
      if (_libssh2_get_string(v14, v21, &v18) || _libssh2_get_string(v14, &v20, &v17)) {
        return 0xFFFFFFFFLL;
      }
      else {
        return _libssh2_ecdsa_verify(v11, v21[0], v18, v20, v17, a4, a5);
      }
    }
  }
  return result;
}

uint64_t hostkey_method_ssh_ecdsa_signv(uint64_t a1, void *a2, char **a3, int a4, uint64_t a5, const EC_KEY **a6)
{
  LODWORD(v7) = a4;
  uint64_t v22 = *MEMORY[0x263EF8340];
  int v11 = *a6;
  curve_os_log_type_t type = _libssh2_ecdsa_get_curve_type(*a6);
  switch(curve_type)
  {
    case 716:
      ctx = 0;
      _libssh2_sha512_init(&ctx);
      if ((int)v7 >= 1)
      {
        uint64_t v7 = v7;
        uint64_t v17 = (size_t *)(a5 + 8);
        do
        {
          EVP_DigestUpdate(ctx, (const void *)*(v17 - 1), *v17);
          v17 += 2;
          --v7;
        }
        while (v7);
      }
      EVP_DigestFinal(ctx, md, 0);
      EVP_MD_CTX_free(ctx);
      uint64_t v14 = a1;
      unsigned int v15 = v11;
      int v16 = 64;
      return _libssh2_ecdsa_sign(v14, v15, md, v16, a2, a3);
    case 715:
      ctx = 0;
      _libssh2_sha384_init(&ctx);
      if ((int)v7 >= 1)
      {
        uint64_t v7 = v7;
        uint64_t v18 = (size_t *)(a5 + 8);
        do
        {
          EVP_DigestUpdate(ctx, (const void *)*(v18 - 1), *v18);
          v18 += 2;
          --v7;
        }
        while (v7);
      }
      EVP_DigestFinal(ctx, md, 0);
      EVP_MD_CTX_free(ctx);
      uint64_t v14 = a1;
      unsigned int v15 = v11;
      int v16 = 48;
      return _libssh2_ecdsa_sign(v14, v15, md, v16, a2, a3);
    case 415:
      ctx = 0;
      _libssh2_sha256_init(&ctx);
      if ((int)v7 >= 1)
      {
        uint64_t v7 = v7;
        int v13 = (size_t *)(a5 + 8);
        do
        {
          EVP_DigestUpdate(ctx, (const void *)*(v13 - 1), *v13);
          v13 += 2;
          --v7;
        }
        while (v7);
      }
      EVP_DigestFinal(ctx, md, 0);
      EVP_MD_CTX_free(ctx);
      uint64_t v14 = a1;
      unsigned int v15 = v11;
      int v16 = 32;
      return _libssh2_ecdsa_sign(v14, v15, md, v16, a2, a3);
  }
  return 0xFFFFFFFFLL;
}

uint64_t hostkey_method_ssh_ecdsa_dtor(uint64_t a1, EC_KEY **a2)
{
  if (*a2) {
    EC_KEY_free(*a2);
  }
  *a2 = 0;
  return 0;
}

uint64_t hostkey_method_ssh_ed25519_init(uint64_t a1, uint64_t a2, unint64_t a3, EVP_PKEY **a4)
{
  int v10 = 0;
  if (*a4)
  {
    EVP_PKEY_free(*a4);
    *a4 = 0;
  }
  if (a3 < 0x13) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  v9[0] = a2;
  v9[1] = a2;
  v9[2] = a3;
  if (_libssh2_match_string(v9, "ssh-ed25519")) {
    return 0xFFFFFFFFLL;
  }
  if (_libssh2_get_string(v9, &v11, &v12)) {
    return 0xFFFFFFFFLL;
  }
  if (!_libssh2_eob(v9)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = _libssh2_ed25519_new_public(&v10, a1, v11, v12);
  if (result) {
    return 0xFFFFFFFFLL;
  }
  *a4 = v10;
  return result;
}

uint64_t hostkey_method_ssh_ed25519_initPEM(uint64_t a1, const char *a2, const char *a3, EVP_PKEY **a4)
{
  uint64_t v9 = 0;
  if (*a4)
  {
    EVP_PKEY_free(*a4);
    *a4 = 0;
  }
  uint64_t result = _libssh2_ed25519_new_private(&v9, a1, a2, a3);
  if (result) {
    return 0xFFFFFFFFLL;
  }
  *a4 = v9;
  return result;
}

uint64_t hostkey_method_ssh_ed25519_initPEMFromMemory(uint64_t a1, void *a2, unint64_t a3, const char *a4, EVP_PKEY **a5)
{
  uint64_t v12 = 0;
  if (a5 && *a5)
  {
    EVP_PKEY_free(*a5);
    *a5 = 0;
  }
  int v10 = _libssh2_ed25519_new_private_frommemory(&v12, a1, a2, a3, a4);
  if (v10) {
    uint64_t result = 0xFFFFFFFFLL;
  }
  else {
    uint64_t result = 0;
  }
  if (a5)
  {
    if (!v10)
    {
      uint64_t result = 0;
      *a5 = v12;
    }
  }
  return result;
}

uint64_t hostkey_method_ssh_ed25519_sig_verify(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, size_t a5, uint64_t *a6)
{
  if (a3 == 83) {
    return _libssh2_ed25519_verify(*a6, a2 + 19, 64, a4, a5);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t hostkey_method_ssh_ed25519_signv(uint64_t a1, void *a2, void *a3, int a4, uint64_t a5, uint64_t *a6)
{
  if (a4 == 1) {
    return _libssh2_ed25519_sign(*a6, a1, a2, a3, *(void **)a5, *(void *)(a5 + 8));
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t hostkey_method_ssh_ed25519_dtor(uint64_t a1, EVP_PKEY **a2)
{
  if (*a2) {
    EVP_PKEY_free(*a2);
  }
  *a2 = 0;
  return 0;
}

uint64_t hostkey_method_ssh_rsa_init(uint64_t a1, uint64_t a2, unint64_t a3, RSA **a4)
{
  if (*a4)
  {
    RSA_free(*a4);
    *a4 = 0;
  }
  if (a3 < 0x13) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  int v16 = 0;
  uint64_t v17 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v13 = 0;
  v12[0] = a2;
  v12[1] = a2;
  v12[2] = a3;
  if (_libssh2_get_string(v12, &v16, &v13)) {
    return 0xFFFFFFFFLL;
  }
  if (v13 != 12)
  {
    if (v13 != 7) {
      return 0xFFFFFFFFLL;
    }
    int v8 = v16;
    uint64_t v9 = "ssh-rsa";
    size_t v10 = 7;
    goto LABEL_12;
  }
  uint64_t v11 = v16;
  if (strncmp("rsa-sha2-256", v16, 0xCuLL))
  {
    uint64_t v9 = "rsa-sha2-512";
    int v8 = v11;
    size_t v10 = 12;
LABEL_12:
    if (strncmp(v9, v8, v10)) {
      return 0xFFFFFFFFLL;
    }
  }
  if (!_libssh2_get_string(v12, &v18, &v15)
    && !_libssh2_get_string(v12, &v17, &v14)
    && _libssh2_eob(v12))
  {
    uint64_t result = _libssh2_rsa_new((uint64_t *)&v19, v18, v15, v17, v14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    if (!result)
    {
      *a4 = v19;
      return result;
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t hostkey_method_ssh_rsa_initPEM(uint64_t a1, char *a2, const char *a3, RSA **a4)
{
  if (*a4)
  {
    RSA_free(*a4);
    *a4 = 0;
  }
  uint64_t v9 = 0;
  uint64_t result = _libssh2_rsa_new_private(&v9, a1, a2, a3);
  if (result) {
    return 0xFFFFFFFFLL;
  }
  *a4 = v9;
  return result;
}

uint64_t hostkey_method_ssh_rsa_initPEMFromMemory(uint64_t a1, void *a2, unint64_t a3, const char *a4, RSA **a5)
{
  if (*a5)
  {
    RSA_free(*a5);
    *a5 = 0;
  }
  uint64_t v11 = 0;
  uint64_t result = _libssh2_rsa_new_private_frommemory((EVP_PKEY **)&v11, a1, a2, a3, a4);
  if (result) {
    return 0xFFFFFFFFLL;
  }
  *a5 = v11;
  return result;
}

uint64_t hostkey_method_ssh_rsa_sha2_512_sig_verify(uint64_t a1, uint64_t a2, unint64_t a3, const void *a4, size_t a5, RSA **a6)
{
  if (a3 >= 0x14) {
    return _libssh2_rsa_sha2_verify(*a6, 0x40uLL, (unsigned __int8 *)(a2 + 20), (int)a3 - 20, a4, a5);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t hostkey_method_ssh_rsa_sha2_512_signv(uint64_t a1, unsigned __int8 **a2, void *a3, int a4, uint64_t a5, RSA **a6)
{
  LODWORD(v7) = a4;
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v11 = *a6;
  ctx = 0;
  if (!_libssh2_sha512_init(&ctx)) {
    return 0xFFFFFFFFLL;
  }
  if ((int)v7 >= 1)
  {
    uint64_t v7 = v7;
    uint64_t v12 = (size_t *)(a5 + 8);
    do
    {
      EVP_DigestUpdate(ctx, (const void *)*(v12 - 1), *v12);
      v12 += 2;
      --v7;
    }
    while (v7);
  }
  EVP_DigestFinal(ctx, md, 0);
  EVP_MD_CTX_free(ctx);
  if (_libssh2_rsa_sha2_sign(a1, v11, md, 64, a2, a3)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t hostkey_method_ssh_rsa_dtor(uint64_t a1, RSA **a2)
{
  *a2 = 0;
  return 0;
}

uint64_t hostkey_method_ssh_rsa_sha2_256_sig_verify(uint64_t a1, uint64_t a2, unint64_t a3, const void *a4, size_t a5, RSA **a6)
{
  if (a3 >= 0x14) {
    return _libssh2_rsa_sha2_verify(*a6, 0x20uLL, (unsigned __int8 *)(a2 + 20), (int)a3 - 20, a4, a5);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t hostkey_method_ssh_rsa_sha2_256_signv(uint64_t a1, unsigned __int8 **a2, void *a3, int a4, uint64_t a5, RSA **a6)
{
  LODWORD(v7) = a4;
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v11 = *a6;
  ctx = 0;
  if (!_libssh2_sha256_init(&ctx)) {
    return 0xFFFFFFFFLL;
  }
  if ((int)v7 >= 1)
  {
    uint64_t v7 = v7;
    uint64_t v12 = (size_t *)(a5 + 8);
    do
    {
      EVP_DigestUpdate(ctx, (const void *)*(v12 - 1), *v12);
      v12 += 2;
      --v7;
    }
    while (v7);
  }
  EVP_DigestFinal(ctx, md, 0);
  EVP_MD_CTX_free(ctx);
  if (_libssh2_rsa_sha2_sign(a1, v11, md, 32, a2, a3)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t hostkey_method_ssh_rsa_sig_verify(uint64_t a1, uint64_t a2, unint64_t a3, const void *a4, size_t a5, RSA **a6)
{
  BOOL v6 = a3 >= 0xF;
  unsigned int v7 = a3 - 15;
  if (v6) {
    return _libssh2_rsa_sha1_verify(*a6, (unsigned __int8 *)(a2 + 15), v7, a4, a5);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t hostkey_method_ssh_rsa_signv(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t *a6)
{
  LODWORD(v7) = a4;
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v11 = *a6;
  ctx = 0;
  _libssh2_sha1_init(&ctx);
  if ((int)v7 >= 1)
  {
    uint64_t v7 = v7;
    uint64_t v12 = (size_t *)(a5 + 8);
    do
    {
      EVP_DigestUpdate(ctx, (const void *)*(v12 - 1), *v12);
      v12 += 2;
      --v7;
    }
    while (v7);
  }
  EVP_DigestFinal(ctx, md, 0);
  EVP_MD_CTX_free(ctx);
  if (_libssh2_rsa_sha1_sign(a1, v11, md, 20, a2, a3)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t hostkey_method_ssh_dss_init(uint64_t a1, uint64_t a2, unint64_t a3, DSA **a4)
{
  if (*a4)
  {
    DSA_free(*a4);
    *a4 = 0;
  }
  if (a3 < 0x1B) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v13 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  v8[0] = a2;
  v8[1] = a2;
  v8[2] = a3;
  if (_libssh2_match_string(v8, "ssh-dss")) {
    return 0xFFFFFFFFLL;
  }
  if (_libssh2_get_string(v8, &v16, &v12)) {
    return 0xFFFFFFFFLL;
  }
  if (_libssh2_get_string(v8, &v15, &v11)) {
    return 0xFFFFFFFFLL;
  }
  if (_libssh2_get_string(v8, &v14, &v10)) {
    return 0xFFFFFFFFLL;
  }
  if (_libssh2_get_string(v8, &v13, &v9)) {
    return 0xFFFFFFFFLL;
  }
  if (!_libssh2_eob(v8)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = _libssh2_dsa_new((uint64_t *)&v17, v16, v12, v15, v11, v14, v10, v13, v9, 0, 0);
  if (result) {
    return 0xFFFFFFFFLL;
  }
  *a4 = v17;
  return result;
}

uint64_t hostkey_method_ssh_dss_initPEM(uint64_t a1, char *a2, const char *a3, DSA **a4)
{
  if (*a4)
  {
    DSA_free(*a4);
    *a4 = 0;
  }
  uint64_t v9 = 0;
  uint64_t result = _libssh2_dsa_new_private(&v9, a1, a2, a3);
  if (result) {
    return 0xFFFFFFFFLL;
  }
  *a4 = v9;
  return result;
}

uint64_t hostkey_method_ssh_dss_initPEMFromMemory(uint64_t a1, void *a2, unint64_t a3, const char *a4, DSA **a5)
{
  if (*a5)
  {
    DSA_free(*a5);
    *a5 = 0;
  }
  uint64_t v11 = 0;
  uint64_t result = _libssh2_dsa_new_private_frommemory((EVP_PKEY **)&v11, a1, a2, a3, a4);
  if (result) {
    return 0xFFFFFFFFLL;
  }
  *a5 = v11;
  return result;
}

uint64_t hostkey_method_ssh_dss_sig_verify(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, size_t a5, DSA **a6)
{
  if (a3 == 55) {
    return _libssh2_dsa_sha1_verify(*a6, (const unsigned __int8 *)(a2 + 15), a4, a5);
  }
  else {
    return _libssh2_error(a1, 4294967282, "Invalid DSS signature length");
  }
}

uint64_t hostkey_method_ssh_dss_signv(uint64_t a1, uint64_t *a2, void *a3, int a4, uint64_t a5, DSA **a6)
{
  LODWORD(v7) = a4;
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v11 = *a6;
  uint64_t v12 = _libssh2_calloc(a1, 0x28uLL);
  *a2 = (uint64_t)v12;
  if (!v12) {
    return 0xFFFFFFFFLL;
  }
  ctx = 0;
  *a3 = 40;
  _libssh2_sha1_init(&ctx);
  if ((int)v7 >= 1)
  {
    uint64_t v7 = v7;
    uint64_t v13 = (size_t *)(a5 + 8);
    do
    {
      EVP_DigestUpdate(ctx, (const void *)*(v13 - 1), *v13);
      v13 += 2;
      --v7;
    }
    while (v7);
  }
  EVP_DigestFinal(ctx, md, 0);
  EVP_MD_CTX_free(ctx);
  uint64_t result = _libssh2_dsa_sha1_sign(v11, md, 20, *a2);
  if (result)
  {
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(*a2, a1);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t hostkey_method_ssh_dss_dtor(uint64_t a1, DSA **a2)
{
  *a2 = 0;
  return 0;
}

uint64_t _libssh2_bcrypt_pbkdf(const void *a1, size_t a2, const void *a3, unint64_t a4, uint64_t a5, unint64_t a6, unsigned int a7)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  if (!a7) {
    return 0xFFFFFFFFLL;
  }
  size_t v7 = a4;
  uint64_t result = 0xFFFFFFFFLL;
  if (a4 > 0x100000 || !a2 || !a4 || a6 - 1025 < 0xFFFFFFFFFFFFFC00) {
    return result;
  }
  size_t cnt = a4 + 4;
  uint64_t v13 = malloc_type_calloc(1uLL, a4 + 4, 0xC06265B5uLL);
  if (!v13) {
    return 0xFFFFFFFFLL;
  }
  ctx = 0;
  unint64_t v14 = (a6 + 31) >> 5;
  uint64_t v29 = v13;
  memcpy(v13, a3, v7);
  _libssh2_sha512_init(&ctx);
  EVP_DigestUpdate(ctx, a1, a2);
  EVP_DigestFinal(ctx, md, 0);
  EVP_MD_CTX_free(ctx);
  unsigned int v15 = 0;
  size_t v26 = v7 + 1;
  size_t v27 = v7;
  size_t v25 = v7 + 2;
  size_t v24 = v7 + 3;
  int v16 = 1;
  unint64_t v17 = a6;
  unint64_t v18 = (unsigned __int16)(v14 + a6 - 1) / (unsigned __int16)v14;
  do
  {
    unsigned int v31 = v15;
    v29[v7] = HIBYTE(v16);
    v29[v26] = BYTE2(v16);
    v29[v25] = BYTE1(v16);
    v29[v24] = v16;
    _libssh2_sha512_init(&ctx);
    EVP_DigestUpdate(ctx, v29, cnt);
    EVP_DigestFinal(ctx, v35, 0);
    EVP_MD_CTX_free(ctx);
    bcrypt_hash((uint64_t)md);
    __s[0] = d[0];
    __s[1] = d[1];
    if (a7 >= 2)
    {
      uint64_t v19 = 1;
      do
      {
        _libssh2_sha512_init(&ctx);
        EVP_DigestUpdate(ctx, d, 0x20uLL);
        EVP_DigestFinal(ctx, v35, 0);
        EVP_MD_CTX_free(ctx);
        bcrypt_hash((uint64_t)md);
        for (uint64_t i = 0; i != 2; ++i)
          __s[i] = veorq_s8((int8x16_t)__s[i], (int8x16_t)d[i]);
        ++v19;
      }
      while (v19 != a7);
    }
    unint64_t v21 = 0;
    if (v18 >= v17) {
      unint64_t v18 = v17;
    }
    if (v18)
    {
      unint64_t v22 = v31;
      while (v22 < a6)
      {
        *(unsigned char *)(a5 + v22) = *((unsigned char *)__s + v21++);
        v22 += v14;
        if (v18 == v21)
        {
          unint64_t v21 = v18;
          break;
        }
      }
    }
    ++v16;
    unsigned int v15 = v31 + 1;
    v17 -= v21;
    size_t v7 = v27;
  }
  while (v17);
  memset_s(__s, 0x20uLL, 0, 0x20uLL);
  free(v29);
  return 0;
}

uint64_t bcrypt_hash(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x270FA5388](a1);
  uint64_t v3 = v2;
  uint64_t v5 = v4;
  uint64_t v6 = v1;
  uint64_t v45 = *MEMORY[0x263EF8340];
  qmemcpy(__s, "OxychromaticBlowfishSwatDynamite", 32);
  memcpy(__dst, &Blowfish_initstate_initstate, sizeof(__dst));
  uint64_t v7 = 0;
  unsigned __int16 v8 = 0;
  do
  {
    int v9 = 0;
    unsigned int v10 = 0;
    do
    {
      if ((v8 & 0xFFC0) != 0) {
        unsigned __int16 v8 = 0;
      }
      int v9 = *(unsigned __int8 *)(v6 + v8++) | (v9 << 8);
      BOOL v11 = v10++ >= 3;
    }
    while (!v11);
    __dst[v7++ + 1024] ^= v9;
  }
  while (v7 != 18);
  int v12 = 0;
  unsigned int v13 = 0;
  unint64_t v14 = 0;
  int v15 = 0;
  do
  {
    int v16 = 0;
    unsigned int v17 = 0;
    do
    {
      if ((v15 & 0xFFC0) != 0) {
        int v18 = 0;
      }
      else {
        int v18 = v15;
      }
      int v16 = *(unsigned __int8 *)(v5 + (unsigned __int16)v18) | (v16 << 8);
      int v15 = v18 + 1;
      BOOL v11 = v17++ >= 3;
    }
    while (!v11);
    int v19 = 0;
    unsigned int v20 = 0;
    v43[0] = v16 ^ v13;
    do
    {
      if ((v15 & 0xFFC0) != 0) {
        int v21 = 0;
      }
      else {
        int v21 = v15;
      }
      int v19 = *(unsigned __int8 *)(v5 + (unsigned __int16)v21) | (v19 << 8);
      int v15 = v21 + 1;
      BOOL v11 = v20++ >= 3;
    }
    while (!v11);
    int v42 = v19 ^ v12;
    Blowfish_encipher(__dst, v43, &v42);
    int v12 = v42;
    unsigned int v13 = v43[0];
    __dst[v14 + 1024] = v43[0];
    *(_DWORD *)((char *)&__dst[1024] + ((4 * v14) | 4)) = v12;
    BOOL v11 = v14 >= 0x10;
    v14 += 2;
  }
  while (!v11);
  for (uint64_t i = 0; i != 4; ++i)
  {
    unint64_t v23 = 0;
    do
    {
      int v24 = 0;
      unsigned int v25 = 0;
      do
      {
        if ((v15 & 0xFFC0) != 0) {
          int v26 = 0;
        }
        else {
          int v26 = v15;
        }
        int v24 = *(unsigned __int8 *)(v5 + (unsigned __int16)v26) | (v24 << 8);
        int v15 = v26 + 1;
        BOOL v11 = v25++ >= 3;
      }
      while (!v11);
      int v27 = 0;
      unsigned int v28 = 0;
      v43[0] = v24 ^ v13;
      do
      {
        if ((v15 & 0xFFC0) != 0) {
          int v29 = 0;
        }
        else {
          int v29 = v15;
        }
        int v27 = *(unsigned __int8 *)(v5 + (unsigned __int16)v29) | (v27 << 8);
        int v15 = v29 + 1;
        BOOL v11 = v28++ >= 3;
      }
      while (!v11);
      int v42 = v27 ^ v12;
      Blowfish_encipher(__dst, v43, &v42);
      int v12 = v42;
      unsigned int v13 = v43[0];
      uint64_t v30 = &__dst[256 * i];
      v30[v23] = v43[0];
      *(_DWORD *)((char *)v30 + ((4 * v23) | 4)) = v12;
      BOOL v11 = v23 >= 0xFE;
      v23 += 2;
    }
    while (!v11);
  }
  int v31 = 64;
  do
  {
    Blowfish_expand0state(__dst, v5);
    Blowfish_expand0state(__dst, v6);
    --v31;
  }
  while (v31);
  uint64_t v32 = 0;
  unsigned __int16 v33 = 0;
  do
  {
    int v34 = 0;
    unsigned int v35 = 0;
    do
    {
      if ((v33 & 0xFFE0) != 0) {
        unsigned __int16 v33 = 0;
      }
      int v34 = __s[v33++] | (v34 << 8);
      BOOL v11 = v35++ >= 3;
    }
    while (!v11);
    v43[v32++] = v34;
  }
  while (v32 != 8);
  for (int j = 0; j != 64; ++j)
  {
    unsigned int v37 = 0;
    unsigned int v38 = v43;
    do
    {
      Blowfish_encipher(__dst, v38, (int *)v38 + 1);
      v38 += 2;
      BOOL v11 = v37++ >= 3;
    }
    while (!v11);
  }
  for (uint64_t k = 0; k != 8; ++k)
    *(_DWORD *)(v3 + k * 4) = v43[k];
  memset_s(__s, 0x20uLL, 0, 0x20uLL);
  memset_s(v43, 0x20uLL, 0, 0x20uLL);
  return memset_s(__dst, 0x1048uLL, 0, 0x1048uLL);
}

_DWORD *Blowfish_expand0state(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = 0;
  unsigned __int16 v4 = 0;
  do
  {
    int v6 = 0;
    unsigned int v7 = 0;
    do
    {
      if ((v4 & 0xFFC0) != 0) {
        unsigned __int16 v4 = 0;
      }
      int v6 = *(unsigned __int8 *)(a2 + v4++) | (v6 << 8);
      BOOL v8 = v7++ >= 3;
    }
    while (!v8);
    a1[v3++ + 1024] ^= v6;
  }
  while (v3 != 18);
  unint64_t v9 = 0;
  uint64_t v15 = 0;
  do
  {
    Blowfish_encipher(v2, (unsigned int *)&v15 + 1, (int *)&v15);
    v2[v9 + 1024] = HIDWORD(v15);
    v2[v9 + 1025] = v15;
    BOOL v8 = v9 >= 0x10;
    v9 += 2;
  }
  while (!v8);
  for (uint64_t i = 0; i != 4; ++i)
  {
    unint64_t v11 = 0;
    do
    {
      uint64_t result = Blowfish_encipher(a1, (unsigned int *)&v15 + 1, (int *)&v15);
      int v13 = v15;
      unint64_t v14 = &v2[v11];
      *unint64_t v14 = HIDWORD(v15);
      v14[1] = v13;
      BOOL v8 = v11 >= 0xFE;
      v11 += 2;
    }
    while (!v8);
    v2 += 256;
  }
  return result;
}

_DWORD *Blowfish_encipher(_DWORD *result, unsigned int *a2, int *a3)
{
  unsigned int v3 = result[1024] ^ *a2;
  unsigned int v4 = result[1025] ^ *a3 ^ (((result[BYTE2(v3) | 0x100] + result[HIBYTE(v3)]) ^ result[BYTE1(v3) | 0x200])
                           + result[(*((unsigned char *)result + 4096) ^ *(unsigned char *)a2) | 0x300]);
  unsigned int v5 = result[1026] ^ v3 ^ (((result[BYTE2(v4) | 0x100] + result[HIBYTE(v4)]) ^ result[BYTE1(v4) | 0x200])
                          + result[(*((unsigned char *)result + 4100) ^ *(unsigned char *)a3 ^ (((LOBYTE(result[BYTE2(v3) | 0x100])
                                                                                                 + LOBYTE(result[HIBYTE(v3)])) ^ LOBYTE(result[BYTE1(v3) | 0x200]))
                                                                                               + LOBYTE(result[(*((unsigned char *)result + 4096) ^ *(unsigned char *)a2) | 0x300]))) | 0x300]);
  unsigned int v6 = result[1027] ^ v4 ^ (((result[BYTE2(v5) | 0x100] + result[HIBYTE(v5)]) ^ result[BYTE1(v5) | 0x200])
                          + result[v5 | 0x300]);
  unsigned int v7 = result[1028] ^ v5 ^ (((result[BYTE2(v6) | 0x100] + result[HIBYTE(v6)]) ^ result[BYTE1(v6) | 0x200])
                          + result[v6 | 0x300]);
  unsigned int v8 = result[1029] ^ v6 ^ (((result[BYTE2(v7) | 0x100] + result[HIBYTE(v7)]) ^ result[BYTE1(v7) | 0x200])
                          + result[v7 | 0x300]);
  unsigned int v9 = result[1030] ^ v7 ^ (((result[BYTE2(v8) | 0x100] + result[HIBYTE(v8)]) ^ result[BYTE1(v8) | 0x200])
                          + result[v8 | 0x300]);
  unsigned int v10 = result[1031] ^ v8 ^ (((result[BYTE2(v9) | 0x100] + result[HIBYTE(v9)]) ^ result[BYTE1(v9) | 0x200])
                           + result[v9 | 0x300]);
  unsigned int v11 = result[1032] ^ v9 ^ (((result[BYTE2(v10) | 0x100] + result[HIBYTE(v10)]) ^ result[BYTE1(v10) | 0x200])
                           + result[v10 | 0x300]);
  unsigned int v12 = result[1033] ^ v10 ^ (((result[BYTE2(v11) | 0x100] + result[HIBYTE(v11)]) ^ result[BYTE1(v11) | 0x200])
                            + result[v11 | 0x300]);
  unsigned int v13 = result[1034] ^ v11 ^ (((result[BYTE2(v12) | 0x100] + result[HIBYTE(v12)]) ^ result[BYTE1(v12) | 0x200])
                            + result[v12 | 0x300]);
  unsigned int v14 = result[1035] ^ v12 ^ (((result[BYTE2(v13) | 0x100] + result[HIBYTE(v13)]) ^ result[BYTE1(v13) | 0x200])
                            + result[v13 | 0x300]);
  unsigned int v15 = result[1036] ^ v13 ^ (((result[BYTE2(v14) | 0x100] + result[HIBYTE(v14)]) ^ result[BYTE1(v14) | 0x200])
                            + result[v14 | 0x300]);
  unsigned int v16 = result[1037] ^ v14 ^ (((result[BYTE2(v15) | 0x100] + result[HIBYTE(v15)]) ^ result[BYTE1(v15) | 0x200])
                            + result[v15 | 0x300]);
  unsigned int v17 = result[1038] ^ v15 ^ (((result[BYTE2(v16) | 0x100] + result[HIBYTE(v16)]) ^ result[BYTE1(v16) | 0x200])
                            + result[v16 | 0x300]);
  unsigned int v18 = result[1039] ^ v16 ^ (((result[BYTE2(v17) | 0x100] + result[HIBYTE(v17)]) ^ result[BYTE1(v17) | 0x200])
                            + result[v17 | 0x300]);
  int v19 = result[1040] ^ v17 ^ (((result[BYTE2(v18) | 0x100] + result[HIBYTE(v18)]) ^ result[BYTE1(v18) | 0x200])
                            + result[v18 | 0x300]);
  *a2 = result[1041] ^ v18;
  *a3 = v19;
  return result;
}

uint64_t libssh2_keepalive_config(uint64_t result, int a2, int a3)
{
  if (a3 == 1) {
    int v3 = 2;
  }
  else {
    int v3 = a3;
  }
  *(_DWORD *)(result + 73560) = v3;
  *(_DWORD *)(result + 73564) = a2 != 0;
  return result;
}

uint64_t libssh2_keepalive_send(uint64_t a1, _DWORD *a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  int v3 = (int *)(a1 + 73560);
  if (*(_DWORD *)(a1 + 73560))
  {
    time_t v5 = time(0);
    time_t v6 = v5;
    uint64_t v7 = *((void *)v3 + 1);
    uint64_t v8 = *v3;
    if (v7 + v8 > v5)
    {
      if (a2) {
        *a2 = v8 + v7 - v5;
      }
      return 0;
    }
    strcpy((char *)v12 + 12, "ve@libssh2.orgW");
    v12[0] = xmmword_23C6FE39C;
    BYTE10(v12[1]) = v3[1];
    uint64_t v10 = _libssh2_transport_send(a1, v12, 0x1BuLL, 0, 0);
    uint64_t v9 = v10;
    if (v10 != -37 && v10)
    {
      _libssh2_error(a1, 4294967289, "Unable to send keepalive message");
    }
    else
    {
      *((void *)v3 + 1) = v6;
      if (a2) {
        *a2 = *v3;
      }
    }
    if (v9 == -37 || !v9) {
      return 0;
    }
  }
  else
  {
    if (!a2) {
      return 0;
    }
    uint64_t v9 = 0;
    *a2 = 0;
  }
  return v9;
}

uint64_t libssh2_session_banner_set(uint64_t a1, char *__s)
{
  if (__s) {
    size_t v4 = strlen(__s);
  }
  else {
    size_t v4 = 0;
  }
  uint64_t v5 = *(void *)(a1 + 424);
  if (v5)
  {
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v5, a1);
    *(void *)(a1 + 424) = 0;
  }
  if (!v4) {
    return 0;
  }
  time_t v6 = (void *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v4 + 3, a1);
  *(void *)(a1 + 424) = v6;
  if (v6)
  {
    memcpy(v6, __s, v4);
    *(unsigned char *)(*(void *)(a1 + 424) + v4) = 0;
    *(unsigned char *)(*(void *)(a1 + 424) + v4) = 13;
    *(unsigned char *)(v4 + *(void *)(a1 + 424) + 1) = 10;
    *(unsigned char *)(v4 + *(void *)(a1 + 424) + 2) = 0;
    return 0;
  }
  return _libssh2_error(a1, 4294967290, "Unable to allocate memory for local banner");
}

void *libssh2_session_init_ex(void *(*a1)(size_t a1), void (__cdecl *a2)(void *), void *(*a3)(void *a1, size_t a2), uint64_t a4)
{
  uint64_t v10 = a4;
  if (a1)
  {
    time_t v6 = a1;
    uint64_t v7 = (void *)((uint64_t (*)(uint64_t, uint64_t *))a1)(73584, &v10);
  }
  else
  {
    time_t v6 = libssh2_default_alloc;
    uint64_t v7 = (void *)((uint64_t (*)(uint64_t, uint64_t *))libssh2_default_alloc)(73584, &v10);
  }
  uint64_t v8 = v7;
  if (v7)
  {
    if (!a3) {
      a3 = libssh2_default_realloc;
    }
    if (!a2) {
      a2 = libssh2_default_free;
    }
    bzero(v7, 0x11F70uLL);
    v8[2] = a3;
    void v8[3] = a2;
    v8[12] = _libssh2_send;
    v8[13] = _libssh2_recv;
    *uint64_t v8 = v10;
    v8[1] = v6;
    v8[22] = 0;
    *((_DWORD *)v8 + 43) = 1;
    v8[9197] = 60;
    *((_DWORD *)v8 + 35) = 1;
    _libssh2_init_if_needed();
  }
  return v8;
}

void *libssh2_default_alloc(size_t a1)
{
  return malloc_type_malloc(a1, 0xA00FEF1BuLL);
}

void *libssh2_default_realloc(void *a1, size_t a2)
{
  return malloc_type_realloc(a1, a2, 0xE27BE433uLL);
}

uint64_t libssh2_session_callback_set(uint64_t *a1, int a2, uint64_t a3)
{
  switch(a2)
  {
    case 0:
      int v3 = a1 + 4;
      goto LABEL_13;
    case 1:
      int v3 = a1 + 5;
      goto LABEL_13;
    case 2:
      int v3 = a1 + 6;
      goto LABEL_13;
    case 3:
      int v3 = a1 + 7;
      goto LABEL_13;
    case 4:
      int v3 = a1 + 8;
      goto LABEL_13;
    case 5:
      int v3 = a1 + 12;
      goto LABEL_13;
    case 6:
      int v3 = a1 + 13;
      goto LABEL_13;
    case 7:
      int v3 = a1 + 9;
      goto LABEL_13;
    case 8:
      int v3 = a1 + 10;
      goto LABEL_13;
    case 9:
      int v3 = a1 + 11;
LABEL_13:
      uint64_t result = *v3;
      *int v3 = a3;
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t _libssh2_wait_socket(uint64_t a1, time_t a2)
{
  int v36 = 0;
  *(_DWORD *)(a1 + 616) = 0;
  uint64_t result = libssh2_keepalive_send(a1, &v36);
  if (!result)
  {
    int v5 = *(_DWORD *)(a1 + 600);
    if (v5) {
      LODWORD(v6) = 1000 * v36;
    }
    else {
      LODWORD(v6) = 1000;
    }
    uint64_t v6 = (int)v6;
    uint64_t v7 = *(void *)(a1 + 176);
    if (v7 < 1 || v36 && v7 >= (int)v6)
    {
      BOOL v8 = (int)v6 > 0;
    }
    else
    {
      time_t v16 = time(0);
      double v17 = difftime(v16, a2) * 1000.0;
      uint64_t v18 = *(void *)(a1 + 176);
      uint64_t v6 = v18 - (uint64_t)v17;
      if (v18 < (uint64_t)v17)
      {
        unsigned int v15 = "API timeout expired";
        return _libssh2_error(a1, 4294967287, v15);
      }
      BOOL v8 = 1;
    }
    uint64_t v9 = 0;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    v19[0] = v6 / 1000;
    v19[1] = 1000 * (v6 % 1000);
    if (v5)
    {
      long long v34 = 0uLL;
      long long v35 = 0uLL;
      long long v32 = 0uLL;
      long long v33 = 0uLL;
      long long v30 = 0uLL;
      long long v31 = 0uLL;
      long long v28 = 0uLL;
      long long v29 = 0uLL;
      int v10 = *(_DWORD *)(a1 + 592);
      uint64_t v9 = (fd_set *)&v28;
      if (__darwin_check_fd_set_overflow(v10, &v28, 0)) {
        *(_DWORD *)((char *)&v28 + (((unint64_t)v10 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v10;
      }
    }
    if ((v5 & 2) != 0)
    {
      long long v26 = 0u;
      long long v27 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      int v12 = *(_DWORD *)(a1 + 592);
      unsigned int v11 = (fd_set *)&v20;
      if (__darwin_check_fd_set_overflow(v12, &v20, 0)) {
        *(_DWORD *)((char *)&v20 + (((unint64_t)v12 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v12;
      }
    }
    else
    {
      unsigned int v11 = 0;
    }
    if (v8) {
      uint64_t v13 = (timeval *)v19;
    }
    else {
      uint64_t v13 = 0;
    }
    int v14 = select(*(_DWORD *)(a1 + 592) + 1, v9, v11, 0, v13);
    if (v14)
    {
      if ((v14 & 0x80000000) == 0) {
        return 0;
      }
      unsigned int v15 = "Error waiting on socket";
    }
    else
    {
      unsigned int v15 = "Timed out waiting on socket";
    }
    return _libssh2_error(a1, 4294967287, v15);
  }
  return result;
}

uint64_t libssh2_session_block_directions(uint64_t a1)
{
  return *(unsigned int *)(a1 + 600);
}

uint64_t libssh2_session_handshake(uint64_t a1, int a2)
{
  int v3 = (void *)(a1 + 71040);
  uint64_t v4 = a1 + 70720;
  time_t v5 = time(0);
  uint64_t v6 = (void *)(a1 + 71024);
  uint64_t v7 = (unint64_t *)(a1 + 71032);
  while (2)
  {
    uint64_t result = 4294967262;
    switch(*(_DWORD *)(v4 + 296))
    {
      case 0:
        if (a2 == -1)
        {
          uint64_t v14 = a1;
          uint64_t v13 = 4294967251;
          unsigned int v15 = "Bad socket provided";
          goto LABEL_77;
        }
        *(_DWORD *)(a1 + 592) = a2;
        char v9 = fcntl(a2, 3, 0);
        *(_DWORD *)(a1 + 604) = (v9 & 4) == 0;
        if ((v9 & 4) == 0)
        {
          int v10 = *(_DWORD *)(a1 + 592);
          int v11 = fcntl(v10, 3, 0);
          uint64_t v12 = fcntl(v10, 4, v11 | 4u);
          if (v12)
          {
            uint64_t v13 = v12;
            uint64_t v14 = a1;
            unsigned int v15 = "Failed changing socket's blocking state to non-blocking";
            goto LABEL_77;
          }
        }
        *(_DWORD *)(v4 + 296) = 2;
        goto LABEL_8;
      case 2:
LABEL_8:
        if (*(_DWORD *)v4)
        {
          time_t v16 = v3;
          double v17 = v6;
          uint64_t v18 = v7;
          int v19 = "SSH-2.0-libssh2_1.11.0\r\n";
          size_t v20 = 24;
        }
        else
        {
          time_t v16 = v3;
          double v17 = v6;
          uint64_t v18 = v7;
          int v19 = *(const char **)(a1 + 424);
          if (v19)
          {
            size_t v20 = strlen(*(const char **)(a1 + 424));
          }
          else
          {
            int v19 = "SSH-2.0-libssh2_1.11.0\r\n";
            size_t v20 = 24;
          }
          *(_DWORD *)uint64_t v4 = 2;
        }
        *(_DWORD *)(a1 + 600) &= ~2u;
        uint64_t v21 = (*(uint64_t (**)(void, const char *, size_t, void, uint64_t))(a1 + 96))(*(unsigned int *)(a1 + 592), &v19[*(void *)(v4 + 264)], v20 - *(void *)(v4 + 264), (*(_DWORD *)(a1 + 132) == 0) << 19, a1);
        uint64_t v22 = *(void *)(v4 + 264);
        if (v21 != v20 - v22)
        {
          uint64_t v7 = v18;
          if (v21 < 0 && v21 != -35)
          {
            *(_DWORD *)uint64_t v4 = 0;
            *(void *)(v4 + 264) = 0;
            uint64_t result = _libssh2_error(a1, 4294967253, "Failed sending banner");
            uint64_t v6 = v17;
            int v3 = v16;
            goto LABEL_78;
          }
          *(_DWORD *)(a1 + 600) = 2;
          uint64_t v6 = v17;
          int v3 = v16;
          if (v21 >= 1) {
            *(void *)(v4 + 264) = v22 + v21;
          }
LABEL_79:
          if (!*(_DWORD *)(a1 + 172)) {
            return 4294967259;
          }
          uint64_t result = _libssh2_wait_socket(a1, v5);
          if (result) {
            return result;
          }
          continue;
        }
        *(void *)(v4 + 264) = 0;
        *(_DWORD *)(v4 + 296) = 3;
        *(_DWORD *)uint64_t v4 = 0;
        uint64_t v7 = v18;
        uint64_t v6 = v17;
        int v3 = v16;
        do
        {
LABEL_17:
          if (*(_DWORD *)v4)
          {
            size_t v23 = *(void *)(v4 + 264);
            if (v23 > 0xFF) {
              goto LABEL_35;
            }
            goto LABEL_19;
          }
          size_t v23 = 0;
          *(_DWORD *)uint64_t v4 = 2;
          do
          {
            char v38 = 0;
            *(_DWORD *)(a1 + 600) &= ~1u;
            uint64_t v24 = (*(uint64_t (**)(void, char *, uint64_t, void, uint64_t))(a1 + 104))(*(unsigned int *)(a1 + 592), &v38, 1, (*(_DWORD *)(a1 + 132) == 0) << 19, a1);
            if (v24 < 0)
            {
              if (v24 == -35)
              {
                *(_DWORD *)(a1 + 600) = 1;
                *(void *)(v4 + 264) = v23;
                uint64_t v13 = 4294967259;
              }
              else
              {
                *(_DWORD *)uint64_t v4 = 0;
                *(void *)(v4 + 264) = 0;
                uint64_t v13 = 4294967253;
              }
LABEL_82:
              if (v13 != -37)
              {
LABEL_64:
                uint64_t v14 = a1;
                unsigned int v15 = "Failed getting banner";
                goto LABEL_77;
              }
              goto LABEL_79;
            }
            if (!v24)
            {
              *(_DWORD *)(a1 + 596) = -1;
              uint64_t v13 = 4294967283;
              goto LABEL_82;
            }
            BOOL v26 = v38 == 13 || v38 == 10;
            if (!v23 && v26)
            {
              size_t v23 = 0;
              goto LABEL_34;
            }
            if (!v38)
            {
              *(_DWORD *)uint64_t v4 = 0;
              *(void *)(v4 + 264) = 0;
              uint64_t v13 = 4294967294;
              goto LABEL_82;
            }
            size_t v27 = a1 + v23++;
            *(unsigned char *)(v27 + 70724) = v38;
LABEL_34:
            if (v23 >= 0x100) {
              break;
            }
LABEL_19:
            ;
          }
          while (!v23 || *(unsigned char *)(v23 + a1 + 70723) != 10);
LABEL_35:
          while (1)
          {
            int v28 = *(unsigned __int8 *)(a1 + 70723 + v23);
            if (v28 != 13 && v28 != 10) {
              break;
            }
            if (!--v23)
            {
              *(_DWORD *)uint64_t v4 = 0;
              *(void *)(v4 + 264) = 0;
              uint64_t v13 = 4294967294;
              goto LABEL_64;
            }
          }
          *(_DWORD *)uint64_t v4 = 0;
          *(void *)(v4 + 264) = 0;
          uint64_t v30 = *(void *)(a1 + 312);
          if (v30) {
            (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v30, a1);
          }
          long long v31 = (void *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v23 + 1, a1);
          *(void *)(a1 + 312) = v31;
          if (v31)
          {
            memcpy(v31, (const void *)(a1 + 70724), v23);
            *(unsigned char *)(*(void *)(a1 + 312) + v23) = 0;
            continue;
          }
          uint64_t v13 = _libssh2_error(a1, 4294967290, "Error allocating space for remote banner");
          if (v13) {
            goto LABEL_82;
          }
        }
        while (strncmp("SSH-", *(const char **)(a1 + 312), 4uLL));
        *(_DWORD *)(v4 + 296) = 4;
LABEL_55:
        uint64_t v32 = _libssh2_kex_exchange(a1, 0, a1 + 71088);
        if (v32 == -37) {
          goto LABEL_79;
        }
        uint64_t v13 = v32;
        if (v32)
        {
          uint64_t v14 = a1;
          unsigned int v15 = "Unable to exchange encryption keys";
          goto LABEL_77;
        }
        *(_DWORD *)(v4 + 296) = 5;
LABEL_58:
        *(unsigned char *)int v3 = 5;
        _libssh2_htonu32((_DWORD *)(a1 + 71041), 0xCu);
        *(_DWORD *)(a1 + 71053) = 1752462689;
        *(void *)(a1 + 71045) = *(void *)"ssh-userauth";
        *(_DWORD *)(v4 + 296) = 6;
LABEL_59:
        uint64_t v33 = _libssh2_transport_send(a1, v3, 0x11uLL, 0, 0);
        if (v33 == -37) {
          goto LABEL_79;
        }
        uint64_t v13 = v33;
        if (v33)
        {
          uint64_t v14 = a1;
          unsigned int v15 = "Unable to ask for ssh-userauth service";
          goto LABEL_77;
        }
        *(_DWORD *)(v4 + 296) = 7;
LABEL_62:
        uint64_t v34 = _libssh2_packet_require(a1, 6, v6, v7, 0, 0, 0, a1 + 71072);
        if (v34)
        {
          uint64_t v13 = v34;
          uint64_t v14 = a1;
          unsigned int v15 = "Failed to get response to ssh-userauth request";
          goto LABEL_77;
        }
        if (*v7 <= 4)
        {
          uint64_t v14 = a1;
          uint64_t v13 = 4294967282;
          unsigned int v15 = "Unexpected packet length";
          goto LABEL_77;
        }
        unsigned int v35 = _libssh2_ntohu32((unsigned int *)(*v6 + 1));
        v3[3] = v35;
        uint64_t v36 = *v6;
        if (v35 == 12 && !strncmp("ssh-userauth", (const char *)(v36 + 5), 0xCuLL))
        {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v36, a1);
          uint64_t result = 0;
          *(void *)(v4 + 304) = 0;
          *(_DWORD *)(v4 + 296) = 0;
        }
        else
        {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v36, a1);
          *uint64_t v6 = 0;
          uint64_t v14 = a1;
          uint64_t v13 = 4294967282;
          unsigned int v15 = "Invalid response received from server";
LABEL_77:
          uint64_t result = _libssh2_error(v14, v13, v15);
LABEL_78:
          if (result == -37) {
            goto LABEL_79;
          }
        }
        return result;
      case 3:
        goto LABEL_17;
      case 4:
        goto LABEL_55;
      case 5:
        goto LABEL_58;
      case 6:
        goto LABEL_59;
      case 7:
        goto LABEL_62;
      default:
        return result;
    }
  }
}

uint64_t libssh2_session_free(uint64_t a1)
{
  uint64_t v2 = a1 + 71000;
  int v3 = (void *)(a1 + 35664);
  time_t v4 = time(0);
  while (2)
  {
    int v5 = *(_DWORD *)(v2 + 752);
    switch(v5)
    {
      case 3:
        goto LABEL_10;
      case 2:
        do
        {
LABEL_6:
          uint64_t v6 = _libssh2_list_first(a1 + 552);
          if (!v6)
          {
            *(_DWORD *)(v2 + 752) = 3;
LABEL_10:
            while (1)
            {
              uint64_t v7 = _libssh2_list_first(a1 + 576);
              if (!v7) {
                break;
              }
              if (_libssh2_channel_forward_cancel(v7) == -37) {
                goto LABEL_12;
              }
            }
            *(_DWORD *)(v2 + 752) = 4;
            goto LABEL_16;
          }
        }
        while (_libssh2_channel_free(v6) != -37);
LABEL_12:
        if (*(_DWORD *)(a1 + 172))
        {
          uint64_t result = _libssh2_wait_socket(a1, v4);
          if (!result) {
            continue;
          }
        }
        else
        {
          return 4294967259;
        }
        break;
      case 0:
        *(_DWORD *)(v2 + 752) = 2;
        goto LABEL_6;
      default:
LABEL_16:
        if ((*(unsigned char *)(a1 + 128) & 2) != 0)
        {
          uint64_t v9 = *(void *)(a1 + 184);
          if (v9)
          {
            int v10 = *(void (**)(uint64_t, uint64_t))(v9 + 64);
            if (v10) {
              v10(a1, a1 + 192);
            }
          }
          uint64_t v11 = *(void *)(a1 + 448);
          if (v11)
          {
            uint64_t v12 = *(void (**)(uint64_t, uint64_t))(v11 + 56);
            if (v12) {
              v12(a1, a1 + 456);
            }
          }
          uint64_t v13 = *(void *)(a1 + 488);
          if (v13)
          {
            uint64_t v14 = *(void (**)(uint64_t, uint64_t, uint64_t))(v13 + 40);
            if (v14) {
              v14(a1, 1, a1 + 496);
            }
          }
          uint64_t v15 = *(void *)(a1 + 464);
          if (v15)
          {
            time_t v16 = *(void (**)(uint64_t, uint64_t))(v15 + 32);
            if (v16) {
              v16(a1, a1 + 480);
            }
          }
          uint64_t v17 = *(void *)(a1 + 336);
          if (v17)
          {
            uint64_t v18 = *(void (**)(uint64_t, uint64_t))(v17 + 56);
            if (v18) {
              v18(a1, a1 + 344);
            }
          }
          uint64_t v19 = *(void *)(a1 + 376);
          if (v19)
          {
            size_t v20 = *(void (**)(uint64_t, void, uint64_t))(v19 + 40);
            if (v20) {
              v20(a1, 0, a1 + 384);
            }
          }
          uint64_t v21 = *(void *)(a1 + 352);
          if (v21)
          {
            uint64_t v22 = *(void (**)(uint64_t, uint64_t))(v21 + 32);
            if (v22) {
              v22(a1, a1 + 368);
            }
          }
          uint64_t v23 = *(void *)(a1 + 160);
          if (v23) {
            (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v23, a1);
          }
        }
        uint64_t v24 = *(void *)(a1 + 312);
        if (v24) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v24, a1);
        }
        uint64_t v25 = *(void *)(a1 + 424);
        if (v25) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v25, a1);
        }
        uint64_t v26 = *(void *)(a1 + 112);
        if (v26) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v26, a1);
        }
        uint64_t v27 = *(void *)(a1 + 120);
        if (v27) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v27, a1);
        }
        uint64_t v28 = *(void *)(a1 + 432);
        if (v28) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v28, a1);
        }
        uint64_t v29 = *(void *)(a1 + 504);
        if (v29) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v29, a1);
        }
        uint64_t v30 = *(void *)(a1 + 512);
        if (v30) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v30, a1);
        }
        uint64_t v31 = *(void *)(a1 + 520);
        if (v31) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v31, a1);
        }
        uint64_t v32 = *(void *)(a1 + 528);
        if (v32) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v32, a1);
        }
        uint64_t v33 = *(void *)(a1 + 320);
        if (v33) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v33, a1);
        }
        uint64_t v34 = *(void *)(a1 + 392);
        if (v34) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v34, a1);
        }
        uint64_t v35 = *(void *)(a1 + 400);
        if (v35) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v35, a1);
        }
        uint64_t v36 = *(void *)(a1 + 408);
        if (v36) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v36, a1);
        }
        uint64_t v37 = *(void *)(a1 + 416);
        if (v37) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v37, a1);
        }
        uint64_t v38 = *(void *)(a1 + 296);
        if (v38) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v38, a1);
        }
        uint64_t v39 = *(void *)(a1 + 304);
        if (v39) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v39, a1);
        }
        if (*(void *)v2) {
          (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)v2, a1);
        }
        uint64_t v40 = *(void *)(v2 + 24);
        if (v40) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v40, a1);
        }
        uint64_t v41 = *(void *)(v2 + 1056);
        if (v41) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v41, a1);
        }
        uint64_t v42 = *(void *)(v2 + 1072);
        if (v42) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v42, a1);
        }
        uint64_t v43 = *(void *)(v2 + 1096);
        if (v43) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v43, a1);
        }
        uint64_t v44 = *(void *)(v2 + 1120);
        if (v44) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v44, a1);
        }
        uint64_t v45 = *(void *)(v2 + 1168);
        if (v45) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v45, a1);
        }
        uint64_t v46 = *(void *)(v2 + 1184);
        if (v46) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v46, a1);
        }
        uint64_t v47 = *(void *)(v2 + 1152);
        if (v47) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v47, a1);
        }
        uint64_t v48 = *(void *)(v2 + 1224);
        if (v48) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v48, a1);
        }
        uint64_t v49 = *(void *)(v2 + 1240);
        if (v49) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v49, a1);
        }
        uint64_t v50 = *(void *)(v2 + 1256);
        if (v50) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v50, a1);
        }
        uint64_t v51 = *(void *)(v2 + 1304);
        if (v51) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v51, a1);
        }
        uint64_t v52 = *(void *)(v2 + 1320);
        if (v52) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v52, a1);
        }
        uint64_t v53 = *(void *)(v2 + 1360);
        if (v53) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v53, a1);
        }
        uint64_t v54 = *(void *)(v2 + 1424);
        if (v54) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v54, a1);
        }
        uint64_t v55 = *(void *)(v2 + 1440);
        if (v55) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v55, a1);
        }
        uint64_t v56 = *(void *)(v2 + 1464);
        if (v56) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v56, a1);
        }
        uint64_t v57 = *(void *)(v2 + 1504);
        if (v57) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v57, a1);
        }
        uint64_t v58 = *(void *)(v2 + 1552);
        if (v58) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v58, a1);
        }
        uint64_t v59 = *(void *)(v2 + 1944);
        if (v59) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v59, a1);
        }
        uint64_t v60 = *(void *)(v2 + 2272);
        if (v60) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v60, a1);
        }
        uint64_t v61 = *(void *)(v2 + 1896);
        if (v61) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v61, a1);
        }
        if (*v3) {
          (*(void (**)(void, uint64_t))(a1 + 24))(v3[1], a1);
        }
        uint64_t v62 = _libssh2_list_first(a1 + 536);
        if (v62)
        {
          uint64_t v63 = (uint64_t *)v62;
          do
          {
            _libssh2_list_remove(v63);
            (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v63[3], a1);
            (*(void (**)(uint64_t *, uint64_t))(a1 + 24))(v63, a1);
            uint64_t v63 = (uint64_t *)_libssh2_list_first(a1 + 536);
          }
          while (v63);
        }
        if (*(_DWORD *)(a1 + 604))
        {
          int v64 = *(_DWORD *)(a1 + 592);
          int v65 = fcntl(v64, 3, 0);
          fcntl(v64, 4, v65 & 0xFFFFFFFB);
        }
        uint64_t v66 = *(void *)(a1 + 200);
        if (v66) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v66, a1);
        }
        if (*(void *)(a1 + 608))
        {
          if (*(unsigned char *)(a1 + 620)) {
            (*(void (**)(void))(a1 + 24))();
          }
        }
        (*(void (**)(uint64_t, uint64_t))(a1 + 24))(a1, a1);
        return 0;
    }
    return result;
  }
}

uint64_t libssh2_session_disconnect_ex(_DWORD *a1, unsigned int a2, const void *a3, const char *a4)
{
  uint64_t v7 = (size_t *)(a1 + 18008);
  BOOL v8 = a1 + 17939;
  a1[32] &= ~1u;
  time_t v9 = time(0);
  while (1)
  {
    size_t v10 = 0;
    uint64_t v17 = 0;
    if (*v8) {
      break;
    }
    if (!a3)
    {
      if (!a4)
      {
        unint64_t v12 = 0;
LABEL_15:
        size_t v10 = 0;
LABEL_16:
        *uint64_t v7 = v12 + v10 + 13;
        uint64_t v17 = (_DWORD *)((char *)a1 + 71761);
        *((unsigned char *)v8 + 4) = 1;
        _libssh2_store_u32(&v17, a2);
        _libssh2_store_str(&v17, a3, v12);
        _libssh2_store_u32(&v17, v10);
        *BOOL v8 = 2;
        break;
      }
      size_t v10 = strlen(a4);
      unint64_t v12 = 0;
LABEL_9:
      uint64_t v14 = "too long language string";
      if (v10 <= 0x100) {
        goto LABEL_16;
      }
      goto LABEL_12;
    }
    size_t v11 = strlen((const char *)a3);
    unint64_t v12 = v11;
    if (a4)
    {
      size_t v13 = strlen(a4);
      uint64_t v14 = "too long description";
      if (v12 > 0x100) {
        goto LABEL_12;
      }
      size_t v10 = v13;
      goto LABEL_9;
    }
    uint64_t v14 = "too long description";
    if (v11 <= 0x100) {
      goto LABEL_15;
    }
LABEL_12:
    uint64_t result = _libssh2_error((uint64_t)a1, 4294967262, v14);
    if (result != -37) {
      return result;
    }
LABEL_18:
    if (!a1[43]) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket((uint64_t)a1, v9);
    if (result) {
      return result;
    }
  }
  if (_libssh2_transport_send((uint64_t)a1, a1 + 17940, *v7, a4, v10) == -37) {
    goto LABEL_18;
  }
  uint64_t result = 0;
  *BOOL v8 = 0;
  return result;
}

const char *libssh2_session_methods(uint64_t a1, int a2)
{
  uint64_t v2 = "";
  switch(a2)
  {
    case 0:
      int v3 = (uint64_t *)(a1 + 144);
      goto LABEL_11;
    case 1:
      int v3 = (uint64_t *)(a1 + 184);
      goto LABEL_11;
    case 2:
      int v3 = (uint64_t *)(a1 + 448);
      goto LABEL_11;
    case 3:
      int v3 = (uint64_t *)(a1 + 336);
      goto LABEL_11;
    case 4:
      int v3 = (uint64_t *)(a1 + 464);
      goto LABEL_11;
    case 5:
      int v3 = (uint64_t *)(a1 + 352);
      goto LABEL_11;
    case 6:
      int v3 = (uint64_t *)(a1 + 488);
      goto LABEL_11;
    case 7:
      int v3 = (uint64_t *)(a1 + 376);
LABEL_11:
      uint64_t v6 = *v3;
      if (v6) {
        return *(const char **)v6;
      }
      time_t v4 = "No method negotiated";
      uint64_t v5 = 4294967279;
LABEL_14:
      _libssh2_error(a1, v5, v4);
      return 0;
    case 8:
    case 9:
      return v2;
    default:
      time_t v4 = "Invalid parameter specified for method_type";
      uint64_t v5 = 4294967262;
      goto LABEL_14;
  }
}

uint64_t libssh2_session_last_error(uint64_t a1, const char **a2, _DWORD *a3, int a4)
{
  if (*(_DWORD *)(a1 + 616))
  {
    if (a2)
    {
      if (*(void *)(a1 + 608)) {
        BOOL v8 = *(const char **)(a1 + 608);
      }
      else {
        BOOL v8 = "";
      }
      size_t v9 = strlen(v8);
      size_t v10 = v9;
      if (!a4)
      {
        *a2 = v8;
        if (!a3) {
          return *(unsigned int *)(a1 + 616);
        }
        goto LABEL_16;
      }
      size_t v11 = (char *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v9 + 1, a1);
      *a2 = v11;
      if (v11)
      {
        memcpy(v11, v8, v10);
        (*a2)[v10] = 0;
        if (!a3) {
          return *(unsigned int *)(a1 + 616);
        }
        goto LABEL_16;
      }
    }
    else
    {
      LODWORD(v10) = 0;
    }
    if (!a3) {
      return *(unsigned int *)(a1 + 616);
    }
LABEL_16:
    *a3 = v10;
    return *(unsigned int *)(a1 + 616);
  }
  if (a2)
  {
    if (a4)
    {
      unint64_t v12 = (const char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(1, a1);
      *a2 = v12;
      if (v12) {
        *unint64_t v12 = 0;
      }
    }
    else
    {
      *a2 = "";
    }
  }
  uint64_t result = 0;
  if (a3) {
    *a3 = 0;
  }
  return result;
}

uint64_t libssh2_session_last_errno(uint64_t a1)
{
  return *(unsigned int *)(a1 + 616);
}

uint64_t libssh2_session_set_last_error(uint64_t a1, uint64_t a2, char *a3)
{
  return _libssh2_error_flags(a1, a2, a3, 1);
}

uint64_t libssh2_session_flag(_DWORD *a1, int a2, int a3)
{
  switch(a2)
  {
    case 3:
      int v3 = a1 + 35;
      goto LABEL_7;
    case 2:
      int v3 = a1 + 34;
      goto LABEL_7;
    case 1:
      int v3 = a1 + 33;
LABEL_7:
      uint64_t result = 0;
      *int v3 = a3;
      return result;
  }
  return 4294967262;
}

uint64_t _libssh2_session_set_blocking(uint64_t a1, int a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 172);
  *(_DWORD *)(a1 + 172) = a2;
  return v2;
}

uint64_t libssh2_session_set_blocking(uint64_t result, int a2)
{
  *(_DWORD *)(result + 172) = a2;
  return result;
}

uint64_t libssh2_session_get_blocking(uint64_t a1)
{
  return *(unsigned int *)(a1 + 172);
}

uint64_t libssh2_session_set_timeout(uint64_t result, uint64_t a2)
{
  *(void *)(result + 176) = a2;
  return result;
}

uint64_t libssh2_session_get_timeout(uint64_t a1)
{
  return *(void *)(a1 + 176);
}

uint64_t libssh2_session_set_read_timeout(uint64_t result, uint64_t a2)
{
  uint64_t v2 = 60;
  if (a2 >= 1) {
    uint64_t v2 = a2;
  }
  *(void *)(result + 73576) = v2;
  return result;
}

uint64_t libssh2_session_get_read_timeout(uint64_t a1)
{
  return *(void *)(a1 + 73576);
}

uint64_t libssh2_poll_channel_read(uint64_t a1, int a2)
{
  if (!a1) {
    return 4294967257;
  }
  uint64_t v4 = *(void *)(a1 + 104);
  uint64_t result = _libssh2_list_first(v4 + 536);
  if (!result) {
    return result;
  }
  uint64_t v6 = result;
  while (*(void *)(v6 + 32) > 4uLL)
  {
    int v7 = *(_DWORD *)(a1 + 48);
    if (v7 == _libssh2_ntohu32((unsigned int *)(*(void *)(v6 + 24) + 1)))
    {
      if (a2)
      {
        if (a2 != 1) {
          goto LABEL_11;
        }
        int v8 = **(unsigned char **)(v6 + 24) & 0xFE;
      }
      else
      {
        int v8 = **(unsigned __int8 **)(v6 + 24);
      }
      if (v8 == 94) {
        return 1;
      }
    }
LABEL_11:
    uint64_t result = _libssh2_list_next(v6);
    uint64_t v6 = result;
    if (!result) {
      return result;
    }
  }
  return _libssh2_error(v4, 4294967258, "Packet too small");
}

uint64_t libssh2_poll(uint64_t a1, unsigned int a2, uint64_t a3)
{
  v52.__darwin_time_t tv_sec = 0;
  *(void *)&v52.__darwin_suseconds_t tv_usec = 0;
  memset(&v54, 0, sizeof(v54));
  memset(&v53, 0, sizeof(v53));
  int v5 = 0;
  if (a2)
  {
    uint64_t v6 = 0;
    int v7 = (void *)(a1 + 16);
    for (uint64_t i = a2; i; --i)
    {
      v7[1] = 0;
      int v9 = *((unsigned __int8 *)v7 - 16);
      switch(v9)
      {
        case 3:
          int v13 = *(_DWORD *)(*(void *)(*(v7 - 1) + 24) + 592);
          if (__darwin_check_fd_set_overflow(v13, &v54, 0)) {
            *(__int32_t *)((char *)v54.fds_bits + (((unint64_t)v13 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v13;
          }
          uint64_t v14 = *(void *)(*(v7 - 1) + 24);
          break;
        case 2:
          int v15 = *(_DWORD *)(*(void *)(*(v7 - 1) + 104) + 592);
          if (__darwin_check_fd_set_overflow(v15, &v54, 0)) {
            *(__int32_t *)((char *)v54.fds_bits + (((unint64_t)v15 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v15;
          }
          uint64_t v14 = *(void *)(*(v7 - 1) + 104);
          break;
        case 1:
          uint64_t v10 = *v7;
          if (*v7)
          {
            int v11 = *((_DWORD *)v7 - 2);
            if (__darwin_check_fd_set_overflow(v11, &v54, 0)) {
              *(__int32_t *)((char *)v54.fds_bits + (((unint64_t)v11 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v11;
            }
            if (*((_DWORD *)v7 - 2) > v5) {
              int v5 = *((_DWORD *)v7 - 2);
            }
            uint64_t v10 = *v7;
          }
          if ((v10 & 4) != 0)
          {
            int v12 = *((_DWORD *)v7 - 2);
            if (__darwin_check_fd_set_overflow(v12, &v53, 0)) {
              *(__int32_t *)((char *)v53.fds_bits + (((unint64_t)v12 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v12;
            }
            if (*((_DWORD *)v7 - 2) > v5) {
              int v5 = *((_DWORD *)v7 - 2);
            }
          }
          goto LABEL_28;
        default:
          if (v6) {
            _libssh2_error(v6, 4294967261, "Invalid descriptor passed to libssh2_poll()");
          }
          return 0xFFFFFFFFLL;
      }
      if (*(_DWORD *)(v14 + 592) > v5) {
        int v5 = *(_DWORD *)(v14 + 592);
      }
      if (!v6) {
        uint64_t v6 = v14;
      }
LABEL_28:
      v7 += 4;
    }
  }
  int v47 = v5 + 1;
  unsigned int v16 = a2;
  do
  {
    uint64_t v17 = 0;
    if (!v16) {
      goto LABEL_61;
    }
    uint64_t v18 = a2;
    uint64_t v19 = (uint64_t *)(a1 + 24);
    do
    {
      uint64_t v21 = *(v19 - 1);
      uint64_t v20 = *v19;
      if (v21 == *v19) {
        goto LABEL_55;
      }
      int v22 = *((unsigned __int8 *)v19 - 24);
      if (v22 == 3)
      {
        if ((v21 & 1) != 0 && (v20 & 1) == 0)
        {
          uint64_t v20 = *v19 | (_libssh2_list_first(*(v19 - 2) + 48) != 0);
          *uint64_t v19 = v20;
        }
        uint64_t v24 = *(void *)(*(v19 - 2) + 24);
      }
      else
      {
        if (v22 != 2)
        {
          uint64_t v21 = *v19;
          goto LABEL_55;
        }
        if ((v21 & 1) != 0 && (v20 & 1) == 0)
        {
          uint64_t v20 = *v19 | (libssh2_poll_channel_read(*(v19 - 2), 0) != 0);
          *uint64_t v19 = v20;
          uint64_t v21 = *(v19 - 1);
        }
        if ((v21 & 2) != 0 && (v20 & 2) == 0)
        {
          uint64_t v20 = *v19 | (2 * (libssh2_poll_channel_read(*(v19 - 2), 1) != 0));
          *uint64_t v19 = v20;
          uint64_t v21 = *(v19 - 1);
        }
        if ((v21 & 4) != 0 && (v20 & 4) == 0)
        {
          v20 |= 4 * (*(_DWORD *)(*(v19 - 2) + 56) != 0);
          *uint64_t v19 = v20;
        }
        uint64_t v23 = *(v19 - 2);
        if (*(unsigned char *)(v23 + 84) || *(unsigned char *)(v23 + 64))
        {
          v20 |= 0x80uLL;
          *uint64_t v19 = v20;
        }
        uint64_t v24 = *(void *)(v23 + 104);
      }
      int v25 = *(_DWORD *)(v24 + 596);
      uint64_t v21 = v20;
      if (v25 == -1)
      {
        *uint64_t v19 = v20 | 0x90;
        uint64_t v21 = 1;
      }
LABEL_55:
      if (v21) {
        uint64_t v17 = (v17 + 1);
      }
      else {
        uint64_t v17 = v17;
      }
      v19 += 4;
      --v18;
    }
    while (v18);
    if (v17) {
      a3 = 0;
    }
LABEL_61:
    *(void *)&v51.__darwin_suseconds_t tv_usec = 0;
    v52.__darwin_time_t tv_sec = a3 / 1000;
    v52.__darwin_suseconds_t tv_usec = 1000 * (a3 % 1000);
    *(void *)&v50.__darwin_suseconds_t tv_usec = 0;
    v51.__darwin_time_t tv_sec = 0;
    v50.__darwin_time_t tv_sec = 0;
    gettimeofday(&v51, 0);
    int v26 = select(v47, &v54, &v53, 0, &v52);
    gettimeofday(&v50, 0);
    __darwin_time_t tv_sec = v50.tv_sec;
    __darwin_time_t v27 = v51.tv_sec;
    __darwin_suseconds_t tv_usec = v50.tv_usec;
    __darwin_suseconds_t v29 = v51.tv_usec;
    if (v26 >= 1 && v16)
    {
      uint64_t v30 = 0;
      do
      {
        int v31 = *(unsigned __int8 *)(a1 + 32 * v30);
        switch(v31)
        {
          case 3:
            uint64_t v37 = a1 + 32 * v30;
            uint64_t v39 = *(void *)(v37 + 8);
            uint64_t v38 = v37 + 8;
            int v40 = *(_DWORD *)(*(void *)(v39 + 24) + 592);
            if (__darwin_check_fd_set_overflow(v40, &v54, 0)
              && ((*(unsigned int *)((char *)v54.fds_bits + (((unint64_t)v40 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v40) & 1) != 0)
            {
              while ((int)_libssh2_transport_read(*(void *)(*(void *)v38 + 24)) > 0)
                ;
            }
            break;
          case 2:
            uint64_t v41 = a1 + 32 * v30;
            uint64_t v43 = *(void *)(v41 + 8);
            uint64_t v42 = v41 + 8;
            int v44 = *(_DWORD *)(*(void *)(v43 + 104) + 592);
            if (__darwin_check_fd_set_overflow(v44, &v54, 0)
              && ((*(unsigned int *)((char *)v54.fds_bits + (((unint64_t)v44 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v44) & 1) != 0)
            {
              while ((int)_libssh2_transport_read(*(void *)(*(void *)v42 + 104)) > 0)
                ;
            }
            break;
          case 1:
            uint64_t v32 = a1 + 32 * v30;
            int v35 = *(_DWORD *)(v32 + 8);
            uint64_t v33 = (int *)(v32 + 8);
            int v34 = v35;
            if (__darwin_check_fd_set_overflow(v35, &v54, 0)
              && ((*(unsigned int *)((char *)v54.fds_bits + (((unint64_t)v34 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v34) & 1) != 0)
            {
              *(void *)(a1 + 32 * v30 + 24) |= 1uLL;
            }
            int v36 = *v33;
            if (__darwin_check_fd_set_overflow(*v33, &v53, 0)
              && ((*(unsigned int *)((char *)v53.fds_bits + (((unint64_t)v36 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v36) & 1) != 0)
            {
              *(void *)(a1 + 32 * v30 + 24) |= 4uLL;
            }
            if (*(void *)(a1 + 32 * v30 + 24)) {
              uint64_t v17 = (v17 + 1);
            }
            else {
              uint64_t v17 = v17;
            }
            break;
        }
        ++v30;
      }
      while (v30 != a2);
    }
    a3 = a3 - 1000 * (tv_sec - v27) + (tv_usec - v29) / -1000;
    BOOL v45 = a3 >= 1 && v17 == 0;
    unsigned int v16 = a2;
  }
  while (v45);
  return v17;
}

uint64_t libssh2_session_banner_get(uint64_t result)
{
  if (result) {
    return *(void *)(result + 312);
  }
  return result;
}

char ***_libssh2_comp_methods(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 136)) {
    return &comp_methods;
  }
  else {
    return &no_comp_methods;
  }
}

uint64_t comp_method_none_comp()
{
  return 0;
}

uint64_t comp_method_none_decomp(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *a2 = a5;
  *a3 = a6;
  return 0;
}

uint64_t libssh2_userauth_list(uint64_t a1, const void *a2, unsigned int a3)
{
  uint64_t v5 = a1 + 72048;
  time_t v6 = time(0);
  size_t v7 = a3 + 27;
  int v8 = (size_t *)(a1 + 72064);
  int v9 = (void **)(a1 + 72056);
  do
  {
    int v30 = 3486516;
    __darwin_suseconds_t v29 = 0;
    int v10 = *(_DWORD *)v5;
    if (*(_DWORD *)v5 == 3) {
      goto LABEL_13;
    }
    if (v10 == 2) {
      goto LABEL_7;
    }
    if (v10) {
      goto LABEL_36;
    }
    *(void *)(a1 + 72080) = 0;
    *int v8 = v7;
    uint64_t v11 = (*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v7, a1);
    *int v9 = (void *)v11;
    if (v11)
    {
      __darwin_suseconds_t v29 = (_DWORD *)(v11 + 1);
      *(unsigned char *)uint64_t v11 = 50;
      _libssh2_store_str(&v29, a2, a3);
      _libssh2_store_str(&v29, "ssh-connection", 0xEuLL);
      _libssh2_store_u32(&v29, 4u);
      *(_DWORD *)uint64_t v5 = 2;
LABEL_7:
      int v12 = _libssh2_transport_send(a1, *v9, *v8, "none", 4uLL);
      if (v12 == -37)
      {
        uint64_t v13 = a1;
        uint64_t v14 = 4294967259;
      }
      else
      {
        int v15 = v12;
        (*(void (**)(void *, uint64_t))(a1 + 24))(*v9, a1);
        *int v9 = 0;
        if (v15)
        {
          uint64_t v16 = a1;
          uint64_t v14 = 4294967289;
          uint64_t v17 = "Unable to send userauth-none request";
          goto LABEL_30;
        }
        *(_DWORD *)uint64_t v5 = 3;
LABEL_13:
        uint64_t v14 = _libssh2_packet_requirev(a1, (char *)&v30, (void *)(a1 + 72056), (unint64_t *)(a1 + 72064), 0, 0, 0, (time_t *)(a1 + 72080));
        if (!v14)
        {
          size_t v20 = *v8;
          if (!*v8) {
            goto LABEL_29;
          }
          uint64_t v21 = (char *)*v9;
          int v22 = *(unsigned __int8 *)*v9;
          if (v22 != 53) {
            goto LABEL_27;
          }
          if (v20 <= 4) {
            goto LABEL_33;
          }
          unsigned int v23 = _libssh2_ntohu32((unsigned int *)(v21 + 1));
          if (*v8 - 5 < v23)
          {
            (*(void (**)(void *, uint64_t))(a1 + 24))(*v9, a1);
            *int v9 = 0;
            uint64_t v13 = a1;
            uint64_t v14 = 4294967255;
            uint64_t v18 = "Unexpected userauth banner size";
            goto LABEL_17;
          }
          size_t v24 = v23;
          int v25 = (void *)(*(uint64_t (**)(void, uint64_t))(a1 + 8))(v23 + 1, a1);
          *(void *)(v5 + 24) = v25;
          if (!v25)
          {
            (*(void (**)(void *, uint64_t))(a1 + 24))(*v9, a1);
            *int v9 = 0;
            uint64_t v13 = a1;
            uint64_t v14 = 4294967290;
            uint64_t v18 = "Unable to allocate memory for userauth_banner";
            goto LABEL_17;
          }
          memcpy(v25, (const void *)(*(void *)(v5 + 8) + 5), v24);
          *(unsigned char *)(*(void *)(v5 + 24) + v24) = 0;
          (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v5 + 8), a1);
          *(void *)(v5 + 8) = 0;
          BYTE2(v30) = 0;
          uint64_t v14 = _libssh2_packet_requirev(a1, (char *)&v30, (void *)(a1 + 72056), (unint64_t *)(a1 + 72064), 0, 0, 0, (time_t *)(a1 + 72080));
          if (!v14)
          {
            size_t v20 = *v8;
            if (*v8)
            {
              uint64_t v21 = (char *)*v9;
              int v22 = *(unsigned __int8 *)*v9;
LABEL_27:
              if (v22 != 52)
              {
                if (v20 > 4)
                {
                  unsigned int v26 = _libssh2_ntohu32((unsigned int *)(v21 + 1));
                  if (*v8 - 5 > v26)
                  {
                    uint64_t v27 = v26;
                    memmove(*v9, (char *)*v9 + 5, v26);
                    *((unsigned char *)*v9 + v27) = 0;
LABEL_36:
                    *(_DWORD *)uint64_t v5 = 0;
                    uint64_t result = *(void *)(v5 + 8);
                    goto LABEL_37;
                  }
                  uint64_t v13 = a1;
                  uint64_t v14 = 4294967255;
                  uint64_t v18 = "Unexpected userauth list size";
                  goto LABEL_17;
                }
LABEL_33:
                (*(void (**)(void))(a1 + 24))();
                *int v9 = 0;
                uint64_t v13 = a1;
                uint64_t v14 = 4294967282;
                uint64_t v18 = "Unexpected packet size";
                goto LABEL_17;
              }
              _libssh2_error(a1, 0, "No error");
              (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v5 + 8), a1);
              uint64_t result = 0;
              *(void *)(v5 + 8) = 0;
              *(_DWORD *)(a1 + 128) |= 4u;
LABEL_31:
              *(_DWORD *)uint64_t v5 = 0;
              goto LABEL_37;
            }
LABEL_29:
            uint64_t v16 = a1;
            uint64_t v17 = "Failed getting response";
LABEL_30:
            _libssh2_error(v16, v14, v17);
            uint64_t result = 0;
            goto LABEL_31;
          }
        }
        if (v14 != -37) {
          goto LABEL_29;
        }
        uint64_t v13 = a1;
      }
      uint64_t v18 = "Would block requesting userauth list";
      goto LABEL_17;
    }
    uint64_t v13 = a1;
    uint64_t v14 = 4294967290;
    uint64_t v18 = "Unable to allocate memory for userauth_list";
LABEL_17:
    _libssh2_error(v13, v14, v18);
    uint64_t result = 0;
LABEL_37:
    if (!*(_DWORD *)(a1 + 172) || result) {
      return result;
    }
  }
  while (libssh2_session_last_errno(a1) == -37 && !_libssh2_wait_socket(a1, v6));
  return 0;
}

uint64_t libssh2_userauth_banner(uint64_t a1, void *a2)
{
  if (!a1) {
    return 4294967246;
  }
  uint64_t v2 = *(void *)(a1 + 72072);
  if (!v2) {
    return _libssh2_error(a1, 4294967246, "Missing userauth banner");
  }
  uint64_t result = 0;
  if (a2) {
    *a2 = v2;
  }
  return result;
}

uint64_t libssh2_userauth_authenticated(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 128) >> 2) & 1;
}

uint64_t libssh2_userauth_password_ex(uint64_t a1, const void *a2, unsigned int a3, const void *a4, unsigned int a5, void (*a6)(uint64_t, const void **, int *, uint64_t))
{
  uint64_t v10 = a1 + 72088;
  time_t v11 = time(0);
  uint64_t v12 = a3 + 40;
  uint64_t v13 = (size_t *)(a1 + 72112);
  uint64_t v14 = (void **)(a1 + 72096);
  unint64_t v40 = a3;
  size_t v15 = a5;
  uint64_t v37 = (int *)(a1 + 72128);
  uint64_t v38 = (const void **)(a1 + 72120);
  size_t v36 = a3 + a5 + 44;
  while (1)
  {
    uint64_t v42 = 0;
    int v16 = *(_DWORD *)v10;
    if (*(_DWORD *)v10 == 2) {
      goto LABEL_6;
    }
    if (!v16)
    {
      *(void *)(v10 + 48) = 0;
      *(void *)(v10 + 24) = v12;
      *(unsigned char *)(v10 + 16) = -61;
      uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(v12, a1);
      *(void *)(v10 + 8) = v17;
      if (v17)
      {
        uint64_t v42 = (_DWORD *)(v17 + 1);
        *(unsigned char *)uint64_t v17 = 50;
        _libssh2_store_str(&v42, a2, v40);
        _libssh2_store_str(&v42, "ssh-connection", 0xEuLL);
        _libssh2_store_str(&v42, "password", 8uLL);
        uint64_t v18 = v42;
        uint64_t v42 = (_DWORD *)((char *)v42 + 1);
        *uint64_t v18 = 0;
        _libssh2_store_u32(&v42, a5);
        *(_DWORD *)uint64_t v10 = 2;
LABEL_6:
        int v19 = _libssh2_transport_send(a1, *v14, *v13, a4, v15);
        if (v19 == -37)
        {
          uint64_t v20 = a1;
          uint64_t v21 = 4294967259;
          int v22 = "Would block writing password request";
        }
        else
        {
          int v26 = v19;
          (*(void (**)(void *, uint64_t))(a1 + 24))(*v14, a1);
          *uint64_t v14 = 0;
          if (!v26) {
            goto LABEL_47;
          }
          *(_DWORD *)uint64_t v10 = 0;
          uint64_t v20 = a1;
          uint64_t v21 = 4294967289;
          int v22 = "Unable to send userauth-password request";
        }
      }
      else
      {
        uint64_t v20 = a1;
        uint64_t v21 = 4294967290;
        int v22 = "Unable to allocate memory for userauth-password request";
      }
LABEL_36:
      uint64_t result = _libssh2_error(v20, v21, v22);
      goto LABEL_37;
    }
    if ((v16 - 3) >= 3)
    {
      size_t v24 = *v14;
LABEL_19:
      (*(void (**)(unsigned char *, uint64_t))(a1 + 24))(v24, a1);
      *(void *)(v10 + 8) = 0;
      *(_DWORD *)uint64_t v10 = 0;
      uint64_t v20 = a1;
      uint64_t v21 = 4294967278;
      int v22 = "Authentication failed";
      goto LABEL_36;
    }
    while (1)
    {
      if (v16 == 3)
      {
        uint64_t v23 = _libssh2_packet_requirev(a1, "43<", (void *)(a1 + 72096), (unint64_t *)(a1 + 72112), 0, 0, 0, (time_t *)(a1 + 72136));
        uint64_t v21 = v23;
        if (v23 == -37) {
          goto LABEL_35;
        }
        if (v23)
        {
          *(_DWORD *)uint64_t v10 = 0;
LABEL_35:
          uint64_t v20 = a1;
          int v22 = "Waiting for password response";
          goto LABEL_36;
        }
        if (!*v13) {
          goto LABEL_33;
        }
        size_t v24 = *v14;
        int v25 = *(unsigned __int8 *)*v14;
        if (v25 == 51)
        {
          (*(void (**)(void *, uint64_t))(a1 + 24))(*v14, a1);
          *(void *)(v10 + 8) = 0;
          *(_DWORD *)uint64_t v10 = 0;
          uint64_t v20 = a1;
          uint64_t v21 = 4294967278;
          int v22 = "Authentication failed (username/password)";
          goto LABEL_36;
        }
        if (v25 == 52)
        {
          (*(void (**)(void *, uint64_t))(a1 + 24))(*v14, a1);
          uint64_t result = 0;
          *(void *)(v10 + 8) = 0;
          *(_DWORD *)(a1 + 128) |= 4u;
          *(_DWORD *)uint64_t v10 = 0;
          return result;
        }
        *(void *)(v10 + 32) = 0;
        *(_DWORD *)(v10 + 40) = 0;
        int v16 = 4;
        *(_DWORD *)uint64_t v10 = 4;
      }
      else
      {
        if (!*v13)
        {
LABEL_33:
          *(_DWORD *)uint64_t v10 = 0;
          uint64_t v20 = a1;
          uint64_t v21 = 4294967282;
          int v22 = "Unexpected packet size";
          goto LABEL_36;
        }
        size_t v24 = *v14;
      }
      if (*v24 != 60 && *(unsigned char *)(v10 + 16) != 60) {
        goto LABEL_19;
      }
      *(unsigned char *)(v10 + 16) = 60;
      if (v16 == 4)
      {
        (*(void (**)(unsigned char *, uint64_t))(a1 + 24))(v24, a1);
        size_t v24 = 0;
        *uint64_t v14 = 0;
      }
      if (!a6) {
        goto LABEL_19;
      }
      if (*(_DWORD *)v10 == 5)
      {
        unsigned int v35 = a5;
      }
      else
      {
        if (*(_DWORD *)v10 != 4) {
          goto LABEL_19;
        }
        a6(a1, v38, v37, a1);
        if (!*v38)
        {
          uint64_t v20 = a1;
          uint64_t v21 = 4294967281;
          int v22 = "Password expired, and callback failed";
          goto LABEL_36;
        }
        unsigned int v35 = a5;
        *uint64_t v13 = v36;
        uint64_t v27 = (_DWORD *)(*(uint64_t (**)(void))(a1 + 8))();
        *uint64_t v14 = v27;
        uint64_t v42 = v27;
        if (!v27)
        {
          (*(void (**)(const void *, uint64_t))(a1 + 24))(*v38, a1);
          *uint64_t v38 = 0;
          uint64_t v31 = a1;
          uint64_t v32 = 4294967290;
          uint64_t v33 = "Unable to allocate memory for userauth password change request";
          goto LABEL_50;
        }
        uint64_t v42 = (_DWORD *)((char *)v27 + 1);
        *(unsigned char *)uint64_t v27 = 50;
        _libssh2_store_str(&v42, a2, v40);
        _libssh2_store_str(&v42, "ssh-connection", 0xEuLL);
        _libssh2_store_str(&v42, "password", 8uLL);
        uint64_t v28 = v42;
        uint64_t v42 = (_DWORD *)((char *)v42 + 1);
        *uint64_t v28 = 1;
        _libssh2_store_str(&v42, a4, v15);
        _libssh2_store_u32(&v42, *(_DWORD *)(v10 + 40));
        *(_DWORD *)uint64_t v10 = 5;
        size_t v24 = *(unsigned char **)(v10 + 8);
      }
      int v30 = _libssh2_transport_send(a1, v24, *v13, *v38, *v37);
      if (v30 == -37) {
        break;
      }
      int v34 = v30;
      (*(void (**)(void *, uint64_t))(a1 + 24))(*v14, a1);
      *uint64_t v14 = 0;
      (*(void (**)(const void *, uint64_t))(a1 + 24))(*v38, a1);
      *uint64_t v38 = 0;
      a5 = v35;
      if (v34)
      {
        uint64_t v20 = a1;
        uint64_t v21 = 4294967289;
        int v22 = "Unable to send userauth password-change request";
        goto LABEL_36;
      }
LABEL_47:
      int v16 = 3;
      *(_DWORD *)uint64_t v10 = 3;
    }
    uint64_t v31 = a1;
    uint64_t v32 = 4294967259;
    uint64_t v33 = "Would block waiting";
LABEL_50:
    uint64_t result = _libssh2_error(v31, v32, v33);
    a5 = v35;
LABEL_37:
    if (result != -37) {
      return result;
    }
    if (!*(_DWORD *)(a1 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(a1, v11);
    if (result) {
      return result;
    }
  }
}

uint64_t libssh2_sign_sk(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5, unsigned int **a6)
{
  time_t v6 = *a6;
  uint64_t v23 = 0;
  long long v21 = 0u;
  long long v22 = 0u;
  uint64_t v7 = *((void *)v6 + 3);
  if (!v7) {
    return 4294967284;
  }
  uint64_t v11 = (*((uint64_t (**)(uint64_t, long long *, uint64_t, uint64_t, void, void, void, void, uint64_t, void))v6
         + 4))(a1, &v21, a4, a5, *v6, *((unsigned __int8 *)v6 + 4), *((void *)v6 + 1), *((void *)v6 + 2), v7, *((void *)v6 + 5));
  if (v11) {
    BOOL v12 = 1;
  }
  else {
    BOOL v12 = (void)v22 == 0;
  }
  if (v12 || *((void *)&v21 + 1) == 0)
  {
    uint64_t v14 = v11;
    *a3 = 0;
    return v14;
  }
  uint64_t v20 = 0;
  if (!v23 || !*((void *)&v22 + 1))
  {
    *a3 = v22 + 9;
    uint64_t v17 = (_DWORD *)(*(uint64_t (**)(void))(a1 + 8))();
    *a2 = v17;
    if (v17)
    {
      uint64_t v20 = v17;
      _libssh2_store_str(&v20, *((const void **)&v21 + 1), v22);
      goto LABEL_18;
    }
LABEL_19:
    uint64_t v14 = 4294967290;
    goto LABEL_20;
  }
  *a3 = v22 + v23 + 19;
  size_t v15 = (_DWORD *)(*(uint64_t (**)(void))(a1 + 8))();
  *a2 = v15;
  if (!v15) {
    goto LABEL_19;
  }
  int v19 = v15;
  uint64_t v20 = v15;
  _libssh2_store_u32(&v20, 0);
  _libssh2_store_bignum2_bytes(&v20, *((unsigned char **)&v21 + 1), v22);
  _libssh2_store_bignum2_bytes(&v20, *((unsigned char **)&v22 + 1), v23);
  int v16 = (char *)v20 - *a2;
  *a3 = v16;
  _libssh2_store_u32(&v19, v16 - 4);
LABEL_18:
  uint64_t v14 = 0;
LABEL_20:
  if (v20)
  {
    *(unsigned char *)uint64_t v20 = v21;
    uint64_t v20 = (_DWORD *)((char *)v20 + 1);
    _libssh2_store_u32(&v20, DWORD1(v21));
    *a3 = (char *)v20 - *a2;
  }
  (*(void (**)(void, uint64_t))(a1 + 24))(*((void *)&v21 + 1), a1);
  if (*((void *)&v22 + 1)) {
    (*(void (**)(void, uint64_t))(a1 + 24))(*((void *)&v22 + 1), a1);
  }
  return v14;
}

uint64_t libssh2_userauth_hostbased_fromfile_ex(uint64_t a1, const void *a2, unsigned int a3, char *a4, char *a5, void *a6, const void *a7, unsigned int a8, const void *a9, unsigned int a10)
{
  v61[8] = *MEMORY[0x263EF8340];
  uint64_t v14 = a1 + 72144;
  time_t v15 = time(0);
  unint64_t v16 = a8;
  uint64_t v17 = (const void **)(a1 + 72184);
  uint64_t v18 = (unint64_t *)(a1 + 72192);
  unint64_t v47 = v16;
  unint64_t v48 = a3;
  unint64_t v51 = v16 + a3 + a10;
  int v19 = (void *)(a1 + 72152);
  while (1)
  {
    int v20 = *(_DWORD *)v14;
    if (*(_DWORD *)v14 == 3) {
      goto LABEL_32;
    }
    if (v20 == 2) {
      goto LABEL_28;
    }
    if (v20)
    {
      size_t v24 = (unsigned char *)*v19;
      goto LABEL_8;
    }
    uint64_t v59 = 0;
    uint64_t v60 = 0;
    unint64_t v57 = 0;
    uint64_t v58 = 0;
    uint64_t v55 = 0;
    unint64_t v56 = 0;
    *(void *)(a1 + 72208) = 0;
    long long v21 = (char **)(a1 + 72184);
    long long v22 = (size_t *)(a1 + 72192);
    if (a4) {
      uint64_t v23 = file_read_publickey(a1, v21, v22, &v59, &v57, a4);
    }
    else {
      uint64_t v23 = _libssh2_pub_priv_keyfile(a1, (const char **)v21, v22, &v59, (uint64_t *)&v57, a5, a6);
    }
    uint64_t v28 = v23;
    if (!v23)
    {
      uint64_t v29 = *(void *)(v14 + 48);
      unint64_t v30 = v57;
      unint64_t v31 = v51 + v29 + v57;
      *(void *)(v14 + 32) = v31 + 52;
      uint64_t v32 = (unsigned char *)(*(uint64_t (**)(unint64_t, uint64_t))(a1 + 8))(v30 + v29 + v31 + 64, a1);
      *(void *)(v14 + 24) = v32;
      *(void *)(v14 + 56) = v32;
      if (!v32)
      {
        (*(void (**)(const void *, uint64_t))(a1 + 24))(*v17, a1);
        *uint64_t v17 = 0;
        (*(void (**)(const void *, uint64_t))(a1 + 24))(v59, a1);
        uint64_t v25 = a1;
        uint64_t v26 = 4294967290;
        uint64_t v27 = "Out of memory";
        goto LABEL_39;
      }
      *(void *)(a1 + 72200) = v32 + 1;
      *uint64_t v32 = 50;
      _libssh2_store_str((_DWORD **)(a1 + 72200), a2, v48);
      _libssh2_store_str((_DWORD **)(a1 + 72200), "ssh-connection", 0xEuLL);
      _libssh2_store_str((_DWORD **)(a1 + 72200), "hostbased", 9uLL);
      _libssh2_store_str((_DWORD **)(a1 + 72200), *v17, *v18);
      _libssh2_store_str((_DWORD **)(a1 + 72200), v59, v57);
      (*(void (**)(const void *, uint64_t))(a1 + 24))(v59, a1);
      _libssh2_store_str((_DWORD **)(a1 + 72200), a7, v47);
      _libssh2_store_str((_DWORD **)(a1 + 72200), a9, a10);
      uint64_t v33 = file_read_privatekey(a1, &v60, &v55, (const char *)*v17, *v18, (uint64_t)a5, (uint64_t)a6);
      if (v33)
      {
        uint64_t v28 = v33;
        (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v14 + 40), a1);
        *(void *)(v14 + 40) = 0;
        (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v14 + 24), a1);
        *(void *)(v14 + 24) = 0;
        goto LABEL_40;
      }
      _libssh2_htonu32(&v54, *(_DWORD *)(a1 + 168));
      v61[0] = (unint64_t)&v54;
      v61[1] = 4;
      unint64_t v34 = *(unsigned int *)(a1 + 168);
      v61[2] = *(void *)(a1 + 160);
      v61[3] = v34;
      unint64_t v35 = *(void *)(v14 + 32);
      v61[4] = *(void *)(v14 + 24);
      v61[5] = v35;
      size_t v36 = v60;
      if (!v60) {
        goto LABEL_23;
      }
      uint64_t v37 = v60[6];
      if (!v37
        || !((unsigned int (*)(uint64_t, const void **, unint64_t *, uint64_t, unint64_t *, uint64_t *))v37)(a1, &v58, &v56, 3, v61, &v55))
      {
        uint64_t v39 = v36[8];
        if (v39) {
          ((void (*)(uint64_t, uint64_t *))v39)(a1, &v55);
        }
LABEL_23:
        int v40 = v56;
        uint64_t v41 = *(void *)(v14 + 24);
        if (v56 > v57)
        {
          unint64_t v42 = v56 + *(void *)(v14 + 32) + *(void *)(v14 + 48) + 12;
          if (v41)
          {
            uint64_t v41 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(a1 + 16))(v41, v42, a1);
            if (v41) {
              goto LABEL_26;
            }
LABEL_45:
            (*(void (**)(const void *, uint64_t))(a1 + 24))(v58, a1);
            (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v14 + 24), a1);
            *(void *)(v14 + 24) = 0;
            (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v14 + 40), a1);
            *(void *)(v14 + 40) = 0;
            uint64_t v25 = a1;
            uint64_t v26 = 4294967290;
            uint64_t v27 = "Failed allocating additional space for userauth-hostbased packet";
LABEL_39:
            uint64_t v28 = _libssh2_error(v25, v26, v27);
            goto LABEL_40;
          }
          uint64_t v41 = (*(uint64_t (**)(unint64_t, uint64_t))(a1 + 8))(v42, a1);
          if (!v41) {
            goto LABEL_45;
          }
LABEL_26:
          *(void *)(v14 + 24) = v41;
          int v40 = v56;
        }
        *(void *)(v14 + 56) = v41 + *(void *)(v14 + 32);
        _libssh2_store_u32((_DWORD **)(a1 + 72200), v40 + *(_DWORD *)(v14 + 48) + 8);
        _libssh2_store_str((_DWORD **)(a1 + 72200), *(const void **)(v14 + 40), *(void *)(v14 + 48));
        (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v14 + 40), a1);
        *(void *)(v14 + 40) = 0;
        _libssh2_store_str((_DWORD **)(a1 + 72200), v58, v56);
        (*(void (**)(const void *, uint64_t))(a1 + 24))(v58, a1);
        *(_DWORD *)uint64_t v14 = 2;
LABEL_28:
        int v43 = _libssh2_transport_send(a1, *(void **)(v14 + 24), *(void *)(v14 + 56) - *(void *)(v14 + 24), 0, 0);
        if (v43)
        {
          if (v43 != -37)
          {
            (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v14 + 24), a1);
            *(void *)(v14 + 24) = 0;
            *(_DWORD *)uint64_t v14 = 0;
            uint64_t v25 = a1;
            uint64_t v26 = 4294967289;
            uint64_t v27 = "Unable to send userauth-hostbased request";
            goto LABEL_39;
          }
LABEL_33:
          uint64_t v25 = a1;
          uint64_t v26 = 4294967259;
          uint64_t v27 = "Would block";
          goto LABEL_39;
        }
        (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v14 + 24), a1);
        *(void *)(v14 + 24) = 0;
        *(_DWORD *)uint64_t v14 = 3;
LABEL_32:
        v61[0] = 0;
        int v44 = _libssh2_packet_requirev(a1, "43", (void *)(a1 + 72152), v61, 0, 0, 0, (time_t *)(a1 + 72208));
        if (v44 == -37) {
          goto LABEL_33;
        }
        *(_DWORD *)uint64_t v14 = 0;
        if (v44 || !v61[0])
        {
          uint64_t v25 = a1;
          uint64_t v26 = 4294967277;
          uint64_t v27 = "Auth failed";
          goto LABEL_39;
        }
        size_t v24 = (unsigned char *)*v19;
        if (*(unsigned char *)*v19 == 52)
        {
          (*(void (**)(void))(a1 + 24))();
          uint64_t v28 = 0;
          *int v19 = 0;
          *(_DWORD *)(a1 + 128) |= 4u;
          goto LABEL_40;
        }
LABEL_8:
        (*(void (**)(unsigned char *, uint64_t))(a1 + 24))(v24, a1);
        *int v19 = 0;
        uint64_t v25 = a1;
        uint64_t v26 = 4294967277;
        uint64_t v27 = "Invalid signature for supplied public key, or bad username/public key combination";
        goto LABEL_39;
      }
      (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v14 + 40), a1);
      *(void *)(v14 + 40) = 0;
      (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v14 + 24), a1);
      *(void *)(v14 + 24) = 0;
      uint64_t v38 = v36[8];
      if (v38) {
        ((void (*)(uint64_t, uint64_t *))v38)(a1, &v55);
      }
      uint64_t v28 = 0xFFFFFFFFLL;
    }
LABEL_40:
    if (v28 != -37) {
      return v28;
    }
    if (!*(_DWORD *)(a1 + 172)) {
      return 4294967259;
    }
    uint64_t v45 = _libssh2_wait_socket(a1, v15);
    if (v45) {
      return v45;
    }
  }
}

size_t plain_method(char *__s2, size_t __n)
{
  size_t v2 = __n;
  if (!strncmp("ssh-rsa-cert-v01@openssh.com", __s2, __n)) {
    return 7;
  }
  if (!strncmp("ecdsa-sha2-nistp256-cert-v01@openssh.com", __s2, v2)
    || !strncmp("ecdsa-sha2-nistp384-cert-v01@openssh.com", __s2, v2)
    || !strncmp("ecdsa-sha2-nistp521-cert-v01@openssh.com", __s2, v2))
  {
    return 19;
  }
  if (!strncmp("ssh-ed25519-cert-v01@openssh.com", __s2, v2)) {
    return 11;
  }
  if (!strncmp("sk-ecdsa-sha2-nistp256-cert-v01@openssh.com", __s2, v2))
  {
    qmemcpy(__s2, "sk-ecdsa-sha2-nistp256@openssh.com", 34);
    return 34;
  }
  else if (!strncmp("sk-ssh-ed25519-cert-v01@openssh.com", __s2, v2))
  {
    qmemcpy(__s2, "sk-ssh-ed25519@openssh.com", 26);
    return 26;
  }
  return v2;
}

uint64_t _libssh2_userauth_publickey(uint64_t a1, const void *a2, unint64_t a3, unsigned int *a4, size_t a5, uint64_t (*a6)(uint64_t, const void **, size_t *, char *, int64_t, uint64_t), uint64_t a7)
{
  uint64_t v7 = a7;
  size_t v8 = a5;
  uint64_t v10 = a1 + 72216;
  *(_DWORD *)id v87 = 3945268;
  uint64_t v86 = 0;
  uint64_t v11 = (time_t *)(a1 + 72288);
  __src = a4 + 1;
  unint64_t v73 = a5 - 4;
  size_t v79 = a5 + a3;
  size_t v78 = a5 + 57;
  BOOL v12 = (void *)(a1 + 72224);
  uint64_t v13 = (unint64_t *)(a1 + 72232);
  int v14 = *(_DWORD *)(a1 + 72216);
  char v83 = 1;
  while (2)
  {
    switch(v14)
    {
      case 0:
        if (v8 <= 3)
        {
          unint64_t v56 = "Invalid public key, too short";
          goto LABEL_115;
        }
        *(void *)(v10 + 72) = 0;
        if (!*(void *)(v10 + 40))
        {
          unsigned int v15 = _libssh2_ntohu32(a4);
          *(void *)(v10 + 48) = v15;
          if (v73 < v15)
          {
            unint64_t v56 = "Invalid public key";
            goto LABEL_115;
          }
          unint64_t v16 = (void *)(*(uint64_t (**)(void))(a1 + 8))();
          *(void *)(v10 + 40) = v16;
          if (!v16)
          {
            unint64_t v56 = "Unable to allocate memory for public key data";
            goto LABEL_117;
          }
          memcpy(v16, __src, *(void *)(v10 + 48));
        }
        unint64_t v74 = v8;
        uint64_t v75 = v13;
        if ((v83 & 1) == 0) {
          goto LABEL_62;
        }
        uint64_t v17 = _libssh2_supported_key_sign_algorithms(a1, *(_DWORD **)(v10 + 40), *(void *)(v10 + 48));
        if (!v17 || !*(void *)(a1 + 296)) {
          goto LABEL_62;
        }
        uint64_t v18 = (char *)v17;
        size_t v19 = strlen(v17);
        uint64_t v20 = (*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v19 + 1, a1);
        if (!v20)
        {
          uint64_t v46 = _libssh2_error(a1, 4294967290, "Unable to allocate filtered algs");
          goto LABEL_61;
        }
        uint64_t v68 = v11;
        uint64_t v70 = v10;
        long long v21 = *(char **)(a1 + 296);
        long long v22 = (char *)v20;
        uint64_t v23 = (char *)v20;
        if (v21)
        {
          long long v22 = (char *)v20;
          do
          {
            if (!*v21) {
              break;
            }
            size_t v24 = strchr(v21, 44);
            uint64_t v25 = v24;
            size_t v26 = v24 ? v24 - v21 : strlen(v21);
            uint64_t v27 = v18;
            do
            {
              if (!*v27) {
                break;
              }
              uint64_t v28 = strchr(v27, 44);
              uint64_t v29 = v28;
              if (v28) {
                size_t v30 = v28 - v27;
              }
              else {
                size_t v30 = strlen(v27);
              }
              if (v30 == v26 && !memcmp(v27, v21, v26))
              {
                unint64_t v31 = v23;
                if (v22 != v23)
                {
                  char *v22 = 44;
                  unint64_t v31 = v22 + 1;
                }
                memcpy(v31, v21, v26);
                long long v22 = &v31[v26];
              }
              uint64_t v27 = v29 + 1;
            }
            while (v29);
            long long v21 = v25 + 1;
          }
          while (v25);
        }
        uint64_t v69 = v12;
        size_t v32 = 0;
        uint64_t v33 = 0;
        char *v22 = 0;
        if (*(void *)(a1 + 304)) {
          unint64_t v34 = *(char **)(a1 + 304);
        }
        else {
          unint64_t v34 = v18;
        }
        id v80 = (unsigned __int8 *)v23;
        break;
      case 2:
LABEL_64:
        int v50 = _libssh2_transport_send(a1, *(void **)(v10 + 24), *(void *)(v10 + 32), 0, 0);
        if (v50)
        {
          if (v50 == -37) {
            goto LABEL_103;
          }
          (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v10 + 24), a1);
          *(void *)(v10 + 24) = 0;
          (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v10 + 40), a1);
          *(void *)(v10 + 40) = 0;
          goto LABEL_110;
        }
        *(_DWORD *)uint64_t v10 = 3;
LABEL_66:
        int v51 = _libssh2_packet_requirev(a1, v87, v12, v13, 0, 0, 0, v11);
        if (v51)
        {
          if (v51 != -37)
          {
LABEL_76:
            (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v10 + 24), a1);
            *(void *)(v10 + 24) = 0;
            (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v10 + 40), a1);
            *(void *)(v10 + 40) = 0;
            *(_DWORD *)uint64_t v10 = 0;
            unint64_t v56 = "Waiting for USERAUTH response";
            goto LABEL_115;
          }
LABEL_103:
          unint64_t v56 = "Would block";
LABEL_104:
          uint64_t v57 = a1;
          uint64_t v58 = 4294967259;
          return _libssh2_error(v57, v58, v56);
        }
        if (!*v13) {
          goto LABEL_76;
        }
        int v52 = *(unsigned __int8 *)*v12;
        if (v52 == 51)
        {
          (*(void (**)(void))(a1 + 24))();
          *(void *)(v10 + 8) = 0;
          (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v10 + 24), a1);
          *(void *)(v10 + 24) = 0;
          (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v10 + 40), a1);
          *(void *)(v10 + 40) = 0;
          *(_DWORD *)uint64_t v10 = 0;
          unint64_t v56 = "Username/PublicKey combination invalid";
          uint64_t v57 = a1;
          uint64_t v58 = 4294967278;
          return _libssh2_error(v57, v58, v56);
        }
        if (v52 == 52)
        {
          (*(void (**)(void))(a1 + 24))();
          *(void *)(v10 + 8) = 0;
          (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v10 + 24), a1);
          *(void *)(v10 + 24) = 0;
          (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v10 + 40), a1);
          uint64_t v46 = 0;
          *(void *)(v10 + 40) = 0;
LABEL_84:
          *(_DWORD *)(a1 + 128) |= 4u;
          *(_DWORD *)uint64_t v10 = 0;
          return v46;
        }
        (*(void (**)(void))(a1 + 24))();
        *(void *)(v10 + 8) = 0;
        **(unsigned char **)(v10 + 64) = 1;
        *(_DWORD *)uint64_t v10 = 4;
LABEL_71:
        size_t v84 = 0;
        uint64_t v85 = 0;
        fd_set v53 = (_DWORD *)(*(uint64_t (**)(void, uint64_t))(a1 + 8))(*(void *)(v10 + 32) + (*(_DWORD *)(a1 + 168) + 4), a1);
        uint64_t v86 = v53;
        if (!v53)
        {
          unint64_t v56 = "Unable to allocate memory for userauth-publickey signed data";
          goto LABEL_117;
        }
        int v54 = (char *)v53;
        _libssh2_store_str(&v86, *(const void **)(a1 + 160), *(unsigned int *)(a1 + 168));
        memcpy(v86, *(const void **)(v10 + 24), *(void *)(v10 + 32));
        uint64_t v86 = (_DWORD *)((char *)v86 + *(void *)(v10 + 32));
        int v55 = a6(a1, &v85, &v84, v54, (char *)v86 - v54, v7);
        (*(void (**)(char *, uint64_t))(a1 + 24))(v54, a1);
        if (v55 == -37) {
          goto LABEL_103;
        }
        if ((v83 & (v55 == -51)) == 0)
        {
          if (v55)
          {
            (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v10 + 40), a1);
            *(void *)(v10 + 40) = 0;
            (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v10 + 24), a1);
            *(void *)(v10 + 24) = 0;
            *(_DWORD *)uint64_t v10 = 0;
            unint64_t v56 = "Callback returned error";
            goto LABEL_115;
          }
          uint64_t v59 = *(void *)(v10 + 24);
          if (v84 > v8)
          {
            if (v59) {
              uint64_t v59 = (*(uint64_t (**)(uint64_t, size_t, uint64_t))(a1 + 16))(v59, v84 + *(void *)(v10 + 32) + *(void *)(v10 + 48) + 12, a1);
            }
            else {
              uint64_t v59 = (*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v84 + *(void *)(v10 + 32) + *(void *)(v10 + 48) + 12, a1);
            }
            if (v59)
            {
              *(void *)(v10 + 24) = v59;
              goto LABEL_96;
            }
            (*(void (**)(const void *, uint64_t))(a1 + 24))(v85, a1);
            (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v10 + 24), a1);
            *(void *)(v10 + 24) = 0;
            (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v10 + 40), a1);
            *(void *)(v10 + 40) = 0;
            *(_DWORD *)uint64_t v10 = 0;
            unint64_t v56 = "Failed allocating additional space for userauth-publickey packet";
LABEL_117:
            uint64_t v57 = a1;
            uint64_t v58 = 4294967290;
            return _libssh2_error(v57, v58, v56);
          }
LABEL_96:
          uint64_t v61 = *(char **)(v10 + 40);
          uint64_t v86 = (_DWORD *)(v59 + *(void *)(v10 + 32));
          *(void *)(v10 + 64) = 0;
          size_t v62 = plain_method(v61, *(void *)(v10 + 48));
          *(void *)(v10 + 48) = v62;
          uint64_t v63 = *(const char **)(v10 + 40);
          if (!strncmp(v63, "sk-ecdsa-sha2-nistp256@openssh.com", v62)
            || !strncmp(v63, "sk-ssh-ed25519@openssh.com", v62))
          {
            _libssh2_store_u32(&v86, v62 + v84 + 4);
            _libssh2_store_str(&v86, *(const void **)(v10 + 40), *(void *)(v10 + 48));
            memcpy(v86, v85, v84);
            uint64_t v86 = (_DWORD *)((char *)v86 + v84);
          }
          else
          {
            _libssh2_store_u32(&v86, v62 + v84 + 8);
            _libssh2_store_str(&v86, *(const void **)(v10 + 40), *(void *)(v10 + 48));
            _libssh2_store_str(&v86, v85, v84);
          }
          (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v10 + 40), a1);
          *(void *)(v10 + 40) = 0;
          (*(void (**)(const void *, uint64_t))(a1 + 24))(v85, a1);
          uint64_t v60 = v86;
          *(void *)(v10 + 56) = v86;
          *(_DWORD *)uint64_t v10 = 5;
LABEL_101:
          int v64 = _libssh2_transport_send(a1, *(void **)(v10 + 24), (size_t)v60 - *(void *)(v10 + 24), 0, 0);
          if (v64)
          {
            if (v64 == -37) {
              goto LABEL_103;
            }
            (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v10 + 24), a1);
            *(void *)(v10 + 24) = 0;
LABEL_110:
            *(_DWORD *)uint64_t v10 = 0;
            unint64_t v56 = "Unable to send userauth-publickey request";
            uint64_t v57 = a1;
            uint64_t v58 = 4294967289;
            return _libssh2_error(v57, v58, v56);
          }
          (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v10 + 24), a1);
          *(void *)(v10 + 24) = 0;
          *(_DWORD *)uint64_t v10 = 6;
LABEL_106:
          v87[2] = 0;
          int v65 = _libssh2_packet_requirev(a1, v87, v12, v13, 0, 0, 0, v11);
          if (v65)
          {
            if (v65 == -37)
            {
              unint64_t v56 = "Would block requesting userauth list";
              goto LABEL_104;
            }
LABEL_114:
            *(_DWORD *)uint64_t v10 = 0;
            unint64_t v56 = "Waiting for publickey USERAUTH response";
          }
          else
          {
            if (!*v13) {
              goto LABEL_114;
            }
            int v66 = *(unsigned __int8 *)*v12;
            (*(void (**)(void))(a1 + 24))();
            *BOOL v12 = 0;
            if (v66 == 52)
            {
              uint64_t v46 = 0;
              goto LABEL_84;
            }
            *(_DWORD *)uint64_t v10 = 0;
            unint64_t v56 = "Invalid signature for supplied public key, or bad username/public key combination";
          }
LABEL_115:
          uint64_t v57 = a1;
          uint64_t v58 = 4294967277;
          return _libssh2_error(v57, v58, v56);
        }
        (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v10 + 40), a1);
        *(void *)(v10 + 40) = 0;
        (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v10 + 24), a1);
        int v14 = 0;
        char v83 = 0;
        *(void *)(v10 + 24) = 0;
        *(_DWORD *)uint64_t v10 = 0;
        continue;
      case 3:
        goto LABEL_66;
      case 4:
        goto LABEL_71;
      case 5:
        uint64_t v60 = *(_DWORD **)(v10 + 56);
        goto LABEL_101;
      default:
        goto LABEL_106;
    }
    break;
  }
  do
  {
    if (v33 || !*v34) {
      break;
    }
    unint64_t v35 = strchr(v34, 44);
    size_t v36 = v35;
    if (v35) {
      size_t v37 = v35 - v34;
    }
    else {
      size_t v37 = strlen(v34);
    }
    uint64_t v38 = v23;
    int v39 = *v23;
    if (!v39)
    {
      uint64_t v33 = 0;
      goto LABEL_53;
    }
    size_t v40 = v32;
    while (1)
    {
      uint64_t v41 = strchr(v38, 44);
      unint64_t v42 = v41;
      if (v41) {
        size_t v43 = v41 - v38;
      }
      else {
        size_t v43 = strlen(v38);
      }
      if (v43 == v37)
      {
        uint64_t v33 = v34;
        size_t v32 = v37;
        if (!memcmp(v38, v34, v37)) {
          goto LABEL_48;
        }
      }
      uint64_t v33 = 0;
      if (!v42) {
        break;
      }
      int v39 = v42[1];
      uint64_t v38 = v42 + 1;
      size_t v32 = v40;
LABEL_48:
      if (!v33)
      {
        size_t v40 = v32;
        if (v39) {
          continue;
        }
      }
      goto LABEL_53;
    }
    size_t v32 = v40;
LABEL_53:
    unint64_t v34 = v36 + 1;
    uint64_t v23 = (char *)v80;
  }
  while (v36);
  if (v33)
  {
    uint64_t v10 = v70;
    uint64_t v44 = *(void *)(v70 + 40);
    if (v44) {
      (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v44, a1);
    }
    uint64_t v45 = (void *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v32, a1);
    *(void *)(v70 + 40) = v45;
    memcpy(v45, v33, v32);
    uint64_t v46 = 0;
    *(void *)(v70 + 48) = v32;
  }
  else
  {
    uint64_t v46 = _libssh2_error(a1, 4294967279, "No signing signature matched");
    uint64_t v10 = v70;
  }
  uint64_t v11 = v68;
  BOOL v12 = v69;
  uint64_t v7 = a7;
  (*(void (**)(unsigned __int8 *, uint64_t))(a1 + 24))(v80, a1);
LABEL_61:
  if (!v46)
  {
LABEL_62:
    uint64_t v47 = *(void *)(v10 + 48);
    *(void *)(v10 + 32) = v79 + v47 + 45;
    unint64_t v48 = (_DWORD *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v78 + v47 + v79 + v47, a1);
    *(void *)(v10 + 24) = v48;
    uint64_t v86 = v48;
    if (v48)
    {
      uint64_t v86 = (_DWORD *)((char *)v48 + 1);
      *(unsigned char *)unint64_t v48 = 50;
      _libssh2_store_str(&v86, a2, a3);
      _libssh2_store_str(&v86, "ssh-connection", 0xEuLL);
      _libssh2_store_str(&v86, "publickey", 9uLL);
      uint64_t v49 = v86;
      *(void *)(v10 + 64) = v86;
      uint64_t v86 = (_DWORD *)((char *)v49 + 1);
      *(unsigned char *)uint64_t v49 = 0;
      _libssh2_store_str(&v86, *(const void **)(v10 + 40), *(void *)(v10 + 48));
      size_t v8 = v74;
      _libssh2_store_str(&v86, a4, v74);
      *(_DWORD *)uint64_t v10 = 2;
      uint64_t v13 = v75;
      goto LABEL_64;
    }
    (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v10 + 40), a1);
    *(void *)(v10 + 40) = 0;
    unint64_t v56 = "Out of memory";
    goto LABEL_117;
  }
  return v46;
}

uint64_t libssh2_userauth_publickey_frommemory(uint64_t a1, const void *a2, unint64_t a3, const void *a4, size_t a5, void *a6, unint64_t a7, char *a8)
{
  if (a8) {
    unsigned int v15 = a8;
  }
  else {
    unsigned int v15 = "";
  }
  time_t v16 = time(0);
  size_t v26 = a4;
  size_t v27 = a5;
  if (a4) {
    BOOL v17 = a5 == 0;
  }
  else {
    BOOL v17 = 1;
  }
  int v18 = !v17;
  if (a6) {
    BOOL v19 = a7 == 0;
  }
  else {
    BOOL v19 = 1;
  }
  int v20 = !v19;
  int v25 = v20;
  uint64_t v28 = (size_t *)(a1 + 72264);
  uint64_t v29 = (char **)(a1 + 72256);
  while (1)
  {
    size_t v32 = 0;
    uint64_t v33 = 0;
    size_t v30 = v31;
    v31[0] = a6;
    v31[1] = v15;
    if (!*(_DWORD *)(a1 + 72216))
    {
      if (v18)
      {
        uint64_t v22 = memory_read_publickey(a1, v29, v28, &v33, &v32, v26, v27);
      }
      else
      {
        if (!v25)
        {
          uint64_t v21 = _libssh2_error(a1, 4294967280, "Invalid data in public and private key.");
          goto LABEL_27;
        }
        uint64_t v22 = _libssh2_pub_priv_keyfilememory(a1, (const char **)v29, v28, &v33, (uint64_t *)&v32, a6, a7, v15);
      }
      uint64_t v21 = v22;
      if (v22) {
        goto LABEL_27;
      }
    }
    uint64_t v21 = _libssh2_userauth_publickey(a1, a2, a3, v33, v32, (uint64_t (*)(uint64_t, const void **, size_t *, char *, int64_t, uint64_t))sign_frommemory, (uint64_t)&v30);
    if (v33) {
      (*(void (**)(unsigned int *, uint64_t))(a1 + 24))(v33, a1);
    }
LABEL_27:
    if (v21 != -37) {
      return v21;
    }
    if (!*(_DWORD *)(a1 + 172)) {
      return 4294967259;
    }
    uint64_t v23 = _libssh2_wait_socket(a1, v16);
    if (v23) {
      return v23;
    }
  }
}

uint64_t libssh2_userauth_publickey_fromfile_ex(uint64_t a1, const void *a2, unsigned int a3, char *a4, char *a5, char *a6)
{
  if (a6) {
    uint64_t v11 = a6;
  }
  else {
    uint64_t v11 = "";
  }
  time_t v12 = time(0);
  BOOL v17 = (size_t *)(a1 + 72264);
  int v18 = (const char **)(a1 + 72256);
  while (1)
  {
    size_t v21 = 0;
    uint64_t v22 = 0;
    BOOL v19 = v20;
    v20[0] = a5;
    v20[1] = v11;
    if (*(_DWORD *)(a1 + 72216)
      || (!a4
        ? (uint64_t v14 = _libssh2_pub_priv_keyfile(a1, v18, v17, &v22, (uint64_t *)&v21, a5, v11))
        : (uint64_t v14 = file_read_publickey(a1, (char **)v18, v17, &v22, &v21, a4)),
          uint64_t v13 = v14,
          !v14))
    {
      uint64_t v13 = _libssh2_userauth_publickey(a1, a2, a3, v22, v21, (uint64_t (*)(uint64_t, const void **, size_t *, char *, int64_t, uint64_t))sign_fromfile, (uint64_t)&v19);
      if (v22) {
        (*(void (**)(unsigned int *, uint64_t))(a1 + 24))(v22, a1);
      }
    }
    if (v13 != -37) {
      break;
    }
    if (!*(_DWORD *)(a1 + 172)) {
      return 4294967259;
    }
    uint64_t v15 = _libssh2_wait_socket(a1, v12);
    if (v15) {
      return v15;
    }
  }
  return v13;
}

uint64_t libssh2_userauth_publickey(uint64_t a1, const char *a2, unsigned int *a3, size_t a4, uint64_t (*a5)(uint64_t, const void **, size_t *, char *, int64_t, uint64_t), uint64_t a6)
{
  if (!a1) {
    return 4294967257;
  }
  time_t v12 = time(0);
  do
  {
    size_t v13 = strlen(a2);
    uint64_t result = _libssh2_userauth_publickey(a1, a2, v13, a3, a4, a5, a6);
    if (result != -37) {
      break;
    }
    if (!*(_DWORD *)(a1 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(a1, v12);
  }
  while (!result);
  return result;
}

uint64_t libssh2_userauth_keyboard_interactive_ex(uint64_t a1, const void *a2, unsigned int a3, void (*a4)(void, void, void, void, void, void, void, uint64_t))
{
  uint64_t v6 = a1 + 72296;
  time_t v7 = time(0);
  size_t v8 = (uint64_t *)(a1 + 72376);
  uint64_t v9 = a3 + 55;
  uint64_t v10 = (unsigned __int8 **)(a1 + 72304);
  unint64_t v41 = a3;
  do
  {
    size_t v43 = 0;
    int v11 = *(_DWORD *)v6;
    if (*(_DWORD *)v6 == 2) {
      goto LABEL_6;
    }
    if (v11)
    {
      while (1)
      {
        if (v11 == 4) {
          goto LABEL_30;
        }
        if (v11 == 3)
        {
          int v17 = _libssh2_packet_requirev(a1, "43<", (void *)(a1 + 72304), (unint64_t *)(a1 + 72312), 0, 0, 0, (time_t *)(a1 + 72392));
          if (v17)
          {
            if (v17 == -37) {
              goto LABEL_32;
            }
LABEL_33:
            *(_DWORD *)uint64_t v6 = 0;
            uint64_t v14 = a1;
            uint64_t v15 = 4294967278;
            time_t v16 = "Waiting for keyboard USERAUTH response";
            goto LABEL_34;
          }
          if (!*(void *)(a1 + 72312)) {
            goto LABEL_33;
          }
          int v18 = **v10;
          if (v18 == 51)
          {
            (*(void (**)(void))(a1 + 24))();
            *(void *)(v6 + 8) = 0;
            *(_DWORD *)uint64_t v6 = 0;
            uint64_t v14 = a1;
            uint64_t v15 = 4294967278;
            time_t v16 = "Authentication failed (keyboard-interactive)";
            goto LABEL_34;
          }
          if (v18 == 52)
          {
            (*(void (**)(void))(a1 + 24))();
            uint64_t result = 0;
            *uint64_t v10 = 0;
            *(_DWORD *)(a1 + 128) |= 4u;
LABEL_65:
            *(_DWORD *)uint64_t v6 = 0;
            return result;
          }
          if ((userauth_keyboard_interactive_decode_info_request((void *)a1) & 0x80000000) == 0) {
            break;
          }
        }
LABEL_41:
        (*(void (**)(void, uint64_t))(a1 + 24))(*v10, a1);
        uint64_t v32 = 0;
        *uint64_t v10 = 0;
        if (*v8)
        {
          if (*(_DWORD *)(v6 + 72))
          {
            uint64_t v33 = 0;
            unint64_t v34 = 0;
            uint64_t v32 = *v8;
            do
            {
              (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v32 + v33), a1);
              uint64_t v32 = *(void *)(v6 + 80);
              *(void *)(v32 + v33) = 0;
              ++v34;
              v33 += 24;
            }
            while (v34 < *(unsigned int *)(v6 + 72));
          }
          else
          {
            uint64_t v32 = *v8;
          }
        }
        uint64_t v35 = *(void *)(v6 + 88);
        if (v35 && *(_DWORD *)(v6 + 72))
        {
          uint64_t v36 = 0;
          unint64_t v37 = 0;
          do
          {
            (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v35 + v36), a1);
            uint64_t v35 = *(void *)(v6 + 88);
            *(void *)(v35 + v36) = 0;
            ++v37;
            v36 += 16;
          }
          while (v37 < *(unsigned int *)(v6 + 72));
          uint64_t v32 = *v8;
        }
        if (v32)
        {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v32, a1);
          *(void *)(v6 + 80) = 0;
          uint64_t v35 = *(void *)(v6 + 88);
        }
        if (v35)
        {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v35, a1);
          *(void *)(v6 + 88) = 0;
        }
        uint64_t v38 = *(void *)(v6 + 48);
        if (v38)
        {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v38, a1);
          *(void *)(v6 + 48) = 0;
        }
        uint64_t v39 = *(void *)(v6 + 64);
        if (v39)
        {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v39, a1);
          *(void *)(v6 + 64) = 0;
        }
        if (*(_DWORD *)(v6 + 76))
        {
          uint64_t result = 0xFFFFFFFFLL;
          goto LABEL_65;
        }
LABEL_11:
        int v11 = 3;
        *(_DWORD *)uint64_t v6 = 3;
      }
      a4(*(void *)(v6 + 48), *(unsigned int *)(v6 + 40), *(void *)(v6 + 64), *(unsigned int *)(v6 + 56), *(unsigned int *)(v6 + 72), *(void *)(v6 + 80), *(void *)(v6 + 88), a1);
      *(void *)(v6 + 32) = 5;
      uint64_t v19 = *(unsigned int *)(v6 + 72);
      if (v19)
      {
        int v20 = (unsigned int *)(*(void *)(v6 + 88) + 8);
        uint64_t v21 = 5;
        while (1)
        {
          unsigned int v23 = *v20;
          v20 += 4;
          unsigned int v22 = v23;
          if (-5 - v21 < (unint64_t)v23) {
            break;
          }
          v21 += v22 + 4;
          *(void *)(v6 + 32) = v21;
          if (!--v19) {
            goto LABEL_25;
          }
        }
      }
      else
      {
LABEL_25:
        (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v6 + 8), a1);
        size_t v24 = (_DWORD *)(*(uint64_t (**)(void, uint64_t))(a1 + 8))(*(void *)(v6 + 32), a1);
        size_t v43 = v24;
        *(void *)(v6 + 8) = v24;
        if (v24)
        {
          *(unsigned char *)size_t v24 = 61;
          size_t v43 = (_DWORD *)((char *)v43 + 1);
          _libssh2_store_u32(&v43, *(_DWORD *)(v6 + 72));
          if (*(_DWORD *)(v6 + 72))
          {
            uint64_t v25 = 0;
            unint64_t v26 = 0;
            do
            {
              _libssh2_store_str(&v43, *(const void **)(*(void *)(v6 + 88) + v25), *(unsigned int *)(*(void *)(v6 + 88) + v25 + 8));
              ++v26;
              v25 += 16;
            }
            while (v26 < *(unsigned int *)(v6 + 72));
          }
          *(_DWORD *)uint64_t v6 = 4;
LABEL_30:
          int v27 = _libssh2_transport_send(a1, *(void **)(v6 + 8), *(void *)(v6 + 32), 0, 0);
          if (!v27)
          {
            *(_DWORD *)(v6 + 76) = 0;
            goto LABEL_41;
          }
          if (v27 == -37) {
            goto LABEL_32;
          }
          uint64_t v29 = a1;
          uint64_t v30 = 4294967289;
          unint64_t v31 = "Unable to send userauth-keyboard-interactive request";
LABEL_40:
          _libssh2_error(v29, v30, v31);
          goto LABEL_41;
        }
      }
      uint64_t v29 = a1;
      uint64_t v30 = 4294967290;
      unint64_t v31 = "Unable to allocate memory for keyboard-interactive response packet";
      goto LABEL_40;
    }
    *(void *)(v6 + 48) = 0;
    *(void *)(v6 + 64) = 0;
    *(void *)(v6 + 72) = 0x100000000;
    *size_t v8 = 0;
    *(void *)(a1 + 72384) = 0;
    *(void *)(v6 + 96) = 0;
    *(void *)(v6 + 32) = v9;
    uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(v9, a1);
    *(void *)(v6 + 8) = v12;
    if (v12)
    {
      size_t v43 = (_DWORD *)(v12 + 1);
      *(unsigned char *)uint64_t v12 = 50;
      _libssh2_store_str(&v43, a2, v41);
      _libssh2_store_str(&v43, "ssh-connection", 0xEuLL);
      _libssh2_store_str(&v43, "keyboard-interactive", 0x14uLL);
      _libssh2_store_u32(&v43, 0);
      _libssh2_store_u32(&v43, 0);
      *(_DWORD *)uint64_t v6 = 2;
LABEL_6:
      int v13 = _libssh2_transport_send(a1, *(void **)(v6 + 8), *(void *)(v6 + 32), 0, 0);
      if (!v13)
      {
        (*(void (**)(void, uint64_t))(a1 + 24))(*v10, a1);
        *uint64_t v10 = 0;
        goto LABEL_11;
      }
      if (v13 == -37)
      {
LABEL_32:
        uint64_t v14 = a1;
        uint64_t v15 = 4294967259;
        time_t v16 = "Would block";
      }
      else
      {
        (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v6 + 8), a1);
        *(void *)(v6 + 8) = 0;
        *(_DWORD *)uint64_t v6 = 0;
        uint64_t v14 = a1;
        uint64_t v15 = 4294967289;
        time_t v16 = "Unable to send keyboard-interactive request";
      }
      goto LABEL_34;
    }
    uint64_t v14 = a1;
    uint64_t v15 = 4294967290;
    time_t v16 = "Unable to allocate memory for keyboard-interactive authentication";
LABEL_34:
    uint64_t result = _libssh2_error(v14, v15, v16);
    if (result != -37) {
      break;
    }
    if (!*(_DWORD *)(a1 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(a1, v7);
  }
  while (!result);
  return result;
}

uint64_t libssh2_userauth_publickey_sk(uint64_t a1, const void *a2, unint64_t a3, const char *a4, size_t a5, void *a6, unint64_t a7, void *a8, uint64_t a9, uint64_t a10)
{
  size_t v37 = 0;
  uint64_t v38 = 0;
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  long long v29 = 0u;
  long long v30 = 0u;
  uint64_t v28 = &v29;
  uint64_t v31 = a9;
  uint64_t v32 = a10;
  if (!a6 || !a7)
  {
    uint64_t v15 = "Invalid data in public and private key.";
    return _libssh2_error(a1, 4294967280, v15);
  }
  if (_libssh2_sk_pub_keyfilememory(a1, &v38, &v37, &v36, &v35, &v29, (unsigned char *)&v29 + 4, (void **)&v29 + 1, &v30, (size_t *)&v30 + 1, a6, a7, a8))
  {
    uint64_t v15 = "Unable to extract public key from private key.";
    return _libssh2_error(a1, 4294967280, v15);
  }
  int v18 = (void *)(a1 + 72256);
  if (!a4 || !a5)
  {
    size_t v22 = v37;
    *int v18 = v38;
    *(void *)(a1 + 72264) = v22;
    unsigned int v23 = (unsigned int **)&v36;
    size_t v24 = (size_t *)&v35;
    goto LABEL_19;
  }
  if (v38) {
    (*(void (**)(const char *, uint64_t))(a1 + 24))(v38, a1);
  }
  if (!strncmp(a4, "sk-ecdsa-sha2-nistp256-cert-v01@openssh.com", 0x2BuLL))
  {
    *(void *)(a1 + 72264) = 43;
    uint64_t v19 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(43, a1);
    *int v18 = v19;
    size_t v20 = *(void *)(a1 + 72264);
    uint64_t v21 = "sk-ecdsa-sha2-nistp256-cert-v01@openssh.com";
  }
  else
  {
    if (strncmp(a4, "sk-ssh-ed25519-cert-v01@openssh.com", 0x23uLL)) {
      goto LABEL_18;
    }
    *(void *)(a1 + 72264) = 35;
    uint64_t v19 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(35, a1);
    *int v18 = v19;
    size_t v20 = *(void *)(a1 + 72264);
    uint64_t v21 = "sk-ssh-ed25519-cert-v01@openssh.com";
  }
  memcpy(v19, v21, v20);
LABEL_18:
  unsigned int v23 = (unsigned int **)&v34;
  size_t v24 = (size_t *)&v33;
  uint64_t v16 = memory_read_publickey(a1, (char **)(a1 + 72256), (void *)(a1 + 72264), &v34, &v33, a4, a5);
  if (!v16)
  {
LABEL_19:
    uint64_t v25 = *v23;
    size_t v26 = *v24;
    uint64_t v16 = _libssh2_userauth_publickey(a1, a2, a3, v25, *v24, (uint64_t (*)(uint64_t, const void **, size_t *, char *, int64_t, uint64_t))libssh2_sign_sk, (uint64_t)&v28);
    if (v16 == -37)
    {
      do
        uint64_t v27 = _libssh2_userauth_publickey(a1, a2, a3, v25, v26, (uint64_t (*)(uint64_t, const void **, size_t *, char *, int64_t, uint64_t))libssh2_sign_sk, (uint64_t)&v28);
      while (v27 == -37);
      uint64_t v16 = v27;
    }
  }
  if (v36) {
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v36, a1);
  }
  if (*((void *)&v29 + 1)) {
    (*(void (**)(void, uint64_t))(a1 + 24))(*((void *)&v29 + 1), a1);
  }
  return v16;
}

uint64_t memory_read_publickey(uint64_t a1, char **a2, void *a3, void *a4, void *a5, const void *a6, size_t a7)
{
  if (a7 <= 1)
  {
    size_t v8 = "Invalid data in public key file";
LABEL_19:
    uint64_t v28 = a1;
    uint64_t v29 = 4294967280;
    goto LABEL_20;
  }
  uint64_t v15 = (char *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(a7, a1);
  if (!v15)
  {
    size_t v8 = "Unable to allocate memory for public key data";
    uint64_t v28 = a1;
    uint64_t v29 = 4294967290;
LABEL_20:
    return _libssh2_error(v28, v29, v8);
  }
  uint64_t v16 = v15;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  memcpy(v15, a6, a7);
  size_t v17 = a7 + 1;
  uint64_t v18 = MEMORY[0x263EF8318];
  do
  {
    size_t v19 = v17 - 1;
    if (v17 == 1)
    {
      (*(void (**)(char *, uint64_t))(a1 + 24))(v16, a1);
      size_t v8 = "Missing public key data";
      goto LABEL_19;
    }
    int v20 = v16[v17 - 2];
    if (v20 < 0) {
      int v21 = __maskrune(v20, 0x4000uLL);
    }
    else {
      int v21 = *(_DWORD *)(v18 + 4 * v20 + 60) & 0x4000;
    }
    size_t v17 = v19;
  }
  while (v21);
  unint64_t v22 = (unint64_t)memchr(v16, 32, v19);
  if (!v22)
  {
    (*(void (**)(char *, uint64_t))(a1 + 24))(v16, a1);
    size_t v8 = "Invalid public key data";
    goto LABEL_19;
  }
  unsigned int v23 = (unsigned __int8 *)(v22 + 1);
  size_t v24 = &v16[v19];
  uint64_t v25 = (char *)memchr((void *)(v22 + 1), 32, (size_t)&v24[~v22]);
  if (v25) {
    size_t v26 = v25;
  }
  else {
    size_t v26 = v24;
  }
  uint64_t result = _libssh2_base64_decode(a1, &v31, &v30, v23, v26 - (char *)v23);
  if (result)
  {
    (*(void (**)(char *, uint64_t))(a1 + 24))(v16, a1);
    return _libssh2_error(a1, 4294967280, "Invalid key data, not base64 encoded");
  }
  else
  {
    *a2 = v16;
    *a3 = v23 - (unsigned __int8 *)v16 - 1;
    *a4 = v31;
    *a5 = v30;
  }
  return result;
}

uint64_t file_read_publickey(uint64_t a1, char **a2, void *a3, void *a4, void *a5, char *__filename)
{
  int v11 = fopen(__filename, "r");
  if (!v11)
  {
    int v13 = "Unable to open public key file";
LABEL_14:
    uint64_t v16 = a1;
    uint64_t v17 = 4294967280;
LABEL_15:
    return _libssh2_error(v16, v17, v13);
  }
  uint64_t v12 = v11;
  if (feof(v11))
  {
    rewind(v12);
LABEL_13:
    fclose(v12);
    int v13 = "Invalid data in public key file";
    goto LABEL_14;
  }
  size_t v14 = 0;
  char __ptr = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  do
  {
    if (fread(&__ptr, 1uLL, 1uLL, v12) != 1) {
      break;
    }
    if (__ptr == 10 || __ptr == 13) {
      break;
    }
    ++v14;
  }
  while (!feof(v12));
  rewind(v12);
  if (v14 <= 1) {
    goto LABEL_13;
  }
  size_t v19 = (char *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v14, a1);
  if (!v19)
  {
    fclose(v12);
    int v13 = "Unable to allocate memory for public key data";
    uint64_t v16 = a1;
    uint64_t v17 = 4294967290;
    goto LABEL_15;
  }
  int v20 = v19;
  if (fread(v19, 1uLL, v14, v12) != v14)
  {
    (*(void (**)(char *, uint64_t))(a1 + 24))(v20, a1);
    fclose(v12);
    int v13 = "Unable to read public key from file";
    goto LABEL_14;
  }
  fclose(v12);
  size_t v21 = v14 + 1;
  uint64_t v22 = MEMORY[0x263EF8318];
  do
  {
    size_t v23 = v21 - 1;
    if (v21 == 1)
    {
      (*(void (**)(char *, uint64_t))(a1 + 24))(v20, a1);
      int v13 = "Missing public key data";
      goto LABEL_14;
    }
    int v24 = v20[v21 - 2];
    if (v24 < 0) {
      int v25 = __maskrune(v24, 0x4000uLL);
    }
    else {
      int v25 = *(_DWORD *)(v22 + 4 * v24 + 60) & 0x4000;
    }
    size_t v21 = v23;
  }
  while (v25);
  size_t v26 = (char *)memchr(v20, 32, v23);
  if (!v26)
  {
    (*(void (**)(char *, uint64_t))(a1 + 24))(v20, a1);
    int v13 = "Invalid public key data";
    goto LABEL_14;
  }
  uint64_t v27 = (unsigned __int8 *)(v26 + 1);
  if (v20 <= v26 + 1) {
    uint64_t v28 = v26 + 1;
  }
  else {
    uint64_t v28 = v20;
  }
  uint64_t v29 = &v20[v23];
  uint64_t v30 = (char *)memchr(v26 + 1, 32, v29 - v28);
  if (v30) {
    uint64_t v31 = v30;
  }
  else {
    uint64_t v31 = v29;
  }
  uint64_t result = _libssh2_base64_decode(a1, &v33, &v32, v27, v31 - (char *)v27);
  if (result)
  {
    (*(void (**)(char *, uint64_t))(a1 + 24))(v20, a1);
    return _libssh2_error(a1, 4294967280, "Invalid key data, not base64 encoded");
  }
  else
  {
    *a2 = v20;
    *a3 = v27 - (unsigned __int8 *)v20 - 1;
    *a4 = v33;
    *a5 = v32;
  }
  return result;
}

uint64_t file_read_privatekey(uint64_t a1, char ***a2, void *a3, const char *a4, size_t a5, uint64_t a6, uint64_t a7)
{
  size_t v14 = libssh2_hostkey_methods();
  *a2 = 0;
  *a3 = 0;
  uint64_t v15 = *v14;
  if (*v14)
  {
    uint64_t v16 = v14 + 1;
    while (*v15)
    {
      if (v15[3] && !strncmp(*v15, a4, a5))
      {
        *a2 = v15;
        goto LABEL_10;
      }
      uint64_t v17 = *v16++;
      uint64_t v15 = v17;
      if (!v17) {
        break;
      }
    }
  }
  uint64_t v15 = *a2;
  if (*a2)
  {
LABEL_10:
    uint64_t result = ((uint64_t (*)(uint64_t, uint64_t, uint64_t, void *))v15[3])(a1, a6, a7, a3);
    if (!result) {
      return result;
    }
    uint64_t v18 = "Unable to initialize private key from file";
    uint64_t v19 = a1;
    uint64_t v20 = 4294967280;
  }
  else
  {
    uint64_t v18 = "No handler for specified private key";
    uint64_t v19 = a1;
    uint64_t v20 = 4294967279;
  }
  return _libssh2_error(v19, v20, v18);
}

uint64_t sign_frommemory(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const char ***a6)
{
  size_t v8 = *a6;
  uint64_t v9 = *(const char **)(a1 + 72256);
  size_t v10 = *(void *)(a1 + 72264);
  int v11 = **a6;
  size_t v12 = strlen(v11);
  int v13 = v8[1];
  size_t v14 = libssh2_hostkey_methods();
  uint64_t v27 = 0;
  uint64_t v15 = *v14;
  if (*v14)
  {
    uint64_t v16 = v14 + 1;
    while (*v15)
    {
      uint64_t v17 = v15[4];
      if (v17 && !strncmp(*v15, v9, v10))
      {
        if (((unsigned int (*)(uint64_t, const char *, size_t, const char *, uint64_t *))v17)(a1, v11, v12, v13, &v27))
        {
          uint64_t v19 = _libssh2_error(a1, 4294967280, "Unable to initialize private key from memory");
          if (v19) {
            return v19;
          }
        }
        goto LABEL_8;
      }
      uint64_t v18 = *v16++;
      uint64_t v15 = v18;
      if (!v18) {
        break;
      }
    }
  }
  uint64_t v19 = _libssh2_error(a1, 4294967279, "No handler for specified private key");
  uint64_t v15 = 0;
  if (!v19)
  {
LABEL_8:
    v26[0] = a4;
    v26[1] = a5;
    int v20 = ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void *, uint64_t *))v15[6])(a1, a2, a3, 1, v26, &v27);
    size_t v21 = v15[8];
    if (v20) {
      uint64_t v19 = 0xFFFFFFFFLL;
    }
    else {
      uint64_t v19 = 0;
    }
    if (v21) {
      ((void (*)(uint64_t, uint64_t *))v21)(a1, &v27);
    }
  }
  return v19;
}

uint64_t sign_fromfile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t **a6)
{
  int v11 = *a6;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v12 = file_read_privatekey(a1, &v19, &v18, *(const char **)(a1 + 72256), *(void *)(a1 + 72264), *v11, v11[1]);
  if (!v12)
  {
    v17[0] = a4;
    v17[1] = a5;
    int v13 = v19;
    int v14 = ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void *, uint64_t *))v19[6])(a1, a2, a3, 1, v17, &v18);
    uint64_t v15 = v13[8];
    if (v14) {
      uint64_t v12 = 0xFFFFFFFFLL;
    }
    else {
      uint64_t v12 = 0;
    }
    if (v15) {
      ((void (*)(uint64_t, uint64_t *))v15)(a1, &v18);
    }
  }
  return v12;
}

uint64_t _libssh2_kex_exchange(uint64_t a1, int a2, uint64_t a3)
{
  int v5 = *(_DWORD *)(a1 + 128);
  *(_DWORD *)(a1 + 128) = v5 | 8;
  int v6 = *(_DWORD *)a3;
  if (!*(_DWORD *)a3)
  {
    *(_DWORD *)(a1 + 128) = v5 | 9;
    if (a2)
    {
      *(void *)(a1 + 144) = 0;
      uint64_t v7 = *(void *)(a1 + 184);
      if (v7)
      {
        size_t v8 = *(void (**)(uint64_t, uint64_t))(v7 + 64);
        if (v8) {
          v8(a1, a1 + 192);
        }
      }
      *(void *)(a1 + 184) = 0;
    }
    int v6 = 2;
    *(_DWORD *)a3 = 2;
  }
  uint64_t v9 = *(void *)(a1 + 144);
  if (!v9 || !*(void *)(a1 + 184))
  {
    if (v6 == 4)
    {
LABEL_66:
      int v55 = (uint64_t *)(a3 + 632);
      unint64_t v56 = (unint64_t *)(a3 + 640);
      int v57 = _libssh2_packet_require(a1, 20, (void *)(a3 + 632), (unint64_t *)(a3 + 640), 0, 0, 0, a3 + 8);
      if (v57)
      {
        if (v57 == -37) {
          goto LABEL_68;
        }
        uint64_t v61 = *(void *)(a1 + 432);
        if (v61) {
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v61, a1);
        }
        goto LABEL_83;
      }
      uint64_t v58 = *(void *)(a1 + 320);
      if (v58) {
        (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v58, a1);
      }
      uint64_t v59 = *v55;
      *(void *)(a1 + 320) = *v55;
      unint64_t v60 = *v56;
      *(void *)(a1 + 328) = *v56;
      if (v60 < 0x11) {
        goto LABEL_80;
      }
      uint64_t v115 = 0;
      uint64_t v116 = 0;
      id v113 = 0;
      id v114 = 0;
      uint64_t v111 = 0;
      id v112 = 0;
      uint64_t v109 = 0;
      uint64_t v110 = 0;
      size_t v107 = 0;
      size_t v108 = 0;
      size_t v105 = 0;
      size_t v106 = 0;
      size_t v103 = 0;
      size_t v104 = 0;
      size_t v101 = 0;
      size_t v102 = 0;
      unint64_t v100 = v60;
      uint64_t v98 = v59;
      uint64_t v99 = (unsigned __int8 *)(v59 + 17);
      if (_libssh2_get_string(&v98, &v116, &v108)
        || _libssh2_get_string(&v98, &v115, &v107)
        || _libssh2_get_string(&v98, &v114, &v106)
        || _libssh2_get_string(&v98, &v113, &v105)
        || _libssh2_get_string(&v98, &v110, &v102)
        || _libssh2_get_string(&v98, &v109, &v101)
        || _libssh2_get_string(&v98, &v112, &v104)
        || _libssh2_get_string(&v98, &v111, &v103)
        || !_libssh2_check_length(&v98, 1uLL)
        || (uint64_t v88 = v99,
            ++v99,
            *(_DWORD *)(a1 + 152) = *v88,
            kex_agree_kex_hostkey(a1, v116, v108, v115, v107))
        || kex_agree_crypt(a1 + 424, v114, v106)
        || kex_agree_crypt(a1 + 312, v113, v105)
        || kex_agree_mac(a1 + 424, v110, v102)
        || kex_agree_mac(a1 + 312, v109, v101)
        || kex_agree_comp(a1, a1 + 424, v112, v104)
        || kex_agree_comp(a1, a1 + 312, v111, v103))
      {
LABEL_80:
        *(_DWORD *)a3 = 5;
        uint64_t v11 = 4294967291;
        goto LABEL_124;
      }
      int v6 = 5;
      *(_DWORD *)a3 = 5;
      uint64_t v9 = *(void *)(a1 + 144);
LABEL_122:
      uint64_t v11 = 0;
      if (!v9 || v6 != 5) {
        goto LABEL_124;
      }
      goto LABEL_11;
    }
    if (v6 != 3)
    {
      if (v6 != 2) {
        goto LABEL_122;
      }
      *(void *)(a3 + 648) = *(void *)(a1 + 432);
      *(void *)(a3 + 656) = *(void *)(a1 + 440);
      *(void *)(a1 + 432) = 0;
      *(_DWORD *)a3 = 3;
    }
    uint64_t v12 = (_DWORD *)(a1 + 70992);
    if (*(_DWORD *)(a1 + 70992))
    {
      int v14 = *(unsigned char **)(a1 + 71000);
      size_t v13 = *(void *)(a1 + 71008);
      *(void *)(a1 + 71000) = 0;
      *(void *)(a1 + 71008) = 0;
    }
    else
    {
      uint64_t v17 = *(const char **)(a1 + 112);
      if (v17) {
        unsigned int v18 = strlen(v17);
      }
      else {
        unsigned int v18 = kex_method_strlen((const char ***)libssh2_kex_methods);
      }
      unsigned int v23 = v18;
      int v24 = *(const char **)(a1 + 120);
      if (v24)
      {
        unsigned int v25 = strlen(v24);
      }
      else
      {
        size_t v26 = libssh2_hostkey_methods();
        unsigned int v25 = kex_method_strlen((const char ***)v26);
      }
      unsigned int v27 = v25;
      uint64_t v28 = *(const char **)(a1 + 504);
      if (v28)
      {
        unsigned int v29 = strlen(v28);
      }
      else
      {
        uint64_t v30 = libssh2_crypt_methods();
        unsigned int v29 = kex_method_strlen((const char ***)v30);
      }
      unsigned int v31 = v29;
      uint64_t v32 = *(const char **)(a1 + 392);
      if (v32)
      {
        unsigned int v33 = strlen(v32);
      }
      else
      {
        uint64_t v34 = libssh2_crypt_methods();
        unsigned int v33 = kex_method_strlen((const char ***)v34);
      }
      unsigned int v95 = v33;
      uint64_t v35 = *(const char **)(a1 + 512);
      if (v35)
      {
        unsigned int v36 = strlen(v35);
      }
      else
      {
        size_t v37 = _libssh2_mac_methods();
        unsigned int v36 = kex_method_strlen((const char ***)v37);
      }
      unsigned int v96 = v36;
      uint64_t v38 = *(const char **)(a1 + 400);
      if (v38)
      {
        unsigned int v39 = strlen(v38);
      }
      else
      {
        size_t v40 = _libssh2_mac_methods();
        unsigned int v39 = kex_method_strlen((const char ***)v40);
      }
      unsigned int v97 = v39;
      unint64_t v41 = *(const char **)(a1 + 520);
      if (v41)
      {
        unsigned int v42 = strlen(v41);
      }
      else
      {
        size_t v43 = _libssh2_comp_methods(a1);
        unsigned int v42 = kex_method_strlen((const char ***)v43);
      }
      unsigned int v44 = v42;
      uint64_t v45 = *(const char **)(a1 + 408);
      if (v45)
      {
        unsigned int v46 = strlen(v45);
      }
      else
      {
        uint64_t v47 = _libssh2_comp_methods(a1);
        unsigned int v46 = kex_method_strlen((const char ***)v47);
      }
      unsigned int v48 = v46;
      uint64_t v49 = *(const char **)(a1 + 528);
      if (v49) {
        unsigned int v50 = strlen(v49);
      }
      else {
        unsigned int v50 = 0;
      }
      int v51 = *(const char **)(a1 + 416);
      if (v51) {
        unsigned int v52 = strlen(v51);
      }
      else {
        unsigned int v52 = 0;
      }
      unsigned int v93 = v44;
      unsigned int v94 = v48;
      size_t v13 = v27 + v23 + v31 + v95 + v96 + v97 + v44 + v48 + v50 + v52 + 62;
      fd_set v53 = (unsigned char *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v13, a1);
      if (!v53)
      {
        int v20 = "Unable to allocate memory";
        uint64_t v21 = a1;
        uint64_t v22 = 4294967290;
        goto LABEL_62;
      }
      int v14 = v53;
      unsigned char *v53 = 20;
      if (_libssh2_openssl_random(v53 + 1, 0x10uLL))
      {
        int v20 = "Unable to get random bytes for KEXINIT cookie";
        uint64_t v21 = a1;
        uint64_t v22 = 4294967247;
        goto LABEL_62;
      }
      unsigned int v92 = v50;
      if (*(void *)(a1 + 112))
      {
        _libssh2_htonu32(v14 + 17, v23);
        memcpy(v14 + 21, *(const void **)(a1 + 112), v23);
        size_t v62 = &v14[v23 + 21];
      }
      else
      {
        size_t v62 = &v14[kex_method_list(v14 + 17, v23, (const char ***)libssh2_kex_methods) + 17];
      }
      if (*(void *)(a1 + 120))
      {
        _libssh2_htonu32(v62, v27);
        uint64_t v63 = (char *)(v62 + 1);
        memcpy(v63, *(const void **)(a1 + 120), v27);
        int v64 = &v63[v27];
      }
      else
      {
        int v65 = libssh2_hostkey_methods();
        int v64 = (char *)v62 + kex_method_list(v62, v27, (const char ***)v65);
      }
      if (*(void *)(a1 + 504))
      {
        _libssh2_htonu32(v64, v31);
        int v66 = v64 + 4;
        memcpy(v66, *(const void **)(a1 + 504), v31);
        uint64_t v67 = &v66[v31];
      }
      else
      {
        uint64_t v68 = libssh2_crypt_methods();
        uint64_t v67 = &v64[kex_method_list(v64, v31, (const char ***)v68)];
      }
      if (*(void *)(a1 + 392))
      {
        _libssh2_htonu32(v67, v95);
        uint64_t v69 = v67 + 4;
        memcpy(v69, *(const void **)(a1 + 392), v95);
        uint64_t v70 = &v69[v95];
      }
      else
      {
        uint64_t v71 = libssh2_crypt_methods();
        uint64_t v70 = &v67[kex_method_list(v67, v95, (const char ***)v71)];
      }
      if (*(void *)(a1 + 512))
      {
        _libssh2_htonu32(v70, v96);
        id v72 = v70 + 4;
        memcpy(v72, *(const void **)(a1 + 512), v96);
        unint64_t v73 = &v72[v96];
      }
      else
      {
        unint64_t v74 = _libssh2_mac_methods();
        unint64_t v73 = &v70[kex_method_list(v70, v96, (const char ***)v74)];
      }
      if (*(void *)(a1 + 400))
      {
        _libssh2_htonu32(v73, v97);
        uint64_t v75 = v73 + 4;
        memcpy(v75, *(const void **)(a1 + 400), v97);
        uint64_t v76 = &v75[v97];
      }
      else
      {
        uint64_t v77 = _libssh2_mac_methods();
        uint64_t v76 = &v73[kex_method_list(v73, v97, (const char ***)v77)];
      }
      if (*(void *)(a1 + 520))
      {
        _libssh2_htonu32(v76, v93);
        size_t v78 = v76 + 4;
        memcpy(v78, *(const void **)(a1 + 520), v93);
        size_t v79 = &v78[v93];
      }
      else
      {
        id v80 = _libssh2_comp_methods(a1);
        size_t v79 = &v76[kex_method_list(v76, v93, (const char ***)v80)];
      }
      if (*(void *)(a1 + 408))
      {
        _libssh2_htonu32(v79, v94);
        uint64_t v81 = v79 + 4;
        memcpy(v81, *(const void **)(a1 + 408), v94);
        uint64_t v82 = &v81[v94];
      }
      else
      {
        char v83 = _libssh2_comp_methods(a1);
        uint64_t v82 = &v79[kex_method_list(v79, v94, (const char ***)v83)];
      }
      uint64_t v84 = *(void *)(a1 + 528);
      _libssh2_htonu32(v82, v92);
      uint64_t v85 = v82 + 4;
      if (v84)
      {
        memcpy(v85, *(const void **)(a1 + 528), v92);
        v85 += v92;
      }
      uint64_t v86 = *(void *)(a1 + 416);
      _libssh2_htonu32(v85, v52);
      id v87 = v85 + 4;
      if (v86)
      {
        memcpy(v87, *(const void **)(a1 + 416), v52);
        v87 += v52;
      }
      unsigned char *v87 = 0;
      _libssh2_htonu32(v87 + 1, 0);
      *uint64_t v12 = 2;
    }
    uint64_t v15 = _libssh2_transport_send(a1, v14, v13);
    if (!v15)
    {
      uint64_t v19 = *(void *)(a1 + 432);
      if (v19) {
        (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v19, a1);
      }
      *(void *)(a1 + 432) = v14;
      *(void *)(a1 + 440) = v13;
      *uint64_t v12 = 0;
LABEL_65:
      *(_DWORD *)a3 = 4;
      goto LABEL_66;
    }
    uint64_t v16 = v15;
    if (v15 == -37)
    {
      *(void *)(a1 + 71000) = v14;
      *(void *)(a1 + 71008) = v13;
LABEL_68:
      *(_DWORD *)(a1 + 128) &= ~8u;
      return 4294967259;
    }
    (*(void (**)(unsigned char *, uint64_t))(a1 + 24))(v14, a1);
    *uint64_t v12 = 0;
    int v20 = "Unable to send KEXINIT packet to remote host";
    uint64_t v21 = a1;
    uint64_t v22 = v16;
LABEL_62:
    int v54 = _libssh2_error(v21, v22, v20);
    if (v54)
    {
      if (v54 == -37) {
        goto LABEL_68;
      }
LABEL_83:
      *(void *)(a1 + 432) = *(void *)(a3 + 648);
      *(void *)(a1 + 440) = *(void *)(a3 + 656);
      *(_DWORD *)a3 = 0;
      *(_DWORD *)(a1 + 128) &= 0xFFFFFFF6;
      return 0xFFFFFFFFLL;
    }
    goto LABEL_65;
  }
  *(_DWORD *)a3 = 5;
LABEL_11:
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t))(v9 + 8))(a1, a3 + 24);
  uint64_t v11 = v10;
  if (v10)
  {
    if (v10 == -37)
    {
      *(_DWORD *)(a1 + 128) &= ~8u;
      return v11;
    }
    uint64_t v11 = _libssh2_error(a1, 4294967288, "Unrecoverable error exchanging keys");
  }
LABEL_124:
  uint64_t v89 = *(void *)(a1 + 432);
  if (v89)
  {
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v89, a1);
    *(void *)(a1 + 432) = 0;
  }
  uint64_t v90 = *(void *)(a1 + 320);
  if (v90)
  {
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v90, a1);
    *(void *)(a1 + 320) = 0;
  }
  *(_DWORD *)(a1 + 128) &= 0xFFFFFFF6;
  *(_DWORD *)a3 = 0;
  return v11;
}

uint64_t libssh2_session_method_pref(uint64_t a1, int a2, char *__s)
{
  size_t v6 = strlen(__s);
  switch(a2)
  {
    case 0:
      uint64_t v7 = (char **)(a1 + 112);
      size_t v8 = (const char ***)libssh2_kex_methods;
      goto LABEL_15;
    case 1:
      uint64_t v7 = (char **)(a1 + 120);
      uint64_t v12 = libssh2_hostkey_methods();
      goto LABEL_14;
    case 2:
      uint64_t v7 = (char **)(a1 + 504);
      goto LABEL_7;
    case 3:
      uint64_t v7 = (char **)(a1 + 392);
LABEL_7:
      uint64_t v12 = libssh2_crypt_methods();
      goto LABEL_14;
    case 4:
      uint64_t v7 = (char **)(a1 + 512);
      goto LABEL_10;
    case 5:
      uint64_t v7 = (char **)(a1 + 400);
LABEL_10:
      uint64_t v12 = _libssh2_mac_methods();
      goto LABEL_14;
    case 6:
      uint64_t v7 = (char **)(a1 + 520);
      goto LABEL_13;
    case 7:
      uint64_t v7 = (char **)(a1 + 408);
LABEL_13:
      uint64_t v12 = _libssh2_comp_methods(a1);
LABEL_14:
      size_t v8 = (const char ***)v12;
      goto LABEL_15;
    case 8:
      size_t v8 = 0;
      uint64_t v7 = (char **)(a1 + 528);
      goto LABEL_15;
    case 9:
      size_t v8 = 0;
      uint64_t v7 = (char **)(a1 + 416);
      goto LABEL_15;
    case 10:
      size_t v8 = 0;
      uint64_t v7 = (char **)(a1 + 304);
LABEL_15:
      size_t v13 = v6 + 1;
      int v14 = (char *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v6 + 1, a1);
      if (!v14)
      {
        uint64_t v9 = "Error allocated space for method preferences";
        uint64_t v10 = a1;
        uint64_t v11 = 4294967290;
        goto LABEL_34;
      }
      uint64_t v15 = v14;
      memcpy(v14, __s, v13);
      if (!v8 || !*v15) {
        goto LABEL_28;
      }
      uint64_t v16 = v15;
      break;
    default:
      uint64_t v9 = "Invalid parameter specified for method_type";
      uint64_t v10 = a1;
      uint64_t v11 = 4294967262;
      goto LABEL_34;
  }
  do
  {
    uint64_t v17 = strchr(v16, 44);
    if (v17)
    {
      int64_t v18 = v17 - v16;
      uint64_t v19 = v17 + 1;
      if (kex_get_method_by_name(v16, v17 - v16, v8))
      {
        uint64_t v16 = v19;
      }
      else
      {
        size_t v21 = strlen(v16);
        memmove(v16, v19, v21 - v18);
      }
    }
    else
    {
      size_t v20 = strlen(v16);
      if (kex_get_method_by_name(v16, v20, v8)) {
        break;
      }
      if (v16 <= v15) {
        *uint64_t v16 = 0;
      }
      else {
        *--uint64_t v16 = 0;
      }
    }
  }
  while (*v16);
LABEL_28:
  if (*v15)
  {
    if (*v7) {
      (*(void (**)(char *, uint64_t))(a1 + 24))(*v7, a1);
    }
    *uint64_t v7 = v15;
    return 0;
  }
  (*(void (**)(char *, uint64_t))(a1 + 24))(v15, a1);
  uint64_t v9 = "The requested method(s) are not currently supported";
  uint64_t v10 = a1;
  uint64_t v11 = 4294967263;
LABEL_34:
  return _libssh2_error(v10, v11, v9);
}

const char **kex_get_method_by_name(const char *a1, size_t a2, const char ***a3)
{
  int v3 = *a3;
  if (*a3)
  {
    size_t v6 = a3 + 1;
    do
    {
      if (strlen(*v3) == a2 && !strncmp(*v3, a1, a2)) {
        break;
      }
      uint64_t v7 = *v6++;
      int v3 = v7;
    }
    while (v7);
  }
  return v3;
}

uint64_t libssh2_session_supported_algs(uint64_t a1, int a2, uint64_t *a3)
{
  uint64_t v3 = a1;
  if (a3)
  {
    int v5 = libssh2_kex_methods;
    switch(a2)
    {
      case 0:
        goto LABEL_10;
      case 1:
        size_t v6 = libssh2_hostkey_methods();
        goto LABEL_9;
      case 2:
      case 3:
        size_t v6 = libssh2_crypt_methods();
        goto LABEL_9;
      case 4:
      case 5:
        size_t v6 = _libssh2_mac_methods();
        goto LABEL_9;
      case 6:
      case 7:
        size_t v6 = _libssh2_comp_methods(a1);
LABEL_9:
        int v5 = v6;
        if (!v6) {
          goto LABEL_28;
        }
LABEL_10:
        uint64_t v9 = *v5;
        if (!*v5) {
          goto LABEL_28;
        }
        LODWORD(v10) = 0;
        unsigned int v11 = 1;
        do
        {
          if (*v9) {
            uint64_t v10 = (v10 + 1);
          }
          else {
            uint64_t v10 = v10;
          }
          uint64_t v9 = v5[v11++];
        }
        while (v9);
        if (!v10)
        {
LABEL_28:
          uint64_t v7 = "No algorithm found";
          a1 = v3;
          uint64_t v8 = 4294967262;
          goto LABEL_29;
        }
        uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t))(v3 + 8))(8 * v10, v3);
        *a3 = v12;
        if (!v12)
        {
          uint64_t v7 = "Memory allocation failed";
          a1 = v3;
          uint64_t v8 = 4294967290;
          goto LABEL_29;
        }
        size_t v13 = *v5;
        if (*v5)
        {
          unsigned int v14 = 0;
          unsigned int v15 = 1;
          do
          {
            uint64_t v16 = *v13;
            if (v16) {
              *(void *)(*a3 + 8 * v14++) = v16;
            }
            size_t v13 = v5[v15++];
            if (v13) {
              BOOL v17 = v14 >= v10;
            }
            else {
              BOOL v17 = 1;
            }
          }
          while (!v17);
        }
        else
        {
          unsigned int v14 = 0;
        }
        if (v14 == v10) {
          return v10;
        }
        (*(void (**)(uint64_t, uint64_t))(v3 + 24))(*a3, v3);
        *a3 = 0;
        uint64_t v7 = "Internal error";
        break;
      case 10:
        goto LABEL_28;
      default:
        uint64_t v7 = "Unknown method type";
        uint64_t v8 = 4294967263;
        goto LABEL_29;
    }
  }
  else
  {
    uint64_t v7 = "algs must not be NULL";
  }
  a1 = v3;
  uint64_t v8 = 4294967257;
LABEL_29:
  return _libssh2_error(a1, v8, v7);
}

const char ***kex_method_strlen(const char ***result)
{
  if (result)
  {
    uint64_t v1 = *result;
    if (*result)
    {
      uint64_t v2 = 0;
      uint64_t v3 = result + 1;
      do
      {
        if (!*v1) {
          break;
        }
        v2 += strlen(*v1) + 1;
        uint64_t v4 = *v3++;
        uint64_t v1 = v4;
      }
      while (v4);
      return (const char ***)(v2 - 1);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t kex_method_list(_DWORD *a1, unsigned int a2, const char ***a3)
{
  _libssh2_htonu32(a1, a2);
  if (!a3) {
    return 4;
  }
  size_t v6 = *a3;
  if (!*a3) {
    return 4;
  }
  uint64_t v7 = (char *)(a1 + 1);
  uint64_t v8 = a3 + 1;
  do
  {
    uint64_t v9 = *v6;
    if (!*v6) {
      break;
    }
    unsigned int v10 = strlen(*v6);
    memcpy(v7, v9, v10);
    unsigned int v11 = &v7[v10];
    *unsigned int v11 = 44;
    uint64_t v7 = v11 + 1;
    uint64_t v12 = *v8++;
    size_t v6 = v12;
  }
  while (v12);
  return a2 + 4;
}

uint64_t kex_agree_kex_hostkey(uint64_t a1, char *a2, size_t a3, char *a4, size_t a5)
{
  unsigned int v10 = *(char **)(a1 + 112);
  if (v10)
  {
    while (*v10)
    {
      unsigned int v11 = strchr(v10, 44);
      uint64_t v12 = v11;
      if (v11) {
        size_t v13 = v11 - v10;
      }
      else {
        size_t v13 = strlen(v10);
      }
      unsigned int v14 = kex_agree_instr(a2, a3, v10, v13);
      if (v14)
      {
        unsigned int v15 = v14;
        method_by_name = kex_get_method_by_name(v10, v13, (const char ***)libssh2_kex_methods);
        if (!method_by_name) {
          return 0xFFFFFFFFLL;
        }
        BOOL v17 = method_by_name;
        uint64_t result = kex_agree_hostkey(a1, (char)method_by_name[2], a4, a5);
        if (!result)
        {
          int v27 = *(_DWORD *)(a1 + 152);
          size_t v26 = (_DWORD *)(a1 + 152);
          int v25 = v27;
          *((void *)v26 - 1) = v17;
          if (v15 == a2 && v25) {
            goto LABEL_28;
          }
          return result;
        }
      }
      unsigned int v10 = v12 + 1;
      if (!v12) {
        return 0xFFFFFFFFLL;
      }
    }
  }
  else
  {
    uint64_t v19 = libssh2_kex_methods[0];
    if (libssh2_kex_methods[0])
    {
      size_t v20 = off_268BA79B8;
      while (*v19)
      {
        size_t v21 = strlen(*v19);
        uint64_t v22 = kex_agree_instr(a2, a3, *v19, v21);
        if (v22)
        {
          unsigned int v23 = v22;
          if (!kex_agree_hostkey(a1, (char)v19[2], a4, a5))
          {
            int v29 = *(_DWORD *)(a1 + 152);
            size_t v26 = (_DWORD *)(a1 + 152);
            int v28 = v29;
            *((void *)v26 - 1) = *(v20 - 1);
            if (v23 != a2 || v28 == 0) {
              return 0;
            }
LABEL_28:
            uint64_t result = 0;
            *size_t v26 = 0;
            return result;
          }
        }
        int v24 = *v20++;
        uint64_t v19 = v24;
        if (!v24) {
          return 0xFFFFFFFFLL;
        }
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t kex_agree_crypt(uint64_t a1, char *a2, size_t a3)
{
  size_t v6 = libssh2_crypt_methods();
  uint64_t v7 = (const char ***)v6;
  uint64_t v8 = *(char **)(a1 + 80);
  if (v8)
  {
    while (*v8)
    {
      uint64_t v9 = strchr(v8, 44);
      unsigned int v10 = v9;
      if (v9) {
        size_t v11 = v9 - v8;
      }
      else {
        size_t v11 = strlen(v8);
      }
      if (kex_agree_instr(a2, a3, v8, v11))
      {
        method_by_name = kex_get_method_by_name(v8, v11, v7);
        if (!method_by_name) {
          return 0xFFFFFFFFLL;
        }
        goto LABEL_16;
      }
      uint64_t v8 = v10 + 1;
      if (!v10) {
        return 0xFFFFFFFFLL;
      }
    }
  }
  else
  {
    method_by_name = (const char **)*v6;
    if (*v6)
    {
      size_t v13 = (const char ***)(v6 + 1);
      while (*method_by_name)
      {
        size_t v14 = strlen(*method_by_name);
        if (kex_agree_instr(a2, a3, (char *)*method_by_name, v14))
        {
LABEL_16:
          uint64_t result = 0;
          *(void *)(a1 + 24) = method_by_name;
          return result;
        }
        unsigned int v15 = *v13++;
        method_by_name = v15;
        if (!v15) {
          return 0xFFFFFFFFLL;
        }
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t kex_agree_mac(uint64_t a1, char *a2, size_t a3)
{
  size_t v6 = _libssh2_mac_methods();
  method_by_name = (const char **)_libssh2_mac_override(*(const char ***)(a1 + 24));
  if (method_by_name)
  {
LABEL_2:
    uint64_t result = 0;
    *(void *)(a1 + 40) = method_by_name;
  }
  else
  {
    uint64_t v9 = *(char **)(a1 + 88);
    if (v9)
    {
      while (*v9)
      {
        unsigned int v10 = strchr(v9, 44);
        size_t v11 = v10;
        if (v10) {
          size_t v12 = v10 - v9;
        }
        else {
          size_t v12 = strlen(v9);
        }
        if (kex_agree_instr(a2, a3, v9, v12))
        {
          method_by_name = kex_get_method_by_name(v9, v12, (const char ***)v6);
          if (method_by_name) {
            goto LABEL_2;
          }
          return 0xFFFFFFFFLL;
        }
        uint64_t v9 = v11 + 1;
        if (!v11) {
          return 0xFFFFFFFFLL;
        }
      }
    }
    else
    {
      method_by_name = (const char **)*v6;
      if (*v6)
      {
        size_t v13 = (const char ***)(v6 + 1);
        while (*method_by_name)
        {
          size_t v14 = strlen(*method_by_name);
          if (kex_agree_instr(a2, a3, (char *)*method_by_name, v14)) {
            goto LABEL_2;
          }
          unsigned int v15 = *v13++;
          method_by_name = v15;
          uint64_t result = 0xFFFFFFFFLL;
          if (!v15) {
            return result;
          }
        }
      }
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t kex_agree_comp(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  uint64_t v7 = _libssh2_comp_methods(a1);
  uint64_t v8 = (const char ***)v7;
  uint64_t v9 = *(char **)(a2 + 96);
  if (v9)
  {
    while (*v9)
    {
      unsigned int v10 = strchr(v9, 44);
      size_t v11 = v10;
      if (v10) {
        size_t v12 = v10 - v9;
      }
      else {
        size_t v12 = strlen(v9);
      }
      if (kex_agree_instr(a3, a4, v9, v12))
      {
        method_by_name = kex_get_method_by_name(v9, v12, v8);
        if (!method_by_name) {
          return 0xFFFFFFFFLL;
        }
        goto LABEL_16;
      }
      uint64_t v9 = v11 + 1;
      if (!v11) {
        return 0xFFFFFFFFLL;
      }
    }
  }
  else
  {
    method_by_name = (const char **)*v7;
    if (*v7)
    {
      size_t v14 = (const char ***)(v7 + 1);
      while (*method_by_name)
      {
        size_t v15 = strlen(*method_by_name);
        if (kex_agree_instr(a3, a4, (char *)*method_by_name, v15))
        {
LABEL_16:
          uint64_t result = 0;
          *(void *)(a2 + 64) = method_by_name;
          return result;
        }
        uint64_t v16 = *v14++;
        method_by_name = v16;
        if (!v16) {
          return 0xFFFFFFFFLL;
        }
      }
    }
  }
  return 0xFFFFFFFFLL;
}

char *kex_agree_instr(char *a1, size_t a2, char *__s2, size_t __n)
{
  uint64_t v4 = 0;
  if (a1 && __n - 1 < a2)
  {
    if (!strncmp(a1, __s2, __n) && (__n == a2 || a1[__n] == 44))
    {
      return a1;
    }
    else
    {
      uint64_t v9 = (const char *)memchr(a1, 44, a2);
      if (v9)
      {
        unsigned int v10 = &a1[a2];
        size_t v11 = __n - (void)a1;
        do
        {
          size_t v12 = v10 - v9;
          if (v10 - v9 <= __n || v10 - v9 - 1 >= a2) {
            break;
          }
          uint64_t v4 = v9 + 1;
          if (!strncmp(v9 + 1, __s2, __n) && (&v4[v11] == (unsigned char *)a2 || v4[__n] == 44)) {
            return v4;
          }
          uint64_t v9 = (const char *)memchr(v4, 44, v12);
        }
        while (v9);
      }
      return 0;
    }
  }
  return v4;
}

uint64_t kex_agree_hostkey(uint64_t a1, char a2, char *a3, size_t a4)
{
  uint64_t v8 = libssh2_hostkey_methods();
  uint64_t v9 = (const char ***)v8;
  unsigned int v10 = *(char **)(a1 + 120);
  if (v10)
  {
    while (*v10)
    {
      size_t v11 = strchr(v10, 44);
      size_t v12 = v11;
      if (v11) {
        size_t v13 = v11 - v10;
      }
      else {
        size_t v13 = strlen(v10);
      }
      if (kex_agree_instr(a3, a4, v10, v13))
      {
        method_by_name = kex_get_method_by_name(v10, v13, v9);
        if (!method_by_name) {
          return 0xFFFFFFFFLL;
        }
        size_t v15 = method_by_name;
        if (((a2 & 1) == 0 || method_by_name[7]) && ((a2 & 2) == 0 || method_by_name[5])) {
          goto LABEL_25;
        }
      }
      unsigned int v10 = v12 + 1;
      if (!v12) {
        return 0xFFFFFFFFLL;
      }
    }
  }
  else if (v8)
  {
    size_t v15 = (const char **)*v8;
    if (*v8)
    {
      uint64_t v16 = (void **)(v8 + 1);
      while (*v15)
      {
        size_t v17 = strlen(*v15);
        if (kex_agree_instr(a3, a4, (char *)*v15, v17) && ((a2 & 1) == 0 || v15[7]) && ((a2 & 2) == 0 || v15[5]))
        {
LABEL_25:
          uint64_t result = 0;
          *(void *)(a1 + 184) = v15;
          return result;
        }
        int64_t v18 = (const char **)*v16++;
        size_t v15 = v18;
        if (!v18) {
          return 0xFFFFFFFFLL;
        }
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t kex_method_curve25519_key_exchange(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 0;
  switch(*(_DWORD *)a2)
  {
    case 0:
      *(void *)(a2 + 576) = 0;
      *(_DWORD *)a2 = 2;
      goto LABEL_3;
    case 2:
LABEL_3:
      v101[0] = 0;
      int v5 = **(const char ***)(a1 + 144);
      if (strcmp(v5, "curve25519-sha256@libssh.org") && strcmp(v5, "curve25519-sha256"))
      {
        size_t v6 = "Unknown KEX curve25519 curve type";
        uint64_t v7 = a1;
        uint64_t v8 = 0xFFFFFFFFLL;
LABEL_26:
        uint64_t v4 = _libssh2_error(v7, v8, v6);
LABEL_123:
        unint64_t v73 = *(void **)(a2 + 592);
        if (v73)
        {
          memset_s(v73, 0x20uLL, 0, 0x20uLL);
          (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(a2 + 592), a1);
          *(void *)(a2 + 592) = 0;
        }
        unint64_t v74 = *(void **)(a2 + 600);
        if (v74)
        {
          memset_s(v74, 0x20uLL, 0, 0x20uLL);
          (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(a2 + 600), a1);
          *(void *)(a2 + 600) = 0;
        }
        *(_DWORD *)a2 = 0;
        return v4;
      }
      uint64_t v9 = _libssh2_curve25519_new(a1, (uint64_t *)(a2 + 592), (uint64_t *)(a2 + 600));
      if (v9)
      {
        uint64_t v8 = v9;
        size_t v6 = "Unable to create private key";
        uint64_t v7 = a1;
        goto LABEL_26;
      }
      *(unsigned char *)(a2 + 288) = 30;
      v101[0] = (EVP_MD_CTX *)(a2 + 289);
      _libssh2_store_str((_DWORD **)v101, *(const void **)(a2 + 592), 0x20uLL);
      size_t v10 = 37;
      *(void *)(a2 + 552) = 37;
      *(_DWORD *)a2 = 3;
LABEL_10:
      uint64_t v11 = _libssh2_transport_send(a1, (void *)(a2 + 288), v10, 0, 0);
      uint64_t v4 = v11;
      if (v11 == -37) {
        return v4;
      }
      if (v11)
      {
        size_t v6 = "Unable to send ECDH_INIT";
        goto LABEL_25;
      }
      *(_DWORD *)a2 = 4;
LABEL_13:
      uint64_t v12 = _libssh2_packet_require(a1, 31, (void *)(a2 + 544), (unint64_t *)(a2 + 560), 0, 0, 0, a2 + 8);
      uint64_t v4 = v12;
      if (v12 == -37) {
        return v4;
      }
      if (v12)
      {
        size_t v6 = "Timeout waiting for ECDH_REPLY reply";
LABEL_25:
        uint64_t v7 = a1;
        uint64_t v8 = v4;
        goto LABEL_26;
      }
      *(_DWORD *)a2 = 5;
LABEL_16:
      size_t v13 = *(EVP_MD_CTX **)(a2 + 560);
      if ((unint64_t)v13 > 4)
      {
        uint64_t v4 = 0;
        uint64_t v14 = *(void *)(a2 + 544);
        size_t v15 = *(const void **)(a2 + 592);
        uint64_t v16 = *(void *)(a2 + 600);
        switch(*(_DWORD *)(a2 + 24))
        {
          case 0:
            *(void *)(a2 + 184) = BN_new();
            *(_DWORD *)(a2 + 24) = 2;
            goto LABEL_20;
          case 2:
LABEL_20:
            __src = 0;
            d = 0;
            uint64_t v102 = 0;
            size_t cnt = 0;
            v101[0] = (EVP_MD_CTX *)v14;
            v101[1] = (EVP_MD_CTX *)(v14 + 1);
            v101[2] = v13;
            if (_libssh2_get_string(v101, &__src, &v102))
            {
              size_t v17 = "Unexpected curve25519 key length 2";
LABEL_22:
              uint64_t v18 = a1;
              uint64_t v19 = 4294967282;
LABEL_117:
              uint64_t v4 = _libssh2_error(v18, v19, v17);
LABEL_118:
              BN_clear_free(*(BIGNUM **)(a2 + 184));
              *(void *)(a2 + 184) = 0;
              uint64_t v72 = *(void *)(a2 + 200);
              if (v72)
              {
                (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v72, a1);
                *(void *)(a2 + 200) = 0;
              }
              *(_DWORD *)(a2 + 24) = 0;
              goto LABEL_121;
            }
            uint64_t v20 = v102;
            *(_DWORD *)(a1 + 208) = v102;
            size_t v21 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(v20, a1);
            *(void *)(a1 + 200) = v21;
            if (v21)
            {
              memcpy(v21, __src, *(unsigned int *)(a1 + 208));
              ctx = 0;
              if (_libssh2_md5_init(&ctx))
              {
                EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
                EVP_DigestFinal(ctx, (unsigned __int8 *)(a1 + 212), 0);
                EVP_MD_CTX_free(ctx);
                int v22 = 1;
              }
              else
              {
                int v22 = 0;
              }
              *(_DWORD *)(a1 + 228) = v22;
              ctx = 0;
              if (_libssh2_sha1_init(&ctx))
              {
                EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
                EVP_DigestFinal(ctx, (unsigned __int8 *)(a1 + 232), 0);
                EVP_MD_CTX_free(ctx);
                int v23 = 1;
              }
              else
              {
                int v23 = 0;
              }
              *(_DWORD *)(a1 + 252) = v23;
              ctx = 0;
              if (_libssh2_sha256_init(&ctx))
              {
                EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
                EVP_DigestFinal(ctx, (unsigned __int8 *)(a1 + 256), 0);
                EVP_MD_CTX_free(ctx);
                int v24 = 1;
              }
              else
              {
                int v24 = 0;
              }
              *(_DWORD *)(a1 + 288) = v24;
              if ((*(unsigned int (**)(uint64_t, void, void, uint64_t))(*(void *)(a1 + 184) + 16))(a1, *(void *)(a1 + 200), *(unsigned int *)(a1 + 208), a1 + 192))
              {
                size_t v17 = "Unable to initialize hostkey importer curve25519";
LABEL_41:
                uint64_t v18 = a1;
                uint64_t v19 = 4294967286;
                goto LABEL_117;
              }
              if (_libssh2_get_string(v101, &d, &cnt))
              {
                size_t v17 = "Unexpected curve25519 key length";
                goto LABEL_22;
              }
              if (cnt != 32)
              {
                size_t v17 = "Unexpected curve25519 server public key length";
                goto LABEL_41;
              }
              if (_libssh2_get_string(v101, (void *)(a2 + 208), (void *)(a2 + 232)))
              {
                size_t v17 = "Unexpected curve25519 server sig length";
                goto LABEL_41;
              }
              if (_libssh2_curve25519_gen_k((BIGNUM **)(a2 + 184), v16, (uint64_t)d))
              {
                size_t v17 = "Unable to create curve25519 shared secret";
                uint64_t v18 = a1;
                uint64_t v19 = 4294967291;
                goto LABEL_117;
              }
              int v25 = BN_num_bits(*(const BIGNUM **)(a2 + 184));
              int v26 = v25 + 7;
              if (v25 < -7) {
                int v26 = v25 + 14;
              }
              *(void *)(a2 + 224) = (v26 >> 3) + 5;
              char v27 = BN_num_bits(*(const BIGNUM **)(a2 + 184));
              uint64_t v28 = *(void *)(a2 + 224);
              if ((v27 & 7) != 0) {
                *(void *)(a2 + 224) = --v28;
              }
              int v29 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(v28, a1);
              *(void *)(a2 + 200) = v29;
              if (!v29)
              {
                size_t v17 = "Unable to allocate buffer for K";
                goto LABEL_31;
              }
              _libssh2_htonu32(v29, *(_DWORD *)(a2 + 224) - 4);
              if ((BN_num_bits(*(const BIGNUM **)(a2 + 184)) & 7) != 0)
              {
                uint64_t v30 = 4;
              }
              else
              {
                *(unsigned char *)(*(void *)(a2 + 200) + 4) = 0;
                uint64_t v30 = 5;
              }
              BN_bn2bin(*(const BIGNUM **)(a2 + 184), (unsigned __int8 *)(*(void *)(a2 + 200) + v30));
              ctx = 0;
              *(void *)(a2 + 240) = &ctx;
              _libssh2_sha256_init(&ctx);
              unsigned int v31 = *(const char **)(a1 + 424);
              if (v31)
              {
                int v32 = strlen(v31);
                _libssh2_htonu32((_DWORD *)(a2 + 56), v32 - 2);
                EVP_DigestUpdate(ctx, (const void *)(a2 + 56), 4uLL);
                size_t v33 = strlen(*(const char **)(a1 + 424)) - 2;
                uint64_t v34 = ctx;
                uint64_t v35 = *(const char **)(a1 + 424);
              }
              else
              {
                _libssh2_htonu32((_DWORD *)(a2 + 56), 0x16u);
                EVP_DigestUpdate(ctx, (const void *)(a2 + 56), 4uLL);
                uint64_t v34 = ctx;
                uint64_t v35 = "SSH-2.0-libssh2_1.11.0";
                size_t v33 = 22;
              }
              EVP_DigestUpdate(v34, v35, v33);
              unsigned int v36 = strlen(*(const char **)(a1 + 312));
              _libssh2_htonu32((_DWORD *)(a2 + 56), v36);
              EVP_DigestUpdate(ctx, (const void *)(a2 + 56), 4uLL);
              size_t v37 = strlen(*(const char **)(a1 + 312));
              EVP_DigestUpdate(ctx, *(const void **)(a1 + 312), v37);
              _libssh2_htonu32((_DWORD *)(a2 + 56), *(_DWORD *)(a1 + 440));
              EVP_DigestUpdate(ctx, (const void *)(a2 + 56), 4uLL);
              EVP_DigestUpdate(ctx, *(const void **)(a1 + 432), *(void *)(a1 + 440));
              _libssh2_htonu32((_DWORD *)(a2 + 56), *(_DWORD *)(a1 + 328));
              EVP_DigestUpdate(ctx, (const void *)(a2 + 56), 4uLL);
              EVP_DigestUpdate(ctx, *(const void **)(a1 + 320), *(void *)(a1 + 328));
              _libssh2_htonu32((_DWORD *)(a2 + 56), *(_DWORD *)(a1 + 208));
              EVP_DigestUpdate(ctx, (const void *)(a2 + 56), 4uLL);
              EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
              _libssh2_htonu32((_DWORD *)(a2 + 56), 0x20u);
              EVP_DigestUpdate(ctx, (const void *)(a2 + 56), 4uLL);
              EVP_DigestUpdate(ctx, v15, 0x20uLL);
              _libssh2_htonu32((_DWORD *)(a2 + 56), cnt);
              EVP_DigestUpdate(ctx, (const void *)(a2 + 56), 4uLL);
              EVP_DigestUpdate(ctx, d, cnt);
              EVP_DigestUpdate(ctx, *(const void **)(a2 + 200), *(void *)(a2 + 224));
              EVP_DigestFinal(ctx, (unsigned __int8 *)(a2 + 56), 0);
              EVP_MD_CTX_free(ctx);
              if ((*(unsigned int (**)(uint64_t, void, void, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 184) + 40))(a1, *(void *)(a2 + 208), *(void *)(a2 + 232), a2 + 56, 32, a1 + 192))
              {
                size_t v17 = "Unable to verify hostkey signature curve25519";
                uint64_t v18 = a1;
                uint64_t v19 = 4294967285;
                goto LABEL_117;
              }
              *(unsigned char *)(a2 + 120) = 21;
              *(_DWORD *)(a2 + 24) = 3;
LABEL_65:
              uint64_t v38 = _libssh2_transport_send(a1, (void *)(a2 + 120), 1uLL, 0, 0);
              uint64_t v4 = v38;
              if (v38 == -37) {
                return v4;
              }
              if (v38)
              {
                size_t v17 = "Unable to send NEWKEYS message curve25519";
              }
              else
              {
                *(_DWORD *)(a2 + 24) = 5;
LABEL_68:
                uint64_t v39 = _libssh2_packet_require(a1, 21, (void *)(a2 + 48), (unint64_t *)(a2 + 144), 0, 0, 0, a2 + 248);
                uint64_t v4 = v39;
                if (v39 == -37) {
                  return v4;
                }
                if (!v39)
                {
                  *(_DWORD *)(a1 + 128) |= 2u;
                  (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(a2 + 48), a1);
                  if (*(void *)(a1 + 160)) {
                    goto LABEL_73;
                  }
                  size_t v40 = (_OWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(32, a1);
                  *(void *)(a1 + 160) = v40;
                  if (v40)
                  {
                    long long v41 = *(_OWORD *)(a2 + 72);
                    *size_t v40 = *(_OWORD *)(a2 + 56);
                    v40[1] = v41;
                    *(_DWORD *)(a1 + 168) = 32;
LABEL_73:
                    uint64_t v42 = *(void *)(a1 + 448);
                    size_t v43 = *(void (**)(uint64_t, uint64_t))(v42 + 56);
                    if (v43)
                    {
                      v43(a1, a1 + 456);
                      uint64_t v42 = *(void *)(a1 + 448);
                    }
                    if (*(void *)(v42 + 40))
                    {
                      LODWORD(d) = 0;
                      LODWORD(__src) = 0;
                      v101[0] = 0;
                      uint64_t v44 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v42 + 20) + 32, a1);
                      if (!v44)
                      {
                        uint64_t v4 = 0xFFFFFFFFLL;
                        goto LABEL_118;
                      }
                      uint64_t v45 = (void *)v44;
                      uint64_t v46 = *(void *)(a1 + 448);
                      if (*(_DWORD *)(v46 + 20))
                      {
                        unint64_t v47 = 0;
                        do
                        {
                          _libssh2_sha256_init(v101);
                          EVP_DigestUpdate(v101[0], *(const void **)(a2 + 200), *(void *)(a2 + 224));
                          EVP_DigestUpdate(v101[0], (const void *)(a2 + 56), 0x20uLL);
                          unsigned int v48 = v101[0];
                          if (v47)
                          {
                            uint64_t v49 = v45;
                            size_t v50 = v47;
                          }
                          else
                          {
                            EVP_DigestUpdate(v101[0], "A", 1uLL);
                            unsigned int v48 = v101[0];
                            uint64_t v49 = *(const void **)(a1 + 160);
                            size_t v50 = *(unsigned int *)(a1 + 168);
                          }
                          EVP_DigestUpdate(v48, v49, v50);
                          EVP_DigestFinal(v101[0], (unsigned __int8 *)v45 + v47, 0);
                          EVP_MD_CTX_free(v101[0]);
                          v47 += 32;
                          uint64_t v46 = *(void *)(a1 + 448);
                        }
                        while (v47 < *(int *)(v46 + 20));
                      }
                      v101[0] = 0;
                      uint64_t v51 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v46 + 24) + 32, a1);
                      if (!v51) {
                        goto LABEL_130;
                      }
                      unsigned int v52 = (void *)v51;
                      uint64_t v53 = *(void *)(a1 + 448);
                      if (*(_DWORD *)(v53 + 24))
                      {
                        unint64_t v54 = 0;
                        do
                        {
                          _libssh2_sha256_init(v101);
                          EVP_DigestUpdate(v101[0], *(const void **)(a2 + 200), *(void *)(a2 + 224));
                          EVP_DigestUpdate(v101[0], (const void *)(a2 + 56), 0x20uLL);
                          int v55 = v101[0];
                          if (v54)
                          {
                            unint64_t v56 = v52;
                            size_t v57 = v54;
                          }
                          else
                          {
                            EVP_DigestUpdate(v101[0], "C", 1uLL);
                            int v55 = v101[0];
                            unint64_t v56 = *(const void **)(a1 + 160);
                            size_t v57 = *(unsigned int *)(a1 + 168);
                          }
                          EVP_DigestUpdate(v55, v56, v57);
                          EVP_DigestFinal(v101[0], (unsigned __int8 *)v52 + v54, 0);
                          EVP_MD_CTX_free(v101[0]);
                          v54 += 32;
                          uint64_t v53 = *(void *)(a1 + 448);
                        }
                        while (v54 < *(int *)(v53 + 24));
                      }
                      if ((*(unsigned int (**)(uint64_t))(v53 + 40))(a1)) {
                        goto LABEL_113;
                      }
                      if (d)
                      {
                        memset_s(v45, *(int *)(*(void *)(a1 + 448) + 20), 0, *(int *)(*(void *)(a1 + 448) + 20));
                        (*(void (**)(void *, uint64_t))(a1 + 24))(v45, a1);
                      }
                      if (__src)
                      {
                        memset_s(v52, *(int *)(*(void *)(a1 + 448) + 24), 0, *(int *)(*(void *)(a1 + 448) + 24));
                        (*(void (**)(void *, uint64_t))(a1 + 24))(v52, a1);
                      }
                    }
                    uint64_t v58 = *(void *)(a1 + 336);
                    uint64_t v59 = *(void (**)(uint64_t, uint64_t))(v58 + 56);
                    if (v59)
                    {
                      v59(a1, a1 + 344);
                      uint64_t v58 = *(void *)(a1 + 336);
                    }
                    if (!*(void *)(v58 + 40)) {
                      goto LABEL_137;
                    }
                    LODWORD(d) = 0;
                    LODWORD(__src) = 0;
                    v101[0] = 0;
                    uint64_t v60 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v58 + 20) + 32, a1);
                    if (!v60)
                    {
LABEL_131:
                      uint64_t v4 = 4294967291;
                      goto LABEL_118;
                    }
                    uint64_t v45 = (void *)v60;
                    uint64_t v61 = *(void *)(a1 + 336);
                    if (*(_DWORD *)(v61 + 20))
                    {
                      unint64_t v62 = 0;
                      do
                      {
                        _libssh2_sha256_init(v101);
                        EVP_DigestUpdate(v101[0], *(const void **)(a2 + 200), *(void *)(a2 + 224));
                        EVP_DigestUpdate(v101[0], (const void *)(a2 + 56), 0x20uLL);
                        uint64_t v63 = v101[0];
                        if (v62)
                        {
                          int v64 = v45;
                          size_t v65 = v62;
                        }
                        else
                        {
                          EVP_DigestUpdate(v101[0], "B", 1uLL);
                          uint64_t v63 = v101[0];
                          int v64 = *(const void **)(a1 + 160);
                          size_t v65 = *(unsigned int *)(a1 + 168);
                        }
                        EVP_DigestUpdate(v63, v64, v65);
                        EVP_DigestFinal(v101[0], (unsigned __int8 *)v45 + v62, 0);
                        EVP_MD_CTX_free(v101[0]);
                        v62 += 32;
                        uint64_t v61 = *(void *)(a1 + 336);
                      }
                      while (v62 < *(int *)(v61 + 20));
                    }
                    v101[0] = 0;
                    uint64_t v66 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v61 + 24) + 32, a1);
                    if (v66)
                    {
                      unsigned int v52 = (void *)v66;
                      uint64_t v67 = *(void *)(a1 + 336);
                      if (*(_DWORD *)(v67 + 24))
                      {
                        unint64_t v68 = 0;
                        do
                        {
                          _libssh2_sha256_init(v101);
                          EVP_DigestUpdate(v101[0], *(const void **)(a2 + 200), *(void *)(a2 + 224));
                          EVP_DigestUpdate(v101[0], (const void *)(a2 + 56), 0x20uLL);
                          uint64_t v69 = v101[0];
                          if (v68)
                          {
                            uint64_t v70 = v52;
                            size_t v71 = v68;
                          }
                          else
                          {
                            EVP_DigestUpdate(v101[0], "D", 1uLL);
                            uint64_t v69 = v101[0];
                            uint64_t v70 = *(const void **)(a1 + 160);
                            size_t v71 = *(unsigned int *)(a1 + 168);
                          }
                          EVP_DigestUpdate(v69, v70, v71);
                          EVP_DigestFinal(v101[0], (unsigned __int8 *)v52 + v68, 0);
                          EVP_MD_CTX_free(v101[0]);
                          v68 += 32;
                          uint64_t v67 = *(void *)(a1 + 336);
                        }
                        while (v68 < *(int *)(v67 + 24));
                      }
                      if ((*(unsigned int (**)(uint64_t))(v67 + 40))(a1))
                      {
LABEL_113:
                        (*(void (**)(void *, uint64_t))(a1 + 24))(v45, a1);
                        (*(void (**)(void *, uint64_t))(a1 + 24))(v52, a1);
                        goto LABEL_131;
                      }
                      if (d)
                      {
                        memset_s(v45, *(int *)(*(void *)(a1 + 336) + 20), 0, *(int *)(*(void *)(a1 + 336) + 20));
                        (*(void (**)(void *, uint64_t))(a1 + 24))(v45, a1);
                      }
                      if (__src)
                      {
                        memset_s(v52, *(int *)(*(void *)(a1 + 336) + 24), 0, *(int *)(*(void *)(a1 + 336) + 24));
                        (*(void (**)(void *, uint64_t))(a1 + 24))(v52, a1);
                      }
LABEL_137:
                      uint64_t v76 = *(void *)(a1 + 464);
                      uint64_t v77 = *(void (**)(uint64_t, uint64_t))(v76 + 32);
                      if (v77)
                      {
                        v77(a1, a1 + 480);
                        uint64_t v76 = *(void *)(a1 + 464);
                      }
                      if (*(void *)(v76 + 16))
                      {
                        LODWORD(d) = 0;
                        v101[0] = 0;
                        uint64_t v78 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v76 + 12) + 32, a1);
                        if (!v78) {
                          goto LABEL_131;
                        }
                        size_t v79 = (void *)v78;
                        uint64_t v80 = *(void *)(a1 + 464);
                        if (*(_DWORD *)(v80 + 12))
                        {
                          unint64_t v81 = 0;
                          do
                          {
                            _libssh2_sha256_init(v101);
                            EVP_DigestUpdate(v101[0], *(const void **)(a2 + 200), *(void *)(a2 + 224));
                            EVP_DigestUpdate(v101[0], (const void *)(a2 + 56), 0x20uLL);
                            uint64_t v82 = v101[0];
                            if (v81)
                            {
                              char v83 = v79;
                              size_t v84 = v81;
                            }
                            else
                            {
                              EVP_DigestUpdate(v101[0], "E", 1uLL);
                              uint64_t v82 = v101[0];
                              char v83 = *(const void **)(a1 + 160);
                              size_t v84 = *(unsigned int *)(a1 + 168);
                            }
                            EVP_DigestUpdate(v82, v83, v84);
                            EVP_DigestFinal(v101[0], (unsigned __int8 *)v79 + v81, 0);
                            EVP_MD_CTX_free(v101[0]);
                            v81 += 32;
                            uint64_t v80 = *(void *)(a1 + 464);
                          }
                          while (v81 < *(int *)(v80 + 12));
                        }
                        (*(void (**)(uint64_t, void *, void **, uint64_t))(v80 + 16))(a1, v79, &d, a1 + 480);
                        if (d)
                        {
                          memset_s(v79, *(int *)(*(void *)(a1 + 464) + 12), 0, *(int *)(*(void *)(a1 + 464) + 12));
                          (*(void (**)(void *, uint64_t))(a1 + 24))(v79, a1);
                        }
                      }
                      uint64_t v85 = *(void *)(a1 + 352);
                      uint64_t v86 = *(void (**)(uint64_t, uint64_t))(v85 + 32);
                      if (v86)
                      {
                        v86(a1, a1 + 368);
                        uint64_t v85 = *(void *)(a1 + 352);
                      }
                      if (*(void *)(v85 + 16))
                      {
                        LODWORD(d) = 0;
                        v101[0] = 0;
                        uint64_t v87 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v85 + 12) + 32, a1);
                        if (!v87) {
                          goto LABEL_131;
                        }
                        uint64_t v88 = (void *)v87;
                        uint64_t v89 = *(void *)(a1 + 352);
                        if (*(_DWORD *)(v89 + 12))
                        {
                          unint64_t v90 = 0;
                          do
                          {
                            _libssh2_sha256_init(v101);
                            EVP_DigestUpdate(v101[0], *(const void **)(a2 + 200), *(void *)(a2 + 224));
                            EVP_DigestUpdate(v101[0], (const void *)(a2 + 56), 0x20uLL);
                            uint64_t v91 = v101[0];
                            if (v90)
                            {
                              unsigned int v92 = v88;
                              size_t v93 = v90;
                            }
                            else
                            {
                              EVP_DigestUpdate(v101[0], "F", 1uLL);
                              uint64_t v91 = v101[0];
                              unsigned int v92 = *(const void **)(a1 + 160);
                              size_t v93 = *(unsigned int *)(a1 + 168);
                            }
                            EVP_DigestUpdate(v91, v92, v93);
                            EVP_DigestFinal(v101[0], (unsigned __int8 *)v88 + v90, 0);
                            EVP_MD_CTX_free(v101[0]);
                            v90 += 32;
                            uint64_t v89 = *(void *)(a1 + 352);
                          }
                          while (v90 < *(int *)(v89 + 12));
                        }
                        (*(void (**)(uint64_t, void *, void **, uint64_t))(v89 + 16))(a1, v88, &d, a1 + 368);
                        if (d)
                        {
                          memset_s(v88, *(int *)(*(void *)(a1 + 352) + 12), 0, *(int *)(*(void *)(a1 + 352) + 12));
                          (*(void (**)(void *, uint64_t))(a1 + 24))(v88, a1);
                        }
                      }
                      uint64_t v94 = *(void *)(a1 + 488);
                      if (!v94
                        || (unsigned int v95 = *(void (**)(uint64_t, uint64_t, uint64_t))(v94 + 40)) != 0
                        && (v95(a1, 1, a1 + 496), (uint64_t v94 = *(void *)(a1 + 488)) == 0)
                        || (unsigned int v96 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v94 + 16)) == 0
                        || !v96(a1, 1, a1 + 496))
                      {
                        uint64_t v97 = *(void *)(a1 + 376);
                        if (v97
                          && ((uint64_t v98 = *(void (**)(uint64_t, void, uint64_t))(v97 + 40)) == 0
                           || (v98(a1, 0, a1 + 384), (uint64_t v97 = *(void *)(a1 + 376)) != 0))
                          && (uint64_t v99 = *(unsigned int (**)(uint64_t, void, uint64_t))(v97 + 16)) != 0)
                        {
                          if (v99(a1, 0, a1 + 384)) {
                            uint64_t v4 = 4294967291;
                          }
                          else {
                            uint64_t v4 = 0;
                          }
                        }
                        else
                        {
                          uint64_t v4 = 0;
                        }
                        goto LABEL_118;
                      }
                      goto LABEL_131;
                    }
LABEL_130:
                    (*(void (**)(void *, uint64_t))(a1 + 24))(v45, a1);
                    goto LABEL_131;
                  }
                  size_t v17 = "Unable to allocate buffer for SHA digest";
LABEL_31:
                  uint64_t v18 = a1;
                  uint64_t v19 = 4294967290;
                  goto LABEL_117;
                }
                size_t v17 = "Timed out waiting for NEWKEYS curve25519";
              }
              uint64_t v18 = a1;
              uint64_t v19 = v4;
              goto LABEL_117;
            }
            size_t v17 = "Unable to allocate memory for a copy of the host curve25519 key";
            goto LABEL_31;
          case 3:
            goto LABEL_65;
          case 5:
            goto LABEL_68;
          default:
            goto LABEL_118;
        }
      }
      uint64_t v4 = _libssh2_error(a1, 4294967286, "Data is too short");
LABEL_121:
      if (v4 != -37)
      {
        (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(a2 + 544), a1);
        goto LABEL_123;
      }
      return v4;
    case 3:
      size_t v10 = *(void *)(a2 + 552);
      goto LABEL_10;
    case 4:
      goto LABEL_13;
    case 5:
      goto LABEL_16;
    default:
      goto LABEL_123;
  }
}

uint64_t kex_method_ecdh_key_exchange(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 0;
  uint64_t v16 = 0;
  int v15 = 0;
  switch(*(_DWORD *)a2)
  {
    case 0:
      *(void *)(a2 + 576) = 0;
      *(_DWORD *)a2 = 2;
      goto LABEL_3;
    case 2:
LABEL_3:
      if (kex_session_ecdh_curve_type(**(const char ***)(a1 + 144), &v15)) {
        goto LABEL_15;
      }
      uint64_t key = _libssh2_ecdsa_create_key(a1, (EC_KEY **)(a2 + 568), (void *)(a2 + 576), (size_t *)(a2 + 584), v15);
      if (key)
      {
        uint64_t v6 = key;
        uint64_t v7 = "Unable to create private key";
        uint64_t v8 = a1;
        goto LABEL_21;
      }
      *(unsigned char *)(a2 + 288) = 30;
      uint64_t v16 = (_DWORD *)(a2 + 289);
      _libssh2_store_str(&v16, *(const void **)(a2 + 576), *(void *)(a2 + 584));
      size_t v9 = *(void *)(a2 + 584) + 5;
      *(void *)(a2 + 552) = v9;
      *(_DWORD *)a2 = 3;
LABEL_8:
      uint64_t v10 = _libssh2_transport_send(a1, (void *)(a2 + 288), v9, 0, 0);
      uint64_t v4 = v10;
      if (v10 == -37) {
        return v4;
      }
      if (v10)
      {
        uint64_t v7 = "Unable to send ECDH_INIT";
        goto LABEL_20;
      }
      *(_DWORD *)a2 = 4;
LABEL_11:
      uint64_t v11 = _libssh2_packet_require(a1, 31, (void *)(a2 + 544), (unint64_t *)(a2 + 560), 0, 0, 0, a2 + 8);
      uint64_t v4 = v11;
      if (v11 != -37)
      {
        if (!v11)
        {
          *(_DWORD *)a2 = 5;
LABEL_14:
          if (!kex_session_ecdh_curve_type(**(const char ***)(a1 + 144), &v15))
          {
            uint64_t v4 = ecdh_sha2_nistp(a1, v15, *(void *)(a2 + 544), *(EVP_MD_CTX **)(a2 + 560), *(const void **)(a2 + 576), *(void *)(a2 + 584), *(const EC_KEY **)(a2 + 568), a2 + 24);
            if (v4 == -37) {
              return v4;
            }
            (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(a2 + 544), a1);
            goto LABEL_22;
          }
LABEL_15:
          uint64_t v7 = "Unknown KEX nistp curve type";
          uint64_t v8 = a1;
          uint64_t v6 = 0xFFFFFFFFLL;
LABEL_21:
          uint64_t v4 = _libssh2_error(v8, v6, v7);
LABEL_22:
          uint64_t v12 = *(void *)(a2 + 576);
          if (v12)
          {
            (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v12, a1);
            *(void *)(a2 + 576) = 0;
          }
          size_t v13 = *(EC_KEY **)(a2 + 568);
          if (v13)
          {
            EC_KEY_free(v13);
            *(void *)(a2 + 568) = 0;
          }
          *(_DWORD *)a2 = 0;
          return v4;
        }
        uint64_t v7 = "Timeout waiting for ECDH_REPLY reply";
LABEL_20:
        uint64_t v8 = a1;
        uint64_t v6 = v4;
        goto LABEL_21;
      }
      return v4;
    case 3:
      size_t v9 = *(void *)(a2 + 552);
      goto LABEL_8;
    case 4:
      goto LABEL_11;
    case 5:
      goto LABEL_14;
    default:
      goto LABEL_22;
  }
}

uint64_t kex_session_ecdh_curve_type(const char *a1, int *a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = strcmp(a1, "ecdh-sha2-nistp256");
  if (!result)
  {
    int v8 = 415;
    goto LABEL_15;
  }
  uint64_t result = strcmp(a1, "ecdh-sha2-nistp384");
  if (!result)
  {
    int v8 = 715;
LABEL_15:
    BOOL v7 = 1;
    if (!a2) {
      return result;
    }
    goto LABEL_16;
  }
  int v5 = strcmp(a1, "ecdh-sha2-nistp521");
  BOOL v6 = v5 == 0;
  BOOL v7 = v5 == 0;
  if (v5) {
    uint64_t result = 0xFFFFFFFFLL;
  }
  else {
    uint64_t result = 0;
  }
  if (v6) {
    int v8 = 716;
  }
  else {
    int v8 = 0;
  }
  if (a2)
  {
LABEL_16:
    if (v7) {
      *a2 = v8;
    }
  }
  return result;
}

uint64_t ecdh_sha2_nistp(uint64_t a1, int a2, uint64_t a3, EVP_MD_CTX *a4, const void *a5, size_t a6, const EC_KEY *a7, uint64_t a8)
{
  if ((unint64_t)a4 > 4)
  {
    uint64_t v11 = 0;
    switch(*(_DWORD *)a8)
    {
      case 0:
        *(void *)(a8 + 160) = BN_new();
        *(_DWORD *)a8 = 2;
        goto LABEL_7;
      case 2:
LABEL_7:
        size_t v149 = 0;
        uint64_t v150 = 0;
        v148[0] = (EVP_MD_CTX *)a3;
        v148[1] = (EVP_MD_CTX *)(a3 + 1);
        v148[2] = a4;
        if (_libssh2_copy_string(a1, v148, (void *)(a1 + 200), &v149))
        {
          uint64_t v18 = "Unable to allocate memory for a copy of the host ECDH key";
LABEL_9:
          uint64_t v19 = a1;
          uint64_t v20 = 4294967290;
LABEL_68:
          uint64_t v11 = _libssh2_error(v19, v20, v18);
          goto LABEL_69;
        }
        *(_DWORD *)(a1 + 208) = v149;
        ctx = 0;
        if (_libssh2_md5_init(&ctx))
        {
          EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
          EVP_DigestFinal(ctx, (unsigned __int8 *)(a1 + 212), 0);
          EVP_MD_CTX_free(ctx);
          int v21 = 1;
        }
        else
        {
          int v21 = 0;
        }
        *(_DWORD *)(a1 + 228) = v21;
        ctx = 0;
        if (_libssh2_sha1_init(&ctx))
        {
          EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
          EVP_DigestFinal(ctx, (unsigned __int8 *)(a1 + 232), 0);
          EVP_MD_CTX_free(ctx);
          int v22 = 1;
        }
        else
        {
          int v22 = 0;
        }
        *(_DWORD *)(a1 + 252) = v22;
        ctx = 0;
        if (_libssh2_sha256_init(&ctx))
        {
          EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
          EVP_DigestFinal(ctx, (unsigned __int8 *)(a1 + 256), 0);
          EVP_MD_CTX_free(ctx);
          int v23 = 1;
        }
        else
        {
          int v23 = 0;
        }
        *(_DWORD *)(a1 + 288) = v23;
        if ((*(unsigned int (**)(uint64_t, void, void, uint64_t))(*(void *)(a1 + 184) + 16))(a1, *(void *)(a1 + 200), *(unsigned int *)(a1 + 208), a1 + 192))
        {
          uint64_t v18 = "Unable to initialize hostkey importer ECDH";
LABEL_21:
          uint64_t v19 = a1;
          uint64_t v20 = 4294967286;
          goto LABEL_68;
        }
        if (_libssh2_get_string(v148, &v150, &v149))
        {
          uint64_t v18 = "Unexpected key length ECDH";
          uint64_t v19 = a1;
          uint64_t v20 = 4294967282;
          goto LABEL_68;
        }
        if (_libssh2_get_string(v148, (void *)(a8 + 184), (void *)(a8 + 208)))
        {
          uint64_t v18 = "Unexpected ECDH server sig length";
          goto LABEL_21;
        }
        if (_libssh2_ecdh_gen_k((BIGNUM **)(a8 + 160), a7, v150, v149))
        {
          uint64_t v18 = "Unable to create ECDH shared secret";
LABEL_101:
          uint64_t v19 = a1;
          uint64_t v20 = 4294967291;
          goto LABEL_68;
        }
        int v24 = BN_num_bits(*(const BIGNUM **)(a8 + 160));
        int v25 = v24 + 7;
        if (v24 < -7) {
          int v25 = v24 + 14;
        }
        *(void *)(a8 + 200) = (v25 >> 3) + 5;
        char v26 = BN_num_bits(*(const BIGNUM **)(a8 + 160));
        uint64_t v27 = *(void *)(a8 + 200);
        if ((v26 & 7) != 0) {
          *(void *)(a8 + 200) = --v27;
        }
        uint64_t v28 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(v27, a1);
        *(void *)(a8 + 176) = v28;
        if (!v28)
        {
          uint64_t v18 = "Unable to allocate buffer for ECDH K";
          goto LABEL_9;
        }
        _libssh2_htonu32(v28, *(_DWORD *)(a8 + 200) - 4);
        if ((BN_num_bits(*(const BIGNUM **)(a8 + 160)) & 7) != 0)
        {
          uint64_t v29 = 4;
        }
        else
        {
          *(unsigned char *)(*(void *)(a8 + 176) + 4) = 0;
          uint64_t v29 = 5;
        }
        BN_bn2bin(*(const BIGNUM **)(a8 + 160), (unsigned __int8 *)(*(void *)(a8 + 176) + v29));
        switch(a2)
        {
          case 716:
            ctx = 0;
            *(void *)(a8 + 216) = &ctx;
            _libssh2_sha512_init(&ctx);
            uint64_t v35 = *(const char **)(a1 + 424);
            if (v35)
            {
              int v36 = strlen(v35);
              _libssh2_htonu32((_DWORD *)(a8 + 32), v36 - 2);
              EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
              size_t v37 = strlen(*(const char **)(a1 + 424)) - 2;
              uint64_t v38 = ctx;
              uint64_t v39 = *(const char **)(a1 + 424);
            }
            else
            {
              _libssh2_htonu32((_DWORD *)(a8 + 32), 0x16u);
              EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
              uint64_t v38 = ctx;
              uint64_t v39 = "SSH-2.0-libssh2_1.11.0";
              size_t v37 = 22;
            }
            EVP_DigestUpdate(v38, v39, v37);
            unsigned int v48 = strlen(*(const char **)(a1 + 312));
            _libssh2_htonu32((_DWORD *)(a8 + 32), v48);
            EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
            size_t v49 = strlen(*(const char **)(a1 + 312));
            EVP_DigestUpdate(ctx, *(const void **)(a1 + 312), v49);
            _libssh2_htonu32((_DWORD *)(a8 + 32), *(_DWORD *)(a1 + 440));
            EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
            EVP_DigestUpdate(ctx, *(const void **)(a1 + 432), *(void *)(a1 + 440));
            _libssh2_htonu32((_DWORD *)(a8 + 32), *(_DWORD *)(a1 + 328));
            EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
            EVP_DigestUpdate(ctx, *(const void **)(a1 + 320), *(void *)(a1 + 328));
            _libssh2_htonu32((_DWORD *)(a8 + 32), *(_DWORD *)(a1 + 208));
            EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
            EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
            _libssh2_htonu32((_DWORD *)(a8 + 32), a6);
            EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
            EVP_DigestUpdate(ctx, a5, a6);
            _libssh2_htonu32((_DWORD *)(a8 + 32), v149);
            EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
            EVP_DigestUpdate(ctx, v150, v149);
            EVP_DigestUpdate(ctx, *(const void **)(a8 + 176), *(void *)(a8 + 200));
            EVP_DigestFinal(ctx, (unsigned __int8 *)(a8 + 32), 0);
            EVP_MD_CTX_free(ctx);
            int v47 = (*(uint64_t (**)(uint64_t, void, void, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 184)
                                                                                                + 40))(a1, *(void *)(a8 + 184), *(void *)(a8 + 208), a8 + 32, 64, a1 + 192);
            break;
          case 715:
            ctx = 0;
            *(void *)(a8 + 216) = &ctx;
            _libssh2_sha384_init(&ctx);
            size_t v40 = *(const char **)(a1 + 424);
            if (v40)
            {
              int v41 = strlen(v40);
              _libssh2_htonu32((_DWORD *)(a8 + 32), v41 - 2);
              EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
              size_t v42 = strlen(*(const char **)(a1 + 424)) - 2;
              size_t v43 = ctx;
              uint64_t v44 = *(const char **)(a1 + 424);
            }
            else
            {
              _libssh2_htonu32((_DWORD *)(a8 + 32), 0x16u);
              EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
              size_t v43 = ctx;
              uint64_t v44 = "SSH-2.0-libssh2_1.11.0";
              size_t v42 = 22;
            }
            EVP_DigestUpdate(v43, v44, v42);
            unsigned int v50 = strlen(*(const char **)(a1 + 312));
            _libssh2_htonu32((_DWORD *)(a8 + 32), v50);
            EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
            size_t v51 = strlen(*(const char **)(a1 + 312));
            EVP_DigestUpdate(ctx, *(const void **)(a1 + 312), v51);
            _libssh2_htonu32((_DWORD *)(a8 + 32), *(_DWORD *)(a1 + 440));
            EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
            EVP_DigestUpdate(ctx, *(const void **)(a1 + 432), *(void *)(a1 + 440));
            _libssh2_htonu32((_DWORD *)(a8 + 32), *(_DWORD *)(a1 + 328));
            EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
            EVP_DigestUpdate(ctx, *(const void **)(a1 + 320), *(void *)(a1 + 328));
            _libssh2_htonu32((_DWORD *)(a8 + 32), *(_DWORD *)(a1 + 208));
            EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
            EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
            _libssh2_htonu32((_DWORD *)(a8 + 32), a6);
            EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
            EVP_DigestUpdate(ctx, a5, a6);
            _libssh2_htonu32((_DWORD *)(a8 + 32), v149);
            EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
            EVP_DigestUpdate(ctx, v150, v149);
            EVP_DigestUpdate(ctx, *(const void **)(a8 + 176), *(void *)(a8 + 200));
            EVP_DigestFinal(ctx, (unsigned __int8 *)(a8 + 32), 0);
            EVP_MD_CTX_free(ctx);
            int v47 = (*(uint64_t (**)(uint64_t, void, void, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 184)
                                                                                                + 40))(a1, *(void *)(a8 + 184), *(void *)(a8 + 208), a8 + 32, 48, a1 + 192);
            break;
          case 415:
            ctx = 0;
            *(void *)(a8 + 216) = &ctx;
            _libssh2_sha256_init(&ctx);
            uint64_t v30 = *(const char **)(a1 + 424);
            if (v30)
            {
              int v31 = strlen(v30);
              _libssh2_htonu32((_DWORD *)(a8 + 32), v31 - 2);
              EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
              size_t v32 = strlen(*(const char **)(a1 + 424)) - 2;
              size_t v33 = ctx;
              uint64_t v34 = *(const char **)(a1 + 424);
            }
            else
            {
              _libssh2_htonu32((_DWORD *)(a8 + 32), 0x16u);
              EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
              size_t v33 = ctx;
              uint64_t v34 = "SSH-2.0-libssh2_1.11.0";
              size_t v32 = 22;
            }
            EVP_DigestUpdate(v33, v34, v32);
            unsigned int v45 = strlen(*(const char **)(a1 + 312));
            _libssh2_htonu32((_DWORD *)(a8 + 32), v45);
            EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
            size_t v46 = strlen(*(const char **)(a1 + 312));
            EVP_DigestUpdate(ctx, *(const void **)(a1 + 312), v46);
            _libssh2_htonu32((_DWORD *)(a8 + 32), *(_DWORD *)(a1 + 440));
            EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
            EVP_DigestUpdate(ctx, *(const void **)(a1 + 432), *(void *)(a1 + 440));
            _libssh2_htonu32((_DWORD *)(a8 + 32), *(_DWORD *)(a1 + 328));
            EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
            EVP_DigestUpdate(ctx, *(const void **)(a1 + 320), *(void *)(a1 + 328));
            _libssh2_htonu32((_DWORD *)(a8 + 32), *(_DWORD *)(a1 + 208));
            EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
            EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
            _libssh2_htonu32((_DWORD *)(a8 + 32), a6);
            EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
            EVP_DigestUpdate(ctx, a5, a6);
            _libssh2_htonu32((_DWORD *)(a8 + 32), v149);
            EVP_DigestUpdate(ctx, (const void *)(a8 + 32), 4uLL);
            EVP_DigestUpdate(ctx, v150, v149);
            EVP_DigestUpdate(ctx, *(const void **)(a8 + 176), *(void *)(a8 + 200));
            EVP_DigestFinal(ctx, (unsigned __int8 *)(a8 + 32), 0);
            EVP_MD_CTX_free(ctx);
            int v47 = (*(uint64_t (**)(uint64_t, void, void, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 184)
                                                                                                + 40))(a1, *(void *)(a8 + 184), *(void *)(a8 + 208), a8 + 32, 32, a1 + 192);
            break;
          default:
            goto LABEL_54;
        }
        if (v47)
        {
          uint64_t v18 = "Unable to verify hostkey signature ECDH";
          uint64_t v19 = a1;
          uint64_t v20 = 4294967285;
          goto LABEL_68;
        }
LABEL_54:
        *(unsigned char *)(a8 + 96) = 21;
        *(_DWORD *)a8 = 3;
LABEL_55:
        uint64_t v52 = _libssh2_transport_send(a1, (void *)(a8 + 96), 1uLL, 0, 0);
        uint64_t v11 = v52;
        if (v52 != -37)
        {
          if (v52)
          {
            uint64_t v18 = "Unable to send NEWKEYS message ECDH";
            goto LABEL_67;
          }
          *(_DWORD *)a8 = 5;
LABEL_58:
          uint64_t v53 = _libssh2_packet_require(a1, 21, (void *)(a8 + 24), (unint64_t *)(a8 + 120), 0, 0, 0, a8 + 224);
          uint64_t v11 = v53;
          if (v53 != -37)
          {
            if (!v53)
            {
              *(_DWORD *)(a1 + 128) |= 2u;
              (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(a8 + 24), a1);
              if (!*(void *)(a1 + 160))
              {
                switch(a2)
                {
                  case 415:
                    size_t v54 = 32;
                    break;
                  case 716:
                    size_t v54 = 64;
                    break;
                  case 715:
                    size_t v54 = 48;
                    break;
                  default:
                    uint64_t v18 = "Unknown SHA digest for EC curve";
                    goto LABEL_101;
                }
                unint64_t v56 = (void *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v54, a1);
                *(void *)(a1 + 160) = v56;
                if (!v56)
                {
                  uint64_t v18 = "Unable to allocate buffer for SHA digest";
                  goto LABEL_9;
                }
                memcpy(v56, (const void *)(a8 + 32), v54);
                *(_DWORD *)(a1 + 168) = v54;
              }
              uint64_t v57 = *(void *)(a1 + 448);
              uint64_t v58 = *(void (**)(uint64_t, uint64_t))(v57 + 56);
              if (v58)
              {
                v58(a1, a1 + 456);
                uint64_t v57 = *(void *)(a1 + 448);
              }
              if (!*(void *)(v57 + 40)) {
                goto LABEL_142;
              }
              LODWORD(v150) = 0;
              LODWORD(v149) = 0;
              switch(a2)
              {
                case 415:
                  v148[0] = 0;
                  uint64_t v59 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v57 + 20) + 32, a1);
                  if (v59 && *(_DWORD *)(*(void *)(a1 + 448) + 20))
                  {
                    unint64_t v60 = 0;
                    do
                    {
                      _libssh2_sha256_init(v148);
                      EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(void *)(a8 + 200));
                      EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x20uLL);
                      uint64_t v61 = v148[0];
                      if (v60)
                      {
                        unint64_t v62 = v59;
                        size_t v63 = v60;
                      }
                      else
                      {
                        EVP_DigestUpdate(v148[0], "A", 1uLL);
                        uint64_t v61 = v148[0];
                        unint64_t v62 = *(const void **)(a1 + 160);
                        size_t v63 = *(unsigned int *)(a1 + 168);
                      }
                      EVP_DigestUpdate(v61, v62, v63);
                      EVP_DigestFinal(v148[0], (unsigned __int8 *)v59 + v60, 0);
                      EVP_MD_CTX_free(v148[0]);
                      v60 += 32;
                    }
                    while (v60 < *(int *)(*(void *)(a1 + 448) + 20));
                  }
                  break;
                case 716:
                  v148[0] = 0;
                  uint64_t v59 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v57 + 20) + 64, a1);
                  if (v59 && *(_DWORD *)(*(void *)(a1 + 448) + 20))
                  {
                    unint64_t v68 = 0;
                    do
                    {
                      _libssh2_sha512_init(v148);
                      EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(void *)(a8 + 200));
                      EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x40uLL);
                      uint64_t v69 = v148[0];
                      if (v68)
                      {
                        uint64_t v70 = v59;
                        size_t v71 = v68;
                      }
                      else
                      {
                        EVP_DigestUpdate(v148[0], "A", 1uLL);
                        uint64_t v69 = v148[0];
                        uint64_t v70 = *(const void **)(a1 + 160);
                        size_t v71 = *(unsigned int *)(a1 + 168);
                      }
                      EVP_DigestUpdate(v69, v70, v71);
                      EVP_DigestFinal(v148[0], (unsigned __int8 *)v59 + v68, 0);
                      EVP_MD_CTX_free(v148[0]);
                      v68 += 64;
                    }
                    while (v68 < *(int *)(*(void *)(a1 + 448) + 20));
                  }
                  break;
                case 715:
                  v148[0] = 0;
                  uint64_t v59 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v57 + 20) + 48, a1);
                  if (v59 && *(_DWORD *)(*(void *)(a1 + 448) + 20))
                  {
                    unint64_t v64 = 0;
                    do
                    {
                      _libssh2_sha384_init(v148);
                      EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(void *)(a8 + 200));
                      EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x30uLL);
                      size_t v65 = v148[0];
                      if (v64)
                      {
                        uint64_t v66 = v59;
                        size_t v67 = v64;
                      }
                      else
                      {
                        EVP_DigestUpdate(v148[0], "A", 1uLL);
                        size_t v65 = v148[0];
                        uint64_t v66 = *(const void **)(a1 + 160);
                        size_t v67 = *(unsigned int *)(a1 + 168);
                      }
                      EVP_DigestUpdate(v65, v66, v67);
                      EVP_DigestFinal(v148[0], (unsigned __int8 *)v59 + v64, 0);
                      EVP_MD_CTX_free(v148[0]);
                      v64 += 48;
                    }
                    while (v64 < *(int *)(*(void *)(a1 + 448) + 20));
                  }
                  break;
                default:
                  goto LABEL_119;
              }
              if (v59)
              {
                if (a2 == 415)
                {
                  v148[0] = 0;
                  uint64_t v72 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(*(void *)(a1 + 448) + 24) + 32, a1);
                  if (v72 && *(_DWORD *)(*(void *)(a1 + 448) + 24))
                  {
                    unint64_t v73 = 0;
                    do
                    {
                      _libssh2_sha256_init(v148);
                      EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(void *)(a8 + 200));
                      EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x20uLL);
                      unint64_t v74 = v148[0];
                      if (v73)
                      {
                        uint64_t v75 = v72;
                        size_t v76 = v73;
                      }
                      else
                      {
                        EVP_DigestUpdate(v148[0], "C", 1uLL);
                        unint64_t v74 = v148[0];
                        uint64_t v75 = *(const void **)(a1 + 160);
                        size_t v76 = *(unsigned int *)(a1 + 168);
                      }
                      EVP_DigestUpdate(v74, v75, v76);
                      EVP_DigestFinal(v148[0], (unsigned __int8 *)v72 + v73, 0);
                      EVP_MD_CTX_free(v148[0]);
                      v73 += 32;
                    }
                    while (v73 < *(int *)(*(void *)(a1 + 448) + 24));
                  }
                }
                else if (a2 == 716)
                {
                  v148[0] = 0;
                  uint64_t v72 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(*(void *)(a1 + 448) + 24) + 64, a1);
                  if (v72 && *(_DWORD *)(*(void *)(a1 + 448) + 24))
                  {
                    unint64_t v81 = 0;
                    do
                    {
                      _libssh2_sha512_init(v148);
                      EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(void *)(a8 + 200));
                      EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x40uLL);
                      uint64_t v82 = v148[0];
                      if (v81)
                      {
                        char v83 = v72;
                        size_t v84 = v81;
                      }
                      else
                      {
                        EVP_DigestUpdate(v148[0], "C", 1uLL);
                        uint64_t v82 = v148[0];
                        char v83 = *(const void **)(a1 + 160);
                        size_t v84 = *(unsigned int *)(a1 + 168);
                      }
                      EVP_DigestUpdate(v82, v83, v84);
                      EVP_DigestFinal(v148[0], (unsigned __int8 *)v72 + v81, 0);
                      EVP_MD_CTX_free(v148[0]);
                      v81 += 64;
                    }
                    while (v81 < *(int *)(*(void *)(a1 + 448) + 24));
                  }
                }
                else
                {
                  v148[0] = 0;
                  uint64_t v72 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(*(void *)(a1 + 448) + 24) + 48, a1);
                  if (v72 && *(_DWORD *)(*(void *)(a1 + 448) + 24))
                  {
                    unint64_t v77 = 0;
                    do
                    {
                      _libssh2_sha384_init(v148);
                      EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(void *)(a8 + 200));
                      EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x30uLL);
                      uint64_t v78 = v148[0];
                      if (v77)
                      {
                        size_t v79 = v72;
                        size_t v80 = v77;
                      }
                      else
                      {
                        EVP_DigestUpdate(v148[0], "C", 1uLL);
                        uint64_t v78 = v148[0];
                        size_t v79 = *(const void **)(a1 + 160);
                        size_t v80 = *(unsigned int *)(a1 + 168);
                      }
                      EVP_DigestUpdate(v78, v79, v80);
                      EVP_DigestFinal(v148[0], (unsigned __int8 *)v72 + v77, 0);
                      EVP_MD_CTX_free(v148[0]);
                      v77 += 48;
                    }
                    while (v77 < *(int *)(*(void *)(a1 + 448) + 24));
                  }
                }
                if (!v72) {
                  goto LABEL_200;
                }
                if ((*(unsigned int (**)(uint64_t))(*(void *)(a1 + 448) + 40))(a1))
                {
LABEL_199:
                  (*(void (**)(void *, uint64_t))(a1 + 24))(v59, a1);
LABEL_201:
                  (*(void (**)(void *, uint64_t))(a1 + 24))(v72, a1);
                  goto LABEL_202;
                }
                if (v150)
                {
                  memset_s(v59, *(int *)(*(void *)(a1 + 448) + 20), 0, *(int *)(*(void *)(a1 + 448) + 20));
                  (*(void (**)(void *, uint64_t))(a1 + 24))(v59, a1);
                }
                if (v149)
                {
                  memset_s(v72, *(int *)(*(void *)(a1 + 448) + 24), 0, *(int *)(*(void *)(a1 + 448) + 24));
                  (*(void (**)(void *, uint64_t))(a1 + 24))(v72, a1);
                }
LABEL_142:
                uint64_t v85 = *(void *)(a1 + 336);
                uint64_t v86 = *(void (**)(uint64_t, uint64_t))(v85 + 56);
                if (v86)
                {
                  v86(a1, a1 + 344);
                  uint64_t v85 = *(void *)(a1 + 336);
                }
                if (!*(void *)(v85 + 40))
                {
LABEL_207:
                  uint64_t v111 = *(void *)(a1 + 464);
                  id v112 = *(void (**)(uint64_t, uint64_t))(v111 + 32);
                  if (v112)
                  {
                    v112(a1, a1 + 480);
                    uint64_t v111 = *(void *)(a1 + 464);
                  }
                  if (*(void *)(v111 + 16))
                  {
                    LODWORD(v150) = 0;
                    switch(a2)
                    {
                      case 716:
                        v148[0] = 0;
                        id v113 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v111 + 12) + 64, a1);
                        if (v113 && *(_DWORD *)(*(void *)(a1 + 464) + 12))
                        {
                          unint64_t v118 = 0;
                          do
                          {
                            _libssh2_sha512_init(v148);
                            EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(void *)(a8 + 200));
                            EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x40uLL);
                            uint64_t v119 = v148[0];
                            if (v118)
                            {
                              uint64_t v120 = v113;
                              size_t v121 = v118;
                            }
                            else
                            {
                              EVP_DigestUpdate(v148[0], "E", 1uLL);
                              uint64_t v119 = v148[0];
                              uint64_t v120 = *(const void **)(a1 + 160);
                              size_t v121 = *(unsigned int *)(a1 + 168);
                            }
                            EVP_DigestUpdate(v119, v120, v121);
                            EVP_DigestFinal(v148[0], (unsigned __int8 *)v113 + v118, 0);
                            EVP_MD_CTX_free(v148[0]);
                            v118 += 64;
                          }
                          while (v118 < *(int *)(*(void *)(a1 + 464) + 12));
                        }
                        break;
                      case 715:
                        v148[0] = 0;
                        id v113 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v111 + 12) + 48, a1);
                        if (v113 && *(_DWORD *)(*(void *)(a1 + 464) + 12))
                        {
                          unint64_t v122 = 0;
                          do
                          {
                            _libssh2_sha384_init(v148);
                            EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(void *)(a8 + 200));
                            EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x30uLL);
                            uint64_t v123 = v148[0];
                            if (v122)
                            {
                              id v124 = v113;
                              size_t v125 = v122;
                            }
                            else
                            {
                              EVP_DigestUpdate(v148[0], "E", 1uLL);
                              uint64_t v123 = v148[0];
                              id v124 = *(const void **)(a1 + 160);
                              size_t v125 = *(unsigned int *)(a1 + 168);
                            }
                            EVP_DigestUpdate(v123, v124, v125);
                            EVP_DigestFinal(v148[0], (unsigned __int8 *)v113 + v122, 0);
                            EVP_MD_CTX_free(v148[0]);
                            v122 += 48;
                          }
                          while (v122 < *(int *)(*(void *)(a1 + 464) + 12));
                        }
                        break;
                      case 415:
                        v148[0] = 0;
                        id v113 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v111 + 12) + 32, a1);
                        if (v113 && *(_DWORD *)(*(void *)(a1 + 464) + 12))
                        {
                          unint64_t v114 = 0;
                          do
                          {
                            _libssh2_sha256_init(v148);
                            EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(void *)(a8 + 200));
                            EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x20uLL);
                            uint64_t v115 = v148[0];
                            if (v114)
                            {
                              uint64_t v116 = v113;
                              size_t v117 = v114;
                            }
                            else
                            {
                              EVP_DigestUpdate(v148[0], "E", 1uLL);
                              uint64_t v115 = v148[0];
                              uint64_t v116 = *(const void **)(a1 + 160);
                              size_t v117 = *(unsigned int *)(a1 + 168);
                            }
                            EVP_DigestUpdate(v115, v116, v117);
                            EVP_DigestFinal(v148[0], (unsigned __int8 *)v113 + v114, 0);
                            EVP_MD_CTX_free(v148[0]);
                            v114 += 32;
                          }
                          while (v114 < *(int *)(*(void *)(a1 + 464) + 12));
                        }
                        break;
                      default:
                        goto LABEL_202;
                    }
                    if (!v113) {
                      goto LABEL_202;
                    }
                    (*(void (**)(uint64_t, void *, const unsigned __int8 **, uint64_t))(*(void *)(a1 + 464)
                                                                                               + 16))(a1, v113, &v150, a1 + 480);
                    if (v150)
                    {
                      memset_s(v113, *(int *)(*(void *)(a1 + 464) + 12), 0, *(int *)(*(void *)(a1 + 464) + 12));
                      (*(void (**)(void *, uint64_t))(a1 + 24))(v113, a1);
                    }
                  }
                  uint64_t v126 = *(void *)(a1 + 352);
                  uint64_t v127 = *(void (**)(uint64_t, uint64_t))(v126 + 32);
                  if (v127)
                  {
                    v127(a1, a1 + 368);
                    uint64_t v126 = *(void *)(a1 + 352);
                  }
                  if (*(void *)(v126 + 16))
                  {
                    LODWORD(v150) = 0;
                    switch(a2)
                    {
                      case 716:
                        v148[0] = 0;
                        uint64_t v128 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v126 + 12) + 64, a1);
                        if (v128 && *(_DWORD *)(*(void *)(a1 + 352) + 12))
                        {
                          unint64_t v133 = 0;
                          do
                          {
                            _libssh2_sha512_init(v148);
                            EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(void *)(a8 + 200));
                            EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x40uLL);
                            id v134 = v148[0];
                            if (v133)
                            {
                              id v135 = v128;
                              size_t v136 = v133;
                            }
                            else
                            {
                              EVP_DigestUpdate(v148[0], "F", 1uLL);
                              id v134 = v148[0];
                              id v135 = *(const void **)(a1 + 160);
                              size_t v136 = *(unsigned int *)(a1 + 168);
                            }
                            EVP_DigestUpdate(v134, v135, v136);
                            EVP_DigestFinal(v148[0], (unsigned __int8 *)v128 + v133, 0);
                            EVP_MD_CTX_free(v148[0]);
                            v133 += 64;
                          }
                          while (v133 < *(int *)(*(void *)(a1 + 352) + 12));
                        }
                        break;
                      case 715:
                        v148[0] = 0;
                        uint64_t v128 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v126 + 12) + 48, a1);
                        if (v128 && *(_DWORD *)(*(void *)(a1 + 352) + 12))
                        {
                          unint64_t v137 = 0;
                          do
                          {
                            _libssh2_sha384_init(v148);
                            EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(void *)(a8 + 200));
                            EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x30uLL);
                            uint64_t v138 = v148[0];
                            if (v137)
                            {
                              uint64_t v139 = v128;
                              size_t v140 = v137;
                            }
                            else
                            {
                              EVP_DigestUpdate(v148[0], "F", 1uLL);
                              uint64_t v138 = v148[0];
                              uint64_t v139 = *(const void **)(a1 + 160);
                              size_t v140 = *(unsigned int *)(a1 + 168);
                            }
                            EVP_DigestUpdate(v138, v139, v140);
                            EVP_DigestFinal(v148[0], (unsigned __int8 *)v128 + v137, 0);
                            EVP_MD_CTX_free(v148[0]);
                            v137 += 48;
                          }
                          while (v137 < *(int *)(*(void *)(a1 + 352) + 12));
                        }
                        break;
                      case 415:
                        v148[0] = 0;
                        uint64_t v128 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v126 + 12) + 32, a1);
                        if (v128 && *(_DWORD *)(*(void *)(a1 + 352) + 12))
                        {
                          unint64_t v129 = 0;
                          do
                          {
                            _libssh2_sha256_init(v148);
                            EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(void *)(a8 + 200));
                            EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x20uLL);
                            uint64_t v130 = v148[0];
                            if (v129)
                            {
                              uint64_t v131 = v128;
                              size_t v132 = v129;
                            }
                            else
                            {
                              EVP_DigestUpdate(v148[0], "F", 1uLL);
                              uint64_t v130 = v148[0];
                              uint64_t v131 = *(const void **)(a1 + 160);
                              size_t v132 = *(unsigned int *)(a1 + 168);
                            }
                            EVP_DigestUpdate(v130, v131, v132);
                            EVP_DigestFinal(v148[0], (unsigned __int8 *)v128 + v129, 0);
                            EVP_MD_CTX_free(v148[0]);
                            v129 += 32;
                          }
                          while (v129 < *(int *)(*(void *)(a1 + 352) + 12));
                        }
                        break;
                      default:
                        goto LABEL_202;
                    }
                    if (!v128) {
                      goto LABEL_202;
                    }
                    (*(void (**)(uint64_t, void *, const unsigned __int8 **, uint64_t))(*(void *)(a1 + 352)
                                                                                               + 16))(a1, v128, &v150, a1 + 368);
                    if (v150)
                    {
                      memset_s(v128, *(int *)(*(void *)(a1 + 352) + 12), 0, *(int *)(*(void *)(a1 + 352) + 12));
                      (*(void (**)(void *, uint64_t))(a1 + 24))(v128, a1);
                    }
                  }
                  uint64_t v141 = *(void *)(a1 + 488);
                  if (!v141
                    || (uint64_t v142 = *(void (**)(uint64_t, uint64_t, uint64_t))(v141 + 40)) != 0
                    && (v142(a1, 1, a1 + 496), (uint64_t v141 = *(void *)(a1 + 488)) == 0)
                    || (uint64_t v143 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v141 + 16)) == 0
                    || !v143(a1, 1, a1 + 496))
                  {
                    uint64_t v144 = *(void *)(a1 + 376);
                    if (v144
                      && ((id v145 = *(void (**)(uint64_t, void, uint64_t))(v144 + 40)) == 0
                       || (v145(a1, 0, a1 + 384), (uint64_t v144 = *(void *)(a1 + 376)) != 0))
                      && (uint64_t v146 = *(unsigned int (**)(uint64_t, void, uint64_t))(v144 + 16)) != 0)
                    {
                      if (v146(a1, 0, a1 + 384)) {
                        uint64_t v11 = 4294967291;
                      }
                      else {
                        uint64_t v11 = 0;
                      }
                    }
                    else
                    {
                      uint64_t v11 = 0;
                    }
LABEL_69:
                    BN_clear_free(*(BIGNUM **)(a8 + 160));
                    *(void *)(a8 + 160) = 0;
                    uint64_t v55 = *(void *)(a8 + 176);
                    if (v55)
                    {
                      (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v55, a1);
                      *(void *)(a8 + 176) = 0;
                    }
                    *(_DWORD *)a8 = 0;
                    return v11;
                  }
LABEL_202:
                  uint64_t v11 = 4294967291;
                  goto LABEL_69;
                }
                LODWORD(v150) = 0;
                LODWORD(v149) = 0;
                switch(a2)
                {
                  case 415:
                    v148[0] = 0;
                    uint64_t v59 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v85 + 20) + 32, a1);
                    if (v59 && *(_DWORD *)(*(void *)(a1 + 336) + 20))
                    {
                      unint64_t v87 = 0;
                      do
                      {
                        _libssh2_sha256_init(v148);
                        EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(void *)(a8 + 200));
                        EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x20uLL);
                        uint64_t v88 = v148[0];
                        if (v87)
                        {
                          uint64_t v89 = v59;
                          size_t v90 = v87;
                        }
                        else
                        {
                          EVP_DigestUpdate(v148[0], "B", 1uLL);
                          uint64_t v88 = v148[0];
                          uint64_t v89 = *(const void **)(a1 + 160);
                          size_t v90 = *(unsigned int *)(a1 + 168);
                        }
                        EVP_DigestUpdate(v88, v89, v90);
                        EVP_DigestFinal(v148[0], (unsigned __int8 *)v59 + v87, 0);
                        EVP_MD_CTX_free(v148[0]);
                        v87 += 32;
                      }
                      while (v87 < *(int *)(*(void *)(a1 + 336) + 20));
                    }
                    break;
                  case 716:
                    v148[0] = 0;
                    uint64_t v59 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v85 + 20) + 64, a1);
                    if (v59 && *(_DWORD *)(*(void *)(a1 + 336) + 20))
                    {
                      unint64_t v95 = 0;
                      do
                      {
                        _libssh2_sha512_init(v148);
                        EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(void *)(a8 + 200));
                        EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x40uLL);
                        unsigned int v96 = v148[0];
                        if (v95)
                        {
                          uint64_t v97 = v59;
                          size_t v98 = v95;
                        }
                        else
                        {
                          EVP_DigestUpdate(v148[0], "B", 1uLL);
                          unsigned int v96 = v148[0];
                          uint64_t v97 = *(const void **)(a1 + 160);
                          size_t v98 = *(unsigned int *)(a1 + 168);
                        }
                        EVP_DigestUpdate(v96, v97, v98);
                        EVP_DigestFinal(v148[0], (unsigned __int8 *)v59 + v95, 0);
                        EVP_MD_CTX_free(v148[0]);
                        v95 += 64;
                      }
                      while (v95 < *(int *)(*(void *)(a1 + 336) + 20));
                    }
                    break;
                  case 715:
                    v148[0] = 0;
                    uint64_t v59 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(v85 + 20) + 48, a1);
                    if (v59 && *(_DWORD *)(*(void *)(a1 + 336) + 20))
                    {
                      unint64_t v91 = 0;
                      do
                      {
                        _libssh2_sha384_init(v148);
                        EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(void *)(a8 + 200));
                        EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x30uLL);
                        unsigned int v92 = v148[0];
                        if (v91)
                        {
                          size_t v93 = v59;
                          size_t v94 = v91;
                        }
                        else
                        {
                          EVP_DigestUpdate(v148[0], "B", 1uLL);
                          unsigned int v92 = v148[0];
                          size_t v93 = *(const void **)(a1 + 160);
                          size_t v94 = *(unsigned int *)(a1 + 168);
                        }
                        EVP_DigestUpdate(v92, v93, v94);
                        EVP_DigestFinal(v148[0], (unsigned __int8 *)v59 + v91, 0);
                        EVP_MD_CTX_free(v148[0]);
                        v91 += 48;
                      }
                      while (v91 < *(int *)(*(void *)(a1 + 336) + 20));
                    }
                    break;
                  default:
                    goto LABEL_202;
                }
                if (!v59) {
                  goto LABEL_202;
                }
                if (a2 == 415)
                {
                  v148[0] = 0;
                  uint64_t v72 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(*(void *)(a1 + 336) + 24) + 32, a1);
                  if (v72 && *(_DWORD *)(*(void *)(a1 + 336) + 24))
                  {
                    unint64_t v99 = 0;
                    do
                    {
                      _libssh2_sha256_init(v148);
                      EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(void *)(a8 + 200));
                      EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x20uLL);
                      unint64_t v100 = v148[0];
                      if (v99)
                      {
                        size_t v101 = v72;
                        size_t v102 = v99;
                      }
                      else
                      {
                        EVP_DigestUpdate(v148[0], "D", 1uLL);
                        unint64_t v100 = v148[0];
                        size_t v101 = *(const void **)(a1 + 160);
                        size_t v102 = *(unsigned int *)(a1 + 168);
                      }
                      EVP_DigestUpdate(v100, v101, v102);
                      EVP_DigestFinal(v148[0], (unsigned __int8 *)v72 + v99, 0);
                      EVP_MD_CTX_free(v148[0]);
                      v99 += 32;
                    }
                    while (v99 < *(int *)(*(void *)(a1 + 336) + 24));
                  }
                }
                else if (a2 == 716)
                {
                  v148[0] = 0;
                  uint64_t v72 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(*(void *)(a1 + 336) + 24) + 64, a1);
                  if (v72 && *(_DWORD *)(*(void *)(a1 + 336) + 24))
                  {
                    unint64_t v107 = 0;
                    do
                    {
                      _libssh2_sha512_init(v148);
                      EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(void *)(a8 + 200));
                      EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x40uLL);
                      size_t v108 = v148[0];
                      if (v107)
                      {
                        uint64_t v109 = v72;
                        size_t v110 = v107;
                      }
                      else
                      {
                        EVP_DigestUpdate(v148[0], "D", 1uLL);
                        size_t v108 = v148[0];
                        uint64_t v109 = *(const void **)(a1 + 160);
                        size_t v110 = *(unsigned int *)(a1 + 168);
                      }
                      EVP_DigestUpdate(v108, v109, v110);
                      EVP_DigestFinal(v148[0], (unsigned __int8 *)v72 + v107, 0);
                      EVP_MD_CTX_free(v148[0]);
                      v107 += 64;
                    }
                    while (v107 < *(int *)(*(void *)(a1 + 336) + 24));
                  }
                }
                else
                {
                  v148[0] = 0;
                  uint64_t v72 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(*(int *)(*(void *)(a1 + 336) + 24) + 48, a1);
                  if (v72 && *(_DWORD *)(*(void *)(a1 + 336) + 24))
                  {
                    unint64_t v103 = 0;
                    do
                    {
                      _libssh2_sha384_init(v148);
                      EVP_DigestUpdate(v148[0], *(const void **)(a8 + 176), *(void *)(a8 + 200));
                      EVP_DigestUpdate(v148[0], (const void *)(a8 + 32), 0x30uLL);
                      size_t v104 = v148[0];
                      if (v103)
                      {
                        size_t v105 = v72;
                        size_t v106 = v103;
                      }
                      else
                      {
                        EVP_DigestUpdate(v148[0], "D", 1uLL);
                        size_t v104 = v148[0];
                        size_t v105 = *(const void **)(a1 + 160);
                        size_t v106 = *(unsigned int *)(a1 + 168);
                      }
                      EVP_DigestUpdate(v104, v105, v106);
                      EVP_DigestFinal(v148[0], (unsigned __int8 *)v72 + v103, 0);
                      EVP_MD_CTX_free(v148[0]);
                      v103 += 48;
                    }
                    while (v103 < *(int *)(*(void *)(a1 + 336) + 24));
                  }
                }
                if (v72)
                {
                  if ((*(unsigned int (**)(uint64_t))(*(void *)(a1 + 336) + 40))(a1)) {
                    goto LABEL_199;
                  }
                  if (v150)
                  {
                    memset_s(v59, *(int *)(*(void *)(a1 + 336) + 20), 0, *(int *)(*(void *)(a1 + 336) + 20));
                    (*(void (**)(void *, uint64_t))(a1 + 24))(v59, a1);
                  }
                  if (v149)
                  {
                    memset_s(v72, *(int *)(*(void *)(a1 + 336) + 24), 0, *(int *)(*(void *)(a1 + 336) + 24));
                    (*(void (**)(void *, uint64_t))(a1 + 24))(v72, a1);
                  }
                  goto LABEL_207;
                }
LABEL_200:
                uint64_t v72 = v59;
                goto LABEL_201;
              }
LABEL_119:
              uint64_t v11 = 0xFFFFFFFFLL;
              goto LABEL_69;
            }
            uint64_t v18 = "Timed out waiting for NEWKEYS ECDH";
LABEL_67:
            uint64_t v19 = a1;
            uint64_t v20 = v11;
            goto LABEL_68;
          }
        }
        return v11;
      case 3:
        goto LABEL_55;
      case 5:
        goto LABEL_58;
      default:
        goto LABEL_69;
    }
  }
  return _libssh2_error(a1, 4294967286, "Host key data is too short");
}

uint64_t kex_method_diffie_hellman_group_exchange_sha256_key_exchange(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 0;
  switch(*(_DWORD *)a2)
  {
    case 0:
      *(void *)(a2 + 272) = BN_new();
      *(void *)(a2 + 280) = BN_new();
      *(unsigned char *)(a2 + 288) = 34;
      _libssh2_htonu32((_DWORD *)(a2 + 289), 0x800u);
      _libssh2_htonu32((_DWORD *)(a2 + 293), 0x1000u);
      _libssh2_htonu32((_DWORD *)(a2 + 297), 0x2000u);
      size_t v5 = 13;
      *(void *)(a2 + 552) = 13;
      *(_DWORD *)a2 = 2;
      goto LABEL_4;
    case 2:
      size_t v5 = *(void *)(a2 + 552);
LABEL_4:
      uint64_t v6 = _libssh2_transport_send(a1, (void *)(a2 + 288), v5, 0, 0);
      uint64_t v3 = v6;
      if (v6 == -37) {
        return v3;
      }
      if (v6)
      {
        int v8 = "Unable to send Group Exchange Request SHA256";
LABEL_16:
        uint64_t v10 = a1;
        uint64_t v11 = v3;
LABEL_20:
        uint64_t v3 = _libssh2_error(v10, v11, v8);
LABEL_21:
        *(_DWORD *)a2 = 0;
        BN_clear_free(*(BIGNUM **)(a2 + 280));
        *(void *)(a2 + 280) = 0;
        BN_clear_free(*(BIGNUM **)(a2 + 272));
        *(void *)(a2 + 272) = 0;
        return v3;
      }
      *(_DWORD *)a2 = 3;
LABEL_7:
      uint64_t v7 = _libssh2_packet_require(a1, 31, (void *)(a2 + 544), (unint64_t *)(a2 + 560), 0, 0, 0, a2 + 8);
      uint64_t v3 = v7;
      if (v7 == -37) {
        return v3;
      }
      if (v7)
      {
        int v8 = "Timeout waiting for GEX_GROUP reply SHA256";
        goto LABEL_16;
      }
      *(_DWORD *)a2 = 4;
LABEL_10:
      size_t v17 = 0;
      uint64_t v18 = 0;
      uint64_t v16 = 0;
      *(void *)len = 0;
      uint64_t v13 = 0;
      if (*(void *)(a2 + 560) <= 8uLL)
      {
        int v8 = "Unexpected key length DH-SHA256";
LABEL_19:
        uint64_t v10 = a1;
        uint64_t v11 = 4294967282;
        goto LABEL_20;
      }
      uint64_t v9 = *(void *)(a2 + 544);
      v14[2] = *(void *)(a2 + 560);
      v14[0] = v9;
      v14[1] = v9 + 1;
      if (_libssh2_get_bignum_bytes(v14, &v18, &v16))
      {
        int v8 = "Unexpected value DH-SHA256 p";
        goto LABEL_19;
      }
      if (_libssh2_get_bignum_bytes(v14, &v17, len))
      {
        int v8 = "Unexpected value DH-SHA256 g";
        goto LABEL_19;
      }
      BN_bin2bn(v18, v16, *(BIGNUM **)(a2 + 272));
      BN_bin2bn(v17, len[0], *(BIGNUM **)(a2 + 280));
      uint64_t v3 = diffie_hellman_sha_algo(a1, *(const BIGNUM **)(a2 + 280), *(const BIGNUM **)(a2 + 272), v16, 256, (uint64_t)&v13, 32, 33, (void *)(*(void *)(a2 + 544) + 1), *(void *)(a2 + 560) - 1, a2 + 24);
      if (v3 != -37)
      {
        (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(a2 + 544), a1);
        goto LABEL_21;
      }
      return v3;
    case 3:
      goto LABEL_7;
    case 4:
      goto LABEL_10;
    default:
      goto LABEL_21;
  }
}

uint64_t diffie_hellman_sha_algo(uint64_t a1, const BIGNUM *a2, const BIGNUM *a3, int a4, uint64_t a5, uint64_t a6, int a7, int a8, void *a9, size_t cnt, uint64_t a11)
{
  *(void *)uint64_t v82 = a6;
  if ((int)a5 > 383)
  {
    if (a5 == 512)
    {
      unsigned int v18 = 64;
      goto LABEL_10;
    }
    if (a5 == 384)
    {
      unsigned int v18 = 48;
      goto LABEL_10;
    }
LABEL_13:
    int v21 = "sha algo value is unimplemented";
LABEL_14:
    uint64_t v22 = a1;
    uint64_t v23 = 4294967282;
    goto LABEL_113;
  }
  if (a5 == 1)
  {
    unsigned int v18 = 20;
    goto LABEL_10;
  }
  if (a5 != 256) {
    goto LABEL_13;
  }
  unsigned int v18 = 32;
LABEL_10:
  uint64_t v19 = 0;
  switch(*(_DWORD *)a11)
  {
    case 0:
      unsigned int v78 = v18;
      *(void *)(a11 + 8) = 0;
      uint64_t v20 = a11 + 8;
      *(void *)(a11 + 176) = 0;
      *(void *)(a11 + 16) = 0;
      *(void *)(a11 + 128) = BN_CTX_new();
      _libssh2_dh_init((BIGNUM **)(a11 + 136));
      *(void *)(a11 + 144) = BN_new();
      *(void *)(a11 + 152) = BN_new();
      *(void *)(a11 + 160) = BN_new();
      *(void *)(a11 + 224) = 0;
      *(void *)(a11 + 232) = 0;
      if (BN_num_bits(a3) > 0x4000)
      {
        int v21 = "dh modulus value is too large";
        uint64_t v22 = a1;
        uint64_t v23 = 4294967262;
        goto LABEL_113;
      }
      if (_libssh2_dh_key_pair((BIGNUM **)(a11 + 136), *(BIGNUM **)(a11 + 144), a2, a3, a4, *(BN_CTX **)(a11 + 128)))
      {
        int v21 = "dh key pair generation failed";
        uint64_t v22 = a1;
        uint64_t v23 = 4294967291;
        goto LABEL_113;
      }
      int v24 = BN_num_bits(*(const BIGNUM **)(a11 + 144));
      int v25 = v24 + 7;
      if (v24 < -7) {
        int v25 = v24 + 14;
      }
      *(void *)(a11 + 104) = (v25 >> 3) + 6;
      char v26 = BN_num_bits(*(const BIGNUM **)(a11 + 144));
      uint64_t v27 = *(void *)(a11 + 104);
      if ((v26 & 7) != 0) {
        *(void *)(a11 + 104) = --v27;
      }
      uint64_t v28 = (unsigned char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(v27, a1);
      *(void *)uint64_t v20 = v28;
      if (!v28)
      {
        int v21 = "Out of memory error";
LABEL_112:
        uint64_t v22 = a1;
        uint64_t v23 = 4294967290;
        goto LABEL_113;
      }
      *uint64_t v28 = a7;
      _libssh2_htonu32((_DWORD *)(*(void *)(a11 + 8) + 1), *(_DWORD *)(a11 + 104) - 5);
      if ((BN_num_bits(*(const BIGNUM **)(a11 + 144)) & 7) != 0)
      {
        uint64_t v29 = 5;
      }
      else
      {
        *(unsigned char *)(*(void *)v20 + 5) = 0;
        uint64_t v29 = 6;
      }
      unsigned int v18 = v78;
      BN_bn2bin(*(const BIGNUM **)(a11 + 144), (unsigned __int8 *)(*(void *)(a11 + 8) + v29));
      *(_DWORD *)a11 = 2;
LABEL_27:
      uint64_t v30 = _libssh2_transport_send(a1, *(void **)(a11 + 8), *(void *)(a11 + 104), 0, 0);
      uint64_t v19 = v30;
      if (v30 == -37) {
        return v19;
      }
      if (v30)
      {
        int v21 = "Unable to send KEX init message";
        goto LABEL_106;
      }
      *(_DWORD *)a11 = 3;
LABEL_30:
      if (*(_DWORD *)(a1 + 152))
      {
        uint64_t v31 = _libssh2_packet_burn(a1, (_DWORD *)(a11 + 240));
        uint64_t v19 = v31;
        if (v31 == -37) {
          return v19;
        }
        if ((int)v31 < 1) {
          goto LABEL_114;
        }
        *(_DWORD *)(a1 + 152) = 0;
      }
      *(_DWORD *)a11 = 4;
LABEL_35:
      uint64_t v80 = 0;
      size_t v32 = (uint64_t *)(a11 + 112);
      int v33 = _libssh2_packet_require(a1, a8, (void *)(a11 + 16), (unint64_t *)(a11 + 112), 0, 0, 0, a11 + 224);
      if (v33)
      {
        if (v33 == -37) {
          return 4294967259;
        }
        int v21 = "Timed out waiting for KEX reply";
        uint64_t v22 = a1;
        uint64_t v23 = 4294967287;
        goto LABEL_113;
      }
      if ((unint64_t)*v32 <= 4)
      {
        int v21 = "Unexpected packet length DH-SHA";
        goto LABEL_14;
      }
      uint64_t v34 = *(void *)(a11 + 16);
      v81[2] = *v32;
      v81[0] = v34;
      v81[1] = v34 + 1;
      uint64_t v35 = *(void *)(a1 + 200);
      if (v35) {
        (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v35, a1);
      }
      if (_libssh2_copy_string(a1, v81, (void *)(a1 + 200), (size_t *)&v80))
      {
        int v21 = "Could not copy host key";
        goto LABEL_112;
      }
      *(_DWORD *)(a1 + 208) = v80;
      ctx = 0;
      if (_libssh2_md5_init(&ctx))
      {
        EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
        EVP_DigestFinal(ctx, (unsigned __int8 *)(a1 + 212), 0);
        EVP_MD_CTX_free(ctx);
        int v36 = 1;
      }
      else
      {
        int v36 = 0;
      }
      *(_DWORD *)(a1 + 228) = v36;
      ctx = 0;
      if (_libssh2_sha1_init(&ctx))
      {
        EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
        EVP_DigestFinal(ctx, (unsigned __int8 *)(a1 + 232), 0);
        EVP_MD_CTX_free(ctx);
        int v37 = 1;
      }
      else
      {
        int v37 = 0;
      }
      *(_DWORD *)(a1 + 252) = v37;
      ctx = 0;
      if (_libssh2_sha256_init(&ctx))
      {
        EVP_DigestUpdate(ctx, *(const void **)(a1 + 200), *(unsigned int *)(a1 + 208));
        EVP_DigestFinal(ctx, (unsigned __int8 *)(a1 + 256), 0);
        EVP_MD_CTX_free(ctx);
        int v38 = 1;
      }
      else
      {
        int v38 = 0;
      }
      *(_DWORD *)(a1 + 288) = v38;
      if ((*(unsigned int (**)(uint64_t, void, void, uint64_t))(*(void *)(a1 + 184) + 16))(a1, *(void *)(a1 + 200), *(unsigned int *)(a1 + 208), a1 + 192))
      {
        int v21 = "Unable to initialize hostkey importer DH-SHA";
LABEL_61:
        uint64_t v22 = a1;
        uint64_t v23 = 4294967286;
        goto LABEL_113;
      }
      if (_libssh2_get_string(v81, (void *)(a11 + 168), (void *)(a11 + 192)))
      {
        int v21 = "Unable to get DH-SHA f value";
        goto LABEL_61;
      }
      BN_bin2bn(*(const unsigned __int8 **)(a11 + 168), *(_DWORD *)(a11 + 192), *(BIGNUM **)(a11 + 152));
      if (_libssh2_get_string(v81, (void *)(a11 + 184), (void *)(a11 + 208)))
      {
        int v21 = "Unable to get DH-SHA h sig";
        goto LABEL_61;
      }
      _libssh2_dh_secret((const BIGNUM **)(a11 + 136), *(BIGNUM **)(a11 + 160), *(BIGNUM **)(a11 + 152), a3, *(BN_CTX **)(a11 + 128));
      int v39 = BN_num_bits(*(const BIGNUM **)(a11 + 160));
      int v40 = v39 + 7;
      if (v39 < -7) {
        int v40 = v39 + 14;
      }
      *(void *)(a11 + 200) = (v40 >> 3) + 5;
      char v41 = BN_num_bits(*(const BIGNUM **)(a11 + 160));
      uint64_t v42 = *(void *)(a11 + 200);
      if ((v41 & 7) != 0) {
        *(void *)(a11 + 200) = --v42;
      }
      size_t v43 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(v42, a1);
      *(void *)(a11 + 176) = v43;
      if (!v43)
      {
        int v21 = "Unable to allocate buffer for DH-SHA K";
        goto LABEL_112;
      }
      _libssh2_htonu32(v43, *(_DWORD *)(a11 + 200) - 4);
      if ((BN_num_bits(*(const BIGNUM **)(a11 + 160)) & 7) != 0)
      {
        uint64_t v44 = 4;
      }
      else
      {
        *(unsigned char *)(*(void *)(a11 + 176) + 4) = 0;
        uint64_t v44 = 5;
      }
      BN_bn2bin(*(const BIGNUM **)(a11 + 160), (unsigned __int8 *)(*(void *)(a11 + 176) + v44));
      *(void *)(a11 + 216) = v82;
      _libssh2_sha_algo_ctx_init(a5, *(EVP_MD_CTX ***)v82);
      unsigned int v45 = *(const char **)(a1 + 424);
      if (v45)
      {
        int v46 = strlen(v45);
        _libssh2_htonu32((_DWORD *)(a11 + 32), v46 - 2);
        _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, (void *)(a11 + 32), 4uLL);
        size_t v47 = strlen(*(const char **)(a1 + 424)) - 2;
        uint64_t v48 = a5;
        size_t v49 = *(EVP_MD_CTX ***)v82;
        unsigned int v50 = *(char **)(a1 + 424);
      }
      else
      {
        _libssh2_htonu32((_DWORD *)(a11 + 32), 0x16u);
        _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, (void *)(a11 + 32), 4uLL);
        size_t v49 = *(EVP_MD_CTX ***)v82;
        unsigned int v50 = "SSH-2.0-libssh2_1.11.0";
        uint64_t v48 = a5;
        size_t v47 = 22;
      }
      _libssh2_sha_algo_ctx_update(v48, v49, v50, v47);
      unsigned int v51 = strlen(*(const char **)(a1 + 312));
      _libssh2_htonu32((_DWORD *)(a11 + 32), v51);
      _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, (void *)(a11 + 32), 4uLL);
      size_t v52 = strlen(*(const char **)(a1 + 312));
      _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, *(void **)(a1 + 312), v52);
      _libssh2_htonu32((_DWORD *)(a11 + 32), *(_DWORD *)(a1 + 440));
      _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, (void *)(a11 + 32), 4uLL);
      _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, *(void **)(a1 + 432), *(void *)(a1 + 440));
      _libssh2_htonu32((_DWORD *)(a11 + 32), *(_DWORD *)(a1 + 328));
      _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, (void *)(a11 + 32), 4uLL);
      _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, *(void **)(a1 + 320), *(void *)(a1 + 328));
      _libssh2_htonu32((_DWORD *)(a11 + 32), *(_DWORD *)(a1 + 208));
      _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, (void *)(a11 + 32), 4uLL);
      _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, *(void **)(a1 + 200), *(unsigned int *)(a1 + 208));
      if (a7 == 32)
      {
        _libssh2_htonu32((_DWORD *)(a11 + 32), 0x800u);
        _libssh2_htonu32((_DWORD *)(a11 + 36), 0x1000u);
        _libssh2_htonu32((_DWORD *)(a11 + 40), 0x2000u);
        _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, (void *)(a11 + 32), 0xCuLL);
      }
      if (a9) {
        _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, a9, cnt);
      }
      _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, (void *)(*(void *)(a11 + 8) + 1), *(void *)(a11 + 104) - 1);
      _libssh2_htonu32((_DWORD *)(a11 + 32), *(_DWORD *)(a11 + 192));
      _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, (void *)(a11 + 32), 4uLL);
      _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, *(void **)(a11 + 168), *(void *)(a11 + 192));
      _libssh2_sha_algo_ctx_update(a5, *(EVP_MD_CTX ***)v82, *(void **)(a11 + 176), *(void *)(a11 + 200));
      _libssh2_sha_algo_ctx_final(a5, *(EVP_MD_CTX ***)v82, (unsigned __int8 *)(a11 + 32));
      if ((*(unsigned int (**)(uint64_t, void, void, uint64_t, void, uint64_t))(*(void *)(a1 + 184)
                                                                                             + 40))(a1, *(void *)(a11 + 184), *(void *)(a11 + 208), a11 + 32, v18, a1 + 192))
      {
        int v21 = "Unable to verify hostkey signature DH-SHA";
        uint64_t v22 = a1;
        uint64_t v23 = 4294967285;
LABEL_113:
        uint64_t v19 = _libssh2_error(v22, v23, v21);
        goto LABEL_114;
      }
      *(unsigned char *)(a11 + 96) = 21;
      *(_DWORD *)a11 = 5;
LABEL_81:
      uint64_t v53 = _libssh2_transport_send(a1, (void *)(a11 + 96), 1uLL, 0, 0);
      uint64_t v19 = v53;
      if (v53 != -37)
      {
        if (v53)
        {
          int v21 = "Unable to send NEWKEYS message DH-SHA";
          goto LABEL_106;
        }
        *(_DWORD *)a11 = 6;
LABEL_84:
        uint64_t v54 = _libssh2_packet_require(a1, 21, (void *)(a11 + 24), (unint64_t *)(a11 + 120), 0, 0, 0, a11 + 224);
        uint64_t v19 = v54;
        if (v54 != -37)
        {
          if (!v54)
          {
            *(_DWORD *)(a1 + 128) |= 2u;
            (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(a11 + 24), a1);
            if (!*(void *)(a1 + 160))
            {
              uint64_t v55 = (void *)(*(uint64_t (**)(void, uint64_t))(a1 + 8))(v18, a1);
              *(void *)(a1 + 160) = v55;
              if (!v55)
              {
                int v21 = "Unable to allocate buffer for SHA digest";
                goto LABEL_112;
              }
              memcpy(v55, (const void *)(a11 + 32), v18);
              *(_DWORD *)(a1 + 168) = v18;
            }
            uint64_t v56 = *(void *)(a1 + 448);
            uint64_t v57 = *(void (**)(uint64_t, uint64_t))(v56 + 56);
            if (v57)
            {
              v57(a1, a1 + 456);
              uint64_t v56 = *(void *)(a1 + 448);
            }
            if (*(void *)(v56 + 40))
            {
              uint64_t v80 = 0;
              v81[0] = 0;
              LODWORD(ctx) = 0;
              _libssh2_sha_algo_value_hash(a5, a1, a11, v81, *(int *)(v56 + 20), "A");
              uint64_t v58 = (void *)v81[0];
              if (!v81[0])
              {
                uint64_t v19 = 0xFFFFFFFFLL;
LABEL_114:
                _libssh2_dh_dtor((BIGNUM **)(a11 + 136));
                BN_clear_free(*(BIGNUM **)(a11 + 144));
                *(void *)(a11 + 144) = 0;
                BN_clear_free(*(BIGNUM **)(a11 + 152));
                *(void *)(a11 + 152) = 0;
                BN_clear_free(*(BIGNUM **)(a11 + 160));
                *(void *)(a11 + 160) = 0;
                BN_CTX_free(*(BN_CTX **)(a11 + 128));
                *(void *)(a11 + 128) = 0;
                uint64_t v62 = *(void *)(a11 + 8);
                if (v62)
                {
                  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v62, a1);
                  *(void *)(a11 + 8) = 0;
                }
                uint64_t v63 = *(void *)(a11 + 16);
                if (v63)
                {
                  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v63, a1);
                  *(void *)(a11 + 16) = 0;
                }
                uint64_t v64 = *(void *)(a11 + 176);
                if (v64)
                {
                  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v64, a1);
                  *(void *)(a11 + 176) = 0;
                }
                *(_DWORD *)a11 = 0;
                return v19;
              }
              _libssh2_sha_algo_value_hash(a5, a1, a11, &v80, *(int *)(*(void *)(a1 + 448) + 24), "C");
              uint64_t v59 = v80;
              if (!v80) {
                goto LABEL_108;
              }
              if ((*(unsigned int (**)(uint64_t))(*(void *)(a1 + 448) + 40))(a1))
              {
LABEL_103:
                (*(void (**)(void *, uint64_t))(a1 + 24))(v58, a1);
LABEL_109:
                (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v59, a1);
                goto LABEL_110;
              }
              if (ctx)
              {
                memset_s(v58, *(int *)(*(void *)(a1 + 448) + 20), 0, *(int *)(*(void *)(a1 + 448) + 20));
                (*(void (**)(void *, uint64_t))(a1 + 24))(v58, a1);
              }
            }
            uint64_t v60 = *(void *)(a1 + 336);
            uint64_t v61 = *(void (**)(uint64_t, uint64_t))(v60 + 56);
            if (v61)
            {
              v61(a1, a1 + 344);
              uint64_t v60 = *(void *)(a1 + 336);
            }
            if (!*(void *)(v60 + 40)) {
              goto LABEL_124;
            }
            uint64_t v80 = 0;
            v81[0] = 0;
            LODWORD(ctx) = 0;
            _libssh2_sha_algo_value_hash(a5, a1, a11, v81, *(int *)(v60 + 20), "B");
            uint64_t v58 = (void *)v81[0];
            if (!v81[0])
            {
LABEL_110:
              uint64_t v19 = 4294967291;
              goto LABEL_114;
            }
            _libssh2_sha_algo_value_hash(a5, a1, a11, &v80, *(int *)(*(void *)(a1 + 336) + 24), "D");
            uint64_t v59 = v80;
            if (v80)
            {
              if ((*(unsigned int (**)(uint64_t))(*(void *)(a1 + 336) + 40))(a1)) {
                goto LABEL_103;
              }
              if (ctx)
              {
                memset_s(v58, *(int *)(*(void *)(a1 + 336) + 20), 0, *(int *)(*(void *)(a1 + 336) + 20));
                (*(void (**)(void *, uint64_t))(a1 + 24))(v58, a1);
              }
LABEL_124:
              uint64_t v66 = *(void *)(a1 + 464);
              size_t v67 = *(void (**)(uint64_t, uint64_t))(v66 + 32);
              if (v67)
              {
                v67(a1, a1 + 480);
                uint64_t v66 = *(void *)(a1 + 464);
              }
              if (*(void *)(v66 + 16))
              {
                v81[0] = 0;
                LODWORD(v80) = 0;
                _libssh2_sha_algo_value_hash(a5, a1, a11, v81, *(int *)(v66 + 12), "E");
                unint64_t v68 = (void *)v81[0];
                if (!v81[0]) {
                  goto LABEL_110;
                }
                (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(void *)(a1 + 464) + 16))(a1, v81[0], &v80, a1 + 480);
                if (v80)
                {
                  memset_s(v68, *(int *)(*(void *)(a1 + 464) + 12), 0, *(int *)(*(void *)(a1 + 464) + 12));
                  (*(void (**)(void *, uint64_t))(a1 + 24))(v68, a1);
                }
              }
              uint64_t v69 = *(void *)(a1 + 352);
              uint64_t v70 = *(void (**)(uint64_t, uint64_t))(v69 + 32);
              if (v70)
              {
                v70(a1, a1 + 368);
                uint64_t v69 = *(void *)(a1 + 352);
              }
              if (*(void *)(v69 + 16))
              {
                v81[0] = 0;
                LODWORD(v80) = 0;
                _libssh2_sha_algo_value_hash(a5, a1, a11, v81, *(int *)(v69 + 12), "F");
                size_t v71 = (void *)v81[0];
                if (!v81[0]) {
                  goto LABEL_110;
                }
                (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t))(*(void *)(a1 + 352) + 16))(a1, v81[0], &v80, a1 + 368);
                if (v80)
                {
                  memset_s(v71, *(int *)(*(void *)(a1 + 352) + 12), 0, *(int *)(*(void *)(a1 + 352) + 12));
                  (*(void (**)(void *, uint64_t))(a1 + 24))(v71, a1);
                }
              }
              uint64_t v72 = *(void *)(a1 + 488);
              if (!v72
                || (unint64_t v73 = *(void (**)(uint64_t, uint64_t, uint64_t))(v72 + 40)) != 0
                && (v73(a1, 1, a1 + 496), (uint64_t v72 = *(void *)(a1 + 488)) == 0)
                || (unint64_t v74 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v72 + 16)) == 0
                || !v74(a1, 1, a1 + 496))
              {
                uint64_t v75 = *(void *)(a1 + 376);
                if (v75
                  && ((size_t v76 = *(void (**)(uint64_t, void, uint64_t))(v75 + 40)) == 0
                   || (v76(a1, 0, a1 + 384), (uint64_t v75 = *(void *)(a1 + 376)) != 0))
                  && (unint64_t v77 = *(unsigned int (**)(uint64_t, void, uint64_t))(v75 + 16)) != 0)
                {
                  if (v77(a1, 0, a1 + 384)) {
                    uint64_t v19 = 4294967291;
                  }
                  else {
                    uint64_t v19 = 0;
                  }
                }
                else
                {
                  uint64_t v19 = 0;
                }
                goto LABEL_114;
              }
              goto LABEL_110;
            }
LABEL_108:
            uint64_t v59 = (uint64_t)v58;
            goto LABEL_109;
          }
          int v21 = "Timed out waiting for NEWKEYS DH-SHA";
LABEL_106:
          uint64_t v22 = a1;
          uint64_t v23 = v19;
          goto LABEL_113;
        }
      }
      return v19;
    case 2:
      goto LABEL_27;
    case 3:
      goto LABEL_30;
    case 4:
      goto LABEL_35;
    case 5:
      goto LABEL_81;
    case 6:
      goto LABEL_84;
    default:
      goto LABEL_114;
  }
}

uint64_t _libssh2_sha_algo_ctx_init(int a1, EVP_MD_CTX **a2)
{
  if (a1 > 383)
  {
    if (a1 == 384)
    {
      return _libssh2_sha384_init(a2);
    }
    else
    {
      if (a1 != 512) {
        goto LABEL_18;
      }
      return _libssh2_sha512_init(a2);
    }
  }
  else
  {
    if (a1 != 1)
    {
      if (a1 == 256)
      {
        return _libssh2_sha256_init(a2);
      }
LABEL_18:
      _libssh2_sha_algo_ctx_init_cold_1();
    }
    return _libssh2_sha1_init(a2);
  }
}

uint64_t _libssh2_sha_algo_ctx_update(uint64_t result, EVP_MD_CTX **a2, void *d, size_t cnt)
{
  if ((int)result <= 383)
  {
    if (result != 1 && result != 256) {
      return result;
    }
    return EVP_DigestUpdate(*a2, d, cnt);
  }
  if (result == 512 || result == 384) {
    return EVP_DigestUpdate(*a2, d, cnt);
  }
  return result;
}

void _libssh2_sha_algo_ctx_final(int a1, EVP_MD_CTX **a2, unsigned __int8 *md)
{
  if (a1 > 383)
  {
    if (a1 != 512 && a1 != 384) {
      return;
    }
  }
  else if (a1 != 1 && a1 != 256)
  {
    return;
  }
  EVP_DigestFinal(*a2, md, 0);
  uint64_t v4 = *a2;
  EVP_MD_CTX_free(v4);
}

void _libssh2_sha_algo_value_hash(int a1, uint64_t a2, uint64_t a3, uint64_t *a4, size_t a5, const void *a6)
{
  if (a1 > 383)
  {
    if (a1 == 384)
    {
      ctx = 0;
      uint64_t v26 = *a4;
      if (!*a4)
      {
        uint64_t v26 = (*(uint64_t (**)(size_t, uint64_t))(a2 + 8))(a5 + 48, a2);
        *a4 = v26;
      }
      if (v26 && a5)
      {
        size_t v27 = 0;
        do
        {
          _libssh2_sha384_init(&ctx);
          EVP_DigestUpdate(ctx, *(const void **)(a3 + 176), *(void *)(a3 + 200));
          EVP_DigestUpdate(ctx, (const void *)(a3 + 32), 0x30uLL);
          uint64_t v28 = ctx;
          if (v27)
          {
            uint64_t v29 = (const void *)*a4;
            size_t v30 = v27;
          }
          else
          {
            EVP_DigestUpdate(ctx, a6, 1uLL);
            uint64_t v28 = ctx;
            uint64_t v29 = *(const void **)(a2 + 160);
            size_t v30 = *(unsigned int *)(a2 + 168);
          }
          EVP_DigestUpdate(v28, v29, v30);
          EVP_DigestFinal(ctx, (unsigned __int8 *)(*a4 + v27), 0);
          EVP_MD_CTX_free(ctx);
          v27 += 48;
        }
        while (v27 < a5);
      }
    }
    else if (a1 == 512)
    {
      ctx = 0;
      uint64_t v16 = *a4;
      if (!*a4)
      {
        uint64_t v16 = (*(uint64_t (**)(size_t, uint64_t))(a2 + 8))(a5 + 64, a2);
        *a4 = v16;
      }
      if (v16 && a5)
      {
        size_t v17 = 0;
        do
        {
          _libssh2_sha512_init(&ctx);
          EVP_DigestUpdate(ctx, *(const void **)(a3 + 176), *(void *)(a3 + 200));
          EVP_DigestUpdate(ctx, (const void *)(a3 + 32), 0x40uLL);
          unsigned int v18 = ctx;
          if (v17)
          {
            uint64_t v19 = (const void *)*a4;
            size_t v20 = v17;
          }
          else
          {
            EVP_DigestUpdate(ctx, a6, 1uLL);
            unsigned int v18 = ctx;
            uint64_t v19 = *(const void **)(a2 + 160);
            size_t v20 = *(unsigned int *)(a2 + 168);
          }
          EVP_DigestUpdate(v18, v19, v20);
          EVP_DigestFinal(ctx, (unsigned __int8 *)(*a4 + v17), 0);
          EVP_MD_CTX_free(ctx);
          v17 += 64;
        }
        while (v17 < a5);
      }
    }
  }
  else if (a1 == 1)
  {
    ctx = 0;
    uint64_t v21 = *a4;
    if (!*a4)
    {
      uint64_t v21 = (*(uint64_t (**)(size_t, uint64_t))(a2 + 8))(a5 + 20, a2);
      *a4 = v21;
    }
    if (v21 && a5)
    {
      size_t v22 = 0;
      do
      {
        _libssh2_sha1_init(&ctx);
        EVP_DigestUpdate(ctx, *(const void **)(a3 + 176), *(void *)(a3 + 200));
        EVP_DigestUpdate(ctx, (const void *)(a3 + 32), 0x14uLL);
        uint64_t v23 = ctx;
        if (v22)
        {
          int v24 = (const void *)*a4;
          size_t v25 = v22;
        }
        else
        {
          EVP_DigestUpdate(ctx, a6, 1uLL);
          uint64_t v23 = ctx;
          int v24 = *(const void **)(a2 + 160);
          size_t v25 = *(unsigned int *)(a2 + 168);
        }
        EVP_DigestUpdate(v23, v24, v25);
        EVP_DigestFinal(ctx, (unsigned __int8 *)(*a4 + v22), 0);
        EVP_MD_CTX_free(ctx);
        v22 += 20;
      }
      while (v22 < a5);
    }
  }
  else if (a1 == 256)
  {
    ctx = 0;
    uint64_t v11 = *a4;
    if (!*a4)
    {
      uint64_t v11 = (*(uint64_t (**)(size_t, uint64_t))(a2 + 8))(a5 + 32, a2);
      *a4 = v11;
    }
    if (v11 && a5)
    {
      size_t v12 = 0;
      do
      {
        _libssh2_sha256_init(&ctx);
        EVP_DigestUpdate(ctx, *(const void **)(a3 + 176), *(void *)(a3 + 200));
        EVP_DigestUpdate(ctx, (const void *)(a3 + 32), 0x20uLL);
        uint64_t v13 = ctx;
        if (v12)
        {
          uint64_t v14 = (const void *)*a4;
          size_t v15 = v12;
        }
        else
        {
          EVP_DigestUpdate(ctx, a6, 1uLL);
          uint64_t v13 = ctx;
          uint64_t v14 = *(const void **)(a2 + 160);
          size_t v15 = *(unsigned int *)(a2 + 168);
        }
        EVP_DigestUpdate(v13, v14, v15);
        EVP_DigestFinal(ctx, (unsigned __int8 *)(*a4 + v12), 0);
        EVP_MD_CTX_free(ctx);
        v12 += 32;
      }
      while (v12 < a5);
    }
  }
}

uint64_t kex_method_diffie_hellman_group16_sha512_key_exchange(uint64_t a1, uint64_t a2)
{
  if (!*(_DWORD *)a2)
  {
    *(void *)(a2 + 272) = BN_new();
    uint64_t v4 = BN_new();
    *(void *)(a2 + 280) = v4;
    BN_set_word(v4, 2uLL);
    BN_bin2bn(kex_method_diffie_hellman_group16_sha512_key_exchange_p_value, 512, *(BIGNUM **)(a2 + 272));
    *(_DWORD *)a2 = 2;
  }
  uint64_t v6 = *(const BIGNUM **)(a2 + 272);
  size_t v5 = *(const BIGNUM **)(a2 + 280);
  uint64_t v9 = 0;
  uint64_t v7 = diffie_hellman_sha_algo(a1, v5, v6, 512, 512, (uint64_t)&v9, 30, 31, 0, 0, a2 + 24);
  if (v7 != -37)
  {
    *(_DWORD *)a2 = 0;
    BN_clear_free(*(BIGNUM **)(a2 + 272));
    *(void *)(a2 + 272) = 0;
    BN_clear_free(*(BIGNUM **)(a2 + 280));
    *(void *)(a2 + 280) = 0;
  }
  return v7;
}

uint64_t kex_method_diffie_hellman_group18_sha512_key_exchange(uint64_t a1, uint64_t a2)
{
  if (!*(_DWORD *)a2)
  {
    *(void *)(a2 + 272) = BN_new();
    uint64_t v4 = BN_new();
    *(void *)(a2 + 280) = v4;
    BN_set_word(v4, 2uLL);
    BN_bin2bn(kex_method_diffie_hellman_group18_sha512_key_exchange_p_value, 1024, *(BIGNUM **)(a2 + 272));
    *(_DWORD *)a2 = 2;
  }
  uint64_t v6 = *(const BIGNUM **)(a2 + 272);
  size_t v5 = *(const BIGNUM **)(a2 + 280);
  uint64_t v9 = 0;
  uint64_t v7 = diffie_hellman_sha_algo(a1, v5, v6, 1024, 512, (uint64_t)&v9, 30, 31, 0, 0, a2 + 24);
  if (v7 != -37)
  {
    *(_DWORD *)a2 = 0;
    BN_clear_free(*(BIGNUM **)(a2 + 272));
    *(void *)(a2 + 272) = 0;
    BN_clear_free(*(BIGNUM **)(a2 + 280));
    *(void *)(a2 + 280) = 0;
  }
  return v7;
}

uint64_t kex_method_diffie_hellman_group14_sha256_key_exchange(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 0;
  return kex_method_diffie_hellman_group14_key_exchange(a1, a2, 256, (uint64_t)&v3);
}

uint64_t kex_method_diffie_hellman_group14_key_exchange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!*(_DWORD *)a2)
  {
    *(void *)(a2 + 272) = BN_new();
    int v8 = BN_new();
    *(void *)(a2 + 280) = v8;
    BN_set_word(v8, 2uLL);
    BN_bin2bn(kex_method_diffie_hellman_group14_key_exchange_p_value, 256, *(BIGNUM **)(a2 + 272));
    *(_DWORD *)a2 = 2;
  }
  uint64_t v9 = diffie_hellman_sha_algo(a1, *(const BIGNUM **)(a2 + 280), *(const BIGNUM **)(a2 + 272), 256, a3, a4, 30, 31, 0, 0, a2 + 24);
  if (v9 != -37)
  {
    *(_DWORD *)a2 = 0;
    BN_clear_free(*(BIGNUM **)(a2 + 272));
    *(void *)(a2 + 272) = 0;
    BN_clear_free(*(BIGNUM **)(a2 + 280));
    *(void *)(a2 + 280) = 0;
  }
  return v9;
}

uint64_t kex_method_diffie_hellman_group14_sha1_key_exchange(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 0;
  return kex_method_diffie_hellman_group14_key_exchange(a1, a2, 1, (uint64_t)&v3);
}

uint64_t kex_method_diffie_hellman_group1_sha1_key_exchange(uint64_t a1, uint64_t a2)
{
  if (!*(_DWORD *)a2)
  {
    *(void *)(a2 + 272) = BN_new();
    uint64_t v4 = BN_new();
    *(void *)(a2 + 280) = v4;
    BN_set_word(v4, 2uLL);
    BN_bin2bn(kex_method_diffie_hellman_group1_sha1_key_exchange_p_value, 128, *(BIGNUM **)(a2 + 272));
    *(_DWORD *)a2 = 2;
  }
  uint64_t v6 = *(const BIGNUM **)(a2 + 272);
  size_t v5 = *(const BIGNUM **)(a2 + 280);
  uint64_t v9 = 0;
  uint64_t v7 = diffie_hellman_sha_algo(a1, v5, v6, 128, 1, (uint64_t)&v9, 30, 31, 0, 0, a2 + 24);
  if (v7 != -37)
  {
    BN_clear_free(*(BIGNUM **)(a2 + 272));
    *(void *)(a2 + 272) = 0;
    BN_clear_free(*(BIGNUM **)(a2 + 280));
    *(void *)(a2 + 280) = 0;
    *(_DWORD *)a2 = 0;
  }
  return v7;
}

uint64_t kex_method_diffie_hellman_group_exchange_sha1_key_exchange(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 0;
  switch(*(_DWORD *)a2)
  {
    case 0:
      *(void *)(a2 + 272) = BN_new();
      *(void *)(a2 + 280) = BN_new();
      *(unsigned char *)(a2 + 288) = 34;
      _libssh2_htonu32((_DWORD *)(a2 + 289), 0x800u);
      _libssh2_htonu32((_DWORD *)(a2 + 293), 0x1000u);
      _libssh2_htonu32((_DWORD *)(a2 + 297), 0x2000u);
      size_t v5 = 13;
      *(void *)(a2 + 552) = 13;
      *(_DWORD *)a2 = 2;
      goto LABEL_4;
    case 2:
      size_t v5 = *(void *)(a2 + 552);
LABEL_4:
      uint64_t v6 = _libssh2_transport_send(a1, (void *)(a2 + 288), v5, 0, 0);
      uint64_t v3 = v6;
      if (v6 == -37) {
        return v3;
      }
      if (v6)
      {
        int v8 = "Unable to send Group Exchange Request";
LABEL_16:
        uint64_t v10 = a1;
        uint64_t v11 = v3;
LABEL_20:
        uint64_t v3 = _libssh2_error(v10, v11, v8);
LABEL_21:
        *(_DWORD *)a2 = 0;
        BN_clear_free(*(BIGNUM **)(a2 + 280));
        *(void *)(a2 + 280) = 0;
        BN_clear_free(*(BIGNUM **)(a2 + 272));
        *(void *)(a2 + 272) = 0;
        return v3;
      }
      *(_DWORD *)a2 = 3;
LABEL_7:
      uint64_t v7 = _libssh2_packet_require(a1, 31, (void *)(a2 + 544), (unint64_t *)(a2 + 560), 0, 0, 0, a2 + 8);
      uint64_t v3 = v7;
      if (v7 == -37) {
        return v3;
      }
      if (v7)
      {
        int v8 = "Timeout waiting for GEX_GROUP reply";
        goto LABEL_16;
      }
      *(_DWORD *)a2 = 4;
LABEL_10:
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      uint64_t v16 = 0;
      s = 0;
      uint64_t v13 = 0;
      if (*(void *)(a2 + 560) <= 8uLL)
      {
        int v8 = "Unexpected key length DH-SHA1";
LABEL_19:
        uint64_t v10 = a1;
        uint64_t v11 = 4294967282;
        goto LABEL_20;
      }
      uint64_t v9 = *(void *)(a2 + 544);
      v14[2] = *(void *)(a2 + 560);
      v14[0] = v9;
      v14[1] = v9 + 1;
      if (_libssh2_get_bignum_bytes(v14, &v16, &v18))
      {
        int v8 = "Unexpected value DH-SHA1 p";
        goto LABEL_19;
      }
      if (_libssh2_get_bignum_bytes(v14, &s, &v17))
      {
        int v8 = "Unexpected value DH-SHA1 g";
        goto LABEL_19;
      }
      BN_bin2bn(v16, v18, *(BIGNUM **)(a2 + 272));
      BN_bin2bn(s, v17, *(BIGNUM **)(a2 + 280));
      uint64_t v3 = diffie_hellman_sha_algo(a1, *(const BIGNUM **)(a2 + 280), *(const BIGNUM **)(a2 + 272), v18, 1, (uint64_t)&v13, 32, 33, (void *)(*(void *)(a2 + 544) + 1), *(void *)(a2 + 560) - 1, a2 + 24);
      if (v3 != -37)
      {
        (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(a2 + 544), a1);
        goto LABEL_21;
      }
      return v3;
    case 3:
      goto LABEL_7;
    case 4:
      goto LABEL_10;
    default:
      goto LABEL_21;
  }
}

void _libssh2_sha_algo_ctx_init_cold_1()
{
}

uint64_t _libssh2_error_flags(uint64_t a1, uint64_t a2, char *__s, char a4)
{
  if (a1)
  {
    if (*(unsigned char *)(a1 + 620)) {
      (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(a1 + 608), a1);
    }
    *(_DWORD *)(a1 + 616) = a2;
    *(_DWORD *)(a1 + 620) = 0;
    if (__s && (a4 & 1) != 0)
    {
      size_t v8 = strlen(__s) + 1;
      uint64_t v9 = (void *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v8, a1);
      if (v9)
      {
        uint64_t v10 = v9;
        memcpy(v9, __s, v8);
        *(_DWORD *)(a1 + 620) = 1;
        *(void *)(a1 + 608) = v10;
      }
      else
      {
        *(void *)(a1 + 608) = "former error forgotten (OOM)";
      }
    }
    else
    {
      *(void *)(a1 + 608) = __s;
    }
  }
  else if (__s)
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "Session is NULL, error: %s\n", __s);
  }
  return a2;
}

uint64_t _libssh2_error(uint64_t a1, uint64_t a2, char *a3)
{
  return _libssh2_error_flags(a1, a2, a3, 0);
}

ssize_t _libssh2_recv(int a1, void *a2, size_t a3, int a4)
{
  ssize_t result = recv(a1, a2, a3, a4);
  if (result < 0)
  {
    if (*__error() == 2 || *__error() == 35) {
      return -35;
    }
    else {
      return -(uint64_t)*__error();
    }
  }
  return result;
}

ssize_t _libssh2_send(int a1, const void *a2, size_t a3, int a4)
{
  ssize_t result = send(a1, a2, a3, a4);
  if (result < 0)
  {
    if (*__error() == 35) {
      return -35;
    }
    else {
      return -(uint64_t)*__error();
    }
  }
  return result;
}

uint64_t _libssh2_ntohu32(unsigned int *a1)
{
  return bswap32(*a1);
}

unint64_t _libssh2_ntohu64(unint64_t *a1)
{
  return bswap64(*a1);
}

_DWORD *_libssh2_htonu32(_DWORD *result, unsigned int a2)
{
  *ssize_t result = bswap32(a2);
  return result;
}

_DWORD **_libssh2_store_u32(_DWORD **result, unsigned int a2)
{
  *(*result)++ = bswap32(a2);
  return result;
}

uint64_t _libssh2_store_str(_DWORD **a1, const void *a2, unint64_t a3)
{
  **a1 = bswap32(a3);
  size_t v5 = *a1 + 1;
  *a1 = v5;
  uint64_t v6 = a3;
  if (a3)
  {
    memcpy(v5, a2, a3);
    *a1 = (_DWORD *)((char *)*a1 + v6);
  }
  if (HIDWORD(a3)) {
    _libssh2_store_str_cold_1();
  }
  return 1;
}

uint64_t _libssh2_store_bignum2_bytes(_DWORD **a1, unsigned char *a2, uint64_t a3)
{
  uint64_t v3 = a3;
  if (a3)
  {
    size_t v5 = &a2[a3];
    while (!*a2)
    {
      ++a2;
      if (!--v3)
      {
        BOOL v6 = 0;
        a2 = v5;
        goto LABEL_8;
      }
    }
    BOOL v6 = (char)*a2 < 0;
  }
  else
  {
    BOOL v6 = 0;
  }
LABEL_8:
  if (v3 == -1 && v6) {
    size_t v7 = 4294967294;
  }
  else {
    size_t v7 = v3;
  }
  **a1 = bswap32(v7 + v6);
  size_t v8 = *a1 + 1;
  *a1 = v8;
  if (v6)
  {
    *size_t v8 = 0;
    size_t v8 = (char *)*a1 + 1;
    *a1 = v8;
  }
  if (v7)
  {
    memcpy(v8, a2, v7);
    *a1 = (_DWORD *)((char *)*a1 + v7);
  }
  else
  {
    size_t v7 = 0;
  }
  if (v3 != v7) {
    _libssh2_store_bignum2_bytes_cold_1();
  }
  return 1;
}

uint64_t libssh2_base64_decode(uint64_t a1, uint64_t *a2, _DWORD *a3, unsigned __int8 *a4, unsigned int a5)
{
  uint64_t v7 = 0;
  uint64_t result = _libssh2_base64_decode(a1, a2, &v7, a4, a5);
  if (a3) {
    *a3 = v7;
  }
  return result;
}

uint64_t _libssh2_base64_decode(uint64_t a1, uint64_t *a2, void *a3, unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v10 = (*(uint64_t (**)(unint64_t, uint64_t))(a1 + 8))(3 * ((unint64_t)a5 >> 2) + 1, a1);
  *a2 = v10;
  if (!v10)
  {
    uint64_t v17 = "Unable to allocate memory for base64 decoding";
    uint64_t v18 = 4294967290;
    uint64_t v19 = a1;
    uint64_t v20 = 4294967290;
    goto LABEL_19;
  }
  if (a5 < 1)
  {
    uint64_t v11 = 0;
LABEL_21:
    uint64_t v18 = 0;
    *a3 = v11;
    return v18;
  }
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = &a4[a5];
  do
  {
    unsigned int v14 = base64_reverse_table[*a4];
    if ((v14 & 0x80000000) == 0)
    {
      if (v12 <= 0) {
        uint64_t v15 = -(-v12 & 3);
      }
      else {
        uint64_t v15 = v12 & 3;
      }
      switch(v15)
      {
        case 0:
          char v16 = 4 * v14;
          goto LABEL_12;
        case 1:
          *(unsigned char *)(v10 + v11++) |= v14 >> 4;
          char v16 = 16 * v14;
          goto LABEL_12;
        case 2:
          *(unsigned char *)(v10 + v11++) |= v14 >> 2;
          char v16 = (_BYTE)v14 << 6;
LABEL_12:
          *(unsigned char *)(v10 + v11) = v16;
          break;
        case 3:
          *(unsigned char *)(v10 + v11++) |= v14;
          break;
        default:
          break;
      }
      ++v12;
    }
    ++a4;
  }
  while (a4 < v13);
  if ((v12 & 0x8000000000000003) != 1) {
    goto LABEL_21;
  }
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(*a2, a1);
  *a2 = 0;
  uint64_t v17 = "Invalid base64";
  uint64_t v18 = 4294967262;
  uint64_t v19 = a1;
  uint64_t v20 = 4294967262;
LABEL_19:
  _libssh2_error_flags(v19, v20, v17, 0);
  return v18;
}

const char *_libssh2_base64_encode(uint64_t a1, char *__s, size_t a3, const char **a4)
{
  size_t v5 = a3;
  BOOL v6 = __s;
  *a4 = 0;
  if (!a3) {
    size_t v5 = strlen(__s);
  }
  uint64_t result = (const char *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(4 * v5 / 3 + 4, a1);
  if (result)
  {
    uint64_t v9 = (char *)result;
    if (v5)
    {
      uint64_t v9 = (char *)result;
      do
      {
        uint64_t v10 = 0;
        int v11 = 0;
        do
        {
          if (v5)
          {
            ++v11;
            char v13 = *v6++;
            char v12 = v13;
            --v5;
          }
          else
          {
            char v12 = 0;
          }
          *(&v19 + v10++) = v12;
        }
        while (v10 != 3);
        unint64_t v14 = (unint64_t)v19 >> 2;
        unint64_t v15 = ((unint64_t)v20 >> 4) & 0xFFFFFFFFFFFFFFCFLL | (16 * (v19 & 3));
        unsigned __int8 v16 = v21;
        unint64_t v17 = ((unint64_t)v21 >> 6) & 0xFFFFFFFFFFFFFFC3 | (4 * (v20 & 0xF));
        if (v11 == 2)
        {
          *uint64_t v9 = table64[v14];
          v9[1] = table64[v15];
          v9[2] = table64[v17];
          char v18 = 61;
        }
        else
        {
          *uint64_t v9 = table64[v14];
          v9[1] = table64[v15];
          if (v11 == 1)
          {
            char v18 = 61;
            v9[2] = 61;
          }
          else
          {
            v9[2] = table64[v17];
            char v18 = table64[v16 & 0x3F];
          }
        }
        void v9[3] = v18;
        v9 += 4;
      }
      while (v5);
    }
    *uint64_t v9 = 0;
    *a4 = result;
    return (const char *)strlen(result);
  }
  return result;
}

uint64_t libssh2_free(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 24))(a2, a1);
}

uint64_t libssh2_trace()
{
  return 0;
}

uint64_t libssh2_trace_sethandler()
{
  return 0;
}

void *_libssh2_list_init(void *result)
{
  *uint64_t result = 0;
  result[1] = 0;
  return result;
}

void *_libssh2_list_add(void **a1, void *a2)
{
  a2[2] = a1;
  uint64_t v2 = *a1;
  *a2 = 0;
  a2[1] = v2;
  *a1 = a2;
  uint64_t result = a1 + 1;
  if (!v2) {
    uint64_t v2 = result;
  }
  *uint64_t v2 = a2;
  return result;
}

uint64_t _libssh2_list_first(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t _libssh2_list_next(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t _libssh2_list_prev(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t *_libssh2_list_remove(uint64_t *result)
{
  uint64_t v2 = *result;
  uint64_t v1 = (void *)result[1];
  if (!v1)
  {
    *(void *)(result[2] + 8) = v2;
    if (v2) {
      goto LABEL_3;
    }
LABEL_5:
    uint64_t v3 = (void *)result[2];
    goto LABEL_6;
  }
  *uint64_t v1 = v2;
  uint64_t v2 = *result;
  if (!*result) {
    goto LABEL_5;
  }
LABEL_3:
  uint64_t v3 = (void *)(v2 + 8);
LABEL_6:
  *uint64_t v3 = v1;
  return result;
}

void *_libssh2_calloc(uint64_t a1, size_t a2)
{
  uint64_t v3 = (void *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(a2, a1);
  uint64_t v4 = v3;
  if (v3) {
    bzero(v3, a2);
  }
  return v4;
}

unsigned char *_libssh2_xor_data(unsigned char *result, char *a2, char *a3, uint64_t a4)
{
  for (; a4; --a4)
  {
    char v5 = *a2++;
    char v4 = v5;
    char v6 = *a3++;
    *result++ = v6 ^ v4;
  }
  return result;
}

unint64_t _libssh2_aes_ctr_increment(unint64_t result, uint64_t a2)
{
  uint64_t v2 = (unsigned __int8 *)(result + a2 - 1);
  if ((unint64_t)v2 >= result)
  {
    int v3 = 1;
    do
    {
      unsigned int v4 = v3 + *v2;
      *v2-- = v4;
      int v3 = v4 >> 8;
    }
    while ((unint64_t)v2 >= result);
  }
  return result;
}

void *_libssh2_string_buf_new(uint64_t a1)
{
  uint64_t result = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(24, a1);
  if (result)
  {
    *uint64_t result = 0;
    result[1] = 0;
    result[2] = 0;
  }
  return result;
}

uint64_t _libssh2_string_buf_free(uint64_t result, void *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    if (*a2) {
      (*(void (**)(void, uint64_t))(result + 24))(*a2, result);
    }
    unsigned int v4 = *(uint64_t (**)(void *, uint64_t))(v3 + 24);
    return v4(a2, v3);
  }
  return result;
}

uint64_t _libssh2_get_byte(void *a1, unsigned char *a2)
{
  uint64_t v2 = (unsigned char *)a1[1];
  unint64_t v3 = a1[2];
  unint64_t v4 = *a1 + v3 - (void)v2;
  if (v4) {
    BOOL v5 = v4 > v3;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  *a2 = *v2;
  ++a1[1];
  return result;
}

BOOL _libssh2_check_length(void *a1, unint64_t a2)
{
  unint64_t v2 = a1[2];
  unint64_t v3 = *a1 + v2 - a1[1];
  return v3 >= a2 && v3 <= v2;
}

uint64_t _libssh2_get_BOOLean(void *a1, BOOL *a2)
{
  unint64_t v2 = (unsigned char *)a1[1];
  unint64_t v3 = a1[2];
  unint64_t v4 = *a1 + v3 - (void)v2;
  if (v4) {
    BOOL v5 = v4 > v3;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  *a2 = *v2 != 0;
  ++a1[1];
  return result;
}

uint64_t _libssh2_get_u32(void *a1, _DWORD *a2)
{
  unint64_t v2 = (unsigned int *)a1[1];
  unint64_t v3 = a1[2];
  unint64_t v4 = *a1 + v3 - (void)v2;
  if (v4 >= 4)
  {
    BOOL v5 = v4 >= v3;
    BOOL v6 = v4 == v3;
  }
  else
  {
    BOOL v5 = 1;
    BOOL v6 = 0;
  }
  if (!v6 && v5) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  *a2 = bswap32(*v2);
  a1[1] = v2 + 1;
  return result;
}

uint64_t _libssh2_get_u64(uint64_t a1, unint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  unint64_t v2 = *(void *)(a1 + 16);
  unint64_t v4 = *(void *)a1 + v2 - v3;
  if (v4 < 8 || v4 > v2) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v8 = _libssh2_ntohu64(*(unint64_t **)(a1 + 8));
  uint64_t result = 0;
  *a2 = v8;
  *(void *)(a1 + 8) = v3 + 8;
  return result;
}

uint64_t _libssh2_match_string(void *a1, const char *a2)
{
  size_t v4 = 0;
  __s1 = 0;
  if (_libssh2_get_string(a1, &__s1, &v4) || v4 != strlen(a2)) {
    return 0xFFFFFFFFLL;
  }
  if (!strncmp(__s1, a2, v4)) {
    return 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t _libssh2_get_string(void *a1, void *a2, void *a3)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v12 = 0;
  if (_libssh2_get_u32(a1, &v12)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = v12;
  uint64_t v7 = a1[1];
  unint64_t v8 = a1[2];
  unint64_t v9 = *a1 + v8 - v7;
  if (v9 < v12 || v9 > v8) {
    return 0xFFFFFFFFLL;
  }
  *a2 = v7;
  a1[1] += v6;
  uint64_t result = 0;
  if (a3) {
    *a3 = v6;
  }
  return result;
}

uint64_t _libssh2_copy_string(uint64_t a1, void *a2, void *a3, size_t *a4)
{
  uint64_t v10 = 0;
  size_t v11 = 0;
  if (_libssh2_get_string(a2, &v10, &v11)) {
    return 0xFFFFFFFFLL;
  }
  if (!v11)
  {
    size_t v9 = 0;
    *a3 = 0;
    goto LABEL_8;
  }
  unint64_t v8 = (void *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v11, a1);
  *a3 = v8;
  if (!v8) {
    return 0xFFFFFFFFLL;
  }
  memcpy(v8, v10, v11);
  if (a4)
  {
    size_t v9 = v11;
LABEL_8:
    uint64_t result = 0;
    *a4 = v9;
    return result;
  }
  return 0;
}

uint64_t _libssh2_get_bignum_bytes(void *a1, void *a2, void *a3)
{
  unsigned int v14 = 0;
  if (_libssh2_get_u32(a1, &v14)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = v14;
  uint64_t v7 = (unsigned char *)a1[1];
  unint64_t v8 = a1[2];
  unint64_t v9 = *a1 + v8 - (void)v7;
  if (v9 < v14 || v9 > v8) {
    return 0xFFFFFFFFLL;
  }
  if (v14)
  {
    unsigned int v12 = &v7[v14];
    unsigned int v13 = v14;
    while (!*v7)
    {
      ++v7;
      if (!--v13)
      {
        uint64_t v7 = v12;
        break;
      }
    }
  }
  else
  {
    unsigned int v13 = 0;
  }
  *a2 = v7;
  a1[1] += v6;
  uint64_t result = 0;
  if (a3) {
    *a3 = v13;
  }
  return result;
}

BOOL _libssh2_eob(void *a1)
{
  return a1[1] >= *a1 + a1[2];
}

void _libssh2_store_str_cold_1()
{
  __assert_rtn("_libssh2_store_str", "misc.c", 268, "len_stored == len");
}

void _libssh2_store_bignum2_bytes_cold_1()
{
  __assert_rtn("_libssh2_store_bignum2_bytes", "misc.c", 300, "len_stored == len");
}

char ***_libssh2_mac_methods()
{
  return mac_methods;
}

char **_libssh2_mac_override(const char **a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = &mac_method_hmac_aesgcm;
  if (strcmp(*a1, "aes256-gcm@openssh.com") && strcmp(v1, "aes128-gcm@openssh.com")) {
    return 0;
  }
  return v2;
}

uint64_t mac_method_common_init(uint64_t a1, uint64_t a2, _DWORD *a3, void *a4)
{
  *a4 = a2;
  *a3 = 0;
  return 0;
}

uint64_t mac_method_hmac_sha2_256_hash(uint64_t a1, unsigned __int8 *a2, unsigned int a3, const unsigned __int8 *a4, size_t a5, const unsigned __int8 *a6, size_t a7, const void **a8)
{
  _libssh2_htonu32(&data, a3);
  unsigned int v14 = HMAC_CTX_new();
  unint64_t v15 = *a8;
  unsigned __int8 v16 = EVP_sha256();
  HMAC_Init_ex(v14, v15, 32, v16, 0);
  HMAC_Update(v14, (const unsigned __int8 *)&data, 4uLL);
  HMAC_Update(v14, a4, a5);
  if (a6 && a7) {
    HMAC_Update(v14, a6, a7);
  }
  HMAC_Final(v14, a2, 0);
  HMAC_CTX_free(v14);
  return 0;
}

uint64_t mac_method_common_dtor(uint64_t a1, void *a2)
{
  if (*a2) {
    (*(void (**)(void))(a1 + 24))();
  }
  *a2 = 0;
  return 0;
}

uint64_t mac_method_hmac_sha2_512_hash(uint64_t a1, unsigned __int8 *a2, unsigned int a3, const unsigned __int8 *a4, size_t a5, const unsigned __int8 *a6, size_t a7, const void **a8)
{
  _libssh2_htonu32(&data, a3);
  unsigned int v14 = HMAC_CTX_new();
  unint64_t v15 = *a8;
  unsigned __int8 v16 = EVP_sha512();
  HMAC_Init_ex(v14, v15, 64, v16, 0);
  HMAC_Update(v14, (const unsigned __int8 *)&data, 4uLL);
  HMAC_Update(v14, a4, a5);
  if (a6 && a7) {
    HMAC_Update(v14, a6, a7);
  }
  HMAC_Final(v14, a2, 0);
  HMAC_CTX_free(v14);
  return 0;
}

uint64_t mac_method_hmac_sha1_hash(uint64_t a1, unsigned __int8 *a2, unsigned int a3, const unsigned __int8 *a4, size_t a5, const unsigned __int8 *a6, size_t a7, const void **a8)
{
  _libssh2_htonu32(&data, a3);
  unsigned int v14 = HMAC_CTX_new();
  unint64_t v15 = *a8;
  unsigned __int8 v16 = EVP_sha1();
  HMAC_Init_ex(v14, v15, 20, v16, 0);
  HMAC_Update(v14, (const unsigned __int8 *)&data, 4uLL);
  HMAC_Update(v14, a4, a5);
  if (a6 && a7) {
    HMAC_Update(v14, a6, a7);
  }
  HMAC_Final(v14, a2, 0);
  HMAC_CTX_free(v14);
  return 0;
}

uint64_t mac_method_hmac_sha1_96_hash(uint64_t a1, uint64_t a2, unsigned int a3, const unsigned __int8 *a4, size_t a5, const unsigned __int8 *a6, size_t a7, const void **a8)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  mac_method_hmac_sha1_hash(a1, (unsigned __int8 *)&v10, a3, a4, a5, a6, a7, a8);
  *(void *)a2 = v10;
  *(_DWORD *)(a2 + 8) = v11;
  return 0;
}

uint64_t mac_method_hmac_md5_hash(uint64_t a1, unsigned __int8 *a2, unsigned int a3, const unsigned __int8 *a4, size_t a5, const unsigned __int8 *a6, size_t a7, const void **a8)
{
  _libssh2_htonu32(&data, a3);
  unsigned int v14 = HMAC_CTX_new();
  unint64_t v15 = *a8;
  unsigned __int8 v16 = EVP_md5();
  HMAC_Init_ex(v14, v15, 16, v16, 0);
  HMAC_Update(v14, (const unsigned __int8 *)&data, 4uLL);
  HMAC_Update(v14, a4, a5);
  if (a6 && a7) {
    HMAC_Update(v14, a6, a7);
  }
  HMAC_Final(v14, a2, 0);
  HMAC_CTX_free(v14);
  return 0;
}

uint64_t mac_method_hmac_md5_96_hash(uint64_t a1, uint64_t a2, unsigned int a3, const unsigned __int8 *a4, size_t a5, const unsigned __int8 *a6, size_t a7, const void **a8)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  mac_method_hmac_md5_hash(a1, (unsigned __int8 *)&v10, a3, a4, a5, a6, a7, a8);
  *(void *)a2 = v10;
  *(_DWORD *)(a2 + 8) = v11;
  return 0;
}

uint64_t mac_method_hmac_ripemd160_hash(uint64_t a1, unsigned __int8 *a2, unsigned int a3, const unsigned __int8 *a4, size_t a5, const unsigned __int8 *a6, size_t a7, const void **a8)
{
  _libssh2_htonu32(&data, a3);
  unsigned int v14 = HMAC_CTX_new();
  unint64_t v15 = *a8;
  unsigned __int8 v16 = EVP_ripemd160();
  HMAC_Init_ex(v14, v15, 20, v16, 0);
  HMAC_Update(v14, (const unsigned __int8 *)&data, 4uLL);
  HMAC_Update(v14, a4, a5);
  if (a6 && a7) {
    HMAC_Update(v14, a6, a7);
  }
  HMAC_Final(v14, a2, 0);
  HMAC_CTX_free(v14);
  return 0;
}

const char *libssh2_version(int a1)
{
  if (a1 >= 68353) {
    return 0;
  }
  else {
    return "1.11.0";
  }
}

uint64_t libssh2_crypto_engine()
{
  return 1;
}

uint64_t libssh2_init(int a1)
{
  int v2 = _libssh2_initialized;
  if (!(_libssh2_initialized | a1 & 1))
  {
    _libssh2_openssl_crypto_init();
    int v2 = _libssh2_initialized;
  }
  _libssh2_initialized = v2 + 1;
  _libssh2_init_flags |= a1;
  return 0;
}

uint64_t libssh2_exit()
{
  int v0 = _libssh2_initialized;
  if (_libssh2_initialized)
  {
    --_libssh2_initialized;
    if (v0 == 1 && (_libssh2_init_flags & 1) == 0) {
      return _libssh2_openssl_crypto_exit();
    }
  }
  return result;
}

uint64_t _libssh2_init_if_needed()
{
  if (!_libssh2_initialized)
  {
    uint64_t result = _libssh2_openssl_crypto_init();
    ++_libssh2_initialized;
  }
  return result;
}

uint64_t _libssh2_packet_add(uint64_t a1, unsigned __int8 *a2, unint64_t a3, int a4)
{
  uint64_t v5 = a1 + 72616;
  uint64_t v6 = a1 + 72040;
  uint64_t v7 = (void *)(a1 + 35664);
  uint64_t v108 = 0;
  uint64_t v109 = 0;
  uint64_t v106 = 0;
  uint64_t v107 = 0;
  int v8 = *a2;
  int v9 = *(_DWORD *)(a1 + 72600);
  unint64_t v10 = a3;
  unint64_t v12 = 0;
  switch(v9)
  {
    case 0:
      if (a4 != -1
        || (unsigned __int8 v19 = *(unsigned int (**)(uint64_t, unsigned __int8 *, unint64_t, uint64_t))(a1 + 56)) != 0
        && !v19(a1, a2, a3, a1))
      {
        *(_DWORD *)(v6 + 560) = 1;
LABEL_4:
        unint64_t v12 = 0;
        unint64_t v13 = 9;
        switch(v8)
        {
          case 'P':
            if (v10 >= 5)
            {
              unsigned int v14 = _libssh2_ntohu32((unsigned int *)(a2 + 1));
              if (v14 <= 0xFFFFFFF9 && v14 + 6 <= v10 && a2[v14 + 5]) {
                goto LABEL_9;
              }
            }
            goto LABEL_97;
          case 'Q':
          case 'R':
          case 'S':
          case 'T':
          case 'U':
          case 'V':
          case 'W':
          case 'X':
          case 'Y':
          case '[':
          case '\\':
            goto LABEL_110;
          case 'Z':
            if (v10 < 0x11) {
              goto LABEL_91;
            }
            if (v10 >= 0x14
              && _libssh2_ntohu32((unsigned int *)(a2 + 1)) == 15
              && *(void *)(a2 + 5) == 0x6564726177726F66
              && *(void *)(a2 + 12) == 0x70697063742D6465)
            {
              *(void *)(a1 + 72712) = 0;
              *(_OWORD *)(a1 + 72680) = 0u;
              *(_OWORD *)(a1 + 72696) = 0u;
              *(_OWORD *)(a1 + 72648) = 0u;
              *(_OWORD *)(a1 + 72664) = 0u;
              *(_OWORD *)(a1 + 72616) = 0u;
              *(_OWORD *)(a1 + 72632) = 0u;
              goto LABEL_192;
            }
            if (_libssh2_ntohu32((unsigned int *)(a2 + 1)) == 3
              && *(_WORD *)(a2 + 5) == 12664
              && a2[7] == 49)
            {
              *(void *)(a1 + 72800) = 0;
              *(_OWORD *)(a1 + 72768) = 0u;
              *(_OWORD *)(a1 + 72784) = 0u;
              *(_OWORD *)(a1 + 72736) = 0u;
              *(_OWORD *)(a1 + 72752) = 0u;
              *(_OWORD *)(a1 + 72720) = 0u;
              goto LABEL_155;
            }
            if (v10 >= 0x1B && _libssh2_ntohu32((unsigned int *)(a2 + 1)) == 22)
            {
              BOOL v23 = *(void *)(a2 + 5) == 0x6567612D68747561 && *(void *)(a2 + 13) == 0x736E65706F40746ELL;
              if (v23 && *(void *)(a2 + 19) == 0x6D6F632E6873736ELL)
              {
                *(_OWORD *)(a1 + 72840) = 0u;
                *(_OWORD *)(a1 + 72856) = 0u;
                *(_OWORD *)(a1 + 72808) = 0u;
                *(_OWORD *)(a1 + 72824) = 0u;
                goto LABEL_46;
              }
            }
LABEL_91:
            uint64_t v18 = 0;
            goto LABEL_238;
          case ']':
            if (v10 >= 9)
            {
              int v32 = _libssh2_ntohu32((unsigned int *)(a2 + 5));
              int v33 = _libssh2_ntohu32((unsigned int *)(a2 + 1));
              uint64_t v34 = _libssh2_channel_locate(a1, v33);
              if (v34) {
                *(_DWORD *)(v34 + 56) += v32;
              }
            }
            goto LABEL_97;
          case '^':
            goto LABEL_62;
          case '_':
            unint64_t v13 = 13;
LABEL_62:
            unint64_t v35 = v10 - v13;
            if (v10 >= v13
              && (int v36 = _libssh2_ntohu32((unsigned int *)(a2 + 1)), (v37 = _libssh2_channel_locate(a1, v36)) != 0))
            {
              uint64_t v15 = v37;
              if (*(unsigned char *)(v37 + 86) == 1 && v8 == 95)
              {
                (*(void (**)(unsigned __int8 *, uint64_t))(a1 + 24))(a2, a1);
                uint64_t v38 = *(void *)(v15 + 96);
                unint64_t v39 = v35 + v38;
                unint64_t v40 = *(unsigned int *)(v15 + 76);
                int v41 = v13 - v38 + v40;
                if (v39 >= v40) {
                  LODWORD(v10) = v41;
                }
                *(_DWORD *)(v15 + 76) = v40 + v13 - v10;
                *(void *)(v6 + 568) = v15;
LABEL_12:
                *(_DWORD *)(v6 + 560) = 11;
                int v16 = _libssh2_channel_receive_window_adjust(v15, (v10 - 13), 1, 0);
                goto LABEL_117;
              }
              if (v35 > *(unsigned int *)(v37 + 80))
              {
                _libssh2_error(a1, 4294967271, "Packet contains more data than we offered to receive, truncating");
                unint64_t v10 = v13 + *(unsigned int *)(v15 + 80);
              }
              unint64_t v60 = *(unsigned int *)(v15 + 76);
              unint64_t v61 = *(void *)(v15 + 96);
              if (v61 < v60)
              {
                *(unsigned char *)(v15 + 85) = 0;
                unint64_t v62 = v10 - v13 + v61;
                if (v62 > v60)
                {
                  _libssh2_error(a1, 4294967272, "Remote sent more data than current window allows, truncating");
                  unint64_t v10 = v13 - *(void *)(v15 + 96) + *(unsigned int *)(v15 + 76);
                  unint64_t v62 = *(unsigned int *)(v15 + 76);
                }
                *(void *)(v15 + 96) = v62;
                unint64_t v12 = v13;
LABEL_110:
                *(_DWORD *)(v6 + 560) = 3;
LABEL_111:
                uint64_t v63 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(48, a1);
                if (!v63)
                {
                  (*(void (**)(unsigned __int8 *, uint64_t))(a1 + 24))(a2, a1);
                  *(_DWORD *)(v6 + 560) = 0;
                  return 4294967290;
                }
                v63[3] = a2;
                v63[4] = v10;
                v63[5] = v12;
                _libssh2_list_add((void **)(a1 + 536), v63);
                int v9 = 4;
                *(_DWORD *)(v6 + 560) = 4;
LABEL_113:
                if (v8 != 20 || (*(unsigned char *)(a1 + 128)) && v9 != 5) {
                  goto LABEL_119;
                }
                *(_DWORD *)uint64_t v6 = 0;
                *uint64_t v7 = 0;
                *(_DWORD *)(v6 + 560) = 0;
                *(_DWORD *)(v5 + 256) = 0;
                bzero((void *)(a1 + 71088), 0x298uLL);
                int v16 = _libssh2_kex_exchange(a1, 1, a1 + 71088);
LABEL_117:
                if (v16 == -37) {
                  return 4294967259;
                }
LABEL_119:
                uint64_t v18 = 0;
LABEL_239:
                *(_DWORD *)(v6 + 560) = 0;
                return v18;
              }
              uint64_t v42 = "The current receive window is full, data ignored";
              uint64_t v43 = a1;
              uint64_t v44 = 4294967272;
            }
            else
            {
              uint64_t v42 = "Packet received for unknown channel";
              uint64_t v43 = a1;
              uint64_t v44 = 4294967273;
            }
            _libssh2_error(v43, v44, v42);
            goto LABEL_97;
            if (v10 >= 5)
            {
              int v45 = _libssh2_ntohu32((unsigned int *)(a2 + 1));
              uint64_t v46 = _libssh2_channel_locate(a1, v45);
              if (v46) {
                *(unsigned char *)(v46 + 85) = 1;
              }
            }
            goto LABEL_97;
          case 'a':
            if (v10 >= 5)
            {
              int v47 = _libssh2_ntohu32((unsigned int *)(a2 + 1));
              uint64_t v48 = _libssh2_channel_locate(a1, v47);
              if (v48) {
                *(_WORD *)(v48 + 84) = 257;
              }
            }
            goto LABEL_97;
          case 'b':
            if (v10 < 9) {
              goto LABEL_91;
            }
            int v49 = _libssh2_ntohu32((unsigned int *)(a2 + 1));
            int v50 = _libssh2_ntohu32((unsigned int *)(a2 + 5));
            unint64_t v51 = (v50 + 9);
            if (v51 >= v10) {
              int v52 = 1;
            }
            else {
              int v52 = a2[v51];
            }
            uint64_t v18 = 0;
            if (v10 < 0x14 || v50 != 11) {
              goto LABEL_211;
            }
            if (*(void *)(a2 + 9) == 0x6174732D74697865 && *(void *)(a2 + 12) == 0x7375746174732D74)
            {
              uint64_t v70 = _libssh2_channel_locate(a1, v49);
              uint64_t v18 = 0;
              if (v10 >= 0x19 && v70)
              {
                uint64_t v18 = 0;
                *(_DWORD *)(v70 + 36) = _libssh2_ntohu32((unsigned int *)(a2 + 21));
              }
            }
            else
            {
              if (*(void *)(a2 + 9) != 0x6769732D74697865 || *(void *)(a2 + 12) != 0x6C616E6769732D74) {
                goto LABEL_132;
              }
              uint64_t v83 = _libssh2_channel_locate(a1, v49);
              uint64_t v18 = 0;
              if (v10 >= 0x19)
              {
                uint64_t v84 = v83;
                if (v83)
                {
                  unsigned int v85 = _libssh2_ntohu32((unsigned int *)(a2 + 21));
                  if (v85 == -1)
                  {
                    *(void *)(v84 + 40) = 0;
                  }
                  else
                  {
                    unsigned int v86 = v85;
                    unint64_t v87 = (void *)(*(uint64_t (**)(void, uint64_t))(a1 + 8))(v85 + 1, a1);
                    *(void *)(v84 + 40) = v87;
                    if (v87)
                    {
                      if ((unint64_t)v86 + 25 > v10)
                      {
LABEL_132:
                        uint64_t v18 = 0;
                        goto LABEL_211;
                      }
                      uint64_t v88 = v86;
                      memcpy(v87, a2 + 25, v86);
                      uint64_t v18 = 0;
                      *(unsigned char *)(*(void *)(v84 + 40) + v88) = 0;
                      goto LABEL_211;
                    }
                  }
                  uint64_t v18 = _libssh2_error(a1, 4294967290, "memory for signal name");
                }
              }
            }
LABEL_211:
            if (v52)
            {
LABEL_212:
              *(_DWORD *)(v6 + 560) = 14;
              char v101 = 100;
              int v102 = *(_DWORD *)(a2 + 1);
              uint64_t v18 = _libssh2_transport_send(a1, &v101, 5uLL);
              if (v18 == -37) {
                return v18;
              }
            }
LABEL_238:
            (*(void (**)(unsigned __int8 *, uint64_t))(a1 + 24))(a2, a1);
            goto LABEL_239;
          default:
            switch(v8)
            {
              case 1:
                if (v10 >= 5)
                {
                  LODWORD(v114) = 0;
                  size_t v110 = a2;
                  uint64_t v111 = a2 + 1;
                  unint64_t v112 = v10;
                  _libssh2_get_u32(&v110, &v114);
                  _libssh2_get_string(&v110, &v109, &v107);
                  _libssh2_get_string(&v110, &v108, &v106);
                  unint64_t v17 = *(void (**)(uint64_t, void, uint64_t, void, uint64_t, void, uint64_t))(a1 + 48);
                  if (v17) {
                    v17(a1, v114, v109, v107, v108, v106, a1);
                  }
                }
                (*(void (**)(unsigned __int8 *, uint64_t))(a1 + 24))(a2, a1);
                *(_DWORD *)(a1 + 596) = -1;
                *(_DWORD *)(v6 + 560) = 0;
                return _libssh2_error(a1, 4294967283, "socket disconnect");
              case 2:
                uint64_t v53 = *(void (**)(uint64_t, const char *, uint64_t, uint64_t))(a1 + 32);
                if (v10 < 2)
                {
                  if (!v53) {
                    goto LABEL_97;
                  }
                  uint64_t v54 = "";
                  uint64_t v56 = a1;
                  uint64_t v55 = 0;
                }
                else
                {
                  if (!v53) {
                    goto LABEL_97;
                  }
                  uint64_t v54 = (const char *)(a2 + 1);
                  uint64_t v55 = (v10 - 1);
                  uint64_t v56 = a1;
                }
                v53(v56, v54, v55, a1);
                break;
              case 4:
                if (v10 >= 2)
                {
                  uint64_t v57 = a2[1];
                  if (v10 >= 6)
                  {
                    size_t v110 = a2;
                    uint64_t v111 = a2 + 2;
                    unint64_t v112 = v10;
                    _libssh2_get_string(&v110, &v109, &v107);
                    _libssh2_get_string(&v110, &v108, &v106);
                  }
                  uint64_t v58 = *(void (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, void, uint64_t))(a1 + 40);
                  if (v58) {
                    v58(a1, v57, v109, v107, v108, v106, a1);
                  }
                }
                goto LABEL_97;
              case 7:
                if (v10 < 5) {
                  goto LABEL_91;
                }
                int v105 = 0;
                size_t v110 = a2;
                uint64_t v111 = a2 + 1;
                unint64_t v112 = v10;
                if (_libssh2_get_u32(&v110, &v105)) {
                  uint64_t v18 = _libssh2_error(a1, 4294967282, "Invalid extension info received");
                }
                else {
                  uint64_t v18 = 0;
                }
                if (!v18)
                {
                  for (int i = v105; v105; int i = v105)
                  {
                    unint64_t v114 = 0;
                    size_t __n = 0;
                    __src = 0;
                    size_t v104 = 0;
                    int v105 = i - 1;
                    _libssh2_get_string(&v110, &v104, &v114);
                    _libssh2_get_string(&v110, &__src, &__n);
                    if (v114 == (_DWORD *)15
                      && (*v104 == 0x732D726576726573
                        ? (BOOL v67 = *(void *)((char *)v104 + 7) == 0x73676C612D676973)
                        : (BOOL v67 = 0),
                          v67))
                    {
                      uint64_t v68 = *(void *)(a1 + 296);
                      if (v68) {
                        (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v68, a1);
                      }
                      uint64_t v69 = (void *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(__n + 1, a1);
                      *(void *)(a1 + 296) = v69;
                      if (v69)
                      {
                        memcpy(v69, __src, __n);
                        uint64_t v18 = 0;
                        *(unsigned char *)(*(void *)(a1 + 296) + __n) = 0;
                      }
                      else
                      {
                        uint64_t v18 = _libssh2_error(a1, 4294967290, "memory for server sign algo");
                      }
                    }
                    else
                    {
                      uint64_t v18 = 0;
                    }
                    if (v18) {
                      break;
                    }
                  }
                }
                goto LABEL_238;
              default:
                goto LABEL_110;
            }
            goto LABEL_97;
        }
      }
      (*(void (**)(unsigned __int8 *, uint64_t))(a1 + 24))(a2, a1);
      return _libssh2_error(a1, 4294967292, "Invalid MAC received");
    case 1:
      goto LABEL_4;
    case 3:
      goto LABEL_111;
    case 11:
      uint64_t v15 = *(void *)(a1 + 72608);
      goto LABEL_12;
    case 12:
LABEL_192:
      *(_DWORD *)(v6 + 560) = 12;
      unint64_t v114 = 0;
      uint64_t v89 = _libssh2_list_first(a1 + 576);
      if (*(_DWORD *)v5 == 3)
      {
        unsigned int v91 = 1;
      }
      else
      {
        uint64_t v90 = v89;
        if (!*(_DWORD *)v5)
        {
          unint64_t v112 = v10;
          size_t __n = 0;
          size_t v110 = a2;
          if (v10 <= 0x13)
          {
            size_t v79 = "Unexpected packet size";
            uint64_t v80 = a1;
            uint64_t v81 = 4294967255;
            goto LABEL_236;
          }
          uint64_t v111 = a2 + 20;
          if (_libssh2_get_u32(&v110, (_DWORD *)(a1 + 72680)))
          {
            size_t v79 = "Data too short extracting channel";
LABEL_219:
            uint64_t v80 = a1;
            uint64_t v81 = 4294967258;
            goto LABEL_236;
          }
          if (_libssh2_get_u32(&v110, (_DWORD *)(a1 + 72684)))
          {
            size_t v79 = "Data too short extracting window size";
            goto LABEL_219;
          }
          if (_libssh2_get_u32(&v110, (_DWORD *)(a1 + 72688)))
          {
            size_t v79 = "Data too short extracting packet";
            goto LABEL_219;
          }
          if (_libssh2_get_string(&v110, (void *)(a1 + 72664), &__n))
          {
            size_t v79 = "Data too short extracting host";
            goto LABEL_219;
          }
          *(_DWORD *)(v5 + 84) = __n;
          if (_libssh2_get_u32(&v110, (_DWORD *)(a1 + 72692)))
          {
            size_t v79 = "Data too short extracting port";
            goto LABEL_219;
          }
          if (_libssh2_get_string(&v110, (void *)(a1 + 72672), &__n))
          {
            size_t v79 = "Data too short extracting shost";
            goto LABEL_219;
          }
          *(_DWORD *)(v5 + 88) = __n;
          if (_libssh2_get_u32(&v110, (_DWORD *)(a1 + 72696)))
          {
            size_t v79 = "Data too short extracting sport";
            goto LABEL_219;
          }
          *(_DWORD *)uint64_t v5 = 1;
        }
        if (v90)
        {
          while (1)
          {
            if (*(_DWORD *)(v90 + 40) == *(_DWORD *)(v5 + 76))
            {
              size_t v92 = strlen(*(const char **)(v90 + 32));
              if (v92 == *(_DWORD *)(v5 + 84) && !memcmp(*(const void **)(v90 + 32), *(const void **)(v5 + 48), v92))
              {
                *(void *)(v5 + 96) = 0;
                if (*(_DWORD *)v5 == 2) {
                  goto LABEL_246;
                }
                if (*(_DWORD *)v5 == 1) {
                  break;
                }
              }
            }
            uint64_t v90 = _libssh2_list_next(v90);
            if (!v90) {
              goto LABEL_228;
            }
          }
          int v94 = *(_DWORD *)(v90 + 68);
          if (!v94 || v94 > *(_DWORD *)(v90 + 64))
          {
            unint64_t v95 = _libssh2_calloc(a1, 0x310uLL);
            if (v95)
            {
              unsigned int v96 = v95;
              *(void *)(v5 + 96) = v95;
              v95[13] = a1;
              *((_DWORD *)v95 + 8) = 15;
              uint64_t v97 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(16, a1);
              v96[3] = v97;
              if (v97)
              {
                memcpy(v97, "forwarded-tcpip", (*((_DWORD *)v96 + 8) + 1));
                *((_DWORD *)v96 + 17) = *(_DWORD *)(v5 + 64);
                v96[9] = 0x20000000200000;
                *((_DWORD *)v96 + 20) = 0x8000;
                *((_DWORD *)v96 + 12) = _libssh2_channel_nextid(a1);
                uint64_t v98 = *(void *)(v5 + 68);
                *((_DWORD *)v96 + 13) = v98;
                v96[7] = v98;
                unint64_t v114 = (_DWORD *)(a1 + 72621);
                *(unsigned char *)(v5 + 4) = 91;
                _libssh2_store_u32(&v114, *((_DWORD *)v96 + 17));
                _libssh2_store_u32(&v114, *((_DWORD *)v96 + 12));
                _libssh2_store_u32(&v114, *((_DWORD *)v96 + 18));
                _libssh2_store_u32(&v114, *((_DWORD *)v96 + 20));
                *(_DWORD *)uint64_t v5 = 2;
LABEL_246:
                uint64_t v99 = _libssh2_transport_send(a1, (void *)(a1 + 72620), 0x11uLL);
                uint64_t v18 = v99;
                if (v99 == -37) {
                  goto LABEL_237;
                }
                if (v99)
                {
                  *(_DWORD *)uint64_t v5 = 0;
                  size_t v79 = "Unable to send channel open confirmation";
                  goto LABEL_235;
                }
                unint64_t v100 = *(void **)(v5 + 96);
                if (v100)
                {
                  _libssh2_list_add((void **)(v90 + 48), v100);
                  ++*(_DWORD *)(v90 + 64);
                }
                uint64_t v18 = 0;
LABEL_232:
                *(_DWORD *)uint64_t v5 = 0;
                goto LABEL_237;
              }
              _libssh2_error(a1, 4294967290, "Unable to allocate a channel for new connection");
              (*(void (**)(void *, uint64_t))(a1 + 24))(v96, a1);
            }
            else
            {
              _libssh2_error(a1, 4294967290, "Unable to allocate a channel for new connection");
            }
          }
          unsigned int v91 = 4;
          goto LABEL_229;
        }
LABEL_228:
        unsigned int v91 = 1;
LABEL_229:
        *(_DWORD *)uint64_t v5 = 3;
      }
      unint64_t v114 = (_DWORD *)(a1 + 72621);
      *(unsigned char *)(v5 + 4) = 92;
      _libssh2_store_u32(&v114, *(_DWORD *)(v5 + 64));
      _libssh2_store_u32(&v114, v91);
      _libssh2_store_str(&v114, "Forward not requested", 0x15uLL);
      _libssh2_htonu32(v114, 0);
      uint64_t v93 = _libssh2_transport_send(a1, (void *)(v5 + 4), 0x26uLL);
      uint64_t v18 = v93;
      if (v93 == -37) {
        goto LABEL_237;
      }
      if (!v93) {
        goto LABEL_232;
      }
      *(_DWORD *)uint64_t v5 = 0;
      goto LABEL_234;
    case 13:
LABEL_155:
      *(_DWORD *)(v6 + 560) = 13;
      unint64_t v114 = 0;
      size_t v71 = *(void **)(v5 + 184);
      int v72 = *(_DWORD *)(v5 + 104);
      if (v72) {
        goto LABEL_156;
      }
      unint64_t v112 = v10;
      size_t __n = 0;
      size_t v110 = a2;
      if (v10 <= 7)
      {
        unint64_t v77 = "unexpected data length";
LABEL_172:
        _libssh2_error(a1, 4294967262, v77);
        goto LABEL_173;
      }
      uint64_t v111 = a2 + 8;
      if (_libssh2_get_u32(&v110, (_DWORD *)(a1 + 72776)))
      {
        unint64_t v77 = "unexpected sender channel size";
        goto LABEL_172;
      }
      if (_libssh2_get_u32(&v110, (_DWORD *)(a1 + 72780))
        || _libssh2_get_u32(&v110, (_DWORD *)(a1 + 72784)))
      {
        unint64_t v77 = "unexpected window size";
        goto LABEL_172;
      }
      if (_libssh2_get_string(&v110, (void *)(a1 + 72768), &__n))
      {
        unint64_t v77 = "unexpected host size";
        goto LABEL_172;
      }
      *(_DWORD *)(v5 + 176) = __n;
      if (_libssh2_get_u32(&v110, (_DWORD *)(a1 + 72788)))
      {
        unint64_t v77 = "unexpected port size";
        goto LABEL_172;
      }
      int v72 = 1;
      *(_DWORD *)(v5 + 104) = 1;
LABEL_156:
      if (!*(void *)(a1 + 64)) {
        goto LABEL_178;
      }
      if (v72 == 2) {
        goto LABEL_162;
      }
      if (v72 != 1)
      {
LABEL_173:
        unsigned int v78 = 2;
LABEL_179:
        unint64_t v114 = (_DWORD *)(a1 + 72725);
        *(unsigned char *)(v5 + 108) = 92;
        _libssh2_store_u32(&v114, *(_DWORD *)(v5 + 160));
        _libssh2_store_u32(&v114, v78);
        _libssh2_store_str(&v114, "X11 Forward Unavailable", 0x17uLL);
        _libssh2_htonu32(v114, 0);
        uint64_t v82 = _libssh2_transport_send(a1, (void *)(v5 + 108), 0x28uLL);
        uint64_t v18 = v82;
        if (v82 == -37) {
          goto LABEL_237;
        }
        if (!v82) {
          goto LABEL_181;
        }
        *(_DWORD *)(v5 + 104) = 0;
        goto LABEL_234;
      }
      unint64_t v73 = _libssh2_calloc(a1, 0x310uLL);
      if (v73)
      {
        size_t v71 = v73;
        v73[13] = a1;
        *((_DWORD *)v73 + 8) = 3;
        unint64_t v74 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(4, a1);
        v71[3] = v74;
        if (v74)
        {
          memcpy(v74, "x11", (*((_DWORD *)v71 + 8) + 1));
          *((_DWORD *)v71 + 17) = *(_DWORD *)(v5 + 160);
          v71[9] = 0x20000000200000;
          *((_DWORD *)v71 + 20) = 0x8000;
          *((_DWORD *)v71 + 12) = _libssh2_channel_nextid(a1);
          uint64_t v75 = *(void *)(v5 + 164);
          *((_DWORD *)v71 + 13) = v75;
          v71[7] = v75;
          unint64_t v114 = (_DWORD *)(a1 + 72725);
          *(unsigned char *)(v5 + 108) = 91;
          _libssh2_store_u32(&v114, *((_DWORD *)v71 + 17));
          _libssh2_store_u32(&v114, *((_DWORD *)v71 + 12));
          _libssh2_store_u32(&v114, *((_DWORD *)v71 + 18));
          _libssh2_store_u32(&v114, *((_DWORD *)v71 + 20));
          *(_DWORD *)(v5 + 104) = 2;
LABEL_162:
          uint64_t v76 = _libssh2_transport_send(a1, (void *)(a1 + 72724), 0x11uLL);
          uint64_t v18 = v76;
          if (v76 == -37) {
            goto LABEL_237;
          }
          if (v76)
          {
            *(_DWORD *)(v5 + 104) = 0;
            goto LABEL_175;
          }
          _libssh2_list_add((void **)(a1 + 552), v71);
          (*(void (**)(void, void *, void, void, void))(v71[13] + 64))(v71[13], v71, *(void *)(v5 + 152), *(unsigned int *)(v5 + 172), v71[13]);
LABEL_181:
          *(_DWORD *)(v5 + 104) = 0;
          goto LABEL_237;
        }
        _libssh2_error(a1, 4294967290, "allocate a channel for new connection");
        (*(void (**)(void *, uint64_t))(a1 + 24))(v71, a1);
      }
      else
      {
        _libssh2_error(a1, 4294967290, "allocate a channel for new connection");
      }
LABEL_178:
      unsigned int v78 = 4;
      goto LABEL_179;
    case 14:
      goto LABEL_212;
    case 15:
LABEL_9:
      *(_DWORD *)(v6 + 560) = 15;
      if (_libssh2_transport_send(a1, &_libssh2_packet_add_packet, 1uLL) == -37) {
        return 4294967259;
      }
LABEL_97:
      (*(void (**)(unsigned __int8 *, uint64_t))(a1 + 24))(a2, a1);
      goto LABEL_119;
    case 18:
LABEL_46:
      *(_DWORD *)(v6 + 560) = 18;
      size_t v25 = *(void **)(v5 + 248);
      int v26 = *(_DWORD *)(v5 + 192);
      if (!v26)
      {
        *(_DWORD *)(v5 + 236) = _libssh2_ntohu32((unsigned int *)(a2 + 27));
        *(_DWORD *)(v5 + 240) = _libssh2_ntohu32((unsigned int *)(a2 + 31));
        *(_DWORD *)(v5 + 244) = _libssh2_ntohu32((unsigned int *)(a2 + 35));
        int v26 = 1;
        *(_DWORD *)(v5 + 192) = 1;
      }
      size_t v110 = 0;
      if (!*(void *)(a1 + 72)) {
        goto LABEL_99;
      }
      if (v26 == 2) {
        goto LABEL_54;
      }
      if (v26 == 1)
      {
        size_t v27 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(784, a1);
        *(void *)(v5 + 248) = v27;
        if (v27)
        {
          size_t v25 = v27;
          bzero(v27, 0x310uLL);
          v25[13] = a1;
          *((_DWORD *)v25 + 8) = 10;
          uint64_t v28 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(11, a1);
          v25[3] = v28;
          if (v28)
          {
            memcpy(v28, "auth agent", (*((_DWORD *)v25 + 8) + 1));
            *((_DWORD *)v25 + 17) = *(_DWORD *)(v5 + 236);
            v25[9] = 0x20000000200000;
            *((_DWORD *)v25 + 20) = 0x8000;
            *((_DWORD *)v25 + 12) = _libssh2_channel_nextid(a1);
            uint64_t v29 = *(void *)(v5 + 240);
            *((_DWORD *)v25 + 13) = v29;
            v25[7] = v29;
            size_t v110 = (unsigned __int8 *)(a1 + 72813);
            *(unsigned char *)(v5 + 196) = 91;
            _libssh2_store_u32((_DWORD **)&v110, *((_DWORD *)v25 + 17));
            _libssh2_store_u32((_DWORD **)&v110, *((_DWORD *)v25 + 12));
            _libssh2_store_u32((_DWORD **)&v110, *((_DWORD *)v25 + 18));
            _libssh2_store_u32((_DWORD **)&v110, *((_DWORD *)v25 + 20));
            *(_DWORD *)(v5 + 192) = 2;
LABEL_54:
            uint64_t v30 = _libssh2_transport_send(a1, (void *)(a1 + 72812), 0x11uLL);
            uint64_t v18 = v30;
            if (v30 == -37)
            {
LABEL_237:
              if (v18 == -37) {
                return v18;
              }
              goto LABEL_238;
            }
            if (v30)
            {
              *(_DWORD *)(v5 + 192) = 0;
LABEL_175:
              size_t v79 = "Unable to send channel open confirmation";
              uint64_t v80 = a1;
              uint64_t v81 = 4294967289;
LABEL_236:
              uint64_t v18 = _libssh2_error(v80, v81, v79);
              goto LABEL_237;
            }
            _libssh2_list_add((void **)(a1 + 552), v25);
            *uint64_t v7 = 0;
            *(_DWORD *)(v5 + 256) = 0;
            (*(void (**)(void, void *, void))(v25[13] + 72))(v25[13], v25, v25[13]);
            goto LABEL_102;
          }
          _libssh2_error(a1, 4294967290, "allocate a channel for new connection");
          (*(void (**)(void *, uint64_t))(a1 + 24))(v25, a1);
        }
        else
        {
          _libssh2_error(a1, 4294967290, "allocate a channel for new connection");
        }
LABEL_99:
        unsigned int v31 = 4;
      }
      else
      {
        unsigned int v31 = 2;
      }
      size_t v110 = (unsigned __int8 *)(a1 + 72813);
      *(unsigned char *)(v5 + 196) = 92;
      _libssh2_store_u32((_DWORD **)&v110, *(_DWORD *)(v5 + 236));
      _libssh2_store_u32((_DWORD **)&v110, v31);
      _libssh2_store_str((_DWORD **)&v110, "Auth Agent unavailable", 0x16uLL);
      _libssh2_htonu32(v110, 0);
      uint64_t v59 = _libssh2_transport_send(a1, (void *)(v5 + 196), 0x28uLL);
      uint64_t v18 = v59;
      if (v59 == -37) {
        goto LABEL_237;
      }
      if (v59)
      {
        *(_DWORD *)(v5 + 192) = 0;
LABEL_234:
        size_t v79 = "Unable to send open failure";
LABEL_235:
        uint64_t v80 = a1;
        uint64_t v81 = v18;
        goto LABEL_236;
      }
LABEL_102:
      *(_DWORD *)(v5 + 192) = 0;
      goto LABEL_237;
    default:
      goto LABEL_113;
  }
}

uint64_t _libssh2_packet_ask(uint64_t a1, int a2, void *a3, unint64_t *a4, int a5, const void *a6, size_t a7)
{
  uint64_t v14 = _libssh2_list_first(a1 + 536);
  if (!v14) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v15 = (uint64_t *)v14;
  unsigned __int8 v21 = a4;
  uint64_t v16 = a5;
  size_t v17 = a7 + a5;
  while (1)
  {
    uint64_t v18 = (unsigned __int8 *)v15[3];
    if (*v18 == a2)
    {
      unint64_t v19 = v15[4];
      if (v19 >= v17 && (!a6 || !memcmp(&v18[v16], a6, a7))) {
        break;
      }
    }
    uint64_t v15 = (uint64_t *)_libssh2_list_next((uint64_t)v15);
    if (!v15) {
      return 0xFFFFFFFFLL;
    }
  }
  *a3 = v18;
  *unsigned __int8 v21 = v19;
  _libssh2_list_remove(v15);
  (*(void (**)(uint64_t *, uint64_t))(a1 + 24))(v15, a1);
  return 0;
}

uint64_t _libssh2_packet_askv(uint64_t a1, char *__s, void *a3, unint64_t *a4, int a5, const void *a6, size_t a7)
{
  unint64_t v12 = __s;
  size_t v14 = strlen(__s);
  if (!v14) {
    return 0xFFFFFFFFLL;
  }
  size_t v15 = v14;
  while (1)
  {
    int v16 = *v12++;
    uint64_t result = _libssh2_packet_ask(a1, v16, a3, a4, a5, a6, a7);
    if (!result) {
      break;
    }
    if (!--v15) {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t _libssh2_packet_require(uint64_t a1, int a2, void *a3, unint64_t *a4, int a5, const void *a6, size_t a7, uint64_t a8)
{
  if (*(void *)(a8 + 8))
  {
    while (1)
    {
LABEL_4:
      if (*(_DWORD *)(a1 + 596)) {
        return 4294967283;
      }
      uint64_t result = _libssh2_transport_read(a1);
      if (result == -37) {
        return result;
      }
      if ((result & 0x80000000) != 0) {
        break;
      }
      if (result == a2)
      {
        uint64_t result = _libssh2_packet_ask(a1, a2, a3, a4, a5, a6, a7);
        break;
      }
      if (!result)
      {
        uint64_t v17 = *(void *)(a1 + 73576);
        if (v17 - time(0) + *(void *)(a8 + 8) > 0) {
          return 0xFFFFFFFFLL;
        }
        uint64_t result = 4294967287;
        break;
      }
    }
    *(void *)(a8 + 8) = 0;
  }
  else
  {
    uint64_t result = _libssh2_packet_ask(a1, a2, a3, a4, a5, a6, a7);
    if (result)
    {
      *(void *)(a8 + 8) = time(0);
      goto LABEL_4;
    }
  }
  return result;
}

uint64_t _libssh2_packet_burn(uint64_t a1, _DWORD *a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  int v9 = 0;
  if (*a2)
  {
LABEL_6:
    while (!*(_DWORD *)(a1 + 596))
    {
      uint64_t v5 = _libssh2_transport_read(a1);
      uint64_t v6 = v5;
      if (v5 == -37) {
        return v6;
      }
      if ((v5 & 0x80000000) != 0) {
        goto LABEL_12;
      }
      if (v5 && !_libssh2_packet_ask(a1, v5, &v9, &v8, 0, 0, 0))
      {
        (*(void (**)(unsigned __int8 *, uint64_t))(a1 + 24))(v9, a1);
LABEL_12:
        *a2 = 0;
        return v6;
      }
    }
    return 4294967283;
  }
  else
  {
    for (uint64_t i = 0; i != 254; ++i)
      __s[i] = i + 1;
    __s[254] = 0;
    if (_libssh2_packet_askv(a1, __s, &v9, &v8, 0, 0, 0))
    {
      *a2 = 2;
      goto LABEL_6;
    }
    uint64_t v6 = *v9;
    (*(void (**)(void))(a1 + 24))();
  }
  return v6;
}

uint64_t _libssh2_packet_requirev(uint64_t a1, char *a2, void *a3, unint64_t *a4, int a5, const void *a6, size_t a7, time_t *a8)
{
  if (_libssh2_packet_askv(a1, a2, a3, a4, a5, a6, a7))
  {
    size_t v20 = a7;
    if (!*a8) {
      *a8 = time(0);
    }
    while (1)
    {
      if (*(_DWORD *)(a1 + 596) == -1)
      {
        uint64_t v17 = 4294967283;
        goto LABEL_15;
      }
      uint64_t v16 = _libssh2_transport_read(a1);
      uint64_t v17 = v16;
      if ((v16 & 0x80000000) != 0 && v16 != -37) {
        goto LABEL_15;
      }
      if ((int)v16 <= 0)
      {
        uint64_t v18 = *(void *)(a1 + 73576);
        if (v18 - time(0) + *a8 < 1)
        {
          uint64_t v17 = 4294967287;
          goto LABEL_15;
        }
        if (v17 == -37) {
          return v17;
        }
      }
      if (strchr(a2, v17))
      {
        uint64_t v17 = _libssh2_packet_askv(a1, a2, a3, a4, a5, a6, v20);
        goto LABEL_15;
      }
    }
  }
  uint64_t v17 = 0;
LABEL_15:
  *a8 = 0;
  return v17;
}

uint64_t _libssh2_channel_nextid(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 568);
  for (uint64_t i = _libssh2_list_first(a1 + 552); i; uint64_t i = _libssh2_list_next(i))
  {
    unsigned int v4 = *(_DWORD *)(i + 48);
    if (v4 <= v2) {
      uint64_t v2 = v2;
    }
    else {
      uint64_t v2 = v4;
    }
  }
  *(_DWORD *)(a1 + 568) = v2 + 1;
  return v2;
}

uint64_t _libssh2_channel_locate(uint64_t a1, int a2)
{
  uint64_t result = _libssh2_list_first(a1 + 552);
  if (result)
  {
    while (*(_DWORD *)(result + 48) != a2)
    {
      uint64_t result = _libssh2_list_next(result);
      if (!result) {
        goto LABEL_4;
      }
    }
  }
  else
  {
LABEL_4:
    uint64_t result = _libssh2_list_first(a1 + 576);
    if (result)
    {
      uint64_t v5 = result;
      while (1)
      {
        uint64_t result = _libssh2_list_first(v5 + 48);
        if (result) {
          break;
        }
LABEL_9:
        uint64_t result = _libssh2_list_next(v5);
        uint64_t v5 = result;
        if (!result) {
          return result;
        }
      }
      while (*(_DWORD *)(result + 48) != a2)
      {
        uint64_t result = _libssh2_list_next(result);
        if (!result) {
          goto LABEL_9;
        }
      }
    }
  }
  return result;
}

uint64_t _libssh2_channel_open(uint64_t a1, const void *a2, unsigned int a3, unsigned int a4, unsigned int a5, const void *a6, size_t a7)
{
  uint64_t v9 = a1 + 72400;
  unint64_t v40 = 0;
  int v10 = *(_DWORD *)(a1 + 72400);
  if (v10 != 3)
  {
    if (v10 != 2)
    {
      if (v10) {
        goto LABEL_25;
      }
      *(void *)(a1 + 72416) = 0;
      uint64_t v16 = (void *)(a1 + 72416);
      *(void *)(a1 + 72424) = 0;
      *(void *)(a1 + 72432) = a3 + 17;
      *(void *)(a1 + 72440) = 0;
      *(_DWORD *)(a1 + 72456) = _libssh2_channel_nextid(a1);
      *(void *)(v9 + 8) = 0;
      uint64_t v17 = _libssh2_calloc(a1, 0x310uLL);
      *uint64_t v16 = v17;
      if (!v17)
      {
        BOOL v23 = "Unable to allocate space for channel data";
        uint64_t v27 = a1;
        uint64_t v22 = 4294967290;
        goto LABEL_37;
      }
      v17[8] = a3;
      uint64_t v18 = (void *)(*(uint64_t (**)(void, uint64_t))(a1 + 8))(a3, a1);
      *(void *)(*v16 + 24) = v18;
      if (!v18)
      {
        _libssh2_error(a1, 4294967290, "Failed allocating memory for channel type name");
        (*(void (**)(void, uint64_t))(a1 + 24))(*v16, a1);
        uint64_t result = 0;
        *uint64_t v16 = 0;
        return result;
      }
      memcpy(v18, a2, a3);
      uint64_t v19 = *(void *)(v9 + 16);
      *(_DWORD *)(v19 + 48) = *(_DWORD *)(v9 + 56);
      *(_DWORD *)(v19 + 72) = a4;
      *(_DWORD *)(v19 + 76) = a4;
      *(_DWORD *)(v19 + 80) = a5;
      *(void *)(v19 + 104) = a1;
      _libssh2_list_add((void **)(a1 + 552), (void *)v19);
      size_t v20 = (_DWORD *)(*(uint64_t (**)(void, uint64_t))(a1 + 8))(*(void *)(v9 + 32), a1);
      *(void *)(v9 + 24) = v20;
      unint64_t v40 = v20;
      if (!v20)
      {
        uint64_t v30 = "Unable to allocate temporary space for packet";
        uint64_t v31 = a1;
        uint64_t v22 = 4294967290;
        goto LABEL_24;
      }
      unint64_t v40 = (_DWORD *)((char *)v20 + 1);
      *(unsigned char *)size_t v20 = 90;
      _libssh2_store_str(&v40, a2, a3);
      _libssh2_store_u32(&v40, *(_DWORD *)(v9 + 56));
      _libssh2_store_u32(&v40, a4);
      _libssh2_store_u32(&v40, a5);
      *(_DWORD *)uint64_t v9 = 2;
    }
    uint64_t v21 = _libssh2_transport_send(a1, *(void **)(v9 + 24), *(void *)(v9 + 32), a6, a7);
    if (v21)
    {
      uint64_t v22 = v21;
      if (v21 == -37)
      {
        BOOL v23 = "Would block sending channel-open request";
LABEL_15:
        uint64_t v27 = a1;
LABEL_37:
        _libssh2_error(v27, v22, v23);
        return 0;
      }
      uint64_t v30 = "Unable to send channel-open request";
LABEL_23:
      uint64_t v31 = a1;
      goto LABEL_24;
    }
    *(_DWORD *)uint64_t v9 = 3;
  }
  int v24 = (unsigned __int8 **)(v9 + 40);
  size_t v25 = (void *)(v9 + 48);
  uint64_t v26 = _libssh2_packet_requirev(a1, "[\\"", (void *)(v9 + 40), (unint64_t *)(v9 + 48), 1, (const void *)(*(void *)(v9 + 24) + a3 + 5), 4uLL, (time_t *)(a1 + 72408));
  if (v26)
  {
    uint64_t v22 = v26;
    if (v26 == -37)
    {
      BOOL v23 = "Would block";
      goto LABEL_15;
    }
    uint64_t v30 = "Unexpected error";
    goto LABEL_23;
  }
  if (!*v25)
  {
LABEL_20:
    uint64_t v30 = "Unexpected packet size";
    uint64_t v31 = a1;
    uint64_t v22 = 4294967282;
LABEL_24:
    _libssh2_error(v31, v22, v30);
    goto LABEL_25;
  }
  uint64_t v28 = (uint64_t)*v24;
  int v29 = **v24;
  if (v29 == 92)
  {
    switch(_libssh2_ntohu32((unsigned int *)(v28 + 5)))
    {
      case 1u:
        uint64_t v30 = "Channel open failure (administratively prohibited)";
        break;
      case 2u:
        uint64_t v30 = "Channel open failure (connect failed)";
        break;
      case 3u:
        uint64_t v30 = "Channel open failure (unknown channel type)";
        break;
      case 4u:
        uint64_t v30 = "Channel open failure (resource shortage)";
        break;
      default:
        uint64_t v30 = "Channel open failure";
        break;
    }
    uint64_t v31 = a1;
    uint64_t v22 = 4294967275;
    goto LABEL_24;
  }
  if (v29 == 91)
  {
    if (*v25 > 0x10uLL)
    {
      *(_DWORD *)(*(void *)(v9 + 16) + 68) = _libssh2_ntohu32((unsigned int *)(v28 + 5));
      *(_DWORD *)(*(void *)(v9 + 16) + 56) = _libssh2_ntohu32((unsigned int *)(*(void *)(v9 + 40) + 9));
      *(_DWORD *)(*(void *)(v9 + 16) + 52) = _libssh2_ntohu32((unsigned int *)(*(void *)(v9 + 40) + 9));
      int v37 = _libssh2_ntohu32((unsigned int *)(*(void *)(v9 + 40) + 13));
      uint64_t v38 = *(void *)(v9 + 24);
      *(_DWORD *)(*(void *)(v9 + 16) + 60) = v37;
      (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v38, a1);
      *(void *)(v9 + 24) = 0;
      (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v9 + 40), a1);
      *(void *)(v9 + 40) = 0;
      *(_DWORD *)uint64_t v9 = 0;
      return *(void *)(v9 + 16);
    }
    goto LABEL_20;
  }
LABEL_25:
  int v33 = (void *)(v9 + 40);
  uint64_t v32 = *(void *)(v9 + 40);
  if (v32)
  {
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v32, a1);
    *int v33 = 0;
  }
  uint64_t v34 = *(void *)(v9 + 24);
  if (v34)
  {
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v34, a1);
    *(void *)(v9 + 24) = 0;
  }
  uint64_t v35 = *(void *)(v9 + 16);
  if (v35)
  {
    (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v35 + 24), a1);
    _libssh2_list_remove(*(uint64_t **)(v9 + 16));
    _libssh2_htonu32(&v39, *(_DWORD *)(*(void *)(v9 + 16) + 48));
    while ((_libssh2_packet_ask(a1, 94, (void *)(v9 + 40), (unint64_t *)(a1 + 72448), 1, &v39, 4uLL) & 0x80000000) == 0
         || (_libssh2_packet_ask(a1, 95, (void *)(v9 + 40), (unint64_t *)(a1 + 72448), 1, &v39, 4uLL) & 0x80000000) == 0)
    {
      (*(void (**)(void, uint64_t))(a1 + 24))(*v33, a1);
      *int v33 = 0;
    }
    (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v9 + 16), a1);
    *(void *)(v9 + 16) = 0;
  }
  uint64_t result = 0;
  *(_DWORD *)uint64_t v9 = 0;
  return result;
}

uint64_t libssh2_channel_open_ex(uint64_t result, const void *a2, unsigned int a3, unsigned int a4, unsigned int a5, const void *a6, unsigned int a7)
{
  if (result)
  {
    uint64_t v13 = result;
    time_t v14 = time(0);
    while (1)
    {
      uint64_t result = _libssh2_channel_open(v13, a2, a3, a4, a5, a6, a7);
      if (!*(_DWORD *)(v13 + 172) || result != 0) {
        break;
      }
      if (libssh2_session_last_errno(v13) != -37 || _libssh2_wait_socket(v13, v14)) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t libssh2_channel_direct_tcpip_ex(uint64_t a1, const char *a2, unsigned int a3, const char *a4, unsigned int a5)
{
  if (a1)
  {
    uint64_t v10 = a1 + 72460;
    time_t v11 = time(0);
    do
    {
      uint64_t v18 = 0;
      if (!*(_DWORD *)v10)
      {
        size_t v12 = strlen(a2);
        *(void *)(v10 + 12) = v12;
        size_t v13 = strlen(a4);
        *(void *)(v10 + 20) = v13;
        *(void *)(v10 + 28) = v12 + v13 + 16;
        time_t v14 = (_DWORD *)(*(uint64_t (**)(void))(a1 + 8))();
        *(void *)(v10 + 4) = v14;
        uint64_t v18 = v14;
        if (!v14)
        {
          _libssh2_error(a1, 4294967290, "Unable to allocate memory for direct-tcpip connection");
          uint64_t v15 = 0;
          goto LABEL_10;
        }
        _libssh2_store_str(&v18, a2, *(void *)(v10 + 12));
        _libssh2_store_u32(&v18, a3);
        _libssh2_store_str(&v18, a4, *(void *)(v10 + 20));
        _libssh2_store_u32(&v18, a5);
      }
      uint64_t v15 = _libssh2_channel_open(a1, "direct-tcpip", 0xCu, 0x200000u, 0x8000u, *(const void **)(v10 + 4), *(void *)(v10 + 28));
      if (v15 || libssh2_session_last_errno(a1) != -37)
      {
        *(_DWORD *)uint64_t v10 = 0;
        (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v10 + 4), a1);
        *(void *)(v10 + 4) = 0;
      }
      else
      {
        uint64_t v15 = 0;
        *(_DWORD *)uint64_t v10 = 2;
      }
LABEL_10:
      if (v15) {
        BOOL v16 = 1;
      }
      else {
        BOOL v16 = *(_DWORD *)(a1 + 172) == 0;
      }
      if (v16) {
        return v15;
      }
    }
    while (libssh2_session_last_errno(a1) == -37 && !_libssh2_wait_socket(a1, v11));
  }
  return 0;
}

uint64_t libssh2_channel_direct_streamlocal_ex(uint64_t a1, const char *a2, const char *a3, unsigned int a4)
{
  if (a1)
  {
    uint64_t v8 = a1 + 72460;
    time_t v9 = time(0);
    do
    {
      BOOL v16 = 0;
      if (!*(_DWORD *)v8)
      {
        size_t v10 = strlen(a2);
        *(void *)(v8 + 12) = v10;
        size_t v11 = strlen(a3);
        *(void *)(v8 + 20) = v11;
        *(void *)(v8 + 28) = v10 + v11 + 12;
        size_t v12 = (_DWORD *)(*(uint64_t (**)(void))(a1 + 8))();
        *(void *)(v8 + 4) = v12;
        BOOL v16 = v12;
        if (!v12)
        {
          _libssh2_error(a1, 4294967290, "Unable to allocate memory for direct-streamlocal connection");
          uint64_t v13 = 0;
          goto LABEL_10;
        }
        _libssh2_store_str(&v16, a2, *(void *)(v8 + 12));
        _libssh2_store_str(&v16, a3, *(void *)(v8 + 20));
        _libssh2_store_u32(&v16, a4);
      }
      uint64_t v13 = _libssh2_channel_open(a1, "direct-streamlocal@openssh.com", 0x1Eu, 0x200000u, 0x8000u, *(const void **)(v8 + 4), *(void *)(v8 + 28));
      if (v13 || libssh2_session_last_errno(a1) != -37)
      {
        *(_DWORD *)uint64_t v8 = 0;
        (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v8 + 4), a1);
        *(void *)(v8 + 4) = 0;
      }
      else
      {
        uint64_t v13 = 0;
        *(_DWORD *)uint64_t v8 = 2;
      }
LABEL_10:
      if (v13) {
        BOOL v14 = 1;
      }
      else {
        BOOL v14 = *(_DWORD *)(a1 + 172) == 0;
      }
      if (v14) {
        return v13;
      }
    }
    while (libssh2_session_last_errno(a1) == -37 && !_libssh2_wait_socket(a1, v9));
  }
  return 0;
}

void *libssh2_channel_forward_listen_ex(uint64_t a1, const char *a2, unsigned int a3, _DWORD *a4, int a5)
{
  if (a1)
  {
    uint64_t v10 = a1 + 72496;
    time_t v11 = time(0);
    if (!a2) {
      a2 = "0.0.0.0";
    }
    do
    {
      uint64_t v31 = 0;
      int v12 = *(_DWORD *)v10;
      if (*(_DWORD *)v10 != 3)
      {
        if (v12 != 2)
        {
          if (v12) {
            goto LABEL_32;
          }
          int v13 = strlen(a2);
          *(_DWORD *)(v10 + 16) = v13;
          *(_DWORD *)(v10 + 20) = v13 + 27;
          *(void *)(v10 + 24) = 0;
          uint64_t v14 = (*(uint64_t (**)(void, uint64_t))(a1 + 8))((v13 + 27), a1);
          *(void *)(v10 + 8) = v14;
          if (!v14)
          {
            uint64_t v17 = a1;
            uint64_t v18 = 4294967290;
            uint64_t v19 = "Unable to allocate memory for setenv packet";
            goto LABEL_29;
          }
          uint64_t v31 = (_DWORD *)(v14 + 1);
          *(unsigned char *)uint64_t v14 = 80;
          _libssh2_store_str(&v31, "tcpip-forward", 0xDuLL);
          uint64_t v15 = v31;
          uint64_t v31 = (_DWORD *)((char *)v31 + 1);
          *uint64_t v15 = 1;
          _libssh2_store_str(&v31, a2, *(unsigned int *)(v10 + 16));
          _libssh2_store_u32(&v31, a3);
          *(_DWORD *)uint64_t v10 = 2;
        }
        int v16 = _libssh2_transport_send(a1, *(void **)(v10 + 8), *(unsigned int *)(v10 + 20), 0, 0);
        if (v16)
        {
          if (v16 != -37)
          {
            _libssh2_error(a1, 4294967289, "Unable to send global-request packet for forward listen request");
            (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v10 + 8), a1);
            uint64_t v22 = 0;
            *(void *)(v10 + 8) = 0;
            goto LABEL_33;
          }
          uint64_t v17 = a1;
          uint64_t v18 = 4294967259;
          uint64_t v19 = "Would block sending global-request packet for forward listen request";
          goto LABEL_29;
        }
        (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v10 + 8), a1);
        *(void *)(v10 + 8) = 0;
        *(_DWORD *)uint64_t v10 = 3;
      }
      unint64_t v29 = 0;
      uint64_t v30 = 0;
      int v20 = _libssh2_packet_requirev(a1, "QR", &v30, &v29, 0, 0, 0, (time_t *)(v10 + 24));
      if (v20 != -37)
      {
        if (v20 || !v29)
        {
          uint64_t v25 = a1;
          uint64_t v26 = 4294967282;
          uint64_t v27 = "Unknown";
        }
        else
        {
          int v21 = *v30;
          if (v21 != 82)
          {
            if (v21 == 81)
            {
              uint64_t v22 = _libssh2_calloc(a1, 0x60uLL);
              if (v22)
              {
                BOOL v23 = (void *)(*(uint64_t (**)(void, uint64_t))(a1 + 8))((*(_DWORD *)(v10 + 16) + 1), a1);
                v22[4] = v23;
                if (v23)
                {
                  v22[3] = a1;
                  memcpy(v23, a2, *(unsigned int *)(v10 + 16));
                  *(unsigned char *)(v22[4] + *(unsigned int *)(v10 + 16)) = 0;
                  int v24 = a3;
                  if (!a3)
                  {
                    int v24 = 0;
                    if (v29 >= 5) {
                      int v24 = _libssh2_ntohu32((unsigned int *)(v30 + 1));
                    }
                  }
                  *((_DWORD *)v22 + 10) = v24;
                  *((_DWORD *)v22 + 16) = 0;
                  *((_DWORD *)v22 + 17) = a5;
                  _libssh2_list_add((void **)(a1 + 576), v22);
                  if (a4) {
                    *a4 = *((_DWORD *)v22 + 10);
                  }
                }
                else
                {
                  _libssh2_error(a1, 4294967290, "Unable to allocate memory for listener queue");
                  (*(void (**)(void *, uint64_t))(a1 + 24))(v22, a1);
                  uint64_t v22 = 0;
                }
              }
              else
              {
                _libssh2_error(a1, 4294967290, "Unable to allocate memory for listener queue");
              }
              (*(void (**)(unsigned __int8 *, uint64_t))(a1 + 24))(v30, a1);
LABEL_33:
              *(_DWORD *)uint64_t v10 = 0;
              if (v22) {
                return v22;
              }
              goto LABEL_34;
            }
LABEL_32:
            uint64_t v22 = 0;
            goto LABEL_33;
          }
          (*(void (**)(void))(a1 + 24))();
          uint64_t v25 = a1;
          uint64_t v26 = 4294967264;
          uint64_t v27 = "Unable to complete request for forward-listen";
        }
        _libssh2_error(v25, v26, v27);
        goto LABEL_32;
      }
      uint64_t v17 = a1;
      uint64_t v18 = 4294967259;
      uint64_t v19 = "Would block";
LABEL_29:
      _libssh2_error(v17, v18, v19);
      uint64_t v22 = 0;
LABEL_34:
      if (!*(_DWORD *)(a1 + 172)) {
        return v22;
      }
    }
    while (libssh2_session_last_errno(a1) == -37 && !_libssh2_wait_socket(a1, v11));
  }
  return 0;
}

uint64_t _libssh2_channel_forward_cancel(uint64_t a1)
{
  int v16 = 0;
  uint64_t v2 = *(void *)(a1 + 24);
  size_t v3 = strlen(*(const char **)(a1 + 32));
  size_t v4 = v3 + 34;
  int v5 = *(_DWORD *)(a1 + 72);
  if (v5)
  {
    if (v5 != 2)
    {
      uint64_t v11 = 0;
      goto LABEL_12;
    }
    uint64_t v6 = *(void **)(a1 + 80);
  }
  else
  {
    unint64_t v7 = v3;
    uint64_t v8 = (*(uint64_t (**)(size_t, uint64_t))(v2 + 8))(v3 + 34, v2);
    if (!v8)
    {
      uint64_t v11 = 4294967290;
      _libssh2_error(v2, 4294967290, "Unable to allocate memory for setenv packet");
      return v11;
    }
    uint64_t v6 = (void *)v8;
    int v16 = (_DWORD *)(v8 + 1);
    *(unsigned char *)uint64_t v8 = 80;
    _libssh2_store_str(&v16, "cancel-tcpip-forward", 0x14uLL);
    time_t v9 = v16;
    int v16 = (_DWORD *)((char *)v16 + 1);
    *time_t v9 = 0;
    _libssh2_store_str(&v16, *(const void **)(a1 + 32), v7);
    _libssh2_store_u32(&v16, *(_DWORD *)(a1 + 40));
    *(_DWORD *)(a1 + 72) = 2;
  }
  uint64_t v10 = _libssh2_transport_send(v2, v6, v4, 0, 0);
  uint64_t v11 = v10;
  if (v10)
  {
    if (v10 == -37)
    {
      _libssh2_error(v2, 4294967259, "Would block sending forward request");
      *(void *)(a1 + 80) = v6;
      return v11;
    }
    uint64_t v11 = 4294967289;
    _libssh2_error(v2, 4294967289, "Unable to send global-request packet for forward listen request");
    *(_DWORD *)(a1 + 72) = 3;
  }
  (*(void (**)(void *, uint64_t))(v2 + 24))(v6, v2);
  *(_DWORD *)(a1 + 72) = 3;
LABEL_12:
  uint64_t v12 = _libssh2_list_first(a1 + 48);
  while (v12)
  {
    uint64_t v13 = _libssh2_list_next(v12);
    int v14 = _libssh2_channel_free(v12);
    uint64_t v12 = v13;
    if (v14 == -37) {
      return 4294967259;
    }
  }
  (*(void (**)(void, uint64_t))(v2 + 24))(*(void *)(a1 + 32), v2);
  _libssh2_list_remove((uint64_t *)a1);
  (*(void (**)(uint64_t, uint64_t))(v2 + 24))(a1, v2);
  return v11;
}

uint64_t _libssh2_channel_free(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 104);
  if (!v1) {
    _libssh2_channel_free_cold_1();
  }
  if (!*(_DWORD *)(a1 + 684)) {
    *(_DWORD *)(a1 + 684) = 2;
  }
  if (*(unsigned char *)(a1 + 64) || *(_DWORD *)(v1 + 596) || (uint64_t result = _libssh2_channel_close(a1), result != -37))
  {
    *(_DWORD *)(a1 + 684) = 0;
    uint64_t v4 = *(void *)(a1 + 40);
    if (v4) {
      (*(void (**)(uint64_t, uint64_t))(v1 + 24))(v4, v1);
    }
    unint64_t v9 = 0;
    uint64_t v10 = 0;
    _libssh2_htonu32(&v11, *(_DWORD *)(a1 + 48));
    while ((_libssh2_packet_ask(v1, 94, &v10, &v9, 1, &v11, 4uLL) & 0x80000000) == 0
         || (_libssh2_packet_ask(v1, 95, &v10, &v9, 1, &v11, 4uLL) & 0x80000000) == 0)
      (*(void (**)(uint64_t, uint64_t))(v1 + 24))(v10, v1);
    uint64_t v5 = *(void *)(a1 + 24);
    if (v5) {
      (*(void (**)(uint64_t, uint64_t))(v1 + 24))(v5, v1);
    }
    _libssh2_list_remove((uint64_t *)a1);
    uint64_t v6 = *(void *)(a1 + 136);
    if (v6) {
      (*(void (**)(uint64_t, uint64_t))(v1 + 24))(v6, v1);
    }
    uint64_t v7 = *(void *)(a1 + 504);
    if (v7) {
      (*(void (**)(uint64_t, uint64_t))(v1 + 24))(v7, v1);
    }
    uint64_t v8 = *(void *)(a1 + 544);
    if (v8) {
      (*(void (**)(uint64_t, uint64_t))(v1 + 24))(v8, v1);
    }
    (*(void (**)(uint64_t, uint64_t))(v1 + 24))(a1, v1);
    return 0;
  }
  return result;
}

uint64_t libssh2_channel_forward_cancel(uint64_t a1)
{
  if (!a1) {
    return 4294967257;
  }
  time_t v2 = time(0);
  do
  {
    uint64_t result = _libssh2_channel_forward_cancel(a1);
    if (result != -37) {
      break;
    }
    uint64_t v4 = *(void *)(a1 + 24);
    if (!*(_DWORD *)(v4 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(v4, v2);
  }
  while (!result);
  return result;
}

uint64_t *libssh2_channel_forward_accept(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  time_t v2 = time(0);
  while (1)
  {
    do
      int v3 = _libssh2_transport_read(*(void *)(a1 + 24));
    while (v3 > 0);
    int v4 = v3;
    if (_libssh2_list_first(a1 + 48)) {
      break;
    }
    if (v4 == -37)
    {
      uint64_t v5 = 4294967259;
      uint64_t v6 = "Would block waiting for packet";
    }
    else
    {
      uint64_t v5 = 4294967273;
      uint64_t v6 = "Channel not found";
    }
    _libssh2_error(*(void *)(a1 + 24), v5, v6);
    uint64_t v7 = *(void *)(a1 + 24);
    if (!*(_DWORD *)(v7 + 172)
      || libssh2_session_last_errno(v7) != -37
      || _libssh2_wait_socket(*(void *)(a1 + 24), v2))
    {
      return 0;
    }
  }
  uint64_t v8 = (uint64_t *)_libssh2_list_first(a1 + 48);
  _libssh2_list_remove(v8);
  --*(_DWORD *)(a1 + 64);
  _libssh2_list_add((void **)(v8[13] + 552), v8);
  return v8;
}

uint64_t libssh2_channel_setenv_ex(uint64_t a1, const void *a2, int a3, const void *a4, int a5)
{
  if (!a1) {
    return 4294967257;
  }
  LODWORD(v12) = a5;
  LODWORD(v11) = a3;
  time_t v8 = time(0);
  uint64_t v9 = (v11 + v12 + 21);
  uint64_t v10 = (time_t *)(a1 + 160);
  unint64_t v11 = v11;
  unint64_t v12 = v12;
  uint64_t v13 = (_DWORD *)(a1 + 152);
  while (1)
  {
    uint64_t v14 = *(void *)(a1 + 104);
    int v36 = 0;
    int v37 = 0;
    unint64_t v35 = 0;
    int v15 = *(_DWORD *)(a1 + 128);
    if (v15 != 3)
    {
      if (v15 != 2)
      {
        if (v15) {
          goto LABEL_16;
        }
        *(void *)(a1 + 144) = v9;
        *(void *)(a1 + 160) = 0;
        uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t))(v14 + 8))(v9, v14);
        *(void *)(a1 + 136) = v16;
        if (!v16)
        {
          uint64_t v30 = v14;
          uint64_t v20 = 4294967290;
          uint64_t v31 = "Unable to allocate memory for setenv packet";
          goto LABEL_21;
        }
        int v37 = (_DWORD *)(v16 + 1);
        *(unsigned char *)uint64_t v16 = 98;
        _libssh2_store_u32(&v37, *(_DWORD *)(a1 + 68));
        _libssh2_store_str(&v37, "env", 3uLL);
        uint64_t v17 = v37;
        int v37 = (_DWORD *)((char *)v37 + 1);
        *uint64_t v17 = 1;
        _libssh2_store_str(&v37, a2, v11);
        _libssh2_store_str(&v37, a4, v12);
        *(_DWORD *)(a1 + 128) = 2;
      }
      int v18 = _libssh2_transport_send(v14, *(void **)(a1 + 136), *(void *)(a1 + 144), 0, 0);
      if (v18)
      {
        if (v18 == -37)
        {
          _libssh2_error(v14, 4294967259, "Would block sending setenv request");
          goto LABEL_22;
        }
        (*(void (**)(void, uint64_t))(v14 + 24))(*(void *)(a1 + 136), v14);
        *(void *)(a1 + 136) = 0;
        *(_DWORD *)(a1 + 128) = 0;
        uint64_t v30 = v14;
        uint64_t v20 = 4294967289;
        uint64_t v31 = "Unable to send channel-request packet for setenv request";
        goto LABEL_21;
      }
      (*(void (**)(void, uint64_t))(v14 + 24))(*(void *)(a1 + 136), v14);
      *(void *)(a1 + 136) = 0;
      _libssh2_htonu32(v13, *(_DWORD *)(a1 + 48));
      *(_DWORD *)(a1 + 128) = 3;
    }
    uint64_t v19 = _libssh2_packet_requirev(v14, "cd", &v36, &v35, 1, v13, 4uLL, v10);
    if (v19 == -37) {
      goto LABEL_22;
    }
    uint64_t v20 = v19;
    if (v19)
    {
      *(_DWORD *)(a1 + 128) = 0;
      uint64_t v30 = v14;
      uint64_t v31 = "Failed getting response for channel-setenv";
      goto LABEL_21;
    }
    if (v35) {
      break;
    }
    *(_DWORD *)(a1 + 128) = 0;
    uint64_t v30 = v14;
    uint64_t v20 = 4294967282;
    uint64_t v31 = "Unexpected packet size";
LABEL_21:
    uint64_t result = _libssh2_error(v30, v20, v31);
    if (result != -37) {
      return result;
    }
LABEL_22:
    uint64_t v33 = *(void *)(a1 + 104);
    if (!*(_DWORD *)(v33 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(v33, v8);
    if (result) {
      return result;
    }
  }
  time_t v34 = v8;
  int v21 = v13;
  uint64_t v22 = v9;
  BOOL v23 = v10;
  int v24 = a2;
  uint64_t v25 = a4;
  unint64_t v26 = v12;
  unint64_t v27 = v11;
  int v28 = *v36;
  (*(void (**)(void))(v14 + 24))();
  BOOL v29 = v28 == 99;
  unint64_t v11 = v27;
  unint64_t v12 = v26;
  a4 = v25;
  a2 = v24;
  uint64_t v10 = v23;
  uint64_t v9 = v22;
  uint64_t v13 = v21;
  time_t v8 = v34;
  if (!v29)
  {
LABEL_16:
    *(_DWORD *)(a1 + 128) = 0;
    uint64_t v30 = v14;
    uint64_t v20 = 4294967274;
    uint64_t v31 = "Unable to complete request for channel-setenv";
    goto LABEL_21;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 128) = 0;
  return result;
}

uint64_t libssh2_channel_request_auth_agent(uint64_t a1)
{
  if (!a1) {
    return 4294967257;
  }
  int v2 = *(_DWORD *)(a1 + 692);
  if (v2)
  {
    uint64_t result = 4294967273;
  }
  else
  {
    time_t v4 = time(0);
    do
    {
      uint64_t result = channel_request_auth_agent(a1, "auth-agent-req@openssh.com", 0x1Au);
      if (result != -37) {
        break;
      }
      uint64_t v5 = *(void *)(a1 + 104);
      if (!*(_DWORD *)(v5 + 172))
      {
        uint64_t result = 4294967259;
        goto LABEL_15;
      }
      uint64_t result = _libssh2_wait_socket(v5, v4);
    }
    while (!result);
    if (result != -37 && result != 0)
    {
      *(_DWORD *)(a1 + 692) = 3;
      goto LABEL_17;
    }
LABEL_15:
    int v2 = *(_DWORD *)(a1 + 692);
  }
  if (v2 == 3)
  {
LABEL_17:
    time_t v7 = time(0);
    do
    {
      uint64_t result = channel_request_auth_agent(a1, "auth-agent-req", 0xEu);
      if (result != -37) {
        break;
      }
      uint64_t v8 = *(void *)(a1 + 104);
      if (!*(_DWORD *)(v8 + 172)) {
        return 4294967259;
      }
      uint64_t result = _libssh2_wait_socket(v8, v7);
    }
    while (!result);
    if (result && result != -37)
    {
      int v9 = 4;
      goto LABEL_27;
    }
  }
  if (result) {
    return result;
  }
  int v9 = 0;
LABEL_27:
  *(_DWORD *)(a1 + 692) = v9;
  return result;
}

uint64_t channel_request_auth_agent(uint64_t a1, const void *a2, unsigned int a3)
{
  uint64_t v4 = *(void *)(a1 + 104);
  uint64_t v19 = 0;
  int v5 = *(_DWORD *)(a1 + 696);
  if (v5 == 3) {
    goto LABEL_9;
  }
  if (v5 != 2)
  {
    if (v5)
    {
LABEL_12:
      uint64_t v14 = "Unable to complete request for auth-agent";
      uint64_t v15 = v4;
      uint64_t v10 = 4294967274;
      return _libssh2_error(v15, v10, v14);
    }
    *(void *)(a1 + 736) = a3 + 10;
    *(void *)(a1 + 752) = 0;
    *(unsigned char *)(a1 + 700) = 98;
    uint64_t v19 = (_DWORD *)(a1 + 701);
    _libssh2_store_u32(&v19, *(_DWORD *)(a1 + 68));
    _libssh2_store_str(&v19, a2, a3);
    uint64_t v8 = v19;
    uint64_t v19 = (_DWORD *)((char *)v19 + 1);
    *uint64_t v8 = 1;
    *(_DWORD *)(a1 + 696) = 2;
  }
  uint64_t v9 = _libssh2_transport_send(v4, (void *)(a1 + 700), *(void *)(a1 + 736), 0, 0);
  if (!v9)
  {
    _libssh2_htonu32((_DWORD *)(a1 + 744), *(_DWORD *)(a1 + 48));
    *(_DWORD *)(a1 + 696) = 3;
LABEL_9:
    unint64_t v17 = 0;
    int v18 = 0;
    uint64_t v12 = _libssh2_packet_requirev(v4, "cd", &v18, &v17, 1, (const void *)(a1 + 744), 4uLL, (time_t *)(a1 + 752));
    uint64_t v11 = v12;
    if (v12 == -37) {
      return v11;
    }
    if (v12)
    {
      *(_DWORD *)(a1 + 696) = 0;
      uint64_t v14 = "Failed to request auth-agent";
      uint64_t v15 = v4;
      uint64_t v10 = 4294967282;
      return _libssh2_error(v15, v10, v14);
    }
    int v13 = *v18;
    (*(void (**)(void))(v4 + 24))();
    *(_DWORD *)(a1 + 696) = 0;
    if (v13 == 99) {
      return v11;
    }
    goto LABEL_12;
  }
  uint64_t v10 = v9;
  if (v9 != -37)
  {
    *(_DWORD *)(a1 + 696) = 0;
    uint64_t v14 = "Unable to send auth-agent request";
    uint64_t v15 = v4;
    return _libssh2_error(v15, v10, v14);
  }
  uint64_t v11 = 4294967259;
  _libssh2_error(v4, v9, "Would block sending auth-agent request");
  return v11;
}

uint64_t libssh2_channel_request_pty_ex(uint64_t a1, const void *a2, unsigned int a3, const void *a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  if (!a1) {
    return 4294967257;
  }
  uint64_t v17 = a9;
  time_t v18 = time(0);
  unsigned int v43 = a5 + a3;
  uint64_t v42 = a5 + a3 + 41;
  unint64_t v19 = a3;
  uint64_t v20 = (time_t *)(a1 + 488);
  unint64_t v40 = a5;
  unint64_t v41 = v19;
  uint64_t v44 = (_DWORD *)(a1 + 480);
  time_t v39 = v18;
  while (1)
  {
    uint64_t v21 = *(void *)(a1 + 104);
    int v47 = 0;
    int v22 = *(_DWORD *)(a1 + 168);
    if (v22 == 3) {
      break;
    }
    if (v22 == 2) {
      goto LABEL_9;
    }
    if (v22) {
      goto LABEL_22;
    }
    if (v43 < 0x101)
    {
      *(void *)(a1 + 472) = v42;
      *(void *)(a1 + 488) = 0;
      int v47 = (_DWORD *)(a1 + 173);
      *(unsigned char *)(a1 + 172) = 98;
      _libssh2_store_u32(&v47, *(_DWORD *)(a1 + 68));
      _libssh2_store_str(&v47, "pty-req", 7uLL);
      unint64_t v26 = v47;
      int v47 = (_DWORD *)((char *)v47 + 1);
      *unint64_t v26 = 1;
      _libssh2_store_str(&v47, a2, v41);
      _libssh2_store_u32(&v47, a6);
      _libssh2_store_u32(&v47, a7);
      _libssh2_store_u32(&v47, a8);
      _libssh2_store_u32(&v47, v17);
      _libssh2_store_str(&v47, a4, v40);
      *(_DWORD *)(a1 + 168) = 2;
LABEL_9:
      uint64_t v27 = _libssh2_transport_send(v21, (void *)(a1 + 172), *(void *)(a1 + 472), 0, 0);
      if (v27)
      {
        uint64_t v24 = v27;
        if (v27 == -37)
        {
          _libssh2_error(v21, v27, "Would block sending pty request");
          goto LABEL_25;
        }
        *(_DWORD *)(a1 + 168) = 0;
        uint64_t v23 = v21;
        uint64_t v25 = "Unable to send pty-request packet";
        goto LABEL_23;
      }
      _libssh2_htonu32(v44, *(_DWORD *)(a1 + 48));
      *(_DWORD *)(a1 + 168) = 3;
      break;
    }
    uint64_t v23 = v21;
    uint64_t v24 = 4294967262;
    uint64_t v25 = "term + mode lengths too large";
LABEL_23:
    uint64_t result = _libssh2_error(v23, v24, v25);
LABEL_24:
    if (result != -37) {
      return result;
    }
LABEL_25:
    uint64_t v38 = *(void *)(a1 + 104);
    if (!*(_DWORD *)(v38 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(v38, v18);
    if (result) {
      return result;
    }
  }
  unint64_t v45 = 0;
  uint64_t v46 = 0;
  uint64_t result = _libssh2_packet_requirev(v21, "cd", &v46, &v45, 1, v44, 4uLL, v20);
  if (result == -37) {
    goto LABEL_24;
  }
  if (result) {
    BOOL v29 = 1;
  }
  else {
    BOOL v29 = v45 == 0;
  }
  if (v29)
  {
    *(_DWORD *)(a1 + 168) = 0;
    uint64_t v23 = v21;
    uint64_t v24 = 4294967282;
    uint64_t v25 = "Failed to require the PTY package";
    goto LABEL_23;
  }
  uint64_t v30 = v20;
  uint64_t v31 = v17;
  uint64_t v32 = a2;
  uint64_t v33 = a4;
  uint64_t v34 = a6;
  uint64_t v35 = a7;
  uint64_t v36 = a8;
  int v37 = *v46;
  (*(void (**)(void))(v21 + 24))();
  *(_DWORD *)(a1 + 168) = 0;
  BOOL v29 = v37 == 99;
  a8 = v36;
  a7 = v35;
  a6 = v34;
  a4 = v33;
  a2 = v32;
  uint64_t v17 = v31;
  uint64_t v20 = v30;
  time_t v18 = v39;
  if (!v29)
  {
LABEL_22:
    uint64_t v23 = v21;
    uint64_t v24 = 4294967274;
    uint64_t v25 = "Unable to complete request for channel request-pty";
    goto LABEL_23;
  }
  return 0;
}

uint64_t libssh2_channel_request_pty_size_ex(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  if (!a1) {
    return 4294967257;
  }
  time_t v10 = time(0);
  while (1)
  {
    uint64_t v11 = *(void *)(a1 + 104);
    uint64_t v17 = 0;
    int v12 = *(_DWORD *)(a1 + 168);
    if (v12 != 2)
    {
      if (v12)
      {
        uint64_t result = 4294967282;
        goto LABEL_18;
      }
      *(void *)(a1 + 472) = 39;
      *(void *)(a1 + 488) = 0;
      uint64_t v17 = (_DWORD *)(a1 + 173);
      *(unsigned char *)(a1 + 172) = 98;
      _libssh2_store_u32(&v17, *(_DWORD *)(a1 + 68));
      _libssh2_store_str(&v17, "window-change", 0xDuLL);
      int v13 = v17;
      uint64_t v17 = (_DWORD *)((char *)v17 + 1);
      *int v13 = 0;
      _libssh2_store_u32(&v17, a2);
      _libssh2_store_u32(&v17, a3);
      _libssh2_store_u32(&v17, a4);
      _libssh2_store_u32(&v17, a5);
      *(_DWORD *)(a1 + 168) = 2;
    }
    uint64_t v14 = _libssh2_transport_send(v11, (void *)(a1 + 172), *(void *)(a1 + 472), 0, 0);
    if (v14 == -37)
    {
      _libssh2_error(v11, v14, "Would block sending window-change request");
      goto LABEL_11;
    }
    if (!v14) {
      break;
    }
    *(_DWORD *)(a1 + 168) = 0;
    uint64_t result = _libssh2_error(v11, v14, "Unable to send window-change packet");
    if (result != -37) {
      return result;
    }
LABEL_11:
    uint64_t v16 = *(void *)(a1 + 104);
    if (!*(_DWORD *)(v16 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(v16, v10);
    if (result) {
      return result;
    }
  }
  _libssh2_htonu32((_DWORD *)(a1 + 480), *(_DWORD *)(a1 + 48));
  uint64_t result = 0;
LABEL_18:
  *(_DWORD *)(a1 + 168) = 0;
  return result;
}

uint64_t libssh2_channel_x11_req_ex(uint64_t a1, int a2, const char *a3, const char *a4, unsigned int a5)
{
  v35[3] = *MEMORY[0x263EF8340];
  if (!a1) {
    return 4294967257;
  }
  time_t v10 = time(0);
  BOOL v31 = a2 != 0;
  uint64_t v11 = "MIT-MAGIC-COOKIE-1";
  if (a3) {
    uint64_t v11 = a3;
  }
  uint64_t v30 = v11;
  uint64_t v32 = (_DWORD *)(a1 + 520);
  while (1)
  {
    uint64_t v12 = *(void *)(a1 + 104);
    if (a3)
    {
      size_t v13 = strlen(a3);
      if (a4) {
        goto LABEL_7;
      }
    }
    else
    {
      size_t v13 = 18;
      if (a4)
      {
LABEL_7:
        size_t v14 = strlen(a4);
        goto LABEL_10;
      }
    }
    size_t v14 = 32;
LABEL_10:
    __dst = 0;
    int v15 = *(_DWORD *)(a1 + 496);
    if (v15 == 3) {
      goto LABEL_21;
    }
    if (v15 == 2) {
      goto LABEL_17;
    }
    if (!v15) {
      break;
    }
LABEL_25:
    uint64_t v24 = v12;
    uint64_t v22 = 4294967274;
    uint64_t v25 = "Unable to complete request for channel x11-req";
LABEL_31:
    uint64_t result = _libssh2_error(v24, v22, v25);
LABEL_32:
    if (result != -37) {
      return result;
    }
LABEL_33:
    uint64_t v26 = *(void *)(a1 + 104);
    if (!*(_DWORD *)(v26 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(v26, v10);
    if (result) {
      return result;
    }
  }
  *(void *)(a1 + 512) = v13 + v14 + 30;
  *(void *)(a1 + 528) = 0;
  uint64_t v16 = (unsigned char *)(*(uint64_t (**)(void))(v12 + 8))();
  *(void *)(a1 + 504) = v16;
  if (!v16)
  {
    uint64_t v24 = v12;
    uint64_t v22 = 4294967290;
    uint64_t v25 = "Unable to allocate memory for pty-request";
    goto LABEL_31;
  }
  __dst = v16 + 1;
  *uint64_t v16 = 98;
  _libssh2_store_u32((_DWORD **)&__dst, *(_DWORD *)(a1 + 68));
  _libssh2_store_str((_DWORD **)&__dst, "x11-req", 7uLL);
  uint64_t v17 = __dst;
  __dst = (char *)__dst + 1;
  *uint64_t v17 = 1;
  time_t v18 = __dst;
  __dst = (char *)__dst + 1;
  *time_t v18 = v31;
  _libssh2_store_str((_DWORD **)&__dst, v30, v13);
  _libssh2_store_u32((_DWORD **)&__dst, v14);
  if (a4)
  {
    memcpy(__dst, a4, v14);
  }
  else
  {
    if (_libssh2_openssl_random((unsigned __int8 *)v35, 0x10uLL))
    {
      uint64_t v24 = v12;
      uint64_t v22 = 4294967247;
      uint64_t v25 = "Unable to get random bytes for x11-req cookie";
      goto LABEL_31;
    }
    unsigned int v29 = a5;
    uint64_t v27 = 0;
    for (uint64_t i = 0; i != 16; ++i)
    {
      snprintf((char *)__dst + v27, 3uLL, "%02X", *((unsigned __int8 *)v35 + i));
      v27 += 2;
    }
    a5 = v29;
  }
  __dst = (char *)__dst + v14;
  _libssh2_store_u32((_DWORD **)&__dst, a5);
  *(_DWORD *)(a1 + 496) = 2;
LABEL_17:
  uint64_t v19 = _libssh2_transport_send(v12, *(void **)(a1 + 504), *(void *)(a1 + 512), 0, 0);
  if (v19)
  {
    uint64_t v20 = v19;
    if (v19 == -37)
    {
      _libssh2_error(v12, 4294967259, "Would block sending X11-req packet");
      goto LABEL_33;
    }
    (*(void (**)(void, uint64_t))(v12 + 24))(*(void *)(a1 + 504), v12);
    *(void *)(a1 + 504) = 0;
    *(_DWORD *)(a1 + 496) = 0;
    uint64_t v24 = v12;
    uint64_t v22 = v20;
    uint64_t v25 = "Unable to send x11-req packet";
    goto LABEL_31;
  }
  (*(void (**)(void, uint64_t))(v12 + 24))(*(void *)(a1 + 504), v12);
  *(void *)(a1 + 504) = 0;
  _libssh2_htonu32(v32, *(_DWORD *)(a1 + 48));
  *(_DWORD *)(a1 + 496) = 3;
LABEL_21:
  v35[0] = 0;
  uint64_t v33 = 0;
  uint64_t result = _libssh2_packet_requirev(v12, "cd", &v33, v35, 1, v32, 4uLL, (time_t *)(a1 + 528));
  if (result == -37) {
    goto LABEL_32;
  }
  uint64_t v22 = result;
  if (result || !v35[0])
  {
    *(_DWORD *)(a1 + 496) = 0;
    uint64_t v24 = v12;
    uint64_t v25 = "waiting for x11-req response packet";
    goto LABEL_31;
  }
  int v23 = *v33;
  (*(void (**)(void))(v12 + 24))();
  *(_DWORD *)(a1 + 496) = 0;
  if (v23 != 99) {
    goto LABEL_25;
  }
  return 0;
}

uint64_t _libssh2_channel_process_startup(uint64_t a1, const void *a2, unint64_t a3, const void *a4, size_t a5)
{
  uint64_t v6 = *(void *)(a1 + 104);
  int v28 = 0;
  int v7 = *(_DWORD *)(a1 + 536);
  if (v7 > 2)
  {
    if (v7 == 3) {
      goto LABEL_18;
    }
    if (v7 != 17)
    {
LABEL_24:
      int v23 = "Unable to complete request for channel-process-startup";
      uint64_t v24 = v6;
      uint64_t v21 = 4294967274;
      return _libssh2_error(v24, v21, v23);
    }
    time_t v10 = "Channel can not be reused";
    uint64_t v11 = v6;
    uint64_t v12 = 4294967257;
  }
  else
  {
    if (v7)
    {
      if (v7 != 2) {
        goto LABEL_24;
      }
      goto LABEL_14;
    }
    *(void *)(a1 + 552) = a3 + 10;
    *(void *)(a1 + 568) = 0;
    if (a4) {
      *(void *)(a1 + 552) = a3 + 14;
    }
    uint64_t v15 = (*(uint64_t (**)(void))(v6 + 8))();
    *(void *)(a1 + 544) = v15;
    if (v15)
    {
      int v28 = (_DWORD *)(v15 + 1);
      *(unsigned char *)uint64_t v15 = 98;
      _libssh2_store_u32(&v28, *(_DWORD *)(a1 + 68));
      _libssh2_store_str(&v28, a2, a3);
      uint64_t v16 = v28;
      int v28 = (_DWORD *)((char *)v28 + 1);
      *uint64_t v16 = 1;
      if (a4) {
        _libssh2_store_u32(&v28, a5);
      }
      *(_DWORD *)(a1 + 536) = 2;
LABEL_14:
      uint64_t v17 = _libssh2_transport_send(v6, *(void **)(a1 + 544), *(void *)(a1 + 552), a4, a5);
      if (v17)
      {
        uint64_t v18 = v17;
        if (v17 != -37)
        {
          (*(void (**)(void, uint64_t))(v6 + 24))(*(void *)(a1 + 544), v6);
          *(void *)(a1 + 544) = 0;
          *(_DWORD *)(a1 + 536) = 17;
          int v23 = "Unable to send channel request";
          uint64_t v24 = v6;
          uint64_t v21 = v18;
          return _libssh2_error(v24, v21, v23);
        }
        uint64_t v19 = 4294967259;
        _libssh2_error(v6, 4294967259, "Would block sending channel request");
        return v19;
      }
      (*(void (**)(void, uint64_t))(v6 + 24))(*(void *)(a1 + 544), v6);
      *(void *)(a1 + 544) = 0;
      _libssh2_htonu32((_DWORD *)(a1 + 560), *(_DWORD *)(a1 + 48));
      *(_DWORD *)(a1 + 536) = 3;
LABEL_18:
      unint64_t v26 = 0;
      uint64_t v27 = 0;
      uint64_t v20 = _libssh2_packet_requirev(v6, "cd", &v27, &v26, 1, (const void *)(a1 + 560), 4uLL, (time_t *)(a1 + 568));
      if (v20 == -37) {
        return 4294967259;
      }
      uint64_t v21 = v20;
      if (v20 || !v26)
      {
        *(_DWORD *)(a1 + 536) = 17;
        int v23 = "Failed waiting for channel success";
        uint64_t v24 = v6;
        return _libssh2_error(v24, v21, v23);
      }
      int v22 = *v27;
      (*(void (**)(void))(v6 + 24))();
      *(_DWORD *)(a1 + 536) = 17;
      if (v22 != 99) {
        goto LABEL_24;
      }
      return 0;
    }
    time_t v10 = "Unable to allocate memory for channel-process request";
    uint64_t v11 = v6;
    uint64_t v12 = 4294967290;
  }
  return _libssh2_error(v11, v12, v10);
}

uint64_t libssh2_channel_process_startup(uint64_t a1, const void *a2, unsigned int a3, const void *a4, unsigned int a5)
{
  if (!a1) {
    return 4294967257;
  }
  time_t v10 = time(0);
  do
  {
    uint64_t result = _libssh2_channel_process_startup(a1, a2, a3, a4, a5);
    if (result != -37) {
      break;
    }
    uint64_t v12 = *(void *)(a1 + 104);
    if (!*(_DWORD *)(v12 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(v12, v10);
  }
  while (!result);
  return result;
}

uint64_t libssh2_channel_set_blocking(uint64_t result, int a2)
{
  if (result) {
    return _libssh2_session_set_blocking(*(void *)(result + 104), a2);
  }
  return result;
}

uint64_t _libssh2_channel_flush(uint64_t a1, int a2)
{
  if (!*(_DWORD *)(a1 + 576))
  {
    uint64_t v4 = _libssh2_list_first(*(void *)(a1 + 104) + 536);
    *(_OWORD *)(a1 + 584) = 0u;
    if (v4)
    {
      int v5 = (uint64_t *)v4;
      do
      {
        uint64_t v6 = _libssh2_list_next((uint64_t)v5);
        if ((unint64_t)v5[4] <= 4) {
          goto LABEL_13;
        }
        int v7 = (unsigned __int8 *)v5[3];
        int v8 = *v7;
        if ((v8 & 0xFE) != 0x5E || _libssh2_ntohu32((unsigned int *)(v7 + 1)) != *(_DWORD *)(a1 + 48)) {
          goto LABEL_13;
        }
        if (v8 == 94)
        {
          int v9 = 0;
        }
        else
        {
          if ((unint64_t)v5[4] < 9)
          {
            *(_DWORD *)(a1 + 576) = 0;
            uint64_t v15 = *(void *)(a1 + 104);
            return _libssh2_error(v15, 4294967282, "Unexpected packet length");
          }
          int v9 = _libssh2_ntohu32((unsigned int *)(v5[3] + 5));
        }
        if (a2 != -2)
        {
          if (v8 == 95)
          {
            if (a2 != -1 && v9 != a2) {
              goto LABEL_13;
            }
          }
          else if (a2 || v8 != 94)
          {
            goto LABEL_13;
          }
        }
        uint64_t v10 = v5[4];
        uint64_t v11 = v5[3];
        uint64_t v12 = v10 - v5[5];
        *(void *)(a1 + 584) = v10 + *(void *)(a1 + 584) - 13;
        *(void *)(a1 + 592) += v12;
        (*(void (**)(uint64_t))(*(void *)(a1 + 104) + 24))(v11);
        _libssh2_list_remove(v5);
        (*(void (**)(uint64_t *))(*(void *)(a1 + 104) + 24))(v5);
LABEL_13:
        int v5 = (uint64_t *)v6;
      }
      while (v6);
    }
    *(_DWORD *)(a1 + 576) = 2;
  }
  uint64_t result = *(void *)(a1 + 592);
  *(void *)(a1 + 96) -= result;
  *(_DWORD *)(a1 + 76) -= result;
  uint64_t v14 = *(void *)(a1 + 584);
  if (v14)
  {
    if (_libssh2_channel_receive_window_adjust(a1, v14, 1, 0) == -37) {
      return 4294967259;
    }
    uint64_t result = *(unsigned int *)(a1 + 592);
  }
  *(_DWORD *)(a1 + 576) = 0;
  return result;
}

uint64_t _libssh2_channel_receive_window_adjust(uint64_t a1, unsigned int a2, int a3, _DWORD *a4)
{
  unsigned int v4 = a2;
  if (a4) {
    *a4 = *(_DWORD *)(a1 + 76);
  }
  if (!*(_DWORD *)(a1 + 600))
  {
    if (!a3)
    {
      unsigned int v8 = *(_DWORD *)(a1 + 88) + a2;
      if (v8 <= 0x3FF)
      {
        uint64_t v7 = 0;
        *(_DWORD *)(a1 + 88) = v8;
        return v7;
      }
    }
    int v9 = *(_DWORD *)(a1 + 88);
    if (!(a2 | v9)) {
      return 0;
    }
    unsigned int v4 = v9 + a2;
    *(_DWORD *)(a1 + 88) = 0;
    *(unsigned char *)(a1 + 604) = 93;
    _libssh2_htonu32((_DWORD *)(a1 + 605), *(_DWORD *)(a1 + 68));
    _libssh2_htonu32((_DWORD *)(a1 + 609), v4);
    *(_DWORD *)(a1 + 600) = 2;
  }
  int v6 = _libssh2_transport_send(*(void *)(a1 + 104), (void *)(a1 + 604), 9uLL, 0, 0);
  if (!v6)
  {
    uint64_t v7 = 0;
    *(_DWORD *)(a1 + 76) += v4;
    *(_DWORD *)(a1 + 600) = 0;
    return v7;
  }
  if (v6 == -37)
  {
    uint64_t v7 = 4294967259;
    _libssh2_error(*(void *)(a1 + 104), 4294967259, "Would block sending window adjust");
    return v7;
  }
  *(_DWORD *)(a1 + 88) = v4;
  uint64_t v11 = *(void *)(a1 + 104);
  return _libssh2_error(v11, 4294967289, "Unable to send transfer-window adjustment packet, deferring");
}

uint64_t libssh2_channel_flush_ex(uint64_t a1, int a2)
{
  if (!a1) {
    return 4294967257;
  }
  time_t v4 = time(0);
  do
  {
    uint64_t result = _libssh2_channel_flush(a1, a2);
    if (result != -37) {
      break;
    }
    uint64_t v6 = *(void *)(a1 + 104);
    if (!*(_DWORD *)(v6 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(v6, v4);
  }
  while (!result);
  return result;
}

uint64_t libssh2_channel_get_exit_status(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 36);
  }
  return result;
}

uint64_t libssh2_channel_get_exit_signal(uint64_t a1, void *a2, size_t *a3, void *a4, void *a5, void *a6, void *a7)
{
  if (!a1) {
    return 0;
  }
  uint64_t v14 = *(const char **)(a1 + 40);
  if (!v14)
  {
    if (a2) {
      *a2 = 0;
    }
    if (!a3) {
      goto LABEL_13;
    }
    size_t v17 = 0;
LABEL_12:
    *a3 = v17;
LABEL_13:
    if (a4) {
      *a4 = 0;
    }
    if (a5) {
      *a5 = 0;
    }
    if (a6) {
      *a6 = 0;
    }
    if (a7) {
      *a7 = 0;
    }
    return 0;
  }
  uint64_t v15 = *(void *)(a1 + 104);
  size_t v16 = strlen(v14);
  size_t v17 = v16;
  if (!a2)
  {
LABEL_6:
    if (!a3) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  uint64_t v18 = (void *)(*(uint64_t (**)(size_t, uint64_t))(v15 + 8))(v16 + 1, v15);
  *a2 = v18;
  if (v18)
  {
    memcpy(v18, *(const void **)(a1 + 40), v17);
    *(unsigned char *)(*a2 + v17) = 0;
    goto LABEL_6;
  }
  return _libssh2_error(v15, 4294967290, "Unable to allocate memory for signal name");
}

uint64_t libssh2_channel_receive_window_adjust(uint64_t a1, unsigned int a2, int a3)
{
  if (!a1) {
    return -39;
  }
  unsigned int v9 = 0;
  time_t v6 = time(0);
  while (1)
  {
    LODWORD(result) = _libssh2_channel_receive_window_adjust(a1, a2, a3, &v9);
    if (result != -37) {
      break;
    }
    uint64_t v8 = *(void *)(a1 + 104);
    if (!*(_DWORD *)(v8 + 172))
    {
      LODWORD(result) = -37;
      return (int)result;
    }
    LODWORD(result) = _libssh2_wait_socket(v8, v6);
    if (result) {
      return (int)result;
    }
  }
  if (result) {
    return (int)result;
  }
  else {
    return v9;
  }
}

uint64_t libssh2_channel_receive_window_adjust2(uint64_t a1, unsigned int a2, int a3, _DWORD *a4)
{
  if (!a1) {
    return 4294967257;
  }
  time_t v8 = time(0);
  do
  {
    uint64_t result = _libssh2_channel_receive_window_adjust(a1, a2, a3, a4);
    if (result != -37) {
      break;
    }
    uint64_t v10 = *(void *)(a1 + 104);
    if (!*(_DWORD *)(v10 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(v10, v8);
  }
  while (!result);
  return result;
}

uint64_t _libssh2_channel_extended_data(uint64_t a1, char a2)
{
  if (!*(_DWORD *)(a1 + 688)) {
    *(unsigned char *)(a1 + 86) = a2;
  }
  *(_DWORD *)(a1 + 688) = 0;
  return 0;
}

uint64_t libssh2_channel_handle_extended_data2(uint64_t a1, char a2)
{
  if (!a1) {
    return 4294967257;
  }
  time(0);
  if (!*(_DWORD *)(a1 + 688)) {
    *(unsigned char *)(a1 + 86) = a2;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 688) = 0;
  return result;
}

time_t libssh2_channel_handle_extended_data(time_t result, char a2)
{
  if (result)
  {
    time_t v3 = result;
    uint64_t result = time(0);
    if (!*(_DWORD *)(v3 + 688)) {
      *(unsigned char *)(v3 + 86) = a2;
    }
    *(_DWORD *)(v3 + 688) = 0;
  }
  return result;
}

unint64_t _libssh2_channel_read(uint64_t a1, int a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = *(void *)(a1 + 104);
  if (*(_DWORD *)(a1 + 616) == 11)
  {
    LODWORD(v10) = *(_DWORD *)(a1 + 72);
    LODWORD(v9) = *(_DWORD *)(a1 + 76);
LABEL_4:
    unsigned int v11 = v10 + a4 - v9;
    if (v11 <= 0x400) {
      unsigned int v12 = 1024;
    }
    else {
      unsigned int v12 = v11;
    }
    *(_DWORD *)(a1 + 616) = 11;
    int v13 = _libssh2_channel_receive_window_adjust(a1, v12, 0, 0);
    if (v13) {
      return v13;
    }
    *(_DWORD *)(a1 + 616) = 0;
    goto LABEL_9;
  }
  unint64_t v10 = *(unsigned int *)(a1 + 72);
  unint64_t v9 = *(unsigned int *)(a1 + 76);
  if (3 * (v10 >> 2) + a4 > v9) {
    goto LABEL_4;
  }
  do
LABEL_9:
    uint64_t v14 = _libssh2_transport_read(v8);
  while ((int)v14 > 0);
  uint64_t v15 = v14;
  if (v14 != -37 && v14)
  {
    int v28 = "transport read";
    uint64_t v29 = v8;
    uint64_t v30 = v15;
    return (int)_libssh2_error(v29, v30, v28);
  }
  uint64_t v16 = _libssh2_list_first(v8 + 536);
  if (!v16 || !a4) {
    goto LABEL_38;
  }
  size_t v17 = (uint64_t *)v16;
  uint64_t v33 = a3;
  unint64_t v18 = 0;
  int v32 = a2;
  do
  {
    uint64_t v19 = _libssh2_list_next((uint64_t)v17);
    if ((unint64_t)v17[4] < 5) {
      goto LABEL_34;
    }
    int v20 = _libssh2_ntohu32((unsigned int *)(v17[3] + 1));
    *(_DWORD *)(a1 + 620) = v20;
    uint64_t v21 = (unsigned __int8 *)v17[3];
    int v22 = *v21;
    if (a2)
    {
      if (v22 != 95
        || *(_DWORD *)(a1 + 48) != v20
        || (unint64_t)v17[4] < 9
        || _libssh2_ntohu32((unsigned int *)(v21 + 5)) != a2)
      {
        goto LABEL_34;
      }
      uint64_t v21 = (unsigned __int8 *)v17[3];
    }
    else if (v22 == 95)
    {
      if (*(_DWORD *)(a1 + 48) != v20 || *(unsigned char *)(a1 + 86) != 2) {
        goto LABEL_34;
      }
    }
    else if (v22 != 94 || *(_DWORD *)(a1 + 48) != v20)
    {
      goto LABEL_34;
    }
    unint64_t v23 = a4 - v18;
    uint64_t v24 = v17[4];
    uint64_t v25 = v17[5];
    unint64_t v26 = v24 - v25;
    if (a4 - v18 >= v24 - v25) {
      size_t v27 = v24 - v25;
    }
    else {
      size_t v27 = a4 - v18;
    }
    memcpy((void *)(v33 + v18), &v21[v25], v27);
    v17[5] += v27;
    v18 += v27;
    if (v23 >= v26)
    {
      _libssh2_list_remove(v17);
      (*(void (**)(uint64_t, uint64_t))(v8 + 24))(v17[3], v8);
      (*(void (**)(uint64_t *, uint64_t))(v8 + 24))(v17, v8);
    }
    a2 = v32;
LABEL_34:
    if (!v19) {
      break;
    }
    size_t v17 = (uint64_t *)v19;
  }
  while (v18 < a4);
  if (v18)
  {
    *(void *)(a1 + 96) -= v18;
    *(_DWORD *)(a1 + 76) -= v18;
    return v18;
  }
LABEL_38:
  if (*(unsigned char *)(a1 + 85)) {
    return 0;
  }
  unint64_t v18 = 0;
  if (v15 == -37 && !*(unsigned char *)(a1 + 84))
  {
    int v28 = "would block";
    uint64_t v29 = v8;
    uint64_t v30 = 4294967259;
    return (int)_libssh2_error(v29, v30, v28);
  }
  return v18;
}

unint64_t libssh2_channel_read_ex(uint64_t a1, int a2, uint64_t a3, unint64_t a4)
{
  if (!a1) {
    return -39;
  }
  if (*(unsigned int *)(a1 + 76) < a4)
  {
    time_t v8 = time(0);
    do
    {
      if (_libssh2_channel_receive_window_adjust(a1, a4, 1, 0) != -37) {
        break;
      }
      uint64_t v9 = *(void *)(a1 + 104);
      if (!*(_DWORD *)(v9 + 172)) {
        break;
      }
    }
    while (!_libssh2_wait_socket(v9, v8));
  }
  time_t v10 = time(0);
  while (1)
  {
    unint64_t result = _libssh2_channel_read(a1, a2, a3, a4);
    if (result != -37) {
      break;
    }
    uint64_t v12 = *(void *)(a1 + 104);
    if (!*(_DWORD *)(v12 + 172)) {
      return -37;
    }
    LODWORD(result) = _libssh2_wait_socket(v12, v10);
    if (result) {
      return (int)result;
    }
  }
  return result;
}

uint64_t libssh2_channel_window_read_ex(uint64_t result, uint64_t *a2, void *a3)
{
  if (result)
  {
    uint64_t v4 = result;
    if (a3) {
      *a3 = *(unsigned int *)(result + 72);
    }
    if (a2)
    {
      uint64_t v5 = _libssh2_list_first(*(void *)(result + 104) + 536);
      if (v5)
      {
        time_t v6 = (void *)v5;
        uint64_t v7 = 0;
        do
        {
          uint64_t v8 = _libssh2_list_next((uint64_t)v6);
          if (v6[4] > 4uLL)
          {
            uint64_t v9 = v6[3];
            if ((*(unsigned char *)v9 & 0xFE) == 0x5E
              && _libssh2_ntohu32((unsigned int *)(v9 + 1)) == *(_DWORD *)(v4 + 48))
            {
              uint64_t v7 = v6[4] + v7 - v6[5];
            }
          }
          time_t v6 = (void *)v8;
        }
        while (v8);
      }
      else
      {
        uint64_t v7 = 0;
      }
      *a2 = v7;
    }
    return *(unsigned int *)(v4 + 76);
  }
  return result;
}

uint64_t _libssh2_channel_packet_data_len(uint64_t a1, int a2)
{
  uint64_t result = _libssh2_list_first(*(void *)(a1 + 104) + 536);
  if (result)
  {
    uint64_t v5 = (void *)result;
    while (1)
    {
      uint64_t v6 = _libssh2_list_next((uint64_t)v5);
      if (v5[4] >= 5uLL)
      {
        int v7 = _libssh2_ntohu32((unsigned int *)(v5[3] + 1));
        uint64_t v8 = (unsigned __int8 *)v5[3];
        int v9 = *v8;
        if (a2)
        {
          if (v9 == 95
            && *(_DWORD *)(a1 + 48) == v7
            && v5[4] >= 9uLL
            && _libssh2_ntohu32((unsigned int *)(v8 + 5)) == a2)
          {
            return v5[4] - v5[5];
          }
        }
        else if (v9 == 95)
        {
          if (*(_DWORD *)(a1 + 48) == v7 && *(unsigned char *)(a1 + 86) == 2) {
            return v5[4] - v5[5];
          }
        }
        else if (v9 == 94 && *(_DWORD *)(a1 + 48) == v7)
        {
          return v5[4] - v5[5];
        }
      }
      uint64_t v5 = (void *)v6;
      if (!v6) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t _libssh2_channel_write(uint64_t a1, unsigned int a2, const void *a3, unint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 104);
  if (a4 >= 0x7FBC) {
    uint64_t v7 = 32700;
  }
  else {
    uint64_t v7 = a4;
  }
  int v8 = *(_DWORD *)(a1 + 624);
  if (v8)
  {
    if (v8 != 2) {
      return -34;
    }
    int v9 = *(char **)(a1 + 648);
    goto LABEL_7;
  }
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v12 = "We have already closed this channel";
    uint64_t v13 = *(void *)(a1 + 104);
    uint64_t v11 = 4294967270;
    return (int)_libssh2_error(v13, v11, v12);
  }
  if (*(unsigned char *)(a1 + 65))
  {
    uint64_t v12 = "EOF has already been received, data might be ignored";
    uint64_t v13 = *(void *)(a1 + 104);
    uint64_t v11 = 4294967269;
    return (int)_libssh2_error(v13, v11, v12);
  }
  uint64_t v16 = a1 + 628;
  do
    uint64_t v17 = _libssh2_transport_read(v6);
  while ((int)v17 > 0);
  uint64_t v11 = v17;
  if (v17 != -37 && v17)
  {
    uint64_t v13 = *(void *)(a1 + 104);
    uint64_t v12 = "Failure while draining incoming flow";
    return (int)_libssh2_error(v13, v11, v12);
  }
  if (*(_DWORD *)(a1 + 56))
  {
    *(void *)(a1 + 656) = v7;
    if (a2) {
      char v18 = 95;
    }
    else {
      char v18 = 94;
    }
    *(unsigned char *)(a1 + 628) = v18;
    int v22 = (_DWORD *)(a1 + 629);
    _libssh2_store_u32(&v22, *(_DWORD *)(a1 + 68));
    if (a2) {
      _libssh2_store_u32(&v22, a2);
    }
    unint64_t v19 = *(void *)(a1 + 656);
    unint64_t v20 = *(unsigned int *)(a1 + 56);
    if (v19 > v20)
    {
      *(void *)(a1 + 656) = v20;
      unint64_t v19 = v20;
    }
    unint64_t v21 = *(unsigned int *)(a1 + 60);
    if (v19 > v21)
    {
      *(void *)(a1 + 656) = v21;
      LODWORD(v19) = v21;
    }
    _libssh2_store_u32(&v22, v19);
    int v9 = (char *)v22 - v16;
    *(void *)(a1 + 648) = (char *)v22 - v16;
    *(_DWORD *)(a1 + 624) = 2;
LABEL_7:
    uint64_t v10 = _libssh2_transport_send(v6, (void *)(a1 + 628), (size_t)v9, a3, *(void *)(a1 + 656));
    if (!v10)
    {
      uint64_t result = *(void *)(a1 + 656);
      *(_DWORD *)(a1 + 56) -= result;
      *(_DWORD *)(a1 + 624) = 0;
      return result;
    }
    uint64_t v11 = v10;
    if (v10 != -37) {
      *(_DWORD *)(a1 + 624) = 0;
    }
    uint64_t v12 = "Unable to send channel data";
    uint64_t v13 = v6;
    return (int)_libssh2_error(v13, v11, v12);
  }
  *(_DWORD *)(v6 + 600) = 1;
  if (v17 == -37) {
    return -37;
  }
  else {
    return 0;
  }
}

uint64_t libssh2_channel_write_ex(uint64_t a1, unsigned int a2, const void *a3, unint64_t a4)
{
  if (!a1) {
    return -39;
  }
  time_t v8 = time(0);
  while (1)
  {
    uint64_t result = _libssh2_channel_write(a1, a2, a3, a4);
    if (result != -37) {
      break;
    }
    uint64_t v10 = *(void *)(a1 + 104);
    if (!*(_DWORD *)(v10 + 172)) {
      return -37;
    }
    LODWORD(result) = _libssh2_wait_socket(v10, v8);
    if (result) {
      return (int)result;
    }
  }
  return result;
}

uint64_t libssh2_channel_send_eof(uint64_t a1)
{
  if (!a1) {
    return 4294967257;
  }
  time_t v2 = time(0);
  do
  {
    uint64_t result = channel_send_eof(a1);
    if (result != -37) {
      break;
    }
    uint64_t v4 = *(void *)(a1 + 104);
    if (!*(_DWORD *)(v4 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(v4, v2);
  }
  while (!result);
  return result;
}

uint64_t channel_send_eof(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 104);
  char __src = 96;
  _libssh2_htonu32(&v7, *(_DWORD *)(a1 + 68));
  int v3 = _libssh2_transport_send(v2, &__src, 5uLL, 0, 0);
  if (v3)
  {
    if (v3 == -37)
    {
      uint64_t v4 = 4294967259;
      _libssh2_error(v2, 4294967259, "Would block sending EOF");
    }
    else
    {
      return _libssh2_error(v2, 4294967289, "Unable to send EOF on channel");
    }
  }
  else
  {
    uint64_t v4 = 0;
    *(unsigned char *)(a1 + 65) = 1;
  }
  return v4;
}

uint64_t libssh2_channel_eof(uint64_t a1)
{
  if (!a1) {
    return 4294967257;
  }
  uint64_t v2 = _libssh2_list_first(*(void *)(a1 + 104) + 536);
  if (!v2) {
    return *(char *)(a1 + 85);
  }
  uint64_t v3 = v2;
  while (1)
  {
    uint64_t v4 = _libssh2_list_next(v3);
    if (*(void *)(v3 + 32) > 4uLL)
    {
      uint64_t v5 = *(void *)(v3 + 24);
      if ((*(unsigned char *)v5 & 0xFE) == 0x5E)
      {
        int v6 = *(_DWORD *)(a1 + 48);
        if (v6 == _libssh2_ntohu32((unsigned int *)(v5 + 1))) {
          break;
        }
      }
    }
    uint64_t v3 = v4;
    if (!v4) {
      return *(char *)(a1 + 85);
    }
  }
  return 0;
}

uint64_t libssh2_channel_wait_eof(uint64_t a1)
{
  if (!a1) {
    return 4294967257;
  }
  time_t v2 = time(0);
  while (2)
  {
    if (!*(_DWORD *)(a1 + 676)) {
      *(_DWORD *)(a1 + 676) = 2;
    }
    uint64_t v3 = *(void *)(a1 + 104);
    while (1)
    {
      if (*(unsigned char *)(a1 + 85))
      {
        uint64_t result = 0;
        *(_DWORD *)(a1 + 676) = 0;
        return result;
      }
      if (*(void *)(a1 + 96) == *(_DWORD *)(a1 + 76) && *(_DWORD *)(v3 + 172)) {
        break;
      }
      uint64_t v4 = _libssh2_transport_read(v3);
      if (v4 == -37) {
        goto LABEL_14;
      }
      uint64_t v5 = v4;
      if ((v4 & 0x80000000) != 0)
      {
        *(_DWORD *)(a1 + 676) = 0;
        uint64_t v6 = v3;
        int v7 = "_libssh2_transport_read() bailed out!";
        goto LABEL_13;
      }
    }
    uint64_t v6 = v3;
    uint64_t v5 = 4294967249;
    int v7 = "Receiving channel window has been exhausted";
LABEL_13:
    uint64_t result = _libssh2_error(v6, v5, v7);
    if (result != -37) {
      return result;
    }
LABEL_14:
    uint64_t v9 = *(void *)(a1 + 104);
    if (!*(_DWORD *)(v9 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(v9, v2);
    if (!result) {
      continue;
    }
    return result;
  }
}

uint64_t _libssh2_channel_close(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v2 = 0;
    *(_DWORD *)(a1 + 664) = 0;
    return v2;
  }
  uint64_t v4 = *(void *)(a1 + 104);
  if (*(unsigned char *)(a1 + 65))
  {
    LODWORD(v2) = 0;
  }
  else
  {
    uint64_t v7 = channel_send_eof(a1);
    uint64_t v2 = v7;
    if (v7 == -37) {
      return v2;
    }
    if (v7) {
      _libssh2_error(v4, v7, "Unable to send EOF, but closing channel anyway");
    }
  }
  int v5 = *(_DWORD *)(a1 + 664);
  if (v5 != 2)
  {
    if (v5) {
      goto LABEL_17;
    }
    *(unsigned char *)(a1 + 668) = 97;
    _libssh2_htonu32((_DWORD *)(a1 + 669), *(_DWORD *)(a1 + 68));
    *(_DWORD *)(a1 + 664) = 2;
  }
  uint64_t v6 = _libssh2_transport_send(v4, (void *)(a1 + 668), 5uLL, 0, 0);
  uint64_t v2 = v6;
  if (v6)
  {
    if (v6 == -37)
    {
      _libssh2_error(v4, 4294967259, "Would block sending close-channel");
      return v2;
    }
    _libssh2_error(v4, v6, "Unable to send close-channel request, but closing anyway");
    int v5 = *(_DWORD *)(a1 + 664);
LABEL_17:
    if (v5 != 3) {
      goto LABEL_26;
    }
    goto LABEL_18;
  }
  *(_DWORD *)(a1 + 664) = 3;
LABEL_18:
  if (!*(unsigned char *)(a1 + 84) && !v2)
  {
    while (*(_DWORD *)(v4 + 596) != -1)
    {
      int v8 = _libssh2_transport_read(v4);
      if (*(unsigned char *)(a1 + 84)) {
        BOOL v9 = 0;
      }
      else {
        BOOL v9 = v8 == 0;
      }
      if (!v9)
      {
        LODWORD(v2) = v8;
        goto LABEL_26;
      }
    }
    LODWORD(v2) = 0;
    goto LABEL_29;
  }
LABEL_26:
  if (v2 != -37)
  {
LABEL_29:
    *(unsigned char *)(a1 + 64) = 1;
    uint64_t v10 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 120);
    if (v10) {
      v10(v4, v4, a1, a1 + 112);
    }
    *(_DWORD *)(a1 + 664) = 0;
  }
  return v2 & ((int)v2 >> 31);
}

uint64_t libssh2_channel_close(uint64_t a1)
{
  if (!a1) {
    return 4294967257;
  }
  time_t v2 = time(0);
  do
  {
    uint64_t result = _libssh2_channel_close(a1);
    if (result != -37) {
      break;
    }
    uint64_t v4 = *(void *)(a1 + 104);
    if (!*(_DWORD *)(v4 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(v4, v2);
  }
  while (!result);
  return result;
}

uint64_t libssh2_channel_wait_closed(uint64_t a1)
{
  if (!a1) {
    return 4294967257;
  }
  time_t v2 = time(0);
  while (1)
  {
    uint64_t v3 = *(void *)(a1 + 104);
    if (*(unsigned char *)(a1 + 85))
    {
      if (!*(_DWORD *)(a1 + 680)) {
        *(_DWORD *)(a1 + 680) = 2;
      }
      if (*(unsigned char *)(a1 + 84)) {
        goto LABEL_20;
      }
      do
      {
        uint64_t result = _libssh2_transport_read(v3);
        if (*(unsigned char *)(a1 + 84)) {
          BOOL v5 = 1;
        }
        else {
          BOOL v5 = (int)result <= 0;
        }
      }
      while (!v5);
      if ((result & 0x80000000) == 0)
      {
LABEL_20:
        uint64_t result = 0;
        *(_DWORD *)(a1 + 680) = 0;
        return result;
      }
    }
    else
    {
      uint64_t result = _libssh2_error(*(void *)(a1 + 104), 4294967262, "libssh2_channel_wait_closed() invoked when channel is not in EOF state");
    }
    if (result != -37) {
      return result;
    }
    uint64_t v6 = *(void *)(a1 + 104);
    if (!*(_DWORD *)(v6 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(v6, v2);
    if (result) {
      return result;
    }
  }
}

uint64_t libssh2_channel_free(uint64_t a1)
{
  if (!a1) {
    return 4294967257;
  }
  time_t v2 = time(0);
  do
  {
    uint64_t result = _libssh2_channel_free(a1);
    if (result != -37) {
      break;
    }
    uint64_t v4 = *(void *)(a1 + 104);
    if (!*(_DWORD *)(v4 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(v4, v2);
  }
  while (!result);
  return result;
}

uint64_t libssh2_channel_window_write_ex(uint64_t result, void *a2)
{
  if (result)
  {
    if (a2) {
      *a2 = *(unsigned int *)(result + 52);
    }
    return *(unsigned int *)(result + 56);
  }
  return result;
}

uint64_t libssh2_channel_signal_ex(uint64_t a1, const void *a2, unint64_t a3)
{
  if (!a1) {
    return 4294967257;
  }
  time_t v6 = time(0);
  while (1)
  {
    uint64_t v7 = *(void *)(a1 + 104);
    int v8 = *(_DWORD *)(a1 + 760);
    if (v8 == 2) {
      break;
    }
    if (v8)
    {
      uint64_t result = 4294967282;
      goto LABEL_20;
    }
    *(void *)(a1 + 776) = a3 + 20;
    uint64_t v9 = (*(uint64_t (**)(unint64_t, uint64_t))(v7 + 8))(a3 + 20, v7);
    *(void *)(a1 + 768) = v9;
    if (v9)
    {
      char v18 = (_DWORD *)(v9 + 1);
      *(unsigned char *)uint64_t v9 = 98;
      _libssh2_store_u32(&v18, *(_DWORD *)(a1 + 68));
      _libssh2_store_str(&v18, "signal", 6uLL);
      uint64_t v10 = v18;
      char v18 = (_DWORD *)((char *)v18 + 1);
      *uint64_t v10 = 0;
      _libssh2_store_str(&v18, a2, a3);
      *(_DWORD *)(a1 + 760) = 2;
      break;
    }
    uint64_t v13 = v7;
    uint64_t v14 = 4294967290;
    uint64_t v15 = "Unable to allocate memory for signal request";
LABEL_12:
    uint64_t result = _libssh2_error(v13, v14, v15);
    if (result != -37) {
      return result;
    }
LABEL_13:
    uint64_t v17 = *(void *)(a1 + 104);
    if (!*(_DWORD *)(v17 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(v17, v6);
    if (result) {
      return result;
    }
  }
  uint64_t v11 = _libssh2_transport_send(v7, *(void **)(a1 + 768), *(void *)(a1 + 776), 0, 0);
  if (v11 == -37)
  {
    _libssh2_error(v7, 4294967259, "Would block sending signal request");
    goto LABEL_13;
  }
  uint64_t v12 = v11;
  if (v11)
  {
    (*(void (**)(void, uint64_t))(v7 + 24))(*(void *)(a1 + 768), v7);
    *(_DWORD *)(a1 + 760) = 0;
    uint64_t v13 = v7;
    uint64_t v14 = v12;
    uint64_t v15 = "Unable to send signal packet";
    goto LABEL_12;
  }
  (*(void (**)(void, uint64_t))(v7 + 24))(*(void *)(a1 + 768), v7);
  uint64_t result = 0;
LABEL_20:
  *(_DWORD *)(a1 + 760) = 0;
  return result;
}

void _libssh2_channel_free_cold_1()
{
}

uint64_t *libssh2_knownhost_init(uint64_t a1)
{
  time_t v2 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(24, a1);
  uint64_t v3 = v2;
  if (v2)
  {
    *time_t v2 = a1;
    _libssh2_list_init(v2 + 1);
  }
  else
  {
    _libssh2_error(a1, 4294967290, "Unable to allocate memory for known-hosts collection");
  }
  return v3;
}

uint64_t libssh2_knownhost_add(uint64_t a1, char *a2, char *a3, char *a4, size_t a5, int a6, void *a7)
{
  return knownhost_add(a1, a2, a3, 0, 0, a4, a5, 0, 0, a6, a7);
}

uint64_t knownhost_add(uint64_t a1, char *__s, char *a3, const void *a4, size_t a5, char *a6, size_t a7, const void *a8, uint64_t a9, int a10, void *a11)
{
  size_t v17 = strlen(__s);
  uint64_t v18 = *(void *)a1;
  if ((a10 & 0x3C0000) != 0)
  {
    unint64_t v19 = _libssh2_calloc(v18, 0x90uLL);
    if (v19)
    {
      unint64_t v20 = v19;
      uint64_t v40 = 0;
      unint64_t v41 = 0;
      v19[11] = a10;
      if ((unsigned __int16)a10 != 3)
      {
        if ((unsigned __int16)a10 == 2)
        {
          uint64_t v25 = _libssh2_base64_decode(*(void *)a1, (uint64_t *)&v41, &v40, (unsigned __int8 *)__s, v17);
          if (v25) {
            goto LABEL_42;
          }
          uint64_t v26 = v40;
          *((void *)v20 + 3) = v41;
          *((void *)v20 + 4) = v26;
          size_t v27 = strlen(a3);
          uint64_t v25 = _libssh2_base64_decode(*(void *)a1, (uint64_t *)&v41, &v40, (unsigned __int8 *)a3, v27);
          if (v25) {
            goto LABEL_42;
          }
          uint64_t v28 = v40;
          *((void *)v20 + 6) = v41;
          *((void *)v20 + 7) = v28;
          if ((a10 & 0x20000) == 0)
          {
LABEL_8:
            if (!_libssh2_base64_encode(*(void *)a1, a6, a7, &v41))
            {
              uint64_t v32 = *(void *)a1;
              uint64_t v33 = "Unable to allocate memory for base64-encoded key";
              goto LABEL_40;
            }
            *((void *)v20 + 8) = v41;
            if (!a4) {
              goto LABEL_26;
            }
LABEL_23:
            if ((a10 & 0x3C0000) == 0x3C0000)
            {
              uint64_t v30 = (void *)(*(uint64_t (**)(size_t))(*(void *)a1 + 8))(a5 + 1);
              *((void *)v20 + 9) = v30;
              if (v30)
              {
                memcpy(v30, a4, a5);
                *(unsigned char *)(*((void *)v20 + 9) + a5) = 0;
                *((void *)v20 + 10) = a5;
                goto LABEL_26;
              }
              uint64_t v32 = *(void *)a1;
              uint64_t v33 = "Unable to allocate memory for key type";
LABEL_40:
              uint64_t v34 = 4294967290;
              goto LABEL_41;
            }
LABEL_26:
            if (!a8)
            {
              *((void *)v20 + 11) = 0;
LABEL_32:
              _libssh2_list_add((void **)(a1 + 8), v20);
              if (!a11) {
                return 0;
              }
              v20[26] = -559035650;
              *((void *)v20 + 14) = v20;
              int v35 = v20[11];
              if ((unsigned __int16)v35 == 1) {
                uint64_t v36 = *((void *)v20 + 3);
              }
              else {
                uint64_t v36 = 0;
              }
              uint64_t v25 = 0;
              uint64_t v37 = *((void *)v20 + 8);
              *((void *)v20 + 15) = v36;
              *((void *)v20 + 16) = v37;
              v20[34] = v35;
              *a11 = v20 + 26;
              return v25;
            }
            BOOL v31 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 8))(a9 + 1);
            *((void *)v20 + 11) = v31;
            if (v31)
            {
              memcpy(v31, a8, a9 + 1);
              *(unsigned char *)(*((void *)v20 + 11) + a9) = 0;
              *((void *)v20 + 12) = a9;
              goto LABEL_32;
            }
            uint64_t v32 = *(void *)a1;
            uint64_t v33 = "Unable to allocate memory for comment";
            goto LABEL_40;
          }
LABEL_19:
          if (!a7) {
            a7 = strlen(a6);
          }
          uint64_t v29 = (void *)(*(uint64_t (**)(size_t))(*(void *)a1 + 8))(a7 + 1);
          *((void *)v20 + 8) = v29;
          if (!v29)
          {
            uint64_t v32 = *(void *)a1;
            uint64_t v33 = "Unable to allocate memory for key";
            goto LABEL_40;
          }
          memcpy(v29, a6, a7 + 1);
          *(unsigned char *)(*((void *)v20 + 8) + a7) = 0;
          if (!a4) {
            goto LABEL_26;
          }
          goto LABEL_23;
        }
        if ((unsigned __int16)a10 != 1)
        {
          uint64_t v32 = *(void *)a1;
          uint64_t v33 = "Unknown host name type";
          uint64_t v34 = 4294967263;
LABEL_41:
          uint64_t v25 = _libssh2_error(v32, v34, v33);
LABEL_42:
          free_host(*(void *)a1, v20);
          return v25;
        }
      }
      unint64_t v21 = (void *)(*(uint64_t (**)(size_t))(*(void *)a1 + 8))(v17 + 1);
      *((void *)v20 + 3) = v21;
      if (!v21)
      {
        uint64_t v32 = *(void *)a1;
        uint64_t v33 = "Unable to allocate memory for host name";
        goto LABEL_40;
      }
      memcpy(v21, __s, v17 + 1);
      *((void *)v20 + 4) = v17;
      if ((a10 & 0x20000) == 0) {
        goto LABEL_8;
      }
      goto LABEL_19;
    }
    uint64_t v18 = *(void *)a1;
    int v22 = "Unable to allocate memory for known host entry";
    uint64_t v23 = 4294967290;
  }
  else
  {
    int v22 = "No key type set";
    uint64_t v23 = 4294967262;
  }
  return _libssh2_error(v18, v23, v22);
}

uint64_t libssh2_knownhost_addc(uint64_t a1, char *a2, char *a3, char *a4, size_t a5, const void *a6, uint64_t a7, int a8, void *a9)
{
  return knownhost_add(a1, a2, a3, 0, 0, a4, a5, a6, a7, a8, a9);
}

uint64_t libssh2_knownhost_check(uint64_t *a1, const char *a2, char *a3, size_t a4, int a5, uint64_t *a6)
{
  return knownhost_check(a1, a2, -1, a3, a4, a5, a6);
}

uint64_t knownhost_check(uint64_t *a1, const char *a2, int a3, char *a4, size_t a5, int a6, uint64_t *a7)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  int v7 = (unsigned __int16)a6;
  int v49 = 0;
  if ((unsigned __int16)a6 == 2) {
    return 1;
  }
  if ((a3 & 0x80000000) == 0)
  {
    uint64_t v14 = __str;
    if (snprintf(__str, 0x10EuLL, "[%s]:%d", a2, a3) >= 0x10E)
    {
      uint64_t v41 = *a1;
      uint64_t v42 = "Known-host write buffer too small";
      uint64_t v43 = 4294967258;
      goto LABEL_55;
    }
    uint64_t v46 = a7;
    int v15 = 2;
    if ((a6 & 0x20000) != 0) {
      goto LABEL_10;
    }
LABEL_8:
    if (_libssh2_base64_encode(*a1, a4, a5, (const char **)&v49))
    {
      a4 = v49;
      goto LABEL_10;
    }
    uint64_t v41 = *a1;
    uint64_t v42 = "Unable to allocate memory for base64-encoded key";
    uint64_t v43 = 4294967290;
LABEL_55:
    _libssh2_error(v41, v43, v42);
    return 3;
  }
  uint64_t v46 = a7;
  int v15 = 1;
  uint64_t v14 = (char *)a2;
  if ((a6 & 0x20000) == 0) {
    goto LABEL_8;
  }
LABEL_10:
  uint64_t v16 = 0;
  unint64_t v45 = a1;
  uint64_t v47 = (uint64_t)(a1 + 1);
  int v17 = a6 & 0x3C0000;
  do
  {
    uint64_t v18 = _libssh2_list_first(v47);
    if (v18)
    {
      uint64_t v19 = v18;
      do
      {
        int v20 = *(unsigned __int16 *)(v19 + 44);
        if (v20 == 3)
        {
          if (v7 != 3) {
            goto LABEL_41;
          }
        }
        else
        {
          if (v20 == 2)
          {
            if (v7 != 1) {
              goto LABEL_41;
            }
            uint64_t v23 = HMAC_CTX_new();
            if (*(void *)(v19 + 32) != 20) {
              goto LABEL_41;
            }
            uint64_t v24 = v23;
            uint64_t v25 = *(const void **)(v19 + 48);
            int v26 = *(_DWORD *)(v19 + 56);
            size_t v27 = EVP_sha1();
            HMAC_Init_ex(v24, v25, v26, v27, 0);
            size_t v28 = strlen(v14);
            HMAC_Update(v24, (const unsigned __int8 *)v14, v28);
            HMAC_Final(v24, md, 0);
            HMAC_CTX_free(v24);
            uint64_t v29 = *(uint64_t **)(v19 + 24);
            uint64_t v30 = *v29;
            uint64_t v31 = v29[1];
            uint64_t v32 = *((unsigned int *)v29 + 4);
            BOOL v22 = *(void *)md == v30 && v51 == v31 && v52 == v32;
            goto LABEL_31;
          }
          if (v20 != 1 || v7 != 1) {
            goto LABEL_41;
          }
        }
        BOOL v22 = strcmp(v14, *(const char **)(v19 + 24)) == 0;
LABEL_31:
        if (v22)
        {
          int v35 = *(_DWORD *)(v19 + 44);
          if (!v17 || v17 != 3932160 && v17 == (v35 & 0x3C0000))
          {
            uint64_t v36 = *(const char **)(v19 + 64);
            if (!strcmp(a4, v36))
            {
              uint64_t v37 = v46;
              if (v46)
              {
                *(_DWORD *)(v19 + 104) = -559035650;
                uint64_t v38 = v19 + 104;
                *(void *)(v19 + 112) = v19;
                if ((unsigned __int16)v35 == 1) {
                  uint64_t v40 = *(void *)(v19 + 24);
                }
                else {
                  uint64_t v40 = 0;
                }
                uint64_t v8 = 0;
                *(void *)(v19 + 120) = v40;
LABEL_62:
                *(void *)(v19 + 128) = v36;
                *(_DWORD *)(v19 + 136) = v35;
                uint64_t *v37 = v38;
              }
              else
              {
                uint64_t v8 = 0;
              }
              goto LABEL_63;
            }
            if (!v16) {
              uint64_t v16 = v19;
            }
          }
        }
LABEL_41:
        uint64_t v19 = _libssh2_list_next(v19);
      }
      while (v19);
    }
    uint64_t v14 = (char *)a2;
    --v15;
  }
  while (v15);
  if (v16)
  {
    uint64_t v37 = v46;
    if (v46)
    {
      *(_DWORD *)(v16 + 104) = -559035650;
      uint64_t v38 = v16 + 104;
      *(void *)(v16 + 112) = v16;
      int v35 = *(_DWORD *)(v16 + 44);
      if ((unsigned __int16)v35 == 1) {
        uint64_t v39 = *(void *)(v16 + 24);
      }
      else {
        uint64_t v39 = 0;
      }
      *(void *)(v16 + 120) = v39;
      uint64_t v36 = *(const char **)(v16 + 64);
      uint64_t v8 = 1;
      uint64_t v19 = v16;
      goto LABEL_62;
    }
    uint64_t v8 = 1;
  }
  else
  {
    uint64_t v8 = 2;
  }
LABEL_63:
  if (v49) {
    (*(void (**)(void))(*v45 + 24))();
  }
  return v8;
}

uint64_t libssh2_knownhost_del(uint64_t *a1, uint64_t a2)
{
  if (a2 && *(_DWORD *)a2 == -559035650)
  {
    uint64_t v4 = *(uint64_t **)(a2 + 8);
    _libssh2_list_remove(v4);
    *(void *)(a2 + 32) = 0;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    free_host(*a1, v4);
    return 0;
  }
  else
  {
    uint64_t v6 = *a1;
    return _libssh2_error(v6, 4294967262, "Invalid host information");
  }
}

uint64_t free_host(uint64_t result, void *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    uint64_t v4 = a2[11];
    if (v4) {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v4, v3);
    }
    uint64_t v5 = a2[9];
    if (v5) {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v5, v3);
    }
    uint64_t v6 = a2[8];
    if (v6) {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v6, v3);
    }
    uint64_t v7 = a2[6];
    if (v7) {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v7, v3);
    }
    uint64_t v8 = a2[3];
    if (v8) {
      (*(void (**)(uint64_t, uint64_t))(v3 + 24))(v8, v3);
    }
    uint64_t v9 = *(uint64_t (**)(void *, uint64_t))(v3 + 24);
    return v9(a2, v3);
  }
  return result;
}

uint64_t libssh2_knownhost_free(uint64_t *a1)
{
  uint64_t v2 = _libssh2_list_first((uint64_t)(a1 + 1));
  if (v2)
  {
    uint64_t v3 = (void *)v2;
    do
    {
      uint64_t v4 = _libssh2_list_next((uint64_t)v3);
      free_host(*a1, v3);
      uint64_t v3 = (void *)v4;
    }
    while (v4);
  }
  uint64_t v5 = *(uint64_t (**)(uint64_t *))(*a1 + 24);
  return v5(a1);
}

uint64_t libssh2_knownhost_readline(uint64_t *a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4 == 1)
  {
    if (a3)
    {
      uint64_t v4 = 0;
      for (uint64_t i = a3; ; --i)
      {
        unsigned int v6 = *(unsigned __int8 *)(a2 + v4);
        if (v6 > 0x23) {
          break;
        }
        if (((1 << v6) & 0x100000200) == 0)
        {
          if (((1 << v6) & 0x800000401) != 0) {
            return 0;
          }
          break;
        }
        if (a3 == ++v4) {
          return 0;
        }
      }
      uint64_t v10 = 0;
      unint64_t v11 = a2 + v4;
      while (v6 > 0x20u || ((1 << v6) & 0x100000201) == 0)
      {
        if (~v4 + a3 == v10) {
          goto LABEL_23;
        }
        LOBYTE(v6) = *(unsigned char *)(a2 + v10++ + v4 + 1);
      }
      uint64_t v12 = v4 + v10;
      uint64_t v13 = v12 + a2;
      uint64_t v14 = i - v10;
      while (1)
      {
        int v15 = *(unsigned __int8 *)(a2 + v12);
        if (v15 != 9 && v15 != 32) {
          break;
        }
        if (a3 == ++v12) {
          goto LABEL_23;
        }
      }
      if (!*(unsigned char *)(a2 + v12))
      {
LABEL_23:
        uint64_t v7 = *a1;
        uint64_t v8 = "Failed to parse known_hosts line";
        return _libssh2_error(v7, 4294967263, v8);
      }
      uint64_t v16 = 0;
      while (v15 != 10)
      {
        if (~v12 + a3 == v16)
        {
          int v15 = *(unsigned __int8 *)(v13 + v14);
          return hostline(a1, v11, v10, (char *)(a2 + v12), a3 - (v15 == 10) - v12);
        }
        int v15 = *(unsigned __int8 *)(a2 + v16++ + v12 + 1);
        if (!v15) {
          return hostline(a1, v11, v10, (char *)(a2 + v12), a3 - (v15 == 10) - v12);
        }
      }
      return hostline(a1, v11, v10, (char *)(a2 + v12), a3 - (v15 == 10) - v12);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    uint64_t v7 = *a1;
    uint64_t v8 = "Unsupported type of known-host information store";
    return _libssh2_error(v7, 4294967263, v8);
  }
}

uint64_t hostline(uint64_t *a1, unint64_t a2, uint64_t a3, char *__s1, unint64_t a5)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  if (a5 <= 0x13)
  {
    uint64_t v6 = *a1;
    return _libssh2_error(v6, 4294967263, "Failed to parse known_hosts line (key too short)");
  }
  size_t v8 = a5;
  uint64_t v9 = __s1;
  if ((*__s1 - 48) >= 0xA)
  {
    int v15 = &__s1[a5];
    uint64_t v16 = __s1;
    while (1)
    {
      unsigned int v17 = *v16;
      BOOL v18 = v17 > 0x20;
      uint64_t v19 = (1 << v17) & 0x100000201;
      if (!v18 && v19 != 0) {
        break;
      }
      ++v16;
      if (!--v8) {
        goto LABEL_14;
      }
    }
    int v15 = v16;
LABEL_14:
    size_t v13 = v15 - __s1;
    if (!strncmp(__s1, "ssh-dss", v15 - __s1))
    {
      int v14 = 786432;
    }
    else if (!strncmp(v9, "ssh-rsa", v15 - v9))
    {
      int v14 = 0x80000;
    }
    else if (!strncmp(v9, "ecdsa-sha2-nistp256", v15 - v9))
    {
      int v14 = 0x100000;
    }
    else if (!strncmp(v9, "ecdsa-sha2-nistp384", v15 - v9))
    {
      int v14 = 1310720;
    }
    else if (!strncmp(v9, "ecdsa-sha2-nistp521", v15 - v9))
    {
      int v14 = 1572864;
    }
    else if (!strncmp(v9, "ssh-ed25519", v15 - v9))
    {
      int v14 = 1835008;
    }
    else
    {
      int v14 = 3932160;
    }
    while (1)
    {
      int v21 = *v15;
      if (v21 != 9 && v21 != 32) {
        break;
      }
      ++v15;
      --v8;
    }
    if (v8)
    {
      uint64_t v22 = 0;
      while (v21 > 0x20u || ((1 << v21) & 0x100000201) == 0)
      {
        if (v8 - 1 == v22) {
          goto LABEL_36;
        }
        LOBYTE(v21) = v15[++v22];
      }
      uint64_t v12 = v8 - v22;
      uint64_t v23 = &v15[v22];
      *(void *)uint64_t v39 = &v15[v8];
      do
      {
        int v24 = *v23;
        if (v24 != 32 && v24 != 9)
        {
          size_t v8 = v22;
          *(void *)uint64_t v39 = v23;
          goto LABEL_45;
        }
        ++v23;
        --v12;
      }
      while (v12);
      size_t v8 = v22;
    }
    else
    {
LABEL_36:
      *(void *)uint64_t v39 = 0;
      uint64_t v12 = 0;
    }
  }
  else
  {
    *(void *)uint64_t v39 = 0;
    uint64_t v12 = 0;
    size_t v13 = 0;
    int v14 = 0x40000;
    int v15 = __s1;
    uint64_t v9 = 0;
  }
LABEL_45:
  if ((unint64_t)a3 >= 3 && (*(_WORD *)a2 != 12668 || *(unsigned char *)(a2 + 2) != 124))
  {
    if (a3 >= 1)
    {
      uint64_t v37 = v9;
      size_t v27 = v13;
      size_t v28 = a1;
      unint64_t v29 = 0;
      unint64_t v30 = a2 + a3;
      int v31 = v14 | 0x20001;
      do
      {
        unint64_t v32 = v30 - 1;
        ++v29;
        if (v30 - 1 == a2 || *(unsigned char *)(v30 - 2) == 44)
        {
          if (v29 >= 0xFF)
          {
            uint64_t v35 = *v28;
LABEL_70:
            uint64_t v36 = "Failed to parse known_hosts line (unexpected length)";
            return _libssh2_error(v35, 4294967263, v36);
          }
          __memcpy_chk();
          __s[v29] = 0;
          uint64_t result = knownhost_add((uint64_t)v28, __s, 0, v37, v27, v15, v8, *(const void **)v39, v12, v31, 0);
          if (result) {
            return result;
          }
          if (v32 > a2)
          {
            unint64_t v29 = 0;
            unint64_t v32 = v30 - 2;
          }
        }
        unint64_t v30 = v32;
      }
      while (v32 > a2);
    }
    return 0;
  }
  unint64_t v33 = 0;
  for (unint64_t i = a3 - 4; ; --i)
  {
    if (!*(unsigned char *)(a2 + v33 + 3)) {
      return 0;
    }
    if (*(unsigned char *)(a2 + v33 + 3) == 124) {
      break;
    }
    ++v33;
  }
  if (v33 >= 0x1F)
  {
    uint64_t v35 = *a1;
    uint64_t v36 = "Failed to parse known_hosts line (unexpectedly long salt)";
    return _libssh2_error(v35, 4294967263, v36);
  }
  int v38 = v14;
  __memcpy_chk();
  v41[v33] = 0;
  if (i >= 0xFF)
  {
    uint64_t v35 = *a1;
    goto LABEL_70;
  }
  __memcpy_chk();
  __s[i] = 0;
  return knownhost_add((uint64_t)a1, __s, v41, v9, v13, v15, v8, *(const void **)v39, v12, v38 | 0x20002u, 0);
}

uint64_t libssh2_knownhost_readfile(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)MEMORY[0x270FA5388](a1);
  uint64_t v3 = v1;
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (v4 != 1)
  {
    uint64_t v9 = *v1;
    uint64_t v10 = "Unsupported type of known-host information store";
    uint64_t v11 = 4294967263;
LABEL_9:
    return _libssh2_error(v9, v11, v10);
  }
  uint64_t v5 = fopen(v2, "r");
  if (!v5)
  {
    uint64_t v9 = *v3;
    uint64_t v10 = "Failed to open file";
    uint64_t v11 = 4294967280;
    goto LABEL_9;
  }
  uint64_t v6 = v5;
  uint64_t v7 = 0;
  if (fgets(__s, 4092, v5))
  {
    while (1)
    {
      size_t v8 = strlen(__s);
      if (libssh2_knownhost_readline(v3, (uint64_t)__s, v8, 1)) {
        break;
      }
      uint64_t v7 = (v7 + 1);
      if (!fgets(__s, 4092, v6)) {
        goto LABEL_13;
      }
    }
    uint64_t v7 = _libssh2_error(*v3, 4294967250, "Failed to parse known hosts file");
  }
LABEL_13:
  fclose(v6);
  return v7;
}

uint64_t libssh2_knownhost_writeline(uint64_t *a1, uint64_t a2, char *a3, size_t a4, void *a5, int a6)
{
  if (*(_DWORD *)a2 == -559035650) {
    return knownhost_writeline(a1, *(void *)(a2 + 8), a3, a4, a5, a6);
  }
  else {
    return _libssh2_error(*a1, 4294967262, "Invalid host information");
  }
}

uint64_t knownhost_writeline(uint64_t *a1, uint64_t a2, char *a3, size_t a4, void *a5, int a6)
{
  if (a6 != 1)
  {
    uint64_t v13 = *a1;
    uint64_t v14 = "Unsupported type of known-host information store";
LABEL_4:
    return _libssh2_error(v13, 4294967263, v14);
  }
  int v8 = *(_DWORD *)(a2 + 44);
  uint64_t v9 = ((v8 & 0x3C0000u) - 0x40000) >> 18;
  switch((int)v9)
  {
    case 0:
      goto LABEL_12;
    case 1:
    case 2:
      uint64_t v9 = 7;
      goto LABEL_12;
    case 3:
    case 4:
    case 5:
      uint64_t v9 = 19;
      goto LABEL_12;
    case 6:
      uint64_t v9 = 11;
      goto LABEL_12;
    case 14:
      if (!*(void *)(a2 + 72)) {
        goto LABEL_33;
      }
      uint64_t v9 = *(void *)(a2 + 80);
LABEL_12:
      size_t v16 = strlen(*(const char **)(a2 + 64));
      if (v9) {
        uint64_t v17 = v9 + 1;
      }
      else {
        uint64_t v17 = 0;
      }
      size_t v18 = v16 + v17;
      uint64_t v19 = *(void *)(a2 + 88);
      if (v19) {
        v18 += *(void *)(a2 + 96) + 1;
      }
      if ((unsigned __int16)v8 != 2)
      {
        unint64_t v23 = v18 + *(void *)(a2 + 32) + 3;
        if (v23 <= a4)
        {
          if (v9) {
            BOOL v25 = v19 == 0;
          }
          else {
            BOOL v25 = 1;
          }
          if (v25)
          {
            if (v19 || v9) {
              snprintf(a3, a4, "%s %s %s\n");
            }
            else {
              snprintf(a3, a4, "%s %s\n");
            }
          }
          else
          {
            snprintf(a3, a4, "%s %s %s %s\n");
          }
        }
        goto LABEL_43;
      }
      size_t v28 = 0;
      unint64_t v29 = 0;
      int v20 = _libssh2_base64_encode(*a1, *(char **)(a2 + 24), *(void *)(a2 + 32), &v29);
      uint64_t v21 = *a1;
      if (!v20)
      {
        int v26 = "Unable to allocate memory for base64-encoded host name";
LABEL_35:
        uint64_t v27 = 4294967290;
        return _libssh2_error(v21, v27, v26);
      }
      uint64_t v22 = _libssh2_base64_encode(v21, *(char **)(a2 + 48), *(void *)(a2 + 56), &v28);
      if (!v22)
      {
        (*(void (**)(const char *))(*a1 + 24))(v29);
        uint64_t v21 = *a1;
        int v26 = "Unable to allocate memory for base64-encoded salt";
        goto LABEL_35;
      }
      unint64_t v23 = (unint64_t)&v20[v18 + 7 + (void)v22];
      if (v23 <= a4)
      {
        uint64_t v24 = *(void *)(a2 + 88);
        if (v9 && v24)
        {
          snprintf(a3, a4, "|1|%s|%s %s %s %s\n");
        }
        else if (v24 || v9)
        {
          snprintf(a3, a4, "|1|%s|%s %s %s\n");
        }
        else
        {
          snprintf(a3, a4, "|1|%s|%s %s\n");
        }
      }
      (*(void (**)(const char *))(*a1 + 24))(v29);
      (*(void (**)(const char *))(*a1 + 24))(v28);
LABEL_43:
      *a5 = v23 - 1;
      if (v23 > a4)
      {
        uint64_t v21 = *a1;
        int v26 = "Known-host write buffer too small";
        uint64_t v27 = 4294967258;
        return _libssh2_error(v21, v27, v26);
      }
      return 0;
    default:
LABEL_33:
      uint64_t v13 = *a1;
      uint64_t v14 = "Unsupported type of known-host entry";
      goto LABEL_4;
  }
}

uint64_t libssh2_knownhost_writefile(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)MEMORY[0x270FA5388](a1);
  uint64_t v3 = v1;
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (v4 != 1)
  {
    uint64_t v12 = *v1;
    uint64_t v13 = "Unsupported type of known-host information store";
    uint64_t v14 = 4294967263;
LABEL_11:
    return _libssh2_error(v12, v14, v13);
  }
  uint64_t v5 = fopen(v2, "w");
  if (!v5)
  {
    uint64_t v12 = *v3;
    uint64_t v13 = "Failed to open file";
    uint64_t v14 = 4294967280;
    goto LABEL_11;
  }
  uint64_t v6 = v5;
  uint64_t v7 = _libssh2_list_first((uint64_t)(v3 + 1));
  if (v7)
  {
    uint64_t v8 = v7;
    while (1)
    {
      size_t __nitems = 0;
      uint64_t v9 = knownhost_writeline(v3, v8, __ptr, 0xFFCuLL, &__nitems, 1);
      if (v9) {
        break;
      }
      size_t v10 = __nitems;
      if (fwrite(__ptr, 1uLL, __nitems, v6) != v10)
      {
        uint64_t v9 = _libssh2_error(*v3, 4294967280, "Write failed");
        break;
      }
      uint64_t v8 = _libssh2_list_next(v8);
      if (!v8) {
        goto LABEL_8;
      }
    }
    uint64_t v11 = v9;
  }
  else
  {
LABEL_8:
    uint64_t v11 = 0;
  }
  fclose(v6);
  return v11;
}

uint64_t libssh2_knownhost_get(uint64_t a1, void *a2, uint64_t a3)
{
  if (a3 && *(void *)(a3 + 8))
  {
    uint64_t v4 = _libssh2_list_next(*(void *)(a3 + 8));
    if (!v4) {
      return 1;
    }
  }
  else
  {
    uint64_t v4 = _libssh2_list_first(a1 + 8);
    if (!v4) {
      return 1;
    }
  }
  *(_DWORD *)(v4 + 104) = -559035650;
  *(void *)(v4 + 112) = v4;
  int v6 = *(_DWORD *)(v4 + 44);
  if ((unsigned __int16)v6 == 1) {
    uint64_t v7 = *(void *)(v4 + 24);
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v5 = 0;
  uint64_t v8 = *(void *)(v4 + 64);
  *(void *)(v4 + 120) = v7;
  *(void *)(v4 + 128) = v8;
  *(_DWORD *)(v4 + 136) = v6;
  *a2 = v4 + 104;
  return v5;
}

uint64_t _libssh2_pem_parse(uint64_t a1, const char *a2, const char *a3, const char *a4, uint64_t a5, uint64_t *a6, rsize_t *a7)
{
  v56[15] = *MEMORY[0x263EF8340];
  do
  {
    __s1[0] = 0;
    if (readline(__s1)) {
      return 0xFFFFFFFFLL;
    }
  }
  while (strcmp(__s1, a2));
  if (readline(__s1)) {
    return 0xFFFFFFFFLL;
  }
  if (a4
    && (*(void *)__s1 == 0x7079542D636F7250 ? (BOOL v15 = v56[0] == 0x434E452C34203A65) : (BOOL v15 = 0),
        v15 ? (BOOL v16 = *(void *)((char *)v56 + 6) == 0x444554505952434ELL) : (BOOL v16 = 0),
        v16))
  {
    if (readline(__s1)) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v24 = libssh2_crypt_methods();
    BOOL v25 = *v24;
    if (!*v24) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v47 = 0;
    int v26 = v24 + 1;
    do
    {
      uint64_t v27 = v25[1];
      if (*v27)
      {
        size_t v28 = strlen(v25[1]);
        if (!memcmp(__s1, v27, v28))
        {
          __memcpy_chk();
          uint64_t v47 = v25;
        }
      }
      unint64_t v29 = *v26++;
      BOOL v25 = v29;
    }
    while (v29);
    if (!v47) {
      return 0xFFFFFFFFLL;
    }
    if (*((int *)v47 + 5) >= 1)
    {
      uint64_t v30 = 0;
      int v31 = v54;
      do
      {
        int v32 = *(v31 - 1);
        if (v32 <= 64) {
          char v33 = 64;
        }
        else {
          char v33 = 9;
        }
        char v34 = v33 + v32;
        int v35 = *v31;
        if (v35 <= 64) {
          char v36 = -48;
        }
        else {
          char v36 = -55;
        }
        v54[v30++ - 1] = (v36 + v35) | (16 * v34);
        v31 += 2;
      }
      while (v30 < *((int *)v47 + 5));
    }
    if (readline(__s1)) {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    uint64_t v47 = 0;
  }
  uint64_t v46 = a6;
  uint64_t v17 = 0;
  rsize_t v18 = 0;
  do
  {
    if (__s1[0])
    {
      size_t v19 = strlen(__s1);
      size_t v20 = v19;
      rsize_t v21 = v19 + v18;
      if (v17) {
        uint64_t v22 = (*(uint64_t (**)(unsigned __int8 *, rsize_t, uint64_t))(a1 + 16))(v17, v21, a1);
      }
      else {
        uint64_t v22 = (*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v19 + v18, a1);
      }
      unint64_t v23 = (unsigned __int8 *)v22;
      if (!v22)
      {
        _libssh2_error(a1, 4294967290, "Unable to allocate memory for PEM parsing");
        goto LABEL_48;
      }
      memcpy((void *)(v22 + v18), __s1, v20);
      uint64_t v17 = v23;
      rsize_t v18 = v21;
    }
    __s1[0] = 0;
    if (readline(__s1)) {
      goto LABEL_48;
    }
  }
  while (strcmp(__s1, a3));
  if (!v17) {
    return 0xFFFFFFFFLL;
  }
  if (_libssh2_base64_decode(a1, v46, a7, v17, v18))
  {
    uint64_t v13 = 0xFFFFFFFFLL;
    goto LABEL_50;
  }
  uint64_t v37 = v47;
  if (!v47)
  {
    uint64_t v13 = 0;
    goto LABEL_50;
  }
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  unint64_t v38 = *((int *)v47 + 4);
  ctx = 0;
  if (!_libssh2_md5_init(&ctx)) {
    goto LABEL_48;
  }
  size_t v39 = strlen(a4);
  EVP_DigestUpdate(ctx, a4, v39);
  EVP_DigestUpdate(ctx, &d, 8uLL);
  EVP_DigestFinal(ctx, md, 0);
  EVP_MD_CTX_free(ctx);
  if (*((int *)v47 + 6) < 17) {
    goto LABEL_56;
  }
  if (!_libssh2_md5_init(&ctx))
  {
LABEL_48:
    uint64_t v13 = 0xFFFFFFFFLL;
    goto LABEL_49;
  }
  EVP_DigestUpdate(ctx, md, 0x10uLL);
  size_t v40 = strlen(a4);
  EVP_DigestUpdate(ctx, a4, v40);
  EVP_DigestUpdate(ctx, &d, 8uLL);
  EVP_DigestFinal(ctx, v52, 0);
  EVP_MD_CTX_free(ctx);
  uint64_t v37 = v47;
LABEL_56:
  if (((unsigned int (*)(uint64_t, char **, char *, char *, unsigned __int8 *, uint64_t *, void, uint64_t *))v37[5])(a1, v37, &d, (char *)&v50 + 4, md, &v50, 0, &v49))
  {
    memset_s(md, 0x20uLL, 0, 0x20uLL);
    goto LABEL_63;
  }
  if (v50) {
    memset_s(md, 0x20uLL, 0, 0x20uLL);
  }
  rsize_t v41 = *a7;
  if (*a7 % v38)
  {
    memset_s(md, 0x20uLL, 0, 0x20uLL);
    ((void (*)(uint64_t, uint64_t *))v47[7])(a1, &v49);
    memset_s((void *)*v46, *a7, 0, *a7);
    uint64_t v46 = (uint64_t *)*v46;
LABEL_63:
    uint64_t v13 = 0xFFFFFFFFLL;
    (*(void (**)(uint64_t *, uint64_t))(a1 + 24))(v46, a1);
  }
  else
  {
    LODWORD(v42) = v41 - v38;
    if ((int)v41 - (int)v38 < 0)
    {
LABEL_71:
      size_t v45 = *(unsigned __int8 *)(v41 + *v46 - 1);
      bzero((void *)(*v46 + v41 - v45), v45);
      *a7 -= v45;
      memset_s(md, 0x20uLL, 0, 0x20uLL);
      ((void (*)(uint64_t, uint64_t *))v47[7])(a1, &v49);
      uint64_t v13 = 0;
    }
    else
    {
      uint64_t v43 = 0;
      while (1)
      {
        uint64_t v44 = v43 ? 2 * (v43 == v42) : 1;
        if (((unsigned int (*)(uint64_t, uint64_t, unint64_t, uint64_t *, uint64_t))v47[6])(a1, *v46 + v43, v38, &v49, v44))
        {
          break;
        }
        v43 += v38;
        rsize_t v41 = *a7;
        uint64_t v42 = (int)*a7 - v38;
        if (v43 > v42) {
          goto LABEL_71;
        }
      }
      memset_s(md, 0x20uLL, 0, 0x20uLL);
      ((void (*)(uint64_t, uint64_t *))v47[7])(a1, &v49);
      memset_s((void *)*v46, *a7, 0, *a7);
      uint64_t v13 = 4294967284;
      (*(void (**)(uint64_t, uint64_t))(a1 + 24))(*v46, a1);
    }
  }
LABEL_49:
  if (!v17) {
    return v13;
  }
LABEL_50:
  memset_s(v17, v18, 0, v18);
  (*(void (**)(unsigned __int8 *, uint64_t))(a1 + 24))(v17, a1);
  return v13;
}

char *__cdecl readline(const char *a1)
{
  if (!a1) {
    return (char *)0xFFFFFFFFLL;
  }
  if (!fgets((char *)a1, 128, v1)) {
    return (char *)0xFFFFFFFFLL;
  }
  if (!*a1) {
    return 0;
  }
  size_t v3 = strlen(a1);
  if (v3)
  {
    if (a1[v3 - 1] == 10)
    {
      a1[v3 - 1] = 0;
      if (!*a1) {
        return 0;
      }
    }
  }
  uint64_t result = (char *)strlen(a1);
  if (!result) {
    return result;
  }
  uint64_t v5 = result - 1;
  if (result[(void)a1 - 1] != 13) {
    return 0;
  }
  uint64_t result = 0;
  v5[(void)a1] = 0;
  return result;
}

uint64_t _libssh2_pem_parse_memory(uint64_t a1, const char *a2, const char *a3, uint64_t a4, unint64_t a5, uint64_t *a6, void *a7)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  unint64_t v22 = 0;
  do
  {
    __s1[0] = 0;
    readline_memory(__s1, a4, a5, &v22);
  }
  while (strcmp(__s1, a2));
  uint64_t v13 = 0;
  rsize_t v14 = 0;
  __s1[0] = 0;
LABEL_7:
  rsize_t v17 = v14;
  while (1)
  {
    __s1[0] = 0;
    readline_memory(__s1, a4, a5, &v22);
    if (!strcmp(__s1, a3)) {
      break;
    }
    rsize_t v14 = v17;
    if (!__s1[0]) {
      goto LABEL_7;
    }
    size_t v15 = strlen(__s1);
    size_t v16 = v15;
    v17 += v15;
    if (v13)
    {
      uint64_t v18 = (*(uint64_t (**)(void *, rsize_t, uint64_t))(a1 + 16))(v13, v17, a1);
      if (!v18)
      {
        _libssh2_error(a1, 4294967290, "Unable to allocate memory for PEM parsing");
        uint64_t v19 = 0xFFFFFFFFLL;
        rsize_t v17 = v14;
LABEL_17:
        memset_s(v13, v17, 0, v17);
        (*(void (**)(void *, uint64_t))(a1 + 24))(v13, a1);
        return v19;
      }
    }
    else
    {
      uint64_t v18 = (*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v15 + v14, a1);
      if (!v18)
      {
        _libssh2_error(a1, 4294967290, "Unable to allocate memory for PEM parsing");
        return 0xFFFFFFFFLL;
      }
    }
    memcpy((void *)(v18 + v14), __s1, v16);
    uint64_t v13 = (void *)v18;
  }
  if (v13)
  {
    if (_libssh2_base64_decode(a1, a6, a7, (unsigned __int8 *)v13, v17)) {
      uint64_t v19 = 0xFFFFFFFFLL;
    }
    else {
      uint64_t v19 = 0;
    }
    goto LABEL_17;
  }
  return 0xFFFFFFFFLL;
}

unsigned char *readline_memory(unsigned char *__dst, uint64_t a2, unint64_t a3, unint64_t *a4)
{
  uint64_t v5 = __dst;
  unint64_t v6 = *a4;
  if (*a4 >= a3)
  {
    size_t v10 = 0;
  }
  else
  {
    unint64_t v7 = 0;
    while (1)
    {
      int v8 = *(unsigned __int8 *)(a2 + v6 + v7);
      if (v8 == 10 || v8 == 13) {
        break;
      }
      size_t v10 = v7 + 1;
      if (v7 <= 0x7D)
      {
        unint64_t v11 = v6 + 1 + v7++;
        if (v11 < a3) {
          continue;
        }
      }
      goto LABEL_12;
    }
    size_t v10 = v7;
    if (!v7) {
      goto LABEL_13;
    }
LABEL_12:
    __dst = memcpy(__dst, (const void *)(a2 + v6), v10);
    *a4 += v10;
  }
LABEL_13:
  v5[v10] = 0;
  ++*a4;
  return __dst;
}

uint64_t _libssh2_openssh_pem_parse(uint64_t a1, const char *a2, uint64_t a3, void *a4)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  do
  {
    __s1[0] = 0;
    if (readline(__s1)) {
      return 0xFFFFFFFFLL;
    }
  }
  while (strcmp(__s1, "-----BEGIN OPENSSH PRIVATE KEY-----"));
  if (readline(__s1)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = 0;
  rsize_t v10 = 0;
  do
  {
    if (__s1[0])
    {
      size_t v11 = strlen(__s1);
      size_t v12 = v11;
      rsize_t v13 = v11 + v10;
      if (v9) {
        uint64_t v14 = (*(uint64_t (**)(unsigned __int8 *, rsize_t, uint64_t))(a1 + 16))(v9, v13, a1);
      }
      else {
        uint64_t v14 = (*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v11 + v10, a1);
      }
      uint64_t v9 = (unsigned __int8 *)v14;
      if (!v14)
      {
        _libssh2_error(a1, 4294967290, "Unable to allocate memory for PEM parsing");
        return 0xFFFFFFFFLL;
      }
      memcpy((void *)(v14 + v10), __s1, v12);
      rsize_t v10 = v13;
    }
    __s1[0] = 0;
    if (readline(__s1)) {
      return 0xFFFFFFFFLL;
    }
  }
  while (strcmp(__s1, "-----END OPENSSH PRIVATE KEY-----"));
  if (!v9) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = _libssh2_openssh_pem_parse_data(a1, a2, v9, v10, a4);
  memset_s(v9, v10, 0, v10);
  (*(void (**)(unsigned __int8 *, uint64_t))(a1 + 24))(v9, a1);
  return v7;
}

uint64_t _libssh2_openssh_pem_parse_data(uint64_t a1, const char *a2, unsigned __int8 *a3, uint64_t a4, void *a5)
{
  uint64_t v5 = (uint64_t)a5;
  uint64_t v55 = 0;
  __s1 = 0;
  uint64_t v53 = 0;
  uint64_t v54 = 0;
  int v52 = 0;
  unsigned int v49 = 0;
  rsize_t __n = 0;
  __s = 0;
  size_t v45 = 0;
  uint64_t v46 = 0;
  unint64_t v44 = 0;
  if (a5) {
    *a5 = 0;
  }
  uint64_t v63 = 0;
  uint64_t v64 = 0;
  rsize_t v65 = 0;
  unint64_t v61 = 0;
  size_t v62 = 0;
  unint64_t v60 = 0;
  uint64_t v58 = 0;
  uint64_t v59 = 0;
  uint64_t v57 = 0;
  uint64_t v51 = 0;
  int v50 = 0;
  if (_libssh2_base64_decode(a1, (uint64_t *)&__s, &__n, a3, a4))
  {
    uint64_t v5 = 0xFFFFFFFFLL;
    goto LABEL_18;
  }
  int v8 = (char *)__s;
  uint64_t v63 = __s;
  uint64_t v64 = __s;
  rsize_t v65 = __n;
  if (__n <= 0xD)
  {
    uint64_t v9 = "key too short";
LABEL_17:
    uint64_t v5 = _libssh2_error(a1, 4294967282, v9);
    goto LABEL_18;
  }
  if (strncmp((const char *)__s, "openssh-key-v1", 0xEuLL))
  {
    uint64_t v9 = "key auth magic mismatch";
    goto LABEL_17;
  }
  uint64_t v64 = v8 + 15;
  if (_libssh2_get_string(&v63, &__s1, &v45) || !v45)
  {
    uint64_t v9 = "ciphername is missing";
    goto LABEL_17;
  }
  if (_libssh2_get_string(&v63, &v55, &v45) || !v45)
  {
    uint64_t v9 = "kdfname is missing";
    goto LABEL_17;
  }
  if (_libssh2_get_string(&v63, &v54, &v46))
  {
    uint64_t v9 = "kdf is missing";
    goto LABEL_17;
  }
  uint64_t v57 = v54;
  uint64_t v58 = v54;
  uint64_t v59 = v46;
  if ((!a2 || !*a2) && strcmp(__s1, "none"))
  {
    uint64_t v5 = 4294967248;
    goto LABEL_18;
  }
  size_t v11 = v55;
  if (!strcmp(v55, "none"))
  {
    if (strcmp(__s1, "none"))
    {
      uint64_t v9 = "invalid format";
      goto LABEL_17;
    }
  }
  else if (strcmp(v11, "bcrypt"))
  {
    uint64_t v9 = "unknown cipher";
    goto LABEL_17;
  }
  if (_libssh2_get_u32(&v63, (_DWORD *)&v51 + 1) || HIDWORD(v51) != 1)
  {
    uint64_t v9 = "Multiple keys are unsupported";
    goto LABEL_17;
  }
  if (_libssh2_get_string(&v63, &v53, &v45) || !v45)
  {
    uint64_t v9 = "Invalid private key; expect embedded public key";
    goto LABEL_17;
  }
  if (_libssh2_get_string(&v63, &v53, &v45) || !v45)
  {
    uint64_t v9 = "Private key data not found";
    goto LABEL_17;
  }
  unint64_t v60 = v53;
  unint64_t v61 = v53;
  size_t v62 = v45;
  if (__s1 && strcmp(__s1, "none"))
  {
    size_t v12 = libssh2_crypt_methods();
    rsize_t v13 = (const char **)*v12;
    if (!*v12) {
      goto LABEL_63;
    }
    uint64_t v14 = 0;
    size_t v15 = __s1;
    uint64_t v16 = (const char ***)(v12 + 1);
    do
    {
      if (**v13)
      {
        size_t v17 = strlen(*v13);
        if (!memcmp(v15, *v13, v17)) {
          uint64_t v14 = (int *)v13;
        }
      }
      uint64_t v18 = *v16++;
      rsize_t v13 = v18;
    }
    while (v18);
    if (!v14)
    {
LABEL_63:
      uint64_t v9 = "No supported cipher found";
      goto LABEL_17;
    }
    uint64_t v19 = v14;
    uint64_t v42 = 0;
    uint64_t v43 = 0;
    int v20 = v14[5];
    int v21 = v14[6];
    int v22 = v20 + v21;
    unint64_t v23 = (char *)_libssh2_calloc(a1, v20 + v21);
    if (!v23)
    {
      uint64_t v5 = _libssh2_error(a1, 4294967282, "Could not alloc key");
LABEL_67:
      size_t v28 = 0;
LABEL_68:
      unint64_t v29 = 0;
      goto LABEL_69;
    }
    int v24 = strcmp(v55, "bcrypt");
    if (!a2 || v24)
    {
      BOOL v25 = "bcrypted without passphrase";
      uint64_t v26 = a1;
      uint64_t v27 = 4294967248;
      goto LABEL_66;
    }
    if (_libssh2_get_string(&v57, &v52, &v44) || _libssh2_get_u32(&v57, &v49))
    {
      BOOL v25 = "kdf contains unexpected values";
      uint64_t v26 = a1;
      uint64_t v27 = 4294967282;
LABEL_66:
      uint64_t v5 = _libssh2_error(v26, v27, v25);
      (*(void (**)(char *, uint64_t))(a1 + 24))(v23, a1);
      goto LABEL_67;
    }
    size_t v36 = strlen(a2);
    if ((_libssh2_bcrypt_pbkdf(a2, v36, v52, v44, (uint64_t)v23, v22, v49) & 0x80000000) != 0)
    {
      BOOL v25 = "invalid format";
      uint64_t v26 = a1;
      uint64_t v27 = 4294967284;
      goto LABEL_66;
    }
    unint64_t v41 = v14[4];
    size_t v28 = _libssh2_calloc(a1, v21);
    if (!v28)
    {
      uint64_t v5 = _libssh2_error(a1, 4294967282, "Could not alloc key part");
      goto LABEL_68;
    }
    unint64_t v29 = _libssh2_calloc(a1, v20);
    if (v29)
    {
      memcpy(v28, v23, v21);
      memcpy(v29, &v23[v21], v20);
      if (!(*((unsigned int (**)(uint64_t, int *, void *, char *, void *, uint64_t *, void, uint64_t *))v19
             + 5))(a1, v19, v29, (char *)&v43 + 4, v28, &v43, 0, &v42))
      {
        if (!(v62 % v41))
        {
          size_t v37 = 0;
          size_t v40 = v62 - v41;
          size_t v39 = v60;
          while (1)
          {
            uint64_t v38 = v37 ? 2 * (v40 == v37) : 1;
            if ((*((unsigned int (**)(uint64_t, char *, unint64_t, uint64_t *, uint64_t))v19 + 6))(a1, &v39[v37], v41, &v42, v38))
            {
              break;
            }
            v37 += v41;
            if (v40 < v37)
            {
              (*((void (**)(uint64_t, uint64_t *))v19 + 7))(a1, &v42);
              goto LABEL_55;
            }
          }
        }
        (*((void (**)(uint64_t, uint64_t *))v19 + 7))(a1, &v42);
      }
      uint64_t v5 = 4294967284;
      goto LABEL_69;
    }
    char v33 = "Could not alloc iv part";
    uint64_t v34 = a1;
    uint64_t v35 = 4294967282;
LABEL_76:
    uint64_t v5 = _libssh2_error(v34, v35, v33);
    goto LABEL_69;
  }
  unint64_t v23 = 0;
  size_t v28 = 0;
  unint64_t v29 = 0;
  int v21 = 0;
  int v20 = 0;
  int v22 = 0;
LABEL_55:
  if (_libssh2_get_u32(&v60, &v51) || _libssh2_get_u32(&v60, &v50) || v51 != v50)
  {
    _libssh2_error(a1, 4294967282, "Private key unpack failed (correct password?)");
    uint64_t v5 = 4294967248;
  }
  else if (v5)
  {
    uint64_t v30 = _libssh2_string_buf_new(a1);
    if (v30)
    {
      int v31 = v30;
      int v32 = _libssh2_calloc(a1, v62);
      *int v31 = v32;
      if (v32)
      {
        memcpy(v32, v60, v62);
        v31[1] = *v31 + v61 - v60;
        void v31[2] = v62;
        *(void *)uint64_t v5 = v31;
        uint64_t v5 = 0;
      }
      else
      {
        uint64_t v5 = _libssh2_error(a1, 4294967290, "Unable to allocate memory for decrypted struct");
        _libssh2_string_buf_free(a1, v31);
      }
      goto LABEL_69;
    }
    char v33 = "Unable to allocate memory for decrypted struct";
    uint64_t v34 = a1;
    uint64_t v35 = 4294967290;
    goto LABEL_76;
  }
LABEL_69:
  if (v23)
  {
    memset_s(v23, v22, 0, v22);
    (*(void (**)(char *, uint64_t))(a1 + 24))(v23, a1);
  }
  if (v28)
  {
    memset_s(v28, v21, 0, v21);
    (*(void (**)(void *, uint64_t))(a1 + 24))(v28, a1);
  }
  if (v29)
  {
    memset_s(v29, v20, 0, v20);
    (*(void (**)(void *, uint64_t))(a1 + 24))(v29, a1);
  }
LABEL_18:
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    (*(void (**)(void *, uint64_t))(a1 + 24))(__s, a1);
  }
  return v5;
}

uint64_t _libssh2_openssh_pem_parse_memory(uint64_t a1, const char *a2, uint64_t a3, unint64_t a4, void *a5)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  unint64_t v24 = 0;
  if (a3 && a4)
  {
    do
    {
      __s1[0] = 0;
      if (v24 >= a4)
      {
        uint64_t v18 = "Error parsing PEM: OpenSSH header not found";
        return _libssh2_error(a1, 4294967282, v18);
      }
      readline_memory(__s1, a3, a4, &v24);
    }
    while (strcmp(__s1, "-----BEGIN OPENSSH PRIVATE KEY-----"));
    unint64_t v23 = a5;
    rsize_t v10 = 0;
    rsize_t v11 = 0;
    __s1[0] = 0;
    while (1)
    {
      __s1[0] = 0;
      if (v24 >= a4)
      {
        int v20 = "Error parsing PEM: offset out of bounds";
        uint64_t v21 = a1;
        uint64_t v22 = 4294967282;
LABEL_24:
        uint64_t v19 = _libssh2_error(v21, v22, v20);
        if (!v10) {
          return v19;
        }
LABEL_25:
        memset_s(v10, v11, 0, v11);
        (*(void (**)(void *, uint64_t))(a1 + 24))(v10, a1);
        return v19;
      }
      readline_memory(__s1, a3, a4, &v24);
      if (!strcmp(__s1, "-----END OPENSSH PRIVATE KEY-----")) {
        break;
      }
      if (__s1[0])
      {
        size_t v12 = strlen(__s1);
        size_t v13 = v12;
        rsize_t v14 = v12 + v11;
        if (v10) {
          uint64_t v15 = (*(uint64_t (**)(void *, rsize_t, uint64_t))(a1 + 16))(v10, v14, a1);
        }
        else {
          uint64_t v15 = (*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v12 + v11, a1);
        }
        uint64_t v16 = (void *)v15;
        if (!v15)
        {
          int v20 = "Unable to allocate memory for PEM parsing";
          uint64_t v21 = a1;
          uint64_t v22 = 4294967290;
          goto LABEL_24;
        }
        memcpy((void *)(v15 + v11), __s1, v13);
        rsize_t v10 = v16;
        rsize_t v11 = v14;
      }
    }
    if (v10)
    {
      uint64_t v19 = _libssh2_openssh_pem_parse_data(a1, a2, (unsigned __int8 *)v10, v11, v23);
      goto LABEL_25;
    }
    uint64_t v18 = "Error parsing PEM: base 64 data missing";
    return _libssh2_error(a1, 4294967282, v18);
  }
  else
  {
    return _libssh2_error(a1, 4294967282, "Error parsing PEM: filedata missing");
  }
}

uint64_t _libssh2_pem_decode_sequence(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (!*a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = (unsigned char *)*a1;
  if (*(unsigned char *)*a1 != 48) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v11 = 0;
  unint64_t v6 = v4 + 1;
  *a1 = v4 + 1;
  uint64_t v7 = v2 - 1;
  *a2 = v2 - 1;
  unsigned int v8 = read_asn1_length(v4 + 1, v2 - 1, &v11);
  if ((v8 & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v9 = v8;
  if (v11 + v8 != v7) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  *a1 = &v6[v9];
  *a2 = v7 - v9;
  return result;
}

uint64_t read_asn1_length(unsigned __int8 *a1, unint64_t a2, unint64_t *a3)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  int v3 = (char)*a1;
  unint64_t v4 = *a1;
  *a3 = v4;
  if (v3 < 0)
  {
    unint64_t v7 = v4 & 0x7F;
    unint64_t v4 = a1[1];
    *a3 = v4;
    unsigned int v5 = v7 + 1;
    if (v7 + 1 <= a2)
    {
      if (v7 < 2) {
        goto LABEL_4;
      }
      *a3 = v4 << 8;
      unint64_t v8 = a1[2] | ((unint64_t)v4 << 8);
      *a3 = v8;
      unint64_t v4 = v8;
      if (v7 == 2) {
        goto LABEL_4;
      }
    }
    return 0xFFFFFFFFLL;
  }
  unsigned int v5 = 1;
LABEL_4:
  if (v4 + v5 > a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v5;
  }
}

uint64_t _libssh2_pem_decode_integer(void *a1, uint64_t *a2, void *a3, _DWORD *a4)
{
  uint64_t v4 = *a2;
  if (!*a2) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v6 = (unsigned char *)*a1;
  if (*(unsigned char *)*a1 != 2) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v20 = 0;
  rsize_t v10 = v6 + 1;
  *a1 = v6 + 1;
  unint64_t v11 = v4 - 1;
  *a2 = v4 - 1;
  unsigned int v12 = read_asn1_length(v6 + 1, v4 - 1, &v20);
  if ((v12 & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v13 = v12;
  unint64_t v14 = v20;
  unint64_t v15 = v20 + v12;
  BOOL v16 = v11 >= v15;
  unint64_t v17 = v11 - v15;
  if (!v16) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v19 = &v10[v13];
  *a1 = v19;
  *a3 = v19;
  *a4 = v14;
  *a1 += v14;
  *a2 = v17;
  return result;
}

_DWORD *libssh2_agent_init(uint64_t a1)
{
  uint64_t v2 = _libssh2_calloc(a1, 0x68uLL);
  int v3 = v2;
  if (v2)
  {
    v2[2] = -1;
    *(void *)uint64_t v2 = a1;
    *((void *)v2 + 12) = 0;
    _libssh2_list_init((void *)v2 + 10);
  }
  else
  {
    _libssh2_error(a1, 4294967290, "Unable to allocate space for agent connection");
  }
  return v3;
}

uint64_t libssh2_agent_connect(uint64_t a1)
{
  *(void *)(a1 + 16) = &agent_ops_unix;
  return agent_ops_unix(a1);
}

uint64_t libssh2_agent_list_identities(uint64_t *a1)
{
  *(_OWORD *)(a1 + 3) = 0u;
  uint64_t v2 = (unsigned char **)(a1 + 3);
  *(_OWORD *)(a1 + 7) = 0u;
  *(_OWORD *)(a1 + 5) = 0u;
  agent_free_identities(a1);
  char v32 = 11;
  if (!*((_DWORD *)a1 + 14))
  {
    a1[3] = (uint64_t)&v32;
    a1[4] = 1;
    a1[8] = 0;
    *((_DWORD *)a1 + 14) = 1;
LABEL_7:
    uint64_t v5 = a1[2];
    if (v5)
    {
      uint64_t v6 = (*(uint64_t (**)(uint64_t *, unsigned char **))(v5 + 8))(a1, v2);
      if (v6)
      {
        uint64_t v7 = v6;
        (*(void (**)(uint64_t))(*a1 + 24))(a1[5]);
        a1[5] = 0;
        return v7;
      }
      a1[3] = 0;
      uint64_t v11 = a1[6];
      if (v11 < 1)
      {
LABEL_26:
        uint64_t v12 = 4294967254;
      }
      else
      {
        uint64_t v12 = 4294967254;
        uint64_t v13 = v11 - 5;
        if ((unint64_t)v11 >= 5)
        {
          uint64_t v14 = a1[5];
          if (*(unsigned char *)v14 == 12)
          {
            unsigned int v15 = _libssh2_ntohu32((unsigned int *)(v14 + 1));
            if (v15)
            {
              uint64_t v16 = v15;
              unint64_t v17 = (unsigned int *)(v14 + 5);
              while (1)
              {
                if (v13 < 4) {
                  goto LABEL_26;
                }
                uint64_t v18 = (*(uint64_t (**)(uint64_t))(*a1 + 8))(64);
                if (!v18)
                {
                  uint64_t v12 = 4294967290;
                  goto LABEL_37;
                }
                uint64_t v19 = v18;
                unsigned int v20 = _libssh2_ntohu32(v17);
                *(void *)(v19 + 48) = v20;
                uint64_t v21 = v13 - 4 - v20;
                uint64_t v22 = *a1;
                if (v21 < 0) {
                  break;
                }
                unint64_t v23 = (void *)(*(uint64_t (**)(void))(v22 + 8))();
                *(void *)(v19 + 40) = v23;
                if (!v23)
                {
                  uint64_t v12 = 4294967290;
                  goto LABEL_35;
                }
                memcpy(v23, v17 + 1, *(void *)(v19 + 48));
                BOOL v24 = (unint64_t)v21 >= 4;
                unint64_t v25 = v21 - 4;
                if (!v24)
                {
                  uint64_t v12 = 4294967254;
                  goto LABEL_33;
                }
                uint64_t v26 = (unsigned int *)((char *)v17 + *(void *)(v19 + 48) + 4);
                unsigned int v27 = _libssh2_ntohu32(v26);
                uint64_t v28 = *a1;
                if (v25 < v27)
                {
                  uint64_t v12 = 4294967254;
                  goto LABEL_34;
                }
                size_t v29 = v27;
                uint64_t v30 = (*(uint64_t (**)(uint64_t))(v28 + 8))(v27 + 1);
                *(void *)(v19 + 56) = v30;
                if (!v30)
                {
                  uint64_t v12 = 4294967290;
LABEL_33:
                  uint64_t v28 = *a1;
LABEL_34:
                  (*(void (**)(void))(v28 + 24))(*(void *)(v19 + 40));
LABEL_35:
                  uint64_t v22 = *a1;
LABEL_36:
                  (*(void (**)(uint64_t))(v22 + 24))(v19);
                  goto LABEL_37;
                }
                --v16;
                int v31 = (char *)(v26 + 1);
                uint64_t v13 = v25 - v29;
                *(unsigned char *)(v30 + v29) = 0;
                memcpy(*(void **)(v19 + 56), v31, v29);
                unint64_t v17 = (unsigned int *)&v31[v29];
                _libssh2_list_add((void **)a1 + 10, (void *)v19);
                uint64_t v12 = 0;
                if (!v16) {
                  goto LABEL_37;
                }
              }
              uint64_t v12 = 4294967254;
              goto LABEL_36;
            }
            uint64_t v12 = 0;
          }
        }
      }
LABEL_37:
      (*(void (**)(uint64_t))(*a1 + 24))(a1[5]);
      a1[5] = 0;
      uint64_t v8 = *a1;
      unsigned int v9 = "agent list id failed";
      uint64_t v10 = v12;
    }
    else
    {
      uint64_t v8 = *a1;
      unsigned int v9 = "agent not connected";
      uint64_t v10 = 4294967257;
    }
    return _libssh2_error(v8, v10, v9);
  }
  if (**v2 == 11) {
    goto LABEL_7;
  }
  uint64_t v3 = *a1;
  return _libssh2_error(v3, 4294967257, "illegal agent request");
}

void *agent_free_identities(void *a1)
{
  uint64_t v2 = a1 + 10;
  uint64_t v3 = _libssh2_list_first((uint64_t)(a1 + 10));
  if (v3)
  {
    uint64_t v4 = v3;
    do
    {
      uint64_t v5 = _libssh2_list_next(v4);
      (*(void (**)(void))(*a1 + 24))(*(void *)(v4 + 40));
      (*(void (**)(void))(*a1 + 24))(*(void *)(v4 + 56));
      (*(void (**)(uint64_t))(*a1 + 24))(v4);
      uint64_t v4 = v5;
    }
    while (v5);
  }
  return _libssh2_list_init(v2);
}

uint64_t libssh2_agent_get_identity(uint64_t a1, void *a2, uint64_t a3)
{
  if (a3 && *(void *)(a3 + 8)) {
    uint64_t v4 = _libssh2_list_next(*(void *)(a3 + 8));
  }
  else {
    uint64_t v4 = _libssh2_list_first(a1 + 80);
  }
  uint64_t v5 = v4;
  if (!v4) {
    return 1;
  }
  uint64_t result = 0;
  *(_DWORD *)(v5 + 24) = 1004469970;
  *(void *)(v5 + 32) = v5;
  *a2 = v5 + 24;
  return result;
}

uint64_t libssh2_agent_userauth(uint64_t *a1, const char *a2, uint64_t a3)
{
  unsigned int v9 = a1;
  if (!*(_DWORD *)(*a1 + 72216))
  {
    *(_OWORD *)(a1 + 7) = 0u;
    *(_OWORD *)(a1 + 5) = 0u;
    *(_OWORD *)(a1 + 3) = 0u;
    a1[9] = *(void *)(a3 + 8);
  }
  time_t v6 = time(0);
  do
  {
    size_t v7 = strlen(a2);
    uint64_t result = _libssh2_userauth_publickey(*a1, a2, v7, *(unsigned int **)(a3 + 16), *(void *)(a3 + 24), (uint64_t (*)(uint64_t, const void **, size_t *, char *, int64_t, uint64_t))agent_sign, (uint64_t)&v9);
    if (result != -37) {
      break;
    }
    if (!*(_DWORD *)(*a1 + 172)) {
      return 4294967259;
    }
    uint64_t result = _libssh2_wait_socket(*a1, v6);
  }
  while (!result);
  return result;
}

uint64_t agent_sign(uint64_t a1, void *a2, size_t *a3, const void *a4, unint64_t a5, uint64_t *a6)
{
  uint64_t v9 = a1 + 72256;
  uint64_t v10 = *a6;
  uint64_t v11 = (unsigned char **)(*a6 + 24);
  uint64_t v12 = *(void *)(*a6 + 72);
  uint64_t v13 = *(void *)(v12 + 48);
  char __src = 0;
  if (*(_DWORD *)(v10 + 56))
  {
    uint64_t v14 = *v11;
    goto LABEL_27;
  }
  unint64_t v17 = (unsigned char *)(*(uint64_t (**)(unint64_t, uint64_t))(a1 + 8))(a5 + v13 + 13, a1);
  *uint64_t v11 = v17;
  if (v17)
  {
    char __src = v17 + 1;
    *unint64_t v17 = 13;
    _libssh2_store_str((_DWORD **)&__src, *(const void **)(v12 + 40), *(void *)(v12 + 48));
    _libssh2_store_str((_DWORD **)&__src, a4, a5);
    uint64_t v18 = *(void *)(v9 + 8);
    if (!v18 || ((uint64_t v19 = *(char **)v9, v18 == 12) ? (v20 = v19 == 0) : (v20 = 1), v20))
    {
      unsigned int v21 = 0;
    }
    else if (*(void *)v19 == 0x326168732D617372 && *((_DWORD *)v19 + 2) == 842085677)
    {
      unsigned int v21 = 4;
    }
    else
    {
      uint64_t v24 = *(void *)v19;
      int v25 = *((_DWORD *)v19 + 2);
      BOOL v27 = v24 == 0x326168732D617372 && v25 == 909455917;
      unsigned int v21 = 2 * v27;
    }
    _libssh2_store_u32((_DWORD **)&__src, v21);
    uint64_t v14 = *(unsigned char **)(v10 + 24);
    *(void *)(v10 + 32) = (unsigned char *)__src - v14;
    *(void *)(v10 + 64) = 0;
    *(_DWORD *)(v10 + 56) = 1;
LABEL_27:
    if (*v14 == 13)
    {
      uint64_t v28 = *(void *)(v10 + 16);
      if (v28)
      {
        uint64_t v29 = (*(uint64_t (**)(uint64_t, unsigned char **))(v28 + 8))(v10, v11);
        if (!v29)
        {
          (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v10 + 24), a1);
          *(void *)(v10 + 24) = 0;
          uint64_t v30 = *(unsigned char **)(v10 + 40);
          uint64_t v31 = *(void *)(v10 + 48);
          char __src = v30;
          if (v31 >= 1
            && *v30 == 14
            && (char __src = v30 + 1, (unint64_t)v31 >= 5)
            && (char __src = v30 + 5, (unint64_t)v31 >= 9)
            && (unsigned int v32 = _libssh2_ntohu32((unsigned int *)(v30 + 5)),
                char __src = (char *)__src + 4,
                uint64_t v33 = v31 - v32 - 9,
                v33 >= 0))
          {
            size_t v34 = v32;
            uint64_t v35 = (void *)(*(uint64_t (**)(void, uint64_t))(a1 + 8))(v32, a1);
            if (v35)
            {
              size_t v36 = v35;
              memcpy(v35, __src, v34);
              char __src = (char *)__src + v34;
              size_t v37 = plain_method(*(char **)v9, *(void *)(v9 + 8));
              if ((*(void *)(v9 + 8) == v34 || v37 == v34) && !memcmp(v36, *(const void **)v9, v34))
              {
                if ((unint64_t)v33 >= 4
                  && (unsigned int v41 = _libssh2_ntohu32((unsigned int *)__src),
                      *a3 = v41,
                      char __src = (char *)__src + 4,
                      v33 - 4 >= (unint64_t)v41))
                {
                  uint64_t v42 = (void *)(*(uint64_t (**)(void))(a1 + 8))();
                  *a2 = v42;
                  if (v42)
                  {
                    memcpy(v42, __src, *a3);
                    uint64_t v29 = 0;
                  }
                  else
                  {
                    uint64_t v29 = 4294967290;
                  }
                }
                else
                {
                  uint64_t v29 = 4294967254;
                }
              }
              else
              {
                uint64_t v29 = 4294967245;
              }
              (*(void (**)(const void *, uint64_t))(a1 + 24))(v36, a1);
            }
            else
            {
              uint64_t v29 = 4294967290;
            }
          }
          else
          {
            uint64_t v29 = 4294967254;
          }
        }
        (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v10 + 24), a1);
        *(void *)(v10 + 24) = 0;
        (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v10 + 40), a1);
        *(void *)(v10 + 40) = 0;
        *(_DWORD *)(v10 + 56) = 0;
        uint64_t v38 = "agent sign failure";
        uint64_t v39 = a1;
        uint64_t v40 = v29;
        return _libssh2_error(v39, v40, v38);
      }
      uint64_t v38 = "agent not connected";
    }
    else
    {
      uint64_t v38 = "illegal request";
    }
    uint64_t v39 = a1;
    uint64_t v40 = 4294967257;
    return _libssh2_error(v39, v40, v38);
  }
  return _libssh2_error(a1, 4294967290, "out of memory");
}

uint64_t libssh2_agent_sign(uint64_t *a1, uint64_t a2, void *a3, size_t *a4, const void *a5, unint64_t a6, const void *a7, unsigned int a8)
{
  unint64_t v23 = a1;
  if (!*(_DWORD *)(*a1 + 72216))
  {
    *(_OWORD *)(a1 + 7) = 0u;
    *(_OWORD *)(a1 + 5) = 0u;
    *(_OWORD *)(a1 + 3) = 0u;
    a1[9] = *(void *)(a2 + 8);
  }
  if (*(void *)(a2 + 24) < 4uLL) {
    return 4294967258;
  }
  unsigned int v16 = _libssh2_ntohu32(*(unsigned int **)(a2 + 16));
  unint64_t v17 = *(void *)(a2 + 24);
  size_t v18 = v16;
  if (v17 < (unint64_t)v16 + 4) {
    return 4294967258;
  }
  uint64_t v20 = *a1;
  *(void *)(v20 + 72264) = a8;
  unsigned int v21 = (void *)(*(uint64_t (**)(void))(v20 + 8))();
  *(void *)(*a1 + 72256) = v21;
  memcpy(v21, a7, v18);
  uint64_t v19 = agent_sign(*a1, a3, a4, a5, a6, (uint64_t *)&v23);
  (*(void (**)(void))(*a1 + 24))(*(void *)(*a1 + 72256));
  *(_OWORD *)(*a1 + 72256) = 0u;
  return v19;
}

uint64_t libssh2_agent_disconnect(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1 || *(_DWORD *)(a1 + 8) == -1) {
    return 0;
  }
  else {
    return (*(uint64_t (**)(void))(v1 + 16))();
  }
}

uint64_t libssh2_agent_free(void *a1)
{
  if (*((_DWORD *)a1 + 2) != -1)
  {
    uint64_t v2 = a1[2];
    if (v2) {
      (*(void (**)(void *))(v2 + 16))(a1);
    }
  }
  if (a1[12]) {
    (*(void (**)(void))(*a1 + 24))();
  }
  agent_free_identities(a1);
  uint64_t v3 = *(uint64_t (**)(void *))(*a1 + 24);
  return v3(a1);
}

unint64_t libssh2_agent_set_identity_path(void *a1, char *__s)
{
  unint64_t result = a1[12];
  if (result)
  {
    unint64_t result = (*(uint64_t (**)(void))(*a1 + 24))();
    a1[12] = 0;
  }
  if (__s)
  {
    unint64_t result = strlen(__s);
    if (result <= 0xFFFFFFFFFFFFFFFDLL)
    {
      size_t v5 = result;
      time_t v6 = (void *)(*(uint64_t (**)(unint64_t))(*a1 + 8))(result + 1);
      unint64_t result = (unint64_t)memcpy(v6, __s, v5);
      *((unsigned char *)v6 + v5) = 0;
      a1[12] = v6;
    }
  }
  return result;
}

uint64_t libssh2_agent_get_identity_path(uint64_t a1)
{
  return *(void *)(a1 + 96);
}

uint64_t agent_connect_unix(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(char **)(a1 + 96);
  if (v2 || (uint64_t v2 = getenv("SSH_AUTH_SOCK")) != 0)
  {
    int v3 = socket(1, 1, 0);
    *(_DWORD *)(a1 + 8) = v3;
    if ((v3 & 0x80000000) == 0)
    {
      int v4 = v3;
      *(_WORD *)&v9.sa_len = 256;
      strncpy(v9.sa_data, v2, 0x68uLL);
      char v10 = 0;
      uint64_t result = connect(v4, &v9, 0x6Au);
      if (result)
      {
        close(*(_DWORD *)(a1 + 8));
        return _libssh2_error(*(void *)a1, 4294967254, "failed connecting with agent");
      }
      return result;
    }
    uint64_t v6 = *(void *)a1;
    size_t v7 = "failed creating socket";
    uint64_t v8 = 4294967251;
  }
  else
  {
    uint64_t v6 = *(void *)a1;
    size_t v7 = "no auth sock variable";
    uint64_t v8 = 4294967257;
  }
  return _libssh2_error(v6, v8, v7);
}

uint64_t agent_transact_unix(unsigned int *a1, uint64_t *a2)
{
  switch(*((_DWORD *)a2 + 8))
  {
    case 1:
      _libssh2_htonu32(&v33, *((_DWORD *)a2 + 2));
      unint64_t v4 = 0;
      uint64_t v5 = *(void *)a1;
      uint64_t v6 = *(uint64_t (**)(uint64_t, char *, unint64_t, void, uint64_t))(*(void *)a1 + 96);
      uint64_t v7 = a1[2];
      do
      {
        if (v4 > 3) {
          goto LABEL_6;
        }
        uint64_t v8 = v6(v7, (char *)&v33 + v4, 4 - v4, 0, v5);
        v4 += v8;
      }
      while ((v8 & 0x8000000000000000) == 0);
      LODWORD(v4) = v8;
LABEL_6:
      if (v4 == -35) {
        return 4294967259;
      }
      if ((v4 & 0x80000000) == 0)
      {
        *((_DWORD *)a2 + 8) = 2;
        goto LABEL_9;
      }
      goto LABEL_35;
    case 2:
LABEL_9:
      unint64_t v9 = 0;
      uint64_t v10 = *(void *)a1;
      uint64_t v11 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t, void, uint64_t))(*(void *)a1 + 96);
      uint64_t v12 = a1[2];
      uint64_t v13 = *a2;
      unint64_t v14 = a2[1];
      break;
    case 3:
      goto LABEL_16;
    case 4:
      uint64_t v22 = a2[2];
      goto LABEL_25;
    default:
      return 0;
  }
  while (v14 > v9)
  {
    uint64_t v15 = v11(v12, v13 + v9, v14 - v9, 0, v10);
    v9 += v15;
    if (v15 < 0)
    {
      LODWORD(v9) = v15;
      break;
    }
  }
  if (v9 == -35) {
    return 4294967259;
  }
  if ((v9 & 0x80000000) != 0)
  {
LABEL_35:
    uint64_t v30 = *(void *)a1;
    uint64_t v31 = "agent send failed";
    goto LABEL_36;
  }
  *((_DWORD *)a2 + 8) = 3;
LABEL_16:
  unint64_t v16 = 0;
  uint64_t v17 = *(void *)a1;
  size_t v18 = *(uint64_t (**)(uint64_t, char *, unint64_t, void, uint64_t))(*(void *)a1 + 104);
  uint64_t v19 = a1[2];
  while (v16 <= 3)
  {
    uint64_t v20 = v18(v19, (char *)&v33 + v16, 4 - v16, 0, v17);
    v16 += v20;
    if (v20 < 0)
    {
      LODWORD(v16) = v20;
      break;
    }
  }
  if ((v16 & 0x80000000) != 0)
  {
    if (v16 != -35)
    {
      uint64_t v30 = *(void *)a1;
      uint64_t v31 = "agent recv failed";
      uint64_t v32 = 4294967253;
      return _libssh2_error(v30, v32, v31);
    }
    return 4294967259;
  }
  a2[3] = _libssh2_ntohu32(&v33);
  uint64_t v21 = (*(uint64_t (**)(void))(*(void *)a1 + 8))();
  a2[2] = v21;
  if (!v21) {
    return 4294967290;
  }
  uint64_t v22 = v21;
  *((_DWORD *)a2 + 8) = 4;
LABEL_25:
  unint64_t v24 = 0;
  uint64_t v25 = *(void *)a1;
  uint64_t v26 = *(uint64_t (**)(uint64_t, unint64_t, unint64_t, void, uint64_t))(*(void *)a1 + 104);
  uint64_t v27 = a1[2];
  unint64_t v28 = a2[3];
  while (v28 > v24)
  {
    uint64_t v29 = v26(v27, v22 + v24, v28 - v24, 0, v25);
    v24 += v29;
    if (v29 < 0)
    {
      LODWORD(v24) = v29;
      break;
    }
  }
  if ((v24 & 0x80000000) == 0)
  {
    uint64_t result = 0;
    *((_DWORD *)a2 + 8) = 5;
    return result;
  }
  if (v24 == -35) {
    return 4294967259;
  }
  uint64_t v30 = *(void *)a1;
  uint64_t v31 = "agent recv failed";
LABEL_36:
  uint64_t v32 = 4294967289;
  return _libssh2_error(v30, v32, v31);
}

uint64_t agent_disconnect_unix(uint64_t a1)
{
  if (close(*(_DWORD *)(a1 + 8)) == -1)
  {
    uint64_t v3 = *(void *)a1;
    return _libssh2_error(v3, 4294967283, "failed closing the agent socket");
  }
  else
  {
    *(_DWORD *)(a1 + 8) = -1;
    return 0;
  }
}

char ***libssh2_crypt_methods()
{
  return _libssh2_crypt_methods;
}

uint64_t crypt_init(uint64_t a1, uint64_t a2, unsigned __int8 *a3, _DWORD *a4, const unsigned __int8 *a5, _DWORD *a6, int a7, uint64_t *a8)
{
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(24, a1);
  if (!v16) {
    return 4294967290;
  }
  uint64_t v17 = v16;
  *(_DWORD *)uint64_t v16 = a7;
  size_t v18 = *(uint64_t (**)(void))(a2 + 64);
  *(void *)(v16 + 8) = v18;
  uint64_t result = _libssh2_cipher_init((EVP_CIPHER_CTX **)(v16 + 16), v18, a3, a5, a7);
  if (result)
  {
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v17, a1);
    return 0xFFFFFFFFLL;
  }
  else
  {
    *a8 = v17;
    *a4 = 1;
    *a6 = 1;
  }
  return result;
}

uint64_t crypt_encrypt(uint64_t a1, const unsigned __int8 *a2, unint64_t a3, int **a4, int a5)
{
  return _libssh2_cipher_crypt((EVP_CIPHER_CTX **)*a4 + 2, *((void *(**)())*a4 + 1), **a4, a2, a3, a5);
}

uint64_t crypt_dtor(uint64_t a1, void *a2)
{
  if (a2 && *a2)
  {
    EVP_CIPHER_CTX_free(*(EVP_CIPHER_CTX **)(*a2 + 16));
    (*(void (**)(void, uint64_t))(a1 + 24))(*a2, a1);
    *a2 = 0;
  }
  return 0;
}

uint64_t crypt_init_arcfour128(uint64_t a1, uint64_t a2, unsigned __int8 *a3, _DWORD *a4, const unsigned __int8 *a5, _DWORD *a6, int a7, uint64_t *a8)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v10 = crypt_init(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!v10)
  {
    uint64_t v11 = *a8;
    uint64_t v12 = (EVP_CIPHER_CTX **)(*a8 + 16);
    uint64_t v13 = -1536;
    do
    {
      _libssh2_cipher_crypt(v12, *(void *(**)())(v11 + 8), *(_DWORD *)v11, v15, *(int *)(a2 + 16), 0);
      v13 += 8;
    }
    while (v13);
  }
  return v10;
}

double libssh2_scp_recv(uint64_t a1, char *a2, uint64_t a3)
{
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  if (a3) {
    uint64_t v6 = v13;
  }
  else {
    uint64_t v6 = 0;
  }
  long long v15 = 0uLL;
  long long v16 = 0uLL;
  long long v14 = 0uLL;
  memset(v13, 0, sizeof(v13));
  time_t v7 = time(0);
  do
  {
    uint64_t v8 = scp_recv(a1, a2, (uint64_t)v6);
    if (*(_DWORD *)(a1 + 172)) {
      BOOL v10 = v8 == 0;
    }
    else {
      BOOL v10 = 0;
    }
  }
  while (v10 && libssh2_session_last_errno(a1) == -37 && !_libssh2_wait_socket(a1, v7));
  if (a3)
  {
    double result = 0.0;
    uint64_t v11 = v15;
    uint64_t v12 = v14;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(void *)(a3 + 48) = v11;
    *(_OWORD *)(a3 + 112) = 0u;
    *(_OWORD *)(a3 + 128) = 0u;
    *(_OWORD *)(a3 + 80) = 0u;
    *(_OWORD *)(a3 + 96) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(void *)(a3 + 32) = v12;
    *(void *)(a3 + 96) = v18;
    *(_WORD *)(a3 + 4) = WORD2(v13[0]);
  }
  return result;
}

uint64_t scp_recv(uint64_t a1, char *__s, uint64_t a3)
{
  uint64_t v5 = a1 + 72936;
  int v6 = *(_DWORD *)(a1 + 72936);
  switch(v6)
  {
    case 0:
      *(_OWORD *)(a1 + 73224) = 0u;
      *(_OWORD *)(a1 + 73240) = 0u;
      size_t v8 = 3 * strlen(__s);
      uint64_t v9 = 10;
      if (a3) {
        uint64_t v9 = 11;
      }
      *(void *)(v5 + 16) = v9 + v8;
      BOOL v10 = (char *)(*(uint64_t (**)(void))(a1 + 8))();
      *(void *)(v5 + 8) = v10;
      if (!v10)
      {
        long long v17 = "Unable to allocate a command buffer for SCP session";
        uint64_t v18 = a1;
        uint64_t v19 = 4294967290;
        goto LABEL_30;
      }
      uint64_t v11 = "p";
      if (!a3) {
        uint64_t v11 = "";
      }
      snprintf(v10, *(void *)(v5 + 16), "scp -%sf ", v11);
      uint64_t v12 = *(const char **)(v5 + 8);
      size_t v13 = strlen(v12);
      size_t v14 = v13;
      if (*(_DWORD *)(a1 + 140))
      {
        size_t v15 = (size_t)shell_quotearg(__s, &v12[v13], *(void *)(v5 + 16) - v13);
      }
      else
      {
        size_t v15 = strlen(__s);
        memcpy((void *)&v12[v14], __s, v15);
      }
      *(void *)(v5 + 16) = v15 + v14;
      *(_DWORD *)uint64_t v5 = 2;
      goto LABEL_17;
    case 2:
LABEL_17:
      uint64_t v16 = _libssh2_channel_open(a1, "session", 7u, 0x200000u, 0x8000u, 0, 0);
      *(void *)(v5 + 320) = v16;
      if (!v16)
      {
        if (libssh2_session_last_errno(a1) == -37)
        {
          long long v17 = "Would block starting up channel";
          goto LABEL_29;
        }
        (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v5 + 8), a1);
        uint64_t result = 0;
        *(void *)(v5 + 8) = 0;
LABEL_135:
        *(_DWORD *)uint64_t v5 = 0;
        return result;
      }
      *(_DWORD *)uint64_t v5 = 3;
LABEL_19:
      int v20 = _libssh2_channel_process_startup(v16, "exec", 4uLL, *(const void **)(v5 + 8), *(void *)(v5 + 16));
      if (v20)
      {
        if (v20 == -37)
        {
          long long v17 = "Would block requesting SCP startup";
          goto LABEL_29;
        }
        (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v5 + 8), a1);
        *(void *)(v5 + 8) = 0;
LABEL_132:
        int v57 = *(_DWORD *)(a1 + 616);
        uint64_t v58 = *(void *)(a1 + 608);
        while (libssh2_channel_free(*(void *)(v5 + 320)) == -37)
          ;
        uint64_t result = 0;
        *(_DWORD *)(a1 + 616) = v57;
        *(void *)(a1 + 608) = v58;
        *(void *)(v5 + 320) = 0;
        goto LABEL_135;
      }
      (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v5 + 8), a1);
      *(void *)(v5 + 8) = 0;
      *(unsigned char *)(v5 + 24) = 0;
      *(_DWORD *)uint64_t v5 = 4;
LABEL_23:
      int v21 = _libssh2_channel_write(*(void *)(v5 + 320), 0, (const void *)(a1 + 72960), 1uLL);
      if (v21 != 1)
      {
        if (v21 == -37)
        {
          long long v17 = "Would block sending initial wakeup";
          goto LABEL_29;
        }
        goto LABEL_132;
      }
      *(void *)(v5 + 280) = 0;
      *(_DWORD *)uint64_t v5 = 5;
LABEL_32:
      if (!a3) {
        goto LABEL_51;
      }
      unint64_t v23 = *(void *)(v5 + 280);
      if (v23 > 0xFF) {
        goto LABEL_51;
      }
      break;
    case 3:
      uint64_t v16 = *(void *)(a1 + 73256);
      goto LABEL_19;
    case 4:
      goto LABEL_23;
    default:
      if ((v6 - 5) <= 1) {
        goto LABEL_32;
      }
      if (v6 == 7) {
        goto LABEL_51;
      }
      if ((v6 & 0xFFFFFFFE) != 8) {
        goto LABEL_74;
      }
      goto LABEL_52;
  }
  while (1)
  {
    if (*(_DWORD *)v5 != 5)
    {
      if (*(_DWORD *)v5 == 6) {
        goto LABEL_118;
      }
      goto LABEL_50;
    }
    unint64_t v24 = _libssh2_channel_read(*(void *)(v5 + 320), 0, v5 + 24 + v23, 1uLL);
    uint64_t v19 = v24;
    if (v24 == -37)
    {
      long long v17 = "Would block waiting for SCP response";
      uint64_t v18 = a1;
      goto LABEL_30;
    }
    if ((v24 & 0x80000000) != 0)
    {
LABEL_79:
      size_t v37 = "Failed reading SCP response";
      uint64_t v38 = a1;
      goto LABEL_131;
    }
    if (!v24)
    {
LABEL_80:
      if (libssh2_channel_eof(*(void *)(v5 + 320)))
      {
        size_t v37 = "Unexpected channel close";
        goto LABEL_130;
      }
      return *(void *)(v5 + 320);
    }
    uint64_t v25 = *(void *)(v5 + 280);
    unint64_t v23 = v25 + 1;
    *(void *)(v5 + 280) = v25 + 1;
    if (*(unsigned char *)(v5 + 24) != 84)
    {
      unint64_t v39 = _libssh2_channel_packet_data_len(*(void *)(v5 + 320), 0);
      uint64_t v40 = (*(uint64_t (**)(unint64_t, uint64_t))(a1 + 8))(v39 + 1, a1);
      if (v40)
      {
        uint64_t v41 = v40;
        _libssh2_channel_read(*(void *)(v5 + 320), 0, v40, v39);
        *(unsigned char *)(v41 + v39) = 0;
        _libssh2_error(a1, 4294967268, "Failed to recv file");
        (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v41, a1);
        goto LABEL_132;
      }
      size_t v37 = "Failed to get memory ";
      uint64_t v38 = a1;
      uint64_t v19 = 4294967290;
LABEL_131:
      _libssh2_error(v38, v19, v37);
      goto LABEL_132;
    }
    if (v23 >= 2)
    {
      unsigned int v26 = *(unsigned __int8 *)(a1 + v25 + 72960);
      if (v26 - 58 <= 0xFFFFFFF5 && (v26 > 0x20 || ((1 << v26) & 0x100002400) == 0))
      {
LABEL_101:
        size_t v37 = "Invalid data in SCP response";
        goto LABEL_130;
      }
      if (v23 >= 9) {
        break;
      }
    }
LABEL_50:
    if (v23 >= 0x100) {
      goto LABEL_51;
    }
  }
  if (v26 != 10)
  {
    if (v25 == 255)
    {
LABEL_86:
      size_t v37 = "Unterminated response from SCP server";
      goto LABEL_130;
    }
    goto LABEL_50;
  }
  for (unint64_t i = (unsigned char *)(a1 + v25 + 72961); ; --i)
  {
    int v48 = *(i - 1);
    if (v48 != 13 && v48 != 10) {
      break;
    }
    *(void *)(v5 + 280) = v25--;
  }
  *unint64_t i = 0;
  if (*(void *)(v5 + 280) <= 7uLL) {
    goto LABEL_110;
  }
  int v50 = strchr((char *)(a1 + 72961), 32);
  if (!v50 || (uint64_t)&v50[-a1 - 72961] <= 0)
  {
    size_t v37 = "Invalid response from SCP server, malformed mtime";
LABEL_130:
    uint64_t v38 = a1;
    uint64_t v19 = 4294967268;
    goto LABEL_131;
  }
  *int v50 = 0;
  uint64_t v51 = v50 + 1;
  *(void *)(v5 + 304) = strtol((const char *)(a1 + 72961), 0, 10);
  int v52 = strchr(v51, 32);
  if (!v52 || v52 - v51 <= 0)
  {
    size_t v37 = "Invalid response from SCP server, malformed mtime.usec";
    goto LABEL_130;
  }
  uint64_t v53 = v52 + 1;
  uint64_t v54 = strchr(v52 + 1, 32);
  if (!v54 || v54 - v53 <= 0) {
    goto LABEL_128;
  }
  char *v54 = 0;
  *(void *)(v5 + 312) = strtol(v53, 0, 10);
  *(unsigned char *)(v5 + 24) = 0;
  *(_DWORD *)uint64_t v5 = 6;
LABEL_118:
  int v55 = _libssh2_channel_write(*(void *)(v5 + 320), 0, (const void *)(v5 + 24), 1uLL);
  if (v55 != 1)
  {
    if (v55 != -37) {
      goto LABEL_132;
    }
    long long v17 = "Would block waiting to send SCP ACK";
LABEL_29:
    uint64_t v18 = a1;
    uint64_t v19 = 4294967259;
LABEL_30:
    _libssh2_error(v18, v19, v17);
    return 0;
  }
LABEL_51:
  *(void *)(v5 + 280) = 0;
  *(_DWORD *)uint64_t v5 = 8;
LABEL_52:
  unint64_t v28 = *(void *)(v5 + 280);
  if (v28 > 0xFF) {
    goto LABEL_74;
  }
  uint64_t v29 = "Would block waiting for SCP response";
  while (2)
  {
    __endptr = 0;
    if (*(_DWORD *)v5 != 8)
    {
      if (*(_DWORD *)v5 == 9) {
        goto LABEL_137;
      }
      goto LABEL_73;
    }
    unint64_t v30 = _libssh2_channel_read(*(void *)(v5 + 320), 0, v5 + 24 + v28, 1uLL);
    uint64_t v19 = v30;
    if (v30 == -37) {
      goto LABEL_141;
    }
    if ((v30 & 0x80000000) != 0) {
      goto LABEL_79;
    }
    if (!v30) {
      goto LABEL_80;
    }
    uint64_t v31 = *(void *)(v5 + 280);
    unint64_t v28 = v31 + 1;
    *(void *)(v5 + 280) = v31 + 1;
    if (*(unsigned char *)(v5 + 24) != 67)
    {
      size_t v37 = "Invalid response from SCP server";
      goto LABEL_130;
    }
    if (v28 < 2) {
      goto LABEL_73;
    }
    unsigned int v32 = *(unsigned __int8 *)(a1 + v31 + 72960);
    if (v32 != 10 && v32 != 13 && v32 <= 0x1F) {
      goto LABEL_101;
    }
    if (v28 < 7) {
      goto LABEL_73;
    }
    if (v32 != 10)
    {
      if (v31 == 255) {
        goto LABEL_86;
      }
LABEL_73:
      if (v28 >= 0x100) {
        goto LABEL_74;
      }
      continue;
    }
    break;
  }
  for (int j = (unsigned char *)(a1 + v31 + 72961); ; --j)
  {
    int v43 = *(j - 1);
    if (v43 != 13 && v43 != 10) {
      break;
    }
    *(void *)(v5 + 280) = v31--;
  }
  *int j = 0;
  if (*(void *)(v5 + 280) <= 5uLL)
  {
LABEL_110:
    size_t v37 = "Invalid response from SCP server, too short";
    goto LABEL_130;
  }
  size_t v45 = strchr((char *)(a1 + 72961), 32);
  if (!v45 || (uint64_t)&v45[-a1 - 72961] <= 0)
  {
    size_t v37 = "Invalid response from SCP server, malformed mode";
    goto LABEL_130;
  }
  char *v45 = 0;
  uint64_t v46 = v45 + 1;
  *(void *)(v5 + 288) = strtol((const char *)(a1 + 72961), &__endptr, 8);
  if (__endptr && *__endptr)
  {
    size_t v37 = "Invalid response from SCP server, invalid mode";
    goto LABEL_130;
  }
  uint64_t v56 = strchr(v46, 32);
  if (!v56 || v56 - v46 <= 0)
  {
LABEL_128:
    size_t v37 = "Invalid response from SCP server, too short or malformed";
    goto LABEL_130;
  }
  char *v56 = 0;
  *(void *)(v5 + 296) = strtoll(v46, &__endptr, 10);
  if (__endptr && *__endptr)
  {
    size_t v37 = "Invalid response from SCP server, invalid size";
    goto LABEL_130;
  }
  *(unsigned char *)(v5 + 24) = 0;
  *(_DWORD *)uint64_t v5 = 9;
LABEL_137:
  int v59 = _libssh2_channel_write(*(void *)(v5 + 320), 0, (const void *)(v5 + 24), 1uLL);
  if (v59 == -37)
  {
    uint64_t v29 = "Would block sending SCP ACK";
LABEL_141:
    uint64_t v18 = a1;
    uint64_t v19 = 4294967259;
    long long v17 = (char *)v29;
    goto LABEL_30;
  }
  if (v59 != 1) {
    goto LABEL_132;
  }
LABEL_74:
  if (a3)
  {
    *(_OWORD *)(a3 + 112) = 0u;
    *(_OWORD *)(a3 + 128) = 0u;
    *(_OWORD *)(a3 + 80) = 0u;
    *(_OWORD *)(a3 + 96) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
    uint64_t v35 = *(void *)(v5 + 312);
    *(void *)(a3 + 48) = *(void *)(v5 + 304);
    *(void *)(a3 + 32) = v35;
    uint64_t v36 = *(void *)(v5 + 288);
    *(void *)(a3 + 96) = *(void *)(v5 + 296);
    *(_WORD *)(a3 + 4) = v36;
  }
  *(_DWORD *)uint64_t v5 = 0;
  return *(void *)(v5 + 320);
}

uint64_t libssh2_scp_recv2(uint64_t a1, char *a2, uint64_t a3)
{
  time_t v6 = time(0);
  while (1)
  {
    uint64_t result = scp_recv(a1, a2, a3);
    if (!*(_DWORD *)(a1 + 172) || result != 0) {
      break;
    }
    if (libssh2_session_last_errno(a1) != -37 || _libssh2_wait_socket(a1, v6)) {
      return 0;
    }
  }
  return result;
}

uint64_t libssh2_scp_send_ex(uint64_t a1, char *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  time_t v12 = time(0);
  while (1)
  {
    uint64_t result = scp_send(a1, a2, a3, a4, a5, a6);
    if (!*(_DWORD *)(a1 + 172) || result != 0) {
      break;
    }
    if (libssh2_session_last_errno(a1) != -37 || _libssh2_wait_socket(a1, v12)) {
      return 0;
    }
  }
  return result;
}

uint64_t scp_send(uint64_t a1, char *__s, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = a1 + 73264;
  int v13 = *(_DWORD *)(a1 + 73264);
  switch(v13)
  {
    case 0:
      size_t v14 = 3 * strlen(__s);
      uint64_t v15 = 10;
      if (a6 | a5) {
        uint64_t v15 = 11;
      }
      *(void *)(v12 + 16) = v15 + v14;
      uint64_t v16 = (char *)(*(uint64_t (**)(void))(a1 + 8))();
      *(void *)(v12 + 8) = v16;
      if (!v16)
      {
        unint64_t v23 = "Unable to allocate a command buffer for SCP session";
        uint64_t v24 = a1;
        uint64_t v25 = 4294967290;
LABEL_58:
        _libssh2_error(v24, v25, v23);
        return 0;
      }
      long long v17 = "p";
      if (!(a6 | a5)) {
        long long v17 = "";
      }
      snprintf(v16, *(void *)(v12 + 16), "scp -%st ", v17);
      uint64_t v18 = *(const char **)(v12 + 8);
      size_t v19 = strlen(v18);
      size_t v20 = v19;
      if (*(_DWORD *)(a1 + 140))
      {
        size_t v21 = (size_t)shell_quotearg(__s, &v18[v19], *(void *)(v12 + 16) - v19);
      }
      else
      {
        size_t v21 = strlen(__s);
        memcpy((void *)&v18[v20], __s, v21);
      }
      *(void *)(v12 + 16) = v21 + v20;
      *(_DWORD *)uint64_t v12 = 2;
LABEL_17:
      uint64_t v22 = _libssh2_channel_open(a1, "session", 7u, 0x200000u, 0x8000u, 0, 0);
      *(void *)(v12 + 288) = v22;
      if (!v22)
      {
        if (libssh2_session_last_errno(a1) == -37)
        {
          unint64_t v23 = "Would block starting up channel";
          goto LABEL_57;
        }
        (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v12 + 8), a1);
        uint64_t result = 0;
        *(void *)(v12 + 8) = 0;
        goto LABEL_73;
      }
      *(_DWORD *)uint64_t v12 = 3;
LABEL_19:
      int v27 = _libssh2_channel_process_startup(v22, "exec", 4uLL, *(const void **)(v12 + 8), *(void *)(v12 + 16));
      if (v27)
      {
        if (v27 == -37)
        {
          unint64_t v23 = "Would block requesting SCP startup";
LABEL_57:
          uint64_t v24 = a1;
          uint64_t v25 = 4294967259;
          goto LABEL_58;
        }
        (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v12 + 8), a1);
        *(void *)(v12 + 8) = 0;
        unint64_t v30 = "Unknown error while getting error string";
        goto LABEL_69;
      }
      (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(v12 + 8), a1);
      *(void *)(v12 + 8) = 0;
      *(_DWORD *)uint64_t v12 = 4;
LABEL_23:
      unint64_t v28 = _libssh2_channel_read(*(void *)(v12 + 288), 0, v12 + 24, 1uLL);
      uint64_t v25 = v28;
      if (v28 == -37)
      {
        unint64_t v23 = "Would block waiting for response from remote";
LABEL_25:
        uint64_t v24 = a1;
        goto LABEL_58;
      }
      if ((v28 & 0x80000000) != 0) {
        goto LABEL_45;
      }
      if (!v28) {
        goto LABEL_67;
      }
      if (*(unsigned char *)(v12 + 24)) {
        goto LABEL_66;
      }
      if (!(a6 | a5)) {
        goto LABEL_46;
      }
      *(void *)(v12 + 280) = snprintf((char *)(v12 + 24), 0x100uLL, "T%ld 0 %ld 0\n", a5, a6);
      *(_DWORD *)uint64_t v12 = 5;
LABEL_31:
      int v29 = _libssh2_channel_write(*(void *)(v12 + 288), 0, (const void *)(a1 + 73288), *(void *)(v12 + 280));
      if (v29 == -37)
      {
        unint64_t v23 = "Would block sending time data for SCP file";
        goto LABEL_57;
      }
      if (v29 != *(_DWORD *)(v12 + 280))
      {
        unint64_t v30 = "Unable to send time data for SCP file";
        goto LABEL_78;
      }
      *(_DWORD *)uint64_t v12 = 6;
LABEL_39:
      unint64_t v32 = _libssh2_channel_read(*(void *)(v12 + 288), 0, v12 + 24, 1uLL);
      uint64_t v25 = v32;
      if (v32 == -37)
      {
        unint64_t v23 = "Would block waiting for response";
        goto LABEL_25;
      }
      if ((v32 & 0x80000000) != 0)
      {
LABEL_45:
        unint64_t v30 = "SCP failure";
        uint64_t v33 = a1;
        goto LABEL_70;
      }
      if (!v32)
      {
LABEL_67:
        if (libssh2_channel_eof(*(void *)(v12 + 288)))
        {
          unint64_t v30 = "Unexpected channel close";
          goto LABEL_69;
        }
        return *(void *)(v12 + 288);
      }
      if (*(unsigned char *)(v12 + 24))
      {
        unint64_t v30 = "Invalid SCP ACK response";
LABEL_69:
        uint64_t v33 = a1;
        uint64_t v25 = 4294967268;
        goto LABEL_70;
      }
LABEL_46:
      *(_DWORD *)uint64_t v12 = 7;
LABEL_47:
      size_t v34 = strrchr(__s, 47);
      if (v34) {
        uint64_t v35 = v34 + 1;
      }
      else {
        uint64_t v35 = __s;
      }
      unint64_t v26 = snprintf((char *)(a1 + 73288), 0x100uLL, "C0%o %lld %s\n", a3, a4, v35);
      *(void *)(v12 + 280) = v26;
      *(_DWORD *)uint64_t v12 = 8;
LABEL_51:
      int v36 = _libssh2_channel_write(*(void *)(v12 + 288), 0, (const void *)(a1 + 73288), v26);
      if (v36 == -37)
      {
        unint64_t v23 = "Would block send core file data for SCP file";
        goto LABEL_57;
      }
      if (v36 != *(_DWORD *)(v12 + 280))
      {
        unint64_t v30 = "Unable to send core file data for SCP file";
LABEL_78:
        uint64_t v33 = a1;
        uint64_t v25 = 4294967289;
        goto LABEL_70;
      }
      *(_DWORD *)uint64_t v12 = 9;
LABEL_55:
      int v37 = _libssh2_channel_read(*(void *)(v12 + 288), 0, v12 + 24, 1uLL);
      if (v37 == -37)
      {
        unint64_t v23 = "Would block waiting for response";
        goto LABEL_57;
      }
      if (v37 < 0)
      {
LABEL_66:
        unint64_t v30 = "Invalid ACK response from remote";
        goto LABEL_69;
      }
      if (!v37) {
        goto LABEL_67;
      }
      if (*(unsigned char *)(v12 + 24))
      {
        unint64_t v38 = _libssh2_channel_packet_data_len(*(void *)(v12 + 288), 0);
        uint64_t v39 = (*(uint64_t (**)(unint64_t, uint64_t))(a1 + 8))(v38 + 1, a1);
        if (v39)
        {
          uint64_t v40 = v39;
          if ((int)_libssh2_channel_read(*(void *)(v12 + 288), 0, v39, v38) >= 1) {
            *(unsigned char *)(v40 + v38) = 0;
          }
          (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v40, a1);
          unint64_t v30 = "failed to send file";
          goto LABEL_69;
        }
        unint64_t v30 = "failed to get memory";
        uint64_t v33 = a1;
        uint64_t v25 = 4294967290;
LABEL_70:
        _libssh2_error(v33, v25, v30);
        int v41 = *(_DWORD *)(a1 + 616);
        uint64_t v42 = *(void *)(a1 + 608);
        while (libssh2_channel_free(*(void *)(v12 + 288)) == -37)
          ;
        uint64_t result = 0;
        *(_DWORD *)(a1 + 616) = v41;
        *(void *)(a1 + 608) = v42;
        *(void *)(v12 + 288) = 0;
LABEL_73:
        *(_DWORD *)uint64_t v12 = 0;
        return result;
      }
LABEL_74:
      *(_DWORD *)uint64_t v12 = 0;
      return *(void *)(v12 + 288);
    case 2:
      goto LABEL_17;
    case 3:
      uint64_t v22 = *(void *)(a1 + 73552);
      goto LABEL_19;
    case 4:
      goto LABEL_23;
    default:
      if (a6 | a5)
      {
        switch(v13)
        {
          case 5:
            goto LABEL_31;
          case 6:
            goto LABEL_39;
          case 7:
            goto LABEL_47;
          case 8:
            goto LABEL_14;
          case 9:
            goto LABEL_55;
          default:
            goto LABEL_74;
        }
      }
      switch(v13)
      {
        case 5:
          goto LABEL_46;
        case 7:
          goto LABEL_47;
        case 8:
LABEL_14:
          unint64_t v26 = *(void *)(a1 + 73544);
          goto LABEL_51;
        case 9:
          goto LABEL_55;
        default:
          goto LABEL_74;
      }
  }
}

uint64_t libssh2_scp_send64(uint64_t a1, char *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  time_t v12 = time(0);
  while (1)
  {
    uint64_t result = scp_send(a1, a2, a3, a4, a5, a6);
    if (!*(_DWORD *)(a1 + 172) || result != 0) {
      break;
    }
    if (libssh2_session_last_errno(a1) != -37 || _libssh2_wait_socket(a1, v12)) {
      return 0;
    }
  }
  return result;
}

char *shell_quotearg(char *a1, _WORD *a2, uint64_t a3)
{
  unint64_t v3 = (unint64_t)a2 + a3;
  unint64_t v4 = (unint64_t)a2 + a3 - 1;
  char v5 = *a1;
  if (*a1) {
    BOOL v6 = v4 > (unint64_t)a2;
  }
  else {
    BOOL v6 = 0;
  }
  time_t v7 = a2;
  if (!v6) {
    goto LABEL_5;
  }
  int v9 = 0;
  BOOL v10 = a1 + 1;
  time_t v7 = a2;
  do
  {
    if (v5 != 33)
    {
      if (v5 == 39)
      {
        if (v9 == 1)
        {
          uint64_t v11 = v7 + 1;
          if ((unint64_t)(v7 + 1) >= v3) {
            return 0;
          }
          *time_t v7 = 8743;
          goto LABEL_24;
        }
        if (!v9)
        {
          uint64_t v11 = (char *)v7 + 1;
          if ((unint64_t)v7 + 1 >= v3) {
            return 0;
          }
          *(unsigned char *)time_t v7 = 34;
LABEL_24:
          int v9 = 2;
          goto LABEL_35;
        }
        int v9 = 2;
        goto LABEL_34;
      }
      if (v9 == 2)
      {
        uint64_t v11 = v7 + 1;
        if ((unint64_t)(v7 + 1) >= v3) {
          return 0;
        }
        *time_t v7 = 10018;
      }
      else
      {
        if (v9)
        {
          int v9 = 1;
LABEL_34:
          uint64_t v11 = v7;
          goto LABEL_35;
        }
        uint64_t v11 = (char *)v7 + 1;
        if ((unint64_t)v7 + 1 >= v3) {
          return 0;
        }
        *(unsigned char *)time_t v7 = 39;
      }
      int v9 = 1;
      goto LABEL_35;
    }
    if (v9 == 2)
    {
      uint64_t v11 = v7 + 1;
      if ((unint64_t)(v7 + 1) >= v3) {
        return 0;
      }
      int v9 = 0;
      *time_t v7 = 23586;
    }
    else if (v9 == 1)
    {
      uint64_t v11 = v7 + 1;
      if ((unint64_t)(v7 + 1) >= v3) {
        return 0;
      }
      int v9 = 0;
      *time_t v7 = 23591;
    }
    else
    {
      uint64_t v11 = (char *)v7 + 1;
      if ((unint64_t)v7 + 1 >= v3) {
        return 0;
      }
      int v9 = 0;
      *(unsigned char *)time_t v7 = 92;
    }
LABEL_35:
    time_t v7 = v11 + 1;
    if ((unint64_t)(v11 + 1) >= v3) {
      return 0;
    }
    *uint64_t v11 = *(v10 - 1);
    char v5 = *v10;
    if (!*v10) {
      break;
    }
    ++v10;
  }
  while ((unint64_t)v7 < v4);
  if (v9 == 1)
  {
    time_t v12 = v11 + 2;
    if ((unint64_t)(v11 + 2) >= v3) {
      return 0;
    }
    char v13 = 39;
LABEL_44:
    *(unsigned char *)time_t v7 = v13;
    time_t v7 = v12;
    goto LABEL_5;
  }
  if (v9 != 2)
  {
LABEL_5:
    if ((unint64_t)v7 + 1 >= v3) {
      return 0;
    }
    *(unsigned char *)time_t v7 = 0;
    return (char *)((char *)v7 - (char *)a2);
  }
  time_t v12 = v11 + 2;
  if ((unint64_t)(v11 + 2) < v3)
  {
    char v13 = 34;
    goto LABEL_44;
  }
  return 0;
}

uint64_t _libssh2_openssl_random(unsigned __int8 *a1, unint64_t a2)
{
  if (a2 >> 31) {
    return 0xFFFFFFFFLL;
  }
  if (RAND_bytes(a1, a2) == 1) {
    return 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t _libssh2_rsa_new(uint64_t *a1, const unsigned __int8 *a2, int a3, const unsigned __int8 *a4, int a5, BIGNUM *a6, int a7, const unsigned __int8 *a8, int a9, const unsigned __int8 *a10, int a11, const unsigned __int8 *a12, int a13, const unsigned __int8 *a14, int a15, const unsigned __int8 *a16, int a17)
{
  uint64_t v25 = BN_new();
  BN_bin2bn(a2, a3, v25);
  unint64_t v26 = BN_new();
  BN_bin2bn(a4, a5, v26);
  if (a6)
  {
    int v27 = BN_new();
    BN_bin2bn((const unsigned __int8 *)a6, a7, v27);
    unint64_t v28 = BN_new();
    BN_bin2bn(a8, a9, v28);
    int v29 = BN_new();
    BN_bin2bn(a10, a11, v29);
    unint64_t v30 = BN_new();
    BN_bin2bn(a12, a13, v30);
    a6 = BN_new();
    BN_bin2bn(a14, a15, a6);
    uint64_t v31 = BN_new();
    BN_bin2bn(a16, a17, v31);
  }
  else
  {
    int v27 = 0;
    unint64_t v28 = 0;
    int v29 = 0;
    unint64_t v30 = 0;
    uint64_t v31 = 0;
  }
  unint64_t v32 = RSA_new();
  *a1 = (uint64_t)v32;
  RSA_set0_key((uint64_t)v32, (uint64_t)v26, (uint64_t)v25, (uint64_t)v27);
  RSA_set0_factors(*a1, (uint64_t)v28, (uint64_t)v29);
  RSA_set0_crt_params(*a1, (uint64_t)v30, (uint64_t)a6, (uint64_t)v31);
  return 0;
}

uint64_t _libssh2_rsa_sha2_verify(RSA *a1, size_t size, unsigned __int8 *a3, unsigned int a4, const void *a5, size_t a6)
{
  time_t v12 = (unsigned __int8 *)malloc_type_malloc(size, 0xDE968358uLL);
  if (!v12) {
    return 0xFFFFFFFFLL;
  }
  char v13 = v12;
  if (size == 64)
  {
    int v16 = _libssh2_sha512(a5, a6, v12);
    int v15 = 674;
    if (!v16) {
      goto LABEL_11;
    }
LABEL_8:
    free(v13);
    return 0xFFFFFFFFLL;
  }
  if (size != 32)
  {
    if (size == 20)
    {
      int v14 = _libssh2_sha1(a5, a6, v12);
      int v15 = 64;
      if (!v14) {
        goto LABEL_11;
      }
    }
    goto LABEL_8;
  }
  int v18 = _libssh2_sha256(a5, a6, v12);
  int v15 = 672;
  if (v18) {
    goto LABEL_8;
  }
LABEL_11:
  int v19 = RSA_verify(v15, v13, size, a3, a4, a1);
  free(v13);
  if (v19 == 1) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t _libssh2_sha1(const void *a1, size_t a2, unsigned __int8 *a3)
{
  BOOL v6 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (!v6) {
    return 1;
  }
  time_t v7 = v6;
  digestbyname = EVP_get_digestbyname("sha1");
  if (EVP_DigestInit(v7, digestbyname))
  {
    EVP_DigestUpdate(v7, a1, a2);
    EVP_DigestFinal(v7, a3, 0);
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t v9 = 1;
  }
  EVP_MD_CTX_free(v7);
  return v9;
}

uint64_t _libssh2_sha256(const void *a1, size_t a2, unsigned __int8 *a3)
{
  BOOL v6 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (!v6) {
    return 1;
  }
  time_t v7 = v6;
  digestbyname = EVP_get_digestbyname("sha256");
  if (EVP_DigestInit(v7, digestbyname))
  {
    EVP_DigestUpdate(v7, a1, a2);
    EVP_DigestFinal(v7, a3, 0);
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t v9 = 1;
  }
  EVP_MD_CTX_free(v7);
  return v9;
}

uint64_t _libssh2_sha512(const void *a1, size_t a2, unsigned __int8 *a3)
{
  BOOL v6 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (!v6) {
    return 1;
  }
  time_t v7 = v6;
  digestbyname = EVP_get_digestbyname("sha512");
  if (EVP_DigestInit(v7, digestbyname))
  {
    EVP_DigestUpdate(v7, a1, a2);
    EVP_DigestFinal(v7, a3, 0);
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t v9 = 1;
  }
  EVP_MD_CTX_free(v7);
  return v9;
}

uint64_t _libssh2_rsa_sha1_verify(RSA *a1, unsigned __int8 *a2, unsigned int a3, const void *a4, size_t a5)
{
  return _libssh2_rsa_sha2_verify(a1, 0x14uLL, a2, a3, a4, a5);
}

uint64_t _libssh2_dsa_new(uint64_t *a1, const unsigned __int8 *a2, int a3, const unsigned __int8 *a4, int a5, const unsigned __int8 *a6, int a7, const unsigned __int8 *a8, int a9, const unsigned __int8 *a10, uint64_t a11)
{
  int v18 = BN_new();
  BN_bin2bn(a2, a3, v18);
  int v19 = BN_new();
  BN_bin2bn(a4, a5, v19);
  size_t v20 = BN_new();
  BN_bin2bn(a6, a7, v20);
  size_t v21 = BN_new();
  BN_bin2bn(a8, a9, v21);
  if (a11)
  {
    uint64_t v22 = BN_new();
    BN_bin2bn(a10, a11, v22);
  }
  else
  {
    uint64_t v22 = 0;
  }
  unint64_t v23 = DSA_new();
  *a1 = (uint64_t)v23;
  DSA_set0_pqg((uint64_t)v23, (uint64_t)v18, (uint64_t)v19, (uint64_t)v20);
  DSA_set0_key(*a1, (uint64_t)v21, (uint64_t)v22);
  return 0;
}

uint64_t _libssh2_dsa_sha1_verify(DSA *a1, const unsigned __int8 *a2, const void *a3, size_t a4)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  size_t v8 = BN_new();
  BN_bin2bn(a2, 20, v8);
  uint64_t v9 = BN_new();
  BN_bin2bn(a2 + 20, 20, v9);
  BOOL v10 = DSA_SIG_new();
  DSA_SIG_set0(&v10->r, v8, v9);
  if (_libssh2_sha1(a3, a4, dgst))
  {
    uint64_t v11 = 0xFFFFFFFFLL;
  }
  else if (DSA_do_verify(dgst, 20, v10, a1) == 1)
  {
    uint64_t v11 = 0;
  }
  else
  {
    uint64_t v11 = 0xFFFFFFFFLL;
  }
  DSA_SIG_free(v10);
  return v11;
}

uint64_t _libssh2_ecdsa_get_curve_type(const EC_KEY *a1)
{
  uint64_t v1 = EC_KEY_get0_group(a1);
  return EC_GROUP_get_curve_name(v1);
}

uint64_t _libssh2_ecdsa_curve_type_from_name(const char *a1, int *a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (strlen(a1) != 19) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = strcmp(a1, "ecdsa-sha2-nistp256");
  if (!result)
  {
    int v8 = 415;
    goto LABEL_17;
  }
  uint64_t result = strcmp(a1, "ecdsa-sha2-nistp384");
  if (!result)
  {
    int v8 = 715;
LABEL_17:
    BOOL v7 = 1;
    if (!a2) {
      return result;
    }
    goto LABEL_18;
  }
  int v5 = strcmp(a1, "ecdsa-sha2-nistp521");
  BOOL v6 = v5 == 0;
  BOOL v7 = v5 == 0;
  if (v5) {
    uint64_t result = 0xFFFFFFFFLL;
  }
  else {
    uint64_t result = 0;
  }
  if (v6) {
    int v8 = 716;
  }
  else {
    int v8 = 0;
  }
  if (a2)
  {
LABEL_18:
    if (v7) {
      *a2 = v8;
    }
  }
  return result;
}

uint64_t _libssh2_ecdsa_curve_name_with_octal_new(EC_KEY **a1, const unsigned __int8 *a2, size_t a3, int nid)
{
  BOOL v7 = EC_KEY_new_by_curve_name(nid);
  if (v7)
  {
    int v8 = v7;
    uint64_t v9 = EC_KEY_get0_group(v7);
    BOOL v10 = EC_POINT_new(v9);
    EC_POINT_oct2point(v9, v10, a2, a3, 0);
    int v11 = EC_KEY_set_public_key(v8, v10);
    if (v10) {
      EC_POINT_free(v10);
    }
    if (a1) {
      *a1 = v8;
    }
  }
  else
  {
    int v11 = 0;
  }
  if (v11 == 1) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t _libssh2_ecdsa_verify(const EC_KEY *a1, const unsigned __int8 *a2, int a3, const unsigned __int8 *a4, int a5, const void *a6, size_t a7)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  char v13 = EC_KEY_get0_group(a1);
  int curve_name = EC_GROUP_get_curve_name(v13);
  int v15 = ECDSA_SIG_new();
  int v16 = BN_new();
  long long v17 = BN_new();
  BN_bin2bn(a2, a3, v16);
  BN_bin2bn(a4, a5, v17);
  ECDSA_SIG_set0(&v15->r, v16, v17);
  switch(curve_name)
  {
    case 716:
      _libssh2_sha512(a6, a7, dgst);
      int v18 = 64;
      goto LABEL_7;
    case 715:
      _libssh2_sha384(a6, a7, dgst);
      int v18 = 48;
LABEL_7:
      int v19 = ECDSA_do_verify(dgst, v18, v15, a1);
      if (!v15) {
        goto LABEL_9;
      }
      goto LABEL_8;
    case 415:
      _libssh2_sha256(a6, a7, dgst);
      int v18 = 32;
      goto LABEL_7;
  }
  int v19 = 0;
  if (v15) {
LABEL_8:
  }
    ECDSA_SIG_free(v15);
LABEL_9:
  if (v19 == 1) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t _libssh2_sha384(const void *a1, size_t a2, unsigned __int8 *a3)
{
  BOOL v6 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (!v6) {
    return 1;
  }
  BOOL v7 = v6;
  digestbyname = EVP_get_digestbyname("sha384");
  if (EVP_DigestInit(v7, digestbyname))
  {
    EVP_DigestUpdate(v7, a1, a2);
    EVP_DigestFinal(v7, a3, 0);
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t v9 = 1;
  }
  EVP_MD_CTX_free(v7);
  return v9;
}

BOOL _libssh2_cipher_init(EVP_CIPHER_CTX **a1, uint64_t (*a2)(void), unsigned __int8 *a3, const unsigned __int8 *a4, int a5)
{
  BOOL v10 = EVP_CIPHER_CTX_new();
  *a1 = v10;
  int v11 = (const EVP_CIPHER *)a2();
  int v12 = EVP_CipherInit(v10, v11, a4, a3, a5);
  BOOL result = v12 == 0;
  if ((char *)a2 == (char *)EVP_aes_128_gcm || (char *)a2 == (char *)EVP_aes_256_gcm)
  {
    int v14 = EVP_CIPHER_CTX_ctrl(*a1, 18, -1, a3);
    return !v12 || v14 == 0;
  }
  return result;
}

uint64_t _libssh2_cipher_crypt(EVP_CIPHER_CTX **a1, void *(*a2)(), int a3, const unsigned __int8 *a4, unint64_t a5, int a6)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  BOOL v6 = a2 == EVP_aes_128_gcm || a2 == EVP_aes_256_gcm;
  int v7 = v6;
  if (v6) {
    unsigned int v8 = 16;
  }
  else {
    unsigned int v8 = 0;
  }
  char v9 = v7 & a6;
  if ((v7 & a6) != 0) {
    unsigned int v10 = 4;
  }
  else {
    unsigned int v10 = 0;
  }
  if ((a6 & 2) != 0) {
    unsigned int v11 = v8;
  }
  else {
    unsigned int v11 = 0;
  }
  if (a5 >= 0x21) {
    _libssh2_cipher_crypt_cold_1();
  }
  int v13 = v10 | v11;
  size_t v14 = a5 - (v10 | v11);
  if ((v14 & 0x80000000) != 0) {
    _libssh2_cipher_crypt_cold_2();
  }
  char v15 = a6;
  if (a6)
  {
    if (!v7)
    {
      int v18 = 1;
      goto LABEL_29;
    }
    int v18 = EVP_CIPHER_CTX_ctrl(*a1, 19, 1, ptr);
    if (v9) {
      int v18 = EVP_Cipher(*a1, 0, a4, 4u);
    }
  }
  else
  {
    int v18 = 1;
  }
  char v19 = v7 ^ 1;
  if (a3) {
    char v19 = 1;
  }
  if ((v19 & 1) == 0 && (v15 & 2) != 0) {
    int v18 = EVP_CIPHER_CTX_ctrl(*a1, 17, v8, (void *)&a4[a5 - v8]);
  }
LABEL_29:
  if (a5 != v13) {
    int v18 = EVP_Cipher(*a1, &ptr[v10 + 1], &a4[v10], v14);
  }
  if (v18 >= 1)
  {
    if ((v15 & 2) == 0) {
      goto LABEL_38;
    }
    if (EVP_Cipher(*a1, 0, 0, 0) < 0)
    {
      BOOL v21 = 1;
      goto LABEL_41;
    }
    char v20 = v7 ^ 1;
    if (!a3) {
      char v20 = 1;
    }
    if (v20) {
LABEL_38:
    }
      BOOL v21 = 0;
    else {
      BOOL v21 = EVP_CIPHER_CTX_ctrl(*a1, 16, v8, (void *)&a4[a5 - v8]) == 0;
    }
LABEL_41:
    memcpy((void *)&a4[v10], &ptr[v10 + 1], v14);
    return v21;
  }
  return 1;
}

uint64_t _libssh2_openssl_crypto_init()
{
  OPENSSL_add_all_algorithms_noconf();
  OpenSSL_add_all_ciphers();
  OpenSSL_add_all_digests();
  ENGINE_load_builtin_engines();
  return ENGINE_register_all_complete();
}

uint64_t _libssh2_rsa_new_private_frommemory(EVP_PKEY **a1, uint64_t a2, void *a3, unint64_t a4, const char *a5)
{
  _libssh2_init_if_needed();
  uint64_t result = read_private_key_from_memory(a1, (uint64_t (*)(BIO *, void, void, uint64_t))PEM_read_bio_RSAPrivateKey, a3, a4, (uint64_t)a5);
  if (result) {
    return _libssh2_pub_priv_openssh_keyfilememory(a2, a1, "ssh-rsa", 0, 0, 0, 0, (uint64_t)a3, a4, a5);
  }
  return result;
}

uint64_t read_private_key_from_memory(void *a1, uint64_t (*a2)(BIO *, void, void, uint64_t), void *buf, int len, uint64_t a5)
{
  *a1 = 0;
  unsigned int v8 = BIO_new_mem_buf(buf, len);
  if (!v8) {
    return 0xFFFFFFFFLL;
  }
  char v9 = v8;
  *a1 = a2(v8, 0, passphrase_cb, a5);
  BIO_free(v9);
  if (*a1) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t read_openssh_private_key_from_memory(EVP_PKEY **a1, uint64_t a2, char *a3, uint64_t a4, unint64_t a5, const char *a6)
{
  return _libssh2_pub_priv_openssh_keyfilememory(a2, a1, a3, 0, 0, 0, 0, a4, a5, a6);
}

uint64_t _libssh2_rsa_new_private(RSA **a1, uint64_t a2, char *a3, const char *a4)
{
  _libssh2_init_if_needed();
  if (!read_private_key_from_file(a1, (uint64_t (*)(BIO *, void, void, uint64_t))PEM_read_bio_RSAPrivateKey, a3, (uint64_t)a4))return 0; {
  char v15 = 0;
  }
  __s2 = 0;
  if (!a2)
  {
    unsigned int v11 = "Session is required";
    uint64_t v12 = 0;
LABEL_11:
    uint64_t v13 = 4294967282;
LABEL_13:
    _libssh2_error(v12, v13, v11);
    return 0xFFFFFFFFLL;
  }
  _libssh2_init_if_needed();
  unsigned int v8 = fopen(a3, "r");
  if (!v8)
  {
    unsigned int v11 = "Unable to open OpenSSH RSA private key file";
    uint64_t v12 = a2;
    uint64_t v13 = 4294967280;
    goto LABEL_13;
  }
  char v9 = v8;
  uint64_t v10 = _libssh2_openssh_pem_parse(a2, a4, (uint64_t)v8, &v15);
  fclose(v9);
  if (v10) {
    return v10;
  }
  if (_libssh2_get_string(v15, &__s2, 0) || !__s2)
  {
    unsigned int v11 = "Public key type in decrypted key data not found";
    uint64_t v12 = a2;
    goto LABEL_11;
  }
  if (!strcmp("ssh-rsa", __s2)) {
    uint64_t v10 = gen_publickey_from_rsa_openssh_priv_data(a2, v15, 0, 0, 0, 0, a1);
  }
  else {
    uint64_t v10 = 0xFFFFFFFFLL;
  }
  if (v15) {
    _libssh2_string_buf_free(a2, v15);
  }
  return v10;
}

uint64_t read_private_key_from_file(void *a1, uint64_t (*a2)(BIO *, void, void, uint64_t), char *filename, uint64_t a4)
{
  *a1 = 0;
  int v7 = BIO_new_file(filename, "r");
  if (!v7) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v8 = v7;
  *a1 = a2(v7, 0, passphrase_cb, a4);
  BIO_free(v8);
  if (*a1) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t _libssh2_dsa_new_private_frommemory(EVP_PKEY **a1, uint64_t a2, void *a3, unint64_t a4, const char *a5)
{
  _libssh2_init_if_needed();
  uint64_t result = read_private_key_from_memory(a1, (uint64_t (*)(BIO *, void, void, uint64_t))PEM_read_bio_DSAPrivateKey, a3, a4, (uint64_t)a5);
  if (result) {
    return _libssh2_pub_priv_openssh_keyfilememory(a2, a1, "ssh-dsa", 0, 0, 0, 0, (uint64_t)a3, a4, a5);
  }
  return result;
}

uint64_t _libssh2_dsa_new_private(DSA **a1, uint64_t a2, char *a3, const char *a4)
{
  _libssh2_init_if_needed();
  if (!read_private_key_from_file(a1, (uint64_t (*)(BIO *, void, void, uint64_t))PEM_read_bio_DSAPrivateKey, a3, (uint64_t)a4))return 0; {
  char v15 = 0;
  }
  __s2 = 0;
  if (!a2)
  {
    unsigned int v11 = "Session is required";
    uint64_t v12 = 0;
LABEL_11:
    uint64_t v13 = 4294967282;
LABEL_13:
    _libssh2_error(v12, v13, v11);
    return 0xFFFFFFFFLL;
  }
  _libssh2_init_if_needed();
  unsigned int v8 = fopen(a3, "r");
  if (!v8)
  {
    unsigned int v11 = "Unable to open OpenSSH DSA private key file";
    uint64_t v12 = a2;
    uint64_t v13 = 4294967280;
    goto LABEL_13;
  }
  char v9 = v8;
  uint64_t v10 = _libssh2_openssh_pem_parse(a2, a4, (uint64_t)v8, &v15);
  fclose(v9);
  if (v10) {
    return v10;
  }
  if (_libssh2_get_string(v15, &__s2, 0) || !__s2)
  {
    unsigned int v11 = "Public key type in decrypted key data not found";
    uint64_t v12 = a2;
    goto LABEL_11;
  }
  if (!strcmp("ssh-dss", __s2)) {
    uint64_t v10 = gen_publickey_from_dsa_openssh_priv_data(a2, v15, 0, 0, 0, 0, a1);
  }
  else {
    uint64_t v10 = 0xFFFFFFFFLL;
  }
  if (v15) {
    _libssh2_string_buf_free(a2, v15);
  }
  return v10;
}

uint64_t _libssh2_ecdsa_new_private_frommemory(EVP_PKEY **a1, uint64_t a2, void *a3, unint64_t a4, const char *a5)
{
  _libssh2_init_if_needed();
  uint64_t result = read_private_key_from_memory(a1, (uint64_t (*)(BIO *, void, void, uint64_t))PEM_read_bio_ECPrivateKey, a3, a4, (uint64_t)a5);
  if (result) {
    return _libssh2_pub_priv_openssh_keyfilememory(a2, a1, "ssh-ecdsa", 0, 0, 0, 0, (uint64_t)a3, a4, a5);
  }
  return result;
}

uint64_t _libssh2_ecdsa_new_private_frommemory_sk(EVP_PKEY **a1, unsigned char *a2, void **a3, void *a4, size_t *a5, uint64_t a6, uint64_t a7, unint64_t a8, const char *a9)
{
  return _libssh2_sk_pub_openssh_keyfilememory(a6, a1, "sk-ecdsa-sha2-nistp256@openssh.com", 0, 0, 0, 0, &v10, a2, a3, a4, a5, a7, a8, a9);
}

uint64_t _libssh2_sk_pub_openssh_keyfilememory(uint64_t a1, EVP_PKEY **a2, char *__s, const char **a4, size_t *a5, void *a6, uint64_t *a7, _DWORD *a8, unsigned char *a9, void **a10, void *a11, size_t *a12, uint64_t a13, unint64_t a14, const char *a15)
{
  unint64_t v28 = 0;
  __s2 = 0;
  if (a2) {
    *a2 = 0;
  }
  if (!a1)
  {
    char v19 = "Session is required";
    uint64_t v20 = 0;
    goto LABEL_13;
  }
  if (__s && strlen(__s) <= 6)
  {
    char v19 = "type is invalid";
    uint64_t v20 = a1;
LABEL_13:
    return _libssh2_error(v20, 4294967282, v19);
  }
  _libssh2_init_if_needed();
  uint64_t v21 = _libssh2_openssh_pem_parse_memory(a1, a15, a13, a14, &v28);
  if (!v21)
  {
    if (_libssh2_get_string(v28, &__s2, 0)) {
      return _libssh2_error(a1, 4294967282, "Public key type in decrypted key data not found");
    }
    uint64_t v22 = __s2;
    if (!__s2)
    {
      return _libssh2_error(a1, 4294967282, "Public key type in decrypted key data not found");
    }
    else
    {
      if (!strcmp("sk-ssh-ed25519@openssh.com", __s2)
        && ((*a8 = 6, !__s) || !strcmp("sk-ssh-ed25519@openssh.com", __s)))
      {
        uint64_t v21 = gen_publickey_from_sk_ed25519_openssh_priv_data(a1, v28, a4, a5, a6, a7, a9, a10, a11, a12, a2);
        uint64_t v22 = __s2;
      }
      else
      {
        uint64_t v21 = 4294967280;
      }
      if (!strcmp("sk-ecdsa-sha2-nistp256@openssh.com", v22))
      {
        *a8 = 3;
        uint64_t v21 = gen_publickey_from_sk_ecdsa_openssh_priv_data(a1, v28, a4, a5, a6, a7, a9, a10, a11, a12, (EC_KEY **)a2);
      }
      if (v21 == -16) {
        uint64_t v21 = _libssh2_error(a1, 4294967280, "Unable to extract public key from private key file: invalid/unrecognized private key file format");
      }
      if (v28) {
        _libssh2_string_buf_free(a1, v28);
      }
    }
  }
  return v21;
}

uint64_t _libssh2_curve25519_new(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  puint64_t key = 0;
  BOOL v6 = (uint64_t *)EVP_PKEY_CTX_new_id(950, 0);
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  int v7 = v6;
  if (EVP_PKEY_keygen_init(v6) != 1 || EVP_PKEY_keygen(v7, &pkey) != 1)
  {
    uint64_t v8 = 0;
    goto LABEL_13;
  }
  if (!a3)
  {
LABEL_8:
    if (!a2)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 0;
      uint64_t v10 = 0;
      goto LABEL_15;
    }
    uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(32, a1);
    if (v9)
    {
      uint64_t v8 = 0;
      uint64_t v10 = 0xFFFFFFFFLL;
      if (EVP_PKEY_get_raw_public_key((uint64_t)pkey) == 1)
      {
        uint64_t v8 = 0;
        uint64_t v10 = 0;
        *a2 = v9;
        uint64_t v9 = 0;
      }
      goto LABEL_15;
    }
    uint64_t v8 = 0;
    goto LABEL_14;
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(32, a1);
  if (!v8)
  {
LABEL_13:
    uint64_t v9 = 0;
LABEL_14:
    uint64_t v10 = 0xFFFFFFFFLL;
    goto LABEL_15;
  }
  uint64_t v9 = 0;
  uint64_t v10 = 0xFFFFFFFFLL;
  if (EVP_PKEY_get_raw_private_key((uint64_t)pkey) == 1)
  {
    *a3 = v8;
    goto LABEL_8;
  }
LABEL_15:
  EVP_PKEY_CTX_free((EVP_PKEY **)v7);
  if (pkey) {
    EVP_PKEY_free(pkey);
  }
  if (v8) {
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v8, a1);
  }
  if (v9) {
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v9, a1);
  }
  return v10;
}

uint64_t _libssh2_ed25519_new_private(EVP_PKEY **a1, uint64_t a2, const char *a3, const char *a4)
{
  puint64_t key = 0;
  long long v17 = 0;
  if (!a2)
  {
    uint64_t v12 = "Session is required";
    uint64_t v13 = 0;
LABEL_9:
    uint64_t v14 = 4294967282;
LABEL_11:
    _libssh2_error(v13, v14, v12);
    return 0xFFFFFFFFLL;
  }
  _libssh2_init_if_needed();
  uint64_t v8 = fopen(a3, "r");
  if (!v8)
  {
    uint64_t v12 = "Unable to open ED25519 private key file";
    uint64_t v13 = a2;
    uint64_t v14 = 4294967280;
    goto LABEL_11;
  }
  uint64_t v9 = v8;
  __s2 = 0;
  uint64_t v10 = _libssh2_openssh_pem_parse(a2, a4, (uint64_t)v8, &v17);
  fclose(v9);
  if (v10) {
    return v10;
  }
  if (_libssh2_get_string(v17, &__s2, 0) || !__s2)
  {
    uint64_t v12 = "Public key type in decrypted key data not found";
    uint64_t v13 = a2;
    goto LABEL_9;
  }
  if (!strcmp("ssh-ed25519", __s2)) {
    int v11 = gen_publickey_from_ed25519_openssh_priv_data(a2, v17, 0, 0, 0, 0, &pkey);
  }
  else {
    int v11 = -1;
  }
  if (v17) {
    _libssh2_string_buf_free(a2, v17);
  }
  if (v11) {
    return 0xFFFFFFFFLL;
  }
  if (a1)
  {
    uint64_t v10 = 0;
    *a1 = pkey;
  }
  else
  {
    if (pkey) {
      EVP_PKEY_free(pkey);
    }
    return 0;
  }
  return v10;
}

uint64_t gen_publickey_from_ed25519_openssh_priv_data(uint64_t a1, void *a2, uint64_t *a3, void *a4, void *a5, void *a6, EVP_PKEY **a7)
{
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  size_t v28 = 0;
  int v29 = 0;
  if (_libssh2_get_string(a2, &v31, &v28) || v28 != 32)
  {
    long long v17 = "Wrong public key length";
LABEL_13:
    _libssh2_error(a1, 4294967282, v17);
    return 0xFFFFFFFFLL;
  }
  if (_libssh2_get_string(a2, &v30, &v28) || v28 != 64)
  {
    long long v17 = "Wrong private key length";
    goto LABEL_13;
  }
  uint64_t v14 = EVP_PKEY_new_raw_private_key(952, 0, v30, 32);
  if (_libssh2_get_string(a2, &v29, &v28))
  {
    char v15 = "Unable to read comment";
    goto LABEL_7;
  }
  if (v28)
  {
    char v19 = _libssh2_calloc(a1, v28 + 1);
    if (v19)
    {
      uint64_t v20 = v19;
      memcpy(v19, v29, v28);
      v20[v28] = 0;
      (*(void (**)(unsigned char *, uint64_t))(a1 + 24))(v20, a1);
    }
  }
  unint64_t v21 = a2[1];
  uint64_t v22 = a2[2];
  if (v21 < *a2 + v22)
  {
    uint64_t v23 = 0;
    unint64_t v24 = v22 + *a2 - v21;
    while (v23 + 1 == *(unsigned __int8 *)(v21 + v23))
    {
      a2[1] = v21 + v23++ + 1;
      if (v24 == v23) {
        goto LABEL_22;
      }
    }
    char v15 = "Wrong padding";
LABEL_7:
    _libssh2_error(a1, 4294967282, v15);
    uint64_t v16 = 0;
    if (!v14) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
LABEL_22:
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(11, a1);
  if (!v16 || (uint64_t v25 = _libssh2_calloc(a1, 0x33uLL)) == 0)
  {
    _libssh2_error(a1, 4294967290, "Unable to allocate memory for ED25519 key");
    if (!v14)
    {
LABEL_9:
      if (v16) {
        (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v16, a1);
      }
      return 0xFFFFFFFFLL;
    }
LABEL_8:
    EVP_PKEY_free(v14);
    goto LABEL_9;
  }
  unint64_t v26 = v25;
  int v27 = v25;
  _libssh2_store_str(&v27, "ssh-ed25519", 0xBuLL);
  _libssh2_store_str(&v27, v31, 0x20uLL);
  *(_DWORD *)(v16 + 7) = 959526197;
  *(void *)uint64_t v16 = *(void *)"ssh-ed25519";
  if (a3) {
    *a3 = v16;
  }
  else {
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v16, a1);
  }
  if (a4) {
    *a4 = 11;
  }
  if (a5) {
    *a5 = v26;
  }
  else {
    (*(void (**)(_DWORD *, uint64_t))(a1 + 24))(v26, a1);
  }
  if (a6) {
    *a6 = 51;
  }
  if (a7)
  {
    uint64_t result = 0;
    *a7 = v14;
  }
  else
  {
    if (v14) {
      EVP_PKEY_free(v14);
    }
    return 0;
  }
  return result;
}

uint64_t _libssh2_ed25519_new_private_sk(EVP_PKEY **a1, unsigned char *a2, void **a3, void *a4, size_t *a5, uint64_t a6, const char *a7, const char *a8)
{
  puint64_t key = 0;
  uint64_t v25 = 0;
  if (!a6)
  {
    uint64_t v20 = "Session is required";
    uint64_t v21 = 0;
LABEL_9:
    uint64_t v22 = 4294967282;
LABEL_11:
    _libssh2_error(v21, v22, v20);
    return 0xFFFFFFFFLL;
  }
  _libssh2_init_if_needed();
  uint64_t v16 = fopen(a7, "r");
  if (!v16)
  {
    uint64_t v20 = "Unable to open ED25519 SK private key file";
    uint64_t v21 = a6;
    uint64_t v22 = 4294967280;
    goto LABEL_11;
  }
  long long v17 = v16;
  __s2 = 0;
  uint64_t v18 = _libssh2_openssh_pem_parse(a6, a8, (uint64_t)v16, &v25);
  fclose(v17);
  if (v18) {
    return v18;
  }
  if (_libssh2_get_string(v25, &__s2, 0) || !__s2)
  {
    uint64_t v20 = "Public key type in decrypted key data not found";
    uint64_t v21 = a6;
    goto LABEL_9;
  }
  if (!strcmp("sk-ssh-ed25519@openssh.com", __s2)) {
    int v19 = gen_publickey_from_sk_ed25519_openssh_priv_data(a6, v25, 0, 0, 0, 0, a2, a3, a4, a5, &pkey);
  }
  else {
    int v19 = -1;
  }
  if (v25) {
    _libssh2_string_buf_free(a6, v25);
  }
  if (v19) {
    return 0xFFFFFFFFLL;
  }
  if (a1)
  {
    uint64_t v18 = 0;
    *a1 = pkey;
  }
  else
  {
    if (pkey) {
      EVP_PKEY_free(pkey);
    }
    return 0;
  }
  return v18;
}

uint64_t gen_publickey_from_sk_ed25519_openssh_priv_data(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, unsigned char *a7, void **a8, void *a9, size_t *a10, EVP_PKEY **a11)
{
  uint64_t v31 = 0;
  unint64_t v32 = 0;
  uint64_t v29 = 0;
  unint64_t v30 = 0;
  if (_libssh2_get_string(a2, &v32, &v29) || v29 != 32)
  {
    int v19 = "Wrong public key length";
    goto LABEL_6;
  }
  if (_libssh2_get_string(a2, &v31, &v30))
  {
    int v19 = "No SK application.";
LABEL_6:
    _libssh2_error(a1, 4294967282, v19);
    return 0xFFFFFFFFLL;
  }
  if (a7 && _libssh2_get_byte(a2, a7))
  {
    int v19 = "No SK flags.";
    goto LABEL_6;
  }
  if (a9 && a10)
  {
    char __src = 0;
    if (_libssh2_get_string(a2, &__src, a10))
    {
      int v19 = "No SK key_handle.";
      goto LABEL_6;
    }
    if (*a10)
    {
      uint64_t v21 = (void *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(*a10, a1);
      *a9 = v21;
      memcpy(v21, __src, *a10);
    }
  }
  uint64_t v22 = EVP_PKEY_new_raw_public_key(952, 0, (uint64_t)v32, 32);
  uint64_t v23 = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(26, a1);
  if (!v23 || (v27 = v30 + 70, (unint64_t v24 = _libssh2_calloc(a1, v30 + 70)) == 0))
  {
    _libssh2_error(a1, 4294967290, "Unable to allocate memory for ED25519 key");
    if (v22) {
      EVP_PKEY_free(v22);
    }
    if (v23) {
      (*(void (**)(void *, uint64_t))(a1 + 24))(v23, a1);
    }
    if (a8 && *a8)
    {
      (*(void (**)(void **, uint64_t))(a1 + 24))(a8, a1);
      *a8 = 0;
    }
    if (a9 && *a9)
    {
      (*(void (**)(void *, uint64_t))(a1 + 24))(a9, a1);
      *a9 = 0;
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v25 = v24;
  char __src = v24;
  _libssh2_store_str((_DWORD **)&__src, "sk-ssh-ed25519@openssh.com", 0x1AuLL);
  _libssh2_store_str((_DWORD **)&__src, v32, 0x20uLL);
  _libssh2_store_str((_DWORD **)&__src, v31, v30);
  if (a8 && v30)
  {
    unint64_t v26 = (void *)(*(uint64_t (**)(unint64_t, uint64_t))(a1 + 8))(v30 + 1, a1);
    *a8 = v26;
    memset_s(v26, v30 + 1, 0, v30 + 1);
    memcpy(*a8, v31, v30);
  }
  qmemcpy(v23, "sk-ssh-ed25519@openssh.com", 26);
  if (a3) {
    *a3 = v23;
  }
  else {
    (*(void (**)(void *, uint64_t))(a1 + 24))(v23, a1);
  }
  if (a4) {
    *a4 = 26;
  }
  if (a5) {
    *a5 = v25;
  }
  else {
    (*(void (**)(void *, uint64_t))(a1 + 24))(v25, a1);
  }
  if (a6) {
    *a6 = v27;
  }
  if (a11)
  {
    uint64_t result = 0;
    *a11 = v22;
  }
  else
  {
    if (v22) {
      EVP_PKEY_free(v22);
    }
    return 0;
  }
  return result;
}

uint64_t _libssh2_ed25519_new_private_frommemory(EVP_PKEY **a1, uint64_t a2, void *a3, unint64_t a4, const char *a5)
{
  uint64_t v12 = 0;
  _libssh2_init_if_needed();
  if (read_private_key_from_memory(&v12, (uint64_t (*)(BIO *, void, void, uint64_t))PEM_read_bio_PrivateKey, a3, a4, (uint64_t)a5))return _libssh2_pub_priv_openssh_keyfilememory(a2, a1, "ssh-ed25519", 0, 0, 0, 0, (uint64_t)a3, a4, a5); {
  int v11 = v12;
  }
  if (EVP_PKEY_id((unsigned int *)v12) == 952)
  {
    *a1 = v11;
    return 0;
  }
  else
  {
    EVP_PKEY_free(v11);
    return _libssh2_error(a2, 4294967282, "Private key is not an ED25519 key");
  }
}

uint64_t _libssh2_ed25519_new_private_frommemory_sk(EVP_PKEY **a1, unsigned char *a2, void **a3, void *a4, size_t *a5, uint64_t a6, uint64_t a7, unint64_t a8, const char *a9)
{
  return _libssh2_sk_pub_openssh_keyfilememory(a6, a1, "sk-ssh-ed25519@openssh.com", 0, 0, 0, 0, &v10, a2, a3, a4, a5, a7, a8, a9);
}

uint64_t _libssh2_ed25519_new_public(EVP_PKEY **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  BOOL v6 = EVP_PKEY_new_raw_public_key(952, 0, a3, a4);
  if (v6)
  {
    int v7 = v6;
    uint64_t result = 0;
    *a1 = v7;
  }
  else
  {
    return _libssh2_error(a2, 4294967282, "could not create ED25519 public key");
  }
  return result;
}

uint64_t _libssh2_rsa_sha2_sign(uint64_t a1, RSA *a2, const unsigned __int8 *a3, uint64_t a4, unsigned __int8 **a5, void *a6)
{
  unsigned int siglen = RSA_size(a2);
  uint64_t v12 = siglen;
  uint64_t v13 = (*(uint64_t (**)(void, uint64_t))(a1 + 8))(siglen, a1);
  if (!v13) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v14 = (unsigned __int8 *)v13;
  switch(a4)
  {
    case 64:
      int v15 = 674;
      uint64_t v16 = a3;
      unsigned int v17 = 64;
      break;
    case 32:
      int v15 = 672;
      uint64_t v16 = a3;
      unsigned int v17 = 32;
      break;
    case 20:
      int v15 = 64;
      uint64_t v16 = a3;
      unsigned int v17 = 20;
      break;
    default:
      _libssh2_error(a1, 4294967282, "Unsupported hash digest length");
      goto LABEL_13;
  }
  if (!RSA_sign(v15, v16, v17, v14, &siglen, a2))
  {
    (*(void (**)(unsigned __int8 *, uint64_t))(a1 + 24))(v14, a1);
    return 0xFFFFFFFFLL;
  }
  uint64_t v12 = siglen;
LABEL_13:
  uint64_t result = 0;
  *a5 = v14;
  *a6 = v12;
  return result;
}

uint64_t _libssh2_dsa_sha1_sign(DSA *dsa, unsigned __int8 *dgst, uint64_t a3, uint64_t a4)
{
  int v5 = DSA_do_sign(dgst, 20, dsa);
  if (!v5) {
    return 0xFFFFFFFFLL;
  }
  BOOL v6 = v5;
  uint64_t v14 = 0;
  a = 0;
  DSA_SIG_get0(v5, &a, &v14);
  int v7 = BN_num_bits(a);
  if (v7 >= -7) {
    int v8 = v7 + 7;
  }
  else {
    int v8 = v7 + 14;
  }
  if ((v7 - 161) >= 0xFFFFFF60 && (int v9 = BN_num_bits(v14), (v9 - 161) >= 0xFFFFFF60))
  {
    int v11 = -(v8 >> 3);
    unsigned int v12 = v9 + 7;
    *(void *)(a4 + 32) = 0;
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    BN_bn2bin(a, (unsigned __int8 *)(a4 + (v11 + 20)));
    BN_bn2bin(v14, (unsigned __int8 *)(a4 + 20 - (v12 >> 3) + 20));
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v10 = 0xFFFFFFFFLL;
  }
  DSA_SIG_free(v6);
  return v10;
}

uint64_t _libssh2_ecdsa_sign(uint64_t a1, EC_KEY *eckey, unsigned __int8 *dgst, int dgst_len, void *a5, char **a6)
{
  unint64_t v24 = 0;
  a = 0;
  int v9 = ECDSA_do_sign(dgst, dgst_len, eckey);
  if (!v9) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = v9;
  ECDSA_SIG_get0(v9, &a, &v24);
  int v11 = BN_num_bits(a);
  if (v11 >= -7) {
    int v12 = v11 + 7;
  }
  else {
    int v12 = v11 + 14;
  }
  int v13 = BN_num_bits(v24);
  int v14 = v13 + 7;
  if (v13 < -7) {
    int v14 = v13 + 14;
  }
  signed int v15 = (v14 >> 3) + 1;
  uint64_t v16 = malloc_type_malloc(v15 + (v12 >> 3) + 9, 0x59225677uLL);
  if (v16)
  {
    unsigned int v17 = v16;
    uint64_t v18 = write_bn((uint64_t)v16, a, (v12 >> 3) + 1);
    int v19 = (char *)(write_bn((uint64_t)v18, v24, v15) - v17);
    uint64_t v20 = _libssh2_calloc(a1, (size_t)v19);
    if (v20)
    {
      uint64_t v21 = v20;
      memcpy(v20, v17, (size_t)v19);
      uint64_t v22 = 0;
      *a5 = v21;
      *a6 = v19;
    }
    else
    {
      uint64_t v22 = 0xFFFFFFFFLL;
    }
    free(v17);
  }
  else
  {
    uint64_t v22 = 0xFFFFFFFFLL;
  }
  ECDSA_SIG_free(v10);
  return v22;
}

char *write_bn(uint64_t a1, BIGNUM *a, signed int a3)
{
  *(unsigned char *)(a1 + 4) = 0;
  int v5 = (char *)(a1 + 4);
  BOOL v6 = (const void *)(a1 + 5);
  BN_bn2bin(a, (unsigned __int8 *)(a1 + 5));
  if ((v5[1] & 0x80000000) == 0) {
    memmove(v5, v6, --a3);
  }
  _libssh2_htonu32((_DWORD *)a1, a3);
  return &v5[a3];
}

uint64_t _libssh2_sha1_init(EVP_MD_CTX **a1)
{
  uint64_t result = (uint64_t)EVP_MD_CTX_new();
  *a1 = (EVP_MD_CTX *)result;
  if (result)
  {
    unint64_t v3 = (EVP_MD_CTX *)result;
    digestbyname = EVP_get_digestbyname("sha1");
    if (EVP_DigestInit(v3, digestbyname))
    {
      return 1;
    }
    else
    {
      EVP_MD_CTX_free(*a1);
      uint64_t result = 0;
      *a1 = 0;
    }
  }
  return result;
}

uint64_t _libssh2_sha256_init(EVP_MD_CTX **a1)
{
  uint64_t result = (uint64_t)EVP_MD_CTX_new();
  *a1 = (EVP_MD_CTX *)result;
  if (result)
  {
    unint64_t v3 = (EVP_MD_CTX *)result;
    digestbyname = EVP_get_digestbyname("sha256");
    if (EVP_DigestInit(v3, digestbyname))
    {
      return 1;
    }
    else
    {
      EVP_MD_CTX_free(*a1);
      uint64_t result = 0;
      *a1 = 0;
    }
  }
  return result;
}

uint64_t _libssh2_sha384_init(EVP_MD_CTX **a1)
{
  uint64_t result = (uint64_t)EVP_MD_CTX_new();
  *a1 = (EVP_MD_CTX *)result;
  if (result)
  {
    unint64_t v3 = (EVP_MD_CTX *)result;
    digestbyname = EVP_get_digestbyname("sha384");
    if (EVP_DigestInit(v3, digestbyname))
    {
      return 1;
    }
    else
    {
      EVP_MD_CTX_free(*a1);
      uint64_t result = 0;
      *a1 = 0;
    }
  }
  return result;
}

uint64_t _libssh2_sha512_init(EVP_MD_CTX **a1)
{
  uint64_t result = (uint64_t)EVP_MD_CTX_new();
  *a1 = (EVP_MD_CTX *)result;
  if (result)
  {
    unint64_t v3 = (EVP_MD_CTX *)result;
    digestbyname = EVP_get_digestbyname("sha512");
    if (EVP_DigestInit(v3, digestbyname))
    {
      return 1;
    }
    else
    {
      EVP_MD_CTX_free(*a1);
      uint64_t result = 0;
      *a1 = 0;
    }
  }
  return result;
}

uint64_t _libssh2_md5_init(EVP_MD_CTX **a1)
{
  uint64_t result = (uint64_t)EVP_MD_CTX_new();
  *a1 = (EVP_MD_CTX *)result;
  if (result)
  {
    unint64_t v3 = (EVP_MD_CTX *)result;
    digestbyname = EVP_get_digestbyname("md5");
    if (EVP_DigestInit(v3, digestbyname))
    {
      return 1;
    }
    else
    {
      EVP_MD_CTX_free(*a1);
      uint64_t result = 0;
      *a1 = 0;
    }
  }
  return result;
}

uint64_t _libssh2_ecdsa_new_private(EC_KEY **a1, uint64_t a2, char *a3, const char *a4)
{
  _libssh2_init_if_needed();
  if (!read_private_key_from_file(a1, (uint64_t (*)(BIO *, void, void, uint64_t))PEM_read_bio_ECPrivateKey, a3, (uint64_t)a4))return 0; {
  unsigned int v17 = 0;
  }
  signed int v15 = 0;
  if (!a2)
  {
    int v11 = "Session is required";
    uint64_t v12 = 0;
LABEL_11:
    uint64_t v13 = 4294967282;
LABEL_13:
    _libssh2_error(v12, v13, v11);
    return 0xFFFFFFFFLL;
  }
  _libssh2_init_if_needed();
  int v8 = fopen(a3, "r");
  if (!v8)
  {
    int v11 = "Unable to open OpenSSH ECDSA private key file";
    uint64_t v12 = a2;
    uint64_t v13 = 4294967280;
    goto LABEL_13;
  }
  int v9 = v8;
  int v16 = 0;
  uint64_t v10 = _libssh2_openssh_pem_parse(a2, a4, (uint64_t)v8, &v15);
  fclose(v9);
  if (v10) {
    return v10;
  }
  if (_libssh2_get_string(v15, &v17, 0) || !v17)
  {
    int v11 = "Public key type in decrypted key data not found";
    uint64_t v12 = a2;
    goto LABEL_11;
  }
  if (_libssh2_ecdsa_curve_type_from_name(v17, &v16)) {
    uint64_t v10 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v10 = gen_publickey_from_ecdsa_openssh_priv_data(a2, v16, v15, 0, 0, 0, 0, a1);
  }
  if (v15) {
    _libssh2_string_buf_free(a2, v15);
  }
  return v10;
}

uint64_t _libssh2_ecdsa_new_private_sk(EC_KEY **a1, unsigned char *a2, void **a3, void *a4, size_t *a5, uint64_t a6, char *a7, const char *a8)
{
  _libssh2_init_if_needed();
  if (!read_private_key_from_file(a1, (uint64_t (*)(BIO *, void, void, uint64_t))PEM_read_bio_ECPrivateKey, a7, (uint64_t)a8))return 0; {
  uint64_t v23 = 0;
  }
  __s2 = 0;
  if (!a6)
  {
    int v19 = "Session is required";
    uint64_t v20 = 0;
LABEL_11:
    uint64_t v21 = 4294967282;
LABEL_13:
    _libssh2_error(v20, v21, v19);
    return 0xFFFFFFFFLL;
  }
  _libssh2_init_if_needed();
  int v16 = fopen(a7, "r");
  if (!v16)
  {
    int v19 = "Unable to open OpenSSH ECDSA private key file";
    uint64_t v20 = a6;
    uint64_t v21 = 4294967280;
    goto LABEL_13;
  }
  unsigned int v17 = v16;
  uint64_t v18 = _libssh2_openssh_pem_parse(a6, a8, (uint64_t)v16, &v23);
  fclose(v17);
  if (v18) {
    return v18;
  }
  if (_libssh2_get_string(v23, &__s2, 0) || !__s2)
  {
    int v19 = "Public key type in decrypted key data not found";
    uint64_t v20 = a6;
    goto LABEL_11;
  }
  if (!strcmp("sk-ecdsa-sha2-nistp256@openssh.com", __s2)) {
    uint64_t v18 = gen_publickey_from_sk_ecdsa_openssh_priv_data(a6, v23, 0, 0, 0, 0, a2, a3, a4, a5, a1);
  }
  else {
    uint64_t v18 = 0xFFFFFFFFLL;
  }
  if (v23) {
    _libssh2_string_buf_free(a6, v23);
  }
  return v18;
}

uint64_t _libssh2_ecdsa_create_key(uint64_t a1, EC_KEY **a2, void *a3, size_t *a4, int a5)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  uint64_t v10 = BN_CTX_new();
  if (!v10) {
    return 0xFFFFFFFFLL;
  }
  int v11 = v10;
  uint64_t v12 = EC_KEY_new_by_curve_name(a5);
  uint64_t v13 = EC_KEY_get0_group(v12);
  EC_KEY_generate_key(v12);
  int v14 = EC_KEY_get0_public_key(v12);
  size_t v15 = EC_POINT_point2oct(v13, v14, POINT_CONVERSION_UNCOMPRESSED, 0, 0, v11);
  if (v15 <= 0x85)
  {
    size_t v16 = v15;
    if (EC_POINT_point2oct(v13, v14, POINT_CONVERSION_UNCOMPRESSED, buf, v15, v11) == v15)
    {
      if (a2) {
        *a2 = v12;
      }
      if (!a3) {
        goto LABEL_9;
      }
      unsigned int v17 = (void *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v16, a1);
      *a3 = v17;
      if (v17)
      {
        memcpy(v17, buf, v16);
LABEL_9:
        uint64_t v18 = 0;
        if (a4) {
          *a4 = v16;
        }
        goto LABEL_12;
      }
    }
  }
  uint64_t v18 = 0xFFFFFFFFLL;
LABEL_12:
  BN_CTX_free(v11);
  return v18;
}

uint64_t _libssh2_ecdh_gen_k(BIGNUM **a1, const EC_KEY *a2, const unsigned __int8 *a3, size_t a4)
{
  int v8 = BN_CTX_new();
  uint64_t v9 = 0xFFFFFFFFLL;
  if (!a1) {
    return v9;
  }
  uint64_t v10 = v8;
  if (!v8) {
    return v9;
  }
  int v11 = EC_KEY_get0_group(a2);
  uint64_t v12 = EC_POINT_new(v11);
  if (!v12) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v13 = v12;
  if (EC_POINT_oct2point(v11, v12, a3, a4, v10) == 1)
  {
    int degree = EC_GROUP_get_degree(v11);
    int v15 = degree + 7;
    if (degree < -7) {
      int v15 = degree + 14;
    }
    size_t v16 = (uint64_t)v15 >> 3;
    unsigned int v17 = (unsigned __int8 *)malloc_type_malloc(v16, 0xEEB4C1A9uLL);
    uint64_t v18 = v17;
    if (v17)
    {
      int v19 = ECDH_compute_key(v17, v16, v13, a2, 0);
      if ((v19 - 134) >= 0xFFFFFF7B)
      {
        BN_bin2bn(v18, v19, *a1);
        uint64_t v9 = 0;
        goto LABEL_13;
      }
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  uint64_t v9 = 0xFFFFFFFFLL;
LABEL_13:
  EC_POINT_free(v13);
  BN_CTX_free(v10);
  if (v18) {
    free(v18);
  }
  return v9;
}

uint64_t _libssh2_ed25519_sign(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, size_t a6)
{
  uint64_t v12 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  uint64_t v13 = v12;
  uint64_t v18 = 0;
  if (v12)
  {
    if (EVP_DigestSignInit((uint64_t)v12, 0, 0, 0, a1) != 1)
    {
      int v14 = -1;
      goto LABEL_12;
    }
    int v14 = -1;
    if (EVP_DigestSign(v13, 0, &v18, a5, a6) != 1) {
      goto LABEL_12;
    }
    if (v18 != 64) {
      goto LABEL_12;
    }
    int v15 = _libssh2_calloc(a2, 0x40uLL);
    if (!v15) {
      goto LABEL_12;
    }
    size_t v16 = v15;
    int v14 = EVP_DigestSign(v13, (uint64_t)v15, &v18, a5, a6);
    if (v14 == 1)
    {
      *a3 = v16;
      *a4 = v18;
LABEL_12:
      EVP_MD_CTX_free(v13);
      goto LABEL_13;
    }
  }
  else
  {
    size_t v16 = 0;
    int v14 = -1;
  }
  *a4 = 0;
  *a3 = 0;
  (*(void (**)(void *, uint64_t))(a2 + 24))(v16, a2);
  if (v13) {
    goto LABEL_12;
  }
LABEL_13:
  if (v14 == 1) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t _libssh2_curve25519_gen_k(BIGNUM **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t v16 = 0;
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (!*a1) {
    return 0xFFFFFFFFLL;
  }
  BOOL v6 = BN_CTX_new();
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  int v7 = v6;
  int v8 = EVP_PKEY_new_raw_public_key(950, 0, a3, 32);
  uint64_t v9 = EVP_PKEY_new_raw_private_key(950, 0, a2, 32);
  uint64_t v10 = v9;
  if (v8 && v9)
  {
    int v11 = (uint64_t *)EVP_PKEY_CTX_new((uint64_t)v9, 0);
    if (v11)
    {
      uint64_t v12 = v11;
      int v13 = EVP_PKEY_derive_init(v11);
      if (v13 < 1
        || (int v13 = EVP_PKEY_derive_set_peer((uint64_t)v12, v8), v13 < 1)
        || (int v13 = EVP_PKEY_derive(v12, 0, &v16), v13 < 1))
      {
        int v14 = v13;
      }
      else if (v16 == 32)
      {
        int v14 = -1;
        if (EVP_PKEY_derive(v12, (uint64_t)s, &v16) == 1 && v16 == 32)
        {
          BN_bin2bn(s, 32, *a1);
          int v14 = 1;
        }
      }
      else
      {
        int v14 = -1;
      }
      EVP_PKEY_CTX_free((EVP_PKEY **)v12);
    }
    else
    {
      int v14 = -1;
    }
  }
  else
  {
    int v14 = -1;
    if (!v8) {
      goto LABEL_21;
    }
  }
  EVP_PKEY_free(v8);
LABEL_21:
  if (v10) {
    EVP_PKEY_free(v10);
  }
  BN_CTX_free(v7);
  if (v14 == 1) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t _libssh2_ed25519_verify(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, size_t a5)
{
  uint64_t v10 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (!v10) {
    return 0xFFFFFFFFLL;
  }
  int v11 = v10;
  unsigned int v12 = EVP_DigestVerifyInit((uint64_t)v10, 0, 0, 0, a1);
  if (v12 == 1) {
    unsigned int v12 = EVP_DigestVerify(v11, a2, a3, a4, a5);
  }
  EVP_MD_CTX_free(v11);
  if (v12 == 1) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t _libssh2_pub_priv_keyfile(uint64_t a1, const char **a2, size_t *a3, void *a4, uint64_t *a5, char *filename, void *a7)
{
  int v14 = BIO_new_file(filename, "r");
  if (v14)
  {
    int v15 = v14;
    BIO_ctrl(v14, 1, 0, 0);
    bio_PrivateKey = PEM_read_bio_PrivateKey(v15, 0, 0, a7);
    BIO_free(v15);
    if (bio_PrivateKey)
    {
      int v17 = EVP_PKEY_id((unsigned int *)bio_PrivateKey);
      if (v17 > 407)
      {
        if (v17 == 408)
        {
          uint64_t v18 = gen_publickey_from_ec_evp(a1, a2, a3, a4, a5, 0, bio_PrivateKey);
          goto LABEL_22;
        }
        if (v17 == 952)
        {
          uint64_t v18 = gen_publickey_from_ed_evp(a1, (uint64_t *)a2, a3, a4, a5, (uint64_t)bio_PrivateKey);
          goto LABEL_22;
        }
      }
      else
      {
        if (v17 == 6)
        {
          uint64_t v18 = gen_publickey_from_rsa_evp(a1, a2, a3, a4, (char **)a5, bio_PrivateKey);
          goto LABEL_22;
        }
        if (v17 == 116)
        {
          uint64_t v18 = gen_publickey_from_dsa_evp(a1, a2, a3, a4, (char **)a5, bio_PrivateKey);
LABEL_22:
          uint64_t v26 = v18;
          EVP_PKEY_free(bio_PrivateKey);
          return v26;
        }
      }
      uint64_t v18 = _libssh2_error(a1, 4294967280, "Unable to extract public key from private key file: Unsupported private key file format");
      goto LABEL_22;
    }
    unint64_t v30 = 0;
    __s2 = 0;
    if (a1)
    {
      _libssh2_init_if_needed();
      uint64_t v20 = fopen(filename, "r");
      if (!v20)
      {
        uint64_t v23 = "Unable to open private key file";
        goto LABEL_24;
      }
      uint64_t v21 = v20;
      int v22 = _libssh2_openssh_pem_parse(a1, (const char *)a7, (uint64_t)v20, &v30);
      fclose(v21);
      if (v22)
      {
        uint64_t v23 = "Not an OpenSSH key file";
LABEL_24:
        uint64_t v24 = a1;
        uint64_t v25 = 4294967280;
        goto LABEL_25;
      }
      if (!_libssh2_get_string(v30, &__s2, 0))
      {
        uint64_t v27 = __s2;
        if (__s2)
        {
          if (!strcmp("ssh-ed25519", __s2))
          {
            int v28 = gen_publickey_from_ed25519_openssh_priv_data(a1, v30, (uint64_t *)a2, a3, a4, a5, 0);
            uint64_t v27 = __s2;
          }
          else
          {
            int v28 = -1;
          }
          if (!strcmp("ssh-rsa", v27))
          {
            int v28 = gen_publickey_from_rsa_openssh_priv_data(a1, v30, a2, a3, a4, (char **)a5, 0);
            uint64_t v27 = __s2;
          }
          if (!strcmp("ssh-dss", v27))
          {
            int v28 = gen_publickey_from_dsa_openssh_priv_data(a1, v30, a2, a3, a4, (char **)a5, 0);
            uint64_t v27 = __s2;
          }
          int v29 = 0;
          if (!_libssh2_ecdsa_curve_type_from_name(v27, &v29)) {
            int v28 = gen_publickey_from_ecdsa_openssh_priv_data(a1, v29, v30, a2, a3, a4, a5, 0);
          }
          if (v30) {
            _libssh2_string_buf_free(a1, v30);
          }
          if (!v28) {
            return 0;
          }
          uint64_t v23 = "Unsupported OpenSSH key type";
          goto LABEL_24;
        }
      }
      uint64_t v23 = "Public key type in decrypted key data not found";
      uint64_t v24 = a1;
    }
    else
    {
      uint64_t v23 = "Session is required";
      uint64_t v24 = 0;
    }
    uint64_t v25 = 4294967282;
LABEL_25:
    _libssh2_error(v24, v25, v23);
    return _libssh2_error(a1, 4294967280, "Unable to extract public key from private key file: Wrong passphrase or invalid/unrecognized private key file format");
  }
  return _libssh2_error(a1, 4294967280, "Unable to extract public key from private key file: Unable to open private key file");
}

uint64_t gen_publickey_from_ed_evp(uint64_t a1, uint64_t *a2, void *a3, void *a4, void *a5, uint64_t a6)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  uint64_t v22 = 0;
  strcpy(v23, "ssh-ed25519");
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(11, a1);
  if (!v12)
  {
    _libssh2_error(a1, 4294967290, "Unable to allocate memory for private key data");
    return 0xFFFFFFFFLL;
  }
  uint64_t v13 = v12;
  *(_DWORD *)(v12 + 7) = 959526197;
  *(void *)uint64_t v12 = *(void *)"ssh-ed25519";
  if (EVP_PKEY_get_raw_public_key(a6) != 1)
  {
    uint64_t v18 = "EVP_PKEY_get_raw_public_key failed";
    uint64_t v19 = a1;
    uint64_t v20 = 4294967282;
LABEL_9:
    _libssh2_error(v19, v20, v18);
    (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v13, a1);
    return 0xFFFFFFFFLL;
  }
  uint64_t v14 = v22 + 19;
  int v15 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(v22 + 19, a1);
  uint64_t v21 = v15;
  if (!v15)
  {
    uint64_t v18 = "Unable to allocate memory for private key data";
    uint64_t v19 = a1;
    uint64_t v20 = 4294967290;
    goto LABEL_9;
  }
  uint64_t v16 = v15;
  _libssh2_store_str(&v21, v23, 0xBuLL);
  _libssh2_store_u32(&v21, v22);
  if (EVP_PKEY_get_raw_public_key(a6) == 1)
  {
    uint64_t result = 0;
    *a2 = v13;
    *a3 = 11;
    *a4 = v16;
    *a5 = v14;
    return result;
  }
  _libssh2_error(a1, 4294967282, "EVP_PKEY_get_raw_public_key failed");
  (*(void (**)(uint64_t, uint64_t))(a1 + 24))(v13, a1);
  (*(void (**)(_DWORD *, uint64_t))(a1 + 24))(v16, a1);
  return 0xFFFFFFFFLL;
}

uint64_t gen_publickey_from_rsa_evp(uint64_t a1, void *a2, void *a3, void *a4, char **a5, EVP_PKEY *pkey)
{
  int v11 = EVP_PKEY_get1_RSA(pkey);
  if (v11)
  {
    uint64_t v12 = v11;
    uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(7, a1);
    if (v13)
    {
      uint64_t v14 = (_DWORD *)v13;
      uint64_t v25 = 0;
      a = 0;
      RSA_get0_key(v12, &v25, &a, 0);
      int v15 = BN_num_bits(a);
      if (v15 >= -7) {
        int v16 = v15 + 7;
      }
      else {
        int v16 = v15 + 14;
      }
      int v17 = BN_num_bits(v25);
      int v18 = v17 + 7;
      if (v17 < -7) {
        int v18 = v17 + 14;
      }
      signed int v19 = (v18 >> 3) + 1;
      uint64_t v20 = (_DWORD *)(*(uint64_t (**)(void, uint64_t))(a1 + 8))(v19 + (v16 >> 3) + 20, a1);
      if (v20)
      {
        uint64_t v21 = v20;
        _libssh2_htonu32(v20, 7u);
        *(_DWORD *)((char *)v21 + 7) = 1634955821;
        v21[1] = 761820019;
        uint64_t v22 = write_bn((uint64_t)v21 + 11, a, (v16 >> 3) + 1);
        uint64_t v23 = (char *)(write_bn((uint64_t)v22, v25, v19) - (char *)v21);
        RSA_free(v12);
        uint64_t result = 0;
        *(_DWORD *)((char *)v14 + 3) = 1634955821;
        *uint64_t v14 = 761820019;
        *a2 = v14;
        *a3 = 7;
        *a4 = v21;
        *a5 = v23;
        return result;
      }
      RSA_free(v12);
      (*(void (**)(_DWORD *, uint64_t))(a1 + 24))(v14, a1);
    }
    else
    {
      RSA_free(v12);
    }
  }
  return _libssh2_error(a1, 4294967290, "Unable to allocate memory for private key data");
}

uint64_t gen_publickey_from_dsa_evp(uint64_t a1, void *a2, void *a3, void *a4, char **a5, EVP_PKEY *pkey)
{
  int v11 = EVP_PKEY_get1_DSA(pkey);
  if (v11)
  {
    uint64_t v12 = v11;
    uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(7, a1);
    if (v13)
    {
      uint64_t v14 = (_DWORD *)v13;
      uint64_t v33 = a4;
      size_t v34 = a5;
      int v37 = 0;
      a = 0;
      uint64_t v35 = 0;
      int v36 = 0;
      DSA_get0_pqg(v12, &a, &v37, &v36);
      DSA_get0_key((uint64_t)v12, &v35, 0);
      int v15 = BN_num_bits(a);
      if (v15 >= -7) {
        int v16 = v15 + 7;
      }
      else {
        int v16 = v15 + 14;
      }
      int v17 = BN_num_bits(v37);
      int v18 = v17 + 7;
      if (v17 < -7) {
        int v18 = v17 + 14;
      }
      signed int v19 = (v18 >> 3) + 1;
      int v20 = BN_num_bits(v36);
      int v21 = v20 + 7;
      if (v20 < -7) {
        int v21 = v20 + 14;
      }
      signed int v22 = (v21 >> 3) + 1;
      int v23 = BN_num_bits(v35);
      int v24 = v23 + 7;
      if (v23 < -7) {
        int v24 = v23 + 14;
      }
      signed int v25 = (v24 >> 3) + 1;
      uint64_t v26 = (_DWORD *)(*(uint64_t (**)(void, uint64_t))(a1 + 8))(v19 + (v16 >> 3) + v22 + v25 + 28, a1);
      if (v26)
      {
        uint64_t v27 = v26;
        _libssh2_htonu32(v26, 7u);
        *(_DWORD *)((char *)v27 + 7) = 1936942125;
        v27[1] = 761820019;
        int v28 = write_bn((uint64_t)v27 + 11, a, (v16 >> 3) + 1);
        int v29 = write_bn((uint64_t)v28, v37, v19);
        unint64_t v30 = write_bn((uint64_t)v29, v36, v22);
        uint64_t v31 = (char *)(write_bn((uint64_t)v30, v35, v25) - (char *)v27);
        DSA_free(v12);
        uint64_t result = 0;
        *(_DWORD *)((char *)v14 + 3) = 1936942125;
        *uint64_t v14 = 761820019;
        *a2 = v14;
        *a3 = 7;
        *uint64_t v33 = v27;
        *size_t v34 = v31;
        return result;
      }
      DSA_free(v12);
      (*(void (**)(_DWORD *, uint64_t))(a1 + 24))(v14, a1);
    }
    else
    {
      DSA_free(v12);
    }
  }
  return _libssh2_error(a1, 4294967290, "Unable to allocate memory for private key data");
}

uint64_t gen_publickey_from_ec_evp(uint64_t a1, const char **a2, size_t *a3, void *a4, uint64_t *a5, int a6, EVP_PKEY *a7)
{
  uint64_t v14 = BN_CTX_new();
  if (!v14) {
    return 0xFFFFFFFFLL;
  }
  int v15 = v14;
  int v16 = EVP_PKEY_get1_EC_KEY(a7);
  if (!v16)
  {
    BN_CTX_free(v15);
    return 0xFFFFFFFFLL;
  }
  int v17 = v16;
  int v36 = a2;
  int v37 = a4;
  int v18 = EC_KEY_get0_public_key(v16);
  signed int v19 = EC_KEY_get0_group(v17);
  int v20 = EC_KEY_get0_group(v17);
  int curve_name = EC_GROUP_get_curve_name(v20);
  if (a6) {
    uint64_t v22 = 34;
  }
  else {
    uint64_t v22 = 19;
  }
  *a3 = v22;
  int v23 = (char *)(*(uint64_t (**)(void))(a1 + 8))();
  if (v23)
  {
    int v24 = v23;
    unint64_t v38 = 0;
    uint64_t v35 = a5;
    if (a6)
    {
      signed int v25 = "sk-ecdsa-sha2-nistp256@openssh.com";
    }
    else
    {
      switch(curve_name)
      {
        case 415:
          signed int v25 = "ecdsa-sha2-nistp256";
          break;
        case 716:
          signed int v25 = "ecdsa-sha2-nistp521";
          break;
        case 715:
          signed int v25 = "ecdsa-sha2-nistp384";
          break;
        default:
          goto LABEL_10;
      }
    }
    memcpy(v23, v25, *a3);
    size_t v26 = EC_POINT_point2oct(v19, v18, POINT_CONVERSION_UNCOMPRESSED, 0, 0, v15);
    if (v26 <= 0x85)
    {
      unint64_t v30 = v26;
      int v28 = malloc_type_malloc(v26, 0x162F364CuLL);
      if (v28
        && EC_POINT_point2oct(v19, v18, POINT_CONVERSION_UNCOMPRESSED, (unsigned __int8 *)v28, v30, v15) == v30
        && (uint64_t v31 = v30 + *a3 + 20,
            (unint64_t v32 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(v31, a1)) != 0))
      {
        uint64_t v33 = v32;
        unint64_t v38 = v32;
        _libssh2_store_str(&v38, v24, *a3);
        if (a6) {
          size_t v34 = "nistp256";
        }
        else {
          size_t v34 = v24 + 11;
        }
        _libssh2_store_str(&v38, v34, 8uLL);
        _libssh2_store_str(&v38, v28, v30);
        *int v36 = v24;
        void *v37 = v33;
        char v27 = 1;
        *uint64_t v35 = v31;
      }
      else
      {
        char v27 = 0;
      }
      goto LABEL_27;
    }
LABEL_10:
    char v27 = 0;
    int v28 = 0;
LABEL_27:
    EC_KEY_free(v17);
    BN_CTX_free(v15);
    if (v28)
    {
      free(v28);
      if (v27) {
        return 0;
      }
    }
    else if (v27)
    {
      return 0;
    }
    (*(void (**)(const char *, uint64_t))(a1 + 24))(v24, a1);
    return 0xFFFFFFFFLL;
  }
  return _libssh2_error(a1, 4294967290, "out of memory");
}

uint64_t _libssh2_pub_priv_openssh_keyfilememory(uint64_t a1, EVP_PKEY **a2, char *__s, uint64_t *a4, size_t *a5, void *a6, char **a7, uint64_t a8, unint64_t a9, const char *a10)
{
  signed int v25 = 0;
  __s2 = 0;
  if (a2) {
    *a2 = 0;
  }
  if (!a1)
  {
    int v18 = "Session is required";
    uint64_t v19 = 0;
    goto LABEL_13;
  }
  if (!__s || strlen(__s) - 12 > 0xFFFFFFFFFFFFFFFALL)
  {
    _libssh2_init_if_needed();
    uint64_t v20 = _libssh2_openssh_pem_parse_memory(a1, a10, a8, a9, &v25);
    if (!v20)
    {
      if (!_libssh2_get_string(v25, &__s2, 0))
      {
        int v21 = __s2;
        if (__s2)
        {
          if (!strcmp("ssh-ed25519", __s2))
          {
            if (__s && strcmp("ssh-ed25519", __s))
            {
              uint64_t v20 = 4294967280;
              if (strcmp("sk-ssh-ed25519@openssh.com", v21)) {
                goto LABEL_26;
              }
              goto LABEL_24;
            }
            uint64_t v20 = gen_publickey_from_ed25519_openssh_priv_data(a1, v25, a4, a5, a6, a7, a2);
            int v21 = __s2;
          }
          else
          {
            uint64_t v20 = 4294967280;
          }
          if (strcmp("sk-ssh-ed25519@openssh.com", v21)) {
            goto LABEL_26;
          }
          if (!__s)
          {
LABEL_25:
            uint64_t v20 = gen_publickey_from_sk_ed25519_openssh_priv_data(a1, v25, a4, a5, a6, a7, 0, 0, 0, 0, a2);
            int v21 = __s2;
LABEL_26:
            if (!strcmp("ssh-rsa", v21))
            {
              if (__s && strcmp("ssh-rsa", __s))
              {
                if (strcmp("ssh-dss", v21)) {
                  goto LABEL_36;
                }
                goto LABEL_34;
              }
              uint64_t v20 = gen_publickey_from_rsa_openssh_priv_data(a1, v25, a4, a5, a6, a7, (RSA **)a2);
              int v21 = __s2;
            }
            if (strcmp("ssh-dss", v21)) {
              goto LABEL_36;
            }
            if (!__s)
            {
LABEL_35:
              uint64_t v20 = gen_publickey_from_dsa_openssh_priv_data(a1, v25, a4, a5, a6, a7, (DSA **)a2);
              int v21 = __s2;
LABEL_36:
              int v24 = 0;
              if (!strcmp("sk-ecdsa-sha2-nistp256@openssh.com", v21))
              {
                uint64_t v23 = gen_publickey_from_sk_ecdsa_openssh_priv_data(a1, v25, (const char **)a4, a5, a6, (uint64_t *)a7, 0, 0, 0, 0, (EC_KEY **)a2);
              }
              else
              {
                if (_libssh2_ecdsa_curve_type_from_name(v21, &v24) || __s && strcmp("ssh-ecdsa", __s)) {
                  goto LABEL_43;
                }
                uint64_t v23 = gen_publickey_from_ecdsa_openssh_priv_data(a1, v24, v25, (const char **)a4, a5, a6, (uint64_t *)a7, (EC_KEY **)a2);
              }
              uint64_t v20 = v23;
LABEL_43:
              if (v20 == -16) {
                uint64_t v20 = _libssh2_error(a1, 4294967280, "Unable to extract public key from private key file: invalid/unrecognized private key file format");
              }
              if (v25) {
                _libssh2_string_buf_free(a1, v25);
              }
              return v20;
            }
LABEL_34:
            if (strcmp("ssh-dss", __s)) {
              goto LABEL_36;
            }
            goto LABEL_35;
          }
LABEL_24:
          if (strcmp("sk-ssh-ed25519@openssh.com", __s)) {
            goto LABEL_26;
          }
          goto LABEL_25;
        }
      }
      return _libssh2_error(a1, 4294967282, "Public key type in decrypted key data not found");
    }
    return v20;
  }
  int v18 = "type is invalid";
  uint64_t v19 = a1;
LABEL_13:
  return _libssh2_error(v19, 4294967282, v18);
}

uint64_t _libssh2_pub_priv_keyfilememory(uint64_t a1, const char **a2, size_t *a3, void *a4, uint64_t *a5, void *buf, unint64_t len, void *a8)
{
  int v16 = BIO_new_mem_buf(buf, len);
  if (v16)
  {
    int v17 = v16;
    BIO_ctrl(v16, 1, 0, 0);
    bio_PrivateKey = PEM_read_bio_PrivateKey(v17, 0, 0, a8);
    BIO_free(v17);
    if (bio_PrivateKey)
    {
      int v19 = EVP_PKEY_id((unsigned int *)bio_PrivateKey);
      if (v19 > 407)
      {
        if (v19 == 408)
        {
          uint64_t v20 = gen_publickey_from_ec_evp(a1, a2, a3, a4, a5, 0, bio_PrivateKey);
          goto LABEL_20;
        }
        if (v19 == 952)
        {
          uint64_t v20 = gen_publickey_from_ed_evp(a1, (uint64_t *)a2, a3, a4, a5, (uint64_t)bio_PrivateKey);
          goto LABEL_20;
        }
      }
      else
      {
        if (v19 == 6)
        {
          uint64_t v20 = gen_publickey_from_rsa_evp(a1, a2, a3, a4, (char **)a5, bio_PrivateKey);
          goto LABEL_20;
        }
        if (v19 == 116)
        {
          uint64_t v20 = gen_publickey_from_dsa_evp(a1, a2, a3, a4, (char **)a5, bio_PrivateKey);
LABEL_20:
          uint64_t v25 = v20;
          EVP_PKEY_free(bio_PrivateKey);
          return v25;
        }
      }
      uint64_t v20 = _libssh2_error(a1, 4294967280, "Unable to extract public key from private key file: Unsupported private key file format");
      goto LABEL_20;
    }
    if (!_libssh2_pub_priv_openssh_keyfilememory(a1, 0, 0, (uint64_t *)a2, a3, a4, (char **)a5, (uint64_t)buf, len, (const char *)a8))return 0; {
    int v21 = "Unable to extract public key from private key file: Unsupported private key file format";
    }
    uint64_t v22 = a1;
    uint64_t v23 = 4294967280;
  }
  else
  {
    int v21 = "Unable to allocate memory whencomputing public key";
    uint64_t v22 = a1;
    uint64_t v23 = 4294967290;
  }
  return _libssh2_error(v22, v23, v21);
}

uint64_t _libssh2_sk_pub_keyfilememory(uint64_t a1, const char **a2, size_t *a3, void *a4, uint64_t *a5, _DWORD *a6, unsigned char *a7, void **a8, void *a9, size_t *a10, void *a11, unint64_t a12, void *a13)
{
  int v17 = BIO_new_mem_buf(a11, a12);
  if (v17)
  {
    int v18 = v17;
    int v21 = a6;
    BIO_ctrl(v17, 1, 0, 0);
    bio_PrivateKey = PEM_read_bio_PrivateKey(v18, 0, 0, a13);
    BIO_free(v18);
    if (bio_PrivateKey) {
      return 0xFFFFFFFFLL;
    }
    else {
      return _libssh2_sk_pub_openssh_keyfilememory(a1, 0, 0, a2, a3, a4, a5, v21, a7, a8, a9, a10, (uint64_t)a11, a12, (const char *)a13);
    }
  }
  else
  {
    return _libssh2_error(a1, 4294967290, "Unable to allocate memory whencomputing public key");
  }
}

BIGNUM *_libssh2_dh_init(BIGNUM **a1)
{
  uint64_t result = BN_new();
  *a1 = result;
  return result;
}

uint64_t _libssh2_dh_key_pair(BIGNUM **a1, BIGNUM *a2, const BIGNUM *a3, const BIGNUM *a4, int a5, BN_CTX *a6)
{
  return 0;
}

uint64_t _libssh2_dh_secret(const BIGNUM **a1, BIGNUM *r, BIGNUM *a, const BIGNUM *a4, BN_CTX *a5)
{
  return 0;
}

void _libssh2_dh_dtor(BIGNUM **a1)
{
  *a1 = 0;
}

const char *_libssh2_supported_key_sign_algorithms(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  if (a3 == 7 && (*a2 == 761820019 ? (BOOL v3 = *(_DWORD *)((char *)a2 + 3) == 1634955821) : (BOOL v3 = 0), v3)) {
    return "rsa-sha2-512,rsa-sha2-256,ssh-rsa";
  }
  else {
    return 0;
  }
}

uint64_t passphrase_cb(void *a1, int a2, int a3, char *__s)
{
  unsigned int v7 = strlen(__s);
  if ((int)v7 >= a2) {
    uint64_t v8 = (a2 - 1);
  }
  else {
    uint64_t v8 = v7;
  }
  memcpy(a1, __s, (int)v8);
  *((unsigned char *)a1 + (int)v8) = 0;
  return v8;
}

uint64_t gen_publickey_from_rsa_openssh_priv_data(uint64_t a1, void *a2, void *a3, void *a4, void *a5, char **a6, RSA **a7)
{
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  size_t v26 = 0;
  uint64_t v27 = 0;
  int v24 = 0;
  uint64_t v25 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v20 = 0;
  int v21 = 0;
  int v19 = 0;
  if (_libssh2_get_bignum_bytes(a2, &v26, &v33))
  {
    uint64_t v14 = "RSA no n";
LABEL_15:
    _libssh2_error(a1, 4294967282, v14);
    return 0xFFFFFFFFLL;
  }
  if (_libssh2_get_bignum_bytes(a2, &v25, &v32))
  {
    uint64_t v14 = "RSA no e";
    goto LABEL_15;
  }
  if (_libssh2_get_bignum_bytes(a2, &v24, &v31))
  {
    uint64_t v14 = "RSA no d";
    goto LABEL_15;
  }
  if (_libssh2_get_bignum_bytes(a2, &v21, &v28))
  {
    uint64_t v14 = "RSA no coeff";
    goto LABEL_15;
  }
  if (_libssh2_get_bignum_bytes(a2, &v23, &v30))
  {
    uint64_t v14 = "RSA no p";
    goto LABEL_15;
  }
  if (_libssh2_get_bignum_bytes(a2, &v22, &v29))
  {
    uint64_t v14 = "RSA no q";
    goto LABEL_15;
  }
  if (_libssh2_get_string(a2, &v20, &v27))
  {
    uint64_t v14 = "RSA no comment";
    goto LABEL_15;
  }
  _libssh2_rsa_new((uint64_t *)&v19, v25, v32, v26, v33, v24, v31, v23, v30, v22, v29, 0, 0, 0, 0, v21, v28);
  int v17 = v19;
  if (v19)
  {
    uint64_t v15 = _libssh2_rsa_new_additional_parameters(v19);
    if (a3)
    {
      if (a5)
      {
        int v18 = EVP_PKEY_new();
        EVP_PKEY_set1_RSA(v18, v17);
        uint64_t v15 = gen_publickey_from_rsa_evp(a1, a3, a4, a5, a6, v18);
        if (v18) {
          EVP_PKEY_free(v18);
        }
      }
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  if (a7) {
    *a7 = v17;
  }
  else {
    RSA_free(v17);
  }
  return v15;
}

uint64_t _libssh2_rsa_new_additional_parameters(void *a1)
{
  int v16 = 0;
  int v17 = 0;
  m = 0;
  RSA_get0_key(a1, 0, 0, &m);
  RSA_get0_factors((uint64_t)a1, &v17, &v16);
  uint64_t v2 = BN_CTX_new();
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  BOOL v3 = v2;
  unint64_t v4 = BN_new();
  if (!v4)
  {
    BN_CTX_free(v3);
    return 0xFFFFFFFFLL;
  }
  int v5 = v4;
  BOOL v6 = BN_new();
  if (v6)
  {
    unsigned int v7 = BN_new();
    if (v7)
    {
      uint64_t v8 = v16;
      uint64_t v9 = BN_value_one();
      if (BN_sub(v5, v8, v9))
      {
        if (BN_div(0, v7, m, v5, v3))
        {
          uint64_t v10 = v17;
          int v11 = BN_value_one();
          if (BN_sub(v5, v10, v11))
          {
            if (BN_div(0, v6, m, v5, v3))
            {
              RSA_set0_crt_params((uint64_t)a1, (uint64_t)v6, (uint64_t)v7, 0);
              uint64_t v12 = 0;
              char v13 = 1;
              goto LABEL_14;
            }
          }
        }
      }
    }
  }
  else
  {
    unsigned int v7 = 0;
  }
  char v13 = 0;
  uint64_t v12 = 0xFFFFFFFFLL;
LABEL_14:
  BN_clear_free(v5);
  BN_CTX_free(v3);
  if ((v13 & 1) == 0)
  {
    if (v6) {
      BN_clear_free(v6);
    }
    if (v7) {
      BN_clear_free(v7);
    }
  }
  return v12;
}

uint64_t gen_publickey_from_dsa_openssh_priv_data(uint64_t a1, void *a2, void *a3, void *a4, void *a5, char **a6, DSA **a7)
{
  uint64_t v29 = 0;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  uint64_t v23 = 0;
  int v24 = 0;
  int v21 = 0;
  uint64_t v22 = 0;
  r = 0;
  uint64_t v20 = 0;
  if (_libssh2_get_bignum_bytes(a2, &v24, &v29))
  {
    uint64_t v14 = "DSA no p";
LABEL_11:
    _libssh2_error(a1, 4294967282, v14);
    return 0xFFFFFFFFLL;
  }
  if (_libssh2_get_bignum_bytes(a2, &v23, &v28))
  {
    uint64_t v14 = "DSA no q";
    goto LABEL_11;
  }
  if (_libssh2_get_bignum_bytes(a2, &v22, &v27))
  {
    uint64_t v14 = "DSA no g";
    goto LABEL_11;
  }
  if (_libssh2_get_bignum_bytes(a2, &v21, &v26))
  {
    uint64_t v14 = "DSA no public key";
    goto LABEL_11;
  }
  if (_libssh2_get_bignum_bytes(a2, &v20, &v25))
  {
    uint64_t v14 = "DSA no private key";
    goto LABEL_11;
  }
  _libssh2_dsa_new((uint64_t *)&r, v24, v29, v23, v28, v22, v27, v21, v26, v20, v25);
  uint64_t v15 = 0;
  int v17 = r;
  if (a3)
  {
    if (a5)
    {
      if (r)
      {
        int v18 = EVP_PKEY_new();
        EVP_PKEY_set1_DSA(v18, v17);
        uint64_t v15 = gen_publickey_from_dsa_evp(a1, a3, a4, a5, a6, v18);
        if (v18) {
          EVP_PKEY_free(v18);
        }
      }
    }
  }
  if (a7) {
    *a7 = v17;
  }
  else {
    DSA_free(v17);
  }
  return v15;
}

uint64_t gen_publickey_from_ecdsa_openssh_priv_data(uint64_t a1, int a2, void *a3, const char **a4, size_t *a5, void *a6, uint64_t *a7, EC_KEY **a8)
{
  *(void *)len = 0;
  uint64_t v32 = 0;
  uint64_t v29 = 0;
  *(void *)uint64_t v30 = 0;
  *(void *)uint64_t v27 = 0;
  s = 0;
  uint64_t key = 0;
  if (_libssh2_get_string(a3, &v29, &v32) || !v32)
  {
    int v16 = "ECDSA no curve";
    goto LABEL_6;
  }
  if (_libssh2_get_string(a3, v27, v30))
  {
    int v16 = "ECDSA no point";
LABEL_6:
    _libssh2_error(a1, 4294967282, v16);
    return 0xFFFFFFFFLL;
  }
  if (_libssh2_get_bignum_bytes(a3, &s, len))
  {
    int v16 = "ECDSA no exponent";
    goto LABEL_6;
  }
  if (_libssh2_ecdsa_curve_name_with_octal_new(&key, *(const unsigned __int8 **)v27, *(size_t *)v30, a2))
  {
    int v19 = "ECDSA could not create key";
    uint64_t v20 = a1;
    uint64_t v21 = 4294967282;
    goto LABEL_13;
  }
  uint64_t v22 = BN_new();
  if (!v22)
  {
    int v19 = "Unable to allocate memory for private key data";
    uint64_t v20 = a1;
    uint64_t v21 = 4294967290;
LABEL_13:
    _libssh2_error(v20, v21, v19);
    if (key) {
      EC_KEY_free(key);
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v23 = v22;
  BN_bin2bn(s, len[0], v22);
  int v24 = EC_KEY_set_private_key(key, v23);
  uint64_t v17 = v24 != 1;
  if (a4)
  {
    if (a6)
    {
      if (v24 == 1)
      {
        if (key)
        {
          uint64_t v25 = EVP_PKEY_new();
          EVP_PKEY_set1_EC_KEY(v25, key);
          uint64_t v17 = gen_publickey_from_ec_evp(a1, a4, a5, a6, a7, 0, v25);
          if (v25) {
            EVP_PKEY_free(v25);
          }
        }
      }
    }
  }
  if (a8) {
    *a8 = key;
  }
  else {
    EC_KEY_free(key);
  }
  return v17;
}

uint64_t gen_publickey_from_sk_ecdsa_openssh_priv_data(uint64_t a1, void *a2, const char **a3, size_t *a4, void *a5, uint64_t *a6, unsigned char *a7, void **a8, void *a9, size_t *a10, EC_KEY **a11)
{
  *(void *)int v37 = 0;
  uint64_t v38 = 0;
  uint64_t v35 = 0;
  size_t __n = 0;
  uint64_t v33 = 0;
  *(void *)size_t v34 = 0;
  uint64_t key = 0;
  uint64_t v32 = 0;
  if (_libssh2_get_string(a2, &v35, &v38) || !v38)
  {
    int v19 = "ECDSA no curve";
    goto LABEL_6;
  }
  if (_libssh2_get_string(a2, v34, v37))
  {
    int v19 = "ECDSA no point";
LABEL_6:
    _libssh2_error(a1, 4294967282, v19);
    return 0xFFFFFFFFLL;
  }
  if (!_libssh2_ecdsa_curve_name_with_octal_new(&key, *(const unsigned __int8 **)v34, *(size_t *)v37, 415))
  {
    if (_libssh2_get_string(a2, &v32, &__n))
    {
      uint64_t v22 = "No SK application.";
    }
    else
    {
      if (!a7 || !_libssh2_get_byte(a2, a7))
      {
        if (a9 && a10)
        {
          char __src = 0;
          if (_libssh2_get_string(a2, &__src, a10))
          {
            uint64_t v22 = "No SK key_handle.";
            goto LABEL_13;
          }
          if (*a10)
          {
            uint64_t v23 = (void *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(*a10, a1);
            *a9 = v23;
            if (v23) {
              memcpy(v23, __src, *a10);
            }
          }
        }
        uint64_t v20 = 0;
        if (a5)
        {
          if (a3)
          {
            if (key)
            {
              int v24 = EVP_PKEY_new();
              EVP_PKEY_set1_EC_KEY(v24, key);
              uint64_t v20 = gen_publickey_from_ec_evp(a1, a3, a4, a5, a6, 1, v24);
              if (v24) {
                EVP_PKEY_free(v24);
              }
            }
          }
        }
        if (a5 && !v20)
        {
          size_t v25 = *a6 + __n + 4;
          uint64_t v26 = (char *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(v25, a1);
          if (!v26) {
            goto LABEL_10;
          }
          uint64_t v27 = v26;
          size_t v28 = *a6;
          uint64_t v33 = &v26[*a6];
          memcpy(v26, (const void *)*a5, v28);
          _libssh2_store_str((_DWORD **)&v33, v32, __n);
          if (a8 && __n)
          {
            uint64_t v29 = (void *)(*(uint64_t (**)(size_t, uint64_t))(a1 + 8))(__n + 1, a1);
            *a8 = v29;
            memset_s(v29, __n + 1, 0, __n + 1);
            memcpy(*a8, v32, __n);
          }
          (*(void (**)(void, uint64_t))(a1 + 24))(*a5, a1);
          *a6 = v25;
          *a5 = v27;
        }
        if (a11) {
          *a11 = key;
        }
        else {
          EC_KEY_free(key);
        }
        return v20;
      }
      uint64_t v22 = "No SK flags.";
    }
LABEL_13:
    _libssh2_error(a1, 4294967282, v22);
    uint64_t v20 = 0;
    goto LABEL_14;
  }
  _libssh2_error(a1, 4294967282, "ECDSA could not create key");
LABEL_10:
  uint64_t v20 = 0xFFFFFFFFLL;
LABEL_14:
  if (key) {
    EC_KEY_free(key);
  }
  if (a8 && *a8)
  {
    (*(void (**)(void **, uint64_t))(a1 + 24))(a8, a1);
    *a8 = 0;
  }
  if (a9 && *a9)
  {
    (*(void (**)(void *, uint64_t))(a1 + 24))(a9, a1);
    *a9 = 0;
  }
  return v20;
}

void _libssh2_cipher_crypt_cold_1()
{
  __assert_rtn("_libssh2_cipher_crypt", "openssl.c", 538, "blocksize <= sizeof(buf)");
}

void _libssh2_cipher_crypt_cold_2()
{
  __assert_rtn("_libssh2_cipher_crypt", "openssl.c", 539, "cryptlen >= 0");
}

uint64_t userauth_keyboard_interactive_decode_info_request(void *a1)
{
  uint64_t v2 = a1 + 9038;
  unint64_t v3 = a1[9039];
  v13[0] = a1[9038];
  v13[1] = v13[0];
  _OWORD v13[2] = v3;
  if (v3 > 0x10)
  {
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    char v15 = 0;
    unsigned int v14 = 0;
    _libssh2_get_byte(v13, &v15);
    if (_libssh2_copy_string((uint64_t)a1, v13, a1 + 9043, a1 + 9042) == -1)
    {
      unint64_t v4 = "Unable to decode keyboard-interactive 'name' request field";
    }
    else if (_libssh2_copy_string((uint64_t)a1, v13, a1 + 9045, a1 + 9044) == -1)
    {
      unint64_t v4 = "Unable to decode keyboard-interactive 'instruction' request field";
    }
    else if (_libssh2_get_string(v13, &v17, &v16) == -1)
    {
      unint64_t v4 = "Unable to decode keyboard-interactive 'language tag' request field";
    }
    else
    {
      if (_libssh2_get_u32(v13, &v14) == -1)
      {
        unint64_t v4 = "Unable to decode keyboard-interactive number of keyboard prompts";
        goto LABEL_3;
      }
      uint64_t v7 = v14;
      *((_DWORD *)v2 + 16) = v14;
      if (v7 > 0x64)
      {
        unint64_t v4 = "Too many replies for keyboard-interactive prompts";
        uint64_t v5 = (uint64_t)a1;
        uint64_t v6 = 4294967255;
        goto LABEL_14;
      }
      if (!v7) {
        return 0;
      }
      uint64_t v9 = _libssh2_calloc((uint64_t)a1, 24 * v7);
      v2[9] = v9;
      if (v9)
      {
        uint64_t v10 = _libssh2_calloc((uint64_t)a1, 16 * *((unsigned int *)v2 + 16));
        v2[10] = v10;
        if (v10)
        {
          if (*((_DWORD *)v2 + 16))
          {
            uint64_t v11 = 0;
            unint64_t v12 = 0;
            while (1)
            {
              if (_libssh2_copy_string((uint64_t)a1, v13, (void *)(v2[9] + v11), (size_t *)(v2[9] + v11 + 8)) == -1)
              {
                unint64_t v4 = "Unable to decode keyboard-interactive prompt message";
                goto LABEL_13;
              }
              if (_libssh2_get_BOOLean(v13, (BOOL *)(v2[9] + v11 + 16)) == -1) {
                break;
              }
              uint64_t result = 0;
              ++v12;
              v11 += 24;
              if (v12 >= *((unsigned int *)v2 + 16)) {
                return result;
              }
            }
            unint64_t v4 = "Unable to decode user auth keyboard prompt echo";
            goto LABEL_3;
          }
          return 0;
        }
        unint64_t v4 = "Unable to allocate memory for keyboard-interactive responses array";
      }
      else
      {
        unint64_t v4 = "Unable to allocate memory for keyboard-interactive prompts array";
      }
    }
LABEL_13:
    uint64_t v5 = (uint64_t)a1;
    uint64_t v6 = 4294967290;
    goto LABEL_14;
  }
  unint64_t v4 = "userauth keyboard data buffer too small to get length";
LABEL_3:
  uint64_t v5 = (uint64_t)a1;
  uint64_t v6 = 4294967258;
LABEL_14:
  _libssh2_error(v5, v6, v4);
  return 0xFFFFFFFFLL;
}

uint64_t _libssh2_transport_read(uint64_t a1)
{
  uint64_t v70 = *MEMORY[0x263EF8340];
  *(_DWORD *)(a1 + 600) &= ~1u;
  if ((*(_DWORD *)(a1 + 128) & 9) == 1)
  {
    uint64_t v2 = _libssh2_kex_exchange(a1, 1, a1 + 71088);
    if (v2) {
      return v2;
    }
  }
  unint64_t v3 = (int64_t *)(a1 + 35632);
  if (*(_DWORD *)(a1 + 72040) == 11)
  {
    *(_DWORD *)(a1 + 72040) = 0;
    int v63 = *(_DWORD *)(a1 + 72044);
LABEL_5:
    unint64_t v4 = (_DWORD *)(a1 + 72040);
    int v5 = *(_DWORD *)(a1 + 72872);
    if (v5)
    {
      if (v5 != 2) {
        goto LABEL_110;
      }
      uint64_t v6 = *(unsigned __int8 **)(a1 + 35672);
      unint64_t v7 = *(void *)(a1 + 72880);
LABEL_107:
      uint64_t v56 = _libssh2_packet_add(a1, v6, v7, v4[209]);
      if (v56)
      {
        uint64_t v2 = v56;
        if (v56 == -37)
        {
LABEL_112:
          if (v4[140])
          {
            *unint64_t v4 = 11;
            v4[1] = v63;
          }
          return 4294967259;
        }
        v4[208] = 0;
LABEL_111:
        if (v2 != -37)
        {
LABEL_120:
          *(void *)(a1 + 35664) = 0;
          return v2;
        }
        goto LABEL_112;
      }
LABEL_110:
      v4[208] = 0;
      uint64_t v2 = v4[212];
      goto LABEL_111;
    }
    *(_DWORD *)(a1 + 72876) = 0;
    uint64_t v43 = (*(_DWORD *)(a1 + 35648) - 1);
    *(void *)(a1 + 72880) = v43;
    if (v63)
    {
      uint64_t v44 = *(void *)(a1 + 448);
      if (!v44 || (*(unsigned char *)(v44 + 32) & 1) == 0)
      {
        uint64_t v45 = *(void *)(a1 + 352);
        int v46 = *(_DWORD *)(v45 + 40);
        size_t v47 = *(int *)(v45 + 8);
        int v48 = *(void (**)(uint64_t, unsigned char *, void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v45 + 24);
        if (v46)
        {
          uint64_t v49 = *(void *)(a1 + 35672);
          uint64_t v50 = *(void *)(a1 + 35664) - v47;
          uint64_t v51 = a1 + 368;
          uint64_t v52 = a1;
          uint64_t v53 = 0;
          uint64_t v43 = 0;
        }
        else
        {
          uint64_t v49 = a1 + 35624;
          uint64_t v53 = *(void *)(a1 + 35672);
          uint64_t v51 = a1 + 368;
          uint64_t v52 = a1;
          uint64_t v50 = 5;
        }
        v48(v52, __s1, *(unsigned int *)(a1 + 360), v49, v50, v53, v43, v51);
        uint64_t v54 = *(void *)(a1 + 35672);
        if (!memcmp(__s1, (const void *)(v54 + *(void *)(a1 + 35664) - v47), v47))
        {
          if (v46)
          {
            uint64_t v57 = *(int *)(*(void *)(a1 + 336) + 16);
            uint64_t v2 = decrypt(a1, (char *)(v54 + 4), v68, v57, 1u);
            if (!v2)
            {
              uint64_t v59 = *(void *)(a1 + 35664) - v47 - 4;
              unint64_t v60 = (char *)(*(uint64_t (**)(uint64_t, uint64_t))(a1 + 8))(v59, a1);
              if (v60)
              {
                unint64_t v61 = v60;
                *(unsigned char *)(a1 + 35652) = v68[0];
                if ((int)v57 >= 2) {
                  memcpy(v60, &v68[1], (v57 - 1));
                }
                if (v59 <= v57
                  || (uint64_t v62 = decrypt(a1, (char *)(*(void *)(a1 + 35672) + v57 + 4), &v61[v57 - 1], v59 - v57, 2u),
                      !v62))
                {
                  (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(a1 + 35672), a1);
                  *(void *)(a1 + 35672) = v61;
                  goto LABEL_99;
                }
                uint64_t v2 = v62;
                (*(void (**)(char *, uint64_t))(a1 + 24))(v61, a1);
              }
              else
              {
                uint64_t v2 = 4294967290;
              }
            }
            unint64_t v4 = (_DWORD *)(a1 + 72040);
            goto LABEL_111;
          }
        }
        else
        {
          *(_DWORD *)(a1 + 72876) = -1;
        }
      }
    }
LABEL_99:
    ++*(_DWORD *)(a1 + 360);
    unint64_t v4 = (_DWORD *)(a1 + 72040);
    unint64_t v7 = *(void *)(a1 + 72880) - *(unsigned __int8 *)(a1 + 35652);
    *(void *)(a1 + 72880) = v7;
    uint64_t v55 = *(void *)(a1 + 488);
    if (v55
      && *(_DWORD *)(v55 + 8)
      && ((*(unsigned char *)(a1 + 128) & 4) != 0 || *(_DWORD *)(v55 + 12))
      && *(void *)(a1 + 384))
    {
      *(void *)uint64_t v68 = 0;
      unint64_t v64 = 0;
      uint64_t v2 = (*(uint64_t (**)(uint64_t, char *, unint64_t *, uint64_t, void))(*(void *)(a1 + 376) + 32))(a1, v68, &v64, 40000, *(void *)(a1 + 35672));
      (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(a1 + 35672), a1);
      if (v2) {
        goto LABEL_111;
      }
      *(void *)(a1 + 35672) = *(void *)v68;
      unint64_t v7 = v64;
      *(void *)(a1 + 72880) = v64;
    }
    uint64_t v6 = *(unsigned __int8 **)(a1 + 35672);
    *(_DWORD *)(a1 + 72888) = *v6;
    *(_DWORD *)(a1 + 72872) = 2;
    goto LABEL_107;
  }
  uint64_t v8 = a1 + 624;
  int v63 = 1;
  while (1)
  {
    if (*(_DWORD *)(a1 + 596) == -1) {
      return 4294967283;
    }
    if ((*(unsigned char *)(a1 + 128) & 2) == 0)
    {
      int v63 = 0;
      int v9 = 0;
      int v10 = 5;
LABEL_16:
      char v12 = 1;
      goto LABEL_17;
    }
    int v10 = *(_DWORD *)(*(void *)(a1 + 336) + 16);
    if (!v63)
    {
      int v63 = 0;
      int v9 = 0;
      goto LABEL_16;
    }
    uint64_t v11 = *(void *)(a1 + 464);
    char v12 = 0;
    int v9 = v11 ? *(_DWORD *)(v11 + 40) : 0;
LABEL_17:
    uint64_t v13 = *(void *)(a1 + 35640);
    int64_t v14 = *v3 - v13;
    if (v14 < 0) {
      _libssh2_transport_read_cold_1();
    }
    if (v14 < v10) {
      break;
    }
LABEL_23:
    uint64_t v17 = v10;
    uint64_t v18 = *(void *)(a1 + 35664);
    if (v18)
    {
      uint64_t v19 = *(void *)(a1 + 35656);
    }
    else
    {
      if (v9) {
        int v20 = 4;
      }
      else {
        int v20 = v10;
      }
      if (v14 < v20) {
        goto LABEL_94;
      }
      uint64_t v21 = (char *)(v8 + v13);
      if (!v9)
      {
        if (v12)
        {
          __memcpy_chk();
        }
        else
        {
          uint64_t v22 = decrypt(a1, v21, (char *)&v65, v10, 1u);
          if (v22) {
            return v22;
          }
          *(_DWORD *)(a1 + 35624) = v65;
          *(unsigned char *)(a1 + 35628) = v66;
          uint64_t v13 = *(void *)(a1 + 35640);
        }
        *(void *)(a1 + 35640) = v13 + v10;
        uint64_t v21 = (char *)&v65;
      }
      unsigned int v23 = _libssh2_ntohu32((unsigned int *)v21);
      *(_DWORD *)(a1 + 35648) = v23;
      if (!v23) {
        return 4294967284;
      }
      if (v23 > 0x9C40) {
        return 4294967255;
      }
      if (v9)
      {
        unsigned int v24 = v23 + *(_DWORD *)(*(void *)(a1 + 352) + 8) + 4;
      }
      else
      {
        unsigned int v25 = v66;
        *(unsigned char *)(a1 + 35652) = v66;
        if (v23 - 1 < v25) {
          return 4294967284;
        }
        if (v12) {
          int v26 = 0;
        }
        else {
          int v26 = *(_DWORD *)(*(void *)(a1 + 352) + 8);
        }
        unsigned int v24 = v26 + v23 - 1;
      }
      if (v24 - 40001 < 0xFFFF63C0) {
        return 4294967255;
      }
      uint64_t v18 = v24;
      uint64_t v27 = (unsigned char *)(*(uint64_t (**)(void, uint64_t))(a1 + 8))(v24, a1);
      *(void *)(a1 + 35672) = v27;
      if (!v27) {
        return 4294967290;
      }
      *(void *)(a1 + 35664) = v18;
      *(void *)(a1 + 35680) = v27;
      if (v9 || v10 < 6)
      {
        uint64_t v29 = v27;
      }
      else
      {
        size_t v28 = (v10 - 5);
        if (v28 > v18)
        {
          (*(void (**)(void))(a1 + 24))();
          return 4294967255;
        }
        memcpy(v27, v67, v28);
        uint64_t v27 = *(unsigned char **)(a1 + 35672);
        uint64_t v29 = (unsigned char *)(*(void *)(a1 + 35680) + v28);
        *(void *)(a1 + 35680) = v29;
        uint64_t v18 = *(void *)(a1 + 35664);
      }
      uint64_t v19 = v29 - v27;
      *(void *)(a1 + 35656) = v19;
      if (v9) {
        uint64_t v30 = 0;
      }
      else {
        uint64_t v30 = v17;
      }
      v14 -= v30;
    }
    if (v14 >= v18 - v19) {
      int64_t v14 = v18 - v19;
    }
    if (v9) {
      char v31 = 1;
    }
    else {
      char v31 = v12;
    }
    if ((v31 & 1) == 0)
    {
      int v32 = *(_DWORD *)(*(void *)(a1 + 352) + 8);
      uint64_t v33 = *(void *)(a1 + 336);
      if (v33 && (*(unsigned char *)(v33 + 32) & 1) != 0) {
        int v32 = 0;
      }
      unint64_t v34 = v18 - v32;
      if (v14 + v19 >= v34)
      {
        int v39 = v34 - v19;
        uint64_t v35 = v39 & ~(v39 >> 31);
        unsigned int v38 = 2;
        if ((v39 & ~(v39 >> 31)) == 0) {
          goto LABEL_80;
        }
      }
      else
      {
        uint64_t v35 = v14 / v17 * v17;
        if (v14 != v35) {
          int64_t v14 = 0;
        }
        if (v33)
        {
          char v36 = *(unsigned char *)(v33 + 32);
          LODWORD(v37) = v18 - (v19 + v17) - v32;
          uint64_t v37 = v35 >= (int)v37 ? (int)v37 : v35;
          if (v36)
          {
            int64_t v14 = 0;
            uint64_t v35 = v37;
          }
        }
        if (v35 < 0) {
          _libssh2_transport_read_cold_2();
        }
        unsigned int v38 = 0;
        if (!v35) {
          goto LABEL_80;
        }
      }
      uint64_t v40 = decrypt(a1, (char *)(v8 + *(void *)(a1 + 35640)), *(char **)(a1 + 35680), v35, v38);
      if (v40)
      {
        uint64_t v2 = v40;
        goto LABEL_120;
      }
      *(void *)(a1 + 35640) += v35;
      *(void *)(a1 + 35680) += v35;
      uint64_t v18 = *(void *)(a1 + 35664);
      uint64_t v19 = *(void *)(a1 + 35656) + v35;
      *(void *)(a1 + 35656) = v19;
      v14 -= v35;
    }
LABEL_80:
    if (v14 >= 1)
    {
      uint64_t v42 = *(void *)(a1 + 35672);
      int v41 = *(void **)(a1 + 35680);
      if (v14 <= (unint64_t)(v18 - (void)v41 + v42))
      {
        memcpy(v41, (const void *)(v8 + *(void *)(a1 + 35640)), v14);
        *(void *)(a1 + 35640) += v14;
        *(void *)(a1 + 35680) += v14;
        uint64_t v18 = *(void *)(a1 + 35664);
        uint64_t v19 = *(void *)(a1 + 35656) + v14;
        *(void *)(a1 + 35656) = v19;
        goto LABEL_83;
      }
      if (v42) {
        (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(a1 + 35672), a1);
      }
      return 4294967255;
    }
LABEL_83:
    if (v18 == v19) {
      goto LABEL_5;
    }
  }
  if (v14) {
    memmove((void *)(a1 + 624), (const void *)(v8 + v13), *v3 - v13);
  }
  *unint64_t v3 = v14;
  *(void *)(a1 + 35640) = 0;
  uint64_t v15 = (*(uint64_t (**)(void, uint64_t, int64_t, void, uint64_t))(a1 + 104))(*(unsigned int *)(a1 + 592), v8 + v14, 35000 - v14, (*(_DWORD *)(a1 + 132) == 0) << 19, a1);
  if (v15 > 0)
  {
    uint64_t v13 = *(void *)(a1 + 35640);
    uint64_t v16 = *v3 + v15;
    *unint64_t v3 = v16;
    int64_t v14 = v16 - v13;
    goto LABEL_23;
  }
  if (v15 == -35)
  {
LABEL_94:
    *(_DWORD *)(a1 + 600) |= 1u;
    return 4294967259;
  }
  return 4294967253;
}

uint64_t decrypt(uint64_t a1, char *a2, char *a3, uint64_t a4, unsigned int a5)
{
  uint64_t v6 = a4;
  int64_t v10 = *(int *)(*(void *)(a1 + 336) + 16);
  uint64_t v11 = *(void *)(a1 + 448);
  if ((!v11 || (*(unsigned char *)(v11 + 32) & 2) == 0) && a4 % v10) {
    decrypt_cold_1();
  }
  if (a4 < 1) {
    return 0;
  }
  uint64_t v12 = 2 * (int)v10;
  while (1)
  {
    if (v6 >= v10) {
      int64_t v13 = v10;
    }
    else {
      int64_t v13 = v6;
    }
    if (v6 <= v10) {
      unsigned int v14 = a5;
    }
    else {
      unsigned int v14 = 0;
    }
    if (a5) {
      uint64_t v15 = 1;
    }
    else {
      uint64_t v15 = v14;
    }
    uint64_t v16 = *(void *)(a1 + 448);
    if (v16)
    {
      uint64_t v17 = *(void *)(v16 + 32) & 2;
      if (v6 >= v12) {
        int64_t v18 = v13;
      }
      else {
        int64_t v18 = v6;
      }
      if (v6 >= v12) {
        int v19 = v15;
      }
      else {
        int v19 = 2;
      }
      BOOL v20 = v17 == 0;
      if (v17) {
        int64_t v21 = v18;
      }
      else {
        int64_t v21 = v13;
      }
      if (v20) {
        unsigned int v22 = v15;
      }
      else {
        unsigned int v22 = v19;
      }
      if ((a5 & 2) != 0)
      {
        int64_t v13 = v21;
        uint64_t v15 = v22;
      }
      else
      {
        uint64_t v15 = v15;
      }
    }
    if ((*(unsigned int (**)(uint64_t, char *, int64_t, uint64_t, uint64_t))(*(void *)(a1 + 336) + 48))(a1, a2, v13, a1 + 344, v15))
    {
      break;
    }
    memcpy(a3, a2, v13);
    a3 += v13;
    a2 += v13;
    BOOL v23 = v6 <= v13;
    v6 -= v13;
    if (v23) {
      return 0;
    }
  }
  (*(void (**)(void, uint64_t))(a1 + 24))(*(void *)(a1 + 35672), a1);
  return 4294967284;
}

uint64_t _libssh2_transport_send(uint64_t a1, void *__src, size_t __n, const void *a4, size_t a5)
{
  if ((*(_DWORD *)(a1 + 128) & 2) != 0) {
    int v10 = *(_DWORD *)(*(void *)(a1 + 448) + 16);
  }
  else {
    int v10 = 8;
  }
  if ((*(_DWORD *)(a1 + 128) & 9) != 1 || (uint64_t result = _libssh2_kex_exchange(a1, 1, a1 + 71088), !result))
  {
    uint64_t v12 = (void *)(a1 + 70688);
    if (*(void *)(a1 + 70704))
    {
      uint64_t v13 = *(void *)(a1 + 70712);
      uint64_t v14 = *v12 - v13;
      uint64_t v15 = (*(uint64_t (**)(void, uint64_t, uint64_t, void, uint64_t))(a1 + 96))(*(unsigned int *)(a1 + 592), a1 + 35688 + v13, v14, (*(_DWORD *)(a1 + 132) == 0) << 19, a1);
      if (v15 == v14)
      {
        *uint64_t v12 = 0;
        *(void *)(a1 + 70704) = 0;
LABEL_14:
        uint64_t result = 0;
        *(_DWORD *)(a1 + 600) &= ~2u;
        return result;
      }
      if ((v15 & 0x8000000000000000) == 0)
      {
        *(void *)(a1 + 70712) += v15;
        if (v15 >= v14) {
          goto LABEL_14;
        }
        return 4294967259;
      }
      if (v15 == -35)
      {
        *(_DWORD *)(a1 + 600) |= 2u;
        return 4294967259;
      }
      return 4294967289;
    }
    *(_DWORD *)(a1 + 600) &= ~2u;
    int v16 = *(_DWORD *)(a1 + 128);
    if ((v16 & 2) != 0 && (uint64_t v17 = *(void *)(a1 + 464)) != 0) {
      int v18 = *(_DWORD *)(v17 + 40);
    }
    else {
      int v18 = 0;
    }
    uint64_t v19 = *(void *)(a1 + 488);
    if (!v19 || !*(_DWORD *)(v19 + 8)) {
      goto LABEL_33;
    }
    if ((v16 & 4) != 0)
    {
      BOOL v20 = 1;
      if ((v16 & 2) == 0) {
        goto LABEL_33;
      }
    }
    else
    {
      BOOL v20 = *(_DWORD *)(v19 + 12) != 0;
      if ((v16 & 2) == 0) {
        goto LABEL_33;
      }
    }
    if (v20 && *(void *)(a1 + 496))
    {
      uint64_t v49 = 34739;
      uint64_t v50 = 34739;
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *, void *, size_t, uint64_t))(v19 + 24))(a1, a1 + 35693, &v50, __src, __n, a1 + 496);
      if (result) {
        return result;
      }
      uint64_t v21 = 0;
      if (a4 && a5)
      {
        v49 -= v50;
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *, const void *, size_t, uint64_t))(*(void *)(a1 + 488) + 24))(a1, v50 + a1 + 35693, &v49, a4, a5, a1 + 496);
        if (result) {
          return result;
        }
        uint64_t v21 = v49;
      }
      uint64_t v22 = v21 + v50;
LABEL_38:
      uint64_t v23 = v22 + 5;
      size_t v47 = __src;
      int v48 = v18;
      if ((v16 & 2) == 0 || v18)
      {
        if (v18)
        {
          uint64_t v25 = 4;
          goto LABEL_45;
        }
      }
      else
      {
        uint64_t v24 = *(void *)(a1 + 336);
        if (v24)
        {
          uint64_t v25 = 0;
          unint64_t v26 = 0;
          uint64_t v27 = 0;
          if ((*(void *)(v24 + 32) & 2) == 0)
          {
LABEL_47:
            uint64_t v28 = 0;
            uint64_t v29 = v10;
            int64_t v30 = (v27 + v23) / (unint64_t)v10 * v10 - (v27 + v23) + v10;
            if (v30 >= 4) {
              uint64_t v29 = 0;
            }
            unint64_t v31 = v29 + v30;
            unint64_t v32 = v29 + v30 + v23;
            if ((v16 & 2) != 0) {
              uint64_t v28 = *(int *)(*(void *)(a1 + 464) + 8);
            }
            uint64_t v33 = a1 + 35688;
            _libssh2_htonu32((_DWORD *)(a1 + 35688), v32 - 4);
            *(unsigned char *)(a1 + 35692) = v31;
            if (_libssh2_openssl_random((unsigned __int8 *)(a1 + 35688 + v22 + 5), v31)) {
              return _libssh2_error(a1, 4294967247, "Unable to get random bytes for packet padding");
            }
            uint64_t v34 = v28 + v32;
            if ((v16 & 2) != 0)
            {
              if (!v48)
              {
                uint64_t v35 = *(void *)(a1 + 336);
                if (!v35 || (*(unsigned char *)(v35 + 32) & 1) == 0) {
                  (*(void (**)(uint64_t, unint64_t, void, uint64_t, unint64_t, void, void, uint64_t))(*(void *)(a1 + 464) + 24))(a1, v33 + v32, *(unsigned int *)(a1 + 472), a1 + 35688, v32, 0, 0, a1 + 480);
                }
              }
              if (v26 < v32)
              {
                uint64_t v36 = *(void *)(a1 + 448);
                LODWORD(v37) = *(_DWORD *)(v36 + 16);
                while (1)
                {
                  uint64_t v38 = a1 + v26 + 35688;
                  unint64_t v39 = v32 - v26;
                  if ((int)v37 >= (int)v32 - (int)v26) {
                    int v40 = v32 - v26;
                  }
                  else {
                    int v40 = v37;
                  }
                  uint64_t v41 = *(void *)(v36 + 32);
                  unint64_t v42 = v32 - (int)v37;
                  if (v26 == v42) {
                    unsigned int v43 = 2;
                  }
                  else {
                    unsigned int v43 = 0;
                  }
                  if (v41) {
                    unsigned int v43 = 0;
                  }
                  if (v26) {
                    uint64_t v44 = v43;
                  }
                  else {
                    uint64_t v44 = 1;
                  }
                  if (v26 <= v32 - 2 * v40)
                  {
                    unint64_t v42 = v26;
                    unint64_t v39 = v40;
                  }
                  if (v41)
                  {
                    unint64_t v45 = v40;
                  }
                  else
                  {
                    unint64_t v26 = v42;
                    unint64_t v45 = v39;
                  }
                  if ((*(unsigned int (**)(uint64_t, uint64_t, unint64_t, uint64_t, uint64_t))(v36 + 48))(a1, v38, v45, a1 + 456, v44))
                  {
                    return 4294967252;
                  }
                  uint64_t v36 = *(void *)(a1 + 448);
                  uint64_t v37 = *(int *)(v36 + 16);
                  v26 += v37;
                  if (v26 >= v32) {
                    goto LABEL_80;
                  }
                }
              }
              uint64_t v36 = *(void *)(a1 + 448);
              if (v36)
              {
LABEL_80:
                if (*(unsigned char *)(v36 + 32))
                {
                  if (v28 + v32 > v32 + *(int *)(v36 + 16)) {
                    _libssh2_transport_send_cold_1();
                  }
                  if ((*(unsigned int (**)(uint64_t, unint64_t, void, uint64_t, uint64_t))(v36 + 48))(a1, a1 + v32 + 35688, *(int *)(*(void *)(a1 + 464) + 8), a1 + 456, 2))
                  {
                    return 4294967252;
                  }
                }
              }
              uint64_t v34 = v28 + v32;
              if (v48) {
                (*(void (**)(uint64_t, unint64_t, void, uint64_t, unint64_t, void, void, uint64_t))(*(void *)(a1 + 464) + 24))(a1, v33 + v32, *(unsigned int *)(a1 + 472), a1 + 35688, v32, 0, 0, a1 + 480);
              }
            }
            ++*(_DWORD *)(a1 + 472);
            uint64_t v46 = (*(uint64_t (**)(void, uint64_t, uint64_t, void, uint64_t))(a1 + 96))(*(unsigned int *)(a1 + 592), a1 + 35688, v34, (*(_DWORD *)(a1 + 132) == 0) << 19, a1);
            if (v46 == v34)
            {
              uint64_t result = 0;
              *(_OWORD *)(a1 + 70696) = 0u;
              return result;
            }
            if ((v46 & 0x8000000000000000) == 0 || v46 == -35)
            {
              *(_DWORD *)(a1 + 600) |= 2u;
              *(void *)(a1 + 70704) = __n;
              *(void *)(a1 + 70712) = v46 & ~(v46 >> 63);
              *uint64_t v12 = v34;
              *(void *)(a1 + 70696) = v47;
              return 4294967259;
            }
            return 4294967289;
          }
LABEL_45:
          uint64_t v27 = -4;
          unint64_t v26 = v25;
          goto LABEL_47;
        }
      }
      unint64_t v26 = 0;
      uint64_t v27 = 0;
      goto LABEL_47;
    }
LABEL_33:
    uint64_t v22 = a5 + __n;
    if (a5 + __n > 0x87B7) {
      return 4294967262;
    }
    memcpy((void *)(a1 + 35693), __src, __n);
    if (a4 && a5) {
      memcpy((void *)(__n + a1 + 35693), a4, a5);
    }
    goto LABEL_38;
  }
  return result;
}

void _libssh2_transport_read_cold_1()
{
  __assert_rtn("_libssh2_transport_read", "transport.c", 436, "remainbuf >= 0");
}

void _libssh2_transport_read_cold_2()
{
  __assert_rtn("_libssh2_transport_read", "transport.c", 678, "numdecrypt >= 0");
}

void decrypt_cold_1()
{
  __assert_rtn("decrypt", "transport.c", 140, "(len % blocksize) == 0");
}

void _libssh2_transport_send_cold_1()
{
  __assert_rtn("_libssh2_transport_send", "transport.c", 1071, "(size_t)total_length <= packet_length + session->local.crypt->blocksize");
}

int *CRYPTO_hchacha_20(int *result, int *a2, int *a3)
{
  int v4 = *a2;
  int v3 = a2[1];
  int v5 = a2[2];
  int v6 = a2[3];
  int v7 = a2[4];
  int v8 = a2[5];
  int v9 = a2[6];
  int v10 = a2[7];
  int v12 = *a3;
  int v11 = a3[1];
  int v13 = 1797285236;
  int v14 = 2036477234;
  int v15 = 857760878;
  int v16 = 1634760805;
  unsigned int v17 = 22;
  int v18 = a3[2];
  int v19 = a3[3];
  do
  {
    int v20 = v16 + v4;
    int v21 = (v16 + v4) ^ v12;
    HIDWORD(v22) = v21;
    LODWORD(v22) = v21;
    int v23 = (v22 >> 16) + v7;
    int v24 = v23 ^ v4;
    HIDWORD(v22) = v24;
    LODWORD(v22) = v24;
    int v25 = (v22 >> 20) + v20;
    LODWORD(v22) = v25 ^ __ROR4__(v21, 16);
    int v26 = v22;
    HIDWORD(v22) = v22;
    int v27 = (v22 >> 24) + v23;
    LODWORD(v22) = v27 ^ __ROR4__(v24, 20);
    int v28 = v22;
    HIDWORD(v22) = v22;
    int v29 = v22 >> 25;
    int v30 = v15 + v3;
    int v31 = v30 ^ v11;
    HIDWORD(v22) = v31;
    LODWORD(v22) = v31;
    int v32 = (v22 >> 16) + v8;
    int v33 = v32 ^ v3;
    HIDWORD(v22) = v33;
    LODWORD(v22) = v33;
    int v34 = (v22 >> 20) + v30;
    LODWORD(v22) = v34 ^ __ROR4__(v31, 16);
    int v35 = v22;
    HIDWORD(v22) = v22;
    int v36 = (v22 >> 24) + v32;
    LODWORD(v22) = v36 ^ __ROR4__(v33, 20);
    int v37 = v22;
    HIDWORD(v22) = v22;
    int v38 = v22 >> 25;
    int v39 = v14 + v5;
    int v40 = v39 ^ v18;
    HIDWORD(v22) = v40;
    LODWORD(v22) = v40;
    int v41 = (v22 >> 16) + v9;
    int v42 = v41 ^ v5;
    HIDWORD(v22) = v42;
    LODWORD(v22) = v42;
    int v43 = (v22 >> 20) + v39;
    LODWORD(v22) = v43 ^ __ROR4__(v40, 16);
    int v44 = v22;
    HIDWORD(v22) = v22;
    int v45 = (v22 >> 24) + v41;
    LODWORD(v22) = v45 ^ __ROR4__(v42, 20);
    int v46 = v22;
    HIDWORD(v22) = v22;
    int v47 = v22 >> 25;
    int v48 = v13 + v6;
    int v49 = v48 ^ v19;
    HIDWORD(v22) = v49;
    LODWORD(v22) = v49;
    int v50 = (v22 >> 16) + v10;
    int v51 = v50 ^ v6;
    HIDWORD(v22) = v51;
    LODWORD(v22) = v51;
    int v52 = (v22 >> 20) + v48;
    LODWORD(v22) = v52 ^ __ROR4__(v49, 16);
    int v53 = v22;
    HIDWORD(v22) = v22;
    int v54 = (v22 >> 24) + v50;
    LODWORD(v22) = v54 ^ __ROR4__(v51, 20);
    int v55 = v22;
    HIDWORD(v22) = v22;
    int v56 = v22 >> 25;
    int v57 = v38 + v25;
    LODWORD(v22) = v57 ^ __ROR4__(v53, 24);
    int v58 = v22;
    HIDWORD(v22) = v22;
    int v59 = (v22 >> 16) + v45;
    LODWORD(v22) = v59 ^ __ROR4__(v37, 25);
    int v60 = v22;
    HIDWORD(v22) = v22;
    int v16 = (v22 >> 20) + v57;
    LODWORD(v22) = v16 ^ __ROR4__(v58, 16);
    HIDWORD(v22) = v22;
    int v19 = v22 >> 24;
    int v9 = v19 + v59;
    LODWORD(v22) = v9 ^ __ROR4__(v60, 20);
    HIDWORD(v22) = v22;
    int v3 = v22 >> 25;
    int v61 = v47 + v34;
    LODWORD(v22) = v61 ^ __ROR4__(v26, 24);
    int v62 = v22;
    HIDWORD(v22) = v22;
    int v63 = (v22 >> 16) + v54;
    LODWORD(v22) = v63 ^ __ROR4__(v46, 25);
    int v64 = v22;
    HIDWORD(v22) = v22;
    int v15 = (v22 >> 20) + v61;
    LODWORD(v22) = v15 ^ __ROR4__(v62, 16);
    HIDWORD(v22) = v22;
    int v12 = v22 >> 24;
    int v10 = v12 + v63;
    LODWORD(v22) = v10 ^ __ROR4__(v64, 20);
    HIDWORD(v22) = v22;
    int v5 = v22 >> 25;
    int v65 = v56 + v43;
    LODWORD(v22) = v65 ^ __ROR4__(v35, 24);
    int v66 = v22;
    HIDWORD(v22) = v22;
    int v67 = (v22 >> 16) + v27;
    LODWORD(v22) = v67 ^ __ROR4__(v55, 25);
    int v68 = v22;
    HIDWORD(v22) = v22;
    int v14 = (v22 >> 20) + v65;
    LODWORD(v22) = v14 ^ __ROR4__(v66, 16);
    HIDWORD(v22) = v22;
    int v11 = v22 >> 24;
    int v7 = v11 + v67;
    LODWORD(v22) = v7 ^ __ROR4__(v68, 20);
    HIDWORD(v22) = v22;
    int v6 = v22 >> 25;
    int v69 = v29 + v52;
    LODWORD(v22) = v69 ^ __ROR4__(v44, 24);
    int v70 = v22;
    HIDWORD(v22) = v22;
    int v71 = (v22 >> 16) + v36;
    LODWORD(v22) = v71 ^ __ROR4__(v28, 25);
    int v72 = v22;
    HIDWORD(v22) = v22;
    int v13 = (v22 >> 20) + v69;
    LODWORD(v22) = v13 ^ __ROR4__(v70, 16);
    HIDWORD(v22) = v22;
    int v18 = v22 >> 24;
    int v8 = v18 + v71;
    v17 -= 2;
    LODWORD(v22) = v8 ^ __ROR4__(v72, 20);
    HIDWORD(v22) = v22;
    int v4 = v22 >> 25;
  }
  while (v17 > 2);
  *uint64_t result = v16;
  result[1] = v15;
  result[2] = v14;
  result[3] = v13;
  result[4] = v12;
  result[5] = v11;
  result[6] = v18;
  result[7] = v19;
  return result;
}

int8x8_t ChaCha_set_key(uint64_t a1, _DWORD *a2, int a3)
{
  *(_DWORD *)(a1 + 16) = *a2;
  *(_DWORD *)(a1 + 20) = a2[1];
  *(_DWORD *)(a1 + 24) = a2[2];
  *(_DWORD *)(a1 + 28) = a2[3];
  int v3 = &a2[4 * (a3 == 256)];
  *(_DWORD *)(a1 + 32) = *v3;
  *(_DWORD *)(a1 + 36) = v3[1];
  *(_DWORD *)(a1 + 40) = v3[2];
  *(_DWORD *)(a1 + 44) = v3[3];
  *(_DWORD *)a1 = 1634760805;
  int8x8_t result = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(a3 == 256), 0x1FuLL)), (int8x8_t)0x79622D323320646ELL, (int8x8_t)0x79622D363120646ELL);
  *(int8x8_t *)(a1 + 4) = result;
  *(_DWORD *)(a1 + 12) = 1797285236;
  *(unsigned char *)(a1 + 128) = 0;
  return result;
}

uint64_t ChaCha_set_iv(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  if (a3)
  {
    *(_DWORD *)(result + 48) = *a3;
    int v3 = a3[1];
  }
  else
  {
    int v3 = 0;
    *(_DWORD *)(result + 48) = 0;
  }
  *(_DWORD *)(result + 52) = v3;
  *(_DWORD *)(result + 56) = *a2;
  *(_DWORD *)(result + 60) = a2[1];
  *(unsigned char *)(result + 128) = 0;
  return result;
}

int *ChaCha(int *result, int *a2, char *a3, unint64_t a4)
{
  unint64_t v4 = a4;
  int v7 = result;
  int v8 = result + 32;
  unint64_t v9 = *((unsigned __int8 *)result + 128);
  if (*((unsigned char *)result + 128))
  {
    if (v9 >= a4) {
      unint64_t v10 = a4;
    }
    else {
      unint64_t v10 = *((unsigned __int8 *)result + 128);
    }
    if (v10)
    {
      int v11 = &v8[-v9];
      int v12 = v10;
      do
      {
        char v14 = *a3++;
        char v13 = v14;
        char v15 = *v11++;
        *(unsigned char *)a2 = v15 ^ v13;
        a2 = (int *)((char *)a2 + 1);
        --v12;
      }
      while (v12);
      LOBYTE(v9) = *v8;
    }
    *int v8 = v9 - v10;
    unint64_t v4 = a4 - v10;
  }
  for (; v4; v4 -= v16)
  {
    if (v4 >= 0xFFFFFFFF) {
      unint64_t v16 = 0xFFFFFFFFLL;
    }
    else {
      unint64_t v16 = v4;
    }
    int8x8_t result = chacha_encrypt_bytes(v7, a3, a2, v16);
    a3 += v16;
    a2 = (int *)((char *)a2 + v16);
  }
  return result;
}

int *chacha_encrypt_bytes(int *result, _DWORD *a2, int *a3, unint64_t a4)
{
  uint64_t v128 = *MEMORY[0x263EF8340];
  if (a4)
  {
    uint64_t v111 = 0;
    int v4 = *result;
    int v124 = result[2];
    int v125 = result[1];
    int v122 = result[4];
    int v123 = result[3];
    int v120 = result[6];
    int v121 = result[5];
    int v118 = result[8];
    int v119 = result[7];
    int v116 = result[10];
    int v117 = result[9];
    int v5 = result[12];
    int v6 = result[13];
    a4 = a4;
    int v114 = result[14];
    int v115 = result[11];
    int v112 = *result;
    int v113 = result[15];
    while (1)
    {
      if (a4 > 0x3F)
      {
        int v8 = a3;
      }
      else
      {
        uint64_t v7 = 0;
        do
        {
          int v8 = (int *)v127;
          v127[v7] = *((unsigned char *)a2 + v7);
          ++v7;
        }
        while (a4 != v7);
        a2 = v127;
        uint64_t v111 = a3;
      }
      int v9 = -20;
      int v11 = v113;
      int v10 = v114;
      int v12 = v6;
      int v126 = v5;
      int v13 = v5;
      int v15 = v115;
      int v14 = v116;
      int v17 = v117;
      int v16 = v118;
      int v19 = v119;
      int v18 = v120;
      int v20 = v121;
      int v21 = v122;
      int v23 = v123;
      int v22 = v124;
      int v24 = v125;
      int v25 = v4;
      do
      {
        int v26 = v21 + v25;
        int v27 = v13 ^ v26;
        HIDWORD(v28) = v27;
        LODWORD(v28) = v27;
        int v29 = (v28 >> 16) + v16;
        HIDWORD(v28) = v29 ^ v21;
        LODWORD(v28) = v29 ^ v21;
        int v30 = (v28 >> 20) + v26;
        LODWORD(v28) = v30 ^ __ROR4__(v27, 16);
        int v31 = v28;
        HIDWORD(v28) = v28;
        int v32 = (v28 >> 24) + v29;
        LODWORD(v28) = v32 ^ __ROR4__(v29 ^ v21, 20);
        int v33 = v28;
        HIDWORD(v28) = v28;
        int v34 = v28 >> 25;
        int v35 = v20 + v24;
        int v36 = v12 ^ v35;
        HIDWORD(v28) = v36;
        LODWORD(v28) = v36;
        int v37 = (v28 >> 16) + v17;
        int v38 = v37 ^ v20;
        HIDWORD(v28) = v38;
        LODWORD(v28) = v38;
        int v39 = (v28 >> 20) + v35;
        LODWORD(v28) = v39 ^ __ROR4__(v36, 16);
        int v40 = v28;
        HIDWORD(v28) = v28;
        int v41 = (v28 >> 24) + v37;
        LODWORD(v28) = v41 ^ __ROR4__(v38, 20);
        int v42 = v28;
        HIDWORD(v28) = v28;
        int v43 = v28 >> 25;
        int v44 = v18 + v22;
        int v45 = v10 ^ v44;
        HIDWORD(v28) = v45;
        LODWORD(v28) = v45;
        int v46 = (v28 >> 16) + v14;
        int v47 = v46 ^ v18;
        HIDWORD(v28) = v47;
        LODWORD(v28) = v47;
        int v48 = (v28 >> 20) + v44;
        LODWORD(v28) = v48 ^ __ROR4__(v45, 16);
        int v49 = v28;
        HIDWORD(v28) = v28;
        int v50 = (v28 >> 24) + v46;
        LODWORD(v28) = v50 ^ __ROR4__(v47, 20);
        int v51 = v28;
        HIDWORD(v28) = v28;
        int v52 = v28 >> 25;
        int v53 = v19 + v23;
        int v54 = v11 ^ v53;
        HIDWORD(v28) = v54;
        LODWORD(v28) = v54;
        int v55 = (v28 >> 16) + v15;
        int v56 = v55 ^ v19;
        HIDWORD(v28) = v55 ^ v19;
        LODWORD(v28) = v55 ^ v19;
        int v57 = (v28 >> 20) + v53;
        LODWORD(v28) = v57 ^ __ROR4__(v54, 16);
        int v58 = v28;
        HIDWORD(v28) = v28;
        int v59 = (v28 >> 24) + v55;
        LODWORD(v28) = v59 ^ __ROR4__(v56, 20);
        int v60 = v28;
        HIDWORD(v28) = v28;
        int v61 = v28 >> 25;
        int v62 = v43 + v30;
        LODWORD(v28) = v62 ^ __ROR4__(v58, 24);
        int v63 = v28;
        HIDWORD(v28) = v28;
        int v64 = (v28 >> 16) + v50;
        LODWORD(v28) = v64 ^ __ROR4__(v42, 25);
        int v65 = v28;
        HIDWORD(v28) = v28;
        int v25 = (v28 >> 20) + v62;
        LODWORD(v28) = v25 ^ __ROR4__(v63, 16);
        HIDWORD(v28) = v28;
        int v11 = v28 >> 24;
        int v14 = v11 + v64;
        LODWORD(v28) = (v11 + v64) ^ __ROR4__(v65, 20);
        HIDWORD(v28) = v28;
        int v20 = v28 >> 25;
        int v66 = v52 + v39;
        LODWORD(v28) = v66 ^ __ROR4__(v31, 24);
        int v67 = v28;
        HIDWORD(v28) = v28;
        int v68 = (v28 >> 16) + v59;
        LODWORD(v28) = v68 ^ __ROR4__(v51, 25);
        int v69 = v28;
        HIDWORD(v28) = v28;
        int v24 = (v28 >> 20) + v66;
        LODWORD(v28) = v24 ^ __ROR4__(v67, 16);
        HIDWORD(v28) = v28;
        int v13 = v28 >> 24;
        int v15 = v13 + v68;
        LODWORD(v28) = (v13 + v68) ^ __ROR4__(v69, 20);
        HIDWORD(v28) = v28;
        int v18 = v28 >> 25;
        int v70 = v61 + v48;
        LODWORD(v28) = v70 ^ __ROR4__(v40, 24);
        int v71 = v28;
        HIDWORD(v28) = v28;
        int v72 = (v28 >> 16) + v32;
        LODWORD(v28) = v72 ^ __ROR4__(v60, 25);
        int v73 = v28;
        HIDWORD(v28) = v28;
        int v22 = (v28 >> 20) + v70;
        LODWORD(v28) = v22 ^ __ROR4__(v71, 16);
        HIDWORD(v28) = v28;
        int v12 = v28 >> 24;
        int v16 = v12 + v72;
        LODWORD(v28) = (v12 + v72) ^ __ROR4__(v73, 20);
        HIDWORD(v28) = v28;
        int v19 = v28 >> 25;
        int v74 = v34 + v57;
        LODWORD(v28) = v74 ^ __ROR4__(v49, 24);
        int v75 = v28;
        HIDWORD(v28) = v28;
        int v76 = (v28 >> 16) + v41;
        LODWORD(v28) = v76 ^ __ROR4__(v33, 25);
        int v77 = v28;
        HIDWORD(v28) = v28;
        int v23 = (v28 >> 20) + v74;
        LODWORD(v28) = v23 ^ __ROR4__(v75, 16);
        HIDWORD(v28) = v28;
        int v10 = v28 >> 24;
        int v17 = v10 + v76;
        LODWORD(v28) = (v10 + v76) ^ __ROR4__(v77, 20);
        HIDWORD(v28) = v28;
        int v21 = v28 >> 25;
        v9 += 2;
      }
      while (v9);
      int v78 = v25 + v4;
      int v79 = v24 + v125;
      int v80 = v22 + v124;
      int v81 = v23 + v123;
      int v82 = v21 + v122;
      int v83 = v20 + v121;
      int v84 = v18 + v120;
      int v85 = v19 + v119;
      int v86 = v16 + v118;
      int v87 = v17 + v117;
      int v88 = v14 + v116;
      int v89 = v15 + v115;
      int v90 = v13 + v126;
      int v91 = v12 + v6;
      int v92 = v10 + v114;
      int v93 = v11 + v113;
      if (a4 <= 0x3F)
      {
        result[16] = v78;
        result[17] = v79;
        result[18] = v80;
        result[19] = v81;
        result[20] = v82;
        result[21] = v83;
        result[22] = v84;
        result[23] = v85;
        result[24] = v86;
        result[25] = v87;
        result[26] = v88;
        result[27] = v89;
        result[28] = v90;
        result[29] = v91;
        result[30] = v92;
        result[31] = v93;
      }
      int v94 = *a2 ^ v78;
      int v95 = a2[1] ^ v79;
      int v96 = a2[2] ^ v80;
      int v97 = a2[3] ^ v81;
      int v98 = a2[4] ^ v82;
      int v99 = a2[5] ^ v83;
      int v100 = a2[6] ^ v84;
      int v101 = a2[7] ^ v85;
      int v102 = a2[8] ^ v86;
      int v103 = a2[9] ^ v87;
      int v104 = a2[10] ^ v88;
      int v105 = a2[11] ^ v89;
      int v106 = a2[12] ^ v90;
      int v107 = a2[13] ^ v91;
      int v108 = a2[14] ^ v92;
      int v109 = a2[15] ^ v93;
      int v5 = v126 + 1;
      if (v126 == -1) {
        ++v6;
      }
      *int v8 = v94;
      v8[1] = v95;
      v8[2] = v96;
      void v8[3] = v97;
      v8[4] = v98;
      v8[5] = v99;
      v8[6] = v100;
      v8[7] = v101;
      v8[8] = v102;
      v8[9] = v103;
      v8[10] = v104;
      v8[11] = v105;
      v8[12] = v106;
      v8[13] = v107;
      v8[14] = v108;
      v8[15] = v109;
      if (a4 <= 0x40) {
        break;
      }
      a3 = v8 + 16;
      a2 += 16;
      a4 -= 64;
      int v4 = v112;
    }
    if ((a4 - 1) <= 0x3E)
    {
      unint64_t v110 = 0;
      do
      {
        *((unsigned char *)v111 + v110) = *((unsigned char *)v8 + v110);
        ++v110;
      }
      while (v110 < a4);
    }
    result[12] = v5;
    result[13] = v6;
    *((unsigned char *)result + 128) = 64 - a4;
  }
  return result;
}

int *CRYPTO_chacha_20(int *result, _DWORD *a2, unint64_t a3, _OWORD *a4, uint64_t *a5, uint64_t a6)
{
  unint64_t v6 = a3;
  int v8 = result;
  uint64_t v19 = *MEMORY[0x263EF8340];
  long long v9 = a4[1];
  v11[1] = *a4;
  v11[2] = v9;
  v11[0] = xmmword_23C6FED80;
  uint64_t v12 = 0;
  uint64_t v13 = *a5;
  if (a6) {
    uint64_t v12 = a6;
  }
  if (a3)
  {
    int v18 = 0;
    long long v16 = 0u;
    long long v17 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    do
    {
      if (v6 >= 0xFFFFFFFF) {
        unint64_t v10 = 0xFFFFFFFFLL;
      }
      else {
        unint64_t v10 = v6;
      }
      int8x8_t result = chacha_encrypt_bytes((int *)v11, a2, v8, v10);
      a2 = (_DWORD *)((char *)a2 + v10);
      int v8 = (int *)((char *)v8 + v10);
      v6 -= v10;
    }
    while (v6);
  }
  return result;
}

int *CRYPTO_xchacha_20(int *a1, _DWORD *a2, unint64_t a3, int *a4, uint64_t a5)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  CRYPTO_hchacha_20(v10, a4, (int *)a5);
  return CRYPTO_chacha_20(a1, a2, a3, v10, (uint64_t *)(a5 + 16), 0);
}

int UTF8_getc(const unsigned __int8 *str, int len, unint64_t *val)
{
  if (len < 1) {
    return 0;
  }
  unsigned __int8 v4 = *str;
  if ((*(char *)str & 0x80000000) == 0)
  {
    unint64_t v5 = v4 & 0x7F;
    int result = 1;
LABEL_4:
    *val = v5;
    return result;
  }
  unsigned int v7 = *str;
  if ((v7 & 0xE0) == 0xC0)
  {
    if (v7 < 0xC2) {
      return -2;
    }
    if (len >= 2)
    {
      unsigned __int8 v11 = str[1];
      if ((v11 & 0xC0) == 0x80)
      {
        unint64_t v5 = v11 & 0x3F | ((v7 & 0x1F) << 6);
        if (v5 >= 0x80)
        {
          int result = 2;
          goto LABEL_4;
        }
        return -4;
      }
      return -3;
    }
    return -1;
  }
  if ((v7 & 0xF0) == 0xE0)
  {
    if (len < 3) {
      return -1;
    }
    unsigned __int8 v8 = str[1];
    if ((v8 & 0xC0) == 0x80)
    {
      unsigned __int8 v9 = str[2];
      if ((v9 & 0xC0) == 0x80)
      {
        unint64_t v10 = ((unint64_t)(v4 & 0xF) << 12) | ((unint64_t)(v8 & 0x3F) << 6);
        unint64_t v5 = v10 & 0xFFFFFFFFFFFFFFC0 | v9 & 0x3F;
        if (v5 >= 0x800)
        {
          if ((v10 & 0xF800) != 0xD800)
          {
            int result = 3;
            goto LABEL_4;
          }
          return -2;
        }
        return -4;
      }
    }
    return -3;
  }
  int result = -2;
  if (v7 <= 0xF4 && (v7 & 0xF8) == 0xF0)
  {
    if (len < 4) {
      return -1;
    }
    unsigned __int8 v12 = str[1];
    if ((v12 & 0xC0) != 0x80) {
      return -3;
    }
    unsigned __int8 v13 = str[2];
    if ((v13 & 0xC0) != 0x80) {
      return -3;
    }
    unsigned __int8 v14 = str[3];
    if ((v14 & 0xC0) != 0x80) {
      return -3;
    }
    unint64_t v5 = ((unint64_t)(v4 & 7) << 18) | ((unint64_t)(v12 & 0x3F) << 12) | ((unint64_t)(v13 & 0x3F) << 6) | v14 & 0x3F;
    if (v5 < 0x10000) {
      return -4;
    }
    if (v5 >> 16 <= 0x10)
    {
      int result = 4;
      goto LABEL_4;
    }
  }
  return result;
}

int UTF8_putc(unsigned __int8 *str, int len, unint64_t value)
{
  if (value <= 0x7F)
  {
    if (!str) {
      return 1;
    }
    if (len >= 1)
    {
      *str = value;
      return 1;
    }
    return -1;
  }
  if (value <= 0x7FF)
  {
    if (!str) {
      return 2;
    }
    if (len >= 2)
    {
      *str = (value >> 6) | 0xC0;
      str[1] = value & 0x3F | 0x80;
      return 2;
    }
    return -1;
  }
  if (!(value >> 16))
  {
    if (value >> 11 != 27)
    {
      if (str)
      {
        if (len < 3) {
          return -1;
        }
        *str = (value >> 12) | 0xE0;
        str[1] = (value >> 6) & 0x3F | 0x80;
        str[2] = value & 0x3F | 0x80;
      }
      return 3;
    }
    return -2;
  }
  if (value >> 16 > 0x10) {
    return -2;
  }
  if (str)
  {
    if (len < 4) {
      return -1;
    }
    *str = (value >> 18) | 0xF0;
    str[1] = (value >> 12) & 0x3F | 0x80;
    str[2] = (value >> 6) & 0x3F | 0x80;
    str[3] = value & 0x3F | 0x80;
  }
  return 4;
}

uint64_t EVP_PKEY_asn1_get_count()
{
  if (asn1_app_methods) {
    return (sk_num((const STACK *)asn1_app_methods) + 18);
  }
  else {
    return 18;
  }
}

char *EVP_PKEY_asn1_get0(unsigned int a1)
{
  if ((a1 & 0x80000000) != 0) {
    return 0;
  }
  if (a1 > 0x11) {
    return sk_value((const STACK *)asn1_app_methods, a1 - 18);
  }
  return (char *)*(&asn1_methods + a1);
}

uint64_t EVP_PKEY_asn1_find(uint64_t *a1, int a2)
{
LABEL_1:
  if (asn1_app_methods) {
    unint64_t v4 = (sk_num((const STACK *)asn1_app_methods) + 18);
  }
  else {
    unint64_t v4 = 18;
  }
  while ((int)v4 >= 1)
  {
    if (v4 > 0x12) {
      unint64_t v5 = sk_value((const STACK *)asn1_app_methods, (int)v4 - 19);
    }
    else {
      unint64_t v5 = (char *)*(&asn1_methods + v4 - 1);
    }
    --v4;
    if (*(_DWORD *)v5 == a2)
    {
      if ((v5[8] & 1) == 0) {
        goto LABEL_12;
      }
      a2 = *((_DWORD *)v5 + 1);
      goto LABEL_1;
    }
  }
  unint64_t v5 = 0;
LABEL_12:
  if (!a1) {
    return (uint64_t)v5;
  }
  uint64_t pkey_asn1_meth_engine = ENGINE_get_pkey_asn1_meth_engine(a2);
  if (!pkey_asn1_meth_engine)
  {
    *a1 = 0;
    return (uint64_t)v5;
  }
  *a1 = pkey_asn1_meth_engine;
  return ENGINE_get_pkey_asn1_meth(pkey_asn1_meth_engine);
}

char *EVP_PKEY_asn1_find_str(ENGINE **a1, char *__s, signed int a3)
{
  signed int v3 = a3;
  if (a3 == -1)
  {
    signed int v3 = strlen(__s);
    if (!a1) {
      goto LABEL_10;
    }
  }
  else if (!a1)
  {
    goto LABEL_10;
  }
  e = 0;
  uint64_t str = ENGINE_pkey_asn1_find_str(&e, (uint64_t)__s, v3);
  if (str)
  {
    unsigned int v7 = (char *)str;
    if (!ENGINE_init(e)) {
      unsigned int v7 = 0;
    }
    ENGINE_free(e);
    *a1 = e;
    return v7;
  }
  *a1 = 0;
LABEL_10:
  if (asn1_app_methods)
  {
    int v8 = sk_num((const STACK *)asn1_app_methods);
    if (v8 < -17) {
      return 0;
    }
    LODWORD(v9) = v8 + 18;
  }
  else
  {
    LODWORD(v9) = 18;
  }
  unint64_t v9 = v9;
  while (1)
  {
    unint64_t v10 = v9 - 1;
    unsigned int v7 = v9 > 0x12
       ? sk_value((const STACK *)asn1_app_methods, (int)v9 - 19)
       : (char *)*(&asn1_methods + v10);
    if ((v7[8] & 1) == 0
      && v3 == strlen(*((const char **)v7 + 2))
      && !strncasecmp(*((const char **)v7 + 2), __s, v3))
    {
      break;
    }
    unint64_t v9 = v10;
    if (v10 + 1 <= 1) {
      return 0;
    }
  }
  return v7;
}

STACK *EVP_PKEY_asn1_add0(char *data)
{
  int result = (STACK *)asn1_app_methods;
  if (asn1_app_methods) {
    return (STACK *)(sk_push(result, data) != 0);
  }
  int result = sk_new(0);
  asn1_app_methods = (uint64_t)result;
  if (result) {
    return (STACK *)(sk_push(result, data) != 0);
  }
  return result;
}

uint64_t EVP_PKEY_asn1_add_alias(int a1, int a2)
{
  uint64_t result = (uint64_t)malloc_type_calloc(1uLL, 0x110uLL, 0x1090040E55D908EuLL);
  if (result)
  {
    uint64_t v5 = result;
    *(void *)(result + 8) = 3;
    *(_DWORD *)uint64_t result = a2;
    *(_DWORD *)(result + 4) = a1;
    if (EVP_PKEY_asn1_add0((char *)result))
    {
      return 1;
    }
    else
    {
      EVP_PKEY_asn1_free(v5);
      return 0;
    }
  }
  return result;
}

uint64_t EVP_PKEY_asn1_new(int a1, int a2, const char *a3, const char *a4)
{
  int v8 = malloc_type_calloc(1uLL, 0x110uLL, 0x1090040E55D908EuLL);
  uint64_t v9 = (uint64_t)v8;
  if (v8)
  {
    if ((*int v8 = a1, v8[1] = a1, *((void *)v8 + 1) = a2 | 2, a4)
      && (unint64_t v10 = strdup(a4), (*(void *)(v9 + 24) = v10) == 0)
      || a3 && (unsigned __int8 v11 = strdup(a3), (*(void *)(v9 + 16) = v11) == 0))
    {
      EVP_PKEY_asn1_free(v9);
      return 0;
    }
  }
  return v9;
}

void EVP_PKEY_asn1_free(uint64_t a1)
{
  if (a1 && (*(unsigned char *)(a1 + 8) & 2) != 0)
  {
    free(*(void **)(a1 + 16));
    free(*(void **)(a1 + 24));
    free((void *)a1);
  }
}

uint64_t EVP_PKEY_asn1_get0_info(_DWORD *a1, _DWORD *a2, _DWORD *a3, void *a4, void *a5, uint64_t a6)
{
  if (!a6) {
    return 0;
  }
  if (a1) {
    *a1 = *(_DWORD *)a6;
  }
  if (a2) {
    *a2 = *(_DWORD *)(a6 + 4);
  }
  if (a3) {
    *a3 = *(void *)(a6 + 8);
  }
  if (a4) {
    *a4 = *(void *)(a6 + 24);
  }
  if (a5) {
    *a5 = *(void *)(a6 + 16);
  }
  return 1;
}

uint64_t EVP_PKEY_get0_asn1(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

__n128 EVP_PKEY_asn1_copy(__n128 *a1, const void *a2)
{
  unint64_t v3 = a1->n128_u64[1];
  __n128 v6 = a1[1];
  unint64_t v4 = a1->n128_u64[0];
  memcpy(a1, a2, 0x110uLL);
  a1->n128_u64[0] = v4;
  a1->n128_u64[1] = v3;
  __n128 result = v6;
  a1[1] = v6;
  return result;
}

void *EVP_PKEY_asn1_set_public(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  result[4] = a2;
  result[5] = a3;
  result[6] = a4;
  result[7] = a5;
  result[11] = a6;
  result[12] = a7;
  return result;
}

void *EVP_PKEY_asn1_set_private(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  result[8] = a2;
  result[9] = a3;
  result[10] = a4;
  return result;
}

void *EVP_PKEY_asn1_set_param(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  result[14] = a2;
  result[15] = a3;
  result[16] = a4;
  result[17] = a5;
  result[18] = a6;
  result[19] = a7;
  return result;
}

uint64_t EVP_PKEY_asn1_set_free(uint64_t result, uint64_t a2)
{
  *(void *)(result + 168) = a2;
  return result;
}

uint64_t EVP_PKEY_asn1_set_ctrl(uint64_t result, uint64_t a2)
{
  *(void *)(result + 176) = a2;
  return result;
}

uint64_t EVP_PKEY_asn1_set_security_bits(uint64_t result, uint64_t a2)
{
  *(void *)(result + 104) = a2;
  return result;
}

uint64_t EVP_PKEY_asn1_set_check(uint64_t result, uint64_t a2)
{
  *(void *)(result + 216) = a2;
  return result;
}

uint64_t EVP_PKEY_asn1_set_public_check(uint64_t result, uint64_t a2)
{
  *(void *)(result + 224) = a2;
  return result;
}

uint64_t EVP_PKEY_asn1_set_param_check(uint64_t result, uint64_t a2)
{
  *(void *)(result + 232) = a2;
  return result;
}

int RSA_generate_key_ex(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb)
{
  rsa_keygen = (uint64_t (*)(void))rsa->meth->rsa_keygen;
  if (rsa_keygen)
  {
    return rsa_keygen();
  }
  else
  {
    memset(&v50, 0, sizeof(v50));
    memset(&v49, 0, sizeof(v49));
    memset(&v48, 0, sizeof(v48));
    unint64_t v10 = BN_CTX_new();
    unsigned __int8 v11 = v10;
    if (v10)
    {
      BN_CTX_start(v10);
      unsigned __int8 v12 = BN_CTX_get(v11);
      if (v12)
      {
        unsigned __int8 v13 = (__n128 *)v12;
        unsigned __int8 v14 = BN_CTX_get(v11);
        if (v14)
        {
          long long v15 = v14;
          long long v16 = BN_CTX_get(v11);
          if (v16)
          {
            long long v17 = v16;
            if (BN_CTX_get(v11))
            {
              int v18 = bits >= -1 ? bits + 1 : bits + 2;
              if (rsa->n || (uint64_t v19 = BN_new(), (rsa->n = v19) != 0))
              {
                if (rsa->d || (int v20 = BN_new(), (rsa->d = v20) != 0))
                {
                  if (rsa->e || (int v21 = BN_new(), (rsa->e = v21) != 0))
                  {
                    if (rsa->p || (int v22 = BN_new(), (rsa->p = v22) != 0))
                    {
                      if (rsa->q || (int v23 = BN_new(), (rsa->q = v23) != 0))
                      {
                        if (rsa->dmp1 || (int v24 = BN_new(), (rsa->dmp1 = v24) != 0))
                        {
                          if (rsa->dmq1 || (int v25 = BN_new(), (rsa->dmq1 = v25) != 0))
                          {
                            if (rsa->iqmp || (int v26 = BN_new(), (rsa->iqmp = v26) != 0))
                            {
                              if (bn_copy(rsa->e, e))
                              {
                                int v27 = 0;
                                int v28 = v18 >> 1;
                                int v29 = bits - (v18 >> 1);
                                do
                                {
                                  if (!BN_generate_prime_ex(rsa->p, v28, 0, 0, 0, cb)) {
                                    break;
                                  }
                                  p = rsa->p;
                                  int v31 = BN_value_one();
                                  if (!BN_sub(v17, p, v31) || !BN_gcd_ct((unint64_t)v15, v17, rsa->e, v11)) {
                                    break;
                                  }
                                  if (BN_is_one((uint64_t)v15))
                                  {
                                    if (BN_GENCB_call(cb, 3, 0))
                                    {
LABEL_38:
                                      int v33 = 3;
                                      while (BN_generate_prime_ex(rsa->q, v29, 0, 0, 0, cb))
                                      {
                                        if (BN_cmp(rsa->p, rsa->q))
                                        {
                                          q = rsa->q;
                                          int v35 = BN_value_one();
                                          if (BN_sub(v17, q, v35) && BN_gcd_ct((unint64_t)v15, v17, rsa->e, v11))
                                          {
                                            if (BN_is_one((uint64_t)v15))
                                            {
                                              if (BN_GENCB_call(cb, 3, 1))
                                              {
                                                int v39 = BN_cmp(rsa->p, rsa->q);
                                                int v41 = rsa->p;
                                                int v40 = rsa->q;
                                                if (v39 < 0)
                                                {
                                                  rsa->p = v40;
                                                  rsa->q = v41;
                                                  int v42 = v41;
                                                }
                                                else
                                                {
                                                  int v42 = rsa->q;
                                                  int v40 = rsa->p;
                                                }
                                                if (BN_mul(rsa->n, v40, v42, v11))
                                                {
                                                  int v43 = rsa->p;
                                                  int v44 = BN_value_one();
                                                  if (BN_sub(v15, v43, v44))
                                                  {
                                                    int v45 = rsa->q;
                                                    int v46 = BN_value_one();
                                                    if (BN_sub(v17, v45, v46))
                                                    {
                                                      if (BN_mul((BIGNUM *)v13, v15, v17, v11))
                                                      {
                                                        BN_init(&v50);
                                                        BN_with_flags((__n128 *)&v50, v13, 4);
                                                        if (BN_mod_inverse_ct(rsa->d, rsa->e, &v50, v11))
                                                        {
                                                          BN_init(&v49);
                                                          BN_with_flags((__n128 *)&v49, (__n128 *)rsa->d, 4);
                                                          if (BN_mod_ct(rsa->dmp1, &v49, v15, v11))
                                                          {
                                                            if (BN_mod_ct(rsa->dmq1, &v49, v17, v11))
                                                            {
                                                              BN_init(&v48);
                                                              BN_with_flags((__n128 *)&v48, (__n128 *)rsa->p, 4);
                                                              if (BN_mod_inverse_ct(rsa->iqmp, rsa->q, &v48, v11))
                                                              {
                                                                int v47 = 1;
                                                                goto LABEL_63;
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                            else if (BN_GENCB_call(cb, 2, v27++))
                                            {
                                              goto LABEL_38;
                                            }
                                          }
                                          goto LABEL_61;
                                        }
                                        if (!--v33)
                                        {
                                          int v37 = 120;
                                          int v38 = 154;
                                          goto LABEL_62;
                                        }
                                      }
                                    }
                                    break;
                                  }
                                }
                                while (BN_GENCB_call(cb, 2, v27++));
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_61:
    int v37 = 3;
    int v38 = 213;
LABEL_62:
    ERR_put_error(4, 4095, v37, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_gen.c", v38);
    int v47 = 0;
LABEL_63:
    if (v11)
    {
      BN_CTX_end(v11);
      BN_CTX_free(v11);
    }
    return v47;
  }
}

RSA *__cdecl RSA_generate_key(int bits, unint64_t e, void (__cdecl *callback)(int, int, void *), void *cb_arg)
{
  memset(&cb, 0, sizeof(cb));
  int v8 = RSA_new();
  uint64_t v9 = BN_new();
  unint64_t v10 = v9;
  if (v8 && v9)
  {
    uint64_t v11 = 0;
    while (((e >> v11) & 1) == 0 || BN_set_bit(v10, v11))
    {
      if (++v11 == 64)
      {
        BN_GENCB_set_old((uint64_t)&cb, (uint64_t)callback, (uint64_t)cb_arg);
        if (!RSA_generate_key_ex(v8, bits, v10, &cb)) {
          break;
        }
        BN_free(v10);
        return v8;
      }
    }
  }
  BN_free(v10);
  RSA_free(v8);
  return 0;
}

X509_LOOKUP *__cdecl X509_LOOKUP_new(X509_LOOKUP_METHOD *method)
{
  uint64_t v2 = (X509_LOOKUP *)malloc_type_calloc(1uLL, 0x20uLL, 0x1030040AE83759AuLL);
  unint64_t v3 = v2;
  if (v2)
  {
    v2->methochar d = method;
    new_item = method->new_item;
    if (new_item && !((unsigned int (*)(X509_LOOKUP *))new_item)(v2))
    {
      free(v3);
      return 0;
    }
  }
  else
  {
    ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_lu.c", 74);
  }
  return v3;
}

void X509_LOOKUP_free(X509_LOOKUP *ctx)
{
  if (ctx)
  {
    methochar d = ctx->method;
    if (method)
    {
      free = method->free;
      if (free) {
        ((void (*)(X509_LOOKUP *))free)(ctx);
      }
    }
    ::free(ctx);
  }
}

int X509_LOOKUP_init(X509_LOOKUP *ctx)
{
  methochar d = ctx->method;
  if (!method) {
    return 0;
  }
  init = (uint64_t (*)(void))method->init;
  if (init) {
    return init();
  }
  else {
    return 1;
  }
}

int X509_LOOKUP_shutdown(X509_LOOKUP *ctx)
{
  methochar d = ctx->method;
  if (!method) {
    return 0;
  }
  shutdown = (uint64_t (*)(void))method->shutdown;
  if (shutdown) {
    return shutdown();
  }
  else {
    return 1;
  }
}

int X509_LOOKUP_ctrl(X509_LOOKUP *ctx, int cmd, const char *argc, uint64_t argl, char **ret)
{
  methochar d = ctx->method;
  if (!method) {
    return -1;
  }
  ctrl = (uint64_t (*)(void))method->ctrl;
  if (ctrl) {
    return ctrl();
  }
  else {
    return 1;
  }
}

int X509_LOOKUP_by_subject(X509_LOOKUP *ctx, int type, X509_NAME *name, X509_OBJECT *ret)
{
  methochar d = ctx->method;
  if (method && (get_by_subject = (uint64_t (*)(void))method->get_by_subject) != 0) {
    return get_by_subject();
  }
  else {
    return 0;
  }
}

int X509_LOOKUP_by_issuer_serial(X509_LOOKUP *ctx, int type, X509_NAME *name, ASN1_INTEGER *serial, X509_OBJECT *ret)
{
  methochar d = ctx->method;
  if (method && (get_by_issuer_serial = (uint64_t (*)(void))method->get_by_issuer_serial) != 0) {
    return get_by_issuer_serial();
  }
  else {
    return 0;
  }
}

int X509_LOOKUP_by_fingerprint(X509_LOOKUP *ctx, int type, unsigned __int8 *bytes, int len, X509_OBJECT *ret)
{
  methochar d = ctx->method;
  if (method && (get_by_fingerprint = (uint64_t (*)(void))method->get_by_fingerprint) != 0) {
    return get_by_fingerprint();
  }
  else {
    return 0;
  }
}

int X509_LOOKUP_by_alias(X509_LOOKUP *ctx, int type, char *str, int len, X509_OBJECT *ret)
{
  methochar d = ctx->method;
  if (method && (get_by_alias = (uint64_t (*)(void))method->get_by_alias) != 0) {
    return get_by_alias();
  }
  else {
    return 0;
  }
}

X509_STORE *X509_STORE_new(void)
{
  int v0 = malloc_type_calloc(1uLL, 0x80uLL, 0x10A0040B451168FuLL);
  if (v0
    && (uint64_t v1 = sk_new((int (__cdecl *)(const char *const *, const char *const *))x509_object_cmp),
        (*(void *)int v0 = v1) != 0)
    && (uint64_t v2 = sk_new_null(), (*((void *)v0 + 1) = v2) != 0)
    && (unint64_t v3 = X509_VERIFY_PARAM_new(), (*((void *)v0 + 2) = v3) != 0)
    && CRYPTO_new_ex_data(4, v0, (CRYPTO_EX_DATA *)v0 + 7))
  {
    *((_DWORD *)v0 + 30) = 1;
  }
  else
  {
    ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_lu.c", 215);
    X509_STORE_free((X509_STORE *)v0);
    return 0;
  }
  return (X509_STORE *)v0;
}

uint64_t x509_object_cmp(const X509_CRL ***a1, const X509_CRL ***a2)
{
  uint64_t v2 = *a1;
  int v3 = *(_DWORD *)*a1;
  unint64_t v4 = *a2;
  int v5 = *(_DWORD *)*a2;
  uint64_t result = (v3 - v5);
  if (v3 == v5)
  {
    if (v3 == 2)
    {
      return X509_CRL_cmp(v2[1], v4[1]);
    }
    else if (v3 == 1)
    {
      return X509_subject_name_cmp((const X509 *)v2[1], (const X509 *)v4[1]);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void X509_STORE_free(X509_STORE *v)
{
  if (v && CRYPTO_add_lock(&v->references, -1, 11, 0, 0) <= 0)
  {
    objs = v->objs;
    if (sk_num(objs) >= 1)
    {
      int v3 = 0;
      do
      {
        unint64_t v4 = sk_value(objs, v3);
        int v5 = (X509_LOOKUP *)v4;
        uint64_t v6 = *((void *)v4 + 1);
        if (v6)
        {
          unsigned int v7 = *(void (**)(char *))(v6 + 32);
          if (v7) {
            v7(v4);
          }
        }
        X509_LOOKUP_free(v5);
        ++v3;
      }
      while (v3 < sk_num(objs));
    }
    sk_free(objs);
    sk_pop_free(*(STACK **)&v->cache, (void (__cdecl *)(void *))X509_OBJECT_free);
    CRYPTO_free_ex_data(4, v, (CRYPTO_EX_DATA *)&v->ex_data.dummy);
    X509_VERIFY_PARAM_free((X509_VERIFY_PARAM *)v->get_cert_methods);
    free(v);
  }
}

_DWORD *X509_OBJECT_new()
{
  int v0 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
  uint64_t v1 = v0;
  if (v0) {
    *int v0 = 0;
  }
  else {
    ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_lu.c", 228);
  }
  return v1;
}

void X509_OBJECT_free(X509_CRL **a1)
{
  if (a1)
  {
    if (*(_DWORD *)a1 == 2)
    {
      X509_CRL_free(a1[1]);
    }
    else if (*(_DWORD *)a1 == 1)
    {
      X509_free((X509 *)a1[1]);
    }
    free(a1);
  }
}

BOOL X509_STORE_up_ref(uint64_t a1)
{
  return CRYPTO_add_lock((int *)(a1 + 120), 1, 11, 0, 0) > 1;
}

X509_LOOKUP *__cdecl X509_STORE_add_lookup(X509_STORE *v, X509_LOOKUP_METHOD *m)
{
  objs = v->objs;
  if (sk_num(objs) < 1)
  {
LABEL_5:
    unsigned int v7 = X509_LOOKUP_new(m);
    int v8 = v7;
    if (v7)
    {
      v7->store_ctx = v;
      if (sk_push(v->objs, (char *)v7) <= 0)
      {
        ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_lu.c", 312);
        methochar d = v8->method;
        if (method)
        {
          free = method->free;
          if (free) {
            ((void (*)(X509_LOOKUP *))free)(v8);
          }
        }
        ::free(v8);
        return 0;
      }
    }
  }
  else
  {
    int v5 = 0;
    while (1)
    {
      uint64_t v6 = (X509_LOOKUP *)sk_value(objs, v5);
      if (v6->method == m) {
        return v6;
      }
      if (++v5 >= sk_num(objs)) {
        goto LABEL_5;
      }
    }
  }
  return v8;
}

X509_OBJECT *X509_STORE_CTX_get_obj_by_subject(uint64_t *a1, uint64_t a2, X509_NAME *a3)
{
  uint64_t v6 = (X509_OBJECT *)X509_OBJECT_new();
  if (v6)
  {
    X509_STORE_CTX_get_by_subject(a1, a2, a3, v6);
    if (!v7)
    {
      X509_OBJECT_free((X509_CRL **)v6);
      return 0;
    }
  }
  return v6;
}

void X509_STORE_CTX_get_by_subject(uint64_t *a1, uint64_t a2, X509_NAME *a3, X509_OBJECT *a4)
{
  uint64_t v4 = *a1;
  if (*a1)
  {
    v14[0] = 0;
    v14[1] = 0;
    CRYPTO_lock(9, 11, 0, 0);
    int v8 = X509_OBJECT_retrieve_by_subject(*(STACK **)v4, a2, a3);
    CRYPTO_lock(10, 11, 0, 0);
    if (a2 == 2 || !v8)
    {
      if (sk_num(*(const STACK **)(v4 + 8)) < 1)
      {
LABEL_10:
        if (!v8) {
          return;
        }
      }
      else
      {
        int v9 = 0;
        while (1)
        {
          unint64_t v10 = sk_value(*(const STACK **)(v4 + 8), v9);
          uint64_t v11 = *((void *)v10 + 1);
          if (v11)
          {
            unsigned __int8 v12 = *(unsigned int (**)(char *, uint64_t))(v11 + 48);
            if (v12)
            {
              if (v12(v10, a2)) {
                break;
              }
            }
          }
          if (++v9 >= sk_num(*(const STACK **)(v4 + 8))) {
            goto LABEL_10;
          }
        }
        int v8 = (X509_OBJECT *)v14;
      }
    }
    X509_OBJECT_up_ref_count(v8);
    if (v13) {
      *a4 = *v8;
    }
  }
}

X509_OBJECT *__cdecl X509_OBJECT_retrieve_by_subject(STACK *h, int type, X509_NAME *name)
{
  int v4 = x509_object_idx_cnt(h, type, (uint64_t)name, 0);
  if (v4 == -1) {
    return 0;
  }
  return (X509_OBJECT *)sk_value(h, v4);
}

void X509_OBJECT_up_ref_count(X509_OBJECT *a)
{
  if (a->type == 2)
  {
    X509_CRL_up_ref((uint64_t)a->data.ptr);
  }
  else if (a->type == 1)
  {
    X509_up_ref((uint64_t)a->data.ptr);
  }
}

int X509_STORE_add_cert(X509_STORE *ctx, X509 *x)
{
  if (!x) {
    return 0;
  }
  int v4 = X509_OBJECT_new();
  if (!v4) {
    return 0;
  }
  int v5 = v4;
  if (!X509_up_ref((uint64_t)x))
  {
    X509_OBJECT_free((X509_CRL **)v5);
    return 0;
  }
  *int v5 = 1;
  *((void *)v5 + 1) = x;
  return X509_STORE_add_object((STACK **)ctx, (char *)v5);
}

uint64_t X509_STORE_add_object(STACK **a1, char *a2)
{
  CRYPTO_lock(9, 11, 0, 0);
  if (!X509_OBJECT_retrieve_match(*a1, (X509_OBJECT *)a2))
  {
    if (sk_push(*a1, a2) <= 0)
    {
      ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_lu.c", 392);
      uint64_t v4 = 0;
      goto LABEL_5;
    }
    a2 = 0;
  }
  uint64_t v4 = 1;
LABEL_5:
  CRYPTO_lock(10, 11, 0, 0);
  X509_OBJECT_free((X509_CRL **)a2);
  return v4;
}

int X509_STORE_add_crl(X509_STORE *ctx, X509_CRL *x)
{
  if (!x) {
    return 0;
  }
  uint64_t v4 = X509_OBJECT_new();
  if (!v4) {
    return 0;
  }
  int v5 = v4;
  if (!X509_CRL_up_ref((uint64_t)x))
  {
    X509_OBJECT_free((X509_CRL **)v5);
    return 0;
  }
  *int v5 = 2;
  *((void *)v5 + 1) = x;
  return X509_STORE_add_object((STACK **)ctx, (char *)v5);
}

uint64_t X509_OBJECT_get_type(unsigned int *a1)
{
  return *a1;
}

int X509_OBJECT_idx_by_subject(STACK *h, int type, X509_NAME *name)
{
  return x509_object_idx_cnt(h, type, (uint64_t)name, 0);
}

uint64_t x509_object_idx_cnt(STACK *st, int a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  *(_DWORD *)&data[4] = 0;
  int v18 = 0;
  uint64_t v21 = 0;
  memset(v20, 0, sizeof(v20));
  uint64_t v16 = 0;
  memset(v15, 0, sizeof(v15));
  memset(v19, 0, sizeof(v19));
  memset(v14, 0, sizeof(v14));
  long long v13 = 0u;
  *(_DWORD *)int data = a2;
  if (a2 == 2)
  {
    int v18 = v19;
    *(void *)&v19[0] = &v13;
    uint64_t v6 = v14;
  }
  else
  {
    if (a2 != 1) {
      return 0xFFFFFFFFLL;
    }
    int v18 = v20;
    *(void *)&v20[0] = v15;
    uint64_t v6 = (void *)&v15[2] + 1;
  }
  *uint64_t v6 = a3;
  uint64_t v7 = sk_find(st, data);
  uint64_t v8 = v7;
  if (a4 && (v7 & 0x80000000) == 0)
  {
    *a4 = 1;
    uint64_t v11 = (const X509_CRL **)data;
    for (int i = v7 + 1; i < sk_num(st); ++i)
    {
      unsigned __int8 v12 = (const X509_CRL **)sk_value(st, i);
      if (x509_object_cmp(&v12, &v11)) {
        break;
      }
      ++*a4;
    }
  }
  return v8;
}

uint64_t X509_OBJECT_get0_X509(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == 1) {
      return *(void *)(result + 8);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t X509_OBJECT_get0_X509_CRL(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == 2) {
      return *(void *)(result + 8);
    }
    else {
      return 0;
    }
  }
  return result;
}

X509_CRL **X509_STORE_CTX_get1_certs(STACK ***a1, X509_NAME *a2)
{
  uint64_t v2 = *a1;
  if (!*a1) {
    return 0;
  }
  uint64_t result = (X509_CRL **)X509_get1_certs_from_cache(*a1, (uint64_t)a2);
  if (!result)
  {
    uint64_t result = (X509_CRL **)X509_STORE_CTX_get_obj_by_subject((uint64_t *)a1, 1, a2);
    if (result)
    {
      X509_OBJECT_free(result);
      return (X509_CRL **)X509_get1_certs_from_cache(v2, (uint64_t)a2);
    }
  }
  return result;
}

STACK *X509_get1_certs_from_cache(STACK **a1, uint64_t a2)
{
  int v10 = 0;
  CRYPTO_lock(9, 11, 0, 0);
  int v4 = x509_object_idx_cnt(*a1, 1, a2, &v10);
  if (v4 < 0)
  {
    uint64_t v6 = 0;
  }
  else
  {
    int v5 = v4;
    uint64_t v6 = sk_new_null();
    if (v6)
    {
      if (v10 < 1)
      {
LABEL_8:
        CRYPTO_lock(10, 11, 0, 0);
        return v6;
      }
      int v7 = 0;
      while (1)
      {
        uint64_t v8 = (char *)*((void *)sk_value(*a1, v5 + v7) + 1);
        if (!X509_up_ref((uint64_t)v8)) {
          break;
        }
        if (!sk_push(v6, v8)) {
          goto LABEL_11;
        }
        if (++v7 >= v10) {
          goto LABEL_8;
        }
      }
    }
  }
  uint64_t v8 = 0;
LABEL_11:
  CRYPTO_lock(10, 11, 0, 0);
  sk_pop_free(v6, (void (__cdecl *)(void *))X509_free);
  X509_free((X509 *)v8);
  return 0;
}

STACK *X509_STORE_CTX_get1_crls(uint64_t *a1, X509_NAME *a2)
{
  uint64_t v2 = (STACK **)*a1;
  if (!*a1) {
    return 0;
  }
  obj_by_subject = (X509_CRL **)X509_STORE_CTX_get_obj_by_subject(a1, 2, a2);
  if (!obj_by_subject) {
    return 0;
  }
  int v11 = 0;
  X509_OBJECT_free(obj_by_subject);
  CRYPTO_lock(9, 11, 0, 0);
  int v5 = x509_object_idx_cnt(*v2, 2, (uint64_t)a2, &v11);
  if (v5 < 0)
  {
    int v7 = 0;
LABEL_12:
    int v9 = 0;
LABEL_13:
    CRYPTO_lock(10, 11, 0, 0);
    X509_CRL_free(v9);
    sk_pop_free(v7, (void (__cdecl *)(void *))X509_CRL_free);
    return 0;
  }
  int v6 = v5;
  int v7 = sk_new_null();
  if (!v7) {
    goto LABEL_12;
  }
  if (v11 >= 1)
  {
    int v8 = 0;
    do
    {
      int v9 = (X509_CRL *)*((void *)sk_value(*v2, v6 + v8) + 1);
      if (!X509_CRL_up_ref((uint64_t)v9)) {
        goto LABEL_12;
      }
      if (!sk_push(v7, (char *)v9)) {
        goto LABEL_13;
      }
    }
    while (++v8 < v11);
  }
  CRYPTO_lock(10, 11, 0, 0);
  return v7;
}

X509_OBJECT *__cdecl X509_OBJECT_retrieve_match(STACK *h, X509_OBJECT *x)
{
  int v9 = (const X509_CRL **)x;
  int v4 = sk_find(h, (char *)x);
  if (v4 != -1)
  {
    int v5 = v4;
    if ((x->type - 1) > 1)
    {
      return (X509_OBJECT *)sk_value(h, v4);
    }
    while (v5 < sk_num(h))
    {
      int v6 = sk_value(h, v5);
      int v8 = (const X509_CRL **)v6;
      if (x509_object_cmp(&v8, &v9)) {
        break;
      }
      if (x->type == 2)
      {
        if (!X509_CRL_match(*((void *)v6 + 1), (uint64_t)x->data.ptr)) {
          return (X509_OBJECT *)v6;
        }
      }
      else if (x->type != 1 || !X509_cmp(*((const X509 **)v6 + 1), x->data.x509))
      {
        return (X509_OBJECT *)v6;
      }
      ++v5;
    }
  }
  return 0;
}

int X509_STORE_CTX_get1_issuer(X509 **issuer, X509_STORE_CTX *ctx, X509 *x)
{
  *issuer = 0;
  issuer_name = X509_get_issuer_name(x);
  obj_by_subject = X509_STORE_CTX_get_obj_by_subject((uint64_t *)ctx, 1, issuer_name);
  if (!obj_by_subject) {
    return 0;
  }
  int v8 = (X509_CRL **)obj_by_subject;
  if (obj_by_subject->type != 1 || (x509 = obj_by_subject->data.x509) == 0)
  {
    X509_OBJECT_free((X509_CRL **)obj_by_subject);
    return 0;
  }
  if (!X509_up_ref((uint64_t)obj_by_subject->data.ptr))
  {
    X509_OBJECT_free(v8);
    return -1;
  }
  if (((unsigned int (*)(X509_STORE_CTX *, X509 *, X509 *))ctx->check_issued)(ctx, x, x509)
    && x509_check_cert_time((uint64_t)ctx, (uint64_t)x509, -1))
  {
    *issuer = x509;
    X509_OBJECT_free(v8);
    return 1;
  }
  X509_free(x509);
  X509_OBJECT_free(v8);
  if (!ctx->ctx) {
    return 0;
  }
  CRYPTO_lock(9, 11, 0, 0);
  int v12 = x509_object_idx_cnt(*(STACK **)ctx->ctx, 1, (uint64_t)issuer_name, 0);
  if (v12 == -1) {
    goto LABEL_24;
  }
  int v13 = v12;
  if (v12 >= sk_num(*(const STACK **)ctx->ctx)) {
    goto LABEL_24;
  }
  unsigned __int8 v14 = 0;
  do
  {
    long long v15 = sk_value(*(const STACK **)ctx->ctx, v13);
    if (*(_DWORD *)v15 != 1) {
      break;
    }
    uint64_t v16 = v15;
    subject_name = X509_get_subject_name(*((X509 **)v15 + 1));
    if (X509_NAME_cmp(issuer_name, subject_name)) {
      break;
    }
    if (((unsigned int (*)(X509_STORE_CTX *, X509 *, void))ctx->check_issued)(ctx, x, *((void *)v16 + 1)))
    {
      unsigned __int8 v14 = (X509 *)*((void *)v16 + 1);
      if (x509_check_cert_time((uint64_t)ctx, (uint64_t)v14, -1)) {
        break;
      }
    }
    ++v13;
  }
  while (v13 < sk_num(*(const STACK **)ctx->ctx));
  if (!v14)
  {
LABEL_24:
    int v10 = 0;
  }
  else if (X509_up_ref((uint64_t)v14))
  {
    *issuer = v14;
    int v10 = 1;
  }
  else
  {
    int v10 = -1;
  }
  CRYPTO_lock(10, 11, 0, 0);
  return v10;
}

uint64_t X509_STORE_get0_objects(uint64_t a1)
{
  return *(void *)a1;
}

void *X509_STORE_get_ex_data(const CRYPTO_EX_DATA *a1, int a2)
{
  return CRYPTO_get_ex_data(a1 + 7, a2);
}

uint64_t X509_STORE_set_ex_data(CRYPTO_EX_DATA *a1, int a2, void *a3)
{
  return CRYPTO_set_ex_data(a1 + 7, a2, a3);
}

int X509_STORE_set_flags(X509_STORE *ctx, unint64_t flags)
{
  return X509_VERIFY_PARAM_set_flags((X509_VERIFY_PARAM *)ctx->get_cert_methods, flags);
}

int X509_STORE_set_depth(X509_STORE *store, int depth)
{
  return 1;
}

int X509_STORE_set_purpose(X509_STORE *ctx, int purpose)
{
  return X509_VERIFY_PARAM_set_purpose((X509_VERIFY_PARAM *)ctx->get_cert_methods, purpose);
}

int X509_STORE_set_trust(X509_STORE *ctx, int trust)
{
  return X509_VERIFY_PARAM_set_trust((X509_VERIFY_PARAM *)ctx->get_cert_methods, trust);
}

int X509_STORE_set1_param(X509_STORE *ctx, X509_VERIFY_PARAM *pm)
{
  return X509_VERIFY_PARAM_set1((X509_VERIFY_PARAM *)ctx->get_cert_methods, pm);
}

uint64_t X509_STORE_get0_param(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t X509_STORE_set_verify(uint64_t result, uint64_t a2)
{
  *(void *)(result + 24) = a2;
  return result;
}

uint64_t X509_STORE_get_verify(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t X509_STORE_set_verify_cb(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32) = a2;
  return result;
}

uint64_t X509_STORE_get_verify_cb(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

unint64_t bn_div_words(unint64_t h, unint64_t l, unint64_t d)
{
  if (!d) {
    return -1;
  }
  int v6 = BN_num_bits_word(d);
  if (v6 != 64 && 1 << v6 < h) {
    bn_div_words_cold_1();
  }
  uint64_t v7 = 0;
  char v8 = 0;
  if (h >= d) {
    unint64_t v9 = d;
  }
  else {
    unint64_t v9 = 0;
  }
  unint64_t v10 = h - v9;
  int v11 = -v6;
  if (v6 == 64) {
    unint64_t v12 = v10;
  }
  else {
    unint64_t v12 = (v10 << -(char)v6) | (l >> v6);
  }
  unint64_t v13 = d << v11;
  unint64_t v14 = l << v11;
  if (v6 == 64)
  {
    unint64_t v14 = l;
    unint64_t v13 = d;
  }
  unint64_t v15 = HIDWORD(v13);
  while (1)
  {
    if (v15 == HIDWORD(v12)) {
      uint64_t v16 = 0xFFFFFFFFLL;
    }
    else {
      uint64_t v16 = v12 / v15;
    }
    uint64_t v17 = v16 * v15;
    unint64_t v18 = v16 * v13;
    *((void *)&v20 + 1) = v12 - v16 * v15;
    *(void *)&long long v20 = v14;
    unint64_t v19 = v20 >> 32;
    if (HIDWORD(*((void *)&v20 + 1))) {
      BOOL v21 = 0;
    }
    else {
      BOOL v21 = v18 > v19;
    }
    if (v21)
    {
      uint64_t v22 = 0;
      uint64_t v23 = 0;
      uint64_t v24 = v13 * (v16 - 1);
      unint64_t v25 = v12 - v15 * (v16 - 1);
      do
      {
        --v16;
        unint64_t v26 = v25 + v22;
        uint64_t v27 = v23 - v13;
        v22 += v15;
        if (HIDWORD(v26)) {
          break;
        }
        unint64_t v28 = v24 + v23;
        *((void *)&v29 + 1) = v26;
        *(void *)&long long v29 = v14;
        v23 -= v13;
      }
      while (v28 > (unint64_t)(v29 >> 32));
      v18 += v27;
      v17 -= v22;
    }
    unint64_t v30 = v17 + HIDWORD(v18);
    if (v14 < v18 << 32) {
      ++v30;
    }
    uint64_t v31 = (__PAIR128__(v16, v12) - v30) >> 64;
    if (v8) {
      break;
    }
    int v32 = v12 - v30;
    if (v12 >= v30) {
      int v33 = 0;
    }
    else {
      int v33 = v13;
    }
    uint64_t v34 = (v32 + v33);
    uint64_t v7 = v31 << 32;
    *((void *)&v35 + 1) = v34;
    *(void *)&long long v35 = v14 - (v18 << 32);
    unint64_t v12 = v35 >> 32;
    v14 <<= 32;
    char v8 = 1;
  }
  return v31 | v7;
}

unint64_t bn_div_rem_words(unint64_t a1, unint64_t a2, unint64_t a3, unint64_t *a4, void *a5)
{
  unint64_t result = bn_div_words(a1, a2, a3);
  *a4 = result;
  *a5 = a2 - result * a3;
  return result;
}

unint64_t bn_div_3_words(unint64_t *a1, unint64_t a2, unint64_t a3)
{
  unint64_t v4 = *a1;
  if (v4 == a3) {
    return -1;
  }
  unint64_t v8 = *(a1 - 1);
  unint64_t result = bn_div_words(v4, v8, a3);
  unint64_t v9 = result * (unint64_t)HIDWORD(a2);
  unint64_t v10 = (v9 << 32) + result * (unint64_t)a2;
  unint64_t v11 = ((result * (unint64_t)a2) | (v9 << 32)) & ~v10 | (result
                                                                                           * (unint64_t)a2) & (v9 << 32);
  unint64_t v12 = HIDWORD(result) * (unint64_t)a2;
  unint64_t v13 = v10 | (v12 << 32);
  unint64_t v14 = v10 & (v12 << 32);
  unint64_t v15 = v10 + (v12 << 32);
  unint64_t v16 = HIDWORD(v9)
      + HIDWORD(result) * (unint64_t)HIDWORD(a2)
      + HIDWORD(v12)
      + (v11 >> 63)
      + ((v13 & ~v15 | v14) >> 63);
  if (v16 >= v8 - result * a3)
  {
    uint64_t v17 = -(uint64_t)(result * a3);
    unint64_t v18 = a3 - result * a3;
    while (1)
    {
      unint64_t v19 = result;
      if (v17 + v8 == v16 && v15 <= *(a1 - 2)) {
        break;
      }
      if (v18 + v8 >= a3)
      {
        BOOL v20 = v15 >= a2;
        v15 -= a2;
        uint64_t v21 = !v20;
        v16 -= v21;
        v8 += a3;
        --result;
        if (v16 >= v17 + v8) {
          continue;
        }
      }
      return v19 - 1;
    }
  }
  return result;
}

int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx)
{
  if (BN_get_flags((uint64_t)m, 4u)) {
    BOOL v10 = 1;
  }
  else {
    BOOL v10 = BN_get_flags((uint64_t)d, 4u) != 0;
  }
  return BN_div_internal((uint64_t)dv, rem, m, d, ctx, v10);
}

uint64_t BN_div_internal(uint64_t a1, BIGNUM *a2, const BIGNUM *a3, const BIGNUM *a4, BN_CTX *ctx, int a6)
{
  memset(&a, 0, sizeof(a));
  BN_CTX_start(ctx);
  int top = a3->top;
  BOOL v13 = __OFSUB__(top, 1);
  int v14 = top - 1;
  if (v14 < 0 == v13 && !a3->d[v14])
  {
    int v16 = 107;
    int v17 = 252;
    goto LABEL_25;
  }
  if (a6) {
    int v15 = -1;
  }
  else {
    int v15 = 0;
  }
  if (BN_is_zero((uint64_t)a4))
  {
    int v16 = 103;
    int v17 = 260;
LABEL_25:
    ERR_put_error(3, 4095, v16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_div.c", v17);
    goto LABEL_26;
  }
  if (!a6 && BN_ucmp(a3, a4) < 0)
  {
    if (a2 && !bn_copy(a2, a3)) {
      goto LABEL_26;
    }
    if (a1) {
      BN_zero(a1);
    }
LABEL_60:
    a1 = 1;
    goto LABEL_27;
  }
  unint64_t v18 = BN_CTX_get(ctx);
  if (!v18) {
    goto LABEL_26;
  }
  unint64_t v19 = v18;
  BOOL v20 = BN_CTX_get(ctx);
  if (!v20) {
    goto LABEL_26;
  }
  uint64_t v21 = v20;
  r = a2;
  p_char d = &v19->d;
  uint64_t v22 = BN_CTX_get(ctx);
  if (!v22) {
    goto LABEL_26;
  }
  uint64_t v23 = v22;
  if (a1 || (a1 = (uint64_t)BN_CTX_get(ctx)) != 0)
  {
    int v24 = BN_num_bits(a4);
    if (v24 <= 0) {
      int v25 = -(-v24 & 0x3F);
    }
    else {
      int v25 = v24 & 0x3F;
    }
    if (!BN_lshift(v23, a4, 64 - v25)) {
      goto LABEL_26;
    }
    b = v23;
    v23->int neg = 0;
    int v26 = 128 - v25;
    if (!BN_lshift(v21, a3, 128 - v25)) {
      goto LABEL_26;
    }
    v21->int neg = 0;
    int v27 = v21->top;
    if (a6)
    {
      int v28 = v23->top;
      if (v27 <= v28 + 1)
      {
        if (!bn_wexpand((uint64_t)v21, (v28 + 2))) {
          goto LABEL_26;
        }
        uint64_t v31 = v21->top;
        int v32 = v23->top;
        int v27 = v32 + 2;
        if ((int)v31 < v32 + 2) {
          bzero(&v21->d[v31], 8 * (v32 - v31 + 1) + 8);
        }
      }
      else
      {
        if (!bn_wexpand((uint64_t)v21, (v27 + 1)))
        {
LABEL_26:
          a1 = 0;
          goto LABEL_27;
        }
        uint64_t v29 = v21->top;
        v21->d[v29] = 0;
        int v27 = v29 + 1;
      }
      v21->int top = v27;
    }
    uint64_t v33 = v23->top;
    int v34 = v27 - v33;
    a.int neg = 0;
    char d = v21->d;
    a.char d = &v21->d[v27 - (int)v33];
    int v35 = v21->dmax - (v27 - v33);
    a.int top = v33;
    a.dmax = v35;
    a.flags = v21->flags | 2;
    int v36 = v23->d;
    int n = v26;
    int v53 = v27;
    *(void *)num = v33;
    if (v33 == 1) {
      unint64_t v56 = 0;
    }
    else {
      unint64_t v56 = v36[(int)v33 - 2];
    }
    unint64_t v57 = v36[(int)v33 - 1];
    int v37 = v27 - v33;
    if (!bn_wexpand(a1, (v34 + 1))) {
      goto LABEL_26;
    }
    *(_DWORD *)(a1 + 8) = v37 + v15;
    int neg = a3->neg;
    int v39 = a4->neg;
    uint64_t v40 = *(void *)a1;
    if (!bn_wexpand((uint64_t)p_d, (num[0] + 1))) {
      goto LABEL_26;
    }
    int v41 = (unint64_t *)(v40 + 8 * (v37 - 1));
    if (!a6)
    {
      if (BN_ucmp(&a, b) < 0)
      {
        int v42 = *(_DWORD *)(a1 + 8) - 1;
        *(_DWORD *)(a1 + 8) = v42;
        goto LABEL_46;
      }
      bn_sub_words(a.d, a.d, b->d, num[0]);
      *int v41 = 1;
    }
    int v42 = *(_DWORD *)(a1 + 8);
LABEL_46:
    int v49 = v39;
    BIGNUM v50 = (uint64_t *)v21;
    if (v42) {
      --v41;
    }
    else {
      *(_DWORD *)(a1 + 16) = 0;
    }
    if (v37 >= 2)
    {
      int v43 = v53 - 1;
      int v44 = &d[v53 - 1];
      do
      {
        unint64_t v45 = bn_div_3_words(v44, v56, v57);
        unint64_t v46 = bn_mul_words(*p_d, b->d, num[0], v45);
        int v47 = *p_d;
        (*p_d)[*(void *)num] = v46;
        --a.d;
        if (bn_sub_words(a.d, a.d, v47, num[0] + 1))
        {
          --v45;
          if (bn_add_words(a.d, a.d, b->d, num[0])) {
            ++*v44;
          }
        }
        *v41-- = v45;
        --v44;
        --v43;
      }
      while (num[0] != v43);
    }
    bn_correct_top(v50);
    if (r)
    {
      int v48 = a3->neg;
      BN_rshift(r, (const BIGNUM *)v50, n);
      BN_set_negative(r, v48);
    }
    if (a6) {
      bn_correct_top((uint64_t *)a1);
    }
    BN_set_negative((BIGNUM *)a1, v49 ^ neg);
    goto LABEL_60;
  }
LABEL_27:
  BN_CTX_end(ctx);
  return a1;
}

uint64_t BN_div_nonct(uint64_t a1, BIGNUM *a2, const BIGNUM *a3, const BIGNUM *a4, BN_CTX *a5)
{
  return BN_div_internal(a1, a2, a3, a4, a5, 0);
}

uint64_t BN_div_ct(uint64_t a1, BIGNUM *a2, const BIGNUM *a3, const BIGNUM *a4, BN_CTX *a5)
{
  return BN_div_internal(a1, a2, a3, a4, a5, 1);
}

void bn_div_words_cold_1()
{
  __assert_rtn("bn_div_words", "bn_div.c", 96, "(i == BN_BITS2) || (h <= (BN_ULONG)1 << i)");
}

int X509_print_fp(FILE *bp, X509 *x)
{
  return X509_print_ex_fp(bp, x, 0, 0);
}

int X509_print_ex_fp(FILE *bp, X509 *x, unint64_t nmflag, unint64_t cflag)
{
  unint64_t v8 = BIO_s_file();
  unint64_t v9 = BIO_new(v8);
  if (v9)
  {
    BOOL v10 = v9;
    BIO_ctrl(v9, 106, 0, bp);
    int v11 = X509_print_ex(v10, x, nmflag, cflag);
    BIO_free(v10);
    return v11;
  }
  else
  {
    ERR_put_error(11, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/t_x509.c", 96);
    return 0;
  }
}

int X509_print_ex(BIO *bp, X509 *x, unint64_t nmflag, unint64_t cflag)
{
  if ((nmflag & 0xF0000) == 0x40000) {
    uint64_t v8 = 10;
  }
  else {
    uint64_t v8 = 32;
  }
  if ((nmflag & 0xF0000) == 0x40000) {
    int v9 = 12;
  }
  else {
    int v9 = 0;
  }
  if (nmflag) {
    int v10 = v9;
  }
  else {
    int v10 = 16;
  }
  cert_info = x->cert_info;
  if ((cflag & 1) == 0 && (BIO_write(bp, "Certificate:\n", 13) < 1 || BIO_write(bp, "    Data:\n", 10) < 1)) {
    return 0;
  }
  if ((cflag & 2) == 0)
  {
    int v12 = (unint64_t)X509_get_version((ASN1_INTEGER ***)x) > 2
        ? BIO_printf(bp, "%8sVersion: unknown (%ld)\n")
        : BIO_printf(bp, "%8sVersion: %ld (0x%lx)\n");
    if (v12 < 1) {
      return 0;
    }
  }
  uint64_t v27 = v8;
  if ((cflag & 4) == 0)
  {
    if (BIO_write(bp, "        Serial Number:", 22) < 1) {
      return 0;
    }
    serialNumber = X509_get_serialNumber(x);
    int v14 = serialNumber;
    if (serialNumber->length > 8 || (uint64_t v15 = ASN1_INTEGER_get(serialNumber), v15 < 0))
    {
      if (v14->type == 258) {
        uint64_t v23 = " (Negative)";
      }
      else {
        uint64_t v23 = "";
      }
      if (BIO_printf(bp, "\n%12s%s", "", v23) < 1) {
        return 0;
      }
      uint64_t v24 = 0;
      while (v24 < v14->length)
      {
        int v25 = v14->data[v24++];
        if (v24 == v14->length) {
          uint64_t v26 = 10;
        }
        else {
          uint64_t v26 = 58;
        }
        if (BIO_printf(bp, "%02x%c", v25, v26) < 1) {
          return 0;
        }
      }
    }
    else if (BIO_printf(bp, " %ld (0x%lx)\n", v15, v15) < 1)
    {
      return 0;
    }
  }
  if ((cflag & 8) == 0 && X509_signature_print(bp, x->sig_alg, 0) < 1) {
    return 0;
  }
  if ((cflag & 0x10) == 0)
  {
    if (BIO_printf(bp, "        Issuer:%c", v27) < 1) {
      return 0;
    }
    issuer_name = X509_get_issuer_name(x);
    if (X509_NAME_print_ex(bp, issuer_name, v10, nmflag) < (nmflag == 0) || BIO_write(bp, "\n", 1) < 1) {
      return 0;
    }
  }
  if ((cflag & 0x20) == 0)
  {
    if (BIO_write(bp, "        Validity\n", 17) < 1 || BIO_write(bp, "            Not Before: ", 24) < 1) {
      return 0;
    }
    int v17 = (ASN1_TIME *)X509_getm_notBefore((uint64_t)x);
    int result = ASN1_TIME_print(bp, v17);
    if (!result) {
      return result;
    }
    if (BIO_write(bp, "\n            Not After : ", 25) < 1) {
      return 0;
    }
    unint64_t v19 = (ASN1_TIME *)X509_getm_notAfter((uint64_t)x);
    int result = ASN1_TIME_print(bp, v19);
    if (!result) {
      return result;
    }
    if (BIO_write(bp, "\n", 1) < 1) {
      return 0;
    }
  }
  if ((cflag & 0x40) == 0)
  {
    if (BIO_printf(bp, "        Subject:%c", v27) < 1) {
      return 0;
    }
    subject_name = X509_get_subject_name(x);
    if (X509_NAME_print_ex(bp, subject_name, v10, nmflag) < (nmflag == 0) || BIO_write(bp, "\n", 1) < 1) {
      return 0;
    }
  }
  if ((cflag & 0x80) == 0)
  {
    if (BIO_write(bp, "        Subject Public Key Info:\n", 33) >= 1
      && BIO_printf(bp, "%12sPublic Key Algorithm: ", "") >= 1
      && i2a_ASN1_OBJECT(bp, cert_info->key->algor->algorithm) >= 1
      && BIO_puts(bp, "\n") >= 1)
    {
      pubuint64_t key = X509_get_pubkey(x);
      if (pubkey)
      {
        uint64_t v22 = pubkey;
        EVP_PKEY_print_public(bp, (uint64_t)pubkey, 16);
        EVP_PKEY_free(v22);
      }
      else
      {
        BIO_printf(bp, "%12sUnable to load Public Key\n", "");
        ERR_print_errors(bp);
      }
      goto LABEL_60;
    }
    return 0;
  }
LABEL_60:
  if ((cflag & 0x100) == 0) {
    X509V3_extensions_print(bp, "X509v3 extensions", cert_info->extensions, cflag, 8);
  }
  if ((cflag & 0x200) == 0 && X509_signature_print(bp, x->sig_alg, x->signature) < 1) {
    return 0;
  }
  if ((cflag & 0x400) != 0) {
    return 1;
  }
  int result = X509_CERT_AUX_print(bp, (X509_CERT_AUX *)x[1].ex_pcpathlen, 0);
  if (result) {
    return 1;
  }
  return result;
}

int X509_print(BIO *bp, X509 *x)
{
  return X509_print_ex(bp, x, 0, 0);
}

int X509_signature_print(BIO *bp, X509_ALGOR *alg, ASN1_STRING *sig)
{
  if (BIO_puts(bp, "    Signature Algorithm: ") < 1 || i2a_ASN1_OBJECT(bp, alg->algorithm) < 1) {
    return 0;
  }
  int v6 = OBJ_obj2nid(alg->algorithm);
  if (v6)
  {
    uint64_t v10 = 0;
    if (OBJ_find_sigid_algs(v6, &v10, (_DWORD *)&v10 + 1))
    {
      uint64_t v7 = EVP_PKEY_asn1_find(0, SHIDWORD(v10));
      if (v7)
      {
        uint64_t v8 = *(uint64_t (**)(BIO *, X509_ALGOR *, ASN1_STRING *, uint64_t, void))(v7 + 160);
        if (v8) {
          return v8(bp, alg, sig, 9, 0);
        }
      }
    }
  }
  if (sig) {
    return X509_signature_dump(bp, (unsigned int *)sig, 9);
  }
  return BIO_puts(bp, "\n") > 0;
}

int ASN1_TIME_print(BIO *fp, ASN1_TIME *a)
{
  int type = a->type;
  if (type == 24)
  {
    return ASN1_GENERALIZEDTIME_print(fp, a);
  }
  else if (type == 23)
  {
    return ASN1_UTCTIME_print(fp, a);
  }
  else
  {
    BIO_write(fp, "Bad time value", 14);
    return 0;
  }
}

int X509_ocspid_print(BIO *bp, X509 *x)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  if (BIO_printf(bp, "        Subject OCSP hash: ") < 1 || (int v4 = i2d_X509_NAME(x->cert_info->subject, 0), v4 < 1))
  {
LABEL_15:
    int v6 = 0;
  }
  else
  {
    size_t v5 = v4;
    int v6 = (unsigned __int8 *)malloc_type_malloc(v4, 0x76F293E4uLL);
    out = v6;
    if (v6)
    {
      if (i2d_X509_NAME(x->cert_info->subject, &out) >= 1)
      {
        uint64_t v7 = EVP_sha1();
        if (EVP_Digest(v6, v5, md, 0, v7, 0))
        {
          uint64_t v8 = 0;
          while (BIO_printf(bp, "%02X", md[v8]) >= 1)
          {
            if (++v8 == 20)
            {
              free(v6);
              if (BIO_printf(bp, "\n        Public key OCSP hash: ") >= 1)
              {
                public_uint64_t key = x->cert_info->key->public_key;
                int data = public_key->data;
                size_t length = public_key->length;
                int v12 = EVP_sha1();
                if (EVP_Digest(data, length, md, 0, v12, 0))
                {
                  uint64_t v13 = 0;
                  while (BIO_printf(bp, "%02X", md[v13]) >= 1)
                  {
                    if (++v13 == 20)
                    {
                      BIO_printf(bp, "\n");
                      return 1;
                    }
                  }
                }
              }
              goto LABEL_15;
            }
          }
        }
      }
    }
  }
  free(v6);
  return 0;
}

BOOL X509_signature_dump(BIO *b, unsigned int *a2, int a3)
{
  unsigned int v5 = 0;
  int v6 = 0;
  uint64_t v7 = *a2;
  uint64_t v8 = (unsigned __int8 *)*((void *)a2 + 1);
  uint64_t v9 = v7 & ~((int)v7 >> 31);
  uint64_t v10 = v7 - 1;
  while (v9)
  {
    if (v6 + 18 * (v5 / 0x12) || BIO_write(b, "\n", 1) >= 1 && BIO_indent(b, a3, a3) >= 1)
    {
      int v12 = *v8++;
      int v11 = v12;
      uint64_t v13 = v10 ? ":" : "";
      --v9;
      --v6;
      ++v5;
      --v10;
      if (BIO_printf(b, "%02x%s", v11, v13) >= 1) {
        continue;
      }
    }
    return 0;
  }
  return BIO_write(b, "\n", 1) == 1;
}

int ASN1_UTCTIME_print(BIO *fp, ASN1_UTCTIME *a)
{
  int length = a->length;
  if (a->length >= 10)
  {
    uint64_t v4 = 0;
    int data = a->data;
    int v6 = data[length - 1];
    while (data[v4] - 58 >= 0xFFFFFFF6)
    {
      if (++v4 == 10)
      {
        int v7 = (char)data[1] + 10 * (char)*data;
        if (v7 >= 578) {
          int v8 = -528;
        }
        else {
          int v8 = -428;
        }
        int v9 = (char)data[3] + 10 * (char)data[2];
        if ((v9 - 541) < 0xFFFFFFF4) {
          break;
        }
        int v10 = (char)data[5] + 10 * (char)data[4] - 528;
        int v11 = (char)data[7] + 10 * (char)data[6] - 528;
        int v12 = (char)data[9] + 10 * (char)data[8] - 528;
        if (length < 12 || (int v13 = (char)data[10], (v13 - 48) > 9))
        {
          int v16 = 0;
        }
        else
        {
          int v14 = data[11];
          unsigned int v15 = v14 - 48;
          int v16 = v14 + 10 * v13 - 528;
          if (v15 > 9) {
            int v16 = 0;
          }
        }
        int v17 = v7 + v8 + 1900;
        if (v6 == 90) {
          unint64_t v18 = " GMT";
        }
        else {
          unint64_t v18 = "";
        }
        return BIO_printf(fp, "%s %2d %02d:%02d:%02d %d%s", mon[v9 - 529], v10, v11, v12, v16, v17, v18) > 0;
      }
    }
  }
  BIO_write(fp, "Bad time value", 14);
  return 0;
}

int ASN1_GENERALIZEDTIME_print(BIO *fp, ASN1_GENERALIZEDTIME *a)
{
  int length = a->length;
  if (a->length >= 12)
  {
    uint64_t v4 = 0;
    int data = a->data;
    int v6 = data[length - 1];
    do
    {
      if (data[v4] - 58 < 0xFFFFFFF6) {
        goto LABEL_2;
      }
      ++v4;
    }
    while (v4 != 12);
    int v7 = (char)data[5] + 10 * (char)data[4];
    if ((v7 - 541) < 0xFFFFFFF4) {
      goto LABEL_2;
    }
    int v8 = 100 * (char)data[1] + 1000 * (char)*data + 10 * (char)data[2] + (char)data[3] - 53328;
    int v9 = (char)data[7] + 10 * (char)data[6] - 528;
    int v10 = (char)data[9] + 10 * (char)data[8] - 528;
    int v11 = (char)data[11] + 10 * (char)data[10] - 528;
    uint64_t v12 = (length - 14);
    if (length < 14)
    {
      int v15 = 0;
      LODWORD(v12) = 0;
      int v16 = "";
    }
    else
    {
      int v13 = (char)data[12];
      if ((v13 - 48) > 9 || (int v14 = data[13], (v14 - 48) > 9))
      {
        int v15 = 0;
      }
      else
      {
        int v15 = v14 + 10 * v13 - 528;
        if (length >= 0xF)
        {
          int v16 = (const char *)(data + 14);
          if (data[14] == 46)
          {
            if (length < 0x10)
            {
              LODWORD(v12) = 1;
            }
            else
            {
              uint64_t v17 = 0;
              unint64_t v18 = data + 15;
              while (v18[v17] - 48 <= 9)
              {
                if (v12 - 1 == ++v17) {
                  goto LABEL_21;
                }
              }
              LODWORD(v12) = v17 + 1;
            }
            goto LABEL_21;
          }
        }
      }
      LODWORD(v12) = 0;
      int v16 = "";
    }
LABEL_21:
    unint64_t v19 = mon[v7 - 529];
    if (v6 == 90) {
      BOOL v20 = " GMT";
    }
    else {
      BOOL v20 = "";
    }
    return BIO_printf(fp, "%s %2d %02d:%02d:%02d%.*s %d%s", v19, v9, v10, v11, v15, v12, v16, v8, v20) > 0;
  }
LABEL_2:
  BIO_write(fp, "Bad time value", 14);
  return 0;
}

int X509_NAME_print(BIO *bp, X509_NAME *name, int obase)
{
  uint64_t v4 = X509_NAME_oneline(name, 0, 0);
  if (!v4) {
    return 0;
  }
  unsigned int v5 = v4;
  if (!*v4)
  {
    free(v4);
    return 1;
  }
  int v6 = v4 + 1;
  uint64_t v7 = 2;
  while (1)
  {
    int v8 = &v5[v7];
    int v9 = v5[v7 - 1];
    if (!v5[v7 - 1]) {
      break;
    }
    if (v9 == 47)
    {
      if (v5[v7] - 65 > 0x19
        || (int v10 = v5[v7 + 1], v10 != 61) && ((v10 - 65) > 0x19 || v5[v7 + 2] != 61))
      {
        int v9 = 47;
        goto LABEL_15;
      }
      break;
    }
LABEL_15:
    ++v7;
    if (!v9) {
      goto LABEL_16;
    }
  }
  if (~v6 + v5 + v7 != BIO_write(bp, v6, ~v6 + v5 + v7)) {
    goto LABEL_19;
  }
  if (!*(v8 - 1))
  {
LABEL_16:
    int v11 = 1;
    goto LABEL_20;
  }
  if (BIO_write(bp, ", ", 2) == 2)
  {
    int v6 = &v5[v7];
    int v9 = *(v8 - 1);
    goto LABEL_15;
  }
LABEL_19:
  ERR_put_error(11, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/t_x509.c", 508);
  int v11 = 0;
LABEL_20:
  free(v5);
  return v11;
}

int CONF_modules_load(const CONF *cnf, const char *appname, unint64_t flags)
{
  if (cnf)
  {
    char v3 = flags;
    if (!appname) {
      goto LABEL_5;
    }
    int string = NCONF_get_string(cnf, 0, appname);
    if (string) {
      goto LABEL_6;
    }
    if ((v3 & 0x20) != 0)
    {
LABEL_5:
      int string = NCONF_get_string(cnf, 0, "openssl_conf");
      if (string)
      {
LABEL_6:
        sectioint n = NCONF_get_section(cnf, string);
        if (!section) {
          return (int)section;
        }
        uint64_t v7 = section;
        if (sk_num(section) >= 1)
        {
          int v8 = 0;
          while (1)
          {
            int v9 = sk_value(v7, v8);
            int v10 = (char *)*((void *)v9 + 1);
            int v11 = (const char *)*((void *)v9 + 2);
            uint64_t v12 = strrchr(v10, 46);
            int v13 = v12 ? (int)v12 - (int)v10 : strlen(v10);
            if (sk_num((const STACK *)supported_modules) >= 1) {
              break;
            }
LABEL_16:
            if ((v3 & 8) == 0)
            {
              int v16 = NCONF_get_string(cnf, v11, "path");
              if (!v16)
              {
                ERR_clear_error();
                int v16 = v10;
              }
              uint64_t v17 = DSO_load(0, v16, 0, 0);
              if (v17)
              {
                unint64_t v18 = v17;
                DSO_FUNC_TYPE v19 = DSO_bind_func(v17, "OPENSSL_init");
                if (v19)
                {
                  uint64_t v20 = (uint64_t)v19;
                  DSO_FUNC_TYPE v21 = DSO_bind_func(v18, "OPENSSL_finish");
                  int v15 = (const char **)module_add((uint64_t)v18, v10, v20, (uint64_t)v21);
                  if (v15) {
                    goto LABEL_22;
                  }
                  int v28 = 0;
                }
                else
                {
                  int v28 = 112;
                }
                DSO_free(v18);
              }
              else
              {
                int v28 = 110;
              }
              ERR_put_error(14, 4095, v28, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_mod.c", 273);
              ERR_asprintf_error_data("module=%s, path=%s", v10, v16);
            }
            if ((v3 & 4) == 0)
            {
              ERR_put_error(14, 4095, 113, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_mod.c", 214);
              ERR_asprintf_error_data("module=%s");
            }
LABEL_42:
            if ((v3 & 1) == 0)
            {
              LODWORD(section) = -1;
              return (int)section;
            }
LABEL_43:
            if (++v8 >= sk_num(v7)) {
              goto LABEL_58;
            }
          }
          int v14 = 0;
          while (1)
          {
            int v15 = (const char **)sk_value((const STACK *)supported_modules, v14);
            if (!strncmp(v15[1], v10, v13)) {
              break;
            }
            if (++v14 >= sk_num((const STACK *)supported_modules)) {
              goto LABEL_16;
            }
          }
LABEL_22:
          uint64_t v22 = (char *)malloc_type_malloc(0x28uLL, 0x10B0040F35B56FDuLL);
          if (!v22)
          {
LABEL_34:
            if ((v3 & 4) == 0)
            {
              ERR_put_error(14, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_mod.c", 224);
              ERR_asprintf_error_data("module=%s, value=%s, retcode=%-8d");
            }
            goto LABEL_42;
          }
          uint64_t v23 = v22;
          *(void *)uint64_t v22 = v15;
          if (v10)
          {
            uint64_t v24 = strdup(v10);
            *((void *)v23 + 1) = v24;
            if (v11)
            {
LABEL_25:
              int v25 = strdup(v11);
              *((void *)v23 + 2) = v25;
              *((void *)v23 + 4) = 0;
              if (v24 && v25)
              {
                uint64_t v26 = v15[2];
                if (v26)
                {
                  int v27 = 1;
                  if (((int (*)(char *, const CONF *))v26)(v23, cnf) < 1)
                  {
LABEL_53:
                    if (v27)
                    {
                      uint64_t v31 = v15[3];
                      if (v31) {
                        ((void (*)(char *))v31)(v23);
                      }
                    }
                    goto LABEL_33;
                  }
                }
                else
                {
                  int v27 = 0;
                }
                uint64_t v29 = (STACK *)initialized_modules;
                if (initialized_modules || (uint64_t v29 = sk_new_null(), (initialized_modules = (uint64_t)v29) != 0))
                {
                  if (sk_push(v29, v23))
                  {
                    ++*((_DWORD *)v15 + 8);
                    goto LABEL_43;
                  }
                  int v30 = 376;
                }
                else
                {
                  int v30 = 370;
                }
                ERR_put_error(14, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_mod.c", v30);
                goto LABEL_53;
              }
LABEL_33:
              free(*((void **)v23 + 1));
              free(*((void **)v23 + 2));
              free(v23);
              goto LABEL_34;
            }
          }
          else
          {
            uint64_t v24 = 0;
            *((void *)v22 + 1) = 0;
            if (v11) {
              goto LABEL_25;
            }
          }
          *((void *)v23 + 2) = 0;
          *((void *)v23 + 4) = 0;
          goto LABEL_33;
        }
LABEL_58:
        LODWORD(section) = 1;
        return (int)section;
      }
    }
    ERR_clear_error();
    goto LABEL_58;
  }
  LODWORD(section) = 1;
  return (int)section;
}

int CONF_modules_load_file(const char *filename, const char *appname, unint64_t flags)
{
  int v6 = NCONF_new(0);
  if (!v6)
  {
    uint64_t v7 = 0;
LABEL_8:
    int v11 = 0;
    goto LABEL_9;
  }
  uint64_t v7 = filename;
  if (!filename)
  {
    int v13 = 0;
    default_cert_areBIGNUM a = X509_get_default_cert_area();
    int v9 = asprintf(&v13, "%s/openssl.cnf", default_cert_area);
    int v10 = 0;
    int v11 = 0;
    if (v9 == -1) {
      goto LABEL_10;
    }
    uint64_t v7 = v13;
    if (!v13) {
      goto LABEL_10;
    }
  }
  if (NCONF_load(v6, v7, 0) > 0)
  {
    int v11 = CONF_modules_load(v6, appname, flags);
    goto LABEL_9;
  }
  if ((flags & 0x10) == 0 || (ERR_peek_last_error() & 0xFFF) != 0x72) {
    goto LABEL_8;
  }
  ERR_clear_error();
  int v11 = 1;
LABEL_9:
  int v10 = (char *)v7;
  if (!filename) {
LABEL_10:
  }
    free(v10);
  NCONF_free(v6);
  return v11;
}

char *CONF_get1_default_config_file(void)
{
  uint64_t v2 = 0;
  default_cert_areBIGNUM a = X509_get_default_cert_area();
  if (asprintf(&v2, "%s/openssl.cnf", default_cert_area) == -1) {
    return 0;
  }
  else {
    return v2;
  }
}

void CONF_modules_unload(int all)
{
  CONF_modules_finish();
  int v2 = sk_num((const STACK *)supported_modules);
  if (v2 >= 1)
  {
    for (unsigned int i = v2 + 1; i > 1; --i)
    {
      uint64_t v4 = sk_value((const STACK *)supported_modules, i - 2);
      unsigned int v5 = v4;
      if (*((int *)v4 + 8) <= 0)
      {
        if (all || *(void *)v4)
        {
LABEL_5:
          sk_delete((STACK *)supported_modules, i - 2);
          if (*(void *)v5) {
            DSO_free(*(DSO **)v5);
          }
          free(*((void **)v5 + 1));
          free(v5);
        }
      }
      else if (all)
      {
        goto LABEL_5;
      }
    }
  }
  if (!sk_num((const STACK *)supported_modules))
  {
    sk_free((STACK *)supported_modules);
    supported_modules = 0;
  }
}

void CONF_modules_finish(void)
{
  if (sk_num((const STACK *)initialized_modules) >= 1)
  {
    do
    {
      int v0 = sk_pop((STACK *)initialized_modules);
      uint64_t v1 = (void **)v0;
      int v2 = *(_DWORD **)v0;
      char v3 = *(void (**)(char *))(*(void *)v0 + 24);
      if (v3)
      {
        v3(v0);
        int v2 = *v1;
      }
      --v2[8];
      free(v1[1]);
      free(v1[2]);
      free(v1);
    }
    while (sk_num((const STACK *)initialized_modules) > 0);
  }
  sk_free((STACK *)initialized_modules);
  initialized_modules = 0;
}

int CONF_module_add(const char *name, conf_init_func *ifunc, conf_finish_func *ffunc)
{
  return module_add(0, name, (uint64_t)ifunc, (uint64_t)ffunc) != 0;
}

void *module_add(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  if (!a2) {
    return 0;
  }
  if (!supported_modules)
  {
    supported_modules = (uint64_t)sk_new_null();
    if (!supported_modules) {
      return 0;
    }
  }
  int v8 = malloc_type_malloc(0x30uLL, 0x10B004022DC5C45uLL);
  int v9 = v8;
  if (v8)
  {
    *int v8 = a1;
    v8[1] = strdup(a2);
    v9[2] = a3;
    void v9[3] = a4;
    *((_DWORD *)v9 + 8) = 0;
    if (!sk_push((STACK *)supported_modules, (char *)v9))
    {
      free(v9);
      return 0;
    }
  }
  return v9;
}

void CONF_modules_free(void)
{
  CONF_modules_finish();
  CONF_modules_unload(1);
}

const char *__cdecl CONF_imodule_get_name(const CONF_IMODULE *md)
{
  return (const char *)*((void *)md + 1);
}

const char *__cdecl CONF_imodule_get_value(const CONF_IMODULE *md)
{
  return (const char *)*((void *)md + 2);
}

void *__cdecl CONF_imodule_get_usr_data(const CONF_IMODULE *md)
{
  return (void *)*((void *)md + 4);
}

void CONF_imodule_set_usr_data(CONF_IMODULE *md, void *usr_data)
{
  *((void *)md + 4) = usr_data;
}

CONF_MODULE *__cdecl CONF_imodule_get_module(const CONF_IMODULE *md)
{
  return *(CONF_MODULE **)md;
}

unint64_t CONF_imodule_get_flags(const CONF_IMODULE *md)
{
  return *((void *)md + 3);
}

void CONF_imodule_set_flags(CONF_IMODULE *md, unint64_t flags)
{
  *((void *)md + 3) = flags;
}

void *__cdecl CONF_module_get_usr_data(CONF_MODULE *pmod)
{
  return (void *)*((void *)pmod + 5);
}

void CONF_module_set_usr_data(CONF_MODULE *pmod, void *usr_data)
{
  *((void *)pmod + 5) = usr_data;
}

int CONF_parse_list(const char *list, int sep, int nospc, int (__cdecl *list_cb)(const char *, int, void *), void *arg)
{
  if (list)
  {
    int v9 = (char *)list;
    uint64_t v10 = MEMORY[0x263EF8318];
    while (1)
    {
      if (nospc)
      {
        unsigned int v11 = *v9;
        if (*v9)
        {
          do
          {
            if ((v11 & 0x80) != 0)
            {
              if (!__maskrune(v11, 0x4000uLL)) {
                break;
              }
            }
            else if ((*(_DWORD *)(v10 + 4 * v11 + 60) & 0x4000) == 0)
            {
              break;
            }
            unsigned int v12 = *++v9;
            unsigned int v11 = v12;
          }
          while (v12);
        }
      }
      int v13 = strchr(v9, sep);
      int v14 = v13;
      if (v13 != v9)
      {
        if (*v9) {
          break;
        }
      }
      unint64_t v18 = 0;
      uint64_t v19 = 0;
LABEL_23:
      int result = ((uint64_t (*)(char *, uint64_t, void *))list_cb)(v18, v19, arg);
      if (result < 1) {
        return result;
      }
      int v9 = v14 + 1;
      if (!v14) {
        return 1;
      }
    }
    int v15 = v13;
    if (v13)
    {
      if (nospc) {
        goto LABEL_14;
      }
    }
    else
    {
      int v15 = &v9[strlen(v9)];
      if (nospc)
      {
        do
        {
LABEL_14:
          uint64_t v16 = *(v15 - 1);
          if (*(v15 - 1) < 0) {
            int v17 = __maskrune(v16, 0x4000uLL);
          }
          else {
            int v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x4000;
          }
          --v15;
        }
        while (v17);
        goto LABEL_22;
      }
    }
    LODWORD(v15) = v15 - 1;
LABEL_22:
    uint64_t v19 = (v15 - v9 + 1);
    unint64_t v18 = v9;
    goto LABEL_23;
  }
  ERR_put_error(14, 4095, 115, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_mod.c", 568);
  return 0;
}

EVP_CIPHER_CTX *pkey_cmac_init(uint64_t a1)
{
  int result = CMAC_CTX_new();
  *(void *)(a1 + 40) = result;
  if (result)
  {
    *(_DWORD *)(a1 + 72) = 0;
    return (EVP_CIPHER_CTX *)1;
  }
  return result;
}

EVP_CIPHER_CTX *pkey_cmac_copy(uint64_t a1, uint64_t a2)
{
  int result = CMAC_CTX_new();
  *(void *)(a1 + 40) = result;
  if (result)
  {
    *(_DWORD *)(a1 + 72) = 0;
    return (EVP_CIPHER_CTX *)(CMAC_CTX_copy(result, *(EVP_CIPHER_CTX **)(a2 + 40)) != 0);
  }
  return result;
}

EVP_CIPHER_CTX *pkey_cmac_cleanup(uint64_t a1)
{
  return CMAC_CTX_free(*(EVP_CIPHER_CTX **)(a1 + 40));
}

EVP_CIPHER_CTX *pkey_cmac_keygen(uint64_t a1, EVP_PKEY *a2)
{
  int result = CMAC_CTX_new();
  if (result)
  {
    unsigned int v5 = (char *)result;
    if (CMAC_CTX_copy(result, *(EVP_CIPHER_CTX **)(a1 + 40)))
    {
      EVP_PKEY_assign(a2, 894, v5);
      return (EVP_CIPHER_CTX *)1;
    }
    else
    {
      CMAC_CTX_free((EVP_CIPHER_CTX *)v5);
      return 0;
    }
  }
  return result;
}

uint64_t cmac_signctx_init(int a1, EVP_MD_CTX *ctx)
{
  ctx[1].engine = (ENGINE *)int_update;
  return 1;
}

uint64_t cmac_signctx(uint64_t a1, unsigned char *a2, size_t *a3)
{
  return CMAC_Final(*(EVP_CIPHER_CTX **)(a1 + 40), a2, a3);
}

uint64_t pkey_cmac_ctrl(uint64_t a1, int a2, uint64_t a3, EVP_CIPHER *a4)
{
  uint64_t v4 = *(EVP_CIPHER_CTX **)(a1 + 40);
  switch(a2)
  {
    case 1:
      uint64_t v8 = *(void *)(a1 + 16);
      if (!v8 || (uint64_t result = CMAC_CTX_copy(*(EVP_CIPHER_CTX **)(a1 + 40), *(EVP_CIPHER_CTX **)(v8 + 32)), result))
      {
        int v6 = v4;
        uint64_t v7 = 0;
        a3 = 0;
        goto LABEL_10;
      }
      break;
    case 12:
      int v9 = *(ENGINE **)(a1 + 8);
      int v6 = *(EVP_CIPHER_CTX **)(a1 + 40);
      uint64_t v7 = 0;
      a3 = 0;
LABEL_12:
      uint64_t result = (uint64_t)CMAC_Init(v6, v7, a3, a4, v9);
      if (result) {
        return 1;
      }
      return result;
    case 6:
      uint64_t result = 0;
      if ((a3 & 0x80000000) == 0 && a4)
      {
        a3 = a3;
        int v6 = v4;
        uint64_t v7 = (const unsigned __int8 *)a4;
LABEL_10:
        a4 = 0;
        int v9 = 0;
        goto LABEL_12;
      }
      break;
    default:
      return 4294967294;
  }
  return result;
}

uint64_t pkey_cmac_ctrl_str(uint64_t a1, char *__s1, char *a3)
{
  if (!a3) {
    return 0;
  }
  if (!strcmp(__s1, "key"))
  {
    unsigned int v7 = strlen(a3);
    if ((v7 & 0x80000000) != 0) {
      return 0;
    }
    uint64_t v8 = v7;
    int v9 = *(EVP_CIPHER_CTX **)(a1 + 40);
    uint64_t v10 = (const unsigned __int8 *)a3;
    unsigned int v11 = 0;
    unsigned int v12 = 0;
    return CMAC_Init(v9, v10, v8, v11, v12) != 0;
  }
  if (!strcmp(__s1, "cipher"))
  {
    cipherbyname = EVP_get_cipherbyname(a3);
    if (!cipherbyname) {
      return 0;
    }
    unsigned int v11 = (EVP_CIPHER *)cipherbyname;
    int v9 = *(EVP_CIPHER_CTX **)(a1 + 40);
    unsigned int v12 = *(ENGINE **)(a1 + 8);
    uint64_t v10 = 0;
    uint64_t v8 = 0;
    return CMAC_Init(v9, v10, v8, v11, v12) != 0;
  }
  if (strcmp(__s1, "hexkey")) {
    return 4294967294;
  }
  leint n = 0;
  int v14 = string_to_hex(a3, &len);
  if (!v14) {
    return 0;
  }
  int v15 = v14;
  BOOL v6 = (len & 0x80000000) == 0
    && CMAC_Init(*(EVP_CIPHER_CTX **)(a1 + 40), v14, len, 0, 0) != 0;
  free(v15);
  return v6;
}

BOOL int_update(uint64_t a1, char *a2, size_t a3)
{
  return CMAC_Update(*(void *)(*(void *)(a1 + 32) + 40), a2, a3) != 0;
}

const ECDH_METHOD *ECDH_OpenSSL(void)
{
  return (const ECDH_METHOD *)&openssl_ecdh_meth;
}

void *ossl_ecdh_compute_key(uint64_t a1, uint64_t a2, uint64_t a3, EC_KEY *a4, uint64_t a5)
{
  uint64_t result = ecdh_check(a4);
  if (result)
  {
    unsigned int v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, EC_KEY *, uint64_t))(result[3] + 8);
    return (void *)v11(a1, a2, a3, a4, a5);
  }
  return result;
}

int ECDH_compute_key(void *out, size_t outlen, const EC_POINT *pub_key, EC_KEY *ecdh, void *(__cdecl *KDF)(const void *, size_t, void *, size_t *))
{
  unsigned int v5 = *(uint64_t (**)(void *, size_t, const EC_POINT *))(*(void *)ecdh + 72);
  if (v5)
  {
    return v5(out, outlen, pub_key);
  }
  else
  {
    ERR_put_error(16, 4095, 126, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdh/ech_key.c", 227);
    return 0;
  }
}

uint64_t ecdh_compute_key(char *a1, size_t a2, const EC_POINT *a3, const EC_KEY *a4, uint64_t (*a5)(char *, unint64_t, char *, size_t *))
{
  size_t v34 = a2;
  if (!(a2 >> 31))
  {
    size_t v5 = a2;
    uint64_t v10 = BN_CTX_new();
    unsigned int v11 = v10;
    if (!v10)
    {
      EC_POINT_free(0);
      uint64_t v24 = 0;
      size_t v5 = 0xFFFFFFFFLL;
LABEL_23:
      BN_CTX_free(v11);
      free(v24);
      return v5;
    }
    BN_CTX_start(v10);
    unsigned int v12 = BN_CTX_get(v11);
    if (!v12) {
      goto LABEL_21;
    }
    int v13 = v12;
    unsigned int v12 = BN_CTX_get(v11);
    if (!v12) {
      goto LABEL_21;
    }
    uint64_t v14 = (uint64_t)v12;
    int v15 = EC_KEY_get0_private_key(a4);
    if (v15)
    {
      uint64_t v16 = v15;
      int v17 = EC_KEY_get0_group(a4);
      if (!EC_POINT_is_on_curve(v17, a3, v11))
      {
LABEL_20:
        unsigned int v12 = 0;
LABEL_21:
        uint64_t v24 = 0;
        size_t v5 = 0xFFFFFFFFLL;
        goto LABEL_22;
      }
      unint64_t v18 = EC_POINT_new(v17);
      if (v18)
      {
        uint64_t v33 = (BIGNUM *)v18;
        if (EC_POINT_mul(v17, v18, 0, a3, v16, v11))
        {
          if (EC_POINT_get_affine_coordinates((uint64_t)v17, v33, (uint64_t)v13, v14, v11))
          {
            signed int v19 = ECDH_size(a4);
            int v20 = BN_num_bits(v13);
            if (v20 >= -7) {
              int v21 = v20 + 7;
            }
            else {
              int v21 = v20 + 14;
            }
            if (v21 >> 3 <= v19)
            {
              unint64_t v28 = v19;
              if (a5 || v5 >= v19)
              {
                uint64_t v29 = (char *)malloc_type_malloc(v19, 0xCB43A3A3uLL);
                uint64_t v24 = v29;
                if (v29)
                {
                  uint64_t v30 = (uint64_t)v21 >> 3;
                  bzero(v29, v28 - v30);
                  if (v30 == BN_bn2bin(v13, (unsigned __int8 *)&v24[v28 - v30]))
                  {
                    if (!a5)
                    {
                      if (v5 > v28)
                      {
                        bzero(&a1[v28], v5 - v28);
                        size_t v34 = v28;
                        size_t v5 = v28;
                      }
                      memcpy(a1, v24, v5);
                      goto LABEL_32;
                    }
                    if (a5(v24, v28, a1, &v34))
                    {
                      size_t v5 = v34;
                      goto LABEL_32;
                    }
                    int v31 = 102;
                    int v32 = 173;
                  }
                  else
                  {
                    int v31 = 3;
                    int v32 = 167;
                  }
                }
                else
                {
                  int v31 = 65;
                  int v32 = 161;
                }
                ERR_put_error(43, 4095, v31, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdh/ech_key.c", v32);
LABEL_31:
                size_t v5 = 0xFFFFFFFFLL;
LABEL_32:
                unsigned int v12 = v33;
                goto LABEL_22;
              }
              int v22 = 104;
              int v23 = 157;
            }
            else
            {
              int v22 = 68;
              int v23 = 152;
            }
          }
          else
          {
            int v22 = 101;
            int v23 = 145;
          }
          ERR_put_error(43, 4095, v22, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdh/ech_key.c", v23);
          uint64_t v24 = 0;
          goto LABEL_31;
        }
        ERR_put_error(43, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdh/ech_key.c", 140);
        uint64_t v24 = 0;
        size_t v5 = 0xFFFFFFFFLL;
        unsigned int v12 = v33;
LABEL_22:
        EC_POINT_free((EC_POINT *)v12);
        BN_CTX_end(v11);
        goto LABEL_23;
      }
      int v25 = 65;
      int v26 = 135;
    }
    else
    {
      int v25 = 100;
      int v26 = 125;
    }
    ERR_put_error(43, 4095, v25, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdh/ech_key.c", v26);
    goto LABEL_20;
  }
  ERR_put_error(43, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdh/ech_key.c", 111);
  return 0xFFFFFFFFLL;
}

void DES_encrypt1(unsigned int *data, DES_key_schedule *ks, int enc)
{
  unsigned int v3 = data[1];
  unsigned int v4 = (*data ^ (v3 >> 4)) & 0xF0F0F0F;
  unsigned int v5 = v4 ^ *data;
  int v6 = v3 ^ (16 * v4);
  int v7 = (unsigned __int16)v6 ^ HIWORD(v5);
  unsigned int v8 = v7 ^ v6;
  int v9 = v5 ^ (v7 << 16);
  int v10 = (v9 ^ (v8 >> 2)) & 0x33333333;
  unsigned int v11 = v10 ^ v9;
  int v12 = v8 ^ (4 * v10);
  int v13 = (v12 ^ (v11 >> 8)) & 0xFF00FF;
  unsigned int v14 = v13 ^ v12;
  int v15 = v11 ^ (v13 << 8);
  int v16 = (v15 ^ (v14 >> 1)) & 0x55555555;
  HIDWORD(v18) = v16 ^ v15;
  LODWORD(v18) = v16 ^ v15;
  int v17 = v18 >> 29;
  HIDWORD(v18) = v14 ^ (2 * v16);
  LODWORD(v18) = HIDWORD(v18);
  int v19 = v18 >> 29;
  if (enc)
  {
    unsigned int v20 = ks->ks[0].deslong[0] ^ v17;
    HIDWORD(v22) = ks->ks[0].deslong[1] ^ v17;
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v21 = v22 >> 4;
    int v23 = DES_SPtrans[v20 >> 2] ^ DES_SPtrans[((unsigned __int16)v20 >> 10) + 128] ^ DES_SPtrans[((v20 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v20 >> 26) + 384] ^ DES_SPtrans[(v21 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v21 >> 10) + 192] ^ DES_SPtrans[((v21 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v21 >> 26) + 448] ^ v19;
    unsigned int v24 = v23 ^ ks->ks[1].deslong[0];
    HIDWORD(v22) = v23 ^ ks->ks[1].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v25 = v22 >> 4;
    int v26 = DES_SPtrans[v24 >> 2] ^ DES_SPtrans[((unsigned __int16)v24 >> 10) + 128] ^ DES_SPtrans[((v24 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v24 >> 26) + 384] ^ DES_SPtrans[(v25 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v25 >> 10) + 192] ^ DES_SPtrans[((v25 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v25 >> 26) + 448] ^ v17;
    unsigned int v27 = v26 ^ ks->ks[2].deslong[0];
    HIDWORD(v22) = v26 ^ ks->ks[2].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v28 = v22 >> 4;
    int v29 = DES_SPtrans[v27 >> 2] ^ DES_SPtrans[((unsigned __int16)v27 >> 10) + 128] ^ DES_SPtrans[((v27 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v27 >> 26) + 384] ^ DES_SPtrans[(v28 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v28 >> 10) + 192] ^ DES_SPtrans[((v28 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v28 >> 26) + 448] ^ v23;
    unsigned int v30 = v29 ^ ks->ks[3].deslong[0];
    HIDWORD(v22) = v29 ^ ks->ks[3].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v31 = v22 >> 4;
    int v32 = DES_SPtrans[v30 >> 2] ^ DES_SPtrans[((unsigned __int16)v30 >> 10) + 128] ^ DES_SPtrans[((v30 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v30 >> 26) + 384] ^ DES_SPtrans[(v31 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v31 >> 10) + 192] ^ DES_SPtrans[((v31 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v31 >> 26) + 448] ^ v26;
    unsigned int v33 = v32 ^ ks->ks[4].deslong[0];
    HIDWORD(v22) = v32 ^ ks->ks[4].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v34 = v22 >> 4;
    int v35 = DES_SPtrans[v33 >> 2] ^ DES_SPtrans[((unsigned __int16)v33 >> 10) + 128] ^ DES_SPtrans[((v33 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v33 >> 26) + 384] ^ DES_SPtrans[(v34 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v34 >> 10) + 192] ^ DES_SPtrans[((v34 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v34 >> 26) + 448] ^ v29;
    unsigned int v36 = v35 ^ ks->ks[5].deslong[0];
    HIDWORD(v22) = v35 ^ ks->ks[5].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v37 = v22 >> 4;
    int v38 = DES_SPtrans[v36 >> 2] ^ DES_SPtrans[((unsigned __int16)v36 >> 10) + 128] ^ DES_SPtrans[((v36 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v36 >> 26) + 384] ^ DES_SPtrans[(v37 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v37 >> 10) + 192] ^ DES_SPtrans[((v37 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v37 >> 26) + 448] ^ v32;
    unsigned int v39 = v38 ^ ks->ks[6].deslong[0];
    HIDWORD(v22) = v38 ^ ks->ks[6].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v40 = v22 >> 4;
    int v41 = DES_SPtrans[v39 >> 2] ^ DES_SPtrans[((unsigned __int16)v39 >> 10) + 128] ^ DES_SPtrans[((v39 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v39 >> 26) + 384] ^ DES_SPtrans[(v40 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v40 >> 10) + 192] ^ DES_SPtrans[((v40 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v40 >> 26) + 448] ^ v35;
    unsigned int v42 = v41 ^ ks->ks[7].deslong[0];
    HIDWORD(v22) = v41 ^ ks->ks[7].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v43 = v22 >> 4;
    int v44 = DES_SPtrans[v42 >> 2] ^ DES_SPtrans[((unsigned __int16)v42 >> 10) + 128] ^ DES_SPtrans[((v42 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v42 >> 26) + 384] ^ DES_SPtrans[(v43 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v43 >> 10) + 192] ^ DES_SPtrans[((v43 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v43 >> 26) + 448] ^ v38;
    unsigned int v45 = v44 ^ ks->ks[8].deslong[0];
    HIDWORD(v22) = v44 ^ ks->ks[8].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v46 = v22 >> 4;
    int v47 = DES_SPtrans[v45 >> 2] ^ DES_SPtrans[((unsigned __int16)v45 >> 10) + 128] ^ DES_SPtrans[((v45 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v45 >> 26) + 384] ^ DES_SPtrans[(v46 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v46 >> 10) + 192] ^ DES_SPtrans[((v46 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v46 >> 26) + 448] ^ v41;
    unsigned int v48 = v47 ^ ks->ks[9].deslong[0];
    HIDWORD(v22) = v47 ^ ks->ks[9].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v49 = v22 >> 4;
    int v50 = DES_SPtrans[v48 >> 2] ^ DES_SPtrans[((unsigned __int16)v48 >> 10) + 128] ^ DES_SPtrans[((v48 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v48 >> 26) + 384] ^ DES_SPtrans[(v49 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v49 >> 10) + 192] ^ DES_SPtrans[((v49 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v49 >> 26) + 448] ^ v44;
    unsigned int v51 = v50 ^ ks->ks[10].deslong[0];
    HIDWORD(v22) = v50 ^ ks->ks[10].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v52 = v22 >> 4;
    int v53 = DES_SPtrans[v51 >> 2] ^ DES_SPtrans[((unsigned __int16)v51 >> 10) + 128] ^ DES_SPtrans[((v51 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v51 >> 26) + 384] ^ DES_SPtrans[(v52 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v52 >> 10) + 192] ^ DES_SPtrans[((v52 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v52 >> 26) + 448] ^ v47;
    unsigned int v54 = v53 ^ ks->ks[11].deslong[0];
    HIDWORD(v22) = v53 ^ ks->ks[11].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v55 = v22 >> 4;
    int v56 = DES_SPtrans[v54 >> 2] ^ DES_SPtrans[((unsigned __int16)v54 >> 10) + 128] ^ DES_SPtrans[((v54 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v54 >> 26) + 384] ^ DES_SPtrans[(v55 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v55 >> 10) + 192] ^ DES_SPtrans[((v55 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v55 >> 26) + 448] ^ v50;
    unsigned int v57 = v56 ^ ks->ks[12].deslong[0];
    HIDWORD(v22) = v56 ^ ks->ks[12].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v58 = v22 >> 4;
    int v59 = DES_SPtrans[v57 >> 2] ^ DES_SPtrans[((unsigned __int16)v57 >> 10) + 128] ^ DES_SPtrans[((v57 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v57 >> 26) + 384] ^ DES_SPtrans[(v58 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v58 >> 10) + 192] ^ DES_SPtrans[((v58 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v58 >> 26) + 448] ^ v53;
    unsigned int v60 = v59 ^ ks->ks[13].deslong[0];
    HIDWORD(v22) = v59 ^ ks->ks[13].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    unsigned int v61 = v22 >> 4;
    int v62 = DES_SPtrans[v60 >> 2] ^ DES_SPtrans[((unsigned __int16)v60 >> 10) + 128] ^ DES_SPtrans[((v60 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v60 >> 26) + 384] ^ DES_SPtrans[(v61 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v61 >> 10) + 192] ^ DES_SPtrans[((v61 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v61 >> 26) + 448] ^ v56;
    unsigned int v63 = v62 ^ ks->ks[14].deslong[0];
    HIDWORD(v22) = v62 ^ ks->ks[14].deslong[1];
    LODWORD(v22) = HIDWORD(v22);
    int v64 = DES_SPtrans[v63 >> 2] ^ DES_SPtrans[((unsigned __int16)v63 >> 10) + 128] ^ DES_SPtrans[((v63 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v63 >> 26) + 384] ^ DES_SPtrans[((v22 >> 4) >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)(v22 >> 4) >> 10) + 192] ^ DES_SPtrans[(((v22 >> 4) >> 18) & 0x3F) + 320] ^ DES_SPtrans[((v22 >> 4) >> 26) + 448] ^ v59;
    unsigned int v65 = ks->ks[15].deslong[0];
    unsigned int v66 = ks->ks[15].deslong[1];
  }
  else
  {
    unsigned int v67 = ks->ks[15].deslong[0] ^ v17;
    HIDWORD(v69) = ks->ks[15].deslong[1] ^ v17;
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v68 = v69 >> 4;
    int v70 = DES_SPtrans[v67 >> 2] ^ DES_SPtrans[((unsigned __int16)v67 >> 10) + 128] ^ DES_SPtrans[((v67 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v67 >> 26) + 384] ^ DES_SPtrans[(v68 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v68 >> 10) + 192] ^ DES_SPtrans[((v68 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v68 >> 26) + 448] ^ v19;
    unsigned int v71 = v70 ^ ks->ks[14].deslong[0];
    HIDWORD(v69) = v70 ^ ks->ks[14].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v72 = v69 >> 4;
    int v73 = DES_SPtrans[v71 >> 2] ^ DES_SPtrans[((unsigned __int16)v71 >> 10) + 128] ^ DES_SPtrans[((v71 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v71 >> 26) + 384] ^ DES_SPtrans[(v72 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v72 >> 10) + 192] ^ DES_SPtrans[((v72 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v72 >> 26) + 448] ^ v17;
    unsigned int v74 = v73 ^ ks->ks[13].deslong[0];
    HIDWORD(v69) = v73 ^ ks->ks[13].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v75 = v69 >> 4;
    int v76 = DES_SPtrans[v74 >> 2] ^ DES_SPtrans[((unsigned __int16)v74 >> 10) + 128] ^ DES_SPtrans[((v74 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v74 >> 26) + 384] ^ DES_SPtrans[(v75 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v75 >> 10) + 192] ^ DES_SPtrans[((v75 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v75 >> 26) + 448] ^ v70;
    unsigned int v77 = v76 ^ ks->ks[12].deslong[0];
    HIDWORD(v69) = v76 ^ ks->ks[12].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v78 = v69 >> 4;
    int v79 = DES_SPtrans[v77 >> 2] ^ DES_SPtrans[((unsigned __int16)v77 >> 10) + 128] ^ DES_SPtrans[((v77 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v77 >> 26) + 384] ^ DES_SPtrans[(v78 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v78 >> 10) + 192] ^ DES_SPtrans[((v78 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v78 >> 26) + 448] ^ v73;
    unsigned int v80 = v79 ^ ks->ks[11].deslong[0];
    HIDWORD(v69) = v79 ^ ks->ks[11].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v81 = v69 >> 4;
    int v82 = DES_SPtrans[v80 >> 2] ^ DES_SPtrans[((unsigned __int16)v80 >> 10) + 128] ^ DES_SPtrans[((v80 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v80 >> 26) + 384] ^ DES_SPtrans[(v81 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v81 >> 10) + 192] ^ DES_SPtrans[((v81 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v81 >> 26) + 448] ^ v76;
    unsigned int v83 = v82 ^ ks->ks[10].deslong[0];
    HIDWORD(v69) = v82 ^ ks->ks[10].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v84 = v69 >> 4;
    int v85 = DES_SPtrans[v83 >> 2] ^ DES_SPtrans[((unsigned __int16)v83 >> 10) + 128] ^ DES_SPtrans[((v83 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v83 >> 26) + 384] ^ DES_SPtrans[(v84 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v84 >> 10) + 192] ^ DES_SPtrans[((v84 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v84 >> 26) + 448] ^ v79;
    unsigned int v86 = v85 ^ ks->ks[9].deslong[0];
    HIDWORD(v69) = v85 ^ ks->ks[9].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v87 = v69 >> 4;
    int v88 = DES_SPtrans[v86 >> 2] ^ DES_SPtrans[((unsigned __int16)v86 >> 10) + 128] ^ DES_SPtrans[((v86 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v86 >> 26) + 384] ^ DES_SPtrans[(v87 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v87 >> 10) + 192] ^ DES_SPtrans[((v87 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v87 >> 26) + 448] ^ v82;
    unsigned int v89 = v88 ^ ks->ks[8].deslong[0];
    HIDWORD(v69) = v88 ^ ks->ks[8].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v90 = v69 >> 4;
    int v91 = DES_SPtrans[v89 >> 2] ^ DES_SPtrans[((unsigned __int16)v89 >> 10) + 128] ^ DES_SPtrans[((v89 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v89 >> 26) + 384] ^ DES_SPtrans[(v90 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v90 >> 10) + 192] ^ DES_SPtrans[((v90 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v90 >> 26) + 448] ^ v85;
    unsigned int v92 = v91 ^ ks->ks[7].deslong[0];
    HIDWORD(v69) = v91 ^ ks->ks[7].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v93 = v69 >> 4;
    int v94 = DES_SPtrans[v92 >> 2] ^ DES_SPtrans[((unsigned __int16)v92 >> 10) + 128] ^ DES_SPtrans[((v92 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v92 >> 26) + 384] ^ DES_SPtrans[(v93 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v93 >> 10) + 192] ^ DES_SPtrans[((v93 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v93 >> 26) + 448] ^ v88;
    unsigned int v95 = v94 ^ ks->ks[6].deslong[0];
    HIDWORD(v69) = v94 ^ ks->ks[6].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v96 = v69 >> 4;
    int v97 = DES_SPtrans[v95 >> 2] ^ DES_SPtrans[((unsigned __int16)v95 >> 10) + 128] ^ DES_SPtrans[((v95 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v95 >> 26) + 384] ^ DES_SPtrans[(v96 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v96 >> 10) + 192] ^ DES_SPtrans[((v96 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v96 >> 26) + 448] ^ v91;
    unsigned int v98 = v97 ^ ks->ks[5].deslong[0];
    HIDWORD(v69) = v97 ^ ks->ks[5].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v99 = v69 >> 4;
    int v100 = DES_SPtrans[v98 >> 2] ^ DES_SPtrans[((unsigned __int16)v98 >> 10) + 128] ^ DES_SPtrans[((v98 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v98 >> 26) + 384] ^ DES_SPtrans[(v99 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v99 >> 10) + 192] ^ DES_SPtrans[((v99 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v99 >> 26) + 448] ^ v94;
    unsigned int v101 = v100 ^ ks->ks[4].deslong[0];
    HIDWORD(v69) = v100 ^ ks->ks[4].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v102 = v69 >> 4;
    int v103 = DES_SPtrans[v101 >> 2] ^ DES_SPtrans[((unsigned __int16)v101 >> 10) + 128] ^ DES_SPtrans[((v101 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v101 >> 26) + 384] ^ DES_SPtrans[(v102 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v102 >> 10) + 192] ^ DES_SPtrans[((v102 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v102 >> 26) + 448] ^ v97;
    unsigned int v104 = v103 ^ ks->ks[3].deslong[0];
    HIDWORD(v69) = v103 ^ ks->ks[3].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v105 = v69 >> 4;
    int v106 = DES_SPtrans[v104 >> 2] ^ DES_SPtrans[((unsigned __int16)v104 >> 10) + 128] ^ DES_SPtrans[((v104 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v104 >> 26) + 384] ^ DES_SPtrans[(v105 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v105 >> 10) + 192] ^ DES_SPtrans[((v105 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v105 >> 26) + 448] ^ v100;
    unsigned int v107 = v106 ^ ks->ks[2].deslong[0];
    HIDWORD(v69) = v106 ^ ks->ks[2].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    unsigned int v108 = v69 >> 4;
    int v62 = DES_SPtrans[v107 >> 2] ^ DES_SPtrans[((unsigned __int16)v107 >> 10) + 128] ^ DES_SPtrans[((v107 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v107 >> 26) + 384] ^ DES_SPtrans[(v108 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v108 >> 10) + 192] ^ DES_SPtrans[((v108 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v108 >> 26) + 448] ^ v103;
    unsigned int v109 = v62 ^ ks->ks[1].deslong[0];
    HIDWORD(v69) = v62 ^ ks->ks[1].deslong[1];
    LODWORD(v69) = HIDWORD(v69);
    int v64 = DES_SPtrans[v109 >> 2] ^ DES_SPtrans[((unsigned __int16)v109 >> 10) + 128] ^ DES_SPtrans[((v109 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v109 >> 26) + 384] ^ DES_SPtrans[((v69 >> 4) >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)(v69 >> 4) >> 10) + 192] ^ DES_SPtrans[(((v69 >> 4) >> 18) & 0x3F) + 320] ^ DES_SPtrans[((v69 >> 4) >> 26) + 448] ^ v106;
    unsigned int v65 = ks->ks[0].deslong[0];
    unsigned int v66 = ks->ks[0].deslong[1];
  }
  unsigned int v110 = v64 ^ v65;
  HIDWORD(v112) = v64 ^ v66;
  LODWORD(v112) = v64 ^ v66;
  unsigned int v111 = v112 >> 4;
  HIDWORD(v112) = DES_SPtrans[v110 >> 2] ^ DES_SPtrans[((unsigned __int16)v110 >> 10) + 128] ^ DES_SPtrans[((v110 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v110 >> 26) + 384] ^ DES_SPtrans[(v111 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v111 >> 10) + 192] ^ DES_SPtrans[((v111 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v111 >> 26) + 448] ^ v62;
  LODWORD(v112) = HIDWORD(v112);
  unsigned int v113 = (((v112 >> 3) >> 1) ^ __ROR4__(v64, 3)) & 0x55555555;
  unsigned int v114 = v113 ^ __ROR4__(v64, 3);
  int v115 = (2 * v113) ^ __ROR4__(HIDWORD(v112), 3);
  int v116 = (v115 ^ (v114 >> 8)) & 0xFF00FF;
  unsigned int v117 = v116 ^ v115;
  int v118 = v114 ^ (v116 << 8);
  int v119 = (v118 ^ (v117 >> 2)) & 0x33333333;
  unsigned int v120 = v119 ^ v118;
  int v121 = v117 ^ (4 * v119);
  int v122 = (unsigned __int16)v121 ^ HIWORD(v120);
  unsigned int v123 = v122 ^ v121;
  int v124 = v120 ^ (v122 << 16);
  int v125 = (v124 ^ (v123 >> 4)) & 0xF0F0F0F;
  *int data = v125 ^ v124;
  data[1] = v123 ^ (16 * v125);
}

void DES_encrypt2(unsigned int *data, DES_key_schedule *ks, int enc)
{
  HIDWORD(v4) = *data;
  LODWORD(v4) = *data;
  int v3 = v4 >> 29;
  HIDWORD(v4) = data[1];
  LODWORD(v4) = HIDWORD(v4);
  int v5 = v4 >> 29;
  if (enc)
  {
    unsigned int v6 = ks->ks[0].deslong[0] ^ v3;
    HIDWORD(v8) = ks->ks[0].deslong[1] ^ v3;
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v7 = v8 >> 4;
    int v9 = DES_SPtrans[v6 >> 2] ^ DES_SPtrans[((unsigned __int16)v6 >> 10) + 128] ^ DES_SPtrans[((v6 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v6 >> 26) + 384] ^ DES_SPtrans[(v7 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v7 >> 10) + 192] ^ DES_SPtrans[((v7 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v7 >> 26) + 448] ^ v5;
    unsigned int v10 = v9 ^ ks->ks[1].deslong[0];
    HIDWORD(v8) = v9 ^ ks->ks[1].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v11 = v8 >> 4;
    int v12 = DES_SPtrans[v10 >> 2] ^ DES_SPtrans[((unsigned __int16)v10 >> 10) + 128] ^ DES_SPtrans[((v10 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v10 >> 26) + 384] ^ DES_SPtrans[(v11 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v11 >> 10) + 192] ^ DES_SPtrans[((v11 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v11 >> 26) + 448] ^ v3;
    unsigned int v13 = v12 ^ ks->ks[2].deslong[0];
    HIDWORD(v8) = v12 ^ ks->ks[2].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v14 = v8 >> 4;
    int v15 = DES_SPtrans[v13 >> 2] ^ DES_SPtrans[((unsigned __int16)v13 >> 10) + 128] ^ DES_SPtrans[((v13 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v13 >> 26) + 384] ^ DES_SPtrans[(v14 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v14 >> 10) + 192] ^ DES_SPtrans[((v14 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v14 >> 26) + 448] ^ v9;
    unsigned int v16 = v15 ^ ks->ks[3].deslong[0];
    HIDWORD(v8) = v15 ^ ks->ks[3].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v17 = v8 >> 4;
    int v18 = DES_SPtrans[v16 >> 2] ^ DES_SPtrans[((unsigned __int16)v16 >> 10) + 128] ^ DES_SPtrans[((v16 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v16 >> 26) + 384] ^ DES_SPtrans[(v17 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v17 >> 10) + 192] ^ DES_SPtrans[((v17 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v17 >> 26) + 448] ^ v12;
    unsigned int v19 = v18 ^ ks->ks[4].deslong[0];
    HIDWORD(v8) = v18 ^ ks->ks[4].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v20 = v8 >> 4;
    int v21 = DES_SPtrans[v19 >> 2] ^ DES_SPtrans[((unsigned __int16)v19 >> 10) + 128] ^ DES_SPtrans[((v19 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v19 >> 26) + 384] ^ DES_SPtrans[(v20 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v20 >> 10) + 192] ^ DES_SPtrans[((v20 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v20 >> 26) + 448] ^ v15;
    unsigned int v22 = v21 ^ ks->ks[5].deslong[0];
    HIDWORD(v8) = v21 ^ ks->ks[5].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v23 = v8 >> 4;
    int v24 = DES_SPtrans[v22 >> 2] ^ DES_SPtrans[((unsigned __int16)v22 >> 10) + 128] ^ DES_SPtrans[((v22 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v22 >> 26) + 384] ^ DES_SPtrans[(v23 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v23 >> 10) + 192] ^ DES_SPtrans[((v23 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v23 >> 26) + 448] ^ v18;
    unsigned int v25 = v24 ^ ks->ks[6].deslong[0];
    HIDWORD(v8) = v24 ^ ks->ks[6].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v26 = v8 >> 4;
    int v27 = DES_SPtrans[v25 >> 2] ^ DES_SPtrans[((unsigned __int16)v25 >> 10) + 128] ^ DES_SPtrans[((v25 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v25 >> 26) + 384] ^ DES_SPtrans[(v26 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v26 >> 10) + 192] ^ DES_SPtrans[((v26 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v26 >> 26) + 448] ^ v21;
    unsigned int v28 = v27 ^ ks->ks[7].deslong[0];
    HIDWORD(v8) = v27 ^ ks->ks[7].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v29 = v8 >> 4;
    int v30 = DES_SPtrans[v28 >> 2] ^ DES_SPtrans[((unsigned __int16)v28 >> 10) + 128] ^ DES_SPtrans[((v28 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v28 >> 26) + 384] ^ DES_SPtrans[(v29 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v29 >> 10) + 192] ^ DES_SPtrans[((v29 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v29 >> 26) + 448] ^ v24;
    unsigned int v31 = v30 ^ ks->ks[8].deslong[0];
    HIDWORD(v8) = v30 ^ ks->ks[8].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v32 = v8 >> 4;
    int v33 = DES_SPtrans[v31 >> 2] ^ DES_SPtrans[((unsigned __int16)v31 >> 10) + 128] ^ DES_SPtrans[((v31 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v31 >> 26) + 384] ^ DES_SPtrans[(v32 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v32 >> 10) + 192] ^ DES_SPtrans[((v32 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v32 >> 26) + 448] ^ v27;
    unsigned int v34 = v33 ^ ks->ks[9].deslong[0];
    HIDWORD(v8) = v33 ^ ks->ks[9].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v35 = v8 >> 4;
    int v36 = DES_SPtrans[v34 >> 2] ^ DES_SPtrans[((unsigned __int16)v34 >> 10) + 128] ^ DES_SPtrans[((v34 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v34 >> 26) + 384] ^ DES_SPtrans[(v35 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v35 >> 10) + 192] ^ DES_SPtrans[((v35 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v35 >> 26) + 448] ^ v30;
    unsigned int v37 = v36 ^ ks->ks[10].deslong[0];
    HIDWORD(v8) = v36 ^ ks->ks[10].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v38 = v8 >> 4;
    int v39 = DES_SPtrans[v37 >> 2] ^ DES_SPtrans[((unsigned __int16)v37 >> 10) + 128] ^ DES_SPtrans[((v37 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v37 >> 26) + 384] ^ DES_SPtrans[(v38 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v38 >> 10) + 192] ^ DES_SPtrans[((v38 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v38 >> 26) + 448] ^ v33;
    unsigned int v40 = v39 ^ ks->ks[11].deslong[0];
    HIDWORD(v8) = v39 ^ ks->ks[11].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v41 = v8 >> 4;
    int v42 = DES_SPtrans[v40 >> 2] ^ DES_SPtrans[((unsigned __int16)v40 >> 10) + 128] ^ DES_SPtrans[((v40 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v40 >> 26) + 384] ^ DES_SPtrans[(v41 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v41 >> 10) + 192] ^ DES_SPtrans[((v41 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v41 >> 26) + 448] ^ v36;
    unsigned int v43 = v42 ^ ks->ks[12].deslong[0];
    HIDWORD(v8) = v42 ^ ks->ks[12].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v44 = v8 >> 4;
    int v45 = DES_SPtrans[v43 >> 2] ^ DES_SPtrans[((unsigned __int16)v43 >> 10) + 128] ^ DES_SPtrans[((v43 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v43 >> 26) + 384] ^ DES_SPtrans[(v44 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v44 >> 10) + 192] ^ DES_SPtrans[((v44 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v44 >> 26) + 448] ^ v39;
    unsigned int v46 = v45 ^ ks->ks[13].deslong[0];
    HIDWORD(v8) = v45 ^ ks->ks[13].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    unsigned int v47 = v8 >> 4;
    int v48 = DES_SPtrans[v46 >> 2] ^ DES_SPtrans[((unsigned __int16)v46 >> 10) + 128] ^ DES_SPtrans[((v46 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v46 >> 26) + 384] ^ DES_SPtrans[(v47 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v47 >> 10) + 192] ^ DES_SPtrans[((v47 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v47 >> 26) + 448] ^ v42;
    unsigned int v49 = v48 ^ ks->ks[14].deslong[0];
    HIDWORD(v8) = v48 ^ ks->ks[14].deslong[1];
    LODWORD(v8) = HIDWORD(v8);
    int v50 = DES_SPtrans[v49 >> 2] ^ DES_SPtrans[((unsigned __int16)v49 >> 10) + 128] ^ DES_SPtrans[((v49 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v49 >> 26) + 384] ^ DES_SPtrans[((v8 >> 4) >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)(v8 >> 4) >> 10) + 192] ^ DES_SPtrans[(((v8 >> 4) >> 18) & 0x3F) + 320] ^ DES_SPtrans[((v8 >> 4) >> 26) + 448] ^ v45;
    unsigned int v51 = ks->ks[15].deslong[0];
    unsigned int v52 = ks->ks[15].deslong[1];
  }
  else
  {
    unsigned int v53 = ks->ks[15].deslong[0] ^ v3;
    HIDWORD(v55) = ks->ks[15].deslong[1] ^ v3;
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v54 = v55 >> 4;
    int v56 = DES_SPtrans[v53 >> 2] ^ DES_SPtrans[((unsigned __int16)v53 >> 10) + 128] ^ DES_SPtrans[((v53 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v53 >> 26) + 384] ^ DES_SPtrans[(v54 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v54 >> 10) + 192] ^ DES_SPtrans[((v54 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v54 >> 26) + 448] ^ v5;
    unsigned int v57 = v56 ^ ks->ks[14].deslong[0];
    HIDWORD(v55) = v56 ^ ks->ks[14].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v58 = v55 >> 4;
    int v59 = DES_SPtrans[v57 >> 2] ^ DES_SPtrans[((unsigned __int16)v57 >> 10) + 128] ^ DES_SPtrans[((v57 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v57 >> 26) + 384] ^ DES_SPtrans[(v58 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v58 >> 10) + 192] ^ DES_SPtrans[((v58 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v58 >> 26) + 448] ^ v3;
    unsigned int v60 = v59 ^ ks->ks[13].deslong[0];
    HIDWORD(v55) = v59 ^ ks->ks[13].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v61 = v55 >> 4;
    int v62 = DES_SPtrans[v60 >> 2] ^ DES_SPtrans[((unsigned __int16)v60 >> 10) + 128] ^ DES_SPtrans[((v60 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v60 >> 26) + 384] ^ DES_SPtrans[(v61 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v61 >> 10) + 192] ^ DES_SPtrans[((v61 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v61 >> 26) + 448] ^ v56;
    unsigned int v63 = v62 ^ ks->ks[12].deslong[0];
    HIDWORD(v55) = v62 ^ ks->ks[12].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v64 = v55 >> 4;
    int v65 = DES_SPtrans[v63 >> 2] ^ DES_SPtrans[((unsigned __int16)v63 >> 10) + 128] ^ DES_SPtrans[((v63 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v63 >> 26) + 384] ^ DES_SPtrans[(v64 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v64 >> 10) + 192] ^ DES_SPtrans[((v64 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v64 >> 26) + 448] ^ v59;
    unsigned int v66 = v65 ^ ks->ks[11].deslong[0];
    HIDWORD(v55) = v65 ^ ks->ks[11].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v67 = v55 >> 4;
    int v68 = DES_SPtrans[v66 >> 2] ^ DES_SPtrans[((unsigned __int16)v66 >> 10) + 128] ^ DES_SPtrans[((v66 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v66 >> 26) + 384] ^ DES_SPtrans[(v67 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v67 >> 10) + 192] ^ DES_SPtrans[((v67 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v67 >> 26) + 448] ^ v62;
    unsigned int v69 = v68 ^ ks->ks[10].deslong[0];
    HIDWORD(v55) = v68 ^ ks->ks[10].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v70 = v55 >> 4;
    int v71 = DES_SPtrans[v69 >> 2] ^ DES_SPtrans[((unsigned __int16)v69 >> 10) + 128] ^ DES_SPtrans[((v69 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v69 >> 26) + 384] ^ DES_SPtrans[(v70 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v70 >> 10) + 192] ^ DES_SPtrans[((v70 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v70 >> 26) + 448] ^ v65;
    unsigned int v72 = v71 ^ ks->ks[9].deslong[0];
    HIDWORD(v55) = v71 ^ ks->ks[9].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v73 = v55 >> 4;
    int v74 = DES_SPtrans[v72 >> 2] ^ DES_SPtrans[((unsigned __int16)v72 >> 10) + 128] ^ DES_SPtrans[((v72 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v72 >> 26) + 384] ^ DES_SPtrans[(v73 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v73 >> 10) + 192] ^ DES_SPtrans[((v73 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v73 >> 26) + 448] ^ v68;
    unsigned int v75 = v74 ^ ks->ks[8].deslong[0];
    HIDWORD(v55) = v74 ^ ks->ks[8].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v76 = v55 >> 4;
    int v77 = DES_SPtrans[v75 >> 2] ^ DES_SPtrans[((unsigned __int16)v75 >> 10) + 128] ^ DES_SPtrans[((v75 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v75 >> 26) + 384] ^ DES_SPtrans[(v76 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v76 >> 10) + 192] ^ DES_SPtrans[((v76 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v76 >> 26) + 448] ^ v71;
    unsigned int v78 = v77 ^ ks->ks[7].deslong[0];
    HIDWORD(v55) = v77 ^ ks->ks[7].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v79 = v55 >> 4;
    int v80 = DES_SPtrans[v78 >> 2] ^ DES_SPtrans[((unsigned __int16)v78 >> 10) + 128] ^ DES_SPtrans[((v78 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v78 >> 26) + 384] ^ DES_SPtrans[(v79 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v79 >> 10) + 192] ^ DES_SPtrans[((v79 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v79 >> 26) + 448] ^ v74;
    unsigned int v81 = v80 ^ ks->ks[6].deslong[0];
    HIDWORD(v55) = v80 ^ ks->ks[6].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v82 = v55 >> 4;
    int v83 = DES_SPtrans[v81 >> 2] ^ DES_SPtrans[((unsigned __int16)v81 >> 10) + 128] ^ DES_SPtrans[((v81 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v81 >> 26) + 384] ^ DES_SPtrans[(v82 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v82 >> 10) + 192] ^ DES_SPtrans[((v82 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v82 >> 26) + 448] ^ v77;
    unsigned int v84 = v83 ^ ks->ks[5].deslong[0];
    HIDWORD(v55) = v83 ^ ks->ks[5].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v85 = v55 >> 4;
    int v86 = DES_SPtrans[v84 >> 2] ^ DES_SPtrans[((unsigned __int16)v84 >> 10) + 128] ^ DES_SPtrans[((v84 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v84 >> 26) + 384] ^ DES_SPtrans[(v85 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v85 >> 10) + 192] ^ DES_SPtrans[((v85 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v85 >> 26) + 448] ^ v80;
    unsigned int v87 = v86 ^ ks->ks[4].deslong[0];
    HIDWORD(v55) = v86 ^ ks->ks[4].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v88 = v55 >> 4;
    int v89 = DES_SPtrans[v87 >> 2] ^ DES_SPtrans[((unsigned __int16)v87 >> 10) + 128] ^ DES_SPtrans[((v87 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v87 >> 26) + 384] ^ DES_SPtrans[(v88 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v88 >> 10) + 192] ^ DES_SPtrans[((v88 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v88 >> 26) + 448] ^ v83;
    unsigned int v90 = v89 ^ ks->ks[3].deslong[0];
    HIDWORD(v55) = v89 ^ ks->ks[3].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v91 = v55 >> 4;
    int v92 = DES_SPtrans[v90 >> 2] ^ DES_SPtrans[((unsigned __int16)v90 >> 10) + 128] ^ DES_SPtrans[((v90 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v90 >> 26) + 384] ^ DES_SPtrans[(v91 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v91 >> 10) + 192] ^ DES_SPtrans[((v91 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v91 >> 26) + 448] ^ v86;
    unsigned int v93 = v92 ^ ks->ks[2].deslong[0];
    HIDWORD(v55) = v92 ^ ks->ks[2].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    unsigned int v94 = v55 >> 4;
    int v48 = DES_SPtrans[v93 >> 2] ^ DES_SPtrans[((unsigned __int16)v93 >> 10) + 128] ^ DES_SPtrans[((v93 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v93 >> 26) + 384] ^ DES_SPtrans[(v94 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v94 >> 10) + 192] ^ DES_SPtrans[((v94 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v94 >> 26) + 448] ^ v89;
    unsigned int v95 = v48 ^ ks->ks[1].deslong[0];
    HIDWORD(v55) = v48 ^ ks->ks[1].deslong[1];
    LODWORD(v55) = HIDWORD(v55);
    int v50 = DES_SPtrans[v95 >> 2] ^ DES_SPtrans[((unsigned __int16)v95 >> 10) + 128] ^ DES_SPtrans[((v95 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v95 >> 26) + 384] ^ DES_SPtrans[((v55 >> 4) >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)(v55 >> 4) >> 10) + 192] ^ DES_SPtrans[(((v55 >> 4) >> 18) & 0x3F) + 320] ^ DES_SPtrans[((v55 >> 4) >> 26) + 448] ^ v92;
    unsigned int v51 = ks->ks[0].deslong[0];
    unsigned int v52 = ks->ks[0].deslong[1];
  }
  unsigned int v96 = v50 ^ v51;
  HIDWORD(v98) = v50 ^ v52;
  LODWORD(v98) = v50 ^ v52;
  unsigned int v97 = v98 >> 4;
  HIDWORD(v98) = v50;
  LODWORD(v98) = v50;
  unsigned int v99 = v98 >> 3;
  HIDWORD(v98) = DES_SPtrans[v96 >> 2] ^ DES_SPtrans[((unsigned __int16)v96 >> 10) + 128] ^ DES_SPtrans[((v96 >> 18) & 0x3F) + 256] ^ DES_SPtrans[(v96 >> 26) + 384] ^ DES_SPtrans[(v97 >> 2) + 64] ^ DES_SPtrans[((unsigned __int16)v97 >> 10) + 192] ^ DES_SPtrans[((v97 >> 18) & 0x3F) + 320] ^ DES_SPtrans[(v97 >> 26) + 448] ^ v48;
  LODWORD(v98) = HIDWORD(v98);
  *int data = v99;
  data[1] = v98 >> 3;
}

void DES_encrypt3(unsigned int *data, DES_key_schedule *ks1, DES_key_schedule *ks2, DES_key_schedule *ks3)
{
  unsigned int v7 = data[1];
  unsigned int v8 = (*data ^ (v7 >> 4)) & 0xF0F0F0F;
  unsigned int v9 = v8 ^ *data;
  int v10 = v7 ^ (16 * v8);
  int v11 = (unsigned __int16)v10 ^ HIWORD(v9);
  unsigned int v12 = v11 ^ v10;
  int v13 = v9 ^ (v11 << 16);
  int v14 = (v13 ^ (v12 >> 2)) & 0x33333333;
  unsigned int v15 = v14 ^ v13;
  int v16 = v12 ^ (4 * v14);
  int v17 = (v16 ^ (v15 >> 8)) & 0xFF00FF;
  unsigned int v18 = v17 ^ v16;
  int v19 = v15 ^ (v17 << 8);
  int v20 = (v19 ^ (v18 >> 1)) & 0x55555555;
  *int data = v20 ^ v19;
  data[1] = v18 ^ (2 * v20);
  DES_encrypt2(data, ks1, 1);
  DES_encrypt2(data, ks2, 0);
  DES_encrypt2(data, ks3, 1);
  unsigned int v21 = data[1];
  unsigned int v22 = (*data ^ (v21 >> 1)) & 0x55555555;
  unsigned int v23 = v22 ^ *data;
  int v24 = v21 ^ (2 * v22);
  int v25 = (v24 ^ (v23 >> 8)) & 0xFF00FF;
  unsigned int v26 = v25 ^ v24;
  int v27 = v23 ^ (v25 << 8);
  int v28 = (v27 ^ (v26 >> 2)) & 0x33333333;
  unsigned int v29 = v28 ^ v27;
  int v30 = v26 ^ (4 * v28);
  int v31 = (unsigned __int16)v30 ^ HIWORD(v29);
  unsigned int v32 = v31 ^ v30;
  int v33 = v29 ^ (v31 << 16);
  int v34 = (v33 ^ (v32 >> 4)) & 0xF0F0F0F;
  *int data = v34 ^ v33;
  data[1] = v32 ^ (16 * v34);
}

void DES_decrypt3(unsigned int *data, DES_key_schedule *ks1, DES_key_schedule *ks2, DES_key_schedule *ks3)
{
  unsigned int v7 = data[1];
  unsigned int v8 = (*data ^ (v7 >> 4)) & 0xF0F0F0F;
  unsigned int v9 = v8 ^ *data;
  int v10 = v7 ^ (16 * v8);
  int v11 = (unsigned __int16)v10 ^ HIWORD(v9);
  unsigned int v12 = v11 ^ v10;
  int v13 = v9 ^ (v11 << 16);
  int v14 = (v13 ^ (v12 >> 2)) & 0x33333333;
  unsigned int v15 = v14 ^ v13;
  int v16 = v12 ^ (4 * v14);
  int v17 = (v16 ^ (v15 >> 8)) & 0xFF00FF;
  unsigned int v18 = v17 ^ v16;
  int v19 = v15 ^ (v17 << 8);
  int v20 = (v19 ^ (v18 >> 1)) & 0x55555555;
  *int data = v20 ^ v19;
  data[1] = v18 ^ (2 * v20);
  DES_encrypt2(data, ks3, 0);
  DES_encrypt2(data, ks2, 1);
  DES_encrypt2(data, ks1, 0);
  unsigned int v21 = data[1];
  unsigned int v22 = (*data ^ (v21 >> 1)) & 0x55555555;
  unsigned int v23 = v22 ^ *data;
  int v24 = v21 ^ (2 * v22);
  int v25 = (v24 ^ (v23 >> 8)) & 0xFF00FF;
  unsigned int v26 = v25 ^ v24;
  int v27 = v23 ^ (v25 << 8);
  int v28 = (v27 ^ (v26 >> 2)) & 0x33333333;
  unsigned int v29 = v28 ^ v27;
  int v30 = v26 ^ (4 * v28);
  int v31 = (unsigned __int16)v30 ^ HIWORD(v29);
  unsigned int v32 = v31 ^ v30;
  int v33 = v29 ^ (v31 << 16);
  int v34 = (v33 ^ (v32 >> 4)) & 0xF0F0F0F;
  *int data = v34 ^ v33;
  data[1] = v32 ^ (16 * v34);
}

void DES_ncbc_encrypt(const unsigned __int8 *input, unsigned __int8 *output, uint64_t length, DES_key_schedule *schedule, DES_cblock *ivec, int enc)
{
  unsigned int v6 = ivec;
  uint64_t v8 = length;
  uint64_t v47 = *MEMORY[0x263EF8340];
  unsigned int v11 = *(_DWORD *)ivec;
  unsigned int v12 = *(_DWORD *)&(*ivec)[4];
  if (enc)
  {
    if (length >= 8)
    {
      do
      {
        int v13 = output;
        unint64_t v14 = v8;
        v8 -= 8;
        unsigned int v15 = *(_DWORD *)input;
        int v16 = *((_DWORD *)input + 1);
        input += 8;
        unsigned int data = v15 ^ v11;
        unsigned int v46 = v16 ^ v12;
        DES_encrypt1(&data, schedule, 1);
        unsigned int v11 = data;
        unsigned int v12 = v46;
        output += 8;
        *(_DWORD *)int v13 = data;
        *((_DWORD *)v13 + 1) = v12;
      }
      while (v14 > 0xF);
    }
    if (v8)
    {
      int v17 = 0;
      unsigned int v18 = &input[v8];
      int v19 = 0;
      switch(v8)
      {
        case 1:
          goto LABEL_12;
        case 2:
          goto LABEL_11;
        case 3:
          goto LABEL_10;
        case 4:
          goto LABEL_9;
        case 5:
          goto LABEL_8;
        case 6:
          goto LABEL_7;
        case 7:
          int v20 = *--v18;
          int v17 = v20 << 16;
LABEL_7:
          int v21 = *--v18;
          v17 |= v21 << 8;
LABEL_8:
          int v22 = *--v18;
          v17 |= v22;
LABEL_9:
          int v19 = v17;
          int v23 = *--v18;
          int v17 = v23 << 24;
LABEL_10:
          int v24 = *--v18;
          v17 |= v24 << 16;
LABEL_11:
          int v25 = *--v18;
          v17 |= v25 << 8;
LABEL_12:
          v17 |= *(v18 - 1);
          break;
        default:
          int v19 = 0;
          break;
      }
      unsigned int data = v17 ^ v11;
      unsigned int v46 = v19 ^ v12;
      DES_encrypt1(&data, schedule, 1);
      LOBYTE(v11) = data;
      unsigned int v12 = v46;
      unsigned int v26 = data >> 8;
      unsigned int v27 = HIWORD(data);
      unsigned int v28 = HIBYTE(data);
      unsigned int v29 = v46 >> 8;
      unsigned int v30 = HIWORD(v46);
      unsigned int v31 = HIBYTE(v46);
      *(_DWORD *)output = data;
      *((_DWORD *)output + 1) = v12;
    }
    else
    {
      unsigned int v26 = v11 >> 8;
      unsigned int v27 = HIWORD(v11);
      unsigned int v28 = HIBYTE(v11);
      unsigned int v29 = v12 >> 8;
      unsigned int v30 = HIWORD(v12);
      unsigned int v31 = HIBYTE(v12);
    }
    *(unsigned char *)unsigned int v6 = v11;
    (*v6)[1] = v26;
    (*v6)[2] = v27;
    (*v6)[3] = v28;
    (*v6)[4] = v12;
    (*v6)[5] = v29;
    (*v6)[6] = v30;
  }
  else
  {
    if (length >= 8)
    {
      do
      {
        unsigned int v32 = output;
        unsigned int v33 = v11;
        unsigned int v34 = v12;
        unsigned int v11 = *(_DWORD *)input;
        unsigned int v12 = *((_DWORD *)input + 1);
        unint64_t v35 = v8;
        v8 -= 8;
        int v36 = input + 8;
        unsigned int data = *(_DWORD *)input;
        unsigned int v46 = v12;
        DES_encrypt1(&data, schedule, 0);
        __int16 v37 = HIWORD(data) ^ HIWORD(v33);
        int v38 = v46 ^ v34;
        *(_WORD *)unsigned int v32 = data ^ v33;
        *((_WORD *)v32 + 1) = v37;
        *((_DWORD *)v32 + 1) = v38;
        output = v32 + 8;
        input += 8;
      }
      while (v35 > 0xF);
      input = v36;
      unsigned int v6 = ivec;
    }
    if (v8)
    {
      unsigned int v40 = *(_DWORD *)input;
      unsigned int v39 = *((_DWORD *)input + 1);
      unsigned int data = v40;
      unsigned int v46 = v39;
      DES_encrypt1(&data, schedule, 0);
      unsigned int v41 = data ^ v11;
      int v42 = v46 ^ v12;
      unsigned int v43 = &output[v8];
      switch(v8)
      {
        case 1:
          goto LABEL_25;
        case 2:
          goto LABEL_24;
        case 3:
          goto LABEL_23;
        case 4:
          goto LABEL_22;
        case 5:
          goto LABEL_21;
        case 6:
          goto LABEL_20;
        case 7:
          *--unsigned int v43 = BYTE2(v42);
LABEL_20:
          *--unsigned int v43 = BYTE1(v42);
LABEL_21:
          *--unsigned int v43 = v42;
LABEL_22:
          *--unsigned int v43 = HIBYTE(v41);
LABEL_23:
          *--unsigned int v43 = BYTE2(v41);
LABEL_24:
          *--unsigned int v43 = BYTE1(v41);
LABEL_25:
          *(v43 - 1) = v41;
          break;
        default:
          break;
      }
    }
    else
    {
      unsigned int v40 = v11;
      unsigned int v39 = v12;
    }
    *(_DWORD *)unsigned int v6 = v40;
    *(_WORD *)&(*v6)[4] = v39;
    unsigned int v31 = HIBYTE(v39);
    (*v6)[6] = BYTE2(v39);
  }
  (*v6)[7] = v31;
}

void DES_ede3_cbc_encrypt(const unsigned __int8 *input, unsigned __int8 *output, uint64_t length, DES_key_schedule *ks1, DES_key_schedule *ks2, DES_key_schedule *ks3, DES_cblock *ivec, int enc)
{
  uint64_t v8 = ivec;
  unsigned int v9 = ks3;
  int v10 = ks2;
  uint64_t v11 = length;
  uint64_t v51 = *MEMORY[0x263EF8340];
  unsigned int v15 = *(_DWORD *)ivec;
  unsigned int v14 = *(_DWORD *)&(*ivec)[4];
  int v48 = ks1;
  if (enc)
  {
    if (length >= 8)
    {
      do
      {
        unint64_t v16 = v11;
        v11 -= 8;
        unsigned int v17 = *(_DWORD *)input;
        int v18 = *((_DWORD *)input + 1);
        input += 8;
        unsigned int data = v17 ^ v15;
        int v50 = v18 ^ v14;
        DES_encrypt3(&data, ks1, v10, v9);
        ks1 = v48;
        unsigned int v15 = data;
        unsigned int v14 = v50;
        *(_WORD *)output = data;
        output[2] = BYTE2(v15);
        output[3] = HIBYTE(v15);
        *((_DWORD *)output + 1) = v14;
        output += 8;
      }
      while (v16 > 0xF);
    }
    if (v11)
    {
      int v19 = 0;
      int v20 = &input[v11];
      int v21 = 0;
      switch(v11)
      {
        case 1:
          goto LABEL_12;
        case 2:
          goto LABEL_11;
        case 3:
          goto LABEL_10;
        case 4:
          goto LABEL_9;
        case 5:
          goto LABEL_8;
        case 6:
          goto LABEL_7;
        case 7:
          int v22 = *--v20;
          int v19 = v22 << 16;
LABEL_7:
          int v23 = *--v20;
          v19 |= v23 << 8;
LABEL_8:
          int v24 = *--v20;
          v19 |= v24;
LABEL_9:
          int v21 = v19;
          int v25 = *--v20;
          int v19 = v25 << 24;
LABEL_10:
          int v26 = *--v20;
          v19 |= v26 << 16;
LABEL_11:
          int v27 = *--v20;
          v19 |= v27 << 8;
LABEL_12:
          v19 |= *(v20 - 1);
          break;
        default:
          int v21 = 0;
          break;
      }
      unsigned int data = v19 ^ v15;
      int v50 = v21 ^ v14;
      DES_encrypt3(&data, ks1, v10, v9);
      unsigned int v15 = data;
      unsigned int v14 = v50;
      *output = data;
      unsigned int v28 = v15 >> 8;
      output[1] = BYTE1(v15);
      unsigned int v29 = HIWORD(v15);
      output[2] = BYTE2(v15);
      unsigned int v30 = HIBYTE(v15);
      output[3] = HIBYTE(v15);
      *((_DWORD *)output + 1) = v14;
      unsigned int v31 = v14 >> 8;
      unsigned int v32 = HIWORD(v14);
      unsigned int v33 = HIBYTE(v14);
    }
    else
    {
      unsigned int v28 = v15 >> 8;
      unsigned int v29 = HIWORD(v15);
      unsigned int v30 = HIBYTE(v15);
      unsigned int v31 = v14 >> 8;
      unsigned int v32 = HIWORD(v14);
      unsigned int v33 = HIBYTE(v14);
    }
    *(unsigned char *)uint64_t v8 = v15;
    (*v8)[1] = v28;
    (*v8)[2] = v29;
    (*v8)[3] = v30;
    (*v8)[4] = v14;
    (*v8)[5] = v31;
    (*v8)[6] = v32;
  }
  else
  {
    if (length >= 8)
    {
      do
      {
        unsigned int v34 = v15;
        unsigned int v35 = v14;
        unsigned int v15 = *(_DWORD *)input;
        unsigned int v14 = *((_DWORD *)input + 1);
        unint64_t v36 = v11;
        v11 -= 8;
        __int16 v37 = input + 8;
        unsigned int data = *(_DWORD *)input;
        int v50 = v14;
        DES_decrypt3(&data, ks1, ks2, ks3);
        ks1 = v48;
        __int16 v38 = HIWORD(data) ^ HIWORD(v34);
        int v39 = v50 ^ v35;
        *(_WORD *)output = data ^ v34;
        *((_WORD *)output + 1) = v38;
        *((_DWORD *)output + 1) = v39;
        output += 8;
        input += 8;
      }
      while (v36 > 0xF);
      input = v37;
      uint64_t v8 = ivec;
      unsigned int v9 = ks3;
      int v10 = ks2;
    }
    if (v11)
    {
      unsigned int v41 = *(_DWORD *)input;
      unsigned int v40 = *((_DWORD *)input + 1);
      unsigned int data = v41;
      int v50 = v40;
      DES_decrypt3(&data, ks1, v10, v9);
      unsigned int v42 = data ^ v15;
      int v43 = v50 ^ v14;
      unsigned int v44 = &output[v11];
      switch(v11)
      {
        case 1:
          goto LABEL_25;
        case 2:
          goto LABEL_24;
        case 3:
          goto LABEL_23;
        case 4:
          goto LABEL_22;
        case 5:
          goto LABEL_21;
        case 6:
          goto LABEL_20;
        case 7:
          *--unsigned int v44 = BYTE2(v43);
LABEL_20:
          *--unsigned int v44 = BYTE1(v43);
LABEL_21:
          *--unsigned int v44 = v43;
LABEL_22:
          *--unsigned int v44 = HIBYTE(v42);
LABEL_23:
          *--unsigned int v44 = BYTE2(v42);
LABEL_24:
          *--unsigned int v44 = BYTE1(v42);
LABEL_25:
          *(v44 - 1) = v42;
          break;
        default:
          break;
      }
    }
    else
    {
      unsigned int v41 = v15;
      unsigned int v40 = v14;
    }
    *(_DWORD *)uint64_t v8 = v41;
    *(_WORD *)&(*v8)[4] = v40;
    unsigned int v33 = HIBYTE(v40);
    (*v8)[6] = BYTE2(v40);
  }
  (*v8)[7] = v33;
}

int EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type)
{
  *(_OWORD *)&ctx->flags = 0u;
  *(_OWORD *)&ctx[1].digest = 0u;
  *(_OWORD *)&ctx->digest = 0u;
  return EVP_DigestInit_ex(ctx, type, 0);
}

void EVP_MD_CTX_init(EVP_MD_CTX *ctx)
{
  *(_OWORD *)&ctx->flags = 0u;
  *(_OWORD *)&ctx[1].digest = 0u;
  *(_OWORD *)&ctx->digest = 0u;
}

int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl)
{
  EVP_MD_CTX_clear_flags(ctx, 2);
  engine = ctx->engine;
  if (!engine || !ctx->digest)
  {
    if (!type)
    {
      digest = ctx->digest;
      if (!ctx->digest)
      {
        int v7 = 139;
        int v8 = 178;
        goto LABEL_35;
      }
      int type = 0;
LABEL_17:
      if (HIDWORD(digest->sign) && ctx->md_data && !EVP_MD_CTX_test_flags(ctx, 4))
      {
        freezero(ctx->md_data, SHIDWORD(ctx->digest->sign));
        ctx->md_unsigned int data = 0;
      }
LABEL_21:
      ctx->digest = type;
      if ((ctx->flags & 0x100) != 0) {
        goto LABEL_24;
      }
      size_t sign_high = SHIDWORD(type->sign);
      if (!sign_high) {
        goto LABEL_24;
      }
      ctx[1].engine = (ENGINE *)type->update;
      unsigned int v12 = malloc_type_calloc(1uLL, sign_high, 0xD2D81BBBuLL);
      ctx->md_unsigned int data = v12;
      if (v12) {
        goto LABEL_24;
      }
      EVP_PKEY_CTX_free((EVP_PKEY **)ctx[1].digest);
      ctx[1].digest = 0;
      int v7 = 65;
      int v8 = 195;
      goto LABEL_35;
    }
LABEL_7:
    ENGINE_finish(engine);
    if (impl)
    {
      if (!ENGINE_init(impl))
      {
        int v7 = 134;
        int v8 = 154;
LABEL_35:
        ERR_put_error(6, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/digest.c", v8);
        return 0;
      }
    }
    else
    {
      impl = ENGINE_get_digest_engine(type->type);
      if (!impl) {
        goto LABEL_15;
      }
    }
    int v10 = ENGINE_get_digest(impl, type->type);
    if (!v10)
    {
      ERR_put_error(6, 4095, 134, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/digest.c", 165);
      ENGINE_finish(impl);
      return 0;
    }
    int type = v10;
LABEL_15:
    ctx->engine = impl;
    digest = ctx->digest;
    if (ctx->digest == type) {
      goto LABEL_24;
    }
    if (!digest) {
      goto LABEL_21;
    }
    goto LABEL_17;
  }
  if (type && type->type != ctx->digest->type) {
    goto LABEL_7;
  }
LABEL_24:
  p_int type = (uint64_t *)&ctx[1].digest->type;
  if (!p_type || (v14 = EVP_PKEY_CTX_ctrl(p_type, -1, 248), v14 > 0) || (v15 = v14, int result = 0, v15 == -2))
  {
    if ((ctx->flags & 0x100) != 0)
    {
      return 1;
    }
    else
    {
      init = ctx->digest->init;
      return ((uint64_t (*)(EVP_MD_CTX *))init)(ctx);
    }
  }
  return result;
}

int EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *d, size_t cnt)
{
  return ((uint64_t (*)(EVP_MD_CTX *, const void *, size_t))ctx[1].engine)(ctx, d, cnt);
}

int EVP_DigestFinal(EVP_MD_CTX *ctx, unsigned __int8 *md, unsigned int *s)
{
  int v4 = EVP_DigestFinal_ex(ctx, md, s);
  EVP_MD_CTX_cleanup(ctx);
  return v4;
}

int EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned __int8 *md, unsigned int *s)
{
  if (ctx->digest->md_size < 0x41u)
  {
    int v3 = ((uint64_t (*)(void))ctx->digest->final)();
    digest = ctx->digest;
    if (s) {
      unsigned __int8 *s = digest->md_size;
    }
    cleanup = digest->cleanup;
    if (cleanup)
    {
      ((void (*)(EVP_MD_CTX *))cleanup)(ctx);
      EVP_MD_CTX_set_flags(ctx, 2);
      digest = ctx->digest;
    }
    bzero(ctx->md_data, SHIDWORD(digest->sign));
  }
  else
  {
    ERR_put_error(6, 4095, 164, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/digest.c", 239);
    return 0;
  }
  return v3;
}

int EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx)
{
  digest = ctx->digest;
  if (ctx->digest)
  {
    if (!digest->cleanup) {
      goto LABEL_15;
    }
    int v3 = EVP_MD_CTX_test_flags(ctx, 2);
    digest = ctx->digest;
    if (!v3)
    {
      ((void (*)(EVP_MD_CTX *))digest->cleanup)(ctx);
      digest = ctx->digest;
    }
    if (digest)
    {
LABEL_15:
      if (HIDWORD(digest->sign) && ctx->md_data && !EVP_MD_CTX_test_flags(ctx, 4)) {
        freezero(ctx->md_data, SHIDWORD(ctx->digest->sign));
      }
    }
  }
  if (!EVP_MD_CTX_test_flags(ctx, 1024)) {
    EVP_PKEY_CTX_free((EVP_PKEY **)ctx[1].digest);
  }
  ENGINE_finish(ctx->engine);
  *(_OWORD *)&ctx->digest = 0u;
  *(_OWORD *)&ctx->flags = 0u;
  *(_OWORD *)&ctx[1].digest = 0u;
  return 1;
}

int EVP_MD_CTX_copy(EVP_MD_CTX *out, const EVP_MD_CTX *in)
{
  *(_OWORD *)&out->flags = 0u;
  *(_OWORD *)&out[1].digest = 0u;
  *(_OWORD *)&out->digest = 0u;
  return EVP_MD_CTX_copy_ex(out, in);
}

int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out, const EVP_MD_CTX *in)
{
  if (!in || (digest = in->digest) == 0)
  {
    int v7 = 111;
    int v8 = 266;
    goto LABEL_9;
  }
  engine = in->engine;
  if (engine)
  {
    if (!ENGINE_init(engine))
    {
      int v7 = 38;
      int v8 = 272;
      goto LABEL_9;
    }
    digest = in->digest;
  }
  if (out->digest == digest)
  {
    md_unsigned int data = out->md_data;
    EVP_MD_CTX_set_flags(out, 4);
  }
  else
  {
    md_unsigned int data = 0;
  }
  EVP_MD_CTX_cleanup(out);
  long long v10 = *(_OWORD *)&in[1].digest;
  long long v11 = *(_OWORD *)&in->digest;
  *(_OWORD *)&out->flags = *(_OWORD *)&in->flags;
  *(_OWORD *)&out[1].digest = v10;
  *(_OWORD *)&out->digest = v11;
  out->md_unsigned int data = 0;
  p_md_unsigned int data = &out->md_data;
  out[1].digest = 0;
  EVP_MD_CTX_clear_flags(out, 1024);
  if (in->md_data)
  {
    int sign_high = HIDWORD(out->digest->sign);
    if (sign_high)
    {
      if (md_data)
      {
        *p_md_unsigned int data = md_data;
LABEL_19:
        memcpy(md_data, in->md_data, sign_high);
        goto LABEL_20;
      }
      int v14 = malloc_type_calloc(1uLL, sign_high, 0x41AE253EuLL);
      *p_md_unsigned int data = v14;
      if (v14)
      {
        md_unsigned int data = v14;
        int sign_high = HIDWORD(out->digest->sign);
        goto LABEL_19;
      }
      int v7 = 65;
      int v8 = 299;
LABEL_9:
      ERR_put_error(6, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/digest.c", v8);
      return 0;
    }
  }
LABEL_20:
  int v15 = in[1].digest;
  out[1].engine = in[1].engine;
  if (v15)
  {
    unint64_t v16 = (const EVP_MD *)EVP_PKEY_CTX_dup((uint64_t)v15);
    out[1].digest = v16;
    if (!v16)
    {
      EVP_MD_CTX_cleanup(out);
      return 0;
    }
  }
  copy = out->digest->copy;
  if (!copy) {
    return 1;
  }
  return ((uint64_t (*)(EVP_MD_CTX *, const EVP_MD_CTX *))copy)(out, in);
}

int EVP_Digest(const void *data, size_t count, unsigned __int8 *md, unsigned int *size, const EVP_MD *type, ENGINE *impl)
{
  long long v15 = 0u;
  memset(&v14, 0, sizeof(v14));
  EVP_MD_CTX_set_flags(&v14, 1);
  int v12 = EVP_DigestInit_ex(&v14, type, impl)
     && (*((unsigned int (**)(EVP_MD_CTX *, const void *, size_t))&v15 + 1))(&v14, data, count)
     && EVP_DigestFinal_ex(&v14, md, size) != 0;
  EVP_MD_CTX_cleanup(&v14);
  return v12;
}

void *EVP_MD_CTX_new()
{
  return malloc_type_calloc(1uLL, 0x30uLL, 0x10E0040E563E252uLL);
}

void EVP_MD_CTX_free(EVP_MD_CTX *a1)
{
  if (a1)
  {
    EVP_MD_CTX_cleanup(a1);
    free(a1);
  }
}

uint64_t EVP_MD_CTX_reset(EVP_MD_CTX *a1)
{
  return 1;
}

EVP_MD_CTX *EVP_MD_CTX_create(void)
{
  return (EVP_MD_CTX *)malloc_type_calloc(1uLL, 0x30uLL, 0x10E0040E563E252uLL);
}

void EVP_MD_CTX_destroy(EVP_MD_CTX *ctx)
{
  if (ctx)
  {
    EVP_MD_CTX_cleanup(ctx);
    free(ctx);
  }
}

uint64_t EVP_MD_CTX_ctrl(uint64_t a1)
{
  if (*(void *)a1)
  {
    uint64_t v1 = *(uint64_t (**)(void))(*(void *)a1 + 72);
    if (v1)
    {
      uint64_t result = v1();
      if (result != -1) {
        return result;
      }
      int v3 = 133;
      int v4 = 425;
    }
    else
    {
      int v3 = 132;
      int v4 = 419;
    }
  }
  else
  {
    int v3 = 131;
    int v4 = 414;
  }
  ERR_put_error(6, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/digest.c", v4);
  return 0;
}

int EVP_SignFinal(EVP_MD_CTX *ctx, unsigned __int8 *md, unsigned int *s, EVP_PKEY *pkey)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  sBIGNUM a = 0;
  long long v14 = 0u;
  memset(&ctxa, 0, sizeof(ctxa));
  uint64_t v12 = 0;
  unsigned __int8 *s = 0;
  EVP_MD_CTX_init(&ctxa);
  if (!EVP_MD_CTX_copy_ex(&ctxa, ctx) || !EVP_DigestFinal_ex(&ctxa, mda, &sa))
  {
    unsigned int v9 = 0;
LABEL_9:
    int v10 = 0;
    goto LABEL_10;
  }
  EVP_MD_CTX_cleanup(&ctxa);
  uint64_t v12 = EVP_PKEY_size(pkey);
  int v8 = (uint64_t *)EVP_PKEY_CTX_new((uint64_t)pkey, 0);
  unsigned int v9 = v8;
  if (!v8
    || (int)EVP_PKEY_sign_init(v8) < 1
    || (int)EVP_PKEY_CTX_ctrl(v9, -1, 248) < 1
    || (int)EVP_PKEY_sign(v9, (uint64_t)md, &v12, (uint64_t)mda, sa) < 1)
  {
    goto LABEL_9;
  }
  unsigned __int8 *s = v12;
  int v10 = 1;
LABEL_10:
  EVP_PKEY_CTX_free((EVP_PKEY **)v9);
  return v10;
}

int ASN1_get_object(const unsigned __int8 **pp, uint64_t *plength, int *ptag, int *pclass, uint64_t omax)
{
  uint64_t v19 = 0;
  int v18 = 0;
  unsigned __int8 v17 = 0;
  unint64_t v16 = 0;
  memset(v15, 0, sizeof(v15));
  *pclass = 0;
  *ptag = 0;
  *pint length = 0;
  CBS_init(v15, (uint64_t)*pp, omax);
  if (!asn1_get_object_cbs(v15, 0, &v17, (int *)&v19 + 1, &v18, &v19, &v16))
  {
    int v12 = 89;
LABEL_8:
    ERR_put_error(13, 4095, 123, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_old_lib.c", v12);
    return 128;
  }
  if (v18 < 0)
  {
    int v12 = 94;
    goto LABEL_8;
  }
  unint64_t v9 = v16;
  if (v9 > CBS_len((uint64_t)v15) || (uint64_t v10 = v16, (v16 & 0x8000000000000000) != 0))
  {
    ERR_put_error(13, 4095, 155, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_old_lib.c", 104);
    int v11 = 128;
    uint64_t v10 = v16;
  }
  else
  {
    int v11 = 0;
  }
  *pclass = v17 << 6;
  *ptag = v18;
  *pint length = v10;
  *pp = (const unsigned __int8 *)CBS_data((uint64_t)v15);
  if (HIDWORD(v19)) {
    int v14 = v11 | 0x20;
  }
  else {
    int v14 = v11;
  }
  return v14 | (v19 != 0);
}

void ASN1_put_object(unsigned __int8 **pp, int constructed, int length, int tag, int xclass)
{
  int v5 = *pp;
  char v6 = xclass & 0xC0 | (32 * (constructed != 0));
  if (tag > 30)
  {
    uint64_t v8 = 0;
    *int v5 = v6 | 0x1F;
    unsigned int v9 = tag;
    do
    {
      ++v8;
      BOOL v10 = v9 >= 0x80;
      v9 >>= 7;
    }
    while (v10);
    uint64_t v11 = 0;
    do
    {
      v5[v11 + v8] = tag & 0x7F | ((v11 != 0) << 7);
      tag = tag >> 7;
      --v11;
    }
    while (v11 + v8 > 0);
    int v7 = &v5[v8 + 1];
  }
  else
  {
    *int v5 = v6 | tag & 0x1F;
    int v7 = v5 + 1;
  }
  if (constructed == 2)
  {
    *int v7 = 0x80;
    int v12 = v7 + 1;
  }
  else if (length >= 128)
  {
    uint64_t v13 = 1;
    unsigned int v14 = length;
    do
    {
      ++v13;
      BOOL v15 = v14 > 0xFF;
      v14 >>= 8;
    }
    while (v15);
    *int v7 = (v13 - 1) | 0x80;
    uint64_t v16 = v13;
    do
    {
      v7[(v16 - 2) + 1] = length;
      int length = length >> 8;
      --v16;
    }
    while (v16 > 1);
    int v12 = &v7[v13];
  }
  else
  {
    *int v7 = length;
    int v12 = v7 + 1;
  }
  *pp = v12;
}

int ASN1_put_eoc(unsigned __int8 **pp)
{
  uint64_t v1 = *pp;
  *(_WORD *)uint64_t v1 = 0;
  *pp = v1 + 2;
  return 2;
}

int ASN1_object_size(int constructed, int length, int tag)
{
  int v3 = length + 1;
  if (tag >= 31)
  {
    do
    {
      ++v3;
      BOOL v4 = tag > 0x7F;
      tag = tag >> 7;
    }
    while (v4);
  }
  if (constructed == 2) {
    return v3 + 3;
  }
  int result = v3 + 1;
  if (length >= 128)
  {
    do
    {
      ++result;
      BOOL v4 = length > 0xFF;
      int length = length >> 8;
    }
    while (v4);
  }
  return result;
}

ASN1_VALUE *d2i_ASRange(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &ASRange_it);
}

uint64_t i2d_ASRange(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &ASRange_it);
}

ASN1_VALUE *ASRange_new()
{
  return ASN1_item_new(&ASRange_it);
}

void ASRange_free(ASN1_VALUE *a1)
{
}

ASN1_VALUE *d2i_ASIdOrRange(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &ASIdOrRange_it);
}

uint64_t i2d_ASIdOrRange(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &ASIdOrRange_it);
}

ASN1_VALUE *ASIdOrRange_new()
{
  return ASN1_item_new(&ASIdOrRange_it);
}

void ASIdOrRange_free(ASN1_VALUE *a1)
{
}

ASN1_VALUE *d2i_ASIdentifierChoice(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &ASIdentifierChoice_it);
}

uint64_t i2d_ASIdentifierChoice(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &ASIdentifierChoice_it);
}

ASN1_VALUE *ASIdentifierChoice_new()
{
  return ASN1_item_new(&ASIdentifierChoice_it);
}

void ASIdentifierChoice_free(ASN1_VALUE *a1)
{
}

ASN1_VALUE *d2i_ASIdentifiers(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &ASIdentifiers_it);
}

uint64_t i2d_ASIdentifiers(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &ASIdentifiers_it);
}

ASN1_VALUE *ASIdentifiers_new()
{
  return ASN1_item_new(&ASIdentifiers_it);
}

void ASIdentifiers_free(ASN1_VALUE *a1)
{
}

uint64_t X509v3_asid_add_inherit(uint64_t result, int a2)
{
  if (result)
  {
    uint64_t v2 = result;
    if (a2)
    {
      if (a2 != 1) {
        return 0;
      }
      uint64_t v2 = result + 8;
    }
    if (*(void *)v2)
    {
      return **(_DWORD **)v2 == 0;
    }
    else
    {
      int result = (uint64_t)ASN1_item_new(&ASIdentifierChoice_it);
      *(void *)uint64_t v2 = result;
      if (result)
      {
        int result = (uint64_t)ASN1_NULL_new();
        *(void *)(*(void *)v2 + 8) = result;
        if (result)
        {
          **(_DWORD **)uint64_t v2 = 0;
          return 1;
        }
      }
    }
  }
  return result;
}

ASN1_VALUE *X509v3_asid_add_id_or_range(ASN1_VALUE *result, int a2, uint64_t a3, uint64_t a4)
{
  if (result)
  {
    char v6 = result;
    if (a2)
    {
      if (a2 != 1) {
        return 0;
      }
      char v6 = (ASN1_VALUE *)((char *)result + 8);
    }
    if (*(void *)v6)
    {
      if (!**(_DWORD **)v6) {
        return 0;
      }
    }
    else
    {
      int result = ASN1_item_new(&ASIdentifierChoice_it);
      *(void *)char v6 = result;
      if (!result) {
        return result;
      }
      *(void *)(*(void *)v6 + 8) = sk_new((int (__cdecl *)(const char *const *, const char *const *))ASIdOrRange_cmp);
      if (!*(void *)(*(void *)v6 + 8)) {
        return 0;
      }
      **(_DWORD **)char v6 = 1;
    }
    int result = ASN1_item_new(&ASIdOrRange_it);
    if (!result) {
      return result;
    }
    int v7 = result;
    if (a4)
    {
      *(_DWORD *)int result = 1;
      uint64_t v8 = (ASN1_INTEGER **)ASN1_item_new(&ASRange_it);
      *((void *)v7 + 1) = v8;
      if (!v8)
      {
LABEL_18:
        ASN1_item_free(v7, &ASIdOrRange_it);
        return 0;
      }
      ASN1_INTEGER_free(*v8);
      **((void **)v7 + 1) = a3;
      ASN1_INTEGER_free(*(ASN1_INTEGER **)(*((void *)v7 + 1) + 8));
      *(void *)(*((void *)v7 + 1) + 8) = a4;
    }
    else
    {
      *(_DWORD *)int result = 0;
      *((void *)result + 1) = a3;
    }
    if (sk_push(*(STACK **)(*(void *)v6 + 8), (char *)v7)) {
      return (ASN1_VALUE *)1;
    }
    goto LABEL_18;
  }
  return result;
}

uint64_t ASIdOrRange_cmp(int **a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *a2;
  int v4 = **a1;
  if (v4 == 1)
  {
    int v5 = (void *)*((void *)v2 + 1);
    if (!v5 || !*v5 || !v5[1]) {
LABEL_8:
    }
      OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_asid.c", 381, "(a->type == ASIdOrRange_id && a->u.id != NULL) || (a->type == ASIdOrRange_range && a->u.range != NULL && a->u.range->min != NULL && a->u.range->max != NULL)");
  }
  else if (v4 || !*((void *)v2 + 1))
  {
    goto LABEL_8;
  }
  if (*(_DWORD *)v3 == 1)
  {
    char v6 = *(void **)(v3 + 8);
    if (!v6 || !*v6 || !v6[1]) {
LABEL_16:
    }
      OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_asid.c", 385, "(b->type == ASIdOrRange_id && b->u.id != NULL) || (b->type == ASIdOrRange_range && b->u.range != NULL && b->u.range->min != NULL && b->u.range->max != NULL)");
  }
  else if (*(_DWORD *)v3 || !*(void *)(v3 + 8))
  {
    goto LABEL_16;
  }
  if (*v2 != 1)
  {
    if (!*v2)
    {
      int v7 = (ASN1_INTEGER *)*((void *)v2 + 1);
      uint64_t v8 = *(ASN1_INTEGER **)(v3 + 8);
      if (*(_DWORD *)v3) {
        uint64_t v8 = *(ASN1_INTEGER **)&v8->length;
      }
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  if (*(_DWORD *)v3 != 1)
  {
LABEL_24:
    int v7 = (ASN1_INTEGER *)**((void **)v2 + 1);
    uint64_t v8 = *(ASN1_INTEGER **)(v3 + 8);
    goto LABEL_25;
  }
  uint64_t result = ASN1_INTEGER_cmp(**((ASN1_INTEGER ***)v2 + 1), **(ASN1_INTEGER ***)(v3 + 8));
  if (result) {
    return result;
  }
  int v7 = *(ASN1_INTEGER **)(*((void *)v2 + 1) + 8);
  uint64_t v8 = *(ASN1_INTEGER **)(*(void *)(v3 + 8) + 8);
LABEL_25:
  return ASN1_INTEGER_cmp(v7, v8);
}

uint64_t X509v3_asid_is_canonical(uint64_t *a1)
{
  if (!a1) {
    return 1;
  }
  uint64_t result = ASIdentifierChoice_is_canonical(*a1);
  if (result) {
    return ASIdentifierChoice_is_canonical(a1[1]) != 0;
  }
  return result;
}

uint64_t ASIdentifierChoice_is_canonical(uint64_t a1)
{
  if (!a1 || !*(_DWORD *)a1) {
    return 1;
  }
  if (*(_DWORD *)a1 != 1 || !sk_num(*(const STACK **)(a1 + 8))) {
    return 0;
  }
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  int v4 = 0;
  while (1)
  {
    int v5 = sk_num(*(const STACK **)(a1 + 8)) - 1;
    char v6 = *(const STACK **)(a1 + 8);
    if (v4 >= v5) {
      break;
    }
    int v7 = sk_value(v6, v4);
    uint64_t v8 = sk_value(*(const STACK **)(a1 + 8), v4 + 1);
    if (*(_DWORD *)v7 == 1)
    {
      unsigned int v9 = (ASN1_INTEGER **)*((void *)v7 + 1);
      BOOL v10 = v9 + 1;
    }
    else
    {
      if (*(_DWORD *)v7) {
        goto LABEL_34;
      }
      unsigned int v9 = (ASN1_INTEGER **)(v7 + 8);
      BOOL v10 = (ASN1_INTEGER **)(v7 + 8);
    }
    uint64_t v11 = *v9;
    int v12 = *v10;
    if (*(_DWORD *)v8 == 1)
    {
      uint64_t v13 = (ASN1_INTEGER **)*((void *)v8 + 1);
      unsigned int v14 = v13 + 1;
    }
    else
    {
      if (*(_DWORD *)v8) {
        goto LABEL_34;
      }
      uint64_t v13 = (ASN1_INTEGER **)(v8 + 8);
      unsigned int v14 = (ASN1_INTEGER **)(v8 + 8);
    }
    BOOL v15 = *v13;
    uint64_t v16 = *v14;
    if ((ASN1_INTEGER_cmp(v11, *v13) & 0x80000000) == 0
      || ASN1_INTEGER_cmp(v11, v12) > 0
      || ASN1_INTEGER_cmp(v15, v16) > 0)
    {
      goto LABEL_34;
    }
    if (!v3 && (uint64_t v3 = BN_new()) == 0 || !ASN1_INTEGER_to_BN(v12, v3) || !BN_add_word(v3, 1uLL))
    {
      int v20 = 563;
LABEL_33:
      ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_asid.c", v20);
      goto LABEL_34;
    }
    unsigned __int8 v17 = BN_to_ASN1_INTEGER(v3, v2);
    if (!v17)
    {
      int v20 = 570;
      goto LABEL_33;
    }
    int v18 = v17;
    ++v4;
    uint64_t v2 = v17;
    if ((ASN1_INTEGER_cmp(v17, v15) & 0x80000000) == 0)
    {
      uint64_t v19 = 0;
      uint64_t v2 = v18;
      goto LABEL_35;
    }
  }
  int v21 = sk_num(v6);
  int v22 = sk_value(*(const STACK **)(a1 + 8), v21 - 1);
  if (!v22
    || *(_DWORD *)v22 != 1
    || ASN1_INTEGER_cmp(**((ASN1_INTEGER ***)v22 + 1), *(ASN1_INTEGER **)(*((void *)v22 + 1) + 8)) <= 0)
  {
    uint64_t v19 = 1;
    goto LABEL_35;
  }
LABEL_34:
  uint64_t v19 = 0;
LABEL_35:
  ASN1_INTEGER_free(v2);
  BN_free(v3);
  return v19;
}

uint64_t X509v3_asid_canonize(uint64_t *a1)
{
  if (!a1) {
    return 1;
  }
  uint64_t result = ASIdentifierChoice_canonize(*a1);
  if (result)
  {
    uint64_t v3 = a1[1];
    return ASIdentifierChoice_canonize(v3);
  }
  return result;
}

uint64_t ASIdentifierChoice_canonize(uint64_t a1)
{
  if (!a1 || !*(_DWORD *)a1) {
    return 1;
  }
  if (*(_DWORD *)a1 == 1 && sk_num(*(const STACK **)(a1 + 8)))
  {
    sk_sort(*(STACK **)(a1 + 8));
    if (sk_num(*(const STACK **)(a1 + 8)) >= 2)
    {
      int v2 = 0;
      uint64_t v3 = 0;
      int v4 = 0;
      while (1)
      {
        int v5 = sk_value(*(const STACK **)(a1 + 8), v2);
        char v6 = sk_value(*(const STACK **)(a1 + 8), v2 + 1);
        int v7 = v6;
        aunsigned int i = v4;
        if (*(_DWORD *)v5 == 1)
        {
          uint64_t v8 = (ASN1_INTEGER **)*((void *)v5 + 1);
          unsigned int v9 = v8 + 1;
        }
        else
        {
          if (*(_DWORD *)v5) {
            goto LABEL_50;
          }
          uint64_t v8 = (ASN1_INTEGER **)(v5 + 8);
          unsigned int v9 = (ASN1_INTEGER **)(v5 + 8);
        }
        BOOL v10 = *v8;
        uint64_t v11 = *v9;
        if (*(_DWORD *)v6 == 1)
        {
          int v12 = (ASN1_INTEGER **)*((void *)v6 + 1);
          uint64_t v13 = v12 + 1;
        }
        else
        {
          if (*(_DWORD *)v6) {
            goto LABEL_50;
          }
          int v12 = (ASN1_INTEGER **)(v6 + 8);
          uint64_t v13 = (ASN1_INTEGER **)(v6 + 8);
        }
        unsigned int v14 = *v12;
        BOOL v15 = *v13;
        if (ASN1_INTEGER_cmp(v10, *v12) > 0 || ASN1_INTEGER_cmp(v10, v11) > 0 || ASN1_INTEGER_cmp(v14, v15) > 0) {
          goto LABEL_50;
        }
        if ((ASN1_INTEGER_cmp(v11, v14) & 0x80000000) == 0)
        {
          int v22 = 116;
          int v23 = 683;
          goto LABEL_49;
        }
        if (!v3 && (uint64_t v3 = BN_new()) == 0 || !ASN1_INTEGER_to_BN(v11, v3) || !BN_add_word(v3, 1uLL))
        {
          int v22 = 65;
          int v23 = 693;
LABEL_49:
          ERR_put_error(34, 4095, v22, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_asid.c", v23);
          goto LABEL_50;
        }
        uint64_t v16 = BN_to_ASN1_INTEGER(v3, ai);
        if (!v16)
        {
          int v22 = 65;
          int v23 = 700;
          goto LABEL_49;
        }
        int v4 = v16;
        if (!ASN1_INTEGER_cmp(v16, v14)) {
          break;
        }
        ++v2;
LABEL_37:
        if (v2 >= sk_num(*(const STACK **)(a1 + 8)) - 1) {
          goto LABEL_42;
        }
      }
      if (*(_DWORD *)v5 == 1)
      {
        ASN1_INTEGER_free(*(ASN1_INTEGER **)(*((void *)v5 + 1) + 8));
        *(void *)(*((void *)v5 + 1) + 8) = v15;
      }
      else if (!*(_DWORD *)v5)
      {
        unsigned __int8 v17 = malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
        if (!v17)
        {
          aunsigned int i = v4;
          int v22 = 65;
          int v23 = 712;
          goto LABEL_49;
        }
        *unsigned __int8 v17 = v10;
        v17[1] = v15;
        *(_DWORD *)int v5 = 1;
        *((void *)v5 + 1) = v17;
      }
      if (*(_DWORD *)v7 == 1)
      {
        int v18 = (void *)(*((void *)v7 + 1) + 8);
      }
      else
      {
        if (*(_DWORD *)v7)
        {
LABEL_36:
          ASN1_item_free((ASN1_VALUE *)v7, &ASIdOrRange_it);
          sk_delete(*(STACK **)(a1 + 8), v2 + 1);
          goto LABEL_37;
        }
        int v18 = v7 + 8;
      }
      *int v18 = 0;
      goto LABEL_36;
    }
    int v4 = 0;
    uint64_t v3 = 0;
LABEL_42:
    aunsigned int i = v4;
    int v20 = sk_num(*(const STACK **)(a1 + 8));
    int v21 = sk_value(*(const STACK **)(a1 + 8), v20 - 1);
    if (v21
      && *(_DWORD *)v21 == 1
      && ASN1_INTEGER_cmp(**((ASN1_INTEGER ***)v21 + 1), *(ASN1_INTEGER **)(*((void *)v21 + 1) + 8)) > 0)
    {
LABEL_50:
      BOOL v19 = 0;
    }
    else
    {
      BOOL v19 = ASIdentifierChoice_is_canonical(a1) != 0;
    }
    ASN1_INTEGER_free(ai);
    BN_free(v3);
  }
  else
  {
    ERR_put_error(34, 4095, 116, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_asid.c", 638);
    return 0;
  }
  return v19;
}

uint64_t *v2i_ASIdentifiers(uint64_t a1, uint64_t a2, const STACK *a3)
{
  x = 0;
  int v4 = (uint64_t *)ASN1_item_new(&ASIdentifiers_it);
  if (!v4)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_asid.c", 796);
    return v4;
  }
  if (sk_num(a3) < 1)
  {
LABEL_24:
    if (X509v3_asid_canonize(v4)) {
      return v4;
    }
    goto LABEL_35;
  }
  int v5 = 0;
  char v6 = "AS";
  int v7 = "inherit";
  int v25 = v4;
  while (1)
  {
    uint64_t v8 = (CONF_VALUE *)sk_value(a3, v5);
    if (name_cmp(v8->name, v6))
    {
      if (name_cmp(v8->name, "RDI"))
      {
        int v22 = 115;
        int v23 = 812;
        goto LABEL_34;
      }
      int v9 = 1;
    }
    else
    {
      int v9 = 0;
    }
    value = v8->value;
    if (!strcmp(value, v7))
    {
      if (X509v3_asid_add_inherit((uint64_t)v4, v9)) {
        goto LABEL_23;
      }
      int v22 = 165;
      int v23 = 823;
LABEL_34:
      ERR_put_error(34, 4095, v22, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_asid.c", v23);
      ERR_asprintf_error_data("section:%s,name:%s,value:%s", v8->section, v8->name, v8->value);
      goto LABEL_35;
    }
    int v11 = strspn(value, "0123456789");
    int v12 = &value[v11];
    if (!*v12)
    {
      if (X509V3_get_value_int(v8, &x))
      {
        BOOL v19 = 0;
        goto LABEL_21;
      }
      ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_asid.c", 857);
LABEL_35:
      BOOL v19 = 0;
      goto LABEL_39;
    }
    uint64_t v13 = strspn(v12, " \t") + v11;
    if (value[(int)v13] != 45)
    {
      int v22 = 162;
      int v23 = 838;
      goto LABEL_34;
    }
    unsigned int v14 = v6;
    BOOL v15 = v7;
    size_t v16 = strspn(&value[((v13 << 32) + 0x100000000) >> 32], " \t") + (((v13 << 32) + 0x100000000) >> 32);
    if (value[(int)(v16 + strspn(&value[(int)v16], "0123456789"))])
    {
      ERR_put_error(34, 4095, 163, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_asid.c", 846);
      ERR_asprintf_error_data("section:%s,name:%s,value:%s", v8->section, v8->name, v8->value);
LABEL_32:
      BOOL v19 = 0;
      goto LABEL_38;
    }
    unsigned __int8 v17 = strdup(value);
    if (!v17)
    {
      ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_asid.c", 863);
      goto LABEL_32;
    }
    int v18 = v17;
    v17[v11] = 0;
    x = s2i_ASN1_INTEGER(0, v17);
    BOOL v19 = s2i_ASN1_INTEGER(0, &v18[(int)v16]);
    free(v18);
    if (!x || !v19)
    {
      int v20 = 65;
      int v21 = 871;
      goto LABEL_37;
    }
    if (ASN1_INTEGER_cmp(x, v19) >= 1) {
      break;
    }
    int v7 = v15;
    char v6 = v14;
    int v4 = v25;
LABEL_21:
    if (!X509v3_asid_add_id_or_range((ASN1_VALUE *)v4, v9, (uint64_t)x, (uint64_t)v19))
    {
      ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_asid.c", 880);
      goto LABEL_39;
    }
    x = 0;
LABEL_23:
    if (++v5 >= sk_num(a3)) {
      goto LABEL_24;
    }
  }
  int v20 = 116;
  int v21 = 875;
LABEL_37:
  ERR_put_error(34, 4095, v20, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_asid.c", v21);
LABEL_38:
  int v4 = v25;
LABEL_39:
  ASN1_item_free((ASN1_VALUE *)v4, &ASIdentifiers_it);
  ASN1_INTEGER_free(x);
  ASN1_INTEGER_free(v19);
  return 0;
}

char *i2r_ASIdentifiers(uint64_t a1, uint64_t *a2, BIO *a3, int a4)
{
  uint64_t result = i2r_ASIdentifierChoice(a3, *a2, a4, "Autonomous System Numbers");
  if (result) {
    return (char *)(i2r_ASIdentifierChoice(a3, a2[1], a4, "Routing Domain Identifiers") != 0);
  }
  return result;
}

void *X509v3_asid_inherits(void *result)
{
  if (result) {
    return (void *)(*result && !*(_DWORD *)*result || (uint64_t v1 = (_DWORD *)result[1]) != 0 && !*v1);
  }
  return result;
}

uint64_t X509v3_asid_subset(uint64_t *a1, uint64_t *a2)
{
  uint64_t result = 1;
  if (a1 && a1 != a2)
  {
    if (a2)
    {
      uint64_t v5 = *a1;
      if (!*a1 || *(_DWORD *)v5)
      {
        uint64_t v6 = a1[1];
        if (!v6 || *(_DWORD *)v6)
        {
          uint64_t v7 = *a2;
          if (!*a2 || *(_DWORD *)v7)
          {
            uint64_t v8 = (_DWORD *)a2[1];
            if (!v8 || *v8)
            {
              if (!v5)
              {
LABEL_16:
                if (!v6) {
                  return 1;
                }
                uint64_t v9 = a2[1];
                if (v9)
                {
                  uint64_t result = asid_contains(*(STACK **)(v9 + 8), *(STACK **)(v6 + 8));
                  if (!result) {
                    return result;
                  }
                  return 1;
                }
                return 0;
              }
              if (v7)
              {
                uint64_t result = asid_contains(*(STACK **)(v7 + 8), *(STACK **)(v5 + 8));
                if (!result) {
                  return result;
                }
                uint64_t v6 = a1[1];
                goto LABEL_16;
              }
            }
          }
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t asid_contains(STACK *a1, STACK *a2)
{
  uint64_t result = 1;
  if (a2 && a1 != a2)
  {
    if (!a1) {
      return 0;
    }
    if (sk_num(a2) >= 1)
    {
      int v5 = 0;
      int v6 = 0;
LABEL_6:
      uint64_t v7 = sk_value(a2, v5);
      if (*(_DWORD *)v7 == 1)
      {
        uint64_t v8 = (ASN1_INTEGER **)*((void *)v7 + 1);
        uint64_t v9 = v8 + 1;
LABEL_10:
        BOOL v10 = *v8;
        int v11 = *v9;
        while (v6 < sk_num(a1))
        {
          int v12 = sk_value(a1, v6);
          if (*(_DWORD *)v12 == 1)
          {
            uint64_t v13 = (ASN1_INTEGER **)*((void *)v12 + 1);
            unsigned int v14 = v13 + 1;
          }
          else
          {
            if (*(_DWORD *)v12) {
              return 0;
            }
            uint64_t v13 = (ASN1_INTEGER **)(v12 + 8);
            unsigned int v14 = (ASN1_INTEGER **)(v12 + 8);
          }
          BOOL v15 = *v13;
          if ((ASN1_INTEGER_cmp(*v14, v11) & 0x80000000) == 0)
          {
            if (ASN1_INTEGER_cmp(v15, v10) > 0) {
              return 0;
            }
            ++v5;
            int v16 = sk_num(a2);
            uint64_t result = 1;
            if (v5 < v16) {
              goto LABEL_6;
            }
            return result;
          }
          ++v6;
        }
        return 0;
      }
      if (!*(_DWORD *)v7)
      {
        uint64_t v8 = (ASN1_INTEGER **)(v7 + 8);
        uint64_t v9 = (ASN1_INTEGER **)(v7 + 8);
        goto LABEL_10;
      }
      return 0;
    }
    return 1;
  }
  return result;
}

uint64_t X509v3_asid_validate_path(uint64_t a1)
{
  if (sk_num(*(const STACK **)(a1 + 160)) >= 1 && *(void *)(a1 + 64))
  {
    int v2 = *(STACK **)(a1 + 160);
    return asid_validate_path_internal(a1, v2, 0);
  }
  else
  {
    *(_DWORD *)(a1 + 176) = 1;
    return 0;
  }
}

uint64_t asid_validate_path_internal(uint64_t a1, STACK *a2, uint64_t *a3)
{
  if (sk_num(a2) < 1)
  {
LABEL_86:
    if (!a1) {
      return 0;
    }
    goto LABEL_87;
  }
  if (!(a1 | (unint64_t)a3)) {
    return 0;
  }
  if (a1 && !*(void *)(a1 + 64))
  {
LABEL_87:
    uint64_t result = 0;
    *(_DWORD *)(a1 + 176) = 1;
    return result;
  }
  if (a3)
  {
    if (X509v3_asid_is_canonical(a3))
    {
      int v6 = 0;
      uint64_t v7 = 0;
      uint64_t v8 = 1;
    }
    else
    {
      if (!a1) {
        return 0;
      }
      *(void *)(a1 + 172) = 0x29FFFFFFFFLL;
      *(void *)(a1 + 184) = 0;
      uint64_t v10 = (*(uint64_t (**)(void, uint64_t))(a1 + 64))(0, a1);
      int v6 = 0;
      if (!v10) {
        return 0;
      }
      uint64_t v8 = v10;
      uint64_t v7 = 0;
    }
LABEL_14:
    uint64_t v11 = *a3;
    if (*a3)
    {
      if (*(_DWORD *)v11 == 1)
      {
        int v13 = 0;
        int v12 = *(STACK **)(v11 + 8);
LABEL_21:
        uint64_t v14 = a3[1];
        if (v14)
        {
          if (*(_DWORD *)v14 == 1)
          {
            int v16 = 0;
            BOOL v15 = *(STACK **)(v14 + 8);
LABEL_27:
            if (v6 < sk_num(a2))
            {
              while (1)
              {
                uint64_t v7 = sk_value(a2, v6);
                if ((X509_get_extension_flags((uint64_t)v7) & 0x80) != 0)
                {
                  if (!a1) {
                    return 0;
                  }
                  *(_DWORD *)(a1 + 172) = v6;
                  *(_DWORD *)(a1 + 176) = 41;
                  *(void *)(a1 + 184) = v7;
                  uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 64))(0, a1);
                  uint64_t v8 = result;
                  if (!result) {
                    return result;
                  }
                }
                unsigned __int8 v17 = (uint64_t *)*((void *)v7 + 17);
                if (!v17)
                {
                  if ((unint64_t)v12 | (unint64_t)v15)
                  {
                    if (!a1) {
                      return 0;
                    }
                    *(_DWORD *)(a1 + 172) = v6;
                    *(_DWORD *)(a1 + 176) = 46;
                    *(void *)(a1 + 184) = v7;
                    uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 64))(0, a1);
                    uint64_t v8 = result;
                    if (!result) {
                      return result;
                    }
                  }
                  else
                  {
                    int v12 = 0;
                    BOOL v15 = 0;
                  }
                  goto LABEL_63;
                }
                uint64_t v18 = *v17;
                if (*v17) {
                  BOOL v19 = 1;
                }
                else {
                  BOOL v19 = v12 == 0;
                }
                if (!v19)
                {
                  if (!a1) {
                    return 0;
                  }
                  *(_DWORD *)(a1 + 172) = v6;
                  *(_DWORD *)(a1 + 176) = 46;
                  *(void *)(a1 + 184) = v7;
                  uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 64))(0, a1);
                  if (!result) {
                    return result;
                  }
                  uint64_t v8 = result;
                  int v12 = 0;
                  int v13 = 0;
                  unsigned __int8 v17 = (uint64_t *)*((void *)v7 + 17);
                  uint64_t v18 = *v17;
                }
                if (v18 && *(_DWORD *)v18 == 1)
                {
                  if (!v13)
                  {
                    if (!asid_contains(*(STACK **)(v18 + 8), v12))
                    {
                      if (!a1) {
                        return 0;
                      }
                      *(_DWORD *)(a1 + 172) = v6;
                      *(_DWORD *)(a1 + 176) = 46;
                      *(void *)(a1 + 184) = v7;
                      uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 64))(0, a1);
                      if (!result) {
                        return result;
                      }
                      uint64_t v8 = result;
                      int v13 = 0;
                      uint64_t v20 = *(void *)(*((void *)v7 + 17) + 8);
                      if (v20 || !v15) {
                        goto LABEL_52;
                      }
                      goto LABEL_50;
                    }
                    unsigned __int8 v17 = (uint64_t *)*((void *)v7 + 17);
                    uint64_t v18 = *v17;
                  }
                  int v13 = 0;
                  int v12 = *(STACK **)(v18 + 8);
                }
                uint64_t v20 = v17[1];
                if (v20) {
                  BOOL v21 = 1;
                }
                else {
                  BOOL v21 = v15 == 0;
                }
                if (!v21)
                {
                  if (!a1) {
                    return 0;
                  }
LABEL_50:
                  *(_DWORD *)(a1 + 172) = v6;
                  *(_DWORD *)(a1 + 176) = 46;
                  *(void *)(a1 + 184) = v7;
                  uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 64))(0, a1);
                  if (!result) {
                    return result;
                  }
                  uint64_t v8 = result;
                  BOOL v15 = 0;
                  int v16 = 0;
                  uint64_t v20 = *(void *)(*((void *)v7 + 17) + 8);
                }
LABEL_52:
                if (!v20 || *(_DWORD *)v20 != 1) {
                  goto LABEL_63;
                }
                if (v16) {
                  goto LABEL_57;
                }
                if (asid_contains(*(STACK **)(v20 + 8), v15))
                {
                  uint64_t v20 = *(void *)(*((void *)v7 + 17) + 8);
LABEL_57:
                  int v16 = 0;
                  BOOL v15 = *(STACK **)(v20 + 8);
                  goto LABEL_63;
                }
                if (!a1) {
                  return 0;
                }
                *(_DWORD *)(a1 + 172) = v6;
                *(_DWORD *)(a1 + 176) = 46;
                *(void *)(a1 + 184) = v7;
                uint64_t v8 = (*(uint64_t (**)(void, uint64_t))(a1 + 64))(0, a1);
                int v16 = 0;
                uint64_t result = 0;
                if (!v8) {
                  return result;
                }
LABEL_63:
                if (++v6 >= sk_num(a2)) {
                  goto LABEL_74;
                }
              }
            }
            if (v7)
            {
LABEL_74:
              int v22 = (void *)*((void *)v7 + 17);
              if (!v22) {
                return v8;
              }
              if (!*v22 || *(_DWORD *)*v22)
              {
LABEL_77:
                int v23 = (int *)v22[1];
                if (v23)
                {
                  int v24 = *v23;
                  if (v24) {
                    uint64_t result = v8;
                  }
                  else {
                    uint64_t result = 0;
                  }
                  if (a1 && !v24)
                  {
                    *(_DWORD *)(a1 + 172) = v6;
                    *(_DWORD *)(a1 + 176) = 46;
                    *(void *)(a1 + 184) = v7;
                    int v25 = *(uint64_t (**)(void, uint64_t))(a1 + 64);
                    return v25(0, a1);
                  }
                  return result;
                }
                return v8;
              }
              if (a1)
              {
                *(_DWORD *)(a1 + 172) = v6;
                *(_DWORD *)(a1 + 176) = 46;
                *(void *)(a1 + 184) = v7;
                uint64_t result = (*(uint64_t (**)(void, uint64_t))(a1 + 64))(0, a1);
                if (!result) {
                  return result;
                }
                uint64_t v8 = result;
                int v22 = (void *)*((void *)v7 + 17);
                goto LABEL_77;
              }
              return 0;
            }
            goto LABEL_86;
          }
          if (!*(_DWORD *)v14)
          {
            BOOL v15 = 0;
            int v16 = 1;
            goto LABEL_27;
          }
        }
        BOOL v15 = 0;
        int v16 = 0;
        goto LABEL_27;
      }
      if (!*(_DWORD *)v11)
      {
        int v12 = 0;
        int v13 = 1;
        goto LABEL_21;
      }
    }
    int v12 = 0;
    int v13 = 0;
    goto LABEL_21;
  }
  uint64_t v7 = sk_value(a2, 0);
  if ((X509_get_extension_flags((uint64_t)v7) & 0x80) != 0) {
    return 1;
  }
  a3 = (uint64_t *)*((void *)v7 + 17);
  int v6 = 1;
  uint64_t v8 = 1;
  uint64_t result = 1;
  if (a3) {
    goto LABEL_14;
  }
  return result;
}

uint64_t X509v3_asid_validate_resource_set(STACK *a1, uint64_t *a2, int a3)
{
  if (!a2) {
    return 1;
  }
  if (sk_num(a1) < 1) {
    return 0;
  }
  if (!a3)
  {
    if (*a2 && !*(_DWORD *)*a2) {
      return 0;
    }
    uint64_t v7 = (_DWORD *)a2[1];
    if (v7)
    {
      if (!*v7) {
        return 0;
      }
    }
  }
  return asid_validate_path_internal(0, a1, a2);
}

char *i2r_ASIdentifierChoice(BIO *a1, uint64_t a2, int a3, const char *a4)
{
  if (!a2) {
    return (char *)1;
  }
  BIO_printf(a1, "%*s%s:\n", a3, "", a4);
  if (*(_DWORD *)a2)
  {
    if (*(_DWORD *)a2 != 1) {
      return 0;
    }
    if (sk_num(*(const STACK **)(a2 + 8)) >= 1)
    {
      for (int i = 0; i < sk_num(*(const STACK **)(a2 + 8)); ++i)
      {
        uint64_t v8 = sk_value(*(const STACK **)(a2 + 8), i);
        uint64_t v9 = v8;
        if (*(_DWORD *)v8 == 1)
        {
          uint64_t result = i2s_ASN1_INTEGER(0, **((ASN1_INTEGER ***)v8 + 1));
          if (!result) {
            return result;
          }
          int v12 = result;
          BIO_printf(a1, "%*s%s-", a3 + 2, "", result);
          free(v12);
          uint64_t result = i2s_ASN1_INTEGER(0, *(ASN1_INTEGER **)(*((void *)v9 + 1) + 8));
          if (!result) {
            return result;
          }
          uint64_t v11 = result;
          BIO_printf(a1, "%s\n");
        }
        else
        {
          if (*(_DWORD *)v8) {
            return 0;
          }
          uint64_t result = i2s_ASN1_INTEGER(0, *((ASN1_INTEGER **)v8 + 1));
          if (!result) {
            return result;
          }
          uint64_t v11 = result;
          BIO_printf(a1, "%*s%s\n");
        }
        free(v11);
      }
    }
  }
  else
  {
    BIO_printf(a1, "%*sinherit\n", a3 + 2, "");
  }
  return (char *)1;
}

void BF_cfb64_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, const BF_KEY *schedule, unsigned __int8 *ivec, int *num, int enc)
{
  uint64_t v10 = length;
  uint64_t v24 = *MEMORY[0x263EF8340];
  int v13 = *num;
  if (enc)
  {
    if (length)
    {
      do
      {
        if (!v13)
        {
          unsigned int v14 = bswap32(*((_DWORD *)ivec + 1));
          unsigned int v22 = bswap32(*(_DWORD *)ivec);
          unsigned int v23 = v14;
          BF_encrypt(&v22, schedule);
          unsigned int v15 = bswap32(v23);
          *(_DWORD *)ivec = bswap32(v22);
          *((_DWORD *)ivec + 1) = v15;
        }
        char v16 = *in++;
        unsigned __int8 v17 = ivec[v13];
        *out++ = v17 ^ v16;
        ivec[v13] = v17 ^ v16;
        int v13 = (v13 + 1) & 7;
        --v10;
      }
      while (v10);
    }
  }
  else if (length)
  {
    do
    {
      if (!v13)
      {
        unsigned int v18 = bswap32(*((_DWORD *)ivec + 1));
        unsigned int v22 = bswap32(*(_DWORD *)ivec);
        unsigned int v23 = v18;
        BF_encrypt(&v22, schedule);
        unsigned int v19 = bswap32(v23);
        *(_DWORD *)ivec = bswap32(v22);
        *((_DWORD *)ivec + 1) = v19;
      }
      unsigned __int8 v20 = *in++;
      unsigned __int8 v21 = ivec[v13];
      ivec[v13] = v20;
      *out++ = v21 ^ v20;
      int v13 = (v13 + 1) & 7;
      --v10;
    }
    while (v10);
  }
  *num = v13;
}

char *__cdecl i2s_ASN1_OCTET_STRING(X509V3_EXT_METHOD *method, ASN1_OCTET_STRING *ia5)
{
  return hex_to_string(ia5->data, ia5->length);
}

ASN1_OCTET_STRING *s2i_skey_id(int a1, uint64_t a2, char *__s1)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  int v5 = (X509V3_EXT_METHOD *)strcmp(__s1, "hash");
  if (!v5)
  {
    uint64_t v8 = ASN1_OCTET_STRING_new();
    if (!v8)
    {
      ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_skey.c", 129);
      return v8;
    }
    unsigned int size = 0;
    if (a2)
    {
      if (*(_DWORD *)a2 == 1) {
        return v8;
      }
      uint64_t v9 = *(void **)(a2 + 24);
      if (v9)
      {
        uint64_t v10 = *v9 + 40;
        goto LABEL_13;
      }
      uint64_t v11 = *(void **)(a2 + 16);
      if (v11)
      {
        uint64_t v10 = *v11 + 48;
LABEL_13:
        int v12 = *(int **)(*(void *)v10 + 8);
        if (!v12)
        {
          int v16 = 114;
          int v17 = 147;
          goto LABEL_18;
        }
        int v13 = (const void *)*((void *)v12 + 1);
        size_t v14 = *v12;
        unsigned int v15 = EVP_sha1();
        if (!EVP_Digest(v13, v14, md, &size, v15, 0))
        {
LABEL_19:
          ASN1_OCTET_STRING_free(v8);
          return 0;
        }
        if (!ASN1_STRING_set(v8, md, size))
        {
          int v16 = 65;
          int v17 = 156;
LABEL_18:
          ERR_put_error(34, 4095, v16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_skey.c", v17);
          goto LABEL_19;
        }
        return v8;
      }
    }
    int v16 = 114;
    int v17 = 137;
    goto LABEL_18;
  }
  return s2i_ASN1_OCTET_STRING(v5, v6, __s1);
}

ASN1_OCTET_STRING *__cdecl s2i_ASN1_OCTET_STRING(X509V3_EXT_METHOD *method, X509V3_CTX *ctx, char *str)
{
  int v4 = ASN1_OCTET_STRING_new();
  if (v4)
  {
    leint n = 0;
    int v5 = string_to_hex(str, &len);
    v4->unsigned int data = v5;
    if (v5)
    {
      v4->int length = len;
    }
    else
    {
      ASN1_OCTET_STRING_free(v4);
      return 0;
    }
  }
  else
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_skey.c", 102);
  }
  return v4;
}

uint64_t WHIRLPOOL_Init(uint64_t a1)
{
  *(void *)(a1 + 160) = 0;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return 1;
}

uint64_t WHIRLPOOL_Update(uint64_t a1, unsigned __int8 *__src, unint64_t a3)
{
  for (unint64_t i = a3; i >> 60; __src += 0x1000000000000000)
  {
    WHIRLPOOL_BitUpdate(a1, __src, 0x8000000000000000);
    i -= 0x1000000000000000;
  }
  if (i) {
    WHIRLPOOL_BitUpdate(a1, __src, 8 * i);
  }
  return 1;
}

uint64_t WHIRLPOOL_BitUpdate(uint64_t result, unsigned __int8 *__src, unint64_t a3)
{
  unint64_t v3 = a3;
  uint64_t v5 = result;
  unsigned int v6 = *(_DWORD *)(result + 128);
  uint64_t v7 = v6 & 7;
  int v8 = -(int)a3 & 7;
  uint64_t v9 = *(void *)(result + 136);
  *(void *)(result + 136) = v9 + a3;
  if (__CFADD__(v9, a3))
  {
    uint64_t v10 = 18;
    do
    {
      uint64_t v11 = *(void *)(result + 8 * v10);
      uint64_t v12 = v11 + 1;
      BOOL v13 = v11 == -1;
      *(void *)(result + 8 * v10) = v12;
      if ((unint64_t)(v10 - 17) > 2) {
        break;
      }
      ++v10;
    }
    while (v13);
  }
  if (v8 | v7)
  {
    if (a3)
    {
      int v26 = (void *)(result + 64);
      uint64_t v14 = 8 - v7;
      do
      {
        unsigned int v15 = v6 >> 3;
        if (v7 == v8)
        {
          char v21 = *__src++;
          *(unsigned char *)(v5 + v15 + 64) |= v21 & (0xFFu >> v7);
          v6 += v14;
          v3 -= v14;
          if (v6 == 512)
          {
            uint64_t result = whirlpool_block((uint64_t *)v5, v26, 1);
            unsigned int v6 = 0;
          }
          *(_DWORD *)(v5 + 128) = v6;
          goto LABEL_32;
        }
        int v16 = *__src << v8;
        unint64_t v17 = v3 - 8;
        if (v3 < 8)
        {
          uint64_t v19 = v5 + v15;
          if (v7) {
            *(unsigned char *)(v19 + 64) |= (*__src << v8) >> v7;
          }
          else {
            *(unsigned char *)(v19 + 64) = v16;
          }
          v6 += v3;
          if (v6 == 512)
          {
            uint64_t result = whirlpool_block((uint64_t *)v5, v26, 1);
            unsigned int v6 = 0;
            unsigned int v20 = 0;
          }
          else
          {
            unsigned int v20 = v15 + 1;
          }
          unint64_t v17 = 0;
          unint64_t v3 = 0;
          if (!v7) {
            goto LABEL_27;
          }
        }
        else
        {
          unsigned int v18 = *++__src;
          v16 |= v18 >> (8 - v8);
          if (v7) {
            *(unsigned char *)(v5 + v15 + 64) |= v16 >> v7;
          }
          else {
            *(unsigned char *)(v5 + v15 + 64) = v16;
          }
          v6 += 8;
          if (v6 < 0x200)
          {
            unsigned int v20 = v15 + 1;
          }
          else
          {
            uint64_t result = whirlpool_block((uint64_t *)v5, v26, 1);
            unsigned int v20 = 0;
            v6 &= 0x1FFu;
          }
          v3 -= 8;
          if (!v7) {
            goto LABEL_27;
          }
        }
        *(unsigned char *)(v5 + v20 + 64) = v16 << v14;
        unint64_t v3 = v17;
LABEL_27:
        *(_DWORD *)(v5 + 128) = v6;
      }
      while (v3);
    }
  }
  else
  {
LABEL_32:
    while (v3)
    {
      if (v3 < 0x200 || v6)
      {
        unint64_t v22 = 512 - v6;
        unsigned int v23 = (void *)(v5 + 64 + (v6 >> 3));
        unint64_t v24 = v3 - v22;
        if (v3 >= v22)
        {
          size_t v25 = v22 >> 3;
          memcpy(v23, __src, v25);
          __src += v25;
          uint64_t result = whirlpool_block((uint64_t *)v5, (void *)(v5 + 64), 1);
          unsigned int v6 = 0;
          unint64_t v3 = v24;
        }
        else
        {
          uint64_t result = (uint64_t)memcpy(v23, __src, v3 >> 3);
          v6 += v3;
          unint64_t v3 = 0;
        }
        *(_DWORD *)(v5 + 128) = v6;
      }
      else
      {
        uint64_t result = whirlpool_block((uint64_t *)v5, __src, v3 >> 9);
        __src += 64 * (v3 >> 9);
        v3 &= 0x1FFu;
      }
    }
  }
  return result;
}

uint64_t WHIRLPOOL_Final(_OWORD *a1, long long *a2)
{
  unint64_t v4 = *((unsigned int *)a2 + 32);
  unint64_t v5 = v4 >> 3;
  if ((v4 & 7) != 0) {
    *((unsigned char *)a2 + v5 + 64) |= 0x80u >> (v4 & 7);
  }
  else {
    *((unsigned char *)a2 + v5 + 64) = 0x80;
  }
  unsigned int v6 = v5 + 1;
  if (v4 >= 0x100)
  {
    if (v4 <= 0x1F7) {
      bzero((char *)a2 + v6 + 64, (63 - v5));
    }
    whirlpool_block((uint64_t *)a2, (void *)a2 + 8, 1);
    unsigned int v6 = 0;
    goto LABEL_9;
  }
  if (v4 <= 0xF7) {
LABEL_9:
  }
    bzero((char *)a2 + v6 + 64, 32 - v6);
  uint64_t v7 = 0;
  uint64_t v8 = (uint64_t)a2 + 127;
  do
  {
    uint64_t v9 = 0;
    unint64_t v10 = *((void *)a2 + v7 + 17);
    do
    {
      *(unsigned char *)(v8 + v9) = v10;
      v10 >>= 8;
      --v9;
    }
    while (v9 != -8);
    ++v7;
    v8 -= 8;
  }
  while (v7 != 4);
  whirlpool_block((uint64_t *)a2, (void *)a2 + 8, 1);
  if (!a1) {
    return 0;
  }
  long long v11 = *a2;
  long long v12 = a2[1];
  long long v13 = a2[3];
  a1[2] = a2[2];
  a1[3] = v13;
  *a1 = v11;
  a1[1] = v12;
  a2[2] = 0u;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[5] = 0u;
  a2[6] = 0u;
  a2[7] = 0u;
  a2[8] = 0u;
  a2[9] = 0u;
  *((void *)a2 + 20) = 0;
  uint64_t result = 1;
  *a2 = 0u;
  a2[1] = 0u;
  return result;
}

_OWORD *WHIRLPOOL(unsigned __int8 *__src, unint64_t a2, _OWORD *a3)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  memset(&v5[8], 0, 32);
  if (a3) {
    unint64_t v3 = a3;
  }
  else {
    unint64_t v3 = &WHIRLPOOL_m;
  }
  memset(v5, 0, 128);
  WHIRLPOOL_Update((uint64_t)v5, __src, a2);
  WHIRLPOOL_Final(v3, v5);
  return v3;
}

int X509V3_EXT_add(X509V3_EXT_METHOD *ext)
{
  int v2 = (STACK *)ext_list;
  if (ext_list
    || (int v2 = sk_new((int (__cdecl *)(const char *const *, const char *const *))ext_cmp), (ext_list = (uint64_t)v2) != 0))
  {
    if (sk_push(v2, (char *)ext)) {
      return 1;
    }
    int v4 = 159;
  }
  else
  {
    int v4 = 155;
  }
  ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_lib.c", v4);
  return 0;
}

uint64_t ext_cmp(_DWORD **a1, _DWORD **a2)
{
  return (**a1 - **a2);
}

X509V3_EXT_METHOD *__cdecl X509V3_EXT_get_nid(int nid)
{
  *(void *)uint64_t key = data;
  if (nid < 0) {
    return 0;
  }
  uint64_t v11 = 0;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  *(_OWORD *)unsigned int data = 0u;
  long long v6 = 0u;
  *(_DWORD *)unsigned int data = nid;
  uint64_t v1 = (X509V3_EXT_METHOD **)OBJ_bsearch_(key, (const char *)&standard_exts, 40, 8, (int (__cdecl *)(const void *, const void *))ext_cmp_BSEARCH_CMP_FN);
  if (v1) {
    return *v1;
  }
  uint64_t result = (X509V3_EXT_METHOD *)ext_list;
  if (ext_list)
  {
    int v3 = sk_find((STACK *)ext_list, data);
    if (v3 != -1) {
      return (X509V3_EXT_METHOD *)sk_value((const STACK *)ext_list, v3);
    }
    return 0;
  }
  return result;
}

X509V3_EXT_METHOD *__cdecl X509V3_EXT_get(X509_EXTENSION *ext)
{
  int v1 = OBJ_obj2nid(ext->object);
  if (!v1) {
    return 0;
  }
  return X509V3_EXT_get_nid(v1);
}

int X509V3_EXT_add_list(X509V3_EXT_METHOD *extlist)
{
  if (extlist->ext_nid == -1) {
    return 1;
  }
  for (unint64_t i = extlist; ; ++i)
  {
    int result = X509V3_EXT_add(i);
    if (!result) {
      break;
    }
    ext_nichar d = i[1].ext_nid;
    if (ext_nid == -1) {
      return 1;
    }
  }
  return result;
}

int X509V3_EXT_add_alias(int nid_to, int nid_from)
{
  nichar d = X509V3_EXT_get_nid(nid_from);
  if (!nid)
  {
    int v14 = 102;
    int v15 = 232;
LABEL_7:
    ERR_put_error(34, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_lib.c", v15);
    return 0;
  }
  int v4 = nid;
  unint64_t v5 = (X509V3_EXT_METHOD *)malloc_type_malloc(0x68uLL, 0x10E0040B735ED96uLL);
  if (!v5)
  {
    int v14 = 65;
    int v15 = 236;
    goto LABEL_7;
  }
  long long v6 = v5;
  long long v7 = *(_OWORD *)&v4->d2i;
  long long v8 = *(_OWORD *)&v4->ext_nid;
  *(_OWORD *)&v5->ext_new = *(_OWORD *)&v4->ext_new;
  *(_OWORD *)&v5->d2unint64_t i = v7;
  *(_OWORD *)&v5->ext_nichar d = v8;
  long long v9 = *(_OWORD *)&v4->i2s;
  long long v10 = *(_OWORD *)&v4->i2v;
  long long v11 = *(_OWORD *)&v4->i2r;
  v5->usr_unsigned int data = v4->usr_data;
  *(_OWORD *)&v5->i2v = v10;
  *(_OWORD *)&v5->i2r = v11;
  *(_OWORD *)&v5->i2s = v9;
  int v12 = v5->ext_flags | 1;
  v5->ext_nichar d = nid_to;
  v5->ext_flags = v12;
  if (X509V3_EXT_add(v5)) {
    return 1;
  }
  free(v6);
  return 0;
}

void X509V3_EXT_cleanup(void)
{
  ext_list = 0;
}

void ext_list_free(void *a1)
{
  if (*((unsigned char *)a1 + 4)) {
    free(a1);
  }
}

int X509V3_add_standard_extensions(void)
{
  return 1;
}

void *__cdecl X509V3_EXT_d2i(X509_EXTENSION *ext)
{
  int result = X509V3_EXT_get(ext);
  if (result)
  {
    value = ext->value;
    iint n = value->data;
    int v4 = (const ASN1_ITEM *)*((void *)result + 1);
    if (v4) {
      return ASN1_item_d2i(0, (const unsigned __int8 **)&in, value->length, v4);
    }
    else {
      return (void *)(*((uint64_t (**)(void, unsigned __int8 **, void))result + 4))(0, &in, value->length);
    }
  }
  return result;
}

void *__cdecl X509V3_get_d2i(STACK *x, int nid, int *crit, int *idx)
{
  if (x)
  {
    int v8 = idx ? *idx + 1 : 0;
    int v9 = v8 & ~(v8 >> 31);
    if (v9 < sk_num(x))
    {
      long long v10 = 0;
      while (1)
      {
        long long v11 = sk_value(x, v9);
        if (OBJ_obj2nid(*(const ASN1_OBJECT **)v11) == nid)
        {
          if (idx)
          {
            *idx = v9;
LABEL_21:
            if (crit) {
              *crit = X509_EXTENSION_get_critical((X509_EXTENSION *)v11);
            }
            return X509V3_EXT_d2i((X509_EXTENSION *)v11);
          }
          if (v10)
          {
            if (!crit) {
              return 0;
            }
            int v12 = -2;
LABEL_18:
            *crit = v12;
            return 0;
          }
        }
        else
        {
          long long v11 = v10;
        }
        ++v9;
        long long v10 = v11;
        if (v9 >= sk_num(x))
        {
          if (!v11) {
            break;
          }
          goto LABEL_21;
        }
      }
    }
  }
  if (idx) {
    *idx = -1;
  }
  if (crit)
  {
    int v12 = -1;
    goto LABEL_18;
  }
  return 0;
}

int X509V3_add1_i2d(STACK **x, int nid, void *value, int crit, unint64_t flags)
{
  unint64_t v9 = flags & 0xF;
  if (v9 == 1)
  {
LABEL_2:
    long long v10 = (char *)X509V3_EXT_i2d(nid, crit, value);
    if (v10)
    {
      long long v11 = *x;
      if (*x || (long long v11 = sk_new_null(), (*x = v11) != 0))
      {
        BOOL v12 = sk_push(v11, v10) == 0;
        goto LABEL_6;
      }
      return -1;
    }
    goto LABEL_24;
  }
  char v14 = flags;
  int ext_by_NID = X509v3_get_ext_by_NID(*x, nid, -1);
  if (ext_by_NID < 0)
  {
    int v18 = 102;
    if (v9 != 3 && v9 != 5) {
      goto LABEL_2;
    }
    if ((v14 & 0x10) != 0) {
      return 0;
    }
LABEL_21:
    int v19 = 433;
LABEL_25:
    ERR_put_error(34, 4095, v18, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_lib.c", v19);
    return 0;
  }
  if (!v9)
  {
    int v18 = 145;
    if ((v14 & 0x10) != 0) {
      return 0;
    }
    goto LABEL_21;
  }
  if (v9 == 4) {
    return 1;
  }
  int v16 = ext_by_NID;
  if (v9 == 5)
  {
    unint64_t v17 = sk_delete(*x, ext_by_NID);
    if (!v17) {
      return -1;
    }
    X509_EXTENSION_free((X509_EXTENSION *)v17);
    return 1;
  }
  unsigned int v20 = X509V3_EXT_i2d(nid, crit, value);
  if (!v20)
  {
LABEL_24:
    int v18 = 144;
    int v19 = 411;
    goto LABEL_25;
  }
  char v21 = (char *)v20;
  unint64_t v22 = sk_value(*x, v16);
  X509_EXTENSION_free((X509_EXTENSION *)v22);
  BOOL v12 = sk_set(*x, v16, v21) == 0;
LABEL_6:
  if (v12) {
    return -1;
  }
  else {
    return 1;
  }
}

uint64_t ext_cmp_BSEARCH_CMP_FN(_DWORD **a1, _DWORD **a2)
{
  return (**a1 - **a2);
}

int ASN1_parse(BIO *bp, const unsigned __int8 *pp, uint64_t len, int indent)
{
  unint64_t v5 = (unsigned __int8 *)pp;
  return asn1_parse2(bp, &v5, len, 0, 0, indent, 0);
}

uint64_t asn1_parse2(BIO *a1, unsigned __int8 **a2, uint64_t a3, int a4, int a5, unsigned int a6, uint64_t a7)
{
  uint64_t v72 = *MEMORY[0x263EF8340];
  puint64_t length = 0;
  iint n = 0;
  BIGNUM a = 0;
  *(void *)pclass = 0;
  unint64_t v9 = *a2;
  pp = *a2;
  if (a5 > 128)
  {
    BIO_printf(a1, "Max depth exceeded\n");
LABEL_3:
    uint64_t v10 = 0;
LABEL_4:
    long long v11 = 0;
    goto LABEL_5;
  }
  uint64_t v15 = a3;
  if (a3 < 1)
  {
    long long v11 = 0;
    BOOL v12 = 0;
    long long v13 = 0;
    uint64_t v10 = 1;
    goto LABEL_7;
  }
  uint64_t v16 = a7;
  uint64_t v64 = a4;
  if (a6) {
    int v17 = a5;
  }
  else {
    int v17 = 0;
  }
  int indent = v17;
  unsigned int v65 = a5 + 1;
  uint64_t v59 = (int)a7;
  unint64_t v62 = (unint64_t)&v9[a3];
  while (1)
  {
    int object = ASN1_get_object((const unsigned __int8 **)&pp, &plength, &pclass[1], pclass, v15);
    if ((object & 0x80) != 0)
    {
      BIO_write(a1, "Error in encoding\n", 18);
      goto LABEL_3;
    }
    int v19 = object;
    uint64_t v20 = v16;
    int v21 = (int)pp;
    if (BIO_printf(a1, "%5ld:", &v9[v64] - *a2) < 1) {
      goto LABEL_3;
    }
    int v22 = v21 - v9;
    int v23 = v19 == 33 ? BIO_printf(a1, "d=%-2d hl=%ld l=inf  ") : BIO_printf(a1, "d=%-2d hl=%ld l=%4ld ");
    if (v23 < 1) {
      goto LABEL_3;
    }
    int v24 = pclass[0];
    int v25 = pclass[1];
    int v26 = (v19 & 0x20) != 0 ? "cons: " : "prim: ";
    if (BIO_write(a1, v26, 6) < 6 || !BIO_indent(a1, indent, 128)) {
      goto LABEL_3;
    }
    if ((~v24 & 0xC0) != 0)
    {
      if ((v24 & 0x80) != 0)
      {
        int v27 = __str;
        snprintf(__str, 0x80uLL, "cont [ %d ]");
      }
      else if ((v24 & 0x40) != 0)
      {
        int v27 = __str;
        snprintf(__str, 0x80uLL, "appl [ %d ]");
      }
      else if (v25 < 31)
      {
        int v27 = ASN1_tag2str(v25);
      }
      else
      {
        int v27 = __str;
        snprintf(__str, 0x80uLL, "<ASN1 %d>");
      }
    }
    else
    {
      int v27 = __str;
      snprintf(__str, 0x80uLL, "priv [ %d ] ");
    }
    if (BIO_printf(a1, "%-18s", v27) <= 0) {
      goto LABEL_3;
    }
    uint64_t v28 = v15 - v22;
    if ((v19 & 0x20) == 0) {
      break;
    }
    unsigned int v31 = pp;
    uint64_t v32 = plength;
    if (BIO_write(a1, "\n", 1) < 1) {
      goto LABEL_3;
    }
    if (plength > v28)
    {
      BIO_printf(a1, "length is greater than %ld\n");
      goto LABEL_3;
    }
    unint64_t v33 = (unint64_t)&v31[v32];
    uint64_t v16 = v20;
    unint64_t v30 = v62;
    uint64_t v34 = v65;
    if (v19 != 33 || plength)
    {
      while (1)
      {
        unsigned int v29 = pp;
        if ((unint64_t)pp >= v33) {
          break;
        }
        if (!asn1_parse2(a1, &pp, v33 - (void)pp, (pp - *(_DWORD *)a2 + a4), v65, a6, v16))goto LABEL_3; {
      }
        }
    }
    else
    {
      unsigned int v29 = pp;
      while (1)
      {
        uint64_t v35 = asn1_parse2(a1, &pp, v62 - (void)v29, (v29 - *(_DWORD *)a2 + a4), v34, a6, v16);
        uint64_t v10 = v35;
        if (!v35) {
          goto LABEL_4;
        }
        if (v35 == 2) {
          break;
        }
        unsigned int v29 = pp;
        uint64_t v34 = v65;
        if ((unint64_t)pp >= v62) {
          goto LABEL_60;
        }
      }
      unsigned int v29 = pp;
LABEL_60:
      puint64_t length = (uint64_t)&v29[-v33];
    }
LABEL_61:
    long long v11 = 0;
    BOOL v12 = 0;
    long long v13 = 0;
    uint64_t v15 = v28 - plength;
    uint64_t v10 = 1;
    BOOL v38 = (unint64_t)v29 >= v30 || v9 >= v29;
    unint64_t v9 = v29;
    if (v38) {
      goto LABEL_7;
    }
  }
  if (pclass[0])
  {
    pp += plength;
    if (BIO_write(a1, "\n", 1) < 1) {
      goto LABEL_3;
    }
    uint64_t v16 = v20;
    unsigned int v29 = pp;
    unint64_t v30 = v62;
    goto LABEL_61;
  }
  uint64_t v16 = v20;
  switch(pclass[1])
  {
    case 1:
      if (plength == 1 && (unint64_t)pp < v62)
      {
        BIO_printf(a1, ":%u", *pp);
        goto LABEL_55;
      }
      unsigned int v53 = a1;
      unsigned int v54 = "Bad BOOLean\n";
      int v55 = 12;
      goto LABEL_126;
    case 2:
      iint n = v9;
      BOOL v12 = d2i_ASN1_INTEGER(0, (const unsigned __int8 **)&in, plength + v22);
      if (v12)
      {
        if (BIO_write(a1, ":", 1) < 1 || v12->type == 258 && BIO_write(a1, "-", 1) < 1) {
          goto LABEL_149;
        }
        LODWORD(length) = v12->length;
        if (v12->length >= 1)
        {
          uint64_t v40 = 0;
          do
          {
            if (BIO_printf(a1, "%02X", v12->data[v40]) < 1) {
              goto LABEL_149;
            }
            ++v40;
            uint64_t length = v12->length;
          }
          while (v40 < length);
          uint64_t v16 = v20;
        }
        if (!length && BIO_write(a1, "00", 2) < 1)
        {
LABEL_149:
          uint64_t v10 = 0;
          long long v11 = 0;
          goto LABEL_6;
        }
      }
      else if (BIO_write(a1, "BAD INTEGER", 11) < 1)
      {
        goto LABEL_3;
      }
      ASN1_INTEGER_free(v12);
      goto LABEL_55;
    case 4:
      iint n = v9;
      int v43 = d2i_ASN1_OCTET_STRING(0, (const unsigned __int8 **)&in, plength + v22);
      long long v11 = v43;
      if (!v43) {
        goto LABEL_106;
      }
      uint64_t v44 = v43->length;
      if ((int)v44 < 1) {
        goto LABEL_106;
      }
      unsigned int data = v43->data;
      iint n = data;
      uint64_t v16 = v20;
      break;
    case 6:
      iint n = v9;
      if (d2i_ASN1_OBJECT(&a, (const unsigned __int8 **)&in, plength + v22))
      {
        if (BIO_write(a1, ":", 1) < 1) {
          goto LABEL_3;
        }
        i2a_ASN1_OBJECT(a1, a);
      }
      else
      {
        unsigned int v53 = a1;
        unsigned int v54 = ":BAD OBJECT";
        int v55 = 11;
LABEL_126:
        if (BIO_write(v53, v54, v55) < 1) {
          goto LABEL_3;
        }
      }
      goto LABEL_55;
    case 0xA:
      iint n = v9;
      long long v13 = d2i_ASN1_ENUMERATED(0, (const unsigned __int8 **)&in, plength + v22);
      if (v13)
      {
        if (BIO_write(a1, ":", 1) < 1 || v13->type == 266 && BIO_write(a1, "-", 1) < 1) {
          goto LABEL_150;
        }
        LODWORD(v51) = v13->length;
        if (v13->length >= 1)
        {
          uint64_t v52 = 0;
          do
          {
            if (BIO_printf(a1, "%02X", v13->data[v52]) < 1) {
              goto LABEL_150;
            }
            ++v52;
            uint64_t v51 = v13->length;
          }
          while (v52 < v51);
          uint64_t v16 = v20;
        }
        if (!v51 && BIO_write(a1, "00", 2) < 1)
        {
LABEL_150:
          uint64_t v10 = 0;
          long long v11 = 0;
          BOOL v12 = 0;
          goto LABEL_7;
        }
      }
      else if (BIO_write(a1, "BAD ENUMERATED", 14) < 1)
      {
        goto LABEL_3;
      }
      ASN1_ENUMERATED_free(v13);
      goto LABEL_55;
    case 0xC:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x1A:
      if (BIO_write(a1, ":", 1) < 1) {
        goto LABEL_3;
      }
      if (plength >= 1)
      {
        int v36 = BIO_write(a1, pp, plength);
        if (v36 != plength) {
          goto LABEL_3;
        }
      }
      goto LABEL_55;
    case 0x1E:
      goto LABEL_55;
    default:
      if (!v20 || plength < 1) {
        goto LABEL_55;
      }
      if (BIO_write(a1, "\n", 1) < 1) {
        goto LABEL_3;
      }
      if (plength < v59 || v20 == -1) {
        int v42 = plength;
      }
      else {
        int v42 = v59;
      }
      int v37 = BIO_dump_indent(a1, (const char *)pp, v42, 6);
      goto LABEL_56;
  }
  while (2)
  {
    unsigned __int8 v46 = *data++;
    unsigned int v47 = v46;
    if (v46 > 0x1Fu)
    {
      if (v47 > 0x7E) {
        goto LABEL_130;
      }
LABEL_103:
      if (--v44) {
        continue;
      }
      if (BIO_write(a1, ":", 1) < 1 || BIO_write(a1, in, v11->length) < 1) {
        goto LABEL_151;
      }
LABEL_106:
      ASN1_OCTET_STRING_free(v11);
      uint64_t v16 = v20;
LABEL_55:
      int v37 = BIO_write(a1, "\n", 1);
LABEL_56:
      if (v37 < 1) {
        goto LABEL_3;
      }
LABEL_57:
      unsigned int v29 = &pp[plength];
      pp += plength;
      unint64_t v30 = v62;
      if (!*(void *)pclass)
      {
        long long v11 = 0;
        BOOL v12 = 0;
        long long v13 = 0;
        uint64_t v10 = 2;
        goto LABEL_7;
      }
      goto LABEL_61;
    }
    break;
  }
  BOOL v48 = v47 > 0xD;
  int v49 = (1 << v47) & 0x2600;
  if (!v48 && v49 != 0) {
    goto LABEL_103;
  }
LABEL_130:
  if (!v20)
  {
    if (BIO_write(a1, "[HEX DUMP]:", 11) < 1) {
      goto LABEL_151;
    }
    if (v11->length >= 1)
    {
      uint64_t v58 = 0;
      while (BIO_printf(a1, "%02X", in[v58]) >= 1)
      {
        if (++v58 >= v11->length) {
          goto LABEL_106;
        }
      }
      goto LABEL_151;
    }
    goto LABEL_106;
  }
  if (BIO_write(a1, "\n", 1) >= 1)
  {
    BOOL v56 = v11->length < (int)v20 || v20 == -1;
    int v57 = v56 ? v11->length : v20;
    if (BIO_dump_indent(a1, (const char *)in, v57, 6) >= 1)
    {
      ASN1_OCTET_STRING_free(v11);
      goto LABEL_57;
    }
  }
LABEL_151:
  uint64_t v10 = 0;
LABEL_5:
  BOOL v12 = 0;
LABEL_6:
  long long v13 = 0;
LABEL_7:
  if (a) {
    ASN1_OBJECT_free(a);
  }
  ASN1_OCTET_STRING_free(v11);
  ASN1_INTEGER_free(v12);
  ASN1_ENUMERATED_free(v13);
  *a2 = pp;
  return v10;
}

int ASN1_parse_dump(BIO *bp, const unsigned __int8 *pp, uint64_t len, int indent, int dump)
{
  long long v6 = (unsigned __int8 *)pp;
  return asn1_parse2(bp, &v6, len, 0, 0, indent, *(uint64_t *)&dump);
}

void ENGINE_unregister_RSA(ENGINE *e)
{
}

int ENGINE_register_RSA(ENGINE *e)
{
  if (*((void *)e + 2)) {
    return engine_table_register(&rsa_table, (uint64_t)engine_unregister_all_RSA, (char *)e, dummy_nid, 1, 0);
  }
  else {
    return 1;
  }
}

void engine_unregister_all_RSA()
{
}

void ENGINE_register_all_RSA(void)
{
  first = ENGINE_get_first();
  if (first)
  {
    next = first;
    do
    {
      if (*((void *)next + 2)) {
        engine_table_register(&rsa_table, (uint64_t)engine_unregister_all_RSA, (char *)next, dummy_nid, 1, 0);
      }
      next = ENGINE_get_next(next);
    }
    while (next);
  }
}

int ENGINE_set_default_RSA(ENGINE *e)
{
  if (*((void *)e + 2)) {
    return engine_table_register(&rsa_table, (uint64_t)engine_unregister_all_RSA, (char *)e, dummy_nid, 1, 1);
  }
  else {
    return 1;
  }
}

ENGINE *ENGINE_get_default_RSA(void)
{
  return (ENGINE *)engine_table_select(&rsa_table, 1);
}

const RSA_METHOD *__cdecl ENGINE_get_RSA(const ENGINE *e)
{
  return (const RSA_METHOD *)*((void *)e + 2);
}

int ENGINE_set_RSA(ENGINE *e, const RSA_METHOD *rsa_meth)
{
  *((void *)e + 2) = rsa_meth;
  return 1;
}

void *EVP_streebog256()
{
  return &streebog256_md;
}

void *EVP_streebog512()
{
  return &streebog512_md;
}

uint64_t streebog_init256(uint64_t a1)
{
  return STREEBOG256_Init(*(void *)(a1 + 24));
}

uint64_t streebog_update256(uint64_t a1, char *a2, size_t a3)
{
  return STREEBOG256_Update(*(_DWORD **)(a1 + 24), a2, a3);
}

uint64_t streebog_final256(uint64_t a1, uint64_t a2)
{
  return STREEBOG256_Final(a2, *(void *)(a1 + 24));
}

uint64_t streebog_init512(uint64_t a1)
{
  return STREEBOG512_Init(*(void *)(a1 + 24));
}

uint64_t streebog_update512(uint64_t a1, char *a2, size_t a3)
{
  return STREEBOG512_Update(*(_DWORD **)(a1 + 24), a2, a3);
}

uint64_t streebog_final512(uint64_t a1, uint64_t a2)
{
  return STREEBOG512_Final(a2, *(void *)(a1 + 24));
}

void *BIO_f_asn1()
{
  return &methods_asn1;
}

uint64_t BIO_asn1_set_prefix(BIO *a1, uint64_t a2, uint64_t a3)
{
  v4[0] = a2;
  v4[1] = a3;
  return BIO_ctrl(a1, 149, 0, v4);
}

uint64_t BIO_asn1_get_prefix(BIO *a1, void *a2, void *a3)
{
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t result = BIO_ctrl(a1, 150, 0, &v7);
  if ((int)result >= 1)
  {
    uint64_t v6 = v8;
    *a2 = v7;
    *a3 = v6;
  }
  return result;
}

uint64_t BIO_asn1_set_suffix(BIO *a1, uint64_t a2, uint64_t a3)
{
  v4[0] = a2;
  v4[1] = a3;
  return BIO_ctrl(a1, 151, 0, v4);
}

uint64_t BIO_asn1_get_suffix(BIO *a1, void *a2, void *a3)
{
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t result = BIO_ctrl(a1, 152, 0, &v7);
  if ((int)result >= 1)
  {
    uint64_t v6 = v8;
    *a2 = v7;
    *a3 = v6;
  }
  return result;
}

uint64_t asn1_bio_write(BIO *b, char *data, int length)
{
  uint64_t result = 0;
  if (data)
  {
    int v5 = length;
    if ((length & 0x80000000) == 0)
    {
      if (b->prev_bio)
      {
        next_bio = b->next_bio;
        if (next_bio)
        {
          uint64_t v7 = data;
          int v8 = 0;
          pp = 0;
          while (1)
          {
            switch(LODWORD(next_bio->method))
            {
              case 0:
                uint64_t result = asn1_bio_setup_ex(b, next_bio, *(unsigned int (**)(BIO *, _DWORD *, _DWORD *, _DWORD *))&next_bio->num, 1, 2);
                if (result) {
                  continue;
                }
                return result;
              case 1:
                int v9 = asn1_bio_flush_ex((uint64_t)b, (uint64_t)next_bio, (void (*)(uint64_t, uint64_t, int *, uint64_t))next_bio->ptr, 2);
                if (v9 >= 1) {
                  continue;
                }
                unsigned int v16 = v9;
                goto LABEL_30;
              case 2:
                int v10 = ASN1_object_size(0, v5, next_bio->retry_reason) - v5;
                if (v10 < 1 || v10 > SLODWORD(next_bio->cb_arg)) {
                  return 0xFFFFFFFFLL;
                }
                next_bio->init = v10;
                pp = (unsigned __int8 *)next_bio->callback;
                ASN1_put_object(&pp, 0, v5, next_bio->retry_reason, next_bio->flags);
                next_bio->shutdowint n = v5;
                LODWORD(next_bio->method) = 3;
                break;
              case 3:
                int v11 = BIO_write(b->prev_bio, (char *)next_bio->callback + SHIDWORD(next_bio->cb_arg), next_bio->init);
                unsigned int v16 = v11;
                if (v11 < 1) {
                  goto LABEL_30;
                }
                int v12 = next_bio->init - v11;
                next_bio->init = v12;
                if (v12)
                {
                  HIDWORD(next_bio->cb_arg) += v11;
                }
                else
                {
                  HIDWORD(next_bio->cb_arg) = 0;
                  LODWORD(next_bio->method) = 4;
                }
                continue;
              case 4:
                if (v5 >= next_bio->shutdown) {
                  shutdowint n = next_bio->shutdown;
                }
                else {
                  shutdowint n = v5;
                }
                int v14 = BIO_write(b->prev_bio, v7, shutdown);
                unsigned int v16 = v14;
                if (v14 >= 1)
                {
                  int v15 = next_bio->shutdown - v14;
                  next_bio->shutdowint n = v15;
                  if (!v15) {
                    LODWORD(next_bio->method) = 2;
                  }
                  v8 += v14;
                  v7 += v14;
                  v5 -= v14;
                  if (v5) {
                    continue;
                  }
                }
LABEL_30:
                BIO_clear_flags(b, 15);
                BIO_copy_next_retry(b);
                if (v8 <= 0) {
                  return v16;
                }
                else {
                  return v8;
                }
              default:
                BIO_clear_flags(b, 15);
                return 0;
            }
          }
        }
      }
      return 0;
    }
  }
  return result;
}

BIO *asn1_bio_read(uint64_t a1, void *a2, int a3)
{
  uint64_t result = *(BIO **)(a1 + 64);
  if (result) {
    return (BIO *)BIO_read(result, a2, a3);
  }
  return result;
}

uint64_t asn1_bio_puts(BIO *a1, char *__s)
{
  int v4 = strlen(__s);
  return asn1_bio_write(a1, __s, v4);
}

BIO *asn1_bio_gets(uint64_t a1, char *a2, int a3)
{
  uint64_t result = *(BIO **)(a1 + 64);
  if (result) {
    return (BIO *)BIO_gets(result, a2, a3);
  }
  return result;
}

uint64_t asn1_bio_ctrl(BIO *b, int a2, uint64_t larg, _OWORD *parg)
{
  next_bio = b->next_bio;
  if (!next_bio) {
    return 0;
  }
  switch(a2)
  {
    case 149:
      *(_OWORD *)&next_bio->num = *parg;
      return 1;
    case 150:
      long long v10 = *(_OWORD *)&next_bio->num;
      goto LABEL_17;
    case 151:
      *(_OWORD *)&next_bio->next_bio = *parg;
      return 1;
    case 152:
      long long v10 = *(_OWORD *)&next_bio->next_bio;
LABEL_17:
      *parg = v10;
      return 1;
    case 153:
      next_bio->num_write = (unint64_t)parg;
      return 1;
    case 154:
      *(void *)parg = next_bio->num_write;
      return 1;
    default:
      if (a2 == 11)
      {
        if (!b->prev_bio) {
          return 0;
        }
        methochar d = (int)next_bio->method;
        if (LODWORD(next_bio->method) == 2)
        {
          if (!asn1_bio_setup_ex(b, b->next_bio, next_bio->next_bio, 5, 6)) {
            return 0;
          }
          methochar d = (int)next_bio->method;
        }
        if (method == 5)
        {
          LODWORD(result) = asn1_bio_flush_ex((uint64_t)b, (uint64_t)next_bio, (void (*)(uint64_t, uint64_t, int *, uint64_t))next_bio->prev_bio, 6);
          if ((int)result < 1) {
            return (int)result;
          }
          methochar d = (int)next_bio->method;
        }
        if (method != 6)
        {
          BIO_clear_flags(b, 15);
          return 0;
        }
        uint64_t result = (uint64_t)b->prev_bio;
        a2 = 11;
      }
      else
      {
        uint64_t result = (uint64_t)b->prev_bio;
        if (!result) {
          return result;
        }
      }
      uint64_t result = BIO_ctrl((BIO *)result, a2, larg, parg);
      break;
  }
  return result;
}

uint64_t asn1_bio_new(uint64_t a1)
{
  uint64_t result = (uint64_t)malloc_type_calloc(1uLL, 0x60uLL, 0x109004097C5DC90uLL);
  if (result)
  {
    int v3 = (void *)result;
    int v4 = malloc_type_malloc(0x14uLL, 0x8883FF2DuLL);
    v3[1] = v4;
    if (v4)
    {
      *((_DWORD *)v3 + 4) = 20;
      v3[4] = 0x400000000;
      *(_DWORD *)int v3 = 0;
      uint64_t result = 1;
      *(_DWORD *)(a1 + 32) = 1;
      *(void *)(a1 + 56) = v3;
      *(_DWORD *)(a1 + 40) = 0;
    }
    else
    {
      free(v3);
      return 0;
    }
  }
  return result;
}

uint64_t asn1_bio_free(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  if (!v1) {
    return 0;
  }
  int v3 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v1 + 48);
  if (v3) {
    v3(a1, v1 + 72, v1 + 80, v1 + 88);
  }
  int v4 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v1 + 64);
  if (v4) {
    v4(a1, v1 + 72, v1 + 80, v1 + 88);
  }
  free(*(void **)(v1 + 8));
  free((void *)v1);
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 56) = 0;
  uint64_t result = 1;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

BIO *asn1_bio_callback_ctrl(uint64_t a1, int a2, void (__cdecl *a3)(bio_st *, int, const char *, int, uint64_t, uint64_t))
{
  uint64_t result = *(BIO **)(a1 + 64);
  if (result) {
    return (BIO *)BIO_callback_ctrl(result, a2, a3);
  }
  return result;
}

uint64_t asn1_bio_setup_ex(BIO *a1, _DWORD *a2, unsigned int (*a3)(BIO *, _DWORD *, _DWORD *, _DWORD *), int a4, int a5)
{
  if (a3 && !a3(a1, a2 + 18, a2 + 20, a2 + 22))
  {
    BIO_clear_flags(a1, 15);
    return 0;
  }
  else
  {
    if ((int)a2[20] <= 0) {
      int v9 = a5;
    }
    else {
      int v9 = a4;
    }
    *a2 = v9;
    return 1;
  }
}

uint64_t asn1_bio_flush_ex(uint64_t a1, uint64_t a2, void (*a3)(uint64_t, uint64_t, int *, uint64_t), int a4)
{
  uint64_t v6 = (int *)(a2 + 80);
  int v5 = *(_DWORD *)(a2 + 80);
  if (v5 < 1) {
    return 1;
  }
  uint64_t v10 = a2 + 72;
  int v11 = *(BIO **)(a1 + 64);
  for (unint64_t i = (const void *)(*(void *)(a2 + 72) + *(int *)(a2 + 84)); ; unint64_t i = (const void *)(*(void *)(a2 + 72) + v15))
  {
    uint64_t v13 = BIO_write(v11, i, v5);
    uint64_t v14 = v13;
    if ((int)v13 < 1) {
      break;
    }
    int v5 = *v6 - v13;
    *uint64_t v6 = v5;
    if (v5 < 1)
    {
      if (a3) {
        a3(a1, v10, v6, a2 + 88);
      }
      *(_DWORD *)a2 = a4;
      *(_DWORD *)(a2 + 84) = 0;
      return v14;
    }
    uint64_t v15 = *(int *)(a2 + 84) + (uint64_t)(int)v13;
    *(_DWORD *)(a2 + 84) = v15;
    int v11 = *(BIO **)(a1 + 64);
  }
  return v14;
}

const EVP_CIPHER *EVP_desx_cbc(void)
{
  return (const EVP_CIPHER *)&d_xcbc_cipher;
}

uint64_t desx_cbc_init_key(uint64_t a1, const_DES_cblock *key)
{
  *(void *)(*(void *)(a1 + 120) + 128) = *(void *)&(*key)[8];
  *(void *)(*(void *)(a1 + 120) + 136) = *(void *)&(*key)[16];
  return 1;
}

uint64_t desx_cbc_cipher(uint64_t a1, unsigned __int8 *output, unsigned __int8 *input, unint64_t a4)
{
  uint64_t v4 = a4;
  if (!(a4 >> 62))
  {
    uint64_t v8 = a4;
    if (!a4) {
      return 1;
    }
    goto LABEL_4;
  }
  do
  {
    DES_xcbc_encrypt(input, output, 0x4000000000000000, *(DES_key_schedule **)(a1 + 120), (DES_cblock *)(a1 + 40), (const_DES_cblock *)(*(void *)(a1 + 120) + 128), (const_DES_cblock *)(*(void *)(a1 + 120) + 136), *(_DWORD *)(a1 + 16));
    uint64_t v8 = v4 - 0x4000000000000000;
    input += 0x4000000000000000;
    output += 0x4000000000000000;
    BOOL v9 = v4 < 0x4000000000000000;
    v4 -= 0x4000000000000000;
  }
  while (v9);
  if (v8) {
LABEL_4:
  }
    DES_xcbc_encrypt(input, output, v8, *(DES_key_schedule **)(a1 + 120), (DES_cblock *)(a1 + 40), (const_DES_cblock *)(*(void *)(a1 + 120) + 128), (const_DES_cblock *)(*(void *)(a1 + 120) + 136), *(_DWORD *)(a1 + 16));
  return 1;
}

uint64_t long_new(void *a1, uint64_t a2)
{
  *a1 = *(void *)(a2 + 40);
  return 1;
}

void *long_free(void *result, uint64_t a2)
{
  *uint64_t result = *(void *)(a2 + 40);
  return result;
}

void *long_clear(void *result, uint64_t a2)
{
  *uint64_t result = *(void *)(a2 + 40);
  return result;
}

uint64_t long_c2i(uint64_t *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  BIGNUM a = 0;
  uint64_t v14 = a2;
  uint64_t v12 = 0;
  if (a3)
  {
    if (a2) {
      uint64_t v8 = (const unsigned __int8 **)&v14;
    }
    else {
      uint64_t v8 = 0;
    }
    if (!c2i_ASN1_INTEGER(&a, v8, a3) || !ASN1_INTEGER_get_int64(&v12, (unsigned int *)a)) {
      goto LABEL_11;
    }
    uint64_t v9 = v12;
  }
  else
  {
    uint64_t v9 = 0;
  }
  if (v9 != *(void *)(a6 + 40))
  {
    *a1 = v9;
    uint64_t v10 = 1;
    goto LABEL_13;
  }
  ERR_put_error(13, 4095, 128, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/x_long.c", 213);
LABEL_11:
  uint64_t v10 = 0;
LABEL_13:
  ASN1_INTEGER_free(a);
  return v10;
}

uint64_t long_i2c(unint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = a2;
  unint64_t v4 = *a1;
  if (*a1 == *(void *)(a4 + 40)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = ASN1_INTEGER_new();
  uint64_t v8 = v7;
  if (v7 && ASN1_INTEGER_set_int64(&v7->length, v4))
  {
    if (a2) {
      uint64_t v9 = (unsigned __int8 **)&v11;
    }
    else {
      uint64_t v9 = 0;
    }
    uint64_t v5 = i2c_ASN1_INTEGER(v8, v9);
  }
  else
  {
    uint64_t v5 = 0;
  }
  ASN1_INTEGER_free(v8);
  return v5;
}

BOOL long_print(BIO *a1, void *a2)
{
  return BIO_printf(a1, "%ld\n", *a2) > 0;
}

BIGNUM *__cdecl BN_mod_sqrt(BIGNUM *ret, const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx)
{
  uint64_t v8 = ret;
  if (!ret)
  {
    uint64_t v8 = BN_new();
    if (!v8) {
      goto LABEL_19;
    }
  }
  BN_CTX_start(ctx);
  uint64_t v9 = BN_CTX_get(ctx);
  if (!v9) {
    goto LABEL_18;
  }
  uint64_t v10 = v9;
  uint64_t v11 = BN_CTX_get(ctx);
  if (!v11) {
    goto LABEL_18;
  }
  uint64_t v12 = v11;
  if (!BN_nnmod(v10, a, n, ctx)) {
    goto LABEL_18;
  }
  if (BN_abs_is_word((uint64_t)n, 2))
  {
    is_odchar d = BN_is_odd((uint64_t)v10);
    goto LABEL_8;
  }
  if (!BN_is_odd((uint64_t)n) || BN_abs_is_word((uint64_t)n, 1))
  {
    int v16 = 112;
    int v17 = 96;
LABEL_17:
    ERR_put_error(3, 4095, v16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_mod_sqrt.c", v17);
    goto LABEL_18;
  }
  if (BN_is_zero((uint64_t)v10) || BN_is_one((uint64_t)v10))
  {
    is_odchar d = BN_is_one((uint64_t)v10);
LABEL_8:
    if (!BN_set_word(v12, is_odd)) {
      goto LABEL_18;
    }
    goto LABEL_9;
  }
  int v20 = BN_kronecker(v10, n, ctx);
  if (v20 == -2) {
    goto LABEL_18;
  }
  if (v20 <= 0)
  {
    int v16 = 111;
    int v17 = 667;
    goto LABEL_17;
  }
  if (!n->top) {
    goto LABEL_57;
  }
  if ((~*(_DWORD *)n->d & 3) == 0)
  {
    BN_CTX_start(ctx);
    int v21 = BN_CTX_get(ctx);
    if (!v21) {
      goto LABEL_13;
    }
    int v22 = v21;
    int v23 = BN_value_one();
    if (!BN_uadd(v22, n, v23) || !BN_rshift(v22, v22, 2)) {
      goto LABEL_13;
    }
    int v24 = BN_mod_exp_ct(v12, v10, v22, n, ctx);
    goto LABEL_36;
  }
  unint64_t v28 = *n->d & 7;
  if (v28 != 1)
  {
    if (v28 == 5)
    {
      BN_CTX_start(ctx);
      unsigned int v29 = BN_CTX_get(ctx);
      if (!v29) {
        goto LABEL_13;
      }
      unint64_t v30 = v29;
      unsigned int v31 = BN_CTX_get(ctx);
      if (!v31) {
        goto LABEL_13;
      }
      uint64_t v32 = v31;
      unint64_t v33 = BN_CTX_get(ctx);
      if (!v33) {
        goto LABEL_13;
      }
      uint64_t v34 = v33;
      uint64_t v35 = BN_CTX_get(ctx);
      if (!v35) {
        goto LABEL_13;
      }
      int v36 = v35;
      if (!BN_rshift(v34, n, 3)) {
        goto LABEL_13;
      }
      BN_set_negative(v34, 0);
      if (!BN_mod_lshift1(v36, v10, n, ctx)
        || !BN_mod_exp_ct(v30, v36, v34, n, ctx)
        || !BN_mod_sqr(v32, v30, n, ctx)
        || !BN_mod_mul(v32, v36, v32, n, ctx)
        || !BN_sub_word(v32, 1uLL)
        || !BN_mod_mul(v12, v10, v30, n, ctx))
      {
        goto LABEL_13;
      }
      int v24 = BN_mod_mul(v12, v12, v32, n, ctx);
      goto LABEL_36;
    }
LABEL_57:
    int v16 = 112;
    int v17 = 684;
    goto LABEL_17;
  }
  BN_CTX_start(ctx);
  int v37 = BN_CTX_get(ctx);
  if (!v37) {
    goto LABEL_13;
  }
  BOOL v38 = v37;
  int v39 = BN_CTX_get(ctx);
  if (!v39) {
    goto LABEL_13;
  }
  uint64_t v40 = v39;
  r = BN_CTX_get(ctx);
  if (!r) {
    goto LABEL_13;
  }
  unsigned int v54 = BN_CTX_get(ctx);
  if (!v54) {
    goto LABEL_13;
  }
  unsigned int v41 = 0;
  do
    ++v41;
  while (!BN_is_bit_set(n, v41));
  if (!BN_rshift(v40, n, v41)) {
    goto LABEL_13;
  }
  BN_CTX_start(ctx);
  aBIGNUM a = BN_CTX_get(ctx);
  if (!aa) {
    goto LABEL_86;
  }
  unsigned int v53 = BN_CTX_get(ctx);
  if (!v53) {
    goto LABEL_86;
  }
  b = BN_CTX_get(ctx);
  if (!b) {
    goto LABEL_86;
  }
  int v59 = 0;
  for (unint64_t i = 2; i != 32; ++i)
  {
    if (!BN_set_word(aa, i) || !bn_mod_sqrt_n_is_non_residue(&v59, aa, (BIGNUM *)n, ctx)) {
      goto LABEL_86;
    }
    if (v59)
    {
LABEL_81:
      if (!BN_mod_exp_ct(v54, aa, v40, n, ctx)) {
        goto LABEL_86;
      }
      if (BN_is_zero((uint64_t)v54) || BN_is_one((uint64_t)v54))
      {
        int v44 = 112;
        int v45 = 295;
      }
      else
      {
        BN_CTX_end(ctx);
        BN_CTX_start(ctx);
        unsigned __int8 v46 = BN_CTX_get(ctx);
        if (!v46) {
          goto LABEL_86;
        }
        unsigned int v47 = v46;
        if (!BN_rshift1(v46, v40)
          || !BN_mod_exp_ct(r, v10, v47, n, ctx)
          || !BN_mod_sqr(v38, r, n, ctx)
          || !BN_mod_mul(v38, v10, v38, n, ctx))
        {
          goto LABEL_86;
        }
        int v48 = BN_mod_mul(r, v10, r, n, ctx);
        BN_CTX_end(ctx);
        if (!v48) {
          goto LABEL_13;
        }
LABEL_93:
        if (BN_is_one((uint64_t)v38))
        {
          int v24 = bn_copy(v12, r);
LABEL_36:
          int v25 = v24;
          BN_CTX_end(ctx);
          if (!v25) {
            goto LABEL_18;
          }
          BN_CTX_start(ctx);
          int v26 = BN_CTX_get(ctx);
          if (!v26) {
            goto LABEL_13;
          }
          int v27 = v26;
          if (!BN_lshift1(v26, v12) || BN_ucmp(v27, n) >= 1 && !BN_usub(v12, n, v12)) {
            goto LABEL_13;
          }
          BN_CTX_end(ctx);
LABEL_9:
          BN_CTX_start(ctx);
          uint64_t v14 = BN_CTX_get(ctx);
          if (!v14) {
            goto LABEL_13;
          }
          uint64_t v15 = v14;
          if (!BN_mod_sqr(v14, v12, n, ctx)) {
            goto LABEL_13;
          }
          if (BN_cmp(v15, v10))
          {
            ERR_put_error(3, 4095, 111, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_mod_sqrt.c", 619);
            goto LABEL_13;
          }
          BN_CTX_end(ctx);
          BOOL v19 = bn_copy(v8, v12);
          BN_CTX_end(ctx);
          if (!v19) {
            goto LABEL_19;
          }
          return v8;
        }
        BN_CTX_start(ctx);
        ab = BN_CTX_get(ctx);
        if (!ab) {
          goto LABEL_86;
        }
        int v49 = v41 - 2;
        if (v41 < 2)
        {
          int v45 = 376;
        }
        else
        {
          if (!BN_is_zero((uint64_t)v38) && !BN_is_one((uint64_t)v38))
          {
            if (bn_copy(ab, v38))
            {
              unsigned int v50 = 1;
              while (BN_mod_sqr(ab, ab, n, ctx))
              {
                if (BN_is_one((uint64_t)ab))
                {
                  BN_CTX_end(ctx);
                  BN_CTX_start(ctx);
                  ac = BN_CTX_get(ctx);
                  if (!ac
                    || !BN_set_bit(ac, v49)
                    || !BN_mod_exp_ct(ac, v54, ac, n, ctx)
                    || !BN_mod_mul(r, r, ac, n, ctx)
                    || !BN_mod_sqr(v54, ac, n, ctx))
                  {
                    goto LABEL_86;
                  }
                  int v51 = BN_mod_mul(v38, v38, v54, n, ctx);
                  BN_CTX_end(ctx);
                  if (v41 > v50)
                  {
                    unsigned int v41 = v50;
                    if (v51) {
                      goto LABEL_93;
                    }
                  }
                  goto LABEL_13;
                }
                ++v50;
                if (--v49 == -1)
                {
                  int v45 = 402;
                  goto LABEL_112;
                }
              }
            }
            goto LABEL_86;
          }
          int v45 = 386;
        }
LABEL_112:
        int v44 = 112;
      }
LABEL_85:
      ERR_put_error(3, 4095, v44, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_mod_sqrt.c", v45);
      goto LABEL_86;
    }
  }
  if (BN_set_word(v53, 0x20uLL) && bn_copy(b, n))
  {
    BN_set_negative(b, 0);
    int v43 = 128;
    while (bn_rand_interval(aa, v53, b) && bn_mod_sqrt_n_is_non_residue(&v59, aa, (BIGNUM *)n, ctx))
    {
      if (v59) {
        goto LABEL_81;
      }
      if (!--v43)
      {
        int v44 = 113;
        int v45 = 282;
        goto LABEL_85;
      }
    }
  }
LABEL_86:
  BN_CTX_end(ctx);
LABEL_13:
  BN_CTX_end(ctx);
LABEL_18:
  BN_CTX_end(ctx);
LABEL_19:
  if (v8 != ret) {
    BN_free(v8);
  }
  return 0;
}

uint64_t bn_mod_sqrt_n_is_non_residue(_DWORD *a1, BIGNUM *a, BIGNUM *b, BN_CTX *ctx)
{
  uint64_t result = BN_kronecker(a, b, ctx);
  if (result == 1)
  {
    *a1 = 0;
  }
  else
  {
    if (result)
    {
      if (result == -1)
      {
        uint64_t result = 1;
        *a1 = 1;
        return result;
      }
    }
    else
    {
      ERR_put_error(3, 4095, 112, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_mod_sqrt.c", 221);
    }
    return 0;
  }
  return result;
}

void ERR_print_errors_cb(int (__cdecl *cb)(const char *, size_t, void *), void *u)
{
  uint64_t v2 = MEMORY[0x270FA5388](cb);
  uint64_t v4 = v3;
  uint64_t v5 = (int (*)(char *, size_t, uint64_t))v2;
  uint64_t v16 = *MEMORY[0x263EF8340];
  unsigned int data = 0;
  file = 0;
  v10[1] = 0;
  *(void *)flags = 0;
  v10[0] = 0;
  CRYPTO_THREADID_current(v10);
  uint64_t v6 = CRYPTO_THREADID_hash((uint64_t)v10);
  do
  {
    error_line_unsigned int data = ERR_get_error_line_data((const char **)&file, &flags[1], (const char **)&data, flags);
    if (!error_line_data) {
      break;
    }
    ERR_error_string_n(error_line_data, v15, 0x100uLL);
    uint64_t v8 = (flags[0] & 2) != 0 ? data : "";
    snprintf(__str, 0x1000uLL, "%lu:%s:%s:%d:%s\n", v6, v15, file, flags[1], v8);
    size_t v9 = strlen(__str);
  }
  while (v5(__str, v9, v4) > 0);
}

void ERR_print_errors_fp(FILE *fp)
{
}

uint64_t print_fp(const char *a1, uint64_t a2, void *a3)
{
  memset(&a, 0, sizeof(a));
  uint64_t v5 = BIO_s_file();
  BIO_set(&a, v5);
  BIO_ctrl(&a, 106, 0, a3);
  return BIO_printf(&a, "%s", a1);
}

void ERR_print_errors(BIO *bp)
{
}

uint64_t print_bio(void *data, int len, BIO *b)
{
  return BIO_write(b, data, len);
}

uint64_t eckey_pub_decode(EVP_PKEY *a1, uint64_t a2)
{
  iint n = 0;
  *(void *)ppint type = 0;
  ppval = 0;
  algor = 0;
  uint64_t result = X509_PUBKEY_get0_param(0, &in, pptype, &algor, a2);
  if (result)
  {
    X509_ALGOR_get0(0, &pptype[1], &ppval, algor);
    BIO a = eckey_type2param(pptype[1], (const ASN1_OBJECT *)ppval);
    if (!a)
    {
      ERR_put_error(16, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", 209);
      return 0;
    }
    if (o2i_ECPublicKey(&a, (const unsigned __int8 **)&in, pptype[0]))
    {
      EVP_PKEY_assign(a1, 408, (char *)a);
      return 1;
    }
    ERR_put_error(16, 4095, 142, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", 214);
    uint64_t result = (uint64_t)a;
    if (a)
    {
      EC_KEY_free(a);
      return 0;
    }
  }
  return result;
}

uint64_t eckey_pub_encode(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(EC_KEY **)(a2 + 32);
  BIO a = 0;
  int v13 = 0;
  out = 0;
  if (eckey_param2type(&v13, &a, v3))
  {
    int v4 = i2o_ECPublicKey(v3, 0);
    if (v4 < 1)
    {
      uint64_t v6 = 0;
    }
    else
    {
      uint64_t v5 = (unsigned __int8 *)malloc_type_malloc(v4, 0x8D6A78E8uLL);
      uint64_t v6 = v5;
      if (v5)
      {
        out = v5;
        int v7 = i2o_ECPublicKey(v3, &out);
        if (v7 >= 1)
        {
          int v8 = v7;
          size_t v9 = OBJ_nid2obj(408);
          int v10 = v13;
          if (X509_PUBKEY_set0_param(a1, v9, v13, a, v6, v8)) {
            return 1;
          }
          goto LABEL_10;
        }
      }
    }
    int v10 = v13;
LABEL_10:
    if (v10 == 6) {
      ASN1_OBJECT_free(a);
    }
    else {
      ASN1_STRING_free((ASN1_STRING *)a);
    }
    free(v6);
    return 0;
  }
  ERR_put_error(16, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", 120);
  return 0;
}

uint64_t eckey_pub_cmp(uint64_t a1, uint64_t a2)
{
  int v4 = EC_KEY_get0_group(*(const EC_KEY **)(a2 + 32));
  uint64_t v5 = EC_KEY_get0_public_key(*(const EC_KEY **)(a1 + 32));
  uint64_t v6 = EC_KEY_get0_public_key(*(const EC_KEY **)(a2 + 32));
  int v7 = EC_POINT_cmp(v4, v5, v6, 0);
  if (v7 == 1) {
    unsigned int v8 = 0;
  }
  else {
    unsigned int v8 = -2;
  }
  if (v7) {
    return v8;
  }
  else {
    return 1;
  }
}

uint64_t eckey_pub_print(BIO *a1, uint64_t a2, int a3)
{
  return do_EC_KEY_print(a1, *(EC_KEY **)(a2 + 32), a3, 1);
}

uint64_t eckey_priv_decode(EVP_PKEY *a1, uint64_t a2)
{
  ppval = 0;
  iint n = 0;
  *(void *)ppint type = 0;
  algor = 0;
  uint64_t result = PKCS8_pkey_get0(0, &in, pptype, &algor, a2);
  if (result)
  {
    X509_ALGOR_get0(0, &pptype[1], &ppval, algor);
    BIO a = eckey_type2param(pptype[1], (const ASN1_OBJECT *)ppval);
    if (!a)
    {
LABEL_17:
      int v4 = 16;
      int v5 = 301;
LABEL_18:
      ERR_put_error(16, 4095, v4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", v5);
      uint64_t result = (uint64_t)a;
      if (a)
      {
        EC_KEY_free(a);
        return 0;
      }
      return result;
    }
    if (!d2i_ECPrivateKey(&a, (const unsigned __int8 **)&in, pptype[0]))
    {
      int v4 = 142;
      int v5 = 261;
      goto LABEL_18;
    }
    if (EC_KEY_get0_public_key(a))
    {
LABEL_5:
      EVP_PKEY_assign(a1, 408, (char *)a);
      return 1;
    }
    uint64_t v6 = EC_KEY_get0_group(a);
    int v7 = EC_POINT_new(v6);
    if (v7)
    {
      unsigned int v8 = v7;
      size_t v9 = EC_GROUP_get0_generator(v6);
      if (EC_POINT_copy(v8, v9))
      {
        int v10 = EC_KEY_get0_private_key(a);
        if (EC_POINT_mul(v6, v8, v10, 0, 0, 0))
        {
          int v11 = EC_KEY_set_public_key(a, v8);
          EC_POINT_free(v8);
          if (v11) {
            goto LABEL_5;
          }
          int v12 = 292;
          goto LABEL_16;
        }
        int v12 = 287;
      }
      else
      {
        int v12 = 281;
      }
      EC_POINT_free(v8);
    }
    else
    {
      int v12 = 276;
    }
LABEL_16:
    ERR_put_error(16, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", v12);
    goto LABEL_17;
  }
  return result;
}

BOOL eckey_priv_encode(uint64_t a1, uint64_t a2)
{
  pint type = 0;
  pval = 0;
  uint64_t v3 = *(const EC_KEY **)(a2 + 32);
  if (eckey_param2type(&ptype, &pval, v3))
  {
    unsigned int enc_flags = EC_KEY_get_enc_flags(v3);
    EC_KEY_set_enc_flags(v3, enc_flags | 1);
    int v5 = i2d_ECPrivateKey(v3, 0);
    if (v5)
    {
      int v6 = v5;
      int v7 = (unsigned __int8 *)malloc_type_malloc(v5, 0x61B21F8FuLL);
      if (v7)
      {
        unsigned int v8 = v7;
        out = v7;
        int v9 = i2d_ECPrivateKey(v3, &out);
        EC_KEY_set_enc_flags(v3, enc_flags);
        if (v9)
        {
          int v10 = OBJ_nid2obj(408);
          return PKCS8_pkey_set0(a1, v10, 0, ptype, pval, v8, v6) != 0;
        }
        free(v8);
        int v12 = 16;
        int v13 = 348;
      }
      else
      {
        EC_KEY_set_enc_flags(v3, enc_flags);
        int v12 = 65;
        int v13 = 341;
      }
    }
    else
    {
      EC_KEY_set_enc_flags(v3, enc_flags);
      int v12 = 16;
      int v13 = 335;
    }
  }
  else
  {
    int v12 = 142;
    int v13 = 320;
  }
  ERR_put_error(16, 4095, v12, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", v13);
  return 0;
}

uint64_t eckey_priv_print(BIO *a1, uint64_t a2, int a3)
{
  return do_EC_KEY_print(a1, *(EC_KEY **)(a2 + 32), a3, 2);
}

uint64_t int_ec_size(uint64_t a1)
{
  return ECDSA_size(*(const EC_KEY **)(a1 + 32));
}

uint64_t ec_bits(uint64_t a1)
{
  uint64_t v2 = BN_new();
  if (v2)
  {
    uint64_t v3 = v2;
    int v4 = EC_KEY_get0_group(*(const EC_KEY **)(a1 + 32));
    if (EC_GROUP_get_order(v4, v3, 0))
    {
      uint64_t v5 = BN_num_bits(v3);
      BN_free(v3);
      return v5;
    }
    BN_free(v3);
  }
  ERR_clear_error();
  return 0;
}

uint64_t ec_security_bits(uint64_t a1)
{
  int v1 = ec_bits(a1);
  if (v1 >= 0) {
    int v2 = v1;
  }
  else {
    int v2 = v1 + 1;
  }
  int v3 = v2 >> 1;
  if (v1 <= 159) {
    int v4 = v3;
  }
  else {
    int v4 = 80;
  }
  if (v1 <= 223) {
    int v5 = v4;
  }
  else {
    int v5 = 112;
  }
  if (v1 <= 255) {
    int v6 = v5;
  }
  else {
    int v6 = 128;
  }
  if (v1 <= 383) {
    unsigned int v7 = v6;
  }
  else {
    unsigned int v7 = 192;
  }
  if (v1 <= 511) {
    return v7;
  }
  else {
    return 256;
  }
}

uint64_t eckey_param_decode(EVP_PKEY *a1, const unsigned __int8 **a2, int a3)
{
  int v4 = (char *)d2i_ECParameters(0, a2, a3);
  if (v4)
  {
    EVP_PKEY_assign(a1, 408, v4);
    return 1;
  }
  else
  {
    ERR_put_error(16, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", 528);
    return 0;
  }
}

uint64_t eckey_param_encode(uint64_t a1, unsigned __int8 **a2)
{
  return i2d_ECParameters(*(EC_KEY **)(a1 + 32), a2);
}

BOOL ec_missing_parameters(uint64_t a1)
{
  return EC_KEY_get0_group(*(const EC_KEY **)(a1 + 32)) == 0;
}

uint64_t ec_copy_parameters(uint64_t a1, uint64_t a2)
{
  int v2 = *(EC_KEY **)(a1 + 32);
  int v3 = EC_KEY_get0_group(*(const EC_KEY **)(a2 + 32));
  return EC_KEY_set_group(v2, v3);
}

BOOL ec_cmp_parameters(uint64_t a1, uint64_t a2)
{
  int v3 = EC_KEY_get0_group(*(const EC_KEY **)(a1 + 32));
  int v4 = EC_KEY_get0_group(*(const EC_KEY **)(a2 + 32));
  return EC_GROUP_cmp(v3, v4, 0) == 0;
}

uint64_t eckey_param_print(BIO *a1, uint64_t a2, int a3)
{
  return do_EC_KEY_print(a1, *(EC_KEY **)(a2 + 32), a3, 0);
}

void int_ec_free(uint64_t a1)
{
}

uint64_t ec_pkey_ctrl(unsigned int *a1, int a2, uint64_t a3, void *a4)
{
  uint64_t v4 = 4294967294;
  switch(a2)
  {
    case 1:
      if (a3) {
        return 1;
      }
      LODWORD(str) = 0;
      paobint j = 0;
      algor = 0;
      PKCS7_SIGNER_INFO_get0_algs(a4, 0, &algor, &paobj);
      goto LABEL_40;
    case 3:
      *(_DWORD *)a4 = 64;
      return 2;
    case 5:
      if (a3) {
        return 1;
      }
      paobint j = 0;
      algor = 0;
      LODWORD(str) = 0;
      CMS_SignerInfo_get0_algs(a4, 0, 0, &algor, &paobj);
LABEL_40:
      if (algor)
      {
        if (algor->algorithm)
        {
          int v27 = OBJ_obj2nid(algor->algorithm);
          if (v27)
          {
            int v28 = v27;
            int v29 = EVP_PKEY_id(a1);
            if (OBJ_find_sigid_by_algs(&str, v28, v29))
            {
              unint64_t v30 = paobj;
              unsigned int v31 = OBJ_nid2obj((int)str);
              X509_ALGOR_set0((X509_ALGOR *)v30, v31, -1, 0);
              return 1;
            }
          }
        }
      }
      return 0xFFFFFFFFLL;
    case 7:
      if (a3 == 1)
      {
        uint64_t v32 = CMS_RecipientInfo_get0_pkey_ctx((uint64_t)a4);
        uint64_t v4 = v32;
        if (!v32) {
          return v4;
        }
        if (EVP_PKEY_CTX_get0_peerkey(v32)) {
          goto LABEL_48;
        }
        mchar d = 0;
        out = 0;
        if (!CMS_RecipientInfo_kari_get0_orig_id((uint64_t)a4, &out, &md, 0, 0, 0)) {
          return 0;
        }
        if (!out) {
          return 0;
        }
        uint64_t v34 = md;
        if (!md) {
          return 0;
        }
        paobint j = 0;
        algor = 0;
        LODWORD(v63) = 0;
        iint n = 0;
        uint64_t str = 0;
        X509_ALGOR_get0((ASN1_OBJECT **)&algor, (int *)&v63, (void **)&paobj, (X509_ALGOR *)out);
        if (OBJ_obj2nid((const ASN1_OBJECT *)algor) != 408) {
          goto LABEL_99;
        }
        if (v63 == 5 || v63 == -1)
        {
          uint64_t v35 = EVP_PKEY_CTX_get0_pkey(v4);
          if (!v35) {
            goto LABEL_99;
          }
          int v36 = EC_KEY_get0_group(*(const EC_KEY **)(v35 + 32));
          int v37 = (ASN1_STRING *)EC_KEY_new();
          uint64_t str = v37;
          if (!v37 || !EC_KEY_set_group((EC_KEY *)v37, v36)) {
            goto LABEL_99;
          }
        }
        else
        {
          uint64_t str = (ASN1_STRING *)eckey_type2param((int)v63, paobj);
          if (!str) {
            goto LABEL_99;
          }
        }
        int v59 = ASN1_STRING_length((ASN1_STRING *)v34);
        iint n = (unsigned __int8 *)ASN1_STRING_get0_data((uint64_t)v34);
        if (in)
        {
          if (v59)
          {
            if (o2i_ECPublicKey((EC_KEY **)&str, (const unsigned __int8 **)&in, v59))
            {
              unsigned int v60 = EVP_PKEY_new();
              if (v60)
              {
                unsigned int v61 = v60;
                EVP_PKEY_set1_EC_KEY(v60, (ec_key_st *)str);
                int v62 = EVP_PKEY_derive_set_peer(v4, v61);
                EC_KEY_free((EC_KEY *)str);
                EVP_PKEY_free(v61);
                if (v62 >= 1)
                {
LABEL_48:
                  paobint j = 0;
                  algor = 0;
                  iint n = 0;
                  if (CMS_RecipientInfo_kari_get0_alg((uint64_t)a4, &algor, &paobj))
                  {
                    int v33 = OBJ_obj2nid(algor->algorithm);
                    if (v33
                      && (LODWORD(out) = 0, LODWORD(md) = 0, OBJ_find_sigid_algs(v33, &md, &out))
                      && (out == 990 || out == 991)
                      && (int)EVP_PKEY_CTX_ctrl((uint64_t *)v4, 408, 1024) >= 1
                      && (int)EVP_PKEY_CTX_ctrl((uint64_t *)v4, 408, 1024) >= 1
                      && (int v45 = OBJ_nid2sn((int)md), EVP_get_digestbyname(v45))
                      && (int)EVP_PKEY_CTX_ctrl((uint64_t *)v4, 408, 1024) > 0)
                    {
                      parameter = algor->parameter;
                      if (parameter->type == 16)
                      {
                        ptr = parameter->value.ptr;
                        uint64_t str = (ASN1_STRING *)*((void *)ptr + 1);
                        int v48 = d2i_X509_ALGOR(0, (const unsigned __int8 **)&str, *(int *)ptr);
                        if (v48)
                        {
                          uint64_t v49 = CMS_RecipientInfo_kari_get0_ctx((uint64_t)a4);
                          if (v49)
                          {
                            unsigned int v50 = (EVP_CIPHER_CTX *)v49;
                            int v51 = OBJ_obj2nid(v48->algorithm);
                            uint64_t v52 = OBJ_nid2sn(v51);
                            cipherbyname = EVP_get_cipherbyname(v52);
                            if (cipherbyname)
                            {
                              unsigned int v54 = cipherbyname;
                              if ((EVP_CIPHER_flags(cipherbyname) & 0xF0007) == 0x10002)
                              {
                                if (EVP_EncryptInit_ex(v50, v54, 0, 0, 0))
                                {
                                  if (EVP_CIPHER_asn1_to_param(v50, v48->parameter) >= 1)
                                  {
                                    int v55 = EVP_CIPHER_CTX_key_length(v50);
                                    if ((int)EVP_PKEY_CTX_ctrl((uint64_t *)v4, 408, 1024) >= 1
                                      && (int)CMS_SharedInfo_encode(&in, (uint64_t)v48, (uint64_t)paobj, v55) >= 1
                                      && (int)EVP_PKEY_CTX_ctrl((uint64_t *)v4, 408, 1024) >= 1)
                                    {
                                      iint n = 0;
                                      X509_ALGOR_free(v48);
                                      free(in);
                                      return 1;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        X509_ALGOR_free(v48);
                        free(in);
                      }
                    }
                    else
                    {
                      ERR_put_error(16, 4095, 148, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", 789);
                    }
                  }
                  int v56 = 150;
                  int v57 = 858;
                  goto LABEL_89;
                }
LABEL_100:
                int v56 = 149;
                int v57 = 851;
LABEL_89:
                ERR_put_error(16, 4095, v56, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", v57);
                return 0;
              }
            }
          }
        }
LABEL_99:
        EC_KEY_free((EC_KEY *)str);
        EVP_PKEY_free(0);
        goto LABEL_100;
      }
      if (!a3)
      {
        out = 0;
        uint64_t v7 = CMS_RecipientInfo_get0_pkey_ctx((uint64_t)a4);
        uint64_t v4 = v7;
        if (v7)
        {
          paobint j = 0;
          algor = 0;
          iint n = 0;
          uint64_t str = 0;
          int n = 0;
          mchar d = 0;
          uint64_t v8 = EVP_PKEY_CTX_get0_pkey(v7);
          if (CMS_RecipientInfo_kari_get0_orig_id((uint64_t)a4, &algor, &str, 0, 0, 0))
          {
            X509_ALGOR_get0(&paobj, 0, 0, algor);
            int v9 = paobj;
            if (v9 == OBJ_nid2obj(0))
            {
              BOOL v38 = *(EC_KEY **)(v8 + 32);
              int v39 = i2o_ECPublicKey(v38, 0);
              if (v39 < 1) {
                goto LABEL_69;
              }
              uint64_t v40 = (unsigned __int8 *)malloc_type_malloc(v39, 0xDE0365E6uLL);
              out = v40;
              if (!v40) {
                goto LABEL_69;
              }
              unsigned int v41 = v40;
              unsigned int v63 = v40;
              int v42 = i2o_ECPublicKey(v38, &v63);
              if (v42 < 1) {
                goto LABEL_69;
              }
              ASN1_STRING_set0(str, v41, v42);
              if (!asn1_abs_set_unused_bits((uint64_t)str, 0)) {
                goto LABEL_69;
              }
              out = 0;
              int v43 = algor;
              int v44 = OBJ_nid2obj(408);
              X509_ALGOR_set0(v43, v44, -1, 0);
            }
            int v10 = EVP_PKEY_CTX_ctrl((uint64_t *)v4, 408, 1024);
            if (v10 >= 1)
            {
              int v11 = v10;
              if (EVP_PKEY_CTX_ctrl((uint64_t *)v4, 408, 1024))
              {
                int v12 = EVP_PKEY_CTX_ctrl((uint64_t *)v4, 408, 1024);
                if ((v12 & 0x80000000) == 0)
                {
                  int v13 = v12 == 1 ? 991 : v12;
                  int v14 = v12 ? v13 : 990;
                  if (v11 == 1 && (int)EVP_PKEY_CTX_ctrl((uint64_t *)v4, 408, 1024) >= 1)
                  {
                    if (md || (mchar d = (EVP_MD *)EVP_sha1(), (int)EVP_PKEY_CTX_ctrl((uint64_t *)v4, 408, 1024) >= 1))
                    {
                      if (CMS_RecipientInfo_kari_get0_alg((uint64_t)a4, &algor, &in))
                      {
                        int v15 = EVP_MD_type(md);
                        if (OBJ_find_sigid_by_algs(&n, v15, v14))
                        {
                          uint64_t v16 = (EVP_CIPHER_CTX *)CMS_RecipientInfo_kari_get0_ctx((uint64_t)a4);
                          int v17 = EVP_CIPHER_CTX_cipher(v16);
                          int v18 = EVP_CIPHER_type(v17);
                          int v19 = EVP_CIPHER_CTX_key_length(v16);
                          int v20 = X509_ALGOR_new();
                          if (v20)
                          {
                            v20->algorithm = OBJ_nid2obj(v18);
                            int v21 = ASN1_TYPE_new();
                            v20->parameter = v21;
                            if (v21)
                            {
                              if (EVP_CIPHER_param_to_asn1(v16, v21) >= 1)
                              {
                                if (!ASN1_TYPE_get(v20->parameter))
                                {
                                  ASN1_TYPE_free(v20->parameter);
                                  v20->parameter = 0;
                                }
                                if ((int)EVP_PKEY_CTX_ctrl((uint64_t *)v4, 408, 1024) >= 1
                                  && (int)CMS_SharedInfo_encode(&out, (uint64_t)v20, (uint64_t)in, v19) >= 1
                                  && (int)EVP_PKEY_CTX_ctrl((uint64_t *)v4, 408, 1024) >= 1)
                                {
                                  out = 0;
                                  int v22 = i2d_X509_ALGOR(v20, &out);
                                  if (v22 >= 1)
                                  {
                                    int v23 = v22;
                                    int v24 = ASN1_STRING_new();
                                    uint64_t v4 = (uint64_t)v24;
                                    if (v24)
                                    {
                                      ASN1_STRING_set0(v24, out, v23);
                                      out = 0;
                                      int v25 = algor;
                                      int v26 = OBJ_nid2obj(n);
                                      X509_ALGOR_set0(v25, v26, 16, (void *)v4);
                                      uint64_t v4 = 1;
                                    }
                                    goto LABEL_71;
                                  }
                                }
                              }
                            }
                          }
LABEL_70:
                          uint64_t v4 = 0;
LABEL_71:
                          free(out);
                          X509_ALGOR_free(v20);
                          return v4;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
LABEL_69:
          int v20 = 0;
          goto LABEL_70;
        }
      }
      return v4;
    case 8:
      uint64_t v4 = 1;
      *(_DWORD *)a4 = 1;
      return v4;
    default:
      return v4;
  }
}

uint64_t old_ec_priv_decode(EVP_PKEY *a1, const unsigned __int8 **a2, int a3)
{
  uint64_t v4 = (char *)d2i_ECPrivateKey(0, a2, a3);
  if (v4)
  {
    EVP_PKEY_assign(a1, 408, v4);
    return 1;
  }
  else
  {
    ERR_put_error(16, 4095, 142, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", 569);
    return 0;
  }
}

uint64_t old_ec_priv_encode(uint64_t a1, unsigned __int8 **a2)
{
  return i2d_ECPrivateKey(*(EC_KEY **)(a1 + 32), a2);
}

uint64_t ec_pkey_check(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(void *)(v1 + 40))
  {
    return EC_KEY_check_key((const EC_KEY *)v1);
  }
  else
  {
    ERR_put_error(16, 4095, 125, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", 649);
    return 0;
  }
}

uint64_t ec_pkey_public_check(uint64_t a1)
{
  return EC_KEY_check_key(*(const EC_KEY **)(a1 + 32));
}

uint64_t ec_pkey_param_check(uint64_t a1)
{
  uint64_t v1 = *(const EC_GROUP **)(*(void *)(a1 + 32) + 24);
  if (v1)
  {
    return EC_GROUP_check(v1, 0);
  }
  else
  {
    ERR_put_error(16, 4095, 124, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", 671);
    return 0;
  }
}

EC_KEY *eckey_type2param(int a1, const ASN1_OBJECT *a2)
{
  if (a1 != 6)
  {
    if (a1 != 16)
    {
      ERR_put_error(16, 4095, 142, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", 180);
      int v3 = 0;
LABEL_13:
      uint64_t v4 = 0;
LABEL_14:
      EC_KEY_free(v3);
      int v3 = 0;
      goto LABEL_15;
    }
    iint n = (unsigned __int8 *)a2->ln;
    int v3 = d2i_ECParameters(0, (const unsigned __int8 **)&in, SLODWORD(a2->sn));
    if (v3)
    {
      uint64_t v4 = 0;
      goto LABEL_15;
    }
    int v7 = 142;
    int v8 = 159;
LABEL_12:
    ERR_put_error(16, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", v8);
    goto LABEL_13;
  }
  int v3 = EC_KEY_new();
  if (!v3)
  {
    int v7 = 65;
    int v8 = 170;
    goto LABEL_12;
  }
  int v5 = OBJ_obj2nid(a2);
  int v6 = EC_GROUP_new_by_curve_name(v5);
  uint64_t v4 = v6;
  if (!v6) {
    goto LABEL_14;
  }
  EC_GROUP_set_asn1_flag(v6, 1);
  if (!EC_KEY_set_group(v3, v4)) {
    goto LABEL_14;
  }
LABEL_15:
  EC_GROUP_free(v4);
  return v3;
}

ASN1_STRING *eckey_param2type(int *a1, void *a2, EC_KEY *a3)
{
  if (!a3 || (int v6 = EC_KEY_get0_group(a3)) == 0)
  {
    int v10 = 124;
    int v11 = 84;
    goto LABEL_7;
  }
  int v7 = v6;
  if (!EC_GROUP_get_asn1_flag(v6) || (int curve_name = EC_GROUP_get_curve_name(v7)) == 0)
  {
    uint64_t result = ASN1_STRING_new();
    if (!result) {
      return result;
    }
    int v13 = result;
    int v14 = i2d_ECParameters(a3, &result->data);
    v13->uint64_t length = v14;
    if (v14 > 0)
    {
      *a2 = v13;
      int v9 = 16;
      goto LABEL_11;
    }
    ASN1_STRING_free(v13);
    int v10 = 16;
    int v11 = 101;
LABEL_7:
    ERR_put_error(16, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", v11);
    return 0;
  }
  *a2 = OBJ_nid2obj(curve_name);
  int v9 = 6;
LABEL_11:
  *a1 = v9;
  return (ASN1_STRING *)1;
}

uint64_t do_EC_KEY_print(BIO *a1, EC_KEY *a2, int a3, int a4)
{
  uint64_t v4 = a2;
  if (!a2)
  {
    int v10 = 0;
    int v18 = 0;
    int v12 = 0;
LABEL_12:
    int v19 = 67;
LABEL_44:
    ERR_put_error(16, 4095, v19, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_ameth.c", 514);
    uint64_t v28 = 0;
    goto LABEL_45;
  }
  int v8 = EC_KEY_get0_group(a2);
  if (!v8)
  {
    int v10 = 0;
    int v18 = 0;
    int v12 = 0;
    uint64_t v4 = 0;
    goto LABEL_12;
  }
  int v9 = v8;
  int v10 = BN_CTX_new();
  if (!v10)
  {
    int v18 = 0;
    int v12 = 0;
    uint64_t v4 = 0;
LABEL_43:
    int v19 = 65;
    goto LABEL_44;
  }
  int v11 = "ECDSA-Parameters";
  if (a4 < 1)
  {
    uint64_t v4 = 0;
    int v12 = 0;
    int v20 = 0;
    goto LABEL_30;
  }
  int v12 = EC_KEY_get0_public_key(v4);
  if (v12)
  {
    point_conversion_form_t conv_form = EC_KEY_get_conv_form(v4);
    int v14 = EC_POINT_point2bn(v9, v12, conv_form, 0, v10);
    int v12 = (const EC_POINT *)v14;
    if (!v14)
    {
      int v18 = 0;
      uint64_t v4 = 0;
      int v19 = 16;
      goto LABEL_44;
    }
    int v15 = BN_num_bits(v14);
    int v16 = v15 + 7;
    if (v15 < -7) {
      int v16 = v15 + 14;
    }
    unint64_t v17 = (uint64_t)v16 >> 3;
  }
  else
  {
    unint64_t v17 = 0;
  }
  if (a4 == 2)
  {
    int v21 = EC_KEY_get0_private_key(v4);
    int v20 = v21;
    if (v21)
    {
      int v22 = BN_num_bits(v21);
      int v23 = v22 + 7;
      if (v22 < -7) {
        int v23 = v22 + 14;
      }
      int v24 = v23 >> 3;
      uint64_t v25 = (uint64_t)v23 >> 3;
      if (v17 <= v24) {
        unint64_t v17 = v25;
      }
    }
  }
  else
  {
    int v20 = 0;
  }
  uint64_t v4 = (const EC_KEY *)malloc_type_malloc(v17 + 10, 0x3B22E2EDuLL);
  if (!v4)
  {
    int v18 = 0;
    goto LABEL_43;
  }
  int v26 = "Public-Key";
  if (a4 != 1) {
    int v26 = "ECDSA-Parameters";
  }
  if (a4 == 2) {
    int v11 = "Private-Key";
  }
  else {
    int v11 = v26;
  }
LABEL_30:
  if (!BIO_indent(a1, a3, 128))
  {
    int v18 = 0;
LABEL_41:
    int v19 = 32;
    goto LABEL_44;
  }
  int v18 = BN_new();
  if (!v18) {
    goto LABEL_41;
  }
  if (!EC_GROUP_get_order(v9, v18, 0)) {
    goto LABEL_41;
  }
  int v27 = BN_num_bits(v18);
  if (BIO_printf(a1, "%s: (%d bit)\n", v11, v27) < 1
    || v20 && !ASN1_bn_print(a1, "priv:", v20, (unsigned __int8 *)v4, a3))
  {
    goto LABEL_41;
  }
  if (v12 && !ASN1_bn_print(a1, "pub: ", (const BIGNUM *)v12, (unsigned __int8 *)v4, a3)
    || !ECPKParameters_print(a1, v9, a3))
  {
    goto LABEL_41;
  }
  uint64_t v28 = 1;
LABEL_45:
  BN_free((BIGNUM *)v12);
  BN_free(v18);
  BN_CTX_free(v10);
  free(v4);
  return v28;
}

unint64_t BN_mod_word(const BIGNUM *a, unint64_t w)
{
  if (!w) {
    return -1;
  }
  if (w >= 0x100000001)
  {
    uint64_t v4 = BN_dup(a);
    if (v4)
    {
      int v5 = v4;
      unint64_t v6 = BN_div_word(v4, w);
      BN_free(v5);
      return v6;
    }
    return -1;
  }
  uint64_t top = a->top;
  if ((int)top < 1) {
    return 0;
  }
  unint64_t result = 0;
  char d = a->d;
  unint64_t v10 = top + 1;
  do
  {
    *((void *)&v11 + 1) = result;
    *(void *)&long long v11 = d[(v10 - 2)];
    unint64_t result = (v11 | ((unint64_t)((unint64_t)(v11 >> 32) % w) << 32)) % w;
    --v10;
  }
  while (v10 > 1);
  return result;
}

unint64_t BN_div_word(BIGNUM *a, unint64_t w)
{
  unint64_t v16 = 0;
  if (!w) {
    return -1;
  }
  if (!a->top) {
    return 0;
  }
  int v4 = BN_num_bits_word(w);
  char v5 = v4;
  char v6 = 64 - v4;
  if (!BN_lshift(a, a, 64 - v4)) {
    return -1;
  }
  uint64_t top = a->top;
  if ((int)top >= 1)
  {
    unint64_t v8 = w << -v5;
    char d = a->d;
    unint64_t v10 = top + 1;
    do
    {
      unint64_t v15 = 0;
      bn_div_rem_words(v16, d[(v10 - 2)], v8, &v15, &v16);
      char d = a->d;
      a->d[(v10-- - 2)] = v15;
    }
    while (v10 > 1);
    int v11 = a->top;
    BOOL v12 = __OFSUB__(v11, 1);
    int v13 = v11 - 1;
    if (v13 < 0 == v12 && !a->d[v13]) {
      a->uint64_t top = v13;
    }
  }
  v16 >>= v6;
  BN_set_negative(a, a->neg);
  return v16;
}

int BN_add_word(BIGNUM *a, unint64_t w)
{
  if (!w) {
    goto LABEL_15;
  }
  unint64_t v2 = w;
  if (!BN_is_zero((uint64_t)a))
  {
    if (a->neg)
    {
      a->int neg = 0;
      int v5 = BN_sub_word(a, v2);
      BN_set_negative(a, a->neg == 0);
      return v5;
    }
    uint64_t v6 = 0;
    uint64_t top = a->top;
    while ((top & ~((int)top >> 31)) != v6)
    {
      unint64_t v8 = a->d[v6];
      BOOL v9 = __CFADD__(v8, v2);
      a->d[v6++] = v8 + v2;
      unint64_t v2 = 1;
      if (!v9) {
        return v2;
      }
    }
    if ((top & 0x80000000) == 0)
    {
      if (!bn_wexpand((uint64_t)a, (top + 1)))
      {
        LODWORD(v2) = 0;
        return v2;
      }
      ++a->top;
      a->d[top] = v2;
    }
LABEL_15:
    LODWORD(v2) = 1;
    return v2;
  }
  return BN_set_word(a, v2);
}

int BN_sub_word(BIGNUM *a, unint64_t w)
{
  if (!w) {
    return 1;
  }
  unint64_t v2 = w;
  if (!BN_is_zero((uint64_t)a))
  {
    if (a->neg)
    {
      a->int neg = 0;
      int v4 = BN_add_word(a, v2);
      BOOL v6 = a->neg == 0;
      int v5 = a;
      goto LABEL_7;
    }
    char d = a->d;
    unint64_t v8 = *a->d;
    int v9 = a->top - 1;
    if (a->top == 1 && v8 < v2)
    {
      unint64_t *d = v2 - v8;
      int v4 = 1;
      goto LABEL_4;
    }
    int v10 = 0;
    uint64_t v11 = v8 - v2;
    if (v8 < v2)
    {
      unint64_t v2 = 1;
      do
      {
        unint64_t *d = v11;
        unint64_t v12 = d[1];
        ++d;
        unint64_t v8 = v12;
        ++v10;
        uint64_t v11 = -1;
      }
      while (!v12);
    }
    unint64_t v13 = v8 - v2;
    unint64_t *d = v13;
    if (v13) {
      BOOL v14 = 0;
    }
    else {
      BOOL v14 = v10 == v9;
    }
    if (v14) {
      a->uint64_t top = v10;
    }
    return 1;
  }
  int v4 = BN_set_word(a, v2);
  if (v4)
  {
LABEL_4:
    int v5 = a;
    BOOL v6 = 1;
LABEL_7:
    BN_set_negative(v5, v6);
  }
  return v4;
}

int BN_mul_word(BIGNUM *a, unint64_t w)
{
  int top = a->top;
  if (top)
  {
    if (w)
    {
      unint64_t v4 = bn_mul_words(a->d, a->d, top, w);
      if (v4)
      {
        unint64_t v5 = v4;
        int result = bn_wexpand((uint64_t)a, (a->top + 1));
        if (!result) {
          return result;
        }
        char d = a->d;
        uint64_t v8 = a->top;
        a->int top = v8 + 1;
        d[v8] = v5;
      }
    }
    else
    {
      BN_zero((uint64_t)a);
    }
  }
  return 1;
}

uint64_t cms_get0_enveloped(uint64_t a1)
{
  if (OBJ_obj2nid(*(const ASN1_OBJECT **)a1) == 23) {
    return *(void *)(a1 + 8);
  }
  ERR_put_error(46, 4095, 107, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 74);
  return 0;
}

uint64_t cms_env_asn1_ctrl(uint64_t a1)
{
  if (*(_DWORD *)a1 != 1)
  {
    if (*(_DWORD *)a1) {
      return 0;
    }
    uint64_t result = *(void *)(*(void *)(a1 + 8) + 40);
LABEL_6:
    uint64_t v2 = *(void *)(result + 16);
    if (v2)
    {
      int v3 = *(uint64_t (**)(void))(v2 + 176);
      if (v3)
      {
        int v4 = v3();
        if (v4 == -2)
        {
          int v5 = 125;
          int v6 = 120;
LABEL_13:
          ERR_put_error(46, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", v6);
          return 0;
        }
        if (v4 <= 0)
        {
          int v5 = 111;
          int v6 = 124;
          goto LABEL_13;
        }
      }
    }
    return 1;
  }
  uint64_t result = *(void *)(*(void *)(a1 + 8) + 40);
  if (result)
  {
    uint64_t result = EVP_PKEY_CTX_get0_pkey(result);
    if (result) {
      goto LABEL_6;
    }
  }
  return result;
}

uint64_t CMS_get0_RecipientInfos(uint64_t a1)
{
  uint64_t result = cms_get0_enveloped(a1);
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t CMS_RecipientInfo_type(unsigned int *a1)
{
  return *a1;
}

uint64_t CMS_RecipientInfo_get0_pkey_ctx(uint64_t a1)
{
  if (*(_DWORD *)a1 == 1)
  {
    uint64_t v1 = *(void *)(a1 + 8) + 40;
    return *(void *)v1;
  }
  if (!*(_DWORD *)a1)
  {
    uint64_t v1 = *(void *)(a1 + 8) + 48;
    return *(void *)v1;
  }
  return 0;
}

ASN1_VALUE *CMS_EnvelopedData_create(ASN1_OBJECT *a1)
{
  uint64_t v2 = CMS_ContentInfo_new();
  int v3 = v2;
  if (!v2) {
    goto LABEL_10;
  }
  if (!*((void *)v2 + 1))
  {
    int v5 = ASN1_item_new(&CMS_EnvelopedData_it);
    *((void *)v3 + 1) = v5;
    if (v5)
    {
      *(void *)int v5 = 0;
      int v6 = OBJ_nid2obj(21);
      int v7 = *(ASN1_OBJECT **)v3;
      **(void **)(*((void *)v3 + 1) + 24) = v6;
      ASN1_OBJECT_free(v7);
      *(void *)int v3 = OBJ_nid2obj(23);
      uint64_t v4 = *((void *)v3 + 1);
      if (v4) {
        goto LABEL_7;
      }
    }
    else
    {
      ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 86);
    }
LABEL_10:
    CMS_ContentInfo_free(v3);
    ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 180);
    return 0;
  }
  uint64_t v4 = cms_get0_enveloped((uint64_t)v2);
  if (!v4) {
    goto LABEL_10;
  }
LABEL_7:
  if (!cms_EncryptedContent_init(*(ASN1_OBJECT ***)(v4 + 24), a1, 0, 0)) {
    goto LABEL_10;
  }
  return v3;
}

ASN1_VALUE *CMS_add1_recipient_cert(uint64_t a1, X509 *a2, unsigned int a3)
{
  uint64_t v5 = cms_get0_enveloped(a1);
  if (!v5)
  {
    int v7 = 0;
    goto LABEL_23;
  }
  uint64_t v6 = v5;
  int v7 = ASN1_item_new(&CMS_RecipientInfo_it);
  if (!v7)
  {
LABEL_21:
    int v14 = 65;
    int v15 = 286;
    goto LABEL_22;
  }
  uint64_t v8 = X509_get0_pubkey((uint64_t)a2);
  if (!v8)
  {
    int v14 = 113;
    int v15 = 258;
LABEL_22:
    ERR_put_error(46, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", v15);
    goto LABEL_23;
  }
  uint64_t v9 = (uint64_t)v8;
  ptr = v8->pkey.ptr;
  if (!ptr) {
    goto LABEL_9;
  }
  uint64_t v11 = (int (*)(EVP_PKEY *, uint64_t, void, int *))*((void *)ptr + 22);
  if (!v11) {
    goto LABEL_9;
  }
  int v18 = 0;
  if (v11(v8, 8, 0, &v18) < 1) {
    goto LABEL_9;
  }
  if (v18 == 1)
  {
    if (cms_RecipientInfo_kari_init((uint64_t)v7, a2, v9, a3)) {
      goto LABEL_20;
    }
LABEL_23:
    ASN1_item_free(v7, &CMS_RecipientInfo_it);
    return 0;
  }
  if (v18)
  {
    int v14 = 125;
    int v15 = 275;
    goto LABEL_22;
  }
LABEL_9:
  unint64_t v12 = ASN1_item_new(&CMS_KeyTransRecipientInfo_it);
  *((void *)v7 + 1) = v12;
  if (!v12) {
    goto LABEL_23;
  }
  unint64_t v13 = v12;
  *(_DWORD *)int v7 = 0;
  *(void *)unint64_t v12 = (a3 & 0x10000) >> 15;
  if (!cms_set1_SignerIdentifier(*((void *)v12 + 1), a2, HIWORD(a3) & 1)) {
    goto LABEL_23;
  }
  X509_up_ref((uint64_t)a2);
  EVP_PKEY_up_ref(v9);
  *((void *)v13 + 4) = a2;
  *((void *)v13 + 5) = v9;
  if ((a3 & 0x40000) != 0)
  {
    unint64_t v16 = (uint64_t *)EVP_PKEY_CTX_new(v9, 0);
    *((void *)v13 + 6) = v16;
    if (!v16 || (int)EVP_PKEY_encrypt_init(v16) < 1) {
      goto LABEL_23;
    }
  }
  else if (!cms_env_asn1_ctrl((uint64_t)v7))
  {
    goto LABEL_23;
  }
LABEL_20:
  if (!sk_push(*(STACK **)(v6 + 16), (char *)v7)) {
    goto LABEL_21;
  }
  return v7;
}

uint64_t cms_pkey_get_ri_type(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1 && (uint64_t v2 = *(int (**)(void))(v1 + 176)) != 0 && (v4 = 0, v2() > 0)) {
    return v4;
  }
  else {
    return 0;
  }
}

uint64_t CMS_RecipientInfo_ktri_get0_algs(uint64_t a1, void *a2, void *a3, void *a4)
{
  if (*(_DWORD *)a1)
  {
    ERR_put_error(46, 4095, 124, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 299);
    return 0;
  }
  else
  {
    uint64_t v5 = *(void **)(a1 + 8);
    if (a2) {
      *a2 = v5[5];
    }
    if (a3) {
      *a3 = v5[4];
    }
    if (a4) {
      *a4 = v5[2];
    }
    return 1;
  }
}

uint64_t CMS_RecipientInfo_ktri_get0_signer_id(uint64_t a1, void *a2, void *a3, void *a4)
{
  if (*(_DWORD *)a1)
  {
    ERR_put_error(46, 4095, 124, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 322);
    return 0;
  }
  else
  {
    uint64_t v5 = *(void *)(*(void *)(a1 + 8) + 8);
    return cms_SignerIdentifier_get0_signer_id(v5, a2, a3, a4);
  }
}

uint64_t CMS_RecipientInfo_ktri_cert_cmp(uint64_t a1, X509 *a2)
{
  if (*(_DWORD *)a1)
  {
    ERR_put_error(46, 4095, 124, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 334);
    return 4294967294;
  }
  else
  {
    uint64_t v3 = *(void *)(*(void *)(a1 + 8) + 8);
    return cms_SignerIdentifier_cert_cmp(v3, a2);
  }
}

uint64_t CMS_RecipientInfo_set0_pkey(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1)
  {
    ERR_put_error(46, 4095, 124, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 345);
    return 0;
  }
  else
  {
    EVP_PKEY_free(*(EVP_PKEY **)(*(void *)(a1 + 8) + 40));
    *(void *)(*(void *)(a1 + 8) + 40) = a2;
    return 1;
  }
}

uint64_t CMS_RecipientInfo_kekri_id_cmp(uint64_t a1, unsigned __int8 *a2, int a3)
{
  if (*(_DWORD *)a1 == 2)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    a.unsigned int data = a2;
    a.flags = 0;
    a.uint64_t length = a3;
    a.int type = 4;
    return ASN1_OCTET_STRING_cmp(&a, **(ASN1_OCTET_STRING ***)(v3 + 8));
  }
  else
  {
    ERR_put_error(46, 4095, 123, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 514);
    return 4294967294;
  }
}

ASN1_VALUE *CMS_add0_recipient_key(uint64_t a1, int a2, uint64_t a3, uint64_t a4, void *a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v16 = cms_get0_enveloped(a1);
  if (!v16) {
    goto LABEL_30;
  }
  uint64_t v17 = v16;
  if (a2 > 788)
  {
    if (a2 == 789)
    {
      uint64_t v18 = 24;
      goto LABEL_14;
    }
    if (a2 == 790)
    {
      uint64_t v18 = 32;
      goto LABEL_14;
    }
    goto LABEL_25;
  }
  if (a2)
  {
    if (a2 == 788)
    {
      uint64_t v18 = 16;
LABEL_14:
      if (v18 == a4) {
        goto LABEL_15;
      }
      int v27 = 118;
      int v28 = 588;
      goto LABEL_29;
    }
LABEL_25:
    int v27 = 153;
    int v28 = 583;
LABEL_29:
    ERR_put_error(46, 4095, v27, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", v28);
LABEL_30:
    int v19 = 0;
    goto LABEL_31;
  }
  switch(a4)
  {
    case 16:
      a2 = 788;
      break;
    case 32:
      a2 = 790;
      break;
    case 24:
      a2 = 789;
      break;
    default:
      int v27 = 118;
      int v28 = 574;
      goto LABEL_29;
  }
LABEL_15:
  int v19 = ASN1_item_new(&CMS_RecipientInfo_it);
  if (!v19
    || (int v20 = ASN1_item_new(&CMS_KEKRecipientInfo_it), (*((void *)v19 + 1) = v20) == 0)
    || (v21 = v20, *(_DWORD *)int v19 = 2, a8)
    && (int v22 = ASN1_item_new(&CMS_OtherKeyAttribute_it), (*(void *)(*((void *)v21 + 1) + 16) = v22) == 0)
    || !sk_push(*(STACK **)(v17 + 16), (char *)v19))
  {
    ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 637);
LABEL_31:
    ASN1_item_free(v19, &CMS_RecipientInfo_it);
    return 0;
  }
  *(void *)int v21 = 4;
  *((void *)v21 + 4) = a3;
  *((void *)v21 + 5) = a4;
  ASN1_STRING_set0(**((ASN1_STRING ***)v21 + 1), a5, a6);
  uint64_t v23 = *((void *)v21 + 1);
  *(void *)(v23 + 8) = a7;
  int v24 = *(void **)(v23 + 16);
  if (v24)
  {
    *int v24 = a8;
    v24[1] = a9;
  }
  uint64_t v25 = (X509_ALGOR *)*((void *)v21 + 2);
  int v26 = OBJ_nid2obj(a2);
  X509_ALGOR_set0(v25, v26, -1, 0);
  return v19;
}

uint64_t CMS_RecipientInfo_kekri_get0_id(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  if (*(_DWORD *)a1 == 2)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    int v7 = *(void **)(v6 + 8);
    if (a2) {
      *a2 = *(void *)(v6 + 16);
    }
    if (a3) {
      *a3 = *v7;
    }
    if (a4) {
      *a4 = v7[1];
    }
    if (a5)
    {
      uint64_t v8 = (void *)v7[2];
      if (v8) {
        uint64_t v8 = (void *)*v8;
      }
      *a5 = v8;
    }
    if (a6)
    {
      uint64_t v9 = v7[2];
      if (v9) {
        *a6 = *(void *)(v9 + 8);
      }
      else {
        *a6 = 0;
      }
    }
    return 1;
  }
  else
  {
    ERR_put_error(46, 4095, 123, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 651);
    return 0;
  }
}

uint64_t CMS_RecipientInfo_set0_key(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)a1 == 2)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    *(void *)(v3 + 32) = a2;
    *(void *)(v3 + 40) = a3;
    return 1;
  }
  else
  {
    ERR_put_error(46, 4095, 123, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 684);
    return 0;
  }
}

EVP_CIPHER_CTX *CMS_RecipientInfo_decrypt(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)a2;
  if (*(_DWORD *)a2 != 3)
  {
    if (v3 != 2)
    {
      if (v3)
      {
        int v19 = 155;
        int v20 = 824;
      }
      else
      {
        uint64_t v4 = *(void *)(a2 + 8);
        uint64_t v5 = *(void *)(v4 + 40);
        if (v5)
        {
          uint64_t v6 = *(void *)(*(void *)(a1 + 8) + 24);
          *(void *)size.rd_uint64_t key = 0;
          if (!*(_DWORD *)(v6 + 52) || *(_DWORD *)(v6 + 48))
          {
            uint64_t v7 = 0;
            goto LABEL_8;
          }
          int v23 = OBJ_obj2nid(**(const ASN1_OBJECT ***)(v6 + 8));
          int v24 = OBJ_nid2sn(v23);
          cipherbyname = EVP_get_cipherbyname(v24);
          if (cipherbyname)
          {
            uint64_t v7 = EVP_CIPHER_key_length(cipherbyname);
LABEL_8:
            uint64_t v8 = (uint64_t *)EVP_PKEY_CTX_new(v5, 0);
            *(void *)(v4 + 48) = v8;
            if (v8)
            {
              if ((int)EVP_PKEY_decrypt_init(v8) >= 1 && cms_env_asn1_ctrl(a2))
              {
                if ((int)EVP_PKEY_CTX_ctrl(*(uint64_t **)(v4 + 48), -1, 512) <= 0)
                {
                  int v10 = 110;
                  int v11 = 465;
                }
                else
                {
                  BOOL v9 = EVP_PKEY_decrypt(*(unsigned __int8 **)(v4 + 48), 0, (int)&size, *(EVP_PKEY **)(*(void *)(v4 + 24) + 8)) < 1|| *(void *)size.rd_key == 0;
                  if (!v9 && (!v7 || *(void *)size.rd_key == v7))
                  {
                    int v28 = (unsigned __int8 *)malloc_type_malloc(*(size_t *)size.rd_key, 0x7DB66469uLL);
                    if (v28)
                    {
                      if (EVP_PKEY_decrypt(*(unsigned __int8 **)(v4 + 48), v28, (int)&size, *(EVP_PKEY **)(*(void *)(v4 + 24) + 8)) > 0)
                      {
                        freezero(*(void **)(v6 + 32), *(void *)(v6 + 40));
                        uint64_t v29 = *(void *)size.rd_key;
                        *(void *)(v6 + 32) = v28;
                        *(void *)(v6 + 40) = v29;
                        EVP_PKEY_CTX_free(*(EVP_PKEY ***)(v4 + 48));
                        *(void *)(v4 + 48) = 0;
                        return (EVP_CIPHER_CTX *)1;
                      }
                      int v32 = 104;
                      int v33 = 485;
                    }
                    else
                    {
                      int v32 = 65;
                      int v33 = 479;
                    }
                    ERR_put_error(46, 4095, v32, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", v33);
                    goto LABEL_50;
                  }
                  int v10 = 104;
                  int v11 = 472;
                }
                ERR_put_error(46, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", v11);
              }
              int v28 = 0;
LABEL_50:
              EVP_PKEY_CTX_free(*(EVP_PKEY ***)(v4 + 48));
              *(void *)(v4 + 48) = 0;
              free(v28);
            }
            return 0;
          }
          int v19 = 148;
          int v20 = 446;
        }
        else
        {
          int v19 = 133;
          int v20 = 436;
        }
      }
LABEL_33:
      ERR_put_error(46, 4095, v19, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", v20);
      return 0;
    }
    memset(&size, 0, sizeof(size));
    uint64_t v13 = *(void *)(a2 + 8);
    if (!*(void *)(v13 + 32))
    {
      int v19 = 130;
      int v20 = 759;
      goto LABEL_33;
    }
    uint64_t v14 = *(void *)(*(void *)(a1 + 8) + 24);
    int v15 = OBJ_obj2nid(**(const ASN1_OBJECT ***)(v13 + 16));
    if ((v15 - 788) >= 3) {
      uint64_t v16 = 0;
    }
    else {
      uint64_t v16 = 8 * (v15 - 788) + 16;
    }
    if (v16 != *(void *)(v13 + 40))
    {
      int v19 = 118;
      int v20 = 765;
      goto LABEL_33;
    }
    if (**(int **)(v13 + 24) > 15)
    {
      if (!AES_set_decrypt_key(*(const unsigned __int8 **)(v13 + 32), 8 * v16, &size))
      {
        int v22 = (unsigned __int8 *)malloc_type_malloc(**(int **)(v13 + 24) - 8, 0xC8CB00B0uLL);
        if (v22)
        {
          int v26 = AES_unwrap_key(&size, 0, v22, *(const unsigned __int8 **)(*(void *)(v13 + 24) + 8), **(_DWORD **)(v13 + 24));
          if (v26 > 0)
          {
            unsigned int v27 = v26;
            freezero(*(void **)(v14 + 32), *(void *)(v14 + 40));
            *(void *)(v14 + 32) = v22;
            *(void *)(v14 + 40) = v27;
LABEL_40:
            explicit_bzero(&size, 0xF4uLL);
          }
          int v30 = 157;
          int v31 = 791;
        }
        else
        {
          int v30 = 65;
          int v31 = 783;
        }
        ERR_put_error(46, 4095, v30, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", v31);
LABEL_39:
        free(v22);
        goto LABEL_40;
      }
      int v17 = 115;
      int v18 = 777;
    }
    else
    {
      int v17 = 117;
      int v18 = 772;
    }
    ERR_put_error(46, 4095, v17, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", v18);
    int v22 = 0;
    goto LABEL_39;
  }
  return cms_RecipientInfo_pwri_crypt(a1, a2, 0);
}

EVP_CIPHER_CTX *CMS_RecipientInfo_encrypt(uint64_t a1, uint64_t a2)
{
  switch(*(_DWORD *)a2)
  {
    case 0:
      *(void *)size.rd_uint64_t key = 0;
      uint64_t v2 = *(void *)(a2 + 8);
      uint64_t v3 = *(void *)(*(void *)(a1 + 8) + 24);
      uint64_t v4 = *(uint64_t **)(v2 + 48);
      if (v4)
      {
        if (!cms_env_asn1_ctrl(a2)) {
          goto LABEL_29;
        }
      }
      else
      {
        int v11 = (uint64_t *)EVP_PKEY_CTX_new(*(void *)(v2 + 40), 0);
        if (!v11) {
          return 0;
        }
        uint64_t v4 = v11;
        if ((int)EVP_PKEY_encrypt_init(v11) < 1) {
          goto LABEL_29;
        }
      }
      if ((int)EVP_PKEY_CTX_ctrl(v4, -1, 256) <= 0)
      {
        ERR_put_error(46, 4095, 110, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 390);
        goto LABEL_29;
      }
      if (EVP_PKEY_encrypt((unsigned __int8 *)v4, 0, (int)&size, *(EVP_PKEY **)(v3 + 32)) < 1)
      {
LABEL_29:
        unint64_t v12 = 0;
        goto LABEL_30;
      }
      unint64_t v12 = malloc_type_malloc(*(size_t *)size.rd_key, 0xFD6232A5uLL);
      if (v12)
      {
        if (EVP_PKEY_encrypt((unsigned __int8 *)v4, (const unsigned __int8 *)v12, (int)&size, *(EVP_PKEY **)(v3 + 32)) >= 1)
        {
          ASN1_STRING_set0(*(ASN1_STRING **)(v2 + 24), v12, size.rd_key[0]);
          unint64_t v12 = 0;
          uint64_t v13 = 1;
          goto LABEL_31;
        }
      }
      else
      {
        ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 400);
      }
LABEL_30:
      uint64_t v13 = 0;
LABEL_31:
      EVP_PKEY_CTX_free((EVP_PKEY **)v4);
      *(void *)(v2 + 48) = 0;
      free(v12);
      return (EVP_CIPHER_CTX *)v13;
    case 1:
      return (EVP_CIPHER_CTX *)cms_RecipientInfo_kari_encrypt(a1, a2);
    case 2:
      memset(&size, 0, sizeof(size));
      uint64_t v8 = *(void *)(a2 + 8);
      if (!*(void *)(v8 + 32))
      {
        int v5 = 130;
        int v6 = 710;
LABEL_23:
        ERR_put_error(46, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", v6);
        return 0;
      }
      uint64_t v9 = *(void *)(*(void *)(a1 + 8) + 24);
      if (AES_set_encrypt_key(*(const unsigned __int8 **)(v8 + 32), 8 * *(_DWORD *)(v8 + 40), &size))
      {
        ERR_put_error(46, 4095, 115, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 715);
        int v10 = 0;
      }
      else
      {
        int v10 = (unsigned __int8 *)malloc_type_malloc(*(void *)(v9 + 40) + 8, 0x9E8967F1uLL);
        if (v10)
        {
          int v14 = AES_wrap_key(&size, 0, v10, *(const unsigned __int8 **)(v9 + 32), *(_DWORD *)(v9 + 40));
          if (v14 > 0)
          {
            ASN1_STRING_set0(*(ASN1_STRING **)(v8 + 24), v10, v14);
            goto LABEL_37;
          }
          int v15 = 159;
          int v16 = 727;
        }
        else
        {
          int v15 = 65;
          int v16 = 721;
        }
        ERR_put_error(46, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", v16);
      }
      free(v10);
LABEL_37:
      explicit_bzero(&size, 0xF4uLL);
    case 3:
      return cms_RecipientInfo_pwri_crypt(a1, a2, 1);
    default:
      int v5 = 154;
      int v6 = 846;
      goto LABEL_23;
  }
}

BIO *cms_EnvelopedData_init_bio(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 24);
  uint64_t inited = cms_EncryptedContent_init_bio(v2);
  if (!inited || !*(void *)(v2 + 24)) {
    return inited;
  }
  uint64_t v4 = *(const STACK **)(*(void *)(a1 + 8) + 16);
  if (sk_num(v4) < 1)
  {
LABEL_7:
    uint64_t v7 = *(void *)(a1 + 8);
    if (*(uint64_t *)v7 > 3) {
      goto LABEL_35;
    }
    uint64_t v8 = *(const STACK ***)(v7 + 8);
    if (v8)
    {
      if (sk_num(*v8) >= 1)
      {
        int v9 = 0;
        do
        {
          int v10 = *(_DWORD *)sk_value(*v8, v9);
          if (v10 == 3)
          {
            if (*(uint64_t *)v7 <= 2) {
              *(void *)uint64_t v7 = 3;
            }
          }
          else if (v10 == 4)
          {
            uint64_t v14 = 4;
            goto LABEL_34;
          }
          ++v9;
        }
        while (v9 < sk_num(*v8));
      }
      if (sk_num(v8[1]) >= 1)
      {
        int v11 = 0;
        uint64_t v14 = 4;
        do
        {
          if (*(_DWORD *)sk_value(v8[1], v11) == 1) {
            goto LABEL_34;
          }
          ++v11;
        }
        while (v11 < sk_num(v8[1]));
      }
    }
    if (*(uint64_t *)v7 > 2) {
      goto LABEL_35;
    }
    if (sk_num(*(const STACK **)(v7 + 16)) >= 1)
    {
      int v12 = 0;
      while (1)
      {
        uint64_t v13 = sk_value(*(const STACK **)(v7 + 16), v12);
        if (*(_DWORD *)v13) {
          break;
        }
        if (**((void **)v13 + 1)) {
          goto LABEL_28;
        }
LABEL_29:
        if (++v12 >= sk_num(*(const STACK **)(v7 + 16))) {
          goto LABEL_30;
        }
      }
      if ((*(_DWORD *)v13 - 3) < 2)
      {
        uint64_t v14 = 3;
        goto LABEL_34;
      }
LABEL_28:
      *(void *)uint64_t v7 = 2;
      goto LABEL_29;
    }
LABEL_30:
    if (*(void *)(v7 + 8) || *(void *)(v7 + 32))
    {
      uint64_t v14 = 2;
    }
    else
    {
      if (*(void *)v7 == 2) {
        goto LABEL_35;
      }
      uint64_t v14 = 0;
    }
LABEL_34:
    *(void *)uint64_t v7 = v14;
LABEL_35:
    *(void *)(v2 + 24) = 0;
    freezero(*(void **)(v2 + 32), *(void *)(v2 + 40));
    *(void *)(v2 + 32) = 0;
    *(void *)(v2 + 40) = 0;
    return inited;
  }
  int v5 = 0;
  while (1)
  {
    int v6 = sk_value(v4, v5);
    if ((int)CMS_RecipientInfo_encrypt(a1, (uint64_t)v6) <= 0) {
      break;
    }
    if (++v5 >= sk_num(v4)) {
      goto LABEL_7;
    }
  }
  ERR_put_error(46, 4095, 116, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_env.c", 945);
  *(void *)(v2 + 24) = 0;
  freezero(*(void **)(v2 + 32), *(void *)(v2 + 40));
  *(void *)(v2 + 32) = 0;
  *(void *)(v2 + 40) = 0;
  BIO_free(inited);
  return 0;
}

void *__cdecl PEM_ASN1_read_bio(d2i_of_void *d2i, const char *name, BIO *bp, void **x, pem_password_cb *cb, void *u)
{
  pleint n = 0;
  punsigned int data = 0;
  if (!PEM_bytes_read_bio(&pdata, &plen, 0, name, bp, cb, u)) {
    return 0;
  }
  int v12 = pdata;
  uint64_t v8 = (void *)((uint64_t (*)(void **, unsigned __int8 **, uint64_t))d2i)(x, &v12, plen);
  if (!v8) {
    ERR_put_error(9, 4095, 13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_oth.c", 84);
  }
  free(pdata);
  return v8;
}

int RSA_padding_add_X931(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl)
{
  unsigned int v4 = tlen - fl;
  if (tlen - fl > 1)
  {
    uint64_t v8 = to;
    if (v4 == 2)
    {
      char v9 = 106;
    }
    else
    {
      *to = 107;
      uint64_t v8 = to + 1;
      if (v4 >= 4)
      {
        size_t v10 = v4 - 3;
        memset(v8, 187, v10);
        v8 += v10;
      }
      char v9 = -70;
    }
    *uint64_t v8 = v9;
    int v11 = v8 + 1;
    memcpy(v11, f, fl);
    *((unsigned char *)v11 + fl) = -52;
    return 1;
  }
  else
  {
    ERR_put_error(4, 4095, 110, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_x931.c", 81);
    return -1;
  }
}

int RSA_padding_check_X931(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl, int rsa_len)
{
  if (rsa_len == fl)
  {
    int v5 = *f;
    if ((v5 & 0xFE) == 0x6A)
    {
      if (v5 == 107)
      {
        if (rsa_len < 4)
        {
LABEL_20:
          int v10 = 138;
          int v11 = 129;
          goto LABEL_10;
        }
        uint64_t v6 = 0;
        int v7 = rsa_len - 3;
        uint64_t v8 = &f[rsa_len - 4 + 2];
        while (1)
        {
          int v9 = f[v6 + 1];
          if (v9 != 187) {
            break;
          }
          if (v7 == ++v6)
          {
            LODWORD(v6) = rsa_len - 3;
            goto LABEL_17;
          }
        }
        if (v9 != 186)
        {
          int v10 = 138;
          int v11 = 123;
          goto LABEL_10;
        }
        uint64_t v8 = &f[v6 + 2];
LABEL_17:
        if (!v6) {
          goto LABEL_20;
        }
        unsigned int v12 = v7 - v6;
        if (v7 - v6 < 0) {
          goto LABEL_19;
        }
      }
      else
      {
        uint64_t v8 = f + 1;
        unsigned int v12 = rsa_len - 2;
        if (rsa_len - 2 < 0)
        {
LABEL_19:
          int v10 = 139;
          int v11 = 138;
          goto LABEL_10;
        }
      }
      if (v8[v12] == 204)
      {
        memcpy(to, v8, v12);
        return v12;
      }
      goto LABEL_19;
    }
  }
  int v10 = 137;
  int v11 = 112;
LABEL_10:
  ERR_put_error(4, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_x931.c", v11);
  return -1;
}

int RSA_X931_hash_id(int nid)
{
  if (nid > 672)
  {
    if (nid != 673)
    {
      if (nid == 674) {
        return 53;
      }
      return -1;
    }
    return 54;
  }
  else
  {
    if (nid != 64)
    {
      if (nid == 672) {
        return 52;
      }
      return -1;
    }
    return 51;
  }
}

const EVP_CIPHER *EVP_des_ede_cbc(void)
{
  return (const EVP_CIPHER *)&des_ede_cbc;
}

const EVP_CIPHER *EVP_des_ede_cfb64(void)
{
  return (const EVP_CIPHER *)&des_ede_cfb64;
}

const EVP_CIPHER *EVP_des_ede_ofb(void)
{
  return (const EVP_CIPHER *)&des_ede_ofb;
}

const EVP_CIPHER *EVP_des_ede_ecb(void)
{
  return (const EVP_CIPHER *)&des_ede_ecb;
}

const EVP_CIPHER *EVP_des_ede3_cbc(void)
{
  return (const EVP_CIPHER *)&des_ede3_cbc;
}

const EVP_CIPHER *EVP_des_ede3_cfb64(void)
{
  return (const EVP_CIPHER *)&des_ede3_cfb64;
}

const EVP_CIPHER *EVP_des_ede3_ofb(void)
{
  return (const EVP_CIPHER *)&des_ede3_ofb;
}

const EVP_CIPHER *EVP_des_ede3_ecb(void)
{
  return (const EVP_CIPHER *)&des_ede3_ecb;
}

const EVP_CIPHER *EVP_des_ede3_cfb1(void)
{
  return (const EVP_CIPHER *)&des_ede3_cfb1;
}

const EVP_CIPHER *EVP_des_ede3_cfb8(void)
{
  return (const EVP_CIPHER *)&des_ede3_cfb8;
}

const EVP_CIPHER *EVP_des_ede(void)
{
  return (const EVP_CIPHER *)&des_ede_ecb;
}

const EVP_CIPHER *EVP_des_ede3(void)
{
  return (const EVP_CIPHER *)&des_ede3_ecb;
}

uint64_t des_ede_init_key(uint64_t a1, const_DES_cblock *key)
{
  DES_set_key_unchecked(key, *(DES_key_schedule **)(a1 + 120));
  DES_set_key_unchecked((const_DES_cblock *)&(*key)[8], (DES_key_schedule *)(*(void *)(a1 + 120) + 128));
  unsigned int v4 = *(_OWORD **)(a1 + 120);
  long long v5 = v4[5];
  v4[20] = v4[4];
  v4[21] = v5;
  long long v6 = v4[7];
  v4[22] = v4[6];
  v4[23] = v6;
  long long v7 = v4[1];
  v4[16] = *v4;
  v4[17] = v7;
  long long v8 = v4[3];
  v4[18] = v4[2];
  v4[19] = v8;
  return 1;
}

uint64_t des_ede_cbc_cipher(uint64_t a1, unsigned __int8 *output, unsigned __int8 *input, unint64_t length)
{
  for (unint64_t i = length; i > 0x7FFFFFFFFFFFFEFFLL; output += 0x7FFFFFFFFFFFFF00)
  {
    DES_ede3_cbc_encrypt(input, output, 0x7FFFFFFFFFFFFF00, *(DES_key_schedule **)(a1 + 120), (DES_key_schedule *)(*(void *)(a1 + 120) + 128), (DES_key_schedule *)(*(void *)(a1 + 120) + 256), (DES_cblock *)(a1 + 40), *(_DWORD *)(a1 + 16));
    i -= 0x7FFFFFFFFFFFFF00;
    input += 0x7FFFFFFFFFFFFF00;
  }
  if (i) {
    DES_ede3_cbc_encrypt(input, output, i, *(DES_key_schedule **)(a1 + 120), (DES_key_schedule *)(*(void *)(a1 + 120) + 128), (DES_key_schedule *)(*(void *)(a1 + 120) + 256), (DES_cblock *)(a1 + 40), *(_DWORD *)(a1 + 16));
  }
  return 1;
}

uint64_t des3_ctrl(uint64_t a1, int a2, int a3, DES_cblock *ret)
{
  if (a2 != 6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = DES_random_key(ret);
  if (result)
  {
    if (*(int *)(a1 + 104) < 16) {
      return 1;
    }
    uint64_t result = DES_random_key((DES_cblock *)&(*ret)[8]);
    if (result)
    {
      if (*(int *)(a1 + 104) < 24) {
        return 1;
      }
      uint64_t result = DES_random_key((DES_cblock *)&(*ret)[16]);
      if (result) {
        return 1;
      }
    }
  }
  return result;
}

uint64_t des_ede_cfb64_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t length)
{
  for (unint64_t i = length; i > 0x7FFFFFFFFFFFFEFFLL; out += 0x7FFFFFFFFFFFFF00)
  {
    DES_ede3_cfb64_encrypt(in, out, 0x7FFFFFFFFFFFFF00, *(DES_key_schedule **)(a1 + 120), (DES_key_schedule *)(*(void *)(a1 + 120) + 128), (DES_key_schedule *)(*(void *)(a1 + 120) + 256), (DES_cblock *)(a1 + 40), (int *)(a1 + 88), *(_DWORD *)(a1 + 16));
    i -= 0x7FFFFFFFFFFFFF00;
    in += 0x7FFFFFFFFFFFFF00;
  }
  if (i) {
    DES_ede3_cfb64_encrypt(in, out, i, *(DES_key_schedule **)(a1 + 120), (DES_key_schedule *)(*(void *)(a1 + 120) + 128), (DES_key_schedule *)(*(void *)(a1 + 120) + 256), (DES_cblock *)(a1 + 40), (int *)(a1 + 88), *(_DWORD *)(a1 + 16));
  }
  return 1;
}

uint64_t des_ede_ofb_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t length)
{
  for (unint64_t i = length; i > 0x7FFFFFFFFFFFFEFFLL; out += 0x7FFFFFFFFFFFFF00)
  {
    DES_ede3_ofb64_encrypt(in, out, 0x7FFFFFFFFFFFFF00, *(DES_key_schedule **)(a1 + 120), (DES_key_schedule *)(*(void *)(a1 + 120) + 128), (DES_key_schedule *)(*(void *)(a1 + 120) + 256), (DES_cblock *)(a1 + 40), (int *)(a1 + 88));
    i -= 0x7FFFFFFFFFFFFF00;
    in += 0x7FFFFFFFFFFFFF00;
  }
  if (i) {
    DES_ede3_ofb64_encrypt(in, out, i, *(DES_key_schedule **)(a1 + 120), (DES_key_schedule *)(*(void *)(a1 + 120) + 128), (DES_key_schedule *)(*(void *)(a1 + 120) + 256), (DES_cblock *)(a1 + 40), (int *)(a1 + 88));
  }
  return 1;
}

uint64_t des_ede_ecb_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4 = *(int *)(*(void *)a1 + 4);
  unint64_t v5 = a4 - v4;
  if (a4 >= v4)
  {
    unint64_t v9 = 0;
    do
    {
      DES_ecb3_encrypt((const_DES_cblock *)(a3 + v9), (DES_cblock *)(a2 + v9), *(DES_key_schedule **)(a1 + 120), (DES_key_schedule *)(*(void *)(a1 + 120) + 128), (DES_key_schedule *)(*(void *)(a1 + 120) + 256), *(_DWORD *)(a1 + 16));
      v9 += v4;
    }
    while (v9 <= v5);
  }
  return 1;
}

uint64_t des_ede3_init_key(uint64_t a1, const_DES_cblock *key)
{
  return 1;
}

uint64_t des_ede3_cfb1_cipher(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((*(unsigned char *)(a1 + 113) & 0x20) != 0) {
    uint64_t v4 = a4;
  }
  else {
    uint64_t v4 = 8 * a4;
  }
  if (v4)
  {
    unint64_t v8 = 0;
    unint64_t v9 = (DES_cblock *)(a1 + 40);
    do
    {
      iint n = *(unsigned __int8 *)(a3 + (v8 >> 3)) >> (v8 & 7 ^ 7) << 7;
      DES_ede3_cfb_encrypt(&in, &out, 1, 1, *(DES_key_schedule **)(a1 + 120), (DES_key_schedule *)(*(void *)(a1 + 120) + 128), (DES_key_schedule *)(*(void *)(a1 + 120) + 256), v9, *(_DWORD *)(a1 + 16));
      *(unsigned char *)(a2 + (v8 >> 3)) = ((out & 0x80) >> (v8 & 7)) | (-129 >> (v8 & 7)) & *(unsigned char *)(a2 + (v8 >> 3));
      ++v8;
    }
    while (v4 != v8);
  }
  return 1;
}

uint64_t des_ede3_cfb8_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t length)
{
  for (unint64_t i = length; i > 0x7FFFFFFFFFFFFEFFLL; out += 0x7FFFFFFFFFFFFF00)
  {
    DES_ede3_cfb_encrypt(in, out, 8, 0x7FFFFFFFFFFFFF00, *(DES_key_schedule **)(a1 + 120), (DES_key_schedule *)(*(void *)(a1 + 120) + 128), (DES_key_schedule *)(*(void *)(a1 + 120) + 256), (DES_cblock *)(a1 + 40), *(_DWORD *)(a1 + 16));
    i -= 0x7FFFFFFFFFFFFF00;
    in += 0x7FFFFFFFFFFFFF00;
  }
  if (i) {
    DES_ede3_cfb_encrypt(in, out, 8, i, *(DES_key_schedule **)(a1 + 120), (DES_key_schedule *)(*(void *)(a1 + 120) + 128), (DES_key_schedule *)(*(void *)(a1 + 120) + 256), (DES_cblock *)(a1 + 40), *(_DWORD *)(a1 + 16));
  }
  return 1;
}

void OPENSSL_load_builtin_modules(void)
{
  ASN1_add_oid_module();
  ENGINE_add_conf_module();
}

uint64_t DH_check_params_ex(uint64_t a1)
{
  int v3 = 0;
  uint64_t result = DH_check_params(a1, &v3);
  if (result)
  {
    int v2 = v3;
    if (v3) {
      ERR_put_error(5, 4095, 117, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_check.c", 84);
    }
    if ((v2 & 8) != 0) {
      ERR_put_error(5, 4095, 120, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_check.c", 86);
    }
    return v2 == 0;
  }
  return result;
}

uint64_t DH_check_params(uint64_t a1, _DWORD *a2)
{
  *a2 = 0;
  if (!BN_is_odd(*(void *)(a1 + 8))) {
    *a2 |= 1u;
  }
  uint64_t v4 = *(const BIGNUM **)(a1 + 16);
  unint64_t v5 = BN_value_one();
  if (BN_cmp(v4, v5) <= 0) {
    *a2 |= 8u;
  }
  long long v6 = BN_dup(*(const BIGNUM **)(a1 + 8));
  long long v7 = v6;
  if (v6 && BN_sub_word(v6, 1uLL))
  {
    if ((BN_cmp(*(const BIGNUM **)(a1 + 16), v7) & 0x80000000) == 0) {
      *a2 |= 8u;
    }
    uint64_t v8 = 1;
  }
  else
  {
    uint64_t v8 = 0;
  }
  BN_free(v7);
  return v8;
}

uint64_t DH_check_ex(const DH *a1)
{
  int codes = 0;
  uint64_t result = DH_check(a1, &codes);
  if (result)
  {
    int v2 = codes;
    if ((codes & 8) != 0)
    {
      ERR_put_error(5, 4095, 120, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_check.c", 139);
      if ((v2 & 0x10) == 0)
      {
LABEL_4:
        if ((v2 & 0x20) == 0) {
          goto LABEL_5;
        }
        goto LABEL_14;
      }
    }
    else if ((codes & 0x10) == 0)
    {
      goto LABEL_4;
    }
    ERR_put_error(5, 4095, 119, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_check.c", 141);
    if ((v2 & 0x20) == 0)
    {
LABEL_5:
      if ((v2 & 0x40) == 0) {
        goto LABEL_6;
      }
      goto LABEL_15;
    }
LABEL_14:
    ERR_put_error(5, 4095, 116, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_check.c", 143);
    if ((v2 & 0x40) == 0)
    {
LABEL_6:
      if ((v2 & 4) == 0) {
        goto LABEL_7;
      }
      goto LABEL_16;
    }
LABEL_15:
    ERR_put_error(5, 4095, 115, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_check.c", 145);
    if ((v2 & 4) == 0)
    {
LABEL_7:
      if ((v2 & 1) == 0) {
        goto LABEL_8;
      }
      goto LABEL_17;
    }
LABEL_16:
    ERR_put_error(5, 4095, 121, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_check.c", 147);
    if ((v2 & 1) == 0)
    {
LABEL_8:
      if ((v2 & 2) == 0) {
        return v2 == 0;
      }
LABEL_9:
      ERR_put_error(5, 4095, 118, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_check.c", 151);
      return v2 == 0;
    }
LABEL_17:
    ERR_put_error(5, 4095, 117, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_check.c", 149);
    if ((v2 & 2) == 0) {
      return v2 == 0;
    }
    goto LABEL_9;
  }
  return result;
}

int DH_check(const DH *dh, int *codes)
{
  *int codes = 0;
  if (!DH_check_params((uint64_t)dh, codes))
  {
    unint64_t v5 = 0;
    goto LABEL_28;
  }
  uint64_t v4 = BN_CTX_new();
  unint64_t v5 = v4;
  if (v4)
  {
    BN_CTX_start(v4);
    if (dh->q)
    {
      long long v6 = BN_CTX_get(v5);
      if (!v6) {
        goto LABEL_28;
      }
      long long v7 = v6;
      uint64_t v8 = BN_CTX_get(v5);
      if (!v8) {
        goto LABEL_28;
      }
      unint64_t v9 = v8;
      if ((*(unsigned char *)codes & 8) == 0)
      {
        if (!BN_mod_exp_ct(v8, dh->g, dh->q, dh->p, v5)) {
          goto LABEL_28;
        }
        if (!BN_is_one((uint64_t)v9)) {
          *codes |= 8u;
        }
      }
      int is_prime = BN_is_prime_ex(dh->q, 64, v5, 0);
      if (is_prime < 0) {
        goto LABEL_28;
      }
      if (!is_prime) {
        *codes |= 0x10u;
      }
      if (!BN_div_ct((uint64_t)v7, v9, dh->p, dh->q, v5)) {
        goto LABEL_28;
      }
      if (!BN_is_one((uint64_t)v9)) {
        *codes |= 0x20u;
      }
      int j = dh->j;
      if (j && BN_cmp(j, v7)) {
        *codes |= 0x40u;
      }
    }
    int v12 = BN_is_prime_ex(dh->p, 64, v5, 0);
    if ((v12 & 0x80000000) == 0)
    {
      if (!v12)
      {
        int v16 = 1;
        goto LABEL_31;
      }
      if (dh->q)
      {
LABEL_32:
        int v17 = 1;
        goto LABEL_29;
      }
      uint64_t v13 = BN_CTX_get(v5);
      if (v13)
      {
        uint64_t v14 = v13;
        if (BN_rshift1(v13, dh->p))
        {
          int v15 = BN_is_prime_ex(v14, 64, v5, 0);
          if ((v15 & 0x80000000) == 0)
          {
            if (!v15)
            {
              int v16 = 2;
LABEL_31:
              *codes |= v16;
              goto LABEL_32;
            }
            goto LABEL_32;
          }
        }
      }
    }
  }
LABEL_28:
  int v17 = 0;
LABEL_29:
  BN_CTX_end(v5);
  BN_CTX_free(v5);
  return v17;
}

uint64_t DH_check_pub_key_ex(const DH *a1, const BIGNUM *a2)
{
  int codes = 0;
  uint64_t result = DH_check_pub_key(a1, a2, &codes);
  if (result)
  {
    int v3 = codes;
    if (codes)
    {
      ERR_put_error(5, 4095, 124, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_check.c", 240);
      if ((v3 & 2) == 0)
      {
LABEL_4:
        if ((v3 & 4) == 0) {
          return v3 == 0;
        }
LABEL_5:
        ERR_put_error(5, 4095, 122, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_check.c", 244);
        return v3 == 0;
      }
    }
    else if ((codes & 2) == 0)
    {
      goto LABEL_4;
    }
    ERR_put_error(5, 4095, 123, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_check.c", 242);
    if ((v3 & 4) == 0) {
      return v3 == 0;
    }
    goto LABEL_5;
  }
  return result;
}

int DH_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *codes)
{
  *int codes = 0;
  long long v6 = BN_CTX_new();
  long long v7 = v6;
  if (!v6) {
    goto LABEL_14;
  }
  BN_CTX_start(v6);
  uint64_t v8 = BN_CTX_get(v7);
  if (!v8) {
    goto LABEL_14;
  }
  unint64_t v9 = v8;
  int v10 = BN_value_one();
  if (BN_cmp(pub_key, v10) <= 0) {
    *codes |= 1u;
  }
  p = dh->p;
  int v12 = BN_value_one();
  if (!BN_sub(v9, p, v12)) {
    goto LABEL_14;
  }
  if ((BN_cmp(pub_key, v9) & 0x80000000) == 0) {
    *codes |= 2u;
  }
  if (!dh->q) {
    goto LABEL_13;
  }
  uint64_t v13 = BN_CTX_get(v7);
  if (!v13 || (uint64_t v14 = (uint64_t)v13, !BN_mod_exp_ct(v13, pub_key, dh->q, dh->p, v7)))
  {
LABEL_14:
    int v15 = 0;
    goto LABEL_15;
  }
  if (!BN_is_one(v14)) {
    *int codes = 4;
  }
LABEL_13:
  int v15 = 1;
LABEL_15:
  BN_CTX_end(v7);
  BN_CTX_free(v7);
  return v15;
}

void BF_set_key(BF_KEY *key, int len, const unsigned __int8 *data)
{
  v25[1] = *MEMORY[0x263EF8340];
  memcpy(key, &bf_init, sizeof(BF_KEY));
  uint64_t v6 = 0;
  if (len >= 72) {
    int v7 = 72;
  }
  else {
    int v7 = len;
  }
  uint64_t v8 = &data[v7];
  unint64_t v9 = data;
  do
  {
    int v12 = *v9;
    int v10 = v9 + 1;
    int v11 = v12;
    if (v10 >= v8) {
      int v10 = data;
    }
    int v15 = *v10;
    uint64_t v13 = v10 + 1;
    int v14 = v15;
    if (v13 >= v8) {
      uint64_t v13 = data;
    }
    int v17 = *v13;
    int v16 = v13 + 1;
    int v18 = (v11 << 16) | (v14 << 8) | v17;
    if (v16 >= v8) {
      int v16 = data;
    }
    int v19 = *v16;
    unint64_t v9 = v16 + 1;
    int v20 = v19 | (v18 << 8);
    if (v9 >= v8) {
      unint64_t v9 = data;
    }
    key->P[v6++] ^= v20;
  }
  while (v6 != 18);
  v25[0] = 0;
  unint64_t v21 = -2;
  int v22 = key;
  do
  {
    BF_encrypt((unsigned int *)v25, key);
    *(void *)v22->P = v25[0];
    int v22 = (BF_KEY *)((char *)v22 + 8);
    v21 += 2;
  }
  while (v21 < 0x10);
  unint64_t v23 = -2;
  uint64_t v24 = 18;
  do
  {
    BF_encrypt((unsigned int *)v25, key);
    *(void *)&key->P[v24] = v25[0];
    v23 += 2;
    v24 += 2;
  }
  while (v23 < 0x3FE);
}

void ERR_load_PEM_strings(void)
{
  if (!ERR_func_error_string(PEM_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&PEM_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&PEM_str_reasons);
  }
}

PBEPARAM *__cdecl d2i_PBEPARAM(PBEPARAM **a, const unsigned __int8 **in, uint64_t len)
{
  return (PBEPARAM *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PBEPARAM_it);
}

int i2d_PBEPARAM(PBEPARAM *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PBEPARAM_it);
}

PBEPARAM *PBEPARAM_new(void)
{
  return (PBEPARAM *)ASN1_item_new(&PBEPARAM_it);
}

void PBEPARAM_free(PBEPARAM *a)
{
}

uint64_t PKCS5_pbe_set0_algor(X509_ALGOR *a1, int a2, int a3, const void *a4, int a5)
{
  oct = 0;
  int v10 = ASN1_item_new(&PBEPARAM_it);
  if (!v10)
  {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/p5_pbe.c", 130);
    goto LABEL_20;
  }
  int v11 = v10;
  if (a3 >= 1) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = 2048;
  }
  if (!ASN1_INTEGER_set(*((ASN1_INTEGER **)v10 + 1), v12))
  {
    int v14 = 136;
LABEL_19:
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/p5_pbe.c", v14);
    ASN1_item_free(v11, &PBEPARAM_it);
    goto LABEL_20;
  }
  if (!a5) {
    a5 = 8;
  }
  if (!ASN1_STRING_set(*(ASN1_STRING **)v11, 0, a5))
  {
    int v14 = 142;
    goto LABEL_19;
  }
  uint64_t v13 = ASN1_STRING_data(*(ASN1_STRING **)v11);
  if (a4) {
    memcpy(v13, a4, a5);
  }
  else {
    arc4random_buf(v13, a5);
  }
  if (!ASN1_item_pack(v11, &PBEPARAM_it, &oct))
  {
    int v14 = 152;
    goto LABEL_19;
  }
  ASN1_item_free(v11, &PBEPARAM_it);
  int v15 = OBJ_nid2obj(a2);
  if (X509_ALGOR_set0(a1, v15, 16, oct)) {
    return 1;
  }
LABEL_20:
  ASN1_STRING_free(oct);
  return 0;
}

X509_ALGOR *__cdecl PKCS5_pbe_set(int alg, int iter, unsigned __int8 *salt, int saltlen)
{
  uint64_t v8 = X509_ALGOR_new();
  unint64_t v9 = v8;
  if (v8)
  {
    if (!PKCS5_pbe_set0_algor(v8, alg, iter, salt, saltlen))
    {
      X509_ALGOR_free(v9);
      return 0;
    }
  }
  else
  {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/p5_pbe.c", 177);
  }
  return v9;
}

PKCS7 *__cdecl d2i_PKCS7(PKCS7 **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS7 *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS7_it);
}

int i2d_PKCS7(PKCS7 *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_it);
}

PKCS7 *PKCS7_new(void)
{
  return (PKCS7 *)ASN1_item_new(&PKCS7_it);
}

void PKCS7_free(PKCS7 *a)
{
}

PKCS7 *__cdecl PKCS7_dup(PKCS7 *p7)
{
  return (PKCS7 *)ASN1_item_dup(&PKCS7_it, p7);
}

PKCS7_SIGNED *__cdecl d2i_PKCS7_SIGNED(PKCS7_SIGNED **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS7_SIGNED *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS7_SIGNED_it);
}

int i2d_PKCS7_SIGNED(PKCS7_SIGNED *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_SIGNED_it);
}

PKCS7_SIGNED *PKCS7_SIGNED_new(void)
{
  return (PKCS7_SIGNED *)ASN1_item_new(&PKCS7_SIGNED_it);
}

void PKCS7_SIGNED_free(PKCS7_SIGNED *a)
{
}

PKCS7_SIGNER_INFO *__cdecl d2i_PKCS7_SIGNER_INFO(PKCS7_SIGNER_INFO **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS7_SIGNER_INFO *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS7_SIGNER_INFO_it);
}

int i2d_PKCS7_SIGNER_INFO(PKCS7_SIGNER_INFO *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_SIGNER_INFO_it);
}

PKCS7_SIGNER_INFO *PKCS7_SIGNER_INFO_new(void)
{
  return (PKCS7_SIGNER_INFO *)ASN1_item_new(&PKCS7_SIGNER_INFO_it);
}

void PKCS7_SIGNER_INFO_free(PKCS7_SIGNER_INFO *a)
{
}

PKCS7_ISSUER_AND_SERIAL *__cdecl d2i_PKCS7_ISSUER_AND_SERIAL(PKCS7_ISSUER_AND_SERIAL **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS7_ISSUER_AND_SERIAL *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS7_ISSUER_AND_SERIAL_it);
}

int i2d_PKCS7_ISSUER_AND_SERIAL(PKCS7_ISSUER_AND_SERIAL *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_ISSUER_AND_SERIAL_it);
}

PKCS7_ISSUER_AND_SERIAL *PKCS7_ISSUER_AND_SERIAL_new(void)
{
  return (PKCS7_ISSUER_AND_SERIAL *)ASN1_item_new(&PKCS7_ISSUER_AND_SERIAL_it);
}

void PKCS7_ISSUER_AND_SERIAL_free(PKCS7_ISSUER_AND_SERIAL *a)
{
}

PKCS7_ENVELOPE *__cdecl d2i_PKCS7_ENVELOPE(PKCS7_ENVELOPE **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS7_ENVELOPE *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS7_ENVELOPE_it);
}

int i2d_PKCS7_ENVELOPE(PKCS7_ENVELOPE *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_ENVELOPE_it);
}

PKCS7_ENVELOPE *PKCS7_ENVELOPE_new(void)
{
  return (PKCS7_ENVELOPE *)ASN1_item_new(&PKCS7_ENVELOPE_it);
}

void PKCS7_ENVELOPE_free(PKCS7_ENVELOPE *a)
{
}

PKCS7_RECIP_INFO *__cdecl d2i_PKCS7_RECIP_INFO(PKCS7_RECIP_INFO **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS7_RECIP_INFO *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS7_RECIP_INFO_it);
}

int i2d_PKCS7_RECIP_INFO(PKCS7_RECIP_INFO *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_RECIP_INFO_it);
}

PKCS7_RECIP_INFO *PKCS7_RECIP_INFO_new(void)
{
  return (PKCS7_RECIP_INFO *)ASN1_item_new(&PKCS7_RECIP_INFO_it);
}

void PKCS7_RECIP_INFO_free(PKCS7_RECIP_INFO *a)
{
}

PKCS7_ENC_CONTENT *__cdecl d2i_PKCS7_ENC_CONTENT(PKCS7_ENC_CONTENT **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS7_ENC_CONTENT *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS7_ENC_CONTENT_it);
}

int i2d_PKCS7_ENC_CONTENT(PKCS7_ENC_CONTENT *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_ENC_CONTENT_it);
}

PKCS7_ENC_CONTENT *PKCS7_ENC_CONTENT_new(void)
{
  return (PKCS7_ENC_CONTENT *)ASN1_item_new(&PKCS7_ENC_CONTENT_it);
}

void PKCS7_ENC_CONTENT_free(PKCS7_ENC_CONTENT *a)
{
}

PKCS7_SIGN_ENVELOPE *__cdecl d2i_PKCS7_SIGN_ENVELOPE(PKCS7_SIGN_ENVELOPE **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS7_SIGN_ENVELOPE *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS7_SIGN_ENVELOPE_it);
}

int i2d_PKCS7_SIGN_ENVELOPE(PKCS7_SIGN_ENVELOPE *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_SIGN_ENVELOPE_it);
}

PKCS7_SIGN_ENVELOPE *PKCS7_SIGN_ENVELOPE_new(void)
{
  return (PKCS7_SIGN_ENVELOPE *)ASN1_item_new(&PKCS7_SIGN_ENVELOPE_it);
}

void PKCS7_SIGN_ENVELOPE_free(PKCS7_SIGN_ENVELOPE *a)
{
}

PKCS7_ENCRYPT *__cdecl d2i_PKCS7_ENCRYPT(PKCS7_ENCRYPT **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS7_ENCRYPT *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS7_ENCRYPT_it);
}

int i2d_PKCS7_ENCRYPT(PKCS7_ENCRYPT *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_ENCRYPT_it);
}

PKCS7_ENCRYPT *PKCS7_ENCRYPT_new(void)
{
  return (PKCS7_ENCRYPT *)ASN1_item_new(&PKCS7_ENCRYPT_it);
}

void PKCS7_ENCRYPT_free(PKCS7_ENCRYPT *a)
{
}

PKCS7_DIGEST *__cdecl d2i_PKCS7_DIGEST(PKCS7_DIGEST **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS7_DIGEST *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS7_DIGEST_it);
}

int i2d_PKCS7_DIGEST(PKCS7_DIGEST *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS7_DIGEST_it);
}

PKCS7_DIGEST *PKCS7_DIGEST_new(void)
{
  return (PKCS7_DIGEST *)ASN1_item_new(&PKCS7_DIGEST_it);
}

void PKCS7_DIGEST_free(PKCS7_DIGEST *a)
{
}

uint64_t PKCS7_print_ctx(BIO *a1, ASN1_VALUE *a2, uint64_t a3, uint64_t *a4)
{
  return ASN1_item_print(a1, a2, a3, (ASN1_ITEM *)&PKCS7_it, a4);
}

PKCS7 *__cdecl d2i_PKCS7_bio(BIO *bp, PKCS7 **p7)
{
  return (PKCS7 *)ASN1_item_d2i_bio(&PKCS7_it, bp, p7);
}

int i2d_PKCS7_bio(BIO *bp, PKCS7 *p7)
{
  return ASN1_item_i2d_bio(&PKCS7_it, bp, p7);
}

PKCS7 *__cdecl d2i_PKCS7_fp(FILE *fp, PKCS7 **p7)
{
  return (PKCS7 *)ASN1_item_d2i_fp(&PKCS7_it, fp, p7);
}

int i2d_PKCS7_fp(FILE *fp, PKCS7 *p7)
{
  return ASN1_item_i2d_fp(&PKCS7_it, fp, p7);
}

int PKCS7_ISSUER_AND_SERIAL_digest(PKCS7_ISSUER_AND_SERIAL *data, const EVP_MD *type, unsigned __int8 *md, unsigned int *len)
{
  return ASN1_item_digest(&PKCS7_ISSUER_AND_SERIAL_it, type, data, md, len);
}

uint64_t pk7_cb(int a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  switch(a1)
  {
    case 10:
      if ((int)PKCS7_stream((void *)(a4 + 16), *a2) < 1) {
        goto LABEL_7;
      }
      goto LABEL_5;
    case 11:
    case 13:
      if (PKCS7_dataFinal((PKCS7 *)*a2, *(BIO **)(a4 + 8)) >= 1) {
        goto LABEL_6;
      }
LABEL_7:
      uint64_t result = 0;
      break;
    case 12:
LABEL_5:
      uint64_t result = (uint64_t)PKCS7_dataInit((PKCS7 *)*a2, *(BIO **)a4);
      *(void *)(a4 + 8) = result;
      if (result) {
        goto LABEL_6;
      }
      return result;
    default:
LABEL_6:
      uint64_t result = 1;
      break;
  }
  return result;
}

uint64_t si_cb(int a1, uint64_t a2)
{
  if (a1 == 3) {
    EVP_PKEY_free(*(EVP_PKEY **)(*(void *)a2 + 56));
  }
  return 1;
}

uint64_t ri_cb(int a1, uint64_t a2)
{
  if (a1 == 3) {
    X509_free(*(X509 **)(*(void *)a2 + 32));
  }
  return 1;
}

uint64_t HKDF(uint64_t a1, size_t a2, EVP_MD *a3, const unsigned __int8 *a4, size_t a5, void *a6, int a7, const unsigned __int8 *a8, size_t a9)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v14 = 0;
  uint64_t result = HKDF_extract(md, &v14, a3, a4, a5, a6, a7);
  if (result) {
    return HKDF_expand(a1, a2, a3, md, v14, a8, a9) != 0;
  }
  return result;
}

uint64_t HKDF_extract(unsigned __int8 *md, void *a2, EVP_MD *evp_md, const unsigned __int8 *a4, size_t a5, void *key, int key_len)
{
  md_leint n = 0;
  if (HMAC(evp_md, key, key_len, a4, a5, md, &md_len))
  {
    *a2 = md_len;
    return 1;
  }
  else
  {
    ERR_put_error(15, 4095, 15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/hkdf/hkdf.c", 60);
    return 0;
  }
}

uint64_t HKDF_expand(uint64_t a1, size_t a2, EVP_MD *md, const void *a4, int a5, const unsigned __int8 *a6, size_t a7)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  int v14 = EVP_MD_size(md);
  size_t v15 = a2 + v14;
  if (!__CFADD__(a2, v14))
  {
    size_t v16 = v14;
    size_t v17 = v15 - 1;
    unint64_t v18 = (v15 - 1) / v14;
    if (v18 < 0x100)
    {
      long long v34 = 0u;
      long long v35 = 0u;
      long long v32 = 0u;
      long long v33 = 0u;
      memset(&ctx, 0, sizeof(ctx));
      HMAC_CTX_init(&ctx);
      HMAC_Init_ex(&ctx, a4, a5, md, 0);
      if (v19 && v17 >= v16)
      {
        uint64_t v20 = 0;
        unsigned int v21 = 1;
        do
        {
          unsigned __int8 v30 = v21;
          if (v21 != 1)
          {
            HMAC_Init_ex(&ctx, 0, 0, 0, 0);
            if (!v22) {
              break;
            }
            HMAC_Update(&ctx, data, v16);
            if (!v23) {
              break;
            }
          }
          HMAC_Update(&ctx, a6, a7);
          if (!v24) {
            break;
          }
          HMAC_Update(&ctx, &v30, 1uLL);
          if (!v25) {
            break;
          }
          HMAC_Final(&ctx, data, 0);
          if (!v26) {
            break;
          }
          size_t v27 = v20 + v16 <= a2 ? v16 : a2 - v20;
          memcpy((void *)(a1 + v20), data, v27);
          v20 += v27;
        }
        while (v18 > v21++);
      }
      HMAC_CTX_cleanup(&ctx);
      explicit_bzero(data, 0x40uLL);
    }
  }
  ERR_put_error(15, 4095, 164, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/hkdf/hkdf.c", 83);
  return 0;
}

X509_CERT_AUX *__cdecl d2i_X509_CERT_AUX(X509_CERT_AUX **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_CERT_AUX *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_CERT_AUX_it);
}

int i2d_X509_CERT_AUX(X509_CERT_AUX *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_CERT_AUX_it);
}

X509_CERT_AUX *X509_CERT_AUX_new(void)
{
  return (X509_CERT_AUX *)ASN1_item_new(&X509_CERT_AUX_it);
}

void X509_CERT_AUX_free(X509_CERT_AUX *a)
{
}

int X509_alias_set1(X509 *x, unsigned __int8 *name, int len)
{
  if (name)
  {
    if (x)
    {
      ex_pcpathleint n = x[1].ex_pcpathlen;
      if (ex_pcpathlen
        || (int v7 = (ASN1_STRING *)ASN1_item_new(&X509_CERT_AUX_it),
            ex_pcpathleint n = (uint64_t)v7,
            (x[1].ex_pcpathleint n = (uint64_t)v7) != 0))
      {
        int v7 = *(ASN1_STRING **)(ex_pcpathlen + 16);
        if (v7 || (int v7 = ASN1_UTF8STRING_new(), (*(void *)(ex_pcpathlen + 16) = v7) != 0))
        {
          LODWORD(v7) = ASN1_STRING_set(v7, name, len);
        }
      }
    }
    else
    {
      LODWORD(v7) = 0;
    }
  }
  else
  {
    if (x)
    {
      uint64_t v8 = x[1].ex_pcpathlen;
      if (v8)
      {
        unint64_t v9 = *(ASN1_UTF8STRING **)(v8 + 16);
        if (v9)
        {
          ASN1_UTF8STRING_free(v9);
          *(void *)(x[1].ex_pcpathlen + 16) = 0;
        }
      }
    }
    LODWORD(v7) = 1;
  }
  return (int)v7;
}

int X509_keyid_set1(X509 *x, unsigned __int8 *id, int len)
{
  if (id)
  {
    if (x)
    {
      ex_pcpathleint n = x[1].ex_pcpathlen;
      if (ex_pcpathlen
        || (int v7 = (ASN1_STRING *)ASN1_item_new(&X509_CERT_AUX_it),
            ex_pcpathleint n = (uint64_t)v7,
            (x[1].ex_pcpathleint n = (uint64_t)v7) != 0))
      {
        int v7 = *(ASN1_STRING **)(ex_pcpathlen + 24);
        if (v7 || (int v7 = ASN1_OCTET_STRING_new(), (*(void *)(ex_pcpathlen + 24) = v7) != 0))
        {
          LODWORD(v7) = ASN1_STRING_set(v7, id, len);
        }
      }
    }
    else
    {
      LODWORD(v7) = 0;
    }
  }
  else
  {
    if (x)
    {
      uint64_t v8 = x[1].ex_pcpathlen;
      if (v8)
      {
        unint64_t v9 = *(ASN1_OCTET_STRING **)(v8 + 24);
        if (v9)
        {
          ASN1_OCTET_STRING_free(v9);
          *(void *)(x[1].ex_pcpathlen + 24) = 0;
        }
      }
    }
    LODWORD(v7) = 1;
  }
  return (int)v7;
}

unsigned __int8 *__cdecl X509_alias_get0(X509 *x, int *len)
{
  ex_pcpathleint n = x[1].ex_pcpathlen;
  if (!ex_pcpathlen) {
    return 0;
  }
  uint64_t v3 = *(void *)(ex_pcpathlen + 16);
  if (!v3) {
    return 0;
  }
  if (len) {
    *leint n = *(_DWORD *)v3;
  }
  return *(unsigned __int8 **)(v3 + 8);
}

unsigned __int8 *__cdecl X509_keyid_get0(X509 *x, int *len)
{
  ex_pcpathleint n = x[1].ex_pcpathlen;
  if (!ex_pcpathlen) {
    return 0;
  }
  uint64_t v3 = *(void *)(ex_pcpathlen + 24);
  if (!v3) {
    return 0;
  }
  if (len) {
    *leint n = *(_DWORD *)v3;
  }
  return *(unsigned __int8 **)(v3 + 8);
}

int X509_add1_trust_object(X509 *x, ASN1_OBJECT *obj)
{
  uint64_t v3 = OBJ_dup(obj);
  if (v3)
  {
    uint64_t v4 = v3;
    if (!x) {
      goto LABEL_8;
    }
    ex_pcpathleint n = (STACK **)x[1].ex_pcpathlen;
    if (!ex_pcpathlen)
    {
      ex_pcpathleint n = (STACK **)ASN1_item_new(&X509_CERT_AUX_it);
      x[1].ex_pcpathleint n = (uint64_t)ex_pcpathlen;
      if (!ex_pcpathlen) {
        goto LABEL_8;
      }
    }
    if ((uint64_t v6 = *ex_pcpathlen) == 0 && (uint64_t v6 = sk_new_null(), (*ex_pcpathlen = v6) == 0)
      || (LODWORD(v3) = sk_push(v6, (char *)v4), !v3))
    {
LABEL_8:
      ASN1_OBJECT_free(v4);
      LODWORD(v3) = 0;
    }
  }
  return (int)v3;
}

int X509_add1_reject_object(X509 *x, ASN1_OBJECT *obj)
{
  uint64_t v3 = OBJ_dup(obj);
  if (v3)
  {
    uint64_t v4 = v3;
    if (!x) {
      goto LABEL_8;
    }
    ex_pcpathleint n = x[1].ex_pcpathlen;
    if (!ex_pcpathlen)
    {
      ex_pcpathleint n = (uint64_t)ASN1_item_new(&X509_CERT_AUX_it);
      x[1].ex_pcpathleint n = ex_pcpathlen;
      if (!ex_pcpathlen) {
        goto LABEL_8;
      }
    }
    if ((uint64_t v6 = *(STACK **)(ex_pcpathlen + 8)) == 0
      && (uint64_t v6 = sk_new_null(), (*(void *)(ex_pcpathlen + 8) = v6) == 0)
      || (LODWORD(v3) = sk_push(v6, (char *)v4), !v3))
    {
LABEL_8:
      ASN1_OBJECT_free(v4);
      LODWORD(v3) = 0;
    }
  }
  return (int)v3;
}

void X509_trust_clear(X509 *x)
{
  ex_pcpathleint n = (STACK **)x[1].ex_pcpathlen;
  if (ex_pcpathlen)
  {
    if (*ex_pcpathlen)
    {
      sk_pop_free(*ex_pcpathlen, (void (__cdecl *)(void *))ASN1_OBJECT_free);
      *(void *)x[1].ex_pcpathleint n = 0;
    }
  }
}

void X509_reject_clear(X509 *x)
{
  ex_pcpathleint n = x[1].ex_pcpathlen;
  if (ex_pcpathlen)
  {
    uint64_t v3 = *(STACK **)(ex_pcpathlen + 8);
    if (v3)
    {
      sk_pop_free(v3, (void (__cdecl *)(void *))ASN1_OBJECT_free);
      *(void *)(x[1].ex_pcpathlen + 8) = 0;
    }
  }
}

const EVP_MD *EVP_md4(void)
{
  return (const EVP_MD *)&md4_md;
}

uint64_t init(uint64_t a1)
{
  return MD4_Init(*(MD4_CTX **)(a1 + 24));
}

uint64_t update(uint64_t a1, const void *a2, size_t a3)
{
  return MD4_Update(*(MD4_CTX **)(a1 + 24), a2, a3);
}

uint64_t final(uint64_t a1, unsigned __int8 *md)
{
  return MD4_Final(md, *(MD4_CTX **)(a1 + 24));
}

uint64_t CRYPTO_ofb128_encrypt(uint64_t result, unsigned char *a2, unint64_t a3, uint64_t a4, uint64_t a5, unsigned int *a6, uint64_t (*a7)(uint64_t, uint64_t, uint64_t))
{
  uint64_t v12 = (char *)result;
  unsigned int v13 = *a6;
  if (*a6) {
    BOOL v14 = a3 == 0;
  }
  else {
    BOOL v14 = 1;
  }
  if (v14)
  {
    unint64_t v15 = a3;
  }
  else
  {
    do
    {
      char v16 = *v12++;
      *a2++ = *(unsigned char *)(a5 + v13) ^ v16;
      unint64_t v15 = a3 - 1;
      unsigned int v13 = ((_BYTE)v13 + 1) & 0xF;
      if (!v13) {
        break;
      }
      --a3;
    }
    while (a3);
  }
  if (v15 < 0x10)
  {
    unsigned int v19 = v13;
    if (!v15) {
      goto LABEL_20;
    }
    goto LABEL_18;
  }
  do
  {
    uint64_t result = a7(a5, a5, a4);
    if (v13 <= 0xF)
    {
      unint64_t v17 = v13;
      do
      {
        *(void *)&a2[v17] = *(void *)(a5 + v17) ^ *(void *)&v12[v17];
        BOOL v18 = v17 >= 8;
        v17 += 8;
      }
      while (!v18);
    }
    unsigned int v13 = 0;
    unsigned int v19 = 0;
    v15 -= 16;
    a2 += 16;
    v12 += 16;
  }
  while (v15 > 0xF);
  if (v15)
  {
LABEL_18:
    uint64_t result = a7(a5, a5, a4);
    do
    {
      a2[v19] = *(unsigned char *)(a5 + v19) ^ v12[v19];
      ++v19;
      --v15;
    }
    while (v15);
  }
LABEL_20:
  *a6 = v19;
  return result;
}

uint64_t i2r_certpol(int a1, STACK *a2, BIO *a3, int a4)
{
  unint64_t v5 = a2;
  if (sk_num(a2) >= 1)
  {
    int v6 = 0;
    int v23 = a4 + 4;
    uint64_t v20 = (STACK *)v5;
    do
    {
      int v22 = v6;
      int v7 = sk_value(v5, v6);
      BIO_printf(a3, "%*sPolicy: ", a4, "");
      i2a_ASN1_OBJECT(a3, *(ASN1_OBJECT **)v7);
      BIO_puts(a3, "\n");
      uint64_t v8 = (const STACK *)*((void *)v7 + 1);
      if (v8 && sk_num(*((const STACK **)v7 + 1)) >= 1)
      {
        int v9 = 0;
        do
        {
          int v10 = sk_value(v8, v9);
          int v11 = OBJ_obj2nid(*(const ASN1_OBJECT **)v10);
          if (v11 == 165)
          {
            BIO_printf(a3, "%*sUser Notice:\n", a4 + 2, "");
            uint64_t v12 = (uint64_t *)*((void *)v10 + 1);
            uint64_t v13 = *v12;
            if (*v12)
            {
              BIO_printf(a3, "%*sOrganization: %.*s\n", v23, "", **(_DWORD **)v13, *(const char **)(*(void *)v13 + 8));
              int v14 = sk_num(*(const STACK **)(v13 + 8));
              unint64_t v15 = "s";
              if (v14 <= 1) {
                unint64_t v15 = "";
              }
              BIO_printf(a3, "%*sNumber%s: ", v23, "", v15);
              if (sk_num(*(const STACK **)(v13 + 8)) >= 1)
              {
                int v16 = 0;
                do
                {
                  unint64_t v17 = sk_value(*(const STACK **)(v13 + 8), v16);
                  if (v16) {
                    BIO_puts(a3, ", ");
                  }
                  BOOL v18 = i2s_ASN1_INTEGER(0, (ASN1_INTEGER *)v17);
                  BIO_puts(a3, v18);
                  free(v18);
                  ++v16;
                }
                while (v16 < sk_num(*(const STACK **)(v13 + 8)));
              }
              BIO_puts(a3, "\n");
            }
            if (v12[1]) {
              BIO_printf(a3, "%*sExplicit Text: %.*s\n");
            }
          }
          else if (v11 == 164)
          {
            BIO_printf(a3, "%*sCPS: %.*s\n");
          }
          else
          {
            BIO_printf(a3, "%*sUnknown Qualifier: ", v23, "");
            i2a_ASN1_OBJECT(a3, *(ASN1_OBJECT **)v10);
            BIO_puts(a3, "\n");
          }
          ++v9;
        }
        while (v9 < sk_num(v8));
      }
      int v6 = v22 + 1;
      unint64_t v5 = v20;
    }
    while (v22 + 1 < sk_num(v20));
  }
  return 1;
}

STACK *r2i_certpol(uint64_t a1, X509V3_CTX *a2, const char *a3)
{
  unint64_t v5 = sk_new_null();
  if (!v5)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cpols.c", 431);
    return v5;
  }
  int v6 = X509V3_parse_list(a3);
  int v7 = v6;
  if (!v6)
  {
    int v50 = 34;
    int v51 = 436;
LABEL_74:
    ERR_put_error(34, 4095, v50, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cpols.c", v51);
    goto LABEL_100;
  }
  if (sk_num(v6) < 1)
  {
LABEL_71:
    sk_pop_free(v7, (void (__cdecl *)(void *))X509V3_conf_free);
    return v5;
  }
  int v8 = 0;
  int v9 = 0;
  while (1)
  {
    int v10 = sk_value(v7, v9);
    int v11 = (const char **)v10;
    if (*((void *)v10 + 2) || (uint64_t v12 = *((void *)v10 + 1)) == 0)
    {
      int v52 = 134;
      int v53 = 443;
LABEL_76:
      ERR_put_error(34, 4095, v52, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cpols.c", v53);
      ERR_asprintf_error_data("section:%s,name:%s,value:%s", *v11, v11[1], v11[2]);
      goto LABEL_100;
    }
    if (!strcmp(*((const char **)v10 + 1), "ia5org"))
    {
      int v8 = 1;
      goto LABEL_70;
    }
    if (*(unsigned char *)v12 == 64) {
      break;
    }
    int v48 = OBJ_txt2obj((const char *)v12, 0);
    if (!v48)
    {
      int v52 = 110;
      int v53 = 465;
      goto LABEL_76;
    }
    uint64_t v49 = v48;
    unint64_t v15 = ASN1_item_new(&POLICYINFO_it);
    *(void *)unint64_t v15 = v49;
LABEL_69:
    if (!sk_push(v5, (char *)v15))
    {
      ASN1_item_free(v15, &POLICYINFO_it);
      int v50 = 65;
      int v51 = 474;
      goto LABEL_74;
    }
LABEL_70:
    if (++v9 >= sk_num(v7)) {
      goto LABEL_71;
    }
  }
  sectioint n = X509V3_get_section(a2, (char *)(v12 + 1));
  if (!section)
  {
    int v52 = 135;
    int v53 = 455;
    goto LABEL_76;
  }
  int v14 = section;
  unint64_t v15 = ASN1_item_new(&POLICYINFO_it);
  if (!v15)
  {
LABEL_84:
    int v42 = 0;
    goto LABEL_85;
  }
  int v67 = v8;
  if (sk_num(v14) < 1)
  {
LABEL_64:
    if (!*(void *)v15)
    {
      ERR_put_error(34, 4095, 139, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cpols.c", 561);
      goto LABEL_92;
    }
    X509V3_section_free(a2, v14);
    int v8 = v67;
    goto LABEL_69;
  }
  int v16 = 0;
  if (v8) {
    int v17 = 22;
  }
  else {
    int v17 = 26;
  }
  int v63 = v17;
  uint64_t v64 = v15;
  HMAC_CTX ctx = a2;
  unsigned int v66 = v14;
  while (1)
  {
    BOOL v18 = (const char **)sk_value(v14, v16);
    unsigned int v19 = v18[1];
    if (strcmp(v19, "policyIdentifier")) {
      break;
    }
    unsigned int v41 = OBJ_txt2obj(v18[2], 0);
    if (!v41)
    {
      int v58 = 110;
      int v59 = 503;
      goto LABEL_91;
    }
    *(void *)unint64_t v15 = v41;
LABEL_63:
    if (++v16 >= sk_num(v14)) {
      goto LABEL_64;
    }
  }
  if (!name_cmp(v19, "CPS"))
  {
    int v42 = ASN1_item_new(&POLICYQUALINFO_it);
    if (!v42) {
      goto LABEL_85;
    }
    *(void *)int v42 = OBJ_nid2obj(164);
    int v43 = ASN1_IA5STRING_new();
    *((void *)v42 + 1) = v43;
    if (!v43) {
      goto LABEL_85;
    }
    int v44 = v43;
    int v45 = v18[2];
    int v46 = strlen(v45);
    if (!ASN1_STRING_set(v44, v45, v46)) {
      goto LABEL_85;
    }
    unsigned int v47 = (STACK *)*((void *)v15 + 1);
    if (!v47)
    {
      unsigned int v47 = sk_new_null();
      *((void *)v15 + 1) = v47;
      if (!v47) {
        goto LABEL_85;
      }
    }
    if (!sk_push(v47, (char *)v42)) {
      goto LABEL_85;
    }
    goto LABEL_63;
  }
  if (name_cmp(v18[1], "userNotice"))
  {
    int v58 = 138;
    int v59 = 555;
LABEL_91:
    ERR_put_error(34, 4095, v58, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cpols.c", v59);
    ERR_asprintf_error_data("section:%s,name:%s,value:%s", *v18, v18[1], v18[2]);
LABEL_92:
    int v42 = 0;
    goto LABEL_99;
  }
  uint64_t v20 = v18[2];
  if (*v20 != 64)
  {
    int v58 = 137;
    int v59 = 532;
    goto LABEL_91;
  }
  unsigned int v21 = X509V3_get_section(a2, (char *)v20 + 1);
  if (!v21)
  {
    ERR_put_error(34, 4095, 135, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cpols.c", 538);
    ERR_asprintf_error_data("section:%s,name:%s,value:%s", *v18, v18[1], v18[2]);
    goto LABEL_98;
  }
  int v22 = v21;
  unsigned int data = (char *)ASN1_item_new(&POLICYQUALINFO_it);
  if (!data || (*(void *)data = OBJ_nid2obj(165), (int v23 = ASN1_item_new(&USERNOTICE_it)) == 0))
  {
LABEL_81:
    int v56 = 65;
    int v57 = 654;
LABEL_82:
    ERR_put_error(34, 4095, v56, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cpols.c", v57);
    goto LABEL_97;
  }
  int v24 = v23;
  *((void *)data + 1) = v23;
  if (sk_num(v22) < 1)
  {
LABEL_48:
    int v39 = *(ASN1_VALUE **)v24;
    if (*(void *)v24 && (!*((void *)v39 + 1) || !*(void *)v39))
    {
      int v56 = 142;
      int v57 = 647;
      goto LABEL_82;
    }
    a2 = ctx;
    X509V3_section_free(ctx, v22);
    unint64_t v15 = v64;
    uint64_t v40 = (STACK *)*((void *)v64 + 1);
    if (v40 || (uint64_t v40 = sk_new_null(), (*((void *)v64 + 1) = v40) != 0))
    {
      int v14 = v66;
      if (!sk_push(v40, data)) {
        goto LABEL_84;
      }
      goto LABEL_63;
    }
    int v42 = 0;
    int v14 = v66;
LABEL_85:
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cpols.c", 568);
    goto LABEL_99;
  }
  int v25 = 0;
  while (1)
  {
    int v26 = (const char **)sk_value(v22, v25);
    size_t v27 = v26[1];
    if (!strcmp(v27, "explicitText"))
    {
      int v36 = (ASN1_STRING *)*((void *)v24 + 1);
      if (!v36)
      {
        int v36 = ASN1_UTF8STRING_new();
        *((void *)v24 + 1) = v36;
        if (!v36) {
          goto LABEL_81;
        }
      }
      goto LABEL_46;
    }
    if (!strcmp(v27, "organization"))
    {
      uint64_t v37 = *(ASN1_VALUE **)v24;
      if (!*(void *)v24)
      {
        uint64_t v37 = ASN1_item_new(&NOTICEREF_it);
        if (!v37) {
          goto LABEL_81;
        }
        *(void *)int v24 = v37;
      }
      int v36 = *(ASN1_STRING **)v37;
      *(_DWORD *)(*(void *)v37 + 4) = v63;
LABEL_46:
      int v38 = strlen(v26[2]);
      if (!ASN1_STRING_set(v36, v26[2], v38)) {
        goto LABEL_81;
      }
      goto LABEL_47;
    }
    if (strcmp(v27, "noticeNumbers"))
    {
      int v60 = 138;
      int v61 = 639;
      goto LABEL_96;
    }
    int v28 = *(ASN1_VALUE **)v24;
    if (!*(void *)v24)
    {
      uint64_t v29 = ASN1_item_new(&NOTICEREF_it);
      if (!v29) {
        goto LABEL_81;
      }
      int v28 = v29;
      *(void *)int v24 = v29;
    }
    unsigned __int8 v30 = X509V3_parse_list(v26[2]);
    if (!v30) {
      break;
    }
    int v31 = v30;
    if (!sk_num(v30))
    {
      ERR_put_error(34, 4095, 141, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cpols.c", 627);
      ERR_asprintf_error_data("section:%s,name:%s,value:%s", *v26, v26[1], v26[2]);
LABEL_80:
      sk_pop_free(v31, (void (__cdecl *)(void *))X509V3_conf_free);
      goto LABEL_97;
    }
    long long v32 = (STACK *)*((void *)v28 + 1);
    if (sk_num(v31) >= 1)
    {
      int v33 = 0;
      while (1)
      {
        long long v34 = sk_value(v31, v33);
        long long v35 = (char *)s2i_ASN1_INTEGER(0, *((char **)v34 + 1));
        if (!v35)
        {
          int v54 = 140;
          int v55 = 671;
          goto LABEL_79;
        }
        if (!sk_push(v32, v35)) {
          break;
        }
        if (++v33 >= sk_num(v31)) {
          goto LABEL_38;
        }
      }
      int v54 = 65;
      int v55 = 680;
LABEL_79:
      ERR_put_error(34, 4095, v54, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cpols.c", v55);
      sk_pop_free(v32, (void (__cdecl *)(void *))ASN1_STRING_free);
      goto LABEL_80;
    }
LABEL_38:
    sk_pop_free(v31, (void (__cdecl *)(void *))X509V3_conf_free);
LABEL_47:
    if (++v25 >= sk_num(v22)) {
      goto LABEL_48;
    }
  }
  int v60 = 141;
  int v61 = 627;
LABEL_96:
  ERR_put_error(34, 4095, v60, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_cpols.c", v61);
  ERR_asprintf_error_data("section:%s,name:%s,value:%s", *v26, v26[1], v26[2]);
LABEL_97:
  unint64_t v15 = v64;
  a2 = ctx;
  ASN1_item_free((ASN1_VALUE *)data, &POLICYQUALINFO_it);
  X509V3_section_free(ctx, v22);
LABEL_98:
  int v42 = 0;
  int v14 = v66;
LABEL_99:
  ASN1_item_free(v42, &POLICYQUALINFO_it);
  ASN1_item_free(v15, &POLICYINFO_it);
  X509V3_section_free(a2, v14);
LABEL_100:
  sk_pop_free(v7, (void (__cdecl *)(void *))X509V3_conf_free);
  sk_pop_free(v5, (void (__cdecl *)(void *))POLICYINFO_free);
  return 0;
}

CERTIFICATEPOLICIES *__cdecl d2i_CERTIFICATEPOLICIES(CERTIFICATEPOLICIES **a, const unsigned __int8 **in, uint64_t len)
{
  return (CERTIFICATEPOLICIES *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &CERTIFICATEPOLICIES_it);
}

int i2d_CERTIFICATEPOLICIES(CERTIFICATEPOLICIES *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &CERTIFICATEPOLICIES_it);
}

CERTIFICATEPOLICIES *CERTIFICATEPOLICIES_new(void)
{
  return (CERTIFICATEPOLICIES *)ASN1_item_new(&CERTIFICATEPOLICIES_it);
}

void CERTIFICATEPOLICIES_free(CERTIFICATEPOLICIES *a)
{
}

POLICYINFO *__cdecl d2i_POLICYINFO(POLICYINFO **a, const unsigned __int8 **in, uint64_t len)
{
  return (POLICYINFO *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &POLICYINFO_it);
}

int i2d_POLICYINFO(POLICYINFO *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &POLICYINFO_it);
}

POLICYINFO *POLICYINFO_new(void)
{
  return (POLICYINFO *)ASN1_item_new(&POLICYINFO_it);
}

void POLICYINFO_free(POLICYINFO *a)
{
}

POLICYQUALINFO *__cdecl d2i_POLICYQUALINFO(POLICYQUALINFO **a, const unsigned __int8 **in, uint64_t len)
{
  return (POLICYQUALINFO *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &POLICYQUALINFO_it);
}

int i2d_POLICYQUALINFO(POLICYQUALINFO *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &POLICYQUALINFO_it);
}

POLICYQUALINFO *POLICYQUALINFO_new(void)
{
  return (POLICYQUALINFO *)ASN1_item_new(&POLICYQUALINFO_it);
}

void POLICYQUALINFO_free(POLICYQUALINFO *a)
{
}

USERNOTICE *__cdecl d2i_USERNOTICE(USERNOTICE **a, const unsigned __int8 **in, uint64_t len)
{
  return (USERNOTICE *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &USERNOTICE_it);
}

int i2d_USERNOTICE(USERNOTICE *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &USERNOTICE_it);
}

USERNOTICE *USERNOTICE_new(void)
{
  return (USERNOTICE *)ASN1_item_new(&USERNOTICE_it);
}

void USERNOTICE_free(USERNOTICE *a)
{
}

NOTICEREF *__cdecl d2i_NOTICEREF(NOTICEREF **a, const unsigned __int8 **in, uint64_t len)
{
  return (NOTICEREF *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &NOTICEREF_it);
}

int i2d_NOTICEREF(NOTICEREF *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &NOTICEREF_it);
}

NOTICEREF *NOTICEREF_new(void)
{
  return (NOTICEREF *)ASN1_item_new(&NOTICEREF_it);
}

void NOTICEREF_free(NOTICEREF *a)
{
}

void OpenSSL_add_all_ciphers(void)
{
}

uint64_t OpenSSL_add_all_ciphers_internal()
{
  int v0 = EVP_des_cfb64();
  EVP_add_cipher(v0);
  uint64_t v1 = EVP_des_cfb1();
  EVP_add_cipher(v1);
  int v2 = EVP_des_cfb8();
  EVP_add_cipher(v2);
  uint64_t v3 = EVP_des_ede_cfb64();
  EVP_add_cipher(v3);
  uint64_t v4 = EVP_des_ede3_cfb64();
  EVP_add_cipher(v4);
  unint64_t v5 = EVP_des_ede3_cfb1();
  EVP_add_cipher(v5);
  int v6 = EVP_des_ede3_cfb8();
  EVP_add_cipher(v6);
  int v7 = EVP_des_ofb();
  EVP_add_cipher(v7);
  int v8 = EVP_des_ede_ofb();
  EVP_add_cipher(v8);
  int v9 = EVP_des_ede3_ofb();
  EVP_add_cipher(v9);
  int v10 = EVP_desx_cbc();
  EVP_add_cipher(v10);
  OBJ_NAME_add("DESX", 32770, "DESX-CBC");
  OBJ_NAME_add("desx", 32770, "DESX-CBC");
  int v11 = EVP_des_cbc();
  EVP_add_cipher(v11);
  OBJ_NAME_add("DES", 32770, "DES-CBC");
  OBJ_NAME_add("des", 32770, "DES-CBC");
  uint64_t v12 = EVP_des_ede_cbc();
  EVP_add_cipher(v12);
  uint64_t v13 = EVP_des_ede3_cbc();
  EVP_add_cipher(v13);
  OBJ_NAME_add("DES3", 32770, "DES-EDE3-CBC");
  OBJ_NAME_add("des3", 32770, "DES-EDE3-CBC");
  int v14 = EVP_des_ecb();
  EVP_add_cipher(v14);
  unint64_t v15 = EVP_des_ede();
  EVP_add_cipher(v15);
  int v16 = EVP_des_ede3();
  EVP_add_cipher(v16);
  int v17 = EVP_rc4();
  EVP_add_cipher(v17);
  BOOL v18 = EVP_rc4_40();
  EVP_add_cipher(v18);
  unsigned int v19 = (const EVP_CIPHER *)EVP_rc4_hmac_md5();
  EVP_add_cipher(v19);
  uint64_t v20 = (const EVP_CIPHER *)EVP_idea_ecb();
  EVP_add_cipher(v20);
  unsigned int v21 = (const EVP_CIPHER *)EVP_idea_cfb64();
  EVP_add_cipher(v21);
  int v22 = (const EVP_CIPHER *)EVP_idea_ofb();
  EVP_add_cipher(v22);
  int v23 = (const EVP_CIPHER *)EVP_idea_cbc();
  EVP_add_cipher(v23);
  OBJ_NAME_add("IDEA", 32770, "IDEA-CBC");
  OBJ_NAME_add("idea", 32770, "IDEA-CBC");
  int v24 = EVP_rc2_ecb();
  EVP_add_cipher(v24);
  int v25 = EVP_rc2_cfb64();
  EVP_add_cipher(v25);
  int v26 = EVP_rc2_ofb();
  EVP_add_cipher(v26);
  size_t v27 = EVP_rc2_cbc();
  EVP_add_cipher(v27);
  int v28 = EVP_rc2_40_cbc();
  EVP_add_cipher(v28);
  uint64_t v29 = EVP_rc2_64_cbc();
  EVP_add_cipher(v29);
  OBJ_NAME_add("RC2", 32770, "RC2-CBC");
  OBJ_NAME_add("rc2", 32770, "RC2-CBC");
  unsigned __int8 v30 = EVP_bf_ecb();
  EVP_add_cipher(v30);
  int v31 = EVP_bf_cfb64();
  EVP_add_cipher(v31);
  long long v32 = EVP_bf_ofb();
  EVP_add_cipher(v32);
  int v33 = EVP_bf_cbc();
  EVP_add_cipher(v33);
  OBJ_NAME_add("BF", 32770, "BF-CBC");
  OBJ_NAME_add("bf", 32770, "BF-CBC");
  OBJ_NAME_add("blowfish", 32770, "BF-CBC");
  long long v34 = EVP_cast5_ecb();
  EVP_add_cipher(v34);
  long long v35 = EVP_cast5_cfb64();
  EVP_add_cipher(v35);
  int v36 = EVP_cast5_ofb();
  EVP_add_cipher(v36);
  uint64_t v37 = EVP_cast5_cbc();
  EVP_add_cipher(v37);
  OBJ_NAME_add("CAST", 32770, "CAST5-CBC");
  OBJ_NAME_add("cast", 32770, "CAST5-CBC");
  OBJ_NAME_add("CAST-cbc", 32770, "CAST5-CBC");
  OBJ_NAME_add("cast-cbc", 32770, "CAST5-CBC");
  int v38 = EVP_aes_128_ecb();
  EVP_add_cipher(v38);
  int v39 = EVP_aes_128_cbc();
  EVP_add_cipher(v39);
  uint64_t v40 = (const EVP_CIPHER *)EVP_aes_128_ccm();
  EVP_add_cipher(v40);
  unsigned int v41 = EVP_aes_128_cfb128();
  EVP_add_cipher(v41);
  int v42 = EVP_aes_128_cfb1();
  EVP_add_cipher(v42);
  int v43 = EVP_aes_128_cfb8();
  EVP_add_cipher(v43);
  int v44 = EVP_aes_128_ofb();
  EVP_add_cipher(v44);
  int v45 = (const EVP_CIPHER *)EVP_aes_128_ctr();
  EVP_add_cipher(v45);
  int v46 = (const EVP_CIPHER *)EVP_aes_128_gcm();
  EVP_add_cipher(v46);
  unsigned int v47 = (const EVP_CIPHER *)EVP_aes_128_wrap();
  EVP_add_cipher(v47);
  int v48 = (const EVP_CIPHER *)EVP_aes_128_xts();
  EVP_add_cipher(v48);
  OBJ_NAME_add("AES128", 32770, "AES-128-CBC");
  OBJ_NAME_add("aes128", 32770, "AES-128-CBC");
  uint64_t v49 = EVP_aes_192_ecb();
  EVP_add_cipher(v49);
  int v50 = EVP_aes_192_cbc();
  EVP_add_cipher(v50);
  int v51 = (const EVP_CIPHER *)EVP_aes_192_ccm();
  EVP_add_cipher(v51);
  int v52 = EVP_aes_192_cfb128();
  EVP_add_cipher(v52);
  int v53 = EVP_aes_192_cfb1();
  EVP_add_cipher(v53);
  int v54 = EVP_aes_192_cfb8();
  EVP_add_cipher(v54);
  int v55 = EVP_aes_192_ofb();
  EVP_add_cipher(v55);
  int v56 = (const EVP_CIPHER *)EVP_aes_192_ctr();
  EVP_add_cipher(v56);
  int v57 = (const EVP_CIPHER *)EVP_aes_192_gcm();
  EVP_add_cipher(v57);
  int v58 = (const EVP_CIPHER *)EVP_aes_192_wrap();
  EVP_add_cipher(v58);
  OBJ_NAME_add("AES192", 32770, "AES-192-CBC");
  OBJ_NAME_add("aes192", 32770, "AES-192-CBC");
  int v59 = EVP_aes_256_ecb();
  EVP_add_cipher(v59);
  int v60 = EVP_aes_256_cbc();
  EVP_add_cipher(v60);
  int v61 = (const EVP_CIPHER *)EVP_aes_256_ccm();
  EVP_add_cipher(v61);
  int v62 = EVP_aes_256_cfb128();
  EVP_add_cipher(v62);
  int v63 = EVP_aes_256_cfb1();
  EVP_add_cipher(v63);
  uint64_t v64 = EVP_aes_256_cfb8();
  EVP_add_cipher(v64);
  unsigned int v65 = EVP_aes_256_ofb();
  EVP_add_cipher(v65);
  unsigned int v66 = (const EVP_CIPHER *)EVP_aes_256_ctr();
  EVP_add_cipher(v66);
  int v67 = (const EVP_CIPHER *)EVP_aes_256_gcm();
  EVP_add_cipher(v67);
  int v68 = (const EVP_CIPHER *)EVP_aes_256_wrap();
  EVP_add_cipher(v68);
  unsigned int v69 = (const EVP_CIPHER *)EVP_aes_256_xts();
  EVP_add_cipher(v69);
  OBJ_NAME_add("AES256", 32770, "AES-256-CBC");
  OBJ_NAME_add("aes256", 32770, "AES-256-CBC");
  unsigned int v70 = (const EVP_CIPHER *)EVP_aes_128_cbc_hmac_sha1();
  EVP_add_cipher(v70);
  int v71 = (const EVP_CIPHER *)EVP_aes_256_cbc_hmac_sha1();
  EVP_add_cipher(v71);
  uint64_t v72 = (const EVP_CIPHER *)EVP_camellia_128_ecb();
  EVP_add_cipher(v72);
  unsigned int v73 = (const EVP_CIPHER *)EVP_camellia_128_cbc();
  EVP_add_cipher(v73);
  int v74 = (const EVP_CIPHER *)EVP_camellia_128_cfb128();
  EVP_add_cipher(v74);
  unsigned int v75 = (const EVP_CIPHER *)EVP_camellia_128_cfb1();
  EVP_add_cipher(v75);
  unsigned int v76 = (const EVP_CIPHER *)EVP_camellia_128_cfb8();
  EVP_add_cipher(v76);
  int v77 = (const EVP_CIPHER *)EVP_camellia_128_ofb();
  EVP_add_cipher(v77);
  OBJ_NAME_add("CAMELLIA128", 32770, "CAMELLIA-128-CBC");
  OBJ_NAME_add("camellia128", 32770, "CAMELLIA-128-CBC");
  unsigned int v78 = (const EVP_CIPHER *)EVP_camellia_192_ecb();
  EVP_add_cipher(v78);
  unsigned int v79 = (const EVP_CIPHER *)EVP_camellia_192_cbc();
  EVP_add_cipher(v79);
  int v80 = (const EVP_CIPHER *)EVP_camellia_192_cfb128();
  EVP_add_cipher(v80);
  unsigned int v81 = (const EVP_CIPHER *)EVP_camellia_192_cfb1();
  EVP_add_cipher(v81);
  unsigned int v82 = (const EVP_CIPHER *)EVP_camellia_192_cfb8();
  EVP_add_cipher(v82);
  int v83 = (const EVP_CIPHER *)EVP_camellia_192_ofb();
  EVP_add_cipher(v83);
  OBJ_NAME_add("CAMELLIA192", 32770, "CAMELLIA-192-CBC");
  OBJ_NAME_add("camellia192", 32770, "CAMELLIA-192-CBC");
  unsigned int v84 = (const EVP_CIPHER *)EVP_camellia_256_ecb();
  EVP_add_cipher(v84);
  unsigned int v85 = (const EVP_CIPHER *)EVP_camellia_256_cbc();
  EVP_add_cipher(v85);
  int v86 = (const EVP_CIPHER *)EVP_camellia_256_cfb128();
  EVP_add_cipher(v86);
  unsigned int v87 = (const EVP_CIPHER *)EVP_camellia_256_cfb1();
  EVP_add_cipher(v87);
  unsigned int v88 = (const EVP_CIPHER *)EVP_camellia_256_cfb8();
  EVP_add_cipher(v88);
  int v89 = (const EVP_CIPHER *)EVP_camellia_256_ofb();
  EVP_add_cipher(v89);
  OBJ_NAME_add("CAMELLIA256", 32770, "CAMELLIA-256-CBC");
  OBJ_NAME_add("camellia256", 32770, "CAMELLIA-256-CBC");
  unsigned int v90 = (const EVP_CIPHER *)EVP_chacha20();
  EVP_add_cipher(v90);
  unsigned int v91 = (const EVP_CIPHER *)EVP_chacha20_poly1305();
  EVP_add_cipher(v91);
  int v92 = (const EVP_CIPHER *)EVP_gost2814789_ecb();
  EVP_add_cipher(v92);
  unsigned int v93 = (const EVP_CIPHER *)EVP_gost2814789_cfb64();
  EVP_add_cipher(v93);
  unsigned int v94 = (const EVP_CIPHER *)EVP_gost2814789_cnt();
  EVP_add_cipher(v94);
  unsigned int v95 = (const EVP_CIPHER *)EVP_sm4_ecb();
  EVP_add_cipher(v95);
  unsigned int v96 = (const EVP_CIPHER *)EVP_sm4_cbc();
  EVP_add_cipher(v96);
  unsigned int v97 = (const EVP_CIPHER *)EVP_sm4_cfb128();
  EVP_add_cipher(v97);
  unint64_t v98 = (const EVP_CIPHER *)EVP_sm4_ofb();
  EVP_add_cipher(v98);
  unsigned int v99 = (const EVP_CIPHER *)EVP_sm4_ctr();
  EVP_add_cipher(v99);
  OBJ_NAME_add("SM4", 32770, "SM4-CBC");
  return OBJ_NAME_add("sm4", 32770, "SM4-CBC");
}

void OpenSSL_add_all_digests(void)
{
}

uint64_t OpenSSL_add_all_digests_internal()
{
  int v0 = EVP_md4();
  EVP_add_digest(v0);
  uint64_t v1 = EVP_md5();
  EVP_add_digest(v1);
  int v2 = (const EVP_MD *)EVP_md5_sha1();
  EVP_add_digest(v2);
  OBJ_NAME_add("ssl2-md5", 32769, "MD5");
  OBJ_NAME_add("ssl3-md5", 32769, "MD5");
  uint64_t v3 = EVP_sha1();
  EVP_add_digest(v3);
  OBJ_NAME_add("ssl3-sha1", 32769, "SHA1");
  OBJ_NAME_add("RSA-SHA1-2", 32769, "RSA-SHA1");
  uint64_t v4 = (const EVP_MD *)EVP_gostr341194();
  EVP_add_digest(v4);
  unint64_t v5 = (const EVP_MD *)EVP_gost2814789imit();
  EVP_add_digest(v5);
  int v6 = (const EVP_MD *)EVP_streebog256();
  EVP_add_digest(v6);
  int v7 = (const EVP_MD *)EVP_streebog512();
  EVP_add_digest(v7);
  int v8 = EVP_ripemd160();
  EVP_add_digest(v8);
  OBJ_NAME_add("ripemd", 32769, "RIPEMD160");
  OBJ_NAME_add("rmd160", 32769, "RIPEMD160");
  int v9 = EVP_sha224();
  EVP_add_digest(v9);
  int v10 = EVP_sha256();
  EVP_add_digest(v10);
  int v11 = EVP_sha384();
  EVP_add_digest(v11);
  uint64_t v12 = EVP_sha512();
  EVP_add_digest(v12);
  uint64_t v13 = EVP_sha512_224();
  EVP_add_digest(v13);
  int v14 = EVP_sha512_256();
  EVP_add_digest(v14);
  unint64_t v15 = (const EVP_MD *)EVP_sha3_224();
  EVP_add_digest(v15);
  int v16 = (const EVP_MD *)EVP_sha3_256();
  EVP_add_digest(v16);
  int v17 = (const EVP_MD *)EVP_sha3_384();
  EVP_add_digest(v17);
  BOOL v18 = (const EVP_MD *)EVP_sha3_512();
  EVP_add_digest(v18);
  unsigned int v19 = (const EVP_MD *)EVP_sm3();
  EVP_add_digest(v19);
  uint64_t v20 = (const EVP_MD *)EVP_whirlpool();
  return EVP_add_digest(v20);
}

void OPENSSL_add_all_algorithms_noconf(void)
{
  OPENSSL_cpuid_setup();
  pthread_once(&OpenSSL_add_all_ciphers_add_all_ciphers_once, (void (*)(void))OpenSSL_add_all_ciphers_internal);
  pthread_once(&OpenSSL_add_all_digests_add_all_digests_once, (void (*)(void))OpenSSL_add_all_digests_internal);
}

void OPENSSL_add_all_algorithms_conf(void)
{
  OPENSSL_add_all_algorithms_noconf();
  OPENSSL_config(0);
}

int BN_kronecker(const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
{
  BN_CTX_start(ctx);
  int v6 = BN_CTX_get(ctx);
  if (!v6) {
    goto LABEL_51;
  }
  int v7 = v6;
  int v8 = BN_CTX_get(ctx);
  if (!v8) {
    goto LABEL_51;
  }
  int v9 = v8;
  if (!bn_copy(v7, a) || !bn_copy(v9, b)) {
    goto LABEL_51;
  }
  if (BN_is_zero((uint64_t)v9))
  {
    is_worchar d = BN_abs_is_word((uint64_t)v7, 1);
    goto LABEL_52;
  }
  if (!BN_is_odd((uint64_t)v7) && !BN_is_odd((uint64_t)v9))
  {
    is_worchar d = 0;
    goto LABEL_52;
  }
  int v11 = -1;
  do
    ++v11;
  while (!BN_is_bit_set(v9, v11));
  if (!BN_rshift(v9, v9, v11))
  {
LABEL_51:
    is_worchar d = -2;
    goto LABEL_52;
  }
  if (v11)
  {
    if (v7->top) {
      uint64_t v13 = *v7->d & 7;
    }
    else {
      uint64_t v13 = 0;
    }
    int v12 = BN_kronecker_tab[v13];
  }
  else
  {
    int v12 = 1;
  }
  if (BN_is_negative((uint64_t)v9))
  {
    BN_set_negative(v9, 0);
    if (BN_is_negative((uint64_t)v7)) {
      int v12 = -v12;
    }
  }
  if (!BN_is_zero((uint64_t)v7))
  {
    while (1)
    {
      int v14 = v7;
      int v7 = v9;
      int v15 = -1;
      do
        ++v15;
      while (!BN_is_bit_set(v14, v15));
      if (!BN_rshift(v14, v14, v15)) {
        goto LABEL_51;
      }
      if (v15)
      {
        if (v7->top) {
          unint64_t v16 = *v7->d;
        }
        else {
          LOBYTE(v16) = 0;
        }
        v12 *= BN_kronecker_tab[v16 & 7];
      }
      BOOL is_negative = BN_is_negative((uint64_t)v14);
      int top = v14->top;
      if (is_negative)
      {
        if (top) {
          unint64_t v19 = *v14->d;
        }
        else {
          LOBYTE(v19) = 0;
        }
        LOBYTE(v20) = ~(_BYTE)v19;
      }
      else if (top)
      {
        unint64_t v20 = *v14->d;
      }
      else
      {
        LOBYTE(v20) = 0;
      }
      if (v7->top) {
        unint64_t v21 = *v7->d;
      }
      else {
        LOBYTE(v21) = 0;
      }
      if (!BN_nnmod(v7, v7, v14, ctx)) {
        goto LABEL_51;
      }
      if ((v20 & v21 & 2) != 0) {
        int v12 = -v12;
      }
      BN_set_negative(v14, 0);
      int v9 = v14;
      if (BN_is_zero((uint64_t)v7)) {
        goto LABEL_24;
      }
    }
  }
  int v14 = v9;
LABEL_24:
  if (BN_is_one((uint64_t)v14)) {
    is_worchar d = v12;
  }
  else {
    is_worchar d = 0;
  }
LABEL_52:
  BN_CTX_end(ctx);
  return is_word;
}

unint64_t idea_set_encrypt_key(unint64_t result, int *a2)
{
  int v2 = *(unsigned __int8 *)result;
  *a2 = v2 << 8;
  *a2 = *(unsigned __int8 *)(result + 1) | (v2 << 8);
  int v3 = *(unsigned __int8 *)(result + 2);
  a2[1] = v3 << 8;
  unsigned int v4 = *(unsigned __int8 *)(result + 3) | (v3 << 8);
  a2[1] = v4;
  int v5 = *(unsigned __int8 *)(result + 4);
  a2[2] = v5 << 8;
  unsigned int v6 = *(unsigned __int8 *)(result + 5) | (v5 << 8);
  a2[2] = v6;
  int v7 = *(unsigned __int8 *)(result + 6);
  a2[3] = v7 << 8;
  unsigned int v8 = *(unsigned __int8 *)(result + 7) | (v7 << 8);
  a2[3] = v8;
  int v9 = *(unsigned __int8 *)(result + 8);
  a2[4] = v9 << 8;
  unsigned int v10 = *(unsigned __int8 *)(result + 9) | (v9 << 8);
  a2[4] = v10;
  int v11 = *(unsigned __int8 *)(result + 10);
  a2[5] = v11 << 8;
  unsigned int v12 = *(unsigned __int8 *)(result + 11) | (v11 << 8);
  a2[5] = v12;
  int v13 = *(unsigned __int8 *)(result + 12);
  a2[6] = v13 << 8;
  unsigned int v14 = *(unsigned __int8 *)(result + 13) | (v13 << 8);
  a2[6] = v14;
  int v15 = *(unsigned __int8 *)(result + 14);
  a2[7] = v15 << 8;
  unsigned int v16 = *(unsigned __int8 *)(result + 15) | (v15 << 8);
  a2[7] = v16;
  for (uint64_t i = 15; ; i += 8)
  {
    BOOL v18 = (unsigned int *)&a2[i];
    unsigned int v19 = (unsigned __int16)((v8 >> 7) | ((_WORD)v6 << 9));
    *(v18 - 7) = (unsigned __int16)((v6 >> 7) | ((_WORD)v4 << 9));
    *(v18 - 6) = v19;
    unsigned int v6 = (unsigned __int16)((v10 >> 7) | ((_WORD)v8 << 9));
    unsigned int v8 = (unsigned __int16)((v12 >> 7) | ((_WORD)v10 << 9));
    *(v18 - 5) = v6;
    *(v18 - 4) = v8;
    unsigned int v10 = (unsigned __int16)((v14 >> 7) | ((_WORD)v12 << 9));
    unsigned int v12 = (unsigned __int16)((v16 >> 7) | ((_WORD)v14 << 9));
    *(v18 - 3) = v10;
    *(v18 - 2) = v12;
    if ((i * 4) == 220) {
      break;
    }
    uint64_t result = *(v18 - 15);
    unsigned int v14 = (unsigned __int16)((result >> 7) | ((_WORD)v16 << 9));
    unsigned int v16 = (unsigned __int16)(((_WORD)result << 9) | (v4 >> 7));
    *(v18 - 1) = v14;
    *BOOL v18 = v16;
    unsigned int v4 = v19;
  }
  return result;
}

int32x2_t idea_set_decrypt_key(uint64_t a1, uint64_t a2)
{
  int v2 = 0;
  int v3 = (unsigned int *)(a1 + 192);
  for (uint64_t i = (_DWORD *)a2; ; i += 6)
  {
    uint64_t v5 = *v3;
    if (v5)
    {
      unint64_t v6 = 0x10001 % v5;
      if (v6)
      {
        uint64_t v7 = 0;
        uint64_t v8 = 1;
        uint64_t v9 = 65537;
        do
        {
          uint64_t v10 = v5;
          uint64_t v11 = v8;
          uint64_t v5 = v6;
          uint64_t v8 = v7 - (uint64_t)(v9 - v6) / v10 * v8;
          unint64_t v6 = v10 % v6;
          uint64_t v7 = v11;
          uint64_t v9 = v10;
        }
        while (v6);
        LODWORD(v5) = v8 + 65537;
        if (v8 >= 0) {
          LODWORD(v5) = v8;
        }
      }
      else
      {
        LODWORD(v5) = 1;
      }
    }
    *uint64_t i = v5;
    i[1] = (unsigned __int16)-*((_WORD *)v3 + 4);
    i[2] = (unsigned __int16)-*((_WORD *)v3 + 2);
    uint64_t v12 = v3[3];
    if (v12)
    {
      unint64_t v13 = 0x10001 % v12;
      if (v13)
      {
        uint64_t v14 = 0;
        uint64_t v15 = 1;
        uint64_t v16 = 65537;
        do
        {
          uint64_t v17 = v12;
          uint64_t v18 = v15;
          uint64_t v12 = v13;
          uint64_t v15 = v14 - (uint64_t)(v16 - v13) / v17 * v15;
          unint64_t v13 = v17 % v13;
          uint64_t v14 = v18;
          uint64_t v16 = v17;
        }
        while (v13);
        LODWORD(v12) = v15 + 65537;
        if (v15 >= 0) {
          LODWORD(v12) = v15;
        }
      }
      else
      {
        LODWORD(v12) = 1;
      }
    }
    i[3] = v12;
    if (v2 == 8) {
      break;
    }
    i[4] = *(v3 - 2);
    int v19 = *(v3 - 1);
    v3 -= 6;
    i[5] = v19;
    ++v2;
  }
  *(int32x2_t *)(a2 + 4) = vrev64_s32(*(int32x2_t *)(a2 + 4));
  int32x2_t result = vrev64_s32(*(int32x2_t *)(a2 + 196));
  *(int32x2_t *)(a2 + 196) = result;
  return result;
}

CONF_METHOD *NCONF_default(void)
{
  return (CONF_METHOD *)&default_method;
}

CONF_METHOD *NCONF_WIN32(void)
{
  return (CONF_METHOD *)&WIN32_method;
}

void *def_create(uint64_t a1)
{
  int v2 = malloc_type_malloc(0x20uLL, 0x7279D4DDuLL);
  int v3 = v2;
  if (v2 && !(*(unsigned int (**)(void *))(a1 + 16))(v2))
  {
    free(v3);
    return 0;
  }
  return v3;
}

uint64_t def_init_default(uint64_t result)
{
  if (result)
  {
    *(void *)int32x2_t result = &default_method;
    *(void *)(result + 8) = &CONF_type_default;
    *(void *)(result + 16) = 0;
    return 1;
  }
  return result;
}

CONF *def_destroy(CONF *result)
{
  if (result)
  {
    uint64_t v1 = result;
    _CONF_free_data(result);
    free(v1);
    return (CONF *)1;
  }
  return result;
}

CONF *def_destroy_data(CONF *result)
{
  if (result)
  {
    _CONF_free_data(result);
    return (CONF *)1;
  }
  return result;
}

uint64_t def_load_bio(CONF *a1, BIO *a2, char **a3)
{
  unsigned int data = a1->data;
  uint64_t v7 = BUF_MEM_new();
  if (!v7)
  {
    ERR_put_error(14, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_def.c", 229);
    unsigned int v78 = 0;
    int v62 = 0;
    uint64_t v9 = 0;
    goto LABEL_148;
  }
  uint64_t v8 = v7;
  uint64_t v9 = strdup("default");
  sectioint n = v9;
  if (!v9)
  {
    ERR_put_error(14, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_def.c", 235);
    int v62 = 0;
    goto LABEL_147;
  }
  if (!_CONF_new_data(a1))
  {
    int v79 = 65;
    int v80 = 240;
LABEL_146:
    ERR_put_error(14, 4095, v79, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_def.c", v80);
    int v62 = 0;
    uint64_t v9 = 0;
    goto LABEL_147;
  }
  int v86 = _CONF_new_section(a1, v9);
  if (!v86)
  {
    int v79 = 103;
    int v80 = 246;
    goto LABEL_146;
  }
  uint64_t v9 = 0;
  if (!BUF_MEM_grow(v8, 512)) {
    goto LABEL_139;
  }
  unsigned int v85 = a3;
  while (2)
  {
    char v10 = 0;
    LODWORD(v11) = 0;
LABEL_8:
    uint64_t v12 = &v8->data[(int)v11];
    *uint64_t v12 = 0;
    BIO_gets(a2, v12, 511);
    v12[511] = 0;
    int v13 = strlen(v12);
    if ((v10 & 1) == 0 && !v13)
    {
      BUF_MEM_free(v8);
      free(section);
      return 1;
    }
    int v14 = v13;
    if (v13 >= 1)
    {
      uint64_t v15 = v13 + 1;
      int v14 = v13;
      while (1)
      {
        int v16 = v12[(v15 - 2)];
        BOOL v17 = v16 == 13 || v16 == 10;
        if (!v17) {
          break;
        }
        --v14;
        if ((unint64_t)--v15 <= 1)
        {
          int v14 = 0;
          break;
        }
      }
    }
    if (v13) {
      BOOL v18 = v14 == v13;
    }
    else {
      BOOL v18 = 0;
    }
    int v19 = v18;
    if (!v18)
    {
      v12[v14] = 0;
      ++v9;
    }
    int v20 = v14 + v11;
    uint64_t v11 = (v20 - 1);
    if (v20 >= 1 && (unint64_t v21 = &v8->data[v11], meth_data = a1->meth_data, (meth_data[*v21] & 0x20) != 0))
    {
      if (v20 < 2
        || ((meth_data[*(v21 - 1)] & 0x20) != 0 ? (LODWORD(v11) = v20) : (LOBYTE(v19) = 1),
            (v19 & 1) != 0))
      {
        char v10 = 1;
        goto LABEL_117;
      }
    }
    else if (v19)
    {
      char v10 = 1;
      LODWORD(v11) = v20;
      goto LABEL_117;
    }
    int v23 = v8->data;
    int v24 = a1->meth_data;
    int v25 = *v23;
    __int16 v26 = v24[*v23];
    size_t v27 = v23;
    if ((v26 & 0x800) == 0)
    {
      size_t v27 = v8->data;
      if ((v26 & 0x10) != 0)
      {
        size_t v27 = v23 + 1;
        while (1)
        {
          int v25 = *v27;
          __int16 v26 = v24[*v27];
          if ((v26 & 0x800) != 0) {
            break;
          }
          ++v27;
          if ((v26 & 0x10) == 0)
          {
            --v27;
            goto LABEL_43;
          }
        }
      }
      else
      {
LABEL_43:
        while ((v26 & 0x80) == 0)
        {
          if ((v26 & 0x400) != 0)
          {
            for (i = (unsigned __int8 *)v27; ; size_t v27 = (char *)i)
            {
              int v30 = *++i;
              int v29 = v30;
              if ((v24[v30] & 8) != 0) {
                break;
              }
              if (v29 == v25)
              {
                if (v27[2] != v25)
                {
                  int v29 = v25;
                  break;
                }
                uint64_t i = (unsigned __int8 *)(v27 + 2);
              }
            }
            v27 += 2;
            if (v29 != v25) {
              size_t v27 = (char *)i;
            }
          }
          else if ((v26 & 0x40) != 0)
          {
            int v31 = (unsigned __int8 *)(v27 + 1);
            __int16 v32 = v24[v27[1]];
            BOOL v33 = v27[1] == v25;
            if (v27[1] != v25 && (v32 & 8) == 0)
            {
              while (1)
              {
                long long v35 = v31;
                if ((v32 & 0x20) != 0)
                {
                  int v36 = v27[2];
                  v27 += 2;
                  long long v35 = (unsigned __int8 *)v27;
                  if ((v24[v36] & 8) != 0) {
                    break;
                  }
                }
                int v31 = v35 + 1;
                int v37 = v35[1];
                __int16 v32 = v24[v35[1]];
                BOOL v33 = v37 == v25;
                BOOL v38 = v37 != v25 && (v32 & 8) == 0;
                size_t v27 = (char *)v35;
                if (!v38)
                {
                  size_t v27 = (char *)v35;
                  goto LABEL_67;
                }
              }
            }
            else
            {
LABEL_67:
              v27 += 2;
              if (!v33) {
                size_t v27 = (char *)v31;
              }
            }
          }
          else if ((v26 & 0x20) != 0)
          {
            int v39 = *++v27;
            if ((v24[v39] & 8) == 0) {
              ++v27;
            }
          }
          else
          {
            if ((v26 & 8) != 0) {
              goto LABEL_78;
            }
            ++v27;
          }
          int v25 = *v27;
          __int16 v26 = v24[*v27];
        }
      }
    }
    *size_t v27 = 0;
    int v24 = a1->meth_data;
    do
    {
LABEL_78:
      uint64_t v40 = v23;
      int v42 = *v23++;
      int v41 = v42;
      __int16 v43 = v24[v42];
    }
    while ((v43 & 0x18) == 0x10);
    if ((v43 & 8) != 0) {
      goto LABEL_116;
    }
    int v44 = v23 - 1;
    int v45 = (unsigned __int8 *)(v23 - 1);
    if (v41 != 91)
    {
      while (1)
      {
        if ((v43 & 0x20) != 0)
        {
          int v46 = *++v45;
          if ((v24[v46] & 8) == 0) {
            ++v45;
          }
        }
        else
        {
          if ((v43 & 0x307) == 0)
          {
            if (v41 == 58 && v45[1] == 58)
            {
              unsigned __int8 *v45 = 0;
              v45 += 2;
              unsigned int v47 = (const char *)v45;
              int v24 = a1->meth_data;
              while (1)
              {
                while ((v24[*v45] & 0x20) != 0)
                {
                  int v48 = *++v45;
                  if ((v24[v48] & 8) == 0) {
                    ++v45;
                  }
                }
                if ((v24[*v45] & 0x307) == 0) {
                  break;
                }
                ++v45;
              }
              uint64_t v49 = (char *)v44;
              int v44 = v47;
            }
            else
            {
              uint64_t v49 = 0;
            }
            int v50 = v45;
            do
            {
              int v51 = (const char *)v50;
              int v53 = *v50++;
              int v52 = v53;
            }
            while ((v24[v53] & 0x18) == 0x10);
            if (v52 != 61)
            {
              int v76 = 101;
              int v77 = 346;
              goto LABEL_140;
            }
            unsigned __int8 *v45 = 0;
            int v54 = a1->meth_data;
            uint64_t v55 = 1;
            int v56 = v51;
            do
            {
              int v57 = *(unsigned __int8 *)++v56;
              uint64_t v58 = v55++;
            }
            while ((v54[v57] & 0x18) == 0x10);
            do
            {
              uint64_t v59 = v58;
              int v60 = *(unsigned __int8 *)++v51;
              --v58;
            }
            while ((v54[v60] & 8) == 0);
            do
            {
              int v61 = v51;
              if (!v59) {
                break;
              }
              --v51;
              ++v59;
            }
            while ((v54[*((unsigned __int8 *)v61 - 1)] & 0x10) != 0);
            *int v61 = 0;
            int v62 = (CONF_VALUE *)malloc_type_malloc(0x18uLL, 0x100402FEFCB83uLL);
            if (!v62)
            {
              int v83 = 65;
              int v84 = 361;
LABEL_160:
              ERR_put_error(14, 4095, v83, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_def.c", v84);
LABEL_161:
              a3 = v85;
              goto LABEL_147;
            }
            int v63 = section;
            if (!v49) {
              uint64_t v49 = section;
            }
            uint64_t v64 = strdup(v44);
            v62->value = 0;
            v62->name = v64;
            if (!v64)
            {
              int v83 = 65;
              int v84 = 369;
              goto LABEL_160;
            }
            if (!str_copy(a1, v49, (void **)&v62->value, v56)) {
              goto LABEL_161;
            }
            int v65 = strcmp(v49, v63);
            unsigned int v66 = v86;
            if (v65)
            {
              unsigned int v66 = _CONF_get_section(a1, v49);
              if (!v66)
              {
                unsigned int v66 = _CONF_new_section(a1, v49);
                if (!v66)
                {
                  int v83 = 103;
                  int v84 = 380;
                  goto LABEL_160;
                }
              }
            }
            a3 = v85;
            if (!_CONF_add_string(a1, v66, v62))
            {
              ERR_put_error(14, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_def.c", 387);
              goto LABEL_147;
            }
LABEL_116:
            char v10 = 0;
            LODWORD(v11) = 0;
LABEL_117:
            if (!BUF_MEM_grow(v8, v11 + 512))
            {
LABEL_139:
              int v76 = 7;
              int v77 = 254;
              goto LABEL_140;
            }
            goto LABEL_8;
          }
          ++v45;
        }
        int v41 = *v45;
        __int16 v43 = v24[*v45];
      }
    }
    do
    {
      unsigned int v68 = *(unsigned __int8 *)++v40;
      uint64_t v67 = v68;
    }
    while ((v24[v68] & 0x18) == 0x10);
    unsigned int v69 = v40;
LABEL_121:
    for (j = v69; ; uint64_t v67 = *(unsigned __int8 *)j)
    {
      __int16 v71 = v24[v67];
      if ((v71 & 0x20) == 0) {
        break;
      }
      int v72 = *(unsigned __int8 *)++j;
      if ((v24[v72] & 8) == 0) {
        ++j;
      }
LABEL_127:
      ;
    }
    if ((v71 & 0x307) != 0)
    {
      ++j;
      goto LABEL_127;
    }
    unsigned int v73 = j - 1;
    do
    {
      unsigned int v74 = *(unsigned __int8 *)++v73;
      uint64_t v67 = v74;
    }
    while ((v24[v74] & 0x18) == 0x10);
    if (!v67) {
      goto LABEL_163;
    }
    if (v67 == 93)
    {
      *int j = 0;
      if (!str_copy(a1, 0, (void **)&section, v40)) {
        goto LABEL_141;
      }
      unsigned int v75 = section;
      int v86 = _CONF_get_section(a1, section);
      if (!v86)
      {
        int v86 = _CONF_new_section(a1, v75);
        if (!v86)
        {
          int v76 = 103;
          int v77 = 329;
          goto LABEL_140;
        }
      }
      if (!BUF_MEM_grow(v8, 512)) {
        goto LABEL_139;
      }
      continue;
    }
    break;
  }
  BOOL v17 = v73 == v69;
  unsigned int v69 = v73;
  if (!v17) {
    goto LABEL_121;
  }
LABEL_163:
  int v76 = 100;
  int v77 = 320;
LABEL_140:
  ERR_put_error(14, 4095, v76, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_def.c", v77);
LABEL_141:
  int v62 = 0;
LABEL_147:
  BUF_MEM_free(v8);
  unsigned int v78 = section;
LABEL_148:
  free(v78);
  if (a3) {
    *a3 = v9;
  }
  ERR_asprintf_error_data("line %ld", v9);
  unsigned int v81 = a1->data;
  if (data != v81 && v81)
  {
    CONF_free(v81);
    a1->unsigned int data = 0;
  }
  if (v62)
  {
    free(v62->name);
    free(v62->value);
    free(v62);
  }
  return 0;
}

uint64_t def_dump(uint64_t a1, void *arg)
{
  return 1;
}

uint64_t def_is_number(uint64_t a1, unsigned __int8 a2)
{
  return *(_WORD *)(*(void *)(a1 + 8) + 2 * a2) & 1;
}

uint64_t def_to_int(uint64_t a1, int a2)
{
  return (a2 - 48);
}

uint64_t def_load(CONF *a1, char *filename, char **a3)
{
  uint64_t v5 = BIO_new_file(filename, "rb");
  if (v5)
  {
    unint64_t v6 = v5;
    uint64_t bio = def_load_bio(a1, v5, a3);
    BIO_free(v6);
    return bio;
  }
  else
  {
    if ((ERR_peek_last_error() & 0xFFF) == 0x80)
    {
      int v9 = 114;
      int v10 = 200;
    }
    else
    {
      int v9 = 2;
      int v10 = 202;
    }
    ERR_put_error(14, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_def.c", v10);
    return 0;
  }
}

BUF_MEM *str_copy(const CONF *a1, char *a2, void **a3, const char *a4)
{
  int32x2_t result = BUF_MEM_new();
  if (!result) {
    return result;
  }
  int v9 = result;
  int v10 = strlen(a4);
  if (!BUF_MEM_grow(v9, v10 + 1)) {
    goto LABEL_86;
  }
  char v52 = 0;
  int v11 = 0;
  while (1)
  {
    for (uint64_t i = a4; ; ++i)
    {
      while (1)
      {
        while (1)
        {
          while (1)
          {
            meth_unsigned int data = a1->meth_data;
            unsigned int v14 = *(unsigned __int8 *)i;
            __int16 v15 = meth_data[*(unsigned __int8 *)i];
            if ((v15 & 0x40) == 0) {
              break;
            }
            BOOL v17 = (unsigned __int8 *)(i + 1);
            int v18 = *((unsigned __int8 *)i + 1);
            __int16 v19 = meth_data[*((unsigned __int8 *)i + 1)];
            if (v18 != v14 && (v19 & 8) == 0)
            {
              uint64_t v21 = v11;
              while (1)
              {
                if ((v19 & 0x20) != 0)
                {
                  int v18 = *((unsigned __int8 *)i + 2);
                  BOOL v17 = (unsigned __int8 *)(i + 2);
                  if ((meth_data[*((unsigned __int8 *)i + 2)] & 8) != 0) {
                    break;
                  }
                }
                uint64_t i = (const char *)v17;
                int v11 = v21 + 1;
                v9->data[v21] = v18;
                int v22 = *++v17;
                int v18 = v22;
                meth_unsigned int data = a1->meth_data;
                __int16 v19 = meth_data[v22];
                BOOL v23 = v22 != v14 && (v19 & 8) == 0;
                ++v21;
                if (!v23) {
                  goto LABEL_44;
                }
              }
              int v11 = v21;
            }
LABEL_44:
            if (v18 == v14) {
              uint64_t i = (const char *)(v17 + 1);
            }
            else {
              uint64_t i = (const char *)v17;
            }
          }
          if ((meth_data[*(unsigned __int8 *)i] & 0x400) == 0) {
            break;
          }
          int v24 = (unsigned __int8 *)(i + 1);
          unsigned int v25 = *((unsigned __int8 *)i + 1);
          if ((meth_data[*((unsigned __int8 *)i + 1)] & 8) == 0)
          {
            uint64_t v26 = v11;
            do
            {
              if (v25 == v14)
              {
                if (*((unsigned __int8 *)i + 2) != v14)
                {
                  unsigned int v25 = v14;
                  break;
                }
                LOBYTE(v25) = v14;
                int v24 = (unsigned __int8 *)(i + 2);
              }
              uint64_t i = (const char *)v24;
              v9->data[v26++] = v25;
              ++v11;
              unsigned int v27 = *++v24;
              unsigned int v25 = v27;
            }
            while ((*((_WORD *)a1->meth_data + v27) & 8) == 0);
          }
          if (v25 == v14) {
            i += 2;
          }
          else {
            uint64_t i = (const char *)v24;
          }
        }
        if ((v15 & 0x20) == 0) {
          break;
        }
        int v28 = *((unsigned __int8 *)i + 1);
        if ((meth_data[*((unsigned __int8 *)i + 1)] & 8) != 0)
        {
LABEL_80:
          v9->data[v11] = 0;
          free(*a3);
          *a3 = v9->data;
          free(v9);
          return (BUF_MEM *)1;
        }
        i += 2;
        if (v28 == 116) {
          char v29 = 9;
        }
        else {
          char v29 = v28;
        }
        if (v28 == 110) {
          char v29 = 10;
        }
        if (v28 == 114) {
          char v29 = 13;
        }
        if (v28 == 98) {
          char v30 = 8;
        }
        else {
          char v30 = v29;
        }
        v9->data[v11++] = v30;
      }
      if ((v15 & 8) != 0) {
        goto LABEL_80;
      }
      int v16 = i + 1;
      if (v14 == 36) {
        break;
      }
      v9->data[v11++] = v14;
    }
    int v31 = *(unsigned __int8 *)v16;
    sectioint n = a2;
    if (v31 == 123)
    {
      int v32 = 125;
    }
    else
    {
      if (v31 != 40)
      {
        int v32 = 0;
        char v33 = 1;
        goto LABEL_57;
      }
      int v32 = 41;
    }
    char v33 = 0;
    int v16 = i + 2;
LABEL_57:
    long long v34 = (char *)(v16 - 1);
    long long v35 = v16 + 1;
    do
    {
      int v36 = (char *)v35;
      int v38 = *++v34;
      int v37 = v38;
      ++v35;
    }
    while ((meth_data[v38] & 0x107) != 0);
    if (v37 != 58) {
      goto LABEL_65;
    }
    if (v34[1] != 58)
    {
      LOBYTE(v37) = 58;
LABEL_65:
      int v36 = v34;
      int v39 = v16;
      int v16 = section;
      long long v34 = 0;
      goto LABEL_66;
    }
    *long long v34 = 0;
    int v39 = v34 + 2;
    do
    {
      unsigned int v40 = *++v36;
      LOBYTE(v37) = v40;
    }
    while ((*((_WORD *)a1->meth_data + v40) & 0x107) != 0);
    char v52 = 58;
LABEL_66:
    *int v36 = 0;
    a4 = v36;
    if (v33) {
      goto LABEL_69;
    }
    if (v32 != (char)v37) {
      break;
    }
    a4 = v36 + 1;
LABEL_69:
    int v50 = a3;
    int string = _CONF_get_string(a1, v16, v39);
    int v42 = string;
    if (v34) {
      *long long v34 = v52;
    }
    *int v36 = v37;
    if (!string)
    {
      int v48 = 104;
      int v49 = 566;
      goto LABEL_85;
    }
    size_t v43 = i - a4 + strlen(string) + *(void *)&v9->length;
    if (v43 > 0x10000)
    {
      int v48 = 116;
      int v49 = 571;
      goto LABEL_85;
    }
    if (!BUF_MEM_grow_clean(v9, v43))
    {
      int v48 = 109;
      int v49 = 575;
      goto LABEL_85;
    }
    char v44 = *v42;
    if (*v42)
    {
      uint64_t v45 = v11;
      int v46 = (unsigned __int8 *)(v42 + 1);
      a3 = v50;
      a2 = section;
      do
      {
        v9->data[v45++] = v44;
        int v47 = *v46++;
        char v44 = v47;
        ++v11;
      }
      while (v47);
    }
    else
    {
      a3 = v50;
      a2 = section;
    }
    *int v36 = v37;
  }
  int v48 = 102;
  int v49 = 547;
LABEL_85:
  ERR_put_error(14, 4095, v48, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_def.c", v49);
LABEL_86:
  BUF_MEM_free(v9);
  return 0;
}

uint64_t dump_value_LHASH_DOALL_ARG(uint64_t a1, BIO *bio)
{
  if (*(void *)(a1 + 8)) {
    return BIO_printf(bio, "[%s] %s=%s\n");
  }
  else {
    return BIO_printf(bio, "[[%s]]\n");
  }
}

uint64_t def_init_WIN32(uint64_t result)
{
  if (result)
  {
    *(void *)int32x2_t result = &WIN32_method;
    *(void *)(result + 8) = &CONF_type_win32;
    *(void *)(result + 16) = 0;
    return 1;
  }
  return result;
}

void CRYPTO_lock(int mode, int type, const char *file, int line)
{
  if (type <= 0x28)
  {
    if (mode)
    {
      pthread_mutex_lock((pthread_mutex_t *)&locks + type);
    }
    else if ((mode & 2) != 0)
    {
      pthread_mutex_unlock((pthread_mutex_t *)&locks + type);
    }
  }
}

int CRYPTO_add_lock(int *pointer, int amount, int type, const char *file, int line)
{
  if (type < 0x29)
  {
    uint64_t v8 = (pthread_mutex_t *)((char *)&locks + 64 * (unint64_t)type);
    pthread_mutex_lock(v8);
    int v7 = *pointer + amount;
    *pointer = v7;
    pthread_mutex_unlock(v8);
  }
  else
  {
    int v7 = *pointer + amount;
    *pointer = v7;
  }
  return v7;
}

int X509_NAME_get_text_by_NID(X509_NAME *name, int nid, char *buf, int len)
{
  int v7 = OBJ_nid2obj(nid);
  if (!v7) {
    return -1;
  }
  return X509_NAME_get_text_by_OBJ(name, v7, buf, len);
}

int X509_NAME_get_text_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj, char *buf, int len)
{
  LODWORD(v7) = -1;
  int index_by_OBJ = X509_NAME_get_index_by_OBJ(name, obj, -1);
  if ((index_by_OBJ & 0x80000000) == 0)
  {
    entry = X509_NAME_get_entry(name, index_by_OBJ);
    if (entry) {
      value = (const void **)entry->value;
    }
    else {
      value = 0;
    }
    if (*(_DWORD *)value >= len) {
      size_t v7 = (len - 1);
    }
    else {
      size_t v7 = *(unsigned int *)value;
    }
    if (buf)
    {
      if ((v7 & 0x80000000) == 0)
      {
        memcpy(buf, value[1], v7);
        buf[v7] = 0;
      }
    }
    else
    {
      LODWORD(v7) = *(_DWORD *)value;
    }
  }
  return v7;
}

int X509_NAME_get_index_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj, int lastpos)
{
  if (name)
  {
    if (lastpos < 0) {
      int v4 = -1;
    }
    else {
      int v4 = lastpos;
    }
    entries = name->entries;
    int v6 = sk_num(name->entries);
    while (++v4 < v6)
    {
      size_t v7 = sk_value(entries, v4);
      if (!OBJ_cmp(*(const ASN1_OBJECT **)v7, obj)) {
        return v4;
      }
    }
  }
  return -1;
}

ASN1_STRING *__cdecl X509_NAME_ENTRY_get_data(ASN1_STRING *ne)
{
  if (ne) {
    return (ASN1_STRING *)ne->data;
  }
  return ne;
}

X509_NAME_ENTRY *__cdecl X509_NAME_get_entry(X509_NAME *name, int loc)
{
  if (!name) {
    return 0;
  }
  int v4 = sk_num(name->entries);
  if (loc < 0 || v4 <= loc) {
    return 0;
  }
  entries = name->entries;
  return (X509_NAME_ENTRY *)sk_value(entries, loc);
}

int X509_NAME_entry_count(X509_NAME *name)
{
  if (name) {
    LODWORD(namengine_table_unregister(&rsa_table, e) = sk_num(name->entries);
  }
  return (int)name;
}

int X509_NAME_get_index_by_NID(X509_NAME *name, int nid, int lastpos)
{
  uint64_t v5 = OBJ_nid2obj(nid);
  if (!v5) {
    return -2;
  }
  return X509_NAME_get_index_by_OBJ(name, v5, lastpos);
}

X509_NAME_ENTRY *__cdecl X509_NAME_delete_entry(X509_NAME *name, int loc)
{
  if (!name) {
    return 0;
  }
  int v4 = sk_num(name->entries);
  uint64_t v5 = 0;
  if ((loc & 0x80000000) == 0 && v4 > loc)
  {
    entries = name->entries;
    uint64_t v5 = (X509_NAME_ENTRY *)sk_delete(name->entries, loc);
    int v7 = sk_num(entries);
    name->modifiechar d = 1;
    if (v7 != loc)
    {
      int v8 = v7;
      if (loc) {
        int set = *((_DWORD *)sk_value(entries, loc - 1) + 4) + 1;
      }
      else {
        int set = v5->set;
      }
      if (set < *((_DWORD *)sk_value(entries, loc) + 4) && v8 > loc)
      {
        do
        {
          uint64_t v12 = sk_value(entries, loc);
          --*((_DWORD *)v12 + 4);
          ++loc;
        }
        while (v8 != loc);
      }
    }
  }
  return v5;
}

int X509_NAME_add_entry_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj, int type, unsigned __int8 *bytes, int len, int loc, int set)
{
  int v10 = X509_NAME_ENTRY_create_by_OBJ(0, obj, type, bytes, len);
  if (v10)
  {
    int v11 = v10;
    int v12 = X509_NAME_add_entry(name, v10, loc, set);
    X509_NAME_ENTRY_free(v11);
    LODWORD(v10) = v12;
  }
  return (int)v10;
}

X509_NAME_ENTRY *__cdecl X509_NAME_ENTRY_create_by_OBJ(X509_NAME_ENTRY **ne, ASN1_OBJECT *obj, int type, const unsigned __int8 *bytes, int len)
{
  if (ne && (int v10 = *ne) != 0 || (int v10 = X509_NAME_ENTRY_new()) != 0)
  {
    if (X509_NAME_ENTRY_set_object(v10, obj) && X509_NAME_ENTRY_set_data(v10, type, bytes, len))
    {
      if (ne && !*ne) {
        *ne = v10;
      }
    }
    else
    {
      if (!ne || v10 != *ne) {
        X509_NAME_ENTRY_free(v10);
      }
      return 0;
    }
  }
  return v10;
}

int X509_NAME_add_entry(X509_NAME *name, X509_NAME_ENTRY *ne, int loc, int set)
{
  if (!name) {
    return (int)name;
  }
  int v7 = name;
  entries = name->entries;
  int v9 = sk_num(name->entries);
  if (v9 < loc || loc < 0) {
    loc = v9;
  }
  BOOL v11 = set == 0;
  v7->modifiechar d = 1;
  if (set == -1)
  {
    if (loc)
    {
      int v12 = sk_value(entries, loc - 1);
      BOOL v11 = 0;
      goto LABEL_12;
    }
    int v13 = 0;
    BOOL v11 = 1;
  }
  else
  {
    if (loc < v9)
    {
      int v12 = sk_value(entries, loc);
LABEL_12:
      int v13 = *((_DWORD *)v12 + 4);
      goto LABEL_17;
    }
    if (loc) {
      int v13 = *((_DWORD *)sk_value(entries, loc - 1) + 4) + 1;
    }
    else {
      int v13 = 0;
    }
  }
LABEL_17:
  name = (X509_NAME *)X509_NAME_ENTRY_dup(ne);
  if (name)
  {
    unsigned int v14 = name;
    LODWORD(name->bytes) = v13;
    if (sk_insert(entries, (char *)name, loc))
    {
      if (v11)
      {
        int v15 = sk_num(entries);
        int v16 = loc + 1;
        if (v16 < v15)
        {
          int v17 = v15;
          do
          {
            int v18 = sk_value(entries, v16);
            ++*((_DWORD *)v18 + 4);
            ++v16;
          }
          while (v17 != v16);
        }
      }
      LODWORD(namengine_table_unregister(&rsa_table, e) = 1;
    }
    else
    {
      ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509name.c", 290);
      X509_NAME_ENTRY_free((X509_NAME_ENTRY *)v14);
      LODWORD(namengine_table_unregister(&rsa_table, e) = 0;
    }
  }
  return (int)name;
}

int X509_NAME_add_entry_by_NID(X509_NAME *name, int nid, int type, unsigned __int8 *bytes, int len, int loc, int set)
{
  int v10 = X509_NAME_ENTRY_create_by_NID(0, nid, type, bytes, len);
  if (v10)
  {
    BOOL v11 = v10;
    int v12 = X509_NAME_add_entry(name, v10, loc, set);
    X509_NAME_ENTRY_free(v11);
    LODWORD(v10) = v12;
  }
  return (int)v10;
}

X509_NAME_ENTRY *__cdecl X509_NAME_ENTRY_create_by_NID(X509_NAME_ENTRY **ne, int nid, int type, unsigned __int8 *bytes, int len)
{
  int v9 = OBJ_nid2obj(nid);
  if (v9)
  {
    int v10 = v9;
    BOOL v11 = X509_NAME_ENTRY_create_by_OBJ(ne, v9, type, bytes, len);
    ASN1_OBJECT_free(v10);
    return v11;
  }
  else
  {
    ERR_put_error(11, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509name.c", 335);
    return 0;
  }
}

int X509_NAME_add_entry_by_txt(X509_NAME *name, const char *field, int type, const unsigned __int8 *bytes, int len, int loc, int set)
{
  int v10 = X509_NAME_ENTRY_create_by_txt(0, field, type, bytes, len);
  if (v10)
  {
    BOOL v11 = v10;
    int v12 = X509_NAME_add_entry(name, v10, loc, set);
    X509_NAME_ENTRY_free(v11);
    LODWORD(v10) = v12;
  }
  return (int)v10;
}

X509_NAME_ENTRY *__cdecl X509_NAME_ENTRY_create_by_txt(X509_NAME_ENTRY **ne, const char *field, int type, const unsigned __int8 *bytes, int len)
{
  int v10 = OBJ_txt2obj(field, 0);
  if (v10)
  {
    BOOL v11 = v10;
    int v12 = X509_NAME_ENTRY_create_by_OBJ(ne, v10, type, bytes, len);
    ASN1_OBJECT_free(v11);
    return v12;
  }
  else
  {
    ERR_put_error(11, 4095, 119, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509name.c", 316);
    ERR_asprintf_error_data("name=%s", field);
    return 0;
  }
}

int X509_NAME_ENTRY_set_object(X509_NAME_ENTRY *ne, ASN1_OBJECT *obj)
{
  if (ne && obj)
  {
    ASN1_OBJECT_free(ne->object);
    int v4 = OBJ_dup(obj);
    ne->int object = v4;
    return v4 != 0;
  }
  else
  {
    ERR_put_error(11, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509name.c", 376);
    return 0;
  }
}

int X509_NAME_ENTRY_set_data(X509_NAME_ENTRY *ne, int type, const unsigned __int8 *bytes, int len)
{
  if (ne)
  {
    int v4 = len;
    int v7 = ne;
    if (bytes || !len)
    {
      if (type >= 1 && (type & 0x1000) != 0)
      {
        int v8 = OBJ_obj2nid(ne->object);
        LODWORD(nengine_table_unregister(&rsa_table, e) = ASN1_STRING_set_by_NID(&v7->value, bytes, v4, type, v8) != 0;
      }
      else
      {
        if (len < 0) {
          int v4 = strlen((const char *)bytes);
        }
        LODWORD(nengine_table_unregister(&rsa_table, e) = ASN1_STRING_set(v7->value, bytes, v4);
        if (ne)
        {
          if (type != -1)
          {
            if (type == -2) {
              v7->value->int type = ASN1_PRINTABLE_type(bytes, v4);
            }
            else {
              v7->value->int type = type;
            }
          }
          LODWORD(nengine_table_unregister(&rsa_table, e) = 1;
        }
      }
    }
    else
    {
      LODWORD(nengine_table_unregister(&rsa_table, e) = 0;
    }
  }
  return (int)ne;
}

ASN1_OBJECT *__cdecl X509_NAME_ENTRY_get_object(ASN1_OBJECT *ne)
{
  if (ne) {
    return (ASN1_OBJECT *)ne->sn;
  }
  return ne;
}

uint64_t X509_NAME_ENTRY_set(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t engine_unlocked_init(uint64_t a1)
{
  LODWORD(v2) = *(_DWORD *)(a1 + 184);
  if (v2 || (int v2 = *(uint64_t (**)(uint64_t))(a1 + 120)) == 0)
  {
    uint64_t result = 1;
LABEL_3:
    ++*(_DWORD *)(a1 + 180);
    *(_DWORD *)(a1 + 184) = v2 + 1;
    return result;
  }
  uint64_t result = v2(a1);
  if (result)
  {
    LODWORD(v2) = *(_DWORD *)(a1 + 184);
    goto LABEL_3;
  }
  return result;
}

uint64_t engine_unlocked_finish(uint64_t a1, int a2)
{
  int v3 = *(_DWORD *)(a1 + 184) - 1;
  *(_DWORD *)(a1 + 184) = v3;
  if (v3 || (int v6 = *(uint64_t (**)(uint64_t))(a1 + 128)) == 0)
  {
    uint64_t v4 = 1;
  }
  else if (a2)
  {
    CRYPTO_lock(10, 30, 0, 0);
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(a1 + 128))(a1);
    CRYPTO_lock(9, 30, 0, 0);
    if (!v4) {
      return v4;
    }
  }
  else
  {
    uint64_t v4 = v6(a1);
    if (!v4) {
      return v4;
    }
  }
  if (!engine_free_util((CRYPTO_EX_DATA *)a1, 0))
  {
    ERR_put_error(38, 4095, 106, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_init.c", 109);
    return 0;
  }
  return v4;
}

int ENGINE_init(ENGINE *e)
{
  if (!e)
  {
    ERR_put_error(38, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_init.c", 122);
    return 0;
  }
  CRYPTO_lock(9, 30, 0, 0);
  LODWORD(v2) = *((_DWORD *)e + 46);
  if (v2 || (int v2 = (uint64_t (*)(ENGINE *))*((void *)e + 15)) == 0)
  {
    int v3 = 1;
  }
  else
  {
    int v3 = v2(e);
    if (!v3) {
      goto LABEL_5;
    }
    LODWORD(v2) = *((_DWORD *)e + 46);
  }
  ++*((_DWORD *)e + 45);
  *((_DWORD *)e + 46) = v2 + 1;
LABEL_5:
  CRYPTO_lock(10, 30, 0, 0);
  return v3;
}

int ENGINE_finish(ENGINE *e)
{
  if (!e) {
    return 1;
  }
  CRYPTO_lock(9, 30, 0, 0);
  int v2 = engine_unlocked_finish((uint64_t)e, 1);
  CRYPTO_lock(10, 30, 0, 0);
  if (!v2) {
    ERR_put_error(38, 4095, 106, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_init.c", 143);
  }
  return v2;
}

uint64_t BN_mod_ct(BIGNUM *a1, const BIGNUM *a2, const BIGNUM *a3, BN_CTX *a4)
{
  return BN_div_ct(0, a1, a2, a3, a4);
}

uint64_t BN_mod_nonct(BIGNUM *a1, const BIGNUM *a2, const BIGNUM *a3, BN_CTX *a4)
{
  return BN_div_nonct(0, a1, a2, a3, a4);
}

int BN_nnmod(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx)
{
  int result = BN_div_ct(0, r, m, d, ctx);
  if (result)
  {
    if (BN_is_negative((uint64_t)r))
    {
      return BN_usub(r, d, r);
    }
    else
    {
      return 1;
    }
  }
  return result;
}

int BN_mod_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx)
{
  int result = BN_add(r, a, b);
  if (result)
  {
    return BN_nnmod(r, r, m, ctx);
  }
  return result;
}

int BN_mod_add_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m)
{
  int result = BN_uadd(r, a, b);
  if (result)
  {
    if (BN_ucmp(r, m) < 0)
    {
      return 1;
    }
    else
    {
      return BN_usub(r, r, m);
    }
  }
  return result;
}

int BN_mod_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx)
{
  int result = BN_sub(r, a, b);
  if (result)
  {
    return BN_nnmod(r, r, m, ctx);
  }
  return result;
}

int BN_mod_sub_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m)
{
  if (BN_ucmp(a, b) < 0)
  {
    int result = BN_usub(r, b, a);
    if (!result) {
      return result;
    }
    int v8 = r;
    int v9 = m;
    int v10 = r;
  }
  else
  {
    int v8 = r;
    int v9 = a;
    int v10 = b;
  }
  return BN_usub(v8, v9, v10);
}

int BN_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m, BN_CTX *ctx)
{
  BN_CTX_start(ctx);
  if (r == a || (int v10 = r, r == b))
  {
    int v10 = BN_CTX_get(ctx);
    if (!v10) {
      goto LABEL_10;
    }
  }
  else if (!r)
  {
    goto LABEL_10;
  }
  if (a == b)
  {
    if (BN_sqr(v10, a, ctx)) {
      goto LABEL_8;
    }
LABEL_10:
    BOOL v11 = 0;
    goto LABEL_11;
  }
  if (!BN_mul(v10, a, b, ctx)) {
    goto LABEL_10;
  }
LABEL_8:
  BOOL v11 = BN_nnmod(r, v10, m, ctx) != 0;
LABEL_11:
  BN_CTX_end(ctx);
  return v11;
}

int BN_mod_sqr(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx)
{
  return BN_mod_mul(r, a, a, m, ctx);
}

int BN_mod_lshift1(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx)
{
  int result = BN_lshift1(r, a);
  if (result)
  {
    return BN_nnmod(r, r, m, ctx);
  }
  return result;
}

int BN_mod_lshift1_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *m)
{
  int result = BN_lshift1(r, a);
  if (result)
  {
    if (BN_ucmp(r, m) < 0)
    {
      return 1;
    }
    else
    {
      return BN_usub(r, r, m);
    }
  }
  return result;
}

int BN_mod_lshift(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m, BN_CTX *ctx)
{
  BN_CTX_start(ctx);
  if (BN_nnmod(r, a, m, ctx))
  {
    if (!BN_is_negative((uint64_t)m))
    {
      BOOL v11 = (BIGNUM *)m;
      goto LABEL_8;
    }
    int v10 = BN_CTX_get(ctx);
    if (v10)
    {
      BOOL v11 = v10;
      if (bn_copy(v10, m))
      {
        BN_set_negative(v11, 0);
LABEL_8:
        int v12 = BN_mod_lshift_quick(r, r, n, v11);
        goto LABEL_9;
      }
    }
  }
  int v12 = 0;
LABEL_9:
  BN_CTX_end(ctx);
  return v12;
}

int BN_mod_lshift_quick(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m)
{
  int result = bn_copy(r, a);
  if (result)
  {
    if (n < 1)
    {
      return 1;
    }
    else
    {
      while (1)
      {
        int v8 = BN_num_bits(m);
        int v9 = BN_num_bits(r);
        unsigned int v10 = v8 - v9;
        if (v8 - v9 < 0) {
          break;
        }
        if (v8 == v9) {
          unsigned int v10 = 1;
        }
        if (v10 >= n) {
          int v11 = n;
        }
        else {
          int v11 = v10;
        }
        int result = BN_lshift(r, r, v11);
        if (!result) {
          return result;
        }
        if ((BN_ucmp(r, m) & 0x80000000) == 0)
        {
          int result = BN_usub(r, r, m);
          if (!result) {
            return result;
          }
        }
        BOOL v12 = __OFSUB__(n, v11);
        n -= v11;
        if ((n < 0) ^ v12 | (n == 0)) {
          return 1;
        }
      }
      ERR_put_error(3, 4095, 110, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_mod.c", 296);
      return 0;
    }
  }
  return result;
}

PBE2PARAM *__cdecl d2i_PBE2PARAM(PBE2PARAM **a, const unsigned __int8 **in, uint64_t len)
{
  return (PBE2PARAM *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PBE2PARAM_it);
}

int i2d_PBE2PARAM(PBE2PARAM *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PBE2PARAM_it);
}

PBE2PARAM *PBE2PARAM_new(void)
{
  return (PBE2PARAM *)ASN1_item_new(&PBE2PARAM_it);
}

void PBE2PARAM_free(PBE2PARAM *a)
{
}

PBKDF2PARAM *__cdecl d2i_PBKDF2PARAM(PBKDF2PARAM **a, const unsigned __int8 **in, uint64_t len)
{
  return (PBKDF2PARAM *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PBKDF2PARAM_it);
}

int i2d_PBKDF2PARAM(PBKDF2PARAM *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PBKDF2PARAM_it);
}

PBKDF2PARAM *PBKDF2PARAM_new(void)
{
  return (PBKDF2PARAM *)ASN1_item_new(&PBKDF2PARAM_it);
}

void PBKDF2PARAM_free(PBKDF2PARAM *a)
{
}

X509_ALGOR *PKCS5_pbe2_set_iv(const EVP_CIPHER *a1, int a2, const void *a3, int a4, uint64_t a5, int a6)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  int ptr = a6;
  memset(&a, 0, sizeof(a));
  int v12 = EVP_CIPHER_type(a1);
  if (!v12)
  {
    ERR_put_error(13, 4095, 108, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/p5_pbev2.c", 198);
    int v20 = 0;
    int v16 = 0;
LABEL_26:
    ASN1_item_free(v16, &PBE2PARAM_it);
    X509_ALGOR_free(0);
    X509_ALGOR_free(v20);
    return 0;
  }
  int v13 = v12;
  unsigned int v14 = OBJ_nid2obj(v12);
  int v15 = ASN1_item_new(&PBE2PARAM_it);
  int v16 = v15;
  if (!v15
    || (uint64_t v17 = *((void *)v15 + 1), *(void *)uint64_t v17 = v14, v18 = ASN1_TYPE_new(), (*(void *)(v17 + 8) = v18) == 0))
  {
LABEL_24:
    int v20 = 0;
LABEL_25:
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/p5_pbev2.c", 278);
    goto LABEL_26;
  }
  if (EVP_CIPHER_iv_length(a1))
  {
    size_t v19 = EVP_CIPHER_iv_length(a1);
    if (a5) {
      __memcpy_chk();
    }
    else {
      arc4random_buf(__buf, v19);
    }
  }
  EVP_CIPHER_CTX_init(&a);
  if (!EVP_CipherInit_ex(&a, a1, 0, 0, __buf, 0))
  {
LABEL_17:
    int v20 = 0;
    goto LABEL_26;
  }
  if (EVP_CIPHER_param_to_asn1(&a, *(ASN1_TYPE **)(v17 + 8)) < 0)
  {
    ERR_put_error(13, 4095, 114, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/p5_pbev2.c", 227);
    EVP_CIPHER_CTX_cleanup(&a);
    goto LABEL_17;
  }
  if (a6 == -1 && EVP_CIPHER_CTX_ctrl(&a, 7, 0, &ptr) <= 0)
  {
    ERR_clear_error();
    int ptr = 163;
  }
  EVP_CIPHER_CTX_cleanup(&a);
  if (v13 == 37) {
    int v21 = EVP_CIPHER_key_length(a1);
  }
  else {
    int v21 = -1;
  }
  X509_ALGOR_free(*(X509_ALGOR **)v16);
  int v22 = PKCS5_pbkdf2_set(a2, a3, a4, ptr, v21);
  *(void *)int v16 = v22;
  if (!v22) {
    goto LABEL_24;
  }
  int v20 = X509_ALGOR_new();
  if (!v20) {
    goto LABEL_25;
  }
  BOOL v23 = ASN1_TYPE_new();
  v20->parameter = v23;
  if (!v23) {
    goto LABEL_25;
  }
  v20->algorithm = OBJ_nid2obj(161);
  if (!ASN1_item_pack(v16, &PBE2PARAM_it, (ASN1_OCTET_STRING **)&v20->parameter->value)) {
    goto LABEL_25;
  }
  v20->parameter->int type = 16;
  ASN1_item_free(v16, &PBE2PARAM_it);
  return v20;
}

X509_ALGOR *PKCS5_pbkdf2_set(int a1, const void *a2, int a3, int a4, int a5)
{
  unsigned int v10 = ASN1_item_new(&PBKDF2PARAM_it);
  if (!v10) {
    goto LABEL_25;
  }
  int v11 = ASN1_OCTET_STRING_new();
  if (!v11) {
    goto LABEL_25;
  }
  int v12 = v11;
  *(void *)(*(void *)v10 + 8) = v11;
  **(_DWORD **)unsigned int v10 = 4;
  int v13 = a3 ? a3 : 8;
  unsigned int v14 = (unsigned __int8 *)malloc_type_malloc(v13, 0xDCB0AC39uLL);
  v12->unsigned int data = v14;
  if (!v14) {
    goto LABEL_25;
  }
  v12->uint64_t length = v13;
  if (a2) {
    memcpy(v14, a2, v13);
  }
  else {
    arc4random_buf(v14, v13);
  }
  uint64_t v15 = a1 >= 1 ? a1 : 2048;
  if (!ASN1_INTEGER_set(*((ASN1_INTEGER **)v10 + 1), v15)) {
    goto LABEL_25;
  }
  if (a5 >= 1)
  {
    int v16 = ASN1_INTEGER_new();
    *((void *)v10 + 2) = v16;
    if (!v16 || !ASN1_INTEGER_set(v16, a5)) {
      goto LABEL_25;
    }
  }
  if (a4 >= 1 && a4 != 163)
  {
    uint64_t v17 = X509_ALGOR_new();
    *((void *)v10 + 3) = v17;
    if (v17)
    {
      int v18 = v17;
      size_t v19 = OBJ_nid2obj(a4);
      X509_ALGOR_set0(v18, v19, 5, 0);
      goto LABEL_21;
    }
LABEL_25:
    int v20 = 0;
LABEL_26:
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/p5_pbev2.c", 370);
    ASN1_item_free(v10, &PBKDF2PARAM_it);
    X509_ALGOR_free(v20);
    return 0;
  }
LABEL_21:
  int v20 = X509_ALGOR_new();
  if (!v20) {
    goto LABEL_26;
  }
  v20->algorithm = OBJ_nid2obj(69);
  int v21 = ASN1_TYPE_new();
  v20->parameter = v21;
  if (!v21 || !ASN1_item_pack(v10, &PBKDF2PARAM_it, (ASN1_OCTET_STRING **)&v21->value)) {
    goto LABEL_26;
  }
  v20->parameter->int type = 16;
  ASN1_item_free(v10, &PBKDF2PARAM_it);
  return v20;
}

X509_ALGOR *__cdecl PKCS5_pbe2_set(const EVP_CIPHER *cipher, int iter, unsigned __int8 *salt, int saltlen)
{
  return PKCS5_pbe2_set_iv(cipher, iter, salt, saltlen, 0, -1);
}

int PKCS5_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen, ASN1_TYPE *param, const EVP_CIPHER *cipher, const EVP_MD *md, int en_de)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  if (!param || param->type != 16 || !param->value.ptr)
  {
    int v21 = 95;
    goto LABEL_10;
  }
  int v14 = EVP_MD_size(md);
  if ((v14 & 0x80000000) == 0)
  {
    unsigned int v15 = v14;
    long long v30 = 0u;
    memset(&ctxa, 0, sizeof(ctxa));
    int ptr = param->value.ptr;
    iint n = (unsigned __int8 *)*((void *)ptr + 1);
    uint64_t v17 = d2i_PBEPARAM(0, (const unsigned __int8 **)&in, *(int *)ptr);
    if (v17)
    {
      int v18 = v17;
      iter = v17->iter;
      if (iter)
      {
        int v20 = ASN1_INTEGER_get(iter);
        if (v20 <= 0)
        {
          ERR_put_error(6, 4095, 135, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p5_crpt.c", 112);
          PBEPARAM_free(v18);
          return 0;
        }
      }
      else
      {
        int v20 = 1;
      }
      unsigned int data = v18->salt->data;
      size_t cnt = v18->salt->length;
      if (pass)
      {
        if (passlen == -1) {
          passleint n = strlen(pass);
        }
      }
      else
      {
        passleint n = 0;
      }
      EVP_MD_CTX_init(&ctxa);
      if (EVP_DigestInit_ex(&ctxa, md, 0)
        && EVP_DigestUpdate(&ctxa, pass, passlen)
        && EVP_DigestUpdate(&ctxa, data, cnt)
        && EVP_DigestFinal_ex(&ctxa, mda, 0))
      {
        if (v20 >= 2)
        {
          int v24 = v20 - 1;
          while (EVP_DigestInit_ex(&ctxa, md, 0)
               && EVP_DigestUpdate(&ctxa, mda, v15)
               && EVP_DigestFinal_ex(&ctxa, mda, 0))
          {
            if (!--v24) {
              goto LABEL_28;
            }
          }
          goto LABEL_33;
        }
LABEL_28:
        if (EVP_CIPHER_key_length(cipher) < 0x41)
        {
          EVP_CIPHER_key_length(cipher);
          __memcpy_chk();
          if (EVP_CIPHER_iv_length(cipher) < 0x11)
          {
            EVP_CIPHER_iv_length(cipher);
            EVP_CIPHER_iv_length(cipher);
            __memcpy_chk();
            if (EVP_CipherInit_ex(ctx, cipher, 0, key, iv, en_de)) {
              explicit_bzero(mda, 0x40uLL);
            }
            goto LABEL_33;
          }
          int v25 = 102;
          int v26 = 148;
        }
        else
        {
          int v25 = 137;
          int v26 = 143;
        }
        ERR_put_error(6, 4095, v25, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p5_crpt.c", v26);
      }
LABEL_33:
      EVP_MD_CTX_cleanup(&ctxa);
      PBEPARAM_free(v18);
      return 0;
    }
    int v21 = 105;
LABEL_10:
    ERR_put_error(6, 4095, 114, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p5_crpt.c", v21);
  }
  return 0;
}

int BN_lshift1(BIGNUM *r, const BIGNUM *a)
{
  int top = a->top;
  if (top <= 0)
  {
    BN_zero((uint64_t)r);
  }
  else
  {
    int v5 = top + 1;
    int result = bn_wexpand((uint64_t)r, (top + 1));
    if (!result) {
      return result;
    }
    char d = a->d;
    uint64_t v8 = a->top;
    int v9 = &a->d[v8];
    unint64_t v11 = *(v9 - 1);
    unsigned int v10 = v9 - 1;
    int v12 = r->d;
    int v13 = &r->d[v8];
    for (unint64_t i = v11 >> 63; ; unint64_t i = v17 >> 63)
    {
      *v13-- = i;
      if (v10 <= d) {
        break;
      }
      unint64_t v15 = *v10;
      uint64_t v16 = *--v10;
      *((void *)&v17 + 1) = v15;
      *(void *)&long long v17 = v16;
    }
    *int v13 = 2 * *v10;
    while (v13 > v12)
      *--int v13 = 0;
    r->int top = v5;
    bn_correct_top((uint64_t *)r);
    BN_set_negative(r, a->neg);
  }
  return 1;
}

int BN_lshift(BIGNUM *r, const BIGNUM *a, int n)
{
  if (n < 0)
  {
    ERR_put_error(3, 4095, 106, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_shift.c", 32);
    return 0;
  }
  else
  {
    int top = a->top;
    if (top <= 0)
    {
      BN_zero((uint64_t)r);
    }
    else
    {
      char v7 = n;
      unint64_t v8 = (unint64_t)n >> 6;
      unsigned int v9 = v8 + top + 1;
      int result = bn_wexpand((uint64_t)r, v9);
      if (!result) {
        return result;
      }
      char v11 = v7 & 0x3F;
      uint64_t v12 = -n & 0x3FLL;
      unint64_t v13 = (v7 & 0x3F) + v12;
      char d = a->d;
      uint64_t v15 = a->top;
      uint64_t v16 = &a->d[v15];
      unint64_t v18 = *(v16 - 1);
      long long v17 = v16 - 1;
      size_t v19 = r->d;
      int v20 = &r->d[v15 + v8];
      *int v20 = (v18 >> v12) & -(uint64_t)(v13 >> 6);
      int v21 = v20 - 1;
      if (v17 > d)
      {
        uint64_t v22 = (uint64_t)&v19[v8 - 1];
        BOOL v23 = d - 1;
        uint64_t v24 = (uint64_t)&d[-(v13 >> 6) - 1];
        do
        {
          *(void *)(v22 + 8 * v15) = (*(void *)(v24 + 8 * v15) >> v12) | (v23[v15] << v11);
          v22 -= 8;
          --v23;
          v24 -= 8;
        }
        while (&v23[v15] > d);
        int v21 = (unint64_t *)(v22 + 8 * v15);
        long long v17 = &v23[v15];
      }
      *int v21 = *v17 << v11;
      while (v21 > v19)
        *--int v21 = 0;
      r->int top = v9;
      bn_correct_top((uint64_t *)r);
      BN_set_negative(r, a->neg);
    }
    return 1;
  }
}

int BN_rshift1(BIGNUM *r, const BIGNUM *a)
{
  unsigned int top = a->top;
  if (top)
  {
    int result = bn_wexpand((uint64_t)r, a->top);
    if (!result) {
      return result;
    }
    char d = a->d;
    char v7 = r->d;
    if (top < 2)
    {
      unsigned int v9 = a->d;
    }
    else
    {
      uint64_t v8 = (int)top - 1;
      unsigned int v9 = a->d;
      do
      {
        unint64_t v10 = v9[1];
        ++v9;
        *((void *)&v11 + 1) = v10;
        *(void *)&long long v11 = *d;
        *v7++ = v11 >> 1;
        char d = v9;
        --v8;
      }
      while (v8);
    }
    *char v7 = *v9 >> 1;
    r->unsigned int top = top;
    bn_correct_top((uint64_t *)r);
    BN_set_negative(r, a->neg);
  }
  else
  {
    BN_zero((uint64_t)r);
  }
  return 1;
}

int BN_rshift(BIGNUM *r, const BIGNUM *a, int n)
{
  if (n < 0)
  {
    ERR_put_error(3, 4095, 106, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_shift.c", 103);
    return 0;
  }
  else
  {
    char v6 = n;
    unint64_t top = a->top;
    if (top <= (unint64_t)n >> 6)
    {
      BN_zero((uint64_t)r);
    }
    else
    {
      unint64_t v8 = (unint64_t)n >> 6;
      unint64_t v9 = top - v8;
      int result = bn_wexpand((uint64_t)r, top - v8);
      if (!result) {
        return result;
      }
      uint64_t v11 = v6 & 0x3F;
      uint64_t v12 = &a->d[v8];
      char d = r->d;
      if (v9 >= 2)
      {
        unint64_t v14 = ~v8 + top;
        do
        {
          unint64_t v15 = v12[((-n & 0x3FuLL) + v11) >> 6] << (-(char)n & 0x3F);
          unint64_t v16 = *v12++;
          *d++ = (v16 >> v11) | v15;
          --v14;
        }
        while (v14);
      }
      unint64_t *d = *v12 >> v11;
      r->unint64_t top = v9;
      bn_correct_top((uint64_t *)r);
      BN_set_negative(r, a->neg);
    }
    return 1;
  }
}

uint64_t timingsafe_memcmp(unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  int v3 = 0;
  LODWORD(v4) = 0;
  do
  {
    int v6 = *a1++;
    int v5 = v6;
    int v7 = *a2++;
    int v8 = v5 - v7;
    int v9 = v7 - v5;
    uint64_t v4 = ((v8 >> 8) - (v9 >> 8)) & ~v3 | v4;
    v3 |= (v9 >> 8) | (v8 >> 8);
    --a3;
  }
  while (a3);
  return v4;
}

uint64_t whirlpool_block(uint64_t *a1, void *a2, uint64_t a3)
{
  unint64_t v3 = *a1;
  unint64_t v4 = a1[1];
  uint64_t v5 = a1[2];
  uint64_t v6 = a1[3];
  unint64_t v7 = a1[4];
  unint64_t v8 = a1[5];
  unint64_t v10 = a1[6];
  unint64_t v9 = a1[7];
  do
  {
    int v47 = a2;
    uint64_t v48 = a3;
    uint64_t v11 = 0;
    unint64_t v12 = *a2 ^ v3;
    uint64_t v13 = a2[1] ^ v4;
    unint64_t v14 = a2[2] ^ v5;
    uint64_t v15 = a2[3] ^ v6;
    uint64_t result = a2[4] ^ v7;
    uint64_t v17 = a2[5] ^ v8;
    unint64_t v18 = a2[6] ^ v10;
    unint64_t v19 = a2[7] ^ v9;
    unint64_t v40 = v9;
    unint64_t v41 = v10;
    unint64_t v42 = v8;
    unint64_t v43 = v7;
    uint64_t v44 = v6;
    uint64_t v45 = v5;
    unint64_t v20 = v6;
    unint64_t v21 = v5;
    unint64_t v46 = v4;
    unint64_t v39 = v12;
    do
    {
      unint64_t v49 = v13;
      unint64_t v54 = v17;
      unint64_t v55 = result;
      unint64_t v56 = v15;
      uint64_t v57 = v11;
      uint64_t v22 = Cx[2 * v4] ^ *(void *)((char *)Cx + ((v3 >> 4) & 0xFF0) + 7);
      uint64_t v23 = *(void *)((char *)Cx + ((v4 >> 4) & 0xFF0) + 7) ^ *(void *)((char *)Cx + ((v3 >> 12) & 0xFF0) + 6);
      uint64_t v24 = *(void *)((char *)&Cx[512] + v11) ^ Cx[2 * v3] ^ *(void *)((char *)Cx
                                                                                          + ((v4 >> 52) & 0xFF0)
                                                                                          + 1) ^ *(void *)((char *)Cx + ((v21 >> 44) & 0xFF0) + 2);
      uint64_t v25 = *(void *)((char *)Cx + ((v4 >> 20) & 0xFF0) + 5) ^ *(void *)((char *)Cx + ((v3 >> 28) & 0xFF0) + 4) ^ *(void *)((char *)Cx + ((v21 >> 12) & 0xFF0) + 6) ^ *(void *)((char *)Cx + ((v20 >> 4) & 0xFF0) + 7);
      uint64_t v26 = *(void *)((char *)Cx + ((v4 >> 28) & 0xFF0) + 4) ^ *(void *)((char *)Cx + ((v3 >> 36) & 0xFF0) + 3) ^ *(void *)((char *)Cx + ((v21 >> 20) & 0xFF0) + 5) ^ *(void *)((char *)Cx + ((v20 >> 12) & 0xFF0) + 6);
      uint64_t v27 = *(void *)((char *)Cx + ((v4 >> 36) & 0xFF0) + 3) ^ *(void *)((char *)Cx + ((v3 >> 44) & 0xFF0) + 2) ^ *(void *)((char *)Cx + ((v21 >> 28) & 0xFF0) + 4) ^ *(void *)((char *)Cx + ((v20 >> 20) & 0xFF0) + 5);
      uint64_t v28 = *(void *)((char *)Cx + ((v4 >> 12) & 0xFF0) + 6) ^ *(void *)((char *)Cx + ((v3 >> 20) & 0xFF0) + 5) ^ *(void *)((char *)Cx + ((v21 >> 4) & 0xFF0) + 7) ^ Cx[2 * v20] ^ *(void *)((char *)Cx + ((v7 >> 52) & 0xFF0) + 1) ^ *(void *)((char *)Cx + ((v8 >> 44) & 0xFF0) + 2) ^ *(void *)((char *)Cx + ((v10 >> 36) & 0xFF0) + 3);
      unint64_t v53 = *(void *)((char *)Cx + ((v4 >> 44) & 0xFF0) + 2) ^ *(void *)((char *)Cx + ((v3 >> 52) & 0xFF0) + 1) ^ *(void *)((char *)Cx + ((v21 >> 36) & 0xFF0) + 3) ^ *(void *)((char *)Cx + ((v20 >> 28) & 0xFF0) + 4) ^ *(void *)((char *)Cx + ((v7 >> 20) & 0xFF0) + 5) ^ *(void *)((char *)Cx + ((v8 >> 12) & 0xFF0) + 6) ^ *(void *)((char *)Cx + ((v10 >> 4) & 0xFF0) + 7) ^ Cx[2 * v9];
      unint64_t v3 = v24 ^ *(void *)((char *)Cx + ((v20 >> 36) & 0xFF0) + 3) ^ *(void *)((char *)Cx + ((v7 >> 28) & 0xFF0) + 4) ^ *(void *)((char *)Cx + ((v8 >> 20) & 0xFF0) + 5) ^ *(void *)((char *)Cx + ((v10 >> 12) & 0xFF0) + 6) ^ *(void *)((char *)Cx + ((v9 >> 4) & 0xFF0) + 7);
      unint64_t v4 = v22 ^ *(void *)((char *)Cx + ((v21 >> 52) & 0xFF0) + 1) ^ *(void *)((char *)Cx + ((v20 >> 44) & 0xFF0)
                                                                                              + 2) ^ *(void *)((char *)Cx + ((v7 >> 36) & 0xFF0) + 3) ^ *(void *)((char *)Cx + ((v8 >> 28) & 0xFF0) + 4) ^ *(void *)((char *)Cx + ((v10 >> 20) & 0xFF0) + 5) ^ *(void *)((char *)Cx + ((v9 >> 12) & 0xFF0) + 6);
      unint64_t v21 = v23 ^ Cx[2 * v21] ^ *(void *)((char *)Cx + ((v20 >> 52) & 0xFF0) + 1) ^ *(void *)((char *)Cx + ((v7 >> 44) & 0xFF0) + 2) ^ *(void *)((char *)Cx + ((v8 >> 36) & 0xFF0) + 3) ^ *(void *)((char *)Cx + ((v10 >> 28) & 0xFF0) + 4) ^ *(void *)((char *)Cx + ((v9 >> 20) & 0xFF0) + 5);
      unint64_t v20 = v28 ^ *(void *)((char *)Cx + ((v9 >> 28) & 0xFF0) + 4);
      uint64_t v52 = v25 ^ Cx[2 * v7] ^ *(void *)((char *)Cx + ((v8 >> 52) & 0xFF0) + 1) ^ *(void *)((char *)Cx + ((v10 >> 44) & 0xFF0) + 2) ^ *(void *)((char *)Cx + ((v9 >> 36) & 0xFF0) + 3);
      uint64_t v51 = v26 ^ *(void *)((char *)Cx + ((v7 >> 4) & 0xFF0) + 7) ^ Cx[2 * v8] ^ *(void *)((char *)Cx + ((v10 >> 52) & 0xFF0) + 1) ^ *(void *)((char *)Cx + ((v9 >> 44) & 0xFF0) + 2);
      uint64_t v50 = v27 ^ *(void *)((char *)Cx + ((v7 >> 12) & 0xFF0) + 6) ^ *(void *)((char *)Cx + ((v8 >> 4) & 0xFF0) + 7) ^ Cx[2 * v10] ^ *(void *)((char *)Cx + ((v9 >> 52) & 0xFF0) + 1);
      uint64_t v29 = *(void *)((char *)Cx + ((v12 >> 52) & 0xFF0) + 1) ^ *(void *)((char *)Cx + ((v49 >> 44) & 0xFF0) + 2) ^ *(void *)((char *)Cx + ((v14 >> 36) & 0xFF0) + 3) ^ *(void *)((char *)Cx + ((v56 >> 28) & 0xFF0) + 4) ^ *(void *)((char *)Cx + ((v55 >> 20) & 0xFF0) + 5) ^ *(void *)((char *)Cx + ((v54 >> 12) & 0xFF0) + 6) ^ *(void *)((char *)Cx + ((v18 >> 4) & 0xFF0) + 7) ^ Cx[2 * v19];
      uint64_t v30 = Cx[2 * v12] ^ *(void *)((char *)Cx + ((v49 >> 52) & 0xFF0) + 1) ^ *(void *)((char *)Cx + ((v14 >> 44) & 0xFF0) + 2) ^ *(void *)((char *)Cx + ((v56 >> 36) & 0xFF0) + 3) ^ *(void *)((char *)Cx + ((v55 >> 28) & 0xFF0) + 4) ^ *(void *)((char *)Cx + ((v54 >> 20) & 0xFF0) + 5) ^ *(void *)((char *)Cx + ((v18 >> 12) & 0xFF0) + 6);
      uint64_t v31 = *(void *)((char *)Cx + ((v12 >> 4) & 0xFF0) + 7) ^ Cx[2 * v49] ^ *(void *)((char *)Cx + ((v14 >> 52) & 0xFF0) + 1) ^ *(void *)((char *)Cx + ((v56 >> 44) & 0xFF0) + 2) ^ *(void *)((char *)Cx + ((v55 >> 36) & 0xFF0) + 3) ^ *(void *)((char *)Cx + ((v54 >> 28) & 0xFF0) + 4) ^ *(void *)((char *)Cx + ((v18 >> 20) & 0xFF0) + 5) ^ *(void *)((char *)Cx + ((v19 >> 12) & 0xFF0) + 6);
      uint64_t v32 = *(void *)((char *)Cx + ((v12 >> 12) & 0xFF0) + 6) ^ *(void *)((char *)Cx + ((v49 >> 4) & 0xFF0) + 7) ^ Cx[2 * v14] ^ *(void *)((char *)Cx + ((v56 >> 52) & 0xFF0) + 1) ^ *(void *)((char *)Cx + ((v55 >> 44) & 0xFF0) + 2) ^ *(void *)((char *)Cx + ((v54 >> 36) & 0xFF0) + 3) ^ *(void *)((char *)Cx + ((v18 >> 28) & 0xFF0) + 4) ^ *(void *)((char *)Cx + ((v19 >> 20) & 0xFF0) + 5);
      uint64_t v33 = *(void *)((char *)Cx + ((v12 >> 20) & 0xFF0) + 5) ^ *(void *)((char *)Cx + ((v49 >> 12) & 0xFF0) + 6) ^ *(void *)((char *)Cx + ((v14 >> 4) & 0xFF0) + 7) ^ Cx[2 * v56] ^ *(void *)((char *)Cx + ((v55 >> 52) & 0xFF0) + 1) ^ *(void *)((char *)Cx + ((v54 >> 44) & 0xFF0) + 2) ^ *(void *)((char *)Cx + ((v18 >> 36) & 0xFF0) + 3) ^ *(void *)((char *)Cx + ((v19 >> 28) & 0xFF0) + 4);
      uint64_t v34 = *(void *)((char *)Cx + ((v12 >> 28) & 0xFF0) + 4) ^ *(void *)((char *)Cx + ((v49 >> 20) & 0xFF0) + 5) ^ *(void *)((char *)Cx + ((v14 >> 12) & 0xFF0) + 6) ^ *(void *)((char *)Cx + ((v56 >> 4) & 0xFF0) + 7) ^ Cx[2 * v55] ^ *(void *)((char *)Cx + ((v54 >> 52) & 0xFF0) + 1) ^ *(void *)((char *)Cx + ((v18 >> 44) & 0xFF0) + 2) ^ *(void *)((char *)Cx + ((v19 >> 36) & 0xFF0) + 3);
      uint64_t v35 = *(void *)((char *)Cx + ((v12 >> 36) & 0xFF0) + 3) ^ *(void *)((char *)Cx + ((v49 >> 28) & 0xFF0) + 4) ^ *(void *)((char *)Cx + ((v14 >> 20) & 0xFF0) + 5) ^ *(void *)((char *)Cx + ((v56 >> 12) & 0xFF0) + 6) ^ *(void *)((char *)Cx + ((v55 >> 4) & 0xFF0) + 7) ^ Cx[2 * v54] ^ *(void *)((char *)Cx + ((v18 >> 52) & 0xFF0) + 1) ^ *(void *)((char *)Cx + ((v19 >> 44) & 0xFF0) + 2);
      unint64_t v10 = v50;
      unint64_t v8 = v51;
      uint64_t v36 = *(void *)((char *)Cx + ((v12 >> 44) & 0xFF0) + 2) ^ *(void *)((char *)Cx + ((v49 >> 36) & 0xFF0) + 3) ^ *(void *)((char *)Cx + ((v14 >> 28) & 0xFF0) + 4) ^ *(void *)((char *)Cx + ((v56 >> 20) & 0xFF0) + 5) ^ *(void *)((char *)Cx + ((v55 >> 12) & 0xFF0) + 6) ^ *(void *)((char *)Cx + ((v54 >> 4) & 0xFF0) + 7) ^ Cx[2 * v18];
      uint64_t v37 = v29 ^ v53;
      unint64_t v12 = v30 ^ *(void *)((char *)Cx + ((v19 >> 4) & 0xFF0) + 7) ^ v3;
      uint64_t v13 = v31 ^ v4;
      unint64_t v14 = v32 ^ v21;
      uint64_t v15 = v33 ^ v20;
      unint64_t v7 = v52;
      uint64_t result = v34 ^ v52;
      uint64_t v17 = v35 ^ v51;
      unint64_t v18 = v36 ^ *(void *)((char *)Cx + ((v19 >> 52) & 0xFF0) + 1) ^ v50;
      uint64_t v11 = v57 + 8;
      unint64_t v9 = v53;
      unint64_t v19 = v37;
    }
    while (v57 != 72);
    unint64_t v3 = v12 ^ v39;
    *a1 = v12 ^ v39;
    unint64_t v4 = v46 ^ v47[1] ^ v13;
    a1[1] = v4;
    uint64_t v5 = v45 ^ v47[2] ^ v14;
    a1[2] = v5;
    uint64_t v6 = v44 ^ v47[3] ^ v15;
    a1[3] = v6;
    unint64_t v7 = v43 ^ v47[4] ^ result;
    a1[4] = v7;
    unint64_t v8 = v42 ^ v47[5] ^ v17;
    a1[5] = v8;
    unint64_t v10 = v41 ^ v47[6] ^ v18;
    a1[6] = v10;
    unint64_t v9 = v40 ^ v47[7] ^ v37;
    a1[7] = v9;
    a2 = v47 + 8;
    a3 = v48 - 1;
  }
  while (v48 != 1);
  return result;
}

void RC2_cfb64_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, RC2_KEY *schedule, unsigned __int8 *ivec, int *num, int enc)
{
  uint64_t v10 = length;
  uint64_t v23 = *MEMORY[0x263EF8340];
  int v13 = *num;
  if (enc)
  {
    if (length)
    {
      do
      {
        if (!v13)
        {
          *(void *)&long long v14 = *(void *)ivec;
          *((void *)&v14 + 1) = HIDWORD(*(void *)ivec);
          *(_OWORD *)uint64_t v22 = v14;
          RC2_encrypt(v22, schedule);
          long long v15 = *(_OWORD *)v22;
          *(_DWORD *)ivec = v22[0];
          *((_DWORD *)ivec + 1) = DWORD2(v15);
        }
        char v16 = *in++;
        unsigned __int8 v17 = ivec[v13];
        *out++ = v17 ^ v16;
        ivec[v13] = v17 ^ v16;
        int v13 = (v13 + 1) & 7;
        --v10;
      }
      while (v10);
    }
  }
  else if (length)
  {
    do
    {
      if (!v13)
      {
        *(void *)&long long v18 = *(void *)ivec;
        *((void *)&v18 + 1) = HIDWORD(*(void *)ivec);
        *(_OWORD *)uint64_t v22 = v18;
        RC2_encrypt(v22, schedule);
        long long v19 = *(_OWORD *)v22;
        *(_DWORD *)ivec = v22[0];
        *((_DWORD *)ivec + 1) = DWORD2(v19);
      }
      unsigned __int8 v20 = *in++;
      unsigned __int8 v21 = ivec[v13];
      ivec[v13] = v20;
      *out++ = v21 ^ v20;
      int v13 = (v13 + 1) & 7;
      --v10;
    }
    while (v10);
  }
  *num = v13;
}

unint64_t CRYPTO_gcm128_init(uint64_t a1, uint64_t a2, void (*a3)(unsigned int *, unsigned int *, uint64_t))
{
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + EVP_MD_CTX_set_flags(ctx, 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  unint64_t v4 = (unsigned int *)(a1 + 80);
  *(void *)(a1 + 376) = a3;
  *(void *)(a1 + 384) = 0;
  *(void *)(a1 + 384) = a2;
  a3(v4, v4, a2);
  uint64_t v5 = *(unsigned __int8 *)(a1 + 87);
  unint64_t v6 = ((unint64_t)*(unsigned __int8 *)(a1 + 84) << 24) | ((unint64_t)*(unsigned __int8 *)(a1 + 85) << 16) | ((unint64_t)bswap32(*v4) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + 86) << 8) | v5;
  uint64_t v7 = bswap32(*(_DWORD *)(a1 + 88));
  uint64_t v8 = *(unsigned __int8 *)(a1 + 94);
  uint64_t v9 = *(unsigned __int8 *)(a1 + 95);
  unint64_t v10 = ((unint64_t)*(unsigned __int8 *)(a1 + 92) << 24) | ((unint64_t)*(unsigned __int8 *)(a1 + 93) << 16);
  *(void *)unint64_t v4 = v6;
  unint64_t v11 = v10 | (v7 << 32) | (v8 << 8) | v9;
  *(void *)(a1 + 88) = v11;
  *(void *)(a1 + 96) = 0;
  *((void *)&v13 + 1) = v5;
  *(void *)&long long v13 = v11;
  uint64_t v12 = v13 >> 1;
  unint64_t v14 = (v9 << 63 >> 63) & 0xE100000000000000 ^ (v6 >> 1);
  *((void *)&v13 + 1) = v6 >> 1;
  *(void *)&long long v13 = v12;
  uint64_t v15 = v13 >> 1;
  unint64_t v16 = (v12 << 63 >> 63) & 0xE100000000000000 ^ (v14 >> 1);
  unint64_t v17 = (v15 << 63 >> 63) & 0xE100000000000000 ^ (v16 >> 1);
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = v17;
  *((void *)&v13 + 1) = v14 >> 1;
  *(void *)&long long v13 = v15;
  uint64_t v18 = v13 >> 1;
  *(void *)(a1 + 120) = v18;
  *(void *)(a1 + 128) = v16;
  *(void *)(a1 + 136) = v15;
  *(void *)(a1 + 144) = v17 ^ v16;
  *(void *)(a1 + 152) = v18 ^ v15;
  *(void *)(a1 + 160) = v14;
  unint64_t result = v17 ^ v14;
  *(void *)(a1 + 168) = v12;
  *(void *)(a1 + 176) = v17 ^ v14;
  *(void *)(a1 + 184) = v18 ^ v12;
  *(void *)(a1 + 192) = v16 ^ v14;
  unint64_t v20 = v17 ^ v16 ^ v14;
  *(void *)(a1 + 200) = v15 ^ v12;
  *(void *)(a1 + 208) = v20;
  uint64_t v21 = v18 ^ v15 ^ v12;
  *(void *)(a1 + 216) = v21;
  *(void *)(a1 + 224) = v6;
  *(void *)(a1 + 232) = v11;
  *(void *)(a1 + 240) = v17 ^ v6;
  *(void *)(a1 + 248) = v18 ^ v11;
  *(void *)(a1 + EVP_MD_CTX_set_flags(ctx, 256) = v16 ^ v6;
  *(void *)(a1 + 264) = v15 ^ v11;
  *(void *)(a1 + 272) = v17 ^ v16 ^ v6;
  *(void *)(a1 + 280) = v18 ^ v15 ^ v11;
  *(void *)(a1 + 288) = v14 ^ v6;
  *(void *)(a1 + 296) = v12 ^ v11;
  *(void *)(a1 + 304) = v17 ^ v14 ^ v6;
  *(void *)(a1 + 312) = v18 ^ v12 ^ v11;
  *(void *)(a1 + 320) = v16 ^ v14 ^ v6;
  *(void *)(a1 + 328) = v15 ^ v12 ^ v11;
  *(void *)(a1 + 336) = v20 ^ v6;
  *(void *)(a1 + 344) = v21 ^ v11;
  return result;
}

uint64_t CRYPTO_gcm128_setiv(uint64_t a1, uint64_t *a2, unint64_t a3)
{
  unint64_t v3 = a2;
  *(void *)(a1 + 368) = 0;
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  if (a3 != 12)
  {
    if (a3 < 0x10)
    {
      unint64_t i = a3;
      if (!a3)
      {
LABEL_14:
        int16x8_t v11 = (int16x8_t)vdupq_n_s64(8 * a3);
        int16x8_t v12 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64((uint64x2_t)v11, (uint64x2_t)xmmword_23C701670), (int32x4_t)vshlq_u64((uint64x2_t)v11, (uint64x2_t)xmmword_23C701660));
        *(int32x2_t *)v11.i8 = vmovn_s64((int64x2_t)vshlq_u64((uint64x2_t)v11, (uint64x2_t)xmmword_23C701680));
        LODWORD(v13) = a3 >> 5;
        HIDWORD(v13) = 8 * a3;
        v11.i64[1] = v13;
        *(int8x8_t *)(a1 + 8) = veor_s8(*(int8x8_t *)(a1 + 8), vmovn_s16(vuzp1q_s16(v12, v11)));
        gcm_gmult_4bit((unsigned char *)a1, a1 + 96);
        unsigned int v6 = bswap32(*(_DWORD *)(a1 + 12)) + 1;
        goto LABEL_15;
      }
    }
    else
    {
      for (unint64_t i = a3; i > 0xF; i -= 16)
      {
        for (uint64_t j = 0; j != 16; ++j)
          *(unsigned char *)(a1 + j) ^= *((unsigned char *)v3 + j);
        gcm_gmult_4bit((unsigned char *)a1, a1 + 96);
        v3 += 2;
      }
      if (!i) {
        goto LABEL_14;
      }
    }
    uint64_t v10 = 0;
    do
    {
      *(unsigned char *)(a1 + v10) ^= *((unsigned char *)v3 + v10);
      ++v10;
    }
    while (i != v10);
    gcm_gmult_4bit((unsigned char *)a1, a1 + 96);
    goto LABEL_14;
  }
  uint64_t v5 = *a2;
  *(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2);
  *(void *)a1 = v5;
  *(unsigned char *)(a1 + 15) = 1;
  unsigned int v6 = 2;
LABEL_15:
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void))(a1 + 376))(a1, a1 + 32, *(void *)(a1 + 384));
  *(_DWORD *)(a1 + 12) = bswap32(v6);
  return result;
}

unsigned char *gcm_gmult_4bit(unsigned char *result, uint64_t a2)
{
  unsigned __int8 v2 = result[15];
  unint64_t v3 = (void *)(a2 + 16 * (v2 & 0xF));
  *((void *)&v4 + 1) = *v3;
  *(void *)&long long v4 = v3[1];
  uint64_t v5 = (void *)(a2 + (v2 & 0xF0));
  unint64_t v6 = rem_4bit[v4 & 0xF] ^ (*v3 >> 4) ^ *v5;
  uint64_t v7 = v5[1] ^ (v4 >> 4);
  for (unint64_t i = 14; i < 0xFFFFFFFFFFFFFFFELL; --i)
  {
    unsigned __int8 v9 = result[i];
    uint64_t v10 = v7 & 0xF;
    *((void *)&v11 + 1) = v6;
    *(void *)&long long v11 = v7;
    int16x8_t v12 = (void *)(a2 + 16 * (v9 & 0xF));
    uint64_t v13 = v12[1] ^ (v11 >> 4);
    *((void *)&v11 + 1) = rem_4bit[v10] ^ (v6 >> 4) ^ *v12;
    *(void *)&long long v11 = v13;
    unint64_t v14 = (void *)(a2 + (v9 & 0xF0));
    uint64_t v15 = v14[1];
    unint64_t v6 = rem_4bit[v13 & 0xF] ^ (*((void *)&v11 + 1) >> 4) ^ *v14;
    uint64_t v7 = v15 ^ (v11 >> 4);
  }
  *uint64_t result = HIBYTE(v6);
  result[1] = BYTE6(v6);
  result[2] = BYTE5(v6);
  result[3] = BYTE4(v6);
  result[4] = BYTE3(v6);
  result[5] = BYTE2(v6);
  result[6] = BYTE1(v6);
  result[7] = v6;
  result[8] = HIBYTE(v7);
  result[9] = BYTE6(v7);
  result[10] = BYTE5(v7);
  result[11] = BYTE4(v7);
  result[12] = BYTE3(v7);
  result[13] = BYTE2(v7);
  result[14] = BYTE1(v7);
  result[15] = v7;
  return result;
}

uint64_t CRYPTO_gcm128_aad(uint64_t a1, char *a2, uint64_t a3)
{
  if (*(void *)(a1 + 56)) {
    return 4294967294;
  }
  uint64_t v5 = *(void *)(a1 + 48);
  BOOL v6 = __CFADD__(v5, a3);
  unint64_t v7 = v5 + a3;
  char v8 = v6;
  uint64_t result = 0xFFFFFFFFLL;
  if (v7 <= 0x2000000000000000 && (v8 & 1) == 0)
  {
    *(void *)(a1 + 48) = v7;
    unsigned int v10 = *(_DWORD *)(a1 + 372);
    if (v10)
    {
      if (!a3) {
        goto LABEL_23;
      }
      long long v11 = (unsigned char *)(a1 + 64);
      do
      {
        char v12 = *a2++;
        v11[v10] ^= v12;
        uint64_t v13 = a3 - 1;
        unsigned int v10 = ((_BYTE)v10 + 1) & 0xF;
        if (!v10) {
          break;
        }
        --a3;
      }
      while (a3);
      if (v10)
      {
LABEL_23:
        uint64_t result = 0;
        *(_DWORD *)(a1 + 372) = v10;
        return result;
      }
      gcm_gmult_4bit(v11, a1 + 96);
    }
    else
    {
      uint64_t v13 = a3;
    }
    if ((v13 & 0xFFFFFFFFFFFFFFF0) != 0)
    {
      gcm_ghash_4bit((unsigned char *)(a1 + 64), a1 + 96, (uint64_t)a2, v13 & 0xFFFFFFFFFFFFFFF0);
      a2 += v13 & 0xFFFFFFFFFFFFFFF0;
      v13 &= 0xFu;
    }
    if (v13)
    {
      unint64_t v14 = (unsigned char *)(a1 + 64);
      uint64_t v15 = v13;
      do
      {
        char v16 = *a2++;
        *v14++ ^= v16;
        --v15;
      }
      while (v15);
      unsigned int v10 = v13;
    }
    else
    {
      unsigned int v10 = 0;
    }
    goto LABEL_23;
  }
  return result;
}

unsigned char *gcm_ghash_4bit(unsigned char *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  LOBYTE(v4) = result[15];
  do
  {
    unsigned __int8 v5 = *(unsigned char *)(a3 + 15) ^ v4;
    BOOL v6 = (void *)(a2 + 16 * (v5 & 0xF));
    *((void *)&v7 + 1) = *v6;
    *(void *)&long long v7 = v6[1];
    char v8 = (void *)(a2 + (v5 & 0xF0));
    unint64_t v9 = rem_4bit[v7 & 0xF] ^ (*v6 >> 4) ^ *v8;
    uint64_t v4 = v8[1] ^ (v7 >> 4);
    for (unint64_t i = 14; i < 0xFFFFFFFFFFFFFFFELL; --i)
    {
      unsigned __int8 v11 = *(unsigned char *)(a3 + i) ^ result[i];
      uint64_t v12 = v4 & 0xF;
      *((void *)&v13 + 1) = v9;
      *(void *)&long long v13 = v4;
      unint64_t v14 = (void *)(a2 + 16 * (v11 & 0xF));
      uint64_t v15 = v14[1] ^ (v13 >> 4);
      *((void *)&v13 + 1) = rem_4bit[v12] ^ (v9 >> 4) ^ *v14;
      *(void *)&long long v13 = v15;
      char v16 = (void *)(a2 + (v11 & 0xF0));
      uint64_t v17 = v16[1];
      unint64_t v9 = rem_4bit[v15 & 0xF] ^ (*((void *)&v13 + 1) >> 4) ^ *v16;
      uint64_t v4 = v17 ^ (v13 >> 4);
    }
    *uint64_t result = HIBYTE(v9);
    result[1] = BYTE6(v9);
    result[2] = BYTE5(v9);
    result[3] = BYTE4(v9);
    result[4] = BYTE3(v9);
    result[5] = BYTE2(v9);
    result[6] = BYTE1(v9);
    result[7] = v9;
    result[8] = HIBYTE(v4);
    result[9] = BYTE6(v4);
    result[10] = BYTE5(v4);
    result[11] = BYTE4(v4);
    result[12] = BYTE3(v4);
    result[13] = BYTE2(v4);
    result[14] = BYTE1(v4);
    a3 += 16;
    result[15] = v4;
    a4 -= 16;
  }
  while (a4);
  return result;
}

uint64_t CRYPTO_gcm128_encrypt(uint64_t a1, char *a2, void *a3, unint64_t a4)
{
  uint64_t v5 = *(void *)(a1 + 56);
  BOOL v6 = __CFADD__(v5, a4);
  unint64_t v7 = v5 + a4;
  char v8 = v6;
  uint64_t result = 0xFFFFFFFFLL;
  if (v7 <= 0xFFFFFFFE0 && (v8 & 1) == 0)
  {
    unint64_t v10 = a4;
    unint64_t v14 = *(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 376);
    uint64_t v13 = *(void *)(a1 + 384);
    *(void *)(a1 + 56) = v7;
    if (*(_DWORD *)(a1 + 372))
    {
      gcm_gmult_4bit((unsigned char *)(a1 + 64), a1 + 96);
      *(_DWORD *)(a1 + 372) = 0;
    }
    unsigned int v15 = *(_DWORD *)(a1 + 12);
    LODWORD(v16) = *(_DWORD *)(a1 + 368);
    if (v16)
    {
      if (!v10) {
        goto LABEL_28;
      }
      uint64_t v17 = (unsigned char *)(a1 + 64);
      do
      {
        char v18 = *a2++;
        char v19 = *(unsigned char *)(a1 + 16 + v16) ^ v18;
        *(unsigned char *)a3 = v19;
        a3 = (void *)((char *)a3 + 1);
        v17[v16] ^= v19;
        unint64_t v20 = v10 - 1;
        LODWORD(v16) = ((_BYTE)v16 + 1) & 0xF;
        if (!v16) {
          break;
        }
        --v10;
      }
      while (v10);
      if (v16)
      {
LABEL_28:
        uint64_t result = 0;
        *(_DWORD *)(a1 + 368) = v16;
        return result;
      }
      gcm_gmult_4bit(v17, a1 + 96);
    }
    else
    {
      unint64_t v20 = v10;
    }
    unsigned int v21 = bswap32(v15);
    if (v20 >= 0xC00)
    {
      do
      {
        unint64_t v26 = v20;
        uint64_t v22 = -3072;
        do
        {
          uint64_t v23 = &a3[(unint64_t)v22 / 8];
          v14(a1, a1 + 16, v13);
          *(_DWORD *)(a1 + 12) = bswap32(++v21);
          v23[384] = *(void *)(a1 + 16) ^ *(void *)&a2[v22 + 3072];
          v23[385] = *(void *)(a1 + 24) ^ *(void *)&a2[v22 + 3080];
          v22 += 16;
        }
        while (v22);
        gcm_ghash_4bit((unsigned char *)(a1 + 64), a1 + 96, (uint64_t)a3, 3072);
        unint64_t v20 = v26 - 3072;
        a3 += 384;
        a2 += 3072;
      }
      while (v26 - 3072 > 0xBFF);
    }
    uint64_t v24 = v20 & 0xFF0;
    if ((v20 & 0xFF0) != 0)
    {
      do
      {
        v14(a1, a1 + 16, v13);
        *(_DWORD *)(a1 + 12) = bswap32(++v21);
        *a3 = *(void *)(a1 + 16) ^ *(void *)a2;
        a3[1] = *(void *)(a1 + 24) ^ *((void *)a2 + 1);
        a3 += 2;
        a2 += 16;
        v20 -= 16;
      }
      while (v20 > 0xF);
      gcm_ghash_4bit((unsigned char *)(a1 + 64), a1 + 96, (uint64_t)a3 - v24, v24);
    }
    if (v20)
    {
      v14(a1, a1 + 16, v13);
      uint64_t v16 = 0;
      *(_DWORD *)(a1 + 12) = bswap32(v21 + 1);
      do
      {
        char v25 = *(unsigned char *)(a1 + 16 + v16) ^ a2[v16];
        *((unsigned char *)a3 + v16) = v25;
        *(unsigned char *)(a1 + 64 + v16++) ^= v25;
      }
      while (v20 != v16);
    }
    else
    {
      LODWORD(v16) = 0;
    }
    goto LABEL_28;
  }
  return result;
}

uint64_t CRYPTO_gcm128_decrypt(uint64_t a1, char *a2, void *a3, unint64_t a4)
{
  uint64_t v5 = *(void *)(a1 + 56);
  BOOL v6 = __CFADD__(v5, a4);
  unint64_t v7 = v5 + a4;
  char v8 = v6;
  uint64_t result = 0xFFFFFFFFLL;
  if (v7 <= 0xFFFFFFFE0 && (v8 & 1) == 0)
  {
    unint64_t v10 = a4;
    unint64_t v14 = *(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 376);
    uint64_t v13 = *(void *)(a1 + 384);
    *(void *)(a1 + 56) = v7;
    if (*(_DWORD *)(a1 + 372))
    {
      gcm_gmult_4bit((unsigned char *)(a1 + 64), a1 + 96);
      *(_DWORD *)(a1 + 372) = 0;
    }
    unsigned int v15 = *(_DWORD *)(a1 + 12);
    LODWORD(v16) = *(_DWORD *)(a1 + 368);
    if (v16)
    {
      if (!v10) {
        goto LABEL_28;
      }
      uint64_t v17 = (unsigned char *)(a1 + 64);
      do
      {
        char v18 = *a2++;
        *(unsigned char *)a3 = *(unsigned char *)(a1 + 16 + v16) ^ v18;
        a3 = (void *)((char *)a3 + 1);
        v17[v16] ^= v18;
        unint64_t v19 = v10 - 1;
        LODWORD(v16) = ((_BYTE)v16 + 1) & 0xF;
        if (!v16) {
          break;
        }
        --v10;
      }
      while (v10);
      if (v16)
      {
LABEL_28:
        uint64_t result = 0;
        *(_DWORD *)(a1 + 368) = v16;
        return result;
      }
      gcm_gmult_4bit(v17, a1 + 96);
    }
    else
    {
      unint64_t v19 = v10;
    }
    unsigned int v20 = bswap32(v15);
    if (v19 >= 0xC00)
    {
      do
      {
        unint64_t v25 = v19;
        gcm_ghash_4bit((unsigned char *)(a1 + 64), a1 + 96, (uint64_t)a2, 3072);
        for (uint64_t i = 0; i != 384; i += 2)
        {
          uint64_t v22 = &a3[i];
          v14(a1, a1 + 16, v13);
          *(_DWORD *)(a1 + 12) = bswap32(++v20);
          void *v22 = *(void *)(a1 + 16) ^ *(void *)&a2[i * 8];
          v22[1] = *(void *)(a1 + 24) ^ *(void *)&a2[i * 8 + 8];
        }
        unint64_t v19 = v25 - 3072;
        a2 += 3072;
        a3 += 384;
      }
      while (v25 - 3072 > 0xBFF);
    }
    uint64_t v23 = v19 & 0xFF0;
    if ((v19 & 0xFF0) != 0)
    {
      gcm_ghash_4bit((unsigned char *)(a1 + 64), a1 + 96, (uint64_t)a2, v23);
      do
      {
        v14(a1, a1 + 16, v13);
        *(_DWORD *)(a1 + 12) = bswap32(++v20);
        *a3 = *(void *)(a1 + 16) ^ *(void *)a2;
        a3[1] = *(void *)(a1 + 24) ^ *((void *)a2 + 1);
        a3 += 2;
        a2 += 16;
        v19 -= 16;
      }
      while (v19 > 0xF);
    }
    if (v19)
    {
      ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t))v14)(a1, a1 + 16, v13, v23);
      uint64_t v16 = 0;
      *(_DWORD *)(a1 + 12) = bswap32(v20 + 1);
      do
      {
        char v24 = a2[v16];
        *(unsigned char *)(a1 + 64 + v16) ^= v24;
        *((unsigned char *)a3 + v16) = *(unsigned char *)(a1 + 16 + v16) ^ v24;
        ++v16;
      }
      while (v19 != v16);
    }
    else
    {
      LODWORD(v16) = 0;
    }
    goto LABEL_28;
  }
  return result;
}

uint64_t CRYPTO_gcm128_encrypt_ctr32(uint64_t a1, char *a2, unsigned char *a3, unint64_t a4, void (*a5)(char *, unsigned char *, uint64_t, uint64_t, uint64_t))
{
  uint64_t v6 = *(void *)(a1 + 56);
  BOOL v7 = __CFADD__(v6, a4);
  unint64_t v8 = v6 + a4;
  char v9 = v7;
  uint64_t result = 0xFFFFFFFFLL;
  if (v8 <= 0xFFFFFFFE0 && (v9 & 1) == 0)
  {
    unint64_t v12 = a4;
    uint64_t v15 = *(void *)(a1 + 384);
    *(void *)(a1 + 56) = v8;
    if (*(_DWORD *)(a1 + 372))
    {
      gcm_gmult_4bit((unsigned char *)(a1 + 64), a1 + 96);
      *(_DWORD *)(a1 + 372) = 0;
    }
    unsigned int v16 = *(_DWORD *)(a1 + 12);
    LODWORD(v17) = *(_DWORD *)(a1 + 368);
    if (v17)
    {
      if (!v12) {
        goto LABEL_25;
      }
      char v18 = (unsigned char *)(a1 + 64);
      do
      {
        char v19 = *a2++;
        char v20 = *(unsigned char *)(a1 + 16 + v17) ^ v19;
        *a3++ = v20;
        v18[v17] ^= v20;
        unint64_t v21 = v12 - 1;
        LODWORD(v17) = ((_BYTE)v17 + 1) & 0xF;
        if (!v17) {
          break;
        }
        --v12;
      }
      while (v12);
      if (v17)
      {
LABEL_25:
        uint64_t result = 0;
        *(_DWORD *)(a1 + 368) = v17;
        return result;
      }
      gcm_gmult_4bit(v18, a1 + 96);
    }
    else
    {
      unint64_t v21 = v12;
    }
    unsigned int v22 = bswap32(v16);
    if (v21 >= 0xC00)
    {
      do
      {
        a5(a2, a3, 192, v15, a1);
        v22 += 192;
        *(_DWORD *)(a1 + 12) = bswap32(v22);
        gcm_ghash_4bit((unsigned char *)(a1 + 64), a1 + 96, (uint64_t)a3, 3072);
        a3 += 3072;
        a2 += 3072;
        v21 -= 3072;
      }
      while (v21 > 0xBFF);
    }
    uint64_t v23 = v21 & 0xFF0;
    if ((v21 & 0xFF0) != 0)
    {
      a5(a2, a3, v21 >> 4, v15, a1);
      v22 += v21 >> 4;
      *(_DWORD *)(a1 + 12) = bswap32(v22);
      a2 += v23;
      v21 &= 0xFu;
      gcm_ghash_4bit((unsigned char *)(a1 + 64), a1 + 96, (uint64_t)a3, v23);
      a3 += v23;
    }
    if (v21)
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 376))(a1, a1 + 16, v15);
      uint64_t v17 = 0;
      *(_DWORD *)(a1 + 12) = bswap32(v22 + 1);
      do
      {
        char v24 = *(unsigned char *)(a1 + 16 + v17) ^ a2[v17];
        a3[v17] = v24;
        *(unsigned char *)(a1 + 64 + v17++) ^= v24;
      }
      while (v21 != v17);
    }
    else
    {
      LODWORD(v17) = 0;
    }
    goto LABEL_25;
  }
  return result;
}

uint64_t CRYPTO_gcm128_decrypt_ctr32(uint64_t a1, char *a2, unsigned char *a3, unint64_t a4, void (*a5)(char *, unsigned char *, uint64_t, uint64_t, uint64_t))
{
  uint64_t v6 = *(void *)(a1 + 56);
  BOOL v7 = __CFADD__(v6, a4);
  unint64_t v8 = v6 + a4;
  char v9 = v7;
  uint64_t result = 0xFFFFFFFFLL;
  if (v8 <= 0xFFFFFFFE0 && (v9 & 1) == 0)
  {
    unint64_t v12 = a4;
    uint64_t v15 = *(void *)(a1 + 384);
    *(void *)(a1 + 56) = v8;
    if (*(_DWORD *)(a1 + 372))
    {
      gcm_gmult_4bit((unsigned char *)(a1 + 64), a1 + 96);
      *(_DWORD *)(a1 + 372) = 0;
    }
    unsigned int v16 = *(_DWORD *)(a1 + 12);
    LODWORD(v17) = *(_DWORD *)(a1 + 368);
    if (v17)
    {
      if (!v12) {
        goto LABEL_25;
      }
      char v18 = (unsigned char *)(a1 + 64);
      do
      {
        char v19 = *a2++;
        *a3++ = *(unsigned char *)(a1 + 16 + v17) ^ v19;
        v18[v17] ^= v19;
        unint64_t v20 = v12 - 1;
        LODWORD(v17) = ((_BYTE)v17 + 1) & 0xF;
        if (!v17) {
          break;
        }
        --v12;
      }
      while (v12);
      if (v17)
      {
LABEL_25:
        uint64_t result = 0;
        *(_DWORD *)(a1 + 368) = v17;
        return result;
      }
      gcm_gmult_4bit(v18, a1 + 96);
    }
    else
    {
      unint64_t v20 = v12;
    }
    unsigned int v21 = bswap32(v16);
    if (v20 >= 0xC00)
    {
      do
      {
        gcm_ghash_4bit((unsigned char *)(a1 + 64), a1 + 96, (uint64_t)a2, 3072);
        a5(a2, a3, 192, v15, a1);
        v21 += 192;
        *(_DWORD *)(a1 + 12) = bswap32(v21);
        a3 += 3072;
        a2 += 3072;
        v20 -= 3072;
      }
      while (v20 > 0xBFF);
    }
    unint64_t v22 = v20 & 0xFF0;
    if ((v20 & 0xFF0) != 0)
    {
      gcm_ghash_4bit((unsigned char *)(a1 + 64), a1 + 96, (uint64_t)a2, v20 & 0xFF0);
      a5(a2, a3, v20 >> 4, v15, a1);
      v21 += v20 >> 4;
      *(_DWORD *)(a1 + 12) = bswap32(v21);
      a3 += v22;
      a2 += v22;
      v20 &= 0xFu;
    }
    if (v20)
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 376))(a1, a1 + 16, v15);
      uint64_t v17 = 0;
      *(_DWORD *)(a1 + 12) = bswap32(v21 + 1);
      do
      {
        char v23 = a2[v17];
        *(unsigned char *)(a1 + 64 + v17) ^= v23;
        a3[v17] = *(unsigned char *)(a1 + 16 + v17) ^ v23;
        ++v17;
      }
      while (v20 != v17);
    }
    else
    {
      LODWORD(v17) = 0;
    }
    goto LABEL_25;
  }
  return result;
}

uint64_t CRYPTO_gcm128_finish(uint64_t a1, const void *a2, size_t a3)
{
  int64x2_t v6 = *(int64x2_t *)(a1 + 48);
  uint64x2_t v7 = (uint64x2_t)vshlq_n_s64(v6, 3uLL);
  if (*(_DWORD *)(a1 + 368) || *(_DWORD *)(a1 + 372))
  {
    int64x2_t v13 = *(int64x2_t *)(a1 + 48);
    uint64x2_t v14 = v7;
    gcm_gmult_4bit((unsigned char *)(a1 + 64), a1 + 96);
    int64x2_t v6 = v13;
    uint64x2_t v7 = v14;
  }
  int8x16_t v9 = *(int8x16_t *)(a1 + 64);
  unint64_t v8 = (int8x16_t *)(a1 + 64);
  v8[-1] = (int8x16_t)v7;
  v10.i64[0] = 65280;
  v10.i64[1] = 65280;
  v11.i64[0] = 255;
  v11.i64[1] = 255;
  *unint64_t v8 = veorq_s8(v9, vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vandq_s8((int8x16_t)vshlq_u64(v7, (uint64x2_t)xmmword_23C7016B0), (int8x16_t)xmmword_23C701700), vandq_s8((int8x16_t)vshlq_u64(v7, (uint64x2_t)xmmword_23C7016C0), (int8x16_t)xmmword_23C7016F0)), vandq_s8((int8x16_t)vshrq_n_u64(v7, 0x28uLL), v10)), (int8x16_t)vshrq_n_u64(v7, 0x38uLL)), (int8x16_t)vshlq_n_s64((int64x2_t)vorrq_s8(vorrq_s8(vandq_s8((int8x16_t)vshlq_u64((uint64x2_t)v6, (uint64x2_t)xmmword_23C701690), (int8x16_t)xmmword_23C7016E0), vandq_s8((int8x16_t)vshlq_u64((uint64x2_t)v6, (uint64x2_t)xmmword_23C7016A0), (int8x16_t)xmmword_23C7016D0)), vorrq_s8(
                                        vandq_s8((int8x16_t)vshrq_n_u64(v7, 8uLL), v10),
                                        vandq_s8((int8x16_t)vshrq_n_u64(v7, 0x18uLL), v11))),
                         0x20uLL)));
  gcm_gmult_4bit(v8, (uint64_t)v8[2].i64);
  *unint64_t v8 = veorq_s8(*v8, v8[-2]);
  if (!a2 || a3 > 0x10) {
    return 0xFFFFFFFFLL;
  }
  return memcmp(v8, a2, a3);
}

void *CRYPTO_gcm128_tag(uint64_t a1, void *a2, unint64_t a3)
{
  CRYPTO_gcm128_finish(a1, 0, 0);
  if (a3 >= 0x10) {
    size_t v6 = 16;
  }
  else {
    size_t v6 = a3;
  }
  return memcpy(a2, (const void *)(a1 + 64), v6);
}

void *CRYPTO_gcm128_new(uint64_t a1, void (*a2)(unsigned int *, unsigned int *, uint64_t))
{
  uint64_t v4 = malloc_type_malloc(0x188uLL, 0x1080040DB0FD529uLL);
  uint64_t v5 = v4;
  if (v4) {
    CRYPTO_gcm128_init((uint64_t)v4, a1, a2);
  }
  return v5;
}

void *CRYPTO_gcm128_release(void *a1)
{
  return freezero(a1, 0x188uLL);
}

STACK *i2v_EXTENDED_KEY_USAGE(int a1, STACK *a2, STACK *a3)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  int8x16_t v9 = a3;
  if (a3)
  {
    uint64_t v4 = a3;
    uint64_t v5 = 0;
  }
  else
  {
    uint64_t v4 = sk_new_null();
    int8x16_t v9 = v4;
    uint64_t v5 = v4;
    if (!v4) {
      return v4;
    }
  }
  if (sk_num(a2) >= 1)
  {
    int v6 = 0;
    while (1)
    {
      uint64x2_t v7 = sk_value(a2, v6);
      if (!v7 || !i2t_ASN1_OBJECT(buf, 80, (ASN1_OBJECT *)v7) || !X509V3_add_value(0, buf, &v9)) {
        break;
      }
      if (++v6 >= sk_num(a2)) {
        return v9;
      }
    }
    sk_pop_free(v5, (void (__cdecl *)(void *))X509V3_conf_free);
    return 0;
  }
  return v4;
}

STACK *v2i_EXTENDED_KEY_USAGE(uint64_t a1, uint64_t a2, const STACK *a3)
{
  uint64_t v4 = sk_new_null();
  if (v4)
  {
    if (sk_num(a3) >= 1)
    {
      int v5 = 0;
      while (1)
      {
        int v6 = sk_value(a3, v5);
        uint64x2_t v7 = (const char *)*((void *)v6 + 2);
        if (!v7) {
          uint64x2_t v7 = (const char *)*((void *)v6 + 1);
        }
        unint64_t v8 = (char *)OBJ_txt2obj(v7, 0);
        if (!v8)
        {
          sk_pop_free(v4, (void (__cdecl *)(void *))ASN1_OBJECT_free);
          ERR_put_error(34, 4095, 110, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_extku.c", 209);
          ERR_asprintf_error_data("section:%s,name:%s,value:%s", *(const char **)v6, *((const char **)v6 + 1), *((const char **)v6 + 2));
          return 0;
        }
        int8x16_t v9 = (ASN1_OBJECT *)v8;
        if (!sk_push(v4, v8)) {
          break;
        }
        if (++v5 >= sk_num(a3)) {
          return v4;
        }
      }
      ASN1_OBJECT_free(v9);
      sk_pop_free(v4, (void (__cdecl *)(void *))ASN1_OBJECT_free);
      ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_extku.c", 216);
      return 0;
    }
  }
  else
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_extku.c", 197);
  }
  return v4;
}

EXTENDED_KEY_USAGE *__cdecl d2i_EXTENDED_KEY_USAGE(EXTENDED_KEY_USAGE **a, const unsigned __int8 **in, uint64_t len)
{
  return (EXTENDED_KEY_USAGE *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &EXTENDED_KEY_USAGE_it);
}

int i2d_EXTENDED_KEY_USAGE(EXTENDED_KEY_USAGE *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &EXTENDED_KEY_USAGE_it);
}

EXTENDED_KEY_USAGE *EXTENDED_KEY_USAGE_new(void)
{
  return (EXTENDED_KEY_USAGE *)ASN1_item_new(&EXTENDED_KEY_USAGE_it);
}

void EXTENDED_KEY_USAGE_free(EXTENDED_KEY_USAGE *a)
{
}

int asn1_get_choice_selector(ASN1_VALUE **pval, const ASN1_ITEM *it)
{
  return *(_DWORD *)((char *)*pval + it->utype);
}

int asn1_set_choice_selector(ASN1_VALUE **pval, int value, const ASN1_ITEM *it)
{
  unint64_t v3 = *pval;
  uint type = it->utype;
  int result = *(_DWORD *)((char *)*pval + utype);
  *(_DWORD *)((char *)v3 + utypengine_table_unregister(&rsa_table, e) = value;
  return result;
}

int asn1_do_lock(ASN1_VALUE **pval, int op, const ASN1_ITEM *it)
{
  iint type = it->itype;
  if (itype != 6 && itype != 1) {
    return 0;
  }
  funcs = (int *)it->funcs;
  if (!funcs || (funcs[2] & 1) == 0) {
    return 0;
  }
  uint64_t v7 = funcs[3];
  unint64_t v8 = (_DWORD *)((char *)*pval + v7);
  if (op) {
    return CRYPTO_add_lock((int *)((char *)*pval + v7), op, funcs[4], 0, 0);
  }
  int result = 1;
  *unint64_t v8 = 1;
  return result;
}

void asn1_enc_init(ASN1_VALUE **pval, const ASN1_ITEM *it)
{
  if (pval)
  {
    funcs = (int *)it->funcs;
    if (*pval) {
      BOOL v3 = funcs == 0;
    }
    else {
      BOOL v3 = 1;
    }
    if (!v3 && (funcs[2] & 2) != 0)
    {
      uint64_t v4 = (char *)*pval + funcs[8];
      *(void *)uint64_t v4 = 0;
      *((void *)v4 + 1) = 0;
      *((_DWORD *)v4 + 4) = 1;
    }
  }
}

void *asn1_enc_cleanup(void *result, uint64_t a2)
{
  if (result)
  {
    uint64_t v2 = *(void *)(a2 + 32);
    if (*result) {
      BOOL v3 = v2 == 0;
    }
    else {
      BOOL v3 = 1;
    }
    if (!v3 && (*(unsigned char *)(v2 + 8) & 2) != 0)
    {
      uint64_t v4 = *result + *(int *)(v2 + 32);
      int result = freezero(*(void **)v4, *(void *)(v4 + 8));
      *(void *)uint64_t v4 = 0;
      *(void *)(v4 + 8) = 0;
      *(_DWORD *)(v4 + 16) = 1;
    }
  }
  return result;
}

int asn1_enc_save(ASN1_VALUE **pval, const unsigned __int8 *in, int inlen, const ASN1_ITEM *it)
{
  size_t v11 = 0;
  unint64_t v12 = 0;
  if (!pval) {
    return 1;
  }
  uint64_t v4 = *(void *)(*(void *)&inlen + 32);
  if (!*pval || v4 == 0) {
    return 1;
  }
  int v6 = 1;
  if ((*(unsigned char *)(v4 + 8) & 2) != 0)
  {
    int8x16_t v9 = (char *)*pval + *(int *)(v4 + 32);
    freezero(*(void **)v9, *((void *)v9 + 1));
    *(void *)int8x16_t v9 = 0;
    *((void *)v9 + 1) = 0;
    *((_DWORD *)v9 + 4) = 1;
    if (CBS_stow((uint64_t)in, &v12, &v11))
    {
      size_t v10 = v11;
      if ((v11 & 0x8000000000000000) == 0)
      {
        *(void *)int8x16_t v9 = v12;
        *((void *)v9 + 1) = v10;
        *((_DWORD *)v9 + 4) = 0;
        return v6;
      }
      freezero(v12, v11);
    }
    return 0;
  }
  return v6;
}

int asn1_enc_restore(int *len, unsigned __int8 **out, ASN1_VALUE **pval, const ASN1_ITEM *it)
{
  if (!pval) {
    return 0;
  }
  funcs = (int *)it->funcs;
  if (*pval) {
    BOOL v5 = funcs == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5) {
    return 0;
  }
  if ((funcs[2] & 2) == 0) {
    return 0;
  }
  int v6 = (char *)*pval + funcs[8];
  if (*((_DWORD *)v6 + 4)) {
    return 0;
  }
  if (out)
  {
    memcpy(*out, *(const void **)v6, *((void *)v6 + 1));
    *out += *((void *)v6 + 1);
  }
  if (len) {
    *leint n = *((void *)v6 + 1);
  }
  return 1;
}

ASN1_VALUE **__cdecl asn1_get_field_ptr(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt)
{
  return (ASN1_VALUE **)((char *)*pval + tt->offset);
}

const ASN1_TEMPLATE *__cdecl asn1_do_adb(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt, int nullerr)
{
  if ((tt->flags & 0x300) == 0) {
    return tt;
  }
  item = tt->item;
  if (!*pval)
  {
    tt = (const ASN1_TEMPLATE *)item->size;
    if (tt) {
      return tt;
    }
    goto LABEL_13;
  }
  BOOL v5 = *(ASN1_OBJECT **)((char *)*pval + item->utype);
  if ((tt->flags & 0x100) != 0) {
    uint64_t v6 = OBJ_obj2nid(v5);
  }
  else {
    uint64_t v6 = ASN1_INTEGER_get((ASN1_INTEGER *)v5);
  }
  uint64_t tcount = item->tcount;
  if (tcount < 1)
  {
LABEL_12:
    tt = (const ASN1_TEMPLATE *)item->funcs;
    if (tt) {
      return tt;
    }
LABEL_13:
    if (nullerr) {
      ERR_put_error(13, 4095, 164, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_utl.c", 297);
    }
    return 0;
  }
  tt = (const ASN1_TEMPLATE *)&item->templates->tag;
  while (tt[-1].item != (ASN1_ITEM_EXP *)v6)
  {
    tt = (const ASN1_TEMPLATE *)((char *)tt + 48);
    if (!--tcount) {
      goto LABEL_12;
    }
  }
  return tt;
}

uint64_t SM4_set_key(unsigned int *a1, uint64_t a2)
{
  uint64_t v2 = 0;
  uint64_t v10 = *MEMORY[0x263EF8340];
  unsigned int v3 = bswap32(a1[1]);
  v9[0] = bswap32(*a1) ^ 0xA3B1BAC6;
  v9[1] = v3 ^ 0x56AA3350;
  unsigned int v4 = bswap32(a1[3]);
  v9[2] = bswap32(a1[2]) ^ 0x677D9197;
  void v9[3] = v4 ^ 0xB27022DC;
  do
  {
    unint64_t v5 = v9[((_BYTE)v2 + 2) & 3] ^ v9[(v2 + 1) & 3] ^ (v9[((_BYTE)v2 - 1) & 3] ^ SM4_set_key_CK[v2]);
    int v6 = (SM4_S[v5 >> 24] << 24) | (SM4_S[BYTE2(v5)] << 16);
    LODWORD(v5) = SM4_S[LOBYTE(v9[((_BYTE)v2 + 2) & 3]) ^ LOBYTE(v9[(v2 + 1) & 3]) ^ LOBYTE(v9[((_BYTE)v2 - 1) & 3]) ^ LOBYTE(SM4_set_key_CK[v2])] | (SM4_S[BYTE1(v5)] << 8);
    HIDWORD(v7) = v5 | v6;
    LODWORD(v7) = v6;
    LODWORD(v5) = v9[v2 & 3] ^ (v7 >> 19) ^ (__PAIR64__(v5, v5 | v6) >> 9) ^ (v5 | v6);
    v9[v2 & 3] = v5;
    *(_DWORD *)(a2 + 4 * v2++) = v5;
  }
  while (v2 != 32);
  return 1;
}

uint64_t SM4_encrypt(unsigned int *a1, unsigned char *a2, _DWORD *a3)
{
  unsigned int v3 = bswap32(*a1);
  unsigned int v4 = bswap32(a1[1]);
  unsigned int v5 = bswap32(a1[2]);
  unsigned int v6 = bswap32(a1[3]);
  unint64_t v7 = v5 ^ *a3 ^ v6 ^ v4;
  unsigned int v8 = SM4_S[v7 >> 24];
  int v9 = SM4_S[(v5 ^ *(unsigned char *)a3 ^ v6 ^ v4)] | (SM4_S[BYTE1(v7)] << 8);
  int v10 = v9 | (v8 << 24) | (SM4_S[BYTE2(v7)] << 16);
  HIDWORD(v12) = v10;
  LODWORD(v12) = (v8 << 24) | (SM4_S[BYTE2(v7)] << 16);
  int v11 = v12 >> 22;
  HIDWORD(v12) = SM4_S[(v5 ^ *(unsigned char *)a3 ^ v6 ^ v4)];
  LODWORD(v12) = v10;
  int v13 = v3 ^ v11 ^ (__PAIR64__(v9, v10) >> 14) ^ (v12 >> 8) ^ ((v8 >> 6) | (4 * v10)) ^ v10;
  unint64_t v14 = v5 ^ a3[1] ^ v6 ^ v13;
  LODWORD(v7) = SM4_S[v14 >> 24];
  int v15 = (v7 << 24) | (SM4_S[BYTE2(v14)] << 16);
  int v16 = SM4_S[(v5 ^ *((unsigned char *)a3 + 4) ^ v6 ^ v13)] | (SM4_S[BYTE1(v14)] << 8);
  int v17 = v16 | v15;
  LODWORD(v7) = (v7 >> 6) | (4 * (v16 | v15));
  HIDWORD(v12) = v16 | v15;
  LODWORD(v12) = v15;
  int v18 = v12 >> 22;
  HIDWORD(v12) = SM4_S[(v5 ^ *((unsigned char *)a3 + 4) ^ v6 ^ v13)];
  LODWORD(v12) = v17;
  int v19 = (__PAIR64__(v16, v17) >> 14) ^ v18 ^ (v12 >> 8) ^ v7 ^ v4 ^ v17;
  unint64_t v20 = a3[2] ^ v6 ^ v19 ^ v13;
  unsigned int v21 = SM4_S[v20 >> 24];
  int v22 = (v21 << 24) | (SM4_S[BYTE2(v20)] << 16);
  int v23 = SM4_S[(*((unsigned char *)a3 + 8) ^ v6 ^ v19 ^ v13)] | (SM4_S[BYTE1(v20)] << 8);
  int v24 = v23 | v22;
  int v25 = (v21 >> 6) | (4 * (v23 | v22));
  HIDWORD(v12) = v23 | v22;
  LODWORD(v12) = v22;
  int v26 = v12 >> 22;
  HIDWORD(v12) = SM4_S[(*((unsigned char *)a3 + 8) ^ v6 ^ v19 ^ v13)];
  LODWORD(v12) = v24;
  unsigned int v27 = (__PAIR64__(v23, v24) >> 14) ^ v26 ^ (v12 >> 8) ^ v25 ^ v5 ^ v24;
  unint64_t v28 = v19 ^ v13 ^ a3[3] ^ v27;
  LODWORD(v20) = SM4_S[v28 >> 24];
  int v29 = SM4_S[(v19 ^ v13 ^ *((unsigned char *)a3 + 12) ^ v27)] | (SM4_S[BYTE1(v28)] << 8);
  int v30 = v29 | (v20 << 24) | (SM4_S[BYTE2(v28)] << 16);
  HIDWORD(v12) = v30;
  LODWORD(v12) = (v20 << 24) | (SM4_S[BYTE2(v28)] << 16);
  int v31 = v12 >> 22;
  HIDWORD(v12) = SM4_S[(v19 ^ v13 ^ *((unsigned char *)a3 + 12) ^ v27)];
  LODWORD(v12) = v30;
  LODWORD(v28) = (__PAIR64__(v29, v30) >> 14) ^ v31 ^ (v12 >> 8) ^ ((v20 >> 6) | (4 * v30)) ^ v6 ^ v30;
  unsigned int v32 = v27 ^ a3[4] ^ v19 ^ v28;
  int v33 = SM4_SBOX_T[HIBYTE(v32)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v32)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v32)], 16) ^ __ROR4__(SM4_SBOX_T[(v27 ^ *((unsigned char *)a3 + 16) ^ v19 ^ v28)], 24) ^ v13;
  LODWORD(v20) = v27 ^ a3[5] ^ v28 ^ v33;
  int v34 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v27 ^ *((unsigned char *)a3 + 20) ^ v28 ^ v33)], 24) ^ v19;
  unsigned int v35 = a3[6] ^ v28 ^ v34 ^ v33;
  int v36 = SM4_SBOX_T[HIBYTE(v35)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v35)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v35)], 16) ^ __ROR4__(SM4_SBOX_T[(*((unsigned char *)a3 + 24) ^ v28 ^ v34 ^ v33)], 24) ^ v27;
  LODWORD(v20) = a3[7] ^ v34 ^ v33 ^ v36;
  LODWORD(v28) = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(*((unsigned char *)a3 + 28) ^ v34 ^ v33 ^ v36)], 24) ^ v28;
  LODWORD(v20) = v36 ^ a3[8] ^ v34 ^ v28;
  int v37 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v36 ^ *((unsigned char *)a3 + 32) ^ v34 ^ v28)], 24) ^ v33;
  LODWORD(v20) = v36 ^ a3[9] ^ v28 ^ v37;
  int v38 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v36 ^ *((unsigned char *)a3 + 36) ^ v28 ^ v37)], 24) ^ v34;
  unsigned int v39 = a3[10] ^ v28 ^ v38 ^ v37;
  int v40 = SM4_SBOX_T[HIBYTE(v39)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v39)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v39)], 16) ^ __ROR4__(SM4_SBOX_T[(*((unsigned char *)a3 + 40) ^ v28 ^ v38 ^ v37)], 24) ^ v36;
  LODWORD(v20) = a3[11] ^ v38 ^ v37 ^ v40;
  LODWORD(v28) = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(*((unsigned char *)a3 + 44) ^ v38 ^ v37 ^ v40)], 24) ^ v28;
  LODWORD(v20) = v40 ^ a3[12] ^ v38 ^ v28;
  int v41 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v40 ^ *((unsigned char *)a3 + 48) ^ v38 ^ v28)], 24) ^ v37;
  LODWORD(v20) = v40 ^ a3[13] ^ v28 ^ v41;
  int v42 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v40 ^ *((unsigned char *)a3 + 52) ^ v28 ^ v41)], 24) ^ v38;
  unsigned int v43 = a3[14] ^ v28 ^ v42 ^ v41;
  int v44 = SM4_SBOX_T[HIBYTE(v43)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v43)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v43)], 16) ^ __ROR4__(SM4_SBOX_T[(*((unsigned char *)a3 + 56) ^ v28 ^ v42 ^ v41)], 24) ^ v40;
  LODWORD(v20) = a3[15] ^ v42 ^ v41 ^ v44;
  LODWORD(v28) = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(*((unsigned char *)a3 + 60) ^ v42 ^ v41 ^ v44)], 24) ^ v28;
  LODWORD(v20) = v44 ^ a3[16] ^ v42 ^ v28;
  int v45 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v44 ^ *((unsigned char *)a3 + 64) ^ v42 ^ v28)], 24) ^ v41;
  LODWORD(v20) = v44 ^ a3[17] ^ v28 ^ v45;
  int v46 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v44 ^ *((unsigned char *)a3 + 68) ^ v28 ^ v45)], 24) ^ v42;
  unsigned int v47 = a3[18] ^ v28 ^ v46 ^ v45;
  int v48 = SM4_SBOX_T[HIBYTE(v47)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v47)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v47)], 16) ^ __ROR4__(SM4_SBOX_T[(*((unsigned char *)a3 + 72) ^ v28 ^ v46 ^ v45)], 24) ^ v44;
  LODWORD(v20) = a3[19] ^ v46 ^ v45 ^ v48;
  LODWORD(v28) = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(*((unsigned char *)a3 + 76) ^ v46 ^ v45 ^ v48)], 24) ^ v28;
  LODWORD(v20) = v48 ^ a3[20] ^ v46 ^ v28;
  int v49 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v48 ^ *((unsigned char *)a3 + 80) ^ v46 ^ v28)], 24) ^ v45;
  LODWORD(v20) = v48 ^ a3[21] ^ v28 ^ v49;
  int v50 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v48 ^ *((unsigned char *)a3 + 84) ^ v28 ^ v49)], 24) ^ v46;
  unsigned int v51 = a3[22] ^ v28 ^ v50 ^ v49;
  int v52 = SM4_SBOX_T[HIBYTE(v51)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v51)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v51)], 16) ^ __ROR4__(SM4_SBOX_T[(*((unsigned char *)a3 + 88) ^ v28 ^ v50 ^ v49)], 24) ^ v48;
  LODWORD(v20) = a3[23] ^ v50 ^ v49 ^ v52;
  LODWORD(v28) = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(*((unsigned char *)a3 + 92) ^ v50 ^ v49 ^ v52)], 24) ^ v28;
  LODWORD(v20) = v52 ^ a3[24] ^ v50 ^ v28;
  int v53 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v52 ^ *((unsigned char *)a3 + 96) ^ v50 ^ v28)], 24) ^ v49;
  LODWORD(v20) = v52 ^ a3[25] ^ v28 ^ v53;
  int v54 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v52 ^ *((unsigned char *)a3 + 100) ^ v28 ^ v53)], 24) ^ v50;
  unsigned int v55 = a3[26] ^ v28 ^ v54 ^ v53;
  int v56 = SM4_SBOX_T[HIBYTE(v55)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v55)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v55)], 16) ^ __ROR4__(SM4_SBOX_T[(*((unsigned char *)a3 + 104) ^ v28 ^ v54 ^ v53)], 24) ^ v52;
  LODWORD(v20) = a3[27] ^ v54 ^ v53 ^ v56;
  unsigned int v57 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(*((unsigned char *)a3 + 108) ^ v54 ^ v53 ^ v56)], 24) ^ v28;
  unint64_t v58 = v56 ^ a3[28] ^ v54 ^ v57;
  unsigned int v59 = SM4_S[v58 >> 24];
  int v60 = SM4_S[(v56 ^ *((unsigned char *)a3 + 112) ^ v54 ^ v57)] | (SM4_S[BYTE1(v58)] << 8);
  int v61 = v60 | (v59 << 24) | (SM4_S[BYTE2(v58)] << 16);
  HIDWORD(v12) = v61;
  LODWORD(v12) = (v59 << 24) | (SM4_S[BYTE2(v58)] << 16);
  int v62 = v12 >> 22;
  HIDWORD(v12) = SM4_S[(v56 ^ *((unsigned char *)a3 + 112) ^ v54 ^ v57)];
  LODWORD(v12) = v61;
  unsigned int v63 = (__PAIR64__(v60, v61) >> 14) ^ v62 ^ (v12 >> 8) ^ ((v59 >> 6) | (4 * v61)) ^ v53 ^ v61;
  unint64_t v64 = v56 ^ a3[29] ^ v57 ^ v63;
  LODWORD(v20) = SM4_S[v64 >> 24];
  int v65 = (v20 << 24) | (SM4_S[BYTE2(v64)] << 16);
  int v66 = SM4_S[(v56 ^ *((unsigned char *)a3 + 116) ^ v57 ^ v63)] | (SM4_S[BYTE1(v64)] << 8);
  int v67 = v66 | v65;
  LODWORD(v20) = (v20 >> 6) | (4 * (v66 | v65));
  HIDWORD(v12) = v66 | v65;
  LODWORD(v12) = v65;
  int v68 = v12 >> 22;
  HIDWORD(v12) = SM4_S[(v56 ^ *((unsigned char *)a3 + 116) ^ v57 ^ v63)];
  LODWORD(v12) = v67;
  int v69 = (__PAIR64__(v66, v67) >> 14) ^ v68 ^ (v12 >> 8) ^ v20 ^ v54 ^ v67;
  int v70 = a3[31];
  unint64_t v71 = a3[30] ^ v57 ^ v69 ^ v63;
  unsigned int v72 = SM4_S[v71 >> 24];
  int v73 = SM4_S[BYTE1(v71)];
  int v74 = (v72 << 24) | (SM4_S[BYTE2(v71)] << 16);
  LODWORD(v71) = SM4_S[v71];
  unsigned int v75 = v71 | (v73 << 8);
  int v76 = v75 | v74;
  HIDWORD(v12) = v75 | v74;
  LODWORD(v12) = v74;
  uint64_t result = (__PAIR64__(v75, v75 | v74) >> 14);
  unsigned int v78 = result ^ (v12 >> 22) ^ (__PAIR64__(v71, v76) >> 8) ^ ((v72 >> 6) | (4 * v76)) ^ v56 ^ v76;
  unint64_t v79 = v69 ^ v63 ^ v70 ^ v78;
  LODWORD(v71) = SM4_S[v79 >> 24];
  int v80 = (v71 << 24) | (SM4_S[BYTE2(v79)] << 16);
  unsigned int v81 = SM4_S[v79];
  LODWORD(v79) = v81 | (SM4_S[BYTE1(v79)] << 8);
  HIDWORD(v12) = v79 | v80;
  LODWORD(v12) = v80;
  int v82 = (__PAIR64__(v79, v79 | v80) >> 14) ^ (v12 >> 22) ^ (__PAIR64__(v81, v79 | v80) >> 8) ^ ((v71 >> 6) | (4 * (v79 | v80))) ^ v57 ^ (v79 | v80);
  *a2 = HIBYTE(v82);
  a2[1] = BYTE2(v82);
  a2[2] = BYTE1(v82);
  a2[3] = v82;
  a2[4] = HIBYTE(v78);
  a2[5] = BYTE2(v78);
  a2[6] = BYTE1(v78);
  a2[7] = v78;
  a2[8] = HIBYTE(v69);
  a2[9] = BYTE2(v69);
  a2[10] = BYTE1(v69);
  a2[11] = v69;
  a2[12] = HIBYTE(v63);
  a2[13] = BYTE2(v63);
  a2[14] = BYTE1(v63);
  a2[15] = v63;
  return result;
}

uint64_t SM4_decrypt(unsigned int *a1, unsigned char *a2, _DWORD *a3)
{
  unsigned int v3 = bswap32(*a1);
  unsigned int v4 = bswap32(a1[1]);
  unsigned int v5 = bswap32(a1[2]);
  unsigned int v6 = bswap32(a1[3]);
  unint64_t v7 = v5 ^ a3[31] ^ v6 ^ v4;
  unsigned int v8 = SM4_S[v7 >> 24];
  int v9 = SM4_S[(v5 ^ *((unsigned char *)a3 + 124) ^ v6 ^ v4)] | (SM4_S[BYTE1(v7)] << 8);
  int v10 = v9 | (v8 << 24) | (SM4_S[BYTE2(v7)] << 16);
  HIDWORD(v12) = v10;
  LODWORD(v12) = (v8 << 24) | (SM4_S[BYTE2(v7)] << 16);
  int v11 = v12 >> 22;
  HIDWORD(v12) = SM4_S[(v5 ^ *((unsigned char *)a3 + 124) ^ v6 ^ v4)];
  LODWORD(v12) = v10;
  int v13 = v3 ^ v11 ^ (__PAIR64__(v9, v10) >> 14) ^ (v12 >> 8) ^ ((v8 >> 6) | (4 * v10)) ^ v10;
  unint64_t v14 = v5 ^ a3[30] ^ v6 ^ v13;
  LODWORD(v7) = SM4_S[v14 >> 24];
  int v15 = (v7 << 24) | (SM4_S[BYTE2(v14)] << 16);
  int v16 = SM4_S[(v5 ^ *((unsigned char *)a3 + 120) ^ v6 ^ v13)] | (SM4_S[BYTE1(v14)] << 8);
  int v17 = v16 | v15;
  LODWORD(v7) = (v7 >> 6) | (4 * (v16 | v15));
  HIDWORD(v12) = v16 | v15;
  LODWORD(v12) = v15;
  int v18 = v12 >> 22;
  HIDWORD(v12) = SM4_S[(v5 ^ *((unsigned char *)a3 + 120) ^ v6 ^ v13)];
  LODWORD(v12) = v17;
  int v19 = (__PAIR64__(v16, v17) >> 14) ^ v18 ^ (v12 >> 8) ^ v7 ^ v4 ^ v17;
  unint64_t v20 = a3[29] ^ v6 ^ v19 ^ v13;
  unsigned int v21 = SM4_S[v20 >> 24];
  int v22 = (v21 << 24) | (SM4_S[BYTE2(v20)] << 16);
  int v23 = SM4_S[(*((unsigned char *)a3 + 116) ^ v6 ^ v19 ^ v13)] | (SM4_S[BYTE1(v20)] << 8);
  int v24 = v23 | v22;
  int v25 = (v21 >> 6) | (4 * (v23 | v22));
  HIDWORD(v12) = v23 | v22;
  LODWORD(v12) = v22;
  int v26 = v12 >> 22;
  HIDWORD(v12) = SM4_S[(*((unsigned char *)a3 + 116) ^ v6 ^ v19 ^ v13)];
  LODWORD(v12) = v24;
  unsigned int v27 = (__PAIR64__(v23, v24) >> 14) ^ v26 ^ (v12 >> 8) ^ v25 ^ v5 ^ v24;
  unint64_t v28 = v19 ^ v13 ^ a3[28] ^ v27;
  LODWORD(v20) = SM4_S[v28 >> 24];
  int v29 = SM4_S[(v19 ^ v13 ^ *((unsigned char *)a3 + 112) ^ v27)] | (SM4_S[BYTE1(v28)] << 8);
  int v30 = v29 | (v20 << 24) | (SM4_S[BYTE2(v28)] << 16);
  HIDWORD(v12) = v30;
  LODWORD(v12) = (v20 << 24) | (SM4_S[BYTE2(v28)] << 16);
  int v31 = v12 >> 22;
  HIDWORD(v12) = SM4_S[(v19 ^ v13 ^ *((unsigned char *)a3 + 112) ^ v27)];
  LODWORD(v12) = v30;
  LODWORD(v28) = (__PAIR64__(v29, v30) >> 14) ^ v31 ^ (v12 >> 8) ^ ((v20 >> 6) | (4 * v30)) ^ v6 ^ v30;
  unsigned int v32 = v27 ^ a3[27] ^ v19 ^ v28;
  int v33 = SM4_SBOX_T[HIBYTE(v32)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v32)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v32)], 16) ^ __ROR4__(SM4_SBOX_T[(v27 ^ *((unsigned char *)a3 + 108) ^ v19 ^ v28)], 24) ^ v13;
  LODWORD(v20) = v27 ^ a3[26] ^ v28 ^ v33;
  int v34 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v27 ^ *((unsigned char *)a3 + 104) ^ v28 ^ v33)], 24) ^ v19;
  unsigned int v35 = a3[25] ^ v28 ^ v34 ^ v33;
  int v36 = SM4_SBOX_T[HIBYTE(v35)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v35)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v35)], 16) ^ __ROR4__(SM4_SBOX_T[(*((unsigned char *)a3 + 100) ^ v28 ^ v34 ^ v33)], 24) ^ v27;
  LODWORD(v20) = a3[24] ^ v34 ^ v33 ^ v36;
  LODWORD(v28) = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(*((unsigned char *)a3 + 96) ^ v34 ^ v33 ^ v36)], 24) ^ v28;
  LODWORD(v20) = v36 ^ a3[23] ^ v34 ^ v28;
  int v37 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v36 ^ *((unsigned char *)a3 + 92) ^ v34 ^ v28)], 24) ^ v33;
  LODWORD(v20) = v36 ^ a3[22] ^ v28 ^ v37;
  int v38 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v36 ^ *((unsigned char *)a3 + 88) ^ v28 ^ v37)], 24) ^ v34;
  unsigned int v39 = a3[21] ^ v28 ^ v38 ^ v37;
  int v40 = SM4_SBOX_T[HIBYTE(v39)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v39)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v39)], 16) ^ __ROR4__(SM4_SBOX_T[(*((unsigned char *)a3 + 84) ^ v28 ^ v38 ^ v37)], 24) ^ v36;
  LODWORD(v20) = a3[20] ^ v38 ^ v37 ^ v40;
  LODWORD(v28) = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(*((unsigned char *)a3 + 80) ^ v38 ^ v37 ^ v40)], 24) ^ v28;
  LODWORD(v20) = v40 ^ a3[19] ^ v38 ^ v28;
  int v41 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v40 ^ *((unsigned char *)a3 + 76) ^ v38 ^ v28)], 24) ^ v37;
  LODWORD(v20) = v40 ^ a3[18] ^ v28 ^ v41;
  int v42 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v40 ^ *((unsigned char *)a3 + 72) ^ v28 ^ v41)], 24) ^ v38;
  unsigned int v43 = a3[17] ^ v28 ^ v42 ^ v41;
  int v44 = SM4_SBOX_T[HIBYTE(v43)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v43)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v43)], 16) ^ __ROR4__(SM4_SBOX_T[(*((unsigned char *)a3 + 68) ^ v28 ^ v42 ^ v41)], 24) ^ v40;
  LODWORD(v20) = a3[16] ^ v42 ^ v41 ^ v44;
  LODWORD(v28) = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(*((unsigned char *)a3 + 64) ^ v42 ^ v41 ^ v44)], 24) ^ v28;
  LODWORD(v20) = v44 ^ a3[15] ^ v42 ^ v28;
  int v45 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v44 ^ *((unsigned char *)a3 + 60) ^ v42 ^ v28)], 24) ^ v41;
  LODWORD(v20) = v44 ^ a3[14] ^ v28 ^ v45;
  int v46 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v44 ^ *((unsigned char *)a3 + 56) ^ v28 ^ v45)], 24) ^ v42;
  unsigned int v47 = a3[13] ^ v28 ^ v46 ^ v45;
  int v48 = SM4_SBOX_T[HIBYTE(v47)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v47)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v47)], 16) ^ __ROR4__(SM4_SBOX_T[(*((unsigned char *)a3 + 52) ^ v28 ^ v46 ^ v45)], 24) ^ v44;
  LODWORD(v20) = a3[12] ^ v46 ^ v45 ^ v48;
  LODWORD(v28) = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(*((unsigned char *)a3 + 48) ^ v46 ^ v45 ^ v48)], 24) ^ v28;
  LODWORD(v20) = v48 ^ a3[11] ^ v46 ^ v28;
  int v49 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v48 ^ *((unsigned char *)a3 + 44) ^ v46 ^ v28)], 24) ^ v45;
  LODWORD(v20) = v48 ^ a3[10] ^ v28 ^ v49;
  int v50 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v48 ^ *((unsigned char *)a3 + 40) ^ v28 ^ v49)], 24) ^ v46;
  unsigned int v51 = a3[9] ^ v28 ^ v50 ^ v49;
  int v52 = SM4_SBOX_T[HIBYTE(v51)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v51)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v51)], 16) ^ __ROR4__(SM4_SBOX_T[(*((unsigned char *)a3 + 36) ^ v28 ^ v50 ^ v49)], 24) ^ v48;
  LODWORD(v20) = a3[8] ^ v50 ^ v49 ^ v52;
  LODWORD(v28) = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(*((unsigned char *)a3 + 32) ^ v50 ^ v49 ^ v52)], 24) ^ v28;
  LODWORD(v20) = v52 ^ a3[7] ^ v50 ^ v28;
  int v53 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v52 ^ *((unsigned char *)a3 + 28) ^ v50 ^ v28)], 24) ^ v49;
  LODWORD(v20) = v52 ^ a3[6] ^ v28 ^ v53;
  int v54 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(v52 ^ *((unsigned char *)a3 + 24) ^ v28 ^ v53)], 24) ^ v50;
  unsigned int v55 = a3[5] ^ v28 ^ v54 ^ v53;
  int v56 = SM4_SBOX_T[HIBYTE(v55)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v55)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v55)], 16) ^ __ROR4__(SM4_SBOX_T[(*((unsigned char *)a3 + 20) ^ v28 ^ v54 ^ v53)], 24) ^ v52;
  LODWORD(v20) = a3[4] ^ v54 ^ v53 ^ v56;
  unsigned int v57 = SM4_SBOX_T[BYTE3(v20)] ^ __ROR4__(SM4_SBOX_T[BYTE2(v20)], 8) ^ __ROR4__(SM4_SBOX_T[BYTE1(v20)], 16) ^ __ROR4__(SM4_SBOX_T[(*((unsigned char *)a3 + 16) ^ v54 ^ v53 ^ v56)], 24) ^ v28;
  unint64_t v58 = v56 ^ a3[3] ^ v54 ^ v57;
  unsigned int v59 = SM4_S[v58 >> 24];
  int v60 = SM4_S[(v56 ^ *((unsigned char *)a3 + 12) ^ v54 ^ v57)] | (SM4_S[BYTE1(v58)] << 8);
  int v61 = v60 | (v59 << 24) | (SM4_S[BYTE2(v58)] << 16);
  HIDWORD(v12) = v61;
  LODWORD(v12) = (v59 << 24) | (SM4_S[BYTE2(v58)] << 16);
  int v62 = v12 >> 22;
  HIDWORD(v12) = SM4_S[(v56 ^ *((unsigned char *)a3 + 12) ^ v54 ^ v57)];
  LODWORD(v12) = v61;
  unsigned int v63 = (__PAIR64__(v60, v61) >> 14) ^ v62 ^ (v12 >> 8) ^ ((v59 >> 6) | (4 * v61)) ^ v53 ^ v61;
  unint64_t v64 = v56 ^ a3[2] ^ v57 ^ v63;
  LODWORD(v20) = SM4_S[v64 >> 24];
  int v65 = (v20 << 24) | (SM4_S[BYTE2(v64)] << 16);
  int v66 = SM4_S[(v56 ^ *((unsigned char *)a3 + 8) ^ v57 ^ v63)] | (SM4_S[BYTE1(v64)] << 8);
  int v67 = v66 | v65;
  LODWORD(v20) = (v20 >> 6) | (4 * (v66 | v65));
  HIDWORD(v12) = v66 | v65;
  LODWORD(v12) = v65;
  int v68 = v12 >> 22;
  HIDWORD(v12) = SM4_S[(v56 ^ *((unsigned char *)a3 + 8) ^ v57 ^ v63)];
  LODWORD(v12) = v67;
  int v69 = (__PAIR64__(v66, v67) >> 14) ^ v68 ^ (v12 >> 8) ^ v20 ^ v54 ^ v67;
  int v70 = *a3;
  unint64_t v71 = a3[1] ^ v57 ^ v69 ^ v63;
  unsigned int v72 = SM4_S[v71 >> 24];
  int v73 = SM4_S[BYTE1(v71)];
  int v74 = (v72 << 24) | (SM4_S[BYTE2(v71)] << 16);
  LODWORD(v71) = SM4_S[v71];
  unsigned int v75 = v71 | (v73 << 8);
  int v76 = v75 | v74;
  HIDWORD(v12) = v75 | v74;
  LODWORD(v12) = v74;
  uint64_t result = (__PAIR64__(v75, v75 | v74) >> 14);
  unsigned int v78 = result ^ (v12 >> 22) ^ (__PAIR64__(v71, v76) >> 8) ^ ((v72 >> 6) | (4 * v76)) ^ v56 ^ v76;
  unint64_t v79 = v69 ^ v63 ^ v70 ^ v78;
  LODWORD(v71) = SM4_S[v79 >> 24];
  int v80 = (v71 << 24) | (SM4_S[BYTE2(v79)] << 16);
  unsigned int v81 = SM4_S[v79];
  LODWORD(v79) = v81 | (SM4_S[BYTE1(v79)] << 8);
  HIDWORD(v12) = v79 | v80;
  LODWORD(v12) = v80;
  int v82 = (__PAIR64__(v79, v79 | v80) >> 14) ^ (v12 >> 22) ^ (__PAIR64__(v81, v79 | v80) >> 8) ^ ((v71 >> 6) | (4 * (v79 | v80))) ^ v57 ^ (v79 | v80);
  *a2 = HIBYTE(v82);
  a2[1] = BYTE2(v82);
  a2[2] = BYTE1(v82);
  a2[3] = v82;
  a2[4] = HIBYTE(v78);
  a2[5] = BYTE2(v78);
  a2[6] = BYTE1(v78);
  a2[7] = v78;
  a2[8] = HIBYTE(v69);
  a2[9] = BYTE2(v69);
  a2[10] = BYTE1(v69);
  a2[11] = v69;
  a2[12] = HIBYTE(v63);
  a2[13] = BYTE2(v63);
  a2[14] = BYTE1(v63);
  a2[15] = v63;
  return result;
}

double CRYPTO_poly1305_init(uint64_t a1, _DWORD *a2)
{
  *(void *)a1 = *a2 & 0x3FFFFFF;
  *(void *)(a1 + 8) = ((unint64_t)*(unsigned int *)((char *)a2 + 3) >> 2) & 0x3FFFF03;
  *(void *)(a1 + 16) = ((unint64_t)*(unsigned int *)((char *)a2 + 6) >> 4) & 0x3FFC0FF;
  *(void *)(a1 + 24) = ((unint64_t)*(unsigned int *)((char *)a2 + 9) >> 6) & 0x3F03FFF;
  *(void *)(a1 + 32) = ((unint64_t)a2[3] >> 8) & 0xFFFFF;
  double result = 0.0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = a2[4];
  *(void *)(a1 + 88) = a2[5];
  *(void *)(a1 + 96) = a2[6];
  *(void *)(a1 + 104) = a2[7];
  *(void *)(a1 + 112) = 0;
  *(unsigned char *)(a1 + 136) = 0;
  return result;
}

uint64_t *CRYPTO_poly1305_update(uint64_t *result, char *a2, unint64_t a3)
{
  unint64_t v3 = a3;
  unsigned int v4 = a2;
  unsigned int v5 = result;
  uint64_t v6 = result[14];
  if (!v6) {
    goto LABEL_10;
  }
  unint64_t v7 = 16 - v6;
  if (16 - v6 >= a3) {
    unint64_t v7 = a3;
  }
  if (v7)
  {
    unsigned int v8 = result + 15;
    int v9 = a2;
    unint64_t v10 = v7;
    do
    {
      char v11 = *v9++;
      *((unsigned char *)v8 + result[14]) = v11;
      unsigned int v8 = (uint64_t *)((char *)v8 + 1);
      --v10;
    }
    while (v10);
    uint64_t v6 = result[14];
  }
  unint64_t v12 = v6 + v7;
  result[14] = v12;
  if (v12 >= 0x10)
  {
    unsigned int v4 = &a2[v7];
    unint64_t v3 = a3 - v7;
    double result = poly1305_blocks(result, (_DWORD *)result + 30, 0x10uLL);
    v5[14] = 0;
LABEL_10:
    if (v3 >= 0x10)
    {
      double result = poly1305_blocks(v5, v4, v3 & 0xFFFFFFFFFFFFFFF0);
      v4 += v3 & 0xFFFFFFFFFFFFFFF0;
      v3 &= 0xFu;
    }
    if (v3)
    {
      int v13 = v5 + 15;
      unint64_t v14 = v3;
      do
      {
        char v15 = *v4++;
        *((unsigned char *)v13 + v5[14]) = v15;
        int v13 = (uint64_t *)((char *)v13 + 1);
        --v14;
      }
      while (v14);
      v5[14] += v3;
    }
  }
  return result;
}

double CRYPTO_poly1305_finish(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 112);
  if (v4)
  {
    *(unsigned char *)(a1 + 120 + v4) = 1;
    if ((unint64_t)(v4 + 1) <= 0xF) {
      bzero((void *)(v4 + a1 + 121), 15 - v4);
    }
    *(unsigned char *)(a1 + 136) = 1;
    poly1305_blocks((uint64_t *)a1, (_DWORD *)(a1 + 120), 0x10uLL);
  }
  unint64_t v5 = *(void *)(a1 + 56) + (*(void *)(a1 + 48) >> 26);
  uint64_t v6 = v5 & 0x3FFFFFF;
  unint64_t v7 = *(void *)(a1 + 64) + (v5 >> 26);
  uint64_t v8 = v7 & 0x3FFFFFF;
  unint64_t v9 = *(void *)(a1 + 72) + (v7 >> 26);
  unint64_t v10 = 5 * (v9 >> 26) + *(void *)(a1 + 40);
  unint64_t v11 = v10 & 0x3FFFFFF;
  uint64_t v12 = (*(void *)(a1 + 48) & 0x3FFFFFFLL) + (v10 >> 26);
  unint64_t v13 = v12 + ((v11 + 5) >> 26);
  unint64_t v14 = v6 + (v13 >> 26);
  unint64_t v15 = v8 + (v14 >> 26);
  int64_t v16 = (v9 | 0xFFFFFFFFFC000000) + (v15 >> 26);
  uint64_t v17 = ((unint64_t)v16 >> 63) - 1;
  unint64_t v18 = v17 & 0x3FFFFFF & v13 | v12 & (v16 >> 63);
  unint64_t v19 = v17 & 0x3FFFFFF & v14 | v6 & (v16 >> 63);
  unint64_t v20 = v17 & 0x3FFFFFF & v15 | v8 & (v16 >> 63);
  unint64_t v21 = (v17 & 0x3FFFFFF & (v11 + 5) | v11 & (v16 >> 63) | (v18 << 26)) + *(void *)(a1 + 80);
  uint64_t v22 = *(void *)(a1 + 96);
  uint64_t v23 = ((v18 >> 6) | (v19 << 20)) + *(void *)(a1 + 88);
  uint64_t v24 = *(void *)(a1 + 104);
  *(_WORD *)a2 = v21;
  *(unsigned char *)(a2 + 2) = BYTE2(v21);
  unint64_t v25 = v23 + HIDWORD(v21);
  *(unsigned char *)(a2 + 3) = BYTE3(v21);
  *(_WORD *)(a2 + 4) = v25;
  *(unsigned char *)(a2 + 6) = BYTE2(v25);
  unint64_t v26 = v22 + (v19 >> 12) + (v20 << 14) + HIDWORD(v25);
  *(unsigned char *)(a2 + 7) = BYTE3(v25);
  *(_WORD *)(a2 + 8) = v26;
  *(unsigned char *)(a2 + 10) = BYTE2(v26);
  *(unsigned char *)(a2 + 11) = BYTE3(v26);
  unint64_t v27 = v24
      + (v20 >> 18)
      + ((v17 & v16 | v9 & (v16 >> 63)) << 8)
      + HIDWORD(v26);
  *(_WORD *)(a2 + 12) = v27;
  *(unsigned char *)(a2 + 14) = BYTE2(v27);
  *(unsigned char *)(a2 + 15) = BYTE3(v27);
  double result = 0.0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  return result;
}

uint64_t *poly1305_blocks(uint64_t *result, _DWORD *a2, unint64_t a3)
{
  unint64_t v4 = result[5];
  unint64_t v3 = result[6];
  uint64_t v5 = result[7];
  uint64_t v6 = result[8];
  uint64_t v7 = result[9];
  if (a3 >= 0x10)
  {
    uint64_t v8 = *result;
    uint64_t v9 = result[1];
    uint64_t v10 = result[2];
    uint64_t v11 = result[3];
    uint64_t v12 = result[4];
    uint64_t v13 = 5 * v10;
    uint64_t v14 = 5 * v11;
    uint64_t v15 = 5 * v12;
    do
    {
      unint64_t v16 = v4 + (*a2 & 0x3FFFFFF);
      unint64_t v17 = v3 + (((unint64_t)*(unsigned int *)((char *)a2 + 3) >> 2) & 0x3FFFFFF);
      uint64_t v18 = v5 + (((unint64_t)*(unsigned int *)((char *)a2 + 6) >> 4) & 0x3FFFFFF);
      uint64_t v19 = v6 + ((unint64_t)*(unsigned int *)((char *)a2 + 9) >> 6);
      unint64_t v20 = (((unint64_t)(*((unsigned char *)result + 136) == 0) << 24) | ((unint64_t)a2[3] >> 8))
          + v7;
      unint64_t v21 = v16 * v8 + v17 * v15 + v18 * v14 + v19 * v13 + 5 * v9 * v20;
      uint64_t v22 = v16 * v9 + v17 * v8 + v18 * v15 + v19 * v14 + v20 * v13;
      uint64_t v23 = v16 * v10 + v17 * v9 + v18 * v8 + v19 * v15 + v20 * v14;
      uint64_t v24 = v16 * v11 + v17 * v10 + v18 * v9 + v19 * v8 + v20 * v15;
      uint64_t v25 = v16 * v12 + v17 * v11 + v18 * v10 + v19 * v9 + v20 * v8;
      unint64_t v26 = v21 & 0x3FFFFFF;
      unint64_t v27 = v22 + (v21 >> 26);
      unint64_t v28 = v27 & 0x3FFFFFF;
      unint64_t v29 = v23 + (v27 >> 26);
      uint64_t v5 = v29 & 0x3FFFFFF;
      unint64_t v30 = v24 + (v29 >> 26);
      uint64_t v6 = v30 & 0x3FFFFFF;
      unint64_t v31 = v25 + (v30 >> 26);
      uint64_t v7 = v31 & 0x3FFFFFF;
      unint64_t v32 = 5 * (v31 >> 26) + v26;
      unint64_t v4 = v32 & 0x3FFFFFF;
      unint64_t v3 = v28 + (v32 >> 26);
      a2 += 4;
      a3 -= 16;
    }
    while (a3 > 0xF);
  }
  result[5] = v4;
  result[6] = v3;
  result[7] = v5;
  result[8] = v6;
  result[9] = v7;
  return result;
}

void *reallocarray(void *a1, unint64_t a2, unint64_t a3)
{
  if (a2 && (a3 | a2) >> 32 && !is_mul_ok(a2, a3))
  {
    *__error() = 12;
    return 0;
  }
  else
  {
    size_t v5 = a3 * a2;
    return malloc_type_realloc(a1, v5, 0x86F04196uLL);
  }
}

EVP_PKEY *__cdecl EVP_PKCS82PKEY(PKCS8_PRIV_KEY_INFO *p8)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  o = 0;
  if (!PKCS8_pkey_get0(&o, 0, 0, 0, (uint64_t)p8)) {
    return 0;
  }
  uint64_t v2 = EVP_PKEY_new();
  if (v2)
  {
    int v3 = OBJ_obj2nid(o);
    if (!EVP_PKEY_set_type((uint64_t)v2, v3))
    {
      ERR_put_error(6, 4095, 118, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_pkey.c", 86);
      i2t_ASN1_OBJECT(buf, 80, o);
      ERR_asprintf_error_data("TYPE=%s", buf);
LABEL_11:
      EVP_PKEY_free(v2);
      return 0;
    }
    unint64_t v4 = (unsigned int (*)(EVP_PKEY *, PKCS8_PRIV_KEY_INFO *))*((void *)v2->pkey.ptr + 8);
    if (!v4)
    {
      int v5 = 144;
      int v6 = 98;
      goto LABEL_10;
    }
    if (!v4(v2, p8))
    {
      int v5 = 145;
      int v6 = 94;
LABEL_10:
      ERR_put_error(6, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_pkey.c", v6);
      goto LABEL_11;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_pkey.c", 81);
  }
  return v2;
}

PKCS8_PRIV_KEY_INFO *__cdecl EVP_PKEY2PKCS8(EVP_PKEY *pkey)
{
  uint64_t v2 = PKCS8_PRIV_KEY_INFO_new();
  int v3 = v2;
  if (v2)
  {
    int ptr = pkey->pkey.ptr;
    if (!ptr)
    {
      int v6 = 118;
      int v7 = 132;
      goto LABEL_9;
    }
    int v5 = (unsigned int (*)(PKCS8_PRIV_KEY_INFO *, EVP_PKEY *))*((void *)ptr + 9);
    if (!v5)
    {
      int v6 = 144;
      int v7 = 128;
      goto LABEL_9;
    }
    if (!v5(v2, pkey))
    {
      int v6 = 146;
      int v7 = 124;
LABEL_9:
      ERR_put_error(6, 4095, v6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_pkey.c", v7);
      PKCS8_PRIV_KEY_INFO_free(v3);
      return 0;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_pkey.c", 117);
  }
  return v3;
}

int EVP_PKEY_get_attr_count(const EVP_PKEY *key)
{
  return X509at_get_attr_count(*(const STACK **)&key[1].references);
}

int EVP_PKEY_get_attr_by_NID(const EVP_PKEY *key, int nid, int lastpos)
{
  return X509at_get_attr_by_NID(*(const STACK **)&key[1].references, nid, lastpos);
}

int EVP_PKEY_get_attr_by_OBJ(const EVP_PKEY *key, ASN1_OBJECT *obj, int lastpos)
{
  return X509at_get_attr_by_OBJ(*(const STACK **)&key[1].references, obj, lastpos);
}

X509_ATTRIBUTE *__cdecl EVP_PKEY_get_attr(const EVP_PKEY *key, int loc)
{
  return X509at_get_attr(*(const STACK **)&key[1].references, loc);
}

X509_ATTRIBUTE *__cdecl EVP_PKEY_delete_attr(EVP_PKEY *key, int loc)
{
  return X509at_delete_attr(*(STACK **)&key[1].references, loc);
}

int EVP_PKEY_add1_attr(EVP_PKEY *key, X509_ATTRIBUTE *attr)
{
  return X509at_add1_attr((STACK **)&key[1].references, attr) != 0;
}

int EVP_PKEY_add1_attr_by_OBJ(EVP_PKEY *key, const ASN1_OBJECT *obj, int type, const unsigned __int8 *bytes, int len)
{
  return X509at_add1_attr_by_OBJ((STACK **)&key[1].references, obj, type, bytes, len) != 0;
}

int EVP_PKEY_add1_attr_by_NID(EVP_PKEY *key, int nid, int type, const unsigned __int8 *bytes, int len)
{
  return X509at_add1_attr_by_NID((STACK **)&key[1].references, nid, type, bytes, len) != 0;
}

int EVP_PKEY_add1_attr_by_txt(EVP_PKEY *key, const char *attrname, int type, const unsigned __int8 *bytes, int len)
{
  return X509at_add1_attr_by_txt((STACK **)&key[1].references, attrname, type, bytes, len) != 0;
}

void CONF_set_nconf(CONF *conf, LHASH *hash)
{
  unint64_t v4 = (CONF_METHOD *)default_CONF_method;
  if (!default_CONF_method)
  {
    unint64_t v4 = NCONF_default();
    default_CONF_methochar d = (uint64_t)v4;
  }
  ((void (*)(CONF *))v4->init)(conf);
  conf->unsigned int data = hash;
}

int CONF_set_default_method(CONF_METHOD *meth)
{
  default_CONF_methochar d = (uint64_t)meth;
  return 1;
}

LHASH *__cdecl CONF_load(LHASH *conf, const char *file, uint64_t *eline)
{
  int v5 = BIO_new_file(file, "rb");
  if (v5)
  {
    int v6 = v5;
    uint64_t bio = CONF_load_bio(conf, v5, eline);
    BIO_free(v6);
    return bio;
  }
  else
  {
    ERR_put_error(14, 4095, 2, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", 97);
    return 0;
  }
}

LHASH *__cdecl CONF_load_bio(LHASH *conf, BIO *bp, uint64_t *eline)
{
  int v6 = (CONF_METHOD *)default_CONF_method;
  if (!default_CONF_method)
  {
    int v6 = NCONF_default();
    default_CONF_methochar d = (uint64_t)v6;
  }
  v8[1] = 0;
  uint64_t v9 = 0;
  v8[0] = 0;
  ((void (*)(void *))v6->init)(v8);
  uint64_t v9 = conf;
  if ((*(unsigned int (**)(void *, BIO *, uint64_t *))(v8[0] + 40))(v8, bp, eline)) {
    return v9;
  }
  else {
    return 0;
  }
}

LHASH *__cdecl CONF_load_fp(LHASH *conf, FILE *fp, uint64_t *eline)
{
  int v5 = BIO_new_fp(fp, 0);
  if (v5)
  {
    int v6 = v5;
    uint64_t bio = CONF_load_bio(conf, v5, eline);
    BIO_free(v6);
    return bio;
  }
  else
  {
    ERR_put_error(14, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", 114);
    return 0;
  }
}

int NCONF_load_bio(CONF *conf, BIO *bp, uint64_t *eline)
{
  if (conf)
  {
    load_uint64_t bio = (uint64_t (*)(void))conf->meth->load_bio;
    return load_bio();
  }
  else
  {
    ERR_put_error(14, 4095, 105, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", 285);
    return 0;
  }
}

STACK *__cdecl CONF_get_section(STACK *conf, const char *section)
{
  if (conf)
  {
    int v3 = conf;
    memset(&confa, 0, sizeof(confa));
    unint64_t v4 = (CONF_METHOD *)default_CONF_method;
    if (!default_CONF_method)
    {
      unint64_t v4 = NCONF_default();
      default_CONF_methochar d = (uint64_t)v4;
    }
    ((void (*)(CONF *))v4->init)(&confa);
    confa.unsigned int data = (LHASH *)v3;
    return NCONF_get_section(&confa, section);
  }
  return conf;
}

STACK *__cdecl NCONF_get_section(const CONF *conf, const char *section)
{
  if (!conf)
  {
    int v3 = 105;
    int v4 = 296;
LABEL_8:
    ERR_put_error(14, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", v4);
    return 0;
  }
  if (!section)
  {
    int v3 = 107;
    int v4 = 301;
    goto LABEL_8;
  }
  return _CONF_get_section_values(conf, section);
}

char *__cdecl CONF_get_string(LHASH *conf, const char *group, const char *name)
{
  if (conf)
  {
    memset(&confa, 0, sizeof(confa));
    int v6 = (CONF_METHOD *)default_CONF_method;
    if (!default_CONF_method)
    {
      int v6 = NCONF_default();
      default_CONF_methochar d = (uint64_t)v6;
    }
    ((void (*)(CONF *))v6->init)(&confa);
    confa.unsigned int data = conf;
    return NCONF_get_string(&confa, group, name);
  }
  else
  {
    return NCONF_get_string(0, group, name);
  }
}

char *__cdecl NCONF_get_string(const CONF *conf, const char *group, const char *name)
{
  int string = _CONF_get_string(conf, group, name);
  if (!string)
  {
    if (conf)
    {
      ERR_put_error(14, 4095, 108, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", 322);
      int v7 = "";
      if (group) {
        int v7 = group;
      }
      ERR_asprintf_error_data("group=%s name=%s", v7, name);
    }
    else
    {
      ERR_put_error(14, 4095, 106, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", 319);
    }
  }
  return string;
}

uint64_t CONF_get_number(LHASH *conf, const char *group, const char *name)
{
  uint64_t result = 0;
  if (conf)
  {
    int v5 = conf;
    v8[0] = 0;
    v8[1] = 0;
    uint64_t v9 = 0;
    int v6 = (CONF_METHOD *)default_CONF_method;
    if (!default_CONF_method)
    {
      int v6 = NCONF_default();
      default_CONF_methochar d = (uint64_t)v6;
    }
    ((void (*)(void *))v6->init)(v8);
    uint64_t v9 = v5;
    conf = (LHASH *)v8;
  }
  if (!NCONF_get_number_e((const CONF *)conf, group, name, &result)) {
    ERR_clear_error();
  }
  return result;
}

int NCONF_get_number_e(const CONF *conf, const char *group, const char *name, uint64_t *result)
{
  if (result)
  {
    int string = NCONF_get_string(conf, group, name);
    if (string)
    {
      int v7 = string;
      *uint64_t result = 0;
      if (((unsigned int (*)(const CONF *, void))conf->meth->is_number)(conf, *string))
      {
        uint64_t v8 = v7 + 1;
        do
        {
          uint64_t v9 = 10 * *result;
          *uint64_t result = v9 + ((int (*)(const CONF *, void))conf->meth->to_int)(conf, *(v8 - 1));
        }
        while (((unsigned int (*)(const CONF *, void))conf->meth->is_number)(conf, *v8++));
      }
      LODWORD(string) = 1;
    }
  }
  else
  {
    ERR_put_error(14, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", 335);
    LODWORD(string) = 0;
  }
  return (int)string;
}

void CONF_free(LHASH *conf)
{
  uint64_t v2 = (CONF_METHOD *)default_CONF_method;
  if (!default_CONF_method)
  {
    uint64_t v2 = NCONF_default();
    default_CONF_methochar d = (uint64_t)v2;
  }
  v3[1] = 0;
  int v4 = 0;
  v3[0] = 0;
  ((void (*)(void *))v2->init)(v3);
  int v4 = conf;
  (*(void (**)(void *))(v3[0] + 32))(v3);
}

void NCONF_free_data(CONF *conf)
{
  if (conf) {
    ((void (*)(CONF *))conf->meth->destroy_data)(conf);
  }
}

int CONF_dump_fp(LHASH *conf, FILE *out)
{
  int v3 = BIO_new_fp(out, 0);
  if (v3)
  {
    int v4 = v3;
    int v5 = CONF_dump_bio(conf, v3);
    BIO_free(v4);
    return v5;
  }
  else
  {
    ERR_put_error(14, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", 199);
    return 0;
  }
}

int CONF_dump_bio(LHASH *conf, BIO *out)
{
  int v4 = (CONF_METHOD *)default_CONF_method;
  if (!default_CONF_method)
  {
    int v4 = NCONF_default();
    default_CONF_methochar d = (uint64_t)v4;
  }
  v6[1] = 0;
  int v7 = 0;
  v6[0] = 0;
  ((void (*)(void *))v4->init)(v6);
  int v7 = conf;
  return (*(uint64_t (**)(void *, BIO *))(v6[0] + 48))(v6, out);
}

int NCONF_dump_bio(const CONF *conf, BIO *out)
{
  if (conf)
  {
    dump = (uint64_t (*)(void))conf->meth->dump;
    return dump();
  }
  else
  {
    ERR_put_error(14, 4095, 105, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", 370);
    return 0;
  }
}

CONF *__cdecl NCONF_new(CONF_METHOD *meth)
{
  if (!meth) {
    meth = NCONF_default();
  }
  uint64_t v1 = (CONF *)((uint64_t (*)(void))meth->create)();
  if (!v1) {
    ERR_put_error(14, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", 232);
  }
  return v1;
}

void NCONF_free(CONF *conf)
{
  if (conf) {
    ((void (*)(CONF *))conf->meth->destroy)(conf);
  }
}

int NCONF_load(CONF *conf, const char *file, uint64_t *eline)
{
  if (conf)
  {
    loachar d = (uint64_t (*)(void))conf->meth->load;
    return load();
  }
  else
  {
    ERR_put_error(14, 4095, 105, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", 259);
    return 0;
  }
}

int NCONF_load_fp(CONF *conf, FILE *fp, uint64_t *eline)
{
  int v5 = BIO_new_fp(fp, 0);
  if (v5)
  {
    int v6 = v5;
    int bio = NCONF_load_bio(conf, v5, eline);
    BIO_free(v6);
    return bio;
  }
  else
  {
    ERR_put_error(14, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", 273);
    return 0;
  }
}

int NCONF_dump_fp(const CONF *conf, FILE *out)
{
  int v3 = BIO_new_fp(out, 0);
  if (v3)
  {
    int v4 = v3;
    int v5 = NCONF_dump_bio(conf, v3);
    BIO_free(v4);
    return v5;
  }
  else
  {
    ERR_put_error(14, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_lib.c", 358);
    return 0;
  }
}

uint64_t CMS_signed_get_attr_count(uint64_t a1)
{
  return X509at_get_attr_count(*(const STACK **)(a1 + 24));
}

uint64_t CMS_signed_get_attr_by_NID(uint64_t a1, int a2, int a3)
{
  return X509at_get_attr_by_NID(*(const STACK **)(a1 + 24), a2, a3);
}

uint64_t CMS_signed_get_attr_by_OBJ(uint64_t a1, ASN1_OBJECT *a2, int a3)
{
  return X509at_get_attr_by_OBJ(*(const STACK **)(a1 + 24), a2, a3);
}

X509_ATTRIBUTE *CMS_signed_get_attr(uint64_t a1, int a2)
{
  return X509at_get_attr(*(const STACK **)(a1 + 24), a2);
}

X509_ATTRIBUTE *CMS_signed_delete_attr(uint64_t a1, int a2)
{
  return X509at_delete_attr(*(STACK **)(a1 + 24), a2);
}

BOOL CMS_signed_add1_attr(uint64_t a1, X509_ATTRIBUTE *a2)
{
  return X509at_add1_attr((STACK **)(a1 + 24), a2) != 0;
}

BOOL CMS_signed_add1_attr_by_OBJ(uint64_t a1, const ASN1_OBJECT *a2, int a3, const unsigned __int8 *a4, int a5)
{
  return X509at_add1_attr_by_OBJ((STACK **)(a1 + 24), a2, a3, a4, a5) != 0;
}

BOOL CMS_signed_add1_attr_by_NID(uint64_t a1, int a2, int a3, const unsigned __int8 *a4, int a5)
{
  return X509at_add1_attr_by_NID((STACK **)(a1 + 24), a2, a3, a4, a5) != 0;
}

BOOL CMS_signed_add1_attr_by_txt(uint64_t a1, const char *a2, int a3, const unsigned __int8 *a4, int a5)
{
  return X509at_add1_attr_by_txt((STACK **)(a1 + 24), a2, a3, a4, a5) != 0;
}

void *CMS_signed_get0_data_by_OBJ(uint64_t a1, ASN1_OBJECT *a2, int a3, int a4)
{
  return X509at_get0_data_by_OBJ(*(STACK **)(a1 + 24), a2, a3, a4);
}

uint64_t CMS_unsigned_get_attr_count(uint64_t a1)
{
  return X509at_get_attr_count(*(const STACK **)(a1 + 48));
}

uint64_t CMS_unsigned_get_attr_by_NID(uint64_t a1, int a2, int a3)
{
  return X509at_get_attr_by_NID(*(const STACK **)(a1 + 48), a2, a3);
}

uint64_t CMS_unsigned_get_attr_by_OBJ(uint64_t a1, ASN1_OBJECT *a2, int a3)
{
  return X509at_get_attr_by_OBJ(*(const STACK **)(a1 + 48), a2, a3);
}

X509_ATTRIBUTE *CMS_unsigned_get_attr(uint64_t a1, int a2)
{
  return X509at_get_attr(*(const STACK **)(a1 + 48), a2);
}

X509_ATTRIBUTE *CMS_unsigned_delete_attr(uint64_t a1, int a2)
{
  return X509at_delete_attr(*(STACK **)(a1 + 48), a2);
}

BOOL CMS_unsigned_add1_attr(uint64_t a1, X509_ATTRIBUTE *a2)
{
  return X509at_add1_attr((STACK **)(a1 + 48), a2) != 0;
}

BOOL CMS_unsigned_add1_attr_by_OBJ(uint64_t a1, const ASN1_OBJECT *a2, int a3, const unsigned __int8 *a4, int a5)
{
  return X509at_add1_attr_by_OBJ((STACK **)(a1 + 48), a2, a3, a4, a5) != 0;
}

BOOL CMS_unsigned_add1_attr_by_NID(uint64_t a1, int a2, int a3, const unsigned __int8 *a4, int a5)
{
  return X509at_add1_attr_by_NID((STACK **)(a1 + 48), a2, a3, a4, a5) != 0;
}

BOOL CMS_unsigned_add1_attr_by_txt(uint64_t a1, const char *a2, int a3, const unsigned __int8 *a4, int a5)
{
  return X509at_add1_attr_by_txt((STACK **)(a1 + 48), a2, a3, a4, a5) != 0;
}

void *CMS_unsigned_get0_data_by_OBJ(uint64_t a1, ASN1_OBJECT *a2, int a3, int a4)
{
  return X509at_get0_data_by_OBJ(*(STACK **)(a1 + 48), a2, a3, a4);
}

const EVP_MD *EVP_sha1(void)
{
  return (const EVP_MD *)&sha1_md;
}

const EVP_MD *EVP_sha224(void)
{
  return (const EVP_MD *)&sha224_md;
}

const EVP_MD *EVP_sha256(void)
{
  return (const EVP_MD *)&sha256_md;
}

const EVP_MD *EVP_sha384(void)
{
  return (const EVP_MD *)&sha384_md;
}

const EVP_MD *EVP_sha512(void)
{
  return (const EVP_MD *)&sha512_md;
}

const EVP_MD *EVP_sha512_224(void)
{
  return (const EVP_MD *)&sha512_224_md;
}

const EVP_MD *EVP_sha512_256(void)
{
  return (const EVP_MD *)&sha512_256_md;
}

uint64_t sha1_init(uint64_t a1)
{
  return SHA1_Init(*(SHA_CTX **)(a1 + 24));
}

uint64_t sha1_update(uint64_t a1, const void *a2, size_t a3)
{
  return SHA1_Update(*(SHA_CTX **)(a1 + 24), a2, a3);
}

uint64_t sha1_final(uint64_t a1, unsigned __int8 *md)
{
  return SHA1_Final(md, *(SHA_CTX **)(a1 + 24));
}

uint64_t sha224_init(uint64_t a1)
{
  return SHA224_Init(*(SHA256_CTX **)(a1 + 24));
}

uint64_t sha224_update(uint64_t a1, const void *a2, size_t a3)
{
  return SHA256_Update(*(SHA256_CTX **)(a1 + 24), a2, a3);
}

uint64_t sha224_final(uint64_t a1, unsigned __int8 *md)
{
  return SHA224_Final(md, *(SHA256_CTX **)(a1 + 24));
}

uint64_t sha256_init(uint64_t a1)
{
  return SHA256_Init(*(SHA256_CTX **)(a1 + 24));
}

uint64_t sha256_update(uint64_t a1, const void *a2, size_t a3)
{
  return SHA256_Update(*(SHA256_CTX **)(a1 + 24), a2, a3);
}

uint64_t sha256_final(uint64_t a1, unsigned __int8 *md)
{
  return SHA256_Final(md, *(SHA256_CTX **)(a1 + 24));
}

uint64_t sha384_init(uint64_t a1)
{
  return SHA384_Init(*(SHA512_CTX **)(a1 + 24));
}

uint64_t sha384_update(uint64_t a1, const void *a2, size_t a3)
{
  return SHA512_Update(*(SHA512_CTX **)(a1 + 24), a2, a3);
}

uint64_t sha384_final(uint64_t a1, unsigned __int8 *md)
{
  return SHA384_Final(md, *(SHA512_CTX **)(a1 + 24));
}

uint64_t sha512_init(uint64_t a1)
{
  return SHA512_Init(*(SHA512_CTX **)(a1 + 24));
}

uint64_t sha512_update(uint64_t a1, const void *a2, size_t a3)
{
  return SHA512_Update(*(SHA512_CTX **)(a1 + 24), a2, a3);
}

uint64_t sha512_final(uint64_t a1, unsigned __int8 *md)
{
  return SHA512_Final(md, *(SHA512_CTX **)(a1 + 24));
}

uint64_t sha512_224_init(uint64_t a1)
{
  return SHA512_224_Init(*(void *)(a1 + 24));
}

uint64_t sha512_224_update(uint64_t a1, const void *a2, size_t a3)
{
  return SHA512_224_Update(*(SHA512_CTX **)(a1 + 24), a2, a3);
}

uint64_t sha512_224_final(uint64_t a1, unsigned __int8 *md)
{
  return SHA512_224_Final(md, *(SHA512_CTX **)(a1 + 24));
}

uint64_t sha512_256_init(uint64_t a1)
{
  return SHA512_256_Init(*(void *)(a1 + 24));
}

uint64_t sha512_256_update(uint64_t a1, const void *a2, size_t a3)
{
  return SHA512_256_Update(*(SHA512_CTX **)(a1 + 24), a2, a3);
}

uint64_t sha512_256_final(uint64_t a1, unsigned __int8 *md)
{
  return SHA512_256_Final(md, *(SHA512_CTX **)(a1 + 24));
}

int (__cdecl *__cdecl sk_set_cmp_func(STACK *sk, int (__cdecl *c)(const char *const *, const char *const *)))(const char *const *, const char *const *)
{
  uint64_t result = sk->comp;
  if (result != c) {
    sk->sortechar d = 0;
  }
  sk->comp = c;
  return result;
}

STACK *__cdecl sk_dup(STACK *st)
{
  uint64_t v2 = sk_new(st->comp);
  int v3 = v2;
  if (v2)
  {
    int v4 = (char **)reallocarray(v2->data, st->num_alloc, 8uLL);
    if (v4)
    {
      v3->unsigned int data = v4;
      v3->num = st->num;
      memcpy(v4, st->data, 8 * st->num);
      *(void *)&v3->sortechar d = *(void *)&st->sorted;
      v3->comp = st->comp;
    }
    else
    {
      free(v3->data);
      free(v3);
      return 0;
    }
  }
  return v3;
}

STACK *__cdecl sk_new(int (__cdecl *cmp)(const char *const *, const char *const *))
{
  uint64_t v2 = (STACK *)malloc_type_malloc(0x20uLL, 0x1080040FC7F6965uLL);
  if (v2 && (int v3 = (char **)reallocarray(0, 4uLL, 8uLL), (v2->data = v3) != 0))
  {
    for (uint64_t i = 0; i != 4; ++i)
      v2->data[i] = 0;
    v2->comp = cmp;
    v2->num = 0;
    *(void *)&v2->sortechar d = 0x400000000;
  }
  else
  {
    free(v2);
    return 0;
  }
  return v2;
}

void sk_free(STACK *a1)
{
  if (a1)
  {
    free(a1->data);
    free(a1);
  }
}

STACK *sk_new_null(void)
{
  return sk_new(0);
}

int sk_insert(STACK *sk, char *data, int where)
{
  if (sk)
  {
    int v5 = sk;
    unint64_t num_alloc = sk->num_alloc;
    int num = sk->num;
    if ((int)num_alloc <= sk->num + 1)
    {
      suint64_t k = (STACK *)reallocarray(sk->data, num_alloc, 0x10uLL);
      if (!sk) {
        return (int)sk;
      }
      v5->unsigned int data = (char **)sk;
      v5->num_alloc *= 2;
      int num = v5->num;
    }
    uint64_t v8 = v5->data;
    if (where < 0 || num <= where)
    {
      v8[num] = data;
    }
    else
    {
      memmove(&v8[where + 1], &v8[where], 8 * (num - where));
      v5->data[where] = data;
      int num = v5->num;
    }
    LODWORD(sk) = num + 1;
    v5->int num = num + 1;
    v5->sortechar d = 0;
  }
  return (int)sk;
}

char *__cdecl sk_delete_ptr(STACK *st, char *p)
{
  uint64_t num = st->num;
  if ((int)num < 1) {
    return 0;
  }
  uint64_t v3 = 0;
  while (st->data[v3] != p)
  {
    if (num == ++v3) {
      return 0;
    }
  }
  return sk_delete(st, v3);
}

char *__cdecl sk_delete(STACK *st, int loc)
{
  uint64_t v2 = 0;
  if (st && (loc & 0x80000000) == 0)
  {
    int num = st->num;
    if (st->num <= loc)
    {
      return 0;
    }
    else
    {
      unsigned int data = st->data;
      int v6 = &data[loc];
      uint64_t v2 = *v6;
      int v7 = num - 1;
      if (v7 != loc)
      {
        memmove(v6, &data[loc + 1], 8 * (v7 - loc));
        int v7 = st->num - 1;
      }
      st->int num = v7;
    }
  }
  return v2;
}

int sk_find(STACK *st, char *data)
{
  return internal_find(st, data, 2);
}

unint64_t internal_find(STACK *st, char *a2, int a3)
{
  *(void *)uint64_t key = a2;
  if (!st) {
    return 0xFFFFFFFFLL;
  }
  if (st->comp)
  {
    sk_sort(st);
    if (a2)
    {
      int v6 = OBJ_bsearch_ex_(key, (const char *)st->data, st->num, 8, (int (__cdecl *)(const void *, const void *))st->comp, a3);
      if (v6) {
        return (unint64_t)(v6 - (const char *)st->data) >> 3;
      }
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t num = st->num;
  if ((int)num < 1) {
    return 0xFFFFFFFFLL;
  }
  unint64_t result = 0;
  while (st->data[result] != a2)
  {
    if (num == ++result) {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

int sk_find_ex(STACK *st, char *data)
{
  return internal_find(st, data, 1);
}

int sk_push(STACK *st, char *data)
{
  return sk_insert(st, data, st->num);
}

int sk_unshift(STACK *st, char *data)
{
  return sk_insert(st, data, 0);
}

char *__cdecl sk_shift(STACK *st)
{
  if (st && st->num >= 1) {
    return sk_delete(st, 0);
  }
  else {
    return 0;
  }
}

char *__cdecl sk_pop(STACK *st)
{
  if (st && st->num >= 1) {
    return sk_delete(st, st->num - 1);
  }
  else {
    return 0;
  }
}

void sk_zero(STACK *st)
{
  if (st)
  {
    uint64_t num = st->num;
    if ((int)num >= 1)
    {
      bzero(st->data, 8 * num);
      st->uint64_t num = 0;
    }
  }
}

void sk_pop_free(STACK *st, void (__cdecl *func)(void *))
{
  if (st)
  {
    int num = st->num;
    if (st->num >= 1)
    {
      uint64_t v5 = 0;
      do
      {
        if (st->data[v5])
        {
          ((void (*)(void))func)();
          int num = st->num;
        }
        ++v5;
      }
      while (v5 < num);
    }
    free(st->data);
    free(st);
  }
}

int sk_num(const STACK *a1)
{
  if (a1) {
    return a1->num;
  }
  else {
    return -1;
  }
}

char *__cdecl sk_value(const STACK *a1, int a2)
{
  unint64_t result = 0;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (a1->num <= a2) {
      return 0;
    }
    else {
      return a1->data[a2];
    }
  }
  return result;
}

char *__cdecl sk_set(STACK *a1, int a2, char *a3)
{
  uint64_t v3 = 0;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (a1->num <= a2)
    {
      return 0;
    }
    else
    {
      a1->sortechar d = 0;
      a1->data[a2] = a3;
      return a3;
    }
  }
  return v3;
}

void sk_sort(STACK *st)
{
  if (st)
  {
    if (!st->sorted)
    {
      qsort(st->data, st->num, 8uLL, (int (__cdecl *)(const void *, const void *))st->comp);
      st->sortechar d = 1;
    }
  }
}

int sk_is_sorted(const STACK *st)
{
  if (!st || st->sorted) {
    return 1;
  }
  if (st->comp) {
    return st->num < 2;
  }
  return 0;
}

void *EVP_idea_cbc()
{
  return &idea_cbc;
}

void *EVP_idea_cfb64()
{
  return &idea_cfb64;
}

void *EVP_idea_ofb()
{
  return &idea_ofb;
}

void *EVP_idea_ecb()
{
  return &idea_ecb;
}

uint64_t idea_init_key(EVP_CIPHER_CTX *ctx, unint64_t a2, uint64_t a3, int a4)
{
  if (!a4 && (EVP_CIPHER_CTX_flags(ctx) & 0xF0007) != 4 && (EVP_CIPHER_CTX_flags(ctx) & 0xF0007) != 3)
  {
    uint64_t v8 = 0;
    memset(v7, 0, sizeof(v7));
    idea_set_encrypt_key(a2, (int *)v7);
    idea_set_decrypt_key((uint64_t)v7, (uint64_t)ctx->cipher_data);
    explicit_bzero(v7, 0xD8uLL);
  }
  idea_set_encrypt_key(a2, (int *)ctx->cipher_data);
  return 1;
}

uint64_t idea_cbc_cipher(uint64_t a1, _DWORD *a2, unsigned int *a3, unint64_t a4)
{
  for (unint64_t i = a4; i > 0x7FFFFFFFFFFFFEFFLL; a2 += 0x1FFFFFFFFFFFFFC0)
  {
    idea_cbc_encrypt(a3, a2, 0x7FFFFFFFFFFFFF00, *(unsigned int **)(a1 + 120), a1 + 40, *(_DWORD *)(a1 + 16));
    i -= 0x7FFFFFFFFFFFFF00;
    a3 += 0x1FFFFFFFFFFFFFC0;
  }
  if (i) {
    idea_cbc_encrypt(a3, a2, i, *(unsigned int **)(a1 + 120), a1 + 40, *(_DWORD *)(a1 + 16));
  }
  return 1;
}

uint64_t idea_cfb64_cipher(uint64_t a1, unsigned char *a2, unint64_t *a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v4 = a4;
    if (a4 >= 0x7FFFFFFFFFFFFF00) {
      unint64_t v8 = 0x7FFFFFFFFFFFFF00;
    }
    else {
      unint64_t v8 = a4;
    }
    uint64_t v9 = (unsigned int *)(a1 + 40);
    uint64_t v10 = (int *)(a1 + 88);
    do
    {
      idea_cfb64_encrypt(a3, a2, v8, *(unsigned int **)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      a3 = (unint64_t *)((char *)a3 + v8);
      a2 += v8;
      v4 -= v8;
      if (v4 < v8) {
        unint64_t v8 = v4;
      }
    }
    while (v4);
  }
  return 1;
}

uint64_t idea_ofb_cipher(uint64_t a1, unsigned char *a2, unint64_t *a3, unint64_t a4)
{
  for (unint64_t i = a4; i > 0x7FFFFFFFFFFFFEFFLL; a2 += 0x7FFFFFFFFFFFFF00)
  {
    idea_ofb64_encrypt(a3, a2, 0x7FFFFFFFFFFFFF00, *(unsigned int **)(a1 + 120), (unsigned __int8 *)(a1 + 40), (int *)(a1 + 88));
    i -= 0x7FFFFFFFFFFFFF00;
    a3 += 0xFFFFFFFFFFFFFE0;
  }
  if (i) {
    idea_ofb64_encrypt(a3, a2, i, *(unsigned int **)(a1 + 120), (unsigned __int8 *)(a1 + 40), (int *)(a1 + 88));
  }
  return 1;
}

uint64_t idea_ecb_cipher(unsigned int **a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4 = (int)(*a1)[1];
  unint64_t v5 = a4 - v4;
  if (a4 >= v4)
  {
    unint64_t v9 = 0;
    do
    {
      idea_ecb_encrypt((unsigned int *)(a3 + v9), (_DWORD *)(a2 + v9), a1[15]);
      v9 += v4;
    }
    while (v9 <= v5);
  }
  return 1;
}

int BN_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)
{
  if (!BN_get_flags((uint64_t)p, 4u))
  {
    BN_CTX_start(ctx);
    unint64_t v9 = BN_CTX_get(ctx);
    if (v9)
    {
      uint64_t v10 = v9;
      if (r == a || (uint64_t v11 = r, r == p))
      {
        uint64_t v11 = BN_CTX_get(ctx);
        if (!v11) {
          goto LABEL_20;
        }
      }
      else if (!r)
      {
        goto LABEL_20;
      }
      if (BN_one((uint64_t)v11)
        && (!BN_is_odd((uint64_t)p) || bn_copy(v11, a))
        && bn_copy(v10, a))
      {
        if (BN_num_bits(p) < 2)
        {
LABEL_19:
          BOOL v8 = bn_copy(r, v11);
LABEL_21:
          BN_CTX_end(ctx);
          return v8;
        }
        int v12 = 1;
        while (BN_sqr(v10, v10, ctx) && (!BN_is_bit_set(p, v12) || BN_mul(v11, v11, v10, ctx)))
        {
          if (++v12 >= BN_num_bits(p)) {
            goto LABEL_19;
          }
        }
      }
    }
LABEL_20:
    BOOL v8 = 0;
    goto LABEL_21;
  }
  ERR_put_error(3, 4095, 66, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_exp.c", 132);
  return -1;
}

int BN_mod_exp_simple(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx)
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  if (BN_get_flags((uint64_t)p, 4u))
  {
    ERR_put_error(3, 4095, 66, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_exp.c", 190);
    LODWORD(v10) = -1;
    return (int)v10;
  }
  int v11 = BN_num_bits(p);
  if (v11)
  {
    int v12 = v11;
    BN_CTX_start(ctx);
    uint64_t v10 = BN_CTX_get(ctx);
    if (!v10)
    {
LABEL_53:
      BN_CTX_end(ctx);
      return (int)v10;
    }
    uint64_t v13 = BN_CTX_get(ctx);
    unint64_t v30 = v13;
    if (v13)
    {
      uint64_t v14 = v13;
      if (BN_nnmod(v13, a, m, ctx))
      {
        if (BN_is_zero((uint64_t)v14))
        {
          BN_zero((uint64_t)r);
LABEL_9:
          LODWORD(v10) = 1;
          goto LABEL_53;
        }
        uint64_t v46 = 0;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v40 = 0u;
        long long v41 = 0u;
        long long v38 = 0u;
        long long v39 = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        long long v34 = 0u;
        long long v35 = 0u;
        long long v32 = 0u;
        long long v33 = 0u;
        long long v31 = 0u;
        if (v12 > 671)
        {
          unsigned int v16 = 6;
          goto LABEL_23;
        }
        if (v12 > 239)
        {
          unsigned int v16 = 5;
          goto LABEL_23;
        }
        if (v12 > 79)
        {
          unsigned int v16 = 4;
          goto LABEL_23;
        }
        if (v12 >= 24)
        {
          unsigned int v16 = 3;
LABEL_23:
          if (BN_mod_mul(v10, v14, v14, m, ctx))
          {
            uint64_t v17 = 0;
            while (1)
            {
              uint64_t v18 = BN_CTX_get(ctx);
              *(&v30 + v17 + 1) = v18;
              if (!v18 || !BN_mod_mul(v18, *(&v30 + v17), v10, m, ctx)) {
                break;
              }
              if ((v17++ + 2) >> (v16 - 1)) {
                goto LABEL_30;
              }
            }
          }
          goto LABEL_52;
        }
        unsigned int v16 = 1;
LABEL_30:
        if (BN_one((uint64_t)r))
        {
          LOBYTE(v10) = 0;
          int v20 = v12 - 1;
          char v21 = 1;
          while (1)
          {
            while (!BN_is_bit_set(p, v20))
            {
              if ((v10 & 1) != 0 && !BN_mod_mul(r, r, r, m, ctx)) {
                goto LABEL_52;
              }
              if (!v20) {
                goto LABEL_9;
              }
              --v20;
            }
            char v29 = v21;
            if (v16 < 2)
            {
              int v22 = 0;
              int v24 = 1;
            }
            else
            {
              int v22 = 0;
              int v23 = v20 - 1;
              int v24 = 1;
              for (int i = 1; i != v16; ++i)
              {
                if (v23 < 0) {
                  break;
                }
                is_bit_int set = BN_is_bit_set(p, v23);
                int v27 = (v24 << (i - v22)) | 1;
                if (is_bit_set)
                {
                  int v22 = i;
                  int v24 = v27;
                }
                --v23;
              }
            }
            if (!(v29 & 1 | (v22 < 0))) {
              break;
            }
LABEL_49:
            if (!BN_mod_mul(r, r, *(&v30 + (v24 >> 1)), m, ctx)) {
              goto LABEL_52;
            }
            char v21 = 0;
            LODWORD(v10) = 1;
            v20 += ~v22;
            if (v20 < 0) {
              goto LABEL_53;
            }
          }
          int v28 = v22 + 1;
          while (BN_mod_mul(r, r, r, m, ctx))
          {
            if (!--v28) {
              goto LABEL_49;
            }
          }
        }
      }
    }
LABEL_52:
    LODWORD(v10) = 0;
    goto LABEL_53;
  }
  if (BN_abs_is_word((uint64_t)m, 1))
  {
    BN_zero((uint64_t)r);
    LODWORD(v10) = 1;
    return (int)v10;
  }
  return BN_one((uint64_t)r);
}

int BN_mod_exp_mont_consttime(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)
{
  if (!BN_is_odd((uint64_t)m))
  {
    ERR_put_error(3, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_exp.c", 396);
    return 0;
  }
  size_t top = m->top;
  int v13 = BN_num_bits(p);
  if (v13)
  {
    int v14 = v13;
    memset(&b, 0, sizeof(b));
    memset(&r, 0, sizeof(r));
    BN_CTX_start(ctx);
    uint64_t v15 = in_mont;
    if (!in_mont)
    {
      int v23 = BN_MONT_CTX_new();
      if (!v23)
      {
        int v52 = 0;
        BOOL v51 = 0;
LABEL_80:
        freezero(v23, v52 + 64);
        BN_CTX_end(ctx);
        return v51;
      }
      uint64_t v15 = v23;
      if (!BN_MONT_CTX_set(v23, m, ctx))
      {
        BOOL v51 = 0;
        int v23 = 0;
        int v52 = 0;
        goto LABEL_73;
      }
    }
    unsigned int v57 = rr;
    if (v14 <= 22) {
      int v16 = 1;
    }
    else {
      int v16 = 3;
    }
    if (v14 <= 89) {
      int v17 = v16;
    }
    else {
      int v17 = 4;
    }
    if (v14 <= 306) {
      int v18 = v17;
    }
    else {
      int v18 = 5;
    }
    if (v14 <= 937) {
      int v19 = v18;
    }
    else {
      int v19 = 6;
    }
    unsigned int v20 = 1 << v19;
    int v21 = 2 * top;
    if (2 * (int)top <= 1 << v19) {
      int v21 = 1 << v19;
    }
    uint64_t v22 = v21 + (top << v19);
    int v59 = 8 * v22;
    int v23 = (BN_MONT_CTX *)malloc_type_calloc(((v22 << 35) + 0x4000000000) >> 32, 1uLL, 0xC562F41FuLL);
    if (!v23)
    {
      BOOL v51 = 0;
      int v52 = v59;
LABEL_73:
      if (!in_mont)
      {
        if (v15)
        {
          int v53 = v23;
          BN_MONT_CTX_free(v15);
          int v23 = v53;
        }
      }
      goto LABEL_80;
    }
    unint64_t v58 = v23;
    uint64_t v56 = ((unint64_t)v23 & 0xFFFFFFFFFFFFFFC0) + 64;
    b.char d = (unint64_t *)(v56 + ((8 * (int)top) << v19));
    r.char d = &b.d[(int)top];
    r.size_t top = 0;
    r.dmax = top;
    b.size_t top = 0;
    b.dmax = top;
    *(void *)&r.int neg = 0x200000000;
    *(void *)&b.int neg = 0x200000000;
    int v24 = BN_value_one();
    if (BN_to_montgomery(&b, v24, (uint64_t)v15, ctx)
      && BN_nnmod(&r, a, m, ctx)
      && BN_to_montgomery(&r, &r, (uint64_t)v15, ctx))
    {
      if (b.top >= (int)top) {
        uint64_t v25 = top;
      }
      else {
        uint64_t v25 = b.top;
      }
      if ((int)v25 >= 1)
      {
        char d = b.d;
        int v27 = (void *)v56;
        do
        {
          uint64_t v28 = *d++;
          *int v27 = v28;
          v27 += (1 << v19);
          --v25;
        }
        while (v25);
      }
      uint64_t v29 = v58 & 0x3F;
      if (r.top >= (int)top) {
        uint64_t v30 = top;
      }
      else {
        uint64_t v30 = r.top;
      }
      if ((int)v30 >= 1)
      {
        long long v31 = r.d;
        long long v32 = (void *)((char *)&v58->Ni.neg - v29);
        do
        {
          uint64_t v33 = *v31++;
          *long long v32 = v33;
          v32 += (1 << v19);
          --v30;
        }
        while (v30);
      }
      if (v19 < 2)
      {
LABEL_54:
        int v45 = v14 - 1;
        int v46 = 0;
        int v47 = (v14 - 1) % v19;
        if ((v47 & 0x80000000) == 0)
        {
          int v48 = v47 + 1;
          do
          {
            int v46 = BN_is_bit_set(p, v45--) + 2 * v46;
            --v48;
          }
          while (v48);
        }
        if (MOD_EXP_CTIME_COPY_FROM_PREBUF((uint64_t)&b, top, v56, v46, v19))
        {
LABEL_58:
          if (v45 < 0)
          {
            BOOL v51 = BN_from_montgomery(v57, &b, v15, ctx) != 0;
            goto LABEL_65;
          }
          int v49 = 0;
          int v50 = 0;
          while (BN_mod_mul_montgomery(&b, &b, &b, v15, ctx))
          {
            int v50 = BN_is_bit_set(p, v45 + v49--) + 2 * v50;
            if (!(v19 + v49))
            {
              if (MOD_EXP_CTIME_COPY_FROM_PREBUF((uint64_t)&r, top, v56, v50, v19))
              {
                v45 += v49;
                if (BN_mod_mul_montgomery(&b, &b, &r, v15, ctx)) {
                  goto LABEL_58;
                }
              }
              break;
            }
          }
        }
      }
      else if (BN_mod_mul_montgomery(&b, &r, &r, v15, ctx))
      {
        if (b.top >= (int)top) {
          uint64_t v34 = top;
        }
        else {
          uint64_t v34 = b.top;
        }
        if ((int)v34 >= 1)
        {
          long long v35 = b.d;
          long long v36 = (unint64_t *)((char *)&v58->n0 - v29);
          do
          {
            uint64_t v37 = *v35++;
            *long long v36 = v37;
            v36 += (1 << v19);
            --v34;
          }
          while (v34);
        }
        if (v20 <= 4) {
          uint64_t v38 = 4;
        }
        else {
          uint64_t v38 = v20;
        }
        uint64_t v55 = v38;
        uint64_t v39 = (uint64_t)&v58->flags - v29;
        uint64_t v40 = 3;
        while (BN_mod_mul_montgomery(&b, &r, &b, v15, ctx))
        {
          if (b.top >= (int)top) {
            uint64_t v41 = top;
          }
          else {
            uint64_t v41 = b.top;
          }
          if ((int)v41 >= 1)
          {
            long long v42 = b.d;
            long long v43 = (void *)v39;
            do
            {
              uint64_t v44 = *v42++;
              *long long v43 = v44;
              v43 += (1 << v19);
              --v41;
            }
            while (v41);
          }
          ++v40;
          v39 += 8;
          if (v40 == v55) {
            goto LABEL_54;
          }
        }
      }
    }
    BOOL v51 = 0;
LABEL_65:
    int v23 = v58;
    int v52 = v59;
    goto LABEL_73;
  }
  if (BN_abs_is_word((uint64_t)m, 1))
  {
    BN_zero((uint64_t)rr);
    return 1;
  }
  return BN_one((uint64_t)rr);
}

uint64_t MOD_EXP_CTIME_COPY_FROM_PREBUF(uint64_t a1, size_t a2, uint64_t a3, int a4, int a5)
{
  int v8 = a2;
  uint64_t result = bn_wexpand(a1, a2);
  if (result)
  {
    uint64_t v11 = (1 << a5);
    if (a5 > 3)
    {
      if (v8 >= 1)
      {
        uint64_t v18 = 0;
        uint64_t v19 = (1 << (a5 - 2));
        int v20 = (v19 - 1) & a4;
        int v21 = a4 >> (a5 - 2);
        uint64_t v22 = 8 * (1 << a5);
        uint64_t v23 = *(void *)a1;
        uint64_t v24 = a3 + 8 * (3 << (a5 - 2));
        uint64_t v25 = a3 + 8 * (2 << (a5 - 2));
        uint64_t v26 = a3 + 8 * (int)v19;
        do
        {
          uint64_t v27 = 0;
          uint64_t v28 = 0;
          do
          {
            uint64_t v29 = *(void *)(a3 + 8 * v27);
            if (v21) {
              uint64_t v29 = 0;
            }
            uint64_t v30 = *(void *)(v26 + 8 * v27);
            if ((((v21 ^ 1) - 1) & ~v21) >= 0) {
              uint64_t v30 = 0;
            }
            uint64_t v31 = v30 | v29;
            uint64_t v32 = *(void *)(v25 + 8 * v27);
            uint64_t v33 = *(void *)(v24 + 8 * v27);
            if ((((v21 ^ 2) - 1) & ~v21) >= 0) {
              uint64_t v32 = 0;
            }
            if ((((v21 ^ 3) - 1) & ~v21) >= 0) {
              uint64_t v33 = 0;
            }
            uint64_t v34 = v31 | v32 | v33;
            if ((int)(((v20 ^ v27) - 1) & ~v20) >= 0) {
              uint64_t v34 = 0;
            }
            v28 |= v34;
            ++v27;
          }
          while (v19 != v27);
          *(void *)(v23 + 8 * v18++) = v28;
          v24 += v22;
          v25 += v22;
          v26 += v22;
          a3 += v22;
        }
        while (v18 != v8);
      }
    }
    else
    {
      BOOL v12 = __OFSUB__(v8, 1);
      if (v8 >= 1)
      {
        uint64_t v13 = 0;
        uint64_t v14 = *(void *)a1;
        do
        {
          uint64_t v15 = 0;
          uint64_t v16 = 0;
          do
          {
            uint64_t v17 = *(void *)(a3 + 8 * v15);
            if ((int)(((v15 ^ a4) - 1) & ~a4) < 0 == v12) {
              uint64_t v17 = 0;
            }
            v16 |= v17;
            BOOL v12 = __OFSUB__(v11, ++v15);
          }
          while (v11 != v15);
          *(void *)(v14 + 8 * v13++) = v16;
          a3 += 8 * (1 << a5);
          BOOL v12 = __OFSUB__(v13, v8);
        }
        while (v13 != v8);
      }
    }
    *(_DWORD *)(a1 + 8) = v8;
    bn_correct_top((uint64_t *)a1);
    return 1;
  }
  return result;
}

int BN_mod_exp_mont(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)
{
  BOOL v12 = BN_get_flags((uint64_t)p, 4u) != 0;
  return BN_mod_exp_mont_internal(r, (BIGNUM *)a, (BIGNUM *)p, (BIGNUM *)m, ctx, m_ctx, v12);
}

uint64_t BN_mod_exp_mont_internal(BIGNUM *rr, BIGNUM *a, BIGNUM *p, BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont, int a7)
{
  uint64_t v60 = *MEMORY[0x263EF8340];
  if (a7)
  {
    return BN_mod_exp_mont_consttime(rr, a, p, m, ctx, in_mont);
  }
  if (!BN_is_odd((uint64_t)m))
  {
    ERR_put_error(3, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_exp.c", 654);
    return 0;
  }
  int v14 = BN_num_bits(p);
  if (v14)
  {
    int v15 = v14;
    BN_CTX_start(ctx);
    uint64_t v16 = BN_CTX_get(ctx);
    if (v16)
    {
      uint64_t v17 = v16;
      uint64_t v18 = BN_CTX_get(ctx);
      if (v18)
      {
        uint64_t v19 = v18;
        int v20 = BN_CTX_get(ctx);
        long long v43 = v20;
        if (v20)
        {
          int v21 = v20;
          mont = in_mont;
          if (in_mont)
          {
LABEL_11:
            if (BN_nnmod(v21, a, m, ctx))
            {
              uint64_t v22 = mont;
              if (BN_is_zero((uint64_t)v21))
              {
                BN_zero((uint64_t)rr);
                BOOL v23 = 1;
LABEL_65:
                if (!in_mont && v22) {
                  BN_MONT_CTX_free(v22);
                }
                goto LABEL_24;
              }
              if (BN_to_montgomery(v21, v21, (uint64_t)mont, ctx))
              {
                uint64_t v59 = 0;
                long long v57 = 0u;
                long long v58 = 0u;
                long long v55 = 0u;
                long long v56 = 0u;
                long long v53 = 0u;
                long long v54 = 0u;
                long long v51 = 0u;
                long long v52 = 0u;
                long long v49 = 0u;
                long long v50 = 0u;
                long long v47 = 0u;
                long long v48 = 0u;
                long long v45 = 0u;
                long long v46 = 0u;
                long long v44 = 0u;
                if (v15 <= 671)
                {
                  if (v15 <= 239)
                  {
                    if (v15 <= 79)
                    {
                      if (v15 < 24)
                      {
                        unsigned int v41 = 1;
LABEL_42:
                        uint64_t v29 = BN_value_one();
                        if (BN_to_montgomery(v19, v29, (uint64_t)v22, ctx))
                        {
                          char v30 = 0;
                          int v31 = v15 - 1;
                          char v32 = 1;
                          while (1)
                          {
                            while (!BN_is_bit_set(p, v31))
                            {
                              if ((v30 & 1) != 0 && !BN_mod_mul_montgomery(v19, v19, v19, v22, ctx)) {
                                goto LABEL_64;
                              }
                              if (!v31)
                              {
LABEL_63:
                                BOOL v23 = BN_from_montgomery(rr, v19, v22, ctx) != 0;
                                goto LABEL_65;
                              }
                              --v31;
                            }
                            char v40 = v32;
                            if (v41 < 2)
                            {
                              int v33 = 0;
                              int v35 = 1;
                            }
                            else
                            {
                              int v33 = 0;
                              int v34 = v31 - 1;
                              int v35 = 1;
                              for (int i = 1; i != v41; ++i)
                              {
                                if (v34 < 0) {
                                  break;
                                }
                                is_bit_int set = BN_is_bit_set(p, v34);
                                int v38 = (v35 << (i - v33)) | 1;
                                if (is_bit_set)
                                {
                                  int v33 = i;
                                  int v35 = v38;
                                }
                                --v34;
                              }
                            }
                            uint64_t v22 = mont;
                            if (!(v40 & 1 | (v33 < 0))) {
                              break;
                            }
LABEL_61:
                            if (!BN_mod_mul_montgomery(v19, v19, *(&v43 + (v35 >> 1)), mont, ctx)) {
                              goto LABEL_64;
                            }
                            char v32 = 0;
                            char v30 = 1;
                            v31 += ~v33;
                            if (v31 < 0) {
                              goto LABEL_63;
                            }
                          }
                          int v39 = v33 + 1;
                          while (BN_mod_mul_montgomery(v19, v19, v19, mont, ctx))
                          {
                            if (!--v39) {
                              goto LABEL_61;
                            }
                          }
                        }
                        goto LABEL_64;
                      }
                      int v25 = 3;
                    }
                    else
                    {
                      int v25 = 4;
                    }
                  }
                  else
                  {
                    int v25 = 5;
                  }
                }
                else
                {
                  int v25 = 6;
                }
                unsigned int v41 = v25;
                if (BN_mod_mul_montgomery(v17, v21, v21, mont, ctx))
                {
                  uint64_t v26 = 0;
                  while (1)
                  {
                    uint64_t v27 = BN_CTX_get(ctx);
                    *(&v43 + v26 + 1) = v27;
                    if (!v27 || !BN_mod_mul_montgomery(v27, *(&v43 + v26), v17, mont, ctx)) {
                      goto LABEL_22;
                    }
                    if ((v26++ + 2) >> (v41 - 1))
                    {
                      uint64_t v22 = mont;
                      goto LABEL_42;
                    }
                  }
                }
              }
LABEL_64:
              BOOL v23 = 0;
              goto LABEL_65;
            }
LABEL_22:
            BOOL v23 = 0;
            uint64_t v22 = mont;
            goto LABEL_65;
          }
          uint64_t v24 = BN_MONT_CTX_new();
          if (v24)
          {
            mont = v24;
            if (!BN_MONT_CTX_set(v24, m, ctx)) {
              goto LABEL_22;
            }
            goto LABEL_11;
          }
        }
      }
    }
    BOOL v23 = 0;
LABEL_24:
    BN_CTX_end(ctx);
    return v23;
  }
  if (BN_abs_is_word((uint64_t)m, 1))
  {
    BN_zero((uint64_t)rr);
    return 1;
  }
  return BN_one((uint64_t)rr);
}

uint64_t BN_mod_exp_mont_nonct(BIGNUM *a1, BIGNUM *a2, BIGNUM *a3, BIGNUM *a4, BN_CTX *a5, BN_MONT_CTX *a6)
{
  return BN_mod_exp_mont_internal(a1, a2, a3, a4, a5, a6, 0);
}

int BN_mod_exp_mont_word(BIGNUM *r, unint64_t a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)
{
  if (BN_get_flags((uint64_t)p, 4u))
  {
    ERR_put_error(3, 4095, 66, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_exp.c", 831);
    return -1;
  }
  if (!BN_is_odd((uint64_t)m))
  {
    ERR_put_error(3, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_exp.c", 837);
    return 0;
  }
  if (m->top == 1) {
    a %= *m->d;
  }
  int v14 = BN_num_bits(p);
  if (!v14)
  {
    if (!BN_abs_is_word((uint64_t)m, 1))
    {
      return BN_one((uint64_t)r);
    }
LABEL_43:
    BN_zero((uint64_t)r);
    return 1;
  }
  if (!a) {
    goto LABEL_43;
  }
  int v15 = v14;
  BN_CTX_start(ctx);
  if (!BN_CTX_get(ctx)) {
    goto LABEL_53;
  }
  uint64_t v16 = BN_CTX_get(ctx);
  if (!v16) {
    goto LABEL_53;
  }
  uint64_t v17 = v16;
  uint64_t v18 = BN_CTX_get(ctx);
  if (!v18) {
    goto LABEL_53;
  }
  uint64_t v28 = v18;
  uint64_t v19 = m_ctx;
  if (!m_ctx)
  {
    uint64_t v24 = BN_MONT_CTX_new();
    if (v24)
    {
      uint64_t v19 = v24;
      if (!BN_MONT_CTX_set(v24, m, ctx))
      {
LABEL_66:
        int v12 = 0;
        goto LABEL_69;
      }
      goto LABEL_13;
    }
LABEL_53:
    int v12 = 0;
    goto LABEL_54;
  }
LABEL_13:
  if (v15 < 2)
  {
    if (a == 1)
    {
LABEL_48:
      if (BN_one((uint64_t)r)) {
        goto LABEL_63;
      }
    }
    else
    {
LABEL_60:
      if (BN_set_word(v17, a) && BN_to_montgomery(v17, v17, (uint64_t)v19, ctx)) {
        goto LABEL_62;
      }
    }
    goto LABEL_66;
  }
  mont = v19;
  int v29 = v15 - 1;
  int v12 = 1;
  unint64_t v20 = a;
  do
  {
    if (is_mul_ok(v20, v20))
    {
      v20 *= v20;
      if (v12)
      {
        char v26 = 0;
        goto LABEL_29;
      }
      int v21 = v28;
    }
    else
    {
      if (v12)
      {
        if (!BN_set_word(v17, v20)) {
          goto LABEL_67;
        }
        uint64_t v19 = mont;
        if (!BN_to_montgomery(v17, v17, (uint64_t)mont, ctx)) {
          goto LABEL_66;
        }
        int v21 = v28;
      }
      else
      {
        if (!BN_mul_word(v17, v20) || !BN_mod_ct(v28, v17, m, ctx)) {
          goto LABEL_67;
        }
        int v21 = v17;
        uint64_t v17 = v28;
      }
      unint64_t v20 = 1;
    }
    int v12 = 0;
    if (!BN_mod_mul_montgomery(v17, v17, v17, mont, ctx)) {
      goto LABEL_68;
    }
    char v26 = 1;
    uint64_t v28 = v21;
LABEL_29:
    uint64_t v22 = v17;
    if (BN_is_bit_set(p, --v29))
    {
      if (is_mul_ok(a, v20))
      {
        v20 *= a;
      }
      else if (v26)
      {
        if (!BN_mul_word(v17, v20)) {
          goto LABEL_67;
        }
        uint64_t v17 = v28;
        int v23 = BN_mod_ct(v28, v22, m, ctx);
        int v12 = 0;
        unint64_t v20 = a;
        uint64_t v28 = (BIGNUM *)v22;
        if (!v23) {
          goto LABEL_68;
        }
      }
      else
      {
        if (!BN_set_word(v17, v20)) {
          goto LABEL_67;
        }
        int v12 = 0;
        unint64_t v20 = a;
        if (!BN_to_montgomery(v17, v17, (uint64_t)mont, ctx)) {
          goto LABEL_68;
        }
      }
    }
  }
  while (v29 > 0);
  if (v20 != 1)
  {
    if (v12)
    {
      EVP_CIPHER_CTX a = v20;
      uint64_t v19 = mont;
      goto LABEL_60;
    }
    if (!BN_mul_word(v17, v20))
    {
LABEL_67:
      int v12 = 0;
LABEL_68:
      uint64_t v19 = mont;
      goto LABEL_69;
    }
    int v25 = BN_mod_ct(v28, v17, m, ctx);
    uint64_t v17 = v28;
    uint64_t v19 = mont;
    if (v25) {
      goto LABEL_62;
    }
    goto LABEL_66;
  }
  uint64_t v19 = mont;
  if (v12) {
    goto LABEL_48;
  }
LABEL_62:
  if (!BN_from_montgomery(r, v17, v19, ctx)) {
    goto LABEL_66;
  }
LABEL_63:
  int v12 = 1;
LABEL_69:
  if (!m_ctx)
  {
    if (v19) {
      BN_MONT_CTX_free(v19);
    }
  }
LABEL_54:
  BN_CTX_end(ctx);
  return v12;
}

int BN_mod_exp_recp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  if (BN_get_flags((uint64_t)p, 4u))
  {
    ERR_put_error(3, 4095, 66, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_exp.c", 964);
    LODWORD(v10) = -1;
    return (int)v10;
  }
  int v11 = BN_num_bits(p);
  if (v11)
  {
    int v12 = v11;
    memset(&v30, 0, sizeof(v30));
    BN_RECP_CTX_init(&v30);
    BN_CTX_start(ctx);
    uint64_t v10 = BN_CTX_get(ctx);
    if (!v10)
    {
LABEL_58:
      BN_CTX_end(ctx);
      BN_RECP_CTX_free(&v30);
      return (int)v10;
    }
    uint64_t v13 = BN_CTX_get(ctx);
    int v31 = v13;
    if (v13)
    {
      int v14 = v13;
      if (m->neg)
      {
        if (!bn_copy(v10, m)) {
          goto LABEL_57;
        }
        v10->int neg = 0;
        int v15 = v10;
      }
      else
      {
        int v15 = m;
      }
      if (BN_RECP_CTX_set(&v30, v15, ctx) >= 1 && BN_nnmod(v14, a, m, ctx))
      {
        if (BN_is_zero((uint64_t)v14))
        {
          BN_zero((uint64_t)r);
LABEL_19:
          LODWORD(v10) = 1;
          goto LABEL_58;
        }
        uint64_t v47 = 0;
        long long v45 = 0u;
        long long v46 = 0u;
        long long v43 = 0u;
        long long v44 = 0u;
        long long v41 = 0u;
        long long v42 = 0u;
        long long v39 = 0u;
        long long v40 = 0u;
        long long v37 = 0u;
        long long v38 = 0u;
        long long v35 = 0u;
        long long v36 = 0u;
        long long v33 = 0u;
        long long v34 = 0u;
        long long v32 = 0u;
        if (v12 > 671)
        {
          unsigned int v17 = 6;
          goto LABEL_28;
        }
        if (v12 > 239)
        {
          unsigned int v17 = 5;
          goto LABEL_28;
        }
        if (v12 > 79)
        {
          unsigned int v17 = 4;
          goto LABEL_28;
        }
        if (v12 >= 24)
        {
          unsigned int v17 = 3;
LABEL_28:
          if (BN_mod_mul_reciprocal(v10, v14, v14, &v30, ctx))
          {
            uint64_t v18 = 0;
            while (1)
            {
              uint64_t v19 = BN_CTX_get(ctx);
              *(&v31 + v18 + 1) = v19;
              if (!v19 || !BN_mod_mul_reciprocal(v19, *(&v31 + v18), v10, &v30, ctx)) {
                break;
              }
              if ((v18++ + 2) >> (v17 - 1)) {
                goto LABEL_35;
              }
            }
          }
          goto LABEL_57;
        }
        unsigned int v17 = 1;
LABEL_35:
        if (BN_one((uint64_t)r))
        {
          LOBYTE(v10) = 0;
          int v21 = v12 - 1;
          char v22 = 1;
          while (1)
          {
            while (!BN_is_bit_set(p, v21))
            {
              if ((v10 & 1) != 0 && !BN_mod_mul_reciprocal(r, r, r, &v30, ctx)) {
                goto LABEL_57;
              }
              if (!v21) {
                goto LABEL_19;
              }
              --v21;
            }
            if (v17 < 2)
            {
              int v23 = 0;
              int v25 = 1;
            }
            else
            {
              int v23 = 0;
              int v24 = v21 - 1;
              int v25 = 1;
              for (int i = 1; i != v17; ++i)
              {
                if (v24 < 0) {
                  break;
                }
                is_bit_int set = BN_is_bit_set(p, v24);
                int v28 = (v25 << (i - v23)) | 1;
                if (is_bit_set)
                {
                  int v23 = i;
                  int v25 = v28;
                }
                --v24;
              }
            }
            if (!(v22 & 1 | (v23 < 0))) {
              break;
            }
LABEL_54:
            if (!BN_mod_mul_reciprocal(r, r, *(&v31 + (v25 >> 1)), &v30, ctx)) {
              goto LABEL_57;
            }
            char v22 = 0;
            LODWORD(v10) = 1;
            v21 += ~v23;
            if (v21 < 0) {
              goto LABEL_58;
            }
          }
          int v29 = v23 + 1;
          while (BN_mod_mul_reciprocal(r, r, r, &v30, ctx))
          {
            if (!--v29) {
              goto LABEL_54;
            }
          }
        }
      }
    }
LABEL_57:
    LODWORD(v10) = 0;
    goto LABEL_58;
  }
  if (BN_abs_is_word((uint64_t)m, 1))
  {
    BN_zero((uint64_t)r);
    LODWORD(v10) = 1;
    return (int)v10;
  }
  return BN_one((uint64_t)r);
}

int BN_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx)
{
  BOOL v10 = BN_get_flags((uint64_t)p, 4u) != 0;
  return BN_mod_exp_internal(r, a, p, m, ctx, v10);
}

uint64_t BN_mod_exp_internal(BIGNUM *a1, const BIGNUM *a2, const BIGNUM *a3, const BIGNUM *a4, BN_CTX *a5, int a6)
{
  if (BN_is_odd((uint64_t)a4))
  {
    if (a2->top == 1 && !(a2->neg | a6))
    {
      unint64_t v13 = *a2->d;
      return BN_mod_exp_mont_word(a1, v13, a3, a4, a5, 0);
    }
    else
    {
      return BN_mod_exp_mont_consttime(a1, a2, a3, a4, a5, 0);
    }
  }
  else
  {
    return BN_mod_exp_recp(a1, a2, a3, a4, a5);
  }
}

uint64_t BN_mod_exp_ct(BIGNUM *a1, const BIGNUM *a2, const BIGNUM *a3, const BIGNUM *a4, BN_CTX *a5)
{
  return BN_mod_exp_internal(a1, a2, a3, a4, a5, 1);
}

uint64_t BN_mod_exp_nonct(BIGNUM *a1, const BIGNUM *a2, const BIGNUM *a3, const BIGNUM *a4, BN_CTX *a5)
{
  return BN_mod_exp_internal(a1, a2, a3, a4, a5, 0);
}

int BN_mod_exp2_mont(BIGNUM *r, const BIGNUM *a1, const BIGNUM *p1, const BIGNUM *a2, const BIGNUM *p2, const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx)
{
  uint64_t v104 = *MEMORY[0x263EF8340];
  if (!BN_is_odd((uint64_t)m))
  {
    ERR_put_error(3, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_exp.c", 1172);
    return 0;
  }
  int v16 = BN_num_bits(p1);
  int v17 = BN_num_bits(p2);
  if (v16 | v17)
  {
    int v20 = v17;
    if (v16 <= v17) {
      int v21 = v17;
    }
    else {
      int v21 = v16;
    }
    int v67 = v21;
    BN_CTX_start(ctx);
    char v22 = BN_CTX_get(ctx);
    if (v22)
    {
      rEVP_CIPHER_CTX a = v22;
      int v23 = BN_CTX_get(ctx);
      if (v23)
      {
        int v62 = v23;
        unint64_t v64 = m_ctx;
        int v24 = BN_CTX_get(ctx);
        unsigned int v87 = v24;
        if (v24)
        {
          int v25 = v24;
          char v26 = BN_CTX_get(ctx);
          int v70 = v26;
          if (v26)
          {
            BIGNUM b = v26;
            uint64_t v27 = v64;
            if (v64) {
              goto LABEL_15;
            }
            int v29 = BN_MONT_CTX_new();
            if (v29)
            {
              mont = v29;
              if (!BN_MONT_CTX_set(v29, m, ctx)) {
                goto LABEL_98;
              }
              uint64_t v27 = mont;
LABEL_15:
              if (v16 <= 671)
              {
                if (v16 <= 239)
                {
                  if (v16 <= 79)
                  {
                    if (v16 <= 23) {
                      unsigned int v28 = 1;
                    }
                    else {
                      unsigned int v28 = 3;
                    }
                  }
                  else
                  {
                    unsigned int v28 = 4;
                  }
                }
                else
                {
                  unsigned int v28 = 5;
                }
              }
              else
              {
                unsigned int v28 = 6;
              }
              mont = v27;
              if (v20 <= 671)
              {
                if (v20 <= 239)
                {
                  if (v20 <= 79)
                  {
                    if (v20 <= 23) {
                      unsigned int v30 = 1;
                    }
                    else {
                      unsigned int v30 = 3;
                    }
                  }
                  else
                  {
                    unsigned int v30 = 4;
                  }
                }
                else
                {
                  unsigned int v30 = 5;
                }
              }
              else
              {
                unsigned int v30 = 6;
              }
              if (BN_nnmod(v25, a1, m, ctx))
              {
                if (BN_is_zero((uint64_t)v25))
                {
                  BN_zero((uint64_t)r);
                  int v19 = 1;
                  goto LABEL_99;
                }
                if (BN_to_montgomery(v25, v25, (uint64_t)mont, ctx))
                {
                  uint64_t v103 = 0;
                  long long v101 = 0u;
                  long long v102 = 0u;
                  long long v99 = 0u;
                  long long v100 = 0u;
                  long long v97 = 0u;
                  long long v98 = 0u;
                  long long v95 = 0u;
                  long long v96 = 0u;
                  long long v93 = 0u;
                  long long v94 = 0u;
                  long long v91 = 0u;
                  long long v92 = 0u;
                  long long v89 = 0u;
                  long long v90 = 0u;
                  long long v88 = 0u;
                  unsigned int v56 = v28;
                  if (v28 >= 2)
                  {
                    if (BN_mod_mul_montgomery(ra, v25, v25, mont, ctx))
                    {
                      uint64_t v31 = 0;
                      while (1)
                      {
                        long long v32 = BN_CTX_get(ctx);
                        *(&v87 + v31 + 1) = v32;
                        if (!v32 || !BN_mod_mul_montgomery(v32, *(&v87 + v31), ra, mont, ctx)) {
                          break;
                        }
                        if ((v31++ + 2) >> (v28 - 1)) {
                          goto LABEL_49;
                        }
                      }
                    }
                    goto LABEL_98;
                  }
LABEL_49:
                  if (!BN_nnmod(b, a2, m, ctx)) {
                    goto LABEL_102;
                  }
                  if (BN_is_zero((uint64_t)b))
                  {
                    BN_zero((uint64_t)r);
                    int v19 = 1;
                    goto LABEL_103;
                  }
                  if (!BN_to_montgomery(b, b, (uint64_t)mont, ctx))
                  {
LABEL_102:
                    int v19 = 0;
LABEL_103:
                    long long v53 = mont;
                    if (!v64)
                    {
LABEL_100:
                      if (v53) {
                        BN_MONT_CTX_free(v53);
                      }
                    }
LABEL_23:
                    BN_CTX_end(ctx);
                    return v19;
                  }
                  uint64_t v86 = 0;
                  long long v84 = 0u;
                  long long v85 = 0u;
                  long long v82 = 0u;
                  long long v83 = 0u;
                  long long v80 = 0u;
                  long long v81 = 0u;
                  long long v78 = 0u;
                  long long v79 = 0u;
                  long long v76 = 0u;
                  long long v77 = 0u;
                  long long v74 = 0u;
                  long long v75 = 0u;
                  long long v72 = 0u;
                  long long v73 = 0u;
                  long long v71 = 0u;
                  if (v30 >= 2)
                  {
                    if (BN_mod_mul_montgomery(ra, b, b, mont, ctx))
                    {
                      uint64_t v34 = 0;
                      while (1)
                      {
                        long long v35 = BN_CTX_get(ctx);
                        *(&v70 + v34 + 1) = v35;
                        if (!v35 || !BN_mod_mul_montgomery(v35, *(&v70 + v34), ra, mont, ctx)) {
                          break;
                        }
                        if ((v34++ + 2) >> (v30 - 1)) {
                          goto LABEL_59;
                        }
                      }
                    }
                    goto LABEL_98;
                  }
LABEL_59:
                  long long v37 = BN_value_one();
                  if (BN_to_montgomery(v62, v37, (uint64_t)mont, ctx))
                  {
                    int v38 = v67;
                    if (v67 < 1)
                    {
LABEL_96:
                      long long v53 = mont;
                      int v19 = BN_from_montgomery(r, v62, mont, ctx) != 0;
                      if (!v64) {
                        goto LABEL_100;
                      }
                      goto LABEL_23;
                    }
                    int v39 = 0;
                    int v19 = 0;
                    int v54 = 0;
                    int v55 = 0;
                    int v40 = v67 - v56;
                    int v41 = v67 - v30;
                    rBIGNUM b = 1;
                    while (1)
                    {
                      int v42 = v38;
                      if (!rb && !BN_mod_mul_montgomery(v62, v62, v62, mont, ctx)) {
                        break;
                      }
                      --v38;
                      if (v19)
                      {
                        if (v39) {
                          goto LABEL_66;
                        }
                      }
                      else if (BN_is_bit_set(p1, v42 - 1))
                      {
                        int v68 = v38;
                        bEVP_CIPHER_CTX a = v40;
                        int v44 = v40;
                        while (!BN_is_bit_set(p1, v44++))
                          ;
                        int v57 = v42;
                        int v46 = v42 - 2;
                        int v47 = v44 - 2;
                        int v55 = v44 - 1;
                        int v19 = 1;
                        if (v46 <= v44 - 2)
                        {
                          int v38 = v68;
                        }
                        else
                        {
                          int v38 = v68;
                          do
                            int v19 = (BN_is_bit_set(p1, v46--) != 0) | (2 * v19);
                          while (v46 > v47);
                        }
                        int v42 = v57;
                        int v40 = ba;
                        if (v39)
                        {
LABEL_66:
                          if (!v19) {
                            goto LABEL_92;
                          }
                          goto LABEL_67;
                        }
                      }
                      else
                      {
                        int v19 = 0;
                        if (v39) {
                          goto LABEL_66;
                        }
                      }
                      if (BN_is_bit_set(p2, v38))
                      {
                        bBIGNUM b = v40;
                        int v69 = v38;
                        int v48 = v41;
                        while (!BN_is_bit_set(p2, v48++))
                          ;
                        int v58 = v42;
                        int v50 = v42 - 2;
                        int v51 = v48 - 2;
                        int v54 = v48 - 1;
                        int v39 = 1;
                        if (v50 <= v48 - 2)
                        {
                          int v38 = v69;
                        }
                        else
                        {
                          int v38 = v69;
                          do
                            int v39 = (BN_is_bit_set(p2, v50--) != 0) | (2 * v39);
                          while (v50 > v51);
                        }
                        int v42 = v58;
                        int v40 = bb;
                        if (!v19) {
                          goto LABEL_92;
                        }
                      }
                      else
                      {
                        int v39 = 0;
                        if (!v19) {
                          goto LABEL_92;
                        }
                      }
LABEL_67:
                      if (v38 == v55)
                      {
                        int v43 = BN_mod_mul_montgomery(v62, v62, *(&v87 + (v19 >> 1)), mont, ctx);
                        int v19 = 0;
                        rBIGNUM b = 0;
                        if (!v43) {
                          goto LABEL_99;
                        }
                      }
LABEL_92:
                      if (v39)
                      {
                        if (v38 == v54)
                        {
                          int v52 = BN_mod_mul_montgomery(v62, v62, *(&v70 + (v39 >> 1)), mont, ctx);
                          int v39 = 0;
                          rBIGNUM b = 0;
                          if (!v52)
                          {
                            int v19 = 0;
                            goto LABEL_99;
                          }
                        }
                      }
                      --v40;
                      --v41;
                      if (v42 <= 1) {
                        goto LABEL_96;
                      }
                    }
                  }
                }
              }
LABEL_98:
              int v19 = 0;
LABEL_99:
              long long v53 = mont;
              if (!v64) {
                goto LABEL_100;
              }
              goto LABEL_23;
            }
          }
        }
      }
    }
    int v19 = 0;
    goto LABEL_23;
  }
  return BN_one((uint64_t)r);
}

int BIO_printf(BIO *bio, const char *format, ...)
{
  va_start(va, format);
  return BIO_vprintf(bio, format, va);
}

int BIO_vprintf(BIO *bio, const char *format, va_list args)
{
  int v6 = 0;
  int v4 = vasprintf(&v6, format, args);
  if (v4 != -1)
  {
    BIO_write(bio, v6, v4);
    free(v6);
  }
  return v4;
}

int BIO_snprintf(char *buf, size_t n, const char *format, ...)
{
  va_start(va, format);
  int result = vsnprintf(buf, n, format, va);
  if (result >= n || result == -1) {
    return -1;
  }
  return result;
}

int BIO_vsnprintf(char *buf, size_t n, const char *format, va_list args)
{
  int result = vsnprintf(buf, n, format, args);
  if (result >= n || result == -1) {
    return -1;
  }
  return result;
}

uint64_t CMS_stream(unsigned __int8 ***a1, uint64_t a2)
{
  uint64_t result = (uint64_t)CMS_get0_content(a2);
  if (result)
  {
    int v4 = (void *)result;
    unint64_t v5 = *(ASN1_OCTET_STRING **)result;
    if (v5 || (unint64_t v5 = ASN1_OCTET_STRING_new(), (*v4 = v5) != 0))
    {
      v5->flags = v5->flags & 0xFFFFFFFFFFFFFFCFLL | 0x10;
      *a1 = &v5->data;
      return 1;
    }
    else
    {
      ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_io.c", 75);
      return 0;
    }
  }
  return result;
}

void *d2i_CMS_bio(BIO *in, void *x)
{
  return ASN1_item_d2i_bio(&CMS_ContentInfo_it, in, x);
}

uint64_t i2d_CMS_bio(BIO *out, void *x)
{
  return ASN1_item_i2d_bio(&CMS_ContentInfo_it, out, x);
}

void *PEM_read_bio_CMS(BIO *bp, void **x, pem_password_cb *cb, void *u)
{
  return PEM_ASN1_read_bio((d2i_of_void *)d2i_CMS_ContentInfo, "CMS", bp, x, cb, u);
}

void *PEM_read_CMS(FILE *fp, void **x, pem_password_cb *cb, void *u)
{
  return PEM_ASN1_read((d2i_of_void *)d2i_CMS_ContentInfo, "CMS", fp, x, cb, u);
}

uint64_t PEM_write_bio_CMS(BIO *bp, char *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_CMS_ContentInfo, "CMS", bp, x, 0, 0, 0, 0, 0);
}

uint64_t PEM_write_CMS(FILE *fp, char *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_CMS_ContentInfo, "CMS", fp, x, 0, 0, 0, 0, 0);
}

uint64_t BIO_new_CMS(BIO *a1, uint64_t a2)
{
  return BIO_new_NDEF(a1, a2, (uint64_t)&CMS_ContentInfo_it);
}

uint64_t i2d_CMS_bio_stream(BIO *a1, void *a2, BIO *a3, int a4)
{
  return i2d_ASN1_bio_stream(a1, a2, a3, a4, &CMS_ContentInfo_it);
}

uint64_t PEM_write_bio_CMS_stream(BIO *a1, void *a2, BIO *a3, int a4)
{
  return PEM_write_bio_ASN1_stream(a1, a2, a3, a4, "CMS", &CMS_ContentInfo_it);
}

uint64_t SMIME_write_CMS(BIO *a1, uint64_t a2, BIO *a3, int a4)
{
  int v8 = OBJ_obj2nid(*(const ASN1_OBJECT **)a2);
  unint64_t v9 = (const ASN1_OBJECT *)CMS_get0_eContentType(a2);
  int v10 = OBJ_obj2nid(v9);
  if (v8 == 22) {
    int v11 = *(STACK **)(*(void *)(a2 + 8) + 8);
  }
  else {
    int v11 = 0;
  }
  return SMIME_write_ASN1(a1, (void *)a2, a3, a4, v8, v10, v11, &CMS_ContentInfo_it);
}

ASN1_VALUE *SMIME_read_CMS(BIO *a1, BIO **a2)
{
  return SMIME_read_ASN1(a1, a2, &CMS_ContentInfo_it);
}

OCSP_SIGNATURE *__cdecl d2i_OCSP_SIGNATURE(OCSP_SIGNATURE **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_SIGNATURE *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_SIGNATURE_it);
}

int i2d_OCSP_SIGNATURE(OCSP_SIGNATURE *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_SIGNATURE_it);
}

OCSP_SIGNATURE *OCSP_SIGNATURE_new(void)
{
  return (OCSP_SIGNATURE *)ASN1_item_new(&OCSP_SIGNATURE_it);
}

void OCSP_SIGNATURE_free(OCSP_SIGNATURE *a)
{
}

OCSP_CERTID *__cdecl d2i_OCSP_CERTID(OCSP_CERTID **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_CERTID *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_CERTID_it);
}

int i2d_OCSP_CERTID(OCSP_CERTID *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_CERTID_it);
}

OCSP_CERTID *OCSP_CERTID_new(void)
{
  return (OCSP_CERTID *)ASN1_item_new(&OCSP_CERTID_it);
}

void OCSP_CERTID_free(OCSP_CERTID *a)
{
}

OCSP_ONEREQ *__cdecl d2i_OCSP_ONEREQ(OCSP_ONEREQ **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_ONEREQ *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_ONEREQ_it);
}

int i2d_OCSP_ONEREQ(OCSP_ONEREQ *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_ONEREQ_it);
}

OCSP_ONEREQ *OCSP_ONEREQ_new(void)
{
  return (OCSP_ONEREQ *)ASN1_item_new(&OCSP_ONEREQ_it);
}

void OCSP_ONEREQ_free(OCSP_ONEREQ *a)
{
}

OCSP_REQINFO *__cdecl d2i_OCSP_REQINFO(OCSP_REQINFO **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_REQINFO *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_REQINFO_it);
}

int i2d_OCSP_REQINFO(OCSP_REQINFO *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_REQINFO_it);
}

OCSP_REQINFO *OCSP_REQINFO_new(void)
{
  return (OCSP_REQINFO *)ASN1_item_new(&OCSP_REQINFO_it);
}

void OCSP_REQINFO_free(OCSP_REQINFO *a)
{
}

OCSP_REQUEST *__cdecl d2i_OCSP_REQUEST(OCSP_REQUEST **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_REQUEST *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_REQUEST_it);
}

int i2d_OCSP_REQUEST(OCSP_REQUEST *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_REQUEST_it);
}

void *d2i_OCSP_REQUEST_bio(BIO *in, void *x)
{
  return ASN1_item_d2i_bio(&OCSP_REQUEST_it, in, x);
}

uint64_t i2d_OCSP_REQUEST_bio(BIO *out, void *x)
{
  return ASN1_item_i2d_bio(&OCSP_REQUEST_it, out, x);
}

OCSP_REQUEST *OCSP_REQUEST_new(void)
{
  return (OCSP_REQUEST *)ASN1_item_new(&OCSP_REQUEST_it);
}

void OCSP_REQUEST_free(OCSP_REQUEST *a)
{
}

OCSP_RESPBYTES *__cdecl d2i_OCSP_RESPBYTES(OCSP_RESPBYTES **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_RESPBYTES *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_RESPBYTES_it);
}

int i2d_OCSP_RESPBYTES(OCSP_RESPBYTES *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_RESPBYTES_it);
}

OCSP_RESPBYTES *OCSP_RESPBYTES_new(void)
{
  return (OCSP_RESPBYTES *)ASN1_item_new(&OCSP_RESPBYTES_it);
}

void OCSP_RESPBYTES_free(OCSP_RESPBYTES *a)
{
}

OCSP_RESPONSE *__cdecl d2i_OCSP_RESPONSE(OCSP_RESPONSE **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_RESPONSE *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_RESPONSE_it);
}

int i2d_OCSP_RESPONSE(OCSP_RESPONSE *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_RESPONSE_it);
}

void *d2i_OCSP_RESPONSE_bio(BIO *in, void *x)
{
  return ASN1_item_d2i_bio(&OCSP_RESPONSE_it, in, x);
}

uint64_t i2d_OCSP_RESPONSE_bio(BIO *out, void *x)
{
  return ASN1_item_i2d_bio(&OCSP_RESPONSE_it, out, x);
}

OCSP_RESPONSE *OCSP_RESPONSE_new(void)
{
  return (OCSP_RESPONSE *)ASN1_item_new(&OCSP_RESPONSE_it);
}

void OCSP_RESPONSE_free(OCSP_RESPONSE *a)
{
}

OCSP_RESPID *__cdecl d2i_OCSP_RESPID(OCSP_RESPID **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_RESPID *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_RESPID_it);
}

int i2d_OCSP_RESPID(OCSP_RESPID *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_RESPID_it);
}

OCSP_RESPID *OCSP_RESPID_new(void)
{
  return (OCSP_RESPID *)ASN1_item_new(&OCSP_RESPID_it);
}

void OCSP_RESPID_free(OCSP_RESPID *a)
{
}

OCSP_REVOKEDINFO *__cdecl d2i_OCSP_REVOKEDINFO(OCSP_REVOKEDINFO **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_REVOKEDINFO *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_REVOKEDINFO_it);
}

int i2d_OCSP_REVOKEDINFO(OCSP_REVOKEDINFO *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_REVOKEDINFO_it);
}

OCSP_REVOKEDINFO *OCSP_REVOKEDINFO_new(void)
{
  return (OCSP_REVOKEDINFO *)ASN1_item_new(&OCSP_REVOKEDINFO_it);
}

void OCSP_REVOKEDINFO_free(OCSP_REVOKEDINFO *a)
{
}

OCSP_CERTSTATUS *__cdecl d2i_OCSP_CERTSTATUS(OCSP_CERTSTATUS **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_CERTSTATUS *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_CERTSTATUS_it);
}

int i2d_OCSP_CERTSTATUS(OCSP_CERTSTATUS *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_CERTSTATUS_it);
}

OCSP_CERTSTATUS *OCSP_CERTSTATUS_new(void)
{
  return (OCSP_CERTSTATUS *)ASN1_item_new(&OCSP_CERTSTATUS_it);
}

void OCSP_CERTSTATUS_free(OCSP_CERTSTATUS *a)
{
}

OCSP_SINGLERESP *__cdecl d2i_OCSP_SINGLERESP(OCSP_SINGLERESP **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_SINGLERESP *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_SINGLERESP_it);
}

int i2d_OCSP_SINGLERESP(OCSP_SINGLERESP *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_SINGLERESP_it);
}

OCSP_SINGLERESP *OCSP_SINGLERESP_new(void)
{
  return (OCSP_SINGLERESP *)ASN1_item_new(&OCSP_SINGLERESP_it);
}

void OCSP_SINGLERESP_free(OCSP_SINGLERESP *a)
{
}

OCSP_RESPDATA *__cdecl d2i_OCSP_RESPDATA(OCSP_RESPDATA **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_RESPDATA *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_RESPDATA_it);
}

int i2d_OCSP_RESPDATA(OCSP_RESPDATA *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_RESPDATA_it);
}

OCSP_RESPDATA *OCSP_RESPDATA_new(void)
{
  return (OCSP_RESPDATA *)ASN1_item_new(&OCSP_RESPDATA_it);
}

void OCSP_RESPDATA_free(OCSP_RESPDATA *a)
{
}

OCSP_BASICRESP *__cdecl d2i_OCSP_BASICRESP(OCSP_BASICRESP **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_BASICRESP *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_BASICRESP_it);
}

int i2d_OCSP_BASICRESP(OCSP_BASICRESP *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_BASICRESP_it);
}

OCSP_BASICRESP *OCSP_BASICRESP_new(void)
{
  return (OCSP_BASICRESP *)ASN1_item_new(&OCSP_BASICRESP_it);
}

void OCSP_BASICRESP_free(OCSP_BASICRESP *a)
{
}

OCSP_CRLID *__cdecl d2i_OCSP_CRLID(OCSP_CRLID **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_CRLID *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_CRLID_it);
}

int i2d_OCSP_CRLID(OCSP_CRLID *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_CRLID_it);
}

OCSP_CRLID *OCSP_CRLID_new(void)
{
  return (OCSP_CRLID *)ASN1_item_new(&OCSP_CRLID_it);
}

void OCSP_CRLID_free(OCSP_CRLID *a)
{
}

OCSP_SERVICELOC *__cdecl d2i_OCSP_SERVICELOC(OCSP_SERVICELOC **a, const unsigned __int8 **in, uint64_t len)
{
  return (OCSP_SERVICELOC *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OCSP_SERVICELOC_it);
}

int i2d_OCSP_SERVICELOC(OCSP_SERVICELOC *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OCSP_SERVICELOC_it);
}

OCSP_SERVICELOC *OCSP_SERVICELOC_new(void)
{
  return (OCSP_SERVICELOC *)ASN1_item_new(&OCSP_SERVICELOC_it);
}

void OCSP_SERVICELOC_free(OCSP_SERVICELOC *a)
{
}

uint64_t i2d_ASN1_bio_stream(BIO *out, void *x, BIO *a3, int a4, ASN1_ITEM *it)
{
  if ((a4 & 0x1000) == 0)
  {
    ASN1_item_i2d_bio(it, out, x);
    return 1;
  }
  int v8 = (BIO *)BIO_new_NDEF(out, (uint64_t)x, (uint64_t)it);
  if (v8)
  {
    unint64_t v9 = v8;
    SMIME_crlf_copy(a3, v8, a4);
    BIO_ctrl(v9, 11, 0, 0);
    do
    {
      int v10 = BIO_pop(v9);
      BIO_free(v9);
      unint64_t v9 = v10;
    }
    while (v10 != out);
    return 1;
  }
  ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", 126);
  return 0;
}

int SMIME_crlf_copy(BIO *in, BIO *out, int flags)
{
  char v3 = flags;
  uint64_t v21 = *MEMORY[0x263EF8340];
  int v6 = BIO_f_buffer();
  int v7 = BIO_new(v6);
  if (v7)
  {
    int v8 = v7;
    unint64_t v9 = BIO_push(v7, out);
    int v10 = v9;
    if (v3 < 0)
    {
      int v17 = BIO_read(in, buf, 1024);
      if (v17 >= 1)
      {
        for (int i = v17; i > 0; int i = BIO_read(in, buf, 1024))
          BIO_write(v10, buf, i);
      }
      goto LABEL_23;
    }
    if (v3) {
      BIO_printf(v9, "Content-Type: text/plain\r\n\r\n");
    }
    int v11 = BIO_gets(in, buf, 1024);
    if (v11 < 1) {
      goto LABEL_23;
    }
    int v12 = v11;
    while (1)
    {
      int v13 = 0;
      uint64_t v14 = v12 - 1;
      while (1)
      {
        int v15 = buf[v14];
        if (v15 == 10)
        {
          int v13 = 1;
          goto LABEL_12;
        }
        if (v15 != 13) {
          break;
        }
LABEL_12:
        --v14;
        BOOL v16 = __OFSUB__(v12--, 1);
        if ((v12 < 0) ^ v16 | (v12 == 0))
        {
          if (!v13) {
            goto LABEL_16;
          }
          goto LABEL_15;
        }
      }
      BIO_write(v10, buf, v12);
      if (v13) {
LABEL_15:
      }
        BIO_write(v10, "\r\n", 2);
LABEL_16:
      int v12 = BIO_gets(in, buf, 1024);
      if (v12 <= 0)
      {
LABEL_23:
        BIO_ctrl(v10, 11, 0, 0);
        BIO_pop(v10);
        BIO_free(v8);
        LODWORD(v7) = 1;
        return (int)v7;
      }
    }
  }
  return (int)v7;
}

uint64_t PEM_write_bio_ASN1_stream(BIO *a1, void *a2, BIO *a3, int a4, const char *a5, ASN1_ITEM *a6)
{
  BIO_printf(a1, "-----BEGIN %s-----\n", a5);
  uint64_t v12 = B64_write_ASN1(a1, a2, a3, a4, a6);
  BIO_printf(a1, "-----END %s-----\n", a5);
  return v12;
}

uint64_t B64_write_ASN1(BIO *a1, void *a2, BIO *a3, int a4, ASN1_ITEM *a5)
{
  int v10 = BIO_f_base64();
  int v11 = BIO_new(v10);
  if (v11)
  {
    uint64_t v12 = v11;
    int v13 = BIO_push(v11, a1);
    uint64_t v14 = i2d_ASN1_bio_stream(v13, a2, a3, a4, a5);
    BIO_ctrl(v13, 11, 0, 0);
    BIO_pop(v13);
    BIO_free(v12);
    return v14;
  }
  else
  {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", 157);
    return 0;
  }
}

uint64_t SMIME_write_ASN1(BIO *bio, void *a2, BIO *a3, int a4, int a5, int a6, STACK *a7, ASN1_ITEM *a8)
{
  uint64_t v49 = *MEMORY[0x263EF8340];
  if ((a4 & 0x400) != 0) {
    uint64_t v14 = "application/x-pkcs7-";
  }
  else {
    uint64_t v14 = "application/pkcs7-";
  }
  if ((a4 & 0x800) != 0) {
    int v15 = "\r\n";
  }
  else {
    int v15 = "\n";
  }
  if (a3 && (a4 & 0x40) != 0)
  {
    arc4random_buf(__buf, 0x20uLL);
    uint64_t v16 = 0;
    v17.i64[0] = 0xF0F0F0F0F0F0F0FLL;
    v17.i64[1] = 0xF0F0F0F0F0F0F0FLL;
    v18.i64[0] = 0xA0A0A0A0A0A0A0ALL;
    v18.i64[1] = 0xA0A0A0A0A0A0A0ALL;
    v19.i64[0] = 0x3030303030303030;
    v19.i64[1] = 0x3030303030303030;
    v20.i64[0] = 0x3737373737373737;
    v20.i64[1] = 0x3737373737373737;
    do
    {
      int8x16_t v21 = vandq_s8(*(int8x16_t *)&__buf[v16], v17);
      *(int8x16_t *)&__buf[v16] = vbslq_s8((int8x16_t)vcgtq_u8(v18, (uint8x16_t)v21), vorrq_s8(v21, v19), vaddq_s8(v21, v20));
      v16 += 16;
    }
    while (v16 != 32);
    __buf[32] = 0;
    BIO_printf(bio, "MIME-Version: 1.0%s", v15);
    BIO_printf(bio, "Content-Type: multipart/signed;");
    BIO_printf(bio, " protocol=\"%ssignature\";", v14);
    BIO_puts(bio, " micalg=\"");
    if (sk_num(a7) >= 1)
    {
      int v22 = 0;
      int v23 = 0;
      for (int i = 0; i < sk_num(a7); ++i)
      {
        if (v22) {
          BIO_write(bio, ",", 1);
        }
        int v25 = sk_value(a7, i);
        int v26 = OBJ_obj2nid(*(const ASN1_OBJECT **)v25);
        uint64_t v27 = OBJ_nid2sn(v26);
        digestbyname = EVP_get_digestbyname(v27);
        if (digestbyname)
        {
          verify = digestbyname->verify;
          if (verify)
          {
            buf = 0;
            int v30 = ((uint64_t (*)(void, uint64_t, void, char **))verify)(0, 2, 0, &buf);
            if (v30 > 0)
            {
              BIO_puts(bio, buf);
              free(buf);
              goto LABEL_32;
            }
            if (v30 != -2) {
              break;
            }
          }
        }
        if (v26 > 672)
        {
          switch(v26)
          {
            case 673:
              uint64_t v31 = bio;
              long long v32 = "sha-384";
              goto LABEL_31;
            case 674:
              uint64_t v31 = bio;
              long long v32 = "sha-512";
              goto LABEL_31;
            case 809:
              BIO_puts(bio, "gostr3411-94");
              goto LABEL_56;
          }
        }
        else
        {
          switch(v26)
          {
            case 4:
              uint64_t v31 = bio;
              long long v32 = "md5";
              goto LABEL_31;
            case 64:
              uint64_t v31 = bio;
              long long v32 = "sha1";
              goto LABEL_31;
            case 672:
              uint64_t v31 = bio;
              long long v32 = "sha-256";
LABEL_31:
              BIO_puts(v31, v32);
              goto LABEL_32;
          }
        }
        if (v23)
        {
          int v22 = 0;
          int v23 = 1;
          continue;
        }
        BIO_puts(bio, "unknown");
        int v23 = 1;
LABEL_32:
        int v22 = 1;
      }
    }
LABEL_56:
    BIO_printf(bio, "\"; boundary=\"----%s\"%s%s", __buf, v15, v15);
    BIO_printf(bio, "This is an S/MIME signed message%s%s", v15, v15);
    BIO_printf(bio, "------%s%s", __buf, v15);
    int v47 = a2;
    if ((a4 & 0x8040) == 0x40)
    {
      long long v37 = a8;
      funcs = a8->funcs;
      if (!funcs || (int v39 = (int (*)(uint64_t, void **, ASN1_ITEM *, char **))funcs[3]) == 0)
      {
        ERR_put_error(13, 4095, 202, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", 391);
        return 0;
      }
      unsigned __int8 out = 0;
      uint64_t v46 = 0;
      buf = (char *)bio;
      if (v39(12, &v47, a8, &buf) < 1) {
        return 0;
      }
      SMIME_crlf_copy(a3, out, a4);
      int v40 = ((uint64_t (*)(uint64_t, void **, ASN1_ITEM *, char **))funcs[3])(13, &v47, a8, &buf);
      for (uint64_t j = out; j != bio; out = j)
      {
        uint64_t j = BIO_pop(j);
        BIO_free(out);
      }
      if (v40 < 1) {
        return 0;
      }
    }
    else
    {
      SMIME_crlf_copy(a3, bio, a4);
      long long v37 = a8;
    }
    BIO_printf(bio, "%s------%s%s", v15, __buf, v15);
    BIO_printf(bio, "Content-Type: %ssignature;", v14);
    BIO_printf(bio, " name=\"smime.p7s\"%s", v15);
    BIO_printf(bio, "Content-Transfer-Encoding: base64%s", v15);
    BIO_printf(bio, "Content-Disposition: attachment;");
    BIO_printf(bio, " filename=\"smime.p7s\"%s%s", v15, v15);
    B64_write_ASN1(bio, a2, 0, 0, v37);
    BIO_printf(bio, "%s------%s--%s%s");
    return 1;
  }
  if (a5 == 786)
  {
    char v33 = 0;
    uint64_t v34 = "compressed-data";
    long long v35 = "smime.p7z";
  }
  else
  {
    if (a5 == 23)
    {
      char v33 = 0;
      uint64_t v34 = "enveloped-data";
    }
    else if (a5 == 22)
    {
      if (a6 == 204)
      {
        char v33 = 0;
        uint64_t v34 = "signed-receipt";
      }
      else
      {
        char v33 = 0;
        if (sk_num(a7) < 0) {
          uint64_t v34 = "certs-only";
        }
        else {
          uint64_t v34 = "signed-data";
        }
      }
    }
    else
    {
      uint64_t v34 = 0;
      char v33 = 1;
    }
    long long v35 = "smime.p7m";
  }
  BIO_printf(bio, "MIME-Version: 1.0%s", v15);
  BIO_printf(bio, "Content-Disposition: attachment;");
  BIO_printf(bio, " filename=\"%s\"%s", v35, v15);
  BIO_printf(bio, "Content-Type: %smime;", v14);
  if ((v33 & 1) == 0) {
    BIO_printf(bio, " smime-type=%s;", v34);
  }
  BIO_printf(bio, " name=\"%s\"%s", v35, v15);
  BIO_printf(bio, "Content-Transfer-Encoding: base64%s%s", v15, v15);
  uint64_t result = B64_write_ASN1(bio, a2, a3, a4, a8);
  if (result)
  {
    BIO_printf(bio, "%s");
    return 1;
  }
  return result;
}

ASN1_VALUE *__cdecl SMIME_read_ASN1(BIO *bio, BIO **bcont, const ASN1_ITEM *it)
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  if (bcont) {
    *bcont = 0;
  }
  int v6 = mime_parse_hdr(bio);
  if (!v6)
  {
    int v13 = 207;
    int v14 = 442;
    goto LABEL_12;
  }
  int v7 = v6;
  int v8 = mime_hdr_find(v6);
  if (!v8 || (unint64_t v9 = v8, (v10 = (const char *)*((void *)v8 + 1)) == 0))
  {
    sk_pop_free(v7, (void (__cdecl *)(void *))mime_hdr_free);
    int v13 = 209;
    int v14 = 448;
LABEL_12:
    ERR_put_error(13, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", v14);
    return 0;
  }
  if (strcmp(*((const char **)v8 + 1), "multipart/signed"))
  {
    if (strcmp(v10, "application/x-pkcs7-mime") && strcmp(v10, "application/pkcs7-mime"))
    {
      ERR_put_error(13, 4095, 205, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", 517);
      ERR_asprintf_error_data("type: %s", *((const char **)v9 + 1));
      int v11 = (void (__cdecl *)(void *))mime_hdr_free;
      uint64_t v12 = v7;
      goto LABEL_59;
    }
    sk_pop_free(v7, (void (__cdecl *)(void *))mime_hdr_free);
    asn1 = (ASN1_VALUE *)b64_read_asn1(bio, it);
    if (!asn1) {
      ERR_put_error(13, 4095, 203, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", 526);
    }
    return asn1;
  }
  *(void *)unsigned int data = "boundary";
  uint64_t v46 = 0;
  int v17 = sk_find(*((STACK **)v9 + 2), data);
  if (v17 < 0
    || (uint8x16_t v18 = sk_value(*((const STACK **)v9 + 2), v17)) == 0
    || (int8x16_t v19 = (const char *)*((void *)v18 + 1)) == 0)
  {
    sk_pop_free(v7, (void (__cdecl *)(void *))mime_hdr_free);
    int v13 = 211;
    int v14 = 459;
    goto LABEL_12;
  }
  __s = (char *)v19;
  int v20 = strlen(v19);
  st = sk_new_null();
  if (!st)
  {
LABEL_55:
    sk_pop_free(v7, (void (__cdecl *)(void *))mime_hdr_free);
LABEL_56:
    int v33 = 210;
    int v34 = 465;
LABEL_57:
    ERR_put_error(13, 4095, v33, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", v34);
    goto LABEL_58;
  }
  int v21 = BIO_gets(bio, data, 1024);
  if (v21 < 1)
  {
    int v23 = 0;
LABEL_54:
    BIO_free(v23);
    goto LABEL_55;
  }
  int v22 = v21;
  uint64_t v44 = 0;
  int v23 = 0;
  int v24 = 1;
  while (1)
  {
    int v25 = v20;
    if (v20 == -1) {
      int v25 = strlen(__s);
    }
    if (v25 + 2 <= v22 && *(unsigned __int16 *)data == 11565)
    {
      uint64_t v26 = v25;
      if (!strncmp(&data[2], __s, v25)) {
        break;
      }
    }
    if (BYTE4(v44))
    {
      int v27 = 0;
      uint64_t v28 = v22 - 1;
      do
      {
        int v29 = data[v28];
        if (v29 == 10)
        {
          int v27 = 1;
        }
        else if (v29 != 13)
        {
          goto LABEL_37;
        }
        --v28;
        BOOL v30 = __OFSUB__(v22--, 1);
      }
      while (!((v22 < 0) ^ v30 | (v22 == 0)));
      int v22 = 0;
LABEL_37:
      if (v24)
      {
        if (v23 && !sk_push(st, (char *)v23)) {
          goto LABEL_55;
        }
        uint64_t v31 = BIO_s_mem();
        long long v32 = BIO_new(v31);
        if (!v32) {
          goto LABEL_55;
        }
        int v23 = v32;
        BIO_ctrl(v32, 130, 0, 0);
      }
      else if (v44)
      {
        BIO_write(v23, "\r\n", 2);
      }
      if (v22) {
        BIO_write(v23, data, v22);
      }
      int v24 = 0;
      LODWORD(v44) = v27;
    }
    else
    {
      HIDWORD(v44) = 0;
    }
LABEL_48:
    int v22 = BIO_gets(bio, data, 1024);
    if (v22 <= 0) {
      goto LABEL_54;
    }
  }
  if (strncmp(&data[v26 + 2], "--", 2uLL))
  {
    ++HIDWORD(v44);
    int v24 = 1;
    goto LABEL_48;
  }
  int v35 = sk_push(st, (char *)v23);
  sk_pop_free(v7, (void (__cdecl *)(void *))mime_hdr_free);
  if (!v35 || sk_num(st) != 2) {
    goto LABEL_56;
  }
  long long v36 = sk_value(st, 1);
  long long v37 = mime_parse_hdr((BIO *)v36);
  if (!v37)
  {
    int v33 = 208;
    int v34 = 474;
    goto LABEL_57;
  }
  int v38 = v37;
  int v39 = mime_hdr_find(v37);
  if (!v39 || (int v40 = v39, (v41 = (const char *)*((void *)v39 + 1)) == 0))
  {
    sk_pop_free(v38, (void (__cdecl *)(void *))mime_hdr_free);
    sk_pop_free(st, (void (__cdecl *)(void *))BIO_vfree);
    int v13 = 212;
    int v14 = 485;
    goto LABEL_12;
  }
  if (!strcmp(*((const char **)v39 + 1), "application/x-pkcs7-signature")
    || !strcmp(v41, "application/pkcs7-signature"))
  {
    sk_pop_free(v38, (void (__cdecl *)(void *))mime_hdr_free);
    asn1 = (ASN1_VALUE *)b64_read_asn1((BIO *)v36, it);
    if (asn1)
    {
      if (bcont)
      {
        *bcont = (BIO *)sk_value(st, 0);
        BIO_free((BIO *)v36);
        sk_free(st);
        return asn1;
      }
    }
    else
    {
      ERR_put_error(13, 4095, 204, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", 500);
    }
    sk_pop_free(st, (void (__cdecl *)(void *))BIO_vfree);
    return asn1;
  }
  ERR_put_error(13, 4095, 213, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", 491);
  ERR_asprintf_error_data("type: %s", *((const char **)v40 + 1));
  sk_pop_free(v38, (void (__cdecl *)(void *))mime_hdr_free);
LABEL_58:
  int v11 = (void (__cdecl *)(void *))BIO_vfree;
  uint64_t v12 = st;
LABEL_59:
  sk_pop_free(v12, v11);
  return 0;
}

STACK *mime_parse_hdr(BIO *a1)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  uint64_t v1 = sk_new((int (__cdecl *)(const char *const *, const char *const *))mime_hdr_cmp);
  if (v1)
  {
    uint64_t v2 = 0;
    int v3 = 0;
    while (1)
    {
      if (BIO_gets(a1, buf, 1024) < 1) {
        return v1;
      }
      if (v2)
      {
        if (buf[0] < 0)
        {
          if (__maskrune(buf[0], 0x4000uLL))
          {
LABEL_7:
            int v4 = 3;
            goto LABEL_10;
          }
        }
        else if ((*(_DWORD *)(MEMORY[0x263EF8318] + 4 * buf[0] + 60) & 0x4000) != 0)
        {
          goto LABEL_7;
        }
      }
      int v4 = 1;
LABEL_10:
      uint64_t v5 = 0;
      int v6 = 0;
      int v7 = buf;
      int v8 = buf;
      while (1)
      {
        unsigned int v9 = buf[v5];
        if (v9 <= 0xD && ((1 << v9) & 0x2401) != 0) {
          break;
        }
        switch(v4)
        {
          case 1:
            if (v9 == 58)
            {
              buf[v5] = 0;
              int v6 = (char *)strip_ends((uint64_t)v8);
              int v4 = 2;
              int v8 = &buf[v5 + 1];
            }
            else
            {
              int v4 = 1;
            }
            goto LABEL_45;
          case 2:
            if (v9 == 40)
            {
              int v3 = 2;
LABEL_44:
              int v4 = 6;
            }
            else if (v9 == 59)
            {
              buf[v5] = 0;
              int v11 = (char *)strip_ends((uint64_t)v8);
              uint64_t v12 = (char *)mime_hdr_new(v6, v11);
              if (!v12) {
                goto LABEL_55;
              }
              uint64_t v2 = (uint64_t)v12;
              if (!sk_push(v1, v12)) {
                goto LABEL_54;
              }
LABEL_30:
              int v6 = 0;
              int v8 = v7 + 1;
LABEL_31:
              int v4 = 3;
            }
            else
            {
              int v4 = 2;
            }
LABEL_45:
            ++v7;
            ++v5;
            break;
          case 3:
            if (v9 != 61) {
              goto LABEL_31;
            }
            buf[v5] = 0;
            int v6 = (char *)strip_ends((uint64_t)v8);
            int v8 = v7 + 1;
            goto LABEL_38;
          case 4:
            switch(v9)
            {
              case '""':
                int v4 = 5;
                goto LABEL_45;
              case '(':
                int v3 = 4;
                goto LABEL_44;
              case ';':
                buf[v5] = 0;
                int v13 = (char *)strip_ends((uint64_t)v8);
                mime_hdr_addparam(v2, v6, v13);
                goto LABEL_30;
            }
LABEL_38:
            int v4 = 4;
            goto LABEL_45;
          case 5:
            if (v9 == 34) {
              int v4 = 4;
            }
            else {
              int v4 = 5;
            }
            goto LABEL_45;
          case 6:
            if (v9 == 41) {
              int v4 = v3;
            }
            else {
              int v4 = 6;
            }
            goto LABEL_45;
          default:
            goto LABEL_45;
        }
      }
      if (v4 == 4)
      {
        uint64_t v16 = (char *)strip_ends((uint64_t)v8);
        mime_hdr_addparam(v2, v6, v16);
        if (!v5) {
          return v1;
        }
      }
      else
      {
        if (v4 == 2)
        {
          int v14 = (char *)strip_ends((uint64_t)v8);
          int v15 = (char *)mime_hdr_new(v6, v14);
          if (!v15) {
            goto LABEL_55;
          }
          uint64_t v2 = (uint64_t)v15;
          if (!sk_push(v1, v15))
          {
LABEL_54:
            mime_hdr_free(v2);
LABEL_55:
            sk_pop_free(v1, (void (__cdecl *)(void *))mime_hdr_free);
            return 0;
          }
        }
        if (!v5) {
          return v1;
        }
      }
    }
  }
  return v1;
}

char *mime_hdr_find(STACK *a1)
{
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  *(void *)unsigned int data = "content-type";
  int v2 = sk_find(a1, data);
  if (v2 < 0) {
    return 0;
  }
  else {
    return sk_value(a1, v2);
  }
}

void mime_hdr_free(uint64_t a1)
{
  free(*(void **)a1);
  free(*(void **)(a1 + 8));
  int v2 = *(STACK **)(a1 + 16);
  if (v2) {
    sk_pop_free(v2, (void (__cdecl *)(void *))mime_param_free);
  }
  free((void *)a1);
}

void *b64_read_asn1(BIO *a1, const ASN1_ITEM *a2)
{
  int v4 = BIO_f_base64();
  uint64_t v5 = BIO_new(v4);
  if (v5)
  {
    uint64_t v6 = v5;
    int v7 = BIO_push(v5, a1);
    int v8 = ASN1_item_d2i_bio(a2, v7, 0);
    if (!v8) {
      ERR_put_error(13, 4095, 110, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", 196);
    }
    BIO_ctrl(v7, 11, 0, 0);
    BIO_pop(v7);
    BIO_free(v6);
  }
  else
  {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", 190);
    return 0;
  }
  return v8;
}

int SMIME_text(BIO *in, BIO *out)
{
  int v2 = (BIO *)MEMORY[0x270FA5388](in);
  int v4 = v3;
  uint64_t v5 = v2;
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v6 = mime_parse_hdr(v2);
  if (!v6)
  {
    ERR_put_error(13, 4095, 207, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", 579);
    return 0;
  }
  int v7 = v6;
  int v8 = mime_hdr_find(v6);
  if (!v8 || (unsigned int v9 = v8, (v10 = (const char *)*((void *)v8 + 1)) == 0))
  {
    ERR_put_error(13, 4095, 206, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", 583);
    goto LABEL_7;
  }
  if (strcmp(v10, "text/plain"))
  {
    ERR_put_error(13, 4095, 205, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn_mime.c", 588);
    ERR_asprintf_error_data("type: %s", *((const char **)v9 + 1));
LABEL_7:
    sk_pop_free(v7, (void (__cdecl *)(void *))mime_hdr_free);
    return 0;
  }
  sk_pop_free(v7, (void (__cdecl *)(void *))mime_hdr_free);
  int v12 = BIO_read(v5, data, 4096);
  if (v12 >= 1)
  {
    do
    {
      BIO_write(v4, data, v12);
      int v12 = BIO_read(v5, data, 4096);
    }
    while (v12 > 0);
  }
  return v12 == 0;
}

uint64_t mime_hdr_cmp(const char ***a1, const char ***a2)
{
  int v2 = **a1;
  int v3 = **a2;
  if (v2) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    return (v2 != 0) - (v3 != 0);
  }
  else {
    return strcmp(v2, v3);
  }
}

const char *strip_ends(uint64_t a1)
{
  uint64_t v1 = (const char *)(a1 + 1);
  uint64_t v2 = MEMORY[0x263EF8318];
  while (1)
  {
    uint64_t v3 = *((unsigned __int8 *)v1 - 1);
    if (!*(v1 - 1)) {
      return 0;
    }
    if (v3 == 34)
    {
      if (!*v1) {
        return 0;
      }
      goto LABEL_12;
    }
    if ((v3 & 0x80) != 0)
    {
      if (!__maskrune(v3, 0x4000uLL))
      {
LABEL_11:
        --v1;
LABEL_12:
        BOOL v4 = &v1[strlen(v1)];
        uint64_t v5 = v4 - 1;
        if (v4 - 1 >= v1)
        {
          unsigned int v6 = *(unsigned __int8 *)v5;
          if (v6 == 34)
          {
LABEL_21:
            if (v4 - 2 != v1)
            {
              *uint64_t v5 = 0;
              return v1;
            }
          }
          else
          {
            while (1)
            {
              if ((v6 & 0x80) != 0)
              {
                if (!__maskrune(v6, 0x4000uLL)) {
                  return v1;
                }
              }
              else if ((*(_DWORD *)(v2 + 4 * v6 + 60) & 0x4000) == 0)
              {
                return v1;
              }
              *v5-- = 0;
              if (v5 < v1) {
                break;
              }
              unsigned int v6 = *(unsigned __int8 *)v5;
              if (v6 == 34)
              {
                BOOL v4 = v5 + 1;
                goto LABEL_21;
              }
            }
          }
        }
        return 0;
      }
    }
    else if ((*(_DWORD *)(v2 + 4 * v3 + 60) & 0x4000) == 0)
    {
      goto LABEL_11;
    }
    ++v1;
  }
}

void *mime_hdr_new(const char *a1, char *a2)
{
  uint64_t v2 = a2;
  if (a1)
  {
    uint64_t v3 = strdup(a1);
    BOOL v4 = (unsigned __int8 *)v3;
    if (!v3)
    {
      uint64_t v2 = 0;
      goto LABEL_17;
    }
    __darwin_ct_rune_t v5 = *v3;
    if (*v4)
    {
      unsigned int v6 = v4 + 1;
      do
      {
        *(v6 - 1) = __tolower(v5);
        __darwin_ct_rune_t v7 = *v6++;
        __darwin_ct_rune_t v5 = v7;
      }
      while (v7);
    }
    if (!v2) {
      goto LABEL_13;
    }
  }
  else
  {
    BOOL v4 = 0;
    if (!a2) {
      goto LABEL_13;
    }
  }
  int v8 = strdup(v2);
  uint64_t v2 = v8;
  if (!v8)
  {
LABEL_17:
    free(v4);
    free(v2);
    return 0;
  }
  __darwin_ct_rune_t v9 = *v8;
  if (*v2)
  {
    int v10 = (unsigned __int8 *)(v2 + 1);
    do
    {
      *(v10 - 1) = __tolower(v9);
      __darwin_ct_rune_t v11 = *v10++;
      __darwin_ct_rune_t v9 = v11;
    }
    while (v11);
  }
LABEL_13:
  int v12 = malloc_type_malloc(0x18uLL, 0x30040254F79A5uLL);
  if (!v12) {
    goto LABEL_17;
  }
  int v13 = v12;
  *int v12 = v4;
  v12[1] = v2;
  uint64_t v14 = sk_new((int (__cdecl *)(const char *const *, const char *const *))mime_param_cmp);
  _OWORD v13[2] = v14;
  if (!v14)
  {
    free(v13);
    goto LABEL_17;
  }
  return v13;
}

void mime_hdr_addparam(uint64_t a1, char *__s1, char *a3)
{
  uint64_t v3 = a3;
  if (__s1)
  {
    __darwin_ct_rune_t v5 = strdup(__s1);
    unsigned int v6 = (unsigned __int8 *)v5;
    if (!v5)
    {
      uint64_t v3 = 0;
      goto LABEL_15;
    }
    __darwin_ct_rune_t v7 = *v5;
    if (*v6)
    {
      int v8 = v6 + 1;
      do
      {
        *(v8 - 1) = __tolower(v7);
        __darwin_ct_rune_t v9 = *v8++;
        __darwin_ct_rune_t v7 = v9;
      }
      while (v9);
    }
    if (!v3) {
      goto LABEL_10;
    }
LABEL_9:
    uint64_t v3 = strdup(v3);
    if (!v3) {
      goto LABEL_15;
    }
    goto LABEL_10;
  }
  unsigned int v6 = 0;
  if (a3) {
    goto LABEL_9;
  }
LABEL_10:
  int v10 = malloc_type_malloc(0x10uLL, 0x10040B8F86A93uLL);
  if (v10)
  {
    __darwin_ct_rune_t v11 = v10;
    *int v10 = v6;
    v10[1] = v3;
    if (sk_push(*(STACK **)(a1 + 16), (char *)v10)) {
      return;
    }
    free(v11);
  }
LABEL_15:
  free(v6);
  free(v3);
}

uint64_t mime_param_cmp(const char ***a1, const char ***a2)
{
  uint64_t v2 = **a1;
  uint64_t v3 = **a2;
  if (v2) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    return (v2 != 0) - (v3 != 0);
  }
  else {
    return strcmp(v2, v3);
  }
}

void mime_param_free(void **a1)
{
  free(*a1);
  free(a1[1]);
  free(a1);
}

BIO_METHOD *BIO_s_null(void)
{
  return (BIO_METHOD *)&null_method;
}

uint64_t null_write(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3;
}

uint64_t null_read()
{
  return 0;
}

size_t null_puts(int a1, char *__s)
{
  if (__s) {
    return strlen(__s);
  }
  else {
    return 0;
  }
}

uint64_t null_gets()
{
  return 0;
}

uint64_t null_ctrl(uint64_t a1, int a2)
{
  if ((a2 - 1) > 0xB) {
    return 0;
  }
  else {
    return qword_23C701D18[a2 - 1];
  }
}

uint64_t null_new(uint64_t a1)
{
  *(_DWORD *)(a1 + 32) = 1;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  return 1;
}

BOOL null_free(uint64_t a1)
{
  return a1 != 0;
}

BOOL X509_CRL_up_ref(uint64_t a1)
{
  return CRYPTO_add_lock((int *)(a1 + 24), 1, 6, 0, 0) > 1;
}

int X509_CRL_set_version(X509_CRL *x, uint64_t version)
{
  if (!x) {
    return 0;
  }
  BOOL v4 = x->crl->version;
  if (!v4)
  {
    BOOL v4 = ASN1_INTEGER_new();
    x->crl->versioint n = v4;
    if (!v4) {
      return 0;
    }
  }
  return ASN1_INTEGER_set(v4, version);
}

int X509_CRL_set_issuer_name(X509_CRL *x, X509_NAME *name)
{
  if (x && x->crl) {
    return X509_NAME_set(&x->crl->issuer, name);
  }
  else {
    return 0;
  }
}

int X509_CRL_set_lastUpdate(X509_CRL *x, ASN1_TIME *tm)
{
  if (x)
  {
    uint64_t v2 = tm;
    uint64_t v3 = x;
    if (x->crl->lastUpdate != tm)
    {
      uint64_t v2 = ASN1_STRING_dup(tm);
      if (v2)
      {
        ASN1_TIME_free(v3->crl->lastUpdate);
        v3->crl->lastUpdate = v2;
      }
    }
    LODWORD(x) = v2 != 0;
  }
  return (int)x;
}

int X509_CRL_set_nextUpdate(X509_CRL *x, ASN1_TIME *tm)
{
  if (x)
  {
    uint64_t v2 = tm;
    uint64_t v3 = x;
    if (x->crl->nextUpdate != tm)
    {
      uint64_t v2 = ASN1_STRING_dup(tm);
      if (v2)
      {
        ASN1_TIME_free(v3->crl->nextUpdate);
        v3->crl->nextUpdate = v2;
      }
    }
    LODWORD(x) = v2 != 0;
  }
  return (int)x;
}

int X509_CRL_sort(X509_CRL *crl)
{
  sk_sort(crl->crl->revoked);
  if (sk_num(crl->crl->revoked) >= 1)
  {
    int v2 = 0;
    do
    {
      *((_DWORD *)sk_value(crl->crl->revoked, v2) + 9) = v2;
      ++v2;
    }
    while (v2 < sk_num(crl->crl->revoked));
  }
  crl->crl->enc.modifiechar d = 1;
  return 1;
}

uint64_t X509_REVOKED_get0_extensions(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t X509_REVOKED_get0_revocationDate(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t X509_REVOKED_get0_serialNumber(uint64_t a1)
{
  return *(void *)a1;
}

int X509_REVOKED_set_revocationDate(X509_REVOKED *r, ASN1_TIME *tm)
{
  if (r)
  {
    int v2 = tm;
    uint64_t v3 = r;
    if (r->revocationDate != tm)
    {
      int v2 = ASN1_STRING_dup(tm);
      if (v2)
      {
        ASN1_TIME_free(v3->revocationDate);
        v3->revocationDate = v2;
      }
    }
    LODWORD(r) = v2 != 0;
  }
  return (int)r;
}

int X509_REVOKED_set_serialNumber(X509_REVOKED *x, ASN1_INTEGER *serial)
{
  if (x)
  {
    int v2 = serial;
    uint64_t v3 = x;
    if (x->serialNumber != serial)
    {
      int v2 = ASN1_INTEGER_dup(serial);
      if (v2)
      {
        ASN1_INTEGER_free(v3->serialNumber);
        v3->serialNumbeBIGNUM r = v2;
      }
    }
    LODWORD(x) = v2 != 0;
  }
  return (int)x;
}

uint64_t i2d_re_X509_CRL_tbs(X509_CRL_INFO **a1, unsigned __int8 **a2)
{
  int v2 = *a1;
  v2->enc.modifiechar d = 1;
  return i2d_X509_CRL_INFO(v2, a2);
}

void ERR_load_UI_strings(void)
{
  if (!ERR_func_error_string(UI_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&UI_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&UI_str_reasons);
  }
}

void *EVP_aead_chacha20_poly1305()
{
  return &aead_chacha20_poly1305;
}

void *EVP_aead_xchacha20_poly1305()
{
  return &aead_xchacha20_poly1305;
}

void *EVP_chacha20_poly1305()
{
  return &cipher_chacha20_poly1305;
}

uint64_t aead_chacha20_poly1305_init(uint64_t a1, _OWORD *a2, uint64_t a3, unint64_t a4)
{
  if (a4) {
    unint64_t v4 = a4;
  }
  else {
    unint64_t v4 = 16;
  }
  if (v4 >= 0x11)
  {
    ERR_put_error(6, 4095, 164, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_chacha20poly1305.c", 58);
    return 0;
  }
  if (a3 != 32) {
    return 0;
  }
  uint64_t result = (uint64_t)malloc_type_malloc(0x21uLL, 0x10000407D106B36uLL);
  if (result)
  {
    long long v8 = a2[1];
    *(_OWORD *)uint64_t result = *a2;
    *(_OWORD *)(result + 16) = v8;
    *(unsigned char *)(result + 32) = v4;
    *(void *)(a1 + 8) = result;
    return 1;
  }
  return result;
}

void *aead_chacha20_poly1305_cleanup(uint64_t a1)
{
  return freezero(*(void **)(a1 + 8), 0x21uLL);
}

uint64_t aead_chacha20_poly1305_seal(void *a1, int *a2, unint64_t *a3, unint64_t a4, unsigned __int8 *a5, uint64_t a6, _DWORD *a7, unint64_t a8, char *a9, unint64_t a10)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v10 = a1[1];
  memset(v26, 0, sizeof(v26));
  if (*(unsigned __int8 *)(v10 + 32) + a8 > a4)
  {
    int v11 = 155;
    int v12 = 137;
LABEL_11:
    ERR_put_error(6, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_chacha20poly1305.c", v12);
    return 0;
  }
  if (*(unsigned __int8 *)(*a1 + 1) != a6)
  {
    int v11 = 102;
    int v12 = 142;
    goto LABEL_11;
  }
  unint64_t v17 = a10;
  unint64_t v18 = ((unint64_t)*a5 << 32) | ((unint64_t)a5[1] << 40) | ((unint64_t)a5[2] << 48) | ((unint64_t)a5[3] << 56);
  int8x16_t v19 = (uint64_t *)(a5 + 4);
  memset(v27, 0, sizeof(v27));
  CRYPTO_chacha_20((int *)v27, v27, 0x20uLL, (_OWORD *)v10, (uint64_t *)(a5 + 4), v18);
  CRYPTO_poly1305_init((uint64_t)v26, v27);
  poly1305_update_with_pad16((uint64_t *)v26, a9, a10);
  CRYPTO_chacha_20(a2, a7, a8, (_OWORD *)v10, v19, v18 | 1);
  poly1305_update_with_pad16((uint64_t *)v26, (char *)a2, a8);
  for (uint64_t i = 0; i != 8; ++i)
  {
    v25[i] = v17;
    v17 >>= 8;
  }
  CRYPTO_poly1305_update((uint64_t *)v26, v25, 8uLL);
  uint64_t v21 = 0;
  unint64_t v22 = a8;
  do
  {
    v25[v21] = v22;
    v22 >>= 8;
    ++v21;
  }
  while (v21 != 8);
  CRYPTO_poly1305_update((uint64_t *)v26, v25, 8uLL);
  if (*(unsigned char *)(v10 + 32) == 16)
  {
    CRYPTO_poly1305_finish((uint64_t)v26, (uint64_t)a2 + a8);
    unint64_t v23 = a8 + 16;
  }
  else
  {
    CRYPTO_poly1305_finish((uint64_t)v26, (uint64_t)v25);
    memcpy((char *)a2 + a8, v25, *(unsigned __int8 *)(v10 + 32));
    unint64_t v23 = *(unsigned __int8 *)(v10 + 32) + a8;
  }
  *a3 = v23;
  return 1;
}

uint64_t aead_chacha20_poly1305_open(void *a1, int *a2, unint64_t *a3, unint64_t a4, unsigned __int8 *a5, uint64_t a6, char *a7, unint64_t a8, char *a9, unint64_t a10)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v10 = a1[1];
  memset(v25, 0, sizeof(v25));
  unint64_t v11 = *(unsigned __int8 *)(v10 + 32);
  unint64_t v12 = a8 - v11;
  if (a8 >= v11)
  {
    if (*(unsigned __int8 *)(*a1 + 1) == a6)
    {
      if (v12 <= a4)
      {
        unint64_t v18 = a10;
        unint64_t v19 = ((unint64_t)*a5 << 32) | ((unint64_t)a5[1] << 40) | ((unint64_t)a5[2] << 48) | ((unint64_t)a5[3] << 56);
        uint64_t v20 = (uint64_t *)(a5 + 4);
        memset(v26, 0, sizeof(v26));
        CRYPTO_chacha_20((int *)v26, v26, 0x20uLL, (_OWORD *)v10, (uint64_t *)(a5 + 4), v19);
        CRYPTO_poly1305_init((uint64_t)v25, v26);
        poly1305_update_with_pad16((uint64_t *)v25, a9, a10);
        poly1305_update_with_pad16((uint64_t *)v25, a7, v12);
        for (uint64_t i = 0; i != 8; ++i)
        {
          v27[i] = v18;
          v18 >>= 8;
        }
        CRYPTO_poly1305_update((uint64_t *)v25, v27, 8uLL);
        uint64_t v22 = 0;
        unint64_t v23 = v12;
        do
        {
          v27[v22] = v23;
          v23 >>= 8;
          ++v22;
        }
        while (v22 != 8);
        CRYPTO_poly1305_update((uint64_t *)v25, v27, 8uLL);
        CRYPTO_poly1305_finish((uint64_t)v25, (uint64_t)v27);
        if (!timingsafe_memcmp((unsigned __int8 *)v27, (unsigned __int8 *)&a7[v12], *(unsigned __int8 *)(v10 + 32)))
        {
          CRYPTO_chacha_20(a2, a7, v12, (_OWORD *)v10, v20, v19 | 1);
          *a3 = v12;
          return 1;
        }
        int v13 = 100;
        int v14 = 222;
      }
      else
      {
        int v13 = 155;
        int v14 = 201;
      }
    }
    else
    {
      int v13 = 102;
      int v14 = 194;
    }
  }
  else
  {
    int v13 = 100;
    int v14 = 189;
  }
  ERR_put_error(6, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_chacha20poly1305.c", v14);
  return 0;
}

uint64_t *poly1305_update_with_pad16(uint64_t *a1, char *a2, unint64_t a3)
{
  char v3 = a3;
  uint64_t result = CRYPTO_poly1305_update(a1, a2, a3);
  if ((v3 & 0xF) != 0)
  {
    return CRYPTO_poly1305_update(a1, poly1305_pad16_zero_pad16, 16 - (v3 & 0xF));
  }
  return result;
}

uint64_t aead_xchacha20_poly1305_seal(void *a1, int *a2, unint64_t *a3, unint64_t a4, int *a5, uint64_t a6, _DWORD *a7, unint64_t a8, char *a9, unint64_t a10)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v10 = a1[1];
  memset(v25, 0, sizeof(v25));
  if (*(unsigned __int8 *)(v10 + 32) + a8 > a4)
  {
    int v11 = 155;
    int v12 = 243;
LABEL_11:
    ERR_put_error(6, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_chacha20poly1305.c", v12);
    return 0;
  }
  if (*(unsigned __int8 *)(*a1 + 1) != a6)
  {
    int v11 = 102;
    int v12 = 248;
    goto LABEL_11;
  }
  int v15 = (uint64_t *)a5;
  unint64_t v18 = a10;
  CRYPTO_hchacha_20(v26, (int *)v10, a5);
  v15 += 2;
  CRYPTO_chacha_20(a2, a7, a8, v26, v15, 1);
  memset(v27, 0, sizeof(v27));
  CRYPTO_chacha_20((int *)v27, v27, 0x20uLL, v26, v15, 0);
  CRYPTO_poly1305_init((uint64_t)v25, v27);
  poly1305_update_with_pad16((uint64_t *)v25, a9, a10);
  poly1305_update_with_pad16((uint64_t *)v25, (char *)a2, a8);
  for (uint64_t i = 0; i != 8; ++i)
  {
    v24[i] = v18;
    v18 >>= 8;
  }
  CRYPTO_poly1305_update((uint64_t *)v25, v24, 8uLL);
  uint64_t v20 = 0;
  unint64_t v21 = a8;
  do
  {
    v24[v20] = v21;
    v21 >>= 8;
    ++v20;
  }
  while (v20 != 8);
  CRYPTO_poly1305_update((uint64_t *)v25, v24, 8uLL);
  if (*(unsigned char *)(v10 + 32) == 16)
  {
    CRYPTO_poly1305_finish((uint64_t)v25, (uint64_t)a2 + a8);
    unint64_t v22 = a8 + 16;
  }
  else
  {
    CRYPTO_poly1305_finish((uint64_t)v25, (uint64_t)v24);
    memcpy((char *)a2 + a8, v24, *(unsigned __int8 *)(v10 + 32));
    unint64_t v22 = *(unsigned __int8 *)(v10 + 32) + a8;
  }
  *a3 = v22;
  return 1;
}

uint64_t aead_xchacha20_poly1305_open(void *a1, int *a2, unint64_t *a3, unint64_t a4, int *a5, uint64_t a6, char *a7, unint64_t a8, char *a9, unint64_t a10)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  uint64_t v10 = a1[1];
  memset(v26, 0, sizeof(v26));
  unint64_t v11 = *(unsigned __int8 *)(v10 + 32);
  unint64_t v12 = a8 - v11;
  if (a8 >= v11)
  {
    if (*(unsigned __int8 *)(*a1 + 1) == a6)
    {
      if (v12 <= a4)
      {
        unint64_t v19 = a10;
        CRYPTO_hchacha_20(v27, (int *)v10, a5);
        memset(v28, 0, sizeof(v28));
        uint64_t v20 = (uint64_t *)(a5 + 4);
        CRYPTO_chacha_20((int *)v28, v28, 0x20uLL, v27, v20, 0);
        CRYPTO_poly1305_init((uint64_t)v26, v28);
        poly1305_update_with_pad16((uint64_t *)v26, a9, a10);
        poly1305_update_with_pad16((uint64_t *)v26, a7, v12);
        for (uint64_t i = 0; i != 8; ++i)
        {
          v29[i] = v19;
          v19 >>= 8;
        }
        CRYPTO_poly1305_update((uint64_t *)v26, v29, 8uLL);
        uint64_t v22 = 0;
        unint64_t v23 = v12;
        do
        {
          v29[v22] = v23;
          v23 >>= 8;
          ++v22;
        }
        while (v22 != 8);
        CRYPTO_poly1305_update((uint64_t *)v26, v29, 8uLL);
        CRYPTO_poly1305_finish((uint64_t)v26, (uint64_t)v29);
        if (!timingsafe_memcmp((unsigned __int8 *)v29, (unsigned __int8 *)&a7[v12], *(unsigned __int8 *)(v10 + 32)))
        {
          uint64_t v24 = 1;
          CRYPTO_chacha_20(a2, a7, v12, v27, v20, 1);
          *a3 = v12;
          return v24;
        }
        int v13 = 100;
        int v14 = 323;
      }
      else
      {
        int v13 = 155;
        int v14 = 305;
      }
    }
    else
    {
      int v13 = 102;
      int v14 = 298;
    }
  }
  else
  {
    int v13 = 100;
    int v14 = 293;
  }
  ERR_put_error(6, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_chacha20poly1305.c", v14);
  return 0;
}

uint64_t chacha20_poly1305_init(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 120);
  __darwin_ct_rune_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  if (!(a2 | a3)) {
    goto LABEL_9;
  }
  *(_DWORD *)(v3 + 380) = 0;
  if (a2)
  {
    long long v5 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)(v3 + 280) = *(_OWORD *)a2;
    *(_OWORD *)(v3 + 296) = v5;
  }
  if (!a3
    || CBB_init_fixed((uint64_t)v8, v3 + 312, 12)
    && CBB_add_space((char **)v8, &v9, 12 - *(void *)(v3 + 328))
    && CBB_add_bytes((char **)v8, (const void *)a3, *(void *)(v3 + 328))
    && CBB_finish((uint64_t *)v8, 0, 0))
  {
LABEL_9:
    uint64_t v6 = 1;
  }
  else
  {
    uint64_t v6 = 0;
  }
  CBB_cleanup((uint64_t *)v8);
  return v6;
}

uint64_t chacha20_poly1305_cipher(uint64_t a1, int *a2, char *a3, unint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 120);
  if (*(_DWORD *)(v8 + 380))
  {
    uint64_t v9 = *(void *)(v8 + 368);
  }
  else
  {
    int v10 = *(_DWORD *)(v8 + 312);
    ChaCha_set_key(*(void *)(a1 + 120), (_DWORD *)(v8 + 280), 256);
    ChaCha_set_iv(v8, (_DWORD *)(v8 + 316), 0);
    *(_DWORD *)(v8 + 48) = 0;
    *(_DWORD *)(v8 + 52) = v10;
    memset(v16, 0, sizeof(v16));
    ChaCha((int *)v8, (int *)v16, (char *)v16, 0x20uLL);
    CRYPTO_poly1305_init(v8 + 136, v16);
    uint64_t v9 = 0;
    *(unsigned char *)(v8 + 128) = 0;
    *(void *)(v8 + 360) = 0;
    *(void *)(v8 + 368) = 0;
    *(void *)(v8 + 376) = 0x100000000;
  }
  if (!__CFADD__(v9, a4))
  {
    if (!a2 && a3 && v9) {
      return 0xFFFFFFFFLL;
    }
    if (*(_DWORD *)(v8 + 376))
    {
      if (!a2 && a3) {
        goto LABEL_21;
      }
      if ((*(void *)(v8 + 360) & 0xFLL) != 0) {
        CRYPTO_poly1305_update((uint64_t *)(v8 + 136), poly1305_pad16_zero_pad16, 16 - (*(void *)(v8 + 360) & 0xFLL));
      }
      *(_DWORD *)(v8 + 376) = 0;
    }
    if (!a3)
    {
      if ((*(void *)(v8 + 368) & 0xFLL) != 0) {
        CRYPTO_poly1305_update((uint64_t *)(v8 + 136), poly1305_pad16_zero_pad16, 16 - (*(void *)(v8 + 368) & 0xFLL));
      }
      uint64_t v12 = 0;
      unint64_t v13 = *(void *)(v8 + 360);
      do
      {
        *((unsigned char *)v16 + v12) = v13;
        v13 >>= 8;
        ++v12;
      }
      while (v12 != 8);
      CRYPTO_poly1305_update((uint64_t *)(v8 + 136), (char *)v16, 8uLL);
      uint64_t v14 = 0;
      unint64_t v15 = *(void *)(v8 + 368);
      do
      {
        *((unsigned char *)v16 + v14) = v15;
        v15 >>= 8;
        ++v14;
      }
      while (v14 != 8);
      CRYPTO_poly1305_update((uint64_t *)(v8 + 136), (char *)v16, 8uLL);
      if (*(_DWORD *)(a1 + 16))
      {
        CRYPTO_poly1305_finish(v8 + 136, v8 + 336);
        *(void *)(v8 + 352) = 16;
      }
      else
      {
        if (!*(void *)(v8 + 352)) {
          return 0xFFFFFFFFLL;
        }
        CRYPTO_poly1305_finish(v8 + 136, (uint64_t)v16);
        if (timingsafe_memcmp((unsigned __int8 *)v16, (unsigned __int8 *)(v8 + 336), *(void *)(v8 + 352)))return 0xFFFFFFFFLL; {
      }
        }
      *(_DWORD *)(v8 + 380) = 0;
      return a4;
    }
    if (a2)
    {
      ChaCha((int *)v8, a2, a3, a4);
      *(void *)(v8 + 368) += a4;
      if (*(_DWORD *)(a1 + 16))
      {
LABEL_23:
        CRYPTO_poly1305_update((uint64_t *)(v8 + 136), (char *)a2, a4);
        return a4;
      }
LABEL_22:
      a2 = (int *)a3;
      goto LABEL_23;
    }
LABEL_21:
    *(void *)(v8 + 360) += a4;
    *(_DWORD *)(v8 + 376) = 1;
    goto LABEL_22;
  }
  ERR_put_error(6, 4095, 164, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_chacha20poly1305.c", 478);
  return 0;
}

void chacha20_poly1305_cleanup(uint64_t a1)
{
}

uint64_t chacha20_poly1305_ctrl(uint64_t a1, int a2, size_t __n, uint64_t *__src)
{
  uint64_t result = 0;
  uint64_t v6 = *(void *)(a1 + 120);
  switch(a2)
  {
    case 9:
      if ((__n - 13) < 0xFFFFFFF4) {
        return 0;
      }
      *(void *)(v6 + 328) = __n;
      return 1;
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return result;
    case 16:
      uint64_t result = 0;
      if ((int)__n < 1 || !*(_DWORD *)(a1 + 16)) {
        return result;
      }
      if (*(void *)(v6 + 352) < (unint64_t)__n) {
        return 0;
      }
      memcpy(__src, (const void *)(v6 + 336), __n);
      return 1;
    case 17:
      if (*(_DWORD *)(a1 + 16) || (__n - 17) < 0xFFFFFFF0) {
        return 0;
      }
      if (__src)
      {
        uint64_t v7 = (int)__n;
        memcpy((void *)(v6 + 336), __src, (int)__n);
        *(void *)(v6 + 352) = v7;
      }
      return 1;
    case 18:
      if (__n != 12) {
        return 0;
      }
      uint64_t v8 = *__src;
      *(_DWORD *)(v6 + 320) = *((_DWORD *)__src + 2);
      *(void *)(v6 + 312) = v8;
      return 1;
    default:
      if (!a2)
      {
        *(_OWORD *)(v6 + 352) = 0u;
        *(_OWORD *)(v6 + 368) = 0u;
        *(_OWORD *)(v6 + 320) = 0u;
        *(_OWORD *)(v6 + 336) = 0u;
        *(_OWORD *)(v6 + 288) = 0u;
        *(_OWORD *)(v6 + 304) = 0u;
        *(_OWORD *)(v6 + EVP_MD_CTX_set_flags(ctx, 256) = 0u;
        *(_OWORD *)(v6 + 272) = 0u;
        *(_OWORD *)(v6 + 224) = 0u;
        *(_OWORD *)(v6 + 240) = 0u;
        *(_OWORD *)(v6 + 192) = 0u;
        *(_OWORD *)(v6 + 208) = 0u;
        *(_OWORD *)(v6 + 160) = 0u;
        *(_OWORD *)(v6 + 176) = 0u;
        *(_OWORD *)(v6 + 128) = 0u;
        *(_OWORD *)(v6 + 144) = 0u;
        *(_OWORD *)(v6 + 96) = 0u;
        *(_OWORD *)(v6 + 112) = 0u;
        *(_OWORD *)(v6 + 64) = 0u;
        *(_OWORD *)(v6 + 80) = 0u;
        *(_OWORD *)(v6 + 32) = 0u;
        *(_OWORD *)(v6 + 48) = 0u;
        *(void *)(v6 + 328) = 12;
        uint64_t result = 1;
        *(_OWORD *)uint64_t v6 = 0u;
        *(_OWORD *)(v6 + 16) = 0u;
      }
      return result;
  }
}

void ERR_load_OBJ_strings(void)
{
  if (!ERR_func_error_string(OBJ_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&OBJ_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&OBJ_str_reasons);
  }
}

uint64_t ERR_load_KDF_strings()
{
  if (!ERR_func_error_string(KDF_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&KDF_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&KDF_str_reasons);
  }
  return 1;
}

void ERR_load_DSO_strings(void)
{
  if (!ERR_func_error_string(DSO_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&DSO_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&DSO_str_reasons);
  }
}

ASN1_INTEGER *ASN1_INTEGER_new(void)
{
  return (ASN1_INTEGER *)ASN1_item_new(&ASN1_INTEGER_it);
}

void ASN1_INTEGER_free(ASN1_INTEGER *a)
{
}

ASN1_INTEGER *__cdecl ASN1_INTEGER_dup(ASN1_INTEGER *x)
{
  if (!x || x->length < 0) {
    return 0;
  }
  else {
    return ASN1_STRING_dup(x);
  }
}

int ASN1_INTEGER_cmp(ASN1_INTEGER *x, ASN1_INTEGER *y)
{
  int type = x->type;
  if (((y->type ^ type) & 0x100) != 0)
  {
    int result = 1;
  }
  else
  {
    int result = ASN1_STRING_cmp(x, y);
    int type = x->type;
  }
  if ((type & 0x100) != 0) {
    return -result;
  }
  return result;
}

uint64_t asn1_aint_get_uint64(void *a1, unint64_t *a2)
{
  unsigned __int8 v6 = 0;
  *a2 = 0;
  unint64_t v4 = 0;
  if (CBS_len((uint64_t)a1))
  {
    while (1)
    {
      uint64_t result = CBS_get_u8(a1, &v6);
      if (!result) {
        break;
      }
      if (HIBYTE(v4))
      {
        ERR_put_error(13, 4095, 223, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_int.c", 141);
        return 0;
      }
      unint64_t v4 = v6 | (v4 << 8);
      if (!CBS_len((uint64_t)a1)) {
        goto LABEL_5;
      }
    }
  }
  else
  {
LABEL_5:
    *a2 = v4;
    return 1;
  }
  return result;
}

uint64_t asn1_aint_set_uint64(unint64_t a1, void *a2, int *a3)
{
  size_t v12 = 0;
  unint64_t v13 = 0;
  memset(v11, 0, sizeof(v11));
  if (!CBB_init((uint64_t)v11, 8uLL)) {
    goto LABEL_6;
  }
  uint64_t v6 = 0;
  if (a2 && a3)
  {
    if (*a2 || (int v7 = *a3) != 0)
    {
LABEL_6:
      uint64_t v6 = 0;
      goto LABEL_7;
    }
    for (uint64_t i = 56; i != -8; i -= 8)
    {
      if (v7 || !i || (a1 >> i))
      {
        if (!CBB_add_u8((char **)v11, (a1 >> i))) {
          goto LABEL_6;
        }
        int v7 = 1;
      }
      else
      {
        int v7 = 0;
      }
    }
    uint64_t v6 = 0;
    if (CBB_finish((uint64_t *)v11, &v13, &v12))
    {
      int v10 = v12;
      if (!(v12 >> 31))
      {
        *a2 = v13;
        *a3 = v10;
        unint64_t v13 = 0;
        uint64_t v6 = 1;
      }
    }
  }
LABEL_7:
  CBB_cleanup((uint64_t *)v11);
  freezero(v13, v12);
  return v6;
}

uint64_t asn1_aint_get_int64(void *a1, int a2, uint64_t *a3)
{
  uint64_t v9 = 0;
  uint64_t result = asn1_aint_get_uint64(a1, (unint64_t *)&v9);
  if (result)
  {
    uint64_t v6 = v9;
    if (a2)
    {
      if ((unint64_t)v9 >= 0x8000000000000001)
      {
        int v7 = 224;
        int v8 = 207;
LABEL_7:
        ERR_put_error(13, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_int.c", v8);
        return 0;
      }
      uint64_t v6 = -v9;
    }
    else if (v9 < 0)
    {
      int v7 = 223;
      int v8 = 213;
      goto LABEL_7;
    }
    *a3 = v6;
    return 1;
  }
  return result;
}

uint64_t ASN1_INTEGER_get_uint64(void *a1, unsigned int *a2)
{
  *a1 = 0;
  if (!a2) {
    return 0;
  }
  uint64_t v2 = *a2;
  if ((v2 & 0x80000000) != 0) {
    return 0;
  }
  unsigned int v3 = a2[1];
  if (v3 != 2)
  {
    if (v3 == 258)
    {
      int v4 = 226;
      int v5 = 234;
    }
    else
    {
      int v4 = 225;
      int v5 = 238;
    }
    ERR_put_error(13, 4095, v4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_int.c", v5);
    return 0;
  }
  unint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  CBS_init(v8, *((void *)a2 + 1), v2);
  uint64_t result = asn1_aint_get_uint64(v8, &v9);
  if (result)
  {
    *a1 = v9;
    return 1;
  }
  return result;
}

uint64_t ASN1_INTEGER_set_uint64(int *a1, unint64_t a2)
{
  int v4 = a1 + 2;
  freezero(*((void **)a1 + 1), *a1);
  *(void *)a1 = 0;
  *int v4 = 0;
  *((void *)a1 + 2) = 0;
  a1[1] = 2;
  return asn1_aint_set_uint64(a2, v4, a1);
}

uint64_t ASN1_INTEGER_get_int64(uint64_t *a1, unsigned int *a2)
{
  *a1 = 0;
  if (a2)
  {
    uint64_t v3 = *a2;
    if ((v3 & 0x80000000) == 0)
    {
      if ((a2[1] | 0x100) == 0x102)
      {
        memset(v6, 0, sizeof(v6));
        CBS_init(v6, *((void *)a2 + 1), v3);
        return asn1_aint_get_int64(v6, a2[1] == 258, a1);
      }
      ERR_put_error(13, 4095, 225, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_int.c", 272);
    }
  }
  return 0;
}

uint64_t ASN1_INTEGER_set_int64(int *a1, unint64_t a2)
{
  int v4 = a1 + 2;
  freezero(*((void **)a1 + 1), *a1);
  *(void *)a1 = 0;
  *int v4 = 0;
  *((void *)a1 + 2) = 0;
  a1[1] = 2;
  if ((a2 & 0x8000000000000000) != 0)
  {
    a1[1] = 258;
    a2 = -(uint64_t)a2;
  }
  return asn1_aint_set_uint64(a2, v4, a1);
}

uint64_t ASN1_INTEGER_get(uint64_t a)
{
  if (a)
  {
    uint64_t v1 = 0;
    if (ASN1_INTEGER_get_int64(&v1, (unsigned int *)a)) {
      return v1;
    }
    else {
      return -1;
    }
  }
  return a;
}

ASN1_INTEGER *__cdecl BN_to_ASN1_INTEGER(BIGNUM *bn, ASN1_INTEGER *ai)
{
  int v4 = ai;
  if (!ai)
  {
    int v4 = (ASN1_INTEGER *)ASN1_item_new(&ASN1_INTEGER_it);
    if (!v4)
    {
      int v11 = 58;
      int v12 = 333;
LABEL_16:
      ERR_put_error(13, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_int.c", v12);
      goto LABEL_17;
    }
  }
  if ((v4->length & 0x80000000) == 0)
  {
    if (BN_is_negative((uint64_t)bn)) {
      int v5 = 258;
    }
    else {
      int v5 = 2;
    }
    v4->int type = v5;
    int v6 = BN_num_bits(bn);
    int v7 = v6 / 8 + 5;
    if (!v6) {
      int v7 = 4;
    }
    unsigned int data = v4->data;
    if (v4->length >= v7) {
      goto LABEL_12;
    }
    unint64_t v9 = (unsigned __int8 *)malloc_type_realloc(v4->data, v7, 0x844DBF6AuLL);
    if (v9)
    {
      unsigned int data = v9;
      v4->unsigned int data = v9;
LABEL_12:
      int v10 = BN_bn2bin(bn, data);
      v4->uint64_t length = v10;
      if (!v10)
      {
        *v4->unsigned int data = 0;
        v4->uint64_t length = 1;
      }
      return v4;
    }
    int v11 = 65;
    int v12 = 349;
    goto LABEL_16;
  }
LABEL_17:
  if (v4 != ai) {
    ASN1_item_free((ASN1_VALUE *)v4, &ASN1_INTEGER_it);
  }
  return 0;
}

BIGNUM *__cdecl ASN1_INTEGER_to_BN(ASN1_INTEGER *ai, BIGNUM *bn)
{
  if (!ai || ai->length < 0) {
    return 0;
  }
  uint64_t v3 = BN_bin2bn(ai->data, ai->length, bn);
  int v4 = v3;
  if (v3)
  {
    if (ai->type == 258) {
      BN_set_negative(v3, 1);
    }
  }
  else
  {
    ERR_put_error(13, 4095, 105, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_int.c", 378);
  }
  return v4;
}

int i2a_ASN1_INTEGER(BIO *bp, ASN1_INTEGER *a)
{
  if (!a) {
    return 0;
  }
  if ((a->type & 0x100) != 0)
  {
    int v4 = 1;
    if (BIO_write(bp, "-", 1) != 1) {
      return -1;
    }
  }
  else
  {
    int v4 = 0;
  }
  if (a->length)
  {
    if (a->length >= 1)
    {
      uint64_t v5 = 0;
      while (1)
      {
        if (v5 && !(v5 % 0x23))
        {
          if (BIO_write(bp, "\\\n", 2) != 2) {
            return -1;
          }
          v4 += 2;
        }
        int v6 = a->data;
        data[0] = i2a_ASN1_INTEGER_h[(unint64_t)v6[v5] >> 4];
        data[1] = i2a_ASN1_INTEGER_h[v6[v5] & 0xF];
        if (BIO_write(bp, data, 2) != 2) {
          break;
        }
        v4 += 2;
        if (++v5 >= a->length) {
          return v4;
        }
      }
      return -1;
    }
  }
  else if (BIO_write(bp, "00", 2) == 2)
  {
    return v4 | 2;
  }
  else
  {
    return -1;
  }
  return v4;
}

int a2i_ASN1_INTEGER(BIO *bp, ASN1_INTEGER *bs, char *buf, int size)
{
  bs->int type = 2;
  int v7 = BIO_gets(bp, buf, size);
  if (v7 >= 1)
  {
    int v34 = bs;
    char v8 = 0;
    int v9 = 0;
    unsigned int v10 = 0;
    int v11 = 0;
    while (1)
    {
      uint64_t v12 = (v7 - 1);
      int v13 = v12;
      if (buf[v12] == 10)
      {
        buf[v12] = 0;
        if (v7 == 1) {
          goto LABEL_47;
        }
        uint64_t v12 = (v7 - 2);
        unsigned int v14 = v7 - 2;
      }
      else
      {
        unsigned int v14 = v7 - 1;
        int v13 = v7;
      }
      if (buf[v12] == 13)
      {
        buf[v12] = 0;
        if (!v14) {
          goto LABEL_47;
        }
        uint64_t v12 = v14 - 1;
        unsigned int v15 = v14 - 1;
      }
      else
      {
        unsigned int v15 = v14;
        unsigned int v14 = v13;
      }
      int v16 = buf[v12];
      if (v16 == 92) {
        unsigned int v17 = v15;
      }
      else {
        unsigned int v17 = v14;
      }
      buf[v17] = 0;
      if (v17 < 2)
      {
LABEL_47:
        uint64_t v20 = v11;
        goto LABEL_44;
      }
      if (v8)
      {
        unint64_t v18 = buf;
      }
      else
      {
        unint64_t v18 = buf;
        if (*buf == 48)
        {
          if (buf[1] == 48) {
            v17 -= 2;
          }
          unint64_t v18 = &buf[2 * (buf[1] == 48)];
        }
      }
      if (v17) {
        break;
      }
      int v19 = v10 + (v17 >> 1);
      if (v19 <= v9)
      {
        uint64_t v20 = v11;
      }
      else
      {
        uint64_t v20 = recallocarray(v11, v9, v10 + (v17 >> 1), 1uLL);
        int v9 = v10 + (v17 >> 1);
        if (!v20)
        {
          int v32 = 65;
          int v33 = 473;
LABEL_49:
          ERR_put_error(13, 4095, v32, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_int.c", v33);
          goto LABEL_46;
        }
      }
      if (v17 >= 2)
      {
        uint64_t v21 = 0;
        uint64_t v22 = 0;
        LODWORD(v23) = v17 >> 1;
        if (v17 >> 1 <= 1) {
          uint64_t v23 = 1;
        }
        else {
          uint64_t v23 = v23;
        }
        while (2)
        {
          uint64_t v24 = 0;
          char v25 = 1;
          do
          {
            char v26 = v25;
            int v27 = v18[v24 | v22];
            char v28 = v27 - 48;
            if ((v27 - 48) >= 0xA)
            {
              if ((v27 - 97) > 5)
              {
                if ((v27 - 65) > 5)
                {
                  int v29 = 141;
                  int v30 = 489;
                  goto LABEL_45;
                }
                char v28 = v27 - 55;
              }
              else
              {
                char v28 = v27 - 87;
              }
            }
            char v25 = 0;
            v20[v21 + v10] = v28 | (16 * v20[v21 + v10]);
            uint64_t v24 = 1;
          }
          while ((v26 & 1) != 0);
          ++v21;
          v22 += 2;
          if (v21 != v23) {
            continue;
          }
          break;
        }
      }
      if (v16 != 92)
      {
        v34->uint64_t length = v19;
        v34->unsigned int data = (unsigned __int8 *)v20;
        return 1;
      }
      int v7 = BIO_gets(bp, buf, size);
      char v8 = 1;
      v10 += v17 >> 1;
      int v11 = v20;
      if (v7 < 1) {
        goto LABEL_44;
      }
    }
    int v32 = 145;
    int v33 = 467;
    goto LABEL_49;
  }
  uint64_t v20 = 0;
LABEL_44:
  int v29 = 150;
  int v30 = 507;
LABEL_45:
  ERR_put_error(13, 4095, v29, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_int.c", v30);
  int v11 = v20;
LABEL_46:
  free(v11);
  return 0;
}

int i2c_ASN1_INTEGER(ASN1_INTEGER *a, unsigned __int8 **pp)
{
  size_t __n = 0;
  char __src = 0;
  memset(v23, 0, sizeof(v23));
  if (!CBB_init((uint64_t)v23, 0))
  {
    size_t v6 = 0;
    goto LABEL_14;
  }
  size_t v28 = 0;
  int v29 = 0;
  char v27 = 0;
  memset(v26, 0, sizeof(v26));
  uint64_t length = a->length;
  if ((length & 0x80000000) != 0 || (unsigned int data = a->data, length) && !data || (a->type & 0xFFFFFEF7 | 8) != 0xA)
  {
LABEL_11:
    size_t v6 = 0;
    int v7 = 0;
LABEL_12:
    freezero(v7, v28);
LABEL_14:
    int v8 = -3;
    goto LABEL_15;
  }
  CBS_init(v26, (uint64_t)data, length);
  while (CBS_len((uint64_t)v26))
  {
    if (!CBS_peek_u8((uint64_t)v26, &v27)) {
      goto LABEL_11;
    }
    if (v27) {
      break;
    }
    if (!CBS_skip(v26, 1uLL)) {
      goto LABEL_11;
    }
  }
  if (CBS_len((uint64_t)v26))
  {
    int v10 = CBS_stow((uint64_t)v26, (void **)&v29, &v28);
    int v7 = v29;
    if (!v10)
    {
LABEL_43:
      size_t v6 = 0;
      goto LABEL_12;
    }
    if ((a->type & 0x100) != 0)
    {
      size_t v14 = v28;
      if ((uint64_t)(v28 - 1) < 0)
      {
        unsigned int v18 = *v29;
        int v19 = (v18 >> 7) - 1;
        int v11 = 1;
LABEL_32:
        if (!v11 || (v18 & 0x80) != 0) {
          goto LABEL_35;
        }
LABEL_34:
        int v20 = CBB_add_u8((char **)v23, v19);
        int v7 = v29;
        if (v20)
        {
LABEL_35:
          int v21 = CBB_add_bytes((char **)v23, v7, v28);
          int v7 = v29;
          if (v21)
          {
            size_t v13 = v28;
            goto LABEL_37;
          }
          size_t v6 = __n;
          goto LABEL_12;
        }
        goto LABEL_43;
      }
      unsigned int v15 = (char *)(v29 - 1);
      char v16 = 1;
      do
      {
        char v17 = v16 + ~v15[v14];
        v15[v14] = v17;
        if (v17) {
          char v16 = 0;
        }
        --v14;
      }
      while (v14);
      int v7 = v29;
      int v11 = a->type & 0x100;
    }
    else
    {
      int v11 = 0;
    }
    unsigned int v18 = (char)*v7;
    int v19 = ((v18 >> 7) & 1) - 1;
    if (!v11 && (v18 & 0x80000000) != 0) {
      goto LABEL_34;
    }
    goto LABEL_32;
  }
  int v12 = CBB_add_u8((char **)v23, 0);
  size_t v13 = 0;
  int v7 = 0;
  size_t v6 = 0;
  if (!v12) {
    goto LABEL_12;
  }
LABEL_37:
  freezero(v7, v13);
  int v22 = CBB_finish((uint64_t *)v23, &__src, &__n);
  size_t v6 = __n;
  int v8 = -3;
  if (v22 && !(__n >> 31))
  {
    if (!pp)
    {
LABEL_42:
      int v8 = v6;
      goto LABEL_15;
    }
    if (!__CFADD__(__n, *pp))
    {
      memcpy(*pp, __src, __n);
      size_t v6 = __n;
      *pp += __n;
      goto LABEL_42;
    }
  }
LABEL_15:
  freezero(__src, v6);
  CBB_cleanup((uint64_t *)v23);
  return v8;
}

uint64_t c2i_ASN1_INTEGER_cbs(ASN1_VALUE **a1, void *a2)
{
  size_t v23 = 0;
  uint64_t v24 = 0;
  __int16 v22 = 0;
  if (!a1) {
    goto LABEL_16;
  }
  int v4 = *a1;
  if (v4)
  {
    ASN1_item_free(v4, &ASN1_INTEGER_it);
    *a1 = 0;
  }
  if (!CBS_len((uint64_t)a2))
  {
    int v9 = 665;
    goto LABEL_15;
  }
  if (!CBS_peek_u8((uint64_t)a2, &v22))
  {
LABEL_16:
    uint64_t v10 = 0;
    goto LABEL_17;
  }
  int v5 = (char)v22;
  int v6 = (char)v22 >> 7;
  __int16 v22 = (char)v22;
  if ((unint64_t)CBS_len((uint64_t)a2) >= 2 && v22 == v6)
  {
    int v7 = (unsigned __int8 *)CBS_data((uint64_t)a2);
    unint64_t v8 = CBS_len((uint64_t)a2);
    if (v8 >= 2 && *v7 == 255)
    {
      unint64_t v12 = v8 - 1;
      size_t v13 = v7 + 1;
      while (!*v13++)
      {
        if (!--v12) {
          goto LABEL_21;
        }
      }
    }
    if (!CBS_get_u8(a2, (unsigned char *)&v22 + 1) || !CBS_peek_u8((uint64_t)a2, &v22)) {
      goto LABEL_16;
    }
    if (((HIBYTE(v22) ^ v22) & 0x80) == 0)
    {
      int v9 = 687;
LABEL_15:
      ERR_put_error(13, 4095, 62, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_int.c", v9);
      goto LABEL_16;
    }
  }
LABEL_21:
  int v15 = CBS_stow((uint64_t)a2, (void **)&v24, &v23);
  uint64_t v10 = 0;
  if (v15 && !(v23 >> 31))
  {
    char v16 = ASN1_item_new(&ASN1_INTEGER_it);
    if (!v16) {
      goto LABEL_16;
    }
    size_t v17 = v23;
    unsigned int v18 = v24;
    if (v5 < 0)
    {
      *((_DWORD *)v16 + 1) = 258;
      if ((uint64_t)(v17 - 1) >= 0)
      {
        int v19 = v18 - 1;
        char v20 = 1;
        do
        {
          char v21 = v20 + ~v19[v17];
          v19[v17] = v21;
          if (v21) {
            char v20 = 0;
          }
          --v17;
        }
        while (v17);
        LODWORD(v17) = v23;
        unsigned int v18 = v24;
      }
    }
    *((void *)v16 + 1) = v18;
    *(_DWORD *)char v16 = v17;
    uint64_t v24 = 0;
    uint64_t v10 = 1;
    *a1 = v16;
  }
LABEL_17:
  ASN1_item_free(0, &ASN1_INTEGER_it);
  freezero(v24, v23);
  return v10;
}

ASN1_INTEGER *__cdecl c2i_ASN1_INTEGER(ASN1_INTEGER **a, const unsigned __int8 **pp, uint64_t length)
{
  unint64_t v8 = 0;
  if (a)
  {
    ASN1_item_free((ASN1_VALUE *)*a, &ASN1_INTEGER_it);
    EC_KEY *a = 0;
  }
  if (length < 0)
  {
    ERR_put_error(13, 4095, 136, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_int.c", 738);
    return 0;
  }
  memset(v7, 0, sizeof(v7));
  CBS_init(v7, (uint64_t)*pp, length);
  if (!c2i_ASN1_INTEGER_cbs((ASN1_VALUE **)&v8, v7)) {
    return 0;
  }
  unsigned __int8 *pp = (const unsigned __int8 *)CBS_data((uint64_t)v7);
  uint64_t result = v8;
  if (a) {
    EC_KEY *a = v8;
  }
  return result;
}

int i2d_ASN1_INTEGER(ASN1_INTEGER *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_INTEGER_it);
}

ASN1_INTEGER *__cdecl d2i_ASN1_INTEGER(ASN1_INTEGER **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_INTEGER *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_INTEGER_it);
}

ASN1_INTEGER *__cdecl d2i_ASN1_UINTEGER(ASN1_INTEGER **a, const unsigned __int8 **pp, uint64_t length)
{
  if (!a || (int v6 = *a) == 0)
  {
    int v6 = (ASN1_INTEGER *)ASN1_item_new(&ASN1_INTEGER_it);
    if (!v6) {
      return v6;
    }
  }
  puint64_t length = 0;
  ppEVP_CIPHER_CTX a = 0;
  *(void *)pclass = 0;
  if (v6->length < 0) {
    goto LABEL_8;
  }
  ppEVP_CIPHER_CTX a = (unsigned __int8 *)*pp;
  if ((ASN1_get_object((const unsigned __int8 **)&ppa, &plength, &pclass[1], pclass, length) & 0x80) != 0)
  {
    int v7 = 102;
    goto LABEL_11;
  }
  if (pclass[1] != 2)
  {
    int v7 = 115;
    goto LABEL_11;
  }
  if ((unint64_t)plength >> 31)
  {
LABEL_8:
    int v7 = 62;
    goto LABEL_11;
  }
  int v9 = (unsigned __int8 *)malloc_type_malloc(plength + 1, 0xA53C0D48uLL);
  if (!v9)
  {
    int v7 = 65;
LABEL_11:
    ERR_put_error(13, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_int.c", 836);
    if (!a || *a != v6) {
      ASN1_item_free((ASN1_VALUE *)v6, &ASN1_INTEGER_it);
    }
    return 0;
  }
  uint64_t v10 = v9;
  v6->int type = 2;
  size_t v11 = plength;
  if (plength)
  {
    unint64_t v12 = ppa;
    if (plength != 1 && !*ppa)
    {
      unint64_t v12 = ppa + 1;
      --plength;
      ++ppa;
      --v11;
    }
    memcpy(v9, v12, v11);
    ppa += plength;
  }
  free(v6->data);
  v6->unsigned int data = v10;
  v6->uint64_t length = plength;
  if (a) {
    EC_KEY *a = v6;
  }
  unsigned __int8 *pp = ppa;
  return v6;
}

void *EVP_sha3_224()
{
  return &sha3_224_md;
}

void *EVP_sha3_256()
{
  return &sha3_256_md;
}

void *EVP_sha3_384()
{
  return &sha3_384_md;
}

void *EVP_sha3_512()
{
  return &sha3_512_md;
}

uint64_t sha3_224_init(uint64_t a1)
{
  return sha3_init(*(void *)(a1 + 24), 0x1Cu);
}

uint64_t sha3_224_update(uint64_t a1, char *a2, uint64_t a3)
{
  return sha3_update(*(void **)(a1 + 24), a2, a3);
}

uint64_t sha3_224_final(uint64_t a1, uint64_t a2)
{
  return sha3_final(a2, *(void **)(a1 + 24));
}

uint64_t sha3_256_init(uint64_t a1)
{
  return sha3_init(*(void *)(a1 + 24), 0x20u);
}

uint64_t sha3_256_update(uint64_t a1, char *a2, uint64_t a3)
{
  return sha3_update(*(void **)(a1 + 24), a2, a3);
}

uint64_t sha3_256_final(uint64_t a1, uint64_t a2)
{
  return sha3_final(a2, *(void **)(a1 + 24));
}

uint64_t sha3_384_init(uint64_t a1)
{
  return sha3_init(*(void *)(a1 + 24), 0x30u);
}

uint64_t sha3_384_update(uint64_t a1, char *a2, uint64_t a3)
{
  return sha3_update(*(void **)(a1 + 24), a2, a3);
}

uint64_t sha3_384_final(uint64_t a1, uint64_t a2)
{
  return sha3_final(a2, *(void **)(a1 + 24));
}

uint64_t sha3_512_init(uint64_t a1)
{
  return sha3_init(*(void *)(a1 + 24), 0x40u);
}

uint64_t sha3_512_update(uint64_t a1, char *a2, uint64_t a3)
{
  return sha3_update(*(void **)(a1 + 24), a2, a3);
}

uint64_t sha3_512_final(uint64_t a1, uint64_t a2)
{
  return sha3_final(a2, *(void **)(a1 + 24));
}

const char *BF_options(void)
{
  return "blowfish(idx)";
}

void BF_ecb_encrypt(const unsigned __int8 *in, unsigned __int8 *out, const BF_KEY *key, int enc)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unsigned int v5 = bswap32(*((_DWORD *)in + 1));
  unsigned int v7 = bswap32(*(_DWORD *)in);
  unsigned int v8 = v5;
  if (enc) {
    BF_encrypt(&v7, key);
  }
  else {
    BF_decrypt(&v7, key);
  }
  unsigned int v6 = bswap32(v8);
  *(_DWORD *)unsigned __int8 out = bswap32(v7);
  *((_DWORD *)out + 1) = v6;
}

CONF_VALUE *__cdecl _CONF_get_section(const CONF *conf, const char *section)
{
  uint64_t result = 0;
  if (conf)
  {
    if (section)
    {
      data[1] = 0;
      unsigned char data[2] = 0;
      data[0] = section;
      return (CONF_VALUE *)lh_retrieve(conf->data, data);
    }
  }
  return result;
}

STACK *__cdecl _CONF_get_section_values(const CONF *conf, const char *section)
{
  if (!conf || !section) {
    return 0;
  }
  data[1] = 0;
  unsigned char data[2] = 0;
  data[0] = section;
  uint64_t result = (STACK *)lh_retrieve(conf->data, data);
  if (result) {
    return *(STACK **)&result->sorted;
  }
  return result;
}

int _CONF_add_string(CONF *conf, CONF_VALUE *section, CONF_VALUE *value)
{
  unsigned int v5 = section->value;
  value->sectioint n = section->section;
  int result = sk_push((STACK *)v5, (char *)value);
  if (result)
  {
    unsigned int v7 = (char *)lh_insert(conf->data, value);
    if (v7)
    {
      unsigned int v8 = (void **)v7;
      sk_delete_ptr((STACK *)v5, v7);
      free(v8[1]);
      free(v8[2]);
      free(v8);
    }
    return 1;
  }
  return result;
}

char *__cdecl _CONF_get_string(const CONF *conf, const char *section, const char *name)
{
  int result = 0;
  if (conf && name)
  {
    unsigned int data = 0;
    unsigned int v7 = 0;
    uint64_t v8 = 0;
    if (section)
    {
      unsigned int data = section;
      unsigned int v7 = name;
      int result = (char *)lh_retrieve(conf->data, &data);
      if (result) {
        return (char *)*((void *)result + 2);
      }
    }
    unsigned int data = "default";
    unsigned int v7 = name;
    int result = (char *)lh_retrieve(conf->data, &data);
    if (result) {
      return (char *)*((void *)result + 2);
    }
  }
  return result;
}

int _CONF_new_data(CONF *conf)
{
  if (conf)
  {
    uint64_t v1 = conf;
    if (conf->data
      || (conf = (CONF *)lh_new((LHASH_HASH_FN_TYPE)conf_value_LHASH_HASH, (LHASH_COMP_FN_TYPE)conf_value_LHASH_COMP),
          (v1->unsigned int data = (LHASH *)conf) != 0))
    {
      LODWORD(conf) = 1;
    }
  }
  return (int)conf;
}

unint64_t conf_value_LHASH_HASH(const char **a1)
{
  unint64_t v2 = lh_strhash(*a1);
  return lh_strhash(a1[1]) ^ (4 * v2);
}

uint64_t conf_value_LHASH_COMP(const char **a1, const char **a2)
{
  int v4 = *a1;
  unsigned int v5 = *a2;
  if (v4 != v5)
  {
    uint64_t result = strcmp(v4, v5);
    if (result) {
      return result;
    }
  }
  unsigned int v7 = a1[1];
  uint64_t v8 = a2[1];
  if (!v7)
  {
    unsigned int v9 = -1;
    goto LABEL_10;
  }
  if (!v8)
  {
    unsigned int v9 = 1;
LABEL_10:
    if (v7 == v8) {
      return 0;
    }
    else {
      return v9;
    }
  }
  return strcmp(v7, v8);
}

void _CONF_free_data(CONF *conf)
{
  if (conf)
  {
    unsigned int data = conf->data;
    if (data)
    {
      data->down_loachar d = 0;
      lh_doall_arg(data, (LHASH_DOALL_ARG_FN_TYPE)value_free_hash_LHASH_DOALL_ARG, data);
      lh_doall(conf->data, (LHASH_DOALL_FN_TYPE)value_free_stack_LHASH_DOALL);
      uint64_t v3 = conf->data;
      lh_free(v3);
    }
  }
}

void *value_free_hash_LHASH_DOALL_ARG(void *data, LHASH *lh)
{
  if (data[1]) {
    return lh_delete(lh, data);
  }
  return data;
}

void value_free_stack_LHASH_DOALL(uint64_t a1)
{
  if (!*(void *)(a1 + 8))
  {
    unint64_t v2 = *(STACK **)(a1 + 16);
    int v3 = sk_num(v2);
    if (v3 >= 1)
    {
      unsigned int v4 = v3 + 1;
      do
      {
        unsigned int v5 = (void **)sk_value(v2, v4 - 2);
        free(v5[2]);
        free(v5[1]);
        free(v5);
        --v4;
      }
      while (v4 > 1);
    }
    if (v2) {
      sk_free(v2);
    }
    free(*(void **)a1);
    free((void *)a1);
  }
}

CONF_VALUE *__cdecl _CONF_new_section(CONF *conf, const char *section)
{
  unsigned int v4 = sk_new_null();
  if (!v4)
  {
    unsigned int v6 = 0;
LABEL_8:
    free(v6);
    return 0;
  }
  unsigned int v5 = v4;
  unsigned int v6 = (CONF_VALUE *)malloc_type_malloc(0x18uLL, 0x100402FEFCB83uLL);
  if (!v6
    || (size_t v7 = (int)(strlen(section) + 1), v8 = (char *)malloc_type_malloc(v7, 0x9215DE77uLL), (v6->section = v8) == 0))
  {
    sk_free(v5);
    goto LABEL_8;
  }
  memcpy(v8, section, v7);
  v6->name = 0;
  v6->value = (char *)v5;
  if (lh_insert(conf->data, v6)) {
    OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/conf/conf_api.c", 268, "vv == NULL");
  }
  return v6;
}

ASN1_INTEGER *s2i_asn1_int(X509V3_EXT_METHOD *a1, int a2, char *value)
{
  return s2i_ASN1_INTEGER(a1, value);
}

BIO_METHOD *BIO_f_md(void)
{
  return (BIO_METHOD *)&methods_md;
}

uint64_t md_write(BIO *a1, const void *a2, int a3)
{
  uint64_t v3 = 0;
  if (a2 && a3 >= 1)
  {
    next_int bio = (EVP_MD_CTX *)a1->next_bio;
    if (next_bio && (prev_int bio = a1->prev_bio) != 0)
    {
      uint64_t v8 = BIO_write(prev_bio, a2, a3);
      uint64_t v3 = v8;
      if (a1->flags && (int)v8 >= 1 && !EVP_DigestUpdate(next_bio, a2, v8))
      {
        BIO_clear_flags(a1, 15);
        return 0;
      }
    }
    else
    {
      uint64_t v3 = 0;
    }
    if (a1->prev_bio)
    {
      BIO_clear_flags(a1, 15);
      BIO_copy_next_retry(a1);
    }
  }
  return v3;
}

uint64_t md_read(BIO *a1, void *a2, int a3)
{
  if (!a2) {
    return 0;
  }
  next_int bio = (EVP_MD_CTX *)a1->next_bio;
  if (!next_bio) {
    return 0;
  }
  prev_int bio = a1->prev_bio;
  if (!prev_bio) {
    return 0;
  }
  uint64_t v7 = BIO_read(prev_bio, a2, a3);
  uint64_t v8 = v7;
  if (a1->flags && (int)v7 >= 1 && EVP_DigestUpdate(next_bio, a2, v7) < 1) {
    return 0xFFFFFFFFLL;
  }
  BIO_clear_flags(a1, 15);
  BIO_copy_next_retry(a1);
  return v8;
}

uint64_t md_gets(uint64_t a1, unsigned __int8 *a2, int a3)
{
  uint64_t v3 = *(EVP_MD_CTX **)(a1 + 56);
  if (v3->digest->md_size > a3) {
    return 0;
  }
  unsigned int s = 0;
  if (EVP_DigestFinal_ex(v3, a2, &s) < 1) {
    return 0xFFFFFFFFLL;
  }
  else {
    return s;
  }
}

uint64_t md_ctrl(BIO *b, int a2, uint64_t a3, bio_st *type)
{
  next_int bio = (const EVP_MD_CTX *)b->next_bio;
  if (a2 <= 110)
  {
    switch(a2)
    {
      case 1:
        if (b->flags)
        {
          LODWORD(result) = EVP_DigestInit_ex((EVP_MD_CTX *)b->next_bio, next_bio->digest, 0);
          if ((int)result < 1) {
            return (int)result;
          }
          prev_int bio = b->prev_bio;
          a2 = 1;
          goto LABEL_27;
        }
        break;
      case 12:
        if (EVP_MD_CTX_copy_ex((EVP_MD_CTX *)type->next_bio, next_bio))
        {
LABEL_24:
          uint64_t result = 1;
          b->flagunsigned int s = 1;
          return result;
        }
        break;
      case 101:
        BIO_clear_flags(b, 15);
        uint64_t v8 = BIO_ctrl(b->prev_bio, 101, a3, type);
        BIO_copy_next_retry(b);
        return v8;
      default:
LABEL_26:
        prev_int bio = b->prev_bio;
LABEL_27:
        return BIO_ctrl(prev_bio, a2, a3, type);
    }
    return 0;
  }
  if (a2 > 119)
  {
    if (a2 != 120)
    {
      if (a2 == 148)
      {
        if (b->flags)
        {
          b->next_int bio = type;
          return 1;
        }
        return 0;
      }
      goto LABEL_26;
    }
    type->methochar d = (BIO_METHOD *)next_bio;
    goto LABEL_24;
  }
  if (a2 != 111)
  {
    if (a2 == 112)
    {
      if (b->flags)
      {
        type->methochar d = (BIO_METHOD *)next_bio->digest;
        return 1;
      }
      return 0;
    }
    goto LABEL_26;
  }
  uint64_t result = EVP_DigestInit_ex((EVP_MD_CTX *)b->next_bio, (const EVP_MD *)type, 0);
  if ((int)result >= 1) {
    b->flagunsigned int s = 1;
  }
  return result;
}

uint64_t md_new(uint64_t a1)
{
  uint64_t result = (uint64_t)EVP_MD_CTX_create();
  if (result)
  {
    *(_DWORD *)(a1 + 32) = 0;
    *(void *)(a1 + 56) = result;
    uint64_t result = 1;
    *(_DWORD *)(a1 + 40) = 0;
  }
  return result;
}

uint64_t md_free(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    EVP_MD_CTX_destroy(*(EVP_MD_CTX **)(result + 56));
    *(void *)(v1 + 56) = 0;
    *(_DWORD *)(v1 + 32) = 0;
    uint64_t result = 1;
    *(_DWORD *)(v1 + 40) = 0;
  }
  return result;
}

BIO *md_callback_ctrl(uint64_t a1, int a2, void (__cdecl *a3)(bio_st *, int, const char *, int, uint64_t, uint64_t))
{
  uint64_t result = *(BIO **)(a1 + 64);
  if (result) {
    return (BIO *)BIO_callback_ctrl(result, a2, a3);
  }
  return result;
}

STACK *__cdecl i2v_ASN1_BIT_STRING(X509V3_EXT_METHOD *method, ASN1_BIT_STRING *bits, STACK *extlist)
{
  extlistEVP_CIPHER_CTX a = extlist;
  if (extlist)
  {
    unsigned int v5 = 0;
  }
  else
  {
    extlist = sk_new_null();
    extlistEVP_CIPHER_CTX a = extlist;
    unsigned int v5 = extlist;
    if (!extlist) {
      return extlist;
    }
  }
  usr_unsigned int data = (char *)method->usr_data;
  if (*((void *)usr_data + 1))
  {
    while (!ASN1_BIT_STRING_get_bit(bits, *(_DWORD *)usr_data)
         || X509V3_add_value(*((const char **)usr_data + 1), 0, &extlista))
    {
      uint64_t v7 = *((void *)usr_data + 4);
      usr_data += 24;
      if (!v7) {
        return extlista;
      }
    }
    sk_pop_free(v5, (void (__cdecl *)(void *))X509V3_conf_free);
    return 0;
  }
  return extlist;
}

ASN1_BIT_STRING *__cdecl v2i_ASN1_BIT_STRING(X509V3_EXT_METHOD *method, X509V3_CTX *ctx, STACK *nval)
{
  unsigned int v5 = ASN1_BIT_STRING_new();
  if (v5)
  {
    if (sk_num(nval) >= 1)
    {
      int v6 = 0;
      while (1)
      {
        uint64_t v7 = sk_value(nval, v6);
        uint64_t v8 = (const char **)v7;
        usr_unsigned int data = (char *)method->usr_data;
        uint64_t v10 = (const char *)*((void *)usr_data + 1);
        if (!v10)
        {
LABEL_15:
          ERR_put_error(34, 4095, 111, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_bitst.c", 212);
          ERR_asprintf_error_data("section:%s,name:%s,value:%s", *v8, v8[1], v8[2]);
          goto LABEL_16;
        }
        size_t v11 = (const char *)*((void *)v7 + 1);
        unint64_t v12 = (const char **)(usr_data + 16);
        while (strcmp(*v12, v11) && strcmp(v10, v11))
        {
          uint64_t v10 = v12[2];
          v12 += 3;
          if (!v10) {
            goto LABEL_15;
          }
        }
        if (!ASN1_BIT_STRING_set_bit(v5, *((_DWORD *)v12 - 4), 1)) {
          break;
        }
        if (!*(v12 - 1)) {
          goto LABEL_15;
        }
        if (++v6 >= sk_num(nval)) {
          return v5;
        }
      }
      ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_bitst.c", 204);
LABEL_16:
      ASN1_BIT_STRING_free(v5);
      return 0;
    }
  }
  else
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_bitst.c", 194);
  }
  return v5;
}

const EVP_MD *EVP_md5(void)
{
  return (const EVP_MD *)&md5_md;
}

uint64_t init_0(uint64_t a1)
{
  return MD5_Init(*(_MD5_CTX **)(a1 + 24));
}

uint64_t update_0(uint64_t a1, const void *a2, size_t a3)
{
  return MD5_Update(*(_MD5_CTX **)(a1 + 24), a2, a3);
}

uint64_t final_0(uint64_t a1, unsigned __int8 *md)
{
  return MD5_Final(md, *(_MD5_CTX **)(a1 + 24));
}

int ASN1_item_digest(const ASN1_ITEM *it, const EVP_MD *type, void *data, unsigned __int8 *md, unsigned int *len)
{
  unsigned __int8 out = 0;
  int v8 = ASN1_item_i2d((ASN1_VALUE *)data, &out, it);
  if (!out) {
    return 0;
  }
  BOOL v9 = EVP_Digest(out, v8, md, len, type, 0) != 0;
  free(out);
  return v9;
}

void *__cdecl ASN1_item_dup(const ASN1_ITEM *it, void *x)
{
  unsigned __int8 out = 0;
  if (!x) {
    return 0;
  }
  int v3 = ASN1_item_i2d((ASN1_VALUE *)x, &out, it);
  if (!out)
  {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", 161);
    return 0;
  }
  int v6 = out;
  unsigned int v4 = ASN1_item_d2i(0, (const unsigned __int8 **)&v6, v3, it);
  free(out);
  return v4;
}

ASN1_STRING *__cdecl ASN1_item_pack(void *obj, const ASN1_ITEM *it, ASN1_OCTET_STRING **oct)
{
  if (!oct || (int v6 = *oct) == 0)
  {
    int v6 = ASN1_STRING_new();
    if (!v6)
    {
      ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", 178);
      return v6;
    }
  }
  free(v6->data);
  v6->unsigned int data = 0;
  int v7 = ASN1_item_i2d((ASN1_VALUE *)obj, &v6->data, it);
  v6->uint64_t length = v7;
  if (v7)
  {
    if (v6->data)
    {
      if (oct) {
        ASN1_OCTET_STRING *oct = v6;
      }
      return v6;
    }
    int v8 = 65;
    int v9 = 192;
  }
  else
  {
    int v8 = 112;
    int v9 = 188;
  }
  ERR_put_error(13, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", v9);
  if (!oct || v6 != *oct) {
    ASN1_STRING_free(v6);
  }
  return 0;
}

void *__cdecl ASN1_item_unpack(ASN1_STRING *oct, const ASN1_ITEM *it)
{
  iint n = oct->data;
  unint64_t v2 = ASN1_item_d2i(0, (const unsigned __int8 **)&in, oct->length, it);
  if (!v2) {
    ERR_put_error(13, 4095, 110, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", 213);
  }
  return v2;
}

int ASN1_item_sign(const ASN1_ITEM *it, X509_ALGOR *algor1, X509_ALGOR *algor2, ASN1_BIT_STRING *signature, void *data, EVP_PKEY *pkey, const EVP_MD *type)
{
  long long v16 = 0u;
  memset(&v15, 0, sizeof(v15));
  EVP_MD_CTX_init(&v15);
  if (EVP_DigestSignInit((uint64_t)&v15, 0, type, 0, (uint64_t)pkey)) {
    return ASN1_item_sign_ctx(it, algor1, algor2, signature, (ASN1_VALUE *)data, &v15);
  }
  EVP_MD_CTX_cleanup(&v15);
  return 0;
}

uint64_t ASN1_item_sign_ctx(const ASN1_ITEM *a1, X509_ALGOR *a2, X509_ALGOR *a3, ASN1_STRING *a4, ASN1_VALUE *a5, EVP_MD_CTX *ctx)
{
  *(void *)leint n = 0;
  unsigned __int8 out = 0;
  unint64_t v12 = EVP_MD_CTX_md(ctx);
  uint64_t v13 = EVP_PKEY_CTX_get0_pkey((uint64_t)ctx[1].digest);
  if (v12 && (uint64_t v14 = v13) != 0)
  {
    int n = 0;
    EVP_MD_CTX v15 = *(uint64_t (**)(EVP_MD_CTX *, const ASN1_ITEM *, ASN1_VALUE *, X509_ALGOR *, X509_ALGOR *, ASN1_STRING *))(*(void *)(v13 + 16) + 208);
    if (!v15) {
      goto LABEL_11;
    }
    int v16 = v15(ctx, a1, a5, a2, a3, a4);
    if (v16 == 1)
    {
      size_t v17 = 0;
      unsigned int v18 = 0;
      uint64_t v19 = 0;
      int length = a4->length;
LABEL_35:
      EVP_MD_CTX_cleanup(ctx);
      freezero(out, v18);
      freezero(v17, length);
      return v19;
    }
    if (v16 <= 0)
    {
      ERR_put_error(13, 4095, 6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", 263);
      goto LABEL_28;
    }
    if (v16 != 2)
    {
LABEL_19:
      int v27 = ASN1_item_i2d(a5, &out, a1);
      if (v27 >= 1)
      {
        unsigned int v18 = v27;
        int v28 = EVP_PKEY_size((EVP_PKEY *)v14);
        if (v28 >= 1)
        {
          int length = v28;
          uint64_t v29 = v28;
          size_t v17 = malloc_type_malloc(v28, 0x6D146B38uLL);
          if (v17)
          {
            *(void *)leint n = v29;
            if (EVP_DigestUpdate(ctx, out, v18) && EVP_DigestSignFinal((uint64_t)ctx, (uint64_t)v17, len))
            {
              if (!(*(void *)len >> 31))
              {
                ASN1_STRING_set0(a4, v17, len[0]);
                if (asn1_abs_set_unused_bits((uint64_t)a4, 0))
                {
                  size_t v17 = 0;
                  uint64_t v19 = len[0];
                  goto LABEL_35;
                }
                ERR_put_error(13, 4095, 13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", 321);
                size_t v17 = 0;
                goto LABEL_34;
              }
              int v30 = 155;
              int v31 = 313;
            }
            else
            {
              int v30 = 6;
              int v31 = 308;
            }
          }
          else
          {
            int v30 = 65;
            int v31 = 301;
          }
          ERR_put_error(13, 4095, v30, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", v31);
LABEL_34:
          uint64_t v19 = 0;
          goto LABEL_35;
        }
        size_t v17 = 0;
LABEL_30:
        int length = 0;
        goto LABEL_34;
      }
LABEL_28:
      size_t v17 = 0;
      unsigned int v18 = 0;
      goto LABEL_30;
    }
    if (*(void *)(v14 + 16))
    {
LABEL_11:
      int v23 = EVP_MD_type(v12);
      if (OBJ_find_sigid_by_algs(&n, v23, **(_DWORD **)(v14 + 16)))
      {
        if ((*(unsigned char *)(*(void *)(v14 + 16) + 8) & 4) != 0) {
          int v24 = 5;
        }
        else {
          int v24 = -1;
        }
        if (a2)
        {
          char v25 = OBJ_nid2obj(n);
          X509_ALGOR_set0(a2, v25, v24, 0);
        }
        if (a3)
        {
          char v26 = OBJ_nid2obj(n);
          X509_ALGOR_set0(a3, v26, v24, 0);
        }
        goto LABEL_19;
      }
    }
    int v21 = 198;
    int v22 = 272;
  }
  else
  {
    int v21 = 217;
    int v22 = 247;
  }
  ERR_put_error(13, 4095, v21, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", v22);
  return 0;
}

int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *algor1, ASN1_BIT_STRING *signature, void *data, EVP_PKEY *pkey)
{
  unsigned __int8 out = 0;
  if (!pkey)
  {
    int v10 = 67;
    int v11 = 345;
    goto LABEL_12;
  }
  if (signature->type != 3 || (signature->flags & 7) == 0)
  {
    long long v28 = 0u;
    memset(&ctx, 0, sizeof(ctx));
    *(void *)int n = 0;
    EVP_MD_CTX_init(&ctx);
    int v12 = OBJ_obj2nid(algor1->algorithm);
    if (OBJ_find_sigid_algs(v12, &n[1], n))
    {
      if (n[1])
      {
        uint64_t v13 = OBJ_nid2sn(n[1]);
        digestbyname = EVP_get_digestbyname(v13);
        if (!digestbyname)
        {
          int v18 = 161;
          int v19 = 380;
          goto LABEL_25;
        }
        EVP_MD_CTX v15 = digestbyname;
        if (EVP_PKEY_type(n[0]) != *(_DWORD *)pkey->pkey.ptr)
        {
          int v18 = 200;
          int v19 = 386;
          goto LABEL_25;
        }
        if (!EVP_DigestVerifyInit((uint64_t)&ctx, 0, v15, 0, (uint64_t)pkey))
        {
          int v16 = 391;
LABEL_30:
          ERR_put_error(13, 4095, 6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", v16);
          int v17 = 0;
          goto LABEL_26;
        }
      }
      else
      {
        int ptr = pkey->pkey.ptr;
        if (!ptr
          || (int v21 = (uint64_t (*)(EVP_MD_CTX *, const ASN1_ITEM *, void *, X509_ALGOR *, ASN1_BIT_STRING *, EVP_PKEY *))*((void *)ptr + 25)) == 0)
        {
          int v18 = 199;
          int v19 = 364;
          goto LABEL_25;
        }
        int v17 = v21(&ctx, it, data, algor1, signature, pkey);
        if (v17 != 2) {
          goto LABEL_26;
        }
      }
      int v22 = ASN1_item_i2d((ASN1_VALUE *)data, &out, it);
      if (out)
      {
        unsigned int v23 = v22;
        if (!EVP_DigestUpdate(&ctx, out, v22))
        {
          int v16 = 406;
          goto LABEL_30;
        }
        freezero(out, v23);
        if ((int)EVP_DigestVerifyFinal((uint64_t)&ctx, (uint64_t)signature->data, signature->length) <= 0)
        {
          int v16 = 415;
          goto LABEL_30;
        }
        int v17 = 1;
LABEL_26:
        EVP_MD_CTX_cleanup(&ctx);
        return v17;
      }
      int v18 = 65;
      int v19 = 401;
    }
    else
    {
      int v18 = 199;
      int v19 = 359;
    }
LABEL_25:
    ERR_put_error(13, 4095, v18, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", v19);
    int v17 = -1;
    goto LABEL_26;
  }
  int v10 = 220;
  int v11 = 351;
LABEL_12:
  ERR_put_error(13, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", v11);
  return -1;
}

uint64_t asn1_d2i_read_bio(BIO *a1, BUF_MEM **a2)
{
  unsigned int v4 = BUF_MEM_new();
  if (!v4)
  {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", 446);
    return 0xFFFFFFFFLL;
  }
  unsigned int v5 = v4;
  pint length = 0;
  pp = 0;
  *(void *)pclasunsigned int s = 0;
  ERR_clear_error();
  int v6 = 0;
  unint64_t v7 = 0;
  uint64_t v8 = 0;
  while (1)
  {
    while (1)
    {
      uint64_t v9 = v8 - v7;
      if (v8 - v7 <= 8)
      {
        if (__CFADD__(8 - v9, v8) || !BUF_MEM_grow_clean(v5, v7 + 8))
        {
          int v21 = 65;
          int v22 = 457;
LABEL_43:
          ERR_put_error(13, 4095, v21, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", v22);
LABEL_44:
          BUF_MEM_free(v5);
          return 0xFFFFFFFFLL;
        }
        int v10 = BIO_read(a1, &v5->data[v8], 8 - v9);
        if (v8 == v7 && v10 < 0)
        {
          int v21 = 142;
          int v22 = 462;
          goto LABEL_43;
        }
        if (v10 >= 1)
        {
          BOOL v11 = __CFADD__(v8, v10);
          v8 += v10;
          if (v11)
          {
            int v21 = 155;
            int v22 = 467;
            goto LABEL_43;
          }
          uint64_t v9 = v8 - v7;
        }
      }
      int v12 = (unsigned __int8 *)&v5->data[v7];
      pp = v12;
      char object = ASN1_get_object((const unsigned __int8 **)&pp, &plength, &pclass[1], pclass, v9);
      if (object < 0)
      {
        if ((ERR_peek_error() & 0xFFF) != 0x9B) {
          goto LABEL_44;
        }
        ERR_clear_error();
      }
      v7 += (int)pp - (int)v12;
      if (object)
      {
        int v20 = 1;
        goto LABEL_41;
      }
      uint64_t v14 = plength;
      if (v6)
      {
        if (!plength && !pclass[1]) {
          break;
        }
      }
      unint64_t v15 = plength - (v8 - v7);
      if (plength > v8 - v7)
      {
        BOOL v16 = __CFADD__(v8, v15);
        if (v15 >> 31 || v16)
        {
          int v21 = 155;
          int v22 = 514;
          goto LABEL_43;
        }
        if (v15)
        {
          unint64_t v17 = 0x4000;
          while (2)
          {
            if (v15 >= v17) {
              unint64_t v18 = v17;
            }
            else {
              unint64_t v18 = v15;
            }
            if (!BUF_MEM_grow_clean(v5, v18 + v8))
            {
              int v21 = 65;
              int v22 = 527;
              goto LABEL_43;
            }
            v15 -= v18;
            do
            {
              int v19 = BIO_read(a1, &v5->data[v8], v18);
              if (v19 <= 0)
              {
                int v21 = 142;
                int v22 = 534;
                goto LABEL_43;
              }
              v8 += v19;
              v18 -= v19;
            }
            while (v18);
            v17 <<= v17 < 0x3FFFFFFF;
            if (v15) {
              continue;
            }
            break;
          }
          uint64_t v14 = plength;
        }
      }
      BOOL v11 = __CFADD__(v14, v7);
      v7 += v14;
      if (v11)
      {
        int v21 = 155;
        int v22 = 549;
        goto LABEL_43;
      }
      if (v6 <= 0) {
        goto LABEL_50;
      }
    }
    if (v6 < 2) {
      break;
    }
    int v20 = -1;
LABEL_41:
    v6 += v20;
  }
LABEL_50:
  if (v7 >> 31)
  {
    int v21 = 155;
    int v22 = 561;
    goto LABEL_43;
  }
  *a2 = v5;
  return v7;
}

void *__cdecl ASN1_item_d2i_bio(const ASN1_ITEM *it, BIO *in, void *x)
{
  unsigned int data = 0;
  int v10 = 0;
  unsigned int v5 = asn1_d2i_read_bio(in, &v10);
  int v6 = v10;
  if ((v5 & 0x80000000) != 0)
  {
    unint64_t v7 = 0;
    uint64_t result = 0;
    if (!v10) {
      return result;
    }
  }
  else
  {
    unsigned int data = v10->data;
    unint64_t v7 = ASN1_item_d2i((ASN1_VALUE **)x, (const unsigned __int8 **)&data, v5, it);
  }
  BUF_MEM_free(v6);
  return v7;
}

void *__cdecl ASN1_item_d2i_fp(const ASN1_ITEM *it, FILE *in, void *x)
{
  int v6 = BIO_s_file();
  unint64_t v7 = BIO_new(v6);
  if (v7)
  {
    uint64_t v8 = v7;
    BIO_ctrl(v7, 106, 0, in);
    uint64_t v9 = ASN1_item_d2i_bio(it, v8, x);
    BIO_free(v8);
    return v9;
  }
  else
  {
    ERR_put_error(13, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", 602);
    return 0;
  }
}

int ASN1_item_i2d_bio(const ASN1_ITEM *it, BIO *out, void *x)
{
  outEVP_CIPHER_CTX a = 0;
  int v4 = ASN1_item_i2d((ASN1_VALUE *)x, &outa, it);
  if (outa)
  {
    int v5 = v4;
    int v6 = BIO_write(out, outa, v4);
    if (v6 == v5)
    {
LABEL_6:
      int v8 = 1;
    }
    else
    {
      int v7 = 0;
      while (v6 >= 1)
      {
        v7 += v6;
        v5 -= v6;
        int v6 = BIO_write(out, &outa[v7], v5);
        if (v6 == v5) {
          goto LABEL_6;
        }
      }
      int v8 = 0;
    }
    free(outa);
  }
  else
  {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", 619);
    return 0;
  }
  return v8;
}

int ASN1_item_i2d_fp(const ASN1_ITEM *it, FILE *out, void *x)
{
  int v6 = BIO_s_file();
  int v7 = BIO_new(v6);
  if (v7)
  {
    int v8 = v7;
    BIO_ctrl(v7, 106, 0, out);
    int v9 = ASN1_item_i2d_bio(it, v8, x);
    BIO_free(v8);
    return v9;
  }
  else
  {
    ERR_put_error(13, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_item.c", 645);
    return 0;
  }
}

void ERR_load_X509_strings(void)
{
  if (!ERR_func_error_string(X509_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&X509_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&X509_str_reasons);
  }
}

void ERR_load_X509V3_strings(void)
{
  if (!ERR_func_error_string(X509V3_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&X509V3_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&X509V3_str_reasons);
  }
}

const EVP_CIPHER *EVP_cast5_cbc(void)
{
  return (const EVP_CIPHER *)&cast5_cbc;
}

const EVP_CIPHER *EVP_cast5_cfb64(void)
{
  return (const EVP_CIPHER *)&cast5_cfb64;
}

const EVP_CIPHER *EVP_cast5_ofb(void)
{
  return (const EVP_CIPHER *)&cast5_ofb;
}

const EVP_CIPHER *EVP_cast5_ecb(void)
{
  return (const EVP_CIPHER *)&cast5_ecb;
}

uint64_t cast_init_key(const EVP_CIPHER_CTX *a1, const unsigned __int8 *a2)
{
  cipher_unsigned int data = (CAST_KEY *)a1->cipher_data;
  int v4 = EVP_CIPHER_CTX_key_length(a1);
  CAST_set_key(cipher_data, v4, a2);
  return 1;
}

uint64_t cast5_cbc_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t length)
{
  for (unint64_t i = length; i > 0x7FFFFFFFFFFFFEFFLL; out += 0x7FFFFFFFFFFFFF00)
  {
    CAST_cbc_encrypt(in, out, 0x7FFFFFFFFFFFFF00, *(const CAST_KEY **)(a1 + 120), (unsigned __int8 *)(a1 + 40), *(_DWORD *)(a1 + 16));
    i -= 0x7FFFFFFFFFFFFF00;
    in += 0x7FFFFFFFFFFFFF00;
  }
  if (i) {
    CAST_cbc_encrypt(in, out, i, *(const CAST_KEY **)(a1 + 120), (unsigned __int8 *)(a1 + 40), *(_DWORD *)(a1 + 16));
  }
  return 1;
}

uint64_t cast5_cfb64_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t a4)
{
  if (a4)
  {
    unint64_t v4 = a4;
    if (a4 >= 0x7FFFFFFFFFFFFF00) {
      unint64_t v8 = 0x7FFFFFFFFFFFFF00;
    }
    else {
      unint64_t v8 = a4;
    }
    int v9 = (unsigned __int8 *)(a1 + 40);
    int v10 = (int *)(a1 + 88);
    do
    {
      CAST_cfb64_encrypt(in, out, v8, *(const CAST_KEY **)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      in += v8;
      out += v8;
      v4 -= v8;
      if (v4 < v8) {
        unint64_t v8 = v4;
      }
    }
    while (v4);
  }
  return 1;
}

uint64_t cast5_ofb_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t length)
{
  for (unint64_t i = length; i > 0x7FFFFFFFFFFFFEFFLL; out += 0x7FFFFFFFFFFFFF00)
  {
    CAST_ofb64_encrypt(in, out, 0x7FFFFFFFFFFFFF00, *(const CAST_KEY **)(a1 + 120), (unsigned __int8 *)(a1 + 40), (int *)(a1 + 88));
    i -= 0x7FFFFFFFFFFFFF00;
    in += 0x7FFFFFFFFFFFFF00;
  }
  if (i) {
    CAST_ofb64_encrypt(in, out, i, *(const CAST_KEY **)(a1 + 120), (unsigned __int8 *)(a1 + 40), (int *)(a1 + 88));
  }
  return 1;
}

uint64_t cast5_ecb_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4 = *(int *)(*(void *)a1 + 4);
  unint64_t v5 = a4 - v4;
  if (a4 >= v4)
  {
    unint64_t v9 = 0;
    do
    {
      CAST_ecb_encrypt((const unsigned __int8 *)(a3 + v9), (unsigned __int8 *)(a2 + v9), *(const CAST_KEY **)(a1 + 120), *(_DWORD *)(a1 + 16));
      v9 += v4;
    }
    while (v9 <= v5);
  }
  return 1;
}

ASN1_OBJECT *__cdecl OBJ_dup(const ASN1_OBJECT *o)
{
  if (!o) {
    return 0;
  }
  if (o->flags)
  {
    unint64_t v2 = ASN1_OBJECT_new();
    if (!v2)
    {
      ERR_put_error(8, 4095, 13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/objects/obj_lib.c", 84);
      return v2;
    }
    int v3 = (unsigned __int8 *)malloc_type_malloc(o->length, 0x40F1F4B9uLL);
    unint64_t v4 = v3;
    if (v3)
    {
      unsigned int data = o->data;
      if (data) {
        memcpy(v3, data, o->length);
      }
      v2->unsigned int data = v4;
      *(void *)&v2->nichar d = *(void *)&o->nid;
      v2->sint n = 0;
      v2->lint n = 0;
      lint n = o->ln;
      if (!ln)
      {
        unint64_t v8 = 0;
        goto LABEL_14;
      }
      int v7 = strdup(ln);
      unint64_t v8 = v7;
      if (v7)
      {
        v2->lint n = v7;
LABEL_14:
        if (!o->sn)
        {
LABEL_17:
          v2->flagunsigned int s = o->flags | 0xD;
          return v2;
        }
        unint64_t v9 = strdup(o->sn);
        if (v9)
        {
          v2->sint n = v9;
          goto LABEL_17;
        }
      }
    }
    else
    {
      unint64_t v8 = 0;
    }
    ERR_put_error(8, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/objects/obj_lib.c", 115);
    free(v8);
    free(v4);
    free(v2);
    return 0;
  }
  return (ASN1_OBJECT *)o;
}

int OBJ_cmp(const ASN1_OBJECT *a, const ASN1_OBJECT *b)
{
  size_t length = a->length;
  if (length == b->length) {
    return memcmp(a->data, b->data, length);
  }
  else {
    return length - b->length;
  }
}

void RC4(RC4_KEY *key, unint64_t len, const unsigned __int8 *indata, unsigned __int8 *outdata)
{
  int v4 = *(_DWORD *)&key->x;
  int v5 = *(_DWORD *)&key->data[2];
  int v6 = &key->data[6];
  if (((outdata | indata) & 7) != 0)
  {
    if (len >= 8)
    {
      unint64_t v7 = len >> 3;
      do
      {
        int v8 = *(_DWORD *)&v6[4 * (v4 + 1)];
        unsigned __int8 v9 = v8 + v5;
        int v10 = *(_DWORD *)&v6[4 * v9];
        *(_DWORD *)&v6[4 * (v4 + 1)] = v10;
        *(_DWORD *)&v6[4 * v9] = v8;
        *outunsigned int data = *indata ^ *(_DWORD *)&v6[4 * (v10 + v8)];
        int v11 = *(_DWORD *)&v6[4 * (v4 + 2)];
        unsigned __int8 v12 = v11 + v9;
        int v13 = *(_DWORD *)&v6[4 * v12];
        *(_DWORD *)&v6[4 * (v4 + 2)] = v13;
        *(_DWORD *)&v6[4 * v12] = v11;
        outdata[1] = indata[1] ^ *(_DWORD *)&v6[4 * (v13 + v11)];
        int v14 = *(_DWORD *)&v6[4 * (v4 + 3)];
        unsigned __int8 v15 = v14 + v12;
        int v16 = *(_DWORD *)&v6[4 * v15];
        *(_DWORD *)&v6[4 * (v4 + 3)] = v16;
        *(_DWORD *)&v6[4 * v15] = v14;
        outunsigned char data[2] = indata[2] ^ *(_DWORD *)&v6[4 * (v16 + v14)];
        int v17 = *(_DWORD *)&v6[4 * (v4 + 4)];
        unsigned __int8 v18 = v17 + v15;
        int v19 = *(_DWORD *)&v6[4 * v18];
        *(_DWORD *)&v6[4 * (v4 + 4)] = v19;
        *(_DWORD *)&v6[4 * v18] = v17;
        outvoid data[3] = indata[3] ^ *(_DWORD *)&v6[4 * (v19 + v17)];
        int v20 = *(_DWORD *)&v6[4 * (v4 + 5)];
        unsigned __int8 v21 = v20 + v18;
        int v22 = *(_DWORD *)&v6[4 * v21];
        *(_DWORD *)&v6[4 * (v4 + 5)] = v22;
        *(_DWORD *)&v6[4 * v21] = v20;
        outdata[4] = indata[4] ^ *(_DWORD *)&v6[4 * (v22 + v20)];
        int v23 = *(_DWORD *)&v6[4 * (v4 + 6)];
        unsigned __int8 v24 = v23 + v21;
        int v25 = *(_DWORD *)&v6[4 * v24];
        *(_DWORD *)&v6[4 * (v4 + 6)] = v25;
        *(_DWORD *)&v6[4 * v24] = v23;
        outdata[5] = indata[5] ^ *(_DWORD *)&v6[4 * (v25 + v23)];
        int v26 = *(_DWORD *)&v6[4 * (v4 + 7)];
        unsigned __int8 v27 = v26 + v24;
        int v28 = *(_DWORD *)&v6[4 * v27];
        *(_DWORD *)&v6[4 * (v4 + 7)] = v28;
        *(_DWORD *)&v6[4 * v27] = v26;
        outdata[6] = indata[6] ^ *(_DWORD *)&v6[4 * (v28 + v26)];
        int v4 = (v4 + 8);
        int v29 = *(_DWORD *)&v6[4 * v4];
        int v5 = (v29 + v27);
        int v30 = *(_DWORD *)&v6[4 * v5];
        *(_DWORD *)&v6[4 * v4] = v30;
        *(_DWORD *)&v6[4 * v5] = v29;
        int v31 = *(_DWORD *)&v6[4 * (v30 + v29)];
        int v32 = indata + 8;
        outdata[7] = indata[7] ^ v31;
        outdata += 8;
        indata += 8;
        --v7;
      }
      while (v7);
      inunsigned int data = v32;
    }
  }
  else
  {
    while (len >= 8)
    {
      int v33 = *(_DWORD *)&v6[4 * (v4 + 1)];
      unsigned __int8 v34 = v33 + v5;
      int v35 = *(_DWORD *)&v6[4 * v34];
      *(_DWORD *)&v6[4 * v34] = v33;
      *(_DWORD *)&v6[4 * (v4 + 1)] = v35;
      uint64_t v36 = *(unsigned int *)&v6[4 * (v35 + v33)];
      int v37 = *(_DWORD *)&v6[4 * (v4 + 2)];
      unsigned __int8 v38 = v37 + v34;
      int v39 = *(_DWORD *)&v6[4 * v38];
      *(_DWORD *)&v6[4 * v38] = v37;
      *(_DWORD *)&v6[4 * (v4 + 2)] = v39;
      uint64_t v40 = *(unsigned int *)&v6[4 * (v39 + v37)];
      int v41 = *(_DWORD *)&v6[4 * (v4 + 3)];
      unsigned __int8 v42 = v41 + v38;
      int v43 = *(_DWORD *)&v6[4 * v42];
      *(_DWORD *)&v6[4 * v42] = v41;
      *(_DWORD *)&v6[4 * (v4 + 3)] = v43;
      unint64_t v44 = v36 | (v40 << 8) | ((unint64_t)*(unsigned int *)&v6[4 * (v43 + v41)] << 16);
      int v45 = *(_DWORD *)&v6[4 * (v4 + 4)];
      unsigned __int8 v46 = v45 + v42;
      int v47 = *(_DWORD *)&v6[4 * v46];
      *(_DWORD *)&v6[4 * v46] = v45;
      *(_DWORD *)&v6[4 * (v4 + 4)] = v47;
      uint64_t v48 = *(unsigned int *)&v6[4 * (v47 + v45)];
      int v49 = *(_DWORD *)&v6[4 * (v4 + 5)];
      unsigned __int8 v50 = v49 + v46;
      int v51 = *(_DWORD *)&v6[4 * v50];
      *(_DWORD *)&v6[4 * v50] = v49;
      *(_DWORD *)&v6[4 * (v4 + 5)] = v51;
      unint64_t v52 = v44 | (v48 << 24) | ((unint64_t)*(unsigned int *)&v6[4 * (v51 + v49)] << 32);
      int v53 = *(_DWORD *)&v6[4 * (v4 + 6)];
      unsigned __int8 v54 = v53 + v50;
      int v55 = *(_DWORD *)&v6[4 * v54];
      *(_DWORD *)&v6[4 * v54] = v53;
      *(_DWORD *)&v6[4 * (v4 + 6)] = v55;
      uint64_t v56 = *(unsigned int *)&v6[4 * (v55 + v53)];
      int v57 = *(_DWORD *)&v6[4 * (v4 + 7)];
      unsigned __int8 v58 = v57 + v54;
      int v59 = *(_DWORD *)&v6[4 * v58];
      *(_DWORD *)&v6[4 * v58] = v57;
      uint64_t v60 = *(void *)indata;
      indata += 8;
      *(_DWORD *)&v6[4 * (v4 + 7)] = v59;
      unint64_t v61 = v52 | (v56 << 40) | ((unint64_t)*(unsigned int *)&v6[4 * (v59 + v57)] << 48);
      int v4 = (v4 + 8);
      LODWORD(v56) = *(_DWORD *)&v6[4 * v4];
      int v5 = (v56 + v58);
      int v62 = *(_DWORD *)&v6[4 * v5];
      *(_DWORD *)&v6[4 * v5] = v56;
      *(_DWORD *)&v6[4 * v4] = v62;
      *(void *)outunsigned int data = (v61 | ((unint64_t)*(unsigned int *)&v6[4 * (v62 + v56)] << 56)) ^ v60;
      outdata += 8;
      len -= 8;
    }
  }
  unint64_t v63 = len & 7;
  if ((len & 7) != 0)
  {
    int v64 = (v4 + 1);
    int v65 = *(_DWORD *)&v6[4 * (v4 + 1)];
    char v66 = v65 + v5;
    int v5 = (v65 + v5);
    int v67 = *(_DWORD *)&v6[4 * v5];
    *(_DWORD *)&v6[4 * (v4 + 1)] = v67;
    *(_DWORD *)&v6[4 * v5] = v65;
    *outunsigned int data = *indata ^ v6[4 * (v67 + v65)];
    if (v63 == 1) {
      goto LABEL_15;
    }
    int v64 = (v4 + 2);
    int v68 = *(_DWORD *)&v6[4 * (v4 + 2)];
    unsigned __int8 v69 = v68 + v66;
    int v5 = v69;
    int v70 = *(_DWORD *)&v6[4 * v69];
    *(_DWORD *)&v6[4 * (v4 + 2)] = v70;
    *(_DWORD *)&v6[4 * v69] = v68;
    outdata[1] = indata[1] ^ v6[4 * (v70 + v68)];
    if (v63 == 2) {
      goto LABEL_15;
    }
    int v64 = (v4 + 3);
    int v71 = *(_DWORD *)&v6[4 * (v4 + 3)];
    unsigned __int8 v72 = v71 + v69;
    int v5 = v72;
    int v73 = *(_DWORD *)&v6[4 * v72];
    *(_DWORD *)&v6[4 * (v4 + 3)] = v73;
    *(_DWORD *)&v6[4 * v72] = v71;
    outunsigned char data[2] = indata[2] ^ v6[4 * (v73 + v71)];
    if (v63 == 3) {
      goto LABEL_15;
    }
    int v64 = (v4 + 4);
    int v74 = *(_DWORD *)&v6[4 * (v4 + 4)];
    unsigned __int8 v75 = v74 + v72;
    int v5 = v75;
    int v76 = *(_DWORD *)&v6[4 * v75];
    *(_DWORD *)&v6[4 * (v4 + 4)] = v76;
    *(_DWORD *)&v6[4 * v75] = v74;
    outvoid data[3] = indata[3] ^ v6[4 * (v76 + v74)];
    if (v63 == 4) {
      goto LABEL_15;
    }
    int v64 = (v4 + 5);
    int v77 = *(_DWORD *)&v6[4 * (v4 + 5)];
    unsigned __int8 v78 = v77 + v75;
    int v5 = v78;
    int v79 = *(_DWORD *)&v6[4 * v78];
    *(_DWORD *)&v6[4 * (v4 + 5)] = v79;
    *(_DWORD *)&v6[4 * v78] = v77;
    outdata[4] = indata[4] ^ v6[4 * (v79 + v77)];
    if (v63 == 5) {
      goto LABEL_15;
    }
    int v64 = (v4 + 6);
    int v80 = *(_DWORD *)&v6[4 * (v4 + 6)];
    unsigned __int8 v81 = v80 + v78;
    int v5 = v81;
    int v82 = *(_DWORD *)&v6[4 * v81];
    *(_DWORD *)&v6[4 * (v4 + 6)] = v82;
    *(_DWORD *)&v6[4 * v81] = v80;
    outdata[5] = indata[5] ^ v6[4 * (v82 + v80)];
    if (v63 == 6)
    {
LABEL_15:
      int v4 = v64;
    }
    else
    {
      int v4 = (v4 + 7);
      int v83 = *(_DWORD *)&v6[4 * v4];
      int v5 = (v83 + v81);
      int v84 = *(_DWORD *)&v6[4 * (v83 + v81)];
      *(_DWORD *)&v6[4 * v4] = v84;
      *(_DWORD *)&v6[4 * (v83 + v81)] = v83;
      outdata[6] = indata[6] ^ v6[4 * (v84 + v83)];
    }
  }
  *(_DWORD *)&key->x = v4;
  *(_DWORD *)&key->unsigned char data[2] = v5;
}

uint64_t gost2814789_set_asn1_params(uint64_t a1, ASN1_TYPE *a2)
{
  uint64_t v4 = *(void *)(a1 + 120);
  int v5 = (ASN1_OCTET_STRING **)GOST_CIPHER_PARAMS_new();
  if (v5)
  {
    int v6 = v5;
    if (ASN1_OCTET_STRING_set(*v5, (const unsigned __int8 *)(a1 + 40), *(_DWORD *)(*(void *)a1 + 12)))
    {
      ASN1_OBJECT_free((ASN1_OBJECT *)v6[1]);
      v6[1] = (ASN1_OCTET_STRING *)OBJ_nid2obj(*(_DWORD *)(v4 + 4136));
      int v7 = i2d_GOST_CIPHER_PARAMS((ASN1_VALUE *)v6, 0);
      int v8 = (unsigned __int8 *)malloc_type_malloc(v7, 0x9BC0FFCuLL);
      unsigned __int8 v15 = v8;
      if (v8)
      {
        unsigned __int8 v9 = v8;
        i2d_GOST_CIPHER_PARAMS((ASN1_VALUE *)v6, &v15);
        GOST_CIPHER_PARAMS_free((ASN1_VALUE *)v6);
        int v10 = ASN1_OCTET_STRING_new();
        if (v10)
        {
          int v11 = v10;
          if (ASN1_OCTET_STRING_set(v10, v9, v7))
          {
            free(v9);
            ASN1_TYPE_set(a2, 16, v11);
            return 1;
          }
          ASN1_OCTET_STRING_free(v11);
          free(v9);
          int v13 = 13;
          int v14 = 142;
        }
        else
        {
          free(v9);
          int v13 = 65;
          int v14 = 136;
        }
      }
      else
      {
        GOST_CIPHER_PARAMS_free((ASN1_VALUE *)v6);
        int v13 = 65;
        int v14 = 127;
      }
    }
    else
    {
      GOST_CIPHER_PARAMS_free((ASN1_VALUE *)v6);
      int v13 = 13;
      int v14 = 117;
    }
  }
  else
  {
    int v13 = 65;
    int v14 = 112;
  }
  ERR_put_error(50, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_gost2814789.c", v14);
  return 0;
}

uint64_t gost2814789_get_asn1_params(void *a1, ASN1_TYPE *a)
{
  uint64_t v4 = a1[15];
  if (ASN1_TYPE_get(a) == 16)
  {
    int ptr = a->value.ptr;
    int v11 = (const unsigned __int8 *)*((void *)ptr + 1);
    int v6 = d2i_GOST_CIPHER_PARAMS(0, &v11, *(int *)ptr);
    int v7 = (const ASN1_OBJECT **)v6;
    size_t v8 = **(int **)v6;
    if (v8 == *(_DWORD *)(*a1 + 12))
    {
      int v9 = OBJ_obj2nid(*((const ASN1_OBJECT **)v6 + 1));
      if (Gost2814789_set_sbox(v4, v9))
      {
        *(_DWORD *)(v4 + 4136) = OBJ_obj2nid(v7[1]);
        memcpy(a1 + 3, (*v7)->ln, v8);
        memcpy(a1 + 5, (*v7)->ln, v8);
        GOST_CIPHER_PARAMS_free((ASN1_VALUE *)v7);
        return 1;
      }
      GOST_CIPHER_PARAMS_free((ASN1_VALUE *)v7);
    }
    else
    {
      GOST_CIPHER_PARAMS_free(v6);
      ERR_put_error(50, 4095, 103, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_gost2814789.c", 171);
    }
  }
  return 0xFFFFFFFFLL;
}

void *EVP_gost2814789_ecb()
{
  return &gost2814789_ecb;
}

void *EVP_gost2814789_cfb64()
{
  return &gost2814789_cfb64;
}

void *EVP_gost2814789_cnt()
{
  return &gost2814789_cnt;
}

uint64_t gost2814789_init_key(uint64_t a1, uint64_t a2)
{
  return Gost2814789_set_key(*(void *)(a1 + 120), a2, 8 * *(_DWORD *)(a1 + 104));
}

uint64_t gost2814789_ecb_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4 = *(int *)(*(void *)a1 + 4);
  unint64_t v5 = a4 - v4;
  if (a4 >= v4)
  {
    unint64_t v9 = 0;
    do
    {
      Gost2814789_ecb_encrypt((int *)(a3 + v9), (int *)(a2 + v9), *(void *)(a1 + 120), *(_DWORD *)(a1 + 16));
      v9 += v4;
    }
    while (v9 <= v5);
  }
  return 1;
}

uint64_t gost2814789_ctl(uint64_t a1, int a2, int a3, _DWORD *a4)
{
  uint64_t v4 = *(void *)(a1 + 120);
  if (!a2)
  {
    *(_DWORD *)(v4 + 4136) = 824;
    int v6 = 824;
    return Gost2814789_set_sbox(v4, v6);
  }
  if (a2 == 25)
  {
    int v6 = a3;
    return Gost2814789_set_sbox(v4, v6);
  }
  if (a2 != 7) {
    return 0xFFFFFFFFLL;
  }
  if (!a4) {
    return 0;
  }
  *a4 = 810;
  return 1;
}

uint64_t gost2814789_cfb64_cipher(uint64_t a1, unsigned char *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v4 = a4;
    if (a4 >= 0x4000000000000000) {
      unint64_t v8 = 0x4000000000000000;
    }
    else {
      unint64_t v8 = a4;
    }
    unint64_t v9 = (int *)(a1 + 40);
    int v10 = (unsigned int *)(a1 + 88);
    do
    {
      Gost2814789_cfb64_encrypt(a3, a2, v8, *(void *)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      a3 += v8;
      a2 += v8;
      v4 -= v8;
      if (v4 < v8) {
        unint64_t v8 = v4;
      }
    }
    while (v4);
  }
  return 1;
}

uint64_t gost2814789_cnt_cipher(uint64_t a1, unsigned char *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v8 = *(void *)(a1 + 120);
  if (!(a4 >> 62))
  {
    unint64_t v9 = a4;
    if (!a4) {
      return 1;
    }
    goto LABEL_4;
  }
  do
  {
    Gost2814789_cnt_encrypt(a3, a2, 0x4000000000000000uLL, v8, (int *)(a1 + 40), (int *)(a1 + 56), (unsigned int *)(a1 + 88));
    unint64_t v9 = v4 - 0x4000000000000000;
    a3 += 0x4000000000000000;
    a2 += 0x4000000000000000;
    BOOL v10 = v4 < 0x4000000000000000;
    v4 -= 0x4000000000000000;
  }
  while (v10);
  if (v9) {
LABEL_4:
  }
    Gost2814789_cnt_encrypt(a3, a2, v9, v8, (int *)(a1 + 40), (int *)(a1 + 56), (unsigned int *)(a1 + 88));
  return 1;
}

uint64_t BIO_get_new_index()
{
  LODWORD(result) = CRYPTO_add_lock((int *)&BIO_get_new_index_bio_type_index, 1, 21, 0, 0);
  if ((int)result > 255) {
    return 0xFFFFFFFFLL;
  }
  else {
    return result;
  }
}

BIO *__cdecl BIO_new(BIO_METHOD *type)
{
  unint64_t v2 = (BIO *)malloc_type_malloc(0x70uLL, 0x10F0040CB86C5B6uLL);
  int v3 = v2;
  if (v2)
  {
    if (!BIO_set(v2, type))
    {
      free(v3);
      return 0;
    }
  }
  else
  {
    ERR_put_error(32, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bio_lib.c", 141);
  }
  return v3;
}

int BIO_set(BIO *a, BIO_METHOD *type)
{
  a->methochar d = type;
  a->callbacuint64_t k = 0;
  a->cb_arg = 0;
  *(void *)&a->init = 0;
  a->flagunsigned int s = 0;
  *(_OWORD *)&a->retry_reasoint n = xmmword_23C701D90;
  a->prev_int bio = 0;
  *(void *)&a->referenceunsigned int s = 0;
  a->next_int bio = 0;
  int v4 = 1;
  LODWORD(a->num_read) = 1;
  p_dummy = &a->ex_data.dummy;
  a->num_write = 0;
  a->ex_data.suint64_t k = 0;
  CRYPTO_new_ex_data(0, a, (CRYPTO_EX_DATA *)&a->ex_data.dummy);
  create = type->create;
  if (create && !((unsigned int (*)(BIO *))create)(a))
  {
    CRYPTO_free_ex_data(0, a, (CRYPTO_EX_DATA *)p_dummy);
    return 0;
  }
  return v4;
}

int BIO_free(BIO *a)
{
  if (!a) {
    return (int)a;
  }
  uint64_t v1 = a;
  if (CRYPTO_add_lock((int *)&a->num_read, -1, 21, 0, 0) > 0)
  {
LABEL_13:
    LODWORD(a) = 1;
    return (int)a;
  }
  callbacuint64_t k = v1->callback;
  cb_arg = v1->cb_arg;
  if (callback)
  {
    if (!cb_arg)
    {
      LODWORD(a) = ((uint64_t (*)(BIO *, uint64_t, void, void, void, uint64_t))callback)(v1, 1, 0, 0, 0, 1);
      goto LABEL_8;
    }
  }
  else if (!cb_arg)
  {
    goto LABEL_9;
  }
  LODWORD(a) = ((uint64_t (*)(BIO *, uint64_t, void, void, void, void, uint64_t, void))cb_arg)(v1, 1, 0, 0, 0, 0, 1, 0);
LABEL_8:
  if ((int)a >= 1)
  {
LABEL_9:
    CRYPTO_free_ex_data(0, v1, (CRYPTO_EX_DATA *)&v1->ex_data.dummy);
    if (v1->method)
    {
      destroy = v1->method->destroy;
      if (destroy) {
        ((void (*)(BIO *))destroy)(v1);
      }
    }
    free(v1);
    goto LABEL_13;
  }
  return (int)a;
}

uint64_t bio_call_callback(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  char v9 = a2;
  BOOL v10 = *(uint64_t (**)(void))(a1 + 16);
  if (v10)
  {
    return v10();
  }
  int v12 = a2 & 0xFFFFFF7F;
  if ((a2 & 0xFFFFFF7E) == 2 || v12 == 5)
  {
    if (a4 >> 31) {
      return -1;
    }
    a5 = a4;
  }
  if (a7 >= 1 && (a2 & 0x80) != 0 && v12 != 6)
  {
    a7 = *a8;
    if ((unint64_t)*a8 >> 31) {
      return -1;
    }
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t, uint64_t, uint64_t))(a1 + 8))(a1, a2, a3, a5, a6, a7);
  if (result >= 1 && v9 < 0 && v12 != 6)
  {
    *a8 = result;
    return 1;
  }
  return result;
}

BOOL BIO_up_ref(uint64_t a1)
{
  return CRYPTO_add_lock((int *)(a1 + 80), 1, 21, 0, 0) > 1;
}

uint64_t BIO_get_data(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t BIO_set_data(uint64_t result, uint64_t a2)
{
  *(void *)(result + 56) = a2;
  return result;
}

uint64_t BIO_get_init(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t BIO_set_init(uint64_t result, int a2)
{
  *(_DWORD *)(result + 32) = a2;
  return result;
}

uint64_t BIO_get_shutdown(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t BIO_set_shutdown(uint64_t result, int a2)
{
  *(_DWORD *)(result + 36) = a2;
  return result;
}

void BIO_clear_flags(BIO *b, int flags)
{
  b->num &= ~flags;
}

int BIO_test_flags(const BIO *b, int flags)
{
  return b->num & flags;
}

void BIO_set_flags(BIO *b, int flags)
{
  b->num |= flags;
}

uint64_t (__cdecl *__cdecl BIO_get_callback(const BIO *b))(bio_st *, int, const char *, int, uint64_t, uint64_t)
{
  return b->callback;
}

void BIO_set_callback(BIO *b, uint64_t (__cdecl *callback)(bio_st *, int, const char *, int, uint64_t, uint64_t))
{
  b->callbacuint64_t k = callback;
}

uint64_t BIO_get_callback_ex(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t BIO_set_callback_ex(uint64_t result, uint64_t a2)
{
  *(void *)(result + 16) = a2;
  return result;
}

void BIO_set_callback_arg(BIO *b, char *arg)
{
  *(void *)&b->init = arg;
}

char *__cdecl BIO_get_callback_arg(const BIO *b)
{
  return *(char **)&b->init;
}

const char *__cdecl BIO_method_name(const BIO *b)
{
  return b->method->name;
}

int BIO_method_type(const BIO *b)
{
  return b->method->type;
}

int BIO_read(BIO *b, void *data, int len)
{
  unint64_t v13 = 0;
  if (!b)
  {
    int v8 = 67;
    int v9 = 327;
LABEL_17:
    ERR_put_error(32, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bio_lib.c", v9);
    return -1;
  }
  uint64_t v3 = *(void *)&len;
  if (len < 1) {
    return 0;
  }
  if (!data)
  {
    int v8 = 67;
    int v9 = 335;
    goto LABEL_17;
  }
  if (!b->method || !b->method->bread)
  {
    int v10 = 121;
    int v11 = 340;
LABEL_15:
    ERR_put_error(32, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bio_lib.c", v11);
    return -2;
  }
  if (b->callback || b->cb_arg)
  {
    int result = bio_call_callback((uint64_t)b, 2, (uint64_t)data, len, 0, 0, 1, 0);
    if (result < 1) {
      return result;
    }
  }
  if (!b->flags)
  {
    int v10 = 120;
    int v11 = 351;
    goto LABEL_15;
  }
  int result = ((uint64_t (*)(BIO *, void *, uint64_t))b->method->bread)(b, data, v3);
  if (result < 1)
  {
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v7 = result;
    unint64_t v13 = result;
  }
  b->num_write += v7;
  if (b->callback || b->cb_arg)
  {
    if (result > 0) {
      int v12 = 1;
    }
    else {
      int v12 = result;
    }
    int result = bio_call_callback((uint64_t)b, 130, (uint64_t)data, v3, 0, 0, v12, (uint64_t *)&v13);
  }
  if (result >= 1)
  {
    int result = v13;
    if (v13 >> 31)
    {
      int v8 = 130;
      int v9 = 367;
      goto LABEL_17;
    }
  }
  return result;
}

int BIO_write(BIO *b, const void *data, int len)
{
  int result = 0;
  unint64_t v13 = 0;
  if (!b) {
    return result;
  }
  uint64_t v5 = *(void *)&len;
  if (len < 1) {
    return result;
  }
  if (!data)
  {
    int v10 = 67;
    int v11 = 391;
LABEL_15:
    ERR_put_error(32, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bio_lib.c", v11);
    return -1;
  }
  if (!b->method || !b->method->bwrite)
  {
    int v8 = 121;
    int v9 = 396;
LABEL_13:
    ERR_put_error(32, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bio_lib.c", v9);
    return -2;
  }
  if (b->callback || b->cb_arg)
  {
    int result = bio_call_callback((uint64_t)b, 3, (uint64_t)data, len, 0, 0, 1, 0);
    if (result < 1) {
      return result;
    }
  }
  if (!b->flags)
  {
    int v8 = 120;
    int v9 = 407;
    goto LABEL_13;
  }
  int result = ((uint64_t (*)(BIO *, const void *, uint64_t))b->method->bwrite)(b, data, v5);
  if (result < 1)
  {
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v7 = result;
    unint64_t v13 = result;
  }
  b->ex_data.suint64_t k = (STACK *)((char *)b->ex_data.sk + v7);
  if (b->callback || b->cb_arg)
  {
    if (result > 0) {
      int v12 = 1;
    }
    else {
      int v12 = result;
    }
    int result = bio_call_callback((uint64_t)b, 131, (uint64_t)data, v5, 0, 0, v12, (uint64_t *)&v13);
  }
  if (result >= 1)
  {
    int result = v13;
    if (v13 >> 31)
    {
      int v10 = 130;
      int v11 = 423;
      goto LABEL_15;
    }
  }
  return result;
}

int BIO_puts(BIO *bp, const char *buf)
{
  unint64_t v11 = 0;
  if (!bp || !bp->method || !bp->method->bputs)
  {
    int v7 = 121;
    int v8 = 440;
LABEL_8:
    ERR_put_error(32, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bio_lib.c", v8);
    return -2;
  }
  callbacuint64_t k = bp->callback;
  cb_arg = bp->cb_arg;
  if (callback)
  {
    if (!cb_arg)
    {
      int result = ((uint64_t (*)(BIO *, uint64_t, const char *, void, void, uint64_t))callback)(bp, 4, buf, 0, 0, 1);
      goto LABEL_12;
    }
  }
  else if (!cb_arg)
  {
    goto LABEL_13;
  }
  int result = ((uint64_t (*)(BIO *, uint64_t, const char *, void, void, void, uint64_t, void))cb_arg)(bp, 4, buf, 0, 0, 0, 1, 0);
LABEL_12:
  if (result < 1) {
    return result;
  }
LABEL_13:
  if (!bp->flags)
  {
    int v7 = 120;
    int v8 = 451;
    goto LABEL_8;
  }
  int result = ((uint64_t (*)(BIO *, const char *))bp->method->bputs)(bp, buf);
  if (result < 1)
  {
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t v9 = result;
    unint64_t v11 = result;
  }
  bp->ex_data.suint64_t k = (STACK *)((char *)bp->ex_data.sk + v9);
  if (bp->callback || bp->cb_arg)
  {
    if (result > 0) {
      int v10 = 1;
    }
    else {
      int v10 = result;
    }
    int result = bio_call_callback((uint64_t)bp, 132, (uint64_t)buf, 0, 0, 0, v10, (uint64_t *)&v11);
  }
  if (result >= 1)
  {
    int result = v11;
    if (v11 >> 31)
    {
      ERR_put_error(32, 4095, 130, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bio_lib.c", 467);
      return -1;
    }
  }
  return result;
}

int BIO_gets(BIO *bp, char *buf, int size)
{
  unint64_t v10 = 0;
  if (!bp || !bp->method || !bp->method->bgets)
  {
    int v8 = 121;
    int v9 = 484;
LABEL_19:
    ERR_put_error(32, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bio_lib.c", v9);
    return -2;
  }
  uint64_t v4 = *(void *)&size;
  if (*(_OWORD *)&bp->callback != 0)
  {
    int result = bio_call_callback((uint64_t)bp, 5, (uint64_t)buf, size, 0, 0, 1, 0);
    if (result < 1) {
      return result;
    }
  }
  if (!bp->flags)
  {
    int v8 = 120;
    int v9 = 495;
    goto LABEL_19;
  }
  int result = ((uint64_t (*)(BIO *, char *, uint64_t))bp->method->bgets)(bp, buf, v4);
  if (result >= 1) {
    unint64_t v10 = result;
  }
  if (bp->callback || bp->cb_arg)
  {
    if (result > 0) {
      int v7 = 1;
    }
    else {
      int v7 = result;
    }
    int result = bio_call_callback((uint64_t)bp, 133, (uint64_t)buf, (int)v4, 0, 0, v7, (uint64_t *)&v10);
  }
  if (result >= 1)
  {
    int result = v10;
    if (v10 >> 31)
    {
      ERR_put_error(32, 4095, 130, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bio_lib.c", 509);
      return -1;
    }
  }
  return result;
}

int BIO_indent(BIO *b, int indent, int max)
{
  if (indent >= max) {
    int v4 = max;
  }
  else {
    int v4 = indent;
  }
  int v5 = (v4 & ~(v4 >> 31)) + 1;
  while (--v5)
  {
    if (BIO_puts(b, " ") != 1) {
      return 0;
    }
  }
  return 1;
}

uint64_t BIO_int_ctrl(BIO *bp, int cmd, uint64_t larg, int iarg)
{
  int parg = iarg;
  return BIO_ctrl(bp, cmd, larg, &parg);
}

uint64_t BIO_ctrl(BIO *bp, int cmd, uint64_t larg, void *parg)
{
  if (!bp) {
    return 0;
  }
  if (!bp->method || (ctrl = bp->method->ctrl) == 0)
  {
    ERR_put_error(32, 4095, 121, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bio_lib.c", 561);
    return -2;
  }
  unint64_t v8 = *(void *)&cmd;
  callbacuint64_t k = bp->callback;
  cb_arg = bp->cb_arg;
  if (callback)
  {
    if (!cb_arg)
    {
      uint64_t v11 = ((uint64_t (*)(BIO *, uint64_t, void *, void, uint64_t, uint64_t))callback)(bp, 6, parg, *(void *)&cmd, larg, 1);
      goto LABEL_12;
    }
LABEL_11:
    uint64_t v11 = ((uint64_t (*)(BIO *, uint64_t, void *, void, void, uint64_t, uint64_t, void))cb_arg)(bp, 6, parg, 0, *(void *)&cmd, larg, 1, 0);
LABEL_12:
    uint64_t v12 = v11;
    if (v11 >= 1)
    {
      ctrl = bp->method->ctrl;
      goto LABEL_14;
    }
    return v12;
  }
  if (cb_arg) {
    goto LABEL_11;
  }
LABEL_14:
  uint64_t v12 = ((uint64_t (*)(BIO *, unint64_t, uint64_t, void *))ctrl)(bp, v8, larg, parg);
  if (!bp->callback && !bp->cb_arg) {
    return v12;
  }
  return bio_call_callback((uint64_t)bp, 134, (uint64_t)parg, 0, v8, larg, v12, 0);
}

char *__cdecl BIO_ptr_ctrl(BIO *bp, int cmd, uint64_t larg)
{
  int parg = 0;
  if (BIO_ctrl(bp, cmd, larg, &parg) >= 1) {
    return parg;
  }
  else {
    return 0;
  }
}

uint64_t BIO_callback_ctrl(BIO *b, int cmd, void (__cdecl *fp)(bio_st *, int, const char *, int, uint64_t, uint64_t))
{
  unint64_t v10 = fp;
  if (!b) {
    return 0;
  }
  if (!b->method || cmd != 14 || (callback_ctrl = b->method->callback_ctrl) == 0)
  {
    ERR_put_error(32, 4095, 121, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bio_lib.c", 591);
    return -2;
  }
  callbacuint64_t k = b->callback;
  cb_arg = b->cb_arg;
  if (callback)
  {
    if (!cb_arg)
    {
      uint64_t v7 = ((uint64_t (*)(BIO *, uint64_t, void (__cdecl **)(bio_st *, int, const char *, int, uint64_t, uint64_t), uint64_t, void, uint64_t))callback)(b, 6, &v10, 14, 0, 1);
LABEL_12:
      uint64_t v8 = v7;
      if (v7 < 1) {
        return v8;
      }
      callback_ctrl = b->method->callback_ctrl;
      goto LABEL_14;
    }
LABEL_11:
    uint64_t v7 = ((uint64_t (*)(BIO *, uint64_t, void (__cdecl **)(bio_st *, int, const char *, int, uint64_t, uint64_t), void, uint64_t, void, uint64_t, void))cb_arg)(b, 6, &v10, 0, 14, 0, 1, 0);
    goto LABEL_12;
  }
  if (cb_arg) {
    goto LABEL_11;
  }
LABEL_14:
  uint64_t v8 = ((uint64_t (*)(BIO *, uint64_t))callback_ctrl)(b, 14);
  if (b->callback || b->cb_arg) {
    return bio_call_callback((uint64_t)b, 134, (uint64_t)&v10, 0, 0xEuLL, 0, v8, 0);
  }
  return v8;
}

size_t BIO_ctrl_pending(BIO *b)
{
  return BIO_ctrl(b, 10, 0, 0);
}

size_t BIO_ctrl_wpending(BIO *b)
{
  return BIO_ctrl(b, 13, 0, 0);
}

BIO *__cdecl BIO_push(BIO *b, BIO *append)
{
  if (!b) {
    return append;
  }
  unint64_t v2 = b;
  uint64_t v3 = b;
  do
  {
    int v4 = v3;
    uint64_t v3 = v3->prev_bio;
  }
  while (v3);
  v4->prev_int bio = append;
  if (append)
  {
    uint64_t v5 = *(void *)&append->references;
    if (v5) {
      *(void *)(v5 + 64) = 0;
    }
    *(void *)&append->referenceunsigned int s = v4;
  }
  BIO_ctrl(b, 6, 0, v4);
  return v2;
}

BIO *__cdecl BIO_pop(BIO *b)
{
  if (!b) {
    return 0;
  }
  p_prev_int bio = &b->prev_bio;
  prev_int bio = b->prev_bio;
  BIO_ctrl(b, 7, 0, b);
  uint64_t v4 = *(void *)&b->references;
  if (v4) {
    *(void *)(v4 + 64) = *p_prev_bio;
  }
  if (*p_prev_bio) {
    *(void *)&(*p_prev_bio)->referenceunsigned int s = v4;
  }
  *p_prev_int bio = 0;
  p_prev_bio[1] = 0;
  return prev_bio;
}

BIO *__cdecl BIO_get_retry_BIO(BIO *bio, int *reason)
{
  unint64_t v2 = bio;
  if ((bio->num & 8) != 0)
  {
    do
    {
      int bio = v2;
      unint64_t v2 = v2->prev_bio;
    }
    while (v2 && (v2->num & 8) != 0);
  }
  if (reason) {
    *reasoint n = *(&bio->num + 1);
  }
  return bio;
}

int BIO_get_retry_reason(BIO *bio)
{
  return *(&bio->num + 1);
}

uint64_t BIO_set_retry_reason(uint64_t result, int a2)
{
  *(_DWORD *)(result + 44) = a2;
  return result;
}

BIO *__cdecl BIO_find_type(BIO *b, int bio_type)
{
  for (; b; BIGNUM b = b->prev_bio)
  {
    if (b->method)
    {
      int type = b->method->type;
      if ((_BYTE)bio_type)
      {
        if (type == bio_type) {
          return b;
        }
      }
      else if ((type & bio_type) != 0)
      {
        return b;
      }
    }
  }
  return b;
}

BIO *__cdecl BIO_next(BIO *b)
{
  if (b) {
    return b->prev_bio;
  }
  return b;
}

uint64_t BIO_set_next(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 64);
  if (v2) {
    *(void *)(v2 + 72) = 0;
  }
  if (a2)
  {
    uint64_t v3 = *(void *)(a2 + 72);
    if (v3) {
      *(void *)(v3 + 64) = 0;
    }
    *(void *)(result + 64) = a2;
    *(void *)(a2 + 72) = result;
  }
  else
  {
    *(void *)(result + 64) = 0;
  }
  return result;
}

void BIO_free_all(BIO *a)
{
  if (a)
  {
    do
    {
      num_reachar d = a->num_read;
      prev_int bio = a->prev_bio;
      BIO_free(a);
      BOOL v3 = num_read > 1 || prev_bio == 0;
      EVP_CIPHER_CTX a = prev_bio;
    }
    while (!v3);
  }
}

BIO *__cdecl BIO_dup_chain(BIO *in)
{
  if (in)
  {
    uint64_t v1 = in;
    uint64_t v2 = 0;
    BOOL v3 = 0;
    while (1)
    {
      uint64_t v4 = BIO_new(v1->method);
      if (!v4) {
        break;
      }
      uint64_t v5 = v4;
      *(_OWORD *)&v4->callbacuint64_t k = *(_OWORD *)&v1->callback;
      *(void *)&v4->init = *(void *)&v1->init;
      *(void *)&v4->flagunsigned int s = *(void *)&v1->flags;
      v4->int num = v1->num;
      LODWORD(v4->ptr) = v1->ptr;
      if (!BIO_ctrl(v1, 12, 0, v4))
      {
        BIO_free(v5);
        break;
      }
      if (!CRYPTO_dup_ex_data(0, (CRYPTO_EX_DATA *)&v5->ex_data.dummy, (CRYPTO_EX_DATA *)&v1->ex_data.dummy)) {
        break;
      }
      iint n = v5;
      if (v3)
      {
        BIO_push(v2, v5);
        iint n = v3;
      }
      uint64_t v1 = v1->prev_bio;
      uint64_t v2 = v5;
      BOOL v3 = in;
      if (!v1) {
        return in;
      }
    }
    BIO_free(v3);
    return 0;
  }
  return in;
}

void BIO_copy_next_retry(BIO *b)
{
  prev_int bio = b->prev_bio;
  int num = prev_bio->num;
  LODWORD(prev_bio) = *(&prev_bio->num + 1);
  b->num |= num & 0xF;
  *(&b->num + 1) = (int)prev_bio;
}

int BIO_get_ex_new_index(uint64_t argl, void *argp, CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
  return CRYPTO_get_ex_new_index(0, argl, argp, new_func, dup_func, free_func);
}

int BIO_set_ex_data(BIO *bio, int idx, void *data)
{
  return CRYPTO_set_ex_data((CRYPTO_EX_DATA *)&bio->ex_data.dummy, idx, data);
}

void *__cdecl BIO_get_ex_data(BIO *bio, int idx)
{
  return CRYPTO_get_ex_data((const CRYPTO_EX_DATA *)&bio->ex_data.dummy, idx);
}

unint64_t BIO_number_read(unint64_t bio)
{
  if (bio) {
    return *(void *)(bio + 88);
  }
  return bio;
}

unint64_t BIO_number_written(unint64_t bio)
{
  if (bio) {
    return *(void *)(bio + 96);
  }
  return bio;
}

void CAST_ofb64_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, const CAST_KEY *schedule, unsigned __int8 *ivec, int *num)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  int v7 = *num;
  int v8 = *ivec;
  int v9 = ivec[1];
  int v10 = ivec[2];
  int v11 = ivec[3];
  unsigned int v12 = (v8 << 24) | (v9 << 16) | (v10 << 8) | v11;
  int v13 = ivec[4];
  int v14 = ivec[5];
  int v15 = ivec[6];
  int v16 = ivec[7];
  int v17 = (v13 << 24) | (v14 << 16) | (v15 << 8) | v16;
  unint64_t data = __PAIR64__(v17, v12);
  LOBYTE(v26) = v8;
  BYTE1(v26) = v9;
  BYTE2(v26) = v10;
  HIBYTE(v26) = v11;
  LOBYTE(v27) = v13;
  BYTE1(v27) = v14;
  BYTE2(v27) = v15;
  HIBYTE(v27) = v16;
  if (length)
  {
    uint64_t v20 = length;
    int v23 = 0;
    do
    {
      if (!v7)
      {
        CAST_encrypt(&data, schedule);
        unsigned int v12 = data;
        int v17 = HIDWORD(data);
        unsigned int v26 = bswap32(data);
        unsigned int v27 = bswap32(HIDWORD(data));
        ++v23;
      }
      char v24 = *in++;
      *out++ = *((unsigned char *)&v26 + v7) ^ v24;
      int v7 = (v7 + 1) & 7;
      --v20;
    }
    while (v20);
    if (v23)
    {
      *ivec = HIBYTE(v12);
      ivec[1] = BYTE2(v12);
      ivec[2] = BYTE1(v12);
      ivec[3] = v12;
      ivec[4] = HIBYTE(v17);
      ivec[5] = BYTE2(v17);
      ivec[6] = BYTE1(v17);
      ivec[7] = v17;
    }
  }
  *int num = v7;
}

void *EVP_camellia_128_cbc()
{
  return &camellia_128_cbc;
}

void *EVP_camellia_128_cfb128()
{
  return &camellia_128_cfb128;
}

void *EVP_camellia_128_ofb()
{
  return &camellia_128_ofb;
}

void *EVP_camellia_128_ecb()
{
  return &camellia_128_ecb;
}

void *EVP_camellia_192_cbc()
{
  return &camellia_192_cbc;
}

void *EVP_camellia_192_cfb128()
{
  return &camellia_192_cfb128;
}

void *EVP_camellia_192_ofb()
{
  return &camellia_192_ofb;
}

void *EVP_camellia_192_ecb()
{
  return &camellia_192_ecb;
}

void *EVP_camellia_256_cbc()
{
  return &camellia_256_cbc;
}

void *EVP_camellia_256_cfb128()
{
  return &camellia_256_cfb128;
}

void *EVP_camellia_256_ofb()
{
  return &camellia_256_ofb;
}

void *EVP_camellia_256_ecb()
{
  return &camellia_256_ecb;
}

void *EVP_camellia_128_cfb1()
{
  return &camellia_128_cfb1;
}

void *EVP_camellia_192_cfb1()
{
  return &camellia_192_cfb1;
}

void *EVP_camellia_256_cfb1()
{
  return &camellia_256_cfb1;
}

void *EVP_camellia_128_cfb8()
{
  return &camellia_128_cfb8;
}

void *EVP_camellia_192_cfb8()
{
  return &camellia_192_cfb8;
}

void *EVP_camellia_256_cfb8()
{
  return &camellia_256_cfb8;
}

uint64_t camellia_init_key(uint64_t a1, unsigned __int8 *a2)
{
  if ((Camellia_set_key(a2, 8 * *(_DWORD *)(a1 + 104), *(unsigned int **)(a1 + 120)) & 0x80000000) == 0) {
    return 1;
  }
  ERR_put_error(6, 4095, 157, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_camellia.c", 84);
  return 0;
}

uint64_t camellia_128_cbc_cipher(uint64_t a1, uint64_t *a2, void *a3, unint64_t a4)
{
  uint64_t v4 = a4;
  if (!(a4 >> 62))
  {
    unint64_t v8 = a4;
    if (!a4) {
      return 1;
    }
    goto LABEL_4;
  }
  do
  {
    Camellia_cbc_encrypt(a3, a2, 0x4000000000000000uLL, *(void *)(a1 + 120), (_OWORD *)(a1 + 40), *(_DWORD *)(a1 + 16));
    unint64_t v8 = v4 - 0x4000000000000000;
    a3 += 0x800000000000000;
    a2 += 0x800000000000000;
    BOOL v9 = v4 < 0x4000000000000000;
    v4 -= 0x4000000000000000;
  }
  while (v9);
  if (v8) {
LABEL_4:
  }
    Camellia_cbc_encrypt(a3, a2, v8, *(void *)(a1 + 120), (_OWORD *)(a1 + 40), *(_DWORD *)(a1 + 16));
  return 1;
}

uint64_t camellia_128_cfb128_cipher(uint64_t a1, unsigned char *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v4 = a4;
    if (a4 >= 0x4000000000000000) {
      unint64_t v8 = 0x4000000000000000;
    }
    else {
      unint64_t v8 = a4;
    }
    uint64_t v9 = a1 + 40;
    int v10 = (unsigned int *)(a1 + 88);
    do
    {
      Camellia_cfb128_encrypt(a3, a2, v8, *(void *)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      a3 += v8;
      a2 += v8;
      v4 -= v8;
      if (v4 < v8) {
        unint64_t v8 = v4;
      }
    }
    while (v4);
  }
  return 1;
}

uint64_t camellia_128_ofb_cipher(uint64_t a1, unsigned char *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4 = a4;
  if (!(a4 >> 62))
  {
    unint64_t v8 = a4;
    if (!a4) {
      return 1;
    }
    goto LABEL_4;
  }
  do
  {
    Camellia_ofb128_encrypt(a3, a2, 0x4000000000000000uLL, *(void *)(a1 + 120), a1 + 40, (unsigned int *)(a1 + 88));
    unint64_t v8 = v4 - 0x4000000000000000;
    a3 += 0x4000000000000000;
    a2 += 0x4000000000000000;
    BOOL v9 = v4 < 0x4000000000000000;
    v4 -= 0x4000000000000000;
  }
  while (v9);
  if (v8) {
LABEL_4:
  }
    Camellia_ofb128_encrypt(a3, a2, v8, *(void *)(a1 + 120), a1 + 40, (unsigned int *)(a1 + 88));
  return 1;
}

uint64_t camellia_128_ecb_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4 = *(int *)(*(void *)a1 + 4);
  unint64_t v5 = a4 - v4;
  if (a4 >= v4)
  {
    unint64_t v9 = 0;
    do
    {
      Camellia_ecb_encrypt((unsigned int *)(a3 + v9), (unsigned char *)(a2 + v9), *(_DWORD **)(a1 + 120), *(_DWORD *)(a1 + 16));
      v9 += v4;
    }
    while (v9 <= v5);
  }
  return 1;
}

uint64_t camellia_192_cbc_cipher(uint64_t a1, uint64_t *a2, void *a3, unint64_t a4)
{
  uint64_t v4 = a4;
  if (!(a4 >> 62))
  {
    unint64_t v8 = a4;
    if (!a4) {
      return 1;
    }
    goto LABEL_4;
  }
  do
  {
    Camellia_cbc_encrypt(a3, a2, 0x4000000000000000uLL, *(void *)(a1 + 120), (_OWORD *)(a1 + 40), *(_DWORD *)(a1 + 16));
    unint64_t v8 = v4 - 0x4000000000000000;
    a3 += 0x800000000000000;
    a2 += 0x800000000000000;
    BOOL v9 = v4 < 0x4000000000000000;
    v4 -= 0x4000000000000000;
  }
  while (v9);
  if (v8) {
LABEL_4:
  }
    Camellia_cbc_encrypt(a3, a2, v8, *(void *)(a1 + 120), (_OWORD *)(a1 + 40), *(_DWORD *)(a1 + 16));
  return 1;
}

uint64_t camellia_192_cfb128_cipher(uint64_t a1, unsigned char *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v4 = a4;
    if (a4 >= 0x4000000000000000) {
      unint64_t v8 = 0x4000000000000000;
    }
    else {
      unint64_t v8 = a4;
    }
    uint64_t v9 = a1 + 40;
    int v10 = (unsigned int *)(a1 + 88);
    do
    {
      Camellia_cfb128_encrypt(a3, a2, v8, *(void *)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      a3 += v8;
      a2 += v8;
      v4 -= v8;
      if (v4 < v8) {
        unint64_t v8 = v4;
      }
    }
    while (v4);
  }
  return 1;
}

uint64_t camellia_192_ofb_cipher(uint64_t a1, unsigned char *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4 = a4;
  if (!(a4 >> 62))
  {
    unint64_t v8 = a4;
    if (!a4) {
      return 1;
    }
    goto LABEL_4;
  }
  do
  {
    Camellia_ofb128_encrypt(a3, a2, 0x4000000000000000uLL, *(void *)(a1 + 120), a1 + 40, (unsigned int *)(a1 + 88));
    unint64_t v8 = v4 - 0x4000000000000000;
    a3 += 0x4000000000000000;
    a2 += 0x4000000000000000;
    BOOL v9 = v4 < 0x4000000000000000;
    v4 -= 0x4000000000000000;
  }
  while (v9);
  if (v8) {
LABEL_4:
  }
    Camellia_ofb128_encrypt(a3, a2, v8, *(void *)(a1 + 120), a1 + 40, (unsigned int *)(a1 + 88));
  return 1;
}

uint64_t camellia_192_ecb_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4 = *(int *)(*(void *)a1 + 4);
  unint64_t v5 = a4 - v4;
  if (a4 >= v4)
  {
    unint64_t v9 = 0;
    do
    {
      Camellia_ecb_encrypt((unsigned int *)(a3 + v9), (unsigned char *)(a2 + v9), *(_DWORD **)(a1 + 120), *(_DWORD *)(a1 + 16));
      v9 += v4;
    }
    while (v9 <= v5);
  }
  return 1;
}

uint64_t camellia_256_cbc_cipher(uint64_t a1, uint64_t *a2, void *a3, unint64_t a4)
{
  uint64_t v4 = a4;
  if (!(a4 >> 62))
  {
    unint64_t v8 = a4;
    if (!a4) {
      return 1;
    }
    goto LABEL_4;
  }
  do
  {
    Camellia_cbc_encrypt(a3, a2, 0x4000000000000000uLL, *(void *)(a1 + 120), (_OWORD *)(a1 + 40), *(_DWORD *)(a1 + 16));
    unint64_t v8 = v4 - 0x4000000000000000;
    a3 += 0x800000000000000;
    a2 += 0x800000000000000;
    BOOL v9 = v4 < 0x4000000000000000;
    v4 -= 0x4000000000000000;
  }
  while (v9);
  if (v8) {
LABEL_4:
  }
    Camellia_cbc_encrypt(a3, a2, v8, *(void *)(a1 + 120), (_OWORD *)(a1 + 40), *(_DWORD *)(a1 + 16));
  return 1;
}

uint64_t camellia_256_cfb128_cipher(uint64_t a1, unsigned char *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v4 = a4;
    if (a4 >= 0x4000000000000000) {
      unint64_t v8 = 0x4000000000000000;
    }
    else {
      unint64_t v8 = a4;
    }
    uint64_t v9 = a1 + 40;
    int v10 = (unsigned int *)(a1 + 88);
    do
    {
      Camellia_cfb128_encrypt(a3, a2, v8, *(void *)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      a3 += v8;
      a2 += v8;
      v4 -= v8;
      if (v4 < v8) {
        unint64_t v8 = v4;
      }
    }
    while (v4);
  }
  return 1;
}

uint64_t camellia_256_ofb_cipher(uint64_t a1, unsigned char *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4 = a4;
  if (!(a4 >> 62))
  {
    unint64_t v8 = a4;
    if (!a4) {
      return 1;
    }
    goto LABEL_4;
  }
  do
  {
    Camellia_ofb128_encrypt(a3, a2, 0x4000000000000000uLL, *(void *)(a1 + 120), a1 + 40, (unsigned int *)(a1 + 88));
    unint64_t v8 = v4 - 0x4000000000000000;
    a3 += 0x4000000000000000;
    a2 += 0x4000000000000000;
    BOOL v9 = v4 < 0x4000000000000000;
    v4 -= 0x4000000000000000;
  }
  while (v9);
  if (v8) {
LABEL_4:
  }
    Camellia_ofb128_encrypt(a3, a2, v8, *(void *)(a1 + 120), a1 + 40, (unsigned int *)(a1 + 88));
  return 1;
}

uint64_t camellia_256_ecb_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4 = *(int *)(*(void *)a1 + 4);
  unint64_t v5 = a4 - v4;
  if (a4 >= v4)
  {
    unint64_t v9 = 0;
    do
    {
      Camellia_ecb_encrypt((unsigned int *)(a3 + v9), (unsigned char *)(a2 + v9), *(_DWORD **)(a1 + 120), *(_DWORD *)(a1 + 16));
      v9 += v4;
    }
    while (v9 <= v5);
  }
  return 1;
}

uint64_t camellia_128_cfb1_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v4 = a4;
    if (a4 >= 0x800000000000000) {
      unint64_t v8 = 0x800000000000000;
    }
    else {
      unint64_t v8 = a4;
    }
    uint64_t v9 = a1 + 40;
    uint64_t v10 = a1 + 88;
    do
    {
      if ((*(void *)(a1 + 112) & 0x2000) != 0) {
        uint64_t v11 = v8;
      }
      else {
        uint64_t v11 = 8 * v8;
      }
      Camellia_cfb1_encrypt(a3, a2, v11, *(void *)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      a3 += v8;
      a2 += v8;
      v4 -= v8;
      if (v4 < v8) {
        unint64_t v8 = v4;
      }
    }
    while (v4);
  }
  return 1;
}

uint64_t camellia_192_cfb1_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v4 = a4;
    if (a4 >= 0x800000000000000) {
      unint64_t v8 = 0x800000000000000;
    }
    else {
      unint64_t v8 = a4;
    }
    uint64_t v9 = a1 + 40;
    uint64_t v10 = a1 + 88;
    do
    {
      if ((*(void *)(a1 + 112) & 0x2000) != 0) {
        uint64_t v11 = v8;
      }
      else {
        uint64_t v11 = 8 * v8;
      }
      Camellia_cfb1_encrypt(a3, a2, v11, *(void *)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      a3 += v8;
      a2 += v8;
      v4 -= v8;
      if (v4 < v8) {
        unint64_t v8 = v4;
      }
    }
    while (v4);
  }
  return 1;
}

uint64_t camellia_256_cfb1_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v4 = a4;
    if (a4 >= 0x800000000000000) {
      unint64_t v8 = 0x800000000000000;
    }
    else {
      unint64_t v8 = a4;
    }
    uint64_t v9 = a1 + 40;
    uint64_t v10 = a1 + 88;
    do
    {
      if ((*(void *)(a1 + 112) & 0x2000) != 0) {
        uint64_t v11 = v8;
      }
      else {
        uint64_t v11 = 8 * v8;
      }
      Camellia_cfb1_encrypt(a3, a2, v11, *(void *)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      a3 += v8;
      a2 += v8;
      v4 -= v8;
      if (v4 < v8) {
        unint64_t v8 = v4;
      }
    }
    while (v4);
  }
  return 1;
}

uint64_t camellia_128_cfb8_cipher(uint64_t a1, unsigned char *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v4 = a4;
    if (a4 >= 0x4000000000000000) {
      unint64_t v8 = 0x4000000000000000;
    }
    else {
      unint64_t v8 = a4;
    }
    uint64_t v9 = (long long *)(a1 + 40);
    uint64_t v10 = a1 + 88;
    do
    {
      Camellia_cfb8_encrypt(a3, a2, v8, *(void *)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      a3 += v8;
      a2 += v8;
      v4 -= v8;
      if (v4 < v8) {
        unint64_t v8 = v4;
      }
    }
    while (v4);
  }
  return 1;
}

uint64_t camellia_192_cfb8_cipher(uint64_t a1, unsigned char *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v4 = a4;
    if (a4 >= 0x4000000000000000) {
      unint64_t v8 = 0x4000000000000000;
    }
    else {
      unint64_t v8 = a4;
    }
    uint64_t v9 = (long long *)(a1 + 40);
    uint64_t v10 = a1 + 88;
    do
    {
      Camellia_cfb8_encrypt(a3, a2, v8, *(void *)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      a3 += v8;
      a2 += v8;
      v4 -= v8;
      if (v4 < v8) {
        unint64_t v8 = v4;
      }
    }
    while (v4);
  }
  return 1;
}

uint64_t camellia_256_cfb8_cipher(uint64_t a1, unsigned char *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v4 = a4;
    if (a4 >= 0x4000000000000000) {
      unint64_t v8 = 0x4000000000000000;
    }
    else {
      unint64_t v8 = a4;
    }
    uint64_t v9 = (long long *)(a1 + 40);
    uint64_t v10 = a1 + 88;
    do
    {
      Camellia_cfb8_encrypt(a3, a2, v8, *(void *)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      a3 += v8;
      a2 += v8;
      v4 -= v8;
      if (v4 < v8) {
        unint64_t v8 = v4;
      }
    }
    while (v4);
  }
  return 1;
}

int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid, char *kstr, int klen, pem_password_cb *cb, void *u)
{
  return do_pk8pkey(bp, x, 0, nid, 0, kstr, klen, (uint64_t (*)(char *, uint64_t, uint64_t, void *))cb, u);
}

uint64_t do_pk8pkey(BIO *a1, EVP_PKEY *pkey, int a3, int a4, const EVP_CIPHER *a5, const char *a6, int a7, uint64_t (*a8)(char *, uint64_t, uint64_t, void *), void *key)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  int v16 = EVP_PKEY2PKCS8(pkey);
  if (!v16)
  {
    ERR_put_error(9, 4095, 115, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_pk8.c", 119);
    return 0;
  }
  int v17 = v16;
  if (a4 == -1 && !a5)
  {
    if (a3) {
      uint64_t v18 = i2d_PKCS8_PRIV_KEY_INFO_bio(a1, v16);
    }
    else {
      uint64_t v18 = PEM_ASN1_write_bio((i2d_of_void *)i2d_PKCS8_PRIV_KEY_INFO, "PRIVATE KEY", a1, (char *)v16, 0, 0, 0, 0, 0);
    }
    uint64_t v19 = v18;
    PKCS8_PRIV_KEY_INFO_free(v17);
    return v19;
  }
  if (!a6)
  {
    if (a8) {
      int v21 = a8(buf, 1024, 1, key);
    }
    else {
      int v21 = PEM_def_callback(buf, 1024, 1, key);
    }
    a7 = v21;
    if (v21 >= 1)
    {
      PKCS8_encrypt(a4, a5, buf, v21, 0, 0, 0, v17);
      goto LABEL_18;
    }
    ERR_put_error(9, 4095, 111, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_pk8.c", 129);
    PKCS8_PRIV_KEY_INFO_free(v17);
    return 0;
  }
  uint64_t v20 = PKCS8_encrypt(a4, a5, a6, a7, 0, 0, 0, v16);
  if (buf == a6) {
LABEL_18:
  }
    explicit_bzero(buf, a7);
  PKCS8_PRIV_KEY_INFO_free(v17);
  if (a3) {
    uint64_t v22 = i2d_PKCS8_bio(a1, v20);
  }
  else {
    uint64_t v22 = PEM_ASN1_write_bio((i2d_of_void *)i2d_X509_SIG, "ENCRYPTED PRIVATE KEY", a1, (char *)v20, 0, 0, 0, 0, 0);
  }
  uint64_t v19 = v22;
  X509_SIG_free(v20);
  return v19;
}

int PEM_write_bio_PKCS8PrivateKey(BIO *a1, EVP_PKEY *a2, const EVP_CIPHER *a3, char *a4, int a5, pem_password_cb *a6, void *key)
{
  return do_pk8pkey(a1, a2, 0, -1, a3, a4, a5, (uint64_t (*)(char *, uint64_t, uint64_t, void *))a6, key);
}

int i2d_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc, char *kstr, int klen, pem_password_cb *cb, void *u)
{
  return do_pk8pkey(bp, x, 1, -1, enc, kstr, klen, (uint64_t (*)(char *, uint64_t, uint64_t, void *))cb, u);
}

int i2d_PKCS8PrivateKey_nid_bio(BIO *bp, EVP_PKEY *x, int nid, char *kstr, int klen, pem_password_cb *cb, void *u)
{
  return do_pk8pkey(bp, x, 1, nid, 0, kstr, klen, (uint64_t (*)(char *, uint64_t, uint64_t, void *))cb, u);
}

EVP_PKEY *__cdecl d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  int v7 = (EVP_PKEY *)d2i_PKCS8_bio(bp, 0);
  if (!v7) {
    return v7;
  }
  if (cb) {
    int v8 = ((uint64_t (*)(char *, uint64_t, void, void *))cb)(buf, 1024, 0, u);
  }
  else {
    int v8 = PEM_def_callback(buf, 1024, 0, u);
  }
  if (v8 <= 0)
  {
    ERR_put_error(9, 4095, 104, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_pk8.c", 173);
    X509_SIG_free((X509_SIG *)v7);
    return 0;
  }
  uint64_t v9 = PKCS8_decrypt((X509_SIG *)v7, buf, v8);
  X509_SIG_free((X509_SIG *)v7);
  if (!v9) {
    return 0;
  }
  int v7 = EVP_PKCS82PKEY(v9);
  PKCS8_PRIV_KEY_INFO_free(v9);
  if (v7 && x)
  {
    EVP_PKEY_free(*x);
    ASN1_INTEGER *x = v7;
  }
  return v7;
}

int i2d_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc, char *kstr, int klen, pem_password_cb *cb, void *u)
{
  return do_pk8pkey_fp(fp, x, 1, -1, enc, kstr, klen, (uint64_t (*)(char *, uint64_t, uint64_t, void *))cb, u);
}

uint64_t do_pk8pkey_fp(FILE *a1, EVP_PKEY *a2, int a3, int a4, const EVP_CIPHER *a5, const char *a6, int a7, uint64_t (*a8)(char *, uint64_t, uint64_t, void *), void *key)
{
  int v16 = BIO_new_fp(a1, 0);
  if (v16)
  {
    int v17 = v16;
    uint64_t v18 = do_pk8pkey(v16, a2, a3, a4, a5, a6, a7, a8, key);
    BIO_free(v17);
    return v18;
  }
  else
  {
    ERR_put_error(9, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_pk8.c", 229);
    return 0;
  }
}

int i2d_PKCS8PrivateKey_nid_fp(FILE *fp, EVP_PKEY *x, int nid, char *kstr, int klen, pem_password_cb *cb, void *u)
{
  return do_pk8pkey_fp(fp, x, 1, nid, 0, kstr, klen, (uint64_t (*)(char *, uint64_t, uint64_t, void *))cb, u);
}

int PEM_write_PKCS8PrivateKey_nid(FILE *fp, EVP_PKEY *x, int nid, char *kstr, int klen, pem_password_cb *cb, void *u)
{
  return do_pk8pkey_fp(fp, x, 0, nid, 0, kstr, klen, (uint64_t (*)(char *, uint64_t, uint64_t, void *))cb, u);
}

int PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc, char *kstr, int klen, pem_password_cb *cd, void *u)
{
  return do_pk8pkey_fp(fp, x, 0, -1, enc, kstr, klen, (uint64_t (*)(char *, uint64_t, uint64_t, void *))cd, u);
}

EVP_PKEY *__cdecl d2i_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u)
{
  int v7 = BIO_new_fp(fp, 0);
  if (v7)
  {
    int v8 = v7;
    uint64_t v9 = d2i_PKCS8PrivateKey_bio(v7, x, cb, u);
    BIO_free(v8);
    return v9;
  }
  else
  {
    ERR_put_error(9, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_pk8.c", 244);
    return 0;
  }
}

X509_SIG *__cdecl PEM_read_PKCS8(FILE *fp, X509_SIG **x, pem_password_cb *cb, void *u)
{
  return (X509_SIG *)PEM_ASN1_read((d2i_of_void *)d2i_X509_SIG, "ENCRYPTED PRIVATE KEY", fp, (void **)x, cb, u);
}

int PEM_write_PKCS8(FILE *fp, X509_SIG *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_X509_SIG, "ENCRYPTED PRIVATE KEY", fp, (char *)x, 0, 0, 0, 0, 0);
}

X509_SIG *__cdecl PEM_read_bio_PKCS8(BIO *bp, X509_SIG **x, pem_password_cb *cb, void *u)
{
  return (X509_SIG *)PEM_ASN1_read_bio((d2i_of_void *)d2i_X509_SIG, "ENCRYPTED PRIVATE KEY", bp, (void **)x, cb, u);
}

int PEM_write_bio_PKCS8(BIO *bp, X509_SIG *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_X509_SIG, "ENCRYPTED PRIVATE KEY", bp, (char *)x, 0, 0, 0, 0, 0);
}

PKCS8_PRIV_KEY_INFO *__cdecl PEM_read_PKCS8_PRIV_KEY_INFO(FILE *fp, PKCS8_PRIV_KEY_INFO **x, pem_password_cb *cb, void *u)
{
  return (PKCS8_PRIV_KEY_INFO *)PEM_ASN1_read((d2i_of_void *)d2i_PKCS8_PRIV_KEY_INFO, "PRIVATE KEY", fp, (void **)x, cb, u);
}

int PEM_write_PKCS8_PRIV_KEY_INFO(FILE *fp, PKCS8_PRIV_KEY_INFO *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_PKCS8_PRIV_KEY_INFO, "PRIVATE KEY", fp, (char *)x, 0, 0, 0, 0, 0);
}

PKCS8_PRIV_KEY_INFO *__cdecl PEM_read_bio_PKCS8_PRIV_KEY_INFO(BIO *bp, PKCS8_PRIV_KEY_INFO **x, pem_password_cb *cb, void *u)
{
  return (PKCS8_PRIV_KEY_INFO *)PEM_ASN1_read_bio((d2i_of_void *)d2i_PKCS8_PRIV_KEY_INFO, "PRIVATE KEY", bp, (void **)x, cb, u);
}

int PEM_write_bio_PKCS8_PRIV_KEY_INFO(BIO *bp, PKCS8_PRIV_KEY_INFO *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_PKCS8_PRIV_KEY_INFO, "PRIVATE KEY", bp, (char *)x, 0, 0, 0, 0, 0);
}

BIO *__cdecl PKCS7_dataInit(PKCS7 *p7, BIO *bio)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  BIGNUM b = 0;
  if (p7)
  {
    if (p7->d.ptr)
    {
      int v4 = OBJ_obj2nid(p7->type);
      p7->state = 0;
      unint64_t v5 = 0;
      int v6 = 0;
      int v7 = 0;
      int v8 = 0;
      uint64_t v9 = 0;
      octet_int string = 0;
      switch(v4)
      {
        case 21:
          goto LABEL_16;
        case 22:
          unint64_t v5 = 0;
          int ptr = p7->d.ptr;
          int v7 = (const STACK *)*((void *)ptr + 1);
          uint64_t v12 = (uint64_t *)(ptr + 40);
          goto LABEL_15;
        case 23:
          int v17 = p7->d.ptr;
          uint64_t v18 = *((void *)v17 + 2);
          int v6 = *(const EVP_CIPHER **)(v18 + 24);
          if (v6)
          {
            unint64_t v5 = 0;
            int v7 = 0;
            octet_int string = 0;
            int v8 = (const STACK *)*((void *)v17 + 1);
            goto LABEL_13;
          }
          int v15 = 116;
          int v16 = 314;
          goto LABEL_47;
        case 24:
          uint64_t v19 = p7->d.ptr;
          uint64_t v18 = *((void *)v19 + 5);
          int v6 = *(const EVP_CIPHER **)(v18 + 24);
          if (!v6)
          {
            int v15 = 116;
            int v16 = 305;
LABEL_47:
            ERR_put_error(33, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v16);
            goto LABEL_48;
          }
          unint64_t v5 = 0;
          octet_int string = 0;
          int v8 = (const STACK *)*((void *)v19 + 6);
          int v7 = (const STACK *)*((void *)v19 + 1);
LABEL_13:
          uint64_t v9 = *(ASN1_OBJECT ***)(v18 + 8);
LABEL_16:
          if (sk_num(v7) >= 1)
          {
            int v21 = 0;
            do
            {
              uint64_t v22 = sk_value(v7, v21);
              if (!PKCS7_bio_add_digest(&b, (const ASN1_OBJECT **)v22)) {
                goto LABEL_48;
              }
            }
            while (++v21 < sk_num(v7));
          }
          if (v5 && !PKCS7_bio_add_digest(&b, v5)) {
            goto LABEL_48;
          }
          if (v6)
          {
            int parg = 0;
            int v23 = BIO_f_cipher();
            char v24 = BIO_new(v23);
            uint64_t v25 = v24;
            if (v24)
            {
              BIO_ctrl(v24, 129, 0, &parg);
              int v26 = EVP_CIPHER_key_length(v6);
              int v27 = EVP_CIPHER_iv_length(v6);
              int v28 = EVP_CIPHER_type(v6);
              *uint64_t v9 = OBJ_nid2obj(v28);
              if (v27 >= 1) {
                arc4random_buf(__buf, v27);
              }
              if (EVP_CipherInit_ex(parg, v6, 0, 0, 0, 1) >= 1
                && EVP_CIPHER_CTX_rand_key(parg, (unsigned __int8 *)&key) >= 1
                && EVP_CipherInit_ex(parg, 0, 0, (const unsigned __int8 *)&key, __buf, 1) >= 1)
              {
                if (v27 < 1
                  || ((int v29 = (ASN1_TYPE *)v9[1]) != 0 || (int v29 = ASN1_TYPE_new(), (v9[1] = (ASN1_OBJECT *)v29) != 0))
                  && (EVP_CIPHER_param_to_asn1(parg, v29) & 0x80000000) == 0)
                {
                  size_t v42 = v26;
                  if (sk_num(v8) < 1) {
LABEL_43:
                  }
                    explicit_bzero(&key, v42);
                  int v30 = 0;
                  while (1)
                  {
                    int v31 = sk_value(v8, v30);
                    pubEVP_PKEY key = X509_get_pubkey(*((X509 **)v31 + 4));
                    if (!pubkey) {
                      goto LABEL_49;
                    }
                    int v33 = pubkey;
                    unsigned __int8 v34 = (uint64_t *)EVP_PKEY_CTX_new((uint64_t)pubkey, 0);
                    if (!v34) {
                      goto LABEL_49;
                    }
                    int v35 = v34;
                    size_t size = 0;
                    if ((int)EVP_PKEY_encrypt_init(v34) < 1) {
                      goto LABEL_68;
                    }
                    if ((int)EVP_PKEY_CTX_ctrl(v35, -1, 256) <= 0) {
                      break;
                    }
                    if (EVP_PKEY_encrypt((unsigned __int8 *)v35, 0, (int)&size, &key) < 1) {
                      goto LABEL_68;
                    }
                    uint64_t v36 = (unsigned __int8 *)malloc_type_malloc(size, 0x59D5AE15uLL);
                    if (!v36)
                    {
                      ERR_put_error(33, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", 180);
                      goto LABEL_70;
                    }
                    if (EVP_PKEY_encrypt((unsigned __int8 *)v35, v36, (int)&size, &key) < 1) {
                      goto LABEL_70;
                    }
                    ASN1_STRING_set0(*((ASN1_STRING **)v31 + 3), v36, size);
                    EVP_PKEY_free(v33);
                    EVP_PKEY_CTX_free((EVP_PKEY **)v35);
                    if (++v30 >= sk_num(v8)) {
                      goto LABEL_43;
                    }
                  }
                  ERR_put_error(33, 4095, 152, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", 170);
LABEL_68:
                  uint64_t v36 = 0;
LABEL_70:
                  EVP_PKEY_free(v33);
                  EVP_PKEY_CTX_free((EVP_PKEY **)v35);
                  free(v36);
                }
              }
            }
            else
            {
              ERR_put_error(33, 4095, 32, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", 343);
            }
LABEL_49:
            if (b) {
              BIO_free_all(b);
            }
            if (v25) {
              BIO_free_all(v25);
            }
            return 0;
          }
          if (bio) {
            goto LABEL_56;
          }
          if (OBJ_obj2nid(p7->type) == 22 && PKCS7_ctrl(p7, 2, 0, 0))
          {
            unsigned __int8 v38 = BIO_s_null();
            int v39 = BIO_new(v38);
          }
          else
          {
            if (!octet_string || *(int *)octet_string < 1) {
              goto LABEL_65;
            }
            int v39 = BIO_new_mem_buf(*(void **)(octet_string + 8), *(_DWORD *)octet_string);
          }
          int bio = v39;
          if (v39) {
            goto LABEL_56;
          }
LABEL_65:
          uint64_t v40 = BIO_s_mem();
          int v41 = BIO_new(v40);
          if (v41)
          {
            int bio = v41;
            BIO_ctrl(v41, 130, 0, 0);
LABEL_56:
            if (b)
            {
              BIO_push(b, bio);
              return b;
            }
            return bio;
          }
LABEL_48:
          uint64_t v25 = 0;
          goto LABEL_49;
        case 25:
          int v7 = 0;
          uint64_t v20 = p7->d.ptr;
          unint64_t v5 = (const ASN1_OBJECT **)*((void *)v20 + 1);
          uint64_t v12 = (uint64_t *)(v20 + 16);
LABEL_15:
          octet_int string = PKCS7_get_octet_string(*v12);
          int v6 = 0;
          int v8 = 0;
          uint64_t v9 = 0;
          goto LABEL_16;
        default:
          int v15 = 112;
          int v16 = 325;
          goto LABEL_47;
      }
    }
    int v13 = 122;
    int v14 = 287;
  }
  else
  {
    int v13 = 143;
    int v14 = 270;
  }
  ERR_put_error(33, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v14);
  return 0;
}

uint64_t PKCS7_get_octet_string(uint64_t a1)
{
  if (OBJ_obj2nid(*(const ASN1_OBJECT **)(a1 + 24)) == 21)
  {
    uint64_t v2 = (_DWORD *)(a1 + 32);
    return *(void *)v2;
  }
  if ((OBJ_obj2nid(*(const ASN1_OBJECT **)(a1 + 24)) - 21) >= 6)
  {
    int v4 = *(_DWORD **)(a1 + 32);
    if (v4)
    {
      if (*v4 == 4)
      {
        uint64_t v2 = v4 + 2;
        return *(void *)v2;
      }
    }
  }
  return 0;
}

uint64_t PKCS7_bio_add_digest(BIO **a1, const ASN1_OBJECT **a2)
{
  int v4 = BIO_f_md();
  unint64_t v5 = BIO_new(v4);
  if (!v5)
  {
    int v9 = 32;
    int v10 = 117;
    goto LABEL_10;
  }
  int v6 = OBJ_obj2nid(*a2);
  int v7 = OBJ_nid2sn(v6);
  digestbyname = (EVP_MD *)EVP_get_digestbyname(v7);
  if (!digestbyname)
  {
    int v9 = 109;
    int v10 = 123;
    goto LABEL_10;
  }
  if (BIO_ctrl(v5, 111, 0, digestbyname) <= 0)
  {
    int v9 = 32;
    int v10 = 128;
    goto LABEL_10;
  }
  if (*a1)
  {
    if (!BIO_push(*a1, v5))
    {
      int v9 = 32;
      int v10 = 135;
LABEL_10:
      ERR_put_error(33, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v10);
      BIO_free(v5);
      return 0;
    }
  }
  else
  {
    *a1 = v5;
  }
  return 1;
}

BIO *__cdecl PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)
{
  unint64_t v61 = 0;
  int parg = 0;
  int v60 = 0;
  if (p7)
  {
    if (p7->d.ptr)
    {
      int v8 = OBJ_obj2nid(p7->type);
      p7->state = 0;
      switch(v8)
      {
        case 24:
          int ptr = p7->d.ptr;
          uint64_t v12 = (const STACK *)*((void *)ptr + 1);
          int v17 = ptr + 40;
          uint64_t v16 = *((void *)ptr + 5);
          uint64_t v11 = (const STACK *)*((void *)v17 + 1);
          octet_int string = *(void *)(v16 + 16);
          int v59 = in_bio;
          int v10 = *(const ASN1_OBJECT ***)(v16 + 8);
          int v18 = OBJ_obj2nid(*v10);
          uint64_t v19 = OBJ_nid2sn(v18);
          cipherbyname = EVP_get_cipherbyname(v19);
          if (cipherbyname)
          {
            int v9 = cipherbyname;
            goto LABEL_12;
          }
          int v35 = 111;
          int v36 = 470;
          break;
        case 23:
          int v29 = p7->d.ptr;
          uint64_t v11 = (const STACK *)*((void *)v29 + 1);
          uint64_t v30 = *((void *)v29 + 2);
          uint64_t v31 = *(void *)(v30 + 16);
          int v57 = *(const ASN1_OBJECT ***)(v30 + 8);
          int v32 = OBJ_obj2nid(*v57);
          int v33 = OBJ_nid2sn(v32);
          unsigned __int8 v34 = EVP_get_cipherbyname(v33);
          if (v34)
          {
            int v9 = v34;
            octet_int string = v31;
            int v59 = in_bio;
            int v21 = 0;
            goto LABEL_28;
          }
          int v35 = 111;
          int v36 = 480;
          break;
        case 22:
          int v59 = in_bio;
          octet_int string = PKCS7_get_octet_string(*((void *)p7->d.ptr + 5));
          int v9 = 0;
          int v10 = 0;
          uint64_t v11 = 0;
          uint64_t v12 = (const STACK *)*((void *)p7->d.ptr + 1);
LABEL_12:
          int v57 = v10;
          if (v12 && sk_num(v12) >= 1)
          {
            int v21 = 0;
            int v22 = 0;
            while (1)
            {
              int v23 = sk_value(v12, v22);
              char v24 = BIO_f_md();
              uint64_t v25 = BIO_new(v24);
              if (!v25)
              {
                int v50 = 32;
                int v51 = 494;
                goto LABEL_59;
              }
              int v26 = OBJ_obj2nid(*(const ASN1_OBJECT **)v23);
              int v27 = OBJ_nid2sn(v26);
              digestbyname = (EVP_MD *)EVP_get_digestbyname(v27);
              if (!digestbyname)
              {
                int v50 = 109;
                int v51 = 501;
                goto LABEL_59;
              }
              if (BIO_ctrl(v25, 111, 0, digestbyname) <= 0) {
                break;
              }
              if (v21) {
                BIO_push(v21, v25);
              }
              else {
                int v21 = v25;
              }
              if (++v22 >= sk_num(v12)) {
                goto LABEL_27;
              }
            }
            int v50 = 32;
            int v51 = 506;
LABEL_59:
            ERR_put_error(33, 4095, v50, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v51);
            goto LABEL_60;
          }
          int v21 = 0;
LABEL_27:
          if (!v9)
          {
            int v44 = 0;
            goto LABEL_40;
          }
LABEL_28:
          int v37 = BIO_f_cipher();
          unsigned __int8 v38 = BIO_new(v37);
          if (v38)
          {
            int v39 = sk_num(v11);
            if (!pcert)
            {
              if (v39 >= 1)
              {
                int v47 = 0;
                do
                {
                  uint64_t v48 = sk_value(v11, v47);
                  int v49 = EVP_CIPHER_key_length(v9);
                  if ((pkcs7_decrypt_rinfo((void **)&v61, &v60, (uint64_t)v48, (uint64_t)pkey, v49) & 0x80000000) != 0) {
                    goto LABEL_38;
                  }
                  ERR_clear_error();
                }
                while (++v47 < sk_num(v11));
              }
LABEL_75:
              int parg = 0;
              BIO_ctrl(v38, 129, 0, &parg);
              if (EVP_CipherInit_ex(parg, v9, 0, 0, 0, 0) >= 1
                && (EVP_CIPHER_asn1_to_param(parg, (ASN1_TYPE *)v57[1]) & 0x80000000) == 0)
              {
                int v44 = EVP_CIPHER_CTX_key_length(parg);
                unint64_t v52 = (unsigned __int8 *)malloc_type_malloc(v44, 0xCDA15344uLL);
                if (!v52 || EVP_CIPHER_CTX_rand_key(parg, v52) < 1) {
                  goto LABEL_89;
                }
                int v55 = v61;
                if (v61)
                {
                  int v56 = v60;
                }
                else
                {
                  unint64_t v61 = v52;
                  int v60 = v44;
                  int v55 = v52;
                  int v56 = v44;
                  unint64_t v52 = 0;
                }
                if (v56 != EVP_CIPHER_CTX_key_length(parg) && !EVP_CIPHER_CTX_set_key_length(parg, v56))
                {
                  freezero(v55, v56);
                  unint64_t v61 = v52;
                  int v60 = v44;
                  int v55 = v52;
                  unint64_t v52 = 0;
                }
                ERR_clear_error();
                if (EVP_CipherInit_ex(parg, 0, 0, v55, 0, 0) < 1)
                {
LABEL_89:
                  uint64_t v25 = 0;
                  goto LABEL_62;
                }
                freezero(v55, v60);
                unint64_t v61 = 0;
                freezero(v52, v44);
                if (v21) {
                  BIO_push(v21, v38);
                }
                else {
                  int v21 = v38;
                }
LABEL_40:
                int v45 = v59;
                if (OBJ_obj2nid(p7->type) == 22)
                {
                  uint64_t v46 = PKCS7_ctrl(p7, 2, 0, 0);
                  if (v59 || v46) {
                    goto LABEL_72;
                  }
                }
                else if (v59)
                {
                  goto LABEL_72;
                }
                if (octet_string && *(int *)octet_string >= 1)
                {
                  int v45 = BIO_new_mem_buf(*(void **)(octet_string + 8), *(_DWORD *)octet_string);
                }
                else
                {
                  unsigned __int8 v54 = BIO_s_mem();
                  int v45 = BIO_new(v54);
                  BIO_ctrl(v45, 130, 0, 0);
                }
                if (!v45)
                {
                  uint64_t v25 = 0;
                  unsigned __int8 v38 = 0;
                  unint64_t v52 = 0;
                  goto LABEL_62;
                }
LABEL_72:
                BIO_push(v21, v45);
                return v21;
              }
LABEL_38:
              uint64_t v25 = 0;
LABEL_61:
              unint64_t v52 = 0;
              int v44 = 0;
LABEL_62:
              freezero(v61, v60);
              freezero(v52, v44);
              if (v21) {
                BIO_free_all(v21);
              }
              if (v25) {
                BIO_free_all(v25);
              }
              if (v38) {
                BIO_free_all(v38);
              }
              return 0;
            }
            if (v39 >= 1)
            {
              int v40 = 0;
              while (1)
              {
                int v41 = sk_value(v11, v40);
                if (!X509_NAME_cmp(**((const X509_NAME ***)v41 + 1), pcert->cert_info->issuer)
                  && !ASN1_INTEGER_cmp(pcert->cert_info->serialNumber, *(ASN1_INTEGER **)(*((void *)v41 + 1) + 8)))
                {
                  break;
                }
                if (++v40 >= sk_num(v11)) {
                  goto LABEL_35;
                }
              }
              if ((pkcs7_decrypt_rinfo((void **)&v61, &v60, (uint64_t)v41, (uint64_t)pkey, 0) & 0x80000000) != 0) {
                goto LABEL_38;
              }
              ERR_clear_error();
              goto LABEL_75;
            }
LABEL_35:
            int v42 = 115;
            int v43 = 537;
          }
          else
          {
            int v42 = 32;
            int v43 = 519;
          }
          ERR_put_error(33, 4095, v42, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v43);
          goto LABEL_38;
        default:
          int v35 = 112;
          int v36 = 485;
          break;
      }
      ERR_put_error(33, 4095, v35, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v36);
      int v21 = 0;
      uint64_t v25 = 0;
LABEL_60:
      unsigned __int8 v38 = 0;
      goto LABEL_61;
    }
    int v13 = 122;
    int v14 = 451;
  }
  else
  {
    int v13 = 143;
    int v14 = 446;
  }
  ERR_put_error(33, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v14);
  return 0;
}

uint64_t pkcs7_decrypt_rinfo(void **a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v9 = (uint64_t *)EVP_PKEY_CTX_new(a4, 0);
  if (!v9) {
    return 0xFFFFFFFFLL;
  }
  int v10 = v9;
  size_t size = 0;
  if ((int)EVP_PKEY_decrypt_init(v9) < 1) {
    goto LABEL_17;
  }
  if ((int)EVP_PKEY_CTX_ctrl(v10, -1, 512) <= 0)
  {
    int v15 = 152;
    int v16 = 219;
LABEL_16:
    ERR_put_error(33, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v16);
    goto LABEL_17;
  }
  if (EVP_PKEY_decrypt((unsigned __int8 *)v10, 0, (int)&size, *(EVP_PKEY **)(*(void *)(a3 + 24) + 8)) < 1)
  {
LABEL_17:
    uint64_t v14 = 0xFFFFFFFFLL;
LABEL_18:
    EVP_PKEY_CTX_free((EVP_PKEY **)v10);
    return v14;
  }
  uint64_t v11 = (const unsigned __int8 *)malloc_type_malloc(size, 0xEB5B041uLL);
  if (!v11)
  {
    int v15 = 65;
    int v16 = 229;
    goto LABEL_16;
  }
  uint64_t v12 = (unsigned __int8 *)v11;
  BOOL v13 = EVP_PKEY_decrypt((unsigned __int8 *)v10, v11, (int)&size, *(EVP_PKEY **)(*(void *)(a3 + 24) + 8)) < 1
     || size == 0;
  if (!v13 && (!a5 || size == a5))
  {
    freezero(*a1, *a2);
    *a1 = v12;
    *a2 = size;
    uint64_t v14 = 1;
    goto LABEL_18;
  }
  ERR_put_error(33, 4095, 6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", 237);
  EVP_PKEY_CTX_free((EVP_PKEY **)v10);
  free(v12);
  return 0;
}

int PKCS7_dataFinal(PKCS7 *p7, BIO *bio)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  if (!p7)
  {
    int v6 = 143;
    int v7 = 709;
LABEL_7:
    ERR_put_error(33, 4095, v6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v7);
    LODWORD(v8) = 0;
    return (int)v8;
  }
  if (!p7->d.ptr)
  {
    int v6 = 122;
    int v7 = 714;
    goto LABEL_7;
  }
  iint n = 0;
  memset(&v27, 0, sizeof(v27));
  long long v28 = 0u;
  EVP_MD_CTX_init(&v27);
  int v4 = OBJ_obj2nid(p7->type);
  p7->state = 0;
  switch(v4)
  {
    case 21:
      uint64_t ptr = (uint64_t)p7->d.ptr;
      goto LABEL_46;
    case 22:
      uint64_t v11 = p7->d.ptr;
      uint64_t v12 = (const STACK *)*((void *)v11 + 4);
      uint64_t ptr = PKCS7_get_octet_string(*((void *)v11 + 5));
      if ((OBJ_obj2nid(p7->type) != 22 || !PKCS7_ctrl(p7, 2, 0, 0)) && !ptr)
      {
        int v9 = 130;
        int v10 = 755;
        goto LABEL_62;
      }
      if (OBJ_obj2nid(*(const ASN1_OBJECT **)(*((void *)p7->d.ptr + 5) + 24)) == 21 && p7->detached)
      {
        ASN1_OCTET_STRING_free((ASN1_OCTET_STRING *)ptr);
        uint64_t ptr = 0;
        *(void *)(*((void *)p7->d.ptr + 5) + 32) = 0;
      }
      goto LABEL_21;
    case 23:
      uint64_t ptr = *(void *)(*((void *)p7->d.ptr + 2) + 16);
      if (ptr) {
        goto LABEL_46;
      }
      BOOL v13 = ASN1_OCTET_STRING_new();
      if (v13)
      {
        uint64_t ptr = (uint64_t)v13;
        *(void *)(*((void *)p7->d.ptr + 2) + 16) = v13;
        goto LABEL_46;
      }
      int v9 = 65;
      int v10 = 745;
      goto LABEL_62;
    case 24:
      uint64_t v14 = p7->d.ptr;
      uint64_t v12 = (const STACK *)*((void *)v14 + 4);
      uint64_t ptr = *(void *)(*((void *)v14 + 5) + 16);
      if (ptr) {
        goto LABEL_21;
      }
      int v15 = ASN1_OCTET_STRING_new();
      if (!v15)
      {
        int v9 = 65;
        int v10 = 733;
        goto LABEL_62;
      }
      uint64_t ptr = (uint64_t)v15;
      *(void *)(*((void *)p7->d.ptr + 5) + 16) = v15;
LABEL_21:
      if (!v12 || sk_num(v12) < 1) {
        goto LABEL_46;
      }
      int v16 = 0;
      while (2)
      {
        int v17 = sk_value(v12, v16);
        if (!*((void *)v17 + 7)) {
          goto LABEL_37;
        }
        int v18 = (PKCS7_SIGNER_INFO *)v17;
        int v19 = OBJ_obj2nid(**((const ASN1_OBJECT ***)v17 + 2));
        if (!PKCS7_find_digest((const EVP_MD_CTX **)&in, bio, v19) || !EVP_MD_CTX_copy_ex(&v27, in)) {
          goto LABEL_63;
        }
        if (sk_num(v18->auth_attr) < 1)
        {
          *(_DWORD *)mchar d = 0;
          *(_DWORD *)mchar d = EVP_PKEY_size(v18->pkey);
          uint64_t v20 = (unsigned __int8 *)malloc_type_malloc(*(unsigned int *)md, 0x7590445CuLL);
          if (!v20) {
            goto LABEL_63;
          }
          int v21 = v20;
          if (EVP_SignFinal(&v27, v20, (unsigned int *)md, v18->pkey))
          {
            ASN1_STRING_set0(v18->enc_digest, v21, *(int *)md);
            goto LABEL_37;
          }
          int v9 = 6;
          int v10 = 819;
        }
        else if (get_attribute(v18->auth_attr, 52) || PKCS7_add0_attrib_signing_time(v18, 0))
        {
          unsigned int s = 0;
          if (EVP_DigestFinal_ex(&v27, md, &s))
          {
            if (PKCS7_add1_attrib_digest(v18, md, s))
            {
              if (!PKCS7_SIGNER_INFO_sign((uint64_t)v18)) {
                goto LABEL_63;
              }
LABEL_37:
              if (++v16 >= sk_num(v12)) {
                goto LABEL_46;
              }
              continue;
            }
            int v9 = 65;
            int v10 = 684;
          }
          else
          {
            int v9 = 6;
            int v10 = 680;
          }
        }
        else
        {
          int v9 = 65;
          int v10 = 673;
        }
        goto LABEL_62;
      }
    case 25:
      octet_int string = PKCS7_get_octet_string(*((void *)p7->d.ptr + 2));
      if (!octet_string)
      {
        int v9 = 130;
        int v10 = 769;
LABEL_62:
        ERR_put_error(33, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v10);
        goto LABEL_63;
      }
      uint64_t ptr = octet_string;
      if (OBJ_obj2nid(*(const ASN1_OBJECT **)(*((void *)p7->d.ptr + 2) + 24)) == 21 && p7->detached)
      {
        ASN1_OCTET_STRING_free((ASN1_OCTET_STRING *)ptr);
        uint64_t ptr = 0;
        *(void *)(*((void *)p7->d.ptr + 2) + 32) = 0;
      }
      unsigned int s = 0;
      int v23 = OBJ_obj2nid(**((const ASN1_OBJECT ***)p7->d.ptr + 1));
      if (!PKCS7_find_digest((const EVP_MD_CTX **)&in, bio, v23)
        || !EVP_DigestFinal_ex(in, md, &s)
        || !ASN1_STRING_set(*((ASN1_STRING **)p7->d.ptr + 3), md, s))
      {
LABEL_63:
        LODWORD(v8) = 0;
        goto LABEL_64;
      }
LABEL_46:
      if (OBJ_obj2nid(p7->type) == 22 && PKCS7_ctrl(p7, 2, 0, 0)) {
        goto LABEL_52;
      }
      if (!ptr) {
        goto LABEL_63;
      }
      if ((*(unsigned char *)(ptr + 16) & 0x10) != 0) {
        goto LABEL_52;
      }
      *(void *)mchar d = 0;
      int type = BIO_find_type(bio, 1025);
      int v8 = type;
      if (type)
      {
        int v25 = BIO_ctrl(type, 3, 0, md);
        BIO_set_flags(v8, 512);
        BIO_ctrl(v8, 130, 0, 0);
        ASN1_STRING_set0((ASN1_STRING *)ptr, *(void **)md, v25);
LABEL_52:
        LODWORD(v8) = 1;
        goto LABEL_64;
      }
      ERR_put_error(33, 4095, 107, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", 852);
LABEL_64:
      EVP_MD_CTX_cleanup(&v27);
      return (int)v8;
    default:
      int v9 = 112;
      int v10 = 782;
      goto LABEL_62;
  }
}

BIO *PKCS7_find_digest(const EVP_MD_CTX **a1, BIO *b, int a3)
{
  int type = BIO_find_type(b, 520);
  if (type)
  {
    int v6 = type;
    while (1)
    {
      BIO_ctrl(v6, 120, 0, a1);
      if (!*a1) {
        break;
      }
      int v7 = EVP_MD_CTX_md(*a1);
      if (EVP_MD_type(v7) == a3) {
        return v6;
      }
      int v8 = BIO_next(v6);
      int v6 = BIO_find_type(v8, 520);
      if (!v6) {
        goto LABEL_6;
      }
    }
    int v9 = 68;
    int v10 = 654;
  }
  else
  {
LABEL_6:
    int v9 = 108;
    int v10 = 649;
  }
  ERR_put_error(33, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v10);
  return 0;
}

const EVP_MD *PKCS7_SIGNER_INFO_sign(uint64_t a1)
{
  long long v13 = 0u;
  memset(&ctx, 0, sizeof(ctx));
  unsigned __int8 out = 0;
  uint64_t v11 = 0;
  size_t size = 0;
  int v2 = OBJ_obj2nid(**(const ASN1_OBJECT ***)(a1 + 16));
  BOOL v3 = OBJ_nid2sn(v2);
  int result = EVP_get_digestbyname(v3);
  if (result)
  {
    unint64_t v5 = result;
    EVP_MD_CTX_init(&ctx);
    if ((int)EVP_DigestSignInit((uint64_t)&ctx, &v11, v5, 0, *(void *)(a1 + 56)) >= 1)
    {
      if ((int)EVP_PKEY_CTX_ctrl(v11, -1, 8) < 1)
      {
        int v8 = 892;
      }
      else
      {
        int v6 = ASN1_item_i2d(*(ASN1_VALUE **)(a1 + 24), &out, &PKCS7_ATTR_SIGN_it);
        if (!out) {
          goto LABEL_13;
        }
        if (EVP_DigestUpdate(&ctx, out, v6) < 1) {
          goto LABEL_13;
        }
        free(out);
        unsigned __int8 out = 0;
        if ((int)EVP_DigestSignFinal((uint64_t)&ctx, 0, &size) < 1) {
          goto LABEL_13;
        }
        int v7 = (unsigned __int8 *)malloc_type_malloc(size, 0x5979CC37uLL);
        unsigned __int8 out = v7;
        if (!v7 || (int)EVP_DigestSignFinal((uint64_t)&ctx, (uint64_t)v7, &size) < 1) {
          goto LABEL_13;
        }
        if ((int)EVP_PKEY_CTX_ctrl(v11, -1, 8) >= 1)
        {
          EVP_MD_CTX_cleanup(&ctx);
          ASN1_STRING_set0(*(ASN1_STRING **)(a1 + 40), out, size);
          return (const EVP_MD *)1;
        }
        int v8 = 914;
      }
      ERR_put_error(33, 4095, 152, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v8);
    }
LABEL_13:
    free(out);
    EVP_MD_CTX_cleanup(&ctx);
    return 0;
  }
  return result;
}

int PKCS7_dataVerify(X509_STORE *cert_store, X509_STORE_CTX *ctx, BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si)
{
  if (!p7)
  {
    int v14 = 143;
    int v15 = 941;
LABEL_17:
    ERR_put_error(33, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v15);
    return 0;
  }
  if (!p7->d.ptr)
  {
    int v14 = 122;
    int v15 = 946;
    goto LABEL_17;
  }
  if (OBJ_obj2nid(p7->type) != 22 && OBJ_obj2nid(p7->type) != 24)
  {
    int v14 = 114;
    int v15 = 955;
    goto LABEL_17;
  }
  int v10 = (STACK *)*((void *)p7->d.ptr + 2);
  uint64_t v11 = X509_find_by_issuer_and_serial(v10, si->issuer_and_serial->issuer, si->issuer_and_serial->serial);
  if (!v11)
  {
    int v14 = 106;
    int v15 = 965;
    goto LABEL_17;
  }
  uint64_t v12 = v11;
  if (!X509_STORE_CTX_init(ctx, cert_store, v11, v10))
  {
    int v14 = 11;
    int v15 = 971;
    goto LABEL_17;
  }
  if (!X509_STORE_CTX_set_purpose(ctx, 4))
  {
LABEL_20:
    X509_STORE_CTX_cleanup(ctx);
    return 0;
  }
  if (X509_verify_cert(ctx) <= 0)
  {
    ERR_put_error(33, 4095, 11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", 980);
    goto LABEL_20;
  }
  X509_STORE_CTX_cleanup(ctx);
  return PKCS7_signatureVerify(bio, p7, si, v12);
}

int PKCS7_signatureVerify(BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si, X509 *x509)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  long long v35 = 0u;
  memset(&ctx, 0, sizeof(ctx));
  int parg = 0;
  EVP_MD_CTX_init(&ctx);
  if (OBJ_obj2nid(p7->type) == 22 || OBJ_obj2nid(p7->type) == 24)
  {
    int v8 = OBJ_obj2nid(si->digest_alg->algorithm);
    if (bio)
    {
      int v9 = v8;
      while (1)
      {
        int type = BIO_find_type(bio, 520);
        if (!type) {
          goto LABEL_10;
        }
        uint64_t v11 = type;
        BIO_ctrl(type, 120, 0, &parg);
        if (!parg)
        {
          int v14 = 68;
          int v15 = 1023;
          goto LABEL_23;
        }
        uint64_t v12 = EVP_MD_CTX_md(parg);
        if (EVP_MD_type(v12) == v9) {
          break;
        }
        long long v13 = EVP_MD_CTX_md(parg);
        if (EVP_MD_pkey_type(v13) == v9) {
          break;
        }
        int bio = BIO_next(v11);
        if (!bio) {
          goto LABEL_10;
        }
      }
      if (!EVP_MD_CTX_copy_ex(&ctx, parg)) {
        goto LABEL_24;
      }
      auth_attBIGNUM r = si->auth_attr;
      if (auth_attr && sk_num(si->auth_attr))
      {
        unsigned __int8 out = 0;
        unsigned int s = 0;
        if (!EVP_DigestFinal_ex(&ctx, md, &s)) {
          goto LABEL_24;
        }
        attribute = get_attribute(auth_attr, 51);
        if (!attribute || *(_DWORD *)attribute != 4 || (int v18 = (const void **)*((void *)attribute + 1)) == 0)
        {
          int v14 = 108;
          int v15 = 1052;
          goto LABEL_23;
        }
        size_t v19 = *(unsigned int *)v18;
        if (v19 != s || memcmp(v18[1], md, v19))
        {
          int v20 = 101;
          int v21 = 1057;
          goto LABEL_35;
        }
        char v24 = OBJ_nid2sn(v9);
        digestbyname = EVP_get_digestbyname(v24);
        if (!EVP_DigestInit_ex(&ctx, digestbyname, 0)) {
          goto LABEL_24;
        }
        int v26 = ASN1_item_i2d((ASN1_VALUE *)auth_attr, &out, &PKCS7_ATTR_VERIFY_it);
        if (v26 <= 0)
        {
          int v20 = 13;
          int v21 = 1069;
          goto LABEL_35;
        }
        if (!EVP_DigestUpdate(&ctx, out, v26)) {
          goto LABEL_24;
        }
        free(out);
      }
      enc_digest = si->enc_digest;
      pubEVP_PKEY key = X509_get_pubkey(x509);
      if (!pubkey)
      {
LABEL_36:
        int v22 = -1;
        goto LABEL_25;
      }
      int v29 = pubkey;
      int v30 = EVP_VerifyFinal(&ctx, enc_digest->data, enc_digest->length, pubkey);
      EVP_PKEY_free(v29);
      if (v30 > 0)
      {
        int v22 = 1;
        goto LABEL_25;
      }
      int v20 = 105;
      int v21 = 1089;
LABEL_35:
      ERR_put_error(33, 4095, v20, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v21);
      goto LABEL_36;
    }
LABEL_10:
    int v14 = 108;
    int v15 = 1018;
  }
  else
  {
    int v14 = 114;
    int v15 = 1008;
  }
LABEL_23:
  ERR_put_error(33, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_doit.c", v15);
LABEL_24:
  int v22 = 0;
LABEL_25:
  EVP_MD_CTX_cleanup(&ctx);
  return v22;
}

ASN1_OCTET_STRING *__cdecl PKCS7_digest_from_attributes(STACK *sk)
{
  int result = (ASN1_OCTET_STRING *)get_attribute(sk, 51);
  if (result)
  {
    if (result->length == 4) {
      return (ASN1_OCTET_STRING *)result->data;
    }
    else {
      return 0;
    }
  }
  return result;
}

PKCS7_ISSUER_AND_SERIAL *__cdecl PKCS7_get_issuer_and_serial(PKCS7 *p7, int idx)
{
  if (OBJ_obj2nid(p7->type) == 24
    && (uint64_t ptr = p7->d.ptr) != 0
    && (unint64_t v5 = (const STACK *)*((void *)ptr + 6)) != 0
    && (sk_value(*((const STACK **)ptr + 6), 0), sk_num(v5) > idx))
  {
    return (PKCS7_ISSUER_AND_SERIAL *)*((void *)sk_value(v5, idx) + 1);
  }
  else
  {
    return 0;
  }
}

ASN1_TYPE *__cdecl PKCS7_get_signed_attribute(PKCS7_SIGNER_INFO *si, int nid)
{
  return (ASN1_TYPE *)get_attribute(si->auth_attr, nid);
}

char *get_attribute(const STACK *a1, int n)
{
  BOOL v3 = OBJ_nid2obj(n);
  if (!a1) {
    return 0;
  }
  int v4 = v3;
  if (!v3 || sk_num(a1) < 1) {
    return 0;
  }
  int v5 = 0;
  while (1)
  {
    int v6 = sk_value(a1, v5);
    if (!OBJ_cmp(*(const ASN1_OBJECT **)v6, v4)) {
      break;
    }
    if (++v5 >= sk_num(a1)) {
      return 0;
    }
  }
  int v8 = (const STACK *)*((void *)v6 + 1);
  return sk_value(v8, 0);
}

ASN1_TYPE *__cdecl PKCS7_get_attribute(PKCS7_SIGNER_INFO *si, int nid)
{
  return (ASN1_TYPE *)get_attribute(si->unauth_attr, nid);
}

int PKCS7_set_signed_attributes(PKCS7_SIGNER_INFO *p7si, STACK *sk)
{
  auth_attBIGNUM r = p7si->auth_attr;
  if (auth_attr) {
    sk_pop_free(auth_attr, (void (__cdecl *)(void *))X509_ATTRIBUTE_free);
  }
  int v5 = sk_dup(sk);
  p7si->auth_attBIGNUM r = v5;
  if (v5)
  {
    if (sk_num(sk) < 1)
    {
LABEL_8:
      LODWORD(v5) = 1;
    }
    else
    {
      int v6 = 0;
      while (1)
      {
        int v7 = p7si->auth_attr;
        int v8 = sk_value(sk, v6);
        int v9 = (char *)X509_ATTRIBUTE_dup((X509_ATTRIBUTE *)v8);
        int v5 = (STACK *)sk_set(v7, v6, v9);
        if (!v5) {
          break;
        }
        if (++v6 >= sk_num(sk)) {
          goto LABEL_8;
        }
      }
    }
  }
  return (int)v5;
}

int PKCS7_set_attributes(PKCS7_SIGNER_INFO *p7si, STACK *sk)
{
  unauth_attBIGNUM r = p7si->unauth_attr;
  if (unauth_attr) {
    sk_pop_free(unauth_attr, (void (__cdecl *)(void *))X509_ATTRIBUTE_free);
  }
  int v5 = sk_dup(sk);
  p7si->unauth_attBIGNUM r = v5;
  if (v5)
  {
    if (sk_num(sk) < 1)
    {
LABEL_8:
      LODWORD(v5) = 1;
    }
    else
    {
      int v6 = 0;
      while (1)
      {
        int v7 = p7si->unauth_attr;
        int v8 = sk_value(sk, v6);
        int v9 = (char *)X509_ATTRIBUTE_dup((X509_ATTRIBUTE *)v8);
        int v5 = (STACK *)sk_set(v7, v6, v9);
        if (!v5) {
          break;
        }
        if (++v6 >= sk_num(sk)) {
          goto LABEL_8;
        }
      }
    }
  }
  return (int)v5;
}

int PKCS7_add_signed_attribute(PKCS7_SIGNER_INFO *p7si, int nid, int type, void *data)
{
  return add_attribute(&p7si->auth_attr, nid, type, data);
}

uint64_t add_attribute(STACK **a1, int a2, int a3, void *a4)
{
  int v8 = *a1;
  if (!v8)
  {
    uint64_t result = (uint64_t)sk_new_null();
    *a1 = (STACK *)result;
    if (!result) {
      return result;
    }
LABEL_8:
    uint64_t result = (uint64_t)X509_ATTRIBUTE_create(a2, a3, a4);
    if (!result) {
      return result;
    }
    uint64_t v12 = (X509_ATTRIBUTE *)result;
    if (!sk_push(*a1, (char *)result)) {
      goto LABEL_13;
    }
    return 1;
  }
  if (sk_num(v8) < 1) {
    goto LABEL_8;
  }
  int v9 = 0;
  while (1)
  {
    int v10 = (X509_ATTRIBUTE *)sk_value(*a1, v9);
    if (OBJ_obj2nid(v10->object) == a2) {
      break;
    }
    if (++v9 >= sk_num(*a1)) {
      goto LABEL_8;
    }
  }
  X509_ATTRIBUTE_free(v10);
  uint64_t result = (uint64_t)X509_ATTRIBUTE_create(a2, a3, a4);
  if (result)
  {
    uint64_t v12 = (X509_ATTRIBUTE *)result;
    if (!sk_set(*a1, v9, (char *)result))
    {
LABEL_13:
      X509_ATTRIBUTE_free(v12);
      return 0;
    }
    return 1;
  }
  return result;
}

int PKCS7_add_attribute(PKCS7_SIGNER_INFO *p7si, int nid, int atrtype, void *value)
{
  return add_attribute(&p7si->unauth_attr, nid, atrtype, value);
}

void ERR_load_ECDSA_strings(void)
{
  if (!ERR_func_error_string(ECDSA_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&ECDSA_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&ECDSA_str_reasons);
  }
}

STACK *v2i_crld(X509V3_EXT_METHOD *a1, X509V3_CTX *a2, const STACK *a3)
{
  int v6 = sk_new_null();
  if (!v6)
  {
    sectioint n = 0;
    goto LABEL_30;
  }
  if (sk_num(a3) >= 1)
  {
    int v7 = 0;
    int v8 = &DIST_POINT_it;
    int v23 = a1;
    do
    {
      int v9 = (CONF_VALUE *)sk_value(a3, v7);
      if (v9->value)
      {
        int v10 = (char *)v2i_GENERAL_NAME(a1, a2, v9);
        if (!v10)
        {
          sectioint n = 0;
          goto LABEL_34;
        }
        uint64_t v11 = GENERAL_NAMES_new();
        sectioint n = v11;
        if (!v11 || !sk_push(v11, v10)) {
          goto LABEL_31;
        }
        long long v13 = (char *)ASN1_item_new(v8);
        if (!v13) {
          goto LABEL_30;
        }
        int v14 = (ASN1_VALUE *)v13;
        if (!sk_push(v6, v13)) {
          goto LABEL_38;
        }
        int v15 = ASN1_item_new(&DIST_POINT_NAME_it);
        *(void *)int v14 = v15;
        if (!v15) {
          goto LABEL_30;
        }
        *((void *)v15 + 1) = section;
        **(_DWORD **)int v14 = 0;
      }
      else
      {
        sectioint n = X509V3_get_section(a2, v9->name);
        if (!section) {
          goto LABEL_33;
        }
        int v16 = v8;
        int v14 = ASN1_item_new(v8);
        if (!v14)
        {
LABEL_32:
          ASN1_item_free(v14, &DIST_POINT_it);
          X509V3_section_free(a2, section);
          sectioint n = 0;
LABEL_33:
          int v10 = 0;
          goto LABEL_34;
        }
        if (sk_num(section) >= 1)
        {
          for (int i = 0; i < sk_num(section); ++i)
          {
            int v18 = sk_value(section, i);
            int v19 = set_dist_point_name((ASN1_VALUE **)v14, a2, (uint64_t)v18);
            if (v19 <= 0)
            {
              if (v19 < 0) {
                goto LABEL_32;
              }
              int v20 = (const char *)*((void *)v18 + 1);
              if (!strcmp(v20, "reasons"))
              {
                if (!set_reasons((ASN1_BIT_STRING **)v14 + 1, *((char **)v18 + 2))) {
                  goto LABEL_32;
                }
              }
              else if (!strcmp(v20, "CRLissuer"))
              {
                int v21 = gnames_from_sectname(a2, *((char **)v18 + 2));
                *((void *)v14 + 2) = v21;
                if (!v21) {
                  goto LABEL_32;
                }
              }
            }
          }
        }
        X509V3_section_free(a2, section);
        a1 = v23;
        int v8 = v16;
        if (!sk_push(v6, (char *)v14))
        {
          sectioint n = 0;
LABEL_38:
          ASN1_item_free(v14, &DIST_POINT_it);
LABEL_30:
          int v10 = 0;
LABEL_31:
          ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_crld.c", 359);
LABEL_34:
          GENERAL_NAME_free((GENERAL_NAME *)v10);
          GENERAL_NAMES_free(section);
          sk_pop_free(v6, (void (__cdecl *)(void *))DIST_POINT_free);
          return 0;
        }
      }
      ++v7;
    }
    while (v7 < sk_num(a3));
  }
  return v6;
}

uint64_t i2r_crldp(int a1, STACK *a2, BIO *a3, int a4)
{
  if (sk_num(a2) >= 1)
  {
    int v7 = 0;
    do
    {
      BIO_puts(a3, "\n");
      int v8 = sk_value(a2, v7);
      if (*(void *)v8) {
        print_distpoint(a3, *(void *)v8, a4);
      }
      int v9 = (ASN1_BIT_STRING *)*((void *)v8 + 1);
      if (v9) {
        print_reasons(a3, "Reasons", v9, a4);
      }
      if (*((void *)v8 + 2))
      {
        BIO_printf(a3, "%*sCRL Issuer:\n", a4, "");
        print_gens(a3, *((STACK **)v8 + 2), a4);
      }
      ++v7;
    }
    while (v7 < sk_num(a2));
  }
  return 1;
}

DIST_POINT_NAME *__cdecl d2i_DIST_POINT_NAME(DIST_POINT_NAME **a, const unsigned __int8 **in, uint64_t len)
{
  return (DIST_POINT_NAME *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &DIST_POINT_NAME_it);
}

int i2d_DIST_POINT_NAME(DIST_POINT_NAME *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &DIST_POINT_NAME_it);
}

DIST_POINT_NAME *DIST_POINT_NAME_new(void)
{
  return (DIST_POINT_NAME *)ASN1_item_new(&DIST_POINT_NAME_it);
}

void DIST_POINT_NAME_free(DIST_POINT_NAME *a)
{
}

DIST_POINT *__cdecl d2i_DIST_POINT(DIST_POINT **a, const unsigned __int8 **in, uint64_t len)
{
  return (DIST_POINT *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &DIST_POINT_it);
}

int i2d_DIST_POINT(DIST_POINT *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &DIST_POINT_it);
}

DIST_POINT *DIST_POINT_new(void)
{
  return (DIST_POINT *)ASN1_item_new(&DIST_POINT_it);
}

void DIST_POINT_free(DIST_POINT *a)
{
}

CRL_DIST_POINTS *__cdecl d2i_CRL_DIST_POINTS(CRL_DIST_POINTS **a, const unsigned __int8 **in, uint64_t len)
{
  return (CRL_DIST_POINTS *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &CRL_DIST_POINTS_it);
}

int i2d_CRL_DIST_POINTS(CRL_DIST_POINTS *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &CRL_DIST_POINTS_it);
}

CRL_DIST_POINTS *CRL_DIST_POINTS_new(void)
{
  return (CRL_DIST_POINTS *)ASN1_item_new(&CRL_DIST_POINTS_it);
}

void CRL_DIST_POINTS_free(CRL_DIST_POINTS *a)
{
}

ASN1_VALUE *d2i_ISSUING_DIST_POINT(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &ISSUING_DIST_POINT_it);
}

uint64_t i2d_ISSUING_DIST_POINT(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &ISSUING_DIST_POINT_it);
}

ASN1_VALUE *ISSUING_DIST_POINT_new()
{
  return ASN1_item_new(&ISSUING_DIST_POINT_it);
}

void ISSUING_DIST_POINT_free(ASN1_VALUE *a1)
{
}

ASN1_VALUE *v2i_idp(uint64_t a1, X509V3_CTX *a2, const STACK *a3)
{
  int v5 = ASN1_item_new(&ISSUING_DIST_POINT_it);
  if (!v5)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_crld.c", 714);
    goto LABEL_21;
  }
  if (sk_num(a3) >= 1)
  {
    for (int i = 0; i < sk_num(a3); ++i)
    {
      int v7 = sk_value(a3, i);
      int v9 = (const char *)*((void *)v7 + 1);
      int v8 = (char *)*((void *)v7 + 2);
      int v10 = set_dist_point_name((ASN1_VALUE **)v5, a2, (uint64_t)v7);
      if (v10 <= 0)
      {
        if (v10 < 0) {
          goto LABEL_21;
        }
        if (!strcmp(v9, "onlyuser"))
        {
          uint64_t v11 = (CONF_VALUE *)v7;
          uint64_t v12 = (int *)((char *)v5 + 8);
          goto LABEL_17;
        }
        if (!strcmp(v9, "onlyCA"))
        {
          uint64_t v11 = (CONF_VALUE *)v7;
          uint64_t v12 = (int *)((char *)v5 + 12);
          goto LABEL_17;
        }
        if (!strcmp(v9, "onlyAA"))
        {
          uint64_t v11 = (CONF_VALUE *)v7;
          uint64_t v12 = (int *)((char *)v5 + 28);
          goto LABEL_17;
        }
        if (!strcmp(v9, "indirectCRL"))
        {
          uint64_t v11 = (CONF_VALUE *)v7;
          uint64_t v12 = (int *)((char *)v5 + 24);
LABEL_17:
          if (!X509V3_get_value_BOOL(v11, v12)) {
            goto LABEL_21;
          }
          continue;
        }
        if (strcmp(v9, "onlysomereasons"))
        {
          ERR_put_error(34, 4095, 106, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_crld.c", 706);
          ERR_asprintf_error_data("section:%s,name:%s,value:%s", *(const char **)v7, *((const char **)v7 + 1), *((const char **)v7 + 2));
LABEL_21:
          ASN1_item_free(v5, &ISSUING_DIST_POINT_it);
          return 0;
        }
        if (!set_reasons((ASN1_BIT_STRING **)v5 + 2, v8)) {
          goto LABEL_21;
        }
      }
    }
  }
  return v5;
}

uint64_t i2r_idp(int a1, uint64_t a2, BIO *bio, int a4)
{
  uint64_t v7 = *(void *)a2;
  if (v7) {
    print_distpoint(bio, v7, a4);
  }
  if (*(int *)(a2 + 8) >= 1) {
    BIO_printf(bio, "%*sOnly User Certificates\n", a4, "");
  }
  if (*(int *)(a2 + 12) >= 1) {
    BIO_printf(bio, "%*sOnly CA Certificates\n", a4, "");
  }
  if (*(int *)(a2 + 24) >= 1) {
    BIO_printf(bio, "%*sIndirect CRL\n", a4, "");
  }
  int v8 = *(ASN1_BIT_STRING **)(a2 + 16);
  if (v8) {
    print_reasons(bio, "Only Some Reasons", v8, a4);
  }
  if (*(int *)(a2 + 28) >= 1) {
    BIO_printf(bio, "%*sOnly Attribute Certificates\n", a4, "");
  }
  if (!*(void *)a2
    && *(int *)(a2 + 8) <= 0
    && *(int *)(a2 + 12) <= 0
    && *(int *)(a2 + 24) <= 0
    && !*(void *)(a2 + 16)
    && *(int *)(a2 + 28) <= 0)
  {
    BIO_printf(bio, "%*s<EMPTY>\n", a4, "");
  }
  return 1;
}

uint64_t DIST_POINT_set_dpname(uint64_t a1, X509_NAME *xn)
{
  if (!a1) {
    return 1;
  }
  if (*(_DWORD *)a1 != 1) {
    return 1;
  }
  BOOL v3 = *(const STACK **)(a1 + 8);
  uint64_t result = (uint64_t)X509_NAME_dup(xn);
  *(void *)(a1 + 16) = result;
  if (!result) {
    return result;
  }
  if (sk_num(v3) >= 1)
  {
    int v5 = 0;
    do
    {
      int v6 = sk_value(v3, v5);
      if (!X509_NAME_add_entry(*(X509_NAME **)(a1 + 16), (X509_NAME_ENTRY *)v6, -1, v5 == 0)) {
        goto LABEL_11;
      }
    }
    while (++v5 < sk_num(v3));
  }
  if ((i2d_X509_NAME(*(X509_NAME **)(a1 + 16), 0) & 0x80000000) == 0) {
    return 1;
  }
LABEL_11:
  X509_NAME_free(*(X509_NAME **)(a1 + 16));
  uint64_t result = 0;
  *(void *)(a1 + 16) = 0;
  return result;
}

uint64_t set_dist_point_name(ASN1_VALUE **a1, X509V3_CTX *a2, uint64_t a3)
{
  int v6 = *(const char **)(a3 + 8);
  if (!strncmp(v6, "fullname", 9uLL))
  {
    int v8 = gnames_from_sectname(a2, *(char **)(a3 + 16));
    entrieunsigned int s = 0;
    int v10 = 0;
    if (!v8)
    {
LABEL_15:
      sk_pop_free(v10, (void (__cdecl *)(void *))GENERAL_NAME_free);
      sk_pop_free(entries, (void (__cdecl *)(void *))X509_NAME_ENTRY_free);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    if (strcmp(v6, "relativename")) {
      return 0;
    }
    uint64_t v11 = X509_NAME_new();
    if (!v11) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v12 = v11;
    sectioint n = X509V3_get_section(a2, *(char **)(a3 + 16));
    if (!section)
    {
      ERR_put_error(34, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_crld.c", 150);
      X509_NAME_free(v12);
      return 0xFFFFFFFFLL;
    }
    int v14 = section;
    int v15 = X509V3_NAME_from_section(v12, section, 0x1001uLL);
    X509V3_section_free(a2, v14);
    entrieunsigned int s = v12->entries;
    v12->entrieunsigned int s = 0;
    X509_NAME_free(v12);
    if (!v15 || sk_num(entries) < 1) {
      goto LABEL_14;
    }
    int v16 = sk_num(entries);
    if (*((_DWORD *)sk_value(entries, v16 - 1) + 4))
    {
      ERR_put_error(34, 4095, 161, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_crld.c", 166);
LABEL_14:
      int v10 = 0;
      goto LABEL_15;
    }
    int v8 = 0;
  }
  if (*a1)
  {
    ERR_put_error(34, 4095, 160, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_crld.c", 173);
LABEL_7:
    int v10 = v8;
    goto LABEL_15;
  }
  int v17 = ASN1_item_new(&DIST_POINT_NAME_it);
  *a1 = v17;
  if (!v17) {
    goto LABEL_7;
  }
  int v18 = v17;
  if (v8)
  {
    *(_DWORD *)int v17 = 0;
    *((void *)v17 + 1) = v8;
    return 1;
  }
  else
  {
    uint64_t result = 1;
    *(_DWORD *)int v18 = 1;
    *((void *)v18 + 1) = entries;
  }
  return result;
}

uint64_t set_reasons(ASN1_BIT_STRING **a1, char *line)
{
  if (*a1) {
    return 0;
  }
  int v4 = X509V3_parse_list(line);
  if (!v4) {
    return 0;
  }
  int v5 = v4;
  if (sk_num(v4) < 1)
  {
LABEL_14:
    uint64_t v2 = 1;
  }
  else
  {
    int v6 = 0;
    while (1)
    {
      uint64_t v7 = (const char *)*((void *)sk_value(v5, v6) + 1);
      int v8 = *a1;
      if (!*a1)
      {
        int v8 = ASN1_BIT_STRING_new();
        *a1 = v8;
        if (!v8) {
          break;
        }
      }
      int v9 = off_264E441C0;
      while (strcmp(*(v9 - 2), v7))
      {
        int v10 = *v9;
        v9 += 3;
        if (!v10) {
          goto LABEL_15;
        }
      }
      if (!ASN1_BIT_STRING_set_bit(v8, *((_DWORD *)v9 - 8), 1)) {
        break;
      }
      if (++v6 >= sk_num(v5)) {
        goto LABEL_14;
      }
    }
LABEL_15:
    uint64_t v2 = 0;
  }
  sk_pop_free(v5, (void (__cdecl *)(void *))X509V3_conf_free);
  return v2;
}

GENERAL_NAMES *gnames_from_sectname(X509V3_CTX *ctx, char *line)
{
  if (*line == 64) {
    sectioint n = X509V3_get_section(ctx, line + 1);
  }
  else {
    sectioint n = X509V3_parse_list(line);
  }
  int v5 = section;
  if (section)
  {
    int v6 = v2i_GENERAL_NAMES(0, ctx, section);
    if (*line == 64) {
      X509V3_section_free(ctx, v5);
    }
    else {
      sk_pop_free(v5, (void (__cdecl *)(void *))X509V3_conf_free);
    }
  }
  else
  {
    ERR_put_error(34, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_crld.c", 120);
    return 0;
  }
  return v6;
}

uint64_t dpn_cb(int a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (a1 == 3)
  {
    BOOL v3 = *(X509_NAME **)(v2 + 16);
    if (v3) {
      X509_NAME_free(v3);
    }
  }
  else if (a1 == 1)
  {
    *(void *)(v2 + 16) = 0;
  }
  return 1;
}

uint64_t print_distpoint(BIO *bio, uint64_t a2, int a3)
{
  if (*(_DWORD *)a2)
  {
    memset(&nm[8], 0, 32);
    *(void *)nm = *(void *)(a2 + 8);
    BIO_printf(bio, "%*sRelative Name:\n%*s", a3, "", a3 + 2, "");
    X509_NAME_print_ex(bio, (X509_NAME *)nm, 0, 0x82031FuLL);
    return BIO_puts(bio, "\n");
  }
  else
  {
    BIO_printf(bio, "%*sFull Name:\n", a3, "");
    uint64_t v7 = *(STACK **)(a2 + 8);
    return print_gens(bio, v7, a3);
  }
}

uint64_t print_reasons(BIO *a1, const char *a2, ASN1_BIT_STRING *a3, int a4)
{
  BIO_printf(a1, "%*s%s:\n%*s", a4, "", a2, a4 + 2, "");
  char v6 = 0;
  uint64_t v7 = &reason_flags;
  int v8 = "Unused";
LABEL_2:
  for (int i = *v7; ; int i = v10)
  {
    if (ASN1_BIT_STRING_get_bit(a3, i))
    {
      if (v6) {
        BIO_puts(a1, ", ");
      }
      BIO_puts(a1, v8);
      int v8 = (const char *)*((void *)v7 + 4);
      v7 += 6;
      char v6 = 1;
      if (!v8) {
        goto LABEL_11;
      }
      goto LABEL_2;
    }
    int v8 = (const char *)*((void *)v7 + 4);
    if (!v8) {
      break;
    }
    int v10 = v7[6];
    v7 += 6;
  }
  if (v6)
  {
LABEL_11:
    uint64_t v11 = "\n";
    goto LABEL_13;
  }
  uint64_t v11 = "<EMPTY>\n";
LABEL_13:
  return BIO_puts(a1, v11);
}

uint64_t print_gens(BIO *a1, STACK *a2, int a3)
{
  uint64_t result = sk_num(a2);
  if ((int)result >= 1)
  {
    int v7 = 0;
    do
    {
      BIO_printf(a1, "%*s", a3 + 2, "");
      int v8 = sk_value(a2, v7);
      GENERAL_NAME_print(a1, (GENERAL_NAME *)v8);
      BIO_puts(a1, "\n");
      ++v7;
      uint64_t result = sk_num(a2);
    }
    while (v7 < (int)result);
  }
  return result;
}

void ASN1_item_free(ASN1_VALUE *val, const ASN1_ITEM *it)
{
  pval = val;
  asn1_item_free(&pval, (ASN1_ITEM *)it);
}

void asn1_item_free(ASN1_VALUE **pval, ASN1_ITEM *it)
{
  if (pval)
  {
    funcunsigned int s = it->funcs;
    if (!it->itype || *pval)
    {
      if (funcs) {
        int v5 = (unsigned int (*)(uint64_t, ASN1_VALUE **, ASN1_ITEM *, void))*((void *)funcs + 3);
      }
      else {
        int v5 = 0;
      }
      switch(it->itype)
      {
        case 0:
          templateunsigned int s = it->templates;
          if (!templates) {
            goto LABEL_21;
          }
          ASN1_template_free(pval, templates);
          break;
        case 1:
        case 6:
          if (asn1_do_lock(pval, -1, it) <= 0 && (!v5 || v5(2, pval, it, 0) != 2))
          {
            asn1_enc_cleanup(pval, (uint64_t)it);
            uint64_t tcount = it->tcount;
            if (tcount >= 1)
            {
              uint64_t v7 = 0;
              int v8 = &it->templates[tcount - 1];
              do
              {
                int v9 = asn1_do_adb(pval, v8, 0);
                if (v9)
                {
                  int v10 = v9;
                  field_uint64_t ptr = asn1_get_field_ptr(pval, v9);
                  ASN1_template_free(field_ptr, v10);
                }
                ++v7;
                --v8;
              }
              while (it->tcount > v7);
            }
            goto LABEL_29;
          }
          break;
        case 2:
          if (!v5 || v5(2, pval, it, 0) != 2)
          {
            choice_selectoBIGNUM r = asn1_get_choice_selector(pval, it);
            if ((choice_selector & 0x80000000) == 0 && it->tcount > choice_selector)
            {
              int v14 = &it->templates[choice_selector];
              int v15 = asn1_get_field_ptr(pval, v14);
              ASN1_template_free(v15, v14);
            }
LABEL_29:
            if (v5) {
              v5(3, pval, it, 0);
            }
            free(*pval);
            ASN1_VALUE *pval = 0;
          }
          break;
        case 4:
          if (funcs)
          {
            int v16 = (void (*)(void))*((void *)funcs + 2);
            if (v16)
            {
              v16();
            }
          }
          break;
        case 5:
LABEL_21:
          ASN1_primitive_free(pval, it);
          break;
        default:
          return;
      }
    }
  }
}

void ASN1_template_free(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt)
{
  if ((tt->flags & 6) != 0)
  {
    int v4 = (STACK *)*pval;
    if (sk_num((const STACK *)*pval) >= 1)
    {
      int v5 = 0;
      do
      {
        pvalEVP_CIPHER_CTX a = 0;
        pvalEVP_CIPHER_CTX a = (ASN1_VALUE *)sk_value(v4, v5);
        asn1_item_free(&pvala, tt->item);
        ++v5;
      }
      while (v5 < sk_num(v4));
    }
    sk_free(v4);
    ASN1_VALUE *pval = 0;
  }
  else
  {
    item = tt->item;
    asn1_item_free(pval, item);
  }
}

void ASN1_primitive_free(ASN1_VALUE **pval, const ASN1_ITEM *it)
{
  uint64_t v2 = pval;
  if (!it)
  {
    int v5 = *pval;
    uint64_t v2 = (ASN1_VALUE **)((char *)*pval + 8);
    char v6 = *v2;
    if (!*v2) {
      return;
    }
    uint type = *(_DWORD *)v5;
    goto LABEL_8;
  }
  funcunsigned int s = it->funcs;
  if (!funcs)
  {
    if (it->itype == 5)
    {
      char v6 = *pval;
      if (!*v2) {
        return;
      }
      goto LABEL_19;
    }
    uint type = it->utype;
    if (utype == 1) {
      goto LABEL_21;
    }
    char v6 = *pval;
    if (!*v2) {
      return;
    }
LABEL_8:
    if (utype > 4)
    {
      if (utype != 5)
      {
        if (utype != 6)
        {
LABEL_19:
          ASN1_STRING_free((ASN1_STRING *)v6);
          goto LABEL_26;
        }
        ASN1_OBJECT_free((ASN1_OBJECT *)v6);
      }
LABEL_26:
      *uint64_t v2 = 0;
      return;
    }
    if (utype == -4)
    {
      ASN1_primitive_free(v2, 0);
      free(*v2);
      goto LABEL_26;
    }
    if (utype != 1) {
      goto LABEL_19;
    }
    if (!it)
    {
      int size = -1;
LABEL_22:
      *(_DWORD *)uint64_t v2 = size;
      return;
    }
LABEL_21:
    int size = it->size;
    goto LABEL_22;
  }
  int v4 = (void (*)(void))*((void *)funcs + 3);
  v4();
}

DH *__cdecl d2i_DHparams(DH **a, const unsigned __int8 **pp, uint64_t length)
{
  return (DH *)ASN1_item_d2i((ASN1_VALUE **)a, pp, length, &DHparams_it);
}

int i2d_DHparams(const DH *a, unsigned __int8 **pp)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, pp, &DHparams_it);
}

void *d2i_DHparams_bio(BIO *in, void *x)
{
  return ASN1_item_d2i_bio(&DHparams_it, in, x);
}

uint64_t i2d_DHparams_bio(BIO *out, void *x)
{
  return ASN1_item_i2d_bio(&DHparams_it, out, x);
}

void *d2i_DHparams_fp(FILE *in, void *x)
{
  return ASN1_item_d2i_fp(&DHparams_it, in, x);
}

uint64_t i2d_DHparams_fp(FILE *out, void *x)
{
  return ASN1_item_i2d_fp(&DHparams_it, out, x);
}

void *DHparams_dup(void *x)
{
  return ASN1_item_dup(&DHparams_it, x);
}

uint64_t dh_cb(int a1, DH **a2)
{
  if (a1 == 2)
  {
    DH_free(*a2);
    *a2 = 0;
    return 2;
  }
  else if (a1)
  {
    return 1;
  }
  else
  {
    BOOL v3 = DH_new();
    *a2 = v3;
    return 2 * (v3 != 0);
  }
}

int X509at_get_attr_by_NID(const STACK *x, int nid, int lastpos)
{
  int v5 = OBJ_nid2obj(nid);
  if (!v5) {
    return -2;
  }
  return X509at_get_attr_by_OBJ(x, v5, lastpos);
}

int X509at_get_attr_by_OBJ(const STACK *sk, ASN1_OBJECT *obj, int lastpos)
{
  if (sk)
  {
    if (lastpos < 0) {
      int v5 = -1;
    }
    else {
      int v5 = lastpos;
    }
    int v6 = sk_num(sk);
    while (++v5 < v6)
    {
      uint64_t v7 = sk_value(sk, v5);
      if (!OBJ_cmp(*(const ASN1_OBJECT **)v7, obj)) {
        return v5;
      }
    }
  }
  return -1;
}

X509_ATTRIBUTE *__cdecl X509at_get_attr(const STACK *x, int loc)
{
  if (!x) {
    return 0;
  }
  int v4 = sk_num(x);
  if (loc < 0 || v4 <= loc) {
    return 0;
  }
  return (X509_ATTRIBUTE *)sk_value(x, loc);
}

X509_ATTRIBUTE *__cdecl X509at_delete_attr(STACK *x, int loc)
{
  if (!x) {
    return 0;
  }
  int v4 = sk_num(x);
  if (loc < 0 || v4 <= loc) {
    return 0;
  }
  return (X509_ATTRIBUTE *)sk_delete(x, loc);
}

STACK *__cdecl X509at_add1_attr(STACK **x, X509_ATTRIBUTE *attr)
{
  if (!x)
  {
    ERR_put_error(11, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_att.c", 141);
    return 0;
  }
  int v4 = *x;
  if (!*x)
  {
    int v4 = sk_new_null();
    if (!v4)
    {
      ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_att.c", 160);
      return v4;
    }
  }
  int v5 = (char *)X509_ATTRIBUTE_dup(attr);
  if (!v5)
  {
LABEL_10:
    if (v4 != *x) {
      sk_free(v4);
    }
    return 0;
  }
  int v6 = (X509_ATTRIBUTE *)v5;
  if (!sk_push(v4, v5))
  {
    ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_att.c", 160);
    X509_ATTRIBUTE_free(v6);
    goto LABEL_10;
  }
  if (!*x) {
    ASN1_INTEGER *x = v4;
  }
  return v4;
}

STACK *__cdecl X509at_add1_attr_by_OBJ(STACK **x, const ASN1_OBJECT *obj, int type, const unsigned __int8 *bytes, int len)
{
  uint64_t result = (STACK *)X509_ATTRIBUTE_create_by_OBJ(0, obj, type, bytes, len);
  if (result)
  {
    uint64_t v7 = result;
    int v8 = X509at_add1_attr(x, (X509_ATTRIBUTE *)result);
    X509_ATTRIBUTE_free((X509_ATTRIBUTE *)v7);
    return v8;
  }
  return result;
}

X509_ATTRIBUTE *__cdecl X509_ATTRIBUTE_create_by_OBJ(X509_ATTRIBUTE **attr, const ASN1_OBJECT *obj, int atrtype, const void *data, int len)
{
  if (attr && (int v10 = *attr) != 0 || (int v10 = X509_ATTRIBUTE_new()) != 0)
  {
    if (X509_ATTRIBUTE_set1_object(v10, obj) && X509_ATTRIBUTE_set1_data(v10, atrtype, data, len))
    {
      if (attr && !*attr) {
        *attBIGNUM r = v10;
      }
    }
    else
    {
      if (!attr || v10 != *attr) {
        X509_ATTRIBUTE_free(v10);
      }
      return 0;
    }
  }
  else
  {
    ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_att.c", 264);
  }
  return v10;
}

STACK *__cdecl X509at_add1_attr_by_NID(STACK **x, int nid, int type, const unsigned __int8 *bytes, int len)
{
  uint64_t result = (STACK *)X509_ATTRIBUTE_create_by_NID(0, nid, type, bytes, len);
  if (result)
  {
    uint64_t v7 = result;
    int v8 = X509at_add1_attr(x, (X509_ATTRIBUTE *)result);
    X509_ATTRIBUTE_free((X509_ATTRIBUTE *)v7);
    return v8;
  }
  return result;
}

X509_ATTRIBUTE *__cdecl X509_ATTRIBUTE_create_by_NID(X509_ATTRIBUTE **attr, int nid, int atrtype, const void *data, int len)
{
  int v9 = OBJ_nid2obj(nid);
  if (v9)
  {
    int v10 = v9;
    uint64_t result = X509_ATTRIBUTE_create_by_OBJ(attr, v9, atrtype, data, len);
    if (result) {
      return result;
    }
    ASN1_OBJECT_free(v10);
  }
  else
  {
    ERR_put_error(11, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_att.c", 246);
  }
  return 0;
}

STACK *__cdecl X509at_add1_attr_by_txt(STACK **x, const char *attrname, int type, const unsigned __int8 *bytes, int len)
{
  uint64_t result = (STACK *)X509_ATTRIBUTE_create_by_txt(0, attrname, type, bytes, len);
  if (result)
  {
    uint64_t v7 = result;
    int v8 = X509at_add1_attr(x, (X509_ATTRIBUTE *)result);
    X509_ATTRIBUTE_free((X509_ATTRIBUTE *)v7);
    return v8;
  }
  return result;
}

X509_ATTRIBUTE *__cdecl X509_ATTRIBUTE_create_by_txt(X509_ATTRIBUTE **attr, const char *atrname, int type, const unsigned __int8 *bytes, int len)
{
  int v10 = OBJ_txt2obj(atrname, 0);
  if (v10)
  {
    uint64_t v11 = v10;
    uint64_t v12 = X509_ATTRIBUTE_create_by_OBJ(attr, v10, type, bytes, len);
    ASN1_OBJECT_free(v11);
    return v12;
  }
  else
  {
    ERR_put_error(11, 4095, 119, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_att.c", 295);
    ERR_asprintf_error_data("name=%s", atrname);
    return 0;
  }
}

void *__cdecl X509at_get0_data_by_OBJ(STACK *x, ASN1_OBJECT *obj, int lastpos, int type)
{
  int attr_by_OBJ = X509at_get_attr_by_OBJ(x, obj, lastpos);
  if (attr_by_OBJ == -1) {
    return 0;
  }
  int v9 = attr_by_OBJ;
  if (lastpos >= -1)
  {
    attBIGNUM r = X509at_get_attr(x, attr_by_OBJ);
    goto LABEL_6;
  }
  if (X509at_get_attr_by_OBJ(x, obj, attr_by_OBJ) != -1) {
    return 0;
  }
  long long v13 = X509at_get_attr(x, v9);
  attBIGNUM r = v13;
  if (lastpos <= 0xFFFFFFFD && (!v13 || sk_num(*(const STACK **)&v13->single) != 1)) {
    return 0;
  }
LABEL_6:
  return X509_ATTRIBUTE_get0_data(attr, 0, type, v11);
}

int X509_ATTRIBUTE_count(X509_ATTRIBUTE *attr)
{
  if (attr) {
    LODWORD(attr) = sk_num(*(const STACK **)&attr->single);
  }
  return (int)attr;
}

void *__cdecl X509_ATTRIBUTE_get0_data(void *attr, int idx, int atrtype, void *data)
{
  if (attr)
  {
    attBIGNUM r = sk_value(*((const STACK **)attr + 1), idx);
    if (attr)
    {
      int v5 = attr;
      if (ASN1_TYPE_get((ASN1_TYPE *)attr) == atrtype)
      {
        return (void *)*((void *)v5 + 1);
      }
      else
      {
        ERR_put_error(11, 4095, 122, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_att.c", 398);
        return 0;
      }
    }
  }
  return attr;
}

int X509_ATTRIBUTE_set1_object(X509_ATTRIBUTE *attr, const ASN1_OBJECT *obj)
{
  int result = 0;
  if (attr)
  {
    if (obj)
    {
      ASN1_OBJECT_free(attr->object);
      int v5 = OBJ_dup(obj);
      attr->char object = v5;
      return v5 != 0;
    }
  }
  return result;
}

int X509_ATTRIBUTE_set1_data(X509_ATTRIBUTE *attr, int attrtype, const void *data, int len)
{
  if (attr)
  {
    uint64_t v7 = attr;
    if ((attrtype & 0x1000) != 0)
    {
      int v8 = OBJ_obj2nid(attr->object);
      int v9 = ASN1_STRING_set_by_NID(0, (const unsigned __int8 *)data, len, attrtype, v8);
      if (!v9)
      {
        int v14 = 13;
        int v15 = 330;
LABEL_22:
        ERR_put_error(11, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_att.c", v15);
        LODWORD(attr) = 0;
        return (int)attr;
      }
      int v10 = v9;
      int type = v9->type;
      goto LABEL_13;
    }
    if (len == -1)
    {
      int v10 = 0;
      int type = 0;
      if (!attrtype) {
        goto LABEL_9;
      }
    }
    else
    {
      uint64_t v12 = ASN1_STRING_type_new(attrtype);
      int v10 = v12;
      if (!v12 || !ASN1_STRING_set(v12, data, len))
      {
        long long v13 = 0;
        goto LABEL_21;
      }
      int type = attrtype;
      if (!attrtype)
      {
LABEL_9:
        ASN1_STRING_free(v10);
LABEL_20:
        LODWORD(attr) = 1;
        return (int)attr;
      }
    }
LABEL_13:
    int v16 = ASN1_TYPE_new();
    long long v13 = (char *)v16;
    if (v16)
    {
      if ((attrtype & 0x1000) != 0 || len != -1)
      {
        ASN1_TYPE_set(v16, type, v10);
      }
      else if (!ASN1_TYPE_set1(v16, attrtype, data))
      {
        goto LABEL_21;
      }
      if (sk_push(*(STACK **)&v7->single, v13)) {
        goto LABEL_20;
      }
    }
LABEL_21:
    ASN1_TYPE_free((ASN1_TYPE *)v13);
    ASN1_STRING_free(v10);
    int v14 = 65;
    int v15 = 365;
    goto LABEL_22;
  }
  return (int)attr;
}

ASN1_OBJECT *__cdecl X509_ATTRIBUTE_get0_object(ASN1_OBJECT *attr)
{
  if (attr) {
    return (ASN1_OBJECT *)attr->sn;
  }
  return attr;
}

ASN1_TYPE *__cdecl X509_ATTRIBUTE_get0_type(ASN1_TYPE *attr, int idx)
{
  if (attr) {
    return (ASN1_TYPE *)sk_value((const STACK *)attr->value.ptr, idx);
  }
  return attr;
}

int EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, const unsigned __int8 *key, const unsigned __int8 *iv, int enc)
{
  if (cipher)
  {
    *(void *)&ctx->final[24] = 0;
    *(_OWORD *)&ctx->final_usechar d = 0u;
    *(_OWORD *)&ctx->final[8] = 0u;
    *(_OWORD *)&ctx->app_unint64_t data = 0u;
    *(_OWORD *)&ctx->flagunsigned int s = 0u;
    *(_OWORD *)&ctx->buf[8] = 0u;
    *(_OWORD *)&ctx->buf[24] = 0u;
    *(_OWORD *)&ctx->oiv[8] = 0u;
    *(_OWORD *)&ctx->iv[8] = 0u;
    *(_OWORD *)&ctx->cipheBIGNUM r = 0u;
    *(_OWORD *)&ctx->encrypt = 0u;
  }
  return EVP_CipherInit_ex(ctx, cipher, 0, key, iv, enc);
}

void EVP_CIPHER_CTX_init(EVP_CIPHER_CTX *a)
{
  *(void *)&a->final[24] = 0;
  *(_OWORD *)&a->final_usechar d = 0u;
  *(_OWORD *)&a->final[8] = 0u;
  *(_OWORD *)&a->app_unint64_t data = 0u;
  *(_OWORD *)&a->flagunsigned int s = 0u;
  *(_OWORD *)&a->buf[8] = 0u;
  *(_OWORD *)&a->buf[24] = 0u;
  *(_OWORD *)&a->oiv[8] = 0u;
  *(_OWORD *)&a->iv[8] = 0u;
  *(_OWORD *)&a->cipheBIGNUM r = 0u;
  *(_OWORD *)&a->encrypt = 0u;
}

int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl, const unsigned __int8 *key, const unsigned __int8 *iv, int enc)
{
  int v9 = cipher;
  if (enc == -1)
  {
    uint64_t encrypt = ctx->encrypt;
  }
  else
  {
    uint64_t encrypt = enc != 0;
    ctx->uint64_t encrypt = encrypt;
  }
  uint64_t v12 = ctx->cipher;
  if (!ctx->engine)
  {
    if (cipher)
    {
      if (!v12) {
        goto LABEL_13;
      }
      goto LABEL_11;
    }
    if (v12) {
      goto LABEL_28;
    }
LABEL_22:
    int v14 = 131;
    int v15 = 163;
    goto LABEL_43;
  }
  if (v12)
  {
    if (!cipher || cipher->nid == v12->nid) {
      goto LABEL_28;
    }
LABEL_11:
    flagunsigned int s = ctx->flags;
    EVP_CIPHER_CTX_cleanup(ctx);
    ctx->uint64_t encrypt = encrypt;
    ctx->flagunsigned int s = flags;
    goto LABEL_13;
  }
  if (!cipher) {
    goto LABEL_22;
  }
LABEL_13:
  if (impl)
  {
    if (!ENGINE_init(impl))
    {
      int v14 = 134;
      int v15 = 120;
      goto LABEL_43;
    }
  }
  else
  {
    impl = ENGINE_get_cipher_engine(v9->nid);
    if (!impl) {
      goto LABEL_18;
    }
  }
  int v9 = ENGINE_get_cipher(impl, v9->nid);
  if (!v9)
  {
    int v14 = 134;
    int v15 = 131;
    goto LABEL_43;
  }
LABEL_18:
  ctx->cipheBIGNUM r = v9;
  ctx->engine = impl;
  ctx_int size = v9->ctx_size;
  if (ctx_size)
  {
    int v17 = malloc_type_calloc(1uLL, ctx_size, 0xDC090842uLL);
    ctx->cipher_unint64_t data = v17;
    if (!v17)
    {
      int v14 = 65;
      int v15 = 148;
      goto LABEL_43;
    }
    uint64_t v12 = ctx->cipher;
  }
  else
  {
    ctx->cipher_unint64_t data = 0;
    uint64_t v12 = v9;
  }
  ctx->key_leint n = v9->key_len;
  ctx->flags &= 1uLL;
  if ((v12->flags & 0x40) != 0)
  {
    if (!EVP_CIPHER_CTX_ctrl(ctx, 0, 0, 0))
    {
      int v14 = 134;
      int v15 = 158;
      goto LABEL_43;
    }
    uint64_t v12 = ctx->cipher;
  }
LABEL_28:
  block_int size = v12->block_size;
  BOOL v19 = block_size > 0x10;
  int v20 = (1 << block_size) & 0x10102;
  if (v19 || v20 == 0)
  {
    int v14 = 136;
    int v15 = 173;
  }
  else
  {
    if ((ctx->flags & 1) != 0 || (EVP_CIPHER_CTX_flags(ctx) & 0xF0007) != 0x10002)
    {
      if ((EVP_CIPHER_CTX_flags(ctx) & 0x10) == 0)
      {
        switch(EVP_CIPHER_CTX_flags(ctx) & 0xF0007)
        {
          case 0uLL:
          case 1uLL:
            break;
          case 2uLL:
            goto LABEL_38;
          case 3uLL:
          case 4uLL:
            ctx->int num = 0;
LABEL_38:
            if (EVP_CIPHER_CTX_iv_length(ctx) >= 0x11)
            {
              int v14 = 102;
              int v15 = 200;
              goto LABEL_43;
            }
            if (iv)
            {
              int v23 = EVP_CIPHER_CTX_iv_length(ctx);
              memcpy(ctx->oiv, iv, v23);
            }
            size_t v24 = EVP_CIPHER_CTX_iv_length(ctx);
            int v25 = ctx->iv;
            oiv = ctx->oiv;
LABEL_51:
            memcpy(v25, oiv, v24);
            break;
          case 5uLL:
            ctx->int num = 0;
            if (!iv) {
              break;
            }
            size_t v24 = EVP_CIPHER_CTX_iv_length(ctx);
            int v25 = ctx->iv;
            oiv = iv;
            goto LABEL_51;
          default:
            return 0;
        }
      }
      EVP_MD_CTX v27 = ctx->cipher;
      if (key || (v27->flags & 0x20) != 0)
      {
        int result = ((uint64_t (*)(EVP_CIPHER_CTX *, const unsigned __int8 *, const unsigned __int8 *, uint64_t))v27->init)(ctx, key, iv, encrypt);
        if (!result) {
          return result;
        }
        EVP_MD_CTX v27 = ctx->cipher;
      }
      ctx->buf_leint n = 0;
      int v28 = v27->block_size - 1;
      ctx->final_usechar d = 0;
      ctx->block_masuint64_t k = v28;
      return 1;
    }
    int v14 = 170;
    int v15 = 179;
  }
LABEL_43:
  ERR_put_error(6, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_enc.c", v15);
  return 0;
}

int EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a)
{
  if (a->cipher)
  {
    cleanup = a->cipher->cleanup;
    if (cleanup) {
      ((void (*)(EVP_CIPHER_CTX *))cleanup)(a);
    }
    cipher_unint64_t data = a->cipher_data;
    if (cipher_data) {
      explicit_bzero(cipher_data, a->cipher->ctx_size);
    }
  }
  free(a->cipher_data);
  ENGINE_finish(a->engine);
  explicit_bzero(a, 0xA8uLL);
}

int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr)
{
  if (ctx->cipher)
  {
    ctrl = (uint64_t (*)(void))ctx->cipher->ctrl;
    if (ctrl)
    {
      int result = ctrl();
      if (result != -1) {
        return result;
      }
      int v6 = 133;
      int v7 = 666;
    }
    else
    {
      int v6 = 132;
      int v7 = 660;
    }
  }
  else
  {
    int v6 = 131;
    int v7 = 655;
  }
  ERR_put_error(6, 4095, v6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_enc.c", v7);
  return 0;
}

int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned __int8 *out, int *outl, const unsigned __int8 *in, int inl)
{
  if (ctx->encrypt) {
    return EVP_EncryptUpdate(ctx, out, outl, in, inl);
  }
  else {
    return EVP_DecryptUpdate(ctx, out, outl, in, inl);
  }
}

int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned __int8 *out, int *outl, const unsigned __int8 *in, int inl)
{
  *outl = 0;
  if (inl < 0) {
    return 0;
  }
  unsigned int v5 = inl;
  if (!inl && (EVP_CIPHER_flags(ctx->cipher) & 0xF0007) != 7) {
    return 1;
  }
  cipheBIGNUM r = ctx->cipher;
  if ((ctx->cipher->flags & 0x100000) != 0)
  {
    int v15 = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, const unsigned __int8 *, void))cipher->do_cipher)(ctx, out, in, v5);
    if ((v15 & 0x80000000) == 0)
    {
      *outl = v15;
      return 1;
    }
    return 0;
  }
  buf_leint n = ctx->buf_len;
  if (!buf_len)
  {
    if ((ctx->block_mask & v5) == 0)
    {
      int result = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, const unsigned __int8 *, void))cipher->do_cipher)(ctx, out, in, v5);
      if (result)
      {
        *outl = v5;
        return 1;
      }
      goto LABEL_15;
    }
    block_int size = cipher->block_size;
    if (block_size <= 0x20)
    {
      int v17 = 0;
      goto LABEL_25;
    }
LABEL_14:
    ERR_put_error(6, 4095, 136, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_enc.c", 330);
    int result = 0;
LABEL_15:
    *outl = 0;
    return result;
  }
  block_int size = cipher->block_size;
  if (block_size >= 0x21) {
    goto LABEL_14;
  }
  int v13 = block_size - buf_len;
  unsigned int v14 = v5 - (block_size - buf_len);
  if ((int)v5 < (int)(block_size - buf_len))
  {
    memcpy(&ctx->buf[buf_len], in, v5);
    ctx->buf_len += v5;
    *outl = 0;
    return 1;
  }
  if ((int)(v14 & -block_size) > (int)(block_size ^ 0x7FFFFFFF))
  {
    ERR_put_error(6, 4095, 164, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_enc.c", 350);
    return 0;
  }
  uint64_t v18 = v13;
  memcpy(&ctx->buf[buf_len], in, v13);
  int result = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, unsigned __int8 *, void))ctx->cipher->do_cipher)(ctx, out, ctx->buf, (int)block_size);
  if (!result) {
    return result;
  }
  in += v18;
  out += (int)block_size;
  int v17 = block_size;
  unsigned int v5 = v14;
LABEL_25:
  *outl = v17;
  int v19 = v5 & (block_size - 1);
  uint64_t v20 = v5 - v19;
  if ((int)v20 < 1)
  {
LABEL_28:
    if (v19) {
      memcpy(ctx->buf, &in[(int)v20], v19);
    }
    ctx->buf_leint n = v19;
    return 1;
  }
  int result = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, const unsigned __int8 *, uint64_t))ctx->cipher->do_cipher)(ctx, out, in, v20);
  if (result)
  {
    *outl += v20;
    goto LABEL_28;
  }
  return result;
}

int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned __int8 *out, int *outl, const unsigned __int8 *in, int inl)
{
  *outl = 0;
  if (inl < 0) {
    return 0;
  }
  if (!inl && (EVP_CIPHER_flags(ctx->cipher) & 0xF0007) != 7) {
    return 1;
  }
  cipheBIGNUM r = ctx->cipher;
  if ((ctx->cipher->flags & 0x100000) != 0)
  {
    int v14 = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, const unsigned __int8 *, void))cipher->do_cipher)(ctx, out, in, inl);
    if (v14 < 0)
    {
      int result = 0;
      *outl = 0;
      return result;
    }
    *outl = v14;
    return 1;
  }
  if ((ctx->flags & 0x100) != 0)
  {
    return EVP_EncryptUpdate(ctx, out, outl, in, inl);
  }
  else
  {
    block_int size = cipher->block_size;
    if (block_size >= 0x21)
    {
      int v12 = 136;
      int v13 = 465;
LABEL_18:
      ERR_put_error(6, 4095, v12, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_enc.c", v13);
      return 0;
    }
    final_usechar d = ctx->final_used;
    if (final_used)
    {
      if ((-(int)block_size & inl) > (block_size ^ 0x7FFFFFFF))
      {
        int v12 = 164;
        int v13 = 477;
        goto LABEL_18;
      }
      memcpy(out, ctx->final, block_size);
      out += block_size;
    }
    int result = EVP_EncryptUpdate(ctx, out, outl, in, inl);
    if (result)
    {
      if (block_size < 2 || ctx->buf_len)
      {
        ctx->final_usechar d = 0;
      }
      else
      {
        *outl -= block_size;
        ctx->final_usechar d = 1;
        memcpy(ctx->final, &out[*outl], block_size);
      }
      if (final_used) {
        *outl += block_size;
      }
      return 1;
    }
  }
  return result;
}

int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned __int8 *outm, int *outl)
{
  if (ctx->encrypt) {
    return EVP_EncryptFinal_ex(ctx, outm, outl);
  }
  else {
    return EVP_DecryptFinal_ex(ctx, outm, outl);
  }
}

int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned __int8 *out, int *outl)
{
  cipheBIGNUM r = ctx->cipher;
  if ((ctx->cipher->flags & 0x100000) != 0)
  {
    int v10 = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, void, void))cipher->do_cipher)(ctx, out, 0, 0);
    if (v10 < 0) {
      return 0;
    }
    *outl = v10;
    return 1;
  }
  block_int size = cipher->block_size;
  if (block_size >= 0x21)
  {
    int v8 = 136;
    int v9 = 406;
LABEL_4:
    ERR_put_error(6, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_enc.c", v9);
    return 0;
  }
  if (block_size == 1)
  {
LABEL_9:
    *outl = 0;
    return 1;
  }
  buf_leint n = ctx->buf_len;
  if ((ctx->flags & 0x100) != 0)
  {
    if (buf_len)
    {
      int v8 = 138;
      int v9 = 416;
      goto LABEL_4;
    }
    goto LABEL_9;
  }
  if (block_size > buf_len) {
    memset(&ctx->buf[buf_len], block_size - buf_len, (block_size + ~buf_len) + 1);
  }
  int result = ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, unsigned __int8 *, uint64_t))cipher->do_cipher)(ctx, out, ctx->buf, block_size);
  if (result) {
    *outl = block_size;
  }
  return result;
}

int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned __int8 *outm, int *outl)
{
  *outl = 0;
  cipheBIGNUM r = ctx->cipher;
  if ((ctx->cipher->flags & 0x100000) != 0)
  {
    int v8 = ((uint64_t (*)(void))cipher->do_cipher)();
    if (v8 < 0) {
      return 0;
    }
    *outl = v8;
  }
  else
  {
    if ((ctx->flags & 0x100) == 0)
    {
      block_int size = cipher->block_size;
      if (block_size < 2)
      {
        LODWORD(v10) = 0;
LABEL_13:
        *outl = v10;
        return 1;
      }
      if (!ctx->buf_len && ctx->final_used)
      {
        if (block_size >= 0x21)
        {
          int v6 = 136;
          int v7 = 548;
          goto LABEL_10;
        }
        uint64_t v11 = block_size - 1;
        unsigned int v12 = ctx->final[v11];
        if (ctx->final[v11]) {
          BOOL v13 = block_size >= v12;
        }
        else {
          BOOL v13 = 0;
        }
        if (!v13)
        {
          int v6 = 100;
          int v7 = 553;
          goto LABEL_10;
        }
        int v14 = ctx->final[v11];
        do
        {
          if (ctx->final[v11] != v12)
          {
            int v6 = 100;
            int v7 = 558;
            goto LABEL_10;
          }
          LODWORD(v11) = v11 - 1;
          --v14;
        }
        while (v14);
        uint64_t v10 = block_size - v12;
        if ((int)v10 >= 1)
        {
          final = ctx->final;
          uint64_t v16 = v10;
          do
          {
            unsigned __int8 v17 = *final++;
            *outm++ = v17;
            --v16;
          }
          while (v16);
        }
        goto LABEL_13;
      }
      int v6 = 109;
      int v7 = 544;
LABEL_10:
      ERR_put_error(6, 4095, v6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_enc.c", v7);
      return 0;
    }
    if (ctx->buf_len)
    {
      int v6 = 138;
      int v7 = 536;
      goto LABEL_10;
    }
  }
  return 1;
}

int EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned __int8 *outm, int *outl)
{
  if (ctx->encrypt) {
    return EVP_EncryptFinal_ex(ctx, outm, outl);
  }
  else {
    return EVP_DecryptFinal_ex(ctx, outm, outl);
  }
}

int EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, const unsigned __int8 *key, const unsigned __int8 *iv)
{
  return EVP_CipherInit(ctx, cipher, key, iv, 1);
}

int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl, const unsigned __int8 *key, const unsigned __int8 *iv)
{
  return EVP_CipherInit_ex(ctx, cipher, impl, key, iv, 1);
}

int EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, const unsigned __int8 *key, const unsigned __int8 *iv)
{
  return EVP_CipherInit(ctx, cipher, key, iv, 0);
}

int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher, ENGINE *impl, const unsigned __int8 *key, const unsigned __int8 *iv)
{
  return EVP_CipherInit_ex(ctx, cipher, impl, key, iv, 0);
}

EVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void)
{
  return (EVP_CIPHER_CTX *)malloc_type_calloc(1uLL, 0xA8uLL, 0x10E004046F6AA3FuLL);
}

void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *a)
{
  if (a)
  {
    EVP_CIPHER_CTX_cleanup(a);
    free(a);
  }
}

uint64_t EVP_CIPHER_CTX_reset(EVP_CIPHER_CTX *a1)
{
  return 1;
}

int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen)
{
  flagunsigned int s = x->cipher->flags;
  if ((flags & 0x80) != 0)
  {
    return EVP_CIPHER_CTX_ctrl(x, 1, keylen, 0);
  }
  else
  {
    if (x->key_len == keylen) {
      return 1;
    }
    if (keylen >= 1 && (flags & 8) != 0)
    {
      x->key_leint n = keylen;
      return 1;
    }
    ERR_put_error(6, 4095, 130, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_enc.c", 635);
    return 0;
  }
}

int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *c, int pad)
{
  c->flagunsigned int s = c->flags & 0xFFFFFFFFFFFFFEFFLL | ((unint64_t)(pad == 0) << 8);
  return 1;
}

int EVP_CIPHER_CTX_rand_key(EVP_CIPHER_CTX *ctx, unsigned __int8 *key)
{
  if ((ctx->cipher->flags & 0x200) != 0)
  {
    return EVP_CIPHER_CTX_ctrl(ctx, 6, 0, key);
  }
  else
  {
    arc4random_buf(key, ctx->key_len);
    return 1;
  }
}

uint64_t EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *a, uint64_t *a2)
{
  if (!a2 || !*a2)
  {
    int v17 = 111;
    int v18 = 685;
    goto LABEL_13;
  }
  int v4 = (ENGINE *)a2[1];
  if (v4 && !ENGINE_init(v4))
  {
    int v17 = 38;
    int v18 = 691;
    goto LABEL_13;
  }
  EVP_CIPHER_CTX_cleanup(a);
  long long v6 = *((_OWORD *)a2 + 1);
  long long v5 = *((_OWORD *)a2 + 2);
  *(_OWORD *)&a->cipheBIGNUM r = *(_OWORD *)a2;
  *(_OWORD *)&a->uint64_t encrypt = v6;
  *(_OWORD *)&a->oiv[8] = v5;
  long long v7 = *((_OWORD *)a2 + 6);
  long long v9 = *((_OWORD *)a2 + 3);
  long long v8 = *((_OWORD *)a2 + 4);
  *(_OWORD *)&a->buf[24] = *((_OWORD *)a2 + 5);
  *(_OWORD *)&a->app_unint64_t data = v7;
  *(_OWORD *)&a->iv[8] = v9;
  *(_OWORD *)&a->buf[8] = v8;
  long long v11 = *((_OWORD *)a2 + 8);
  long long v10 = *((_OWORD *)a2 + 9);
  long long v12 = *((_OWORD *)a2 + 7);
  *(void *)&a->final[24] = a2[20];
  *(_OWORD *)&a->final_usechar d = v11;
  *(_OWORD *)&a->final[8] = v10;
  *(_OWORD *)&a->flagunsigned int s = v12;
  uint64_t v13 = *a2;
  if (a2[15])
  {
    size_t v14 = *(int *)(v13 + 48);
    if (v14)
    {
      int v15 = malloc_type_calloc(1uLL, v14, 0xD5E8FBC9uLL);
      a->cipher_unint64_t data = v15;
      if (v15)
      {
        memcpy(v15, (const void *)a2[15], *(int *)(*a2 + 48));
        uint64_t v13 = *a2;
        goto LABEL_9;
      }
      int v17 = 65;
      int v18 = 702;
LABEL_13:
      ERR_put_error(6, 4095, v17, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_enc.c", v18);
      return 0;
    }
  }
LABEL_9:
  if ((*(unsigned char *)(v13 + 17) & 4) == 0
    || (*(unsigned int (**)(uint64_t *, uint64_t, void, EVP_CIPHER_CTX *))(v13 + 72))(a2, 8, 0, a))
  {
    return 1;
  }
  freezero(a->cipher_data, *(int *)(*a2 + 48));
  uint64_t result = 0;
  a->cipher_unint64_t data = 0;
  return result;
}

uint64_t x25519_ge_tobytes(uint64_t a1, int *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  uint64_t v8 = 0;
  memset(v7, 0, sizeof(v7));
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  fe_invert(v9, a2 + 20);
  fe_mul(v7, a2, (int *)v9);
  fe_mul(v5, a2 + 10, (int *)v9);
  fe_tobytes(a1, v5);
  uint64_t result = fe_tobytes((uint64_t)v11, v7);
  *(unsigned char *)(a1 + 31) ^= v11[0] << 7;
  return result;
}

uint64_t fe_invert(_DWORD *a1, int *a2)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  uint64_t v20 = 0;
  memset(v19, 0, sizeof(v19));
  uint64_t v18 = 0;
  memset(v17, 0, sizeof(v17));
  uint64_t v16 = 0;
  memset(v15, 0, sizeof(v15));
  fe_sq(v19, a2);
  fe_sq(v17, (int *)v19);
  fe_sq(v17, (int *)v17);
  fe_mul(v17, a2, (int *)v17);
  fe_mul(v19, (int *)v19, (int *)v17);
  fe_sq(v15, (int *)v19);
  fe_mul(v17, (int *)v17, (int *)v15);
  fe_sq(v15, (int *)v17);
  int v4 = 4;
  do
  {
    fe_sq(v15, (int *)v15);
    --v4;
  }
  while (v4);
  fe_mul(v17, (int *)v15, (int *)v17);
  fe_sq(v15, (int *)v17);
  int v5 = 9;
  do
  {
    fe_sq(v15, (int *)v15);
    --v5;
  }
  while (v5);
  uint64_t v14 = 0;
  memset(v13, 0, sizeof(v13));
  fe_mul(v15, (int *)v15, (int *)v17);
  fe_sq(v13, (int *)v15);
  int v6 = 19;
  do
  {
    fe_sq(v13, (int *)v13);
    --v6;
  }
  while (v6);
  fe_mul(v15, (int *)v13, (int *)v15);
  fe_sq(v15, (int *)v15);
  int v7 = 9;
  do
  {
    fe_sq(v15, (int *)v15);
    --v7;
  }
  while (v7);
  fe_mul(v17, (int *)v15, (int *)v17);
  fe_sq(v15, (int *)v17);
  int v8 = 49;
  do
  {
    fe_sq(v15, (int *)v15);
    --v8;
  }
  while (v8);
  fe_mul(v15, (int *)v15, (int *)v17);
  fe_sq(v13, (int *)v15);
  int v9 = 99;
  do
  {
    fe_sq(v13, (int *)v13);
    --v9;
  }
  while (v9);
  fe_mul(v15, (int *)v13, (int *)v15);
  fe_sq(v15, (int *)v15);
  int v10 = 49;
  do
  {
    fe_sq(v15, (int *)v15);
    --v10;
  }
  while (v10);
  fe_mul(v17, (int *)v15, (int *)v17);
  fe_sq(v17, (int *)v17);
  int v11 = 4;
  do
  {
    fe_sq(v17, (int *)v17);
    --v11;
  }
  while (v11);
  return fe_mul(a1, (int *)v17, (int *)v19);
}

uint64_t fe_mul(_DWORD *a1, int *a2, int *a3)
{
  uint64_t v4 = a2[8];
  uint64_t v5 = a3[1];
  uint64_t v6 = 2 * a2[9];
  uint64_t v7 = a2[9];
  int v9 = a3[2];
  uint64_t v8 = a3[3];
  uint64_t v10 = 19 * v9;
  uint64_t v11 = 19 * (int)v8;
  int v12 = a3[4];
  uint64_t v81 = a3[5];
  uint64_t v13 = 19 * v12;
  uint64_t v14 = 19 * (int)v81;
  uint64_t v16 = a2[2];
  uint64_t v15 = a2[3];
  uint64_t v82 = a2[1];
  uint64_t v17 = a2[4];
  uint64_t v18 = a2[5];
  uint64_t v19 = a2[6];
  uint64_t v20 = a2[7];
  uint64_t v71 = 2 * v15;
  uint64_t v72 = 2 * v18;
  uint64_t v21 = 19 * v5 * v6 + *a3 * (uint64_t)*a2 + v10 * v4 + v11 * 2 * v20;
  uint64_t v22 = *a3 * (uint64_t)(int)v82 + (int)v5 * (uint64_t)*a2 + v10 * v7 + v11 * v4;
  uint64_t v23 = v5 * 2 * v82 + *a3 * (uint64_t)(int)v16 + v9 * (uint64_t)*a2 + v11 * v6;
  uint64_t v24 = v21 + v13 * v19 + v14 * 2 * v18;
  uint64_t v25 = v5 * 2 * v15
      + *a3 * (uint64_t)(int)v17
      + v9 * (uint64_t)(int)v16
      + v8 * 2 * v82
      + v12 * (uint64_t)*a2
      + v14 * 2 * v7;
  uint64_t v79 = v15;
  uint64_t v26 = v22 + v13 * v20 + v14 * v19;
  uint64_t v80 = v23 + v13 * v4 + v14 * 2 * v20;
  uint64_t v27 = *a3 * (uint64_t)(int)v15
      + (int)v5 * (uint64_t)(int)v16
      + v9 * (uint64_t)(int)v82
      + (int)v8 * (uint64_t)*a2
      + v13 * v7
      + v14 * v4;
  LODWORD(v23) = a3[6];
  uint64_t v28 = a3[7];
  uint64_t v29 = 19 * (int)v23;
  uint64_t v30 = v24 + v29 * v17;
  uint64_t v31 = v25 + v29 * v4;
  uint64_t v75 = v18;
  uint64_t v32 = v26 + v29 * v18;
  uint64_t v33 = *a3 * (uint64_t)(int)v18
      + (int)v5 * (uint64_t)(int)v17
      + v9 * (uint64_t)(int)v15
      + (int)v8 * (uint64_t)(int)v16
      + v12 * (uint64_t)(int)v82
      + (int)v81 * (uint64_t)*a2
      + v29 * a2[9];
  uint64_t v34 = a2[9];
  uint64_t v35 = v80 + v29 * v19;
  uint64_t v36 = v27 + v29 * v20;
  uint64_t v37 = 19 * (int)v28;
  uint64_t v74 = v31 + v37 * 2 * v20;
  uint64_t v76 = v32 + v37 * v17;
  uint64_t v77 = v30 + v37 * v71;
  uint64_t v38 = v33 + v37 * v4;
  uint64_t v78 = v35 + v37 * v72;
  uint64_t v39 = v5 * v72
      + *a3 * (uint64_t)(int)v19
      + v9 * (uint64_t)(int)v17
      + v8 * v71
      + v12 * (uint64_t)(int)v16
      + v81 * 2 * v82
      + (int)v23 * (uint64_t)*a2
      + v37 * 2 * v34;
  uint64_t v73 = v36 + v37 * v19;
  LODWORD(v37) = a3[8];
  LODWORD(v80) = a3[9];
  uint64_t v40 = 19 * (int)v37;
  uint64_t v41 = 19 * (int)v80;
  uint64_t v42 = v39 + v40 * v4 + v41 * 2 * v20;
  uint64_t v43 = v5 * 2 * v20 + *a3 * (uint64_t)(int)v4;
  uint64_t v44 = v38 + v40 * v20;
  uint64_t v45 = *a3 * (uint64_t)(int)v34 + (int)v5 * (uint64_t)(int)v4 + v9 * (uint64_t)(int)v20;
  uint64_t v46 = *a3 * (uint64_t)(int)v20 + (int)v5 * (uint64_t)(int)v19 + v9 * (uint64_t)(int)v75;
  uint64_t v47 = v74 + v40 * v19 + v41 * v72;
  uint64_t v48 = v43 + v9 * (uint64_t)(int)v19 + v8 * v72;
  uint64_t v49 = v44 + v41 * v19;
  uint64_t v50 = v45 + (int)v8 * (uint64_t)(int)v19;
  uint64_t v51 = v46
      + (int)v8 * (uint64_t)(int)v17
      + v12 * (uint64_t)(int)v79
      + (int)v81 * (uint64_t)(int)v16
      + (int)v23 * (uint64_t)(int)v82
      + (int)v28 * (uint64_t)*a2
      + v40 * v34;
  uint64_t v52 = v77 + v40 * v16;
  uint64_t v53 = v76 + v40 * v79;
  uint64_t v54 = v50 + v12 * (uint64_t)(int)v75;
  uint64_t v55 = v78 + v40 * v17 + v41 * v71;
  uint64_t v56 = v73 + v40 * v75 + v41 * v17;
  uint64_t v57 = v51 + v41 * v4;
  uint64_t v58 = v52 + v41 * 2 * v82;
  uint64_t v59 = v48
      + v12 * (uint64_t)(int)v17
      + v81 * v71
      + (int)v23 * (uint64_t)(int)v16
      + v28 * 2 * v82
      + (int)v37 * (uint64_t)*a2
      + v41 * 2 * v34;
  uint64_t result = 0x2000000;
  uint64_t v61 = v53 + v41 * v16 + ((v58 + 0x2000000) >> 26);
  uint64_t v62 = v49 + ((v47 + 0x2000000) >> 26);
  uint64_t v63 = v55 + ((v61 + 0x1000000) >> 25);
  uint64_t v64 = v42 + ((v62 + 0x1000000) >> 25);
  uint64_t v65 = v56 + ((v63 + 0x2000000) >> 26);
  uint64_t v66 = v57 + ((v64 + 0x2000000) >> 26);
  uint64_t v67 = v59 + ((v66 + 0x1000000) >> 25);
  uint64_t v68 = v54
      + (int)v81 * (uint64_t)(int)v17
      + (int)v23 * (uint64_t)(int)v79
      + (int)v28 * (uint64_t)(int)v16
      + (int)v37 * (uint64_t)(int)v82
      + (int)v80 * (uint64_t)*a2
      + ((v67 + 0x2000000) >> 26);
  unint64_t v69 = v58 - ((v58 + 0x2000000) & 0xFFFFFFFFFC000000) + 19 * ((v68 + 0x1000000) >> 25);
  *a1 = v69 - ((v69 + 0x2000000) & 0xFC000000);
  a1[1] = v61 - ((v61 + 0x1000000) & 0xFE000000) + ((v69 + 0x2000000) >> 26);
  unint64_t v70 = v47 - ((v47 + 0x2000000) & 0xFFFFFFFFFC000000) + ((v65 + 0x1000000) >> 25);
  a1[2] = v63 - ((v63 + 0x2000000) & 0xFC000000);
  a1[3] = v65 - ((v65 + 0x1000000) & 0xFE000000);
  a1[4] = v70 - ((v70 + 0x2000000) & 0xFC000000);
  a1[5] = v62 - ((v62 + 0x1000000) & 0xFE000000) + ((v70 + 0x2000000) >> 26);
  a1[6] = v64 - ((v64 + 0x2000000) & 0xFC000000);
  a1[7] = v66 - ((v66 + 0x1000000) & 0xFE000000);
  a1[8] = v67 - ((v67 + 0x2000000) & 0xFC000000);
  a1[9] = v68 - ((v68 + 0x1000000) & 0xFE000000);
  return result;
}

uint64_t fe_tobytes(uint64_t result, _DWORD *a2)
{
  int v2 = a2[1];
  int v3 = a2[2];
  int v4 = a2[3];
  int v5 = a2[4];
  int v6 = a2[5];
  int v7 = a2[6];
  int v8 = a2[7];
  int v9 = a2[8];
  int v10 = a2[9];
  int v11 = *a2
      + 19
      * ((v10
        + ((v9
          + ((v8
            + ((v7
              + ((v6
                + ((v5 + ((v4 + ((v3 + ((v2 + ((*a2 + ((19 * v10 + 0x1000000) >> 25)) >> 26)) >> 25)) >> 26)) >> 25)) >> 26)) >> 25)) >> 26)) >> 25)) >> 26)) >> 25);
  unsigned int v12 = v2 + (v11 >> 26);
  unsigned int v13 = v3 + ((int)v12 >> 25);
  unsigned int v14 = v4 + ((int)v13 >> 26);
  unsigned int v15 = v5 + ((int)v14 >> 25);
  int v16 = v6 + ((int)v15 >> 26);
  unsigned int v17 = v7 + (v16 >> 25);
  unsigned int v18 = v8 + ((int)v17 >> 26);
  unsigned int v19 = v9 + ((int)v18 >> 25);
  unsigned int v20 = v10 + ((int)v19 >> 26);
  *(_WORD *)uint64_t result = v11;
  *(unsigned char *)(result + 2) = BYTE2(v11);
  *(unsigned char *)(result + 3) = HIBYTE(v11) & 3 | (4 * v12);
  *(unsigned char *)(result + 4) = v12 >> 6;
  *(unsigned char *)(result + 5) = v12 >> 14;
  *(unsigned char *)(result + 6) = (v12 >> 22) & 7 | (8 * v13);
  *(unsigned char *)(result + 7) = v13 >> 5;
  *(unsigned char *)(result + 8) = v13 >> 13;
  *(unsigned char *)(result + 9) = (v13 >> 21) & 0x1F | (32 * v14);
  *(unsigned char *)(result + 10) = v14 >> 3;
  *(unsigned char *)(result + 11) = v14 >> 11;
  *(unsigned char *)(result + 12) = (v14 >> 19) & 0x3F | ((_BYTE)v15 << 6);
  *(unsigned char *)(result + 13) = v15 >> 2;
  *(unsigned char *)(result + 14) = v15 >> 10;
  *(unsigned char *)(result + 15) = v15 >> 18;
  *(_WORD *)(result + 16) = v16;
  *(unsigned char *)(result + 18) = BYTE2(v16);
  *(unsigned char *)(result + 19) = HIBYTE(v16) & 1 | (2 * v17);
  *(unsigned char *)(result + 20) = v17 >> 7;
  *(unsigned char *)(result + 21) = v17 >> 15;
  *(unsigned char *)(result + 22) = (v17 >> 23) & 7 | (8 * v18);
  *(unsigned char *)(result + 23) = v18 >> 5;
  *(unsigned char *)(result + 24) = v18 >> 13;
  *(unsigned char *)(result + 25) = (v18 >> 21) & 0xF | (16 * v19);
  *(unsigned char *)(result + 26) = v19 >> 4;
  *(unsigned char *)(result + 27) = v19 >> 12;
  *(unsigned char *)(result + 28) = (v19 >> 20) & 0x3F | ((_BYTE)v20 << 6);
  *(unsigned char *)(result + 29) = v20 >> 2;
  *(unsigned char *)(result + 30) = v20 >> 10;
  *(unsigned char *)(result + 31) = (v20 >> 18) & 0x7F;
  return result;
}

uint64_t x25519_ge_frombytes_vartime(uint64_t a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  uint64_t v27 = 0;
  memset(v26, 0, sizeof(v26));
  uint64_t v25 = 0;
  memset(v24, 0, sizeof(v24));
  int v4 = (int *)(a1 + 40);
  fe_frombytes((_DWORD *)(a1 + 40), (unsigned int *)a2);
  *(void *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_DWORD *)(a1 + 80) = 1;
  fe_sq(v26, v4);
  fe_mul(v24, (int *)v26, d);
  for (uint64_t i = 0; i != 40; i += 4)
    *(_DWORD *)((char *)v26 + i) -= *(_DWORD *)(a1 + i + 80);
  for (uint64_t j = 0; j != 40; j += 4)
    *(_DWORD *)((char *)v24 + j) += *(_DWORD *)(a1 + j + 80);
  uint64_t v23 = 0;
  memset(v22, 0, sizeof(v22));
  fe_sq(v22, (int *)v24);
  fe_mul(v22, (int *)v22, (int *)v24);
  fe_sq((_DWORD *)a1, (int *)v22);
  fe_mul((_DWORD *)a1, (int *)a1, (int *)v24);
  fe_mul((_DWORD *)a1, (int *)a1, (int *)v26);
  uint64_t v33 = 0;
  memset(v32, 0, sizeof(v32));
  uint64_t v31 = 0;
  memset(v30, 0, sizeof(v30));
  fe_sq(v32, (int *)a1);
  fe_sq(v30, (int *)v32);
  fe_sq(v30, (int *)v30);
  fe_mul(v30, (int *)a1, (int *)v30);
  fe_mul(v32, (int *)v32, (int *)v30);
  fe_sq(v32, (int *)v32);
  fe_mul(v32, (int *)v30, (int *)v32);
  fe_sq(v30, (int *)v32);
  int v7 = 4;
  do
  {
    fe_sq(v30, (int *)v30);
    --v7;
  }
  while (v7);
  fe_mul(v32, (int *)v30, (int *)v32);
  fe_sq(v30, (int *)v32);
  int v8 = 9;
  do
  {
    fe_sq(v30, (int *)v30);
    --v8;
  }
  while (v8);
  uint64_t v29 = 0;
  memset(v28, 0, sizeof(v28));
  fe_mul(v30, (int *)v30, (int *)v32);
  fe_sq(v28, (int *)v30);
  int v9 = 19;
  do
  {
    fe_sq(v28, (int *)v28);
    --v9;
  }
  while (v9);
  fe_mul(v30, (int *)v28, (int *)v30);
  fe_sq(v30, (int *)v30);
  int v10 = 9;
  do
  {
    fe_sq(v30, (int *)v30);
    --v10;
  }
  while (v10);
  fe_mul(v32, (int *)v30, (int *)v32);
  fe_sq(v30, (int *)v32);
  int v11 = 49;
  do
  {
    fe_sq(v30, (int *)v30);
    --v11;
  }
  while (v11);
  fe_mul(v30, (int *)v30, (int *)v32);
  fe_sq(v28, (int *)v30);
  int v12 = 99;
  do
  {
    fe_sq(v28, (int *)v28);
    --v12;
  }
  while (v12);
  fe_mul(v30, (int *)v28, (int *)v30);
  fe_sq(v30, (int *)v30);
  int v13 = 49;
  do
  {
    fe_sq(v30, (int *)v30);
    --v13;
  }
  while (v13);
  uint64_t v21 = 0;
  memset(v20, 0, sizeof(v20));
  memset(v18, 0, sizeof(v18));
  uint64_t v19 = 0;
  fe_mul(v32, (int *)v30, (int *)v32);
  fe_sq(v32, (int *)v32);
  fe_sq(v32, (int *)v32);
  fe_mul((_DWORD *)a1, (int *)v32, (int *)a1);
  fe_mul((_DWORD *)a1, (int *)a1, (int *)v22);
  fe_mul((_DWORD *)a1, (int *)a1, (int *)v26);
  fe_sq(v20, (int *)a1);
  fe_mul(v20, (int *)v20, (int *)v24);
  for (uint64_t k = 0; k != 40; k += 4)
    *(_DWORD *)((char *)v18 + k) = *(_DWORD *)((char *)v20 + k) - *(_DWORD *)((char *)v26 + k);
  fe_tobytes((uint64_t)v32, v18);
  if (timingsafe_memcmp((unsigned __int8 *)v32, fe_isnonzero_zero, 32))
  {
    for (uint64_t m = 0; m != 40; m += 4)
      *(_DWORD *)((char *)v18 + m) = *(_DWORD *)((char *)v26 + m) + *(_DWORD *)((char *)v20 + m);
    fe_tobytes((uint64_t)v32, v18);
    if (timingsafe_memcmp((unsigned __int8 *)v32, fe_isnonzero_zero, 32)) {
      return 0xFFFFFFFFLL;
    }
    fe_mul((_DWORD *)a1, (int *)a1, sqrtm1);
  }
  fe_tobytes((uint64_t)v32, (_DWORD *)a1);
  if ((v32[0] & 1) != *(unsigned __int8 *)(a2 + 31) >> 7)
  {
    for (uint64_t n = 0; n != 40; n += 4)
      *(_DWORD *)(a1 + n) = -*(_DWORD *)(a1 + n);
  }
  fe_mul((_DWORD *)(a1 + 120), (int *)a1, v4);
  return 0;
}

_DWORD *fe_frombytes(_DWORD *result, unsigned int *a2)
{
  unint64_t v2 = ((unint64_t)*((unsigned __int8 *)a2 + 4) << 6) | ((unint64_t)*((unsigned __int8 *)a2 + 5) << 14) | ((unint64_t)*((unsigned __int8 *)a2 + 6) << 22);
  unint64_t v3 = (8 * *((unsigned __int8 *)a2 + 10)) | ((unint64_t)*((unsigned __int8 *)a2 + 11) << 11) | ((unint64_t)*((unsigned __int8 *)a2 + 12) << 19);
  uint64_t v4 = a2[4];
  unint64_t v5 = ((4 * *((unsigned __int8 *)a2 + 29)) | ((unint64_t)*((unsigned __int8 *)a2 + 30) << 10)) & 0xFFFFFFFFFE03FFFFLL | ((unint64_t)(*((unsigned char *)a2 + 31) & 0x7F) << 18);
  uint64_t v6 = *a2 + 19 * ((v5 + 0x1000000) >> 25);
  unint64_t v7 = ((32 * *((unsigned __int8 *)a2 + 7)) | ((unint64_t)*((unsigned __int8 *)a2 + 8) << 13) | ((unint64_t)*((unsigned __int8 *)a2 + 9) << 21))
     + ((v2 + 0x1000000) >> 25);
  int v8 = ((v7 + 0x2000000) >> 26) + v3;
  v3 += 0x1000000;
  unint64_t v9 = ((4 * *((unsigned __int8 *)a2 + 13)) | ((unint64_t)*((unsigned __int8 *)a2 + 14) << 10) | ((unint64_t)*((unsigned __int8 *)a2 + 15) << 18))
     + (v3 >> 25);
  LODWORD(v3) = v8 - (v3 & 0xE000000);
  unint64_t v10 = (32 * *((unsigned __int8 *)a2 + 23)) | ((unint64_t)*((unsigned __int8 *)a2 + 24) << 13) | ((unint64_t)*((unsigned __int8 *)a2 + 25) << 21);
  uint64_t v11 = *((unsigned __int8 *)a2 + 26);
  unint64_t v12 = (((unint64_t)*((unsigned __int8 *)a2 + 20) << 7) | ((unint64_t)*((unsigned __int8 *)a2 + 21) << 15) | ((unint64_t)*((unsigned __int8 *)a2 + 22) << 23))
      + ((unint64_t)(v4 + 0x1000000) >> 25);
  uint64_t v13 = *((unsigned __int8 *)a2 + 27);
  uint64_t v14 = *((unsigned __int8 *)a2 + 28);
  *uint64_t result = v6 - ((v6 + 0x2000000) & 0xFC000000);
  result[1] = v2 - ((v2 + 0x1000000) & 0x7E000000) + ((unint64_t)(v6 + 0x2000000) >> 26);
  unint64_t v15 = ((16 * v11) | (v13 << 12) | (v14 << 20)) + ((v10 + 0x1000000) >> 25);
  result[2] = v7 - ((v7 + 0x2000000) & 0xFC000000);
  result[3] = v3;
  result[4] = v9 - ((v9 + 0x2000000) & 0xFC000000);
  result[5] = v4 - ((v4 + 0x1000000) & 0xFE000000) + ((v9 + 0x2000000) >> 26);
  result[6] = v12 - ((v12 + 0x2000000) & 0xFC000000);
  result[7] = ((v12 + 0x2000000) >> 26) + v10 - ((v10 + 0x1000000) & 0x3E000000);
  result[8] = v15 - ((v15 + 0x2000000) & 0xFC000000);
  result[9] = v5 + ((v15 + 0x2000000) >> 26) - ((v5 + 0x1000000) & 0x2000000);
  return result;
}

_DWORD *fe_sq(_DWORD *result, int *a2)
{
  uint64_t v3 = a2[4];
  uint64_t v2 = a2[5];
  uint64_t v5 = a2[6];
  uint64_t v4 = a2[7];
  uint64_t v6 = 19 * (int)v5;
  uint64_t v7 = *a2;
  uint64_t v8 = a2[1];
  uint64_t v9 = 38 * (int)v4;
  uint64_t v11 = a2[8];
  uint64_t v10 = a2[9];
  uint64_t v12 = 19 * (int)v11;
  uint64_t v13 = a2[2];
  uint64_t v14 = a2[3];
  uint64_t v15 = 2 * v7;
  uint64_t v16 = 2 * v13;
  uint64_t v17 = 2 * v14;
  uint64_t v18 = 38 * (int)v10;
  uint64_t v19 = 2 * v7 * v8;
  uint64_t v20 = 2 * v8 * v13;
  uint64_t v21 = 38 * (int)v2 * (uint64_t)(int)v2
      + (int)v7 * (uint64_t)(int)v7
      + v6 * 2 * v3
      + v9 * 2 * v14
      + v12 * 2 * v13
      + v18 * 2 * v8;
  uint64_t v22 = 2 * v8 * v8 + v13 * 2 * v7;
  uint64_t v23 = 2 * v14 * 2 * v8 + (int)v13 * (uint64_t)(int)v13 + v3 * 2 * v7 + v9 * v4 + 2 * v5 * v12 + v18 * 2 * v2;
  uint64_t v24 = v19 + v6 * 2 * v2 + v9 * v3 + v12 * 2 * v14 + v18 * v13 + ((v21 + 0x2000000) >> 26);
  uint64_t v25 = 2 * v13 * v14 + v3 * 2 * v8 + v2 * v15 + v12 * 2 * v4 + v18 * v5 + ((v23 + 0x2000000) >> 26);
  uint64_t v26 = v22 + v6 * v5 + v9 * 2 * v2 + v12 * 2 * v3 + v18 * 2 * v14 + ((v24 + 0x1000000) >> 25);
  uint64_t v27 = v20 + v14 * v15;
  uint64_t v28 = v3 * v16 + 2 * v14 * v14 + 2 * v2 * 2 * v8 + v5 * v15 + v12 * v11 + v18 * 2 * v4 + ((v25 + 0x1000000) >> 25);
  uint64_t v29 = v27 + v9 * v5 + v12 * 2 * v2 + v18 * v3 + ((v26 + 0x2000000) >> 26);
  LODWORD(v12) = v26 - ((v26 + 0x2000000) & 0xFC000000);
  uint64_t v30 = 2 * v3 * v2;
  uint64_t v31 = v17 * v3 + v2 * v16;
  uint64_t v32 = v5 * v16 + (int)v3 * (uint64_t)(int)v3 + 2 * v2 * v17;
  uint64_t v33 = v31 + v5 * 2 * v8 + v4 * v15 + v18 * v11 + ((v28 + 0x2000000) >> 26);
  uint64_t v34 = v30 + v5 * v17 + v4 * v16 + v11 * 2 * v8;
  uint64_t v35 = v32 + 2 * v4 * 2 * v8 + v11 * v15 + v18 * v10 + ((v33 + 0x1000000) >> 25);
  uint64_t v36 = v34 + v10 * v15 + ((v35 + 0x2000000) >> 26);
  unint64_t v37 = v21 - ((v21 + 0x2000000) & 0xFFFFFFFFFC000000) + 19 * ((v36 + 0x1000000) >> 25);
  *uint64_t result = v37 - ((v37 + 0x2000000) & 0xFC000000);
  result[1] = v24 - ((v24 + 0x1000000) & 0xFE000000) + ((v37 + 0x2000000) >> 26);
  unint64_t v38 = v23 - ((v23 + 0x2000000) & 0xFFFFFFFFFC000000) + ((v29 + 0x1000000) >> 25);
  result[2] = v12;
  result[3] = v29 - ((v29 + 0x1000000) & 0xFE000000);
  result[4] = v38 - ((v38 + 0x2000000) & 0xFC000000);
  result[5] = v25 - ((v25 + 0x1000000) & 0xFE000000) + ((v38 + 0x2000000) >> 26);
  result[6] = v28 - ((v28 + 0x2000000) & 0xFC000000);
  result[7] = v33 - ((v33 + 0x1000000) & 0xFE000000);
  result[8] = v35 - ((v35 + 0x2000000) & 0xFC000000);
  result[9] = v36 - ((v36 + 0x1000000) & 0xFE000000);
  return result;
}

uint64_t x25519_ge_p3_to_cached(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = 0; i != 40; i += 4)
    *(_DWORD *)(a1 + i) = *(_DWORD *)(a2 + i) + *(_DWORD *)(a2 + i + 40);
  for (uint64_t j = 0; j != 40; j += 4)
    *(_DWORD *)(a1 + 40 + j) = *(_DWORD *)(a2 + j + 40) - *(_DWORD *)(a2 + j);
  long long v4 = *(_OWORD *)(a2 + 80);
  long long v5 = *(_OWORD *)(a2 + 96);
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(_OWORD *)(a1 + 80) = v4;
  *(_OWORD *)(a1 + 96) = v5;
  return fe_mul((_DWORD *)(a1 + 120), (int *)(a2 + 120), d2);
}

uint64_t x25519_ge_p1p1_to_p2(_DWORD *a1, int *a2)
{
  long long v4 = a2 + 30;
  fe_mul(a1, a2, a2 + 30);
  long long v5 = a2 + 10;
  uint64_t v6 = a2 + 20;
  fe_mul(a1 + 10, v5, v6);
  return fe_mul(a1 + 20, v6, v4);
}

uint64_t x25519_ge_p1p1_to_p3(_DWORD *a1, int *a2)
{
  long long v4 = a2 + 30;
  fe_mul(a1, a2, a2 + 30);
  fe_mul(a1 + 10, a2 + 10, a2 + 20);
  fe_mul(a1 + 20, a2 + 20, v4);
  return fe_mul(a1 + 30, a2, a2 + 10);
}

uint64_t x25519_ge_add(int *a1, uint64_t a2, int *a3)
{
  uint64_t v6 = 0;
  uint64_t v16 = *MEMORY[0x263EF8340];
  do
  {
    a1[v6] = *(_DWORD *)(a2 + v6 * 4) + *(_DWORD *)(a2 + v6 * 4 + 40);
    ++v6;
  }
  while (v6 != 10);
  for (uint64_t i = 0; i != 10; ++i)
    a1[i + 10] = *(_DWORD *)(a2 + i * 4 + 40) - *(_DWORD *)(a2 + i * 4);
  uint64_t v15 = 0;
  memset(v14, 0, sizeof(v14));
  fe_mul(a1 + 20, a1, a3);
  fe_mul(a1 + 10, a1 + 10, a3 + 10);
  fe_mul(a1 + 30, a3 + 30, (int *)(a2 + 120));
  uint64_t result = fe_mul(a1, (int *)(a2 + 80), a3 + 20);
  for (uint64_t j = 0; j != 10; ++j)
    *(_DWORD *)((char *)v14 + j * 4) = 2 * a1[j];
  for (uint64_t k = 0; k != 10; ++k)
    a1[k] = a1[k + 20] - a1[k + 10];
  for (uint64_t m = 0; m != 10; ++m)
    a1[m + 10] += a1[m + 20];
  for (uint64_t n = 0; n != 10; ++n)
    a1[n + 20] = a1[n + 30] + *(_DWORD *)((char *)v14 + n * 4);
  for (iuint64_t i = 0; ii != 10; ++ii)
    a1[ii + 30] = *(_DWORD *)((char *)v14 + ii * 4) - a1[ii + 30];
  return result;
}

uint64_t x25519_ge_sub(int *a1, uint64_t a2, int *a3)
{
  uint64_t v6 = 0;
  uint64_t v16 = *MEMORY[0x263EF8340];
  do
  {
    a1[v6] = *(_DWORD *)(a2 + v6 * 4) + *(_DWORD *)(a2 + v6 * 4 + 40);
    ++v6;
  }
  while (v6 != 10);
  for (uint64_t i = 0; i != 10; ++i)
    a1[i + 10] = *(_DWORD *)(a2 + i * 4 + 40) - *(_DWORD *)(a2 + i * 4);
  uint64_t v15 = 0;
  memset(v14, 0, sizeof(v14));
  fe_mul(a1 + 20, a1, a3 + 10);
  fe_mul(a1 + 10, a1 + 10, a3);
  fe_mul(a1 + 30, a3 + 30, (int *)(a2 + 120));
  uint64_t result = fe_mul(a1, (int *)(a2 + 80), a3 + 20);
  for (uint64_t j = 0; j != 10; ++j)
    *(_DWORD *)((char *)v14 + j * 4) = 2 * a1[j];
  for (uint64_t k = 0; k != 10; ++k)
    a1[k] = a1[k + 20] - a1[k + 10];
  for (uint64_t m = 0; m != 10; ++m)
    a1[m + 10] += a1[m + 20];
  for (uint64_t n = 0; n != 10; ++n)
    a1[n + 20] = *(_DWORD *)((char *)v14 + n * 4) - a1[n + 30];
  for (iuint64_t i = 0; ii != 10; ++ii)
    a1[ii + 30] += *(_DWORD *)((char *)v14 + ii * 4);
  return result;
}

uint64_t x25519_ge_scalarmult_small_precomp(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = 0;
  v40[225] = *MEMORY[0x263EF8340];
  uint64_t v6 = v40;
  do
  {
    *(void *)&long long v32 = 0;
    long long v30 = 0u;
    long long v31 = 0u;
    *(void *)&long long v22 = 0;
    long long v20 = 0u;
    long long v21 = 0u;
    fe_frombytes(&v30, (unsigned int *)(a3 + (v5 << 6)));
    fe_frombytes(&v20, (unsigned int *)(a3 + (v5 << 6) + 32));
    for (uint64_t i = 0; i != 40; i += 4)
      *(_DWORD *)((char *)v6 + i) = *(_DWORD *)((char *)&v30 + i) + *(_DWORD *)((char *)&v20 + i);
    for (uint64_t j = 0; j != 40; j += 4)
      *(_DWORD *)((char *)v6 + j + 40) = *(_DWORD *)((char *)&v20 + j) - *(_DWORD *)((char *)&v30 + j);
    fe_mul(&v40[15 * v5 + 10], (int *)&v30, (int *)&v20);
    fe_mul(&v40[15 * v5 + 10], (int *)&v40[15 * v5 + 10], d2);
    ++v5;
    v6 += 15;
  }
  while (v5 != 15);
  ge_p3_0((uint64_t)a1);
  unint64_t v9 = 63;
  do
  {
    uint64_t v10 = 0;
    int v11 = 0;
    uint64_t v12 = (unsigned __int8 *)(a2 + (v9 >> 3));
    do
    {
      unsigned int v13 = *v12;
      v12 += 8;
      v11 |= ((v13 >> (v9 & 7)) & 1) << v10++;
    }
    while (v10 != 4);
    uint64_t v19 = 0;
    memset(v18, 0, sizeof(v18));
    ge_precomp_0((uint64_t)v18);
    uint64_t v14 = v40;
    for (uint64_t k = 1; k != 16; ++k)
    {
      cmov((uint64_t)v18, (uint64_t)v14, ((v11 ^ k) - 1) >> 31);
      v14 += 15;
    }
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    x25519_ge_p3_to_cached((uint64_t)&v30, (uint64_t)a1);
    x25519_ge_add((int *)&v20, (uint64_t)a1, (int *)&v30);
    x25519_ge_p1p1_to_p3(a1, (int *)&v20);
    ge_madd((int *)&v20, (uint64_t)a1, (int *)v18);
    uint64_t result = x25519_ge_p1p1_to_p3(a1, (int *)&v20);
    --v9;
  }
  while (v9 < 0x40);
  return result;
}

double ge_p3_0(uint64_t a1)
{
  *(void *)(a1 + 32) = 0;
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 40) = 1;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(void *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 80) = 1;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(void *)(a1 + 152) = 0;
  return result;
}

double ge_precomp_0(uint64_t a1)
{
  *(void *)(a1 + 32) = 0;
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)a1 = 1;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 40) = 1;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(void *)(a1 + 112) = 0;
  return result;
}

uint64_t cmov(uint64_t result, uint64_t a2, int a3)
{
  for (uint64_t i = 0; i != 40; i += 4)
    *(_DWORD *)(result + i) = *(_DWORD *)(a2 + i) & -a3 | *(_DWORD *)(result + i) & (a3 - 1);
  for (uint64_t j = 0; j != 40; j += 4)
    *(_DWORD *)(result + 40 + j) = *(_DWORD *)(a2 + 40 + j) & -a3 | *(_DWORD *)(result + 40 + j) & (a3 - 1);
  for (uint64_t k = 0; k != 40; k += 4)
    *(_DWORD *)(result + 80 + k) = *(_DWORD *)(a2 + 80 + k) & -a3 | *(_DWORD *)(result + 80 + k) & (a3 - 1);
  return result;
}

uint64_t ge_madd(int *a1, uint64_t a2, int *a3)
{
  uint64_t v6 = 0;
  uint64_t v16 = *MEMORY[0x263EF8340];
  do
  {
    a1[v6] = *(_DWORD *)(a2 + v6 * 4) + *(_DWORD *)(a2 + v6 * 4 + 40);
    ++v6;
  }
  while (v6 != 10);
  for (uint64_t i = 0; i != 10; ++i)
    a1[i + 10] = *(_DWORD *)(a2 + i * 4 + 40) - *(_DWORD *)(a2 + i * 4);
  uint64_t v15 = 0;
  memset(v14, 0, sizeof(v14));
  fe_mul(a1 + 20, a1, a3);
  fe_mul(a1 + 10, a1 + 10, a3 + 10);
  uint64_t result = fe_mul(a1 + 30, a3 + 20, (int *)(a2 + 120));
  for (uint64_t j = 0; j != 40; j += 4)
    *(_DWORD *)((char *)v14 + j) = 2 * *(_DWORD *)(a2 + 80 + j);
  for (uint64_t k = 0; k != 10; ++k)
    a1[k] = a1[k + 20] - a1[k + 10];
  for (uint64_t m = 0; m != 10; ++m)
    a1[m + 10] += a1[m + 20];
  for (uint64_t n = 0; n != 10; ++n)
    a1[n + 20] = a1[n + 30] + *(_DWORD *)((char *)v14 + n * 4);
  for (iuint64_t i = 0; ii != 10; ++ii)
    a1[ii + 30] = *(_DWORD *)((char *)v14 + ii * 4) - a1[ii + 30];
  return result;
}

uint64_t x25519_ge_scalarmult_base(long long *a1, int8x16_t *a2)
{
  uint64_t v3 = 0;
  uint64_t v25 = *MEMORY[0x263EF8340];
  v4.i64[0] = 0xF0F0F0F0F0F0F0FLL;
  v4.i64[1] = 0xF0F0F0F0F0F0F0FLL;
  do
  {
    int8x16_t v5 = *a2++;
    v26.val[0] = vandq_s8(v5, v4);
    v26.val[1] = (int8x16_t)vshrq_n_u8((uint8x16_t)v5, 4uLL);
    uint64_t v6 = &v23[v3];
    vst2q_s8(v6, v26);
    v3 += 32;
  }
  while (v3 != 64);
  uint64_t v7 = 0;
  int v8 = 0;
  do
  {
    int v9 = v23[v7] + v8;
    int v8 = (v9 + 8) << 24 >> 28;
    v23[v7++] = v9 - ((v9 + 8) & 0xF0);
  }
  while (v7 != 63);
  memset(v20, 0, sizeof(v20));
  memset(v16, 0, sizeof(v16));
  uint64_t v17 = 0;
  v24 += v8;
  ge_p3_0((uint64_t)a1);
  int v10 = 0;
  unint64_t v11 = 1;
  do
  {
    table_select((uint64_t)v16, v10, (char)v23[v11]);
    ge_madd((int *)v20, (uint64_t)a1, (int *)v16);
    x25519_ge_p1p1_to_p3(a1, (int *)v20);
    ++v10;
    BOOL v12 = v11 >= 0x3E;
    v11 += 2;
  }
  while (!v12);
  uint64_t v19 = 0;
  memset(v18, 0, sizeof(v18));
  uint64_t v22 = 0;
  memset(v21, 0, sizeof(v21));
  ge_p3_to_p2((uint64_t)v21, a1);
  ge_p2_dbl(v20, (int *)v21);
  x25519_ge_p1p1_to_p2(v18, (int *)v20);
  ge_p2_dbl(v20, (int *)v18);
  x25519_ge_p1p1_to_p2(v18, (int *)v20);
  ge_p2_dbl(v20, (int *)v18);
  x25519_ge_p1p1_to_p2(v18, (int *)v20);
  ge_p2_dbl(v20, (int *)v18);
  x25519_ge_p1p1_to_p3(a1, (int *)v20);
  int v13 = 0;
  unint64_t v14 = 0;
  do
  {
    table_select((uint64_t)v16, v13, (char)v23[v14]);
    ge_madd((int *)v20, (uint64_t)a1, (int *)v16);
    uint64_t result = x25519_ge_p1p1_to_p3(a1, (int *)v20);
    ++v13;
    BOOL v12 = v14 >= 0x3E;
    v14 += 2;
  }
  while (!v12);
  return result;
}

uint64_t table_select(uint64_t a1, int a2, int a3)
{
  int v6 = a3 - 2 * (a3 & (a3 >> 31));
  ge_precomp_0(a1);
  uint64_t v7 = (char *)&k25519Precomp + 960 * a2;
  cmov(a1, (uint64_t)v7, ((v6 ^ 1u) - 1) >> 31);
  cmov(a1, (uint64_t)(v7 + 120), ((v6 ^ 2u) - 1) >> 31);
  cmov(a1, (uint64_t)(v7 + 240), ((v6 ^ 3u) - 1) >> 31);
  cmov(a1, (uint64_t)(v7 + 360), ((v6 ^ 4u) - 1) >> 31);
  cmov(a1, (uint64_t)(v7 + 480), ((v6 ^ 5u) - 1) >> 31);
  cmov(a1, (uint64_t)(v7 + 600), ((v6 ^ 6u) - 1) >> 31);
  cmov(a1, (uint64_t)(v7 + 720), ((v6 ^ 7u) - 1) >> 31);
  cmov(a1, (uint64_t)(v7 + 840), ((v6 ^ 8u) - 1) >> 31);
  long long v8 = *(_OWORD *)(a1 + 56);
  v12[0] = *(_OWORD *)(a1 + 40);
  v12[1] = v8;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v9 = *(_OWORD *)(a1 + 16);
  long long v14 = *(_OWORD *)a1;
  uint64_t v13 = *(void *)(a1 + 72);
  uint64_t v19 = 0;
  uint64_t v16 = *(void *)(a1 + 32);
  uint64_t v10 = 80;
  long long v15 = v9;
  do
  {
    *(_DWORD *)((char *)v12 + v10) = -*(_DWORD *)(a1 + v10);
    v10 += 4;
  }
  while (v10 != 120);
  return cmov(a1, (uint64_t)v12, (a3 >> 7) & 1);
}

_DWORD *ge_p2_dbl(_DWORD *a1, int *a2)
{
  uint64_t v77 = *MEMORY[0x263EF8340];
  fe_sq(a1, a2);
  fe_sq(a1 + 20, a2 + 10);
  uint64_t v4 = 0;
  uint64_t v5 = a2[20];
  uint64_t v6 = a2[21];
  uint64_t v7 = a2[24];
  uint64_t v8 = a2[25];
  uint64_t v10 = a2[26];
  uint64_t v9 = a2[27];
  uint64_t v11 = 19 * (int)v10;
  uint64_t v12 = a2[22];
  uint64_t v13 = a2[23];
  uint64_t v15 = a2[28];
  uint64_t v14 = a2[29];
  uint64_t v16 = 2 * v5;
  uint64_t v17 = 2 * v6;
  uint64_t v18 = 2 * v12;
  uint64_t v19 = 38 * (int)v9;
  uint64_t v20 = 2 * v13;
  uint64_t v21 = 2 * v8;
  uint64_t v22 = 19 * (int)v15;
  uint64_t v23 = 38 * (int)v14;
  uint64_t v24 = 2 * v5 * v6;
  uint64_t v25 = 38 * (int)v8 * (uint64_t)(int)v8 + (int)v5 * (uint64_t)(int)v5 + v11 * 2 * v7;
  uint64_t v26 = 2 * v6 * v6 + v12 * v16 + v11 * v10;
  uint64_t v27 = v24 + v11 * 2 * v8 + v19 * v7 + v22 * 2 * v13 + v23 * v12;
  uint64_t v28 = 2 * v13 * v17 + (int)v12 * (uint64_t)(int)v12;
  uint64_t v29 = v25 + v19 * 2 * v13;
  uint64_t v30 = v26 + v19 * 2 * v8;
  uint64_t v31 = v17 * v12 + v13 * v16 + v19 * v10;
  uint64_t v32 = v28 + v7 * v16 + v19 * v9 + 2 * v10 * v22;
  uint64_t v33 = v7 * v18 + 2 * v13 * v13;
  uint64_t v34 = v30 + v22 * 2 * v7;
  uint64_t v35 = v31 + v22 * 2 * v8;
  uint64_t v36 = v18 * v13 + v7 * v17 + v8 * v16 + v22 * 2 * v9;
  uint64_t v37 = v33 + 2 * v8 * v17 + v10 * v16 + v22 * v15;
  uint64_t v38 = 2 * v7 * v8;
  uint64_t v39 = v20 * v7 + v8 * v18;
  uint64_t v40 = v35 + v23 * v7;
  uint64_t v41 = v32 + v23 * v21;
  uint64_t v42 = v10 * v18 + (int)v7 * (uint64_t)(int)v7 + v21 * v20;
  uint64_t v43 = v34 + v23 * v20;
  uint64_t v44 = v38 + v10 * v20;
  uint64_t v45 = v36 + v23 * v10;
  uint64_t v46 = v39 + v10 * v17;
  uint64_t v47 = v29 + v22 * v18 + v23 * v17;
  uint64_t v48 = v37 + v23 * 2 * v9;
  uint64_t v49 = v42 + 2 * v9 * v17;
  uint64_t v50 = 2 * v47;
  uint64_t v51 = 2 * v47 + 0x2000000;
  uint64_t v52 = (v51 >> 26) + 2 * v27;
  unint64_t v53 = v50 - (v51 & 0xFFFFFFFFFC000000);
  uint64_t v54 = 2 * v41 + 0x2000000;
  uint64_t v55 = (v54 >> 26) + 2 * v45;
  uint64_t v56 = v46 + v9 * v16 + v23 * v15;
  uint64_t v57 = v44 + v9 * v18 + v15 * v17;
  uint64_t v58 = v49 + v15 * v16;
  uint64_t v59 = ((v52 + 0x1000000) >> 25) + 2 * v43;
  uint64_t v60 = v58 + v23 * v14;
  uint64_t v61 = ((v55 + 0x1000000) >> 25) + 2 * v48;
  uint64_t v62 = v57 + v14 * v16;
  uint64_t v63 = ((v59 + 0x2000000) >> 26) + 2 * v40;
  uint64_t v64 = ((v61 + 0x2000000) >> 26) + 2 * v56;
  uint64_t v65 = ((v64 + 0x1000000) >> 25) + 2 * v60;
  uint64_t v66 = ((v65 + 0x2000000) >> 26) + 2 * v62;
  unint64_t v67 = v53 + 19 * ((v66 + 0x1000000) >> 25);
  a1[30] = v67 - ((v67 + 0x2000000) & 0xFC000000);
  a1[31] = v52 - ((v52 + 0x1000000) & 0xFE000000) + ((v67 + 0x2000000) >> 26);
  unint64_t v68 = 2 * v41 - (v54 & 0xFFFFFFFFFC000000) + ((v63 + 0x1000000) >> 25);
  a1[32] = v59 - ((v59 + 0x2000000) & 0xFC000000);
  a1[33] = v63 - ((v63 + 0x1000000) & 0xFE000000);
  a1[34] = v68 - ((v68 + 0x2000000) & 0xFC000000);
  a1[35] = v55 - ((v55 + 0x1000000) & 0xFE000000) + ((v68 + 0x2000000) >> 26);
  a1[36] = v61 - ((v61 + 0x2000000) & 0xFC000000);
  a1[37] = v64 - ((v64 + 0x1000000) & 0xFE000000);
  a1[38] = v65 - ((v65 + 0x2000000) & 0xFC000000);
  a1[39] = v66 - ((v66 + 0x1000000) & 0xFE000000);
  unint64_t v69 = a1 + 10;
  do
  {
    v69[v4] = a2[v4 + 10] + a2[v4];
    ++v4;
  }
  while (v4 != 10);
  uint64_t v76 = 0;
  memset(v75, 0, sizeof(v75));
  uint64_t result = fe_sq(v75, v69);
  for (uint64_t i = 0; i != 10; ++i)
    a1[i + 10] = a1[i] + a1[i + 20];
  for (uint64_t j = 0; j != 10; ++j)
    a1[j + 20] -= a1[j];
  for (uint64_t k = 0; k != 10; ++k)
    a1[k] = *(_DWORD *)((char *)v75 + k * 4) - a1[k + 10];
  for (uint64_t m = 0; m != 10; ++m)
    a1[m + 30] -= a1[m + 20];
  return result;
}

uint64_t x25519_ge_scalarmult(int *a1, uint64_t a2, long long *a3)
{
  v34[90] = *MEMORY[0x263EF8340];
  memset(v19, 0, sizeof(v19));
  ge_cached_0((uint64_t)v30);
  x25519_ge_p3_to_cached((uint64_t)&v31, (uint64_t)a3);
  uint64_t v6 = (int *)v33;
  ge_p3_to_p2((uint64_t)v33, a3);
  unint64_t v7 = 0;
  uint64_t v8 = (int *)&v32;
  uint64_t v9 = v34;
  do
  {
    ge_p2_dbl(v19, v6);
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    x25519_ge_p1p1_to_p3(&v20, (int *)v19);
    x25519_ge_p3_to_cached((uint64_t)v8, (uint64_t)&v20);
    if (v7 + 2 <= 7) {
      x25519_ge_p1p1_to_p2(v9, (int *)v19);
    }
    x25519_ge_add((int *)v19, (uint64_t)a3, v8);
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    x25519_ge_p1p1_to_p3(&v20, (int *)v19);
    x25519_ge_p3_to_cached((uint64_t)(v8 + 40), (uint64_t)&v20);
    if (v7 + 2 <= 6) {
      x25519_ge_p1p1_to_p2(v9 + 30, (int *)v19);
    }
    v7 += 2;
    v8 += 80;
    v9 += 60;
    v6 += 30;
  }
  while (v7 < 0xE);
  ge_p2_0((uint64_t)a1);
  unsigned int v10 = 0;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  do
  {
    ge_p2_dbl(v19, a1);
    x25519_ge_p1p1_to_p2(a1, (int *)v19);
    ge_p2_dbl(v19, a1);
    x25519_ge_p1p1_to_p2(a1, (int *)v19);
    ge_p2_dbl(v19, a1);
    x25519_ge_p1p1_to_p2(a1, (int *)v19);
    ge_p2_dbl(v19, a1);
    x25519_ge_p1p1_to_p3(&v20, (int *)v19);
    int v11 = (*(unsigned __int8 *)(a2 - (v10 >> 3) + 31) >> (~(_BYTE)v10 & 4)) & 0xF;
    memset(v18, 0, sizeof(v18));
    ge_cached_0((uint64_t)v18);
    uint64_t v12 = 0;
    uint64_t v13 = v30;
    do
    {
      uint64_t v14 = 0;
      int v15 = (int)((v11 ^ v12) - 1) >> 31;
      do
      {
        *(_DWORD *)((char *)v18 + v14) = *(_DWORD *)&v13[v14] & v15 | *(_DWORD *)((unsigned char *)v18 + v14) & ~v15;
        v14 += 4;
      }
      while (v14 != 40);
      do
      {
        *(_DWORD *)((char *)v18 + v14) = *(_DWORD *)&v13[v14] & v15 | *(_DWORD *)((unsigned char *)v18 + v14) & ~v15;
        v14 += 4;
      }
      while (v14 != 80);
      do
      {
        *(_DWORD *)((char *)v18 + v14) = *(_DWORD *)&v13[v14] & v15 | *(_DWORD *)((unsigned char *)v18 + v14) & ~v15;
        v14 += 4;
      }
      while (v14 != 120);
      do
      {
        *(_DWORD *)((char *)v18 + v14) = *(_DWORD *)&v13[v14] & v15 | *(_DWORD *)((unsigned char *)v18 + v14) & ~v15;
        v14 += 4;
      }
      while (v14 != 160);
      ++v12;
      v13 += 160;
    }
    while (v12 != 16);
    x25519_ge_add((int *)v19, (uint64_t)&v20, (int *)v18);
    uint64_t result = x25519_ge_p1p1_to_p2(a1, (int *)v19);
    BOOL v17 = v10 >= 0xFC;
    v10 += 4;
  }
  while (!v17);
  return result;
}

double ge_cached_0(uint64_t a1)
{
  *(void *)(a1 + 32) = 0;
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)a1 = 1;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 40) = 1;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(void *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 80) = 1;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(void *)(a1 + 152) = 0;
  return result;
}

__n128 ge_p3_to_p2(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  long long v3 = a2[1];
  *(void *)(a1 + 32) = *((void *)a2 + 4);
  *(_OWORD *)a1 = v2;
  *(_OWORD *)(a1 + 16) = v3;
  long long v4 = *(long long *)((char *)a2 + 40);
  long long v5 = *(long long *)((char *)a2 + 56);
  *(void *)(a1 + 72) = *((void *)a2 + 9);
  *(_OWORD *)(a1 + 56) = v5;
  *(_OWORD *)(a1 + 40) = v4;
  __n128 result = (__n128)a2[5];
  long long v7 = a2[6];
  *(void *)(a1 + 112) = *((void *)a2 + 14);
  *(__n128 *)(a1 + 80) = result;
  *(_OWORD *)(a1 + 96) = v7;
  return result;
}

double ge_p2_0(uint64_t a1)
{
  *(void *)(a1 + 32) = 0;
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 40) = 1;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(void *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 80) = 1;
  return result;
}

unsigned __int16 *x25519_sc_reduce(unsigned __int16 *result)
{
  unint64_t v1 = *(unsigned int *)((char *)result + 15);
  unint64_t v2 = *((unsigned int *)result + 9);
  unint64_t v3 = (v2 >> 24) | ((unint64_t)*((unsigned __int8 *)result + 40) << 8) | ((unint64_t)*((unsigned __int8 *)result + 41) << 16);
  unint64_t v4 = ((unint64_t)(HIBYTE(*((_DWORD *)result + 11)) | (*((unsigned __int8 *)result + 48) << 8) | (*((unsigned __int8 *)result + 49) << 16)) >> 2) & 0x1FFFFF;
  unint64_t v5 = ((unint64_t)*(unsigned int *)((char *)result + 49) >> 7) & 0x1FFFFF;
  unint64_t v6 = ((unint64_t)*((unsigned int *)result + 13) >> 4) & 0x1FFFFF;
  unint64_t v7 = ((unint64_t)(HIBYTE(*((_DWORD *)result + 13)) | (*((unsigned __int8 *)result + 56) << 8) | (*((unsigned __int8 *)result + 57) << 16)) >> 1) & 0x1FFFFF;
  uint64_t v8 = ((v1 >> 6) & 0x1FFFFF) + 666643 * v4;
  unint64_t v9 = (*(unsigned __int16 *)((char *)result + 21) | ((unint64_t)(*((unsigned char *)result + 23) & 0x1F) << 16))
     + 470296 * v5
     + 666643 * v6
     + 654183 * v4;
  unint64_t v10 = (((v1 >> 24) | ((unint64_t)*((unsigned __int8 *)result + 19) << 8) | ((unint64_t)*((unsigned __int8 *)result + 20) << 16)) >> 3)
      + 666643 * v5
      + 470296 * v4
      + ((unint64_t)(v8 + 0x100000) >> 21);
  unint64_t v11 = (((unint64_t)*(unsigned int *)((char *)result + 23) >> 5) & 0x1FFFFF)
      + 654183 * v5
      + 470296 * v6
      - 997805 * (int)v4
      + 666643 * v7
      + ((v9 + 0x100000) >> 21);
  unint64_t v12 = (((unint64_t)(HIBYTE(*(_DWORD *)((char *)result + 23)) | (*((unsigned __int8 *)result + 27) << 8) | (*((unsigned __int8 *)result + 28) << 16)) >> 2) & 0x1FFFFF)
      - 997805 * (int)v5
      + 654183 * v6
      + 136657 * v4;
  unint64_t v13 = (((unint64_t)*((unsigned int *)result + 7) >> 7) & 0x1FFFFF)
      + 136657 * v5
      - 997805 * (int)v6
      - 683901 * (int)v4;
  unint64_t v14 = (((unint64_t)*(unsigned int *)((char *)result + 31) >> 4) & 0x1FFFFF)
      - 683901 * (int)v5
      + 136657 * v6;
  unint64_t v15 = (((unint64_t)(HIBYTE(*(_DWORD *)((char *)result + 31)) | (*((unsigned __int8 *)result + 35) << 8) | (*((unsigned __int8 *)result + 36) << 16)) >> 1) & 0x1FFFFF)
      - 683901 * (int)v6;
  unint64_t v16 = (unint64_t)*((unsigned int *)result + 15) >> 3;
  uint64_t v17 = ((v2 >> 6) & 0x1FFFFF) - 997805 * (int)v16;
  uint64_t v18 = (v3 >> 3) + 136657 * v16;
  unint64_t v19 = (result[21] | ((unint64_t)(result[22] & 0x1F) << 16)) - 683901 * (int)v16;
  unint64_t v20 = v14 + 470296 * v16;
  unint64_t v21 = v13 + 666643 * v16;
  unint64_t v22 = v15 + 654183 * v16;
  unint64_t v23 = ((unint64_t)*(unsigned int *)((char *)result + 57) >> 6) & 0x1FFFFF;
  uint64_t v24 = v18 - 683901 * (int)v23;
  uint64_t v25 = v17 + 136657 * v23 - 683901 * (int)v7;
  uint64_t v26 = v20 + 654183 * v23 - 997805 * (int)v7;
  uint64_t v27 = v12 + 666643 * v23 + 470296 * v7;
  unint64_t v28 = v21 + 470296 * v23;
  unint64_t v29 = v22 - 997805 * (int)v23;
  uint64_t v30 = v28 + 654183 * v7 + ((v27 + 0x100000) >> 21);
  uint64_t v31 = v29 + 136657 * v7 + ((v26 + 0x100000) >> 21);
  unint64_t v32 = v26 - ((v26 + 0x100000) & 0xFFFFFFFFFFE00000);
  uint64_t v33 = v24 + ((v25 + 0x100000) >> 21);
  unint64_t v34 = (((unint64_t)*((unsigned int *)result + 11) >> 5) & 0x1FFFFF) + ((uint64_t)(v19 + 0x100000) >> 21);
  unint64_t v35 = v9 - ((v9 + 0x100000) & 0xFFFFFE00000) + ((v10 + 0x100000) >> 21);
  unint64_t v36 = v10 - ((v10 + 0x100000) & 0x7FFFFFFFFFE00000);
  unint64_t v37 = v32 + ((v30 + 0x100000) >> 21);
  unint64_t v38 = v30 - ((v30 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v39 = v25 - ((v25 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v31 + 0x100000) >> 21);
  unint64_t v40 = v31 - ((v31 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v41 = v19 - ((v19 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v33 + 0x100000) >> 21);
  unint64_t v42 = v33 - ((v33 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v43 = (((unint64_t)*(unsigned int *)((char *)result + 7) >> 7) & 0x1FFFFF) + 666643 * v42;
  unint64_t v44 = (((unint64_t)*(unsigned int *)(result + 5) >> 4) & 0x1FFFFF) + 666643 * v41 + 470296 * v42;
  unint64_t v45 = (((unint64_t)(HIBYTE(*(_DWORD *)(result + 5)) | (*((unsigned __int8 *)result + 14) << 8) | (*((unsigned __int8 *)result + 15) << 16)) >> 1) & 0x1FFFFF)
      + 666643 * v34
      + 470296 * v41
      + 654183 * v42;
  uint64_t v46 = v8 - ((v8 + 0x100000) & 0x7FFFFE00000) + 470296 * v34 + 654183 * v41 - 997805 * v42;
  uint64_t v47 = v36 + 654183 * v34 - 997805 * v41 + 136657 * v42;
  uint64_t v48 = v35 - 997805 * v34 + 136657 * v41 - 683901 * v42;
  unint64_t v49 = (((unint64_t)(HIBYTE(*(_DWORD *)(result + 1)) | (*((unsigned __int8 *)result + 6) << 8) | (*((unsigned __int8 *)result + 7) << 16)) >> 2) & 0x1FFFFF)
      + 666643 * v39;
  unint64_t v50 = v43 + 470296 * v39;
  unint64_t v51 = v44 + 654183 * v39;
  unint64_t v52 = v45 - 997805 * v39;
  unint64_t v53 = v46 + 136657 * v39;
  unint64_t v54 = v47 - 683901 * v39;
  unint64_t v55 = (((unint64_t)*(unsigned int *)(result + 1) >> 5) & 0x1FFFFF) + 666643 * v40;
  unint64_t v56 = v49 + 470296 * v40;
  unint64_t v57 = v50 + 654183 * v40;
  unint64_t v58 = v51 - 997805 * v40;
  unint64_t v59 = v52 + 136657 * v40;
  unint64_t v60 = v53 - 683901 * v40;
  unint64_t v61 = v27 - 683901 * v34 - ((v27 + 0x100000) & 0xFFFFFFFFFFE00000) + ((uint64_t)(v11 + 0x100000) >> 21);
  unint64_t v62 = (*result | ((unint64_t)(result[1] & 0x1F) << 16)) + 666643 * v37;
  unint64_t v63 = v56 + 654183 * v37;
  unint64_t v64 = v58 + 136657 * v37;
  uint64_t v65 = v55 + 470296 * v37 + ((uint64_t)(v62 + 0x100000) >> 21);
  unint64_t v66 = v54 + ((uint64_t)(v60 + 0x100000) >> 21);
  unint64_t v67 = v11 + 136657 * v34 - ((v11 + 0x100000) & 0xFFFFFFFFFFE00000) - 683901 * v41 + ((v48 + 0x100000) >> 21);
  unint64_t v68 = v48 - ((v48 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v69 = v38 + ((uint64_t)(v61 + 0x100000) >> 21);
  unint64_t v70 = v61 - ((v61 + 0x100000) & 0xFFFFFFFFFFE00000);
  uint64_t v71 = v65 + 0x100000;
  unint64_t v72 = v70 + ((uint64_t)(v67 + 0x100000) >> 21);
  unint64_t v73 = v67 - ((v67 + 0x100000) & 0xFFFFFFFFFFE00000);
  uint64_t v74 = (uint64_t)(v69 + 0x100000) >> 21;
  unint64_t v75 = v65 + 470296 * v74 - ((v65 + 0x100000) & 0xFFFFFFFFFFE00000);
  uint64_t v76 = v57 - 997805 * v37 + ((uint64_t)(v63 + 0x100000) >> 21);
  unint64_t v77 = v63 + 654183 * v74 - ((v63 + 0x100000) & 0xFFFFFFFFFFE00000) + (v71 >> 21);
  unint64_t v78 = v76 - 997805 * v74 - ((v76 + 0x100000) & 0xFFFFFFFFFFE00000);
  uint64_t v79 = v59 - 683901 * v37 + ((uint64_t)(v64 + 0x100000) >> 21);
  unint64_t v80 = v64 + 136657 * v74 - ((v64 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v76 + 0x100000) >> 21);
  int64_t v81 = v62 - ((v62 + 0x100000) & 0xFFFFFFFFFFE00000) + 666643 * v74;
  uint64_t v82 = v79 - 683901 * v74;
  v79 += 0x100000;
  unint64_t v83 = v60 - ((v60 + 0x100000) & 0xFFFFFFFFFFE00000) + (v79 >> 21);
  uint64_t v84 = v75 + (v81 >> 21);
  uint64_t v85 = v77 + (v84 >> 21);
  uint64_t v86 = v78 + (v85 >> 21);
  uint64_t v87 = v80 + (v86 >> 21);
  int64_t v88 = v82 - (v79 & 0xFFFFFFFFFFE00000) + (v87 >> 21);
  uint64_t v89 = v83 + (v88 >> 21);
  int64_t v90 = v66 - ((v66 + 0x100000) & 0xFFFFFFFFFFE00000) + (v89 >> 21);
  uint64_t v91 = v68 + ((uint64_t)(v66 + 0x100000) >> 21) + (v90 >> 21);
  uint64_t v92 = v73 + (v91 >> 21);
  uint64_t v93 = v72 + (v92 >> 21);
  int64_t v94 = v69 - ((v69 + 0x100000) & 0xFFFFFFFFFFE00000) + (v93 >> 21);
  uint64_t v95 = (v81 & 0x1FFFFF) + 666643 * (v94 >> 21);
  *((unsigned char *)result + 1) = (unsigned __int16)(v81 + 11283 * (v94 >> 21)) >> 8;
  uint64_t v96 = (v84 & 0x1FFFFF) + 470296 * (v94 >> 21) + (v95 >> 21);
  *(unsigned char *)double result = v81 + 19 * (v94 >> 21);
  *((unsigned char *)result + 2) = ((unint64_t)((v81 & 0x1FFFFF) + 666643 * (v94 >> 21)) >> 16) & 0x1F | (32 * (v84 + 24 * (v94 >> 21) + (v95 >> 21)));
  *((unsigned char *)result + 3) = (unint64_t)v96 >> 3;
  *((unsigned char *)result + 4) = (unint64_t)v96 >> 11;
  uint64_t v97 = (v85 & 0x1FFFFF) + 654183 * (v94 >> 21) + (v96 >> 21);
  *((unsigned char *)result + 5) = (v96 >> 19) & 3 | (4 * (v85 + 103 * (v94 >> 21) + (v96 >> 21)));
  *((unsigned char *)result + 6) = (unint64_t)v97 >> 6;
  uint64_t v98 = (v86 & 0x1FFFFF) - 997805 * (v94 >> 21) + (v97 >> 21);
  *((unsigned char *)result + 7) = (v97 >> 14) & 0x7F | (((_BYTE)v86
                                                              - -83 * (v94 >> 21)
                                                              + (v97 >> 21)) << 7);
  *((unsigned char *)result + 8) = (unint64_t)v98 >> 1;
  *((unsigned char *)result + 9) = (unint64_t)v98 >> 9;
  uint64_t v99 = (v87 & 0x1FFFFF) + 136657 * (v94 >> 21) + (v98 >> 21);
  *((unsigned char *)result + 10) = (v98 >> 17) & 0xF | (16 * (v87 - 47 * (v94 >> 21) + (v98 >> 21)));
  *((unsigned char *)result + 11) = (unint64_t)v99 >> 4;
  *((unsigned char *)result + 12) = (unint64_t)v99 >> 12;
  uint64_t v100 = (v88 & 0x1FFFFF) - 683901 * (v94 >> 21) + (v99 >> 21);
  *((unsigned char *)result + 13) = ((v99 & 0x100000) != 0) | (2 * (v88 - 125 * (v94 >> 21) + (v99 >> 21)));
  *((unsigned char *)result + 14) = (unint64_t)v100 >> 7;
  uint64_t v101 = (v89 & 0x1FFFFF) + (v100 >> 21);
  *((unsigned char *)result + 15) = (v100 >> 15) & 0x3F | (((_BYTE)v89 + (v100 >> 21)) << 6);
  *((unsigned char *)result + 16) = (unint64_t)v101 >> 2;
  *((unsigned char *)result + 17) = (unint64_t)v101 >> 10;
  uint64_t v102 = (v90 & 0x1FFFFF) + (v101 >> 21);
  *((unsigned char *)result + 18) = (v101 >> 18) & 7 | (8 * (v66 + (v89 >> 21) + (v101 >> 21)));
  *((unsigned char *)result + 19) = (unint64_t)v102 >> 5;
  *((unsigned char *)result + 20) = (unint64_t)v102 >> 13;
  *((unsigned char *)result + 22) = (unsigned __int16)(v91 + (v102 >> 21)) >> 8;
  uint64_t v103 = (v92 & 0x1FFFFF) + (((v91 & 0x1FFFFF) + (v102 >> 21)) >> 21);
  *((unsigned char *)result + 21) = v91 + (v102 >> 21);
  *((unsigned char *)result + 23) = ((unint64_t)((v91 & 0x1FFFFF) + (v102 >> 21)) >> 16) & 0x1F | (32 * v103);
  *((unsigned char *)result + 24) = (unint64_t)v103 >> 3;
  *((unsigned char *)result + 25) = (unint64_t)v103 >> 11;
  uint64_t v104 = (v93 & 0x1FFFFF) + (v103 >> 21);
  *((unsigned char *)result + 26) = (v103 >> 19) & 3 | (4 * v104);
  *((unsigned char *)result + 27) = (unint64_t)v104 >> 6;
  unint64_t v105 = (v94 & 0x1FFFFF) + (v104 >> 21);
  *((unsigned char *)result + 28) = (v104 >> 14) & 0x7F | ((_BYTE)v105 << 7);
  *((unsigned char *)result + 29) = v105 >> 1;
  *((unsigned char *)result + 30) = v105 >> 9;
  *((unsigned char *)result + 31) = v105 >> 17;
  return result;
}

uint64_t ED25519_public_from_private(uint64_t a1, unsigned __int8 *d)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  SHA512(d, 0x20uLL, (unsigned __int8 *)&md);
  md.i8[0] &= 0xF8u;
  char v6 = v6 & 0x3F | 0x40;
  memset(v4, 0, sizeof(v4));
  x25519_ge_scalarmult_base(v4, &md);
  return ge_p3_tobytes(a1, (int *)v4);
}

uint64_t ge_p3_tobytes(uint64_t a1, int *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  uint64_t v8 = 0;
  memset(v7, 0, sizeof(v7));
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  fe_invert(v9, a2 + 20);
  fe_mul(v7, a2, (int *)v9);
  fe_mul(v5, a2 + 10, (int *)v9);
  fe_tobytes(a1, v5);
  uint64_t result = fe_tobytes((uint64_t)v11, v7);
  *(unsigned char *)(a1 + 31) ^= v11[0] << 7;
  return result;
}

uint64_t ED25519_keypair(uint64_t a1, void *__buf)
{
  arc4random_buf(__buf, 0x20uLL);
  return ED25519_public_from_private(a1, (unsigned __int8 *)__buf);
}

uint64_t ED25519_sign(unsigned char *a1, const void *a2, size_t a3, const void *a4, unsigned __int8 *d)
{
  v188[4] = *MEMORY[0x263EF8340];
  SHA512(d, 0x20uLL, md);
  md[0] &= 0xF8u;
  HIBYTE(v187) = HIBYTE(v187) & 0x3F | 0x40;
  memset(&c, 0, sizeof(c));
  SHA512_Init(&c);
  SHA512_Update(&c, v188, 0x20uLL);
  SHA512_Update(&c, a2, a3);
  SHA512_Final(v164, &c);
  x25519_sc_reduce((unsigned __int16 *)v164);
  memset(v150, 0, sizeof(v150));
  x25519_ge_scalarmult_base(v150, (int8x16_t *)v164);
  ge_p3_tobytes((uint64_t)a1, (int *)v150);
  SHA512_Init(&c);
  SHA512_Update(&c, a1, 0x20uLL);
  SHA512_Update(&c, a4, 0x20uLL);
  SHA512_Update(&c, a2, a3);
  SHA512_Final(v152, &c);
  x25519_sc_reduce((unsigned __int16 *)v152);
  unsigned int v9 = *(unsigned __int16 *)v152 | ((v153 & 0x1F) << 16);
  unsigned int v10 = v160 | ((v161 & 0x1F) << 16);
  unsigned int v11 = *(unsigned __int16 *)md | ((v177 & 0x1F) << 16);
  unsigned int v12 = v184 | ((v185 & 0x1F) << 16);
  unint64_t v13 = ((unint64_t)v153 >> 5) & 0x1FFFFF;
  unint64_t v14 = ((unint64_t)(HIBYTE(v153) | (v154 << 8) | (v155[0] << 16)) >> 2) & 0x1FFFFF;
  unint64_t v15 = ((unint64_t)v177 >> 5) & 0x1FFFFF;
  unint64_t v16 = ((unint64_t)(HIBYTE(v177) | (v178 << 8) | (v179[0] << 16)) >> 2) & 0x1FFFFF;
  unint64_t v149 = v15 * v13
       + v11 * (unint64_t)v14
       + v16 * v9
       + (((unint64_t)(HIBYTE(v165) | (v166 << 8) | (v167[0] << 16)) >> 2) & 0x1FFFFF);
  unint64_t v17 = ((unint64_t)*(unsigned int *)v155 >> 7) & 0x1FFFFF;
  unint64_t v18 = ((unint64_t)*(unsigned int *)&v155[3] >> 4) & 0x1FFFFF;
  unint64_t v19 = ((unint64_t)*(unsigned int *)v179 >> 7) & 0x1FFFFF;
  unint64_t v20 = ((unint64_t)*(unsigned int *)&v179[3] >> 4) & 0x1FFFFF;
  unint64_t v21 = v15 * (unint64_t)v17
      + v11 * v18
      + v19 * (unint64_t)v13
      + v9 * (unint64_t)v20
      + v16 * (unint64_t)v14
      + (((unint64_t)*(unsigned int *)&v167[3] >> 4) & 0x1FFFFF);
  unint64_t v22 = ((unint64_t)(v155[6] | (v156 << 8) | (v157 << 16)) >> 1) & 0x1FFFFF;
  unint64_t v23 = ((unint64_t)v157 >> 6) & 0x1FFFFF;
  unint64_t v24 = ((unint64_t)v181 >> 6) & 0x1FFFFF;
  unint64_t v25 = ((unint64_t)(v179[6] | (v180 << 8) | (v181 << 16)) >> 1) & 0x1FFFFF;
  unint64_t v147 = v22 * (unint64_t)v15
       + v11 * (unint64_t)v23
       + v19 * (unint64_t)v17
       + v14 * (unint64_t)v20
       + v16 * (unint64_t)v18
       + v9 * (unint64_t)v24
       + v25 * (unint64_t)v13
       + (((unint64_t)v169 >> 6) & 0x1FFFFF);
  unint64_t v26 = (((unint64_t)v157 >> 24) | ((unint64_t)v158 << 8) | ((unint64_t)v159 << 16)) >> 3;
  unint64_t v27 = (((unint64_t)v181 >> 24) | ((unint64_t)v182 << 8) | ((unint64_t)v183 << 16)) >> 3;
  unint64_t v146 = v26 * (unint64_t)v15
       + v11 * (unint64_t)v10
       + v22 * (unint64_t)v19
       + v20 * (unint64_t)v18
       + v16 * (unint64_t)v23
       + v14 * (unint64_t)v24
       + v25 * (unint64_t)v17
       + v27 * (unint64_t)v13
       + v12 * (unint64_t)v9
       + v172
       + ((unint64_t)(v173 & 0x1F) << 16);
  unint64_t v28 = ((unint64_t)v161 >> 5) & 0x1FFFFF;
  unint64_t v29 = ((unint64_t)(HIBYTE(v161) | (v162 << 8) | (v163 << 16)) >> 2) & 0x1FFFFF;
  unint64_t v30 = ((unint64_t)v185 >> 5) & 0x1FFFFF;
  unint64_t v31 = ((unint64_t)(HIBYTE(v185) | (v186 << 8) | (v187 << 16)) >> 2) & 0x1FFFFF;
  unint64_t v145 = v15 * v28
       + v11 * v29
       + v26 * (unint64_t)v19
       + v20 * (unint64_t)v23
       + v16 * (unint64_t)v10
       + v24 * (unint64_t)v18
       + v25 * (unint64_t)v22
       + v27 * (unint64_t)v17
       + v30 * v13
       + v12 * (unint64_t)v14
       + v31 * v9
       + (((unint64_t)(HIBYTE(v173) | (v174 << 8) | (v175 << 16)) >> 2) & 0x1FFFFF);
  unint64_t v32 = (*(unsigned __int16 *)v164 | ((unint64_t)(v165 & 0x1F) << 16)) + v11 * (unint64_t)v9;
  unint64_t v33 = v9 * (unint64_t)v15
      + v11 * (unint64_t)v13
      + (((unint64_t)v165 >> 5) & 0x1FFFFF)
      + ((v32 + 0x100000) >> 21);
  unint64_t v148 = v32 - ((v32 + 0x100000) & 0xFFFFFE00000);
  unint64_t v34 = v14 * (unint64_t)v15
      + v11 * (unint64_t)v17
      + v9 * (unint64_t)v19
      + v16 * (unint64_t)v13
      + (((unint64_t)*(unsigned int *)v167 >> 7) & 0x1FFFFF);
  unint64_t v143 = v15 * (unint64_t)v18
       + v11 * (unint64_t)v22
       + v14 * (unint64_t)v19
       + v20 * (unint64_t)v13
       + v16 * (unint64_t)v17
       + v25 * (unint64_t)v9
       + ((v21 + 0x100000) >> 21)
       + (((unint64_t)(v167[6] | (v168 << 8) | (v169 << 16)) >> 1) & 0x1FFFFF);
  unint64_t v35 = v21 - ((v21 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v141 = v15 * (unint64_t)v23
       + v11 * (unint64_t)v26
       + v19 * (unint64_t)v18
       + v20 * (unint64_t)v17
       + v16 * (unint64_t)v22
       + v24 * (unint64_t)v13
       + v25 * (unint64_t)v14
       + v27 * (unint64_t)v9
       + ((((unint64_t)v169 >> 24) | ((unint64_t)v170 << 8) | ((unint64_t)v171 << 16)) >> 3);
  unint64_t v140 = v10 * (unint64_t)v15
       + v11 * (unint64_t)v28
       + v19 * (unint64_t)v23
       + v22 * (unint64_t)v20
       + v16 * (unint64_t)v26
       + v24 * (unint64_t)v17
       + v25 * (unint64_t)v18
       + v27 * (unint64_t)v14
       + v9 * (unint64_t)v30
       + v12 * (unint64_t)v13
       + (((unint64_t)v173 >> 5) & 0x1FFFFF);
  unint64_t v36 = (unint64_t)v163 >> 7;
  unint64_t v37 = v29 * (unint64_t)v15 + v11 * (unint64_t)v36;
  unint64_t v38 = (unint64_t)v187 >> 7;
  unint64_t v39 = v37
      + v10 * (unint64_t)v19
      + v26 * (unint64_t)v20
      + v16 * (unint64_t)v28
      + v22 * (unint64_t)v24
      + v25 * (unint64_t)v23
      + v27 * (unint64_t)v18
      + v14 * (unint64_t)v30
      + v12 * (unint64_t)v17
      + v9 * (unint64_t)v38;
  unint64_t v40 = v15 * (unint64_t)v36
      + v19 * (unint64_t)v28
      + v10 * (unint64_t)v20
      + v16 * (unint64_t)v29
      + v24 * (unint64_t)v23
      + v25 * (unint64_t)v26
      + v27 * (unint64_t)v22
      + v30 * (unint64_t)v17
      + v12 * (unint64_t)v18
      + v38 * (unint64_t)v13;
  unint64_t v41 = v39 + v31 * (unint64_t)v13 + ((unint64_t)v175 >> 7);
  unint64_t v42 = v40 + v31 * (unint64_t)v14;
  unint64_t v43 = v19 * (unint64_t)v36
      + v29 * (unint64_t)v20
      + v10 * (unint64_t)v24
      + v25 * (unint64_t)v28
      + v27 * (unint64_t)v26
      + v22 * (unint64_t)v30
      + v12 * (unint64_t)v23
      + v38 * (unint64_t)v17;
  unint64_t v44 = v29 * (unint64_t)v19
      + v20 * (unint64_t)v28
      + v16 * (unint64_t)v36
      + v26 * (unint64_t)v24
      + v25 * (unint64_t)v10
      + v27 * (unint64_t)v23
      + v30 * (unint64_t)v18
      + v12 * (unint64_t)v22
      + v14 * (unint64_t)v38
      + v31 * (unint64_t)v17;
  unint64_t v45 = v27 * (unint64_t)v36
      + v30 * (unint64_t)v28
      + v12 * (unint64_t)v29
      + v26 * (unint64_t)v38
      + v31 * (unint64_t)v10;
  unint64_t v46 = v29 * (unint64_t)v30
      + v12 * (unint64_t)v36
      + v10 * (unint64_t)v38
      + v31 * (unint64_t)v28
      + ((v45 + 0x100000) >> 21);
  unint64_t v47 = v43 + v31 * (unint64_t)v18;
  unint64_t v48 = v20 * (unint64_t)v36
      + v24 * (unint64_t)v28
      + v25 * (unint64_t)v29
      + v27 * (unint64_t)v10
      + v30 * (unint64_t)v23
      + v12 * (unint64_t)v26
      + v38 * (unint64_t)v18;
  unint64_t v49 = v29 * (unint64_t)v24
      + v25 * (unint64_t)v36
      + v27 * (unint64_t)v28
      + v26 * (unint64_t)v30
      + v12 * (unint64_t)v10
      + v22 * (unint64_t)v38;
  unint64_t v50 = v24 * (unint64_t)v36
      + v27 * (unint64_t)v29
      + v10 * (unint64_t)v30;
  unint64_t v51 = v34 + ((v149 + 0x100000) >> 21);
  unint64_t v52 = v44 + ((v42 + 0x100000) >> 21);
  unint64_t v53 = v49 + v31 * (unint64_t)v23;
  unint64_t v54 = v48 + v31 * (unint64_t)v22 + ((v47 + 0x100000) >> 21);
  unint64_t v55 = v50
      + v12 * (unint64_t)v28
      + v38 * (unint64_t)v23
      + v31 * (unint64_t)v26
      + ((v53 + 0x100000) >> 21);
  unint64_t v56 = v30 * (unint64_t)v36
      + v38 * (unint64_t)v28
      + v31 * (unint64_t)v29;
  unint64_t v57 = v29 * (unint64_t)v38
      + v31 * (unint64_t)v36
      + ((v56 + 0x100000) >> 21);
  unint64_t v58 = v38 * (unint64_t)v36;
  unint64_t v59 = (v58 + 0x100000) >> 21;
  unint64_t v60 = v33 + 0x100000;
  unint64_t v142 = v33 - ((v33 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v144 = v35 + ((v51 + 0x100000) >> 21);
  unint64_t v61 = v45 - ((v45 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v55 + 0x100000) >> 21);
  unint64_t v62 = v55 - ((v55 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v63 = v56 - ((v56 + 0x100000) & 0x1FFFFFFE00000) + ((v46 + 0x100000) >> 21);
  unint64_t v64 = v46 - ((v46 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v65 = v58 - ((v58 + 0x100000) & 0x7FFFFFFE00000) + ((v57 + 0x100000) >> 21);
  unint64_t v66 = v57 - ((v57 + 0x100000) & 0x1FFFFFFE00000);
  unint64_t v67 = v53 - 683901 * (int)v59 - ((v53 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v68 = v47 - 997805 * (int)v59 - ((v47 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v69 = v42 + 470296 * v59 - ((v42 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v70 = v141 + ((v147 + 0x100000) >> 21);
  unint64_t v71 = v140 + ((v146 + 0x100000) >> 21);
  unint64_t v72 = 666643 * v63
      + 470296 * v64
      + 654183 * v61
      + v146
      + ((v70 + 0x100000) >> 21)
      - ((v146 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v73 = v41 + ((v145 + 0x100000) >> 21);
  unint64_t v74 = 666643 * v65
      + 470296 * v66
      + 654183 * v63
      - 997805 * v64
      + 136657 * v61
      + ((v71 + 0x100000) >> 21)
      + v145
      - ((v145 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v75 = 666643 * v64 + 470296 * v61 + v70 - ((v70 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v76 = 666643 * v66 + 470296 * v63 + 654183 * v64 - 997805 * v61 + v71 - ((v71 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v77 = v69 + 654183 * v65 - 997805 * v66 + 136657 * v63 - 683901 * v64 + ((v73 + 0x100000) >> 21);
  unint64_t v78 = 470296 * v65
      + 666643 * v59
      + 654183 * v66
      - 997805 * v63
      + 136657 * v64
      - 683901 * v61
      + v73
      - ((v73 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v79 = v68 + ((v52 + 0x100000) >> 21);
  unint64_t v80 = v52
      + 654183 * v59
      - ((v52 + 0x100000) & 0xFFFFFFFFFFE00000)
      - 997805 * v65
      + 136657 * v66
      - 683901 * v63
      + ((uint64_t)(v77 + 0x100000) >> 21);
  unint64_t v81 = v54 + 136657 * v59;
  v54 += 0x100000;
  unint64_t v82 = v67 + (v54 >> 21);
  unint64_t v83 = v147 + 666643 * v61 - ((v147 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v143 + 0x100000) >> 21);
  unint64_t v84 = v76 + ((uint64_t)(v72 + 0x100000) >> 21);
  uint64_t v85 = v79 + 136657 * v65 - 683901 * v66;
  unint64_t v86 = v78 + ((uint64_t)(v74 + 0x100000) >> 21);
  unint64_t v87 = v81 - (v54 & 0xFFFFFFFFFFE00000) - 683901 * v65 + ((v85 + 0x100000) >> 21);
  unint64_t v88 = v62 + ((uint64_t)(v82 + 0x100000) >> 21);
  unint64_t v89 = v82 - ((v82 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v90 = v77 - ((v77 + 0x100000) & 0xFFFFFFFFFFE00000) + ((uint64_t)(v86 + 0x100000) >> 21);
  unint64_t v91 = v86 - ((v86 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v92 = v85 - ((v85 + 0x100000) & 0xFFFFFFFFFFE00000) + ((uint64_t)(v80 + 0x100000) >> 21);
  unint64_t v93 = v80 - ((v80 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v94 = v89 + ((uint64_t)(v87 + 0x100000) >> 21);
  unint64_t v95 = v87 - ((v87 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v96 = v74 - 683901 * v88 + ((uint64_t)(v84 + 0x100000) >> 21) - ((v74 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v97 = v75 + ((uint64_t)(v83 + 0x100000) >> 21);
  unint64_t v98 = -997805 * v88
      + 136657 * v94
      - 683901 * v95
      + v72
      + ((uint64_t)(v97 + 0x100000) >> 21)
      - ((v72 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v99 = v83 + 470296 * v88 - ((v83 + 0x100000) & 0xFFFFFFFFFFE00000);
  unint64_t v100 = v148 + 666643 * v90;
  uint64_t v101 = v142 + 470296 * v90 + 666643 * v93 + ((uint64_t)(v100 + 0x100000) >> 21);
  uint64_t v102 = v99 + 654183 * v94 - 997805 * v95 + 136657 * v92 - 683901 * v93;
  unint64_t v103 = v97
       + 654183 * v88
       - 997805 * v94
       + 136657 * v95
       - ((v97 + 0x100000) & 0xFFFFFFFFFFE00000)
       - 683901 * v92
       + ((v102 + 0x100000) >> 21);
  unint64_t v104 = 136657 * v88
       - 683901 * v94
       + v84
       - ((v84 + 0x100000) & 0xFFFFFFFFFFE00000)
       + ((uint64_t)(v98 + 0x100000) >> 21);
  unint64_t v105 = v91 + ((uint64_t)(v96 + 0x100000) >> 21);
  uint64_t v106 = (uint64_t)(v105 + 0x100000) >> 21;
  unint64_t v107 = v149 + (v60 >> 21) - ((v149 + 0x100000) & 0xFFFFFFFFFFE00000) + 654183 * v90 + 666643 * v92 + 470296 * v93;
  unint64_t v108 = v51
       - ((v51 + 0x100000) & 0xFFFFFFFFFFE00000)
       + 666643 * v95
       - 997805 * v90
       + 470296 * v92
       + 654183 * v93
       + ((uint64_t)(v107 + 0x100000) >> 21);
  unint64_t v109 = v143 + 666643 * v88 - ((v143 + 0x100000) & 0xFFFFFFFFFFE00000) + 470296 * v94 + 654183 * v95 - 683901 * v90;
  uint64_t v110 = v144 + 666643 * v94 + 470296 * v95 + 136657 * v90 + 654183 * v92 - 997805 * v93;
  uint64_t v111 = v109 - 997805 * v92 + 136657 * v93 + ((v110 + 0x100000) >> 21);
  unint64_t v112 = v96 + ((uint64_t)(v104 + 0x100000) >> 21);
  int64_t v113 = v100 - ((v100 + 0x100000) & 0xFFFFFFFFFFE00000) + 666643 * v106;
  unint64_t v114 = (v96 + 0x100000) & 0xFFFFFFFFFFE00000;
  int64_t v115 = v101 + 470296 * v106 - ((v101 + 0x100000) & 0xFFFFFFFFFFE00000) + (v113 >> 21);
  uint64_t v116 = v113 & 0x1FFFFF;
  int64_t v117 = v107 + 654183 * v106 - ((v107 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v101 + 0x100000) >> 21) + (v115 >> 21);
  int64_t v118 = v108 - 997805 * v106 - ((v108 + 0x100000) & 0xFFFFFFFFFFE00000) + (v117 >> 21);
  int64_t v119 = v110
       + 136657 * v106
       - ((v110 + 0x100000) & 0xFFFFFFFFFFE00000)
       + ((uint64_t)(v108 + 0x100000) >> 21)
       + (v118 >> 21);
  int64_t v120 = v111 - 683901 * v106 - ((v111 + 0x100000) & 0xFFFFFFFFFFE00000) + (v119 >> 21);
  int64_t v121 = v102 - ((v102 + 0x100000) & 0xFFFFFFFFFFE00000) + ((v111 + 0x100000) >> 21) + (v120 >> 21);
  int64_t v122 = v103 - ((v103 + 0x100000) & 0xFFFFFFFFFFE00000) + (v121 >> 21);
  int64_t v123 = v98 - ((v98 + 0x100000) & 0xFFFFFFFFFFE00000) + ((uint64_t)(v103 + 0x100000) >> 21) + (v122 >> 21);
  int64_t v124 = v104 - ((v104 + 0x100000) & 0xFFFFFFFFFFE00000) + (v123 >> 21);
  uint64_t v125 = v112 - v114 + (v124 >> 21);
  int64_t v126 = v105 - ((v105 + 0x100000) & 0xFFFFFFFFFFE00000) + (v125 >> 21);
  uint64_t v127 = v116 + 666643 * (v126 >> 21);
  a1[33] = BYTE1(v127);
  uint64_t v128 = (v115 & 0x1FFFFF) + 470296 * (v126 >> 21) + (v127 >> 21);
  a1[32] = v127;
  a1[34] = ((v116 + 666643 * (v126 >> 21)) >> 16) & 0x1F | (32
                                                                                      * (v115
                                                                                       + 24 * (v126 >> 21)
                                                                                       + (v127 >> 21)));
  a1[35] = (unint64_t)v128 >> 3;
  a1[36] = (unint64_t)v128 >> 11;
  uint64_t v129 = (v117 & 0x1FFFFF) + 654183 * (v126 >> 21) + (v128 >> 21);
  a1[37] = (v128 >> 19) & 3 | (4 * (v117 + 103 * (v126 >> 21) + (v128 >> 21)));
  a1[38] = (unint64_t)v129 >> 6;
  uint64_t v130 = (v118 & 0x1FFFFF) - 997805 * (v126 >> 21) + (v129 >> 21);
  a1[39] = (v129 >> 14) & 0x7F | (((_BYTE)v108
                                               - -83 * (_BYTE)v106
                                               + (v117 >> 21)
                                               - -83 * (v126 >> 21)
                                               + (v129 >> 21)) << 7);
  a1[40] = (unint64_t)v130 >> 1;
  a1[41] = (unint64_t)v130 >> 9;
  uint64_t v131 = (v119 & 0x1FFFFF) + 136657 * (v126 >> 21) + (v130 >> 21);
  a1[42] = (v130 >> 17) & 0xF | (16 * (v119 - 47 * (v126 >> 21) + (v130 >> 21)));
  a1[43] = (unint64_t)v131 >> 4;
  a1[44] = (unint64_t)v131 >> 12;
  uint64_t v132 = (v120 & 0x1FFFFF) - 683901 * (v126 >> 21) + (v131 >> 21);
  a1[45] = ((v131 & 0x100000) != 0) | (2 * (v120 - 125 * (v126 >> 21) + (v131 >> 21)));
  a1[46] = (unint64_t)v132 >> 7;
  uint64_t v133 = (v121 & 0x1FFFFF) + (v132 >> 21);
  a1[47] = (v132 >> 15) & 0x3F | (((_BYTE)v121 + (v132 >> 21)) << 6);
  a1[48] = (unint64_t)v133 >> 2;
  a1[49] = (unint64_t)v133 >> 10;
  uint64_t v134 = (v122 & 0x1FFFFF) + (v133 >> 21);
  a1[50] = (v133 >> 18) & 7 | (8 * (v122 + (v133 >> 21)));
  a1[51] = (unint64_t)v134 >> 5;
  uint64_t v135 = (v123 & 0x1FFFFF) + (v134 >> 21);
  a1[52] = (unint64_t)v134 >> 13;
  a1[54] = BYTE1(v135);
  uint64_t v136 = (v124 & 0x1FFFFF) + (v135 >> 21);
  a1[53] = v135;
  a1[55] = BYTE2(v135) & 0x1F | (32 * (v124 + (v135 >> 21)));
  a1[56] = (unint64_t)v136 >> 3;
  a1[57] = (unint64_t)v136 >> 11;
  uint64_t v137 = (v125 & 0x1FFFFF) + (v136 >> 21);
  a1[58] = (v136 >> 19) & 3 | (4 * v137);
  a1[59] = (unint64_t)v137 >> 6;
  unint64_t v138 = (v126 & 0x1FFFFF) + (v137 >> 21);
  a1[60] = (v137 >> 14) & 0x7F | ((_BYTE)v138 << 7);
  a1[61] = v138 >> 1;
  a1[62] = v138 >> 9;
  a1[63] = v138 >> 17;
  return 1;
}

BOOL ED25519_verify(const void *a1, size_t a2, unsigned __int8 *a3, const void *a4)
{
  uint64_t v60 = *MEMORY[0x263EF8340];
  if (a3[63] > 0x1Fu) {
    return 0;
  }
  memset(v32, 0, sizeof(v32));
  if (x25519_ge_frombytes_vartime((uint64_t)v32, (uint64_t)a4)) {
    return 0;
  }
  for (uint64_t i = 0; i != 40; i += 4)
    *(_DWORD *)((char *)v32 + i) = -*(_DWORD *)((char *)v32 + i);
  for (uint64_t j = 120; j != 160; j += 4)
    *(_DWORD *)((char *)v32 + j) = -*(_DWORD *)((char *)v32 + j);
  long long v10 = *((_OWORD *)a3 + 1);
  v41[0] = *(_OWORD *)a3;
  v41[1] = v10;
  long long v11 = *((_OWORD *)a3 + 2);
  long long v40 = *((_OWORD *)a3 + 3);
  long long v39 = v11;
  unsigned int v12 = HIBYTE(v40);
  if (HIBYTE(v40) > 0x10u) {
    return 0;
  }
  unsigned int v13 = 16;
  uint64_t v14 = 0x1Eu;
  while (v12 >= v13)
  {
    if (v14 != -1)
    {
      unsigned int v12 = *((unsigned __int8 *)&v39 + v14);
      unsigned int v13 = order[v14--];
      if (v12 <= v13) {
        continue;
      }
    }
    return 0;
  }
  memset(&c, 0, sizeof(c));
  SHA512_Init(&c);
  SHA512_Update(&c, a3, 0x20uLL);
  SHA512_Update(&c, a4, 0x20uLL);
  SHA512_Update(&c, a1, a2);
  SHA512_Final((unsigned __int8 *)md, &c);
  x25519_sc_reduce(md);
  uint64_t v30 = 0;
  memset(v29, 0, sizeof(v29));
  memset(v37, 0, sizeof(v37));
  memset(v36, 0, sizeof(v36));
  memset(v35, 0, sizeof(v35));
  memset(v34, 0, sizeof(v34));
  memset(v33, 0, sizeof(v33));
  slide((uint64_t)v51, (uint64_t)md);
  slide((uint64_t)v50, (uint64_t)&v39);
  x25519_ge_p3_to_cached((uint64_t)v42, (uint64_t)v32);
  uint64_t v59 = 0;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v52 = 0u;
  ge_p3_to_p2((uint64_t)&v52, v32);
  ge_p2_dbl(v36, (int *)&v52);
  x25519_ge_p1p1_to_p3(v33, (int *)v36);
  x25519_ge_add((int *)v36, (uint64_t)v33, v42);
  x25519_ge_p1p1_to_p3(v34, (int *)v36);
  x25519_ge_p3_to_cached((uint64_t)v43, (uint64_t)v34);
  x25519_ge_add((int *)v36, (uint64_t)v33, v43);
  x25519_ge_p1p1_to_p3(v34, (int *)v36);
  x25519_ge_p3_to_cached((uint64_t)v44, (uint64_t)v34);
  x25519_ge_add((int *)v36, (uint64_t)v33, v44);
  x25519_ge_p1p1_to_p3(v34, (int *)v36);
  x25519_ge_p3_to_cached((uint64_t)v45, (uint64_t)v34);
  x25519_ge_add((int *)v36, (uint64_t)v33, v45);
  x25519_ge_p1p1_to_p3(v34, (int *)v36);
  x25519_ge_p3_to_cached((uint64_t)v46, (uint64_t)v34);
  x25519_ge_add((int *)v36, (uint64_t)v33, v46);
  x25519_ge_p1p1_to_p3(v34, (int *)v36);
  x25519_ge_p3_to_cached((uint64_t)v47, (uint64_t)v34);
  x25519_ge_add((int *)v36, (uint64_t)v33, v47);
  x25519_ge_p1p1_to_p3(v34, (int *)v36);
  x25519_ge_p3_to_cached((uint64_t)v48, (uint64_t)v34);
  x25519_ge_add((int *)v36, (uint64_t)v33, v48);
  x25519_ge_p1p1_to_p3(v34, (int *)v36);
  x25519_ge_p3_to_cached((uint64_t)&v49, (uint64_t)v34);
  ge_p2_0((uint64_t)v29);
  unsigned int v16 = 255;
  while (1)
  {
    uint64_t v17 = v16;
    if (v51[v16] || v50[v16]) {
      break;
    }
    --v16;
    if (!v17) {
      goto LABEL_42;
    }
  }
  if ((v16 & 0x80000000) == 0)
  {
    do
    {
      ge_p2_dbl(v36, (int *)v29);
      unint64_t v18 = v51[v17];
      if ((char)v51[v17] < 1)
      {
        if ((v18 & 0x80) != 0)
        {
          x25519_ge_p1p1_to_p3(v34, (int *)v36);
          x25519_ge_sub((int *)v36, (uint64_t)v34, &v42[40 * (-(char)v18 >> 1)]);
        }
      }
      else
      {
        x25519_ge_p1p1_to_p3(v34, (int *)v36);
        x25519_ge_add((int *)v36, (uint64_t)v34, &v42[40 * (v18 >> 1)]);
      }
      int v19 = (char)v50[v17];
      if (v19 < 1)
      {
        if (v19 < 0)
        {
          x25519_ge_p1p1_to_p3(v34, (int *)v36);
          for (uint64_t k = 0; k != 40; k += 4)
            *(_DWORD *)((char *)v36 + k) = *(_DWORD *)((char *)v34 + k) + *(_DWORD *)((char *)&v34[2] + k + 8);
          for (uint64_t m = 0; m != 40; m += 4)
            *(_DWORD *)((char *)&v36[2] + m + 8) = *(_DWORD *)((char *)&v34[2] + m + 8) - *(_DWORD *)((char *)v34 + m);
          *(void *)&long long v54 = 0;
          unint64_t v22 = &Bi[30 * (-(char)v19 >> 1)];
          long long v52 = 0u;
          long long v53 = 0u;
          fe_mul(v37, (int *)v36, v22 + 10);
          fe_mul((_DWORD *)&v36[2] + 2, (int *)&v36[2] + 2, v22);
          fe_mul((_DWORD *)&v37[2] + 2, v22 + 20, (int *)&v35[2] + 2);
          for (uint64_t n = 0; n != 40; n += 4)
            *(_DWORD *)((char *)&v52 + n) = 2 * *(_DWORD *)((char *)v35 + n);
          for (iuint64_t i = 0; ii != 40; ii += 4)
            *(_DWORD *)((char *)v36 + ii) = *(_DWORD *)((char *)v37 + ii) - *(_DWORD *)((char *)&v36[2] + ii + 8);
          for (juint64_t j = 0; jj != 40; jj += 4)
            *(_DWORD *)((char *)&v36[2] + jj + 8) += *(_DWORD *)((char *)v37 + jj);
          for (kuint64_t k = 0; kk != 40; kk += 4)
            *(_DWORD *)((char *)v37 + kk) = *(_DWORD *)((char *)&v52 + kk) - *(_DWORD *)((char *)&v37[2] + kk + 8);
          for (muint64_t m = 0; mm != 40; mm += 4)
            *(_DWORD *)((char *)&v37[2] + mm + 8) += *(_DWORD *)((char *)&v52 + mm);
        }
      }
      else
      {
        x25519_ge_p1p1_to_p3(v34, (int *)v36);
        ge_madd((int *)v36, (uint64_t)v34, &Bi[30 * (v19 >> 1)]);
      }
      x25519_ge_p1p1_to_p2(v29, (int *)v36);
    }
    while (v17-- > 0);
  }
LABEL_42:
  x25519_ge_tobytes((uint64_t)v42, (int *)v29);
  return timingsafe_memcmp((unsigned __int8 *)v42, (unsigned __int8 *)v41, 32) == 0;
}

uint64_t x25519_scalar_mult_generic(uint64_t a1, long long *a2, unsigned int *a3)
{
  uint64_t v69 = *MEMORY[0x263EF8340];
  uint64_t v68 = 0;
  long long v66 = 0u;
  long long v67 = 0u;
  uint64_t v53 = 0;
  memset(v52, 0, sizeof(v52));
  uint64_t v51 = 0;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v3 = a2[1];
  long long v47 = *a2;
  long long v48 = v3;
  LOBYTE(v47) = v47 & 0xF8;
  HIBYTE(v48) = HIBYTE(v3) & 0x3F | 0x40;
  fe_frombytes(&v66, a3);
  int v4 = 0;
  long long v64 = 0u;
  long long v63 = 0u;
  int v65 = 0;
  int v62 = 1;
  memset(v60, 0, sizeof(v60));
  uint64_t v61 = 0;
  v58[0] = v66;
  v58[1] = v67;
  unsigned int v5 = 254;
  uint64_t v59 = v68;
  long long v55 = 0u;
  long long v56 = 0u;
  int v54 = 1;
  int v57 = 0;
  do
  {
    uint64_t v6 = 0;
    unsigned int v7 = v5;
    int v8 = v4;
    int v4 = (*((unsigned __int8 *)&v47 + ((unint64_t)v5 >> 3)) >> (v5 & 7)) & 1;
    int v9 = -(v4 ^ v8);
    do
    {
      int v10 = *(int *)((char *)&v62 + v6);
      int v11 = *(_DWORD *)((char *)v58 + v6);
      int v12 = (v11 ^ v10) & v9;
      *(int *)((char *)&v62 + v6) = v12 ^ v10;
      *(_DWORD *)((char *)v58 + v6) = v12 ^ v11;
      v6 += 4;
    }
    while (v6 != 40);
    for (uint64_t i = 0; i != 40; i += 4)
    {
      int v14 = *(_DWORD *)((char *)v60 + i);
      int v15 = *(int *)((char *)&v54 + i);
      int v16 = (v15 ^ v14) & v9;
      *(_DWORD *)((char *)v60 + i) = v16 ^ v14;
      *(int *)((char *)&v54 + i) = v16 ^ v15;
    }
    for (uint64_t j = 0; j != 40; j += 4)
      *(_DWORD *)((char *)v52 + j) = *(_DWORD *)((char *)v58 + j) - *(int *)((char *)&v54 + j);
    for (uint64_t k = 0; k != 40; k += 4)
      *(_DWORD *)((char *)&v49 + k) = *(int *)((char *)&v62 + k) - *(_DWORD *)((char *)v60 + k);
    for (uint64_t m = 0; m != 40; m += 4)
      *(int *)((char *)&v62 + m) += *(_DWORD *)((char *)v60 + m);
    for (uint64_t n = 0; n != 40; n += 4)
      *(_DWORD *)((char *)v60 + n) = *(int *)((char *)&v54 + n) + *(_DWORD *)((char *)v58 + n);
    fe_mul(&v54, (int *)v52, &v62);
    fe_mul(v60, (int *)v60, (int *)&v49);
    fe_sq(v52, (int *)&v49);
    fe_sq(&v49, &v62);
    for (iuint64_t i = 0; ii != 40; ii += 4)
      *(_DWORD *)((char *)v58 + ii) = *(_DWORD *)((char *)v60 + ii) + *(int *)((char *)&v54 + ii);
    for (juint64_t j = 0; jj != 40; jj += 4)
      *(_DWORD *)((char *)v60 + jj) = *(int *)((char *)&v54 + jj) - *(_DWORD *)((char *)v60 + jj);
    fe_mul(&v62, (int *)&v49, (int *)v52);
    for (kuint64_t k = 0; kk != 40; kk += 4)
      *(_DWORD *)((char *)&v49 + kk) -= *(_DWORD *)((char *)v52 + kk);
    fe_sq(v60, (int *)v60);
    uint64_t v24 = 121666 * SDWORD1(v49) + 0x1000000;
    uint64_t v25 = 121666 * SDWORD2(v49) + (v24 >> 25);
    uint64_t v26 = 121666 * SHIDWORD(v51) + 0x1000000;
    uint64_t v27 = 121666 * SHIDWORD(v49) + 0x1000000;
    uint64_t v28 = 121666 * (int)v50 + (v27 >> 25);
    uint64_t v29 = 121666 * SDWORD1(v50) + 0x1000000;
    uint64_t v30 = 121666 * SDWORD2(v50) + (v29 >> 25);
    int v31 = 121666 * DWORD1(v50) - (v29 & 0xFE000000);
    uint64_t v32 = 121666 * SHIDWORD(v50) + 0x1000000;
    uint64_t v33 = 121666 * (int)v51 + (v32 >> 25);
    uint64_t v34 = 121666 * (int)v49 + 19 * (int)(v26 >> 25);
    int v54 = v34 - ((v34 + 0x2000000) & 0xFC000000);
    LODWORD(v55) = 121666 * DWORD1(v49) - (v24 & 0xFE000000) + ((unint64_t)(v34 + 0x2000000) >> 26);
    DWORD1(v55) = v25 - ((v25 + 0x2000000) & 0xFC000000);
    DWORD2(v55) = 121666 * HIDWORD(v49) - (v27 & 0xFE000000) + ((unint64_t)(v25 + 0x2000000) >> 26);
    HIDWORD(v55) = v28 - ((v28 + 0x2000000) & 0xFC000000);
    LODWORD(v56) = v31 + ((unint64_t)(v28 + 0x2000000) >> 26);
    DWORD1(v56) = v30 - ((v30 + 0x2000000) & 0xFC000000);
    DWORD2(v56) = 121666 * HIDWORD(v50) - (v32 & 0xFE000000) + ((unint64_t)(v30 + 0x2000000) >> 26);
    HIDWORD(v56) = v33 - ((v33 + 0x2000000) & 0xFC000000);
    int v57 = 121666 * HIDWORD(v51) - (v26 & 0xFE000000) + ((unint64_t)(v33 + 0x2000000) >> 26);
    fe_sq(v58, (int *)v58);
    for (muint64_t m = 0; mm != 40; mm += 4)
      *(_DWORD *)((char *)v52 + mm) += *(int *)((char *)&v54 + mm);
    fe_mul(&v54, (int *)&v66, (int *)v60);
    fe_mul(v60, (int *)&v49, (int *)v52);
    unsigned int v5 = v7 - 1;
  }
  while (v7);
  uint64_t v36 = 0;
  int v37 = -v4;
  do
  {
    int v38 = *(int *)((char *)&v62 + v36);
    int v39 = *(_DWORD *)((char *)v58 + v36);
    int v40 = (v39 ^ v38) & v37;
    *(int *)((char *)&v62 + v36) = v40 ^ v38;
    *(_DWORD *)((char *)v58 + v36) = v40 ^ v39;
    v36 += 4;
  }
  while (v36 != 40);
  for (nuint64_t n = 0; nn != 40; nn += 4)
  {
    int v42 = *(_DWORD *)((char *)v60 + nn);
    int v43 = *(int *)((char *)&v54 + nn);
    int v44 = (v43 ^ v42) & v37;
    *(_DWORD *)((char *)v60 + nn) = v44 ^ v42;
    *(int *)((char *)&v54 + nn) = v44 ^ v43;
  }
  fe_invert(v60, (int *)v60);
  fe_mul(&v62, &v62, (int *)v60);
  return fe_tobytes(a1, &v62);
}

uint64_t X25519_public_from_private(uint64_t a1, uint64_t a2)
{
  return x25519_scalar_mult(a1, a2, &X25519_public_from_private_kMongomeryBasePoint);
}

uint64_t X25519_keypair(uint64_t a1, unsigned char *__buf)
{
  arc4random_buf(__buf, 0x20uLL);
  *__buf |= 7u;
  __buf[31] = __buf[31] & 0x3F | 0x80;
  return x25519_scalar_mult(a1, __buf, &X25519_public_from_private_kMongomeryBasePoint);
}

BOOL X25519(unsigned __int8 *a1, uint64_t a2, uint64_t a3)
{
  return timingsafe_memcmp(X25519_kZeros, a1, 32) != 0;
}

uint64_t slide(uint64_t result, uint64_t a2)
{
  for (uint64_t i = 0; i != 256; ++i)
    *(unsigned char *)(result + i) = (*(unsigned __int8 *)(a2 + (i >> 3)) >> (i & 7)) & 1;
  unint64_t v3 = 0;
  uint64_t v4 = result + 1;
  uint64_t v5 = 1;
  do
  {
    if (*(unsigned char *)(result + v3) && v3 <= 0xFE)
    {
      unint64_t v6 = v3;
      unint64_t v7 = 1;
      uint64_t v8 = v5;
      do
      {
        int v9 = *(char *)(result + v8);
        if (*(unsigned char *)(result + v8))
        {
          int v10 = *(char *)(result + v3);
          int v11 = v9 << v7;
          int v12 = (v9 << v7) + v10;
          if (v12 > 15)
          {
            int v13 = v10 - v11;
            if (v13 < -15) {
              break;
            }
            *(unsigned char *)(result + v3) = v13;
            unint64_t v14 = v6;
            while (*(unsigned char *)(v4 + v14))
            {
              *(unsigned char *)(v4 + v14++) = 0;
              if (v14 >= 0xFF) {
                goto LABEL_16;
              }
            }
            *(unsigned char *)(v4 + v14) = 1;
          }
          else
          {
            *(unsigned char *)(result + v3) = v12;
            *(unsigned char *)(result + v8) = 0;
          }
        }
LABEL_16:
        if (v7 > 5) {
          break;
        }
        ++v7;
        ++v8;
        ++v6;
      }
      while (v7 + v3 < 0x100);
    }
    ++v3;
    ++v5;
  }
  while (v3 != 256);
  return result;
}

int RAND_set_rand_method(const RAND_METHOD *meth)
{
  return 1;
}

const RAND_METHOD *RAND_get_rand_method(void)
{
  return 0;
}

RAND_METHOD *RAND_SSLeay(void)
{
  return 0;
}

int RAND_set_rand_engine(ENGINE *engine)
{
  return 1;
}

int RAND_status(void)
{
  return 1;
}

int RAND_poll(void)
{
  return 1;
}

int RAND_bytes(unsigned __int8 *buf, int num)
{
  if (num >= 1) {
    arc4random_buf(buf, num);
  }
  return 1;
}

int RAND_pseudo_bytes(unsigned __int8 *buf, int num)
{
  if (num >= 1) {
    arc4random_buf(buf, num);
  }
  return 1;
}

STACK *i2v_POLICY_CONSTRAINTS(uint64_t a1, ASN1_INTEGER **a2, STACK *a3)
{
  extlist = a3;
  if (a3)
  {
    uint64_t v4 = 0;
  }
  else
  {
    uint64_t result = sk_new_null();
    uint64_t v4 = result;
    extlist = result;
    if (!result) {
      return result;
    }
  }
  if (X509V3_add_value_int("Require Explicit Policy", *a2, &extlist)
    && X509V3_add_value_int("Inhibit Policy Mapping", a2[1], &extlist))
  {
    return extlist;
  }
  sk_pop_free(v4, (void (__cdecl *)(void *))X509V3_conf_free);
  return 0;
}

ASN1_VALUE *v2i_POLICY_CONSTRAINTS(uint64_t a1, uint64_t a2, const STACK *a3)
{
  uint64_t v4 = ASN1_item_new(&POLICY_CONSTRAINTS_it);
  if (!v4)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_pcons.c", 169);
    return v4;
  }
  if (sk_num(a3) >= 1)
  {
    for (int i = 0; i < sk_num(a3); ++i)
    {
      unint64_t v6 = sk_value(a3, i);
      unint64_t v7 = (const char *)*((void *)v6 + 1);
      if (!strcmp(v7, "requireExplicitPolicy"))
      {
        uint64_t v8 = (CONF_VALUE *)v6;
        int v9 = (ASN1_INTEGER **)v4;
      }
      else
      {
        if (strcmp(v7, "inhibitPolicyMapping"))
        {
          ERR_put_error(34, 4095, 106, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_pcons.c", 181);
          ERR_asprintf_error_data("section:%s,name:%s,value:%s", *(const char **)v6, *((const char **)v6 + 1), *((const char **)v6 + 2));
LABEL_15:
          ASN1_item_free(v4, &POLICY_CONSTRAINTS_it);
          return 0;
        }
        uint64_t v8 = (CONF_VALUE *)v6;
        int v9 = (ASN1_INTEGER **)((char *)v4 + 8);
      }
      if (!X509V3_get_value_int(v8, v9)) {
        goto LABEL_15;
      }
    }
  }
  if (!*((void *)v4 + 1) && !*(void *)v4)
  {
    ERR_put_error(34, 4095, 151, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_pcons.c", 187);
    goto LABEL_15;
  }
  return v4;
}

POLICY_CONSTRAINTS *POLICY_CONSTRAINTS_new(void)
{
  return (POLICY_CONSTRAINTS *)ASN1_item_new(&POLICY_CONSTRAINTS_it);
}

void POLICY_CONSTRAINTS_free(POLICY_CONSTRAINTS *a)
{
}

ASN1_VALUE *__cdecl ASN1_item_new(const ASN1_ITEM *it)
{
  pval = 0;
  if (asn1_item_ex_new(&pval, (ASN1_ITEM *)it)) {
    return pval;
  }
  else {
    return 0;
  }
}

uint64_t asn1_item_ex_new(ASN1_VALUE **pval, ASN1_ITEM *it)
{
  funcunsigned int s = it->funcs;
  if (funcs) {
    uint64_t v5 = (uint64_t (*)(uint64_t, ASN1_VALUE **, ASN1_ITEM *, void))funcs[3];
  }
  else {
    uint64_t v5 = 0;
  }
  ASN1_VALUE *pval = 0;
  uint64_t v6 = 1;
  switch(it->itype)
  {
    case 0:
      templateunsigned int s = it->templates;
      if (!templates) {
        goto LABEL_18;
      }
      if (!ASN1_template_new(pval, templates)) {
        goto LABEL_30;
      }
      return v6;
    case 1:
    case 6:
      if (!v5) {
        goto LABEL_35;
      }
      int v7 = v5(0, pval, it, 0);
      if (!v7) {
        goto LABEL_26;
      }
      if (v7 != 2)
      {
LABEL_35:
        uint64_t v8 = (ASN1_VALUE *)malloc_type_calloc(1uLL, it->size, 0x31C8A62EuLL);
        ASN1_VALUE *pval = v8;
        if (!v8) {
          goto LABEL_30;
        }
        asn1_do_lock(pval, 0, it);
        asn1_enc_init(pval, it);
        if (it->tcount >= 1)
        {
          uint64_t v9 = 0;
          int v10 = it->templates;
          do
          {
            field_uint64_t ptr = asn1_get_field_ptr(pval, v10);
            if (!ASN1_template_new(field_ptr, v10)) {
              goto LABEL_30;
            }
            ++v10;
            ++v9;
          }
          while (it->tcount > v9);
        }
        uint64_t v6 = 1;
        if (v5) {
          goto LABEL_25;
        }
      }
      return v6;
    case 2:
      if (!v5) {
        goto LABEL_23;
      }
      int v13 = v5(0, pval, it, 0);
      if (!v13) {
        goto LABEL_26;
      }
      if (v13 != 2)
      {
LABEL_23:
        unint64_t v14 = (ASN1_VALUE *)malloc_type_calloc(1uLL, it->size, 0x1D76C7DAuLL);
        ASN1_VALUE *pval = v14;
        if (!v14) {
          goto LABEL_30;
        }
        asn1_set_choice_selector(pval, -1, it);
        if (v5)
        {
LABEL_25:
          if (!v5(1, pval, it, 0))
          {
LABEL_26:
            ERR_put_error(13, 4095, 100, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_new.c", 176);
            ASN1_item_ex_free(pval, it);
            return 0;
          }
        }
      }
      return v6;
    case 4:
      int v15 = it->funcs;
      if (v15)
      {
        int v16 = (unsigned int (*)(ASN1_VALUE **, ASN1_ITEM *))v15[1];
        if (v16)
        {
          if (!v16(pval, it)) {
            goto LABEL_30;
          }
        }
      }
      return v6;
    case 5:
LABEL_18:
      if (!ASN1_primitive_new(pval, it))
      {
LABEL_30:
        ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_new.c", 172);
        return 0;
      }
      return v6;
    default:
      return v6;
  }
}

int ASN1_template_new(ASN1_VALUE **pval, const ASN1_TEMPLATE *tt)
{
  unint64_t v2 = tt;
  flagunsigned int s = tt->flags;
  if (tt->flags)
  {
    while ((v2->flags & 0x306) == 0)
    {
      iteuint64_t m = (uint64_t)v2->item;
      if (*(unsigned char *)item)
      {
        switch(*(unsigned char *)item)
        {
          case 1:
          case 2:
          case 6:
            goto LABEL_11;
          case 4:
            uint64_t v9 = *(void *)(item + 32);
            if (!v9) {
              goto LABEL_11;
            }
            int v10 = *(void (**)(ASN1_VALUE **))(v9 + 24);
            if (!v10) {
              goto LABEL_11;
            }
            v10(pval);
            break;
          case 5:
            goto LABEL_13;
          default:
            return 1;
        }
        return 1;
      }
      unint64_t v2 = *(const ASN1_TEMPLATE **)(item + 16);
      if (!v2)
      {
LABEL_13:
        asn1_primitive_clear(pval, item);
        return 1;
      }
    }
    goto LABEL_11;
  }
  if ((flags & 0x300) != 0)
  {
LABEL_11:
    ASN1_VALUE *pval = 0;
    return 1;
  }
  if ((flags & 6) != 0)
  {
    uint64_t v5 = sk_new_null();
    if (v5)
    {
      ASN1_VALUE *pval = (ASN1_VALUE *)v5;
      return 1;
    }
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_new.c", 236);
    return 0;
  }
  else
  {
    uint64_t v8 = tt->item;
    return asn1_item_ex_new(pval, v8);
  }
}

int ASN1_primitive_new(ASN1_VALUE **pval, const ASN1_ITEM *it)
{
  if (!it)
  {
    int v7 = (ASN1_VALUE *)ASN1_STRING_type_new(-1);
LABEL_8:
    ASN1_VALUE *pval = v7;
    return v7 != 0;
  }
  funcunsigned int s = it->funcs;
  if (!funcs)
  {
    if (it->itype == 5)
    {
      uint type = -1;
LABEL_11:
      int v7 = (ASN1_VALUE *)ASN1_STRING_type_new(utype);
      if (it->itype == 5 && v7) {
        *((void *)v7 + 2) |= 0x40uLL;
      }
      goto LABEL_8;
    }
    uint type = it->utype;
    if (utype > 4)
    {
      if (utype == 5)
      {
        int result = 1;
        ASN1_VALUE *pval = (ASN1_VALUE *)1;
        return result;
      }
      if (utype != 6) {
        goto LABEL_11;
      }
      ASN1_VALUE *pval = (ASN1_VALUE *)OBJ_nid2obj(0);
    }
    else
    {
      if (utype == -4)
      {
        int v7 = (ASN1_VALUE *)malloc_type_malloc(0x10uLL, 0x1032040EB7D8BF6uLL);
        if (v7)
        {
          *((void *)v7 + 1) = 0;
          *(_DWORD *)int v7 = -1;
        }
        goto LABEL_8;
      }
      if (utype != 1) {
        goto LABEL_11;
      }
      *(_DWORD *)pval = it->size;
    }
    return 1;
  }
  uint64_t v5 = (uint64_t (*)(void))*((void *)funcs + 2);
  if (!v5) {
    return 0;
  }
  return v5();
}

_DWORD *asn1_primitive_clear(_DWORD *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(void *)(a2 + 32);
    if (v2)
    {
      unint64_t v3 = *(uint64_t (**)(void))(v2 + 32);
      if (v3) {
        return (_DWORD *)v3();
      }
    }
    else if (*(unsigned char *)a2 != 5 && *(_DWORD *)(a2 + 8) == 1)
    {
      *int result = *(void *)(a2 + 40);
      return result;
    }
  }
  *(void *)int result = 0;
  return result;
}

X509 *__cdecl d2i_X509_bio(BIO *bp, X509 **x509)
{
  return (X509 *)ASN1_item_d2i_bio(&X509_it, bp, x509);
}

int i2d_X509_bio(BIO *bp, X509 *x509)
{
  return ASN1_item_i2d_bio(&X509_it, bp, x509);
}

X509 *__cdecl d2i_X509_fp(FILE *fp, X509 **x509)
{
  return (X509 *)ASN1_item_d2i_fp(&X509_it, fp, x509);
}

int i2d_X509_fp(FILE *fp, X509 *x509)
{
  return ASN1_item_i2d_fp(&X509_it, fp, x509);
}

X509_CRL *__cdecl d2i_X509_CRL_bio(BIO *bp, X509_CRL **crl)
{
  return (X509_CRL *)ASN1_item_d2i_bio(&X509_CRL_it, bp, crl);
}

int i2d_X509_CRL_bio(BIO *bp, X509_CRL *crl)
{
  return ASN1_item_i2d_bio(&X509_CRL_it, bp, crl);
}

X509_CRL *__cdecl d2i_X509_CRL_fp(FILE *fp, X509_CRL **crl)
{
  return (X509_CRL *)ASN1_item_d2i_fp(&X509_CRL_it, fp, crl);
}

int i2d_X509_CRL_fp(FILE *fp, X509_CRL *crl)
{
  return ASN1_item_i2d_fp(&X509_CRL_it, fp, crl);
}

X509_REQ *__cdecl d2i_X509_REQ_bio(BIO *bp, X509_REQ **req)
{
  return (X509_REQ *)ASN1_item_d2i_bio(&X509_REQ_it, bp, req);
}

int i2d_X509_REQ_bio(BIO *bp, X509_REQ *req)
{
  return ASN1_item_i2d_bio(&X509_REQ_it, bp, req);
}

X509_REQ *__cdecl d2i_X509_REQ_fp(FILE *fp, X509_REQ **req)
{
  return (X509_REQ *)ASN1_item_d2i_fp(&X509_REQ_it, fp, req);
}

int i2d_X509_REQ_fp(FILE *fp, X509_REQ *req)
{
  return ASN1_item_i2d_fp(&X509_REQ_it, fp, req);
}

RSA *__cdecl d2i_RSAPrivateKey_bio(BIO *bp, RSA **rsa)
{
  return (RSA *)ASN1_item_d2i_bio(&RSAPrivateKey_it, bp, rsa);
}

int i2d_RSAPrivateKey_bio(BIO *bp, RSA *rsa)
{
  return ASN1_item_i2d_bio(&RSAPrivateKey_it, bp, rsa);
}

RSA *__cdecl d2i_RSAPrivateKey_fp(FILE *fp, RSA **rsa)
{
  return (RSA *)ASN1_item_d2i_fp(&RSAPrivateKey_it, fp, rsa);
}

int i2d_RSAPrivateKey_fp(FILE *fp, RSA *rsa)
{
  return ASN1_item_i2d_fp(&RSAPrivateKey_it, fp, rsa);
}

RSA *__cdecl d2i_RSAPublicKey_bio(BIO *bp, RSA **rsa)
{
  return (RSA *)ASN1_item_d2i_bio(&RSAPublicKey_it, bp, rsa);
}

int i2d_RSAPublicKey_bio(BIO *bp, RSA *rsa)
{
  return ASN1_item_i2d_bio(&RSAPublicKey_it, bp, rsa);
}

RSA *__cdecl d2i_RSAPublicKey_fp(FILE *fp, RSA **rsa)
{
  return (RSA *)ASN1_item_d2i_fp(&RSAPublicKey_it, fp, rsa);
}

int i2d_RSAPublicKey_fp(FILE *fp, RSA *rsa)
{
  return ASN1_item_i2d_fp(&RSAPublicKey_it, fp, rsa);
}

DSA *__cdecl d2i_DSAPrivateKey_bio(BIO *bp, DSA **dsa)
{
  return (DSA *)ASN1_item_d2i_bio(&DSAPrivateKey_it, bp, dsa);
}

int i2d_DSAPrivateKey_bio(BIO *bp, DSA *dsa)
{
  return ASN1_item_i2d_bio(&DSAPrivateKey_it, bp, dsa);
}

DSA *__cdecl d2i_DSAPrivateKey_fp(FILE *fp, DSA **dsa)
{
  return (DSA *)ASN1_item_d2i_fp(&DSAPrivateKey_it, fp, dsa);
}

int i2d_DSAPrivateKey_fp(FILE *fp, DSA *dsa)
{
  return ASN1_item_i2d_fp(&DSAPrivateKey_it, fp, dsa);
}

EC_KEY *__cdecl d2i_ECPrivateKey_bio(BIO *bp, EC_KEY **eckey)
{
  return (EC_KEY *)ASN1_d2i_bio((void *(*)(void))EC_KEY_new, (d2i_of_void *)d2i_ECPrivateKey, bp, (void **)eckey);
}

int i2d_ECPrivateKey_bio(BIO *bp, EC_KEY *eckey)
{
  return ASN1_i2d_bio((i2d_of_void *)i2d_ECPrivateKey, bp, (unsigned __int8 *)eckey);
}

EC_KEY *__cdecl d2i_ECPrivateKey_fp(FILE *fp, EC_KEY **eckey)
{
  return (EC_KEY *)ASN1_d2i_fp((void *(*)(void))EC_KEY_new, (d2i_of_void *)d2i_ECPrivateKey, fp, (void **)eckey);
}

int i2d_ECPrivateKey_fp(FILE *fp, EC_KEY *eckey)
{
  return ASN1_i2d_fp((i2d_of_void *)i2d_ECPrivateKey, fp, eckey);
}

X509_SIG *__cdecl d2i_PKCS8_bio(BIO *bp, X509_SIG **p8)
{
  return (X509_SIG *)ASN1_item_d2i_bio(&X509_SIG_it, bp, p8);
}

int i2d_PKCS8_bio(BIO *bp, X509_SIG *p8)
{
  return ASN1_item_i2d_bio(&X509_SIG_it, bp, p8);
}

X509_SIG *__cdecl d2i_PKCS8_fp(FILE *fp, X509_SIG **p8)
{
  return (X509_SIG *)ASN1_item_d2i_fp(&X509_SIG_it, fp, p8);
}

int i2d_PKCS8_fp(FILE *fp, X509_SIG *p8)
{
  return ASN1_item_i2d_fp(&X509_SIG_it, fp, p8);
}

PKCS8_PRIV_KEY_INFO *__cdecl d2i_PKCS8_PRIV_KEY_INFO_bio(BIO *bp, PKCS8_PRIV_KEY_INFO **p8inf)
{
  return (PKCS8_PRIV_KEY_INFO *)ASN1_item_d2i_bio(&PKCS8_PRIV_KEY_INFO_it, bp, p8inf);
}

int i2d_PKCS8_PRIV_KEY_INFO_bio(BIO *bp, PKCS8_PRIV_KEY_INFO *p8inf)
{
  return ASN1_item_i2d_bio(&PKCS8_PRIV_KEY_INFO_it, bp, p8inf);
}

PKCS8_PRIV_KEY_INFO *__cdecl d2i_PKCS8_PRIV_KEY_INFO_fp(FILE *fp, PKCS8_PRIV_KEY_INFO **p8inf)
{
  return (PKCS8_PRIV_KEY_INFO *)ASN1_item_d2i_fp(&PKCS8_PRIV_KEY_INFO_it, fp, p8inf);
}

int i2d_PKCS8_PRIV_KEY_INFO_fp(FILE *fp, PKCS8_PRIV_KEY_INFO *p8inf)
{
  return ASN1_item_i2d_fp(&PKCS8_PRIV_KEY_INFO_it, fp, p8inf);
}

EVP_PKEY *__cdecl d2i_PrivateKey_bio(BIO *bp, EVP_PKEY **a)
{
  return (EVP_PKEY *)ASN1_d2i_bio((void *(*)(void))EVP_PKEY_new, (d2i_of_void *)d2i_AutoPrivateKey, bp, (void **)a);
}

int i2d_PrivateKey_bio(BIO *bp, EVP_PKEY *pkey)
{
  return ASN1_i2d_bio((i2d_of_void *)i2d_PrivateKey, bp, (unsigned __int8 *)pkey);
}

EVP_PKEY *__cdecl d2i_PrivateKey_fp(FILE *fp, EVP_PKEY **a)
{
  return (EVP_PKEY *)ASN1_d2i_fp((void *(*)(void))EVP_PKEY_new, (d2i_of_void *)d2i_AutoPrivateKey, fp, (void **)a);
}

int i2d_PrivateKey_fp(FILE *fp, EVP_PKEY *pkey)
{
  return ASN1_i2d_fp((i2d_of_void *)i2d_PrivateKey, fp, pkey);
}

int i2d_PKCS8PrivateKeyInfo_bio(BIO *bp, EVP_PKEY *key)
{
  unint64_t v3 = EVP_PKEY2PKCS8(key);
  if (v3)
  {
    uint64_t v4 = v3;
    int v5 = ASN1_item_i2d_bio(&PKCS8_PRIV_KEY_INFO_it, bp, v3);
    PKCS8_PRIV_KEY_INFO_free(v4);
    LODWORD(v3) = v5;
  }
  return (int)v3;
}

int i2d_PKCS8PrivateKeyInfo_fp(FILE *fp, EVP_PKEY *key)
{
  unint64_t v3 = EVP_PKEY2PKCS8(key);
  if (v3)
  {
    uint64_t v4 = v3;
    int v5 = ASN1_item_i2d_fp(&PKCS8_PRIV_KEY_INFO_it, fp, v3);
    PKCS8_PRIV_KEY_INFO_free(v4);
    LODWORD(v3) = v5;
  }
  return (int)v3;
}

int X509_verify(X509 *a, EVP_PKEY *r)
{
  if (X509_ALGOR_cmp((uint64_t)a->sig_alg, (uint64_t)a->cert_info->signature)) {
    return 0;
  }
  sig_alg = a->sig_alg;
  signature = a->signature;
  cert_info = a->cert_info;
  return ASN1_item_verify(&X509_CINF_it, sig_alg, signature, cert_info, r);
}

int X509_REQ_verify(X509_REQ *a, EVP_PKEY *r)
{
  return ASN1_item_verify(&X509_REQ_INFO_it, a->sig_alg, a->signature, a->req_info, r);
}

int NETSCAPE_SPKI_verify(NETSCAPE_SPKI *a, EVP_PKEY *r)
{
  return ASN1_item_verify(&NETSCAPE_SPKAC_it, a->sig_algor, a->signature, a->spkac, r);
}

int X509_sign(X509 *x, EVP_PKEY *pkey, const EVP_MD *md)
{
  cert_info = x->cert_info;
  sig_alg = x->sig_alg;
  cert_info->enc.modifiechar d = 1;
  return ASN1_item_sign(&X509_CINF_it, cert_info->signature, sig_alg, x->signature, cert_info, pkey, md);
}

uint64_t X509_sign_ctx(uint64_t *a1, EVP_MD_CTX *ctx)
{
  uint64_t v3 = *a1;
  uint64_t v2 = (X509_ALGOR *)a1[1];
  *(_DWORD *)(v3 + 96) = 1;
  return ASN1_item_sign_ctx(&X509_CINF_it, *(X509_ALGOR **)(v3 + 16), v2, (ASN1_STRING *)a1[2], (ASN1_VALUE *)v3, ctx);
}

int X509_REQ_sign(X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *md)
{
  return ASN1_item_sign(&X509_REQ_INFO_it, x->sig_alg, 0, x->signature, x->req_info, pkey, md);
}

uint64_t X509_REQ_sign_ctx(uint64_t a1, EVP_MD_CTX *ctx)
{
  return ASN1_item_sign_ctx(&X509_REQ_INFO_it, *(X509_ALGOR **)(a1 + 8), 0, *(ASN1_STRING **)(a1 + 16), *(ASN1_VALUE **)a1, ctx);
}

int X509_CRL_sign(X509_CRL *x, EVP_PKEY *pkey, const EVP_MD *md)
{
  crl = x->crl;
  sig_alg = x->sig_alg;
  crl->enc.modifiechar d = 1;
  return ASN1_item_sign(&X509_CRL_INFO_it, crl->sig_alg, sig_alg, x->signature, crl, pkey, md);
}

uint64_t X509_CRL_sign_ctx(uint64_t *a1, EVP_MD_CTX *ctx)
{
  uint64_t v3 = *a1;
  uint64_t v2 = (X509_ALGOR *)a1[1];
  *(_DWORD *)(v3 + 72) = 1;
  return ASN1_item_sign_ctx(&X509_CRL_INFO_it, *(X509_ALGOR **)(v3 + 8), v2, (ASN1_STRING *)a1[2], (ASN1_VALUE *)v3, ctx);
}

int NETSCAPE_SPKI_sign(NETSCAPE_SPKI *x, EVP_PKEY *pkey, const EVP_MD *md)
{
  return ASN1_item_sign(&NETSCAPE_SPKAC_it, x->sig_algor, 0, x->signature, x->spkac, pkey, md);
}

int X509_pubkey_digest(const X509 *data, const EVP_MD *type, unsigned __int8 *md, unsigned int *len)
{
  int v7 = X509_get0_pubkey_bitstr(data);
  if (v7)
  {
    size_t length = v7->length;
    uint64_t v9 = v7->data;
    LODWORD(v7) = EVP_Digest(v9, length, md, len, type, 0);
  }
  return (int)v7;
}

int X509_digest(const X509 *data, const EVP_MD *type, unsigned __int8 *md, unsigned int *len)
{
  return ASN1_item_digest(&X509_it, type, (void *)data, md, len);
}

int X509_CRL_digest(const X509_CRL *data, const EVP_MD *type, unsigned __int8 *md, unsigned int *len)
{
  return ASN1_item_digest(&X509_CRL_it, type, (void *)data, md, len);
}

int X509_REQ_digest(const X509_REQ *data, const EVP_MD *type, unsigned __int8 *md, unsigned int *len)
{
  return ASN1_item_digest(&X509_REQ_it, type, (void *)data, md, len);
}

int X509_NAME_digest(const X509_NAME *data, const EVP_MD *type, unsigned __int8 *md, unsigned int *len)
{
  return ASN1_item_digest(&X509_NAME_it, type, (void *)data, md, len);
}

BOOL X509_up_ref(uint64_t a1)
{
  return CRYPTO_add_lock((int *)(a1 + 28), 1, 3, 0, 0) > 1;
}

int EC_GROUP_check(const EC_GROUP *group, BN_CTX *ctx)
{
  uint64_t v4 = ctx;
  if (!ctx)
  {
    uint64_t v4 = BN_CTX_new();
    if (!v4) {
      goto LABEL_16;
    }
  }
  BN_CTX_start(v4);
  int v5 = BN_CTX_get(v4);
  if (!v5) {
    goto LABEL_16;
  }
  uint64_t v6 = v5;
  if (!EC_GROUP_check_discriminant(group, v4))
  {
    int v11 = 118;
    int v12 = 79;
LABEL_15:
    ERR_put_error(16, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_check.c", v12);
LABEL_16:
    uint64_t v8 = 0;
    goto LABEL_17;
  }
  int v7 = (const EC_POINT *)*((void *)group + 1);
  if (!v7)
  {
    int v11 = 113;
    int v12 = 84;
    goto LABEL_15;
  }
  if (EC_POINT_is_on_curve(group, v7, v4) <= 0)
  {
    int v11 = 107;
    int v12 = 88;
    goto LABEL_15;
  }
  uint64_t v8 = EC_POINT_new(group);
  if (!v8 || !EC_GROUP_get_order(group, v6, v4)) {
    goto LABEL_17;
  }
  if (BN_is_zero((uint64_t)v6))
  {
    int v9 = 128;
    int v10 = 97;
LABEL_11:
    ERR_put_error(16, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_check.c", v10);
LABEL_17:
    int v13 = 0;
    goto LABEL_18;
  }
  if (!EC_POINT_mul(group, v8, v6, 0, 0, v4)) {
    goto LABEL_17;
  }
  if (EC_POINT_is_at_infinity(group, v8) <= 0)
  {
    int v9 = 122;
    int v10 = 103;
    goto LABEL_11;
  }
  int v13 = 1;
LABEL_18:
  BN_CTX_end(v4);
  if (v4 != ctx) {
    BN_CTX_free(v4);
  }
  EC_POINT_free(v8);
  return v13;
}

uint64_t SM3_Update(unint64_t a1, char *__src, size_t __n)
{
  if (__n)
  {
    size_t v3 = __n;
    uint64_t v4 = __src;
    *(void *)(a1 + 32) += 8 * __n;
    uint64_t v6 = *(unsigned int *)(a1 + 104);
    if (v6)
    {
      int v7 = (_OWORD *)(a1 + 40);
      uint64_t v8 = (void *)(a1 + 40 + v6);
      if (__n <= 0x3F && v6 + __n < 0x40)
      {
        memcpy(v8, __src, __n);
        *(_DWORD *)(a1 + 104) += v3;
        return 1;
      }
      uint64_t v9 = 64 - v6;
      memcpy(v8, __src, 64 - v6);
      SM3_block_data_order(a1, a1 + 40, 1);
      v4 += v9;
      v3 -= v9;
      *(_DWORD *)(a1 + 104) = 0;
      *int v7 = 0u;
      *(_OWORD *)(a1 + 56) = 0u;
      *(_OWORD *)(a1 + 72) = 0u;
      *(_OWORD *)(a1 + 88) = 0u;
    }
    if (v3 >= 0x40)
    {
      SM3_block_data_order(a1, (uint64_t)v4, v3 >> 6);
      v4 += v3 & 0xFFFFFFFFFFFFFFC0;
      v3 &= 0x3Fu;
    }
    if (v3)
    {
      *(_DWORD *)(a1 + 104) = v3;
      memcpy((void *)(a1 + 40), v4, v3);
    }
  }
  return 1;
}

unint64_t SM3_block_data_order(unint64_t result, uint64_t a2, uint64_t a3)
{
  v1072 = (int *)result;
  if (a3)
  {
    int v3 = *(_DWORD *)result;
    int v4 = *(_DWORD *)(result + 4);
    int v6 = *(_DWORD *)(result + 8);
    int v5 = *(_DWORD *)(result + 12);
    int v8 = *(_DWORD *)(result + 16);
    int v7 = *(_DWORD *)(result + 20);
    int v10 = *(_DWORD *)(result + 24);
    int v9 = *(_DWORD *)(result + 28);
    do
    {
      unsigned int v1097 = v8;
      int v1098 = v6;
      int v1099 = v4;
      int v1100 = v3;
      uint64_t v1088 = a3;
      unsigned int v11 = _byteswap_ulong(*(_DWORD *)(a2 + 12));
      unsigned int v12 = _byteswap_ulong(*(_DWORD *)(a2 + 16));
      unsigned int v13 = _byteswap_ulong(*(_DWORD *)(a2 + 20));
      unsigned int v14 = _byteswap_ulong(*(_DWORD *)(a2 + 24));
      unsigned int v15 = _byteswap_ulong(*(_DWORD *)(a2 + 28));
      unsigned int v16 = _byteswap_ulong(*(_DWORD *)(a2 + 32));
      unsigned int v17 = _byteswap_ulong(*(_DWORD *)(a2 + 36));
      unsigned int v18 = _byteswap_ulong(*(_DWORD *)(a2 + 40));
      unsigned int v1091 = *(unsigned __int8 *)(a2 + 52);
      unsigned int v1094 = *(unsigned __int8 *)(a2 + 56);
      unsigned int v1074 = _byteswap_ulong(*(_DWORD *)(a2 + 48));
      unsigned int v19 = (v1091 << 24) | (*(unsigned __int8 *)(a2 + 53) << 16) | (bswap32(*(unsigned __int16 *)(a2 + 54)) >> 16);
      unsigned int v1089 = *(unsigned __int8 *)(a2 + 60);
      unsigned int v1077 = (v1094 << 24) | (*(unsigned __int8 *)(a2 + 57) << 16) | (bswap32(*(unsigned __int16 *)(a2 + 58)) >> 16);
      unsigned int v1076 = (v1089 << 24) | (*(unsigned __int8 *)(a2 + 61) << 16) | (bswap32(*(unsigned __int16 *)(a2 + 62)) >> 16);
      HIDWORD(v20) = v3;
      LODWORD(v20) = v3;
      HIDWORD(v20) = (v20 >> 20) + v8 + 2043430169;
      LODWORD(v20) = HIDWORD(v20);
      int v21 = v20 >> 25;
      int v1086 = v9;
      int v1087 = v5;
      int v22 = (v4 ^ v3 ^ v6) + v5 + (v21 ^ __ROR4__(v3, 20));
      int v1085 = v10;
      int v23 = v9 + (v7 ^ v8 ^ v10) + v21;
      unsigned int v24 = bswap32(*(_DWORD *)a2);
      unsigned int v25 = v22 + (v12 ^ v24);
      int v26 = v23 + v24;
      HIDWORD(v20) = v23 + v24;
      LODWORD(v20) = v23 + v24;
      int v27 = v20 >> 15;
      unint64_t v28 = __PAIR64__(v19, __ROR4__(v26, 23));
      unsigned int v29 = v27 ^ v28 ^ v26;
      LODWORD(v28) = (v1091 << 24) | (*(unsigned __int8 *)(a2 + 53) << 16);
      int v30 = (v28 >> 17) ^ v15 ^ v24;
      unint64_t v31 = __PAIR64__(v25, __ROR4__(v30, 17));
      int v32 = ((*(unsigned __int8 *)(a2 + 12) >> 1) | (v11 << 7)) ^ __ROR4__(v30, 9) ^ v31 ^ v30 ^ v18;
      LODWORD(v31) = v25;
      unsigned int v33 = v29 - 208106958 + (v31 >> 20);
      unsigned int v34 = bswap32(*(_DWORD *)(a2 + 4));
      unint64_t v35 = __PAIR64__(v33, __ROR4__(v1099, 23));
      int v36 = (v1100 ^ v35 ^ v25) + v1098 + (v13 ^ v34);
      LODWORD(v35) = v33;
      int v37 = v35 >> 25;
      unsigned int v38 = v36 + (v37 ^ __ROR4__(v25, 20));
      int v1084 = v7;
      unint64_t v39 = __PAIR64__(v1077, __ROR4__(v7, 13));
      unsigned int v40 = v34 + v10 + (v1097 ^ v39 ^ v29) + v37;
      LODWORD(v39) = (v1094 << 24) | (*(unsigned __int8 *)(a2 + 57) << 16);
      int v41 = (v39 >> 17) ^ v16 ^ v34;
      unint64_t v43 = __PAIR64__(v40, __ROR4__(v41, 17));
      int v42 = ((*(unsigned __int8 *)(a2 + 16) >> 1) | (v12 << 7)) ^ __ROR4__(v41, 9) ^ v43;
      LODWORD(v43) = v40;
      int v44 = v43 >> 15;
      unint64_t v45 = __PAIR64__(v1099, __ROR4__(v40, 23));
      unsigned int v46 = v44 ^ v45 ^ v40;
      unsigned int v47 = _byteswap_ulong(*(_DWORD *)(a2 + 44));
      int v48 = v42 ^ v41 ^ v47;
      unsigned int v49 = bswap32(*(_DWORD *)(a2 + 8));
      LODWORD(v45) = v1099;
      int v50 = (v14 ^ v49) + (v45 >> 23);
      unint64_t v51 = __PAIR64__(v38, __ROR4__(v1100, 23));
      int v52 = v25 ^ v51 ^ v38;
      LODWORD(v51) = v38;
      int v53 = v50 + v52;
      HIDWORD(v51) = (v51 >> 20) - 416213915 + v46;
      LODWORD(v51) = HIDWORD(v51);
      int v54 = v51 >> 25;
      unint64_t v55 = __PAIR64__(v7, __ROR4__(v38, 20));
      unsigned int v56 = v53 + (v54 ^ v55);
      LODWORD(v55) = v7;
      int v57 = v49 + (v55 >> 13);
      unint64_t v58 = __PAIR64__(v1076, __ROR4__(v1097, 13));
      unsigned int v59 = v57 + (v29 ^ v58 ^ v46) + v54;
      LODWORD(v58) = (v1089 << 24) | (*(unsigned __int8 *)(a2 + 61) << 16);
      int v60 = (v58 >> 17) ^ v17 ^ v49;
      unint64_t v61 = __PAIR64__(v1100, __ROR4__(v60, 17));
      unsigned int v62 = ((*(unsigned __int8 *)(a2 + 20) >> 1) | (v13 << 7)) ^ __ROR4__(v60, 9) ^ v61 ^ v60 ^ v1074;
      LODWORD(v61) = v1100;
      int v63 = (v15 ^ v11) + (v61 >> 23);
      unint64_t v64 = __PAIR64__(v59, __ROR4__(v25, 23));
      int v65 = v63 + (v38 ^ v64 ^ v56);
      LODWORD(v64) = v59;
      int v66 = v64 >> 15;
      unint64_t v67 = __PAIR64__(v56, __ROR4__(v59, 23));
      unsigned int v68 = v66 ^ v67 ^ v59;
      LODWORD(v67) = v56;
      HIDWORD(v67) = (v67 >> 20) - 832427829 + v68;
      LODWORD(v67) = HIDWORD(v67);
      int v69 = v67 >> 25;
      unsigned int v70 = v65 + (v69 ^ __ROR4__(v56, 20));
      unint64_t v71 = __PAIR64__(v1097, __ROR4__(v29, 13));
      int v72 = v46 ^ v71 ^ v68;
      LODWORD(v71) = v1097;
      int v73 = v11 + (v71 >> 13) + v72 + v69;
      int v74 = v32;
      int v1073 = v32;
      int v75 = v18 ^ v11 ^ __ROR4__(v32, 17);
      unint64_t v76 = __PAIR64__(v25, __ROR4__(v75, 17));
      int v77 = ((*(unsigned __int8 *)(a2 + 24) >> 1) | (v14 << 7)) ^ __ROR4__(v75, 9) ^ v76 ^ v18 ^ v11;
      LODWORD(v76) = v25;
      int v78 = (v16 ^ v12) + (v76 >> 23);
      HIDWORD(v76) = v73;
      LODWORD(v76) = v73;
      unsigned int v79 = (v76 >> 15) ^ __ROR4__(v73, 23) ^ v73;
      unint64_t v80 = __PAIR64__(v29, __ROR4__(v38, 23));
      int v81 = v78 + (v56 ^ v80 ^ v70);
      LODWORD(v80) = v29;
      int v82 = v12 + (v80 >> 13) + (v68 ^ __ROR4__(v46, 13) ^ v79);
      int v83 = v47 ^ v12 ^ __ROR4__(v48, 17);
      int v1075 = v48;
      unint64_t v85 = __PAIR64__(v70, __ROR4__(v83, 17));
      int v84 = ((*(unsigned __int8 *)(a2 + 28) >> 1) | (v15 << 7)) ^ __ROR4__(v83, 9) ^ v85;
      LODWORD(v85) = v70;
      HIDWORD(v85) = (v85 >> 20) - 1664855657 + v79;
      LODWORD(v85) = HIDWORD(v85);
      int v86 = v85 >> 25;
      unsigned int v87 = v82 + v86;
      unint64_t v88 = __PAIR64__(v38, __ROR4__(v70, 20));
      unsigned int v89 = v81 + (v86 ^ v88);
      int v90 = v84 ^ v47 ^ v12;
      LODWORD(v88) = v38;
      int v91 = (v17 ^ v13) + (v88 >> 23);
      unint64_t v92 = __PAIR64__(v87, __ROR4__(v56, 23));
      int v93 = v91 + (v70 ^ v92 ^ v89);
      LODWORD(v92) = v87;
      int v94 = v92 >> 15;
      unint64_t v95 = __PAIR64__(v89, __ROR4__(v87, 23));
      unsigned int v96 = v94 ^ v95 ^ v87;
      LODWORD(v95) = v89;
      HIDWORD(v95) = (v95 >> 20) + 965255983 + v96;
      LODWORD(v95) = HIDWORD(v95);
      int v97 = v95 >> 25;
      unint64_t v98 = __PAIR64__(v46, __ROR4__(v89, 20));
      unsigned int v99 = v93 + (v97 ^ v98);
      LODWORD(v98) = v46;
      int v100 = (v98 >> 13) + v13 + (v79 ^ __ROR4__(v68, 13) ^ v96) + v97;
      int v101 = v1074 ^ v13 ^ __ROR4__(v62, 17);
      unint64_t v102 = __PAIR64__(v56, __ROR4__(v101, 17));
      int v103 = ((*(unsigned __int8 *)(a2 + 32) >> 1) | (v16 << 7)) ^ __ROR4__(v101, 9) ^ v102 ^ v1074 ^ v13;
      LODWORD(v102) = v56;
      int v104 = (v18 ^ v14) + (v102 >> 23);
      HIDWORD(v102) = v100;
      LODWORD(v102) = v100;
      unsigned int v105 = (v102 >> 15) ^ __ROR4__(v100, 23) ^ v100;
      unint64_t v106 = __PAIR64__(v68, __ROR4__(v70, 23));
      int v107 = v104 + (v89 ^ v106 ^ v99);
      LODWORD(v106) = v68;
      int v108 = v106 >> 13;
      unint64_t v109 = __PAIR64__(v99, __ROR4__(v79, 13));
      int v110 = v108 + v14 + (v96 ^ v109 ^ v105);
      LODWORD(v109) = v99;
      HIDWORD(v109) = (v109 >> 20) + 1930511966 + v105;
      LODWORD(v109) = HIDWORD(v109);
      int v111 = v109 >> 25;
      unsigned int v112 = v110 + v111;
      unsigned int v113 = v107 + (v111 ^ __ROR4__(v99, 20));
      int v1078 = v77 ^ __ROR4__(v74, 17) ^ v19;
      int v114 = v19 ^ v14 ^ __ROR4__(v1078, 17);
      unint64_t v116 = __PAIR64__(v112, __ROR4__(v114, 17));
      int v115 = ((*(unsigned __int8 *)(a2 + 36) >> 1) | (v17 << 7)) ^ __ROR4__(v114, 9) ^ v116;
      LODWORD(v116) = v112;
      int v117 = v116 >> 15;
      unint64_t v118 = __PAIR64__(v70, __ROR4__(v112, 23));
      unsigned int v119 = v117 ^ v118 ^ v112;
      int v120 = v115 ^ v19 ^ v14;
      LODWORD(v118) = v70;
      int v121 = (v47 ^ v15) + (v118 >> 23);
      unint64_t v122 = __PAIR64__(v79, __ROR4__(v89, 23));
      int v123 = v121 + (v99 ^ v122 ^ v113);
      LODWORD(v122) = v79;
      int v124 = v122 >> 13;
      unint64_t v125 = __PAIR64__(v113, __ROR4__(v96, 13));
      int v126 = v124 + v15 + (v105 ^ v125 ^ v119);
      LODWORD(v125) = v113;
      HIDWORD(v125) = (v125 >> 20) - 433943364 + v119;
      LODWORD(v125) = HIDWORD(v125);
      int v127 = v125 >> 25;
      unsigned int v128 = v126 + v127;
      unint64_t v130 = __PAIR64__(v128, __ROR4__(v113, 20));
      int v129 = v127 ^ v130;
      LODWORD(v130) = v128;
      unsigned int v131 = v123 + v129;
      unsigned int v132 = (v130 >> 15) ^ __ROR4__(v128, 23) ^ v128;
      int v1081 = v90 ^ __ROR4__(v48, 17) ^ v1077;
      int v133 = v1077 ^ v15 ^ __ROR4__(v1081, 17);
      unint64_t v135 = __PAIR64__(v89, __ROR4__(v133, 9));
      int v134 = ((*(unsigned __int8 *)(a2 + 40) >> 1) | (v18 << 7)) ^ v135;
      LODWORD(v135) = v89;
      int v136 = v135 >> 23;
      unint64_t v137 = __PAIR64__(v131, __ROR4__(v133, 17));
      int v138 = v134 ^ v137 ^ v1077 ^ v15;
      int v139 = (v1074 ^ v16) + v136;
      LODWORD(v137) = v131;
      unsigned int v140 = (v137 >> 20) - 867886727 + v132;
      unint64_t v141 = __PAIR64__(v140, __ROR4__(v99, 23));
      int v142 = v113 ^ v141 ^ v131;
      LODWORD(v141) = v140;
      int v143 = v141 >> 25;
      unint64_t v144 = __PAIR64__(v96, __ROR4__(v131, 20));
      unsigned int v145 = v139 + v142 + (v143 ^ v144);
      LODWORD(v144) = v96;
      int v146 = (v144 >> 13) + v16 + (v119 ^ __ROR4__(v105, 13) ^ v132);
      unint64_t v148 = __PAIR64__(v99, __ROR4__(v62, 17));
      int v147 = v103 ^ v148;
      LODWORD(v148) = v99;
      int v149 = v148 >> 23;
      HIDWORD(v148) = v146 + v143;
      LODWORD(v148) = v146 + v143;
      int v150 = (v148 >> 15) ^ __ROR4__(v146 + v143, 23) ^ (v146 + v143);
      unint64_t v152 = __PAIR64__(v105, __ROR4__(v147 ^ v1076, 17));
      int v151 = v1076 ^ v16 ^ v152;
      LODWORD(v152) = v105;
      int v153 = v152 >> 13;
      unint64_t v154 = __PAIR64__(v145, __ROR4__(v151, 17));
      int v155 = ((*(unsigned __int8 *)(a2 + 44) >> 1) | (v47 << 7)) ^ __ROR4__(v151, 9) ^ v154 ^ v1076 ^ v16;
      LODWORD(v154) = v145;
      unsigned int v156 = (v154 >> 20) - 1735773453 + v150;
      unint64_t v158 = __PAIR64__(v156, __ROR4__(v113, 23));
      int v157 = v131 ^ v158;
      LODWORD(v158) = v156;
      int v159 = v158 >> 25;
      int v160 = v149 + (v19 ^ v17) + (v157 ^ v145) + (v159 ^ __ROR4__(v145, 20));
      unint64_t v161 = __PAIR64__(v113, __ROR4__(v1078, 17));
      unsigned int v162 = v120 ^ v161 ^ v1073;
      LODWORD(v161) = v113;
      int v163 = v161 >> 23;
      HIDWORD(v161) = v153 + v17 + (v132 ^ __ROR4__(v119, 13) ^ v150) + v159;
      LODWORD(v161) = HIDWORD(v161);
      int v164 = v1073 ^ v17;
      unsigned int v165 = (v161 >> 15) ^ __ROR4__(HIDWORD(v161), 23) ^ HIDWORD(v161);
      LODWORD(v161) = __ROR4__(v162, 17);
      int v166 = v164 ^ v161;
      unint64_t v168 = __PAIR64__(v119, __ROR4__(v164 ^ v161, 9));
      int v167 = ((*(unsigned __int8 *)(a2 + 48) >> 1) | (v1074 << 7)) ^ v168;
      LODWORD(v168) = v119;
      int v169 = v168 >> 13;
      unint64_t v170 = __PAIR64__(v160, __ROR4__(v166, 17));
      int v171 = v167 ^ v170 ^ v164;
      LODWORD(v170) = v160;
      unsigned int v172 = (v170 >> 20) + 823420391 + v165;
      unint64_t v173 = __PAIR64__(v172, __ROR4__(v131, 23));
      int v174 = v145 ^ v173 ^ v160;
      LODWORD(v173) = v172;
      int v175 = v173 >> 25;
      int v176 = v163 + (v1077 ^ v18) + v174 + (v175 ^ __ROR4__(v160, 20));
      int v177 = v169 + v18 + (v150 ^ __ROR4__(v132, 13) ^ v165);
      int v178 = v138 ^ __ROR4__(v1081, 17);
      HIDWORD(v173) = v177 + v175;
      LODWORD(v173) = v177 + v175;
      int v179 = v178 ^ v48;
      unsigned int v180 = (v173 >> 15) ^ __ROR4__(HIDWORD(v173), 23) ^ HIDWORD(v173);
      int v181 = v48 ^ v18;
      int v182 = v181 ^ __ROR4__(v178 ^ v48, 17);
      unint64_t v183 = __PAIR64__(v131, __ROR4__(v147 ^ v1076, 17));
      unsigned int v184 = v62;
      unsigned int v185 = v155 ^ v183 ^ v62;
      LODWORD(v183) = v131;
      int v186 = v183 >> 23;
      unint64_t v188 = __PAIR64__(v132, __ROR4__(v178 ^ v48, 17));
      int v187 = ((v1091 >> 1) | (v19 << 7)) ^ __ROR4__(v182, 9) ^ __ROR4__(v182, 17) ^ v181 ^ v188;
      LODWORD(v188) = v132;
      int v189 = v188 >> 13;
      unint64_t v190 = __PAIR64__(v176, __ROR4__(v150, 13));
      int v191 = v189 + v47 + (v165 ^ v190 ^ v180);
      LODWORD(v190) = v176;
      int v192 = v171 ^ __ROR4__(v162, 17) ^ v1078;
      HIDWORD(v190) = (v190 >> 20) + 1646840782 + v180;
      LODWORD(v190) = HIDWORD(v190);
      int v193 = v190 >> 25;
      unsigned int v194 = v191 + v193;
      int v195 = v186 + (v1076 ^ v47) + (v160 ^ __ROR4__(v145, 23) ^ v176) + (v193 ^ __ROR4__(v176, 20));
      unint64_t v197 = __PAIR64__(v145, __ROR4__(v185, 17));
      int v196 = v62 ^ v47 ^ v197;
      LODWORD(v197) = v145;
      int v198 = v197 >> 23;
      unint64_t v200 = __PAIR64__(v194, __ROR4__(v196, 17));
      int v199 = ((v1094 >> 1) | (v1077 << 7)) ^ __ROR4__(v196, 9) ^ v200;
      LODWORD(v200) = v194;
      int v201 = v200 >> 15;
      HIDWORD(v200) = v150;
      LODWORD(v200) = v150;
      int v202 = v200 >> 13;
      int v203 = v187 ^ v1081;
      unint64_t v204 = __PAIR64__(v195, __ROR4__(v185, 17));
      unsigned int v1092 = v185;
      unsigned int v1095 = v199 ^ v62 ^ v47 ^ v204 ^ v147 ^ v1076;
      int v205 = v201 ^ __ROR4__(v194, 23) ^ v194;
      LODWORD(v204) = v195;
      int v206 = v204 >> 20;
      int v207 = v198 + (v1073 ^ v1074);
      HIDWORD(v204) = v160;
      LODWORD(v204) = v160;
      int v208 = v204 >> 23;
      HIDWORD(v204) = v206 - 1001285732 + v205;
      LODWORD(v204) = HIDWORD(v204);
      int v209 = v204 >> 25;
      int v210 = v207 + (v176 ^ __ROR4__(v160, 23) ^ v195);
      int v211 = v209 ^ __ROR4__(v195, 20);
      int v212 = v202 + v1074 + (v180 ^ __ROR4__(v165, 13) ^ v205) + v209;
      unint64_t v214 = __PAIR64__(v165, __ROR4__(v192, 17));
      int v213 = v1078 ^ v1074 ^ v214;
      LODWORD(v214) = v165;
      int v215 = v214 >> 13;
      unint64_t v217 = __PAIR64__(v176, __ROR4__(v213, 17));
      int v216 = ((v1089 >> 1) | (v1076 << 7)) ^ __ROR4__(v213, 9) ^ v217;
      LODWORD(v217) = v176;
      int v218 = v217 >> 23;
      unsigned int v219 = v210 + v211;
      HIDWORD(v217) = v212;
      LODWORD(v217) = v212;
      int v220 = (v217 >> 15) ^ __ROR4__(v212, 23);
      unint64_t v222 = __PAIR64__(v219, __ROR4__(v192, 17));
      int v221 = v216 ^ v1078 ^ v1074 ^ v222;
      int v223 = v220 ^ v212;
      LODWORD(v222) = v219;
      HIDWORD(v222) = (v222 >> 20) - 2002571463 + (v220 ^ v212);
      LODWORD(v222) = HIDWORD(v222);
      int v224 = v222 >> 25;
      int v225 = v215 + v19 + (v205 ^ __ROR4__(v180, 13) ^ v223) + v224;
      int v226 = v208 + (v48 ^ v19) + (v195 ^ __ROR4__(v176, 23) ^ v219) + (v224 ^ __ROR4__(v219, 20));
      HIDWORD(v222) = v225;
      LODWORD(v222) = v225;
      int v227 = v222 >> 15;
      unint64_t v229 = __PAIR64__(v180, __ROR4__(v203, 17));
      int v228 = v1081 ^ v19 ^ v229;
      LODWORD(v229) = v180;
      int v230 = v229 >> 13;
      HIDWORD(v229) = v1073;
      LODWORD(v229) = v1073;
      int v231 = (v229 >> 25) ^ __ROR4__(v228, 9);
      unint64_t v233 = __PAIR64__(v195, __ROR4__(v228, 17));
      int v232 = v231 ^ v233;
      LODWORD(v233) = v195;
      int v234 = v233 >> 23;
      int v235 = v221 ^ v162;
      unint64_t v236 = __PAIR64__(v226, __ROR4__(v203, 17));
      unsigned int v237 = v232 ^ v1081 ^ v19 ^ v236 ^ v178 ^ v48;
      int v238 = v227 ^ __ROR4__(v225, 23) ^ v225;
      LODWORD(v236) = v226;
      int v239 = v236 >> 20;
      HIDWORD(v236) = v205;
      LODWORD(v236) = v205;
      int v240 = v236 >> 13;
      HIDWORD(v236) = v239 + 289824371 + v238;
      LODWORD(v236) = HIDWORD(v236);
      int v241 = v236 >> 25;
      int v242 = v218 + (v62 ^ v1077) + (v219 ^ __ROR4__(v195, 23) ^ v226);
      int v243 = v230 + v1077 + (v223 ^ __ROR4__(v205, 13) ^ v238);
      unint64_t v245 = __PAIR64__(v219, __ROR4__(v226, 20));
      int v244 = v241 ^ v245;
      int v246 = v243 + v241;
      LODWORD(v245) = v219;
      int v247 = v245 >> 23;
      unint64_t v249 = __PAIR64__(v48, __ROR4__(v1095, 17));
      int v248 = v147 ^ v1076 ^ v1077 ^ v249;
      unsigned int v250 = v242 + v244;
      LODWORD(v249) = v48;
      int v251 = (v249 >> 25) ^ __ROR4__(v248, 9);
      unint64_t v253 = __PAIR64__(v223, __ROR4__(v248, 17));
      int v252 = v251 ^ v253;
      LODWORD(v253) = v223;
      int v254 = v253 >> 13;
      HIDWORD(v253) = v246;
      LODWORD(v253) = v246;
      int v255 = (v253 >> 15) ^ __ROR4__(v246, 23);
      unint64_t v257 = __PAIR64__(v250, __ROR4__(v1095, 17));
      int v256 = v252 ^ v147 ^ v1076 ^ v1077 ^ v257;
      int v258 = v255 ^ v246;
      int v259 = v234 + (v1078 ^ v1076);
      LODWORD(v257) = v250;
      HIDWORD(v257) = (v257 >> 20) + 579648742 + v258;
      LODWORD(v257) = HIDWORD(v257);
      int v260 = v257 >> 25;
      unsigned int v261 = v240 + v1076 + (v238 ^ __ROR4__(v223, 13) ^ v258) + v260;
      int v262 = v259 + (v226 ^ __ROR4__(v219, 23) ^ v250) + (v260 ^ __ROR4__(v250, 20));
      unint64_t v264 = __PAIR64__(v62, __ROR4__(v235, 17));
      int v263 = v162 ^ v1076 ^ v264;
      LODWORD(v264) = v184;
      int v265 = v264 >> 25;
      HIDWORD(v264) = v226;
      LODWORD(v264) = v226;
      int v266 = v264 >> 23;
      unint64_t v268 = __PAIR64__(v261, __ROR4__(v263, 17));
      int v267 = v265 ^ __ROR4__(v263, 9) ^ v268;
      LODWORD(v268) = v261;
      int v269 = v268 >> 15;
      HIDWORD(v268) = v238;
      LODWORD(v268) = v238;
      int v270 = v268 >> 13;
      int v271 = v256 ^ v1092;
      int v272 = v269 ^ __ROR4__(v261, 23);
      unint64_t v273 = __PAIR64__(v262, __ROR4__(v235, 17));
      unsigned int v274 = v267 ^ v162 ^ v1076 ^ v273 ^ v192;
      int v275 = v272 ^ v261;
      LODWORD(v273) = v262;
      HIDWORD(v273) = (v273 >> 20) - 1651869049 + (v272 ^ v261);
      LODWORD(v273) = HIDWORD(v273);
      int v276 = v273 >> 25;
      int v277 = v247 + (v1081 ^ v1073) + ((v262 | v250) & __ROR4__(v226, 23) | v262 & v250);
      unint64_t v279 = __PAIR64__(v250, __ROR4__(v262, 20));
      int v278 = v276 ^ v279;
      unsigned int v280 = v254 + v1073 + (v258 & v275 | v270 & ~v275) + v276;
      LODWORD(v279) = v250;
      int v281 = v279 >> 23;
      unsigned int v282 = v277 + v278;
      unint64_t v284 = __PAIR64__(v1078, __ROR4__(v237, 17));
      int v283 = v178 ^ v48 ^ v1073 ^ v284;
      LODWORD(v284) = v1078;
      int v285 = v284 >> 25;
      unint64_t v287 = __PAIR64__(v258, __ROR4__(v283, 9));
      int v286 = v285 ^ v287;
      LODWORD(v287) = v258;
      int v288 = v287 >> 13;
      unint64_t v290 = __PAIR64__(v280, __ROR4__(v283, 17));
      int v289 = v286 ^ v290;
      LODWORD(v290) = v280;
      int v291 = v289 ^ v178 ^ v48 ^ v1073;
      int v292 = (v290 >> 15) ^ __ROR4__(v280, 23) ^ v280;
      unint64_t v293 = __PAIR64__(v282, __ROR4__(v237, 17));
      unsigned int v294 = v291 ^ v293 ^ v203;
      LODWORD(v293) = v282;
      unsigned int v295 = (v293 >> 20) + 991229199 + v292;
      unint64_t v296 = __PAIR64__(v295, __ROR4__(v250, 23));
      int v297 = (v282 | v262) & v296 | v282 & v262;
      LODWORD(v296) = v295;
      int v298 = v296 >> 25;
      int v299 = v266 + (v147 ^ v1076 ^ v1075) + v297;
      unint64_t v301 = __PAIR64__(v275, __ROR4__(v282, 20));
      int v300 = v298 ^ v301;
      int v302 = v270 + v1075 + (v275 & v292 | v288 & ~v292);
      LODWORD(v301) = v275;
      int v303 = v301 >> 13;
      unsigned int v304 = v299 + v300;
      int v305 = v302 + v298;
      HIDWORD(v301) = v302 + v298;
      LODWORD(v301) = v302 + v298;
      int v306 = v301 >> 15;
      int v307 = v1092 ^ v1075 ^ __ROR4__(v271, 17);
      unint64_t v309 = __PAIR64__(v1081, __ROR4__(v305, 23));
      int v308 = v306 ^ v309;
      LODWORD(v309) = v1081;
      int v310 = (v309 >> 25) ^ __ROR4__(v307, 9) ^ __ROR4__(v307, 17) ^ v1092 ^ v1075;
      int v311 = v308 ^ v305;
      unint64_t v313 = __PAIR64__(v304, __ROR4__(v271, 17));
      int v312 = v310 ^ v313;
      LODWORD(v313) = v304;
      int v314 = (v313 >> 20) + 1982458398;
      HIDWORD(v313) = v262;
      LODWORD(v313) = v262;
      int v315 = v313 >> 23;
      int v316 = v281 + (v162 ^ v184) + ((v304 | v282) & __ROR4__(v262, 23) | v304 & v282);
      HIDWORD(v313) = v314 + v311;
      LODWORD(v313) = v314 + v311;
      int v317 = v313 >> 25;
      unsigned int v318 = v288 + v184 + (v292 & v311 | v303 & ~v311) + v317;
      int v319 = v316 + (v317 ^ __ROR4__(v304, 20));
      int v320 = v192 ^ v184;
      unsigned int v321 = v274;
      unsigned int v1083 = v274;
      unint64_t v323 = __PAIR64__(v147 ^ v1076, __ROR4__(v274, 17));
      int v322 = v192 ^ v184 ^ v323;
      LODWORD(v323) = v147 ^ v1076;
      int v324 = v323 >> 25;
      HIDWORD(v323) = v282;
      LODWORD(v323) = v282;
      int v325 = v323 >> 23;
      unint64_t v327 = __PAIR64__(v318, __ROR4__(v322, 17));
      int v326 = v324 ^ __ROR4__(v322, 9) ^ v327;
      LODWORD(v327) = v318;
      int v328 = v327 >> 15;
      HIDWORD(v327) = v292;
      LODWORD(v327) = v292;
      int v329 = v327 >> 13;
      int v330 = v312 ^ v1095;
      unint64_t v331 = __PAIR64__(v319, __ROR4__(v321, 17));
      unsigned int v332 = v326 ^ v320 ^ v331 ^ v235;
      int v333 = v328 ^ __ROR4__(v318, 23) ^ v318;
      LODWORD(v331) = v319;
      HIDWORD(v331) = (v331 >> 20) - 330050500 + v333;
      LODWORD(v331) = HIDWORD(v331);
      int v334 = v331 >> 25;
      int v335 = v315 + (v179 ^ v1078) + ((v319 | v304) & __ROR4__(v282, 23) | v319 & v304);
      unint64_t v337 = __PAIR64__(v304, __ROR4__(v319, 20));
      int v336 = v334 ^ v337;
      unsigned int v338 = v303 + v1078 + (v311 & v333 | v329 & ~v333) + v334;
      LODWORD(v337) = v304;
      int v339 = v337 >> 23;
      unsigned int v340 = v335 + v336;
      unsigned int v1080 = v294;
      unint64_t v342 = __PAIR64__(v162, __ROR4__(v294, 17));
      int v341 = v203 ^ v1078 ^ v342;
      LODWORD(v342) = v162;
      int v343 = v342 >> 25;
      unint64_t v345 = __PAIR64__(v311, __ROR4__(v341, 9));
      int v344 = v343 ^ v345;
      LODWORD(v345) = v311;
      int v346 = v345 >> 13;
      unint64_t v348 = __PAIR64__(v338, __ROR4__(v341, 17));
      int v347 = v344 ^ v348;
      LODWORD(v348) = v338;
      int v349 = (v348 >> 15) ^ __ROR4__(v338, 23) ^ v338;
      unint64_t v350 = __PAIR64__(v340, __ROR4__(v294, 17));
      unsigned int v351 = v347 ^ v203 ^ v1078 ^ v350 ^ v237;
      LODWORD(v350) = v340;
      unsigned int v352 = (v350 >> 20) - 660100999 + v349;
      unint64_t v353 = __PAIR64__(v352, __ROR4__(v304, 23));
      int v354 = (v340 | v319) & v353 | v340 & v319;
      LODWORD(v353) = v352;
      int v355 = v353 >> 25;
      unint64_t v357 = __PAIR64__(v333, __ROR4__(v340, 20));
      int v356 = v355 ^ v357;
      int v358 = v329 + v1081 + (v333 & v349 | v346 & ~v349);
      LODWORD(v357) = v333;
      int v359 = v357 >> 13;
      unsigned int v360 = v325 + (v1092 ^ v1081) + v354 + v356;
      int v361 = v358 + v355;
      HIDWORD(v357) = v358 + v355;
      LODWORD(v357) = v358 + v355;
      int v362 = v357 >> 15;
      int v363 = v1095 ^ v1081 ^ __ROR4__(v330, 17);
      unint64_t v365 = __PAIR64__(v179, __ROR4__(v361, 23));
      int v364 = v362 ^ v365;
      LODWORD(v365) = v179;
      int v366 = (v365 >> 25) ^ __ROR4__(v363, 9) ^ __ROR4__(v363, 17) ^ v1095 ^ v1081;
      int v367 = v364 ^ v361;
      unint64_t v369 = __PAIR64__(v360, __ROR4__(v330, 17));
      int v368 = v366 ^ v369;
      LODWORD(v369) = v360;
      int v370 = (v369 >> 20) - 1320201997;
      HIDWORD(v369) = v319;
      LODWORD(v369) = v319;
      int v371 = v369 >> 23;
      int v372 = v339 + (v192 ^ v147 ^ v1076) + ((v360 | v340) & __ROR4__(v319, 23) | v360 & v340);
      HIDWORD(v369) = v370 + v367;
      LODWORD(v369) = v370 + v367;
      int v373 = v369 >> 25;
      unsigned int v374 = v346 + (v147 ^ v1076) + (v349 & v367 | v359 & ~v367) + v373;
      int v375 = v372 + (v373 ^ __ROR4__(v360, 20));
      int v376 = v235 ^ v147 ^ v1076;
      unint64_t v378 = __PAIR64__(v1092, __ROR4__(v332, 17));
      int v377 = v376 ^ v378;
      LODWORD(v378) = v1092;
      int v379 = v378 >> 25;
      HIDWORD(v378) = v340;
      LODWORD(v378) = v340;
      int v380 = v378 >> 23;
      unint64_t v382 = __PAIR64__(v374, __ROR4__(v377, 17));
      int v381 = v379 ^ __ROR4__(v377, 9) ^ v382;
      LODWORD(v382) = v374;
      int v383 = v382 >> 15;
      HIDWORD(v382) = v349;
      LODWORD(v382) = v349;
      int v384 = v382 >> 13;
      int v385 = v368 ^ v271;
      int v386 = v383 ^ __ROR4__(v374, 23);
      unint64_t v387 = __PAIR64__(v375, __ROR4__(v332, 17));
      unsigned int v388 = v381 ^ v376 ^ v387 ^ v1083;
      int v389 = v386 ^ v374;
      LODWORD(v387) = v375;
      HIDWORD(v387) = (v387 >> 20) + 1654563303 + v389;
      LODWORD(v387) = HIDWORD(v387);
      int v390 = v387 >> 25;
      int v391 = v371 + (v203 ^ v162) + ((v375 | v360) & __ROR4__(v340, 23) | v375 & v360);
      unint64_t v393 = __PAIR64__(v360, __ROR4__(v375, 20));
      int v392 = v390 ^ v393;
      unsigned int v394 = v359 + v162 + (v367 & v389 | v384 & ~v389) + v390;
      LODWORD(v393) = v360;
      int v395 = v393 >> 23;
      int v396 = v237 ^ v162;
      unsigned int v397 = v391 + v392;
      unint64_t v399 = __PAIR64__(v192, __ROR4__(v351, 17));
      int v398 = v396 ^ v399;
      LODWORD(v399) = v192;
      int v400 = v399 >> 25;
      unint64_t v402 = __PAIR64__(v367, __ROR4__(v398, 9));
      int v401 = v400 ^ v402;
      LODWORD(v402) = v367;
      int v403 = v402 >> 13;
      unint64_t v405 = __PAIR64__(v394, __ROR4__(v398, 17));
      int v404 = v401 ^ v405;
      LODWORD(v405) = v394;
      int v406 = v404 ^ v396;
      int v407 = (v405 >> 15) ^ __ROR4__(v394, 23) ^ v394;
      unint64_t v408 = __PAIR64__(v397, __ROR4__(v351, 17));
      unsigned int v1090 = v406 ^ v408 ^ v1080;
      LODWORD(v408) = v397;
      unsigned int v409 = (v408 >> 20) - 985840690 + v407;
      unint64_t v410 = __PAIR64__(v409, __ROR4__(v360, 23));
      int v411 = (v397 | v375) & v410 | v397 & v375;
      LODWORD(v410) = v409;
      int v412 = v410 >> 25;
      int v413 = v380 + (v1095 ^ v179) + v411;
      unint64_t v415 = __PAIR64__(v389, __ROR4__(v397, 20));
      int v414 = v412 ^ v415;
      int v416 = v384 + v179 + (v389 & v407 | v403 & ~v407);
      LODWORD(v415) = v389;
      int v417 = v415 >> 13;
      unsigned int v418 = v413 + v414;
      int v419 = v416 + v412;
      HIDWORD(v415) = v416 + v412;
      LODWORD(v415) = v416 + v412;
      int v420 = v415 >> 15;
      int v421 = v271 ^ v179;
      int v422 = v421 ^ __ROR4__(v385, 17);
      unint64_t v424 = __PAIR64__(v203, __ROR4__(v419, 23));
      int v423 = v420 ^ v424;
      LODWORD(v424) = v203;
      int v425 = (v424 >> 25) ^ __ROR4__(v422, 9) ^ __ROR4__(v422, 17) ^ v421;
      int v426 = v423 ^ v419;
      unint64_t v428 = __PAIR64__(v418, __ROR4__(v385, 17));
      int v427 = v425 ^ v428;
      LODWORD(v428) = v418;
      int v429 = (v428 >> 20) - 1971681379;
      HIDWORD(v428) = v375;
      LODWORD(v428) = v375;
      int v430 = v428 >> 23;
      int v431 = v395 + (v235 ^ v1092) + ((v418 | v397) & __ROR4__(v375, 23) | v418 & v397);
      HIDWORD(v428) = v429 + v426;
      LODWORD(v428) = v429 + v426;
      int v432 = v428 >> 25;
      unsigned int v433 = v403 + v1092 + (v407 & v426 | v417 & ~v426) + v432;
      int v434 = v431 + (v432 ^ __ROR4__(v418, 20));
      unsigned int v1082 = v388;
      unint64_t v436 = __PAIR64__(v1095, __ROR4__(v388, 17));
      int v435 = v1083 ^ v1092 ^ v436;
      LODWORD(v436) = v1095;
      int v437 = v436 >> 25;
      HIDWORD(v436) = v397;
      LODWORD(v436) = v397;
      int v438 = v436 >> 23;
      unint64_t v440 = __PAIR64__(v433, __ROR4__(v435, 17));
      int v439 = v437 ^ __ROR4__(v435, 9) ^ v440;
      LODWORD(v440) = v433;
      int v441 = v440 >> 15;
      HIDWORD(v440) = v407;
      LODWORD(v440) = v407;
      int v442 = v440 >> 13;
      int v443 = v427 ^ v330;
      int v444 = v441 ^ __ROR4__(v433, 23);
      unint64_t v445 = __PAIR64__(v434, __ROR4__(v388, 17));
      unsigned int v446 = v439 ^ v1083 ^ v1092 ^ v445 ^ v332;
      int v447 = v444 ^ v433;
      LODWORD(v445) = v434;
      HIDWORD(v445) = (v445 >> 20) + 351604539 + v447;
      LODWORD(v445) = HIDWORD(v445);
      int v448 = v445 >> 25;
      int v449 = v430 + (v237 ^ v192) + ((v434 | v418) & __ROR4__(v397, 23) | v434 & v418);
      unint64_t v451 = __PAIR64__(v418, __ROR4__(v434, 20));
      int v450 = v448 ^ v451;
      unsigned int v452 = v417 + v192 + (v426 & v447 | v442 & ~v447) + v448;
      LODWORD(v451) = v418;
      int v453 = v451 >> 23;
      int v454 = v1080 ^ v192;
      unsigned int v455 = v449 + v450;
      unint64_t v457 = __PAIR64__(v235, __ROR4__(v1090, 17));
      int v456 = v454 ^ v457;
      LODWORD(v457) = v235;
      int v458 = v457 >> 25;
      unint64_t v460 = __PAIR64__(v426, __ROR4__(v456, 9));
      int v459 = v458 ^ v460;
      LODWORD(v460) = v426;
      int v461 = v460 >> 13;
      unint64_t v463 = __PAIR64__(v452, __ROR4__(v456, 17));
      int v462 = v459 ^ v463;
      LODWORD(v463) = v452;
      int v464 = (v463 >> 15) ^ __ROR4__(v452, 23) ^ v452;
      unint64_t v465 = __PAIR64__(v455, __ROR4__(v1090, 17));
      unsigned int v1093 = v462 ^ v454 ^ v465 ^ v351;
      LODWORD(v465) = v455;
      unsigned int v466 = (v465 >> 20) + 703209078 + v464;
      unint64_t v467 = __PAIR64__(v466, __ROR4__(v418, 23));
      int v468 = (v455 | v434) & v467 | v455 & v434;
      LODWORD(v467) = v466;
      int v469 = v467 >> 25;
      int v470 = v438 + (v271 ^ v203) + v468;
      unint64_t v472 = __PAIR64__(v447, __ROR4__(v455, 20));
      int v471 = v469 ^ v472;
      LODWORD(v472) = v447;
      int v473 = v472 >> 13;
      unsigned int v474 = v470 + v471;
      int v475 = v442 + v203 + (v447 & v464 | v461 & ~v464) + v469;
      HIDWORD(v472) = v475;
      LODWORD(v472) = v475;
      int v476 = v472 >> 15;
      int v477 = v330 ^ v203;
      int v478 = v477 ^ __ROR4__(v443, 17);
      unint64_t v480 = __PAIR64__(v237, __ROR4__(v475, 23));
      int v479 = v476 ^ v480;
      LODWORD(v480) = v237;
      int v481 = (v480 >> 25) ^ __ROR4__(v478, 9) ^ __ROR4__(v478, 17) ^ v477;
      int v482 = v479 ^ v475;
      unint64_t v484 = __PAIR64__(v474, __ROR4__(v443, 17));
      int v483 = v481 ^ v484;
      LODWORD(v484) = v474;
      int v485 = (v484 >> 20) + 1406418156;
      HIDWORD(v484) = v434;
      LODWORD(v484) = v434;
      int v486 = v484 >> 23;
      HIDWORD(v484) = v485 + v482;
      LODWORD(v484) = v485 + v482;
      int v487 = v484 >> 25;
      unsigned int v488 = v461 + v1095 + (v464 & v482 | v473 & ~v482) + v487;
      int v489 = v453 + (v1083 ^ v1095) + ((v474 | v455) & __ROR4__(v434, 23) | v474 & v455) + (v487 ^ __ROR4__(v474, 20));
      int v490 = v332 ^ v1095;
      unsigned int v491 = v332;
      unsigned int v492 = v446;
      unsigned int v1079 = v446;
      unint64_t v494 = __PAIR64__(v271, __ROR4__(v446, 17));
      int v493 = v490 ^ v494;
      LODWORD(v494) = v271;
      int v495 = v494 >> 25;
      HIDWORD(v494) = v455;
      LODWORD(v494) = v455;
      int v496 = v494 >> 23;
      unint64_t v498 = __PAIR64__(v488, __ROR4__(v493, 17));
      int v497 = v495 ^ __ROR4__(v493, 9) ^ v498;
      LODWORD(v498) = v488;
      int v499 = v498 >> 15;
      HIDWORD(v498) = v464;
      LODWORD(v498) = v464;
      int v500 = v498 >> 13;
      int v501 = v483 ^ v385;
      unint64_t v502 = __PAIR64__(v489, __ROR4__(v492, 17));
      unsigned int v503 = v497 ^ v490 ^ v502 ^ v1082;
      int v504 = v499 ^ __ROR4__(v488, 23) ^ v488;
      LODWORD(v502) = v489;
      HIDWORD(v502) = (v502 >> 20) - 1482130984 + v504;
      LODWORD(v502) = HIDWORD(v502);
      int v505 = v502 >> 25;
      int v506 = v486 + (v1080 ^ v235) + ((v489 | v474) & __ROR4__(v455, 23) | v489 & v474);
      unint64_t v508 = __PAIR64__(v474, __ROR4__(v489, 20));
      int v507 = v505 ^ v508;
      unsigned int v509 = v473 + v235 + (v482 & v504 | v500 & ~v504) + v505;
      LODWORD(v508) = v474;
      int v510 = v508 >> 23;
      int v511 = v351 ^ v235;
      unsigned int v512 = v506 + v507;
      unint64_t v514 = __PAIR64__(v1083, __ROR4__(v1093, 17));
      int v513 = v511 ^ v514;
      LODWORD(v514) = v1083;
      int v515 = v514 >> 25;
      unint64_t v517 = __PAIR64__(v482, __ROR4__(v513, 9));
      int v516 = v515 ^ v517;
      LODWORD(v517) = v482;
      int v518 = v517 >> 13;
      unint64_t v520 = __PAIR64__(v509, __ROR4__(v513, 17));
      int v519 = v516 ^ v520;
      LODWORD(v520) = v509;
      int v521 = v519 ^ v511;
      int v522 = (v520 >> 15) ^ __ROR4__(v509, 23) ^ v509;
      unint64_t v523 = __PAIR64__(v512, __ROR4__(v1093, 17));
      unsigned int v524 = v521 ^ v523 ^ v1090;
      LODWORD(v523) = v512;
      unsigned int v525 = (v523 >> 20) + 1330705329 + v522;
      unint64_t v526 = __PAIR64__(v525, __ROR4__(v474, 23));
      int v527 = (v512 | v489) & v526 | v512 & v489;
      LODWORD(v526) = v525;
      int v528 = v526 >> 25;
      unint64_t v530 = __PAIR64__(v504, __ROR4__(v512, 20));
      int v529 = v528 ^ v530;
      LODWORD(v530) = v504;
      int v531 = v530 >> 13;
      unsigned int v532 = v496 + (v330 ^ v237) + v527 + v529;
      int v533 = v500 + v237 + (v504 & v522 | v518 & ~v522) + v528;
      HIDWORD(v530) = v533;
      LODWORD(v530) = v533;
      int v534 = v530 >> 15;
      int v535 = v385 ^ v237 ^ __ROR4__(v501, 17);
      unint64_t v537 = __PAIR64__(v1080, __ROR4__(v533, 23));
      int v536 = v534 ^ v537;
      LODWORD(v537) = v1080;
      int v538 = (v537 >> 25) ^ __ROR4__(v535, 9) ^ __ROR4__(v535, 17) ^ v385 ^ v237;
      int v539 = v536 ^ v533;
      unint64_t v541 = __PAIR64__(v532, __ROR4__(v501, 17));
      int v540 = v538 ^ v541;
      LODWORD(v541) = v532;
      int v542 = (v541 >> 20) - 1633556638;
      HIDWORD(v541) = v489;
      LODWORD(v541) = v489;
      int v543 = v541 >> 23;
      int v544 = v510 + (v491 ^ v271) + ((v532 | v512) & __ROR4__(v489, 23) | v532 & v512);
      HIDWORD(v541) = v542 + v539;
      LODWORD(v541) = v542 + v539;
      int v545 = v541 >> 25;
      unsigned int v546 = v518 + v271 + (v522 & v539 | v531 & ~v539) + v545;
      int v547 = v544 + (v545 ^ __ROR4__(v532, 20));
      int v548 = v1082 ^ v271;
      unint64_t v550 = __PAIR64__(v330, __ROR4__(v503, 17));
      int v549 = v1082 ^ v271 ^ v550;
      LODWORD(v550) = v330;
      int v551 = v550 >> 25;
      HIDWORD(v550) = v512;
      LODWORD(v550) = v512;
      int v552 = v550 >> 23;
      unint64_t v554 = __PAIR64__(v546, __ROR4__(v549, 17));
      int v553 = v551 ^ __ROR4__(v549, 9) ^ v554;
      LODWORD(v554) = v546;
      int v555 = v554 >> 15;
      HIDWORD(v554) = v522;
      LODWORD(v554) = v522;
      int v556 = v554 >> 13;
      int v557 = v540 ^ v443;
      unint64_t v558 = __PAIR64__(v547, __ROR4__(v503, 17));
      unsigned int v1096 = v553 ^ v548 ^ v558 ^ v1079;
      int v559 = v555 ^ __ROR4__(v546, 23) ^ v546;
      LODWORD(v558) = v547;
      HIDWORD(v558) = (v558 >> 20) + 1027854021 + v559;
      LODWORD(v558) = HIDWORD(v558);
      int v560 = v558 >> 25;
      int v561 = v543 + (v351 ^ v1083) + ((v547 | v532) & __ROR4__(v512, 23) | v547 & v532);
      unint64_t v563 = __PAIR64__(v532, __ROR4__(v547, 20));
      int v562 = v560 ^ v563;
      unsigned int v564 = v531 + v1083 + (v539 & v559 | v556 & ~v559) + v560;
      LODWORD(v563) = v532;
      int v565 = v563 >> 23;
      unsigned int v566 = v561 + v562;
      unint64_t v568 = __PAIR64__(v491, __ROR4__(v524, 17));
      int v567 = v1090 ^ v1083 ^ v568;
      LODWORD(v568) = v491;
      int v569 = v568 >> 25;
      unint64_t v571 = __PAIR64__(v539, __ROR4__(v567, 9));
      int v570 = v569 ^ v571;
      LODWORD(v571) = v539;
      int v572 = v571 >> 13;
      unint64_t v574 = __PAIR64__(v564, __ROR4__(v567, 17));
      int v573 = v570 ^ v574;
      LODWORD(v574) = v564;
      int v575 = (v574 >> 15) ^ __ROR4__(v564, 23) ^ v564;
      unint64_t v576 = __PAIR64__(v566, __ROR4__(v524, 17));
      unsigned int v577 = v573 ^ v1090 ^ v1083 ^ v576 ^ v1093;
      LODWORD(v576) = v566;
      unsigned int v578 = (v576 >> 20) + 2055708042 + v575;
      unint64_t v579 = __PAIR64__(v578, __ROR4__(v532, 23));
      int v580 = (v566 | v547) & v579 | v566 & v547;
      LODWORD(v579) = v578;
      int v581 = v579 >> 25;
      unint64_t v583 = __PAIR64__(v559, __ROR4__(v566, 20));
      int v582 = v581 ^ v583;
      LODWORD(v583) = v559;
      int v584 = v583 >> 13;
      unsigned int v585 = v552 + (v385 ^ v1080) + v580 + v582;
      int v586 = v556 + v1080 + (v559 & v575 | v572 & ~v575) + v581;
      HIDWORD(v583) = v586;
      LODWORD(v583) = v586;
      int v587 = v583 >> 15;
      int v588 = v443 ^ v1080 ^ __ROR4__(v557, 17);
      unint64_t v590 = __PAIR64__(v351, __ROR4__(v586, 23));
      int v589 = v587 ^ v590;
      LODWORD(v590) = v351;
      unsigned int v591 = v351;
      int v592 = (v590 >> 25) ^ __ROR4__(v588, 9) ^ __ROR4__(v588, 17) ^ v443 ^ v1080;
      int v593 = v589 ^ v586;
      unint64_t v595 = __PAIR64__(v585, __ROR4__(v557, 17));
      int v594 = v592 ^ v595;
      LODWORD(v595) = v585;
      int v596 = (v595 >> 20) - 183551212;
      HIDWORD(v595) = v547;
      LODWORD(v595) = v547;
      int v597 = v595 >> 23;
      HIDWORD(v595) = v596 + v593;
      LODWORD(v595) = v596 + v593;
      int v598 = v595 >> 25;
      int v599 = v598 ^ __ROR4__(v585, 20);
      unsigned int v600 = v572 + v330 + (v575 & v593 | v584 & ~v593) + v598;
      int v601 = v565 + (v1082 ^ v330) + ((v585 | v566) & __ROR4__(v547, 23) | v585 & v566) + v599;
      int v602 = v1079 ^ v330;
      unint64_t v604 = __PAIR64__(v385, __ROR4__(v1096, 17));
      int v603 = v1079 ^ v330 ^ v604;
      LODWORD(v604) = v385;
      int v605 = v604 >> 25;
      HIDWORD(v604) = v566;
      LODWORD(v604) = v566;
      int v606 = v604 >> 23;
      unint64_t v608 = __PAIR64__(v600, __ROR4__(v603, 17));
      int v607 = v605 ^ __ROR4__(v603, 9) ^ v608;
      LODWORD(v608) = v600;
      int v609 = v608 >> 15;
      HIDWORD(v608) = v575;
      LODWORD(v608) = v575;
      int v610 = v608 >> 13;
      int v611 = v594 ^ v501;
      unint64_t v612 = __PAIR64__(v601, __ROR4__(v1096, 17));
      unsigned int v613 = v607 ^ v602 ^ v612 ^ v503;
      int v614 = v609 ^ __ROR4__(v600, 23) ^ v600;
      LODWORD(v612) = v601;
      HIDWORD(v612) = (v612 >> 20) - 367102423 + v614;
      LODWORD(v612) = HIDWORD(v612);
      int v615 = v612 >> 25;
      int v616 = v597 + (v1090 ^ v491) + ((v601 | v585) & __ROR4__(v566, 23) | v601 & v585);
      unint64_t v618 = __PAIR64__(v585, __ROR4__(v601, 20));
      int v617 = v615 ^ v618;
      unsigned int v619 = v584 + v491 + (v593 & v614 | v610 & ~v614) + v615;
      LODWORD(v618) = v585;
      int v620 = v618 >> 23;
      unsigned int v621 = v616 + v617;
      unint64_t v623 = __PAIR64__(v1082, __ROR4__(v577, 17));
      int v622 = v1093 ^ v491 ^ v623;
      LODWORD(v623) = v1082;
      int v624 = v623 >> 25;
      unint64_t v626 = __PAIR64__(v593, __ROR4__(v622, 9));
      int v625 = v624 ^ v626;
      LODWORD(v626) = v593;
      int v627 = v626 >> 13;
      unint64_t v629 = __PAIR64__(v619, __ROR4__(v622, 17));
      int v628 = v625 ^ v629;
      LODWORD(v629) = v619;
      int v630 = (v629 >> 15) ^ __ROR4__(v619, 23) ^ v619;
      unint64_t v631 = __PAIR64__(v621, __ROR4__(v577, 17));
      unsigned int v632 = v628 ^ v1093 ^ v491 ^ v631 ^ v524;
      LODWORD(v631) = v621;
      unsigned int v633 = (v631 >> 20) - 734204845 + v630;
      unint64_t v634 = __PAIR64__(v633, __ROR4__(v585, 23));
      int v635 = (v621 | v601) & v634 | v621 & v601;
      LODWORD(v634) = v633;
      int v636 = v634 >> 25;
      unint64_t v638 = __PAIR64__(v614, __ROR4__(v621, 20));
      int v637 = v636 ^ v638;
      LODWORD(v638) = v614;
      int v639 = v638 >> 13;
      unsigned int v640 = v606 + (v443 ^ v591) + v635 + v637;
      int v641 = v610 + v591 + (v614 & v630 | v627 & ~v630) + v636;
      HIDWORD(v638) = v641;
      LODWORD(v638) = v641;
      int v642 = v638 >> 15;
      int v643 = v501 ^ v591 ^ __ROR4__(v611, 17);
      unint64_t v645 = __PAIR64__(v1090, __ROR4__(v641, 23));
      int v644 = v642 ^ v645;
      LODWORD(v645) = v1090;
      int v646 = (v645 >> 25) ^ __ROR4__(v643, 9) ^ __ROR4__(v643, 17) ^ v501 ^ v591;
      int v647 = v644 ^ v641;
      unint64_t v649 = __PAIR64__(v640, __ROR4__(v611, 17));
      int v648 = v646 ^ v649;
      LODWORD(v649) = v640;
      int v650 = (v649 >> 20) - 1468409689;
      HIDWORD(v649) = v601;
      LODWORD(v649) = v601;
      int v651 = v649 >> 23;
      int v652 = v620 + (v1079 ^ v385) + ((v640 | v621) & __ROR4__(v601, 23) | v640 & v621);
      HIDWORD(v649) = v650 + v647;
      LODWORD(v649) = v650 + v647;
      int v653 = v649 >> 25;
      unsigned int v654 = v627 + v385 + (v630 & v647 | v639 & ~v647) + v653;
      int v655 = v652 + (v653 ^ __ROR4__(v640, 20));
      int v656 = v503 ^ v385;
      unint64_t v658 = __PAIR64__(v443, __ROR4__(v613, 17));
      int v657 = v656 ^ v658;
      LODWORD(v658) = v443;
      int v659 = v658 >> 25;
      HIDWORD(v658) = v621;
      LODWORD(v658) = v621;
      int v660 = v658 >> 23;
      unint64_t v662 = __PAIR64__(v654, __ROR4__(v657, 17));
      int v661 = v659 ^ __ROR4__(v657, 9) ^ v662;
      LODWORD(v662) = v654;
      int v663 = v662 >> 15;
      HIDWORD(v662) = v630;
      LODWORD(v662) = v630;
      int v664 = v662 >> 13;
      int v665 = v648 ^ v557;
      int v666 = v663 ^ __ROR4__(v654, 23);
      unint64_t v667 = __PAIR64__(v655, __ROR4__(v613, 17));
      int v668 = v661 ^ v656 ^ v667 ^ v1096;
      int v669 = v666 ^ v654;
      LODWORD(v667) = v655;
      HIDWORD(v667) = (v667 >> 20) + 1358147919 + v669;
      LODWORD(v667) = HIDWORD(v667);
      int v670 = v667 >> 25;
      unint64_t v672 = __PAIR64__(v640, __ROR4__(v655, 20));
      int v671 = v670 ^ v672;
      unsigned int v673 = v639 + v1082 + (v647 & v669 | v664 & ~v669) + v670;
      LODWORD(v672) = v640;
      int v674 = v672 >> 23;
      unsigned int v675 = v651 + (v1093 ^ v1082) + ((v655 | v640) & __ROR4__(v621, 23) | v655 & v640) + v671;
      unint64_t v677 = __PAIR64__(v1079, __ROR4__(v632, 17));
      int v676 = v524 ^ v1082 ^ v677;
      LODWORD(v677) = v1079;
      int v678 = v677 >> 25;
      unint64_t v680 = __PAIR64__(v647, __ROR4__(v676, 9));
      int v679 = v678 ^ v680;
      LODWORD(v680) = v647;
      int v681 = v680 >> 13;
      unint64_t v683 = __PAIR64__(v673, __ROR4__(v676, 17));
      int v682 = v679 ^ v683;
      LODWORD(v683) = v673;
      int v684 = v682 ^ v524 ^ v1082;
      int v685 = (v683 >> 15) ^ __ROR4__(v673, 23) ^ v673;
      unint64_t v686 = __PAIR64__(v675, __ROR4__(v632, 17));
      unsigned int v687 = v684 ^ v686 ^ v577;
      LODWORD(v686) = v675;
      unsigned int v688 = (v686 >> 20) - 1578671458 + v685;
      unint64_t v689 = __PAIR64__(v688, __ROR4__(v640, 23));
      int v690 = (v675 | v655) & v689 | v675 & v655;
      LODWORD(v689) = v688;
      int v691 = v689 >> 25;
      int v692 = v660 + (v501 ^ v1090) + v690;
      unint64_t v694 = __PAIR64__(v669, __ROR4__(v675, 20));
      int v693 = v691 ^ v694;
      LODWORD(v694) = v669;
      int v695 = v694 >> 13;
      unsigned int v696 = v692 + v693;
      int v697 = v664 + v1090 + (v669 & v685 | v681 & ~v685) + v691;
      HIDWORD(v694) = v697;
      LODWORD(v694) = v697;
      int v698 = v694 >> 15;
      int v699 = v557 ^ v1090 ^ __ROR4__(v665, 17);
      unint64_t v701 = __PAIR64__(v1093, __ROR4__(v697, 23));
      int v700 = v698 ^ v701;
      LODWORD(v701) = v1093;
      int v702 = (v701 >> 25) ^ __ROR4__(v699, 9) ^ __ROR4__(v699, 17) ^ v557 ^ v1090;
      int v703 = v700 ^ v697;
      unint64_t v705 = __PAIR64__(v696, __ROR4__(v665, 17));
      int v704 = v702 ^ v705;
      LODWORD(v705) = v696;
      int v706 = (v705 >> 20) + 1137624381;
      HIDWORD(v705) = v655;
      LODWORD(v705) = v655;
      int v707 = v705 >> 23;
      HIDWORD(v705) = v706 + v703;
      LODWORD(v705) = v706 + v703;
      int v708 = v705 >> 25;
      unsigned int v709 = v681 + v443 + (v685 & v703 | v695 & ~v703) + v708;
      int v710 = v674 + (v503 ^ v443) + ((v696 | v675) & __ROR4__(v655, 23) | v696 & v675) + (v708 ^ __ROR4__(v696, 20));
      int v711 = v1096 ^ v443;
      unint64_t v713 = __PAIR64__(v501, __ROR4__(v668, 17));
      int v712 = v711 ^ v713;
      LODWORD(v713) = v501;
      int v714 = v713 >> 25;
      HIDWORD(v713) = v675;
      LODWORD(v713) = v675;
      int v715 = v713 >> 23;
      unint64_t v717 = __PAIR64__(v709, __ROR4__(v712, 17));
      int v716 = v714 ^ __ROR4__(v712, 9) ^ v717;
      LODWORD(v717) = v709;
      int v718 = v717 >> 15;
      HIDWORD(v717) = v685;
      LODWORD(v717) = v685;
      int v719 = v717 >> 13;
      int v720 = v704 ^ v611;
      unint64_t v721 = __PAIR64__(v710, __ROR4__(v668, 17));
      int v722 = v716 ^ v711 ^ v721 ^ v613;
      int v723 = v718 ^ __ROR4__(v709, 23) ^ v709;
      LODWORD(v721) = v710;
      HIDWORD(v721) = (v721 >> 20) - 2019718534 + v723;
      LODWORD(v721) = HIDWORD(v721);
      int v724 = v721 >> 25;
      int v725 = v707 + (v524 ^ v1079) + ((v710 | v696) & __ROR4__(v675, 23) | v710 & v696);
      unint64_t v727 = __PAIR64__(v696, __ROR4__(v710, 20));
      int v726 = v724 ^ v727;
      unsigned int v728 = v695 + v1079 + (v703 & v723 | v719 & ~v723) + v724;
      LODWORD(v727) = v696;
      int v729 = v727 >> 23;
      unsigned int v730 = v725 + v726;
      unint64_t v732 = __PAIR64__(v503, __ROR4__(v687, 17));
      int v731 = v577 ^ v1079 ^ v732;
      LODWORD(v732) = v503;
      int v733 = v732 >> 25;
      unint64_t v735 = __PAIR64__(v703, __ROR4__(v731, 9));
      int v734 = v733 ^ v735;
      LODWORD(v735) = v703;
      int v736 = v735 >> 13;
      unint64_t v738 = __PAIR64__(v728, __ROR4__(v731, 17));
      int v737 = v734 ^ v738;
      LODWORD(v738) = v728;
      int v739 = v737 ^ v577 ^ v1079;
      int v740 = (v738 >> 15) ^ __ROR4__(v728, 23) ^ v728;
      unint64_t v741 = __PAIR64__(v730, __ROR4__(v687, 17));
      int v742 = v739 ^ v741 ^ v632;
      LODWORD(v741) = v730;
      unsigned int v743 = (v741 >> 20) + 255530229 + v740;
      unint64_t v744 = __PAIR64__(v743, __ROR4__(v696, 23));
      int v745 = (v730 | v710) & v744 | v730 & v710;
      LODWORD(v744) = v743;
      int v746 = v744 >> 25;
      unint64_t v748 = __PAIR64__(v723, __ROR4__(v730, 20));
      int v747 = v746 ^ v748;
      LODWORD(v748) = v723;
      int v749 = v748 >> 13;
      unsigned int v750 = v715 + (v557 ^ v1093) + v745 + v747;
      int v751 = v719 + v1093 + (v723 & v740 | v736 & ~v740) + v746;
      HIDWORD(v748) = v751;
      LODWORD(v748) = v751;
      int v752 = v748 >> 15;
      int v753 = v611 ^ v1093 ^ __ROR4__(v720, 17);
      unint64_t v755 = __PAIR64__(v524, __ROR4__(v751, 23));
      int v754 = v752 ^ v755;
      LODWORD(v755) = v524;
      int v756 = (v755 >> 25) ^ __ROR4__(v753, 9) ^ __ROR4__(v753, 17) ^ v611 ^ v1093;
      int v757 = v754 ^ v751;
      unint64_t v759 = __PAIR64__(v750, __ROR4__(v720, 17));
      int v758 = v756 ^ v759;
      LODWORD(v759) = v750;
      int v760 = (v759 >> 20) + 511060458;
      HIDWORD(v759) = v710;
      LODWORD(v759) = v710;
      int v761 = v759 >> 23;
      HIDWORD(v759) = v760 + v757;
      LODWORD(v759) = v760 + v757;
      int v762 = v759 >> 25;
      unsigned int v763 = v736 + v501 + (v740 & v757 | v749 & ~v757) + v762;
      int v764 = v729 + (v1096 ^ v501) + ((v750 | v730) & __ROR4__(v710, 23) | v750 & v730) + (v762 ^ __ROR4__(v750, 20));
      int v765 = v613 ^ v501;
      unint64_t v767 = __PAIR64__(v557, __ROR4__(v722, 17));
      int v766 = v613 ^ v501 ^ v767;
      LODWORD(v767) = v557;
      int v768 = v767 >> 25;
      HIDWORD(v767) = v730;
      LODWORD(v767) = v730;
      int v769 = v767 >> 23;
      unint64_t v771 = __PAIR64__(v763, __ROR4__(v766, 17));
      int v770 = v768 ^ __ROR4__(v766, 9) ^ v771;
      LODWORD(v771) = v763;
      int v772 = v771 >> 15;
      HIDWORD(v771) = v740;
      LODWORD(v771) = v740;
      int v773 = v771 >> 13;
      int v774 = v758 ^ v665;
      unint64_t v775 = __PAIR64__(v764, __ROR4__(v722, 17));
      int v776 = v770 ^ v765 ^ v775 ^ v668;
      int v777 = v772 ^ __ROR4__(v763, 23) ^ v763;
      LODWORD(v775) = v764;
      HIDWORD(v775) = (v775 >> 20) + 1022120916 + v777;
      LODWORD(v775) = HIDWORD(v775);
      int v778 = v775 >> 25;
      int v779 = v761 + (v577 ^ v503) + ((v764 | v750) & __ROR4__(v730, 23) | v764 & v750);
      unint64_t v781 = __PAIR64__(v750, __ROR4__(v764, 20));
      int v780 = v778 ^ v781;
      unsigned int v782 = v749 + v503 + (v757 & v777 | v773 & ~v777) + v778;
      LODWORD(v781) = v750;
      int v783 = v781 >> 23;
      int v784 = v632 ^ v503;
      unsigned int v785 = v779 + v780;
      unint64_t v787 = __PAIR64__(v1096, __ROR4__(v742, 17));
      int v786 = v784 ^ v787;
      LODWORD(v787) = v1096;
      int v788 = v787 >> 25;
      unint64_t v790 = __PAIR64__(v757, __ROR4__(v786, 9));
      int v789 = v788 ^ v790;
      LODWORD(v790) = v757;
      int v791 = v790 >> 13;
      unint64_t v793 = __PAIR64__(v782, __ROR4__(v786, 17));
      int v792 = v789 ^ v793;
      LODWORD(v793) = v782;
      int v794 = v792 ^ v784;
      int v795 = (v793 >> 15) ^ __ROR4__(v782, 23) ^ v782;
      unint64_t v796 = __PAIR64__(v785, __ROR4__(v742, 17));
      int v797 = v794 ^ v796 ^ v687;
      LODWORD(v796) = v785;
      unsigned int v798 = (v796 >> 20) + 2044241832 + v795;
      unint64_t v799 = __PAIR64__(v798, __ROR4__(v750, 23));
      int v800 = (v785 | v764) & v799 | v785 & v764;
      LODWORD(v799) = v798;
      int v801 = v799 >> 25;
      int v802 = v769 + (v611 ^ v524) + v800;
      unint64_t v804 = __PAIR64__(v777, __ROR4__(v785, 20));
      int v803 = v801 ^ v804;
      int v805 = v773 + v524 + (v777 & v795 | v791 & ~v795);
      LODWORD(v804) = v777;
      int v806 = v804 >> 13;
      unsigned int v807 = v802 + v803;
      int v808 = v805 + v801;
      HIDWORD(v804) = v805 + v801;
      LODWORD(v804) = v805 + v801;
      int v809 = v804 >> 15;
      int v810 = v665 ^ v524;
      int v811 = v810 ^ __ROR4__(v774, 17);
      unint64_t v813 = __PAIR64__(v577, __ROR4__(v808, 23));
      int v812 = v809 ^ v813;
      LODWORD(v813) = v577;
      int v814 = (v813 >> 25) ^ __ROR4__(v811, 9) ^ __ROR4__(v811, 17) ^ v810;
      int v815 = v812 ^ v808;
      unint64_t v817 = __PAIR64__(v807, __ROR4__(v774, 17));
      int v816 = v814 ^ v817;
      LODWORD(v817) = v807;
      int v818 = (v817 >> 20) - 206483632;
      HIDWORD(v817) = v764;
      LODWORD(v817) = v764;
      int v819 = v817 >> 23;
      int v820 = v783 + (v613 ^ v557) + ((v807 | v785) & __ROR4__(v764, 23) | v807 & v785);
      HIDWORD(v817) = v818 + v815;
      LODWORD(v817) = v818 + v815;
      int v821 = v817 >> 25;
      unsigned int v822 = v791 + v557 + (v795 & v815 | v806 & ~v815) + v821;
      int v823 = v820 + (v821 ^ __ROR4__(v807, 20));
      int v824 = v668 ^ v557;
      unint64_t v826 = __PAIR64__(v611, __ROR4__(v776, 17));
      int v825 = v668 ^ v557 ^ v826;
      LODWORD(v826) = v611;
      int v827 = v826 >> 25;
      HIDWORD(v826) = v785;
      LODWORD(v826) = v785;
      int v828 = v826 >> 23;
      unint64_t v830 = __PAIR64__(v822, __ROR4__(v825, 17));
      int v829 = v827 ^ __ROR4__(v825, 9) ^ v830;
      LODWORD(v830) = v822;
      int v831 = v830 >> 15;
      HIDWORD(v830) = v795;
      LODWORD(v830) = v795;
      int v832 = v830 >> 13;
      int v833 = v816 ^ v720;
      unint64_t v834 = __PAIR64__(v823, __ROR4__(v776, 17));
      int v835 = v829 ^ v824 ^ v834 ^ v722;
      int v836 = v831 ^ __ROR4__(v822, 23) ^ v822;
      LODWORD(v834) = v823;
      HIDWORD(v834) = (v834 >> 20) - 412967263 + v836;
      LODWORD(v834) = HIDWORD(v834);
      int v837 = v834 >> 25;
      int v838 = v819 + (v632 ^ v1096) + ((v823 | v807) & __ROR4__(v785, 23) | v823 & v807);
      unint64_t v840 = __PAIR64__(v807, __ROR4__(v823, 20));
      int v839 = v837 ^ v840;
      unsigned int v841 = v806 + v1096 + (v815 & v836 | v832 & ~v836) + v837;
      LODWORD(v840) = v807;
      int v842 = v840 >> 23;
      unsigned int v843 = v838 + v839;
      unint64_t v845 = __PAIR64__(v613, __ROR4__(v797, 17));
      int v844 = v687 ^ v1096 ^ v845;
      LODWORD(v845) = v613;
      int v846 = v845 >> 25;
      unint64_t v848 = __PAIR64__(v815, __ROR4__(v844, 9));
      int v847 = v846 ^ v848;
      LODWORD(v848) = v815;
      int v849 = v848 >> 13;
      unint64_t v851 = __PAIR64__(v841, __ROR4__(v844, 17));
      int v850 = v847 ^ v851;
      LODWORD(v851) = v841;
      int v852 = v851 >> 15;
      unint64_t v853 = __PAIR64__(v843, __ROR4__(v841, 23));
      unsigned int v854 = v852 ^ v853 ^ v841;
      LODWORD(v853) = v843;
      HIDWORD(v853) = (v853 >> 20) - 825934525 + v854;
      LODWORD(v853) = HIDWORD(v853);
      int v855 = v853 >> 25;
      int v856 = v828 + (v665 ^ v577) + ((v843 | v823) & __ROR4__(v807, 23) | v843 & v823);
      unint64_t v858 = __PAIR64__(v823, __ROR4__(v843, 20));
      int v857 = v855 ^ v858;
      unsigned int v859 = v832 + v577 + (v836 & v854 | v849 & ~v854) + v855;
      LODWORD(v858) = v823;
      int v860 = v858 >> 23;
      int v861 = v720 ^ v577;
      unsigned int v862 = v856 + v857;
      unint64_t v864 = __PAIR64__(v632, __ROR4__(v833, 17));
      int v863 = v720 ^ v577 ^ v864;
      LODWORD(v864) = v632;
      int v865 = v864 >> 25;
      unint64_t v867 = __PAIR64__(v836, __ROR4__(v863, 9));
      int v866 = v865 ^ v867;
      LODWORD(v867) = v836;
      int v868 = v867 >> 13;
      unint64_t v870 = __PAIR64__(v859, __ROR4__(v863, 17));
      int v869 = v866 ^ v870;
      LODWORD(v870) = v859;
      int v871 = v870 >> 15;
      unint64_t v872 = __PAIR64__(v862, __ROR4__(v859, 23));
      int v873 = v869 ^ v861;
      int v874 = v871 ^ v872 ^ v859;
      LODWORD(v872) = v862;
      HIDWORD(v872) = (v872 >> 20) - 1651869049 + v874;
      LODWORD(v872) = HIDWORD(v872);
      int v875 = v872 >> 25;
      int v876 = v842 + (v668 ^ v611) + ((v862 | v843) & __ROR4__(v823, 23) | v862 & v843);
      unint64_t v878 = __PAIR64__(v843, __ROR4__(v862, 20));
      int v877 = v875 ^ v878;
      unsigned int v879 = v849 + v611 + (v854 & v874 | v868 & ~v874) + v875;
      LODWORD(v878) = v843;
      int v880 = v878 >> 23;
      int v881 = v722 ^ v611;
      unsigned int v882 = v876 + v877;
      unint64_t v884 = __PAIR64__(v665, __ROR4__(v835, 17));
      int v883 = v881 ^ v884;
      LODWORD(v884) = v665;
      int v885 = v884 >> 25;
      unint64_t v887 = __PAIR64__(v854, __ROR4__(v883, 9));
      int v886 = v885 ^ v887;
      LODWORD(v887) = v854;
      int v888 = v887 >> 13;
      unint64_t v890 = __PAIR64__(v879, __ROR4__(v883, 17));
      int v889 = v886 ^ v890;
      LODWORD(v890) = v879;
      int v891 = v890 >> 15;
      unint64_t v892 = __PAIR64__(v882, __ROR4__(v879, 23));
      int v893 = v889 ^ v881;
      int v894 = v891 ^ v892 ^ v879;
      LODWORD(v892) = v882;
      HIDWORD(v892) = (v892 >> 20) + 991229199 + v894;
      LODWORD(v892) = HIDWORD(v892);
      int v895 = v892 >> 25;
      int v896 = v860 + (v687 ^ v613) + ((v882 | v862) & __ROR4__(v843, 23) | v882 & v862);
      int v897 = v895 ^ __ROR4__(v882, 20);
      int v898 = v868 + v613 + (v874 & v894 | v888 & ~v894) + v895;
      HIDWORD(v892) = v898;
      LODWORD(v892) = v898;
      int v899 = v892 >> 15;
      HIDWORD(v892) = v874;
      LODWORD(v892) = v874;
      int v900 = v892 >> 13;
      int v901 = v896 + v897;
      unint64_t v903 = __PAIR64__(v896 + v897, __ROR4__(v898, 23));
      int v902 = v899 ^ v903;
      LODWORD(v903) = v901;
      int v904 = v903 >> 20;
      HIDWORD(v903) = v862;
      LODWORD(v903) = v862;
      int v905 = v903 >> 23;
      int v906 = v902 ^ v898;
      HIDWORD(v903) = v904 + 1982458398 + v906;
      LODWORD(v903) = HIDWORD(v903);
      int v907 = v903 >> 25;
      int v908 = v880 + (v720 ^ v632) + ((v901 | v882) & __ROR4__(v862, 23) | v901 & v882);
      unint64_t v910 = __PAIR64__(v882, __ROR4__(v901, 20));
      int v909 = v907 ^ v910;
      int v911 = v888 + v632 + (v894 & v906 | v900 & ~v906) + v907;
      LODWORD(v910) = v882;
      int v912 = v910 >> 23;
      HIDWORD(v910) = v894;
      LODWORD(v910) = v894;
      int v913 = v910 >> 13;
      unsigned int v914 = v908 + v909;
      HIDWORD(v910) = v911;
      LODWORD(v910) = v911;
      int v915 = v910 >> 15;
      unint64_t v917 = __PAIR64__(v914, __ROR4__(v911, 23));
      int v916 = v915 ^ v917;
      LODWORD(v917) = v914;
      int v918 = v916 ^ v911;
      unsigned int v919 = (v917 >> 20) - 330050500 + v918;
      unint64_t v921 = __PAIR64__(v919, __ROR4__(v882, 23));
      int v920 = (v914 | v901) & v921;
      LODWORD(v921) = v919;
      int v922 = v921 >> 25;
      unint64_t v923 = __PAIR64__(v906, __ROR4__(v914, 20));
      unsigned int v924 = v905 + (v722 ^ v665) + (v920 | v914 & v901) + (v922 ^ v923);
      int v925 = v900 + v665 + (v906 & v918 | v913 & ~v918) + v922;
      LODWORD(v923) = v906;
      int v926 = v923 >> 13;
      HIDWORD(v923) = v925;
      LODWORD(v923) = v925;
      int v927 = v923 >> 15;
      unint64_t v928 = __PAIR64__(v924, __ROR4__(v925, 23));
      unsigned int v929 = v927 ^ v928 ^ v925;
      LODWORD(v928) = v924;
      int v930 = (v928 >> 20) - 660100999;
      HIDWORD(v928) = v901;
      LODWORD(v928) = v901;
      int v931 = v928 >> 23;
      HIDWORD(v928) = v930 + v929;
      LODWORD(v928) = v930 + v929;
      int v932 = v928 >> 25;
      unint64_t v933 = __PAIR64__(v914, __ROR4__(v924, 20));
      int v934 = v913 + v668 + (v918 & v929 | v926 & ~v929) + v932;
      unsigned int v935 = v912 + (v742 ^ v668) + ((v924 | v914) & __ROR4__(v901, 23) | v924 & v914) + (v932 ^ v933);
      LODWORD(v933) = v914;
      int v936 = v933 >> 23;
      HIDWORD(v933) = v934;
      LODWORD(v933) = v934;
      int v937 = v933 >> 15;
      HIDWORD(v933) = v918;
      LODWORD(v933) = v918;
      int v938 = v933 >> 13;
      int v939 = v937 ^ __ROR4__(v934, 23) ^ v934;
      unint64_t v940 = __PAIR64__(v935, __ROR4__(v914, 23));
      int v941 = v931 + (v774 ^ v687) + ((v935 | v924) & v940 | v935 & v924);
      LODWORD(v940) = v935;
      HIDWORD(v940) = (v940 >> 20) - 1320201997 + v939;
      LODWORD(v940) = HIDWORD(v940);
      int v942 = v940 >> 25;
      int v943 = v926 + v687 + (v929 & v939 | v938 & ~v939);
      unint64_t v945 = __PAIR64__(v929, __ROR4__(v935, 20));
      int v944 = v942 ^ v945;
      LODWORD(v945) = v929;
      int v946 = v945 >> 13;
      unsigned int v947 = v941 + v944;
      HIDWORD(v945) = v943 + v942;
      LODWORD(v945) = v943 + v942;
      unsigned int v948 = (v945 >> 15) ^ __ROR4__(v943 + v942, 23) ^ (v943 + v942);
      unint64_t v949 = __PAIR64__(v947, __ROR4__(v924, 23));
      int v950 = v936 + (v776 ^ v720) + ((v947 | v935) & v949 | v947 & v935);
      LODWORD(v949) = v947;
      HIDWORD(v949) = (v949 >> 20) + 1654563303 + v948;
      LODWORD(v949) = HIDWORD(v949);
      int v951 = v949 >> 25;
      HIDWORD(v949) = v924;
      LODWORD(v949) = v924;
      int v952 = v949 >> 23;
      int v953 = v938 + v720 + (v939 & v948 | v946 & ~v948);
      unint64_t v955 = __PAIR64__(v939, __ROR4__(v947, 20));
      int v954 = v951 ^ v955;
      int v956 = v953 + v951;
      LODWORD(v955) = v939;
      int v957 = v955 >> 13;
      unsigned int v958 = v950 + v954;
      HIDWORD(v955) = v956;
      LODWORD(v955) = v956;
      int v959 = (v955 >> 15) ^ __ROR4__(v956, 23) ^ v956;
      unint64_t v960 = __PAIR64__(v958, __ROR4__(v935, 23));
      int v961 = v952 + (v797 ^ v722) + ((v958 | v947) & v960 | v958 & v947);
      LODWORD(v960) = v958;
      HIDWORD(v960) = (v960 >> 20) - 985840690 + v959;
      LODWORD(v960) = HIDWORD(v960);
      int v962 = v960 >> 25;
      unint64_t v963 = __PAIR64__(v948, __ROR4__(v958, 20));
      unsigned int v964 = v961 + (v962 ^ v963);
      int v965 = v946 + v722 + (v948 & v959 | v957 & ~v959) + v962;
      LODWORD(v963) = v948;
      int v966 = v963 >> 13;
      HIDWORD(v963) = v965;
      LODWORD(v963) = v965;
      int v967 = v963 >> 15;
      unint64_t v968 = __PAIR64__(v964, __ROR4__(v965, 23));
      int v969 = v967 ^ v968 ^ v965;
      LODWORD(v968) = v964;
      int v970 = (v968 >> 20) - 1971681379;
      HIDWORD(v968) = v935;
      LODWORD(v968) = v935;
      int v971 = v968 >> 23;
      HIDWORD(v968) = v970 + v969;
      LODWORD(v968) = v970 + v969;
      int v972 = v968 >> 25;
      int v973 = v971 + (v833 ^ v742) + ((v964 | v958) & __ROR4__(v947, 23) | v964 & v958) + (v972 ^ __ROR4__(v964, 20));
      int v974 = v742 ^ v613;
      int v975 = v850 ^ v687 ^ v1096 ^ __ROR4__(v797, 17) ^ v742;
      unint64_t v976 = __PAIR64__(v947, __ROR4__(v833, 17));
      int v977 = v873 ^ v976 ^ v774;
      int v978 = v774 ^ v632;
      LODWORD(v976) = v947;
      int v979 = v976 >> 23;
      int v980 = v957 + v742 + (v959 & v969 | v966 & ~v969) + v972;
      HIDWORD(v976) = v980;
      LODWORD(v976) = v980;
      int v981 = v976 >> 15;
      HIDWORD(v976) = v959;
      LODWORD(v976) = v959;
      int v982 = v976 >> 13;
      int v983 = v981 ^ __ROR4__(v980, 23) ^ v980;
      int v984 = (v973 | v964) & __ROR4__(v958, 23) | v973 & v964;
      int v985 = v979 + (v835 ^ v774);
      unint64_t v987 = __PAIR64__(v973, __ROR4__(v835, 17));
      int v986 = v893 ^ v987;
      int v988 = v966 + v774 + (v969 & v983 | v982 & ~v983);
      LODWORD(v987) = v973;
      int v989 = v987 >> 20;
      HIDWORD(v987) = v958;
      LODWORD(v987) = v958;
      int v990 = v987 >> 23;
      int v991 = v776 ^ v665;
      HIDWORD(v987) = v989 + 351604539 + v983;
      LODWORD(v987) = HIDWORD(v987);
      int v992 = v987 >> 25;
      int v993 = v985 + v984;
      int v994 = v992 ^ __ROR4__(v973, 20);
      int v995 = v988 + v992;
      HIDWORD(v987) = v995;
      LODWORD(v987) = v995;
      int v996 = v987 >> 15;
      HIDWORD(v987) = v969;
      LODWORD(v987) = v969;
      int v997 = v987 >> 13;
      unsigned int v998 = v993 + v994;
      int v999 = v996 ^ __ROR4__(v995, 23) ^ v995;
      unint64_t v1000 = __PAIR64__(v998, __ROR4__(v964, 23));
      int v1001 = v990 + (v975 ^ v776) + ((v998 | v973) & v1000 | v998 & v973);
      LODWORD(v1000) = v998;
      int v1002 = v986 ^ v776;
      HIDWORD(v1000) = (v1000 >> 20) + 703209078 + v999;
      LODWORD(v1000) = HIDWORD(v1000);
      int v1003 = v1000 >> 25;
      unint64_t v1004 = __PAIR64__(v983, __ROR4__(v998, 20));
      unsigned int v1005 = v1001 + (v1003 ^ v1004);
      int v1006 = v982 + v776 + (v983 & v999 | v997 & ~v999) + v1003;
      LODWORD(v1004) = v983;
      int v1007 = v1004 >> 13;
      HIDWORD(v1004) = v1006;
      LODWORD(v1004) = v1006;
      int v1008 = v1004 >> 15;
      unint64_t v1009 = __PAIR64__(v1005, __ROR4__(v1006, 23));
      unsigned int v1010 = v1008 ^ v1009 ^ v1006;
      LODWORD(v1009) = v1005;
      int v1011 = (v1009 >> 20) + 1406418156;
      HIDWORD(v1009) = v964;
      LODWORD(v1009) = v964;
      int v1012 = v1009 >> 23;
      HIDWORD(v1009) = v1011 + v1010;
      LODWORD(v1009) = v1011 + v1010;
      int v1013 = v1009 >> 25;
      unint64_t v1014 = __PAIR64__(v973, __ROR4__(v1005, 20));
      unsigned int v1015 = v1012 + (v977 ^ v797) + ((v1005 | v998) & __ROR4__(v973, 23) | v1005 & v998) + (v1013 ^ v1014);
      LODWORD(v1014) = v973;
      int v1016 = v1014 >> 23;
      int v1017 = v997 + v797 + (v999 & v1010 | v1007 & ~v1010) + v1013;
      HIDWORD(v1014) = v1017;
      LODWORD(v1014) = v1017;
      int v1018 = v1014 >> 15;
      HIDWORD(v1014) = v999;
      LODWORD(v1014) = v999;
      int v1019 = v1014 >> 13;
      int v1020 = v1018 ^ __ROR4__(v1017, 23) ^ v1017;
      unint64_t v1021 = __PAIR64__(v1015, __ROR4__(v998, 23));
      int v1022 = v1016 + (v1002 ^ v833) + ((v1015 | v1005) & v1021 | v1015 & v1005);
      LODWORD(v1021) = v1015;
      int v1023 = (v1021 >> 20) - 1482130984 + v1020;
      HIDWORD(v1021) = v668;
      LODWORD(v1021) = v668;
      int v1024 = v1021 >> 25;
      HIDWORD(v1021) = v1023;
      LODWORD(v1021) = v1023;
      int v1025 = v1021 >> 25;
      int v1026 = v1022 + (v1025 ^ __ROR4__(v1015, 20));
      int v1027 = v974 ^ __ROR4__(v975, 17);
      HIDWORD(v1021) = v1007 + v833 + (v1010 & v1020 | v1019 & ~v1020) + v1025;
      LODWORD(v1021) = HIDWORD(v1021);
      int v1028 = (v1021 >> 15) ^ __ROR4__(HIDWORD(v1021), 23) ^ HIDWORD(v1021);
      int v1029 = v1024 ^ __ROR4__(v1027, 9) ^ __ROR4__(v1027, 17);
      unint64_t v1031 = __PAIR64__(v998, __ROR4__(v1005, 23));
      int v1030 = (v1026 | v1015) & v1031;
      LODWORD(v1031) = v998;
      int v1032 = v1031 >> 23;
      unint64_t v1034 = __PAIR64__(v1010, __ROR4__(v975, 17));
      int v1033 = v1029 ^ v974 ^ v1034;
      LODWORD(v1034) = v1010;
      int v1035 = v1034 >> 13;
      HIDWORD(v1034) = v1026;
      LODWORD(v1034) = v1026;
      int v1036 = v1032 + (v1033 ^ v797 ^ v835) + (v1030 | v1026 & v1015);
      HIDWORD(v1034) = (v1034 >> 20) + 1330705329 + v1028;
      LODWORD(v1034) = HIDWORD(v1034);
      unsigned int v1037 = v1034 >> 25;
      unsigned int v1038 = v1019 + v835 + (v1020 & v1028 | v1035 & ~v1028) + v1037;
      int result = v1036 + (v1037 ^ __ROR4__(v1026, 20));
      HIDWORD(v1034) = v1038;
      LODWORD(v1034) = v1038;
      int v1039 = (v1034 >> 15) ^ __ROR4__(v1038, 23) ^ v1038;
      unint64_t v1041 = __PAIR64__(v687, __ROR4__(v977, 17));
      int v1040 = v978 ^ v1041;
      LODWORD(v1041) = v687;
      int v1042 = (v1041 >> 25) ^ __ROR4__(v1040, 9) ^ __ROR4__(v1040, 17);
      unint64_t v1044 = __PAIR64__(v1005, __ROR4__(v977, 17));
      int v1043 = v1042 ^ v978 ^ v1044;
      LODWORD(v1044) = v1005;
      int v1045 = v1044 >> 23;
      int v1046 = v1043 ^ v833 ^ v975;
      HIDWORD(v1044) = v1020;
      LODWORD(v1044) = v1020;
      int v1047 = v1044 >> 13;
      unsigned int v1048 = v1045 + v1046 + ((result | v1026) & __ROR4__(v1015, 23) | result & v1026);
      HIDWORD(v1044) = v720;
      LODWORD(v1044) = v720;
      int v1049 = v991 ^ __ROR4__(v1002, 17);
      int v1050 = (v1044 >> 25) ^ __ROR4__(v1049, 9);
      unint64_t v1052 = __PAIR64__(result, __ROR4__(v1049, 17));
      int v1051 = v1050 ^ v1052;
      LODWORD(v1052) = result;
      HIDWORD(v1052) = (v1052 >> 20) - 1633556638 + v1039;
      LODWORD(v1052) = HIDWORD(v1052);
      int v1053 = v1052 >> 25;
      unsigned int v1054 = v1035 + v975 + (v1028 & v1039 | v1047 & ~v1039) + v1053;
      unsigned int v1055 = v1048 + (v1053 ^ __ROR4__(result, 20));
      unint64_t v1057 = __PAIR64__(v1054, __ROR4__(v1002, 17));
      int v1056 = v1051 ^ v991 ^ v1057;
      LODWORD(v1057) = v1054;
      int v1058 = (v1057 >> 15) ^ __ROR4__(v1054, 23) ^ v1054;
      unint64_t v1059 = __PAIR64__(v1015, __ROR4__(v1026, 23));
      int v1060 = (v1055 | result) & v1059 | v1055 & result;
      LODWORD(v1059) = v1015;
      int v1061 = (v1059 >> 23) + (v1056 ^ v835 ^ v977);
      HIDWORD(v1059) = v1028;
      LODWORD(v1059) = v1028;
      int v1062 = v1061 + v1060;
      int v1063 = v1039 & v1058 | (v1059 >> 13) & ~v1058;
      HIDWORD(v1059) = v1055;
      LODWORD(v1059) = v1055;
      HIDWORD(v1059) = (v1059 >> 20) + 1027854021 + v1058;
      LODWORD(v1059) = HIDWORD(v1059);
      int v1064 = v1059 >> 25;
      int v1065 = v1064 ^ __ROR4__(v1055, 20);
      unsigned int v1066 = v1047 + v977 + v1063 + v1064;
      int v4 = v1055 ^ v1099;
      int v6 = v1098 ^ __ROR4__(result, 23);
      int v1067 = v1058 ^ v1084;
      unint64_t v1069 = __PAIR64__(v1066, __ROR4__(v1026, 23));
      int v1068 = v1087 ^ v1069;
      LODWORD(v1069) = v1066;
      int v3 = (v1062 + v1065) ^ v1100;
      int v8 = (v1069 >> 15) ^ __ROR4__(v1066, 23) ^ v1097 ^ v1066;
      int v1070 = v1085 ^ __ROR4__(v1039, 13);
      int v1071 = v1086 ^ __ROR4__(v1028, 13);
      v1072[2] = v6;
      v1072[3] = v1068;
      int v5 = v1068;
      int *v1072 = v3;
      v1072[1] = v4;
      v1072[4] = v8;
      v1072[5] = v1067;
      int v7 = v1067;
      int v10 = v1070;
      v1072[6] = v1070;
      v1072[7] = v1071;
      int v9 = v1071;
      a2 += 64;
      a3 = v1088 - 1;
    }
    while (v1088 != 1);
  }
  return result;
}

unint64_t SM3_Transform(unint64_t a1, uint64_t a2)
{
  return SM3_block_data_order(a1, a2, 1);
}

uint64_t SM3_Final(_DWORD *a1, unsigned int *a2)
{
  int v4 = a2 + 10;
  uint64_t v5 = a2[26];
  *((unsigned char *)a2 + v5 + 40) = 0x80;
  uint64_t v6 = v5 + 1;
  if (v5 >= 0x38)
  {
    bzero((char *)v4 + v6, 63 - v5);
    SM3_block_data_order((unint64_t)a2, (uint64_t)v4, 1);
    uint64_t v6 = 0;
  }
  bzero((char *)v4 + v6, 56 - v6);
  unsigned int v7 = bswap32(a2[8]);
  a2[24] = bswap32(a2[9]);
  a2[25] = v7;
  SM3_block_data_order((unint64_t)a2, (uint64_t)v4, 1);
  a2[26] = 0;
  *int v4 = 0u;
  v4[1] = 0u;
  void v4[2] = 0u;
  v4[3] = 0u;
  *a1 = bswap32(*a2);
  a1[1] = bswap32(a2[1]);
  a1[2] = bswap32(a2[2]);
  a1[3] = bswap32(a2[3]);
  a1[4] = bswap32(a2[4]);
  a1[5] = bswap32(a2[5]);
  a1[6] = bswap32(a2[6]);
  a1[7] = bswap32(a2[7]);
  return 1;
}

uint64_t SM3_Init(_OWORD *a1)
{
  *(_OWORD *)((char *)a1 + 92) = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = xmmword_23C709A60;
  a1[1] = xmmword_23C709A70;
  return 1;
}

uint64_t ec_wNAF_mul(EC_GROUP *a1, EC_POINT *a2, const BIGNUM *a3, unint64_t a4, void **a5, uint64_t a6, BN_CTX *a7)
{
  if (*(void *)a1 != *(void *)a2)
  {
    int v7 = 364;
LABEL_3:
    ERR_put_error(16, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", v7);
    return 0;
  }
  if (a3 || a4)
  {
    if (a4)
    {
      unsigned int v17 = a5;
      unint64_t v18 = a4;
      while (*(void *)a1 == **v17)
      {
        ++v17;
        if (!--v18) {
          goto LABEL_14;
        }
      }
      int v7 = 372;
      goto LABEL_3;
    }
LABEL_14:
    if (a3)
    {
      unsigned int v19 = EC_GROUP_get0_generator(a1);
      if (!v19)
      {
        ERR_put_error(16, 4095, 113, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", 380);
        int v42 = 0;
        int v26 = 0;
        unint64_t v43 = 0;
        int v44 = 0;
        goto LABEL_52;
      }
      unint64_t data = EC_EX_DATA_get_data(*((void **)a1 + 12), (uint64_t)ec_pre_comp_dup, (uint64_t)ec_pre_comp_free, (uint64_t)ec_pre_comp_clear_free);
      if (data && (int v21 = data, data[2]) && !EC_POINT_cmp(a1, v19, *(const EC_POINT **)data[4], a7))
      {
        int v101 = v21;
        size_t v99 = v21[1];
        unint64_t v51 = BN_num_bits(a3) / v99;
        unint64_t v52 = v21[2];
        uint64_t v53 = v21[3];
        if (v51 + 1 < v52) {
          uint64_t v22 = v51 + 1;
        }
        else {
          uint64_t v22 = v21[2];
        }
        if (v21[5] != v52 << (v53 - 1))
        {
          int v40 = 68;
          int v41 = 409;
LABEL_50:
          ERR_put_error(16, 4095, v40, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", v41);
          int v42 = 0;
          int v26 = 0;
          unint64_t v43 = 0;
          int v44 = 0;
          unsigned int v19 = 0;
LABEL_52:
          unint64_t v45 = 0;
          unint64_t v28 = 0;
          uint64_t v8 = 0;
          goto LABEL_94;
        }
        char v97 = 0;
        uint64_t v23 = 0;
        char v98 = 1;
        uint64_t v96 = 1 << (v53 - 1);
      }
      else
      {
        char v98 = 0;
        size_t v99 = 0;
        uint64_t v96 = 0;
        int v101 = 0;
        uint64_t v22 = 1;
        char v97 = 1;
        uint64_t v23 = 1;
      }
    }
    else
    {
      unsigned int v19 = 0;
      uint64_t v22 = 0;
      uint64_t v96 = 0;
      int v101 = 0;
      char v97 = 0;
      uint64_t v23 = 0;
      char v98 = 1;
      size_t v99 = 0;
    }
    uint64_t v100 = v22;
    unint64_t v24 = v22 + a4;
    unsigned int v25 = (void **)reallocarray(0, v22 + a4 + 1, 8uLL);
    if (v25)
    {
      int v91 = v19;
      unint64_t v92 = a5;
      EVP_CIPHER_CTX a = a2;
      int v107 = v25;
      *unsigned int v25 = 0;
      int v26 = reallocarray(0, v24, 8uLL);
      unsigned int v19 = (const EC_POINT *)reallocarray(0, v24, 8uLL);
      unint64_t v94 = v24;
      int v27 = reallocarray(0, v24, 8uLL);
      unint64_t v28 = v27;
      if (v26 && v19 && v27)
      {
        int v90 = a7;
        unsigned int v105 = v19;
        unint64_t v106 = v26;
        unint64_t v95 = v27;
        unint64_t v89 = v23 + a4;
        if (v23 + a4)
        {
          uint64_t v29 = 0;
          size_t v30 = 0;
          unint64_t v31 = 0;
          uint64_t v102 = -(uint64_t)(v23 + a4);
          uint64_t v32 = 1;
          while (1)
          {
            unsigned int v33 = a3;
            if (v32 - 1 < a4) {
              unsigned int v33 = *(const BIGNUM **)(a6 + v29 * 8);
            }
            unsigned int v34 = BN_num_bits(v33);
            if (v34 <= 0x13) {
              uint64_t v35 = 1;
            }
            else {
              uint64_t v35 = 2;
            }
            if (v34 > 0x45) {
              uint64_t v35 = 3;
            }
            if (v34 > 0x12B) {
              uint64_t v35 = 4;
            }
            if (v34 > 0x31F) {
              uint64_t v35 = 5;
            }
            if (v34 <= 0x7CF) {
              uint64_t v36 = v35;
            }
            else {
              uint64_t v36 = 6;
            }
            v106[v29] = v36;
            v107[v29 + 1] = 0;
            int v37 = a3;
            if (v32 - 1 < a4) {
              int v37 = *(const BIGNUM **)(a6 + v29 * 8);
            }
            unsigned int v38 = (unint64_t *)((char *)v105 + v29 * 8);
            unint64_t v39 = compute_wNAF(v37, v36, (unint64_t *)((char *)v105 + v29 * 8));
            v107[v29] = v39;
            if (!v39) {
              break;
            }
            v30 += 1 << (v36 - 1);
            if (*v38 > v31) {
              unint64_t v31 = *v38;
            }
            ++v29;
            ++v32;
            if (v102 + v32 == 1) {
              goto LABEL_55;
            }
          }
          int v42 = 0;
          int v44 = 0;
          unint64_t v45 = 0;
          uint64_t v8 = 0;
          unint64_t v43 = v107;
          unint64_t v28 = v95;
          goto LABEL_93;
        }
        unint64_t v31 = 0;
        size_t v30 = 0;
LABEL_55:
        if (!v100)
        {
          int v44 = 0;
          unint64_t v43 = v107;
          unint64_t v28 = v95;
          goto LABEL_79;
        }
        unint64_t v43 = v107;
        unint64_t v28 = v95;
        if (v101)
        {
          size_t v110 = 0;
          if (v98)
          {
            uint64_t v46 = v101[3];
            v106[a4] = v46;
            unsigned int v47 = compute_wNAF(a3, v46, &v110);
            if (v47)
            {
              int v103 = v47;
              unint64_t v48 = v110;
              if (v110 > v31)
              {
                size_t v49 = v99;
                if (v110 < v100 * v99)
                {
                  unint64_t v50 = (v99 + v110 - 1) / v99;
                  if (v50 > v101[2])
                  {
                    ERR_put_error(16, 4095, 68, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", 520);
LABEL_162:
                    int v44 = v103;
                    goto LABEL_74;
                  }
                  unint64_t v94 = v50 + a4;
                }
                if (v94 > a4)
                {
                  unsigned int v79 = v103;
                  unint64_t v80 = (void *)v101[4];
                  int v81 = &v107[a4 + 1];
                  unint64_t v82 = a4;
                  while (1)
                  {
                    if (v82 >= v94 - 1)
                    {
                      *((void *)v105 + v82) = v48;
                      size_t v49 = v48;
                    }
                    else
                    {
                      *((void *)v105 + v82) = v49;
                      BOOL v83 = v48 >= v49;
                      v48 -= v49;
                      if (!v83)
                      {
                        int v87 = 68;
                        int v88 = 533;
                        goto LABEL_161;
                      }
                    }
                    *int v81 = 0;
                    int v84 = malloc_type_malloc(v49, 0xFE1E066CuLL);
                    *(v81 - 1) = v84;
                    if (!v84)
                    {
                      int v87 = 65;
                      int v88 = 549;
                      goto LABEL_161;
                    }
                    memcpy(v84, v79, *((void *)v105 + v82));
                    if (!*v80) {
                      break;
                    }
                    unint64_t v85 = *((void *)v105 + v82);
                    v95[v82] = v80;
                    unint64_t v86 = v82 + 1;
                    if (v85 > v31) {
                      unint64_t v31 = v85;
                    }
                    size_t v49 = v99;
                    v79 += v99;
                    v80 += v96;
                    ++v81;
                    ++v82;
                    if (v94 == v86)
                    {
                      unint64_t v43 = v107;
                      unint64_t v28 = v95;
                      goto LABEL_158;
                    }
                  }
                  int v87 = 68;
                  int v88 = 557;
LABEL_161:
                  ERR_put_error(16, 4095, v87, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", v88);
                  unint64_t v43 = v107;
                  unint64_t v28 = v95;
                  goto LABEL_162;
                }
LABEL_158:
                int v44 = v103;
LABEL_79:
                int v54 = (EC_POINT **)reallocarray(0, v30 + 1, 8uLL);
                unint64_t v45 = v54;
                if (!v54)
                {
                  ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", 575);
                  int v42 = 0;
                  goto LABEL_92;
                }
                int v104 = v44;
                int v108 = &v54[v30];
                *int v108 = 0;
                unint64_t v55 = v54;
                if (v89)
                {
                  uint64_t v56 = 0;
                  unint64_t v55 = v54;
                  while (2)
                  {
                    v28[v56] = v55;
                    unint64_t v57 = 1;
                    do
                    {
                      unint64_t v58 = EC_POINT_new(a1);
                      *unint64_t v55 = v58;
                      if (!v58)
                      {
                        int v42 = 0;
                        uint64_t v8 = 0;
                        unint64_t v28 = v95;
                        goto LABEL_90;
                      }
                      ++v55;
                    }
                    while (!(v57++ >> (v106[v56] - 1)));
                    ++v56;
                    unint64_t v28 = v95;
                    if (v56 != v89) {
                      continue;
                    }
                    break;
                  }
                }
                if (v55 != v108)
                {
                  ERR_put_error(16, 4095, 68, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", 592);
                  int v42 = 0;
                  goto LABEL_88;
                }
                int v42 = EC_POINT_new(a1);
                if (!v42)
                {
LABEL_88:
                  uint64_t v8 = 0;
LABEL_90:
                  int v26 = v106;
                  int v44 = v104;
                  unsigned int v19 = v105;
                  goto LABEL_94;
                }
                if (v89)
                {
                  unint64_t v66 = 0;
                  do
                  {
                    unint64_t v67 = v66 >= a4 ? v91 : (const EC_POINT *)v92[v66];
                    if (!EC_POINT_copy(*(EC_POINT **)v28[v66], v67)) {
                      goto LABEL_88;
                    }
                    if (v106[v66] >= 2uLL)
                    {
                      if (!EC_POINT_dbl(a1, v42, *(const EC_POINT **)v28[v66], v90)) {
                        goto LABEL_88;
                      }
                      if (v106[v66] != 1)
                      {
                        uint64_t v68 = 0;
                        do
                        {
                          int v69 = (const EC_POINT **)(v28[v66] + 8 * v68);
                          if (!EC_POINT_add(a1, v69[1], *v69, v42, v90)) {
                            goto LABEL_88;
                          }
                          unint64_t v70 = (unint64_t)(v68 + 2) >> (LOBYTE(v106[v66]) - 1);
                          ++v68;
                        }
                        while (!v70);
                      }
                    }
                  }
                  while (++v66 != v89);
                }
                if (!EC_POINTs_make_affine(a1, v30, v45, v90)) {
                  goto LABEL_88;
                }
                unint64_t v109 = v42;
                unsigned int v71 = v31 - 1;
                if ((int)v31 - 1 < 0)
                {
LABEL_143:
                  if (!EC_POINT_set_to_infinity(a1, a))
                  {
LABEL_168:
                    uint64_t v8 = 0;
LABEL_169:
                    int v26 = v106;
                    int v44 = v104;
                    unsigned int v19 = v105;
LABEL_170:
                    int v42 = v109;
                    goto LABEL_94;
                  }
                }
                else
                {
                  int v72 = 0;
                  uint64_t v8 = 1;
                  do
                  {
                    if (!v8 && !EC_POINT_dbl(a1, a, a, v90))
                    {
                      uint64_t v8 = 0;
LABEL_165:
                      int v26 = v106;
                      int v44 = v104;
                      unsigned int v19 = v105;
                      goto LABEL_170;
                    }
                    if (v94)
                    {
                      for (uint64_t i = 0; v94 != i; ++i)
                      {
                        if (*((void *)v105 + i) > (unint64_t)v71)
                        {
                          unsigned int v74 = *((unsigned __int8 *)v43[i] + v71);
                          if (*((unsigned char *)v43[i] + v71))
                          {
                            if ((v74 & 0x80u) == 0) {
                              LOBYTE(v75) = *((unsigned char *)v43[i] + v71);
                            }
                            else {
                              int v75 = -(char)v74;
                            }
                            if (v72 != v74 >> 7)
                            {
                              if (!v8 && !EC_POINT_invert(a1, a, v90))
                              {
                                uint64_t v8 = 0;
                                unint64_t v28 = v95;
                                goto LABEL_165;
                              }
                              int v72 = v72 == 0;
                            }
                            uint64_t v76 = v95[i];
                            if (v8)
                            {
                              int v77 = EC_POINT_copy(a, *(const EC_POINT **)(v76 + 8 * (v75 >> 1)));
                              uint64_t v8 = 0;
                            }
                            else
                            {
                              int v77 = EC_POINT_add(a1, a, a, *(const EC_POINT **)(v76 + 8 * (v75 >> 1)), v90);
                            }
                            unint64_t v28 = v95;
                            if (!v77) {
                              goto LABEL_165;
                            }
                          }
                        }
                      }
                    }
                    BOOL v78 = __OFSUB__(v71--, 1);
                  }
                  while (((v71 & 0x80000000) != 0) == v78);
                  if (v8) {
                    goto LABEL_143;
                  }
                  if (v72 && !EC_POINT_invert(a1, a, v90)) {
                    goto LABEL_168;
                  }
                }
                uint64_t v8 = 1;
                goto LABEL_169;
              }
              v107[a4] = v47;
              unint64_t v94 = a4 + 1;
              v107[a4 + 1] = 0;
              *((void *)v105 + a4) = v48;
              v95[a4] = v101[4];
LABEL_78:
              int v44 = 0;
              goto LABEL_79;
            }
          }
          else
          {
            ERR_put_error(16, 4095, 68, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", 470);
          }
          int v44 = 0;
LABEL_74:
          int v42 = 0;
          goto LABEL_75;
        }
        if ((v97 & 1) == 0)
        {
          ERR_put_error(16, 4095, 68, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", 462);
          int v42 = 0;
          int v44 = 0;
LABEL_75:
          unint64_t v45 = 0;
LABEL_92:
          uint64_t v8 = 0;
LABEL_93:
          int v26 = v106;
          unsigned int v19 = v105;
          goto LABEL_94;
        }
        goto LABEL_78;
      }
      ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", 436);
      int v42 = 0;
      int v44 = 0;
      unint64_t v45 = 0;
      uint64_t v8 = 0;
      unint64_t v43 = v107;
LABEL_94:
      EC_POINT_free(v42);
      free(v26);
      free(v19);
      free(v44);
      if (v43)
      {
        int v60 = *v43;
        if (*v43)
        {
          unint64_t v61 = v43 + 1;
          do
          {
            free(v60);
            unsigned int v62 = *v61++;
            int v60 = v62;
          }
          while (v62);
        }
        free(v43);
      }
      if (v45)
      {
        int v63 = *v45;
        if (*v45)
        {
          unint64_t v64 = v45 + 1;
          do
          {
            EC_POINT_free(v63);
            int v65 = *v64++;
            int v63 = v65;
          }
          while (v65);
        }
        free(v45);
      }
      free(v28);
      return v8;
    }
    int v40 = 65;
    int v41 = 425;
    goto LABEL_50;
  }
  return EC_POINT_set_to_infinity(a1, a2);
}

uint64_t ec_pre_comp_dup(uint64_t a1)
{
  return a1;
}

void ec_pre_comp_free(uint64_t a1)
{
  if (a1 && CRYPTO_add_lock((int *)(a1 + 48), -1, 36, 0, 0) <= 0)
  {
    uint64_t v2 = *(EC_POINT ***)(a1 + 32);
    if (v2)
    {
      int v3 = *v2;
      if (*v2)
      {
        int v4 = v2 + 1;
        do
        {
          EC_POINT_free(v3);
          uint64_t v5 = *v4++;
          int v3 = v5;
        }
        while (v5);
        uint64_t v2 = *(EC_POINT ***)(a1 + 32);
      }
      free(v2);
    }
    free((void *)a1);
  }
}

void *ec_pre_comp_clear_free(void *result)
{
  if (result)
  {
    unint64_t v1 = result;
    int result = (void *)CRYPTO_add_lock((int *)result + 12, -1, 36, 0, 0);
    if ((int)result <= 0)
    {
      uint64_t v2 = (EC_POINT **)v1[4];
      if (v2)
      {
        if (*v2)
        {
          EC_POINT_free(*v2);
          explicit_bzero(v2, 8uLL);
        }
        free(v2);
      }
      return freezero(v1, 0x38uLL);
    }
  }
  return result;
}

unsigned char *compute_wNAF(const BIGNUM *a1, unsigned int a2, unint64_t *a3)
{
  if (BN_is_zero((uint64_t)a1))
  {
    uint64_t v6 = malloc_type_malloc(1uLL, 0x6423EC1FuLL);
    int v7 = v6;
    if (!v6)
    {
      int v10 = 65;
      int v11 = 207;
      goto LABEL_8;
    }
    *uint64_t v6 = 0;
    unint64_t v8 = 1;
LABEL_4:
    *a3 = v8;
    return v7;
  }
  if (a2 - 8 <= 0xFFFFFFF8)
  {
    int v9 = 217;
LABEL_34:
    ERR_put_error(16, 4095, 68, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", v9);
    int v7 = 0;
    goto LABEL_35;
  }
  BOOL is_negative = BN_is_negative((uint64_t)a1);
  if (!a1->d || !a1->top)
  {
    int v9 = 228;
    goto LABEL_34;
  }
  BOOL v13 = is_negative;
  unint64_t v14 = BN_num_bits(a1);
  int v7 = malloc_type_malloc(v14 + 1, 0x2232A5FEuLL);
  if (!v7)
  {
    int v10 = 65;
    int v11 = 237;
    goto LABEL_8;
  }
  unint64_t v8 = 0;
  uint64_t v15 = a2;
  int v16 = 1 << a2;
  int v17 = 2 << a2;
  int v18 = (v17 - 1) & *(_DWORD *)a1->d;
  while (v18)
  {
    if ((v18 & 1) == 0) {
      goto LABEL_28;
    }
    signed int v19 = v18 - v17;
    if (v15 + v8 + 1 >= v14) {
      signed int v19 = v18 & ((v17 - 1) >> 1);
    }
    int v20 = v19 & 1;
    if ((v18 & v16) == 0)
    {
      int v20 = 1;
      signed int v19 = v18;
    }
    if (v19 <= -v16 || v19 >= v16 || !v20)
    {
      int v10 = 68;
      int v11 = 271;
      goto LABEL_8;
    }
    v18 -= v19;
    if (v18 && v18 != v17 && v18 != v16)
    {
      int v10 = 68;
      int v11 = 282;
      goto LABEL_8;
    }
LABEL_29:
    if (v13) {
      signed int v19 = -v19;
    }
    unint64_t v21 = v8 + 1;
    v7[v8] = v19;
    int v18 = (BN_is_bit_set(a1, v15 + v8 + 1) << v15) + (v18 >> 1);
    unint64_t v8 = v21;
    if (v18 > v17)
    {
      int v10 = 68;
      int v11 = 292;
      goto LABEL_8;
    }
  }
  if (v15 + v8 + 1 < v14)
  {
    int v18 = 0;
LABEL_28:
    signed int v19 = 0;
    goto LABEL_29;
  }
  if (v8 <= v14 + 1) {
    goto LABEL_4;
  }
  int v10 = 68;
  int v11 = 298;
LABEL_8:
  ERR_put_error(16, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", v11);
LABEL_35:
  free(v7);
  return 0;
}

BOOL ec_wNAF_precompute_mult(uint64_t a1, BN_CTX *a2)
{
  uint64_t v4 = a1 + 96;
  EC_EX_DATA_free_data((void **)(a1 + 96), (uint64_t)ec_pre_comp_dup, (void (*)(void *))ec_pre_comp_free, ec_pre_comp_clear_free);
  if (!a1) {
    return 0;
  }
  uint64_t v5 = (char *)malloc_type_malloc(0x38uLL, 0x10E00400304B0BDuLL);
  if (!v5)
  {
    ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", 110);
    return 0;
  }
  uint64_t v6 = v5;
  *(void *)uint64_t v5 = a1;
  *(_OWORD *)(v5 + 8) = xmmword_23C709A80;
  *((void *)v5 + 4) = 0;
  *((void *)v5 + 5) = 0;
  *((void *)v5 + 3) = 4;
  *((_DWORD *)v5 + 12) = 1;
  int v7 = EC_GROUP_get0_generator((const EC_GROUP *)a1);
  if (!v7)
  {
    int v10 = 113;
    int v11 = 737;
    goto LABEL_11;
  }
  unint64_t v8 = v7;
  BN_CTX_start(a2);
  int v9 = BN_CTX_get(a2);
  if (!v9) {
    goto LABEL_35;
  }
  if (!EC_GROUP_get_order((const EC_GROUP *)a1, v9, a2))
  {
LABEL_12:
    BOOL v13 = 0;
    unint64_t v14 = 0;
    int v9 = 0;
    goto LABEL_37;
  }
  if (BN_is_zero((uint64_t)v9))
  {
    int v10 = 114;
    int v11 = 749;
LABEL_11:
    ERR_put_error(16, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", v11);
    goto LABEL_12;
  }
  unsigned int v15 = BN_num_bits(v9);
  uint64_t v16 = 5;
  if (v15 > 0x7CF) {
    uint64_t v16 = 6;
  }
  if (v15 <= 0x31F) {
    uint64_t v17 = 4;
  }
  else {
    uint64_t v17 = v16;
  }
  unint64_t v18 = (int)v15 + 7;
  char v39 = v17 - 1;
  size_t v19 = v18 >> 3 << (v17 - 1);
  int v20 = (BIGNUM *)reallocarray(0, v19 + 1, 8uLL);
  int v9 = v20;
  if (!v20)
  {
    int v25 = 777;
LABEL_34:
    ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", v25);
LABEL_35:
    BOOL v13 = 0;
    goto LABEL_36;
  }
  unint64_t v38 = v18 >> 3;
  *((void *)&v20->d + v19) = 0;
  if (v19)
  {
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t v22 = EC_POINT_new((const EC_GROUP *)a1);
      *((void *)&v9->d + v21) = v22;
      if (!v22) {
        break;
      }
      if (v19 == ++v21) {
        goto LABEL_23;
      }
    }
    int v25 = 784;
    goto LABEL_34;
  }
LABEL_23:
  uint64_t v37 = v17;
  BOOL v13 = EC_POINT_new((const EC_GROUP *)a1);
  if (!v13 || (uint64_t v23 = EC_POINT_new((const EC_GROUP *)a1)) == 0)
  {
    ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_mult.c", 790);
LABEL_36:
    unint64_t v14 = 0;
    goto LABEL_37;
  }
  unint64_t v14 = v23;
  if (EC_POINT_copy(v23, v8))
  {
    if (v18 >= 8)
    {
      uint64_t v30 = v18 >> 3;
      unint64_t v36 = 0;
      if (v38 <= 1) {
        uint64_t v30 = 1;
      }
      uint64_t v35 = v30;
      unint64_t v31 = (EC_POINT **)v9;
LABEL_48:
      if (EC_POINT_dbl((const EC_GROUP *)a1, v13, v14, a2) && EC_POINT_copy(*v31, v14))
      {
        ++v31;
        unint64_t v32 = 2;
        while (EC_POINT_add((const EC_GROUP *)a1, *v31, v13, *(v31 - 1), a2))
        {
          ++v31;
          if (v32++ >> v39)
          {
            if (v36 < v38 - 1)
            {
              if (EC_POINT_dbl((const EC_GROUP *)a1, v14, v13, a2))
              {
                uint64_t v34 = 6;
                while (EC_POINT_dbl((const EC_GROUP *)a1, v14, v14, a2))
                {
                  if (!--v34) {
                    goto LABEL_58;
                  }
                }
              }
              break;
            }
LABEL_58:
            if (++v36 != v35) {
              goto LABEL_48;
            }
            goto LABEL_27;
          }
        }
      }
    }
    else
    {
LABEL_27:
      if (EC_POINTs_make_affine((const EC_GROUP *)a1, v19, (EC_POINT **)v9, a2))
      {
        *uint64_t v6 = a1;
        v6[1] = 8;
        void v6[2] = v38;
        void v6[3] = v37;
        v6[4] = v9;
        v6[5] = v19;
        int v24 = EC_EX_DATA_set_data(v4, (uint64_t)v6, (uint64_t)ec_pre_comp_dup, (uint64_t)ec_pre_comp_free, (uint64_t)ec_pre_comp_clear_free);
        int v9 = 0;
        BOOL v12 = v24 != 0;
        if (v24) {
          uint64_t v6 = 0;
        }
        goto LABEL_38;
      }
    }
  }
LABEL_37:
  BOOL v12 = 0;
LABEL_38:
  BN_CTX_end(a2);
  ec_pre_comp_free((uint64_t)v6);
  if (v9)
  {
    char d = (EC_POINT *)v9->d;
    if (v9->d)
    {
      p_size_t top = &v9->top;
      do
      {
        EC_POINT_free(d);
        unint64_t v28 = *(EC_POINT **)p_top;
        p_top += 2;
        char d = v28;
      }
      while (v28);
    }
    free(v9);
  }
  EC_POINT_free(v13);
  EC_POINT_free(v14);
  return v12;
}

BOOL ec_wNAF_have_precompute_mult(uint64_t a1)
{
  return EC_EX_DATA_get_data(*(void **)(a1 + 96), (uint64_t)ec_pre_comp_dup, (uint64_t)ec_pre_comp_free, (uint64_t)ec_pre_comp_clear_free) != 0;
}

X509_REVOKED *__cdecl d2i_X509_REVOKED(X509_REVOKED **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_REVOKED *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_REVOKED_it);
}

int i2d_X509_REVOKED(X509_REVOKED *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_REVOKED_it);
}

X509_REVOKED *X509_REVOKED_new(void)
{
  return (X509_REVOKED *)ASN1_item_new(&X509_REVOKED_it);
}

void X509_REVOKED_free(X509_REVOKED *a)
{
}

void *X509_REVOKED_dup(void *x)
{
  return ASN1_item_dup(&X509_REVOKED_it, x);
}

X509_CRL_INFO *__cdecl d2i_X509_CRL_INFO(X509_CRL_INFO **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_CRL_INFO *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_CRL_INFO_it);
}

int i2d_X509_CRL_INFO(X509_CRL_INFO *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_CRL_INFO_it);
}

X509_CRL_INFO *X509_CRL_INFO_new(void)
{
  return (X509_CRL_INFO *)ASN1_item_new(&X509_CRL_INFO_it);
}

void X509_CRL_INFO_free(X509_CRL_INFO *a)
{
}

X509_CRL *__cdecl d2i_X509_CRL(X509_CRL **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_CRL *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_CRL_it);
}

int i2d_X509_CRL(X509_CRL *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_CRL_it);
}

X509_CRL *X509_CRL_new(void)
{
  return (X509_CRL *)ASN1_item_new(&X509_CRL_it);
}

void X509_CRL_free(X509_CRL *a)
{
}

X509_CRL *__cdecl X509_CRL_dup(X509_CRL *crl)
{
  return (X509_CRL *)ASN1_item_dup(&X509_CRL_it, crl);
}

int X509_CRL_add0_revoked(X509_CRL *crl, X509_REVOKED *rev)
{
  int v3 = crl->crl;
  revokechar d = crl->crl->revoked;
  if ((revoked
     || (revokechar d = sk_new((int (__cdecl *)(const char *const *, const char *const *))X509_REVOKED_cmp),
         (v3->revokechar d = revoked) != 0))
    && sk_push(revoked, (char *)rev))
  {
    int result = 1;
    v3->enc.modifiechar d = 1;
  }
  else
  {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/x_crl.c", 541);
    return 0;
  }
  return result;
}

uint64_t X509_REVOKED_cmp(ASN1_INTEGER ***a1, ASN1_INTEGER ***a2)
{
  return ASN1_INTEGER_cmp(**a1, **a2);
}

int X509_CRL_verify(X509_CRL *a, EVP_PKEY *r)
{
  unint64_t data = a[4].signature[1].data;
  if (data) {
    return ((uint64_t (*)(void))data)();
  }
  else {
    return 0;
  }
}

uint64_t X509_CRL_get0_by_serial(uint64_t a1)
{
  unint64_t v1 = *(uint64_t (**)(void))(*(void *)(a1 + 144) + 24);
  if (v1) {
    return v1();
  }
  else {
    return 0;
  }
}

uint64_t X509_CRL_get0_by_cert(uint64_t a1, uint64_t a2, X509 *x)
{
  uint64_t v4 = *(void *)(a1 + 144);
  uint64_t result = *(void *)(v4 + 24);
  if (result)
  {
    int v10 = *(uint64_t (**)(uint64_t, uint64_t, ASN1_INTEGER *, X509_NAME *))(v4 + 24);
    serialNumbeBIGNUM r = X509_get_serialNumber(x);
    issuer_name = X509_get_issuer_name(x);
    return v10(a1, a2, serialNumber, issuer_name);
  }
  return result;
}

void *X509_CRL_set_default_method(void *result)
{
  unint64_t v1 = &int_crl_meth;
  if (result) {
    unint64_t v1 = result;
  }
  default_crl_methochar d = (uint64_t)v1;
  return result;
}

void *X509_CRL_METHOD_new(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = malloc_type_calloc(1uLL, 0x28uLL, 0x1080040E6FF41AEuLL);
  if (result)
  {
    result[1] = a1;
    result[2] = a2;
    result[3] = a3;
    result[4] = a4;
    *(_DWORD *)uint64_t result = 1;
  }
  return result;
}

void X509_CRL_METHOD_free(void *a1)
{
  if (a1)
  {
    if (*(unsigned char *)a1) {
      free(a1);
    }
  }
}

uint64_t X509_CRL_set_meth_data(uint64_t result, uint64_t a2)
{
  *(void *)(result + 152) = a2;
  return result;
}

uint64_t X509_CRL_get_meth_data(uint64_t a1)
{
  return *(void *)(a1 + 152);
}

uint64_t X509_CRL_get_signature_nid(uint64_t a1)
{
  return OBJ_obj2nid(**(const ASN1_OBJECT ***)(a1 + 8));
}

uint64_t X509_CRL_get0_extensions(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 48);
}

uint64_t X509_CRL_get_version(ASN1_INTEGER ***a1)
{
  return ASN1_INTEGER_get(**a1);
}

uint64_t X509_CRL_get0_lastUpdate(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 24);
}

uint64_t X509_CRL_get_lastUpdate(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 24);
}

uint64_t X509_CRL_get0_nextUpdate(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 32);
}

uint64_t X509_CRL_get_nextUpdate(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 32);
}

uint64_t X509_CRL_get_issuer(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 16);
}

uint64_t X509_CRL_get_REVOKED(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 40);
}

uint64_t X509_CRL_get0_signature(uint64_t result, void *a2, void *a3)
{
  if (a2) {
    *a2 = *(void *)(result + 16);
  }
  if (a3) {
    *a3 = *(void *)(result + 8);
  }
  return result;
}

uint64_t X509_CRL_get0_tbs_sigalg(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 8);
}

uint64_t crl_inf_cb(int a1, uint64_t a2)
{
  if (*(void *)a2)
  {
    if (a1 == 5)
    {
      uint64_t v2 = *(STACK **)(*(void *)a2 + 40);
      if (v2) {
        sk_set_cmp_func(v2, (int (__cdecl *)(const char *const *, const char *const *))X509_REVOKED_cmp);
      }
    }
  }
  return 1;
}

BOOL crl_cb(int a1, void *a2)
{
  uint64_t v2 = *a2;
  if (a1 == 5)
  {
    int v3 = EVP_sha512();
    X509_CRL_digest((const X509_CRL *)v2, v3, (unsigned __int8 *)(v2 + 72), 0);
    ext_d2uint64_t i = (int *)X509_CRL_get_ext_d2i((X509_CRL *)v2, 770, 0, 0);
    *(void *)(v2 + 40) = ext_d2i;
    if (ext_d2i)
    {
      int v5 = *(_DWORD *)(v2 + 48);
      int v6 = v5 | 1;
      *(_DWORD *)(v2 + 48) = v5 | 1;
      if (ext_d2i[2] < 1)
      {
        unsigned int v7 = 0;
      }
      else
      {
        int v6 = v5 | 5;
        *(_DWORD *)(v2 + 48) = v5 | 5;
        unsigned int v7 = 1;
      }
      if (ext_d2i[3] >= 1)
      {
        ++v7;
        v6 |= 8u;
        *(_DWORD *)(v2 + 48) = v6;
      }
      int v12 = ext_d2i[7];
      if (v12 > 0)
      {
        v6 |= 0x10u;
        ++v7;
      }
      if (v7 > 1) {
        v6 |= 2u;
      }
      if (v12 > 0 || v7 >= 2) {
        *(_DWORD *)(v2 + 48) = v6;
      }
      if (ext_d2i[6] >= 1)
      {
        v6 |= 0x20u;
        *(_DWORD *)(v2 + 48) = v6;
      }
      uint64_t v14 = *((void *)ext_d2i + 2);
      if (v14)
      {
        *(_DWORD *)(v2 + 48) = v6 | 0x40;
        int v15 = *(_DWORD *)v14;
        if (*(int *)v14 <= 0)
        {
          int v17 = *(_DWORD *)(v2 + 52);
        }
        else
        {
          uint64_t v16 = *(unsigned __int8 **)(v14 + 8);
          int v17 = *v16;
          *(_DWORD *)(v2 + 52) = v17;
          if (v15 != 1) {
            LOWORD(v17) = v17 | (v16[1] << 8);
          }
        }
        *(_DWORD *)(v2 + 52) = v17 & 0x807F;
      }
      DIST_POINT_set_dpname(*(void *)ext_d2i, *(X509_NAME **)(*(void *)v2 + 16));
    }
    *(void *)(v2 + 32) = X509_CRL_get_ext_d2i((X509_CRL *)v2, 90, 0, 0);
    *(void *)(v2 + 56) = X509_CRL_get_ext_d2i((X509_CRL *)v2, 88, 0, 0);
    unint64_t v18 = X509_CRL_get_ext_d2i((X509_CRL *)v2, 140, 0, 0);
    *(void *)(v2 + 64) = v18;
    if (v18 && !*(void *)(v2 + 56)) {
      *(_DWORD *)(v2 + 28) |= 0x80u;
    }
    size_t v19 = *(const STACK **)(*(void *)v2 + 48);
    if (sk_num(v19) >= 1)
    {
      int v20 = 0;
      while (1)
      {
        uint64_t v21 = sk_value(v19, v20);
        int v22 = OBJ_obj2nid(*(const ASN1_OBJECT **)v21);
        if (v22 == 857) {
          *(_DWORD *)(v2 + 28) |= 0x1000u;
        }
        if (*((int *)v21 + 2) >= 1) {
          break;
        }
        if (++v20 >= sk_num(v19)) {
          goto LABEL_52;
        }
      }
      if (v22 != 90 && v22 != 140 && v22 != 770) {
        *(_DWORD *)(v2 + 28) |= 0x200u;
      }
    }
LABEL_52:
    int crit = 0;
    uint64_t v23 = *(const STACK **)(*(void *)v2 + 40);
    if (sk_num(v23) >= 1)
    {
      int v24 = 0;
      int v25 = 0;
      while (1)
      {
        int v26 = sk_value(v23, v25);
        int v27 = (char *)X509_REVOKED_get_ext_d2i((X509_REVOKED *)v26, 771, &crit, 0);
        unint64_t v28 = v27;
        if (!v27 && crit != -1) {
          break;
        }
        if (v27)
        {
          uint64_t v29 = *(STACK **)(v2 + 136);
          if (!v29)
          {
            uint64_t v29 = sk_new_null();
            *(void *)(v2 + 136) = v29;
            if (!v29) {
              return 0;
            }
          }
          int v24 = v28;
          if (!sk_push(v29, v28)) {
            return 0;
          }
        }
        *((void *)v26 + 3) = v24;
        uint64_t v30 = (ASN1_ENUMERATED *)X509_REVOKED_get_ext_d2i((X509_REVOKED *)v26, 141, &crit, 0);
        unint64_t v31 = v30;
        if (!v30 && crit != -1) {
          break;
        }
        if (v30)
        {
          *((_DWORD *)v26 + 8) = ASN1_ENUMERATED_get(v30);
          ASN1_ENUMERATED_free(v31);
        }
        else
        {
          *((_DWORD *)v26 + 8) = -1;
        }
        unint64_t v32 = (const STACK *)*((void *)v26 + 2);
        int crit = 0;
        if (sk_num(v32) >= 1)
        {
          while (1)
          {
            unsigned int v33 = sk_value(v32, crit);
            if (*((int *)v33 + 2) >= 1 && OBJ_obj2nid(*(const ASN1_OBJECT **)v33) != 771) {
              break;
            }
            int v34 = ++crit;
            if (v34 >= sk_num(v32)) {
              goto LABEL_71;
            }
          }
          *(_DWORD *)(v2 + 28) |= 0x200u;
        }
LABEL_71:
        if (++v25 >= sk_num(v23)) {
          goto LABEL_74;
        }
      }
      *(_DWORD *)(v2 + 28) |= 0x80u;
    }
LABEL_74:
    uint64_t v35 = *(unsigned int (**)(uint64_t))(*(void *)(v2 + 144) + 8);
    return !v35 || v35(v2);
  }
  if (a1 != 3)
  {
    if (a1 == 1)
    {
      *(void *)(v2 + 36) = 0;
      *(void *)(v2 + 28) = 0;
      *(void *)(v2 + 44) = 0;
      *(_DWORD *)(v2 + 52) = 32895;
      *(void *)(v2 + 144) = default_crl_method;
      *(void *)(v2 + 152) = 0;
      *(void *)(v2 + 136) = 0;
      *(void *)(v2 + 56) = 0;
      *(void *)(v2 + 64) = 0;
    }
    return 1;
  }
  unint64_t v8 = *(unsigned int (**)(void))(*(void *)(v2 + 144) + 16);
  if (v8) {
    BOOL v9 = v8(*a2) != 0;
  }
  else {
    BOOL v9 = 1;
  }
  int v10 = *(AUTHORITY_KEYID **)(v2 + 32);
  if (v10) {
    AUTHORITY_KEYID_free(v10);
  }
  int v11 = *(ASN1_VALUE **)(v2 + 40);
  if (v11) {
    ISSUING_DIST_POINT_free(v11);
  }
  ASN1_INTEGER_free(*(ASN1_INTEGER **)(v2 + 56));
  ASN1_INTEGER_free(*(ASN1_INTEGER **)(v2 + 64));
  sk_pop_free(*(STACK **)(v2 + 136), (void (__cdecl *)(void *))GENERAL_NAMES_free);
  return v9;
}

uint64_t def_crl_lookup(uint64_t a1, char **a2, ASN1_INTEGER *a3, const X509_NAME *a4)
{
  *(void *)unint64_t data = a3;
  if (!sk_is_sorted(*(const STACK **)(*(void *)a1 + 40)))
  {
    CRYPTO_lock(9, 6, 0, 0);
    sk_sort(*(STACK **)(*(void *)a1 + 40));
    CRYPTO_lock(10, 6, 0, 0);
  }
  long long v17 = 0u;
  long long v18 = 0u;
  int v8 = sk_find(*(STACK **)(*(void *)a1 + 40), data);
  if ((v8 & 0x80000000) == 0)
  {
    for (int i = v8; i < sk_num(*(const STACK **)(*(void *)a1 + 40)); ++i)
    {
      int v10 = sk_value(*(const STACK **)(*(void *)a1 + 40), i);
      if (ASN1_INTEGER_cmp(*(ASN1_INTEGER **)v10, a3)) {
        break;
      }
      int v11 = (const STACK *)*((void *)v10 + 3);
      if (v11)
      {
        int v12 = a4;
        if (!a4) {
          int v12 = *(const X509_NAME **)(*(void *)a1 + 16);
        }
        if (sk_num(v11) >= 1)
        {
          int v13 = 0;
          while (1)
          {
            uint64_t v14 = sk_value(*((const STACK **)v10 + 3), v13);
            if (*(_DWORD *)v14 == 4 && !X509_NAME_cmp(v12, *((const X509_NAME **)v14 + 1))) {
              break;
            }
            if (++v13 >= sk_num(*((const STACK **)v10 + 3))) {
              goto LABEL_18;
            }
          }
LABEL_20:
          if (a2) {
            *a2 = v10;
          }
          if (*((_DWORD *)v10 + 8) == 8) {
            return 2;
          }
          else {
            return 1;
          }
        }
      }
      else if (!a4 || !X509_NAME_cmp(a4, *(const X509_NAME **)(*(void *)a1 + 16)))
      {
        goto LABEL_20;
      }
LABEL_18:
      ;
    }
  }
  return 0;
}

uint64_t def_crl_verify(uint64_t a1, EVP_PKEY *pkey)
{
  return ASN1_item_verify(&X509_CRL_INFO_it, *(X509_ALGOR **)(a1 + 8), *(ASN1_BIT_STRING **)(a1 + 16), *(void **)a1, pkey);
}

int AES_wrap_key(AES_KEY *key, const unsigned __int8 *iv, unsigned __int8 *out, const unsigned __int8 *in, unsigned int inlen)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  int result = -1;
  if (inlen >= 0x10 && (inlen & 7) == 0)
  {
    memmove(out + 8, in, inlen);
    int v10 = 0;
    int v11 = (const unsigned __int8 *)&default_iv;
    if (iv) {
      int v11 = iv;
    }
    *(void *)outEVP_CIPHER_CTX a = *(void *)v11;
    unsigned int v12 = 1;
    do
    {
      uint64_t v13 = 0;
      do
      {
        uint64_t v15 = *(void *)&out[v13 + 8];
        AES_encrypt(outa, outa, key);
        outa[7] ^= v12;
        if (v12 >= 0x100)
        {
          outa[6] ^= BYTE1(v12);
          outa[5] ^= BYTE2(v12);
          outa[4] ^= HIBYTE(v12);
        }
        *(void *)&out[v13 + 8] = v15;
        ++v12;
        v13 += 8;
      }
      while (v13 < inlen);
      ++v10;
    }
    while (v10 != 6);
    *(void *)unsigned __int8 out = *(void *)outa;
    return inlen + 8;
  }
  return result;
}

int AES_unwrap_key(AES_KEY *key, const unsigned __int8 *iv, unsigned __int8 *out, const unsigned __int8 *in, unsigned int inlen)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  LODWORD(v5) = -1;
  if (inlen >= 0x18 && (inlen & 7) == 0)
  {
    size_t v5 = inlen - 8;
    unsigned int v9 = 6 * (v5 >> 3);
    *(void *)outEVP_CIPHER_CTX a = *(void *)in;
    memmove(out, in + 8, v5);
    for (int i = 0; i != 6; ++i)
    {
      unsigned int v11 = 0;
      size_t v12 = v5 - 8;
      do
      {
        outa[7] ^= v9;
        if (v9 >= 0x100)
        {
          outa[6] ^= BYTE1(v9);
          outa[5] ^= BYTE2(v9);
          outa[4] ^= HIBYTE(v9);
        }
        uint64_t v16 = *(void *)&out[v12];
        AES_decrypt(outa, outa, key);
        *(void *)&out[v12] = v16;
        v11 += 8;
        --v9;
        v12 -= 8;
      }
      while (v11 < v5);
    }
    uint64_t v13 = (const unsigned __int8 *)&default_iv;
    if (iv) {
      uint64_t v13 = iv;
    }
    if (*(void *)outa != *(void *)v13) {
      explicit_bzero(out, v5);
    }
  }
  return v5;
}

void ERR_load_PKCS12_strings(void)
{
  if (!ERR_func_error_string(PKCS12_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&PKCS12_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&PKCS12_str_reasons);
  }
}

void ECDSA_set_default_method(const ECDSA_METHOD *meth)
{
  default_ECDSA_methochar d = (uint64_t)meth;
}

const ECDSA_METHOD *ECDSA_get_default_method(void)
{
  int result = (const ECDSA_METHOD *)default_ECDSA_method;
  if (!default_ECDSA_method)
  {
    int result = ECDSA_OpenSSL();
    default_ECDSA_methochar d = (uint64_t)result;
  }
  return result;
}

int ECDSA_set_method(EC_KEY *eckey, const ECDSA_METHOD *meth)
{
  int v3 = (ENGINE **)ecdsa_check(eckey);
  if (v3)
  {
    uint64_t v4 = v3;
    ENGINE_finish(v3[1]);
    v4[1] = 0;
    v4[3] = meth;
    LODWORD(v3) = 1;
  }
  return (int)v3;
}

void *ecdsa_check(EC_KEY *a1)
{
  key_method_unint64_t data = EC_KEY_get_key_method_data(a1, (void *(__cdecl *)(void *))ecdsa_data_dup, (void (__cdecl *)(void *))ecdsa_data_free, (void (__cdecl *)(void *))ecdsa_data_free);
  if (!key_method_data)
  {
    key_method_unint64_t data = ecdsa_data_new();
    if (key_method_data)
    {
      EC_KEY_insert_key_method_data(a1, key_method_data, (void *(__cdecl *)(void *))ecdsa_data_dup, (void (__cdecl *)(void *))ecdsa_data_free, (void (__cdecl *)(void *))ecdsa_data_free);
      if (v3)
      {
        uint64_t v4 = v3;
        ecdsa_data_free((uint64_t)key_method_data);
        return (void *)v4;
      }
    }
  }
  return key_method_data;
}

CRYPTO_EX_DATA *ecdsa_data_dup(CRYPTO_EX_DATA *result)
{
  if (result) {
    return ecdsa_data_new();
  }
  return result;
}

void *ecdsa_data_free(uint64_t a1)
{
  ENGINE_finish(*(ENGINE **)(a1 + 8));
  CRYPTO_free_ex_data(12, (void *)a1, (CRYPTO_EX_DATA *)(a1 + 32));
  return freezero((void *)a1, 0x28uLL);
}

CRYPTO_EX_DATA *ecdsa_data_new()
{
  int v0 = (CRYPTO_EX_DATA *)malloc_type_malloc(0x28uLL, 0x10E00407A09E776uLL);
  unint64_t v1 = v0;
  if (!v0)
  {
    ERR_put_error(42, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_lib.c", 116);
    return v1;
  }
  v0->suint64_t k = 0;
  uint64_t v2 = (const ECDSA_METHOD *)default_ECDSA_method;
  if (!default_ECDSA_method)
  {
    uint64_t v2 = ECDSA_OpenSSL();
    default_ECDSA_methochar d = (uint64_t)v2;
  }
  *(void *)&v1[1].dummy = v2;
  *(void *)&v1->dummy = 0;
  default_ECDSA = ENGINE_get_default_ECDSA();
  *(void *)&v1->dummy = default_ECDSA;
  if (!default_ECDSA)
  {
    ECDSA = *(const ECDSA_METHOD **)&v1[1].dummy;
    goto LABEL_9;
  }
  ECDSA = ENGINE_get_ECDSA(default_ECDSA);
  *(void *)&v1[1].dummy = ECDSA;
  if (ECDSA)
  {
LABEL_9:
    LODWORD(v1[1].sk) = *((_DWORD *)ECDSA + 8);
    CRYPTO_new_ex_data(12, v1, v1 + 2);
    return v1;
  }
  ERR_put_error(42, 4095, 38, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_lib.c", 130);
  ENGINE_finish(*(ENGINE **)&v1->dummy);
  free(v1);
  return 0;
}

int ECDSA_size(const EC_KEY *eckey)
{
  v5.BIGNUM r = 0;
  v5.unsigned int s = 0;
  if (!eckey)
  {
    uint64_t v2 = 0;
LABEL_7:
    LODWORD(v1) = 0;
    goto LABEL_9;
  }
  unint64_t v1 = EC_KEY_get0_group(eckey);
  if (!v1)
  {
    uint64_t v2 = 0;
    goto LABEL_9;
  }
  uint64_t v2 = BN_new();
  if (!v2 || !EC_GROUP_get_order(v1, v2, 0)) {
    goto LABEL_7;
  }
  v5.BIGNUM r = v2;
  v5.unsigned int s = v2;
  int v3 = i2d_ECDSA_SIG(&v5, 0);
  LODWORD(v1) = v3 & ~(v3 >> 31);
LABEL_9:
  BN_free(v2);
  return (int)v1;
}

int ECDSA_get_ex_new_index(uint64_t argl, void *argp, CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
  return CRYPTO_get_ex_new_index(12, argl, argp, new_func, dup_func, free_func);
}

int ECDSA_set_ex_data(EC_KEY *d, int idx, void *arg)
{
  ECDSA_SIG v5 = (CRYPTO_EX_DATA *)ecdsa_check(d);
  if (v5)
  {
    int v6 = v5 + 2;
    LODWORD(v5) = CRYPTO_set_ex_data(v6, idx, arg);
  }
  return (int)v5;
}

void *__cdecl ECDSA_get_ex_data(EC_KEY *d, int idx)
{
  int result = ecdsa_check(d);
  if (result)
  {
    uint64_t v4 = (const CRYPTO_EX_DATA *)((char *)result + 32);
    return CRYPTO_get_ex_data(v4, idx);
  }
  return result;
}

X509_SIG *__cdecl PKCS8_encrypt(int pbe_nid, const EVP_CIPHER *cipher, const char *pass, int passlen, unsigned __int8 *salt, int saltlen, int iter, PKCS8_PRIV_KEY_INFO *p8)
{
  uint64_t v16 = X509_SIG_new();
  if (!v16)
  {
    int v18 = 65;
    int v19 = 75;
LABEL_10:
    ERR_put_error(35, 4095, v18, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs12/p12_p8e.c", v19);
    X509_SIG_free(v16);
    return 0;
  }
  if (pbe_nid == -1) {
    uint64_t v17 = PKCS5_pbe2_set(cipher, iter, salt, saltlen);
  }
  else {
    uint64_t v17 = PKCS5_pbe_set(pbe_nid, iter, salt, saltlen);
  }
  int v20 = v17;
  if (!v17)
  {
    int v18 = 13;
    int v19 = 84;
    goto LABEL_10;
  }
  X509_ALGOR_free(v16->algor);
  v16->algoBIGNUM r = v20;
  ASN1_OCTET_STRING_free(v16->digest);
  uint64_t v21 = PKCS12_item_i2d_encrypt(v20, &PKCS8_PRIV_KEY_INFO_it, pass, passlen, p8, 1);
  v16->digest = v21;
  if (!v21)
  {
    int v18 = 103;
    int v19 = 93;
    goto LABEL_10;
  }
  return v16;
}

ASN1_VALUE *v2i_NAME_CONSTRAINTS(X509V3_EXT_METHOD *a1, X509V3_CTX *a2, const STACK *a3)
{
  memset(&cnf, 0, sizeof(cnf));
  int v6 = ASN1_item_new(&NAME_CONSTRAINTS_it);
  if (v6)
  {
    if (sk_num(a3) >= 1)
    {
      for (int i = 0; i < sk_num(a3); ++i)
      {
        int v8 = sk_value(a3, i);
        uint64_t v9 = *((void *)v8 + 1);
        if (!strncmp((const char *)v9, "permitted", 9uLL) && *(unsigned char *)(v9 + 9))
        {
          uint64_t v10 = 10;
          unsigned int v11 = (STACK **)v6;
        }
        else
        {
          if (strncmp((const char *)v9, "excluded", 8uLL) || !*(unsigned char *)(v9 + 8))
          {
            ERR_put_error(34, 4095, 143, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_ncons.c", 213);
            uint64_t v13 = 0;
            goto LABEL_19;
          }
          uint64_t v10 = 9;
          unsigned int v11 = (STACK **)((char *)v6 + 8);
        }
        size_t v12 = (char *)*((void *)v8 + 2);
        cnf.name = (char *)(v9 + v10);
        cnf.value = v12;
        uint64_t v13 = (GENERAL_NAME **)ASN1_item_new(&GENERAL_SUBTREE_it);
        if (!v2i_GENERAL_NAME_ex(*v13, a1, a2, &cnf, 1)) {
          goto LABEL_19;
        }
        uint64_t v14 = *v11;
        if (!*v11)
        {
          uint64_t v14 = sk_new_null();
          *unsigned int v11 = v14;
          if (!v14) {
            goto LABEL_17;
          }
        }
        if (!sk_push(v14, (char *)v13)) {
          goto LABEL_17;
        }
      }
    }
  }
  else
  {
    uint64_t v13 = 0;
LABEL_17:
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_ncons.c", 230);
LABEL_19:
    ASN1_item_free(v6, &NAME_CONSTRAINTS_it);
    ASN1_item_free((ASN1_VALUE *)v13, &GENERAL_SUBTREE_it);
    return 0;
  }
  return v6;
}

uint64_t i2r_NAME_CONSTRAINTS(uint64_t a1, const STACK **a2, BIO *a3, int a4)
{
  return 1;
}

GENERAL_SUBTREE *GENERAL_SUBTREE_new(void)
{
  return (GENERAL_SUBTREE *)ASN1_item_new(&GENERAL_SUBTREE_it);
}

void GENERAL_SUBTREE_free(GENERAL_SUBTREE *a)
{
}

NAME_CONSTRAINTS *NAME_CONSTRAINTS_new(void)
{
  return (NAME_CONSTRAINTS *)ASN1_item_new(&NAME_CONSTRAINTS_it);
}

void NAME_CONSTRAINTS_free(NAME_CONSTRAINTS *a)
{
}

uint64_t NAME_CONSTRAINTS_check(uint64_t a1, const STACK **a2)
{
  subject_name = X509_get_subject_name((X509 *)a1);
  if (X509_NAME_entry_count(subject_name) >= 1)
  {
    unint64_t data = (ASN1_STRING *)subject_name;
    uint64_t v11 = 4;
    uint64_t result = nc_match(&v11, a2);
    if (result) {
      return result;
    }
    LODWORD(v11) = 1;
    int v6 = -1;
    while (1)
    {
      int index_by_NID = X509_NAME_get_index_by_NID(subject_name, 48, v6);
      if (index_by_NID == -1) {
        break;
      }
      int v6 = index_by_NID;
      entry = X509_NAME_get_entry(subject_name, index_by_NID);
      unint64_t data = X509_NAME_ENTRY_get_data(entry);
      if (data->type != 22) {
        return 53;
      }
      uint64_t result = nc_match(&v11, a2);
      if (result) {
        return result;
      }
    }
  }
  if (sk_num(*(const STACK **)(a1 + 112)) < 1) {
    return 0;
  }
  int v9 = 0;
  while (1)
  {
    uint64_t v10 = sk_value(*(const STACK **)(a1 + 112), v9);
    uint64_t result = nc_match(v10, a2);
    if (result) {
      break;
    }
    if (++v9 >= sk_num(*(const STACK **)(a1 + 112))) {
      return 0;
    }
  }
  return result;
}

uint64_t nc_match(_DWORD *a1, const STACK **a2)
{
  if (sk_num(*a2) < 1)
  {
LABEL_14:
    if (sk_num(a2[1]) < 1)
    {
      return 0;
    }
    else
    {
      int v8 = 0;
      while (1)
      {
        int v9 = (uint64_t *)sk_value(a2[1], v8);
        if (*a1 == *(_DWORD *)*v9)
        {
          if (v9[1] || v9[2]) {
            return 49;
          }
          uint64_t result = nc_match_single((uint64_t)a1, *v9);
          if (result != 47) {
            break;
          }
        }
        if (++v8 >= sk_num(a2[1])) {
          return 0;
        }
      }
      if (!result) {
        return 48;
      }
    }
  }
  else
  {
    int v4 = 0;
    int v5 = 0;
    do
    {
      int v6 = (uint64_t *)sk_value(*a2, v5);
      if (*a1 == *(_DWORD *)*v6)
      {
        if (v6[1] || v6[2]) {
          return 49;
        }
        if (v4 != 2)
        {
          uint64_t result = nc_match_single((uint64_t)a1, *v6);
          if (result)
          {
            int v4 = 1;
            if (result != 47) {
              return result;
            }
          }
          else
          {
            int v4 = 2;
          }
        }
      }
      ++v5;
    }
    while (v5 < sk_num(*a2));
    if (v4 != 1) {
      goto LABEL_14;
    }
    return 47;
  }
  return result;
}

uint64_t do_i2r_name_constraints(const STACK *a1, BIO *a2, int a3, const char *a4)
{
  if (sk_num(a1) >= 1) {
    BIO_printf(a2, "%*s%s:\n", a3, "", a4);
  }
  uint64_t result = sk_num(a1);
  if ((int)result >= 1)
  {
    int v9 = 0;
    int v10 = a3 + 2;
    do
    {
      uint64_t v11 = sk_value(a1, v9);
      BIO_printf(a2, "%*s", v10, "");
      size_t v12 = *(GENERAL_NAME **)v11;
      if (**(_DWORD **)v11 == 7)
      {
        uint64_t ptr = v12->d.ptr;
        uint64_t v14 = (unsigned __int8 *)*((void *)ptr + 1);
        int v15 = *(_DWORD *)ptr;
        BIO_puts(a2, "IP:");
        if (v15 == 8)
        {
          BIO_printf(a2, "%d.%d.%d.%d/%d.%d.%d.%d", *v14);
        }
        else
        {
          if (v15 == 32)
          {
            for (int i = 0; ; ++i)
            {
              BIO_printf(a2, "%X", __rev16(*(unsigned __int16 *)v14));
              uint64_t v17 = "/";
              if (i != 7)
              {
                if (i == 15) {
                  goto LABEL_16;
                }
                uint64_t v17 = ":";
              }
              BIO_puts(a2, v17);
              v14 += 2;
            }
          }
          BIO_printf(a2, "IP Address:<invalid>");
        }
      }
      else
      {
        GENERAL_NAME_print(a2, v12);
      }
LABEL_16:
      BIO_puts(a2, "\n");
      ++v9;
      uint64_t result = sk_num(a1);
    }
    while (v9 < (int)result);
  }
  return result;
}

uint64_t nc_match_single(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 51;
  switch(*(_DWORD *)a2)
  {
    case 1:
      uint64_t v4 = *(void *)(a1 + 8);
      uint64_t v5 = *(void *)(a2 + 8);
      int v6 = *(char **)(v5 + 8);
      unsigned int v7 = *(char **)(v4 + 8);
      int v8 = strchr(v6, 64);
      int v9 = strchr(v7, 64);
      if (!v9) {
        return 53;
      }
      int v10 = v9;
      if (v8)
      {
        size_t v11 = v8 - v6;
        if (v8 == v6 || v11 == v9 - v7 && !strncmp(v6, v7, v11))
        {
          int v6 = v8 + 1;
LABEL_38:
          int v15 = v10 + 1;
          uint64_t v13 = v6;
          goto LABEL_39;
        }
        return 47;
      }
      if (*v6 != 46) {
        goto LABEL_38;
      }
      if (*(_DWORD *)v4 <= *(_DWORD *)v5 || strcasecmp(v6, &v7[*(_DWORD *)v4 - *(_DWORD *)v5])) {
        return 47;
      }
      return 0;
    case 2:
      size_t v12 = *(int **)(a2 + 8);
      uint64_t v13 = (const char *)*((void *)v12 + 1);
      if (!*v13) {
        return 0;
      }
      uint64_t v14 = *(void *)(a1 + 8);
      int v15 = *(const char **)(v14 + 8);
      LODWORD(v14) = *(_DWORD *)v14;
      int v16 = *v12;
      BOOL v17 = __OFSUB__(v14, v16);
      int v18 = v14 - v16;
      if (!((v18 < 0) ^ v17 | (v18 == 0)))
      {
        v15 += v18;
        if (*v13 != 46 && *(v15 - 1) != 46) {
          return 47;
        }
      }
LABEL_39:
      if (!strcasecmp(v13, v15)) {
        return 0;
      }
      else {
        return 47;
      }
    case 4:
      uint64_t v19 = *(void *)(a1 + 8);
      uint64_t v20 = *(void *)(a2 + 8);
      if (*(_DWORD *)(v19 + 8) && i2d_X509_NAME((X509_NAME *)v19, 0) < 0
        || *(_DWORD *)(v20 + 8) && i2d_X509_NAME((X509_NAME *)v20, 0) < 0)
      {
        return 17;
      }
      size_t v21 = *(int *)(v20 + 32);
      uint64_t v2 = 47;
      if ((int)v21 > *(_DWORD *)(v19 + 32)) {
        return v2;
      }
      int v22 = memcmp(*(const void **)(v20 + 24), *(const void **)(v19 + 24), v21);
      goto LABEL_19;
    case 6:
      uint64_t v23 = *(int **)(a2 + 8);
      int v24 = (const char *)*((void *)v23 + 1);
      int v25 = strchr(*(char **)(*(void *)(a1 + 8) + 8), 58);
      if (!v25 || v25[1] != 47 || v25[2] != 47) {
        return 53;
      }
      int v26 = v25 + 3;
      int v27 = strchr(v25 + 3, 58);
      if (v27 || (int v27 = strchr(v26, 47)) != 0)
      {
        int v28 = v27 - v26;
        if (v28) {
          goto LABEL_28;
        }
        return 53;
      }
      int v28 = strlen(v26);
      if (!v28) {
        return 53;
      }
LABEL_28:
      size_t v29 = *v23;
      if (*v24 == 46)
      {
        if ((int)v29 < v28 && !strncasecmp(&v26[v28 - v29], v24, v29)) {
          return 0;
        }
        else {
          return 47;
        }
      }
      else
      {
        uint64_t v2 = 47;
        if (v29 == v28)
        {
          int v22 = strncasecmp(v26, v24, v28);
LABEL_19:
          if (v22) {
            return 47;
          }
          else {
            return 0;
          }
        }
      }
      return v2;
    default:
      return v2;
  }
}

void ENGINE_unregister_DH(ENGINE *e)
{
}

int ENGINE_register_DH(ENGINE *e)
{
  if (*((void *)e + 4)) {
    return engine_table_register(&dh_table, (uint64_t)engine_unregister_all_DH, (char *)e, dummy_nid_0, 1, 0);
  }
  else {
    return 1;
  }
}

void engine_unregister_all_DH()
{
}

void ENGINE_register_all_DH(void)
{
  first = ENGINE_get_first();
  if (first)
  {
    next = first;
    do
    {
      if (*((void *)next + 4)) {
        engine_table_register(&dh_table, (uint64_t)engine_unregister_all_DH, (char *)next, dummy_nid_0, 1, 0);
      }
      next = ENGINE_get_next(next);
    }
    while (next);
  }
}

int ENGINE_set_default_DH(ENGINE *e)
{
  if (*((void *)e + 4)) {
    return engine_table_register(&dh_table, (uint64_t)engine_unregister_all_DH, (char *)e, dummy_nid_0, 1, 1);
  }
  else {
    return 1;
  }
}

ENGINE *ENGINE_get_default_DH(void)
{
  return (ENGINE *)engine_table_select(&dh_table, 1);
}

const DH_METHOD *__cdecl ENGINE_get_DH(const ENGINE *e)
{
  return (const DH_METHOD *)*((void *)e + 4);
}

int ENGINE_set_DH(ENGINE *e, const DH_METHOD *dh_meth)
{
  *((void *)e + 4) = dh_meth;
  return 1;
}

void ERR_load_crypto_strings(void)
{
}

void ERR_load_crypto_strings_internal()
{
  ERR_load_ERR_strings_internal();
  ERR_load_ASN1_strings();
  ERR_load_BIO_strings();
  ERR_load_BN_strings();
  ERR_load_BUF_strings();
  ERR_load_CMS_strings();
  ERR_load_CONF_strings();
  ERR_load_CRYPTO_strings();
  ERR_load_DH_strings();
  ERR_load_DSA_strings();
  ERR_load_DSO_strings();
  ERR_load_ECDH_strings();
  ERR_load_ECDSA_strings();
  ERR_load_EC_strings();
  ERR_load_ENGINE_strings();
  ERR_load_EVP_strings();
  ERR_load_GOST_strings();
  ERR_load_KDF_strings();
  ERR_load_OBJ_strings();
  ERR_load_OCSP_strings();
  ERR_load_PEM_strings();
  ERR_load_PKCS12_strings();
  ERR_load_PKCS7_strings();
  ERR_load_RAND_strings();
  ERR_load_RSA_strings();
  ERR_load_TS_strings();
  ERR_load_UI_strings();
  ERR_load_X509V3_strings();
  ERR_load_X509_strings();
}

EC_GROUP *__cdecl EC_GROUP_new(const EC_METHOD *a1)
{
  if (!a1)
  {
    int v4 = 108;
    int v5 = 82;
LABEL_8:
    ERR_put_error(16, 4095, v4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v5);
    return 0;
  }
  if (!*((void *)a1 + 1))
  {
    int v4 = 66;
    int v5 = 86;
    goto LABEL_8;
  }
  uint64_t v2 = (char *)malloc_type_malloc(0xE8uLL, 0x10F0040D5F8239AuLL);
  int v3 = v2;
  if (!v2)
  {
    ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", 91);
    return (EC_GROUP *)v3;
  }
  *((void *)v2 + 12) = 0;
  *(void *)uint64_t v2 = a1;
  *((void *)v2 + 1) = 0;
  BN_init((BIGNUM *)(v2 + 16));
  BN_init((BIGNUM *)(v3 + 40));
  *((void *)v3 + 8) = 0x100000000;
  *((_DWORD *)v3 + 18) = 4;
  *((void *)v3 + 10) = 0;
  *((void *)v3 + 11) = 0;
  if (!(*((unsigned int (**)(char *))a1 + 1))(v3))
  {
    free(v3);
    return 0;
  }
  return (EC_GROUP *)v3;
}

void EC_GROUP_free(EC_GROUP *a1)
{
  if (a1)
  {
    uint64_t v2 = *(void (**)(EC_GROUP *))(*(void *)a1 + 16);
    if (v2) {
      v2(a1);
    }
    EC_EX_DATA_clear_free_all_data((void **)a1 + 12);
    int v3 = (void *)*((void *)a1 + 1);
    if (v3)
    {
      int v4 = *(void (**)(void))(*(void *)v3 + 80);
      if (v4) {
        v4(*((void *)a1 + 1));
      }
      freezero(v3, 0x58uLL);
    }
    BN_free((BIGNUM *)((char *)a1 + 16));
    BN_free((BIGNUM *)((char *)a1 + 40));
    freezero(*((void **)a1 + 10), *((void *)a1 + 11));
    freezero(a1, 0xE8uLL);
  }
}

void EC_EX_DATA_clear_free_all_data(void **a1)
{
  if (a1)
  {
    uint64_t v2 = (void (**)(void))*a1;
    if (*a1)
    {
      do
      {
        int v3 = *v2;
        v2[4](v2[1]);
        free(v2);
        uint64_t v2 = (void (**)(void))v3;
      }
      while (v3);
    }
    *a1 = 0;
  }
}

void EC_POINT_free(EC_POINT *a1)
{
  if (a1)
  {
    uint64_t v2 = *(void (**)(EC_POINT *))(*(void *)a1 + 80);
    if (v2) {
      v2(a1);
    }
    freezero(a1, 0x58uLL);
  }
}

int EC_GROUP_copy(EC_GROUP *a1, const EC_GROUP *a2)
{
  if (!*(void *)(*(void *)a1 + 24))
  {
    int v3 = 66;
    int v4 = 148;
    goto LABEL_5;
  }
  if (*(void *)a1 != *(void *)a2)
  {
    int v3 = 101;
    int v4 = 152;
LABEL_5:
    ERR_put_error(16, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v4);
    LODWORD(v5) = 0;
    return (int)v5;
  }
  if (a1 == a2)
  {
    LODWORD(v5) = 1;
  }
  else
  {
    EC_EX_DATA_free_all_data((void **)a1 + 12);
    unsigned int v7 = (void *)((char *)a2 + 96);
    while (1)
    {
      unsigned int v7 = (void *)*v7;
      if (!v7) {
        break;
      }
      int v5 = (EC_POINT *)((uint64_t (*)(void))v7[2])(v7[1]);
      if (v5)
      {
        LODWORD(v5) = EC_EX_DATA_set_data((uint64_t)a1 + 96, (uint64_t)v5, v7[2], v7[3], v7[4]);
        if (v5) {
          continue;
        }
      }
      return (int)v5;
    }
    int v8 = (const EC_POINT *)*((void *)a2 + 1);
    int v5 = (EC_POINT *)*((void *)a1 + 1);
    if (v8)
    {
      if (!v5)
      {
        int v5 = EC_POINT_new(a1);
        *((void *)a1 + 1) = v5;
        if (!v5) {
          return (int)v5;
        }
        int v8 = (const EC_POINT *)*((void *)a2 + 1);
      }
      LODWORD(v5) = EC_POINT_copy(v5, v8);
      if (!v5) {
        return (int)v5;
      }
    }
    else
    {
      EC_POINT_free(v5);
      *((void *)a1 + 1) = 0;
    }
    LODWORD(v5) = bn_copy((BIGNUM *)((char *)a1 + 16), (const BIGNUM *)((char *)a2 + 16));
    if (v5)
    {
      LODWORD(v5) = bn_copy((BIGNUM *)((char *)a1 + 40), (const BIGNUM *)((char *)a2 + 40));
      if (v5)
      {
        int v10 = (EC_POINT **)((char *)a1 + 80);
        int v9 = (void *)*((void *)a1 + 10);
        *((void *)a1 + 8) = *((void *)a2 + 8);
        *((_DWORD *)a1 + 18) = *((_DWORD *)a2 + 18);
        uint64_t v11 = *((void *)a2 + 10);
        free(v9);
        if (v11)
        {
          int v5 = (EC_POINT *)malloc_type_malloc(*((void *)a2 + 11), 0x24900E62uLL);
          *int v10 = v5;
          if (!v5) {
            return (int)v5;
          }
          memcpy(v5, *((const void **)a2 + 10), *((void *)a2 + 11));
          *((void *)a1 + 11) = *((void *)a2 + 11);
        }
        else
        {
          *int v10 = 0;
          *((void *)a1 + 11) = 0;
        }
        size_t v12 = *(uint64_t (**)(EC_GROUP *, const EC_GROUP *))(*(void *)a1 + 24);
        LODWORD(v5) = v12(a1, a2);
      }
    }
  }
  return (int)v5;
}

void EC_EX_DATA_free_all_data(void **a1)
{
  if (a1)
  {
    uint64_t v2 = (void (**)(void))*a1;
    if (*a1)
    {
      do
      {
        int v3 = *v2;
        v2[3](v2[1]);
        free(v2);
        uint64_t v2 = (void (**)(void))v3;
      }
      while (v3);
    }
    *a1 = 0;
  }
}

uint64_t EC_EX_DATA_set_data(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (result)
  {
    int v9 = (void *)result;
    int v10 = *(void **)result;
    if (*(void *)result)
    {
      while (v10[2] != a3 || v10[3] != a4 || v10[4] != a5)
      {
        int v10 = (void *)*v10;
        if (!v10) {
          goto LABEL_7;
        }
      }
      ERR_put_error(16, 4095, 108, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", 695);
      return 0;
    }
    else
    {
LABEL_7:
      if (a2)
      {
        uint64_t result = (uint64_t)malloc_type_malloc(0x28uLL, 0xA0040B756CE11uLL);
        if (!result) {
          return result;
        }
        *(void *)(result + 8) = a2;
        *(void *)(result + 16) = a3;
        *(void *)(result + 24) = a4;
        *(void *)(result + 32) = a5;
        *(void *)uint64_t result = *v9;
        *int v9 = result;
      }
      return 1;
    }
  }
  return result;
}

EC_POINT *__cdecl EC_POINT_new(const EC_GROUP *a1)
{
  if (!a1)
  {
    int v5 = 67;
    int v6 = 838;
LABEL_8:
    ERR_put_error(16, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v6);
    return 0;
  }
  if (!*(void *)(*(void *)a1 + 72))
  {
    int v5 = 66;
    int v6 = 842;
    goto LABEL_8;
  }
  uint64_t v2 = (EC_POINT *)malloc_type_malloc(0x58uLL, 0x10700408AB58AABuLL);
  int v3 = v2;
  if (!v2)
  {
    ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", 847);
    return v3;
  }
  uint64_t v4 = *(void *)a1;
  *(void *)uint64_t v2 = *(void *)a1;
  if (!(*(unsigned int (**)(EC_POINT *))(v4 + 72))(v2))
  {
    free(v3);
    return 0;
  }
  return v3;
}

int EC_POINT_copy(EC_POINT *a1, const EC_POINT *a2)
{
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)a1 + 88);
  if (!v2)
  {
    int v3 = 66;
    int v4 = 881;
    goto LABEL_5;
  }
  if (*(void *)a1 != *(void *)a2)
  {
    int v3 = 101;
    int v4 = 885;
LABEL_5:
    ERR_put_error(16, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v4);
    return 0;
  }
  if (a1 == a2) {
    return 1;
  }
  return v2();
}

EC_GROUP *__cdecl EC_GROUP_dup(const EC_GROUP *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = EC_GROUP_new(*(const EC_METHOD **)a1);
  int v3 = v2;
  if (v2 && !EC_GROUP_copy(v2, a1))
  {
    EC_GROUP_free(v3);
    return 0;
  }
  return v3;
}

const EC_METHOD *__cdecl EC_GROUP_method_of(const EC_GROUP *a1)
{
  return *(const EC_METHOD **)a1;
}

int EC_METHOD_get_field_type(const EC_METHOD *a1)
{
  return *(_DWORD *)a1;
}

int EC_GROUP_set_generator(EC_GROUP *a1, const EC_POINT *generator, const BIGNUM *order, const BIGNUM *cofactor)
{
  if (!generator)
  {
    int v9 = 67;
    int v10 = 322;
    goto LABEL_6;
  }
  int v8 = (const BIGNUM *)((char *)a1 + 104);
  if (BN_is_zero((uint64_t)a1 + 104) || BN_is_negative((uint64_t)v8))
  {
    int v9 = 103;
    int v10 = 328;
LABEL_6:
    ERR_put_error(16, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v10);
    LODWORD(v11) = 0;
    return (int)v11;
  }
  if (!order || (size_t v12 = BN_value_one(), BN_cmp(order, v12) < 1) || (v13 = BN_num_bits(order), v13 > BN_num_bits(v8) + 1))
  {
    int v9 = 122;
    int v10 = 338;
    goto LABEL_6;
  }
  if (cofactor && BN_is_negative((uint64_t)cofactor))
  {
    int v9 = 164;
    int v10 = 348;
    goto LABEL_6;
  }
  uint64_t v11 = (EC_POINT *)*((void *)a1 + 1);
  if (v11 || (uint64_t v11 = EC_POINT_new(a1), (*((void *)a1 + 1) = v11) != 0))
  {
    LODWORD(v11) = EC_POINT_copy(v11, generator);
    if (v11)
    {
      LODWORD(v11) = bn_copy((BIGNUM *)((char *)a1 + 16), order);
      if (v11)
      {
        if (cofactor && !BN_is_zero((uint64_t)cofactor))
        {
          LODWORD(v11) = bn_copy((BIGNUM *)((char *)a1 + 40), cofactor);
          if (!v11) {
            return (int)v11;
          }
        }
        else
        {
          LODWORD(v11) = ec_guess_cofactor((uint64_t)a1);
          if (!v11) {
            return (int)v11;
          }
        }
        int v14 = BN_num_bits((const BIGNUM *)((char *)a1 + 40));
        if (v14 > BN_num_bits(v8) + 1)
        {
          int v9 = 122;
          int v10 = 372;
          goto LABEL_6;
        }
        LODWORD(v11) = 1;
      }
    }
  }
  return (int)v11;
}

BOOL ec_guess_cofactor(uint64_t a1)
{
  uint64_t v2 = (const BIGNUM *)(a1 + 16);
  int v3 = BN_num_bits((const BIGNUM *)(a1 + 16));
  int v4 = BN_num_bits((const BIGNUM *)(a1 + 104));
  int v5 = v4 + 2;
  if (v4 >= -1) {
    int v5 = v4 + 1;
  }
  if (v3 <= (v5 >> 1) + 3)
  {
    BOOL v11 = 1;
LABEL_17:
    BN_zero(a1 + 40);
    return v11;
  }
  int v6 = BN_CTX_new();
  unsigned int v7 = v6;
  if (!v6) {
    goto LABEL_15;
  }
  BN_CTX_start(v6);
  int v8 = BN_CTX_get(v7);
  if (!v8) {
    goto LABEL_15;
  }
  int v9 = v8;
  if (**(_DWORD **)a1 == 407)
  {
    BN_zero((uint64_t)v8);
    int v10 = BN_num_bits((const BIGNUM *)(a1 + 104));
    if (!BN_set_bit(v9, v10 - 1)) {
      goto LABEL_15;
    }
  }
  else if (!bn_copy(v8, (const BIGNUM *)(a1 + 104)))
  {
    goto LABEL_15;
  }
  if (BN_rshift1((BIGNUM *)(a1 + 40), v2))
  {
    size_t v12 = BN_value_one();
    if (BN_add((BIGNUM *)(a1 + 40), (const BIGNUM *)(a1 + 40), v12))
    {
      if (BN_add((BIGNUM *)(a1 + 40), (const BIGNUM *)(a1 + 40), v9))
      {
        BOOL v11 = BN_div_ct(a1 + 40, 0, (const BIGNUM *)(a1 + 40), v2, v7) != 0;
        goto LABEL_16;
      }
    }
  }
LABEL_15:
  BOOL v11 = 0;
LABEL_16:
  BN_CTX_end(v7);
  BN_CTX_free(v7);
  if (!v11) {
    goto LABEL_17;
  }
  return v11;
}

const EC_POINT *__cdecl EC_GROUP_get0_generator(const EC_GROUP *a1)
{
  return (const EC_POINT *)*((void *)a1 + 1);
}

int EC_GROUP_get_order(const EC_GROUP *a1, BIGNUM *order, BN_CTX *a3)
{
  int result = bn_copy(order, (const BIGNUM *)((char *)a1 + 16));
  if (result) {
    return !BN_is_zero((uint64_t)order);
  }
  return result;
}

uint64_t EC_GROUP_order_bits(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
}

int EC_GROUP_get_cofactor(const EC_GROUP *a1, BIGNUM *cofactor, BN_CTX *a3)
{
  int v3 = (char *)a1 + 40;
  int result = bn_copy(cofactor, (const BIGNUM *)((char *)a1 + 40));
  if (result) {
    return !BN_is_zero((uint64_t)v3);
  }
  return result;
}

void EC_GROUP_set_curve_name(EC_GROUP *a1, int nid)
{
  *((_DWORD *)a1 + 16) = nid;
}

int EC_GROUP_get_curve_name(const EC_GROUP *a1)
{
  return *((_DWORD *)a1 + 16);
}

void EC_GROUP_set_asn1_flag(EC_GROUP *a1, int flag)
{
  *((_DWORD *)a1 + 17) = flag;
}

int EC_GROUP_get_asn1_flag(const EC_GROUP *a1)
{
  return *((_DWORD *)a1 + 17);
}

void EC_GROUP_set_point_conversion_form(EC_GROUP *a1, point_conversion_form_t a2)
{
  *((_DWORD *)a1 + 18) = a2;
}

point_conversion_form_t EC_GROUP_get_point_conversion_form(const EC_GROUP *a1)
{
  return *((_DWORD *)a1 + 18);
}

size_t EC_GROUP_set_seed(EC_GROUP *a1, const unsigned __int8 *a2, size_t len)
{
  unsigned int v7 = (size_t *)((char *)a1 + 80);
  int v6 = (void *)*((void *)a1 + 10);
  if (v6)
  {
    free(v6);
    *unsigned int v7 = 0;
    v7[1] = 0;
  }
  size_t result = 1;
  if (a2 && len)
  {
    size_t result = (size_t)malloc_type_malloc(len, 0x611930E7uLL);
    *unsigned int v7 = result;
    if (result)
    {
      memcpy((void *)result, a2, len);
      *((void *)a1 + 11) = len;
      return len;
    }
  }
  return result;
}

unsigned __int8 *__cdecl EC_GROUP_get0_seed(const EC_GROUP *a1)
{
  return (unsigned __int8 *)*((void *)a1 + 10);
}

size_t EC_GROUP_get_seed_len(const EC_GROUP *a1)
{
  return *((void *)a1 + 11);
}

uint64_t EC_GROUP_set_curve(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, BN_CTX *a5)
{
  int v10 = a5;
  if (a5 || (int v10 = BN_CTX_new()) != 0)
  {
    BOOL v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, BN_CTX *))(*(void *)a1 + 32);
    if (v11)
    {
      uint64_t v12 = v11(a1, a2, a3, a4, v10);
      goto LABEL_7;
    }
    ERR_put_error(16, 4095, 66, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", 501);
  }
  uint64_t v12 = 0;
LABEL_7:
  if (v10 != a5) {
    BN_CTX_free(v10);
  }
  return v12;
}

uint64_t EC_GROUP_get_curve(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, BN_CTX *a5)
{
  int v10 = a5;
  if (a5 || (int v10 = BN_CTX_new()) != 0)
  {
    BOOL v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, BN_CTX *))(*(void *)a1 + 40);
    if (v11)
    {
      uint64_t v12 = v11(a1, a2, a3, a4, v10);
      goto LABEL_7;
    }
    ERR_put_error(16, 4095, 66, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", 526);
  }
  uint64_t v12 = 0;
LABEL_7:
  if (v10 != a5) {
    BN_CTX_free(v10);
  }
  return v12;
}