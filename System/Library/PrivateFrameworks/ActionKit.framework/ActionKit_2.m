int EC_GROUP_get_degree(const EC_GROUP *a1)
{
  uint64_t (*v1)(void);
  uint64_t vars8;

  v1 = *(uint64_t (**)(void))(*(void *)a1 + 48);
  if (v1)
  {
    return v1();
  }
  else
  {
    ERR_put_error(16, 4095, 66, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", 556);
    return 0;
  }
}

int EC_GROUP_check_discriminant(const EC_GROUP *a1, BN_CTX *a2)
{
  v4 = a2;
  if (a2 || (v4 = BN_CTX_new()) != 0)
  {
    v5 = *(uint64_t (**)(const EC_GROUP *, BN_CTX *))(*(void *)a1 + 64);
    if (v5)
    {
      int v6 = v5(a1, v4);
      goto LABEL_7;
    }
    ERR_put_error(16, 4095, 66, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", 575);
  }
  int v6 = 0;
LABEL_7:
  if (v4 != a2) {
    BN_CTX_free(v4);
  }
  return v6;
}

int EC_GROUP_cmp(const EC_GROUP *a1, const EC_GROUP *a2, BN_CTX *a3)
{
  if (**(_DWORD **)a1 == **(_DWORD **)a2)
  {
    v3 = a3;
    int v6 = *((_DWORD *)a1 + 16);
    if (!v6 || ((int v7 = *((_DWORD *)a2 + 16)) != 0 ? (v8 = v6 == v7) : (v8 = 1), v8))
    {
      if (a3)
      {
        v9 = 0;
      }
      else
      {
        v9 = BN_CTX_new();
        v3 = v9;
        if (!v9) {
          return -1;
        }
      }
      BN_CTX_start(v3);
      v11 = BN_CTX_get(v3);
      if (v11)
      {
        v12 = v11;
        v13 = BN_CTX_get(v3);
        if (v13)
        {
          v14 = v13;
          v15 = BN_CTX_get(v3);
          if (v15)
          {
            v16 = v15;
            v17 = BN_CTX_get(v3);
            if (v17)
            {
              v18 = v17;
              v19 = BN_CTX_get(v3);
              if (v19)
              {
                v20 = v19;
                v21 = BN_CTX_get(v3);
                if (v21)
                {
                  v22 = v21;
                  if (!(*(unsigned int (**)(const EC_GROUP *, BIGNUM *, BIGNUM *, const BIGNUM *, BN_CTX *))(*(void *)a1 + 40))(a1, v12, v14, v16, v3)|| !(*(unsigned int (**)(const EC_GROUP *, BIGNUM *, BIGNUM *, const BIGNUM *, BN_CTX *))(*(void *)a2 + 40))(a2, v18, v20, v22, v3)|| BN_cmp(v12, v18)|| BN_cmp(v14, v20)|| BN_cmp(v16, v22)|| EC_POINT_cmp(a1, *((const EC_POINT **)a1 + 1), *((const EC_POINT **)a2 + 1), v3))
                  {
                    goto LABEL_24;
                  }
                  if (EC_GROUP_get_order(a1, v12, v23)
                    && EC_GROUP_get_order(a2, v18, v24)
                    && EC_GROUP_get_cofactor(a1, v14, v25)
                    && EC_GROUP_get_cofactor(a2, v20, v26))
                  {
                    if (!BN_cmp(v12, v18) && !BN_cmp(v14, v20))
                    {
                      int v10 = 0;
LABEL_25:
                      BN_CTX_end(v3);
                      if (!v9) {
                        return v10;
                      }
                      goto LABEL_36;
                    }
LABEL_24:
                    int v10 = 1;
                    goto LABEL_25;
                  }
                }
              }
            }
          }
        }
      }
      BN_CTX_end(v3);
      int v10 = -1;
      if (!v9) {
        return v10;
      }
LABEL_36:
      BN_CTX_free(v3);
      return v10;
    }
  }
  return 1;
}

int EC_POINT_cmp(const EC_GROUP *a1, const EC_POINT *a, const EC_POINT *b, BN_CTX *a4)
{
  BOOL v8 = a4;
  if (!a4)
  {
    BOOL v8 = BN_CTX_new();
    if (!v8) {
      goto LABEL_9;
    }
  }
  uint64_t v9 = *(void *)a1;
  int v10 = *(uint64_t (**)(const EC_GROUP *, const EC_POINT *, const EC_POINT *, BN_CTX *))(*(void *)a1 + 200);
  if (!v10)
  {
    int v11 = 66;
    int v12 = 1238;
    goto LABEL_8;
  }
  if (v9 != *(void *)a || v9 != *(void *)b)
  {
    int v11 = 101;
    int v12 = 1242;
LABEL_8:
    ERR_put_error(16, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v12);
LABEL_9:
    int v13 = -1;
    goto LABEL_10;
  }
  int v13 = v10(a1, a, b, v8);
LABEL_10:
  if (v8 != a4) {
    BN_CTX_free(v8);
  }
  return v13;
}

uint64_t ec_point_blind_coordinates(uint64_t a1)
{
  v1 = *(uint64_t (**)(void))(*(void *)a1 + 312);
  if (v1) {
    return v1();
  }
  else {
    return 1;
  }
}

void *EC_EX_DATA_get_data(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (result)
  {
    while (result[2] != a2 || result[3] != a3 || result[4] != a4)
    {
      result = (void *)*result;
      if (!result) {
        return result;
      }
    }
    return (void *)result[1];
  }
  return result;
}

void EC_EX_DATA_free_data(void **a1, uint64_t a2, void (*a3)(void *), void *a4)
{
  if (a1)
  {
    while (1)
    {
      v4 = *a1;
      if (!*a1) {
        break;
      }
      v5 = a1;
      a1 = (void **)*a1;
      if (v4[2] == a2 && a1[3] == a3 && a1[4] == a4)
      {
        int v6 = *a1;
        a3(a1[1]);
        free(*v5);
        *v5 = v6;
        return;
      }
    }
  }
}

void EC_EX_DATA_clear_free_data(void **a1, uint64_t a2, void *a3, void (*a4)(void *))
{
  if (a1)
  {
    while (1)
    {
      v4 = *a1;
      if (!*a1) {
        break;
      }
      v5 = a1;
      a1 = (void **)*a1;
      if (v4[2] == a2 && a1[3] == a3 && a1[4] == a4)
      {
        int v6 = *a1;
        a4(a1[1]);
        free(*v5);
        *v5 = v6;
        return;
      }
    }
  }
}

void EC_POINT_clear_free(EC_POINT *a1)
{
  if (a1)
  {
    v2 = *(void (**)(EC_POINT *))(*(void *)a1 + 80);
    if (v2) {
      v2(a1);
    }
    freezero(a1, 0x58uLL);
  }
}

EC_POINT *__cdecl EC_POINT_dup(const EC_POINT *a1, const EC_GROUP *a2)
{
  if (!a1) {
    return 0;
  }
  v3 = EC_POINT_new(a2);
  v4 = v3;
  if (v3 && !EC_POINT_copy(v3, a1))
  {
    v5 = *(void (**)(EC_POINT *))(*(void *)v4 + 80);
    if (v5) {
      v5(v4);
    }
    freezero(v4, 0x58uLL);
    return 0;
  }
  return v4;
}

const EC_METHOD *__cdecl EC_POINT_method_of(const EC_POINT *a1)
{
  return *(const EC_METHOD **)a1;
}

int EC_POINT_set_to_infinity(const EC_GROUP *a1, EC_POINT *a2)
{
  v2 = *(uint64_t (**)(void))(*(void *)a1 + 96);
  if (!v2)
  {
    int v3 = 66;
    int v4 = 923;
    goto LABEL_5;
  }
  if (*(void *)a1 != *(void *)a2)
  {
    int v3 = 101;
    int v4 = 927;
LABEL_5:
    ERR_put_error(16, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v4);
    return 0;
  }
  return v2();
}

uint64_t EC_POINT_set_Jprojective_coordinates(const EC_GROUP *a1, const EC_POINT *a2, uint64_t a3, uint64_t a4, uint64_t a5, BN_CTX *a6)
{
  int v12 = a6;
  if (!a6)
  {
    int v12 = BN_CTX_new();
    if (!v12) {
      goto LABEL_8;
    }
  }
  int v13 = *(unsigned int (**)(const EC_GROUP *, const EC_POINT *, uint64_t, uint64_t, uint64_t, BN_CTX *))(*(void *)a1 + 104);
  if (!v13)
  {
    int v14 = 66;
    int v15 = 946;
    goto LABEL_7;
  }
  if (*(void *)a1 != *(void *)a2)
  {
    int v14 = 101;
    int v15 = 950;
LABEL_7:
    ERR_put_error(16, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v15);
LABEL_8:
    uint64_t v16 = 0;
    goto LABEL_9;
  }
  if (!v13(a1, a2, a3, a4, a5, v12)) {
    goto LABEL_8;
  }
  if (EC_POINT_is_on_curve(a1, a2, v12) <= 0)
  {
    int v14 = 107;
    int v15 = 958;
    goto LABEL_7;
  }
  uint64_t v16 = 1;
LABEL_9:
  if (v12 != a6) {
    BN_CTX_free(v12);
  }
  return v16;
}

int EC_POINT_is_on_curve(const EC_GROUP *a1, const EC_POINT *a2, BN_CTX *a3)
{
  int v6 = a3;
  if (!a3)
  {
    int v6 = BN_CTX_new();
    if (!v6) {
      goto LABEL_8;
    }
  }
  int v7 = *(uint64_t (**)(const EC_GROUP *, const EC_POINT *, BN_CTX *))(*(void *)a1 + 192);
  if (!v7)
  {
    int v8 = 66;
    int v9 = 1209;
    goto LABEL_7;
  }
  if (*(void *)a1 != *(void *)a2)
  {
    int v8 = 101;
    int v9 = 1213;
LABEL_7:
    ERR_put_error(16, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v9);
LABEL_8:
    int v10 = 0;
    goto LABEL_10;
  }
  int v10 = v7(a1, a2, v6);
LABEL_10:
  if (v6 != a3) {
    BN_CTX_free(v6);
  }
  return v10;
}

uint64_t EC_POINT_get_Jprojective_coordinates(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, BN_CTX *a6)
{
  int v12 = a6;
  if (!a6)
  {
    int v12 = BN_CTX_new();
    if (!v12) {
      goto LABEL_8;
    }
  }
  int v13 = *(uint64_t (**)(uint64_t, void *, uint64_t, uint64_t, uint64_t, BN_CTX *))(*(void *)a1 + 112);
  if (!v13)
  {
    int v14 = 66;
    int v15 = 984;
    goto LABEL_7;
  }
  if (*(void *)a1 != *a2)
  {
    int v14 = 101;
    int v15 = 988;
LABEL_7:
    ERR_put_error(16, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v15);
LABEL_8:
    uint64_t v16 = 0;
    goto LABEL_10;
  }
  uint64_t v16 = v13(a1, a2, a3, a4, a5, v12);
LABEL_10:
  if (v12 != a6) {
    BN_CTX_free(v12);
  }
  return v16;
}

uint64_t EC_POINT_set_affine_coordinates(const EC_GROUP *a1, const EC_POINT *a2, uint64_t a3, uint64_t a4, BN_CTX *a5)
{
  int v10 = a5;
  if (!a5)
  {
    int v10 = BN_CTX_new();
    if (!v10) {
      goto LABEL_8;
    }
  }
  int v11 = *(unsigned int (**)(const EC_GROUP *, const EC_POINT *, uint64_t, uint64_t, BN_CTX *))(*(void *)a1 + 120);
  if (!v11)
  {
    int v12 = 66;
    int v13 = 1028;
    goto LABEL_7;
  }
  if (*(void *)a1 != *(void *)a2)
  {
    int v12 = 101;
    int v13 = 1032;
LABEL_7:
    ERR_put_error(16, 4095, v12, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v13);
LABEL_8:
    uint64_t v14 = 0;
    goto LABEL_9;
  }
  if (!v11(a1, a2, a3, a4, v10)) {
    goto LABEL_8;
  }
  if (EC_POINT_is_on_curve(a1, a2, v10) <= 0)
  {
    int v12 = 107;
    int v13 = 1039;
    goto LABEL_7;
  }
  uint64_t v14 = 1;
LABEL_9:
  if (v10 != a5) {
    BN_CTX_free(v10);
  }
  return v14;
}

uint64_t EC_POINT_get_affine_coordinates(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, BN_CTX *a5)
{
  int v10 = a5;
  if (!a5)
  {
    int v10 = BN_CTX_new();
    if (!v10) {
      goto LABEL_8;
    }
  }
  int v11 = *(uint64_t (**)(uint64_t, void *, uint64_t, uint64_t, BN_CTX *))(*(void *)a1 + 128);
  if (!v11)
  {
    int v12 = 66;
    int v13 = 1072;
    goto LABEL_7;
  }
  if (*(void *)a1 != *a2)
  {
    int v12 = 101;
    int v13 = 1076;
LABEL_7:
    ERR_put_error(16, 4095, v12, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v13);
LABEL_8:
    uint64_t v14 = 0;
    goto LABEL_10;
  }
  uint64_t v14 = v11(a1, a2, a3, a4, v10);
LABEL_10:
  if (v10 != a5) {
    BN_CTX_free(v10);
  }
  return v14;
}

int EC_POINT_add(const EC_GROUP *a1, EC_POINT *r, const EC_POINT *a, const EC_POINT *b, BN_CTX *a5)
{
  int v10 = a5;
  if (!a5)
  {
    int v10 = BN_CTX_new();
    if (!v10) {
      goto LABEL_10;
    }
  }
  uint64_t v11 = *(void *)a1;
  int v12 = *(uint64_t (**)(const EC_GROUP *, EC_POINT *, const EC_POINT *, const EC_POINT *, BN_CTX *))(*(void *)a1 + 160);
  if (!v12)
  {
    int v13 = 66;
    int v14 = 1108;
    goto LABEL_9;
  }
  if (v11 != *(void *)r || v11 != *(void *)a || v11 != *(void *)b)
  {
    int v13 = 101;
    int v14 = 1113;
LABEL_9:
    ERR_put_error(16, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v14);
LABEL_10:
    int v15 = 0;
    goto LABEL_11;
  }
  int v15 = v12(a1, r, a, b, v10);
LABEL_11:
  if (v10 != a5) {
    BN_CTX_free(v10);
  }
  return v15;
}

int EC_POINT_dbl(const EC_GROUP *a1, EC_POINT *r, const EC_POINT *a, BN_CTX *a4)
{
  int v8 = a4;
  if (!a4)
  {
    int v8 = BN_CTX_new();
    if (!v8) {
      goto LABEL_9;
    }
  }
  uint64_t v9 = *(void *)a1;
  int v10 = *(uint64_t (**)(const EC_GROUP *, EC_POINT *, const EC_POINT *, BN_CTX *))(*(void *)a1 + 168);
  if (!v10)
  {
    int v11 = 66;
    int v12 = 1138;
    goto LABEL_8;
  }
  if (v9 != *(void *)r || v9 != *(void *)a)
  {
    int v11 = 101;
    int v12 = 1142;
LABEL_8:
    ERR_put_error(16, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v12);
LABEL_9:
    int v13 = 0;
    goto LABEL_10;
  }
  int v13 = v10(a1, r, a, v8);
LABEL_10:
  if (v8 != a4) {
    BN_CTX_free(v8);
  }
  return v13;
}

int EC_POINT_invert(const EC_GROUP *a1, EC_POINT *a2, BN_CTX *a3)
{
  int v6 = a3;
  if (!a3)
  {
    int v6 = BN_CTX_new();
    if (!v6) {
      goto LABEL_8;
    }
  }
  int v7 = *(uint64_t (**)(const EC_GROUP *, EC_POINT *, BN_CTX *))(*(void *)a1 + 176);
  if (!v7)
  {
    int v8 = 66;
    int v9 = 1166;
    goto LABEL_7;
  }
  if (*(void *)a1 != *(void *)a2)
  {
    int v8 = 101;
    int v9 = 1170;
LABEL_7:
    ERR_put_error(16, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v9);
LABEL_8:
    int v10 = 0;
    goto LABEL_10;
  }
  int v10 = v7(a1, a2, v6);
LABEL_10:
  if (v6 != a3) {
    BN_CTX_free(v6);
  }
  return v10;
}

int EC_POINT_is_at_infinity(const EC_GROUP *a1, const EC_POINT *a2)
{
  v2 = *(uint64_t (**)(void))(*(void *)a1 + 184);
  if (!v2)
  {
    int v3 = 66;
    int v4 = 1186;
    goto LABEL_5;
  }
  if (*(void *)a1 != *(void *)a2)
  {
    int v3 = 101;
    int v4 = 1190;
LABEL_5:
    ERR_put_error(16, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v4);
    return 0;
  }
  return v2();
}

int EC_POINT_make_affine(const EC_GROUP *a1, EC_POINT *a2, BN_CTX *a3)
{
  int v6 = a3;
  if (!a3)
  {
    int v6 = BN_CTX_new();
    if (!v6) {
      goto LABEL_8;
    }
  }
  int v7 = *(uint64_t (**)(const EC_GROUP *, EC_POINT *, BN_CTX *))(*(void *)a1 + 208);
  if (!v7)
  {
    int v8 = 66;
    int v9 = 1266;
    goto LABEL_7;
  }
  if (*(void *)a1 != *(void *)a2)
  {
    int v8 = 101;
    int v9 = 1270;
LABEL_7:
    ERR_put_error(16, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v9);
LABEL_8:
    int v10 = 0;
    goto LABEL_10;
  }
  int v10 = v7(a1, a2, v6);
LABEL_10:
  if (v6 != a3) {
    BN_CTX_free(v6);
  }
  return v10;
}

int EC_POINTs_make_affine(const EC_GROUP *a1, size_t num, EC_POINT *a3[], BN_CTX *a4)
{
  int v8 = a4;
  if (a4 || (int v8 = BN_CTX_new()) != 0)
  {
    int v9 = *(uint64_t (**)(const EC_GROUP *, size_t, EC_POINT **__attribute__((__org_arrdim(0,0))), BN_CTX *))(*(void *)a1 + 216);
    if (v9)
    {
      if (!num)
      {
LABEL_8:
        int v12 = v9(a1, num, a3, v8);
        goto LABEL_13;
      }
      EC_POINT **__attribute__((__org_arrdim(0,0))) v10 = a3;
      size_t v11 = num;
      while (*(void *)a1 == *(void *)*v10)
      {
        ++v10;
        if (!--v11) {
          goto LABEL_8;
        }
      }
      int v13 = 101;
      int v14 = 1301;
    }
    else
    {
      int v13 = 66;
      int v14 = 1296;
    }
    ERR_put_error(16, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v14);
  }
  int v12 = 0;
LABEL_13:
  if (v8 != a4) {
    BN_CTX_free(v8);
  }
  return v12;
}

int EC_POINTs_mul(const EC_GROUP *a1, EC_POINT *r, const BIGNUM *a3, size_t num, const EC_POINT *a5[], const BIGNUM *a6[], BN_CTX *a7)
{
  int v14 = a7;
  if (!a7)
  {
    int v14 = BN_CTX_new();
    if (!v14) {
      goto LABEL_13;
    }
  }
  uint64_t v15 = *(void *)a1;
  if (!*(void *)(*(void *)a1 + 224) || !*(void *)(v15 + 232) || num > 1 || !*(void *)(v15 + 240))
  {
    int v21 = 66;
    int v22 = 1332;
LABEL_12:
    ERR_put_error(16, 4095, v21, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v22);
LABEL_13:
    int v23 = 0;
    goto LABEL_14;
  }
  if (num != 1 || !a5 || !a6)
  {
    if (a3 && !a5 && !a6)
    {
      v18 = a1;
      v19 = r;
      v20 = a3;
      uint64_t v16 = 0;
      v17 = 0;
      goto LABEL_21;
    }
    int v21 = 16;
    int v22 = 1344;
    goto LABEL_12;
  }
  uint64_t v16 = *a5;
  v17 = *a6;
  v18 = a1;
  v19 = r;
  v20 = a3;
LABEL_21:
  int v23 = EC_POINT_mul(v18, v19, v20, v16, v17, v14);
LABEL_14:
  if (v14 != a7) {
    BN_CTX_free(v14);
  }
  return v23;
}

int EC_POINT_mul(const EC_GROUP *a1, EC_POINT *r, const BIGNUM *a3, const EC_POINT *a4, const BIGNUM *a5, BN_CTX *a6)
{
  int v12 = a6;
  if (!a6)
  {
    int v12 = BN_CTX_new();
    if (!v12) {
      goto LABEL_12;
    }
  }
  uint64_t v13 = *(void *)a1;
  int v14 = *(uint64_t (**)(const EC_GROUP *, EC_POINT *, const BIGNUM *, BN_CTX *))(*(void *)a1 + 224);
  if (!v14
    || (uint64_t v15 = *(uint64_t (**)(const EC_GROUP *, EC_POINT *, const BIGNUM *, const EC_POINT *, BN_CTX *))(v13 + 232)) == 0
    || (uint64_t v16 = *(uint64_t (**)(const EC_GROUP *, EC_POINT *, const BIGNUM *, const BIGNUM *, const EC_POINT *, BN_CTX *))(v13 + 240)) == 0)
  {
    int v18 = 66;
    int v19 = 1370;
LABEL_11:
    ERR_put_error(16, 4095, v18, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_lib.c", v19);
LABEL_12:
    int v20 = 0;
    goto LABEL_13;
  }
  if (!a3 || a4 || a5)
  {
    if (!a3 && a4 && a5)
    {
      int v17 = v15(a1, r, a5, a4, v12);
      goto LABEL_24;
    }
    if (a3 && a4 && a5)
    {
      int v17 = v16(a1, r, a3, a5, a4, v12);
      goto LABEL_24;
    }
    int v18 = 16;
    int v19 = 1405;
    goto LABEL_11;
  }
  int v17 = v14(a1, r, a3, v12);
LABEL_24:
  int v20 = v17;
LABEL_13:
  if (v12 != a6) {
    BN_CTX_free(v12);
  }
  return v20;
}

int EC_GROUP_precompute_mult(EC_GROUP *a1, BN_CTX *a2)
{
  v2 = *(uint64_t (**)(EC_GROUP *, BN_CTX *))(*(void *)a1 + 248);
  if (!v2) {
    return 1;
  }
  v5 = a2;
  if (a2) {
    goto LABEL_5;
  }
  v5 = BN_CTX_new();
  if (v5)
  {
    v2 = *(uint64_t (**)(EC_GROUP *, BN_CTX *))(*(void *)a1 + 248);
LABEL_5:
    int v6 = v2(a1, v5);
    goto LABEL_6;
  }
  int v6 = 0;
LABEL_6:
  if (v5 != a2) {
    BN_CTX_free(v5);
  }
  return v6;
}

int EC_GROUP_have_precompute_mult(const EC_GROUP *a1)
{
  v1 = *(uint64_t (**)(void))(*(void *)a1 + 256);
  if (v1) {
    return v1();
  }
  else {
    return 0;
  }
}

uint64_t ec_group_simple_order_bits(uint64_t a1)
{
  return BN_num_bits((const BIGNUM *)(a1 + 16));
}

EC_KEY *ECParameters_dup(EC_KEY *a1)
{
  v5 = 0;
  if (!a1) {
    return 0;
  }
  int v1 = i2d_ECParameters(a1, &v5);
  if (v1 < 1) {
    return 0;
  }
  in = v5;
  size_t v2 = v1;
  int v3 = d2i_ECParameters(0, (const unsigned __int8 **)&in, v1);
  freezero(v5, v2);
  return v3;
}

uint64_t **x509_issuer_tree_RB_INSERT_COLOR(uint64_t **result, uint64_t *a2)
{
  for (i = (uint64_t *)a2[2]; i; a2 = v5)
  {
    if (*((_DWORD *)i + 6) != 1) {
      break;
    }
    int v3 = (uint64_t *)i[2];
    uint64_t v4 = *v3;
    if (i == (uint64_t *)*v3)
    {
      uint64_t v4 = v3[1];
      if (!v4 || *(_DWORD *)(v4 + 24) != 1)
      {
        int v6 = (uint64_t *)i[1];
        if (v6 != a2)
        {
          int v7 = i;
          v5 = a2;
          a2 = i;
LABEL_33:
          *((_DWORD *)a2 + 6) = 0;
          *((_DWORD *)v3 + 6) = 1;
          uint64_t *v3 = (uint64_t)v6;
          if (v6) {
            v6[2] = (uint64_t)v3;
          }
          uint64_t v18 = v3[2];
          v7[2] = v18;
          int v19 = result;
          if (v18)
          {
            int v19 = (uint64_t **)v3[2];
            if (v3 != *v19) {
              ++v19;
            }
          }
          EC_POINT *v19 = v7;
          v7[1] = (uint64_t)v3;
          v3[2] = (uint64_t)v7;
          goto LABEL_39;
        }
        uint64_t v11 = *a2;
        i[1] = *a2;
        if (v11)
        {
          *(void *)(v11 + 16) = i;
          uint64_t v12 = i[2];
          a2[2] = v12;
          uint64_t v13 = result;
          if (!v12)
          {
LABEL_32:
            BIGNUM *v13 = a2;
            *a2 = (uint64_t)i;
            i[2] = (uint64_t)a2;
            int v7 = (uint64_t *)*v3;
            int v6 = *(uint64_t **)(*v3 + 8);
            v5 = i;
            goto LABEL_33;
          }
        }
        else
        {
          a2[2] = (uint64_t)v3;
        }
        uint64_t v13 = (uint64_t **)i[2];
        if (i != *v13) {
          ++v13;
        }
        goto LABEL_32;
      }
    }
    else if (!v4 || *(_DWORD *)(v4 + 24) != 1)
    {
      if ((uint64_t *)*i != a2)
      {
        v5 = a2;
        a2 = i;
LABEL_23:
        *((_DWORD *)a2 + 6) = 0;
        *((_DWORD *)v3 + 6) = 1;
        int v14 = (uint64_t *)v3[1];
        uint64_t v15 = *v14;
        v3[1] = *v14;
        if (v15) {
          *(void *)(v15 + 16) = v3;
        }
        uint64_t v16 = v3[2];
        v14[2] = v16;
        int v17 = result;
        if (v16)
        {
          int v17 = (uint64_t **)v3[2];
          if (v3 != *v17) {
            ++v17;
          }
        }
        const BIGNUM *v17 = v14;
        uint64_t *v14 = (uint64_t)v3;
        v3[2] = (uint64_t)v14;
        goto LABEL_39;
      }
      uint64_t v8 = a2[1];
      uint64_t *i = v8;
      if (v8)
      {
        *(void *)(v8 + 16) = i;
        uint64_t v9 = i[2];
        a2[2] = v9;
        EC_POINT **__attribute__((__org_arrdim(0,0))) v10 = result;
        if (!v9)
        {
LABEL_22:
          *EC_POINT **__attribute__((__org_arrdim(0,0))) v10 = a2;
          a2[1] = (uint64_t)i;
          v5 = i;
          i[2] = (uint64_t)a2;
          goto LABEL_23;
        }
      }
      else
      {
        a2[2] = (uint64_t)v3;
      }
      EC_POINT **__attribute__((__org_arrdim(0,0))) v10 = (uint64_t **)i[2];
      if (i != *v10) {
        ++v10;
      }
      goto LABEL_22;
    }
    *(_DWORD *)(v4 + 24) = 0;
    *((_DWORD *)i + 6) = 0;
    v5 = v3;
    *((_DWORD *)v3 + 6) = 1;
LABEL_39:
    i = (uint64_t *)v5[2];
  }
  *((_DWORD *)*result + 6) = 0;
  return result;
}

uint64_t *x509_issuer_tree_RB_REMOVE_COLOR(uint64_t *result, uint64_t a2, uint64_t **a3)
{
  while (1)
  {
    int v3 = a3;
    a3 = (uint64_t **)a2;
    if (v3)
    {
      if (*((_DWORD *)v3 + 6)) {
        break;
      }
    }
    uint64_t v4 = (uint64_t **)*result;
    if (v3 == (uint64_t **)*result) {
      goto LABEL_74;
    }
    v5 = *(uint64_t **)a2;
    if (*(uint64_t ***)a2 == v3)
    {
      v5 = *(uint64_t **)(a2 + 8);
      if (*((_DWORD *)v5 + 6) == 1)
      {
        *((_DWORD *)v5 + 6) = 0;
        *(_DWORD *)(a2 + 24) = 1;
        uint64_t v9 = (uint64_t *)*v5;
        *(void *)(a2 + 8) = *v5;
        if (v9) {
          v9[2] = a2;
        }
        uint64_t v10 = *(void *)(a2 + 16);
        v5[2] = v10;
        if (v10)
        {
          uint64_t v11 = *(uint64_t ***)(a2 + 16);
          if ((uint64_t *)a2 == *v11)
          {
            BIGNUM *v11 = v5;
          }
          else
          {
            v11[1] = v5;
            uint64_t v9 = *(uint64_t **)(a2 + 8);
          }
        }
        else
        {
          *result = (uint64_t)v5;
          uint64_t v4 = (uint64_t **)v5;
        }
        uint64_t *v5 = a2;
        *(void *)(a2 + 16) = v5;
        v5 = v9;
      }
      uint64_t v14 = *v5;
      if (*v5 && *(_DWORD *)(v14 + 24))
      {
        uint64_t v15 = v5[1];
        if (!v15) {
          goto LABEL_56;
        }
LABEL_37:
        if (*(_DWORD *)(v15 + 24))
        {
          *((_DWORD *)v5 + 6) = *(_DWORD *)(a2 + 24);
          *(_DWORD *)(a2 + 24) = 0;
          int v17 = v4;
          goto LABEL_64;
        }
        if (v14) {
LABEL_56:
        }
          *(_DWORD *)(v14 + 24) = 0;
        *((_DWORD *)v5 + 6) = 1;
        uint64_t v26 = *(void *)(v14 + 8);
        uint64_t *v5 = v26;
        if (v26) {
          *(void *)(v26 + 16) = v5;
        }
        uint64_t v27 = v5[2];
        *(void *)(v14 + 16) = v27;
        v28 = result;
        int v17 = (uint64_t **)v14;
        if (v27)
        {
          v28 = (uint64_t *)v5[2];
          if (v5 != (uint64_t *)*v28) {
            ++v28;
          }
          int v17 = v4;
        }
        uint64_t *v28 = v14;
        *(void *)(v14 + 8) = v5;
        v5[2] = v14;
        v5 = a3[1];
        uint64_t v15 = v5[1];
        *((_DWORD *)v5 + 6) = *((_DWORD *)a3 + 6);
        *((_DWORD *)a3 + 6) = 0;
        if (v15) {
LABEL_64:
        }
          *(_DWORD *)(v15 + 24) = 0;
        uint64_t v29 = *v5;
        a3[1] = (uint64_t *)*v5;
        if (v29) {
          *(void *)(v29 + 16) = a3;
        }
        v30 = a3[2];
        v5[2] = (uint64_t)v30;
        int v3 = (uint64_t **)v5;
        if (v30)
        {
          v31 = a3[2];
          v33 = (uint64_t **)*v31;
          v32 = v31 + 1;
          if (a3 == v33) {
            result = a3[2];
          }
          else {
            result = v32;
          }
          int v3 = v17;
        }
        *result = (uint64_t)v5;
        uint64_t *v5 = (uint64_t)a3;
        goto LABEL_73;
      }
      uint64_t v15 = v5[1];
      if (v15 && *(_DWORD *)(v15 + 24)) {
        goto LABEL_37;
      }
    }
    else
    {
      if (*((_DWORD *)v5 + 6) == 1)
      {
        *((_DWORD *)v5 + 6) = 0;
        *(_DWORD *)(a2 + 24) = 1;
        int v6 = (uint64_t *)v5[1];
        *(void *)a2 = v6;
        if (v6) {
          v6[2] = a2;
        }
        uint64_t v7 = *(void *)(a2 + 16);
        v5[2] = v7;
        if (v7)
        {
          uint64_t v8 = *(uint64_t ***)(a2 + 16);
          if ((uint64_t *)a2 == *v8)
          {
            *uint64_t v8 = v5;
            int v6 = *(uint64_t **)a2;
          }
          else
          {
            v8[1] = v5;
          }
        }
        else
        {
          *result = (uint64_t)v5;
          uint64_t v4 = (uint64_t **)v5;
        }
        v5[1] = a2;
        *(void *)(a2 + 16) = v5;
        v5 = v6;
      }
      uint64_t v12 = *v5;
      if (*v5 && *(_DWORD *)(v12 + 24)) {
        goto LABEL_35;
      }
      uint64_t v13 = (uint64_t **)v5[1];
      if (v13 && *((_DWORD *)v13 + 6))
      {
        if (v12 && *(_DWORD *)(v12 + 24))
        {
LABEL_35:
          *((_DWORD *)v5 + 6) = *(_DWORD *)(a2 + 24);
          *(_DWORD *)(a2 + 24) = 0;
          uint64_t v16 = v4;
          goto LABEL_46;
        }
        *((_DWORD *)v13 + 6) = 0;
        *((_DWORD *)v5 + 6) = 1;
        uint64_t v18 = *v13;
        v5[1] = (uint64_t)*v13;
        if (v18) {
          v18[2] = (uint64_t)v5;
        }
        int v19 = (uint64_t *)v5[2];
        v13[2] = v19;
        int v20 = result;
        uint64_t v16 = v13;
        if (v19)
        {
          int v20 = (uint64_t *)v5[2];
          if (v5 != (uint64_t *)*v20) {
            ++v20;
          }
          uint64_t v16 = v4;
        }
        uint64_t *v20 = (uint64_t)v13;
        BIGNUM *v13 = v5;
        v5[2] = (uint64_t)v13;
        v5 = *a3;
        uint64_t v12 = **a3;
        *((_DWORD *)*a3 + 6) = *((_DWORD *)a3 + 6);
        *((_DWORD *)a3 + 6) = 0;
        if (v12) {
LABEL_46:
        }
          *(_DWORD *)(v12 + 24) = 0;
        int v21 = (uint64_t *)v5[1];
        *a3 = v21;
        if (v21) {
          v21[2] = (uint64_t)a3;
        }
        int v22 = a3[2];
        v5[2] = (uint64_t)v22;
        int v3 = (uint64_t **)v5;
        if (v22)
        {
          int v23 = a3[2];
          v25 = (uint64_t **)*v23;
          v24 = v23 + 1;
          if (a3 == v25) {
            result = a3[2];
          }
          else {
            result = v24;
          }
          int v3 = v16;
        }
        *result = (uint64_t)v5;
        v5[1] = (uint64_t)a3;
LABEL_73:
        a3[2] = v5;
LABEL_74:
        if (!v3) {
          return result;
        }
        break;
      }
    }
    *((_DWORD *)v5 + 6) = 1;
    a2 = *(void *)(a2 + 16);
  }
  *((_DWORD *)v3 + 6) = 0;
  return result;
}

uint64_t x509_issuer_tree_RB_REMOVE(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *(uint64_t **)a2;
  int v3 = *(uint64_t **)(a2 + 8);
  if (!*(void *)a2)
  {
    uint64_t v9 = *(uint64_t **)(a2 + 16);
    int v15 = *(_DWORD *)(a2 + 24);
    if (!v3)
    {
      if (!v9)
      {
LABEL_26:
        uint64_t v16 = a1;
        goto LABEL_27;
      }
LABEL_21:
      uint64_t v16 = v9 + 1;
      if (*v9 == a2) {
        uint64_t v16 = v9;
      }
LABEL_27:
      void *v16 = v3;
      if (v15) {
        return a2;
      }
LABEL_28:
      x509_issuer_tree_RB_REMOVE_COLOR(a1, (uint64_t)v9, (uint64_t **)v3);
      return a2;
    }
LABEL_25:
    v3[2] = (uint64_t)v9;
    if (!v9) {
      goto LABEL_26;
    }
    goto LABEL_21;
  }
  if (!v3)
  {
    uint64_t v9 = *(uint64_t **)(a2 + 16);
    int v15 = *(_DWORD *)(a2 + 24);
    int v3 = v4;
    goto LABEL_25;
  }
  do
  {
    v5 = v3;
    int v3 = (uint64_t *)*v3;
  }
  while (v3);
  int v3 = (uint64_t *)v5[1];
  int v6 = (void *)v5[2];
  int v7 = *((_DWORD *)v5 + 6);
  if (v3) {
    v3[2] = (uint64_t)v6;
  }
  uint64_t v8 = a1;
  if (v6)
  {
    uint64_t v8 = v6 + 1;
    if ((uint64_t *)*v6 == v5) {
      uint64_t v8 = v6;
    }
  }
  *uint64_t v8 = v3;
  if (v5[2] == a2) {
    uint64_t v9 = v5;
  }
  else {
    uint64_t v9 = v6;
  }
  long long v10 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)v5 = *(_OWORD *)a2;
  *((_OWORD *)v5 + 1) = v10;
  uint64_t v11 = *(void **)(a2 + 16);
  uint64_t v12 = a1;
  if (v11)
  {
    uint64_t v12 = v11 + 1;
    if (*v11 == a2) {
      uint64_t v12 = *(uint64_t **)(a2 + 16);
    }
  }
  uint64_t *v12 = (uint64_t)v5;
  uint64_t v13 = *(void *)(a2 + 8);
  *(void *)(*(void *)a2 + 16) = v5;
  if (v13) {
    *(void *)(v13 + 16) = v5;
  }
  if (!v7) {
    goto LABEL_28;
  }
  return a2;
}

uint64_t **x509_issuer_tree_RB_INSERT(uint64_t **a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  if (*a1)
  {
    do
    {
      v5 = (uint64_t **)v4;
      int v6 = x509_issuer_cmp(a2, (uint64_t)v4);
      int v7 = v5;
      if ((v6 & 0x80000000) == 0)
      {
        if (!v6) {
          return v5;
        }
        int v7 = v5 + 1;
      }
      uint64_t v4 = *v7;
    }
    while (v4);
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = v5;
    *(void *)a2 = 0;
    *(_DWORD *)(a2 + 24) = 1;
    uint64_t v8 = v5 + 1;
    if (v6 < 0) {
      uint64_t v8 = v5;
    }
  }
  else
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(_DWORD *)(a2 + 24) = 1;
    uint64_t v8 = a1;
  }
  *uint64_t v8 = a2;
  x509_issuer_tree_RB_INSERT_COLOR(a1, (uint64_t *)a2);
  return 0;
}

uint64_t x509_issuer_cmp(uint64_t a1, uint64_t a2)
{
  uint64_t result = memcmp(*(const void **)(a1 + 48), *(const void **)(a2 + 48), 0x40uLL);
  if (!result)
  {
    v5 = *(const void **)(a1 + 56);
    int v6 = *(const void **)(a2 + 56);
    return memcmp(v5, v6, 0x40uLL);
  }
  return result;
}

void *x509_issuer_tree_RB_FIND(void **a1, uint64_t a2)
{
  for (i = *a1; i; i = (void *)*i)
  {
    int v4 = x509_issuer_cmp(a2, (uint64_t)i);
    if ((v4 & 0x80000000) == 0)
    {
      if (!v4) {
        return i;
      }
      ++i;
    }
  }
  return i;
}

void *x509_issuer_tree_RB_NFIND(void **a1, uint64_t a2)
{
  size_t v2 = *a1;
  if (*a1)
  {
    int v4 = 0;
    while (1)
    {
      int v5 = x509_issuer_cmp(a2, (uint64_t)v2);
      if (v5 < 0)
      {
        int v4 = v2;
      }
      else
      {
        if (!v5) {
          return v2;
        }
        ++v2;
      }
      size_t v2 = (void *)*v2;
      if (!v2) {
        return v4;
      }
    }
  }
  return 0;
}

void *x509_issuer_tree_RB_NEXT(uint64_t a1)
{
  int v1 = *(void **)(a1 + 8);
  if (v1)
  {
    do
    {
      uint64_t result = v1;
      int v1 = (void *)*v1;
    }
    while (v1);
  }
  else
  {
    uint64_t v3 = a1;
    uint64_t result = *(void **)(a1 + 16);
    if (!result || *result != v3)
    {
      do
      {
        uint64_t result = *(void **)(v3 + 16);
        if (!result) {
          break;
        }
        BOOL v4 = v3 == result[1];
        uint64_t v3 = *(void *)(v3 + 16);
      }
      while (v4);
    }
  }
  return result;
}

void *x509_issuer_tree_RB_PREV(void *a1)
{
  int v1 = (void *)*a1;
  if (*a1)
  {
    do
    {
      uint64_t result = v1;
      int v1 = (void *)v1[1];
    }
    while (v1);
  }
  else
  {
    uint64_t v3 = a1;
    uint64_t result = (void *)a1[2];
    if (!result || (void *)result[1] != v3)
    {
      do
      {
        uint64_t result = (void *)v3[2];
        if (!result) {
          break;
        }
        BOOL v4 = v3 == (void *)*result;
        uint64_t v3 = (void *)v3[2];
      }
      while (v4);
    }
  }
  return result;
}

void *x509_issuer_tree_RB_MINMAX(void *a1, int a2)
{
  size_t v2 = (void *)*a1;
  if (!*a1) {
    return 0;
  }
  do
  {
    uint64_t result = v2;
    BOOL v4 = v2 + 1;
    if (a2 < 0) {
      BOOL v4 = result;
    }
    size_t v2 = (void *)*v4;
  }
  while (v2);
  return result;
}

uint64_t x509_issuer_cache_set_max(uint64_t a1)
{
  if (pthread_mutex_lock(&x509_issuer_tree_mutex)) {
    return 0;
  }
  x509_issuer_cache_max = a1;
  pthread_mutex_unlock(&x509_issuer_tree_mutex);
  return 1;
}

void x509_issuer_cache_free_oldest()
{
  if (x509_issuer_cache_count)
  {
    uint64_t v0 = **((void **)off_268BA9B18 + 1);
    uint64_t v1 = *(void *)(v0 + 32);
    size_t v2 = *(void **)(v0 + 40);
    if (v1)
    {
      *(void *)(v1 + 40) = v2;
      size_t v2 = *(void **)(v0 + 40);
    }
    else
    {
      off_268BA9B18 = *(_UNKNOWN **)(v0 + 40);
    }
    *size_t v2 = v1;
    x509_issuer_tree_RB_REMOVE((uint64_t *)&x509_issuer_cache, v0);
    free(*(void **)(v0 + 48));
    free(*(void **)(v0 + 56));
    free((void *)v0);
    --x509_issuer_cache_count;
  }
}

uint64_t x509_issuer_cache_free()
{
  uint64_t result = pthread_mutex_lock(&x509_issuer_tree_mutex);
  if (!result)
  {
    while (x509_issuer_cache_count)
      x509_issuer_cache_free_oldest();
    return pthread_mutex_unlock(&x509_issuer_tree_mutex);
  }
  return result;
}

uint64_t x509_issuer_cache_find(uint64_t a1, uint64_t a2)
{
  memset(v11, 0, sizeof(v11));
  uint64_t v12 = a1;
  uint64_t v13 = a2;
  uint64_t v14 = 0;
  if (!x509_issuer_cache_max || pthread_mutex_lock(&x509_issuer_tree_mutex)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = x509_issuer_tree_RB_FIND(&x509_issuer_cache, (uint64_t)v11);
  if (v3)
  {
    uint64_t v4 = v3[4];
    int v5 = (void *)v3[5];
    if (v4)
    {
      *(void *)(v4 + 40) = v5;
      int v5 = (void *)v3[5];
    }
    else
    {
      off_268BA9B18 = (_UNKNOWN *)v3[5];
    }
    void *v5 = v4;
    int v6 = (char *)x509_issuer_lru;
    v3[4] = x509_issuer_lru;
    int v7 = v6 + 40;
    BOOL v8 = v6 == 0;
    x509_issuer_lru = v3;
    uint64_t v9 = &off_268BA9B18;
    if (!v8) {
      uint64_t v9 = v7;
    }
    void *v9 = v3 + 4;
    v3[5] = &x509_issuer_lru;
    uint64_t v2 = *((unsigned int *)v3 + 16);
  }
  else
  {
    uint64_t v2 = 0xFFFFFFFFLL;
  }
  pthread_mutex_unlock(&x509_issuer_tree_mutex);
  return v2;
}

void x509_issuer_cache_add(long long *a1, long long *a2, unsigned int a3)
{
  if (a3 > 1) {
    return;
  }
  if (!x509_issuer_cache_max) {
    return;
  }
  int v6 = malloc_type_calloc(1uLL, 0x48uLL, 0x10B004061D455DBuLL);
  if (!v6) {
    return;
  }
  uint64_t v7 = (uint64_t)v6;
  BOOL v8 = malloc_type_calloc(1uLL, 0x40uLL, 0x5D37DD96uLL);
  *(void *)(v7 + 48) = v8;
  if (v8)
  {
    long long v9 = *a1;
    long long v10 = a1[1];
    long long v11 = a1[3];
    v8[2] = a1[2];
    v8[3] = v11;
    *BOOL v8 = v9;
    v8[1] = v10;
    uint64_t v12 = malloc_type_calloc(1uLL, 0x40uLL, 0xE84DAE18uLL);
    *(void *)(v7 + 56) = v12;
    if (v12)
    {
      long long v13 = *a2;
      long long v14 = a2[1];
      long long v15 = a2[3];
      v12[2] = a2[2];
      v12[3] = v15;
      _OWORD *v12 = v13;
      v12[1] = v14;
      *(_DWORD *)(v7 + 64) = a3;
      if (!pthread_mutex_lock(&x509_issuer_tree_mutex))
      {
        while (1)
        {
          uint64_t v16 = x509_issuer_cache_count;
          if (x509_issuer_cache_count < (unint64_t)x509_issuer_cache_max) {
            break;
          }
          x509_issuer_cache_free_oldest();
        }
        if (!x509_issuer_tree_RB_INSERT(&x509_issuer_cache, v7))
        {
          int v17 = (char *)x509_issuer_lru;
          *(void *)(v7 + 32) = x509_issuer_lru;
          x509_issuer_lru = (_UNKNOWN *)v7;
          if (v17) {
            uint64_t v18 = v17 + 40;
          }
          else {
            uint64_t v18 = &off_268BA9B18;
          }
          void *v18 = v7 + 32;
          *(void *)(v7 + 40) = &x509_issuer_lru;
          x509_issuer_cache_count = v16 + 1;
          pthread_mutex_unlock(&x509_issuer_tree_mutex);
          uint64_t v7 = 0;
          goto LABEL_13;
        }
        pthread_mutex_unlock(&x509_issuer_tree_mutex);
      }
    }
  }
  free(*(void **)(v7 + 48));
  free(*(void **)(v7 + 56));
LABEL_13:
  free((void *)v7);
}

void ENGINE_add_conf_module(void)
{
}

uint64_t int_engine_module_init(const CONF_IMODULE *a1, const CONF *a2)
{
  value = CONF_imodule_get_value(a1);
  section = NCONF_get_section(a2, value);
  if (!section)
  {
    int v23 = 148;
    int v24 = 223;
    goto LABEL_50;
  }
  int v5 = section;
  if (sk_num(section) < 1) {
    return 1;
  }
  int v6 = 0;
  uint64_t v26 = v5;
  conf = (CONF *)a2;
LABEL_4:
  uint64_t v7 = sk_value(v5, v6);
  BOOL v8 = (char *)*((void *)v7 + 1);
  long long v9 = (const char *)*((void *)v7 + 2);
  uint64_t result = -1;
  long long v10 = strchr(v8, 46);
  long long v11 = NCONF_get_section(a2, v9);
  if (v11)
  {
    uint64_t v12 = v11;
    int v28 = v6;
    if (sk_num(v11) < 1)
    {
      long long v13 = 0;
      goto LABEL_45;
    }
    int v29 = 0;
    long long v13 = 0;
    int v14 = 0;
    if (v10) {
      long long v15 = v10 + 1;
    }
    else {
      long long v15 = v8;
    }
    while (1)
    {
      uint64_t v16 = sk_value(v12, v14);
      int v17 = (char *)*((void *)v16 + 1);
      uint64_t v18 = strchr(v17, 46);
      if (v18) {
        int v17 = v18 + 1;
      }
      int v19 = (const char *)*((void *)v16 + 2);
      if (!strcmp(v17, "engine_id"))
      {
        long long v15 = v19;
      }
      else if (!strcmp(v17, "soft_load"))
      {
        int v29 = 1;
      }
      else
      {
        if (!strcmp(v17, "dynamic_path"))
        {
          int v22 = ENGINE_by_id("dynamic");
          long long v13 = v22;
          if (!v22
            || !ENGINE_ctrl_cmd_string(v22, "SO_PATH", v19, 0)
            || !ENGINE_ctrl_cmd_string(v13, "LIST_ADD", "2", 0)
            || !ENGINE_ctrl_cmd_string(v13, "LOAD", 0, 0))
          {
            goto LABEL_54;
          }
          goto LABEL_36;
        }
        if (!v13)
        {
          int v20 = ENGINE_by_id(v15);
          long long v13 = v20;
          if (!v20 && v29)
          {
            ERR_clear_error();
            int v5 = v26;
            a2 = conf;
            goto LABEL_46;
          }
          if (!v20) {
            goto LABEL_54;
          }
        }
        if (!strcmp(v19, "EMPTY")) {
          int v19 = 0;
        }
        if (strcmp(v17, "init"))
        {
          if (!strcmp(v17, "default_algorithms")) {
            int v21 = ENGINE_set_default_string(v13, v19);
          }
          else {
            int v21 = ENGINE_ctrl_cmd_string(v13, v17, v19, 0);
          }
LABEL_35:
          if (!v21) {
            goto LABEL_54;
          }
          goto LABEL_36;
        }
        if (!NCONF_get_number_e(conf, v9, "init", &result)) {
          goto LABEL_54;
        }
        if (result)
        {
          if (result != 1)
          {
            ERR_put_error(38, 4095, 151, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_cnf.c", 177);
LABEL_54:
            ERR_put_error(38, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_cnf.c", 197);
            ERR_asprintf_error_data("section=%s, name=%s, value=%s", *(const char **)v16, *((const char **)v16 + 1), *((const char **)v16 + 2));
LABEL_55:
            ENGINE_free(v13);
            return 0;
          }
          int v21 = int_engine_init(v13);
          goto LABEL_35;
        }
      }
LABEL_36:
      if (++v14 >= sk_num(v12))
      {
        if (!v13)
        {
          int v5 = v26;
          a2 = conf;
          goto LABEL_45;
        }
        int v5 = v26;
        a2 = conf;
        if (result == -1 && !int_engine_init(v13))
        {
          ERR_put_error(38, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_cnf.c", 197);
          goto LABEL_55;
        }
LABEL_45:
        ENGINE_free(v13);
LABEL_46:
        ++v6;
        if (v28 + 1 >= sk_num(v5)) {
          return 1;
        }
        goto LABEL_4;
      }
    }
  }
  int v23 = 149;
  int v24 = 118;
LABEL_50:
  ERR_put_error(38, 4095, v23, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_cnf.c", v24);
  return 0;
}

void int_engine_module_finish()
{
  while (1)
  {
    uint64_t v0 = sk_pop((STACK *)initialized_engines);
    if (!v0) {
      break;
    }
    ENGINE_finish((ENGINE *)v0);
  }
  sk_free((STACK *)initialized_engines);
  initialized_engines = 0;
}

uint64_t int_engine_init(ENGINE *a1)
{
  uint64_t result = ENGINE_init(a1);
  if (result)
  {
    uint64_t v3 = (STACK *)initialized_engines;
    if ((initialized_engines || (uint64_t v3 = sk_new_null(), (initialized_engines = (uint64_t)v3) != 0))
      && sk_push(v3, (char *)a1))
    {
      return 1;
    }
    else
    {
      ENGINE_finish(a1);
      return 0;
    }
  }
  return result;
}

ASN1_VALUE *__cdecl ASN1_item_d2i(ASN1_VALUE **val, const unsigned __int8 **in, uint64_t len, const ASN1_ITEM *it)
{
  uint64_t v7 = 0;
  if (val) {
    int v5 = val;
  }
  else {
    int v5 = (ASN1_VALUE **)&v7;
  }
  if (ASN1_item_ex_d2i(v5, in, len, it, -1, 0, 0, v4) < 1) {
    return 0;
  }
  else {
    return *v5;
  }
}

int ASN1_item_ex_d2i(ASN1_VALUE **pval, const unsigned __int8 **in, uint64_t len, const ASN1_ITEM *it, int tag, int aclass, char opt, ASN1_TLC *ctx)
{
  if (len < 0) {
    return 0;
  }
  int v8 = opt;
  uint64_t v9 = *(void *)&aclass;
  uint64_t v10 = *(void *)&tag;
  memset(v15, 0, sizeof(v15));
  CBS_init(v15, (uint64_t)*in, len);
  int result = asn1_item_d2i((uint64_t)pval, v15, (ASN1_ITEM *)it, v10, v9, v8, 0);
  if (result == 1)
  {
    unsigned __int8 *in = (const unsigned __int8 *)CBS_data((uint64_t)v15);
    return 1;
  }
  return result;
}

uint64_t asn1_item_d2i(uint64_t pval, uint64_t *a2, ASN1_ITEM *it, uint64_t a4, uint64_t a5, int a6, int a7)
{
  if (!pval) {
    return pval;
  }
  int v8 = (ASN1_TYPE **)pval;
  if (a7 >= 30)
  {
    int v9 = 219;
    int v10 = 948;
LABEL_4:
    ERR_put_error(13, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", v10);
LABEL_5:
    long long v11 = (ASN1_VALUE **)v8;
LABEL_6:
    ASN1_item_ex_free(v11, it);
LABEL_7:
    ERR_asprintf_error_data("Type=%s");
    return 0;
  }
  pval = 0;
  switch(it->itype)
  {
    case 0:
      templates = it->templates;
      if (templates)
      {
        if (a4 != -1 || a6)
        {
          int v9 = 170;
          int v10 = 963;
          goto LABEL_4;
        }
        return asn1_template_d2i((uint64_t)v8, a2, (uint64_t)templates, 0);
      }
      else
      {
        return asn1_d2i_primitive(v8, (uint64_t)a2, (uint64_t)it, a4, a5, a6);
      }
    case 1:
    case 6:
      pvala[0] = 0;
      pvala[1] = 0;
      *(void *)&long long v68 = 0;
      memset(v75, 0, sizeof(v75));
      *(void *)in = 0;
      uint64_t v73 = 0;
      uint64_t v74 = 0;
      v70 = 0;
      uint64_t v71 = 0;
      *(void *)tag = 0;
      uint64_t v16 = CBS_data((uint64_t)a2);
      uint64_t v17 = CBS_len((uint64_t)a2);
      CBS_init(pvala, v16, v17);
      funcs = it->funcs;
      if (funcs) {
        int v19 = (unsigned int (*)(uint64_t, ASN1_VALUE **, ASN1_ITEM *, void))funcs[3];
      }
      else {
        int v19 = 0;
      }
      int itype = it->itype;
      if (itype != 6 && itype != 1) {
        goto LABEL_137;
      }
      if (*v8)
      {
        ASN1_item_ex_free((ASN1_VALUE **)v8, it);
        *int v8 = 0;
      }
      if (a4 == -1) {
        int v34 = 0;
      }
      else {
        int v34 = a5;
      }
      if (a4 == -1) {
        int v35 = 16;
      }
      else {
        int v35 = a4;
      }
      pval = asn1_check_tag(pvala, tag, 0, 0, &v71, (_DWORD *)&v71 + 1, v35, v34, a6);
      if (pval == -1) {
        return pval;
      }
      if (pval != 1)
      {
        int v39 = 58;
        int v40 = 777;
        goto LABEL_136;
      }
      if (!HIDWORD(v71))
      {
        int v39 = 149;
        int v40 = 782;
        goto LABEL_136;
      }
      int v36 = v71;
      if (v71)
      {
        uint64_t v37 = CBS_data((uint64_t)pvala);
        uint64_t v38 = CBS_len((uint64_t)pvala);
        CBS_init(v75, v37, v38);
      }
      else if (!CBS_get_bytes((uint64_t *)pvala, v75, *(unint64_t *)tag))
      {
        goto LABEL_137;
      }
      if (!ASN1_item_ex_new(&v70, it))
      {
        int v39 = 58;
        int v40 = 796;
        goto LABEL_136;
      }
      if (v19 && !v19(4, &v70, it, 0))
      {
        int v39 = 100;
        int v40 = 801;
        goto LABEL_136;
      }
      if (it->tcount < 1)
      {
        LODWORD(v50) = 0;
LABEL_93:
        if (v36 && !asn1_check_eoc(v75))
        {
          int v39 = 137;
          int v40 = 848;
          goto LABEL_136;
        }
        if (!v71)
        {
          if (CBS_len((uint64_t)v75))
          {
            int v39 = 148;
            int v40 = 856;
            goto LABEL_136;
          }
          goto LABEL_116;
        }
      }
      else
      {
        uint64_t v49 = 0;
        uint64_t v50 = 0;
        while (1)
        {
          v51 = it->templates;
          if (asn1_check_eoc(v75)) {
            break;
          }
          if (!CBS_len((uint64_t)v75)) {
            goto LABEL_93;
          }
          v52 = asn1_do_adb(&v70, &v51[v49], 1);
          if (!v52) {
            goto LABEL_137;
          }
          v53 = v52;
          field_ptr = asn1_get_field_ptr(&v70, v52);
          v55 = field_ptr;
          if (v50 == it->tcount - 1) {
            int v56 = 0;
          }
          else {
            int v56 = v53->flags & 1;
          }
          int v57 = asn1_template_d2i((uint64_t)field_ptr, v75, (uint64_t)v53, v56);
          if (v57 != 1)
          {
            if (v57 != -1) {
              goto LABEL_132;
            }
            ASN1_template_free(v55, v53);
          }
          ++v50;
          ++v49;
          if (it->tcount <= v50) {
            goto LABEL_93;
          }
        }
        if (!v71)
        {
          int v39 = 159;
          int v40 = 810;
          goto LABEL_136;
        }
      }
      unint64_t v59 = CBS_offset((uint64_t)v75);
      if (!CBS_skip(pvala, v59)) {
        goto LABEL_137;
      }
LABEL_116:
      if (it->tcount > v50)
      {
        uint64_t v60 = v50;
        uint64_t v61 = v50;
        while (1)
        {
          v62 = asn1_do_adb(&v70, &it->templates[v61], 1);
          if (!v62) {
            goto LABEL_137;
          }
          v63 = v62;
          if ((v62->flags & 1) == 0) {
            break;
          }
          v64 = asn1_get_field_ptr(&v70, v62);
          ASN1_template_free(v64, v63);
          ++v60;
          ++v61;
          if (it->tcount <= v60) {
            goto LABEL_121;
          }
        }
        ERR_put_error(13, 4095, 121, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", 871);
LABEL_132:
        ASN1_item_ex_free(&v70, it);
        goto LABEL_133;
      }
LABEL_121:
      unint64_t v65 = CBS_offset((uint64_t)pvala);
      if (!CBS_get_bytes(a2, in, v65))
      {
LABEL_137:
        long long v11 = &v70;
        goto LABEL_6;
      }
      if (asn1_enc_save(&v70, in, (int)it, v66))
      {
        if (!v19 || v19(5, &v70, it, 0))
        {
          v58 = v70;
          goto LABEL_126;
        }
        int v39 = 100;
        int v40 = 890;
      }
      else
      {
        int v39 = 65;
        int v40 = 885;
      }
LABEL_136:
      ERR_put_error(13, 4095, v39, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", v40);
      goto LABEL_137;
    case 2:
      int v21 = it->itype;
      pvala[0] = 0;
      int v22 = it->funcs;
      if (v22) {
        int v23 = (unsigned int (*)(uint64_t, ASN1_VALUE **, ASN1_ITEM *, void))v22[3];
      }
      else {
        int v23 = 0;
      }
      if (v21 != 2) {
        goto LABEL_52;
      }
      if (a4 != -1)
      {
        int v41 = 230;
        int v42 = 663;
        goto LABEL_51;
      }
      if (*v8)
      {
        ASN1_item_ex_free((ASN1_VALUE **)v8, it);
        *int v8 = 0;
      }
      if (!ASN1_item_ex_new(pvala, it))
      {
        int v41 = 58;
        int v42 = 673;
        goto LABEL_51;
      }
      if (v23 && !v23(4, pvala, it, 0))
      {
        int v41 = 100;
        int v42 = 678;
        goto LABEL_51;
      }
      uint64_t tcount = it->tcount;
      if (tcount < 1)
      {
        uint64_t v44 = 0;
      }
      else
      {
        uint64_t v44 = 0;
        uint64_t v45 = 24;
        while (1)
        {
          v46 = it->templates;
          v47 = asn1_get_field_ptr(pvala, (const ASN1_TEMPLATE *)((char *)v46 + v45 - 24));
          int v48 = asn1_template_d2i((uint64_t)v47, a2, (uint64_t)v46 + v45 - 24, 1);
          if (v48 != -1) {
            break;
          }
          ++v44;
          uint64_t tcount = it->tcount;
          v45 += 40;
          if (tcount <= v44) {
            goto LABEL_102;
          }
        }
        if (v48 != 1)
        {
          ERR_put_error(13, 4095, 58, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", 693);
          ASN1_item_ex_free(pvala, it);
          if (!v46) {
            goto LABEL_7;
          }
LABEL_133:
          ERR_asprintf_error_data("Field=%s, Type=%s");
          return 0;
        }
        asn1_set_choice_selector(pvala, v44, it);
        uint64_t tcount = it->tcount;
      }
LABEL_102:
      if (tcount == v44)
      {
        if (a6)
        {
          ASN1_item_ex_free(pvala, it);
          return 0xFFFFFFFFLL;
        }
        int v41 = 143;
        int v42 = 709;
        goto LABEL_51;
      }
      if (v23 && !v23(5, pvala, it, 0))
      {
        int v41 = 100;
        int v42 = 714;
LABEL_51:
        ERR_put_error(13, 4095, v41, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", v42);
LABEL_52:
        long long v11 = pvala;
        goto LABEL_6;
      }
      v58 = pvala[0];
LABEL_126:
      *int v8 = (ASN1_TYPE *)v58;
      return 1;
    case 4:
      int v24 = it->funcs;
      *(_OWORD *)pvala = 0u;
      long long v68 = 0u;
      if (CBS_len((uint64_t)a2) < 0) {
        return 0;
      }
      v75[0] = (unsigned __int16 *)CBS_data((uint64_t)a2);
      v25 = (uint64_t (*)(ASN1_TYPE **, unsigned __int16 **, uint64_t, ASN1_ITEM *, uint64_t, uint64_t, void, ASN1_VALUE **))v24[4];
      uint64_t v26 = CBS_len((uint64_t)a2);
      pval = v25(v8, v75, v26, it, a4, a5, (char)a6, pvala);
      if (pval != 1) {
        return pval;
      }
      uint64_t v27 = v75[0];
      uint64_t v28 = CBS_data((uint64_t)a2);
      if (CBS_skip(a2, (unint64_t)v27 - v28)) {
        return 1;
      }
      goto LABEL_5;
    case 5:
      *(_DWORD *)in = 0;
      LODWORD(v70) = 0;
      BYTE4(v71) = 0;
      tag[0] = 0;
      pvala[0] = 0;
      pvala[1] = 0;
      *(void *)&long long v68 = 0;
      v75[0] = 0;
      uint64_t v29 = CBS_data((uint64_t)a2);
      uint64_t v30 = CBS_len((uint64_t)a2);
      CBS_init(pvala, v29, v30);
      if (a4 != -1)
      {
        int v31 = 230;
        int v32 = 576;
LABEL_69:
        ERR_put_error(13, 4095, v31, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", v32);
        return 0;
      }
      if (asn1_check_tag(pvala, v75, tag, (unsigned char *)&v71 + 4, &v70, in, -1, 0, 1) != 1)
      {
        int v31 = 58;
        int v32 = 582;
        goto LABEL_69;
      }
      if (BYTE4(v71))
      {
        if (!a6)
        {
          int v31 = 139;
          int v32 = 590;
          goto LABEL_69;
        }
      }
      else
      {
        if ((it->utype & ASN1_tag2bit(tag[0])) != 0) {
          return asn1_d2i_primitive_content(v8, a2, (unsigned __int16 **)pvala, tag[0], *(int *)in, v70, (unint64_t)v75[0], (uint64_t)it);
        }
        if (!a6)
        {
          int v31 = 140;
          int v32 = 597;
          goto LABEL_69;
        }
      }
      return 0xFFFFFFFFLL;
    default:
      return pval;
  }
}

int ASN1_template_d2i(ASN1_VALUE **pval, const unsigned __int8 **in, uint64_t len, const ASN1_TEMPLATE *tt)
{
  if (len < 0) {
    return 0;
  }
  memset(v8, 0, sizeof(v8));
  CBS_init(v8, (uint64_t)*in, len);
  int result = asn1_template_d2i((uint64_t)pval, v8, (uint64_t)tt, 0);
  if (result == 1)
  {
    unsigned __int8 *in = (const unsigned __int8 *)CBS_data((uint64_t)v8);
    return 1;
  }
  return result;
}

uint64_t asn1_template_d2i(uint64_t result, void *a2, uint64_t a3, int a4)
{
  if (!result) {
    return result;
  }
  uint64_t v7 = (ASN1_VALUE **)result;
  if ((*(unsigned char *)a3 & 0x10) != 0)
  {
    memset(v21, 0, sizeof(v21));
    uint64_t v19 = 0;
    memset(v20, 0, sizeof(v20));
    unint64_t v18 = 0;
    uint64_t v8 = CBS_data((uint64_t)a2);
    uint64_t v9 = CBS_len((uint64_t)a2);
    CBS_init(v21, v8, v9);
    int result = asn1_check_tag(v21, &v18, 0, 0, &v19, (_DWORD *)&v19 + 1, *(_DWORD *)(a3 + 8), *(_DWORD *)a3 & 0xC0, a4);
    if (result == -1) {
      return result;
    }
    if (result == 1)
    {
      if (HIDWORD(v19))
      {
        if (v19)
        {
          uint64_t v10 = CBS_data((uint64_t)v21);
          uint64_t v11 = CBS_len((uint64_t)v21);
          CBS_init(v20, v10, v11);
        }
        else if (!CBS_get_bytes(v21, v20, v18))
        {
          goto LABEL_29;
        }
        if (asn1_template_noexp_d2i(v7, v20, a3, 0) == 1)
        {
          if (v19)
          {
            if (asn1_check_eoc(v20))
            {
              unint64_t v14 = CBS_offset((uint64_t)v20);
              if (!CBS_skip(v21, v14)) {
                goto LABEL_29;
              }
LABEL_25:
              unint64_t v17 = CBS_offset((uint64_t)v21);
              if (CBS_skip(a2, v17)) {
                return 1;
              }
              goto LABEL_29;
            }
            int v15 = 137;
            int v16 = 1207;
          }
          else
          {
            if (!CBS_len((uint64_t)v20)) {
              goto LABEL_25;
            }
            int v15 = 148;
            int v16 = 1213;
          }
          ERR_put_error(13, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", v16);
LABEL_29:
          ASN1_template_free(v7, (const ASN1_TEMPLATE *)a3);
          return 0;
        }
        int v12 = 58;
        int v13 = 1201;
      }
      else
      {
        int v12 = 120;
        int v13 = 1188;
      }
    }
    else
    {
      int v12 = 58;
      int v13 = 1183;
    }
    ERR_put_error(13, 4095, v12, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", v13);
    return 0;
  }
  return asn1_template_noexp_d2i((ASN1_VALUE **)result, a2, a3, a4);
}

uint64_t asn1_d2i_primitive(ASN1_TYPE **a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6)
{
  memset(v31, 0, sizeof(v31));
  unint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v12 = *(unsigned int *)(a3 + 8);
  uint64_t v13 = CBS_data(a2);
  uint64_t v14 = CBS_len(a2);
  CBS_init(v31, v13, v14);
  uint64_t result = 0;
  if (*(unsigned char *)a3 != 5)
  {
    if (*(void *)(a3 + 8) == -4)
    {
      uint64_t v36 = 0;
      char v35 = 0;
      unsigned int v34 = 0;
      memset(v33, 0, sizeof(v33));
      unint64_t v32 = 0;
      uint64_t v16 = CBS_data(a2);
      uint64_t v17 = CBS_len(a2);
      CBS_init(v33, v16, v17);
      uint64_t result = 0;
      if (*(void *)(a3 + 8) != -4) {
        return result;
      }
      if ((a4 & 0x80000000) == 0)
      {
        int v18 = 127;
        int v19 = 538;
LABEL_23:
        ERR_put_error(13, 4095, v18, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", v19);
        return 0;
      }
      if (a6)
      {
        int v18 = 126;
        int v19 = 542;
        goto LABEL_23;
      }
      if (asn1_check_tag(v33, &v32, &v34, &v35, &v36, (_DWORD *)&v36 + 1, -1, 0, 0) != 1)
      {
        int v18 = 58;
        int v19 = 549;
        goto LABEL_23;
      }
      if (v35)
      {
        uint64_t v28 = 4294967293;
        unsigned int v34 = -3;
      }
      else
      {
        uint64_t v28 = v34;
      }
      unsigned int v23 = v36;
      int v22 = HIDWORD(v36);
      unint64_t v24 = v32;
      v25 = (unsigned __int16 **)v33;
      uint64_t v26 = a1;
      uint64_t v27 = (void *)a2;
      return asn1_d2i_primitive_content(v26, v27, v25, v28, v22, v23, v24, a3);
    }
    if (a4 == -1) {
      int v20 = *(void *)(a3 + 8);
    }
    else {
      int v20 = a4;
    }
    if (a4 == -1) {
      int v21 = 0;
    }
    else {
      int v21 = a5;
    }
    uint64_t result = asn1_check_tag(v31, &v29, 0, 0, &v30, (_DWORD *)&v30 + 1, v20, v21, a6);
    if (result != -1)
    {
      if (result != 1)
      {
        int v18 = 58;
        int v19 = 633;
        goto LABEL_23;
      }
      unsigned int v23 = v30;
      int v22 = HIDWORD(v30);
      unint64_t v24 = v29;
      v25 = (unsigned __int16 **)v31;
      uint64_t v26 = a1;
      uint64_t v27 = (void *)a2;
      uint64_t v28 = v12;
      return asn1_d2i_primitive_content(v26, v27, v25, v28, v22, v23, v24, a3);
    }
  }
  return result;
}

uint64_t asn1_check_tag(void *a1, void *a2, _DWORD *a3, unsigned char *a4, _DWORD *a5, _DWORD *a6, int a7, int a8, int a9)
{
  if (a2) {
    *a2 = 0;
  }
  if (a3) {
    *a3 = 0;
  }
  if (a4) {
    *a4 = 0;
  }
  if (a5) {
    *a5 = 0;
  }
  if (a6) {
    *a6 = 0;
  }
  uint64_t v24 = 0;
  int v23 = 0;
  unsigned __int8 v22 = 0;
  unint64_t v21 = 0;
  if (!asn1_get_identifier_cbs(a1, 0, &v22, (int *)&v24 + 1, &v23))
  {
    int v17 = 102;
    int v18 = 127;
    goto LABEL_42;
  }
  if ((a7 & 0x80000000) == 0 && (v23 != a7 || a8 != v22 << 6))
  {
    if (a9) {
      return 0xFFFFFFFFLL;
    }
    int v17 = 168;
    int v18 = 137;
    goto LABEL_42;
  }
  if (!asn1_get_length_cbs(a1, 0, &v24, &v21))
  {
    int v17 = 102;
    int v18 = 142;
    goto LABEL_42;
  }
  if (v24 && !HIDWORD(v24))
  {
    int v17 = 102;
    int v18 = 148;
LABEL_42:
    ERR_put_error(13, 4095, v17, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", v18);
    return 0;
  }
  if (!v24)
  {
    unint64_t v20 = CBS_len((uint64_t)a1);
    if (v20 < v21)
    {
      int v17 = 155;
      int v18 = 153;
      goto LABEL_42;
    }
  }
  if (v23 < 0)
  {
    int v17 = 155;
    int v18 = 158;
    goto LABEL_42;
  }
  if (v24) {
    unint64_t v21 = CBS_len((uint64_t)a1);
  }
  if (a2) {
    *a2 = v21;
  }
  if (a3) {
    *a3 = v23;
  }
  if (a4) {
    *a4 = v22 << 6;
  }
  if (a5) {
    *a5 = v24;
  }
  if (a6) {
    *a6 = HIDWORD(v24);
  }
  return 1;
}

BOOL asn1_d2i_primitive_content(ASN1_TYPE **a1, void *a2, unsigned __int16 **a3, uint64_t a4, int a5, unsigned int a6, unint64_t a7, uint64_t a8)
{
  memset(v38, 0, sizeof(v38));
  memset(v37, 0, sizeof(v37));
  size_t v35 = 0;
  uint64_t v36 = 0;
  memset(v34, 0, sizeof(v34));
  CBS_dup(a2, v37);
  CBS_init(v38, 0, 0);
  BOOL must_be_constructed = asn1_must_be_constructed(a4);
  if (a5 || !must_be_constructed)
  {
    int must_be_primitive = asn1_must_be_primitive(a4);
    if (a5 && must_be_primitive)
    {
      int v17 = 231;
      int v18 = 473;
      goto LABEL_7;
    }
    if ((a4 + 3) <= 0x14 && ((1 << (a4 + 3)) & 0x180001) != 0)
    {
      unint64_t v40 = a7;
      unsigned int v39 = a6;
      if (a6)
      {
        uint64_t v22 = 1;
        while (CBS_len((uint64_t)a3))
        {
          if (asn1_check_eoc(a3))
          {
            if (!--v22) {
              goto LABEL_32;
            }
          }
          else
          {
            if (!asn1_check_tag(a3, &v40, 0, 0, &v39, 0, -1, 0, 0))
            {
              int v17 = 58;
              int v18 = 257;
              goto LABEL_7;
            }
            if (v39)
            {
              ++v22;
            }
            else if (!CBS_skip(a3, v40))
            {
              goto LABEL_8;
            }
          }
        }
        if (!v22) {
          goto LABEL_32;
        }
        int v17 = 137;
        int v18 = 269;
        goto LABEL_7;
      }
      if (!CBS_skip(a3, a7))
      {
        int v17 = 58;
        int v18 = 241;
        goto LABEL_7;
      }
LABEL_32:
      unint64_t v23 = CBS_offset((uint64_t)a3);
      uint64_t v24 = v37;
    }
    else
    {
      if (a5)
      {
        if (!CBB_init((uint64_t)v34, 0)
          || !asn1_collect((char **)v34, (uint64_t *)a3, a6, 0)
          || !CBB_finish((uint64_t *)v34, &v36, &v35))
        {
          goto LABEL_8;
        }
        CBS_init(v38, (uint64_t)v36, v35);
        goto LABEL_36;
      }
      uint64_t v24 = (uint64_t *)a3;
      unint64_t v23 = a7;
    }
    if (!CBS_get_bytes(v24, v38, v23)) {
      goto LABEL_8;
    }
LABEL_36:
    if ((unint64_t)CBS_len((uint64_t)v38) >> 31) {
      goto LABEL_8;
    }
    uint64_t v25 = *(void *)(a8 + 32);
    if (v25)
    {
      LOBYTE(v40) = 0;
      uint64_t v26 = *(uint64_t (**)(ASN1_TYPE **, uint64_t, uint64_t, uint64_t, unint64_t *, uint64_t))(v25 + 40);
      if (v26)
      {
        uint64_t v27 = CBS_data((uint64_t)v38);
        uint64_t v28 = CBS_len((uint64_t)v38);
        int v29 = v26(a1, v27, v28, a4, &v40, a8);
      }
      else
      {
        int v29 = 0;
      }
    }
    else
    {
      if (*(void *)(a8 + 8) == -4)
      {
        if (*a1)
        {
          ASN1_TYPE_free(*a1);
          *a1 = 0;
        }
        uint64_t v30 = ASN1_TYPE_new();
        if (!v30) {
          goto LABEL_8;
        }
        int v31 = v30;
        p_value = &v30->value;
        if (!asn1_c2i_primitive((ASN1_VALUE **)&v30->value, v38, a4, a8))
        {
          ASN1_TYPE_free(v31);
          goto LABEL_8;
        }
        v31->type = a4;
        if (a4 == 5) {
          p_value->ptr = 0;
        }
        *a1 = v31;
        goto LABEL_51;
      }
      int v29 = asn1_c2i_primitive((ASN1_VALUE **)a1, v38, a4, a8);
    }
    if (!v29) {
      goto LABEL_8;
    }
LABEL_51:
    unint64_t v33 = CBS_offset((uint64_t)a3);
    BOOL v20 = CBS_skip(a2, v33) != 0;
    goto LABEL_9;
  }
  int v17 = 156;
  int v18 = 469;
LABEL_7:
  ERR_put_error(13, 4095, v17, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", v18);
LABEL_8:
  BOOL v20 = 0;
LABEL_9:
  CBB_cleanup((uint64_t *)v34);
  freezero(v36, v35);
  return v20;
}

uint64_t asn1_collect(char **a1, uint64_t *a2, unsigned int a3, int a4)
{
  unsigned int v17 = a3;
  if (a4 <= 5)
  {
    int v16 = 0;
    unint64_t v15 = 0;
    memset(v14, 0, sizeof(v14));
    if (CBS_len((uint64_t)a2))
    {
      uint64_t v10 = (a4 + 1);
      while (!asn1_check_eoc((unsigned __int16 **)a2))
      {
        if (!asn1_check_tag(a2, &v15, 0, 0, &v17, &v16, -1, 0, 0))
        {
          int v4 = 58;
          int v5 = 206;
          goto LABEL_20;
        }
        if (v16)
        {
          uint64_t result = asn1_collect(a1, a2, v17, v10);
          if (!result) {
            return result;
          }
        }
        else
        {
          if (!CBS_get_bytes(a2, v14, v15))
          {
            int v4 = 58;
            int v5 = 218;
            goto LABEL_20;
          }
          uint64_t v12 = (const void *)CBS_data((uint64_t)v14);
          size_t v13 = CBS_len((uint64_t)v14);
          uint64_t result = CBB_add_bytes(a1, v12, v13);
          if (!result) {
            return result;
          }
        }
        if (!CBS_len((uint64_t)a2)) {
          goto LABEL_13;
        }
      }
      if (a3) {
        return 1;
      }
      int v4 = 159;
      int v5 = 199;
    }
    else
    {
LABEL_13:
      if (!a3) {
        return 1;
      }
      int v4 = 137;
      int v5 = 226;
    }
  }
  else
  {
    int v4 = 197;
    int v5 = 190;
  }
LABEL_20:
  ERR_put_error(13, 4095, v4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", v5);
  return 0;
}

uint64_t asn1_check_eoc(unsigned __int16 **a1)
{
  __int16 v4 = 0;
  int v2 = CBS_peek_u16(a1, &v4);
  uint64_t result = 0;
  if (v2)
  {
    if (!v4) {
      return CBS_skip(a1, 2uLL);
    }
  }
  return result;
}

uint64_t asn1_c2i_primitive(ASN1_VALUE **a1, void *a2, int a3, uint64_t a4)
{
  if (*(void *)(a4 + 32) || (unint64_t)CBS_len((uint64_t)a2) >> 31) {
    return 0;
  }
  switch(a3)
  {
    case 1:
      if (CBS_len((uint64_t)a2) != 1)
      {
        int v8 = 106;
        int v9 = 307;
        goto LABEL_33;
      }
      unsigned __int8 v14 = 0;
      uint64_t result = CBS_get_u8(a2, &v14);
      if (result)
      {
        *(_DWORD *)a1 = v14;
        goto LABEL_38;
      }
      return result;
    case 2:
      uint64_t result = c2i_ASN1_INTEGER_cbs(a1, a2);
      if (result) {
        goto LABEL_38;
      }
      return result;
    case 3:
      uint64_t result = c2i_ASN1_BIT_STRING_cbs(a1, a2);
      if (result) {
        goto LABEL_38;
      }
      return result;
    case 4:
    case 7:
    case 8:
    case 9:
      goto LABEL_11;
    case 5:
      if (CBS_len((uint64_t)a2))
      {
        int v8 = 144;
        int v9 = 298;
        goto LABEL_33;
      }
      *a1 = (ASN1_VALUE *)1;
      goto LABEL_38;
    case 6:
      uint64_t result = c2i_ASN1_OBJECT_cbs((ASN1_OBJECT **)a1, a2);
      if (!result) {
        return result;
      }
      goto LABEL_38;
    case 10:
      uint64_t result = c2i_ASN1_ENUMERATED_cbs((uint64_t)a1, a2);
      if (!result) {
        return result;
      }
      goto LABEL_38;
    default:
      if (a3 == 28)
      {
        if ((CBS_len((uint64_t)a2) & 3) != 0)
        {
          int v8 = 215;
          int v9 = 353;
          goto LABEL_33;
        }
      }
      else if (a3 == 30)
      {
        if (CBS_len((uint64_t)a2))
        {
          int v8 = 214;
          int v9 = 349;
LABEL_33:
          ERR_put_error(13, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", v9);
          return 0;
        }
      }
      else
      {
LABEL_11:
        if ((a3 - 23) <= 1 && !asn1_time_parse_cbs(a2, a3 == 24, 0))
        {
          int v8 = 132;
          int v9 = 359;
          goto LABEL_33;
        }
      }
      if (*a1)
      {
        ASN1_STRING_free((ASN1_STRING *)*a1);
        *a1 = 0;
      }
      uint64_t v10 = ASN1_STRING_type_new(a3);
      if (!v10)
      {
        int v8 = 65;
        int v9 = 369;
        goto LABEL_33;
      }
      uint64_t v11 = v10;
      uint64_t v12 = (const void *)CBS_data((uint64_t)a2);
      int v13 = CBS_len((uint64_t)a2);
      if (!ASN1_STRING_set(v11, v12, v13))
      {
        ASN1_STRING_free(v11);
        return 0;
      }
      *a1 = (ASN1_VALUE *)v11;
LABEL_38:
      uint64_t result = 1;
      break;
  }
  return result;
}

uint64_t asn1_template_noexp_d2i(ASN1_VALUE **pval, void *a2, uint64_t a3, int a4)
{
  if ((*(void *)a3 & 6) != 0)
  {
    memset(v27, 0, sizeof(v27));
    memset(v26, 0, sizeof(v26));
    data = 0;
    int v24 = 0;
    unint64_t v23 = 0;
    uint64_t v8 = CBS_data((uint64_t)a2);
    uint64_t v9 = CBS_len((uint64_t)a2);
    CBS_init(v27, v8, v9);
    asn1_template_stack_of_free((STACK *)*pval, a3);
    *pval = 0;
    uint64_t v10 = *(void *)a3;
    if ((*(void *)a3 & 2) != 0) {
      int v11 = 17;
    }
    else {
      int v11 = 16;
    }
    if ((v10 & 8) != 0) {
      int v12 = *(_DWORD *)(a3 + 8);
    }
    else {
      int v12 = v11;
    }
    if ((v10 & 8) != 0) {
      int v13 = *(_DWORD *)a3 & 0xC0;
    }
    else {
      int v13 = 0;
    }
    uint64_t result = asn1_check_tag(v27, &v23, 0, 0, &v24, 0, v12, v13, a4);
    if (result != -1)
    {
      if (result == 1)
      {
        int v15 = v24;
        if (v24)
        {
          uint64_t v16 = CBS_data((uint64_t)v27);
          uint64_t v17 = CBS_len((uint64_t)v27);
          CBS_init(v26, v16, v17);
        }
        else if (!CBS_get_bytes(v27, v26, v23))
        {
          int v18 = 0;
LABEL_40:
          asn1_template_stack_of_free(v18, a3);
          ASN1_item_ex_free((ASN1_VALUE **)&data, *(const ASN1_ITEM **)(a3 + 32));
          return 0;
        }
        int v18 = sk_new_null();
        if (v18)
        {
          while (1)
          {
            if (!CBS_len((uint64_t)v26))
            {
              if (v15)
              {
                int v19 = 137;
                int v20 = 1096;
                goto LABEL_39;
              }
              goto LABEL_32;
            }
            if (asn1_check_eoc(v26)) {
              break;
            }
            if (!asn1_item_d2i((ASN1_VALUE **)&data, (int)v26, *(ASN1_ITEM **)(a3 + 32)))
            {
              int v19 = 58;
              int v20 = 1086;
              goto LABEL_39;
            }
            if (!sk_push(v18, data))
            {
              int v19 = 65;
              int v20 = 1090;
              goto LABEL_39;
            }
            data = 0;
          }
          if (!v15)
          {
            int v19 = 159;
            int v20 = 1078;
            goto LABEL_39;
          }
LABEL_32:
          if (!v24 || (unint64_t v21 = CBS_offset((uint64_t)v26), CBS_skip(v27, v21)))
          {
            unint64_t v22 = CBS_offset((uint64_t)v27);
            if (CBS_skip(a2, v22))
            {
              *pval = (ASN1_VALUE *)v18;
              return 1;
            }
          }
        }
        else
        {
          int v19 = 65;
          int v20 = 1070;
LABEL_39:
          ERR_put_error(13, 4095, v19, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", v20);
        }
        goto LABEL_40;
      }
      ERR_put_error(13, 4095, 58, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", 1054);
      return 0;
    }
  }
  else
  {
    uint64_t result = asn1_item_d2i(pval, (int)a2, *(ASN1_ITEM **)(a3 + 32));
    if (result != -1 && result != 1)
    {
      ERR_put_error(13, 4095, 58, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_dec.c", 1147);
      ASN1_template_free(pval, (const ASN1_TEMPLATE *)a3);
      return 0;
    }
  }
  return result;
}

void asn1_template_stack_of_free(STACK *a1, uint64_t a2)
{
  if (a1)
  {
    pval = 0;
    if (sk_num(a1) >= 1)
    {
      do
      {
        pval = (ASN1_VALUE *)sk_pop(a1);
        ASN1_item_ex_free(&pval, *(const ASN1_ITEM **)(a2 + 32));
      }
      while (sk_num(a1) > 0);
    }
    sk_free(a1);
  }
}

int ASN1_mbstring_copy(ASN1_STRING **out, const unsigned __int8 *in, int len, int inform, unint64_t mask)
{
  return ASN1_mbstring_ncopy(out, in, len, inform, mask, 0, 0);
}

int ASN1_mbstring_ncopy(ASN1_STRING **out, const unsigned __int8 *in, int len, int inform, unint64_t mask, uint64_t minsize, uint64_t maxsize)
{
  int v11 = len;
  unint64_t v36 = mask;
  int v35 = 0;
  if (len < 0)
  {
    int v11 = strlen((const char *)in);
    if (mask) {
      goto LABEL_3;
    }
LABEL_7:
    unint64_t v36 = 10246;
    goto LABEL_3;
  }
  if (!mask) {
    goto LABEL_7;
  }
LABEL_3:
  unsigned int v34 = 0;
  switch(inform)
  {
    case 4096:
      int v33 = 0;
      if ((traverse_string((unsigned __int8 *)in, v11, 4096, (uint64_t (*)(unint64_t, uint64_t))in_utf8, (uint64_t)&v33) & 0x80000000) == 0)
      {
        int v14 = v33;
        goto LABEL_18;
      }
      int v15 = 134;
      int v16 = 135;
      goto LABEL_42;
    case 4097:
      int v33 = v11;
      int v14 = v11;
      goto LABEL_18;
    case 4098:
      if ((v11 & 1) == 0)
      {
        int v14 = v11 >> 1;
        goto LABEL_17;
      }
      int v15 = 129;
      int v16 = 116;
      goto LABEL_42;
    case 4100:
      if ((v11 & 3) != 0)
      {
        int v15 = 133;
        int v16 = 124;
LABEL_42:
        ERR_put_error(13, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_mbstr.c", v16);
        return -1;
      }
      int v14 = v11 >> 2;
LABEL_17:
      int v33 = v14;
LABEL_18:
      if (minsize >= 1 && v14 < minsize)
      {
        ERR_put_error(13, 4095, 152, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_mbstr.c", 150);
        ERR_asprintf_error_data("minsize=%ld");
        return -1;
      }
      if (maxsize >= 1 && v14 > maxsize)
      {
        ERR_put_error(13, 4095, 151, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_mbstr.c", 156);
        ERR_asprintf_error_data("maxsize=%ld");
        return -1;
      }
      if ((traverse_string((unsigned __int8 *)in, v11, inform, (uint64_t (*)(unint64_t, uint64_t))type_str, (uint64_t)&v36) & 0x80000000) != 0)
      {
        int v15 = 124;
        int v16 = 163;
        goto LABEL_42;
      }
      if ((v36 & 2) != 0)
      {
        int v20 = 4097;
        int v19 = 19;
      }
      else if ((v36 & 0x10) != 0)
      {
        int v20 = 4097;
        int v19 = 22;
      }
      else if ((v36 & 4) != 0)
      {
        int v20 = 4097;
        int v19 = 20;
      }
      else
      {
        if ((v36 & 0x100) != 0) {
          int v17 = 28;
        }
        else {
          int v17 = 12;
        }
        if ((v36 & 0x100) != 0) {
          int v18 = 4100;
        }
        else {
          int v18 = 4096;
        }
        if ((v36 & 0x800) != 0) {
          int v19 = 30;
        }
        else {
          int v19 = v17;
        }
        if ((v36 & 0x800) != 0) {
          int v20 = 4098;
        }
        else {
          int v20 = v18;
        }
      }
      if (!out) {
        return v19;
      }
      unint64_t v22 = *out;
      if (*out)
      {
        data = v22->data;
        if (data)
        {
          v22->length = 0;
          free(data);
          v22->data = 0;
        }
        v22->type = v19;
        int v24 = v22;
      }
      else
      {
        uint64_t v25 = ASN1_STRING_type_new(v19);
        if (!v25)
        {
          int v15 = 65;
          int v16 = 201;
          goto LABEL_42;
        }
        int v24 = v25;
        *out = v25;
      }
      if (v20 == inform)
      {
        if (!ASN1_STRING_set(v24, in, v11))
        {
          int v26 = 65;
          int v27 = 209;
          goto LABEL_69;
        }
      }
      else
      {
        uint64_t v28 = 0;
        int v29 = 0;
        switch(v20)
        {
          case 4096:
            int v35 = 0;
            if ((traverse_string((unsigned __int8 *)in, v11, inform, (uint64_t (*)(unint64_t, uint64_t))out_utf8, (uint64_t)&v35) & 0x80000000) == 0)
            {
              uint64_t v28 = (uint64_t (*)(unint64_t, uint64_t))cpy_utf8;
              int v29 = v35;
              break;
            }
            int v26 = 124;
            int v27 = 235;
            goto LABEL_69;
          case 4097:
            int v29 = v33;
            int v35 = v33;
            uint64_t v30 = (uint64_t (*)(unint64_t, uint64_t))cpy_asc;
            goto LABEL_65;
          case 4098:
            int v29 = 2 * v33;
            int v35 = 2 * v33;
            uint64_t v30 = (uint64_t (*)(unint64_t, uint64_t))cpy_bmp;
            goto LABEL_65;
          case 4100:
            int v29 = 4 * v33;
            int v35 = 4 * v33;
            uint64_t v30 = (uint64_t (*)(unint64_t, uint64_t))cpy_univ;
LABEL_65:
            uint64_t v28 = v30;
            break;
          default:
            break;
        }
        int v31 = (unsigned __int8 *)malloc_type_malloc(v29 + 1, 0xD4CC7B26uLL);
        unsigned int v34 = v31;
        if (!v31)
        {
          int v26 = 65;
          int v27 = 242;
LABEL_69:
          ERR_put_error(13, 4095, v26, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_mbstr.c", v27);
          if (!v22)
          {
            ASN1_STRING_free(v24);
            *out = 0;
          }
          return -1;
        }
        uint64_t v32 = v35;
        v24->length = v35;
        v24->data = v31;
        v31[v32] = 0;
        traverse_string((unsigned __int8 *)in, v11, inform, v28, (uint64_t)&v34);
      }
      return v19;
    default:
      int v15 = 160;
      int v16 = 145;
      goto LABEL_42;
  }
}

uint64_t traverse_string(unsigned __int8 *str, int len, int a3, uint64_t (*a4)(unint64_t, uint64_t), uint64_t a5)
{
  if (!len) {
    return 1;
  }
  int v8 = len;
  unint64_t val = 0;
  while (a3 != 4100)
  {
    if (a3 == 4098)
    {
      uint64_t v15 = *str;
      unint64_t val = v15 << 8;
      unint64_t val = str[1] | ((unint64_t)v15 << 8);
      if ((v15 & 0xF8) == 0xD8) {
        return 0xFFFFFFFFLL;
      }
      str += 2;
      v8 -= 2;
      if (a4) {
        goto LABEL_19;
      }
    }
    else if (a3 == 4097)
    {
      unsigned int v10 = *str++;
      unint64_t val = v10;
      --v8;
      if (a4) {
        goto LABEL_19;
      }
    }
    else
    {
      unsigned int v16 = UTF8_getc(str, v8, &val);
      if ((v16 & 0x80000000) != 0) {
        return 0xFFFFFFFFLL;
      }
      v8 -= v16;
      str += v16;
      if (a4)
      {
LABEL_19:
        uint64_t result = a4(val, a5);
        if ((int)result < 1) {
          return result;
        }
      }
    }
LABEL_20:
    if (!v8) {
      return 1;
    }
  }
  unint64_t val = (unint64_t)*str << 24;
  unint64_t v11 = val | ((unint64_t)str[1] << 16);
  unint64_t val = v11;
  unint64_t v12 = v11 | ((unint64_t)str[2] << 8);
  unint64_t val = v12;
  unint64_t val = v12 | str[3];
  uint64_t v13 = v12 & 0xFFFFF800;
  if (v11 >> 16 <= 0x10 && v13 != 55296)
  {
    str += 4;
    v8 -= 4;
    if (a4) {
      goto LABEL_19;
    }
    goto LABEL_20;
  }
  return 0xFFFFFFFFLL;
}

uint64_t in_utf8(uint64_t a1, _DWORD *a2)
{
  return 1;
}

uint64_t type_str(unint64_t __c, unint64_t *a2)
{
  unint64_t v4 = *a2;
  if ((*a2 & 2) != 0
    && (__c > 0x7F
     || __c != 32
     && (__c - 48) >= 0xA
     && (__c & 0xFFFFFFDF) - 65 >= 0x1A
     && !memchr("'()+,-./:=?", __c, 0xCuLL)))
  {
    v4 &= ~2uLL;
  }
  if (__c > 0x7F && (v4 & 0x10) != 0) {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFEFLL;
  }
  else {
    unint64_t v5 = v4;
  }
  if (__c > 0xFF && (v5 & 4) != 0) {
    v5 &= ~4uLL;
  }
  if ((__c & 0xFFFFFFFFFFFF0000) != 0 && (v5 & 0x800) != 0) {
    v5 &= ~0x800uLL;
  }
  if (!v5) {
    return 0xFFFFFFFFLL;
  }
  *a2 = v5;
  return 1;
}

uint64_t cpy_asc(char a1, void *a2)
{
  *(unsigned char *)(*a2)++ = a1;
  return 1;
}

uint64_t cpy_bmp(unsigned int a1, _WORD **a2)
{
  *(*a2)++ = bswap32(a1) >> 16;
  return 1;
}

uint64_t cpy_univ(unsigned int a1, _DWORD **a2)
{
  *(*a2)++ = bswap32(a1);
  return 1;
}

uint64_t out_utf8(unint64_t value, _DWORD *a2)
{
  uint64_t result = UTF8_putc(0, -1, value);
  if ((result & 0x80000000) == 0)
  {
    *a2 += result;
    return 1;
  }
  return result;
}

uint64_t cpy_utf8(unint64_t value, unsigned __int8 **a2)
{
  *a2 += UTF8_putc(*a2, 255, value);
  return 1;
}

LHASH *__cdecl lh_new(LHASH_HASH_FN_TYPE h, LHASH_COMP_FN_TYPE c)
{
  unint64_t v4 = (LHASH *)malloc_type_calloc(1uLL, 0xB0uLL, 0x1080040A9E2475DuLL);
  if (v4)
  {
    unint64_t v5 = (LHASH_NODE **)malloc_type_calloc(0x10uLL, 8uLL, 0x2004093837F09uLL);
    v4->b = v5;
    if (v5)
    {
      if (c) {
        LHASH_COMP_FN_TYPE v6 = c;
      }
      else {
        LHASH_COMP_FN_TYPE v6 = (LHASH_COMP_FN_TYPE)MEMORY[0x263EF8A90];
      }
      if (h) {
        uint64_t v7 = h;
      }
      else {
        uint64_t v7 = (unint64_t (__cdecl *)(const void *))lh_strhash;
      }
      v4->comp = v6;
      v4->hash = v7;
      *(void *)&v4->num_nodes = 0x1000000008;
      v4->pmax = 8;
      *(_OWORD *)&v4->up_load = xmmword_23C709AB0;
    }
    else
    {
      free(v4);
      return 0;
    }
  }
  return v4;
}

unint64_t lh_strhash(unint64_t c)
{
  if (c)
  {
    char v1 = *(unsigned char *)c;
    if (*(unsigned char *)c)
    {
      unint64_t v2 = 0;
      uint64_t v3 = (unsigned __int8 *)(c + 1);
      uint64_t v4 = 256;
      do
      {
        unint64_t v5 = v1 ^ ((unint64_t)v1 >> 2);
        if ((v5 & 0xF) != 0) {
          unint64_t v2 = (v2 >> (32 - (v5 & 0xFu))) | (v2 << (v5 & 0xF));
        }
        unint64_t v2 = v2 ^ ((v4 | v1) * (v4 | v1));
        int v6 = *v3++;
        char v1 = v6;
        v4 += 256;
      }
      while (v6);
      return v2 ^ (v2 >> 16);
    }
    else
    {
      return 0;
    }
  }
  return c;
}

void lh_free(LHASH *lh)
{
  if (lh)
  {
    unint64_t num_nodes = lh->num_nodes;
    if (num_nodes)
    {
      for (unint64_t i = 0; i < num_nodes; ++i)
      {
        uint64_t v4 = lh->b[i];
        if (v4)
        {
          do
          {
            next = v4->next;
            free(v4);
            uint64_t v4 = next;
          }
          while (next);
          unint64_t num_nodes = lh->num_nodes;
        }
      }
    }
    free(lh->b);
    free(lh);
  }
}

void *__cdecl lh_insert(LHASH *lh, void *data)
{
  unint64_t v21 = 0;
  lh->error = 0;
  unint64_t num_nodes = lh->num_nodes;
  if (lh->up_load <= (lh->num_items << 8) / num_nodes)
  {
    lh->unint64_t num_nodes = num_nodes + 1;
    ++lh->num_expands;
    unint64_t num_alloc_nodes = lh->num_alloc_nodes;
    uint64_t p = lh->p;
    lh->uint64_t p = p + 1;
    b = lh->b;
    p_next = &lh->b[p];
    unsigned int pmax = lh->pmax;
    uint64_t v10 = pmax + p;
    lh->b[v10] = 0;
    while (1)
    {
      unint64_t v11 = *p_next;
      if (!*p_next) {
        break;
      }
      if (v11->hash % num_alloc_nodes == p)
      {
        p_next = &v11->next;
      }
      else
      {
        *p_next = v11->next;
        v11->next = b[v10];
        b[v10] = v11;
      }
    }
    if ((int)p + 1 >= pmax)
    {
      unsigned int v12 = 2 * num_alloc_nodes;
      uint64_t v13 = (LHASH_NODE **)reallocarray(lh->b, (2 * num_alloc_nodes), 8uLL);
      if (v13)
      {
        int v14 = v13;
        uint64_t v15 = lh->num_alloc_nodes;
        if (v15 < v12) {
          bzero(&v13[v15], 8 * (v12 + ~v15) + 8);
        }
        lh->uint64_t p = 0;
        lh->unsigned int pmax = v15;
        ++lh->num_expand_reallocs;
        lh->unint64_t num_alloc_nodes = v12;
        lh->b = v14;
      }
      else
      {
        ++lh->error;
        lh->uint64_t p = 0;
      }
    }
  }
  unsigned int v16 = (void ***)getrn((uint64_t)lh, (uint64_t)data, (unint64_t *)&v21);
  int v17 = *v16;
  if (*v16)
  {
    uint64_t result = *v17;
    char *v17 = data;
    ++lh->num_replace;
  }
  else
  {
    int v19 = v16;
    uint64_t result = malloc_type_malloc(0x18uLL, 0x10A0040AFD1EA57uLL);
    if (result)
    {
      int v20 = (void **)result;
      uint64_t result = 0;
      ENGINE *v20 = data;
      v20[1] = 0;
      v20[2] = v21;
      const char *v19 = v20;
      ++lh->num_insert;
      ++lh->num_items;
    }
    else
    {
      ++lh->error;
    }
  }
  return result;
}

void *getrn(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v6 = (*(uint64_t (**)(uint64_t))(a1 + 16))(a2);
  unint64_t v7 = v6;
  ++*(void *)(a1 + 96);
  *a3 = v6;
  unint64_t v8 = v6 % *(unsigned int *)(a1 + 36);
  if (v8 < *(unsigned int *)(a1 + 32)) {
    unint64_t v8 = v6 % *(unsigned int *)(a1 + 28);
  }
  uint64_t v9 = (void *)(*(void *)a1 + 8 * (int)v8);
  uint64_t v10 = (void *)*v9;
  if (*v9)
  {
    unint64_t v11 = *(unsigned int (**)(void, uint64_t))(a1 + 8);
    do
    {
      ++*(void *)(a1 + 160);
      if (v10[2] == v7)
      {
        ++*(void *)(a1 + 104);
        if (!v11(*v10, a2)) {
          break;
        }
      }
      uint64_t v9 = v10 + 1;
      uint64_t v10 = (void *)v10[1];
    }
    while (v10);
  }
  return v9;
}

void *__cdecl lh_delete(LHASH *lh, const void *data)
{
  lh->error = 0;
  uint64_t v3 = (void **)getrn((uint64_t)lh, (uint64_t)data, &v19);
  uint64_t v4 = *v3;
  if (*v3)
  {
    unsigned __int8 *v3 = (void *)*((void *)v4 + 1);
    unint64_t v5 = *(void **)v4;
    free(v4);
    ++lh->num_delete;
    unint64_t v6 = lh->num_items - 1;
    lh->num_items = v6;
    unint64_t num_nodes = lh->num_nodes;
    if (num_nodes >= 0x11 && lh->down_load >= (v6 << 8) / num_nodes)
    {
      unsigned int p = lh->p;
      unint64_t pmax = lh->pmax;
      signed int v10 = p - 1;
      int v11 = p - 1 + pmax;
      unsigned int v12 = lh->b[v11];
      lh->b[v11] = 0;
      if (p)
      {
        lh->unsigned int p = v10;
        b = lh->b;
      }
      else
      {
        b = (LHASH_NODE **)reallocarray(lh->b, pmax, 8uLL);
        if (!b)
        {
          ++lh->error;
          return v5;
        }
        ++lh->num_contract_reallocs;
        LODWORD(num_nodes) = lh->num_nodes;
        unsigned int v15 = lh->num_alloc_nodes >> 1;
        unsigned int v16 = lh->pmax >> 1;
        lh->unint64_t pmax = v16;
        signed int v10 = v16 - 1;
        lh->unint64_t num_alloc_nodes = v15;
        lh->unsigned int p = v10;
        lh->b = b;
      }
      lh->unint64_t num_nodes = num_nodes - 1;
      ++lh->num_contracts;
      int v17 = b[v10];
      if (v17)
      {
        do
        {
          int v18 = v17;
          int v17 = v17->next;
        }
        while (v17);
        v18->next = v12;
      }
      else
      {
        b[v10] = v12;
      }
    }
  }
  else
  {
    unint64_t v5 = 0;
    ++lh->num_no_delete;
  }
  return v5;
}

void *__cdecl lh_retrieve(LHASH *lh, const void *data)
{
  lh->error = 0;
  uint64_t v3 = (void ***)getrn((uint64_t)lh, (uint64_t)data, &v6);
  if (*v3)
  {
    uint64_t result = **v3;
    p_num_retrieve = &lh->num_retrieve;
  }
  else
  {
    uint64_t result = 0;
    p_num_retrieve = &lh->num_retrieve_miss;
  }
  ++*p_num_retrieve;
  return result;
}

void lh_doall(LHASH *lh, LHASH_DOALL_FN_TYPE func)
{
  if (lh)
  {
    unsigned int num_nodes = lh->num_nodes;
    uint64_t v4 = num_nodes - 1;
    if ((int)(num_nodes - 1) >= 0)
    {
      do
      {
        unint64_t v6 = lh->b[v4];
        if (v6)
        {
          do
          {
            next = v6->next;
            ((void (*)(void *))func)(v6->data);
            unint64_t v6 = next;
          }
          while (next);
        }
      }
      while (v4-- >= 1);
    }
  }
}

void lh_doall_arg(LHASH *lh, LHASH_DOALL_ARG_FN_TYPE func, void *arg)
{
  if (lh)
  {
    unsigned int num_nodes = lh->num_nodes;
    uint64_t v5 = num_nodes - 1;
    if ((int)(num_nodes - 1) >= 0)
    {
      do
      {
        unint64_t v8 = lh->b[v5];
        if (v8)
        {
          do
          {
            next = v8->next;
            ((void (*)(void *, void *))func)(v8->data, arg);
            unint64_t v8 = next;
          }
          while (next);
        }
      }
      while (v5-- >= 1);
    }
  }
}

unint64_t lh_num_items(unint64_t lh)
{
  if (lh) {
    return *(void *)(lh + 56);
  }
  return lh;
}

void ENGINE_unregister_EC(void *a1)
{
}

uint64_t ENGINE_register_EC(uint64_t a1)
{
  if (*(void *)(a1 + 56)) {
    return engine_table_register(&ec_table, (uint64_t)engine_unregister_all_EC, (char *)a1, dummy_nid_1, 1, 0);
  }
  else {
    return 1;
  }
}

void engine_unregister_all_EC()
{
}

ENGINE *ENGINE_register_all_EC()
{
  uint64_t result = ENGINE_get_first();
  if (result)
  {
    char v1 = result;
    do
    {
      if (*((void *)v1 + 7)) {
        engine_table_register(&ec_table, (uint64_t)engine_unregister_all_EC, (char *)v1, dummy_nid_1, 1, 0);
      }
      uint64_t result = ENGINE_get_next(v1);
      char v1 = result;
    }
    while (result);
  }
  return result;
}

uint64_t ENGINE_set_default_EC(uint64_t a1)
{
  if (*(void *)(a1 + 56)) {
    return engine_table_register(&ec_table, (uint64_t)engine_unregister_all_EC, (char *)a1, dummy_nid_1, 1, 1);
  }
  else {
    return 1;
  }
}

uint64_t ENGINE_get_default_EC()
{
  return engine_table_select(&ec_table, 1);
}

uint64_t ENGINE_get_EC(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t ENGINE_set_EC(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 56) = a2;
  return 1;
}

void EVP_set_pw_prompt(const char *prompt)
{
  if (prompt) {
    __strlcpy_chk();
  }
  else {
    prompt_string = 0;
  }
}

char *EVP_get_pw_prompt(void)
{
  if (prompt_string) {
    return &prompt_string;
  }
  else {
    return 0;
  }
}

int EVP_read_pw_string(char *buf, int length, const char *prompt, int verify)
{
  return EVP_read_pw_string_min(buf, 0, length, prompt, verify);
}

uint64_t EVP_read_pw_string_min(char *a1, int a2, int a3, const char *a4, int a5)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  if ((a2 & 0x80000000) == 0)
  {
    int v6 = a3 >= 1024 ? 1024 : a3;
    if (v6 > a2)
    {
      if (prompt_string) {
        BOOL v9 = a4 == 0;
      }
      else {
        BOOL v9 = 0;
      }
      if (v9) {
        signed int v10 = &prompt_string;
      }
      else {
        signed int v10 = a4;
      }
      int v11 = UI_new();
      if (v11)
      {
        unsigned int v12 = v11;
        int v13 = v6 - 1;
        if ((UI_add_input_string(v11, v10, 0, a1, a2, v13) & 0x80000000) == 0
          && (!a5 || (UI_add_verify_string(v12, v10, 0, result_buf, a2, v13, a1) & 0x80000000) == 0))
        {
          UI_process(v12);
          UI_free(v12);
          explicit_bzero(result_buf, 0x400uLL);
        }
      }
    }
  }
  return 0xFFFFFFFFLL;
}

int EVP_BytesToKey(const EVP_CIPHER *type, const EVP_MD *md, const unsigned __int8 *salt, const unsigned __int8 *data, int datal, int count, unsigned __int8 *key, unsigned __int8 *iv)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  cnt[0] = 0;
  uint64_t key_len = type->key_len;
  if (key_len >= 0x41)
  {
    int v9 = 137;
    int v10 = 144;
LABEL_5:
    ERR_put_error(6, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_key.c", v10);
    LODWORD(key_len) = 0;
    return key_len;
  }
  unsigned int iv_len = type->iv_len;
  if (iv_len >= 0x11)
  {
    int v9 = 102;
    int v10 = 148;
    goto LABEL_5;
  }
  int v13 = data;
  if (data)
  {
    uint64_t v16 = *(void *)&count;
    long long v32 = 0u;
    memset(&cnt[1], 0, 32);
    EVP_MD_CTX_init((EVP_MD_CTX *)&cnt[1]);
    size_t v30 = datal;
    int v20 = 0;
    int v29 = v16 - 1;
    uint64_t v28 = v13;
    while (1)
    {
      if (!EVP_DigestInit_ex((EVP_MD_CTX *)&cnt[1], md, 0)
        || v20 && !EVP_DigestUpdate((EVP_MD_CTX *)&cnt[1], d, cnt[0])
        || !EVP_DigestUpdate((EVP_MD_CTX *)&cnt[1], v13, v30)
        || salt && !EVP_DigestUpdate((EVP_MD_CTX *)&cnt[1], salt, 8uLL)
        || !EVP_DigestFinal_ex((EVP_MD_CTX *)&cnt[1], d, cnt))
      {
        goto LABEL_39;
      }
      unint64_t v21 = salt;
      uint64_t v22 = v16;
      int v23 = v20;
      int v24 = v29;
      uint64_t v25 = v22;
      if (v22 >= 2) {
        break;
      }
LABEL_21:
      int v26 = v23;
      if (!key_len)
      {
        LODWORD(v27) = 0;
        uint64_t v16 = v25;
        salt = v21;
        int v13 = v28;
        if (!iv_len) {
          goto LABEL_37;
        }
        goto LABEL_32;
      }
      uint64_t v27 = 0;
      uint64_t v16 = v25;
      salt = v21;
      int v13 = v28;
      do
      {
        if (v27 == cnt[0])
        {
          uint64_t key_len = (key_len - v27);
          if (iv_len) {
            goto LABEL_32;
          }
          goto LABEL_37;
        }
        if (key) {
          *key++ = d[v27];
        }
        ++v27;
      }
      while (key_len != v27);
      LODWORD(v27) = key_len;
      uint64_t key_len = 0;
      if (!iv_len) {
        goto LABEL_37;
      }
LABEL_32:
      if (v27 != cnt[0])
      {
        do
        {
          if (v27 == cnt[0]) {
            break;
          }
          if (iv) {
            *iv++ = d[v27];
          }
          LODWORD(v27) = v27 + 1;
          --iv_len;
        }
        while (iv_len);
      }
LABEL_37:
      int v20 = v26 + 1;
      if (!key_len && !iv_len) {
        goto LABEL_39;
      }
    }
    while (EVP_DigestInit_ex((EVP_MD_CTX *)&cnt[1], md, 0)
         && EVP_DigestUpdate((EVP_MD_CTX *)&cnt[1], d, cnt[0])
         && EVP_DigestFinal_ex((EVP_MD_CTX *)&cnt[1], d, cnt))
    {
      if (!--v24) {
        goto LABEL_21;
      }
    }
LABEL_39:
    EVP_MD_CTX_cleanup((EVP_MD_CTX *)&cnt[1]);
    explicit_bzero(d, 0x40uLL);
  }
  return key_len;
}

uint64_t EVP_PKEY_paramgen_init(uint64_t *a1)
{
  if (a1 && (uint64_t v2 = *a1) != 0 && *(void *)(v2 + 40))
  {
    *((_DWORD *)a1 + 8) = 2;
    uint64_t v3 = *(uint64_t (**)(uint64_t *))(v2 + 32);
    if (v3)
    {
      uint64_t result = v3(a1);
      if ((int)result <= 0) {
        *((_DWORD *)a1 + 8) = 0;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_gn.c", 77);
    return 4294967294;
  }
  return result;
}

uint64_t EVP_PKEY_paramgen(_DWORD *a1, EVP_PKEY **a2)
{
  if (!a1 || !*(void *)a1 || (uint64_t v3 = *(uint64_t (**)(_DWORD *))(*(void *)a1 + 40)) == 0)
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_gn.c", 95);
    return 4294967294;
  }
  if (a1[8] != 2)
  {
    ERR_put_error(6, 4095, 151, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_gn.c", 100);
    return 0xFFFFFFFFLL;
  }
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  if (!*a2)
  {
    *a2 = EVP_PKEY_new();
    uint64_t v3 = *(uint64_t (**)(_DWORD *))(*(void *)a1 + 40);
  }
  uint64_t v5 = v3(a1);
  if ((int)v5 <= 0)
  {
    EVP_PKEY_free(*a2);
    *a2 = 0;
  }
  return v5;
}

uint64_t EVP_PKEY_keygen_init(uint64_t *a1)
{
  if (a1 && (uint64_t v2 = *a1) != 0 && *(void *)(v2 + 56))
  {
    *((_DWORD *)a1 + 8) = 4;
    uint64_t v3 = *(uint64_t (**)(uint64_t *))(v2 + 48);
    if (v3)
    {
      uint64_t result = v3(a1);
      if ((int)result <= 0) {
        *((_DWORD *)a1 + 8) = 0;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_gn.c", 124);
    return 4294967294;
  }
  return result;
}

uint64_t EVP_PKEY_keygen(_DWORD *a1, EVP_PKEY **a2)
{
  if (!a1 || !*(void *)a1 || (uint64_t v3 = *(uint64_t (**)(_DWORD *))(*(void *)a1 + 56)) == 0)
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_gn.c", 142);
    return 4294967294;
  }
  if (a1[8] != 4)
  {
    ERR_put_error(6, 4095, 151, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_gn.c", 146);
    return 0xFFFFFFFFLL;
  }
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  if (!*a2)
  {
    *a2 = EVP_PKEY_new();
    uint64_t v3 = *(uint64_t (**)(_DWORD *))(*(void *)a1 + 56);
  }
  uint64_t v5 = v3(a1);
  if ((int)v5 <= 0)
  {
    EVP_PKEY_free(*a2);
    *a2 = 0;
  }
  return v5;
}

uint64_t EVP_PKEY_CTX_set_cb(uint64_t result, uint64_t a2)
{
  *(void *)(result + 56) = a2;
  return result;
}

uint64_t EVP_PKEY_CTX_get_cb(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t evp_pkey_set_cb_translate(uint64_t a1, uint64_t a2)
{
  return BN_GENCB_set(a1, (uint64_t)trans_cb, a2);
}

uint64_t trans_cb(int a1, int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  uint64_t v4 = *(uint64_t (**)(uint64_t))(v3 + 56);
  uint64_t v5 = *(_DWORD **)(v3 + 64);
  _DWORD *v5 = a1;
  v5[1] = a2;
  return v4(v3);
}

uint64_t EVP_PKEY_CTX_get_keygen_info(uint64_t a1, unsigned int a2)
{
  if (a2 == -1) {
    return *(unsigned int *)(a1 + 72);
  }
  if ((a2 & 0x80000000) != 0 || *(_DWORD *)(a1 + 72) < (signed int)a2) {
    return 0;
  }
  return *(unsigned int *)(*(void *)(a1 + 64) + 4 * a2);
}

uint64_t *EVP_PKEY_new_mac_key(int a1, ENGINE *a2)
{
  uint64_t v4 = 0;
  uint64_t result = (uint64_t *)EVP_PKEY_CTX_new_id(a1, a2);
  if (result)
  {
    uint64_t v3 = result;
    if ((int)EVP_PKEY_keygen_init(result) >= 1 && (int)EVP_PKEY_CTX_ctrl(v3, -1, 4) >= 1) {
      EVP_PKEY_keygen(v3, &v4);
    }
    EVP_PKEY_CTX_free((EVP_PKEY **)v3);
    return (uint64_t *)v4;
  }
  return result;
}

uint64_t EVP_PKEY_check(void *a1)
{
  uint64_t v2 = a1[2];
  if (v2)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*a1 + 224);
    if (v3 || (v5 = *(void *)(v2 + 16)) != 0 && (uint64_t v3 = *(uint64_t (**)(void))(v5 + 216)) != 0)
    {
      return v3();
    }
    else
    {
      ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_gn.c", 241);
      return 4294967294;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 154, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_gn.c", 233);
    return 0;
  }
}

uint64_t EVP_PKEY_public_check(void *a1)
{
  uint64_t v2 = a1[2];
  if (v2)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*a1 + 232);
    if (v3 || (v5 = *(void *)(v2 + 16)) != 0 && (uint64_t v3 = *(uint64_t (**)(void))(v5 + 224)) != 0)
    {
      return v3();
    }
    else
    {
      ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_gn.c", 262);
      return 4294967294;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 154, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_gn.c", 254);
    return 0;
  }
}

uint64_t EVP_PKEY_param_check(void *a1)
{
  uint64_t v2 = a1[2];
  if (v2)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*a1 + 240);
    if (v3 || (v5 = *(void *)(v2 + 16)) != 0 && (uint64_t v3 = *(uint64_t (**)(void))(v5 + 232)) != 0)
    {
      return v3();
    }
    else
    {
      ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_gn.c", 283);
      return 4294967294;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 154, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_gn.c", 275);
    return 0;
  }
}

void RC2_ecb_encrypt(const unsigned __int8 *in, unsigned __int8 *out, RC2_KEY *key, int enc)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  *(void *)&long long v5 = *(void *)in;
  *((void *)&v5 + 1) = HIDWORD(*(void *)in);
  long long v7 = v5;
  if (enc) {
    RC2_encrypt((unint64_t *)&v7, key);
  }
  else {
    RC2_decrypt((unint64_t *)&v7, key);
  }
  int v6 = DWORD2(v7);
  *(_DWORD *)out = v7;
  *((_DWORD *)out + 1) = v6;
}

unint64_t *bn_mul_comba4(unint64_t *result, void *a2, void *a3)
{
  uint64_t v3 = HIDWORD(*a2);
  unint64_t v4 = *a3 * (unint64_t)*a2;
  unint64_t v5 = *a3 * (unint64_t)v3;
  unint64_t v6 = v4 | (v5 << 32);
  uint64_t v7 = HIDWORD(*a3);
  unint64_t v8 = HIDWORD(v5);
  unint64_t v9 = v4 & (v5 << 32);
  unint64_t v10 = (v5 << 32) + *a3 * (unint64_t)*a2;
  unint64_t v11 = v7 * (unint64_t)*a2;
  unint64_t v12 = v10 | (v11 << 32);
  unint64_t v13 = v8 + v7 * (unint64_t)v3;
  unint64_t v14 = v6 & ~v10;
  unint64_t v15 = v10 & (v11 << 32);
  unint64_t v16 = v10 + (v11 << 32);
  unint64_t v17 = v13 + HIDWORD(v11) + ((v14 | v9) >> 63) + ((v12 & ~v16 | v15) >> 63);
  *uint64_t result = v16;
  unint64_t v18 = a2[1];
  uint64_t v19 = HIDWORD(*a2);
  LODWORD(v9) = *a2;
  unint64_t v20 = a3[1];
  unint64_t v21 = HIDWORD(v20);
  unsigned int v22 = v20;
  unint64_t v23 = v20 * (unint64_t)v9;
  unint64_t v24 = v20 * (unint64_t)v19;
  unint64_t v25 = HIDWORD(v24) + v21 * (unint64_t)v19;
  unint64_t v26 = v23 | (v24 << 32);
  unint64_t v27 = v23 & (v24 << 32);
  unint64_t v28 = (v24 << 32) + v22 * (unint64_t)v9;
  unint64_t v29 = v26 & ~v28 | v27;
  unint64_t v30 = v21 * (unint64_t)v9;
  unint64_t v31 = v28 | (v30 << 32);
  unint64_t v32 = v28 & (v30 << 32);
  unint64_t v33 = v28 + (v30 << 32);
  unint64_t v34 = v25 + HIDWORD(v30) + (v29 >> 63) + ((v31 & ~v33 | v32) >> 63);
  unint64_t v35 = v17 | v33;
  unint64_t v36 = v17 & v33;
  unint64_t v37 = v17 + v33;
  unint64_t v38 = v34 + ((v35 & ~v37 | v36) >> 63);
  unint64_t v39 = HIDWORD(v18);
  LODWORD(v36) = v18;
  uint64_t v40 = HIDWORD(*a3);
  LODWORD(v31) = *a3;
  unint64_t v41 = v31 * (unint64_t)v18;
  unint64_t v42 = v31 * (unint64_t)v39;
  unint64_t v43 = HIDWORD(v42) + v40 * (unint64_t)v39;
  unint64_t v44 = v41 | (v42 << 32);
  unint64_t v45 = v41 & (v42 << 32);
  unint64_t v46 = (v42 << 32) + v31 * (unint64_t)v36;
  unint64_t v47 = v44 & ~v46 | v45;
  unint64_t v48 = v40 * (unint64_t)v36;
  unint64_t v49 = v46 | (v48 << 32);
  unint64_t v50 = v46 & (v48 << 32);
  unint64_t v51 = v46 + (v48 << 32);
  unint64_t v52 = v43 + HIDWORD(v48) + (v47 >> 63) + ((v49 & ~v51 | v50) >> 63);
  unint64_t v53 = v51 | v37;
  unint64_t v54 = v51 & v37;
  unint64_t v55 = v51 + v37;
  unint64_t v56 = v52 + ((v53 & ~v55 | v54) >> 63);
  unint64_t v57 = v56 | v38;
  unint64_t v58 = v56 & v38;
  unint64_t v59 = v56 + v38;
  unint64_t v60 = v57 & ~v59 | v58;
  result[1] = v55;
  unint64_t v61 = a2[2];
  unint64_t v62 = HIDWORD(v61);
  LODWORD(v58) = v61;
  unint64_t v63 = a3[1];
  uint64_t v64 = HIDWORD(*a3);
  LODWORD(v32) = *a3;
  unint64_t v65 = v32 * (unint64_t)v61;
  unint64_t v66 = v32 * (unint64_t)v62;
  unint64_t v67 = HIDWORD(v66) + v64 * (unint64_t)v62;
  unint64_t v68 = v65 | (v66 << 32);
  unint64_t v69 = v65 & (v66 << 32);
  unint64_t v70 = (v66 << 32) + v32 * (unint64_t)v58;
  unint64_t v71 = v68 & ~v70 | v69;
  unint64_t v72 = v64 * (unint64_t)v58;
  unint64_t v73 = v70 | (v72 << 32);
  unint64_t v74 = v70 & (v72 << 32);
  unint64_t v75 = v70 + (v72 << 32);
  unint64_t v76 = v67 + HIDWORD(v72) + (v71 >> 63) + ((v73 & ~v75 | v74) >> 63);
  unint64_t v77 = v59 | v75;
  unint64_t v78 = v59 & v75;
  unint64_t v79 = v59 + v75;
  unint64_t v80 = v76 + ((v77 & ~v79 | v78) >> 63);
  unint64_t v81 = v80 + (v60 >> 63);
  unint64_t v82 = v80 & ~v81;
  unint64_t v83 = a2[1];
  unint64_t v84 = HIDWORD(v83);
  LODWORD(v73) = v83;
  unint64_t v85 = HIDWORD(v63);
  LODWORD(v44) = v63;
  unint64_t v86 = v63 * (unint64_t)v83;
  unint64_t v87 = v63 * (unint64_t)v84;
  unint64_t v88 = HIDWORD(v87) + v85 * (unint64_t)v84;
  unint64_t v89 = v86 | (v87 << 32);
  unint64_t v90 = v86 & (v87 << 32);
  unint64_t v91 = (v87 << 32) + v44 * (unint64_t)v73;
  unint64_t v92 = v89 & ~v91 | v90;
  unint64_t v93 = v85 * (unint64_t)v73;
  unint64_t v94 = v91 | (v93 << 32);
  unint64_t v95 = v91 & (v93 << 32);
  unint64_t v96 = v91 + (v93 << 32);
  unint64_t v97 = v88 + HIDWORD(v93) + (v92 >> 63) + ((v94 & ~v96 | v95) >> 63);
  unint64_t v98 = v79 | v96;
  unint64_t v99 = v79 & v96;
  unint64_t v100 = v79 + v96;
  unint64_t v101 = v97 + ((v98 & ~v100 | v99) >> 63);
  unint64_t v102 = v101 | v81;
  unint64_t v103 = v101 & v81;
  unint64_t v104 = v101 + v81;
  unint64_t v105 = ((v102 & ~v104 | v103) >> 63) + (v82 >> 63);
  unint64_t v106 = a3[2];
  uint64_t v107 = HIDWORD(*a2);
  LODWORD(v103) = *a2;
  unint64_t v108 = HIDWORD(v106);
  LODWORD(v94) = v106;
  unint64_t v109 = v106 * (unint64_t)v103;
  unint64_t v110 = v94 * (unint64_t)v107;
  unint64_t v111 = HIDWORD(v110) + v108 * (unint64_t)v107;
  unint64_t v112 = v109 | (v110 << 32);
  unint64_t v113 = v109 & (v110 << 32);
  unint64_t v114 = (v110 << 32) + v94 * (unint64_t)v103;
  unint64_t v115 = v112 & ~v114 | v113;
  unint64_t v116 = v108 * (unint64_t)v103;
  unint64_t v117 = v114 | (v116 << 32);
  unint64_t v118 = v114 & (v116 << 32);
  unint64_t v119 = v114 + (v116 << 32);
  unint64_t v120 = v111 + HIDWORD(v116) + (v115 >> 63) + ((v117 & ~v119 | v118) >> 63);
  unint64_t v121 = v100 | v119;
  unint64_t v122 = v100 & v119;
  unint64_t v123 = v100 + v119;
  unint64_t v124 = v120 + ((v121 & ~v123 | v122) >> 63);
  unint64_t v125 = v124 | v104;
  unint64_t v126 = v124 & v104;
  unint64_t v127 = v124 + v104;
  unint64_t v128 = v105 + ((v125 & ~v127 | v126) >> 63);
  result[2] = v123;
  unint64_t v129 = a2[1];
  uint64_t v130 = HIDWORD(*a2);
  LODWORD(v126) = *a2;
  unint64_t v132 = a3[2];
  unint64_t v131 = a3[3];
  unint64_t v133 = HIDWORD(v131);
  LODWORD(v95) = v131;
  unint64_t v134 = v131 * (unint64_t)v126;
  unint64_t v135 = v131 * (unint64_t)v130;
  unint64_t v136 = HIDWORD(v135) + v133 * (unint64_t)v130;
  unint64_t v137 = v134 | (v135 << 32);
  unint64_t v138 = v134 & (v135 << 32);
  unint64_t v139 = (v135 << 32) + v95 * (unint64_t)v126;
  unint64_t v140 = v137 & ~v139 | v138;
  unint64_t v141 = v133 * (unint64_t)v126;
  unint64_t v142 = v139 | (v141 << 32);
  unint64_t v143 = v139 & (v141 << 32);
  unint64_t v144 = v139 + (v141 << 32);
  unint64_t v145 = v136 + HIDWORD(v141) + (v140 >> 63) + ((v142 & ~v144 | v143) >> 63);
  unint64_t v146 = v127 | v144;
  unint64_t v147 = v127 & v144;
  unint64_t v148 = v127 + v144;
  unint64_t v149 = v145 + ((v146 & ~v148 | v147) >> 63);
  unint64_t v150 = v128 + v149;
  unint64_t v151 = v149 & ~(v128 + v149);
  unint64_t v152 = HIDWORD(v129);
  LODWORD(v149) = v129;
  unint64_t v153 = HIDWORD(v132);
  LODWORD(v142) = v132;
  unint64_t v154 = v132 * (unint64_t)v129;
  unint64_t v155 = v132 * (unint64_t)v152;
  unint64_t v156 = HIDWORD(v155) + v153 * (unint64_t)v152;
  unint64_t v157 = v154 | (v155 << 32);
  unint64_t v158 = v154 & (v155 << 32);
  unint64_t v159 = (v155 << 32) + v142 * (unint64_t)v149;
  unint64_t v160 = v157 & ~v159 | v158;
  unint64_t v161 = v153 * (unint64_t)v149;
  unint64_t v162 = v159 | (v161 << 32);
  unint64_t v163 = v159 & (v161 << 32);
  unint64_t v164 = v159 + (v161 << 32);
  unint64_t v165 = v156 + HIDWORD(v161) + (v160 >> 63) + ((v162 & ~v164 | v163) >> 63);
  unint64_t v166 = v148 + v164;
  unint64_t v167 = v165 + (((v148 | v164) & ~(v148 + v164) | v148 & v164) >> 63);
  unint64_t v168 = v167 | v150;
  unint64_t v169 = v167 & v150;
  unint64_t v170 = v167 + v150;
  unint64_t v171 = ((v168 & ~v170 | v169) >> 63) + (v151 >> 63);
  unint64_t v172 = a2[2];
  unint64_t v173 = a2[3];
  unint64_t v174 = HIDWORD(v172);
  LODWORD(v162) = v172;
  unint64_t v175 = a3[1];
  unint64_t v176 = HIDWORD(v175);
  LODWORD(v157) = v175;
  unint64_t v177 = v175 * (unint64_t)v172;
  unint64_t v178 = v175 * (unint64_t)v174;
  unint64_t v179 = HIDWORD(v178) + v176 * (unint64_t)v174;
  unint64_t v180 = v177 | (v178 << 32);
  unint64_t v181 = v177 & (v178 << 32);
  unint64_t v182 = (v178 << 32) + v157 * (unint64_t)v162;
  unint64_t v183 = v180 & ~v182 | v181;
  unint64_t v184 = v176 * (unint64_t)v162;
  unint64_t v185 = v182 | (v184 << 32);
  unint64_t v186 = v182 & (v184 << 32);
  unint64_t v187 = v182 + (v184 << 32);
  unint64_t v188 = v179 + HIDWORD(v184) + (v183 >> 63) + ((v185 & ~v187 | v186) >> 63);
  unint64_t v189 = v166 | v187;
  unint64_t v190 = v166 & v187;
  unint64_t v191 = v166 + v187;
  unint64_t v192 = v188 + ((v189 & ~v191 | v190) >> 63);
  unint64_t v193 = v192 | v170;
  unint64_t v194 = v192 & v170;
  unint64_t v195 = v192 + v170;
  unint64_t v196 = v171 + ((v193 & ~v195 | v194) >> 63);
  unint64_t v197 = HIDWORD(v173);
  LODWORD(v193) = v173;
  uint64_t v198 = HIDWORD(*a3);
  LODWORD(v187) = *a3;
  unint64_t v199 = v187 * (unint64_t)v173;
  unint64_t v200 = v187 * (unint64_t)v197;
  unint64_t v201 = HIDWORD(v200) + v198 * (unint64_t)v197;
  unint64_t v202 = (v200 << 32) + v187 * (unint64_t)v193;
  unint64_t v203 = (v199 | (v200 << 32)) & ~v202 | v199 & (v200 << 32);
  unint64_t v204 = v198 * (unint64_t)v193;
  unint64_t v205 = v202 | (v204 << 32);
  unint64_t v206 = v202 & (v204 << 32);
  unint64_t v207 = v202 + (v204 << 32);
  unint64_t v208 = v201 + HIDWORD(v204) + (v203 >> 63) + ((v205 & ~v207 | v206) >> 63);
  unint64_t v209 = v191 | v207;
  unint64_t v210 = v191 & v207;
  unint64_t v211 = v191 + v207;
  unint64_t v212 = v208 + ((v209 & ~v211 | v210) >> 63);
  unint64_t v213 = v212 | v195;
  unint64_t v214 = v212 & v195;
  unint64_t v215 = v212 + v195;
  unint64_t v216 = v196 + ((v213 & ~v215 | v214) >> 63);
  result[3] = v211;
  unint64_t v217 = a2[3];
  unint64_t v218 = HIDWORD(v217);
  LODWORD(v213) = v217;
  unint64_t v219 = a3[1];
  unint64_t v220 = a3[2];
  unint64_t v221 = HIDWORD(v219);
  LODWORD(v206) = v219;
  unint64_t v222 = v219 * (unint64_t)v217;
  unint64_t v223 = v219 * (unint64_t)v218;
  unint64_t v224 = HIDWORD(v223) + v221 * (unint64_t)v218;
  unint64_t v225 = v222 | (v223 << 32);
  unint64_t v226 = v222 & (v223 << 32);
  unint64_t v227 = (v223 << 32) + v206 * (unint64_t)v213;
  unint64_t v228 = v225 & ~v227 | v226;
  unint64_t v229 = v221 * (unint64_t)v213;
  unint64_t v230 = v227 | (v229 << 32);
  unint64_t v231 = v227 & (v229 << 32);
  unint64_t v232 = v227 + (v229 << 32);
  unint64_t v233 = v224 + HIDWORD(v229) + (v228 >> 63) + ((v230 & ~v232 | v231) >> 63);
  unint64_t v234 = v215 | v232;
  unint64_t v235 = v215 & v232;
  unint64_t v236 = v215 + v232;
  unint64_t v237 = v233 + ((v234 & ~v236 | v235) >> 63);
  unint64_t v238 = v237 | v216;
  unint64_t v239 = v237 + v216;
  unint64_t v240 = v238 & ~v239;
  unint64_t v242 = a2[1];
  unint64_t v241 = a2[2];
  unint64_t v243 = HIDWORD(v241);
  LODWORD(v230) = v241;
  unint64_t v244 = HIDWORD(v220);
  LODWORD(v185) = v220;
  unint64_t v245 = v220 * (unint64_t)v241;
  unint64_t v246 = v220 * (unint64_t)v243;
  unint64_t v247 = HIDWORD(v246) + v244 * (unint64_t)v243;
  unint64_t v248 = v245 | (v246 << 32);
  unint64_t v249 = v245 & (v246 << 32);
  unint64_t v250 = (v246 << 32) + v185 * (unint64_t)v230;
  unint64_t v251 = v248 & ~v250 | v249;
  unint64_t v252 = v244 * (unint64_t)v230;
  unint64_t v253 = v250 | (v252 << 32);
  unint64_t v254 = v250 & (v252 << 32);
  unint64_t v255 = v250 + (v252 << 32);
  unint64_t v256 = v247 + HIDWORD(v252) + (v251 >> 63) + ((v253 & ~v255 | v254) >> 63);
  unint64_t v257 = v236 | v255;
  unint64_t v258 = v236 & v255;
  uint64_t v259 = v236 + v255;
  unint64_t v260 = v256 + ((v257 & ~v259 | v258) >> 63);
  unint64_t v261 = v260 | v239;
  unint64_t v262 = v260 & v239;
  unint64_t v263 = v260 + v239;
  unint64_t v264 = ((v261 & ~v263 | v262) >> 63) + (v240 >> 63);
  unint64_t v265 = a3[3];
  unint64_t v266 = HIDWORD(v242);
  LODWORD(v262) = v242;
  unint64_t v267 = HIDWORD(v265);
  LODWORD(v253) = v265;
  unint64_t v268 = v265 * (unint64_t)v242;
  unint64_t v269 = v253 * (unint64_t)HIDWORD(v242);
  unint64_t v270 = HIDWORD(v269) + v267 * (unint64_t)v266;
  unint64_t v271 = v268 | (v269 << 32);
  unint64_t v272 = v268 & (v269 << 32);
  unint64_t v273 = (v269 << 32) + v253 * (unint64_t)v262;
  unint64_t v274 = v271 & ~v273 | v272;
  unint64_t v275 = v267 * (unint64_t)v262;
  unint64_t v276 = v273 | (v275 << 32);
  unint64_t v277 = v273 & (v275 << 32);
  unint64_t v278 = v273 + (v275 << 32);
  unint64_t v279 = v270 + HIDWORD(v275) + (v274 >> 63) + ((v276 & ~v278 | v277) >> 63);
  unint64_t v280 = v259 | v278;
  unint64_t v281 = v259 & v278;
  unint64_t v282 = v259 + v278;
  unint64_t v283 = v279 + ((v280 & ~v282 | v281) >> 63);
  unint64_t v284 = v283 | v263;
  unint64_t v285 = v283 & v263;
  unint64_t v286 = v283 + v263;
  unint64_t v287 = v264 + ((v284 & ~v286 | v285) >> 63);
  result[4] = v282;
  unint64_t v288 = a2[2];
  unint64_t v289 = a2[3];
  unint64_t v290 = HIDWORD(v288);
  LODWORD(v285) = v288;
  unint64_t v292 = a3[2];
  unint64_t v291 = a3[3];
  unint64_t v293 = HIDWORD(v291);
  LODWORD(v254) = v291;
  unint64_t v294 = v291 * (unint64_t)v288;
  unint64_t v295 = v291 * (unint64_t)v290;
  unint64_t v296 = HIDWORD(v295) + v293 * (unint64_t)v290;
  unint64_t v297 = v294 | (v295 << 32);
  unint64_t v298 = v294 & (v295 << 32);
  unint64_t v299 = (v295 << 32) + v254 * (unint64_t)v285;
  unint64_t v300 = v297 & ~v299 | v298;
  unint64_t v301 = v293 * (unint64_t)v285;
  unint64_t v302 = v299 | (v301 << 32);
  unint64_t v303 = v299 & (v301 << 32);
  unint64_t v304 = v299 + (v301 << 32);
  unint64_t v305 = v296 + HIDWORD(v301) + (v300 >> 63) + ((v302 & ~v304 | v303) >> 63);
  unint64_t v306 = v286 | v304;
  unint64_t v307 = v286 & v304;
  unint64_t v308 = v286 + v304;
  unint64_t v309 = v305 + ((v306 & ~v308 | v307) >> 63);
  unint64_t v310 = v287 + v309;
  unint64_t v311 = v309 & ~(v287 + v309);
  unint64_t v312 = HIDWORD(v289);
  LODWORD(v306) = v289;
  unint64_t v313 = HIDWORD(v292);
  LODWORD(v302) = v292;
  unint64_t v314 = v292 * (unint64_t)v289;
  unint64_t v315 = v292 * (unint64_t)v312;
  unint64_t v316 = HIDWORD(v315) + v313 * (unint64_t)v312;
  unint64_t v317 = v314 | (v315 << 32);
  unint64_t v318 = v314 & (v315 << 32);
  unint64_t v319 = (v315 << 32) + v302 * (unint64_t)v306;
  unint64_t v320 = v317 & ~v319 | v318;
  unint64_t v321 = v313 * (unint64_t)v306;
  unint64_t v322 = v319 | (v321 << 32);
  unint64_t v323 = v319 & (v321 << 32);
  unint64_t v324 = v319 + (v321 << 32);
  unint64_t v325 = v316
       + HIDWORD(v321)
       + (v320 >> 63)
       + ((v322 & ~v324 | v323) >> 63)
       + (((v308 | v324) & ~(v308 + v324) | v308 & v324) >> 63);
  unint64_t v326 = v325 | v310;
  unint64_t v327 = v325 & v310;
  unint64_t v328 = v325 + v310;
  unint64_t v329 = v326 & ~v328 | v327;
  result[5] = v308 + v324;
  unint64_t v330 = a2[3];
  unint64_t v331 = a3[3];
  unint64_t v332 = HIDWORD(v330);
  LODWORD(v308) = v330;
  unint64_t v333 = HIDWORD(v331);
  LODWORD(v323) = v331;
  unint64_t v334 = v331 * (unint64_t)v330;
  unint64_t v335 = v331 * (unint64_t)v332;
  unint64_t v336 = HIDWORD(v335) + v333 * (unint64_t)v332;
  unint64_t v337 = v334 | (v335 << 32);
  unint64_t v338 = v334 & (v335 << 32);
  unint64_t v339 = (v335 << 32) + v323 * (unint64_t)v308;
  unint64_t v340 = v337 & ~v339 | v338;
  unint64_t v341 = v333 * (unint64_t)v308;
  unint64_t v342 = v339 | (v341 << 32);
  unint64_t v343 = v339 & (v341 << 32);
  unint64_t v344 = v339 + (v341 << 32);
  unint64_t v345 = v336 + HIDWORD(v341) + (v340 >> 63) + ((v342 & ~v344 | v343) >> 63);
  unint64_t v346 = v328 | v344;
  unint64_t v347 = v328 & v344;
  unint64_t v348 = v328 + v344;
  result[6] = v348;
  result[7] = v345 + (v311 >> 63) + (v329 >> 63) + ((v346 & ~v348 | v347) >> 63);
  return result;
}

unint64_t *bn_mul_comba8(unint64_t *result, void *a2, void *a3)
{
  uint64_t v3 = HIDWORD(*a2);
  unint64_t v4 = *a3 * (unint64_t)*a2;
  unint64_t v5 = *a3 * (unint64_t)v3;
  unint64_t v6 = v4 | (v5 << 32);
  uint64_t v7 = HIDWORD(*a3);
  unint64_t v8 = HIDWORD(v5);
  unint64_t v9 = v4 & (v5 << 32);
  unint64_t v10 = (v5 << 32) + *a3 * (unint64_t)*a2;
  unint64_t v11 = v7 * (unint64_t)*a2;
  unint64_t v12 = v10 | (v11 << 32);
  unint64_t v13 = v8 + v7 * (unint64_t)v3;
  unint64_t v14 = v6 & ~v10;
  unint64_t v15 = v10 & (v11 << 32);
  unint64_t v16 = v10 + (v11 << 32);
  unint64_t v17 = v13 + HIDWORD(v11) + ((v14 | v9) >> 63) + ((v12 & ~v16 | v15) >> 63);
  *uint64_t result = v16;
  unint64_t v18 = a2[1];
  uint64_t v19 = HIDWORD(*a2);
  LODWORD(v9) = *a2;
  unint64_t v20 = a3[1];
  unint64_t v21 = HIDWORD(v20);
  unsigned int v22 = v20;
  unint64_t v23 = v20 * (unint64_t)v9;
  unint64_t v24 = v20 * (unint64_t)v19;
  unint64_t v25 = HIDWORD(v24) + v21 * (unint64_t)v19;
  unint64_t v26 = v23 | (v24 << 32);
  unint64_t v27 = v23 & (v24 << 32);
  unint64_t v28 = (v24 << 32) + v22 * (unint64_t)v9;
  unint64_t v29 = v26 & ~v28 | v27;
  unint64_t v30 = v21 * (unint64_t)v9;
  unint64_t v31 = v28 | (v30 << 32);
  unint64_t v32 = v28 & (v30 << 32);
  unint64_t v33 = v28 + (v30 << 32);
  unint64_t v34 = v25 + HIDWORD(v30) + (v29 >> 63) + ((v31 & ~v33 | v32) >> 63);
  unint64_t v35 = v17 | v33;
  unint64_t v36 = v17 & v33;
  unint64_t v37 = v17 + v33;
  unint64_t v38 = v34 + ((v35 & ~v37 | v36) >> 63);
  unint64_t v39 = HIDWORD(v18);
  LODWORD(v36) = v18;
  uint64_t v40 = HIDWORD(*a3);
  LODWORD(v31) = *a3;
  unint64_t v41 = v31 * (unint64_t)v18;
  unint64_t v42 = v31 * (unint64_t)v39;
  unint64_t v43 = HIDWORD(v42) + v40 * (unint64_t)v39;
  unint64_t v44 = v41 | (v42 << 32);
  unint64_t v45 = v41 & (v42 << 32);
  unint64_t v46 = (v42 << 32) + v31 * (unint64_t)v36;
  unint64_t v47 = v44 & ~v46 | v45;
  unint64_t v48 = v40 * (unint64_t)v36;
  unint64_t v49 = v46 | (v48 << 32);
  unint64_t v50 = v46 & (v48 << 32);
  unint64_t v51 = v46 + (v48 << 32);
  unint64_t v52 = v43 + HIDWORD(v48) + (v47 >> 63) + ((v49 & ~v51 | v50) >> 63);
  unint64_t v53 = v51 | v37;
  unint64_t v54 = v51 & v37;
  unint64_t v55 = v51 + v37;
  unint64_t v56 = v52 + ((v53 & ~v55 | v54) >> 63);
  unint64_t v57 = v56 | v38;
  unint64_t v58 = v56 & v38;
  unint64_t v59 = v56 + v38;
  unint64_t v60 = v57 & ~v59 | v58;
  result[1] = v55;
  unint64_t v61 = a2[2];
  unint64_t v62 = HIDWORD(v61);
  LODWORD(v58) = v61;
  unint64_t v63 = a3[1];
  uint64_t v64 = HIDWORD(*a3);
  LODWORD(v32) = *a3;
  unint64_t v65 = v32 * (unint64_t)v61;
  unint64_t v66 = v32 * (unint64_t)v62;
  unint64_t v67 = HIDWORD(v66) + v64 * (unint64_t)v62;
  unint64_t v68 = v65 | (v66 << 32);
  unint64_t v69 = v65 & (v66 << 32);
  unint64_t v70 = (v66 << 32) + v32 * (unint64_t)v58;
  unint64_t v71 = v68 & ~v70 | v69;
  unint64_t v72 = v64 * (unint64_t)v58;
  unint64_t v73 = v70 | (v72 << 32);
  unint64_t v74 = v70 & (v72 << 32);
  unint64_t v75 = v70 + (v72 << 32);
  unint64_t v76 = v67 + HIDWORD(v72) + (v71 >> 63) + ((v73 & ~v75 | v74) >> 63);
  unint64_t v77 = v59 | v75;
  unint64_t v78 = v59 & v75;
  unint64_t v79 = v59 + v75;
  unint64_t v80 = v76 + ((v77 & ~v79 | v78) >> 63);
  unint64_t v81 = v80 + (v60 >> 63);
  unint64_t v82 = v80 & ~v81;
  unint64_t v83 = a2[1];
  unint64_t v84 = HIDWORD(v83);
  LODWORD(v73) = v83;
  unint64_t v85 = HIDWORD(v63);
  LODWORD(v44) = v63;
  unint64_t v86 = v63 * (unint64_t)v83;
  unint64_t v87 = v63 * (unint64_t)v84;
  unint64_t v88 = HIDWORD(v87) + v85 * (unint64_t)v84;
  unint64_t v89 = v86 | (v87 << 32);
  unint64_t v90 = v86 & (v87 << 32);
  unint64_t v91 = (v87 << 32) + v44 * (unint64_t)v73;
  unint64_t v92 = v89 & ~v91 | v90;
  unint64_t v93 = v85 * (unint64_t)v73;
  unint64_t v94 = v91 | (v93 << 32);
  unint64_t v95 = v91 & (v93 << 32);
  unint64_t v96 = v91 + (v93 << 32);
  unint64_t v97 = v88 + HIDWORD(v93) + (v92 >> 63) + ((v94 & ~v96 | v95) >> 63);
  unint64_t v98 = v79 | v96;
  unint64_t v99 = v79 & v96;
  unint64_t v100 = v79 + v96;
  unint64_t v101 = v97 + ((v98 & ~v100 | v99) >> 63);
  unint64_t v102 = v101 | v81;
  unint64_t v103 = v101 & v81;
  unint64_t v104 = v101 + v81;
  unint64_t v105 = ((v102 & ~v104 | v103) >> 63) + (v82 >> 63);
  unint64_t v106 = a3[2];
  uint64_t v107 = HIDWORD(*a2);
  LODWORD(v103) = *a2;
  unint64_t v108 = HIDWORD(v106);
  LODWORD(v94) = v106;
  unint64_t v109 = v106 * (unint64_t)v103;
  unint64_t v110 = v94 * (unint64_t)v107;
  unint64_t v111 = HIDWORD(v110) + v108 * (unint64_t)v107;
  unint64_t v112 = v109 | (v110 << 32);
  unint64_t v113 = v109 & (v110 << 32);
  unint64_t v114 = (v110 << 32) + v94 * (unint64_t)v103;
  unint64_t v115 = v112 & ~v114 | v113;
  unint64_t v116 = v108 * (unint64_t)v103;
  unint64_t v117 = v114 | (v116 << 32);
  unint64_t v118 = v114 & (v116 << 32);
  unint64_t v119 = v114 + (v116 << 32);
  unint64_t v120 = v111 + HIDWORD(v116) + (v115 >> 63) + ((v117 & ~v119 | v118) >> 63);
  unint64_t v121 = v100 | v119;
  unint64_t v122 = v100 & v119;
  unint64_t v123 = v100 + v119;
  unint64_t v124 = v120 + ((v121 & ~v123 | v122) >> 63);
  unint64_t v125 = v124 | v104;
  unint64_t v126 = v124 & v104;
  unint64_t v127 = v124 + v104;
  unint64_t v128 = v105 + ((v125 & ~v127 | v126) >> 63);
  result[2] = v123;
  unint64_t v129 = a2[1];
  uint64_t v130 = HIDWORD(*a2);
  LODWORD(v126) = *a2;
  unint64_t v132 = a3[2];
  unint64_t v131 = a3[3];
  unint64_t v133 = HIDWORD(v131);
  LODWORD(v95) = v131;
  unint64_t v134 = v131 * (unint64_t)v126;
  unint64_t v135 = v131 * (unint64_t)v130;
  unint64_t v136 = HIDWORD(v135) + v133 * (unint64_t)v130;
  unint64_t v137 = v134 | (v135 << 32);
  unint64_t v138 = v134 & (v135 << 32);
  unint64_t v139 = (v135 << 32) + v95 * (unint64_t)v126;
  unint64_t v140 = v137 & ~v139 | v138;
  unint64_t v141 = v133 * (unint64_t)v126;
  unint64_t v142 = v139 | (v141 << 32);
  unint64_t v143 = v139 & (v141 << 32);
  unint64_t v144 = v139 + (v141 << 32);
  unint64_t v145 = v136 + HIDWORD(v141) + (v140 >> 63) + ((v142 & ~v144 | v143) >> 63);
  unint64_t v146 = v127 | v144;
  unint64_t v147 = v127 & v144;
  unint64_t v148 = v127 + v144;
  unint64_t v149 = v145 + ((v146 & ~v148 | v147) >> 63);
  unint64_t v150 = v128 + v149;
  unint64_t v151 = v149 & ~(v128 + v149);
  unint64_t v152 = HIDWORD(v129);
  LODWORD(v149) = v129;
  unint64_t v153 = HIDWORD(v132);
  LODWORD(v142) = v132;
  unint64_t v154 = v132 * (unint64_t)v129;
  unint64_t v155 = v132 * (unint64_t)v152;
  unint64_t v156 = HIDWORD(v155) + v153 * (unint64_t)v152;
  unint64_t v157 = v154 | (v155 << 32);
  unint64_t v158 = v154 & (v155 << 32);
  unint64_t v159 = (v155 << 32) + v142 * (unint64_t)v149;
  unint64_t v160 = v157 & ~v159 | v158;
  unint64_t v161 = v153 * (unint64_t)v149;
  unint64_t v162 = v159 | (v161 << 32);
  unint64_t v163 = v159 & (v161 << 32);
  unint64_t v164 = v159 + (v161 << 32);
  unint64_t v165 = v156 + HIDWORD(v161) + (v160 >> 63) + ((v162 & ~v164 | v163) >> 63);
  unint64_t v166 = v148 + v164;
  unint64_t v167 = v165 + (((v148 | v164) & ~(v148 + v164) | v148 & v164) >> 63);
  unint64_t v168 = v167 | v150;
  unint64_t v169 = v167 & v150;
  unint64_t v170 = v167 + v150;
  unint64_t v171 = ((v168 & ~v170 | v169) >> 63) + (v151 >> 63);
  unint64_t v172 = a2[2];
  unint64_t v173 = a2[3];
  unint64_t v174 = HIDWORD(v172);
  LODWORD(v162) = v172;
  unint64_t v175 = a3[1];
  unint64_t v176 = HIDWORD(v175);
  LODWORD(v157) = v175;
  unint64_t v177 = v175 * (unint64_t)v172;
  unint64_t v178 = v175 * (unint64_t)v174;
  unint64_t v179 = HIDWORD(v178) + v176 * (unint64_t)v174;
  unint64_t v180 = v177 | (v178 << 32);
  unint64_t v181 = v177 & (v178 << 32);
  unint64_t v182 = (v178 << 32) + v157 * (unint64_t)v162;
  unint64_t v183 = v180 & ~v182 | v181;
  unint64_t v184 = v176 * (unint64_t)v162;
  unint64_t v185 = v182 | (v184 << 32);
  unint64_t v186 = v182 & (v184 << 32);
  unint64_t v187 = v182 + (v184 << 32);
  unint64_t v188 = v179 + HIDWORD(v184) + (v183 >> 63) + ((v185 & ~v187 | v186) >> 63);
  unint64_t v189 = v166 | v187;
  unint64_t v190 = v166 & v187;
  unint64_t v191 = v166 + v187;
  unint64_t v192 = v188 + ((v189 & ~v191 | v190) >> 63);
  unint64_t v193 = v192 | v170;
  unint64_t v194 = v192 & v170;
  unint64_t v195 = v192 + v170;
  unint64_t v196 = v171 + ((v193 & ~v195 | v194) >> 63);
  unint64_t v197 = HIDWORD(v173);
  LODWORD(v193) = v173;
  uint64_t v198 = HIDWORD(*a3);
  LODWORD(v187) = *a3;
  unint64_t v199 = v187 * (unint64_t)v173;
  unint64_t v200 = v187 * (unint64_t)v197;
  unint64_t v201 = HIDWORD(v200) + v198 * (unint64_t)v197;
  unint64_t v202 = (v200 << 32) + v187 * (unint64_t)v193;
  unint64_t v203 = (v199 | (v200 << 32)) & ~v202 | v199 & (v200 << 32);
  unint64_t v204 = v198 * (unint64_t)v193;
  unint64_t v205 = v202 | (v204 << 32);
  unint64_t v206 = v202 & (v204 << 32);
  unint64_t v207 = v202 + (v204 << 32);
  unint64_t v208 = v201 + HIDWORD(v204) + (v203 >> 63) + ((v205 & ~v207 | v206) >> 63);
  unint64_t v209 = v191 | v207;
  unint64_t v210 = v191 & v207;
  unint64_t v211 = v191 + v207;
  unint64_t v212 = v208 + ((v209 & ~v211 | v210) >> 63);
  unint64_t v213 = v212 | v195;
  unint64_t v214 = v212 & v195;
  unint64_t v215 = v212 + v195;
  unint64_t v216 = v196 + ((v213 & ~v215 | v214) >> 63);
  result[3] = v211;
  unint64_t v217 = a2[4];
  unint64_t v218 = HIDWORD(v217);
  LODWORD(v213) = v217;
  unint64_t v219 = a3[1];
  uint64_t v220 = HIDWORD(*a3);
  LODWORD(v206) = *a3;
  unint64_t v221 = v206 * (unint64_t)v217;
  unint64_t v222 = v206 * (unint64_t)v218;
  unint64_t v223 = HIDWORD(v222) + v220 * (unint64_t)v218;
  unint64_t v224 = v221 | (v222 << 32);
  unint64_t v225 = v221 & (v222 << 32);
  unint64_t v226 = (v222 << 32) + v206 * (unint64_t)v213;
  unint64_t v227 = v224 & ~v226 | v225;
  unint64_t v228 = v220 * (unint64_t)v213;
  unint64_t v229 = v226 | (v228 << 32);
  unint64_t v230 = v226 & (v228 << 32);
  unint64_t v231 = v226 + (v228 << 32);
  unint64_t v232 = v223 + HIDWORD(v228) + (v227 >> 63) + ((v229 & ~v231 | v230) >> 63);
  unint64_t v233 = v215 | v231;
  unint64_t v234 = v215 & v231;
  unint64_t v235 = v215 + v231;
  unint64_t v236 = v232 + ((v233 & ~v235 | v234) >> 63);
  unint64_t v237 = v236 | v216;
  unint64_t v238 = v236 + v216;
  unint64_t v239 = v237 & ~v238;
  unint64_t v241 = a2[2];
  unint64_t v240 = a2[3];
  unint64_t v242 = HIDWORD(v240);
  LODWORD(v229) = v240;
  unint64_t v243 = HIDWORD(v219);
  LODWORD(v185) = v219;
  unint64_t v244 = v219 * (unint64_t)v240;
  unint64_t v245 = v219 * (unint64_t)v242;
  unint64_t v246 = HIDWORD(v245) + v243 * (unint64_t)v242;
  unint64_t v247 = v244 | (v245 << 32);
  unint64_t v248 = v244 & (v245 << 32);
  unint64_t v249 = (v245 << 32) + v185 * (unint64_t)v229;
  unint64_t v250 = v247 & ~v249 | v248;
  unint64_t v251 = v243 * (unint64_t)v229;
  unint64_t v252 = v249 | (v251 << 32);
  unint64_t v253 = v249 & (v251 << 32);
  unint64_t v254 = v249 + (v251 << 32);
  unint64_t v255 = v246 + HIDWORD(v251) + (v250 >> 63) + ((v252 & ~v254 | v253) >> 63);
  unint64_t v256 = v235 | v254;
  unint64_t v257 = v235 & v254;
  uint64_t v258 = v235 + v254;
  unint64_t v259 = v255 + ((v256 & ~v258 | v257) >> 63);
  unint64_t v260 = v259 | v238;
  unint64_t v261 = v259 & v238;
  unint64_t v262 = v259 + v238;
  unint64_t v263 = ((v260 & ~v262 | v261) >> 63) + (v239 >> 63);
  unint64_t v264 = HIDWORD(v241);
  LODWORD(v260) = v241;
  unint64_t v265 = a3[2];
  unint64_t v266 = a3[3];
  unint64_t v267 = HIDWORD(v265);
  LODWORD(v253) = v265;
  unint64_t v268 = v265 * (unint64_t)v241;
  unint64_t v269 = v265 * (unint64_t)v264;
  unint64_t v270 = HIDWORD(v269) + v267 * (unint64_t)v264;
  unint64_t v271 = v268 | (v269 << 32);
  unint64_t v272 = v268 & (v269 << 32);
  unint64_t v273 = (v269 << 32) + v253 * (unint64_t)v260;
  unint64_t v274 = v271 & ~v273 | v272;
  unint64_t v275 = v267 * (unint64_t)v260;
  unint64_t v276 = v273 | (v275 << 32);
  unint64_t v277 = v273 & (v275 << 32);
  unint64_t v278 = v273 + (v275 << 32);
  unint64_t v279 = v270 + HIDWORD(v275) + (v274 >> 63) + ((v276 & ~v278 | v277) >> 63);
  unint64_t v280 = v258 | v278;
  unint64_t v281 = v258 & v278;
  uint64_t v282 = v258 + v278;
  unint64_t v283 = v279 + ((v280 & ~v282 | v281) >> 63);
  unint64_t v284 = v283 | v262;
  unint64_t v285 = v283 & v262;
  unint64_t v286 = v283 + v262;
  unint64_t v287 = v263 + ((v284 & ~v286 | v285) >> 63);
  unint64_t v288 = a2[1];
  unint64_t v289 = HIDWORD(v288);
  LODWORD(v278) = v288;
  unint64_t v290 = HIDWORD(v266);
  LODWORD(v277) = v266;
  unint64_t v291 = v266 * (unint64_t)v288;
  unint64_t v292 = v266 * (unint64_t)v289;
  unint64_t v293 = HIDWORD(v292) + v290 * (unint64_t)v289;
  unint64_t v294 = v291 | (v292 << 32);
  unint64_t v295 = v291 & (v292 << 32);
  unint64_t v296 = (v292 << 32) + v277 * (unint64_t)v278;
  unint64_t v297 = v294 & ~v296 | v295;
  unint64_t v298 = v290 * (unint64_t)v278;
  unint64_t v299 = v296 | (v298 << 32);
  unint64_t v300 = v296 & (v298 << 32);
  unint64_t v301 = v296 + (v298 << 32);
  unint64_t v302 = v293 + HIDWORD(v298) + (v297 >> 63) + ((v299 & ~v301 | v300) >> 63);
  unint64_t v303 = v282 | v301;
  unint64_t v304 = v282 & v301;
  uint64_t v305 = v282 + v301;
  unint64_t v306 = v302 + ((v303 & ~v305 | v304) >> 63);
  unint64_t v307 = v306 | v286;
  unint64_t v308 = v306 & v286;
  unint64_t v309 = v306 + v286;
  unint64_t v310 = v287 + ((v307 & ~v309 | v308) >> 63);
  unint64_t v311 = a3[4];
  uint64_t v312 = HIDWORD(*a2);
  LODWORD(v308) = *a2;
  unint64_t v313 = HIDWORD(v311);
  LODWORD(v299) = v311;
  unint64_t v314 = v311 * (unint64_t)v308;
  unint64_t v315 = v299 * (unint64_t)v312;
  unint64_t v316 = HIDWORD(v315) + v313 * (unint64_t)v312;
  unint64_t v317 = v314 | (v315 << 32);
  unint64_t v318 = v314 & (v315 << 32);
  unint64_t v319 = (v315 << 32) + v299 * (unint64_t)v308;
  unint64_t v320 = v317 & ~v319 | v318;
  unint64_t v321 = v313 * (unint64_t)v308;
  unint64_t v322 = v319 | (v321 << 32);
  unint64_t v323 = v319 & (v321 << 32);
  unint64_t v324 = v319 + (v321 << 32);
  unint64_t v325 = v316 + HIDWORD(v321) + (v320 >> 63) + ((v322 & ~v324 | v323) >> 63);
  unint64_t v326 = v324 | v305;
  unint64_t v327 = v324 & v305;
  unint64_t v328 = v324 + v305;
  unint64_t v329 = v325 + ((v326 & ~v328 | v327) >> 63);
  unint64_t v330 = v329 | v309;
  unint64_t v331 = v329 & v309;
  uint64_t v332 = v329 + v309;
  unint64_t v333 = v310 + ((v330 & ~v332 | v331) >> 63);
  result[4] = v328;
  unint64_t v334 = a2[1];
  uint64_t v335 = HIDWORD(*a2);
  LODWORD(v331) = *a2;
  unint64_t v337 = a3[4];
  unint64_t v336 = a3[5];
  unint64_t v338 = HIDWORD(v336);
  LODWORD(v300) = v336;
  unint64_t v339 = v336 * (unint64_t)v331;
  unint64_t v340 = v336 * (unint64_t)v335;
  unint64_t v341 = HIDWORD(v340) + v338 * (unint64_t)v335;
  unint64_t v342 = v339 | (v340 << 32);
  unint64_t v343 = v339 & (v340 << 32);
  unint64_t v344 = (v340 << 32) + v300 * (unint64_t)v331;
  unint64_t v345 = v342 & ~v344 | v343;
  unint64_t v346 = v338 * (unint64_t)v331;
  unint64_t v347 = v344 | (v346 << 32);
  unint64_t v348 = v344 & (v346 << 32);
  unint64_t v349 = v344 + (v346 << 32);
  unint64_t v350 = v341 + HIDWORD(v346) + (v345 >> 63) + ((v347 & ~v349 | v348) >> 63);
  unint64_t v351 = v332 | v349;
  unint64_t v352 = v332 & v349;
  uint64_t v353 = v332 + v349;
  unint64_t v354 = v350 + ((v351 & ~v353 | v352) >> 63);
  unint64_t v355 = v354 | v333;
  unint64_t v356 = v354 + v333;
  unint64_t v357 = v355 & ~v356;
  unint64_t v358 = HIDWORD(v334);
  LODWORD(v352) = v334;
  unint64_t v359 = HIDWORD(v337);
  LODWORD(v347) = v337;
  unint64_t v360 = v337 * (unint64_t)v334;
  unint64_t v361 = v337 * (unint64_t)v358;
  unint64_t v362 = HIDWORD(v361) + v359 * (unint64_t)v358;
  unint64_t v363 = v360 | (v361 << 32);
  unint64_t v364 = v360 & (v361 << 32);
  unint64_t v365 = (v361 << 32) + v347 * (unint64_t)v352;
  unint64_t v366 = v363 & ~v365 | v364;
  unint64_t v367 = v359 * (unint64_t)v352;
  unint64_t v368 = v365 | (v367 << 32);
  unint64_t v369 = v365 & (v367 << 32);
  unint64_t v370 = v365 + (v367 << 32);
  unint64_t v371 = v362 + HIDWORD(v367) + (v366 >> 63) + ((v368 & ~v370 | v369) >> 63);
  unint64_t v372 = v353 | v370;
  unint64_t v373 = v353 & v370;
  uint64_t v374 = v353 + v370;
  unint64_t v375 = v371 + ((v372 & ~v374 | v373) >> 63);
  unint64_t v376 = v375 | v356;
  unint64_t v377 = v375 & v356;
  unint64_t v378 = v375 + v356;
  unint64_t v379 = ((v376 & ~v378 | v377) >> 63) + (v357 >> 63);
  unint64_t v380 = a2[2];
  unint64_t v381 = a2[3];
  unint64_t v382 = HIDWORD(v380);
  LODWORD(v368) = v380;
  unint64_t v384 = a3[2];
  unint64_t v383 = a3[3];
  unint64_t v385 = HIDWORD(v383);
  LODWORD(v363) = v383;
  unint64_t v386 = v383 * (unint64_t)v380;
  unint64_t v387 = v383 * (unint64_t)v382;
  unint64_t v388 = HIDWORD(v387) + v385 * (unint64_t)v382;
  unint64_t v389 = v386 | (v387 << 32);
  unint64_t v390 = v386 & (v387 << 32);
  unint64_t v391 = (v387 << 32) + v363 * (unint64_t)v368;
  unint64_t v392 = v389 & ~v391 | v390;
  unint64_t v393 = v385 * (unint64_t)v368;
  unint64_t v394 = v391 | (v393 << 32);
  unint64_t v395 = v391 & (v393 << 32);
  unint64_t v396 = v391 + (v393 << 32);
  unint64_t v397 = v388 + HIDWORD(v393) + (v392 >> 63) + ((v394 & ~v396 | v395) >> 63);
  unint64_t v398 = v374 | v396;
  unint64_t v399 = v374 & v396;
  uint64_t v400 = v374 + v396;
  unint64_t v401 = v397 + ((v398 & ~v400 | v399) >> 63);
  unint64_t v402 = v401 | v378;
  unint64_t v403 = v401 & v378;
  unint64_t v404 = v401 + v378;
  unint64_t v405 = v379 + ((v402 & ~v404 | v403) >> 63);
  unint64_t v406 = HIDWORD(v381);
  LODWORD(v402) = v381;
  unint64_t v407 = HIDWORD(v384);
  LODWORD(v396) = v384;
  unint64_t v408 = v384 * (unint64_t)v381;
  unint64_t v409 = v384 * (unint64_t)v406;
  unint64_t v410 = HIDWORD(v409) + v407 * (unint64_t)v406;
  unint64_t v411 = (v409 << 32) + v396 * (unint64_t)v402;
  unint64_t v412 = (v408 | (v409 << 32)) & ~v411 | v408 & (v409 << 32);
  unint64_t v413 = v407 * (unint64_t)v402;
  unint64_t v414 = v411 | (v413 << 32);
  unint64_t v415 = v411 & (v413 << 32);
  unint64_t v416 = v411 + (v413 << 32);
  unint64_t v417 = v410 + HIDWORD(v413) + (v412 >> 63) + ((v414 & ~v416 | v415) >> 63);
  unint64_t v418 = v416 | v400;
  unint64_t v419 = v416 & v400;
  uint64_t v420 = v416 + v400;
  unint64_t v421 = v417 + ((v418 & ~v420 | v419) >> 63);
  unint64_t v422 = v421 | v404;
  unint64_t v423 = v421 & v404;
  uint64_t v424 = v421 + v404;
  unint64_t v425 = v405 + ((v422 & ~v424 | v423) >> 63);
  unint64_t v426 = a2[4];
  unint64_t v427 = a2[5];
  unint64_t v428 = HIDWORD(v426);
  LODWORD(v414) = v426;
  unint64_t v429 = a3[1];
  unint64_t v430 = HIDWORD(v429);
  LODWORD(v395) = v429;
  unint64_t v431 = v429 * (unint64_t)v426;
  unint64_t v432 = v429 * (unint64_t)v428;
  unint64_t v433 = HIDWORD(v432) + v430 * (unint64_t)v428;
  unint64_t v434 = v431 | (v432 << 32);
  unint64_t v435 = v431 & (v432 << 32);
  unint64_t v436 = (v432 << 32) + v395 * (unint64_t)v414;
  unint64_t v437 = v434 & ~v436 | v435;
  unint64_t v438 = v430 * (unint64_t)v414;
  unint64_t v439 = v436 | (v438 << 32);
  unint64_t v440 = v436 & (v438 << 32);
  unint64_t v441 = v436 + (v438 << 32);
  unint64_t v442 = v433 + HIDWORD(v438) + (v437 >> 63) + ((v439 & ~v441 | v440) >> 63);
  unint64_t v443 = v441 | v420;
  unint64_t v444 = v441 & v420;
  uint64_t v445 = v441 + v420;
  unint64_t v446 = v442 + ((v443 & ~v445 | v444) >> 63);
  unint64_t v447 = v446 | v424;
  unint64_t v448 = v446 & v424;
  uint64_t v449 = v446 + v424;
  unint64_t v450 = v425 + ((v447 & ~v449 | v448) >> 63);
  unint64_t v451 = HIDWORD(v427);
  LODWORD(v447) = v427;
  uint64_t v452 = HIDWORD(*a3);
  LODWORD(v441) = *a3;
  unint64_t v453 = v441 * (unint64_t)v427;
  unint64_t v454 = v441 * (unint64_t)v451;
  unint64_t v455 = HIDWORD(v454) + v452 * (unint64_t)v451;
  unint64_t v456 = (v454 << 32) + v441 * (unint64_t)v447;
  unint64_t v457 = (v453 | (v454 << 32)) & ~v456 | v453 & (v454 << 32);
  unint64_t v458 = v452 * (unint64_t)v447;
  unint64_t v459 = v456 | (v458 << 32);
  unint64_t v460 = v456 & (v458 << 32);
  unint64_t v461 = v456 + (v458 << 32);
  unint64_t v462 = v455 + HIDWORD(v458) + (v457 >> 63) + ((v459 & ~v461 | v460) >> 63);
  unint64_t v463 = v461 | v445;
  unint64_t v464 = v461 & v445;
  unint64_t v465 = v461 + v445;
  unint64_t v466 = v462 + ((v463 & ~v465 | v464) >> 63);
  unint64_t v467 = v466 | v449;
  unint64_t v468 = v466 & v449;
  uint64_t v469 = v466 + v449;
  unint64_t v470 = v450 + ((v467 & ~v469 | v468) >> 63);
  result[5] = v465;
  unint64_t v471 = a2[6];
  unint64_t v472 = HIDWORD(v471);
  LODWORD(v467) = v471;
  unint64_t v473 = a3[1];
  uint64_t v474 = HIDWORD(*a3);
  LODWORD(v460) = *a3;
  unint64_t v475 = v460 * (unint64_t)v471;
  unint64_t v476 = v460 * (unint64_t)v472;
  unint64_t v477 = HIDWORD(v476) + v474 * (unint64_t)v472;
  unint64_t v478 = v475 | (v476 << 32);
  unint64_t v479 = v475 & (v476 << 32);
  unint64_t v480 = (v476 << 32) + v460 * (unint64_t)v467;
  unint64_t v481 = v478 & ~v480 | v479;
  unint64_t v482 = v474 * (unint64_t)v467;
  unint64_t v483 = v480 | (v482 << 32);
  unint64_t v484 = v480 & (v482 << 32);
  unint64_t v485 = v480 + (v482 << 32);
  unint64_t v486 = v477 + HIDWORD(v482) + (v481 >> 63) + ((v483 & ~v485 | v484) >> 63);
  unint64_t v487 = v469 | v485;
  unint64_t v488 = v469 & v485;
  uint64_t v489 = v469 + v485;
  unint64_t v490 = v486 + ((v487 & ~v489 | v488) >> 63);
  unint64_t v491 = v490 | v470;
  unint64_t v492 = v490 + v470;
  unint64_t v493 = v491 & ~v492;
  unint64_t v495 = a2[4];
  unint64_t v494 = a2[5];
  unint64_t v496 = HIDWORD(v494);
  LODWORD(v483) = v494;
  unint64_t v497 = HIDWORD(v473);
  LODWORD(v439) = v473;
  unint64_t v498 = v473 * (unint64_t)v494;
  unint64_t v499 = v473 * (unint64_t)v496;
  unint64_t v500 = HIDWORD(v499) + v497 * (unint64_t)v496;
  unint64_t v501 = v498 | (v499 << 32);
  unint64_t v502 = v498 & (v499 << 32);
  unint64_t v503 = (v499 << 32) + v439 * (unint64_t)v483;
  unint64_t v504 = v501 & ~v503 | v502;
  unint64_t v505 = v497 * (unint64_t)v483;
  unint64_t v506 = v503 | (v505 << 32);
  unint64_t v507 = v503 & (v505 << 32);
  unint64_t v508 = v503 + (v505 << 32);
  unint64_t v509 = v500 + HIDWORD(v505) + (v504 >> 63) + ((v506 & ~v508 | v507) >> 63);
  unint64_t v510 = v489 | v508;
  unint64_t v511 = v489 & v508;
  uint64_t v512 = v489 + v508;
  unint64_t v513 = v509 + ((v510 & ~v512 | v511) >> 63);
  unint64_t v514 = v513 | v492;
  unint64_t v515 = v513 & v492;
  unint64_t v516 = v513 + v492;
  unint64_t v517 = ((v514 & ~v516 | v515) >> 63) + (v493 >> 63);
  unint64_t v518 = HIDWORD(v495);
  LODWORD(v514) = v495;
  unint64_t v519 = a3[2];
  unint64_t v520 = a3[3];
  unint64_t v521 = HIDWORD(v519);
  LODWORD(v507) = v519;
  unint64_t v522 = v519 * (unint64_t)v495;
  unint64_t v523 = v519 * (unint64_t)v518;
  unint64_t v524 = HIDWORD(v523) + v521 * (unint64_t)v518;
  unint64_t v525 = v522 | (v523 << 32);
  unint64_t v526 = v522 & (v523 << 32);
  unint64_t v527 = (v523 << 32) + v507 * (unint64_t)v514;
  unint64_t v528 = v525 & ~v527 | v526;
  unint64_t v529 = v521 * (unint64_t)v514;
  unint64_t v530 = v527 | (v529 << 32);
  unint64_t v531 = v527 & (v529 << 32);
  unint64_t v532 = v527 + (v529 << 32);
  unint64_t v533 = v524 + HIDWORD(v529) + (v528 >> 63) + ((v530 & ~v532 | v531) >> 63);
  unint64_t v534 = v512 | v532;
  unint64_t v535 = v512 & v532;
  uint64_t v536 = v512 + v532;
  unint64_t v537 = v533 + ((v534 & ~v536 | v535) >> 63);
  unint64_t v538 = v537 | v516;
  unint64_t v539 = v537 & v516;
  uint64_t v540 = v537 + v516;
  unint64_t v541 = v517 + ((v538 & ~v540 | v539) >> 63);
  unint64_t v543 = a2[2];
  unint64_t v542 = a2[3];
  unint64_t v544 = HIDWORD(v542);
  LODWORD(v532) = v542;
  unint64_t v545 = HIDWORD(v520);
  LODWORD(v531) = v520;
  unint64_t v546 = v520 * (unint64_t)v542;
  unint64_t v547 = v520 * (unint64_t)v544;
  unint64_t v548 = HIDWORD(v547) + v545 * (unint64_t)v544;
  unint64_t v549 = v546 | (v547 << 32);
  unint64_t v550 = v546 & (v547 << 32);
  unint64_t v551 = (v547 << 32) + v531 * (unint64_t)v532;
  unint64_t v552 = v549 & ~v551 | v550;
  unint64_t v553 = v545 * (unint64_t)v532;
  unint64_t v554 = v551 | (v553 << 32);
  unint64_t v555 = v551 & (v553 << 32);
  unint64_t v556 = v551 + (v553 << 32);
  unint64_t v557 = v548 + HIDWORD(v553) + (v552 >> 63) + ((v554 & ~v556 | v555) >> 63);
  unint64_t v558 = v556 | v536;
  unint64_t v559 = v556 & v536;
  uint64_t v560 = v556 + v536;
  unint64_t v561 = v557 + ((v558 & ~v560 | v559) >> 63);
  unint64_t v562 = v561 | v540;
  unint64_t v563 = v561 & v540;
  uint64_t v564 = v561 + v540;
  unint64_t v565 = v541 + ((v562 & ~v564 | v563) >> 63);
  unint64_t v566 = HIDWORD(v543);
  LODWORD(v562) = v543;
  unint64_t v567 = a3[4];
  unint64_t v568 = a3[5];
  unint64_t v569 = HIDWORD(v567);
  LODWORD(v555) = v567;
  unint64_t v570 = v567 * (unint64_t)v543;
  unint64_t v571 = v567 * (unint64_t)v566;
  unint64_t v572 = HIDWORD(v571) + v569 * (unint64_t)v566;
  unint64_t v573 = v570 | (v571 << 32);
  unint64_t v574 = v570 & (v571 << 32);
  unint64_t v575 = (v571 << 32) + v555 * (unint64_t)v562;
  unint64_t v576 = v573 & ~v575 | v574;
  unint64_t v577 = v569 * (unint64_t)v562;
  unint64_t v578 = v575 | (v577 << 32);
  unint64_t v579 = v575 & (v577 << 32);
  unint64_t v580 = v575 + (v577 << 32);
  unint64_t v581 = v572 + HIDWORD(v577) + (v576 >> 63) + ((v578 & ~v580 | v579) >> 63);
  unint64_t v582 = v580 | v560;
  unint64_t v583 = v580 & v560;
  uint64_t v584 = v580 + v560;
  unint64_t v585 = v581 + ((v582 & ~v584 | v583) >> 63);
  unint64_t v586 = v585 | v564;
  unint64_t v587 = v585 & v564;
  uint64_t v588 = v585 + v564;
  unint64_t v589 = v565 + ((v586 & ~v588 | v587) >> 63);
  unint64_t v590 = a2[1];
  unint64_t v591 = HIDWORD(v590);
  LODWORD(v580) = v590;
  unint64_t v592 = HIDWORD(v568);
  LODWORD(v579) = v568;
  unint64_t v593 = v568 * (unint64_t)v590;
  unint64_t v594 = v568 * (unint64_t)v591;
  unint64_t v595 = HIDWORD(v594) + v592 * (unint64_t)v591;
  unint64_t v596 = v593 | (v594 << 32);
  unint64_t v597 = v593 & (v594 << 32);
  unint64_t v598 = (v594 << 32) + v579 * (unint64_t)v580;
  unint64_t v599 = v596 & ~v598 | v597;
  unint64_t v600 = v592 * (unint64_t)v580;
  unint64_t v601 = v598 | (v600 << 32);
  unint64_t v602 = v598 & (v600 << 32);
  unint64_t v603 = v598 + (v600 << 32);
  unint64_t v604 = v595 + HIDWORD(v600) + (v599 >> 63) + ((v601 & ~v603 | v602) >> 63);
  unint64_t v605 = v603 | v584;
  unint64_t v606 = v603 & v584;
  uint64_t v607 = v603 + v584;
  unint64_t v608 = v604 + ((v605 & ~v607 | v606) >> 63);
  unint64_t v609 = v608 | v588;
  unint64_t v610 = v608 & v588;
  uint64_t v611 = v608 + v588;
  unint64_t v612 = v589 + ((v609 & ~v611 | v610) >> 63);
  unint64_t v613 = a3[6];
  uint64_t v614 = HIDWORD(*a2);
  LODWORD(v610) = *a2;
  unint64_t v615 = HIDWORD(v613);
  LODWORD(v601) = v613;
  unint64_t v616 = v613 * (unint64_t)v610;
  unint64_t v617 = v601 * (unint64_t)v614;
  unint64_t v618 = HIDWORD(v617) + v615 * (unint64_t)v614;
  unint64_t v619 = v616 | (v617 << 32);
  unint64_t v620 = v616 & (v617 << 32);
  unint64_t v621 = (v617 << 32) + v601 * (unint64_t)v610;
  unint64_t v622 = v619 & ~v621 | v620;
  unint64_t v623 = v615 * (unint64_t)v610;
  unint64_t v624 = v621 | (v623 << 32);
  unint64_t v625 = v621 & (v623 << 32);
  unint64_t v626 = v621 + (v623 << 32);
  unint64_t v627 = v618 + HIDWORD(v623) + (v622 >> 63) + ((v624 & ~v626 | v625) >> 63);
  unint64_t v628 = v626 | v607;
  unint64_t v629 = v626 & v607;
  unint64_t v630 = v626 + v607;
  unint64_t v631 = v627 + ((v628 & ~v630 | v629) >> 63);
  unint64_t v632 = v631 | v611;
  unint64_t v633 = v631 & v611;
  uint64_t v634 = v631 + v611;
  unint64_t v635 = v612 + ((v632 & ~v634 | v633) >> 63);
  result[6] = v630;
  unint64_t v636 = a2[1];
  uint64_t v637 = HIDWORD(*a2);
  LODWORD(v633) = *a2;
  unint64_t v639 = a3[6];
  unint64_t v638 = a3[7];
  unint64_t v640 = HIDWORD(v638);
  LODWORD(v602) = v638;
  unint64_t v641 = v638 * (unint64_t)v633;
  unint64_t v642 = v638 * (unint64_t)v637;
  unint64_t v643 = HIDWORD(v642) + v640 * (unint64_t)v637;
  unint64_t v644 = v641 | (v642 << 32);
  unint64_t v645 = v641 & (v642 << 32);
  unint64_t v646 = (v642 << 32) + v602 * (unint64_t)v633;
  unint64_t v647 = v644 & ~v646 | v645;
  unint64_t v648 = v640 * (unint64_t)v633;
  unint64_t v649 = v646 | (v648 << 32);
  unint64_t v650 = v646 & (v648 << 32);
  unint64_t v651 = v646 + (v648 << 32);
  unint64_t v652 = v643 + HIDWORD(v648) + (v647 >> 63) + ((v649 & ~v651 | v650) >> 63);
  unint64_t v653 = v634 | v651;
  unint64_t v654 = v634 & v651;
  uint64_t v655 = v634 + v651;
  unint64_t v656 = v652 + ((v653 & ~v655 | v654) >> 63);
  unint64_t v657 = v656 | v635;
  unint64_t v658 = v656 & v635;
  unint64_t v659 = v656 + v635;
  unint64_t v660 = v657 & ~v659 | v658;
  unint64_t v661 = HIDWORD(v636);
  LODWORD(v658) = v636;
  unint64_t v662 = HIDWORD(v639);
  LODWORD(v649) = v639;
  unint64_t v663 = v639 * (unint64_t)v636;
  unint64_t v664 = v639 * (unint64_t)v661;
  unint64_t v665 = HIDWORD(v664) + v662 * (unint64_t)v661;
  unint64_t v666 = v663 | (v664 << 32);
  unint64_t v667 = v663 & (v664 << 32);
  unint64_t v668 = (v664 << 32) + v649 * (unint64_t)v658;
  unint64_t v669 = v666 & ~v668 | v667;
  unint64_t v670 = v662 * (unint64_t)v658;
  unint64_t v671 = v668 | (v670 << 32);
  unint64_t v672 = v668 & (v670 << 32);
  unint64_t v673 = v668 + (v670 << 32);
  unint64_t v674 = v665 + HIDWORD(v670) + (v669 >> 63) + ((v671 & ~v673 | v672) >> 63);
  unint64_t v675 = v655 | v673;
  unint64_t v676 = v655 & v673;
  uint64_t v677 = v655 + v673;
  unint64_t v678 = v674 + ((v675 & ~v677 | v676) >> 63);
  unint64_t v679 = v678 | v659;
  unint64_t v680 = v678 & v659;
  uint64_t v681 = v678 + v659;
  unint64_t v682 = ((v679 & ~v681 | v680) >> 63) + (v660 >> 63);
  unint64_t v683 = a2[2];
  unint64_t v684 = a2[3];
  unint64_t v685 = HIDWORD(v683);
  LODWORD(v671) = v683;
  unint64_t v687 = a3[4];
  unint64_t v686 = a3[5];
  unint64_t v688 = HIDWORD(v686);
  LODWORD(v666) = v686;
  unint64_t v689 = v686 * (unint64_t)v683;
  unint64_t v690 = v686 * (unint64_t)v685;
  unint64_t v691 = HIDWORD(v690) + v688 * (unint64_t)v685;
  unint64_t v692 = v689 | (v690 << 32);
  unint64_t v693 = v689 & (v690 << 32);
  unint64_t v694 = (v690 << 32) + v666 * (unint64_t)v671;
  unint64_t v695 = v692 & ~v694 | v693;
  unint64_t v696 = v688 * (unint64_t)v671;
  unint64_t v697 = v694 | (v696 << 32);
  unint64_t v698 = v694 & (v696 << 32);
  unint64_t v699 = v694 + (v696 << 32);
  unint64_t v700 = v691 + HIDWORD(v696) + (v695 >> 63) + ((v697 & ~v699 | v698) >> 63);
  unint64_t v701 = v677 | v699;
  unint64_t v702 = v677 & v699;
  uint64_t v703 = v677 + v699;
  unint64_t v704 = v700 + ((v701 & ~v703 | v702) >> 63);
  unint64_t v705 = v704 | v681;
  unint64_t v706 = v704 & v681;
  uint64_t v707 = v704 + v681;
  unint64_t v708 = v682 + ((v705 & ~v707 | v706) >> 63);
  unint64_t v709 = HIDWORD(v684);
  LODWORD(v705) = v684;
  unint64_t v710 = HIDWORD(v687);
  LODWORD(v699) = v687;
  unint64_t v711 = v687 * (unint64_t)v684;
  unint64_t v712 = v687 * (unint64_t)v709;
  unint64_t v713 = HIDWORD(v712) + v710 * (unint64_t)v709;
  unint64_t v714 = (v712 << 32) + v699 * (unint64_t)v705;
  unint64_t v715 = (v711 | (v712 << 32)) & ~v714 | v711 & (v712 << 32);
  unint64_t v716 = v710 * (unint64_t)v705;
  unint64_t v717 = v714 | (v716 << 32);
  unint64_t v718 = v714 & (v716 << 32);
  unint64_t v719 = v714 + (v716 << 32);
  unint64_t v720 = v713 + HIDWORD(v716) + (v715 >> 63) + ((v717 & ~v719 | v718) >> 63);
  unint64_t v721 = v719 | v703;
  unint64_t v722 = v719 & v703;
  uint64_t v723 = v719 + v703;
  unint64_t v724 = v720 + ((v721 & ~v723 | v722) >> 63);
  unint64_t v725 = v724 | v707;
  unint64_t v726 = v724 & v707;
  uint64_t v727 = v724 + v707;
  unint64_t v728 = v708 + ((v725 & ~v727 | v726) >> 63);
  unint64_t v729 = a2[4];
  unint64_t v730 = a2[5];
  unint64_t v731 = HIDWORD(v729);
  LODWORD(v717) = v729;
  unint64_t v733 = a3[2];
  unint64_t v732 = a3[3];
  unint64_t v734 = HIDWORD(v732);
  LODWORD(v698) = v732;
  unint64_t v735 = v732 * (unint64_t)v729;
  unint64_t v736 = v732 * (unint64_t)v731;
  unint64_t v737 = HIDWORD(v736) + v734 * (unint64_t)v731;
  unint64_t v738 = v735 | (v736 << 32);
  unint64_t v739 = v735 & (v736 << 32);
  unint64_t v740 = (v736 << 32) + v698 * (unint64_t)v717;
  unint64_t v741 = v738 & ~v740 | v739;
  unint64_t v742 = v734 * (unint64_t)v717;
  unint64_t v743 = v740 | (v742 << 32);
  unint64_t v744 = v740 & (v742 << 32);
  unint64_t v745 = v740 + (v742 << 32);
  unint64_t v746 = v737 + HIDWORD(v742) + (v741 >> 63) + ((v743 & ~v745 | v744) >> 63);
  unint64_t v747 = v745 | v723;
  unint64_t v748 = v745 & v723;
  uint64_t v749 = v745 + v723;
  unint64_t v750 = v746 + ((v747 & ~v749 | v748) >> 63);
  unint64_t v751 = v750 | v727;
  unint64_t v752 = v750 & v727;
  uint64_t v753 = v750 + v727;
  unint64_t v754 = v728 + ((v751 & ~v753 | v752) >> 63);
  unint64_t v755 = HIDWORD(v730);
  LODWORD(v751) = v730;
  unint64_t v756 = HIDWORD(v733);
  LODWORD(v745) = v733;
  unint64_t v757 = v733 * (unint64_t)v730;
  unint64_t v758 = v733 * (unint64_t)v755;
  unint64_t v759 = HIDWORD(v758) + v756 * (unint64_t)v755;
  unint64_t v760 = (v758 << 32) + v745 * (unint64_t)v751;
  unint64_t v761 = (v757 | (v758 << 32)) & ~v760 | v757 & (v758 << 32);
  unint64_t v762 = v756 * (unint64_t)v751;
  unint64_t v763 = v760 | (v762 << 32);
  unint64_t v764 = v760 & (v762 << 32);
  unint64_t v765 = v760 + (v762 << 32);
  unint64_t v766 = v759 + HIDWORD(v762) + (v761 >> 63) + ((v763 & ~v765 | v764) >> 63);
  unint64_t v767 = v765 | v749;
  unint64_t v768 = v765 & v749;
  uint64_t v769 = v765 + v749;
  unint64_t v770 = v766 + ((v767 & ~v769 | v768) >> 63);
  unint64_t v771 = v770 | v753;
  unint64_t v772 = v770 & v753;
  uint64_t v773 = v770 + v753;
  unint64_t v774 = v754 + ((v771 & ~v773 | v772) >> 63);
  unint64_t v775 = a2[6];
  unint64_t v776 = a2[7];
  unint64_t v777 = HIDWORD(v775);
  LODWORD(v763) = v775;
  unint64_t v778 = a3[1];
  unint64_t v779 = HIDWORD(v778);
  LODWORD(v744) = v778;
  unint64_t v780 = v778 * (unint64_t)v775;
  unint64_t v781 = v778 * (unint64_t)v777;
  unint64_t v782 = HIDWORD(v781) + v779 * (unint64_t)v777;
  unint64_t v783 = v780 | (v781 << 32);
  unint64_t v784 = v780 & (v781 << 32);
  unint64_t v785 = (v781 << 32) + v744 * (unint64_t)v763;
  unint64_t v786 = v783 & ~v785 | v784;
  unint64_t v787 = v779 * (unint64_t)v763;
  unint64_t v788 = v785 | (v787 << 32);
  unint64_t v789 = v785 & (v787 << 32);
  unint64_t v790 = v785 + (v787 << 32);
  unint64_t v791 = v782 + HIDWORD(v787) + (v786 >> 63) + ((v788 & ~v790 | v789) >> 63);
  unint64_t v792 = v790 | v769;
  unint64_t v793 = v790 & v769;
  uint64_t v794 = v790 + v769;
  unint64_t v795 = v791 + ((v792 & ~v794 | v793) >> 63);
  unint64_t v796 = v795 | v773;
  unint64_t v797 = v795 & v773;
  uint64_t v798 = v795 + v773;
  unint64_t v799 = v774 + ((v796 & ~v798 | v797) >> 63);
  unint64_t v800 = HIDWORD(v776);
  LODWORD(v796) = v776;
  uint64_t v801 = HIDWORD(*a3);
  LODWORD(v790) = *a3;
  unint64_t v802 = v790 * (unint64_t)v776;
  unint64_t v803 = v790 * (unint64_t)v800;
  unint64_t v804 = HIDWORD(v803) + v801 * (unint64_t)v800;
  unint64_t v805 = (v803 << 32) + v790 * (unint64_t)v796;
  unint64_t v806 = (v802 | (v803 << 32)) & ~v805 | v802 & (v803 << 32);
  unint64_t v807 = v801 * (unint64_t)v796;
  unint64_t v808 = v805 | (v807 << 32);
  unint64_t v809 = v805 & (v807 << 32);
  unint64_t v810 = v805 + (v807 << 32);
  unint64_t v811 = v804 + HIDWORD(v807) + (v806 >> 63) + ((v808 & ~v810 | v809) >> 63);
  unint64_t v812 = v810 + v794;
  unint64_t v813 = v811 + (((v810 | v794) & ~(v810 + v794) | v810 & v794) >> 63);
  unint64_t v814 = v813 | v798;
  unint64_t v815 = v813 & v798;
  uint64_t v816 = v813 + v798;
  unint64_t v817 = v799 + ((v814 & ~v816 | v815) >> 63);
  result[7] = v812;
  unint64_t v818 = a2[7];
  unint64_t v819 = HIDWORD(v818);
  LODWORD(v815) = v818;
  unint64_t v820 = a3[1];
  unint64_t v821 = a3[2];
  unint64_t v822 = HIDWORD(v820);
  LODWORD(v809) = v820;
  unint64_t v823 = v820 * (unint64_t)v818;
  unint64_t v824 = v820 * (unint64_t)v819;
  unint64_t v825 = HIDWORD(v824) + v822 * (unint64_t)v819;
  unint64_t v826 = v823 | (v824 << 32);
  unint64_t v827 = v823 & (v824 << 32);
  unint64_t v828 = (v824 << 32) + v809 * (unint64_t)v815;
  unint64_t v829 = v826 & ~v828 | v827;
  unint64_t v830 = v822 * (unint64_t)v815;
  unint64_t v831 = v828 | (v830 << 32);
  unint64_t v832 = v828 & (v830 << 32);
  unint64_t v833 = v828 + (v830 << 32);
  unint64_t v834 = v825 + HIDWORD(v830) + (v829 >> 63) + ((v831 & ~v833 | v832) >> 63);
  unint64_t v835 = v816 | v833;
  unint64_t v836 = v816 & v833;
  uint64_t v837 = v816 + v833;
  unint64_t v838 = v834 + ((v835 & ~v837 | v836) >> 63);
  unint64_t v839 = v838 | v817;
  unint64_t v840 = v838 & v817;
  uint64_t v841 = v838 + v817;
  unint64_t v842 = v839 & ~v841 | v840;
  unint64_t v844 = a2[5];
  unint64_t v843 = a2[6];
  unint64_t v845 = HIDWORD(v843);
  LODWORD(v831) = v843;
  unint64_t v846 = HIDWORD(v821);
  LODWORD(v788) = v821;
  unint64_t v847 = v821 * (unint64_t)v843;
  unint64_t v848 = v821 * (unint64_t)v845;
  unint64_t v849 = HIDWORD(v848) + v846 * (unint64_t)v845;
  unint64_t v850 = v847 | (v848 << 32);
  unint64_t v851 = v847 & (v848 << 32);
  unint64_t v852 = (v848 << 32) + v788 * (unint64_t)v831;
  unint64_t v853 = v850 & ~v852 | v851;
  unint64_t v854 = v846 * (unint64_t)v831;
  unint64_t v855 = v852 | (v854 << 32);
  unint64_t v856 = v852 & (v854 << 32);
  unint64_t v857 = v852 + (v854 << 32);
  unint64_t v858 = v849 + HIDWORD(v854) + (v853 >> 63) + ((v855 & ~v857 | v856) >> 63);
  unint64_t v859 = v837 | v857;
  unint64_t v860 = v837 & v857;
  uint64_t v861 = v837 + v857;
  unint64_t v862 = v858 + ((v859 & ~v861 | v860) >> 63);
  unint64_t v863 = v862 | v841;
  unint64_t v864 = v862 & v841;
  uint64_t v865 = v862 + v841;
  unint64_t v866 = ((v863 & ~v865 | v864) >> 63) + (v842 >> 63);
  unint64_t v867 = HIDWORD(v844);
  LODWORD(v863) = v844;
  unint64_t v868 = a3[3];
  unint64_t v869 = a3[4];
  unint64_t v870 = HIDWORD(v868);
  LODWORD(v856) = v868;
  unint64_t v871 = v868 * (unint64_t)v844;
  unint64_t v872 = v868 * (unint64_t)v867;
  unint64_t v873 = HIDWORD(v872) + v870 * (unint64_t)v867;
  unint64_t v874 = v871 | (v872 << 32);
  unint64_t v875 = v871 & (v872 << 32);
  unint64_t v876 = (v872 << 32) + v856 * (unint64_t)v863;
  unint64_t v877 = v874 & ~v876 | v875;
  unint64_t v878 = v870 * (unint64_t)v863;
  unint64_t v879 = v876 | (v878 << 32);
  unint64_t v880 = v876 & (v878 << 32);
  unint64_t v881 = v876 + (v878 << 32);
  unint64_t v882 = v873 + HIDWORD(v878) + (v877 >> 63) + ((v879 & ~v881 | v880) >> 63);
  unint64_t v883 = v861 | v881;
  unint64_t v884 = v861 & v881;
  uint64_t v885 = v861 + v881;
  unint64_t v886 = v882 + ((v883 & ~v885 | v884) >> 63);
  unint64_t v887 = v886 | v865;
  unint64_t v888 = v886 & v865;
  uint64_t v889 = v886 + v865;
  unint64_t v890 = v866 + ((v887 & ~v889 | v888) >> 63);
  unint64_t v892 = a2[3];
  unint64_t v891 = a2[4];
  unint64_t v893 = HIDWORD(v891);
  LODWORD(v881) = v891;
  unint64_t v894 = HIDWORD(v869);
  LODWORD(v880) = v869;
  unint64_t v895 = v869 * (unint64_t)v891;
  unint64_t v896 = v869 * (unint64_t)v893;
  unint64_t v897 = HIDWORD(v896) + v894 * (unint64_t)v893;
  unint64_t v898 = v895 | (v896 << 32);
  unint64_t v899 = v895 & (v896 << 32);
  unint64_t v900 = (v896 << 32) + v880 * (unint64_t)v881;
  unint64_t v901 = v898 & ~v900 | v899;
  unint64_t v902 = v894 * (unint64_t)v881;
  unint64_t v903 = v900 | (v902 << 32);
  unint64_t v904 = v900 & (v902 << 32);
  unint64_t v905 = v900 + (v902 << 32);
  unint64_t v906 = v897 + HIDWORD(v902) + (v901 >> 63) + ((v903 & ~v905 | v904) >> 63);
  unint64_t v907 = v905 | v885;
  unint64_t v908 = v905 & v885;
  uint64_t v909 = v905 + v885;
  unint64_t v910 = v906 + ((v907 & ~v909 | v908) >> 63);
  unint64_t v911 = v910 | v889;
  unint64_t v912 = v910 & v889;
  uint64_t v913 = v910 + v889;
  unint64_t v914 = v890 + ((v911 & ~v913 | v912) >> 63);
  unint64_t v915 = HIDWORD(v892);
  LODWORD(v911) = v892;
  unint64_t v916 = a3[5];
  unint64_t v917 = a3[6];
  unint64_t v918 = HIDWORD(v916);
  LODWORD(v904) = v916;
  unint64_t v919 = v916 * (unint64_t)v892;
  unint64_t v920 = v916 * (unint64_t)v915;
  unint64_t v921 = HIDWORD(v920) + v918 * (unint64_t)v915;
  unint64_t v922 = v919 | (v920 << 32);
  unint64_t v923 = v919 & (v920 << 32);
  unint64_t v924 = (v920 << 32) + v904 * (unint64_t)v911;
  unint64_t v925 = v922 & ~v924 | v923;
  unint64_t v926 = v918 * (unint64_t)v911;
  unint64_t v927 = v924 | (v926 << 32);
  unint64_t v928 = v924 & (v926 << 32);
  unint64_t v929 = v924 + (v926 << 32);
  unint64_t v930 = v921 + HIDWORD(v926) + (v925 >> 63) + ((v927 & ~v929 | v928) >> 63);
  unint64_t v931 = v929 | v909;
  unint64_t v932 = v929 & v909;
  uint64_t v933 = v929 + v909;
  unint64_t v934 = v930 + ((v931 & ~v933 | v932) >> 63);
  unint64_t v935 = v934 | v913;
  unint64_t v936 = v934 & v913;
  uint64_t v937 = v934 + v913;
  unint64_t v938 = v914 + ((v935 & ~v937 | v936) >> 63);
  unint64_t v940 = a2[1];
  unint64_t v939 = a2[2];
  unint64_t v941 = HIDWORD(v939);
  LODWORD(v929) = v939;
  unint64_t v942 = HIDWORD(v917);
  LODWORD(v928) = v917;
  unint64_t v943 = v917 * (unint64_t)v939;
  unint64_t v944 = v917 * (unint64_t)v941;
  unint64_t v945 = HIDWORD(v944) + v942 * (unint64_t)v941;
  unint64_t v946 = v943 | (v944 << 32);
  unint64_t v947 = v943 & (v944 << 32);
  unint64_t v948 = (v944 << 32) + v928 * (unint64_t)v929;
  unint64_t v949 = v946 & ~v948 | v947;
  unint64_t v950 = v942 * (unint64_t)v929;
  unint64_t v951 = v948 | (v950 << 32);
  unint64_t v952 = v948 & (v950 << 32);
  unint64_t v953 = v948 + (v950 << 32);
  unint64_t v954 = v945 + HIDWORD(v950) + (v949 >> 63) + ((v951 & ~v953 | v952) >> 63);
  unint64_t v955 = v953 | v933;
  unint64_t v956 = v953 & v933;
  uint64_t v957 = v953 + v933;
  unint64_t v958 = v954 + ((v955 & ~v957 | v956) >> 63);
  unint64_t v959 = v958 | v937;
  unint64_t v960 = v958 & v937;
  uint64_t v961 = v958 + v937;
  unint64_t v962 = v938 + ((v959 & ~v961 | v960) >> 63);
  unint64_t v963 = a3[7];
  unint64_t v964 = HIDWORD(v940);
  LODWORD(v960) = v940;
  unint64_t v965 = HIDWORD(v963);
  LODWORD(v951) = v963;
  unint64_t v966 = v963 * (unint64_t)v940;
  unint64_t v967 = v951 * (unint64_t)HIDWORD(v940);
  unint64_t v968 = HIDWORD(v967) + v965 * (unint64_t)v964;
  unint64_t v969 = v966 | (v967 << 32);
  unint64_t v970 = v966 & (v967 << 32);
  unint64_t v971 = (v967 << 32) + v951 * (unint64_t)v960;
  unint64_t v972 = v969 & ~v971 | v970;
  unint64_t v973 = v965 * (unint64_t)v960;
  unint64_t v974 = v971 | (v973 << 32);
  unint64_t v975 = v971 & (v973 << 32);
  unint64_t v976 = v971 + (v973 << 32);
  unint64_t v977 = v968 + HIDWORD(v973) + (v972 >> 63) + ((v974 & ~v976 | v975) >> 63);
  unint64_t v978 = v976 | v957;
  unint64_t v979 = v976 & v957;
  unint64_t v980 = v976 + v957;
  unint64_t v981 = v977 + ((v978 & ~v980 | v979) >> 63);
  unint64_t v982 = v981 | v961;
  unint64_t v983 = v981 & v961;
  uint64_t v984 = v981 + v961;
  unint64_t v985 = v962 + ((v982 & ~v984 | v983) >> 63);
  result[8] = v980;
  unint64_t v986 = a2[2];
  unint64_t v987 = a2[3];
  unint64_t v988 = HIDWORD(v986);
  LODWORD(v983) = v986;
  unint64_t v990 = a3[6];
  unint64_t v989 = a3[7];
  unint64_t v991 = HIDWORD(v989);
  LODWORD(v952) = v989;
  unint64_t v992 = v989 * (unint64_t)v986;
  unint64_t v993 = v989 * (unint64_t)v988;
  unint64_t v994 = HIDWORD(v993) + v991 * (unint64_t)v988;
  unint64_t v995 = v992 | (v993 << 32);
  unint64_t v996 = v992 & (v993 << 32);
  unint64_t v997 = (v993 << 32) + v952 * (unint64_t)v983;
  unint64_t v998 = v995 & ~v997 | v996;
  unint64_t v999 = v991 * (unint64_t)v983;
  unint64_t v1000 = v997 | (v999 << 32);
  unint64_t v1001 = v997 & (v999 << 32);
  unint64_t v1002 = v997 + (v999 << 32);
  unint64_t v1003 = v994 + HIDWORD(v999) + (v998 >> 63) + ((v1000 & ~v1002 | v1001) >> 63);
  unint64_t v1004 = v984 | v1002;
  unint64_t v1005 = v984 & v1002;
  uint64_t v1006 = v984 + v1002;
  unint64_t v1007 = v1003 + ((v1004 & ~v1006 | v1005) >> 63);
  unint64_t v1008 = v1007 | v985;
  unint64_t v1009 = v1007 & v985;
  unint64_t v1010 = v1007 + v985;
  unint64_t v1011 = v1008 & ~v1010 | v1009;
  unint64_t v1012 = HIDWORD(v987);
  LODWORD(v1009) = v987;
  unint64_t v1013 = HIDWORD(v990);
  LODWORD(v1000) = v990;
  unint64_t v1014 = v990 * (unint64_t)v987;
  unint64_t v1015 = v990 * (unint64_t)v1012;
  unint64_t v1016 = HIDWORD(v1015) + v1013 * (unint64_t)v1012;
  unint64_t v1017 = v1014 | (v1015 << 32);
  unint64_t v1018 = v1014 & (v1015 << 32);
  unint64_t v1019 = (v1015 << 32) + v1000 * (unint64_t)v1009;
  unint64_t v1020 = v1017 & ~v1019 | v1018;
  unint64_t v1021 = v1013 * (unint64_t)v1009;
  unint64_t v1022 = v1019 | (v1021 << 32);
  unint64_t v1023 = v1019 & (v1021 << 32);
  unint64_t v1024 = v1019 + (v1021 << 32);
  unint64_t v1025 = v1016 + HIDWORD(v1021) + (v1020 >> 63) + ((v1022 & ~v1024 | v1023) >> 63);
  unint64_t v1026 = v1006 | v1024;
  unint64_t v1027 = v1006 & v1024;
  uint64_t v1028 = v1006 + v1024;
  unint64_t v1029 = v1025 + ((v1026 & ~v1028 | v1027) >> 63);
  unint64_t v1030 = v1029 | v1010;
  unint64_t v1031 = v1029 & v1010;
  uint64_t v1032 = v1029 + v1010;
  unint64_t v1033 = ((v1030 & ~v1032 | v1031) >> 63) + (v1011 >> 63);
  unint64_t v1034 = a2[4];
  unint64_t v1035 = a2[5];
  unint64_t v1036 = HIDWORD(v1034);
  LODWORD(v1022) = v1034;
  unint64_t v1038 = a3[4];
  unint64_t v1037 = a3[5];
  unint64_t v1039 = HIDWORD(v1037);
  LODWORD(v1017) = v1037;
  unint64_t v1040 = v1037 * (unint64_t)v1034;
  unint64_t v1041 = v1037 * (unint64_t)v1036;
  unint64_t v1042 = HIDWORD(v1041) + v1039 * (unint64_t)v1036;
  unint64_t v1043 = v1040 | (v1041 << 32);
  unint64_t v1044 = v1040 & (v1041 << 32);
  unint64_t v1045 = (v1041 << 32) + v1017 * (unint64_t)v1022;
  unint64_t v1046 = v1043 & ~v1045 | v1044;
  unint64_t v1047 = v1039 * (unint64_t)v1022;
  unint64_t v1048 = v1045 | (v1047 << 32);
  unint64_t v1049 = v1045 & (v1047 << 32);
  unint64_t v1050 = v1045 + (v1047 << 32);
  unint64_t v1051 = v1042 + HIDWORD(v1047) + (v1046 >> 63) + ((v1048 & ~v1050 | v1049) >> 63);
  unint64_t v1052 = v1028 | v1050;
  unint64_t v1053 = v1028 & v1050;
  uint64_t v1054 = v1028 + v1050;
  unint64_t v1055 = v1051 + ((v1052 & ~v1054 | v1053) >> 63);
  unint64_t v1056 = v1055 | v1032;
  unint64_t v1057 = v1055 & v1032;
  uint64_t v1058 = v1055 + v1032;
  unint64_t v1059 = v1033 + ((v1056 & ~v1058 | v1057) >> 63);
  unint64_t v1060 = HIDWORD(v1035);
  LODWORD(v1056) = v1035;
  unint64_t v1061 = HIDWORD(v1038);
  LODWORD(v1050) = v1038;
  unint64_t v1062 = v1038 * (unint64_t)v1035;
  unint64_t v1063 = v1038 * (unint64_t)v1060;
  unint64_t v1064 = HIDWORD(v1063) + v1061 * (unint64_t)v1060;
  unint64_t v1065 = (v1063 << 32) + v1050 * (unint64_t)v1056;
  unint64_t v1066 = (v1062 | (v1063 << 32)) & ~v1065 | v1062 & (v1063 << 32);
  unint64_t v1067 = v1061 * (unint64_t)v1056;
  unint64_t v1068 = v1065 | (v1067 << 32);
  unint64_t v1069 = v1065 & (v1067 << 32);
  unint64_t v1070 = v1065 + (v1067 << 32);
  unint64_t v1071 = v1064 + HIDWORD(v1067) + (v1066 >> 63) + ((v1068 & ~v1070 | v1069) >> 63);
  unint64_t v1072 = v1070 | v1054;
  unint64_t v1073 = v1070 & v1054;
  uint64_t v1074 = v1070 + v1054;
  unint64_t v1075 = v1071 + ((v1072 & ~v1074 | v1073) >> 63);
  unint64_t v1076 = v1075 | v1058;
  unint64_t v1077 = v1075 & v1058;
  uint64_t v1078 = v1075 + v1058;
  unint64_t v1079 = v1059 + ((v1076 & ~v1078 | v1077) >> 63);
  unint64_t v1080 = a2[6];
  unint64_t v1081 = a2[7];
  unint64_t v1082 = HIDWORD(v1080);
  LODWORD(v1068) = v1080;
  unint64_t v1084 = a3[2];
  unint64_t v1083 = a3[3];
  unint64_t v1085 = HIDWORD(v1083);
  LODWORD(v1049) = v1083;
  unint64_t v1086 = v1083 * (unint64_t)v1080;
  unint64_t v1087 = v1083 * (unint64_t)v1082;
  unint64_t v1088 = HIDWORD(v1087) + v1085 * (unint64_t)v1082;
  unint64_t v1089 = v1086 | (v1087 << 32);
  unint64_t v1090 = v1086 & (v1087 << 32);
  unint64_t v1091 = (v1087 << 32) + v1049 * (unint64_t)v1068;
  unint64_t v1092 = v1089 & ~v1091 | v1090;
  unint64_t v1093 = v1085 * (unint64_t)v1068;
  unint64_t v1094 = v1091 | (v1093 << 32);
  unint64_t v1095 = v1091 & (v1093 << 32);
  unint64_t v1096 = v1091 + (v1093 << 32);
  unint64_t v1097 = v1088 + HIDWORD(v1093) + (v1092 >> 63) + ((v1094 & ~v1096 | v1095) >> 63);
  unint64_t v1098 = v1096 | v1074;
  unint64_t v1099 = v1096 & v1074;
  uint64_t v1100 = v1096 + v1074;
  unint64_t v1101 = v1097 + ((v1098 & ~v1100 | v1099) >> 63);
  unint64_t v1102 = v1101 | v1078;
  unint64_t v1103 = v1101 & v1078;
  uint64_t v1104 = v1101 + v1078;
  unint64_t v1105 = v1079 + ((v1102 & ~v1104 | v1103) >> 63);
  unint64_t v1106 = HIDWORD(v1081);
  LODWORD(v1102) = v1081;
  unint64_t v1107 = HIDWORD(v1084);
  LODWORD(v1096) = v1084;
  unint64_t v1108 = v1084 * (unint64_t)v1081;
  unint64_t v1109 = v1084 * (unint64_t)v1106;
  unint64_t v1110 = HIDWORD(v1109) + v1107 * (unint64_t)v1106;
  unint64_t v1111 = (v1109 << 32) + v1096 * (unint64_t)v1102;
  unint64_t v1112 = (v1108 | (v1109 << 32)) & ~v1111 | v1108 & (v1109 << 32);
  unint64_t v1113 = v1107 * (unint64_t)v1102;
  unint64_t v1114 = v1111 | (v1113 << 32);
  unint64_t v1115 = v1111 & (v1113 << 32);
  unint64_t v1116 = v1111 + (v1113 << 32);
  unint64_t v1117 = v1110 + HIDWORD(v1113) + (v1112 >> 63) + ((v1114 & ~v1116 | v1115) >> 63);
  unint64_t v1118 = v1116 | v1100;
  unint64_t v1119 = v1116 & v1100;
  unint64_t v1120 = v1116 + v1100;
  unint64_t v1121 = v1117 + ((v1118 & ~v1120 | v1119) >> 63);
  unint64_t v1122 = v1121 | v1104;
  unint64_t v1123 = v1121 & v1104;
  uint64_t v1124 = v1121 + v1104;
  unint64_t v1125 = v1105 + ((v1122 & ~v1124 | v1123) >> 63);
  result[9] = v1120;
  unint64_t v1126 = a2[7];
  unint64_t v1127 = HIDWORD(v1126);
  LODWORD(v1122) = v1126;
  unint64_t v1128 = a3[3];
  unint64_t v1129 = a3[4];
  unint64_t v1130 = HIDWORD(v1128);
  LODWORD(v1115) = v1128;
  unint64_t v1131 = v1128 * (unint64_t)v1126;
  unint64_t v1132 = v1128 * (unint64_t)v1127;
  unint64_t v1133 = HIDWORD(v1132) + v1130 * (unint64_t)v1127;
  unint64_t v1134 = v1131 | (v1132 << 32);
  unint64_t v1135 = v1131 & (v1132 << 32);
  unint64_t v1136 = (v1132 << 32) + v1115 * (unint64_t)v1122;
  unint64_t v1137 = v1134 & ~v1136 | v1135;
  unint64_t v1138 = v1130 * (unint64_t)v1122;
  unint64_t v1139 = v1136 | (v1138 << 32);
  unint64_t v1140 = v1136 & (v1138 << 32);
  unint64_t v1141 = v1136 + (v1138 << 32);
  unint64_t v1142 = v1133 + HIDWORD(v1138) + (v1137 >> 63) + ((v1139 & ~v1141 | v1140) >> 63);
  unint64_t v1143 = v1124 | v1141;
  unint64_t v1144 = v1124 & v1141;
  uint64_t v1145 = v1124 + v1141;
  unint64_t v1146 = v1142 + ((v1143 & ~v1145 | v1144) >> 63);
  unint64_t v1147 = v1146 | v1125;
  unint64_t v1148 = v1146 + v1125;
  unint64_t v1149 = v1147 & ~v1148;
  unint64_t v1151 = a2[5];
  unint64_t v1150 = a2[6];
  unint64_t v1152 = HIDWORD(v1150);
  LODWORD(v1139) = v1150;
  unint64_t v1153 = HIDWORD(v1129);
  LODWORD(v1094) = v1129;
  unint64_t v1154 = v1129 * (unint64_t)v1150;
  unint64_t v1155 = v1129 * (unint64_t)v1152;
  unint64_t v1156 = HIDWORD(v1155) + v1153 * (unint64_t)v1152;
  unint64_t v1157 = v1154 | (v1155 << 32);
  unint64_t v1158 = v1154 & (v1155 << 32);
  unint64_t v1159 = (v1155 << 32) + v1094 * (unint64_t)v1139;
  unint64_t v1160 = v1157 & ~v1159 | v1158;
  unint64_t v1161 = v1153 * (unint64_t)v1139;
  unint64_t v1162 = v1159 | (v1161 << 32);
  unint64_t v1163 = v1159 & (v1161 << 32);
  unint64_t v1164 = v1159 + (v1161 << 32);
  unint64_t v1165 = v1156 + HIDWORD(v1161) + (v1160 >> 63) + ((v1162 & ~v1164 | v1163) >> 63);
  unint64_t v1166 = v1145 | v1164;
  unint64_t v1167 = v1145 & v1164;
  uint64_t v1168 = v1145 + v1164;
  unint64_t v1169 = v1165 + ((v1166 & ~v1168 | v1167) >> 63);
  unint64_t v1170 = v1169 | v1148;
  unint64_t v1171 = v1169 & v1148;
  unint64_t v1172 = v1169 + v1148;
  unint64_t v1173 = ((v1170 & ~v1172 | v1171) >> 63) + (v1149 >> 63);
  unint64_t v1174 = HIDWORD(v1151);
  LODWORD(v1170) = v1151;
  unint64_t v1175 = a3[5];
  unint64_t v1176 = a3[6];
  unint64_t v1177 = HIDWORD(v1175);
  LODWORD(v1163) = v1175;
  unint64_t v1178 = v1175 * (unint64_t)v1151;
  unint64_t v1179 = v1175 * (unint64_t)v1174;
  unint64_t v1180 = HIDWORD(v1179) + v1177 * (unint64_t)v1174;
  unint64_t v1181 = v1178 | (v1179 << 32);
  unint64_t v1182 = v1178 & (v1179 << 32);
  unint64_t v1183 = (v1179 << 32) + v1163 * (unint64_t)v1170;
  unint64_t v1184 = v1181 & ~v1183 | v1182;
  unint64_t v1185 = v1177 * (unint64_t)v1170;
  unint64_t v1186 = v1183 | (v1185 << 32);
  unint64_t v1187 = v1183 & (v1185 << 32);
  unint64_t v1188 = v1183 + (v1185 << 32);
  unint64_t v1189 = v1180 + HIDWORD(v1185) + (v1184 >> 63) + ((v1186 & ~v1188 | v1187) >> 63);
  unint64_t v1190 = v1168 | v1188;
  unint64_t v1191 = v1168 & v1188;
  uint64_t v1192 = v1168 + v1188;
  unint64_t v1193 = v1189 + ((v1190 & ~v1192 | v1191) >> 63);
  unint64_t v1194 = v1193 | v1172;
  unint64_t v1195 = v1193 & v1172;
  uint64_t v1196 = v1193 + v1172;
  unint64_t v1197 = v1173 + ((v1194 & ~v1196 | v1195) >> 63);
  unint64_t v1199 = a2[3];
  unint64_t v1198 = a2[4];
  unint64_t v1200 = HIDWORD(v1198);
  LODWORD(v1188) = v1198;
  unint64_t v1201 = HIDWORD(v1176);
  LODWORD(v1187) = v1176;
  unint64_t v1202 = v1176 * (unint64_t)v1198;
  unint64_t v1203 = v1176 * (unint64_t)v1200;
  unint64_t v1204 = HIDWORD(v1203) + v1201 * (unint64_t)v1200;
  unint64_t v1205 = v1202 | (v1203 << 32);
  unint64_t v1206 = v1202 & (v1203 << 32);
  unint64_t v1207 = (v1203 << 32) + v1187 * (unint64_t)v1188;
  unint64_t v1208 = v1205 & ~v1207 | v1206;
  unint64_t v1209 = v1201 * (unint64_t)v1188;
  unint64_t v1210 = v1207 | (v1209 << 32);
  unint64_t v1211 = v1207 & (v1209 << 32);
  unint64_t v1212 = v1207 + (v1209 << 32);
  unint64_t v1213 = v1204 + HIDWORD(v1209) + (v1208 >> 63) + ((v1210 & ~v1212 | v1211) >> 63);
  unint64_t v1214 = v1212 | v1192;
  unint64_t v1215 = v1212 & v1192;
  uint64_t v1216 = v1212 + v1192;
  unint64_t v1217 = v1213 + ((v1214 & ~v1216 | v1215) >> 63);
  unint64_t v1218 = v1217 | v1196;
  unint64_t v1219 = v1217 & v1196;
  uint64_t v1220 = v1217 + v1196;
  unint64_t v1221 = v1197 + ((v1218 & ~v1220 | v1219) >> 63);
  unint64_t v1222 = a3[7];
  unint64_t v1223 = HIDWORD(v1199);
  LODWORD(v1219) = v1199;
  unint64_t v1224 = HIDWORD(v1222);
  LODWORD(v1210) = v1222;
  unint64_t v1225 = v1222 * (unint64_t)v1199;
  unint64_t v1226 = v1210 * (unint64_t)HIDWORD(v1199);
  unint64_t v1227 = HIDWORD(v1226) + v1224 * (unint64_t)v1223;
  unint64_t v1228 = v1225 | (v1226 << 32);
  unint64_t v1229 = v1225 & (v1226 << 32);
  unint64_t v1230 = (v1226 << 32) + v1210 * (unint64_t)v1219;
  unint64_t v1231 = v1228 & ~v1230 | v1229;
  unint64_t v1232 = v1224 * (unint64_t)v1219;
  unint64_t v1233 = v1230 | (v1232 << 32);
  unint64_t v1234 = v1230 & (v1232 << 32);
  unint64_t v1235 = v1230 + (v1232 << 32);
  unint64_t v1236 = v1227 + HIDWORD(v1232) + (v1231 >> 63) + ((v1233 & ~v1235 | v1234) >> 63);
  unint64_t v1237 = v1235 | v1216;
  unint64_t v1238 = v1235 & v1216;
  unint64_t v1239 = v1235 + v1216;
  unint64_t v1240 = v1236 + ((v1237 & ~v1239 | v1238) >> 63);
  unint64_t v1241 = v1240 | v1220;
  unint64_t v1242 = v1240 & v1220;
  uint64_t v1243 = v1240 + v1220;
  unint64_t v1244 = v1221 + ((v1241 & ~v1243 | v1242) >> 63);
  result[10] = v1239;
  unint64_t v1245 = a2[4];
  unint64_t v1246 = a2[5];
  unint64_t v1247 = HIDWORD(v1245);
  LODWORD(v1242) = v1245;
  unint64_t v1249 = a3[6];
  unint64_t v1248 = a3[7];
  unint64_t v1250 = HIDWORD(v1248);
  LODWORD(v1211) = v1248;
  unint64_t v1251 = v1248 * (unint64_t)v1245;
  unint64_t v1252 = v1248 * (unint64_t)v1247;
  unint64_t v1253 = HIDWORD(v1252) + v1250 * (unint64_t)v1247;
  unint64_t v1254 = v1251 | (v1252 << 32);
  unint64_t v1255 = v1251 & (v1252 << 32);
  unint64_t v1256 = (v1252 << 32) + v1211 * (unint64_t)v1242;
  unint64_t v1257 = v1254 & ~v1256 | v1255;
  unint64_t v1258 = v1250 * (unint64_t)v1242;
  unint64_t v1259 = v1256 | (v1258 << 32);
  unint64_t v1260 = v1256 & (v1258 << 32);
  unint64_t v1261 = v1256 + (v1258 << 32);
  unint64_t v1262 = v1253 + HIDWORD(v1258) + (v1257 >> 63) + ((v1259 & ~v1261 | v1260) >> 63);
  unint64_t v1263 = v1243 | v1261;
  unint64_t v1264 = v1243 & v1261;
  uint64_t v1265 = v1243 + v1261;
  unint64_t v1266 = v1262 + ((v1263 & ~v1265 | v1264) >> 63);
  unint64_t v1267 = v1266 | v1244;
  unint64_t v1268 = v1266 + v1244;
  unint64_t v1269 = v1267 & ~v1268;
  unint64_t v1270 = HIDWORD(v1246);
  LODWORD(v1264) = v1246;
  unint64_t v1271 = HIDWORD(v1249);
  LODWORD(v1259) = v1249;
  unint64_t v1272 = v1249 * (unint64_t)v1246;
  unint64_t v1273 = v1249 * (unint64_t)v1270;
  unint64_t v1274 = HIDWORD(v1273) + v1271 * (unint64_t)v1270;
  unint64_t v1275 = v1272 | (v1273 << 32);
  unint64_t v1276 = v1272 & (v1273 << 32);
  unint64_t v1277 = (v1273 << 32) + v1259 * (unint64_t)v1264;
  unint64_t v1278 = v1275 & ~v1277 | v1276;
  unint64_t v1279 = v1271 * (unint64_t)v1264;
  unint64_t v1280 = v1277 | (v1279 << 32);
  unint64_t v1281 = v1277 & (v1279 << 32);
  unint64_t v1282 = v1277 + (v1279 << 32);
  unint64_t v1283 = v1274 + HIDWORD(v1279) + (v1278 >> 63) + ((v1280 & ~v1282 | v1281) >> 63);
  unint64_t v1284 = v1265 | v1282;
  unint64_t v1285 = v1265 & v1282;
  uint64_t v1286 = v1265 + v1282;
  unint64_t v1287 = v1283 + ((v1284 & ~v1286 | v1285) >> 63);
  unint64_t v1288 = v1287 | v1268;
  unint64_t v1289 = v1287 & v1268;
  unint64_t v1290 = v1287 + v1268;
  unint64_t v1291 = ((v1288 & ~v1290 | v1289) >> 63) + (v1269 >> 63);
  unint64_t v1292 = a2[6];
  unint64_t v1293 = a2[7];
  unint64_t v1294 = HIDWORD(v1292);
  LODWORD(v1280) = v1292;
  unint64_t v1296 = a3[4];
  unint64_t v1295 = a3[5];
  unint64_t v1297 = HIDWORD(v1295);
  LODWORD(v1275) = v1295;
  unint64_t v1298 = v1295 * (unint64_t)v1292;
  unint64_t v1299 = v1295 * (unint64_t)v1294;
  unint64_t v1300 = HIDWORD(v1299) + v1297 * (unint64_t)v1294;
  unint64_t v1301 = v1298 | (v1299 << 32);
  unint64_t v1302 = v1298 & (v1299 << 32);
  unint64_t v1303 = (v1299 << 32) + v1275 * (unint64_t)v1280;
  unint64_t v1304 = v1301 & ~v1303 | v1302;
  unint64_t v1305 = v1297 * (unint64_t)v1280;
  unint64_t v1306 = v1303 | (v1305 << 32);
  unint64_t v1307 = v1303 & (v1305 << 32);
  unint64_t v1308 = v1303 + (v1305 << 32);
  unint64_t v1309 = v1300 + HIDWORD(v1305) + (v1304 >> 63) + ((v1306 & ~v1308 | v1307) >> 63);
  unint64_t v1310 = v1286 | v1308;
  unint64_t v1311 = v1286 & v1308;
  uint64_t v1312 = v1286 + v1308;
  unint64_t v1313 = v1309 + ((v1310 & ~v1312 | v1311) >> 63);
  unint64_t v1314 = v1313 | v1290;
  unint64_t v1315 = v1313 & v1290;
  unint64_t v1316 = v1313 + v1290;
  unint64_t v1317 = v1291 + ((v1314 & ~v1316 | v1315) >> 63);
  unint64_t v1318 = HIDWORD(v1293);
  LODWORD(v1314) = v1293;
  unint64_t v1319 = HIDWORD(v1296);
  LODWORD(v1308) = v1296;
  unint64_t v1320 = v1296 * (unint64_t)v1293;
  unint64_t v1321 = v1296 * (unint64_t)v1318;
  unint64_t v1322 = HIDWORD(v1321) + v1319 * (unint64_t)v1318;
  unint64_t v1323 = (v1321 << 32) + v1308 * (unint64_t)v1314;
  unint64_t v1324 = (v1320 | (v1321 << 32)) & ~v1323 | v1320 & (v1321 << 32);
  unint64_t v1325 = v1319 * (unint64_t)v1314;
  unint64_t v1326 = v1323 | (v1325 << 32);
  unint64_t v1327 = v1323 & (v1325 << 32);
  unint64_t v1328 = v1323 + (v1325 << 32);
  unint64_t v1329 = v1322 + HIDWORD(v1325) + (v1324 >> 63) + ((v1326 & ~v1328 | v1327) >> 63);
  unint64_t v1330 = v1328 | v1312;
  unint64_t v1331 = v1328 & v1312;
  unint64_t v1332 = v1328 + v1312;
  unint64_t v1333 = v1329 + ((v1330 & ~v1332 | v1331) >> 63);
  unint64_t v1334 = v1333 | v1316;
  unint64_t v1335 = v1333 & v1316;
  uint64_t v1336 = v1333 + v1316;
  unint64_t v1337 = v1317 + ((v1334 & ~v1336 | v1335) >> 63);
  result[11] = v1332;
  unint64_t v1338 = a2[7];
  unint64_t v1339 = HIDWORD(v1338);
  LODWORD(v1334) = v1338;
  unint64_t v1340 = a3[5];
  unint64_t v1341 = a3[6];
  unint64_t v1342 = HIDWORD(v1340);
  LODWORD(v1327) = v1340;
  unint64_t v1343 = v1340 * (unint64_t)v1338;
  unint64_t v1344 = v1340 * (unint64_t)v1339;
  unint64_t v1345 = HIDWORD(v1344) + v1342 * (unint64_t)v1339;
  unint64_t v1346 = v1343 | (v1344 << 32);
  unint64_t v1347 = v1343 & (v1344 << 32);
  unint64_t v1348 = (v1344 << 32) + v1327 * (unint64_t)v1334;
  unint64_t v1349 = v1346 & ~v1348 | v1347;
  unint64_t v1350 = v1342 * (unint64_t)v1334;
  unint64_t v1351 = v1348 | (v1350 << 32);
  unint64_t v1352 = v1348 & (v1350 << 32);
  unint64_t v1353 = v1348 + (v1350 << 32);
  unint64_t v1354 = v1345 + HIDWORD(v1350) + (v1349 >> 63) + ((v1351 & ~v1353 | v1352) >> 63);
  unint64_t v1355 = v1336 | v1353;
  unint64_t v1356 = v1336 & v1353;
  uint64_t v1357 = v1336 + v1353;
  unint64_t v1358 = v1354 + ((v1355 & ~v1357 | v1356) >> 63);
  unint64_t v1359 = v1358 | v1337;
  unint64_t v1360 = v1358 + v1337;
  unint64_t v1361 = v1359 & ~v1360;
  unint64_t v1363 = a2[5];
  unint64_t v1362 = a2[6];
  unint64_t v1364 = HIDWORD(v1362);
  LODWORD(v1351) = v1362;
  unint64_t v1365 = HIDWORD(v1341);
  LODWORD(v1306) = v1341;
  unint64_t v1366 = v1341 * (unint64_t)v1362;
  unint64_t v1367 = v1341 * (unint64_t)v1364;
  unint64_t v1368 = HIDWORD(v1367) + v1365 * (unint64_t)v1364;
  unint64_t v1369 = v1366 | (v1367 << 32);
  unint64_t v1370 = v1366 & (v1367 << 32);
  unint64_t v1371 = (v1367 << 32) + v1306 * (unint64_t)v1351;
  unint64_t v1372 = v1369 & ~v1371 | v1370;
  unint64_t v1373 = v1365 * (unint64_t)v1351;
  unint64_t v1374 = v1371 | (v1373 << 32);
  unint64_t v1375 = v1371 & (v1373 << 32);
  unint64_t v1376 = v1371 + (v1373 << 32);
  unint64_t v1377 = v1368 + HIDWORD(v1373) + (v1372 >> 63) + ((v1374 & ~v1376 | v1375) >> 63);
  unint64_t v1378 = v1357 | v1376;
  unint64_t v1379 = v1357 & v1376;
  uint64_t v1380 = v1357 + v1376;
  unint64_t v1381 = v1377 + ((v1378 & ~v1380 | v1379) >> 63);
  unint64_t v1382 = v1381 | v1360;
  unint64_t v1383 = v1381 & v1360;
  unint64_t v1384 = v1381 + v1360;
  unint64_t v1385 = ((v1382 & ~v1384 | v1383) >> 63) + (v1361 >> 63);
  unint64_t v1386 = a3[7];
  unint64_t v1387 = HIDWORD(v1363);
  LODWORD(v1383) = v1363;
  unint64_t v1388 = HIDWORD(v1386);
  LODWORD(v1374) = v1386;
  unint64_t v1389 = v1386 * (unint64_t)v1363;
  unint64_t v1390 = v1374 * (unint64_t)HIDWORD(v1363);
  unint64_t v1391 = HIDWORD(v1390) + v1388 * (unint64_t)v1387;
  unint64_t v1392 = v1389 | (v1390 << 32);
  unint64_t v1393 = v1389 & (v1390 << 32);
  unint64_t v1394 = (v1390 << 32) + v1374 * (unint64_t)v1383;
  unint64_t v1395 = v1392 & ~v1394 | v1393;
  unint64_t v1396 = v1388 * (unint64_t)v1383;
  unint64_t v1397 = v1394 | (v1396 << 32);
  unint64_t v1398 = v1394 & (v1396 << 32);
  unint64_t v1399 = v1394 + (v1396 << 32);
  unint64_t v1400 = v1391 + HIDWORD(v1396) + (v1395 >> 63) + ((v1397 & ~v1399 | v1398) >> 63);
  unint64_t v1401 = v1380 | v1399;
  unint64_t v1402 = v1380 & v1399;
  unint64_t v1403 = v1380 + v1399;
  unint64_t v1404 = v1400 + ((v1401 & ~v1403 | v1402) >> 63);
  unint64_t v1405 = v1404 | v1384;
  unint64_t v1406 = v1404 & v1384;
  unint64_t v1407 = v1404 + v1384;
  unint64_t v1408 = v1385 + ((v1405 & ~v1407 | v1406) >> 63);
  result[12] = v1403;
  unint64_t v1409 = a2[6];
  unint64_t v1410 = a2[7];
  unint64_t v1411 = HIDWORD(v1409);
  LODWORD(v1406) = v1409;
  unint64_t v1413 = a3[6];
  unint64_t v1412 = a3[7];
  unint64_t v1414 = HIDWORD(v1412);
  LODWORD(v1375) = v1412;
  unint64_t v1415 = v1412 * (unint64_t)v1409;
  unint64_t v1416 = v1412 * (unint64_t)v1411;
  unint64_t v1417 = HIDWORD(v1416) + v1414 * (unint64_t)v1411;
  unint64_t v1418 = v1415 | (v1416 << 32);
  unint64_t v1419 = v1415 & (v1416 << 32);
  unint64_t v1420 = (v1416 << 32) + v1375 * (unint64_t)v1406;
  unint64_t v1421 = v1418 & ~v1420 | v1419;
  unint64_t v1422 = v1414 * (unint64_t)v1406;
  unint64_t v1423 = v1420 | (v1422 << 32);
  unint64_t v1424 = v1420 & (v1422 << 32);
  unint64_t v1425 = v1420 + (v1422 << 32);
  unint64_t v1426 = v1417 + HIDWORD(v1422) + (v1421 >> 63) + ((v1423 & ~v1425 | v1424) >> 63);
  unint64_t v1427 = v1407 | v1425;
  unint64_t v1428 = v1407 & v1425;
  unint64_t v1429 = v1407 + v1425;
  unint64_t v1430 = v1426 + ((v1427 & ~v1429 | v1428) >> 63);
  unint64_t v1431 = v1408 + v1430;
  unint64_t v1432 = v1430 & ~(v1408 + v1430);
  unint64_t v1433 = HIDWORD(v1410);
  LODWORD(v1427) = v1410;
  unint64_t v1434 = HIDWORD(v1413);
  LODWORD(v1423) = v1413;
  unint64_t v1435 = v1413 * (unint64_t)v1410;
  unint64_t v1436 = v1413 * (unint64_t)v1433;
  unint64_t v1437 = HIDWORD(v1436) + v1434 * (unint64_t)v1433;
  unint64_t v1438 = v1435 | (v1436 << 32);
  unint64_t v1439 = v1435 & (v1436 << 32);
  unint64_t v1440 = (v1436 << 32) + v1423 * (unint64_t)v1427;
  unint64_t v1441 = v1438 & ~v1440 | v1439;
  unint64_t v1442 = v1434 * (unint64_t)v1427;
  unint64_t v1443 = v1440 | (v1442 << 32);
  unint64_t v1444 = v1440 & (v1442 << 32);
  unint64_t v1445 = v1440 + (v1442 << 32);
  unint64_t v1446 = v1437
        + HIDWORD(v1442)
        + (v1441 >> 63)
        + ((v1443 & ~v1445 | v1444) >> 63)
        + (((v1429 | v1445) & ~(v1429 + v1445) | v1429 & v1445) >> 63);
  unint64_t v1447 = v1446 | v1431;
  unint64_t v1448 = v1446 & v1431;
  unint64_t v1449 = v1446 + v1431;
  unint64_t v1450 = v1447 & ~v1449 | v1448;
  result[13] = v1429 + v1445;
  unint64_t v1451 = a2[7];
  unint64_t v1452 = a3[7];
  unint64_t v1453 = HIDWORD(v1451);
  LODWORD(v1429) = v1451;
  unint64_t v1454 = HIDWORD(v1452);
  LODWORD(v1444) = v1452;
  unint64_t v1455 = v1452 * (unint64_t)v1451;
  unint64_t v1456 = v1452 * (unint64_t)v1453;
  unint64_t v1457 = HIDWORD(v1456) + v1454 * (unint64_t)v1453;
  unint64_t v1458 = v1455 | (v1456 << 32);
  unint64_t v1459 = v1455 & (v1456 << 32);
  unint64_t v1460 = (v1456 << 32) + v1444 * (unint64_t)v1429;
  unint64_t v1461 = v1458 & ~v1460 | v1459;
  unint64_t v1462 = v1454 * (unint64_t)v1429;
  unint64_t v1463 = v1460 | (v1462 << 32);
  unint64_t v1464 = v1460 & (v1462 << 32);
  unint64_t v1465 = v1460 + (v1462 << 32);
  unint64_t v1466 = v1457 + HIDWORD(v1462) + (v1461 >> 63) + ((v1463 & ~v1465 | v1464) >> 63);
  unint64_t v1467 = v1449 | v1465;
  unint64_t v1468 = v1449 & v1465;
  unint64_t v1469 = v1449 + v1465;
  result[14] = v1469;
  result[15] = v1466 + (v1432 >> 63) + (v1450 >> 63) + ((v1467 & ~v1469 | v1468) >> 63);
  return result;
}

unint64_t bn_mul_words(unint64_t *rp, const unint64_t *ap, int num, unint64_t w)
{
  if (num < 0) {
    bn_mul_words_cold_1();
  }
  if (!num) {
    return 0;
  }
  if (num < 4)
  {
    unint64_t v4 = 0;
    do
    {
LABEL_9:
      uint64_t v72 = *ap++;
      unint64_t v73 = v72 * (unint64_t)w;
      unint64_t v74 = HIDWORD(v72) * (unint64_t)w;
      unint64_t v75 = HIDWORD(v74) + HIDWORD(v72) * (unint64_t)HIDWORD(w);
      unint64_t v76 = v73 | (v74 << 32);
      unint64_t v77 = v73 & (v74 << 32);
      unint64_t v78 = (v74 << 32) + v72 * (unint64_t)w;
      unint64_t v79 = v76 & ~v78 | v77;
      unint64_t v80 = v72 * (unint64_t)HIDWORD(w);
      unint64_t v81 = v78 | (v80 << 32);
      unint64_t v82 = v78 & (v80 << 32);
      unint64_t v83 = v78 + (v80 << 32);
      unint64_t v84 = v75 + HIDWORD(v80) + (v79 >> 63) + ((v81 & ~v83 | v82) >> 63);
      unint64_t v85 = v83 | v4;
      unint64_t v86 = v83 & v4;
      unint64_t v87 = v83 + v4;
      unint64_t v4 = v84 + ((v85 & ~v87 | v86) >> 63);
      *rp++ = v87;
      --num;
    }
    while (num);
    return v4;
  }
  unint64_t v4 = 0;
  do
  {
    unint64_t v5 = HIDWORD(*ap);
    unint64_t v6 = *ap * (unint64_t)w;
    unint64_t v7 = v5 * (unint64_t)w;
    unint64_t v8 = HIDWORD(v7) + v5 * (unint64_t)HIDWORD(w);
    unint64_t v9 = v6 | (v7 << 32);
    unint64_t v10 = v6 & (v7 << 32);
    unint64_t v11 = (v7 << 32) + *ap * (unint64_t)w;
    unint64_t v12 = v9 & ~v11 | v10;
    unint64_t v13 = *ap * (unint64_t)HIDWORD(w);
    unint64_t v14 = v11 | (v13 << 32);
    unint64_t v15 = v11 & (v13 << 32);
    unint64_t v16 = v11 + (v13 << 32);
    unint64_t v17 = v8 + HIDWORD(v13) + (v12 >> 63) + ((v14 & ~v16 | v15) >> 63);
    unint64_t v18 = v16 | v4;
    unint64_t v19 = v16 & v4;
    unint64_t v20 = v16 + v4;
    unint64_t v21 = v17 + ((v18 & ~v20 | v19) >> 63);
    *runsigned int p = v20;
    unint64_t v22 = ap[1];
    unint64_t v23 = v22 * (unint64_t)w;
    unint64_t v24 = HIDWORD(v22) * (unint64_t)w;
    unint64_t v25 = HIDWORD(v24) + HIDWORD(v22) * (unint64_t)HIDWORD(w);
    unint64_t v26 = v23 | (v24 << 32);
    unint64_t v27 = v23 & (v24 << 32);
    unint64_t v28 = (v24 << 32) + v22 * (unint64_t)w;
    unint64_t v29 = v26 & ~v28 | v27;
    unint64_t v30 = v22 * (unint64_t)HIDWORD(w);
    unint64_t v31 = v28 | (v30 << 32);
    unint64_t v32 = v28 & (v30 << 32);
    unint64_t v33 = v28 + (v30 << 32);
    unint64_t v34 = v25 + HIDWORD(v30) + (v29 >> 63) + ((v31 & ~v33 | v32) >> 63);
    unint64_t v35 = v21 | v33;
    unint64_t v36 = v21 & v33;
    unint64_t v37 = v21 + v33;
    unint64_t v38 = v34 + ((v35 & ~v37 | v36) >> 63);
    rp[1] = v37;
    unint64_t v39 = ap[2];
    unint64_t v40 = v39 * (unint64_t)w;
    unint64_t v41 = HIDWORD(v39) * (unint64_t)w;
    unint64_t v42 = HIDWORD(v41) + HIDWORD(v39) * (unint64_t)HIDWORD(w);
    unint64_t v43 = v40 | (v41 << 32);
    unint64_t v44 = v40 & (v41 << 32);
    unint64_t v45 = (v41 << 32) + v39 * (unint64_t)w;
    unint64_t v46 = v43 & ~v45 | v44;
    unint64_t v47 = v39 * (unint64_t)HIDWORD(w);
    unint64_t v48 = v45 | (v47 << 32);
    unint64_t v49 = v45 & (v47 << 32);
    unint64_t v50 = v45 + (v47 << 32);
    unint64_t v51 = v42 + HIDWORD(v47) + (v46 >> 63) + ((v48 & ~v50 | v49) >> 63);
    unint64_t v52 = v38 | v50;
    unint64_t v53 = v38 & v50;
    unint64_t v54 = v38 + v50;
    unint64_t v55 = v51 + ((v52 & ~v54 | v53) >> 63);
    rp[2] = v54;
    unint64_t v56 = ap[3];
    unint64_t v57 = v56 * (unint64_t)w;
    unint64_t v58 = HIDWORD(v56) * (unint64_t)w;
    unint64_t v59 = HIDWORD(v58) + HIDWORD(v56) * (unint64_t)HIDWORD(w);
    unint64_t v60 = v57 | (v58 << 32);
    unint64_t v61 = v57 & (v58 << 32);
    unint64_t v62 = (v58 << 32) + v56 * (unint64_t)w;
    unint64_t v63 = v60 & ~v62 | v61;
    unint64_t v64 = v56 * (unint64_t)HIDWORD(w);
    unint64_t v65 = v62 | (v64 << 32);
    unint64_t v66 = v62 & (v64 << 32);
    unint64_t v67 = v62 + (v64 << 32);
    unint64_t v68 = v59 + HIDWORD(v64) + (v63 >> 63) + ((v65 & ~v67 | v66) >> 63);
    unint64_t v69 = v55 | v67;
    unint64_t v70 = v55 & v67;
    unint64_t v71 = v55 + v67;
    unint64_t v4 = v68 + ((v69 & ~v71 | v70) >> 63);
    rp[3] = v71;
    ap += 4;
    rp += 4;
    num -= 4;
  }
  while (num >= 4);
  if (num) {
    goto LABEL_9;
  }
  return v4;
}

unint64_t bn_mul_add_words(unint64_t *rp, const unint64_t *ap, int num, unint64_t w)
{
  if (num < 0) {
    bn_mul_add_words_cold_1();
  }
  if (!num) {
    return 0;
  }
  if (num < 4)
  {
    unint64_t v4 = 0;
    do
    {
LABEL_9:
      uint64_t v89 = *ap++;
      unint64_t v90 = v89 * (unint64_t)w;
      unint64_t v91 = HIDWORD(v89) * (unint64_t)w;
      unint64_t v92 = HIDWORD(v91) + HIDWORD(v89) * (unint64_t)HIDWORD(w);
      unint64_t v93 = v90 | (v91 << 32);
      unint64_t v94 = v90 & (v91 << 32);
      unint64_t v95 = (v91 << 32) + v89 * (unint64_t)w;
      unint64_t v96 = v93 & ~v95 | v94;
      unint64_t v97 = v89 * (unint64_t)HIDWORD(w);
      unint64_t v98 = v95 | (v97 << 32);
      unint64_t v99 = v95 & (v97 << 32);
      unint64_t v100 = v95 + (v97 << 32);
      unint64_t v101 = v100 + *rp;
      unint64_t v102 = v92
           + HIDWORD(v97)
           + (v96 >> 63)
           + ((v98 & ~v100 | v99) >> 63)
           + (((v100 | *rp) & ~v101 | v100 & *rp) >> 63);
      unint64_t v103 = v101 | v4;
      unint64_t v104 = v101 & v4;
      unint64_t v105 = v101 + v4;
      unint64_t v4 = v102 + ((v103 & ~v105 | v104) >> 63);
      *rp++ = v105;
      --num;
    }
    while (num);
    return v4;
  }
  unint64_t v4 = 0;
  do
  {
    unint64_t v5 = HIDWORD(*ap);
    unint64_t v6 = *ap * (unint64_t)w;
    unint64_t v7 = v5 * (unint64_t)w;
    unint64_t v8 = HIDWORD(v7) + v5 * (unint64_t)HIDWORD(w);
    unint64_t v9 = v6 | (v7 << 32);
    unint64_t v10 = v6 & (v7 << 32);
    unint64_t v11 = (v7 << 32) + *ap * (unint64_t)w;
    unint64_t v12 = v9 & ~v11 | v10;
    unint64_t v13 = *ap * (unint64_t)HIDWORD(w);
    unint64_t v14 = v11 | (v13 << 32);
    unint64_t v15 = v11 & (v13 << 32);
    unint64_t v16 = v11 + (v13 << 32);
    unint64_t v17 = v8 + HIDWORD(v13) + (v12 >> 63) + ((v14 & ~v16 | v15) >> 63);
    unint64_t v18 = rp[1];
    unint64_t v19 = v16 + *rp;
    unint64_t v20 = v17 + (((v16 | *rp) & ~v19 | v16 & *rp) >> 63);
    unint64_t v21 = v19 | v4;
    unint64_t v22 = v19 & v4;
    unint64_t v23 = v19 + v4;
    unint64_t v24 = v20 + ((v21 & ~v23 | v22) >> 63);
    *runsigned int p = v23;
    unint64_t v25 = ap[1];
    unint64_t v26 = v25 * (unint64_t)w;
    unint64_t v27 = HIDWORD(v25) * (unint64_t)w;
    unint64_t v28 = HIDWORD(v27) + HIDWORD(v25) * (unint64_t)HIDWORD(w);
    unint64_t v29 = v26 | (v27 << 32);
    unint64_t v30 = v26 & (v27 << 32);
    unint64_t v31 = (v27 << 32) + v25 * (unint64_t)w;
    unint64_t v32 = v29 & ~v31 | v30;
    unint64_t v33 = v25 * (unint64_t)HIDWORD(w);
    unint64_t v34 = v31 | (v33 << 32);
    unint64_t v35 = v31 & (v33 << 32);
    unint64_t v36 = v31 + (v33 << 32);
    unint64_t v37 = v28 + HIDWORD(v33) + (v32 >> 63) + ((v34 & ~v36 | v35) >> 63);
    unint64_t v38 = v36 | v18;
    unint64_t v39 = v36 & v18;
    unint64_t v40 = v36 + v18;
    unint64_t v41 = v37 + ((v38 & ~v40 | v39) >> 63);
    unint64_t v42 = v24 | v40;
    unint64_t v43 = v24 & v40;
    unint64_t v44 = v24 + v40;
    unint64_t v45 = v41 + ((v42 & ~v44 | v43) >> 63);
    rp[1] = v44;
    unint64_t v46 = ap[2];
    unint64_t v47 = v46 * (unint64_t)w;
    unint64_t v48 = HIDWORD(v46) * (unint64_t)w;
    unint64_t v49 = HIDWORD(v48) + HIDWORD(v46) * (unint64_t)HIDWORD(w);
    unint64_t v50 = v47 | (v48 << 32);
    unint64_t v51 = v47 & (v48 << 32);
    unint64_t v52 = (v48 << 32) + v46 * (unint64_t)w;
    unint64_t v53 = v50 & ~v52 | v51;
    unint64_t v54 = v46 * (unint64_t)HIDWORD(w);
    unint64_t v55 = v52 | (v54 << 32);
    unint64_t v56 = v52 & (v54 << 32);
    unint64_t v57 = v52 + (v54 << 32);
    unint64_t v58 = v49 + HIDWORD(v54) + (v53 >> 63) + ((v55 & ~v57 | v56) >> 63);
    unint64_t v59 = rp[2];
    unint64_t v60 = rp[3];
    unint64_t v61 = v57 | v59;
    unint64_t v62 = v57 & v59;
    unint64_t v63 = v57 + v59;
    unint64_t v64 = v58 + ((v61 & ~v63 | v62) >> 63);
    unint64_t v65 = v45 | v63;
    unint64_t v66 = v45 & v63;
    unint64_t v67 = v45 + v63;
    unint64_t v68 = v64 + ((v65 & ~v67 | v66) >> 63);
    rp[2] = v67;
    unint64_t v69 = ap[3];
    unint64_t v70 = v69 * (unint64_t)w;
    unint64_t v71 = HIDWORD(v69) * (unint64_t)w;
    unint64_t v72 = HIDWORD(v71) + HIDWORD(v69) * (unint64_t)HIDWORD(w);
    unint64_t v73 = v70 | (v71 << 32);
    unint64_t v74 = v70 & (v71 << 32);
    unint64_t v75 = (v71 << 32) + v69 * (unint64_t)w;
    unint64_t v76 = v73 & ~v75 | v74;
    unint64_t v77 = v69 * (unint64_t)HIDWORD(w);
    unint64_t v78 = v75 | (v77 << 32);
    unint64_t v79 = v75 & (v77 << 32);
    unint64_t v80 = v75 + (v77 << 32);
    unint64_t v81 = v72 + HIDWORD(v77) + (v76 >> 63) + ((v78 & ~v80 | v79) >> 63);
    unint64_t v82 = v80 | v60;
    unint64_t v83 = v80 & v60;
    unint64_t v84 = v80 + v60;
    unint64_t v85 = v81 + ((v82 & ~v84 | v83) >> 63);
    unint64_t v86 = v68 | v84;
    unint64_t v87 = v68 & v84;
    unint64_t v88 = v68 + v84;
    unint64_t v4 = v85 + ((v86 & ~v88 | v87) >> 63);
    rp[3] = v88;
    ap += 4;
    rp += 4;
    num -= 4;
  }
  while (num >= 4);
  if (num) {
    goto LABEL_9;
  }
  return v4;
}

unint64_t bn_mul_normal(unint64_t *rp, unint64_t *a2, int a3, unint64_t *a4, int a5)
{
  if (a3 < a5) {
    int v6 = a5;
  }
  else {
    int v6 = a3;
  }
  if (a3 < a5) {
    unint64_t v7 = a2;
  }
  else {
    unint64_t v7 = a4;
  }
  if (a3 < a5) {
    int v8 = a3;
  }
  else {
    int v8 = a5;
  }
  if (a3 < a5) {
    unint64_t v9 = a4;
  }
  else {
    unint64_t v9 = a2;
  }
  if (v8 <= 0)
  {
    return bn_mul_words(rp, v9, v6, 0);
  }
  else
  {
    unint64_t v10 = &rp[v6];
    unint64_t result = bn_mul_words(rp, v9, v6, *v7);
    *unint64_t v10 = result;
    if (v8 != 1)
    {
      uint64_t v12 = 0;
      unint64_t v13 = v7 + 2;
      do
      {
        unint64_t result = bn_mul_add_words(&rp[v12 + 1], v9, v6, v13[v12 - 1]);
        v10[v12 + 1] = result;
        if (v8 == 2) {
          break;
        }
        unint64_t result = bn_mul_add_words(&rp[v12 + 2], v9, v6, v13[v12]);
        v10[v12 + 2] = result;
        if (v8 < 4) {
          break;
        }
        unint64_t v14 = &v13[v12];
        unint64_t result = bn_mul_add_words(&rp[v12 + 3], v9, v6, v13[v12 + 1]);
        unint64_t v15 = &v10[v12];
        v10[v12 + 3] = result;
        v8 -= 4;
        if (!v8) {
          break;
        }
        v12 += 4;
        unint64_t result = bn_mul_add_words(&rp[v12], v9, v6, v14[2]);
        v15[4] = result;
      }
      while (v8 > 1);
    }
  }
  return result;
}

uint64_t bn_mul(unint64_t **a1, uint64_t a2, uint64_t a3)
{
  return 1;
}

int BN_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
{
  BN_CTX_start(ctx);
  if (!BN_is_zero((uint64_t)a) && !BN_is_zero((uint64_t)b))
  {
    if (r == a || (unint64_t v10 = r, r == b)) {
      unint64_t v10 = BN_CTX_get(ctx);
    }
    if (!v10) {
      goto LABEL_21;
    }
    tounsigned int p = b->top;
    if (top < 0) {
      goto LABEL_21;
    }
    unsigned int v12 = top + a->top;
    if (!bn_wexpand((uint64_t)v10, v12)) {
      goto LABEL_21;
    }
    int v13 = a->top;
    if (v13 == 4)
    {
      int v14 = b->top;
      if (v14 == 4)
      {
        bn_mul_comba4(v10->d, a->d, b->d);
        goto LABEL_20;
      }
    }
    else if (v13 == 8)
    {
      int v14 = b->top;
      if (v14 == 8)
      {
        bn_mul_comba8(v10->d, a->d, b->d);
        goto LABEL_20;
      }
    }
    else
    {
      int v14 = b->top;
    }
    bn_mul_normal(v10->d, a->d, v13, b->d, v14);
LABEL_20:
    v10->tounsigned int p = v12;
    bn_correct_top((uint64_t *)v10);
    BN_set_negative(v10, b->neg ^ a->neg);
    if (bn_copy(r, v10)) {
      goto LABEL_4;
    }
LABEL_21:
    int v8 = 0;
    goto LABEL_5;
  }
  BN_zero((uint64_t)r);
LABEL_4:
  int v8 = 1;
LABEL_5:
  BN_CTX_end(ctx);
  return v8;
}

void bn_mul_words_cold_1()
{
  __assert_rtn("bn_mul_words", "bn_mul.c", 209, "num >= 0");
}

void bn_mul_add_words_cold_1()
{
  __assert_rtn("bn_mul_add_words", "bn_mul.c", 246, "num >= 0");
}

X509_VERIFY_PARAM *X509_VERIFY_PARAM_new(void)
{
  uint64_t v0 = (X509_VERIFY_PARAM *)malloc_type_calloc(1uLL, 0x40uLL, 0x103004012F0C6E0uLL);
  if (v0)
  {
    char v1 = (char *)malloc_type_calloc(1uLL, 0x40uLL, 0x10300402D538A19uLL);
    if (v1)
    {
      v0[1].name = v1;
      x509_verify_param_zero((uint64_t)v0);
    }
    else
    {
      free(v0);
      return 0;
    }
  }
  return v0;
}

void x509_verify_param_zero(uint64_t a1)
{
  free(*(void **)a1);
  *(void *)a1 = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 40) = -1;
  uint64_t v2 = *(STACK **)(a1 + 48);
  if (v2)
  {
    sk_pop_free(v2, (void (__cdecl *)(void *))ASN1_OBJECT_free);
    *(void *)(a1 + 48) = 0;
  }
  uint64_t v3 = *(void *)(a1 + 56);
  if (*(void *)v3)
  {
    sk_pop_free(*(STACK **)v3, str_free);
    *(void *)uint64_t v3 = 0;
  }
  free(*(void **)(v3 + 16));
  *(void *)(v3 + 16) = 0;
  free(*(void **)(v3 + 24));
  *(void *)(v3 + 24) = 0;
  *(void *)(v3 + 32) = 0;
  free(*(void **)(v3 + 40));
  *(void *)(v3 + 40) = 0;
  *(void *)(v3 + 48) = 0;
  *(_DWORD *)(v3 + 56) = 0;
}

void X509_VERIFY_PARAM_free(X509_VERIFY_PARAM *param)
{
  if (param)
  {
    x509_verify_param_zero((uint64_t)param);
    free(param[1].name);
    free(param);
  }
}

int X509_VERIFY_PARAM_inherit(X509_VERIFY_PARAM *to, const X509_VERIFY_PARAM *from)
{
  if (!from) {
    return 1;
  }
  name = from[1].name;
  unint64_t inh_flags = to->inh_flags;
  unint64_t v6 = from->inh_flags;
  char v7 = v6 | inh_flags;
  if (((v6 | inh_flags) & 0x10) != 0) {
    to->unint64_t inh_flags = 0;
  }
  if (((v6 | inh_flags) & 8) != 0) {
    return 1;
  }
  int purpose = from->purpose;
  if ((v7 & 2) != 0)
  {
    to->int purpose = purpose;
    *(void *)&to->int trust = *(void *)&from->trust;
    unint64_t flags = to->flags;
LABEL_23:
    to->check_time = from->check_time;
    flags &= ~2uLL;
    to->unint64_t flags = flags;
    goto LABEL_24;
  }
  if (purpose)
  {
    if ((v7 & 1) == 0 && to->purpose)
    {
      int trust = from->trust;
      if (!trust) {
        goto LABEL_18;
      }
      goto LABEL_16;
    }
    to->int purpose = purpose;
  }
  int trust = from->trust;
  if (!trust) {
    goto LABEL_18;
  }
  if (v7)
  {
LABEL_17:
    to->int trust = trust;
    goto LABEL_18;
  }
LABEL_16:
  if (!to->trust) {
    goto LABEL_17;
  }
LABEL_18:
  int depth = from->depth;
  if (depth != -1 && ((v7 & 1) != 0 || to->depth == -1)) {
    to->int depth = depth;
  }
  unint64_t flags = to->flags;
  if ((flags & 2) == 0) {
    goto LABEL_23;
  }
LABEL_24:
  if ((v7 & 4) != 0)
  {
    unint64_t flags = 0;
    to->unint64_t flags = 0;
  }
  to->unint64_t flags = flags | from->flags;
  policies = from->policies;
  if ((v7 & 2) != 0)
  {
    int result = X509_VERIFY_PARAM_set1_policies(to, policies);
    if (!result) {
      return result;
    }
    unint64_t v15 = to[1].name;
    *((_DWORD *)v15 + 2) = *((_DWORD *)name + 2);
    goto LABEL_47;
  }
  int v14 = name;
  if (!policies)
  {
LABEL_36:
    if (!*((_DWORD *)v14 + 2)) {
      goto LABEL_42;
    }
    if (v7)
    {
      unint64_t v16 = to[1].name;
LABEL_41:
      *((_DWORD *)v16 + 2) = *((_DWORD *)name + 2);
      goto LABEL_42;
    }
LABEL_38:
    unint64_t v16 = to[1].name;
    if (*((_DWORD *)v16 + 2)) {
      goto LABEL_42;
    }
    goto LABEL_41;
  }
  if ((v7 & 1) != 0 || !to->policies)
  {
    int result = X509_VERIFY_PARAM_set1_policies(to, policies);
    if (!result) {
      return result;
    }
    int v14 = from[1].name;
    goto LABEL_36;
  }
  int v14 = name;
  if (*((_DWORD *)name + 2)) {
    goto LABEL_38;
  }
LABEL_42:
  if (!*(void *)v14) {
    goto LABEL_59;
  }
  unint64_t v17 = to + 1;
  unint64_t v15 = to[1].name;
  if ((v7 & 1) == 0)
  {
    if (*(void *)v15)
    {
      if (!*((void *)v14 + 3)) {
        goto LABEL_65;
      }
      goto LABEL_61;
    }
    goto LABEL_49;
  }
LABEL_47:
  unint64_t v17 = to + 1;
  if (*(void *)v15)
  {
    sk_pop_free(*(STACK **)v15, str_free);
    unint64_t v15 = v17->name;
    *(void *)v17->name = 0;
  }
LABEL_49:
  if (*(void *)name)
  {
    unint64_t v18 = sk_dup(*(STACK **)name);
    if (!v18)
    {
LABEL_78:
      int result = 0;
      *(void *)v17->name = 0;
      return result;
    }
    unint64_t v19 = v18;
    uint64_t num = v18->num;
    if (num)
    {
      uint64_t v21 = 0;
      data = v18->data;
      while (1)
      {
        unint64_t v23 = data[v21];
        if (v23)
        {
          data[v21] = strdup(v23);
          data = v19->data;
          if (!data[v21]) {
            break;
          }
        }
        if (num == ++v21) {
          goto LABEL_56;
        }
      }
      if (v21)
      {
        for (uint64_t i = 0; i != v21; ++i)
        {
          unint64_t v25 = v19->data[i];
          if (v25) {
            free(v25);
          }
        }
      }
      sk_free(v19);
      goto LABEL_78;
    }
LABEL_56:
    unint64_t v15 = v17->name;
    *(void *)v17->name = v19;
  }
  if ((v7 & 2) != 0)
  {
LABEL_62:
    int result = x509_param_set1_internal((void **)v15 + 3, (size_t *)v15 + 4, *((char **)name + 3), *((void *)name + 4), 1);
    if (!result)
    {
      *((_DWORD *)to[1].name + 14) = 1;
      return result;
    }
    if ((v7 & 2) != 0)
    {
LABEL_68:
      int result = X509_VERIFY_PARAM_set1_ip((uint64_t)to, *((char **)name + 5), *((void *)name + 6));
      if (!result) {
        return result;
      }
      return 1;
    }
    int v14 = from[1].name;
    goto LABEL_65;
  }
  int v14 = from[1].name;
LABEL_59:
  if (!*((void *)v14 + 3)) {
    goto LABEL_65;
  }
  unint64_t v15 = to[1].name;
  if (v7) {
    goto LABEL_62;
  }
LABEL_61:
  if (!*((void *)v15 + 3)) {
    goto LABEL_62;
  }
LABEL_65:
  if (*((void *)v14 + 5) && ((v7 & 1) != 0 || !*((void *)to[1].name + 5))) {
    goto LABEL_68;
  }
  return 1;
}

int X509_VERIFY_PARAM_set1_policies(X509_VERIFY_PARAM *param, STACK *policies)
{
  if (!param) {
    return (int)param;
  }
  uint64_t v3 = param;
  unint64_t v4 = param->policies;
  if (v4) {
    sk_pop_free(v4, (void (__cdecl *)(void *))ASN1_OBJECT_free);
  }
  if (!policies)
  {
    v3->policies = 0;
    goto LABEL_13;
  }
  param = (X509_VERIFY_PARAM *)sk_new_null();
  v3->policies = (STACK *)param;
  if (!param) {
    return (int)param;
  }
  if (sk_num(policies) < 1)
  {
LABEL_13:
    LODWORD(param) = 1;
    return (int)param;
  }
  int v5 = 0;
  while (1)
  {
    unint64_t v6 = sk_value(policies, v5);
    param = (X509_VERIFY_PARAM *)OBJ_dup((const ASN1_OBJECT *)v6);
    if (!param) {
      return (int)param;
    }
    char v7 = (ASN1_OBJECT *)param;
    if (!sk_push(v3->policies, (char *)param))
    {
      ASN1_OBJECT_free(v7);
      LODWORD(param) = 0;
      return (int)param;
    }
    if (++v5 >= sk_num(policies)) {
      goto LABEL_13;
    }
  }
}

uint64_t X509_VERIFY_PARAM_set1_email(uint64_t a1, char *__s, size_t __n)
{
  uint64_t v4 = 1;
  if (!x509_param_set1_internal((void **)(*(void *)(a1 + 56) + 24), (size_t *)(*(void *)(a1 + 56) + 32), __s, __n, 1))
  {
    *(_DWORD *)(*(void *)(a1 + 56) + 56) = 1;
    return 0;
  }
  return v4;
}

uint64_t X509_VERIFY_PARAM_set1_ip(uint64_t a1, char *__s, size_t __n)
{
  if ((__n == 16 || __n == 4)
    && x509_param_set1_internal((void **)(*(void *)(a1 + 56) + 40), (size_t *)(*(void *)(a1 + 56) + 48), __s, __n, 0))
  {
    return 1;
  }
  uint64_t result = 0;
  *(_DWORD *)(*(void *)(a1 + 56) + 56) = 1;
  return result;
}

int X509_VERIFY_PARAM_set1(X509_VERIFY_PARAM *to, const X509_VERIFY_PARAM *from)
{
  unint64_t inh_flags = to->inh_flags;
  to->unint64_t inh_flags = inh_flags | 1;
  int result = X509_VERIFY_PARAM_inherit(to, from);
  to->unint64_t inh_flags = inh_flags;
  return result;
}

int X509_VERIFY_PARAM_set1_name(X509_VERIFY_PARAM *param, const char *name)
{
  free(param->name);
  param->name = 0;
  if (!name) {
    return 1;
  }
  uint64_t v4 = strdup(name);
  param->name = v4;
  return v4 != 0;
}

int X509_VERIFY_PARAM_set_flags(X509_VERIFY_PARAM *param, unint64_t flags)
{
  param->flags |= flags;
  return 1;
}

int X509_VERIFY_PARAM_clear_flags(X509_VERIFY_PARAM *param, unint64_t flags)
{
  param->flags &= ~flags;
  return 1;
}

unint64_t X509_VERIFY_PARAM_get_flags(X509_VERIFY_PARAM *param)
{
  return param->flags;
}

int X509_VERIFY_PARAM_set_purpose(X509_VERIFY_PARAM *param, int purpose)
{
  return X509_PURPOSE_set(&param->purpose, purpose);
}

int X509_VERIFY_PARAM_set_trust(X509_VERIFY_PARAM *param, int trust)
{
  return X509_TRUST_set(&param->trust, trust);
}

void X509_VERIFY_PARAM_set_depth(X509_VERIFY_PARAM *param, int depth)
{
  param->int depth = depth;
}

uint64_t X509_VERIFY_PARAM_set_auth_level(uint64_t result, int a2)
{
  *(_DWORD *)(result + 44) = a2;
  return result;
}

uint64_t X509_VERIFY_PARAM_get_time(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void X509_VERIFY_PARAM_set_time(X509_VERIFY_PARAM *param, time_t t)
{
  param->check_time = t;
  param->flags |= 2uLL;
}

int X509_VERIFY_PARAM_add0_policy(X509_VERIFY_PARAM *param, ASN1_OBJECT *policy)
{
  policies = param->policies;
  if (policies || (policies = sk_new_null(), (param->policies = policies) != 0)) {
    LODWORD(policies) = sk_push(policies, (char *)policy) != 0;
  }
  return (int)policies;
}

uint64_t X509_VERIFY_PARAM_set1_host(uint64_t a1, char *__s1, size_t __n)
{
  int v4 = x509_param_set_hosts_internal(*(STACK ***)(a1 + 56), 0, __s1, __n);
  uint64_t result = 1;
  if (!v4)
  {
    *(_DWORD *)(*(void *)(a1 + 56) + 56) = 1;
    return 0;
  }
  return result;
}

uint64_t x509_param_set_hosts_internal(STACK **a1, int a2, char *__s1, size_t __n)
{
  size_t v4 = __n;
  if (__s1 && !__n)
  {
    size_t v4 = strlen(__s1);
    goto LABEL_5;
  }
  if (__s1)
  {
LABEL_5:
    int v8 = memchr(__s1, 0, v4);
    uint64_t result = 0;
    if (v8) {
      return result;
    }
  }
  if (!a2 && *a1)
  {
    sk_pop_free(*a1, str_free);
    *a1 = 0;
  }
  uint64_t result = 1;
  if (__s1)
  {
    if (v4)
    {
      uint64_t result = (uint64_t)strndup(__s1, v4);
      if (result)
      {
        unint64_t v10 = (char *)result;
        unint64_t v11 = *a1;
        if (*a1 || (unint64_t v11 = sk_new_null(), (*a1 = v11) != 0))
        {
          if (sk_push(v11, v10)) {
            return 1;
          }
          free(v10);
          if (!sk_num(*a1))
          {
            sk_free(*a1);
            uint64_t result = 0;
            *a1 = 0;
            return result;
          }
        }
        else
        {
          free(v10);
        }
        return 0;
      }
    }
  }
  return result;
}

uint64_t X509_VERIFY_PARAM_add1_host(uint64_t a1, char *__s1, size_t __n)
{
  uint64_t v4 = 1;
  if (!x509_param_set_hosts_internal(*(STACK ***)(a1 + 56), 1, __s1, __n))
  {
    *(_DWORD *)(*(void *)(a1 + 56) + 56) = 1;
    return 0;
  }
  return v4;
}

uint64_t X509_VERIFY_PARAM_get_hostflags(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 56) + 8);
}

uint64_t X509_VERIFY_PARAM_set_hostflags(uint64_t result, int a2)
{
  *(_DWORD *)(*(void *)(result + 56) + 8) = a2;
  return result;
}

uint64_t X509_VERIFY_PARAM_get0_peername(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 56) + 16);
}

uint64_t x509_param_set1_internal(void **a1, size_t *a2, char *__s, size_t __n, int a5)
{
  if (!__s) {
    return 0;
  }
  size_t v5 = __n;
  if (__n)
  {
    if (a5)
    {
      unint64_t v9 = memchr(__s, 0, __n);
      uint64_t result = 0;
      if (v9) {
        return result;
      }
    }
    uint64_t result = (uint64_t)malloc_type_malloc(v5, 0xA8D27C08uLL);
    if (!result) {
      return result;
    }
    uint64_t v11 = result;
    memcpy((void *)result, __s, v5);
  }
  else
  {
    uint64_t result = strlen(__s);
    if (!result) {
      return result;
    }
    size_t v5 = result;
    uint64_t result = (uint64_t)strdup(__s);
    if (!result) {
      return result;
    }
    uint64_t v11 = result;
  }
  if (*a1) {
    free(*a1);
  }
  *a1 = (void *)v11;
  if (a2) {
    *a2 = v5;
  }
  return 1;
}

uint64_t X509_VERIFY_PARAM_set1_ip_asc(uint64_t a1, const char *a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  int v3 = a2i_ipadd(ipout, a2);
  return X509_VERIFY_PARAM_set1_ip(a1, (char *)ipout, v3);
}

int X509_VERIFY_PARAM_get_depth(const X509_VERIFY_PARAM *param)
{
  return param->depth;
}

uint64_t X509_VERIFY_PARAM_get0_name(uint64_t a1)
{
  return *(void *)a1;
}

int X509_VERIFY_PARAM_add0_table(X509_VERIFY_PARAM *param)
{
  if (param_table)
  {
    int v2 = sk_find((STACK *)param_table, (char *)param);
    int v3 = (STACK *)param_table;
    if (v2 != -1)
    {
      uint64_t v4 = sk_value((const STACK *)param_table, v2);
      X509_VERIFY_PARAM_free((X509_VERIFY_PARAM *)v4);
      sk_delete((STACK *)param_table, v2);
      int v3 = (STACK *)param_table;
    }
    goto LABEL_5;
  }
  int v3 = sk_new((int (__cdecl *)(const char *const *, const char *const *))param_cmp);
  param_table = (uint64_t)v3;
  if (v3) {
LABEL_5:
  }
    LODWORD(v3) = sk_push(v3, (char *)param) != 0;
  return (int)v3;
}

uint64_t param_cmp(const char ***a1, const char ***a2)
{
  return strcmp(**a1, **a2);
}

uint64_t X509_VERIFY_PARAM_get_count()
{
  if (param_table) {
    return (sk_num((const STACK *)param_table) + 5);
  }
  else {
    return 5;
  }
}

char *X509_VERIFY_PARAM_get0(int a1)
{
  if (a1 > 4) {
    return sk_value((const STACK *)param_table, a1 - 5);
  }
  else {
    return (char *)&(&default_table)[8 * (uint64_t)a1];
  }
}

const X509_VERIFY_PARAM *__cdecl X509_VERIFY_PARAM_lookup(const char *name)
{
  uint64_t v9 = 0;
  long long v8 = 0u;
  long long v7 = 0u;
  long long v6 = 0u;
  size_t v5 = name;
  if (param_table)
  {
    int v2 = sk_find((STACK *)param_table, (char *)&v5);
    if (v2 != -1) {
      return (const X509_VERIFY_PARAM *)sk_value((const STACK *)param_table, v2);
    }
  }
  uint64_t v4 = 0;
  while (strcmp((&default_table)[v4], name))
  {
    v4 += 8;
    if (v4 == 40) {
      return 0;
    }
  }
  return (const X509_VERIFY_PARAM *)&(&default_table)[v4];
}

void X509_VERIFY_PARAM_table_cleanup(void)
{
  if (param_table) {
    sk_pop_free((STACK *)param_table, (void (__cdecl *)(void *))X509_VERIFY_PARAM_free);
  }
  param_table = 0;
}

int X509_CERT_AUX_print(BIO *bp, X509_CERT_AUX *x, int indent)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  if (x)
  {
    if (x->trust)
    {
      BIO_printf(bp, "%*sTrusted Uses:\n%*s", indent, "", indent + 2, "");
      if (sk_num(x->trust) >= 1)
      {
        int v6 = 0;
        char v7 = 0;
        do
        {
          if (v7) {
            BIO_puts(bp, ", ");
          }
          long long v8 = sk_value(x->trust, v6);
          OBJ_obj2txt(buf, 80, (const ASN1_OBJECT *)v8, 0);
          BIO_puts(bp, buf);
          ++v6;
          int v9 = sk_num(x->trust);
          char v7 = 1;
        }
        while (v6 < v9);
      }
      BIO_puts(bp, "\n");
    }
    else
    {
      BIO_printf(bp, "%*sNo Trusted Uses.\n", indent, "");
    }
    if (x->reject)
    {
      BIO_printf(bp, "%*sRejected Uses:\n%*s", indent, "", indent + 2, "");
      if (sk_num(x->reject) >= 1)
      {
        int v10 = 0;
        char v11 = 0;
        do
        {
          if (v11) {
            BIO_puts(bp, ", ");
          }
          unsigned int v12 = sk_value(x->reject, v10);
          OBJ_obj2txt(buf, 80, (const ASN1_OBJECT *)v12, 0);
          BIO_puts(bp, buf);
          ++v10;
          int v13 = sk_num(x->reject);
          char v11 = 1;
        }
        while (v10 < v13);
      }
      BIO_puts(bp, "\n");
    }
    else
    {
      BIO_printf(bp, "%*sNo Rejected Uses.\n", indent, "");
    }
    alias = x->alias;
    if (alias) {
      BIO_printf(bp, "%*sAlias: %.*s\n", indent, "", alias->length, (const char *)alias->data);
    }
    if (x->keyid)
    {
      BIO_printf(bp, "%*sKey Id: ", indent, "");
      keyid = x->keyid;
      if (keyid->length >= 1)
      {
        uint64_t v16 = 0;
        do
        {
          if (v16) {
            unint64_t v17 = ":";
          }
          else {
            unint64_t v17 = "";
          }
          BIO_printf(bp, "%s%02X", v17, keyid->data[v16++]);
          keyid = x->keyid;
        }
        while (v16 < keyid->length);
      }
      BIO_write(bp, "\n", 1);
    }
  }
  return 1;
}

int RSA_padding_add_PKCS1_type_1(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl)
{
  if (tlen - 11 >= fl)
  {
    *(_WORD *)to = 256;
    char v7 = to + 2;
    int v8 = tlen - fl - 3;
    memset(to + 2, 255, v8);
    int v9 = &v7[v8];
    unsigned __int8 *v9 = 0;
    memcpy(v9 + 1, f, fl);
    return 1;
  }
  else
  {
    ERR_put_error(4, 4095, 110, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pk1.c", 75);
    return 0;
  }
}

int RSA_padding_check_PKCS1_type_1(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl, int rsa_len)
{
  if (fl + 1 != rsa_len || *f != 1)
  {
    int v8 = 106;
    int v9 = 103;
    goto LABEL_9;
  }
  int v5 = fl - 2;
  if (fl < 2)
  {
    if (fl != 1)
    {
LABEL_12:
      int v8 = 103;
      int v9 = 129;
      goto LABEL_9;
    }
LABEL_18:
    int v8 = 113;
    int v9 = 124;
    goto LABEL_9;
  }
  int v6 = f + 2;
  int v7 = 1;
  while (*(v6 - 1) == 255)
  {
    ++v6;
    ++v7;
    if (--v5 == -1) {
      goto LABEL_18;
    }
  }
  if (*(v6 - 1))
  {
    int v8 = 102;
    int v9 = 116;
    goto LABEL_9;
  }
  if (v5 == -1) {
    goto LABEL_18;
  }
  if ((v7 - 1) <= 7) {
    goto LABEL_12;
  }
  if (v5 <= tlen)
  {
    memcpy(to, v6, v5);
    return v5;
  }
  int v8 = 109;
  int v9 = 135;
LABEL_9:
  ERR_put_error(4, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pk1.c", v9);
  return -1;
}

int RSA_padding_add_PKCS1_type_2(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl)
{
  if (tlen - 11 >= fl)
  {
    *(_WORD *)to = 512;
    int v7 = to + 2;
    int v8 = tlen - fl - 3;
    arc4random_buf(to + 2, v8);
    if (v8 >= 1)
    {
      for (int i = 0; i != v8; ++i)
      {
        while (!*v7)
          arc4random_buf(v7, 1uLL);
        ++v7;
      }
    }
    *int v7 = 0;
    memcpy(v7 + 1, f, fl);
    return 1;
  }
  else
  {
    ERR_put_error(4, 4095, 110, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pk1.c", 151);
    return 0;
  }
}

int RSA_padding_check_PKCS1_type_2(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl, int rsa_len)
{
  if (fl + 1 != rsa_len || *f != 2)
  {
    int v8 = 107;
    int v9 = 185;
    goto LABEL_9;
  }
  int v5 = fl - 2;
  if (fl < 2)
  {
    if (fl != 1)
    {
LABEL_12:
      int v8 = 103;
      int v9 = 201;
      goto LABEL_9;
    }
LABEL_17:
    int v8 = 113;
    int v9 = 196;
    goto LABEL_9;
  }
  int v6 = f + 2;
  int v7 = 1;
  while (*(v6 - 1))
  {
    ++v6;
    ++v7;
    if (--v5 == -1) {
      goto LABEL_17;
    }
  }
  if (v5 == -1) {
    goto LABEL_17;
  }
  if ((v7 - 1) <= 7) {
    goto LABEL_12;
  }
  if (v5 <= tlen)
  {
    memcpy(to, v6, v5);
    return v5;
  }
  int v8 = 109;
  int v9 = 207;
LABEL_9:
  ERR_put_error(4, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pk1.c", v9);
  return -1;
}

void mackey_free_gost(uint64_t a1)
{
}

uint64_t mac_ctrl_gost(uint64_t a1, int a2, uint64_t a3, _DWORD *a4)
{
  if (a2 != 3) {
    return 4294967294;
  }
  *a4 = 815;
  return 2;
}

uint64_t ASN1_bn_print(BIO *a1, const char *a2, const BIGNUM *a3, unsigned __int8 *a4, int a5)
{
  if (!a3) {
    return 1;
  }
  if (BN_is_negative((uint64_t)a3)) {
    int v10 = "-";
  }
  else {
    int v10 = "";
  }
  uint64_t result = BIO_indent(a1, a5, 128);
  if (result)
  {
    if (BN_is_zero((uint64_t)a3)) {
      return BIO_printf(a1, "%s 0\n", a2) > 0;
    }
    if (BN_num_bits(a3) > 64)
    {
      *a4 = 0;
      if (*v10 == 45) {
        int v13 = " (Negative)";
      }
      else {
        int v13 = "";
      }
      if (BIO_printf(a1, "%s%s", a2, v13) < 1) {
        return 0;
      }
      int v14 = BN_bn2bin(a3, a4 + 1);
      unsigned int v15 = 0;
      int v16 = 0;
      unsigned int v17 = a4[1];
      if ((v17 & 0x80u) != 0) {
        unint64_t v18 = a4;
      }
      else {
        unint64_t v18 = a4 + 1;
      }
      uint64_t v19 = v14 + (v17 >> 7);
      uint64_t v20 = v19 & ~((int)v19 >> 31);
      uint64_t v21 = v19 - 1;
      while (v20)
      {
        if (v16 - v15 / 0xF + 16 * (v15 / 0xF)) {
          goto LABEL_34;
        }
        if (BIO_puts(a1, "\n") < 1) {
          return 0;
        }
        uint64_t result = BIO_indent(a1, a5 + 4, 128);
        if (result)
        {
LABEL_34:
          int v23 = *v18++;
          int v22 = v23;
          unint64_t v24 = v21 ? ":" : "";
          int v25 = BIO_printf(a1, "%02x%s", v22, v24);
          uint64_t result = 0;
          --v20;
          --v16;
          ++v15;
          --v21;
          if (v25 >= 1) {
            continue;
          }
        }
        return result;
      }
      int v12 = BIO_write(a1, "\n", 1);
    }
    else
    {
      int v12 = BIO_printf(a1, "%s %s%lu (%s0x%lx)\n", a2, v10, *a3->d, v10, *a3->d);
    }
    return v12 >= 1;
  }
  return result;
}

uint64_t ASN1_buf_print(BIO *b, uint64_t a2, uint64_t a3, int indent)
{
  if (!a3) {
    return BIO_write(b, "\n", 1) > 0;
  }
  unint64_t v8 = 0;
  uint64_t v9 = a3 - 1;
  while (1)
  {
    if (15 * (v8 / 0xF) == v8)
    {
      if (v8 && BIO_puts(b, "\n") < 1) {
        return 0;
      }
      uint64_t result = BIO_indent(b, indent, 64);
      if (!result) {
        return result;
      }
    }
    char v11 = v9 == v8 ? "" : ":";
    if (BIO_printf(b, "%02x%s", *(unsigned __int8 *)(a2 + v8), v11) < 1) {
      break;
    }
    if (a3 == ++v8) {
      return BIO_write(b, "\n", 1) > 0;
    }
  }
  return 0;
}

BOOL bn_new(BIGNUM **a1)
{
  int v2 = BN_new();
  *a1 = v2;
  return v2 != 0;
}

void bn_free(BIGNUM **a1)
{
  int v2 = *a1;
  if (v2)
  {
    BN_free(v2);
    *a1 = 0;
  }
}

void bn_clear(BIGNUM **a1)
{
  *a1 = 0;
}

uint64_t bn_c2i(BIGNUM **a1, uint64_t a2, unsigned int a3)
{
  aint i = 0;
  memset(v9, 0, sizeof(v9));
  BN_free(*a1);
  *a1 = 0;
  if ((a3 & 0x80000000) == 0
    && (CBS_init(v9, a2, a3), c2i_ASN1_INTEGER_cbs((ASN1_VALUE **)&ai, v9))
    && (int v6 = ASN1_INTEGER_to_BN(ai, 0)) != 0)
  {
    *a1 = v6;
    uint64_t v7 = 1;
  }
  else
  {
    uint64_t v7 = 0;
  }
  ASN1_INTEGER_free(ai);
  return v7;
}

uint64_t bn_i2c(BIGNUM **a1, uint64_t a2)
{
  uint64_t v9 = a2;
  int v2 = *a1;
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = BN_to_ASN1_INTEGER(v2, 0);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  int v5 = v4;
  if (a2) {
    int v6 = (unsigned __int8 **)&v9;
  }
  else {
    int v6 = 0;
  }
  uint64_t v7 = i2c_ASN1_INTEGER(v4, v6);
  ASN1_INTEGER_free(v5);
  return v7;
}

uint64_t bn_print(BIO *a1, const BIGNUM **a2)
{
  uint64_t result = BN_print(a1, *a2);
  if (result) {
    return BIO_printf(a1, "\n") > 0;
  }
  return result;
}

const EVP_MD *EVP_md_null(void)
{
  return (const EVP_MD *)&null_md;
}

uint64_t init_1()
{
  return 1;
}

uint64_t update_1()
{
  return 1;
}

uint64_t final_1()
{
  return 1;
}

ASN1_VALUE *d2i_IPAddressRange(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &IPAddressRange_it);
}

uint64_t i2d_IPAddressRange(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &IPAddressRange_it);
}

ASN1_VALUE *IPAddressRange_new()
{
  return ASN1_item_new(&IPAddressRange_it);
}

void IPAddressRange_free(ASN1_VALUE *a1)
{
}

ASN1_VALUE *d2i_IPAddressOrRange(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &IPAddressOrRange_it);
}

uint64_t i2d_IPAddressOrRange(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &IPAddressOrRange_it);
}

ASN1_VALUE *IPAddressOrRange_new()
{
  return ASN1_item_new(&IPAddressOrRange_it);
}

void IPAddressOrRange_free(ASN1_VALUE *a1)
{
}

ASN1_VALUE *d2i_IPAddressChoice(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &IPAddressChoice_it);
}

uint64_t i2d_IPAddressChoice(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &IPAddressChoice_it);
}

ASN1_VALUE *IPAddressChoice_new()
{
  return ASN1_item_new(&IPAddressChoice_it);
}

void IPAddressChoice_free(ASN1_VALUE *a1)
{
}

ASN1_VALUE *d2i_IPAddressFamily(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &IPAddressFamily_it);
}

uint64_t i2d_IPAddressFamily(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &IPAddressFamily_it);
}

ASN1_VALUE *IPAddressFamily_new()
{
  return ASN1_item_new(&IPAddressFamily_it);
}

void IPAddressFamily_free(ASN1_VALUE *a1)
{
}

int **X509v3_addr_get_afi(int **result)
{
  if (result)
  {
    if (*result && *((void *)*result + 1))
    {
      unsigned __int16 v1 = 0;
      uint64_t result = (int **)IPAddressFamily_afi_safi(result, &v1, 0, 0);
      if (result) {
        return (int **)v1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t X509v3_addr_add_inherit(STACK *a1, unsigned int a2, unsigned int *a3)
{
  uint64_t result = (uint64_t)make_IPAddressFamily(a1, a2, a3);
  if (result)
  {
    uint64_t v4 = result;
    uint64_t v5 = *(void *)(result + 8);
    if (v5)
    {
      if (*(_DWORD *)v5)
      {
        if (*(_DWORD *)v5 == 1 && *(void *)(v5 + 8)) {
          return 0;
        }
      }
      else if (*(void *)(v5 + 8))
      {
        return 1;
      }
    }
    uint64_t result = (uint64_t)ASN1_NULL_new();
    *(void *)(*(void *)(v4 + 8) + 8) = result;
    if (!result) {
      return result;
    }
    **(_DWORD **)(v4 + 8) = 0;
    return 1;
  }
  return result;
}

char *make_IPAddressFamily(STACK *a1, unsigned int a2, unsigned int *a3)
{
  memset(v13, 0, sizeof(v13));
  memset(v12, 0, sizeof(v12));
  *(void *)len = 0;
  data = 0;
  if (!CBB_init((uint64_t)v13, 0)
    || !CBB_add_u16((char **)v13, a2)
    || a3 && !CBB_add_u8((char **)v13, *a3)
    || !CBB_finish((uint64_t *)v13, &data, len))
  {
    uint64_t v7 = 0;
    goto LABEL_15;
  }
  if (sk_num(a1) >= 1)
  {
    int v6 = 0;
    do
    {
      uint64_t v7 = sk_value(a1, v6);
      CBS_init(v12, *(void *)(*(void *)v7 + 8), **(int **)v7);
      if (CBS_mem_equal((uint64_t)v12, data, *(uint64_t *)len)) {
        goto LABEL_13;
      }
    }
    while (++v6 < sk_num(a1));
  }
  unint64_t v8 = (ASN1_OCTET_STRING **)ASN1_item_new(&IPAddressFamily_it);
  uint64_t v7 = (char *)v8;
  if (!v8 || !ASN1_OCTET_STRING_set(*v8, data, len[0]) || !sk_push(a1, v7))
  {
LABEL_15:
    CBB_cleanup((uint64_t *)v13);
    free(data);
    ASN1_item_free((ASN1_VALUE *)v7, &IPAddressFamily_it);
    return 0;
  }
LABEL_13:
  free(data);
  return v7;
}

uint64_t X509v3_addr_add_prefix(STACK *a1, unsigned int a2, unsigned int *a3, unsigned __int8 *a4, unsigned int a5)
{
  uint64_t result = (uint64_t)make_prefix_or_range(a1, a2, a3);
  if (result)
  {
    uint64_t v9 = (STACK *)result;
    data = 0;
    uint64_t result = make_addressPrefix((ASN1_VALUE **)&data, a4, a2, a5);
    if (result)
    {
      int v10 = data;
      if (sk_push(v9, data) <= 0)
      {
        ASN1_item_free((ASN1_VALUE *)v10, &IPAddressOrRange_it);
        return 0;
      }
      else
      {
        return 1;
      }
    }
  }
  return result;
}

STACK *make_prefix_or_range(STACK *a1, unsigned int a2, unsigned int *a3)
{
  IPAddressFamily = make_IPAddressFamily(a1, a2, a3);
  if (!IPAddressFamily) {
    return 0;
  }
  uint64_t v5 = IPAddressFamily;
  uint64_t v6 = *((void *)IPAddressFamily + 1);
  if (!v6)
  {
LABEL_9:
    unint64_t v8 = sk_new_null();
    uint64_t v7 = v8;
    if (!v8) {
      return v7;
    }
    uint64_t v9 = (int (__cdecl *)(const char *const *, const char *const *))v4IPAddressOrRange_cmp;
    if (a2 != 1)
    {
      if (a2 != 2)
      {
LABEL_14:
        uint64_t v10 = *((void *)v5 + 1);
        *(_DWORD *)uint64_t v10 = 1;
        *(void *)(v10 + 8) = v7;
        return v7;
      }
      uint64_t v9 = (int (__cdecl *)(const char *const *, const char *const *))v6IPAddressOrRange_cmp;
    }
    sk_set_cmp_func(v8, v9);
    goto LABEL_14;
  }
  if (*(_DWORD *)v6 == 1)
  {
    uint64_t v7 = *(STACK **)(v6 + 8);
    if (v7) {
      return v7;
    }
    goto LABEL_9;
  }
  if (*(_DWORD *)v6 || !*(void *)(v6 + 8)) {
    goto LABEL_9;
  }
  return 0;
}

uint64_t make_addressPrefix(ASN1_VALUE **a1, unsigned __int8 *a2, int a3, unsigned int a4)
{
  if ((a4 & 0x80000000) != 0) {
    goto LABEL_8;
  }
  int v5 = 16 * (a3 == 2);
  if (a3 == 1) {
    int v5 = 4;
  }
  unsigned int v6 = v5 ? 8 * v5 : 128;
  if (v6 < a4)
  {
LABEL_8:
    uint64_t v7 = 0;
LABEL_9:
    ASN1_item_free(v7, &IPAddressOrRange_it);
    return 0;
  }
  if ((a4 & 7) != 0) {
    unsigned __int8 v11 = 8 - (a4 & 7);
  }
  else {
    unsigned __int8 v11 = 0;
  }
  int v12 = ASN1_item_new(&IPAddressOrRange_it);
  uint64_t v7 = v12;
  if (!v12) {
    goto LABEL_9;
  }
  *(_DWORD *)int v12 = 0;
  int v13 = ASN1_BIT_STRING_new();
  *((void *)v7 + 1) = v13;
  if (!v13
    || !ASN1_BIT_STRING_set(v13, a2, (a4 + 7) >> 3)
    || !asn1_abs_set_unused_bits(*((void *)v7 + 1), v11))
  {
    goto LABEL_9;
  }
  *a1 = v7;
  return 1;
}

uint64_t X509v3_addr_add_range(STACK *a1, unsigned int a2, unsigned int *a3, void *a4, void *a5)
{
  uint64_t result = (uint64_t)make_prefix_or_range(a1, a2, a3);
  if (result)
  {
    uint64_t v9 = (STACK *)result;
    data = 0;
    if (a2 == 1) {
      size_t v10 = 4;
    }
    else {
      size_t v10 = 16 * (a2 == 2);
    }
    uint64_t result = make_addressRange((ASN1_VALUE **)&data, a4, a5, a2, v10);
    if (result)
    {
      unsigned __int8 v11 = data;
      if (sk_push(v9, data) <= 0)
      {
        ASN1_item_free((ASN1_VALUE *)v11, &IPAddressOrRange_it);
        return 0;
      }
      else
      {
        return 1;
      }
    }
  }
  return result;
}

uint64_t make_addressRange(ASN1_VALUE **a1, void *__s1, void *__s2, int a4, size_t __n)
{
  int v5 = __n;
  memset(v27, 0, sizeof(v27));
  unsigned __int8 v26 = 0;
  uint64_t v10 = __n;
  unsigned __int8 v11 = 0;
  if (memcmp(__s1, __s2, __n) > 0) {
    goto LABEL_21;
  }
  unsigned int should_be_prefix = range_should_be_prefix((uint64_t)__s1, (uint64_t)__s2, v5);
  if ((should_be_prefix & 0x80000000) != 0)
  {
    CBS_init(v27, (uint64_t)__s1, v10);
    if (trim_end_u8(v27, 0))
    {
      uint64_t v14 = CBS_len((uint64_t)v27);
      int v15 = v14;
      if (!v14)
      {
        unsigned __int8 v17 = 0;
        goto LABEL_15;
      }
      if (CBS_peek_last_u8(v27, &v26))
      {
        if (v26)
        {
          int v16 = 0;
          do
            unsigned __int8 v17 = v16++;
          while (((v26 >> v17) & 1) == 0);
        }
        else
        {
          unsigned __int8 v17 = 8;
        }
LABEL_15:
        CBS_init(v27, (uint64_t)__s2, v10);
        if (trim_end_u8(v27, 255))
        {
          uint64_t v18 = CBS_len((uint64_t)v27);
          int v19 = v18;
          if (!v18)
          {
            unsigned __int8 v21 = 0;
            goto LABEL_26;
          }
          if (CBS_peek_last_u8(v27, &v26))
          {
            unsigned int v20 = (v26 + 1);
            if (v20 == v26 + 1)
            {
              int v22 = 0;
              do
                unsigned __int8 v21 = v22++;
              while (((v20 >> v21) & 1) == 0);
            }
            else
            {
              unsigned __int8 v21 = 8;
            }
LABEL_26:
            int v23 = ASN1_item_new(&IPAddressOrRange_it);
            unsigned __int8 v11 = v23;
            if (v23)
            {
              *(_DWORD *)int v23 = 1;
              unint64_t v24 = (ASN1_BIT_STRING **)ASN1_item_new(&IPAddressRange_it);
              *((void *)v11 + 1) = v24;
              if (v24)
              {
                int v25 = v24;
                if (ASN1_BIT_STRING_set(*v24, (unsigned __int8 *)__s1, v15))
                {
                  if (asn1_abs_set_unused_bits((uint64_t)*v25, v17)
                    && ASN1_BIT_STRING_set(v25[1], (unsigned __int8 *)__s2, v19)
                    && asn1_abs_set_unused_bits((uint64_t)v25[1], v21))
                  {
                    *a1 = v11;
                    return 1;
                  }
                }
              }
            }
            goto LABEL_21;
          }
        }
      }
    }
    unsigned __int8 v11 = 0;
LABEL_21:
    ASN1_item_free(v11, &IPAddressOrRange_it);
    return 0;
  }
  return make_addressPrefix(a1, (unsigned __int8 *)__s1, a4, should_be_prefix);
}

uint64_t X509v3_addr_get_range(uint64_t a1, int a2, char *__dst, char *a4, int a5)
{
  if (a2 == 1) {
    int v5 = 4;
  }
  else {
    int v5 = 16 * (a2 == 2);
  }
  if (v5) {
    BOOL v6 = v5 <= a5;
  }
  else {
    BOOL v6 = 0;
  }
  if (!v6) {
    return 0;
  }
  if (extract_min_max(a1, __dst, a4, v5)) {
    return v5;
  }
  return 0;
}

uint64_t extract_min_max(uint64_t a1, char *__dst, char *a3, int a4)
{
  if (!a1 || !__dst || !a3) {
    return 0;
  }
  if (*(_DWORD *)a1 == 1)
  {
    unint64_t v8 = *(unsigned int ***)(a1 + 8);
    BOOL v6 = *v8;
    uint64_t v7 = v8[1];
  }
  else
  {
    if (*(_DWORD *)a1) {
      return 0;
    }
    BOOL v6 = *(unsigned int **)(a1 + 8);
    uint64_t v7 = v6;
  }
  if (!addr_expand(__dst, v6, a4, 0)) {
    return 0;
  }
  return addr_expand(a3, v7, a4, 1);
}

uint64_t X509v3_addr_is_canonical(STACK *a1)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 1;
  }
  for (int i = 0; i < sk_num(a1) - 1; ++i)
  {
    int v3 = sk_value(a1, i);
    uint64_t v4 = sk_value(a1, i + 1);
    uint64_t result = IPAddressFamily_afi_safi((int **)v3, 0, 0, 0);
    if (!result) {
      return result;
    }
    uint64_t result = IPAddressFamily_afi_safi((int **)v4, 0, 0, 0);
    if (!result) {
      return result;
    }
    BOOL v6 = *(int **)v3;
    int v7 = **(_DWORD **)v3;
    int v8 = **(_DWORD **)v4;
    int v9 = v7 - v8;
    if (v7 >= v8) {
      int v7 = **(_DWORD **)v4;
    }
    int v10 = memcmp(*((const void **)v6 + 1), *(const void **)(*(void *)v4 + 8), v7);
    if (v10) {
      int v11 = v10;
    }
    else {
      int v11 = v9;
    }
    if ((v11 & 0x80000000) == 0) {
      return 0;
    }
  }
  if (sk_num(a1) < 1) {
    return 1;
  }
  int v12 = 0;
  unsigned int v28 = 0;
  do
  {
    int v13 = sk_value(a1, v12);
    int v14 = IPAddressFamily_afi_length((int **)v13, (int *)&v28);
    uint64_t result = 0;
    if (!v13 || !v14) {
      break;
    }
    uint64_t v15 = *((void *)v13 + 1);
    if (!v15) {
      return 0;
    }
    if (*(_DWORD *)v15 == 1)
    {
      int v16 = *(const STACK **)(v15 + 8);
      if (!v16) {
        return 0;
      }
      uint64_t result = sk_num(*(const STACK **)(v15 + 8));
      if (!result) {
        return result;
      }
      if (sk_num(v16) >= 2)
      {
        int v17 = 0;
        uint64_t v18 = v28;
        size_t v19 = (int)v28;
        while (1)
        {
          unsigned int v20 = sk_value(v16, v17);
          unsigned __int8 v21 = sk_value(v16, ++v17);
          uint64_t result = extract_min_max((uint64_t)v20, __s1, v31, v19);
          if (!result) {
            return result;
          }
          uint64_t result = extract_min_max((uint64_t)v21, __s2, v29, v18);
          if (!result) {
            return result;
          }
          if ((memcmp(__s1, __s2, v19) & 0x80000000) == 0 || memcmp(__s1, v31, v19) > 0 || memcmp(__s2, v29, v19) > 0) {
            return 0;
          }
          uint64_t v22 = v18;
          do
          {
            if ((int)v22 < 1) {
              break;
            }
            int v23 = &__s2[v22--];
            int v24 = *(v23 - 1);
            *(v23 - 1) = v24 - 1;
          }
          while (!v24);
          if ((memcmp(v31, __s2, v19) & 0x80000000) == 0
            || *(_DWORD *)v20 && (range_should_be_prefix((uint64_t)__s1, (uint64_t)v31, v19) & 0x80000000) == 0)
          {
            return 0;
          }
          if (v17 >= sk_num(v16) - 1) {
            goto LABEL_40;
          }
        }
      }
      int v17 = 0;
LABEL_40:
      int v25 = sk_value(v16, v17);
      if (*(_DWORD *)v25 == 1)
      {
        int v26 = v28;
        uint64_t result = extract_min_max((uint64_t)v25, __s1, v31, v28);
        if (!result) {
          return result;
        }
        if (memcmp(__s1, v31, v26) > 0 || (range_should_be_prefix((uint64_t)__s1, (uint64_t)v31, v26) & 0x80000000) == 0) {
          return 0;
        }
      }
    }
    else if (*(_DWORD *)v15 || !*(void *)(v15 + 8))
    {
      return 0;
    }
    ++v12;
    int v27 = sk_num(a1);
    uint64_t result = 1;
  }
  while (v12 < v27);
  return result;
}

uint64_t IPAddressFamily_cmp(const void ****a1, const void ****a2)
{
  int v2 = **a1;
  int v3 = **a2;
  int v4 = *(_DWORD *)v2;
  unsigned int v5 = *(_DWORD *)v2 - *(_DWORD *)v3;
  if (*(_DWORD *)v2 >= *(_DWORD *)v3) {
    int v4 = *(_DWORD *)v3;
  }
  LODWORD(result) = memcmp(v2[1], v3[1], v4);
  if (result) {
    return result;
  }
  else {
    return v5;
  }
}

uint64_t IPAddressFamily_afi_length(int **a1, int *a2)
{
  __int16 v5 = 0;
  *a2 = 0;
  uint64_t result = IPAddressFamily_afi_safi(a1, &v5, 0, 0);
  if (result)
  {
    if (v5 == 1) {
      int v4 = 4;
    }
    else {
      int v4 = 16 * (v5 == 2);
    }
    *a2 = v4;
    return 1;
  }
  return result;
}

uint64_t range_should_be_prefix(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 < 1)
  {
    LODWORD(v3) = 0;
  }
  else
  {
    uint64_t v3 = 0;
    while (*(unsigned __int8 *)(a1 + v3) == *(unsigned __int8 *)(a2 + v3))
    {
      if (a3 == ++v3)
      {
        LODWORD(v3) = a3;
        break;
      }
    }
  }
  int v4 = a3 & (a3 >> 31);
  unsigned int v5 = a3 - 1;
  while (1)
  {
    int v6 = a3;
    BOOL v7 = __OFSUB__(a3--, 1);
    if (a3 < 0 != v7) {
      break;
    }
    if (!*(unsigned char *)(a1 + v5))
    {
      int v8 = *(unsigned __int8 *)(a2 + v5--);
      if (v8 == 255) {
        continue;
      }
    }
    goto LABEL_13;
  }
  int v6 = v4;
  a3 = v4 - 1;
LABEL_13:
  if ((int)v3 < a3) {
    return 0xFFFFFFFFLL;
  }
  if ((int)v3 >= v6) {
    return (8 * v3);
  }
  int v10 = *(unsigned __int8 *)(a1 + v3);
  int v11 = *(unsigned __int8 *)(a2 + v3);
  int v12 = v11 ^ v10;
  uint64_t result = 0xFFFFFFFFLL;
  if ((v11 ^ v10) <= 14)
  {
    switch(v12)
    {
      case 1:
        int v13 = 7;
        break;
      case 3:
        int v13 = 6;
        break;
      case 7:
        int v13 = 5;
        break;
      default:
        return result;
    }
  }
  else if (v12 > 62)
  {
    if (v12 == 63)
    {
      int v13 = 2;
    }
    else
    {
      if (v12 != 127) {
        return result;
      }
      int v13 = 1;
    }
  }
  else if (v12 == 15)
  {
    int v13 = 4;
  }
  else
  {
    if (v12 != 31) {
      return result;
    }
    int v13 = 3;
  }
  if ((v12 & v10) == 0)
  {
    unsigned int v14 = v13 | (8 * v3);
    if ((v12 & v11) == v12) {
      return v14;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t X509v3_addr_canonize(STACK *a1)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  unsigned __int16 v16 = 0;
  if (sk_num(a1) < 1)
  {
LABEL_33:
    sk_set_cmp_func(a1, (int (__cdecl *)(const char *const *, const char *const *))IPAddressFamily_cmp);
    sk_sort(a1);
    return X509v3_addr_is_canonical(a1);
  }
  else
  {
    int v2 = 0;
    while (1)
    {
      uint64_t v3 = sk_value(a1, v2);
      uint64_t result = IPAddressFamily_afi_safi((int **)v3, &v16, 0, 0);
      if (!result) {
        break;
      }
      if (v3)
      {
        uint64_t v5 = *((void *)v3 + 1);
        if (v5)
        {
          if (*(_DWORD *)v5 == 1)
          {
            int v6 = *(STACK **)(v5 + 8);
            if (v6)
            {
              int v7 = v16;
              int v17 = 0;
              if (v16 == 1) {
                size_t v8 = 4;
              }
              else {
                size_t v8 = 16 * (v16 == 2);
              }
              sk_sort(v6);
              if (sk_num(v6) >= 2)
              {
                int v9 = 0;
                while (1)
                {
                  int v10 = sk_value(v6, v9);
                  int v11 = sk_value(v6, v9 + 1);
                  if (!extract_min_max((uint64_t)v10, __s1, __s2, v8)
                    || !extract_min_max((uint64_t)v11, __dst, v18, v8)
                    || memcmp(__s1, __s2, v8) > 0
                    || memcmp(__dst, v18, v8) > 0
                    || (memcmp(__s2, __dst, v8) & 0x80000000) == 0)
                  {
                    return 0;
                  }
                  uint64_t v12 = v8;
                  do
                  {
                    if (v12-- < 1) {
                      break;
                    }
                    int v14 = __dst[v12];
                    __dst[v12] = v14 - 1;
                  }
                  while (!v14);
                  if (!memcmp(__s2, __dst, v8))
                  {
                    if (!make_addressRange((ASN1_VALUE **)&v17, __s1, v18, v7, v8)) {
                      return 0;
                    }
                    sk_set(v6, v9, v17);
                    sk_delete(v6, v9 + 1);
                    ASN1_item_free((ASN1_VALUE *)v10, &IPAddressOrRange_it);
                    ASN1_item_free((ASN1_VALUE *)v11, &IPAddressOrRange_it);
                  }
                  else
                  {
                    ++v9;
                  }
                  if (v9 >= sk_num(v6) - 1) {
                    goto LABEL_28;
                  }
                }
              }
              int v9 = 0;
LABEL_28:
              uint64_t v15 = sk_value(v6, v9);
              if (v15
                && *(_DWORD *)v15 == 1
                && (!extract_min_max((uint64_t)v15, __s1, __s2, v8) || memcmp(__s1, __s2, v8) >= 1))
              {
                return 0;
              }
            }
          }
        }
      }
      if (++v2 >= sk_num(a1)) {
        goto LABEL_33;
      }
    }
  }
  return result;
}

STACK *v2i_IPAddrBlocks(uint64_t a1, uint64_t a2, const STACK *a3)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  int v4 = sk_new((int (__cdecl *)(const char *const *, const char *const *))IPAddressFamily_cmp);
  if (!v4)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_addr.c", 1507);
    return v4;
  }
  __endptr = 0;
  if (sk_num(a3) < 1)
  {
LABEL_42:
    if (X509v3_addr_canonize(v4)) {
      return v4;
    }
LABEL_43:
    int v10 = 0;
    goto LABEL_59;
  }
  int v5 = 0;
  unint64_t v37 = v4;
  while (1)
  {
    int v6 = (const char **)sk_value(a3, v5);
    int v42 = 0;
    __errstrunsigned int p = 0;
    if (!name_cmp(v6[1], "IPv4"))
    {
      unsigned int v38 = 4;
      unsigned int v7 = 1;
      int v9 = "0123456789.";
      goto LABEL_11;
    }
    if (!name_cmp(v6[1], "IPv6"))
    {
      unsigned int v38 = 16;
      unsigned int v7 = 2;
      int v9 = "0123456789.:abcdefABCDEF";
LABEL_11:
      int v10 = strdup(v6[2]);
      int v11 = 0;
      if (!v10) {
        goto LABEL_45;
      }
      goto LABEL_24;
    }
    if (!name_cmp(v6[1], "IPv4-SAFI"))
    {
      unsigned int v38 = 4;
      unsigned int v7 = 1;
      size_t v8 = "0123456789.";
      goto LABEL_14;
    }
    if (name_cmp(v6[1], "IPv6-SAFI"))
    {
      ERR_put_error(34, 4095, 115, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_addr.c", 1530);
      ERR_asprintf_error_data("section:%s,name:%s,value:%s", *v6, v6[1], v6[2]);
      goto LABEL_43;
    }
    unsigned int v38 = 16;
    unsigned int v7 = 2;
    size_t v8 = "0123456789.:abcdefABCDEF";
LABEL_14:
    unint64_t v39 = v8;
    int v12 = *__error();
    *__error() = 0;
    unint64_t v13 = strtoul(v6[2], &__endptr, 0);
    if (!*v6[2]
      || (int v14 = __endptr, v15 = *__endptr, v15 > 0x3A)
      || ((1 << v15) & 0x400000100000200) == 0)
    {
      int v32 = 1560;
      goto LABEL_52;
    }
    unint64_t v16 = v13;
    int v17 = *__error();
    BOOL v18 = v16 == -1 && v17 == 34;
    if (v18 || v16 >= 0x100)
    {
      int v32 = 1567;
      goto LABEL_52;
    }
    *__error() = v12;
    int v42 = v16;
    size_t v19 = &v14[strspn(v14, " \t")];
    __endptr = v19;
    if (*v19 != 58) {
      break;
    }
    __endptr = &v19[strspn(v19 + 1, " \t") + 1];
    int v10 = strdup(__endptr);
    int v11 = (unsigned int *)&v42;
    int v4 = v37;
    int v9 = v39;
    if (!v10)
    {
LABEL_45:
      int v35 = 1594;
      goto LABEL_46;
    }
LABEL_24:
    unint64_t v40 = v11;
    if (!strcmp(v10, "inherit"))
    {
      if (X509v3_addr_add_inherit(v4, v7, v40)) {
        goto LABEL_41;
      }
      ERR_put_error(34, 4095, 165, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_addr.c", 1604);
      long long v33 = *(_OWORD *)v6;
      unint64_t v34 = v6[2];
      goto LABEL_62;
    }
    unsigned int v20 = v7;
    unsigned __int8 v21 = a3;
    int v22 = strspn(v10, v9);
    int v23 = &v10[v22];
    int v24 = strspn(v23, " \t") + v22;
    int v25 = v10[v24];
    const char *v23 = 0;
    if (a2i_ipadd(ipout, v10) != v38)
    {
      int v30 = 166;
      int v31 = 1619;
      goto LABEL_57;
    }
    if (v25)
    {
      uint64_t v26 = v24 + 1;
      if (v25 != 45)
      {
        if (v25 == 47)
        {
          unsigned int v27 = strtonum(&v10[(int)v26], 0, 8 * v38, (const char **)&__errstrp);
          if (__errstrp)
          {
            ERR_put_error(34, 4095, 116, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_addr.c", 1631);
            ERR_asprintf_error_data("section:%s,name:%s,value:%s", *v6, v6[1], v6[2]);
            int v4 = v37;
            goto LABEL_59;
          }
          int v4 = v37;
          a3 = v21;
          if (!X509v3_addr_add_prefix(v37, v20, v40, ipout, v27))
          {
            int v35 = 1637;
LABEL_46:
            ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_addr.c", v35);
            goto LABEL_59;
          }
          goto LABEL_41;
        }
        int v30 = 116;
        int v31 = 1672;
LABEL_57:
        ERR_put_error(34, 4095, v30, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_addr.c", v31);
        ERR_asprintf_error_data("section:%s,name:%s,value:%s", *v6, v6[1], v6[2]);
        goto LABEL_58;
      }
      int v28 = v26 + strspn(&v10[v26], " \t");
      int v29 = strspn(&v10[v28], v9);
      if (!v29 || v10[v28 + v29])
      {
        int v30 = 116;
        int v31 = 1645;
        goto LABEL_57;
      }
      if (a2i_ipadd(__s2, &v10[v28]) != v38)
      {
        int v30 = 166;
        int v31 = 1650;
        goto LABEL_57;
      }
      int v4 = v37;
      if (memcmp(ipout, __s2, v38) < 1)
      {
        a3 = v21;
        if (!X509v3_addr_add_range(v37, v20, v40, ipout, __s2))
        {
          int v35 = 1660;
          goto LABEL_46;
        }
        goto LABEL_41;
      }
      ERR_put_error(34, 4095, 116, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_addr.c", 1655);
      long long v33 = *(_OWORD *)v6;
      unint64_t v34 = v6[2];
LABEL_62:
      ERR_asprintf_error_data("section:%s,name:%s,value:%s", (const char *)v33, *((const char **)&v33 + 1), v34);
      goto LABEL_59;
    }
    int v4 = v37;
    a3 = v21;
    if (!X509v3_addr_add_prefix(v37, v20, v40, ipout, 8 * v38))
    {
      int v35 = 1667;
      goto LABEL_46;
    }
LABEL_41:
    free(v10);
    if (++v5 >= sk_num(a3)) {
      goto LABEL_42;
    }
  }
  int v32 = 1578;
LABEL_52:
  ERR_put_error(34, 4095, 164, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_addr.c", v32);
  ERR_asprintf_error_data("section:%s,name:%s,value:%s", *v6, v6[1], v6[2]);
  int v10 = 0;
LABEL_58:
  int v4 = v37;
LABEL_59:
  free(v10);
  sk_pop_free(v4, (void (__cdecl *)(void *))IPAddressFamily_free);
  return 0;
}

uint64_t i2r_IPAddrBlocks(int a1, STACK *a2, BIO *a3, int a4)
{
  unsigned __int16 v23 = 0;
  unsigned __int8 v22 = 0;
  if (sk_num(a2) >= 1)
  {
    int v7 = 0;
    int v21 = 0;
    do
    {
      size_t v8 = sk_value(a2, v7);
      if (!IPAddressFamily_afi_safi((int **)v8, &v23, &v22, &v21)) {
        goto LABEL_27;
      }
      if (v23 == 2)
      {
        BIO_printf(a3, "%*sIPv6");
      }
      else if (v23 == 1)
      {
        BIO_printf(a3, "%*sIPv4");
      }
      else
      {
        BIO_printf(a3, "%*sUnknown AFI %u");
      }
      if (!v21) {
        goto LABEL_27;
      }
      if (v22 <= 0x3Fu)
      {
        switch(v22)
        {
          case 1u:
            int v9 = a3;
            int v10 = " (Unicast)";
            goto LABEL_24;
          case 2u:
            int v9 = a3;
            int v10 = " (Multicast)";
            goto LABEL_24;
          case 3u:
            int v9 = a3;
            int v10 = " (Unicast/Multicast)";
            goto LABEL_24;
          case 4u:
            int v9 = a3;
            int v10 = " (MPLS)";
            goto LABEL_24;
          default:
            goto LABEL_35;
        }
      }
      if (v22 > 0x41u)
      {
        if (v22 == 66)
        {
          BIO_puts(a3, " (BGP MDT)");
LABEL_27:
          if (v8) {
            goto LABEL_28;
          }
          goto LABEL_48;
        }
        if (v22 == 128)
        {
          int v9 = a3;
          int v10 = " (MPLS-labeled VPN)";
          goto LABEL_24;
        }
      }
      else
      {
        if (v22 == 64)
        {
          int v9 = a3;
          int v10 = " (Tunnel)";
LABEL_24:
          BIO_puts(v9, v10);
          if (v8) {
            goto LABEL_28;
          }
          goto LABEL_48;
        }
        if (v22 == 65)
        {
          int v9 = a3;
          int v10 = " (VPLS)";
          goto LABEL_24;
        }
      }
LABEL_35:
      BIO_printf(a3, " (Unknown SAFI %u)", v22);
      if (v8)
      {
LABEL_28:
        int v11 = (unsigned int *)*((void *)v8 + 1);
        if (v11)
        {
          unsigned int v12 = *v11;
          if (v12 <= 1)
          {
            if (v12 == 1)
            {
              BIO_puts(a3, ":\n");
              uint64_t v13 = *((void *)v8 + 1);
              if (v13 && *(_DWORD *)v13 == 1) {
                int v14 = *(const STACK **)(v13 + 8);
              }
              else {
                int v14 = 0;
              }
              int v15 = v23;
              if (sk_num(v14) >= 1)
              {
                int v16 = 0;
                do
                {
                  int v17 = sk_value(v14, v16);
                  BIO_printf(a3, "%*s", a4 + 2, "");
                  if (*(_DWORD *)v17 == 1)
                  {
                    unsigned int v20 = (unsigned int **)*((void *)v17 + 1);
                    uint64_t result = i2r_address(a3, v15, 0, *v20);
                    if (!result) {
                      return result;
                    }
                    BIO_puts(a3, "-");
                    uint64_t result = i2r_address(a3, v15, 255, v20[1]);
                    if (!result) {
                      return result;
                    }
                    BIO_puts(a3, "\n");
                  }
                  else if (!*(_DWORD *)v17)
                  {
                    BOOL v18 = (unsigned int *)*((void *)v17 + 1);
                    uint64_t result = i2r_address(a3, v15, 0, v18);
                    if (!result) {
                      return result;
                    }
                    BIO_printf(a3, "/%d\n", 8 * *v18 - (v18[4] & 7));
                  }
                }
                while (++v16 < sk_num(v14));
              }
            }
            else
            {
              BIO_puts(a3, ": inherit\n");
            }
          }
        }
      }
LABEL_48:
      ++v7;
    }
    while (v7 < sk_num(a2));
  }
  return 1;
}

const STACK *X509v3_addr_inherits(const STACK *result)
{
  if (result)
  {
    unsigned __int16 v1 = result;
    if (sk_num(result) < 1)
    {
      return 0;
    }
    else
    {
      int v2 = 0;
      while (1)
      {
        uint64_t v3 = sk_value(v1, v2);
        if (v3)
        {
          uint64_t v4 = *((void *)v3 + 1);
          if (v4)
          {
            if (!*(_DWORD *)v4 && *(void *)(v4 + 8)) {
              break;
            }
          }
        }
        if (++v2 >= sk_num(v1)) {
          return 0;
        }
      }
      return (const STACK *)1;
    }
  }
  return result;
}

uint64_t X509v3_addr_subset(const STACK *a1, STACK *a2)
{
  uint64_t result = 1;
  if (a1 && a1 != a2)
  {
    if (!a2 || X509v3_addr_inherits(a1) || X509v3_addr_inherits(a2))
    {
      return 0;
    }
    else if (sk_num(a1) < 1)
    {
      return 1;
    }
    else
    {
      int v5 = 0;
      int v13 = 0;
      do
      {
        int v6 = sk_value(a1, v5);
        uint64_t result = (uint64_t)IPAddressFamily_find_in_parent(a2, v6);
        if (!result) {
          break;
        }
        uint64_t v7 = result;
        uint64_t result = IPAddressFamily_afi_length((int **)result, &v13);
        if (!result) {
          break;
        }
        if (v6 && (uint64_t v8 = *((void *)v6 + 1)) != 0 && *(_DWORD *)v8 == 1) {
          int v9 = *(STACK **)(v8 + 8);
        }
        else {
          int v9 = 0;
        }
        uint64_t v10 = *(void *)(v7 + 8);
        if (v10 && *(_DWORD *)v10 == 1) {
          int v11 = *(STACK **)(v10 + 8);
        }
        else {
          int v11 = 0;
        }
        uint64_t result = addr_contains(v11, v9, v13);
        if (!result) {
          break;
        }
        ++v5;
        int v12 = sk_num(a1);
        uint64_t result = 1;
      }
      while (v5 < v12);
    }
  }
  return result;
}

char *IPAddressFamily_find_in_parent(STACK *a1, char *a2)
{
  sk_set_cmp_func(a1, (int (__cdecl *)(const char *const *, const char *const *))IPAddressFamily_cmp);
  int v4 = sk_find(a1, a2);
  if (v4 < 0) {
    return 0;
  }
  return sk_value(a1, v4);
}

uint64_t addr_contains(STACK *a1, STACK *a2, int a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t result = 1;
  if (a2 && a1 != a2)
  {
    if (!a1) {
      return 0;
    }
    if (sk_num(a2) < 1)
    {
      return 1;
    }
    else
    {
      int v7 = 0;
      int v8 = 0;
LABEL_6:
      int v9 = sk_value(a2, v7);
      uint64_t result = extract_min_max((uint64_t)v9, __dst, __s2, a3);
      if (result)
      {
        while (v8 < sk_num(a1))
        {
          uint64_t v10 = sk_value(a1, v8);
          uint64_t result = extract_min_max((uint64_t)v10, v15, __s1, a3);
          if (!result) {
            return result;
          }
          if ((memcmp(__s1, __s2, a3) & 0x80000000) == 0)
          {
            if (memcmp(v15, __dst, a3) > 0) {
              return 0;
            }
            ++v7;
            int v11 = sk_num(a2);
            uint64_t result = 1;
            if (v7 < v11) {
              goto LABEL_6;
            }
            return result;
          }
          ++v8;
        }
        return 0;
      }
    }
  }
  return result;
}

uint64_t X509v3_addr_validate_path(uint64_t a1)
{
  if (sk_num(*(const STACK **)(a1 + 160)) >= 1 && *(void *)(a1 + 64))
  {
    int v2 = *(STACK **)(a1 + 160);
    return addr_validate_path_internal(a1, v2, 0);
  }
  else
  {
    *(_DWORD *)(a1 + 176) = 1;
    return 0;
  }
}

uint64_t addr_validate_path_internal(uint64_t a1, STACK *a2, STACK *a3)
{
  int v4 = a2;
  int v34 = 0;
  if (sk_num(a2) < 1)
  {
    int v6 = 0;
LABEL_5:
    sk_free(v6);
    if (!a1) {
      return 0;
    }
    goto LABEL_76;
  }
  if (a1 | (unint64_t)a3)
  {
    if (!a1 || *(void *)(a1 + 64))
    {
      if (a3)
      {
        if (!X509v3_addr_is_canonical(a3))
        {
          if (!a1) {
            goto LABEL_83;
          }
          *(void *)(a1 + 184) = 0;
          *(void *)(a1 + 172) = 0x29FFFFFFFFLL;
          uint64_t v9 = (*(uint64_t (**)(void, uint64_t))(a1 + 64))(0, a1);
          int v8 = 0;
          uint64_t v7 = 0;
          int v6 = 0;
          if (!v9) {
            goto LABEL_86;
          }
LABEL_15:
          sk_set_cmp_func(a3, (int (__cdecl *)(const char *const *, const char *const *))IPAddressFamily_cmp);
          uint64_t v10 = sk_dup(a3);
          if (v10)
          {
            int v6 = v10;
            if ((int)v7 < sk_num(v4))
            {
              int v32 = (STACK *)v4;
              do
              {
                int v8 = sk_value(v4, v7);
                if ((X509_get_extension_flags((uint64_t)v8) & 0x80) != 0)
                {
                  if (!a1) {
                    goto LABEL_84;
                  }
                  *(void *)(a1 + 184) = v8;
                  *(_DWORD *)(a1 + 172) = v7;
                  *(_DWORD *)(a1 + 176) = 41;
                  LODWORD(v9) = (*(uint64_t (**)(void, uint64_t))(a1 + 64))(0, a1);
                  if (!v9) {
                    goto LABEL_84;
                  }
                }
                int v11 = (STACK *)*((void *)v8 + 16);
                int v12 = sk_num(v6);
                unsigned int v33 = v9;
                if (v11)
                {
                  if (v12 >= 1)
                  {
                    for (int i = 0; i < sk_num(v6); ++i)
                    {
                      int v14 = sk_value(v6, i);
                      int v15 = IPAddressFamily_find_in_parent(v11, v14);
                      if (!v15)
                      {
                        if (!v14) {
                          goto LABEL_61;
                        }
                        uint64_t v23 = *((void *)v14 + 1);
                        if (!v23 || *(_DWORD *)v23 || !*(void *)(v23 + 8)) {
                          goto LABEL_61;
                        }
                        continue;
                      }
                      uint64_t v16 = v15;
                      uint64_t v17 = *((void *)v15 + 1);
                      if (v17 && !*(_DWORD *)v17 && *(void *)(v17 + 8)) {
                        continue;
                      }
                      if (v14)
                      {
                        uint64_t v18 = *((void *)v14 + 1);
                        if (v18)
                        {
                          if (*(_DWORD *)v18 == 1)
                          {
                            size_t v19 = *(STACK **)(v18 + 8);
                            goto LABEL_35;
                          }
                          if (!*(_DWORD *)v18 && *(void *)(v18 + 8)) {
                            goto LABEL_41;
                          }
                        }
                      }
                      size_t v19 = 0;
LABEL_35:
                      if (!v17) {
                        goto LABEL_5;
                      }
                      if (*(_DWORD *)v17 != 1) {
                        goto LABEL_5;
                      }
                      if (!v19) {
                        goto LABEL_5;
                      }
                      unsigned int v20 = v8;
                      int v21 = *(STACK **)(v17 + 8);
                      if (!v21 || !IPAddressFamily_afi_length((int **)v14, &v34)) {
                        goto LABEL_5;
                      }
                      int v22 = addr_contains(v21, v19, v34);
                      int v8 = v20;
                      if (v22)
                      {
LABEL_41:
                        sk_set(v6, i, v16);
                        continue;
                      }
                      if (!a1) {
                        goto LABEL_84;
                      }
                      *(void *)(a1 + 184) = v20;
                      *(_DWORD *)(a1 + 172) = v7;
                      *(_DWORD *)(a1 + 176) = 46;
                      unsigned int v33 = (*(uint64_t (**)(void, uint64_t))(a1 + 64))(0, a1);
                      if (!v33) {
                        goto LABEL_84;
                      }
                    }
                  }
                }
                else if (v12 >= 1)
                {
                  int v24 = 0;
                  while (1)
                  {
                    int v25 = sk_value(v6, v24);
                    if (!v25) {
                      break;
                    }
                    uint64_t v26 = *((void *)v25 + 1);
                    if (!v26 || *(_DWORD *)v26 || !*(void *)(v26 + 8)) {
                      break;
                    }
                    if (++v24 >= sk_num(v6)) {
                      goto LABEL_63;
                    }
                  }
LABEL_61:
                  if (!a1) {
                    goto LABEL_84;
                  }
                  *(void *)(a1 + 184) = v8;
                  *(_DWORD *)(a1 + 172) = v7;
                  *(_DWORD *)(a1 + 176) = 46;
                  unsigned int v33 = (*(uint64_t (**)(void, uint64_t))(a1 + 64))(0, a1);
                  if (!v33) {
                    goto LABEL_84;
                  }
                }
LABEL_63:
                LODWORD(v7) = v7 + 1;
                int v4 = v32;
                uint64_t v9 = v33;
              }
              while ((int)v7 < sk_num(v32));
            }
            unsigned int v27 = (const STACK *)*((void *)v8 + 16);
            if (v27 && sk_num(*((const STACK **)v8 + 16)) >= 1)
            {
              int v28 = 0;
              do
              {
                int v29 = sk_value(v27, v28);
                if (v29)
                {
                  uint64_t v30 = *((void *)v29 + 1);
                  if (v30)
                  {
                    if (!*(_DWORD *)v30)
                    {
                      if (*(void *)(v30 + 8))
                      {
                        if (!a1) {
                          goto LABEL_84;
                        }
                        *(void *)(a1 + 184) = v8;
                        *(_DWORD *)(a1 + 172) = v7;
                        *(_DWORD *)(a1 + 176) = 46;
                        uint64_t v9 = (*(uint64_t (**)(void, uint64_t))(a1 + 64))(0, a1);
                        if (!v9) {
                          goto LABEL_84;
                        }
                      }
                    }
                  }
                }
              }
              while (++v28 < sk_num(v27));
            }
            uint64_t v7 = v9;
LABEL_86:
            sk_free(v6);
            return v7;
          }
          ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_addr.c", 1885);
          if (a1)
          {
            int v6 = 0;
            uint64_t v7 = 0;
            *(_DWORD *)(a1 + 176) = 17;
            goto LABEL_86;
          }
LABEL_83:
          int v6 = 0;
LABEL_84:
          uint64_t v7 = 0;
          goto LABEL_86;
        }
        int v8 = 0;
        LODWORD(v7) = 0;
      }
      else
      {
        int v8 = sk_value(v4, 0);
        if ((X509_get_extension_flags((uint64_t)v8) & 0x80) != 0)
        {
          int v6 = 0;
          uint64_t v7 = 1;
          goto LABEL_86;
        }
        a3 = (STACK *)*((void *)v8 + 16);
        uint64_t v7 = 1;
        if (!a3)
        {
          int v6 = 0;
          goto LABEL_86;
        }
      }
      uint64_t v9 = 1;
      goto LABEL_15;
    }
    sk_free(0);
LABEL_76:
    uint64_t v7 = 0;
    *(_DWORD *)(a1 + 176) = 1;
    return v7;
  }
  sk_free(0);
  return 0;
}

uint64_t X509v3_addr_validate_resource_set(STACK *a1, STACK *a2, int a3)
{
  if (!a2) {
    return 1;
  }
  if (sk_num(a1) < 1 || !a3 && X509v3_addr_inherits(a2)) {
    return 0;
  }
  return addr_validate_path_internal(0, a1, a2);
}

uint64_t IPAddressFamily_afi_safi(int **a1, _WORD *a2, unsigned char *a3, int *a4)
{
  memset(v11, 0, sizeof(v11));
  __int16 v10 = 0;
  char v9 = 0;
  CBS_init(v11, *((void *)*a1 + 1), **a1);
  uint64_t result = CBS_get_u16(v11, &v10);
  if (result)
  {
    if (CBS_len((uint64_t)v11))
    {
      uint64_t result = CBS_get_u8(v11, &v9);
      if (!result) {
        return result;
      }
      int v8 = 1;
    }
    else
    {
      int v8 = 0;
    }
    if (CBS_len((uint64_t)v11))
    {
      return 0;
    }
    else
    {
      if (a2) {
        *a2 = v10;
      }
      if (a3)
      {
        *a3 = v9;
        *a4 = v8;
      }
      return 1;
    }
  }
  return result;
}

uint64_t v4IPAddressOrRange_cmp(uint64_t *a1, uint64_t *a2)
{
  return IPAddressOrRange_cmp(*a1, *a2, 4u);
}

uint64_t v6IPAddressOrRange_cmp(uint64_t *a1, uint64_t *a2)
{
  return IPAddressOrRange_cmp(*a1, *a2, 0x10u);
}

uint64_t IPAddressOrRange_cmp(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)a1 == 1)
  {
    if (!addr_expand(__s1, **(unsigned int ***)(a1 + 8), a3, 0)) {
      return 0xFFFFFFFFLL;
    }
    int v6 = 8 * a3;
  }
  else if (*(_DWORD *)a1)
  {
    int v6 = 0;
  }
  else
  {
    if (!addr_expand(__s1, *(unsigned int **)(a1 + 8), a3, 0)) {
      return 0xFFFFFFFFLL;
    }
    int v6 = 8 * **(_DWORD **)(a1 + 8) - (*(_DWORD *)(*(void *)(a1 + 8) + 16) & 7);
  }
  if (*(_DWORD *)a2 == 1)
  {
    if (!addr_expand(__s2, **(unsigned int ***)(a2 + 8), a3, 0)) {
      return 0xFFFFFFFFLL;
    }
    int v7 = 8 * a3;
  }
  else
  {
    if (!*(_DWORD *)a2)
    {
      if (addr_expand(__s2, *(unsigned int **)(a2 + 8), a3, 0))
      {
        int v7 = 8 * **(_DWORD **)(a2 + 8) - (*(_DWORD *)(*(void *)(a2 + 8) + 16) & 7);
        goto LABEL_16;
      }
      return 0xFFFFFFFFLL;
    }
    int v7 = 0;
  }
LABEL_16:
  LODWORD(result) = memcmp(__s1, __s2, a3);
  if (result) {
    return result;
  }
  else {
    return (v6 - v7);
  }
}

uint64_t addr_expand(char *__dst, unsigned int *a2, int a3, int a4)
{
  uint64_t result = 0;
  size_t v7 = *a2;
  if ((v7 & 0x80000000) == 0 && (int)v7 <= a3)
  {
    if (v7)
    {
      int v10 = -1 << (a2[4] & 7);
      memcpy(__dst, *((const void **)a2 + 1), v7);
      uint64_t v11 = &__dst[*a2];
      if (a4) {
        char v12 = *(v11 - 1) | ~(_BYTE)v10;
      }
      else {
        char v12 = *(v11 - 1) & v10;
      }
      *(v11 - 1) = v12;
    }
    if (a4) {
      int v13 = -1;
    }
    else {
      int v13 = 0;
    }
    memset(&__dst[*a2], v13, a3 - (uint64_t)(int)*a2);
    return 1;
  }
  return result;
}

uint64_t trim_end_u8(void *a1, int a2)
{
  unsigned __int8 v5 = 0;
  while (CBS_len((uint64_t)a1))
  {
    uint64_t result = CBS_peek_last_u8(a1, &v5);
    if (!result) {
      return result;
    }
    if (v5 != a2) {
      break;
    }
    uint64_t result = CBS_get_last_u8(a1, &v5);
    if (!result) {
      return result;
    }
  }
  return 1;
}

uint64_t i2r_address(BIO *bio, int a2, int a3, unsigned int *a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  if ((*a4 & 0x80000000) != 0) {
    return 0;
  }
  if (a2 == 1)
  {
    uint64_t result = addr_expand(&__dst, a4, 4, a3);
    if (!result) {
      return result;
    }
    BIO_printf(bio, "%d.%d.%d.%d");
  }
  else if (a2 == 2)
  {
    uint64_t result = addr_expand(&__dst, a4, 16, a3);
    if (!result) {
      return result;
    }
    uint64_t v7 = 0;
    do
    {
      if (v7 == -16) {
        goto LABEL_28;
      }
      int v8 = v7;
      if (*(&__dst + (v7 + 15))) {
        break;
      }
      v7 -= 2;
    }
    while (!*(&__dst + ((v8 + 14) & 0xFFFFFFFE)));
    int v9 = v8 + 16;
    if (v9 < 1)
    {
LABEL_28:
      BIO_puts(bio, ":");
LABEL_29:
      BIO_puts(bio, ":");
      return 1;
    }
    unint64_t v10 = 0;
    unint64_t v11 = v9 & 0xFFFFFFFE;
    do
    {
      unsigned int v12 = __rev16(*(unsigned __int16 *)(&__dst + v10));
      if (v10 >= 0xE) {
        int v13 = "";
      }
      else {
        int v13 = ":";
      }
      BIO_printf(bio, "%x%s", v12, v13);
      v10 += 2;
    }
    while (v10 < v11);
    if (v10 <= 0xF)
    {
      BIO_puts(bio, ":");
      if (!v10) {
        goto LABEL_29;
      }
    }
  }
  else
  {
    if (*a4)
    {
      uint64_t v14 = 0;
      do
      {
        if (v14) {
          int v15 = ":";
        }
        else {
          int v15 = "";
        }
        BIO_printf(bio, "%s%02x", v15, *(unsigned __int8 *)(*((void *)a4 + 1) + v14++));
      }
      while (v14 < (int)*a4);
    }
    BIO_printf(bio, "[%d]");
  }
  return 1;
}

DSO_METHOD *DSO_METHOD_null(void)
{
  return (DSO_METHOD *)&dso_meth_null;
}

uint64_t CMS_RecipientInfo_set0_password(uint64_t a1, char *__s, size_t a3)
{
  if (*(_DWORD *)a1 == 3)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    *(void *)(v3 + 32) = __s;
    if (__s)
    {
      if ((a3 & 0x8000000000000000) != 0) {
        a3 = strlen(__s);
      }
    }
    *(void *)(v3 + 40) = a3;
    return 1;
  }
  else
  {
    ERR_put_error(46, 4095, 177, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_pwri.c", 75);
    return 0;
  }
}

EVP_CIPHER_CTX *CMS_add0_recipient_password(uint64_t a1, int a2, int a3, uint64_t a4, char *a5, size_t a6, const EVP_CIPHER *a7)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  uint64_t v12 = cms_get0_enveloped(a1);
  if (!v12) {
    return 0;
  }
  uint64_t v13 = v12;
  if (!a7)
  {
    a7 = *(const EVP_CIPHER **)(*(void *)(v12 + 24) + 24);
    if (!a7)
    {
      int v14 = 126;
      int v15 = 116;
      goto LABEL_26;
    }
  }
  if (a3 >= 1 && a3 != 893)
  {
    int v14 = 179;
    int v15 = 120;
LABEL_26:
    ERR_put_error(46, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_pwri.c", v15);
    return 0;
  }
  uint64_t v16 = X509_ALGOR_new();
  if (!v16)
  {
    uint64_t v18 = 0;
    goto LABEL_23;
  }
  uint64_t v17 = EVP_CIPHER_CTX_new();
  uint64_t v18 = v17;
  if (!v17) {
    goto LABEL_23;
  }
  if (EVP_EncryptInit_ex(v17, a7, 0, 0, 0) <= 0)
  {
    int v28 = 6;
    int v29 = 134;
    goto LABEL_31;
  }
  int v19 = EVP_CIPHER_CTX_iv_length(v18);
  if (v19 >= 1)
  {
    arc4random_buf(__buf, v19);
    if (EVP_EncryptInit_ex(v18, 0, 0, 0, __buf) <= 0)
    {
      int v28 = 6;
      int v29 = 143;
    }
    else
    {
      unsigned int v20 = ASN1_TYPE_new();
      v16->parameter = v20;
      if (v20)
      {
        if (EVP_CIPHER_param_to_asn1(v18, v20) > 0) {
          goto LABEL_14;
        }
        int v28 = 102;
        int v29 = 152;
      }
      else
      {
        int v28 = 65;
        int v29 = 148;
      }
    }
LABEL_31:
    ERR_put_error(46, 4095, v28, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_pwri.c", v29);
    EVP_CIPHER_CTX_free(v18);
    goto LABEL_32;
  }
LABEL_14:
  int v21 = EVP_CIPHER_CTX_cipher(v18);
  int v22 = EVP_CIPHER_type(v21);
  v16->algorithm = OBJ_nid2obj(v22);
  EVP_CIPHER_CTX_free(v18);
  uint64_t v18 = (EVP_CIPHER_CTX *)ASN1_item_new(&CMS_RecipientInfo_it);
  if (!v18) {
    goto LABEL_23;
  }
  uint64_t v23 = ASN1_item_new(&CMS_PasswordRecipientInfo_it);
  v18->engine = v23;
  if (!v23) {
    goto LABEL_23;
  }
  int v24 = v23;
  LODWORD(v18->cipher) = 3;
  X509_ALGOR_free(*((X509_ALGOR **)v23 + 2));
  int v25 = X509_ALGOR_new();
  *((void *)v24 + 2) = v25;
  if (!v25
    || (**((void **)v24 + 2) = OBJ_nid2obj(893),
        uint64_t v26 = ASN1_TYPE_new(),
        (*(void *)(*((void *)v24 + 2) + 8) = v26) == 0)
    || !ASN1_item_pack(v16, &X509_ALGOR_it, (ASN1_OCTET_STRING **)&v26->value))
  {
LABEL_23:
    ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_pwri.c", 207);
    EVP_CIPHER_CTX_free(0);
    if (!v18)
    {
LABEL_32:
      X509_ALGOR_free(v16);
      return 0;
    }
LABEL_24:
    ASN1_item_free((ASN1_VALUE *)v18, &CMS_RecipientInfo_it);
    goto LABEL_32;
  }
  **(_DWORD **)(*((void *)v24 + 2) + 8) = 16;
  X509_ALGOR_free(v16);
  unsigned int v27 = PKCS5_pbkdf2_set(a2, 0, 0, -1, -1);
  *((void *)v24 + 1) = v27;
  if (!v27)
  {
    EVP_CIPHER_CTX_free(0);
    uint64_t v16 = 0;
    goto LABEL_24;
  }
  CMS_RecipientInfo_set0_password((uint64_t)v18, a5, a6);
  *(void *)int v24 = 0;
  if (!sk_push(*(STACK **)(v13 + 16), (char *)v18))
  {
    uint64_t v16 = 0;
    goto LABEL_23;
  }
  return v18;
}

EVP_CIPHER_CTX *cms_RecipientInfo_pwri_crypt(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (!*(void *)(v3 + 32))
  {
    int v24 = 178;
    int v25 = 342;
    goto LABEL_22;
  }
  uint64_t v4 = *(void *)(v3 + 16);
  if (!v4 || (uint64_t v6 = *(void *)(*(void *)(a1 + 8) + 24), OBJ_obj2nid(*(const ASN1_OBJECT **)v4) != 893))
  {
    int v24 = 179;
    int v25 = 348;
LABEL_22:
    ERR_put_error(46, 4095, v24, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_pwri.c", v25);
    return 0;
  }
  uint64_t v7 = *(void *)(v4 + 8);
  if (!v7
    || *(_DWORD *)v7 != 16
    || (int v8 = *(ASN1_STRING **)(v7 + 8)) == 0
    || (int v9 = (const ASN1_OBJECT **)ASN1_item_unpack(v8, &X509_ALGOR_it)) == 0)
  {
    int v24 = 176;
    int v25 = 359;
    goto LABEL_22;
  }
  unint64_t v10 = (X509_ALGOR *)v9;
  int v11 = OBJ_obj2nid(*v9);
  uint64_t v12 = OBJ_nid2sn(v11);
  cipherbyname = EVP_get_cipherbyname(v12);
  if (!cipherbyname)
  {
    int v24 = 148;
    int v25 = 365;
    goto LABEL_22;
  }
  int v14 = cipherbyname;
  int v15 = EVP_CIPHER_CTX_new();
  uint64_t v16 = v15;
  if (v15)
  {
    if (EVP_CipherInit_ex(v15, v14, 0, 0, 0, a3))
    {
      EVP_CIPHER_CTX_set_padding(v16, 0);
      if (EVP_CIPHER_asn1_to_param(v16, v10->parameter) <= 0)
      {
        int v27 = 102;
        int v28 = 379;
      }
      else
      {
        if ((EVP_PBE_CipherInit(**(ASN1_OBJECT ***)(v3 + 8), *(const char **)(v3 + 32), *(_DWORD *)(v3 + 40), *(ASN1_TYPE **)(*(void *)(v3 + 8) + 8), v16, a3) & 0x80000000) == 0)
        {
          size_t v33 = 0;
          if (a3)
          {
            unint64_t v17 = *(void *)(v6 + 40);
            int v18 = EVP_CIPHER_CTX_block_size(v16);
            int v19 = 0;
            if (v17 <= 0xFF)
            {
              int v20 = v18;
              size_t v21 = (v17 + v18 + 3) / v18 * v18;
              if (v21 >= 2 * v20)
              {
                size_t v33 = v21;
                int v22 = (unsigned __int8 *)malloc_type_malloc(v21, 0x2C9EFED8uLL);
                int v19 = v22;
                if (v22)
                {
                  if (kek_wrap_key(v22, &v33, *(unsigned char **)(v6 + 32), *(void *)(v6 + 40), v16))
                  {
                    uint64_t v23 = *(void *)(v3 + 24);
                    *(void *)(v23 + 8) = v19;
                    *(_DWORD *)uint64_t v23 = v33;
LABEL_35:
                    EVP_CIPHER_CTX_free(v16);
                    uint64_t v16 = (EVP_CIPHER_CTX *)1;
                    goto LABEL_31;
                  }
                }
              }
            }
          }
          else
          {
            int v29 = (unsigned __int8 *)malloc_type_malloc(**(int **)(v3 + 24), 0x1B8657BFuLL);
            int v19 = v29;
            if (v29)
            {
              if (kek_unwrap_key(v29, &v33, *(const unsigned __int8 **)(*(void *)(v3 + 24) + 8), **(int **)(v3 + 24), v16))
              {
                freezero(*(void **)(v6 + 32), *(void *)(v6 + 40));
                unint64_t v30 = v33;
                *(void *)(v6 + 32) = v19;
                *(void *)(v6 + 40) = v30;
                goto LABEL_35;
              }
              int v31 = 180;
              int v32 = 415;
            }
            else
            {
              int v31 = 65;
              int v32 = 410;
            }
            ERR_put_error(46, 4095, v31, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_pwri.c", v32);
          }
LABEL_30:
          EVP_CIPHER_CTX_free(v16);
          free(v19);
          uint64_t v16 = 0;
LABEL_31:
          X509_ALGOR_free(v10);
          return v16;
        }
        int v27 = 6;
        int v28 = 389;
      }
      ERR_put_error(46, 4095, v27, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_pwri.c", v28);
    }
    int v19 = 0;
    goto LABEL_30;
  }
  ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_pwri.c", 371);
  return v16;
}

uint64_t kek_wrap_key(unsigned __int8 *a1, unint64_t *a2, unsigned char *a3, size_t a4, EVP_CIPHER_CTX *ctx)
{
  int v10 = EVP_CIPHER_CTX_block_size(ctx);
  uint64_t result = 0;
  if (a4 <= 0xFF)
  {
    unint64_t v12 = (a4 + v10 + 3) / v10 * v10;
    if (v12 >= 2 * v10)
    {
      if (!a1) {
        goto LABEL_8;
      }
      *a1 = a4;
      a1[1] = ~*a3;
      a1[2] = ~a3[1];
      a1[3] = ~a3[2];
      memcpy(a1 + 4, a3, a4);
      if (v12 > a4 + 4) {
        arc4random_buf(&a1[a4 + 4], v12 - a4 - 4);
      }
      int outl = 0;
      uint64_t result = EVP_EncryptUpdate(ctx, a1, &outl, a1, v12);
      if (result)
      {
        uint64_t result = EVP_EncryptUpdate(ctx, a1, &outl, a1, v12);
        if (result)
        {
LABEL_8:
          *a2 = v12;
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t kek_unwrap_key(void *a1, size_t *a2, const unsigned __int8 *a3, unint64_t a4, EVP_CIPHER_CTX *ctx)
{
  int v10 = EVP_CIPHER_CTX_block_size(ctx);
  unint64_t v11 = 2 * v10;
  if (v11 > a4) {
    return 0;
  }
  uint64_t v12 = v10;
  if (a4 % v10) {
    return 0;
  }
  int v15 = (unsigned __int8 *)malloc_type_malloc(a4, 0xD22D1FABuLL);
  if (!v15)
  {
    ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_pwri.c", 239);
    return 0;
  }
  uint64_t v16 = v15;
  int outl = 0;
  unint64_t v17 = &v15[a4];
  if (EVP_DecryptUpdate(ctx, &v15[a4 - v11], &outl, &a3[a4 - v11], v11)
    && EVP_DecryptUpdate(ctx, v16, &outl, &v17[-v12], v12)
    && EVP_DecryptUpdate(ctx, v16, &outl, a3, a4 - v12)
    && EVP_DecryptInit_ex(ctx, 0, 0, 0, 0)
    && EVP_DecryptUpdate(ctx, v16, &outl, v16, a4)
    && ((v16[5] ^ v16[2]) & (v16[4] ^ v16[1]) & (v16[6] ^ v16[3])) == 0xFF
    && (size_t v18 = *v16, v18 - 4 <= a4))
  {
    *a2 = v18;
    memcpy(a1, v16 + 4, v18);
    uint64_t v13 = 1;
  }
  else
  {
    uint64_t v13 = 0;
  }
  freezero(v16, a4);
  return v13;
}

void ERR_load_ENGINE_strings(void)
{
  if (!ERR_func_error_string(ENGINE_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&ENGINE_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&ENGINE_str_reasons);
  }
}

const char *DES_options(void)
{
  if ((DES_options_init & 1) == 0)
  {
    snprintf(DES_options_buf, 0x20uLL, "des(%s,%s,%s,%s)", "idx", "cisc", "16", "int");
    DES_options_init = 1;
  }
  return DES_options_buf;
}

void DES_ecb_encrypt(const_DES_cblock *input, DES_cblock *output, DES_key_schedule *ks, int enc)
{
  v6[1] = *MEMORY[0x263EF8340];
  v6[0] = *(void *)input;
  DES_encrypt1((unsigned int *)v6, ks, enc);
  int v5 = HIDWORD(v6[0]);
  *(_DWORD *)output = v6[0];
  *(_DWORD *)&(*output)[4] = v5;
}

time_t x509_verify_asn1_time_to_time_t(int *a1, int a2)
{
  memset(&v5, 0, sizeof(v5));
  int v3 = ASN1_time_parse(*((void *)a1 + 1), *a1, &v5, a1[1]);
  if (v3 != -1
    && (v3 == 23 || v5.tm_year >= 150)
    && (v3 == 24 || v5.tm_year <= 149)
    && (!a2 || ASN1_time_tm_clamp_notafter()))
  {
    return timegm(&v5);
  }
  else
  {
    return -1;
  }
}

time_t x509_verify_cert_info_populate(uint64_t a1)
{
  int v2 = (int *)X509_getm_notBefore(a1);
  *(void *)(a1 + 208) = x509_verify_asn1_time_to_time_t(v2, 0);
  int v3 = (int *)X509_getm_notAfter(a1);
  time_t result = x509_verify_asn1_time_to_time_t(v3, 1);
  *(void *)(a1 + 216) = result;
  return result;
}

void *x509_verify_chain_new()
{
  uint64_t v0 = malloc_type_calloc(1uLL, 0x18uLL, 0x30040275E93A9uLL);
  if (!v0
    || (unsigned __int16 v1 = sk_new_null(), (*v0 = v1) == 0)
    || (int v2 = malloc_type_calloc(0x20uLL, 4uLL, 0x100004052888210uLL), (v0[1] = v2) == 0)
    || (int v3 = x509_constraints_names_new(512), (v0[2] = v3) == 0))
  {
    x509_verify_chain_free((uint64_t)v0);
    return 0;
  }
  return v0;
}

void x509_verify_chain_free(uint64_t a1)
{
  if (a1)
  {
    sk_pop_free(*(STACK **)a1, (void (__cdecl *)(void *))X509_free);
    *(void *)a1 = 0;
    free(*(void **)(a1 + 8));
    *(void *)(a1 + 8) = 0;
    x509_constraints_names_free(*(void **)(a1 + 16));
    free((void *)a1);
  }
}

char *x509_verify_chain_leaf(char **a1)
{
  time_t result = *a1;
  if (result) {
    return sk_value((const STACK *)result, 0);
  }
  return result;
}

uint64_t x509_verify_ctx_new_from_xsc(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  int v2 = x509_verify_ctx_new(0);
  uint64_t v3 = (uint64_t)v2;
  if (v2)
  {
    *(void *)int v2 = a1;
    uint64_t v4 = *(STACK **)(a1 + 24);
    if (!v4 || (tm v5 = X509_chain_up_ref(v4), (*(void *)(v3 + 48) = v5) != 0))
    {
      LODWORD(v6) = *(_DWORD *)(*(void *)(a1 + 48) + 40);
      uint64_t v6 = (v6 - 1) >= 0x1F ? 32 : v6;
      if ((unint64_t)(v6 - 33) >= 0xFFFFFFFFFFFFFFE0)
      {
        *(void *)(v3 + 80) = v6;
        return v3;
      }
    }
    x509_verify_ctx_free(v3);
    return 0;
  }
  return v3;
}

char *x509_verify_ctx_new(STACK *a1)
{
  int v2 = (char *)malloc_type_calloc(1uLL, 0x78uLL, 0x10B0040622242DAuLL);
  if (v2)
  {
    if (a1) {
      uint64_t v3 = X509_chain_up_ref(a1);
    }
    else {
      uint64_t v3 = sk_new_null();
    }
    *((void *)v2 + 5) = v3;
    if (!v3
      || (*(_OWORD *)(v2 + 72) = xmmword_23C709B30,
          *((void *)v2 + 11) = 256,
          uint64_t v4 = malloc_type_calloc(8uLL, 8uLL, 0x2004093837F09uLL),
          (*((void *)v2 + 1) = v4) == 0))
    {
      x509_verify_ctx_free((uint64_t)v2);
      return 0;
    }
  }
  return v2;
}

uint64_t x509_verify_ctx_set_max_depth(uint64_t a1, uint64_t a2)
{
  if ((unint64_t)(a2 - 33) < 0xFFFFFFFFFFFFFFE0) {
    return 0;
  }
  *(void *)(a1 + 80) = a2;
  return 1;
}

void x509_verify_ctx_free(uint64_t a1)
{
  if (a1)
  {
    sk_pop_free(*(STACK **)(a1 + 40), (void (__cdecl *)(void *))X509_free);
    if (*(void *)(a1 + 32))
    {
      unint64_t v2 = 0;
      do
        x509_verify_chain_free(*(void *)(*(void *)(a1 + 8) + 8 * v2++));
      while (v2 < *(void *)(a1 + 32));
    }
    sk_pop_free(*(STACK **)(a1 + 16), (void (__cdecl *)(void *))X509_free);
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 96) = 0;
    *(void *)(a1 + 104) = 0;
    *(_DWORD *)(a1 + 112) = 0;
    sk_pop_free(*(STACK **)(a1 + 48), (void (__cdecl *)(void *))X509_free);
    free(*(void **)(a1 + 8));
    free((void *)a1);
  }
}

uint64_t x509_verify_ctx_set_max_chains(uint64_t a1, uint64_t a2)
{
  if ((unint64_t)(a2 - 9) < 0xFFFFFFFFFFFFFFF8) {
    return 0;
  }
  *(void *)(a1 + 72) = a2;
  return 1;
}

uint64_t x509_verify_ctx_set_max_signatures(uint64_t a1, uint64_t a2)
{
  if ((unint64_t)(a2 - 100001) < 0xFFFFFFFFFFFE7960) {
    return 0;
  }
  *(void *)(a1 + 88) = a2;
  return 1;
}

uint64_t x509_verify_ctx_set_purpose(uint64_t a1, int a2)
{
  if ((a2 - 10) < 0xFFFFFFF7) {
    return 0;
  }
  *(_DWORD *)(a1 + 64) = a2;
  return 1;
}

BOOL x509_verify_ctx_set_intermediates(uint64_t a1, STACK *a2)
{
  uint64_t v3 = X509_chain_up_ref(a2);
  *(void *)(a1 + 48) = v3;
  return v3 != 0;
}

const char *x509_verify_ctx_error_string(uint64_t a1)
{
  return X509_verify_cert_error_string(*(int *)(a1 + 112));
}

uint64_t x509_verify_ctx_error_depth(uint64_t a1)
{
  return *(void *)(a1 + 104);
}

uint64_t x509_verify_ctx_chain(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 32) <= a2) {
    return 0;
  }
  else {
    return **(void **)(*(void *)(a1 + 8) + 8 * a2);
  }
}

uint64_t x509_verify(void **a1, uint64_t a2, const char *a3)
{
  if (!a1[5] || !a1[10]) {
    goto LABEL_5;
  }
  uint64_t v5 = a2;
  uint64_t v6 = (char *)*a1;
  if (!*a1)
  {
    BOOL v11 = 0;
    goto LABEL_14;
  }
  if (a2 | (unint64_t)a3)
  {
LABEL_5:
    int v7 = 65;
LABEL_6:
    *((_DWORD *)a1 + 28) = v7;
    goto LABEL_7;
  }
  uint64_t v5 = *((void *)v6 + 2);
  BOOL v11 = (*(void *)(*((void *)v6 + 6) + 24) & 0x80000) == 0;
  size_t v21 = sk_new_null();
  (*a1)[20] = v21;
  if (!v21 || !X509_up_ref(v5))
  {
LABEL_41:
    int v7 = 17;
    goto LABEL_6;
  }
  if (!sk_push((STACK *)(*a1)[20], (char *)v5))
  {
    X509_free((X509 *)v5);
    goto LABEL_41;
  }
  int v22 = (char *)*a1;
  *((_DWORD *)v22 + 43) = 0;
  *((void *)v22 + 23) = v5;
LABEL_14:
  uint64_t v12 = (const STACK **)x509_verify_chain_new();
  uint64_t v13 = (int *)(a1 + 14);
  if (!v12)
  {
    int *v13 = 17;
    goto LABEL_7;
  }
  int v14 = v12;
  if (!x509_verify_chain_append((uint64_t)v12, (X509 *)v5, (int *)a1 + 28))
  {
LABEL_48:
    x509_verify_chain_free((uint64_t)v14);
    goto LABEL_7;
  }
  while (1)
  {
    if (!x509v3_cache_extensions(v5)) {
      goto LABEL_27;
    }
    if (!*a1) {
      break;
    }
    int v15 = x509_vfy_lookup_cert_match(*a1, (X509 *)v5);
    if (v15)
    {
      X509_free((X509 *)v15);
      goto LABEL_20;
    }
LABEL_27:
    x509_verify_build_chains((uint64_t)a1, v5, v14, v11, a3);
    if (!v11) {
      goto LABEL_43;
    }
LABEL_28:
    if (a1[4]) {
      goto LABEL_43;
    }
    BOOL v11 = 0;
    size_t v18 = (char *)*a1;
    *((_DWORD *)v18 + 43) = a1[13];
    if (*((void *)v18 + 20))
    {
      sk_pop_free((STACK *)a1[2], (void (__cdecl *)(void *))X509_free);
      int v19 = X509_chain_up_ref((STACK *)(*a1)[20]);
      a1[2] = &v19->num;
      if (v19)
      {
        BOOL v11 = 0;
        a1[3] = (void *)vrev64_s32(*(int32x2_t *)((char *)*a1 + 172));
      }
      else
      {
        *((_DWORD *)a1 + 28) = 17;
        a1[13] = 0;
        int v20 = (char *)*a1;
        if (!*a1) {
          goto LABEL_48;
        }
        *(void *)(v20 + 172) = 0x1100000000;
        *((void *)v20 + 23) = 0;
        BOOL v11 = 0;
        if (!(*((unsigned int (**)(void))v20 + 8))(0)) {
          goto LABEL_48;
        }
      }
    }
  }
  if (sk_num((const STACK *)a1[5]) < 1) {
    goto LABEL_27;
  }
  int v16 = 0;
  while (1)
  {
    unint64_t v17 = sk_value((const STACK *)a1[5], v16);
    if (!X509_cmp((const X509 *)v17, (const X509 *)v5)) {
      break;
    }
    if (++v16 >= sk_num((const STACK *)a1[5])) {
      goto LABEL_27;
    }
  }
LABEL_20:
  if (v11 && (*(unsigned char *)(v5 + 57) & 0x20) == 0)
  {
    x509_verify_build_chains((uint64_t)a1, v5, v14, v11, a3);
    goto LABEL_28;
  }
  if (!x509_verify_ctx_add_chain((uint64_t *)a1, (uint64_t)v14, a3)) {
    goto LABEL_48;
  }
LABEL_43:
  x509_verify_chain_free((uint64_t)v14);
  uint64_t result = (uint64_t)a1[4];
  if (!*a1)
  {
    if (result)
    {
      int *v13 = 0;
      return result;
    }
    if (!*v13)
    {
      uint64_t result = 0;
      int *v13 = 1;
      return result;
    }
    return 0;
  }
  if (result)
  {
    if (x509_verify_ctx_set_xsc_chain((uint64_t *)a1, *a1[1], 1, 1)
      && x509_vfy_callback_indicate_completion((uint64_t)*a1))
    {
      return 1;
    }
LABEL_7:
    if (!*((_DWORD *)a1 + 28)) {
      *((_DWORD *)a1 + 28) = 1;
    }
    uint64_t v8 = (uint64_t)*a1;
    if (*a1)
    {
      int v9 = *(_DWORD *)(v8 + 176);
      if (!v9)
      {
        int v9 = 1;
        *(_DWORD *)(v8 + 176) = 1;
      }
      uint64_t result = 0;
      *((_DWORD *)a1 + 28) = v9;
      return result;
    }
    return 0;
  }
  if (!x509_verify_ctx_restore_xsc_error((uint64_t *)a1)) {
    goto LABEL_7;
  }
  uint64_t v23 = (uint64_t)*a1;
  if (!*((_DWORD *)*a1 + 44))
  {
    int v24 = *v13;
    if (!*v13)
    {
      int v24 = 1;
      int *v13 = 1;
    }
    *(_DWORD *)(v23 + 176) = v24;
  }
  return (*(int (**)(void))(v23 + 64))(0);
}

uint64_t x509_verify_chain_append(uint64_t a1, X509 *a2, int *a3)
{
  int v13 = 1;
  uint64_t v6 = *(void *)(a1 + 16);
  BOOL v7 = sk_num(*(const STACK **)a1) == 0;
  uint64_t result = x509_constraints_extract_names(v6, (uint64_t)a2, v7, &v13);
  if (!result)
  {
    int v12 = v13;
LABEL_9:
    *a3 = v12;
    return result;
  }
  X509_up_ref((uint64_t)a2);
  if (!sk_push(*(STACK **)a1, (char *)a2))
  {
    X509_free(a2);
    uint64_t result = 0;
    int v12 = 17;
    goto LABEL_9;
  }
  int v9 = sk_num(*(const STACK **)a1) - 1;
  uint64_t v10 = *(void *)(a1 + 8);
  *(_DWORD *)(v10 + 4 * v9) = *a3;
  if (v9 >= 2)
  {
    uint64_t v11 = v9 - 1;
    if (*(_DWORD *)(v10 + 4 * v11) == 20) {
      *(_DWORD *)(v10 + 4 * v11) = 0;
    }
  }
  return 1;
}

uint64_t x509_verify_ctx_add_chain(uint64_t *a1, uint64_t a2, const char *a3)
{
  uint64_t v6 = x509_verify_chain_last((const STACK **)a2);
  BOOL v7 = *(const STACK **)a2;
  if (*(void *)a2)
  {
    uint64_t v8 = sk_value(v7, 0);
    BOOL v7 = *(const STACK **)a2;
  }
  else
  {
    uint64_t v8 = 0;
  }
  int v9 = sk_num(v7);
  if (v9) {
    uint64_t v10 = v9 - 1;
  }
  else {
    uint64_t v10 = 0;
  }
  if (a1[4] >= (unint64_t)a1[9])
  {
    int v21 = 22;
    goto LABEL_22;
  }
  uint64_t v11 = *(void *)(a2 + 8);
  if (*(_DWORD *)(v11 + 4 * v10) == 20) {
    *(_DWORD *)(v11 + 4 * v10) = 0;
  }
  uint64_t v12 = *a1;
  if (*a1)
  {
    *(_DWORD *)(v12 + 172) = 0;
    *(_DWORD *)(v12 + 176) = 0;
    BOOL v20 = x509_verify_ctx_set_xsc_chain(a1, a2, 0, 1)
       && x509_vfy_check_trust(*a1) == 1
       && x509_vfy_check_chain_extensions(*a1)
       && X509v3_asid_validate_path(*a1)
       && X509v3_addr_validate_path(*a1)
       && x509_vfy_check_security_level(*a1)
       && (x509_constraints_chain(*(const STACK **)(*a1 + 160), (int *)(*a1 + 176), (int *)(*a1 + 172))
        || (int v13 = sk_value(*(const STACK **)(*a1 + 160), v10),
            uint64_t v14 = *a1,
            uint64_t v15 = *(int *)(*a1 + 172),
            *((_DWORD *)a1 + 28) = *(_DWORD *)(*a1 + 176),
            a1[13] = v15,
            *(void *)(v14 + 184) = v13,
            (*(unsigned int (**)(void))(v14 + 64))(0)))
       && x509_vfy_check_revocation(*a1)
       && x509_vfy_check_policy(*a1, v16, v17, v18, v19) != 0;
    uint64_t v25 = *a1;
    int v26 = *(_DWORD *)(*a1 + 176);
    if (v26)
    {
      uint64_t v27 = *(unsigned int *)(v25 + 172);
      if (v27 > 0x1F) {
        return 0;
      }
      *(_DWORD *)(*(void *)(a2 + 8) + 4 * v27) = v26;
      a1[13] = *(int *)(v25 + 172);
    }
    if (!v20) {
      return 0;
    }
  }
  uint64_t result = x509_verify_cert_valid(a1, (uint64_t)v8, 0);
  if (!result) {
    return result;
  }
  if (a3)
  {
    int v28 = strdup(a3);
    int v29 = v28;
    if (!v28)
    {
      int v31 = 17;
      goto LABEL_47;
    }
    size_t v30 = strlen(v28);
    if (!v30)
    {
      int v31 = 1;
      goto LABEL_47;
    }
    if (*v29 == 91 && v29[v30 - 1] == 93)
    {
      v29[v30 - 1] = 0;
      if ((int)X509_check_ip_asc((X509 *)v8, v29 + 1, 0) < 1)
      {
        int v31 = 64;
LABEL_47:
        *((_DWORD *)a1 + 28) = v31;
        free(v29);
        a1[13] = 0;
        uint64_t v32 = *a1;
        if (!*a1) {
          return 0;
        }
        *(_DWORD *)(v32 + 172) = 0;
        *(_DWORD *)(v32 + 176) = v31;
        *(void *)(v32 + 184) = v8;
        uint64_t result = (*(uint64_t (**)(void))(v32 + 64))(0);
        if (!result) {
          return result;
        }
        goto LABEL_49;
      }
    }
    else if ((int)X509_check_host((X509 *)v8, v29, v30, 32 * (*a1 == 0), 0) < 1)
    {
      int v31 = 62;
      goto LABEL_47;
    }
    free(v29);
  }
  else if (*a1)
  {
    uint64_t result = x509_vfy_check_id();
    if (!result)
    {
      *((_DWORD *)a1 + 28) = *(_DWORD *)(*a1 + 176);
      return result;
    }
  }
LABEL_49:
  if (!a1[13])
  {
    int v33 = *((_DWORD *)a1 + 28);
    if (v33 != 20) {
      **(_DWORD **)(a2 + 8) = v33;
    }
  }
  int v34 = x509_verify_chain_dup(a2);
  uint64_t v35 = a1[4];
  *(void *)(a1[1] + 8 * v35) = v34;
  if (v34)
  {
    a1[4] = v35 + 1;
    *((_DWORD *)a1 + 28) = 0;
    a1[13] = v10;
    return 1;
  }
  int v21 = 17;
LABEL_22:
  *((_DWORD *)a1 + 28) = v21;
  a1[13] = v10;
  uint64_t v22 = *a1;
  if (!*a1) {
    return 0;
  }
  *(_DWORD *)(v22 + 172) = v10;
  *(_DWORD *)(v22 + 176) = v21;
  *(void *)(v22 + 184) = v6;
  uint64_t v23 = *(uint64_t (**)(void))(v22 + 64);
  return v23(0);
}

uint64_t x509_verify_build_chains(uint64_t result, uint64_t a2, const STACK **a3, uint64_t a4, const char *a5)
{
  uint64_t v9 = result;
  if (*(void *)result && *(void *)(result + 32)) {
    return result;
  }
  uint64_t result = sk_num(*a3);
  int v10 = result - ((int)result > 0);
  if (*(void *)(v9 + 80) <= (unint64_t)v10)
  {
    *(_DWORD *)(v9 + 112) = 22;
    *(void *)(v9 + 104) = v10;
    uint64_t v11 = *(void *)v9;
    if (!*(void *)v9) {
      return result;
    }
    *(_DWORD *)(v11 + 172) = v10;
    *(_DWORD *)(v11 + 176) = 22;
    *(void *)(v11 + 184) = a2;
    uint64_t result = (*(uint64_t (**)(void))(v11 + 64))(0);
    if (!result) {
      return result;
    }
  }
  uint64_t v12 = *(void *)(v9 + 32);
  *(_DWORD *)(v9 + 112) = 20;
  *(void *)(v9 + 104) = v10;
  int v13 = *(_DWORD *)(v9 + 24);
  if (v13) {
    *(_DWORD *)(v9 + 112) = v13;
  }
  uint64_t v14 = *(int *)(v9 + 28);
  if (v14) {
    *(void *)(v9 + 104) = v14;
  }
  a = 0;
  uint64_t v15 = *(void *)v9;
  if (!*(void *)v9)
  {
    if (sk_num(*(const STACK **)(v9 + 40)) < 1)
    {
      unsigned int v19 = 0;
    }
    else
    {
      int v18 = 0;
      do
      {
        unsigned int v19 = sk_value(*(const STACK **)(v9 + 40), v18);
        if (x509_verify_potential_parent(v9, (X509 *)v19, (X509 *)a2))
        {
          if (a4) {
            int v20 = (*((_DWORD *)v19 + 14) >> 13) & 1;
          }
          else {
            int v20 = 1;
          }
          x509_verify_consider_candidate(v9, a2, v20, (uint64_t)v19, a3, a4, a5);
        }
        ++v18;
      }
      while (v18 < sk_num(*(const STACK **)(v9 + 40)));
    }
    a = (X509 *)v19;
    goto LABEL_37;
  }
  if ((*(unsigned char *)(a2 + 57) & 0x20) != 0)
  {
    if (v10) {
      int v16 = 19;
    }
    else {
      int v16 = 18;
    }
    *(_DWORD *)(v9 + 112) = v16;
  }
  uint64_t result = (*(uint64_t (**)(X509 **))(v15 + 72))(&a);
  if ((result & 0x80000000) == 0)
  {
    if (result)
    {
      if (x509_verify_potential_parent(v9, a, (X509 *)a2))
      {
        if (a4) {
          int v17 = (LODWORD(a->ex_pathlen) >> 13) & 1;
        }
        else {
          int v17 = 1;
        }
        x509_verify_consider_candidate(v9, a2, v17, (uint64_t)a, a3, a4, a5);
      }
      X509_free(a);
    }
LABEL_37:
    uint64_t result = *(void *)(v9 + 48);
    if (result)
    {
      uint64_t result = sk_num((const STACK *)result);
      if ((int)result >= 1)
      {
        int v22 = 0;
        do
        {
          a = (X509 *)sk_value(*(const STACK **)(v9 + 48), v22);
          if (x509_verify_potential_parent(v9, a, (X509 *)a2)) {
            x509_verify_consider_candidate(v9, a2, 0, (uint64_t)a, a3, a4, a5);
          }
          ++v22;
          uint64_t result = sk_num(*(const STACK **)(v9 + 48));
        }
        while (v22 < (int)result);
      }
    }
    if (*(void *)(v9 + 32) <= (unint64_t)(int)v12)
    {
      if (*(void *)(v9 + 104) == v10) {
        return x509_verify_ctx_set_xsc_chain((uint64_t *)v9, (uint64_t)a3, 0, 0);
      }
    }
    else
    {
      uint64_t v23 = *(void *)v9;
      if (*(void *)v9)
      {
        *(_DWORD *)(v23 + 172) = v10;
        *(_DWORD *)(v23 + 176) = 0;
        *(void *)(v23 + 184) = a2;
      }
    }
    return result;
  }
  *(_DWORD *)(v9 + 112) = 66;
  *(void *)(v9 + 104) = v10;
  uint64_t v21 = *(void *)v9;
  if (*(void *)v9)
  {
    *(_DWORD *)(v21 + 172) = v10;
    *(_DWORD *)(v21 + 176) = 66;
    *(void *)(v21 + 184) = a2;
    return (*(uint64_t (**)(void))(v21 + 64))(0);
  }
  return result;
}

uint64_t x509_verify_ctx_set_xsc_chain(uint64_t *a1, uint64_t a2, int a3, int a4)
{
  if (!*a1) {
    return 1;
  }
  int v8 = sk_num(*(const STACK **)a2);
  if (a4) {
    BOOL v9 = v8 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  int v10 = !v9;
  uint64_t v11 = *a1;
  *(_DWORD *)(v11 + 156) = v8 - v10;
  sk_pop_free(*(STACK **)(v11 + 160), (void (__cdecl *)(void *))X509_free);
  uint64_t v12 = X509_chain_up_ref(*(STACK **)a2);
  uint64_t v13 = *a1;
  *(void *)(*a1 + 160) = v12;
  if (v12)
  {
    if (a3)
    {
      *(_DWORD *)(v13 + 172) = 0;
      *(_DWORD *)(v13 + 176) = 0;
      if (sk_num(*(const STACK **)a2) >= 1)
      {
        uint64_t v14 = 0;
        while (1)
        {
          int v15 = *(_DWORD *)(*(void *)(a2 + 8) + 4 * v14);
          if (v15) {
            break;
          }
          if (++v14 >= sk_num(*(const STACK **)a2)) {
            return 1;
          }
        }
        uint64_t v18 = *a1;
        *(_DWORD *)(v18 + 172) = v14;
        *(_DWORD *)(v18 + 176) = v15;
      }
    }
    return 1;
  }
  *((_DWORD *)a1 + 28) = 17;
  a1[13] = 0;
  *(void *)(v13 + 172) = 0x1100000000;
  *(void *)(v13 + 184) = 0;
  int v16 = *(uint64_t (**)(void))(v13 + 64);
  return v16();
}

uint64_t x509_verify_ctx_restore_xsc_error(uint64_t *a1)
{
  if (!*a1 || a1[4] || !a1[2]) {
    return 1;
  }
  sk_pop_free(*(STACK **)(*a1 + 160), (void (__cdecl *)(void *))X509_free);
  uint64_t v3 = X509_chain_up_ref((STACK *)a1[2]);
  uint64_t v4 = *a1;
  *(void *)(*a1 + 160) = v3;
  if (v3)
  {
    *(int32x2_t *)(v4 + 172) = vrev64_s32((int32x2_t)a1[3]);
    return 1;
  }
  *((_DWORD *)a1 + 28) = 17;
  a1[13] = 0;
  *(void *)(v4 + 172) = 0x1100000000;
  *(void *)(v4 + 184) = 0;
  uint64_t v5 = *(uint64_t (**)(void))(v4 + 64);
  return v5();
}

char *x509_verify_chain_last(const STACK **a1)
{
  unint64_t v2 = *a1;
  if (!v2) {
    return 0;
  }
  int v3 = sk_num(v2);
  int v4 = v3 - 1;
  if (v3 < 1) {
    return 0;
  }
  uint64_t v5 = *a1;
  return sk_value(v5, v4);
}

uint64_t x509_verify_cert_valid(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  BOOL v6 = a3 != 0;
  if (a3) {
    uint64_t v7 = sk_num(*(const STACK **)a3);
  }
  else {
    uint64_t v7 = 0;
  }
  if (!x509v3_cache_extensions(a2))
  {
    int v12 = 1;
    goto LABEL_24;
  }
  if (!*a1)
  {
    if ((*(void *)(a2 + 56) & 0x200) != 0)
    {
      int v12 = 34;
    }
    else if (a3 && (*(void *)(a2 + 56) & 0x11) == 0x10)
    {
      int v12 = 24;
    }
    else
    {
      int v18 = *((_DWORD *)a1 + 16);
      if (v18 < 1 || !X509_check_purpose((X509 *)a2, v18, v6)) {
        goto LABEL_6;
      }
      int v12 = 26;
    }
LABEL_24:
    uint64_t result = 0;
    *((_DWORD *)a1 + 28) = v12;
    return result;
  }
LABEL_6:
  if (!a3) {
    goto LABEL_52;
  }
  int v8 = x509_verify_chain_last((const STACK **)a3);
  if (!v8 || X509_check_issued((X509 *)v8, (X509 *)a2)) {
    goto LABEL_52;
  }
  *((_DWORD *)a1 + 28) = 29;
  a1[13] = v7;
  uint64_t v17 = *a1;
  if (!*a1) {
    return 0;
  }
  *(_DWORD *)(v17 + 172) = v7;
  *(_DWORD *)(v17 + 176) = 29;
  *(void *)(v17 + 184) = a2;
  uint64_t result = (*(uint64_t (**)(void))(v17 + 64))(0);
  if (result)
  {
LABEL_52:
    if (*a1)
    {
      uint64_t v9 = *(void *)(*a1 + 48);
      uint64_t v10 = *(void *)(v9 + 24);
      if ((v10 & 2) != 0)
      {
        time_t v11 = *(void *)(v9 + 8);
        a1[7] = v9 + 8;
LABEL_19:
        time_t v13 = *(void *)(a2 + 208);
        if (v13 == -1)
        {
          int v14 = 13;
        }
        else if (v11 >= v13)
        {
          time_t v16 = *(void *)(a2 + 216);
          if (v16 == -1)
          {
            int v14 = 14;
          }
          else
          {
            if (v11 <= v16) {
              goto LABEL_37;
            }
            int v14 = 10;
          }
        }
        else
        {
          int v14 = 9;
        }
        *((_DWORD *)a1 + 28) = v14;
        a1[13] = v7;
        uint64_t v19 = *a1;
        if (*a1)
        {
          *(_DWORD *)(v19 + 172) = v7;
          *(_DWORD *)(v19 + 176) = v14;
          *(void *)(v19 + 184) = a2;
          uint64_t result = (*(uint64_t (**)(void))(v19 + 64))(0);
          if (!result) {
            return result;
          }
LABEL_37:
          int v24 = 1;
          if (!a3 || !*(void *)(a2 + 120)) {
            return 1;
          }
          int v20 = x509_constraints_names_new(512);
          if (v20)
          {
            uint64_t v21 = x509_constraints_names_new(512);
            if (v21)
            {
              if (x509_constraints_extract_constraints(a2, (uint64_t)v20, (uint64_t)v21, &v24)
                && x509_constraints_check(*(void **)(a3 + 16), (uint64_t)v20, (uint64_t)v21, &v24))
              {
                x509_constraints_names_free(v21);
                x509_constraints_names_free(v20);
                return 1;
              }
              goto LABEL_46;
            }
          }
          else
          {
            uint64_t v21 = 0;
          }
          int v24 = 17;
LABEL_46:
          *((_DWORD *)a1 + 28) = v24;
          x509_constraints_names_free(v21);
          x509_constraints_names_free(v20);
          int v22 = *((_DWORD *)a1 + 28);
          a1[13] = v7;
          uint64_t v23 = *a1;
          if (*a1)
          {
            *(_DWORD *)(v23 + 172) = v7;
            *(_DWORD *)(v23 + 176) = v22;
            *(void *)(v23 + 184) = a2;
            uint64_t result = (*(uint64_t (**)(void))(v23 + 64))(0);
            if (!result) {
              return result;
            }
            return 1;
          }
        }
        return 0;
      }
      if ((v10 & 0x200000) != 0) {
        goto LABEL_37;
      }
    }
    a1[7] = 0;
    time_t v11 = time(0);
    goto LABEL_19;
  }
  return result;
}

void *x509_verify_chain_dup(uint64_t a1)
{
  unint64_t v2 = malloc_type_calloc(1uLL, 0x18uLL, 0x30040275E93A9uLL);
  if (!v2) {
    goto LABEL_5;
  }
  int v3 = X509_chain_up_ref(*(STACK **)a1);
  *unint64_t v2 = v3;
  if (!v3) {
    goto LABEL_5;
  }
  int v4 = malloc_type_calloc(0x20uLL, 4uLL, 0x100004052888210uLL);
  v2[1] = v4;
  if (!v4) {
    goto LABEL_5;
  }
  uint64_t v5 = *(long long **)(a1 + 8);
  long long v6 = *v5;
  long long v7 = v5[1];
  long long v8 = v5[3];
  v4[2] = v5[2];
  v4[3] = v8;
  _OWORD *v4 = v6;
  v4[1] = v7;
  long long v9 = v5[4];
  long long v10 = v5[5];
  long long v11 = v5[7];
  v4[6] = v5[6];
  v4[7] = v11;
  v4[4] = v9;
  v4[5] = v10;
  int v12 = x509_constraints_names_dup(*(void **)(a1 + 16));
  v2[2] = v12;
  if (!v12)
  {
LABEL_5:
    x509_verify_chain_free((uint64_t)v2);
    return 0;
  }
  return v2;
}

uint64_t x509_verify_potential_parent(uint64_t a1, X509 *a2, X509 *a3)
{
  uint64_t result = x509v3_cache_extensions((uint64_t)a2);
  if (result)
  {
    if (*(void *)a1)
    {
      long long v7 = *(uint64_t (**)(void))(*(void *)a1 + 80);
      return v7();
    }
    else
    {
      return X509_check_issued(a3, a2) != 0;
    }
  }
  return result;
}

void x509_verify_consider_candidate(uint64_t a1, uint64_t a2, int a3, uint64_t a4, const STACK **a5, uint64_t a6, const char *a7)
{
  int v14 = sk_num(*a5);
  if (sk_num(*a5) < 1)
  {
LABEL_5:
    unint64_t v17 = *(void *)(a1 + 96);
    *(void *)(a1 + 96) = v17 + 1;
    if (v17 >= 0x101)
    {
      uint64_t v18 = v14;
      int v19 = 22;
      goto LABEL_7;
    }
    int v36 = a3;
    uint64_t v22 = a6;
    uint64_t v35 = (int *)(a1 + 112);
    unsigned int v23 = x509_issuer_cache_find(a4 + 144, a2 + 144);
    if ((v23 & 0x80000000) != 0)
    {
      int v34 = a7;
      pubkey = X509_get_pubkey((X509 *)a4);
      if (!pubkey)
      {
        int v26 = 6;
        *uint64_t v35 = 6;
        uint64_t v27 = v22;
        int v28 = v36;
        goto LABEL_20;
      }
      uint64_t v25 = pubkey;
      if (X509_verify((X509 *)a2, pubkey) <= 0)
      {
        unsigned int v23 = 0;
        *uint64_t v35 = 7;
      }
      else
      {
        unsigned int v23 = 1;
      }
      x509_issuer_cache_add((long long *)(a4 + 144), (long long *)(a2 + 144), v23);
      EVP_PKEY_free(v25);
      a7 = v34;
    }
    uint64_t v27 = v22;
    int v28 = v36;
    if (v23)
    {
LABEL_22:
      if (!x509_verify_cert_valid((uint64_t *)a1, a4, (uint64_t)a5)) {
        return;
      }
      size_t v30 = x509_verify_chain_dup((uint64_t)a5);
      if (v30)
      {
        uint64_t v31 = (uint64_t)v30;
        if (x509_verify_chain_append((uint64_t)v30, (X509 *)a4, v35))
        {
          if (v28)
          {
            if (x509_verify_ctx_set_xsc_chain((uint64_t *)a1, v31, 0, 1)) {
              x509_verify_ctx_add_chain((uint64_t *)a1, v31, a7);
            }
          }
          else
          {
            x509_verify_build_chains(a1, a4, v31, v27, a7);
          }
        }
        else
        {
          int v32 = *(_DWORD *)(a1 + 112);
          *(void *)(a1 + 104) = v14;
          uint64_t v33 = *(void *)a1;
          if (*(void *)a1)
          {
            *(_DWORD *)(v33 + 172) = v14;
            *(_DWORD *)(v33 + 176) = v32;
            *(void *)(v33 + 184) = a4;
            (*(void (**)(void))(v33 + 64))(0);
          }
        }
        x509_verify_chain_free(v31);
        return;
      }
      uint64_t v18 = v14;
      int v19 = 17;
LABEL_7:
      *(_DWORD *)(a1 + 112) = v19;
      *(void *)(a1 + 104) = v18;
      uint64_t v20 = *(void *)a1;
      if (*(void *)a1)
      {
        *(_DWORD *)(v20 + 172) = v14;
        *(_DWORD *)(v20 + 176) = v19;
        *(void *)(v20 + 184) = a4;
        uint64_t v21 = *(void (**)(void))(v20 + 64);
        v21(0);
      }
      return;
    }
    int v26 = *v35;
LABEL_20:
    *(void *)(a1 + 104) = v14;
    uint64_t v29 = *(void *)a1;
    if (!*(void *)a1) {
      return;
    }
    *(_DWORD *)(v29 + 172) = v14;
    *(_DWORD *)(v29 + 176) = v26;
    *(void *)(v29 + 184) = a4;
    if (!(*(unsigned int (**)(void))(v29 + 64))(0)) {
      return;
    }
    goto LABEL_22;
  }
  int v15 = 0;
  while (1)
  {
    time_t v16 = sk_value(*a5, v15);
    if (!X509_cmp((const X509 *)v16, (const X509 *)a4)) {
      break;
    }
    if (++v15 >= sk_num(*a5)) {
      goto LABEL_5;
    }
  }
}

uint64_t Gost2814789_set_sbox(uint64_t a1, int a2)
{
  uint64_t v2 = 0;
  int v3 = 824;
  while (v3 != a2)
  {
    int v3 = *(_DWORD *)&gost_cipher_list[v2 + 24];
    v2 += 24;
    if (v2 == 192) {
      return 0;
    }
  }
  uint64_t v4 = *(void *)&gost_cipher_list[v2 + 8];
  *(unsigned char *)(a1 + 4132) = *(unsigned char *)(a1 + 4132) & 0xFE | gost_cipher_list[v2 + 16] & 1;
  uint64_t v6 = -256;
  do
  {
    long long v7 = (unsigned __int8 *)(v4 + ((v6 + 256) >> 4));
    long long v8 = (unsigned __int8 *)(v4 + ((v6 + 256) & 0xF));
    *(_DWORD *)(a1 + 32) = ((v8[16] << 24) | (*v7 << 28)) >> 21;
    HIDWORD(v9) = (v8[48] << 16) | (v7[32] << 20);
    LODWORD(v9) = HIDWORD(v9);
    *(_DWORD *)(a1 + 1056) = v9 >> 21;
    *(_DWORD *)(a1 + 2080) = (v8[80] << 19) | (v7[64] << 23);
    *(_DWORD *)(a1 + 3104) = (v8[112] << 11) | (v7[96] << 15);
    a1 += 4;
  }
  while (!__CFADD__(v6++, 1));
  return 1;
}

uint64_t Gost2814789_set_key(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 != 256) {
    return 0;
  }
  for (uint64_t i = 0; i != 32; i += 4)
  {
    int v4 = *(unsigned __int8 *)(a2 + i);
    *(_DWORD *)(a1 + i) = v4;
    int v5 = v4 | (*(unsigned __int8 *)(a2 + i + 1) << 8);
    *(_DWORD *)(a1 + i) = v5;
    int v6 = v5 | (*(unsigned __int8 *)(a2 + i + 2) << 16);
    *(_DWORD *)(a1 + i) = v6;
    *(_DWORD *)(a1 + i) = v6 | (*(unsigned __int8 *)(a2 + i + 3) << 24);
  }
  *(_DWORD *)(a1 + 4128) = 0;
  return 1;
}

uint64_t Gost2814789_cryptopro_key_mesh(int *a1)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  Gost2814789_decrypt(CryptoProKeyMeshingKey, v4, a1);
  Gost2814789_decrypt(&CryptoProKeyMeshingKey[2], &v5, a1);
  Gost2814789_decrypt(&CryptoProKeyMeshingKey[4], &v6, a1);
  uint64_t result = Gost2814789_decrypt(&CryptoProKeyMeshingKey[6], &v7, a1);
  for (uint64_t i = 0; i != 8; ++i)
    a1[i] = v4[i];
  a1[1032] = 0;
  return result;
}

STACK *__cdecl i2v_GENERAL_NAMES(X509V3_EXT_METHOD *method, GENERAL_NAMES *gen, STACK *extlist)
{
  if (extlist)
  {
    int v4 = extlist;
    int v5 = 0;
  }
  else
  {
    int v4 = sk_new_null();
    int v5 = v4;
    if (!v4) {
      return v4;
    }
  }
  if (sk_num(gen) >= 1)
  {
    int v6 = 0;
    while (1)
    {
      int v7 = sk_value(gen, v6);
      if (!v7) {
        break;
      }
      uint64_t v8 = i2v_GENERAL_NAME((X509V3_EXT_METHOD *)v7, (GENERAL_NAME *)v7, v4);
      if (!v8) {
        break;
      }
      int v4 = v8;
      if (++v6 >= sk_num(gen)) {
        return v4;
      }
    }
    sk_pop_free(v5, (void (__cdecl *)(void *))X509V3_conf_free);
    return 0;
  }
  return v4;
}

STACK *v2i_subject_alt(X509V3_EXT_METHOD *a1, X509V3_CTX *a2, const STACK *a3)
{
  int v6 = sk_new_null();
  if (!v6)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 402);
    return v6;
  }
  if (sk_num(a3) >= 1)
  {
    int v7 = 0;
    while (1)
    {
      uint64_t v8 = (CONF_VALUE *)sk_value(a3, v7);
      if (!name_cmp(v8->name, "email"))
      {
        value = v8->value;
        if (value)
        {
          if (!strcmp(value, "copy")) {
            break;
          }
        }
      }
      if (!name_cmp(v8->name, "email"))
      {
        int v15 = v8->value;
        if (v15)
        {
          if (!strcmp(v15, "move"))
          {
            uint64_t v12 = (uint64_t)a2;
            time_t v13 = v6;
            int v14 = 1;
LABEL_16:
            if (!copy_email(v12, v13, v14)) {
              goto LABEL_20;
            }
            goto LABEL_8;
          }
        }
      }
      unint64_t v9 = (char *)v2i_GENERAL_NAME_ex(0, a1, a2, v8, 0);
      if (!v9) {
        goto LABEL_20;
      }
      long long v10 = (GENERAL_NAME *)v9;
      if (!sk_push(v6, v9))
      {
        GENERAL_NAME_free(v10);
LABEL_20:
        sk_pop_free(v6, (void (__cdecl *)(void *))GENERAL_NAME_free);
        return 0;
      }
LABEL_8:
      if (++v7 >= sk_num(a3)) {
        return v6;
      }
    }
    uint64_t v12 = (uint64_t)a2;
    time_t v13 = v6;
    int v14 = 0;
    goto LABEL_16;
  }
  return v6;
}

STACK *v2i_issuer_alt(X509V3_EXT_METHOD *a1, X509V3_CTX *a2, const STACK *a3)
{
  int v6 = sk_new_null();
  if (!v6)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 326);
    return v6;
  }
  if (sk_num(a3) >= 1)
  {
    for (int i = 0; i < sk_num(a3); ++i)
    {
      uint64_t v8 = (CONF_VALUE *)sk_value(a3, i);
      if (!name_cmp(v8->name, "issuer") && (value = v8->value) != 0 && !strcmp(value, "copy"))
      {
        if (!a2) {
          goto LABEL_25;
        }
        if (a2->flags != 1)
        {
          issuer_cert = a2->issuer_cert;
          if (!issuer_cert)
          {
LABEL_25:
            int v19 = 127;
            int v20 = 365;
            goto LABEL_27;
          }
          int ext_by_NID = X509_get_ext_by_NID(issuer_cert, 85, -1);
          if ((ext_by_NID & 0x80000000) == 0)
          {
            ext = X509_get_ext(a2->issuer_cert, ext_by_NID);
            if (!ext || (int v15 = (const STACK *)X509V3_EXT_d2i(ext)) == 0)
            {
              int v19 = 126;
              int v20 = 373;
              goto LABEL_27;
            }
            time_t v16 = (STACK *)v15;
            if (sk_num(v15) >= 1)
            {
              int v17 = 0;
              while (1)
              {
                uint64_t v18 = sk_value(v16, v17);
                if (!sk_push(v6, v18)) {
                  break;
                }
                if (++v17 >= sk_num(v16)) {
                  goto LABEL_21;
                }
              }
              int v19 = 65;
              int v20 = 380;
LABEL_27:
              ERR_put_error(34, 4095, v19, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", v20);
LABEL_28:
              sk_pop_free(v6, (void (__cdecl *)(void *))GENERAL_NAME_free);
              return 0;
            }
LABEL_21:
            sk_free(v16);
          }
        }
      }
      else
      {
        unint64_t v9 = (char *)v2i_GENERAL_NAME_ex(0, a1, a2, v8, 0);
        if (!v9) {
          goto LABEL_28;
        }
        long long v10 = (GENERAL_NAME *)v9;
        if (!sk_push(v6, v9))
        {
          GENERAL_NAME_free(v10);
          goto LABEL_28;
        }
      }
    }
  }
  return v6;
}

STACK *__cdecl i2v_GENERAL_NAME(X509V3_EXT_METHOD *method, GENERAL_NAME *gen, STACK *ret)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  extlist = ret;
  if (ret)
  {
    int v4 = 0;
  }
  else
  {
    uint64_t result = sk_new_null();
    int v4 = result;
    extlist = result;
    if (!result) {
      return result;
    }
  }
  switch(gen->type)
  {
    case 0:
      int v6 = "othername";
      goto LABEL_12;
    case 1:
      int v7 = (const unsigned __int8 *)*((void *)gen->d.ptr + 1);
      uint64_t v8 = "email";
      goto LABEL_14;
    case 2:
      int v7 = (const unsigned __int8 *)*((void *)gen->d.ptr + 1);
      uint64_t v8 = "DNS";
      goto LABEL_14;
    case 3:
      int v6 = "X400Name";
      goto LABEL_12;
    case 4:
      if (!X509_NAME_oneline(gen->d.directoryName, buf, 256)) {
        goto LABEL_27;
      }
      int v6 = "DirName";
      goto LABEL_24;
    case 5:
      int v6 = "EdiPartyName";
LABEL_12:
      unint64_t v9 = "<unsupported>";
      goto LABEL_25;
    case 6:
      int v7 = (const unsigned __int8 *)*((void *)gen->d.ptr + 1);
      uint64_t v8 = "URI";
LABEL_14:
      if (!X509V3_add_value_uchar(v8, v7, &extlist)) {
        goto LABEL_27;
      }
      goto LABEL_26;
    case 7:
      ptr = gen->d.ptr;
      long long v11 = (unsigned __int8 *)*((void *)ptr + 1);
      int v12 = *(_DWORD *)ptr;
      if (v12 == 16)
      {
        buf[0] = 0;
        snprintf(__str, 5uLL, "%X", __rev16(*(unsigned __int16 *)v11));
        __strlcat_chk();
        uint64_t v13 = 0;
        do
        {
          __strlcat_chk();
          snprintf(__str, 5uLL, "%X", __rev16(*(unsigned __int16 *)&v11[v13 + 2]));
          __strlcat_chk();
          v13 += 2;
        }
        while (v13 != 14);
      }
      else
      {
        if (v12 != 4)
        {
          int v6 = "IP Address";
          unint64_t v9 = "<invalid>";
          goto LABEL_25;
        }
        snprintf(buf, 0x100uLL, "%d.%d.%d.%d", *v11, v11[1], v11[2], v11[3]);
      }
      int v6 = "IP Address";
LABEL_24:
      unint64_t v9 = buf;
LABEL_25:
      if (X509V3_add_value(v6, v9, &extlist))
      {
LABEL_26:
        uint64_t result = extlist;
      }
      else
      {
LABEL_27:
        sk_pop_free(v4, (void (__cdecl *)(void *))X509V3_conf_free);
        uint64_t result = 0;
      }
      break;
    case 8:
      if (!i2t_ASN1_OBJECT(buf, 256, gen->d.registeredID)) {
        goto LABEL_27;
      }
      int v6 = "Registered ID";
      goto LABEL_24;
    default:
      goto LABEL_26;
  }
  return result;
}

int GENERAL_NAME_print(BIO *out, GENERAL_NAME *gen)
{
  switch(gen->type)
  {
    case 0:
      BIO_printf(out, "othername:<unsupported>");
      break;
    case 1:
      BIO_printf(out, "email:%.*s");
      break;
    case 2:
      BIO_printf(out, "DNS:%.*s");
      break;
    case 3:
      BIO_printf(out, "X400Name:<unsupported>");
      break;
    case 4:
      BIO_printf(out, "DirName: ");
      X509_NAME_print_ex(out, gen->d.directoryName, 0, 0x82031FuLL);
      break;
    case 5:
      BIO_printf(out, "EdiPartyName:<unsupported>");
      break;
    case 6:
      BIO_printf(out, "URI:%.*s");
      break;
    case 7:
      ptr = gen->d.ptr;
      uint64_t v5 = *((void *)ptr + 1);
      int v6 = *(_DWORD *)ptr;
      if (v6 == 16)
      {
        BIO_printf(out, "IP Address");
        uint64_t v7 = 0;
        do
        {
          BIO_printf(out, ":%X", __rev16(*(unsigned __int16 *)(v5 + v7)));
          v7 += 2;
        }
        while (v7 != 16);
        BIO_puts(out, "\n");
      }
      else if (v6 == 4)
      {
        BIO_printf(out, "IP Address:%d.%d.%d.%d");
      }
      else
      {
        BIO_printf(out, "IP Address:<invalid>");
      }
      break;
    case 8:
      BIO_printf(out, "Registered ID");
      i2a_ASN1_OBJECT(out, gen->d.registeredID);
      break;
    default:
      return 1;
  }
  return 1;
}

GENERAL_NAMES *__cdecl v2i_GENERAL_NAMES(X509V3_EXT_METHOD *method, X509V3_CTX *ctx, STACK *nval)
{
  int v6 = sk_new_null();
  if (v6)
  {
    if (sk_num(nval) >= 1)
    {
      int v7 = 0;
      while (1)
      {
        uint64_t v8 = sk_value(nval, v7);
        unint64_t v9 = (char *)v2i_GENERAL_NAME_ex(0, method, ctx, (CONF_VALUE *)v8, 0);
        if (!v9) {
          break;
        }
        long long v10 = (GENERAL_NAME *)v9;
        if (!sk_push(v6, v9))
        {
          GENERAL_NAME_free(v10);
          break;
        }
        if (++v7 >= sk_num(nval)) {
          return v6;
        }
      }
      sk_pop_free(v6, (void (__cdecl *)(void *))GENERAL_NAME_free);
      return 0;
    }
  }
  else
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 500);
  }
  return v6;
}

GENERAL_NAME *__cdecl v2i_GENERAL_NAME(X509V3_EXT_METHOD *method, X509V3_CTX *ctx, CONF_VALUE *cnf)
{
  return v2i_GENERAL_NAME_ex(0, method, ctx, cnf, 0);
}

GENERAL_NAME *__cdecl v2i_GENERAL_NAME_ex(GENERAL_NAME *out, X509V3_EXT_METHOD *method, X509V3_CTX *ctx, CONF_VALUE *cnf, int is_nc)
{
  uint64_t v20 = 0;
  unint64_t v19 = 0;
  value = cnf->value;
  if (!value)
  {
    ERR_put_error(34, 4095, 124, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 634);
    return 0;
  }
  name = cnf->name;
  if (name_cmp(name, "email"))
  {
    if (name_cmp(name, "URI"))
    {
      if (name_cmp(name, "DNS"))
      {
        if (name_cmp(name, "RID"))
        {
          if (name_cmp(name, "IP"))
          {
            if (name_cmp(name, "dirName"))
            {
              if (name_cmp(name, "otherName"))
              {
                ERR_put_error(34, 4095, 117, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 653);
                ERR_asprintf_error_data("name=%s", name);
                return 0;
              }
              int v12 = 0;
            }
            else
            {
              int v12 = 4;
            }
          }
          else
          {
            int v12 = 7;
          }
        }
        else
        {
          int v12 = 8;
        }
      }
      else
      {
        int v12 = 2;
      }
    }
    else
    {
      int v12 = 6;
    }
  }
  else
  {
    int v12 = 1;
  }
  uint64_t v13 = a2i_GENERAL_NAME(out, v10, ctx, v12, value, is_nc);
  long long v11 = v13;
  if (!v13) {
    return v11;
  }
  memset(v18, 0, sizeof(v18));
  if (is_nc)
  {
    uint64_t v17 = 0;
    if (x509_constraints_validate((unsigned int *)v13, &v17, 0))
    {
      x509_constraints_name_free(v17);
      return v11;
    }
    ERR_put_error(34, 4095, 119, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 670);
    ERR_asprintf_error_data("name=%s");
LABEL_36:
    if (!out) {
      GENERAL_NAME_free(v11);
    }
    return 0;
  }
  int v15 = x509_constraints_general_to_bytes((unsigned int *)v13, &v20, &v19);
  CBS_init(v18, v20, v19);
  switch(v15)
  {
    case 1:
      if (!x509_constraints_parse_mailbox((uint64_t)v18, 0))
      {
        int v16 = 699;
        goto LABEL_32;
      }
      break;
    case 2:
      if (!x509_constraints_valid_sandns(v18))
      {
        int v16 = 683;
        goto LABEL_32;
      }
      break;
    case 6:
      if (!x509_constraints_uri_host(v20, v19, 0))
      {
        int v16 = 691;
LABEL_32:
        ERR_put_error(34, 4095, 119, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", v16);
        ERR_asprintf_error_data("name=%s value='%.*s'");
        goto LABEL_36;
      }
      break;
    case 7:
      if (v19 != 4 && v19 != 16)
      {
        ERR_put_error(34, 4095, 118, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 707);
        ERR_asprintf_error_data("name=%s len=%zu");
        goto LABEL_36;
      }
      break;
    default:
      return v11;
  }
  return v11;
}

GENERAL_NAME *a2i_GENERAL_NAME(GENERAL_NAME *a1, int a2, X509V3_CTX *a3, int a4, char *__s, int a6)
{
  if (!__s)
  {
    ERR_put_error(34, 4095, 124, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 536);
    return 0;
  }
  long long v11 = a1;
  if (a1 || (long long v11 = GENERAL_NAME_new()) != 0)
  {
    switch(a4)
    {
      case 0:
        uint64_t v17 = strchr(__s, 59);
        if (v17)
        {
          uint64_t v18 = v17;
          unint64_t v19 = OTHERNAME_new();
          v11->d.ptr = (char *)v19;
          if (v19)
          {
            ASN1_TYPE_free(v19->value);
            uint64_t v20 = ASN1_generate_v3(v18 + 1, a3);
            *((void *)v11->d.ptr + 1) = v20;
            if (v20)
            {
              size_t v21 = (int)v18 - (int)__s + 1;
              uint64_t v22 = (char *)malloc_type_malloc(v21, 0xF907CCF3uLL);
              if (v22)
              {
                unsigned int v23 = v22;
                strlcpy(v22, __s, v21);
                *(void *)v11->d.ptr = OBJ_txt2obj(v23, 0);
                free(v23);
              }
              else
              {
                *(void *)v11->d.ptr = 0;
              }
              if (*(void *)v11->d.ptr) {
                goto LABEL_35;
              }
            }
          }
        }
        int v15 = 147;
        int v16 = 590;
        goto LABEL_37;
      case 1:
      case 2:
      case 6:
        int v12 = ASN1_IA5STRING_new();
        v11->d.ptr = (char *)v12;
        if (v12)
        {
          uint64_t v13 = v12;
          int v14 = strlen(__s);
          if (ASN1_STRING_set(v13, __s, v14)) {
            goto LABEL_35;
          }
        }
        int v15 = 65;
        int v16 = 603;
        goto LABEL_37;
      case 4:
        int v24 = X509_NAME_new();
        if (!v24) {
          goto LABEL_32;
        }
        uint64_t v25 = v24;
        section = X509V3_get_section(a3, __s);
        if (section)
        {
          uint64_t v27 = section;
          if (X509V3_NAME_from_section(v25, section, 0x1001uLL))
          {
            v11->d.ptr = (char *)v25;
            X509V3_section_free(a3, v27);
            goto LABEL_35;
          }
          X509_NAME_free(v25);
          v11->d.ptr = (char *)v25;
          X509V3_section_free(a3, v27);
        }
        else
        {
          ERR_put_error(34, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 763);
          ERR_asprintf_error_data("section=%s", __s);
          X509_NAME_free(v25);
        }
LABEL_32:
        int v15 = 149;
        int v16 = 583;
LABEL_37:
        ERR_put_error(34, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", v16);
        if (!a1) {
          goto LABEL_38;
        }
        return 0;
      case 7:
        if (a6) {
          int v28 = a2i_IPADDRESS_NC(__s);
        }
        else {
          int v28 = a2i_IPADDRESS(__s);
        }
        v11->d.ptr = (char *)v28;
        if (v28) {
          goto LABEL_35;
        }
        int v30 = 118;
        int v31 = 575;
        goto LABEL_28;
      case 8:
        uint64_t v29 = OBJ_txt2obj(__s, 0);
        if (v29)
        {
          v11->d.ptr = (char *)v29;
LABEL_35:
          v11->type = a4;
          return v11;
        }
        int v30 = 119;
        int v31 = 561;
LABEL_28:
        ERR_put_error(34, 4095, v30, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", v31);
        ERR_asprintf_error_data("value=%s", __s);
        if (!a1) {
LABEL_38:
        }
          GENERAL_NAME_free(v11);
        break;
      default:
        int v15 = 167;
        int v16 = 596;
        goto LABEL_37;
    }
    return 0;
  }
  ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 545);
  return v11;
}

uint64_t copy_email(uint64_t a1, STACK *a2, int a3)
{
  if (a1)
  {
    if (*(_DWORD *)a1 == 1) {
      return 1;
    }
    if (*(void *)(a1 + 16))
    {
      uint64_t subject_name = (uint64_t)X509_get_subject_name(*(X509 **)(a1 + 16));
      goto LABEL_8;
    }
    uint64_t v7 = *(void *)(a1 + 24);
    if (v7)
    {
      uint64_t subject_name = X509_REQ_get_subject_name(v7);
LABEL_8:
      uint64_t v8 = (X509_NAME *)subject_name;
      int v9 = -1;
      while (1)
      {
        int index_by_NID = X509_NAME_get_index_by_NID(v8, 48, v9);
        if (index_by_NID < 0) {
          return 1;
        }
        int v9 = index_by_NID;
        entry = X509_NAME_get_entry(v8, index_by_NID);
        data = X509_NAME_ENTRY_get_data(entry);
        uint64_t v13 = ASN1_STRING_dup(data);
        if (a3)
        {
          X509_NAME_delete_entry(v8, v9);
          X509_NAME_ENTRY_free(entry);
          --v9;
        }
        if (!v13 || (int v14 = GENERAL_NAME_new()) == 0)
        {
          ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 469);
          goto LABEL_18;
        }
        int v15 = v14;
        v14->d.ptr = (char *)v13;
        v14->type = 1;
        if (!sk_push(a2, (char *)v14))
        {
          ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 476);
          uint64_t v13 = 0;
          goto LABEL_19;
        }
      }
    }
  }
  ERR_put_error(34, 4095, 125, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_alt.c", 448);
  uint64_t v13 = 0;
LABEL_18:
  int v15 = 0;
LABEL_19:
  GENERAL_NAME_free(v15);
  ASN1_IA5STRING_free(v13);
  return 0;
}

UI *UI_new(void)
{
  return UI_new_method(0);
}

UI *__cdecl UI_new_method(const UI_METHOD *method)
{
  uint64_t v2 = (UI_METHOD **)malloc_type_calloc(1uLL, 0x28uLL, 0x10E00402F6BC7AFuLL);
  int v3 = v2;
  if (v2)
  {
    *uint64_t v2 = method;
    if (!method)
    {
      int v4 = (UI_METHOD *)default_UI_meth;
      if (!default_UI_meth)
      {
        int v4 = UI_OpenSSL();
        default_UI_meth = (uint64_t)v4;
      }
      STACK *v3 = v4;
    }
    CRYPTO_new_ex_data(11, v3, (CRYPTO_EX_DATA *)(v3 + 3));
  }
  else
  {
    ERR_put_error(40, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ui/ui_lib.c", 84);
  }
  return (UI *)v3;
}

const UI_METHOD *UI_get_default_method(void)
{
  uint64_t result = (const UI_METHOD *)default_UI_meth;
  if (!default_UI_meth)
  {
    uint64_t result = UI_OpenSSL();
    default_UI_meth = (uint64_t)result;
  }
  return result;
}

void UI_free(UI *ui)
{
  if (ui)
  {
    sk_pop_free(*((STACK **)ui + 1), (void (__cdecl *)(void *))free_string);
    CRYPTO_free_ex_data(11, ui, (CRYPTO_EX_DATA *)((char *)ui + 24));
    free(ui);
  }
}

void free_string(void **a1)
{
  if (a1)
  {
    if ((_BYTE)a1[7])
    {
      free(a1[1]);
      if (*(_DWORD *)a1 == 3)
      {
        free(a1[4]);
        free(a1[5]);
        free(a1[6]);
      }
    }
    free(a1);
  }
}

int UI_add_input_string(UI *ui, const char *prompt, int flags, char *result_buf, int minsize, int maxsize)
{
  return general_allocate_string((uint64_t)ui, prompt, 0, 1, flags, (uint64_t)result_buf, minsize, maxsize, 0);
}

uint64_t general_allocate_string(uint64_t a1, const char *a2, int a3, int a4, int a5, uint64_t a6, int a7, int a8, void *a9)
{
  prompt = (void **)general_allocate_prompt(a2, a3, a4, a5, a6);
  uint64_t v13 = prompt;
  if (!prompt
    || (*((_DWORD *)prompt + 8) = a7,
        *((_DWORD *)prompt + 9) = a8,
        prompt[5] = a9,
        (allocate_string_stack(a1) & 0x80000000) != 0)
    || (uint64_t result = sk_push(*(STACK **)(a1 + 8), (char *)v13), (int)result <= 0))
  {
    free_string(v13);
    return 0xFFFFFFFFLL;
  }
  return result;
}

int UI_dup_input_string(UI *ui, const char *prompt, int flags, char *result_buf, int minsize, int maxsize)
{
  return general_allocate_string((uint64_t)ui, prompt, 1, 1, flags, (uint64_t)result_buf, minsize, maxsize, 0);
}

int UI_add_verify_string(UI *ui, const char *prompt, int flags, char *result_buf, int minsize, int maxsize, const char *test_buf)
{
  return general_allocate_string((uint64_t)ui, prompt, 0, 2, flags, (uint64_t)result_buf, minsize, maxsize, (void *)test_buf);
}

int UI_dup_verify_string(UI *ui, const char *prompt, int flags, char *result_buf, int minsize, int maxsize, const char *test_buf)
{
  return general_allocate_string((uint64_t)ui, prompt, 1, 2, flags, (uint64_t)result_buf, minsize, maxsize, (void *)test_buf);
}

int UI_add_input_BOOLean(UI *ui, const char *prompt, const char *action_desc, const char *ok_chars, const char *cancel_chars, int flags, char *result_buf)
{
  return general_allocate_BOOLean((uint64_t)ui, prompt, action_desc, (char *)ok_chars, (char *)cancel_chars, 0, flags, (uint64_t)result_buf);
}

uint64_t general_allocate_BOOLean(uint64_t a1, const char *a2, const char *a3, char *__s, char *__charset, int a6, int a7, uint64_t a8)
{
  if (!__s || !__charset)
  {
    int v16 = 67;
    int v17 = 214;
    goto LABEL_6;
  }
  if (__s[strcspn(__s, __charset)])
  {
    int v16 = 104;
    int v17 = 218;
LABEL_6:
    ERR_put_error(40, 4095, v16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ui/ui_lib.c", v17);
    uint64_t v18 = 0;
LABEL_7:
    free_string(v18);
    return 0xFFFFFFFFLL;
  }
  prompt = (void **)general_allocate_prompt(a2, a6, 3, a7, a8);
  uint64_t v18 = prompt;
  if (!prompt) {
    goto LABEL_7;
  }
  if (a6)
  {
    if (a3)
    {
      size_t v21 = strdup(a3);
      v18[4] = v21;
      if (!v21)
      {
        int v24 = 230;
        goto LABEL_22;
      }
    }
    uint64_t v22 = strdup(__s);
    v18[5] = v22;
    if (!v22)
    {
      int v24 = 235;
      goto LABEL_22;
    }
    unsigned int v23 = strdup(__charset);
    v18[6] = v23;
    if (!v23)
    {
      int v24 = 240;
LABEL_22:
      ERR_put_error(40, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ui/ui_lib.c", v24);
      goto LABEL_7;
    }
  }
  else
  {
    prompt[4] = (void *)a3;
    prompt[5] = __s;
    prompt[6] = __charset;
  }
  if ((allocate_string_stack(a1) & 0x80000000) != 0) {
    goto LABEL_7;
  }
  uint64_t result = sk_push(*(STACK **)(a1 + 8), (char *)v18);
  if ((int)result <= 0) {
    goto LABEL_7;
  }
  return result;
}

int UI_dup_input_BOOLean(UI *ui, const char *prompt, const char *action_desc, const char *ok_chars, const char *cancel_chars, int flags, char *result_buf)
{
  return general_allocate_BOOLean((uint64_t)ui, prompt, action_desc, (char *)ok_chars, (char *)cancel_chars, 1, flags, (uint64_t)result_buf);
}

int UI_add_info_string(UI *ui, const char *text)
{
  return general_allocate_string((uint64_t)ui, text, 0, 4, 0, 0, 0, 0, 0);
}

int UI_dup_info_string(UI *ui, const char *text)
{
  return general_allocate_string((uint64_t)ui, text, 1, 4, 0, 0, 0, 0, 0);
}

int UI_add_error_string(UI *ui, const char *text)
{
  return general_allocate_string((uint64_t)ui, text, 0, 5, 0, 0, 0, 0, 0);
}

int UI_dup_error_string(UI *ui, const char *text)
{
  return general_allocate_string((uint64_t)ui, text, 1, 5, 0, 0, 0, 0, 0);
}

char *__cdecl UI_construct_prompt(UI *ui_method, const char *object_desc, const char *object_name)
{
  int v3 = *(uint64_t (**)(void))(*(void *)ui_method + 48);
  if (v3)
  {
    return (char *)v3();
  }
  else
  {
    if (!object_desc) {
      return 0;
    }
    int v6 = 0;
    int v5 = object_name ? asprintf(&v6, "Enter %s for %s:") : asprintf(&v6, "Enter %s:");
    if (v5 == -1) {
      return 0;
    }
    else {
      return v6;
    }
  }
}

void *__cdecl UI_add_user_data(UI *ui, void *user_data)
{
  uint64_t v2 = (void *)*((void *)ui + 2);
  *((void *)ui + 2) = user_data;
  return v2;
}

void *__cdecl UI_get0_user_data(UI *ui)
{
  return (void *)*((void *)ui + 2);
}

const char *__cdecl UI_get0_result(UI *ui, int i)
{
  if (i < 0)
  {
    int v5 = 103;
    int v6 = 399;
LABEL_8:
    ERR_put_error(40, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ui/ui_lib.c", v6);
    return 0;
  }
  if (sk_num(*((const STACK **)ui + 1)) <= i)
  {
    int v5 = 102;
    int v6 = 403;
    goto LABEL_8;
  }
  uint64_t result = sk_value(*((const STACK **)ui + 1), i);
  if (!result) {
    return result;
  }
  if ((*(_DWORD *)result - 1) <= 1) {
    return (const char *)*((void *)result + 3);
  }
  return 0;
}

const char *__cdecl UI_get0_result_string(const char *uis)
{
  if (uis)
  {
    if ((*(_DWORD *)uis - 1) > 1) {
      return 0;
    }
    else {
      return (const char *)*((void *)uis + 3);
    }
  }
  return uis;
}

int UI_process(UI *ui)
{
  uint64_t v2 = *(unsigned int (**)(UI *))(*(void *)ui + 8);
  if (v2 && !v2(ui)) {
    return -1;
  }
  if (*((unsigned char *)ui + 33)) {
    ERR_print_errors_cb((int (__cdecl *)(const char *, size_t, void *))print_error, ui);
  }
  if (sk_num(*((const STACK **)ui + 1)) >= 1)
  {
    int v3 = 0;
    do
    {
      int v4 = *(unsigned int (**)(UI *, char *))(*(void *)ui + 16);
      if (v4)
      {
        int v5 = sk_value(*((const STACK **)ui + 1), v3);
        if (!v4(ui, v5)) {
          goto LABEL_13;
        }
      }
    }
    while (++v3 < sk_num(*((const STACK **)ui + 1)));
  }
  int v6 = *(uint64_t (**)(UI *))(*(void *)ui + 24);
  if (!v6) {
    goto LABEL_14;
  }
  int v7 = v6(ui);
  if (v7 == -1) {
    goto LABEL_22;
  }
  if (v7)
  {
LABEL_14:
    if (sk_num(*((const STACK **)ui + 1)) < 1)
    {
LABEL_20:
      int v8 = 0;
      goto LABEL_23;
    }
    int v9 = 0;
    while (1)
    {
      int v10 = *(uint64_t (**)(UI *, char *))(*(void *)ui + 32);
      if (v10)
      {
        long long v11 = sk_value(*((const STACK **)ui + 1), v9);
        int v12 = v10(ui, v11);
        if (!v12) {
          goto LABEL_13;
        }
        if (v12 == -1) {
          break;
        }
      }
      if (++v9 >= sk_num(*((const STACK **)ui + 1))) {
        goto LABEL_20;
      }
    }
    *((_DWORD *)ui + 8) &= ~1u;
LABEL_22:
    int v8 = -2;
    goto LABEL_23;
  }
LABEL_13:
  int v8 = -1;
LABEL_23:
  uint64_t v13 = *(unsigned int (**)(UI *))(*(void *)ui + 40);
  if (v13 && !v13(ui)) {
    return -1;
  }
  return v8;
}

uint64_t print_error(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v7 = 0u;
  long long v8 = 0u;
  long long v6 = 0u;
  v5[0] = 5;
  v5[1] = a1;
  int v3 = *(unsigned int (**)(uint64_t, void *))(*(void *)a3 + 16);
  if (v3 && !v3(a3, v5)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

int UI_ctrl(UI *ui, int cmd, uint64_t i, void *p, void (*f)(void))
{
  if (ui)
  {
    if (cmd == 2) {
      return *((_DWORD *)ui + 8) & 1;
    }
    if (cmd == 1)
    {
      unsigned int v6 = *((_DWORD *)ui + 8);
      int result = (v6 >> 8) & 1;
      *((_DWORD *)ui + 8) = v6 & 0xFFFFFEFF | ((i != 0) << 8);
      return result;
    }
    int v8 = 106;
    int v9 = 507;
  }
  else
  {
    int v8 = 67;
    int v9 = 488;
  }
  ERR_put_error(40, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ui/ui_lib.c", v9);
  return -1;
}

int UI_get_ex_new_index(uint64_t argl, void *argp, CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
  return CRYPTO_get_ex_new_index(11, argl, argp, new_func, dup_func, free_func);
}

int UI_set_ex_data(UI *r, int idx, void *arg)
{
  return CRYPTO_set_ex_data((CRYPTO_EX_DATA *)((char *)r + 24), idx, arg);
}

void *__cdecl UI_get_ex_data(UI *r, int idx)
{
  return CRYPTO_get_ex_data((const CRYPTO_EX_DATA *)((char *)r + 24), idx);
}

void UI_set_default_method(const UI_METHOD *meth)
{
  default_UI_meth = (uint64_t)meth;
}

const UI_METHOD *__cdecl UI_get_method(UI *ui)
{
  return *(const UI_METHOD **)ui;
}

const UI_METHOD *__cdecl UI_set_method(UI *ui, const UI_METHOD *meth)
{
  *(void *)uint i = meth;
  return meth;
}

UI_METHOD *__cdecl UI_create_method(char *name)
{
  uint64_t v2 = (UI_METHOD *)malloc_type_calloc(1uLL, 0x38uLL, 0x90040541F721BuLL);
  if (!v2 || name && (int v3 = strdup(name), (*(void *)v2 = v3) == 0))
  {
    UI_destroy_method(v2);
    return 0;
  }
  return v2;
}

void UI_destroy_method(UI_METHOD *ui_method)
{
  if (ui_method)
  {
    free(*(void **)ui_method);
    free(ui_method);
  }
}

int UI_method_set_opener(UI_METHOD *method, int (__cdecl *opener)(UI *))
{
  if (!method) {
    return -1;
  }
  int result = 0;
  *((void *)method + 1) = opener;
  return result;
}

int UI_method_set_writer(UI_METHOD *method, int (__cdecl *writer)(UI *, UI_STRING *))
{
  if (!method) {
    return -1;
  }
  int result = 0;
  *((void *)method + 2) = writer;
  return result;
}

int UI_method_set_flusher(UI_METHOD *method, int (__cdecl *flusher)(UI *))
{
  if (!method) {
    return -1;
  }
  int result = 0;
  *((void *)method + 3) = flusher;
  return result;
}

int UI_method_set_reader(UI_METHOD *method, int (__cdecl *reader)(UI *, UI_STRING *))
{
  if (!method) {
    return -1;
  }
  int result = 0;
  *((void *)method + 4) = reader;
  return result;
}

int UI_method_set_closer(UI_METHOD *method, int (__cdecl *closer)(UI *))
{
  if (!method) {
    return -1;
  }
  int result = 0;
  *((void *)method + 5) = closer;
  return result;
}

uint64_t UI_method_set_prompt_constructor(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  *(void *)(a1 + 48) = a2;
  return result;
}

int (__cdecl *__cdecl UI_method_get_opener(int (__cdecl *method)(UI *)))(UI *)
{
  if (method) {
    return (int (__cdecl *)(UI *))*((void *)method + 1);
  }
  return method;
}

int (__cdecl *__cdecl UI_method_get_writer(int (__cdecl *method)(UI *, UI_STRING *)))(UI *, UI_STRING *)
{
  if (method) {
    return (int (__cdecl *)(UI *, UI_STRING *))*((void *)method + 2);
  }
  return method;
}

int (__cdecl *__cdecl UI_method_get_flusher(int (__cdecl *method)(UI *)))(UI *)
{
  if (method) {
    return (int (__cdecl *)(UI *))*((void *)method + 3);
  }
  return method;
}

int (__cdecl *__cdecl UI_method_get_reader(int (__cdecl *method)(UI *, UI_STRING *)))(UI *, UI_STRING *)
{
  if (method) {
    return (int (__cdecl *)(UI *, UI_STRING *))*((void *)method + 4);
  }
  return method;
}

int (__cdecl *__cdecl UI_method_get_closer(int (__cdecl *method)(UI *)))(UI *)
{
  if (method) {
    return (int (__cdecl *)(UI *))*((void *)method + 5);
  }
  return method;
}

uint64_t UI_method_get_prompt_constructor(uint64_t result)
{
  if (result) {
    return *(void *)(result + 48);
  }
  return result;
}

UI_string_types UI_get_string_type(UI_STRING *uis)
{
  if (uis) {
    LODWORD(uis) = *(_DWORD *)uis;
  }
  return uis;
}

int UI_get_input_flags(UI_STRING *uis)
{
  if (uis) {
    LODWORD(uis) = *((_DWORD *)uis + 4);
  }
  return (int)uis;
}

const char *__cdecl UI_get0_output_string(const char *uis)
{
  if (uis) {
    return (const char *)*((void *)uis + 1);
  }
  return uis;
}

const char *__cdecl UI_get0_action_string(const char *uis)
{
  if (uis)
  {
    if ((*(_DWORD *)uis | 2) == 3) {
      return (const char *)*((void *)uis + 4);
    }
    else {
      return 0;
    }
  }
  return uis;
}

const char *__cdecl UI_get0_test_string(const char *uis)
{
  if (uis)
  {
    if (*(_DWORD *)uis == 2) {
      return (const char *)*((void *)uis + 5);
    }
    else {
      return 0;
    }
  }
  return uis;
}

int UI_get_result_minsize(UI_STRING *uis)
{
  if (uis && (*(_DWORD *)uis - 1) <= 1) {
    return *((_DWORD *)uis + 8);
  }
  else {
    return -1;
  }
}

int UI_get_result_maxsize(UI_STRING *uis)
{
  if (uis && (*(_DWORD *)uis - 1) <= 1) {
    return *((_DWORD *)uis + 9);
  }
  else {
    return -1;
  }
}

int UI_set_result(UI *ui, UI_STRING *uis, const char *result)
{
  int v6 = strlen(result);
  int v7 = *((_DWORD *)ui + 8);
  *((_DWORD *)ui + 8) = v7 & 0xFFFFFFFE;
  if (!uis) {
    goto LABEL_22;
  }
  if ((*(_DWORD *)uis - 1) < 2)
  {
    if (*((_DWORD *)uis + 8) > v6)
    {
      *((_DWORD *)ui + 8) = v7 | 1;
      int v8 = 101;
      int v9 = 861;
LABEL_15:
      ERR_put_error(40, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ui/ui_lib.c", v9);
      ERR_asprintf_error_data("You must type in %d to %d characters", *((_DWORD *)uis + 8), *((_DWORD *)uis + 9));
LABEL_22:
      LODWORD(v16) = -1;
      return (int)v16;
    }
    uint64_t v18 = *((int *)uis + 9);
    if ((int)v18 < v6)
    {
      *((_DWORD *)ui + 8) = v7 | 1;
      int v8 = 100;
      int v9 = 870;
      goto LABEL_15;
    }
    unint64_t v19 = (char *)*((void *)uis + 3);
    if (v19)
    {
      strlcpy(v19, result, v18 + 1);
      goto LABEL_18;
    }
    int v20 = 878;
LABEL_21:
    ERR_put_error(40, 4095, 105, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ui/ui_lib.c", v20);
    goto LABEL_22;
  }
  if (*(_DWORD *)uis != 3) {
    goto LABEL_18;
  }
  int v10 = (unsigned char *)*((void *)uis + 3);
  if (!v10)
  {
    int v20 = 886;
    goto LABEL_21;
  }
  *int v10 = 0;
  char v11 = *result;
  if (!*result)
  {
LABEL_18:
    LODWORD(v16) = 0;
    return (int)v16;
  }
  int v12 = (char *)*((void *)uis + 5);
  uint64_t v13 = result + 1;
  while (1)
  {
    int v14 = v11;
    if (strchr(v12, v11))
    {
      LODWORD(v16) = 0;
      char v21 = *v12;
      goto LABEL_25;
    }
    int v15 = (char *)*((void *)uis + 6);
    int v16 = strchr(v15, v14);
    if (v16) {
      break;
    }
    int v17 = *(unsigned __int8 *)v13++;
    char v11 = v17;
    if (!v17) {
      return (int)v16;
    }
  }
  LODWORD(v16) = 0;
  char v21 = *v15;
LABEL_25:
  **((unsigned char **)uis + 3) = v21;
  return (int)v16;
}

void *general_allocate_prompt(const char *a1, int a2, int a3, int a4, uint64_t a5)
{
  if (!a1)
  {
    int v10 = 67;
    int v11 = 146;
    goto LABEL_6;
  }
  if ((a3 - 1) > 2 || a5)
  {
    int v14 = malloc_type_calloc(1uLL, 0x40uLL, 0x1052040C0D9DABDuLL);
    int v12 = v14;
    if (v14)
    {
      v14[1] = a1;
      if (!a2)
      {
LABEL_13:
        *((_DWORD *)v12 + 4) = a4;
        *(_DWORD *)int v12 = a3;
        void v12[3] = a5;
        return v12;
      }
      int v15 = strdup(a1);
      v12[1] = v15;
      if (v15)
      {
        *((_DWORD *)v12 + 14) = 1;
        goto LABEL_13;
      }
      int v16 = 162;
    }
    else
    {
      int v16 = 156;
    }
    ERR_put_error(40, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ui/ui_lib.c", v16);
    goto LABEL_7;
  }
  int v10 = 105;
  int v11 = 151;
LABEL_6:
  ERR_put_error(40, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ui/ui_lib.c", v11);
  int v12 = 0;
LABEL_7:
  free_string((void **)v12);
  return 0;
}

uint64_t allocate_string_stack(uint64_t a1)
{
  if (*(void *)(a1 + 8)) {
    return 0;
  }
  uint64_t v2 = sk_new_null();
  *(void *)(a1 + 8) = v2;
  if (v2) {
    return 0;
  }
  ERR_put_error(40, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ui/ui_lib.c", 132);
  return 0xFFFFFFFFLL;
}

void ERR_load_EC_strings(void)
{
  if (!ERR_func_error_string(EC_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&EC_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&EC_str_reasons);
  }
}

BIGNUM *__cdecl EC_POINT_point2bn(const EC_GROUP *a1, const EC_POINT *a2, point_conversion_form_t form, BIGNUM *a4, BN_CTX *a5)
{
  size_t v10 = EC_POINT_point2oct(a1, a2, form, 0, 0, a5);
  if (!v10) {
    return 0;
  }
  size_t v11 = v10;
  int v12 = (unsigned __int8 *)malloc_type_malloc(v10, 0x1115782uLL);
  if (!v12) {
    return 0;
  }
  uint64_t v13 = v12;
  if (EC_POINT_point2oct(a1, a2, form, v12, v11, a5)) {
    int v14 = BN_bin2bn(v13, v11, a4);
  }
  else {
    int v14 = 0;
  }
  free(v13);
  return v14;
}

EC_POINT *__cdecl EC_POINT_bn2point(const EC_GROUP *a1, const BIGNUM *a2, EC_POINT *a3, BN_CTX *a4)
{
  int v8 = BN_num_bits(a2);
  int v9 = v8 + 7;
  if (v8 < -7) {
    int v9 = v8 + 14;
  }
  if ((v8 + 14) >= 0xF)
  {
    size_t v10 = (uint64_t)v9 >> 3;
    size_t v11 = (unsigned __int8 *)malloc_type_malloc(v10, 0xDA6F2E94uLL);
    if (v11)
    {
      int v12 = v11;
      if (BN_bn2bin(a2, v11))
      {
        if (a3)
        {
          if (EC_POINT_oct2point(a1, a3, v12, v10, a4))
          {
LABEL_14:
            free(v12);
            return a3;
          }
        }
        else
        {
          a3 = EC_POINT_new(a1);
          if (!a3 || EC_POINT_oct2point(a1, a3, v12, v10, a4)) {
            goto LABEL_14;
          }
          EC_POINT_free(a3);
        }
      }
      a3 = 0;
      goto LABEL_14;
    }
  }
  return 0;
}

char *__cdecl EC_POINT_point2hex(const EC_GROUP *a1, const EC_POINT *a2, point_conversion_form_t form, BN_CTX *a4)
{
  size_t v8 = EC_POINT_point2oct(a1, a2, form, 0, 0, a4);
  if (!v8) {
    return 0;
  }
  size_t v9 = v8;
  unint64_t v10 = v8 + 1;
  if (v8 == -1) {
    return 0;
  }
  size_t v11 = (unsigned __int8 *)malloc_type_malloc(v8, 0x76EBF871uLL);
  if (!v11) {
    return 0;
  }
  int v12 = v11;
  if (!EC_POINT_point2oct(a1, a2, form, v11, v9, a4))
  {
    free(v12);
    return 0;
  }
  uint64_t v13 = (char *)reallocarray(0, v10, 2uLL);
  int v14 = v13;
  if (v13)
  {
    uint64_t v15 = 0;
    int v16 = v13;
    do
    {
      unint64_t v17 = v12[v15];
      char *v16 = a0123456789abcd[v17 >> 4];
      v16[1] = a0123456789abcd[v17 & 0xF];
      v16 += 2;
      ++v15;
    }
    while (v9 != v15);
    char *v16 = 0;
  }
  free(v12);
  return v14;
}

EC_POINT *__cdecl EC_POINT_hex2point(const EC_GROUP *a1, const char *a2, EC_POINT *a3, BN_CTX *a4)
{
  a = 0;
  if (!BN_hex2bn(&a, a2)) {
    return 0;
  }
  int v7 = EC_POINT_bn2point(a1, a, a3, a4);
  BN_free(a);
  return v7;
}

BIO_METHOD *BIO_f_cipher(void)
{
  return (BIO_METHOD *)&methods_enc;
}

void BIO_set_cipher(BIO *b, const EVP_CIPHER *c, const unsigned __int8 *k, const unsigned __int8 *i, int enc)
{
  if (b)
  {
    uint64_t data = BIO_get_data((uint64_t)b);
    if (data)
    {
      uint64_t v11 = data;
      callback = BIO_get_callback(b);
      if (!callback
        || ((uint64_t (*)(BIO *, uint64_t, const EVP_CIPHER *, uint64_t, void, void))callback)(b, 6, c, 4, enc, 0) >= 1)
      {
        BIO_set_init((uint64_t)b, 1);
        int v13 = EVP_CipherInit_ex((EVP_CIPHER_CTX *)(v11 + 24), c, 0, k, i, enc);
        if (callback)
        {
          if (v13) {
            ((void (*)(BIO *, uint64_t, const EVP_CIPHER *, uint64_t, void, uint64_t))callback)(b, 6, c, 4, enc, 1);
          }
        }
      }
    }
  }
}

uint64_t enc_write(BIO *a1, const unsigned __int8 *a2, uint64_t a3)
{
  next_bio = a1->next_bio;
  BIO_clear_flags(a1, 15);
  int method_high = HIDWORD(next_bio->method);
  int v8 = LODWORD(next_bio->method) - method_high;
  if (v8 < 1)
  {
LABEL_5:
    uint64_t v10 = 0;
    if (a2 && (int)a3 >= 1)
    {
      HIDWORD(next_bio->method) = 0;
      int v12 = a3;
      while (1)
      {
        uint64_t v13 = v12 >= 4096 ? 4096 : v12;
        EVP_CipherUpdate((EVP_CIPHER_CTX *)&next_bio->init, (unsigned __int8 *)&next_bio[1].num_read, (int *)next_bio, a2, v13);
        v12 -= v13;
        HIDWORD(next_bio->method) = 0;
        int method = (int)next_bio->method;
        if (SLODWORD(next_bio->method) >= 1) {
          break;
        }
LABEL_16:
        a2 += v13;
        next_bio->int method = 0;
        if (v12 <= 0)
        {
          BIO_copy_next_retry(a1);
          return a3;
        }
      }
      int v15 = 0;
      while (1)
      {
        int v16 = BIO_write(a1->prev_bio, (char *)&next_bio[1].num_read + v15, method);
        unsigned int v17 = v16;
        if (v16 <= 0) {
          break;
        }
        int v15 = HIDWORD(next_bio->method) + v16;
        HIDWORD(next_bio->method) = v15;
        BOOL v11 = __OFSUB__(method, v16);
        method -= v16;
        if ((method < 0) ^ v11 | (method == 0)) {
          goto LABEL_16;
        }
      }
      BIO_copy_next_retry(a1);
      if (a3 == v12) {
        return v17;
      }
      else {
        return (a3 - v12);
      }
    }
  }
  else
  {
    while (1)
    {
      uint64_t v9 = BIO_write(a1->prev_bio, (char *)&next_bio[1].num_read + method_high, v8);
      uint64_t v10 = v9;
      if ((int)v9 <= 0) {
        break;
      }
      int method_high = HIDWORD(next_bio->method) + v9;
      HIDWORD(next_bio->method) = method_high;
      BOOL v11 = __OFSUB__(v8, v9);
      v8 -= v9;
      if ((v8 < 0) ^ v11 | (v8 == 0)) {
        goto LABEL_5;
      }
    }
    BIO_copy_next_retry(a1);
  }
  return v10;
}

uint64_t enc_read(BIO *a1, char *__dst, int a3)
{
  if (!__dst) {
    return 0;
  }
  next_bio = a1->next_bio;
  if (!next_bio || !a1->prev_bio) {
    return 0;
  }
  int v5 = a3;
  int v6 = __dst;
  if (SLODWORD(next_bio->method) < 1)
  {
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t method_high = SHIDWORD(next_bio->method);
    int v8 = LODWORD(next_bio->method) - method_high;
    if (v8 >= a3) {
      uint64_t v9 = a3;
    }
    else {
      uint64_t v9 = v8;
    }
    memcpy(__dst, (char *)&next_bio[1].num_read + method_high, (int)v9);
    v6 += (int)v9;
    v5 -= v9;
    int method = (int)next_bio->method;
    int v11 = HIDWORD(next_bio->method) + v9;
    HIDWORD(next_bio->method) = v11;
    if (method == v11) {
      next_bio->int method = 0;
    }
  }
  if (v5 >= 1)
  {
LABEL_14:
    int callback = (int)next_bio->callback;
    while (callback >= 1)
    {
      int v14 = BIO_read(a1->prev_bio, &next_bio[2].flags, 4096);
      if (v14 <= 0)
      {
        if (BIO_test_flags(a1->prev_bio, 8))
        {
          if (v9) {
            uint64_t v9 = v9;
          }
          else {
            uint64_t v9 = v14;
          }
          break;
        }
        LODWORD(next_bio->callback) = v14;
        LODWORD(next_bio->cb_arg) = EVP_CipherFinal_ex((EVP_CIPHER_CTX *)&next_bio->init, (unsigned __int8 *)&next_bio[1].num_read, (int *)next_bio);
        HIDWORD(next_bio->method) = 0;
        int v15 = (int)next_bio->method;
LABEL_21:
        if (v15 >= v5) {
          size_t v16 = v5;
        }
        else {
          size_t v16 = v15;
        }
        if ((int)v16 < 1) {
          break;
        }
        memcpy(v6, &next_bio[1].num_read, v16);
        uint64_t v9 = (v16 + v9);
        HIDWORD(next_bio->method) = v16;
        v6 += v16;
        BOOL v17 = __OFSUB__(v5, v16);
        v5 -= v16;
        if ((v5 < 0) ^ v17 | (v5 == 0)) {
          break;
        }
        goto LABEL_14;
      }
      EVP_CipherUpdate((EVP_CIPHER_CTX *)&next_bio->init, (unsigned __int8 *)&next_bio[1].num_read, (int *)next_bio, (const unsigned __int8 *)&next_bio[2].flags, v14);
      int callback = 1;
      LODWORD(next_bio->callback) = 1;
      int v15 = (int)next_bio->method;
      if (LODWORD(next_bio->method)) {
        goto LABEL_21;
      }
    }
  }
  BIO_clear_flags(a1, 15);
  BIO_copy_next_retry(a1);
  if (!v9) {
    return LODWORD(next_bio->callback);
  }
  return v9;
}

uint64_t enc_ctrl(BIO *b, int a2, uint64_t a3, int **a4)
{
  next_bio = b->next_bio;
  if (a2 > 100)
  {
    switch(a2)
    {
      case 101:
        BIO_clear_flags(b, 15);
        uint64_t v13 = BIO_ctrl(b->prev_bio, 101, a3, a4);
        BIO_copy_next_retry(b);
        return v13;
      case 113:
        return SLODWORD(next_bio->cb_arg);
      case 129:
        *a4 = &next_bio->init;
        uint64_t result = 1;
        b->unint64_t flags = 1;
        return result;
    }
LABEL_24:
    prev_bio = b->prev_bio;
  }
  else
  {
    switch(a2)
    {
      case 1:
        *(uint64_t (__cdecl **)(bio_st *, int, const char *, int, uint64_t, uint64_t))((char *)&next_bio->callback + 4) = (uint64_t (__cdecl *)(bio_st *, int, const char *, int, uint64_t, uint64_t))0x100000000;
        EVP_CipherInit_ex((EVP_CIPHER_CTX *)&next_bio->init, 0, 0, 0, 0, next_bio->num);
        prev_bio = b->prev_bio;
        a2 = 1;
        goto LABEL_27;
      case 2:
        if (SLODWORD(next_bio->callback) >= 1)
        {
          prev_bio = b->prev_bio;
          a2 = 2;
          goto LABEL_27;
        }
        return 1;
      case 10:
        int method_high = HIDWORD(next_bio->method);
        uint64_t result = (LODWORD(next_bio->method) - method_high);
        if (SLODWORD(next_bio->method) > method_high) {
          return result;
        }
        prev_bio = b->prev_bio;
        a2 = 10;
        goto LABEL_27;
      case 11:
        goto LABEL_12;
      case 12:
        int v11 = (EVP_CIPHER_CTX *)(a4[7] + 6);
        EVP_CIPHER_CTX_init(v11);
        LODWORD(result) = EVP_CIPHER_CTX_copy(v11, (uint64_t *)&next_bio->init);
        if (!result) {
          return 0;
        }
        uint64_t result = (int)result;
        *((_DWORD *)a4 + 8) = 1;
        return result;
      case 13:
        int v12 = HIDWORD(next_bio->method);
        uint64_t result = (LODWORD(next_bio->method) - v12);
        if (SLODWORD(next_bio->method) > v12) {
          return result;
        }
        prev_bio = b->prev_bio;
        a2 = 13;
        goto LABEL_27;
      default:
        goto LABEL_24;
    }
    while (1)
    {
LABEL_12:
      while (LODWORD(next_bio->method) != HIDWORD(next_bio->method))
      {
        LODWORD(result) = enc_write(b, 0, 0);
        if ((result & 0x80000000) != 0) {
          return (int)result;
        }
      }
      if (HIDWORD(next_bio->callback)) {
        break;
      }
      HIDWORD(next_bio->callback) = 1;
      HIDWORD(next_bio->method) = 0;
      LODWORD(result) = EVP_CipherFinal_ex((EVP_CIPHER_CTX *)&next_bio->init, (unsigned __int8 *)&next_bio[1].num_read, (int *)next_bio);
      LODWORD(next_bio->cb_arg) = result;
      if ((int)result < 1) {
        return (int)result;
      }
    }
    prev_bio = b->prev_bio;
    a2 = 11;
  }
LABEL_27:
  return BIO_ctrl(prev_bio, a2, a3, a4);
}

uint64_t enc_new(uint64_t a1)
{
  uint64_t result = (uint64_t)malloc_type_malloc(0x1108uLL, 0x10E004092A15CCAuLL);
  if (result)
  {
    uint64_t v3 = result;
    EVP_CIPHER_CTX_init((EVP_CIPHER_CTX *)(result + 24));
    *(_OWORD *)uint64_t v3 = xmmword_23C709EF0;
    uint64_t result = 1;
    *(_DWORD *)(v3 + 16) = 1;
    *(_DWORD *)(a1 + 32) = 0;
    *(void *)(a1 + 56) = v3;
    *(_DWORD *)(a1 + 40) = 0;
  }
  return result;
}

uint64_t enc_free(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    EVP_CIPHER_CTX_cleanup((EVP_CIPHER_CTX *)(*(void *)(result + 56) + 24));
    freezero(*(void **)(v1 + 56), 0x1108uLL);
    *(void *)(v1 + 56) = 0;
    *(_DWORD *)(v1 + 32) = 0;
    uint64_t result = 1;
    *(_DWORD *)(v1 + 40) = 0;
  }
  return result;
}

BIO *enc_callback_ctrl(uint64_t a1, int a2, void (__cdecl *a3)(bio_st *, int, const char *, int, uint64_t, uint64_t))
{
  uint64_t result = *(BIO **)(a1 + 64);
  if (result) {
    return (BIO *)BIO_callback_ctrl(result, a2, a3);
  }
  return result;
}

int ENGINE_set_default(ENGINE *e, unsigned int flags)
{
  __int16 v2 = flags;
  if (((flags & 0x40) == 0 || (int result = ENGINE_set_default_ciphers(e)) != 0)
    && ((v2 & 0x80) == 0 || (int result = ENGINE_set_default_digests(e)) != 0)
    && ((v2 & 1) == 0 || (int result = ENGINE_set_default_RSA(e)) != 0)
    && ((v2 & 2) == 0 || (int result = ENGINE_set_default_DSA(e)) != 0)
    && ((v2 & 4) == 0 || (int result = ENGINE_set_default_DH(e)) != 0)
    && ((v2 & 0x10) == 0 || (int result = ENGINE_set_default_ECDH(e)) != 0)
    && ((v2 & 0x20) == 0 || (int result = ENGINE_set_default_ECDSA(e)) != 0)
    && ((v2 & 0x800) == 0 || (int result = ENGINE_set_default_EC((uint64_t)e)) != 0)
    && ((v2 & 8) == 0 || (int result = ENGINE_set_default_RAND(e)) != 0)
    && ((v2 & 0x200) == 0 || (int result = ENGINE_set_default_pkey_meths((uint64_t)e)) != 0))
  {
    if ((v2 & 0x400) == 0) {
      return 1;
    }
    int result = ENGINE_set_default_pkey_asn1_meths((uint64_t)e);
    if (result) {
      return 1;
    }
  }
  return result;
}

int ENGINE_set_default_string(ENGINE *e, const char *def_list)
{
  unsigned int arg = 0;
  if (CONF_parse_list(def_list, 44, 1, (int (__cdecl *)(const char *, int, void *))int_def_cb, &arg)) {
    return ENGINE_set_default(e, arg);
  }
  ERR_put_error(38, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_fat.c", 156);
  ERR_asprintf_error_data("str=%s", def_list);
  return 0;
}

uint64_t int_def_cb(const char *a1, int a2, _DWORD *a3)
{
  size_t v5 = a2;
  if (!strncmp(a1, "ALL", a2))
  {
    int v7 = 0xFFFF;
  }
  else if (!strncmp(a1, "RSA", v5))
  {
    int v7 = 1;
  }
  else if (!strncmp(a1, "DSA", v5))
  {
    int v7 = 2;
  }
  else if (!strncmp(a1, "ECDH", v5))
  {
    int v7 = 16;
  }
  else if (!strncmp(a1, "ECDSA", v5))
  {
    int v7 = 32;
  }
  else if (!strncmp(a1, "DH", v5))
  {
    int v7 = 4;
  }
  else if (!strncmp(a1, "EC", v5))
  {
    int v7 = 2048;
  }
  else if (!strncmp(a1, "RAND", v5))
  {
    int v7 = 8;
  }
  else if (!strncmp(a1, "CIPHERS", v5))
  {
    int v7 = 64;
  }
  else if (!strncmp(a1, "DIGESTS", v5))
  {
    int v7 = 128;
  }
  else if (!strncmp(a1, "PKEY", v5))
  {
    int v7 = 1536;
  }
  else if (!strncmp(a1, "PKEY_CRYPTO", v5))
  {
    int v7 = 512;
  }
  else
  {
    if (strncmp(a1, "PKEY_ASN1", v5)) {
      return 0;
    }
    int v7 = 1024;
  }
  *a3 |= v7;
  return 1;
}

int ENGINE_register_complete(ENGINE *e)
{
  return 1;
}

int ENGINE_register_all_complete(void)
{
  first = ENGINE_get_first();
  if (first)
  {
    next = first;
    do
    {
      if ((*((unsigned char *)next + 176) & 8) == 0) {
        ENGINE_register_complete(next);
      }
      next = ENGINE_get_next(next);
    }
    while (next);
  }
  return 1;
}

uint64_t check_defer(uint64_t result)
{
  if ((int)result >= 1053 && !obj_cleanup_defer) {
    obj_cleanup_defer = 1;
  }
  return result;
}

void OBJ_cleanup(void)
{
  if (obj_cleanup_defer)
  {
    obj_cleanup_defer = 2;
  }
  else
  {
    uint64_t v0 = (LHASH *)added;
    if (added)
    {
      *(void *)(added + 48) = 0;
      lh_doall(v0, (LHASH_DOALL_FN_TYPE)cleanup1_LHASH_DOALL);
      lh_doall((LHASH *)added, (LHASH_DOALL_FN_TYPE)cleanup2_LHASH_DOALL);
      lh_doall((LHASH *)added, (LHASH_DOALL_FN_TYPE)cleanup3_LHASH_DOALL);
      lh_free((LHASH *)added);
      added = 0;
    }
  }
}

uint64_t cleanup1_LHASH_DOALL(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  *(_DWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 32) |= 0xDu;
  return result;
}

uint64_t cleanup2_LHASH_DOALL(uint64_t result)
{
  return result;
}

void cleanup3_LHASH_DOALL(void *a1)
{
  __int16 v2 = (ASN1_OBJECT *)a1[1];
  int v3 = v2->nid - 1;
  v2->nid = v3;
  if (!v3) {
    ASN1_OBJECT_free(v2);
  }
  free(a1);
}

int OBJ_new_nid(int num)
{
  int v1 = new_nid;
  new_nid += num;
  return v1;
}

int OBJ_add_object(const ASN1_OBJECT *obj)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  long long v9 = 0u;
  long long v10 = 0u;
  if (!added)
  {
    __int16 v2 = lh_new((LHASH_HASH_FN_TYPE)added_obj_LHASH_HASH, (LHASH_COMP_FN_TYPE)added_obj_LHASH_COMP);
    added = (uint64_t)v2;
    if (!v2) {
      return (int)v2;
    }
  }
  int v3 = OBJ_dup(obj);
  if (!v3)
  {
LABEL_18:
    for (uint64_t i = 0; i != 32; i += 8)
      free(*(void **)((char *)&v9 + i));
    ASN1_OBJECT_free(v3);
    LODWORD(v2) = 0;
    return (int)v2;
  }
  *((void *)&v10 + 1) = malloc_type_malloc(0x10uLL, 0x1020040D5A9D86FuLL);
  if (!*((void *)&v10 + 1)
    || v3->length && obj->data && (*(void *)&long long v9 = malloc_type_malloc(0x10uLL, 0x1020040D5A9D86FuLL), !(void)v9)
    || v3->sn && (*((void *)&v9 + 1) = malloc_type_malloc(0x10uLL, 0x1020040D5A9D86FuLL)) == 0
    || v3->ln && (*(void *)&long long v10 = malloc_type_malloc(0x10uLL, 0x1020040D5A9D86FuLL), !(void)v10))
  {
    ERR_put_error(8, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/objects/obj_dat.c", 334);
    goto LABEL_18;
  }
  for (uint64_t j = 0; j != 4; ++j)
  {
    size_t v5 = (void *)*((void *)&v9 + j);
    if (v5)
    {
      *(_DWORD *)size_t v5 = j;
      v5[1] = v3;
      int v6 = lh_insert((LHASH *)added, v5);
      free(v6);
    }
  }
  v3->flags &= 0xFFFFFFF2;
  LODWORD(v2) = v3->nid;
  return (int)v2;
}

ASN1_OBJECT *__cdecl OBJ_nid2obj(int n)
{
  if (n <= 0x41C)
  {
    if (!n)
    {
      unsigned int v1 = 0;
      return (ASN1_OBJECT *)&nid_objs[5 * v1];
    }
    if (LODWORD(nid_objs[5 * n + 2]))
    {
      unsigned int v1 = n;
      return (ASN1_OBJECT *)&nid_objs[5 * v1];
    }
    int v4 = 350;
    goto LABEL_12;
  }
  if (added)
  {
    long long v5 = 0u;
    long long v6 = 0u;
    uint64_t v7 = 0;
    data[0] = 3;
    data[1] = &v5;
    LODWORD(v6) = n;
    __int16 v2 = lh_retrieve((LHASH *)added, data);
    if (v2) {
      return (ASN1_OBJECT *)*((void *)v2 + 1);
    }
    int v4 = 364;
LABEL_12:
    ERR_put_error(8, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/objects/obj_dat.c", v4);
  }
  return 0;
}

const char *__cdecl OBJ_nid2sn(int n)
{
  if (n <= 0x41C)
  {
    if (!n)
    {
      unsigned int v1 = 0;
      return nid_objs[5 * v1];
    }
    if (LODWORD(nid_objs[5 * n + 2]))
    {
      unsigned int v1 = n;
      return nid_objs[5 * v1];
    }
    int v4 = 378;
    goto LABEL_12;
  }
  if (added)
  {
    long long v5 = 0u;
    long long v6 = 0u;
    uint64_t v7 = 0;
    data[0] = 3;
    data[1] = &v5;
    LODWORD(v6) = n;
    __int16 v2 = lh_retrieve((LHASH *)added, data);
    if (v2) {
      return (const char *)**((void **)v2 + 1);
    }
    int v4 = 392;
LABEL_12:
    ERR_put_error(8, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/objects/obj_dat.c", v4);
  }
  return 0;
}

const char *__cdecl OBJ_nid2ln(int n)
{
  if (n <= 0x41C)
  {
    if (!n)
    {
      unsigned int v1 = 0;
      goto LABEL_9;
    }
    if (LODWORD(nid_objs[5 * n + 2]))
    {
      unsigned int v1 = n;
LABEL_9:
      int v3 = &nid_objs[5 * v1];
      return v3[1];
    }
    int v5 = 406;
    goto LABEL_13;
  }
  if (added)
  {
    long long v6 = 0u;
    long long v7 = 0u;
    uint64_t v8 = 0;
    data[0] = 3;
    data[1] = &v6;
    LODWORD(v7) = n;
    __int16 v2 = lh_retrieve((LHASH *)added, data);
    if (v2)
    {
      int v3 = (char **)*((void *)v2 + 1);
      return v3[1];
    }
    int v5 = 420;
LABEL_13:
    ERR_put_error(8, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/objects/obj_dat.c", v5);
  }
  return 0;
}

int OBJ_obj2nid(const ASN1_OBJECT *o)
{
  int v12 = o;
  if (!o) {
    return 0;
  }
  int length = o->length;
  if (length)
  {
    int length = o->nid;
    if (!length)
    {
      uint64_t data = 0;
      uint64_t v11 = 0;
      if (added)
      {
        uint64_t v11 = o;
        __int16 v2 = lh_retrieve((LHASH *)added, &data);
        if (v2)
        {
          int v3 = (char **)*((void *)v2 + 1);
          return *((_DWORD *)v3 + 4);
        }
      }
      int v4 = 0;
      int v5 = 975;
      while (1)
      {
        int v6 = v4 + v5;
        if (v4 + v5 < 0 != __OFADD__(v4, v5)) {
          ++v6;
        }
        int v7 = v6 >> 1;
        int v8 = obj_cmp_BSEARCH_CMP_FN((uint64_t *)&v12, &obj_objs[v6 >> 1]);
        if (v8 < 0)
        {
          int v5 = v7;
        }
        else
        {
          if (!v8)
          {
            int v3 = &nid_objs[5 * obj_objs[v7]];
            return *((_DWORD *)v3 + 4);
          }
          int v4 = v7 + 1;
        }
        if (v4 >= v5) {
          return 0;
        }
      }
    }
  }
  return length;
}

ASN1_OBJECT *__cdecl OBJ_txt2obj(const char *s, int no_name)
{
  if (!no_name && ((int v4 = OBJ_sn2nid(s)) != 0 || (int v4 = OBJ_ln2nid(s)) != 0))
  {
    return OBJ_nid2obj(v4);
  }
  else
  {
    return t2i_ASN1_OBJECT_internal(s);
  }
}

int OBJ_sn2nid(const char *s)
{
  unsigned int v1 = s;
  long long v14 = 0u;
  long long v15 = 0u;
  uint64_t data = 0;
  int v12 = 0;
  uint64_t v13 = s;
  if (!added) {
    goto LABEL_5;
  }
  LODWORD(data) = 1;
  int v12 = &v13;
  __int16 v2 = lh_retrieve((LHASH *)added, &data);
  if (!v2)
  {
    unsigned int v1 = v13;
LABEL_5:
    int v4 = 0;
    uint64_t v5 = 1046;
    while (1)
    {
      int v6 = v4 + v5;
      if (v4 + (int)v5 < 0 != __OFADD__(v4, v5)) {
        ++v6;
      }
      uint64_t v7 = (v6 >> 1);
      unsigned int v8 = sn_objs[(int)v7];
      int v9 = strcmp(v1, nid_objs[5 * v8]);
      if ((v9 & 0x80000000) == 0)
      {
        if (!v9)
        {
          int v3 = &nid_objs[5 * v8];
          return *((_DWORD *)v3 + 4);
        }
        int v4 = v7 + 1;
        uint64_t v7 = v5;
      }
      uint64_t v5 = v7;
      if (v4 >= (int)v7) {
        return 0;
      }
    }
  }
  int v3 = (char **)*((void *)v2 + 1);
  return *((_DWORD *)v3 + 4);
}

int OBJ_ln2nid(const char *s)
{
  unsigned int v1 = s;
  uint64_t v13 = 0;
  long long v15 = 0u;
  uint64_t v11 = 0;
  int v12 = 0;
  uint64_t v16 = 0;
  long long v14 = s;
  if (!added) {
    goto LABEL_5;
  }
  LODWORD(v11) = 2;
  int v12 = &v13;
  __int16 v2 = lh_retrieve((LHASH *)added, &v11);
  if (!v2)
  {
    unsigned int v1 = v14;
LABEL_5:
    int v4 = 0;
    uint64_t v5 = 1046;
    while (1)
    {
      int v6 = v4 + v5;
      if (v4 + (int)v5 < 0 != __OFADD__(v4, v5)) {
        ++v6;
      }
      uint64_t v7 = (v6 >> 1);
      unsigned int v8 = ln_objs[(int)v7];
      int v9 = strcmp(v1, nid_objs[5 * v8 + 1]);
      if ((v9 & 0x80000000) == 0)
      {
        if (!v9)
        {
          int v3 = &nid_objs[5 * v8];
          return *((_DWORD *)v3 + 4);
        }
        int v4 = v7 + 1;
        uint64_t v7 = v5;
      }
      uint64_t v5 = v7;
      if (v4 >= (int)v7) {
        return 0;
      }
    }
  }
  int v3 = (char **)*((void *)v2 + 1);
  return *((_DWORD *)v3 + 4);
}

int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)
{
  return i2t_ASN1_OBJECT_internal((ASN1_OBJECT *)a, buf, buf_len, no_name);
}

int OBJ_txt2nid(const char *s)
{
  unsigned int v1 = OBJ_txt2obj(s, 0);
  int v2 = OBJ_obj2nid(v1);
  ASN1_OBJECT_free(v1);
  return v2;
}

const char *__cdecl OBJ_bsearch_(const char *key, const char *base, int num, int size, int (__cdecl *cmp)(const void *, const void *))
{
  if (num >= 1)
  {
    int v7 = num;
    int v10 = 0;
    do
    {
      int v11 = v10 + v7;
      if (v10 + v7 < 0 != __OFADD__(v10, v7)) {
        ++v11;
      }
      int v12 = v11 >> 1;
      uint64_t v13 = &base[(v11 >> 1) * size];
      int v14 = ((uint64_t (*)(const char *, const char *))cmp)(key, v13);
      if (v14 < 0)
      {
        int v7 = v12;
      }
      else
      {
        if (!v14) {
          return v13;
        }
        int v10 = v12 + 1;
      }
    }
    while (v10 < v7);
  }
  return 0;
}

const char *__cdecl OBJ_bsearch_ex_(const char *key, const char *base, int num, int size, int (__cdecl *cmp)(const void *, const void *), int flags)
{
  if (!num) {
    return 0;
  }
  char v6 = flags;
  uint64_t v9 = *(void *)&num;
  if (num < 1)
  {
    char v18 = 0;
    long long v15 = 0;
    LODWORD(v14) = 0;
    if ((flags & 2) == 0) {
      return v15;
    }
  }
  else
  {
    int v12 = 0;
    do
    {
      int v13 = v9 + v12;
      if ((int)v9 + v12 < 0 != __OFADD__(v9, v12)) {
        ++v13;
      }
      uint64_t v14 = (v13 >> 1);
      long long v15 = &base[(int)v14 * (uint64_t)size];
      int v16 = ((uint64_t (*)(const char *, const char *))cmp)(key, v15);
      uint64_t v17 = v14;
      if ((v16 & 0x80000000) == 0)
      {
        if (!v16)
        {
          char v18 = 0;
          if ((v6 & 2) != 0) {
            goto LABEL_17;
          }
          return v15;
        }
        int v12 = v14 + 1;
        uint64_t v17 = v9;
      }
      uint64_t v9 = v17;
    }
    while (v12 < (int)v17);
    if ((v6 & 1) == 0) {
      return 0;
    }
    char v18 = 1;
    if ((v6 & 2) == 0) {
      return v15;
    }
  }
LABEL_17:
  if ((v18 & 1) == 0)
  {
    uint64_t v19 = (int)v14;
    int v20 = v14 & ((int)v14 >> 31);
    char v21 = &base[((int)v14 - 1) * (uint64_t)size];
    while (v19-- >= 1)
    {
      int v23 = ((uint64_t (*)(const char *, const char *))cmp)(key, v21);
      v21 -= size;
      if (v23)
      {
        int v20 = v19 + 1;
        return &base[v20 * (uint64_t)size];
      }
    }
    return &base[v20 * (uint64_t)size];
  }
  return v15;
}

int OBJ_create_objects(BIO *in)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  int v2 = BIO_gets(in, buf, 512);
  if (v2 < 1) {
    return 0;
  }
  int v3 = 0;
  int v4 = 0;
  uint64_t v5 = MEMORY[0x263EF8318];
  do
  {
    buf[v2 - 1] = 0;
    if (buf[0] < 0)
    {
      if (!__maskrune(buf[0], 0x500uLL)) {
        return v4;
      }
    }
    else if ((*(_DWORD *)(v5 + 4 * buf[0] + 60) & 0x500) == 0)
    {
      return v4;
    }
    char v6 = &v20;
    do
    {
      int v8 = *(unsigned __int8 *)++v6;
      int v7 = v8;
      unsigned int v9 = v8 - 48;
    }
    while (v8 == 46 || v9 < 0xA);
    if (!v7) {
      goto LABEL_28;
    }
    *char v6 = 0;
    do
    {
      while (1)
      {
        int v12 = *++v6;
        unsigned __int8 v11 = v12;
        uint64_t v13 = v12;
        if (v12 < 0) {
          break;
        }
        if ((*(_DWORD *)(v5 + 4 * v13 + 60) & 0x4000) == 0) {
          goto LABEL_19;
        }
      }
    }
    while (__maskrune(v11, 0x4000uLL));
LABEL_19:
    if (!v13)
    {
LABEL_28:
      char v6 = 0;
      goto LABEL_39;
    }
    unsigned int v14 = *(unsigned __int8 *)v6;
    if (!*v6)
    {
LABEL_38:
      int v3 = 0;
      goto LABEL_39;
    }
    int v3 = v6;
    while ((v14 & 0x80) == 0)
    {
      if ((*(_DWORD *)(v5 + 4 * v14 + 60) & 0x4000) != 0) {
        goto LABEL_29;
      }
LABEL_26:
      unsigned int v15 = *(unsigned __int8 *)++v3;
      unsigned int v14 = v15;
      if (!v15) {
        goto LABEL_38;
      }
    }
    if (!__maskrune(v14, 0x4000uLL)) {
      goto LABEL_26;
    }
LABEL_29:
    if (!*v3) {
      goto LABEL_38;
    }
    const char *v3 = 0;
    do
    {
      while (1)
      {
        int v17 = *++v3;
        unsigned __int8 v16 = v17;
        uint64_t v18 = v17;
        if (v17 < 0) {
          break;
        }
        if ((*(_DWORD *)(v5 + 4 * v18 + 60) & 0x4000) == 0) {
          goto LABEL_35;
        }
      }
    }
    while (__maskrune(v16, 0x4000uLL));
LABEL_35:
    if (!v18) {
      int v3 = 0;
    }
LABEL_39:
    if (!buf[0]) {
      break;
    }
    if (!OBJ_create(buf, v6, v3)) {
      break;
    }
    ++v4;
    int v2 = BIO_gets(in, buf, 512);
  }
  while (v2 > 0);
  return v4;
}

int OBJ_create(const char *oid, const char *sn, const char *ln)
{
  int v6 = a2d_ASN1_OBJECT(0, 0, oid, -1);
  if (v6 < 1) {
    return 0;
  }
  int v7 = v6;
  int v8 = (unsigned __int8 *)malloc_type_malloc(v6, 0x618C04BBuLL);
  if (!v8)
  {
    ERR_put_error(8, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/objects/obj_dat.c", 663);
    return 0;
  }
  unsigned int v9 = v8;
  int v10 = a2d_ASN1_OBJECT(v8, v7, oid, -1);
  if (v10)
  {
    int v11 = v10;
    int v12 = new_nid++;
    uint64_t v13 = ASN1_OBJECT_create(v12, v9, v11, sn, ln);
    unsigned int v14 = v13;
    if (v13) {
      int v15 = OBJ_add_object(v13);
    }
    else {
      int v15 = 0;
    }
  }
  else
  {
    int v15 = 0;
    unsigned int v14 = 0;
  }
  ASN1_OBJECT_free(v14);
  free(v9);
  return v15;
}

uint64_t OBJ_length(uint64_t result)
{
  if (result) {
    return *(_DWORD *)(result + 20) & ~(*(int *)(result + 20) >> 31);
  }
  return result;
}

uint64_t OBJ_get0_data(uint64_t result)
{
  if (result) {
    return *(void *)(result + 24);
  }
  return result;
}

unint64_t added_obj_LHASH_HASH(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  switch(*(_DWORD *)a1)
  {
    case 0:
      uint64_t v3 = *(unsigned int *)(v2 + 20);
      int v4 = v3 << 20;
      if ((int)v3 >= 1)
      {
        unsigned int v5 = 0;
        int v6 = *(unsigned __int8 **)(v2 + 24);
        do
        {
          int v7 = *v6++;
          v4 ^= v7 << (v5 % 0x18);
          v5 += 3;
          --v3;
        }
        while (v3);
      }
      goto LABEL_11;
    case 1:
      unsigned int v9 = *(const char **)v2;
      goto LABEL_9;
    case 2:
      unsigned int v9 = *(const char **)(v2 + 8);
LABEL_9:
      int v4 = lh_strhash(v9);
      goto LABEL_11;
    case 3:
      int v4 = *(_DWORD *)(v2 + 16);
LABEL_11:
      unint64_t v8 = (int)(*(_DWORD *)a1 << 30) & 0xFFFFFFFFC0000000 | v4 & 0x3FFFFFFF;
      break;
    default:
      unint64_t v8 = 0;
      break;
  }
  return v8;
}

uint64_t added_obj_LHASH_COMP(int *a1, uint64_t a2)
{
  int v3 = *a1;
  uint64_t result = (*a1 - *(_DWORD *)a2);
  if (v3 == *(_DWORD *)a2)
  {
    uint64_t v5 = *((void *)a1 + 1);
    uint64_t v6 = *(void *)(a2 + 8);
    switch(v3)
    {
      case 0:
        size_t v7 = *(int *)(v5 + 20);
        int v8 = *(_DWORD *)(v6 + 20);
        uint64_t result = (v7 - v8);
        if (v7 == v8) {
          uint64_t result = memcmp(*(const void **)(v5 + 24), *(const void **)(v6 + 24), v7);
        }
        break;
      case 1:
        unsigned int v9 = *(const char **)v5;
        if (!*(void *)v5) {
          goto LABEL_14;
        }
        int v10 = *(const char **)v6;
        if (!*(void *)v6) {
          goto LABEL_15;
        }
        goto LABEL_9;
      case 2:
        unsigned int v9 = *(const char **)(v5 + 8);
        if (v9)
        {
          int v10 = *(const char **)(v6 + 8);
          if (v10) {
LABEL_9:
          }
            uint64_t result = strcmp(v9, v10);
          else {
LABEL_15:
          }
            uint64_t result = 1;
        }
        else
        {
LABEL_14:
          uint64_t result = 0xFFFFFFFFLL;
        }
        break;
      case 3:
        uint64_t result = (*(_DWORD *)(v5 + 16) - *(_DWORD *)(v6 + 16));
        break;
      default:
        uint64_t result = 0;
        break;
    }
  }
  return result;
}

uint64_t obj_cmp_BSEARCH_CMP_FN(uint64_t *a1, unsigned int *a2)
{
  uint64_t v2 = *a1;
  size_t v3 = *(int *)(*a1 + 20);
  int v4 = HIDWORD(nid_objs[5 * *a2 + 2]);
  uint64_t result = (v3 - v4);
  if (v3 == v4) {
    return memcmp(*(const void **)(v2 + 24), nid_objs[5 * *a2 + 3], v3);
  }
  return result;
}

void RC2_cbc_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, RC2_KEY *ks, unsigned __int8 *iv, int enc)
{
  uint64_t v6 = iv;
  uint64_t v8 = length;
  uint64_t v47 = *MEMORY[0x263EF8340];
  unint64_t v11 = *(unsigned int *)iv;
  unint64_t v12 = *((unsigned int *)iv + 1);
  if (enc)
  {
    if (length >= 8)
    {
      do
      {
        uint64_t v13 = out;
        unint64_t v14 = v8;
        v8 -= 8;
        uint64_t v15 = *(unsigned int *)in;
        uint64_t v16 = *((unsigned int *)in + 1);
        in += 8;
        unint64_t data = v11 ^ v15;
        unint64_t v46 = v12 ^ v16;
        RC2_encrypt(&data, ks);
        unint64_t v11 = data;
        unint64_t v12 = v46;
        out += 8;
        *(_DWORD *)uint64_t v13 = data;
        *((_DWORD *)v13 + 1) = v12;
      }
      while (v14 > 0xF);
    }
    if (v8)
    {
      unint64_t v17 = 0;
      uint64_t v18 = &in[v8];
      unint64_t v19 = 0;
      switch(v8)
      {
        case 1:
          goto LABEL_12;
        case 2:
          goto LABEL_11;
        case 3:
          goto LABEL_10;
        case 4:
          goto LABEL_9;
        case 5:
          goto LABEL_8;
        case 6:
          goto LABEL_7;
        case 7:
          unsigned int v20 = *--v18;
          unint64_t v17 = (unint64_t)v20 << 16;
LABEL_7:
          unsigned int v21 = *--v18;
          v17 |= (unint64_t)v21 << 8;
LABEL_8:
          unsigned int v22 = *--v18;
          v17 |= v22;
LABEL_9:
          unint64_t v19 = v17;
          unsigned int v23 = *--v18;
          unint64_t v17 = (unint64_t)v23 << 24;
LABEL_10:
          unsigned int v24 = *--v18;
          v17 |= (unint64_t)v24 << 16;
LABEL_11:
          unsigned int v25 = *--v18;
          v17 |= (unint64_t)v25 << 8;
LABEL_12:
          v17 |= *(v18 - 1);
          break;
        default:
          unint64_t v19 = 0;
          break;
      }
      unint64_t data = v17 ^ v11;
      unint64_t v46 = v19 ^ v12;
      RC2_encrypt(&data, ks);
      LOBYTE(v11) = data;
      LODWORD(v12) = v46;
      unint64_t v26 = data >> 8;
      unint64_t v27 = data >> 16;
      unint64_t v28 = data >> 24;
      unint64_t v29 = v46 >> 8;
      unint64_t v30 = v46 >> 16;
      unint64_t v31 = v46 >> 24;
      *(_DWORD *)out = data;
      *((_DWORD *)out + 1) = v12;
    }
    else
    {
      unint64_t v26 = v11 >> 8;
      unint64_t v29 = v12 >> 8;
      unint64_t v30 = v12 >> 16;
      unint64_t v31 = v12 >> 24;
      unint64_t v28 = v11 >> 24;
      unint64_t v27 = v11 >> 16;
    }
    *uint64_t v6 = v11;
    v6[1] = v26;
    void v6[2] = v27;
    v6[3] = v28;
    v6[4] = v12;
    v6[5] = v29;
  }
  else
  {
    if (length >= 8)
    {
      do
      {
        int v32 = out;
        int v33 = v11;
        int v34 = v12;
        LODWORD(v11) = *(_DWORD *)in;
        unint64_t v12 = *((unsigned int *)in + 1);
        unint64_t v35 = v8;
        v8 -= 8;
        int v36 = in + 8;
        unint64_t data = *(unsigned int *)in;
        unint64_t v46 = v12;
        RC2_decrypt(&data, ks);
        __int16 v37 = WORD1(data) ^ HIWORD(v33);
        int v38 = v46 ^ v34;
        *(_WORD *)int v32 = data ^ v33;
        *((_WORD *)v32 + 1) = v37;
        *((_DWORD *)v32 + 1) = v38;
        out = v32 + 8;
        in += 8;
      }
      while (v35 > 0xF);
      in = v36;
      uint64_t v6 = iv;
    }
    if (v8)
    {
      int v39 = *(_DWORD *)in;
      unint64_t data = *(unsigned int *)in;
      unint64_t v40 = *((unsigned int *)in + 1);
      unint64_t v46 = v40;
      RC2_decrypt(&data, ks);
      int v41 = data ^ v11;
      int v42 = v46 ^ v12;
      unint64_t v43 = &out[v8];
      switch(v8)
      {
        case 1:
          goto LABEL_25;
        case 2:
          goto LABEL_24;
        case 3:
          goto LABEL_23;
        case 4:
          goto LABEL_22;
        case 5:
          goto LABEL_21;
        case 6:
          goto LABEL_20;
        case 7:
          *--unint64_t v43 = BYTE2(v42);
LABEL_20:
          *--unint64_t v43 = BYTE1(v42);
LABEL_21:
          *--unint64_t v43 = v42;
LABEL_22:
          *--unint64_t v43 = HIBYTE(v41);
LABEL_23:
          *--unint64_t v43 = BYTE2(v41);
LABEL_24:
          *--unint64_t v43 = BYTE1(v41);
LABEL_25:
          *(v43 - 1) = v41;
          break;
        default:
          break;
      }
    }
    else
    {
      int v39 = v11;
      unint64_t v40 = v12;
    }
    *(_DWORD *)uint64_t v6 = v39;
    *((_WORD *)v6 + 2) = v40;
    unint64_t v30 = v40 >> 16;
    unint64_t v31 = v40 >> 24;
  }
  v6[6] = v30;
  v6[7] = v31;
}

void RC2_encrypt(unint64_t *data, RC2_KEY *key)
{
  int v2 = (unsigned __int16)*data;
  unint64_t v3 = *data >> 16;
  unsigned int v4 = (unsigned __int16)data[1];
  unint64_t v5 = data[1] >> 16;
  int v6 = 3;
  size_t v7 = key;
  int v8 = 5;
  while (1)
  {
    do
    {
      unsigned int v9 = (v3 & ~v5) + v2 + (v5 & v4) + v7->data[0];
      int v2 = (v9 >> 15) & 1 | (2 * (unsigned __int16)v9);
      int v10 = v7->data[1] + v3 + (v4 & ~v2) + (v2 & v5);
      LODWORD(v3) = ((unsigned __int16)v10 >> 14) & 0xFFFC0003 | (4 * (unsigned __int16)v10);
      int v11 = v7->data[2] + v4 + (v5 & ~v3) + (v3 & v2);
      unsigned int v4 = ((unsigned __int16)v11 >> 13) & 0xFFF80007 | (8 * (unsigned __int16)v11);
      unint64_t v12 = (RC2_KEY *)&v7->data[4];
      LODWORD(v5) = ((unsigned __int16)(v7->data[3] + v5 + (v2 & ~(_WORD)v4) + (v4 & v3)) >> 11) & 0xFFE0001F | (32 * (unsigned __int16)(v7->data[3] + v5 + (v2 & ~(_WORD)v4) + (v4 & v3)));
      size_t v7 = (RC2_KEY *)((char *)v7 + 16);
      --v8;
    }
    while (v8);
    if (!--v6) {
      break;
    }
    if (v6 == 2) {
      int v8 = 6;
    }
    else {
      int v8 = 5;
    }
    v2 += key->data[v5 & 0x3F];
    LODWORD(v3) = key->data[v2 & 0x3F] + v3;
    v4 += key->data[v3 & 0x3F];
    LODWORD(v5) = key->data[v4 & 0x3F] + v5;
    size_t v7 = v12;
  }
  ASN1_STRING *data = (unsigned __int16)v2 | ((unsigned __int16)v3 << 16);
  data[1] = (unsigned __int16)v4 | ((unsigned __int16)v5 << 16);
}

void RC2_decrypt(unint64_t *data, RC2_KEY *key)
{
  unsigned int v2 = (unsigned __int16)*data;
  unint64_t v3 = *data >> 16;
  unsigned int v4 = (unsigned __int16)data[1];
  unint64_t v5 = data[1] >> 16;
  int v6 = &key->data[63];
  int v7 = 3;
  int v8 = 5;
  while (1)
  {
    int v9 = ((v5 << 11) | (v5 >> 5)) - (v2 & ~v4 | v4 & v3) - *v6;
    LODWORD(v5) = (unsigned __int16)((((_WORD)v5 << 11) | (v5 >> 5))
                                   - (v2 & ~(_WORD)v4 | v4 & v3)
                                   - *(_WORD *)v6);
    int v10 = ((v4 << 13) | (v4 >> 3)) - ((v3 & v2) + *(v6 - 1)) - (v9 & ~v3);
    unsigned int v4 = (unsigned __int16)((((_WORD)v4 << 13) | (v4 >> 3)) - ((v3 & v2) + *((_WORD *)v6 - 2)) - (v9 & ~(_WORD)v3));
    int v11 = *(v6 - 3);
    LODWORD(v3) = ((v3 << 14) | (v3 >> 2)) - (*(v6 - 2) + (v9 & v2)) - (v10 & ~v2);
    int v12 = ((v2 << 15) | (v2 >> 1)) - v11 - (v3 & ~v5 | v10 & v9);
    unsigned int v2 = (unsigned __int16)((((_WORD)v2 << 15) | (v2 >> 1)) - v11 - (v3 & ~(_WORD)v5 | v10 & v9));
    if (--v8) {
      goto LABEL_8;
    }
    if (!--v7) {
      break;
    }
    if (v7 == 2) {
      int v8 = 6;
    }
    else {
      int v8 = 5;
    }
    LODWORD(v5) = (unsigned __int16)(v9 - key->data[v10 & 0x3F]);
    unsigned int v4 = (unsigned __int16)(v10 - key->data[v3 & 0x3F]);
    LODWORD(v3) = v3 - key->data[v12 & 0x3F];
    unsigned int v2 = (unsigned __int16)(v12 - key->data[((_BYTE)v9 - key->data[v10 & 0x3F]) & 0x3F]);
LABEL_8:
    LODWORD(v3) = (unsigned __int16)v3;
    v6 -= 4;
  }
  ASN1_STRING *data = v2 | (v3 << 16);
  data[1] = v4 | (v9 << 16);
}

uint64_t CRYPTO_cfb128_encrypt(uint64_t result, unsigned char *a2, unint64_t a3, uint64_t a4, uint64_t a5, unsigned int *a6, int a7, uint64_t (*a8)(uint64_t, uint64_t, uint64_t))
{
  uint64_t v13 = (char *)result;
  unsigned int v14 = *a6;
  if (*a6) {
    BOOL v15 = a3 == 0;
  }
  else {
    BOOL v15 = 1;
  }
  int v16 = !v15;
  if (a7)
  {
    if (v16)
    {
      do
      {
        char v17 = *v13++;
        char v18 = *(unsigned char *)(a5 + v14);
        *(unsigned char *)(a5 + v14) = v18 ^ v17;
        *a2++ = v18 ^ v17;
        unint64_t v19 = a3 - 1;
        unsigned int v14 = ((_BYTE)v14 + 1) & 0xF;
        if (!v14) {
          break;
        }
        --a3;
      }
      while (a3);
    }
    else
    {
      unint64_t v19 = a3;
    }
    if (v19 < 0x10)
    {
      unsigned int v25 = v14;
      if (!v19) {
        goto LABEL_41;
      }
    }
    else
    {
      do
      {
        uint64_t result = a8(a5, a5, a4);
        if (v14 <= 0xF)
        {
          unint64_t v22 = v14;
          do
          {
            uint64_t v23 = *(void *)(a5 + v22) ^ *(void *)&v13[v22];
            *(void *)(a5 + v22) = v23;
            *(void *)&a2[v22] = v23;
            BOOL v24 = v22 >= 8;
            v22 += 8;
          }
          while (!v24);
        }
        unsigned int v14 = 0;
        unsigned int v25 = 0;
        v19 -= 16;
        a2 += 16;
        v13 += 16;
      }
      while (v19 > 0xF);
      if (!v19) {
        goto LABEL_41;
      }
    }
    uint64_t result = a8(a5, a5, a4);
    do
    {
      char v26 = *(unsigned char *)(a5 + v25) ^ v13[v25];
      *(unsigned char *)(a5 + v25) = v26;
      a2[v25++] = v26;
      --v19;
    }
    while (v19);
    goto LABEL_41;
  }
  if (v16)
  {
    do
    {
      char v20 = *v13++;
      *a2++ = v20 ^ *(unsigned char *)(a5 + v14);
      *(unsigned char *)(a5 + v14) = v20;
      unint64_t v21 = a3 - 1;
      unsigned int v14 = ((_BYTE)v14 + 1) & 0xF;
      if (!v14) {
        break;
      }
      --a3;
    }
    while (a3);
  }
  else
  {
    unint64_t v21 = a3;
  }
  if (v21 < 0x10)
  {
    unsigned int v25 = v14;
    if (!v21) {
      goto LABEL_41;
    }
    goto LABEL_39;
  }
  do
  {
    uint64_t result = a8(a5, a5, a4);
    if (v14 <= 0xF)
    {
      unint64_t v27 = v14;
      do
      {
        uint64_t v28 = *(void *)&v13[v27];
        *(void *)&a2[v27] = *(void *)(a5 + v27) ^ v28;
        *(void *)(a5 + v27) = v28;
        BOOL v24 = v27 >= 8;
        v27 += 8;
      }
      while (!v24);
    }
    unsigned int v14 = 0;
    unsigned int v25 = 0;
    v21 -= 16;
    a2 += 16;
    v13 += 16;
  }
  while (v21 > 0xF);
  if (v21)
  {
LABEL_39:
    uint64_t result = a8(a5, a5, a4);
    do
    {
      char v29 = v13[v25];
      a2[v25] = v29 ^ *(unsigned char *)(a5 + v25);
      *(unsigned char *)(a5 + v25++) = v29;
      --v21;
    }
    while (v21);
  }
LABEL_41:
  *a6 = v25;
  return result;
}

int8x16_t CRYPTO_cfb128_1_encrypt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, void (*a8)(uint64_t, uint64_t, uint64_t))
{
  if (a3)
  {
    for (unint64_t i = 0; i != a3; ++i)
    {
      int v26 = 1 << (i & 7 ^ 7);
      int v16 = (const char *)a5;
      int8x16_t v17 = vld1q_dup_s8(v16++);
      int8x16_t v25 = v17;
      char v18 = (v26 & *(unsigned char *)(a1 + (i >> 3))) != 0;
      v17.i64[0] = *(void *)v16;
      v17.i32[2] = *(_DWORD *)(a5 + 9);
      v17.i16[6] = *(_WORD *)(a5 + 13);
      v17.i8[14] = *(unsigned char *)(a5 + 15);
      int8x16_t v24 = v17;
      a8(a5, a5, a4);
      char v19 = *(unsigned char *)a5 ^ (v18 << 7);
      __int8 v20 = v18 << 7;
      if (a7) {
        __int8 v20 = *(unsigned char *)a5 ^ (v18 << 7);
      }
      uint8x16_t v21 = (uint8x16_t)v24;
      int8x16_t v22 = vextq_s8(v25, v24, 0xFuLL);
      v21.i8[15] = v20;
      int8x16_t result = vorrq_s8(vaddq_s8(v22, v22), (int8x16_t)vshrq_n_u8(vshrq_n_u8(v21, 1uLL), 6uLL));
      *(int8x16_t *)a5 = result;
      *(unsigned char *)(a2 + (i >> 3)) = *(unsigned char *)(a2 + (i >> 3)) & ~(_BYTE)v26 | ((v19 & 0x80) >> (i & 7));
    }
  }
  return result;
}

uint64_t CRYPTO_cfb128_8_encrypt(uint64_t result, unsigned char *a2, uint64_t a3, uint64_t a4, long long *a5, uint64_t a6, int a7, uint64_t (*a8)(long long *, long long *, uint64_t))
{
  if (a3)
  {
    uint64_t v12 = a3;
    unsigned int v14 = (char *)result;
    do
    {
      long long v18 = *a5;
      int8x16_t result = a8(a5, a5, a4);
      char v16 = *v14++;
      char v15 = v16;
      char v17 = *(unsigned char *)a5 ^ v16;
      if (a7) {
        char v15 = v17;
      }
      *a2++ = v17;
      *(void *)a5 = *(void *)((char *)&v18 + 1);
      *(void *)((char *)a5 + 7) = *((void *)&v18 + 1);
      *((unsigned char *)a5 + 15) = v15;
      --v12;
    }
    while (v12);
  }
  return result;
}

void ERR_load_ASN1_strings(void)
{
  if (!ERR_func_error_string(ASN1_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&ASN1_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&ASN1_str_reasons);
  }
}

uint64_t CRYPTO_xts128_encrypt(void *a1, int8x16_t *a2, int8x16_t *a3, __n128 *a4, unint64_t a5, int a6)
{
  unint64_t v6 = a5 - 16;
  if (a5 < 0x10) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v9 = a5;
  int8x16_t v13 = *a2;
  int8x16_t v28 = 0u;
  int8x16_t v29 = v13;
  ((void (*)(int8x16_t *, int8x16_t *, void))a1[3])(&v29, &v29, a1[1]);
  if ((v9 & 0xF) != 0 && a6 == 0) {
    unint64_t v9 = v6;
  }
  if (v9 >= 0x10)
  {
    __n128 v14 = (__n128)v29;
    do
    {
      int8x16_t v28 = veorq_s8((int8x16_t)v14, *a3);
      ((void (*)(int8x16_t *, int8x16_t *, void))a1[2])(&v28, &v28, *a1);
      long long v16 = (__int128)v29;
      __n128 v17 = (__n128)veorq_s8(v28, v29);
      int8x16_t v28 = (int8x16_t)v17;
      *a4 = v17;
      v9 -= 16;
      if (!v9) {
        return 0;
      }
      ++a4;
      ++a3;
      v29.i64[0] = (*((uint64_t *)&v16 + 1) >> 63) & 0x87 ^ (2 * v16);
      v29.i64[1] = v16 >> 63;
      __n128 v14 = (__n128)v29;
    }
    while (v9 > 0xF);
    if (!a6) {
      goto LABEL_20;
    }
    goto LABEL_14;
  }
  __n128 v17 = 0uLL;
  if (a6)
  {
LABEL_14:
    if (v9)
    {
      uint64_t v18 = 0;
      do
      {
        __int8 v19 = a3->i8[v18];
        a4->n128_u8[v18] = v28.u8[v18];
        v28.i8[v18++] = v19;
      }
      while (v9 > v18);
      __n128 v17 = (__n128)v28;
    }
    int8x16_t v28 = veorq_s8((int8x16_t)v17, v29);
    ((void (*)(int8x16_t *, int8x16_t *, void))a1[2])(&v28, &v28, *a1);
    uint64_t result = 0;
    int8x16_t v28 = veorq_s8(v28, v29);
    a4[-1] = (__n128)v28;
    return result;
  }
LABEL_20:
  uint64_t v20 = 135;
  if (v29.i32[3] >= 0) {
    uint64_t v20 = 0;
  }
  uint64_t v21 = v20 ^ (2 * v29.i64[0]);
  uint64_t v22 = *(_OWORD *)&v29 >> 63;
  uint64_t v23 = a3->i64[1] ^ v22;
  v28.i64[0] = a3->i64[0] ^ v21;
  v28.i64[1] = v23;
  ((void (*)(int8x16_t *, int8x16_t *, void, __n128, __n128))a1[2])(&v28, &v28, *a1, v14, v17);
  uint64_t v24 = v28.i64[0] ^ v21;
  uint64_t v25 = v28.i64[1] ^ v22;
  v28.i64[0] ^= v21;
  v28.i64[1] ^= v22;
  if (v9)
  {
    uint64_t v26 = 0;
    do
    {
      __int8 v27 = a3->i8[(v26 + 16)];
      a4->n128_u8[(v26 + 16)] = v28.u8[v26];
      v28.i8[v26++] = v27;
    }
    while (v9 > v26);
    uint64_t v25 = v28.i64[1];
    uint64_t v24 = v28.i64[0];
  }
  v28.i64[0] = v24 ^ v29.i64[0];
  v28.i64[1] = v25 ^ v29.i64[1];
  ((void (*)(int8x16_t *, int8x16_t *, void))a1[2])(&v28, &v28, *a1);
  uint64_t result = 0;
  *(int8x16_t *)a4 = veorq_s8(v29, v28);
  return result;
}

int PKCS7_add_attrib_smimecap(PKCS7_SIGNER_INFO *si, STACK *cap)
{
  unsigned int v4 = ASN1_STRING_new();
  if (v4)
  {
    unint64_t v5 = v4;
    v4->int length = ASN1_item_i2d((ASN1_VALUE *)cap, &v4->data, &X509_ALGORS_it);
    return PKCS7_add_signed_attribute(si, 167, 16, v5);
  }
  else
  {
    ERR_put_error(33, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_attr.c", 74);
    return 0;
  }
}

STACK *__cdecl PKCS7_get_smimecap(PKCS7_SIGNER_INFO *si)
{
  uint64_t result = (STACK *)PKCS7_get_signed_attribute(si, 167);
  if (result)
  {
    if (result->num == 16)
    {
      unint64_t data = result->data;
      in = (unsigned __int8 *)data[1];
      return (STACK *)ASN1_item_d2i(0, (const unsigned __int8 **)&in, *(int *)data, &X509_ALGORS_it);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

int PKCS7_simple_smimecap(STACK *sk, int nid, int arg)
{
  unint64_t v6 = X509_ALGOR_new();
  if (v6)
  {
    int v7 = v6;
    ASN1_OBJECT_free(v6->algorithm);
    v7->algorithm = OBJ_nid2obj(nid);
    if (arg < 1) {
      goto LABEL_7;
    }
    int v8 = ASN1_TYPE_new();
    v7->parameter = v8;
    if (v8)
    {
      unint64_t v9 = ASN1_INTEGER_new();
      if (v9)
      {
        int v10 = v9;
        if (ASN1_INTEGER_set(v9, arg))
        {
          v7->parameter->value.ptr = (char *)v10;
          v7->parameter->type = 2;
LABEL_7:
          if (sk_push(sk, (char *)v7)) {
            return 1;
          }
          goto LABEL_11;
        }
        ASN1_INTEGER_free(v10);
      }
    }
LABEL_11:
    ERR_put_error(33, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_attr.c", 131);
    X509_ALGOR_free(v7);
    return 0;
  }
  ERR_put_error(33, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_attr.c", 107);
  return 0;
}

uint64_t PKCS7_add_attrib_content_type(PKCS7_SIGNER_INFO *a1, ASN1_OBJECT *a2)
{
  if (PKCS7_get_signed_attribute(a1, 50)) {
    return 0;
  }
  if (!a2) {
    a2 = OBJ_nid2obj(21);
  }
  return PKCS7_add_signed_attribute(a1, 50, 6, a2);
}

uint64_t PKCS7_add0_attrib_signing_time(PKCS7_SIGNER_INFO *p7si, ASN1_TIME *a2)
{
  unsigned int v2 = a2;
  if (a2 || (unsigned int v2 = X509_gmtime_adj(0, 0)) != 0)
  {
    return PKCS7_add_signed_attribute(p7si, 52, 23, v2);
  }
  else
  {
    ERR_put_error(33, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_attr.c", 153);
    return 0;
  }
}

ASN1_OCTET_STRING *PKCS7_add1_attrib_digest(PKCS7_SIGNER_INFO *a1, const void *a2, int a3)
{
  uint64_t result = ASN1_OCTET_STRING_new();
  if (result)
  {
    int v7 = result;
    if (ASN1_STRING_set(result, a2, a3) && PKCS7_add_signed_attribute(a1, 51, 4, v7))
    {
      return (ASN1_OCTET_STRING *)1;
    }
    else
    {
      ASN1_OCTET_STRING_free(v7);
      return 0;
    }
  }
  return result;
}

X509_SIG *__cdecl d2i_X509_SIG(X509_SIG **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_SIG *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_SIG_it);
}

int i2d_X509_SIG(X509_SIG *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_SIG_it);
}

X509_SIG *X509_SIG_new(void)
{
  return (X509_SIG *)ASN1_item_new(&X509_SIG_it);
}

void X509_SIG_free(X509_SIG *a)
{
}

void *X509_SIG_get0(void *result, void *a2, void *a3)
{
  if (a2) {
    *a2 = *result;
  }
  if (a3) {
    *a3 = result[1];
  }
  return result;
}

void *X509_SIG_getm(void *result, void *a2, void *a3)
{
  if (a2) {
    *a2 = *result;
  }
  if (a3) {
    *a3 = result[1];
  }
  return result;
}

const char *X509_get_default_private_dir(void)
{
  return "/etc/ssl/private";
}

const char *X509_get_default_cert_area(void)
{
  return "/etc/ssl";
}

const char *X509_get_default_cert_dir(void)
{
  return "/etc/ssl/certs";
}

const char *X509_get_default_cert_file(void)
{
  return "/etc/ssl/cert.pem";
}

const char *X509_get_default_cert_dir_env(void)
{
  return "SSL_CERT_DIR";
}

const char *X509_get_default_cert_file_env(void)
{
  return "SSL_CERT_FILE";
}

PKCS8_PRIV_KEY_INFO *__cdecl d2i_PKCS8_PRIV_KEY_INFO(PKCS8_PRIV_KEY_INFO **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS8_PRIV_KEY_INFO *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS8_PRIV_KEY_INFO_it);
}

int i2d_PKCS8_PRIV_KEY_INFO(PKCS8_PRIV_KEY_INFO *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS8_PRIV_KEY_INFO_it);
}

PKCS8_PRIV_KEY_INFO *PKCS8_PRIV_KEY_INFO_new(void)
{
  return (PKCS8_PRIV_KEY_INFO *)ASN1_item_new(&PKCS8_PRIV_KEY_INFO_it);
}

void PKCS8_PRIV_KEY_INFO_free(PKCS8_PRIV_KEY_INFO *a)
{
}

uint64_t PKCS8_pkey_set0(uint64_t a1, ASN1_OBJECT *aobj, uint64_t v, int ptype, void *pval, void *a6, int a7)
{
  if ((v & 0x80000000) != 0 || (uint64_t result = ASN1_INTEGER_set(*(ASN1_INTEGER **)a1, v), result))
  {
    uint64_t result = X509_ALGOR_set0(*(X509_ALGOR **)(a1 + 8), aobj, ptype, pval);
    if (result)
    {
      if (a6) {
        ASN1_STRING_set0(*(ASN1_STRING **)(a1 + 16), a6, a7);
      }
      return 1;
    }
  }
  return result;
}

uint64_t PKCS8_pkey_get0(void *a1, unsigned __int8 **a2, int *a3, void *a4, uint64_t a5)
{
  if (a1) {
    *a1 = **(void **)(a5 + 8);
  }
  if (a2)
  {
    *a2 = ASN1_STRING_data(*(ASN1_STRING **)(a5 + 16));
    *a3 = ASN1_STRING_length(*(ASN1_STRING **)(a5 + 16));
  }
  if (a4) {
    *a4 = *(void *)(a5 + 8);
  }
  return 1;
}

uint64_t PKCS8_pkey_get0_attrs(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

BOOL PKCS8_pkey_add1_attr_by_NID(uint64_t a1, int a2, int a3, const unsigned __int8 *a4, int a5)
{
  return X509at_add1_attr_by_NID((STACK **)(a1 + 24), a2, a3, a4, a5) != 0;
}

uint64_t pkey_cb(int a1, uint64_t a2)
{
  if (a1 == 2)
  {
    unsigned int v2 = *(void ***)(*(void *)a2 + 16);
    if (v2) {
      explicit_bzero(v2[1], *(int *)v2);
    }
  }
  return 1;
}

void *__cdecl ASN1_dup(i2d_of_void *i2d, d2i_of_void *d2i, char *x)
{
  if (!x) {
    return 0;
  }
  int v6 = ((uint64_t (*)(char *, void))i2d)(x, 0);
  int v7 = malloc_type_malloc(v6 + 10, 0xF23DFE3FuLL);
  if (!v7)
  {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_old.c", 84);
    return 0;
  }
  int v8 = v7;
  int8x16_t v13 = v7;
  int v9 = ((uint64_t (*)(char *, void **))i2d)(x, &v13);
  uint64_t v12 = v8;
  int v10 = (void *)((uint64_t (*)(void, void **, void))d2i)(0, &v12, v9);
  free(v8);
  return v10;
}

void *__cdecl ASN1_d2i_fp(void *(*xnew)(void), d2i_of_void *d2i, FILE *in, void **x)
{
  int v7 = BIO_s_file();
  int v8 = BIO_new(v7);
  if (v8)
  {
    int v9 = v8;
    int v10 = (void *(*)(void))BIO_ctrl(v8, 106, 0, in);
    int v11 = ASN1_d2i_bio(v10, d2i, v9, x);
    BIO_free(v9);
    return v11;
  }
  else
  {
    ERR_put_error(13, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_old.c", 102);
    return 0;
  }
}

void *__cdecl ASN1_d2i_bio(void *(*xnew)(void), d2i_of_void *d2i, BIO *in, void **x)
{
  unint64_t data = 0;
  a = 0;
  unsigned int v6 = asn1_d2i_read_bio(in, &a);
  if ((v6 & 0x80000000) != 0)
  {
    int v7 = 0;
  }
  else
  {
    unint64_t data = a->data;
    int v7 = (void *)((uint64_t (*)(void **, char **, void))d2i)(x, &data, v6);
  }
  if (a) {
    BUF_MEM_free(a);
  }
  return v7;
}

int ASN1_i2d_fp(i2d_of_void *i2d, FILE *out, void *x)
{
  unsigned int v6 = BIO_s_file();
  int v7 = BIO_new(v6);
  if (v7)
  {
    int v8 = v7;
    BIO_ctrl(v7, 106, 0, out);
    int v9 = ASN1_i2d_bio(i2d, v8, (unsigned __int8 *)x);
    BIO_free(v8);
    return v9;
  }
  else
  {
    ERR_put_error(13, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_old.c", 139);
    return 0;
  }
}

int ASN1_i2d_bio(i2d_of_void *i2d, BIO *out, unsigned __int8 *x)
{
  int v6 = ((uint64_t (*)(unsigned __int8 *, void))i2d)(x, 0);
  int v7 = (char *)malloc_type_malloc(v6, 0x43814B7FuLL);
  if (v7)
  {
    int v8 = v7;
    int8x16_t v13 = v7;
    ((void (*)(unsigned __int8 *, char **))i2d)(x, &v13);
    int v9 = BIO_write(out, v8, v6);
    if (v9 == v6)
    {
LABEL_6:
      int v11 = 1;
    }
    else
    {
      int v10 = 0;
      while (v9 >= 1)
      {
        v10 += v9;
        v6 -= v9;
        int v9 = BIO_write(out, &v8[v10], v6);
        if (v9 == v6) {
          goto LABEL_6;
        }
      }
      int v11 = 0;
    }
    free(v8);
  }
  else
  {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_old.c", 158);
    return 0;
  }
  return v11;
}

int X509_REQ_set_version(X509_REQ *x, uint64_t version)
{
  if (x)
  {
    req_info = x->req_info;
    req_info->enc.modified = 1;
    LODWORD(x) = ASN1_INTEGER_set(req_info->version, version);
  }
  return (int)x;
}

uint64_t X509_REQ_get_version(uint64_t a1)
{
  return ASN1_INTEGER_get(*(ASN1_INTEGER **)(*(void *)a1 + 24));
}

int X509_REQ_set_subject_name(X509_REQ *req, X509_NAME *name)
{
  if (!req) {
    return 0;
  }
  req_info = req->req_info;
  if (!req->req_info) {
    return 0;
  }
  req_info->enc.modified = 1;
  return X509_NAME_set(&req_info->subject, name);
}

uint64_t X509_REQ_get_subject_name(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 32);
}

int X509_REQ_set_pubkey(X509_REQ *x, EVP_PKEY *pkey)
{
  if (!x) {
    return 0;
  }
  req_info = x->req_info;
  if (!x->req_info) {
    return 0;
  }
  req_info->enc.modified = 1;
  return X509_PUBKEY_set(&req_info->pubkey, pkey);
}

X509_NAME_ENTRY *__cdecl d2i_X509_NAME_ENTRY(X509_NAME_ENTRY **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_NAME_ENTRY *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_NAME_ENTRY_it);
}

int i2d_X509_NAME_ENTRY(X509_NAME_ENTRY *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_NAME_ENTRY_it);
}

X509_NAME_ENTRY *X509_NAME_ENTRY_new(void)
{
  return (X509_NAME_ENTRY *)ASN1_item_new(&X509_NAME_ENTRY_it);
}

void X509_NAME_ENTRY_free(X509_NAME_ENTRY *a)
{
}

X509_NAME_ENTRY *__cdecl X509_NAME_ENTRY_dup(X509_NAME_ENTRY *ne)
{
  return (X509_NAME_ENTRY *)ASN1_item_dup(&X509_NAME_ENTRY_it, ne);
}

uint64_t x509_name_ex_new(STACK ***a1)
{
  unsigned int v2 = (STACK **)malloc_type_malloc(0x28uLL, 0x10300406D22A611uLL);
  if (v2)
  {
    unint64_t v3 = v2;
    unsigned int v4 = sk_new_null();
    const char *v3 = v4;
    if (v4)
    {
      unint64_t v5 = BUF_MEM_new();
      v3[2] = (STACK *)v5;
      if (v5)
      {
        v3[3] = 0;
        *((_DWORD *)v3 + 8) = 0;
        uint64_t result = 1;
        *((_DWORD *)v3 + 2) = 1;
        *a1 = v3;
        return result;
      }
    }
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/x_name.c", 261);
    if (*v3) {
      sk_free(*v3);
    }
    free(v3);
  }
  else
  {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/x_name.c", 261);
  }
  return 0;
}

void x509_name_ex_free(uint64_t *a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (*a1)
    {
      BUF_MEM_free(*(BUF_MEM **)(v2 + 16));
      sk_pop_free(*(STACK **)v2, (void (__cdecl *)(void *))X509_NAME_ENTRY_free);
      free(*(void **)(v2 + 24));
      free((void *)v2);
      *a1 = 0;
    }
  }
}

uint64_t x509_name_ex_d2i(uint64_t *a1, unsigned __int8 **a2, uint64_t a3, uint64_t a4, int a5, int a6, char a7, ASN1_TLC *a8)
{
  int v10 = *a2;
  punint64_t val = 0;
  in = v10;
  uint64_t v18 = 0;
  uint64_t result = ASN1_item_ex_d2i(&pval, (const unsigned __int8 **)&in, a3, &X509_NAME_INTERNAL_it, a5, a6, a7, a8);
  if ((int)result >= 1)
  {
    if (*a1) {
      x509_name_ex_free(a1);
    }
    int v12 = x509_name_ex_new(&v18);
    int8x16_t v13 = v18;
    if (v12)
    {
      if (!BUF_MEM_grow((BUF_MEM *)v18[2], in - v10)) {
        goto LABEL_16;
      }
      memcpy(v13[2]->data, v10, in - v10);
      if (sk_num((const STACK *)pval) >= 1)
      {
        int v14 = 0;
        while (1)
        {
          char v15 = (STACK *)sk_value((const STACK *)pval, v14);
          if (sk_num(v15) >= 1) {
            break;
          }
LABEL_12:
          sk_free(v15);
          if (++v14 >= sk_num((const STACK *)pval)) {
            goto LABEL_13;
          }
        }
        int v16 = 0;
        while (1)
        {
          __n128 v17 = sk_value(v15, v16);
          *((_DWORD *)v17 + 4) = v14;
          if (!sk_push(*v13, v17)) {
            goto LABEL_16;
          }
          if (++v16 >= sk_num(v15)) {
            goto LABEL_12;
          }
        }
      }
LABEL_13:
      sk_free((STACK *)pval);
      if (x509_name_canon((uint64_t)v13))
      {
        *((_DWORD *)v13 + 2) = 0;
        *a1 = (uint64_t)v13;
        *a2 = in;
        return 1;
      }
    }
    if (!v13)
    {
LABEL_17:
      ERR_put_error(13, 4095, 58, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/x_name.c", 343);
      return 0;
    }
LABEL_16:
    ASN1_item_free((ASN1_VALUE *)v13, &X509_NAME_it);
    goto LABEL_17;
  }
  return result;
}

uint64_t x509_name_ex_i2d(uint64_t *a1, void **a2)
{
  uint64_t v3 = *a1;
  if (!*(_DWORD *)(*a1 + 8)) {
    goto LABEL_16;
  }
  unsigned int v4 = (ASN1_VALUE *)sk_new_null();
  punint64_t val = v4;
  if (!v4)
  {
LABEL_19:
    sk_pop_free((STACK *)v4, (void (__cdecl *)(void *))local_sk_X509_NAME_ENTRY_free);
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/x_name.c", 428);
    return 0xFFFFFFFFLL;
  }
  if (sk_num(*(const STACK **)v3) >= 1)
  {
    int v5 = 0;
    int v6 = 0;
    int v7 = -1;
    do
    {
      int v8 = sk_value(*(const STACK **)v3, v5);
      if (*((_DWORD *)v8 + 4) == v7)
      {
        if (!v6) {
          goto LABEL_19;
        }
      }
      else
      {
        int v9 = (char *)sk_new_null();
        if (!v9) {
          goto LABEL_19;
        }
        int v6 = (STACK *)v9;
        if (!sk_push((STACK *)v4, v9)) {
          goto LABEL_19;
        }
        int v7 = *((_DWORD *)v8 + 4);
      }
      if (!sk_push(v6, v8)) {
        goto LABEL_19;
      }
      ++v5;
    }
    while (v5 < sk_num(*(const STACK **)v3));
  }
  uint64_t v10 = ASN1_item_ex_i2d(&pval, 0, &X509_NAME_INTERNAL_it, -1, -1);
  if (!BUF_MEM_grow(*(BUF_MEM **)(v3 + 16), v10))
  {
    unsigned int v4 = pval;
    goto LABEL_19;
  }
  int v14 = *(unsigned __int8 **)(*(void *)(v3 + 16) + 8);
  ASN1_item_ex_i2d(&pval, &v14, &X509_NAME_INTERNAL_it, -1, -1);
  sk_pop_free((STACK *)pval, (void (__cdecl *)(void *))local_sk_X509_NAME_ENTRY_free);
  *(_DWORD *)(v3 + 8) = 0;
  uint64_t v11 = v10;
  if ((v10 & 0x80000000) != 0) {
    return v11;
  }
  x509_name_canon(v3);
LABEL_16:
  int v12 = *(uint64_t **)(v3 + 16);
  uint64_t v11 = *v12;
  if (a2)
  {
    memcpy(*a2, (const void *)v12[1], (int)v11);
    *a2 = (char *)*a2 + (int)v11;
  }
  return v11;
}

uint64_t x509_name_ex_print(BIO *a1, X509_NAME **a2, int a3, uint64_t a4, uint64_t a5)
{
  return 2 * (X509_NAME_print_ex(a1, *a2, a3, *(void *)(a5 + 8)) > 0);
}

X509_NAME *__cdecl d2i_X509_NAME(X509_NAME **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_NAME *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_NAME_it);
}

int i2d_X509_NAME(X509_NAME *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_NAME_it);
}

X509_NAME *X509_NAME_new(void)
{
  return (X509_NAME *)ASN1_item_new(&X509_NAME_it);
}

void X509_NAME_free(X509_NAME *a)
{
}

X509_NAME *__cdecl X509_NAME_dup(X509_NAME *xn)
{
  return (X509_NAME *)ASN1_item_dup(&X509_NAME_it, xn);
}

int X509_NAME_set(X509_NAME **xn, X509_NAME *name)
{
  if (*xn == name)
  {
    LODWORD(v3) = name != 0;
  }
  else
  {
    uint64_t v3 = (X509_NAME *)ASN1_item_dup(&X509_NAME_it, name);
    if (v3)
    {
      unsigned int v4 = v3;
      ASN1_item_free((ASN1_VALUE *)*xn, &X509_NAME_it);
      *xn = v4;
      LODWORD(v3) = 1;
    }
  }
  return (int)v3;
}

uint64_t X509_NAME_get0_der(uint64_t a1, void *a2, void *a3)
{
  if (ASN1_item_i2d((ASN1_VALUE *)a1, 0, &X509_NAME_it) < 1) {
    return 0;
  }
  if (a2) {
    *a2 = *(void *)(*(void *)(a1 + 16) + 8);
  }
  if (a3) {
    *a3 = **(void **)(a1 + 16);
  }
  return 1;
}

uint64_t x509_name_canon(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    free(v2);
    *(void *)(a1 + 24) = 0;
  }
  if (sk_num(*(const STACK **)a1))
  {
    uint64_t v3 = sk_new_null();
    if (v3)
    {
      unsigned int v4 = v3;
      int v39 = 0;
      if (sk_num(*(const STACK **)a1) >= 1)
      {
        int v5 = 0;
        int v6 = 0;
        int v38 = -1;
        uint64_t v7 = MEMORY[0x263EF8318];
        do
        {
          int v8 = sk_value(*(const STACK **)a1, v5);
          if (*((_DWORD *)v8 + 4) != v38)
          {
            int v9 = (char *)sk_new_null();
            if (!v9) {
              goto LABEL_54;
            }
            int v6 = (STACK *)v9;
            if (!sk_push(v4, v9))
            {
              sk_free(v6);
              goto LABEL_54;
            }
            int v38 = *((_DWORD *)v8 + 4);
          }
          uint64_t v10 = ASN1_item_new(&X509_NAME_ENTRY_it);
          if (!v10) {
            goto LABEL_54;
          }
          uint64_t v11 = v10;
          int v12 = OBJ_dup(*(const ASN1_OBJECT **)v8);
          *(void *)uint64_t v11 = v12;
          if (!v12) {
            goto LABEL_53;
          }
          int8x16_t v13 = (ASN1_STRING *)*((void *)v11 + 1);
          int v14 = (ASN1_STRING *)*((void *)v8 + 1);
          if ((ASN1_tag2bit(v14->type) & 0x2956) == 0)
          {
            BOOL v22 = ASN1_STRING_copy(v13, (uint64_t)v14) != 0;
            goto LABEL_44;
          }
          v13->type = 12;
          p_unint64_t data = &v13->data;
          int v16 = ASN1_STRING_to_UTF8(&v13->data, v14);
          v13->int length = v16;
          if (v16 == -1)
          {
LABEL_53:
            ASN1_item_free(v11, &X509_NAME_ENTRY_it);
            goto LABEL_54;
          }
          __n128 v17 = *p_data;
          if (v16 < 1)
          {
            uint64_t v21 = *p_data;
            goto LABEL_43;
          }
          uint64_t v18 = 0;
          int v19 = v16;
          while (((char)v17[v18] & 0x80000000) == 0 && (*(_DWORD *)(v7 + 4 * v17[v18] + 60) & 0x4000) != 0)
          {
            ++v18;
            BOOL v20 = __OFSUB__(v19--, 1);
            if ((v19 < 0) ^ v20 | (v19 == 0))
            {
              uint64_t v21 = *p_data;
              goto LABEL_43;
            }
          }
          __int16 v37 = v6;
          uint64_t v23 = &v17[v18];
          uint64_t v24 = v16 - 1;
          while (((char)v17[v24] & 0x80000000) == 0 && (*(_DWORD *)(v7 + 4 * v17[v24] + 60) & 0x4000) != 0)
          {
            --v24;
            BOOL v20 = __OFSUB__(v19--, 1);
            if ((v19 < 0) ^ v20 | (v19 == 0))
            {
              LODWORD(v21) = *p_data;
              goto LABEL_42;
            }
          }
          int v36 = v4;
          int v25 = 0;
          do
          {
            int v26 = (char)*v23;
            if (v26 < 0)
            {
              ++v23;
              unsigned __int8 *v17 = v26;
              goto LABEL_35;
            }
            if ((*(_DWORD *)(v7 + 4 * *v23 + 60) & 0x4000) == 0)
            {
              unsigned __int8 *v17 = __tolower(*v23++);
LABEL_35:
              ++v25;
              goto LABEL_36;
            }
            unsigned __int8 *v17 = 32;
            __int8 v27 = v23 + 1;
            int v28 = v25 + 1;
            do
            {
              uint64_t v23 = v27;
              int v25 = v28;
              int v29 = (char)*v27;
              if (v29 < 0) {
                break;
              }
              int v30 = *(_DWORD *)(v7 + 4 * v29 + 60);
              __int8 v27 = v23 + 1;
              ++v28;
            }
            while ((v30 & 0x4000) != 0);
LABEL_36:
            ++v17;
          }
          while (v25 < v19);
          uint64_t v21 = *p_data;
          unsigned int v4 = v36;
LABEL_42:
          int v6 = v37;
LABEL_43:
          v13->int length = v17 - v21;
          BOOL v22 = 1;
LABEL_44:
          if (!v22 || !v6 || !sk_push(v6, (char *)v11)) {
            goto LABEL_53;
          }
          ++v5;
        }
        while (v5 < sk_num(*(const STACK **)a1));
      }
      unsigned int v31 = i2d_name_canon(v4, 0);
      if ((v31 & 0x80000000) != 0
        || (unsigned int v32 = v31, v33 = (unsigned __int8 *)malloc_type_malloc(v31, 0x8AC01138uLL), (v39 = v33) == 0))
      {
LABEL_54:
        uint64_t v34 = 0;
      }
      else
      {
        *(void *)(a1 + 24) = v33;
        *(_DWORD *)(a1 + 32) = v32;
        i2d_name_canon(v4, &v39);
        uint64_t v34 = 1;
      }
      sk_pop_free(v4, (void (__cdecl *)(void *))local_sk_X509_NAME_ENTRY_pop_free);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 32) = 0;
    return 1;
  }
  return v34;
}

uint64_t i2d_name_canon(const STACK *a1, unsigned __int8 **a2)
{
  punint64_t val = 0;
  if (sk_num(a1) < 1) {
    return 0;
  }
  LODWORD(v4) = 0;
  int v5 = 0;
  while (1)
  {
    punint64_t val = (ASN1_VALUE *)sk_value(a1, v5);
    uint64_t v6 = ASN1_item_ex_i2d(&pval, a2, &X509_NAME_ENTRIES_it, -1, -1);
    if ((v6 & 0x80000000) != 0) {
      break;
    }
    uint64_t v4 = (v6 + v4);
    if (++v5 >= sk_num(a1)) {
      return v4;
    }
  }
  return v6;
}

void local_sk_X509_NAME_ENTRY_pop_free(STACK *a1)
{
}

uint64_t asn1_time_tm_to_time_t(int *a1, void *a2)
{
  int v2 = a1[5];
  if (v2 > 9999) {
    return 0;
  }
  int v3 = a1[4];
  if (v3 > 12) {
    return 0;
  }
  uint64_t v6 = 0;
  uint64_t result = posix_time_from_utc(v2 + 1900, v3 + 1, a1[3], a1[2], a1[1], *a1, &v6);
  if (result)
  {
    *a2 = v6;
    return 1;
  }
  return result;
}

uint64_t asn1_time_time_t_to_tm(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  *(void *)(a2 + 48) = 0;
  *(_OWORD *)(a2 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = 0u;
  int v3 = (int32x2_t *)(a2 + 16);
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  uint64_t result = utc_from_posix_time(v2, (_DWORD *)(a2 + 20), (int *)(a2 + 16), (_DWORD *)(a2 + 12), (unsigned int *)(a2 + 8), (unsigned int *)(a2 + 4), (unsigned int *)a2);
  if (result)
  {
    int32x2_t *v3 = vadd_s32(*v3, (int32x2_t)0xFFFFF894FFFFFFFFLL);
    return 1;
  }
  return result;
}

uint64_t OPENSSL_gmtime_adj(int *a1, int a2, uint64_t a3)
{
  uint64_t v4 = a1 + 5;
  int v3 = a1[5];
  if (v3 > 9999) {
    return 0;
  }
  uint64_t v7 = (int32x2_t *)(a1 + 4);
  int v6 = a1[4];
  if (v6 > 12) {
    return 0;
  }
  uint64_t v11 = 0;
  uint64_t result = posix_time_from_utc(v3 + 1900, v6 + 1, a1[3], a1[2], a1[1], *a1, &v11);
  if (result)
  {
    uint64_t result = utc_from_posix_time(a3 + 86400 * a2 + v11, v4, (int *)v7, a1 + 3, (unsigned int *)a1 + 2, (unsigned int *)a1 + 1, (unsigned int *)a1);
    if (result)
    {
      *uint64_t v7 = vadd_s32(*v7, (int32x2_t)0xFFFFF894FFFFFFFFLL);
      return 1;
    }
  }
  return result;
}

uint64_t posix_time_from_utc(unsigned int a1, unsigned int a2, int a3, int a4, int a5, int a6, void *a7)
{
  if (a1 >> 4 > 0x270 || (int)a2 < 1 || a3 < 1) {
    return 0;
  }
  uint64_t v9 = 0;
  if (a2 <= 0xC)
  {
    if (((1 << a2) & 0x15AA) != 0)
    {
      unsigned int v10 = 31;
    }
    else if (((1 << a2) & 0xA50) != 0)
    {
      unsigned int v10 = 30;
    }
    else
    {
      if (a2 != 2) {
        return v9;
      }
      HIDWORD(v18) = -1030792151 * (unsigned __int16)a1;
      LODWORD(v18) = HIDWORD(v18);
      BOOL v19 = (v18 >> 2) > 0x28F5C28 && (a1 & 3) == 0;
      HIDWORD(v21) = -1030792151 * (unsigned __int16)a1;
      LODWORD(v21) = HIDWORD(v21);
      unsigned int v20 = v21 >> 4;
      if (!v19 && v20 >= 0xA3D70B) {
        unsigned int v10 = 28;
      }
      else {
        unsigned int v10 = 29;
      }
    }
    if (v10 < a3) {
      return 0;
    }
    uint64_t v9 = 0;
    if (a6 <= 59 && a5 <= 59 && a4 <= 23 && ((a5 | a4 | a6) & 0x80000000) == 0)
    {
      int v12 = (__PAIR64__(a1, a2) - 3) >> 32;
      __int16 v13 = v12 - 399;
      if (v12 >= 0) {
        __int16 v13 = (__PAIR64__(a1, a2) - 3) >> 32;
      }
      signed int v14 = ((5243 * v13) >> 21) + ((5243 * v13) >> 31);
      uint64_t v15 = v12 - 400 * v14;
      if (a2 <= 2) {
        __int16 v16 = 9;
      }
      else {
        __int16 v16 = -3;
      }
      int v17 = 26215 * (__int16)(153 * (v16 + a2) + 2);
      *a7 = 60 * a5
          + 3600 * a4
          + a6
          + 86400
          * ((int)(a3 + (v17 >> 17) + (v17 >> 31) - 1)
           + 146097 * v14
           + 365 * v15
           + ((int)((v15 + (((__int16)v15 >> 29) & 3)) << 16) >> 18)
           + (int)(((-5243 * (__int16)v15) >> 19) + ((-5243 * (__int16)v15) >> 31)))
          - 0xE79256200;
      return 1;
    }
  }
  return v9;
}

uint64_t utc_from_posix_time(uint64_t a1, _DWORD *a2, int *a3, _DWORD *a4, unsigned int *a5, unsigned int *a6, unsigned int *a7)
{
  if ((unint64_t)(a1 - 0x3AFFF44180) < 0xFFFFFFB686974280) {
    return 0;
  }
  uint64_t v8 = a1 / 86400 + ((a1 % 86400) >> 63);
  if (a1 % 86400 >= 0) {
    uint64_t v9 = a1 % 86400;
  }
  else {
    uint64_t v9 = a1 % 86400 + 86400;
  }
  int v10 = v8 + 573372;
  if (v8 > -719468) {
    int v10 = v8 + 719468;
  }
  int v11 = v10 / 146097;
  uint64_t v12 = v8 + 719468 - 146097 * v11;
  int v13 = ((int)(((unint64_t)(1282606671 * (int)v12) >> 32) - v12) >> 10)
      + ((((unint64_t)(1282606671 * (int)v12) >> 32) - v12) >> 31)
      + v12
      + (int)v12 / 36524
      + ((int)(((unint64_t)(441679365 * (int)v12) >> 32) - v12) >> 17)
      + ((((unint64_t)(441679365 * (int)v12) >> 32) - v12) >> 31);
  *a2 = v13 / 365 + 400 * v11;
  uint64_t v14 = v12
      + (int)(((int)(((unint64_t)(1282606671 * v13) >> 32) - v13) >> 10)
            + ((((unint64_t)(1282606671 * v13) >> 32) - v13) >> 31))
      + v13 / 36500
      - 365 * (v13 / 365);
  int v15 = (5 * (int)v14 + 2) / 153;
  if (v14 >= 306) {
    int v16 = -9;
  }
  else {
    int v16 = 3;
  }
  int v17 = v16 + v15;
  *a3 = v17;
  if (v17 <= 2) {
    ++*a2;
  }
  *a4 = (153 * v15 + 2) / -5 + v14 + 1;
  *a5 = v9 / 0xE10;
  unsigned __int16 v18 = v9 % 0xE10;
  *a6 = v18 / 0x3Cu;
  *a7 = v18 % 0x3Cu;
  return 1;
}

uint64_t OPENSSL_gmtime_diff(_DWORD *a1, _DWORD *a2, int *a3, int *a4)
{
  uint64_t v10 = 0;
  uint64_t result = posix_time_from_utc(a4[5] + 1900, a4[4] + 1, a4[3], a4[2], a4[1], *a4, &v10);
  if (result)
  {
    uint64_t v9 = 0;
    uint64_t result = posix_time_from_utc(a3[5] + 1900, a3[4] + 1, a3[3], a3[2], a3[1], *a3, &v9);
    if (result)
    {
      uint64_t v8 = v10 - v9;
      if ((unint64_t)(v10 - v9 - 0xA8C000000000) >= 0xFFFEAE7FFFFEAE81)
      {
        *a2 = v8 % 86400;
        *a1 = v8 / 86400;
        return 1;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

int SHA224_Init(SHA256_CTX *c)
{
  *(_OWORD *)&c->data[10] = 0u;
  *(_OWORD *)&c->data[14] = 0u;
  *(_OWORD *)&c->void data[2] = 0u;
  *(_OWORD *)&c->data[6] = 0u;
  *(_OWORD *)c->h = xmmword_23C70EA20;
  *(_OWORD *)&c->h[4] = xmmword_23C70EA30;
  *(_OWORD *)&c->Nl = 0u;
  c->md_len = 28;
  return 1;
}

int SHA256_Init(SHA256_CTX *c)
{
  *(_OWORD *)&c->data[10] = 0u;
  *(_OWORD *)&c->data[14] = 0u;
  *(_OWORD *)&c->void data[2] = 0u;
  *(_OWORD *)&c->data[6] = 0u;
  *(_OWORD *)c->h = xmmword_23C70EA40;
  *(_OWORD *)&c->h[4] = xmmword_23C70EA50;
  *(_OWORD *)&c->Nl = 0u;
  c->md_len = 32;
  return 1;
}

unsigned __int8 *__cdecl SHA224(const unsigned __int8 *d, size_t n, unsigned __int8 *md)
{
  if (md) {
    int v3 = md;
  }
  else {
    int v3 = (unsigned __int8 *)&SHA224_m;
  }
  memset(&v5.Nl, 0, 76);
  *(_OWORD *)v5.h = xmmword_23C70EA20;
  *(_OWORD *)&v5.h[4] = xmmword_23C70EA30;
  v5.md_len = 28;
  SHA256_Update(&v5, d, n);
  SHA256_Final(v3, &v5);
  explicit_bzero(&v5, 0x70uLL);
}

int SHA256_Update(SHA256_CTX *c, const void *data, size_t len)
{
  if (len)
  {
    size_t v3 = len;
    uint64_t v4 = (unsigned int *)data;
    *(void *)&c->Nl += 8 * len;
    uint64_t num = c->num;
    if (num)
    {
      uint64_t v7 = c->data;
      uint64_t v8 = (char *)c->data + num;
      if (len <= 0x3F && num + len < 0x40)
      {
        memcpy(v8, data, len);
        c->num += v3;
        return 1;
      }
      uint64_t v9 = 64 - num;
      memcpy(v8, data, 64 - num);
      sha256_block_data_order((unint64_t)c, c->data, 1);
      uint64_t v4 = (unsigned int *)((char *)v4 + v9);
      v3 -= v9;
      c->uint64_t num = 0;
      *(_OWORD *)uint64_t v7 = 0u;
      *(_OWORD *)&c->data[4] = 0u;
      *(_OWORD *)&c->data[8] = 0u;
      *(_OWORD *)&c->data[12] = 0u;
    }
    if (v3 >= 0x40)
    {
      sha256_block_data_order((unint64_t)c, v4, v3 >> 6);
      uint64_t v4 = (unsigned int *)((char *)v4 + (v3 & 0xFFFFFFFFFFFFFFC0));
      v3 &= 0x3Fu;
    }
    if (v3)
    {
      c->uint64_t num = v3;
      memcpy(c->data, v4, v3);
    }
  }
  return 1;
}

int SHA256_Final(unsigned __int8 *md, SHA256_CTX *c)
{
  unint64_t data = c->data;
  uint64_t num = c->num;
  *((unsigned char *)c->data + num) = 0x80;
  uint64_t v6 = num + 1;
  if (num >= 0x38)
  {
    bzero((char *)data + v6, 63 - num);
    sha256_block_data_order((unint64_t)c, data, 1);
    uint64_t v6 = 0;
  }
  bzero((char *)data + v6, 56 - v6);
  unsigned int v7 = bswap32(c->Nl);
  c->data[14] = bswap32(c->Nh);
  c->data[15] = v7;
  sha256_block_data_order((unint64_t)c, data, 1);
  c->uint64_t num = 0;
  *(_OWORD *)unint64_t data = 0u;
  *((_OWORD *)data + 1) = 0u;
  *((_OWORD *)data + 2) = 0u;
  *((_OWORD *)data + 3) = 0u;
  unsigned int md_len = c->md_len;
  if (md_len == 28)
  {
    for (uint64_t i = 0; i != 7; ++i)
      *(_DWORD *)&md[i * 4] = bswap32(c->h[i]);
  }
  else if (md_len == 32)
  {
    for (uint64_t j = 0; j != 8; ++j)
      *(_DWORD *)&md[j * 4] = bswap32(c->h[j]);
  }
  else
  {
    if (md_len > 0x20) {
      return 0;
    }
    if (md_len >= 4)
    {
      unint64_t v12 = 0;
      do
      {
        *(_DWORD *)md = bswap32(c->h[v12]);
        md += 4;
        ++v12;
      }
      while (v12 < (unint64_t)c->md_len >> 2);
    }
  }
  return 1;
}

unsigned __int8 *__cdecl SHA256(const unsigned __int8 *d, size_t n, unsigned __int8 *md)
{
  if (md) {
    size_t v3 = md;
  }
  else {
    size_t v3 = (unsigned __int8 *)&SHA256_m;
  }
  memset(&v5.Nl, 0, 76);
  *(_OWORD *)v5.h = xmmword_23C70EA40;
  *(_OWORD *)&v5.h[4] = xmmword_23C70EA50;
  v5.unsigned int md_len = 32;
  SHA256_Update(&v5, d, n);
  SHA256_Final(v3, &v5);
  explicit_bzero(&v5, 0x70uLL);
}

int SHA224_Update(SHA256_CTX *c, const void *data, size_t len)
{
  return 1;
}

unint64_t sha256_block_data_order(unint64_t result, unsigned int *a2, uint64_t a3)
{
  unint64_t v217 = (_DWORD *)result;
  uint64_t v229 = *MEMORY[0x263EF8340];
  if (a3)
  {
    unsigned int v3 = *(_DWORD *)result;
    int v4 = *(_DWORD *)(result + 4);
    int v6 = *(_DWORD *)(result + 8);
    int v5 = *(_DWORD *)(result + 12);
    int v8 = *(_DWORD *)(result + 16);
    int v7 = *(_DWORD *)(result + 20);
    int v9 = *(_DWORD *)(result + 24);
    LODWORD(result) = *(_DWORD *)(result + 28);
    do
    {
      uint64_t v227 = a3;
      unsigned int v10 = bswap32(*a2);
      HIDWORD(v11) = v8;
      LODWORD(v11) = v8;
      int v12 = (v11 >> 6) ^ __ROR4__(v8, 11);
      unint64_t v13 = __PAIR64__(v3, __ROR4__(v8, 25));
      int v218 = result;
      int v14 = (v7 & v8) + result + (v9 & ~v8) + v10 + (v12 ^ v13) + 1116352408;
      LODWORD(v13) = v3;
      int v222 = v5;
      int v15 = v14 + v5;
      unsigned int v16 = ((v6 ^ v4) & v3 ^ v6 & v4) + ((v13 >> 2) ^ __ROR4__(v3, 13) ^ __ROR4__(v3, 22)) + v14;
      unsigned int v17 = bswap32(a2[1]);
      HIDWORD(v13) = v15;
      LODWORD(v13) = v15;
      v228[0] = v10;
      v228[1] = v17;
      int v18 = (v13 >> 6) ^ __ROR4__(v15, 11);
      unint64_t v19 = __PAIR64__(v16, __ROR4__(v15, 25));
      int v219 = v9;
      int v20 = v9 + (v7 & ~v15) + (v15 & v8) + v17 + 1899447441 + (v18 ^ v19);
      LODWORD(v19) = v16;
      int v223 = v6;
      int v21 = v20 + v6;
      unsigned int v22 = ((v19 >> 2) ^ __ROR4__(v16, 13) ^ __ROR4__(v16, 22)) + (v16 & (v4 ^ v3) ^ v4 & v3) + v20;
      unsigned int v23 = bswap32(a2[2]);
      HIDWORD(v19) = v21;
      LODWORD(v19) = v21;
      int v24 = (v19 >> 6) ^ __ROR4__(v21, 11);
      unint64_t v26 = __PAIR64__(v22, __ROR4__(v21, 25));
      int v25 = v24 ^ v26;
      int v220 = v7;
      LODWORD(v26) = v22;
      int v27 = v7 + v23 + (v8 & ~v21) + (v21 & v15) - 1245643825 + v25;
      int v224 = v4;
      int v28 = v27 + v4;
      unsigned int v29 = ((v26 >> 2) ^ __ROR4__(v22, 13) ^ __ROR4__(v22, 22)) + (v22 & (v16 ^ v3) ^ v16 & v3) + v27;
      unsigned int v30 = bswap32(a2[3]);
      v228[2] = v23;
      v228[3] = v30;
      HIDWORD(v26) = v28;
      LODWORD(v26) = v28;
      int v31 = (v26 >> 6) ^ __ROR4__(v28, 11);
      unint64_t v32 = __PAIR64__(v29, __ROR4__(v28, 25));
      int v221 = v8;
      int v33 = v8 + v30 + (v15 & ~v28) + (v28 & v21) - 373957723 + (v31 ^ v32);
      LODWORD(v32) = v29;
      unsigned int v225 = v3;
      int v34 = v33 + v3;
      unsigned int v35 = ((v32 >> 2) ^ __ROR4__(v29, 13) ^ __ROR4__(v29, 22)) + (v29 & (v22 ^ v16) ^ v22 & v16) + v33;
      unsigned int v36 = bswap32(a2[4]);
      HIDWORD(v32) = v34;
      LODWORD(v32) = v34;
      int v37 = (v32 >> 6) ^ __ROR4__(v34, 11);
      unint64_t v38 = __PAIR64__(v35, __ROR4__(v34, 25));
      int v39 = v15 + v36 + (v21 & ~v34) + (v34 & v28) + 961987163 + (v37 ^ v38);
      LODWORD(v38) = v35;
      int v40 = v39 + v16;
      unsigned int v41 = ((v38 >> 2) ^ __ROR4__(v35, 13) ^ __ROR4__(v35, 22)) + (v35 & (v29 ^ v22) ^ v29 & v22) + v39;
      unsigned int v42 = bswap32(a2[5]);
      v228[4] = v36;
      v228[5] = v42;
      HIDWORD(v38) = v40;
      LODWORD(v38) = v40;
      int v43 = (v38 >> 6) ^ __ROR4__(v40, 11);
      unint64_t v44 = __PAIR64__(v41, __ROR4__(v40, 25));
      int v45 = v21 + v42 + (v28 & ~v40) + (v40 & v34) + 1508970993 + (v43 ^ v44);
      LODWORD(v44) = v41;
      int v46 = v45 + v22;
      unsigned int v47 = ((v44 >> 2) ^ __ROR4__(v41, 13) ^ __ROR4__(v41, 22)) + (v41 & (v35 ^ v29) ^ v35 & v29) + v45;
      unsigned int v48 = bswap32(a2[6]);
      int v49 = v28 + v48 + (v34 & ~v46) + (v46 & v40);
      HIDWORD(v44) = v46;
      LODWORD(v44) = v46;
      int v50 = (v44 >> 6) ^ __ROR4__(v46, 11);
      unint64_t v51 = __PAIR64__(v47, __ROR4__(v46, 25));
      int v52 = v49 - 1841331548 + (v50 ^ v51);
      LODWORD(v51) = v47;
      int v53 = v52 + v29;
      unsigned int v54 = ((v51 >> 2) ^ __ROR4__(v47, 13) ^ __ROR4__(v47, 22)) + (v47 & (v41 ^ v35) ^ v41 & v35) + v52;
      unsigned int v55 = bswap32(a2[7]);
      HIDWORD(v51) = v53;
      LODWORD(v51) = v53;
      v228[6] = v48;
      v228[7] = v55;
      int v56 = (v51 >> 6) ^ __ROR4__(v53, 11);
      unint64_t v57 = __PAIR64__(v54, __ROR4__(v53, 25));
      int v58 = v34 + v55 + (v40 & ~v53) + (v53 & v46) - 1424204075 + (v56 ^ v57);
      LODWORD(v57) = v54;
      int v59 = v58 + v35;
      unsigned int v60 = ((v57 >> 2) ^ __ROR4__(v54, 13) ^ __ROR4__(v54, 22)) + (v54 & (v47 ^ v41) ^ v47 & v41) + v58;
      HIDWORD(v57) = v59;
      LODWORD(v57) = v59;
      unsigned int v61 = bswap32(a2[8]);
      int v62 = (v57 >> 6) ^ __ROR4__(v59, 11);
      unint64_t v63 = __PAIR64__(v60, __ROR4__(v59, 25));
      int v64 = v40 + v61 + (v46 & ~v59) + (v59 & v53) - 670586216 + (v62 ^ v63);
      LODWORD(v63) = v60;
      int v65 = v64 + v41;
      unsigned int v66 = ((v63 >> 2) ^ __ROR4__(v60, 13) ^ __ROR4__(v60, 22)) + (v60 & (v54 ^ v47) ^ v54 & v47) + v64;
      unsigned int v67 = bswap32(a2[9]);
      v228[8] = v61;
      v228[9] = v67;
      HIDWORD(v63) = v65;
      LODWORD(v63) = v65;
      int v68 = (v63 >> 6) ^ __ROR4__(v65, 11);
      unint64_t v69 = __PAIR64__(v66, __ROR4__(v65, 25));
      int v70 = v46 + v67 + (v53 & ~v65) + (v65 & v59) + 310598401 + (v68 ^ v69);
      LODWORD(v69) = v66;
      int v71 = v70 + v47;
      unsigned int v72 = ((v69 >> 2) ^ __ROR4__(v66, 13) ^ __ROR4__(v66, 22)) + (v66 & (v60 ^ v54) ^ v60 & v54) + v70;
      unsigned int v73 = bswap32(a2[10]);
      int v74 = v53 + v73 + (v59 & ~v71) + (v71 & v65);
      HIDWORD(v69) = v71;
      LODWORD(v69) = v71;
      int v75 = (v69 >> 6) ^ __ROR4__(v71, 11);
      unint64_t v76 = __PAIR64__(v72, __ROR4__(v71, 25));
      int v77 = v74 + 607225278 + (v75 ^ v76);
      LODWORD(v76) = v72;
      int v78 = v77 + v54;
      unsigned int v79 = ((v76 >> 2) ^ __ROR4__(v72, 13) ^ __ROR4__(v72, 22)) + (v72 & (v66 ^ v60) ^ v66 & v60) + v77;
      unsigned int v80 = bswap32(a2[11]);
      v228[10] = v73;
      v228[11] = v80;
      HIDWORD(v76) = v78;
      LODWORD(v76) = v78;
      int v81 = (v76 >> 6) ^ __ROR4__(v78, 11);
      unint64_t v82 = __PAIR64__(v79, __ROR4__(v78, 25));
      int v83 = v80 + v59 + (v65 & ~v78) + (v78 & v71) + 1426881987 + (v81 ^ v82);
      LODWORD(v82) = v79;
      int v84 = v83 + v60;
      unsigned int v85 = ((v82 >> 2) ^ __ROR4__(v79, 13) ^ __ROR4__(v79, 22)) + (v79 & (v72 ^ v66) ^ v72 & v66) + v83;
      unsigned int v86 = bswap32(a2[12]);
      HIDWORD(v82) = v84;
      LODWORD(v82) = v84;
      int v87 = (v82 >> 6) ^ __ROR4__(v84, 11);
      unint64_t v88 = __PAIR64__(v85, __ROR4__(v84, 25));
      int v89 = v86 + v65 + (v71 & ~v84) + (v84 & v78) + 1925078388 + (v87 ^ v88);
      LODWORD(v88) = v85;
      unsigned int v90 = v89 + v66;
      unsigned int v91 = ((v88 >> 2) ^ __ROR4__(v85, 13) ^ __ROR4__(v85, 22)) + (v85 & (v79 ^ v72) ^ v79 & v72) + v89;
      unsigned int v92 = bswap32(a2[13]);
      HIDWORD(v88) = v90;
      LODWORD(v88) = v90;
      v228[12] = v86;
      v228[13] = v92;
      int v93 = (v88 >> 6) ^ __ROR4__(v90, 11);
      unint64_t v94 = __PAIR64__(v91, __ROR4__(v90, 25));
      int v95 = v92 + v71 + (v78 & ~v90) + (v90 & v84) - 2132889090 + (v93 ^ v94);
      LODWORD(v94) = v91;
      unsigned int v96 = v95 + v72;
      unsigned int v97 = ((v94 >> 2) ^ __ROR4__(v91, 13) ^ __ROR4__(v91, 22)) + (v91 & (v85 ^ v79) ^ v85 & v79) + v95;
      HIDWORD(v94) = v96;
      LODWORD(v94) = v95 + v72;
      unint64_t v226 = a2;
      unsigned int v98 = bswap32(a2[14]);
      int v99 = (v94 >> 6) ^ __ROR4__(v96, 11);
      unint64_t v100 = __PAIR64__(v97, __ROR4__(v96, 25));
      int v101 = v98 + v78 + (v84 & ~v96) + (v96 & v90) - 1680079193 + (v99 ^ v100);
      LODWORD(v100) = v97;
      unsigned int v102 = v101 + v79;
      unsigned int v103 = ((v100 >> 2) ^ __ROR4__(v97, 13) ^ __ROR4__(v97, 22)) + (v97 & (v91 ^ v85) ^ v91 & v85) + v101;
      unsigned int v104 = bswap32(a2[15]);
      v228[14] = v98;
      v228[15] = v104;
      HIDWORD(v100) = v102;
      LODWORD(v100) = v102;
      int v105 = (v100 >> 6) ^ __ROR4__(v102, 11);
      unint64_t v106 = __PAIR64__(v103, __ROR4__(v102, 25));
      int v107 = v104 + v84 + (v90 & ~v102) + (v102 & v96) - 1046744716 + (v105 ^ v106);
      LODWORD(v106) = v103;
      unsigned int v108 = v107 + v85;
      unsigned int v109 = ((v106 >> 2) ^ __ROR4__(v103, 13) ^ __ROR4__(v103, 22)) + (v103 & (v97 ^ v91) ^ v97 & v91) + v107;
      unint64_t v110 = &dword_23C70EABC;
      uint64_t v111 = 31;
      do
      {
        unint64_t v112 = v111 - 15;
        uint64_t v113 = ((int)v111 - 14) & 9;
        unsigned int v114 = v228[v113];
        unsigned int v115 = v228[((_BYTE)v111 - 1) & 0xE];
        HIDWORD(v117) = v114;
        LODWORD(v117) = v114;
        int v116 = v117 >> 7;
        unint64_t v119 = __PAIR64__(v115, __ROR4__(v114, 18));
        int v118 = v116 ^ v119;
        LODWORD(v119) = v115;
        int v120 = v119 >> 17;
        unint64_t v121 = __PAIR64__(v108, __ROR4__(v115, 19));
        uint64_t v122 = (v111 - 15) & 8;
        int v123 = v120 ^ v121 ^ (v115 >> 10);
        LODWORD(v121) = v108;
        int v124 = (v111 - 15) & 8;
        unsigned int v125 = (v118 ^ (v114 >> 3)) + v228[((int)v111 - 6) & 9] + v228[v122] + v123;
        int v126 = (v121 >> 6) ^ __ROR4__(v108, 11);
        unint64_t v128 = __PAIR64__(v109, __ROR4__(v108, 25));
        int v127 = v126 ^ v128;
        LODWORD(v128) = v109;
        int v129 = *(v110 - 6);
        int v130 = v127 + (v102 & v108) + v90 + (v96 & ~v108) + *(v110 - 7);
        v228[v122] = v125;
        LODWORD(v122) = ((v97 ^ v103) & v109 ^ v97 & v103) + ((v128 >> 2) ^ __ROR4__(v109, 13) ^ __ROR4__(v109, 22));
        int v131 = v130 + v125;
        unsigned int v132 = v131 + v91;
        HIDWORD(v128) = v228[v124 | 2];
        LODWORD(v128) = HIDWORD(v128);
        unsigned int v133 = v122 + v131;
        unsigned int v134 = v228[v111 & 0xF];
        int v135 = (v128 >> 7) ^ __ROR4__(HIDWORD(v128), 18) ^ (HIDWORD(v128) >> 3);
        HIDWORD(v128) = v134;
        LODWORD(v128) = v134;
        int v136 = v128 >> 17;
        unint64_t v137 = __PAIR64__(v132, __ROR4__(v134, 19));
        int v138 = v228[((int)v111 - 5) & 0xALL] + v114 + (v136 ^ v137 ^ (v134 >> 10));
        LODWORD(v137) = v132;
        int v139 = v138 + v135;
        int v140 = (v137 >> 6) ^ __ROR4__(v132, 11);
        unint64_t v142 = __PAIR64__(v133, __ROR4__(v132, 25));
        int v141 = v140 ^ v142;
        LODWORD(v142) = v133;
        v228[v113] = v139;
        LODWORD(v113) = (v142 >> 2) ^ __ROR4__(v133, 13);
        unint64_t v143 = __PAIR64__(v125, __ROR4__(v133, 22));
        int v144 = (v102 & ~v132) + v96 + (v132 & v108) + v129 + v139 + v141;
        int v145 = (v113 ^ v143) + (v133 & (v103 ^ v109) ^ v103 & v109);
        unsigned int v146 = v144 + v97;
        unsigned int v147 = v228[v124 | 3];
        LODWORD(v143) = v125;
        int v148 = v143 >> 17;
        HIDWORD(v143) = v147;
        LODWORD(v143) = v147;
        LODWORD(v122) = (v143 >> 7) ^ __ROR4__(v147, 18);
        unint64_t v149 = __PAIR64__(v146, __ROR4__(v125, 19));
        int v150 = v148 ^ v149 ^ (v125 >> 10);
        uint64_t v151 = ((int)v111 - 13) & 0xALL;
        unsigned int v152 = v145 + v144;
        int v153 = v228[((int)v111 - 4) & 0xBLL] + v228[v151] + (v122 ^ (v147 >> 3)) + v150;
        LODWORD(v149) = v146;
        int v154 = (v149 >> 6) ^ __ROR4__(v146, 11);
        unint64_t v156 = __PAIR64__(v152, __ROR4__(v146, 25));
        int v155 = v154 ^ v156;
        v228[v151] = v153;
        LODWORD(v151) = *(v110 - 4);
        int v157 = *(v110 - 5) + v102 + v153;
        LODWORD(v156) = v152;
        int v158 = ((v156 >> 2) ^ __ROR4__(v152, 13) ^ __ROR4__(v152, 22)) + (v152 & (v133 ^ v109) ^ v133 & v109);
        unsigned int v159 = v228[v124 | 4];
        int v160 = v157 + (v108 & ~v146) + (v146 & v132) + v155;
        HIDWORD(v156) = v159;
        LODWORD(v156) = v159;
        int v161 = v156 >> 7;
        LODWORD(v122) = v228[v124 | 1];
        unint64_t v163 = __PAIR64__(v122, __ROR4__(v159, 18));
        int v162 = v161 ^ v163;
        LODWORD(v163) = v122;
        int v164 = v162 ^ (v159 >> 3);
        uint64_t v165 = ((int)v111 - 12) & 0xBLL;
        int v166 = v160 + v103;
        int v167 = v164
             + v228[((_BYTE)v111 - 3) & 0xC]
             + v228[v165]
             + ((v163 >> 17) ^ __ROR4__(v122, 19) ^ (v122 >> 10));
        unsigned int v168 = v158 + v160;
        HIDWORD(v163) = v166;
        LODWORD(v163) = v166;
        int v169 = (v163 >> 6) ^ __ROR4__(v166, 11);
        unint64_t v171 = __PAIR64__(v168, __ROR4__(v166, 25));
        int v170 = v169 ^ v171;
        v228[v165] = v167;
        LODWORD(v171) = v168;
        int v172 = v151 + v108 + v167 + (v132 & ~v166) + (v166 & v146) + v170;
        int v173 = ((v171 >> 2) ^ __ROR4__(v168, 13) ^ __ROR4__(v168, 22)) + (v168 & (v152 ^ v133) ^ v152 & v133);
        unsigned int v174 = v172 + v109;
        unsigned int v175 = v228[v124 | 5];
        HIDWORD(v171) = v175;
        LODWORD(v171) = v175;
        int v176 = (v171 >> 7) ^ __ROR4__(v175, 18);
        unsigned int v177 = v228[v124 | 2];
        HIDWORD(v171) = v177;
        LODWORD(v171) = v177;
        LODWORD(v165) = v171 >> 17;
        unint64_t v178 = __PAIR64__(v174, __ROR4__(v177, 19));
        uint64_t v179 = ((_BYTE)v111 - 11) & 0xC;
        int v180 = (v176 ^ (v175 >> 3)) + v228[((int)v111 - 2) & 0xDLL] + v228[v179] + (v165 ^ v178 ^ (v177 >> 10));
        unsigned int v181 = v173 + v172;
        LODWORD(v178) = v174;
        int v182 = (v178 >> 6) ^ __ROR4__(v174, 11);
        unint64_t v184 = __PAIR64__(v181, __ROR4__(v174, 25));
        int v183 = v182 ^ v184;
        v228[v179] = v180;
        LODWORD(v165) = *(v110 - 2);
        LODWORD(v184) = v181;
        LODWORD(v151) = ((v184 >> 2) ^ __ROR4__(v181, 13) ^ __ROR4__(v181, 22)) + (v181 & (v168 ^ v152) ^ v168 & v152);
        int v185 = *(v110 - 3) + v180 + v132 + (v146 & ~v174) + (v174 & v166) + v183;
        unsigned int v90 = v185 + v133;
        unsigned int v186 = v228[v124 | 6];
        HIDWORD(v184) = v186;
        LODWORD(v184) = v186;
        int v187 = v184 >> 7;
        LODWORD(v113) = v228[v124 | 3];
        HIDWORD(v184) = v113;
        LODWORD(v184) = v113;
        int v188 = v184 >> 17;
        int v189 = v187 ^ __ROR4__(v186, 18) ^ (v186 >> 3);
        unint64_t v191 = __PAIR64__(v90, __ROR4__(v113, 19));
        int v190 = v188 ^ v191;
        uint64_t v192 = ((int)v111 - 10) & 0xDLL;
        unsigned int v91 = v151 + v185;
        unsigned int v193 = v228[v192] + v115 + v189 + (v190 ^ (v113 >> 10));
        LODWORD(v191) = v90;
        int v194 = (v191 >> 6) ^ __ROR4__(v90, 11);
        unint64_t v196 = __PAIR64__(v91, __ROR4__(v90, 25));
        int v195 = v194 ^ v196;
        v228[v192] = v193;
        LODWORD(v196) = v91;
        int v197 = v165 + v193 + v146 + (v166 & ~v90) + (v90 & v174) + v195;
        int v198 = ((v196 >> 2) ^ __ROR4__(v91, 13) ^ __ROR4__(v91, 22)) + (v91 & (v181 ^ v168) ^ v181 & v168);
        LODWORD(v179) = v228[v124 | 7];
        unsigned int v96 = v197 + v152;
        HIDWORD(v196) = v179;
        LODWORD(v196) = v179;
        LODWORD(v113) = v196 >> 7;
        unsigned int v199 = v228[v124 | 4];
        unint64_t v200 = __PAIR64__(v199, __ROR4__(v179, 18));
        LODWORD(v179) = v113 ^ v200 ^ (v179 >> 3);
        LODWORD(v200) = v199;
        LODWORD(v113) = v200 >> 17;
        unint64_t v201 = __PAIR64__(v96, __ROR4__(v199, 19));
        uint64_t v202 = ((_BYTE)v111 - 9) & 0xE;
        LODWORD(v179) = v228[v202] + v134 + v179 + (v113 ^ v201 ^ (v199 >> 10));
        unsigned int v97 = v198 + v197;
        LODWORD(v201) = v96;
        int v203 = (v201 >> 6) ^ __ROR4__(v96, 11);
        unint64_t v205 = __PAIR64__(v97, __ROR4__(v96, 25));
        int v204 = v203 ^ v205;
        v228[v202] = v179;
        LODWORD(v205) = v97;
        int v206 = *(v110 - 1) + v179 + v166 + (v174 & ~v96) + (v96 & v90) + v204;
        unsigned int v102 = v206 + v168;
        unsigned int v103 = ((v205 >> 2) ^ __ROR4__(v97, 13) ^ __ROR4__(v97, 22)) + (v97 & (v91 ^ v181) ^ v91 & v181) + v206;
        unsigned int v207 = v228[v124 ^ 8];
        HIDWORD(v205) = v207;
        LODWORD(v205) = v207;
        LODWORD(v179) = v205 >> 7;
        unsigned int v208 = v228[v124 | 5];
        HIDWORD(v205) = v208;
        LODWORD(v205) = v208;
        LODWORD(v113) = v205 >> 17;
        int v209 = v179 ^ __ROR4__(v207, 18) ^ (v207 >> 3);
        unint64_t v210 = __PAIR64__(v102, __ROR4__(v208, 19));
        uint64_t v211 = ((_BYTE)v111 - 8) & 0xF;
        LODWORD(v179) = v113 ^ v210 ^ (v208 >> 10);
        LODWORD(v210) = v102;
        int v212 = (v210 >> 6) ^ __ROR4__(v102, 11);
        int v213 = v228[v211] + v209 + v125 + v179;
        unint64_t v214 = __PAIR64__(v103, __ROR4__(v102, 25));
        LODWORD(v179) = v212 ^ v214;
        int v215 = *v110;
        v110 += 8;
        v228[v211] = v213;
        LODWORD(v214) = v103;
        int v216 = v215 + v213 + v174 + (v90 & ~v102) + (v102 & v96) + v179;
        unsigned int v108 = v216 + v181;
        unsigned int v109 = ((v214 >> 2) ^ __ROR4__(v103, 13) ^ __ROR4__(v103, 22)) + (v103 & (v97 ^ v91) ^ v97 & v91) + v216;
        v111 += 8;
      }
      while (v112 < 0x38);
      a2 = v226 + 16;
      unsigned int v3 = v109 + v225;
      int v4 = v103 + v224;
      *unint64_t v217 = v109 + v225;
      v217[1] = v103 + v224;
      int v6 = v97 + v223;
      int v5 = v91 + v222;
      v217[2] = v97 + v223;
      v217[3] = v91 + v222;
      int v8 = v108 + v221;
      int v7 = v102 + v220;
      v217[4] = v108 + v221;
      v217[5] = v102 + v220;
      int v9 = v96 + v219;
      uint64_t result = v90 + v218;
      v217[6] = v96 + v219;
      v217[7] = result;
      a3 = v227 - 1;
    }
    while (v227 != 1);
  }
  return result;
}

void SHA256_Transform(SHA256_CTX *c, const unsigned __int8 *data)
{
}

uint64_t sha3_init(uint64_t a1, unsigned int a2)
{
  if (a2 > 0x63) {
    return 0;
  }
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = 0u;
  uint64_t v2 = 1;
  *(void *)(a1 + 208) = 200 - 2 * a2;
  *(void *)(a1 + 2++*(_DWORD *)(*(void *)(result + 8) + 16) = a2;
  return v2;
}

uint64_t sha3_update(void *a1, char *a2, uint64_t a3)
{
  uint64_t v4 = a1[25];
  if (a3)
  {
    uint64_t v5 = a3;
    do
    {
      char v7 = *a2++;
      uint64_t v8 = v4 + 1;
      *((unsigned char *)a1 + v4) ^= v7;
      if ((unint64_t)(v4 + 1) >= a1[26])
      {
        sha3_keccakf(a1);
        uint64_t v8 = 0;
      }
      uint64_t v4 = v8;
      --v5;
    }
    while (v5);
  }
  else
  {
    uint64_t v8 = a1[25];
  }
  a1[25] = v8;
  return 1;
}

void *sha3_keccakf(void *result)
{
  uint64_t v1 = 0;
  uint64_t v25 = *MEMORY[0x263EF8340];
  do
  {
    for (uint64_t i = 0; i != 5; ++i)
      *(void *)((char *)v23 + i * 8) = result[i + 5] ^ result[i] ^ result[i + 10] ^ result[i + 15] ^ result[i + 20];
    uint64_t v3 = 0;
    uint64_t v4 = result;
    do
    {
      unint64_t v5 = 0;
      uint64_t v6 = (v3 - 1);
      if (!v3) {
        uint64_t v6 = 4;
      }
      uint64_t v7 = *((void *)v23 + v6);
      uint64_t v8 = ++v3;
      if (v3 == 5) {
        uint64_t v8 = 0;
      }
      uint64_t v9 = v7 ^ __ROR8__(*((void *)v23 + v8), 63);
      do
      {
        v4[v5] ^= v9;
        BOOL v10 = v5 >= 0x14;
        v5 += 5;
      }
      while (!v10);
      ++v4;
    }
    while (v3 != 5);
    uint64_t v11 = 0;
    uint64_t v12 = result[1];
    do
    {
      uint64_t v13 = sha3_keccakf_piln[v11];
      uint64_t v14 = result[v13];
      result[v13] = __ROR8__(v12, -sha3_keccakf_rotc[v11 * 4]);
      ++v11;
      uint64_t v12 = v14;
    }
    while (v11 != 24);
    uint64_t v15 = 0;
    unsigned int v16 = result;
    do
    {
      unint64_t v17 = 0;
      int v18 = &result[5 * v15];
      long long v19 = *((_OWORD *)v18 + 1);
      v23[0] = *(_OWORD *)v18;
      v23[1] = v19;
      uint64_t v24 = v18[4];
      do
      {
        if (v17 == 4) {
          unint64_t v20 = 0;
        }
        else {
          unint64_t v20 = v17 + 1;
        }
        uint64_t v21 = *((void *)v23 + v20);
        if (v17 > 2) {
          int v22 = -3;
        }
        else {
          int v22 = 2;
        }
        v16[v17] ^= *((void *)v23 + v22 + (int)v17) & ~v21;
        ++v17;
      }
      while (v17 != 5);
      ++v15;
      v16 += 5;
    }
    while (v15 != 5);
    *result ^= sha3_keccakf_rndc[v1++];
  }
  while (v1 != 24);
  return result;
}

uint64_t sha3_final(uint64_t a1, void *a2)
{
  *((unsigned char *)a2 + a2[25]) ^= 6u;
  *((unsigned char *)a2 + a2[26] - 1) ^= 0x80u;
  sha3_keccakf(a2);
  if (a2[27])
  {
    unint64_t v4 = 0;
    do
    {
      *(unsigned char *)(a1 + v4) = *((unsigned char *)a2 + v4);
      ++v4;
    }
    while (a2[27] > v4);
  }
  return 1;
}

void *shake_xof(void *a1)
{
  *((unsigned char *)a1 + a1[25]) ^= 0x1Fu;
  *((unsigned char *)a1 + a1[26] - 1) ^= 0x80u;
  uint64_t result = sha3_keccakf(a1);
  a1[25] = 0;
  return result;
}

void *shake_out(void *result, unsigned char *a2, uint64_t a3)
{
  uint64_t v3 = result;
  unint64_t v4 = result[25];
  if (a3)
  {
    uint64_t v5 = a3;
    do
    {
      if (v4 >= v3[26])
      {
        uint64_t result = sha3_keccakf(v3);
        unint64_t v4 = 0;
      }
      unint64_t v7 = v4 + 1;
      *a2++ = *((unsigned char *)v3 + v4++);
      --v5;
    }
    while (v5);
  }
  else
  {
    unint64_t v7 = result[25];
  }
  v3[25] = v7;
  return result;
}

UI_METHOD *UI_OpenSSL(void)
{
  return (UI_METHOD *)&ui_openssl;
}

uint64_t open_console()
{
  CRYPTO_lock(9, 31, 0, 0);
  is_a_tty = 1;
  tty_in = (uint64_t)fopen("/dev/tty", "r");
  if (!tty_in) {
    tty_in = *MEMORY[0x263EF8350];
  }
  tty_out = (uint64_t)fopen("/dev/tty", "w");
  if (!tty_out) {
    tty_out = *MEMORY[0x263EF8348];
  }
  int v0 = fileno((FILE *)tty_in);
  if (tcgetattr(v0, (termios *)&tty_orig) != -1) {
    return 1;
  }
  if (*__error() == 25 || *__error() == 22)
  {
    is_a_tty = 0;
    return 1;
  }
  return 0;
}

uint64_t write_string(int a1, UI_STRING *uis)
{
  if ((UI_get_string_type(uis) & 0xFFFFFFFE) == 4)
  {
    uint64_t v3 = UI_get0_output_string(uis);
    fputs(v3, (FILE *)tty_out);
    fflush((FILE *)tty_out);
  }
  return 1;
}

uint64_t read_string(UI *a1, UI_STRING *uis)
{
  UI_string_types string_type = UI_get_string_type(uis);
  switch(string_type)
  {
    case UIT_PROMPT:
      uint64_t v11 = UI_get0_output_string(uis);
      fputs(v11, (FILE *)tty_out);
      fflush((FILE *)tty_out);
      int v7 = UI_get_input_flags(uis) & 1;
      uint64_t v8 = a1;
      uint64_t v9 = uis;
      int v10 = 1;
LABEL_6:
      read_string_inner(v8, v9, v7, v10);
    case UIT_VERIFY:
      uint64_t v12 = (FILE *)tty_out;
      uint64_t v13 = UI_get0_output_string(uis);
      fprintf(v12, "Verifying - %s", v13);
      fflush((FILE *)tty_out);
      input_unint64_t flags = UI_get_input_flags(uis);
      read_string_inner(a1, uis, input_flags & 1, 1);
    case UIT_BOOLEAN:
      uint64_t v5 = UI_get0_output_string(uis);
      fputs(v5, (FILE *)tty_out);
      uint64_t v6 = UI_get0_action_string(uis);
      fputs(v6, (FILE *)tty_out);
      fflush((FILE *)tty_out);
      int v7 = UI_get_input_flags(uis) & 1;
      uint64_t v8 = a1;
      uint64_t v9 = uis;
      int v10 = 0;
      goto LABEL_6;
  }
  return 1;
}

uint64_t close_console()
{
  if (tty_in != *MEMORY[0x263EF8350]) {
    fclose((FILE *)tty_in);
  }
  if (tty_out != *MEMORY[0x263EF8348]) {
    fclose((FILE *)tty_out);
  }
  CRYPTO_lock(10, 31, 0, 0);
  return 1;
}

void read_string_inner(UI *a1, UI_STRING *a2, int a3, int a4)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  intr_signal = 0;
  read_string_inner_ps = 0;
  v19[0].c_iflag = (tcflag_t)recsig;
  v19[0].c_oflag = 0;
  uint64_t v8 = -31;
  uint64_t v9 = (sigaction *)&unk_268BB45F8;
  do
  {
    if (v8 != -23 && ((v8 + 32) & 0x7FFFFFFE) != 0x1E) {
      sigaction(v8 + 32, (const sigaction *)v19, v9);
    }
    ++v9;
    BOOL v10 = __CFADD__(v8++, 1);
  }
  while (!v10);
  signal(28, 0);
  read_string_inner_ps = 1;
  if (!a3)
  {
    *(_OWORD *)v19[0].c_cc = xmmword_268BB45B8;
    *(_OWORD *)&v19[0].c_cc[16] = unk_268BB45C8;
    v19[0].c_ospeed = qword_268BB45D8;
    *(_OWORD *)&v19[0].c_iflag = tty_orig;
    v19[0].c_cflag = unk_268BB45A8;
    v19[0].c_lflag = unk_268BB45B0 & 0xFFFFFFFFFFFFFFF7;
    if (is_a_tty == 1)
    {
      int v11 = fileno((FILE *)tty_in);
      if (tcsetattr(v11, 0, v19) == -1) {
        goto LABEL_29;
      }
    }
  }
  read_string_inner_ps = 2;
  LOBYTE(v19[0].c_iflag) = 0;
  if (fgets((char *)v19, 1023, (FILE *)tty_in))
  {
    if (!feof((FILE *)tty_in))
    {
      uint64_t v12 = (FILE *)tty_in;
      if (!ferror((FILE *)tty_in))
      {
        unsigned int v16 = strchr((char *)v19, 10);
        if (v16)
        {
          if (a4) {
            char *v16 = 0;
          }
LABEL_25:
          UI_set_result(a1, a2, (const char *)v19);
        }
        else
        {
          while (fgets(__s, 4, v12))
          {
            if (strchr(__s, 10)) {
              goto LABEL_25;
            }
          }
        }
      }
    }
  }
  if (!a3)
  {
LABEL_29:
    fputc(10, (FILE *)tty_out);
    int v13 = read_string_inner_ps;
    if (read_string_inner_ps <= 1)
    {
LABEL_15:
      if (v13 < 1) {
        goto LABEL_21;
      }
      goto LABEL_16;
    }
    if (is_a_tty != 1)
    {
LABEL_16:
      uint64_t v14 = -31;
      uint64_t v15 = (const sigaction *)&unk_268BB45F8;
      do
      {
        if (((v14 + 32) & 0x7FFFFFFE) != 0x1E) {
          sigaction(v14 + 32, v15, 0);
        }
        ++v15;
        BOOL v10 = __CFADD__(v14++, 1);
      }
      while (!v10);
LABEL_21:
      explicit_bzero(v19, 0x400uLL);
    }
    int v17 = fileno((FILE *)tty_in);
    tcsetattr(v17, 0, (const termios *)&tty_orig);
  }
  int v13 = read_string_inner_ps;
  goto LABEL_15;
}

uint64_t recsig(uint64_t result)
{
  intr_signal = result;
  return result;
}

int X509_CRL_get_ext_count(X509_CRL *x)
{
  return X509v3_get_ext_count(x->crl->extensions);
}

int X509_CRL_get_ext_by_NID(X509_CRL *x, int nid, int lastpos)
{
  return X509v3_get_ext_by_NID(x->crl->extensions, nid, lastpos);
}

int X509_CRL_get_ext_by_OBJ(X509_CRL *x, ASN1_OBJECT *obj, int lastpos)
{
  return X509v3_get_ext_by_OBJ(x->crl->extensions, obj, lastpos);
}

int X509_CRL_get_ext_by_critical(X509_CRL *x, int crit, int lastpos)
{
  return X509v3_get_ext_by_critical(x->crl->extensions, crit, lastpos);
}

X509_EXTENSION *__cdecl X509_CRL_get_ext(X509_CRL *x, int loc)
{
  return X509v3_get_ext(x->crl->extensions, loc);
}

X509_EXTENSION *__cdecl X509_CRL_delete_ext(X509_CRL *x, int loc)
{
  return X509v3_delete_ext(x->crl->extensions, loc);
}

void *__cdecl X509_CRL_get_ext_d2i(X509_CRL *x, int nid, int *crit, int *idx)
{
  return X509V3_get_d2i(x->crl->extensions, nid, crit, idx);
}

int X509_CRL_add1_ext_i2d(X509_CRL *x, int nid, void *value, int crit, unint64_t flags)
{
  return X509V3_add1_i2d(&x->crl->extensions, nid, value, crit, flags);
}

int X509_CRL_add_ext(X509_CRL *x, X509_EXTENSION *ex, int loc)
{
  return X509v3_add_ext(&x->crl->extensions, ex, loc) != 0;
}

int X509_get_ext_count(X509 *x)
{
  return X509v3_get_ext_count(x->cert_info->extensions);
}

int X509_get_ext_by_NID(X509 *x, int nid, int lastpos)
{
  return X509v3_get_ext_by_NID(x->cert_info->extensions, nid, lastpos);
}

int X509_get_ext_by_OBJ(X509 *x, ASN1_OBJECT *obj, int lastpos)
{
  return X509v3_get_ext_by_OBJ(x->cert_info->extensions, obj, lastpos);
}

int X509_get_ext_by_critical(X509 *x, int crit, int lastpos)
{
  return X509v3_get_ext_by_critical(x->cert_info->extensions, crit, lastpos);
}

X509_EXTENSION *__cdecl X509_get_ext(X509 *x, int loc)
{
  return X509v3_get_ext(x->cert_info->extensions, loc);
}

X509_EXTENSION *__cdecl X509_delete_ext(X509 *x, int loc)
{
  return X509v3_delete_ext(x->cert_info->extensions, loc);
}

int X509_add_ext(X509 *x, X509_EXTENSION *ex, int loc)
{
  return X509v3_add_ext(&x->cert_info->extensions, ex, loc) != 0;
}

void *__cdecl X509_get_ext_d2i(X509 *x, int nid, int *crit, int *idx)
{
  return X509V3_get_d2i(x->cert_info->extensions, nid, crit, idx);
}

int X509_add1_ext_i2d(X509 *x, int nid, void *value, int crit, unint64_t flags)
{
  return X509V3_add1_i2d(&x->cert_info->extensions, nid, value, crit, flags);
}

int X509_REVOKED_get_ext_count(X509_REVOKED *x)
{
  return X509v3_get_ext_count(x->extensions);
}

int X509_REVOKED_get_ext_by_NID(X509_REVOKED *x, int nid, int lastpos)
{
  return X509v3_get_ext_by_NID(x->extensions, nid, lastpos);
}

int X509_REVOKED_get_ext_by_OBJ(X509_REVOKED *x, ASN1_OBJECT *obj, int lastpos)
{
  return X509v3_get_ext_by_OBJ(x->extensions, obj, lastpos);
}

int X509_REVOKED_get_ext_by_critical(X509_REVOKED *x, int crit, int lastpos)
{
  return X509v3_get_ext_by_critical(x->extensions, crit, lastpos);
}

X509_EXTENSION *__cdecl X509_REVOKED_get_ext(X509_REVOKED *x, int loc)
{
  return X509v3_get_ext(x->extensions, loc);
}

X509_EXTENSION *__cdecl X509_REVOKED_delete_ext(X509_REVOKED *x, int loc)
{
  return X509v3_delete_ext(x->extensions, loc);
}

int X509_REVOKED_add_ext(X509_REVOKED *x, X509_EXTENSION *ex, int loc)
{
  return X509v3_add_ext(&x->extensions, ex, loc) != 0;
}

void *__cdecl X509_REVOKED_get_ext_d2i(X509_REVOKED *x, int nid, int *crit, int *idx)
{
  return X509V3_get_d2i(x->extensions, nid, crit, idx);
}

int X509_REVOKED_add1_ext_i2d(X509_REVOKED *x, int nid, void *value, int crit, unint64_t flags)
{
  return X509V3_add1_i2d(&x->extensions, nid, value, crit, flags);
}

BIO *__cdecl BIO_new_file(const char *filename, const char *mode)
{
  unint64_t v4 = fopen(filename, mode);
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = BIO_new(&methods_filep);
    int v7 = v6;
    if (v6) {
      BIO_ctrl(v6, 106, 1, v5);
    }
    else {
      fclose(v5);
    }
  }
  else
  {
    uint64_t v8 = __error();
    ERR_put_error(2, 4095, *v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bss_file.c", 124);
    ERR_asprintf_error_data("fopen('%s', '%s')", filename, mode);
    if (*__error() == 2)
    {
      int v9 = 128;
      int v10 = 127;
    }
    else
    {
      int v9 = 2;
      int v10 = 129;
    }
    ERR_put_error(32, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bss_file.c", v10);
    return 0;
  }
  return v7;
}

BIO_METHOD *BIO_s_file(void)
{
  return (BIO_METHOD *)&methods_filep;
}

BIO *__cdecl BIO_new_fp(FILE *stream, int close_flag)
{
  unint64_t v4 = BIO_new(&methods_filep);
  uint64_t v5 = v4;
  if (v4) {
    BIO_ctrl(v4, 106, close_flag, stream);
  }
  return v5;
}

size_t file_write(uint64_t a1, void *__ptr, int a3)
{
  size_t result = 0;
  if (__ptr)
  {
    if (*(_DWORD *)(a1 + 32)) {
      return fwrite(__ptr, 1uLL, a3, *(FILE **)(a1 + 56));
    }
  }
  return result;
}

uint64_t file_read(uint64_t a1, void *__ptr, int a3)
{
  uint64_t result = 0;
  if (__ptr)
  {
    if (*(_DWORD *)(a1 + 32))
    {
      uint64_t result = fread(__ptr, 1uLL, a3, *(FILE **)(a1 + 56));
      if (!result)
      {
        uint64_t result = ferror(*(FILE **)(a1 + 56));
        if (result)
        {
          uint64_t v5 = __error();
          ERR_put_error(2, 4095, *v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bss_file.c", 193);
          ERR_put_error(32, 4095, 2, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bss_file.c", 194);
          return 0xFFFFFFFFLL;
        }
      }
    }
  }
  return result;
}

size_t file_puts(uint64_t a1, char *__s)
{
  size_t result = 0;
  if (__s)
  {
    if (*(_DWORD *)(a1 + 32))
    {
      int v5 = strlen(__s);
      return fwrite(__s, 1uLL, v5, *(FILE **)(a1 + 56));
    }
  }
  return result;
}

char *file_gets(uint64_t a1, char *a2, int a3)
{
  *a2 = 0;
  size_t result = fgets(a2, a3, *(FILE **)(a1 + 56));
  if (result)
  {
    if (*a2) {
      return (char *)strlen(a2);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t file_ctrl(uint64_t a1, int a2, uint64_t a3, char *a4)
{
  char v4 = a3;
  uint64_t v6 = *(FILE **)(a1 + 56);
  if (a2 <= 105)
  {
    uint64_t v7 = 1;
    switch(a2)
    {
      case 1:
        return fseek(v6, a3, 0);
      case 2:
        return feof(v6);
      case 3:
        goto LABEL_13;
      case 8:
        return *(int *)(a1 + 36);
      case 9:
        *(_DWORD *)(a1 + 36) = a3;
        return 1;
      case 11:
        fflush(v6);
        return 1;
      case 12:
        return v7;
      default:
        return 0;
    }
  }
  if (a2 > 107)
  {
    switch(a2)
    {
      case 108:
        file_free(a1);
        *(_DWORD *)(a1 + 36) = v4 & 1;
        if ((v4 & 8) != 0 || (v4 & 6) == 6 || (v4 & 6) != 0)
        {
          __strlcpy_chk();
          int v10 = fopen(a4, __mode);
          if (v10)
          {
            *(void *)(a1 + 56) = v10;
            uint64_t v7 = 1;
            *(_DWORD *)(a1 + 32) = 1;
            return v7;
          }
          int v11 = __error();
          ERR_put_error(2, 4095, *v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bss_file.c", 257);
          ERR_asprintf_error_data("fopen('%s', '%s')", a4, __mode);
          int v12 = 2;
          int v13 = 259;
        }
        else
        {
          int v12 = 101;
          int v13 = 251;
        }
        ERR_put_error(32, 4095, v12, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bss_file.c", v13);
        break;
      case 133:
LABEL_13:
        JUMPOUT(0x23ECE5DD0);
      case 128:
        return fseek(v6, a3, 0);
    }
    return 0;
  }
  if (a2 == 106)
  {
    file_free(a1);
    *(void *)(a1 + 56) = a4;
    uint64_t v7 = 1;
    *(_DWORD *)(a1 + 32) = 1;
    *(_DWORD *)(a1 + 36) = v4 & 1;
  }
  else
  {
    if (a4) {
      *(void *)a4 = v6;
    }
    return 1;
  }
  return v7;
}

uint64_t file_new(uint64_t a1)
{
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return 1;
}

uint64_t file_free(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(_DWORD *)(result + 36))
    {
      if (*(_DWORD *)(result + 32))
      {
        uint64_t v2 = *(FILE **)(result + 56);
        if (v2)
        {
          fclose(v2);
          *(void *)(v1 + 56) = 0;
          *(_DWORD *)(v1 + 40) = 0;
        }
      }
      *(_DWORD *)(v1 + 32) = 0;
    }
    return 1;
  }
  return result;
}

AUTHORITY_KEYID *__cdecl d2i_AUTHORITY_KEYID(AUTHORITY_KEYID **a, const unsigned __int8 **in, uint64_t len)
{
  return (AUTHORITY_KEYID *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &AUTHORITY_KEYID_it);
}

int i2d_AUTHORITY_KEYID(AUTHORITY_KEYID *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &AUTHORITY_KEYID_it);
}

AUTHORITY_KEYID *AUTHORITY_KEYID_new(void)
{
  return (AUTHORITY_KEYID *)ASN1_item_new(&AUTHORITY_KEYID_it);
}

void AUTHORITY_KEYID_free(AUTHORITY_KEYID *a)
{
}

uint64_t Camellia_ecb_encrypt(unsigned int *a1, unsigned char *a2, _DWORD *a3, int a4)
{
  if (a4 == 1) {
    return Camellia_encrypt(a1, a2, a3);
  }
  else {
    return Camellia_decrypt(a1, a2, a3);
  }
}

void HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len, const EVP_MD *md, ENGINE *impl)
{
  int v6 = len;
  uint64_t v20 = *MEMORY[0x263EF8340];
  int v9 = ctx->md;
  if (md)
  {
    if (v9 != md && (!key || len < 0)) {
      return;
    }
    ctx->md = md;
    int v9 = md;
  }
  else if (!v9)
  {
    return;
  }
  if (key)
  {
    int v10 = EVP_MD_block_size(v9);
    if (v10 >= 0x91)
    {
      int v11 = 136;
      int v12 = 92;
LABEL_27:
      ERR_put_error(6, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/hmac/hmac.c", v12);
      return;
    }
    if (v10 >= v6)
    {
      if (v6 >= 0x91)
      {
        int v11 = 137;
        int v12 = 105;
        goto LABEL_27;
      }
      memcpy(&ctx->key[48], key, v6);
      *(_DWORD *)&ctx->key[44] = v6;
    }
    else
    {
      if (!EVP_DigestInit_ex(&ctx->md_ctx, v9, impl)
        || !EVP_DigestUpdate(&ctx->md_ctx, key, v6)
        || !EVP_DigestFinal_ex(&ctx->md_ctx, &ctx->key[48], (unsigned int *)&ctx->key[44]))
      {
        return;
      }
      int v6 = *(_DWORD *)&ctx->key[44];
    }
    if (v6 != 144) {
      bzero(&ctx->key[v6 + 48], (144 - v6));
    }
  }
  else if (!md)
  {
LABEL_19:
    EVP_MD_CTX_copy_ex(&ctx->md_ctx, (const EVP_MD_CTX *)&ctx->i_ctx.flags);
    return;
  }
  uint64_t v13 = 0;
  v14.i64[0] = 0x3636363636363636;
  v14.i64[1] = 0x3636363636363636;
  do
  {
    *(int8x16_t *)&d[v13] = veorq_s8(*(int8x16_t *)&ctx->key[v13 + 48], v14);
    v13 += 16;
  }
  while (v13 != 144);
  if (EVP_DigestInit_ex((EVP_MD_CTX *)&ctx->i_ctx.flags, v9, impl))
  {
    int v15 = EVP_MD_block_size(v9);
    if (EVP_DigestUpdate((EVP_MD_CTX *)&ctx->i_ctx.flags, d, v15))
    {
      uint64_t v16 = 0;
      v17.i64[0] = 0x5C5C5C5C5C5C5C5CLL;
      v17.i64[1] = 0x5C5C5C5C5C5C5C5CLL;
      do
      {
        *(int8x16_t *)&d[v16] = veorq_s8(*(int8x16_t *)&ctx->key[v16 + 48], v17);
        v16 += 16;
      }
      while (v16 != 144);
      if (EVP_DigestInit_ex((EVP_MD_CTX *)&ctx->key_length, v9, impl))
      {
        int v18 = EVP_MD_block_size(v9);
        if (EVP_DigestUpdate((EVP_MD_CTX *)&ctx->key_length, d, v18)) {
          goto LABEL_19;
        }
      }
    }
  }
}

void HMAC_Init(HMAC_CTX *ctx, const void *key, int len, const EVP_MD *md)
{
  if (key && md) {
    HMAC_CTX_init(ctx);
  }
  HMAC_Init_ex(ctx, key, len, md, 0);
}

void HMAC_CTX_init(HMAC_CTX *ctx)
{
  ctx->md = 0;
}

void HMAC_Update(HMAC_CTX *ctx, const unsigned __int8 *data, size_t len)
{
  if (ctx->md) {
    EVP_DigestUpdate(&ctx->md_ctx, data, len);
  }
}

void HMAC_Final(HMAC_CTX *ctx, unsigned __int8 *md, unsigned int *len)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (ctx->md)
  {
    unsigned int s = 0;
    p_md_ctx = &ctx->md_ctx;
    if (EVP_DigestFinal_ex(&ctx->md_ctx, mda, &s))
    {
      if (EVP_MD_CTX_copy_ex(p_md_ctx, (const EVP_MD_CTX *)&ctx->key_length))
      {
        if (EVP_DigestUpdate(p_md_ctx, mda, s)) {
          EVP_DigestFinal_ex(p_md_ctx, md, len);
        }
      }
    }
  }
}

HMAC_CTX *HMAC_CTX_new()
{
  int v0 = (HMAC_CTX *)malloc_type_calloc(1uLL, 0x130uLL, 0x10E0040A0318B61uLL);
  uint64_t v1 = v0;
  if (v0) {
    HMAC_CTX_init(v0);
  }
  return v1;
}

void HMAC_CTX_free(HMAC_CTX *a1)
{
  if (a1)
  {
    HMAC_CTX_cleanup(a1);
    free(a1);
  }
}

void HMAC_CTX_cleanup(HMAC_CTX *ctx)
{
  EVP_MD_CTX_cleanup((EVP_MD_CTX *)&ctx->i_ctx.flags);
  EVP_MD_CTX_cleanup((EVP_MD_CTX *)&ctx->key_length);
  EVP_MD_CTX_cleanup(&ctx->md_ctx);
  explicit_bzero(ctx, 0x130uLL);
}

uint64_t HMAC_CTX_reset(HMAC_CTX *a1)
{
  return 1;
}

uint64_t HMAC_CTX_copy(uint64_t a1, uint64_t a2)
{
  uint64_t result = EVP_MD_CTX_copy((EVP_MD_CTX *)(a1 + 56), (const EVP_MD_CTX *)(a2 + 56));
  if (result)
  {
    uint64_t result = EVP_MD_CTX_copy((EVP_MD_CTX *)(a1 + 104), (const EVP_MD_CTX *)(a2 + 104));
    if (result)
    {
      uint64_t result = EVP_MD_CTX_copy((EVP_MD_CTX *)(a1 + 8), (const EVP_MD_CTX *)(a2 + 8));
      if (result)
      {
        *(_OWORD *)(a1 + 156) = *(_OWORD *)(a2 + 156);
        long long v5 = *(_OWORD *)(a2 + 172);
        long long v6 = *(_OWORD *)(a2 + 188);
        long long v7 = *(_OWORD *)(a2 + 204);
        *(_OWORD *)(a1 + 220) = *(_OWORD *)(a2 + 220);
        *(_OWORD *)(a1 + 204) = v7;
        *(_OWORD *)(a1 + 188) = v6;
        *(_OWORD *)(a1 + 172) = v5;
        long long v8 = *(_OWORD *)(a2 + 236);
        long long v9 = *(_OWORD *)(a2 + 252);
        long long v10 = *(_OWORD *)(a2 + 284);
        *(_OWORD *)(a1 + 268) = *(_OWORD *)(a2 + 268);
        *(_OWORD *)(a1 + 284) = v10;
        *(_OWORD *)(a1 + 252) = v9;
        *(_OWORD *)(a1 + 236) = v8;
        *(_DWORD *)(a1 + 152) = *(_DWORD *)(a2 + 152);
        *(void *)a1 = *(void *)a2;
        return 1;
      }
    }
  }
  return result;
}

void HMAC_CTX_set_flags(HMAC_CTX *ctx, unint64_t flags)
{
  int v2 = flags;
  EVP_MD_CTX_set_flags((EVP_MD_CTX *)&ctx->i_ctx.flags, flags);
  EVP_MD_CTX_set_flags((EVP_MD_CTX *)&ctx->key_length, v2);
  EVP_MD_CTX_set_flags(&ctx->md_ctx, v2);
}

uint64_t HMAC_CTX_get_md(uint64_t a1)
{
  return *(void *)a1;
}

unsigned __int8 *__cdecl HMAC(const EVP_MD *evp_md, const void *key, int key_len, const unsigned __int8 *d, size_t n, unsigned __int8 *md, unsigned int *md_len)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  memset(&ctx.md_ctx.md_data, 0, 208);
  if (md) {
    int v11 = md;
  }
  else {
    int v11 = (unsigned __int8 *)&HMAC_m;
  }
  memset(&ctx, 0, 32);
  if (key) {
    int v12 = key_len;
  }
  else {
    int v12 = 0;
  }
  if (key) {
    uint64_t v13 = (char *)key;
  }
  else {
    uint64_t v13 = &v17;
  }
  char v17 = 0;
  HMAC_CTX_init(&ctx);
  HMAC_Init_ex(&ctx, v13, v12, evp_md, 0);
  if (!v14 || !ctx.md || !EVP_DigestUpdate(&ctx.md_ctx, d, n) || (HMAC_Final(&ctx, v11, md_len), !v15)) {
    int v11 = 0;
  }
  HMAC_CTX_cleanup(&ctx);
  return v11;
}

int EC_GROUP_get_basis_type(const EC_GROUP *a1)
{
  int v2 = EC_GROUP_method_of(a1);
  if (EC_METHOD_get_field_type(v2) != 407) {
    return 0;
  }
  uint64_t v3 = 0;
  while (*((_DWORD *)a1 + v3++ + 32))
    ;
  if (v3 == 3) {
    int v5 = 682;
  }
  else {
    int v5 = 0;
  }
  if (v3 == 5) {
    return 683;
  }
  else {
    return v5;
  }
}

ASN1_VALUE *X9_62_PENTANOMIAL_new()
{
  return ASN1_item_new(&X9_62_PENTANOMIAL_it);
}

void X9_62_PENTANOMIAL_free(ASN1_VALUE *a1)
{
}

ASN1_VALUE *X9_62_CHARACTERISTIC_TWO_new()
{
  return ASN1_item_new(&X9_62_CHARACTERISTIC_TWO_it);
}

void X9_62_CHARACTERISTIC_TWO_free(ASN1_VALUE *a1)
{
}

ASN1_VALUE *ECPARAMETERS_new()
{
  return ASN1_item_new(&ECPARAMETERS_it);
}

void ECPARAMETERS_free(ASN1_VALUE *a1)
{
}

ASN1_VALUE *d2i_ECPKPARAMETERS(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &ECPKPARAMETERS_it);
}

uint64_t i2d_ECPKPARAMETERS(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &ECPKPARAMETERS_it);
}

ASN1_VALUE *ECPKPARAMETERS_new()
{
  return ASN1_item_new(&ECPKPARAMETERS_it);
}

void ECPKPARAMETERS_free(ASN1_VALUE *a1)
{
}

ASN1_VALUE *d2i_EC_PRIVATEKEY(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &EC_PRIVATEKEY_it);
}

uint64_t i2d_EC_PRIVATEKEY(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &EC_PRIVATEKEY_it);
}

ASN1_VALUE *EC_PRIVATEKEY_new()
{
  return ASN1_item_new(&EC_PRIVATEKEY_it);
}

void EC_PRIVATEKEY_free(ASN1_VALUE *a1)
{
}

EC_GROUP *__cdecl d2i_ECPKParameters(EC_GROUP **a1, const unsigned __int8 **in, uint64_t len)
{
  char v4 = (const ASN1_OBJECT **)ASN1_item_d2i(0, in, len, &ECPKPARAMETERS_it);
  int v5 = (ASN1_VALUE *)v4;
  if (v4)
  {
    long long v6 = ec_asn1_pkparameters2group(v4);
    if (v6)
    {
      if (a1)
      {
        EC_GROUP_free(*a1);
        *a1 = v6;
      }
    }
    else
    {
      ERR_put_error(16, 4095, 127, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 1107);
    }
  }
  else
  {
    ERR_put_error(16, 4095, 117, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 1103);
    long long v6 = 0;
  }
  ASN1_item_free(v5, &ECPKPARAMETERS_it);
  return v6;
}

EC_GROUP *ec_asn1_pkparameters2group(const ASN1_OBJECT **a1)
{
  if (!a1)
  {
    int v6 = 124;
    int v7 = 1066;
LABEL_22:
    ERR_put_error(16, 4095, v6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v7);
    return 0;
  }
  int v1 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 != 2)
  {
    if (v1 != 1)
    {
      if (!v1)
      {
        int v2 = OBJ_obj2nid(a1[1]);
        uint64_t v3 = EC_GROUP_new_by_curve_name(v2);
        char v4 = v3;
        if (v3)
        {
          int v5 = 1;
LABEL_33:
          EC_GROUP_set_asn1_flag(v3, v5);
          return v4;
        }
        int v20 = 119;
        int v21 = 1072;
        goto LABEL_35;
      }
      int v6 = 115;
      int v7 = 1087;
      goto LABEL_22;
    }
    long long v8 = a1[1];
    ln = v8->ln;
    if (ln && *(void *)ln && *((void *)ln + 1))
    {
      long long v10 = *(uint64_t **)&v8->nid;
      if (v10)
      {
        uint64_t v11 = *v10;
        if (*v10)
        {
          int v12 = *(const unsigned __int8 **)(v11 + 8);
          if (v12)
          {
            uint64_t v13 = v10[1];
            if (v13)
            {
              if (*(void *)(v13 + 8))
              {
                int v14 = BN_bin2bn(v12, *(_DWORD *)v11, 0);
                if (v14)
                {
                  int v15 = BN_bin2bn(*(const unsigned __int8 **)(*(void *)(*(void *)&v8->nid + 8) + 8), **(_DWORD **)(*(void *)&v8->nid + 8), 0);
                  if (v15)
                  {
                    int v16 = OBJ_obj2nid(*(const ASN1_OBJECT **)v8->ln);
                    if (v16 != 406)
                    {
                      if (v16 == 407)
                      {
                        int v17 = 147;
                        int v18 = 957;
                      }
                      else
                      {
                        int v17 = 103;
                        int v18 = 983;
                      }
                      goto LABEL_46;
                    }
                    uint64_t v25 = (ASN1_INTEGER *)*((void *)v8->ln + 1);
                    if (v25)
                    {
                      unint64_t v26 = ASN1_INTEGER_to_BN(v25, 0);
                      long long v22 = v26;
                      if (!v26)
                      {
                        int v27 = 13;
                        int v28 = 968;
                        goto LABEL_48;
                      }
                      if (BN_is_negative((uint64_t)v26) || BN_is_zero((uint64_t)v22))
                      {
                        int v27 = 103;
                        int v28 = 972;
LABEL_48:
                        ERR_put_error(16, 4095, v27, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v28);
                        char v4 = 0;
                        goto LABEL_29;
                      }
                      int v40 = v8;
                      int v29 = BN_num_bits(v22);
                      if (v29 >= 662)
                      {
                        int v27 = 143;
                        int v28 = 977;
                        goto LABEL_48;
                      }
                      int v30 = v29;
                      int v31 = EC_GROUP_new_curve_GFp(v22, v14, v15, 0);
                      char v4 = v31;
                      if (v31)
                      {
                        if (*(void *)(*(void *)&v40->nid + 16))
                        {
                          free(*((void **)v31 + 10));
                          unint64_t v32 = malloc_type_malloc(**(int **)(*(void *)&v40->nid + 16), 0x8DA7DACBuLL);
                          *((void *)v4 + 10) = v32;
                          if (!v32)
                          {
                            int v37 = 65;
                            int v38 = 995;
                            goto LABEL_67;
                          }
                          memcpy(v32, *(const void **)(*(void *)(*(void *)&v40->nid + 16) + 8), **(int **)(*(void *)&v40->nid + 16));
                          *((void *)v4 + 11) = **(int **)(*(void *)&v40->nid + 16);
                        }
                        if (*(void *)&v40->flags)
                        {
                          unint64_t data = v40->data;
                          if (data)
                          {
                            if (*((void *)data + 1))
                            {
                              uint64_t v23 = EC_POINT_new(v4);
                              if (!v23) {
                                goto LABEL_30;
                              }
                              EC_GROUP_set_point_conversion_form(v4, (point_conversion_form_t)(**((unsigned char **)v40->data + 1) & 0xFE));
                              if (EC_POINT_oct2point(v4, v23, *((const unsigned __int8 **)v40->data + 1), *(int *)v40->data, 0))
                              {
                                int v34 = ASN1_INTEGER_to_BN(*(ASN1_INTEGER **)&v40->flags, v14);
                                int v14 = v34;
                                if (v34)
                                {
                                  if (BN_is_negative((uint64_t)v34) || BN_is_zero((uint64_t)v14))
                                  {
                                    int v35 = 122;
                                    int v36 = 1025;
                                  }
                                  else
                                  {
                                    if (BN_num_bits(v14) <= v30 + 1)
                                    {
                                      sn = (ASN1_INTEGER *)v40[1].sn;
                                      if (sn)
                                      {
                                        int v15 = ASN1_INTEGER_to_BN(sn, v15);
                                        if (!v15)
                                        {
                                          int v35 = 13;
                                          int v36 = 1037;
                                          goto LABEL_70;
                                        }
                                      }
                                      else
                                      {
                                        BN_free(v15);
                                        int v15 = 0;
                                      }
                                      if (EC_GROUP_set_generator(v4, v23, v14, v15)) {
                                        goto LABEL_31;
                                      }
                                      int v35 = 16;
                                      int v36 = 1042;
                                      goto LABEL_70;
                                    }
                                    int v35 = 122;
                                    int v36 = 1029;
                                  }
                                }
                                else
                                {
                                  int v35 = 13;
                                  int v36 = 1021;
                                }
                              }
                              else
                              {
                                int v35 = 16;
                                int v36 = 1016;
                              }
LABEL_70:
                              ERR_put_error(16, 4095, v35, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v36);
                              goto LABEL_30;
                            }
                          }
                        }
                        int v37 = 115;
                        int v38 = 1003;
                      }
                      else
                      {
                        int v37 = 16;
                        int v38 = 988;
                      }
LABEL_67:
                      ERR_put_error(16, 4095, v37, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v38);
                      goto LABEL_29;
                    }
                    int v17 = 115;
                    int v18 = 963;
                  }
                  else
                  {
                    int v17 = 3;
                    int v18 = 951;
                  }
LABEL_46:
                  ERR_put_error(16, 4095, v17, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v18);
                  char v4 = 0;
                  long long v22 = 0;
                  goto LABEL_29;
                }
                ERR_put_error(16, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 946);
                char v4 = 0;
                long long v22 = 0;
LABEL_28:
                int v15 = 0;
LABEL_29:
                uint64_t v23 = 0;
LABEL_30:
                EC_GROUP_free(v4);
                char v4 = 0;
LABEL_31:
                BN_free(v22);
                BN_free(v14);
                BN_free(v15);
                EC_POINT_free(v23);
                if (v4)
                {
                  uint64_t v3 = v4;
                  int v5 = 0;
                  goto LABEL_33;
                }
                int v20 = 16;
                int v21 = 1080;
LABEL_35:
                ERR_put_error(16, 4095, v20, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v21);
                return v4;
              }
            }
          }
        }
      }
      int v19 = 941;
    }
    else
    {
      int v19 = 934;
    }
    ERR_put_error(16, 4095, 115, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v19);
    char v4 = 0;
    long long v22 = 0;
    int v14 = 0;
    goto LABEL_28;
  }
  return 0;
}

int i2d_ECPKParameters(const EC_GROUP *a1, unsigned __int8 **out)
{
  uint64_t v3 = ec_asn1_group2pkparameters(a1, 0);
  if (v3)
  {
    char v4 = v3;
    int v5 = ASN1_item_i2d(v3, out, &ECPKPARAMETERS_it);
    if (!v5) {
      ERR_put_error(16, 4095, 121, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 1131);
    }
    ASN1_item_free(v4, &ECPKPARAMETERS_it);
  }
  else
  {
    ERR_put_error(16, 4095, 120, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 1127);
    return 0;
  }
  return v5;
}

ASN1_VALUE *ec_asn1_group2pkparameters(EC_GROUP *a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = (ASN1_VALUE *)a2;
    if (*(_DWORD *)a2 == 1)
    {
      int v5 = *(ASN1_VALUE **)(a2 + 8);
      if (v5) {
        ASN1_item_free(v5, &ECPARAMETERS_it);
      }
    }
    else if (!*(_DWORD *)a2)
    {
      char v4 = *(ASN1_OBJECT **)(a2 + 8);
      if (v4) {
        ASN1_OBJECT_free(v4);
      }
    }
  }
  else
  {
    uint64_t v3 = ASN1_item_new(&ECPKPARAMETERS_it);
    if (!v3)
    {
      ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 885);
      return v3;
    }
  }
  if (!EC_GROUP_get_asn1_flag(a1))
  {
    *(_DWORD *)uint64_t v3 = 1;
    long long v9 = BN_new();
    if (!v9)
    {
      ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 794);
      int v31 = 0;
LABEL_52:
      uint64_t v11 = 0;
      goto LABEL_53;
    }
    long long v10 = ASN1_item_new(&ECPARAMETERS_it);
    uint64_t v11 = v10;
    if (!v10)
    {
      ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 799);
      int v31 = 0;
      goto LABEL_53;
    }
    *(void *)long long v10 = 1;
    if (!a1) {
      goto LABEL_49;
    }
    uint64_t v12 = *((void *)v10 + 1);
    if (!v12) {
      goto LABEL_49;
    }
    if (*(void *)v12) {
      ASN1_OBJECT_free(*(ASN1_OBJECT **)v12);
    }
    uint64_t v13 = *(ASN1_TYPE **)(v12 + 8);
    if (v13) {
      ASN1_TYPE_free(v13);
    }
    int v14 = EC_GROUP_method_of(a1);
    int field_type = EC_METHOD_get_field_type(v14);
    int v16 = OBJ_nid2obj(field_type);
    *(void *)uint64_t v12 = v16;
    if (v16)
    {
      if (field_type == 406)
      {
        int v17 = BN_new();
        if (v17)
        {
          if (EC_GROUP_get_curve((uint64_t)a1, (uint64_t)v17, 0, 0, 0))
          {
            int v18 = BN_to_ASN1_INTEGER(v17, 0);
            *(void *)(v12 + 8) = v18;
            if (v18)
            {
              BN_free(v17);
              int v19 = (ASN1_STRING **)*((void *)v11 + 2);
              char v60 = 0;
              if (!v19 || !*v19 || !v19[1]) {
                goto LABEL_59;
              }
              int v20 = BN_new();
              if (v20 && (int v21 = BN_new()) != 0)
              {
                long long v22 = v21;
                if (EC_GROUP_get_curve((uint64_t)a1, 0, (uint64_t)v20, (uint64_t)v21, 0))
                {
                  int v23 = BN_num_bits(v20);
                  int v24 = BN_num_bits(v22);
                  unsigned int v25 = v24 + 14;
                  if (v24 >= -7) {
                    int v26 = v24 + 7;
                  }
                  else {
                    int v26 = v24 + 14;
                  }
                  int v27 = v23 + 14;
                  if ((v23 + 14) < 0xF)
                  {
                    int v28 = 0;
                    int v29 = 1;
                    int v30 = (unsigned __int8 *)&v60;
                    goto LABEL_66;
                  }
                  if (v23 >= -7) {
                    int v27 = v23 + 7;
                  }
                  int v28 = (unsigned __int8 *)malloc_type_malloc((uint64_t)v27 >> 3, 0xE0C18CA2uLL);
                  if (v28)
                  {
                    int v39 = BN_bn2bin(v20, v28);
                    if (v39)
                    {
                      int v29 = v39;
                      int v30 = v28;
LABEL_66:
                      if (v25 < 0xF)
                      {
                        int v38 = 0;
                        int v40 = 1;
                        int v59 = &v60;
LABEL_71:
                        if (ASN1_STRING_set(*v19, v30, v29) && ASN1_STRING_set(v19[1], v59, v40))
                        {
                          ASN1_BIT_STRING_free(v19[2]);
                          v19[2] = 0;
                          if (!*((void *)a1 + 10)) {
                            goto LABEL_77;
                          }
                          unsigned int v42 = ASN1_BIT_STRING_new();
                          v19[2] = v42;
                          if (v42)
                          {
                            if (ASN1_BIT_STRING_set(v42, *((unsigned __int8 **)a1 + 10), *((_DWORD *)a1 + 22)))
                            {
                              if (asn1_abs_set_unused_bits((uint64_t)v19[2], 0))
                              {
LABEL_77:
                                free(v28);
                                free(v38);
                                BN_free(v20);
                                BN_free(v22);
                                int v43 = EC_GROUP_get0_generator(a1);
                                if (v43)
                                {
                                  unint64_t v44 = v43;
                                  point_conversion_form_t point_conversion_form = EC_GROUP_get_point_conversion_form(a1);
                                  size_t v46 = EC_POINT_point2oct(a1, v44, point_conversion_form, 0, 0, 0);
                                  if (v46)
                                  {
                                    size_t v47 = v46;
                                    int v31 = malloc_type_malloc(v46, 0x5CC31266uLL);
                                    if (v31)
                                    {
                                      if (EC_POINT_point2oct(a1, v44, point_conversion_form, (unsigned __int8 *)v31, v47, 0))
                                      {
                                        unsigned int v48 = (ASN1_OCTET_STRING *)*((void *)v11 + 3);
                                        if (v48 || (unsigned int v48 = ASN1_OCTET_STRING_new(), (*((void *)v11 + 3) = v48) != 0))
                                        {
                                          if (ASN1_OCTET_STRING_set(v48, (const unsigned __int8 *)v31, v47))
                                          {
                                            if (EC_GROUP_get_order(a1, v9, 0))
                                            {
                                              int v49 = BN_to_ASN1_INTEGER(v9, *((ASN1_INTEGER **)v11 + 4));
                                              *((void *)v11 + 4) = v49;
                                              if (v49)
                                              {
                                                if (!EC_GROUP_get_cofactor(a1, v9, 0)
                                                  || (int v50 = BN_to_ASN1_INTEGER(v9, *((ASN1_INTEGER **)v11 + 5)),
                                                      (*((void *)v11 + 5) = v50) != 0))
                                                {
LABEL_53:
                                                  BN_free(v9);
                                                  free(v31);
                                                  *((void *)v3 + 1) = v11;
                                                  if (v11) {
                                                    return v3;
                                                  }
                                                  goto LABEL_13;
                                                }
                                                int v51 = 13;
                                                int v52 = 860;
                                              }
                                              else
                                              {
                                                int v51 = 13;
                                                int v52 = 853;
                                              }
                                            }
                                            else
                                            {
                                              int v51 = 16;
                                              int v52 = 848;
                                            }
                                          }
                                          else
                                          {
                                            int v51 = 13;
                                            int v52 = 843;
                                          }
                                        }
                                        else
                                        {
                                          int v51 = 65;
                                          int v52 = 839;
                                        }
                                      }
                                      else
                                      {
                                        int v51 = 16;
                                        int v52 = 835;
                                      }
                                    }
                                    else
                                    {
                                      int v51 = 65;
                                      int v52 = 831;
                                    }
                                    ERR_put_error(16, 4095, v51, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v52);
                                    goto LABEL_51;
                                  }
                                  int v36 = 16;
                                  int v37 = 827;
                                }
                                else
                                {
                                  int v36 = 113;
                                  int v37 = 820;
                                }
LABEL_50:
                                ERR_put_error(16, 4095, v36, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v37);
                                int v31 = 0;
LABEL_51:
                                ASN1_item_free(v11, &ECPARAMETERS_it);
                                goto LABEL_52;
                              }
                              int v53 = 13;
                              int v54 = 767;
                            }
                            else
                            {
                              int v53 = 13;
                              int v54 = 763;
                            }
                          }
                          else
                          {
                            int v53 = 65;
                            int v54 = 758;
                          }
                        }
                        else
                        {
                          int v53 = 13;
                          int v54 = 748;
                        }
                        goto LABEL_100;
                      }
                      unint64_t data = v30;
                      int len = v29;
                      int v38 = malloc_type_malloc((uint64_t)v26 >> 3, 0xC4CDE50CuLL);
                      if (v38)
                      {
                        int v41 = BN_bn2bin(v22, (unsigned __int8 *)v38);
                        if (v41)
                        {
                          int v40 = v41;
                          int v59 = (char *)v38;
                          int v29 = len;
                          int v30 = data;
                          goto LABEL_71;
                        }
                        int v53 = 3;
                        int v54 = 739;
                      }
                      else
                      {
                        int v53 = 65;
                        int v54 = 735;
                      }
LABEL_100:
                      ERR_put_error(16, 4095, v53, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v54);
                      goto LABEL_58;
                    }
                    int v55 = 3;
                    int v56 = 723;
                  }
                  else
                  {
                    int v55 = 65;
                    int v56 = 719;
                  }
                  ERR_put_error(16, 4095, v55, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v56);
LABEL_57:
                  int v38 = 0;
LABEL_58:
                  free(v28);
                  free(v38);
                  BN_free(v20);
                  BN_free(v22);
LABEL_59:
                  int v36 = 16;
                  int v37 = 815;
                  goto LABEL_50;
                }
                ERR_put_error(16, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 707);
              }
              else
              {
                ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 701);
                long long v22 = 0;
              }
              int v28 = 0;
              goto LABEL_57;
            }
            int v34 = 13;
            int v35 = 672;
          }
          else
          {
            int v34 = 16;
            int v35 = 666;
          }
        }
        else
        {
          int v34 = 65;
          int v35 = 661;
        }
        ERR_put_error(16, 4095, v34, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v35);
        goto LABEL_48;
      }
      int v32 = 147;
      int v33 = 676;
    }
    else
    {
      int v32 = 8;
      int v33 = 656;
    }
    ERR_put_error(16, 4095, v32, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v33);
    int v17 = 0;
LABEL_48:
    BN_free(v17);
LABEL_49:
    int v36 = 16;
    int v37 = 810;
    goto LABEL_50;
  }
  int curve_name = EC_GROUP_get_curve_name(a1);
  if (!curve_name || (*(_DWORD *)v3 = 0, int v7 = OBJ_nid2obj(curve_name), (*((void *)v3 + 1) = v7) == 0))
  {
LABEL_13:
    ASN1_item_free(v3, &ECPKPARAMETERS_it);
    return 0;
  }
  return v3;
}

EC_KEY *__cdecl d2i_ECPrivateKey(EC_KEY **a, const unsigned __int8 **in, uint64_t len)
{
  char v4 = ASN1_item_d2i(0, in, len, &EC_PRIVATEKEY_it);
  if (!v4)
  {
    ERR_put_error(16, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 1148);
    return 0;
  }
  int v5 = v4;
  if (!a || (int v6 = *a) == 0)
  {
    int v6 = EC_KEY_new();
    if (!v6)
    {
      int v18 = 65;
      int v19 = 1153;
      goto LABEL_30;
    }
  }
  int v7 = (EC_GROUP *)*((void *)v6 + 3);
  if (*((void *)v5 + 2))
  {
    EC_GROUP_free(v7);
    int v7 = ec_asn1_pkparameters2group(*((const ASN1_OBJECT ***)v5 + 2));
    *((void *)v6 + 3) = v7;
  }
  if (!v7)
  {
    int v18 = 16;
    int v19 = 1164;
    goto LABEL_30;
  }
  long long v8 = (ASN1_STRING *)*((void *)v5 + 1);
  *((_DWORD *)v6 + 4) = *(void *)v5;
  if (!v8)
  {
    int v18 = 125;
    int v19 = 1179;
    goto LABEL_30;
  }
  long long v9 = ASN1_STRING_data(v8);
  int v10 = ASN1_STRING_length(*((ASN1_STRING **)v5 + 1));
  uint64_t v11 = BN_bin2bn(v9, v10, *((BIGNUM **)v6 + 5));
  *((void *)v6 + 5) = v11;
  if (!v11)
  {
    int v18 = 3;
    int v19 = 1175;
    goto LABEL_30;
  }
  uint64_t v12 = (EC_POINT *)*((void *)v6 + 4);
  if (v12) {
    EC_POINT_free(v12);
  }
  uint64_t v13 = EC_POINT_new(*((const EC_GROUP **)v6 + 3));
  *((void *)v6 + 4) = v13;
  if (!v13)
  {
    int v18 = 16;
    int v19 = 1187;
    goto LABEL_30;
  }
  int v14 = v13;
  int v15 = (ASN1_STRING *)*((void *)v5 + 3);
  if (!v15)
  {
    if (EC_POINT_mul(*((const EC_GROUP **)v6 + 3), v14, *((const BIGNUM **)v6 + 5), 0, 0, 0))
    {
      *((_DWORD *)v6 + 12) |= 2u;
      goto LABEL_26;
    }
    int v18 = 16;
    int v19 = 1212;
LABEL_30:
    ERR_put_error(16, 4095, v18, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v19);
    if (!a || *a != v6) {
      EC_KEY_free(v6);
    }
    ASN1_item_free(v5, &EC_PRIVATEKEY_it);
    return 0;
  }
  int v16 = ASN1_STRING_data(v15);
  int v17 = ASN1_STRING_length(*((ASN1_STRING **)v5 + 3));
  if (!v16 || !v17)
  {
    int v18 = 100;
    int v19 = 1198;
    goto LABEL_30;
  }
  *((_DWORD *)v6 + 13) = *v16 & 0xFE;
  if (!EC_POINT_oct2point(*((const EC_GROUP **)v6 + 3), *((EC_POINT **)v6 + 4), v16, v17, 0))
  {
    int v18 = 16;
    int v19 = 1206;
    goto LABEL_30;
  }
LABEL_26:
  ASN1_item_free(v5, &EC_PRIVATEKEY_it);
  if (a) {
    BUF_MEM *a = v6;
  }
  return v6;
}

int i2d_ECPrivateKey(EC_KEY *a, unsigned __int8 **out)
{
  if (a && *((void *)a + 3) && *((void *)a + 5) && ((*((unsigned char *)a + 48) & 2) != 0 || *((void *)a + 4)))
  {
    char v4 = ASN1_item_new(&EC_PRIVATEKEY_it);
    if (v4)
    {
      int v5 = v4;
      *(void *)char v4 = *((int *)a + 4);
      int v6 = BN_num_bits(*((const BIGNUM **)a + 5));
      int v7 = v6 + 7;
      if (v6 < -7) {
        int v7 = v6 + 14;
      }
      unint64_t v8 = (uint64_t)v7 >> 3;
      long long v9 = (unsigned __int8 *)malloc_type_malloc(v8, 0xE62F4307uLL);
      if (!v9)
      {
        int v16 = 65;
        int v17 = 1255;
        goto LABEL_30;
      }
      if (!BN_bn2bin(*((const BIGNUM **)a + 5), v9))
      {
        int v16 = 3;
        int v17 = 1259;
        goto LABEL_30;
      }
      if (!ASN1_STRING_set(*((ASN1_STRING **)v5 + 1), v9, v8))
      {
        int v16 = 13;
        int v17 = 1263;
        goto LABEL_30;
      }
      int v10 = *((_DWORD *)a + 12);
      if ((v10 & 1) == 0)
      {
        uint64_t v11 = ec_asn1_group2pkparameters(*((EC_GROUP **)a + 3), *((void *)v5 + 2));
        *((void *)v5 + 2) = v11;
        if (!v11)
        {
          int v16 = 16;
          int v17 = 1269;
          goto LABEL_30;
        }
        int v10 = *((_DWORD *)a + 12);
      }
      if ((v10 & 2) == 0 && *((void *)a + 4))
      {
        uint64_t v12 = ASN1_BIT_STRING_new();
        *((void *)v5 + 3) = v12;
        if (!v12)
        {
          int v16 = 65;
          int v17 = 1276;
          goto LABEL_30;
        }
        size_t v13 = EC_POINT_point2oct(*((const EC_GROUP **)a + 3), *((const EC_POINT **)a + 4), (point_conversion_form_t)*((_DWORD *)a + 13), 0, 0, 0);
        if (v13 <= v8)
        {
          int v15 = v9;
        }
        else
        {
          size_t v14 = v13;
          int v15 = (unsigned __int8 *)malloc_type_realloc(v9, v13, 0x8CC09097uLL);
          unint64_t v8 = v14;
          if (!v15)
          {
            int v16 = 65;
            int v17 = 1285;
LABEL_30:
            ERR_put_error(16, 4095, v16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v17);
            int v20 = 0;
LABEL_31:
            free(v9);
            ASN1_item_free(v5, &EC_PRIVATEKEY_it);
            return v20;
          }
        }
        if (EC_POINT_point2oct(*((const EC_GROUP **)a + 3), *((const EC_POINT **)a + 4), (point_conversion_form_t)*((_DWORD *)a + 13), v15, v8, 0))
        {
          if (ASN1_STRING_set(*((ASN1_STRING **)v5 + 3), v15, v8))
          {
            if (asn1_abs_set_unused_bits(*((void *)v5 + 3), 0))
            {
              long long v9 = v15;
              goto LABEL_37;
            }
            int v22 = 13;
            int v23 = 1301;
          }
          else
          {
            int v22 = 13;
            int v23 = 1297;
          }
        }
        else
        {
          int v22 = 16;
          int v23 = 1293;
        }
        ERR_put_error(16, 4095, v22, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v23);
        int v20 = 0;
        long long v9 = v15;
        goto LABEL_31;
      }
LABEL_37:
      int v20 = ASN1_item_i2d(v5, out, &EC_PRIVATEKEY_it);
      if (!v20) {
        ERR_put_error(16, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 1306);
      }
      goto LABEL_31;
    }
    int v18 = 65;
    int v19 = 1247;
  }
  else
  {
    int v18 = 67;
    int v19 = 1243;
  }
  ERR_put_error(16, 4095, v18, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v19);
  return 0;
}

int i2d_ECParameters(EC_KEY *a, unsigned __int8 **out)
{
  if (a)
  {
    int v2 = (const EC_GROUP *)*((void *)a + 3);
    return i2d_ECPKParameters(v2, out);
  }
  else
  {
    ERR_put_error(16, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 1321);
    return 0;
  }
}

EC_KEY *__cdecl d2i_ECParameters(EC_KEY **a, const unsigned __int8 **in, uint64_t len)
{
  if (!in || !*in)
  {
    ERR_put_error(16, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 1333);
    return 0;
  }
  if (!a || (int v6 = *a) == 0)
  {
    unint64_t v8 = EC_KEY_new();
    int v6 = v8;
    if (!v8)
    {
      ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 1338);
      return v6;
    }
    if (!d2i_ECPKParameters((EC_GROUP **)v8 + 3, in, len))
    {
      ERR_put_error(16, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 1345);
      if (!a)
      {
LABEL_17:
        EC_KEY_free(v6);
        return 0;
      }
      goto LABEL_16;
    }
    if (!a) {
      return v6;
    }
LABEL_13:
    BUF_MEM *a = v6;
    return v6;
  }
  if (d2i_ECPKParameters((EC_GROUP **)v6 + 3, in, len)) {
    goto LABEL_13;
  }
  ERR_put_error(16, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 1345);
LABEL_16:
  if (*a != v6) {
    goto LABEL_17;
  }
  return 0;
}

EC_KEY *__cdecl o2i_ECPublicKey(EC_KEY **a, const unsigned __int8 **in, uint64_t len)
{
  if (!a || (uint64_t v3 = *a) == 0 || (v4 = (const EC_GROUP *)*((void *)v3 + 3)) == 0)
  {
    int v10 = 67;
    int v11 = 1363;
LABEL_10:
    ERR_put_error(16, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v11);
    return 0;
  }
  int v7 = (EC_POINT *)*((void *)v3 + 4);
  if (!v7)
  {
    unint64_t v8 = EC_POINT_new(v4);
    *((void *)v3 + 4) = v8;
    if (!v8)
    {
      int v10 = 65;
      int v11 = 1369;
      goto LABEL_10;
    }
    int v7 = v8;
    char v4 = (const EC_GROUP *)*((void *)v3 + 3);
  }
  if (!EC_POINT_oct2point(v4, v7, *in, len, 0))
  {
    int v10 = 16;
    int v11 = 1373;
    goto LABEL_10;
  }
  long long v9 = *in;
  *((_DWORD *)v3 + 13) = **in & 0xFE;
  unsigned __int8 *in = &v9[len];
  return v3;
}

int i2o_ECPublicKey(EC_KEY *a, unsigned __int8 **out)
{
  if (!a)
  {
    int v8 = 67;
    int v9 = 1389;
LABEL_10:
    ERR_put_error(16, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", v9);
LABEL_11:
    LODWORD(v5) = 0;
    return v5;
  }
  size_t v4 = EC_POINT_point2oct(*((const EC_GROUP **)a + 3), *((const EC_POINT **)a + 4), (point_conversion_form_t)*((_DWORD *)a + 13), 0, 0, 0);
  size_t v5 = v4;
  if (!out || !v4) {
    return v5;
  }
  int v6 = *out;
  int v7 = *out;
  if (!*out)
  {
    int v7 = (unsigned __int8 *)malloc_type_malloc(v4, 0xDFAC327DuLL);
    *out = v7;
    if (!v7)
    {
      int v8 = 65;
      int v9 = 1401;
      goto LABEL_10;
    }
  }
  if (!EC_POINT_point2oct(*((const EC_GROUP **)a + 3), *((const EC_POINT **)a + 4), (point_conversion_form_t)*((_DWORD *)a + 13), v7, v5, 0))
  {
    ERR_put_error(16, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_asn1.c", 1408);
    if (!v6)
    {
      free(*out);
      LODWORD(v5) = 0;
      *out = 0;
      return v5;
    }
    goto LABEL_11;
  }
  if (v6) {
    *out += v5;
  }
  return v5;
}

ASN1_BIT_STRING *ASN1_BIT_STRING_new(void)
{
  return (ASN1_BIT_STRING *)ASN1_item_new(&ASN1_BIT_STRING_it);
}

void ASN1_BIT_STRING_free(ASN1_BIT_STRING *a)
{
}

uint64_t asn1_abs_set_unused_bits(uint64_t a1, unsigned int a2)
{
  if (a2 > 7) {
    return 0;
  }
  *(void *)(a1 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = *(void *)(a1 + 16) & 0xFFFFFFFFFFFFFFF0 | a2 | 8;
  return 1;
}

int ASN1_BIT_STRING_set_bit(ASN1_BIT_STRING *a, int n, int value)
{
  int v3 = n + 7;
  if (n >= 0) {
    int v3 = n;
  }
  int v4 = 1 << (~(_BYTE)n & 7);
  if (value) {
    char v5 = 1 << (~(_BYTE)n & 7);
  }
  else {
    char v5 = 0;
  }
  if (a)
  {
    int v6 = a;
    int v7 = v3 >> 3;
    a->flags &= 0xFFFFFFFFFFFFFFF0;
    unint64_t length = a->length;
    if ((int)length > v3 >> 3)
    {
      unint64_t data = a->data;
      if (data)
      {
LABEL_12:
        data[v7] = data[v7] & ~(_BYTE)v4 | v5;
        uint64_t v10 = v6->length;
        if ((int)v10 >= 1)
        {
          int v11 = v6->data;
          do
          {
            uint64_t v12 = v10 - 1;
            if (v11[(v10 - 1)]) {
              break;
            }
            v6->unint64_t length = --v10;
          }
          while ((unint64_t)(v12 + 1) > 1);
        }
        goto LABEL_16;
      }
    }
    if (!value)
    {
LABEL_16:
      LODWORD(a) = 1;
      return (int)a;
    }
    unint64_t data = (unsigned __int8 *)recallocarray((char *)v6->data, length, v7 + 1, 1uLL);
    if (data)
    {
      v6->unint64_t data = data;
      v6->unint64_t length = v7 + 1;
      goto LABEL_12;
    }
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_bitstr.c", 135);
    LODWORD(a) = 0;
  }
  return (int)a;
}

int ASN1_BIT_STRING_get_bit(ASN1_BIT_STRING *a, int n)
{
  int v2 = n + 7;
  if (n >= 0) {
    int v2 = n;
  }
  if (a)
  {
    int v3 = v2 >> 3;
    if (a->length > v3 && (unint64_t data = a->data) != 0) {
      LODWORD(a) = (data[v3] >> (~(_BYTE)n & 7)) & 1;
    }
    else {
      LODWORD(a) = 0;
    }
  }
  return (int)a;
}

BOOL ASN1_BIT_STRING_check(unsigned int *a1, uint64_t a2, int a3)
{
  if (!a1) {
    return 1;
  }
  uint64_t v3 = *((void *)a1 + 1);
  if (!v3) {
    return 1;
  }
  unint64_t v4 = *a1;
  if ((int)v4 < 1) {
    return 1;
  }
  unint64_t v5 = 0;
  do
  {
    if ((uint64_t)v5 >= a3) {
      char v6 = -1;
    }
    else {
      char v6 = ~*(unsigned char *)(a2 + v5);
    }
    int v7 = (*(unsigned char *)(v3 + v5++) & v6);
  }
  while (v5 < v4 && !v7);
  return v7 == 0;
}

int ASN1_BIT_STRING_name_print(BIO *out, ASN1_BIT_STRING *bs, BIT_STRING_BITNAME *tbl, int indent)
{
  BIO_printf(out, "%*s", indent, "");
  lname = tbl->lname;
  if (lname)
  {
    int v8 = 1;
    do
    {
      bituint64_t num = tbl->bitnum + 7;
      if (tbl->bitnum >= 0) {
        bituint64_t num = tbl->bitnum;
      }
      if (bs)
      {
        int v10 = bitnum >> 3;
        if (bs->length > v10)
        {
          unint64_t data = bs->data;
          if (data)
          {
            if ((data[v10] >> (~tbl->bitnum & 7)))
            {
              if (!v8)
              {
                BIO_puts(out, ", ");
                lname = tbl->lname;
              }
              BIO_puts(out, lname);
              int v8 = 0;
            }
          }
        }
      }
      lname = tbl[1].lname;
      ++tbl;
    }
    while (lname);
  }
  BIO_puts(out, "\n");
  return 1;
}

int ASN1_BIT_STRING_set_asc(ASN1_BIT_STRING *bs, char *name, int value, BIT_STRING_BITNAME *tbl)
{
  int v6 = ASN1_BIT_STRING_num_asc(name, tbl);
  if (v6 < 0) {
    return 0;
  }
  if (!bs) {
    return 1;
  }
  int result = ASN1_BIT_STRING_set_bit(bs, v6, value);
  if (result) {
    return 1;
  }
  return result;
}

int ASN1_BIT_STRING_num_asc(char *name, BIT_STRING_BITNAME *tbl)
{
  lname = tbl->lname;
  if (!lname) {
    return -1;
  }
  for (uint64_t i = &tbl[1].lname; strcmp(*(i - 2), name) && strcmp(lname, name); i += 3)
  {
    unint64_t v5 = *i;
    lname = v5;
    if (!v5) {
      return -1;
    }
  }
  return *((_DWORD *)i - 8);
}

int i2c_ASN1_BIT_STRING(ASN1_BIT_STRING *a, unsigned __int8 **pp)
{
  if (a)
  {
    uint64_t length = a->length;
    if (length != 0x7FFFFFFF)
    {
      int v3 = length + 1;
      if (!pp) {
        return v3;
      }
      if ((int)length > 0)
      {
        uint64_t flags = a->flags;
        if ((flags & 8) != 0)
        {
          unsigned __int8 v8 = flags & 7;
          unsigned int v6 = a->length;
LABEL_21:
          int v9 = *pp;
          **punsigned int p = v8;
LABEL_22:
          uint64_t v12 = v9 + 1;
          memcpy(v9 + 1, a->data, v6);
          int v11 = &v12[v6];
          *(v11 - 1) &= -1 << v8;
          goto LABEL_23;
        }
        unsigned int v6 = length + 1;
        while (length >= 1)
        {
          signed __int8 v7 = a->data[length - 1];
          --v6;
          --length;
          if (v7)
          {
            if (v7)
            {
              unsigned __int8 v8 = 0;
            }
            else if ((v7 & 2) != 0)
            {
              unsigned __int8 v8 = 1;
            }
            else if ((v7 & 4) != 0)
            {
              unsigned __int8 v8 = 2;
            }
            else if ((v7 & 8) != 0)
            {
              unsigned __int8 v8 = 3;
            }
            else if ((v7 & 0x10) != 0)
            {
              unsigned __int8 v8 = 4;
            }
            else if ((v7 & 0x20) != 0)
            {
              unsigned __int8 v8 = 5;
            }
            else if ((v7 & 0x40) != 0)
            {
              unsigned __int8 v8 = 6;
            }
            else
            {
              if ((v7 & 0x80000000) == 0)
              {
                unsigned __int8 v8 = 0;
                int v9 = *pp;
                **punsigned int p = 0;
                goto LABEL_22;
              }
              unsigned __int8 v8 = 7;
            }
            goto LABEL_21;
          }
        }
      }
      int v10 = *pp;
      *int v10 = 0;
      int v11 = v10 + 1;
LABEL_23:
      *punsigned int p = v11;
      return v3;
    }
  }
  return 0;
}

uint64_t c2i_ASN1_BIT_STRING_cbs(ASN1_VALUE **a1, void *a2)
{
  size_t v14 = 0;
  int v15 = 0;
  unsigned __int8 v13 = 0;
  if (!a1) {
    goto LABEL_11;
  }
  unint64_t v4 = *a1;
  if (v4)
  {
    ASN1_item_free(v4, &ASN1_BIT_STRING_it);
    *a1 = 0;
  }
  if (!CBS_get_u8(a2, &v13))
  {
    ERR_put_error(13, 4095, 152, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_bitstr.c", 318);
LABEL_11:
    signed __int8 v7 = 0;
    goto LABEL_12;
  }
  int v5 = CBS_stow((uint64_t)a2, (void **)&v15, &v14);
  uint64_t v6 = 0;
  signed __int8 v7 = 0;
  if (v5 && !(v14 >> 31))
  {
    unsigned __int8 v8 = ASN1_item_new(&ASN1_BIT_STRING_it);
    signed __int8 v7 = v8;
    if (!v8)
    {
LABEL_12:
      uint64_t v6 = 0;
      goto LABEL_13;
    }
    int v10 = v14;
    int v9 = v15;
    *((void *)v8 + 1) = v15;
    *(_DWORD *)unsigned __int8 v8 = v10;
    int v15 = 0;
    unsigned __int8 v11 = v13;
    if (v13 >= 8u)
    {
      ERR_put_error(13, 4095, 220, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_bitstr.c", 339);
      goto LABEL_12;
    }
    *((void *)v8 + 2) = v13 | *((void *)v8 + 2) & 0xFFFFFFFFFFFFFFF0 | 8;
    if (v10 >= 1) {
      v9[v10 - 1] &= -1 << v11;
    }
    *a1 = v8;
    uint64_t v6 = 1;
    signed __int8 v7 = 0;
  }
LABEL_13:
  ASN1_item_free(v7, &ASN1_BIT_STRING_it);
  freezero(v15, v14);
  return v6;
}

ASN1_BIT_STRING *__cdecl c2i_ASN1_BIT_STRING(ASN1_BIT_STRING **a, const unsigned __int8 **pp, uint64_t length)
{
  unsigned __int8 v8 = 0;
  if (a)
  {
    ASN1_item_free((ASN1_VALUE *)*a, &ASN1_BIT_STRING_it);
    BUF_MEM *a = 0;
  }
  if (length < 0)
  {
    ERR_put_error(13, 4095, 136, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_bitstr.c", 369);
    return 0;
  }
  memset(v7, 0, sizeof(v7));
  CBS_init(v7, (uint64_t)*pp, length);
  if (!c2i_ASN1_BIT_STRING_cbs((ASN1_VALUE **)&v8, v7)) {
    return 0;
  }
  *punsigned int p = (const unsigned __int8 *)CBS_data((uint64_t)v7);
  int result = v8;
  if (a) {
    BUF_MEM *a = v8;
  }
  return result;
}

int i2d_ASN1_BIT_STRING(ASN1_BIT_STRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_BIT_STRING_it);
}

ASN1_BIT_STRING *__cdecl d2i_ASN1_BIT_STRING(ASN1_BIT_STRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_BIT_STRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_BIT_STRING_it);
}

void ERR_load_RAND_strings(void)
{
  if (!ERR_func_error_string(RAND_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&RAND_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&RAND_str_reasons);
  }
}

void ERR_load_PKCS7_strings(void)
{
  if (!ERR_func_error_string(PKCS7_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&PKCS7_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&PKCS7_str_reasons);
  }
}

NETSCAPE_SPKAC *__cdecl d2i_NETSCAPE_SPKAC(NETSCAPE_SPKAC **a, const unsigned __int8 **in, uint64_t len)
{
  return (NETSCAPE_SPKAC *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &NETSCAPE_SPKAC_it);
}

int i2d_NETSCAPE_SPKAC(NETSCAPE_SPKAC *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &NETSCAPE_SPKAC_it);
}

NETSCAPE_SPKAC *NETSCAPE_SPKAC_new(void)
{
  return (NETSCAPE_SPKAC *)ASN1_item_new(&NETSCAPE_SPKAC_it);
}

void NETSCAPE_SPKAC_free(NETSCAPE_SPKAC *a)
{
}

NETSCAPE_SPKI *__cdecl d2i_NETSCAPE_SPKI(NETSCAPE_SPKI **a, const unsigned __int8 **in, uint64_t len)
{
  return (NETSCAPE_SPKI *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &NETSCAPE_SPKI_it);
}

int i2d_NETSCAPE_SPKI(NETSCAPE_SPKI *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &NETSCAPE_SPKI_it);
}

NETSCAPE_SPKI *NETSCAPE_SPKI_new(void)
{
  return (NETSCAPE_SPKI *)ASN1_item_new(&NETSCAPE_SPKI_it);
}

void NETSCAPE_SPKI_free(NETSCAPE_SPKI *a)
{
}

ASN1_NULL *__cdecl d2i_ASN1_NULL(ASN1_NULL **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_NULL *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_NULL_it);
}

int i2d_ASN1_NULL(ASN1_NULL *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_NULL_it);
}

ASN1_NULL *ASN1_NULL_new(void)
{
  return (ASN1_NULL *)ASN1_item_new(&ASN1_NULL_it);
}

void ASN1_NULL_free(ASN1_NULL *a)
{
}

ASN1_UTF8STRING *__cdecl d2i_ASN1_UTF8STRING(ASN1_UTF8STRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_UTF8STRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_UTF8STRING_it);
}

int i2d_ASN1_UTF8STRING(ASN1_UTF8STRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_UTF8STRING_it);
}

ASN1_UTF8STRING *ASN1_UTF8STRING_new(void)
{
  return (ASN1_UTF8STRING *)ASN1_item_new(&ASN1_UTF8STRING_it);
}

void ASN1_UTF8STRING_free(ASN1_UTF8STRING *a)
{
}

ASN1_PRINTABLESTRING *__cdecl d2i_ASN1_PRINTABLESTRING(ASN1_PRINTABLESTRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_PRINTABLESTRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_PRINTABLESTRING_it);
}

int i2d_ASN1_PRINTABLESTRING(ASN1_PRINTABLESTRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_PRINTABLESTRING_it);
}

ASN1_PRINTABLESTRING *ASN1_PRINTABLESTRING_new(void)
{
  return (ASN1_PRINTABLESTRING *)ASN1_item_new(&ASN1_PRINTABLESTRING_it);
}

void ASN1_PRINTABLESTRING_free(ASN1_PRINTABLESTRING *a)
{
}

ASN1_T61STRING *__cdecl d2i_ASN1_T61STRING(ASN1_T61STRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_T61STRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_T61STRING_it);
}

int i2d_ASN1_T61STRING(ASN1_T61STRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_T61STRING_it);
}

ASN1_T61STRING *ASN1_T61STRING_new(void)
{
  return (ASN1_T61STRING *)ASN1_item_new(&ASN1_T61STRING_it);
}

void ASN1_T61STRING_free(ASN1_T61STRING *a)
{
}

ASN1_IA5STRING *__cdecl d2i_ASN1_IA5STRING(ASN1_IA5STRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_IA5STRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_IA5STRING_it);
}

int i2d_ASN1_IA5STRING(ASN1_IA5STRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_IA5STRING_it);
}

ASN1_IA5STRING *ASN1_IA5STRING_new(void)
{
  return (ASN1_IA5STRING *)ASN1_item_new(&ASN1_IA5STRING_it);
}

void ASN1_IA5STRING_free(ASN1_IA5STRING *a)
{
}

ASN1_GENERALSTRING *__cdecl d2i_ASN1_GENERALSTRING(ASN1_GENERALSTRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_GENERALSTRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_GENERALSTRING_it);
}

int i2d_ASN1_GENERALSTRING(ASN1_GENERALSTRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_GENERALSTRING_it);
}

ASN1_GENERALSTRING *ASN1_GENERALSTRING_new(void)
{
  return (ASN1_GENERALSTRING *)ASN1_item_new(&ASN1_GENERALSTRING_it);
}

void ASN1_GENERALSTRING_free(ASN1_GENERALSTRING *a)
{
}

ASN1_UTCTIME *__cdecl d2i_ASN1_UTCTIME(ASN1_UTCTIME **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_UTCTIME *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_UTCTIME_it);
}

int i2d_ASN1_UTCTIME(ASN1_UTCTIME *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_UTCTIME_it);
}

ASN1_UTCTIME *ASN1_UTCTIME_new(void)
{
  return (ASN1_UTCTIME *)ASN1_item_new(&ASN1_UTCTIME_it);
}

void ASN1_UTCTIME_free(ASN1_UTCTIME *a)
{
}

ASN1_GENERALIZEDTIME *__cdecl d2i_ASN1_GENERALIZEDTIME(ASN1_GENERALIZEDTIME **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_GENERALIZEDTIME *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_GENERALIZEDTIME_it);
}

int i2d_ASN1_GENERALIZEDTIME(ASN1_GENERALIZEDTIME *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_GENERALIZEDTIME_it);
}

ASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_new(void)
{
  return (ASN1_GENERALIZEDTIME *)ASN1_item_new(&ASN1_GENERALIZEDTIME_it);
}

void ASN1_GENERALIZEDTIME_free(ASN1_GENERALIZEDTIME *a)
{
}

ASN1_VISIBLESTRING *__cdecl d2i_ASN1_VISIBLESTRING(ASN1_VISIBLESTRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_VISIBLESTRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_VISIBLESTRING_it);
}

int i2d_ASN1_VISIBLESTRING(ASN1_VISIBLESTRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_VISIBLESTRING_it);
}

ASN1_VISIBLESTRING *ASN1_VISIBLESTRING_new(void)
{
  return (ASN1_VISIBLESTRING *)ASN1_item_new(&ASN1_VISIBLESTRING_it);
}

void ASN1_VISIBLESTRING_free(ASN1_VISIBLESTRING *a)
{
}

ASN1_UNIVERSALSTRING *__cdecl d2i_ASN1_UNIVERSALSTRING(ASN1_UNIVERSALSTRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_UNIVERSALSTRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_UNIVERSALSTRING_it);
}

int i2d_ASN1_UNIVERSALSTRING(ASN1_UNIVERSALSTRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_UNIVERSALSTRING_it);
}

ASN1_UNIVERSALSTRING *ASN1_UNIVERSALSTRING_new(void)
{
  return (ASN1_UNIVERSALSTRING *)ASN1_item_new(&ASN1_UNIVERSALSTRING_it);
}

void ASN1_UNIVERSALSTRING_free(ASN1_UNIVERSALSTRING *a)
{
}

ASN1_BMPSTRING *__cdecl d2i_ASN1_BMPSTRING(ASN1_BMPSTRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_BMPSTRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_BMPSTRING_it);
}

int i2d_ASN1_BMPSTRING(ASN1_BMPSTRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_BMPSTRING_it);
}

ASN1_BMPSTRING *ASN1_BMPSTRING_new(void)
{
  return (ASN1_BMPSTRING *)ASN1_item_new(&ASN1_BMPSTRING_it);
}

void ASN1_BMPSTRING_free(ASN1_BMPSTRING *a)
{
}

ASN1_STRING *__cdecl d2i_ASN1_PRINTABLE(ASN1_STRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_STRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_PRINTABLE_it);
}

int i2d_ASN1_PRINTABLE(ASN1_STRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_PRINTABLE_it);
}

ASN1_STRING *ASN1_PRINTABLE_new(void)
{
  return (ASN1_STRING *)ASN1_item_new(&ASN1_PRINTABLE_it);
}

void ASN1_PRINTABLE_free(ASN1_STRING *a)
{
}

ASN1_STRING *__cdecl d2i_DISPLAYTEXT(ASN1_STRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_STRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &DISPLAYTEXT_it);
}

int i2d_DISPLAYTEXT(ASN1_STRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &DISPLAYTEXT_it);
}

ASN1_STRING *DISPLAYTEXT_new(void)
{
  return (ASN1_STRING *)ASN1_item_new(&DISPLAYTEXT_it);
}

void DISPLAYTEXT_free(ASN1_STRING *a)
{
}

ASN1_STRING *__cdecl d2i_DIRECTORYSTRING(ASN1_STRING **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_STRING *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &DIRECTORYSTRING_it);
}

int i2d_DIRECTORYSTRING(ASN1_STRING *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &DIRECTORYSTRING_it);
}

ASN1_STRING *DIRECTORYSTRING_new(void)
{
  return (ASN1_STRING *)ASN1_item_new(&DIRECTORYSTRING_it);
}

void DIRECTORYSTRING_free(ASN1_STRING *a)
{
}

int i2d_ASN1_BOOLEAN(int a, unsigned __int8 **pp)
{
  LODWORD(pval) = a;
  return ASN1_item_ex_i2d(&pval, pp, &ASN1_BOOLEAN_it, -1, 0);
}

int d2i_ASN1_BOOLEAN(int *a, const unsigned __int8 **pp, uint64_t length)
{
  LODWORD(pval) = 0;
  int v4 = -1;
  if (ASN1_item_ex_d2i(&pval, pp, length, &ASN1_BOOLEAN_it, -1, 0, 0, 0) >= 1)
  {
    int v4 = (int)pval;
    if (a) {
      BUF_MEM *a = (int)pval;
    }
  }
  return v4;
}

ASN1_VALUE *d2i_ASN1_SEQUENCE_ANY(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &ASN1_SEQUENCE_ANY_it);
}

uint64_t i2d_ASN1_SEQUENCE_ANY(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &ASN1_SEQUENCE_ANY_it);
}

ASN1_VALUE *d2i_ASN1_SET_ANY(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &ASN1_SET_ANY_it);
}

uint64_t i2d_ASN1_SET_ANY(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &ASN1_SET_ANY_it);
}

uint64_t pkey_hmac_init(uint64_t a1)
{
  uint64_t result = (uint64_t)malloc_type_calloc(1uLL, 0x150uLL, 0x10F00401018A6D6uLL);
  if (result)
  {
    uint64_t v3 = result;
    *(_DWORD *)(result + 12) = 4;
    HMAC_CTX_init((HMAC_CTX *)(result + 32));
    *(void *)(a1 + 40) = v3;
    *(_DWORD *)(a1 + 72) = 0;
    return 1;
  }
  return result;
}

uint64_t pkey_hmac_copy(uint64_t a1, uint64_t a2)
{
  uint64_t result = pkey_hmac_init(a1);
  if (result)
  {
    uint64_t v5 = *(void *)(a2 + 40);
    uint64_t v6 = *(void *)(a1 + 40);
    *(void *)uint64_t v6 = *(void *)v5;
    HMAC_CTX_init((HMAC_CTX *)(v6 + 32));
    uint64_t result = HMAC_CTX_copy(v6 + 32, v5 + 32);
    if (result)
    {
      signed __int8 v7 = *(const unsigned __int8 **)(v5 + 16);
      if (!v7) {
        return 1;
      }
      uint64_t result = ASN1_OCTET_STRING_set((ASN1_OCTET_STRING *)(v6 + 8), v7, *(_DWORD *)(v5 + 8));
      if (result) {
        return 1;
      }
    }
  }
  return result;
}

void pkey_hmac_cleanup(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1)
  {
    HMAC_CTX_cleanup((HMAC_CTX *)(v1 + 32));
    freezero(*(void **)(v1 + 16), *(int *)(v1 + 8));
    free((void *)v1);
  }
}

char *pkey_hmac_keygen(uint64_t a1, EVP_PKEY *a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (!*(void *)(v2 + 16)) {
    return 0;
  }
  uint64_t result = (char *)ASN1_OCTET_STRING_dup((ASN1_OCTET_STRING *)(v2 + 8));
  if (result)
  {
    EVP_PKEY_assign(a2, 855, result);
    return (char *)1;
  }
  return result;
}

uint64_t hmac_signctx_init(uint64_t a1, EVP_MD_CTX *a2)
{
  a2[1].engine = (ENGINE *)int_update_0;
  return 1;
}

void hmac_signctx(uint64_t a1, unsigned __int8 *a2, void *a3, EVP_MD_CTX *ctx)
{
  uint64_t v6 = *(void *)(a1 + 40);
  signed __int8 v7 = EVP_MD_CTX_md(ctx);
  unsigned int v8 = EVP_MD_size(v7);
  if ((v8 & 0x80000000) == 0)
  {
    *a3 = v8;
    if (a2)
    {
      unsigned int len = 0;
      HMAC_Final((HMAC_CTX *)(v6 + 32), a2, &len);
      if (v9) {
        *a3 = len;
      }
    }
  }
}

uint64_t pkey_hmac_ctrl(uint64_t a1, int a2, int a3, unsigned __int8 *data)
{
  uint64_t v5 = *(void *)(a1 + 40);
  if (a2 == 1)
  {
    *(void *)uint64_t v5 = data;
    return 1;
  }
  if (a2 == 7)
  {
    HMAC_Init_ex((HMAC_CTX *)(v5 + 32), *(const void **)(*(void *)(*(void *)(a1 + 16) + 32) + 8), **(_DWORD **)(*(void *)(a1 + 16) + 32), *(const EVP_MD **)v5, *(ENGINE **)(a1 + 8));
    return v9 != 0;
  }
  if (a2 != 6) {
    return 4294967294;
  }
  uint64_t v6 = 0;
  BOOL v8 = a3 > 0 && data == 0;
  if (a3 >= -1 && !v8) {
    return ASN1_OCTET_STRING_set((ASN1_OCTET_STRING *)(v5 + 8), data, a3) != 0;
  }
  return v6;
}

uint64_t pkey_hmac_ctrl_str(uint64_t a1, char *__s1, unsigned __int8 *a3)
{
  if (!a3) {
    return 0;
  }
  if (!strcmp(__s1, "key")) {
    return ASN1_OCTET_STRING_set((ASN1_OCTET_STRING *)(*(void *)(a1 + 40) + 8), a3, -1) != 0;
  }
  if (strcmp(__s1, "hexkey")) {
    return 4294967294;
  }
  uint64_t len = 0;
  signed __int8 v7 = string_to_hex((char *)a3, &len);
  if (!v7) {
    return 0;
  }
  BOOL v8 = v7;
  BOOL v6 = (int)len >= -1 && ASN1_OCTET_STRING_set((ASN1_OCTET_STRING *)(*(void *)(a1 + 40) + 8), v7, len) != 0;
  free(v8);
  return v6;
}

BOOL int_update_0(uint64_t a1, const unsigned __int8 *a2, size_t a3)
{
  HMAC_Update((HMAC_CTX *)(*(void *)(*(void *)(a1 + 32) + 40) + 32), a2, a3);
  return v3 != 0;
}

void DES_ede3_ofb64_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, DES_key_schedule *ks1, DES_key_schedule *ks2, DES_key_schedule *ks3, DES_cblock *ivec, int *num)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  int v8 = *num;
  int v9 = (*ivec)[0];
  int v10 = (*ivec)[1];
  int v11 = (*ivec)[2];
  int v12 = (*ivec)[3];
  unsigned int v13 = v9 | (v10 << 8) | (v11 << 16) | (v12 << 24);
  int v14 = (*ivec)[4];
  int v15 = (*ivec)[5];
  int v16 = (*ivec)[6];
  int v17 = (*ivec)[7];
  int v18 = v14 | (v15 << 8) | (v16 << 16) | (v17 << 24);
  unsigned int data = v13;
  int v30 = v18;
  LOBYTE(v31) = v9;
  BYTE1(v31) = v10;
  BYTE2(v31) = v11;
  HIBYTE(v31) = v12;
  LOBYTE(v32) = v14;
  BYTE1(v32) = v15;
  BYTE2(v32) = v16;
  HIBYTE(v32) = v17;
  if (length)
  {
    uint64_t v23 = length;
    int v28 = num;
    int v26 = 0;
    do
    {
      if (!v8)
      {
        DES_encrypt3(&data, ks1, ks2, ks3);
        unsigned int v13 = data;
        int v18 = v30;
        unsigned int v31 = data;
        int v32 = v30;
        ++v26;
      }
      char v27 = *in++;
      *out++ = *((unsigned char *)&v31 + v8) ^ v27;
      int v8 = (v8 + 1) & 7;
      --v23;
    }
    while (v23);
    if (v26)
    {
      *(_DWORD *)ivec = v13;
      *(_DWORD *)&(*ivec)[4] = v18;
    }
    uint64_t num = v28;
  }
  *uint64_t num = v8;
}

char *recallocarray(char *a1, unint64_t a2, size_t count, size_t size)
{
  if (a1)
  {
    uint64_t v5 = a1;
    if (count && (size | count) >> 32 && !is_mul_ok(count, size))
    {
      BOOL v6 = __error();
      uint64_t v5 = 0;
      int v7 = 12;
LABEL_10:
      *BOOL v6 = v7;
      return v5;
    }
    if (a2 && (size | a2) >> 32 && !is_mul_ok(a2, size))
    {
      BOOL v6 = __error();
      uint64_t v5 = 0;
      int v7 = 22;
      goto LABEL_10;
    }
    size_t v9 = size * count;
    size_t v10 = size * a2;
    size_t v11 = size * count - size * a2;
    if (size * count <= size * a2)
    {
      if (v10 - v9 < v10 >> 1 && v10 - v9 < getpagesize())
      {
        bzero(&v5[v9], v10 - v9);
        return v5;
      }
      int v14 = malloc_type_malloc(v9, 0xCA6BA60AuLL);
      if (v14)
      {
        memcpy(v14, v5, v9);
LABEL_22:
        explicit_bzero(v5, v10);
      }
    }
    else
    {
      int v12 = (char *)malloc_type_malloc(size * count, 0xCA6BA60AuLL);
      if (v12)
      {
        unsigned int v13 = v12;
        memcpy(v12, v5, v10);
        bzero(&v13[v10], v11);
        goto LABEL_22;
      }
    }
    return 0;
  }
  return (char *)malloc_type_calloc(count, size, 0xA14FC9F3uLL);
}

BIO_METHOD *BIO_f_base64(void)
{
  return (BIO_METHOD *)&methods_b64;
}

uint64_t b64_write(BIO *a1, char *a2, int a3)
{
  next_bio = a1->next_bio;
  BIO_clear_flags(a1, 15);
  if (LODWORD(next_bio->cb_arg) != 1)
  {
    LODWORD(next_bio->cb_arg) = 1;
    next_bio->int method = 0;
    LODWORD(next_bio->callback) = 0;
    EVP_EncodeInit((EVP_ENCODE_CTX *)&next_bio->shutdown);
  }
  if (SHIDWORD(next_bio->method) >= 1502) {
    OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 372, "ctx->buf_off < (int)sizeof(ctx->buf)");
  }
  int method = (int)next_bio->method;
  if (SLODWORD(next_bio->method) > 1502) {
    OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 373, "ctx->buf_len <= (int)sizeof(ctx->buf)");
  }
  int method_high = HIDWORD(next_bio->method);
  if (method < method_high) {
    OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 374, "ctx->buf_len >= ctx->buf_off");
  }
  int v9 = method - method_high;
  if (method - method_high < 1)
  {
LABEL_18:
    uint64_t v11 = 0;
    next_bio->int method = 0;
    if (a2 && a3 >= 1)
    {
      LODWORD(v11) = 0;
      f = (unsigned __int8 *)&next_bio[14].next_bio + 2;
      char v27 = (unsigned __int8 *)&next_bio[1].callback + 4;
      while (1)
      {
        uint64_t v14 = a3 >= 1024 ? 1024 : a3;
        if ((BIO_test_flags(a1, -1) & 0x100) != 0)
        {
          int callback = (int)next_bio->callback;
          if (callback < 1)
          {
            if (v14 <= 2)
            {
              memcpy(f, a2, v14);
              LODWORD(next_bio->callback) = v14;
              return (v11 + v14);
            }
            LODWORD(v14) = v14 - (unsigned __int16)v14 % 3u;
            int v19 = EVP_EncodeBlock(v27, (const unsigned __int8 *)a2, v14);
            LODWORD(next_bio->method) = v19;
            if (v19 >= 1503) {
              OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 431, "ctx->buf_len <= (int)sizeof(ctx->buf)");
            }
            if (v19 < SHIDWORD(next_bio->method)) {
              OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 432, "ctx->buf_len >= ctx->buf_off");
            }
            uint64_t v11 = (v14 + v11);
          }
          else
          {
            if (callback >= 4) {
              OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 400, "ctx->tmp_len <= 3");
            }
            if (3 - callback >= a3) {
              LODWORD(v14) = a3;
            }
            else {
              LODWORD(v14) = 3 - callback;
            }
            memcpy((char *)&next_bio[14].next_bio + callback + 2, a2, (int)v14);
            int v17 = LODWORD(next_bio->callback) + v14;
            LODWORD(next_bio->callback) = v17;
            uint64_t v11 = (v14 + v11);
            if (v17 < 3) {
              return v11;
            }
            int v18 = EVP_EncodeBlock(v27, f, v17);
            LODWORD(next_bio->method) = v18;
            if (v18 >= 1503) {
              OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 414, "ctx->buf_len <= (int)sizeof(ctx->buf)");
            }
            if (v18 < SHIDWORD(next_bio->method)) {
              OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 415, "ctx->buf_len >= ctx->buf_off");
            }
            LODWORD(next_bio->callback) = 0;
          }
        }
        else
        {
          EVP_EncodeUpdate((EVP_ENCODE_CTX *)&next_bio->shutdown, v27, (int *)next_bio, (const unsigned __int8 *)a2, v14);
          if (!v15)
          {
            if (v11) {
              return v11;
            }
            else {
              return 0xFFFFFFFFLL;
            }
          }
          if (SLODWORD(next_bio->method) >= 1503) {
            OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 440, "ctx->buf_len <= (int)sizeof(ctx->buf)");
          }
          if (SLODWORD(next_bio->method) < SHIDWORD(next_bio->method)) {
            OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 441, "ctx->buf_len >= ctx->buf_off");
          }
          uint64_t v11 = (v11 + v14);
        }
        HIDWORD(next_bio->method) = 0;
        int v20 = (int)next_bio->method;
        if (SLODWORD(next_bio->method) >= 1) {
          break;
        }
LABEL_58:
        a2 += (int)v14;
        next_bio->int method = 0;
        BOOL v24 = __OFSUB__(a3, v14);
        a3 -= v14;
        if ((a3 < 0) ^ v24 | (a3 == 0)) {
          return v11;
        }
      }
      while (1)
      {
        int v21 = BIO_write(a1->prev_bio, (char *)&next_bio[1].callback + SHIDWORD(next_bio->method) + 4, v20);
        unsigned int v22 = v21;
        if (v21 <= 0) {
          break;
        }
        BOOL v12 = v20 >= v21;
        v20 -= v21;
        if (!v12) {
          OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 455, "i <= n");
        }
        int v23 = HIDWORD(next_bio->method) + v21;
        HIDWORD(next_bio->method) = v23;
        if (v23 >= 1503) {
          OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 458, "ctx->buf_off <= (int)sizeof(ctx->buf)");
        }
        if (SLODWORD(next_bio->method) < v23) {
          OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 459, "ctx->buf_len >= ctx->buf_off");
        }
        if (v20 <= 0) {
          goto LABEL_58;
        }
      }
      BIO_copy_next_retry(a1);
      if (v11) {
        return v11;
      }
      else {
        return v22;
      }
    }
  }
  else
  {
    while (1)
    {
      uint64_t v10 = BIO_write(a1->prev_bio, (char *)&next_bio[1].callback + SHIDWORD(next_bio->method) + 4, v9);
      uint64_t v11 = v10;
      if ((int)v10 <= 0) {
        break;
      }
      BOOL v12 = v9 >= v10;
      v9 -= v10;
      if (!v12) {
        OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 382, "i <= n");
      }
      int v13 = HIDWORD(next_bio->method) + v10;
      HIDWORD(next_bio->method) = v13;
      if (v13 >= 1503) {
        OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 384, "ctx->buf_off <= (int)sizeof(ctx->buf)");
      }
      if (SLODWORD(next_bio->method) < v13) {
        OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 385, "ctx->buf_len >= ctx->buf_off");
      }
      if (v9 <= 0) {
        goto LABEL_18;
      }
    }
    BIO_copy_next_retry(a1);
  }
  return v11;
}

uint64_t b64_read(BIO *b, char *a2, int a3)
{
  if (!a2) {
    return 0;
  }
  next_bio = b->next_bio;
  if (!next_bio || !b->prev_bio) {
    return 0;
  }
  BOOL v6 = a2;
  int outl = 0;
  BIO_clear_flags(b, 15);
  if (LODWORD(next_bio->cb_arg) != 2)
  {
    LODWORD(next_bio->cb_arg) = 2;
    next_bio->int method = 0;
    LODWORD(next_bio->callback) = 0;
    EVP_DecodeInit((EVP_ENCODE_CTX *)&next_bio->shutdown);
  }
  int method = (int)next_bio->method;
  if (SLODWORD(next_bio->method) < 1)
  {
    int v10 = 0;
  }
  else
  {
    int method_high = HIDWORD(next_bio->method);
    if (method < method_high) {
      OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 177, "ctx->buf_len >= ctx->buf_off");
    }
    int v9 = method - method_high;
    if (v9 >= a3) {
      int v10 = a3;
    }
    else {
      int v10 = v9;
    }
    if (v10 + method_high >= 1502) {
      OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 181, "ctx->buf_off + i < (int)sizeof(ctx->buf)");
    }
    memcpy(v6, (char *)&next_bio[1].callback + method_high + 4, v10);
    v6 += v10;
    a3 -= v10;
    int v11 = (int)next_bio->method;
    int v12 = HIDWORD(next_bio->method) + v10;
    HIDWORD(next_bio->method) = v12;
    if (v11 == v12) {
      next_bio->int method = 0;
    }
  }
  unsigned int v42 = v10;
  unsigned int v14 = 0;
  if (a3 >= 1)
  {
    int v15 = (const unsigned __int8 *)&next_bio[14].next_bio + 2;
    while (1)
    {
      if (next_bio->init < 1) {
        goto LABEL_85;
      }
      unsigned int v43 = v14;
      int v41 = a3;
LABEL_23:
      int v16 = BIO_read(b->prev_bio, (char *)&next_bio[14].next_bio + SLODWORD(next_bio->callback) + 2, 1024 - LODWORD(next_bio->callback));
      unsigned int v14 = v16;
      if (v16 < 1)
      {
        if (BIO_test_flags(b->prev_bio, 8)) {
          goto LABEL_85;
        }
        next_bio->init = v14;
        int callback = (int)next_bio->callback;
        if (!callback) {
          goto LABEL_85;
        }
        int v18 = 0;
        unsigned int v43 = v14;
      }
      else
      {
        int callback = (int)next_bio->callback;
        int v18 = v16;
      }
      LODWORD(v19) = callback + v18;
      LODWORD(next_bio->callback) = callback + v18;
      if (HIDWORD(next_bio->cb_arg))
      {
        if ((BIO_test_flags(b, -1) & 0x100) != 0) {
          goto LABEL_65;
        }
        if (HIDWORD(next_bio->cb_arg)) {
          break;
        }
      }
      if ((int)v19 <= 1023 && next_bio->init > 0) {
        goto LABEL_63;
      }
LABEL_66:
      if ((BIO_test_flags(b, -1) & 0x100) != 0)
      {
        unint64_t v33 = (int)v19 & 0xFFFFFFFFFFFFFFFCLL;
        int v34 = EVP_DecodeBlock((unsigned __int8 *)&next_bio[1].callback + 4, (const unsigned __int8 *)&next_bio[14].next_bio + 2, v19 & 0xFFFFFFFC);
        int v31 = v34;
        if ((int)v33 >= 3 && *((unsigned char *)&next_bio[14].next_bio + (v33 - 1) + 2) == 61)
        {
          if (*((unsigned char *)&next_bio[14].next_bio + (v33 - 2) + 2) == 61) {
            int v35 = -2;
          }
          else {
            int v35 = -1;
          }
          int v31 = v35 + v34;
        }
        if (v33 != v19)
        {
          size_t v36 = v19 & 3;
          memmove((char *)&next_bio[14].next_bio + 2, (char *)&next_bio[14].next_bio + v33 + 2, v36);
          LODWORD(next_bio->callback) = v36;
        }
        LODWORD(next_bio->method) = v31 & ~(v31 >> 31);
        int v32 = v41;
      }
      else
      {
        int v31 = EVP_DecodeUpdate((EVP_ENCODE_CTX *)&next_bio->shutdown, (unsigned __int8 *)&next_bio[1].callback + 4, (int *)next_bio, (const unsigned __int8 *)&next_bio[14].next_bio + 2, v19);
        LODWORD(next_bio->callback) = 0;
        int v32 = v41;
      }
      HIDWORD(next_bio->method) = 0;
      if (v31 < 0)
      {
        unsigned int v14 = 0;
        LODWORD(next_bio->method) = 0;
        goto LABEL_85;
      }
      if (SLODWORD(next_bio->method) >= v32) {
        int v37 = v32;
      }
      else {
        int v37 = (int)next_bio->method;
      }
      int v38 = v32;
      int v39 = v37;
      memcpy(v6, (char *)&next_bio[1].callback + 4, v37);
      HIDWORD(next_bio->method) = v37;
      if (v37 == LODWORD(next_bio->method)) {
        next_bio->int method = 0;
      }
      v42 += v37;
      v6 += v37;
      a3 = v38 - v37;
      BOOL v40 = v38 <= v39;
      unsigned int v14 = v43;
      if (v40) {
        goto LABEL_85;
      }
    }
    int outl = 0;
    if ((int)v19 < 1)
    {
      LODWORD(v22) = 0;
      int v21 = (const unsigned __int8 *)&next_bio[14].next_bio + 2;
      uint64_t v25 = (uint64_t)&next_bio[14].next_bio + 2;
      goto LABEL_52;
    }
    uint64_t v20 = 0;
    int v21 = (const unsigned __int8 *)&next_bio[14].next_bio + 2;
    while (1)
    {
      uint64_t v22 = v20;
      int v23 = (char *)next_bio + v20;
      if (v23[1626] == 10)
      {
        BOOL v24 = (const unsigned __int8 *)(v23 + 1627);
        if (HIDWORD(next_bio->callback))
        {
          HIDWORD(next_bio->callback) = 0;
        }
        else
        {
          if (EVP_DecodeUpdate((EVP_ENCODE_CTX *)&next_bio->shutdown, (unsigned __int8 *)&next_bio[1].callback + 4, &outl, v21, next_bio + 1627 + v22 - v21) > 0|| outl|| !HIDWORD(next_bio->cb_arg))
          {
            if (v21 != v15)
            {
              unint64_t v19 = (v19 + v15 - v21);
              if ((int)v19 >= 1)
              {
                for (unint64_t i = 0; i < v19; ++i)
                  v15[i] = v21[i];
              }
            }
            uint64_t v25 = (uint64_t)&next_bio[14].next_bio + v22 + 3;
            EVP_DecodeInit((EVP_ENCODE_CTX *)&next_bio->shutdown);
            HIDWORD(next_bio->cb_arg) = 0;
LABEL_52:
            if (v22 != v19 || outl)
            {
LABEL_65:
              LODWORD(next_bio->callback) = 0;
              goto LABEL_66;
            }
            if (v21 == v15)
            {
              if (v22 == 1024)
              {
                int v27 = 0;
                HIDWORD(next_bio->callback) = 1;
                goto LABEL_62;
              }
            }
            else if (v21 != (const unsigned __int8 *)v25)
            {
              int v27 = v25 - v21;
              if ((int)v25 - (int)v21 >= 1)
              {
                uint64_t v28 = (v25 - v21);
                int v29 = (char *)&next_bio[14].next_bio + 2;
                do
                {
                  char v30 = *v21++;
                  *v29++ = v30;
                  --v28;
                }
                while (v28);
              }
LABEL_62:
              LODWORD(next_bio->callback) = v27;
            }
LABEL_63:
            if (next_bio->init < 1)
            {
              unsigned int v14 = v43;
              break;
            }
            goto LABEL_23;
          }
          EVP_DecodeInit((EVP_ENCODE_CTX *)&next_bio->shutdown);
        }
        int v21 = v24;
      }
      uint64_t v20 = v22 + 1;
      if (v19 == v22 + 1)
      {
        uint64_t v25 = (uint64_t)&next_bio[14].next_bio + v22 + 3;
        LODWORD(v22) = v19;
        goto LABEL_52;
      }
    }
  }
LABEL_85:
  BIO_copy_next_retry(b);
  if (v42) {
    return v42;
  }
  else {
    return v14;
  }
}

uint64_t b64_puts(BIO *a1, char *__s)
{
  int v4 = strlen(__s);
  return b64_write(a1, __s, v4);
}

uint64_t b64_ctrl(BIO *b, int a2, uint64_t larg, void *parg)
{
  next_bio = b->next_bio;
  uint64_t result = 1;
  switch(a2)
  {
    case 1:
      next_bio->init = 1;
      next_bio->cb_unsigned int arg = (char *)0x100000000;
      prev_bio = b->prev_bio;
      a2 = 1;
      goto LABEL_30;
    case 2:
      if (next_bio->init < 1) {
        return 1;
      }
      prev_bio = b->prev_bio;
      a2 = 2;
      goto LABEL_30;
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      goto LABEL_5;
    case 10:
      int method = (int)next_bio->method;
      int method_high = HIDWORD(next_bio->method);
      if (SLODWORD(next_bio->method) < method_high) {
        OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 499, "ctx->buf_len >= ctx->buf_off");
      }
      uint64_t result = (method - method_high);
      if (method > method_high) {
        return result;
      }
      prev_bio = b->prev_bio;
      a2 = 10;
      goto LABEL_30;
    case 11:
      break;
    case 12:
      return result;
    case 13:
      int v15 = (int)next_bio->method;
      int v16 = HIDWORD(next_bio->method);
      if (SLODWORD(next_bio->method) < v16) {
        OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/bio_b64.c", 490, "ctx->buf_len >= ctx->buf_off");
      }
      uint64_t result = (v15 - v16);
      if (v15 == v16 && LODWORD(next_bio->cb_arg) && next_bio->shutdown) {
        return 1;
      }
      if ((int)result > 0) {
        return result;
      }
      prev_bio = b->prev_bio;
      a2 = 13;
      goto LABEL_30;
    default:
      if (a2 == 101)
      {
        BIO_clear_flags(b, 15);
        uint64_t v10 = BIO_ctrl(b->prev_bio, 101, larg, parg);
        BIO_copy_next_retry(b);
        return v10;
      }
LABEL_5:
      prev_bio = b->prev_bio;
      goto LABEL_30;
  }
  while (2)
  {
    while (LODWORD(next_bio->method) != HIDWORD(next_bio->method))
    {
      LODWORD(result) = b64_write(b, 0, 0);
      if ((result & 0x80000000) != 0) {
        return (int)result;
      }
    }
    if ((BIO_test_flags(b, -1) & 0x100) != 0)
    {
      int callback = (int)next_bio->callback;
      if (callback)
      {
        int v14 = EVP_EncodeBlock((unsigned __int8 *)&next_bio[1].callback + 4, (const unsigned __int8 *)&next_bio[14].next_bio + 2, callback);
        HIDWORD(next_bio->method) = 0;
        LODWORD(next_bio->callback) = 0;
        LODWORD(next_bio->method) = v14;
        continue;
      }
    }
    else if (LODWORD(next_bio->cb_arg) && next_bio->shutdown)
    {
      HIDWORD(next_bio->method) = 0;
      EVP_EncodeFinal((EVP_ENCODE_CTX *)&next_bio->shutdown, (unsigned __int8 *)&next_bio[1].callback + 4, (int *)next_bio);
      continue;
    }
    break;
  }
  prev_bio = b->prev_bio;
  a2 = 11;
LABEL_30:
  return BIO_ctrl(prev_bio, a2, larg, parg);
}

double b64_new(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0xA5CuLL, 0x10000407E11CA4CuLL);
  if (v2)
  {
    *uint64_t v2 = 0;
    v2[1] = 0;
    *((_DWORD *)v2 + 6) = 1;
    *(void *)&double result = 0x100000000;
    v2[2] = 0x100000000;
    *(_DWORD *)(a1 + 32) = 1;
    *(void *)(a1 + 56) = v2;
    *(_DWORD *)(a1 + 40) = 0;
    *(_DWORD *)(a1 + 48) = 0;
  }
  return result;
}

uint64_t b64_free(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    free(*(void **)(result + 56));
    *(void *)(v1 + 56) = 0;
    *(_DWORD *)(v1 + 32) = 0;
    double result = 1;
    *(_DWORD *)(v1 + 40) = 0;
  }
  return result;
}

BIO *b64_callback_ctrl(uint64_t a1, int a2, void (__cdecl *a3)(bio_st *, int, const char *, int, uint64_t, uint64_t))
{
  double result = *(BIO **)(a1 + 64);
  if (result) {
    return (BIO *)BIO_callback_ctrl(result, a2, a3);
  }
  return result;
}

void ENGINE_unregister_ECDH(ENGINE *e)
{
}

int ENGINE_register_ECDH(ENGINE *e)
{
  if (*((void *)e + 5)) {
    return engine_table_register(&ecdh_table, (uint64_t)engine_unregister_all_ECDH, (char *)e, &dummy_nid_2, 1, 0);
  }
  else {
    return 1;
  }
}

void engine_unregister_all_ECDH()
{
}

void ENGINE_register_all_ECDH(void)
{
  first = ENGINE_get_first();
  if (first)
  {
    next = first;
    do
    {
      if (*((void *)next + 5)) {
        engine_table_register(&ecdh_table, (uint64_t)engine_unregister_all_ECDH, (char *)next, &dummy_nid_2, 1, 0);
      }
      next = ENGINE_get_next(next);
    }
    while (next);
  }
}

int ENGINE_set_default_ECDH(ENGINE *e)
{
  if (*((void *)e + 5)) {
    return engine_table_register(&ecdh_table, (uint64_t)engine_unregister_all_ECDH, (char *)e, &dummy_nid_2, 1, 1);
  }
  else {
    return 1;
  }
}

ENGINE *ENGINE_get_default_ECDH(void)
{
  return (ENGINE *)engine_table_select(&ecdh_table, 1);
}

const ECDH_METHOD *__cdecl ENGINE_get_ECDH(const ENGINE *e)
{
  return (const ECDH_METHOD *)*((void *)e + 5);
}

int ENGINE_set_ECDH(ENGINE *e, const ECDH_METHOD *ecdh_meth)
{
  *((void *)e + 5) = ecdh_meth;
  return 1;
}

int DH_generate_key(DH *dh)
{
  return (*(uint64_t (**)(void))(*(void *)&dh->ex_data.dummy + 8))();
}

int DH_compute_key(unsigned __int8 *key, const BIGNUM *pub_key, DH *dh)
{
  return (*(uint64_t (**)(unsigned __int8 *, const BIGNUM *))(*(void *)&dh->ex_data.dummy + 16))(key, pub_key);
}

const DH_METHOD *DH_OpenSSL(void)
{
  return (const DH_METHOD *)&dh_ossl;
}

uint64_t generate_key(uint64_t a1)
{
  if (BN_num_bits(*(const BIGNUM **)(a1 + 8)) >= 10001)
  {
    ERR_put_error(5, 4095, 103, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_key.c", 112);
    return 0;
  }
  int v3 = BN_CTX_new();
  if (!v3)
  {
    uint64_t v5 = 0;
    int v4 = 0;
    goto LABEL_11;
  }
  int v4 = *(BIGNUM **)(a1 + 40);
  if (!v4)
  {
    int v4 = BN_new();
    if (!v4)
    {
      uint64_t v5 = 0;
      goto LABEL_11;
    }
  }
  uint64_t v5 = *(BIGNUM **)(a1 + 32);
  if (!v5)
  {
    uint64_t v5 = BN_new();
    if (!v5) {
      goto LABEL_11;
    }
  }
  if ((*(unsigned char *)(a1 + 48) & 1) == 0)
  {
    BOOL v6 = 0;
    goto LABEL_20;
  }
  BOOL v6 = BN_MONT_CTX_set_locked((BN_MONT_CTX **)(a1 + 56), 26, *(const BIGNUM **)(a1 + 8), v3);
  if (!v6)
  {
LABEL_11:
    int v7 = 0;
    goto LABEL_12;
  }
LABEL_20:
  if (*(void *)(a1 + 40))
  {
    int v7 = 0;
  }
  else if (*(void *)(a1 + 64))
  {
    int v7 = BN_new();
    if (!v7) {
      goto LABEL_12;
    }
    int v9 = BN_value_one();
    uint64_t v10 = BN_value_one();
    if (!BN_add(v7, v9, v10) || !bn_rand_interval(v4, v7, *(BIGNUM **)(a1 + 64))) {
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 24);
    if (!v11) {
      LODWORD(v11) = BN_num_bits(*(const BIGNUM **)(a1 + 8)) - 1;
    }
    int v7 = 0;
    if (!BN_rand(v4, v11, 0, 0)) {
      goto LABEL_12;
    }
  }
  if (!(*(unsigned int (**)(uint64_t, BIGNUM *, void, BIGNUM *, void, BN_CTX *, BN_MONT_CTX *))(*(void *)(a1 + 120) + 24))(a1, v5, *(void *)(a1 + 16), v4, *(void *)(a1 + 8), v3, v6))
  {
LABEL_12:
    ERR_put_error(5, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_key.c", 162);
    if (!*(void *)(a1 + 32)) {
      BN_free(v5);
    }
    uint64_t v2 = 0;
    goto LABEL_15;
  }
  *(void *)(a1 + 32) = v5;
  *(void *)(a1 + 40) = v4;
  uint64_t v2 = 1;
LABEL_15:
  if (!*(void *)(a1 + 40)) {
    BN_free(v4);
  }
  BN_CTX_free(v3);
  BN_free(v7);
  return v2;
}

uint64_t compute_key(unsigned __int8 *a1, const BIGNUM *a2, uint64_t a3)
{
  if (BN_num_bits(*(const BIGNUM **)(a3 + 8)) < 10001)
  {
    BOOL v6 = BN_CTX_new();
    if (!v6) {
      return 0xFFFFFFFFLL;
    }
    int v7 = v6;
    codeunsigned int s = 0;
    BN_CTX_start(v6);
    int v8 = BN_CTX_get(v7);
    if (!v8) {
      goto LABEL_18;
    }
    if (*(void *)(a3 + 40))
    {
      int v9 = v8;
      if (*(unsigned char *)(a3 + 48))
      {
        uint64_t v10 = BN_MONT_CTX_set_locked((BN_MONT_CTX **)(a3 + 56), 26, *(const BIGNUM **)(a3 + 8), v7);
        BN_set_flags(*(void *)(a3 + 40), 4);
        if (!v10)
        {
LABEL_18:
          uint64_t v11 = 0xFFFFFFFFLL;
          goto LABEL_19;
        }
      }
      else
      {
        uint64_t v10 = 0;
      }
      if (!DH_check_pub_key((const DH *)a3, a2, &codes) || codes)
      {
        int v12 = 102;
        int v13 = 210;
      }
      else
      {
        if ((*(unsigned int (**)(uint64_t, const BIGNUM *, const BIGNUM *, void, void, BN_CTX *, BN_MONT_CTX *))(*(void *)(a3 + 120) + 24))(a3, v9, a2, *(void *)(a3 + 40), *(void *)(a3 + 8), v7, v10))
        {
          uint64_t v11 = BN_bn2bin(v9, a1);
LABEL_19:
          BN_CTX_end(v7);
          BN_CTX_free(v7);
          return v11;
        }
        int v12 = 3;
        int v13 = 216;
      }
    }
    else
    {
      int v12 = 100;
      int v13 = 195;
    }
    ERR_put_error(5, 4095, v12, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_key.c", v13);
    goto LABEL_18;
  }
  ERR_put_error(5, 4095, 103, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_key.c", 183);
  return 0xFFFFFFFFLL;
}

uint64_t dh_bn_mod_exp(int a1, BIGNUM *rr, BIGNUM *a, BIGNUM *p, BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)
{
  return BN_mod_exp_mont_ct(rr, a, p, m, ctx, in_mont);
}

uint64_t dh_init(uint64_t a1)
{
  *(_DWORD *)(a1 + 48) |= 1u;
  return 1;
}

uint64_t dh_finish(uint64_t a1)
{
  return 1;
}

int EVP_PBE_CipherInit(ASN1_OBJECT *pbe_obj, const char *pass, int passlen, ASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de)
{
  uint64_t v6 = *(void *)&en_de;
  size_t v9 = *(void *)&passlen;
  uint64_t v23 = *MEMORY[0x263EF8340];
  uint64_t v20 = 0;
  *(void *)n = 0;
  int v12 = OBJ_obj2nid(pbe_obj);
  if (!EVP_PBE_find(0, v12, &n[1], n, &v20))
  {
    ERR_put_error(6, 4095, 121, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_pbe.c", 133);
    if (pbe_obj) {
      i2t_ASN1_OBJECT(buf, 80, pbe_obj);
    }
    else {
      __strlcpy_chk();
    }
    ERR_asprintf_error_data("TYPE=%s", buf);
    return 0;
  }
  if (pass)
  {
    if (v9 == -1) {
      size_t v9 = strlen(pass);
    }
  }
  else
  {
    size_t v9 = 0;
  }
  if (n[1] == -1)
  {
    cipherbyname = 0;
LABEL_12:
    if (n[0] == -1)
    {
      digestbyname = 0;
    }
    else
    {
      int v17 = OBJ_nid2sn(n[0]);
      digestbyname = EVP_get_digestbyname(v17);
      if (!digestbyname)
      {
        int v15 = 161;
        int v16 = 162;
        goto LABEL_21;
      }
    }
    if (v20(ctx, pass, v9, param, cipherbyname, digestbyname, v6)) {
      return 1;
    }
    int v15 = 120;
    int v16 = 168;
    goto LABEL_21;
  }
  int v13 = OBJ_nid2sn(n[1]);
  cipherbyname = EVP_get_cipherbyname(v13);
  if (cipherbyname) {
    goto LABEL_12;
  }
  int v15 = 160;
  int v16 = 152;
LABEL_21:
  ERR_put_error(6, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_pbe.c", v16);
  return 0;
}

uint64_t EVP_PBE_find(int a1, int a2, _DWORD *a3, _DWORD *a4, void *a5)
{
  if (!a2) {
    return 0;
  }
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  *(_DWORD *)unsigned int data = a1;
  int v11 = a2;
  if (pbe_algs
    && (int v8 = sk_find((STACK *)pbe_algs, data), v8 != -1)
    && (uint64_t result = (uint64_t)sk_value((const STACK *)pbe_algs, v8)) != 0
    || (uint64_t result = (uint64_t)OBJ_bsearch_(data, builtin_pbe, 23, 24, (int (__cdecl *)(const void *, const void *))pbe2_cmp_BSEARCH_CMP_FN)) != 0)
  {
    if (a3) {
      *a3 = *(_DWORD *)(result + 8);
    }
    if (a4) {
      *a4 = *(_DWORD *)(result + 12);
    }
    if (a5) {
      *a5 = *(void *)(result + 16);
    }
    return 1;
  }
  return result;
}

uint64_t EVP_PBE_alg_add_type(int a1, int a2, int a3, int a4, uint64_t a5)
{
  if (pbe_algs || (pbe_algunsigned int s = (uint64_t)sk_new((int (__cdecl *)(const char *const *, const char *const *))pbe_cmp)) != 0)
  {
    uint64_t v10 = malloc_type_malloc(0x18uLL, 0x108004098BBCF0FuLL);
    if (v10)
    {
      int v11 = v10;
      *uint64_t v10 = a1;
      v10[1] = a2;
      v10[2] = a3;
      v10[3] = a4;
      *((void *)v10 + 2) = a5;
      if (sk_push((STACK *)pbe_algs, (char *)v10)) {
        return 1;
      }
      free(v11);
      int v13 = 244;
    }
    else
    {
      int v13 = 233;
    }
  }
  else
  {
    int v13 = 227;
  }
  ERR_put_error(6, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_pbe.c", v13);
  return 0;
}

uint64_t pbe_cmp(int **a1, int **a2)
{
  uint64_t v2 = *a1;
  int v3 = **a1;
  int v4 = **a2;
  uint64_t result = (v3 - v4);
  if (v3 == v4) {
    return (v2[1] - (*a2)[1]);
  }
  return result;
}

int EVP_PBE_alg_add(int nid, const EVP_CIPHER *cipher, const EVP_MD *md, EVP_PBE_KEYGEN *keygen)
{
  if (cipher)
  {
    int v7 = EVP_CIPHER_nid(cipher);
    if (md)
    {
LABEL_3:
      int v8 = EVP_MD_type(md);
      goto LABEL_6;
    }
  }
  else
  {
    int v7 = -1;
    if (md) {
      goto LABEL_3;
    }
  }
  int v8 = -1;
LABEL_6:
  return EVP_PBE_alg_add_type(0, nid, v7, v8, (uint64_t)keygen);
}

void EVP_PBE_cleanup(void)
{
  pbe_algunsigned int s = 0;
}

uint64_t pbe2_cmp_BSEARCH_CMP_FN(int *a1, _DWORD *a2)
{
  int v3 = *a1;
  uint64_t result = (*a1 - *a2);
  if (v3 == *a2) {
    return (a1[1] - a2[1]);
  }
  return result;
}

void DES_set_odd_parity(DES_cblock *key)
{
  for (uint64_t i = 0; i != 8; ++i)
    (*key)[i] = odd_parity[(*key)[i]];
}

int DES_check_key_parity(const_DES_cblock *key)
{
  uint64_t v1 = 0;
  while ((*key)[v1] == odd_parity[(*key)[v1]])
  {
    if (++v1 == 8) {
      return 1;
    }
  }
  return 0;
}

int DES_is_weak_key(const_DES_cblock *key)
{
  uint64_t v1 = 0;
  while (weak_keys[v1] != *(void *)key)
  {
    if (++v1 == 16) {
      return 0;
    }
  }
  return 1;
}

int DES_set_key(const_DES_cblock *key, DES_key_schedule *schedule)
{
  if (DES_check_key)
  {
    return DES_set_key_checked(key, schedule);
  }
  else
  {
    DES_set_key_unchecked(key, schedule);
    return 0;
  }
}

int DES_set_key_checked(const_DES_cblock *key, DES_key_schedule *schedule)
{
  for (uint64_t i = 0; i != 8; ++i)
  {
    if ((*key)[i] != odd_parity[(*key)[i]]) {
      return -1;
    }
  }
  uint64_t v3 = 0;
  while (weak_keys[v3] != *(void *)key)
  {
    if (++v3 == 16)
    {
      DES_set_key_unchecked(key, schedule);
      return 0;
    }
  }
  return -2;
}

void DES_set_key_unchecked(const_DES_cblock *key, DES_key_schedule *schedule)
{
  uint64_t v2 = 0;
  unsigned int v3 = *(_DWORD *)&(*key)[4];
  int v4 = (*(_DWORD *)key ^ (v3 >> 4)) & 0xF0F0F0F;
  unsigned int v5 = ((v4 ^ *(_DWORD *)key ^ ((v4 ^ *(_DWORD *)key) << 18)) & 0xCCCC0000 | (((v4 ^ *(_DWORD *)key ^ ((v4 ^ *(_DWORD *)key) << 18)) & 0xCCCC0000) >> 18)) ^ v4 ^ *(_DWORD *)key;
  unsigned int v6 = ((v3 ^ (16 * v4) ^ ((v3 ^ (16 * v4)) << 18)) & 0xCCCC0000 | (((v3 ^ (16 * v4) ^ ((v3 ^ (16 * v4)) << 18)) & 0xCCCC0000) >> 18)) ^ v3 ^ (16 * v4);
  int v7 = (v5 ^ (v6 >> 1)) & 0x55555555;
  unsigned int v8 = v7 ^ v5;
  int v9 = v6 ^ (2 * v7);
  int v10 = (v9 ^ (v8 >> 8)) & 0xFF00FF;
  unsigned int v11 = v10 ^ v9;
  int v12 = v8 ^ (v10 << 8);
  int v13 = (v12 ^ (v11 >> 1)) & 0x55555555;
  unsigned int v14 = v13 ^ v12;
  unsigned int v15 = (v14 >> 4) & 0xF000000 | (v11 ^ (2 * v13)) & 0xFF00 | ((v11 ^ (2 * v13)) << 16) | ((v11 ^ (2 * v13)) >> 16);
  do
  {
    if ((0x8103uLL >> v2)) {
      char v16 = 1;
    }
    else {
      char v16 = 2;
    }
    unsigned int v17 = (v14 & 0xFFFFFFF) >> v16;
    if ((0x8103uLL >> v2)) {
      char v18 = 27;
    }
    else {
      char v18 = 26;
    }
    unsigned int v19 = v15 >> v16;
    unsigned int v14 = v17 | (v14 << v18);
    unsigned int v20 = v19 | (v15 << v18);
    unsigned int v15 = v20 & 0xFFFFFFF;
    int v21 = des_skb[((v17 >> 7) & 0x3C | (v17 >> 6)) + 64] | des_skb[v17 & 0x3F] | des_skb[((v17 >> 14) & 0x30 | (v17 >> 13) & 0xF) + 128] | des_skb[((v17 >> 21) & 6 | (v17 >> 20) & 1 | (v14 >> 22) & 0x38) + 192];
    int v22 = des_skb[((v19 >> 8) & 0x3C | (v19 >> 7) & 3) + 320] | des_skb[(v19 & 0x3F) + 256] | des_skb[((v19 >> 15) & 0x3F) + 384] | des_skb[((v20 >> 22) & 0x30 | (v19 >> 21) & 0xF) + 448];
    HIDWORD(v24) = v22 << 16;
    LODWORD(v24) = v22 << 16;
    int v23 = v24 >> 30;
    HIDWORD(v24) = v22 & 0x3FF0000 | HIWORD(v21);
    LODWORD(v24) = v22;
    schedule->ks[0].deslong[0] = v23 | (4 * (unsigned __int16)v21);
    schedule->ks[0].deslong[1] = v24 >> 26;
    schedule = (DES_key_schedule *)((char *)schedule + 8);
    ++v2;
  }
  while (v2 != 16);
}

int BN_bn2bin(const BIGNUM *a, unsigned __int8 *to)
{
  return bn2binpad(a, (char *)to, 0xFFFFFFFFLL, 0);
}

uint64_t bn2binpad(const BIGNUM *a1, char *a2, uint64_t a3, int a4)
{
  int v8 = BN_num_bits(a1);
  int v9 = v8 + 7;
  if (v8 < -7) {
    int v9 = v8 + 14;
  }
  uint64_t v10 = (v9 >> 3);
  if (a3 == -1)
  {
    a3 = v10;
  }
  else if ((int)v10 > (int)a3)
  {
    BIGNUM v22 = *a1;
    bn_correct_top((uint64_t *)&v22);
    int v11 = BN_num_bits(&v22);
    int v12 = v11 + 7;
    if (v11 < -7) {
      int v12 = v11 + 14;
    }
    if ((int)a3 < v12 >> 3) {
      return 0xFFFFFFFFLL;
    }
  }
  uint64_t dmax = a1->dmax;
  if (!dmax) {
    explicit_bzero(a2, (int)a3);
  }
  if (a3)
  {
    uint64_t v14 = 0;
    uint64_t v15 = (int)a3;
    if (a4) {
      uint64_t v16 = 0;
    }
    else {
      uint64_t v16 = (int)a3;
    }
    unsigned int v17 = &a2[v16];
    uint64_t v18 = 8 * dmax;
    uint64_t v19 = -8 * a1->top;
    do
    {
      if (a4) {
        unsigned int v20 = v17;
      }
      else {
        unsigned int v20 = v17 - 1;
      }
      if (a4) {
        ++v17;
      }
      else {
        --v17;
      }
      char *v20 = (v19 >> 63) & (*(unint64_t *)((char *)a1->d + (v14 & 0xFFFFFFFFFFFFFFF8)) >> (8
                                                                                                  * (v14 & 7u)));
      v14 += (unint64_t)(v14 - v18 + 1) >> 63;
      ++v19;
      --v15;
    }
    while (v15);
  }
  return a3;
}

uint64_t BN_bn2binpad(const BIGNUM *a1, char *a2, uint64_t a3)
{
  if ((a3 & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  else {
    return bn2binpad(a1, a2, a3, 0);
  }
}

BIGNUM *__cdecl BN_bin2bn(const unsigned __int8 *s, int len, BIGNUM *ret)
{
  if (len < 0) {
    return 0;
  }
  unsigned int v3 = ret;
  int v4 = len;
  if (ret)
  {
    unsigned int v6 = 0;
  }
  else
  {
    unsigned int v6 = BN_new();
    unsigned int v3 = v6;
    if (!v6) {
      return v3;
    }
  }
  if (!v4)
  {
    v3->tounsigned int p = 0;
    return v3;
  }
  unsigned int v7 = ((v4 - 1) >> 3) + 1;
  if (!bn_wexpand((uint64_t)v3, v7))
  {
    BN_free(v6);
    return 0;
  }
  unint64_t v8 = 0;
  int v9 = ((_BYTE)v4 - 1) & 7;
  v3->tounsigned int p = v7;
  v3->neg = 0;
  do
  {
    unsigned int v10 = *s++;
    unint64_t v8 = v10 | (v8 << 8);
    if (v9)
    {
      --v9;
    }
    else
    {
      v3->d[--v7] = v8;
      int v9 = 7;
      unint64_t v8 = 0;
    }
    --v4;
  }
  while (v4);
  bn_correct_top((uint64_t *)v3);
  return v3;
}

uint64_t BN_bn2lebinpad(const BIGNUM *a1, char *a2, uint64_t a3)
{
  if ((a3 & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  else {
    return bn2binpad(a1, a2, a3, 1);
  }
}

uint64_t BN_lebin2bn(uint64_t a1, int a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v5 = a3;
    unsigned int v6 = 0;
  }
  else
  {
    unsigned int v6 = BN_new();
    uint64_t v5 = (uint64_t)v6;
    if (!v6) {
      return v5;
    }
  }
  uint64_t v7 = a1 + a2;
  if (a2 < 1)
  {
    if (!a2)
    {
LABEL_18:
      *(_DWORD *)(v5 + 8) = 0;
      return v5;
    }
  }
  else
  {
    uint64_t v8 = a1 + a2;
    while (!*(unsigned __int8 *)--v8)
    {
      uint64_t v7 = v8;
      BOOL v10 = __OFSUB__(a2--, 1);
      if ((a2 < 0) ^ v10 | (a2 == 0)) {
        goto LABEL_18;
      }
    }
  }
  unsigned int v11 = ((a2 - 1) >> 3) + 1;
  if (bn_wexpand(v5, v11))
  {
    unint64_t v12 = 0;
    *(_DWORD *)(v5 + 8) = v11;
    *(_DWORD *)(v5 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = 0;
    int v13 = ((_BYTE)a2 - 1) & 7;
    uint64_t v14 = (unsigned __int8 *)(v7 - 1);
    do
    {
      unsigned int v15 = *v14--;
      unint64_t v12 = v15 | (v12 << 8);
      if (v13)
      {
        --v13;
      }
      else
      {
        *(void *)(*(void *)v5 + 8 * --v11) = v12;
        int v13 = 7;
        unint64_t v12 = 0;
      }
      --a2;
    }
    while (a2);
    bn_correct_top((uint64_t *)v5);
  }
  else
  {
    BN_free(v6);
    return 0;
  }
  return v5;
}

uint64_t BN_asc2bn(BIGNUM **a, uint64_t a2)
{
  uint64_t v2 = (unsigned char *)a2;
  if (*(unsigned char *)a2 == 45) {
    ++a2;
  }
  if (*(unsigned char *)a2 == 48 && (*(unsigned __int8 *)(a2 + 1) | 0x20) == 0x78)
  {
    if (!BN_hex2bn(a, (const char *)(a2 + 2))) {
      return 0;
    }
  }
  else if (!BN_dec2bn(a, (const char *)a2))
  {
    return 0;
  }
  if (*v2 != 45) {
    return 1;
  }
  uint64_t v5 = *a;
  uint64_t v4 = 1;
  BN_set_negative(v5, 1);
  return v4;
}

int BN_hex2bn(BIGNUM **a, const char *str)
{
  if (!str) {
    return 0;
  }
  int v2 = *(unsigned __int8 *)str;
  if (*str)
  {
    unsigned int v4 = 0;
    uint64_t v5 = 0;
    unsigned int v6 = v2 == 45 ? str + 1 : str;
    BOOL v7 = v2 == 45;
    while ((*(_DWORD *)(MEMORY[0x263EF8318] + 4 * v6[v5] + 60) & 0x10000) != 0)
    {
      ++v5;
      v4 += 4;
      if (v5 == 0x20000000) {
        return 0;
      }
    }
    int v2 = v7 + v5;
    if (a)
    {
      int v9 = *a;
      if (*a)
      {
        BN_zero((uint64_t)*a);
      }
      else
      {
        int v9 = BN_new();
        if (!v9) {
          return 0;
        }
      }
      if (bn_expand((uint64_t)v9, v4))
      {
        if (v5)
        {
          uint64_t v10 = 0;
          unsigned int v11 = &v6[v5];
          uint64_t d = (uint64_t)v9->d;
          uint64_t v13 = ((v5 - 1) >> 4) + 1;
          do
          {
            uint64_t v14 = 0;
            if (v5 >= 16) {
              uint64_t v15 = 16;
            }
            else {
              uint64_t v15 = v5;
            }
            uint64_t v16 = v15 + 1;
            unsigned int v17 = &v11[-v15];
            do
            {
              int v19 = *v17++;
              int v18 = v19;
              unsigned int v20 = v19 - 48;
              unsigned int v21 = v19 - 97;
              int v22 = v19 - 55;
              if ((v19 - 65) >= 6) {
                int v23 = 0;
              }
              else {
                int v23 = v22;
              }
              LODWORD(v24) = v18 - 87;
              if (v21 > 5) {
                LODWORD(v24) = v23;
              }
              if (v20 <= 9) {
                uint64_t v24 = v20;
              }
              else {
                uint64_t v24 = v24;
              }
              uint64_t v14 = v24 | (16 * v14);
              --v16;
            }
            while (v16 > 1);
            *(void *)(d + 8 * v10) = v14;
            v11 -= 16;
            ++v10;
            v5 -= 16;
          }
          while (v10 != v13);
        }
        else
        {
          LODWORD(v13) = 0;
        }
        v9->tounsigned int p = v13;
        bn_correct_top((uint64_t *)v9);
        BN_set_negative(v9, v7);
        BUF_MEM *a = v9;
        return v2;
      }
      if (!*a) {
        BN_free(v9);
      }
      return 0;
    }
  }
  return v2;
}

int BN_dec2bn(BIGNUM **a, const char *str)
{
  if (!str) {
    return 0;
  }
  int v2 = *(unsigned __int8 *)str;
  if (*str)
  {
    unsigned int v4 = 0;
    unint64_t v5 = 0;
    unsigned int v6 = v2 == 45 ? str + 1 : str;
    BOOL v7 = v2 == 45;
    while (v6[v5] - 48 <= 9)
    {
      ++v5;
      v4 += 4;
      if (v5 == 0x20000000) {
        return 0;
      }
    }
    int v2 = v7 + v5;
    if (a)
    {
      int v9 = *a;
      if (*a)
      {
        BN_zero((uint64_t)*a);
      }
      else
      {
        int v9 = BN_new();
        if (!v9) {
          return 0;
        }
      }
      if (bn_expand((uint64_t)v9, v4))
      {
        char v10 = *v6;
        if (*v6)
        {
          unint64_t v11 = 0;
          int v12 = 19 * (v5 / 0x13) - v5 + 19;
          if (19 * (v5 / 0x13) == v5) {
            int v12 = 0;
          }
          uint64_t v13 = (unsigned __int8 *)(v6 + 1);
          do
          {
            unint64_t v11 = 10 * v11 + v10 - 48;
            if (++v12 == 19)
            {
              if (!BN_mul_word(v9, 0x8AC7230489E80000) || !BN_add_word(v9, v11)) {
                goto LABEL_26;
              }
              unint64_t v11 = 0;
              int v12 = 0;
            }
            int v14 = *v13++;
            char v10 = v14;
          }
          while (v14);
        }
        bn_correct_top((uint64_t *)v9);
        BN_set_negative(v9, v7);
        BUF_MEM *a = v9;
        return v2;
      }
LABEL_26:
      if (!*a) {
        BN_free(v9);
      }
      return 0;
    }
  }
  return v2;
}

char *__cdecl BN_bn2dec(const BIGNUM *a)
{
  unint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v13 = 0;
  uint64_t v12 = 0;
  unsigned __int8 v11 = 0;
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  if (CBB_init((uint64_t)v10, 0))
  {
    int v2 = BN_dup(a);
    unsigned int v3 = v2;
    if (v2)
    {
      if (BN_is_zero((uint64_t)v2))
      {
LABEL_4:
        if (CBB_finish((uint64_t *)v10, &v15, &v14)
          && v14 <= 0xFFFFFFFFFFFFFFFCLL
          && CBB_init((uint64_t)v10, v14 + 3)
          && (!BN_is_negative((uint64_t)a) || CBB_add_u8((char **)v10, 0x2DuLL)))
        {
          CBS_init(v9, (uint64_t)v15, v14);
          if (CBS_len((uint64_t)v9))
          {
            if (CBS_get_last_u8(v9, &v11))
            {
              LOBYTE(v4) = 1;
              do
              {
                int v4 = v4 & (v11 == 48);
                if (v4 == 1)
                {
                  if (!CBS_len((uint64_t)v9)) {
                    goto LABEL_27;
                  }
                }
                else
                {
                  if (!CBB_add_u8((char **)v10, v11)) {
                    break;
                  }
                  if (!CBS_len((uint64_t)v9)) {
                    goto LABEL_28;
                  }
                }
              }
              while (CBS_get_last_u8(v9, &v11));
            }
          }
          else
          {
LABEL_27:
            if (CBB_add_u8((char **)v10, 0x30uLL))
            {
LABEL_28:
              if (CBB_add_u8((char **)v10, 0)) {
                CBB_finish((uint64_t *)v10, &v13, &v12);
              }
            }
          }
        }
      }
      else
      {
LABEL_21:
        unint64_t v6 = BN_div_word(v3, 0x8AC7230489E80000);
        if (v6 != -1)
        {
          int v7 = 19;
          while (1)
          {
            unint64_t v8 = v6 / 0xA;
            if (!CBB_add_u8((char **)v10, (v6 % 0xA) | 0x30)) {
              break;
            }
            unint64_t v6 = v8;
            if (!--v7)
            {
              if (!BN_is_zero((uint64_t)v3)) {
                goto LABEL_21;
              }
              goto LABEL_4;
            }
          }
        }
      }
    }
  }
  else
  {
    unsigned int v3 = 0;
  }
  BN_free(v3);
  CBB_cleanup((uint64_t *)v10);
  freezero(v15, v14);
  return v13;
}

char *__cdecl BN_bn2hex(const BIGNUM *a)
{
  uint64_t v9 = 0;
  char v10 = 0;
  memset(v8, 0, sizeof(v8));
  if (CBB_init((uint64_t)v8, 0)
    && (!BN_is_negative((uint64_t)a) || CBB_add_u8((char **)v8, 0x2DuLL))
    && (!BN_is_zero((uint64_t)a) || CBB_add_u8((char **)v8, 0x30uLL)))
  {
    tounsigned int p = a->top;
    if ((int)top >= 1)
    {
      int v3 = 0;
      do
      {
        uint64_t v4 = top--;
        unint64_t v5 = a->d[top];
        for (uint64_t i = 56; i != -8; i -= 8)
        {
          if (v3 || (v5 >> i))
          {
            if (!CBB_add_u8((char **)v8, hex_digits[(unint64_t)(v5 >> i) >> 4])
              || !CBB_add_u8((char **)v8, hex_digits[(v5 >> i) & 0xF]))
            {
              goto LABEL_19;
            }
            int v3 = 1;
          }
          else
          {
            int v3 = 0;
          }
        }
      }
      while (v4 >= 2);
    }
    if (CBB_add_u8((char **)v8, 0)) {
      CBB_finish((uint64_t *)v8, &v10, &v9);
    }
  }
LABEL_19:
  CBB_cleanup((uint64_t *)v8);
  return v10;
}

int BN_bn2mpi(const BIGNUM *a, unsigned __int8 *to)
{
  int v4 = BN_num_bits(a);
  int v5 = v4 + 7;
  if (v4 < -7) {
    int v5 = v4 + 14;
  }
  int v6 = v5 >> 3;
  BOOL v8 = (v4 & 7) == 0 && v4 > 0;
  if (to)
  {
    *(_DWORD *)to = bswap32(v6 + v8);
    if (v8) {
      to[4] = 0;
    }
    int v6 = bn2binpad(a, (char *)&to[v8 | 4], 0xFFFFFFFFLL, 0);
    if (a->neg) {
      to[4] |= 0x80u;
    }
  }
  if (v8) {
    int v9 = 5;
  }
  else {
    int v9 = 4;
  }
  return v9 + v6;
}

BIGNUM *__cdecl BN_mpi2bn(const unsigned __int8 *s, int len, BIGNUM *ret)
{
  if (len <= 3)
  {
    int v3 = 106;
    int v4 = 580;
LABEL_11:
    ERR_put_error(3, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_convert.c", v4);
    return 0;
  }
  uint64_t v6 = bswap32(*(_DWORD *)s);
  if (v6 + 4 != len)
  {
    int v3 = 104;
    int v4 = 586;
    goto LABEL_11;
  }
  BOOL v8 = ret;
  if (ret || (BOOL v8 = BN_new()) != 0)
  {
    if (!v6)
    {
      v8->neg = 0;
      v8->tounsigned int p = 0;
      return v8;
    }
    unsigned int v9 = s[4];
    if (!BN_bin2bn(s + 4, v6, v8))
    {
      if (!ret) {
        BN_free(v8);
      }
      return 0;
    }
    BN_set_negative(v8, v9 >> 7);
    if ((v9 & 0x80) != 0)
    {
      int v10 = BN_num_bits(v8);
      BN_clear_bit(v8, v10 - 1);
    }
  }
  return v8;
}

int BN_print_fp(FILE *fp, const BIGNUM *a)
{
  int v4 = BIO_s_file();
  int v5 = BIO_new(v4);
  if (v5)
  {
    uint64_t v6 = v5;
    BIO_ctrl(v5, 106, 0, fp);
    int v7 = BN_print(v6, a);
    BIO_free(v6);
    LODWORD(v5) = v7;
  }
  return (int)v5;
}

int BN_print(BIO *fp, const BIGNUM *a)
{
  if (a->neg && BIO_write(fp, "-", 1) != 1 || BN_is_zero((uint64_t)a) && BIO_write(fp, "0", 1) != 1) {
    return 0;
  }
  tounsigned int p = a->top;
  if ((int)top < 1) {
    return 1;
  }
  int v5 = 0;
  do
  {
    uint64_t v6 = top--;
    for (uint64_t i = 60; i != -4; i -= 4)
    {
      unint64_t v8 = (a->d[top] >> i) & 0xF;
      if (v5 || v8)
      {
        int v5 = 1;
        if (BIO_write(fp, &hex_digits[v8], 1) != 1) {
          return 0;
        }
      }
      else
      {
        int v5 = 0;
      }
    }
    int result = 1;
  }
  while (v6 >= 2);
  return result;
}

uint64_t bn_isqrt(BIGNUM *a1, BOOL *a2, const BIGNUM *a3, BN_CTX *a4)
{
  if (!((unint64_t)a1 | (unint64_t)a2))
  {
    int v5 = 67;
    int v6 = 54;
LABEL_5:
    ERR_put_error(3, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_isqrt.c", v6);
    int v10 = 0;
LABEL_6:
    uint64_t v11 = 0;
    goto LABEL_7;
  }
  if (BN_is_negative((uint64_t)a3))
  {
    int v5 = 115;
    int v6 = 59;
    goto LABEL_5;
  }
  int v10 = a4;
  if (!a4)
  {
    int v10 = BN_CTX_new();
    if (!v10) {
      goto LABEL_6;
    }
  }
  BN_CTX_start(v10);
  uint64_t v13 = BN_CTX_get(v10);
  if (!v13) {
    goto LABEL_6;
  }
  unint64_t v14 = v13;
  uint64_t v15 = BN_CTX_get(v10);
  if (!v15) {
    goto LABEL_6;
  }
  uint64_t v16 = v15;
  if (BN_is_zero((uint64_t)a3))
  {
    BN_zero((uint64_t)v14);
    BOOL v17 = 1;
    if (a2) {
LABEL_16:
    }
      *a2 = v17;
  }
  else
  {
    if (!BN_one((uint64_t)v14)) {
      goto LABEL_6;
    }
    int v18 = BN_num_bits(a3);
    int v19 = v18 >= 1 ? v18 - 1 : v18;
    if (!BN_set_word(v16, (uint64_t)v19 >> 1)) {
      goto LABEL_6;
    }
    int v20 = v19 >> 1;
    int v21 = BN_num_bits(v16);
    int v22 = 0;
    while (1)
    {
      BOOL v23 = __OFSUB__(v21--, 1);
      if (v21 < 0 != v23) {
        break;
      }
      if (BN_rshift(v16, a3, ((2 * v20) | 1) - v22 - (v20 >> v21)))
      {
        if (BN_div_ct((uint64_t)v16, 0, v16, v14, v10))
        {
          if (BN_lshift(v14, v14, (v20 >> v21) + ~v22))
          {
            int v22 = v20 >> v21;
            if (BN_add(v14, v14, v16)) {
              continue;
            }
          }
        }
      }
      goto LABEL_6;
    }
    if (!BN_sqr(v16, v14, v10)) {
      goto LABEL_6;
    }
    int v24 = BN_cmp(v16, a3);
    if (v24 >= 1 && !BN_sub_word(v14, 1uLL)) {
      goto LABEL_6;
    }
    BOOL v17 = v24 == 0;
    if (a2) {
      goto LABEL_16;
    }
  }
  if (a1 && !bn_copy(a1, v14)) {
    goto LABEL_6;
  }
  uint64_t v11 = 1;
LABEL_7:
  BN_CTX_end(v10);
  if (v10 != a4) {
    BN_CTX_free(v10);
  }
  return v11;
}

uint64_t bn_is_perfect_square(BOOL *a1, const BIGNUM *a2, BN_CTX *a3)
{
  *a1 = 0;
  if (BN_is_negative((uint64_t)a2)) {
    return 1;
  }
  if (a2->top) {
    uint64_t v6 = *a2->d & 0x3F;
  }
  else {
    LOBYTE(v6) = 0;
  }
  if ((0xFDFDFDEDFDFCFDECLL >> v6)) {
    return 1;
  }
  unint64_t v7 = BN_mod_word(a2, 0xAFF5uLL);
  if (v7 == -1) {
    return 0;
  }
  if (((0x7BFDB7CFEDBAFD6CuLL >> (v7 % 0x3F)) & 1) != 0
    || !is_square_mod_65[v7 % 0x41]
    || ((0x5C4uLL >> (v7 % 0xB)) & 1) != 0)
  {
    return 1;
  }
  return bn_isqrt(0, a1, a2, a3);
}

uint64_t ERR_load_CMS_strings()
{
  if (!ERR_func_error_string(CMS_str_functs))
  {
    ERR_load_strings(46, (ERR_STRING_DATA *)&CMS_str_functs);
    ERR_load_strings(46, (ERR_STRING_DATA *)&CMS_str_reasons);
  }
  return 1;
}

int SHA1_Update(SHA_CTX *c, const void *data, size_t len)
{
  if (len)
  {
    size_t v3 = len;
    int v4 = (unsigned int *)data;
    *(void *)&c->Nl += 8 * len;
    uint64_t num = c->num;
    if (num)
    {
      unint64_t v7 = c->data;
      unint64_t v8 = (char *)c->data + num;
      if (len <= 0x3F && num + len < 0x40)
      {
        memcpy(v8, data, len);
        c->num += v3;
        return 1;
      }
      uint64_t v9 = 64 - num;
      memcpy(v8, data, 64 - num);
      sha1_block_data_order((int *)c, c->data, 1);
      int v4 = (unsigned int *)((char *)v4 + v9);
      v3 -= v9;
      c->uint64_t num = 0;
      *(_OWORD *)unint64_t v7 = 0u;
      *(_OWORD *)&c->char data[4] = 0u;
      *(_OWORD *)&c->data[8] = 0u;
      *(_OWORD *)&c->data[12] = 0u;
    }
    if (v3 >= 0x40)
    {
      sha1_block_data_order((int *)c, v4, v3 >> 6);
      int v4 = (unsigned int *)((char *)v4 + (v3 & 0xFFFFFFFFFFFFFFC0));
      v3 &= 0x3Fu;
    }
    if (v3)
    {
      c->uint64_t num = v3;
      memcpy(c->data, v4, v3);
    }
  }
  return 1;
}

uint64_t sha1_block_data_order(int *a1, unsigned int *a2, uint64_t a3)
{
  int v3 = a1[3];
  int v4 = a1[4];
  int v5 = a1[1];
  int v6 = a1[2];
  int v7 = *a1;
  do
  {
    int v550 = v3;
    int v551 = v5;
    int v549 = v6;
    int v545 = v7;
    int v546 = v4;
    unint64_t v547 = a2;
    uint64_t v548 = a3;
    HIDWORD(v9) = v7;
    LODWORD(v9) = v7;
    int v8 = v9 >> 27;
    int v10 = v3 & ~v5;
    unsigned int v11 = bswap32(*a2);
    int v12 = v6 & v5;
    HIDWORD(v9) = v5;
    LODWORD(v9) = v5;
    int v13 = v9 >> 2;
    int v14 = v12 | v10;
    int v15 = v7;
    int v16 = v7 & __ROR4__(v5, 2);
    unsigned int v17 = bswap32(a2[1]);
    unsigned int v18 = v4 + 1518500249 + v8 + v14 + v11;
    HIDWORD(v9) = v18;
    LODWORD(v9) = v18;
    int v19 = v9 >> 27;
    HIDWORD(v9) = v15;
    LODWORD(v9) = v15;
    int v20 = v9 >> 2;
    int v21 = v18 & __ROR4__(v15, 2);
    unsigned int v22 = v550 + 1518500249 + (v16 | v549 & ~v15) + v17 + v19;
    HIDWORD(v9) = v22;
    LODWORD(v9) = v22;
    int v23 = v9 >> 27;
    HIDWORD(v9) = v18;
    LODWORD(v9) = v18;
    int v24 = v9 >> 2;
    unsigned int v25 = bswap32(a2[2]);
    unsigned int v26 = bswap32(a2[3]);
    unint64_t v28 = __PAIR64__(v22, __ROR4__(v18, 2));
    int v27 = v22 & v28;
    LODWORD(v28) = v22;
    int v29 = v28 >> 2;
    unsigned int v30 = v549 + 1518500249 + v25 + (v21 | v13 & ~v18) + v23;
    HIDWORD(v28) = v30;
    LODWORD(v28) = v30;
    int v31 = v28 >> 27;
    unint64_t v33 = __PAIR64__(v30, __ROR4__(v22, 2));
    int v32 = v30 & v33;
    unsigned int v542 = bswap32(a2[4]);
    LODWORD(v33) = v30;
    int v34 = v33 >> 2;
    unsigned int v35 = v13 + 1518500249 + v26 + (v27 | v20 & ~v22) + v31;
    HIDWORD(v33) = v35;
    LODWORD(v33) = v35;
    unsigned int v36 = v20 + 1518500249 + v542 + (v32 | v24 & ~v30) + (v33 >> 27);
    HIDWORD(v33) = v36;
    LODWORD(v33) = v36;
    int v37 = v33 >> 27;
    unint64_t v39 = __PAIR64__(v35, __ROR4__(v30, 2));
    int v38 = v35 & v39;
    LODWORD(v39) = v35;
    int v40 = v39 >> 2;
    unint64_t v42 = __PAIR64__(v36, __ROR4__(v35, 2));
    int v41 = v36 & v42;
    unsigned int v43 = bswap32(a2[5]);
    int v44 = v38 | v29 & ~v35;
    LODWORD(v42) = v36;
    int v45 = v42 >> 2;
    int v46 = v24 + 1518500249 + v43 + v44 + v37;
    HIDWORD(v42) = v46;
    LODWORD(v42) = v46;
    int v47 = v42 >> 27;
    unsigned int v532 = bswap32(a2[6]);
    HIDWORD(v42) = v46;
    LODWORD(v42) = v46;
    int v48 = v42 >> 2;
    unsigned int v49 = v29 + 1518500249 + v532 + (v41 | v34 & ~v36) + v47;
    HIDWORD(v42) = v49;
    LODWORD(v42) = v49;
    int v50 = v42 >> 27;
    unint64_t v51 = __PAIR64__(v49, __ROR4__(v36, 2));
    unsigned int v538 = bswap32(a2[7]);
    int v52 = v46 & v51 | v40 & ~v46;
    LODWORD(v51) = v49;
    int v53 = v51 >> 2;
    unsigned int v54 = v34 + 1518500249 + v538 + v52 + v50;
    HIDWORD(v51) = v54;
    LODWORD(v51) = v54;
    int v55 = v51 >> 27;
    unint64_t v57 = __PAIR64__(v54, __ROR4__(v49, 2));
    int v56 = v54 & v57;
    LODWORD(v57) = v54;
    int v58 = v57 >> 2;
    unsigned int v526 = bswap32(a2[8]);
    unsigned int v59 = v40 + 1518500249 + v526 + (v49 & __ROR4__(v46, 2) | v45 & ~v49) + v55;
    unsigned int v60 = bswap32(a2[13]);
    HIDWORD(v57) = v59;
    LODWORD(v57) = v59;
    int v61 = v57 >> 27;
    HIDWORD(v57) = v25 ^ v11 ^ v526 ^ v60;
    LODWORD(v57) = HIDWORD(v57);
    int v62 = v57 >> 31;
    int v63 = HIDWORD(v57);
    int v520 = HIDWORD(v57);
    unint64_t v65 = __PAIR64__(v59, __ROR4__(v54, 2));
    int v64 = v59 & v65;
    unsigned int v66 = bswap32(a2[9]);
    int v67 = v56 | v48 & ~v54;
    LODWORD(v65) = v59;
    int v68 = v65 >> 2;
    int v69 = v45 + 1518500249 + v66 + v67 + v61;
    HIDWORD(v65) = v69;
    LODWORD(v65) = v69;
    int v70 = v65 >> 27;
    unsigned int v71 = bswap32(a2[10]);
    HIDWORD(v65) = v69;
    LODWORD(v65) = v69;
    int v72 = v65 >> 2;
    unsigned int v73 = v48 + 1518500249 + v71 + (v64 | v53 & ~v59) + v70;
    HIDWORD(v65) = v73;
    LODWORD(v65) = v73;
    int v74 = v65 >> 27;
    unint64_t v75 = __PAIR64__(v73, __ROR4__(v59, 2));
    unsigned int v76 = bswap32(a2[11]);
    int v77 = v69 & v75 | v58 & ~v69;
    LODWORD(v75) = v73;
    int v78 = v75 >> 2;
    unsigned int v79 = v53 + 1518500249 + v76 + v77 + v74;
    HIDWORD(v75) = v79;
    LODWORD(v75) = v79;
    int v80 = v75 >> 27;
    unint64_t v81 = __PAIR64__(v79, __ROR4__(v69, 2));
    int v82 = v73 & v81 | v68 & ~v73;
    LODWORD(v81) = v79;
    int v83 = v81 >> 2;
    unsigned int v521 = bswap32(a2[12]);
    unsigned int v84 = v58 + 1518500249 + v521 + v82 + v80;
    HIDWORD(v81) = v84;
    LODWORD(v81) = v84;
    int v85 = v81 >> 27;
    int v86 = v79 & __ROR4__(v73, 2);
    unsigned int v87 = a2[15];
    unsigned int v88 = bswap32(a2[14]);
    int v89 = v72 & ~v79;
    unint64_t v91 = __PAIR64__(v84, __ROR4__(v79, 2));
    int v90 = v84 & v91;
    unsigned int v92 = v60;
    int v93 = v68 + 1518500249 + v60 + (v86 | v89);
    LODWORD(v91) = v84;
    int v94 = v91 >> 2;
    int v95 = v93 + v85;
    int v96 = v26 ^ v17 ^ v66 ^ v88;
    HIDWORD(v91) = v95;
    LODWORD(v91) = v95;
    int v97 = v91 >> 27;
    HIDWORD(v91) = v96;
    LODWORD(v91) = v96;
    int v529 = v91 >> 31;
    HIDWORD(v91) = v95;
    LODWORD(v91) = v95;
    int v98 = v91 >> 2;
    int v99 = v72 + 1518500249 + v88 + (v90 | v78 & ~v84) + v97;
    HIDWORD(v91) = v99;
    LODWORD(v91) = v99;
    int v100 = v91 >> 27;
    unsigned int v101 = bswap32(v87);
    int v102 = v542 ^ v25 ^ v71 ^ v101;
    unint64_t v104 = __PAIR64__(v102, __ROR4__(v95, 2));
    int v103 = v99 & v104;
    LODWORD(v104) = v102;
    int v524 = v104 >> 31;
    int v105 = v95 & __ROR4__(v84, 2) | v83 & ~v95;
    HIDWORD(v104) = v99;
    LODWORD(v104) = v99;
    int v106 = v104 >> 2;
    unsigned int v107 = v78 + 1518500249 + v101 + v105 + v100;
    HIDWORD(v104) = v107;
    LODWORD(v104) = v107;
    int v108 = v104 >> 27;
    unint64_t v110 = __PAIR64__(v107, __ROR4__(v99, 2));
    int v109 = v107 & v110;
    LODWORD(v110) = v107;
    int v111 = v110 >> 2;
    unsigned int v112 = v83 + v62 + 1518500249 + (v103 | v94 & ~v99) + v108;
    HIDWORD(v110) = v112;
    LODWORD(v110) = v112;
    int v113 = v110 >> 27;
    LODWORD(v110) = v43 ^ v26 ^ v76 ^ __ROR4__(v63, 31);
    int v114 = v110;
    HIDWORD(v110) = v110;
    int v115 = v110 >> 31;
    int v116 = v112 & __ROR4__(v107, 2);
    unint64_t v118 = __PAIR64__(v112, __ROR4__(v96, 31));
    int v117 = v532 ^ v542 ^ v521 ^ v118;
    LODWORD(v118) = v112;
    int v119 = v118 >> 2;
    unsigned int v120 = v94 + v529 + 1518500249 + (v109 | v98 & ~v107) + v113;
    HIDWORD(v118) = v120;
    LODWORD(v118) = v120;
    int v121 = v118 >> 27;
    HIDWORD(v118) = v117;
    LODWORD(v118) = v117;
    int v535 = v118 >> 31;
    unsigned int v122 = v92;
    int v123 = v538 ^ v43 ^ v92 ^ __ROR4__(v102, 31);
    unint64_t v125 = __PAIR64__(v120, __ROR4__(v112, 2));
    int v124 = v120 & v125;
    LODWORD(v125) = v120;
    int v126 = v125 >> 2;
    int v127 = v98 + v524 + 1518500249 + (v116 | v106 & ~v112) + v121;
    int v128 = v124 | v111 & ~v120;
    HIDWORD(v125) = v127;
    LODWORD(v125) = v127;
    int v129 = v125 >> 27;
    HIDWORD(v125) = v123;
    LODWORD(v125) = v123;
    int v522 = v125 >> 31;
    int v130 = v115 + 1518500249 + v106;
    HIDWORD(v125) = v127;
    LODWORD(v125) = v127;
    int v131 = v125 >> 2;
    int v132 = v130 + v128 + v129;
    HIDWORD(v125) = v132;
    LODWORD(v125) = v132;
    int v133 = v125 >> 27;
    HIDWORD(v125) = v132;
    LODWORD(v125) = v132;
    int v134 = v125 >> 2;
    int v136 = v535 + 1859775393 + v111 + (v126 ^ __ROR4__(v112, 2) ^ v127);
    LODWORD(v125) = v526 ^ v532 ^ v88 ^ __ROR4__(v114, 31);
    int v135 = v125;
    HIDWORD(v125) = v125;
    int v137 = v125 >> 31;
    int v138 = v134 ^ __ROR4__(v127, 2);
    unsigned int v139 = v136 + v133;
    HIDWORD(v125) = v139;
    LODWORD(v125) = v139;
    int v140 = v125 >> 27;
    unint64_t v142 = __PAIR64__(v139, __ROR4__(v117, 31));
    int v141 = v66 ^ v538 ^ v101 ^ v142;
    LODWORD(v142) = v139;
    int v143 = v142 >> 2;
    unsigned int v144 = v522 + 1859775393 + v119 + (v131 ^ __ROR4__(v120, 2) ^ v132) + v140;
    HIDWORD(v142) = v141;
    LODWORD(v142) = v141;
    int v539 = v142 >> 31;
    unint64_t v146 = __PAIR64__(v144, __ROR4__(v132, 2));
    int v145 = v143 ^ v146;
    int v147 = v137 + 1859775393 + v126 + (v138 ^ v139);
    int v148 = v539 + 1859775393 + v131;
    LODWORD(v146) = v144;
    int v149 = v146 >> 27;
    HIDWORD(v146) = v144;
    LODWORD(v146) = v144;
    int v150 = v146 >> 2;
    unsigned int v152 = v147 + v149;
    LODWORD(v146) = v71 ^ v526 ^ __ROR4__(v520, 31) ^ __ROR4__(v123, 31);
    int v151 = v146;
    HIDWORD(v146) = v146;
    int v153 = v146 >> 31;
    int v154 = v148 + (v145 ^ v144);
    HIDWORD(v146) = v152;
    LODWORD(v146) = v152;
    int v155 = v146 >> 27;
    unint64_t v157 = __PAIR64__(v152, __ROR4__(v139, 2));
    int v156 = v150 ^ v157;
    unsigned int v158 = v154 + v155;
    int v159 = v153 + 1859775393 + v134;
    LODWORD(v157) = v152;
    int v160 = v157 >> 2;
    unint64_t v162 = __PAIR64__(v158, __ROR4__(v96, 31));
    int v161 = v76 ^ v66 ^ v162;
    LODWORD(v162) = v158;
    int v163 = v159 + (v156 ^ v152) + (v162 >> 27);
    LODWORD(v162) = v161 ^ __ROR4__(v135, 31);
    int v164 = v162;
    HIDWORD(v162) = v162;
    int v165 = v162 >> 31;
    unint64_t v166 = __PAIR64__(v158, __ROR4__(v144, 2));
    int v167 = v160 ^ v166 ^ v158;
    int v168 = v165 + 1859775393 + v143;
    LODWORD(v166) = v158;
    int v169 = v166 >> 2;
    LODWORD(v166) = v521 ^ v71 ^ __ROR4__(v102, 31) ^ __ROR4__(v141, 31);
    int v170 = v166;
    HIDWORD(v166) = v166;
    int v543 = v166 >> 31;
    HIDWORD(v166) = v163;
    LODWORD(v166) = v163;
    unsigned int v171 = v168 + v167 + (v166 >> 27);
    unint64_t v173 = __PAIR64__(v171, __ROR4__(v152, 2));
    int v172 = v169 ^ v173;
    LODWORD(v173) = v171;
    unsigned int v174 = v122;
    unsigned int v176 = v543 + 1859775393 + v150 + (v172 ^ v163) + (v173 >> 27);
    LODWORD(v173) = v122 ^ v76 ^ __ROR4__(v114, 31) ^ __ROR4__(v151, 31);
    int v175 = v173;
    HIDWORD(v173) = v173;
    int v177 = v173 >> 31;
    HIDWORD(v173) = v163;
    LODWORD(v173) = v163;
    int v178 = v173 >> 2;
    unint64_t v179 = __PAIR64__(v176, __ROR4__(v158, 2));
    int v180 = v177 + 1859775393 + v160 + (v178 ^ v179 ^ v171);
    LODWORD(v179) = v176;
    unsigned int v181 = v180 + (v179 >> 27);
    LODWORD(v179) = v88 ^ v521 ^ __ROR4__(v117, 31) ^ __ROR4__(v164, 31);
    int v182 = v179;
    HIDWORD(v179) = v179;
    int v183 = (v179 >> 31) + 1859775393 + v169;
    HIDWORD(v179) = v171;
    LODWORD(v179) = v171;
    int v184 = v179 >> 2;
    unint64_t v185 = __PAIR64__(v181, __ROR4__(v163, 2));
    int v186 = v183 + (v184 ^ v185 ^ v176);
    LODWORD(v185) = v181;
    int v187 = v101 ^ v174 ^ __ROR4__(v123, 31) ^ __ROR4__(v170, 31);
    unsigned int v188 = v186 + (v185 >> 27);
    HIDWORD(v185) = v187;
    LODWORD(v185) = v187;
    int v533 = v185 >> 31;
    int v189 = v533 + 1859775393 + v178;
    HIDWORD(v185) = v176;
    LODWORD(v185) = v176;
    int v190 = v185 >> 2;
    unint64_t v191 = __PAIR64__(v188, __ROR4__(v171, 2));
    int v192 = v189 + (v190 ^ v191 ^ v181);
    LODWORD(v191) = v188;
    unsigned int v193 = v192 + (v191 >> 27);
    int v194 = v88 ^ __ROR4__(v520, 31) ^ __ROR4__(v135, 31) ^ __ROR4__(v175, 31);
    HIDWORD(v191) = v194;
    LODWORD(v191) = v194;
    int v195 = v191 >> 31;
    HIDWORD(v191) = v181;
    LODWORD(v191) = v181;
    int v196 = v191 >> 2;
    int v197 = v195 + 1859775393 + v184 + (v196 ^ __ROR4__(v176, 2) ^ v188);
    unint64_t v199 = __PAIR64__(v193, __ROR4__(v96, 31));
    int v198 = v101 ^ v199;
    LODWORD(v199) = v193;
    int v200 = v198 ^ __ROR4__(v141, 31) ^ __ROR4__(v182, 31);
    unsigned int v201 = v197 + (v199 >> 27);
    HIDWORD(v199) = v200;
    LODWORD(v199) = v200;
    int v202 = (v199 >> 31) + 1859775393 + v190;
    HIDWORD(v199) = v188;
    LODWORD(v199) = v188;
    int v203 = v199 >> 2;
    unint64_t v204 = __PAIR64__(v201, __ROR4__(v181, 2));
    int v205 = v202 + (v203 ^ v204 ^ v193);
    LODWORD(v204) = v201;
    unsigned int v206 = v205 + (v204 >> 27);
    LODWORD(v204) = v524 ^ __ROR4__(v520, 31) ^ __ROR4__(v151, 31) ^ __ROR4__(v187, 31);
    int v207 = v204;
    HIDWORD(v204) = v204;
    int v527 = v204 >> 31;
    HIDWORD(v204) = v193;
    LODWORD(v204) = v193;
    int v208 = v204 >> 2;
    unint64_t v209 = __PAIR64__(v206, __ROR4__(v188, 2));
    int v210 = v527 + 1859775393 + v196 + (v208 ^ v209 ^ v201);
    LODWORD(v209) = v206;
    int v211 = v529 ^ __ROR4__(v114, 31) ^ __ROR4__(v164, 31) ^ __ROR4__(v194, 31);
    unsigned int v212 = v210 + (v209 >> 27);
    HIDWORD(v209) = v211;
    LODWORD(v209) = v211;
    int v213 = v209 >> 31;
    HIDWORD(v209) = v201;
    LODWORD(v209) = v201;
    int v214 = v209 >> 2;
    unint64_t v215 = __PAIR64__(v212, __ROR4__(v193, 2));
    int v216 = v213 + 1859775393 + v203 + (v214 ^ v215 ^ v206);
    LODWORD(v215) = v212;
    unsigned int v217 = v216 + (v215 >> 27);
    LODWORD(v215) = v524 ^ __ROR4__(v117, 31) ^ __ROR4__(v170, 31) ^ __ROR4__(v200, 31);
    int v218 = v215;
    HIDWORD(v215) = v215;
    int v219 = (v215 >> 31) + 1859775393 + v208;
    HIDWORD(v215) = v206;
    LODWORD(v215) = v206;
    int v220 = v215 >> 2;
    unint64_t v221 = __PAIR64__(v217, __ROR4__(v201, 2));
    int v222 = v219 + (v220 ^ v221 ^ v212);
    LODWORD(v221) = v217;
    int v223 = v522 ^ __ROR4__(v114, 31) ^ __ROR4__(v175, 31) ^ __ROR4__(v207, 31);
    unsigned int v224 = v222 + (v221 >> 27);
    HIDWORD(v221) = v223;
    LODWORD(v221) = v223;
    int v530 = v221 >> 31;
    int v225 = v530 + 1859775393 + v214;
    HIDWORD(v221) = v212;
    LODWORD(v221) = v212;
    int v226 = v221 >> 2;
    unint64_t v227 = __PAIR64__(v224, __ROR4__(v206, 2));
    int v228 = v225 + (v226 ^ v227 ^ v217);
    LODWORD(v227) = v224;
    unsigned int v229 = v228 + (v227 >> 27);
    int v230 = v535 ^ __ROR4__(v135, 31) ^ __ROR4__(v182, 31) ^ __ROR4__(v211, 31);
    HIDWORD(v227) = v230;
    LODWORD(v227) = v230;
    int v525 = v227 >> 31;
    int v231 = v525 + 1859775393 + v220;
    HIDWORD(v227) = v217;
    LODWORD(v227) = v217;
    int v232 = v227 >> 2;
    unint64_t v234 = __PAIR64__(v229, __ROR4__(v141, 31));
    int v233 = v522 ^ v234;
    LODWORD(v234) = v229;
    unsigned int v236 = v231 + (v232 ^ __ROR4__(v212, 2) ^ v224) + (v234 >> 27);
    LODWORD(v234) = v233 ^ __ROR4__(v187, 31) ^ __ROR4__(v218, 31);
    int v235 = v234;
    HIDWORD(v234) = v234;
    int v237 = (v234 >> 31) + 1859775393 + v226;
    HIDWORD(v234) = v224;
    LODWORD(v234) = v224;
    int v238 = v234 >> 2;
    unint64_t v239 = __PAIR64__(v236, __ROR4__(v217, 2));
    int v240 = v237 + (v238 ^ v239 ^ v229);
    LODWORD(v239) = v236;
    unsigned int v241 = v240 + (v239 >> 27);
    LODWORD(v239) = v153 ^ __ROR4__(v135, 31) ^ __ROR4__(v194, 31) ^ __ROR4__(v223, 31);
    int v242 = v239;
    HIDWORD(v239) = v239;
    int v536 = v239 >> 31;
    HIDWORD(v239) = v229;
    LODWORD(v239) = v229;
    int v243 = v239 >> 2;
    unint64_t v244 = __PAIR64__(v241, __ROR4__(v224, 2));
    int v245 = v536 + 1859775393 + v232 + (v243 ^ v244 ^ v236);
    LODWORD(v244) = v241;
    int v246 = v539 ^ __ROR4__(v164, 31) ^ __ROR4__(v200, 31) ^ __ROR4__(v230, 31);
    unsigned int v247 = v245 + (v244 >> 27);
    HIDWORD(v244) = v246;
    LODWORD(v244) = v246;
    int v248 = v244 >> 31;
    int v249 = v248 + 1859775393 + v238;
    HIDWORD(v244) = v236;
    LODWORD(v244) = v236;
    int v250 = v244 >> 2;
    unint64_t v251 = __PAIR64__(v247, __ROR4__(v229, 2));
    int v252 = v249 + (v250 ^ v251 ^ v241);
    LODWORD(v251) = v247;
    unsigned int v253 = v252 + (v251 >> 27);
    int v254 = v153 ^ __ROR4__(v170, 31) ^ __ROR4__(v207, 31) ^ __ROR4__(v235, 31);
    unint64_t v255 = __PAIR64__(v254, __ROR4__(v241, 2));
    int v256 = (v247 | __ROR4__(v241, 2)) & __ROR4__(v236, 2) | v247 & v255;
    LODWORD(v255) = v254;
    int v257 = (v255 >> 31) - 1894007588;
    HIDWORD(v255) = v241;
    LODWORD(v255) = v241;
    int v258 = v255 >> 2;
    unint64_t v260 = __PAIR64__(v253, __ROR4__(v211, 31));
    int v259 = v177 ^ __ROR4__(v164, 31) ^ v260;
    LODWORD(v260) = v253;
    int v261 = v260 >> 27;
    int v262 = v259 ^ __ROR4__(v242, 31);
    unint64_t v264 = __PAIR64__(v262, __ROR4__(v241, 2));
    int v263 = (v253 | __ROR4__(v247, 2)) & v264;
    LODWORD(v264) = v262;
    int v540 = v264 >> 31;
    unsigned int v265 = v257 + v243 + v256 + v261;
    unint64_t v266 = __PAIR64__(v265, __ROR4__(v247, 2));
    int v267 = v263 | v253 & v266;
    LODWORD(v266) = v265;
    int v268 = v540 - 1894007588 + v250 + v267;
    int v269 = v543 ^ __ROR4__(v182, 31) ^ __ROR4__(v218, 31) ^ __ROR4__(v246, 31);
    int v270 = v268 + (v266 >> 27);
    unint64_t v271 = __PAIR64__(v269, __ROR4__(v247, 2));
    int v272 = (v265 | __ROR4__(v253, 2)) & v271 | v265 & __ROR4__(v253, 2);
    LODWORD(v271) = v269;
    int v273 = v271 >> 31;
    HIDWORD(v271) = v247;
    LODWORD(v271) = v247;
    int v274 = v271 >> 2;
    HIDWORD(v271) = v270;
    LODWORD(v271) = v270;
    int v275 = v273 - 1894007588 + v258 + v272 + (v271 >> 27);
    int v276 = v177 ^ __ROR4__(v187, 31) ^ __ROR4__(v223, 31) ^ __ROR4__(v254, 31);
    unint64_t v277 = __PAIR64__(v276, __ROR4__(v253, 2));
    int v278 = (v270 | __ROR4__(v265, 2)) & v277 | v270 & __ROR4__(v265, 2);
    LODWORD(v277) = v276;
    int v279 = v277 >> 31;
    HIDWORD(v277) = v253;
    LODWORD(v277) = v253;
    int v280 = v277 >> 2;
    int v281 = v279 - 1894007588 + v274;
    HIDWORD(v277) = v275;
    LODWORD(v277) = v275;
    int v282 = v277 >> 27;
    LODWORD(v277) = v195 ^ __ROR4__(v182, 31) ^ __ROR4__(v230, 31) ^ __ROR4__(v262, 31);
    int v283 = v277;
    HIDWORD(v277) = v277;
    int v544 = v277 >> 31;
    int v284 = v281 + v278 + v282;
    unint64_t v285 = __PAIR64__(v265, __ROR4__(v265, 2));
    int v286 = (v275 | __ROR4__(v270, 2)) & v285 | v275 & __ROR4__(v270, 2);
    LODWORD(v285) = v265;
    int v287 = v285 >> 2;
    HIDWORD(v285) = v284;
    LODWORD(v285) = v284;
    int v288 = v544 - 1894007588 + v280 + v286 + (v285 >> 27);
    int v289 = v533 ^ __ROR4__(v200, 31) ^ __ROR4__(v235, 31) ^ __ROR4__(v269, 31);
    unint64_t v290 = __PAIR64__(v289, __ROR4__(v270, 2));
    int v291 = (v284 | __ROR4__(v275, 2)) & v290 | v284 & __ROR4__(v275, 2);
    LODWORD(v290) = v289;
    int v292 = v290 >> 31;
    HIDWORD(v290) = v270;
    LODWORD(v290) = v270;
    int v293 = v290 >> 2;
    HIDWORD(v290) = v288;
    LODWORD(v290) = v288;
    unsigned int v294 = v292 - 1894007588 + v287 + v291 + (v290 >> 27);
    HIDWORD(v290) = v275;
    LODWORD(v290) = v275;
    int v295 = v290 >> 2;
    int v296 = v195 ^ __ROR4__(v207, 31) ^ __ROR4__(v242, 31) ^ __ROR4__(v276, 31);
    unint64_t v297 = __PAIR64__(v296, __ROR4__(v284, 2));
    int v298 = (v288 | __ROR4__(v284, 2)) & __ROR4__(v275, 2) | v288 & v297;
    LODWORD(v297) = v296;
    int v299 = (v297 >> 31) - 1894007588;
    HIDWORD(v297) = v284;
    LODWORD(v297) = v284;
    int v300 = v297 >> 2;
    int v301 = v299 + v293;
    unint64_t v303 = __PAIR64__(v294, __ROR4__(v246, 31));
    int v302 = v213 ^ __ROR4__(v200, 31) ^ v303;
    LODWORD(v303) = v294;
    int v304 = v303 >> 27;
    int v305 = v302 ^ __ROR4__(v283, 31);
    unint64_t v307 = __PAIR64__(v305, __ROR4__(v284, 2));
    int v306 = (v294 | __ROR4__(v288, 2)) & v307;
    LODWORD(v307) = v305;
    int v534 = v307 >> 31;
    unsigned int v308 = v301 + v298 + v304;
    unint64_t v309 = __PAIR64__(v308, __ROR4__(v288, 2));
    int v310 = v306 | v294 & v309;
    LODWORD(v309) = v308;
    int v311 = v527 ^ __ROR4__(v218, 31) ^ __ROR4__(v254, 31) ^ __ROR4__(v289, 31);
    int v312 = v534 - 1894007588 + v295 + v310 + (v309 >> 27);
    unint64_t v313 = __PAIR64__(v311, __ROR4__(v288, 2));
    int v314 = (v308 | __ROR4__(v294, 2)) & v313 | v308 & __ROR4__(v294, 2);
    LODWORD(v313) = v311;
    int v315 = v313 >> 31;
    HIDWORD(v313) = v288;
    LODWORD(v313) = v288;
    int v316 = v313 >> 2;
    HIDWORD(v313) = v312;
    LODWORD(v313) = v312;
    int v317 = v315 - 1894007588 + v300 + v314 + (v313 >> 27);
    int v318 = v213 ^ __ROR4__(v223, 31) ^ __ROR4__(v262, 31) ^ __ROR4__(v296, 31);
    unint64_t v319 = __PAIR64__(v318, __ROR4__(v294, 2));
    int v320 = (v312 | __ROR4__(v308, 2)) & v319 | v312 & __ROR4__(v308, 2);
    LODWORD(v319) = v318;
    int v321 = v319 >> 31;
    HIDWORD(v319) = v294;
    LODWORD(v319) = v294;
    int v322 = v319 >> 2;
    int v323 = v321 - 1894007588 + v316;
    HIDWORD(v319) = v317;
    LODWORD(v319) = v317;
    int v324 = v319 >> 27;
    int v325 = v323 + v320;
    LODWORD(v319) = v525 ^ __ROR4__(v218, 31) ^ __ROR4__(v269, 31) ^ __ROR4__(v305, 31);
    int v326 = v319;
    HIDWORD(v319) = v319;
    int v528 = v319 >> 31;
    int v327 = v325 + v324;
    unint64_t v328 = __PAIR64__(v308, __ROR4__(v308, 2));
    int v329 = (v317 | __ROR4__(v312, 2)) & v328 | v317 & __ROR4__(v312, 2);
    LODWORD(v328) = v308;
    int v330 = v328 >> 2;
    HIDWORD(v328) = v327;
    LODWORD(v328) = v327;
    int v331 = v528 - 1894007588 + v322 + v329 + (v328 >> 27);
    int v332 = v530 ^ __ROR4__(v235, 31) ^ __ROR4__(v276, 31) ^ __ROR4__(v311, 31);
    unint64_t v333 = __PAIR64__(v332, __ROR4__(v312, 2));
    int v334 = (v327 | __ROR4__(v317, 2)) & v333 | v327 & __ROR4__(v317, 2);
    LODWORD(v333) = v332;
    int v523 = v333 >> 31;
    HIDWORD(v333) = v312;
    LODWORD(v333) = v312;
    int v335 = v333 >> 2;
    HIDWORD(v333) = v331;
    LODWORD(v333) = v331;
    unsigned int v336 = v523 - 1894007588 + v330 + v334 + (v333 >> 27);
    HIDWORD(v333) = v317;
    LODWORD(v333) = v317;
    int v337 = v333 >> 2;
    int v338 = v525 ^ __ROR4__(v242, 31) ^ __ROR4__(v283, 31) ^ __ROR4__(v318, 31);
    unint64_t v339 = __PAIR64__(v338, __ROR4__(v327, 2));
    int v340 = (v331 | __ROR4__(v327, 2)) & __ROR4__(v317, 2) | v331 & v339;
    LODWORD(v339) = v338;
    int v341 = (v339 >> 31) - 1894007588;
    HIDWORD(v339) = v327;
    LODWORD(v339) = v327;
    int v342 = v339 >> 2;
    int v343 = v341 + v335;
    unint64_t v345 = __PAIR64__(v336, __ROR4__(v289, 31));
    int v344 = v248 ^ __ROR4__(v235, 31) ^ v345;
    LODWORD(v345) = v336;
    int v346 = v345 >> 27;
    int v347 = v343 + v340;
    int v348 = v344 ^ __ROR4__(v326, 31);
    unint64_t v350 = __PAIR64__(v348, __ROR4__(v327, 2));
    int v349 = (v336 | __ROR4__(v331, 2)) & v350;
    LODWORD(v350) = v348;
    int v531 = v350 >> 31;
    unsigned int v351 = v347 + v346;
    unint64_t v352 = __PAIR64__(v351, __ROR4__(v331, 2));
    int v353 = v349 | v336 & v352;
    LODWORD(v352) = v351;
    int v354 = v531 - 1894007588 + v337 + v353;
    int v355 = v536 ^ __ROR4__(v254, 31) ^ __ROR4__(v296, 31) ^ __ROR4__(v332, 31);
    int v356 = v354 + (v352 >> 27);
    unint64_t v357 = __PAIR64__(v355, __ROR4__(v331, 2));
    int v358 = (v351 | __ROR4__(v336, 2)) & v357 | v351 & __ROR4__(v336, 2);
    LODWORD(v357) = v355;
    int v359 = v357 >> 31;
    HIDWORD(v357) = v331;
    LODWORD(v357) = v331;
    int v360 = v357 >> 2;
    HIDWORD(v357) = v356;
    LODWORD(v357) = v356;
    int v361 = v359 - 1894007588 + v342 + v358 + (v357 >> 27);
    int v362 = v248 ^ __ROR4__(v262, 31) ^ __ROR4__(v305, 31) ^ __ROR4__(v338, 31);
    unint64_t v363 = __PAIR64__(v362, __ROR4__(v336, 2));
    int v364 = (v356 | __ROR4__(v351, 2)) & v363 | v356 & __ROR4__(v351, 2);
    LODWORD(v363) = v362;
    int v365 = v363 >> 31;
    HIDWORD(v363) = v336;
    LODWORD(v363) = v336;
    int v366 = v363 >> 2;
    int v367 = v365 - 1894007588 + v360;
    HIDWORD(v363) = v361;
    LODWORD(v363) = v361;
    int v368 = v363 >> 27;
    LODWORD(v363) = v273 ^ __ROR4__(v254, 31) ^ __ROR4__(v311, 31) ^ __ROR4__(v348, 31);
    int v369 = v363;
    HIDWORD(v363) = v363;
    int v537 = v363 >> 31;
    int v370 = v367 + v364 + v368;
    unint64_t v371 = __PAIR64__(v351, __ROR4__(v351, 2));
    int v372 = (v361 | __ROR4__(v356, 2)) & v371 | v361 & __ROR4__(v356, 2);
    LODWORD(v371) = v351;
    int v373 = v371 >> 2;
    HIDWORD(v371) = v370;
    LODWORD(v371) = v370;
    int v374 = v537 - 1894007588 + v366 + v372 + (v371 >> 27);
    int v375 = v540 ^ __ROR4__(v276, 31) ^ __ROR4__(v318, 31) ^ __ROR4__(v355, 31);
    unint64_t v376 = __PAIR64__(v375, __ROR4__(v356, 2));
    int v377 = (v370 | __ROR4__(v361, 2)) & v376 | v370 & __ROR4__(v361, 2);
    LODWORD(v376) = v375;
    int v541 = v376 >> 31;
    HIDWORD(v376) = v356;
    LODWORD(v376) = v356;
    int v378 = v376 >> 2;
    HIDWORD(v376) = v374;
    LODWORD(v376) = v374;
    unsigned int v379 = v541 - 1894007588 + v373 + v377 + (v376 >> 27);
    HIDWORD(v376) = v361;
    LODWORD(v376) = v361;
    int v380 = v376 >> 2;
    int v381 = v273 ^ __ROR4__(v283, 31) ^ __ROR4__(v326, 31) ^ __ROR4__(v362, 31);
    unint64_t v382 = __PAIR64__(v381, __ROR4__(v370, 2));
    int v383 = (v374 | __ROR4__(v370, 2)) & __ROR4__(v361, 2) | v374 & v382;
    LODWORD(v382) = v381;
    int v384 = (v382 >> 31) - 1894007588;
    HIDWORD(v382) = v370;
    LODWORD(v382) = v370;
    int v385 = v382 >> 2;
    unint64_t v387 = __PAIR64__(v379, __ROR4__(v332, 31));
    int v386 = v292 ^ __ROR4__(v276, 31) ^ v387;
    LODWORD(v387) = v379;
    int v388 = v387 >> 27;
    int v389 = v384 + v378 + v383;
    int v390 = v386 ^ __ROR4__(v369, 31);
    unint64_t v392 = __PAIR64__(v390, __ROR4__(v370, 2));
    int v391 = (v379 | __ROR4__(v374, 2)) & v392;
    LODWORD(v392) = v390;
    int v393 = v392 >> 31;
    int v394 = v389 + v388;
    int v395 = v393 - 1894007588 + v380 + (v391 | v379 & __ROR4__(v374, 2));
    int v396 = v544 ^ __ROR4__(v296, 31) ^ __ROR4__(v338, 31) ^ __ROR4__(v375, 31);
    HIDWORD(v392) = v396;
    LODWORD(v392) = v396;
    int v397 = v392 >> 31;
    HIDWORD(v392) = v394;
    LODWORD(v392) = v394;
    unsigned int v398 = v395 + (v392 >> 27);
    HIDWORD(v392) = v379;
    LODWORD(v392) = v379;
    int v399 = v392 >> 2;
    unint64_t v401 = __PAIR64__(v398, __ROR4__(v305, 31));
    int v400 = v292 ^ v401;
    LODWORD(v401) = v398;
    unsigned int v402 = v397 - 899497514 + v385 + (v399 ^ __ROR4__(v374, 2) ^ v394) + (v401 >> 27);
    int v403 = v400 ^ __ROR4__(v348, 31) ^ __ROR4__(v381, 31);
    HIDWORD(v401) = v403;
    LODWORD(v401) = v403;
    int v404 = v401 >> 31;
    HIDWORD(v401) = v374;
    LODWORD(v401) = v374;
    int v405 = v404 - 899497514 + (v401 >> 2);
    HIDWORD(v401) = v394;
    LODWORD(v401) = v394;
    int v406 = v401 >> 2;
    unint64_t v407 = __PAIR64__(v402, __ROR4__(v379, 2));
    int v408 = v405 + (v406 ^ v407 ^ v398);
    LODWORD(v407) = v402;
    unsigned int v409 = v408 + (v407 >> 27);
    LODWORD(v407) = v315 ^ __ROR4__(v296, 31) ^ __ROR4__(v355, 31) ^ __ROR4__(v390, 31);
    int v410 = v407;
    HIDWORD(v407) = v407;
    int v411 = v407 >> 31;
    HIDWORD(v407) = v398;
    LODWORD(v407) = v398;
    int v412 = v407 >> 2;
    unint64_t v413 = __PAIR64__(v409, __ROR4__(v394, 2));
    int v414 = v411 - 899497514 + v399 + (v412 ^ v413 ^ v402);
    LODWORD(v413) = v409;
    unsigned int v415 = v414 + (v413 >> 27);
    int v416 = v534 ^ __ROR4__(v318, 31) ^ __ROR4__(v362, 31) ^ __ROR4__(v396, 31);
    HIDWORD(v413) = v416;
    LODWORD(v413) = v416;
    unsigned int v417 = v413 >> 31;
    HIDWORD(v413) = v402;
    LODWORD(v413) = v402;
    int v418 = v413 >> 2;
    unint64_t v420 = __PAIR64__(v415, __ROR4__(v326, 31));
    int v419 = v315 ^ v420;
    LODWORD(v420) = v415;
    unsigned int v421 = v417 - 899497514 + v406 + (v418 ^ __ROR4__(v398, 2) ^ v409) + (v420 >> 27);
    int v422 = v419 ^ __ROR4__(v369, 31) ^ __ROR4__(v403, 31);
    HIDWORD(v420) = v422;
    LODWORD(v420) = v422;
    int v423 = (v420 >> 31) - 899497514;
    HIDWORD(v420) = v409;
    LODWORD(v420) = v409;
    int v424 = v420 >> 2;
    unint64_t v425 = __PAIR64__(v421, __ROR4__(v402, 2));
    int v426 = v423 + v412 + (v424 ^ v425 ^ v415);
    LODWORD(v425) = v421;
    int v427 = v425 >> 27;
    unint64_t v429 = __PAIR64__(v415, __ROR4__(v375, 31));
    int v428 = v523 ^ __ROR4__(v318, 31) ^ v429;
    LODWORD(v429) = v415;
    int v430 = v429 >> 2;
    int v432 = v426 + v427;
    LODWORD(v429) = v428 ^ __ROR4__(v410, 31);
    int v431 = v429;
    HIDWORD(v429) = v429;
    int v433 = (v429 >> 31) - 899497514 + v418;
    HIDWORD(v429) = v432;
    LODWORD(v429) = v432;
    unsigned int v434 = v433 + (v430 ^ __ROR4__(v409, 2) ^ v421) + (v429 >> 27);
    LODWORD(v429) = v528 ^ __ROR4__(v338, 31) ^ __ROR4__(v381, 31) ^ __ROR4__(v416, 31);
    int v435 = v429;
    HIDWORD(v429) = v429;
    int v436 = (v429 >> 31) - 899497514;
    HIDWORD(v429) = v421;
    LODWORD(v429) = v421;
    int v437 = v429 >> 2;
    unint64_t v438 = __PAIR64__(v434, __ROR4__(v415, 2));
    int v439 = v436 + v424 + (v437 ^ v438 ^ v432);
    LODWORD(v438) = v434;
    unsigned int v440 = v439 + (v438 >> 27);
    int v441 = v523 ^ __ROR4__(v348, 31) ^ __ROR4__(v390, 31) ^ __ROR4__(v422, 31);
    HIDWORD(v438) = v441;
    LODWORD(v438) = v441;
    int v442 = (v438 >> 31) - 899497514 + v430;
    HIDWORD(v438) = v432;
    LODWORD(v438) = v432;
    int v443 = v438 >> 2;
    unint64_t v444 = __PAIR64__(v440, __ROR4__(v421, 2));
    int v445 = v442 + (v443 ^ v444 ^ v434);
    LODWORD(v444) = v440;
    unsigned int v446 = v445 + (v444 >> 27);
    int v447 = v359 ^ __ROR4__(v338, 31) ^ __ROR4__(v396, 31) ^ __ROR4__(v431, 31);
    HIDWORD(v444) = v447;
    LODWORD(v444) = v447;
    int v448 = (v444 >> 31) - 899497514;
    HIDWORD(v444) = v434;
    LODWORD(v444) = v434;
    int v449 = v444 >> 2;
    unint64_t v450 = __PAIR64__(v446, __ROR4__(v432, 2));
    int v451 = v448 + v437 + (v449 ^ v450 ^ v440);
    LODWORD(v450) = v446;
    unsigned int v452 = v451 + (v450 >> 27);
    LODWORD(v450) = v531 ^ __ROR4__(v362, 31) ^ __ROR4__(v403, 31) ^ __ROR4__(v435, 31);
    int v453 = v450;
    HIDWORD(v450) = v450;
    int v454 = (v450 >> 31) - 899497514 + v443;
    HIDWORD(v450) = v440;
    LODWORD(v450) = v440;
    int v455 = v450 >> 2;
    unint64_t v456 = __PAIR64__(v452, __ROR4__(v434, 2));
    int v457 = v454 + (v455 ^ v456 ^ v446);
    LODWORD(v456) = v452;
    unsigned int v458 = v457 + (v456 >> 27);
    LODWORD(v456) = v359 ^ __ROR4__(v369, 31) ^ __ROR4__(v410, 31) ^ __ROR4__(v441, 31);
    int v459 = v456;
    HIDWORD(v456) = v456;
    int v460 = (v456 >> 31) - 899497514;
    HIDWORD(v456) = v446;
    LODWORD(v456) = v446;
    int v461 = v456 >> 2;
    unint64_t v462 = __PAIR64__(v458, __ROR4__(v440, 2));
    int v463 = v460 + v449 + (v461 ^ v462 ^ v452);
    LODWORD(v462) = v458;
    int v464 = v462 >> 27;
    unint64_t v466 = __PAIR64__(v452, __ROR4__(v416, 31));
    int v465 = v541 ^ __ROR4__(v362, 31) ^ v466;
    LODWORD(v466) = v452;
    int v467 = v466 >> 2;
    int v468 = v465 ^ __ROR4__(v447, 31);
    int v469 = v463 + v464;
    HIDWORD(v466) = v468;
    LODWORD(v466) = v468;
    int v470 = (v466 >> 31) - 899497514 + v455;
    HIDWORD(v466) = v469;
    LODWORD(v466) = v469;
    int v471 = v381;
    unsigned int v472 = v470 + (v467 ^ __ROR4__(v446, 2) ^ v458) + (v466 >> 27);
    int v473 = v537 ^ __ROR4__(v381, 31) ^ __ROR4__(v422, 31) ^ __ROR4__(v453, 31);
    HIDWORD(v466) = v473;
    LODWORD(v466) = v473;
    int v474 = (v466 >> 31) - 899497514;
    HIDWORD(v466) = v458;
    LODWORD(v466) = v458;
    int v475 = v466 >> 2;
    unint64_t v476 = __PAIR64__(v472, __ROR4__(v452, 2));
    int v477 = v474 + v461 + (v475 ^ v476 ^ v469);
    LODWORD(v476) = v472;
    unsigned int v478 = v477 + (v476 >> 27);
    int v479 = v541 ^ __ROR4__(v390, 31) ^ __ROR4__(v431, 31) ^ __ROR4__(v459, 31);
    HIDWORD(v476) = v479;
    LODWORD(v476) = v479;
    int v480 = (v476 >> 31) - 899497514 + v467;
    HIDWORD(v476) = v469;
    LODWORD(v476) = v469;
    int v481 = v476 >> 2;
    unint64_t v482 = __PAIR64__(v478, __ROR4__(v458, 2));
    int v483 = v480 + (v481 ^ v482 ^ v472);
    LODWORD(v482) = v478;
    int v484 = v397 ^ __ROR4__(v471, 31) ^ __ROR4__(v435, 31);
    unsigned int v485 = v483 + (v482 >> 27);
    int v486 = v484 ^ __ROR4__(v468, 31);
    HIDWORD(v482) = v486;
    LODWORD(v482) = v486;
    int v487 = (v482 >> 31) - 899497514;
    HIDWORD(v482) = v472;
    LODWORD(v482) = v472;
    int v488 = v482 >> 2;
    unint64_t v489 = __PAIR64__(v485, __ROR4__(v469, 2));
    int v490 = v487 + v475 + (v488 ^ v489 ^ v478);
    LODWORD(v489) = v485;
    unsigned int v491 = v490 + (v489 >> 27);
    int v492 = v393 ^ __ROR4__(v403, 31) ^ __ROR4__(v441, 31) ^ __ROR4__(v473, 31);
    HIDWORD(v489) = v492;
    LODWORD(v489) = v492;
    int v493 = (v489 >> 31) - 899497514 + v481;
    HIDWORD(v489) = v478;
    LODWORD(v489) = v478;
    int v494 = v489 >> 2;
    unint64_t v496 = __PAIR64__(v491, __ROR4__(v447, 31));
    int v495 = v397 ^ __ROR4__(v410, 31) ^ v496;
    LODWORD(v496) = v491;
    unsigned int v497 = v493 + (v494 ^ __ROR4__(v472, 2) ^ v485) + (v496 >> 27);
    int v498 = v495 ^ __ROR4__(v479, 31);
    HIDWORD(v496) = v498;
    LODWORD(v496) = v498;
    int v499 = (v496 >> 31) - 899497514;
    HIDWORD(v496) = v485;
    LODWORD(v496) = v485;
    int v500 = v496 >> 2;
    unint64_t v501 = __PAIR64__(v497, __ROR4__(v478, 2));
    int v502 = v499 + v488 + (v500 ^ v501 ^ v491);
    LODWORD(v501) = v497;
    unsigned int v503 = v502 + (v501 >> 27);
    uint64_t result = v417 ^ __ROR4__(v403, 31);
    LODWORD(v501) = result ^ __ROR4__(v453, 31) ^ __ROR4__(v486, 31);
    HIDWORD(v501) = v501;
    int v505 = (v501 >> 31) - 899497514 + v494;
    HIDWORD(v501) = v491;
    LODWORD(v501) = v491;
    int v506 = v501 >> 2;
    unint64_t v508 = __PAIR64__(v503, __ROR4__(v459, 31));
    int v507 = v411 ^ __ROR4__(v422, 31) ^ v508;
    LODWORD(v508) = v503;
    unsigned int v509 = v505 + (v506 ^ __ROR4__(v485, 2) ^ v497) + (v508 >> 27);
    LODWORD(v508) = v507 ^ __ROR4__(v492, 31);
    HIDWORD(v508) = v508;
    int v510 = (v508 >> 31) - 899497514;
    HIDWORD(v508) = v497;
    LODWORD(v508) = v497;
    int v511 = v508 >> 2;
    unint64_t v512 = __PAIR64__(v509, __ROR4__(v491, 2));
    int v513 = v510 + v500 + (v511 ^ v512 ^ v503);
    LODWORD(v512) = v509;
    unsigned int v514 = v513 + (v512 >> 27);
    LODWORD(v512) = v417 ^ __ROR4__(v431, 31) ^ __ROR4__(v468, 31) ^ __ROR4__(v498, 31);
    HIDWORD(v512) = v512;
    int v515 = v545 - 899497514 + (v512 >> 31) + v506;
    HIDWORD(v512) = v503;
    LODWORD(v512) = v503;
    int v516 = v512 >> 2;
    unint64_t v517 = __PAIR64__(v514, __ROR4__(v497, 2));
    int v518 = v515 + (v516 ^ v517 ^ v509);
    LODWORD(v517) = v514;
    int v7 = v518 + (v517 >> 27);
    HIDWORD(v517) = v509;
    LODWORD(v517) = v509;
    int v6 = (v517 >> 2) + v549;
    int v5 = v514 + v551;
    int v4 = v511 + v546;
    int v3 = v516 + v550;
    *a1 = v7;
    a1[1] = v514 + v551;
    a1[2] = v6;
    a1[3] = v516 + v550;
    a1[4] = v4;
    a2 = v547 + 16;
    a3 = v548 - 1;
  }
  while (v548 != 1);
  return result;
}

void SHA1_Transform(SHA_CTX *c, const unsigned __int8 *data)
{
}

int SHA1_Final(unsigned __int8 *md, SHA_CTX *c)
{
  unsigned int data = c->data;
  uint64_t num = c->num;
  *((unsigned char *)c->data + num) = 0x80;
  uint64_t v6 = num + 1;
  if (num >= 0x38)
  {
    bzero((char *)data + v6, 63 - num);
    sha1_block_data_order((int *)c, data, 1);
    uint64_t v6 = 0;
  }
  bzero((char *)data + v6, 56 - v6);
  unsigned int v7 = bswap32(c->Nl);
  c->data[14] = bswap32(c->Nh);
  c->data[15] = v7;
  sha1_block_data_order((int *)c, data, 1);
  c->uint64_t num = 0;
  *(_OWORD *)unsigned int data = 0u;
  *((_OWORD *)data + 1) = 0u;
  *((_OWORD *)data + 2) = 0u;
  *((_OWORD *)data + 3) = 0u;
  *(_DWORD *)muint64_t d = bswap32(c->h0);
  *((_DWORD *)md + 1) = bswap32(c->h1);
  *((_DWORD *)md + 2) = bswap32(c->h2);
  *((_DWORD *)md + 3) = bswap32(c->h3);
  *((_DWORD *)md + 4) = bswap32(c->h4);
  return 1;
}

int SHA1_Init(SHA_CTX *c)
{
  *(_OWORD *)&c->data[9] = 0u;
  *(_OWORD *)&c->data[13] = 0u;
  *(_OWORD *)&c->data[1] = 0u;
  *(_OWORD *)&c->data[5] = 0u;
  *(_OWORD *)&c->h0 = xmmword_23C70F740;
  *(_OWORD *)&c->h4 = 0u;
  c->h4 = -1009589776;
  return 1;
}

unsigned __int8 *__cdecl SHA1(const unsigned __int8 *d, size_t n, unsigned __int8 *md)
{
  if (md) {
    int v3 = md;
  }
  else {
    int v3 = (unsigned __int8 *)&SHA1_m;
  }
  memset(&v5.Nl, 0, 76);
  *(_OWORD *)&v5.h0 = xmmword_23C70F740;
  v5.h4 = -1009589776;
  SHA1_Update(&v5, d, n);
  SHA1_Final(v3, &v5);
  explicit_bzero(&v5, 0x60uLL);
}

void *ASN1_PCTX_new()
{
  int v0 = malloc_type_calloc(1uLL, 0x28uLL, 0x10000400A747E1EuLL);
  if (!v0) {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_prn.c", 85);
  }
  return v0;
}

uint64_t ASN1_PCTX_get_flags(uint64_t a1)
{
  return *(void *)a1;
}

void *ASN1_PCTX_set_flags(void *result, uint64_t a2)
{
  *uint64_t result = a2;
  return result;
}

uint64_t ASN1_PCTX_get_nm_flags(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t ASN1_PCTX_set_nm_flags(uint64_t result, uint64_t a2)
{
  *(void *)(result + 8) = a2;
  return result;
}

uint64_t ASN1_PCTX_get_cert_flags(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t ASN1_PCTX_set_cert_flags(uint64_t result, uint64_t a2)
{
  *(void *)(result + ++*(_DWORD *)(*(void *)(result + 8) + 16) = a2;
  return result;
}

uint64_t ASN1_PCTX_get_oid_flags(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t ASN1_PCTX_set_oid_flags(uint64_t result, uint64_t a2)
{
  *(void *)(result + 24) = a2;
  return result;
}

uint64_t ASN1_PCTX_get_str_flags(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t ASN1_PCTX_set_str_flags(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32) = a2;
  return result;
}

uint64_t ASN1_item_print(BIO *a1, ASN1_VALUE *a2, uint64_t a3, ASN1_ITEM *a4, uint64_t *a5)
{
  punint64_t val = a2;
  if (a5) {
    SHA_CTX v5 = a5;
  }
  else {
    SHA_CTX v5 = (uint64_t *)&default_pctx;
  }
  if (*((unsigned char *)v5 + 1)) {
    sname = 0;
  }
  else {
    sname = a4->sname;
  }
  return asn1_item_print_ctx(a1, (const STACK **)&pval, a3, a4, 0, sname, 0, v5);
}

uint64_t asn1_item_print_ctx(BIO *b, const STACK **pval, uint64_t a3, ASN1_ITEM *it, const char *a5, const char *a6, int a7, uint64_t *a8)
{
  p_unsigned int data = (ASN1_OBJECT **)pval;
  funcunsigned int s = it->funcs;
  unint64_t v39 = 0;
  uint64_t v40 = 0;
  int v41 = 0;
  if (funcs)
  {
    int v16 = (uint64_t (*)(uint64_t, ASN1_OBJECT **, ASN1_ITEM *, BIO **))funcs[3];
    if (v16)
    {
      unint64_t v39 = b;
      LODWORD(v40) = a3;
      int v41 = a8;
    }
  }
  else
  {
    int v16 = 0;
  }
  if (!it->itype && it->utype == 1)
  {
LABEL_21:
    templateunsigned int s = (int *)it->templates;
    if (templates)
    {
      uint64_t result = asn1_template_print_ctx(b, pval, a3, templates, a8);
      if (!result) {
        return result;
      }
    }
LABEL_23:
    uint64_t result = asn1_print_fsname(b, a3, a5, a6, a8);
    if (!result) {
      return result;
    }
    unsigned int v22 = it->funcs;
    if (v22)
    {
      int v23 = (uint64_t (*)(BIO *, ASN1_OBJECT **, ASN1_ITEM *, uint64_t, uint64_t *))v22[7];
      if (v23)
      {
        uint64_t result = v23(b, p_data, it, a3, a8);
        if (!result) {
          return result;
        }
        return 1;
      }
      return 0;
    }
    if (it->itype == 5)
    {
      unint64_t v28 = (ASN1_STRING *)*p_data;
      unint64_t utype = SHIDWORD((*p_data)->sn) & 0xFFFFFFFFFFFFFEFFLL;
    }
    else
    {
      unint64_t utype = it->utype;
      if (utype == 1)
      {
        unint64_t v28 = 0;
      }
      else
      {
        unint64_t v28 = (ASN1_STRING *)*p_data;
        if (utype == -4)
        {
          int length = v28->length;
          unint64_t utype = v28->length;
          p_unsigned int data = (ASN1_OBJECT **)&v28->data;
          unint64_t v28 = (ASN1_STRING *)v28->data;
          if ((*(unsigned char *)a8 & 0x10) != 0)
          {
LABEL_67:
            unsigned int v35 = 0;
            goto LABEL_70;
          }
LABEL_69:
          unsigned int v35 = ASN1_tag2str(length);
LABEL_70:
          if (utype == 5)
          {
            uint64_t result = BIO_puts(b, "NULL\n") > 0;
            if (!result) {
              return result;
            }
            return 1;
          }
          if (!v35 || BIO_puts(b, v35) >= 1 && BIO_puts(b, ":") >= 1)
          {
            switch(utype)
            {
              case 1uLL:
                int size = *(_DWORD *)p_data;
                if (*(_DWORD *)p_data == -1) {
                  int size = it->size;
                }
                int v37 = "TRUE";
                if (!size) {
                  int v37 = "FALSE";
                }
                if (size == -1) {
                  int v38 = "BOOL ABSENT";
                }
                else {
                  int v38 = v37;
                }
                uint64_t result = BIO_puts(b, v38) > 0;
                goto LABEL_97;
              case 2uLL:
              case 0xAuLL:
                uint64_t result = asn1_print_integer_ctx(b, v28);
                goto LABEL_97;
              case 3uLL:
              case 4uLL:
                uint64_t result = asn1_print_obstring_ctx(b, (uint64_t)v28, a3);
                if (result) {
                  return 1;
                }
                return result;
              case 5uLL:
              case 7uLL:
              case 8uLL:
              case 9uLL:
              case 0xBuLL:
              case 0xCuLL:
              case 0xDuLL:
              case 0xEuLL:
              case 0xFuLL:
              case 0x12uLL:
              case 0x13uLL:
              case 0x14uLL:
              case 0x15uLL:
              case 0x16uLL:
                goto LABEL_85;
              case 6uLL:
                uint64_t result = asn1_print_oid_ctx(b, *p_data);
                goto LABEL_97;
              case 0x10uLL:
              case 0x11uLL:
                goto LABEL_81;
              case 0x17uLL:
                uint64_t result = ASN1_UTCTIME_print(b, v28);
                goto LABEL_97;
              case 0x18uLL:
                uint64_t result = ASN1_GENERALIZEDTIME_print(b, v28);
                goto LABEL_97;
              default:
                if (utype == -3)
                {
LABEL_81:
                  if (BIO_puts(b, "\n") < 1) {
                    return 0;
                  }
                  int v20 = ASN1_parse_dump(b, v28->data, v28->length, a3, 0);
                  return v20 >= 1;
                }
LABEL_85:
                uint64_t result = ASN1_STRING_print_ex(b, v28, a8[4]);
LABEL_97:
                if (!result) {
                  return result;
                }
                break;
            }
LABEL_98:
            int v19 = "\n";
LABEL_18:
            int v20 = BIO_puts(b, v19);
            return v20 >= 1;
          }
          return 0;
        }
      }
    }
    if ((*(unsigned char *)a8 & 8) == 0) {
      goto LABEL_67;
    }
    int length = utype;
    goto LABEL_69;
  }
  if (!*pval)
  {
    if ((*(unsigned char *)a8 & 1) == 0) {
      return 1;
    }
    if (!a7)
    {
      uint64_t result = asn1_print_fsname(b, a3, a5, a6, a8);
      if (!result) {
        return result;
      }
    }
    int v19 = "<ABSENT>\n";
    goto LABEL_18;
  }
  switch(it->itype)
  {
    case 0:
      goto LABEL_21;
    case 1:
    case 6:
      if (!a7)
      {
        uint64_t result = asn1_print_fsname(b, a3, a5, a6, a8);
        if (!result) {
          return result;
        }
      }
      if ((unint64_t)a5 | (unint64_t)a6)
      {
        unsigned int v18 = (*(unsigned char *)a8 & 2) != 0 ? " {\n" : "\n";
        if (BIO_puts(b, v18) < 1) {
          return 0;
        }
      }
      if (!v16) {
        goto LABEL_53;
      }
      uint64_t result = v16(8, p_data, it, &v39);
      if (!result) {
        return result;
      }
      if (result == 2) {
        return 1;
      }
LABEL_53:
      if (it->tcount < 1) {
        goto LABEL_58;
      }
      uint64_t v30 = 0;
      int v31 = it->templates;
      break;
    case 2:
      unsigned int choice_selector = asn1_get_choice_selector((ASN1_VALUE **)pval, it);
      if ((choice_selector & 0x80000000) != 0 || it->tcount <= choice_selector) {
        return BIO_printf(b, "ERROR: selector [%d] invalid\n", choice_selector) > 0;
      }
      unsigned int v25 = (ASN1_TEMPLATE *)&it->templates[choice_selector];
      field_ptr = asn1_get_field_ptr((ASN1_VALUE **)p_data, v25);
      uint64_t result = asn1_template_print_ctx(b, (const STACK **)field_ptr, a3, (int *)v25, a8);
      if (result) {
        return 1;
      }
      return result;
    case 4:
      if (a7) {
        goto LABEL_36;
      }
      uint64_t result = asn1_print_fsname(b, a3, a5, a6, a8);
      if (!result) {
        return result;
      }
      funcunsigned int s = it->funcs;
LABEL_36:
      if (!funcs
        || (int v27 = (uint64_t (*)(BIO *, ASN1_OBJECT **, uint64_t, const char *, uint64_t *))funcs[6]) == 0)
      {
        if (!a6) {
          return 1;
        }
        int v20 = BIO_printf(b, ":EXTERNAL TYPE %s\n", a6);
        return v20 >= 1;
      }
      uint64_t result = v27(b, p_data, a3, "", a8);
      if (!result) {
        return result;
      }
      if (result == 2) {
        goto LABEL_98;
      }
      return 1;
    case 5:
      goto LABEL_23;
    default:
      BIO_printf(b, "Unprocessed type %d\n", it->itype);
      return 0;
  }
  while (1)
  {
    uint64_t result = (uint64_t)asn1_do_adb((ASN1_VALUE **)p_data, v31, 1);
    if (!result) {
      break;
    }
    int v32 = (int *)result;
    unint64_t v33 = asn1_get_field_ptr((ASN1_VALUE **)p_data, (const ASN1_TEMPLATE *)result);
    uint64_t result = asn1_template_print_ctx(b, (const STACK **)v33, (int)a3 + 2, v32, a8);
    if (!result) {
      break;
    }
    ++v30;
    ++v31;
    if (it->tcount <= v30)
    {
LABEL_58:
      if ((*(unsigned char *)a8 & 2) != 0 && BIO_printf(b, "%*s}\n", a3, "") < 0) {
        return 0;
      }
      if (!v16) {
        return 1;
      }
      uint64_t result = v16(9, p_data, it, &v39);
      if (result) {
        return 1;
      }
      return result;
    }
  }
  return result;
}

uint64_t asn1_template_print_ctx(BIO *b, const STACK **pval, int a3, int *a4, uint64_t *a5)
{
  uint64_t v10 = *a5;
  int v11 = *a4;
  if ((*a5 & 0x40) != 0)
  {
    if ((v11 & 6) != 0)
    {
      pvala = 0;
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v12 = *((void *)a4 + 3);
    if ((v11 & 6) != 0)
    {
      pvala = 0;
      if (v12)
      {
        int v13 = (v10 & 4) != 0 ? BIO_printf(b, "%*s%s OF %s {\n") : BIO_printf(b, "%*s%s:\n");
        if (v13 < 1) {
          return 0;
        }
      }
LABEL_13:
      int v16 = *pval;
      if (sk_num(*pval) < 1)
      {
        if (BIO_printf(b, "%*s<EMPTY>\n", a3 + 2, "") >= 1)
        {
LABEL_21:
          if ((*(unsigned char *)a5 & 2) == 0 || BIO_printf(b, "%*s}\n", a3, "") >= 1) {
            return 1;
          }
        }
      }
      else
      {
        int v17 = 0;
        while (!v17 || BIO_puts(b, "\n") >= 1)
        {
          pvala = (ASN1_VALUE *)sk_value(v16, v17);
          uint64_t result = asn1_item_print_ctx(b, &pvala, a3 + 2, *((ASN1_ITEM **)a4 + 4));
          if (!result) {
            return result;
          }
          if (++v17 >= sk_num(v16)) {
            goto LABEL_21;
          }
        }
      }
      return 0;
    }
  }
  int v14 = (ASN1_ITEM *)*((void *)a4 + 4);
  return asn1_item_print_ctx(b, (ASN1_VALUE **)pval, a3, v14);
}

BOOL asn1_print_fsname(BIO *b, int a2, const char *a3, const char *a4, void *a5)
{
  int v8 = a2;
  if (a2 >= 21)
  {
    while (BIO_write(b, asn1_print_fsname_spaces, 20) == 20)
    {
      int v10 = v8 - 20;
      BOOL v11 = v8 <= 40;
      v8 -= 20;
      if (v11) {
        goto LABEL_7;
      }
    }
    return 0;
  }
  int v10 = a2;
LABEL_7:
  if (BIO_write(b, asn1_print_fsname_spaces, v10) != v10) {
    return 0;
  }
  if ((*a5 & 0x100) != 0) {
    a4 = 0;
  }
  if ((*a5 & 0x40) != 0) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = a3;
  }
  if (!((unint64_t)a4 | (unint64_t)v12)) {
    return 1;
  }
  if (v12)
  {
    if (BIO_puts(b, v12) < 1) {
      return 0;
    }
    if (a4)
    {
      int v13 = BIO_printf(b, " (%s)", a4);
      goto LABEL_21;
    }
    return BIO_write(b, ": ", 2) == 2;
  }
  if (!a4) {
    return BIO_write(b, ": ", 2) == 2;
  }
  int v13 = BIO_puts(b, a4);
LABEL_21:
  if (v13 >= 1) {
    return BIO_write(b, ": ", 2) == 2;
  }
  return 0;
}

BOOL asn1_print_integer_ctx(BIO *a1, ASN1_INTEGER *a2)
{
  int v3 = i2s_ASN1_INTEGER(0, a2);
  if (!v3) {
    return 0;
  }
  int v4 = v3;
  BOOL v5 = BIO_puts(a1, v3) > 0;
  free(v4);
  return v5;
}

BOOL asn1_print_oid_ctx(BIO *a1, ASN1_OBJECT *o)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  int v4 = OBJ_obj2nid(o);
  BOOL v5 = OBJ_nid2ln(v4);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = "";
  }
  OBJ_obj2txt(buf, 80, o, 1);
  return BIO_printf(a1, "%s (%s)", v6, buf) > 0;
}

BOOL asn1_print_obstring_ctx(BIO *bp, uint64_t a2, int a3)
{
  if (*(_DWORD *)(a2 + 4) == 3) {
    int v6 = BIO_printf(bp, " (%ld unused bits)\n", *(void *)(a2 + 16) & 7);
  }
  else {
    int v6 = BIO_puts(bp, "\n");
  }
  return v6 >= 1 && (*(int *)a2 < 1 || BIO_dump_indent(bp, *(const char **)(a2 + 8), *(_DWORD *)a2, a3 + 2) >= 1);
}

int RSA_check_key(const RSA *a1)
{
  if (a1->p && a1->q && a1->n && a1->e && a1->d)
  {
    int v2 = BN_new();
    int v3 = BN_new();
    int v4 = BN_new();
    BOOL v5 = BN_new();
    int v6 = BN_new();
    unsigned int v7 = BN_CTX_new();
    int v8 = v7;
    if (v2 && v3 && v4 && v5 && v6 && v7)
    {
      if (BN_is_one((uint64_t)a1->e))
      {
        ERR_put_error(4, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_chk.c", 86);
        int v9 = 0;
      }
      else
      {
        int v9 = 1;
      }
      if (!BN_is_odd((uint64_t)a1->e))
      {
        ERR_put_error(4, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_chk.c", 90);
        int v9 = 0;
      }
      int is_prime = BN_is_prime_ex(a1->p, 0, 0, 0);
      if (is_prime != 1)
      {
        int v9 = is_prime;
        if (is_prime) {
          goto LABEL_18;
        }
        ERR_put_error(4, 4095, 128, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_chk.c", 99);
      }
      int v12 = BN_is_prime_ex(a1->q, 0, 0, 0);
      if (v12 != 1)
      {
        int v9 = v12;
        if (v12) {
          goto LABEL_18;
        }
        ERR_put_error(4, 4095, 129, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_chk.c", 108);
      }
      if (BN_mul(v2, a1->p, a1->q, v8))
      {
        if (BN_cmp(v2, a1->n))
        {
          ERR_put_error(4, 4095, 127, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_chk.c", 120);
          int v9 = 0;
        }
        unsigned int p = a1->p;
        int v14 = BN_value_one();
        if (BN_sub(v2, p, v14))
        {
          q = a1->q;
          int v16 = BN_value_one();
          if (BN_sub(v3, q, v16))
          {
            if (BN_mul(v5, v2, v3, v8)
              && BN_gcd_ct((unint64_t)v6, v2, v3, v8)
              && BN_div_ct((uint64_t)v4, 0, v5, v6, v8)
              && BN_mod_mul(v2, a1->d, a1->e, v4, v8))
            {
              if (!BN_is_one((uint64_t)v2))
              {
                ERR_put_error(4, 4095, 123, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_chk.c", 161);
                int v9 = 0;
              }
              if (!a1->dmp1 || !a1->dmq1 || !a1->iqmp) {
                goto LABEL_18;
              }
              int v17 = a1->p;
              unsigned int v18 = BN_value_one();
              if (BN_sub(v2, v17, v18))
              {
                if (BN_mod_ct(v3, a1->d, v2, v8))
                {
                  if (BN_cmp(v3, a1->dmp1))
                  {
                    ERR_put_error(4, 4095, 124, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_chk.c", 180);
                    int v9 = 0;
                  }
                  int v19 = a1->q;
                  int v20 = BN_value_one();
                  if (BN_sub(v2, v19, v20))
                  {
                    if (BN_mod_ct(v3, a1->d, v2, v8))
                    {
                      if (BN_cmp(v3, a1->dmq1))
                      {
                        ERR_put_error(4, 4095, 125, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_chk.c", 198);
                        int v9 = 0;
                      }
                      if (BN_mod_inverse_ct(v2, a1->q, a1->p, v8))
                      {
                        if (BN_cmp(v2, a1->iqmp))
                        {
                          ERR_put_error(4, 4095, 126, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_chk.c", 209);
                          int v9 = 0;
                        }
                        goto LABEL_18;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else
    {
      ERR_put_error(4, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_chk.c", 80);
    }
    int v9 = -1;
LABEL_18:
    BN_free(v2);
    BN_free(v3);
    BN_free(v4);
    BN_free(v5);
    BN_free(v6);
    BN_CTX_free(v8);
    return v9;
  }
  ERR_put_error(4, 4095, 147, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_chk.c", 67);
  return 0;
}

X509_VAL *__cdecl d2i_X509_VAL(X509_VAL **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_VAL *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_VAL_it);
}

int i2d_X509_VAL(X509_VAL *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_VAL_it);
}

X509_VAL *X509_VAL_new(void)
{
  return (X509_VAL *)ASN1_item_new(&X509_VAL_it);
}

void X509_VAL_free(X509_VAL *a)
{
}

int MD5_Update(_MD5_CTX *c, const void *data, size_t len)
{
  if (len)
  {
    size_t v3 = len;
    int v4 = data;
    *(void *)&c->Nl += 8 * len;
    uint64_t num = c->num;
    if (num)
    {
      unsigned int v7 = c->data;
      int v8 = (char *)c->data + num;
      if (len <= 0x3F && num + len < 0x40)
      {
        memcpy(v8, data, len);
        c->num += v3;
        return 1;
      }
      uint64_t v9 = 64 - num;
      memcpy(v8, data, 64 - num);
      md5_block_data_order((unint64_t)c, c->data, 1);
      int v4 = (_DWORD *)((char *)v4 + v9);
      v3 -= v9;
      c->uint64_t num = 0;
      *(_OWORD *)unsigned int v7 = 0u;
      *(_OWORD *)&c->char data[4] = 0u;
      *(_OWORD *)&c->data[8] = 0u;
      *(_OWORD *)&c->data[12] = 0u;
    }
    if (v3 >= 0x40)
    {
      md5_block_data_order((unint64_t)c, v4, v3 >> 6);
      int v4 = (_DWORD *)((char *)v4 + (v3 & 0xFFFFFFFFFFFFFFC0));
      v3 &= 0x3Fu;
    }
    if (v3)
    {
      c->uint64_t num = v3;
      memcpy(c->data, v4, v3);
    }
  }
  return 1;
}

unint64_t md5_block_data_order(unint64_t result, _DWORD *a2, uint64_t a3)
{
  int v85 = (_DWORD *)result;
  if (a3)
  {
    int v4 = *(_DWORD *)(result + 8);
    int v3 = *(_DWORD *)(result + 12);
    int v5 = *(_DWORD *)result;
    int v6 = *(_DWORD *)(result + 4);
    do
    {
      int v7 = a2[1];
      HIDWORD(v8) = v5 + (v4 & v6 | v3 & ~v6) - 680876936 + *a2;
      LODWORD(v8) = HIDWORD(v8);
      int v9 = (v8 >> 25) + v6;
      HIDWORD(v8) = v3 + v7 - 389564586 + (v6 & v9 | v4 & ~v9);
      LODWORD(v8) = HIDWORD(v8);
      int v10 = (v8 >> 20) + v9;
      uint64_t result = a2[2];
      int v11 = a2[3];
      HIDWORD(v8) = v4 + result + 606105819 + (v9 & v10 | v6 & ~v10);
      LODWORD(v8) = HIDWORD(v8);
      int v12 = (v8 >> 15) + v10;
      HIDWORD(v8) = v6 + v11 - 1044525330 + (v10 & v12 | v9 & ~v12);
      LODWORD(v8) = HIDWORD(v8);
      int v13 = (v8 >> 10) + v12;
      int v14 = a2[4];
      int v15 = a2[5];
      HIDWORD(v8) = v9 + v14 - 176418897 + (v12 & v13 | v10 & ~v13);
      LODWORD(v8) = HIDWORD(v8);
      int v16 = (v8 >> 25) + v13;
      HIDWORD(v8) = v10 + v15 + 1200080426 + (v13 & v16 | v12 & ~v16);
      LODWORD(v8) = HIDWORD(v8);
      int v17 = (v8 >> 20) + v16;
      int v19 = a2[6];
      int v18 = a2[7];
      HIDWORD(v8) = v12 + v19 - 1473231341 + (v16 & v17 | v13 & ~v17);
      LODWORD(v8) = HIDWORD(v8);
      int v20 = (v8 >> 15) + v17;
      HIDWORD(v8) = v13 + v18 - 45705983 + (v17 & v20 | v16 & ~v20);
      LODWORD(v8) = HIDWORD(v8);
      int v21 = (v8 >> 10) + v20;
      int v23 = a2[8];
      int v22 = a2[9];
      HIDWORD(v8) = v16 + v23 + 1770035416 + (v20 & v21 | v17 & ~v21);
      LODWORD(v8) = HIDWORD(v8);
      int v24 = (v8 >> 25) + v21;
      HIDWORD(v8) = v17 + v22 - 1958414417 + (v21 & v24 | v20 & ~v24);
      LODWORD(v8) = HIDWORD(v8);
      int v25 = (v8 >> 20) + v24;
      int v26 = a2[10];
      int v27 = a2[11];
      HIDWORD(v8) = v26 + v20 - 42063 + (v24 & v25 | v21 & ~v25);
      LODWORD(v8) = HIDWORD(v8);
      int v28 = (v8 >> 15) + v25;
      HIDWORD(v8) = v27 + v21 - 1990404162 + (v25 & v28 | v24 & ~v28);
      LODWORD(v8) = HIDWORD(v8);
      int v29 = (v8 >> 10) + v28;
      int v31 = a2[12];
      int v30 = a2[13];
      HIDWORD(v8) = v31 + v24 + 1804603682 + (v28 & v29 | v25 & ~v29);
      LODWORD(v8) = HIDWORD(v8);
      int v32 = (v8 >> 25) + v29;
      HIDWORD(v8) = v30 + v25 - 40341101 + (v29 & v32 | v28 & ~v32);
      LODWORD(v8) = HIDWORD(v8);
      int v33 = (v8 >> 20) + v32;
      int v35 = a2[14];
      int v34 = a2[15];
      HIDWORD(v8) = v35 + v28 - 1502002290 + (v32 & v33 | v29 & ~v33);
      LODWORD(v8) = HIDWORD(v8);
      int v36 = (v8 >> 15) + v33;
      HIDWORD(v8) = v34 + v29 + 1236535329 + (v33 & v36 | v32 & ~v36);
      LODWORD(v8) = HIDWORD(v8);
      int v37 = (v8 >> 10) + v36;
      HIDWORD(v8) = v7 + v32 - 165796510 + (v37 & v33 | v36 & ~v33);
      LODWORD(v8) = HIDWORD(v8);
      int v38 = (v8 >> 27) + v37;
      HIDWORD(v8) = v19 + v33 - 1069501632 + (v38 & v36 | v37 & ~v36);
      LODWORD(v8) = HIDWORD(v8);
      int v39 = (v8 >> 23) + v38;
      HIDWORD(v8) = v27 + v36 + 643717713 + (v39 & v37 | v38 & ~v37);
      LODWORD(v8) = HIDWORD(v8);
      int v40 = (v8 >> 18) + v39;
      HIDWORD(v8) = *a2 + v37 - 373897302 + (v40 & v38 | v39 & ~v38);
      LODWORD(v8) = HIDWORD(v8);
      int v41 = (v8 >> 12) + v40;
      HIDWORD(v8) = v15 + v38 - 701558691 + (v41 & v39 | v40 & ~v39);
      LODWORD(v8) = HIDWORD(v8);
      int v42 = (v8 >> 27) + v41;
      HIDWORD(v8) = v26 + v39 + 38016083 + (v42 & v40 | v41 & ~v40);
      LODWORD(v8) = HIDWORD(v8);
      int v43 = (v8 >> 23) + v42;
      HIDWORD(v8) = v34 + v40 - 660478335 + (v43 & v41 | v42 & ~v41);
      LODWORD(v8) = HIDWORD(v8);
      int v44 = (v8 >> 18) + v43;
      HIDWORD(v8) = v14 + v41 - 405537848 + (v44 & v42 | v43 & ~v42);
      LODWORD(v8) = HIDWORD(v8);
      int v45 = (v8 >> 12) + v44;
      HIDWORD(v8) = v22 + v42 + 568446438 + (v45 & v43 | v44 & ~v43);
      LODWORD(v8) = HIDWORD(v8);
      int v46 = (v8 >> 27) + v45;
      HIDWORD(v8) = v35 + v43 - 1019803690 + (v46 & v44 | v45 & ~v44);
      LODWORD(v8) = HIDWORD(v8);
      int v47 = (v8 >> 23) + v46;
      HIDWORD(v8) = v11 + v44 - 187363961 + (v47 & v45 | v46 & ~v45);
      LODWORD(v8) = HIDWORD(v8);
      int v48 = (v8 >> 18) + v47;
      HIDWORD(v8) = v23 + v45 + 1163531501 + (v48 & v46 | v47 & ~v46);
      LODWORD(v8) = HIDWORD(v8);
      int v49 = (v8 >> 12) + v48;
      HIDWORD(v8) = v30 + v46 - 1444681467 + (v49 & v47 | v48 & ~v47);
      LODWORD(v8) = HIDWORD(v8);
      int v50 = (v8 >> 27) + v49;
      HIDWORD(v8) = result + v47 - 51403784 + (v50 & v48 | v49 & ~v48);
      LODWORD(v8) = HIDWORD(v8);
      int v51 = (v8 >> 23) + v50;
      HIDWORD(v8) = v18 + v48 + 1735328473 + (v51 & v49 | v50 & ~v49);
      LODWORD(v8) = HIDWORD(v8);
      int v52 = (v8 >> 18) + v51;
      HIDWORD(v8) = v31 + v49 - 1926607734 + ((v52 ^ v51) & v50 ^ v51);
      LODWORD(v8) = HIDWORD(v8);
      int v53 = (v8 >> 12) + v52;
      HIDWORD(v8) = v15 + v50 - 378558 + (v52 ^ v51 ^ v53);
      LODWORD(v8) = HIDWORD(v8);
      int v54 = (v8 >> 28) + v53;
      HIDWORD(v8) = v23 + v51 - 2022574463 + (v53 ^ v52 ^ v54);
      LODWORD(v8) = HIDWORD(v8);
      int v55 = (v8 >> 21) + v54;
      HIDWORD(v8) = v27 + v52 + 1839030562 + (v54 ^ v53 ^ v55);
      LODWORD(v8) = HIDWORD(v8);
      int v56 = (v8 >> 16) + v55;
      HIDWORD(v8) = v35 + v53 - 35309556 + (v55 ^ v54 ^ v56);
      LODWORD(v8) = HIDWORD(v8);
      int v57 = (v8 >> 9) + v56;
      HIDWORD(v8) = v7 + v54 - 1530992060 + (v56 ^ v55 ^ v57);
      LODWORD(v8) = HIDWORD(v8);
      int v58 = (v8 >> 28) + v57;
      HIDWORD(v8) = v14 + v55 + 1272893353 + (v57 ^ v56 ^ v58);
      LODWORD(v8) = HIDWORD(v8);
      int v59 = (v8 >> 21) + v58;
      HIDWORD(v8) = v18 + v56 - 155497632 + (v58 ^ v57 ^ v59);
      LODWORD(v8) = HIDWORD(v8);
      int v60 = (v8 >> 16) + v59;
      HIDWORD(v8) = v26 + v57 - 1094730640 + (v59 ^ v58 ^ v60);
      LODWORD(v8) = HIDWORD(v8);
      int v61 = (v8 >> 9) + v60;
      HIDWORD(v8) = v30 + v58 + 681279174 + (v60 ^ v59 ^ v61);
      LODWORD(v8) = HIDWORD(v8);
      int v62 = (v8 >> 28) + v61;
      HIDWORD(v8) = *a2 + v59 - 358537222 + (v61 ^ v60 ^ v62);
      LODWORD(v8) = HIDWORD(v8);
      int v63 = (v8 >> 21) + v62;
      HIDWORD(v8) = v11 + v60 - 722521979 + (v62 ^ v61 ^ v63);
      LODWORD(v8) = HIDWORD(v8);
      int v64 = (v8 >> 16) + v63;
      HIDWORD(v8) = v19 + v61 + 76029189 + (v63 ^ v62 ^ v64);
      LODWORD(v8) = HIDWORD(v8);
      int v65 = (v8 >> 9) + v64;
      HIDWORD(v8) = v22 + v62 - 640364487 + (v64 ^ v63 ^ v65);
      LODWORD(v8) = HIDWORD(v8);
      int v66 = (v8 >> 28) + v65;
      HIDWORD(v8) = v31 + v63 - 421815835 + (v65 ^ v64 ^ v66);
      LODWORD(v8) = HIDWORD(v8);
      int v67 = (v8 >> 21) + v66;
      HIDWORD(v8) = v34 + v64 + 530742520 + (v66 ^ v65 ^ v67);
      LODWORD(v8) = HIDWORD(v8);
      int v68 = (v8 >> 16) + v67;
      HIDWORD(v8) = result + v65 - 995338651 + (v67 ^ v66 ^ v68);
      LODWORD(v8) = HIDWORD(v8);
      int v69 = (v8 >> 9) + v68;
      HIDWORD(v8) = *a2 + v66 - 198630844 + ((v69 | ~v67) ^ v68);
      LODWORD(v8) = HIDWORD(v8);
      int v70 = (v8 >> 26) + v69;
      HIDWORD(v8) = v18 + v67 + 1126891415 + ((v70 | ~v68) ^ v69);
      LODWORD(v8) = HIDWORD(v8);
      int v71 = (v8 >> 22) + v70;
      HIDWORD(v8) = v35 + v68 - 1416354905 + ((v71 | ~v69) ^ v70);
      LODWORD(v8) = HIDWORD(v8);
      int v72 = (v8 >> 17) + v71;
      HIDWORD(v8) = v15 + v69 - 57434055 + ((v72 | ~v70) ^ v71);
      LODWORD(v8) = HIDWORD(v8);
      int v73 = (v8 >> 11) + v72;
      HIDWORD(v8) = v31 + v70 + 1700485571 + ((v73 | ~v71) ^ v72);
      LODWORD(v8) = HIDWORD(v8);
      int v74 = (v8 >> 26) + v73;
      HIDWORD(v8) = v11 + v71 - 1894986606 + ((v74 | ~v72) ^ v73);
      LODWORD(v8) = HIDWORD(v8);
      int v75 = (v8 >> 22) + v74;
      HIDWORD(v8) = v26 + v72 - 1051523 + ((v75 | ~v73) ^ v74);
      LODWORD(v8) = HIDWORD(v8);
      int v76 = (v8 >> 17) + v75;
      HIDWORD(v8) = v7 + v73 - 2054922799 + ((v76 | ~v74) ^ v75);
      LODWORD(v8) = HIDWORD(v8);
      int v77 = (v8 >> 11) + v76;
      HIDWORD(v8) = v23 + v74 + 1873313359 + ((v77 | ~v75) ^ v76);
      LODWORD(v8) = HIDWORD(v8);
      int v78 = (v8 >> 26) + v77;
      HIDWORD(v8) = v34 + v75 - 30611744 + ((v78 | ~v76) ^ v77);
      LODWORD(v8) = HIDWORD(v8);
      int v79 = (v8 >> 22) + v78;
      HIDWORD(v8) = v19 + v76 - 1560198380 + ((v79 | ~v77) ^ v78);
      LODWORD(v8) = HIDWORD(v8);
      int v80 = (v8 >> 17) + v79;
      HIDWORD(v8) = v30 + v77 + 1309151649 + ((v80 | ~v78) ^ v79);
      LODWORD(v8) = HIDWORD(v8);
      int v81 = (v8 >> 11) + v80;
      HIDWORD(v8) = v14 + v78 - 145523070 + ((v81 | ~v79) ^ v80);
      LODWORD(v8) = HIDWORD(v8);
      int v82 = (v8 >> 26) + v81;
      HIDWORD(v8) = v27 + v79 - 1120210379 + ((v82 | ~v80) ^ v81);
      LODWORD(v8) = HIDWORD(v8);
      int v83 = (v8 >> 22) + v82;
      HIDWORD(v8) = result + v80 + 718787259 + ((v83 | ~v81) ^ v82);
      LODWORD(v8) = HIDWORD(v8);
      int v84 = (v8 >> 17) + v83;
      v5 += v82;
      HIDWORD(v8) = v22 + v81 - 343485551 + ((v84 | ~v82) ^ v83);
      LODWORD(v8) = HIDWORD(v8);
      v6 += v84 + (v8 >> 11);
      v4 += v84;
      v3 += v83;
      *int v85 = v5;
      v85[1] = v6;
      v85[2] = v4;
      v85[3] = v3;
      a2 += 16;
      --a3;
    }
    while (a3);
  }
  return result;
}

void MD5_Transform(_MD5_CTX *c, const unsigned __int8 *b)
{
}

int MD5_Final(unsigned __int8 *md, _MD5_CTX *c)
{
  unsigned int data = c->data;
  uint64_t num = c->num;
  *((unsigned char *)c->data + num) = 0x80;
  uint64_t v6 = num + 1;
  if (num >= 0x38)
  {
    bzero((char *)data + v6, 63 - num);
    md5_block_data_order((unint64_t)c, data, 1);
    uint64_t v6 = 0;
  }
  bzero((char *)data + v6, 56 - v6);
  unsigned int Nh = c->Nh;
  c->data[14] = c->Nl;
  c->data[15] = Nh;
  md5_block_data_order((unint64_t)c, data, 1);
  c->uint64_t num = 0;
  *(_OWORD *)unsigned int data = 0u;
  *((_OWORD *)data + md5_block_data_order((unint64_t)c, b, 1) = 0u;
  *((_OWORD *)data + 2) = 0u;
  *((_OWORD *)data + 3) = 0u;
  *(_DWORD *)muint64_t d = c->A;
  *((_DWORD *)md + md5_block_data_order((unint64_t)c, b, 1) = c->B;
  *((_DWORD *)md + 2) = c->C;
  *((_DWORD *)md + 3) = c->D;
  return 1;
}

int MD5_Init(_MD5_CTX *c)
{
  *(_OWORD *)&c->data[13] = 0u;
  *(_OWORD *)&c->data[6] = 0u;
  *(_OWORD *)&c->data[10] = 0u;
  *(_OWORD *)&c->Nl = 0u;
  *(_OWORD *)&c->void data[2] = 0u;
  *(_OWORD *)&c->A = xmmword_23C70F740;
  return 1;
}

void RC2_set_key(RC2_KEY *key, int len, const unsigned __int8 *data, int bits)
{
  LOBYTE(key->data[0]) = 0;
  if (len >= 128) {
    int v4 = 128;
  }
  else {
    int v4 = len;
  }
  if (bits >= 1024) {
    int v5 = 1024;
  }
  else {
    int v5 = bits;
  }
  if (bits < 1) {
    int v5 = 1024;
  }
  if (len < 1) {
    goto LABEL_16;
  }
  uint64_t v6 = v4 <= 1 ? 1 : v4;
  int v7 = key;
  do
  {
    char v8 = *data++;
    LOBYTE(v7->data[0]) = v8;
    int v7 = (RC2_KEY *)((char *)v7 + 1);
    --v6;
  }
  while (v6);
  if (len <= 127)
  {
LABEL_16:
    char v9 = *((unsigned char *)key->data + v4 - 1);
    uint64_t v10 = (128 - v4);
    int v11 = key;
    do
    {
      char v9 = key_table[(LOBYTE(v11->data[0]) + v9)];
      *((unsigned char *)v11->data + SHA256_Update(c, data, len) = v9;
      int v11 = (RC2_KEY *)((char *)v11 + 1);
      --v10;
    }
    while (v10);
  }
  int v12 = (v5 + 7) >> 3;
  char v13 = key_table[(0xFFu >> (-(char)v5 & 7)) & (unint64_t)*((unsigned __int8 *)key->data
                                                                 + (128 - v12))];
  *((unsigned char *)key->data + (128 - v12)) = v13;
  if (v12 != 128)
  {
    uint64_t v14 = 0;
    uint64_t v15 = -(uint64_t)v12;
    int v16 = (char *)&key->data[31] - v12 + 3;
    do
    {
      char v13 = key_table[(*((unsigned char *)&key->data[31] + v14 + 3) ^ v13)];
      v16[v14--] = v13;
    }
    while (v15 + v14 != -128);
  }
  uint64_t v17 = 0;
  uint64_t v18 = 63;
  do
  {
    key->data[v18] = *(unsigned __int16 *)((char *)&key->data[31] + v17 + 2);
    unint64_t v19 = v17 + 127;
    v17 -= 2;
    --v18;
  }
  while (v19 > 1);
}

ASN1_OBJECT *ASN1_OBJECT_new(void)
{
  int v0 = (ASN1_OBJECT *)malloc_type_calloc(1uLL, 0x28uLL, 0x10500408E18043EuLL);
  uint64_t v1 = v0;
  if (v0) {
    v0->uint64_t flags = 1;
  }
  else {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_object.c", 83);
  }
  return v1;
}

void ASN1_OBJECT_free(ASN1_OBJECT *a)
{
  if (!a) {
    return;
  }
  int flags = a->flags;
  if ((flags & 4) == 0)
  {
    if ((flags & 8) == 0) {
      goto LABEL_4;
    }
LABEL_7:
    freezero(a->data, a->length);
    a->unsigned int data = 0;
    a->int length = 0;
    if ((a->flags & 1) == 0) {
      return;
    }
    goto LABEL_8;
  }
  free((void *)a->sn);
  free((void *)a->ln);
  a->sn = 0;
  a->ln = 0;
  int flags = a->flags;
  if ((flags & 8) != 0) {
    goto LABEL_7;
  }
LABEL_4:
  if ((flags & 1) == 0) {
    return;
  }
LABEL_8:
  free(a);
}

ASN1_OBJECT *__cdecl ASN1_OBJECT_create(int nid, unsigned __int8 *data, int len, const char *sn, const char *ln)
{
  o.sn = sn;
  o.ln = ln;
  o.unsigned int data = data;
  *(&o.flags + md5_block_data_order((unint64_t)c, b, 1) = 0;
  o.niuint64_t d = nid;
  o.int length = len;
  o.int flags = 13;
  return OBJ_dup(&o);
}

int a2d_ASN1_OBJECT(unsigned __int8 *out, int olen, const char *buf, int num)
{
  char v13 = 0;
  memset(v10, 0, sizeof(v10));
  if (num == -1) {
    uint64_t num = strlen(buf);
  }
  size_t v12 = 0;
  memset(v11, 0, sizeof(v11));
  if (num < 1) {
    goto LABEL_14;
  }
  CBS_init(v11, (uint64_t)buf, num);
  if (!CBB_init((uint64_t)v10, 0) || !a2c_ASN1_OBJECT_internal((char **)v10, v11)) {
    goto LABEL_14;
  }
  int v7 = 0;
  if (CBB_finish((uint64_t *)v10, &v13, &v12))
  {
    int v8 = v12;
    if (!(v12 >> 31))
    {
      if (!out)
      {
LABEL_12:
        int v7 = v8;
        goto LABEL_15;
      }
      if (olen >= 1 && v12 <= olen)
      {
        memcpy(out, v13, v12);
        goto LABEL_12;
      }
      ERR_put_error(13, 4095, 107, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_object.c", 356);
LABEL_14:
      int v7 = 0;
    }
  }
LABEL_15:
  CBB_cleanup((uint64_t *)v10);
  free(v13);
  return v7;
}

uint64_t a2c_ASN1_OBJECT_internal(char **a1, void *a2)
{
  unint64_t v10 = 0;
  unsigned __int8 v8 = 0;
  uint64_t result = oid_parse_arc_txt(a2, &v10, &v8, 1);
  if (result)
  {
    if (!CBS_len((uint64_t)a2))
    {
      int v5 = 138;
      int v6 = 257;
      goto LABEL_12;
    }
    unint64_t v9 = 0;
    uint64_t result = oid_parse_arc_txt(a2, &v9, &v8, 0);
    if (!result) {
      return result;
    }
    if (v10 >= 3)
    {
      int v5 = 122;
      int v6 = 270;
LABEL_12:
      ERR_put_error(13, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_object.c", v6);
      return 0;
    }
    if (v10 != 2 && v9 > 0x27 || __CFADD__(v9, 40 * v10))
    {
      int v5 = 147;
      int v6 = 274;
      goto LABEL_12;
    }
    unint64_t v11 = v9 + 40 * v10;
    uint64_t result = oid_add_arc(a1, v11);
    if (result)
    {
      while (CBS_len((uint64_t)a2))
      {
        uint64_t result = oid_parse_arc_txt(a2, &v11, &v8, 0);
        if (result)
        {
          int v7 = oid_add_arc(a1, v11);
          uint64_t result = 0;
          if (v7) {
            continue;
          }
        }
        return result;
      }
      return 1;
    }
  }
  return result;
}

size_t i2t_ASN1_OBJECT_internal(ASN1_OBJECT *a1, char *a2, unsigned int a3, int a4)
{
  __source = 0;
  if ((a3 & 0x80000000) != 0) {
    return 0;
  }
  if (a3) {
    *a2 = 0;
  }
  if (!a1 || !a1->data) {
    return 0;
  }
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  if (CBB_init((uint64_t)v10, 0)
    && i2t_ASN1_OBJECT_cbb(a1, (char **)v10, a4)
    && CBB_finish((uint64_t *)v10, &__source, &v11))
  {
    size_t v8 = strlcpy(a2, __source, a3);
  }
  else
  {
    size_t v8 = 0;
  }
  CBB_cleanup((uint64_t *)v10);
  free(__source);
  return v8;
}

uint64_t i2t_ASN1_OBJECT_cbb(ASN1_OBJECT *o, char **a2, int a3)
{
  if (!a3
    && (int v9 = OBJ_obj2nid(o)) != 0
    && ((int v10 = v9, (v11 = OBJ_nid2ln(v9)) != 0) || (v11 = OBJ_nid2sn(v10)) != 0))
  {
    size_t v12 = strlen(v11);
    uint64_t result = CBB_add_bytes(a2, v11, v12);
    if (result) {
      return CBB_add_u8(a2, 0) != 0;
    }
  }
  else
  {
    memset(v13, 0, sizeof(v13));
    CBS_init(v13, (uint64_t)o->data, o->length);
    unint64_t v14 = 0;
    uint64_t result = oid_parse_arc(v13, &v14);
    if (result)
    {
      unint64_t v6 = v14;
      uint64_t v7 = v14 / 0x28 >= 2 ? 2 : v14 / 0x28;
      uint64_t result = oid_add_arc_txt(a2, v7, 1);
      if (result)
      {
        for (uint64_t i = v6 - 40 * v7; ; uint64_t i = v14)
        {
          uint64_t result = oid_add_arc_txt(a2, i, 0);
          if (!result) {
            break;
          }
          if (!CBS_len((uint64_t)v13)) {
            return CBB_add_u8(a2, 0) != 0;
          }
          uint64_t result = oid_parse_arc(v13, &v14);
          if (!result) {
            break;
          }
        }
      }
    }
  }
  return result;
}

int i2t_ASN1_OBJECT(char *buf, int buf_len, ASN1_OBJECT *a)
{
  return i2t_ASN1_OBJECT_internal(a, buf, buf_len, 0);
}

ASN1_OBJECT *t2i_ASN1_OBJECT_internal(const char *a1)
{
  unint64_t v8 = 0;
  int v9 = 0;
  memset(v6, 0, sizeof(v6));
  memset(v7, 0, sizeof(v7));
  size_t v2 = strlen(a1);
  CBS_init(v6, (uint64_t)a1, v2);
  if (CBB_init((uint64_t)v7, 0) && a2c_ASN1_OBJECT_internal((char **)v7, v6))
  {
    int v3 = 0;
    if (CBB_finish((uint64_t *)v7, &v9, &v8))
    {
      if (!(v8 >> 31))
      {
        int v4 = ASN1_OBJECT_new();
        int v3 = v4;
        if (v4)
        {
          v4->unsigned int data = v9;
          v4->int length = v8;
          v4->flags |= 8u;
          int v9 = 0;
        }
      }
    }
  }
  else
  {
    int v3 = 0;
  }
  CBB_cleanup((uint64_t *)v7);
  free(v9);
  return v3;
}

int i2a_ASN1_OBJECT(BIO *bp, ASN1_OBJECT *a)
{
  uint64_t v11 = 0;
  if (a && a->data)
  {
    uint64_t v10 = 0;
    memset(v9, 0, sizeof(v9));
    if (CBB_init((uint64_t)v9, 0))
    {
      if (!i2t_ASN1_OBJECT_cbb(a, (char **)v9, 0))
      {
        unint64_t v6 = "<INVALID>";
        int v5 = bp;
        int v4 = 9;
        goto LABEL_12;
      }
      if (CBB_finish((uint64_t *)v9, &v11, &v10))
      {
        int v4 = strlen(v11);
        int v5 = bp;
        unint64_t v6 = v11;
LABEL_12:
        int v8 = BIO_write(v5, v6, v4);
        goto LABEL_13;
      }
    }
    int v8 = -1;
LABEL_13:
    CBB_cleanup((uint64_t *)v9);
    free(v11);
    return v8;
  }
  return BIO_write(bp, "NULL", 4);
}

uint64_t c2i_ASN1_OBJECT_cbs(ASN1_OBJECT **a1, void *a2)
{
  uint64_t v10 = 0;
  unint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  if (a1)
  {
    int v3 = a1;
    int v4 = *a1;
    if (v4)
    {
      ASN1_OBJECT_free(v4);
      ASN1_OBJECT *v3 = 0;
    }
    CBS_dup(a2, v8);
    if (CBS_len((uint64_t)v8))
    {
      while (CBS_len((uint64_t)v8))
      {
        if (!oid_parse_arc(v8, 0))
        {
          int v5 = 551;
          goto LABEL_9;
        }
      }
      if (!CBS_stow((uint64_t)a2, (void **)&v10, &v9) || v9 >> 31)
      {
        a1 = v10;
      }
      else
      {
        uint64_t v7 = ASN1_OBJECT_new();
        a1 = v10;
        if (v7)
        {
          v7->unsigned int data = (unsigned __int8 *)v10;
          v7->int length = v9;
          v7->flags |= 8u;
          ASN1_OBJECT *v3 = v7;
          return 1;
        }
      }
    }
    else
    {
      int v5 = 546;
LABEL_9:
      ERR_put_error(13, 4095, 216, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_object.c", v5);
      a1 = 0;
    }
  }
  free(a1);
  return 0;
}

uint64_t oid_parse_arc(void *a1, unint64_t *a2)
{
  unint64_t v4 = 0;
  unsigned __int8 v10 = 0;
  while (1)
  {
    uint64_t result = CBS_get_u8(a1, &v10);
    if (!result) {
      break;
    }
    uint64_t result = 0;
    BOOL v6 = !a2 || v4 >> 57 == 0;
    BOOL v7 = !v6;
    BOOL v8 = v10 == 128 && v4 == 0;
    if (v8 || v7) {
      break;
    }
    unint64_t v9 = v10 & 0x7F | (v4 << 7);
    unint64_t v4 = v9;
    if ((v10 & 0x80) == 0)
    {
      if (a2) {
        *a2 = v9;
      }
      return 1;
    }
  }
  return result;
}

ASN1_OBJECT *__cdecl c2i_ASN1_OBJECT(ASN1_OBJECT **a, const unsigned __int8 **pp, uint64_t length)
{
  BOOL v8 = 0;
  if (a)
  {
    ASN1_OBJECT_free(*a);
    BUF_MEM *a = 0;
  }
  if (length < 0)
  {
    ERR_put_error(13, 4095, 136, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_object.c", 592);
    return 0;
  }
  memset(v7, 0, sizeof(v7));
  CBS_init(v7, (uint64_t)*pp, length);
  if (!c2i_ASN1_OBJECT_cbs(&v8, v7)) {
    return 0;
  }
  *punsigned int p = (const unsigned __int8 *)CBS_data((uint64_t)v7);
  uint64_t result = v8;
  if (a) {
    BUF_MEM *a = v8;
  }
  return result;
}

int i2d_ASN1_OBJECT(ASN1_OBJECT *a, unsigned __int8 **pp)
{
  if (!a || !a->data) {
    return 0;
  }
  int v4 = ASN1_object_size(0, a->length, 6);
  if (pp)
  {
    ppa = *pp;
    ASN1_put_object(&ppa, 0, a->length, 6, 0);
    memcpy(ppa, a->data, a->length);
    *punsigned int p = &ppa[a->length];
  }
  return v4;
}

ASN1_OBJECT *__cdecl d2i_ASN1_OBJECT(ASN1_OBJECT **a, const unsigned __int8 **pp, uint64_t length)
{
  size_t v12 = 0;
  if (a)
  {
    ASN1_OBJECT_free(*a);
    BUF_MEM *a = 0;
  }
  if (length < 0)
  {
    int v7 = 136;
    int v8 = 644;
LABEL_12:
    ERR_put_error(13, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_object.c", v8);
    return 0;
  }
  int v11 = 0;
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  CBS_init(v10, (uint64_t)*pp, length);
  if (!asn1_get_primitive(v10, 0, &v11, v9))
  {
    int v7 = 102;
    int v8 = 651;
    goto LABEL_12;
  }
  if (v11 != 6)
  {
    int v7 = 116;
    int v8 = 655;
    goto LABEL_12;
  }
  if (!c2i_ASN1_OBJECT_cbs(&v12, v9)) {
    return 0;
  }
  *punsigned int p = (const unsigned __int8 *)CBS_data((uint64_t)v10);
  uint64_t result = v12;
  if (a) {
    BUF_MEM *a = v12;
  }
  return result;
}

uint64_t oid_parse_arc_txt(void *a1, unint64_t *a2, unsigned __int8 *a3, int a4)
{
  unsigned __int8 v15 = 0;
  if (!a4)
  {
    uint64_t result = CBS_get_u8(a1, &v15);
    if (!result) {
      return result;
    }
    if (*a3)
    {
      if (v15 != (char)*a3)
      {
LABEL_26:
        int v13 = 131;
        int v14 = 199;
        goto LABEL_32;
      }
    }
    else if (v15 != 32 && v15 != 46)
    {
      goto LABEL_26;
    }
    *a3 = v15;
  }
  if (!CBS_len((uint64_t)a1))
  {
LABEL_22:
    int v13 = 187;
    int v14 = 238;
LABEL_32:
    ERR_put_error(13, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_object.c", v14);
    return 0;
  }
  int v7 = 0;
  unint64_t v8 = 0;
  while (1)
  {
    uint64_t result = CBS_peek_u8((uint64_t)a1, &v15);
    if (!result) {
      return result;
    }
    if (v15 == 32 || v15 == 46)
    {
      if (!v7) {
        goto LABEL_22;
      }
LABEL_21:
      *a2 = v8;
      return 1;
    }
    uint64_t result = CBS_get_u8(a1, &v15);
    if (!result) {
      return result;
    }
    if ((v15 - 58) <= 0xF5u)
    {
      if (a4)
      {
        int v13 = 131;
        int v14 = 216;
      }
      else
      {
        int v13 = 130;
        int v14 = 219;
      }
      goto LABEL_32;
    }
    unsigned __int8 v10 = v15 - 48;
    v15 -= 48;
    BOOL v11 = v7-- != 0;
    if (v11 && !v8 && !v10)
    {
      int v13 = 187;
      int v14 = 225;
      goto LABEL_32;
    }
    if (v8 >= 0x199999999999999ALL)
    {
      int v13 = 155;
      int v14 = 231;
      goto LABEL_32;
    }
    unint64_t v8 = 10 * v8 + v10;
    if (!CBS_len((uint64_t)a1)) {
      goto LABEL_21;
    }
  }
}

uint64_t oid_add_arc(char **a1, unint64_t a2)
{
  int v4 = 0;
  for (uint64_t i = 63; i != -7; i -= 7)
  {
    uint64_t v6 = (a2 >> i) & 0x7F;
    if (v4 || !i || v6)
    {
      uint64_t result = CBB_add_u8(a1, v6 | ((i != 0) << 7));
      if (!result) {
        return result;
      }
      int v4 = 1;
    }
    else
    {
      int v4 = 0;
    }
  }
  return 1;
}

BOOL oid_add_arc_txt(char **a1, uint64_t a2, int a3)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a3) {
    unsigned int v4 = snprintf(__str, 0x16uLL, "%llu");
  }
  else {
    unsigned int v4 = snprintf(__str, 0x16uLL, ".%llu");
  }
  return v4 <= 0x15 && CBB_add_bytes(a1, __str, v4) != 0;
}

uint64_t PKCS7_ctrl(PKCS7 *p7, int cmd, uint64_t larg, char *parg)
{
  int v7 = OBJ_obj2nid(p7->type);
  if (cmd != 2)
  {
    if (cmd == 1)
    {
      if (v7 == 22)
      {
        p7->detacheuint64_t d = larg;
        if (larg << 32)
        {
          lunsigned int arg = (int)larg;
          if (OBJ_obj2nid(*(const ASN1_OBJECT **)(*((void *)p7->d.ptr + 5) + 24)) == 21)
          {
            ASN1_OCTET_STRING_free(*(ASN1_OCTET_STRING **)(*((void *)p7->d.ptr + 5) + 32));
            *(void *)(*((void *)p7->d.ptr + 5) + 32) = 0;
          }
          return larg;
        }
        return 0;
      }
      int v9 = 104;
      int v10 = 88;
    }
    else
    {
      int v9 = 110;
      int v10 = 107;
    }
LABEL_13:
    ERR_put_error(33, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", v10);
    return 0;
  }
  if (v7 != 22)
  {
    int v9 = 104;
    int v10 = 101;
    goto LABEL_13;
  }
  ptr = p7->d.ptr;
  if (ptr) {
    lunsigned int arg = *(void *)(*((void *)ptr + 5) + 32) == 0;
  }
  else {
    lunsigned int arg = 1;
  }
  p7->detacheuint64_t d = larg;
  return larg;
}

int PKCS7_content_new(PKCS7 *p7, int nid)
{
  unsigned int v4 = PKCS7_new();
  if (v4)
  {
    int v5 = v4;
    if (PKCS7_set_type(v4, nid) && PKCS7_set_content(p7, v5))
    {
      LODWORD(v4) = 1;
    }
    else
    {
      PKCS7_free(v5);
      LODWORD(v4) = 0;
    }
  }
  return (int)v4;
}

int PKCS7_set_type(PKCS7 *p7, int type)
{
  unsigned int v4 = OBJ_nid2obj(type);
  switch(type)
  {
    case 21:
      p7->type = v4;
      int v5 = (char *)ASN1_OCTET_STRING_new();
      p7->d.ptr = v5;
      return v5 != 0;
    case 22:
      p7->type = v4;
      uint64_t v6 = (char *)PKCS7_SIGNED_new();
      p7->d.ptr = v6;
      if (!v6) {
        return 0;
      }
      int v7 = 1;
      if (!ASN1_INTEGER_set(*(ASN1_INTEGER **)v6, 1))
      {
        PKCS7_SIGNED_free(p7->d.sign);
        p7->d.ptr = 0;
        return 0;
      }
      return v7;
    case 23:
      p7->type = v4;
      unint64_t v8 = (char *)PKCS7_ENVELOPE_new();
      p7->d.ptr = v8;
      if (!v8 || !ASN1_INTEGER_set(*(ASN1_INTEGER **)v8, 0)) {
        return 0;
      }
      int v9 = OBJ_nid2obj(21);
      int v10 = (ASN1_OBJECT **)*((void *)p7->d.ptr + 2);
      goto LABEL_20;
    case 24:
      p7->type = v4;
      BOOL v11 = (char *)PKCS7_SIGN_ENVELOPE_new();
      p7->d.ptr = v11;
      if (!v11 || !ASN1_INTEGER_set(*(ASN1_INTEGER **)v11, 1)) {
        return 0;
      }
      int v9 = OBJ_nid2obj(21);
      int v10 = (ASN1_OBJECT **)*((void *)p7->d.ptr + 5);
      goto LABEL_20;
    case 25:
      p7->type = v4;
      size_t v12 = (char *)PKCS7_DIGEST_new();
      p7->d.ptr = v12;
      return v12 && ASN1_INTEGER_set(*(ASN1_INTEGER **)v12, 0);
    case 26:
      p7->type = v4;
      int v13 = (char *)PKCS7_ENCRYPT_new();
      p7->d.ptr = v13;
      if (!v13 || !ASN1_INTEGER_set(*(ASN1_INTEGER **)v13, 0)) {
        return 0;
      }
      int v9 = OBJ_nid2obj(21);
      int v10 = (ASN1_OBJECT **)*((void *)p7->d.ptr + 1);
LABEL_20:
      *int v10 = v9;
      return 1;
    default:
      ERR_put_error(33, 4095, 112, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", 226);
      return 0;
  }
}

int PKCS7_set_content(PKCS7 *p7, PKCS7 *p7_data)
{
  int v4 = OBJ_obj2nid(p7->type);
  if (v4 == 25)
  {
    ptr = p7->d.ptr;
    unint64_t v8 = (PKCS7 *)*((void *)ptr + 2);
    if (v8)
    {
      PKCS7_free(v8);
      ptr = p7->d.ptr;
    }
    *((void *)ptr + 2) = p7_data;
    return 1;
  }
  if (v4 == 22)
  {
    int v5 = p7->d.ptr;
    uint64_t v6 = (PKCS7 *)*((void *)v5 + 5);
    if (v6)
    {
      PKCS7_free(v6);
      int v5 = p7->d.ptr;
    }
    *((void *)v5 + 5) = p7_data;
    return 1;
  }
  ERR_put_error(33, 4095, 112, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", 156);
  return 0;
}

int PKCS7_set0_type_other(PKCS7 *p7, int type, ASN1_TYPE *other)
{
  p7->type = OBJ_nid2obj(type);
  p7->d.ptr = (char *)other;
  return 1;
}

int PKCS7_add_signer(PKCS7 *p7, PKCS7_SIGNER_INFO *p7i)
{
  int v4 = OBJ_obj2nid(p7->type);
  if (v4 != 24 && v4 != 22)
  {
    int v14 = 113;
    int v15 = 263;
LABEL_13:
    ERR_put_error(33, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", v15);
    return 0;
  }
  ptr = p7->d.ptr;
  uint64_t v6 = (STACK *)*((void *)ptr + 1);
  int v7 = (STACK *)*((void *)ptr + 4);
  int v8 = OBJ_obj2nid(p7i->digest_alg->algorithm);
  if (sk_num(v6) >= 1)
  {
    int v9 = 0;
    do
    {
      int v10 = sk_value(v6, v9);
      if (OBJ_obj2nid(*(const ASN1_OBJECT **)v10) == v8) {
        return sk_push(v7, (char *)p7i) != 0;
      }
    }
    while (++v9 < sk_num(v6));
  }
  BOOL v11 = X509_ALGOR_new();
  if (!v11 || (size_t v12 = ASN1_TYPE_new(), (v11->parameter = v12) == 0))
  {
    X509_ALGOR_free(v11);
    int v14 = 65;
    int v15 = 283;
    goto LABEL_13;
  }
  v11->algorithm = OBJ_nid2obj(v8);
  v11->parameter->type = 5;
  if (sk_push(v6, (char *)v11)) {
    return sk_push(v7, (char *)p7i) != 0;
  }
  X509_ALGOR_free(v11);
  return 0;
}

int PKCS7_add_certificate(PKCS7 *p7, X509 *x509)
{
  int v4 = OBJ_obj2nid(p7->type);
  if (v4 != 24 && v4 != 22)
  {
    int v8 = 113;
    int v9 = 315;
LABEL_9:
    ERR_put_error(33, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", v9);
    return 0;
  }
  int v5 = (STACK **)(p7->d.ptr + 16);
  if (!*v5)
  {
    uint64_t v6 = sk_new_null();
    char *v5 = v6;
    if (!v6)
    {
      int v8 = 65;
      int v9 = 322;
      goto LABEL_9;
    }
  }
  int v7 = 1;
  CRYPTO_add_lock(&x509->references, 1, 3, 0, 0);
  if (!sk_push(*v5, (char *)x509))
  {
    X509_free(x509);
    return 0;
  }
  return v7;
}

int PKCS7_add_crl(PKCS7 *p7, X509_CRL *x509)
{
  int v4 = OBJ_obj2nid(p7->type);
  if (v4 != 24 && v4 != 22)
  {
    int v8 = 113;
    int v9 = 349;
LABEL_9:
    ERR_put_error(33, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", v9);
    return 0;
  }
  int v5 = (STACK **)(p7->d.ptr + 24);
  if (!*v5)
  {
    uint64_t v6 = sk_new_null();
    char *v5 = v6;
    if (!v6)
    {
      int v8 = 65;
      int v9 = 356;
      goto LABEL_9;
    }
  }
  int v7 = 1;
  CRYPTO_add_lock(&x509->references, 1, 6, 0, 0);
  if (!sk_push(*v5, (char *)x509))
  {
    X509_CRL_free(x509);
    return 0;
  }
  return v7;
}

int PKCS7_SIGNER_INFO_set(PKCS7_SIGNER_INFO *p7i, X509 *x509, EVP_PKEY *pkey, const EVP_MD *dgst)
{
  if (!ASN1_INTEGER_set(p7i->version, 1)) {
    return 0;
  }
  issuer_and_serial = p7i->issuer_and_serial;
  issuer_name = X509_get_issuer_name(x509);
  if (!X509_NAME_set(&issuer_and_serial->issuer, issuer_name)) {
    return 0;
  }
  ASN1_INTEGER_free(p7i->issuer_and_serial->serial);
  serialNumber = X509_get_serialNumber(x509);
  BOOL v11 = ASN1_INTEGER_dup(serialNumber);
  p7i->issuer_and_serial->serial = v11;
  if (!v11) {
    return 0;
  }
  CRYPTO_add_lock(&pkey->references, 1, 10, 0, 0);
  p7i->pkey = pkey;
  digest_alg = p7i->digest_alg;
  int v13 = EVP_MD_type(dgst);
  int v14 = OBJ_nid2obj(v13);
  X509_ALGOR_set0(digest_alg, v14, 5, 0);
  ptr = pkey->pkey.ptr;
  if (!ptr) {
    goto LABEL_8;
  }
  int v16 = (uint64_t (*)(EVP_PKEY *, uint64_t, void, PKCS7_SIGNER_INFO *))*((void *)ptr + 22);
  if (!v16) {
    goto LABEL_8;
  }
  int v17 = 1;
  int v18 = v16(pkey, 1, 0, p7i);
  if (v18 <= 0)
  {
    if (v18 != -2)
    {
      int v19 = 147;
      int v20 = 404;
      goto LABEL_9;
    }
LABEL_8:
    int v19 = 148;
    int v20 = 408;
LABEL_9:
    ERR_put_error(33, 4095, v19, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", v20);
    return 0;
  }
  return v17;
}

PKCS7_SIGNER_INFO *__cdecl PKCS7_add_signature(PKCS7 *p7, X509 *x509, EVP_PKEY *pkey, const EVP_MD *dgst)
{
  int v4 = dgst;
  if (!dgst)
  {
    if ((int)EVP_PKEY_get_default_digest_nid((uint64_t)pkey) < 1) {
      return 0;
    }
    int v10 = OBJ_nid2sn(0);
    digestbyname = EVP_get_digestbyname(v10);
    if (!digestbyname)
    {
      ERR_put_error(33, 4095, 151, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", 425);
      return 0;
    }
    int v4 = digestbyname;
  }
  int v8 = PKCS7_SIGNER_INFO_new();
  int v9 = v8;
  if (v8 && (!PKCS7_SIGNER_INFO_set(v8, x509, pkey, v4) || !PKCS7_add_signer(p7, v9)))
  {
    PKCS7_SIGNER_INFO_free(v9);
    return 0;
  }
  return v9;
}

int PKCS7_set_digest(PKCS7 *p7, const EVP_MD *md)
{
  if (OBJ_obj2nid(p7->type) != 25)
  {
    ERR_put_error(33, 4095, 113, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", 457);
    return 1;
  }
  int v4 = ASN1_TYPE_new();
  *(void *)(*((void *)p7->d.ptr + 1) + 8) = v4;
  if (v4)
  {
    **(_DWORD **)(*((void *)p7->d.ptr + 1) + 8) = 5;
    int v5 = EVP_MD_type(md);
    **((void **)p7->d.ptr + md5_block_data_order((unint64_t)c, b, 1) = OBJ_nid2obj(v5);
    return 1;
  }
  ERR_put_error(33, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", 449);
  return 0;
}

STACK *__cdecl PKCS7_get_signer_info(STACK *p7)
{
  if (p7)
  {
    uint64_t v1 = p7;
    if (*(void *)&p7[1].num
      && (OBJ_obj2nid((const ASN1_OBJECT *)p7->comp) == 22 || OBJ_obj2nid((const ASN1_OBJECT *)v1->comp) == 24))
    {
      return *(STACK **)(*(void *)&v1[1].num + 32);
    }
    else
    {
      return 0;
    }
  }
  return p7;
}

void *PKCS7_SIGNER_INFO_get0_algs(void *result, void *a2, void *a3, void *a4)
{
  if (a2) {
    *a2 = result[7];
  }
  if (a3) {
    *a3 = result[2];
  }
  if (a4) {
    *a4 = result[4];
  }
  return result;
}

uint64_t PKCS7_RECIP_INFO_get0_alg(uint64_t result, void *a2)
{
  if (a2) {
    *a2 = *(void *)(result + 16);
  }
  return result;
}

PKCS7_RECIP_INFO *__cdecl PKCS7_add_recipient(PKCS7 *p7, X509 *x509)
{
  int v4 = PKCS7_RECIP_INFO_new();
  int v5 = v4;
  if (v4 && (!PKCS7_RECIP_INFO_set(v4, x509) || !PKCS7_add_recipient_info(p7, v5)))
  {
    PKCS7_RECIP_INFO_free(v5);
    return 0;
  }
  return v5;
}

int PKCS7_RECIP_INFO_set(PKCS7_RECIP_INFO *p7i, X509 *x509)
{
  if (ASN1_INTEGER_set(p7i->version, 0))
  {
    issuer_and_serial = p7i->issuer_and_serial;
    issuer_name = X509_get_issuer_name(x509);
    if (X509_NAME_set(&issuer_and_serial->issuer, issuer_name))
    {
      ASN1_INTEGER_free(p7i->issuer_and_serial->serial);
      serialNumber = X509_get_serialNumber(x509);
      int v7 = ASN1_INTEGER_dup(serialNumber);
      p7i->issuer_and_serial->serial = v7;
      if (v7)
      {
        pubkey = X509_get_pubkey(x509);
        int v9 = pubkey;
        if (pubkey
          && (ptr = pubkey->pkey.ptr) != 0
          && (BOOL v11 = (uint64_t (*)(EVP_PKEY *, uint64_t, void, PKCS7_RECIP_INFO *))*((void *)ptr + 22)) != 0)
        {
          int v12 = v11(pubkey, 2, 0, p7i);
          if (v12 == -2)
          {
            int v13 = 150;
            int v14 = 567;
          }
          else
          {
            if (v12 > 0)
            {
              EVP_PKEY_free(v9);
              int v15 = 1;
              CRYPTO_add_lock(&x509->references, 1, 3, 0, 0);
              p7i->cert = x509;
              return v15;
            }
            int v13 = 149;
            int v14 = 571;
          }
        }
        else
        {
          int v13 = 150;
          int v14 = 560;
        }
        ERR_put_error(33, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", v14);
        EVP_PKEY_free(v9);
      }
    }
  }
  return 0;
}

int PKCS7_add_recipient_info(PKCS7 *p7, PKCS7_RECIP_INFO *ri)
{
  int v4 = OBJ_obj2nid(p7->type);
  if (v4 == 23)
  {
    int v5 = p7->d.ptr + 8;
    return sk_push(*(STACK **)v5, (char *)ri) != 0;
  }
  if (v4 == 24)
  {
    int v5 = p7->d.ptr + 48;
    return sk_push(*(STACK **)v5, (char *)ri) != 0;
  }
  ERR_put_error(33, 4095, 113, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", 531);
  return 0;
}

X509 *__cdecl PKCS7_cert_from_signer_info(PKCS7 *p7, PKCS7_SIGNER_INFO *si)
{
  if (OBJ_obj2nid(p7->type) != 22) {
    return 0;
  }
  int v4 = (STACK *)*((void *)p7->d.ptr + 2);
  issuer_and_serial = si->issuer_and_serial;
  issuer = issuer_and_serial->issuer;
  serial = issuer_and_serial->serial;
  return X509_find_by_issuer_and_serial(v4, issuer, serial);
}

int PKCS7_set_cipher(PKCS7 *p7, const EVP_CIPHER *cipher)
{
  int v4 = OBJ_obj2nid(p7->type);
  if (v4 == 23)
  {
    int v5 = p7->d.ptr + 16;
  }
  else
  {
    if (v4 != 24)
    {
      int v8 = 113;
      int v9 = 615;
      goto LABEL_9;
    }
    int v5 = p7->d.ptr + 40;
  }
  uint64_t v6 = *(void *)v5;
  if (EVP_CIPHER_type(cipher))
  {
    *(void *)(v6 + 24) = cipher;
    return 1;
  }
  int v8 = 144;
  int v9 = 622;
LABEL_9:
  ERR_put_error(33, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs7/pk7_lib.c", v9);
  return 0;
}

uint64_t PKCS7_stream(void *a1, uint64_t a2)
{
  switch(OBJ_obj2nid(*(const ASN1_OBJECT **)(a2 + 24)))
  {
    case 21:
      uint64_t result = *(void *)(a2 + 32);
      if (result) {
        goto LABEL_12;
      }
      break;
    case 22:
      uint64_t result = *(void *)(*(void *)(*(void *)(a2 + 32) + 40) + 32);
      if (result) {
        goto LABEL_12;
      }
      break;
    case 23:
      uint64_t result = *(void *)(*(void *)(*(void *)(a2 + 32) + 16) + 16);
      if (result) {
        goto LABEL_12;
      }
      uint64_t result = (uint64_t)ASN1_OCTET_STRING_new();
      uint64_t v5 = *(void *)(*(void *)(a2 + 32) + 16);
      goto LABEL_11;
    case 24:
      uint64_t result = *(void *)(*(void *)(*(void *)(a2 + 32) + 40) + 16);
      if (result) {
        goto LABEL_12;
      }
      uint64_t result = (uint64_t)ASN1_OCTET_STRING_new();
      uint64_t v5 = *(void *)(*(void *)(a2 + 32) + 40);
LABEL_11:
      *(void *)(v5 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = result;
      if (result)
      {
LABEL_12:
        *(void *)(result + 16) |= 0x10uLL;
        *a1 = result + 8;
        uint64_t result = 1;
      }
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t Camellia_set_key(unsigned __int8 *a1, int a2, unsigned int *a3)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a3)
  {
    if (a2 == 128 || a2 == 256 || a2 == 192)
    {
      unsigned int v6 = Camellia_Ekeygen(a2, a1, a3);
      uint64_t result = 0;
      a3[68] = v6;
    }
    else
    {
      return 4294967294;
    }
  }
  return result;
}

uint64_t Camellia_encrypt(unsigned int *a1, unsigned char *a2, _DWORD *a3)
{
  return Camellia_EncryptBlock_Rounds(a3[68], a1, a3, a2);
}

uint64_t Camellia_decrypt(unsigned int *a1, unsigned char *a2, _DWORD *a3)
{
  return Camellia_DecryptBlock_Rounds(a3[68], a1, a3, a2);
}

BN_BLINDING *__cdecl BN_BLINDING_new(const BIGNUM *A, const BIGNUM *Ai, BIGNUM *mod)
{
  unsigned int v6 = malloc_type_calloc(1uLL, 0x50uLL, 0x10A0040DBBD1971uLL);
  if (v6)
  {
    if ((!A || (v7 = BN_dup(A), (*unsigned int v6 = v7) != 0))
      && (!Ai || (int v8 = BN_dup(Ai), (v6[1] = v8) != 0))
      && (int v9 = BN_dup(mod), (v6[3] = v9) != 0))
    {
      if (BN_get_flags((uint64_t)mod, 4u)) {
        BN_set_flags(v6[3], 4);
      }
      *((_DWORD *)v6 + 12) = -1;
      CRYPTO_THREADID_current(v6 + 4);
    }
    else
    {
      BN_BLINDING_free((BN_BLINDING *)v6);
      return 0;
    }
  }
  else
  {
    ERR_put_error(3, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_blind.c", 142);
  }
  return (BN_BLINDING *)v6;
}

void BN_BLINDING_free(BN_BLINDING *b)
{
  if (b)
  {
    BN_free(*(BIGNUM **)b);
    BN_free(*((BIGNUM **)b + 1));
    BN_free(*((BIGNUM **)b + 2));
    BN_free(*((BIGNUM **)b + 3));
    free(b);
  }
}

int BN_BLINDING_update(BN_BLINDING *b, BN_CTX *ctx)
{
  int v3 = *(BIGNUM **)b;
  if (!v3 || !*((void *)b + 1))
  {
    ERR_put_error(3, 4095, 107, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_blind.c", 192);
    LODWORD(param) = 0;
    goto LABEL_15;
  }
  int v5 = *((_DWORD *)b + 12);
  if (v5 == -1)
  {
    *((_DWORD *)b + 12) = 1;
  }
  else
  {
    int v6 = v5 + 1;
    *((_DWORD *)b + 12) = v6;
    if (v6 == 32 && *((void *)b + 2) && (*((unsigned char *)b + 56) & 2) == 0)
    {
      param = BN_BLINDING_create_param(b, 0, 0, ctx, 0, 0);
      if (!param) {
        goto LABEL_15;
      }
LABEL_14:
      LODWORD(param) = 1;
      goto LABEL_15;
    }
  }
  if (*((unsigned char *)b + 56)) {
    goto LABEL_14;
  }
  LODWORD(param) = BN_mod_mul(v3, v3, v3, *((const BIGNUM **)b + 3), ctx);
  if (param)
  {
    LODWORD(param) = BN_mod_mul(*((BIGNUM **)b + 1), *((const BIGNUM **)b + 1), *((const BIGNUM **)b + 1), *((const BIGNUM **)b + 3), ctx);
    if (param) {
      goto LABEL_14;
    }
  }
LABEL_15:
  if (*((_DWORD *)b + 12) == 32) {
    *((_DWORD *)b + 12) = 0;
  }
  return (int)param;
}

BN_BLINDING *__cdecl BN_BLINDING_create_param(BN_BLINDING *b, const BIGNUM *e, BIGNUM *m, BN_CTX *ctx, int (__cdecl *bn_mod_exp)(BIGNUM *, const BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *, BN_MONT_CTX *), BN_MONT_CTX *m_ctx)
{
  BOOL v11 = b;
  if (!b)
  {
    BOOL v11 = BN_BLINDING_new(0, 0, m);
    if (!v11) {
      return v11;
    }
  }
  if (!*(void *)v11)
  {
    int v12 = BN_new();
    *(void *)BOOL v11 = v12;
    if (!v12) {
      goto LABEL_20;
    }
  }
  if (!*((void *)v11 + 1))
  {
    int v13 = BN_new();
    *((void *)v11 + md5_block_data_order((unint64_t)c, b, 1) = v13;
    if (!v13) {
      goto LABEL_20;
    }
  }
  int v14 = (BIGNUM *)*((void *)v11 + 2);
  if (e)
  {
    BN_free(v14);
    int v14 = BN_dup(e);
    *((void *)v11 + 2) = v14;
  }
  if (!v14) {
    goto LABEL_20;
  }
  if (bn_mod_exp) {
    *((void *)v11 + 9) = bn_mod_exp;
  }
  if (m_ctx) {
    *((void *)v11 + 8) = m_ctx;
  }
  if (!BN_rand_range(*(BIGNUM **)v11, *((const BIGNUM **)v11 + 3)))
  {
LABEL_20:
    if (b) {
      return v11;
    }
LABEL_21:
    BN_BLINDING_free(v11);
    return 0;
  }
  int v15 = -33;
  while (!BN_mod_inverse_ct(*((BIGNUM **)v11 + 1), *(const BIGNUM **)v11, *((const BIGNUM **)v11 + 3), ctx))
  {
    if ((ERR_peek_last_error() & 0xFFF) != 0x6C) {
      goto LABEL_20;
    }
    if (__CFADD__(v15++, 1))
    {
      ERR_put_error(3, 4095, 113, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_blind.c", 337);
      if (b) {
        return v11;
      }
      goto LABEL_21;
    }
    ERR_clear_error();
    if (!BN_rand_range(*(BIGNUM **)v11, *((const BIGNUM **)v11 + 3))) {
      goto LABEL_20;
    }
  }
  int v18 = (uint64_t (*)(void, void, void, void, BN_CTX *))*((void *)v11 + 9);
  if (v18 && *((void *)v11 + 8))
  {
    int v19 = v18(*(void *)v11, *(void *)v11, *((void *)v11 + 2), *((void *)v11 + 3), ctx);
    if (b) {
      return v11;
    }
  }
  else
  {
    int v19 = BN_mod_exp_ct(*(BIGNUM **)v11, *(const BIGNUM **)v11, *((const BIGNUM **)v11 + 2), *((const BIGNUM **)v11 + 3), ctx);
    if (b) {
      return v11;
    }
  }
  if (!v19) {
    goto LABEL_21;
  }
  return v11;
}

int BN_BLINDING_convert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx)
{
  return BN_BLINDING_convert_ex(n, 0, b, ctx);
}

int BN_BLINDING_convert_ex(BIGNUM *n, BIGNUM *r, BN_BLINDING *b, BN_CTX *a4)
{
  if (!*(void *)b || !*((void *)b + 1))
  {
    ERR_put_error(3, 4095, 107, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_blind.c", 232);
    return 0;
  }
  if (*((_DWORD *)b + 12) == -1)
  {
    *((_DWORD *)b + 12) = 0;
    if (r)
    {
LABEL_6:
      BOOL v9 = bn_copy(r, *((const BIGNUM **)b + 1));
      return BN_mod_mul(n, n, *(const BIGNUM **)b, *((const BIGNUM **)b + 3), a4) && v9;
    }
  }
  else
  {
    int result = BN_BLINDING_update(b, a4);
    if (!result) {
      return result;
    }
    if (r) {
      goto LABEL_6;
    }
  }
  BOOL v9 = 1;
  return BN_mod_mul(n, n, *(const BIGNUM **)b, *((const BIGNUM **)b + 3), a4) && v9;
}

int BN_BLINDING_invert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx)
{
  return BN_BLINDING_invert_ex(n, 0, b, ctx);
}

int BN_BLINDING_invert_ex(BIGNUM *n, const BIGNUM *r, BN_BLINDING *b, BN_CTX *a4)
{
  if (r)
  {
    int v5 = r;
  }
  else
  {
    int v5 = (const BIGNUM *)*((void *)b + 1);
    if (!v5)
    {
      ERR_put_error(3, 4095, 107, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_blind.c", 269);
      return 0;
    }
  }
  int v6 = (const BIGNUM *)*((void *)b + 3);
  return BN_mod_mul(n, n, v5, v6, a4);
}

uint64_t BN_BLINDING_thread_id(uint64_t a1)
{
  return a1 + 32;
}

unint64_t BN_BLINDING_get_flags(const BN_BLINDING *a1)
{
  return *((void *)a1 + 7);
}

void BN_BLINDING_set_flags(BN_BLINDING *a1, unint64_t a2)
{
  *((void *)a1 + 7) = a2;
}

void *EVP_rc4_hmac_md5()
{
  return &r4_hmac_md5_cipher;
}

uint64_t rc4_hmac_md5_init_key(const EVP_CIPHER_CTX *a1, const unsigned __int8 *a2)
{
  cipher_unsigned int data = (char *)a1->cipher_data;
  int v4 = EVP_CIPHER_CTX_key_length(a1);
  RC4_set_key((RC4_KEY *)cipher_data, v4, a2);
  MD5_Init((_MD5_CTX *)(cipher_data + 1032));
  long long v5 = *(_OWORD *)(cipher_data + 1064);
  long long v6 = *(_OWORD *)(cipher_data + 1080);
  *(_OWORD *)(cipher_data + 1156) = v5;
  *(_OWORD *)(cipher_data + 1172) = v6;
  long long v7 = *(_OWORD *)(cipher_data + 1096);
  *(_OWORD *)(cipher_data + 1188) = v7;
  long long v8 = *(_OWORD *)(cipher_data + 1108);
  *((_OWORD *)cipher_data + 75) = v8;
  long long v9 = *(_OWORD *)(cipher_data + 1032);
  long long v10 = *(_OWORD *)(cipher_data + 1048);
  *(_OWORD *)(cipher_data + 1124) = v9;
  *(_OWORD *)(cipher_data + 1140) = v10;
  *((_OWORD *)cipher_data + 78) = v5;
  *((_OWORD *)cipher_data + 79) = v6;
  *((_OWORD *)cipher_data + 80) = v7;
  *(_OWORD *)(cipher_data + 1292) = v8;
  *((_OWORD *)cipher_data + 76) = v9;
  *((_OWORD *)cipher_data + 77) = v10;
  *((void *)cipher_data + 164) = -1;
  return 1;
}

uint64_t rc4_hmac_md5_cipher(uint64_t a1, unsigned __int8 *outdata, unsigned __int8 *indata, size_t len)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(a1 + 120);
  size_t v5 = *(void *)(v4 + 1312);
  if (v5 != -1 && v5 + 16 != len) {
    return 0;
  }
  if (*(_DWORD *)(a1 + 16))
  {
    if (v5 == -1) {
      size_t v10 = len;
    }
    else {
      size_t v10 = *(void *)(v4 + 1312);
    }
    MD5_Update((_MD5_CTX *)(v4 + 1216), indata, v10);
    if (v10 == len)
    {
      BOOL v11 = (RC4_KEY *)v4;
      unint64_t v12 = len;
      int v13 = indata;
    }
    else
    {
      if (indata != outdata) {
        memcpy(outdata, indata, v10);
      }
      MD5_Final(&outdata[v10], (_MD5_CTX *)(v4 + 1216));
      long long v18 = *(_OWORD *)(v4 + 1172);
      *(_OWORD *)(v4 + 1248) = *(_OWORD *)(v4 + 1156);
      *(_OWORD *)(v4 + 1264) = v18;
      *(_OWORD *)(v4 + 1280) = *(_OWORD *)(v4 + 1188);
      *(_OWORD *)(v4 + 1292) = *(_OWORD *)(v4 + 1200);
      long long v19 = *(_OWORD *)(v4 + 1140);
      *(_OWORD *)(v4 + 12++*(_DWORD *)(*(void *)(result + 8) + 16) = *(_OWORD *)(v4 + 1124);
      *(_OWORD *)(v4 + 1232) = v19;
      MD5_Update((_MD5_CTX *)(v4 + 1216), &outdata[v10], 0x10uLL);
      MD5_Final(&outdata[v10], (_MD5_CTX *)(v4 + 1216));
      BOOL v11 = (RC4_KEY *)v4;
      unint64_t v12 = len;
      int v13 = outdata;
    }
    RC4(v11, v12, v13, outdata);
  }
  else
  {
    RC4(*(RC4_KEY **)(a1 + 120), len, indata, outdata);
    if (v5 == -1)
    {
      MD5_Update((_MD5_CTX *)(v4 + 1216), outdata, len);
    }
    else
    {
      MD5_Update((_MD5_CTX *)(v4 + 1216), outdata, v5);
      MD5_Final(md, (_MD5_CTX *)(v4 + 1216));
      long long v14 = *(_OWORD *)(v4 + 1172);
      *(_OWORD *)(v4 + 1248) = *(_OWORD *)(v4 + 1156);
      *(_OWORD *)(v4 + 1264) = v14;
      *(_OWORD *)(v4 + 1280) = *(_OWORD *)(v4 + 1188);
      *(_OWORD *)(v4 + 1292) = *(_OWORD *)(v4 + 1200);
      long long v15 = *(_OWORD *)(v4 + 1140);
      *(_OWORD *)(v4 + 12++*(_DWORD *)(*(void *)(result + 8) + 16) = *(_OWORD *)(v4 + 1124);
      *(_OWORD *)(v4 + 1232) = v15;
      MD5_Update((_MD5_CTX *)(v4 + 1216), md, 0x10uLL);
      MD5_Final(md, (_MD5_CTX *)(v4 + 1216));
      if (*(void *)&outdata[v5] != *(void *)md || *(void *)&outdata[v5 + 8] != v21) {
        return 0;
      }
    }
  }
  *(void *)(v4 + 1312) = -1;
  return 1;
}

uint64_t rc4_hmac_md5_ctrl(uint64_t a1, int a2, int a3, unsigned char *data)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(void *)(a1 + 120);
  if (a2 == 22)
  {
    uint64_t v7 = a3 - 2;
    unsigned int v8 = __rev16(*(unsigned __int16 *)&data[v7]);
    if (!*(_DWORD *)(a1 + 16))
    {
      BOOL v9 = v8 >= 0x10;
      v8 -= 16;
      if (!v9) {
        return 0xFFFFFFFFLL;
      }
      data[v7] = BYTE1(v8);
      data[a3 - 1] = v8;
    }
    long long v15 = *(_OWORD *)(v6 + 1080);
    *(_OWORD *)(v6 + 1248) = *(_OWORD *)(v6 + 1064);
    *(_OWORD *)(v6 + 1264) = v15;
    *(_OWORD *)(v6 + 1280) = *(_OWORD *)(v6 + 1096);
    *(_OWORD *)(v6 + 1292) = *(_OWORD *)(v6 + 1108);
    long long v16 = *(_OWORD *)(v6 + 1048);
    *(_OWORD *)(v6 + 12++*(_DWORD *)(*(void *)(result + 8) + 16) = *(_OWORD *)(v6 + 1032);
    *(void *)(v6 + 1312) = v8;
    *(_OWORD *)(v6 + 1232) = v16;
    MD5_Update((_MD5_CTX *)(v6 + 1216), data, a3);
    return 16;
  }
  if (a2 != 23) {
    return 0xFFFFFFFFLL;
  }
  memset(v17, 0, sizeof(v17));
  if (a3 < 65)
  {
    __memcpy_chk();
  }
  else
  {
    MD5_Init((_MD5_CTX *)(v6 + 1032));
    MD5_Update((_MD5_CTX *)(v6 + 1032), data, a3);
    MD5_Final((unsigned __int8 *)v17, (_MD5_CTX *)(v6 + 1032));
  }
  uint64_t v11 = 0;
  v12.i64[0] = 0x3636363636363636;
  v12.i64[1] = 0x3636363636363636;
  do
  {
    v17[v11] = veorq_s8((int8x16_t)v17[v11], v12);
    ++v11;
  }
  while (v11 != 4);
  MD5_Init((_MD5_CTX *)(v6 + 1032));
  MD5_Update((_MD5_CTX *)(v6 + 1032), v17, 0x40uLL);
  uint64_t v13 = 0;
  v14.i64[0] = 0x6A6A6A6A6A6A6A6ALL;
  v14.i64[1] = 0x6A6A6A6A6A6A6A6ALL;
  do
  {
    v17[v13] = veorq_s8((int8x16_t)v17[v13], v14);
    ++v13;
  }
  while (v13 != 4);
  MD5_Init((_MD5_CTX *)(v6 + 1124));
  MD5_Update((_MD5_CTX *)(v6 + 1124), v17, 0x40uLL);
  return 1;
}

void *EVP_ENCODE_CTX_new()
{
  return malloc_type_calloc(1uLL, 0x60uLL, 0x1000040565EDBD2uLL);
}

void EVP_EncodeInit(EVP_ENCODE_CTX *ctx)
{
  *(void *)&ctx->uint64_t num = 0x3000000000;
  ctx->line_uint64_t num = 0;
}

void EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx, unsigned __int8 *out, int *outl, const unsigned __int8 *in, int inl)
{
  *int outl = 0;
  if (inl >= 1)
  {
    int v5 = inl;
    uint64_t v6 = in;
    int length = ctx->length;
    if (length >= 81) {
      OpenSSLDie("/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/encode.c", 156, "ctx->length <= (int)sizeof(ctx->enc_data)");
    }
    uint64_t num = ctx->num;
    uint64_t v12 = length - num;
    int v13 = inl - v12;
    if (inl >= (int)v12)
    {
      if (num)
      {
        memcpy(&ctx->enc_data[num], in, length - num);
        v6 += v12;
        int v14 = EVP_EncodeBlock(out, ctx->enc_data, ctx->length);
        ctx->uint64_t num = 0;
        long long v15 = &out[v14];
        *(_WORD *)long long v15 = 10;
        out = v15 + 1;
        unint64_t v16 = v14 + 1;
        int length = ctx->length;
        int v5 = v13;
      }
      else
      {
        unint64_t v16 = 0;
      }
      if (v5 >= length && !(v16 >> 31))
      {
        do
        {
          int v17 = EVP_EncodeBlock(out, v6, length);
          uint64_t v18 = ctx->length;
          v6 += v18;
          v5 -= v18;
          long long v19 = &out[v17];
          *(_WORD *)long long v19 = 10;
          out = v19 + 1;
          v16 += v17 + 1;
          int length = ctx->length;
        }
        while (v5 >= length && v16 >> 31 == 0);
      }
      if (v16 >> 31)
      {
        *int outl = 0;
      }
      else
      {
        if (v5) {
          memcpy(ctx->enc_data, v6, v5);
        }
        ctx->uint64_t num = v5;
        *int outl = v16;
      }
    }
    else
    {
      memcpy(&ctx->enc_data[num], in, inl);
      ctx->num += v5;
    }
  }
}

int EVP_EncodeBlock(unsigned __int8 *t, const unsigned __int8 *f, int n)
{
  if (n < 1)
  {
    LODWORD(v4) = 0;
  }
  else
  {
    uint64_t v4 = 0;
    int v5 = f + 1;
    while (1)
    {
      unint64_t v6 = *(v5 - 1);
      unint64_t v7 = v6 << 16;
      if (n <= 2) {
        break;
      }
      int v8 = *v5;
      int v9 = v5[1];
      unint64_t v10 = v9 | (v8 << 8);
      unint64_t v11 = v7 | (v8 << 8);
      uint64_t v12 = &t[v4];
      unsigned __int8 *v12 = data_bin2ascii[v6 >> 2];
      v12[1] = data_bin2ascii[(v11 >> 12) & 0x3F];
      v12[2] = data_bin2ascii[(v10 >> 6) & 0x3F];
      void v12[3] = data_bin2ascii[v9 & 0x3F];
      v4 += 4;
      v5 += 3;
      n -= 3;
      if (!n)
      {
        t += v4;
        goto LABEL_12;
      }
    }
    if (n == 2) {
      v7 |= (unint64_t)*v5 << 8;
    }
    int v13 = &t[v4];
    unsigned __int8 *v13 = data_bin2ascii[v7 >> 18];
    v13[1] = data_bin2ascii[(v7 >> 12) & 0x3F];
    char v14 = 61;
    if (n != 1) {
      char v14 = data_bin2ascii[(v7 >> 6) & 0x3F];
    }
    _OWORD v13[2] = v14;
    void v13[3] = 61;
    t = v13 + 4;
    LODWORD(v4) = v4 + 4;
  }
LABEL_12:
  *t = 0;
  return v4;
}

void EVP_EncodeFinal(EVP_ENCODE_CTX *ctx, unsigned __int8 *out, int *outl)
{
  if (ctx->num)
  {
    int v6 = EVP_EncodeBlock(out, ctx->enc_data, ctx->num);
    out[v6] = 10;
    int v7 = v6 + 1;
    out[v6 + 1] = 0;
    ctx->uint64_t num = 0;
  }
  else
  {
    int v7 = 0;
  }
  *int outl = v7;
}

void EVP_DecodeInit(EVP_ENCODE_CTX *ctx)
{
  *(void *)&ctx->uint64_t num = 0;
  *(void *)&ctx->line_uint64_t num = 0;
}

int EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx, unsigned __int8 *out, int *outl, const unsigned __int8 *in, int inl)
{
  int v9 = ctx;
  enc_unsigned int data = ctx->enc_data;
  int num = ctx->num;
  if (ctx->num < 1 || enc_data[ctx->num - 1] != 61)
  {
    int v12 = 0;
    if (inl) {
      goto LABEL_8;
    }
LABEL_29:
    int result = 0;
    int v15 = 0;
    goto LABEL_48;
  }
  int v12 = 1;
  if (num >= 2)
  {
    if (enc_data[num - 2] == 61) {
      int v12 = 2;
    }
    else {
      int v12 = 1;
    }
  }
  if (!inl) {
    goto LABEL_29;
  }
LABEL_8:
  int v29 = outl;
  if (inl >= 1)
  {
    uint64_t v13 = 0;
    BOOL v14 = 0;
    int v15 = 0;
    int v17 = data_ascii2bin;
    while (1)
    {
      if ((char)in[v13] < 0 || (int v18 = v17[in[v13]], v18 == 255))
      {
LABEL_30:
        int result = -1;
        goto LABEL_31;
      }
      int v19 = in[v13];
      if (v19 == 61)
      {
        ++v12;
      }
      else
      {
        if (v12 < 1)
        {
          int v12 = 0;
          goto LABEL_17;
        }
        if ((v18 & 0xEC) != 0xE0) {
          goto LABEL_30;
        }
      }
      if (v12 > 2) {
        goto LABEL_30;
      }
LABEL_17:
      if (v19 == 45) {
        goto LABEL_33;
      }
      if ((v18 & 0xEC) != 0xE0)
      {
        if (num > 63) {
          goto LABEL_30;
        }
        enc_data[num++] = v19;
      }
      if (num == 64)
      {
        int v20 = v17;
        int v21 = EVP_DecodeBlock(out, enc_data, 64);
        int result = -1;
        if (v21 < 0 || (BOOL v23 = __OFSUB__(v21, v12), v24 = v21 - v12, (v24 < 0) ^ v23))
        {
          int num = 0;
LABEL_31:
          int v9 = ctx;
          int outl = v29;
          goto LABEL_48;
        }
        int num = 0;
        v15 += v24;
        out += v24;
        int v17 = v20;
      }
      BOOL v14 = (int)++v13 >= inl;
      if (inl == v13) {
        goto LABEL_33;
      }
    }
  }
  int v15 = 0;
  BOOL v14 = 1;
LABEL_33:
  if (num < 1)
  {
    int v9 = ctx;
    int outl = v29;
  }
  else
  {
    int v9 = ctx;
    int outl = v29;
    if ((num & 3) != 0)
    {
      if (!v14)
      {
        int result = -1;
        goto LABEL_48;
      }
    }
    else
    {
      int v25 = EVP_DecodeBlock(out, enc_data, num);
      int num = 0;
      int result = -1;
      if (v25 < 0 || v12 > v25) {
        goto LABEL_48;
      }
      int num = 0;
      int v15 = v15 - v12 + v25;
    }
  }
  if (v12) {
    BOOL v26 = num == 0;
  }
  else {
    BOOL v26 = 0;
  }
  int v27 = !v26;
  int result = v14 & v27;
LABEL_48:
  *int outl = v15;
  v9->int num = num;
  return result;
}

int EVP_DecodeBlock(unsigned __int8 *t, const unsigned __int8 *f, int n)
{
  uint64_t v3 = n;
  if ((*(char *)f & 0x80000000) == 0)
  {
    int v4 = *f;
    do
    {
      if (v4 != 32 && v4 != 9 || (int)v3 <= 0) {
        break;
      }
      int v7 = *(char *)++f;
      --v3;
      int v4 = v7;
    }
    while ((v7 & 0x80000000) == 0);
  }
  int v8 = &f[v3 - 1];
  do
  {
    int v9 = v3;
    if ((int)v3 < 4) {
      break;
    }
    if (*(char *)v8 < 0) {
      break;
    }
    int v10 = data_ascii2bin[*v8--] & 0xEC;
    LODWORD(v3) = v3 - 1;
  }
  while (v10 == 224);
  if ((v9 & 3) != 0) {
    return -1;
  }
  if (v9 < 1) {
    return 0;
  }
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  while (1)
  {
    int v15 = (char *)&f[v13];
    int v16 = (char)f[v13] < 0 ? 255 : data_ascii2bin[f[v13]];
    int v17 = v15[1] < 0 ? 255 : data_ascii2bin[v15[1]];
    __int16 v18 = v15[2] < 0 ? 255 : data_ascii2bin[v15[2]];
    int v19 = v15[3];
    char v20 = v19 < 0 ? -1 : data_ascii2bin[v19];
    int v11 = -1;
    if ((v16 & 0x80) != 0 || (char)v17 < 0 || (char)v18 < 0 || v20 < 0) {
      break;
    }
    int v21 = &t[v14];
    unsigned __int8 *v21 = ((v17 << 12) | (v16 << 18)) >> 16;
    v21[1] = (unsigned __int16)((v18 << 6) | ((_WORD)v17 << 12)) >> 8;
    v21[2] = v20 | ((_BYTE)v18 << 6);
    v14 += 3;
    v13 += 4;
    if ((int)v13 >= v9) {
      return v14;
    }
  }
  return v11;
}

int EVP_DecodeFinal(EVP_ENCODE_CTX *ctx, unsigned __int8 *out, int *outl)
{
  *int outl = 0;
  if (!ctx->num) {
    return 1;
  }
  int v5 = EVP_DecodeBlock(out, ctx->enc_data, ctx->num);
  if ((v5 & 0x80000000) == 0)
  {
    ctx->int num = 0;
    *int outl = v5;
    return 1;
  }
  return -1;
}

void CAST_cfb64_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, const CAST_KEY *schedule, unsigned __int8 *ivec, int *num, int enc)
{
  uint64_t v10 = length;
  v20[1] = *MEMORY[0x263EF8340];
  int v13 = *num;
  if (enc)
  {
    if (length)
    {
      do
      {
        if (!v13)
        {
          v20[0] = __PAIR64__(bswap32(*((_DWORD *)ivec + 1)), bswap32(*(_DWORD *)ivec));
          CAST_encrypt(v20, schedule);
          unsigned int v14 = bswap32(HIDWORD(v20[0]));
          *(_DWORD *)ivec = bswap32(v20[0]);
          *((_DWORD *)ivec + md5_block_data_order((unint64_t)c, b, 1) = v14;
        }
        char v15 = *in++;
        unsigned __int8 v16 = ivec[v13];
        *out++ = v16 ^ v15;
        ivec[v13] = v16 ^ v15;
        int v13 = (v13 + 1) & 7;
        --v10;
      }
      while (v10);
    }
  }
  else if (length)
  {
    do
    {
      if (!v13)
      {
        v20[0] = __PAIR64__(bswap32(*((_DWORD *)ivec + 1)), bswap32(*(_DWORD *)ivec));
        CAST_encrypt(v20, schedule);
        unsigned int v17 = bswap32(HIDWORD(v20[0]));
        *(_DWORD *)ivec = bswap32(v20[0]);
        *((_DWORD *)ivec + md5_block_data_order((unint64_t)c, b, 1) = v17;
      }
      unsigned __int8 v18 = *in++;
      unsigned __int8 v19 = ivec[v13];
      ivec[v13] = v18;
      *out++ = v19 ^ v18;
      int v13 = (v13 + 1) & 7;
      --v10;
    }
    while (v10);
  }
  *int num = v13;
}

uint64_t pkey_rsa_init(uint64_t a1)
{
  uint64_t result = (uint64_t)malloc_type_calloc(1uLL, 0x50uLL, 0x107004004B23913uLL);
  if (result)
  {
    *(_DWORD *)uint64_t result = 2048;
    if (**(_DWORD **)a1 == 912) {
      int v3 = 6;
    }
    else {
      int v3 = 1;
    }
    *(_DWORD *)(result + 24) = v3;
    *(void *)(result + 48) = -2;
    *(void *)(a1 + 40) = result;
    *(void *)(a1 + 64) = result + 16;
    *(_DWORD *)(a1 + 72) = 2;
    return 1;
  }
  return result;
}

uint64_t pkey_rsa_copy(uint64_t a1, uint64_t a2)
{
  uint64_t result = pkey_rsa_init(a1);
  if (result)
  {
    uint64_t v5 = *(void *)(a2 + 40);
    uint64_t v6 = *(void *)(a1 + 40);
    *(_DWORD *)uint64_t v6 = *(_DWORD *)v5;
    if (!*(void *)(v5 + 8)
      || (BN_free(*(BIGNUM **)(v6 + 8)),
          uint64_t result = (uint64_t)BN_dup(*(const BIGNUM **)(v5 + 8)),
          (*(void *)(v6 + 8) = result) != 0))
    {
      *(_DWORD *)(v6 + 24) = *(_DWORD *)(v5 + 24);
      *(_OWORD *)(v6 + 32) = *(_OWORD *)(v5 + 32);
      if (*(void *)(v5 + 64))
      {
        free(*(void **)(v6 + 64));
        uint64_t result = (uint64_t)malloc_type_calloc(1uLL, *(void *)(v5 + 72), 0x12A371CAuLL);
        *(void *)(v6 + 64) = result;
        if (!result) {
          return result;
        }
        memcpy((void *)result, *(const void **)(v5 + 64), *(void *)(v5 + 72));
        *(void *)(v6 + 72) = *(void *)(v5 + 72);
      }
      return 1;
    }
  }
  return result;
}

void pkey_rsa_cleanup(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1)
  {
    BN_free(*(BIGNUM **)(v1 + 8));
    free(*(void **)(v1 + 56));
    free(*(void **)(v1 + 64));
    free((void *)v1);
  }
}

uint64_t pkey_rsa_keygen(uint64_t a1, EVP_PKEY *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  memset(v18, 0, sizeof(v18));
  if (!*(void *)(v4 + 8))
  {
    int v8 = BN_new();
    *(void *)(v4 + 8) = v8;
    if (!v8 || !BN_set_word(v8, 0x10001uLL)) {
      return 0;
    }
  }
  uint64_t v5 = RSA_new();
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v5;
  if (*(void *)(a1 + 56))
  {
    int v7 = (BN_GENCB *)v18;
    evp_pkey_set_cb_translate((uint64_t)v18, a1);
  }
  else
  {
    int v7 = 0;
  }
  uint64_t key = RSA_generate_key_ex(v6, *(_DWORD *)v4, *(BIGNUM **)(v4 + 8), v7);
  if ((int)key >= 1)
  {
    int v10 = **(_DWORD **)a1;
    if (v10 != 912)
    {
LABEL_21:
      EVP_PKEY_assign(a2, v10, (char *)v6);
      return key;
    }
    uint64_t v11 = *(void *)(a1 + 40);
    int v12 = *(EVP_MD **)(v11 + 32);
    int v13 = *(EVP_MD **)(v11 + 40);
    int v14 = *(_DWORD *)(v11 + 48);
    if (!((unint64_t)v12 | (unint64_t)v13))
    {
      if (v14 == -2)
      {
        int v10 = 912;
        goto LABEL_21;
      }
      int v13 = 0;
    }
    if (v14 == -2) {
      int v15 = 0;
    }
    else {
      int v15 = v14;
    }
    unsigned __int8 v16 = rsa_pss_params_create(v12, v13, v15);
    v6->ex_data.sk = (STACK *)v16;
    if (v16)
    {
      int v10 = **(_DWORD **)a1;
      goto LABEL_21;
    }
    RSA_free(v6);
    return 0;
  }
  RSA_free(v6);
  return key;
}

uint64_t pkey_rsa_sign(uint64_t a1, unsigned __int8 *to, void *a3, unsigned __int8 *from, size_t flen)
{
  uint64_t v10 = *(void *)(a1 + 40);
  uint64_t v11 = *(void *)(a1 + 16);
  int v12 = *(RSA **)(v11 + 32);
  int v13 = *(const EVP_MD **)(v10 + 32);
  if (!v13)
  {
    int v17 = *(_DWORD *)(v10 + 24);
    int v18 = flen;
    unsigned __int8 v19 = from;
    char v20 = to;
    int v21 = *(RSA **)(v11 + 32);
LABEL_9:
    uint64_t result = RSA_private_encrypt(v18, v19, v20, v21, v17);
    if ((result & 0x80000000) != 0) {
      return result;
    }
LABEL_10:
    *a3 = result;
    return 1;
  }
  if (EVP_MD_size(v13) != flen)
  {
    int v15 = 143;
    int v16 = 196;
    goto LABEL_12;
  }
  int v14 = *(_DWORD *)(v10 + 24);
  if (v14 != 1)
  {
    if (v14 == 6)
    {
      if (!setup_tbuf(v10, a1)
        || !RSA_padding_add_PKCS1_PSS_mgf1(v12, *(unsigned __int8 **)(v10 + 56), from, *(const EVP_MD **)(v10 + 32), *(const EVP_MD **)(v10 + 40), *(_DWORD *)(v10 + 48)))
      {
        return 0xFFFFFFFFLL;
      }
      int v18 = RSA_size(v12);
      unsigned __int8 v19 = *(const unsigned __int8 **)(v10 + 56);
      char v20 = to;
      int v21 = v12;
      int v17 = 3;
    }
    else
    {
      if (v14 != 5) {
        return 0xFFFFFFFFLL;
      }
      if (flen + 1 > EVP_PKEY_size(*(EVP_PKEY **)(a1 + 16)))
      {
        int v15 = 120;
        int v16 = 202;
LABEL_12:
        ERR_put_error(4, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pmeth.c", v16);
        return 0xFFFFFFFFLL;
      }
      if (!setup_tbuf(v10, a1))
      {
        int v15 = 65;
        int v16 = 206;
        goto LABEL_12;
      }
      memcpy(*(void **)(v10 + 56), from, flen);
      int v24 = EVP_MD_type(*(const EVP_MD **)(v10 + 32));
      *(unsigned char *)(*(void *)(v10 + 56) + fSHA256_Update(c, data, len) = RSA_X931_hash_id(v24);
      unsigned __int8 v19 = *(const unsigned __int8 **)(v10 + 56);
      int v18 = flen + 1;
      char v20 = to;
      int v21 = v12;
      int v17 = 5;
    }
    goto LABEL_9;
  }
  siguint64_t len = 0;
  int v23 = EVP_MD_type(*(const EVP_MD **)(v10 + 32));
  uint64_t result = RSA_sign(v23, from, flen, to, &siglen, v12);
  if ((int)result > 0)
  {
    uint64_t result = siglen;
    if ((siglen & 0x80000000) == 0) {
      goto LABEL_10;
    }
  }
  return result;
}

uint64_t pkey_rsa_verify(uint64_t a1, unsigned __int8 *a2, size_t a3, const void *a4, size_t a5)
{
  uint64_t v10 = *(void *)(a1 + 40);
  uint64_t v11 = *(RSA **)(*(void *)(a1 + 16) + 32);
  int v12 = *(const EVP_MD **)(v10 + 32);
  if (!v12)
  {
    if (setup_tbuf(v10, a1))
    {
      int v15 = RSA_public_decrypt(a3, a2, *(unsigned __int8 **)(v10 + 56), v11, *(_DWORD *)(v10 + 24));
      if (v15 >= 1)
      {
        size_t v16 = v15;
        goto LABEL_9;
      }
      return 0;
    }
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)(v10 + 24) != 1)
  {
    if (EVP_MD_size(v12) == a5)
    {
      int v17 = *(_DWORD *)(v10 + 24);
      if (v17 == 6)
      {
        if (setup_tbuf(v10, a1))
        {
          if (RSA_public_decrypt(a3, a2, *(unsigned __int8 **)(v10 + 56), v11, 3) >= 1) {
            return (int)RSA_verify_PKCS1_PSS_mgf1(v11, a4, *(const EVP_MD **)(v10 + 32), *(const EVP_MD **)(v10 + 40), *(char **)(v10 + 56), *(_DWORD *)(v10 + 48)) > 0;
          }
          return 0;
        }
      }
      else if (v17 == 5)
      {
        size_t v18 = 0;
        if ((int)pkey_rsa_verifyrecover(a1, 0, &v18, a2, a3) >= 1)
        {
          size_t v16 = v18;
LABEL_9:
          if (v16 == a5) {
            return timingsafe_bcmp(a4, *(const void **)(v10 + 56), a5) == 0;
          }
          return 0;
        }
        return 0;
      }
    }
    else
    {
      ERR_put_error(4, 4095, 143, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pmeth.c", 304);
    }
    return 0xFFFFFFFFLL;
  }
  int v13 = EVP_MD_type(v12);
  return RSA_verify(v13, (const unsigned __int8 *)a4, a5, a2, a3, v11);
}

uint64_t pkey_rsa_verifyrecover(uint64_t a1, unsigned __int8 *to, size_t *a3, unsigned __int8 *from, size_t flen)
{
  uint64_t v10 = *(void *)(a1 + 40);
  uint64_t v11 = *(const EVP_MD **)(v10 + 32);
  if (v11)
  {
    int v12 = *(_DWORD *)(v10 + 24);
    if (v12 != 1)
    {
      if (v12 != 5 || !setup_tbuf(v10, a1)) {
        return 0xFFFFFFFFLL;
      }
      int v13 = RSA_public_decrypt(flen, from, *(unsigned __int8 **)(v10 + 56), *(RSA **)(*(void *)(a1 + 16) + 32), 5);
      size_t v14 = (v13 - 1);
      if (v13 >= 1)
      {
        int v15 = *(unsigned __int8 *)(*(void *)(v10 + 56) + v14);
        int v16 = EVP_MD_type(*(const EVP_MD **)(v10 + 32));
        if (RSA_X931_hash_id(v16) == v15)
        {
          if (v14 == EVP_MD_size(*(const EVP_MD **)(v10 + 32)))
          {
            if (to) {
              memcpy(to, *(const void **)(v10 + 56), v14);
            }
            goto LABEL_16;
          }
          int v19 = 143;
          int v20 = 265;
        }
        else
        {
          int v19 = 100;
          int v20 = 261;
        }
        ERR_put_error(4, 4095, v19, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pmeth.c", v20);
      }
      return 0;
    }
    uint64_t v21 = 0;
    int v18 = EVP_MD_type(v11);
    if ((int)int_rsa_verify(v18, 0, 0, to, &v21, from, flen, *(RSA **)(*(void *)(a1 + 16) + 32)) <= 0) {
      return 0;
    }
    uint64_t result = v21;
    if ((v21 & 0x80000000) != 0) {
      return result;
    }
LABEL_15:
    size_t v14 = result;
LABEL_16:
    *a3 = v14;
    return 1;
  }
  uint64_t result = RSA_public_decrypt(flen, from, to, *(RSA **)(*(void *)(a1 + 16) + 32), *(_DWORD *)(v10 + 24));
  if ((result & 0x80000000) == 0) {
    goto LABEL_15;
  }
  return result;
}

uint64_t pkey_rsa_encrypt(uint64_t a1, unsigned __int8 *to, void *a3, unsigned __int8 *from, int flen)
{
  uint64_t v9 = *(void *)(a1 + 40);
  int v10 = *(_DWORD *)(v9 + 24);
  if (v10 == 4)
  {
    int v11 = RSA_size(*(const RSA **)(*(void *)(a1 + 16) + 32));
    if (setup_tbuf(v9, a1)) {
      RSA_padding_add_PKCS1_OAEP_mgf1(*(unsigned char **)(v9 + 56), v11, from, flen, *(const void **)(v9 + 64), *(_DWORD *)(v9 + 72), *(EVP_MD **)(v9 + 32), *(EVP_MD **)(v9 + 40));
    }
    return 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t result = RSA_public_encrypt(flen, from, to, *(RSA **)(*(void *)(a1 + 16) + 32), v10);
    if ((result & 0x80000000) == 0)
    {
      *a3 = result;
      return 1;
    }
  }
  return result;
}

uint64_t pkey_rsa_decrypt(uint64_t a1, unsigned __int8 *to, void *a3, unsigned __int8 *from, int flen)
{
  uint64_t v10 = *(void *)(a1 + 40);
  int v11 = *(_DWORD *)(v10 + 24);
  if (v11 != 4)
  {
    uint64_t v13 = RSA_private_decrypt(flen, from, to, *(RSA **)(*(void *)(a1 + 16) + 32), v11);
LABEL_6:
    uint64_t v12 = v13;
    if ((v13 & 0x80000000) == 0)
    {
      *a3 = v13;
      return 1;
    }
    return v12;
  }
  if (!setup_tbuf(*(void *)(a1 + 40), a1)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v12 = RSA_private_decrypt(flen, from, *(unsigned __int8 **)(v10 + 56), *(RSA **)(*(void *)(a1 + 16) + 32), 3);
  if ((int)v12 >= 1)
  {
    uint64_t v13 = RSA_padding_check_PKCS1_OAEP_mgf1(to, v12, *(void *)(v10 + 56), v12, v12, *(const void **)(v10 + 64), *(_DWORD *)(v10 + 72), *(EVP_MD **)(v10 + 32), *(const EVP_MD **)(v10 + 40));
    goto LABEL_6;
  }
  return v12;
}

uint64_t pkey_rsa_ctrl(uint64_t a1, int a2, int a3, EVP_MD *a4)
{
  uint64_t v6 = *(void *)(a1 + 40);
  switch(a2)
  {
    case 4097:
      if ((a3 - 1) > 5) {
        goto LABEL_61;
      }
      uint64_t result = check_padding_md(*(const EVP_MD **)(v6 + 32), a3);
      if (!result) {
        return result;
      }
      if (a3 == 6)
      {
        if ((*(unsigned char *)(a1 + 32) & 0x18) != 0) {
          goto LABEL_25;
        }
        goto LABEL_61;
      }
      if (**(_DWORD **)a1 == 912) {
        goto LABEL_61;
      }
      if (a3 == 4)
      {
        if ((*(unsigned char *)(a1 + 33) & 3) != 0)
        {
LABEL_25:
          if (!*(void *)(v6 + 32)) {
            *(void *)(v6 + 32) = EVP_sha1();
          }
          goto LABEL_68;
        }
LABEL_61:
        int v10 = 144;
        int v11 = 476;
        goto LABEL_62;
      }
LABEL_68:
      *(_DWORD *)(v6 + 24) = a3;
      return 1;
    case 4098:
    case 4103:
      if (*(_DWORD *)(v6 + 24) != 6)
      {
        int v10 = 146;
        int v11 = 486;
        goto LABEL_62;
      }
      if (a2 == 4103)
      {
        int v8 = *(_DWORD *)(v6 + 48);
LABEL_34:
        a4->type = v8;
        return 1;
      }
      if (a3 < -3) {
        return 4294967294;
      }
      int v17 = *(_DWORD *)(v6 + 52);
      if (v17 == -1) {
        goto LABEL_74;
      }
      if (a3 == -1)
      {
        if (v17 > EVP_MD_size(*(const EVP_MD **)(v6 + 32))) {
          goto LABEL_73;
        }
      }
      else
      {
        if (a3 == -2)
        {
          if (*(_DWORD *)(a1 + 32) == 16)
          {
            int v10 = 146;
            int v11 = 497;
            goto LABEL_62;
          }
          goto LABEL_74;
        }
        if ((a3 & 0x80000000) == 0 && v17 > a3)
        {
LABEL_73:
          int v14 = 164;
          int v15 = 503;
          goto LABEL_48;
        }
      }
LABEL_74:
      *(_DWORD *)(v6 + 48) = a3;
      return 1;
    case 4099:
      if (a3 <= 511)
      {
        int v10 = 120;
        int v11 = 513;
        goto LABEL_62;
      }
      *(_DWORD *)uint64_t v6 = a3;
      return 1;
    case 4100:
      if (!a4 || !BN_is_odd((uint64_t)a4) || BN_is_one((uint64_t)a4))
      {
        int v10 = 101;
        int v11 = 522;
        goto LABEL_62;
      }
      BN_free(*(BIGNUM **)(v6 + 8));
      *(void *)(v6 + 8) = a4;
      return 1;
    case 4101:
    case 4104:
      if ((*(_DWORD *)(v6 + 24) | 2) != 6)
      {
        int v10 = 156;
        int v11 = 561;
        goto LABEL_62;
      }
      if (a2 == 4104)
      {
        uint64_t v12 = *(void *)(v6 + 40);
        if (v12) {
          goto LABEL_15;
        }
        goto LABEL_14;
      }
      if (*(_DWORD *)(v6 + 52) == -1)
      {
        *(void *)(v6 + 40) = a4;
        return 1;
      }
      int v16 = EVP_MD_type(*(const EVP_MD **)(v6 + 40));
      if (v16 == EVP_MD_type(a4)) {
        return 1;
      }
      int v14 = 152;
      int v15 = 573;
LABEL_48:
      ERR_put_error(4, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pmeth.c", v15);
      return 0;
    case 4102:
      int v8 = *(_DWORD *)(v6 + 24);
      goto LABEL_34;
    case 4105:
    case 4107:
      if (*(_DWORD *)(v6 + 24) != 4)
      {
        int v10 = 141;
        int v11 = 532;
        goto LABEL_62;
      }
      if (a2 == 4107)
      {
LABEL_14:
        uint64_t v12 = *(void *)(v6 + 32);
LABEL_15:
        *(void *)&a4->type = v12;
      }
      else
      {
LABEL_43:
        *(void *)(v6 + 32) = a4;
      }
      return 1;
    case 4106:
      if (*(_DWORD *)(v6 + 24) != 4)
      {
        int v10 = 141;
        int v11 = 582;
        goto LABEL_62;
      }
      free(*(void **)(v6 + 64));
      if (a3 >= 1 && a4)
      {
        *(void *)(v6 + 64) = a4;
        *(void *)(v6 + 72) = a3;
      }
      else
      {
        *(void *)(v6 + 64) = 0;
        *(void *)(v6 + 72) = 0;
      }
      return 1;
    case 4108:
      if (*(_DWORD *)(v6 + 24) == 4)
      {
        *(void *)&a4->type = *(void *)(v6 + 64);
        return *(unsigned int *)(v6 + 72);
      }
      else
      {
        int v10 = 141;
        int v11 = 597;
LABEL_62:
        ERR_put_error(4, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pmeth.c", v11);
        return 4294967294;
      }
    default:
      uint64_t result = 1;
      switch(a2)
      {
        case 1:
          uint64_t result = check_padding_md(a4, *(_DWORD *)(v6 + 24));
          if (!result) {
            return result;
          }
          if (*(_DWORD *)(v6 + 52) == -1) {
            goto LABEL_43;
          }
          int v13 = EVP_MD_type(*(const EVP_MD **)(v6 + 32));
          if (v13 == EVP_MD_type(a4)) {
            return 1;
          }
          int v14 = 145;
          int v15 = 547;
          break;
        case 2:
          goto LABEL_7;
        case 3:
        case 4:
        case 9:
        case 10:
          if (**(_DWORD **)a1 != 912) {
            return result;
          }
LABEL_7:
          int v10 = 148;
          int v11 = 621;
          goto LABEL_62;
        case 5:
        case 7:
        case 11:
          return result;
        case 13:
          *(void *)&a4->type = *(void *)(v6 + 32);
          return result;
        default:
          return 4294967294;
      }
      goto LABEL_48;
  }
}

uint64_t pkey_rsa_ctrl_str(uint64_t *a1, char *__s1, char *a3)
{
  if (!a3)
  {
    ERR_put_error(4, 4095, 147, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pmeth.c", 634);
    return 0;
  }
  if (!strcmp(__s1, "rsa_padding_mode"))
  {
    if (strcmp(a3, "pkcs1")
      && strcmp(a3, "none")
      && strcmp(a3, "oeap")
      && strcmp(a3, "oaep")
      && strcmp(a3, "x931")
      && strcmp(a3, "pss"))
    {
      ERR_put_error(4, 4095, 118, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pmeth.c", 652);
      return 4294967294;
    }
    int v10 = a1;
    int v11 = -1;
    goto LABEL_40;
  }
  if (!strcmp(__s1, "rsa_pss_saltlen"))
  {
    if (strcmp(a3, "digest") && strcmp(a3, "max") && strcmp(a3, "auto")) {
      atoi(a3);
    }
    int v10 = a1;
    int v11 = 24;
    goto LABEL_40;
  }
  if (!strcmp(__s1, "rsa_keygen_bits"))
  {
    atoi(a3);
    int v10 = a1;
    int v11 = 4;
LABEL_40:
    return RSA_pkey_ctx_ctrl(v10, v11);
  }
  if (!strcmp(__s1, "rsa_keygen_pubexp"))
  {
    uint64_t len = 0;
    if (BN_asc2bn((BIGNUM **)&len, (uint64_t)a3))
    {
      uint64_t v8 = RSA_pkey_ctx_ctrl(a1, 4);
      if ((int)v8 <= 0) {
        BN_free((BIGNUM *)len);
      }
      return v8;
    }
    return 0;
  }
  if (!strcmp(__s1, "rsa_mgf1_md"))
  {
    uint64_t v12 = a1;
    int v13 = 1016;
LABEL_46:
    int v14 = 4101;
LABEL_47:
    return EVP_PKEY_CTX_md(v12, v13, v14, a3);
  }
  if (*(_DWORD *)*a1 != 912)
  {
LABEL_11:
    if (strcmp(__s1, "rsa_oaep_md"))
    {
      if (!strcmp(__s1, "rsa_oaep_label"))
      {
        uint64_t len = 0;
        uint64_t v6 = string_to_hex(a3, &len);
        if (v6)
        {
          int v7 = v6;
          uint64_t v8 = EVP_PKEY_CTX_ctrl(a1, 6, 768);
          if ((int)v8 <= 0) {
            free(v7);
          }
          return v8;
        }
        return 0;
      }
      return 4294967294;
    }
    uint64_t v12 = a1;
    int v13 = 768;
    int v14 = 4105;
    goto LABEL_47;
  }
  if (!strcmp(__s1, "rsa_pss_keygen_mgf1_md"))
  {
    uint64_t v12 = a1;
    int v13 = 4;
    goto LABEL_46;
  }
  if (!strcmp(__s1, "rsa_pss_keygen_md"))
  {
    uint64_t v12 = a1;
    int v13 = 4;
    int v14 = 1;
    goto LABEL_47;
  }
  if (strcmp(__s1, "rsa_pss_keygen_saltlen")) {
    goto LABEL_11;
  }
  atoi(a3);
  return EVP_PKEY_CTX_ctrl(a1, 912, 4);
}

uint64_t pkey_pss_init(uint64_t a1)
{
  uint64_t result = 0;
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v12 = 0;
  muint64_t d = 0;
  int v11 = 0;
  if (**(_DWORD **)a1 == 912)
  {
    uint64_t v4 = *(const RSA **)(*(void *)(a1 + 16) + 32);
    uint64_t sk = (uint64_t)v4->ex_data.sk;
    if (sk)
    {
      uint64_t result = rsa_pss_get_param(sk, (uint64_t *)&md, &v12, &v11);
      if (!result) {
        return result;
      }
      int v6 = RSA_size(v4);
      int v7 = v6 - EVP_MD_size(md);
      int v8 = v7 - ((RSA_bits((uint64_t)v4) & 7) == 1);
      int v9 = v11;
      if (v11 > v8)
      {
        ERR_put_error(4, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pmeth.c", 844);
        return 0;
      }
      uint64_t v10 = v12;
      *(void *)(v3 + 32) = md;
      *(void *)(v3 + 40) = v10;
      *(_DWORD *)(v3 + 48) = v9;
      *(_DWORD *)(v3 + 52) = v9;
    }
    return 1;
  }
  return result;
}

uint64_t setup_tbuf(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 56)) {
    return 1;
  }
  int v4 = EVP_PKEY_size(*(EVP_PKEY **)(a2 + 16));
  uint64_t v2 = 1;
  uint64_t v5 = malloc_type_calloc(1uLL, v4, 0x434431A6uLL);
  *(void *)(a1 + 56) = v5;
  if (!v5)
  {
    ERR_put_error(4, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pmeth.c", 167);
    return 0;
  }
  return v2;
}

uint64_t check_padding_md(const EVP_MD *a1, int a2)
{
  if (!a1) {
    return 1;
  }
  if (a2 == 5)
  {
    int v5 = EVP_MD_type(a1);
    if (RSA_X931_hash_id(v5) != -1) {
      return 1;
    }
    int v2 = 142;
    int v3 = 414;
    goto LABEL_18;
  }
  if (a2 == 3)
  {
    int v2 = 141;
    int v3 = 408;
LABEL_18:
    ERR_put_error(4, 4095, v2, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pmeth.c", v3);
    return 0;
  }
  int v6 = EVP_MD_type(a1);
  uint64_t result = 1;
  if (v6 > 1028)
  {
    if ((v6 - 1029) < 6) {
      return result;
    }
    goto LABEL_21;
  }
  if (v6 > 671)
  {
    if ((v6 - 672) >= 4)
    {
LABEL_21:
      int v2 = 157;
      int v3 = 439;
      goto LABEL_18;
    }
  }
  else if (((v6 - 64) > 0x35 || ((1 << (v6 - 64)) & 0x24000000000001) == 0) {
         && v6 != 4
  }
         && v6 != 257)
  {
    goto LABEL_21;
  }
  return result;
}

uint64_t Camellia_ofb128_encrypt(uint64_t a1, unsigned char *a2, unint64_t a3, uint64_t a4, uint64_t a5, unsigned int *a6)
{
  return CRYPTO_ofb128_encrypt(a1, a2, a3, a4, a5, a6, (uint64_t (*)(uint64_t, uint64_t, uint64_t))Camellia_encrypt);
}

EC_KEY *EC_KEY_new(void)
{
  return (EC_KEY *)EC_KEY_new_method(0);
}

EC_KEY *__cdecl EC_KEY_new_by_curve_name(int nid)
{
  int v2 = EC_KEY_new_method(0);
  if (v2)
  {
    int v3 = EC_GROUP_new_by_curve_name(nid);
    v2[3] = (uint64_t)v3;
    if (!v3 || (int v4 = *(unsigned int (**)(uint64_t *, EC_GROUP *))(*v2 + 40)) != 0 && !v4(v2, v3))
    {
      EC_KEY_free((EC_KEY *)v2);
      return 0;
    }
  }
  return (EC_KEY *)v2;
}

void EC_KEY_free(EC_KEY *a1)
{
  if (a1 && CRYPTO_add_lock((int *)a1 + 14, -1, 33, 0, 0) <= 0)
  {
    if (*(void *)a1)
    {
      int v2 = *(void (**)(EC_KEY *))(*(void *)a1 + 24);
      if (v2) {
        v2(a1);
      }
    }
    ENGINE_finish(*((ENGINE **)a1 + 1));
    CRYPTO_free_ex_data(16, a1, (CRYPTO_EX_DATA *)((char *)a1 + 72));
    EC_GROUP_free(*((EC_GROUP **)a1 + 3));
    EC_POINT_free(*((EC_POINT **)a1 + 4));
    BN_free(*((BIGNUM **)a1 + 5));
    EC_EX_DATA_free_all_data((void **)a1 + 8);
    freezero(a1, 0x50uLL);
  }
}

EC_KEY *__cdecl EC_KEY_copy(EC_KEY *a1, const EC_KEY *a2)
{
  if (!a1 || !a2)
  {
    ERR_put_error(16, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_key.c", 136);
    return 0;
  }
  int v3 = a1;
  uint64_t v4 = *(void *)a1;
  if (*(void *)a2 != *(void *)a1)
  {
    if (v4)
    {
      int v5 = *(void (**)(EC_KEY *))(v4 + 24);
      if (v5) {
        v5(a1);
      }
    }
    if (!ENGINE_finish(*((ENGINE **)v3 + 1))) {
      return 0;
    }
    *((void *)v3 + md5_block_data_order((unint64_t)c, b, 1) = 0;
  }
  int v6 = (const EC_GROUP *)*((void *)a2 + 3);
  if (v6)
  {
    int v7 = EC_GROUP_method_of(v6);
    EC_GROUP_free(*((EC_GROUP **)v3 + 3));
    int v8 = EC_GROUP_new(v7);
    *((void *)v3 + 3) = v8;
    if (!v8 || !EC_GROUP_copy(v8, *((const EC_GROUP **)a2 + 3))) {
      return 0;
    }
  }
  if (*((void *)a2 + 4))
  {
    if (*((void *)a2 + 3))
    {
      EC_POINT_free(*((EC_POINT **)v3 + 4));
      int v9 = EC_POINT_new(*((const EC_GROUP **)a2 + 3));
      *((void *)v3 + 4) = v9;
      if (!v9 || !EC_POINT_copy(v9, *((const EC_POINT **)a2 + 4))) {
        return 0;
      }
    }
  }
  uint64_t v10 = (const BIGNUM *)*((void *)a2 + 5);
  if (v10)
  {
    int v11 = (BIGNUM *)*((void *)v3 + 5);
    if (!v11)
    {
      int v11 = BN_new();
      *((void *)v3 + 5) = v11;
      if (!v11) {
        return 0;
      }
      uint64_t v10 = (const BIGNUM *)*((void *)a2 + 5);
    }
    if (!bn_copy(v11, v10)) {
      return 0;
    }
  }
  EC_EX_DATA_free_all_data((void **)v3 + 8);
  uint64_t v12 = (void *)((char *)a2 + 64);
  while (1)
  {
    uint64_t v12 = (void *)*v12;
    if (!v12) {
      break;
    }
    uint64_t v13 = ((uint64_t (*)(void))v12[2])(v12[1]);
    if (!v13 || !EC_EX_DATA_set_data((uint64_t)v3 + 64, v13, v12[2], v12[3], v12[4])) {
      return 0;
    }
  }
  *((void *)v3 + 6) = *((void *)a2 + 6);
  *((_DWORD *)v3 + 4) = *((_DWORD *)a2 + 4);
  *((_DWORD *)v3 + 15) = *((_DWORD *)a2 + 15);
  if (!CRYPTO_dup_ex_data(16, (CRYPTO_EX_DATA *)((char *)v3 + 72), (CRYPTO_EX_DATA *)((char *)a2 + 72))) {
    return 0;
  }
  uint64_t v15 = *(void *)a2;
  if (*(void *)a2 != *(void *)v3)
  {
    int v16 = (ENGINE *)*((void *)a2 + 1);
    if (!v16)
    {
      long long v17 = *(unint64_t *)a2;
      goto LABEL_35;
    }
    if (ENGINE_init(v16))
    {
      long long v17 = *(_OWORD *)a2;
LABEL_35:
      *(_OWORD *)int v3 = v17;
      uint64_t v15 = *(void *)a2;
      goto LABEL_36;
    }
    return 0;
  }
LABEL_36:
  if (v15)
  {
    int v18 = *(unsigned int (**)(EC_KEY *, const EC_KEY *))(v15 + 32);
    if (v18)
    {
      if (!v18(v3, a2)) {
        return 0;
      }
    }
  }
  return v3;
}

EC_KEY *__cdecl EC_KEY_dup(const EC_KEY *a1)
{
  int v2 = EC_KEY_new_method(*((ENGINE **)a1 + 1));
  int v3 = (EC_KEY *)v2;
  if (v2 && !EC_KEY_copy((EC_KEY *)v2, a1))
  {
    EC_KEY_free(v3);
    return 0;
  }
  return v3;
}

int EC_KEY_up_ref(EC_KEY *a1)
{
  return CRYPTO_add_lock((int *)a1 + 14, 1, 33, 0, 0) > 1;
}

uint64_t EC_KEY_set_ex_data(uint64_t a1, int a2, void *a3)
{
  return CRYPTO_set_ex_data((CRYPTO_EX_DATA *)(a1 + 72), a2, a3);
}

void *EC_KEY_get_ex_data(uint64_t a1, int a2)
{
  return CRYPTO_get_ex_data((const CRYPTO_EX_DATA *)(a1 + 72), a2);
}

int EC_KEY_generate_key(EC_KEY *a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)a1 + 64);
  if (v1)
  {
    return v1();
  }
  else
  {
    ERR_put_error(16, 4095, 126, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_key.c", 255);
    return 0;
  }
}

uint64_t ossl_ec_key_gen(uint64_t a1)
{
  if (!a1 || !*(void *)(a1 + 24))
  {
    ERR_put_error(16, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_key.c", 269);
    int v5 = 0;
    int v2 = 0;
LABEL_12:
    int v3 = 0;
LABEL_13:
    uint64_t v9 = 0;
    goto LABEL_14;
  }
  int v2 = BN_new();
  if (!v2)
  {
    int v5 = 0;
    goto LABEL_12;
  }
  int v3 = EC_POINT_new(*(const EC_GROUP **)(a1 + 24));
  if (!v3)
  {
    int v5 = 0;
    goto LABEL_13;
  }
  uint64_t v4 = BN_CTX_new();
  int v5 = v4;
  if (!v4) {
    goto LABEL_13;
  }
  BN_CTX_start(v4);
  int v6 = BN_CTX_get(v5);
  if (!v6) {
    goto LABEL_13;
  }
  int v7 = v6;
  if (!EC_GROUP_get_order(*(const EC_GROUP **)(a1 + 24), v6, v5)) {
    goto LABEL_13;
  }
  int v8 = (BIGNUM *)BN_value_one();
  if (!bn_rand_interval(v2, v8, v7) || !EC_POINT_mul(*(const EC_GROUP **)(a1 + 24), v3, v2, 0, 0, v5)) {
    goto LABEL_13;
  }
  BN_free(*(BIGNUM **)(a1 + 40));
  *(void *)(a1 + 40) = v2;
  EC_POINT_free(*(EC_POINT **)(a1 + 32));
  int v2 = 0;
  *(void *)(a1 + 32) = v3;
  uint64_t v9 = 1;
  int v3 = 0;
LABEL_14:
  EC_POINT_free(v3);
  BN_free(v2);
  BN_CTX_end(v5);
  BN_CTX_free(v5);
  return v9;
}

int EC_KEY_check_key(const EC_KEY *a1)
{
  if (!a1 || (v2 = (const EC_GROUP *)*((void *)a1 + 3)) == 0 || (int v3 = (const EC_POINT *)*((void *)a1 + 4)) == 0)
  {
    int v4 = 67;
    int v5 = 321;
    goto LABEL_7;
  }
  if (EC_POINT_is_at_infinity(v2, v3) < 1)
  {
    uint64_t v10 = BN_CTX_new();
    int v6 = v10;
    if (!v10) {
      goto LABEL_8;
    }
    BN_CTX_start(v10);
    int v11 = BN_CTX_get(v6);
    if (!v11) {
      goto LABEL_8;
    }
    uint64_t v12 = v11;
    int v7 = EC_POINT_new(*((const EC_GROUP **)a1 + 3));
    if (!v7) {
      goto LABEL_9;
    }
    if (EC_POINT_is_on_curve(*((const EC_GROUP **)a1 + 3), *((const EC_POINT **)a1 + 4), v6) > 0)
    {
      if (!EC_GROUP_get_order(*((const EC_GROUP **)a1 + 3), v12, v6))
      {
        int v14 = 122;
        int v15 = 349;
        goto LABEL_25;
      }
      if (!EC_POINT_mul(*((const EC_GROUP **)a1 + 3), v7, 0, *((const EC_POINT **)a1 + 4), v12, v6))
      {
        int v14 = 16;
        int v15 = 353;
        goto LABEL_25;
      }
      if (EC_POINT_is_at_infinity(*((const EC_GROUP **)a1 + 3), v7) <= 0)
      {
        int v14 = 130;
        int v15 = 357;
        goto LABEL_25;
      }
      uint64_t v13 = (const BIGNUM *)*((void *)a1 + 5);
      if (v13)
      {
        if ((BN_cmp(v13, v12) & 0x80000000) == 0)
        {
          int v14 = 130;
          int v15 = 367;
LABEL_25:
          ERR_put_error(16, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_key.c", v15);
          goto LABEL_9;
        }
        if (!EC_POINT_mul(*((const EC_GROUP **)a1 + 3), v7, *((const BIGNUM **)a1 + 5), 0, 0, v6))
        {
          int v14 = 16;
          int v15 = 372;
          goto LABEL_25;
        }
        if (EC_POINT_cmp(*((const EC_GROUP **)a1 + 3), v7, *((const EC_POINT **)a1 + 4), v6))
        {
          int v14 = 123;
          int v15 = 377;
          goto LABEL_25;
        }
      }
      int v8 = 1;
      goto LABEL_10;
    }
    int v14 = 107;
    int v15 = 343;
    goto LABEL_25;
  }
  int v4 = 106;
  int v5 = 326;
LABEL_7:
  ERR_put_error(16, 4095, v4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_key.c", v5);
  int v6 = 0;
LABEL_8:
  int v7 = 0;
LABEL_9:
  int v8 = 0;
LABEL_10:
  BN_CTX_end(v6);
  BN_CTX_free(v6);
  EC_POINT_free(v7);
  return v8;
}

uint64_t EC_KEY_set_public_key_affine_coordinates(uint64_t a1, const BIGNUM *a2, const BIGNUM *a3)
{
  if (!a1 || !a3 || !a2 || !*(void *)(a1 + 24))
  {
    ERR_put_error(16, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_key.c", 401);
    int v7 = 0;
LABEL_15:
    uint64_t v12 = 0;
    goto LABEL_16;
  }
  int v6 = BN_CTX_new();
  int v7 = v6;
  if (!v6) {
    goto LABEL_15;
  }
  BN_CTX_start(v6);
  int v8 = BN_CTX_get(v7);
  if (!v8) {
    goto LABEL_15;
  }
  uint64_t v9 = v8;
  uint64_t v10 = BN_CTX_get(v7);
  if (!v10) {
    goto LABEL_15;
  }
  int v11 = v10;
  uint64_t v12 = EC_POINT_new(*(const EC_GROUP **)(a1 + 24));
  if (v12
    && EC_POINT_set_affine_coordinates(*(const EC_GROUP **)(a1 + 24), v12, (uint64_t)a2, (uint64_t)a3, v7)
    && EC_POINT_get_affine_coordinates(*(void *)(a1 + 24), v12, (uint64_t)v9, (uint64_t)v11, v7))
  {
    if (BN_cmp(a2, v9) || BN_cmp(a3, v11))
    {
      ERR_put_error(16, 4095, 146, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_key.c", 428);
    }
    else if (EC_KEY_set_public_key((EC_KEY *)a1, v12))
    {
      uint64_t v13 = EC_KEY_check_key((const EC_KEY *)a1);
      goto LABEL_17;
    }
  }
LABEL_16:
  uint64_t v13 = 0;
LABEL_17:
  BN_CTX_end(v7);
  BN_CTX_free(v7);
  EC_POINT_free(v12);
  return v13;
}

int EC_KEY_set_public_key(EC_KEY *a1, const EC_POINT *a2)
{
  int v4 = *(uint64_t (**)(EC_KEY *, const EC_POINT *))(*(void *)a1 + 56);
  if (!v4 || (int result = v4(a1, a2)) != 0)
  {
    EC_POINT_free(*((EC_POINT **)a1 + 4));
    int v6 = EC_POINT_dup(a2, *((const EC_GROUP **)a1 + 3));
    *((void *)a1 + 4) = v6;
    return v6 != 0;
  }
  return result;
}

const EC_GROUP *__cdecl EC_KEY_get0_group(const EC_KEY *a1)
{
  return (const EC_GROUP *)*((void *)a1 + 3);
}

int EC_KEY_set_group(EC_KEY *a1, const EC_GROUP *a2)
{
  int v4 = *(uint64_t (**)(EC_KEY *, const EC_GROUP *))(*(void *)a1 + 40);
  if (!v4 || (int result = v4(a1, a2)) != 0)
  {
    EC_GROUP_free(*((EC_GROUP **)a1 + 3));
    int v6 = EC_GROUP_dup(a2);
    *((void *)a1 + 3) = v6;
    return v6 != 0;
  }
  return result;
}

const BIGNUM *__cdecl EC_KEY_get0_private_key(const EC_KEY *a1)
{
  return (const BIGNUM *)*((void *)a1 + 5);
}

int EC_KEY_set_private_key(EC_KEY *a1, const BIGNUM *a2)
{
  int v4 = *(uint64_t (**)(EC_KEY *, const BIGNUM *))(*(void *)a1 + 48);
  if (!v4 || (int result = v4(a1, a2)) != 0)
  {
    BN_free(*((BIGNUM **)a1 + 5));
    int v6 = BN_dup(a2);
    *((void *)a1 + 5) = v6;
    return v6 != 0;
  }
  return result;
}

const EC_POINT *__cdecl EC_KEY_get0_public_key(const EC_KEY *a1)
{
  return (const EC_POINT *)*((void *)a1 + 4);
}

unsigned int EC_KEY_get_enc_flags(const EC_KEY *a1)
{
  return *((_DWORD *)a1 + 12);
}

void EC_KEY_set_enc_flags(EC_KEY *a1, unsigned int a2)
{
  *((_DWORD *)a1 + 12) = a2;
}

point_conversion_form_t EC_KEY_get_conv_form(const EC_KEY *a1)
{
  return *((_DWORD *)a1 + 13);
}

void EC_KEY_set_conv_form(EC_KEY *a1, point_conversion_form_t a2)
{
  *((_DWORD *)a1 + 13) = a2;
  int v2 = (EC_GROUP *)*((void *)a1 + 3);
  if (v2) {
    EC_GROUP_set_point_conversion_form(v2, a2);
  }
}

void *__cdecl EC_KEY_get_key_method_data(EC_KEY *a1, void *(__cdecl *dup_func)(void *), void (__cdecl *free_func)(void *), void (__cdecl *clear_free_func)(void *))
{
  CRYPTO_lock(5, 33, 0, 0);
  unsigned int data = EC_EX_DATA_get_data(*((void **)a1 + 8), (uint64_t)dup_func, (uint64_t)free_func, (uint64_t)clear_free_func);
  CRYPTO_lock(6, 33, 0, 0);
  return data;
}

void EC_KEY_insert_key_method_data(EC_KEY *a1, void *data, void *(__cdecl *dup_func)(void *), void (__cdecl *free_func)(void *), void (__cdecl *clear_free_func)(void *))
{
  CRYPTO_lock(9, 33, 0, 0);
  int v11 = (void *)*((void *)a1 + 8);
  uint64_t v10 = (char *)a1 + 64;
  if (!EC_EX_DATA_get_data(v11, (uint64_t)dup_func, (uint64_t)free_func, (uint64_t)clear_free_func)) {
    EC_EX_DATA_set_data((uint64_t)v10, (uint64_t)data, (uint64_t)dup_func, (uint64_t)free_func, (uint64_t)clear_free_func);
  }
  CRYPTO_lock(10, 33, 0, 0);
}

void EC_KEY_set_asn1_flag(EC_KEY *a1, int a2)
{
  int v2 = (EC_GROUP *)*((void *)a1 + 3);
  if (v2) {
    EC_GROUP_set_asn1_flag(v2, a2);
  }
}

int EC_KEY_precompute_mult(EC_KEY *a1, BN_CTX *ctx)
{
  int v2 = (EC_GROUP *)*((void *)a1 + 3);
  if (v2) {
    LODWORD(v2) = EC_GROUP_precompute_mult(v2, ctx);
  }
  return (int)v2;
}

uint64_t EC_KEY_get_flags(uint64_t a1)
{
  return *(unsigned int *)(a1 + 60);
}

uint64_t EC_KEY_set_flags(uint64_t result, int a2)
{
  *(_DWORD *)(result + 60) |= a2;
  return result;
}

uint64_t EC_KEY_clear_flags(uint64_t result, int a2)
{
  *(_DWORD *)(result + 60) &= ~a2;
  return result;
}

void ENGINE_unregister_pkey_asn1_meths(void *a1)
{
}

uint64_t ENGINE_register_pkey_asn1_meths(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(a1 + 104);
  if (v1 && (int v3 = v1(), v3 > 0)) {
    return engine_table_register((LHASH **)&pkey_asn1_meth_table, (uint64_t)engine_unregister_all_pkey_asn1_meths, (char *)a1, 0, v3, 0);
  }
  else {
    return 1;
  }
}

void engine_unregister_all_pkey_asn1_meths()
{
}

ENGINE *ENGINE_register_all_pkey_asn1_meths()
{
  int result = ENGINE_get_first();
  if (result)
  {
    uint64_t v1 = result;
    do
    {
      ENGINE_register_pkey_asn1_meths((uint64_t)v1);
      int result = ENGINE_get_next(v1);
      uint64_t v1 = result;
    }
    while (result);
  }
  return result;
}

uint64_t ENGINE_set_default_pkey_asn1_meths(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(a1 + 104);
  if (v1 && (int v3 = v1(), v3 > 0)) {
    return engine_table_register((LHASH **)&pkey_asn1_meth_table, (uint64_t)engine_unregister_all_pkey_asn1_meths, (char *)a1, 0, v3, 1);
  }
  else {
    return 1;
  }
}

uint64_t ENGINE_get_pkey_asn1_meth_engine(int a1)
{
  return engine_table_select((LHASH **)&pkey_asn1_meth_table, a1);
}

uint64_t ENGINE_get_pkey_asn1_meth(uint64_t a1)
{
  uint64_t v3 = 0;
  uint64_t v1 = *(unsigned int (**)(void))(a1 + 104);
  if (v1 && v1()) {
    return v3;
  }
  ERR_put_error(38, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/tb_asnmth.c", 138);
  return 0;
}

uint64_t ENGINE_get_pkey_asn1_meths(uint64_t a1)
{
  return *(void *)(a1 + 104);
}

uint64_t ENGINE_set_pkey_asn1_meths(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 104) = a2;
  return 1;
}

void engine_pkey_asn1_meths_free(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(a1 + 104);
  if (v1)
  {
    uint64_t v6 = 0;
    int v3 = v1();
    if (v3 >= 1)
    {
      int v4 = 0;
      uint64_t v5 = 4 * v3;
      do
      {
        if ((*(unsigned int (**)(uint64_t, uint64_t *, void, void))(a1 + 104))(a1, &v6, 0, *v4)) {
          EVP_PKEY_asn1_free(v6);
        }
        ++v4;
      }
      while ((unsigned int *)v5 != v4);
    }
  }
}

uint64_t (*ENGINE_get_pkey_asn1_meth_str(uint64_t a1, char *__s, int a3))(uint64_t, void, uint64_t *, void)
{
  int v3 = *(uint64_t (**)(uint64_t, void, uint64_t *, void))(a1 + 104);
  if (v3)
  {
    int v4 = a3;
    if (a3 == -1) {
      int v4 = strlen(__s);
    }
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    int v7 = v3(a1, 0, &v12, 0);
    if (v7 < 1)
    {
      return 0;
    }
    else
    {
      uint64_t v8 = 0;
      uint64_t v9 = 4 * v7;
      while (1)
      {
        (*(void (**)(uint64_t, uint64_t *, void, void))(a1 + 104))(a1, &v11, 0, *(unsigned int *)(v12 + v8));
        int v3 = (uint64_t (*)(uint64_t, void, uint64_t *, void))v11;
        if (v4 == strlen(*(const char **)(v11 + 16)) && !strncasecmp(*(const char **)(v11 + 16), __s, v4)) {
          break;
        }
        v8 += 4;
        if (v9 == v8) {
          return 0;
        }
      }
    }
  }
  return v3;
}

uint64_t ENGINE_pkey_asn1_find_str(void *a1, uint64_t a2, unsigned int a3)
{
  long long v6 = 0u;
  uint64_t v7 = a2;
  uint64_t v8 = a3;
  CRYPTO_lock(9, 30, 0, 0);
  engine_table_doall((LHASH *)pkey_asn1_meth_table, (uint64_t)look_str_cb, (uint64_t)&v6);
  uint64_t v4 = v6;
  if ((void)v6) {
    ++*(_DWORD *)(v6 + 180);
  }
  *a1 = v4;
  CRYPTO_lock(10, 30, 0, 0);
  return *((void *)&v6 + 1);
}

uint64_t look_str_cb(uint64_t result, STACK *a2, uint64_t a3, uint64_t a4)
{
  if (!*(void *)(a4 + 8))
  {
    uint64_t v6 = result;
    int result = sk_num(a2);
    if ((int)result >= 1)
    {
      int v7 = 0;
      while (1)
      {
        uint64_t v8 = sk_value(a2, v7);
        uint64_t v11 = 0;
        (*((void (**)(char *, uint64_t *, void, uint64_t))v8 + 13))(v8, &v11, 0, v6);
        uint64_t v9 = v11;
        int v10 = strlen(*(const char **)(v11 + 16));
        if (*(_DWORD *)(a4 + 24) == v10)
        {
          int result = strncasecmp(*(const char **)(v11 + 16), *(const char **)(a4 + 16), v10);
          if (!result) {
            break;
          }
        }
        ++v7;
        int result = sk_num(a2);
        if (v7 >= (int)result) {
          return result;
        }
      }
      *(void *)a4 = v8;
      *(void *)(a4 + 8) = v9;
    }
  }
  return result;
}

uint64_t OpenSSL_config(uint64_t a1)
{
  if (a1) {
    openssl_config_name = a1;
  }
  uint64_t result = OPENSSL_init_crypto(0, 0);
  if (result) {
    return pthread_once(&openssl_configured, (void (*)(void))OPENSSL_config_internal) == 0;
  }
  return result;
}

uint64_t OPENSSL_config_internal()
{
  OPENSSL_load_builtin_modules();
  ENGINE_load_builtin_engines();
  ERR_clear_error();
  uint64_t result = CONF_modules_load_file(0, (const char *)openssl_config_name, 0x30uLL);
  if ((int)result <= 0)
  {
    ERR_load_crypto_strings();
    uint64_t v1 = BIO_new_fp((FILE *)*MEMORY[0x263EF8348], 0);
    if (v1)
    {
      int v2 = v1;
      BIO_printf(v1, "Auto configuration failed\n");
      ERR_print_errors(v2);
      BIO_free(v2);
    }
    exit(1);
  }
  return result;
}

BOOL OpenSSL_no_config()
{
  return pthread_once(&openssl_configured, (void (*)(void))OPENSSL_no_config_internal) == 0;
}

void OPENSSL_no_config(void)
{
}

int BIO_dump_cb(int (__cdecl *cb)(const void *, size_t, void *), void *u, const char *s, int len)
{
  return BIO_dump_indent_cb(cb, u, s, len, 0);
}

int BIO_dump_indent_cb(int (__cdecl *cb)(const void *, size_t, void *), void *u, const char *s, int len, int indent)
{
  int v5 = len;
  uint64_t v6 = s;
  uint64_t v42 = *MEMORY[0x263EF8340];
  if (len < 1)
  {
    int v11 = len;
    int v5 = 0;
  }
  else
  {
    int v9 = 0;
    int v10 = len - 1;
    while ((s[v10] | 0x20) == 0x20)
    {
      ++v9;
      --v10;
      if (len == v9)
      {
        int v11 = 0;
        goto LABEL_8;
      }
    }
    int v11 = len - v9;
    int v5 = v9;
  }
LABEL_8:
  unsigned int v12 = indent & ~(indent >> 31);
  if (v12 >= 0x40) {
    int v13 = 64;
  }
  else {
    int v13 = indent & ~(indent >> 31);
  }
  __memset_chk();
  v39[v13] = 0;
  if (v12 >= 6) {
    int v14 = 6;
  }
  else {
    int v14 = v12;
  }
  int v15 = v13 - v14;
  if (v15 > 60) {
    return -1;
  }
  int v32 = v5;
  unint64_t v17 = (16 - ((char)(v15 + 3 + (((char)(v15 + 3) >> 13) & 3)) >> 2));
  LODWORD(v18) = v11 / (int)v17;
  if (v11 / (int)v17 * (int)v17 >= v11) {
    uint64_t v18 = v18;
  }
  else {
    uint64_t v18 = (v18 + 1);
  }
  uint64_t v37 = v18;
  if ((int)v18 >= 1)
  {
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    int v16 = 0;
    if ((16 - ((char)(v15 + 3 + (((char)(v15 + 3) >> 13) & 3)) >> 2)) <= 1u) {
      uint64_t v21 = 1;
    }
    else {
      uint64_t v21 = (16 - ((char)(v15 + 3 + (((char)(v15 + 3) >> 13) & 3)) >> 2));
    }
    int v36 = (char)v15;
    int v33 = v6;
    int v34 = u;
    int v35 = cb;
    while (1)
    {
      int v38 = v16;
      __strlcpy_chk();
      snprintf(__str, 0x14uLL, "%04x - ", v20 * v17);
      __strlcat_chk();
      if (v36 >= 61)
      {
        __strlcat_chk();
      }
      else
      {
        uint64_t v22 = 0;
        do
        {
          if (v19 + v22 < v11)
          {
            uint64_t v23 = 32;
            if (v22 == 7) {
              uint64_t v23 = 45;
            }
            snprintf(__str, 0x14uLL, "%02x%c", v33[v19 + v22], v23);
          }
          __strlcat_chk();
          ++v22;
        }
        while (v21 != v22);
        __strlcat_chk();
        cb = v35;
        u = v34;
        if ((uint64_t)(v20 * v17) < v11)
        {
          uint64_t v24 = 0;
          do
          {
            int v25 = v6[v24];
            if ((v25 - 32) >= 0x5F) {
              LOBYTE(v25) = 46;
            }
            __str[0] = v25;
            __str[1] = 0;
            __strlcat_chk();
            if (v24 + 1 >= v17) {
              break;
            }
            int v26 = v19 + v24++ + 1;
          }
          while (v26 < v11);
        }
      }
      __strlcat_chk();
      size_t v27 = strlen(__s);
      int v28 = ((uint64_t (*)(char *, size_t, void *))cb)(__s, v27, u);
      if (v28 < 0) {
        return -1;
      }
      int v16 = v28 + v38;
      ++v20;
      v19 += v17;
      v6 += v17;
      if (v20 == v37) {
        goto LABEL_43;
      }
    }
  }
  int v16 = 0;
LABEL_43:
  if (v32)
  {
    snprintf(__s, 0x121uLL, "%s%04x - <SPACES/NULS>\n", v39, v32 + v11);
    size_t v29 = strlen(__s);
    int v30 = ((uint64_t (*)(char *, size_t, void *))cb)(__s, v29, u);
    if (v30 < 0) {
      return -1;
    }
    else {
      v16 += v30;
    }
  }
  return v16;
}

int BIO_dump_fp(FILE *fp, const char *s, int len)
{
  return BIO_dump_indent_cb((int (__cdecl *)(const void *, size_t, void *))write_fp, fp, s, len, 0);
}

size_t write_fp(const void *a1, size_t __nitems, FILE *__stream)
{
  return fwrite(a1, 1uLL, __nitems, __stream);
}

int BIO_dump_indent_fp(FILE *fp, const char *s, int len, int indent)
{
  return BIO_dump_indent_cb((int (__cdecl *)(const void *, size_t, void *))write_fp, fp, s, len, indent);
}

int BIO_dump(BIO *b, const char *bytes, int len)
{
  return BIO_dump_indent_cb((int (__cdecl *)(const void *, size_t, void *))write_bio, b, bytes, len, 0);
}

uint64_t write_bio(void *data, int len, BIO *b)
{
  return BIO_write(b, data, len);
}

int BIO_dump_indent(BIO *b, const char *bytes, int len, int indent)
{
  return BIO_dump_indent_cb((int (__cdecl *)(const void *, size_t, void *))write_bio, b, bytes, len, indent);
}

int (__cdecl *__cdecl X509_TRUST_set_default(int (__cdecl *trust)(int, X509 *, int)))(int, X509 *, int)
{
  uint64_t v1 = (int (__cdecl *)(int, X509 *, int))default_trust;
  default_int trust = (uint64_t (*)())trust;
  return v1;
}

int X509_check_trust(X509 *x, int id, int flags)
{
  if (id == -1) {
    return 1;
  }
  uint64_t v3 = *(void *)&id;
  if (id)
  {
    uint64_t v6 = *(void *)&flags;
    unsigned int v7 = X509_TRUST_get_by_id(id);
    if (v7 == -1)
    {
      int v9 = default_trust;
      return ((uint64_t (*)(uint64_t, X509 *, uint64_t))v9)(v3, x, v6);
    }
    else
    {
      if (v7 > 7) {
        uint64_t v8 = sk_value((const STACK *)trtable, v7 - 8);
      }
      else {
        uint64_t v8 = (char *)&trstandard + 40 * v7;
      }
      int v10 = (uint64_t (*)(void))*((void *)v8 + 1);
      return v10();
    }
  }
  else
  {
    int result = obj_trust(910, (uint64_t)x);
    if (result == 3)
    {
      X509_check_purpose(x, -1, 0);
      if ((x->ex_pathlen & 0x2000) != 0) {
        return 1;
      }
      else {
        return 3;
      }
    }
  }
  return result;
}

uint64_t obj_trust(int a1, uint64_t a2)
{
  int v2 = *(const STACK ***)(a2 + 224);
  if (!v2) {
    return 3;
  }
  uint64_t v4 = v2[1];
  if (!v4 || sk_num(v4) < 1)
  {
LABEL_8:
    if (*v2 && sk_num(*v2) >= 1)
    {
      int v9 = 0;
      while (1)
      {
        int v10 = sk_value(*v2, v9);
        int v11 = OBJ_obj2nid((const ASN1_OBJECT *)v10);
        uint64_t result = 1;
        if (v11 == a1 || v11 == 910) {
          break;
        }
        if (++v9 >= sk_num(*v2)) {
          return 3;
        }
      }
      return result;
    }
    return 3;
  }
  int v5 = 0;
  while (1)
  {
    uint64_t v6 = sk_value(v2[1], v5);
    int v7 = OBJ_obj2nid((const ASN1_OBJECT *)v6);
    uint64_t result = 2;
    if (v7 == a1 || v7 == 910) {
      return result;
    }
    if (++v5 >= sk_num(v2[1])) {
      goto LABEL_8;
    }
  }
}

uint64_t trust_compat(int a1, X509 *x)
{
  if ((x->ex_pathlen & 0x2000) != 0) {
    return 1;
  }
  else {
    return 3;
  }
}

int X509_TRUST_get_by_id(int id)
{
  int result = id - 1;
  if (result >= 8)
  {
    uint64_t v8 = v1;
    uint64_t v9 = v2;
    uint64_t v7 = 0;
    memset(v6, 0, sizeof(v6));
    LODWORD(v6[0]) = id;
    if (trtable)
    {
      int v5 = sk_find((STACK *)trtable, (char *)v6);
      if (v5 == -1) {
        return -1;
      }
      else {
        return v5 + 8;
      }
    }
    else
    {
      return -1;
    }
  }
  return result;
}

X509_TRUST *__cdecl X509_TRUST_get0(int idx)
{
  if (idx < 0) {
    return 0;
  }
  if (idx > 7) {
    return (X509_TRUST *)sk_value((const STACK *)trtable, idx - 8);
  }
  return (X509_TRUST *)((char *)&trstandard + 40 * idx);
}

int X509_TRUST_get_count(void)
{
  if (trtable) {
    return sk_num((const STACK *)trtable) + 8;
  }
  else {
    return 8;
  }
}

int X509_TRUST_set(int *t, int trust)
{
  if (X509_TRUST_get_by_id(trust) == -1)
  {
    ERR_put_error(11, 4095, 123, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_trs.c", 188);
    return 0;
  }
  else
  {
    *t = trust;
    return 1;
  }
}

int X509_TRUST_add(int id, int flags, int (__cdecl *ck)(X509_TRUST *, X509 *, int), char *name, int arg1, void *arg2)
{
  unsigned int v12 = X509_TRUST_get_by_id(id);
  unsigned int v13 = v12;
  if (v12 == -1)
  {
    int v15 = (char *)malloc_type_malloc(0x28uLL, 0x10900403507AD87uLL);
    if (v15)
    {
      int v14 = v15;
      *((_DWORD *)v15 + md5_block_data_order((unint64_t)c, b, 1) = 1;
      int v16 = strdup(name);
      if (!v16)
      {
LABEL_20:
        free(v14);
        goto LABEL_21;
      }
LABEL_10:
      unsigned int v17 = flags & 0xFFFFFFFC;
      int v18 = *((_DWORD *)v14 + 1);
      if ((v18 & 2) != 0)
      {
        free(*((void **)v14 + 2));
        int v18 = *((_DWORD *)v14 + 1);
      }
      *(_DWORD *)int v14 = id;
      *((_DWORD *)v14 + md5_block_data_order((unint64_t)c, b, 1) = v17 | v18 & 1 | 2;
      *((void *)v14 + md5_block_data_order((unint64_t)c, b, 1) = ck;
      *((void *)v14 + 2) = v16;
      *((_DWORD *)v14 + 6) = arg1;
      *((void *)v14 + 4) = arg2;
      if (v13 != -1) {
        return 1;
      }
      uint64_t v19 = (STACK *)trtable;
      if (trtable
        || (uint64_t v19 = sk_new((int (__cdecl *)(const char *const *, const char *const *))tr_cmp),
            (trtable = (uint64_t)v19) != 0))
      {
        if (sk_push(v19, v14)) {
          return 1;
        }
      }
      free(v16);
      goto LABEL_20;
    }
    int v21 = 65;
    int v22 = 213;
  }
  else
  {
    if ((v12 & 0x80000000) == 0)
    {
      if (v12 <= 7)
      {
        int v14 = (char *)&trstandard + 40 * v12;
        goto LABEL_9;
      }
      int v14 = sk_value((const STACK *)trtable, v12 - 8);
      if (v14)
      {
LABEL_9:
        int v16 = strdup(name);
        if (!v16)
        {
LABEL_21:
          int v21 = 65;
          int v22 = 257;
          goto LABEL_22;
        }
        goto LABEL_10;
      }
    }
    int v21 = 123;
    int v22 = 220;
  }
LABEL_22:
  ERR_put_error(11, 4095, v21, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_trs.c", v22);
  return 0;
}

uint64_t tr_cmp(_DWORD **a1, _DWORD **a2)
{
  return (**a1 - **a2);
}

void X509_TRUST_cleanup(void)
{
  trtable = 0;
}

void trtable_free(void *a1)
{
  if (a1)
  {
    int v2 = *((_DWORD *)a1 + 1);
    if (v2)
    {
      if ((v2 & 2) != 0) {
        free(*((void **)a1 + 2));
      }
      free(a1);
    }
  }
}

int X509_TRUST_get_flags(X509_TRUST *xp)
{
  return xp->flags;
}

char *__cdecl X509_TRUST_get0_name(X509_TRUST *xp)
{
  return xp->name;
}

int X509_TRUST_get_trust(X509_TRUST *xp)
{
  return xp->trust;
}

uint64_t trust_1oidany(uint64_t a1, X509 *x)
{
  ex_pcpathuint64_t len = (void *)x[1].ex_pcpathlen;
  if (ex_pcpathlen && (*ex_pcpathlen || ex_pcpathlen[1]))
  {
    int v4 = *(_DWORD *)(a1 + 24);
    return obj_trust(v4, (uint64_t)x);
  }
  else
  {
    X509_check_purpose(x, -1, 0);
    if ((x->ex_pathlen & 0x2000) != 0) {
      return 1;
    }
    else {
      return 3;
    }
  }
}

uint64_t trust_1oid(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 224)) {
    return obj_trust(*(_DWORD *)(a1 + 24), a2);
  }
  else {
    return 3;
  }
}

uint64_t pub_decode_gost01(uint64_t a1, uint64_t a2)
{
  in = 0;
  algor = 0;
  int pptype = -1;
  memset(len, 0, sizeof(len));
  unsigned int v13 = 0;
  if (!X509_PUBKEY_get0_param(&len[1], &in, len, &algor, a2)) {
    return 0;
  }
  EVP_PKEY_assign((EVP_PKEY *)a1, 811, 0);
  X509_ALGOR_get0(0, &pptype, (void **)&v13, algor);
  if (pptype != 16)
  {
    int v10 = 104;
    int v11 = 211;
LABEL_11:
    ERR_put_error(50, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", v11);
    return 0;
  }
  int v16 = (const unsigned __int8 *)v13[1];
  if (!decode_gost01_algor_params((EVP_PKEY *)a1, &v16, *(_DWORD *)v13))
  {
    int v10 = 104;
    int v11 = 216;
    goto LABEL_11;
  }
  uint64_t v3 = d2i_ASN1_OCTET_STRING(0, (const unsigned __int8 **)&in, len[0]);
  if (!v3)
  {
    int v10 = 65;
    int v11 = 222;
    goto LABEL_11;
  }
  int v4 = v3;
  int v5 = v3->length / 2;
  unint64_t v6 = (uint64_t)(v3->length + (v3->length < 0)) >> 1;
  uint64_t v7 = GOST_le2bn(v3->data, v6, 0);
  uint64_t v8 = GOST_le2bn(&v4->data[v5], v6, 0);
  ASN1_OCTET_STRING_free(v4);
  uint64_t v9 = GOST_KEY_set_public_key_affine_coordinates(*(const EC_GROUP ***)(a1 + 32), v7, v8);
  if (!v9) {
    ERR_put_error(50, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", 234);
  }
  BN_free(v7);
  BN_free(v8);
  return v9;
}

ASN1_STRING *pub_encode_gost01(uint64_t a1, uint64_t a2)
{
  out = 0;
  int v4 = *(BIGNUM **)(a2 + 32);
  int digest = GOST_KEY_get_digest((uint64_t)v4);
  pk_int digest = GostR3410_get_pk_digest(digest);
  uint64_t v7 = OBJ_nid2obj(pk_digest);
  if (*(_DWORD *)(a2 + 40))
  {
    int result = encode_gost01_algor_params(a2);
    if (!result) {
      return result;
    }
    uint64_t v9 = result;
    int v10 = 16;
  }
  else
  {
    uint64_t v9 = 0;
    int v10 = -1;
  }
  int size = GOST_KEY_get_size(v4);
  uint64_t v12 = GOST_KEY_get0_public_key((uint64_t)v4);
  if (!v12)
  {
    ERR_put_error(50, 4095, 118, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", 269);
    int v15 = 0;
LABEL_17:
    int v16 = 0;
    int v18 = 0;
    goto LABEL_18;
  }
  unsigned int v13 = (void *)v12;
  int v14 = ASN1_OCTET_STRING_new();
  int v15 = v14;
  if (!v14)
  {
    int v21 = 65;
    int v22 = 275;
LABEL_16:
    ERR_put_error(50, 4095, v21, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", v22);
    goto LABEL_17;
  }
  if (!ASN1_STRING_set(v14, 0, 2 * size))
  {
    int v21 = 68;
    int v22 = 281;
    goto LABEL_16;
  }
  int v25 = ASN1_STRING_data(v15);
  int v16 = BN_new();
  unsigned int v17 = BN_new();
  int v18 = v17;
  if (v16 && v17)
  {
    uint64_t v19 = GOST_KEY_get0_group((uint64_t)v4);
    if (EC_POINT_get_affine_coordinates(v19, v13, (uint64_t)v16, (uint64_t)v18, 0))
    {
      GOST_bn2le(v16, (uint64_t)v25, size);
      GOST_bn2le(v18, (uint64_t)&v25[size], size);
      BN_free(v18);
      BN_free(v16);
      int v20 = i2d_ASN1_OCTET_STRING(v15, &out);
      ASN1_BIT_STRING_free(v15);
      if ((v20 & 0x80000000) == 0) {
        return (ASN1_STRING *)X509_PUBKEY_set0_param(a1, v7, v10, v9, out, v20);
      }
      return 0;
    }
    int v23 = 16;
    int v24 = 296;
  }
  else
  {
    int v23 = 65;
    int v24 = 290;
  }
  ERR_put_error(50, 4095, v23, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", v24);
LABEL_18:
  BN_free(v18);
  BN_free(v16);
  ASN1_BIT_STRING_free(v15);
  ASN1_STRING_free(v9);
  return 0;
}

BOOL pub_cmp_gost01(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a2 + 32);
  if (v2) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    return 0;
  }
  int v5 = (const EC_POINT *)GOST_KEY_get0_public_key(*(void *)(a1 + 32));
  uint64_t v6 = GOST_KEY_get0_public_key(v3);
  if (!v5 || v6 == 0) {
    return 0;
  }
  uint64_t v8 = (const EC_POINT *)v6;
  uint64_t v9 = (const EC_GROUP *)GOST_KEY_get0_group(v2);
  return EC_POINT_cmp(v9, v5, v8, 0) == 0;
}

uint64_t pub_print_gost01(BIO *a1, uint64_t a2, int a3)
{
  uint64_t v6 = BN_CTX_new();
  if (!v6)
  {
    ERR_put_error(50, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", 346);
    return 0;
  }
  uint64_t v7 = v6;
  BN_CTX_start(v6);
  uint64_t v8 = BN_CTX_get(v7);
  if (!v8 || (v9 = v8, (int v10 = BN_CTX_get(v7)) == 0))
  {
LABEL_13:
    BN_CTX_end(v7);
    BN_CTX_free(v7);
    return 0;
  }
  int v11 = v10;
  uint64_t v12 = (void *)GOST_KEY_get0_public_key(*(void *)(a2 + 32));
  uint64_t v13 = GOST_KEY_get0_group(*(void *)(a2 + 32));
  if (!EC_POINT_get_affine_coordinates(v13, v12, (uint64_t)v9, (uint64_t)v11, v7))
  {
    ERR_put_error(50, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", 357);
    goto LABEL_13;
  }
  if (!BIO_indent(a1, a3, 128)) {
    goto LABEL_13;
  }
  BIO_printf(a1, "Public key:\n");
  if (!BIO_indent(a1, a3 + 3, 128)) {
    goto LABEL_13;
  }
  BIO_printf(a1, "X:");
  BN_print(a1, v9);
  BIO_printf(a1, "\n");
  if (!BIO_indent(a1, a3 + 3, 128)) {
    goto LABEL_13;
  }
  BIO_printf(a1, "Y:");
  BN_print(a1, v11);
  BIO_printf(a1, "\n");
  BN_CTX_end(v7);
  BN_CTX_free(v7);
  return param_print_gost01(a1, a2, a3);
}

BOOL priv_decode_gost01(EVP_PKEY *a1, uint64_t a2)
{
  uint64_t v19 = 0;
  len[0] = 0;
  uint64_t v16 = 0;
  algor = 0;
  int pptype = -1;
  ppunint64_t val = 0;
  if (!PKCS8_pkey_get0(&v16, &v19, len, &algor, a2))
  {
    int v6 = 104;
    int v7 = 418;
LABEL_10:
    ERR_put_error(50, 4095, v6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", v7);
    return 0;
  }
  EVP_PKEY_assign(a1, 811, 0);
  X509_ALGOR_get0(0, &pptype, &ppval, algor);
  if (pptype != 16)
  {
    int v6 = 104;
    int v7 = 424;
    goto LABEL_10;
  }
  *(void *)&len[1] = *((void *)ppval + 1);
  if (!decode_gost01_algor_params(a1, (const unsigned __int8 **)&len[1], *(_DWORD *)ppval))
  {
    int v6 = 104;
    int v7 = 429;
    goto LABEL_10;
  }
  *(void *)&len[1] = v19;
  if (*v19 == 4)
  {
    uint64_t v3 = d2i_ASN1_OCTET_STRING(0, (const unsigned __int8 **)&len[1], len[0]);
    if (!v3)
    {
      ERR_put_error(50, 4095, 114, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", 439);
      ASN1_STRING_free(0);
      return 0;
    }
    BOOL v4 = v3;
    int v5 = GOST_le2bn(v3->data, v3->length, 0);
    ASN1_STRING_free(v4);
    goto LABEL_15;
  }
  int v10 = d2i_ASN1_INTEGER(0, (const unsigned __int8 **)&len[1], len[0]);
  if (!v10) {
    return 0;
  }
  int v11 = v10;
  int v5 = ASN1_INTEGER_to_BN(v10, 0);
  ASN1_INTEGER_free(v11);
  if (!v5)
  {
    int v6 = 114;
    int v7 = 453;
    goto LABEL_10;
  }
LABEL_15:
  attributeunsigned int s = a1->attributes;
  if (!attributes)
  {
    uint64_t v13 = (char *)GOST_KEY_new();
    if (!v13) {
      goto LABEL_22;
    }
    attributeunsigned int s = v13;
    if (!EVP_PKEY_assign(a1, 811, v13))
    {
      BN_free(v5);
      GOST_KEY_free(attributes);
      return 0;
    }
  }
  if (!GOST_KEY_set_private_key((uint64_t)attributes, v5))
  {
LABEL_22:
    BN_free(v5);
    return 0;
  }
  if (EVP_PKEY_missing_parameters(a1)) {
    BOOL v8 = 0;
  }
  else {
    BOOL v8 = gost2001_compute_public((const EC_GROUP **)attributes) != 0;
  }
  BN_free(v5);
  return v8;
}

ASN1_STRING *priv_encode_gost01(uint64_t a1, uint64_t a2)
{
  int digest = GOST_KEY_get_digest(*(void *)(a2 + 32));
  pk_int digest = GostR3410_get_pk_digest(digest);
  int v6 = OBJ_nid2obj(pk_digest);
  int result = encode_gost01_algor_params(a2);
  out = 0;
  if (result)
  {
    BOOL v8 = result;
    uint64_t v9 = (BIGNUM *)GOST_KEY_get0_private_key(*(void *)(a2 + 32));
    int v10 = BN_to_ASN1_INTEGER(v9, 0);
    if (v10)
    {
      int v11 = v10;
      int v12 = i2d_ASN1_INTEGER(v10, &out);
      ASN1_INTEGER_free(v11);
      return (ASN1_STRING *)PKCS8_pkey_set0(a1, v6, 0, 16, v8, out, v12);
    }
    else
    {
      ASN1_STRING_free(v8);
      return 0;
    }
  }
  return result;
}

uint64_t priv_print_gost01(BIO *a1, uint64_t a2, int indent)
{
  uint64_t result = BIO_indent(a1, indent, 128);
  if (result)
  {
    BIO_printf(a1, "Private key: ");
    int v7 = (const BIGNUM *)GOST_KEY_get0_private_key(*(void *)(a2 + 32));
    if (v7) {
      BN_print(a1, v7);
    }
    else {
      BIO_printf(a1, "<undefined)");
    }
    BIO_printf(a1, "\n");
    return pub_print_gost01(a1, a2, indent);
  }
  return result;
}

uint64_t pkey_size_gost01(uint64_t a1)
{
  if (GOST_KEY_get_digest(*(void *)(a1 + 32)) == 942) {
    return 128;
  }
  else {
    return 64;
  }
}

uint64_t pkey_bits_gost01(uint64_t a1)
{
  if (GOST_KEY_get_digest(*(void *)(a1 + 32)) == 942) {
    return 512;
  }
  else {
    return 256;
  }
}

uint64_t param_decode_gost01(EVP_PKEY *a1, const unsigned __int8 **a2, int a3)
{
  a = 0;
  if (**a2 != 48)
  {
    if (d2i_ASN1_OBJECT(&a, a2, a3))
    {
      int v5 = OBJ_obj2nid(a);
      ASN1_OBJECT_free(a);
      int v6 = GOST_KEY_new();
      if (v6)
      {
        int v7 = v6;
        BOOL v8 = EC_GROUP_new_by_curve_name(v5);
        if (v8)
        {
          uint64_t v9 = v8;
          EC_GROUP_set_asn1_flag(v8, 1);
          if (!GOST_KEY_set_group((EC_GROUP **)v7, v9))
          {
            ERR_put_error(50, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", 558);
            EC_GROUP_free(v9);
LABEL_19:
            GOST_KEY_free(v7);
            return 0;
          }
          EC_GROUP_free(v9);
          if (GOST_KEY_set_digest((uint64_t)v7, 822))
          {
            uint64_t result = EVP_PKEY_assign(a1, 811, (char *)v7);
            if (result) {
              return result;
            }
            goto LABEL_19;
          }
          int v11 = 100;
          int v12 = 566;
        }
        else
        {
          int v11 = 119;
          int v12 = 551;
        }
        ERR_put_error(50, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", v12);
        goto LABEL_19;
      }
      int v10 = 546;
    }
    else
    {
      int v10 = 538;
    }
    ERR_put_error(50, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", v10);
    return 0;
  }
  return decode_gost01_algor_params(a1, a2, a3);
}

uint64_t param_encode_gost01(uint64_t a1, void **a2)
{
  uint64_t v3 = encode_gost01_algor_params(a1);
  if (!v3) {
    return 0;
  }
  BOOL v4 = v3;
  uint64_t length = v3->length;
  if (a2) {
    memcpy(*a2, v3->data, (int)length);
  }
  ASN1_STRING_free(v4);
  return length;
}

BOOL param_missing_gost01(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  return !v1 || !GOST_KEY_get0_group(*(void *)(a1 + 32)) || GOST_KEY_get_digest(v1) == 0;
}

uint64_t param_copy_gost01(EVP_PKEY *a1, uint64_t a2)
{
  attributeunsigned int s = a1->attributes;
  uint64_t v5 = *(void *)(a2 + 32);
  int v6 = EVP_PKEY_base_id((int *)a2);
  if (v6 != EVP_PKEY_base_id(&a1->type))
  {
    int v10 = 110;
    int v11 = 598;
LABEL_10:
    ERR_put_error(50, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", v11);
    return 0;
  }
  if (!v5)
  {
    int v10 = 113;
    int v11 = 602;
    goto LABEL_10;
  }
  if (attributes) {
    goto LABEL_4;
  }
  int v12 = (STACK *)GOST_KEY_new();
  if (!v12)
  {
    int v10 = 65;
    int v11 = 608;
    goto LABEL_10;
  }
  attributeunsigned int s = v12;
  int v13 = EVP_PKEY_base_id((int *)a2);
  if (!EVP_PKEY_assign(a1, v13, (char *)attributes))
  {
    GOST_KEY_free(attributes);
    return 0;
  }
LABEL_4:
  int v7 = (const EC_GROUP *)GOST_KEY_get0_group(v5);
  GOST_KEY_set_group((EC_GROUP **)attributes, v7);
  int digest = GOST_KEY_get_digest(v5);
  GOST_KEY_set_digest((uint64_t)attributes, digest);
  if (!GOST_KEY_get0_private_key((uint64_t)attributes)) {
    return 1;
  }
  return gost2001_compute_public((const EC_GROUP **)attributes);
}

BOOL param_cmp_gost01(uint64_t a1, uint64_t a2)
{
  BOOL v4 = (const EC_GROUP *)GOST_KEY_get0_group(*(void *)(a1 + 32));
  int curve_name = EC_GROUP_get_curve_name(v4);
  int v6 = (const EC_GROUP *)GOST_KEY_get0_group(*(void *)(a2 + 32));
  if (curve_name != EC_GROUP_get_curve_name(v6)) {
    return 0;
  }
  int digest = GOST_KEY_get_digest(*(void *)(a1 + 32));
  return digest == GOST_KEY_get_digest(*(void *)(a2 + 32));
}

uint64_t param_print_gost01(BIO *a1, uint64_t a2, int a3)
{
  int v6 = (const EC_GROUP *)GOST_KEY_get0_group(*(void *)(a2 + 32));
  int curve_name = EC_GROUP_get_curve_name(v6);
  uint64_t result = BIO_indent(a1, a3, 128);
  if (result)
  {
    uint64_t v9 = OBJ_nid2ln(curve_name);
    BIO_printf(a1, "Parameter set: %s\n", v9);
    uint64_t result = BIO_indent(a1, a3, 128);
    if (result)
    {
      int digest = GOST_KEY_get_digest(*(void *)(a2 + 32));
      int v11 = OBJ_nid2ln(digest);
      BIO_printf(a1, "Digest Algorithm: %s\n", v11);
      return 1;
    }
  }
  return result;
}

void *pkey_free_gost01(uint64_t a1)
{
  return GOST_KEY_free(*(void **)(a1 + 32));
}

uint64_t pkey_ctrl_gost01(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  int v23 = 0;
  int v24 = 0;
  int v22 = 0;
  uint64_t digest = GOST_KEY_get_digest(*(void *)(a1 + 32));
  uint64_t v9 = digest;
  switch(a2)
  {
    case 3:
      *(_DWORD *)a4 = GostR3410_get_md_digest(digest);
      return 2;
    case 2:
      if (!a3) {
        PKCS7_RECIP_INFO_get0_alg((uint64_t)a4, &v22);
      }
      break;
    case 1:
      if (!a3)
      {
        PKCS7_SIGNER_INFO_get0_algs(a4, 0, &v24, &v23);
        int v10 = v24;
        if (v24)
        {
          md_uint64_t digest = GostR3410_get_md_digest(v9);
          int v12 = OBJ_nid2obj(md_digest);
          X509_ALGOR_set0(v10, v12, 5, 0);
        }
      }
      break;
    default:
      return 4294967294;
  }
  int v14 = v23;
  if (v23)
  {
    pk_uint64_t digest = GostR3410_get_pk_digest(v9);
    uint64_t v16 = OBJ_nid2obj(pk_digest);
    X509_ALGOR_set0(v14, v16, 5, 0);
  }
  if (!v22) {
    return 1;
  }
  unsigned int v17 = encode_gost01_algor_params(a1);
  if (v17)
  {
    int v18 = v17;
    uint64_t v19 = v22;
    int v20 = GostR3410_get_pk_digest(v9);
    int v21 = OBJ_nid2obj(v20);
    X509_ALGOR_set0(v19, v21, 16, v18);
    return 1;
  }
  return 0xFFFFFFFFLL;
}

uint64_t decode_gost01_algor_params(EVP_PKEY *a1, const unsigned __int8 **a2, int a3)
{
  BOOL v4 = (const ASN1_OBJECT **)d2i_GOST_KEY_PARAMS(0, a2, a3);
  if (!v4)
  {
    int v13 = 105;
    int v14 = 90;
    goto LABEL_12;
  }
  uint64_t v5 = v4;
  int v6 = OBJ_obj2nid(*v4);
  int v7 = OBJ_obj2nid(v5[1]);
  GOST_KEY_PARAMS_free((ASN1_VALUE *)v5);
  attributeunsigned int s = (EC_GROUP **)a1->attributes;
  if (attributes) {
    goto LABEL_3;
  }
  int v15 = (char *)GOST_KEY_new();
  if (!v15)
  {
    int v13 = 65;
    int v14 = 101;
    goto LABEL_12;
  }
  attributeunsigned int s = (EC_GROUP **)v15;
  uint64_t result = EVP_PKEY_assign(a1, 811, v15);
  if (result)
  {
LABEL_3:
    uint64_t v9 = EC_GROUP_new_by_curve_name(v6);
    if (v9)
    {
      int v10 = v9;
      EC_GROUP_set_asn1_flag(v9, 1);
      BOOL v11 = GOST_KEY_set_group(attributes, v10);
      EC_GROUP_free(v10);
      if (v11) {
        return GOST_KEY_set_digest((uint64_t)attributes, v7) != 0;
      }
      return 0;
    }
    int v13 = 119;
    int v14 = 110;
LABEL_12:
    ERR_put_error(50, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", v14);
    return 0;
  }
  return result;
}

ASN1_STRING *encode_gost01_algor_params(uint64_t a1)
{
  uint64_t v2 = ASN1_STRING_new();
  uint64_t v3 = GOST_KEY_PARAMS_new();
  BOOL v4 = v3;
  if (!v2 || !v3)
  {
    int v9 = 132;
LABEL_7:
    ERR_put_error(50, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_ameth.c", v9);
    ASN1_STRING_free(v2);
    uint64_t v2 = 0;
    goto LABEL_8;
  }
  uint64_t v5 = (const EC_GROUP *)GOST_KEY_get0_group(*(void *)(a1 + 32));
  int curve_name = EC_GROUP_get_curve_name(v5);
  *(void *)BOOL v4 = OBJ_nid2obj(curve_name);
  int digest = GOST_KEY_get_digest(*(void *)(a1 + 32));
  *((void *)v4 + md5_block_data_order((unint64_t)c, b, 1) = OBJ_nid2obj(digest);
  int v8 = i2d_GOST_KEY_PARAMS(v4, &v2->data);
  v2->uint64_t length = v8;
  if (v8 <= 0)
  {
    int v9 = 145;
    goto LABEL_7;
  }
  v2->type = 16;
LABEL_8:
  GOST_KEY_PARAMS_free(v4);
  return v2;
}

int PEM_def_callback(char *buf, int num, int w, void *key)
{
  if (num < 0) {
    goto LABEL_15;
  }
  LODWORD(v5) = num;
  if (key)
  {
    size_t v7 = strlen((const char *)key);
    if (v7 >= v5) {
      size_t v5 = v5;
    }
    else {
      size_t v5 = v7;
    }
    memcpy(buf, key, v5);
    return v5;
  }
  pw_prompt = EVP_get_pw_prompt();
  if (pw_prompt) {
    int v10 = pw_prompt;
  }
  else {
    int v10 = "Enter PEM pass phrase:";
  }
  if (EVP_read_pw_string_min(buf, 4, v5, v10, w))
  {
LABEL_14:
    ERR_put_error(9, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", 116);
    bzero(buf, v5);
LABEL_15:
    LODWORD(v5) = -1;
    return v5;
  }
  BOOL v11 = (FILE **)MEMORY[0x263EF8348];
  while (1)
  {
    size_t v12 = strlen(buf);
    if (v12 > 3) {
      break;
    }
    fprintf(*v11, "phrase is too short, needs to be at least %zu chars\n", 4uLL);
    if (EVP_read_pw_string_min(buf, 4, v5, v10, w)) {
      goto LABEL_14;
    }
  }
  LODWORD(v5) = v12;
  return v5;
}

void PEM_proc_type(char *buf, int type)
{
  uint64_t v3 = "MIC-ONLY";
  BOOL v4 = "BAD-TYPE";
  if (type == 30) {
    BOOL v4 = "MIC-CLEAR";
  }
  if (type != 20) {
    uint64_t v3 = v4;
  }
  if (type == 10) {
    size_t v5 = "ENCRYPTED";
  }
  else {
    size_t v5 = v3;
  }
  strlcat(buf, "Proc-Type: 4,", 0x400uLL);
  strlcat(buf, v5, 0x400uLL);
  strlcat(buf, "\n", 0x400uLL);
}

void PEM_dek_info(char *buf, const char *type, int len, char *str)
{
  strlcat(buf, "DEK-Info: ", 0x400uLL);
  strlcat(buf, type, 0x400uLL);
  strlcat(buf, ",", 0x400uLL);
  int v8 = strlen(buf);
  if (v8 + 2 * len <= 1023)
  {
    if (len < 1)
    {
      uint64_t v12 = 0;
    }
    else
    {
      int v9 = &buf[v8 + 1];
      uint64_t v10 = len;
      do
      {
        *(v9 - md5_block_data_order((unint64_t)c, b, 1) = PEM_dek_info_map[(unint64_t)*str >> 4];
        char v11 = *str++;
        char *v9 = PEM_dek_info_map[v11 & 0xF];
        v9 += 2;
        --v10;
      }
      while (v10);
      uint64_t v12 = 2 * len;
    }
    *(_WORD *)&buf[v12 + v8] = 10;
  }
}

void *__cdecl PEM_ASN1_read(d2i_of_void *d2i, const char *name, FILE *fp, void **x, pem_password_cb *cb, void *u)
{
  uint64_t v12 = BIO_s_file();
  int v13 = BIO_new(v12);
  if (v13)
  {
    int v14 = v13;
    BIO_ctrl(v13, 106, 0, fp);
    biASN1_OBJECT o = PEM_ASN1_read_bio(d2i, name, v14, x, cb, u);
    BIO_free(v14);
    return bio;
  }
  else
  {
    ERR_put_error(9, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", 179);
    return 0;
  }
}

int PEM_bytes_read_bio(unsigned __int8 **pdata, uint64_t *plen, char **pnm, const char *name, BIO *bp, pem_password_cb *cb, void *u)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  memset(&cipher, 0, sizeof(cipher));
  header = 0;
  namea = 0;
  uint64_t len = 0;
  unsigned int data = 0;
  if (PEM_read_bio(bp, &namea, &header, &data, &len))
  {
    while (1)
    {
      int v9 = namea;
      if (!strcmp(namea, name)) {
        break;
      }
      if (!strcmp(name, "ANY PRIVATE KEY"))
      {
        if (!strcmp(v9, "ENCRYPTED PRIVATE KEY")) {
          break;
        }
        if (!strcmp(v9, "PRIVATE KEY")) {
          break;
        }
        signed int v12 = pem_check_suffix(v9, "PRIVATE KEY");
        if (v12 >= 1)
        {
          str = EVP_PKEY_asn1_find_str(0, v9, v12);
          if (str)
          {
            if (*((void *)str + 23)) {
              break;
            }
          }
        }
      }
      else if (!strcmp(name, "PARAMETERS"))
      {
        signed int v14 = pem_check_suffix(v9, "PARAMETERS");
        if (v14 >= 1)
        {
          e = 0;
          int v15 = EVP_PKEY_asn1_find_str(&e, v9, v14);
          if (v15)
          {
            uint64_t v16 = *((void *)v15 + 14);
            ENGINE_finish(e);
            if (v16) {
              break;
            }
          }
        }
      }
      else
      {
        int v10 = strcmp(v9, "X509 CERTIFICATE");
        if (!v10 && !strcmp(name, "CERTIFICATE")) {
          break;
        }
        if (!strcmp(v9, "NEW CERTIFICATE REQUEST") && !strcmp(name, "CERTIFICATE REQUEST")) {
          break;
        }
        int v11 = strcmp(v9, "CERTIFICATE");
        if (!v11 && !strcmp(name, "TRUSTED CERTIFICATE")) {
          break;
        }
        if (!v10 && !strcmp(name, "TRUSTED CERTIFICATE")
          || !v11 && !strcmp(name, "PKCS7")
          || !strcmp(v9, "PKCS #7 SIGNED DATA") && !strcmp(name, "PKCS7")
          || !v11 && !strcmp(name, "CMS")
          || !strcmp(v9, "PKCS7") && !strcmp(name, "CMS"))
        {
          break;
        }
      }
      free(v9);
      free(header);
      free(data);
      if (!PEM_read_bio(bp, &namea, &header, &data, &len)) {
        goto LABEL_32;
      }
    }
    int v18 = header;
    if (PEM_get_EVP_CIPHER_INFO(header, &cipher) && (uint64_t v19 = data, PEM_do_header(&cipher, data, &len, cb, u)))
    {
      *punsigned int data = v19;
      *puint64_t len = len;
      if (pnm)
      {
        *pnm = v9;
        free(v18);
        return 1;
      }
      int v17 = 1;
    }
    else
    {
      int v17 = 0;
    }
    free(v9);
    free(v18);
    if ((v17 & 1) == 0) {
      free(data);
    }
  }
  else
  {
LABEL_32:
    if ((ERR_peek_error() & 0xFFF) == 0x6C) {
      ERR_asprintf_error_data("Expecting: %s", name);
    }
    return 0;
  }
  return v17;
}

int PEM_read_bio(BIO *bp, char **name, char **header, unsigned __int8 **data, uint64_t *len)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  int outl = 0;
  int v10 = BUF_MEM_new();
  int v11 = BUF_MEM_new();
  signed int v12 = BUF_MEM_new();
  int v13 = v12;
  if (!v10 || !v11 || !v12)
  {
    BUF_MEM_free(v10);
    BUF_MEM_free(v11);
    BUF_MEM_free(v13);
    ERR_put_error(9, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", 685);
    return 0;
  }
  int v45 = len;
  str = v11;
  int v43 = header;
  int v44 = data;
  signed int v14 = v10;
  int v47 = v12;
  memset(&ctx, 0, sizeof(ctx));
  int v49 = 0;
  v51[243] = 0;
  int v15 = BIO_gets(bp, buf, 254);
  if (v15 < 1)
  {
LABEL_16:
    ERR_put_error(9, 4095, 108, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", 694);
    int v20 = str;
    uint64_t v19 = v47;
    int v21 = v10;
    goto LABEL_17;
  }
  while (1)
  {
    do
    {
      if ((char)buf[v15] > 32) {
        goto LABEL_9;
      }
      BOOL v16 = v15-- <= 0;
    }
    while (!v16);
    int v15 = -1;
LABEL_9:
    *(_WORD *)&buf[v15 + 1] = 10;
    if (*(void *)buf == 0x4745422D2D2D2D2DLL && *(void *)&buf[3] == 0x204E494745422D2DLL)
    {
      size_t v18 = strlen(v51);
      if (!strncmp(&buf[(uint64_t)((v18 << 32) + 0x500000000) >> 32], "-----\n", 6uLL)) {
        break;
      }
    }
    int v15 = BIO_gets(bp, buf, 254);
    if (v15 < 1) {
      goto LABEL_16;
    }
  }
  size_t v23 = v18 << 32;
  int v21 = v10;
  if (!BUF_MEM_grow(v10, ((v18 << 32) + 0x900000000) >> 32))
  {
    ERR_put_error(9, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", 709);
    int v20 = str;
    uint64_t v19 = v47;
    goto LABEL_17;
  }
  memcpy(v10->data, v51, (uint64_t)(v23 - 0x600000000) >> 32);
  v10->data[(uint64_t)(v23 - 0x600000000) >> 32] = 0;
  uint64_t v19 = v47;
  if (!BUF_MEM_grow(str, 256))
  {
    int v30 = 719;
    goto LABEL_69;
  }
  *str->unsigned int data = 0;
  int v24 = BIO_gets(bp, buf, 254);
  if (v24 >= 1)
  {
    int v25 = 0;
    while (1)
    {
      if ((char)buf[v24] > 32) {
        goto LABEL_29;
      }
      BOOL v16 = v24-- <= 0;
      if (v16)
      {
        int v24 = -1;
LABEL_29:
        *(_WORD *)&buf[v24 + 1] = 10;
        if (buf[0] == 10) {
          goto LABEL_40;
        }
        size_t v26 = v24 + 2;
        uint64_t v27 = v24 + 2 + (uint64_t)v25;
        if (!BUF_MEM_grow(str, v27 + 9))
        {
          int v30 = 736;
          goto LABEL_69;
        }
        if (*(void *)buf == 0x444E452D2D2D2D2DLL && buf[8] == 32)
        {
          int v29 = 0;
          goto LABEL_43;
        }
        memcpy(&str->data[v25], buf, v26);
        str->data[v27] = 0;
        int v24 = BIO_gets(bp, buf, 254);
        int v25 = v27;
        if (v24 <= 0)
        {
          int v29 = 1;
          int v25 = v27;
          goto LABEL_43;
        }
      }
    }
  }
  int v25 = 0;
LABEL_40:
  int v29 = 1;
LABEL_43:
  int outl = 0;
  if (!BUF_MEM_grow(v47, 1024))
  {
    int v30 = 750;
    goto LABEL_69;
  }
  *v47->unsigned int data = 0;
  if (!v29)
  {
    int outl = v25;
    LODWORD(v3md5_block_data_order((unint64_t)c, b, 1) = v25;
    int v20 = v47;
    uint64_t v19 = str;
LABEL_71:
    BOOL v38 = *(void *)buf == 0x444E452D2D2D2D2DLL && buf[8] == 32;
    if (v38
      && (size_t v39 = strlen(v14->data), !strncmp(v21->data, &buf[9], (int)v39))
      && !strncmp(&buf[(uint64_t)((v39 << 32) + 0x900000000) >> 32], "-----\n", 6uLL))
    {
      EVP_DecodeInit(&ctx);
      if (EVP_DecodeUpdate(&ctx, (unsigned __int8 *)v19->data, &outl, (const unsigned __int8 *)v19->data, v31) < 0)
      {
        int v40 = 100;
        int v41 = 811;
      }
      else
      {
        if ((EVP_DecodeFinal(&ctx, (unsigned __int8 *)&v19->data[outl], &v49) & 0x80000000) == 0)
        {
          uint64_t v42 = outl + (uint64_t)v49;
          int outl = v42;
          if (!v42) {
            goto LABEL_17;
          }
          char *name = v21->data;
          *int v43 = v20->data;
          *int v44 = (unsigned __int8 *)v19->data;
          *int v45 = v42;
          free(v21);
          free(v20);
          free(v19);
          return 1;
        }
        int v40 = 100;
        int v41 = 816;
      }
    }
    else
    {
      int v40 = 102;
      int v41 = 802;
    }
    ERR_put_error(9, 4095, v40, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", v41);
    goto LABEL_17;
  }
  LODWORD(v3md5_block_data_order((unint64_t)c, b, 1) = 0;
  while (1)
  {
    int v32 = BIO_gets(bp, buf, 254);
    if (v32 < 1) {
      goto LABEL_67;
    }
    while ((char)buf[v32] <= 32)
    {
      BOOL v16 = v32-- <= 0;
      if (v16)
      {
        int v32 = -1;
        break;
      }
    }
    buf[v32 + 1] = 10;
    size_t v33 = (v32 + 2);
    buf[v33] = 0;
    BOOL v34 = *(void *)buf == 0x444E452D2D2D2D2DLL && buf[8] == 32;
    BOOL v35 = !v34;
    if (v32 > 63 || !v35) {
      goto LABEL_67;
    }
    if (!BUF_MEM_grow_clean(v47, v32 + v31 + 11)) {
      break;
    }
    int v36 = v31;
    memcpy(&v47->data[(int)v31], buf, v33);
    uint64_t v31 = (int)v31 + (uint64_t)(int)v33;
    v47->data[v31] = 0;
    int outl = v36 + v33;
    if (v33 != 65)
    {
      buf[0] = 0;
      int v37 = BIO_gets(bp, buf, 254);
      if (v37 >= 1)
      {
        while ((char)buf[v37] <= 32)
        {
          BOOL v16 = v37-- <= 0;
          if (v16)
          {
            int v37 = -1;
            break;
          }
        }
        buf[v37 + 1] = 10;
        buf[v37 + 2] = 0;
      }
LABEL_67:
      int v20 = str;
      goto LABEL_71;
    }
  }
  int v30 = 772;
LABEL_69:
  ERR_put_error(9, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", v30);
  int v20 = str;
LABEL_17:
  BUF_MEM_free(v21);
  BUF_MEM_free(v20);
  BUF_MEM_free(v19);
  return 0;
}

int PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher)
{
  cipher->EVP_CIPHER_INFO cipher = 0;
  if (!header) {
    return 1;
  }
  if (!*header || *header == 10) {
    return 1;
  }
  if (!strncmp(header, "Proc-Type: ", 0xBuLL))
  {
    if (header[11] != 52 || header[12] != 44) {
      return 0;
    }
    if (!strncmp(header + 13, "ENCRYPTED", 9uLL))
    {
      for (uint64_t i = header + 24; ; ++i)
      {
        if (!*(i - 11))
        {
          int v6 = 112;
          int v7 = 515;
          goto LABEL_10;
        }
        if (*(i - 11) == 10) {
          break;
        }
      }
      if (!strncmp(i - 10, "DEK-Info: ", 0xAuLL))
      {
        int v9 = i;
        do
        {
          do
          {
            signed int v14 = v9;
            int v11 = *(unsigned __int8 *)v9++;
            int v10 = v11;
          }
          while ((v11 - 48) < 0xA);
        }
        while (v10 == 45 || (v10 - 65) < 0x1A);
        *((unsigned char *)v9 - md5_block_data_order((unint64_t)c, b, 1) = 0;
        cipherbyname = EVP_get_cipherbyname(i);
        cipher->EVP_CIPHER_INFO cipher = cipherbyname;
        *((unsigned char *)v9 - md5_block_data_order((unint64_t)c, b, 1) = v10;
        signed int v14 = v9;
        if (cipherbyname) {
          return load_iv((uint64_t *)&v14, cipher->iv, cipherbyname->iv_len);
        }
        int v6 = 114;
        int v7 = 539;
      }
      else
      {
        int v6 = 105;
        int v7 = 520;
      }
    }
    else
    {
      int v6 = 106;
      int v7 = 509;
    }
  }
  else
  {
    int v6 = 107;
    int v7 = 498;
  }
LABEL_10:
  ERR_put_error(9, 4095, v6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", v7);
  return 0;
}

int PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned __int8 *data, uint64_t *len, pem_password_cb *callback, void *u)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (!cipher->cipher) {
    return 1;
  }
  uint64_t v7 = *len;
  int outl = 0;
  memset(&a, 0, sizeof(a));
  if (callback) {
    int v8 = ((uint64_t (*)(char *, uint64_t, void, void *))callback)(buf, 1024, 0, u);
  }
  else {
    int v8 = PEM_def_callback(buf, 1024, 0, u);
  }
  int v9 = v8;
  if (v8 <= 0)
  {
    ERR_put_error(9, 4095, 104, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", 461);
    return 0;
  }
  else
  {
    int v10 = cipher->cipher;
    int v11 = EVP_md5();
    int result = EVP_BytesToKey(v10, v11, cipher->iv, (const unsigned __int8 *)buf, v9, 1, key, 0);
    if (result)
    {
      int v13 = v7;
      EVP_CIPHER_CTX_init(&a);
      if (EVP_DecryptInit_ex(&a, cipher->cipher, 0, key, cipher->iv))
      {
        if (EVP_DecryptUpdate(&a, data, &outl, data, v7))
        {
          EVP_DecryptFinal_ex(&a, &data[outl], &v13);
          EVP_CIPHER_CTX_cleanup(&a);
          explicit_bzero(buf, 0x400uLL);
        }
      }
      EVP_CIPHER_CTX_cleanup(&a);
      explicit_bzero(buf, 0x400uLL);
    }
  }
  return result;
}

int PEM_ASN1_write(i2d_of_void *i2d, const char *name, FILE *fp, char *x, const EVP_CIPHER *enc, unsigned __int8 *kstr, int klen, pem_password_cb *callback, void *u)
{
  int v17 = BIO_s_file();
  uint64_t v18 = BIO_new(v17);
  if (v18)
  {
    uint64_t v19 = v18;
    BIO_ctrl(v18, 106, 0, fp);
    int v20 = PEM_ASN1_write_bio(i2d, name, v19, x, enc, kstr, klen, callback, u);
    BIO_free(v19);
    return v20;
  }
  else
  {
    ERR_put_error(9, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", 335);
    return 0;
  }
}

int PEM_ASN1_write_bio(i2d_of_void *i2d, const char *name, BIO *bp, char *x, const EVP_CIPHER *enc, unsigned __int8 *kstr, int klen, pem_password_cb *cb, void *u)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  memset(&a, 0, sizeof(a));
  int v32 = 0;
  *(void *)int outl = 0;
  if (enc)
  {
    int v17 = EVP_CIPHER_nid(enc);
    uint64_t v18 = OBJ_nid2sn(v17);
    if (!v18)
    {
      int v19 = 113;
      int v20 = 360;
LABEL_12:
      ERR_put_error(9, 4095, v19, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", v20);
      goto LABEL_28;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  int v21 = ((uint64_t (*)(char *, void))i2d)(x, 0);
  if (v21 < 0)
  {
    int v19 = 13;
    int v20 = 366;
    goto LABEL_12;
  }
  bpEVP_CIPHER_CTX a = bp;
  int v22 = (unsigned __int8 *)malloc_type_malloc((v21 + 20), 0xEA451B8DuLL);
  size_t v23 = v22;
  if (v22)
  {
    int v32 = v22;
    int v24 = ((uint64_t (*)(char *, unsigned __int8 **))i2d)(x, &v32);
    outl[1] = v24;
    if (enc)
    {
      if (!kstr)
      {
        if (cb) {
          int v25 = ((uint64_t (*)(char *, uint64_t, uint64_t, void *))cb)(hdr, 1024, 1, u);
        }
        else {
          int v25 = PEM_def_callback(hdr, 1024, 1, u);
        }
        kuint64_t len = v25;
        if (v25 <= 0)
        {
          int v26 = 111;
          int v27 = 387;
          goto LABEL_27;
        }
        kstr = (unsigned __int8 *)hdr;
      }
      size_t iv_len = enc->iv_len;
      if (iv_len >= 0x11)
      {
        int v26 = 102;
        int v27 = 393;
        goto LABEL_27;
      }
      arc4random_buf(__buf, iv_len);
      int v29 = EVP_md5();
      if (!EVP_BytesToKey(enc, v29, (const unsigned __int8 *)__buf, kstr, klen, 1, key, 0)) {
        goto LABEL_28;
      }
      if (kstr == (unsigned __int8 *)hdr) {
        explicit_bzero(hdr, 0x400uLL);
      }
      if (strlen(v18) + 2 * enc->iv_len - 989 <= 0xFFFFFFFFFFFFFBFELL)
      {
        int v26 = 107;
        int v27 = 407;
        goto LABEL_27;
      }
      hdr[0] = 0;
      PEM_proc_type(hdr, 10);
      PEM_dek_info(hdr, v18, enc->iv_len, __buf);
      EVP_CIPHER_CTX_init(&a);
      if (!EVP_EncryptInit_ex(&a, enc, 0, key, (const unsigned __int8 *)__buf)
        || !EVP_EncryptUpdate(&a, v23, outl, v23, v24)
        || !EVP_EncryptFinal_ex(&a, &v23[outl[0]], &outl[1]))
      {
        EVP_CIPHER_CTX_cleanup(&a);
LABEL_28:
        explicit_bzero(key, 0x40uLL);
      }
      EVP_CIPHER_CTX_cleanup(&a);
      int v24 = outl[1] + outl[0];
      outl[1] += outl[0];
    }
    else
    {
      hdr[0] = 0;
    }
    outl[1] = PEM_write_bio(bpa, name, hdr, v23, v24);
    goto LABEL_28;
  }
  int v26 = 65;
  int v27 = 374;
LABEL_27:
  ERR_put_error(9, 4095, v26, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", v27);
  goto LABEL_28;
}

int PEM_write_bio(BIO *bp, const char *name, char *hdr, unsigned __int8 *data, uint64_t len)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  int outl = 0;
  memset(&ctx, 0, sizeof(ctx));
  EVP_EncodeInit(&ctx);
  int v10 = strlen(name);
  if (BIO_write(bp, "-----BEGIN ", 11) != 11) {
    goto LABEL_30;
  }
  if (BIO_write(bp, name, v10) != v10) {
    goto LABEL_30;
  }
  if (BIO_write(bp, "-----\n", 6) != 6) {
    goto LABEL_30;
  }
  if (hdr)
  {
    int v11 = strlen(hdr);
    if (v11 >= 1 && (BIO_write(bp, hdr, v11) != v11 || BIO_write(bp, "\n", 1) != 1)) {
      goto LABEL_30;
    }
  }
  signed int v12 = (unsigned __int8 *)reallocarray(0, 0x400uLL, 8uLL);
  if (v12)
  {
    if (len >= 1)
    {
      int v13 = 0;
      int v14 = 0;
      while (1)
      {
        uint64_t v15 = len >= 5120 ? 5120 : len;
        EVP_EncodeUpdate(&ctx, v12, &outl, &data[v13], v15);
        if (!v16) {
          goto LABEL_31;
        }
        if (outl)
        {
          int v17 = BIO_write(bp, v12, outl);
          if (v17 != outl) {
            goto LABEL_31;
          }
        }
        else
        {
          int v17 = 0;
        }
        v14 += v17;
        v13 += v15;
        BOOL v18 = len <= v15;
        len -= v15;
        if (v18) {
          goto LABEL_24;
        }
      }
    }
    int v14 = 0;
LABEL_24:
    EVP_EncodeFinal(&ctx, v12, &outl);
    if (outl >= 1)
    {
      int v20 = BIO_write(bp, v12, outl);
      if (v20 != outl) {
        goto LABEL_31;
      }
    }
    freezero(v12, 0x2000uLL);
    if (BIO_write(bp, "-----END ", 9) == 9 && BIO_write(bp, name, v10) == v10 && BIO_write(bp, "-----\n", 6) == 6) {
      return outl + v14;
    }
LABEL_30:
    signed int v12 = 0;
LABEL_31:
    int v19 = 7;
    goto LABEL_32;
  }
  int v19 = 65;
LABEL_32:
  freezero(v12, 0x2000uLL);
  ERR_put_error(9, 4095, v19, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", 647);
  return 0;
}

uint64_t load_iv(uint64_t *a1, void *a2, int a3)
{
  uint64_t v4 = *a1;
  if (a3 < 1)
  {
LABEL_12:
    *a1 = v4;
    return 1;
  }
  bzero(a2, a3);
  int v7 = 0;
  uint64_t v8 = 0;
  int v9 = 2 * a3;
  if (2 * a3 <= 1) {
    int v9 = 1;
  }
  while (1)
  {
    int v10 = *(unsigned __int8 *)(v4 + v8);
    if ((v10 - 48) >= 0xA) {
      break;
    }
    int v11 = -48;
LABEL_10:
    *((unsigned char *)a2 + (v8++ >> 1)) |= (v11 + v10) << (~(_BYTE)v7 & 4);
    v7 += 4;
    if (v9 == v8)
    {
      v4 += v8;
      goto LABEL_12;
    }
  }
  if ((v10 - 65) < 6)
  {
    int v11 = -55;
    goto LABEL_10;
  }
  if ((v10 - 97) < 6)
  {
    int v11 = -87;
    goto LABEL_10;
  }
  ERR_put_error(9, 4095, 103, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", 566);
  return 0;
}

int PEM_write(FILE *fp, char *name, char *hdr, unsigned __int8 *data, uint64_t len)
{
  int v10 = BIO_s_file();
  int v11 = BIO_new(v10);
  if (v11)
  {
    signed int v12 = v11;
    BIO_ctrl(v11, 106, 0, fp);
    int v13 = PEM_write_bio(v12, name, hdr, data, len);
    BIO_free(v12);
    return v13;
  }
  else
  {
    ERR_put_error(9, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", 585);
    return 0;
  }
}

int PEM_read(FILE *fp, char **name, char **header, unsigned __int8 **data, uint64_t *len)
{
  int v10 = BIO_s_file();
  int v11 = BIO_new(v10);
  if (v11)
  {
    signed int v12 = v11;
    BIO_ctrl(v11, 106, 0, fp);
    biASN1_OBJECT o = PEM_read_bio(v12, name, header, data, len);
    BIO_free(v12);
    return bio;
  }
  else
  {
    ERR_put_error(9, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_lib.c", 658);
    return 0;
  }
}

uint64_t pem_check_suffix(const char *a1, const char *a2)
{
  int v4 = strlen(a1);
  int v5 = strlen(a2);
  if (v5 + 1 < v4
    && (int v6 = &a1[v4 - v5], !strcmp(v6, a2))
    && (v8 = *((unsigned __int8 *)v6 - 1), int v7 = v6 - 1, v8 == 32))
  {
    return (v7 - a1);
  }
  else
  {
    return 0;
  }
}

uint64_t asn1_get_identifier_cbs(void *a1, int a2, unsigned char *a3, int *a4, int *a5)
{
  unsigned __int8 v17 = 0;
  *a3 = 0;
  *a4 = 0;
  *a5 = 0;
  uint64_t result = CBS_get_u8(a1, &v17);
  if (result)
  {
    unsigned int v11 = v17;
    int v12 = v17 & 0x1F;
    if (v12 == 31)
    {
      unsigned int v13 = 0;
      while (1)
      {
        uint64_t result = CBS_get_u8(a1, &v17);
        if (!result) {
          break;
        }
        if (v17 == 128 && v13 == 0 && a2 != 0 || v13 >> 25 != 0) {
          return 0;
        }
        int v12 = v17 & 0x7F | (v13 << 7);
        unsigned int v13 = v12;
        if ((v17 & 0x80) == 0) {
          goto LABEL_17;
        }
      }
    }
    else
    {
LABEL_17:
      *a3 = v11 >> 6;
      *a4 = (v11 >> 5) & 1;
      *a5 = v12;
      return 1;
    }
  }
  return result;
}

uint64_t asn1_get_length_cbs(void *a1, int a2, _DWORD *a3, unint64_t *a4)
{
  unsigned __int8 v14 = 0;
  *a4 = 0;
  *a3 = 0;
  uint64_t result = CBS_get_u8(a1, &v14);
  if (result)
  {
    if (((char)v14 & 0x80000000) == 0)
    {
      *a4 = v14;
      return 1;
    }
    if (v14 == 128)
    {
      uint64_t result = 1;
      *a3 = 1;
    }
    else
    {
      int v9 = v14 & 0x7F;
      if ((v14 & 0x7F) == 0)
      {
        unint64_t v10 = v14 & 0x7F;
LABEL_26:
        *a4 = v10;
        return 1;
      }
      if (v9 == 127)
      {
        return 0;
      }
      else
      {
        unint64_t v10 = 0;
        while (1)
        {
          uint64_t result = CBS_get_u8(a1, &v14);
          if (!result) {
            break;
          }
          if (v14) {
            BOOL v11 = 0;
          }
          else {
            BOOL v11 = v10 == 0;
          }
          if (v11 && a2 != 0 || HIBYTE(v10) != 0) {
            return 0;
          }
          --v9;
          unint64_t v10 = v14 | (v10 << 8);
          if (!(_BYTE)v9) {
            goto LABEL_26;
          }
        }
      }
    }
  }
  return result;
}

uint64_t asn1_get_object_cbs(void *a1, int a2, unsigned char *a3, int *a4, _DWORD *a5, _DWORD *a6, void *a7)
{
  int v21 = 0;
  int v19 = 0;
  char v18 = 0;
  *a3 = 0;
  *a4 = 0;
  *a5 = 0;
  *a6 = 0;
  *a7 = 0;
  uint64_t result = asn1_get_identifier_cbs(a1, a2, &v18, &v21, &v19);
  if (result)
  {
    int v20 = 0;
    unint64_t v17 = 0;
    uint64_t result = asn1_get_length_cbs(a1, a2, &v20, &v17);
    if (result)
    {
      int v15 = v20;
      int v16 = v21;
      if (!v20 || v21)
      {
        *a3 = v18;
        *a4 = v16;
        *a5 = v19;
        *a6 = v15;
        *a7 = v17;
        return 1;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t asn1_get_primitive(uint64_t *a1, int a2, _DWORD *a3, void *a4)
{
  HIDWORD(v12) = 0;
  int v11 = 0;
  *a3 = 0;
  CBS_init(a4, 0, 0);
  uint64_t result = asn1_get_identifier_cbs(a1, a2, &v10, (int *)&v12 + 1, &v11);
  if (result)
  {
    LODWORD(v12) = 0;
    unint64_t v9 = 0;
    uint64_t result = asn1_get_length_cbs(a1, a2, &v12, &v9);
    if (result)
    {
      if (v12)
      {
        return 0;
      }
      else
      {
        uint64_t result = CBS_get_bytes(a1, a4, v9);
        if (result)
        {
          *a3 = v11;
          return 1;
        }
      }
    }
  }
  return result;
}

int DSA_generate_key(DSA *a)
{
  comunsigned int p = (uint64_t (*)(void))a->ex_data.sk[2].comp;
  if (!comp)
  {
    int v4 = BN_new();
    if (v4)
    {
      int v5 = BN_new();
      if (v5)
      {
        int v6 = BN_CTX_new();
        if (v6)
        {
          int v7 = (BIGNUM *)BN_value_one();
          if (bn_rand_interval(v4, v7, a->p))
          {
            if (BN_mod_exp_ct(v5, a->q, v4, *(const BIGNUM **)&a->write_params, v6))
            {
              BN_free(a->pub_key);
              a->pub_uint64_t key = v4;
              BN_free(a->g);
              int v4 = 0;
              a->g = v5;
              int v8 = 1;
              int v5 = 0;
LABEL_14:
              BN_free(v5);
              BN_free(v4);
              BN_CTX_free(v6);
              return v8;
            }
          }
        }
LABEL_13:
        int v8 = 0;
        goto LABEL_14;
      }
    }
    else
    {
      int v5 = 0;
    }
    int v6 = 0;
    goto LABEL_13;
  }
  return comp();
}

const EVP_CIPHER *EVP_des_cbc(void)
{
  return (const EVP_CIPHER *)&des_cbc;
}

const EVP_CIPHER *EVP_des_cfb64(void)
{
  return (const EVP_CIPHER *)&des_cfb64;
}

const EVP_CIPHER *EVP_des_ofb(void)
{
  return (const EVP_CIPHER *)&des_ofb;
}

const EVP_CIPHER *EVP_des_ecb(void)
{
  return (const EVP_CIPHER *)&des_ecb;
}

const EVP_CIPHER *EVP_des_cfb1(void)
{
  return (const EVP_CIPHER *)&des_cfb1;
}

const EVP_CIPHER *EVP_des_cfb8(void)
{
  return (const EVP_CIPHER *)&des_cfb8;
}

uint64_t des_init_key(uint64_t a1, const_DES_cblock *key)
{
  return 1;
}

uint64_t des_cbc_cipher(uint64_t a1, unsigned __int8 *output, unsigned __int8 *input, unint64_t length)
{
  for (unint64_t i = length; i > 0x7FFFFFFFFFFFFEFFLL; output += 0x7FFFFFFFFFFFFF00)
  {
    DES_ncbc_encrypt(input, output, 0x7FFFFFFFFFFFFF00, *(DES_key_schedule **)(a1 + 120), (DES_cblock *)(a1 + 40), *(_DWORD *)(a1 + 16));
    i -= 0x7FFFFFFFFFFFFF00;
    input += 0x7FFFFFFFFFFFFF00;
  }
  if (i) {
    DES_ncbc_encrypt(input, output, i, *(DES_key_schedule **)(a1 + 120), (DES_cblock *)(a1 + 40), *(_DWORD *)(a1 + 16));
  }
  return 1;
}

uint64_t des_ctrl(int a1, int a2, int a3, DES_cblock *ret)
{
  if (a2 == 6) {
    return DES_random_key(ret) != 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t des_cfb64_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t length)
{
  for (unint64_t i = length; i > 0x7FFFFFFFFFFFFEFFLL; out += 0x7FFFFFFFFFFFFF00)
  {
    DES_cfb64_encrypt(in, out, 0x7FFFFFFFFFFFFF00, *(DES_key_schedule **)(a1 + 120), (DES_cblock *)(a1 + 40), (int *)(a1 + 88), *(_DWORD *)(a1 + 16));
    i -= 0x7FFFFFFFFFFFFF00;
    in += 0x7FFFFFFFFFFFFF00;
  }
  if (i) {
    DES_cfb64_encrypt(in, out, i, *(DES_key_schedule **)(a1 + 120), (DES_cblock *)(a1 + 40), (int *)(a1 + 88), *(_DWORD *)(a1 + 16));
  }
  return 1;
}

uint64_t des_ofb_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t length)
{
  for (unint64_t i = length; i > 0x7FFFFFFFFFFFFEFFLL; out += 0x7FFFFFFFFFFFFF00)
  {
    DES_ofb64_encrypt(in, out, 0x7FFFFFFFFFFFFF00, *(DES_key_schedule **)(a1 + 120), (DES_cblock *)(a1 + 40), (int *)(a1 + 88));
    i -= 0x7FFFFFFFFFFFFF00;
    in += 0x7FFFFFFFFFFFFF00;
  }
  if (i) {
    DES_ofb64_encrypt(in, out, i, *(DES_key_schedule **)(a1 + 120), (DES_cblock *)(a1 + 40), (int *)(a1 + 88));
  }
  return 1;
}

uint64_t des_ecb_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4 = *(int *)(*(void *)a1 + 4);
  unint64_t v5 = a4 - v4;
  if (a4 >= v4)
  {
    unint64_t v9 = 0;
    do
    {
      DES_ecb_encrypt((const_DES_cblock *)(a3 + v9), (DES_cblock *)(a2 + v9), *(DES_key_schedule **)(a1 + 120), *(_DWORD *)(a1 + 16));
      v9 += v4;
    }
    while (v9 <= v5);
  }
  return 1;
}

uint64_t des_cfb1_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0xFFFFFFFFFFFFFFFLL) {
      unint64_t v7 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v7 = a4;
    }
    int v8 = (DES_cblock *)(a1 + 40);
    do
    {
      unint64_t v12 = a4;
      if (v7)
      {
        unint64_t v9 = 0;
        if (8 * v7 <= 1) {
          uint64_t v10 = 1;
        }
        else {
          uint64_t v10 = 8 * v7;
        }
        do
        {
          unsigned __int8 in = *(unsigned __int8 *)(a3 + (v9 >> 3)) >> (v9 & 7 ^ 7) << 7;
          DES_cfb_encrypt(&in, &out, 1, 1, *(DES_key_schedule **)(a1 + 120), v8, *(_DWORD *)(a1 + 16));
          *(unsigned char *)(a2 + (v9 >> 3)) = ((out & 0x80) >> (v9 & 7)) | (-129 >> (v9 & 7)) & *(unsigned char *)(a2 + (v9 >> 3));
          ++v9;
        }
        while (v10 != v9);
      }
      a3 += v7;
      a2 += v7;
      a4 = v12 - v7;
      if (v12 - v7 < v7) {
        unint64_t v7 = v12 - v7;
      }
    }
    while (a4);
  }
  return 1;
}

uint64_t des_cfb8_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t length)
{
  for (unint64_t i = length; i > 0x7FFFFFFFFFFFFEFFLL; out += 0x7FFFFFFFFFFFFF00)
  {
    DES_cfb_encrypt(in, out, 8, 0x7FFFFFFFFFFFFF00, *(DES_key_schedule **)(a1 + 120), (DES_cblock *)(a1 + 40), *(_DWORD *)(a1 + 16));
    i -= 0x7FFFFFFFFFFFFF00;
    in += 0x7FFFFFFFFFFFFF00;
  }
  if (i) {
    DES_cfb_encrypt(in, out, 8, i, *(DES_key_schedule **)(a1 + 120), (DES_cblock *)(a1 + 40), *(_DWORD *)(a1 + 16));
  }
  return 1;
}

uint64_t PKCS5_PBKDF2_HMAC(const char *a1, int a2, const unsigned __int8 *a3, int a4, int a5, EVP_MD *md, int a7, char *a8)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  int v16 = EVP_MD_size(md);
  if ((v16 & 0x80000000) == 0)
  {
    int v17 = v16;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    memset(&ctx, 0, sizeof(ctx));
    long long v39 = 0u;
    long long v40 = 0u;
    long long v38 = 0u;
    memset(&v37, 0, sizeof(v37));
    HMAC_CTX_init(&ctx);
    if (a1)
    {
      if (a2 == -1) {
        a2 = strlen(a1);
      }
    }
    else
    {
      a2 = 0;
    }
    p_HMAC_CTX ctx = &ctx;
    HMAC_Init_ex(&ctx, a1, a2, md, 0);
    if (v20)
    {
      if (!a7)
      {
        uint64_t v18 = 1;
        p_HMAC_CTX ctx = &ctx;
        goto LABEL_31;
      }
      unsigned int v21 = 1;
      size_t len = a4;
      while (1)
      {
        uint64_t v22 = a7 >= v17 ? v17 : a7;
        *(_DWORD *)unsigned int data = bswap32(v21);
        p_HMAC_CTX ctx = &ctx;
        if (!HMAC_CTX_copy((uint64_t)&v37, (uint64_t)&ctx)) {
          break;
        }
        size_t v23 = a3;
        HMAC_Update(&v37, a3, len);
        if (!v24 || (HMAC_Update(&v37, data, 4uLL), !v25) || (HMAC_Final(&v37, mda, 0), !v26))
        {
LABEL_29:
          HMAC_CTX_cleanup(&ctx);
          uint64_t v18 = 0;
          p_HMAC_CTX ctx = &v37;
          goto LABEL_31;
        }
        HMAC_CTX_cleanup(&v37);
        memcpy(a8, mda, (int)v22);
        if (a5 >= 2)
        {
          int v27 = 1;
          do
          {
            p_HMAC_CTX ctx = &ctx;
            if (!HMAC_CTX_copy((uint64_t)&v37, (uint64_t)&ctx)) {
              goto LABEL_28;
            }
            HMAC_Update(&v37, mda, v17);
            if (!v28) {
              goto LABEL_29;
            }
            HMAC_Final(&v37, mda, 0);
            if (!v29) {
              goto LABEL_29;
            }
            HMAC_CTX_cleanup(&v37);
            if ((int)v22 >= 1)
            {
              int v30 = mda;
              uint64_t v31 = v22;
              int v32 = a8;
              do
              {
                char v33 = *v30++;
                *v32++ ^= v33;
                --v31;
              }
              while (v31);
            }
          }
          while (++v27 != a5);
        }
        ++v21;
        a8 += (int)v22;
        uint64_t v18 = 1;
        p_HMAC_CTX ctx = &ctx;
        a7 -= v22;
        a3 = v23;
        if (!a7) {
          goto LABEL_31;
        }
      }
    }
LABEL_28:
    uint64_t v18 = 0;
LABEL_31:
    HMAC_CTX_cleanup(p_ctx);
    return v18;
  }
  return 0;
}

int PKCS5_PBKDF2_HMAC_SHA1(const char *pass, int passlen, const unsigned __int8 *salt, int saltlen, int iter, int keylen, unsigned __int8 *out)
{
  unsigned __int8 v14 = (EVP_MD *)EVP_sha1();
  return PKCS5_PBKDF2_HMAC(pass, passlen, salt, saltlen, iter, v14, keylen, (char *)out);
}

int PKCS5_v2_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen, ASN1_TYPE *param, const EVP_CIPHER *cipher, const EVP_MD *md, int en_de)
{
  unsigned __int8 in = 0;
  if (!param || param->type != 16 || (ptr = param->value.ptr) == 0)
  {
    ERR_put_error(6, 4095, 114, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p5_crpt2.c", 179);
    unsigned int v13 = 0;
    goto LABEL_11;
  }
  unsigned __int8 in = (unsigned __int8 *)*((void *)ptr + 1);
  unint64_t v12 = d2i_PBE2PARAM(0, (const unsigned __int8 **)&in, *(int *)ptr);
  unsigned int v13 = v12;
  if (!v12)
  {
    int v21 = 114;
    int v22 = 186;
LABEL_17:
    ERR_put_error(6, 4095, v21, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p5_crpt2.c", v22);
    goto LABEL_11;
  }
  if (OBJ_obj2nid(v12->keyfunc->algorithm) != 69)
  {
    int v21 = 124;
    int v22 = 193;
    goto LABEL_17;
  }
  int v14 = OBJ_obj2nid(v13->encryption->algorithm);
  int v15 = OBJ_nid2sn(v14);
  cipherbyname = EVP_get_cipherbyname(v15);
  if (!cipherbyname)
  {
    int v21 = 107;
    int v22 = 203;
    goto LABEL_17;
  }
  if (!EVP_CipherInit_ex(ctx, cipherbyname, 0, 0, 0, en_de))
  {
LABEL_11:
    int v19 = 0;
    goto LABEL_12;
  }
  if (EVP_CIPHER_asn1_to_param(ctx, v13->encryption->parameter) < 0)
  {
    int v21 = 122;
    int v22 = 211;
    goto LABEL_17;
  }
  int v19 = PKCS5_v2_PBKDF2_keyivgen(ctx, pass, passlen, (uint64_t)v13->keyfunc->parameter, v17, v18, en_de);
LABEL_12:
  PBE2PARAM_free(v13);
  return v19;
}

uint64_t PKCS5_v2_PBKDF2_keyivgen(EVP_CIPHER_CTX *a1, const char *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  if (!EVP_CIPHER_CTX_cipher(a1))
  {
    int v13 = 131;
    int v14 = 236;
    goto LABEL_13;
  }
  unsigned int v12 = EVP_CIPHER_CTX_key_length(a1);
  if (v12 < 0x41)
  {
    if (!a4 || *(_DWORD *)a4 != 16)
    {
      int v13 = 114;
      int v14 = 248;
      goto LABEL_13;
    }
    unsigned int v15 = v12;
    int n = 0;
    int v16 = *(int **)(a4 + 8);
    unsigned __int8 in = (unsigned __int8 *)*((void *)v16 + 1);
    uint64_t v17 = d2i_PBKDF2PARAM(0, (const unsigned __int8 **)&in, *v16);
    if (!v17)
    {
      int v13 = 114;
      int v14 = 256;
      goto LABEL_13;
    }
    uint64_t v18 = v17;
    keyuint64_t length = v17->keylength;
    if (keylength && ASN1_INTEGER_get(keylength) != v15)
    {
      int v23 = 123;
      int v24 = 264;
    }
    else
    {
      p_algorithm = (const ASN1_OBJECT **)&v18->prf->algorithm;
      if (p_algorithm) {
        int v21 = OBJ_obj2nid(*p_algorithm);
      }
      else {
        int v21 = 163;
      }
      if (EVP_PBE_find(1, v21, 0, &n, 0))
      {
        int v25 = OBJ_nid2sn(n);
        digestbyname = EVP_get_digestbyname(v25);
        if (digestbyname)
        {
          if (v18->salt->type == 4)
          {
            int v27 = (EVP_MD *)digestbyname;
            ptr = v18->salt->value.ptr;
            int v29 = (const unsigned __int8 *)*((void *)ptr + 1);
            int v30 = *(_DWORD *)ptr;
            int v31 = ASN1_INTEGER_get(v18->iter);
            if (v31 > 0)
            {
              if (PKCS5_PBKDF2_HMAC(a2, a3, v29, v30, v31, v27, v15, (char *)key)) {
                EVP_CipherInit_ex(a1, 0, 0, key, 0, a7);
              }
LABEL_28:
              explicit_bzero(key, v15);
            }
            int v23 = 135;
            int v24 = 293;
          }
          else
          {
            int v23 = 126;
            int v24 = 285;
          }
        }
        else
        {
          int v23 = 125;
          int v24 = 280;
        }
      }
      else
      {
        int v23 = 125;
        int v24 = 274;
      }
    }
    ERR_put_error(6, 4095, v23, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p5_crpt2.c", v24);
    goto LABEL_28;
  }
  int v13 = 137;
  int v14 = 241;
LABEL_13:
  ERR_put_error(6, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p5_crpt2.c", v14);
  return 0;
}

STACK *i2v_POLICY_MAPPINGS(int a1, STACK *a2, STACK *a3)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v10 = a3;
  if (a3)
  {
    unint64_t v4 = a3;
    unint64_t v5 = 0;
  }
  else
  {
    unint64_t v4 = sk_new_null();
    uint64_t v10 = v4;
    unint64_t v5 = v4;
    if (!v4) {
      return v4;
    }
  }
  if (sk_num(a2) >= 1)
  {
    int v6 = 0;
    while (1)
    {
      unint64_t v7 = sk_value(a2, v6);
      if (!v7) {
        break;
      }
      int v8 = v7;
      if (!i2t_ASN1_OBJECT(buf, 80, *(ASN1_OBJECT **)v7)
        || !i2t_ASN1_OBJECT(value, 80, *((ASN1_OBJECT **)v8 + 1))
        || !X509V3_add_value(buf, value, &v10))
      {
        break;
      }
      if (++v6 >= sk_num(a2)) {
        return v10;
      }
    }
    sk_pop_free(v5, (void (__cdecl *)(void *))X509V3_conf_free);
    return 0;
  }
  return v4;
}

STACK *v2i_POLICY_MAPPINGS(uint64_t a1, uint64_t a2, const STACK *a3)
{
  unint64_t v4 = sk_new_null();
  if (!v4)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_pmaps.c", 196);
    return v4;
  }
  if (sk_num(a3) >= 1)
  {
    int v5 = 0;
    while (1)
    {
      int v6 = sk_value(a3, v5);
      unint64_t v7 = (const char **)v6;
      if (!*((void *)v6 + 2)) {
        break;
      }
      int v8 = (const char *)*((void *)v6 + 1);
      if (!v8) {
        break;
      }
      unint64_t v9 = OBJ_txt2obj(v8, 0);
      uint64_t v10 = OBJ_txt2obj(v7[2], 0);
      int v11 = v10;
      if (v9) {
        BOOL v12 = v10 == 0;
      }
      else {
        BOOL v12 = 1;
      }
      if (v12)
      {
        int v14 = 0;
        goto LABEL_17;
      }
      uint64_t v13 = ASN1_item_new(&POLICY_MAPPING_it);
      int v14 = v13;
      if (!v13) {
        goto LABEL_19;
      }
      *(void *)uint64_t v13 = v9;
      *((void *)v13 + md5_block_data_order((unint64_t)c, b, 1) = v11;
      if (!sk_push(v4, (char *)v13))
      {
        unint64_t v9 = 0;
        int v11 = 0;
LABEL_19:
        int v16 = 0;
        int v15 = 65;
LABEL_20:
        sk_pop_free(v4, (void (__cdecl *)(void *))POLICY_MAPPING_free);
        ERR_put_error(34, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_pmaps.c", 230);
        if (v16) {
          ERR_asprintf_error_data("section:%s,name:%s,value:%s", *v7, v7[1], v7[2]);
        }
        ASN1_OBJECT_free(v9);
        ASN1_OBJECT_free(v11);
        ASN1_item_free(v14, &POLICY_MAPPING_it);
        return 0;
      }
      if (++v5 >= sk_num(a3)) {
        return v4;
      }
    }
    int v14 = 0;
    unint64_t v9 = 0;
    int v11 = 0;
LABEL_17:
    int v15 = 110;
    int v16 = 1;
    goto LABEL_20;
  }
  return v4;
}

POLICY_MAPPING *POLICY_MAPPING_new(void)
{
  return (POLICY_MAPPING *)ASN1_item_new(&POLICY_MAPPING_it);
}

void POLICY_MAPPING_free(POLICY_MAPPING *a)
{
}

int SHA384_Init(SHA512_CTX *c)
{
  *(void *)&c->int num = 0;
  *(_OWORD *)&c->u.p[96] = 0u;
  *(_OWORD *)&c->u.p[112] = 0u;
  *(_OWORD *)&c->u.p[64] = 0u;
  *(_OWORD *)&c->u.p[80] = 0u;
  *(_OWORD *)&c->u.p[32] = 0u;
  *(_OWORD *)&c->u.p[48] = 0u;
  *(_OWORD *)c->u.uint64_t d = 0u;
  *(_OWORD *)&c->u.p[16] = 0u;
  *(_OWORD *)c->h = xmmword_23C70F910;
  *(_OWORD *)&c->h[2] = xmmword_23C70F920;
  *(_OWORD *)&c->h[4] = xmmword_23C70F930;
  *(_OWORD *)&c->h[6] = xmmword_23C70F940;
  *(_OWORD *)&c->Nl = 0u;
  c->unsigned int md_len = 48;
  return 1;
}

int SHA384_Update(SHA512_CTX *c, const void *data, size_t len)
{
  return 1;
}

int SHA512_Update(SHA512_CTX *c, const void *data, size_t len)
{
  if (len)
  {
    size_t v3 = len;
    unint64_t v4 = (unint64_t *)data;
    p_u = &c->u;
    *(_OWORD *)&c->Nl += __PAIR128__(len >> 61, 8 * len);
    uint64_t num = c->num;
    if (num)
    {
      uint64_t v8 = 128 - num;
      unint64_t v9 = (char *)p_u + num;
      size_t v10 = len - (128 - num);
      if (len < 128 - num)
      {
        memcpy(v9, data, len);
        LODWORD(v3) = c->num + v3;
LABEL_10:
        c->uint64_t num = v3;
        return 1;
      }
      memcpy(v9, data, 128 - num);
      c->uint64_t num = 0;
      unint64_t v4 = (unint64_t *)((char *)v4 + v8);
      sha512_block_data_order((unint64_t)c, p_u->d, 1);
      size_t v3 = v10;
    }
    if (v3 >= 0x80)
    {
      sha512_block_data_order((unint64_t)c, v4, v3 >> 7);
      int v11 = (char *)v4 + v3;
      v3 &= 0x7Fu;
      unint64_t v4 = (unint64_t *)&v11[-v3];
    }
    if (v3)
    {
      memcpy(p_u, v4, v3);
      goto LABEL_10;
    }
  }
  return 1;
}

int SHA512_Final(unsigned __int8 *md, SHA512_CTX *c)
{
  p_u = &c->u;
  uint64_t num = c->num;
  c->u.p[num] = 0x80;
  uint64_t v6 = num + 1;
  if (num >= 0x70)
  {
    bzero((char *)p_u + v6, 127 - num);
    sha512_block_data_order((unint64_t)c, p_u->d, 1);
    uint64_t v6 = 0;
  }
  bzero((char *)p_u + v6, 112 - v6);
  int8x16_t v7 = vrev64q_s8(*(int8x16_t *)&c->Nl);
  *(int8x16_t *)&c->u.p[112] = vextq_s8(v7, v7, 8uLL);
  sha512_block_data_order((unint64_t)c, p_u->d, 1);
  int result = 0;
  if (md)
  {
    HIDWORD(v9) = c->md_len;
    LODWORD(v9) = HIDWORD(v9) - 28;
    switch((v9 >> 2))
    {
      case 0u:
        for (uint64_t i = 0; i != 3; ++i)
          *(void *)&md[i * 8] = bswap64(c->h[i]);
        *((_DWORD *)md + 6) = bswap32(HIDWORD(c->h[3]));
        goto LABEL_16;
      case 1u:
        for (uint64_t j = 0; j != 4; ++j)
          *(void *)&md[j * 8] = bswap64(c->h[j]);
        goto LABEL_16;
      case 5u:
        for (uint64_t k = 0; k != 6; ++k)
          *(void *)&md[k * 8] = bswap64(c->h[k]);
        goto LABEL_16;
      case 9u:
        for (uint64_t m = 0; m != 8; ++m)
          *(void *)&md[m * 8] = bswap64(c->h[m]);
LABEL_16:
        int result = 1;
        break;
      default:
        return result;
    }
  }
  return result;
}

unsigned __int8 *__cdecl SHA384(const unsigned __int8 *d, size_t n, unsigned __int8 *md)
{
  memset(&v5.u.p[64], 0, 72);
  if (md) {
    size_t v3 = md;
  }
  else {
    size_t v3 = (unsigned __int8 *)&SHA384_m;
  }
  *(_OWORD *)v5.h = xmmword_23C70F910;
  *(_OWORD *)&v5.h[2] = xmmword_23C70F920;
  *(_OWORD *)&v5.h[4] = xmmword_23C70F930;
  *(_OWORD *)&v5.h[6] = xmmword_23C70F940;
  memset(&v5.Nl, 0, 80);
  v5.unsigned int md_len = 48;
  SHA512_Update(&v5, d, n);
  SHA512_Final(v3, &v5);
  explicit_bzero(&v5, 0xD8uLL);
}

int SHA512_Init(SHA512_CTX *c)
{
  *(void *)&c->uint64_t num = 0;
  *(_OWORD *)&c->u.p[96] = 0u;
  *(_OWORD *)&c->u.p[112] = 0u;
  *(_OWORD *)&c->u.p[64] = 0u;
  *(_OWORD *)&c->u.p[80] = 0u;
  *(_OWORD *)&c->u.p[32] = 0u;
  *(_OWORD *)&c->u.p[48] = 0u;
  *(_OWORD *)c->u.uint64_t d = 0u;
  *(_OWORD *)&c->u.p[16] = 0u;
  *(_OWORD *)c->h = xmmword_23C70F950;
  *(_OWORD *)&c->h[2] = xmmword_23C70F960;
  *(_OWORD *)&c->h[4] = xmmword_23C70F970;
  *(_OWORD *)&c->h[6] = xmmword_23C70F980;
  *(_OWORD *)&c->Nl = 0u;
  c->unsigned int md_len = 64;
  return 1;
}

void SHA512_Transform(SHA512_CTX *c, const unsigned __int8 *data)
{
}

unint64_t sha512_block_data_order(unint64_t result, unint64_t *a2, uint64_t a3)
{
  int v123 = (void *)result;
  if (a3)
  {
    uint64_t v4 = *(void *)result;
    uint64_t v3 = *(void *)(result + 8);
    uint64_t v6 = *(void *)(result + 16);
    uint64_t v5 = *(void *)(result + 24);
    uint64_t v8 = *(void *)(result + 32);
    unint64_t v7 = *(void *)(result + 40);
    uint64_t v10 = *(void *)(result + 48);
    uint64_t v9 = *(void *)(result + 56);
    do
    {
      uint64_t v132 = a3;
      unint64_t v138 = 0;
      unint64_t v139 = bswap64(*a2);
      uint64_t v124 = v9;
      uint64_t v11 = (v7 & v8)
          + v9
          + (v10 & ~v8)
          + v139
          + (__ROR8__(v8, 14) ^ __ROR8__(v8, 18) ^ __ROR8__(v8, 41))
          + 0x428A2F98D728AE22;
      uint64_t v128 = v5;
      uint64_t v12 = v11 + v5;
      uint64_t v13 = ((v6 ^ v3) & v4 ^ v6 & v3) + (__ROR8__(v4, 28) ^ __ROR8__(v4, 34) ^ __ROR8__(v4, 39)) + v11;
      unint64_t v14 = bswap64(a2[1]);
      uint64_t v125 = v10;
      uint64_t v15 = v10
          + (v7 & ~v12)
          + (v12 & v8)
          + v14
          + 0x7137449123EF65CDLL
          + (__ROR8__(v12, 14) ^ __ROR8__(v12, 18) ^ __ROR8__(v12, 41));
      uint64_t v129 = v6;
      uint64_t v16 = v15 + v6;
      uint64_t v17 = (__ROR8__(v13, 28) ^ __ROR8__(v13, 34) ^ __ROR8__(v13, 39)) + (v13 & (v3 ^ v4) ^ v3 & v4) + v15;
      unint64_t v18 = bswap64(a2[2]);
      unint64_t v126 = v7;
      uint64_t v19 = v7
          + (v8 & ~v16)
          + (v16 & v12)
          + v18
          - 0x4A3F043013B2C4D1
          + (__ROR8__(v15 + v6, 14) ^ __ROR8__(v15 + v6, 18) ^ __ROR8__(v16, 41));
      uint64_t v130 = v3;
      uint64_t v20 = v19 + v3;
      uint64_t v21 = (__ROR8__(v17, 28) ^ __ROR8__(v17, 34) ^ __ROR8__(v17, 39)) + (v17 & (v13 ^ v4) ^ v13 & v4) + v19;
      unint64_t v22 = bswap64(a2[3]);
      uint64_t v127 = v8;
      uint64_t v23 = v8
          + (v12 & ~v20)
          + (v20 & v16)
          + v22
          - 0x164A245A7E762444
          + (__ROR8__(v20, 14) ^ __ROR8__(v20, 18) ^ __ROR8__(v20, 41));
      uint64_t v131 = v4;
      uint64_t v24 = v23 + v4;
      uint64_t v25 = (__ROR8__(v21, 28) ^ __ROR8__(v21, 34) ^ __ROR8__(v21, 39)) + (v21 & (v17 ^ v13) ^ v17 & v13) + v23;
      unint64_t v26 = bswap64(a2[4]);
      uint64_t v27 = v12
          + (v16 & ~v24)
          + (v24 & v20)
          + v26
          + 0x3956C25BF348B538
          + (__ROR8__(v24, 14) ^ __ROR8__(v24, 18) ^ __ROR8__(v24, 41));
      uint64_t v28 = v27 + v13;
      uint64_t v29 = (__ROR8__(v25, 28) ^ __ROR8__(v25, 34) ^ __ROR8__(v25, 39)) + (v25 & (v21 ^ v17) ^ v21 & v17) + v27;
      unint64_t v30 = bswap64(a2[5]);
      uint64_t v31 = v16
          + (v20 & ~v28)
          + (v28 & v24)
          + v30
          + 0x59F111F1B605D019
          + (__ROR8__(v28, 14) ^ __ROR8__(v28, 18) ^ __ROR8__(v28, 41));
      uint64_t v32 = v31 + v17;
      uint64_t v33 = (__ROR8__(v29, 28) ^ __ROR8__(v29, 34) ^ __ROR8__(v29, 39)) + (v29 & (v25 ^ v21) ^ v25 & v21) + v31;
      unint64_t v34 = bswap64(a2[6]);
      uint64_t v35 = v20
          + (v24 & ~v32)
          + (v32 & v28)
          + v34
          - 0x6DC07D5B50E6B065
          + (__ROR8__(v32, 14) ^ __ROR8__(v32, 18) ^ __ROR8__(v32, 41));
      uint64_t v36 = v35 + v21;
      uint64_t v37 = (__ROR8__(v33, 28) ^ __ROR8__(v33, 34) ^ __ROR8__(v33, 39)) + (v33 & (v29 ^ v25) ^ v29 & v25) + v35;
      unint64_t v137 = bswap64(a2[7]);
      uint64_t v38 = v24
          + (v28 & ~v36)
          + (v36 & v32)
          + v137
          - 0x54E3A12A25927EE8
          + (__ROR8__(v36, 14) ^ __ROR8__(v36, 18) ^ __ROR8__(v36, 41));
      uint64_t v39 = v38 + v25;
      uint64_t v40 = (__ROR8__(v37, 28) ^ __ROR8__(v37, 34) ^ __ROR8__(v37, 39)) + (v37 & (v33 ^ v29) ^ v33 & v29) + v38;
      unint64_t v136 = bswap64(a2[8]);
      uint64_t v41 = v28
          + (v32 & ~v39)
          + (v39 & v36)
          + v136
          - 0x27F855675CFCFDBELL
          + (__ROR8__(v39, 14) ^ __ROR8__(v39, 18) ^ __ROR8__(v39, 41));
      uint64_t v42 = v41 + v29;
      uint64_t v43 = (__ROR8__(v40, 28) ^ __ROR8__(v40, 34) ^ __ROR8__(v40, 39)) + (v40 & (v37 ^ v33) ^ v37 & v33) + v41;
      unint64_t v135 = bswap64(a2[9]);
      uint64_t v44 = v32
          + (v36 & ~v42)
          + (v42 & v39)
          + v135
          + 0x12835B0145706FBELL
          + (__ROR8__(v42, 14) ^ __ROR8__(v42, 18) ^ __ROR8__(v42, 41));
      uint64_t v45 = v44 + v33;
      uint64_t v46 = (__ROR8__(v43, 28) ^ __ROR8__(v43, 34) ^ __ROR8__(v43, 39)) + (v43 & (v40 ^ v37) ^ v40 & v37) + v44;
      unint64_t v134 = bswap64(a2[10]);
      uint64_t v47 = v36
          + (v39 & ~v45)
          + (v45 & v42)
          + v134
          + 0x243185BE4EE4B28CLL
          + (__ROR8__(v45, 14) ^ __ROR8__(v45, 18) ^ __ROR8__(v45, 41));
      uint64_t v48 = v47 + v37;
      uint64_t v49 = (__ROR8__(v46, 28) ^ __ROR8__(v46, 34) ^ __ROR8__(v46, 39)) + (v46 & (v43 ^ v40) ^ v43 & v40) + v47;
      unint64_t v50 = bswap64(a2[11]);
      uint64_t v51 = v39
          + (v42 & ~v48)
          + (v48 & v45)
          + v50
          + 0x550C7DC3D5FFB4E2
          + (__ROR8__(v48, 14) ^ __ROR8__(v48, 18) ^ __ROR8__(v48, 41));
      uint64_t v52 = v51 + v40;
      uint64_t v53 = (__ROR8__(v49, 28) ^ __ROR8__(v49, 34) ^ __ROR8__(v49, 39)) + (v49 & (v46 ^ v43) ^ v46 & v43) + v51;
      unint64_t v54 = bswap64(a2[12]);
      uint64_t v55 = v42
          + (v45 & ~v52)
          + (v52 & v48)
          + v54
          + 0x72BE5D74F27B896FLL
          + (__ROR8__(v52, 14) ^ __ROR8__(v52, 18) ^ __ROR8__(v52, 41));
      uint64_t v56 = v55 + v43;
      uint64_t v57 = (__ROR8__(v53, 28) ^ __ROR8__(v53, 34) ^ __ROR8__(v53, 39)) + (v53 & (v49 ^ v46) ^ v49 & v46) + v55;
      unint64_t v58 = bswap64(a2[13]);
      uint64_t v59 = v45
          + (v48 & ~v56)
          + (v56 & v52)
          + v58
          - 0x7F214E01C4E9694FLL
          + (__ROR8__(v55 + v43, 14) ^ __ROR8__(v55 + v43, 18) ^ __ROR8__(v56, 41));
      uint64_t v60 = v59 + v46;
      uint64_t v61 = (__ROR8__(v57, 28) ^ __ROR8__(v57, 34) ^ __ROR8__(v57, 39)) + (v57 & (v53 ^ v49) ^ v53 & v49) + v59;
      unint64_t v62 = bswap64(a2[14]);
      uint64_t v63 = v48
          + (v52 & ~v60)
          + (v60 & v56)
          + v62
          - 0x6423F958DA38EDCBLL
          + (__ROR8__(v59 + v46, 14) ^ __ROR8__(v59 + v46, 18) ^ __ROR8__(v60, 41));
      int result = v63 + v49;
      uint64_t v64 = (__ROR8__(v61, 28) ^ __ROR8__(v61, 34) ^ __ROR8__(v61, 39)) + (v61 & (v57 ^ v53) ^ v57 & v53) + v63;
      unint64_t v65 = bswap64(a2[15]);
      uint64_t v66 = v52
          + (v56 & ~result)
          + (result & v60)
          + v65
          - 0x3E640E8B3096D96CLL
          + (__ROR8__(result, 14) ^ __ROR8__(result, 18) ^ __ROR8__(result, 41));
      unint64_t v67 = v139;
      uint64_t v68 = v66 + v53;
      uint64_t v69 = (__ROR8__(v64, 28) ^ __ROR8__(v64, 34) ^ __ROR8__(v64, 39)) + (v64 & (v61 ^ v57) ^ v61 & v57) + v66;
      int v70 = &qword_23C70FB08;
      do
      {
        unint64_t v133 = v50;
        unint64_t v71 = v135
            + v67
            + (__ROR8__(v62, 19) ^ __ROR8__(v62, 61) ^ (v62 >> 6))
            + (__ROR8__(v14, 1) ^ __ROR8__(v14, 8) ^ (v14 >> 7));
        unint64_t v72 = (__ROR8__(v68, 14) ^ __ROR8__(v68, 18) ^ __ROR8__(v68, 41))
            + (result & v68)
            + v56
            + (v60 & ~v68)
            + *(v70 - 15)
            + v71;
        unint64_t v73 = v72 + v57;
        unint64_t v74 = ((v61 ^ v64) & v69 ^ v61 & v64) + (__ROR8__(v69, 28) ^ __ROR8__(v69, 34) ^ __ROR8__(v69, 39)) + v72;
        unint64_t v75 = v54;
        unint64_t v76 = v134
            + v14
            + (__ROR8__(v65, 19) ^ __ROR8__(v65, 61) ^ (v65 >> 6))
            + (__ROR8__(v18, 1) ^ __ROR8__(v18, 8) ^ (v18 >> 7));
        unint64_t v77 = v76
            + v60
            + *(v70 - 14)
            + (result & ~v73)
            + (v73 & v68)
            + (__ROR8__(v73, 14) ^ __ROR8__(v73, 18) ^ __ROR8__(v73, 41));
        unint64_t v78 = v77 + v61;
        unint64_t v79 = (__ROR8__(v74, 28) ^ __ROR8__(v74, 34) ^ __ROR8__(v74, 39)) + (v74 & (v64 ^ v69) ^ v64 & v69) + v77;
        unint64_t v140 = v71;
        unint64_t v80 = v18
            + v50
            + (__ROR8__(v22, 1) ^ __ROR8__(v22, 8) ^ (v22 >> 7))
            + (__ROR8__(v71, 19) ^ __ROR8__(v71, 61) ^ (v71 >> 6));
        int v81 = (char *)(v80
                     + result
                     + *(v70 - 13)
                     + (v68 & ~v78)
                     + (v78 & v73)
                     + (__ROR8__(v77 + v61, 14) ^ __ROR8__(v77 + v61, 18) ^ __ROR8__(v78, 41)));
        int v82 = &v81[v64];
        int v83 = &v81[(__ROR8__(v79, 28) ^ __ROR8__(v79, 34) ^ __ROR8__(v79, 39)) + (v79 & (v74 ^ v69) ^ v74 & v69)];
        unint64_t v84 = v22
            + v54
            + (__ROR8__(v26, 1) ^ __ROR8__(v26, 8) ^ (v26 >> 7))
            + (__ROR8__(v76, 19) ^ __ROR8__(v76, 61) ^ (v76 >> 6));
        uint64_t v85 = v84
            + v68
            + *(v70 - 12)
            + (v73 & ~(unint64_t)v82)
            + ((unint64_t)v82 & v78)
            + (__ROR8__(&v81[v64], 14) ^ __ROR8__(&v81[v64], 18) ^ __ROR8__(&v81[v64], 41));
        uint64_t v86 = v85 + v69;
        uint64_t v87 = (__ROR8__(v83, 28) ^ __ROR8__(v83, 34) ^ __ROR8__(v83, 39))
            + ((unint64_t)v83 & (v79 ^ v74) ^ v79 & v74)
            + v85;
        v26 += v58
             + (__ROR8__(v30, 1) ^ __ROR8__(v30, 8) ^ (v30 >> 7))
             + (__ROR8__(v80, 19) ^ __ROR8__(v80, 61) ^ (v80 >> 6));
        unint64_t v88 = v73
            + *(v70 - 11)
            + v26
            + (v78 & ~v86)
            + (v86 & (unint64_t)v82)
            + (__ROR8__(v85 + v69, 14) ^ __ROR8__(v85 + v69, 18) ^ __ROR8__(v86, 41));
        unint64_t v89 = v88 + v74;
        unint64_t v90 = (__ROR8__(v87, 28) ^ __ROR8__(v87, 34) ^ __ROR8__(v87, 39))
            + (v87 & ((unint64_t)v83 ^ v79) ^ (unint64_t)v83 & v79)
            + v88;
        v30 += v62
             + (__ROR8__(v34, 1) ^ __ROR8__(v34, 8) ^ (v34 >> 7))
             + (__ROR8__(v84, 19) ^ __ROR8__(v84, 61) ^ (v84 >> 6));
        unint64_t v91 = *(v70 - 10)
            + v78
            + v30
            + ((unint64_t)v82 & ~v89)
            + (v89 & v86)
            + (__ROR8__(v89, 14) ^ __ROR8__(v89, 18) ^ __ROR8__(v89, 41));
        unint64_t v92 = v91 + v79;
        unint64_t v93 = (__ROR8__(v90, 28) ^ __ROR8__(v90, 34) ^ __ROR8__(v90, 39))
            + (v90 & (v87 ^ (unint64_t)v83) ^ v87 & (unint64_t)v83)
            + v91;
        v34 += v65
             + (__ROR8__(v137, 1) ^ __ROR8__(v137, 8) ^ (v137 >> 7))
             + (__ROR8__(v26, 19) ^ __ROR8__(v26, 61) ^ (v26 >> 6));
        unint64_t v94 = (unint64_t)&v82[*(v70 - 9)
                                   + v34
                                   + (v86 & ~v92)
                                   + (v92 & v89)
                                   + (__ROR8__(v92, 14) ^ __ROR8__(v92, 18) ^ __ROR8__(v92, 41))];
        int v95 = &v83[v94];
        unint64_t v96 = (__ROR8__(v93, 28) ^ __ROR8__(v93, 34) ^ __ROR8__(v93, 39)) + (v93 & (v90 ^ v87) ^ v90 & v87) + v94;
        unint64_t v97 = (__ROR8__(v136, 1) ^ __ROR8__(v136, 8) ^ (v136 >> 7))
            + v137
            + v140
            + (__ROR8__(v30, 19) ^ __ROR8__(v30, 61) ^ (v30 >> 6));
        uint64_t v98 = *(v70 - 8)
            + v97
            + v86
            + (v89 & ~(unint64_t)v95)
            + ((unint64_t)v95 & v92)
            + (__ROR8__(&v83[v94], 14) ^ __ROR8__(&v83[v94], 18) ^ __ROR8__(v95, 41));
        uint64_t v99 = v98 + v87;
        uint64_t v100 = (__ROR8__(v96, 28) ^ __ROR8__(v96, 34) ^ __ROR8__(v96, 39)) + (v96 & (v93 ^ v90) ^ v93 & v90) + v98;
        unint64_t v101 = (__ROR8__(v135, 1) ^ __ROR8__(v135, 8) ^ (v135 >> 7))
             + v136
             + v76
             + (__ROR8__(v34, 19) ^ __ROR8__(v34, 61) ^ (v34 >> 6));
        uint64_t v102 = *(v70 - 7)
             + v101
             + v89
             + (v92 & ~v99)
             + (v99 & (unint64_t)v95)
             + (__ROR8__(v99, 14) ^ __ROR8__(v99, 18) ^ __ROR8__(v99, 41));
        unint64_t v103 = v102 + v90;
        uint64_t v104 = (__ROR8__(v100, 28) ^ __ROR8__(v100, 34) ^ __ROR8__(v100, 39)) + (v100 & (v96 ^ v93) ^ v96 & v93) + v102;
        unint64_t v105 = (__ROR8__(v134, 1) ^ __ROR8__(v134, 8) ^ (v134 >> 7))
             + v135
             + v80
             + (__ROR8__(v97, 19) ^ __ROR8__(v97, 61) ^ (v97 >> 6));
        uint64_t v106 = *(v70 - 6)
             + v105
             + v92
             + ((unint64_t)v95 & ~v103)
             + (v103 & v99)
             + (__ROR8__(v103, 14) ^ __ROR8__(v103, 18) ^ __ROR8__(v103, 41));
        unint64_t v107 = v106 + v93;
        uint64_t v108 = (__ROR8__(v104, 28) ^ __ROR8__(v104, 34) ^ __ROR8__(v104, 39))
             + (v104 & (v100 ^ v96) ^ v100 & v96)
             + v106;
        unint64_t v109 = (__ROR8__(v133, 1) ^ __ROR8__(v133, 8) ^ (v133 >> 7))
             + v134
             + v84
             + (__ROR8__(v101, 19) ^ __ROR8__(v101, 61) ^ (v101 >> 6));
        uint64_t v110 = (uint64_t)&v95[*(v70 - 5)
                           + v109
                           + (v99 & ~v107)
                           + (v107 & v103)
                           + (__ROR8__(v107, 14) ^ __ROR8__(v107, 18) ^ __ROR8__(v107, 41))];
        unint64_t v111 = v110 + v96;
        uint64_t v112 = (__ROR8__(v108, 28) ^ __ROR8__(v108, 34) ^ __ROR8__(v108, 39))
             + (v108 & (v104 ^ v100) ^ v104 & v100)
             + v110;
        unint64_t v135 = v105;
        unint64_t v50 = (__ROR8__(v75, 1) ^ __ROR8__(v75, 8) ^ (v75 >> 7))
            + v133
            + v26
            + (__ROR8__(v105, 19) ^ __ROR8__(v105, 61) ^ (v105 >> 6));
        unint64_t v113 = *(v70 - 4)
             + v50
             + v99
             + (v103 & ~v111)
             + (v111 & v107)
             + (__ROR8__(v110 + v96, 14) ^ __ROR8__(v110 + v96, 18) ^ __ROR8__(v111, 41));
        unint64_t v114 = v113 + v100;
        unint64_t v115 = (__ROR8__(v112, 28) ^ __ROR8__(v112, 34) ^ __ROR8__(v112, 39))
             + (v112 & (v108 ^ v104) ^ v108 & v104)
             + v113;
        unint64_t v134 = v109;
        unint64_t v54 = (__ROR8__(v58, 1) ^ __ROR8__(v58, 8) ^ (v58 >> 7))
            + v75
            + v30
            + (__ROR8__(v109, 19) ^ __ROR8__(v109, 61) ^ (v109 >> 6));
        unint64_t v116 = *(v70 - 3)
             + v54
             + v103
             + (v107 & ~v114)
             + (v114 & v111)
             + (__ROR8__(v114, 14) ^ __ROR8__(v114, 18) ^ __ROR8__(v114, 41));
        uint64_t v56 = v116 + v104;
        uint64_t v57 = (__ROR8__(v115, 28) ^ __ROR8__(v115, 34) ^ __ROR8__(v115, 39))
            + (v115 & (v112 ^ v108) ^ v112 & v108)
            + v116;
        v58 += (__ROR8__(v62, 1) ^ __ROR8__(v62, 8) ^ (v62 >> 7))
             + v34
             + (__ROR8__(v50, 19) ^ __ROR8__(v50, 61) ^ (v50 >> 6));
        unint64_t v117 = *(v70 - 2)
             + v58
             + v107
             + (v111 & ~v56)
             + (v56 & v114)
             + (__ROR8__(v116 + v104, 14) ^ __ROR8__(v116 + v104, 18) ^ __ROR8__(v56, 41));
        uint64_t v60 = v117 + v108;
        uint64_t v61 = (__ROR8__(v57, 28) ^ __ROR8__(v57, 34) ^ __ROR8__(v57, 39)) + (v57 & (v115 ^ v112) ^ v115 & v112) + v117;
        unint64_t v137 = v97;
        unint64_t v118 = (__ROR8__(v65, 1) ^ __ROR8__(v65, 8) ^ (v65 >> 7)) + v62 + v97;
        unint64_t v18 = v80;
        unint64_t v62 = v118 + (__ROR8__(v54, 19) ^ __ROR8__(v54, 61) ^ (v54 >> 6));
        unint64_t v67 = v140;
        unint64_t v119 = *(v70 - 1)
             + v62
             + v111
             + (v114 & ~v60)
             + (v60 & v56)
             + (__ROR8__(v60, 14) ^ __ROR8__(v60, 18) ^ __ROR8__(v60, 41));
        int result = v119 + v112;
        uint64_t v64 = (__ROR8__(v61, 28) ^ __ROR8__(v61, 34) ^ __ROR8__(v61, 39)) + (v61 & (v57 ^ v115) ^ v57 & v115) + v119;
        unint64_t v136 = v101;
        unint64_t v120 = (__ROR8__(v140, 1) ^ __ROR8__(v140, 8) ^ (v140 >> 7)) + v65 + v101;
        unint64_t v22 = v84;
        unint64_t v65 = v120 + (__ROR8__(v58, 19) ^ __ROR8__(v58, 61) ^ (v58 >> 6));
        uint64_t v121 = *v70;
        v70 += 16;
        unint64_t v122 = v121
             + v65
             + v114
             + (v56 & ~result)
             + (result & v60)
             + (__ROR8__(result, 14) ^ __ROR8__(result, 18) ^ __ROR8__(result, 41));
        uint64_t v68 = v122 + v115;
        uint64_t v69 = (__ROR8__(v64, 28) ^ __ROR8__(v64, 34) ^ __ROR8__(v64, 39)) + (v64 & (v61 ^ v57) ^ v61 & v57) + v122;
        unint64_t v14 = v76;
        v138 += 16;
      }
      while (v138 < 0x40);
      uint64_t v4 = v69 + v131;
      uint64_t v3 = v64 + v130;
      *int v123 = v69 + v131;
      v123[1] = v64 + v130;
      uint64_t v6 = v61 + v129;
      uint64_t v5 = v57 + v128;
      v123[2] = v61 + v129;
      v123[3] = v57 + v128;
      uint64_t v8 = v68 + v127;
      unint64_t v7 = result + v126;
      v123[4] = v68 + v127;
      v123[5] = result + v126;
      uint64_t v10 = v60 + v125;
      uint64_t v9 = v56 + v124;
      a2 += 16;
      v123[6] = v60 + v125;
      v123[7] = v56 + v124;
      a3 = v132 - 1;
    }
    while (v132 != 1);
  }
  return result;
}

unsigned __int8 *__cdecl SHA512(const unsigned __int8 *d, size_t n, unsigned __int8 *md)
{
  memset(&v5.u.p[64], 0, 72);
  if (md) {
    uint64_t v3 = md;
  }
  else {
    uint64_t v3 = (unsigned __int8 *)&SHA512_m;
  }
  *(_OWORD *)v5.h = xmmword_23C70F950;
  *(_OWORD *)&v5.h[2] = xmmword_23C70F960;
  *(_OWORD *)&v5.h[4] = xmmword_23C70F970;
  *(_OWORD *)&v5.h[6] = xmmword_23C70F980;
  memset(&v5.Nl, 0, 80);
  v5.unsigned int md_len = 64;
  SHA512_Update(&v5, d, n);
  SHA512_Final(v3, &v5);
  explicit_bzero(&v5, 0xD8uLL);
}

uint64_t SHA512_224_Init(uint64_t a1)
{
  *(void *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 16X509_check_purpose(x, -1, 0) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 8X509_check_purpose(x, -1, 0) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)a1 = xmmword_23C70F990;
  *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = xmmword_23C70F9A0;
  *(_OWORD *)(a1 + 32) = xmmword_23C70F9B0;
  *(_OWORD *)(a1 + 48) = xmmword_23C70F9C0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_DWORD *)(a1 + 212) = 28;
  return 1;
}

uint64_t SHA512_224_Update(SHA512_CTX *a1, const void *a2, size_t a3)
{
  return 1;
}

uint64_t SHA512_256_Init(uint64_t a1)
{
  *(void *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 16X509_check_purpose(x, -1, 0) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 8X509_check_purpose(x, -1, 0) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)a1 = xmmword_23C70F9D0;
  *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = xmmword_23C70F9E0;
  *(_OWORD *)(a1 + 32) = xmmword_23C70F9F0;
  *(_OWORD *)(a1 + 48) = xmmword_23C70FA00;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_DWORD *)(a1 + 212) = 32;
  return 1;
}

uint64_t SHA512_256_Update(SHA512_CTX *a1, const void *a2, size_t a3)
{
  return 1;
}

void BF_encrypt(unsigned int *data, const BF_KEY *key)
{
  unsigned int v2 = key->P[0] ^ *data;
  unsigned int v3 = key->P[1] ^ data[1] ^ (((key->S[BYTE2(v2) | 0x100] + key->S[HIBYTE(v2)]) ^ key->S[BYTE1(v2) | 0x200])
                            + key->S[(LOBYTE(key->P[0]) ^ *(unsigned char *)data) | 0x300]);
  unsigned int v4 = key->P[2] ^ v2 ^ (((key->S[BYTE2(v3) | 0x100] + key->S[HIBYTE(v3)]) ^ key->S[BYTE1(v3) | 0x200])
                       + key->S[(LOBYTE(key->P[1]) ^ *((unsigned char *)data + 4) ^ (((LOBYTE(key->S[BYTE2(v2) | 0x100])
                                                                                              + LOBYTE(key->S[HIBYTE(v2)])) ^ LOBYTE(key->S[BYTE1(v2) | 0x200]))
                                                                                            + LOBYTE(key->S[(LOBYTE(key->P[0]) ^ *(unsigned char *)data) | 0x300]))) | 0x300]);
  unsigned int v5 = key->P[3] ^ v3 ^ (((key->S[BYTE2(v4) | 0x100] + key->S[HIBYTE(v4)]) ^ key->S[BYTE1(v4) | 0x200])
                       + key->S[v4 | 0x300]);
  unsigned int v6 = key->P[4] ^ v4 ^ (((key->S[BYTE2(v5) | 0x100] + key->S[HIBYTE(v5)]) ^ key->S[BYTE1(v5) | 0x200])
                       + key->S[v5 | 0x300]);
  unsigned int v7 = key->P[5] ^ v5 ^ (((key->S[BYTE2(v6) | 0x100] + key->S[HIBYTE(v6)]) ^ key->S[BYTE1(v6) | 0x200])
                       + key->S[v6 | 0x300]);
  unsigned int v8 = key->P[6] ^ v6 ^ (((key->S[BYTE2(v7) | 0x100] + key->S[HIBYTE(v7)]) ^ key->S[BYTE1(v7) | 0x200])
                       + key->S[v7 | 0x300]);
  unsigned int v9 = key->P[7] ^ v7 ^ (((key->S[BYTE2(v8) | 0x100] + key->S[HIBYTE(v8)]) ^ key->S[BYTE1(v8) | 0x200])
                       + key->S[v8 | 0x300]);
  unsigned int v10 = key->P[8] ^ v8 ^ (((key->S[BYTE2(v9) | 0x100] + key->S[HIBYTE(v9)]) ^ key->S[BYTE1(v9) | 0x200])
                        + key->S[v9 | 0x300]);
  unsigned int v11 = key->P[9] ^ v9 ^ (((key->S[BYTE2(v10) | 0x100] + key->S[HIBYTE(v10)]) ^ key->S[BYTE1(v10) | 0x200])
                        + key->S[v10 | 0x300]);
  unsigned int v12 = key->P[10] ^ v10 ^ (((key->S[BYTE2(v11) | 0x100] + key->S[HIBYTE(v11)]) ^ key->S[BYTE1(v11) | 0x200])
                          + key->S[v11 | 0x300]);
  unsigned int v13 = key->P[11] ^ v11 ^ (((key->S[BYTE2(v12) | 0x100] + key->S[HIBYTE(v12)]) ^ key->S[BYTE1(v12) | 0x200])
                          + key->S[v12 | 0x300]);
  unsigned int v14 = key->P[12] ^ v12 ^ (((key->S[BYTE2(v13) | 0x100] + key->S[HIBYTE(v13)]) ^ key->S[BYTE1(v13) | 0x200])
                          + key->S[v13 | 0x300]);
  unsigned int v15 = key->P[13] ^ v13 ^ (((key->S[BYTE2(v14) | 0x100] + key->S[HIBYTE(v14)]) ^ key->S[BYTE1(v14) | 0x200])
                          + key->S[v14 | 0x300]);
  unsigned int v16 = key->P[14] ^ v14 ^ (((key->S[BYTE2(v15) | 0x100] + key->S[HIBYTE(v15)]) ^ key->S[BYTE1(v15) | 0x200])
                          + key->S[v15 | 0x300]);
  unsigned int v17 = key->P[15] ^ v15 ^ (((key->S[BYTE2(v16) | 0x100] + key->S[HIBYTE(v16)]) ^ key->S[BYTE1(v16) | 0x200])
                          + key->S[v16 | 0x300]);
  unsigned int v18 = key->P[16] ^ v16 ^ (((key->S[BYTE2(v17) | 0x100] + key->S[HIBYTE(v17)]) ^ key->S[BYTE1(v17) | 0x200])
                          + key->S[v17 | 0x300]);
  unsigned __int8 *data = key->P[17] ^ v17;
  data[1] = v18;
}

void BF_decrypt(unsigned int *data, const BF_KEY *key)
{
  unsigned int v2 = key->P[17] ^ *data;
  unsigned int v3 = key->P[16] ^ data[1] ^ (((key->S[BYTE2(v2) | 0x100] + key->S[HIBYTE(v2)]) ^ key->S[BYTE1(v2) | 0x200])
                             + key->S[(LOBYTE(key->P[17]) ^ *(unsigned char *)data) | 0x300]);
  unsigned int v4 = key->P[15] ^ v2 ^ (((key->S[BYTE2(v3) | 0x100] + key->S[HIBYTE(v3)]) ^ key->S[BYTE1(v3) | 0x200])
                        + key->S[(LOBYTE(key->P[16]) ^ *((unsigned char *)data + 4) ^ (((LOBYTE(key->S[BYTE2(v2) | 0x100])
                                                                                                + LOBYTE(key->S[HIBYTE(v2)])) ^ LOBYTE(key->S[BYTE1(v2) | 0x200]))
                                                                                              + LOBYTE(key->S[(LOBYTE(key->P[17]) ^ *(unsigned char *)data) | 0x300]))) | 0x300]);
  unsigned int v5 = key->P[14] ^ v3 ^ (((key->S[BYTE2(v4) | 0x100] + key->S[HIBYTE(v4)]) ^ key->S[BYTE1(v4) | 0x200])
                        + key->S[v4 | 0x300]);
  unsigned int v6 = key->P[13] ^ v4 ^ (((key->S[BYTE2(v5) | 0x100] + key->S[HIBYTE(v5)]) ^ key->S[BYTE1(v5) | 0x200])
                        + key->S[v5 | 0x300]);
  unsigned int v7 = key->P[12] ^ v5 ^ (((key->S[BYTE2(v6) | 0x100] + key->S[HIBYTE(v6)]) ^ key->S[BYTE1(v6) | 0x200])
                        + key->S[v6 | 0x300]);
  unsigned int v8 = key->P[11] ^ v6 ^ (((key->S[BYTE2(v7) | 0x100] + key->S[HIBYTE(v7)]) ^ key->S[BYTE1(v7) | 0x200])
                        + key->S[v7 | 0x300]);
  unsigned int v9 = key->P[10] ^ v7 ^ (((key->S[BYTE2(v8) | 0x100] + key->S[HIBYTE(v8)]) ^ key->S[BYTE1(v8) | 0x200])
                        + key->S[v8 | 0x300]);
  unsigned int v10 = key->P[9] ^ v8 ^ (((key->S[BYTE2(v9) | 0x100] + key->S[HIBYTE(v9)]) ^ key->S[BYTE1(v9) | 0x200])
                        + key->S[v9 | 0x300]);
  unsigned int v11 = key->P[8] ^ v9 ^ (((key->S[BYTE2(v10) | 0x100] + key->S[HIBYTE(v10)]) ^ key->S[BYTE1(v10) | 0x200])
                        + key->S[v10 | 0x300]);
  unsigned int v12 = key->P[7] ^ v10 ^ (((key->S[BYTE2(v11) | 0x100] + key->S[HIBYTE(v11)]) ^ key->S[BYTE1(v11) | 0x200])
                         + key->S[v11 | 0x300]);
  unsigned int v13 = key->P[6] ^ v11 ^ (((key->S[BYTE2(v12) | 0x100] + key->S[HIBYTE(v12)]) ^ key->S[BYTE1(v12) | 0x200])
                         + key->S[v12 | 0x300]);
  unsigned int v14 = key->P[5] ^ v12 ^ (((key->S[BYTE2(v13) | 0x100] + key->S[HIBYTE(v13)]) ^ key->S[BYTE1(v13) | 0x200])
                         + key->S[v13 | 0x300]);
  unsigned int v15 = key->P[4] ^ v13 ^ (((key->S[BYTE2(v14) | 0x100] + key->S[HIBYTE(v14)]) ^ key->S[BYTE1(v14) | 0x200])
                         + key->S[v14 | 0x300]);
  unsigned int v16 = key->P[3] ^ v14 ^ (((key->S[BYTE2(v15) | 0x100] + key->S[HIBYTE(v15)]) ^ key->S[BYTE1(v15) | 0x200])
                         + key->S[v15 | 0x300]);
  unsigned int v17 = key->P[2] ^ v15 ^ (((key->S[BYTE2(v16) | 0x100] + key->S[HIBYTE(v16)]) ^ key->S[BYTE1(v16) | 0x200])
                         + key->S[v16 | 0x300]);
  unsigned int v18 = key->P[1] ^ v16 ^ (((key->S[BYTE2(v17) | 0x100] + key->S[HIBYTE(v17)]) ^ key->S[BYTE1(v17) | 0x200])
                         + key->S[v17 | 0x300]);
  unsigned __int8 *data = key->P[0] ^ v17;
  data[1] = v18;
}

void BF_cbc_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, const BF_KEY *schedule, unsigned __int8 *ivec, int enc)
{
  uint64_t v8 = length;
  uint64_t v45 = *MEMORY[0x263EF8340];
  unsigned int v10 = bswap32(*(_DWORD *)ivec);
  unsigned int v11 = bswap32(*((_DWORD *)ivec + 1));
  if (enc)
  {
    if (length >= 8)
    {
      do
      {
        unsigned int v12 = out;
        unint64_t v13 = v8;
        v8 -= 8;
        unsigned int v14 = in + 8;
        unsigned int v15 = bswap32(*((_DWORD *)in + 1));
        unsigned int v43 = bswap32(*(_DWORD *)in) ^ v10;
        int v44 = v15 ^ v11;
        BF_encrypt(&v43, schedule);
        unsigned int v10 = v43;
        unsigned int v11 = v44;
        unsigned __int8 *out = HIBYTE(v43);
        out[1] = BYTE2(v10);
        out[2] = BYTE1(v10);
        out[3] = v10;
        out[4] = HIBYTE(v11);
        out[5] = BYTE2(v11);
        out[6] = BYTE1(v11);
        out += 8;
        v12[7] = v11;
        unsigned __int8 in = v14;
      }
      while (v13 > 0xF);
      unsigned __int8 in = v14;
    }
    if (v8)
    {
      int v16 = 0;
      unsigned int v17 = &in[v8];
      int v18 = 0;
      switch(v8)
      {
        case 1:
          goto LABEL_13;
        case 2:
          goto LABEL_12;
        case 3:
          goto LABEL_11;
        case 4:
          goto LABEL_10;
        case 5:
          goto LABEL_9;
        case 6:
          goto LABEL_8;
        case 7:
          int v19 = *--v17;
          int v16 = v19 << 8;
LABEL_8:
          int v20 = *--v17;
          v16 |= v20 << 16;
LABEL_9:
          int v21 = *--v17;
          v16 |= v21 << 24;
LABEL_10:
          int v18 = v16;
          int v22 = *--v17;
          int v16 = v22;
LABEL_11:
          int v23 = *--v17;
          v16 |= v23 << 8;
LABEL_12:
          int v24 = *--v17;
          v16 |= v24 << 16;
LABEL_13:
          v16 |= *(v17 - 1) << 24;
          break;
        default:
          int v18 = 0;
          break;
      }
      unsigned int v43 = v16 ^ v10;
      int v44 = v18 ^ v11;
      BF_encrypt(&v43, schedule);
      unsigned int v10 = v43;
      unsigned int v25 = v44;
      unsigned int v26 = HIBYTE(v43);
      unsigned __int8 *out = HIBYTE(v43);
      unsigned int v27 = HIWORD(v10);
      out[1] = BYTE2(v10);
      unsigned int v28 = v10 >> 8;
      out[2] = BYTE1(v10);
      out[3] = v10;
      unsigned int v29 = HIBYTE(v25);
      out[4] = HIBYTE(v25);
      unsigned int v30 = HIWORD(v25);
      out[5] = BYTE2(v25);
      unsigned int v31 = v25 >> 8;
      out[6] = BYTE1(v25);
      out[7] = v25;
    }
    else
    {
      unsigned int v26 = HIBYTE(v10);
      unsigned int v27 = HIWORD(v10);
      unsigned int v28 = v10 >> 8;
      unsigned int v29 = HIBYTE(v11);
      unsigned int v30 = HIWORD(v11);
      LOBYTE(v25) = v11;
      unsigned int v31 = v11 >> 8;
    }
    *ivec = v26;
    ivec[1] = v27;
    ivec[2] = v28;
    ivec[3] = v10;
    ivec[4] = v29;
    ivec[5] = v30;
    ivec[6] = v31;
  }
  else
  {
    if (length >= 8)
    {
      do
      {
        uint64_t v32 = out;
        unsigned int v33 = v10;
        unsigned int v34 = v11;
        unint64_t v35 = v8;
        v8 -= 8;
        unsigned int v10 = bswap32(*(_DWORD *)in);
        uint64_t v36 = in + 8;
        unsigned int v11 = bswap32(*((_DWORD *)in + 1));
        unsigned int v43 = v10;
        int v44 = v11;
        BF_decrypt(&v43, schedule);
        unsigned int v37 = v43 ^ v33;
        int v38 = v44 ^ v34;
        unsigned __int8 *v32 = (v43 ^ v33) >> 24;
        v32[1] = BYTE2(v37);
        v32[2] = BYTE1(v37);
        v32[3] = v37;
        v32[4] = HIBYTE(v38);
        v32[5] = BYTE2(v38);
        v32[6] = BYTE1(v38);
        unsigned __int8 out = v32 + 8;
        v32[7] = v38;
        unsigned __int8 in = v36;
      }
      while (v35 > 0xF);
      unsigned __int8 in = v36;
    }
    if (v8)
    {
      unsigned int v39 = bswap32(*(_DWORD *)in);
      unsigned int v25 = bswap32(*((_DWORD *)in + 1));
      unsigned int v43 = v39;
      int v44 = v25;
      BF_decrypt(&v43, schedule);
      unsigned int v40 = v43 ^ v10;
      int v41 = v44 ^ v11;
      uint64_t v42 = &out[v8];
      switch(v8)
      {
        case 1:
          goto LABEL_26;
        case 2:
          goto LABEL_25;
        case 3:
          goto LABEL_24;
        case 4:
          goto LABEL_23;
        case 5:
          goto LABEL_22;
        case 6:
          goto LABEL_21;
        case 7:
          *--uint64_t v42 = BYTE1(v41);
LABEL_21:
          *--uint64_t v42 = BYTE2(v41);
LABEL_22:
          *--uint64_t v42 = HIBYTE(v41);
LABEL_23:
          *--uint64_t v42 = v40;
LABEL_24:
          *--uint64_t v42 = BYTE1(v40);
LABEL_25:
          *--uint64_t v42 = BYTE2(v40);
LABEL_26:
          *(v42 - md5_block_data_order((unint64_t)c, b, 1) = HIBYTE(v40);
          break;
        default:
          break;
      }
    }
    else
    {
      unsigned int v39 = v10;
      unsigned int v25 = v11;
    }
    *ivec = HIBYTE(v39);
    ivec[1] = BYTE2(v39);
    ivec[2] = BYTE1(v39);
    ivec[3] = v39;
    ivec[4] = HIBYTE(v25);
    ivec[5] = BYTE2(v25);
    ivec[6] = BYTE1(v25);
  }
  ivec[7] = v25;
}

const ECDSA_METHOD *ECDSA_OpenSSL(void)
{
  return (const ECDSA_METHOD *)&openssl_ecdsa_meth;
}

BOOL ossl_ecdsa_sign(int a1, unsigned __int8 *dgst, int dgstlen, unsigned __int8 *a4, int *a5, BIGNUM *kinv, BIGNUM *rp, EC_KEY *eckey)
{
  punsigned int p = a4;
  unsigned int v9 = ECDSA_do_sign_ex(dgst, dgstlen, kinv, rp, eckey);
  unsigned int v10 = v9;
  if (v9)
  {
    int v11 = i2d_ECDSA_SIG(v9, &pp);
    int v12 = v11 & ~(v11 >> 31);
    BOOL v13 = v11 >= 0;
  }
  else
  {
    int v12 = 0;
    BOOL v13 = 0;
  }
  *a5 = v12;
  ECDSA_SIG_free(v10);
  return v13;
}

ECDSA_SIG *__cdecl ECDSA_do_sign_ex(const unsigned __int8 *dgst, int dgstlen, const BIGNUM *kinv, const BIGNUM *rp, EC_KEY *eckey)
{
  unsigned int v5 = *(uint64_t (**)(const unsigned __int8 *, void, const BIGNUM *, const BIGNUM *))(*(void *)eckey
                                                                                                 + 96);
  if (v5)
  {
    return (ECDSA_SIG *)v5(dgst, *(void *)&dgstlen, kinv, rp);
  }
  else
  {
    ERR_put_error(42, 4095, 144, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 590);
    return 0;
  }
}

void *ossl_ecdsa_sign_setup(EC_KEY *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int result = ecdsa_check(a1);
  if (result)
  {
    unsigned int v9 = *(uint64_t (**)(EC_KEY *, uint64_t, uint64_t, uint64_t))(result[3] + 16);
    return (void *)v9(a1, a2, a3, a4);
  }
  return result;
}

void *ossl_ecdsa_sign_sig(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, EC_KEY *a5)
{
  int result = ecdsa_check(a5);
  if (result)
  {
    int v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, EC_KEY *))(result[3] + 8);
    return (void *)v11(a1, a2, a3, a4, a5);
  }
  return result;
}

uint64_t ossl_ecdsa_verify(uint64_t a1, const unsigned __int8 *a2, int a3, unsigned __int8 *a4, int a5, EC_KEY *a6)
{
  punsigned int p = a4;
  int v16 = 0;
  v = ECDSA_SIG_new();
  if (v)
  {
    if (d2i_ECDSA_SIG(&v, (const unsigned __int8 **)&pp, a5))
    {
      int v11 = i2d_ECDSA_SIG(v, &v16);
      int v12 = v16;
      if (v11 != a5)
      {
        uint64_t v13 = 0xFFFFFFFFLL;
        a5 = v11;
        goto LABEL_10;
      }
      if (!memcmp(a4, v16, a5))
      {
        uint64_t v13 = ECDSA_do_verify(a2, a3, v, a6);
        int v12 = v16;
LABEL_10:
        freezero(v12, a5);
        ECDSA_SIG_free(v);
        return v13;
      }
    }
    else
    {
      int v12 = 0;
      a5 = -1;
    }
    uint64_t v13 = 0xFFFFFFFFLL;
    goto LABEL_10;
  }
  return 0xFFFFFFFFLL;
}

int ECDSA_do_verify(const unsigned __int8 *dgst, int dgst_len, const ECDSA_SIG *sig, EC_KEY *eckey)
{
  unsigned int v4 = *(uint64_t (**)(const unsigned __int8 *, void, const ECDSA_SIG *))(*(void *)eckey + 112);
  if (v4)
  {
    return v4(dgst, *(void *)&dgst_len, sig);
  }
  else
  {
    ERR_put_error(42, 4095, 144, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 626);
    return 0;
  }
}

void *ossl_ecdsa_verify_sig(uint64_t a1, uint64_t a2, uint64_t a3, EC_KEY *a4)
{
  int result = ecdsa_check(a4);
  if (result)
  {
    unsigned int v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, EC_KEY *))(result[3] + 24);
    return (void *)v9(a1, a2, a3, a4);
  }
  return result;
}

ECDSA_SIG *__cdecl ECDSA_do_sign(const unsigned __int8 *dgst, int dgst_len, EC_KEY *eckey)
{
  return ECDSA_do_sign_ex(dgst, dgst_len, 0, 0, eckey);
}

int ECDSA_sign(int type, const unsigned __int8 *dgst, int dgstlen, unsigned __int8 *sig, unsigned int *siglen, EC_KEY *eckey)
{
  return ECDSA_sign_ex(type, dgst, dgstlen, sig, siglen, 0, 0, eckey);
}

int ECDSA_sign_ex(int type, const unsigned __int8 *dgst, int dgstlen, unsigned __int8 *sig, unsigned int *siglen, const BIGNUM *kinv, const BIGNUM *rp, EC_KEY *eckey)
{
  uint64_t v8 = *(uint64_t (**)(void, const unsigned __int8 *, void, unsigned __int8 *, unsigned int *, const BIGNUM *, const BIGNUM *))(*(void *)eckey + 80);
  if (v8)
  {
    return v8(*(void *)&type, dgst, *(void *)&dgstlen, sig, siglen, kinv, rp);
  }
  else
  {
    ERR_put_error(42, 4095, 144, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 607);
    return 0;
  }
}

int ECDSA_sign_setup(EC_KEY *eckey, BN_CTX *ctx, BIGNUM **kinv, BIGNUM **rp)
{
  unsigned int v4 = *(uint64_t (**)(void))(*(void *)eckey + 88);
  if (v4)
  {
    return v4();
  }
  else
  {
    ERR_put_error(42, 4095, 144, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 616);
    return 0;
  }
}

int ECDSA_verify(int type, const unsigned __int8 *dgst, int dgstlen, const unsigned __int8 *sig, int siglen, EC_KEY *eckey)
{
  unsigned int v6 = *(uint64_t (**)(void, const unsigned __int8 *, void, const unsigned __int8 *, void))(*(void *)eckey + 104);
  if (v6)
  {
    return v6(*(void *)&type, dgst, *(void *)&dgstlen, sig, *(void *)&siglen);
  }
  else
  {
    ERR_put_error(42, 4095, 144, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 637);
    return 0;
  }
}

ECDSA_SIG *ecdsa_do_sign(const unsigned __int8 *a1, int a2, const BIGNUM *a3, const BIGNUM *a4, EC_KEY *a5)
{
  kinv = 0;
  unsigned int v10 = ecdsa_check(a5);
  int v11 = EC_KEY_get0_group(a5);
  int v12 = EC_KEY_get0_private_key(a5);
  if (!v11 || (uint64_t v13 = v12) == 0 || !v10)
  {
    ERR_put_error(42, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 301);
    return 0;
  }
  unsigned int v14 = ECDSA_SIG_new();
  unsigned int v15 = v14;
  if (!v14)
  {
    ERR_put_error(42, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 306);
    return v15;
  }
  unsigned int s = v14->s;
  unsigned int v17 = BN_CTX_new();
  if (!v17)
  {
    unsigned int v25 = 0;
    unsigned int v29 = 0;
    unsigned int v30 = 0;
    int v22 = 0;
    int v18 = 0;
    goto LABEL_44;
  }
  unsigned int v43 = s;
  int v18 = BN_new();
  if (!v18 || (r = BN_new()) == 0)
  {
    unsigned int v25 = 0;
    unsigned int v29 = 0;
    unsigned int v30 = 0;
    int v22 = 0;
LABEL_44:
    int v24 = 0;
LABEL_45:
    ERR_put_error(42, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 315);
    unsigned int v31 = 0;
    goto LABEL_46;
  }
  rnuint64_t d = BN_new();
  if (!rnd)
  {
    unsigned int v25 = 0;
    unsigned int v29 = 0;
    unsigned int v30 = 0;
    int v22 = 0;
    int v24 = r;
    goto LABEL_45;
  }
  int v41 = BN_new();
  if (!v41)
  {
    unsigned int v29 = 0;
    unsigned int v30 = 0;
    int v22 = 0;
    int v24 = r;
    unsigned int v25 = rnd;
    goto LABEL_45;
  }
  unsigned int v40 = BN_new();
  if (!v40)
  {
    unsigned int v30 = 0;
    int v22 = 0;
    int v24 = r;
    unsigned int v29 = v41;
    unsigned int v25 = rnd;
    goto LABEL_45;
  }
  unsigned int v39 = BN_new();
  if (!v39)
  {
    int v22 = 0;
    int v24 = r;
    unsigned int v29 = v41;
    unsigned int v25 = rnd;
    unsigned int v30 = v40;
    goto LABEL_45;
  }
  b = BN_new();
  if (!b)
  {
    int v24 = r;
    unsigned int v29 = v41;
    unsigned int v25 = rnd;
    int v22 = (BIGNUM *)v39;
    unsigned int v30 = v40;
    goto LABEL_45;
  }
  if (!EC_GROUP_get_order(v11, v18, v17))
  {
    ERR_put_error(42, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 320);
LABEL_55:
    int v24 = r;
    unsigned int v29 = v41;
    unsigned int v25 = rnd;
    unsigned int v30 = v40;
LABEL_56:
    int v22 = (BIGNUM *)v39;
    goto LABEL_75;
  }
  if (!ecdsa_prepare_digest(a1, a2, v18, b)) {
    goto LABEL_55;
  }
  if (a4) {
    BOOL v19 = a3 == 0;
  }
  else {
    BOOL v19 = 1;
  }
  if (a4) {
    BOOL v20 = a3 != 0;
  }
  else {
    BOOL v20 = 0;
  }
  BOOL v34 = v19;
  BOOL v35 = v20;
  int v21 = 33;
  int v22 = (BIGNUM *)v39;
  while (1)
  {
    int v36 = v21;
    if (!v19) {
      break;
    }
    if (!ECDSA_sign_setup(a5, v17, &kinv, &v15->r))
    {
      int v27 = 42;
      int v28 = 330;
      goto LABEL_72;
    }
    unsigned int v37 = kinv;
LABEL_26:
    int v23 = BN_value_one();
    int v24 = r;
    if (!BN_sub(r, v18, v23))
    {
      ERR_put_error(42, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 357);
      goto LABEL_73;
    }
    unsigned int v25 = rnd;
    if (!BN_rand_range(rnd, r))
    {
      int v33 = 361;
LABEL_61:
      ERR_put_error(42, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", v33);
      int v24 = r;
      goto LABEL_74;
    }
    unsigned int v26 = BN_value_one();
    if (!BN_add(rnd, rnd, v26))
    {
      int v33 = 365;
      goto LABEL_61;
    }
    if (!BN_mod_inverse_ct(v41, rnd, v18, v17))
    {
      int v33 = 370;
      goto LABEL_61;
    }
    if (!BN_mod_mul(v22, rnd, v13, v18, v17))
    {
      int v27 = 3;
      int v28 = 375;
      goto LABEL_72;
    }
    if (!BN_mod_mul(v22, v22, v15->r, v18, v17))
    {
      int v27 = 3;
      int v28 = 379;
      goto LABEL_72;
    }
    if (!BN_mod_mul(v40, rnd, b, v18, v17))
    {
      ERR_put_error(42, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 383);
      int v24 = r;
      unsigned int v29 = v41;
      unsigned int v25 = rnd;
      unsigned int v30 = v40;
      goto LABEL_56;
    }
    int v22 = (BIGNUM *)v39;
    if (!BN_mod_add(v43, v40, v39, v18, v17))
    {
      int v27 = 3;
      int v28 = 387;
      goto LABEL_72;
    }
    if (!BN_mod_mul(v43, v43, v37, v18, v17))
    {
      int v27 = 3;
      int v28 = 391;
      goto LABEL_72;
    }
    if (!BN_mod_mul(v43, v43, v41, v18, v17))
    {
      int v27 = 3;
      int v28 = 395;
      goto LABEL_72;
    }
    if (!BN_is_zero((uint64_t)v43))
    {
      int v24 = r;
      unsigned int v29 = v41;
      unsigned int v25 = rnd;
      unsigned int v30 = v40;
      unsigned int v31 = b;
      goto LABEL_47;
    }
    if (v35)
    {
      int v27 = 106;
      int v28 = 405;
      goto LABEL_72;
    }
    int v21 = v36 - 1;
    BOOL v19 = v34;
    if (v36 == 1)
    {
      int v27 = 145;
      int v28 = 410;
      goto LABEL_72;
    }
  }
  unsigned int v37 = a3;
  if (bn_copy(v15->r, a4)) {
    goto LABEL_26;
  }
  int v27 = 65;
  int v28 = 337;
LABEL_72:
  ERR_put_error(42, 4095, v27, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", v28);
  int v24 = r;
LABEL_73:
  unsigned int v25 = rnd;
LABEL_74:
  unsigned int v30 = v40;
  unsigned int v29 = v41;
LABEL_75:
  unsigned int v31 = b;
LABEL_46:
  ECDSA_SIG_free(v15);
  unsigned int v15 = 0;
LABEL_47:
  BN_CTX_free(v17);
  BN_free(v25);
  BN_free(v29);
  BN_free(v30);
  BN_free(v22);
  BN_free(kinv);
  BN_free(v31);
  BN_free(v18);
  BN_free(v24);
  return v15;
}

uint64_t ecdsa_sign_setup(const EC_KEY *a1, BN_CTX *a2, BIGNUM **a3, BIGNUM **a4)
{
  if (a1 && (unsigned int v7 = EC_KEY_get0_group(a1)) != 0)
  {
    uint64_t v8 = v7;
    unsigned int v9 = a2;
    if (a2 || (unsigned int v9 = BN_CTX_new()) != 0)
    {
      unsigned int v10 = BN_new();
      if (v10)
      {
        int v11 = BN_new();
        if (v11)
        {
          int v12 = BN_new();
          if (v12)
          {
            uint64_t v13 = BN_new();
            if (v13)
            {
              unsigned int v14 = v13;
              unsigned int v15 = EC_POINT_new(v8);
              if (v15)
              {
                if (EC_GROUP_get_order(v8, v12, v9))
                {
                  int v16 = BN_value_one();
                  if (BN_cmp(v12, v16) <= 0)
                  {
                    int v18 = 122;
                    int v19 = 178;
                  }
                  else
                  {
                    int v17 = BN_num_bits(v12);
                    if (v17 > 79)
                    {
                      int n = v17;
                      if (!BN_set_bit(v10, v17) || !BN_set_bit(v11, n) || !BN_set_bit(v14, n))
                      {
LABEL_19:
                        BN_free(v10);
                        BN_free(v11);
                        uint64_t v22 = 0;
                        if (a2)
                        {
LABEL_21:
                          BN_free(v12);
                          EC_POINT_free(v15);
                          BN_free(v14);
                          return v22;
                        }
LABEL_20:
                        BN_CTX_free(v9);
                        goto LABEL_21;
                      }
                      do
                      {
                        do
                        {
                          if (!BN_rand_range(v10, v12))
                          {
                            int v18 = 104;
                            int v19 = 198;
                            goto LABEL_27;
                          }
                        }
                        while (BN_is_zero((uint64_t)v10));
                        if (!BN_add(v11, v10, v12) || !BN_add(v14, v11, v12)) {
                          goto LABEL_19;
                        }
                        int v24 = BN_num_bits(v11) <= n ? v14 : v11;
                        if (!bn_copy(v10, v24)) {
                          goto LABEL_19;
                        }
                        BN_set_flags((uint64_t)v10, 4);
                        if (!EC_POINT_mul(v8, v15, v10, 0, 0, v9))
                        {
                          int v18 = 16;
                          int v19 = 226;
                          goto LABEL_27;
                        }
                        if (!EC_POINT_get_affine_coordinates((uint64_t)v8, v15, (uint64_t)v14, 0, v9))
                        {
                          int v18 = 16;
                          int v19 = 231;
                          goto LABEL_27;
                        }
                        if (!BN_nnmod(v11, v14, v12, v9))
                        {
                          int v18 = 3;
                          int v19 = 235;
                          goto LABEL_27;
                        }
                      }
                      while (BN_is_zero((uint64_t)v11));
                      if (BN_mod_inverse_ct(v10, v10, v12, v9))
                      {
                        BN_free(*a4);
                        BN_free(*a3);
                        *a4 = v11;
                        *a3 = v10;
                        uint64_t v22 = 1;
                        if (a2) {
                          goto LABEL_21;
                        }
                        goto LABEL_20;
                      }
                      int v18 = 3;
                      int v19 = 241;
                    }
                    else
                    {
                      int v18 = 122;
                      int v19 = 184;
                    }
                  }
                }
                else
                {
                  int v18 = 16;
                  int v19 = 173;
                }
              }
              else
              {
                int v18 = 16;
                int v19 = 169;
              }
LABEL_27:
              ERR_put_error(42, 4095, v18, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", v19);
              goto LABEL_19;
            }
          }
LABEL_18:
          ERR_put_error(42, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 165);
          unsigned int v14 = 0;
          unsigned int v15 = 0;
          goto LABEL_19;
        }
      }
      else
      {
        int v11 = 0;
      }
      int v12 = 0;
      goto LABEL_18;
    }
    int v20 = 65;
    int v21 = 158;
  }
  else
  {
    int v20 = 67;
    int v21 = 152;
  }
  ERR_put_error(42, 4095, v20, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", v21);
  return 0;
}

uint64_t ecdsa_do_verify(const unsigned __int8 *a1, int a2, uint64_t *a3, EC_KEY *a4)
{
  if (a4
    && (uint64_t v8 = EC_KEY_get0_group(a4)) != 0
    && (v9 = v8, unsigned int v10 = EC_KEY_get0_public_key(a4), a3)
    && (int v11 = v10) != 0)
  {
    int v12 = BN_CTX_new();
    if (v12)
    {
      uint64_t v13 = v12;
      BN_CTX_start(v12);
      unsigned int v14 = BN_CTX_get(v13);
      r = BN_CTX_get(v13);
      unsigned int v15 = BN_CTX_get(v13);
      int v16 = BN_CTX_get(v13);
      int v17 = BN_CTX_get(v13);
      if (v17)
      {
        int v18 = v17;
        if (EC_GROUP_get_order(v9, v14, v13))
        {
          if (BN_is_zero(*a3)
            || BN_is_negative(*a3)
            || (BN_ucmp((const BIGNUM *)*a3, v14) & 0x80000000) == 0
            || BN_is_zero(a3[1])
            || BN_is_negative(a3[1])
            || (BN_ucmp((const BIGNUM *)a3[1], v14) & 0x80000000) == 0)
          {
            ERR_put_error(42, 4095, 100, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", 517);
            int v19 = 0;
            uint64_t v20 = 0;
LABEL_24:
            BN_CTX_end(v13);
            BN_CTX_free(v13);
            EC_POINT_free(v19);
            return v20;
          }
          if (!ecdsa_prepare_digest(a1, a2, v14, v16)) {
            goto LABEL_22;
          }
          if (BN_mod_inverse_ct(v15, (const BIGNUM *)a3[1], v14, v13))
          {
            if (BN_mod_mul(r, v16, v15, v14, v13))
            {
              if (BN_mod_mul(v15, (const BIGNUM *)*a3, v15, v14, v13))
              {
                int v19 = EC_POINT_new(v9);
                if (v19)
                {
                  if (EC_POINT_mul(v9, v19, r, v11, v15, v13))
                  {
                    if (EC_POINT_get_affine_coordinates((uint64_t)v9, v19, (uint64_t)v18, 0, v13))
                    {
                      if (BN_nnmod(r, v18, v14, v13))
                      {
                        uint64_t v20 = BN_ucmp(r, (const BIGNUM *)*a3) == 0;
                        goto LABEL_24;
                      }
                      int v26 = 3;
                      int v27 = 552;
                    }
                    else
                    {
                      int v26 = 16;
                      int v27 = 548;
                    }
                  }
                  else
                  {
                    int v26 = 16;
                    int v27 = 544;
                  }
                }
                else
                {
                  int v26 = 65;
                  int v27 = 540;
                }
                ERR_put_error(42, 4095, v26, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", v27);
                goto LABEL_23;
              }
              int v24 = 3;
              int v25 = 534;
            }
            else
            {
              int v24 = 3;
              int v25 = 530;
            }
          }
          else
          {
            int v24 = 3;
            int v25 = 526;
          }
        }
        else
        {
          int v24 = 16;
          int v25 = 508;
        }
      }
      else
      {
        int v24 = 3;
        int v25 = 503;
      }
      ERR_put_error(42, 4095, v24, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", v25);
LABEL_22:
      int v19 = 0;
LABEL_23:
      uint64_t v20 = 0xFFFFFFFFLL;
      goto LABEL_24;
    }
    int v21 = 65;
    int v22 = 493;
  }
  else
  {
    int v21 = 103;
    int v22 = 488;
  }
  ERR_put_error(42, 4095, v21, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", v22);
  return 0xFFFFFFFFLL;
}

uint64_t ecdsa_prepare_digest(const unsigned __int8 *a1, int a2, const BIGNUM *a3, BIGNUM *ret)
{
  if (BN_bin2bn(a1, a2, ret))
  {
    int v7 = 8 * a2;
    int v8 = BN_num_bits(a3);
    if (v7 <= v8 || BN_rshift(ret, ret, v7 - v8)) {
      return 1;
    }
    int v10 = 110;
  }
  else
  {
    int v10 = 101;
  }
  ERR_put_error(42, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdsa/ecs_ossl.c", v10);
  return 0;
}

BOOL ecx_pub_decode(uint64_t a1, uint64_t a2)
{
  algor = 0;
  int pptype = 0;
  uint64_t v11 = 0;
  int v10 = 0;
  if (!X509_PUBKEY_get0_param(0, &v11, &v10, &algor, a2)) {
    goto LABEL_14;
  }
  if (algor)
  {
    X509_ALGOR_get0(0, &pptype, 0, algor);
    if (pptype != -1)
    {
      int v3 = 215;
LABEL_13:
      ERR_put_error(16, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecx_methods.c", v3);
LABEL_14:
      unsigned int v6 = 0;
LABEL_15:
      BOOL v8 = 0;
      goto LABEL_16;
    }
  }
  if (!v11 || (int v4 = **(_DWORD **)(a1 + 16), v10 != 32 * (((v4 - 950) & 0xFFFFFFFD) == 0)))
  {
    int v3 = 221;
    goto LABEL_13;
  }
  unsigned int v5 = (char *)ecx_key_new(v4);
  unsigned int v6 = v5;
  if (!v5 || !ecx_key_set_pub((uint64_t)v5, v11, v10)) {
    goto LABEL_15;
  }
  int v7 = EVP_PKEY_assign((EVP_PKEY *)a1, **(_DWORD **)(a1 + 16), v6);
  BOOL v8 = v7 != 0;
  if (v7) {
    unsigned int v6 = 0;
  }
LABEL_16:
  ecx_key_free(v6);
  return v8;
}

uint64_t ecx_pub_encode(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  uint64_t v11 = 0;
  int v12 = 0;
  memset(v10, 0, sizeof(v10));
  if (!v2)
  {
    ERR_put_error(16, 4095, 165, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecx_methods.c", 252);
LABEL_8:
    int v7 = 0;
    goto LABEL_9;
  }
  if (*(void *)(v2 + 32) != *(_DWORD *)(v2 + 4)) {
    goto LABEL_8;
  }
  int v4 = OBJ_nid2obj(**(_DWORD **)(a2 + 16));
  if (!v4) {
    goto LABEL_8;
  }
  unsigned int v5 = v4;
  CBS_init(v10, *(void *)(v2 + 24), *(void *)(v2 + 32));
  int v6 = CBS_stow((uint64_t)v10, &v12, &v11);
  int v7 = v12;
  if (!v6)
  {
LABEL_9:
    uint64_t v8 = 0;
    goto LABEL_10;
  }
  if (X509_PUBKEY_set0_param(a1, v5, -1, 0, v12, v11))
  {
    int v7 = 0;
    uint64_t v11 = 0;
    int v12 = 0;
    uint64_t v8 = 1;
  }
  else
  {
    uint64_t v8 = 0;
    int v7 = v12;
  }
LABEL_10:
  free(v7);
  return v8;
}

uint64_t ecx_pub_cmp(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2
    && (int v3 = *(unsigned __int8 **)(v2 + 24)) != 0
    && (uint64_t v4 = *(void *)(a2 + 32)) != 0
    && (unsigned int v5 = *(unsigned __int8 **)(v4 + 24)) != 0
    && (uint64_t v6 = *(void *)(v2 + 32), v6 == *(void *)(v4 + 32)))
  {
    return timingsafe_memcmp(v3, v5, v6) == 0;
  }
  else
  {
    return 4294967294;
  }
}

const char *ecx_pub_print(BIO *a1, uint64_t a2, int a3)
{
  uint64_t v5 = *(void *)(a2 + 32);
  int result = OBJ_nid2ln(**(_DWORD **)(a2 + 16));
  if (result)
  {
    if (v5 && *(void *)(v5 + 24))
    {
      if (BIO_printf(a1, "%*s%s Public-Key:\n", a3, "", result) < 1 || BIO_printf(a1, "%*spub:\n", a3, "") < 1) {
        return 0;
      }
      else {
        return (const char *)(ASN1_buf_print(a1, *(void *)(v5 + 24), *(void *)(v5 + 32), a3 + 4) != 0);
      }
    }
    else
    {
      return (const char *)(BIO_printf(a1, "%*s<INVALID PUBLIC KEY>\n", a3, "") > 0);
    }
  }
  return result;
}

BOOL ecx_priv_decode(uint64_t a1, uint64_t a2)
{
  algor = 0;
  int pptype = 0;
  len_4 = 0;
  int len = 0;
  if (!PKCS8_pkey_get0(0, &len_4, &len, &algor, a2))
  {
    uint64_t v5 = 0;
    int v3 = 0;
LABEL_16:
    BOOL v13 = 0;
    goto LABEL_17;
  }
  int v3 = d2i_ASN1_OCTET_STRING(0, (const unsigned __int8 **)&len_4, len);
  if (!v3) {
    goto LABEL_15;
  }
  if (algor)
  {
    X509_ALGOR_get0(0, &pptype, 0, algor);
    if (pptype != -1)
    {
      int v4 = 339;
LABEL_14:
      ERR_put_error(16, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecx_methods.c", v4);
      goto LABEL_15;
    }
  }
  if (!ASN1_STRING_get0_data((uint64_t)v3)
    || (int v6 = ASN1_STRING_length(v3), v7 = **(_DWORD **)(a1 + 16), v6 != 32 * (((v7 - 950) & 0xFFFFFFFD) == 0)))
  {
    int v4 = 346;
    goto LABEL_14;
  }
  uint64_t v8 = (char *)ecx_key_new(v7);
  if (!v8)
  {
LABEL_15:
    uint64_t v5 = 0;
    goto LABEL_16;
  }
  unsigned int v9 = v8;
  int v10 = (unsigned __int8 *)ASN1_STRING_get0_data((uint64_t)v3);
  int v11 = ASN1_STRING_length(v3);
  ecx_key_set_priv((uint64_t)v9, v10, v11);
  int v12 = EVP_PKEY_assign((EVP_PKEY *)a1, **(_DWORD **)(a1 + 16), v9);
  BOOL v13 = v12 != 0;
  if (v12) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = v9;
  }
LABEL_17:
  ASN1_OCTET_STRING_free(v3);
  ecx_key_free(v5);
  return v13;
}

uint64_t ecx_priv_encode(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  unsigned __int8 out = 0;
  if (!v2 || !*(void *)(v2 + 8))
  {
    ERR_put_error(16, 4095, 123, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecx_methods.c", 379);
    goto LABEL_10;
  }
  int v4 = OBJ_nid2obj(**(_DWORD **)(a2 + 16));
  if (!v4)
  {
LABEL_10:
    unsigned int v9 = 0;
    int v7 = 0;
LABEL_11:
    int v8 = 0;
    goto LABEL_12;
  }
  uint64_t v5 = v4;
  int v6 = ASN1_OCTET_STRING_new();
  int v7 = v6;
  if (!v6 || !ASN1_OCTET_STRING_set(v6, *(const unsigned __int8 **)(v2 + 8), *(_DWORD *)(v2 + 16)))
  {
    unsigned int v9 = 0;
    goto LABEL_11;
  }
  int v8 = i2d_ASN1_OCTET_STRING(v7, &out);
  unsigned int v9 = out;
  if (v8 < 0)
  {
LABEL_12:
    uint64_t v10 = 0;
    goto LABEL_13;
  }
  if (PKCS8_pkey_set0(a1, v5, 0, -1, 0, out, v8))
  {
    unsigned int v9 = 0;
    int v8 = 0;
    unsigned __int8 out = 0;
    uint64_t v10 = 1;
  }
  else
  {
    uint64_t v10 = 0;
    unsigned int v9 = out;
  }
LABEL_13:
  freezero(v9, v8);
  ASN1_OCTET_STRING_free(v7);
  return v10;
}

const char *ecx_priv_print(BIO *a1, uint64_t a2, int a3)
{
  uint64_t v5 = *(uint64_t **)(a2 + 32);
  int result = OBJ_nid2ln(**(_DWORD **)(a2 + 16));
  if (result)
  {
    if (v5 && v5[1])
    {
      if (BIO_printf(a1, "%*s%s Private-Key:\n", a3, "", result) < 1 || BIO_printf(a1, "%*spriv:\n", a3, "") < 1) {
        return 0;
      }
      int result = (const char *)ASN1_buf_print(a1, v5[1], v5[2], a3 + 4);
      if (!result) {
        return result;
      }
      if (BIO_printf(a1, "%*spub:\n", a3, "") < 1) {
        return 0;
      }
      else {
        return (const char *)(ASN1_buf_print(a1, v5[3], v5[4], a3 + 4) != 0);
      }
    }
    else
    {
      return (const char *)(BIO_printf(a1, "%*s<INVALID PRIVATE KEY>\n", a3, "") > 0);
    }
  }
  return result;
}

uint64_t ecx_size(uint64_t a1)
{
  return 32 * (((**(_DWORD **)(a1 + 16) - 950) & 0xFFFFFFFD) == 0);
}

uint64_t ecx_bits(uint64_t a1)
{
  if (((**(_DWORD **)(a1 + 16) - 950) & 0xFFFFFFFD) != 0) {
    return 0;
  }
  else {
    return 253;
  }
}

uint64_t ecx_security_bits(uint64_t a1)
{
  return (((**(_DWORD **)(a1 + 16) - 950) & 0xFFFFFFFD) == 0) << 7;
}

uint64_t ecx_param_cmp()
{
  return 1;
}

void *ecx_free(uint64_t a1)
{
  return ecx_key_free(*(void **)(a1 + 32));
}

uint64_t ecx_ctrl()
{
  return 4294967294;
}

BOOL ecx_set_priv_key(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  if (!a2 || (int v5 = **(_DWORD **)(a1 + 16), a3 != 32 * (((v5 - 950) & 0xFFFFFFFD) == 0)))
  {
    ERR_put_error(16, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecx_methods.c", 518);
    int v7 = 0;
    goto LABEL_8;
  }
  int v7 = (char *)ecx_key_new(v5);
  if (!v7)
  {
LABEL_8:
    BOOL v10 = 0;
    goto LABEL_9;
  }
  int v8 = v7;
  ecx_key_set_priv((uint64_t)v7, a2, a3);
  int v9 = EVP_PKEY_assign((EVP_PKEY *)a1, **(_DWORD **)(a1 + 16), v8);
  BOOL v10 = v9 != 0;
  if (v9) {
    int v7 = 0;
  }
  else {
    int v7 = v8;
  }
LABEL_9:
  ecx_key_free(v7);
  return v10;
}

BOOL ecx_set_pub_key(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a2 || (int v5 = **(_DWORD **)(a1 + 16), a3 != 32 * (((v5 - 950) & 0xFFFFFFFD) == 0)))
  {
    ERR_put_error(16, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecx_methods.c", 545);
    int v8 = 0;
LABEL_9:
    BOOL v10 = 0;
    goto LABEL_10;
  }
  int v7 = (char *)ecx_key_new(v5);
  int v8 = v7;
  if (!v7 || !ecx_key_set_pub((uint64_t)v7, a2, a3)) {
    goto LABEL_9;
  }
  int v9 = EVP_PKEY_assign((EVP_PKEY *)a1, **(_DWORD **)(a1 + 16), v8);
  BOOL v10 = v9 != 0;
  if (v9) {
    int v8 = 0;
  }
LABEL_10:
  ecx_key_free(v8);
  return v10;
}

BOOL ecx_get_priv_key(uint64_t a1, void *a2, size_t *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  memset(v8, 0, sizeof(v8));
  if (a2)
  {
    if (v4 && (uint64_t v6 = *(void *)(v4 + 8)) != 0)
    {
      CBS_init(v8, v6, *(void *)(v4 + 16));
      return CBS_write_bytes((uint64_t)v8, a2, *a3, a3) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *a3 = 32 * (((**(_DWORD **)(a1 + 16) - 950) & 0xFFFFFFFD) == 0);
    return 1;
  }
}

BOOL ecx_get_pub_key(uint64_t a1, void *a2, size_t *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  memset(v8, 0, sizeof(v8));
  if (a2)
  {
    if (v4 && (uint64_t v6 = *(void *)(v4 + 24)) != 0)
    {
      CBS_init(v8, v6, *(void *)(v4 + 32));
      return CBS_write_bytes((uint64_t)v8, a2, *a3, a3) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *a3 = 32 * (((**(_DWORD **)(a1 + 16) - 950) & 0xFFFFFFFD) == 0);
    return 1;
  }
}

BOOL pkey_ecx_keygen(int **a1, EVP_PKEY *a2)
{
  uint64_t v4 = ecx_key_new(**a1);
  int v5 = v4;
  if (!v4) {
    goto LABEL_9;
  }
  ecx_key_clear((uint64_t)v4);
  uint64_t v6 = malloc_type_calloc(1uLL, (int)v5[1], 0x3DB11B7DuLL);
  if (!v6)
  {
    int v7 = 0;
    goto LABEL_8;
  }
  int v7 = malloc_type_calloc(1uLL, (int)v5[1], 0xD6AAD79EuLL);
  if (!v7)
  {
LABEL_8:
    freezero(v6, (int)v5[1]);
    freezero(v7, (int)v5[1]);
LABEL_9:
    BOOL v8 = 0;
    goto LABEL_10;
  }
  if (*v5 != 950)
  {
    if (*v5 == 952)
    {
      ED25519_keypair((uint64_t)v6, v7);
      goto LABEL_12;
    }
    goto LABEL_8;
  }
  X25519_keypair((uint64_t)v6, v7);
LABEL_12:
  size_t v10 = (int)v5[1];
  *((void *)v5 + md5_block_data_order((unint64_t)c, b, 1) = v7;
  *((void *)v5 + 2) = v10;
  *((void *)v5 + 3) = v6;
  *((void *)v5 + 4) = v10;
  freezero(0, v10);
  freezero(0, (int)v5[1]);
  int v11 = EVP_PKEY_assign(a2, **a1, (char *)v5);
  BOOL v8 = v11 != 0;
  if (v11) {
    int v5 = 0;
  }
LABEL_10:
  ecx_key_free(v5);
  return v8;
}

BOOL pkey_ecx_derive(uint64_t a1, unsigned __int8 *a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3 || (uint64_t v4 = *(void *)(a1 + 24)) == 0)
  {
    int v10 = 140;
    int v11 = 636;
LABEL_10:
    ERR_put_error(16, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecx_methods.c", v11);
    return 0;
  }
  uint64_t v5 = *(void *)(v3 + 32);
  if (!v5)
  {
    int v10 = 123;
    int v11 = 641;
    goto LABEL_10;
  }
  uint64_t v6 = *(void *)(v5 + 8);
  if (!v6)
  {
    int v10 = 123;
    int v11 = 645;
    goto LABEL_10;
  }
  uint64_t v7 = *(void *)(v4 + 32);
  if (!v7)
  {
    int v10 = 152;
    int v11 = 650;
    goto LABEL_10;
  }
  if (!a2 || (BOOL result = X25519(a2, v6, *(void *)(v7 + 24))))
  {
    *a3 = 32;
    return 1;
  }
  return result;
}

uint64_t pkey_ecx_ctrl(uint64_t a1, int a2)
{
  if (a2 == 2) {
    return 1;
  }
  else {
    return 4294967294;
  }
}

uint64_t ecx_sig_size(uint64_t a1)
{
  return (**(_DWORD **)(a1 + 16) == 952) << 6;
}

uint64_t ecx_sign_ctrl(uint64_t a1, int a2, uint64_t a3, _DWORD *a4)
{
  if (a2 != 3) {
    return 4294967294;
  }
  *a4 = 0;
  return 2;
}

uint64_t ecx_item_verify(uint64_t a1, uint64_t a2, uint64_t a3, X509_ALGOR *a4, uint64_t a5, uint64_t a6)
{
  paobuint64_t j = 0;
  int pptype = 0;
  X509_ALGOR_get0(&paobj, &pptype, 0, a4);
  if (OBJ_obj2nid(paobj) == 952 && pptype == -1) {
    return 2 * (EVP_DigestVerifyInit(a1, 0, 0, 0, a6) != 0);
  }
  ERR_put_error(16, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecx_methods.c", 685);
  return 0;
}

ASN1_OBJECT *ecx_item_sign(uint64_t a1, uint64_t a2, uint64_t a3, X509_ALGOR *a4, X509_ALGOR *a5)
{
  BOOL result = OBJ_nid2obj(952);
  if (result)
  {
    BOOL v8 = result;
    BOOL result = (ASN1_OBJECT *)X509_ALGOR_set0(a4, result, -1, 0);
    if (result)
    {
      if (!a5) {
        return (ASN1_OBJECT *)3;
      }
      BOOL result = (ASN1_OBJECT *)X509_ALGOR_set0(a5, v8, -1, 0);
      if (result) {
        return (ASN1_OBJECT *)3;
      }
    }
  }
  return result;
}

uint64_t pkey_ecx_ed_ctrl(uint64_t a1, int a2, uint64_t a3, const EVP_MD *a4)
{
  if (a2 == 7) {
    return 1;
  }
  if (a2 != 1) {
    return 4294967294;
  }
  if (!a4 || EVP_md_null() == a4) {
    return 1;
  }
  ERR_put_error(16, 4095, 138, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecx_methods.c", 774);
  return 0;
}

uint64_t pkey_ecx_digestsign(uint64_t a1, unsigned char *a2, void *a3, const void *a4, size_t a5)
{
  uint64_t v9 = EVP_MD_CTX_pkey_ctx(a1);
  uint64_t v10 = *(void *)(v9 + 16);
  if (!a2)
  {
    BOOL v13 = *(_DWORD **)(v10 + 16);
    goto LABEL_6;
  }
  uint64_t v11 = v9;
  uint64_t v12 = *(void *)(v10 + 32);
  if (**(_DWORD **)(v10 + 16) != 952 || *a3 > 0x3FuLL)
  {
    if (!v12) {
      return 0;
    }
    unsigned int v15 = *(unsigned __int8 **)(v12 + 8);
    if (!v15) {
      return 0;
    }
    int v16 = *(const void **)(v12 + 24);
    if (!v16) {
      return 0;
    }
    uint64_t result = ED25519_sign(a2, a4, a5, v16, v15);
    if (!result) {
      return result;
    }
    BOOL v13 = *(_DWORD **)(*(void *)(v11 + 16) + 16);
LABEL_6:
    *a3 = (unint64_t)(*v13 == 952) << 6;
    return 1;
  }
  ERR_put_error(16, 4095, 100, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecx_methods.c", 731);
  return 0;
}

BOOL pkey_ecx_digestverify(uint64_t a1, unsigned __int8 *a2, uint64_t a3, const void *a4, size_t a5)
{
  uint64_t v9 = *(void *)(EVP_MD_CTX_pkey_ctx(a1) + 16);
  uint64_t v10 = *(void *)(v9 + 32);
  if (!v10) {
    return 0;
  }
  uint64_t v11 = *(const void **)(v10 + 24);
  if (!v11 || a3 != (unint64_t)(**(_DWORD **)(v9 + 16) == 952) << 6) {
    return 0;
  }
  return ED25519_verify(a4, a5, a2, v11);
}

_DWORD *ecx_key_new(int a1)
{
  if (((a1 - 950) & 0xFFFFFFFD) != 0) {
    return 0;
  }
  uint64_t result = malloc_type_calloc(1uLL, 0x28uLL, 0x101004019361378uLL);
  if (result)
  {
    *uint64_t result = a1;
    result[1] = 32;
  }
  return result;
}

BOOL ecx_key_set_pub(uint64_t a1, uint64_t a2, uint64_t a3)
{
  ecx_key_clear(a1);
  if (*(_DWORD *)(a1 + 4) != a3) {
    return 0;
  }
  memset(v7, 0, sizeof(v7));
  CBS_init(v7, a2, a3);
  return CBS_stow((uint64_t)v7, (void **)(a1 + 24), (void *)(a1 + 32)) != 0;
}

void *ecx_key_free(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    ecx_key_clear((uint64_t)result);
    return freezero(v1, 0x28uLL);
  }
  return result;
}

void *ecx_key_clear(uint64_t a1)
{
  freezero(*(void **)(a1 + 8), *(void *)(a1 + 16));
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = 0;
  uint64_t result = freezero(*(void **)(a1 + 24), *(void *)(a1 + 32));
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  return result;
}

void *ecx_key_set_priv(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  memset(v10, 0, sizeof(v10));
  ecx_key_clear(a1);
  uint64_t v6 = 0;
  if (*(_DWORD *)(a1 + 4) == a3)
  {
    uint64_t v7 = malloc_type_calloc(1uLL, a3, 0xA5D9D1B3uLL);
    uint64_t v6 = v7;
    if (v7)
    {
      if (*(_DWORD *)a1 == 950)
      {
        X25519_public_from_private((uint64_t)v7, (uint64_t)a2);
      }
      else
      {
        if (*(_DWORD *)a1 != 952) {
          return freezero(v6, *(int *)(a1 + 4));
        }
        ED25519_public_from_private((uint64_t)v7, a2);
      }
      CBS_init(v10, (uint64_t)a2, a3);
      if (CBS_stow((uint64_t)v10, (void **)(a1 + 8), (void *)(a1 + 16)))
      {
        uint64_t v8 = *(int *)(a1 + 4);
        *(void *)(a1 + 24) = v6;
        *(void *)(a1 + 32) = v8;
        uint64_t v6 = 0;
      }
    }
  }
  return freezero(v6, *(int *)(a1 + 4));
}

int X509V3_add_value(const char *name, const char *value, STACK **extlist)
{
  uint64_t v6 = (CONF_VALUE *)malloc_type_calloc(1uLL, 0x18uLL, 0x100402FEFCB83uLL);
  if (!v6
    || name && (uint64_t v7 = strdup(name), (v6->name = v7) == 0)
    || value && (uint64_t v8 = strdup(value), (v6->value = v8) == 0))
  {
    uint64_t v10 = 0;
    goto LABEL_9;
  }
  uint64_t v9 = *extlist;
  if (*extlist)
  {
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v9 = sk_new_null();
    STACK *extlist = v9;
    uint64_t v10 = v9;
    if (!v9) {
      goto LABEL_9;
    }
  }
  if (sk_push(v9, (char *)v6)) {
    return 1;
  }
LABEL_9:
  ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_utl.c", 115);
  X509V3_conf_free(v6);
  if (!v10) {
    return 0;
  }
  sk_free(*extlist);
  int result = 0;
  STACK *extlist = 0;
  return result;
}

void X509V3_conf_free(CONF_VALUE *val)
{
  if (val)
  {
    free(val->name);
    free(val->value);
    free(val->section);
    free(val);
  }
}

int X509V3_add_value_BOOL(const char *name, int asn1_BOOL, STACK **extlist)
{
  if (asn1_BOOL) {
    uint64_t v3 = "TRUE";
  }
  else {
    uint64_t v3 = "FALSE";
  }
  return X509V3_add_value(name, v3, extlist);
}

int X509V3_add_value_BOOL_nf(char *name, int asn1_BOOL, STACK **extlist)
{
  if (asn1_BOOL) {
    return X509V3_add_value(name, "TRUE", extlist);
  }
  else {
    return 1;
  }
}

char *__cdecl i2s_ASN1_ENUMERATED(X509V3_EXT_METHOD *meth, ASN1_ENUMERATED *aint)
{
  if (!aint) {
    return 0;
  }
  uint64_t v2 = ASN1_ENUMERATED_to_BN(aint, 0);
  uint64_t v3 = v2;
  if (!v2 || (uint64_t v4 = bn_to_string(v2)) == 0)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_utl.c", 204);
    uint64_t v4 = 0;
  }
  BN_free(v3);
  return v4;
}

char *bn_to_string(const BIGNUM *a1)
{
  uint64_t v8 = 0;
  if (BN_num_bits(a1) > 127)
  {
    uint64_t v3 = BN_bn2hex(a1);
    if (v3)
    {
      BOOL is_negative = BN_is_negative((uint64_t)a1);
      uint64_t v5 = "";
      if (is_negative)
      {
        uint64_t v5 = "-";
        uint64_t v6 = v3 + 1;
      }
      else
      {
        uint64_t v6 = v3;
      }
      if (asprintf(&v8, "%s0x%s", v5, v6) == -1) {
        uint64_t v7 = 0;
      }
      else {
        uint64_t v7 = v8;
      }
    }
    else
    {
      uint64_t v7 = 0;
    }
    free(v3);
    return v7;
  }
  else
  {
    return BN_bn2dec(a1);
  }
}

char *__cdecl i2s_ASN1_ENUMERATED_TABLE(X509V3_EXT_METHOD *meth, ASN1_ENUMERATED *aint)
{
  uint64_t v4 = (X509V3_EXT_METHOD *)ASN1_ENUMERATED_get(aint);
  usr_unsigned int data = (char *)meth->usr_data;
  uint64_t v6 = (const char *)*((void *)usr_data + 1);
  if (v6)
  {
    if (v4 == (X509V3_EXT_METHOD *)*(int *)usr_data)
    {
LABEL_6:
      return strdup(v6);
    }
    uint64_t v7 = (const char **)(usr_data + 32);
    while (1)
    {
      uint64_t v6 = *v7;
      if (!*v7) {
        break;
      }
      uint64_t v8 = (X509V3_EXT_METHOD *)*((int *)v7 - 2);
      v7 += 3;
      if (v4 == v8) {
        goto LABEL_6;
      }
    }
  }
  return i2s_ASN1_ENUMERATED(v4, aint);
}

char *__cdecl i2s_ASN1_INTEGER(X509V3_EXT_METHOD *meth, ASN1_INTEGER *aint)
{
  if (!aint) {
    return 0;
  }
  uint64_t v2 = ASN1_INTEGER_to_BN(aint, 0);
  uint64_t v3 = v2;
  if (!v2 || (uint64_t v4 = bn_to_string(v2)) == 0)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_utl.c", 235);
    uint64_t v4 = 0;
  }
  BN_free(v3);
  return v4;
}

ASN1_INTEGER *__cdecl s2i_ASN1_INTEGER(X509V3_EXT_METHOD *meth, char *value)
{
  uint64_t v2 = (ASN1_INTEGER *)value;
  if (!value)
  {
    int v5 = 109;
    int v6 = 250;
LABEL_10:
    ERR_put_error(34, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_utl.c", v6);
    return v2;
  }
  EVP_CIPHER_CTX a = BN_new();
  if (!a)
  {
    int v7 = 65;
    int v8 = 254;
    goto LABEL_15;
  }
  int length_low = LOBYTE(v2->length);
  if (length_low == 45) {
    uint64_t v2 = (ASN1_INTEGER *)((char *)v2 + 1);
  }
  if (LOBYTE(v2->length) == 48 && (BYTE1(v2->length) | 0x20) == 0x78)
  {
    uint64_t v2 = (ASN1_INTEGER *)((char *)v2 + 2);
    int v4 = BN_hex2bn(&a, (const char *)v2);
    if (!v4) {
      goto LABEL_13;
    }
  }
  else
  {
    int v4 = BN_dec2bn(&a, (const char *)v2);
    if (!v4)
    {
LABEL_13:
      BN_free(a);
      int v7 = 100;
      int v8 = 274;
LABEL_15:
      ERR_put_error(34, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_utl.c", v8);
      return 0;
    }
  }
  if (*((unsigned char *)&v2->length + v4)) {
    goto LABEL_13;
  }
  is_zerASN1_OBJECT o = BN_is_zero((uint64_t)a);
  uint64_t v2 = BN_to_ASN1_INTEGER(a, 0);
  BN_free(a);
  if (!v2)
  {
    int v5 = 101;
    int v6 = 284;
    goto LABEL_10;
  }
  if (length_low == 45 && !is_zero) {
    v2->type |= 0x100u;
  }
  return v2;
}

int X509V3_add_value_int(const char *name, ASN1_INTEGER *aint, STACK **extlist)
{
  if (aint)
  {
    int v5 = i2s_ASN1_INTEGER((X509V3_EXT_METHOD *)name, aint);
    if (v5)
    {
      int v6 = v5;
      int v7 = X509V3_add_value(name, v5, extlist);
      free(v6);
      LODWORD(v5) = v7;
    }
  }
  else
  {
    LODWORD(v5) = 1;
  }
  return (int)v5;
}

int X509V3_get_value_BOOL(CONF_VALUE *value, int *asn1_BOOL)
{
  uint64_t v3 = value->value;
  if (!v3) {
    goto LABEL_14;
  }
  if (!strcmp(value->value, "TRUE")
    || !strcmp(v3, "true")
    || !strcmp(v3, "Y")
    || !strcmp(v3, "y")
    || !strcmp(v3, "YES")
    || !strcmp(v3, "yes"))
  {
    *asn1_BOOL = 255;
  }
  else
  {
    if (strcmp(v3, "FALSE")
      && strcmp(v3, "false")
      && strcmp(v3, "N")
      && strcmp(v3, "n")
      && strcmp(v3, "NO")
      && strcmp(v3, "no"))
    {
LABEL_14:
      ERR_put_error(34, 4095, 104, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_utl.c", 330);
      ERR_asprintf_error_data("section:%s,name:%s,value:%s", value->section, value->name, value->value);
      return 0;
    }
    *asn1_BOOL = 0;
  }
  return 1;
}

int X509V3_get_value_int(CONF_VALUE *value, ASN1_INTEGER **aint)
{
  int v4 = s2i_ASN1_INTEGER((X509V3_EXT_METHOD *)value, value->value);
  if (v4)
  {
    *aint = v4;
    return 1;
  }
  else
  {
    ERR_asprintf_error_data("section:%s,name:%s,value:%s", value->section, value->name, value->value);
    return 0;
  }
}

STACK *__cdecl X509V3_parse_list(const char *line)
{
  extlist = 0;
  uint64_t v1 = strdup(line);
  uint64_t v2 = v1;
  if (!v1)
  {
    int v14 = 65;
    int v15 = 366;
    goto LABEL_33;
  }
  uint64_t v3 = 0;
  int v4 = v1 + 1;
  int v5 = v1;
  int v6 = 1;
  while (1)
  {
    unsigned int v7 = *(v4 - 1);
    if (v7 <= 0xD && ((1 << v7) & 0x2401) != 0) {
      break;
    }
    if (v6 == 2)
    {
      if (v7 == 44)
      {
        *(v4 - md5_block_data_order((unint64_t)c, b, 1) = 0;
        uint64_t v10 = strip_spaces(v1);
        if (!v10)
        {
          int v14 = 109;
          int v15 = 405;
          goto LABEL_33;
        }
        X509V3_add_value(v3, v10, &extlist);
        uint64_t v3 = 0;
        uint64_t v1 = v5 + 1;
LABEL_16:
        int v6 = 1;
        goto LABEL_20;
      }
      goto LABEL_17;
    }
    if (v7 != 44)
    {
      if (v7 != 58) {
        goto LABEL_16;
      }
      *(v4 - md5_block_data_order((unint64_t)c, b, 1) = 0;
      uint64_t v9 = strip_spaces(v1);
      if (!v9)
      {
        int v14 = 108;
        int v15 = 383;
        goto LABEL_33;
      }
      uint64_t v3 = v9;
      uint64_t v1 = v5 + 1;
LABEL_17:
      int v6 = 2;
      goto LABEL_20;
    }
    *(v4 - md5_block_data_order((unint64_t)c, b, 1) = 0;
    uint64_t v11 = strip_spaces(v1);
    if (!v11)
    {
      int v14 = 108;
      int v15 = 392;
      goto LABEL_33;
    }
    uint64_t v3 = v11;
    X509V3_add_value(v11, 0, &extlist);
    int v6 = 1;
    uint64_t v1 = v4;
LABEL_20:
    ++v5;
    ++v4;
  }
  uint64_t v12 = strip_spaces(v1);
  BOOL v13 = v12;
  if (v6 == 2)
  {
    if (v12)
    {
      uint64_t v12 = (char *)v3;
LABEL_27:
      X509V3_add_value(v12, v13, &extlist);
      free(v2);
      return extlist;
    }
    int v14 = 109;
    int v15 = 419;
  }
  else
  {
    if (v12)
    {
      BOOL v13 = 0;
      goto LABEL_27;
    }
    int v14 = 108;
    int v15 = 426;
  }
LABEL_33:
  ERR_put_error(34, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_utl.c", v15);
  free(v2);
  sk_pop_free(extlist, (void (__cdecl *)(void *))X509V3_conf_free);
  return 0;
}

char *strip_spaces(char *__s)
{
  uint64_t v1 = __s;
  unsigned int v2 = *__s;
  if (!v2) {
    return 0;
  }
  uint64_t v3 = MEMORY[0x263EF8318];
  while ((v2 & 0x80) == 0)
  {
    if ((*(_DWORD *)(v3 + 4 * v2 + 60) & 0x4000) == 0) {
      goto LABEL_9;
    }
LABEL_7:
    unsigned int v4 = *++v1;
    unsigned int v2 = v4;
    if (!v4) {
      return 0;
    }
  }
  if (__maskrune(v2, 0x4000uLL)) {
    goto LABEL_7;
  }
LABEL_9:
  if (!*v1) {
    return 0;
  }
  size_t v5 = strlen(v1);
  while (1)
  {
    size_t v6 = v5 - 1;
    if (v5 == 1) {
      break;
    }
    int v7 = v1[v5 - 1];
    uint64_t v8 = v1[v5 - 1];
    if (v7 < 0) {
      int v9 = __maskrune(v8, 0x4000uLL);
    }
    else {
      int v9 = *(_DWORD *)(v3 + 4 * v8 + 60) & 0x4000;
    }
    size_t v5 = v6;
    if (!v9)
    {
      v1[v6 + 1] = 0;
      break;
    }
  }
  if (*v1) {
    return v1;
  }
  else {
    return 0;
  }
}

char *__cdecl hex_to_string(unsigned __int8 *buffer, uint64_t len)
{
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  uint64_t v8 = 0;
  unsigned __int8 v7 = 0;
  uint64_t v6 = 0;
  int v4 = CBB_init((uint64_t)v10, 0);
  if ((len & 0x8000000000000000) == 0 && v4)
  {
    CBS_init(v9, (uint64_t)buffer, len);
    if (CBS_len((uint64_t)v9))
    {
      while (CBS_get_u8(v9, &v7)
           && CBB_add_u8((char **)v10, hex_digits_0[(unint64_t)v7 >> 4])
           && CBB_add_u8((char **)v10, hex_digits_0[v7 & 0xF])
           && (!CBS_len((uint64_t)v9) || CBB_add_u8((char **)v10, 0x3AuLL)))
      {
        if (!CBS_len((uint64_t)v9)) {
          goto LABEL_10;
        }
      }
    }
    else
    {
LABEL_10:
      if (CBB_add_u8((char **)v10, 0)) {
        CBB_finish((uint64_t *)v10, &v8, &v6);
      }
    }
  }
  CBB_cleanup((uint64_t *)v10);
  return v8;
}

unsigned __int8 *__cdecl string_to_hex(char *str, uint64_t *len)
{
  memset(v12, 0, sizeof(v12));
  memset(v11, 0, sizeof(v11));
  size_t v9 = 0;
  uint64_t v10 = 0;
  __int16 v8 = 0;
  *int len = 0;
  if (CBB_init((uint64_t)v12, 0))
  {
    if (str)
    {
      size_t v4 = strlen(str);
      CBS_init(v11, (uint64_t)str, v4);
      while (CBS_len((uint64_t)v11))
      {
        char v13 = 0;
        while (CBS_len((uint64_t)v11))
        {
          if (!CBS_peek_u8((uint64_t)v11, &v13)) {
            goto LABEL_19;
          }
          if (v13 != 58) {
            break;
          }
          if (!CBS_get_u8(v11, &v13)) {
            goto LABEL_19;
          }
        }
        if (!CBS_len((uint64_t)v11)) {
          break;
        }
        if (!x509_get_xdigit_nibble_cbs(v11, (unsigned char *)&v8 + 1)) {
          goto LABEL_19;
        }
        if (!CBS_len((uint64_t)v11))
        {
          int v5 = 112;
          int v6 = 583;
          goto LABEL_18;
        }
        if (!x509_get_xdigit_nibble_cbs(v11, &v8)
          || !CBB_add_u8((char **)v12, v8 | (16 * HIBYTE(v8))))
        {
          goto LABEL_19;
        }
      }
      if (CBB_finish((uint64_t *)v12, &v10, &v9))
      {
        if ((v9 & 0x8000000000000000) != 0)
        {
          freezero(v10, v9);
          uint64_t v10 = 0;
        }
        else
        {
          *int len = v9;
        }
      }
    }
    else
    {
      int v5 = 107;
      int v6 = 565;
LABEL_18:
      ERR_put_error(34, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_utl.c", v6);
    }
  }
LABEL_19:
  CBB_cleanup((uint64_t *)v12);
  return (unsigned __int8 *)v10;
}

uint64_t x509_get_xdigit_nibble_cbs(void *a1, unsigned char *a2)
{
  unsigned __int8 v6 = 0;
  uint64_t result = CBS_get_u8(a1, &v6);
  if (result)
  {
    unsigned int v4 = v6 - 48;
    if (v4 > 9)
    {
      if (v6 - 97 > 5)
      {
        if (v6 - 65 > 5)
        {
          ERR_put_error(34, 4095, 113, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_utl.c", 546);
          return 0;
        }
        char v5 = v6 - 55;
      }
      else
      {
        char v5 = v6 - 87;
      }
      *a2 = v5;
    }
    else
    {
      *a2 = v4;
    }
    return 1;
  }
  return result;
}

int name_cmp(const char *name, const char *cmp)
{
  size_t v4 = (int)strlen(cmp);
  int result = strncmp(name, cmp, v4);
  if (!result)
  {
    int v6 = name[v4];
    return v6 != 46 && v6 != 0;
  }
  return result;
}

STACK *__cdecl X509_get1_email(X509 *x)
{
  ext_d2uint64_t i = (STACK *)X509_get_ext_d2i(x, 85, 0, 0);
  uint64_t subject_name = X509_get_subject_name(x);
  email = get_email(subject_name, ext_d2i);
  sk_pop_free(ext_d2i, (void (__cdecl *)(void *))GENERAL_NAME_free);
  return email;
}

STACK *get_email(X509_NAME *name, const STACK *a2)
{
  uint64_t v11 = 0;
  int v4 = -1;
  while (1)
  {
    int index_by_NID = X509_NAME_get_index_by_NID(name, 48, v4);
    if (index_by_NID < 0) {
      break;
    }
    int v4 = index_by_NID;
    entry = X509_NAME_get_entry(name, index_by_NID);
    unsigned int data = X509_NAME_ENTRY_get_data(entry);
    if (!append_ia5(&v11, (uint64_t)data)) {
      return 0;
    }
  }
  if (sk_num(a2) >= 1)
  {
    int v9 = 0;
    while (1)
    {
      uint64_t v10 = sk_value(a2, v9);
      if (*(_DWORD *)v10 == 1 && !append_ia5(&v11, *((void *)v10 + 1))) {
        break;
      }
      if (++v9 >= sk_num(a2)) {
        return v11;
      }
    }
    return 0;
  }
  return v11;
}

STACK *__cdecl X509_get1_ocsp(X509 *x)
{
  __int16 v8 = 0;
  ext_d2uint64_t i = (const STACK *)X509_get_ext_d2i(x, 177, 0, 0);
  if (!ext_d2i) {
    return 0;
  }
  unsigned int v2 = (AUTHORITY_INFO_ACCESS *)ext_d2i;
  if (sk_num(ext_d2i) < 1)
  {
    int v6 = 0;
  }
  else
  {
    int v3 = 0;
    do
    {
      int v4 = sk_value(v2, v3);
      if (OBJ_obj2nid(*(const ASN1_OBJECT **)v4) == 178)
      {
        uint64_t v5 = *((void *)v4 + 1);
        if (*(_DWORD *)v5 == 6 && !append_ia5(&v8, *(void *)(v5 + 8))) {
          break;
        }
      }
      ++v3;
    }
    while (v3 < sk_num(v2));
    int v6 = v8;
  }
  AUTHORITY_INFO_ACCESS_free(v2);
  return v6;
}

STACK *append_ia5(STACK **a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 4) == 22)
  {
    int v3 = *(char **)(a2 + 8);
    if (v3)
    {
      if (*(_DWORD *)a2)
      {
        int result = *a1;
        if (!result)
        {
          int result = sk_new((int (__cdecl *)(const char *const *, const char *const *))sk_strcmp);
          *a1 = result;
          if (!result) {
            return result;
          }
          int v3 = *(char **)(a2 + 8);
        }
        if (sk_find(result, v3) == -1)
        {
          int v6 = strdup(*(const char **)(a2 + 8));
          if (!v6 || !sk_push(*a1, v6))
          {
            sk_pop_free(*a1, str_free_0);
            int result = 0;
            *a1 = 0;
            return result;
          }
        }
      }
    }
  }
  return (STACK *)1;
}

STACK *__cdecl X509_REQ_get1_email(X509_REQ *x)
{
  extensionunsigned int s = X509_REQ_get_extensions(x);
  d2uint64_t i = (STACK *)X509V3_get_d2i(extensions, 85, 0, 0);
  uint64_t subject_name = (X509_NAME *)X509_REQ_get_subject_name((uint64_t)x);
  email = get_email(subject_name, d2i);
  sk_pop_free(d2i, (void (__cdecl *)(void *))GENERAL_NAME_free);
  sk_pop_free(extensions, (void (__cdecl *)(void *))X509_EXTENSION_free);
  return email;
}

void X509_email_free(STACK *sk)
{
}

uint64_t X509_check_host(X509 *a1, char *__s, size_t __n, int a4, char **a5)
{
  if (!__s) {
    return 4294967294;
  }
  size_t v7 = __n;
  if (__n)
  {
    if (memchr(__s, 0, __n)) {
      return 4294967294;
    }
  }
  else
  {
    size_t v7 = strlen(__s);
  }
  return do_x509_check(a1, __s, v7, a4, 2, a5);
}

uint64_t do_x509_check(X509 *x, unsigned char *a2, size_t a3, int a4, int a5, char **a6)
{
  uint64_t v10 = x;
  uint64_t v11 = a4 & 0xFFFF7FFF;
  if (a5 == 1)
  {
    ext_d2unint64_t i = (GENERAL_NAMES *)X509_get_ext_d2i(x, 85, 0, 0);
    int v32 = 48;
    int v14 = (uint64_t (*)(void))equal_email;
    if (!ext_d2i)
    {
      int v16 = 48;
      goto LABEL_29;
    }
LABEL_15:
    int v17 = ext_d2i;
    int v18 = 22;
    goto LABEL_18;
  }
  if (a5 == 2)
  {
    char v12 = a4;
    if ((a4 & 0x20) != 0) {
      int v13 = 0;
    }
    else {
      int v13 = 13;
    }
    int v32 = v13;
    if (a3 >= 2) {
      uint64_t v11 = v11 | ((*a2 == 46) << 15);
    }
    if ((v11 & 2) != 0) {
      int v14 = (uint64_t (*)(void))equal_nocase;
    }
    else {
      int v14 = (uint64_t (*)(void))equal_wildcard;
    }
    ext_d2unint64_t i = (GENERAL_NAMES *)X509_get_ext_d2i(x, 85, 0, 0);
    if (!ext_d2i)
    {
      int v16 = v32;
      if ((v12 & 0x20) == 0)
      {
LABEL_29:
        uint64_t subject_name = X509_get_subject_name(v10);
        int v26 = -1;
        while (1)
        {
          int index_by_NID = X509_NAME_get_index_by_NID(subject_name, v16, v26);
          if (index_by_NID < 0) {
            break;
          }
          int v26 = index_by_NID;
          entry = X509_NAME_get_entry(subject_name, index_by_NID);
          if (!entry) {
            return 0xFFFFFFFFLL;
          }
          unsigned int data = X509_NAME_ENTRY_get_data(entry);
          if (!data) {
            return 0xFFFFFFFFLL;
          }
          uint64_t result = do_check_string(data, -1, v14, v11, a2, a3, a6);
          if (result) {
            return result;
          }
        }
      }
      return 0;
    }
    goto LABEL_15;
  }
  int v19 = (GENERAL_NAMES *)X509_get_ext_d2i(x, 85, 0, 0);
  int v32 = 0;
  if (v19)
  {
    int v17 = v19;
    int v14 = (uint64_t (*)(void))equal_case;
    int v18 = 4;
LABEL_18:
    unsigned int v31 = v10;
    int v20 = 0;
    if (sk_num(v17))
    {
      for (unint64_t i = 0; i < sk_num(v17); ++i)
      {
        int v22 = sk_value(v17, i);
        if (*(_DWORD *)v22 == a5)
        {
          uint64_t v23 = do_check_string(*((ASN1_STRING **)v22 + 1), v18, v14, v11, a2, a3, a6);
          if (v23)
          {
            uint64_t v30 = v23;
            GENERAL_NAMES_free(v17);
            return v30;
          }
          int v20 = 1;
        }
      }
    }
    GENERAL_NAMES_free(v17);
    int v16 = v32;
    uint64_t v10 = v31;
    if (v32 && ((v11 & 1) != 0 || !v20)) {
      goto LABEL_29;
    }
    return 0;
  }
  return 0;
}

uint64_t X509_check_email(X509 *a1, char *__s, size_t __n, int a4)
{
  if (!__s) {
    return 4294967294;
  }
  size_t v5 = __n;
  if (__n)
  {
    if (memchr(__s, 0, __n)) {
      return 4294967294;
    }
  }
  else
  {
    size_t v5 = strlen(__s);
  }
  return do_x509_check(a1, __s, v5, a4, 1, 0);
}

uint64_t X509_check_ip(X509 *a1, unsigned char *a2, size_t a3, int a4)
{
  if (a2) {
    return do_x509_check(a1, a2, a3, a4, 7, 0);
  }
  else {
    return 4294967294;
  }
}

uint64_t X509_check_ip_asc(X509 *a1, const char *a2, int a3)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (a2 && (unsigned int v5 = a2i_ipadd(ipout, a2)) != 0) {
    return do_x509_check(a1, ipout, v5, a3, 7, 0);
  }
  else {
    return 4294967294;
  }
}

int a2i_ipadd(unsigned __int8 *ipout, const char *ipasc)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (!strchr((char *)ipasc, 58)) {
    return 4 * (ipv4_from_asc(ipout, (char *)ipasc) != 0);
  }
  long long arg = 0uLL;
  int v9 = 0;
  uint64_t v10 = 0xFFFFFFFFLL;
  if (!CONF_parse_list(ipasc, 58, 0, (int (__cdecl *)(const char *, int, void *))ipv6_cb, &arg)) {
    return 0;
  }
  uint64_t v4 = v10;
  uint64_t v5 = v9;
  if (v10 == -1)
  {
    if (v9 == 16) {
      goto LABEL_12;
    }
    return 0;
  }
  if (v9 == 16 || SHIDWORD(v10) > 3) {
    return 0;
  }
  if (HIDWORD(v10) == 2)
  {
    if (v10 && v9 != v10) {
      return 0;
    }
    goto LABEL_19;
  }
  if (HIDWORD(v10) != 3)
  {
    if (!v10 || v9 == v10) {
      return 0;
    }
LABEL_19:
    if ((v10 & 0x80000000) == 0)
    {
      memcpy(ipout, &arg, v10);
      size_t v7 = &ipout[v4];
      bzero(v7, 16 - v5);
      if (v5 != v4) {
        memcpy(&v7[-v5 + 16], (char *)&arg + v4, (int)v5 - (int)v4);
      }
      return 16;
    }
LABEL_12:
    *(_OWORD *)ipunsigned __int8 out = arg;
    return 16;
  }
  if (v9 <= 0) {
    goto LABEL_19;
  }
  return 0;
}

ASN1_OCTET_STRING *__cdecl a2i_IPADDRESS(const char *ipasc)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v1 = a2i_ipadd(ipout, ipasc);
  if (!v1) {
    return 0;
  }
  int v2 = v1;
  int v3 = ASN1_OCTET_STRING_new();
  uint64_t v4 = v3;
  if (v3 && !ASN1_OCTET_STRING_set(v3, ipout, v2))
  {
    ASN1_OCTET_STRING_free(v4);
    return 0;
  }
  return v4;
}

ASN1_OCTET_STRING *__cdecl a2i_IPADDRESS_NC(const char *ipasc)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  int v2 = strchr((char *)ipasc, 47);
  if (!v2) {
    return 0;
  }
  int v3 = v2;
  uint64_t v4 = strdup(ipasc);
  uint64_t v5 = (ASN1_OCTET_STRING *)v4;
  if (v4)
  {
    int v6 = &v4[v3 - ipasc];
    *int v6 = 0;
    int v7 = a2i_ipadd(ipout, v4);
    if (!v7
      || (int v8 = v7, v9 = a2i_ipadd(&ipout[v7], v6 + 1), free(v5), v5 = 0, !v9)
      || v8 != v9
      || (uint64_t v10 = ASN1_OCTET_STRING_new(), (v5 = v10) == 0))
    {
      free(v5);
      return 0;
    }
    if (!ASN1_OCTET_STRING_set(v10, ipout, 2 * v8))
    {
      ASN1_OCTET_STRING_free(v5);
      return 0;
    }
  }
  return v5;
}

uint64_t ipv4_from_asc(unsigned char *a1, char *a2)
{
  uint64_t v10 = 0;
  int v9 = 0;
  int v8 = 0;
  int v3 = sscanf(a2, "%d.%d.%d.%d", (char *)&v10 + 4, &v10, &v9, &v8);
  uint64_t result = 0;
  if (v3 == 4)
  {
    uint64_t result = 0;
    if (HIDWORD(v10) <= 0xFF)
    {
      char v5 = v10;
      if ((v10 & 0x80000000) == 0 && (int)v10 <= 255)
      {
        char v6 = v9;
        if ((v9 & 0x80000000) == 0 && v9 <= 255)
        {
          char v7 = v8;
          if ((v8 & 0x80000000) == 0 && v8 <= 255)
          {
            *a1 = BYTE4(v10);
            a1[1] = v5;
            a1[2] = v6;
            uint64_t result = 1;
            a1[3] = v7;
          }
        }
      }
    }
  }
  return result;
}

int X509V3_NAME_from_section(X509_NAME *nm, STACK *dn_sk, unint64_t chtype)
{
  if (!nm) {
    return (int)nm;
  }
  int v3 = chtype;
  char v5 = nm;
  if (sk_num(dn_sk) < 1) {
    goto LABEL_22;
  }
  int v6 = 0;
  while (2)
  {
    char v7 = sk_value(dn_sk, v6);
    int v8 = (unsigned __int8 *)*((void *)v7 + 1);
    for (unint64_t i = v8 + 1; ; ++i)
    {
      unsigned int v10 = *(i - 1);
      if (v10 <= 0x2D) {
        break;
      }
      if (v10 == 58 || v10 == 46) {
        goto LABEL_12;
      }
LABEL_11:
      ;
    }
    if (!*(i - 1)) {
      goto LABEL_14;
    }
    if (v10 != 44) {
      goto LABEL_11;
    }
LABEL_12:
    if (*i) {
      int v8 = i;
    }
LABEL_14:
    int v11 = *v8;
    if (v11 == 43) {
      int v12 = -1;
    }
    else {
      int v12 = 0;
    }
    if (v11 == 43) {
      uint64_t v13 = (const char *)(v8 + 1);
    }
    else {
      uint64_t v13 = (const char *)v8;
    }
    LODWORD(nm) = X509_NAME_add_entry_by_txt(v5, v13, v3, *((const unsigned __int8 **)v7 + 2), -1, -1, v12);
    if (nm)
    {
      if (++v6 >= sk_num(dn_sk))
      {
LABEL_22:
        LODWORD(nm) = 1;
        return (int)nm;
      }
      continue;
    }
    return (int)nm;
  }
}

uint64_t sk_strcmp(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

BOOL equal_email(char *a1, size_t __n, char *a3, uint64_t a4)
{
  if (__n != a4) {
    return 0;
  }
  size_t v5 = __n;
  uint64_t v7 = 0;
  int v8 = a3 - 1;
  int v9 = a1 - 1;
  while (__n != v7)
  {
    uint64_t v10 = v7;
    int v11 = v8;
    int v12 = v9;
    if (v9[__n] != 64)
    {
      int v13 = v8[__n];
      ++v7;
      --v8;
      --v9;
      if (v13 != 64) {
        continue;
      }
    }
    if (!equal_nocase(&v12[__n], v10 + 1, &v11[__n], v10 + 1, 0)) {
      return 0;
    }
    if (v5 - 1 != v10) {
      v5 += ~v10;
    }
    break;
  }
  return equal_case(a1, v5, a3, v5, 0);
}

BOOL equal_nocase(char *a1, size_t __n, void *a3, size_t a4, unsigned int a5)
{
  size_t v8 = __n;
  int v9 = a1;
  uint64_t v10 = memchr(a1, 0, __n);
  BOOL result = 0;
  if (!v10)
  {
    int v12 = memchr(a3, 0, a4);
    BOOL result = 0;
    if (!v12)
    {
      if ((a5 & 0x8000) != 0)
      {
        unint64_t i = v9;
        size_t v14 = v8;
        if (v8 > a4)
        {
          int v15 = &v9[v8 - a4];
          size_t v14 = v8;
          for (unint64_t i = v9; *i && ((*i == 46) & (a5 >> 4)) == 0; ++i)
          {
            if (--v14 <= a4)
            {
              size_t v8 = a4;
              int v9 = v15;
              return strncasecmp(v9, (const char *)a3, v8) == 0;
            }
          }
        }
        if (v14 == a4)
        {
          size_t v8 = a4;
          int v9 = i;
          return strncasecmp(v9, (const char *)a3, v8) == 0;
        }
      }
      if (v8 == a4) {
        return strncasecmp(v9, (const char *)a3, v8) == 0;
      }
      return 0;
    }
  }
  return result;
}

uint64_t equal_wildcard(char *a1, size_t __n, char *a3, size_t a4, unsigned int a5)
{
  if (a4 < 2)
  {
    if (!__n) {
      goto LABEL_47;
    }
LABEL_6:
    int v9 = 0;
    size_t v10 = 0;
    unint64_t v11 = 0;
    size_t v12 = __n - 1;
    int v13 = 1;
    BOOL v35 = a3;
    do
    {
      int v14 = a1[v10];
      if (v14 == 42)
      {
        if (v10 == v12)
        {
          BOOL v15 = 1;
          if (v11) {
            goto LABEL_47;
          }
        }
        else
        {
          BOOL v15 = a1[v10 + 1] == 46;
          if (v11) {
            goto LABEL_47;
          }
        }
        if (v13 & 8 | v9) {
          goto LABEL_47;
        }
        int v17 = v13 & v15;
        if ((a5 & 4) == 0) {
          int v17 = 1;
        }
        if (v17 != 1 || ((v13 | v15) & 1) == 0) {
          goto LABEL_47;
        }
        int v9 = 0;
        v13 &= ~1u;
        unint64_t v11 = (unint64_t)&a1[v10];
      }
      else if (v13)
      {
        if ((v13 & 8) != 0 || __n - v10 < 4 || (int v18 = strncasecmp(&a1[v10], "xn--", 4uLL), a3 = v35, v18))
        {
          if ((v14 - 48) >= 0xA && (v14 & 0xFFFFFFDF) - 65 >= 0x1A) {
            goto LABEL_47;
          }
          v13 &= ~1u;
        }
        else
        {
          v10 += 3;
          v13 |= 8u;
        }
      }
      else if ((v14 - 48) >= 0xA && (v14 & 0xFFFFFFDF) - 65 > 0x19)
      {
        if (v14 == 45)
        {
          v13 |= 4u;
        }
        else
        {
          if (v14 != 46 || (v13 & 5) != 0) {
            goto LABEL_47;
          }
          ++v9;
          int v13 = 1;
        }
      }
      else
      {
        v13 &= 8u;
      }
      ++v10;
    }
    while (v10 < __n);
    if ((v13 & 5) != 0 || v9 < 2 || !v11) {
      goto LABEL_47;
    }
    unint64_t v21 = v11 - (void)a1;
    size_t v22 = (size_t)&a1[__n + ~v11];
    if (~v11 + __n + v11 > a4) {
      return 0;
    }
    int v24 = a3;
    uint64_t result = equal_nocase(a1, v11 - (void)a1, a3, v11 - (void)a1, a5);
    if (!result) {
      return result;
    }
    size_t v34 = a4 - v22;
    int v25 = &v24[a4 - v22];
    uint64_t result = equal_nocase(v25, (size_t)&a1[__n + ~v11], (void *)(v11 + 1), (size_t)&a1[__n + ~v11], a5);
    if (!result) {
      return result;
    }
    if ((char *)v11 == a1 && *(unsigned char *)(v11 + 1) == 46)
    {
      if (a4 == v22) {
        return 0;
      }
      int v26 = (a5 >> 3) & 1;
    }
    else
    {
      if (a4 >= 4)
      {
        int v27 = v35;
        uint64_t result = strncasecmp(v35, "xn--", 4uLL);
        LOBYTE(v26) = 0;
        if (!result) {
          return result;
        }
        goto LABEL_61;
      }
      LOBYTE(v26) = 0;
    }
    int v27 = v35;
LABEL_61:
    int v28 = &v27[v21];
    if (v25 == &v27[v21 + 1])
    {
      uint64_t result = 1;
      if (v34 == v21 || *v28 == 42) {
        return result;
      }
    }
    else if (v34 == v21)
    {
      return 1;
    }
    size_t v29 = a4 - __n + 1;
    while (1)
    {
      int v30 = *v28;
      if ((v30 - 48) >= 0xA && (v30 - 65) >= 0x1A)
      {
        char v32 = v30 == 46 ? v26 : 0;
        if ((v32 & 1) == 0 && v30 != 45 && (v30 - 97) > 0x19) {
          break;
        }
      }
      ++v28;
      if (!--v29) {
        return 1;
      }
    }
    return 0;
  }
  if (__n && *a3 != 46) {
    goto LABEL_6;
  }
LABEL_47:
  return equal_nocase(a1, __n, a3, a4, a5);
}

BOOL equal_case(char *a1, size_t __n, void *a3, size_t a4, unsigned int a5)
{
  size_t v8 = __n;
  int v9 = a1;
  size_t v10 = memchr(a1, 0, __n);
  BOOL result = 0;
  if (!v10)
  {
    size_t v12 = memchr(a3, 0, a4);
    BOOL result = 0;
    if (!v12)
    {
      if ((a5 & 0x8000) != 0)
      {
        unint64_t i = v9;
        size_t v14 = v8;
        if (v8 > a4)
        {
          BOOL v15 = &v9[v8 - a4];
          size_t v14 = v8;
          for (unint64_t i = v9; *i && ((*i == 46) & (a5 >> 4)) == 0; ++i)
          {
            if (--v14 <= a4)
            {
              size_t v8 = a4;
              int v9 = v15;
              return strncmp(v9, (const char *)a3, v8) == 0;
            }
          }
        }
        if (v14 == a4)
        {
          size_t v8 = a4;
          int v9 = i;
          return strncmp(v9, (const char *)a3, v8) == 0;
        }
      }
      if (v8 == a4) {
        return strncmp(v9, (const char *)a3, v8) == 0;
      }
      return 0;
    }
  }
  return result;
}

uint64_t do_check_string(ASN1_STRING *in, int a2, uint64_t (*a3)(void), uint64_t a4, void *__s2, size_t __n, char **a7)
{
  unsigned int data = in->data;
  if (!data || !in->length) {
    return 0;
  }
  if (a2 >= 1)
  {
    if (in->type == a2)
    {
      if (a2 == 22)
      {
        uint64_t v14 = a3();
        if (!a7) {
          return v14;
        }
LABEL_17:
        if ((int)v14 >= 1)
        {
          int v20 = strndup((const char *)in->data, in->length);
          *a7 = v20;
          if (v20) {
            return v14;
          }
          else {
            return 0xFFFFFFFFLL;
          }
        }
        return v14;
      }
      if (in->length == __n)
      {
        uint64_t v14 = memcmp(data, __s2, __n) == 0;
        if (!a7) {
          return v14;
        }
        goto LABEL_17;
      }
    }
    return 0;
  }
  unsigned __int8 out = 0;
  unsigned int v15 = ASN1_STRING_to_UTF8(&out, in);
  if ((v15 & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  size_t v16 = v15;
  uint64_t v17 = ((uint64_t (*)(unsigned __int8 *, void, void *, size_t, uint64_t))a3)(out, v15, __s2, __n, a4);
  uint64_t v14 = v17;
  int v18 = out;
  if (a7 && (int)v17 >= 1)
  {
    int v19 = strndup((const char *)out, v16);
    *a7 = v19;
    if (v19) {
      uint64_t v14 = v14;
    }
    else {
      uint64_t v14 = 0xFFFFFFFFLL;
    }
  }
  free(v18);
  return v14;
}

uint64_t ipv6_cb(char *a1, int a2, _DWORD *a3)
{
  uint64_t v4 = a3 + 4;
  int v3 = a3[4];
  if (v3 == 16) {
    return 0;
  }
  if (!a2)
  {
    int v8 = a3[5];
    if (v8 == -1)
    {
      a3[5] = v3;
    }
    else if (v8 != v3)
    {
      return 0;
    }
    uint64_t v4 = a3 + 6;
    int v7 = 1;
    goto LABEL_23;
  }
  int v6 = a1;
  if (a2 < 5)
  {
    unsigned int v9 = 0;
    size_t v10 = (_WORD *)((char *)a3 + v3);
    do
    {
      int v12 = *v6++;
      int v11 = v12;
      if ((v12 - 48) >= 0xA)
      {
        if ((v11 - 65) >= 6)
        {
          if ((v11 - 97) > 5) {
            return 0;
          }
          int v13 = -87;
        }
        else
        {
          int v13 = -55;
        }
      }
      else
      {
        int v13 = -48;
      }
      unsigned int v9 = (v13 + v11) | (16 * v9);
      --a2;
    }
    while (a2);
    *size_t v10 = bswap32(v9) >> 16;
    int v7 = 2;
    goto LABEL_23;
  }
  if (v3 > 12 || a1[a2]) {
    return 0;
  }
  uint64_t result = ipv4_from_asc((unsigned char *)a3 + v3, a1);
  if (!result) {
    return result;
  }
  int v7 = 4;
LABEL_23:
  *v4 += v7;
  return 1;
}

uint64_t Gost2814789_encrypt(int *a1, int *a2, int *a3)
{
  int v3 = *a1;
  int v4 = a1[1];
  int v5 = *a3;
  int v6 = a3[1];
  unsigned int v7 = *a1 + *a3;
  int v8 = a3 + 8;
  int v9 = a3[HIBYTE(v7) + 8];
  size_t v10 = a3 + 264;
  int v11 = a3[BYTE2(v7) + 264];
  int v12 = a3 + 520;
  int v13 = a3[BYTE1(v7) + 520];
  int v14 = v7;
  unsigned int v15 = a3 + 776;
  int v16 = (v11 | v9 | v13 | a3[v14 + 776]) ^ v4;
  int v17 = (a3[((v16 + v6) >> 16) + 264] | a3[((v16 + v6) >> 24) + 8] | a3[((unsigned __int16)(v16 + v6) >> 8) + 520] | a3[(v16 + v6) + 776]) ^ v3;
  int v18 = a3[2];
  int v19 = a3[3];
  int v20 = (a3[((v17 + v18) >> 16) + 264] | a3[((v17 + v18) >> 24) + 8] | a3[((unsigned __int16)(v17 + v18) >> 8) + 520] | a3[(v17 + v18) + 776]) ^ v16;
  int v21 = (a3[((v20 + v19) >> 16) + 264] | a3[((v20 + v19) >> 24) + 8] | a3[((unsigned __int16)(v20 + v19) >> 8) + 520] | a3[(v20 + v19) + 776]) ^ v17;
  int v22 = a3[4];
  int v23 = a3[5];
  int v24 = (a3[((v21 + v22) >> 16) + 264] | a3[((v21 + v22) >> 24) + 8] | a3[((unsigned __int16)(v21 + v22) >> 8) + 520] | a3[(v21 + v22) + 776]) ^ v20;
  int v25 = (a3[((v24 + v23) >> 16) + 264] | a3[((v24 + v23) >> 24) + 8] | a3[((unsigned __int16)(v24 + v23) >> 8) + 520] | a3[(v24 + v23) + 776]) ^ v21;
  int v26 = a3[6];
  int v27 = a3[7];
  int v28 = (v10[((v25 + v26) >> 16)] | v8[(v25 + v26) >> 24] | v12[((unsigned __int16)(v25 + v26) >> 8)] | v15[(v25 + v26)]) ^ v24;
  int v29 = (v10[((v28 + v27) >> 16)] | v8[(v28 + v27) >> 24] | v12[((unsigned __int16)(v28 + v27) >> 8)] | v15[(v28 + v27)]) ^ v25;
  int v30 = (v10[((v29 + v5) >> 16)] | v8[(v29 + v5) >> 24] | v12[((unsigned __int16)(v29 + v5) >> 8)] | v15[(v29 + v5)]) ^ v28;
  int v31 = (v10[((v30 + v6) >> 16)] | v8[(v30 + v6) >> 24] | v12[((unsigned __int16)(v30 + v6) >> 8)] | v15[(v30 + v6)]) ^ v29;
  int v32 = (v10[((v31 + v18) >> 16)] | v8[(v31 + v18) >> 24] | v12[((unsigned __int16)(v31 + v18) >> 8)] | v15[(v31 + v18)]) ^ v30;
  int v33 = (v10[((v32 + v19) >> 16)] | v8[(v32 + v19) >> 24] | v12[((unsigned __int16)(v32 + v19) >> 8)] | v15[(v32 + v19)]) ^ v31;
  int v34 = (v10[((v33 + v22) >> 16)] | v8[(v33 + v22) >> 24] | v12[((unsigned __int16)(v33 + v22) >> 8)] | v15[(v33 + v22)]) ^ v32;
  int v35 = (v10[((v34 + v23) >> 16)] | v8[(v34 + v23) >> 24] | v12[((unsigned __int16)(v34 + v23) >> 8)] | v15[(v34 + v23)]) ^ v33;
  int v36 = (v10[((v35 + v26) >> 16)] | v8[(v35 + v26) >> 24] | v12[((unsigned __int16)(v35 + v26) >> 8)] | v15[(v35 + v26)]) ^ v34;
  int v37 = (v10[((v36 + v27) >> 16)] | v8[(v36 + v27) >> 24] | v12[((unsigned __int16)(v36 + v27) >> 8)] | v15[(v36 + v27)]) ^ v35;
  int v38 = (v10[((v37 + v5) >> 16)] | v8[(v37 + v5) >> 24] | v12[((unsigned __int16)(v37 + v5) >> 8)] | v15[(v37 + v5)]) ^ v36;
  int v39 = (v10[((v38 + v6) >> 16)] | v8[(v38 + v6) >> 24] | v12[((unsigned __int16)(v38 + v6) >> 8)] | v15[(v38 + v6)]) ^ v37;
  int v40 = (v10[((v39 + v18) >> 16)] | v8[(v39 + v18) >> 24] | v12[((unsigned __int16)(v39 + v18) >> 8)] | v15[(v39 + v18)]) ^ v38;
  int v41 = (v10[((v40 + v19) >> 16)] | v8[(v40 + v19) >> 24] | v12[((unsigned __int16)(v40 + v19) >> 8)] | v15[(v40 + v19)]) ^ v39;
  int v42 = (v10[((v41 + v22) >> 16)] | v8[(v41 + v22) >> 24] | v12[((unsigned __int16)(v41 + v22) >> 8)] | v15[(v41 + v22)]) ^ v40;
  int v43 = (v10[((v42 + v23) >> 16)] | v8[(v42 + v23) >> 24] | v12[((unsigned __int16)(v42 + v23) >> 8)] | v15[(v42 + v23)]) ^ v41;
  int v44 = (v10[((v43 + v26) >> 16)] | v8[(v43 + v26) >> 24] | v12[((unsigned __int16)(v43 + v26) >> 8)] | v15[(v43 + v26)]) ^ v42;
  int v45 = (v10[((v44 + v27) >> 16)] | v8[(v44 + v27) >> 24] | v12[((unsigned __int16)(v44 + v27) >> 8)] | v15[(v44 + v27)]) ^ v43;
  int v46 = (v10[((v45 + v27) >> 16)] | v8[(v45 + v27) >> 24] | v12[((unsigned __int16)(v45 + v27) >> 8)] | v15[(v45 + v27)]) ^ v44;
  int v47 = (v10[((v46 + v26) >> 16)] | v8[(v46 + v26) >> 24] | v12[((unsigned __int16)(v46 + v26) >> 8)] | v15[(v46 + v26)]) ^ v45;
  int v48 = (v10[((v47 + v23) >> 16)] | v8[(v47 + v23) >> 24] | v12[((unsigned __int16)(v47 + v23) >> 8)] | v15[(v47 + v23)]) ^ v46;
  int v49 = (v10[((v48 + v22) >> 16)] | v8[(v48 + v22) >> 24] | v12[((unsigned __int16)(v48 + v22) >> 8)] | v15[(v48 + v22)]) ^ v47;
  int v50 = (v10[((v49 + v19) >> 16)] | v8[(v49 + v19) >> 24] | v12[((unsigned __int16)(v49 + v19) >> 8)] | v15[(v49 + v19)]) ^ v48;
  unsigned int v51 = v50 + v18;
  uint64_t result = v12[BYTE1(v51)];
  int v53 = (v10[BYTE2(v51)] | v8[HIBYTE(v51)] | result | v15[v51]) ^ v49;
  int v54 = (v10[((v53 + v6) >> 16)] | v8[(v53 + v6) >> 24] | v12[((unsigned __int16)(v53 + v6) >> 8)] | v15[(v53 + v6)]) ^ v50;
  unsigned int v55 = v54 + v5;
  LODWORD(v8) = v8[HIBYTE(v55)];
  LODWORD(v1X509_check_purpose(x, -1, 0) = v10[BYTE2(v55)];
  int v56 = v12[BYTE1(v55)] | v15[v55];
  *a2 = v54;
  a2[1] = (v10 | v8 | v56) ^ v53;
  return result;
}

uint64_t Gost2814789_decrypt(int *a1, int *a2, int *a3)
{
  int v3 = *a1;
  int v4 = a1[1];
  int v5 = *a3;
  int v6 = a3[1];
  unsigned int v7 = *a1 + *a3;
  int v8 = a3 + 8;
  int v9 = a3[HIBYTE(v7) + 8];
  size_t v10 = a3 + 264;
  int v11 = a3[BYTE2(v7) + 264];
  int v12 = a3 + 520;
  int v13 = a3[BYTE1(v7) + 520];
  int v14 = v7;
  unsigned int v15 = a3 + 776;
  int v16 = (v11 | v9 | v13 | a3[v14 + 776]) ^ v4;
  int v17 = (a3[((v16 + v6) >> 16) + 264] | a3[((v16 + v6) >> 24) + 8] | a3[((unsigned __int16)(v16 + v6) >> 8) + 520] | a3[(v16 + v6) + 776]) ^ v3;
  int v18 = a3[2];
  int v19 = a3[3];
  int v20 = (a3[((v17 + v18) >> 16) + 264] | a3[((v17 + v18) >> 24) + 8] | a3[((unsigned __int16)(v17 + v18) >> 8) + 520] | a3[(v17 + v18) + 776]) ^ v16;
  int v21 = (a3[((v20 + v19) >> 16) + 264] | a3[((v20 + v19) >> 24) + 8] | a3[((unsigned __int16)(v20 + v19) >> 8) + 520] | a3[(v20 + v19) + 776]) ^ v17;
  int v22 = a3[4];
  int v23 = a3[5];
  int v24 = (a3[((v21 + v22) >> 16) + 264] | a3[((v21 + v22) >> 24) + 8] | a3[((unsigned __int16)(v21 + v22) >> 8) + 520] | a3[(v21 + v22) + 776]) ^ v20;
  int v25 = (a3[((v24 + v23) >> 16) + 264] | a3[((v24 + v23) >> 24) + 8] | a3[((unsigned __int16)(v24 + v23) >> 8) + 520] | a3[(v24 + v23) + 776]) ^ v21;
  int v26 = a3[6];
  int v27 = a3[7];
  int v28 = (v10[((v25 + v26) >> 16)] | v8[(v25 + v26) >> 24] | v12[((unsigned __int16)(v25 + v26) >> 8)] | v15[(v25 + v26)]) ^ v24;
  int v29 = (v10[((v28 + v27) >> 16)] | v8[(v28 + v27) >> 24] | v12[((unsigned __int16)(v28 + v27) >> 8)] | v15[(v28 + v27)]) ^ v25;
  int v30 = (v10[((v29 + v27) >> 16)] | v8[(v29 + v27) >> 24] | v12[((unsigned __int16)(v29 + v27) >> 8)] | v15[(v29 + v27)]) ^ v28;
  int v31 = (v10[((v30 + v26) >> 16)] | v8[(v30 + v26) >> 24] | v12[((unsigned __int16)(v30 + v26) >> 8)] | v15[(v30 + v26)]) ^ v29;
  int v32 = (v10[((v31 + v23) >> 16)] | v8[(v31 + v23) >> 24] | v12[((unsigned __int16)(v31 + v23) >> 8)] | v15[(v31 + v23)]) ^ v30;
  int v33 = (v10[((v32 + v22) >> 16)] | v8[(v32 + v22) >> 24] | v12[((unsigned __int16)(v32 + v22) >> 8)] | v15[(v32 + v22)]) ^ v31;
  int v34 = (v10[((v33 + v19) >> 16)] | v8[(v33 + v19) >> 24] | v12[((unsigned __int16)(v33 + v19) >> 8)] | v15[(v33 + v19)]) ^ v32;
  int v35 = (v10[((v34 + v18) >> 16)] | v8[(v34 + v18) >> 24] | v12[((unsigned __int16)(v34 + v18) >> 8)] | v15[(v34 + v18)]) ^ v33;
  int v36 = (v10[((v35 + v6) >> 16)] | v8[(v35 + v6) >> 24] | v12[((unsigned __int16)(v35 + v6) >> 8)] | v15[(v35 + v6)]) ^ v34;
  int v37 = (v10[((v36 + v5) >> 16)] | v8[(v36 + v5) >> 24] | v12[((unsigned __int16)(v36 + v5) >> 8)] | v15[(v36 + v5)]) ^ v35;
  int v38 = (v10[((v37 + v27) >> 16)] | v8[(v37 + v27) >> 24] | v12[((unsigned __int16)(v37 + v27) >> 8)] | v15[(v37 + v27)]) ^ v36;
  int v39 = (v10[((v38 + v26) >> 16)] | v8[(v38 + v26) >> 24] | v12[((unsigned __int16)(v38 + v26) >> 8)] | v15[(v38 + v26)]) ^ v37;
  int v40 = (v10[((v39 + v23) >> 16)] | v8[(v39 + v23) >> 24] | v12[((unsigned __int16)(v39 + v23) >> 8)] | v15[(v39 + v23)]) ^ v38;
  int v41 = (v10[((v40 + v22) >> 16)] | v8[(v40 + v22) >> 24] | v12[((unsigned __int16)(v40 + v22) >> 8)] | v15[(v40 + v22)]) ^ v39;
  int v42 = (v10[((v41 + v19) >> 16)] | v8[(v41 + v19) >> 24] | v12[((unsigned __int16)(v41 + v19) >> 8)] | v15[(v41 + v19)]) ^ v40;
  int v43 = (v10[((v42 + v18) >> 16)] | v8[(v42 + v18) >> 24] | v12[((unsigned __int16)(v42 + v18) >> 8)] | v15[(v42 + v18)]) ^ v41;
  int v44 = (v10[((v43 + v6) >> 16)] | v8[(v43 + v6) >> 24] | v12[((unsigned __int16)(v43 + v6) >> 8)] | v15[(v43 + v6)]) ^ v42;
  int v45 = (v10[((v44 + v5) >> 16)] | v8[(v44 + v5) >> 24] | v12[((unsigned __int16)(v44 + v5) >> 8)] | v15[(v44 + v5)]) ^ v43;
  int v46 = (v10[((v45 + v27) >> 16)] | v8[(v45 + v27) >> 24] | v12[((unsigned __int16)(v45 + v27) >> 8)] | v15[(v45 + v27)]) ^ v44;
  int v47 = (v10[((v46 + v26) >> 16)] | v8[(v46 + v26) >> 24] | v12[((unsigned __int16)(v46 + v26) >> 8)] | v15[(v46 + v26)]) ^ v45;
  int v48 = (v10[((v47 + v23) >> 16)] | v8[(v47 + v23) >> 24] | v12[((unsigned __int16)(v47 + v23) >> 8)] | v15[(v47 + v23)]) ^ v46;
  int v49 = (v10[((v48 + v22) >> 16)] | v8[(v48 + v22) >> 24] | v12[((unsigned __int16)(v48 + v22) >> 8)] | v15[(v48 + v22)]) ^ v47;
  int v50 = (v10[((v49 + v19) >> 16)] | v8[(v49 + v19) >> 24] | v12[((unsigned __int16)(v49 + v19) >> 8)] | v15[(v49 + v19)]) ^ v48;
  unsigned int v51 = v50 + v18;
  uint64_t result = v12[BYTE1(v51)];
  int v53 = (v10[BYTE2(v51)] | v8[HIBYTE(v51)] | result | v15[v51]) ^ v49;
  int v54 = (v10[((v53 + v6) >> 16)] | v8[(v53 + v6) >> 24] | v12[((unsigned __int16)(v53 + v6) >> 8)] | v15[(v53 + v6)]) ^ v50;
  unsigned int v55 = v54 + v5;
  LODWORD(v8) = v8[HIBYTE(v55)];
  LODWORD(v1X509_check_purpose(x, -1, 0) = v10[BYTE2(v55)];
  int v56 = v12[BYTE1(v55)] | v15[v55];
  *a2 = v54;
  a2[1] = (v10 | v8 | v56) ^ v53;
  return result;
}

uint64_t Gost2814789_ecb_encrypt(int *a1, int *a2, uint64_t a3, int a4)
{
  if ((*(unsigned char *)(a3 + 4132) & 1) != 0 && *(_DWORD *)(a3 + 4128) == 1024)
  {
    Gost2814789_cryptopro_key_mesh((int *)a3);
    *(_DWORD *)(a3 + 4128) = 0;
  }
  if (a4)
  {
    return Gost2814789_encrypt(a1, a2, (int *)a3);
  }
  else
  {
    return Gost2814789_decrypt(a1, a2, (int *)a3);
  }
}

uint64_t Gost2814789_cfb64_encrypt(uint64_t result, unsigned char *a2, unint64_t a3, uint64_t a4, int *a5, unsigned int *a6, int a7)
{
  int v11 = (char *)result;
  unsigned int v12 = *a6;
  if (*a6) {
    BOOL v13 = a3 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  int v14 = !v13;
  if (a7)
  {
    if (v14)
    {
      do
      {
        char v15 = *v11++;
        char v16 = *((unsigned char *)a5 + v12);
        *((unsigned char *)a5 + v12) = v16 ^ v15;
        *a2++ = v16 ^ v15;
        unint64_t v17 = a3 - 1;
        char v18 = v12 + 1;
        unsigned int v12 = ((_BYTE)v12 + 1) & 7;
        if ((v18 & 7) == 0) {
          break;
        }
        --a3;
      }
      while (a3);
    }
    else
    {
      unint64_t v17 = a3;
    }
    if (v17 < 8)
    {
      unsigned int v23 = v12;
      if (!v17) {
        goto LABEL_49;
      }
    }
    else
    {
      do
      {
        if ((*(unsigned char *)(a4 + 4132) & 1) != 0 && *(_DWORD *)(a4 + 4128) == 1024)
        {
          Gost2814789_cryptopro_key_mesh((int *)a4);
          Gost2814789_encrypt(a5, a5, (int *)a4);
          *(_DWORD *)(a4 + 4128) = 0;
        }
        uint64_t result = Gost2814789_encrypt(a5, a5, (int *)a4);
        *(_DWORD *)(a4 + 4128) += 8;
        if (v12 <= 7)
        {
          uint64_t v22 = *(void *)((char *)a5 + v12) ^ *(void *)&v11[v12];
          *(void *)((char *)a5 + v12) = v22;
          *(void *)&a2[v12] = v22;
        }
        unsigned int v12 = 0;
        unsigned int v23 = 0;
        v17 -= 8;
        a2 += 8;
        v11 += 8;
      }
      while (v17 > 7);
      if (!v17) {
        goto LABEL_49;
      }
    }
    if ((*(unsigned char *)(a4 + 4132) & 1) != 0 && *(_DWORD *)(a4 + 4128) == 1024)
    {
      Gost2814789_cryptopro_key_mesh((int *)a4);
      Gost2814789_encrypt(a5, a5, (int *)a4);
      *(_DWORD *)(a4 + 4128) = 0;
    }
    uint64_t result = Gost2814789_encrypt(a5, a5, (int *)a4);
    *(_DWORD *)(a4 + 4128) += 8;
    do
    {
      char v24 = *((unsigned char *)a5 + v23) ^ v11[v23];
      *((unsigned char *)a5 + v23) = v24;
      a2[v23++] = v24;
      --v17;
    }
    while (v17);
    goto LABEL_49;
  }
  if (v14)
  {
    do
    {
      char v19 = *v11++;
      *a2++ = v19 ^ *((unsigned char *)a5 + v12);
      *((unsigned char *)a5 + v12) = v19;
      unint64_t v20 = a3 - 1;
      char v21 = v12 + 1;
      unsigned int v12 = ((_BYTE)v12 + 1) & 7;
      if ((v21 & 7) == 0) {
        break;
      }
      --a3;
    }
    while (a3);
  }
  else
  {
    unint64_t v20 = a3;
  }
  if (v20 < 8)
  {
    unsigned int v23 = v12;
    if (!v20) {
      goto LABEL_49;
    }
    goto LABEL_44;
  }
  do
  {
    if ((*(unsigned char *)(a4 + 4132) & 1) != 0 && *(_DWORD *)(a4 + 4128) == 1024)
    {
      Gost2814789_cryptopro_key_mesh((int *)a4);
      Gost2814789_encrypt(a5, a5, (int *)a4);
      *(_DWORD *)(a4 + 4128) = 0;
    }
    uint64_t result = Gost2814789_encrypt(a5, a5, (int *)a4);
    *(_DWORD *)(a4 + 4128) += 8;
    if (v12 <= 7)
    {
      uint64_t v25 = *(void *)&v11[v12];
      *(void *)&a2[v12] = *(void *)((char *)a5 + v12) ^ v25;
      *(void *)((char *)a5 + v12) = v25;
    }
    unsigned int v12 = 0;
    unsigned int v23 = 0;
    v20 -= 8;
    a2 += 8;
    v11 += 8;
  }
  while (v20 > 7);
  if (v20)
  {
LABEL_44:
    if ((*(unsigned char *)(a4 + 4132) & 1) != 0 && *(_DWORD *)(a4 + 4128) == 1024)
    {
      Gost2814789_cryptopro_key_mesh((int *)a4);
      Gost2814789_encrypt(a5, a5, (int *)a4);
      *(_DWORD *)(a4 + 4128) = 0;
    }
    uint64_t result = Gost2814789_encrypt(a5, a5, (int *)a4);
    *(_DWORD *)(a4 + 4128) += 8;
    do
    {
      char v26 = v11[v23];
      a2[v23] = v26 ^ *((unsigned char *)a5 + v23);
      *((unsigned char *)a5 + v23++) = v26;
      --v20;
    }
    while (v20);
  }
LABEL_49:
  *a6 = v23;
  return result;
}

uint64_t Gost2814789_cnt_encrypt(uint64_t result, unsigned char *a2, unint64_t a3, uint64_t a4, int *a5, int *a6, unsigned int *a7)
{
  unsigned int v12 = (char *)result;
  unsigned int v13 = *a7;
  if (*a7) {
    BOOL v14 = a3 == 0;
  }
  else {
    BOOL v14 = 1;
  }
  if (v14)
  {
    unint64_t v15 = a3;
  }
  else
  {
    do
    {
      char v16 = *v12++;
      *a2++ = *((unsigned char *)a6 + v13) ^ v16;
      unint64_t v15 = a3 - 1;
      char v17 = v13 + 1;
      unsigned int v13 = ((_BYTE)v13 + 1) & 7;
      if ((v17 & 7) == 0) {
        break;
      }
      --a3;
    }
    while (a3);
  }
  if (v15 < 8)
  {
    unsigned int v18 = v13;
    if (!v15) {
      goto LABEL_18;
    }
    goto LABEL_16;
  }
  do
  {
    uint64_t result = Gost2814789_cnt_next(a5, a6, a4);
    if (v13 <= 7) {
      *(void *)&a2[v13] = *(void *)((char *)a6 + v13) ^ *(void *)&v12[v13];
    }
    unsigned int v13 = 0;
    unsigned int v18 = 0;
    v15 -= 8;
    a2 += 8;
    v12 += 8;
  }
  while (v15 > 7);
  if (v15)
  {
LABEL_16:
    uint64_t result = Gost2814789_cnt_next(a5, a6, a4);
    do
    {
      a2[v18] = *((unsigned char *)a6 + v18) ^ v12[v18];
      ++v18;
      --v15;
    }
    while (v15);
  }
LABEL_18:
  *a7 = v18;
  return result;
}

uint64_t Gost2814789_cnt_next(int *a1, int *a2, uint64_t a3)
{
  if (!*(_DWORD *)(a3 + 4128)) {
    Gost2814789_encrypt(a1, a1, (int *)a3);
  }
  if ((*(unsigned char *)(a3 + 4132) & 1) != 0 && *(_DWORD *)(a3 + 4128) == 1024)
  {
    Gost2814789_cryptopro_key_mesh((int *)a3);
    Gost2814789_encrypt(a1, a1, (int *)a3);
    *(_DWORD *)(a3 + 4128) = 0;
  }
  unsigned int v6 = a1[1];
  if (v6 <= 0xFEFEFEFB) {
    int v7 = 16843012;
  }
  else {
    int v7 = 16843013;
  }
  *a1 += 16843009;
  a1[1] = v7 + v6;
  uint64_t result = Gost2814789_encrypt(a1, a2, (int *)a3);
  *(_DWORD *)(a3 + 4128) += 8;
  return result;
}

uint64_t GOST2814789IMIT_Init(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = 0;
  *(void *)a1 = 0;
  *(void *)(a1 + 4156) = 0;
  return Gost2814789_set_sbox(a1 + 20, a2);
}

uint64_t GOST2814789IMIT_Update(uint64_t a1, char *__src, size_t __n)
{
  if (__n)
  {
    size_t v3 = __n;
    int v4 = __src;
    *(void *)a1 += 8 * __n;
    uint64_t v6 = *(unsigned int *)(a1 + 16);
    if (v6)
    {
      int v7 = (void *)(a1 + 8 + v6);
      if (__n <= 7 && v6 + __n < 8)
      {
        memcpy(v7, __src, __n);
        *(_DWORD *)(a1 + 16) += v3;
        return 1;
      }
      uint64_t v8 = 8 - v6;
      memcpy(v7, __src, 8 - v6);
      Gost2814789_mac_mesh(a1 + 8, (int *)(a1 + 4156), a1 + 20);
      v4 += v8;
      v3 -= v8;
      *(_DWORD *)(a1 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = 0;
      *(void *)(a1 + 8) = 0;
    }
    if (v3 >= 8)
    {
      size_t v9 = v3 >> 3;
      uint64_t v10 = (uint64_t)v4;
      do
      {
        Gost2814789_mac_mesh(v10, (int *)(a1 + 4156), a1 + 20);
        v10 += 8;
        --v9;
      }
      while (v9);
      v4 += v3 & 0xFFFFFFFFFFFFFFF8;
      v3 &= 7u;
    }
    if (v3)
    {
      *(_DWORD *)(a1 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = v3;
      memcpy((void *)(a1 + 8), v4, v3);
    }
  }
  return 1;
}

uint64_t GOST2814789IMIT_Transform(uint64_t a1, uint64_t a2)
{
  return Gost2814789_mac_mesh(a2, (int *)(a1 + 4156), a1 + 20);
}

uint64_t GOST2814789IMIT_Final(_DWORD *a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a2 + 16);
  if (v4)
  {
    bzero((void *)(a2 + 8 + v4), (8 - v4));
    Gost2814789_mac_mesh(a2 + 8, (int *)(a2 + 4156), a2 + 20);
  }
  if ((*(_DWORD *)a2 - 65) >= 0xFFFFFFC0 && !*(_DWORD *)(a2 + 4))
  {
    *(void *)(a2 + 8) = 0;
    Gost2814789_mac_mesh(a2 + 8, (int *)(a2 + 4156), a2 + 20);
  }
  *a1 = *(_DWORD *)(a2 + 4156);
  return 1;
}

uint64_t Gost2814789_mac_mesh(uint64_t a1, int *a2, uint64_t a3)
{
  if ((*(unsigned char *)(a3 + 4132) & 1) != 0 && *(_DWORD *)(a3 + 4128) == 1024)
  {
    Gost2814789_cryptopro_key_mesh((int *)a3);
    *(_DWORD *)(a3 + 4128) = 0;
  }
  for (uint64_t i = 0; i != 8; ++i)
    *((unsigned char *)a2 + i) ^= *(unsigned char *)(a1 + i);
  int v7 = *(_DWORD *)(a3 + 4);
  int v8 = (*(_DWORD *)(a3 + 1056 + 4 * ((*a2 + *(_DWORD *)a3) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((*a2 + *(_DWORD *)a3) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(*(_WORD *)a2 + *(_WORD *)a3) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (*(unsigned char *)a2 + *(unsigned char *)a3))) ^ a2[1];
  int v9 = (*(_DWORD *)(a3 + 1056 + 4 * ((v8 + v7) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v8 + v7) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v8 + v7) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v8 + v7))) ^ *a2;
  int v11 = *(_DWORD *)(a3 + 8);
  int v10 = *(_DWORD *)(a3 + 12);
  int v12 = (*(_DWORD *)(a3 + 1056 + 4 * ((v9 + v11) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v9 + v11) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v9 + v11) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v9 + v11))) ^ v8;
  int v13 = (*(_DWORD *)(a3 + 1056 + 4 * ((v12 + v10) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v12 + v10) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v12 + v10) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v12 + v10))) ^ v9;
  int v14 = *(_DWORD *)(a3 + 16);
  int v15 = *(_DWORD *)(a3 + 20);
  int v16 = (*(_DWORD *)(a3 + 1056 + 4 * ((v13 + v14) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v13 + v14) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v13 + v14) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v13 + v14))) ^ v12;
  int v17 = (*(_DWORD *)(a3 + 1056 + 4 * ((v16 + v15) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v16 + v15) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v16 + v15) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v16 + v15))) ^ v13;
  uint64_t result = *(unsigned int *)(a3 + 24);
  int v19 = *(_DWORD *)(a3 + 28);
  int v20 = (*(_DWORD *)(a3 + 1056 + 4 * ((v17 + result) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v17 + result) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v17 + result) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v17 + result))) ^ v16;
  int v21 = (*(_DWORD *)(a3 + 1056 + 4 * ((v20 + v19) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v20 + v19) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v20 + v19) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v20 + v19))) ^ v17;
  int v22 = (*(_DWORD *)(a3 + 1056 + 4 * ((v21 + *(_DWORD *)a3) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v21 + *(_DWORD *)a3) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v21 + *(_WORD *)a3) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v21 + *(unsigned char *)a3))) ^ v20;
  int v23 = (*(_DWORD *)(a3 + 1056 + 4 * ((v22 + v7) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v22 + v7) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v22 + v7) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v22 + v7))) ^ v21;
  int v24 = (*(_DWORD *)(a3 + 1056 + 4 * ((v23 + v11) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v23 + v11) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v23 + v11) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v23 + v11))) ^ v22;
  int v25 = (*(_DWORD *)(a3 + 1056 + 4 * ((v24 + v10) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v24 + v10) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v24 + v10) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v24 + v10))) ^ v23;
  int v26 = (*(_DWORD *)(a3 + 1056 + 4 * ((v25 + v14) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v25 + v14) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v25 + v14) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v25 + v14))) ^ v24;
  int v27 = (*(_DWORD *)(a3 + 1056 + 4 * ((v26 + v15) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v26 + v15) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v26 + v15) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v26 + v15))) ^ v25;
  int v28 = (*(_DWORD *)(a3 + 1056 + 4 * ((v27 + result) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v27 + result) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v27 + result) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v27 + result))) ^ v26;
  *a2 = (*(_DWORD *)(a3 + 1056 + 4 * ((v28 + v19) >> 16)) | *(_DWORD *)(a3 + 32 + 4 * ((v28 + v19) >> 24)) | *(_DWORD *)(a3 + 2080 + 4 * ((unsigned __int16)(v28 + v19) >> 8)) | *(_DWORD *)(a3 + 3104 + 4 * (v28 + v19))) ^ v27;
  a2[1] = v28;
  *(_DWORD *)(a3 + 4128) += 8;
  return result;
}

void GOST2814789IMIT(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x270FA5388](a1);
  int v5 = v4;
  uint64_t v7 = v6;
  size_t v9 = v8;
  int v10 = (char *)v1;
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v13 = 0;
  memset(v12, 0, 64);
  if (v2) {
    int v11 = v2;
  }
  else {
    int v11 = &GOST2814789IMIT_m;
  }
  memset(&v12[4], 0, 448);
  Gost2814789_set_sbox((uint64_t)&v12[1] + 4, v3);
  uint64_t v13 = *v5;
  Gost2814789_set_key((uint64_t)&v12[1] + 4, v7, 256);
  GOST2814789IMIT_Update((uint64_t)v12, v10, v9);
  GOST2814789IMIT_Final(v11, (uint64_t)v12);
  explicit_bzero(v12, 0x1044uLL);
}

ECDSA_SIG *__cdecl d2i_ECDSA_SIG(ECDSA_SIG **v, const unsigned __int8 **pp, uint64_t len)
{
  return (ECDSA_SIG *)ASN1_item_d2i((ASN1_VALUE **)v, pp, len, &ECDSA_SIG_it);
}

int i2d_ECDSA_SIG(const ECDSA_SIG *a, unsigned __int8 **pp)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, pp, &ECDSA_SIG_it);
}

ECDSA_SIG *ECDSA_SIG_new(void)
{
  return (ECDSA_SIG *)ASN1_item_new(&ECDSA_SIG_it);
}

void ECDSA_SIG_free(ECDSA_SIG *a)
{
}

void *ECDSA_SIG_get0(void *result, void *a2, void *a3)
{
  if (a2) {
    *a2 = *result;
  }
  if (a3) {
    *a3 = result[1];
  }
  return result;
}

uint64_t ECDSA_SIG_get0_r(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t ECDSA_SIG_get0_s(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t ECDSA_SIG_set0(BIGNUM **a1, BIGNUM *a2, BIGNUM *a3)
{
  uint64_t result = 0;
  if (a2)
  {
    if (a3)
    {
      BN_free(*a1);
      BN_free(a1[1]);
      *a1 = a2;
      a1[1] = a3;
      return 1;
    }
  }
  return result;
}

uint64_t EC_POINT_set_compressed_coordinates(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, BN_CTX *a5)
{
  int v10 = a5;
  if (!a5)
  {
    int v10 = BN_CTX_new();
    if (!v10) {
      goto LABEL_8;
    }
  }
  int v11 = *(uint64_t (**)(uint64_t, void *, uint64_t, uint64_t, BN_CTX *))(*(void *)a1 + 136);
  if (!v11)
  {
    int v12 = 66;
    int v13 = 86;
    goto LABEL_7;
  }
  if (*(void *)a1 != *a2)
  {
    int v12 = 101;
    int v13 = 90;
LABEL_7:
    ERR_put_error(16, 4095, v12, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_oct.c", v13);
LABEL_8:
    uint64_t v14 = 0;
    goto LABEL_10;
  }
  uint64_t v14 = v11(a1, a2, a3, a4, v10);
LABEL_10:
  if (v10 != a5) {
    BN_CTX_free(v10);
  }
  return v14;
}

size_t EC_POINT_point2oct(const EC_GROUP *a1, const EC_POINT *a2, point_conversion_form_t form, unsigned __int8 *buf, size_t len, BN_CTX *a6)
{
  uint64_t v9 = *(void *)&form;
  int v12 = a6;
  if (!a6)
  {
    int v12 = BN_CTX_new();
    if (!v12) {
      goto LABEL_8;
    }
  }
  int v13 = *(uint64_t (**)(const EC_GROUP *, const EC_POINT *, uint64_t, unsigned __int8 *, size_t, BN_CTX *))(*(void *)a1 + 144);
  if (!v13)
  {
    int v14 = 66;
    int v15 = 124;
    goto LABEL_7;
  }
  if (*(void *)a1 != *(void *)a2)
  {
    int v14 = 101;
    int v15 = 128;
LABEL_7:
    ERR_put_error(16, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_oct.c", v15);
LABEL_8:
    size_t v16 = 0;
    goto LABEL_10;
  }
  size_t v16 = v13(a1, a2, v9, buf, len, v12);
LABEL_10:
  if (v12 != a6) {
    BN_CTX_free(v12);
  }
  return v16;
}

int EC_POINT_oct2point(const EC_GROUP *a1, EC_POINT *a2, const unsigned __int8 *buf, size_t len, BN_CTX *a5)
{
  int v10 = a5;
  if (!a5)
  {
    int v10 = BN_CTX_new();
    if (!v10) {
      goto LABEL_8;
    }
  }
  int v11 = *(uint64_t (**)(const EC_GROUP *, EC_POINT *, const unsigned __int8 *, size_t, BN_CTX *))(*(void *)a1 + 152);
  if (!v11)
  {
    int v12 = 66;
    int v13 = 153;
    goto LABEL_7;
  }
  if (*(void *)a1 != *(void *)a2)
  {
    int v12 = 101;
    int v13 = 157;
LABEL_7:
    ERR_put_error(16, 4095, v12, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_oct.c", v13);
LABEL_8:
    int v14 = 0;
    goto LABEL_10;
  }
  int v14 = v11(a1, a2, buf, len, v10);
LABEL_10:
  if (v10 != a5) {
    BN_CTX_free(v10);
  }
  return v14;
}

uint64_t cmac_size()
{
  return 32;
}

EVP_CIPHER_CTX *cmac_key_free(uint64_t a1)
{
  return CMAC_CTX_free(*(EVP_CIPHER_CTX **)(a1 + 32));
}

void *EVP_gostr341194()
{
  return &gostr341194_md;
}

uint64_t gostr341194_init(uint64_t a1)
{
  return GOSTR341194_Init(*(void **)(a1 + 24), 822);
}

uint64_t gostr341194_update(uint64_t a1, char *a2, size_t a3)
{
  return GOSTR341194_Update(*(void *)(a1 + 24), a2, a3);
}

uint64_t gostr341194_final(uint64_t a1, _OWORD *a2)
{
  return GOSTR341194_Final(a2, *(void *)(a1 + 24));
}

void *EVP_sm3()
{
  return &sm3_md;
}

uint64_t sm3_init(uint64_t a1)
{
  return SM3_Init(*(_OWORD **)(a1 + 24));
}

uint64_t sm3_update(uint64_t a1, char *a2, size_t a3)
{
  return SM3_Update(*(void *)(a1 + 24), a2, a3);
}

uint64_t sm3_final(uint64_t a1, _DWORD *a2)
{
  return SM3_Final(a2, *(unsigned int **)(a1 + 24));
}

X509_ALGOR *__cdecl d2i_X509_ALGOR(X509_ALGOR **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_ALGOR *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_ALGOR_it);
}

int i2d_X509_ALGOR(X509_ALGOR *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_ALGOR_it);
}

X509_ALGOR *X509_ALGOR_new(void)
{
  return (X509_ALGOR *)ASN1_item_new(&X509_ALGOR_it);
}

void X509_ALGOR_free(X509_ALGOR *a)
{
}

X509_ALGORS *__cdecl d2i_X509_ALGORS(X509_ALGORS **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_ALGORS *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_ALGORS_it);
}

int i2d_X509_ALGORS(X509_ALGORS *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_ALGORS_it);
}

X509_ALGOR *__cdecl X509_ALGOR_dup(X509_ALGOR *xn)
{
  return (X509_ALGOR *)ASN1_item_dup(&X509_ALGOR_it, xn);
}

int X509_ALGOR_set0(X509_ALGOR *alg, ASN1_OBJECT *aobj, int ptype, void *pval)
{
  if (alg)
  {
    uint64_t v7 = alg;
    if (ptype == -1
      || alg->parameter
      || (alg = (X509_ALGOR *)ASN1_TYPE_new(), (v7->parameter = (ASN1_TYPE *)alg) != 0))
    {
      if (v7->algorithm) {
        ASN1_OBJECT_free(v7->algorithm);
      }
      v7->algorithuint64_t m = aobj;
      if (ptype)
      {
        if (ptype == -1)
        {
          parameter = v7->parameter;
          if (parameter)
          {
            ASN1_TYPE_free(parameter);
            v7->parameter = 0;
          }
        }
        else
        {
          ASN1_TYPE_set(v7->parameter, ptype, pval);
        }
      }
      LODWORD(alg) = 1;
    }
  }
  return (int)alg;
}

void X509_ALGOR_get0(ASN1_OBJECT **paobj, int *pptype, void **ppval, X509_ALGOR *algor)
{
  if (paobj) {
    *paobuint64_t j = algor->algorithm;
  }
  if (pptype)
  {
    parameter = algor->parameter;
    if (parameter)
    {
      *int pptype = parameter->type;
      if (ppval) {
        *ppunint64_t val = parameter->value.ptr;
      }
    }
    else
    {
      *int pptype = -1;
    }
  }
}

uint64_t X509_ALGOR_set_md(X509_ALGOR *a1, const EVP_MD *a2)
{
  if ((EVP_MD_flags((uint64_t)a2) & 8) != 0) {
    int v4 = -1;
  }
  else {
    int v4 = 5;
  }
  int v5 = EVP_MD_type(a2);
  uint64_t v6 = OBJ_nid2obj(v5);
  return X509_ALGOR_set0(a1, v6, v4, 0);
}

uint64_t X509_ALGOR_cmp(uint64_t a1, uint64_t a2)
{
  uint64_t result = OBJ_cmp(*(const ASN1_OBJECT **)a1, *(const ASN1_OBJECT **)a2);
  if (!result)
  {
    int v5 = *(const ASN1_OBJECT ***)(a1 + 8);
    uint64_t v6 = *(void *)(a2 + 8);
    if ((unint64_t)v5 | v6)
    {
      return ASN1_TYPE_cmp(v5, v6);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void CAST_ecb_encrypt(const unsigned __int8 *in, unsigned __int8 *out, const CAST_KEY *key, int enc)
{
  v6[1] = *MEMORY[0x263EF8340];
  v6[0] = __PAIR64__(bswap32(*((_DWORD *)in + 1)), bswap32(*(_DWORD *)in));
  if (enc) {
    CAST_encrypt(v6, key);
  }
  else {
    CAST_decrypt(v6, key);
  }
  unsigned int v5 = bswap32(HIDWORD(v6[0]));
  *(_DWORD *)unsigned __int8 out = bswap32(v6[0]);
  *((_DWORD *)out + md5_block_data_order((unint64_t)c, b, 1) = v5;
}

uint64_t GostR3410_get_md_digest(uint64_t result)
{
  if (result == 822) {
    return 809;
  }
  else {
    return result;
  }
}

uint64_t GostR3410_get_pk_digest(int a1)
{
  if (a1 == 941) {
    int v1 = 946;
  }
  else {
    int v1 = 0;
  }
  if (a1 == 942) {
    unsigned int v2 = 947;
  }
  else {
    unsigned int v2 = v1;
  }
  if (a1 == 822) {
    return 811;
  }
  else {
    return v2;
  }
}

uint64_t GostR3410_256_param_id(char *a1)
{
  uint64_t v2 = 0;
  while (strcasecmp((&GostR3410_256_params)[v2], a1))
  {
    v2 += 2;
    if (v2 == 12) {
      return 0;
    }
  }
  return LODWORD((&GostR3410_256_params)[v2 + 1]);
}

uint64_t GostR3410_512_param_id(char *a1)
{
  uint64_t v2 = 0;
  while (strcasecmp((&GostR3410_512_params)[v2], a1))
  {
    v2 += 2;
    if (v2 == 4) {
      return 0;
    }
  }
  return LODWORD((&GostR3410_512_params)[v2 + 1]);
}

unint64_t *idea_cfb64_encrypt(unint64_t *result, unsigned char *a2, uint64_t a3, unsigned int *a4, unsigned int *a5, int *a6, int a7)
{
  uint64_t v10 = a3;
  int v12 = result;
  uint64_t v24 = *MEMORY[0x263EF8340];
  int v13 = *a6;
  if (a7)
  {
    if (a3)
    {
      do
      {
        if (!v13)
        {
          uint64_t v14 = bswap32(a5[1]);
          unint64_t v22 = bswap32(*a5);
          uint64_t v23 = v14;
          uint64_t result = idea_encrypt(&v22, a4);
          unsigned int v15 = bswap32(v23);
          *a5 = bswap32(v22);
          a5[1] = v15;
        }
        char v16 = *(unsigned char *)v12;
        int v12 = (unint64_t *)((char *)v12 + 1);
        char v17 = *((unsigned char *)a5 + v13);
        *a2++ = v17 ^ v16;
        *((unsigned char *)a5 + v13) = v17 ^ v16;
        int v13 = (v13 + 1) & 7;
        --v10;
      }
      while (v10);
    }
  }
  else if (a3)
  {
    do
    {
      if (!v13)
      {
        uint64_t v18 = bswap32(a5[1]);
        unint64_t v22 = bswap32(*a5);
        uint64_t v23 = v18;
        uint64_t result = idea_encrypt(&v22, a4);
        unsigned int v19 = bswap32(v23);
        *a5 = bswap32(v22);
        a5[1] = v19;
      }
      char v20 = *(unsigned char *)v12;
      int v12 = (unint64_t *)((char *)v12 + 1);
      char v21 = *((unsigned char *)a5 + v13);
      *((unsigned char *)a5 + v13) = v20;
      *a2++ = v21 ^ v20;
      int v13 = (v13 + 1) & 7;
      --v10;
    }
    while (v10);
  }
  *a6 = v13;
  return result;
}

void DH_set_default_method(const DH_METHOD *meth)
{
  default_DH_int method = (uint64_t)meth;
}

const DH_METHOD *DH_get_default_method(void)
{
  uint64_t result = (const DH_METHOD *)default_DH_method;
  if (!default_DH_method)
  {
    uint64_t result = DH_OpenSSL();
    default_DH_int method = (uint64_t)result;
  }
  return result;
}

int DH_set_method(DH *dh, const DH_METHOD *meth)
{
  int v4 = *(void (**)(DH *))(*(void *)&dh->ex_data.dummy + 40);
  if (v4) {
    v4(dh);
  }
  ENGINE_finish((ENGINE *)dh->meth);
  *(void *)&dh->ex_data.dummy = meth;
  dh->meth = 0;
  init = meth->init;
  if (init) {
    ((void (*)(DH *))init)(dh);
  }
  return 1;
}

DH *DH_new(void)
{
  return DH_new_method(0);
}

DH *__cdecl DH_new_method(ENGINE *engine)
{
  uint64_t v2 = (char *)malloc_type_malloc(0x88uLL, 0x1070040C1BEA720uLL);
  if (!v2)
  {
    ERR_put_error(5, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_lib.c", 125);
    return (DH *)v2;
  }
  int v3 = (const DH_METHOD *)default_DH_method;
  if (!default_DH_method)
  {
    int v3 = DH_OpenSSL();
    default_DH_int method = (uint64_t)v3;
  }
  *((void *)v2 + 15) = v3;
  if (engine)
  {
    if (!ENGINE_init(engine))
    {
      ERR_put_error(5, 4095, 38, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_lib.c", 133);
      goto LABEL_16;
    }
    *((void *)v2 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = engine;
    goto LABEL_9;
  }
  engine = ENGINE_get_default_DH();
  *((void *)v2 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = engine;
  if (engine)
  {
LABEL_9:
    DH = ENGINE_get_DH(engine);
    *((void *)v2 + 15) = DH;
    if (!DH)
    {
      ERR_put_error(5, 4095, 38, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_lib.c", 143);
      ENGINE_finish(*((ENGINE **)v2 + 16));
LABEL_16:
      free(v2);
      return 0;
    }
    goto LABEL_13;
  }
  DH = (const DH_METHOD *)*((void *)v2 + 15);
LABEL_13:
  *((void *)v2 + 12) = 0;
  *(_OWORD *)uint64_t v2 = 0u;
  *((_OWORD *)v2 + md5_block_data_order((unint64_t)c, b, 1) = 0u;
  *((_OWORD *)v2 + 2) = 0u;
  *(_OWORD *)(v2 + 56) = 0u;
  *(_OWORD *)(v2 + 72) = 0u;
  *((_DWORD *)v2 + 22) = 0;
  *((_DWORD *)v2 + 26) = 1;
  *((_DWORD *)v2 + 12) = DH->flags & 0xFFFFFBFF;
  CRYPTO_new_ex_data(8, v2, (CRYPTO_EX_DATA *)v2 + 7);
  unsigned int v5 = *(unsigned int (**)(char *))(*((void *)v2 + 15) + 32);
  if (v5 && !v5(v2))
  {
    ENGINE_finish(*((ENGINE **)v2 + 16));
    CRYPTO_free_ex_data(8, v2, (CRYPTO_EX_DATA *)v2 + 7);
    goto LABEL_16;
  }
  return (DH *)v2;
}

void DH_free(DH *dh)
{
  if (dh && CRYPTO_add_lock(&dh->references, -1, 26, 0, 0) <= 0)
  {
    uint64_t v2 = *(void (**)(DH *))(*(void *)&dh->ex_data.dummy + 40);
    if (v2) {
      v2(dh);
    }
    ENGINE_finish((ENGINE *)dh->meth);
    CRYPTO_free_ex_data(8, dh, &dh->ex_data);
    BN_free(dh->p);
    BN_free(dh->g);
    BN_free(dh->q);
    BN_free(dh->j);
    free(dh->seed);
    BN_free(dh->counter);
    BN_free(dh->pub_key);
    BN_free(dh->priv_key);
    free(dh);
  }
}

int DH_up_ref(DH *dh)
{
  return CRYPTO_add_lock(&dh->references, 1, 26, 0, 0) > 1;
}

int DH_get_ex_new_index(uint64_t argl, void *argp, CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
  return CRYPTO_get_ex_new_index(8, argl, argp, new_func, dup_func, free_func);
}

int DH_set_ex_data(DH *d, int idx, void *arg)
{
  return CRYPTO_set_ex_data(&d->ex_data, idx, arg);
}

void *__cdecl DH_get_ex_data(DH *d, int idx)
{
  return CRYPTO_get_ex_data(&d->ex_data, idx);
}

int DH_size(const DH *dh)
{
  int v1 = BN_num_bits(dh->p);
  int v2 = v1 + 7;
  if (v1 < -7) {
    int v2 = v1 + 14;
  }
  return v2 >> 3;
}

uint64_t DH_bits(uint64_t a1)
{
  return BN_num_bits(*(const BIGNUM **)(a1 + 8));
}

uint64_t DH_security_bits(uint64_t a1)
{
  int v2 = *(const BIGNUM **)(a1 + 64);
  if (v2)
  {
    int v3 = BN_num_bits(v2);
  }
  else if (*(uint64_t *)(a1 + 24) <= 0)
  {
    int v3 = -1;
  }
  else
  {
    int v3 = *(void *)(a1 + 24);
  }
  int v4 = BN_num_bits(*(const BIGNUM **)(a1 + 8));
  return BN_security_bits(v4, v3);
}

uint64_t DH_get0_engine(uint64_t a1)
{
  return *(void *)(a1 + 128);
}

void *DH_get0_pqg(void *result, void *a2, void *a3, void *a4)
{
  if (a2) {
    *a2 = result[1];
  }
  if (a3) {
    *a3 = result[8];
  }
  if (a4) {
    *a4 = result[2];
  }
  return result;
}

uint64_t DH_set0_pqg(uint64_t a1, uint64_t a2, const BIGNUM *a3, uint64_t a4)
{
  unsigned int v5 = *(BIGNUM **)(a1 + 8);
  if (!(a2 | (unint64_t)v5) || !(a4 | *(void *)(a1 + 16))) {
    return 0;
  }
  if (a2)
  {
    BN_free(v5);
    *(void *)(a1 + 8) = a2;
  }
  if (a3)
  {
    BN_free(*(BIGNUM **)(a1 + 64));
    *(void *)(a1 + 64) = a3;
    *(void *)(a1 + 24) = BN_num_bits(a3);
  }
  if (a4)
  {
    BN_free(*(BIGNUM **)(a1 + 16));
    *(void *)(a1 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = a4;
  }
  return 1;
}

uint64_t DH_get0_key(uint64_t result, void *a2, void *a3)
{
  if (a2) {
    *a2 = *(void *)(result + 32);
  }
  if (a3) {
    *a3 = *(void *)(result + 40);
  }
  return result;
}

uint64_t DH_set0_key(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    BN_free(*(BIGNUM **)(a1 + 32));
    *(void *)(a1 + 32) = a2;
  }
  if (a3)
  {
    BN_free(*(BIGNUM **)(a1 + 40));
    *(void *)(a1 + 4X509_check_purpose(x, -1, 0) = a3;
  }
  return 1;
}

uint64_t DH_get0_p(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t DH_get0_q(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t DH_get0_g(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t DH_get0_priv_key(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t DH_get0_pub_key(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t DH_clear_flags(uint64_t result, int a2)
{
  *(_DWORD *)(result + 48) &= ~a2;
  return result;
}

uint64_t DH_test_flags(uint64_t a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 48) & a2;
}

uint64_t DH_set_flags(uint64_t result, int a2)
{
  *(_DWORD *)(result + 48) |= a2;
  return result;
}

uint64_t DH_get_length(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t DH_set_length(uint64_t a1, unint64_t a2)
{
  if (a2 >> 31) {
    return 0;
  }
  *(void *)(a1 + 24) = a2;
  return 1;
}

int EVP_add_cipher(const EVP_CIPHER *cipher)
{
  if (!cipher) {
    return 0;
  }
  int v2 = OBJ_nid2sn(cipher->nid);
  if (!OBJ_NAME_add(v2, 2, (const char *)cipher)) {
    return 0;
  }
  check_defer(cipher->nid);
  int v3 = OBJ_nid2ln(cipher->nid);
  return OBJ_NAME_add(v3, 2, (const char *)cipher);
}

int EVP_add_digest(const EVP_MD *digest)
{
  int v2 = OBJ_nid2sn(digest->type);
  int result = OBJ_NAME_add(v2, 1, (const char *)digest);
  if (result)
  {
    check_defer(digest->type);
    int v4 = OBJ_nid2ln(digest->type);
    int result = OBJ_NAME_add(v4, 1, (const char *)digest);
    if (result)
    {
      int pkey_type = digest->pkey_type;
      if (pkey_type)
      {
        if (digest->type != pkey_type)
        {
          uint64_t v6 = OBJ_nid2sn(digest->pkey_type);
          int result = OBJ_NAME_add(v6, 32769, v2);
          if (result)
          {
            check_defer(digest->pkey_type);
            uint64_t v7 = OBJ_nid2ln(digest->pkey_type);
            return OBJ_NAME_add(v7, 32769, v2);
          }
        }
      }
    }
  }
  return result;
}

const EVP_CIPHER *__cdecl EVP_get_cipherbyname(const char *name)
{
  if (!OPENSSL_init_crypto(0)) {
    return 0;
  }
  return (const EVP_CIPHER *)OBJ_NAME_get(name, 2);
}

const EVP_MD *__cdecl EVP_get_digestbyname(const char *name)
{
  if (!OPENSSL_init_crypto(0)) {
    return 0;
  }
  return (const EVP_MD *)OBJ_NAME_get(name, 1);
}

void EVP_cleanup(void)
{
  OBJ_NAME_cleanup(2);
  OBJ_NAME_cleanup(1);
  OBJ_NAME_cleanup(-1);
  EVP_PBE_cleanup();
  if (obj_cleanup_defer == 2)
  {
    obj_cleanup_defer = 0;
    OBJ_cleanup();
  }
  OBJ_sigid_free();
}

void EVP_CIPHER_do_all(uint64_t a1, uint64_t a2)
{
  OPENSSL_init_crypto(0);
  v4[0] = a2;
  v4[1] = a1;
  OBJ_NAME_do_all(2, (void (__cdecl *)(const OBJ_NAME *, void *))do_all_cipher_fn, v4);
}

uint64_t do_all_cipher_fn(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  int v3 = (uint64_t (*)(void, void, void, uint64_t))a2[1];
  if (*(_DWORD *)(a1 + 4)) {
    return v3(0, *(void *)(a1 + 8), *(void *)(a1 + 16), v2);
  }
  else {
    return v3(*(void *)(a1 + 16), *(void *)(a1 + 8), 0, v2);
  }
}

void EVP_CIPHER_do_all_sorted(uint64_t a1, uint64_t a2)
{
  OPENSSL_init_crypto(0);
  v4[0] = a2;
  v4[1] = a1;
  OBJ_NAME_do_all_sorted(2, (void (__cdecl *)(const OBJ_NAME *, void *))do_all_cipher_fn, v4);
}

void EVP_MD_do_all(uint64_t a1, uint64_t a2)
{
  OPENSSL_init_crypto(0);
  v4[0] = a2;
  v4[1] = a1;
  OBJ_NAME_do_all(1, (void (__cdecl *)(const OBJ_NAME *, void *))do_all_md_fn, v4);
}

uint64_t do_all_md_fn(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  int v3 = (uint64_t (*)(void, void, void, uint64_t))a2[1];
  if (*(_DWORD *)(a1 + 4)) {
    return v3(0, *(void *)(a1 + 8), *(void *)(a1 + 16), v2);
  }
  else {
    return v3(*(void *)(a1 + 16), *(void *)(a1 + 8), 0, v2);
  }
}

void EVP_MD_do_all_sorted(uint64_t a1, uint64_t a2)
{
  OPENSSL_init_crypto(0);
  v4[0] = a2;
  v4[1] = a1;
  OBJ_NAME_do_all_sorted(1, (void (__cdecl *)(const OBJ_NAME *, void *))do_all_md_fn, v4);
}

void ERR_load_OCSP_strings(void)
{
  if (!ERR_func_error_string(OCSP_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&OCSP_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&OCSP_str_reasons);
  }
}

int PKCS12_key_gen_asc(const char *pass, int passlen, unsigned __int8 *salt, int saltlen, int id, int iter, int n, unsigned __int8 *out, const EVP_MD *md_type)
{
  passEVP_CIPHER_CTX a = 0;
  int v17 = 0;
  if (pass)
  {
    if (!OPENSSL_asc2uni((char *)pass, passlen, &passa, &v17))
    {
      ERR_put_error(35, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs12/p12_key.c", 86);
      return 0;
    }
    pasunsigned int s = (const char *)passa;
    int v15 = v17;
  }
  else
  {
    int v15 = 0;
    passEVP_CIPHER_CTX a = 0;
    int v17 = 0;
  }
  int result = PKCS12_key_gen_uni((unsigned __int8 *)pass, v15, salt, saltlen, id, iter, n, out, md_type);
  if (result)
  {
    freezero(passa, v17);
    return 1;
  }
  return result;
}

int PKCS12_key_gen_uni(unsigned __int8 *pass, int passlen, unsigned __int8 *salt, int saltlen, int id, int iter, int n, unsigned __int8 *out, const EVP_MD *md_type)
{
  int v17 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (!v17
    || (__c = id, int v18 = EVP_MD_block_size(md_type), v18 < 1)
    || (int v19 = v18, v51 = iter, v20 = EVP_MD_size(md_type), v20 < 1))
  {
    int v31 = 0;
    unint64_t v22 = 0;
LABEL_43:
    int v26 = 0;
    uint64_t v23 = 0;
    goto LABEL_44;
  }
  int v21 = v20;
  int v49 = n;
  __int len = v19;
  unint64_t v22 = malloc_type_malloc(v19, 0x5D2391B5uLL);
  if (!v22)
  {
    int v31 = 0;
    goto LABEL_43;
  }
  char __dst = out;
  uint64_t v23 = malloc_type_malloc(v21, 0x5604AAD5uLL);
  if (!v23 || (int v46 = (char *)malloc_type_malloc((v19 + 1), 0xB4D0AFD2uLL)) == 0)
  {
    int v31 = 0;
    int v26 = 0;
    goto LABEL_44;
  }
  __b = v22;
  HMAC_CTX ctx = v17;
  int v24 = (saltlen + v19 - 1) / v19 * v19;
  if (passlen) {
    int v25 = (passlen + v19 - 1) / v19 * v19;
  }
  else {
    int v25 = 0;
  }
  int64_t cnt = v25 + v24;
  int v26 = (char *)malloc_type_malloc(cnt, 0xC0C787ECuLL);
  if (!v26)
  {
    int v17 = ctx;
LABEL_49:
    int v31 = v46;
    unint64_t v22 = __b;
    goto LABEL_44;
  }
  memset(__b, __c, v19);
  int v27 = v26;
  if (v24 >= 1)
  {
    uint64_t v28 = 0;
    do
    {
      v26[v28] = salt[(int)v28 % saltlen];
      ++v28;
    }
    while (v24 != v28);
    int v27 = &v26[v28];
  }
  if (v25 >= 1)
  {
    uint64_t v29 = 0;
    do
    {
      v27[v29] = pass[(int)v29 % passlen];
      ++v29;
    }
    while (v25 != v29);
  }
  int v17 = ctx;
  if (!EVP_DigestInit_ex(ctx, md_type, 0)) {
    goto LABEL_49;
  }
  uint64_t v30 = v19;
  int v31 = v46;
  unint64_t v22 = __b;
  int v32 = md_type;
  while (EVP_DigestUpdate(ctx, v22, __len)
       && EVP_DigestUpdate(ctx, v26, cnt)
       && EVP_DigestFinal_ex(ctx, (unsigned __int8 *)v23, 0))
  {
    int v33 = v51 - 1;
    if (v51 >= 2)
    {
      while (EVP_DigestInit_ex(ctx, v32, 0)
           && EVP_DigestUpdate(ctx, v23, v21)
           && EVP_DigestFinal_ex(ctx, (unsigned __int8 *)v23, 0))
      {
        if (!--v33) {
          goto LABEL_28;
        }
      }
      unint64_t v22 = __b;
      break;
    }
LABEL_28:
    if (v49 >= v21) {
      int v34 = v21;
    }
    else {
      int v34 = v49;
    }
    memcpy(__dst, v23, v34);
    BOOL v35 = v49 <= v21;
    v49 -= v21;
    unint64_t v22 = __b;
    if (v35)
    {
      int v42 = 1;
      goto LABEL_45;
    }
    uint64_t v36 = 0;
    __dst += v21;
    do
    {
      v46[v36] = *((unsigned char *)v23 + ((int)v36 % v21));
      ++v36;
    }
    while (__len != v36);
    int v32 = md_type;
    if ((int)cnt >= 1)
    {
      int64_t v37 = 0;
      int v38 = v26 - 1;
      do
      {
        __int16 v39 = 1;
        uint64_t v40 = v30;
        do
        {
          __int16 v41 = v39 + v38[v40] + v46[v40 - 1];
          v38[v40] = v41;
          __int16 v39 = HIBYTE(v41);
          BOOL v35 = v40-- <= 1;
        }
        while (!v35);
        v37 += v30;
        v38 += v30;
      }
      while (v37 < cnt);
    }
    if (!EVP_DigestInit_ex(ctx, md_type, 0)) {
      break;
    }
  }
LABEL_44:
  ERR_put_error(35, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs12/p12_key.c", 186);
  int v42 = 0;
LABEL_45:
  free(v23);
  free(v31);
  free(v22);
  free(v26);
  EVP_MD_CTX_free(v17);
  return v42;
}

void AES_cbc_encrypt(const unsigned __int8 *in, unsigned __int8 *out, const unint64_t length, const AES_KEY *key, unsigned __int8 *ivec, const int enc)
{
  if (enc) {
    CRYPTO_cbc128_encrypt(in, out, length, (uint64_t)key, ivec, (void (*)(void *, void *, uint64_t))AES_encrypt);
  }
  else {
    CRYPTO_cbc128_decrypt((uint64_t)in, (uint64_t *)out, length, (uint64_t)key, ivec, (uint64_t (*)(void *, uint64_t *, uint64_t))AES_decrypt);
  }
}

EVP_CIPHER_CTX *CMAC_CTX_new()
{
  int v0 = (EVP_CIPHER_CTX *)malloc_type_malloc(0x130uLL, 0x10E0040F7627181uLL);
  int v1 = v0;
  if (v0)
  {
    EVP_CIPHER_CTX_init(v0);
    v1[1].final_useuint64_t d = -1;
  }
  return v1;
}

void CMAC_CTX_cleanup(EVP_CIPHER_CTX *a1)
{
}

EVP_CIPHER_CTX *CMAC_CTX_free(EVP_CIPHER_CTX *result)
{
  if (result) {
    CMAC_CTX_cleanup(result);
  }
  return result;
}

uint64_t CMAC_CTX_copy(EVP_CIPHER_CTX *a1, EVP_CIPHER_CTX *a2)
{
  if (a2[1].final_used == -1) {
    return 0;
  }
  uint64_t result = EVP_CIPHER_CTX_copy(a1, (uint64_t *)a2);
  if (result)
  {
    size_t v5 = EVP_CIPHER_CTX_block_size(a2);
    memcpy(&a1[1], &a2[1], v5);
    memcpy(&a1[1].oiv[8], &a2[1].oiv[8], v5);
    memcpy(&a1[1].buf[8], &a2[1].buf[8], v5);
    memcpy(&a1[1].app_data, &a2[1].app_data, v5);
    a1[1].final_useuint64_t d = a2[1].final_used;
    return 1;
  }
  return result;
}

const EVP_CIPHER *CMAC_Init(EVP_CIPHER_CTX *ctx, const unsigned __int8 *a2, uint64_t a3, EVP_CIPHER *cipher, ENGINE *impl)
{
  int v5 = a3;
  if (!a2 && !cipher && !a3 && !impl)
  {
    if (ctx[1].final_used == -1) {
      return 0;
    }
    uint64_t result = (const EVP_CIPHER *)EVP_EncryptInit_ex(ctx, 0, 0, 0, CMAC_Init_zero_iv);
    if (!result) {
      return result;
    }
    int v9 = EVP_CIPHER_CTX_block_size(ctx);
    bzero(&ctx[1].buf[8], v9);
    ctx[1].final_useuint64_t d = 0;
    return (const EVP_CIPHER *)1;
  }
  if (cipher)
  {
    int v10 = EVP_EncryptInit_ex(ctx, cipher, impl, 0, 0);
    uint64_t result = (const EVP_CIPHER *)(v10 != 0);
    if (!a2 || !v10) {
      return result;
    }
  }
  else if (!a2)
  {
    return (const EVP_CIPHER *)1;
  }
  uint64_t result = EVP_CIPHER_CTX_cipher(ctx);
  if (result)
  {
    uint64_t result = (const EVP_CIPHER *)EVP_CIPHER_CTX_set_key_length(ctx, v5);
    if (result)
    {
      uint64_t result = (const EVP_CIPHER *)EVP_EncryptInit_ex(ctx, 0, 0, a2, CMAC_Init_zero_iv);
      if (result)
      {
        int v11 = EVP_CIPHER_CTX_block_size(ctx);
        uint64_t result = (const EVP_CIPHER *)EVP_Cipher(ctx, &ctx[1].buf[8], CMAC_Init_zero_iv, v11);
        if (result)
        {
          make_kn((uint64_t)&ctx[1], (char *)&ctx[1].buf[8], v11);
          make_kn((uint64_t)&ctx[1].oiv[8], (char *)&ctx[1], v11);
          explicit_bzero(&ctx[1].buf[8], v11);
        }
      }
    }
  }
  return result;
}

uint64_t make_kn(uint64_t result, char *a2, int a3)
{
  if (a3 >= 1)
  {
    for (unint64_t i = 0; i != a3; ++i)
    {
      char v4 = 2 * a2[i];
      *(unsigned char *)(result + i) = v4;
      if (i < (a3 - 1) && a2[i + 1] < 0) {
        *(unsigned char *)(result + i) = v4 | 1;
      }
    }
  }
  if (*a2 < 0)
  {
    if (a3 == 16) {
      char v5 = -121;
    }
    else {
      char v5 = 27;
    }
    *(unsigned char *)(result + a3 - 1) ^= v5;
  }
  return result;
}

uint64_t CMAC_Update(uint64_t a1, char *a2, size_t a3)
{
  if (*(_DWORD *)(a1 + 296) == -1) {
    return 0;
  }
  size_t v3 = a3;
  if (!a3) {
    return 1;
  }
  int v6 = EVP_CIPHER_CTX_block_size((const EVP_CIPHER_CTX *)a1);
  size_t v7 = v6;
  uint64_t v8 = *(unsigned int *)(a1 + 296);
  if ((int)v8 >= 1)
  {
    if (v6 - v8 >= v3) {
      size_t v9 = v3;
    }
    else {
      size_t v9 = v6 - v8;
    }
    memcpy((void *)(a1 + 264 + v8), a2, v9);
    *(_DWORD *)(a1 + 296) += v9;
    v3 -= v9;
    if (!v3) {
      return 1;
    }
    uint64_t result = EVP_Cipher((EVP_CIPHER_CTX *)a1, (unsigned __int8 *)(a1 + 232), (const unsigned __int8 *)(a1 + 264), v7);
    if (!result) {
      return result;
    }
    a2 += v9;
  }
  if (v3 <= v7)
  {
LABEL_13:
    memcpy((void *)(a1 + 264), a2, v3);
    *(_DWORD *)(a1 + 296) = v3;
    return 1;
  }
  while (1)
  {
    uint64_t result = EVP_Cipher((EVP_CIPHER_CTX *)a1, (unsigned __int8 *)(a1 + 232), (const unsigned __int8 *)a2, v7);
    if (!result) {
      return result;
    }
    v3 -= v7;
    a2 += v7;
    if (v3 <= v7) {
      goto LABEL_13;
    }
  }
}

uint64_t CMAC_Final(EVP_CIPHER_CTX *a1, unsigned char *a2, size_t *a3)
{
  if (a1[1].final_used == -1) {
    return 0;
  }
  size_t v6 = EVP_CIPHER_CTX_block_size(a1);
  *a3 = v6;
  if (a2)
  {
    final_useuint64_t d = a1[1].final_used;
    if (v6 == final_used)
    {
      if ((int)v6 >= 1)
      {
        uint64_t v8 = v6;
        p_app_unsigned int data = &a1[1].app_data;
        int v10 = a2;
        do
        {
          *v10++ = *(p_app_data - 96) ^ *p_app_data;
          ++p_app_data;
          --v8;
        }
        while (v8);
      }
    }
    else
    {
      int v11 = (char *)a1 + final_used;
      *((unsigned char *)&a1[1].app_data + final_used) = 0x80;
      int v12 = v6 - final_used;
      if (v12 > 1) {
        bzero(v11 + 265, (v12 - 1));
      }
      if ((int)v6 >= 1)
      {
        uint64_t v13 = v6;
        uint64_t v14 = &a1[1].app_data;
        int v15 = a2;
        do
        {
          *v15++ = *(v14 - 64) ^ *v14;
          ++v14;
          --v13;
        }
        while (v13);
      }
    }
    if (!EVP_Cipher(a1, a2, a2, v6)) {
      explicit_bzero(a2, v6);
    }
  }
  return 1;
}

uint64_t CMAC_resume(EVP_CIPHER_CTX *a1)
{
  if (a1[1].final_used == -1) {
    return 0;
  }
  else {
    return EVP_EncryptInit_ex(a1, 0, 0, 0, &a1[1].buf[8]);
  }
}

ASN1_STRING *ASN1_STRING_new(void)
{
  return ASN1_STRING_type_new(4);
}

ASN1_STRING *__cdecl ASN1_STRING_type_new(int type)
{
  uint64_t v2 = (ASN1_STRING *)malloc_type_calloc(1uLL, 0x18uLL, 0x1010040A500212DuLL);
  size_t v3 = v2;
  if (v2) {
    v2->type = type;
  }
  else {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_string.c", 80);
  }
  return v3;
}

void ASN1_STRING_free(ASN1_STRING *a)
{
  if (a)
  {
    ASN1_STRING_clear(&a->length);
    free(a);
  }
}

int *ASN1_STRING_clear(int *result)
{
  int v1 = result;
  uint64_t v2 = *((void *)result + 2);
  if ((v2 & 0x10) == 0)
  {
    uint64_t result = (int *)freezero(*((void **)result + 1), *result);
    uint64_t v2 = *((void *)v1 + 2);
  }
  *((void *)v1 + md5_block_data_order((unint64_t)c, b, 1) = 0;
  *((void *)v1 + 2) = v2 & 0xFFFFFFFFFFFFFFEFLL;
  *int v1 = 0;
  return result;
}

int ASN1_STRING_cmp(ASN1_STRING *a, ASN1_STRING *b)
{
  int result = -1;
  if (a)
  {
    if (b)
    {
      size_t length = a->length;
      int result = length - b->length;
      if (length == b->length)
      {
        int result = memcmp(a->data, b->data, length);
        if (!result) {
          return a->type - b->type;
        }
      }
    }
  }
  return result;
}

uint64_t ASN1_STRING_copy(ASN1_STRING *a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t result = ASN1_STRING_set(a1, *(const void **)(a2 + 8), *(_DWORD *)a2);
  if (result)
  {
    a1->type = *(_DWORD *)(a2 + 4);
    a1->int flags = *(void *)(a2 + 16) & 0xFFFFFFFFFFFFFFEFLL;
    return 1;
  }
  return result;
}

int ASN1_STRING_set(ASN1_STRING *str, const void *data, int len)
{
  unsigned int v3 = len;
  if (len == -1)
  {
    if (!data) {
      return 0;
    }
    size_t v8 = strlen((const char *)data);
    unsigned int v3 = v8;
    if (v8 >> 31) {
      return 0;
    }
  }
  ASN1_STRING_clear(&str->length);
  if (v3 > 0x7FFFFFFE) {
    return 0;
  }
  size_t v6 = (unsigned __int8 *)malloc_type_calloc(1uLL, v3 + 1, 0x7D32741AuLL);
  str->unsigned int data = v6;
  if (!v6)
  {
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_string.c", 180);
    return 0;
  }
  str->size_t length = v3;
  if (data)
  {
    memcpy(v6, data, v3);
    str->data[v3] = 0;
  }
  return 1;
}

ASN1_STRING *__cdecl ASN1_STRING_dup(ASN1_STRING *a)
{
  if (!a) {
    return 0;
  }
  uint64_t v2 = ASN1_STRING_type_new(4);
  unsigned int v3 = v2;
  if (v2 && !ASN1_STRING_copy(v2, (uint64_t)a))
  {
    ASN1_STRING_clear(&v3->length);
    free(v3);
    return 0;
  }
  return v3;
}

void ASN1_STRING_set0(ASN1_STRING *str, void *data, int len)
{
  str->unsigned int data = (unsigned __int8 *)data;
  str->size_t length = len;
}

int ASN1_STRING_length(ASN1_STRING *x)
{
  return x->length;
}

void ASN1_STRING_length_set(ASN1_STRING *x, int n)
{
  x->size_t length = n;
}

int ASN1_STRING_type(ASN1_STRING *x)
{
  return x->type;
}

unsigned __int8 *__cdecl ASN1_STRING_data(ASN1_STRING *x)
{
  return x->data;
}

uint64_t ASN1_STRING_get0_data(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

int ASN1_STRING_print(BIO *bp, ASN1_STRING *v)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (!v) {
    return 0;
  }
  int length = v->length;
  if (v->length < 1) {
    return 1;
  }
  uint64_t v5 = 0;
  int v6 = 0;
  size_t v7 = v->data;
  do
  {
    char v8 = v7[v5];
    if (v8 == 127)
    {
      char v8 = 46;
    }
    else
    {
      if (v8 == 10) {
        char v9 = 10;
      }
      else {
        char v9 = 46;
      }
      if (v8 == 13) {
        char v9 = 13;
      }
      if (v8 <= 31) {
        char v8 = v9;
      }
    }
    data[v6] = v8;
    if (v6 < 79)
    {
      ++v6;
    }
    else
    {
      if (BIO_write(bp, data, v6 + 1) < 1) {
        return 0;
      }
      int v6 = 0;
      int length = v->length;
    }
    ++v5;
  }
  while (v5 < length);
  return v6 < 1 || BIO_write(bp, data, v6) >= 1;
}

int ASN1_STRING_to_UTF8(unsigned __int8 **out, ASN1_STRING *in)
{
  outEVP_CIPHER_CTX a = 0;
  int length = -1;
  if (out)
  {
    if (in)
    {
      int v5 = asn1_tag2charwidth(in->type);
      if (v5 != -1)
      {
        int v6 = ASN1_mbstring_copy(&outa, in->data, in->length, v5 | 0x1000, 0x2000uLL);
        size_t v7 = outa;
        if ((v6 & 0x80000000) == 0)
        {
          unsigned __int8 *out = outa->data;
          int length = v7->length;
          v7->unsigned int data = 0;
          v7->int length = 0;
LABEL_7:
          ASN1_STRING_clear(&v7->length);
          free(v7);
          return length;
        }
        int length = v6;
        if (outa) {
          goto LABEL_7;
        }
      }
    }
  }
  return length;
}

int i2a_ASN1_STRING(BIO *bp, ASN1_STRING *a, int type)
{
  if (!a) {
    return 0;
  }
  if (a->length)
  {
    if (a->length >= 1)
    {
      uint64_t v5 = 0;
      int v6 = 0;
      while (1)
      {
        if (v5 && !(v5 % 0x23))
        {
          if (BIO_write(bp, "\\\n", 2) != 2) {
            return -1;
          }
          v6 += 2;
        }
        size_t v7 = a->data;
        data[0] = i2a_ASN1_STRING_h[(unint64_t)v7[v5] >> 4];
        data[1] = i2a_ASN1_STRING_h[v7[v5] & 0xF];
        if (BIO_write(bp, data, 2) != 2) {
          break;
        }
        v6 += 2;
        if (++v5 >= a->length) {
          return v6;
        }
      }
      return -1;
    }
    return 0;
  }
  int v6 = 1;
  if (BIO_write(bp, "0", 1) != 1) {
    return -1;
  }
  return v6;
}

int a2i_ASN1_STRING(BIO *bp, ASN1_STRING *bs, char *buf, int size)
{
  int v8 = BIO_gets(bp, buf, size);
  if (v8 < 1)
  {
    int v20 = 0;
    int v19 = 0;
    goto LABEL_36;
  }
  int v33 = bs;
  unint64_t v9 = 0;
  uint64_t v10 = 0;
  int v11 = 0;
  sizeEVP_CIPHER_CTX a = size;
  while (2)
  {
    uint64_t v12 = (v8 - 1);
    int v13 = v12;
    if (buf[v12] == 10)
    {
      buf[v12] = 0;
      if (v8 == 1) {
        goto LABEL_37;
      }
      uint64_t v12 = (v8 - 2);
      unsigned int v14 = v8 - 2;
    }
    else
    {
      unsigned int v14 = v8 - 1;
      int v13 = v8;
    }
    if (buf[v12] == 13)
    {
      buf[v12] = 0;
      if (v14)
      {
        uint64_t v12 = v14 - 1;
        unsigned int v15 = v14 - 1;
        goto LABEL_11;
      }
LABEL_37:
      int v20 = v11;
      goto LABEL_38;
    }
    unsigned int v15 = v14;
    unsigned int v14 = v13;
LABEL_11:
    int v16 = buf[v12];
    if (v16 == 92) {
      unsigned int v17 = v15;
    }
    else {
      unsigned int v17 = v14;
    }
    buf[v17] = 0;
    if (v17 < 2) {
      goto LABEL_37;
    }
    if (v17)
    {
      int v31 = 145;
      int v32 = 384;
      goto LABEL_40;
    }
    uint64_t v18 = v17 >> 1;
    int v19 = v10 + v18;
    if (v10 + v18 <= v9)
    {
      int v20 = v11;
    }
    else
    {
      int v20 = (unsigned __int8 *)malloc_type_realloc(v11, v10 + v18, 0xAA819642uLL);
      unint64_t v9 = v10 + v18;
      if (!v20)
      {
        int v31 = 65;
        int v32 = 391;
LABEL_40:
        ERR_put_error(13, 4095, v31, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_string.c", v32);
LABEL_34:
        free(v11);
        return 0;
      }
    }
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    while (2)
    {
      uint64_t v23 = 0;
      char v24 = 1;
      do
      {
        char v25 = v24;
        int v26 = buf[v23 | v22];
        char v27 = v26 - 48;
        if ((v26 - 48) >= 0xA)
        {
          if ((v26 - 97) > 5)
          {
            if ((v26 - 65) > 5)
            {
              int v28 = 141;
              int v29 = 407;
              goto LABEL_33;
            }
            char v27 = v26 - 55;
          }
          else
          {
            char v27 = v26 - 87;
          }
        }
        char v24 = 0;
        v20[v10 + v21] = v27 | (16 * v20[v10 + v21]);
        uint64_t v23 = 1;
      }
      while ((v25 & 1) != 0);
      ++v21;
      v22 += 2;
      if (v21 != v18) {
        continue;
      }
      break;
    }
    if (v16 == 92)
    {
      int v8 = BIO_gets(bp, buf, sizea);
      v10 += v18;
      int v11 = v20;
      if (v8 >= 1) {
        continue;
      }
LABEL_38:
      int v28 = 150;
      int v29 = 426;
LABEL_33:
      ERR_put_error(13, 4095, v28, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_string.c", v29);
      int v11 = v20;
      goto LABEL_34;
    }
    break;
  }
  bunsigned int s = v33;
LABEL_36:
  bs->int length = v19;
  bs->unsigned int data = v20;
  return 1;
}

DSA_SIG *__cdecl d2i_DSA_SIG(DSA_SIG **v, const unsigned __int8 **pp, uint64_t length)
{
  return (DSA_SIG *)ASN1_item_d2i((ASN1_VALUE **)v, pp, length, &DSA_SIG_it);
}

int i2d_DSA_SIG(const DSA_SIG *a, unsigned __int8 **pp)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, pp, &DSA_SIG_it);
}

void *DSA_SIG_get0(void *result, void *a2, void *a3)
{
  if (a2) {
    *a2 = *result;
  }
  if (a3) {
    *a3 = result[1];
  }
  return result;
}

uint64_t DSA_SIG_set0(BIGNUM **a1, BIGNUM *a2, BIGNUM *a3)
{
  uint64_t result = 0;
  if (a2)
  {
    if (a3)
    {
      BN_free(*a1);
      *a1 = a2;
      BN_free(a1[1]);
      a1[1] = a3;
      return 1;
    }
  }
  return result;
}

DSA *__cdecl d2i_DSAPrivateKey(DSA **a, const unsigned __int8 **pp, uint64_t length)
{
  return (DSA *)ASN1_item_d2i((ASN1_VALUE **)a, pp, length, &DSAPrivateKey_it);
}

int i2d_DSAPrivateKey(const DSA *a, unsigned __int8 **pp)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, pp, &DSAPrivateKey_it);
}

DSA *__cdecl d2i_DSAparams(DSA **a, const unsigned __int8 **pp, uint64_t length)
{
  return (DSA *)ASN1_item_d2i((ASN1_VALUE **)a, pp, length, &DSAparams_it);
}

int i2d_DSAparams(const DSA *a, unsigned __int8 **pp)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, pp, &DSAparams_it);
}

void *d2i_DSAparams_bio(BIO *in, void *x)
{
  return ASN1_item_d2i_bio(&DSAparams_it, in, x);
}

uint64_t i2d_DSAparams_bio(BIO *out, void *x)
{
  return ASN1_item_i2d_bio(&DSAparams_it, out, x);
}

void *d2i_DSAparams_fp(FILE *in, void *x)
{
  return ASN1_item_d2i_fp(&DSAparams_it, in, x);
}

uint64_t i2d_DSAparams_fp(FILE *out, void *x)
{
  return ASN1_item_i2d_fp(&DSAparams_it, out, x);
}

DSA *__cdecl d2i_DSAPublicKey(DSA **a, const unsigned __int8 **pp, uint64_t length)
{
  return (DSA *)ASN1_item_d2i((ASN1_VALUE **)a, pp, length, &DSAPublicKey_it);
}

int i2d_DSAPublicKey(const DSA *a, unsigned __int8 **pp)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, pp, &DSAPublicKey_it);
}

void *DSAparams_dup(void *x)
{
  return ASN1_item_dup(&DSAparams_it, x);
}

int DSA_sign(int type, const unsigned __int8 *dgst, int dlen, unsigned __int8 *sig, unsigned int *siglen, DSA *dsa)
{
  unsigned __int8 out = sig;
  *sigint len = 0;
  size_t v7 = (ASN1_VALUE *)DSA_do_sign(dgst, dlen, dsa);
  int v8 = (DSA_SIG *)v7;
  if (!v7 || (unsigned int v9 = ASN1_item_i2d(v7, &out, &DSA_SIG_it), (v9 & 0x80000000) != 0))
  {
    int v10 = 0;
  }
  else
  {
    *sigint len = v9;
    int v10 = 1;
  }
  DSA_SIG_free(v8);
  return v10;
}

int DSA_verify(int type, const unsigned __int8 *dgst, int dgst_len, const unsigned __int8 *sigbuf, int siglen, DSA *dsa)
{
  uint64_t v18 = sigbuf;
  unsigned __int8 out = 0;
  size_t v11 = siglen;
  uint64_t v12 = ASN1_item_d2i(0, &v18, siglen, &DSA_SIG_it);
  int v13 = (DSA_SIG *)v12;
  if (!v12)
  {
    unsigned int v15 = 0;
LABEL_6:
    int v16 = -1;
    goto LABEL_7;
  }
  int v14 = ASN1_item_i2d(v12, &out, &DSA_SIG_it);
  unsigned int v15 = out;
  if (v14 != siglen || memcmp(out, sigbuf, v11)) {
    goto LABEL_6;
  }
  int v16 = DSA_do_verify(dgst, dgst_len, v13, dsa);
  unsigned int v15 = out;
LABEL_7:
  free(v15);
  DSA_SIG_free(v13);
  return v16;
}

uint64_t sig_cb(int a1, DSA_SIG **a2)
{
  if (a1) {
    return 1;
  }
  char v4 = DSA_SIG_new();
  if (v4)
  {
    *a2 = v4;
    return 2;
  }
  else
  {
    ERR_put_error(10, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_asn1.c", 78);
    return 0;
  }
}

uint64_t dsa_cb(int a1, DSA **a2)
{
  if (a1 == 2)
  {
    DSA_free(*a2);
    *a2 = 0;
    return 2;
  }
  else if (a1)
  {
    return 1;
  }
  else
  {
    unsigned int v3 = DSA_new();
    *a2 = v3;
    return 2 * (v3 != 0);
  }
}

const ERR_FNS *ERR_get_implementation(void)
{
  return (const ERR_FNS *)err_fns;
}

void err_fns_check()
{
  if (!err_fns)
  {
    CRYPTO_lock(9, 1, 0, 0);
    if (!err_fns) {
      err_fnunsigned int s = (uint64_t)err_defaults;
    }
    CRYPTO_lock(10, 1, 0, 0);
  }
}

int ERR_set_implementation(const ERR_FNS *fns)
{
  CRYPTO_lock(9, 1, 0, 0);
  int v2 = 0;
  if (!err_fns)
  {
    err_fnunsigned int s = (uint64_t)fns;
    int v2 = 1;
  }
  CRYPTO_lock(10, 1, 0, 0);
  return v2;
}

void ERR_load_ERR_strings_internal()
{
  err_init_threauint64_t d = (uint64_t)pthread_self();
  err_fns_check();
  if (ERR_str_libraries)
  {
    int v0 = &ERR_str_libraries;
    do
    {
      (*(void (**)(uint64_t *))(err_fns + 24))(v0);
      uint64_t v1 = v0[2];
      v0 += 2;
    }
    while (v1);
  }
  if (ERR_str_reasons)
  {
    int v2 = &ERR_str_reasons;
    do
    {
      (*(void (**)(uint64_t *))(err_fns + 24))(v2);
      uint64_t v3 = v2[2];
      v2 += 2;
    }
    while (v3);
  }
  uint64_t v4 = ERR_str_functs;
  if (ERR_str_functs)
  {
    uint64_t v5 = &ERR_str_functs;
    do
    {
      uint64_t *v5 = v4 | 0x2000000;
      (*(void (**)(uint64_t *))(err_fns + 24))(v5);
      uint64_t v6 = v5[2];
      v5 += 2;
      uint64_t v4 = v6;
    }
    while (v6);
  }
  CRYPTO_lock(5, 1, 0, 0);
  char v7 = build_SYS_str_reasons_init;
  CRYPTO_lock(6, 1, 0, 0);
  if (v7) {
    goto LABEL_22;
  }
  CRYPTO_lock(9, 1, 0, 0);
  if (build_SYS_str_reasons_init) {
    goto LABEL_21;
  }
  int v8 = (char *)&build_SYS_str_reasons_strerror_tab;
  int v9 = *__error();
  int v10 = &qword_268BB4920;
  for (uint64_t i = 1; i != 128; ++i)
  {
    *(v10 - md5_block_data_order((unint64_t)c, b, 1) = i;
    if (*v10) {
      goto LABEL_18;
    }
    uint64_t v12 = strerror(i);
    if (v12)
    {
      strlcpy(v8, v12, 0x20uLL);
      int v13 = v8;
LABEL_16:
      *int v10 = (uint64_t)v13;
      goto LABEL_18;
    }
    if (!*v10)
    {
      int v13 = "unknown";
      goto LABEL_16;
    }
LABEL_18:
    v8 += 32;
    v10 += 2;
  }
  *__error() = v9;
  build_SYS_str_reasons_init = 1;
LABEL_21:
  CRYPTO_lock(10, 1, 0, 0);
LABEL_22:
  uint64_t v14 = SYS_str_reasons;
  if (SYS_str_reasons)
  {
    unsigned int v15 = &SYS_str_reasons;
    do
    {
      uint64_t *v15 = v14 | 0x2000000;
      (*(void (**)(uint64_t *))(err_fns + 24))(v15);
      uint64_t v16 = v15[2];
      v15 += 2;
      uint64_t v14 = v16;
    }
    while (v16);
  }
}

void ERR_load_ERR_strings(void)
{
  int v0 = pthread_self();
  if (!pthread_equal(v0, (pthread_t)err_init_thread))
  {
    OPENSSL_init_crypto(0, 0);
    pthread_once(&ERR_load_ERR_strings_once, ERR_load_ERR_strings_internal);
  }
}

void ERR_load_strings(int lib, ERR_STRING_DATA str[])
{
  ERR_load_ERR_strings();
  unint64_t error = str->error;
  if (str->error)
  {
    do
    {
      if (lib) {
        str->unint64_t error = error | (lib << 24);
      }
      (*(void (**)(ERR_STRING_DATA *__attribute__((__org_arrdim(0,0)))))(err_fns + 24))(str);
      unint64_t v5 = str[1].error;
      ++str;
      unint64_t error = v5;
    }
    while (v5);
  }
}

void ERR_unload_strings(int lib, ERR_STRING_DATA str[])
{
  OPENSSL_init_crypto(0);
  unint64_t error = str->error;
  if (str->error)
  {
    do
    {
      if (lib) {
        str->unint64_t error = error | (lib << 24);
      }
      (*(void (**)(ERR_STRING_DATA *__attribute__((__org_arrdim(0,0)))))(err_fns + 32))(str);
      unint64_t v5 = str[1].error;
      ++str;
      unint64_t error = v5;
    }
    while (v5);
  }
}

void ERR_free_strings(void)
{
  OPENSSL_init_crypto(0);
  err_fns_check();
  int v0 = *(void (**)(void))(err_fns + 8);
  v0();
}

void ERR_put_error(int lib, int func, int reason, const char *file, int line)
{
  __int16 v7 = reason;
  __int16 v8 = func;
  int v10 = *__error();
  state = ERR_get_state();
  uint64_t v12 = state;
  int v13 = LODWORD(state[1].pid) + 1;
  BOOL v14 = -v13 < 0;
  int v15 = -v13 & 0xF;
  int v16 = v13 & 0xF;
  if (v14) {
    int v17 = v16;
  }
  else {
    int v17 = -v15;
  }
  LODWORD(state[1].pid) = v17;
  if (v17 == HIDWORD(state[1].pid)) {
    HIDWORD(state[1].pid) = (char)(v17 + 1 - ((v17 + 1 + (((char)(v17 + 1) >> 11) & 0xF)) & 0xF0));
  }
  uint64_t pid_low = v17;
  int v19 = (char *)state + 4 * v17;
  *((_DWORD *)v19 + 4) = 0;
  int v20 = &state->pid + v17;
  v20[10] = (lib << 24) | ((v8 & 0xFFF) << 12) | v7 & 0xFFFu;
  v20[50] = (unint64_t)file;
  *((_DWORD *)v19 + 132) = line;
  uint64_t v21 = (void *)v20[26];
  if (v21 && (v12->err_data_flags[pid_low + 2] & 1) != 0)
  {
    free(v21);
    uint64_t pid_low = SLODWORD(v12[1].pid);
    v12->err_data[pid_low + 1] = 0;
  }
  v12->err_data_flags[pid_low + 2] = 0;
  *__error() = v10;
}

ERR_STATE *ERR_get_state(void)
{
  memset(v6, 0, 512);
  __n128 v5 = 0uLL;
  err_fns_check();
  CRYPTO_THREADID_current(&v5);
  __n128 v0 = CRYPTO_THREADID_cpy(v6, &v5);
  uint64_t v1 = (ERR_STATE *)(*(uint64_t (**)(__n128 *, __n128))(err_fns + 56))(v6, v0);
  if (!v1)
  {
    int v2 = (__n128 *)malloc_type_malloc(0x258uLL, 0x10D004035475690uLL);
    if (v2)
    {
      uint64_t v1 = (ERR_STATE *)v2;
      CRYPTO_THREADID_cpy(v2, &v5);
      v1[1].piuint64_t d = 0;
      *(_OWORD *)&v1->err_data[1] = 0u;
      *(_OWORD *)&v1->err_data[3] = 0u;
      *(_OWORD *)&v1->err_data[5] = 0u;
      *(_OWORD *)&v1->err_data[7] = 0u;
      *(_OWORD *)&v1->err_data[9] = 0u;
      *(_OWORD *)&v1->err_data[11] = 0u;
      *(_OWORD *)&v1->err_data[13] = 0u;
      *(_OWORD *)&v1->err_data[15] = 0u;
      *(_OWORD *)&v1->err_data_flags[2] = 0u;
      *(_OWORD *)&v1->err_data_flags[6] = 0u;
      *(_OWORD *)&v1->err_data_flags[10] = 0u;
      *(_OWORD *)&v1->err_data_flags[14] = 0u;
      uint64_t v3 = (ERR_STATE *)(*(uint64_t (**)(ERR_STATE *))(err_fns + 64))(v1);
      if ((ERR_STATE *)(*(uint64_t (**)(ERR_STATE *))(err_fns + 56))(v1) != v1)
      {
        uint64_t v3 = v1;
        uint64_t v1 = (ERR_STATE *)&ERR_get_state_fallback;
LABEL_7:
        ERR_STATE_free(v3);
        return v1;
      }
      if (v3) {
        goto LABEL_7;
      }
    }
    else
    {
      return (ERR_STATE *)&ERR_get_state_fallback;
    }
  }
  return v1;
}

void ERR_clear_error(void)
{
  state = ERR_get_state();
  uint64_t v1 = 0;
  int v2 = state;
  do
  {
    v2->err_flags[2] = 0;
    uint64_t v3 = (char *)state + v1 * 8;
    state->err_buffer[v1 + 1] = 0;
    uint64_t v4 = state->err_data[v1 + 1];
    if (v4 && (v2->err_data_flags[2] & 1) != 0)
    {
      free(v4);
      *((void *)v3 + 26) = 0;
    }
    v2->err_data_flags[2] = 0;
    *((void *)v3 + 5X509_check_purpose(x, -1, 0) = 0;
    v2->err_line[2] = -1;
    int v2 = (ERR_STATE *)((char *)v2 + 4);
    ++v1;
  }
  while (v1 != 16);
  state[1].piuint64_t d = 0;
}

unint64_t ERR_get_error(void)
{
  return get_error_values(1, 0, 0, 0, 0, 0);
}

uint64_t get_error_values(int a1, int a2, const char **a3, _DWORD *a4, char **a5, _DWORD *a6)
{
  state = ERR_get_state();
  int v13 = state;
  if (a1 && a2)
  {
    if (a3) {
      *a3 = "";
    }
    if (a4) {
      *a4 = 0;
    }
    if (a5) {
      *a5 = "";
    }
    if (a6) {
      *a6 = 0;
    }
    return 68;
  }
  else
  {
    int pid_high = HIDWORD(state[1].pid);
    piuint64_t d = state[1].pid;
    if (pid_high == pid)
    {
      return 0;
    }
    else
    {
      int v18 = pid_high + 1;
      BOOL v19 = -v18 < 0;
      int v20 = -v18 & 0xF;
      int v21 = v18 & 0xF;
      if (!v19) {
        int v21 = -v20;
      }
      if (!a2) {
        piuint64_t d = v21;
      }
      uint64_t v22 = &state->pid + pid;
      unint64_t v24 = v22[10];
      uint64_t v23 = v22 + 10;
      unint64_t v14 = v24;
      if (a1)
      {
        HIDWORD(state[1].pid) = pid;
        void *v23 = 0;
      }
      uint64_t v25 = pid;
      if (a3 && a4)
      {
        int v26 = state->err_file[pid + 1];
        if (v26)
        {
          *a3 = v26;
          LODWORD(v26) = state->err_line[v25 + 2];
        }
        else
        {
          *a3 = "NA";
        }
        *a4 = v26;
      }
      if (a5)
      {
        char v27 = state->err_data[v25 + 1];
        if (v27)
        {
          *a5 = v27;
          if (a6) {
            *a6 = state->err_data_flags[v25 + 2];
          }
        }
        else
        {
          *a5 = "";
          if (a6) {
            *a6 = 0;
          }
        }
      }
      else if (a1)
      {
        int v28 = &state->pid + v25;
        int v31 = (void *)v28[26];
        uint64_t v30 = v28 + 26;
        int v29 = v31;
        if (v31 && (v13->err_data_flags[v25 + 2] & 1) != 0)
        {
          free(v29);
          void *v30 = 0;
        }
        v13->err_data_flags[v25 + 2] = 0;
      }
    }
  }
  return v14;
}

unint64_t ERR_get_error_line(const char **file, int *line)
{
  return get_error_values(1, 0, file, line, 0, 0);
}

unint64_t ERR_get_error_line_data(const char **file, int *line, const char **data, int *flags)
{
  return get_error_values(1, 0, file, line, (char **)data, flags);
}

unint64_t ERR_peek_error(void)
{
  state = ERR_get_state();
  int pid_high = HIDWORD(state[1].pid);
  if (pid_high == LODWORD(state[1].pid)) {
    return 0;
  }
  int v3 = pid_high + 1;
  BOOL v4 = -v3 < 0;
  int v5 = -v3 & 0xF;
  int v6 = v3 & 0xF;
  if (!v4) {
    int v6 = -v5;
  }
  return state->err_buffer[v6 + 1];
}

unint64_t ERR_peek_error_line(const char **file, int *line)
{
  return get_error_values(0, 0, file, line, 0, 0);
}

unint64_t ERR_peek_error_line_data(const char **file, int *line, const char **data, int *flags)
{
  return get_error_values(0, 0, file, line, (char **)data, flags);
}

unint64_t ERR_peek_last_error(void)
{
  state = ERR_get_state();
  uint64_t pid_low = SLODWORD(state[1].pid);
  if (HIDWORD(state[1].pid) == pid_low) {
    return 0;
  }
  else {
    return state->err_buffer[pid_low + 1];
  }
}

unint64_t ERR_peek_last_error_line(const char **file, int *line)
{
  return get_error_values(0, 1, file, line, 0, 0);
}

unint64_t ERR_peek_last_error_line_data(const char **file, int *line, const char **data, int *flags)
{
  return get_error_values(0, 1, file, line, (char **)data, flags);
}

void ERR_error_string_n(unint64_t e, char *buf, size_t len)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  int v6 = ERR_lib_error_string(e);
  __int16 v7 = ERR_func_error_string(e);
  __int16 v8 = ERR_reason_error_string(e);
  if (v6)
  {
    if (v7) {
      goto LABEL_3;
    }
LABEL_14:
    __int16 v7 = v15;
    snprintf(v15, 0x1EuLL, "func(%d)", (e >> 12) & 0xFFF);
    if (v8) {
      goto LABEL_4;
    }
LABEL_15:
    __int16 v8 = v14;
    snprintf(v14, 0x1EuLL, "reason(%d)", e & 0xFFF);
    goto LABEL_4;
  }
  int v6 = __str;
  snprintf(__str, 0x1EuLL, "lib(%d)", BYTE3(e));
  if (!v7) {
    goto LABEL_14;
  }
LABEL_3:
  if (!v8) {
    goto LABEL_15;
  }
LABEL_4:
  int v9 = snprintf(buf, len, "error:%08lX:%s:%s:%s", e, v6, v7, v8);
  if (v9 != -1 && len >= 5 && v9 >= len)
  {
    int v10 = &buf[len];
    for (uint64_t i = -5; i != -1; ++i)
    {
      uint64_t v12 = strchr(buf, 58);
      int v13 = &v10[i];
      if (!v12 || v12 > v13)
      {
        char *v13 = 58;
        uint64_t v12 = &v10[i];
      }
      buf = v12 + 1;
    }
  }
}

const char *__cdecl ERR_lib_error_string(unint64_t e)
{
  int v1 = e;
  if (!OPENSSL_init_crypto(0, 0)) {
    return 0;
  }
  v3[1] = 0;
  err_fns_check();
  v3[0] = v1 & 0xFF000000;
  uint64_t result = (const char *)(*(uint64_t (**)(void *))(err_fns + 16))(v3);
  if (result) {
    return (const char *)*((void *)result + 1);
  }
  return result;
}

const char *__cdecl ERR_func_error_string(unint64_t e)
{
  int v1 = e;
  v3[1] = 0;
  err_fns_check();
  v3[0] = v1 & 0xFFFFF000;
  uint64_t result = (const char *)(*(uint64_t (**)(void *))(err_fns + 16))(v3);
  if (result) {
    return (const char *)*((void *)result + 1);
  }
  return result;
}

const char *__cdecl ERR_reason_error_string(unint64_t e)
{
  int v1 = e;
  v3[1] = 0;
  err_fns_check();
  v3[0] = v1 & 0xFF000FFF;
  uint64_t result = (const char *)(*(uint64_t (**)(void *))(err_fns + 16))(v3);
  if (result) {
    return (const char *)*((void *)result + 1);
  }
  v3[0] = v1 & 0xFFF;
  uint64_t result = (const char *)(*(uint64_t (**)(void *))(err_fns + 16))(v3);
  if (result) {
    return (const char *)*((void *)result + 1);
  }
  return result;
}

char *__cdecl ERR_error_string(unint64_t e, char *buf)
{
  if (buf) {
    int v2 = buf;
  }
  else {
    int v2 = (char *)&ERR_error_string_buf;
  }
  ERR_error_string_n(e, v2, 0x100uLL);
  return v2;
}

LHASH *ERR_get_string_table(void)
{
  err_fns_check();
  __n128 v0 = *(uint64_t (**)(void))err_fns;
  return (LHASH *)v0(0);
}

LHASH *ERR_get_err_state_table(void)
{
  err_fns_check();
  __n128 v0 = *(uint64_t (**)(void))(err_fns + 40);
  return (LHASH *)v0(0);
}

void ERR_release_err_state_table(LHASH **hash)
{
  err_fns_check();
  int v2 = *(void (**)(LHASH **))(err_fns + 48);
  v2(hash);
}

uint64_t ERR_remove_thread_state(__n128 *a1)
{
  memset(v2, 0, 512);
  if (a1) {
    CRYPTO_THREADID_cpy(v2, a1);
  }
  else {
    CRYPTO_THREADID_current(v2);
  }
  err_fns_check();
  return (*(uint64_t (**)(__n128 *))(err_fns + 72))(v2);
}

void ERR_remove_state(unint64_t pid)
{
  memset(v1, 0, 512);
  CRYPTO_THREADID_current(v1);
  err_fns_check();
  (*(void (**)(_OWORD *))(err_fns + 72))(v1);
}

void ERR_STATE_free(unsigned char *a1)
{
  for (uint64_t i = 0; i != 16; ++i)
  {
    int v3 = &a1[8 * i];
    BOOL v4 = (void *)*((void *)v3 + 26);
    if (v4 && (a1[4 * i + 336] & 1) != 0)
    {
      free(v4);
      *((void *)v3 + 26) = 0;
    }
    *(_DWORD *)&a1[4 * i + 336] = 0;
  }
  free(a1);
}

int ERR_get_next_error_library(void)
{
  err_fns_check();
  __n128 v0 = *(uint64_t (**)(void))(err_fns + 80);
  return v0();
}

void ERR_set_error_data(char *data, int flags)
{
  state = ERR_get_state();
  int v5 = state;
  piuint64_t d = state[1].pid;
  if (!pid) {
    piuint64_t d = 15;
  }
  uint64_t v7 = pid;
  __int16 v8 = &state->pid + pid;
  size_t v11 = (void *)v8[26];
  int v10 = (char **)(v8 + 26);
  int v9 = v11;
  if (v11 && (v5->err_data_flags[pid + 2] & 1) != 0) {
    free(v9);
  }
  *int v10 = data;
  v5->err_data_flags[v7 + 2] = flags;
}

void ERR_asprintf_error_data(char *a1, ...)
{
  va_start(va, a1);
  int v3 = 0;
  if (vasprintf(&v3, a1, va) == -1)
  {
    int v1 = "malloc failed";
    int v2 = 2;
  }
  else
  {
    int v1 = v3;
    int v2 = 3;
  }
  ERR_set_error_data(v1, v2);
}

void ERR_add_error_vdata(int a1, va_list a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  int v6 = 0;
  v7[0] = 0;
  if (a1 >= 1)
  {
    int v3 = a1;
    while ((unint64_t)__strlcat_chk() < 0x81)
    {
      if (!--v3) {
        goto LABEL_5;
      }
    }
    BOOL v4 = "too many errors";
    goto LABEL_9;
  }
LABEL_5:
  if (vasprintf(&v6, v7, a2) == -1)
  {
    BOOL v4 = "malloc failed";
LABEL_9:
    int v5 = 2;
    goto LABEL_10;
  }
  BOOL v4 = v6;
  int v5 = 3;
LABEL_10:
  ERR_set_error_data(v4, v5);
}

void ERR_add_error_data(int num, ...)
{
  va_start(va, num);
  ERR_add_error_vdata(num, va);
}

int ERR_set_mark(void)
{
  state = ERR_get_state();
  uint64_t pid_low = SLODWORD(state[1].pid);
  if (HIDWORD(state[1].pid) == pid_low) {
    return 0;
  }
  state->err_flags[pid_low + 2] |= 1u;
  return 1;
}

int ERR_pop_to_mark(void)
{
  state = ERR_get_state();
  piuint64_t d = state[1].pid;
  if (HIDWORD(state[1].pid) == pid) {
    return 0;
  }
  int v2 = state;
  while (1)
  {
    int v3 = (char *)v2 + 4 * pid;
    int v6 = *((_DWORD *)v3 + 4);
    BOOL v4 = (unsigned int *)(v3 + 16);
    int v5 = v6;
    if (v6) {
      break;
    }
    unsigned int *v4 = 0;
    uint64_t pid_low = SLODWORD(v2[1].pid);
    uint64_t v8 = &v2->pid + pid_low;
    v8[10] = 0;
    int v9 = (void *)v8[26];
    if (v9 && (v2->err_data_flags[pid_low + 2] & 1) != 0)
    {
      free(v9);
      uint64_t pid_low = SLODWORD(v2[1].pid);
      v2->err_data[pid_low + 1] = 0;
    }
    v2->err_data_flags[pid_low + 2] = 0;
    uint64_t v10 = SLODWORD(v2[1].pid);
    v2->err_file[v10 + 1] = 0;
    v2->err_line[v10 + 2] = -1;
    int v11 = v2[1].pid;
    if (v11) {
      piuint64_t d = v11 - 1;
    }
    else {
      piuint64_t d = 15;
    }
    LODWORD(v2[1].pid) = pid;
    if (HIDWORD(v2[1].pid) == pid) {
      return 0;
    }
  }
  unsigned int *v4 = v5 & 0xFFFFFFFE;
  return 1;
}

ERR_STATE *err_clear_last_constant_time(int a1)
{
  uint64_t result = ERR_get_state();
  if (result)
  {
    uint64_t pid_low = SLODWORD(result[1].pid);
    BOOL v4 = (char *)result + 4 * pid_low;
    *((_DWORD *)v4 + 4) &= a1 - 1;
    uint64_t v5 = a1 - 1;
    int v6 = &result->pid + pid_low;
    v6[10] &= v5;
    v6[50] &= v5;
    *((_DWORD *)v4 + 132) |= -a1;
    int v7 = pid_low - a1 + 16;
    int v8 = v7 & 0xF;
    int v10 = -v7;
    BOOL v9 = v10 < 0;
    int v11 = v10 & 0xF;
    if (v9) {
      int v12 = v8;
    }
    else {
      int v12 = -v11;
    }
    LODWORD(result[1].pid) = v12;
  }
  return result;
}

uint64_t int_err_get(int a1)
{
  CRYPTO_lock(9, 1, 0, 0);
  uint64_t v2 = int_error_hash;
  if (a1 && !int_error_hash)
  {
    CRYPTO_push_info_("int_err_get (err.c)", 0, 0);
    int_error_hash = (uint64_t)lh_new((LHASH_HASH_FN_TYPE)err_string_data_LHASH_HASH, (LHASH_COMP_FN_TYPE)err_string_data_LHASH_COMP);
    CRYPTO_pop_info();
    uint64_t v2 = int_error_hash;
  }
  CRYPTO_lock(10, 1, 0, 0);
  return v2;
}

void int_err_del()
{
  CRYPTO_lock(9, 1, 0, 0);
  if (int_error_hash)
  {
    lh_free((LHASH *)int_error_hash);
    int_error_hash = 0;
  }
  CRYPTO_lock(10, 1, 0, 0);
}

uint64_t int_err_get_item(const void *a1)
{
  err_fns_check();
  uint64_t result = (*(uint64_t (**)(void))err_fns)(0);
  if (result)
  {
    int v3 = (LHASH *)result;
    CRYPTO_lock(5, 1, 0, 0);
    BOOL v4 = lh_retrieve(v3, a1);
    CRYPTO_lock(6, 1, 0, 0);
    return (uint64_t)v4;
  }
  return result;
}

uint64_t int_err_set_item(void *a1)
{
  err_fns_check();
  uint64_t result = (*(uint64_t (**)(uint64_t))err_fns)(1);
  if (result)
  {
    int v3 = (LHASH *)result;
    CRYPTO_lock(9, 1, 0, 0);
    BOOL v4 = lh_insert(v3, a1);
    CRYPTO_lock(10, 1, 0, 0);
    return (uint64_t)v4;
  }
  return result;
}

uint64_t int_err_del_item(const void *a1)
{
  err_fns_check();
  uint64_t result = (*(uint64_t (**)(void))err_fns)(0);
  if (result)
  {
    int v3 = (LHASH *)result;
    CRYPTO_lock(9, 1, 0, 0);
    BOOL v4 = lh_delete(v3, a1);
    CRYPTO_lock(10, 1, 0, 0);
    return (uint64_t)v4;
  }
  return result;
}

uint64_t int_thread_get(int a1)
{
  CRYPTO_lock(9, 1, 0, 0);
  uint64_t v2 = int_thread_hash;
  if (a1 && !int_thread_hash)
  {
    CRYPTO_push_info_("int_thread_get (err.c)", 0, 0);
    int_thread_hash = (uint64_t)lh_new((LHASH_HASH_FN_TYPE)err_state_LHASH_HASH, (LHASH_COMP_FN_TYPE)err_state_LHASH_COMP);
    CRYPTO_pop_info();
    uint64_t v2 = int_thread_hash;
  }
  if (v2) {
    ++int_thread_hash_references;
  }
  CRYPTO_lock(10, 1, 0, 0);
  return v2;
}

void *int_thread_release(void *result)
{
  if (result)
  {
    int v1 = result;
    if (*result)
    {
      uint64_t result = (void *)CRYPTO_add_lock(&int_thread_hash_references, -1, 1, 0, 0);
      if ((int)result <= 0) {
        *int v1 = 0;
      }
    }
  }
  return result;
}

uint64_t int_thread_get_item(const void *a1)
{
  err_fns_check();
  uint64_t result = (*(uint64_t (**)(void))(err_fns + 40))(0);
  uint64_t v5 = result;
  if (result)
  {
    int v3 = (LHASH *)result;
    CRYPTO_lock(5, 1, 0, 0);
    BOOL v4 = lh_retrieve(v3, a1);
    CRYPTO_lock(6, 1, 0, 0);
    (*(void (**)(uint64_t *))(err_fns + 48))(&v5);
    return (uint64_t)v4;
  }
  return result;
}

uint64_t int_thread_set_item(void *a1)
{
  err_fns_check();
  uint64_t result = (*(uint64_t (**)(uint64_t))(err_fns + 40))(1);
  uint64_t v5 = result;
  if (result)
  {
    int v3 = (LHASH *)result;
    CRYPTO_lock(9, 1, 0, 0);
    BOOL v4 = lh_insert(v3, a1);
    CRYPTO_lock(10, 1, 0, 0);
    (*(void (**)(uint64_t *))(err_fns + 48))(&v5);
    return (uint64_t)v4;
  }
  return result;
}

void int_thread_del_item(const void *a1)
{
  err_fns_check();
  uint64_t v2 = (*(uint64_t (**)(void))(err_fns + 40))(0);
  uint64_t v6 = v2;
  if (v2)
  {
    int v3 = (LHASH *)v2;
    CRYPTO_lock(9, 1, 0, 0);
    BOOL v4 = lh_delete(v3, a1);
    BOOL v5 = int_thread_hash_references != 1 || int_thread_hash == 0;
    if (!v5 && !lh_num_items((const LHASH *)int_thread_hash))
    {
      lh_free((LHASH *)int_thread_hash);
      int_thread_hash = 0;
    }
    CRYPTO_lock(10, 1, 0, 0);
    (*(void (**)(uint64_t *))(err_fns + 48))(&v6);
    if (v4) {
      ERR_STATE_free(v4);
    }
  }
}

uint64_t int_err_get_next_lib()
{
  CRYPTO_lock(9, 1, 0, 0);
  uint64_t v0 = int_err_library_number++;
  CRYPTO_lock(10, 1, 0, 0);
  return v0;
}

unint64_t err_string_data_LHASH_HASH(void *a1)
{
  unint64_t v1 = BYTE3(*a1) ^ (*a1 >> 12) & 0xFFFLL ^ *a1;
  return (13 * (v1 % 0x13)) ^ v1;
}

uint64_t err_string_data_LHASH_COMP(_DWORD *a1, _DWORD *a2)
{
  return (*a1 - *a2);
}

uint64_t err_state_LHASH_HASH(uint64_t a1)
{
  return 13 * CRYPTO_THREADID_hash(a1);
}

int BN_GENCB_call(BN_GENCB *cb, int a, int b)
{
  if (!cb) {
    return 1;
  }
  if (cb->ver == 2)
  {
    cb_1 = cb->cb.cb_1;
    return ((uint64_t (*)(void, void, BN_GENCB *))cb_1)(*(void *)&a, *(void *)&b, cb);
  }
  else
  {
    if (cb->ver == 1)
    {
      int v3 = cb->cb.cb_1;
      if (v3) {
        ((void (*)(void, void, void *))v3)(*(void *)&a, *(void *)&b, cb->arg);
      }
      return 1;
    }
    return 0;
  }
}

int BN_generate_prime_ex(BIGNUM *ret, int bits, int safe, const BIGNUM *add, const BIGNUM *rem, BN_GENCB *cb)
{
  uint64_t v6 = MEMORY[0x270FA5388](ret);
  uint64_t v51 = *MEMORY[0x263EF8340];
  if (v7 < 2 || (int v12 = v11, v13 = v10, v14 = v9, v15 = v8, v16 = v7, v17 = (BIGNUM *)v6, v7 == 2) && v8)
  {
    ERR_put_error(3, 4095, 117, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_prime.c", 169);
    return 0;
  }
  v50[0] = 0;
  BOOL v19 = BN_CTX_new();
  int v20 = v19;
  if (v19)
  {
    BN_CTX_start(v19);
    int v21 = BN_CTX_get(v20);
    if (v21)
    {
      uint64_t v22 = v21;
      EVP_CIPHER_CTX a = v13;
      int v23 = 0;
      int v47 = v12;
      int v46 = v15;
      int v45 = v21;
LABEL_8:
      int b = v23;
      if (!v14)
      {
        if (BN_rand(v17, v16, 1, 1))
        {
          uint64_t v30 = 1;
LABEL_23:
          while (1)
          {
            unint64_t v31 = BN_mod_word(v17, (unsigned __int16)primes[v30]);
            if (v31 == -1) {
              break;
            }
            *(void *)&v50[2 * v30++ + 1] = v31;
            if (v30 == 2048)
            {
              unint64_t v32 = 0;
              int v33 = b;
LABEL_26:
              for (uint64_t i = 1; i != 2048; ++i)
              {
                if ((*(void *)&v50[2 * i + 1] + v32) % (unsigned __int16)primes[i] <= 1)
                {
                  v32 += 2;
                  if (v32 <= 0xFFFFFFFFFFFFBA38) {
                    goto LABEL_26;
                  }
                  uint64_t v30 = 1;
                  if (BN_rand(v17, v16, 1, 1)) {
                    goto LABEL_23;
                  }
                  goto LABEL_80;
                }
              }
              if (!BN_add_word(v17, v32)) {
                goto LABEL_80;
              }
LABEL_68:
              if (!BN_GENCB_call(v12, 0, v33)) {
                goto LABEL_80;
              }
              int v23 = v33 + 1;
              int is_prime_bpsw = bn_is_prime_bpsw(v50, v17, v20, 1);
              if (!v15)
              {
                if (!is_prime_bpsw) {
                  goto LABEL_80;
                }
                if (v50[0]) {
                  goto LABEL_84;
                }
                goto LABEL_8;
              }
              if (!is_prime_bpsw) {
                goto LABEL_80;
              }
              if (!v50[0]) {
                goto LABEL_8;
              }
              if (BN_rshift1(v22, v17) && bn_is_prime_bpsw(v50, v22, v20, 1))
              {
                if (!v50[0]) {
                  goto LABEL_8;
                }
                if (BN_GENCB_call(v12, 2, b))
                {
LABEL_84:
                  int v18 = 1;
                  goto LABEL_81;
                }
              }
              goto LABEL_80;
            }
          }
        }
        goto LABEL_80;
      }
      BN_CTX_start(v20);
      unint64_t v24 = BN_CTX_get(v20);
      uint64_t v25 = v24;
      if (v15)
      {
        if (!v24) {
          goto LABEL_79;
        }
        int v26 = BN_CTX_get(v20);
        if (!v26) {
          goto LABEL_79;
        }
        char v27 = v26;
        int v28 = BN_CTX_get(v20);
        if (!v28) {
          goto LABEL_79;
        }
        int v29 = v28;
        if (!BN_rshift1(v28, v14)
          || !BN_rand(v27, v16 - 1, 0, 1)
          || !BN_mod_ct(v25, v27, v29, v20)
          || !BN_sub(v27, v27, v25))
        {
          goto LABEL_79;
        }
        if (a)
        {
          if (!BN_rshift1(v25, a) || !BN_add(v27, v27, v25)) {
            goto LABEL_79;
          }
LABEL_43:
          if (BN_lshift1(v17, v27) && BN_add_word(v17, 1uLL))
          {
            uint64_t v35 = 1;
            while (1)
            {
              unint64_t v36 = (unsigned __int16)primes[v35];
              unint64_t v37 = BN_mod_word(v17, v36);
              unint64_t v38 = BN_mod_word(v27, v36);
              if (v37 == -1 || v38 == -1) {
                break;
              }
              if (v37) {
                BOOL v40 = v38 == 0;
              }
              else {
                BOOL v40 = 1;
              }
              if (v40)
              {
                if (!BN_add(v17, v17, v14)) {
                  goto LABEL_79;
                }
                uint64_t v35 = 1;
                if (!BN_add(v27, v27, v29)) {
                  goto LABEL_79;
                }
              }
              else if (++v35 == 2048)
              {
                goto LABEL_67;
              }
            }
          }
          goto LABEL_79;
        }
        if (BN_add_word(v27, 1uLL)) {
          goto LABEL_43;
        }
LABEL_79:
        BN_CTX_end(v20);
        goto LABEL_80;
      }
      if (!v24 || !BN_rand(v17, v16, 0, 1) || !BN_mod_ct(v25, v17, v14, v20) || !BN_sub(v17, v17, v25)) {
        goto LABEL_79;
      }
      if (a)
      {
        if (!BN_add(v17, v17, a)) {
          goto LABEL_79;
        }
      }
      else if (!BN_add_word(v17, 1uLL))
      {
        goto LABEL_79;
      }
      uint64_t v41 = 1;
      while (1)
      {
        int64_t v42 = BN_mod_word(v17, (unsigned __int16)primes[v41]);
        if (v42 == -1) {
          goto LABEL_79;
        }
        if (v42 > 1)
        {
          if (++v41 == 2048)
          {
LABEL_67:
            BN_CTX_end(v20);
            int v12 = v47;
            int v15 = v46;
            uint64_t v22 = v45;
            int v33 = b;
            goto LABEL_68;
          }
        }
        else
        {
          uint64_t v41 = 1;
          if (!BN_add(v17, v17, v14)) {
            goto LABEL_79;
          }
        }
      }
    }
  }
LABEL_80:
  int v18 = 0;
LABEL_81:
  BN_CTX_end(v20);
  BN_CTX_free(v20);
  return v18;
}

int BN_is_prime_fasttest_ex(const BIGNUM *p, int nchecks, BN_CTX *ctx, int do_trial_division, BN_GENCB *cb)
{
  if (nchecks < 0) {
    return -1;
  }
  if (!nchecks)
  {
    if (BN_num_bits(p) <= 3746)
    {
      if (BN_num_bits(p) <= 1344)
      {
        if (BN_num_bits(p) <= 475)
        {
          if (BN_num_bits(p) <= 399)
          {
            if (BN_num_bits(p) <= 346)
            {
              if (BN_num_bits(p) <= 307)
              {
                if (BN_num_bits(p) <= 54) {
                  ncheckunsigned int s = 34;
                }
                else {
                  ncheckunsigned int s = 27;
                }
              }
              else
              {
                ncheckunsigned int s = 8;
              }
            }
            else
            {
              ncheckunsigned int s = 7;
            }
          }
          else
          {
            ncheckunsigned int s = 6;
          }
        }
        else
        {
          ncheckunsigned int s = 5;
        }
      }
      else
      {
        ncheckunsigned int s = 4;
      }
    }
    else
    {
      ncheckunsigned int s = 3;
    }
  }
  int v8 = 0;
  if (bn_is_prime_bpsw(&v8, p, ctx, nchecks)) {
    return v8;
  }
  else {
    return -1;
  }
}

int OBJ_NAME_init(void)
{
  if (names_lh) {
    return 1;
  }
  names_lh = (uint64_t)lh_new((LHASH_HASH_FN_TYPE)obj_name_LHASH_HASH, (LHASH_COMP_FN_TYPE)obj_name_LHASH_COMP);
  return names_lh != 0;
}

unint64_t obj_name_LHASH_HASH(int *a1)
{
  if (name_funcs_stack && sk_num((const STACK *)name_funcs_stack) > *a1)
  {
    uint64_t v2 = sk_value((const STACK *)name_funcs_stack, *a1);
    unint64_t v3 = (*(uint64_t (**)(void))v2)(*((void *)a1 + 1));
  }
  else
  {
    unint64_t v3 = lh_strhash(*((const char **)a1 + 1));
  }
  return v3 ^ *a1;
}

uint64_t obj_name_LHASH_COMP(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)a1;
  uint64_t result = (*(_DWORD *)a1 - *(_DWORD *)a2);
  if (v3 == *(_DWORD *)a2)
  {
    if (name_funcs_stack && sk_num((const STACK *)name_funcs_stack) > *(_DWORD *)a1)
    {
      uint64_t v6 = (uint64_t (*)(uint64_t, uint64_t))*((void *)sk_value((const STACK *)name_funcs_stack, *(_DWORD *)a1)+ 1);
      uint64_t v7 = *(void *)(a1 + 8);
      uint64_t v8 = *(void *)(a2 + 8);
      return v6(v7, v8);
    }
    else
    {
      BOOL v9 = *(const char **)(a1 + 8);
      int v10 = *(const char **)(a2 + 8);
      return strcmp(v9, v10);
    }
  }
  return result;
}

int OBJ_NAME_new_index(unint64_t (__cdecl *hash_func)(const char *), int (__cdecl *cmp_func)(const char *, const char *), void (__cdecl *free_func)(const char *, int, const char *))
{
  uint64_t v6 = (STACK *)name_funcs_stack;
  if (!name_funcs_stack)
  {
    uint64_t v6 = sk_new_null();
    name_funcs_stacuint64_t k = (uint64_t)v6;
    if (!v6) {
      return 0;
    }
  }
  int v7 = names_type_num++;
  int v8 = sk_num(v6);
  if (v8 < names_type_num)
  {
    int v9 = v8;
    while (1)
    {
      int v10 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
      if (!v10)
      {
        int v13 = 70;
        goto LABEL_16;
      }
      int v11 = v10;
      *int v10 = lh_strhash;
      v10[1] = MEMORY[0x263EF8A90];
      _OWORD v10[2] = 0;
      if (!sk_push((STACK *)name_funcs_stack, (char *)v10)) {
        break;
      }
      if (++v9 >= names_type_num) {
        goto LABEL_8;
      }
    }
    free(v11);
    int v13 = 78;
LABEL_16:
    ERR_put_error(8, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/objects/o_names.c", v13);
    return 0;
  }
LABEL_8:
  int v12 = sk_value((const STACK *)name_funcs_stack, v7);
  if (hash_func) {
    *(void *)int v12 = hash_func;
  }
  if (cmp_func) {
    *((void *)v12 + md5_block_data_order((unint64_t)c, b, 1) = cmp_func;
  }
  if (free_func) {
    *((void *)v12 + 2) = free_func;
  }
  return v7;
}

const char *__cdecl OBJ_NAME_get(const char *name, int type)
{
  if (name)
  {
    int v3 = name;
    name = (const char *)names_lh;
    if (names_lh
      || (name = (const char *)lh_new((LHASH_HASH_FN_TYPE)obj_name_LHASH_HASH, (LHASH_COMP_FN_TYPE)obj_name_LHASH_COMP),
          (names_lh = (uint64_t)name) != 0))
    {
      uint64_t v6 = v3;
      uint64_t v7 = 0;
      uint64_t data = type & 0xFFFF7FFF;
      name = (const char *)lh_retrieve((LHASH *)name, &data);
      if (name)
      {
        int v4 = 11;
        while (1)
        {
          if ((type & 0x8000) != 0 || !*((_DWORD *)name + 1)) {
            return (const char *)*((void *)name + 2);
          }
          if (!--v4) {
            break;
          }
          uint64_t v6 = (const char *)*((void *)name + 2);
          name = (const char *)lh_retrieve((LHASH *)names_lh, &data);
          if (!name) {
            return name;
          }
        }
        return 0;
      }
    }
  }
  return name;
}

int OBJ_NAME_add(const char *name, int type, const char *data)
{
  if (!names_lh)
  {
    names_lh = (uint64_t)lh_new((LHASH_HASH_FN_TYPE)obj_name_LHASH_HASH, (LHASH_COMP_FN_TYPE)obj_name_LHASH_COMP);
    if (!names_lh) {
      return 0;
    }
  }
  uint64_t v6 = (int8x8_t *)malloc_type_malloc(0x18uLL, 0x105004015D6E50FuLL);
  if (!v6) {
    return 0;
  }
  uint64_t v7 = v6;
  *uint64_t v6 = vand_s8((int8x8_t)vdup_n_s32(type), (int8x8_t)0x8000FFFF7FFFLL);
  v6[1] = (int8x8_t)name;
  unint64_t v6[2] = (int8x8_t)data;
  int v8 = (int *)lh_insert((LHASH *)names_lh, v6);
  if (v8)
  {
    int v9 = v8;
    if (name_funcs_stack && sk_num((const STACK *)name_funcs_stack) > *v8)
    {
      int v10 = sk_value((const STACK *)name_funcs_stack, *v9);
      (*((void (**)(void, void, void))v10 + 2))(*((void *)v9 + 1), *v9, *((void *)v9 + 2));
    }
    int v11 = 1;
  }
  else
  {
    if (!*(_DWORD *)(names_lh + 168)) {
      return 1;
    }
    int v11 = 0;
    int v9 = (int *)v7;
  }
  free(v9);
  return v11;
}

int OBJ_NAME_remove(const char *name, int type)
{
  uint64_t v2 = name;
  LODWORD(namengine_table_unregister(&ecdh_table, e) = names_lh;
  if (names_lh)
  {
    data[1] = v2;
    unsigned char data[2] = 0;
    data[0] = type & 0xFFFF7FFF;
    name = (const char *)lh_delete((LHASH *)names_lh, data);
    if (name)
    {
      int v3 = (char *)name;
      if (name_funcs_stack && sk_num((const STACK *)name_funcs_stack) > *(_DWORD *)name)
      {
        int v4 = sk_value((const STACK *)name_funcs_stack, *(_DWORD *)v3);
        (*((void (**)(void, void, void))v4 + 2))(*((void *)v3 + 1), *(unsigned int *)v3, *((void *)v3 + 2));
      }
      free(v3);
      LODWORD(namengine_table_unregister(&ecdh_table, e) = 1;
    }
  }
  return (int)name;
}

void OBJ_NAME_do_all(int type, void (__cdecl *fn)(const OBJ_NAME *, void *), void *arg)
{
  arga[1] = fn;
  arga[0] = type;
  arga[2] = arg;
  lh_doall_arg((LHASH *)names_lh, (LHASH_DOALL_ARG_FN_TYPE)do_all_fn_LHASH_DOALL_ARG, arga);
}

_DWORD *do_all_fn_LHASH_DOALL_ARG(_DWORD *result, uint64_t a2)
{
  if (*result == *(_DWORD *)a2) {
    return (_DWORD *)(*(uint64_t (**)(void))(a2 + 8))();
  }
  return result;
}

void OBJ_NAME_do_all_sorted(int type, void (__cdecl *fn)(const OBJ_NAME *, void *), void *arg)
{
  int v8 = type;
  unint64_t v6 = lh_num_items((const LHASH *)names_lh);
  *(void *)&__nel[1] = reallocarray(0, v6, 8uLL);
  __nel[0] = 0;
  if (*(void *)&__nel[1])
  {
    arga[0] = type;
    arga[1] = do_all_sorted_fn;
    arga[2] = &v8;
    lh_doall_arg((LHASH *)names_lh, (LHASH_DOALL_ARG_FN_TYPE)do_all_fn_LHASH_DOALL_ARG, arga);
    qsort(*(void **)&__nel[1], __nel[0], 8uLL, (int (__cdecl *)(const void *, const void *))do_all_sorted_cmp);
    if (__nel[0] >= 1)
    {
      uint64_t v7 = 0;
      do
        ((void (*)(void, void *))fn)(*(void *)(*(void *)&__nel[1] + 8 * v7++), arg);
      while (v7 < __nel[0]);
    }
    free(*(void **)&__nel[1]);
  }
}

_DWORD *do_all_sorted_fn(_DWORD *result, uint64_t a2)
{
  if (*result == *(_DWORD *)a2)
  {
    uint64_t v2 = *(void *)(a2 + 8);
    uint64_t v3 = *(int *)(a2 + 4);
    *(_DWORD *)(a2 + 4) = v3 + 1;
    *(void *)(v2 + 8 * v3) = result;
  }
  return result;
}

uint64_t do_all_sorted_cmp(uint64_t a1, uint64_t a2)
{
  return strcmp(*(const char **)(*(void *)a1 + 8), *(const char **)(*(void *)a2 + 8));
}

void OBJ_NAME_cleanup(int type)
{
  uint64_t v2 = (LHASH *)names_lh;
  if (names_lh)
  {
    free_type = type;
    uint64_t v3 = *(void *)(names_lh + 48);
    *(void *)(names_lh + 48) = 0;
    lh_doall(v2, (LHASH_DOALL_FN_TYPE)names_lh_free_LHASH_DOALL);
    if (type < 0)
    {
      lh_free((LHASH *)names_lh);
      sk_pop_free((STACK *)name_funcs_stack, name_funcs_free);
      names_lh = 0;
      name_funcs_stacuint64_t k = 0;
    }
    else
    {
      *(void *)(names_lh + 48) = v3;
    }
  }
}

uint64_t names_lh_free_LHASH_DOALL(uint64_t result)
{
  if (result)
  {
    int v1 = *(_DWORD *)result;
    if (free_type < 0 || free_type == v1) {
      return OBJ_NAME_remove(*(const char **)(result + 8), v1);
    }
  }
  return result;
}

const char *__cdecl X509_verify_cert_error_string(uint64_t n)
{
  if (n > 0x45) {
    return "Unknown certificate verification error";
  }
  else {
    return off_264E50938[(int)n];
  }
}

const EVP_CIPHER *EVP_aes_128_cbc(void)
{
  return (const EVP_CIPHER *)&aes_128_cbc;
}

const EVP_CIPHER *EVP_aes_128_ecb(void)
{
  return (const EVP_CIPHER *)&aes_128_ecb;
}

const EVP_CIPHER *EVP_aes_128_ofb(void)
{
  return (const EVP_CIPHER *)&aes_128_ofb;
}

const EVP_CIPHER *EVP_aes_128_cfb128(void)
{
  return (const EVP_CIPHER *)&aes_128_cfb;
}

const EVP_CIPHER *EVP_aes_128_cfb1(void)
{
  return (const EVP_CIPHER *)&aes_128_cfb1;
}

const EVP_CIPHER *EVP_aes_128_cfb8(void)
{
  return (const EVP_CIPHER *)&aes_128_cfb8;
}

void *EVP_aes_128_ctr()
{
  return &aes_128_ctr;
}

const EVP_CIPHER *EVP_aes_192_cbc(void)
{
  return (const EVP_CIPHER *)&aes_192_cbc;
}

const EVP_CIPHER *EVP_aes_192_ecb(void)
{
  return (const EVP_CIPHER *)&aes_192_ecb;
}

const EVP_CIPHER *EVP_aes_192_ofb(void)
{
  return (const EVP_CIPHER *)&aes_192_ofb;
}

const EVP_CIPHER *EVP_aes_192_cfb128(void)
{
  return (const EVP_CIPHER *)&aes_192_cfb;
}

const EVP_CIPHER *EVP_aes_192_cfb1(void)
{
  return (const EVP_CIPHER *)&aes_192_cfb1;
}

const EVP_CIPHER *EVP_aes_192_cfb8(void)
{
  return (const EVP_CIPHER *)&aes_192_cfb8;
}

void *EVP_aes_192_ctr()
{
  return &aes_192_ctr;
}

const EVP_CIPHER *EVP_aes_256_cbc(void)
{
  return (const EVP_CIPHER *)&aes_256_cbc;
}

const EVP_CIPHER *EVP_aes_256_ecb(void)
{
  return (const EVP_CIPHER *)&aes_256_ecb;
}

const EVP_CIPHER *EVP_aes_256_ofb(void)
{
  return (const EVP_CIPHER *)&aes_256_ofb;
}

const EVP_CIPHER *EVP_aes_256_cfb128(void)
{
  return (const EVP_CIPHER *)&aes_256_cfb;
}

const EVP_CIPHER *EVP_aes_256_cfb1(void)
{
  return (const EVP_CIPHER *)&aes_256_cfb1;
}

const EVP_CIPHER *EVP_aes_256_cfb8(void)
{
  return (const EVP_CIPHER *)&aes_256_cfb8;
}

void *EVP_aes_256_ctr()
{
  return &aes_256_ctr;
}

void *EVP_aes_128_gcm()
{
  return &aes_128_gcm;
}

void *EVP_aes_192_gcm()
{
  return &aes_192_gcm;
}

void *EVP_aes_256_gcm()
{
  return &aes_256_gcm;
}

void *EVP_aes_128_xts()
{
  return &aes_128_xts;
}

void *EVP_aes_256_xts()
{
  return &aes_256_xts;
}

void *EVP_aes_128_ccm()
{
  return &aes_128_ccm;
}

void *EVP_aes_192_ccm()
{
  return &aes_192_ccm;
}

void *EVP_aes_256_ccm()
{
  return &aes_256_ccm;
}

void *EVP_aead_aes_128_gcm()
{
  return &aead_aes_128_gcm;
}

void *EVP_aead_aes_256_gcm()
{
  return &aead_aes_256_gcm;
}

void *EVP_aes_128_wrap()
{
  return &aes_128_wrap;
}

void *EVP_aes_192_wrap()
{
  return &aes_192_wrap;
}

void *EVP_aes_256_wrap()
{
  return &aes_256_wrap;
}

uint64_t aes_init_key(uint64_t a1, unsigned __int8 *userKey, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(a1 + 120);
  int v5 = *(_DWORD *)(*(void *)a1 + 16) & 0xF0007;
  int v6 = 8 * *(_DWORD *)(a1 + 104);
  if (v5 == 2) {
    uint64_t v7 = AES_cbc_encrypt;
  }
  else {
    uint64_t v7 = 0;
  }
  if (a4 || (v5 - 3) < 0xFFFFFFFE)
  {
    int v8 = AES_set_encrypt_key(userKey, v6, (AES_KEY *)v4);
    int v9 = AES_encrypt;
  }
  else
  {
    int v8 = AES_set_decrypt_key(userKey, v6, (AES_KEY *)v4);
    int v9 = AES_decrypt;
  }
  *(void *)(v4 + 248) = v9;
  *(void *)(v4 + 256) = v7;
  if ((v8 & 0x80000000) == 0) {
    return 1;
  }
  ERR_put_error(6, 4095, 143, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_aes.c", 422);
  return 0;
}

uint64_t aes_cbc_cipher(uint64_t a1, uint64_t *a2, void *a3, unint64_t a4)
{
  uint64_t v5 = *(void *)(a1 + 120);
  int v6 = *(void (**)(void *, uint64_t *, unint64_t))(v5 + 256);
  if (v6)
  {
    v6(a3, a2, a4);
  }
  else
  {
    uint64_t v7 = (_OWORD *)(a1 + 40);
    int v8 = *(uint64_t (**)(void *, uint64_t *, uint64_t))(v5 + 248);
    if (*(_DWORD *)(a1 + 16)) {
      CRYPTO_cbc128_encrypt(a3, a2, a4, v5, v7, (void (*)(void *, void *, uint64_t))v8);
    }
    else {
      CRYPTO_cbc128_decrypt((uint64_t)a3, a2, a4, v5, v7, v8);
    }
  }
  return 1;
}

uint64_t aes_ecb_cipher(void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4 = *(int *)(*a1 + 4);
  unint64_t v5 = a4 - v4;
  if (a4 >= v4)
  {
    unint64_t v8 = 0;
    uint64_t v9 = a1[15];
    do
    {
      (*(void (**)(unint64_t, unint64_t, uint64_t))(v9 + 248))(a3 + v8, a2 + v8, v9);
      v8 += v4;
    }
    while (v8 <= v5);
  }
  return 1;
}

uint64_t aes_ofb_cipher(uint64_t a1, unsigned char *a2, uint64_t a3, unint64_t a4)
{
  return 1;
}

uint64_t aes_cfb_cipher(uint64_t a1, unsigned char *a2, uint64_t a3, unint64_t a4)
{
  return 1;
}

uint64_t aes_cfb1_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4 = a4;
  uint64_t v5 = a3;
  uint64_t v6 = a2;
  uint64_t v8 = *(void *)(a1 + 120);
  if ((*(unsigned char *)(a1 + 113) & 0x20) != 0)
  {
    uint64_t v10 = a1 + 40;
    uint64_t v11 = a1 + 88;
    int v12 = *(_DWORD *)(a1 + 16);
    int v13 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 248);
    uint64_t v14 = a3;
    uint64_t v9 = a4;
    goto LABEL_7;
  }
  if (a4 >> 60)
  {
    do
    {
      CRYPTO_cfb128_1_encrypt(v5, v6, 0x8000000000000000, v8, a1 + 40, a1 + 88, *(_DWORD *)(a1 + 16), *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 248));
      v4 -= 0x1000000000000000;
      v5 += 0x1000000000000000;
      v6 += 0x1000000000000000;
    }
    while (v4 >> 60);
  }
  if (v4)
  {
    uint64_t v9 = 8 * v4;
    uint64_t v10 = a1 + 40;
    uint64_t v11 = a1 + 88;
    int v12 = *(_DWORD *)(a1 + 16);
    int v13 = *(void (**)(uint64_t, uint64_t, uint64_t))(v8 + 248);
    uint64_t v14 = v5;
    a2 = v6;
LABEL_7:
    CRYPTO_cfb128_1_encrypt(v14, a2, v9, v8, v10, v11, v12, v13);
  }
  return 1;
}

uint64_t aes_cfb8_cipher(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4)
{
  return 1;
}

uint64_t aes_ctr_cipher(uint64_t a1, unsigned char *a2, uint64_t a3, unint64_t a4)
{
  unsigned int v11 = *(_DWORD *)(a1 + 88);
  uint64_t v6 = *(void *)(a1 + 120);
  uint64_t v7 = *(uint64_t (**)(char *, unsigned char *, unint64_t, uint64_t, uint64_t))(v6 + 256);
  uint64_t v8 = a1 + 40;
  uint64_t v9 = (void *)(a1 + 56);
  if (v7) {
    CRYPTO_ctr128_encrypt_ctr32(a3, a2, a4, v6, v8, v9, &v11, v7);
  }
  else {
    CRYPTO_ctr128_encrypt(a3, a2, a4, v6, v8, (uint64_t)v9, &v11, *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v6 + 248));
  }
  *(_DWORD *)(a1 + 88) = v11;
  return 1;
}

uint64_t aes_gcm_init_key(uint64_t a1, unsigned __int8 *userKey, void *__src)
{
  if ((unint64_t)userKey | (unint64_t)__src)
  {
    uint64_t v3 = (uint64_t *)__src;
    uint64_t v4 = *(void *)(a1 + 120);
    if (userKey)
    {
      AES_set_encrypt_key(userKey, 8 * *(_DWORD *)(a1 + 104), (AES_KEY *)v4);
      CRYPTO_gcm128_init(v4 + 256, v4, (void (*)(unsigned int *, unsigned int *, uint64_t))AES_encrypt);
      *(void *)(v4 + 672) = 0;
      if (v3 || *(_DWORD *)(v4 + 248) && (uint64_t v3 = *(uint64_t **)(v4 + 648)) != 0)
      {
        CRYPTO_gcm128_setiv(v4 + 256, v3, *(int *)(v4 + 656));
        *(_DWORD *)(v4 + 248) = 1;
      }
      *(_DWORD *)(v4 + 244) = 1;
    }
    else
    {
      if (*(_DWORD *)(v4 + 244)) {
        CRYPTO_gcm128_setiv(v4 + 256, (uint64_t *)__src, *(int *)(v4 + 656));
      }
      else {
        memcpy(*(void **)(v4 + 648), __src, *(int *)(v4 + 656));
      }
      *(_DWORD *)(v4 + 248) = 1;
      *(_DWORD *)(v4 + 664) = 0;
    }
  }
  return 1;
}

unint64_t aes_gcm_cipher(EVP_CIPHER_CTX *ctx, char *a2, char *ptr, unint64_t a4)
{
  cipher_uint64_t data = ctx->cipher_data;
  if (!cipher_data[61]) {
    return 0xFFFFFFFFLL;
  }
  if ((cipher_data[167] & 0x80000000) != 0)
  {
    if (!cipher_data[62]) {
      return 0xFFFFFFFFLL;
    }
    if (!ptr)
    {
      if (ctx->encrypt)
      {
        CRYPTO_gcm128_tag((uint64_t)(cipher_data + 64), ctx->buf, 0x10uLL);
        unint64_t result = 0;
        cipher_data[165] = 16;
      }
      else
      {
        size_t v18 = cipher_data[165];
        if ((v18 & 0x80000000) != 0) {
          return 0xFFFFFFFFLL;
        }
        unint64_t result = CRYPTO_gcm128_finish((uint64_t)(cipher_data + 64), ctx->buf, v18);
        if (result) {
          return 0xFFFFFFFFLL;
        }
      }
      cipher_data[62] = 0;
      return result;
    }
    if (a2)
    {
      int encrypt = ctx->encrypt;
      int v12 = (void (*)(char *, unsigned char *, uint64_t, uint64_t, uint64_t))*((void *)cipher_data + 84);
      uint64_t v13 = (uint64_t)(cipher_data + 64);
      if (encrypt)
      {
        if (v12)
        {
          if (!CRYPTO_gcm128_encrypt_ctr32(v13, ptr, a2, a4, v12)) {
            return a4;
          }
          return 0xFFFFFFFFLL;
        }
        if (CRYPTO_gcm128_encrypt(v13, ptr, a2, a4)) {
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        if (v12)
        {
          if (!CRYPTO_gcm128_decrypt_ctr32(v13, ptr, a2, a4, v12)) {
            return a4;
          }
          return 0xFFFFFFFFLL;
        }
        if (CRYPTO_gcm128_decrypt(v13, ptr, a2, a4)) {
          return 0xFFFFFFFFLL;
        }
      }
      return a4;
    }
    if (!CRYPTO_gcm128_aad((uint64_t)(cipher_data + 64), ptr, a4)) {
      return a4;
    }
    return 0xFFFFFFFFLL;
  }
  unint64_t result = 0xFFFFFFFFLL;
  if (a2 == ptr)
  {
    unint64_t v9 = a4 - 24;
    if (a4 >= 0x18)
    {
      if (ctx->encrypt) {
        int v10 = 19;
      }
      else {
        int v10 = 24;
      }
      if (EVP_CIPHER_CTX_ctrl(ctx, v10, 8, ptr) < 1
        || CRYPTO_gcm128_aad((uint64_t)(cipher_data + 64), (char *)ctx->buf, (int)cipher_data[167]))
      {
        goto LABEL_10;
      }
      uint64_t v14 = ptr + 8;
      int v15 = (void (*)(char *, unsigned char *, uint64_t, uint64_t, uint64_t))*((void *)cipher_data + 84);
      uint64_t v16 = (uint64_t)(cipher_data + 64);
      unint64_t v17 = a4 - 24;
      if (ctx->encrypt)
      {
        if (v15)
        {
          if (!CRYPTO_gcm128_encrypt_ctr32(v16, v14, v14, v17, v15)) {
            goto LABEL_41;
          }
        }
        else if (!CRYPTO_gcm128_encrypt(v16, v14, v14, v17))
        {
LABEL_41:
          CRYPTO_gcm128_tag((uint64_t)(cipher_data + 64), &v14[v9], 0x10uLL);
          unint64_t result = a4;
          goto LABEL_11;
        }
LABEL_10:
        unint64_t result = 0xFFFFFFFFLL;
LABEL_11:
        cipher_data[62] = 0;
        cipher_data[167] = -1;
        return result;
      }
      if (v15)
      {
        if (CRYPTO_gcm128_decrypt_ctr32(v16, v14, v14, v17, v15)) {
          goto LABEL_10;
        }
      }
      else if (CRYPTO_gcm128_decrypt(v16, v14, v14, v17))
      {
        goto LABEL_10;
      }
      CRYPTO_gcm128_tag((uint64_t)(cipher_data + 64), ctx->buf, 0x10uLL);
      if (*(void *)ctx->buf != *(void *)&v14[v9] || *(void *)&ctx->buf[8] != *(void *)&v14[v9 + 8]) {
        explicit_bzero(v14, a4 - 24);
      }
      unint64_t result = a4 - 24;
      goto LABEL_11;
    }
  }
  return result;
}

void aes_gcm_cleanup(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 120);
  uint64_t v3 = (void *)v2[81];
  if (v3 != (void *)(a1 + 40)) {
    free(v3);
  }
  explicit_bzero(v2, 0x2A8uLL);
}

uint64_t aes_gcm_ctrl(uint64_t a1, int a2, size_t __n, uint64_t *__src)
{
  uint64_t v5 = *(void *)(a1 + 120);
  uint64_t result = 0xFFFFFFFFLL;
  int v8 = __n;
  switch(a2)
  {
    case 8:
      uint64_t v9 = __src[15];
      uint64_t v10 = *(void *)(v5 + 640);
      if (v10)
      {
        if (v10 != v5) {
          return 0;
        }
        *(void *)(v9 + 64X509_check_purpose(x, -1, 0) = v9;
      }
      if (*(void *)(v5 + 648) == a1 + 40)
      {
        *(void *)(v9 + 648) = __src + 5;
        return 1;
      }
      uint64_t result = (uint64_t)malloc_type_calloc(1uLL, *(int *)(v5 + 656), 0x5934C551uLL);
      *(void *)(v9 + 648) = result;
      if (result)
      {
        unsigned int v11 = *(const void **)(v5 + 648);
        __int n = *(int *)(v5 + 656);
        goto LABEL_22;
      }
      return result;
    case 9:
      if ((int)__n < 1) {
        return 0;
      }
      if (__n < 0x11 || *(_DWORD *)(v5 + 656) >= (int)__n) {
        goto LABEL_17;
      }
      uint64_t v13 = *(void **)(v5 + 648);
      if (v13 != (void *)(a1 + 40)) {
        free(v13);
      }
      uint64_t result = (uint64_t)malloc_type_malloc(v8, 0xDDFE345BuLL);
      *(void *)(v5 + 648) = result;
      if (result)
      {
LABEL_17:
        *(_DWORD *)(v5 + 656) = v8;
        return 1;
      }
      return result;
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 20:
    case 21:
    case 23:
      return result;
    case 16:
      if ((__n - 17) < 0xFFFFFFF0 || !*(_DWORD *)(a1 + 16) || (*(_DWORD *)(v5 + 660) & 0x80000000) != 0) {
        return 0;
      }
      unsigned int v11 = (const void *)(a1 + 56);
      __int n = __n;
      uint64_t result = (uint64_t)__src;
LABEL_22:
      memcpy((void *)result, v11, __n);
      return 1;
    case 17:
      if ((__n - 17) < 0xFFFFFFF0 || *(_DWORD *)(a1 + 16)) {
        return 0;
      }
      memcpy((void *)(a1 + 56), __src, __n);
      *(_DWORD *)(v5 + 66X509_check_purpose(x, -1, 0) = v8;
      return 1;
    case 18:
      if (__n == -1)
      {
        memcpy(*(void **)(v5 + 648), __src, *(int *)(v5 + 656));
LABEL_55:
        uint64_t result = 1;
        *(_DWORD *)(v5 + 664) = 1;
        return result;
      }
      if ((int)__n >= 4 && *(_DWORD *)(v5 + 656) - (int)__n >= 8)
      {
        memcpy(*(void **)(v5 + 648), __src, __n);
        if (*(_DWORD *)(a1 + 16)) {
          arc4random_buf((void *)(*(void *)(v5 + 648) + v8), *(int *)(v5 + 656) - (uint64_t)v8);
        }
        goto LABEL_55;
      }
      return 0;
    case 19:
      if (!*(_DWORD *)(v5 + 664) || !*(_DWORD *)(v5 + 244)) {
        return 0;
      }
      CRYPTO_gcm128_setiv(v5 + 256, *(uint64_t **)(v5 + 648), *(int *)(v5 + 656));
      uint64_t v14 = *(int *)(v5 + 656);
      if ((int)v14 < v8 || v8 < 1) {
        int v16 = *(_DWORD *)(v5 + 656);
      }
      else {
        int v16 = v8;
      }
      memcpy(__src, (const void *)(*(void *)(v5 + 648) + v14 - v16), v16);
      uint64_t v17 = 0;
      uint64_t v18 = *(int *)(v5 + 656) + *(void *)(v5 + 648) - 1;
      do
      {
        char v19 = *(unsigned char *)(v18 + v17) + 1;
        *(unsigned char *)(v18 + v17) = v19;
        if (v17 == -7) {
          break;
        }
        --v17;
      }
      while (!v19);
      goto LABEL_53;
    case 22:
      if (__n != 13) {
        return 0;
      }
      uint64_t v20 = *__src;
      *(void *)(a1 + 6md5_block_data_order((unint64_t)c, b, 1) = *(uint64_t *)((char *)__src + 5);
      *(void *)(a1 + 56) = v20;
      *(_DWORD *)(v5 + 668) = 13;
      unsigned int v21 = __rev16(*(unsigned __int16 *)(a1 + 67));
      unsigned int v22 = v21 - 8;
      if (v21 < 8) {
        return 0;
      }
      if (*(_DWORD *)(a1 + 16)) {
        goto LABEL_48;
      }
      if (v22 < 0x10) {
        return 0;
      }
      unsigned int v22 = v21 - 24;
LABEL_48:
      *(_WORD *)(a1 + 67) = bswap32(v22) >> 16;
      return 16;
    case 24:
      if (!*(_DWORD *)(v5 + 664) || !*(_DWORD *)(v5 + 244) || *(_DWORD *)(a1 + 16)) {
        return 0;
      }
      memcpy((void *)(*(void *)(v5 + 648) + *(int *)(v5 + 656) - (int)__n), __src, (int)__n);
      CRYPTO_gcm128_setiv(v5 + 256, *(uint64_t **)(v5 + 648), *(int *)(v5 + 656));
LABEL_53:
      uint64_t result = 1;
      *(_DWORD *)(v5 + 248) = 1;
      return result;
    default:
      if (a2) {
        return result;
      }
      *(_DWORD *)(v5 + 244) = 0;
      *(_DWORD *)(v5 + 248) = 0;
      int v12 = *(_DWORD *)(*(void *)a1 + 12);
      if (!v12)
      {
        ERR_put_error(6, 4095, 194, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_aes.c", 1298);
        return 0;
      }
      *(_DWORD *)(v5 + 656) = v12;
      *(void *)(v5 + 648) = a1 + 40;
      *(_DWORD *)(v5 + 66X509_check_purpose(x, -1, 0) = -1;
      *(void *)(v5 + 664) = 0xFFFFFFFF00000000;
      return 1;
  }
}

uint64_t aes_xts_init_key(uint64_t a1, unsigned __int8 *userKey, unint64_t a3, int a4)
{
  if ((unint64_t)userKey | a3)
  {
    uint64_t v7 = *(void *)(a1 + 120);
    if (userKey)
    {
      *(void *)(v7 + 52X509_check_purpose(x, -1, 0) = 0;
      int v8 = 4 * *(_DWORD *)(a1 + 104);
      if (a4)
      {
        AES_set_encrypt_key(userKey, v8, (AES_KEY *)v7);
        uint64_t v9 = AES_encrypt;
      }
      else
      {
        AES_set_decrypt_key(userKey, v8, (AES_KEY *)v7);
        uint64_t v9 = AES_decrypt;
      }
      *(void *)(v7 + 504) = v9;
      int v10 = *(_DWORD *)(a1 + 104);
      if (v10 >= 0) {
        int v11 = *(_DWORD *)(a1 + 104);
      }
      else {
        int v11 = v10 + 1;
      }
      AES_set_encrypt_key(&userKey[v11 >> 1], 4 * v10, (AES_KEY *)(v7 + 244));
      *(void *)(v7 + 512) = AES_encrypt;
      *(void *)(v7 + 488) = v7;
    }
    if (a3)
    {
      *(void *)(v7 + 496) = v7 + 244;
      *(_OWORD *)(a1 + 4X509_check_purpose(x, -1, 0) = *(_OWORD *)a3;
    }
  }
  return 1;
}

BOOL aes_xts_cipher(uint64_t a1, __n128 *a2, int8x16_t *a3, unint64_t a4)
{
  uint64_t v4 = *(void **)(a1 + 120);
  if (!v4[61] || !v4[62]) {
    return 0;
  }
  uint64_t v5 = 0;
  if (a2 && a3 && a4 >= 0x10)
  {
    uint64_t v6 = (void (*)(int8x16_t *, __n128 *, unint64_t))v4[65];
    if (v6)
    {
      v6(a3, a2, a4);
      return 1;
    }
    return !CRYPTO_xts128_encrypt(v4 + 61, (int8x16_t *)(a1 + 40), a3, a2, a4, *(_DWORD *)(a1 + 16));
  }
  return v5;
}

uint64_t aes_xts_ctrl(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 120);
  if (a2 == 8)
  {
    uint64_t v6 = *(void *)(a4 + 120);
    uint64_t v7 = *(void *)(v4 + 488);
    if (v7)
    {
      if (v7 != v4) {
        return 0;
      }
      *(void *)(v6 + 488) = v6;
    }
    uint64_t v8 = *(void *)(v4 + 496);
    if (!v8) {
      return 1;
    }
    if (v8 == v4 + 244)
    {
      *(void *)(v6 + 496) = v6 + 244;
      return 1;
    }
    return 0;
  }
  if (!a2)
  {
    *(void *)(v4 + 488) = 0;
    *(void *)(v4 + 496) = 0;
    return 1;
  }
  return 0xFFFFFFFFLL;
}

uint64_t aes_ccm_init_key(uint64_t a1, unsigned __int8 *userKey, unint64_t __src)
{
  if ((unint64_t)userKey | __src)
  {
    uint64_t v5 = *(void *)(a1 + 120);
    if (userKey)
    {
      AES_set_encrypt_key(userKey, 8 * *(_DWORD *)(a1 + 104), (AES_KEY *)v5);
      CRYPTO_ccm128_init((void *)(v5 + 272), *(_DWORD *)(v5 + 264), *(_DWORD *)(v5 + 260), v5, (uint64_t)AES_encrypt);
      *(void *)(v5 + 328) = 0;
      *(_DWORD *)(v5 + 244) = 1;
    }
    if (__src)
    {
      memcpy((void *)(a1 + 40), (const void *)__src, 15 - *(int *)(v5 + 260));
      *(_DWORD *)(v5 + 248) = 1;
    }
  }
  return 1;
}

uint64_t aes_ccm_cipher(uint64_t a1, uint64_t *a2, char *a3, unint64_t a4)
{
  unint64_t v4 = a4;
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(int8x16_t **)(a1 + 120);
  if (!v8[15].i32[2] && !v8[15].i32[1]) {
    return 0xFFFFFFFFLL;
  }
  int v9 = *(_DWORD *)(a1 + 16);
  if (!v9 && !v8[15].i32[3]) {
    return 0xFFFFFFFFLL;
  }
  if (a2)
  {
    if (a3)
    {
      if (v8[16].i32[0]) {
        goto LABEL_8;
      }
      if (!CRYPTO_ccm128_setiv(v8[17].i8, (const void *)(a1 + 40), 15 - v8[16].i32[1], a4))
      {
        v8[16].i32[0] = 1;
        int v9 = *(_DWORD *)(a1 + 16);
LABEL_8:
        int v10 = (void (*)(char *, unsigned char *, unint64_t, uint64_t, int8x16_t *, int8x16_t *))v8[20].i64[1];
        if (v9)
        {
          int v11 = v8 + 17;
          if (v10)
          {
            CRYPTO_ccm128_encrypt_ccm64(v11, a3, a2, v4, v10);
            if (!v12) {
              goto LABEL_27;
            }
          }
          else
          {
            CRYPTO_ccm128_encrypt(v11, a3, a2, v4);
            if (!v14)
            {
LABEL_27:
              v8[15].i32[3] = 1;
              return v4;
            }
          }
          return 0xFFFFFFFFLL;
        }
        uint64_t v13 = v8 + 17;
        if (v10)
        {
          if (CRYPTO_ccm128_decrypt_ccm64(v13, a3, a2, v4, v10)) {
            goto LABEL_31;
          }
        }
        else if (CRYPTO_ccm128_decrypt(v13, a3, a2, v4))
        {
          goto LABEL_31;
        }
        if (CRYPTO_ccm128_tag((unsigned __int8 *)&v8[17], __s1, v8[16].i32[2])
          && !memcmp(__s1, (const void *)(a1 + 56), v8[16].i32[2])
          && v4 != -1)
        {
          v8[15].i64[1] = 0;
          v8[16].i32[0] = 0;
          return v4;
        }
LABEL_31:
        explicit_bzero(a2, v4);
      }
      return 0xFFFFFFFFLL;
    }
    return 0;
  }
  else if (a3)
  {
    if (a4 && !v8[16].i32[0]) {
      return 0xFFFFFFFFLL;
    }
    CRYPTO_ccm128_aad((uint64_t)v8[17].i64, a3, a4);
  }
  else
  {
    if (CRYPTO_ccm128_setiv(v8[17].i8, (const void *)(a1 + 40), 15 - v8[16].i32[1], a4)) {
      return 0xFFFFFFFFLL;
    }
    v8[16].i32[0] = 1;
  }
  return v4;
}

size_t aes_ccm_ctrl(uint64_t a1, int a2, size_t __n, void *__dst)
{
  int v4 = __n;
  uint64_t v6 = *(void *)(a1 + 120);
  size_t result = 0xFFFFFFFFLL;
  switch(a2)
  {
    case 8:
      uint64_t v8 = *(void *)(v6 + 320);
      if (!v8) {
        return 1;
      }
      if (v8 != v6) {
        return 0;
      }
      *(void *)(__dst[15] + 32X509_check_purpose(x, -1, 0) = __dst[15];
      return 1;
    case 9:
      int v4 = 15 - __n;
      goto LABEL_9;
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return result;
    case 16:
      if (!*(_DWORD *)(a1 + 16) || !*(_DWORD *)(v6 + 252)) {
        return 0;
      }
      size_t result = CRYPTO_ccm128_tag((unsigned __int8 *)(v6 + 272), __dst, (int)__n);
      if (result)
      {
        *(void *)(v6 + 248) = 0;
        size_t result = 1;
        *(_DWORD *)(v6 + 256) = 0;
      }
      return result;
    case 17:
      size_t result = 0;
      if ((__n & 1) != 0 || (__n - 17) < 0xFFFFFFF3) {
        return result;
      }
      if ((__dst != 0) == (*(_DWORD *)(a1 + 16) != 0)) {
        return 0;
      }
      if (__dst)
      {
        *(_DWORD *)(v6 + 252) = 1;
        memcpy((void *)(a1 + 56), __dst, __n);
      }
      *(_DWORD *)(v6 + 264) = v4;
      return 1;
    default:
      if (a2 == 20)
      {
LABEL_9:
        if ((v4 - 9) < 0xFFFFFFF9)
        {
          return 0;
        }
        else
        {
          *(_DWORD *)(v6 + 26X509_check_purpose(x, -1, 0) = v4;
          return 1;
        }
      }
      else if (!a2)
      {
        *(void *)(v6 + 26X509_check_purpose(x, -1, 0) = 0xC00000008;
        *(_DWORD *)(v6 + 256) = 0;
        *(void *)(v6 + 248) = 0;
        size_t result = 1;
        *(_DWORD *)(v6 + 244) = 0;
      }
      return result;
  }
}

uint64_t aead_aes_gcm_init(uint64_t a1, const unsigned __int8 *a2, uint64_t a3, unint64_t a4)
{
  int v4 = a3;
  if (8 * a3 != 128 && 8 * a3 != 256)
  {
    int v8 = 137;
    int v9 = 2249;
    goto LABEL_9;
  }
  if (a4) {
    unint64_t v7 = a4;
  }
  else {
    unint64_t v7 = 16;
  }
  if (v7 >= 0x11)
  {
    int v8 = 171;
    int v9 = 2257;
LABEL_9:
    ERR_put_error(6, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_aes.c", v9);
    return 0;
  }
  uint64_t result = (uint64_t)malloc_type_calloc(1uLL, 0x290uLL, 0x1080040FF578D95uLL);
  if (result)
  {
    uint64_t v11 = result;
    uint64_t v12 = result + 248;
    AES_set_encrypt_key(a2, 8 * v4, (AES_KEY *)result);
    CRYPTO_gcm128_init(v12, v11, (void (*)(unsigned int *, unsigned int *, uint64_t))AES_encrypt);
    *(void *)(v11 + 64X509_check_purpose(x, -1, 0) = 0;
    *(unsigned char *)(v11 + 648) = v7;
    uint64_t result = 1;
    *(void *)(a1 + 8) = v11;
  }
  return result;
}

void *aead_aes_gcm_cleanup(uint64_t a1)
{
  return freezero(*(void **)(a1 + 8), 0x290uLL);
}

uint64_t aead_aes_gcm_seal(uint64_t a1, unsigned char *a2, void *a3, unint64_t a4, uint64_t *a5, unint64_t a6, char *a7, unint64_t a8, char *a9, uint64_t a10)
{
  uint64_t v10 = *(void *)(a1 + 8);
  if (*(unsigned __int8 *)(v10 + 648) + a8 > a4)
  {
    int v11 = 155;
    int v12 = 2301;
LABEL_10:
    ERR_put_error(6, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_aes.c", v12);
    return 0;
  }
  memcpy(__dst, (const void *)(v10 + 248), sizeof(__dst));
  if (!a6)
  {
    int v11 = 194;
    int v12 = 2308;
    goto LABEL_10;
  }
  CRYPTO_gcm128_setiv((uint64_t)__dst, a5, a6);
  if (a10 && CRYPTO_gcm128_aad((uint64_t)__dst, a9, a10)) {
    return 0;
  }
  char v19 = *(void (**)(char *, unsigned char *, uint64_t, uint64_t, uint64_t))(v10 + 640);
  if (v19)
  {
    if (CRYPTO_gcm128_encrypt_ctr32((uint64_t)__dst, a7, a2, a8, v19)) {
      return 0;
    }
  }
  else if (CRYPTO_gcm128_encrypt((uint64_t)__dst, a7, a2, a8))
  {
    return 0;
  }
  CRYPTO_gcm128_tag((uint64_t)__dst, &a2[a8], *(unsigned __int8 *)(v10 + 648));
  *a3 = *(unsigned __int8 *)(v10 + 648) + a8;
  return 1;
}

uint64_t aead_aes_gcm_open(uint64_t a1, unsigned char *a2, unint64_t *a3, unint64_t a4, uint64_t *a5, unint64_t a6, char *a7, unint64_t a8, char *a9, uint64_t a10)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v10 = *(void *)(a1 + 8);
  unint64_t v11 = *(unsigned __int8 *)(v10 + 648);
  unint64_t v12 = a8 - v11;
  if (a8 < v11)
  {
    int v13 = 100;
    int v14 = 2345;
LABEL_11:
    ERR_put_error(6, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_aes.c", v14);
    return 0;
  }
  if (v12 > a4)
  {
    int v13 = 155;
    int v14 = 2352;
    goto LABEL_11;
  }
  memcpy(__dst, (const void *)(v10 + 248), sizeof(__dst));
  if (!a6)
  {
    int v13 = 194;
    int v14 = 2359;
    goto LABEL_11;
  }
  CRYPTO_gcm128_setiv((uint64_t)__dst, a5, a6);
  if (CRYPTO_gcm128_aad((uint64_t)__dst, a9, a10)) {
    return 0;
  }
  unsigned int v21 = *(void (**)(char *, unsigned char *, uint64_t, uint64_t, uint64_t))(v10 + 640);
  unint64_t v22 = a8 - *(unsigned __int8 *)(v10 + 648);
  if (v21)
  {
    if (!CRYPTO_gcm128_decrypt_ctr32((uint64_t)__dst, a7, a2, v22, v21)) {
      goto LABEL_14;
    }
    return 0;
  }
  if (CRYPTO_gcm128_decrypt((uint64_t)__dst, a7, a2, v22)) {
    return 0;
  }
LABEL_14:
  CRYPTO_gcm128_tag((uint64_t)__dst, v25, *(unsigned __int8 *)(v10 + 648));
  if (timingsafe_memcmp(v25, (unsigned __int8 *)&a7[v12], *(unsigned __int8 *)(v10 + 648)))
  {
    int v13 = 100;
    int v14 = 2379;
    goto LABEL_11;
  }
  *a3 = v12;
  return 1;
}

uint64_t aes_wrap_init_key(const EVP_CIPHER_CTX *a1, unsigned __int8 *userKey, unint64_t a3)
{
  if ((unint64_t)userKey | a3)
  {
    cipher_uint64_t data = (AES_KEY *)a1->cipher_data;
    if (userKey)
    {
      int encrypt = a1->encrypt;
      int v8 = 8 * a1->key_len;
      if (encrypt)
      {
        AES_set_encrypt_key(userKey, v8, cipher_data);
        if (!a3) {
          goto LABEL_10;
        }
      }
      else
      {
        AES_set_decrypt_key(userKey, v8, cipher_data);
        if (!a3)
        {
LABEL_10:
          iv = 0;
          goto LABEL_11;
        }
      }
    }
    else if (!a3)
    {
      return 1;
    }
    iv = a1->iv;
    int v10 = EVP_CIPHER_CTX_iv_length(a1);
    memcpy(a1->iv, (const void *)a3, v10);
LABEL_11:
    *(void *)&cipher_data[1].rd_key[1] = iv;
  }
  return 1;
}

uint64_t aes_wrap_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t inlen)
{
  if (!in) {
    return 0;
  }
  if ((inlen & 7) != 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = *(void *)(a1 + 120);
  int v10 = *(_DWORD *)(a1 + 16);
  if (inlen <= 7 && v10) {
    return 0xFFFFFFFFLL;
  }
  BOOL v12 = inlen < 0x10 && v10 == 0;
  uint64_t v6 = 0xFFFFFFFFLL;
  if (!(inlen >> 31) && !v12)
  {
    if (out)
    {
      int v13 = *(const unsigned __int8 **)(v9 + 248);
      if (v10) {
        unsigned int v14 = AES_wrap_key((AES_KEY *)v9, v13, out, in, inlen);
      }
      else {
        unsigned int v14 = AES_unwrap_key((AES_KEY *)v9, v13, out, in, inlen);
      }
      if (v14) {
        return v14;
      }
      else {
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      LODWORD(v6) = inlen - 8;
      if (v10) {
        return (inlen + 8);
      }
      else {
        return v6;
      }
    }
  }
  return v6;
}

uint64_t aes_wrap_ctrl(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if (a2 != 8) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = *(void *)(*(void *)(a1 + 120) + 248);
  if (v4)
  {
    if (a1 + 40 != v4) {
      return 0;
    }
    *(void *)(*(void *)(a4 + 120) + 248) = a4 + 40;
  }
  return 1;
}

void ENGINE_load_builtin_engines(void)
{
  OPENSSL_init_crypto(0);
  pthread_once(&ENGINE_load_builtin_engines_once, (void (*)(void))ENGINE_load_builtin_engines_internal);
}

uint64_t EVP_aes_128_cbc_hmac_sha1()
{
  return 0;
}

uint64_t EVP_aes_256_cbc_hmac_sha1()
{
  return 0;
}

const EC_METHOD *EC_GFp_mont_method(void)
{
  return (const EC_METHOD *)&ec_GFp_mont_method;
}

uint64_t ec_GFp_mont_group_init(uint64_t a1)
{
  uint64_t result = ec_GFp_simple_group_init(a1);
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 2++*(_DWORD *)(*(void *)(result + 8) + 16) = 0;
  return result;
}

void ec_GFp_mont_group_finish(uint64_t a1)
{
  BN_MONT_CTX_free(*(BN_MONT_CTX **)(a1 + 208));
  *(void *)(a1 + 208) = 0;
  BN_free(*(BIGNUM **)(a1 + 216));
  *(void *)(a1 + 2++*(_DWORD *)(*(void *)(result + 8) + 16) = 0;
  ec_GFp_simple_group_finish(a1);
}

BN_MONT_CTX *ec_GFp_mont_group_copy(uint64_t a1, uint64_t a2)
{
  BN_MONT_CTX_free(*(BN_MONT_CTX **)(a1 + 208));
  *(void *)(a1 + 208) = 0;
  BN_free(*(BIGNUM **)(a1 + 216));
  *(void *)(a1 + 2++*(_DWORD *)(*(void *)(result + 8) + 16) = 0;
  uint64_t result = (BN_MONT_CTX *)ec_GFp_simple_group_copy(a1, a2);
  if (result)
  {
    if (*(void *)(a2 + 208))
    {
      uint64_t result = BN_MONT_CTX_new();
      *(void *)(a1 + 208) = result;
      if (!result) {
        return result;
      }
      if (!BN_MONT_CTX_copy(result, *(BN_MONT_CTX **)(a2 + 208))) {
        goto LABEL_8;
      }
    }
    uint64_t v5 = *(const BIGNUM **)(a2 + 216);
    if (v5 && (uint64_t v6 = BN_dup(v5), (*(void *)(a1 + 216) = v6) == 0))
    {
LABEL_8:
      uint64_t result = *(BN_MONT_CTX **)(a1 + 208);
      if (result)
      {
        BN_MONT_CTX_free(result);
        uint64_t result = 0;
        *(void *)(a1 + 208) = 0;
      }
    }
    else
    {
      return (BN_MONT_CTX *)1;
    }
  }
  return result;
}

uint64_t ec_GFp_mont_group_set_curve(uint64_t a1, BIGNUM *a2, const BIGNUM *a3, const BIGNUM *a4, BN_CTX *a5)
{
  BN_MONT_CTX_free(*(BN_MONT_CTX **)(a1 + 208));
  *(void *)(a1 + 208) = 0;
  BN_free(*(BIGNUM **)(a1 + 216));
  *(void *)(a1 + 2++*(_DWORD *)(*(void *)(result + 8) + 16) = 0;
  int v10 = BN_MONT_CTX_new();
  unint64_t v11 = v10;
  if (!v10) {
    goto LABEL_8;
  }
  if (!BN_MONT_CTX_set(v10, a2, a5))
  {
    ERR_put_error(16, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_mont.c", 140);
LABEL_8:
    BOOL v12 = 0;
LABEL_9:
    uint64_t v14 = 0;
    goto LABEL_10;
  }
  BOOL v12 = BN_new();
  if (!v12) {
    goto LABEL_9;
  }
  int v13 = BN_value_one();
  if (!BN_to_montgomery(v12, v13, (uint64_t)v11, a5)) {
    goto LABEL_9;
  }
  *(void *)(a1 + 208) = v11;
  *(void *)(a1 + 2++*(_DWORD *)(*(void *)(result + 8) + 16) = v12;
  uint64_t v14 = ec_GFp_simple_group_set_curve(a1, a2, a3, a4, a5);
  if (v14)
  {
    unint64_t v11 = 0;
    BOOL v12 = 0;
  }
  else
  {
    BN_MONT_CTX_free(*(BN_MONT_CTX **)(a1 + 208));
    *(void *)(a1 + 208) = 0;
    BN_free(*(BIGNUM **)(a1 + 216));
    unint64_t v11 = 0;
    BOOL v12 = 0;
    *(void *)(a1 + 2++*(_DWORD *)(*(void *)(result + 8) + 16) = 0;
  }
LABEL_10:
  BN_MONT_CTX_free(v11);
  BN_free(v12);
  return v14;
}

uint64_t ec_GFp_mont_field_mul(uint64_t a1, BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *a5)
{
  uint64_t v5 = *(BN_MONT_CTX **)(a1 + 208);
  if (v5)
  {
    return BN_mod_mul_montgomery(r, a, b, v5, a5);
  }
  else
  {
    ERR_put_error(16, 4095, 111, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_mont.c", 170);
    return 0;
  }
}

uint64_t ec_GFp_mont_field_sqr(uint64_t a1, BIGNUM *r, BIGNUM *a, BN_CTX *ctx)
{
  uint64_t v5 = *(BN_MONT_CTX **)(a1 + 208);
  if (v5)
  {
    return BN_mod_mul_montgomery(r, a, a, v5, ctx);
  }
  else
  {
    ERR_put_error(16, 4095, 111, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_mont.c", 181);
    return 0;
  }
}

uint64_t ec_GFp_mont_field_encode(uint64_t a1, BIGNUM *a2, const BIGNUM *a3, BN_CTX *a4)
{
  uint64_t v4 = *(void *)(a1 + 208);
  if (v4)
  {
    return BN_to_montgomery(a2, a3, v4, a4);
  }
  else
  {
    ERR_put_error(16, 4095, 111, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_mont.c", 192);
    return 0;
  }
}

uint64_t ec_GFp_mont_field_decode(uint64_t a1, BIGNUM *r, BIGNUM *a, BN_CTX *a4)
{
  uint64_t v4 = *(BN_MONT_CTX **)(a1 + 208);
  if (v4)
  {
    return BN_from_montgomery(r, a, v4, a4);
  }
  else
  {
    ERR_put_error(16, 4095, 111, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_mont.c", 203);
    return 0;
  }
}

BOOL ec_GFp_mont_field_set_to_one(uint64_t a1, BIGNUM *a2)
{
  uint64_t v2 = *(const BIGNUM **)(a1 + 216);
  if (v2) {
    return bn_copy(a2, v2);
  }
  ERR_put_error(16, 4095, 111, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_mont.c", 213);
  return 0;
}

int ASN1_item_ndef_i2d(ASN1_VALUE *val, unsigned __int8 **out, const ASN1_ITEM *it)
{
  return asn1_item_flags_i2d(val, out, (ASN1_ITEM *)it, 2048);
}

uint64_t asn1_item_flags_i2d(ASN1_VALUE *a1, unsigned __int8 **out, ASN1_ITEM *it, int aclass)
{
  punint64_t val = a1;
  if (!out || *out) {
    return ASN1_item_ex_i2d(&pval, out, it, -1, aclass);
  }
  uint64_t v7 = ASN1_item_ex_i2d(&pval, 0, it, -1, aclass);
  if ((int)v7 >= 1)
  {
    uint64_t v9 = (unsigned __int8 *)malloc_type_calloc(1uLL, v7, 0x9799F1EFuLL);
    if (v9)
    {
      int v10 = v9;
      unint64_t v11 = v9;
      if (ASN1_item_ex_i2d(&pval, &v11, it, -1, aclass) == v7)
      {
        unsigned __int8 *out = v10;
        return v7;
      }
      freezero(v10, v7);
      ERR_put_error(13, 4095, 136, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_enc.c", 124);
    }
    return 0xFFFFFFFFLL;
  }
  return v7;
}

int ASN1_item_i2d(ASN1_VALUE *val, unsigned __int8 **out, const ASN1_ITEM *it)
{
  return asn1_item_flags_i2d(val, out, (ASN1_ITEM *)it, 0);
}

int ASN1_item_ex_i2d(ASN1_VALUE **pval, unsigned __int8 **out, const ASN1_ITEM *it, int tag, int aclass)
{
  int v5 = aclass;
  int v6 = tag;
  uint64_t v7 = it;
  int v8 = out;
  uint64_t v9 = pval;
  funcunsigned int s = it->funcs;
  int itype = it->itype;
  if (!it->itype || *pval)
  {
    if (funcs) {
      BOOL v12 = (unsigned int (*)(uint64_t, ASN1_VALUE **, const ASN1_ITEM *, void))*((void *)funcs + 3);
    }
    else {
      BOOL v12 = 0;
    }
    int v13 = 0;
    LOBYTE(v14) = 0;
    switch(it->itype)
    {
      case 0:
        templateunsigned int s = (int *)it->templates;
        if (templates) {
          goto LABEL_8;
        }
        it = v7;
        goto LABEL_41;
      case 1:
        goto LABEL_22;
      case 2:
        if (tag != -1)
        {
          int v17 = 182;
          goto LABEL_18;
        }
        if (v12 && !v12(6, pval, it, 0)) {
          return 0;
        }
        unsigned int choice_selector = asn1_get_choice_selector(v9, v7);
        if ((choice_selector & 0x80000000) != 0 || v7->tcount <= choice_selector)
        {
          if (v12) {
            v12(7, v9, v7, 0);
          }
          return 0;
        }
        int v28 = &v7->templates[choice_selector];
        punint64_t val = asn1_get_field_ptr(v9, v28);
        unsigned __int8 out = v8;
        templateunsigned int s = (int *)v28;
        tag = -1;
LABEL_8:
        return asn1_template_ex_i2d((STACK **)pval, out, templates, tag, v5);
      case 4:
        uint64_t v18 = (uint64_t (*)(void))*((void *)funcs + 5);
        return v18();
      case 5:
        if (tag == -1)
        {
          tag = -1;
LABEL_41:
          return asn1_i2d_ex_primitive(pval, out, (ASN1_ITEM *)it, tag, aclass);
        }
        int v17 = 170;
LABEL_18:
        ERR_put_error(13, 4095, 230, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/tasn_enc.c", v17);
        return 0;
      case 6:
        int v14 = (unsigned __int16)(aclass & 0x800) >> 11;
        if ((aclass & 0x800) != 0) {
          int itype = 2;
        }
        else {
          int itype = 1;
        }
LABEL_22:
        int len = 0;
        int v19 = asn1_enc_restore(&len, out, pval, it);
        if (v19 < 0) {
          return 0;
        }
        if (v19) {
          return len;
        }
        int len = 0;
        if (v6 == -1)
        {
          v5 &= 0xFFFFFF3F;
          int v6 = 16;
        }
        if (v12 && !v12(6, v9, v7, 0)) {
          return 0;
        }
        if (v7->tcount <= 0)
        {
          int v26 = len;
        }
        else
        {
          tagEVP_CIPHER_CTX a = v6;
          uint64_t v20 = 0;
          unsigned int v21 = v7->templates;
          do
          {
            unint64_t v22 = asn1_do_adb(v9, v21, 1);
            if (!v22) {
              return 0;
            }
            int v23 = (int *)v22;
            field_ptr = (STACK **)asn1_get_field_ptr(v9, v22);
            int v25 = asn1_template_ex_i2d(field_ptr, 0, v23, -1, v5);
            int v26 = len + v25;
            len += v25;
            ++v21;
            ++v20;
          }
          while (v7->tcount > v20);
          int v6 = taga;
        }
        int v13 = ASN1_object_size(itype, v26, v6);
        if (!v8) {
          return v13;
        }
        ASN1_put_object(v8, itype, len, v6, v5);
        if (v7->tcount < 1) {
          goto LABEL_54;
        }
        uint64_t v29 = 0;
        uint64_t v30 = v7->templates;
        break;
      default:
        return v13;
    }
    while (1)
    {
      unint64_t v31 = asn1_do_adb(v9, v30, 1);
      if (!v31) {
        break;
      }
      unint64_t v32 = (int *)v31;
      int v33 = (STACK **)asn1_get_field_ptr(v9, v31);
      asn1_template_ex_i2d(v33, v8, v32, -1, v5);
      ++v30;
      if (v7->tcount <= ++v29)
      {
LABEL_54:
        if (v14) {
          ASN1_put_eoc(v8);
        }
        if (!v12 || v12(7, v9, v7, 0)) {
          return v13;
        }
        return 0;
      }
    }
  }
  return 0;
}

uint64_t asn1_template_ex_i2d(STACK **pval, unsigned __int8 **out, int *a3, int tag, int a5)
{
  int v5 = tag;
  int v9 = *a3;
  if ((*a3 & 0x18) != 0)
  {
    if (tag != -1) {
      return 0xFFFFFFFFLL;
    }
    int v5 = a3[2];
    int v11 = *a3 & 0xC0;
  }
  else if (tag == -1)
  {
    int v11 = 0;
  }
  else
  {
    int v11 = a5 & 0xC0;
  }
  unsigned int v12 = a5 & 0xFFFFFF3F;
  int v13 = (unsigned __int16)a5 & (unsigned __int16)v9 & 0x800;
  if (((unsigned __int16)a5 & (unsigned __int16)v9 & 0x800) != 0) {
    int v14 = 2;
  }
  else {
    int v14 = 1;
  }
  if ((v9 & 6) != 0)
  {
    int v15 = *pval;
    pvalEVP_CIPHER_CTX a = 0;
    if (v15)
    {
      BOOL v16 = v5 != -1;
      BOOL v17 = (v9 & 0x10) == 0;
      if ((v9 & 2) != 0) {
        int v18 = 17;
      }
      else {
        int v18 = 16;
      }
      BOOL v19 = !v17 || !v16;
      if (v17 && v16) {
        int v20 = v5;
      }
      else {
        int v20 = v18;
      }
      tagEVP_CIPHER_CTX a = v20;
      if (v19) {
        int v21 = 0;
      }
      else {
        int v21 = v11;
      }
      xclasunsigned int s = v21;
      int v46 = (unsigned __int16)a5 & (unsigned __int16)v9 & 0x800;
      int v22 = 0;
      if (sk_num(v15) >= 1)
      {
        int v23 = 0;
        do
        {
          pvalEVP_CIPHER_CTX a = (ASN1_VALUE *)sk_value(v15, v23);
          v22 += ASN1_item_ex_i2d(&pvala, 0, *((const ASN1_ITEM **)a3 + 4), -1, v12);
          ++v23;
        }
        while (v23 < sk_num(v15));
      }
      uint64_t v10 = ASN1_object_size(v14, v22, taga);
      if ((v9 & 0x10) != 0)
      {
        uint64_t v26 = ASN1_object_size(v14, v10, v5);
        int v27 = v10;
        uint64_t v10 = v26;
        if (!out) {
          return v10;
        }
        ASN1_put_object(out, v14, v27, v5, v11);
      }
      else if (!out)
      {
        return v10;
      }
      ASN1_put_object(out, v14, v22, taga, xclass);
      int v28 = (const ASN1_ITEM *)*((void *)a3 + 4);
      uint64_t v51 = 0;
      if ((v9 & 2) != 0 && sk_num(v15) > 1)
      {
        tagint b = v10;
        int v33 = sk_num(v15);
        int v34 = (char **)reallocarray(0, v33, 0x18uLL);
        uint64_t v35 = (unsigned __int8 *)malloc_type_malloc(v22, 0x52712E22uLL);
        unint64_t v36 = v35;
        if (v34 && v35)
        {
          outEVP_CIPHER_CTX a = v35;
          if (sk_num(v15) >= 1)
          {
            int v37 = 0;
            unint64_t v38 = v34;
            do
            {
              uint64_t v51 = (ASN1_VALUE *)sk_value(v15, v37);
              *unint64_t v38 = (char *)outa;
              *((_DWORD *)v38 + 2) = ASN1_item_ex_i2d(&v51, &outa, v28, -1, v12);
              v38[2] = (char *)v51;
              ++v37;
              v38 += 3;
            }
            while (v37 < sk_num(v15));
          }
          int v39 = sk_num(v15);
          qsort(v34, v39, 0x18uLL, (int (__cdecl *)(const void *, const void *))der_cmp);
          outEVP_CIPHER_CTX a = *out;
          if (sk_num(v15) >= 1)
          {
            int v40 = 0;
            uint64_t v41 = v34;
            do
            {
              memcpy(outa, *v41, *((int *)v41 + 2));
              outa += *((int *)v41 + 2);
              ++v40;
              v41 += 3;
            }
            while (v40 < sk_num(v15));
          }
          unsigned __int8 *out = outa;
          if ((v9 & 4) != 0 && sk_num(v15) >= 1)
          {
            int v42 = 0;
            int v43 = v34 + 2;
            do
            {
              int v44 = *v43;
              v43 += 3;
              sk_set(v15, v42++, v44);
            }
            while (v42 < sk_num(v15));
          }
        }
        free(v34);
        free(v36);
        uint64_t v10 = tagb;
      }
      else if (sk_num(v15) >= 1)
      {
        int v29 = 0;
        do
        {
          uint64_t v51 = (ASN1_VALUE *)sk_value(v15, v29);
          ASN1_item_ex_i2d(&v51, out, v28, -1, v12);
          ++v29;
        }
        while (v29 < sk_num(v15));
      }
      if (v46)
      {
        ASN1_put_eoc(out);
        if ((v9 & 0x10) != 0) {
          ASN1_put_eoc(out);
        }
      }
      return v10;
    }
    return 0;
  }
  unint64_t v24 = (const ASN1_ITEM *)*((void *)a3 + 4);
  if ((v9 & 0x10) != 0)
  {
    int v30 = ASN1_item_ex_i2d((ASN1_VALUE **)pval, 0, v24, -1, a5 & 0xFFFFFF3F);
    if (v30)
    {
      int v31 = v30;
      uint64_t v32 = ASN1_object_size(v14, v30, v5);
      if (out)
      {
        ASN1_put_object(out, v14, v31, v5, v11);
        ASN1_item_ex_i2d((ASN1_VALUE **)pval, out, *((const ASN1_ITEM **)a3 + 4), -1, v12);
        if (v13) {
          ASN1_put_eoc(out);
        }
      }
      return v32;
    }
    return 0;
  }
  return ASN1_item_ex_i2d((ASN1_VALUE **)pval, out, v24, v5, v11 | v12);
}

uint64_t asn1_i2d_ex_primitive(ASN1_VALUE **a1, unsigned __int8 **a2, ASN1_ITEM *it, int a4, int a5)
{
  punint64_t utype = it->utype;
  unsigned int v10 = asn1_ex_i2c(a1, 0, &putype, it);
  if (v10 == -1) {
    return 0;
  }
  unsigned int v11 = v10;
  if (v10 == -2) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = v10;
  }
  if ((v12 & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  int v13 = putype;
  int v14 = 2 * (v10 == -2);
  if (a4 == -1) {
    a4 = putype;
  }
  if (!a2) {
    goto LABEL_21;
  }
  if ((putype + 3) > 0x14 || ((1 << (putype + 3)) & 0x180001) == 0) {
    ASN1_put_object(a2, v14, v12, a4, a5);
  }
  if (asn1_ex_i2c(a1, *a2, &putype, it) != v11) {
    return 0xFFFFFFFFLL;
  }
  if (v11 == -2) {
    ASN1_put_eoc(a2);
  }
  else {
    *a2 += v11;
  }
LABEL_21:
  if ((v13 + 3) > 0x14 || ((1 << (v13 + 3)) & 0x180001) == 0) {
    return ASN1_object_size(v14, v12, a4);
  }
  return v12;
}

int ASN1_template_i2d(ASN1_VALUE **pval, unsigned __int8 **out, const ASN1_TEMPLATE *tt)
{
  return asn1_template_ex_i2d((STACK **)pval, out, (int *)tt, -1, 0);
}

uint64_t der_cmp(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  int v3 = *(_DWORD *)(a2 + 8);
  unsigned int v4 = v2 - v3;
  if (v2 >= v3) {
    int v2 = *(_DWORD *)(a2 + 8);
  }
  LODWORD(result) = memcmp(*(const void **)a1, *(const void **)a2, v2);
  if (result) {
    return result;
  }
  else {
    return v4;
  }
}

int asn1_ex_i2c(ASN1_VALUE **pval, unsigned __int8 *cont, int *putype, const ASN1_ITEM *it)
{
  int v21 = cont;
  funcunsigned int s = it->funcs;
  if (!funcs)
  {
    if (it->itype)
    {
      if (!*pval) {
        return -1;
      }
      if (it->itype == 5)
      {
        int v7 = *((_DWORD *)*pval + 1);
LABEL_16:
        *puint64_t utype = v7;
LABEL_18:
        char __src = 0;
        int v11 = 0;
        switch(v7)
        {
          case 1:
            if (*(_DWORD *)pval == -1) {
              return -1;
            }
            if (it->utype == -4) {
              goto LABEL_25;
            }
            uint64_t size = it->size;
            if (*(_DWORD *)pval)
            {
              if (size > 0) {
                return -1;
              }
            }
            else if (!size)
            {
              return -1;
            }
LABEL_25:
            char __src = *(_DWORD *)pval;
            int v11 = 1;
            p_src = &__src;
            goto LABEL_35;
          case 2:
          case 10:
            uint64_t v12 = (ASN1_INTEGER *)*pval;
            if (cont) {
              int v13 = &v21;
            }
            else {
              int v13 = 0;
            }
            return i2c_ASN1_INTEGER(v12, v13);
          case 3:
            BOOL v16 = (ASN1_BIT_STRING *)*pval;
            if (cont) {
              BOOL v17 = &v21;
            }
            else {
              BOOL v17 = 0;
            }
            return i2c_ASN1_BIT_STRING(v16, v17);
          case 5:
            return v11;
          case 6:
            p_src = (char *)*((void *)*pval + 3);
            int v11 = *((_DWORD *)*pval + 5);
            goto LABEL_35;
          default:
            int v18 = *pval;
            if (it->size == 2048 && (*((unsigned char *)v18 + 16) & 0x10) != 0)
            {
              if (cont)
              {
                *((void *)v18 + md5_block_data_order((unint64_t)c, b, 1) = cont;
                *(_DWORD *)int v18 = 0;
              }
              return -2;
            }
            else
            {
              p_src = (char *)*((void *)v18 + 1);
              int v11 = *(_DWORD *)v18;
LABEL_35:
              if (cont && v11) {
                memcpy(cont, p_src, v11);
              }
            }
            return v11;
        }
      }
      uint64_t utype = it->utype;
    }
    else
    {
      uint64_t utype = it->utype;
      if (utype == 1) {
        goto LABEL_17;
      }
      if (!*pval) {
        return -1;
      }
    }
    if (utype == -4)
    {
      int v9 = *pval;
      int v10 = *(_DWORD *)v9;
      punint64_t val = (ASN1_VALUE **)((char *)v9 + 8);
      int v7 = v10;
      goto LABEL_16;
    }
LABEL_17:
    int v7 = *putype;
    goto LABEL_18;
  }
  int v5 = (uint64_t (*)(ASN1_VALUE **, unsigned __int8 *, int *))funcs[6];
  if (v5)
  {
    return v5(pval, cont, putype);
  }
  return -1;
}

void Camellia_cbc_encrypt(void *a1, uint64_t *a2, unint64_t a3, uint64_t a4, _OWORD *a5, int a6)
{
  if (a6) {
    CRYPTO_cbc128_encrypt(a1, a2, a3, a4, a5, (void (*)(void *, void *, uint64_t))Camellia_encrypt);
  }
  else {
    CRYPTO_cbc128_decrypt((uint64_t)a1, a2, a3, a4, a5, (uint64_t (*)(void *, uint64_t *, uint64_t))Camellia_decrypt);
  }
}

BUF_MEM *BUF_MEM_new(void)
{
  uint64_t v0 = (BUF_MEM *)malloc_type_calloc(1uLL, 0x18uLL, 0x1010040A500212DuLL);
  if (!v0) {
    ERR_put_error(7, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/buffer/buffer.c", 79);
  }
  return v0;
}

void BUF_MEM_free(BUF_MEM *a)
{
  if (a)
  {
    freezero(a->data, *(void *)&a->max);
    free(a);
  }
}

int BUF_MEM_grow_clean(BUF_MEM *str, int len)
{
  unint64_t v2 = *(void *)&len;
  unint64_t v4 = *(void *)&str->max;
  if (v4 >= v2)
  {
    if (*(void *)&str->length >= v2) {
      bzero(&str->data[v2], *(void *)&str->length - v2);
    }
  }
  else
  {
    if (v2 >= 0x5FFFFFFD)
    {
      int v5 = 116;
LABEL_10:
      ERR_put_error(7, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/buffer/buffer.c", v5);
      LODWORD(v2) = 0;
      return v2;
    }
    int v6 = recallocarray(str->data, v4, ((2863311531u * (unint64_t)(v2 + 3)) >> 31) & 0x1FFFFFFFCLL, 1uLL);
    if (!v6)
    {
      int v5 = 122;
      goto LABEL_10;
    }
    str->uint64_t data = v6;
    *(void *)&str->max = ((2863311531u * (unint64_t)(v2 + 3)) >> 31) & 0x1FFFFFFFCLL;
  }
  *(void *)&str->int length = v2;
  return v2;
}

char *BUF_reverse(char *result, char *a2, unint64_t a3)
{
  if (a2)
  {
    for (; a3; --a3)
    {
      char v3 = *a2++;
      result[a3 - 1] = v3;
    }
  }
  else if (a3 >= 2)
  {
    unint64_t v4 = a3 >> 1;
    int v5 = &result[a3 - 1];
    do
    {
      char v6 = *v5;
      *v5-- = *result;
      *result++ = v6;
      --v4;
    }
    while (v4);
  }
  return result;
}

unsigned int ENGINE_get_table_flags(void)
{
  return table_flags;
}

void ENGINE_set_table_flags(unsigned int flags)
{
  table_int flags = flags;
}

uint64_t engine_table_register(LHASH **a1, uint64_t a2, char *a3, _DWORD *a4, int a5, int a6)
{
  memset(v19, 0, sizeof(v19));
  CRYPTO_lock(9, 30, 0, 0);
  if (!*a1)
  {
    uint64_t v12 = lh_new((LHASH_HASH_FN_TYPE)engine_pile_LHASH_HASH, (LHASH_COMP_FN_TYPE)engine_pile_LHASH_COMP);
    if (!v12) {
      goto LABEL_19;
    }
    *a1 = v12;
    engine_cleanup_add_first(a2);
  }
  uint64_t v13 = 1;
  if (a5)
  {
    while (1)
    {
      LODWORD(v19[0]) = *a4;
      int v14 = lh_retrieve(*a1, v19);
      if (!v14)
      {
        int v15 = malloc_type_malloc(0x20uLL, 0x10200406A377A34uLL);
        if (!v15) {
          goto LABEL_19;
        }
        int v14 = v15;
        v15[6] = 1;
        _DWORD *v15 = *a4;
        BOOL v16 = sk_new_null();
        *((void *)v14 + md5_block_data_order((unint64_t)c, b, 1) = v16;
        if (!v16)
        {
          free(v14);
LABEL_19:
          uint64_t v13 = 0;
          break;
        }
        *((void *)v14 + 2) = 0;
        lh_insert(*a1, v14);
      }
      sk_delete_ptr(*((STACK **)v14 + 1), a3);
      if (!sk_push(*((STACK **)v14 + 1), a3)) {
        goto LABEL_19;
      }
      *((_DWORD *)v14 + 6) = 0;
      if (a6)
      {
        if (!engine_unlocked_init((uint64_t)a3))
        {
          ERR_put_error(38, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_table.c", 175);
          goto LABEL_19;
        }
        uint64_t v17 = *((void *)v14 + 2);
        if (v17) {
          engine_unlocked_finish(v17, 0);
        }
        *((void *)v14 + 2) = a3;
        *((_DWORD *)v14 + 6) = 1;
      }
      ++a4;
      if (!--a5)
      {
        uint64_t v13 = 1;
        break;
      }
    }
  }
  CRYPTO_lock(10, 30, 0, 0);
  return v13;
}

void engine_table_unregister(LHASH **a1, void *a2)
{
  CRYPTO_lock(9, 30, 0, 0);
  if (*a1) {
    lh_doall_arg(*a1, (LHASH_DOALL_ARG_FN_TYPE)int_unregister_cb_LHASH_DOALL_ARG, a2);
  }
  CRYPTO_lock(10, 30, 0, 0);
}

uint64_t int_unregister_cb_LHASH_DOALL_ARG(uint64_t a1, char *a2)
{
  uint64_t result = sk_find(*(STACK **)(a1 + 8), a2);
  if ((result & 0x80000000) == 0)
  {
    int v5 = result;
    do
    {
      sk_delete(*(STACK **)(a1 + 8), v5);
      *(_DWORD *)(a1 + 24) = 0;
      uint64_t result = sk_find(*(STACK **)(a1 + 8), a2);
      int v5 = result;
    }
    while ((result & 0x80000000) == 0);
  }
  if (*(char **)(a1 + 16) == a2)
  {
    uint64_t result = engine_unlocked_finish((uint64_t)a2, 0);
    *(void *)(a1 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = 0;
  }
  return result;
}

void engine_table_cleanup(LHASH **a1)
{
  CRYPTO_lock(9, 30, 0, 0);
  if (*a1)
  {
    lh_doall(*a1, (LHASH_DOALL_FN_TYPE)int_cleanup_cb_LHASH_DOALL);
    lh_free(*a1);
    *a1 = 0;
  }
  CRYPTO_lock(10, 30, 0, 0);
}

void int_cleanup_cb_LHASH_DOALL(uint64_t a1)
{
  sk_free(*(STACK **)(a1 + 8));
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2) {
    engine_unlocked_finish(v2, 0);
  }
  free((void *)a1);
}

uint64_t engine_table_select(LHASH **a1, int a2)
{
  if (!*a1) {
    return 0;
  }
  memset(v14, 0, sizeof(v14));
  ERR_set_mark();
  CRYPTO_lock(9, 30, 0, 0);
  unint64_t v4 = *a1;
  if (*a1 && (LODWORD(v14[0]) = a2, (int v5 = lh_retrieve(v4, v14)) != 0))
  {
    char v6 = v5;
    uint64_t v7 = v5[2];
    if (v7 && engine_unlocked_init(v7) || *((_DWORD *)v6 + 6))
    {
      uint64_t v8 = v6[2];
    }
    else
    {
      int v10 = 0;
      while (1)
      {
        int v11 = sk_value((const STACK *)v6[1], v10);
        uint64_t v8 = (uint64_t)v11;
        if (!v11) {
          break;
        }
        if (*((int *)v11 + 46) <= 0 && (table_flags & 1) != 0) {
          int v12 = 0;
        }
        else {
          int v12 = engine_unlocked_init((uint64_t)v11);
        }
        ++v10;
        if (v12)
        {
          if (v6[2] != v8 && engine_unlocked_init(v8))
          {
            uint64_t v13 = v6[2];
            if (v13) {
              engine_unlocked_finish(v13, 0);
            }
            unint64_t v6[2] = v8;
          }
          break;
        }
      }
    }
    *((_DWORD *)v6 + 6) = 1;
  }
  else
  {
    uint64_t v8 = 0;
  }
  CRYPTO_lock(10, 30, 0, 0);
  ERR_pop_to_mark();
  return v8;
}

void engine_table_doall(LHASH *a1, uint64_t a2, uint64_t a3)
{
  v3[0] = a2;
  v3[1] = a3;
  lh_doall_arg(a1, (LHASH_DOALL_ARG_FN_TYPE)int_cb_LHASH_DOALL_ARG, v3);
}

uint64_t int_cb_LHASH_DOALL_ARG(unsigned int *a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, void, void, void))a2)(*a1, *((void *)a1 + 1), *((void *)a1 + 2), *(void *)(a2 + 8));
}

uint64_t engine_pile_LHASH_HASH(int *a1)
{
  return *a1;
}

uint64_t engine_pile_LHASH_COMP(_DWORD *a1, _DWORD *a2)
{
  return (*a1 - *a2);
}

int RSA_padding_add_PKCS1_OAEP(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl, const unsigned __int8 *p, int pl)
{
}

void RSA_padding_add_PKCS1_OAEP_mgf1(unsigned char *a1, int a2, const void *a3, int a4, const void *a5, int a6, EVP_MD *md, EVP_MD *a8)
{
  int v9 = md;
  uint64_t v36 = *MEMORY[0x263EF8340];
  if (!md) {
    int v9 = (EVP_MD *)EVP_sha1();
  }
  if (!a8) {
    a8 = v9;
  }
  int v16 = EVP_MD_size(v9);
  if (v16 >= 1)
  {
    unsigned int v17 = v16;
    dgst = a8;
    int v18 = a2 - 1;
    int v19 = ~(2 * v16);
    if (a2 - 1 + v19 < a4)
    {
      int v20 = 110;
      int v21 = 115;
LABEL_20:
      ERR_put_error(4, 4095, v20, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_oaep.c", v21);
      goto LABEL_21;
    }
    if (((2 * v16) | 1) >= a2)
    {
      int v20 = 120;
      int v21 = 120;
      goto LABEL_20;
    }
    *a1 = 0;
    int v22 = a1 + 1;
    int v23 = &v22[v16];
    if (EVP_Digest(a5, a6, v23, 0, v9, 0))
    {
      uint64_t v24 = v17;
      bzero(&v23[v17], v18 - a4 + v19);
      v23[v18 - a4 + ~v17] = 1;
      memcpy(&v23[v18 - a4 - v17], a3, a4);
      arc4random_buf(v22, v17);
      uint64_t v25 = v18 - v17;
      uint64_t v26 = (unsigned __int8 *)malloc_type_malloc((int)v25, 0xABE65EDCuLL);
      int v27 = v26;
      if (v26)
      {
        if ((PKCS1_MGF1(v26, (int)v25, v22, v24, dgst) & 0x80000000) == 0)
        {
          if ((int)v25 >= 1)
          {
            uint64_t v28 = v25;
            int v29 = v27;
            int v30 = v23;
            do
            {
              char v31 = *v29++;
              *v30++ ^= v31;
              --v28;
            }
            while (v28);
          }
          if ((PKCS1_MGF1(mask, v24, v23, (int)v25, dgst) & 0x80000000) == 0)
          {
            uint64_t v32 = mask;
            do
            {
              char v33 = *v32++;
              *v22++ ^= v33;
              --v24;
            }
            while (v24);
          }
        }
      }
      else
      {
        ERR_put_error(4, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_oaep.c", 138);
      }
    }
  }
LABEL_21:
  explicit_bzero(mask, 0x40uLL);
}

int PKCS1_MGF1(unsigned __int8 *mask, uint64_t len, const unsigned __int8 *seed, uint64_t seedlen, const EVP_MD *dgst)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  long long v18 = 0u;
  memset(&v17, 0, sizeof(v17));
  EVP_MD_CTX_init(&v17);
  unsigned int v10 = EVP_MD_size(dgst);
  if ((v10 & 0x80000000) != 0)
  {
LABEL_14:
    int v15 = -1;
    goto LABEL_15;
  }
  if (len >= 1)
  {
    uint64_t v11 = 0;
    unsigned int v12 = 0;
    uint64_t v13 = v10;
    do
    {
      unsigned int d = bswap32(v12);
      if (!EVP_DigestInit_ex(&v17, dgst, 0)
        || !EVP_DigestUpdate(&v17, seed, seedlen)
        || !EVP_DigestUpdate(&v17, &d, 4uLL))
      {
        goto LABEL_14;
      }
      uint64_t v14 = v11 + v13;
      if (v11 + v13 > len)
      {
        if (!EVP_DigestFinal_ex(&v17, md, 0)) {
          goto LABEL_14;
        }
        memcpy(&mask[v11], md, len - v11);
        break;
      }
      if (!EVP_DigestFinal_ex(&v17, &mask[v11], 0)) {
        goto LABEL_14;
      }
      ++v12;
      v11 += v13;
    }
    while (v14 < len);
  }
  int v15 = 0;
LABEL_15:
  EVP_MD_CTX_cleanup(&v17);
  return v15;
}

int RSA_padding_check_PKCS1_OAEP(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl, int rsa_len, const unsigned __int8 *p, int pl)
{
  return RSA_padding_check_PKCS1_OAEP_mgf1(to, tlen, (uint64_t)f, fl, rsa_len, p, pl, 0, 0);
}

uint64_t RSA_padding_check_PKCS1_OAEP_mgf1(unsigned char *a1, int a2, uint64_t a3, int a4, int a5, const void *a6, int a7, EVP_MD *md, const EVP_MD *a9)
{
  int v9 = md;
  EVP_MD_CTX v17 = a9;
  uint64_t v55 = *MEMORY[0x263EF8340];
  if (!md) {
    int v9 = (EVP_MD *)EVP_sha1();
  }
  if (!a9) {
    EVP_MD_CTX v17 = v9;
  }
  int v18 = EVP_MD_size(v9);
  if (v18 < 1) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v19 = v18;
  uint64_t result = 0xFFFFFFFFLL;
  if (a2 >= 1 && a4 >= 1)
  {
    if (a5 >= a4 && (int)(2 * v19 + 2) <= a5)
    {
      seedint len = (int)(~v19 + a5);
      uint64_t v51 = (unsigned __int8 *)malloc_type_malloc(seedlen, 0x20011BAFuLL);
      if (v51)
      {
        int v50 = a1;
        uint64_t v21 = (char *)malloc_type_malloc(a5, 0xC0B13CBAuLL);
        if (v21)
        {
          int v22 = 0;
          int v23 = &v21[a5];
          uint64_t v24 = (unsigned __int8 *)(a3 + a4);
          do
          {
            uint64_t v25 = v23;
            uint64_t v26 = a4 != 0;
            v24 -= v26;
            unsigned __int8 v27 = *v24;
            if (!a4) {
              unsigned __int8 v27 = 0;
            }
            a4 -= v26;
            *--int v23 = v27;
            ++v22;
          }
          while (v22 != a5);
          int v28 = v27 - 1;
          if (!PKCS1_MGF1(mask, v19, (const unsigned __int8 *)&v25[v19], seedlen, v17))
          {
            for (uint64_t i = 0; i != v19; ++i)
              mask[i] ^= v23[i + 1];
            if (!PKCS1_MGF1(v51, seedlen, mask, v19, v17))
            {
              if ((int)seedlen >= 1)
              {
                uint64_t v30 = ~v19 + a5;
                uint64_t v31 = v19 + 1;
                uint64_t v32 = v51;
                do
                {
                  *v32++ ^= v23[v31++];
                  --v30;
                }
                while (v30);
              }
              if (EVP_Digest(a6, a7, mda, 0, v9, 0))
              {
                int v33 = timingsafe_memcmp(v51, mda, v19);
                int v34 = ((v33 - 1) & ~v33 & v28) >> 31;
                if ((int)v19 >= (int)seedlen)
                {
                  int v35 = 0;
                  int v41 = 1;
                  int v38 = ~v19;
                }
                else
                {
                  int v35 = 0;
                  int v36 = 0;
                  int v37 = &v51[v19];
                  int v38 = ~v19;
                  do
                  {
                    int v39 = *v37++;
                    int v40 = (v39 ^ 1) - 1;
                    int v36 = v36 & ~((v40 >> 31) & ~v35) | (v40 >> 31) & ~v35 & v19;
                    v35 |= v40 >> 31;
                    v34 &= v35 | ((v39 - 1) >> 31);
                    ++v19;
                  }
                  while ((int)seedlen > (int)v19);
                  int v41 = v36 + 1;
                }
                if ((int)(((a2 - (seedlen - v41)) ^ (seedlen - v41) | (seedlen - v41) ^ a2) ^ a2) < 0) {
                  int v35 = 0;
                }
                int v42 = v35 & v34;
                LODWORD(v43) = seedlen + v38;
                if ((int)(((v43 - a2) ^ a2 | v43 ^ a2) ^ v43) >= 0) {
                  uint64_t v43 = a2;
                }
                else {
                  uint64_t v43 = v43;
                }
                int v44 = (seedlen - v43) & ~v42 | v42 & v41;
                int v45 = v50;
                if ((int)v43 >= 1)
                {
                  uint64_t v46 = v43;
                  char v47 = v42;
                  do
                  {
                    if (v44 == seedlen) {
                      int v48 = v43;
                    }
                    else {
                      int v48 = 0;
                    }
                    if (v44 == seedlen) {
                      char v47 = 0;
                    }
                    int v49 = v44 - v48;
                    int v44 = v49 + 1;
                    *int v45 = *v45 & ~v47 | v51[v49] & v47;
                    ++v45;
                    --v46;
                  }
                  while (v46);
                }
                ERR_put_error(4, 4095, 121, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_oaep.c", 308);
                err_clear_last_constant_time(v42 & 1);
              }
            }
          }
        }
        else
        {
          ERR_put_error(4, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_oaep.c", 211);
        }
      }
      else
      {
        ERR_put_error(4, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_oaep.c", 207);
      }
      explicit_bzero(mask, 0x40uLL);
    }
    ERR_put_error(4, 4095, 121, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_oaep.c", 201);
    return 0xFFFFFFFFLL;
  }
  return result;
}

int DSA_generate_parameters_ex(DSA *dsa, int bits, unsigned __int8 *seed, int seed_len, int *counter_ret, unint64_t *h_ret, BN_GENCB *cb)
{
  uint64_t v14 = *(uint64_t (**)(void))&dsa->ex_data.sk[2].sorted;
  if (v14)
  {
    return v14();
  }
  else
  {
    if (bits < 2048)
    {
      unint64_t v16 = 160;
      EVP_MD_CTX v17 = EVP_sha1();
    }
    else
    {
      unint64_t v16 = 256;
      EVP_MD_CTX v17 = EVP_sha256();
    }
    return dsa_builtin_paramgen((BIGNUM **)dsa, bits, v16, v17, (uint64_t)seed, seed_len, 0, counter_ret, h_ret, cb);
  }
}

BOOL dsa_builtin_paramgen(BIGNUM **a1, unint64_t a2, unint64_t a3, const EVP_MD *a4, uint64_t a5, unint64_t a6, void *a7, int *a8, void *a9, BN_GENCB *a10)
{
  BOOL v10 = 0;
  uint64_t v78 = *MEMORY[0x263EF8340];
  unint64_t v11 = a3 >> 3;
  if ((a3 >> 3) > 0x20) {
    return v10;
  }
  uint64_t v12 = (a3 >> 3);
  if (((1 << (a3 >> 3)) & 0x110100000) == 0) {
    return v10;
  }
  unint64_t v16 = a4;
  if (!a4) {
    unint64_t v16 = EVP_sha1();
  }
  if (a2 <= 0x200) {
    uint64_t v19 = 512;
  }
  else {
    uint64_t v19 = a2;
  }
  size_t v20 = (int)v11;
  if ((int)v11 <= a6) {
    unint64_t v21 = a6;
  }
  else {
    unint64_t v21 = 0;
  }
  if (v21 >= (int)v11) {
    unint64_t v22 = (int)v11;
  }
  else {
    unint64_t v22 = v21;
  }
  if (a5 && (int)v11 <= a6)
  {
    __memcpy_chk();
    goto LABEL_19;
  }
  if (!v22)
  {
LABEL_19:
    uint64_t v24 = BN_MONT_CTX_new();
    if (v24)
    {
      uint64_t v25 = BN_CTX_new();
      int v23 = v25;
      if (v25)
      {
        BN_CTX_start(v25);
        unint64_t v72 = BN_CTX_get(v23);
        if (v72)
        {
          uint64_t v26 = BN_CTX_get(v23);
          if (v26)
          {
            unint64_t v71 = v26;
            unsigned __int8 v27 = BN_CTX_get(v23);
            if (v27)
            {
              EVP_CIPHER_CTX a = v27;
              int v28 = BN_CTX_get(v23);
              if (v28)
              {
                ret = v28;
                int v29 = BN_CTX_get(v23);
                if (v29)
                {
                  uint64_t v68 = v29;
                  uint64_t v30 = BN_CTX_get(v23);
                  if (v30)
                  {
                    uint64_t v63 = v30;
                    uint64_t v31 = BN_CTX_get(v23);
                    if (v31)
                    {
                      r = v31;
                      uint64_t v32 = BN_CTX_get(v23);
                      if (v32)
                      {
                        unint64_t v66 = (v19 + 63) & 0xFFFFFFFFFFFFFFC0;
                        int v33 = v32;
                        int v34 = BN_value_one();
                        int b = v33;
                        if (BN_lshift(v33, v34, v66 - 1))
                        {
                          int v35 = 0;
                          int n = v66 - 1;
                          int v36 = a10;
                          unint64_t v67 = (v66 - 1) / 0xA0;
LABEL_31:
                          while (1)
                          {
                            int v64 = v35;
                            if (!BN_GENCB_call(v36, 0, v35)) {
                              break;
                            }
                            if (v22)
                            {
                              int v37 = 0;
                            }
                            else
                            {
                              arc4random_buf(__buf, (int)v11);
                              int v37 = 1;
                            }
                            int v65 = v64 + 1;
                            __memcpy_chk();
                            __memcpy_chk();
                            int v38 = v11 - 1;
                            do
                            {
                              __int16 v39 = ++data[v38];
                              if ((v39 & 0x100) == 0) {
                                break;
                              }
                            }
                            while (v38-- > 0);
                            if (!EVP_Digest(__buf, (int)v11, md, 0, v16, 0)) {
                              break;
                            }
                            if (!EVP_Digest(data, (int)v11, v74, 0, v16, 0)) {
                              break;
                            }
                            uint64_t v41 = 0;
                            do
                            {
                              md[v41] ^= v74[v41];
                              ++v41;
                            }
                            while (v12 != v41);
                            md[0] |= 0x80u;
                            md[(v11 - 1)] |= 1u;
                            if (!BN_bin2bn(md, v11, ret)) {
                              break;
                            }
                            int v36 = a10;
                            int is_prime_fasttest = BN_is_prime_fasttest_ex(ret, 64, v23, v37, a10);
                            if (is_prime_fasttest > 0)
                            {
                              if (BN_GENCB_call(a10, 2, 0) && BN_GENCB_call(a10, 3, 0))
                              {
                                int v43 = 0;
                                uint64_t v44 = (uint64_t)a;
                                while (1)
                                {
                                  if (v43)
                                  {
                                    int v45 = BN_GENCB_call(a10, 0, v43);
                                    uint64_t v44 = (uint64_t)a;
                                    if (!v45) {
                                      break;
                                    }
                                  }
                                  int v60 = v43;
                                  BN_zero(v44);
                                  if ((v67 & 0x80000000) == 0)
                                  {
                                    int v46 = 0;
                                    do
                                    {
                                      uint64_t v47 = v12;
                                      do
                                      {
                                        if ((int)v47 < 1) {
                                          break;
                                        }
                                        int v48 = &data[v47--];
                                        __int16 v49 = ++*(v48 - 1);
                                      }
                                      while ((v49 & 0x100) != 0);
                                      if (!EVP_Digest(data, (int)v11, md, 0, v16, 0)
                                        || !BN_bin2bn(md, v11, v72)
                                        || !BN_lshift(v72, v72, 8 * v11 * v46)
                                        || !BN_add(a, a, v72))
                                      {
                                        goto LABEL_76;
                                      }
                                    }
                                    while (v46++ != v67);
                                  }
                                  if (!BN_mask_bits(a, n)) {
                                    goto LABEL_76;
                                  }
                                  if (!bn_copy(v68, a)) {
                                    goto LABEL_76;
                                  }
                                  if (!BN_add(v68, v68, b)) {
                                    goto LABEL_76;
                                  }
                                  if (!BN_lshift1(v72, ret)) {
                                    goto LABEL_76;
                                  }
                                  if (!BN_mod_ct(v63, v68, v72, v23)) {
                                    goto LABEL_76;
                                  }
                                  uint64_t v51 = BN_value_one();
                                  if (!BN_sub(v72, v63, v51) || !BN_sub(r, v68, v72)) {
                                    goto LABEL_76;
                                  }
                                  if ((BN_cmp(r, b) & 0x80000000) == 0)
                                  {
                                    int v52 = BN_is_prime_fasttest_ex(r, 64, v23, 1, a10);
                                    if (v52 > 0)
                                    {
                                      if (!BN_GENCB_call(a10, 2, 1)) {
                                        goto LABEL_76;
                                      }
                                      int v54 = BN_value_one();
                                      if (!BN_sub(b, r, v54)
                                        || !BN_div_ct((uint64_t)v72, 0, b, ret, v23)
                                        || !BN_set_word(b, 2uLL)
                                        || !BN_MONT_CTX_set(v24, r, v23)
                                        || !BN_mod_exp_mont_ct(v71, b, v72, r, v23, v24))
                                      {
                                        goto LABEL_76;
                                      }
                                      unsigned int v55 = 2;
                                      while (BN_is_one((uint64_t)v71))
                                      {
                                        int v56 = BN_value_one();
                                        if (BN_add(b, b, v56))
                                        {
                                          ++v55;
                                          if (BN_mod_exp_mont_ct(v71, b, v72, r, v23, v24)) {
                                            continue;
                                          }
                                        }
                                        goto LABEL_76;
                                      }
                                      int v57 = BN_GENCB_call(a10, 3, 1);
                                      BOOL v10 = v57 != 0;
                                      if (v57)
                                      {
                                        BN_free(a1[2]);
                                        BN_free(a1[3]);
                                        BN_free(a1[4]);
                                        a1[2] = BN_dup(r);
                                        a1[3] = BN_dup(ret);
                                        unint64_t v58 = BN_dup(v71);
                                        a1[4] = v58;
                                        if (!a1[2]) {
                                          goto LABEL_76;
                                        }
                                        BOOL v10 = 0;
                                        if (a1[3] && v58)
                                        {
                                          if (a8) {
                                            *a8 = v60;
                                          }
                                          if (a9) {
                                            *a9 = v55;
                                          }
                                          if (a7) {
                                            memcpy(a7, __buf, v20);
                                          }
                                          BOOL v10 = 1;
                                        }
                                      }
                                      goto LABEL_77;
                                    }
                                    if (v52) {
                                      goto LABEL_76;
                                    }
                                  }
                                  int v43 = v60 + 1;
                                  uint64_t v44 = (uint64_t)a;
                                  if (v60 == 4095)
                                  {
                                    unint64_t v22 = 0;
                                    int v35 = v65;
                                    int v36 = a10;
                                    goto LABEL_31;
                                  }
                                }
                              }
                              goto LABEL_76;
                            }
                            unint64_t v22 = 0;
                            int v35 = v65;
                            if (is_prime_fasttest) {
                              goto LABEL_76;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else
    {
      int v23 = 0;
    }
    goto LABEL_76;
  }
  int v23 = 0;
  uint64_t v24 = 0;
LABEL_76:
  BOOL v10 = 0;
LABEL_77:
  BN_CTX_end(v23);
  BN_CTX_free(v23);
  BN_MONT_CTX_free(v24);
  return v10;
}

DSA *__cdecl DSA_generate_parameters(int bits, unsigned __int8 *seed, int seed_len, int *counter_ret, unint64_t *h_ret, void (__cdecl *callback)(int, int, void *), void *cb_arg)
{
  uint64_t v14 = DSA_new();
  if (v14)
  {
    memset(&cb, 0, sizeof(cb));
    BN_GENCB_set_old((uint64_t)&cb, (uint64_t)callback, (uint64_t)cb_arg);
    if (!DSA_generate_parameters_ex(v14, bits, seed, seed_len, counter_ret, h_ret, &cb))
    {
      DSA_free(v14);
      return 0;
    }
  }
  return v14;
}

int EVP_PKEY_bits(EVP_PKEY *pkey)
{
  if (pkey && (ptr = pkey->pkey.ptr) != 0 && (uint64_t v2 = (uint64_t (*)(void))*((void *)ptr + 12)) != 0) {
    return v2();
  }
  else {
    return 0;
  }
}

uint64_t EVP_PKEY_security_bits(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 16);
    if (v1 && (uint64_t v2 = *(uint64_t (**)(void))(v1 + 104)) != 0) {
      return v2();
    }
    else {
      return 4294967294;
    }
  }
  return result;
}

int EVP_PKEY_size(EVP_PKEY *pkey)
{
  if (pkey && (ptr = pkey->pkey.ptr) != 0 && (uint64_t v2 = (uint64_t (*)(void))*((void *)ptr + 11)) != 0) {
    return v2();
  }
  else {
    return 0;
  }
}

int EVP_PKEY_save_parameters(EVP_PKEY *pkey, int mode)
{
  if (pkey->type != 408 && pkey->type != 116) {
    return 0;
  }
  int type = pkey[1].type;
  uint64_t v2 = pkey + 1;
  int v3 = type;
  if ((mode & 0x80000000) == 0) {
    v2->int type = mode;
  }
  return v3;
}

int EVP_PKEY_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from)
{
  if (to->type != from->type)
  {
    int v6 = 101;
    int v7 = 144;
    goto LABEL_7;
  }
  ptr = from->pkey.ptr;
  if (!ptr) {
    return 0;
  }
  int v5 = (unsigned int (*)(const EVP_PKEY *))*((void *)ptr + 16);
  if (v5)
  {
    if (v5(from))
    {
      int v6 = 103;
      int v7 = 149;
LABEL_7:
      ERR_put_error(6, 4095, v6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", v7);
      return 0;
    }
    ptr = from->pkey.ptr;
    if (!ptr) {
      return 0;
    }
  }
  int v9 = (uint64_t (*)(EVP_PKEY *, const EVP_PKEY *))*((void *)ptr + 17);
  if (!v9) {
    return 0;
  }
  return v9(to, from);
}

int EVP_PKEY_missing_parameters(const EVP_PKEY *pkey)
{
  ptr = pkey->pkey.ptr;
  if (ptr && (uint64_t v2 = (uint64_t (*)(void))*((void *)ptr + 16)) != 0) {
    return v2();
  }
  else {
    return 0;
  }
}

int EVP_PKEY_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b)
{
  if (a->type != b->type) {
    return -1;
  }
  ptr = a->pkey.ptr;
  if (ptr && (int v3 = (uint64_t (*)(void))*((void *)ptr + 18)) != 0) {
    return v3();
  }
  else {
    return -2;
  }
}

int EVP_PKEY_cmp(const EVP_PKEY *a, const EVP_PKEY *b)
{
  if (a->type != b->type) {
    return -1;
  }
  ptr = a->pkey.ptr;
  if (!ptr) {
    return -2;
  }
  int v5 = (uint64_t (*)(const EVP_PKEY *, const EVP_PKEY *))*((void *)ptr + 18);
  if (v5)
  {
    int result = v5(a, b);
    if (result < 1) {
      return result;
    }
    ptr = a->pkey.ptr;
  }
  int v7 = (uint64_t (*)(const EVP_PKEY *, const EVP_PKEY *))*((void *)ptr + 6);
  if (!v7) {
    return -2;
  }
  return v7(a, b);
}

EVP_PKEY *EVP_PKEY_new(void)
{
  uint64_t v0 = (EVP_PKEY *)malloc_type_malloc(0x38uLL, 0x10E20405E855B9FuLL);
  uint64_t v1 = v0;
  if (v0)
  {
    *(void *)&v0->int type = 0;
    v0->referenceunsigned int s = 1;
    *(void *)&v0[1].referenceunsigned int s = 0;
    *(void *)&v0->save_parameterunsigned int s = 0;
    v0->attributeunsigned int s = 0;
    v0->pkey.ptr = 0;
    v0[1].int type = 1;
  }
  else
  {
    ERR_put_error(6, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", 206);
  }
  return v1;
}

BOOL EVP_PKEY_up_ref(uint64_t a1)
{
  return CRYPTO_add_lock((int *)(a1 + 8), 1, 10, 0, 0) > 1;
}

uint64_t EVP_PKEY_set_type(uint64_t a1, int a2)
{
  return pkey_set_type(a1, 0, a2, 0, -1);
}

uint64_t pkey_set_type(uint64_t a1, ENGINE *a2, int a3, char *__s, signed int a5)
{
  e = a2;
  if (a2) {
    p_e = 0;
  }
  else {
    p_e = &e;
  }
  if (a1)
  {
    if (*(void *)(a1 + 32)) {
      EVP_PKEY_free_it(a1);
    }
    if (*(_DWORD *)(a1 + 4) == a3 && *(void *)(a1 + 16)) {
      return 1;
    }
    ENGINE_finish(*(ENGINE **)(a1 + 24));
    *(void *)(a1 + 24) = 0;
  }
  if (__s) {
    uint64_t str = (uint64_t)EVP_PKEY_asn1_find_str(p_e, __s, a5);
  }
  else {
    uint64_t str = EVP_PKEY_asn1_find((uint64_t *)p_e, a3);
  }
  uint64_t v12 = (_DWORD *)str;
  if (!(a1 | (unint64_t)a2)) {
    ENGINE_finish(e);
  }
  if (v12)
  {
    if (a1)
    {
      uint64_t v13 = e;
      *(void *)(a1 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = v12;
      *(void *)(a1 + 24) = v13;
      *(_DWORD *)a1 = *v12;
      *(_DWORD *)(a1 + 4) = a3;
    }
    return 1;
  }
  ERR_put_error(6, 4095, 156, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", 262);
  return 0;
}

EVP_PKEY *EVP_PKEY_new_raw_private_key(int a1, ENGINE *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = EVP_PKEY_new();
  int v9 = v8;
  if (!v8 || !pkey_set_type((uint64_t)v8, a2, a1, 0, -1)) {
    goto LABEL_8;
  }
  BOOL v10 = (unsigned int (*)(EVP_PKEY *, uint64_t, uint64_t))*((void *)v9->pkey.ptr + 30);
  if (!v10)
  {
    int v11 = 150;
    int v12 = 294;
    goto LABEL_7;
  }
  if (!v10(v9, a3, a4))
  {
    int v11 = 180;
    int v12 = 298;
LABEL_7:
    ERR_put_error(6, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", v12);
LABEL_8:
    EVP_PKEY_free(v9);
    return 0;
  }
  return v9;
}

void EVP_PKEY_free(EVP_PKEY *pkey)
{
  if (pkey && CRYPTO_add_lock(&pkey->references, -1, 10, 0, 0) <= 0)
  {
    EVP_PKEY_free_it((uint64_t)pkey);
    uint64_t v2 = *(STACK **)&pkey[1].references;
    if (v2) {
      sk_pop_free(v2, (void (__cdecl *)(void *))X509_ATTRIBUTE_free);
    }
    free(pkey);
  }
}

EVP_PKEY *EVP_PKEY_new_raw_public_key(int a1, ENGINE *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = EVP_PKEY_new();
  int v9 = v8;
  if (!v8 || !pkey_set_type((uint64_t)v8, a2, a1, 0, -1)) {
    goto LABEL_8;
  }
  BOOL v10 = (unsigned int (*)(EVP_PKEY *, uint64_t, uint64_t))*((void *)v9->pkey.ptr + 31);
  if (!v10)
  {
    int v11 = 150;
    int v12 = 323;
    goto LABEL_7;
  }
  if (!v10(v9, a3, a4))
  {
    int v11 = 180;
    int v12 = 327;
LABEL_7:
    ERR_put_error(6, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", v12);
LABEL_8:
    EVP_PKEY_free(v9);
    return 0;
  }
  return v9;
}

uint64_t EVP_PKEY_get_raw_private_key(uint64_t a1)
{
  uint64_t v1 = *(unsigned int (**)(void))(*(void *)(a1 + 16) + 256);
  if (v1)
  {
    if (v1()) {
      return 1;
    }
    int v3 = 182;
    int v4 = 348;
  }
  else
  {
    int v3 = 150;
    int v4 = 344;
  }
  ERR_put_error(6, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", v4);
  return 0;
}

uint64_t EVP_PKEY_get_raw_public_key(uint64_t a1)
{
  uint64_t v1 = *(unsigned int (**)(void))(*(void *)(a1 + 16) + 264);
  if (v1)
  {
    if (v1()) {
      return 1;
    }
    int v3 = 182;
    int v4 = 364;
  }
  else
  {
    int v3 = 150;
    int v4 = 360;
  }
  ERR_put_error(6, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", v4);
  return 0;
}

EVP_PKEY *EVP_PKEY_new_CMAC_key(ENGINE *a1, const unsigned __int8 *a2, uint64_t a3, EVP_CIPHER *a4)
{
  uint64_t v8 = EVP_PKEY_new();
  if (!v8)
  {
    int v9 = 0;
LABEL_8:
    EVP_PKEY_free(v8);
    CMAC_CTX_free(v9);
    return 0;
  }
  int v9 = CMAC_CTX_new();
  if (!v9 || !pkey_set_type((uint64_t)v8, a1, 894, 0, -1)) {
    goto LABEL_8;
  }
  if (!CMAC_Init(v9, a2, a3, a4, a1))
  {
    ERR_put_error(6, 4095, 180, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", 387);
    goto LABEL_8;
  }
  v8->attributeunsigned int s = (STACK *)v9;
  return v8;
}

uint64_t EVP_PKEY_set_type_str(uint64_t a1, char *__s, signed int a3)
{
  return pkey_set_type(a1, 0, 0, __s, a3);
}

int EVP_PKEY_assign(EVP_PKEY *pkey, int type, char *key)
{
  int result = pkey_set_type((uint64_t)pkey, 0, type, 0, -1);
  if (result)
  {
    pkey->attributeunsigned int s = (STACK *)key;
    return key != 0;
  }
  return result;
}

uint64_t EVP_PKEY_get0(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t EVP_PKEY_get0_hmac(uint64_t a1, void *a2)
{
  if (*(_DWORD *)a1 == 855)
  {
    uint64_t v2 = *(int **)(a1 + 32);
    *a2 = *v2;
    return *((void *)v2 + 1);
  }
  else
  {
    ERR_put_error(6, 4095, 174, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", 428);
    return 0;
  }
}

uint64_t EVP_PKEY_get0_RSA(uint64_t a1)
{
  if (*(_DWORD *)a1 == 6) {
    return *(void *)(a1 + 32);
  }
  ERR_put_error(6, 4095, 127, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", 443);
  return 0;
}

rsa_st *__cdecl EVP_PKEY_get1_RSA(EVP_PKEY *pkey)
{
  if (pkey->type == 6)
  {
    RSA_up_ref((RSA *)pkey->attributes);
    return (rsa_st *)pkey->attributes;
  }
  else
  {
    ERR_put_error(6, 4095, 127, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", 453);
    return 0;
  }
}

int EVP_PKEY_set1_RSA(EVP_PKEY *pkey, rsa_st *key)
{
  int result = pkey_set_type((uint64_t)pkey, 0, 6, 0, -1);
  if (result)
  {
    pkey->attributeunsigned int s = (STACK *)key;
    if (key)
    {
      RSA_up_ref(key);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t EVP_PKEY_get0_DSA(uint64_t a1)
{
  if (*(_DWORD *)a1 == 116) {
    return *(void *)(a1 + 32);
  }
  ERR_put_error(6, 4095, 129, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", 475);
  return 0;
}

dsa_st *__cdecl EVP_PKEY_get1_DSA(EVP_PKEY *pkey)
{
  if (pkey->type == 116)
  {
    DSA_up_ref((DSA *)pkey->attributes);
    return (dsa_st *)pkey->attributes;
  }
  else
  {
    ERR_put_error(6, 4095, 129, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", 485);
    return 0;
  }
}

int EVP_PKEY_set1_DSA(EVP_PKEY *pkey, dsa_st *key)
{
  int result = pkey_set_type((uint64_t)pkey, 0, 116, 0, -1);
  if (result)
  {
    pkey->attributeunsigned int s = (STACK *)key;
    if (key)
    {
      DSA_up_ref(key);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t EVP_PKEY_get0_EC_KEY(uint64_t a1)
{
  if (*(_DWORD *)a1 == 408) {
    return *(void *)(a1 + 32);
  }
  ERR_put_error(6, 4095, 142, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", 507);
  return 0;
}

ec_key_st *__cdecl EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey)
{
  if (pkey->type == 408)
  {
    EC_KEY_up_ref((EC_KEY *)pkey->attributes);
    return (ec_key_st *)pkey->attributes;
  }
  else
  {
    ERR_put_error(6, 4095, 142, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", 517);
    return 0;
  }
}

int EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey, ec_key_st *key)
{
  int result = pkey_set_type((uint64_t)pkey, 0, 408, 0, -1);
  if (result)
  {
    pkey->attributeunsigned int s = (STACK *)key;
    if (key)
    {
      EC_KEY_up_ref(key);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t EVP_PKEY_get0_DH(uint64_t a1)
{
  if (*(_DWORD *)a1 == 28) {
    return *(void *)(a1 + 32);
  }
  ERR_put_error(6, 4095, 128, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", 540);
  return 0;
}

dh_st *__cdecl EVP_PKEY_get1_DH(EVP_PKEY *pkey)
{
  if (pkey->type == 28)
  {
    DH_up_ref((DH *)pkey->attributes);
    return (dh_st *)pkey->attributes;
  }
  else
  {
    ERR_put_error(6, 4095, 128, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/p_lib.c", 550);
    return 0;
  }
}

int EVP_PKEY_set1_DH(EVP_PKEY *pkey, dh_st *key)
{
  int result = pkey_set_type((uint64_t)pkey, 0, 28, 0, -1);
  if (result)
  {
    pkey->attributeunsigned int s = (STACK *)key;
    if (key)
    {
      DH_up_ref(key);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

int EVP_PKEY_type(int type)
{
  e = 0;
  uint64_t v1 = (int *)EVP_PKEY_asn1_find((uint64_t *)&e, type);
  if (v1) {
    int v2 = *v1;
  }
  else {
    int v2 = 0;
  }
  ENGINE_finish(e);
  return v2;
}

uint64_t EVP_PKEY_id(unsigned int *a1)
{
  return *a1;
}

uint64_t EVP_PKEY_base_id(int *a1)
{
  return EVP_PKEY_type(*a1);
}

uint64_t EVP_PKEY_free_it(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2)
  {
    int v3 = *(void (**)(uint64_t))(v2 + 168);
    if (v3)
    {
      v3(a1);
      *(void *)(a1 + 32) = 0;
    }
  }
  uint64_t result = ENGINE_finish(*(ENGINE **)(a1 + 24));
  *(void *)(a1 + 24) = 0;
  return result;
}

uint64_t EVP_PKEY_print_public(BIO *a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(a2 + 16);
  if (v3 && (int v4 = *(uint64_t (**)(void))(v3 + 56)) != 0) {
    return v4();
  }
  else {
    return unsup_alg(a1, (int *)a2, a3, "Public Key");
  }
}

uint64_t unsup_alg(BIO *a1, int *a2, int indent, const char *a4)
{
  uint64_t result = BIO_indent(a1, indent, 128);
  if (result)
  {
    uint64_t v8 = OBJ_nid2ln(*a2);
    BIO_printf(a1, "%s algorithm \"%s\" unsupported\n", a4, v8);
    return 1;
  }
  return result;
}

uint64_t EVP_PKEY_print_private(BIO *a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(a2 + 16);
  if (v3 && (int v4 = *(uint64_t (**)(void))(v3 + 80)) != 0) {
    return v4();
  }
  else {
    return unsup_alg(a1, (int *)a2, a3, "Private Key");
  }
}

uint64_t EVP_PKEY_print_params(BIO *a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(a2 + 16);
  if (v3 && (int v4 = *(uint64_t (**)(void))(v3 + 152)) != 0) {
    return v4();
  }
  else {
    return unsup_alg(a1, (int *)a2, a3, "Parameters");
  }
}

uint64_t EVP_PKEY_get_default_digest_nid(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1 && (uint64_t v2 = *(uint64_t (**)(void))(v1 + 176)) != 0) {
    return v2();
  }
  else {
    return 4294967294;
  }
}

BIO_METHOD *BIO_f_buffer(void)
{
  return (BIO_METHOD *)&methods_buffer;
}

uint64_t buffer_write(BIO *b, char *a2, int a3)
{
  uint64_t v3 = 0;
  if (!a2) {
    return v3;
  }
  int v4 = a3;
  if (a3 < 1) {
    return v3;
  }
  next_biASN1_OBJECT o = b->next_bio;
  if (!next_bio || !b->prev_bio) {
    return 0;
  }
  int v7 = a2;
  BIO_clear_flags(b, 15);
  int flags = next_bio->flags;
  retry_reasoint n = next_bio->retry_reason;
  int v10 = retry_reason + flags;
  int v11 = HIDWORD(next_bio->method) - (retry_reason + flags);
  if (v11 >= v4)
  {
    LODWORD(v3) = 0;
LABEL_21:
    memcpy((void *)(*(void *)&next_bio->init + v10), v7, v4);
    next_bio->flags += v4;
    return (v3 + v4);
  }
  uint64_t v3 = 0;
  while (2)
  {
    if (!flags)
    {
LABEL_12:
      next_bio->retry_reasoint n = 0;
      while (1)
      {
        int method_high = HIDWORD(next_bio->method);
        if (v4 < method_high) {
          break;
        }
        int v16 = BIO_write(b->prev_bio, v7, v4);
        int v17 = v16;
        if (v16 <= 0)
        {
          BIO_copy_next_retry(b);
          if ((int)v3 <= 0) {
            unsigned int v18 = v17;
          }
          else {
            unsigned int v18 = v3;
          }
          if (v17 < 0) {
            return v18;
          }
          else {
            return v3;
          }
        }
        uint64_t v3 = (v16 + v3);
        v7 += v16;
        v4 -= v16;
        if (!v4) {
          return v3;
        }
      }
      int flags = next_bio->flags;
      retry_reasoint n = next_bio->retry_reason;
      int v10 = retry_reason + flags;
      int v11 = method_high - (retry_reason + flags);
      if (v11 < v4) {
        continue;
      }
      goto LABEL_21;
    }
    break;
  }
  if (v11 >= 1)
  {
    memcpy((void *)(*(void *)&next_bio->init + v10), v7, v11);
    v7 += v11;
    v4 -= v11;
    uint64_t v3 = (v11 + v3);
    retry_reasoint n = next_bio->retry_reason;
    int flags = next_bio->flags + v11;
    next_bio->int flags = flags;
  }
  while (1)
  {
    int v12 = BIO_write(b->prev_bio, (const void *)(*(void *)&next_bio->init + retry_reason), flags);
    unsigned int v13 = v12;
    if (v12 <= 0) {
      break;
    }
    int v14 = next_bio->flags;
    retry_reasoint n = next_bio->retry_reason + v12;
    int flags = v14 - v12;
    next_bio->int flags = v14 - v12;
    next_bio->retry_reasoint n = retry_reason;
    if (v14 == v12) {
      goto LABEL_12;
    }
  }
  BIO_copy_next_retry(b);
  if ((v13 & 0x80000000) != 0)
  {
    if ((int)v3 <= 0) {
      return v13;
    }
    else {
      return v3;
    }
  }
  return v3;
}

uint64_t buffer_read(BIO *b, char *a2, int a3)
{
  if (!a2) {
    return 0;
  }
  next_biASN1_OBJECT o = b->next_bio;
  if (!next_bio || !b->prev_bio) {
    return 0;
  }
  int v6 = a2;
  BIO_clear_flags(b, 15);
  LODWORD(v7) = 0;
  cb_long long arg = (int)next_bio->cb_arg;
  if (!cb_arg) {
    goto LABEL_10;
  }
  while (1)
  {
    int v9 = cb_arg >= a3 ? a3 : cb_arg;
    memcpy(v6, (char *)next_bio->callback + SHIDWORD(next_bio->cb_arg), v9);
    int v10 = HIDWORD(next_bio->cb_arg) + v9;
    LODWORD(next_bio->cb_arg) -= v9;
    HIDWORD(next_bio->cb_arg) = v10;
    uint64_t v7 = (v9 + v7);
    if (a3 <= cb_arg) {
      return v7;
    }
    a3 -= v9;
    v6 += v9;
LABEL_10:
    prev_biASN1_OBJECT o = b->prev_bio;
    if (a3 > SLODWORD(next_bio->method))
    {
      while (1)
      {
        int v12 = BIO_read(prev_bio, v6, a3);
        cb_long long arg = v12;
        if (v12 < 1) {
          break;
        }
        uint64_t v7 = (v12 + v7);
        a3 -= v12;
        if (!a3) {
          return v7;
        }
        v6 += v12;
        prev_biASN1_OBJECT o = b->prev_bio;
      }
LABEL_16:
      BIO_copy_next_retry(b);
      if ((int)v7 <= 0) {
        unsigned int v13 = cb_arg;
      }
      else {
        unsigned int v13 = v7;
      }
      if (cb_arg < 0) {
        return v13;
      }
      else {
        return v7;
      }
    }
    cb_long long arg = BIO_read(prev_bio, next_bio->callback, (int)next_bio->method);
    if (cb_arg <= 0) {
      goto LABEL_16;
    }
    next_bio->cb_long long arg = (char *)cb_arg;
  }
}

uint64_t buffer_puts(BIO *a1, char *__s)
{
  int v4 = strlen(__s);
  return buffer_write(a1, __s, v4);
}

uint64_t buffer_gets(BIO *a1, unsigned char *a2, int a3)
{
  next_biASN1_OBJECT o = a1->next_bio;
  int v6 = a3 - 1;
  BIO_clear_flags(a1, 15);
  LODWORD(v7) = 0;
  LODWORD(cb_arg_low) = next_bio->cb_arg;
  while (1)
  {
    while ((int)cb_arg_low >= 1)
    {
      if (v6 < 1)
      {
        char v13 = 0;
        LODWORD(v9) = 0;
      }
      else
      {
        unint64_t v9 = 0;
        int v10 = (char *)next_bio->callback + SHIDWORD(next_bio->cb_arg);
        while (1)
        {
          unint64_t v11 = v9;
          a2[v9] = v10[v9];
          if (v10[v9] == 10) {
            break;
          }
          ++v9;
          int64_t cb_arg_low = SLODWORD(next_bio->cb_arg);
          if ((uint64_t)(v11 + 1) >= cb_arg_low || v9 >= v6)
          {
            char v13 = 0;
            a2 += v11 + 1;
            goto LABEL_16;
          }
        }
        LODWORD(v9) = v9 + 1;
        LODWORD(cb_arg_low) = next_bio->cb_arg;
        a2 += v11 + 1;
        char v13 = 1;
      }
LABEL_16:
      uint64_t v7 = (v9 + v7);
      LODWORD(cb_arg_low) = cb_arg_low - v9;
      int v14 = HIDWORD(next_bio->cb_arg) + v9;
      LODWORD(next_bio->cb_arg) = cb_arg_low;
      HIDWORD(next_bio->cb_arg) = v14;
      if ((v13 & 1) == 0)
      {
        v6 -= v9;
        if (v6) {
          continue;
        }
      }
      *a2 = 0;
      return v7;
    }
    LODWORD(cb_arg_low) = BIO_read(a1->prev_bio, next_bio->callback, (int)next_bio->method);
    if ((int)cb_arg_low <= 0) {
      break;
    }
    next_bio->cb_long long arg = (char *)cb_arg_low;
  }
  BIO_copy_next_retry(a1);
  *a2 = 0;
  if ((int)v7 <= 0) {
    unsigned int v15 = cb_arg_low;
  }
  else {
    unsigned int v15 = v7;
  }
  if ((int)cb_arg_low < 0) {
    return v15;
  }
  else {
    return v7;
  }
}

uint64_t buffer_ctrl(BIO *b, int a2, uint64_t size, BIO *parg)
{
  next_biASN1_OBJECT o = b->next_bio;
  if (a2 <= 100)
  {
    switch(a2)
    {
      case 1:
        next_bio->cb_long long arg = 0;
        *(void *)&next_bio->int flags = 0;
        prev_biASN1_OBJECT o = b->prev_bio;
        if (!prev_bio) {
          return 0;
        }
        a2 = 1;
        goto LABEL_42;
      case 3:
        return next_bio->flags;
      case 10:
        uint64_t cb_arg_low = SLODWORD(next_bio->cb_arg);
        if (cb_arg_low) {
          return cb_arg_low;
        }
        prev_biASN1_OBJECT o = b->prev_bio;
        if (!prev_bio) {
          return 0;
        }
        a2 = 10;
        goto LABEL_42;
      case 11:
        prev_biASN1_OBJECT o = b->prev_bio;
        if (!prev_bio) {
          return 0;
        }
        if (next_bio->flags < 1) {
          goto LABEL_29;
        }
        BIO_clear_flags(b, 15);
        int flags = next_bio->flags;
        if (flags < 1) {
          goto LABEL_28;
        }
        break;
      case 12:
        if (!BIO_int_ctrl(parg, 117, SLODWORD(next_bio->method), 0)) {
          return 0;
        }
        uint64_t cb_arg_low = 1;
        if (!BIO_int_ctrl(parg, 117, SHIDWORD(next_bio->method), 1)) {
          return 0;
        }
        return cb_arg_low;
      case 13:
        uint64_t cb_arg_low = next_bio->flags;
        if (cb_arg_low) {
          return cb_arg_low;
        }
        prev_biASN1_OBJECT o = b->prev_bio;
        if (!prev_bio) {
          return 0;
        }
        a2 = 13;
        goto LABEL_42;
      default:
        goto LABEL_41;
    }
    do
    {
      LODWORD(cb_arg_low) = BIO_write(b->prev_bio, (const void *)(*(void *)&next_bio->init + next_bio->retry_reason), flags);
      BIO_copy_next_retry(b);
      if ((int)cb_arg_low <= 0) {
        return (int)cb_arg_low;
      }
      int v16 = next_bio->retry_reason + cb_arg_low;
      next_bio->flags -= cb_arg_low;
      next_bio->retry_reasoint n = v16;
      BIO_clear_flags(b, 15);
      int flags = next_bio->flags;
    }
    while (flags > 0);
LABEL_28:
    *(void *)&next_bio->int flags = 0;
    prev_biASN1_OBJECT o = b->prev_bio;
LABEL_29:
    a2 = 11;
    goto LABEL_42;
  }
  if (a2 > 116)
  {
    if (a2 != 117)
    {
      if (a2 != 122) {
        goto LABEL_41;
      }
      if (SLODWORD(next_bio->method) >= size)
      {
        int callback = next_bio->callback;
        goto LABEL_46;
      }
      char v13 = (uint64_t (__cdecl *)(bio_st *, int, const char *, int, uint64_t, uint64_t))malloc_type_malloc(size, 0x89B49EC2uLL);
      if (v13)
      {
        int callback = v13;
        free(next_bio->callback);
        next_bio->int callback = callback;
LABEL_46:
        LODWORD(next_bio->cb_arg) = size;
        HIDWORD(next_bio->cb_arg) = 0;
        memcpy(callback, parg, size);
        return 1;
      }
LABEL_64:
      ERR_put_error(32, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bio/bf_buff.c", 450);
      return 0;
    }
    if (parg)
    {
      if (!LODWORD(parg->method))
      {
        int method_high = HIDWORD(next_bio->method);
        int method = size;
        goto LABEL_50;
      }
      int method = (int)next_bio->method;
    }
    else
    {
      int method = size;
    }
    int method_high = size;
LABEL_50:
    unint64_t v21 = next_bio->callback;
    unint64_t v22 = *(void **)&next_bio->init;
    if (method <= 4096
      || method == LODWORD(next_bio->method)
      || (unint64_t v21 = (uint64_t (__cdecl *)(bio_st *, int, const char *, int, uint64_t, uint64_t))malloc_type_malloc(size, 0x4CF0AF09uLL)) != 0)
    {
      if (method_high <= 4096
        || method_high == HIDWORD(next_bio->method)
        || (unint64_t v22 = malloc_type_malloc(size, 0x16909226uLL)) != 0)
      {
        int v23 = next_bio->callback;
        if (v23 != v21)
        {
          free(v23);
          next_bio->int callback = v21;
          next_bio->cb_long long arg = 0;
          LODWORD(next_bio->method) = method;
        }
        uint64_t v24 = *(void **)&next_bio->init;
        if (v24 != v22)
        {
          free(v24);
          *(void *)&next_bio->init = v22;
          *(void *)&next_bio->int flags = 0;
          uint64_t cb_arg_low = 1;
          HIDWORD(next_bio->method) = method_high;
          return cb_arg_low;
        }
        return 1;
      }
      if (v21 != next_bio->callback) {
        free(v21);
      }
    }
    goto LABEL_64;
  }
  if (a2 == 101)
  {
    if (b->prev_bio)
    {
      BIO_clear_flags(b, 15);
      uint64_t v17 = BIO_ctrl(b->prev_bio, 101, size, parg);
      BIO_copy_next_retry(b);
      return v17;
    }
    return 0;
  }
  if (a2 == 116)
  {
    uint64_t v9 = LODWORD(next_bio->cb_arg);
    if ((int)v9 >= 1)
    {
      uint64_t cb_arg_low = 0;
      unint64_t v11 = (unsigned __int8 *)next_bio->callback + SHIDWORD(next_bio->cb_arg);
      do
      {
        int v12 = *v11++;
        if (v12 == 10) {
          ++cb_arg_low;
        }
        --v9;
      }
      while (v9);
      return cb_arg_low;
    }
    return 0;
  }
LABEL_41:
  prev_biASN1_OBJECT o = b->prev_bio;
  if (!prev_bio) {
    return 0;
  }
LABEL_42:
  return BIO_ctrl(prev_bio, a2, size, parg);
}

uint64_t buffer_new(uint64_t a1)
{
  uint64_t result = (uint64_t)malloc_type_malloc(0x28uLL, 0x101004019361378uLL);
  if (result)
  {
    uint64_t v3 = result;
    int v4 = malloc_type_malloc(0x1000uLL, 0x9E55FA89uLL);
    *(void *)(v3 + 8) = v4;
    if (v4)
    {
      int v5 = malloc_type_malloc(0x1000uLL, 0x865A550FuLL);
      *(void *)(v3 + 24) = v5;
      if (v5)
      {
        *(void *)uint64_t v3 = 0x100000001000;
        *(void *)(v3 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = 0;
        *(void *)(v3 + 32) = 0;
        uint64_t result = 1;
        *(_DWORD *)(a1 + 32) = 1;
        *(void *)(a1 + 56) = v3;
        *(_DWORD *)(a1 + 4RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0;
        return result;
      }
      free(*(void **)(v3 + 8));
    }
    free((void *)v3);
    return 0;
  }
  return result;
}

uint64_t buffer_free(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void *)(result + 56);
    free(*(void **)(v2 + 8));
    free(*(void **)(v2 + 24));
    free(*(void **)(v1 + 56));
    *(void *)(v1 + 56) = 0;
    *(_DWORD *)(v1 + 32) = 0;
    uint64_t result = 1;
    *(_DWORD *)(v1 + 4RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0;
  }
  return result;
}

BIO *buffer_callback_ctrl(uint64_t a1, int a2, void (__cdecl *a3)(bio_st *, int, const char *, int, uint64_t, uint64_t))
{
  uint64_t result = *(BIO **)(a1 + 64);
  if (result) {
    return (BIO *)BIO_callback_ctrl(result, a2, a3);
  }
  return result;
}

void ERR_load_ECDH_strings(void)
{
  if (!ERR_func_error_string(ECDH_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&ECDH_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&ECDH_str_reasons);
  }
}

void X509V3_EXT_val_prn(BIO *out, STACK *val, int indent, int ml)
{
  if (val)
  {
    if (!ml || !sk_num(val))
    {
      BIO_printf(out, "%*s", indent, "");
      if (!sk_num(val)) {
        BIO_puts(out, "<EMPTY>\n");
      }
    }
    if (sk_num(val) >= 1)
    {
      for (int i = 0; i < sk_num(val); ++i)
      {
        if (ml)
        {
          BIO_printf(out, "%*s");
        }
        else if (i)
        {
          BIO_printf(out, ", ");
        }
        uint64_t v9 = sk_value(val, i);
        int v10 = (const char *)*((void *)v9 + 1);
        unint64_t v11 = (const char *)*((void *)v9 + 2);
        if (v10)
        {
          if (v11)
          {
            BIO_printf(out, "%s:%s", *((const char **)v9 + 1), v11);
            if (!ml) {
              continue;
            }
LABEL_19:
            BIO_puts(out, "\n");
            continue;
          }
          int v12 = out;
        }
        else
        {
          int v12 = out;
          int v10 = v11;
        }
        BIO_puts(v12, v10);
        if (ml) {
          goto LABEL_19;
        }
      }
    }
  }
}

int X509V3_EXT_print(BIO *out, X509_EXTENSION *ext, unint64_t flag, int indent)
{
  uint64_t v4 = *(void *)&indent;
  uint64_t v8 = X509V3_EXT_get(ext);
  if (v8)
  {
    uint64_t v9 = v8;
    value = ext->value;
    unsigned __int8 in = value->data;
    it = v8->it;
    if (it) {
      int v12 = ASN1_item_d2i(0, (const unsigned __int8 **)&in, value->length, it);
    }
    else {
      int v12 = (ASN1_VALUE *)((uint64_t (*)(void, unsigned __int8 **, void))v8->d2i)(0, &in, value->length);
    }
    int v14 = v12;
    if (!v12) {
      return unknown_ext_print(out, (uint64_t)ext, flag, v4, 1);
    }
    i2unsigned int s = (uint64_t (*)(X509V3_EXT_METHOD *, ASN1_VALUE *))v9->i2s;
    if (i2s)
    {
      int v16 = (const char *)i2s(v9, v12);
      uint64_t v17 = (char *)v16;
      if (v16)
      {
        BIO_printf(out, "%*s%s", v4, "", v16);
        unsigned int v18 = 0;
LABEL_16:
        BOOL v19 = 1;
        goto LABEL_23;
      }
    }
    else
    {
      i2v = (uint64_t (*)(void, void, void))v9->i2v;
      if (i2v)
      {
        unsigned int v18 = (STACK *)i2v(v9, v12, 0);
        if (v18)
        {
          X509V3_EXT_val_prn(out, v18, v4, v9->ext_flags & 4);
          uint64_t v17 = 0;
          goto LABEL_16;
        }
        uint64_t v17 = 0;
        goto LABEL_22;
      }
      i2r = (uint64_t (*)(X509V3_EXT_METHOD *, ASN1_VALUE *, BIO *, uint64_t))v9->i2r;
      if (i2r)
      {
        uint64_t v17 = 0;
        unsigned int v18 = 0;
        BOOL v19 = i2r(v9, v12, out, v4) != 0;
        goto LABEL_23;
      }
      uint64_t v17 = 0;
    }
    unsigned int v18 = 0;
LABEL_22:
    BOOL v19 = 0;
LABEL_23:
    sk_pop_free(v18, (void (__cdecl *)(void *))X509V3_conf_free);
    free(v17);
    unint64_t v22 = v9->it;
    if (v22) {
      ASN1_item_free(v14, v22);
    }
    else {
      ((void (*)(ASN1_VALUE *))v9->ext_free)(v14);
    }
    return v19;
  }
  return unknown_ext_print(out, (uint64_t)ext, flag, v4, 0);
}

uint64_t unknown_ext_print(BIO *a1, uint64_t a2, unint64_t a3, int a4, int a5)
{
  uint64_t v5 = 0;
  switch((a3 >> 16) & 0xF)
  {
    case 0uLL:
      return v5;
    case 1uLL:
      if (a5) {
        BIO_printf(a1, "%*s<Parse Error>");
      }
      else {
        BIO_printf(a1, "%*s<Not Supported>");
      }
      return 1;
    case 2uLL:
      int v6 = *(int **)(a2 + 16);
      uint64_t v7 = (const unsigned __int8 *)*((void *)v6 + 1);
      uint64_t v8 = *v6;
      return ASN1_parse_dump(a1, v7, v8, a4, -1);
    case 3uLL:
      uint64_t v10 = *(void *)(a2 + 16);
      unint64_t v11 = *(const char **)(v10 + 8);
      int v12 = *(_DWORD *)v10;
      return BIO_dump_indent(a1, v11, v12, a4);
    default:
      return 1;
  }
}

int X509V3_extensions_print(BIO *out, char *title, STACK *exts, unint64_t flag, int indent)
{
  if (sk_num(exts) < 1) {
    return 1;
  }
  if (title)
  {
    BIO_printf(out, "%*s%s:\n", indent, "", title);
    indent += 4;
  }
  if (sk_num(exts) < 1) {
    return 1;
  }
  int v10 = 0;
  while (1)
  {
    unint64_t v11 = (X509_EXTENSION *)sk_value(exts, v10);
    if (indent)
    {
      if (BIO_printf(out, "%*s", indent, "") < 1) {
        break;
      }
    }
    object = X509_EXTENSION_get_object(v11);
    i2a_ASN1_OBJECT(out, object);
    int critical = X509_EXTENSION_get_critical(v11);
    int v14 = " critical";
    if (!critical) {
      int v14 = "";
    }
    if (BIO_printf(out, ":%s\n", v14) < 1) {
      break;
    }
    if (!X509V3_EXT_print(out, v11, flag, indent + 4))
    {
      BIO_printf(out, "%*s", indent + 4, "");
      ASN1_STRING_print(out, v11->value);
    }
    if (BIO_write(out, "\n", 1) <= 0) {
      break;
    }
    if (++v10 >= sk_num(exts)) {
      return 1;
    }
  }
  return 0;
}

int X509V3_EXT_print_fp(FILE *out, X509_EXTENSION *ext, int flag, int indent)
{
  uint64_t v7 = BIO_new_fp(out, 0);
  if (v7)
  {
    uint64_t v8 = v7;
    int v9 = X509V3_EXT_print(v7, ext, flag, indent);
    BIO_free(v8);
    LODWORD(v7) = v9;
  }
  return (int)v7;
}

void CAST_set_key(CAST_KEY *key, int len, const unsigned __int8 *data)
{
  uint64_t v93 = *MEMORY[0x263EF8340];
  long long v89 = 0u;
  long long v90 = 0u;
  long long v91 = 0u;
  long long v92 = 0u;
  if (len >= 16) {
    int v3 = 16;
  }
  else {
    int v3 = len;
  }
  if (len >= 1)
  {
    if (v3 <= 1) {
      uint64_t v4 = 1;
    }
    else {
      uint64_t v4 = v3;
    }
    uint64_t v5 = &v89;
    do
    {
      int v6 = *data++;
      *(_DWORD *)uint64_t v5 = v6;
      uint64_t v5 = (long long *)((char *)v5 + 4);
      --v4;
    }
    while (v4);
  }
  int v7 = v89;
  int v8 = DWORD1(v89) << 16;
  LODWORD(key->data[16]) = v3 < 11;
  unsigned int v9 = v8 | (v7 << 24) | (DWORD2(v89) << 8) | HIDWORD(v89);
  unsigned int v10 = (DWORD1(v90) << 16) | (v90 << 24) | (DWORD2(v90) << 8) | HIDWORD(v90);
  int v11 = DWORD1(v91);
  int v12 = DWORD2(v91);
  int v13 = HIDWORD(v91);
  unsigned int v14 = (DWORD1(v91) << 16) | (v91 << 24) | (DWORD2(v91) << 8) | HIDWORD(v91);
  unsigned int v15 = v92;
  int v16 = DWORD1(v92);
  int v17 = DWORD2(v92);
  unsigned int v18 = (DWORD1(v92) << 16) | (v92 << 24) | (DWORD2(v92) << 8) | HIDWORD(v92);
  int v19 = CAST_S_table5[HIDWORD(v92)];
  size_t v20 = (int *)v88;
  int v21 = CAST_S_table6[v91];
  do
  {
    unsigned int v22 = CAST_S_table4[v16] ^ v9 ^ v19 ^ CAST_S_table6[v15] ^ CAST_S_table7[v17] ^ v21;
    int v23 = CAST_S_table6[BYTE2(v22)];
    int v24 = v22;
    unsigned int v25 = CAST_S_table4[HIBYTE(v22)] ^ v14 ^ CAST_S_table5[BYTE1(v22)] ^ CAST_S_table7[v22] ^ CAST_S_table7[v12] ^ v23;
    int v26 = CAST_S_table7[HIBYTE(v25)];
    int v27 = CAST_S_table5[BYTE1(v25)] ^ CAST_S_table6[BYTE2(v25)];
    unsigned int v28 = v18 ^ CAST_S_table4[v11] ^ CAST_S_table4[v25] ^ v27 ^ v26;
    int v29 = CAST_S_table4[BYTE1(v28)];
    int v30 = CAST_S_table5[BYTE2(v28)];
    unsigned int v31 = v10 ^ CAST_S_table6[v28] ^ CAST_S_table7[HIBYTE(v28)] ^ CAST_S_table5[v13] ^ v29 ^ v30;
    int v32 = CAST_S_table7[BYTE1(v25)];
    int v33 = v27 ^ v26 ^ CAST_S_table5[v28] ^ v29;
    int v34 = CAST_S_table6[v22];
    int v35 = CAST_S_table7[BYTE1(v22)];
    int v36 = CAST_S_table6[BYTE2(v28)];
    int *v20 = CAST_S_table4[HIBYTE(v28)] ^ CAST_S_table6[v25] ^ CAST_S_table4[BYTE1(v22)] ^ v30 ^ v32;
    v20[1] = v33;
    unsigned int v37 = CAST_S_table4[BYTE2(v25)] ^ CAST_S_table5[v25] ^ CAST_S_table6[HIBYTE(v25)] ^ CAST_S_table6[HIBYTE(v22)] ^ v32 ^ v28;
    int v38 = (LOBYTE(CAST_S_table4[BYTE2(v25)]) ^ LOBYTE(CAST_S_table5[v25]) ^ LOBYTE(CAST_S_table6[HIBYTE(v25)]) ^ LOBYTE(CAST_S_table6[HIBYTE(v22)]) ^ v32 ^ v28);
    int v39 = CAST_S_table5[BYTE1(v37)];
    unsigned int v40 = CAST_S_table4[HIBYTE(v37)] ^ CAST_S_table6[BYTE2(v37)] ^ CAST_S_table7[v38] ^ v22 ^ v35 ^ v39;
    int v41 = CAST_S_table5[BYTE1(v40)] ^ CAST_S_table4[v40];
    int v42 = CAST_S_table4[BYTE1(v31)] ^ CAST_S_table5[v31] ^ CAST_S_table7[HIBYTE(v22)] ^ CAST_S_table7[HIBYTE(v31)] ^ v23;
    unsigned int v43 = CAST_S_table6[BYTE2(v40)] ^ CAST_S_table7[HIBYTE(v40)] ^ CAST_S_table4[BYTE2(v22)] ^ v25 ^ v41;
    int v44 = v43;
    int v45 = BYTE2(v43);
    int v46 = CAST_S_table7[HIBYTE(v43)];
    unsigned int v47 = CAST_S_table4[BYTE1(v43)] ^ CAST_S_table5[BYTE2(v43)] ^ CAST_S_table6[v43] ^ v46 ^ CAST_S_table5[v24] ^ v31;
    int v48 = (LOBYTE(CAST_S_table4[BYTE1(v43)]) ^ LOBYTE(CAST_S_table5[BYTE2(v43)]) ^ LOBYTE(CAST_S_table6[v43]) ^ v46 ^ LOBYTE(CAST_S_table5[v24]) ^ v31);
    int v49 = CAST_S_table4[v38];
    unint64_t v20[2] = CAST_S_table5[BYTE2(v31)] ^ CAST_S_table4[HIBYTE(v31)] ^ v34 ^ v36 ^ v35;
    v20[3] = v42;
    int v50 = CAST_S_table6[HIBYTE(v47)];
    int v51 = CAST_S_table6[HIBYTE(v43)];
    int v52 = v49 ^ CAST_S_table4[HIBYTE(v43)] ^ v39 ^ CAST_S_table7[BYTE2(v47)];
    int v53 = CAST_S_table5[HIBYTE(v37)] ^ CAST_S_table4[BYTE2(v37)] ^ CAST_S_table6[BYTE1(v47)];
    int v54 = CAST_S_table7[v48] ^ CAST_S_table5[BYTE2(v47)];
    int v55 = CAST_S_table5[HIBYTE(v40)] ^ CAST_S_table4[BYTE2(v40)] ^ CAST_S_table6[BYTE1(v43)] ^ CAST_S_table7[v43] ^ CAST_S_table7[v40];
    v20[6] = CAST_S_table7[BYTE2(v43)] ^ CAST_S_table6[v38] ^ v41 ^ v51;
    v20[7] = v55;
    int v56 = CAST_S_table4[BYTE2(v47)] ^ CAST_S_table5[v48];
    int v57 = CAST_S_table7[BYTE1(v47)] ^ v37;
    v20[4] = v52 ^ v50;
    v20[5] = v53 ^ v54;
    unsigned int v58 = v56 ^ v57 ^ v50 ^ v51;
    int v59 = CAST_S_table5[BYTE1(v58)];
    int v60 = v58;
    unsigned int v61 = CAST_S_table4[HIBYTE(v58)] ^ CAST_S_table6[BYTE2(v58)] ^ CAST_S_table7[v58] ^ CAST_S_table7[BYTE1(v43)] ^ v43 ^ v59;
    int v62 = CAST_S_table5[BYTE1(v61)] ^ CAST_S_table4[v61];
    unsigned int v63 = CAST_S_table6[BYTE2(v61)] ^ CAST_S_table7[HIBYTE(v61)] ^ CAST_S_table4[v45] ^ v47 ^ v62;
    unsigned int v64 = CAST_S_table4[BYTE1(v63)] ^ CAST_S_table5[BYTE2(v63)] ^ CAST_S_table6[v63] ^ CAST_S_table7[HIBYTE(v63)] ^ CAST_S_table5[v44] ^ v40;
    int v65 = CAST_S_table4[BYTE2(v61)];
    int v66 = CAST_S_table4[BYTE2(v58)];
    int v67 = CAST_S_table7[BYTE1(v61)];
    int v68 = CAST_S_table5[HIBYTE(v61)] ^ CAST_S_table6[BYTE1(v63)] ^ CAST_S_table7[v63] ^ v65 ^ v67;
    unsigned int v9 = CAST_S_table5[v61] ^ CAST_S_table6[HIBYTE(v61)] ^ CAST_S_table6[HIBYTE(v58)] ^ v65 ^ v67 ^ v63;
    int v69 = CAST_S_table6[BYTE2(v9)];
    int v70 = CAST_S_table4[v58] ^ CAST_S_table6[HIBYTE(v64)] ^ CAST_S_table7[BYTE2(v64)] ^ CAST_S_table4[BYTE2(v63)];
    unsigned int v10 = CAST_S_table4[HIBYTE(v9)] ^ CAST_S_table5[BYTE1(v9)] ^ CAST_S_table7[v9] ^ CAST_S_table7[BYTE1(v58)] ^ v58 ^ v69;
    int v71 = (LOBYTE(CAST_S_table4[HIBYTE(v9)]) ^ LOBYTE(CAST_S_table5[BYTE1(v9)]) ^ LOBYTE(CAST_S_table7[v9]) ^ LOBYTE(CAST_S_table7[BYTE1(v58)]) ^ v58 ^ v69);
    int v72 = CAST_S_table5[HIBYTE(v58)] ^ CAST_S_table6[BYTE1(v64)] ^ CAST_S_table7[v64] ^ CAST_S_table5[HIBYTE(v64)];
    int v73 = CAST_S_table4[(LOBYTE(CAST_S_table4[HIBYTE(v9)]) ^ LOBYTE(CAST_S_table5[BYTE1(v9)]) ^ LOBYTE(CAST_S_table7[v9]) ^ LOBYTE(CAST_S_table7[BYTE1(v58)]) ^ v58 ^ v69)];
    v20[10] = CAST_S_table6[HIBYTE(v63)] ^ CAST_S_table7[BYTE2(v63)] ^ CAST_S_table6[BYTE1(v58)] ^ v62;
    v20[11] = v68;
    int v74 = v70 ^ v59;
    int v75 = CAST_S_table6[BYTE2(v10)];
    int v76 = CAST_S_table7[HIBYTE(v10)];
    int v77 = v73 ^ CAST_S_table5[BYTE1(v10)] ^ v75 ^ v76;
    v20[8] = v74;
    v20[9] = v72 ^ v66;
    unsigned int v14 = v77 ^ v61 ^ v66;
    int v13 = (v77 ^ v61 ^ v66);
    int v12 = BYTE1(v14);
    int v78 = CAST_S_table4[BYTE1(v14)];
    int v11 = BYTE2(v14);
    int v79 = CAST_S_table5[v60] ^ v64;
    int v80 = CAST_S_table5[BYTE2(v14)];
    unsigned int v18 = CAST_S_table6[v13] ^ CAST_S_table7[HIBYTE(v14)] ^ v79 ^ v78 ^ v80;
    int v81 = CAST_S_table4[HIBYTE(v14)] ^ CAST_S_table6[v71] ^ CAST_S_table7[BYTE1(v10)] ^ CAST_S_table4[v9] ^ v80;
    int v17 = BYTE1(v18);
    int v16 = BYTE2(v18);
    int v82 = CAST_S_table5[v13] ^ CAST_S_table5[v71] ^ v75 ^ v76 ^ v78;
    unsigned int v15 = HIBYTE(v18);
    v20[12] = v81;
    v20[13] = v82;
    int v19 = CAST_S_table5[v18];
    int v21 = CAST_S_table6[HIBYTE(v14)];
    int v83 = CAST_S_table4[BYTE1(v18)] ^ CAST_S_table7[HIBYTE(v9)] ^ CAST_S_table7[BYTE2(v18)] ^ v19 ^ v69;
    v20[14] = CAST_S_table5[BYTE2(v18)] ^ CAST_S_table4[HIBYTE(v18)] ^ CAST_S_table6[v9] ^ CAST_S_table7[BYTE1(v9)] ^ v21;
    v20[15] = v83;
    BOOL v84 = v20 == (int *)v88;
    v20 += 16;
  }
  while (v84);
  uint64_t v85 = 0;
  v86.i64[0] = 0x1000000010;
  v86.i64[1] = 0x1000000010;
  v87.i64[0] = 0x1F0000001FLL;
  v87.i64[1] = 0x1F0000001FLL;
  do
  {
    v94.val[0] = *(float32x4_t *)&v88[v85];
    v94.val[1] = (float32x4_t)vandq_s8((int8x16_t)vaddq_s32(*(int32x4_t *)&v88[v85 + 64], v86), v87);
    vst2q_f32((float *)key, v94);
    uint64_t key = (CAST_KEY *)((char *)key + 32);
    v85 += 16;
  }
  while (v85 != 64);
}

void ERR_load_CONF_strings(void)
{
  if (!ERR_func_error_string(CONF_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&CONF_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&CONF_str_reasons);
  }
}

uint64_t pkey_ec_init(uint64_t a1)
{
  uint64_t v2 = malloc_type_calloc(1uLL, 0x40uLL, 0x1070040E3D958DBuLL);
  if (v2)
  {
    v2[12] = 511;
    *(void *)(a1 + 4RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = v2;
    return 1;
  }
  else
  {
    ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_pmeth.c", 102);
    return 0;
  }
}

uint64_t pkey_ec_copy(uint64_t a1, uint64_t a2)
{
  uint64_t result = pkey_ec_init(a1);
  if (result)
  {
    uint64_t v5 = *(void *)(a2 + 40);
    uint64_t v6 = *(void *)(a1 + 40);
    if (!*(void *)v5 || (result = (uint64_t)EC_GROUP_dup(*(const EC_GROUP **)v5), (*(void *)uint64_t v6 = result) != 0))
    {
      int v7 = *(const EC_KEY **)(v5 + 16);
      *(void *)(v6 + 8) = *(void *)(v5 + 8);
      if (!v7 || (uint64_t result = (uint64_t)EC_KEY_dup(v7), (*(void *)(v6 + 16) = result) != 0))
      {
        *(unsigned char *)(v6 + 25) = *(unsigned char *)(v5 + 25);
        uint64_t v8 = *(void *)(v5 + 40);
        *(void *)(v6 + 32) = *(void *)(v5 + 32);
        *(void *)(v6 + 56) = *(void *)(v5 + 56);
        if (v8)
        {
          uint64_t result = (uint64_t)malloc_type_calloc(1uLL, *(void *)(v5 + 48), 0x94AC5A2BuLL);
          *(void *)(v6 + 4RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = result;
          if (!result) {
            return result;
          }
          memcpy((void *)result, *(const void **)(v5 + 40), *(void *)(v5 + 48));
        }
        else
        {
          *(void *)(v6 + 4RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0;
        }
        *(void *)(v6 + 48) = *(void *)(v5 + 48);
        return 1;
      }
    }
  }
  return result;
}

void pkey_ec_cleanup(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1)
  {
    EC_GROUP_free(*(EC_GROUP **)v1);
    EC_KEY_free(*(EC_KEY **)(v1 + 16));
    free(*(void **)(v1 + 40));
    free((void *)v1);
    *(void *)(a1 + 4RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0;
  }
}

uint64_t pkey_ec_paramgen(uint64_t a1, EVP_PKEY *a2)
{
  uint64_t v2 = *(const EC_GROUP ***)(a1 + 40);
  if (!*v2)
  {
    ERR_put_error(16, 4095, 139, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_pmeth.c", 464);
    return 0;
  }
  uint64_t v4 = EC_KEY_new();
  if (!v4) {
    return 0;
  }
  uint64_t v5 = (char *)v4;
  uint64_t v6 = EC_KEY_set_group(v4, *v2);
  if (v6) {
    EVP_PKEY_assign(a2, 408, v5);
  }
  else {
    EC_KEY_free((EC_KEY *)v5);
  }
  return v6;
}

uint64_t pkey_ec_keygen(uint64_t a1, EVP_PKEY *a2)
{
  uint64_t v4 = *(const EC_GROUP ***)(a1 + 40);
  if (!*(void *)(a1 + 16) && !*v4)
  {
    ERR_put_error(16, 4095, 139, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_pmeth.c", 485);
    return 0;
  }
  uint64_t v5 = (char *)EC_KEY_new();
  if (!v5) {
    return 0;
  }
  uint64_t v6 = (EC_KEY *)v5;
  if (!EVP_PKEY_assign(a2, 408, v5))
  {
    EC_KEY_free(v6);
    return 0;
  }
  int v7 = *(const EVP_PKEY **)(a1 + 16);
  if (!v7)
  {
    if (EC_KEY_set_group(v6, *v4)) {
      goto LABEL_11;
    }
    return 0;
  }
  if (!EVP_PKEY_copy_parameters(a2, v7)) {
    return 0;
  }
LABEL_11:
  return EC_KEY_generate_key(v6);
}

uint64_t pkey_ec_sign(uint64_t a1, unsigned __int8 *a2, unint64_t *a3, const unsigned __int8 *a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 16);
  int v7 = *(EC_KEY **)(v6 + 32);
  if (!a2)
  {
    unint64_t v14 = ECDSA_size(*(const EC_KEY **)(v6 + 32));
LABEL_10:
    *a3 = v14;
    return 1;
  }
  uint64_t v11 = *(void *)(a1 + 40);
  unint64_t v12 = *a3;
  if (v12 < ECDSA_size(*(const EC_KEY **)(v6 + 32)))
  {
    ERR_put_error(16, 4095, 100, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_pmeth.c", 176);
    return 0;
  }
  unsigned int v15 = *(const EVP_MD **)(v11 + 8);
  if (v15) {
    int v16 = EVP_MD_type(v15);
  }
  else {
    int v16 = 64;
  }
  sigint len = 0;
  uint64_t result = ECDSA_sign(v16, a4, a5, a2, &siglen, v7);
  if ((int)result >= 1)
  {
    unint64_t v14 = siglen;
    goto LABEL_10;
  }
  return result;
}

uint64_t pkey_ec_verify(uint64_t a1, const unsigned __int8 *a2, int a3, const unsigned __int8 *a4, int a5)
{
  unsigned int v9 = *(EC_KEY **)(*(void *)(a1 + 16) + 32);
  unsigned int v10 = *(const EVP_MD **)(*(void *)(a1 + 40) + 8);
  if (v10) {
    int v11 = EVP_MD_type(v10);
  }
  else {
    int v11 = 64;
  }
  return ECDSA_verify(v11, a4, a5, a2, a3, v9);
}

uint64_t pkey_ec_kdf_derive(void *a1, char *a2, unint64_t *a3)
{
  uint64_t v6 = a1[5];
  if (*(unsigned char *)(v6 + 25) != 1)
  {
    if (a2)
    {
      if (*a3 == *(void *)(v6 + 56))
      {
        size_t size = 0;
        if (pkey_ec_derive(a1, 0, &size))
        {
          uint64_t v8 = malloc_type_calloc(1uLL, size, 0x109F10A0uLL);
          if (v8)
          {
            unsigned int v9 = v8;
            int v10 = pkey_ec_derive(a1, v8, &size);
            size_t v11 = size;
            if (v10) {
              BOOL v12 = ecdh_KDF_X9_63(a2, *a3, v9, size, *(const void **)(v6 + 40), *(void *)(v6 + 48), *(const EVP_MD **)(v6 + 32)) != 0;
            }
            else {
              BOOL v12 = 0;
            }
            freezero(v9, v11);
            return v12;
          }
          ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_pmeth.c", 269);
        }
      }
      return 0;
    }
    else
    {
      *a3 = *(void *)(v6 + 56);
      return 1;
    }
  }
  return pkey_ec_derive(a1, a2, a3);
}

uint64_t pkey_ec_ctrl(uint64_t a1, unsigned int a2, int nid, EVP_MD *md)
{
  uint64_t v5 = *(void *)(a1 + 40);
  switch(a2)
  {
    case 0x1001u:
      int v7 = EC_GROUP_new_by_curve_name(nid);
      if (v7)
      {
        uint64_t v8 = v7;
        EC_GROUP_free(*(EC_GROUP **)v5);
        *(void *)uint64_t v5 = v8;
        return 1;
      }
      int v14 = 141;
      int v15 = 296;
      goto LABEL_48;
    case 0x1002u:
      if (*(void *)v5)
      {
        EC_GROUP_set_asn1_flag(*(EC_GROUP **)v5, nid);
        return 1;
      }
      int v14 = 139;
      int v15 = 305;
      goto LABEL_48;
    case 0x1003u:
      if (nid == -2)
      {
        uint64_t result = *(char *)(v5 + 24);
        if (result == -1) {
          return (EC_KEY_get_flags(*(void *)(*(void *)(a1 + 16) + 32)) >> 12) & 1;
        }
        return result;
      }
      if ((nid - 2) < 0xFFFFFFFD) {
        return 4294967294;
      }
      *(unsigned char *)(v5 + 24) = nid;
      if (nid == -1)
      {
        EC_KEY_free(*(EC_KEY **)(v5 + 16));
        *(void *)(v5 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = 0;
        return 1;
      }
      uint64_t v12 = *(void *)(*(void *)(a1 + 16) + 32);
      uint64_t v13 = *(void *)(v12 + 24);
      if (!v13) {
        return 4294967294;
      }
      if (BN_is_one(v13 + 40)) {
        return 1;
      }
      uint64_t result = *(void *)(v5 + 16);
      if (!result)
      {
        uint64_t result = (uint64_t)EC_KEY_dup((const EC_KEY *)v12);
        *(void *)(v5 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = result;
        if (!result) {
          return result;
        }
      }
      if (nid) {
        EC_KEY_set_flags(result, 4096);
      }
      else {
        EC_KEY_clear_flags(result, 4096);
      }
      return 1;
    case 0x1004u:
      if (nid == -2) {
        return *(char *)(v5 + 25);
      }
      if ((nid - 3) < 0xFFFFFFFE) {
        return 4294967294;
      }
      *(unsigned char *)(v5 + 25) = nid;
      return 1;
    case 0x1005u:
      *(void *)(v5 + 32) = md;
      return 1;
    case 0x1006u:
      uint64_t v9 = *(void *)(v5 + 32);
      goto LABEL_20;
    case 0x1007u:
      if (nid < 1) {
        return 4294967294;
      }
      *(void *)(v5 + 56) = nid;
      return 1;
    case 0x1008u:
      md->int type = *(void *)(v5 + 56);
      return 1;
    case 0x1009u:
      free(*(void **)(v5 + 40));
      *(void *)(v5 + 4RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = md;
      if (md) {
        *(void *)(v5 + 48) = nid;
      }
      else {
        *(void *)(v5 + 48) = 0;
      }
      return 1;
    case 0x100Au:
      *(void *)&md->int type = *(void *)(v5 + 40);
      return *(unsigned int *)(v5 + 48);
    default:
      if (a2 > 0xD) {
        return 4294967294;
      }
      if (((1 << a2) & 0x8A4) != 0) {
        return 1;
      }
      if (a2 != 1)
      {
        if (a2 != 13) {
          return 4294967294;
        }
        uint64_t v9 = *(void *)(v5 + 8);
LABEL_20:
        *(void *)&md->int type = v9;
        return 1;
      }
      if (EVP_MD_type(md) == 64
        || EVP_MD_type(md) == 416
        || EVP_MD_type(md) == 675
        || EVP_MD_type(md) == 672
        || EVP_MD_type(md) == 673
        || EVP_MD_type(md) == 674
        || EVP_MD_type(md) == 1031
        || EVP_MD_type(md) == 1032
        || EVP_MD_type(md) == 1033
        || EVP_MD_type(md) == 1034)
      {
        *(void *)(v5 + 8) = md;
        return 1;
      }
      int v14 = 138;
      int v15 = 395;
LABEL_48:
      ERR_put_error(16, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_pmeth.c", v15);
      return 0;
  }
}

uint64_t pkey_ec_ctrl_str(uint64_t *a1, char *__s1, char *a3)
{
  if (!strcmp(__s1, "ec_paramgen_curve"))
  {
    if (EC_curve_nist2nid(a3) || OBJ_sn2nid(a3) || OBJ_ln2nid(a3))
    {
      uint64_t v6 = a1;
      int v7 = 6;
      goto LABEL_16;
    }
    int v9 = 141;
    int v10 = 429;
LABEL_21:
    ERR_put_error(16, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_pmeth.c", v10);
    return 0;
  }
  if (!strcmp(__s1, "ec_param_enc"))
  {
    if (!strcmp(a3, "explicit") || !strcmp(a3, "named_curve"))
    {
      uint64_t v6 = a1;
      int v7 = 6;
      goto LABEL_16;
    }
    return 4294967294;
  }
  if (!strcmp(__s1, "ecdh_kdf_md"))
  {
    if (EVP_get_digestbyname(a3))
    {
      uint64_t v6 = a1;
      int v7 = 1024;
      goto LABEL_16;
    }
    int v9 = 151;
    int v10 = 445;
    goto LABEL_21;
  }
  if (strcmp(__s1, "ecdh_cofactor_mode")) {
    return 4294967294;
  }
  atoi(a3);
  uint64_t v6 = a1;
  int v7 = 1024;
LABEL_16:
  return EVP_PKEY_CTX_ctrl(v6, 408, v7);
}

uint64_t pkey_ec_derive(void *a1, void *a2, size_t *a3)
{
  uint64_t v3 = a1[2];
  if (!v3 || (uint64_t v4 = a1[3]) == 0)
  {
    ERR_put_error(16, 4095, 140, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_pmeth.c", 220);
    return 0;
  }
  int v7 = *(const EC_KEY **)(a1[5] + 16);
  if (v7)
  {
    if (a2) {
      goto LABEL_5;
    }
LABEL_10:
    uint64_t v12 = EC_KEY_get0_group(v7);
    int degree = EC_GROUP_get_degree(v12);
    int v14 = degree + 7;
    if (degree < -7) {
      int v14 = degree + 14;
    }
    uint64_t v10 = (uint64_t)v14 >> 3;
    goto LABEL_13;
  }
  int v7 = *(const EC_KEY **)(v3 + 32);
  if (!a2) {
    goto LABEL_10;
  }
LABEL_5:
  uint64_t v8 = EC_KEY_get0_public_key(*(const EC_KEY **)(v4 + 32));
  int v9 = ECDH_compute_key(a2, *a3, v8, v7, 0);
  if (v9 < 1) {
    return 0;
  }
  uint64_t v10 = v9;
LABEL_13:
  *a3 = v10;
  return 1;
}

int X509_NAME_print_ex(BIO *out, X509_NAME *nm, int indent, unint64_t flags)
{
  if (flags) {
    return do_name_ex((unsigned int (*)(uint64_t, char *, uint64_t))send_bio_chars, (uint64_t)out, nm, indent, flags);
  }
  else {
    return X509_NAME_print(out, nm, indent);
  }
}

uint64_t do_name_ex(unsigned int (*a1)(uint64_t, char *, uint64_t), uint64_t a2, X509_NAME *name, int a4, int a5)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  uint64_t v9 = a4 & ~(a4 >> 31);
  if (a4 >= 1)
  {
    int v10 = a4 & ~(a4 >> 31);
    do
    {
      if (!a1(a2, " ", 1)) {
        return 0xFFFFFFFFLL;
      }
      --v10;
    }
    while (v10);
  }
  unsigned int v46 = 3;
  int v11 = 1;
  int v12 = v9;
  uint64_t v13 = " + ";
  int v14 = "\n";
  switch(((*(void *)&a5 & 0xF0000uLL) - 0x10000) >> 16)
  {
    case 0uLL:
      int v12 = 0;
      uint64_t v13 = "+";
      unsigned int v46 = 1;
      int v14 = ",";
      break;
    case 1uLL:
      int v12 = 0;
      unsigned int v46 = 3;
      int v11 = 2;
      int v14 = ", ";
      break;
    case 2uLL:
      int v12 = 0;
      unsigned int v46 = 3;
      int v11 = 2;
      int v14 = "; ";
      break;
    case 3uLL:
      break;
    default:
      return 0xFFFFFFFFLL;
  }
  int v15 = " = ";
  if ((*(void *)&a5 & 0x800000) == 0) {
    int v15 = "=";
  }
  int v45 = v15;
  if ((*(void *)&a5 & 0x800000) != 0) {
    int v16 = 3;
  }
  else {
    int v16 = 1;
  }
  unsigned int v44 = v16;
  int v17 = X509_NAME_entry_count(name);
  if (v17 >= 1)
  {
    int v18 = v17;
    int v38 = v14;
    int v39 = v13;
    int v19 = 0;
    int v47 = a5 & 0x600000;
    int v40 = v12;
    unsigned int v41 = v11;
    int v37 = v11 + v12;
    int v20 = -1;
    unsigned int v43 = name;
    int v42 = v17;
    do
    {
      if ((*(void *)&a5 & 0x100000) != 0) {
        int v21 = v18 + ~v19;
      }
      else {
        int v21 = v19;
      }
      entry = X509_NAME_get_entry(name, v21);
      int v23 = entry;
      if (v20 != -1)
      {
        if (v20 == X509_NAME_ENTRY_set((uint64_t)entry))
        {
          if (!a1(a2, (char *)v39, v46)) {
            return 0xFFFFFFFFLL;
          }
          LODWORD(v9) = v9 + v46;
        }
        else
        {
          if (!a1(a2, (char *)v38, v41)) {
            return 0xFFFFFFFFLL;
          }
          int v24 = v40;
          if (v40)
          {
            while (a1(a2, " ", 1))
            {
              if (!--v24) {
                goto LABEL_27;
              }
            }
            return 0xFFFFFFFFLL;
          }
LABEL_27:
          LODWORD(v9) = v37 + v9;
        }
      }
      int v20 = X509_NAME_ENTRY_set((uint64_t)v23);
      object = X509_NAME_ENTRY_get_object(v23);
      uint64_t data = X509_NAME_ENTRY_get_data(v23);
      int v26 = OBJ_obj2nid(object);
      int v27 = v26;
      if (v47 != 6291456)
      {
        if (v47 == 0x400000 || !v26)
        {
          unsigned int v28 = buf;
          OBJ_obj2txt(buf, 80, object, 1);
          int v29 = 0;
        }
        else if (v47 == 0x200000)
        {
          unsigned int v28 = OBJ_nid2ln(v26);
          int v29 = 25;
        }
        else if (v47)
        {
          int v29 = 0;
          unsigned int v28 = "";
        }
        else
        {
          unsigned int v28 = OBJ_nid2sn(v26);
          int v29 = 10;
        }
        size_t v30 = strlen(v28);
        if (!a1(a2, (char *)v28, v30)) {
          return 0xFFFFFFFFLL;
        }
        if ((a5 & 0x2000000) != 0)
        {
          int v31 = v29 - v30;
          if (v29 > (int)v30)
          {
            int v32 = v29 - v30;
            if (v31 >= 1)
            {
              while (a1(a2, " ", 1))
              {
                if (!--v32) {
                  goto LABEL_43;
                }
              }
              return 0xFFFFFFFFLL;
            }
LABEL_43:
            LODWORD(v9) = v31 + v9;
          }
        }
        name = v43;
        if (!a1(a2, (char *)v45, v44)) {
          return 0xFFFFFFFFLL;
        }
        LODWORD(v9) = v44 + v30 + v9;
        int v18 = v42;
      }
      if (v27) {
        BOOL v33 = 1;
      }
      else {
        BOOL v33 = (a5 & 0x1000000) == 0;
      }
      __int16 v34 = 128;
      if (v33) {
        __int16 v34 = 0;
      }
      int v35 = do_print_ex(a1, a2, v34 | (unsigned __int16)a5, (uint64_t)data);
      if (v35 < 0) {
        return 0xFFFFFFFFLL;
      }
      uint64_t v9 = (v35 + v9);
      ++v19;
    }
    while (v19 != v18);
  }
  return v9;
}

BOOL send_bio_chars(BIO *a1, const void *a2, int a3)
{
  return !a1 || BIO_write(a1, a2, a3) == a3;
}

int X509_NAME_print_ex_fp(FILE *fp, X509_NAME *nm, int indent, unint64_t flags)
{
  if (flags)
  {
    return do_name_ex((unsigned int (*)(uint64_t, char *, uint64_t))send_fp_chars, (uint64_t)fp, nm, indent, flags);
  }
  else
  {
    int v7 = BIO_new_fp(fp, 0);
    if (v7)
    {
      uint64_t v8 = v7;
      int v9 = X509_NAME_print(v7, nm, indent);
      BIO_free(v8);
      return v9;
    }
    else
    {
      return -1;
    }
  }
}

BOOL send_fp_chars(FILE *__stream, void *__ptr, int a3)
{
  return !__stream || fwrite(__ptr, 1uLL, a3, __stream) == a3;
}

int ASN1_STRING_print_ex(BIO *out, ASN1_STRING *str, unint64_t flags)
{
  return do_print_ex((unsigned int (*)(uint64_t, char *, uint64_t))send_bio_chars, (uint64_t)out, flags, (uint64_t)str);
}

uint64_t do_print_ex(unsigned int (*a1)(uint64_t, char *, uint64_t), uint64_t a2, __int16 a3, uint64_t a4)
{
  int v8 = 0;
  char v25 = 0;
  unsigned int v9 = *(_DWORD *)(a4 + 4);
  if ((a3 & 0x40) != 0)
  {
    int v10 = ASN1_tag2str(*(_DWORD *)(a4 + 4));
    size_t v11 = strlen(v10);
    if (!a1(a2, (char *)v10, v11)) {
      return 0xFFFFFFFFLL;
    }
    unsigned int v12 = a1(a2, ":", 1);
    int v8 = v12 ? v11 + 1 : v11;
    if (!v12) {
      return 0xFFFFFFFFLL;
    }
  }
  if ((a3 & 0x80) != 0) {
    goto LABEL_28;
  }
  if ((a3 & 0x20) != 0)
  {
LABEL_13:
    unsigned int v14 = 9;
    unsigned int v13 = 1;
    goto LABEL_14;
  }
  unsigned int v13 = asn1_tag2charwidth(v9);
  if (v13 == -1)
  {
    if ((a3 & 0x100) == 0) {
      goto LABEL_13;
    }
LABEL_28:
    if (a1(a2, "#", 1))
    {
      if ((a3 & 0x200) != 0)
      {
        int v20 = *(_DWORD *)(a4 + 4);
        *(&a.type + md5_block_data_order((unint64_t)c, b, 1) = 0;
        a.value.ptr = (char *)a4;
        a.int type = v20;
        int v21 = i2d_ASN1_TYPE(&a, 0);
        unsigned int v22 = (unsigned __int8 *)malloc_type_malloc(v21, 0x6B9AAD46uLL);
        if (!v22) {
          return 0xFFFFFFFFLL;
        }
        int v23 = v22;
        unsigned __int8 out = v22;
        i2d_ASN1_TYPE(&a, &out);
        int v19 = do_hex_dump(a1, a2, v23, v21);
        free(v23);
        if (v19 < 0) {
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        int v19 = do_hex_dump(a1, a2, *(unsigned __int8 **)(a4 + 8), *(_DWORD *)a4);
        if (v19 < 0) {
          return 0xFFFFFFFFLL;
        }
      }
      if (v19 > -2) {
        return (v8 + v19 + 1);
      }
    }
    return 0xFFFFFFFFLL;
  }
  unsigned int v14 = v13 | 8;
  if (!v13) {
    unsigned int v14 = 1;
  }
LABEL_14:
  char v15 = a3 & 0xF;
  if ((a3 & 0x10) != 0) {
    uint64_t v16 = v14;
  }
  else {
    uint64_t v16 = v13;
  }
  int v17 = do_buf(*(unsigned __int8 **)(a4 + 8), *(_DWORD *)a4, v16, a3 & 0xF, &v25, a1, 0);
  if (v17 < 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v18 = v25 ? (v17 + v8 + 2) : (v17 + v8);
  if (a2
    && (v25 && !a1(a2, "\"", 1)
     || (do_buf(*(unsigned __int8 **)(a4 + 8), *(_DWORD *)a4, v16, v15, 0, a1, a2) & 0x80000000) != 0
     || v25 && !a1(a2, "\"", 1)))
  {
    return 0xFFFFFFFFLL;
  }
  return v18;
}

int ASN1_STRING_print_ex_fp(FILE *fp, ASN1_STRING *str, unint64_t flags)
{
  return do_print_ex((unsigned int (*)(uint64_t, char *, uint64_t))send_fp_chars, (uint64_t)fp, flags, (uint64_t)str);
}

uint64_t do_buf(unsigned __int8 *str, int a2, uint64_t a3, char a4, unsigned char *a5, unsigned int (*a6)(uint64_t, char *, uint64_t), uint64_t a7)
{
  if (!a2) {
    return 0;
  }
  uint64_t v7 = a3;
  unsigned int v8 = a3 & 7;
  uint64_t v9 = 0xFFFFFFFFLL;
  if (v8 <= 4 && v8 != 3)
  {
    unsigned int v14 = str;
    uint64_t v9 = 0;
    unint64_t val = 0;
    char v15 = str;
    uint64_t v16 = &str[a2];
    unsigned int v39 = a3 & 7;
    int v38 = v16;
    do
    {
      if (v15 != v14 || (a4 & 1) == 0) {
        char v18 = 0;
      }
      else {
        char v18 = 32;
      }
      switch(v8)
      {
        case 1u:
          unsigned int v23 = *v15++;
          unint64_t val = v23;
          break;
        case 2u:
          uint64_t v24 = *v15;
          unint64_t val = v24 << 8;
          unint64_t val = v15[1] | ((unint64_t)v24 << 8);
          if ((v24 & 0xF8) == 0xD8) {
            return 0xFFFFFFFFLL;
          }
          v15 += 2;
          break;
        case 4u:
          unint64_t val = (unint64_t)*v15 << 24;
          unint64_t v19 = val | ((unint64_t)v15[1] << 16);
          unint64_t val = v19;
          unint64_t v20 = v19 | ((unint64_t)v15[2] << 8);
          unint64_t val = v20;
          unint64_t val = v20 | v15[3];
          uint64_t v21 = v20 & 0xFFFFF800;
          if (v19 >> 16 > 0x10 || v21 == 55296) {
            return 0xFFFFFFFFLL;
          }
          v15 += 4;
          break;
        default:
          unsigned int v25 = UTF8_getc(v15, v16 - v15, &val);
          if ((v25 & 0x80000000) != 0) {
            return 0xFFFFFFFFLL;
          }
          v15 += v25;
          break;
      }
      if (v15 != v16 || (a4 & 1) == 0) {
        char v27 = v18;
      }
      else {
        char v27 = 64;
      }
      if ((v7 & 8) != 0)
      {
        uint64_t v29 = v7;
        unsigned int v30 = UTF8_putc(stra, 6, val);
        if ((v30 & 0x80000000) != 0) {
          return 0xFFFFFFFFLL;
        }
        if (v30)
        {
          char v31 = v27 | a4;
          uint64_t v32 = v30;
          BOOL v33 = stra;
          do
          {
            unsigned int v34 = *v33++;
            int v35 = do_esc_char(v34, v31, a5, a6, a7);
            if (v35 < 0) {
              return 0xFFFFFFFFLL;
            }
            uint64_t v9 = (v35 + v9);
          }
          while (--v32);
        }
        uint64_t v7 = v29;
        unsigned int v14 = str;
      }
      else
      {
        int v28 = do_esc_char(val, v27 | a4, a5, a6, a7);
        if (v28 < 0) {
          return 0xFFFFFFFFLL;
        }
        uint64_t v9 = (v28 + v9);
      }
      uint64_t v16 = v38;
      unsigned int v8 = v39;
    }
    while (v15 != v38);
  }
  return v9;
}

uint64_t do_hex_dump(unsigned int (*a1)(uint64_t, unsigned char *, uint64_t), uint64_t a2, unsigned __int8 *a3, int a4)
{
  if (!a2 || !a4) {
    return (2 * a4);
  }
  uint64_t v8 = a4;
  while (1)
  {
    unint64_t v9 = *a3;
    v11[0] = do_hex_dump_hexdig[v9 >> 4];
    v11[1] = do_hex_dump_hexdig[v9 & 0xF];
    if (!a1(a2, v11, 2)) {
      break;
    }
    ++a3;
    if (!--v8) {
      return (2 * a4);
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t do_esc_char(unint64_t a1, char a2, unsigned char *a3, unsigned int (*a4)(uint64_t, char *, uint64_t), uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  if (HIDWORD(a1)) {
    return 0xFFFFFFFFLL;
  }
  if (a1 >= 0x10000)
  {
    snprintf(__str, 0x13uLL, "\\W%08lX", a1);
    unsigned int v8 = 10;
    unint64_t v9 = __str;
    uint64_t v10 = a5;
    uint64_t v11 = 10;
    goto LABEL_7;
  }
  if (a1 >= 0x100)
  {
    snprintf(__str, 0x13uLL, "\\U%04lX", a1);
    unsigned int v8 = 6;
    unint64_t v9 = __str;
    uint64_t v10 = a5;
    uint64_t v11 = 6;
    goto LABEL_7;
  }
  char v13 = a1;
  if ((a1 & 0x80) != 0) {
    char v12 = a2 & 4;
  }
  else {
    char v12 = char_type[a1] & a2;
  }
  if ((v12 & 0x61) == 0)
  {
    if ((v12 & 6) != 0)
    {
      snprintf(__str, 0x13uLL, "\\%02X", a1);
      unsigned int v8 = 3;
      unint64_t v9 = __str;
      uint64_t v10 = a5;
      uint64_t v11 = 3;
    }
    else
    {
      if (a1 != 92 || (a2 & 0xF) == 0)
      {
LABEL_24:
        if (a4(a5, &v13, 1)) {
          return 1;
        }
        else {
          return 0xFFFFFFFFLL;
        }
      }
      unint64_t v9 = "\\\\"";
      unsigned int v8 = 2;
      uint64_t v10 = a5;
      uint64_t v11 = 2;
    }
LABEL_7:
    if (a4(v10, v9, v11)) {
      return v8;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  if ((v12 & 8) != 0)
  {
    if (a3) {
      *a3 = 1;
    }
    goto LABEL_24;
  }
  if (!a4(a5, "\\"", 1)) {
    return 0xFFFFFFFFLL;
  }
  if (a4(a5, &v13, 1)) {
    return 2;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t CRYPTO_ctr128_encrypt(uint64_t result, unsigned char *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int *a7, uint64_t (*a8)(uint64_t, uint64_t, uint64_t))
{
  unsigned int v14 = (char *)result;
  unsigned int v15 = *a7;
  if (*a7) {
    BOOL v16 = a3 == 0;
  }
  else {
    BOOL v16 = 1;
  }
  if (v16)
  {
    unint64_t v17 = a3;
  }
  else
  {
    do
    {
      char v18 = *v14++;
      *a2++ = *(unsigned char *)(a6 + v15) ^ v18;
      unint64_t v17 = a3 - 1;
      unsigned int v15 = ((_BYTE)v15 + 1) & 0xF;
      if (!v15) {
        break;
      }
      --a3;
    }
    while (a3);
  }
  if (v17 < 0x10)
  {
    unsigned int v23 = v15;
    if (!v17) {
      goto LABEL_25;
    }
    goto LABEL_21;
  }
  do
  {
    uint64_t result = a8(a5, a6, a4);
    uint64_t v19 = 15;
    do
    {
      char v20 = *(unsigned char *)(a5 + v19) + 1;
      *(unsigned char *)(a5 + v19) = v20;
      if (!v19) {
        break;
      }
      --v19;
    }
    while (!v20);
    if (v15 <= 0xF)
    {
      unint64_t v21 = v15;
      do
      {
        *(void *)&a2[v21] = *(void *)(a6 + v21) ^ *(void *)&v14[v21];
        BOOL v22 = v21 >= 8;
        v21 += 8;
      }
      while (!v22);
    }
    unsigned int v15 = 0;
    unsigned int v23 = 0;
    v17 -= 16;
    a2 += 16;
    v14 += 16;
  }
  while (v17 > 0xF);
  if (v17)
  {
LABEL_21:
    uint64_t result = a8(a5, a6, a4);
    uint64_t v24 = 15;
    do
    {
      char v25 = *(unsigned char *)(a5 + v24) + 1;
      *(unsigned char *)(a5 + v24) = v25;
      if (!v24) {
        break;
      }
      --v24;
    }
    while (!v25);
    do
    {
      a2[v23] = *(unsigned char *)(a6 + v23) ^ v14[v23];
      ++v23;
      --v17;
    }
    while (v17);
  }
LABEL_25:
  *a7 = v23;
  return result;
}

uint64_t CRYPTO_ctr128_encrypt_ctr32(uint64_t result, unsigned char *a2, unint64_t a3, uint64_t a4, uint64_t a5, void *a6, unsigned int *a7, uint64_t (*a8)(char *, unsigned char *, unint64_t, uint64_t, uint64_t))
{
  char v12 = (char *)result;
  unsigned int v13 = *a7;
  if (*a7) {
    BOOL v14 = a3 == 0;
  }
  else {
    BOOL v14 = 1;
  }
  if (v14)
  {
    unint64_t v15 = a3;
  }
  else
  {
    do
    {
      char v16 = *v12++;
      *a2++ = *((unsigned char *)a6 + v13) ^ v16;
      unint64_t v15 = a3 - 1;
      unsigned int v13 = ((_BYTE)v13 + 1) & 0xF;
      if (!v13) {
        break;
      }
      --a3;
    }
    while (a3);
  }
  unsigned int v17 = bswap32(*(_DWORD *)(a5 + 12));
  if (v15 >= 0x10)
  {
    do
    {
      unint64_t v18 = v15 >> 4;
      if (v15 >> 4 >= 0x10000000) {
        unint64_t v18 = 0x10000000;
      }
      unint64_t v19 = v17 + v18;
      if (v18 <= v19) {
        v17 += v18;
      }
      else {
        unsigned int v17 = 0;
      }
      if (v18 <= v19) {
        unint64_t v19 = 0;
      }
      unint64_t v20 = v18 - v19;
      uint64_t result = a8(v12, a2, v18 - v19, a4, a5);
      *(_DWORD *)(a5 + 12) = bswap32(v17);
      if (!v17)
      {
        uint64_t v21 = 11;
        do
        {
          char v22 = *(unsigned char *)(a5 + v21) + 1;
          *(unsigned char *)(a5 + v2md5_block_data_order((unint64_t)c, b, 1) = v22;
          if (!v21) {
            break;
          }
          --v21;
        }
        while (!v22);
      }
      v15 -= 16 * v20;
      a2 += 16 * v20;
      v12 += 16 * v20;
    }
    while (v15 > 0xF);
  }
  if (v15)
  {
    *a6 = 0;
    a6[1] = 0;
    uint64_t result = a8((char *)a6, a6, 1uLL, a4, a5);
    *(_DWORD *)(a5 + 12) = bswap32(v17 + 1);
    if (v17 == -1)
    {
      uint64_t v23 = 11;
      do
      {
        char v24 = *(unsigned char *)(a5 + v23) + 1;
        *(unsigned char *)(a5 + v23) = v24;
        if (!v23) {
          break;
        }
        --v23;
      }
      while (!v24);
    }
    char v25 = a7;
    do
    {
      a2[v13] = *((unsigned char *)a6 + v13) ^ v12[v13];
      ++v13;
      --v15;
    }
    while (v15);
  }
  else
  {
    char v25 = a7;
  }
  unsigned int *v25 = v13;
  return result;
}

void ERR_load_GOST_strings()
{
  if (!ERR_func_error_string(GOST_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&GOST_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&GOST_str_reasons);
  }
}

void *x509_constraints_name_new()
{
  return malloc_type_calloc(1uLL, 0x50uLL, 0x1010040B88FB30EuLL);
}

double x509_constraints_name_clear(uint64_t a1)
{
  free(*(void **)(a1 + 8));
  free(*(void **)(a1 + 16));
  free(*(void **)(a1 + 24));
  double result = 0.0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  return result;
}

void x509_constraints_name_free(void *a1)
{
  if (a1)
  {
    x509_constraints_name_clear((uint64_t)a1);
    free(a1);
  }
}

uint64_t x509_constraints_name_dup(uint64_t a1)
{
  uint64_t v2 = malloc_type_calloc(1uLL, 0x50uLL, 0x1010040B88FB30EuLL);
  uint64_t v3 = (uint64_t)v2;
  if (v2)
  {
    *uint64_t v2 = *(_DWORD *)a1;
    v2[10] = *(_DWORD *)(a1 + 40);
    *((void *)v2 + 4) = *(void *)(a1 + 32);
    size_t v4 = *(void *)(a1 + 32);
    if (v4)
    {
      uint64_t v5 = malloc_type_malloc(v4, 0x41EC30A9uLL);
      *(void *)(v3 + 24) = v5;
      if (!v5) {
        goto LABEL_10;
      }
      memcpy(v5, *(const void **)(a1 + 24), *(void *)(a1 + 32));
    }
    uint64_t v6 = *(const char **)(a1 + 8);
    if (!v6 || (uint64_t v7 = strdup(v6), (*(void *)(v3 + 8) = v7) != 0))
    {
      unsigned int v8 = *(const char **)(a1 + 16);
      if (!v8 || (unint64_t v9 = strdup(v8), (*(void *)(v3 + 16) = v9) != 0))
      {
        long long v10 = *(_OWORD *)(a1 + 44);
        *(_OWORD *)(v3 + 6RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = *(_OWORD *)(a1 + 60);
        *(_OWORD *)(v3 + 44) = v10;
        return v3;
      }
    }
LABEL_10:
    x509_constraints_name_clear(v3);
    free((void *)v3);
    return 0;
  }
  return v3;
}

void *x509_constraints_names_new(uint64_t a1)
{
  double result = malloc_type_calloc(1uLL, 0x20uLL, 0x1080040ABB4582EuLL);
  if (result) {
    result[3] = a1;
  }
  return result;
}

double x509_constraints_names_clear(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    for (unint64_t i = 0; i < v2; ++i)
    {
      size_t v4 = *(void **)(*(void *)a1 + 8 * i);
      if (v4)
      {
        x509_constraints_name_clear(*(void *)(*(void *)a1 + 8 * i));
        free(v4);
        unint64_t v2 = *(void *)(a1 + 8);
      }
    }
  }
  free(*(void **)a1);
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = 0u;
  return result;
}

void x509_constraints_names_free(void *a1)
{
  if (a1)
  {
    x509_constraints_names_clear((uint64_t)a1);
    free(a1);
  }
}

char *x509_constraints_names_add(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a1 + 8);
  if (v3 >= *(void *)(a1 + 24)) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  double result = *(char **)a1;
  if (v3 == v5)
  {
    double result = recallocarray(result, v3, v3 + 32, 8uLL);
    if (!result) {
      return result;
    }
    unint64_t v3 = *(void *)(a1 + 8);
    *(void *)(a1 + 16) += 32;
    *(void *)a1 = result;
  }
  *(void *)&result[8 * v3] = a2;
  *(void *)(a1 + 8) = v3 + 1;
  return (char *)1;
}

void *x509_constraints_names_dup(void *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = a1[3];
  unint64_t v3 = malloc_type_calloc(1uLL, 0x20uLL, 0x1080040ABB4582EuLL);
  size_t v4 = v3;
  if (v3)
  {
    *((void *)v3 + 3) = v2;
    if (a1[1])
    {
      uint64_t v5 = 0;
      while (1)
      {
        uint64_t v6 = x509_constraints_name_dup(*(void *)(*a1 + 8 * v5));
        if (!v6)
        {
          x509_constraints_names_clear((uint64_t)v4);
          uint64_t v7 = v4;
          goto LABEL_12;
        }
        uint64_t v7 = (void *)v6;
        if (!x509_constraints_names_add((uint64_t)v4, v6)) {
          break;
        }
        if ((unint64_t)++v5 >= a1[1]) {
          return v4;
        }
      }
      x509_constraints_names_clear((uint64_t)v4);
      free(v4);
      x509_constraints_name_clear((uint64_t)v7);
LABEL_12:
      free(v7);
      return 0;
    }
  }
  return v4;
}

uint64_t x509_constraints_valid_host(void *a1)
{
  _OWORD v8[2] = *MEMORY[0x263EF8340];
  char v4 = 0;
  int v2 = CBS_peek_u8((uint64_t)a1, &v4);
  uint64_t result = 0;
  if (v2 && v4 != 46)
  {
    uint64_t v5 = 0;
    if ((unint64_t)CBS_len((uint64_t)a1) <= 0x2E)
    {
      memset(v6, 0, sizeof(v6));
      int v7 = 0;
      v8[0] = 0;
      v8[1] = 0;
      if (CBS_strdup((uint64_t)a1, (void **)&v5))
      {
        if (inet_pton(2, v5, v8) == 1 || inet_pton(30, v5, v6) == 1)
        {
          free(v5);
          return 0;
        }
        free(v5);
      }
    }
    return x509_constraints_valid_domain_internal(a1, 0);
  }
  return result;
}

uint64_t x509_constraints_valid_domain_internal(void *a1, int a2)
{
  unsigned __int8 v14 = 0;
  memset(v13, 0, sizeof(v13));
  CBS_dup(a1, v13);
  unint64_t v4 = CBS_len((uint64_t)a1);
  uint64_t result = 0;
  if (v4 <= 0xFF)
  {
    if (v4)
    {
      int v6 = 0;
      uint64_t v7 = 0;
      int v8 = 0;
      unint64_t v9 = v4 - 1;
      uint64_t v10 = MEMORY[0x263EF8318];
      while (1)
      {
        uint64_t result = CBS_get_u8(v13, &v14);
        if (!result) {
          break;
        }
        if ((char)v14 < 1) {
          return 0;
        }
        if ((*(_DWORD *)(v10 + 4 * v14 + 60) & 0x500) == 0
          && (v14 - 42 > 0x35 || ((1 << (v14 - 42)) & 0x20000000000019) == 0))
        {
          return 0;
        }
        if (!a2 && v14 == 42) {
          return 0;
        }
        if (v14 == 46)
        {
          uint64_t result = 0;
          if (v7) {
            BOOL v12 = v8 == 0;
          }
          else {
            BOOL v12 = 0;
          }
          if (v12 || v9 == v7 || v6 == 45) {
            return result;
          }
        }
        else
        {
          if (v14 == 45)
          {
            uint64_t result = 0;
            if (!v8 || v9 == v7) {
              return result;
            }
          }
          uint64_t result = 0;
          if (v6 == 42 || v8 > 62) {
            return result;
          }
          LODWORD(result) = v8 + 1;
        }
        ++v7;
        int v6 = v14;
        int v8 = result;
        if (v4 == v7) {
          return 1;
        }
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t x509_constraints_valid_sandns(void *a1)
{
  char v4 = 0;
  int v2 = CBS_peek_u8((uint64_t)a1, &v4);
  uint64_t result = 0;
  if (v2 && v4 != 46)
  {
    if ((unint64_t)CBS_len((uint64_t)a1) <= 3 && v4 == 42) {
      return 0;
    }
    else {
      return x509_constraints_valid_domain_internal(a1, 1);
    }
  }
  return result;
}

uint64_t x509_constraints_parse_mailbox(uint64_t result, uint64_t a2)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v26 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  *(_OWORD *)__s1 = 0u;
  if (!result) {
    return result;
  }
  memset(v20, 0, sizeof(v20));
  memset(v19, 0, sizeof(v19));
  CBS_dup((void *)result, v19);
  uint64_t v3 = CBS_len((uint64_t)v19);
  if ((unint64_t)(v3 - 321) < 0xFFFFFFFFFFFFFEC0) {
    return 0;
  }
  uint64_t v4 = v3;
  uint64_t v15 = a2;
  int v5 = 0;
  int v6 = 0;
  unint64_t v7 = 0;
  uint64_t v8 = 0;
  unint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v16 = v3 - 1;
  do
  {
    char v18 = 0;
    if (!CBS_get_u8(v19, &v18) || v18 < 0) {
      goto LABEL_55;
    }
    unsigned __int8 v11 = v18;
    if (v18 <= 0xD && ((1 << v18) & 0x2401) != 0) {
      goto LABEL_55;
    }
    if (!v8)
    {
      if (v18 == 34) {
        int v5 = 1;
      }
      if (v18 == 46) {
        goto LABEL_55;
      }
    }
    if (v6)
    {
      if (v7 > 0xFE) {
        goto LABEL_55;
      }
LABEL_17:
      int v6 = 0;
      goto LABEL_18;
    }
    if (v10)
    {
      if (v7 > 0xFE) {
        goto LABEL_55;
      }
      unint64_t v13 = v7 + 1;
      __s1[v7] = v18;
      if (v16 == v8)
      {
        if (v9) {
          goto LABEL_55;
        }
        unint64_t v9 = strdup(__s1);
        if (!v9) {
          goto LABEL_55;
        }
      }
      int v6 = 0;
    }
    else
    {
      if (v7 >= 0x40) {
        goto LABEL_54;
      }
      if (v5)
      {
        if (v18 != 92)
        {
          int v5 = 1;
          if (v8 && v18 == 34)
          {
            unsigned __int8 v17 = 0;
            if (!CBS_peek_u8((uint64_t)v19, &v17) || v17 != 64) {
              goto LABEL_54;
            }
            int v5 = 0;
            unsigned __int8 v11 = v18;
          }
          if (v11 == 9) {
            goto LABEL_54;
          }
          uint64_t v10 = 0;
          goto LABEL_17;
        }
        uint64_t v10 = 0;
        int v6 = 1;
        unint64_t v13 = v7;
        int v5 = 1;
      }
      else
      {
        if (v18 == 92)
        {
          unsigned __int8 v17 = 0;
          if (!CBS_peek_u8((uint64_t)v19, &v17) || !local_part_ok(v17))
          {
LABEL_54:
            uint64_t v10 = 0;
LABEL_55:
            free(v10);
            free(v9);
            return 0;
          }
          int v6 = 1;
          unsigned __int8 v11 = v18;
LABEL_47:
          if (!local_part_ok(v11)) {
            goto LABEL_54;
          }
          uint64_t v10 = 0;
          int v5 = 0;
LABEL_18:
          unint64_t v13 = v7 + 1;
          __s1[v7] = v11;
          goto LABEL_25;
        }
        if (v18 != 64)
        {
          int v6 = 0;
          goto LABEL_47;
        }
        if (!v7) {
          goto LABEL_54;
        }
        uint64_t v10 = strdup(__s1);
        if (!v10) {
          goto LABEL_55;
        }
        unint64_t v13 = 0;
        int v6 = 0;
        int v5 = 0;
        long long v35 = 0u;
        long long v36 = 0u;
        long long v33 = 0u;
        long long v34 = 0u;
        long long v31 = 0u;
        long long v32 = 0u;
        long long v29 = 0u;
        long long v30 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        long long v26 = 0u;
        long long v24 = 0u;
        long long v25 = 0u;
        long long v22 = 0u;
        long long v23 = 0u;
        *(_OWORD *)__s1 = 0u;
      }
    }
LABEL_25:
    ++v8;
    unint64_t v7 = v13;
  }
  while (v4 != v8);
  if (!v10) {
    goto LABEL_55;
  }
  if (!v9) {
    goto LABEL_55;
  }
  size_t v14 = strlen(v9);
  CBS_init(v20, (uint64_t)v9, v14);
  if (!x509_constraints_valid_host(v20)) {
    goto LABEL_55;
  }
  if (v15)
  {
    *(void *)(v15 + 8) = v9;
    *(void *)(v15 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = v10;
    uint64_t result = 1;
    *(_DWORD *)uint64_t v15 = 1;
  }
  else
  {
    free(v10);
    free(v9);
    return 1;
  }
  return result;
}

uint64_t local_part_ok(unsigned __int8 a1)
{
  int v1 = a1;
  unsigned int v2 = a1 - 48;
  unsigned int v3 = (a1 & 0xDF) - 65;
  uint64_t result = 1;
  BOOL v5 = v2 >= 0xA && v3 >= 0x1A;
  if (v5 && ((v1 - 33) > 0x3F || ((1 << (v1 - 33)) & 0xE00000005000567DLL) == 0))
  {
    unsigned int v6 = v1 - 123;
    BOOL v7 = v1 == 46;
    return v6 < 4 || v7;
  }
  return result;
}

uint64_t x509_constraints_valid_domain_constraint(void *a1)
{
  if (!CBS_len((uint64_t)a1)) {
    return 1;
  }
  char v4 = 0;
  if ((unint64_t)CBS_len((uint64_t)a1) > 2) {
    return x509_constraints_valid_domain_internal(a1, 0);
  }
  int v2 = CBS_peek_u8((uint64_t)a1, &v4);
  uint64_t result = 0;
  if (v2)
  {
    if (v4 != 46) {
      return x509_constraints_valid_domain_internal(a1, 0);
    }
  }
  return result;
}

uint64_t x509_constraints_uri_host(uint64_t a1, unint64_t a2, void **a3)
{
  if (a2 < 3) {
    return 0;
  }
  v17[5] = v3;
  v17[6] = v4;
  uint64_t v7 = 0;
  do
  {
    int v8 = *(char *)(a1 + v7);
    if (v8 < 0) {
      return 0;
    }
    if (v8 == 47)
    {
      uint64_t v9 = a1 + v7;
      if (*(unsigned char *)(a1 + v7 + 1) == 47)
      {
        if (v7 + 2 >= a2) {
          return 0;
        }
        uint64_t v10 = 0;
        uint64_t v11 = 0;
        uint64_t v12 = v9 + 2;
        uint64_t v13 = v9 + 3;
        uint64_t v14 = a2 - v7 - 2;
        while (1)
        {
          if (*(char *)(v13 - 1) < 0) {
            return 0;
          }
          unsigned int v15 = *(unsigned __int8 *)(v13 - 1) - 35;
          if (v15 <= 0x1D)
          {
            if (*(unsigned char *)(v13 - 1) == 64)
            {
              if (v10) {
                return 0;
              }
              uint64_t v11 = 0;
              uint64_t v10 = v13;
              goto LABEL_20;
            }
            if (((1 << v15) & 0x10801001) != 0) {
              goto LABEL_21;
            }
          }
          ++v11;
LABEL_20:
          ++v13;
          if (!--v14)
          {
LABEL_21:
            if (!v11) {
              return 0;
            }
            memset(v17, 0, 24);
            if (v10) {
              uint64_t v16 = v10;
            }
            else {
              uint64_t v16 = v12;
            }
            CBS_init(v17, v16, v11);
            uint64_t result = x509_constraints_valid_host(v17);
            if (result)
            {
              if (!a3) {
                return 1;
              }
              uint64_t result = CBS_strdup((uint64_t)v17, a3);
              if (result) {
                return 1;
              }
            }
            return result;
          }
        }
      }
    }
    ++v7;
  }
  while (a2 - 1 != v7);
  if (a3) {
    *a3 = strdup("");
  }
  return 1;
}

BOOL x509_constraints_sandns(uint64_t a1, unint64_t a2, char *a3, size_t a4)
{
  if (!a4) {
    return 1;
  }
  if (a2 >= a4) {
    return strncasecmp((const char *)(a1 + a2 - a4), a3, a4) == 0;
  }
  return 0;
}

BOOL x509_constraints_domain(char *a1, size_t a2, char *a3, size_t a4)
{
  if (!a4) {
    return 1;
  }
  BOOL v5 = a1;
  if (*a3 == 46)
  {
    BOOL v6 = a2 >= a4;
    size_t v7 = a2 - a4;
    if (!v6) {
      return 0;
    }
    a1 += v7;
    goto LABEL_11;
  }
  if (*a1 == 46)
  {
    if (a4 >= a2)
    {
      a1 = &a3[a4 - a2];
      size_t v9 = a2;
      return strncasecmp(a1, v5, v9) == 0;
    }
  }
  else if (a2 == a4)
  {
LABEL_11:
    BOOL v5 = a3;
    size_t v9 = a4;
    return strncasecmp(a1, v5, v9) == 0;
  }
  return 0;
}

BOOL x509_constraints_uri(uint64_t a1, unint64_t a2, char *a3, size_t a4, int *a5)
{
  __unsigned int s = 0;
  memset(v14, 0, sizeof(v14));
  CBS_init(v14, (uint64_t)a3, a4);
  if (!x509_constraints_uri_host(a1, a2, (void **)&__s))
  {
    BOOL v11 = 0;
    int v12 = 53;
LABEL_8:
    *a5 = v12;
    goto LABEL_9;
  }
  if (!__s)
  {
    BOOL v11 = 0;
    int v12 = 17;
    goto LABEL_8;
  }
  if (!x509_constraints_valid_domain_constraint(v14))
  {
    BOOL v11 = 0;
    int v12 = 52;
    goto LABEL_8;
  }
  size_t v10 = strlen(__s);
  BOOL v11 = x509_constraints_domain(__s, v10, a3, a4);
LABEL_9:
  free(__s);
  return v11;
}

uint64_t x509_constraints_ipaddr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 == 2 * a2)
  {
    if (!a2) {
      return 1;
    }
    uint64_t v4 = 0;
    while (((*(unsigned __int8 *)(a3 + v4) ^ *(unsigned __int8 *)(a1 + v4)) & *(unsigned __int8 *)(a3 + a2 + v4)) == 0)
    {
      if (a2 == ++v4) {
        return 1;
      }
    }
  }
  return 0;
}

BOOL x509_constraints_dirname(void *__s2, size_t a2, void *__s1, size_t __n)
{
  return __n <= a2 && memcmp(__s1, __s2, __n) == 0;
}

uint64_t x509_constraints_general_to_bytes(unsigned int *a1, void *a2, void *a3)
{
  *a2 = 0;
  *a3 = 0;
  uint64_t result = *a1;
  switch((int)result)
  {
    case 1:
      size_t v7 = (int *)*((void *)a1 + 1);
      *a2 = *((void *)v7 + 1);
      uint64_t result = 1;
      goto LABEL_12;
    case 2:
      size_t v7 = (int *)*((void *)a1 + 1);
      *a2 = *((void *)v7 + 1);
      uint64_t result = 2;
      goto LABEL_12;
    case 4:
      uint64_t v8 = *((void *)a1 + 1);
      if (!*(_DWORD *)(v8 + 8))
      {
        uint64_t result = 4;
        goto LABEL_11;
      }
      int v9 = i2d_X509_NAME(*((X509_NAME **)a1 + 1), 0);
      uint64_t result = *a1;
      if ((v9 & 0x80000000) == 0)
      {
LABEL_11:
        *a2 = *(void *)(v8 + 24);
        size_t v7 = (int *)(v8 + 32);
        goto LABEL_12;
      }
LABEL_6:
      if (result != 7) {
        return 0;
      }
      *a2 = *(void *)(*((void *)a1 + 1) + 8);
      size_t v7 = (int *)*((void *)a1 + 1);
LABEL_12:
      *a3 = *v7;
      return result;
    case 6:
      size_t v7 = (int *)*((void *)a1 + 1);
      *a2 = *((void *)v7 + 1);
      uint64_t result = 6;
      goto LABEL_12;
    default:
      goto LABEL_6;
  }
}

uint64_t x509_constraints_extract_names(uint64_t a1, uint64_t a2, int a3, int *a4)
{
  uint64_t v8 = sk_value(*(const STACK **)(a2 + 112), 0);
  if (!v8)
  {
    int v18 = 1;
    int v11 = a3;
LABEL_31:
    uint64_t subject_name = X509_get_subject_name((X509 *)a2);
    if (X509_NAME_entry_count(subject_name) >= 1)
    {
      if (subject_name->modified && i2d_X509_NAME(subject_name, 0) < 0)
      {
LABEL_58:
        int v12 = 0;
LABEL_59:
        int v20 = 17;
        goto LABEL_60;
      }
      int v12 = malloc_type_calloc(1uLL, 0x50uLL, 0x1010040B88FB30EuLL);
      if (!v12) {
        goto LABEL_59;
      }
      long long v22 = malloc_type_malloc(SLODWORD(subject_name[1].entries), 0x9E8C541uLL);
      *((void *)v12 + 3) = v22;
      if (!v22) {
        goto LABEL_59;
      }
      memcpy(v22, (const void *)subject_name->hash, SLODWORD(subject_name[1].entries));
      *((void *)v12 + 4) = SLODWORD(subject_name[1].entries);
      _DWORD *v12 = 4;
      if (!x509_constraints_names_add(a1, (uint64_t)v12))
      {
        *a4 = 17;
        goto LABEL_61;
      }
      if (v11)
      {
        for (int i = X509_NAME_get_index_by_NID(subject_name, 48, v18);
              (i & 0x80000000) == 0;
              int i = X509_NAME_get_index_by_NID(subject_name, 48, i))
        {
          uint64_t v33 = 0;
          uint64_t v34 = 0;
          uint64_t v35 = 0;
          entry = X509_NAME_get_entry(subject_name, i);
          if (!entry) {
            goto LABEL_58;
          }
          uint64_t data = X509_NAME_ENTRY_get_data(entry);
          if (!data) {
            goto LABEL_58;
          }
          CBS_init(&v33, (uint64_t)data->data, data->length);
          int v12 = malloc_type_calloc(1uLL, 0x50uLL, 0x1010040B88FB30EuLL);
          if (!v12) {
            goto LABEL_59;
          }
          if (!x509_constraints_parse_mailbox((uint64_t)&v33, (uint64_t)v12)) {
            goto LABEL_29;
          }
          _DWORD *v12 = 1;
          if (!x509_constraints_names_add(a1, (uint64_t)v12)) {
            goto LABEL_59;
          }
        }
        int v18 = i;
      }
      if (a3)
      {
        int index_by_NID = X509_NAME_get_index_by_NID(subject_name, 13, v18);
        if ((index_by_NID & 0x80000000) == 0)
        {
          int v27 = index_by_NID;
          while (1)
          {
            uint64_t v33 = 0;
            uint64_t v34 = 0;
            uint64_t v35 = 0;
            long long v28 = X509_NAME_get_entry(subject_name, v27);
            if (!v28) {
              goto LABEL_58;
            }
            long long v29 = X509_NAME_ENTRY_get_data(v28);
            if (!v29) {
              goto LABEL_58;
            }
            CBS_init(&v33, (uint64_t)v29->data, v29->length);
            if (x509_constraints_valid_host(&v33))
            {
              long long v30 = malloc_type_calloc(1uLL, 0x50uLL, 0x1010040B88FB30EuLL);
              int v12 = v30;
              if (!v30) {
                goto LABEL_59;
              }
              if (!CBS_strdup((uint64_t)&v33, (void **)v30 + 1)) {
                goto LABEL_59;
              }
              _DWORD *v12 = 2;
              if (!x509_constraints_names_add(a1, (uint64_t)v12)) {
                goto LABEL_59;
              }
            }
            int v27 = X509_NAME_get_index_by_NID(subject_name, 13, v27);
            uint64_t result = 1;
            if (v27 < 0) {
              return result;
            }
          }
        }
      }
    }
    return 1;
  }
  int v9 = (unsigned int *)v8;
  uint64_t v10 = 1;
  int v11 = a3;
  long long v32 = a4;
  while (2)
  {
    size_t v36 = 0;
    uint64_t v37 = 0;
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    int v12 = malloc_type_calloc(1uLL, 0x50uLL, 0x1010040B88FB30EuLL);
    if (!v12) {
      goto LABEL_59;
    }
    int v13 = x509_constraints_general_to_bytes(v9, &v37, &v36);
    size_t v14 = v36;
    unsigned int v15 = v37;
    CBS_init(&v33, (uint64_t)v37, v36);
    switch(v13)
    {
      case 1:
        if (!x509_constraints_parse_mailbox((uint64_t)&v33, (uint64_t)v12)) {
          goto LABEL_29;
        }
        int v11 = 0;
        goto LABEL_24;
      case 2:
        if (!x509_constraints_valid_sandns(&v33)) {
          goto LABEL_29;
        }
        if (!CBS_strdup((uint64_t)&v33, (void **)v12 + 1)) {
          goto LABEL_59;
        }
        a3 = 0;
        goto LABEL_24;
      case 4:
        if (!v14) {
          goto LABEL_29;
        }
        if (!v15) {
          goto LABEL_59;
        }
        uint64_t v16 = malloc_type_malloc(v14, 0x64E6E4BAuLL);
        *((void *)v12 + 3) = v16;
        if (!v16) {
          goto LABEL_59;
        }
        memcpy(v16, v15, v14);
        *((void *)v12 + 4) = v14;
        goto LABEL_24;
      case 6:
        if (x509_constraints_uri_host((uint64_t)v15, v14, (void **)v12 + 1))
        {
          a4 = v32;
          if (!*((void *)v12 + 1)) {
            goto LABEL_59;
          }
LABEL_24:
          _DWORD *v12 = v13;
          if (!x509_constraints_names_add(a1, (uint64_t)v12)) {
            goto LABEL_59;
          }
LABEL_25:
          int v18 = v10 + 1;
          int v9 = (unsigned int *)sk_value(*(const STACK **)(a2 + 112), v10++);
          if (!v9) {
            goto LABEL_31;
          }
          continue;
        }
        int v20 = 53;
        a4 = v32;
LABEL_60:
        *a4 = v20;
        if (v12)
        {
LABEL_61:
          x509_constraints_name_clear((uint64_t)v12);
          free(v12);
        }
        return 0;
      case 7:
        if (v14 == 4)
        {
          int v17 = 2;
          goto LABEL_22;
        }
        if (v14 == 16)
        {
          int v17 = 30;
LABEL_22:
          v12[10] = v17;
          goto LABEL_23;
        }
        int v19 = v12[10];
        if (v19 != 2 && v19 != 30)
        {
LABEL_29:
          int v20 = 53;
          goto LABEL_60;
        }
LABEL_23:
        __memcpy_chk();
        goto LABEL_24;
      default:
        x509_constraints_name_clear((uint64_t)v12);
        free(v12);
        goto LABEL_25;
    }
  }
}

uint64_t x509_constraints_validate(unsigned int *a1, void ***a2, int *a3)
{
  size_t v17 = 0;
  int v18 = 0;
  if (!a2 || *a2) {
    return 0;
  }
  if (a3) {
    *a3 = 0;
  }
  size_t v7 = (void **)malloc_type_calloc(1uLL, 0x50uLL, 0x1010040B88FB30EuLL);
  if (v7)
  {
    uint64_t v8 = v7;
    char v19 = 0;
    memset(v16, 0, sizeof(v16));
    int v9 = x509_constraints_general_to_bytes(a1, &v18, &v17);
    size_t v10 = v17;
    int v11 = v18;
    CBS_init(v16, (uint64_t)v18, v17);
    switch(v9)
    {
      case 1:
        if (v10 && memchr((void *)(v11 + 1), 64, v10 - 1))
        {
          if (x509_constraints_parse_mailbox((uint64_t)v16, (uint64_t)v8)) {
            goto LABEL_37;
          }
          goto LABEL_31;
        }
        if (CBS_len((uint64_t)v16)
          && (!CBS_peek_u8((uint64_t)v16, &v19) || v19 == 64 && !CBS_skip(v16, 1uLL))
          || !x509_constraints_valid_domain_constraint(v16))
        {
          goto LABEL_31;
        }
        if (CBS_strdup((uint64_t)v16, v8 + 1)) {
          goto LABEL_36;
        }
        goto LABEL_30;
      case 2:
      case 6:
        if (!x509_constraints_valid_domain_constraint(v16)) {
          goto LABEL_31;
        }
        int v12 = strndup(v11, v10);
        v8[1] = v12;
        if (!v12) {
          goto LABEL_30;
        }
        goto LABEL_36;
      case 4:
        if (!v10) {
          goto LABEL_31;
        }
        if (v11)
        {
          size_t v14 = malloc_type_malloc(v10, 0xDCEF90EAuLL);
          void v8[3] = v14;
          if (v14)
          {
            memcpy(v14, v11, v10);
            v8[4] = (void *)v10;
            goto LABEL_36;
          }
        }
LABEL_30:
        int v13 = 17;
        goto LABEL_32;
      case 7:
        if (v10 == 8)
        {
          int v15 = 2;
LABEL_35:
          *((_DWORD *)v8 + 1RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = v15;
          __memcpy_chk();
LABEL_36:
          *(_DWORD *)uint64_t v8 = v9;
LABEL_37:
          *a2 = v8;
          return 1;
        }
        if (v10 == 32)
        {
          int v15 = 30;
          goto LABEL_35;
        }
LABEL_31:
        int v13 = 52;
LABEL_32:
        x509_constraints_name_clear((uint64_t)v8);
        free(v8);
        if (!a3) {
          return 0;
        }
        break;
      default:
        goto LABEL_37;
    }
  }
  else
  {
    int v13 = 17;
    if (!a3) {
      return 0;
    }
  }
  uint64_t result = 0;
  *a3 = v13;
  return result;
}

uint64_t x509_constraints_extract_constraints(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  size_t v17 = 0;
  uint64_t v4 = *(const STACK ***)(a1 + 120);
  if (!v4) {
    return 1;
  }
  if (sk_num(*v4) >= 1)
  {
    int v8 = 0;
    do
    {
      int v9 = sk_value(*v4, v8);
      if (*((void *)v9 + 1) || *((void *)v9 + 2)) {
        goto LABEL_23;
      }
      uint64_t result = x509_constraints_validate(*(unsigned int **)v9, &v17, a4);
      if (!result) {
        return result;
      }
      int v11 = v17;
      if (*(_DWORD *)v17)
      {
        if (!x509_constraints_names_add(a2, (uint64_t)v17))
        {
LABEL_24:
          uint64_t v16 = v17;
          if (v17)
          {
            x509_constraints_name_clear((uint64_t)v17);
            free(v16);
          }
          int v15 = 17;
          goto LABEL_27;
        }
      }
      else
      {
        x509_constraints_name_clear((uint64_t)v17);
        free(v11);
      }
      size_t v17 = 0;
    }
    while (++v8 < sk_num(*v4));
  }
  if (sk_num(v4[1]) < 1) {
    return 1;
  }
  int v12 = 0;
  while (1)
  {
    int v13 = sk_value(v4[1], v12);
    if (*((void *)v13 + 1) || *((void *)v13 + 2)) {
      break;
    }
    uint64_t result = x509_constraints_validate(*(unsigned int **)v13, &v17, a4);
    if (!result) {
      return result;
    }
    size_t v14 = v17;
    if (*(_DWORD *)v17)
    {
      if (!x509_constraints_names_add(a3, (uint64_t)v17)) {
        goto LABEL_24;
      }
    }
    else
    {
      x509_constraints_name_clear((uint64_t)v17);
      free(v14);
    }
    size_t v17 = 0;
    if (++v12 >= sk_num(v4[1])) {
      return 1;
    }
  }
LABEL_23:
  int v15 = 49;
LABEL_27:
  uint64_t result = 0;
  *a4 = v15;
  return result;
}

uint64_t x509_constraints_match(int *a1, uint64_t a2)
{
  int v2 = *a1;
  if (*a1 == *(_DWORD *)a2)
  {
    uint64_t result = 0;
    switch(v2)
    {
      case 1:
        BOOL v6 = *(const char **)(a2 + 16);
        if (!v6) {
          goto LABEL_6;
        }
        if (strcmp(*((const char **)a1 + 2), v6)) {
          return 0;
        }
        int v7 = strcmp(*((const char **)a1 + 1), *(const char **)(a2 + 8));
        return v7 == 0;
      case 2:
        int v12 = (const char *)*((void *)a1 + 1);
        size_t v13 = strlen(v12);
        size_t v14 = *(const char **)(a2 + 8);
        size_t v15 = strlen(v14);
        if (!v15) {
          return 1;
        }
        if (v13 < v15) {
          return 0;
        }
        int v7 = strncasecmp(&v12[v13 - v15], v14, v15);
        return v7 == 0;
      case 4:
        size_t v16 = *(void *)(a2 + 32);
        if (v16 > *((void *)a1 + 4)) {
          return 0;
        }
        int v7 = memcmp(*(const void **)(a2 + 24), *((const void **)a1 + 3), v16);
        return v7 == 0;
      case 6:
LABEL_6:
        int v8 = (char *)*((void *)a1 + 1);
        size_t v9 = strlen(v8);
        size_t v10 = *(char **)(a2 + 8);
        size_t v11 = strlen(v10);
        return x509_constraints_domain(v8, v9, v10, v11);
      case 7:
        int v17 = a1[10];
        uint64_t v18 = 16;
        if (v17 == 2) {
          uint64_t v18 = 4;
        }
        uint64_t v19 = 32;
        if (v17 == 2) {
          uint64_t v19 = 8;
        }
        if (v17 != 30 && v17 != 2) {
          return 0;
        }
        int v20 = *(_DWORD *)(a2 + 40);
        if (v20 != 30 && v20 != 2) {
          return 0;
        }
        if (v17 != v20 || v19 != 2 * v18) {
          return 0;
        }
        uint64_t v21 = 0;
        uint64_t result = 1;
        break;
      default:
        return result;
    }
    while (((*(unsigned __int8 *)(a2 + 44 + v21) ^ *((unsigned __int8 *)a1 + v21 + 44)) & *(unsigned __int8 *)(a2 + 44 + v18 + v21)) == 0)
    {
      if (v18 == ++v21) {
        return result;
      }
    }
  }
  return 0;
}

uint64_t x509_constraints_check(void *a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v4 = a1[1];
  if (!v4) {
    return 1;
  }
  uint64_t v7 = 0;
  uint64_t v8 = *(void *)(a3 + 8);
  while (!v8)
  {
LABEL_7:
    uint64_t v12 = *(void *)(a2 + 8);
    if (v12)
    {
      int v13 = 0;
      size_t v14 = *(uint64_t **)a2;
      size_t v15 = *(int **)(*a1 + 8 * v7);
      while (1)
      {
        size_t v16 = (_DWORD *)*v14;
        if (x509_constraints_match(v15, *v14)) {
          break;
        }
        if (*v16 == *v15) {
          ++v13;
        }
        ++v14;
        if (!--v12)
        {
          if (!v13) {
            break;
          }
          int v18 = 47;
          goto LABEL_17;
        }
      }
    }
    if (++v7 == v4) {
      return 1;
    }
  }
  size_t v9 = *(int **)(*a1 + 8 * v7);
  size_t v10 = *(uint64_t **)a3;
  uint64_t v11 = v8;
  while (!x509_constraints_match(v9, *v10))
  {
    ++v10;
    if (!--v11) {
      goto LABEL_7;
    }
  }
  int v18 = 48;
LABEL_17:
  uint64_t result = 0;
  *a4 = v18;
  return result;
}

uint64_t x509_constraints_chain(const STACK *a1, int *a2, int *a3)
{
  int v22 = 1;
  if (!a1)
  {
    LODWORD(v7) = 0;
    goto LABEL_21;
  }
  uint64_t v6 = sk_num(a1);
  uint64_t v7 = v6;
  if (!v6)
  {
LABEL_21:
    size_t v9 = 0;
LABEL_22:
    *a2 = v22;
    *a3 = v7;
    goto LABEL_23;
  }
  if (v6 == 1) {
    return v7;
  }
  uint64_t v8 = malloc_type_calloc(1uLL, 0x20uLL, 0x1080040ABB4582EuLL);
  size_t v9 = v8;
  if (!v8)
  {
    LODWORD(v7) = 0;
    int v22 = 17;
    goto LABEL_22;
  }
  void v8[3] = 512;
  size_t v10 = sk_value(a1, 0);
  if (!v10 || !x509_constraints_extract_names((uint64_t)v9, (uint64_t)v10, 1, &v22))
  {
    LODWORD(v7) = 0;
    goto LABEL_22;
  }
  if ((int)v7 < 2)
  {
    uint64_t v19 = 1;
    goto LABEL_24;
  }
  unint64_t v11 = 0;
  int v12 = 1;
  while (1)
  {
    int v13 = sk_value(a1, v12);
    if (!v13) {
      goto LABEL_31;
    }
    uint64_t v14 = (uint64_t)v13;
    if (!*((void *)v13 + 15)) {
      goto LABEL_17;
    }
    size_t v15 = malloc_type_calloc(1uLL, 0x20uLL, 0x1080040ABB4582EuLL);
    if (!v15)
    {
      int v22 = 17;
LABEL_31:
      LODWORD(v7) = v12;
      goto LABEL_22;
    }
    size_t v16 = v15;
    uint64_t v15[3] = 512;
    int v17 = malloc_type_calloc(1uLL, 0x20uLL, 0x1080040ABB4582EuLL);
    if (!v17)
    {
      int v22 = 17;
      *a2 = 17;
      *a3 = v12;
      goto LABEL_35;
    }
    int v18 = v17;
    v17[3] = 512;
    if (!x509_constraints_extract_constraints(v14, (uint64_t)v16, (uint64_t)v17, &v22)) {
      goto LABEL_29;
    }
    v11 += v16[1] + v18[1];
    if (v11 >= 0x201) {
      break;
    }
    if (!x509_constraints_check(v9, (uint64_t)v16, (uint64_t)v18, &v22))
    {
LABEL_29:
      int v21 = v22;
      goto LABEL_34;
    }
    x509_constraints_names_clear((uint64_t)v18);
    free(v18);
    x509_constraints_names_clear((uint64_t)v16);
    free(v16);
LABEL_17:
    if (!x509_constraints_extract_names((uint64_t)v9, v14, 0, &v22)) {
      goto LABEL_31;
    }
    ++v12;
    uint64_t v19 = 1;
    if (v7 == v12) {
      goto LABEL_24;
    }
  }
  int v21 = 17;
  int v22 = 17;
LABEL_34:
  *a2 = v21;
  *a3 = v12;
  x509_constraints_names_clear((uint64_t)v18);
  free(v18);
LABEL_35:
  x509_constraints_names_clear((uint64_t)v16);
  free(v16);
LABEL_23:
  uint64_t v19 = 0;
  uint64_t v7 = 0;
  if (v9)
  {
LABEL_24:
    x509_constraints_names_clear((uint64_t)v9);
    free(v9);
    return v19;
  }
  return v7;
}

uint64_t sk_X509_POLICY_NODE_delete_if (STACK *a1, unsigned int (*a2)(char *, uint64_t), uint64_t a3)
{
  uint64_t result = sk_num(a1);
  if ((int)result < 1)
  {
    int v8 = 0;
  }
  else
  {
    int v7 = 0;
    int v8 = 0;
    do
    {
      size_t v9 = sk_value(a1, v7);
      if (!a2(v9, a3)) {
        a1->data[v8++] = v9;
      }
      ++v7;
      uint64_t result = sk_num(a1);
    }
    while (v7 < (int)result);
  }
  a1->uint64_t num = v8;
  return result;
}

int X509_policy_check(X509_POLICY_TREE **ptree, int *pexplicit_policy, STACK *certs, STACK *policy_oids, unsigned int flags)
{
  BOOL v5 = policy_oids;
  __int16 v6 = (__int16)certs;
  int v8 = ptree;
  *(void *)&policy_oids->uint64_t num = 0;
  int v9 = sk_num((const STACK *)ptree);
  int v10 = v9 - 2;
  if (v9 < 2) {
    return 0;
  }
  unint64_t v12 = (v9 + 1);
  if ((v6 & 0x100) != 0) {
    unint64_t v13 = 0;
  }
  else {
    unint64_t v13 = (v9 + 1);
  }
  if ((v6 & 0x200) != 0) {
    unint64_t v14 = 0;
  }
  else {
    unint64_t v14 = (v9 + 1);
  }
  unint64_t v82 = v14;
  unint64_t v83 = v13;
  if ((v6 & 0x400) != 0) {
    unint64_t v12 = 0;
  }
  unint64_t v81 = v12;
  size_t v15 = sk_new_null();
  if (!v15)
  {
LABEL_144:
    size_t v16 = 0;
LABEL_145:
    int v71 = 0;
    goto LABEL_146;
  }
  int v74 = (STACK *)pexplicit_policy;
  size_t v16 = 0;
  int v17 = v10;
  int v78 = v10;
  while (2)
  {
    int v18 = (X509 *)sk_value((const STACK *)v8, v17);
    if (!x509v3_cache_extensions((uint64_t)v18)) {
      goto LABEL_145;
    }
    ex_pathint len = v18->ex_pathlen;
    if (!v16)
    {
      if (v17 != v10) {
        goto LABEL_144;
      }
      int v20 = x509_policy_level_new();
      size_t v16 = v20;
      if (!v20) {
        goto LABEL_145;
      }
      *((_DWORD *)v20 + 2) = 1;
    }
    int v80 = v17;
    if (v82)
    {
      BOOL v21 = 1;
    }
    else if (v17)
    {
      BOOL v21 = (ex_pathlen & 0x20) != 0;
    }
    else
    {
      BOOL v21 = 0;
    }
    int crit = 0;
    ext_d2int i = (const STACK *)X509_get_ext_d2i(v18, 89, &crit, 0);
    if (!ext_d2i)
    {
      if (crit == -1)
      {
        *((_DWORD *)v16 + 2) = 0;
        if (sk_num(*v16) >= 1)
        {
          int v38 = 0;
          do
          {
            unsigned int v39 = sk_value(*v16, v38);
            x509_policy_node_free((uint64_t)v39);
            ++v38;
          }
          while (v38 < sk_num(*v16));
        }
        sk_zero(*v16);
        goto LABEL_58;
      }
      goto LABEL_149;
    }
    long long v23 = (CERTIFICATEPOLICIES *)ext_d2i;
    if (!sk_num(ext_d2i))
    {
      ERR_put_error(11, 4095, 201, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_policy.c", 377);
LABEL_154:
      uint64_t v33 = 0;
      goto LABEL_148;
    }
    sk_set_cmp_func(v23, (int (__cdecl *)(const char *const *, const char *const *))policyinfo_cmp);
    sk_sort(v23);
    if (sk_num(v23) < 1)
    {
      int v31 = *((_DWORD *)v16 + 2);
LABEL_54:
      if (sk_is_sorted(v23))
      {
        sk_X509_POLICY_NODE_delete_if (*v16, (unsigned int (*)(char *, uint64_t))delete_if_not_in_policies, (uint64_t)v23);
        *((_DWORD *)v16 + 2) = 0;
        if (!v31) {
          goto LABEL_56;
        }
LABEL_37:
        uint64_t v33 = sk_new_null();
        if (v33)
        {
          char v34 = ex_pathlen;
          if (sk_num(v23) < 1)
          {
LABEL_46:
            LOBYTE(ex_pathSHA512_Update(c, data, len) = v34;
            int v10 = v78;
            if (x509_policy_level_add_nodes(v16, v33)) {
              goto LABEL_57;
            }
          }
          else
          {
            int v35 = 0;
            while (1)
            {
              size_t v36 = sk_value(v23, v35);
              if (OBJ_obj2nid(*(const ASN1_OBJECT **)v36) != 746)
              {
                if (!sk_is_sorted(*v16)) {
                  goto LABEL_148;
                }
                if (!x509_policy_level_find(v16, *(void *)v36))
                {
                  uint64_t v37 = (char *)x509_policy_node_new(*(const ASN1_OBJECT **)v36);
                  if (!v37 || !sk_push(v33, v37)) {
                    break;
                  }
                }
              }
              if (++v35 >= sk_num(v23)) {
                goto LABEL_46;
              }
            }
            x509_policy_node_free((uint64_t)v37);
          }
        }
        goto LABEL_148;
      }
      goto LABEL_154;
    }
    char v76 = ex_pathlen;
    long long v24 = v8;
    long long v25 = v5;
    long long v26 = v15;
    int v27 = 0;
    int v28 = 0;
    do
    {
      long long v29 = sk_value(v23, v27);
      if (OBJ_obj2nid(*(const ASN1_OBJECT **)v29) == 746) {
        int v28 = 1;
      }
      if (v27)
      {
        long long v30 = sk_value(v23, v27 - 1);
        if (!OBJ_cmp(*(const ASN1_OBJECT **)v30, *(const ASN1_OBJECT **)v29))
        {
          ERR_put_error(11, 4095, 201, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_policy.c", 395);
          uint64_t v33 = 0;
          size_t v15 = v26;
          BOOL v5 = v25;
LABEL_148:
          sk_pop_free(v33, (void (__cdecl *)(void *))x509_policy_node_free);
          CERTIFICATEPOLICIES_free(v23);
LABEL_149:
          int v71 = 0;
          *(void *)&v5->uint64_t num = v18;
          int v11 = 42;
          goto LABEL_150;
        }
      }
      ++v27;
    }
    while (v27 < sk_num(v23));
    int v31 = *((_DWORD *)v16 + 2);
    if (v28) {
      BOOL v32 = v21;
    }
    else {
      BOOL v32 = 0;
    }
    size_t v15 = v26;
    BOOL v5 = v25;
    int v8 = v24;
    int v10 = v78;
    LOBYTE(ex_pathSHA512_Update(c, data, len) = v76;
    if (!v32) {
      goto LABEL_54;
    }
    if (v31) {
      goto LABEL_37;
    }
LABEL_56:
    uint64_t v33 = 0;
LABEL_57:
    sk_pop_free(v33, (void (__cdecl *)(void *))x509_policy_node_free);
    CERTIFICATEPOLICIES_free(v23);
LABEL_58:
    int v40 = v80;
    if (!v83 && !*((_DWORD *)v16 + 2) && !sk_num(*v16))
    {
      int v71 = 0;
LABEL_167:
      int v11 = 43;
      goto LABEL_150;
    }
    if (!sk_push(v15, (char *)v16)) {
      goto LABEL_145;
    }
    if (!v80)
    {
      int v45 = 0;
      goto LABEL_122;
    }
    int v75 = v15;
    unint64_t v41 = v81;
    int crit = 0;
    int v42 = (const STACK *)X509_get_ext_d2i(v18, 747, &crit, 0);
    unsigned int v43 = (STACK *)v42;
    if (!v42)
    {
      st = 0;
      unsigned int v44 = 0;
      int v45 = 0;
      if (crit != -1) {
        goto LABEL_119;
      }
    }
    if (!v42)
    {
LABEL_93:
      unsigned int v43 = sk_new_null();
      st = 0;
      unsigned int v44 = 0;
      int v45 = 0;
      if (!v43) {
        goto LABEL_119;
      }
      goto LABEL_94;
    }
    if (!sk_num(v42))
    {
      ERR_put_error(11, 4095, 201, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_policy.c", 532);
LABEL_89:
      st = 0;
      int v45 = 0;
      unsigned int v44 = v43;
      goto LABEL_119;
    }
    char v77 = ex_pathlen;
    if (sk_num(v43) >= 1)
    {
      int v46 = 0;
      while (1)
      {
        int v47 = (const ASN1_OBJECT **)sk_value(v43, v46);
        if (OBJ_obj2nid(*v47) == 746 || OBJ_obj2nid(v47[1]) == 746) {
          break;
        }
        if (++v46 >= sk_num(v43)) {
          goto LABEL_72;
        }
      }
LABEL_90:
      st = 0;
LABEL_117:
      int v45 = 0;
      goto LABEL_118;
    }
LABEL_72:
    sk_set_cmp_func(v43, (int (__cdecl *)(const char *const *, const char *const *))compare_issuer_policy);
    sk_sort(v43);
    if (!v41)
    {
      LOBYTE(ex_pathSHA512_Update(c, data, len) = v77;
      if (!sk_is_sorted(v43)) {
        goto LABEL_89;
      }
      sk_X509_POLICY_NODE_delete_if (*v16, (unsigned int (*)(char *, uint64_t))delete_if_mapped, (uint64_t)v43);
      sk_pop_free(v43, (void (__cdecl *)(void *))POLICY_MAPPING_free);
      goto LABEL_93;
    }
    st = sk_new_null();
    if (!st) {
      goto LABEL_90;
    }
    if (sk_num(v43) >= 1)
    {
      int v48 = 0;
      int v49 = 0;
      while (1)
      {
        uint64_t v50 = sk_value(v43, v48);
        int v51 = (uint64_t *)v50;
        if (v49 && !OBJ_cmp(*(const ASN1_OBJECT **)v50, v49)) {
          goto LABEL_84;
        }
        int v49 = (const ASN1_OBJECT *)*v51;
        if (!sk_is_sorted(*v16)) {
          goto LABEL_117;
        }
        int v52 = x509_policy_level_find(v16, *v51);
        if (v52) {
          goto LABEL_83;
        }
        if (*((_DWORD *)v16 + 2)) {
          break;
        }
LABEL_84:
        if (++v48 >= sk_num(v43)) {
          goto LABEL_85;
        }
      }
      int v52 = (char *)x509_policy_node_new((const ASN1_OBJECT *)*v51);
      if (!v52 || !sk_push(st, v52))
      {
        x509_policy_node_free((uint64_t)v52);
        goto LABEL_117;
      }
LABEL_83:
      *((_DWORD *)v52 + 4) = 1;
      goto LABEL_84;
    }
LABEL_85:
    if (!x509_policy_level_add_nodes(v16, st)) {
      goto LABEL_117;
    }
    LOBYTE(ex_pathSHA512_Update(c, data, len) = v77;
LABEL_94:
    char v77 = ex_pathlen;
    if (sk_num(*v16) >= 1)
    {
      int v53 = 0;
      while (1)
      {
        int v54 = sk_value(*v16, v53);
        if (!*((_DWORD *)v54 + 4))
        {
          int v55 = (const ASN1_OBJECT **)v54;
          int v56 = POLICY_MAPPING_new();
          if (!v56) {
            goto LABEL_117;
          }
          int v57 = v56;
          v56->issuerDomainPolicy = OBJ_dup(*v55);
          unsigned int v58 = OBJ_dup(*v55);
          v57->subjectDomainPolicy = v58;
          if (!v57->issuerDomainPolicy || !v58 || !sk_push(v43, (char *)v57)) {
            break;
          }
        }
        if (++v53 >= sk_num(*v16)) {
          goto LABEL_102;
        }
      }
      POLICY_MAPPING_free(v57);
      goto LABEL_117;
    }
LABEL_102:
    sk_set_cmp_func(v43, (int (__cdecl *)(const char *const *, const char *const *))compare_subject_policy);
    sk_sort(v43);
    int v59 = x509_policy_level_new();
    int v45 = v59;
    if (!v59) {
      goto LABEL_118;
    }
    *((_DWORD *)v59 + 2) = *((_DWORD *)v16 + 2);
    if (sk_num(v43) < 1)
    {
LABEL_115:
      sk_sort(*v45);
      LOBYTE(ex_pathSHA512_Update(c, data, len) = v77;
      goto LABEL_120;
    }
    int v60 = 0;
    int v61 = 0;
    while (2)
    {
      int v62 = sk_value(v43, v61);
      if (!*((_DWORD *)v16 + 2))
      {
        if (!sk_is_sorted(*v16)) {
          goto LABEL_118;
        }
        if (!x509_policy_level_find(v16, *(void *)v62))
        {
LABEL_114:
          if (++v61 >= sk_num(v43)) {
            goto LABEL_115;
          }
          continue;
        }
      }
      break;
    }
    if (v60 && !OBJ_cmp(*(const ASN1_OBJECT **)v60, *((const ASN1_OBJECT **)v62 + 1))
      || (int v60 = (char *)x509_policy_node_new(*((const ASN1_OBJECT **)v62 + 1))) != 0 && sk_push(*v45, v60))
    {
      if (!sk_push(*((STACK **)v60 + 1), *(char **)v62)) {
        goto LABEL_118;
      }
      *(void *)int v62 = 0;
      goto LABEL_114;
    }
    x509_policy_node_free((uint64_t)v60);
LABEL_118:
    unsigned int v44 = v43;
    LOBYTE(ex_pathSHA512_Update(c, data, len) = v77;
LABEL_119:
    x509_policy_level_free(v45);
    int v45 = 0;
    unsigned int v43 = v44;
LABEL_120:
    sk_pop_free(v43, (void (__cdecl *)(void *))POLICY_MAPPING_free);
    sk_pop_free(st, (void (__cdecl *)(void *))x509_policy_node_free);
    size_t v15 = v75;
    if (!v45)
    {
      size_t v16 = 0;
      goto LABEL_149;
    }
    size_t v16 = v45;
    int v40 = v80;
    if ((ex_pathlen & 0x20) == 0)
    {
LABEL_122:
      if (v83) {
        --v83;
      }
      if (v81) {
        --v81;
      }
      if (v82) {
        --v82;
      }
      size_t v16 = v45;
    }
    int crit = 0;
    unsigned int v63 = (uint64_t *)X509_get_ext_d2i(v18, 401, &crit, 0);
    unsigned int v64 = v63;
    if (!v63 && crit != -1) {
      goto LABEL_149;
    }
    if (!v63) {
      goto LABEL_136;
    }
    uint64_t v65 = *v63;
    if (!*v64 && !v64[1])
    {
      ERR_put_error(11, 4095, 201, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_policy.c", 741);
LABEL_162:
      POLICY_CONSTRAINTS_free((POLICY_CONSTRAINTS *)v64);
      goto LABEL_149;
    }
    if (!apply_skip_certs(v65, &v83)) {
      goto LABEL_162;
    }
    int v66 = apply_skip_certs(v64[1], &v81);
    POLICY_CONSTRAINTS_free((POLICY_CONSTRAINTS *)v64);
    if (!v66) {
      goto LABEL_149;
    }
LABEL_136:
    int v67 = (ASN1_INTEGER *)X509_get_ext_d2i(v18, 748, &crit, 0);
    int v68 = v67;
    if (!v67 && crit != -1) {
      goto LABEL_149;
    }
    int v69 = apply_skip_certs((uint64_t)v67, &v82);
    ASN1_INTEGER_free(v68);
    if (!v69) {
      goto LABEL_149;
    }
    BOOL v70 = __OFSUB__(v40, 1);
    int v17 = v40 - 1;
    if (v17 < 0 == v70) {
      continue;
    }
    break;
  }
  if (v83)
  {
    int v71 = 0;
    goto LABEL_166;
  }
  if (!v74)
  {
    int v71 = 0;
LABEL_165:
    if (has_explicit_policy(v15, v71))
    {
LABEL_166:
      int v11 = 0;
      goto LABEL_150;
    }
    goto LABEL_167;
  }
  int v73 = sk_dup(v74);
  int v71 = v73;
  if (v73)
  {
    sk_set_cmp_func(v73, (int (__cdecl *)(const char *const *, const char *const *))asn1_object_cmp);
    sk_sort(v71);
    goto LABEL_165;
  }
LABEL_146:
  int v11 = 17;
LABEL_150:
  x509_policy_level_free(v16);
  sk_free(v71);
  sk_pop_free(v15, (void (__cdecl *)(void *))x509_policy_level_free);
  return v11;
}

STACK **x509_policy_level_new()
{
  uint64_t v0 = (STACK **)malloc_type_calloc(1uLL, 0x10uLL, 0x10200403A5D3213uLL);
  if (!v0
    || (int v1 = sk_new((int (__cdecl *)(const char *const *, const char *const *))x509_policy_node_cmp), (*v0 = v1) == 0))
  {
    x509_policy_level_free(v0);
    return 0;
  }
  return v0;
}

uint64_t asn1_object_cmp(const ASN1_OBJECT **a1, const ASN1_OBJECT **a2)
{
  return OBJ_cmp(*a1, *a2);
}

uint64_t has_explicit_policy(const STACK *a1, STACK *st)
{
  uint64_t result = sk_is_sorted(st);
  if (!result) {
    return result;
  }
  int v5 = sk_num(a1);
  int v6 = v5 - 1;
  int v7 = sk_value(a1, v5 - 1);
  int v8 = v7;
  if (!*((_DWORD *)v7 + 2))
  {
    uint64_t result = sk_num(*(const STACK **)v7);
    if (!result) {
      return result;
    }
  }
  int v9 = sk_num(st);
  if (sk_num(st) >= 1)
  {
    int v10 = 0;
    do
    {
      int v11 = sk_value(st, v10);
      if (OBJ_obj2nid((const ASN1_OBJECT *)v11) == 746) {
        return 1;
      }
    }
    while (++v10 < sk_num(st));
  }
  if (v9 < 1 || *((_DWORD *)v8 + 2)) {
    return 1;
  }
  if (sk_num(*(const STACK **)v8) >= 1)
  {
    int v12 = 0;
    do
      *((_DWORD *)sk_value(*(const STACK **)v8, v12++) + 5) = 1;
    while (v12 < sk_num(*(const STACK **)v8));
  }
  if (v5 < 1) {
    return 0;
  }
  do
  {
    unint64_t v13 = sk_value(a1, v6);
    if (sk_num(*(const STACK **)v13) > 0)
    {
      int v14 = 0;
      while (1)
      {
        size_t v15 = sk_value(*(const STACK **)v13, v14);
        if (*((_DWORD *)v15 + 5))
        {
          size_t v16 = v15;
          if (sk_num(*((const STACK **)v15 + 1)))
          {
            if (v6 >= 1)
            {
              int v17 = sk_num(*((const STACK **)v16 + 1));
              int v18 = sk_value(a1, v6 - 1);
              if (v17 >= 1)
              {
                uint64_t v19 = (const STACK **)v18;
                int v20 = 0;
                do
                {
                  uint64_t result = sk_is_sorted(*v19);
                  if (!result) {
                    return result;
                  }
                  BOOL v21 = sk_value(*((const STACK **)v16 + 1), v20);
                  int v22 = x509_policy_level_find((STACK **)v19, (uint64_t)v21);
                  if (v22) {
                    *((_DWORD *)v22 + 5) = 1;
                  }
                }
                while (v17 != ++v20);
              }
            }
          }
          else if ((sk_find(st, *(char **)v16) & 0x80000000) == 0)
          {
            return 1;
          }
        }
        if (++v14 >= sk_num(*(const STACK **)v13))
        {
          int v23 = v6 - 1;
          goto LABEL_32;
        }
      }
    }
    int v23 = v6 - 1;
LABEL_32:
    uint64_t result = 0;
    BOOL v24 = v6 <= 0;
    int v6 = v23;
  }
  while (!v24);
  return result;
}

void x509_policy_level_free(STACK **a1)
{
  if (a1)
  {
    sk_pop_free(*a1, (void (__cdecl *)(void *))x509_policy_node_free);
    free(a1);
  }
}

uint64_t x509_policy_node_cmp(const ASN1_OBJECT ***a1, const ASN1_OBJECT ***a2)
{
  return OBJ_cmp(**a1, **a2);
}

uint64_t policyinfo_cmp(const ASN1_OBJECT ***a1, const ASN1_OBJECT ***a2)
{
  return OBJ_cmp(**a1, **a2);
}

uint64_t delete_if_not_in_policies(void *a1, STACK *st)
{
  v4[0] = *a1;
  v4[1] = 0;
  if ((sk_find(st, (char *)v4) & 0x80000000) == 0) {
    return 0;
  }
  x509_policy_node_free((uint64_t)a1);
  return 1;
}

char *x509_policy_level_find(STACK **a1, uint64_t a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  *(void *)uint64_t data = a2;
  int v3 = sk_find(*a1, data);
  if (v3 < 0) {
    return 0;
  }
  else {
    return sk_value(*a1, v3);
  }
}

void *x509_policy_node_new(const ASN1_OBJECT *a1)
{
  if (OBJ_obj2nid(a1) == 746)
  {
    int v2 = 0;
LABEL_6:
    x509_policy_node_free((uint64_t)v2);
    return 0;
  }
  int v2 = malloc_type_calloc(1uLL, 0x18uLL, 0x102004062D53EE8uLL);
  if (!v2) {
    goto LABEL_6;
  }
  int v3 = OBJ_dup(a1);
  *int v2 = v3;
  if (!v3) {
    goto LABEL_6;
  }
  uint64_t v4 = sk_new_null();
  v2[1] = v4;
  if (!v4) {
    goto LABEL_6;
  }
  return v2;
}

void x509_policy_node_free(uint64_t a1)
{
  if (a1)
  {
    ASN1_OBJECT_free(*(ASN1_OBJECT **)a1);
    sk_pop_free(*(STACK **)(a1 + 8), (void (__cdecl *)(void *))ASN1_OBJECT_free);
    free((void *)a1);
  }
}

uint64_t x509_policy_level_add_nodes(STACK **a1, STACK *a2)
{
  if (sk_num(a2) < 1)
  {
LABEL_5:
    sk_sort(*a1);
    return 1;
  }
  else
  {
    int v4 = 0;
    while (1)
    {
      int v5 = sk_value(a2, v4);
      uint64_t result = sk_push(*a1, v5);
      if (!result) {
        break;
      }
      sk_set(a2, v4++, 0);
      if (v4 >= sk_num(a2)) {
        goto LABEL_5;
      }
    }
  }
  return result;
}

uint64_t compare_issuer_policy(const ASN1_OBJECT ***a1, const ASN1_OBJECT ***a2)
{
  return OBJ_cmp(**a1, **a2);
}

uint64_t delete_if_mapped(void *a1, STACK *st)
{
  v4[0] = *a1;
  v4[1] = 0;
  if (sk_find(st, (char *)v4) < 0) {
    return 0;
  }
  x509_policy_node_free((uint64_t)a1);
  return 1;
}

uint64_t compare_subject_policy(uint64_t a1, uint64_t a2)
{
  return OBJ_cmp(*(const ASN1_OBJECT **)(*(void *)a1 + 8), *(const ASN1_OBJECT **)(*(void *)a2 + 8));
}

uint64_t apply_skip_certs(uint64_t a1, unint64_t *a2)
{
  if (!a1) {
    return 1;
  }
  if (*(unsigned char *)(a1 + 5))
  {
    ERR_put_error(11, 4095, 201, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_policy.c", 702);
    return 0;
  }
  else
  {
    unint64_t v4 = 0;
    if (ASN1_INTEGER_get_uint64(&v4, (unsigned int *)a1))
    {
      if (v4 < *a2) {
        *a2 = v4;
      }
    }
    ERR_clear_error();
    return 1;
  }
}

BIO *cms_EncryptedContent_init_bio(uint64_t a1)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  unint64_t v4 = BIO_f_cipher();
  int v5 = BIO_new(v4);
  uint64_t v6 = v5;
  if (!v5)
  {
    ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_enc.c", 89);
    return v6;
  }
  HMAC_CTX ctx = 0;
  BIO_ctrl(v5, 129, 0, &ctx);
  if (!v3)
  {
    int v13 = OBJ_obj2nid(*(const ASN1_OBJECT **)v2);
    int v14 = OBJ_nid2sn(v13);
    cipherbyname = EVP_get_cipherbyname(v14);
    if (!cipherbyname)
    {
      int v17 = 148;
      int v18 = 106;
      goto LABEL_41;
    }
    if (EVP_CipherInit_ex(ctx, cipherbyname, 0, 0, 0, 0) > 0)
    {
      if (EVP_CIPHER_asn1_to_param(ctx, *(ASN1_TYPE **)(v2 + 8)) > 0)
      {
        int v12 = 0;
        size_t v16 = EVP_CIPHER_CTX_key_length(ctx);
        goto LABEL_29;
      }
      int v17 = 102;
      int v18 = 126;
LABEL_41:
      ERR_put_error(46, 4095, v17, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_enc.c", v18);
      size_t v16 = 0;
      uint64_t v19 = 0;
      goto LABEL_45;
    }
LABEL_13:
    int v17 = 101;
    int v18 = 112;
    goto LABEL_41;
  }
  uint64_t v7 = (const unsigned __int8 **)(a1 + 32);
  int v8 = *(const EVP_CIPHER **)(a1 + 24);
  if (*(void *)(a1 + 32)) {
    *(void *)(a1 + 24) = 0;
  }
  if (EVP_CipherInit_ex(ctx, v8, 0, 0, 0, v3 != 0) < 1) {
    goto LABEL_13;
  }
  int v9 = EVP_CIPHER_CTX_cipher(ctx);
  int v10 = EVP_CIPHER_type(v9);
  *(void *)uint64_t v2 = OBJ_nid2obj(v10);
  int v11 = EVP_CIPHER_CTX_iv_length(ctx);
  if (v11 < 1)
  {
    int v12 = 0;
  }
  else
  {
    int v12 = __buf;
    arc4random_buf(__buf, v11);
  }
  size_t v16 = EVP_CIPHER_CTX_key_length(ctx);
  if (*v7) {
    goto LABEL_16;
  }
LABEL_29:
  uint64_t v19 = malloc_type_malloc(v16, 0xC30DF115uLL);
  if (!v19)
  {
    int v24 = 65;
    int v25 = 134;
    goto LABEL_44;
  }
  if (EVP_CIPHER_CTX_rand_key(ctx, (unsigned __int8 *)v19) < 1)
  {
LABEL_45:
    freezero(*(void **)(a1 + 32), *(void *)(a1 + 40));
    *(void *)(a1 + 32) = 0;
    freezero(v19, v16);
    BIO_free(v6);
    return 0;
  }
  uint64_t v7 = (const unsigned __int8 **)(a1 + 32);
  if (*(void *)(a1 + 32)) {
    goto LABEL_17;
  }
  *(void *)(a1 + 32) = v19;
  *(void *)(a1 + 4RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = v16;
  if (v3)
  {
    uint64_t v19 = 0;
    char v20 = 0;
    goto LABEL_18;
  }
  ERR_clear_error();
LABEL_16:
  uint64_t v19 = 0;
LABEL_17:
  char v20 = 1;
LABEL_18:
  uint64_t v21 = *(void *)(a1 + 40);
  if (v21 != v16 && !EVP_CIPHER_CTX_set_key_length(ctx, v21))
  {
    if (v3 || *(_DWORD *)(a1 + 48))
    {
      int v24 = 118;
      int v25 = 160;
      goto LABEL_44;
    }
    freezero(*(void **)(a1 + 32), *(void *)(a1 + 40));
    *(void *)(a1 + 32) = v19;
    *(void *)(a1 + 4RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = v16;
    ERR_clear_error();
    uint64_t v19 = 0;
  }
  if (EVP_CipherInit_ex(ctx, 0, 0, *v7, v12, v3 != 0) <= 0)
  {
    int v24 = 101;
    int v25 = 174;
LABEL_44:
    ERR_put_error(46, 4095, v24, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_enc.c", v25);
    goto LABEL_45;
  }
  if (v3)
  {
    int v22 = ASN1_TYPE_new();
    *(void *)(v2 + 8) = v22;
    if (v22)
    {
      if (EVP_CIPHER_param_to_asn1(ctx, v22) > 0)
      {
        int v23 = *(ASN1_TYPE **)(v2 + 8);
        if (v23->type == -1)
        {
          ASN1_TYPE_free(v23);
          *(void *)(v2 + 8) = 0;
        }
        goto LABEL_26;
      }
      int v24 = 102;
      int v25 = 184;
    }
    else
    {
      int v24 = 65;
      int v25 = 180;
    }
    goto LABEL_44;
  }
LABEL_26:
  if (v20)
  {
    freezero(*(void **)(a1 + 32), *(void *)(a1 + 40));
    *(void *)(a1 + 32) = 0;
  }
  freezero(v19, v16);
  return v6;
}

uint64_t cms_EncryptedContent_init(ASN1_OBJECT **a1, ASN1_OBJECT *a2, const void *a3, ASN1_OBJECT *size)
{
  a1[3] = a2;
  if (a3)
  {
    int v8 = (ASN1_OBJECT *)malloc_type_malloc((size_t)size, 0x87629521uLL);
    a1[4] = v8;
    if (!v8)
    {
      ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_enc.c", 214);
      return 0;
    }
    memcpy(v8, a3, (size_t)size);
  }
  a1[5] = size;
  if (a2) {
    *a1 = OBJ_nid2obj(21);
  }
  return 1;
}

uint64_t CMS_EncryptedData_set1_key(uint64_t a1, ASN1_OBJECT *a2, const void *a3, ASN1_OBJECT *a4)
{
  if (!a3 || !a4)
  {
    int v9 = 130;
    int v10 = 233;
    goto LABEL_7;
  }
  if (!a2)
  {
    if (OBJ_obj2nid(*(const ASN1_OBJECT **)a1) == 26) {
      goto LABEL_9;
    }
    int v9 = 122;
    int v10 = 245;
LABEL_7:
    ERR_put_error(46, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_enc.c", v10);
    return 0;
  }
  int v8 = ASN1_item_new(&CMS_EncryptedData_it);
  *(void *)(a1 + 8) = v8;
  if (!v8)
  {
    int v9 = 65;
    int v10 = 239;
    goto LABEL_7;
  }
  *(void *)a1 = OBJ_nid2obj(26);
  **(void **)(a1 + 8) = 0;
LABEL_9:
  int v12 = *(ASN1_OBJECT ***)(*(void *)(a1 + 8) + 8);
  return cms_EncryptedContent_init(v12, a2, a3, a4);
}

BIO *cms_EncryptedData_init_bio(uint64_t a1)
{
  int v1 = *(void **)(a1 + 8);
  uint64_t v2 = v1[1];
  if (*(void *)(v2 + 24) && v1[2]) {
    *int v1 = 2;
  }
  return cms_EncryptedContent_init_bio(v2);
}

uint64_t i2r_ocsp_crlid(int a1, ASN1_STRING **a2, BIO *bio, int a4)
{
  if (*a2
    && (BIO_printf(bio, "%*scrlUrl: ", a4, "") < 1 || !ASN1_STRING_print(bio, *a2) || BIO_write(bio, "\n", 1) < 1)
    || a2[1]
    && (BIO_printf(bio, "%*scrlNum: ", a4, "") < 1 || i2a_ASN1_INTEGER(bio, a2[1]) < 1 || BIO_write(bio, "\n", 1) < 1))
  {
    return 0;
  }
  if (!a2[2]) {
    return 1;
  }
  if (BIO_printf(bio, "%*scrlTime: ", a4, "") < 1) {
    return 0;
  }
  if (!ASN1_GENERALIZEDTIME_print(bio, a2[2])) {
    return 0;
  }
  uint64_t v7 = 1;
  if (BIO_write(bio, "\n", 1) <= 0) {
    return 0;
  }
  return v7;
}

BOOL i2r_ocsp_acutoff(int a1, ASN1_GENERALIZEDTIME *a2, BIO *bio, int a4)
{
  return BIO_printf(bio, "%*s", a4, "") >= 1 && ASN1_GENERALIZEDTIME_print(bio, a2) != 0;
}

BOOL i2r_object(int a1, ASN1_OBJECT *a2, BIO *bio, int a4)
{
  return BIO_printf(bio, "%*s", a4, "") >= 1 && i2a_ASN1_OBJECT(bio, a2) > 0;
}

ASN1_OCTET_STRING *d2i_ocsp_nonce(ASN1_OCTET_STRING **a1, const unsigned __int8 **a2, uint64_t len)
{
  if ((a1 && (uint64_t v6 = *a1) != 0 || (uint64_t v6 = ASN1_OCTET_STRING_new()) != 0) && ASN1_OCTET_STRING_set(v6, *a2, len))
  {
    *a2 += len;
    if (a1) {
      *a1 = v6;
    }
  }
  else
  {
    if (!a1 || *a1 != v6) {
      ASN1_OCTET_STRING_free(v6);
    }
    ERR_put_error(39, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_ocsp.c", 318);
    return 0;
  }
  return v6;
}

uint64_t i2d_ocsp_nonce(const void **a1, void **a2)
{
  uint64_t result = *(unsigned int *)a1;
  if (a2)
  {
    memcpy(*a2, a1[1], (int)result);
    uint64_t result = *(int *)a1;
    *a2 = (char *)*a2 + result;
  }
  return result;
}

BOOL i2r_ocsp_nonce(int a1, ASN1_STRING *a2, BIO *bio, int a4)
{
  return BIO_printf(bio, "%*s", a4, "") >= 1 && i2a_ASN1_STRING(bio, a2, 4) > 0;
}

uint64_t i2r_ocsp_nocheck()
{
  return 1;
}

uint64_t i2r_ocsp_serviceloc(int a1, uint64_t a2, BIO *bio, int a4)
{
  if (BIO_printf(bio, "%*sIssuer: ", a4, "") >= 1 && X509_NAME_print_ex(bio, *(X509_NAME **)a2, 0, 0x82031FuLL) >= 1)
  {
    if (sk_num(*(const STACK **)(a2 + 8)) < 1) {
      return 1;
    }
    int v7 = 0;
    while (1)
    {
      int v8 = sk_value(*(const STACK **)(a2 + 8), v7);
      if (BIO_printf(bio, "\n%*s", 2 * a4, "") < 1
        || i2a_ASN1_OBJECT(bio, *(ASN1_OBJECT **)v8) < 1
        || BIO_puts(bio, " - ") < 1
        || GENERAL_NAME_print(bio, *((GENERAL_NAME **)v8 + 1)) <= 0)
      {
        break;
      }
      if (++v7 >= sk_num(*(const STACK **)(a2 + 8))) {
        return 1;
      }
    }
  }
  return 0;
}

unint64_t *idea_ofb64_encrypt(unint64_t *result, unsigned char *a2, uint64_t a3, unsigned int *a4, unsigned __int8 *a5, int *a6)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  int v7 = *a6;
  uint64_t v8 = *a5;
  uint64_t v9 = a5[1];
  uint64_t v10 = a5[2];
  uint64_t v11 = a5[3];
  int v12 = (v8 << 24) | (v9 << 16) | (v10 << 8) | v11;
  uint64_t v13 = a5[4];
  uint64_t v14 = a5[5];
  uint64_t v15 = a5[6];
  uint64_t v16 = a5[7];
  int v17 = (v13 << 24) | (v14 << 16) | (v15 << 8) | v16;
  uint64_t v25 = (v8 << 24) | (v9 << 16) | (v10 << 8) | v11;
  uint64_t v26 = (v13 << 24) | (v14 << 16) | (v15 << 8) | v16;
  LOBYTE(v27) = v8;
  BYTE1(v27) = v9;
  BYTE2(v27) = v10;
  HIBYTE(v27) = v11;
  LOBYTE(v28) = v13;
  BYTE1(v28) = v14;
  BYTE2(v28) = v15;
  HIBYTE(v28) = v16;
  if (a3)
  {
    uint64_t v20 = a3;
    int v22 = result;
    int v23 = 0;
    do
    {
      if (!v7)
      {
        uint64_t result = idea_encrypt((unint64_t *)&v25, a4);
        int v12 = v25;
        int v17 = v26;
        unsigned int v27 = bswap32(v25);
        unsigned int v28 = bswap32(v26);
        ++v23;
      }
      char v24 = *(unsigned char *)v22;
      int v22 = (unint64_t *)((char *)v22 + 1);
      *a2++ = *((unsigned char *)&v27 + v7) ^ v24;
      int v7 = (v7 + 1) & 7;
      --v20;
    }
    while (v20);
    if (v23)
    {
      *a5 = HIBYTE(v12);
      a5[1] = BYTE2(v12);
      a5[2] = BYTE1(v12);
      a5[3] = v12;
      a5[4] = HIBYTE(v17);
      a5[5] = BYTE2(v17);
      a5[6] = BYTE1(v17);
      a5[7] = v17;
    }
  }
  *a6 = v7;
  return result;
}

void ASN1_STRING_set_default_mask(unint64_t mask)
{
  global_mauint64_t sk = mask;
}

unint64_t ASN1_STRING_get_default_mask(void)
{
  return global_mask;
}

int ASN1_STRING_set_default_mask_asc(const char *p)
{
  if (strncmp(p, "MASK:", 5uLL))
  {
    if (!strcmp(p, "nombstr"))
    {
      unint64_t v2 = -10241;
      goto LABEL_15;
    }
    if (!strcmp(p, "pkix"))
    {
      unint64_t v2 = -5;
      goto LABEL_15;
    }
    if (!strcmp(p, "utf8only"))
    {
      unint64_t v2 = 0x2000;
      goto LABEL_15;
    }
    if (!strcmp(p, "default"))
    {
      unint64_t v2 = 0xFFFFFFFFLL;
LABEL_15:
      global_mauint64_t sk = v2;
      return 1;
    }
    return 0;
  }
  int v4 = *((unsigned __int8 *)p + 5);
  uint64_t v3 = p + 5;
  if (!v4) {
    return 0;
  }
  __endptr = 0;
  int v5 = *__error();
  *__error() = 0;
  unint64_t v2 = strtoul(v3, &__endptr, 0);
  if (*__error() != 34 || (int result = 0, v2 != -1))
  {
    *__error() = v5;
    if (!*__endptr) {
      goto LABEL_15;
    }
    return 0;
  }
  return result;
}

ASN1_STRING *__cdecl ASN1_STRING_set_by_NID(ASN1_STRING **out, const unsigned __int8 *in, int inlen, int inform, int nid)
{
  uint64_t v13 = 0;
  if (out) {
    uint64_t v8 = out;
  }
  else {
    uint64_t v8 = (ASN1_STRING **)&v13;
  }
  uint64_t v9 = ASN1_STRING_TABLE_get(nid);
  if (v9)
  {
    if ((v9->flags & 2) != 0) {
      uint64_t v10 = -1;
    }
    else {
      uint64_t v10 = global_mask;
    }
    int v11 = ASN1_mbstring_ncopy(v8, in, inlen, inform, v10 & v9->mask, v9->minsize, v9->maxsize);
  }
  else
  {
    int v11 = ASN1_mbstring_copy(v8, in, inlen, inform, global_mask & 0x2806);
  }
  if (v11 < 1) {
    return 0;
  }
  else {
    return *v8;
  }
}

ASN1_STRING_TABLE *__cdecl ASN1_STRING_TABLE_get(int nid)
{
  uint64_t v4 = 0;
  memset(v3, 0, sizeof(v3));
  LODWORD(v3[0]) = nid;
  if (!stable) {
    return (ASN1_STRING_TABLE *)OBJ_bsearch_((const char *)v3, "\r", 19, 40, (int (__cdecl *)(const void *, const void *))table_cmp_BSEARCH_CMP_FN);
  }
  int v1 = sk_find((STACK *)stable, (char *)v3);
  if (v1 < 0) {
    return (ASN1_STRING_TABLE *)OBJ_bsearch_((const char *)v3, "\r", 19, 40, (int (__cdecl *)(const void *, const void *))table_cmp_BSEARCH_CMP_FN);
  }
  else {
    return (ASN1_STRING_TABLE *)sk_value((const STACK *)stable, v1);
  }
}

int ASN1_STRING_TABLE_add(int a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  if (!stable)
  {
    stable = (uint64_t)sk_new((int (__cdecl *)(const char *const *, const char *const *))sk_table_cmp);
    if (!stable) {
      goto LABEL_21;
    }
  }
  uint64_t v10 = ASN1_STRING_TABLE_get(a1);
  int v11 = v10;
  if (!v10 || (v10->flags & 1) == 0)
  {
    int v12 = (char *)malloc_type_calloc(1uLL, 0x28uLL, 0x1000040B4E0BC51uLL);
    if (v12)
    {
      p_niunsigned int d = v12;
      if (sk_push((STACK *)stable, v12))
      {
        if (v11)
        {
          *(_DWORD *)p_niunsigned int d = v11->nid;
          *(_OWORD *)(p_nid + md5_block_data_order((unint64_t)c, b, 1) = *(_OWORD *)&v11->minsize;
          uint64_t v14 = v11->flags | 1;
          p_nid[3] = v11->mask;
          p_nid[4] = v14;
          if (a2 < 0) {
            goto LABEL_12;
          }
        }
        else
        {
          *(_DWORD *)p_niunsigned int d = a1;
          p_nid[1] = -1;
          p_nid[2] = -1;
          p_nid[4] = 1;
          if (a2 < 0) {
            goto LABEL_12;
          }
        }
        goto LABEL_11;
      }
      free(p_nid);
    }
    else
    {
      ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_strnid.c", 281);
    }
LABEL_21:
    ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_strnid.c", 310);
    return 0;
  }
  p_niunsigned int d = &v10->nid;
  if ((a2 & 0x8000000000000000) == 0) {
LABEL_11:
  }
    p_nid[1] = a2;
LABEL_12:
  if ((a3 & 0x8000000000000000) == 0) {
    p_nid[2] = a3;
  }
  if (a4) {
    p_nid[3] = a4;
  }
  if (a5) {
    p_nid[4] = a5 | 1;
  }
  return 1;
}

void ASN1_STRING_TABLE_cleanup(void)
{
  uint64_t v0 = (STACK *)stable;
  if (stable)
  {
    stable = 0;
    sk_pop_free(v0, (void (__cdecl *)(void *))st_free);
  }
}

void st_free(void *a1)
{
  if (*((unsigned char *)a1 + 32)) {
    free(a1);
  }
}

uint64_t table_cmp_BSEARCH_CMP_FN(_DWORD *a1, _DWORD *a2)
{
  return (*a1 - *a2);
}

uint64_t sk_table_cmp(_DWORD **a1, _DWORD **a2)
{
  return (**a1 - **a2);
}

uint64_t ASN1_time_tm_cmp(_DWORD *a1, _DWORD *a2)
{
  int v2 = a1[5];
  int v3 = a2[5];
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  if (v2 > v3) {
    return 1;
  }
  int v4 = a1[4];
  int v5 = a2[4];
  if (v4 < v5) {
    return 0xFFFFFFFFLL;
  }
  if (v4 > v5) {
    return 1;
  }
  int v6 = a1[3];
  int v7 = a2[3];
  if (v6 < v7) {
    return 0xFFFFFFFFLL;
  }
  if (v6 > v7) {
    return 1;
  }
  int v8 = a1[2];
  int v9 = a2[2];
  if (v8 < v9) {
    return 0xFFFFFFFFLL;
  }
  if (v8 > v9) {
    return 1;
  }
  int v10 = a1[1];
  int v11 = a2[1];
  if (v10 < v11) {
    return 0xFFFFFFFFLL;
  }
  if (v10 > v11) {
    return 1;
  }
  if (*a1 >= *a2) {
    return *a1 > *a2;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t ASN1_time_tm_clamp_notafter()
{
  return 1;
}

ASN1_TIME *tm_to_gentime(_DWORD *a1, ASN1_TIME *a2)
{
  int v7 = 0;
  int v2 = a1[5];
  if ((v2 - 8100) <= 0xFFFFD8EF)
  {
    int v3 = 184;
    int v4 = 89;
LABEL_9:
    ERR_put_error(13, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_time_tm.c", v4);
    free(v7);
    return 0;
  }
  if (asprintf(&v7, "%04u%02u%02u%02u%02u%02uZ", v2 + 1900, a1[4] + 1, a1[3], a1[2], a1[1], *a1) == -1)
  {
    int v7 = 0;
    int v3 = 65;
    int v4 = 97;
    goto LABEL_9;
  }
  if (!a2)
  {
    a2 = ASN1_TIME_new();
    if (!a2)
    {
      int v3 = 65;
      int v4 = 104;
      goto LABEL_9;
    }
  }
  free(a2->data);
  a2->uint64_t data = (unsigned __int8 *)v7;
  *(void *)&a2->int length = 0x180000000FLL;
  return a2;
}

ASN1_TIME *tm_to_utctime(_DWORD *a1, ASN1_TIME *a2)
{
  int v7 = 0;
  unsigned int v2 = a1[5];
  if (v2 - 150 <= 0xFFFFFF9B)
  {
    int v3 = 184;
    int v4 = 128;
LABEL_11:
    ERR_put_error(13, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_time_tm.c", v4);
    free(v7);
    return 0;
  }
  if (v2 >= 0x64) {
    v2 -= 100;
  }
  if (asprintf(&v7, "%02u%02u%02u%02u%02u%02uZ", v2, a1[4] + 1, a1[3], a1[2], a1[1], *a1) == -1)
  {
    int v7 = 0;
    int v3 = 65;
    int v4 = 136;
    goto LABEL_11;
  }
  if (!a2)
  {
    a2 = ASN1_TIME_new();
    if (!a2)
    {
      int v3 = 65;
      int v4 = 143;
      goto LABEL_11;
    }
  }
  free(a2->data);
  a2->uint64_t data = (unsigned __int8 *)v7;
  *(void *)&a2->int length = 0x170000000DLL;
  return a2;
}

ASN1_TIME *tm_to_rfc5280_time(_DWORD *a1, ASN1_TIME *a2)
{
  unsigned int v2 = a1[5];
  if (v2 - 8100 > 0xFFFFE08D)
  {
    if (v2 > 0x95)
    {
      return tm_to_gentime(a1, a2);
    }
    else
    {
      return tm_to_utctime(a1, a2);
    }
  }
  else
  {
    ERR_put_error(13, 4095, 184, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_time_tm.c", 167);
    return 0;
  }
}

uint64_t asn1_time_parse_cbs(void *a1, int a2, uint64_t a3)
{
  int v25 = 0;
  memset(v24, 0, sizeof(v24));
  char v23 = 0;
  CBS_dup(a1, v24);
  uint64_t result = cbs_get_two_digit_value(v24, &v25);
  if (a2)
  {
    if (!result) {
      return result;
    }
    int v6 = v25;
    uint64_t result = cbs_get_two_digit_value(v24, &v25);
    if (!result) {
      return result;
    }
    int v7 = v25 + 100 * v6;
  }
  else
  {
    if (!result) {
      return result;
    }
    if (v25 >= 50) {
      int v8 = 1900;
    }
    else {
      int v8 = 2000;
    }
    int v7 = v8 + v25;
    if (v8 + v25 > 2049) {
      return 0;
    }
  }
  unsigned int v30 = 0;
  uint64_t result = cbs_get_two_digit_value(v24, &v30);
  if (!result) {
    return result;
  }
  unsigned int v9 = v30;
  if (v30 - 13 < 0xFFFFFFF4) {
    return 0;
  }
  unsigned int v29 = 0;
  uint64_t result = cbs_get_two_digit_value(v24, &v29);
  if (result)
  {
    unsigned int v10 = v29;
    if ((int)v29 < 1) {
      return 0;
    }
    uint64_t result = 0;
    if (v9 > 0xC) {
      return result;
    }
    if (((1 << v9) & 0x15AA) != 0)
    {
      if (v29 > 0x1F) {
        return 0;
      }
    }
    else if (((1 << v9) & 0xA50) != 0)
    {
      if (v29 >= 0x1F) {
        return 0;
      }
    }
    else
    {
      if (v9 != 2) {
        return result;
      }
      HIDWORD(v19) = -1030792151 * v7 + 85899344;
      LODWORD(v19) = HIDWORD(v19);
      unsigned int v18 = v19 >> 2;
      BOOL v21 = (v7 & 3) == 0 && v18 > 0x28F5C28;
      HIDWORD(v22) = -1030792151 * v7 + 85899344;
      LODWORD(v22) = HIDWORD(v22);
      if ((v22 >> 4) < 0xA3D70B || v21)
      {
        if (v29 >= 0x1E) {
          return 0;
        }
      }
      else if (v29 >= 0x1D)
      {
        return 0;
      }
    }
    int v28 = 0;
    int two_digit_value = cbs_get_two_digit_value(v24, &v28);
    uint64_t result = 0;
    if (two_digit_value)
    {
      int v12 = v28;
      if (v28 <= 23)
      {
        int v27 = 0;
        int v13 = cbs_get_two_digit_value(v24, &v27);
        uint64_t result = 0;
        if (v13)
        {
          int v14 = v27;
          if (v27 <= 59)
          {
            int v26 = 0;
            int v15 = cbs_get_two_digit_value(v24, &v26);
            uint64_t result = 0;
            if (v15)
            {
              int v16 = v26;
              if (v26 <= 59)
              {
                int u8 = CBS_get_u8(v24, &v23);
                uint64_t result = 0;
                if (u8)
                {
                  if (v23 == 90)
                  {
                    if (!CBS_len((uint64_t)v24))
                    {
                      if (!a3) {
                        return 1;
                      }
                      *(_OWORD *)a3 = 0u;
                      *(_OWORD *)(a3 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = 0u;
                      *(void *)(a3 + 48) = 0;
                      *(_OWORD *)(a3 + 32) = 0u;
                      *(_DWORD *)(a3 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = v9 - 1;
                      *(_DWORD *)(a3 + 2RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = v7 - 1900;
                      *(_DWORD *)(a3 + 8) = v12;
                      *(_DWORD *)(a3 + 12) = v10;
                      uint64_t result = 1;
                      *(_DWORD *)a3 = v16;
                      *(_DWORD *)(a3 + 4) = v14;
                      return result;
                    }
                    return 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t cbs_get_two_digit_value(void *a1, _DWORD *a2)
{
  __int16 v5 = 0;
  uint64_t result = CBS_get_u8(a1, (unsigned char *)&v5 + 1);
  if (result)
  {
    if (HIBYTE(v5) - 48 > 9) {
      return 0;
    }
    uint64_t result = CBS_get_u8(a1, &v5);
    if (!result) {
      return result;
    }
    if (v5 - 48 > 9)
    {
      return 0;
    }
    else
    {
      *a2 = v5 + 10 * HIBYTE(v5) - 528;
      return 1;
    }
  }
  return result;
}

uint64_t ASN1_time_parse(uint64_t a1, uint64_t a2, _OWORD *a3, int a4)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v14 = 0;
  memset(v13, 0, sizeof(v13));
  v12[1] = 0;
  _OWORD v12[2] = 0;
  if (a3) {
    __int16 v5 = a3;
  }
  else {
    __int16 v5 = v13;
  }
  v12[0] = 0;
  CBS_init(v12, a1, a2);
  uint64_t v6 = CBS_len((uint64_t)v12);
  uint64_t v7 = CBS_len((uint64_t)v12);
  int v8 = asn1_time_parse_cbs(v12, v7 == 15, (uint64_t)v5);
  if (v6 == 13) {
    unsigned int v9 = 23;
  }
  else {
    unsigned int v9 = 0;
  }
  if (v7 == 15) {
    unsigned int v9 = 24;
  }
  if (v9 != a4 && a4 != 0) {
    unsigned int v9 = -1;
  }
  if (v8) {
    return v9;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

ASN1_TIME *__cdecl ASN1_TIME_set(ASN1_TIME *s, time_t t)
{
  return ASN1_TIME_adj_internal(s, t, 0, 0, 0);
}

ASN1_TIME *ASN1_TIME_adj(ASN1_TIME *a1, uint64_t a2, int a3, uint64_t a4)
{
  return ASN1_TIME_adj_internal(a1, a2, a3, a4, 0);
}

ASN1_TIME *ASN1_TIME_set_tm(ASN1_TIME *a1, int *a2)
{
  uint64_t v4 = 0;
  if (asn1_time_tm_to_time_t(a2, &v4)) {
    return ASN1_TIME_adj_internal(a1, v4, 0, 0, 0);
  }
  else {
    return 0;
  }
}

ASN1_TIME *ASN1_TIME_adj_internal(ASN1_TIME *a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v12 = a2;
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  if (asn1_time_time_t_to_tm(&v12, (uint64_t)v10)
    && (!a3 && !a4 || OPENSSL_gmtime_adj((int *)v10, a3, a4)))
  {
    switch(a5)
    {
      case 0:
        return tm_to_rfc5280_time(v10, a1);
      case 24:
        return tm_to_gentime(v10, a1);
      case 23:
        return tm_to_utctime(v10, a1);
    }
  }
  return 0;
}

int ASN1_TIME_check(ASN1_TIME *t)
{
  int type = t->type;
  return (type - 23) <= 1 && type == ASN1_time_parse((uint64_t)t->data, t->length, 0, type);
}

ASN1_GENERALIZEDTIME *__cdecl ASN1_TIME_to_generalizedtime(ASN1_TIME *t, ASN1_GENERALIZEDTIME **out)
{
  int type = t->type;
  if ((type - 23) > 1) {
    return 0;
  }
  uint64_t v7 = 0;
  memset(v6, 0, sizeof(v6));
  int v4 = ASN1_time_parse((uint64_t)t->data, t->length, v6, type);
  uint64_t result = 0;
  if (type == v4)
  {
    if (out)
    {
      uint64_t result = tm_to_gentime(v6, *out);
      if (result) {
        unsigned __int8 *out = result;
      }
    }
    else
    {
      return tm_to_gentime(v6, 0);
    }
  }
  return result;
}

char *ASN1_TIME_set_string(uint64_t a1, char *a2)
{
  return ASN1_TIME_set_string_internal(a1, a2, 0);
}

char *ASN1_TIME_set_string_internal(uint64_t a1, char *__s, int a3)
{
  size_t v6 = strlen(__s);
  int v7 = ASN1_time_parse((uint64_t)__s, v6, 0, a3);
  if (v7 == -1) {
    return 0;
  }
  int v8 = v7;
  if (a3)
  {
    if (v7 != a3) {
      return 0;
    }
  }
  if (a1)
  {
    uint64_t result = strdup(__s);
    if (!result) {
      return result;
    }
    unsigned int v10 = result;
    free(*(void **)(a1 + 8));
    *(void *)(a1 + 8) = v10;
    *(_DWORD *)a1 = strlen(v10);
    *(_DWORD *)(a1 + 4) = v8;
  }
  return (char *)1;
}

uint64_t ASN1_TIME_compare(int *a1, int *a2)
{
  int v2 = a1[1];
  if ((v2 - 23) > 1) {
    return 4294967294;
  }
  if ((a2[1] - 23) > 1) {
    return 4294967294;
  }
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  memset(v6, 0, sizeof(v6));
  uint64_t v7 = 0;
  if (ASN1_time_parse(*((void *)a1 + 1), *a1, v8, v2) == -1
    || ASN1_time_parse(*((void *)a1 + 1), *a2, v6, a2[1]) == -1)
  {
    return 4294967294;
  }
  else
  {
    return ASN1_time_tm_cmp(v8, v6);
  }
}

uint64_t ASN1_TIME_cmp_time_t(int *a1, uint64_t a2)
{
  int v2 = a1[1];
  if ((v2 - 23) > 1) {
    return 4294967294;
  }
  else {
    return ASN1_TIME_cmp_time_t_internal(a1, a2, v2);
  }
}

uint64_t ASN1_TIME_cmp_time_t_internal(int *a1, uint64_t a2, int a3)
{
  uint64_t v8 = a2;
  uint64_t v7 = 0;
  memset(v6, 0, sizeof(v6));
  uint64_t v5 = 0;
  memset(v4, 0, sizeof(v4));
  if (ASN1_time_parse(*((void *)a1 + 1), *a1, v6, a3) == -1
    || !asn1_time_time_t_to_tm(&v8, (uint64_t)v4))
  {
    return 4294967294;
  }
  else
  {
    return ASN1_time_tm_cmp(v6, v4);
  }
}

int ASN1_UTCTIME_check(ASN1_UTCTIME *a)
{
  return a->type == 23 && ASN1_time_parse((uint64_t)a->data, a->length, 0, 23) == 23;
}

int ASN1_UTCTIME_set_string(ASN1_UTCTIME *s, const char *str)
{
  if (s && s->type != 23) {
    return 0;
  }
  else {
    return ASN1_TIME_set_string_internal((uint64_t)s, (char *)str, 23);
  }
}

ASN1_UTCTIME *__cdecl ASN1_UTCTIME_set(ASN1_UTCTIME *s, time_t t)
{
  return ASN1_TIME_adj_internal(s, t, 0, 0, 23);
}

ASN1_TIME *ASN1_UTCTIME_adj(ASN1_TIME *a1, uint64_t a2, int a3, uint64_t a4)
{
  return ASN1_TIME_adj_internal(a1, a2, a3, a4, 23);
}

int ASN1_UTCTIME_cmp_time_t(const ASN1_UTCTIME *s, time_t t)
{
  if (s->type == 23) {
    return ASN1_TIME_cmp_time_t_internal(&s->length, t, 23);
  }
  else {
    return -2;
  }
}

int ASN1_GENERALIZEDTIME_check(ASN1_GENERALIZEDTIME *a)
{
  return a->type == 24 && ASN1_time_parse((uint64_t)a->data, a->length, 0, 24) == 24;
}

int ASN1_GENERALIZEDTIME_set_string(ASN1_GENERALIZEDTIME *s, const char *str)
{
  if (s && s->type != 24) {
    return 0;
  }
  else {
    return ASN1_TIME_set_string_internal((uint64_t)s, (char *)str, 24);
  }
}

ASN1_GENERALIZEDTIME *__cdecl ASN1_GENERALIZEDTIME_set(ASN1_GENERALIZEDTIME *s, time_t t)
{
  return ASN1_TIME_adj_internal(s, t, 0, 0, 24);
}

ASN1_TIME *ASN1_GENERALIZEDTIME_adj(ASN1_TIME *a1, uint64_t a2, int a3, uint64_t a4)
{
  return ASN1_TIME_adj_internal(a1, a2, a3, a4, 24);
}

uint64_t ASN1_TIME_normalize(ASN1_TIME *a1)
{
  uint64_t v4 = 0;
  memset(v3, 0, sizeof(v3));
  uint64_t result = ASN1_TIME_to_tm(&a1->length, (uint64_t)v3);
  if (result) {
    return tm_to_rfc5280_time(v3, a1) != 0;
  }
  return result;
}

char *ASN1_TIME_set_string_X509(uint64_t a1, char *a2)
{
  return ASN1_TIME_set_string_internal(a1, a2, 0);
}

void ERR_load_TS_strings()
{
  if (!ERR_func_error_string(TS_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&TS_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&TS_str_reasons);
  }
}

BOOL asn1_must_be_constructed(unsigned int a1)
{
  if ((a1 & 0xFFFFFFF7) == 0x102) {
    unsigned int v1 = a1 & 0xFFFFFEFF;
  }
  else {
    unsigned int v1 = a1;
  }
  BOOL v2 = v1 >= 0x1F;
  unsigned int v3 = v1 & 0xFFFFFFFE;
  return !v2 && v3 == 16;
}

unint64_t asn1_must_be_primitive(unsigned int a1)
{
  if ((a1 & 0xFFFFFFF7) == 0x102) {
    unsigned int v1 = a1 & 0xFFFFFEFF;
  }
  else {
    unsigned int v1 = a1;
  }
  if (v1 <= 0x1E) {
    return (0x6666uLL >> v1) & 1;
  }
  else {
    return 0;
  }
}

uint64_t asn1_tag2charwidth(unsigned int a1)
{
  if (a1 <= 0x1E) {
    return *((unsigned int *)&asn1_types + 6 * a1 + 3);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

unint64_t ASN1_tag2bit(int tag)
{
  if (tag <= 0x1E) {
    return LODWORD((&asn1_types)[3 * tag + 1]);
  }
  else {
    return 0;
  }
}

const char *__cdecl ASN1_tag2str(int tag)
{
  if ((tag & 0xFFFFFFF7) == 0x102) {
    unsigned int v1 = tag & 0xFFFFFEFF;
  }
  else {
    unsigned int v1 = tag;
  }
  if (v1 <= 0x1E) {
    return (&asn1_types)[3 * v1];
  }
  else {
    return "(unknown)";
  }
}

void syslog_r(int a1, uint64_t a2, char *a3, ...)
{
  va_start(va, a3);
  vsyslog(a1, a3, va);
}

void vsyslog_r(int a1, int a2, char *a3, __darwin_va_list a4)
{
}

uint64_t X509_get0_extensions(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 72);
}

uint64_t X509_get0_tbs_sigalg(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 16);
}

int X509_set_version(X509 *x, uint64_t version)
{
  if (!x) {
    return 0;
  }
  cert_infASN1_OBJECT o = x->cert_info;
  uint64_t v5 = x->cert_info->version;
  if (!v5)
  {
    uint64_t v5 = ASN1_INTEGER_new();
    cert_infASN1_OBJECT o = x->cert_info;
    x->cert_info->versioint n = v5;
    if (!v5) {
      return 0;
    }
  }
  cert_info->enc.modifieunsigned int d = 1;
  return ASN1_INTEGER_set(v5, version);
}

uint64_t X509_get_version(ASN1_INTEGER ***a1)
{
  return ASN1_INTEGER_get(**a1);
}

int X509_set_serialNumber(X509 *x, ASN1_INTEGER *serial)
{
  if (x)
  {
    BOOL v2 = serial;
    unsigned int v3 = x;
    if (x->cert_info->serialNumber != serial)
    {
      BOOL v2 = ASN1_INTEGER_dup(serial);
      if (v2)
      {
        cert_infASN1_OBJECT o = v3->cert_info;
        cert_info->enc.modifieunsigned int d = 1;
        ASN1_INTEGER_free(cert_info->serialNumber);
        v3->cert_info->serialNumber = v2;
      }
    }
    LODWORD(x) = v2 != 0;
  }
  return (int)x;
}

int X509_set_issuer_name(X509 *x, X509_NAME *name)
{
  if (!x) {
    return 0;
  }
  cert_infASN1_OBJECT o = x->cert_info;
  if (!x->cert_info) {
    return 0;
  }
  cert_info->enc.modifieunsigned int d = 1;
  return X509_NAME_set(&cert_info->issuer, name);
}

int X509_set_subject_name(X509 *x, X509_NAME *name)
{
  if (!x) {
    return 0;
  }
  cert_infASN1_OBJECT o = x->cert_info;
  if (!x->cert_info) {
    return 0;
  }
  cert_info->enc.modifieunsigned int d = 1;
  return X509_NAME_set(&cert_info->subject, name);
}

uint64_t X509_get0_notBefore(uint64_t result)
{
  if (result)
  {
    if (*(void *)result && (uint64_t v1 = *(void *)(*(void *)result + 32)) != 0) {
      return *(void *)v1;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t X509_getm_notBefore(uint64_t result)
{
  if (result)
  {
    if (*(void *)result && (uint64_t v1 = *(void *)(*(void *)result + 32)) != 0) {
      return *(void *)v1;
    }
    else {
      return 0;
    }
  }
  return result;
}

int X509_set_notBefore(X509 *x, ASN1_TIME *tm)
{
  if (x)
  {
    BOOL v2 = x;
    validity = x->cert_info->validity;
    if (validity)
    {
      uint64_t v4 = tm;
      if (validity->notBefore != tm)
      {
        uint64_t v4 = ASN1_STRING_dup(tm);
        if (v4)
        {
          cert_infASN1_OBJECT o = v2->cert_info;
          cert_info->enc.modifieunsigned int d = 1;
          ASN1_TIME_free(cert_info->validity->notBefore);
          v2->cert_info->validity->notBefore = v4;
        }
      }
      LODWORD(x) = v4 != 0;
    }
    else
    {
      LODWORD(x) = 0;
    }
  }
  return (int)x;
}

uint64_t X509_get0_notAfter(uint64_t result)
{
  if (result)
  {
    if (*(void *)result && (uint64_t v1 = *(void *)(*(void *)result + 32)) != 0) {
      return *(void *)(v1 + 8);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t X509_getm_notAfter(uint64_t result)
{
  if (result)
  {
    if (*(void *)result && (uint64_t v1 = *(void *)(*(void *)result + 32)) != 0) {
      return *(void *)(v1 + 8);
    }
    else {
      return 0;
    }
  }
  return result;
}

int X509_set_notAfter(X509 *x, ASN1_TIME *tm)
{
  if (x)
  {
    BOOL v2 = x;
    validity = x->cert_info->validity;
    if (validity)
    {
      uint64_t v4 = tm;
      if (validity->notAfter != tm)
      {
        uint64_t v4 = ASN1_STRING_dup(tm);
        if (v4)
        {
          cert_infASN1_OBJECT o = v2->cert_info;
          cert_info->enc.modifieunsigned int d = 1;
          ASN1_TIME_free(cert_info->validity->notAfter);
          v2->cert_info->validity->notAfter = v4;
        }
      }
      LODWORD(x) = v4 != 0;
    }
    else
    {
      LODWORD(x) = 0;
    }
  }
  return (int)x;
}

int X509_set_pubkey(X509 *x, EVP_PKEY *pkey)
{
  if (!x) {
    return 0;
  }
  cert_infASN1_OBJECT o = x->cert_info;
  if (!x->cert_info) {
    return 0;
  }
  cert_info->enc.modifieunsigned int d = 1;
  return X509_PUBKEY_set(&cert_info->key, pkey);
}

uint64_t X509_get_signature_type(uint64_t a1)
{
  int v1 = OBJ_obj2nid(**(const ASN1_OBJECT ***)(a1 + 8));
  return EVP_PKEY_type(v1);
}

uint64_t X509_get_X509_PUBKEY(uint64_t a1)
{
  return *(void *)(*(void *)a1 + 48);
}

uint64_t X509_get0_uids(uint64_t result, void *a2, void *a3)
{
  if (a2) {
    *a2 = *(void *)(*(void *)result + 56);
  }
  if (a3) {
    *a3 = *(void *)(*(void *)result + 64);
  }
  return result;
}

ENGINE *ENGINE_new(void)
{
  if (!OPENSSL_init_crypto(0, 0)) {
    return 0;
  }
  uint64_t v0 = (CRYPTO_EX_DATA *)malloc_type_malloc(0xD8uLL, 0x10F0040B12B0AC7uLL);
  int v1 = (ENGINE *)v0;
  if (v0)
  {
    v0[13].uint64_t sk = 0;
    v0[10] = 0u;
    v0[11] = 0u;
    v0[8] = 0u;
    v0[9] = 0u;
    v0[6] = 0u;
    v0[7] = 0u;
    v0[4] = 0u;
    v0[5] = 0u;
    v0[2] = 0u;
    v0[3] = 0u;
    *uint64_t v0 = 0u;
    v0[1] = 0u;
    v0[12] = 0u;
    HIDWORD(v0[11].sk) = 1;
    CRYPTO_new_ex_data(9, v0, v0 + 12);
  }
  else
  {
    ERR_put_error(38, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_lib.c", 78);
  }
  return v1;
}

double engine_set_all_null(uint64_t a1)
{
  *(void *)(a1 + 168) = 0;
  *(_DWORD *)(a1 + 176) = 0;
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = 0u;
  *(void *)(a1 + 32) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  return result;
}

uint64_t engine_free_util(CRYPTO_EX_DATA *a1, int a2)
{
  if (a1)
  {
    unsigned int v3 = (int *)&a1[11].sk + 1;
    if (a2)
    {
      int v4 = CRYPTO_add_lock(v3, -1, 30, 0, 0);
    }
    else
    {
      int v4 = *v3 - 1;
      int *v3 = v4;
    }
    if (v4 <= 0)
    {
      engine_pkey_meths_free((uint64_t)a1);
      engine_pkey_asn1_meths_free((uint64_t)a1);
      uint64_t sk = a1[7].sk;
      if (sk) {
        ((void (*)(CRYPTO_EX_DATA *))sk)(a1);
      }
      CRYPTO_free_ex_data(9, a1, a1 + 12);
      free(a1);
    }
  }
  return 1;
}

int ENGINE_free(ENGINE *e)
{
  return 1;
}

char *engine_cleanup_add_first(uint64_t a1)
{
  if (cleanup_stack || (double result = (char *)sk_new_null(), (cleanup_stack = (uint64_t)result) != 0))
  {
    double result = (char *)malloc_type_malloc(8uLL, 0x80040B8603338uLL);
    if (result)
    {
      unsigned int v3 = result;
      *(void *)double result = a1;
      int v4 = (STACK *)cleanup_stack;
      return (char *)sk_insert(v4, v3, 0);
    }
  }
  return result;
}

char *engine_cleanup_add_last(uint64_t a1)
{
  if (cleanup_stack || (double result = (char *)sk_new_null(), (cleanup_stack = (uint64_t)result) != 0))
  {
    double result = (char *)malloc_type_malloc(8uLL, 0x80040B8603338uLL);
    if (result)
    {
      unsigned int v3 = result;
      *(void *)double result = a1;
      int v4 = (STACK *)cleanup_stack;
      return (char *)sk_push(v4, v3);
    }
  }
  return result;
}

void ENGINE_cleanup(void)
{
  if (cleanup_stack)
  {
    sk_pop_free((STACK *)cleanup_stack, (void (__cdecl *)(void *))engine_cleanup_cb_free);
    cleanup_stacuint64_t k = 0;
  }
  RAND_set_rand_method(0);
}

void engine_cleanup_cb_free(void (**a1)(void))
{
  (*a1)();
  free(a1);
}

int ENGINE_get_ex_new_index(uint64_t argl, void *argp, CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
  return CRYPTO_get_ex_new_index(9, argl, argp, new_func, dup_func, free_func);
}

int ENGINE_set_ex_data(ENGINE *e, int idx, void *arg)
{
  return CRYPTO_set_ex_data((CRYPTO_EX_DATA *)e + 12, idx, arg);
}

void *__cdecl ENGINE_get_ex_data(const ENGINE *e, int idx)
{
  return CRYPTO_get_ex_data((const CRYPTO_EX_DATA *)e + 12, idx);
}

int ENGINE_set_id(ENGINE *e, const char *id)
{
  if (id)
  {
    *(void *)e = id;
    return 1;
  }
  else
  {
    ERR_put_error(38, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_lib.c", 248);
    return 0;
  }
}

int ENGINE_set_name(ENGINE *e, const char *name)
{
  if (name)
  {
    *((void *)e + engine_free_util((CRYPTO_EX_DATA *)e, 1) = name;
    return 1;
  }
  else
  {
    ERR_put_error(38, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_lib.c", 259);
    return 0;
  }
}

int ENGINE_set_destroy_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR destroy_f)
{
  *((void *)e + 14) = destroy_f;
  return 1;
}

int ENGINE_set_init_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR init_f)
{
  *((void *)e + 15) = init_f;
  return 1;
}

int ENGINE_set_finish_function(ENGINE *e, ENGINE_GEN_INT_FUNC_PTR finish_f)
{
  *((void *)e + ++*(_DWORD *)(*(void *)(result + 8) + 16) = finish_f;
  return 1;
}

int ENGINE_set_ctrl_function(ENGINE *e, ENGINE_CTRL_FUNC_PTR ctrl_f)
{
  *((void *)e + 17) = ctrl_f;
  return 1;
}

int ENGINE_set_flags(ENGINE *e, int flags)
{
  *((_DWORD *)e + 44) = flags;
  return 1;
}

int ENGINE_set_cmd_defns(ENGINE *e, const ENGINE_CMD_DEFN *defns)
{
  *((void *)e + 2engine_free_util((CRYPTO_EX_DATA *)e, 1) = defns;
  return 1;
}

const char *__cdecl ENGINE_get_id(const ENGINE *e)
{
  return *(const char **)e;
}

const char *__cdecl ENGINE_get_name(const ENGINE *e)
{
  return (const char *)*((void *)e + 1);
}

ENGINE_GEN_INT_FUNC_PTR ENGINE_get_destroy_function(const ENGINE *e)
{
  return (ENGINE_GEN_INT_FUNC_PTR)*((void *)e + 14);
}

ENGINE_GEN_INT_FUNC_PTR ENGINE_get_init_function(const ENGINE *e)
{
  return (ENGINE_GEN_INT_FUNC_PTR)*((void *)e + 15);
}

ENGINE_GEN_INT_FUNC_PTR ENGINE_get_finish_function(const ENGINE *e)
{
  return (ENGINE_GEN_INT_FUNC_PTR)*((void *)e + 16);
}

ENGINE_CTRL_FUNC_PTR ENGINE_get_ctrl_function(const ENGINE *e)
{
  return (ENGINE_CTRL_FUNC_PTR)*((void *)e + 17);
}

int ENGINE_get_flags(const ENGINE *e)
{
  return *((_DWORD *)e + 44);
}

const ENGINE_CMD_DEFN *__cdecl ENGINE_get_cmd_defns(const ENGINE *e)
{
  return (const ENGINE_CMD_DEFN *)*((void *)e + 21);
}

void *ENGINE_get_static_state(void)
{
  return &internal_static_hack;
}

ASN1_VALUE *d2i_GOST_KEY_TRANSPORT(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &GOST_KEY_TRANSPORT_it);
}

uint64_t i2d_GOST_KEY_TRANSPORT(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &GOST_KEY_TRANSPORT_it);
}

ASN1_VALUE *GOST_KEY_TRANSPORT_new()
{
  return ASN1_item_new(&GOST_KEY_TRANSPORT_it);
}

void GOST_KEY_TRANSPORT_free(ASN1_VALUE *a1)
{
}

ASN1_VALUE *d2i_GOST_KEY_INFO(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &GOST_KEY_INFO_it);
}

uint64_t i2d_GOST_KEY_INFO(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &GOST_KEY_INFO_it);
}

ASN1_VALUE *GOST_KEY_INFO_new()
{
  return ASN1_item_new(&GOST_KEY_INFO_it);
}

void GOST_KEY_INFO_free(ASN1_VALUE *a1)
{
}

ASN1_VALUE *d2i_GOST_KEY_AGREEMENT_INFO(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &GOST_KEY_AGREEMENT_INFO_it);
}

uint64_t i2d_GOST_KEY_AGREEMENT_INFO(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &GOST_KEY_AGREEMENT_INFO_it);
}

ASN1_VALUE *GOST_KEY_AGREEMENT_INFO_new()
{
  return ASN1_item_new(&GOST_KEY_AGREEMENT_INFO_it);
}

void GOST_KEY_AGREEMENT_INFO_free(ASN1_VALUE *a1)
{
}

ASN1_VALUE *d2i_GOST_KEY_PARAMS(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &GOST_KEY_PARAMS_it);
}

uint64_t i2d_GOST_KEY_PARAMS(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &GOST_KEY_PARAMS_it);
}

ASN1_VALUE *GOST_KEY_PARAMS_new()
{
  return ASN1_item_new(&GOST_KEY_PARAMS_it);
}

void GOST_KEY_PARAMS_free(ASN1_VALUE *a1)
{
}

ASN1_VALUE *d2i_GOST_CIPHER_PARAMS(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &GOST_CIPHER_PARAMS_it);
}

uint64_t i2d_GOST_CIPHER_PARAMS(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &GOST_CIPHER_PARAMS_it);
}

ASN1_VALUE *GOST_CIPHER_PARAMS_new()
{
  return ASN1_item_new(&GOST_CIPHER_PARAMS_it);
}

void GOST_CIPHER_PARAMS_free(ASN1_VALUE *a1)
{
}

void ERR_load_BUF_strings(void)
{
  if (!ERR_func_error_string(BUF_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&BUF_str_functs);
    ERR_load_strings(0, &BUF_str_reasons);
  }
}

unsigned __int8 *__cdecl PKCS12_pbe_crypt(X509_ALGOR *algor, const char *pass, int passlen, unsigned __int8 *in, int inlen, unsigned __int8 **data, int *datalen, int en_de)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  int outl = 0;
  memset(&a, 0, sizeof(a));
  EVP_CIPHER_CTX_init(&a);
  if (!EVP_PBE_CipherInit(algor->algorithm, pass, passlen, algor->parameter, &a, en_de))
  {
    int v19 = 115;
    int v20 = 85;
LABEL_13:
    ERR_put_error(35, 4095, v19, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs12/p12_decr.c", v20);
    int v17 = 0;
    goto LABEL_14;
  }
  int v16 = EVP_CIPHER_CTX_block_size(&a);
  int v17 = malloc_type_malloc(v16 + inlen, 0xEDB6E310uLL);
  if (!v17)
  {
    ERR_put_error(35, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs12/p12_decr.c", 90);
    goto LABEL_14;
  }
  if (!EVP_CipherUpdate(&a, (unsigned __int8 *)v17, &outl, in, inlen))
  {
    free(v17);
    int v19 = 6;
    int v20 = 97;
    goto LABEL_13;
  }
  int v18 = outl;
  if (!EVP_CipherFinal_ex(&a, (unsigned __int8 *)v17 + outl, &outl))
  {
    free(v17);
    int v19 = 116;
    int v20 = 105;
    goto LABEL_13;
  }
  if (datalen) {
    *dataint len = outl + v18;
  }
  if (data) {
    ASN1_STRING *data = (unsigned __int8 *)v17;
  }
LABEL_14:
  EVP_CIPHER_CTX_cleanup(&a);
  return (unsigned __int8 *)v17;
}

void *__cdecl PKCS12_item_decrypt_d2i(X509_ALGOR *algor, const ASN1_ITEM *it, const char *pass, int passlen, ASN1_OCTET_STRING *oct, int zbuf)
{
  uint64_t data = 0;
  dataint len = 0;
  if (PKCS12_pbe_crypt(algor, pass, passlen, oct->data, oct->length, &data, &datalen, 0))
  {
    unsigned __int8 in = data;
    uint64_t v8 = ASN1_item_d2i(0, (const unsigned __int8 **)&in, datalen, it);
    if (zbuf) {
      explicit_bzero(data, datalen);
    }
    if (!v8) {
      ERR_put_error(35, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs12/p12_decr.c", 144);
    }
    free(data);
  }
  else
  {
    ERR_put_error(35, 4095, 117, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs12/p12_decr.c", 136);
    return 0;
  }
  return v8;
}

ASN1_OCTET_STRING *__cdecl PKCS12_item_i2d_encrypt(X509_ALGOR *algor, const ASN1_ITEM *it, const char *pass, int passlen, void *obj, int zbuf)
{
  unsigned __int8 out = 0;
  uint64_t v12 = ASN1_OCTET_STRING_new();
  if (!v12)
  {
    ERR_put_error(35, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs12/p12_decr.c", 164);
    return v12;
  }
  int v13 = ASN1_item_i2d((ASN1_VALUE *)obj, &out, it);
  if (!out)
  {
    int v15 = 102;
    int v16 = 169;
LABEL_10:
    ERR_put_error(35, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs12/p12_decr.c", v16);
    free(out);
    ASN1_OCTET_STRING_free(v12);
    return 0;
  }
  int v14 = v13;
  if (!PKCS12_pbe_crypt(algor, pass, passlen, out, v13, &v12->data, &v12->length, 1))
  {
    int v15 = 103;
    int v16 = 174;
    goto LABEL_10;
  }
  if (zbuf) {
    explicit_bzero(out, v14);
  }
  free(out);
  return v12;
}

void ENGINE_unregister_DSA(ENGINE *e)
{
}

int ENGINE_register_DSA(ENGINE *e)
{
  if (*((void *)e + 3)) {
    return engine_table_register(&dsa_table, (uint64_t)engine_unregister_all_DSA, (char *)e, dummy_nid_3, 1, 0);
  }
  else {
    return 1;
  }
}

void engine_unregister_all_DSA()
{
}

void ENGINE_register_all_DSA(void)
{
  first = ENGINE_get_first();
  if (first)
  {
    next = first;
    do
    {
      if (*((void *)next + 3)) {
        engine_table_register(&dsa_table, (uint64_t)engine_unregister_all_DSA, (char *)next, dummy_nid_3, 1, 0);
      }
      next = ENGINE_get_next(next);
    }
    while (next);
  }
}

int ENGINE_set_default_DSA(ENGINE *e)
{
  if (*((void *)e + 3)) {
    return engine_table_register(&dsa_table, (uint64_t)engine_unregister_all_DSA, (char *)e, dummy_nid_3, 1, 1);
  }
  else {
    return 1;
  }
}

ENGINE *ENGINE_get_default_DSA(void)
{
  return (ENGINE *)engine_table_select(&dsa_table, 1);
}

const DSA_METHOD *__cdecl ENGINE_get_DSA(const ENGINE *e)
{
  return (const DSA_METHOD *)*((void *)e + 3);
}

int ENGINE_set_DSA(ENGINE *e, const DSA_METHOD *dsa_meth)
{
  *((void *)e + 3) = dsa_meth;
  return 1;
}

EVP_PKEY *__cdecl d2i_PrivateKey(int type, EVP_PKEY **a, const unsigned __int8 **pp, uint64_t length)
{
  uint64_t v8 = *pp;
  if (a && (uint64_t v9 = *a) != 0)
  {
    ENGINE_finish(*(ENGINE **)&v9->save_parameters);
    *(void *)&v9->save_parameterunsigned int s = 0;
  }
  else
  {
    uint64_t v9 = EVP_PKEY_new();
    if (!v9)
    {
      ERR_put_error(13, 4095, 6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_pkey.c", 85);
      return v9;
    }
  }
  if (!EVP_PKEY_set_type((uint64_t)v9, type))
  {
    int v14 = 163;
    int v15 = 97;
LABEL_17:
    ERR_put_error(13, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_pkey.c", v15);
    goto LABEL_18;
  }
  ptr = v9->pkey.ptr;
  uint64_t v11 = (unsigned int (*)(EVP_PKEY *, const unsigned __int8 **, uint64_t))*((void *)ptr + 23);
  if (v11)
  {
    if (v11(v9, pp, length)) {
      goto LABEL_12;
    }
    ptr = v9->pkey.ptr;
  }
  if (!*((void *)ptr + 8))
  {
    int v14 = 13;
    int v15 = 113;
    goto LABEL_17;
  }
  *punsigned int p = v8;
  uint64_t v12 = d2i_PKCS8_PRIV_KEY_INFO(0, pp, length);
  if (v12)
  {
    int v13 = v12;
    EVP_PKEY_free(v9);
    uint64_t v9 = EVP_PKCS82PKEY(v13);
    PKCS8_PRIV_KEY_INFO_free(v13);
LABEL_12:
    if (a) {
      BIGNUM *a = v9;
    }
    return v9;
  }
LABEL_18:
  if (!a || *a != v9) {
    EVP_PKEY_free(v9);
  }
  return 0;
}

int i2d_PrivateKey(EVP_PKEY *a, unsigned __int8 **pp)
{
  ptr = a->pkey.ptr;
  if (!ptr)
  {
LABEL_8:
    ERR_put_error(13, 4095, 167, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_pkey.c", 139);
    return -1;
  }
  int v4 = (uint64_t (*)(void))*((void *)ptr + 24);
  if (!v4)
  {
    if (*((void *)ptr + 9))
    {
      size_t v6 = EVP_PKEY2PKCS8(a);
      int v7 = i2d_PKCS8_PRIV_KEY_INFO(v6, pp);
      PKCS8_PRIV_KEY_INFO_free(v6);
      return v7;
    }
    goto LABEL_8;
  }
  return v4();
}

EVP_PKEY *__cdecl d2i_AutoPrivateKey(EVP_PKEY **a, const unsigned __int8 **pp, uint64_t length)
{
  uint64_t v11 = *pp;
  size_t v6 = (STACK *)d2i_ASN1_SEQUENCE_ANY(0, &v11, length);
  if (sk_num(v6) == 6)
  {
    int v7 = 116;
LABEL_10:
    sk_pop_free(v6, (void (__cdecl *)(void *))ASN1_TYPE_free);
    return d2i_PrivateKey(v7, a, pp, length);
  }
  if (sk_num(v6) == 4)
  {
    int v7 = 408;
    goto LABEL_10;
  }
  if (sk_num(v6) != 3)
  {
    int v7 = 6;
    goto LABEL_10;
  }
  uint64_t v8 = d2i_PKCS8_PRIV_KEY_INFO(0, pp, length);
  sk_pop_free(v6, (void (__cdecl *)(void *))ASN1_TYPE_free);
  if (v8)
  {
    uint64_t v9 = EVP_PKCS82PKEY(v8);
    PKCS8_PRIV_KEY_INFO_free(v8);
    if (a) {
      BIGNUM *a = v9;
    }
  }
  else
  {
    ERR_put_error(13, 4095, 167, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_pkey.c", 173);
    return 0;
  }
  return v9;
}

uint64_t Camellia_cfb128_encrypt(uint64_t a1, unsigned char *a2, unint64_t a3, uint64_t a4, uint64_t a5, unsigned int *a6, int a7)
{
  return CRYPTO_cfb128_encrypt(a1, a2, a3, a4, a5, a6, a7, (uint64_t (*)(uint64_t, uint64_t, uint64_t))Camellia_encrypt);
}

double Camellia_cfb1_encrypt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  *(void *)&double result = CRYPTO_cfb128_1_encrypt(a1, a2, a3, a4, a5, a6, a7, (void (*)(uint64_t, uint64_t, uint64_t))Camellia_encrypt).u64[0];
  return result;
}

uint64_t Camellia_cfb8_encrypt(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4, long long *a5, uint64_t a6, int a7)
{
  return CRYPTO_cfb128_8_encrypt(a1, a2, a3, a4, a5, a6, a7, (uint64_t (*)(long long *, long long *, uint64_t))Camellia_encrypt);
}

int CRYPTO_num_locks(void)
{
  return 1;
}

unint64_t (*CRYPTO_get_id_callback(void))(void)
{
  return 0;
}

void CRYPTO_set_locking_callback(void (__cdecl *func)(int, int, const char *, int))
{
  locking_int callback = (uint64_t)func;
}

void (__cdecl *CRYPTO_get_locking_callback(void))(int, int, const char *, int)
{
  return (void (__cdecl *)(int, int, const char *, int))locking_callback;
}

void CRYPTO_set_add_lock_callback(int (__cdecl *func)(int *, int, int, const char *, int))
{
  add_lock_int callback = (uint64_t)func;
}

int (__cdecl *CRYPTO_get_add_lock_callback(void))(int *, int, int, const char *, int)
{
  return (int (__cdecl *)(int *, int, int, const char *, int))add_lock_callback;
}

const char *__cdecl CRYPTO_get_lock_name(int type)
{
  return "";
}

CRYPTO_dynlock_value *__cdecl CRYPTO_get_dynlock_value(int i)
{
  return 0;
}

int CRYPTO_get_new_dynlockid(void)
{
  return 0;
}

int CRYPTO_get_new_lockid(char *name)
{
  return 0;
}

uint64_t CRYPTO_THREADID_set_callback()
{
  return 1;
}

uint64_t CRYPTO_THREADID_get_callback()
{
  return 0;
}

CRYPTO_dynlock_value *(__cdecl *CRYPTO_get_dynlock_create_callback(void))(const char *, int)
{
  return 0;
}

void (__cdecl *CRYPTO_get_dynlock_lock_callback(void))(int, CRYPTO_dynlock_value *, const char *, int)
{
  return 0;
}

void (__cdecl *CRYPTO_get_dynlock_destroy_callback(void))(CRYPTO_dynlock_value *, const char *, int)
{
  return 0;
}

pthread_t CRYPTO_THREADID_current(void *a1)
{
  *a1 = 0;
  a1[1] = 0;
  pthread_t result = pthread_self();
  a1[1] = result;
  return result;
}

uint64_t CRYPTO_THREADID_cmp(unint64_t *a1, unint64_t *a2)
{
  unint64_t v2 = bswap64(*a1);
  unint64_t v3 = bswap64(*a2);
  if (v2 == v3)
  {
    unint64_t v2 = bswap64(a1[1]);
    unint64_t v3 = bswap64(a2[1]);
    if (v2 == v3) {
      return 0;
    }
  }
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  return 1;
}

__n128 CRYPTO_THREADID_cpy(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  *a1 = *a2;
  return result;
}

uint64_t CRYPTO_THREADID_hash(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t OPENSSL_cpu_caps()
{
  return 0;
}

void OpenSSLDie(const char *file, int line, const char *assertion)
{
  char v3 = getuid();
  uint64_t v11 = getprogname();
  OPENSSL_showfatal((uint64_t)v11, v4, v5, v6, v7, v8, v9, v10, v3);
  _exit(1);
}

void OPENSSL_showfatal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  long long v9 = xmmword_23C713028;
  uint64_t v10 = 0xFF00000008;
  vsyslog_r(150, (int)&v9, "uid %u cmd %s %s(%d): OpenSSL internal error, assertion failed: %s\n", &a9);
}

uint64_t CRYPTO_memcmp(char *a1, char *a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  unsigned __int8 v3 = 0;
  do
  {
    char v5 = *a1++;
    char v4 = v5;
    char v6 = *a2++;
    v3 |= v6 ^ v4;
    --a3;
  }
  while (a3);
  return v3;
}

int AES_set_encrypt_key(const unsigned __int8 *userKey, const int bits, AES_KEY *key)
{
  int v3 = -1;
  if (userKey && key)
  {
    if (bits == 128 || bits == 256 || bits == 192)
    {
      if (bits == 128)
      {
        int v4 = 10;
      }
      else if (bits == 192)
      {
        int v4 = 12;
      }
      else
      {
        int v4 = 14;
      }
      key->roundunsigned int s = v4;
      unsigned int v5 = bswap32(*(_DWORD *)userKey);
      key->rd_key[0] = v5;
      unsigned int v6 = bswap32(*((_DWORD *)userKey + 1));
      key->rd_key[1] = v6;
      unsigned int v7 = bswap32(*((_DWORD *)userKey + 2));
      key->rd_key[2] = v7;
      unsigned int v8 = bswap32(*((_DWORD *)userKey + 3));
      key->rd_key[3] = v8;
      if (bits == 128)
      {
        uint64_t v9 = 0;
        uint64_t v10 = &key->rd_key[4];
        do
        {
          unint64_t v11 = *(v10 - 1);
          v5 ^= (Te2[4 * BYTE2(v11) + 3] << 24) ^ (Te3[4 * BYTE1(v11) + 2] << 16) ^ (Te0[4 * v11 + 1] << 8) ^ Te1[(v11 >> 22) & 0x3FC] ^ rcon[v9];
          int v12 = *(v10 - 2);
          int v13 = *(v10 - 3) ^ v5;
          *uint64_t v10 = v5;
          v10[1] = v13;
          int v14 = v12 ^ v13;
          _OWORD v10[2] = v14;
          _OWORD v10[3] = v14 ^ v11;
          ++v9;
          v10 += 4;
        }
        while (v9 != 10);
      }
      else
      {
        key->rd_key[4] = bswap32(*((_DWORD *)userKey + 4));
        unsigned int v16 = bswap32(*((_DWORD *)userKey + 5));
        key->rd_key[5] = v16;
        if (bits == 192)
        {
          uint64_t v17 = 0;
          for (int i = &key->rd_key[11]; ; i += 6)
          {
            v5 ^= (Te2[4 * BYTE2(v16) + 3] << 24) ^ (Te3[4 * BYTE1(v16) + 2] << 16) ^ (Te0[4 * v16 + 1] << 8) ^ Te1[4 * HIBYTE(v16)] ^ rcon[v17];
            v6 ^= v5;
            *(i - 5) = v5;
            *(i - 4) = v6;
            v7 ^= v6;
            v8 ^= v7;
            *(i - 3) = v7;
            *(i - 2) = v8;
            if (v17 == 7) {
              break;
            }
            int v19 = *(i - 7) ^ v8;
            v16 ^= v19;
            *(i - engine_free_util((CRYPTO_EX_DATA *)e, 1) = v19;
            unsigned int *i = v16;
            ++v17;
          }
        }
        else
        {
          key->rd_key[6] = bswap32(*((_DWORD *)userKey + 6));
          unsigned int v20 = bswap32(*((_DWORD *)userKey + 7));
          key->rd_key[7] = v20;
          uint64_t v21 = 0;
          for (uint64_t j = &key->rd_key[8]; ; j += 8)
          {
            v5 ^= (Te2[4 * BYTE2(v20) + 3] << 24) ^ (Te3[4 * BYTE1(v20) + 2] << 16) ^ (Te0[4 * v20 + 1] << 8) ^ Te1[4 * HIBYTE(v20)] ^ rcon[v21];
            v6 ^= v5;
            *uint64_t j = v5;
            j[1] = v6;
            v7 ^= v6;
            v8 ^= v7;
            j[2] = v7;
            j[3] = v8;
            if (v21 == 6) {
              break;
            }
            int v23 = *(j - 4) ^ (Te2[4 * HIBYTE(v8) + 3] << 24) ^ (Te3[4 * BYTE2(v8) + 2] << 16) ^ (Te0[4 * BYTE1(v8) + 1] << 8) ^ Te1[4 * v8];
            int v24 = *(j - 3) ^ v23;
            j[4] = v23;
            j[5] = v24;
            int v25 = *(j - 2) ^ v24;
            v20 ^= v25;
            j[6] = v25;
            j[7] = v20;
            ++v21;
          }
        }
      }
      return 0;
    }
    else
    {
      return -2;
    }
  }
  return v3;
}

int AES_set_decrypt_key(const unsigned __int8 *userKey, const int bits, AES_KEY *key)
{
  int result = AES_set_encrypt_key(userKey, bits, key);
  if ((result & 0x80000000) == 0)
  {
    roundunsigned int s = key->rounds;
    if (rounds >= 1)
    {
      uint64_t v6 = 0;
      int v7 = 4 * rounds;
      uint64_t v8 = 4 * rounds - 4;
      uint64_t v9 = &key->rd_key[2];
      uint64_t v10 = &key->rd_key[v7 + 2];
      do
      {
        unsigned int v11 = *(v9 - 2);
        *(v9 - 2) = *(v10 - 2);
        *(v10 - 2) = v11;
        unsigned int v12 = *(v9 - 1);
        *(v9 - engine_free_util((CRYPTO_EX_DATA *)e, 1) = *(v10 - 1);
        *(v10 - engine_free_util((CRYPTO_EX_DATA *)e, 1) = v12;
        unsigned int v13 = *v9;
        unsigned int *v9 = *v10;
        *uint64_t v10 = v13;
        unsigned int v14 = v9[1];
        v9[1] = v10[1];
        v10[1] = v14;
        v6 += 4;
        v10 -= 4;
        v9 += 4;
        BOOL v15 = v6 < v8;
        v8 -= 4;
      }
      while (v15);
      if (key->rounds >= 2)
      {
        unsigned int v16 = &key->rd_key[7];
        int v17 = 1;
        do
        {
          unint64_t v18 = *(v16 - 3);
          unint64_t v19 = *(v16 - 2);
          *(v16 - 3) = Td1[Te1[4 * BYTE2(v18)]] ^ Td0[Te1[(v18 >> 22) & 0x3FC]] ^ Td2[Te1[4 * BYTE1(v18)]] ^ Td3[Te1[4 * *(v16 - 3)]];
          *(v16 - 2) = Td1[Te1[4 * BYTE2(v19)]] ^ Td0[Te1[(v19 >> 22) & 0x3FC]] ^ Td2[Te1[4 * BYTE1(v19)]] ^ Td3[Te1[4 * v19]];
          unint64_t v20 = *(v16 - 1);
          *(v16 - engine_free_util((CRYPTO_EX_DATA *)e, 1) = Td1[Te1[4 * BYTE2(v20)]] ^ Td0[Te1[(v20 >> 22) & 0x3FC]] ^ Td2[Te1[4 * BYTE1(v20)]] ^ Td3[Te1[4 * *(v16 - 1)]];
          unint64_t v21 = *v16;
          unsigned int *v16 = Td1[Te1[4 * BYTE2(v21)]] ^ Td0[Te1[(v21 >> 22) & 0x3FC]] ^ Td2[Te1[4 * BYTE1(v21)]] ^ Td3[Te1[4 * *v16]];
          v16 += 4;
          ++v17;
        }
        while (v17 < key->rounds);
      }
    }
    return 0;
  }
  return result;
}

void AES_encrypt(const unsigned __int8 *in, unsigned __int8 *out, const AES_KEY *key)
{
  unsigned int v3 = bswap32(*(_DWORD *)in) ^ key->rd_key[0];
  unsigned int v4 = bswap32(*((_DWORD *)in + 1)) ^ key->rd_key[1];
  unsigned int v5 = bswap32(*((_DWORD *)in + 2)) ^ key->rd_key[2];
  unsigned int v6 = bswap32(*((_DWORD *)in + 3)) ^ key->rd_key[3];
  int v7 = &key->rd_key[6];
  for (int i = (key->rounds >> 1) - 1; ; --i)
  {
    unsigned int v9 = *(_DWORD *)&Te1[4 * BYTE2(v4)] ^ *(_DWORD *)&Te0[4 * HIBYTE(v3)] ^ *(_DWORD *)&Te2[4 * BYTE1(v5)] ^ *(_DWORD *)&Te3[4 * v6] ^ *(v7 - 2);
    unsigned int v10 = *(_DWORD *)&Te1[4 * BYTE2(v5)] ^ *(_DWORD *)&Te0[4 * HIBYTE(v4)] ^ *(_DWORD *)&Te2[4 * BYTE1(v6)] ^ *(_DWORD *)&Te3[4 * v3] ^ *(v7 - 1);
    unsigned int v11 = *(_DWORD *)&Te1[4 * BYTE2(v6)] ^ *(_DWORD *)&Te0[4 * HIBYTE(v5)] ^ *(_DWORD *)&Te2[4 * BYTE1(v3)] ^ *(_DWORD *)&Te3[4 * v4] ^ *v7;
    unsigned int v12 = *(_DWORD *)&Te1[4 * BYTE2(v3)] ^ *(_DWORD *)&Te0[4 * HIBYTE(v6)] ^ *(_DWORD *)&Te2[4 * BYTE1(v4)] ^ *(_DWORD *)&Te3[4 * v5] ^ v7[1];
    unsigned int v13 = HIBYTE(v9);
    unsigned int v14 = HIBYTE(v10);
    int v15 = BYTE1(v12);
    unsigned int v16 = HIBYTE(v11);
    int v17 = BYTE2(v12);
    int v18 = BYTE1(v9);
    unsigned int v19 = HIBYTE(v12);
    int v20 = BYTE2(v9);
    if (!i) {
      break;
    }
    int v21 = *(_DWORD *)&Te1[4 * BYTE2(v10)] ^ *(_DWORD *)&Te0[4 * v13] ^ *(_DWORD *)&Te2[4 * BYTE1(v11)] ^ *(_DWORD *)&Te3[4 * v12];
    unsigned int v22 = v7[2];
    unsigned int v23 = v7[3];
    unsigned int v24 = v7[4];
    unsigned int v25 = v7[5];
    v7 += 8;
    unsigned int v3 = v21 ^ v22;
    unsigned int v4 = *(_DWORD *)&Te1[4 * BYTE2(v11)] ^ *(_DWORD *)&Te0[4 * v14] ^ *(_DWORD *)&Te2[4 * v15] ^ *(_DWORD *)&Te3[4 * v9] ^ v23;
    int v26 = *(_DWORD *)&Te0[4 * v19];
    int v27 = *(_DWORD *)&Te1[4 * v20];
    unsigned int v5 = *(_DWORD *)&Te1[4 * v17] ^ *(_DWORD *)&Te0[4 * v16] ^ *(_DWORD *)&Te2[4 * v18] ^ *(_DWORD *)&Te3[4 * v10] ^ v24;
    unsigned int v6 = v27 ^ v26 ^ *(_DWORD *)&Te2[4 * BYTE1(v10)] ^ *(_DWORD *)&Te3[4 * v11] ^ v25;
  }
  int v28 = &key->rd_key[8 * ((key->rounds >> 1) - 1)];
  *(_DWORD *)unsigned __int8 out = bswap32(((Te2[4 * v13 + 3] << 24) | (Te3[4 * BYTE2(v10) + 2] << 16) | (Te0[4 * BYTE1(v11) + 1] << 8) | Te1[4 * v12]) ^ v28[8]);
  *((_DWORD *)out + engine_free_util((CRYPTO_EX_DATA *)e, 1) = bswap32(((Te2[4 * v14 + 3] << 24) | (Te3[4 * BYTE2(v11) + 2] << 16) | (Te0[4 * BYTE1(v12) + 1] << 8) | Te1[4 * v9]) ^ v28[9]);
  *((_DWORD *)out + 2) = bswap32(((Te2[4 * v16 + 3] << 24) | (Te3[4 * BYTE2(v12) + 2] << 16) | (Te0[4 * BYTE1(v9) + 1] << 8) | Te1[4 * v10]) ^ v28[10]);
  *((_DWORD *)out + 3) = bswap32(((Te2[4 * v19 + 3] << 24) | (Te3[4 * BYTE2(v9) + 2] << 16) | (Te0[4 * BYTE1(v10) + 1] << 8) | Te1[4 * v11]) ^ v28[11]);
}

void AES_decrypt(const unsigned __int8 *in, unsigned __int8 *out, const AES_KEY *key)
{
  unsigned int v3 = bswap32(*(_DWORD *)in) ^ key->rd_key[0];
  unsigned int v4 = bswap32(*((_DWORD *)in + 1)) ^ key->rd_key[1];
  unsigned int v5 = bswap32(*((_DWORD *)in + 2)) ^ key->rd_key[2];
  unsigned int v6 = bswap32(*((_DWORD *)in + 3)) ^ key->rd_key[3];
  int v7 = &key->rd_key[6];
  for (int i = (key->rounds >> 1) - 1; ; --i)
  {
    unint64_t v9 = Td1[BYTE2(v6)] ^ Td0[HIBYTE(v3)] ^ Td2[BYTE1(v5)] ^ Td3[v4] ^ *(v7 - 2);
    unint64_t v10 = Td1[BYTE2(v3)] ^ Td0[HIBYTE(v4)] ^ Td2[BYTE1(v6)] ^ Td3[v5] ^ *(v7 - 1);
    unint64_t v11 = Td1[BYTE2(v4)] ^ Td0[HIBYTE(v5)] ^ Td2[BYTE1(v3)] ^ Td3[v6] ^ *v7;
    unint64_t v12 = Td1[BYTE2(v5)] ^ Td0[HIBYTE(v6)] ^ Td2[BYTE1(v4)] ^ Td3[v3] ^ v7[1];
    if (!i) {
      break;
    }
    unsigned int v3 = Td1[BYTE2(v12)] ^ Td0[BYTE3(v9)] ^ Td2[BYTE1(v11)] ^ Td3[v10] ^ v7[2];
    unsigned int v4 = Td1[BYTE2(v9)] ^ Td0[BYTE3(v10)] ^ Td2[BYTE1(v12)] ^ Td3[v11] ^ v7[3];
    unsigned int v13 = v7[4];
    unsigned int v14 = v7[5];
    v7 += 8;
    unsigned int v5 = Td1[BYTE2(v10)] ^ Td0[BYTE3(v11)] ^ Td2[BYTE1(v9)] ^ Td3[v12] ^ v13;
    unsigned int v6 = Td1[BYTE2(v11)] ^ Td0[BYTE3(v12)] ^ Td2[BYTE1(v10)] ^ Td3[v9] ^ v14;
  }
  int v15 = &key->rd_key[8 * ((key->rounds >> 1) - 1)];
  *(_DWORD *)unsigned __int8 out = bswap32(((Td4[v9 >> 24] << 24) | (Td4[BYTE2(v12)] << 16) | (Td4[BYTE1(v11)] << 8) | Td4[v10]) ^ v15[8]);
  *((_DWORD *)out + engine_free_util((CRYPTO_EX_DATA *)e, 1) = bswap32(((Td4[v10 >> 24] << 24) | (Td4[BYTE2(v9)] << 16) | (Td4[BYTE1(v12)] << 8) | Td4[v11]) ^ v15[9]);
  *((_DWORD *)out + 2) = bswap32(((Td4[v11 >> 24] << 24) | (Td4[BYTE2(v10)] << 16) | (Td4[BYTE1(v9)] << 8) | Td4[v12]) ^ v15[10]);
  *((_DWORD *)out + 3) = bswap32(((Td4[v12 >> 24] << 24) | (Td4[BYTE2(v11)] << 16) | (Td4[BYTE1(v10)] << 8) | Td4[v9]) ^ v15[11]);
}

char **RSA_PKCS1_OpenSSL()
{
  return &rsa_pkcs1_eay_meth;
}

const RSA_METHOD *RSA_PKCS1_SSLeay(void)
{
  return (const RSA_METHOD *)&rsa_pkcs1_eay_meth;
}

uint64_t RSA_eay_public_encrypt(int a1, const unsigned __int8 *a2, unsigned __int8 *a3, uint64_t a4, int a5)
{
  if (BN_num_bits(*(const BIGNUM **)(a4 + 32)) <= 0x4000)
  {
    if (BN_ucmp(*(const BIGNUM **)(a4 + 32), *(const BIGNUM **)(a4 + 40)) <= 0)
    {
      int v10 = 101;
      int v11 = 175;
      goto LABEL_19;
    }
    if (BN_num_bits(*(const BIGNUM **)(a4 + 32)) >= 3073 && BN_num_bits(*(const BIGNUM **)(a4 + 40)) >= 65)
    {
      int v10 = 101;
      int v11 = 182;
      goto LABEL_19;
    }
    unint64_t v12 = BN_CTX_new();
    if (!v12)
    {
      unsigned int v19 = 0;
      size_t v22 = 0;
      uint64_t v20 = 0xFFFFFFFFLL;
LABEL_25:
      freezero(v19, v22);
      return v20;
    }
    unsigned int v13 = v12;
    BN_CTX_start(v12);
    unsigned int v14 = BN_CTX_get(v13);
    int v15 = BN_CTX_get(v13);
    int v16 = BN_num_bits(*(const BIGNUM **)(a4 + 32));
    if (v16 >= -7) {
      int v17 = v16 + 7;
    }
    else {
      int v17 = v16 + 14;
    }
    size_t v29 = (uint64_t)v17 >> 3;
    int v18 = (unsigned __int8 *)malloc_type_malloc(v29, 0x416763EAuLL);
    unsigned int v19 = v18;
    if (v14 && v15 && v18)
    {
      uint64_t v20 = (v17 >> 3);
      switch(a5)
      {
        case 4:
          int v21 = RSA_padding_add_PKCS1_OAEP(v18, v20, a2, a1, 0, 0);
          break;
        case 3:
          int v21 = RSA_padding_add_none(v18, v20, a2, a1);
          break;
        case 1:
          int v21 = RSA_padding_add_PKCS1_type_2(v18, v20, a2, a1);
          break;
        default:
          int v23 = 118;
          int v24 = 214;
          goto LABEL_22;
      }
      if (v21 < 1 || !BN_bin2bn(v19, v20, v14)) {
        goto LABEL_23;
      }
      if (BN_ucmp(v14, *(const BIGNUM **)(a4 + 32)) < 0)
      {
        if (((*(unsigned char *)(a4 + 116) & 2) == 0
           || BN_MONT_CTX_set_locked((BN_MONT_CTX **)(a4 + 120), 9, *(const BIGNUM **)(a4 + 32), v13))
          && (*(unsigned int (**)(BIGNUM *, BIGNUM *, void, void, BN_CTX *, void))(*(void *)(a4 + 16)
                                                                                                  + 48))(v15, v14, *(void *)(a4 + 40), *(void *)(a4 + 32), v13, *(void *)(a4 + 120)))
        {
          int v26 = BN_num_bits(v15);
          int v27 = v26 + 7;
          if (v26 < -7) {
            int v27 = v26 + 14;
          }
          int v28 = BN_bn2bin(v15, &a3[(int)v20 - (v27 >> 3)]);
          if ((int)v20 > v28) {
            bzero(a3, (v20 + ~v28) + 1);
          }
          goto LABEL_24;
        }
LABEL_23:
        uint64_t v20 = 0xFFFFFFFFLL;
LABEL_24:
        size_t v22 = v29;
        BN_CTX_end(v13);
        BN_CTX_free(v13);
        goto LABEL_25;
      }
      int v23 = 132;
      int v24 = 225;
    }
    else
    {
      int v23 = 65;
      int v24 = 197;
    }
LABEL_22:
    ERR_put_error(4, 4095, v23, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_eay.c", v24);
    goto LABEL_23;
  }
  int v10 = 105;
  int v11 = 170;
LABEL_19:
  ERR_put_error(4, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_eay.c", v11);
  return 0xFFFFFFFFLL;
}

uint64_t RSA_eay_public_decrypt(int a1, const unsigned __int8 *a2, unsigned __int8 *a3, uint64_t a4, int a5)
{
  if (BN_num_bits(*(const BIGNUM **)(a4 + 32)) <= 0x4000)
  {
    if (BN_ucmp(*(const BIGNUM **)(a4 + 32), *(const BIGNUM **)(a4 + 40)) <= 0)
    {
      int v10 = 101;
      int v11 = 619;
      goto LABEL_16;
    }
    if (BN_num_bits(*(const BIGNUM **)(a4 + 32)) >= 3073 && BN_num_bits(*(const BIGNUM **)(a4 + 40)) >= 65)
    {
      int v10 = 101;
      int v11 = 626;
      goto LABEL_16;
    }
    unint64_t v12 = BN_CTX_new();
    if (!v12)
    {
      uint64_t v20 = 0;
      uint64_t v18 = 0;
      uint64_t v23 = 0xFFFFFFFFLL;
LABEL_22:
      freezero(v20, v18);
      return v23;
    }
    unsigned int v13 = v12;
    BN_CTX_start(v12);
    unsigned int v14 = BN_CTX_get(v13);
    int v15 = BN_CTX_get(v13);
    int v16 = BN_num_bits(*(const BIGNUM **)(a4 + 32));
    int v17 = v16 + 7;
    if (v16 < -7) {
      int v17 = v16 + 14;
    }
    uint64_t v18 = (uint64_t)v17 >> 3;
    unsigned int v19 = malloc_type_malloc(v18, 0xA03CDE1uLL);
    uint64_t v20 = v19;
    if (v14 && v15 && v19)
    {
      if ((int)v18 >= a1)
      {
        if (!BN_bin2bn(a2, a1, v14)) {
          goto LABEL_20;
        }
        if (BN_ucmp(v14, *(const BIGNUM **)(a4 + 32)) < 0)
        {
          if ((*(unsigned char *)(a4 + 116) & 2) != 0
            && !BN_MONT_CTX_set_locked((BN_MONT_CTX **)(a4 + 120), 9, *(const BIGNUM **)(a4 + 32), v13)
            || !(*(unsigned int (**)(BIGNUM *, BIGNUM *, void, void, BN_CTX *, void))(*(void *)(a4 + 16) + 48))(v15, v14, *(void *)(a4 + 40), *(void *)(a4 + 32), v13, *(void *)(a4 + 120)))
          {
            goto LABEL_20;
          }
          if (a5 == 5)
          {
            if ((*v15->d & 0xF) != 0xC && !BN_sub(v15, *(const BIGNUM **)(a4 + 32), v15)) {
              goto LABEL_20;
            }
            int v25 = BN_bn2bin(v15, (unsigned __int8 *)v20);
            uint64_t v26 = RSA_padding_check_X931(a3, v18, (const unsigned __int8 *)v20, v25, v18);
          }
          else
          {
            int v27 = BN_bn2bin(v15, (unsigned __int8 *)v20);
            if (a5 == 3)
            {
              uint64_t v26 = RSA_padding_check_none(a3, v18, (const unsigned __int8 *)v20, v27, v18);
            }
            else
            {
              if (a5 != 1)
              {
                int v21 = 118;
                int v22 = 688;
                goto LABEL_19;
              }
              uint64_t v26 = RSA_padding_check_PKCS1_type_1(a3, v18, (const unsigned __int8 *)v20, v27, v18);
            }
          }
          uint64_t v23 = v26;
          if ((v26 & 0x80000000) != 0) {
            ERR_put_error(4, 4095, 114, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_eay.c", 692);
          }
          goto LABEL_21;
        }
        int v21 = 132;
        int v22 = 656;
      }
      else
      {
        int v21 = 108;
        int v22 = 648;
      }
    }
    else
    {
      int v21 = 65;
      int v22 = 641;
    }
LABEL_19:
    ERR_put_error(4, 4095, v21, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_eay.c", v22);
LABEL_20:
    uint64_t v23 = 0xFFFFFFFFLL;
LABEL_21:
    BN_CTX_end(v13);
    BN_CTX_free(v13);
    goto LABEL_22;
  }
  int v10 = 105;
  int v11 = 614;
LABEL_16:
  ERR_put_error(4, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_eay.c", v11);
  return 0xFFFFFFFFLL;
}

uint64_t RSA_eay_private_encrypt(int a1, const unsigned __int8 *a2, unsigned __int8 *a3, RSA *a4, int a5)
{
  int v36 = 0;
  int v10 = BN_CTX_new();
  if (v10)
  {
    int v11 = v10;
    char v34 = a3;
    BN_CTX_start(v10);
    unint64_t v12 = BN_CTX_get(v11);
    unsigned int v13 = BN_CTX_get(v11);
    int v14 = BN_num_bits(a4->n);
    if (v14 >= -7) {
      int v15 = v14 + 7;
    }
    else {
      int v15 = v14 + 14;
    }
    size_t v16 = (uint64_t)v15 >> 3;
    int v17 = (unsigned __int8 *)malloc_type_malloc(v16, 0x6D86A53EuLL);
    uint64_t v18 = v17;
    if (v12 && v13 && v17)
    {
      uint64_t v19 = (v15 >> 3);
      switch(a5)
      {
        case 5:
          int v20 = RSA_padding_add_X931(v17, v19, a2, a1);
          break;
        case 3:
          int v20 = RSA_padding_add_none(v17, v19, a2, a1);
          break;
        case 1:
          int v20 = RSA_padding_add_PKCS1_type_1(v17, v19, a2, a1);
          break;
        default:
          int v21 = 118;
          int v22 = 392;
          goto LABEL_21;
      }
      if (v20 < 1 || !BN_bin2bn(v18, v19, v12)) {
        goto LABEL_22;
      }
      if (BN_ucmp(v12, a4->n) < 0)
      {
        int flags = a4->flags;
        if ((flags & 2) != 0)
        {
          if (!BN_MONT_CTX_set_locked(&a4->_method_mod_n, 9, a4->n, v11)) {
            goto LABEL_22;
          }
          int flags = a4->flags;
        }
        if ((flags & 0x80) != 0)
        {
          uint64_t v26 = 0;
          r = 0;
          LOBYTE(v28) = flags;
        }
        else
        {
          blinding = rsa_get_blinding(a4, &v36, v11);
          if (!blinding)
          {
            int v21 = 68;
            int v22 = 416;
            goto LABEL_21;
          }
          uint64_t v26 = blinding;
          if (v36)
          {
            int v27 = 0;
          }
          else
          {
            int v27 = BN_CTX_get(v11);
            if (!v27)
            {
              int v21 = 65;
              int v22 = 423;
              goto LABEL_21;
            }
          }
          r = v27;
          if (!rsa_blinding_convert(v26, v12, v27, v11)) {
            goto LABEL_22;
          }
          int v28 = a4->flags;
        }
        if ((v28 & 0x20) != 0 || a4->p && a4->q && a4->dmp1 && a4->dmq1 && a4->iqmp)
        {
          if (!((unsigned int (*)(BIGNUM *, BIGNUM *, RSA *, BN_CTX *))a4->meth->rsa_mod_exp)(v13, v12, a4, v11))goto LABEL_22; {
        }
          }
        else
        {
          memset(&v35, 0, sizeof(v35));
          BN_init(&v35);
          __n128 v29 = BN_with_flags((__n128 *)&v35, (__n128 *)a4->d, 4);
          if (!((unsigned int (*)(BIGNUM *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *, BN_MONT_CTX *, __n128))a4->meth->bn_mod_exp)(v13, v12, &v35, a4->n, v11, a4->_method_mod_n, v29))goto LABEL_22; {
        }
          }
        if ((flags & 0x80) == 0 && !BN_BLINDING_invert_ex(v13, r, v26, v11)) {
          goto LABEL_22;
        }
        if (a5 == 5)
        {
          if (!BN_sub(v12, a4->n, v13)) {
            goto LABEL_22;
          }
          if (BN_cmp(v13, v12) > 0) {
            unsigned int v13 = v12;
          }
        }
        int v30 = BN_num_bits(v13);
        int v31 = v30 + 7;
        if (v30 < -7) {
          int v31 = v30 + 14;
        }
        int v32 = BN_bn2bin(v13, &v34[(int)v19 - (v31 >> 3)]);
        if ((int)v19 > v32) {
          bzero(v34, (v19 + ~v32) + 1);
        }
        goto LABEL_23;
      }
      int v21 = 132;
      int v22 = 403;
    }
    else
    {
      int v21 = 65;
      int v22 = 377;
    }
LABEL_21:
    ERR_put_error(4, 4095, v21, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_eay.c", v22);
LABEL_22:
    uint64_t v19 = 0xFFFFFFFFLL;
LABEL_23:
    BN_CTX_end(v11);
    BN_CTX_free(v11);
    goto LABEL_24;
  }
  uint64_t v18 = 0;
  size_t v16 = 0;
  uint64_t v19 = 0xFFFFFFFFLL;
LABEL_24:
  freezero(v18, v16);
  return v19;
}

uint64_t RSA_eay_private_decrypt(int a1, const unsigned __int8 *a2, unsigned __int8 *a3, RSA *a4, int a5)
{
  int v33 = 0;
  int v10 = BN_CTX_new();
  if (v10)
  {
    int v11 = v10;
    BN_CTX_start(v10);
    unint64_t v12 = BN_CTX_get(v11);
    unsigned int v13 = BN_CTX_get(v11);
    int v14 = BN_num_bits(a4->n);
    int v15 = v14 + 7;
    if (v14 < -7) {
      int v15 = v14 + 14;
    }
    uint64_t v16 = (uint64_t)v15 >> 3;
    int v17 = (unsigned __int8 *)malloc_type_malloc(v16, 0x82DCF202uLL);
    uint64_t v18 = v17;
    if (v12 && v13 && v17)
    {
      if ((int)v16 >= a1)
      {
        if (!BN_bin2bn(a2, a1, v12)) {
          goto LABEL_12;
        }
        if (BN_ucmp(v12, a4->n) < 0)
        {
          int flags = a4->flags;
          if ((flags & 2) != 0)
          {
            if (!BN_MONT_CTX_set_locked(&a4->_method_mod_n, 9, a4->n, v11)) {
              goto LABEL_12;
            }
            int flags = a4->flags;
          }
          if ((flags & 0x80) != 0)
          {
            int v25 = 0;
            r = 0;
            LOBYTE(v27) = flags;
          }
          else
          {
            blinding = rsa_get_blinding(a4, &v33, v11);
            if (!blinding)
            {
              int v19 = 68;
              int v20 = 535;
              goto LABEL_11;
            }
            int v25 = blinding;
            if (v33)
            {
              uint64_t v26 = 0;
            }
            else
            {
              uint64_t v26 = BN_CTX_get(v11);
              if (!v26)
              {
                int v19 = 65;
                int v20 = 542;
                goto LABEL_11;
              }
            }
            r = v26;
            if (!rsa_blinding_convert(v25, v12, v26, v11)) {
              goto LABEL_12;
            }
            int v27 = a4->flags;
          }
          if ((v27 & 0x20) != 0 || a4->p && a4->q && a4->dmp1 && a4->dmq1 && a4->iqmp)
          {
            if (!((unsigned int (*)(BIGNUM *, BIGNUM *, RSA *, BN_CTX *))a4->meth->rsa_mod_exp)(v13, v12, a4, v11))goto LABEL_12; {
          }
            }
          else
          {
            memset(&v32, 0, sizeof(v32));
            BN_init(&v32);
            __n128 v28 = BN_with_flags((__n128 *)&v32, (__n128 *)a4->d, 4);
            if (!((unsigned int (*)(BIGNUM *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *, BN_MONT_CTX *, __n128))a4->meth->bn_mod_exp)(v13, v12, &v32, a4->n, v11, a4->_method_mod_n, v28))goto LABEL_12; {
          }
            }
          if ((flags & 0x80) == 0 && !BN_BLINDING_invert_ex(v13, r, v25, v11)) {
            goto LABEL_12;
          }
          int v29 = BN_bn2bin(v13, v18);
          switch(a5)
          {
            case 4:
              uint64_t v30 = RSA_padding_check_PKCS1_OAEP(a3, v16, v18, v29, v16, 0, 0);
              break;
            case 3:
              uint64_t v30 = RSA_padding_check_none(a3, v16, v18, v29, v16);
              break;
            case 1:
              uint64_t v30 = RSA_padding_check_PKCS1_type_2(a3, v16, v18, v29, v16);
              break;
            default:
              int v19 = 118;
              int v20 = 587;
              goto LABEL_11;
          }
          uint64_t v21 = v30;
          if ((v30 & 0x80000000) != 0) {
            ERR_put_error(4, 4095, 114, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_eay.c", 591);
          }
          goto LABEL_13;
        }
        int v19 = 132;
        int v20 = 522;
      }
      else
      {
        int v19 = 108;
        int v20 = 513;
      }
    }
    else
    {
      int v19 = 65;
      int v20 = 506;
    }
LABEL_11:
    ERR_put_error(4, 4095, v19, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_eay.c", v20);
LABEL_12:
    uint64_t v21 = 0xFFFFFFFFLL;
LABEL_13:
    BN_CTX_end(v11);
    BN_CTX_free(v11);
    goto LABEL_14;
  }
  uint64_t v18 = 0;
  uint64_t v16 = 0;
  uint64_t v21 = 0xFFFFFFFFLL;
LABEL_14:
  freezero(v18, v16);
  return v21;
}

uint64_t RSA_eay_mod_exp(BIGNUM *a1, __n128 *a2, uint64_t a3, BN_CTX *ctx)
{
  memset(&v23, 0, sizeof(v23));
  memset(&v22, 0, sizeof(v22));
  memset(&v21, 0, sizeof(v21));
  memset(&v20, 0, sizeof(v20));
  BN_CTX_start(ctx);
  uint64_t v8 = BN_CTX_get(ctx);
  unint64_t v9 = BN_CTX_get(ctx);
  int v10 = BN_CTX_get(ctx);
  if (!v8 || !v9 || (int v11 = v10) == 0)
  {
    ERR_put_error(4, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_eay.c", 715);
    goto LABEL_34;
  }
  memset(&mod, 0, sizeof(mod));
  memset(&v18, 0, sizeof(v18));
  BN_init(&mod);
  BN_init(&v18);
  BN_with_flags((__n128 *)&mod, *(__n128 **)(a3 + 56), 4);
  BN_with_flags((__n128 *)&v18, *(__n128 **)(a3 + 64), 4);
  int v12 = *(_DWORD *)(a3 + 116);
  if ((v12 & 4) == 0) {
    goto LABEL_8;
  }
  if (!BN_MONT_CTX_set_locked((BN_MONT_CTX **)(a3 + 128), 9, &mod, ctx)
    || !BN_MONT_CTX_set_locked((BN_MONT_CTX **)(a3 + 136), 9, &v18, ctx))
  {
LABEL_34:
    uint64_t v16 = 0;
    goto LABEL_35;
  }
  int v12 = *(_DWORD *)(a3 + 116);
LABEL_8:
  if ((v12 & 2) != 0 && !BN_MONT_CTX_set_locked((BN_MONT_CTX **)(a3 + 120), 9, *(const BIGNUM **)(a3 + 32), ctx)) {
    goto LABEL_34;
  }
  BN_init(&v21);
  BN_with_flags((__n128 *)&v21, a2, 4);
  if (!BN_mod_ct(v8, &v21, *(const BIGNUM **)(a3 + 64), ctx)) {
    goto LABEL_34;
  }
  BN_init(&v22);
  __n128 v13 = BN_with_flags((__n128 *)&v22, (__n128 *)*(void *)(a3 + 80), 4);
  if (!(*(unsigned int (**)(BIGNUM *, BIGNUM *, BIGNUM *, void, BN_CTX *, void, __n128))(*(void *)(a3 + 16) + 48))(v9, v8, &v22, *(void *)(a3 + 64), ctx, *(void *)(a3 + 136), v13))goto LABEL_34; {
  BN_init(&v21);
  }
  BN_with_flags((__n128 *)&v21, a2, 4);
  if (!BN_mod_ct(v8, &v21, *(const BIGNUM **)(a3 + 56), ctx)) {
    goto LABEL_34;
  }
  BN_init(&v23);
  __n128 v14 = BN_with_flags((__n128 *)&v23, (__n128 *)*(void *)(a3 + 72), 4);
  if (!(*(unsigned int (**)(BIGNUM *, BIGNUM *, BIGNUM *, void, BN_CTX *, void, __n128))(*(void *)(a3 + 16) + 48))(a1, v8, &v23, *(void *)(a3 + 56), ctx, *(void *)(a3 + 128), v14)|| !BN_sub(a1, a1, v9)|| BN_is_negative((uint64_t)a1) && !BN_add(a1, a1, *(const BIGNUM **)(a3 + 56)))
  {
    goto LABEL_34;
  }
  if (!BN_mul(v8, a1, *(const BIGNUM **)(a3 + 88), ctx)) {
    goto LABEL_34;
  }
  BN_init(&v20);
  BN_with_flags((__n128 *)&v20, (__n128 *)v8, 4);
  if (!BN_mod_ct(a1, &v20, *(const BIGNUM **)(a3 + 56), ctx)
    || BN_is_negative((uint64_t)a1) && !BN_add(a1, a1, *(const BIGNUM **)(a3 + 56)))
  {
    goto LABEL_34;
  }
  if (!BN_mul(v8, a1, *(const BIGNUM **)(a3 + 64), ctx) || !BN_add(a1, v8, v9)) {
    goto LABEL_34;
  }
  if (*(void *)(a3 + 40) && *(void *)(a3 + 32))
  {
    if (!(*(unsigned int (**)(BIGNUM *, BIGNUM *))(*(void *)(a3 + 16) + 48))(v11, a1)
      || !BN_sub(v11, v11, (const BIGNUM *)a2)
      || !BN_mod_ct(v11, v11, *(const BIGNUM **)(a3 + 32), ctx)
      || BN_is_negative((uint64_t)v11) && !BN_add(v11, v11, *(const BIGNUM **)(a3 + 32)))
    {
      goto LABEL_34;
    }
    if (!BN_is_zero((uint64_t)v11))
    {
      memset(&mod, 0, sizeof(mod));
      BN_init(&mod);
      __n128 v15 = BN_with_flags((__n128 *)&mod, (__n128 *)*(void *)(a3 + 48), 4);
      if (!(*(unsigned int (**)(BIGNUM *, __n128 *, BIGNUM *, void, BN_CTX *, void, __n128))(*(void *)(a3 + 16) + 48))(a1, a2, &mod, *(void *)(a3 + 32), ctx, *(void *)(a3 + 120), v15))goto LABEL_34; {
    }
      }
  }
  uint64_t v16 = 1;
LABEL_35:
  BN_CTX_end(ctx);
  return v16;
}

uint64_t RSA_eay_init(uint64_t a1)
{
  *(_DWORD *)(a1 + 116) |= 6u;
  return 1;
}

uint64_t RSA_eay_finish(BN_MONT_CTX **a1)
{
  return 1;
}

BN_BLINDING *rsa_get_blinding(RSA *a1, _DWORD *a2, BN_CTX *a3)
{
  v11[0] = 0;
  v11[1] = 0;
  CRYPTO_lock(5, 9, 0, 0);
  bignum_uint64_t data = a1->bignum_data;
  blinding = (BN_BLINDING *)bignum_data;
  if (!bignum_data)
  {
    CRYPTO_lock(6, 9, 0, 0);
    CRYPTO_lock(9, 9, 0, 0);
    blinding = (BN_BLINDING *)a1->bignum_data;
    if (!blinding)
    {
      blinding = RSA_setup_blinding(a1, a3);
      a1->bignum_uint64_t data = (char *)blinding;
      if (!blinding)
      {
LABEL_9:
        int v9 = 10;
        goto LABEL_14;
      }
    }
  }
  CRYPTO_THREADID_current(v11);
  uint64_t v8 = (unint64_t *)BN_BLINDING_thread_id((uint64_t)blinding);
  if (CRYPTO_THREADID_cmp(v11, v8))
  {
    *a2 = 0;
    blinding = a1->blinding;
    if (!blinding)
    {
      if (!bignum_data || (CRYPTO_lock(6, 9, 0, 0), CRYPTO_lock(9, 9, 0, 0), (blinding = a1->blinding) == 0))
      {
        blinding = RSA_setup_blinding(a1, a3);
        a1->blinding = blinding;
      }
      goto LABEL_9;
    }
  }
  else
  {
    *a2 = 1;
  }
  if (bignum_data) {
    int v9 = 6;
  }
  else {
    int v9 = 10;
  }
LABEL_14:
  CRYPTO_lock(v9, 9, 0, 0);
  return blinding;
}

uint64_t rsa_blinding_convert(BN_BLINDING *b, BIGNUM *n, BIGNUM *a3, BN_CTX *a4)
{
  if (a3)
  {
    CRYPTO_lock(9, 25, 0, 0);
    uint64_t v8 = BN_BLINDING_convert_ex(n, a3, b, a4);
    CRYPTO_lock(10, 25, 0, 0);
    return v8;
  }
  else
  {
    return BN_BLINDING_convert_ex(n, 0, b, a4);
  }
}

EVP_PKEY **EVP_DigestSignInit(uint64_t a1, void *a2, const EVP_MD *a3, ENGINE *a4, uint64_t a5)
{
  return do_sigver_init(a1, a2, a3, a4, a5, 0);
}

EVP_PKEY **do_sigver_init(uint64_t a1, void *a2, const EVP_MD *digestbyname, ENGINE *a4, uint64_t a5, int a6)
{
  int result = *(EVP_PKEY ***)(a1 + 32);
  if (!result)
  {
    int result = EVP_PKEY_CTX_new(a5, a4);
    *(void *)(a1 + 32) = result;
    if (!result) {
      return result;
    }
  }
  if (!digestbyname && ((*result)->save_type & 4) == 0)
  {
    if ((int)EVP_PKEY_get_default_digest_nid(a5) <= 0
      || (__n128 v13 = OBJ_nid2sn(0), (digestbyname = EVP_get_digestbyname(v13)) == 0))
    {
      ERR_put_error(6, 4095, 158, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/m_sigver.c", 92);
      return 0;
    }
  }
  uint64_t v14 = *(void *)(a1 + 32);
  __n128 v15 = *(void **)v14;
  if (a6)
  {
    uint64_t v16 = (int (*)(void))v15[16];
    if (v16)
    {
      if (v16() >= 1)
      {
        uint64_t v17 = *(void *)(a1 + 32);
        int v18 = 128;
LABEL_15:
        *(_DWORD *)(v17 + 32) = v18;
        goto LABEL_24;
      }
      return 0;
    }
    if (v15[27])
    {
      int v20 = 16;
LABEL_20:
      *(_DWORD *)(v14 + 32) = v20;
      *(void *)(a1 + 4RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = update_oneshot_only;
      goto LABEL_24;
    }
    int v21 = EVP_PKEY_verify_init((uint64_t *)v14);
  }
  else
  {
    int v19 = (int (*)(void))v15[14];
    if (v19)
    {
      if (v19() >= 1)
      {
        uint64_t v17 = *(void *)(a1 + 32);
        int v18 = 64;
        goto LABEL_15;
      }
      return 0;
    }
    if (v15[26])
    {
      int v20 = 8;
      goto LABEL_20;
    }
    int v21 = EVP_PKEY_sign_init((uint64_t *)v14);
  }
  if (v21 < 1) {
    return 0;
  }
LABEL_24:
  if ((int)EVP_PKEY_CTX_ctrl(*(uint64_t **)(a1 + 32), -1, 248) < 1) {
    return 0;
  }
  if (a2) {
    *a2 = *(void *)(a1 + 32);
  }
  if ((*(unsigned char *)(**(void **)(a1 + 32) + 4) & 4) != 0) {
    return (EVP_PKEY **)1;
  }
  else {
    return (EVP_PKEY **)(EVP_DigestInit_ex((EVP_MD_CTX *)a1, digestbyname, a4) != 0);
  }
}

EVP_PKEY **EVP_DigestVerifyInit(uint64_t a1, void *a2, const EVP_MD *a3, ENGINE *a4, uint64_t a5)
{
  return do_sigver_init(a1, a2, a3, a4, a5, 1);
}

uint64_t EVP_DigestSignFinal(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = *(void *)v6;
  if ((*(unsigned char *)(*(void *)v6 + 4) & 4) == 0)
  {
    uint64_t v8 = *(uint64_t (**)(void))(v7 + 120);
    if (a2)
    {
      long long v19 = 0u;
      memset(&ctx, 0, sizeof(ctx));
      unsigned int s = 0;
      EVP_MD_CTX_init(&ctx);
      if (!EVP_MD_CTX_copy_ex(&ctx, (const EVP_MD_CTX *)a1)) {
        return 0;
      }
      if (v8)
      {
        uint64_t v9 = (*(uint64_t (**)(void, uint64_t, void *, EVP_MD_CTX *))(*(void *)v19 + 120))(v19, a2, a3, &ctx);
        EVP_MD_CTX_cleanup(&ctx);
        return v9;
      }
      int v15 = EVP_DigestFinal_ex(&ctx, md, &s);
      EVP_MD_CTX_cleanup(&ctx);
      if (!v15 || (int)EVP_PKEY_sign(*(uint64_t **)(a1 + 32), a2, a3, (uint64_t)md, s) <= 0) {
        return 0;
      }
    }
    else
    {
      if (v8)
      {
        int v12 = v8();
      }
      else
      {
        unsigned int v16 = EVP_MD_size(*(const EVP_MD **)a1);
        if ((v16 & 0x80000000) != 0) {
          return 0;
        }
        int v12 = EVP_PKEY_sign(*(uint64_t **)(a1 + 32), 0, a3, 0, v16);
      }
      if (v12 < 1) {
        return 0;
      }
    }
    return 1;
  }
  if (a2)
  {
    int v10 = (EVP_PKEY **)EVP_PKEY_CTX_dup(v6);
    if (v10)
    {
      int v11 = v10;
      uint64_t v9 = (*(uint64_t (**)(EVP_PKEY **, uint64_t, void *, uint64_t))&(*v10)[3].type)(v10, a2, a3, a1);
      EVP_PKEY_CTX_free(v11);
      return v9;
    }
    return 0;
  }
  __n128 v13 = *(uint64_t (**)(void))(v7 + 120);
  return v13();
}

uint64_t EVP_DigestSign(EVP_MD_CTX *ctx, uint64_t a2, void *a3, void *d, size_t cnt)
{
  uint64_t v8 = *(uint64_t (**)(void))(*(void *)ctx[1].digest + 208);
  if (v8)
  {
    return v8();
  }
  else if (a2 && EVP_DigestUpdate(ctx, d, cnt) < 1)
  {
    return 0;
  }
  else
  {
    return EVP_DigestSignFinal((uint64_t)ctx, a2, a3);
  }
}

uint64_t EVP_DigestVerifyFinal(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  long long v12 = 0u;
  memset(&ctx, 0, sizeof(ctx));
  unsigned int s = 0;
  uint64_t v6 = *(void *)(**(void **)(a1 + 32) + 136);
  EVP_MD_CTX_init(&ctx);
  if (!EVP_MD_CTX_copy_ex(&ctx, (const EVP_MD_CTX *)a1)) {
    return 0xFFFFFFFFLL;
  }
  if (v6)
  {
    uint64_t v7 = (*(uint64_t (**)(void, uint64_t, uint64_t, EVP_MD_CTX *))(*(void *)v12 + 136))(v12, a2, a3, &ctx);
    EVP_MD_CTX_cleanup(&ctx);
  }
  else
  {
    int v8 = EVP_DigestFinal_ex(&ctx, md, &s);
    EVP_MD_CTX_cleanup(&ctx);
    if (v8) {
      return EVP_PKEY_verify(*(_DWORD **)(a1 + 32));
    }
    else {
      return 0;
    }
  }
  return v7;
}

uint64_t EVP_DigestVerify(EVP_MD_CTX *ctx, uint64_t a2, uint64_t a3, void *d, size_t cnt)
{
  int v8 = *(uint64_t (**)(void))(*(void *)ctx[1].digest + 216);
  if (v8)
  {
    return v8();
  }
  else if (EVP_DigestUpdate(ctx, d, cnt) < 1)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return EVP_DigestVerifyFinal((uint64_t)ctx, a2, a3);
  }
}

uint64_t update_oneshot_only()
{
  return 0;
}

__n128 CRYPTO_cbc128_encrypt(void *a1, void *a2, unint64_t a3, uint64_t a4, _OWORD *a5, void (*a6)(void *, void *, uint64_t))
{
  unint64_t v9 = a3;
  long long v12 = a5;
  if (a3 >= 0x10)
  {
    do
    {
      __n128 v13 = a2;
      *a2 = *v12 ^ *a1;
      a2[1] = v12[1] ^ a1[1];
      a6(a2, a2, a4);
      v9 -= 16;
      a1 += 2;
      a2 += 2;
      long long v12 = v13;
    }
    while (v9 > 0xF);
    long long v12 = a2 - 2;
  }
  if (v9)
  {
    uint64_t v14 = 0;
    uint64_t v15 = 15;
    if (v9 > 0xF) {
      uint64_t v15 = v9;
    }
    do
    {
      *((unsigned char *)a2 + v14) = *((unsigned char *)v12 + v14) ^ *((unsigned char *)a1 + v14);
      ++v14;
    }
    while (v9 != v14);
    if ((unint64_t)(v14 - 1) <= 0xE)
    {
      uint64_t v16 = v15 - 2 * v9 + v14 + 1;
      uint64_t v17 = (char *)a2 + v9;
      int v18 = (char *)v12 + v9;
      do
      {
        char v19 = *v18++;
        *v17++ = v19;
        --v16;
      }
      while (v16);
    }
    a6(a2, a2, a4);
  }
  else
  {
    a2 = v12;
  }
  __n128 result = *(__n128 *)a2;
  *a5 = *(_OWORD *)a2;
  return result;
}

uint64_t CRYPTO_cbc128_decrypt(uint64_t result, uint64_t *a2, unint64_t a3, uint64_t a4, void *a5, uint64_t (*a6)(void *, uint64_t *, uint64_t))
{
  unint64_t v9 = a3;
  int v10 = (void *)result;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  if ((uint64_t *)result == a2)
  {
    if (a3 < 0x10)
    {
      char v19 = (void *)result;
      if (!a3) {
        return result;
      }
      goto LABEL_12;
    }
    do
    {
      __n128 result = a6(v10, &v27, a4);
      uint64_t v16 = v28;
      uint64_t v17 = *v10;
      *int v10 = *a5 ^ v27;
      *a5 = v17;
      uint64_t v18 = v10[1];
      v10[1] = a5[1] ^ v16;
      a5[1] = v18;
      v9 -= 16;
      v10 += 2;
      char v19 = v10;
    }
    while (v9 > 0xF);
  }
  else
  {
    int v11 = a2;
    if (a3 < 0x10)
    {
      uint64_t v15 = a5;
    }
    else
    {
      long long v12 = a5;
      do
      {
        __n128 v13 = v10;
        __n128 result = a6(v10, v11, a4);
        uint64_t v14 = v11[1];
        *v11 ^= *v12;
        v9 -= 16;
        v11[1] = v14 ^ v12[1];
        v10 += 2;
        v11 += 2;
        long long v12 = v13;
      }
      while (v9 > 0xF);
      uint64_t v15 = v10 - 2;
    }
    char v19 = v10;
    *(_OWORD *)a5 = *v15;
    int v10 = v11;
  }
  if (!v9) {
    return result;
  }
LABEL_12:
  __n128 result = a6(v19, &v27, a4);
  uint64_t v20 = 0;
  uint64_t v21 = 15;
  if (v9 > 0xF) {
    uint64_t v21 = v9;
  }
  do
  {
    char v22 = *((unsigned char *)v19 + v20);
    *((unsigned char *)v10 + v2RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = *((unsigned char *)a5 + v20) ^ *((unsigned char *)&v27 + v20);
    *((unsigned char *)a5 + v20++) = v22;
  }
  while (v9 != v20);
  if ((unint64_t)(v20 - 1) <= 0xE)
  {
    uint64_t v23 = v21 - 2 * v9 + v20 + 1;
    int v24 = (char *)a5 + v9;
    int v25 = (char *)v19 + v9;
    do
    {
      char v26 = *v25++;
      *v24++ = v26;
      --v23;
    }
    while (v23);
  }
  return result;
}

void ECDH_set_default_method(const ECDH_METHOD *a1)
{
  default_ECDH_int method = (uint64_t)a1;
}

const ECDH_METHOD *ECDH_get_default_method(void)
{
  __n128 result = (const ECDH_METHOD *)default_ECDH_method;
  if (!default_ECDH_method)
  {
    __n128 result = ECDH_OpenSSL();
    default_ECDH_int method = (uint64_t)result;
  }
  return result;
}

int ECDH_set_method(EC_KEY *a1, const ECDH_METHOD *a2)
{
  unsigned int v3 = (ENGINE **)ecdh_check(a1);
  if (v3)
  {
    unsigned int v4 = v3;
    ENGINE_finish(v3[1]);
    v4[1] = 0;
    _OWORD v4[3] = a2;
    LODWORD(v3) = 1;
  }
  return (int)v3;
}

void *ecdh_check(EC_KEY *a1)
{
  key_method_uint64_t data = EC_KEY_get_key_method_data(a1, (void *(__cdecl *)(void *))ecdh_data_dup, (void (__cdecl *)(void *))ecdh_data_free, (void (__cdecl *)(void *))ecdh_data_free);
  if (!key_method_data)
  {
    key_method_uint64_t data = ecdh_data_new();
    if (key_method_data)
    {
      EC_KEY_insert_key_method_data(a1, key_method_data, (void *(__cdecl *)(void *))ecdh_data_dup, (void (__cdecl *)(void *))ecdh_data_free, (void (__cdecl *)(void *))ecdh_data_free);
      if (v3)
      {
        uint64_t v4 = v3;
        ecdh_data_free((uint64_t)key_method_data);
        return (void *)v4;
      }
    }
  }
  return key_method_data;
}

CRYPTO_EX_DATA *ecdh_data_dup(CRYPTO_EX_DATA *result)
{
  if (result) {
    return ecdh_data_new();
  }
  return result;
}

void *ecdh_data_free(uint64_t a1)
{
  ENGINE_finish(*(ENGINE **)(a1 + 8));
  CRYPTO_free_ex_data(13, (void *)a1, (CRYPTO_EX_DATA *)(a1 + 32));
  return freezero((void *)a1, 0x28uLL);
}

CRYPTO_EX_DATA *ecdh_data_new()
{
  uint64_t v0 = (CRYPTO_EX_DATA *)malloc_type_malloc(0x28uLL, 0x10E00407A09E776uLL);
  int v1 = v0;
  if (!v0)
  {
    ERR_put_error(43, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdh/ech_lib.c", 128);
    return v1;
  }
  v0->uint64_t sk = 0;
  unint64_t v2 = (const ECDH_METHOD *)default_ECDH_method;
  if (!default_ECDH_method)
  {
    unint64_t v2 = ECDH_OpenSSL();
    default_ECDH_int method = (uint64_t)v2;
  }
  *(void *)&v1[1].dummy = v2;
  *(void *)&v1->dummy = 0;
  default_ECDH = ENGINE_get_default_ECDH();
  *(void *)&v1->dummy = default_ECDH;
  if (!default_ECDH)
  {
    ECDH = *(const ECDH_METHOD **)&v1[1].dummy;
    goto LABEL_9;
  }
  ECDH = ENGINE_get_ECDH(default_ECDH);
  *(void *)&v1[1].dummy = ECDH;
  if (ECDH)
  {
LABEL_9:
    LODWORD(v1[1].sk) = *((_DWORD *)ECDH + 4);
    CRYPTO_new_ex_data(13, v1, v1 + 2);
    return v1;
  }
  ERR_put_error(43, 4095, 38, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ecdh/ech_lib.c", 142);
  ENGINE_finish(*(ENGINE **)&v1->dummy);
  free(v1);
  return 0;
}

int ECDH_get_ex_new_index(uint64_t argl, void *argp, CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
  return CRYPTO_get_ex_new_index(13, argl, argp, new_func, dup_func, free_func);
}

int ECDH_set_ex_data(EC_KEY *d, int idx, void *arg)
{
  unsigned int v5 = (CRYPTO_EX_DATA *)ecdh_check(d);
  if (v5)
  {
    uint64_t v6 = v5 + 2;
    LODWORD(v5) = CRYPTO_set_ex_data(v6, idx, arg);
  }
  return (int)v5;
}

void *__cdecl ECDH_get_ex_data(EC_KEY *d, int idx)
{
  __n128 result = ecdh_check(d);
  if (result)
  {
    uint64_t v4 = (const CRYPTO_EX_DATA *)((char *)result + 32);
    return CRYPTO_get_ex_data(v4, idx);
  }
  return result;
}

uint64_t ECDH_size(const EC_KEY *a1)
{
  int v1 = EC_KEY_get0_group(a1);
  int degree = EC_GROUP_get_degree(v1);
  int v3 = degree + 7;
  if (degree < -7) {
    int v3 = degree + 14;
  }
  return (v3 >> 3);
}

void RC2_ofb64_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, RC2_KEY *schedule, unsigned __int8 *ivec, int *num)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  int v7 = *num;
  uint64_t v8 = *ivec;
  uint64_t v9 = ivec[1];
  uint64_t v10 = ivec[2];
  uint64_t v11 = ivec[3];
  int v12 = v8 | (v9 << 8) | (v10 << 16) | (v11 << 24);
  uint64_t v13 = ivec[4];
  uint64_t v14 = ivec[5];
  uint64_t v15 = ivec[6];
  uint64_t v16 = ivec[7];
  int v17 = v13 | (v14 << 8) | (v15 << 16) | (v16 << 24);
  uint64_t v25 = v8 | (v9 << 8) | (v10 << 16) | (v11 << 24);
  uint64_t v26 = v13 | (v14 << 8) | (v15 << 16) | (v16 << 24);
  LOBYTE(v27) = v8;
  BYTE1(v27) = v9;
  BYTE2(v27) = v10;
  HIBYTE(v27) = v11;
  LOBYTE(v28) = v13;
  BYTE1(v28) = v14;
  BYTE2(v28) = v15;
  HIBYTE(v28) = v16;
  if (length)
  {
    uint64_t v20 = length;
    int v23 = 0;
    do
    {
      if (!v7)
      {
        RC2_encrypt((unint64_t *)&v25, schedule);
        int v12 = v25;
        int v17 = v26;
        int v27 = v25;
        int v28 = v26;
        ++v23;
      }
      char v24 = *in++;
      *out++ = *((unsigned char *)&v27 + v7) ^ v24;
      int v7 = (v7 + 1) & 7;
      --v20;
    }
    while (v20);
    if (v23)
    {
      *(_DWORD *)ivec = v12;
      *((_DWORD *)ivec + engine_free_util((CRYPTO_EX_DATA *)e, 1) = v17;
    }
  }
  *uint64_t num = v7;
}

int BN_rand(BIGNUM *rnd, int bits, int top, int bottom)
{
  return bnrand(0, (uint64_t)rnd, bits, top, bottom);
}

uint64_t bnrand(int a1, uint64_t a2, int a3, int a4, int a5)
{
  BOOL v5 = a2;
  if (!a2)
  {
    ERR_put_error(3, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_rand.c", 128);
    return v5;
  }
  if ((a3 & 0x80000000) == 0 && (a3 != 1 || a4 < 1))
  {
    if (!a3)
    {
      BN_zero(a2);
      return 1;
    }
    char v9 = a3 + 7;
    size_t v10 = (a3 + 7) >> 3;
    uint64_t v11 = (unsigned __int8 *)malloc_type_malloc(v10, 0x30A95773uLL);
    int v12 = v11;
    if (v11)
    {
      int v13 = v9 & 7;
      arc4random_buf(v11, v10);
      if (a1 == 2)
      {
        uint64_t v14 = 0;
        unsigned __int8 __buf = 0;
        while (1)
        {
          arc4random_buf(&__buf, 1uLL);
          if (v14)
          {
            if ((char)__buf < 0) {
              break;
            }
          }
          if (__buf < 0x2Au)
          {
            char v15 = 0;
            goto LABEL_18;
          }
          if (__buf <= 0x53u)
          {
            char v15 = -1;
            goto LABEL_18;
          }
LABEL_19:
          if (v10 == ++v14) {
            goto LABEL_20;
          }
        }
        char v15 = v12[(v14 - 1)];
LABEL_18:
        v12[v14] = v15;
        goto LABEL_19;
      }
LABEL_20:
      if (a4 < 1)
      {
        LOBYTE(v++*(_DWORD *)(*(void *)(result + 8) + 16) = *v12;
        if (!a4) {
          LOBYTE(v++*(_DWORD *)(*(void *)(result + 8) + 16) = v16 | (1 << v13);
        }
      }
      else if (v13)
      {
        int v16 = *v12 | (3 << (v13 - 1));
      }
      else
      {
        v12[1] |= 0x80u;
        LOBYTE(v++*(_DWORD *)(*(void *)(result + 8) + 16) = 1;
      }
      unsigned __int8 *v12 = v16 & ~(510 << v13);
      if (a5) {
        v12[v10 - 1] |= 1u;
      }
      BOOL v5 = BN_bin2bn(v12, v10, (BIGNUM *)v5) != 0;
    }
    else
    {
      ERR_put_error(3, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_rand.c", 148);
      BOOL v5 = 0;
    }
    freezero(v12, v10);
    return v5;
  }
  ERR_put_error(3, 4095, 117, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_rand.c", 133);
  return 0;
}

int BN_pseudo_rand(BIGNUM *rnd, int bits, int top, int bottom)
{
  return bnrand(1, (uint64_t)rnd, bits, top, bottom);
}

int BN_bntest_rand(BIGNUM *rnd, int bits, int top, int bottom)
{
  return bnrand(2, (uint64_t)rnd, bits, top, bottom);
}

int BN_rand_range(BIGNUM *rnd, const BIGNUM *range)
{
  return bn_rand_range(0, rnd, range);
}

uint64_t bn_rand_range(int a1, BIGNUM *a2, const BIGNUM *a3)
{
  if (a1) {
    int v3 = BN_pseudo_rand;
  }
  else {
    int v3 = BN_rand;
  }
  if (a3->neg || BN_is_zero((uint64_t)a3))
  {
    int v6 = 115;
    int v7 = 226;
LABEL_7:
    ERR_put_error(3, 4095, v6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_rand.c", v7);
    return 0;
  }
  else
  {
    uint64_t v9 = BN_num_bits(a3);
    if (v9 == 1)
    {
      BN_zero((uint64_t)a2);
      return 1;
    }
    else
    {
      uint64_t v10 = v9;
      if (BN_is_bit_set(a3, v9 - 2) || BN_is_bit_set(a3, v10 - 3))
      {
        int v11 = -100;
        do
        {
          uint64_t result = ((uint64_t (*)(BIGNUM *, uint64_t, uint64_t, void))v3)(a2, v10, 0xFFFFFFFFLL, 0);
          if (!result) {
            break;
          }
          BOOL v12 = __CFADD__(v11++, 1);
          if (v12)
          {
            int v6 = 113;
            int v7 = 268;
            goto LABEL_7;
          }
          int v13 = BN_cmp(a2, a3);
          uint64_t result = 1;
        }
        while ((v13 & 0x80000000) == 0);
      }
      else
      {
        uint64_t v14 = (v10 + 1);
        int v15 = -100;
        do
        {
          uint64_t result = ((uint64_t (*)(BIGNUM *, uint64_t, uint64_t, void))v3)(a2, v14, 0xFFFFFFFFLL, 0);
          if (!result) {
            break;
          }
          if ((BN_cmp(a2, a3) & 0x80000000) == 0)
          {
            uint64_t result = BN_sub(a2, a2, a3);
            if (!result) {
              break;
            }
            if ((BN_cmp(a2, a3) & 0x80000000) == 0)
            {
              uint64_t result = BN_sub(a2, a2, a3);
              if (!result) {
                break;
              }
            }
          }
          BOOL v12 = __CFADD__(v15++, 1);
          if (v12)
          {
            int v6 = 113;
            int v7 = 256;
            goto LABEL_7;
          }
          int v16 = BN_cmp(a2, a3);
          uint64_t result = 1;
        }
        while ((v16 & 0x80000000) == 0);
      }
    }
  }
  return result;
}

BOOL bn_rand_interval(BIGNUM *a1, BIGNUM *a, BIGNUM *b)
{
  if (BN_cmp(a, b) < 0)
  {
    uint64_t v9 = BN_new();
    int v6 = v9;
    if (v9 && BN_sub(v9, b, a) && bn_rand_range(0, a1, v6))
    {
      BOOL v7 = BN_add(a1, a1, a) != 0;
      goto LABEL_4;
    }
  }
  else
  {
    int v6 = 0;
  }
  BOOL v7 = 0;
LABEL_4:
  BN_free(v6);
  return v7;
}

int BN_pseudo_rand_range(BIGNUM *rnd, const BIGNUM *range)
{
  return bn_rand_range(1, rnd, range);
}

int BN_gcd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)
{
  BN_CTX_start(ctx);
  uint64_t v8 = BN_CTX_get(ctx);
  if (!v8) {
    goto LABEL_40;
  }
  uint64_t v9 = BN_CTX_get(ctx);
  if (!v9 || (uint64_t v10 = v9, !bn_copy(v8, a)) || !bn_copy(v10, b))
  {
LABEL_39:
    LODWORD(v8) = 0;
    goto LABEL_40;
  }
  v8->neg = 0;
  v10->neg = 0;
  int v11 = BN_cmp(v8, v10);
  if (v11 >= 0) {
    BOOL v12 = v8;
  }
  else {
    BOOL v12 = v10;
  }
  if (v11 >= 0) {
    int v13 = v10;
  }
  else {
    int v13 = v8;
  }
  if (BN_is_zero((uint64_t)v13))
  {
    uint64_t v14 = v12;
LABEL_13:
    LODWORD(v8) = bn_copy(r, v14);
    goto LABEL_40;
  }
  int v15 = 0;
  do
  {
    while (1)
    {
      if (BN_is_odd((uint64_t)v12) && BN_is_odd((uint64_t)v13))
      {
        if (!BN_sub(v12, v12, v13)) {
          goto LABEL_39;
        }
        goto LABEL_26;
      }
      if (BN_is_odd((uint64_t)v12) && !BN_is_odd((uint64_t)v13))
      {
        int v16 = v13;
        int v17 = v13;
        goto LABEL_28;
      }
      if (BN_is_odd((uint64_t)v12) || !BN_is_odd((uint64_t)v13)) {
        break;
      }
LABEL_26:
      int v16 = v12;
      int v17 = v12;
LABEL_28:
      if (!BN_rshift1(v16, v17)) {
        goto LABEL_39;
      }
      int v18 = BN_cmp(v12, v13);
      if (v18 >= 0) {
        uint64_t v14 = v12;
      }
      else {
        uint64_t v14 = v13;
      }
      if (v18 < 0) {
        int v13 = v12;
      }
      BOOL v12 = v14;
      if (BN_is_zero((uint64_t)v13)) {
        goto LABEL_35;
      }
    }
    if (!BN_rshift1(v12, v12) || !BN_rshift1(v13, v13)) {
      goto LABEL_39;
    }
    ++v15;
  }
  while (!BN_is_zero((uint64_t)v13));
  uint64_t v14 = v12;
LABEL_35:
  if (!v15) {
    goto LABEL_13;
  }
  int v19 = BN_lshift(v14, v14, v15);
  LODWORD(v8) = 0;
  if (v19) {
    goto LABEL_13;
  }
LABEL_40:
  BN_CTX_end(ctx);
  return (int)v8;
}

BOOL BN_gcd_ct(unint64_t a1, const BIGNUM *a2, const BIGNUM *a3, BN_CTX *a4)
{
  memset(&v25, 0, sizeof(v25));
  memset(&v24, 0, sizeof(v24));
  if (a1)
  {
    BN_init(&v25);
    BN_init(&v24);
    BN_CTX_start(a4);
    uint64_t v8 = BN_CTX_get(a4);
    if (!v8) {
      goto LABEL_24;
    }
    uint64_t v9 = v8;
    uint64_t v10 = BN_CTX_get(a4);
    if (!v10) {
      goto LABEL_24;
    }
    int v11 = v10;
    BOOL v12 = BN_CTX_get(a4);
    if (!v12) {
      goto LABEL_24;
    }
    uint64_t v13 = (uint64_t)v12;
    uint64_t v14 = BN_CTX_get(a4);
    if (!v14) {
      goto LABEL_24;
    }
    int v15 = v14;
    int v16 = BN_CTX_get(a4);
    if (!v16) {
      goto LABEL_24;
    }
    int v17 = v16;
    int v18 = BN_CTX_get(a4);
    if (!v18) {
      goto LABEL_24;
    }
    int v19 = v18;
    if (!BN_CTX_get(a4)) {
      goto LABEL_24;
    }
    if (!BN_one(v13)) {
      goto LABEL_24;
    }
    BN_zero((uint64_t)v19);
    if (!bn_copy(v11, a2) || !bn_copy(v9, a3)) {
      goto LABEL_24;
    }
    v9->neg = 0;
    if (v11->neg || (BN_ucmp(v11, v9) & 0x80000000) == 0)
    {
      BN_with_flags((__n128 *)&v24, (__n128 *)v11, 4);
      if (!BN_nnmod(v11, &v24, v9, a4)) {
        goto LABEL_24;
      }
    }
    unint64_t v20 = 0;
    while (1)
    {
      uint64_t v21 = v19;
      int v19 = (const BIGNUM *)v13;
      uint64_t v13 = (uint64_t)v9;
      if (BN_is_zero((uint64_t)v11)) {
        break;
      }
      BN_with_flags((__n128 *)&v25, (__n128 *)v9, 4);
      if (!BN_div_ct((uint64_t)v15, v17, &v25, v11, a4) || !BN_mul(v9, v15, v19, a4)) {
        goto LABEL_21;
      }
      int v22 = BN_add(v9, v9, v21);
      uint64_t v9 = v11;
      int v11 = v17;
      int v17 = (BIGNUM *)v21;
      if (!v22) {
        goto LABEL_22;
      }
    }
    if (bn_copy((BIGNUM *)a1, v9)) {
      unint64_t v20 = a1;
    }
    else {
      unint64_t v20 = 0;
    }
  }
  else
  {
LABEL_21:
    unint64_t v20 = 0;
  }
LABEL_22:
  if (!(a1 | v20))
  {
    BN_free(0);
LABEL_24:
    unint64_t v20 = 0;
  }
  BN_CTX_end(a4);
  return v20 != 0;
}

BIGNUM *__cdecl BN_mod_inverse(BIGNUM *ret, const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx)
{
  if (BN_get_flags((uint64_t)a, 4u)) {
    BOOL v8 = 1;
  }
  else {
    BOOL v8 = BN_get_flags((uint64_t)n, 4u) != 0;
  }
  return BN_mod_inverse_internal(ret, a, n, ctx, v8);
}

BIGNUM *BN_mod_inverse_internal(BIGNUM *a1, const BIGNUM *a2, const BIGNUM *a3, BN_CTX *ctx, int a5)
{
  if (a5)
  {
    memset(&v64, 0, sizeof(v64));
    memset(&m, 0, sizeof(m));
    BN_init(&v64);
    BN_init(&m);
    BN_CTX_start(ctx);
    uint64_t v9 = BN_CTX_get(ctx);
    if (v9)
    {
      uint64_t v10 = v9;
      int v11 = BN_CTX_get(ctx);
      if (v11)
      {
        BOOL v12 = v11;
        uint64_t v13 = BN_CTX_get(ctx);
        if (v13)
        {
          uint64_t v14 = v13;
          int v15 = BN_CTX_get(ctx);
          if (v15)
          {
            int v16 = v15;
            int v17 = BN_CTX_get(ctx);
            if (v17)
            {
              int v18 = v17;
              int v19 = BN_CTX_get(ctx);
              if (!v19) {
                goto LABEL_65;
              }
              if (BN_CTX_get(ctx))
              {
                int b = v19;
                int v19 = a1;
                if (!a1)
                {
                  int v19 = BN_new();
                  if (!v19) {
                    goto LABEL_65;
                  }
                }
                if (!BN_one((uint64_t)v14)) {
                  goto LABEL_65;
                }
                BN_zero((uint64_t)b);
                if (!bn_copy(v12, a2) || !bn_copy(v10, a3)) {
                  goto LABEL_65;
                }
                v10->neg = 0;
                if (v12->neg || (BN_ucmp(v12, v10) & 0x80000000) == 0)
                {
                  BN_with_flags((__n128 *)&m, (__n128 *)v12, 4);
                  if (!BN_nnmod(v12, &m, v10, ctx)) {
                    goto LABEL_65;
                  }
                }
                if (!BN_is_zero((uint64_t)v12))
                {
                  int v40 = -1;
                  int v41 = 1;
                  while (1)
                  {
                    int v56 = v41;
                    int v58 = v40;
                    int v42 = v12;
                    BOOL v12 = v18;
                    BN_with_flags((__n128 *)&v64, (__n128 *)v10, 4);
                    r = (BIGNUM *)v42;
                    if (!BN_div_ct((uint64_t)v16, v18, &v64, v42, ctx)) {
                      goto LABEL_65;
                    }
                    if (!BN_mul(v10, v16, v14, ctx)) {
                      goto LABEL_65;
                    }
                    int v18 = b;
                    if (!BN_add(v10, v10, b)) {
                      goto LABEL_65;
                    }
                    is_zerASN1_OBJECT o = BN_is_zero((uint64_t)v12);
                    int v41 = v58;
                    int v40 = v56;
                    int b = (BIGNUM *)v14;
                    unsigned int v44 = (BIGNUM *)v14;
                    uint64_t v14 = v10;
                    uint64_t v10 = (BIGNUM *)v42;
                    if (is_zero)
                    {
                      unint64_t v20 = v44;
                      if ((v56 & 0x80000000) == 0) {
                        goto LABEL_20;
                      }
                      goto LABEL_19;
                    }
                  }
                }
                unint64_t v20 = b;
                r = v10;
LABEL_19:
                if (!BN_sub(v20, a3, v20)) {
                  goto LABEL_65;
                }
LABEL_20:
                if (!BN_is_one((uint64_t)r))
                {
                  int v21 = 510;
LABEL_120:
                  ERR_put_error(3, 4095, 108, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_gcd.c", v21);
                  goto LABEL_65;
                }
                goto LABEL_73;
              }
            }
          }
        }
      }
    }
LABEL_64:
    int v19 = 0;
    goto LABEL_65;
  }
  BN_CTX_start(ctx);
  int v22 = BN_CTX_get(ctx);
  if (!v22) {
    goto LABEL_64;
  }
  int v23 = v22;
  BIGNUM v24 = BN_CTX_get(ctx);
  if (!v24) {
    goto LABEL_64;
  }
  BIGNUM v25 = v24;
  uint64_t v26 = BN_CTX_get(ctx);
  if (!v26) {
    goto LABEL_64;
  }
  int v27 = v26;
  int v28 = BN_CTX_get(ctx);
  if (!v28) {
    goto LABEL_64;
  }
  uint64_t v29 = v28;
  uint64_t v30 = BN_CTX_get(ctx);
  if (!v30) {
    goto LABEL_64;
  }
  int v31 = v30;
  int v19 = BN_CTX_get(ctx);
  if (!v19) {
    goto LABEL_65;
  }
  BIGNUM v32 = BN_CTX_get(ctx);
  if (!v32) {
    goto LABEL_64;
  }
  rEVP_CIPHER_CTX a = v32;
  bEVP_CIPHER_CTX a = v19;
  int v19 = a1;
  if (!a1)
  {
    int v19 = BN_new();
    if (!v19) {
      goto LABEL_65;
    }
  }
  if (!BN_one((uint64_t)v27)) {
    goto LABEL_65;
  }
  BN_zero((uint64_t)ba);
  if (!bn_copy(v25, a2) || !bn_copy(v23, a3)) {
    goto LABEL_65;
  }
  v23->neg = 0;
  if ((v25->neg || (BN_ucmp(v25, v23) & 0x80000000) == 0) && !BN_nnmod(v25, v25, v23, ctx)) {
    goto LABEL_65;
  }
  if (BN_is_odd((uint64_t)a3) && BN_num_bits(a3) <= 2048)
  {
    if (!BN_is_zero((uint64_t)v25))
    {
      int v33 = 0;
      while (1)
      {
        while (!BN_is_bit_set(v25, v33))
        {
          if (!BN_is_odd((uint64_t)v27) || BN_uadd(v27, v27, a3))
          {
            ++v33;
            if (BN_rshift1(v27, v27)) {
              continue;
            }
          }
          goto LABEL_65;
        }
        if (v33 && !BN_rshift(v25, v25, v33)) {
          goto LABEL_65;
        }
        int v34 = 0;
        while (!BN_is_bit_set(v23, v34))
        {
          if (!BN_is_odd((uint64_t)ba) || BN_uadd(ba, ba, a3))
          {
            ++v34;
            if (BN_rshift1(ba, ba)) {
              continue;
            }
          }
          goto LABEL_65;
        }
        if (v34 && !BN_rshift(v23, v23, v34)) {
          goto LABEL_65;
        }
        if (BN_ucmp(v25, v23) < 0)
        {
          if (!BN_uadd(ba, ba, v27)) {
            goto LABEL_65;
          }
          BIGNUM v35 = v23;
          int v36 = v23;
          uint64_t v37 = v25;
        }
        else
        {
          if (!BN_uadd(v27, v27, ba)) {
            goto LABEL_65;
          }
          BIGNUM v35 = v25;
          int v36 = v25;
          uint64_t v37 = v23;
        }
        if (!BN_usub(v35, v36, v37)) {
          goto LABEL_65;
        }
        int v33 = 0;
        if (BN_is_zero((uint64_t)v25)) {
          break;
        }
      }
    }
LABEL_70:
    unint64_t v20 = ba;
    goto LABEL_71;
  }
  if (BN_is_zero((uint64_t)v25)) {
    goto LABEL_70;
  }
  int v57 = -1;
  int v45 = 1;
  do
  {
    int v46 = v25;
    BIGNUM v25 = v31;
    int v55 = v45;
    int v47 = BN_num_bits(v23);
    if (v47 == BN_num_bits(v46))
    {
LABEL_86:
      if (!BN_one((uint64_t)v29)) {
        goto LABEL_65;
      }
      int v48 = v25;
      int v49 = v23;
LABEL_88:
      if (!BN_sub(v48, v49, v46)) {
        goto LABEL_65;
      }
      goto LABEL_99;
    }
    int v50 = BN_num_bits(v23);
    if (v50 == BN_num_bits(v46) + 1)
    {
      if (!BN_lshift1(ra, v46)) {
        goto LABEL_65;
      }
      if (BN_ucmp(v23, ra) < 0) {
        goto LABEL_86;
      }
      if (!BN_sub(v25, v23, ra) || !BN_add(v29, ra, v46)) {
        goto LABEL_65;
      }
      if ((BN_ucmp(v23, v29) & 0x80000000) == 0)
      {
        if (!BN_set_word(v29, 3uLL)) {
          goto LABEL_65;
        }
        int v48 = v25;
        int v49 = v25;
        goto LABEL_88;
      }
      if (!BN_set_word(v29, 2uLL)) {
        goto LABEL_65;
      }
    }
    else if (!BN_div_nonct((uint64_t)v29, v25, v23, v46, ctx))
    {
      goto LABEL_65;
    }
LABEL_99:
    if (BN_is_one((uint64_t)v29))
    {
      int v51 = v23;
      int v52 = v27;
    }
    else
    {
      if (BN_is_word((uint64_t)v29, 2))
      {
        if (!BN_lshift1(v23, v27)) {
          goto LABEL_65;
        }
      }
      else if (BN_is_word((uint64_t)v29, 4))
      {
        if (!BN_lshift(v23, v27, 2)) {
          goto LABEL_65;
        }
      }
      else if (v29->top == 1)
      {
        if (!bn_copy(v23, v27) || !BN_mul_word(v23, *v29->d)) {
          goto LABEL_65;
        }
      }
      else if (!BN_mul(v23, v29, v27, ctx))
      {
        goto LABEL_65;
      }
      int v51 = v23;
      int v52 = v23;
    }
    int v31 = ba;
    if (!BN_add(v51, v52, ba)) {
      goto LABEL_65;
    }
    BOOL v53 = BN_is_zero((uint64_t)v25);
    int v45 = v57;
    int v57 = v55;
    bEVP_CIPHER_CTX a = v27;
    int v54 = v27;
    int v27 = v23;
    int v23 = (BIGNUM *)v46;
  }
  while (!v53);
  int v23 = (BIGNUM *)v46;
  unint64_t v20 = v54;
  if ((v55 & 0x80000000) == 0)
  {
LABEL_72:
    if (!BN_is_one((uint64_t)v23))
    {
      int v21 = 798;
      goto LABEL_120;
    }
LABEL_73:
    if (!v20->neg && BN_ucmp(v20, a3) < 0)
    {
      if (!bn_copy(v19, v20)) {
        goto LABEL_65;
      }
    }
    else if (!BN_nnmod(v19, v20, a3, ctx))
    {
      goto LABEL_65;
    }
    int v38 = v19;
    goto LABEL_66;
  }
LABEL_71:
  if (BN_sub(v20, a3, v20)) {
    goto LABEL_72;
  }
LABEL_65:
  int v38 = 0;
LABEL_66:
  if (!((unint64_t)a1 | (unint64_t)v38)) {
    BN_free(v19);
  }
  BN_CTX_end(ctx);
  return v38;
}

BIGNUM *BN_mod_inverse_nonct(BIGNUM *a1, const BIGNUM *a2, const BIGNUM *a3, BN_CTX *a4)
{
  return BN_mod_inverse_internal(a1, a2, a3, a4, 0);
}

BIGNUM *BN_mod_inverse_ct(BIGNUM *a1, const BIGNUM *a2, const BIGNUM *a3, BN_CTX *a4)
{
  return BN_mod_inverse_internal(a1, a2, a3, a4, 1);
}

unint64_t bn_add_words(unint64_t *rp, const unint64_t *ap, const unint64_t *bp, int num)
{
  if (num < 0) {
    bn_add_words_cold_1();
  }
  if (!num) {
    return 0;
  }
  if (num < 4)
  {
    unint64_t v4 = 0;
    do
    {
LABEL_9:
      uint64_t v34 = *ap++;
      uint64_t v33 = v34;
      uint64_t v35 = *bp++;
      uint64_t v36 = v35 | v33;
      uint64_t v37 = v35 & v33;
      uint64_t v38 = v35 + v33;
      unint64_t v39 = v36 & ~v38 | v37;
      unint64_t v40 = v38 | v4;
      unint64_t v41 = v38 & v4;
      unint64_t v42 = v38 + v4;
      unint64_t v4 = ((v40 & ~v42 | v41) >> 63) + (v39 >> 63);
      *rp++ = v42;
      --num;
    }
    while (num);
    return v4;
  }
  unint64_t v4 = 0;
  do
  {
    unint64_t v5 = *bp + *ap;
    unint64_t v6 = (*bp | *ap) & ~v5 | *bp & *ap;
    unint64_t v7 = v5 | v4;
    unint64_t v8 = v5 & v4;
    unint64_t v9 = v5 + v4;
    unint64_t v10 = v7 & ~v9 | v8;
    *runsigned int p = v9;
    unint64_t v11 = ap[1];
    unint64_t v12 = bp[1];
    unint64_t v13 = v12 | v11;
    unint64_t v14 = v12 & v11;
    unint64_t v15 = v12 + v11;
    unint64_t v16 = v13 & ~v15 | v14;
    unint64_t v17 = v15 + (v6 >> 63) + (v10 >> 63);
    unint64_t v18 = v15 & ~v17;
    rp[1] = v17;
    unint64_t v19 = ap[2];
    unint64_t v20 = bp[2];
    unint64_t v21 = v20 | v19;
    unint64_t v22 = v20 & v19;
    unint64_t v23 = v20 + v19;
    unint64_t v24 = v21 & ~v23 | v22;
    unint64_t v25 = v23 + (v16 >> 63) + (v18 >> 63);
    unint64_t v26 = v23 & ~v25;
    rp[2] = v25;
    unint64_t v27 = ap[3];
    unint64_t v28 = bp[3];
    unint64_t v29 = v28 | v27;
    unint64_t v30 = v28 & v27;
    unint64_t v31 = v28 + v27;
    unint64_t v32 = v31 + (v24 >> 63) + (v26 >> 63);
    unint64_t v4 = ((v31 & ~v32) >> 63) + ((v29 & ~v31 | v30) >> 63);
    rp[3] = v32;
    ap += 4;
    bp += 4;
    rp += 4;
    num -= 4;
  }
  while (num >= 4);
  if (num) {
    goto LABEL_9;
  }
  return v4;
}

unint64_t bn_add(unint64_t *a1, int a2, unint64_t *ap, int a4, unint64_t *bp, int a6)
{
  int v11 = a4 - a6;
  if (a4 >= a6) {
    int v12 = a6;
  }
  else {
    int v12 = a4;
  }
  unint64_t result = bn_add_words(a1, ap, bp, v12);
  unint64_t v14 = &a1[v12];
  if (v11 < 0)
  {
    unint64_t v19 = &bp[v12];
    int v20 = a6 - a4;
    do
    {
      uint64_t v21 = *v19++;
      unint64_t v22 = v21 + result;
      unint64_t result = ((v21 | result) & ~(v21 + result) | v21 & result) >> 63;
      *v14++ = v22;
      --v20;
    }
    while (v20);
  }
  else if (v11)
  {
    unint64_t v15 = &ap[v12];
    unsigned int v16 = v11 + 1;
    do
    {
      uint64_t v17 = *v15++;
      unint64_t v18 = v17 + result;
      unint64_t result = ((v17 | result) & ~(v17 + result) | v17 & result) >> 63;
      *v14++ = v18;
      --v16;
    }
    while (v16 > 1);
  }
  return result;
}

unint64_t bn_sub_words(unint64_t *rp, const unint64_t *ap, const unint64_t *bp, int num)
{
  if (num < 0) {
    bn_sub_words_cold_1();
  }
  if (!num) {
    return 0;
  }
  if (num < 4)
  {
    unint64_t v4 = 0;
    do
    {
LABEL_9:
      uint64_t v25 = *ap++;
      uint64_t v24 = v25;
      uint64_t v26 = *bp++;
      unint64_t v27 = v24 - v26 - v4;
      unint64_t v4 = (((v27 | v4 & ~(v24 - v26)) & (v4 | ~(v24 - v26))) >> 63)
         + ((((v24 - v26) | v26 & ~v24) & (v26 | (unint64_t)~v24)) >> 63);
      *rp++ = v27;
      --num;
    }
    while (num);
    return v4;
  }
  unint64_t v4 = 0;
  do
  {
    unint64_t v5 = *ap - *bp;
    int64_t v6 = (v5 | *bp & ~*ap) & (*bp | ~*ap);
    unint64_t v7 = v5 - v4;
    uint64_t v8 = ((v5 - v4) | v4 & ~v5) & (v4 | ~v5);
    *runsigned int p = v7;
    unint64_t v9 = ap[1];
    unint64_t v10 = bp[1];
    unint64_t v11 = v9 - v10;
    uint64_t v12 = ((v9 - v10) | v10 & ~v9) & (v10 | ~v9);
    uint64_t v13 = v11 + (v6 >> 63) + (v8 >> 63);
    uint64_t v14 = v13 & ~v11;
    rp[1] = v13;
    unint64_t v15 = ap[2];
    unint64_t v16 = bp[2];
    unint64_t v17 = v15 - v16;
    uint64_t v18 = ((v15 - v16) | v16 & ~v15) & (v16 | ~v15);
    uint64_t v19 = v17 + (v12 >> 63) + (v14 >> 63);
    uint64_t v20 = v19 & ~v17;
    rp[2] = v19;
    unint64_t v21 = ap[3];
    unint64_t v22 = bp[3];
    uint64_t v23 = v21 - v22 + (v18 >> 63) + (v20 >> 63);
    unint64_t v4 = ((v23 & ~(v21 - v22)) >> 63) + ((((v21 - v22) | v22 & ~v21) & (v22 | ~v21)) >> 63);
    rp[3] = v23;
    ap += 4;
    bp += 4;
    rp += 4;
    num -= 4;
  }
  while (num >= 4);
  if (num) {
    goto LABEL_9;
  }
  return v4;
}

unint64_t bn_sub(unint64_t *a1, int a2, unint64_t *ap, int a4, unint64_t *bp, int a6)
{
  int v11 = a4 - a6;
  if (a4 >= a6) {
    int v12 = a6;
  }
  else {
    int v12 = a4;
  }
  unint64_t result = bn_sub_words(a1, ap, bp, v12);
  uint64_t v14 = &a1[v12];
  if (v11 < 0)
  {
    uint64_t v19 = &bp[v12];
    int v20 = a6 - a4;
    do
    {
      uint64_t v21 = *v19++;
      unint64_t v22 = -(uint64_t)result - v21;
      unint64_t result = (((v21 - 1) & result | v22) & ((v21 - 1) | result)) >> 63;
      *v14++ = v22;
      --v20;
    }
    while (v20);
  }
  else if (v11)
  {
    unint64_t v15 = &ap[v12];
    unsigned int v16 = v11 + 1;
    do
    {
      uint64_t v17 = *v15++;
      unint64_t v18 = v17 - result;
      unint64_t result = (((v17 - result) | result & ~v17) & (result | ~v17)) >> 63;
      *v14++ = v18;
      --v16;
    }
    while (v16 > 1);
  }
  return result;
}

int BN_uadd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
{
  if (a->top <= b->top) {
    tounsigned int p = b->top;
  }
  else {
    tounsigned int p = a->top;
  }
  if (top == 0x7FFFFFFF) {
    return 0;
  }
  int result = bn_wexpand((uint64_t)r, (top + 1));
  if (result)
  {
    unint64_t v9 = bn_add(r->d, v8, a->d, a->top, b->d, b->top);
    r->d[top] = v9;
    r->tounsigned int p = (v9 & 1) + top;
    r->neg = 0;
    return 1;
  }
  return result;
}

int BN_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
{
  tounsigned int p = a->top;
  if (top >= b->top)
  {
    int result = bn_wexpand((uint64_t)r, a->top);
    if (!result) {
      return result;
    }
    if (!bn_sub(r->d, v9, a->d, a->top, b->d, b->top))
    {
      r->tounsigned int p = top;
      r->neg = 0;
      bn_correct_top((uint64_t *)r);
      return 1;
    }
    int v4 = 277;
  }
  else
  {
    int v4 = 267;
  }
  ERR_put_error(3, 4095, 100, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_add.c", v4);
  return 0;
}

int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
{
  int neg = a->neg;
  if (neg == b->neg)
  {
    int v7 = BN_uadd(r, a, b);
  }
  else
  {
    int v8 = BN_ucmp(a, b);
    if (v8 < 1)
    {
      if ((v8 & 0x80000000) == 0)
      {
        BN_zero((uint64_t)r);
        int neg = 0;
        int v12 = 1;
        goto LABEL_7;
      }
      int neg = b->neg;
      int v9 = r;
      unint64_t v10 = b;
      int v11 = a;
    }
    else
    {
      int neg = a->neg;
      int v9 = r;
      unint64_t v10 = a;
      int v11 = b;
    }
    int v7 = BN_usub(v9, v10, v11);
  }
  int v12 = v7;
LABEL_7:
  BN_set_negative(r, neg);
  return v12;
}

int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)
{
  int neg = a->neg;
  if (neg == b->neg)
  {
    int v7 = BN_ucmp(a, b);
    if (v7 < 1)
    {
      if ((v7 & 0x80000000) == 0)
      {
        BN_zero((uint64_t)r);
        int neg = 0;
        int v12 = 1;
        goto LABEL_7;
      }
      int neg = b->neg == 0;
      int v8 = r;
      int v9 = b;
      unint64_t v10 = a;
    }
    else
    {
      int neg = a->neg;
      int v8 = r;
      int v9 = a;
      unint64_t v10 = b;
    }
    int v11 = BN_usub(v8, v9, v10);
  }
  else
  {
    int v11 = BN_uadd(r, a, b);
  }
  int v12 = v11;
LABEL_7:
  BN_set_negative(r, neg);
  return v12;
}

void bn_add_words_cold_1()
{
  __assert_rtn("bn_add_words", "bn_add.c", 79, "n >= 0");
}

void bn_sub_words_cold_1()
{
  __assert_rtn("bn_sub_words", "bn_add.c", 164, "n >= 0");
}

OTHERNAME *__cdecl d2i_OTHERNAME(OTHERNAME **a, const unsigned __int8 **in, uint64_t len)
{
  return (OTHERNAME *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &OTHERNAME_it);
}

int i2d_OTHERNAME(OTHERNAME *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &OTHERNAME_it);
}

OTHERNAME *OTHERNAME_new(void)
{
  return (OTHERNAME *)ASN1_item_new(&OTHERNAME_it);
}

void OTHERNAME_free(OTHERNAME *a)
{
}

EDIPARTYNAME *__cdecl d2i_EDIPARTYNAME(EDIPARTYNAME **a, const unsigned __int8 **in, uint64_t len)
{
  return (EDIPARTYNAME *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &EDIPARTYNAME_it);
}

int i2d_EDIPARTYNAME(EDIPARTYNAME *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &EDIPARTYNAME_it);
}

EDIPARTYNAME *EDIPARTYNAME_new(void)
{
  return (EDIPARTYNAME *)ASN1_item_new(&EDIPARTYNAME_it);
}

void EDIPARTYNAME_free(EDIPARTYNAME *a)
{
}

GENERAL_NAME *__cdecl d2i_GENERAL_NAME(GENERAL_NAME **a, const unsigned __int8 **in, uint64_t len)
{
  return (GENERAL_NAME *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &GENERAL_NAME_it);
}

int i2d_GENERAL_NAME(GENERAL_NAME *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &GENERAL_NAME_it);
}

GENERAL_NAME *GENERAL_NAME_new(void)
{
  return (GENERAL_NAME *)ASN1_item_new(&GENERAL_NAME_it);
}

void GENERAL_NAME_free(GENERAL_NAME *a)
{
}

GENERAL_NAMES *__cdecl d2i_GENERAL_NAMES(GENERAL_NAMES **a, const unsigned __int8 **in, uint64_t len)
{
  return (GENERAL_NAMES *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &GENERAL_NAMES_it);
}

int i2d_GENERAL_NAMES(GENERAL_NAMES *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &GENERAL_NAMES_it);
}

GENERAL_NAMES *GENERAL_NAMES_new(void)
{
  return (GENERAL_NAMES *)ASN1_item_new(&GENERAL_NAMES_it);
}

void GENERAL_NAMES_free(GENERAL_NAMES *a)
{
}

void *GENERAL_NAME_dup(void *x)
{
  return ASN1_item_dup(&GENERAL_NAME_it, x);
}

uint64_t GENERAL_NAME_cmp(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 && *(_DWORD *)a1 == *(_DWORD *)a2)
  {
    switch(*(_DWORD *)a1)
    {
      case 0:
        uint64_t v6 = *(void *)(a1 + 8);
        uint64_t v7 = *(void *)(a2 + 8);
        return OTHERNAME_cmp(v6, v7);
      case 1:
      case 2:
      case 3:
      case 6:
        int v4 = *(ASN1_STRING **)(a1 + 8);
        unint64_t v5 = *(ASN1_STRING **)(a2 + 8);
        goto LABEL_6;
      case 4:
        int v8 = *(const X509_NAME **)(a1 + 8);
        int v9 = *(const X509_NAME **)(a2 + 8);
        return X509_NAME_cmp(v8, v9);
      case 5:
        unint64_t v10 = *(ASN1_STRING ***)(a1 + 8);
        if (!v10) {
          return result;
        }
        int v11 = *(ASN1_STRING ***)(a2 + 8);
        if (!v11) {
          return result;
        }
        int v12 = *v11;
        if (*v10)
        {
          if (!v12) {
            return 1;
          }
          uint64_t result = ASN1_STRING_cmp(*v10, v12);
          if (result) {
            return result;
          }
        }
        else if (v12)
        {
          return 0xFFFFFFFFLL;
        }
        int v4 = v10[1];
        if (!v4) {
          return 0xFFFFFFFFLL;
        }
        unint64_t v5 = v11[1];
        if (!v5) {
          return 0xFFFFFFFFLL;
        }
LABEL_6:
        uint64_t result = ASN1_STRING_cmp(v4, v5);
        break;
      case 7:
        uint64_t v13 = *(ASN1_OCTET_STRING **)(a1 + 8);
        uint64_t v14 = *(ASN1_OCTET_STRING **)(a2 + 8);
        return ASN1_OCTET_STRING_cmp(v13, v14);
      case 8:
        unint64_t v15 = *(const ASN1_OBJECT **)(a1 + 8);
        unsigned int v16 = *(const ASN1_OBJECT **)(a2 + 8);
        return OBJ_cmp(v15, v16);
      default:
        return result;
    }
  }
  return result;
}

uint64_t OTHERNAME_cmp(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = OBJ_cmp(*(const ASN1_OBJECT **)a1, *(const ASN1_OBJECT **)a2);
      if (!result)
      {
        unint64_t v5 = *(const ASN1_OBJECT ***)(a1 + 8);
        uint64_t v6 = *(void *)(a2 + 8);
        return ASN1_TYPE_cmp(v5, v6);
      }
    }
  }
  return result;
}

uint64_t GENERAL_NAME_set0_value(uint64_t result, unsigned int a2, uint64_t a3)
{
  if (a2 <= 8) {
    *(void *)(result + 8) = a3;
  }
  *(_DWORD *)uint64_t result = a2;
  return result;
}

uint64_t GENERAL_NAME_get0_value(uint64_t a1, _DWORD *a2)
{
  if (a2) {
    *a2 = *(_DWORD *)a1;
  }
  if (*(_DWORD *)a1 > 8u) {
    return 0;
  }
  else {
    return *(void *)(a1 + 8);
  }
}

uint64_t GENERAL_NAME_set0_othername(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = (uint64_t)ASN1_item_new(&OTHERNAME_it);
  if (result)
  {
    *(void *)uint64_t result = a2;
    *(void *)(result + 8) = a3;
    *(void *)(a1 + 8) = result;
    uint64_t result = 1;
    *(_DWORD *)a1 = 0;
  }
  return result;
}

uint64_t GENERAL_NAME_get0_otherName(uint64_t a1, void *a2, void *a3)
{
  if (*(_DWORD *)a1) {
    return 0;
  }
  if (a2) {
    *a2 = **(void **)(a1 + 8);
  }
  if (a3) {
    *a3 = *(void *)(*(void *)(a1 + 8) + 8);
  }
  return 1;
}

int X509_check_purpose(X509 *x, int id, int ca)
{
  if (!x509v3_cache_extensions((uint64_t)x)) {
    return -1;
  }
  if (id == -1) {
    return 1;
  }
  int result = X509_PURPOSE_get_by_id(id);
  if (result != -1)
  {
    if (result > 8) {
      unint64_t v5 = sk_value((const STACK *)xptable, result - 9);
    }
    else {
      unint64_t v5 = (char *)&xstandard + 48 * result;
    }
    uint64_t v6 = (uint64_t (*)(void))*((void *)v5 + 2);
    return v6();
  }
  return result;
}

BOOL x509v3_cache_extensions(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  if ((v1 & 0x100) == 0)
  {
    CRYPTO_lock(9, 3, 0, 0);
    if (*(unsigned char *)(a1 + 57))
    {
LABEL_112:
      CRYPTO_lock(10, 3, 0, 0);
      uint64_t v1 = *(void *)(a1 + 56);
      return (v1 & 0x80) == 0;
    }
    int v3 = EVP_sha512();
    X509_digest((const X509 *)a1, v3, (unsigned __int8 *)(a1 + 144), 0);
    if (!X509_get_version((ASN1_INTEGER ***)a1))
    {
      *(void *)(a1 + 56) |= 0x40uLL;
      if (X509_get_ext_count((X509 *)a1)) {
        *(void *)(a1 + 56) |= 0x80uLL;
      }
    }
    int crit = 0;
    ext_d2int i = (BASIC_CONSTRAINTS *)X509_get_ext_d2i((X509 *)a1, 87, &crit, 0);
    if (ext_d2i)
    {
      unint64_t v5 = ext_d2i;
      cEVP_CIPHER_CTX a = ext_d2i->ca;
      if (ext_d2i->ca) {
        *(void *)(a1 + 56) |= 0x10uLL;
      }
      pathint len = ext_d2i->pathlen;
      if (pathlen)
      {
        if (!ca || pathlen->type == 258)
        {
          uint64_t v8 = 0;
          *(void *)(a1 + 56) |= 0x80uLL;
        }
        else
        {
          uint64_t v8 = ASN1_INTEGER_get(pathlen);
        }
      }
      else
      {
        uint64_t v8 = -1;
      }
      *(void *)(a1 + 48) = v8;
      BASIC_CONSTRAINTS_free(v5);
      uint64_t v9 = 1;
    }
    else
    {
      if (crit == -1)
      {
LABEL_19:
        unint64_t v10 = (ASN1_BIT_STRING *)X509_get_ext_d2i((X509 *)a1, 83, &crit, 0);
        if (v10)
        {
          int length = v10->length;
          if (v10->length < 1)
          {
            *(void *)(a1 + 64) = 0;
          }
          else
          {
            uint64_t data = v10->data;
            uint64_t v13 = *data;
            *(void *)(a1 + 64) = v13;
            if (length != 1) {
              *(void *)(a1 + 64) = v13 | ((unint64_t)data[1] << 8);
            }
          }
          *(void *)(a1 + 56) |= 2uLL;
          ASN1_BIT_STRING_free(v10);
        }
        else if (crit != -1)
        {
          *(void *)(a1 + 56) |= 0x80uLL;
        }
        *(void *)(a1 + 72) = 0;
        uint64_t v14 = (const STACK *)X509_get_ext_d2i((X509 *)a1, 126, &crit, 0);
        if (v14)
        {
          unint64_t v15 = (STACK *)v14;
          *(void *)(a1 + 56) |= 4uLL;
          int crit = 0;
          if (sk_num(v14) >= 1)
          {
            while (1)
            {
              unsigned int v16 = sk_value(v15, crit);
              int v17 = OBJ_obj2nid((const ASN1_OBJECT *)v16);
              if (v17 <= 179)
              {
                uint64_t v18 = 1;
                switch(v17)
                {
                  case 129:
                    goto LABEL_42;
                  case 130:
                    uint64_t v18 = 2;
                    goto LABEL_42;
                  case 131:
                    uint64_t v18 = 8;
                    goto LABEL_42;
                  case 132:
                    uint64_t v18 = 4;
                    goto LABEL_42;
                  case 133:
                    uint64_t v18 = 64;
                    goto LABEL_42;
                  case 137:
                  case 139:
                    uint64_t v18 = 16;
                    goto LABEL_42;
                  default:
                    goto LABEL_43;
                }
                goto LABEL_43;
              }
              if (v17 == 180) {
                break;
              }
              if (v17 == 297)
              {
                uint64_t v18 = 128;
                goto LABEL_42;
              }
              if (v17 == 910)
              {
                uint64_t v18 = 256;
LABEL_42:
                *(void *)(a1 + 72) |= v18;
              }
LABEL_43:
              int v19 = ++crit;
              if (v19 >= sk_num(v15)) {
                goto LABEL_44;
              }
            }
            uint64_t v18 = 32;
            goto LABEL_42;
          }
LABEL_44:
          sk_pop_free(v15, (void (__cdecl *)(void *))ASN1_OBJECT_free);
        }
        else if (crit != -1)
        {
          *(void *)(a1 + 56) |= 0x80uLL;
        }
        int v20 = (ASN1_BIT_STRING *)X509_get_ext_d2i((X509 *)a1, 71, &crit, 0);
        if (v20)
        {
          if (v20->length < 1) {
            uint64_t v21 = 0;
          }
          else {
            uint64_t v21 = *v20->data;
          }
          *(void *)(a1 + 8RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = v21;
          *(void *)(a1 + 56) |= 8uLL;
          ASN1_BIT_STRING_free(v20);
        }
        else if (crit != -1)
        {
          *(void *)(a1 + 56) |= 0x80uLL;
        }
        unint64_t v22 = X509_get_ext_d2i((X509 *)a1, 82, &crit, 0);
        *(void *)(a1 + 88) = v22;
        if (!v22 && crit != -1) {
          *(void *)(a1 + 56) |= 0x80uLL;
        }
        uint64_t v23 = X509_get_ext_d2i((X509 *)a1, 90, &crit, 0);
        *(void *)(a1 + 96) = v23;
        if (!v23 && crit != -1) {
          *(void *)(a1 + 56) |= 0x80uLL;
        }
        uint64_t subject_name = X509_get_subject_name((X509 *)a1);
        issuer_name = X509_get_issuer_name((X509 *)a1);
        if (!X509_NAME_cmp(subject_name, issuer_name))
        {
          *(void *)(a1 + 56) |= 0x20uLL;
          if (!X509_check_akid((X509 *)a1, *(void *)(a1 + 96)))
          {
            uint64_t v26 = *(void *)(a1 + 56);
            if ((v26 & 2) == 0 || (*(unsigned char *)(a1 + 64) & 4) != 0) {
              *(void *)(a1 + 56) = v26 | 0x2000;
            }
          }
        }
        unint64_t v27 = X509_get_ext_d2i((X509 *)a1, 85, &crit, 0);
        *(void *)(a1 + 112) = v27;
        if (!v27 && crit != -1) {
          *(void *)(a1 + 56) |= 0x80uLL;
        }
        unint64_t v28 = X509_get_ext_d2i((X509 *)a1, 666, &crit, 0);
        *(void *)(a1 + 12RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = v28;
        if (!v28 && crit != -1) {
          *(void *)(a1 + 56) |= 0x80uLL;
        }
        int v47 = 0;
        unint64_t v29 = (const STACK *)X509_get_ext_d2i((X509 *)a1, 103, &v47, 0);
        *(void *)(a1 + 104) = v29;
        if (v29 || v47 == -1)
        {
          int v47 = 0;
          if (sk_num(v29) >= 1)
          {
            do
            {
              unint64_t v30 = sk_value(*(const STACK **)(a1 + 104), v47);
              unint64_t v31 = v30;
              uint64_t v32 = *((void *)v30 + 1);
              if (v32)
              {
                int v33 = *(_DWORD *)v32;
                if (*(int *)v32 <= 0)
                {
                  int v35 = *((_DWORD *)v30 + 6);
                }
                else
                {
                  uint64_t v34 = *(unsigned __int8 **)(v32 + 8);
                  int v35 = *v34;
                  *((_DWORD *)v30 + 6) = v35;
                  if (v33 != 1) {
                    LOWORD(v35) = v35 | (v34[1] << 8);
                  }
                }
                *((_DWORD *)v30 + 6) = v35 & 0x807F;
              }
              else
              {
                *((_DWORD *)v30 + 6) = 32895;
              }
              if (*(void *)v30 && **(_DWORD **)v30 == 1)
              {
                if (sk_num(*((const STACK **)v30 + 2)) < 1) {
                  goto LABEL_90;
                }
                int v36 = 0;
                while (1)
                {
                  uint64_t v37 = sk_value(*((const STACK **)v31 + 2), v36);
                  if (*(_DWORD *)v37 == 4) {
                    break;
                  }
                  if (++v36 >= sk_num(*((const STACK **)v31 + 2))) {
                    goto LABEL_90;
                  }
                }
                uint64_t v38 = (X509_NAME *)*((void *)v37 + 1);
                if (!v38) {
LABEL_90:
                }
                  uint64_t v38 = X509_get_issuer_name((X509 *)a1);
                DIST_POINT_set_dpname(*(void *)v31, v38);
              }
              int v39 = ++v47;
            }
            while (v39 < sk_num(*(const STACK **)(a1 + 104)));
          }
        }
        else
        {
          *(void *)(a1 + 56) |= 0x80uLL;
        }
        unint64_t v40 = (STACK *)X509_get_ext_d2i((X509 *)a1, 290, &crit, 0);
        *(void *)(a1 + 128) = v40;
        if (!v40 && crit != -1) {
          *(void *)(a1 + 56) |= 0x80uLL;
        }
        if (!X509v3_addr_is_canonical(v40)) {
          *(void *)(a1 + 56) |= 0x80uLL;
        }
        unint64_t v41 = (uint64_t *)X509_get_ext_d2i((X509 *)a1, 291, &crit, 0);
        *(void *)(a1 + 136) = v41;
        if (!v41 && crit != -1) {
          *(void *)(a1 + 56) |= 0x80uLL;
        }
        if (!X509v3_asid_is_canonical(v41)) {
          *(void *)(a1 + 56) |= 0x80uLL;
        }
        int crit = 0;
        if (X509_get_ext_count((X509 *)a1) >= 1)
        {
          while (1)
          {
            ext = X509_get_ext((X509 *)a1, crit);
            object = X509_EXTENSION_get_object(ext);
            if (OBJ_obj2nid(object) == 857) {
              *(void *)(a1 + 56) |= 0x1000uLL;
            }
            if (X509_EXTENSION_get_critical(ext) && !X509_supported_extension(ext)) {
              break;
            }
            int v44 = ++crit;
            if (v44 >= X509_get_ext_count((X509 *)a1)) {
              goto LABEL_111;
            }
          }
          *(void *)(a1 + 56) |= 0x200uLL;
        }
LABEL_111:
        x509_verify_cert_info_populate(a1);
        *(void *)(a1 + 56) |= 0x100uLL;
        goto LABEL_112;
      }
      uint64_t v9 = 128;
    }
    *(void *)(a1 + 56) |= v9;
    goto LABEL_19;
  }
  return (v1 & 0x80) == 0;
}

int X509_PURPOSE_get_by_id(int id)
{
  int result = id - 1;
  if (result >= 9)
  {
    uint64_t v7 = v1;
    uint64_t v8 = v2;
    memset(v6, 0, sizeof(v6));
    LODWORD(v6[0]) = id;
    if (xptable)
    {
      int v5 = sk_find((STACK *)xptable, (char *)v6);
      if (v5 == -1) {
        return -1;
      }
      else {
        return v5 + 9;
      }
    }
    else
    {
      return -1;
    }
  }
  return result;
}

X509_PURPOSE *__cdecl X509_PURPOSE_get0(int idx)
{
  if (idx < 0) {
    return 0;
  }
  if (idx > 8) {
    return (X509_PURPOSE *)sk_value((const STACK *)xptable, idx - 9);
  }
  return (X509_PURPOSE *)((char *)&xstandard + 48 * idx);
}

int X509_PURPOSE_set(int *p, int purpose)
{
  if (X509_PURPOSE_get_by_id(purpose) == -1)
  {
    ERR_put_error(34, 4095, 146, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_purp.c", 149);
    return 0;
  }
  else
  {
    *unsigned int p = purpose;
    return 1;
  }
}

int X509_PURPOSE_get_count(void)
{
  if (xptable) {
    return sk_num((const STACK *)xptable) + 9;
  }
  else {
    return 9;
  }
}

int X509_PURPOSE_get_by_sname(char *sname)
{
  unint64_t v2 = 0;
  for (int i = (char *)&xstandard; ; i += 48)
  {
    int v4 = xptable ? sk_num((const STACK *)xptable) + 9 : 9;
    if ((uint64_t)v2 >= v4) {
      break;
    }
    int v5 = i;
    if (v2 >= 9) {
      int v5 = sk_value((const STACK *)xptable, (int)v2 - 9);
    }
    if (!strcmp(*((const char **)v5 + 4), sname)) {
      return v2;
    }
    ++v2;
  }
  LODWORD(v2) = -1;
  return v2;
}

int X509_PURPOSE_add(int id, int trust, int flags, int (__cdecl *ck)(const X509_PURPOSE *, const X509 *, int), char *name, char *sname, void *arg)
{
  if (name && sname)
  {
    unsigned int v14 = X509_PURPOSE_get_by_id(id);
    unsigned int v15 = v14;
    if (v14 == -1)
    {
      int v19 = (char *)malloc_type_malloc(0x30uLL, 0x109004064E8B8A4uLL);
      if (!v19)
      {
        int v17 = 65;
        int v18 = 235;
        goto LABEL_25;
      }
      unsigned int v16 = v19;
      *((_DWORD *)v19 + 2) = 1;
    }
    else if ((v14 & 0x80000000) != 0)
    {
      unsigned int v16 = 0;
    }
    else if (v14 > 8)
    {
      unsigned int v16 = sk_value((const STACK *)xptable, v14 - 9);
    }
    else
    {
      unsigned int v16 = (char *)&xstandard + 48 * v14;
    }
    int v20 = strdup(name);
    if (v20)
    {
      uint64_t v21 = strdup(sname);
      if (v21)
      {
        unsigned int v22 = flags & 0xFFFFFFFC;
        int v23 = *((_DWORD *)v16 + 2);
        if ((v23 & 2) != 0)
        {
          free(*((void **)v16 + 3));
          free(*((void **)v16 + 4));
          int v23 = *((_DWORD *)v16 + 2);
        }
        *((_DWORD *)v16 + engine_free_util((CRYPTO_EX_DATA *)e, 1) = trust;
        *((_DWORD *)v16 + 2) = v22 | v23 & 1 | 2;
        *(_DWORD *)unsigned int v16 = id;
        *((void *)v16 + 2) = ck;
        *((void *)v16 + 3) = v20;
        *((void *)v16 + 4) = v21;
        *((void *)v16 + 5) = arg;
        if (v15 != -1) {
          return 1;
        }
        uint64_t v24 = (STACK *)xptable;
        if (xptable
          || (uint64_t v24 = sk_new((int (__cdecl *)(const char *const *, const char *const *))xp_cmp),
              (xptable = (uint64_t)v24) != 0))
        {
          if (sk_push(v24, v16)) {
            return 1;
          }
        }
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    free(v20);
    free(v21);
    if (v15 == -1) {
      free(v16);
    }
    int v17 = 65;
    int v18 = 280;
  }
  else
  {
    int v17 = 107;
    int v18 = 222;
  }
LABEL_25:
  ERR_put_error(34, 4095, v17, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_purp.c", v18);
  return 0;
}

uint64_t xp_cmp(_DWORD **a1, _DWORD **a2)
{
  return (**a1 - **a2);
}

void X509_PURPOSE_cleanup(void)
{
  xptable = 0;
}

void xptable_free(void *a1)
{
  if (a1)
  {
    int v2 = *((_DWORD *)a1 + 2);
    if (v2)
    {
      if ((v2 & 2) != 0)
      {
        free(*((void **)a1 + 3));
        free(*((void **)a1 + 4));
      }
      free(a1);
    }
  }
}

int X509_PURPOSE_get_id(X509_PURPOSE *a1)
{
  return a1->purpose;
}

char *__cdecl X509_PURPOSE_get0_name(X509_PURPOSE *xp)
{
  return xp->name;
}

char *__cdecl X509_PURPOSE_get0_sname(X509_PURPOSE *xp)
{
  return xp->sname;
}

int X509_PURPOSE_get_trust(X509_PURPOSE *xp)
{
  return xp->trust;
}

int X509_supported_extension(X509_EXTENSION *ex)
{
  object = X509_EXTENSION_get_object(ex);
  int result = OBJ_obj2nid(object);
  *(_DWORD *)uint64_t key = result;
  if (result) {
    return OBJ_bsearch_(key, "G", 12, 4, (int (__cdecl *)(const void *, const void *))nid_cmp_BSEARCH_CMP_FN) != 0;
  }
  return result;
}

int X509_check_ca(X509 *x)
{
  x509v3_cache_extensions((uint64_t)x);
  return check_ca((uint64_t)x);
}

uint64_t check_ca(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  if ((v1 & 2) != 0 && (*(unsigned char *)(a1 + 64) & 4) == 0) {
    return 0;
  }
  if (v1) {
    return (v1 >> 4) & 1;
  }
  if ((*(void *)(a1 + 56) & 0x2040) == 0x2040) {
    uint64_t v2 = 3;
  }
  else {
    uint64_t v2 = 4;
  }
  if ((*(void *)(a1 + 56) & 0x2040) != 0x2040 && (*(void *)(a1 + 56) & 2) == 0)
  {
    if ((v1 & 8) != 0 && (*(unsigned char *)(a1 + 80) & 7) != 0) {
      return 5;
    }
    return 0;
  }
  return v2;
}

int X509_check_issued(X509 *issuer, X509 *subject)
{
  uint64_t subject_name = X509_get_subject_name(issuer);
  issuer_name = X509_get_issuer_name(subject);
  if (X509_NAME_cmp(subject_name, issuer_name)) {
    return 29;
  }
  if (!x509v3_cache_extensions((uint64_t)issuer) || !x509v3_cache_extensions((uint64_t)subject)) {
    return 1;
  }
  unint64_t ex_nscert = subject->ex_nscert;
  if (!ex_nscert || (int result = X509_check_akid(issuer, ex_nscert)) == 0)
  {
    if ((issuer->ex_pathlen & 2) == 0 || (issuer->ex_pcpathlen & 4) != 0) {
      return 0;
    }
    else {
      return 32;
    }
  }
  return result;
}

uint64_t X509_check_akid(X509 *x, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  int v4 = *(ASN1_OCTET_STRING **)a2;
  if (*(void *)a2)
  {
    ex_xkusage = (ASN1_OCTET_STRING *)x->ex_xkusage;
    if (ex_xkusage)
    {
      if (ASN1_OCTET_STRING_cmp(v4, ex_xkusage)) {
        return 30;
      }
    }
  }
  if (*(void *)(a2 + 16))
  {
    serialNumber = X509_get_serialNumber(x);
    if (ASN1_INTEGER_cmp(serialNumber, *(ASN1_INTEGER **)(a2 + 16))) {
      return 31;
    }
  }
  uint64_t v8 = *(const STACK **)(a2 + 8);
  if (v8 && sk_num(v8) >= 1)
  {
    int v9 = 0;
    while (1)
    {
      unint64_t v10 = sk_value(v8, v9);
      if (*(_DWORD *)v10 == 4) {
        break;
      }
      if (++v9 >= sk_num(v8)) {
        return 0;
      }
    }
    int v11 = (const X509_NAME *)*((void *)v10 + 1);
    if (v11)
    {
      issuer_name = X509_get_issuer_name(x);
      if (X509_NAME_cmp(v11, issuer_name)) {
        return 31;
      }
    }
  }
  return 0;
}

uint64_t X509_get_extension_flags(uint64_t a1)
{
  if (x509v3_cache_extensions(a1)) {
    return *(unsigned int *)(a1 + 56);
  }
  else {
    return 128;
  }
}

uint64_t X509_get_key_usage(uint64_t a1)
{
  uint64_t result = x509v3_cache_extensions(a1);
  if (result)
  {
    if ((*(unsigned char *)(a1 + 56) & 2) != 0) {
      return *(unsigned int *)(a1 + 64);
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t X509_get_extended_key_usage(uint64_t a1)
{
  uint64_t result = x509v3_cache_extensions(a1);
  if (result)
  {
    if ((*(unsigned char *)(a1 + 56) & 4) != 0) {
      return *(unsigned int *)(a1 + 72);
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t check_purpose_ssl_client(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = *(void *)(a2 + 56);
  if ((v4 & 4) != 0 && (*(unsigned char *)(a2 + 72) & 2) == 0) {
    return 0;
  }
  if (!a3) {
    return ((v4 & 2) == 0 || (*(unsigned char *)(a2 + 64) & 0x80) != 0) && ((v4 & 8) == 0 || (*(unsigned char *)(a2 + 80) & 0x80) != 0);
  }
  uint64_t result = check_ca(a2);
  if (result == 5)
  {
    if ((*(unsigned char *)(a2 + 80) & 4) != 0) {
      return 5;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t check_purpose_ssl_server(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = *(void *)(a2 + 56);
  if ((v4 & 4) != 0 && (*(unsigned char *)(a2 + 72) & 0x11) == 0) {
    return 0;
  }
  if (!a3) {
    return ((v4 & 8) == 0 || (*(unsigned char *)(a2 + 80) & 0x40) != 0) && ((v4 & 2) == 0 || (*(unsigned char *)(a2 + 64) & 0xA0) != 0);
  }
  uint64_t result = check_ca(a2);
  if (result == 5)
  {
    if ((*(unsigned char *)(a2 + 80) & 4) != 0) {
      return 5;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t check_purpose_ns_ssl_server(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result = check_purpose_ssl_server(a1, a2, a3);
  if (!a3 && result && (*(unsigned char *)(a2 + 56) & 2) != 0 && (*(unsigned char *)(a2 + 64) & 0x20) == 0) {
    return 0;
  }
  return result;
}

uint64_t check_purpose_smime_sign(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result = purpose_smime(a2, a3);
  if (!a3 && result && (*(unsigned char *)(a2 + 56) & 2) != 0 && (*(unsigned char *)(a2 + 64) & 0xC0) == 0) {
    return 0;
  }
  return result;
}

uint64_t check_purpose_smime_encrypt(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result = purpose_smime(a2, a3);
  if (!a3 && result && (*(unsigned char *)(a2 + 56) & 2) != 0 && (*(unsigned char *)(a2 + 64) & 0x20) == 0) {
    return 0;
  }
  return result;
}

uint64_t check_purpose_crl_sign(uint64_t a1, uint64_t a2, int a3)
{
  if (!a3) {
    return (*(unsigned char *)(a2 + 56) & 2) == 0 || (*(unsigned char *)(a2 + 64) & 2) != 0;
  }
  LODWORD(result) = check_ca(a2);
  if (result == 2) {
    return 0;
  }
  else {
    return result;
  }
}

uint64_t no_check()
{
  return 1;
}

uint64_t ocsp_helper(uint64_t a1, uint64_t a2, int a3)
{
  if (a3) {
    return check_ca(a2);
  }
  else {
    return 1;
  }
}

uint64_t check_purpose_timestamp_sign(int a1, X509 *x, int a3)
{
  if (a3)
  {
    return check_ca((uint64_t)x);
  }
  ex_pathint len = x->ex_pathlen;
  if ((ex_pathlen & 2) != 0)
  {
    uint64_t result = 0;
    if ((ex_pathlen & 4) == 0) {
      return result;
    }
    if ((x->ex_pcpathlen & 0xFFFFFFFFFFFFFF3FLL) != 0 || (x->ex_pcpathlen & 0xC0) == 0) {
      return result;
    }
  }
  else if ((ex_pathlen & 4) == 0)
  {
    return 0;
  }
  if (x->ex_flags != 64) {
    return 0;
  }
  int ext_by_NID = X509_get_ext_by_NID(x, 126, -1);
  if (ext_by_NID < 0) {
    return 1;
  }
  ext = X509_get_ext(x, ext_by_NID);
  uint64_t result = X509_EXTENSION_get_critical(ext);
  if (result) {
    return 1;
  }
  return result;
}

uint64_t purpose_smime(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(a1 + 56);
  if ((v3 & 4) != 0 && (*(unsigned char *)(a1 + 72) & 4) == 0) {
    return 0;
  }
  if (a2)
  {
    uint64_t result = check_ca(a1);
    if (result == 5)
    {
      if ((*(unsigned char *)(a1 + 80) & 2) != 0) {
        return 5;
      }
      else {
        return 0;
      }
    }
  }
  else if ((v3 & 8) != 0)
  {
    uint64_t v5 = *(void *)(a1 + 80);
    if ((v5 & 0x20) != 0) {
      return 1;
    }
    else {
      return (v5 >> 6) & 2;
    }
  }
  else
  {
    return 1;
  }
  return result;
}

uint64_t nid_cmp_BSEARCH_CMP_FN(_DWORD *a1, _DWORD *a2)
{
  return (*a1 - *a2);
}

char **EC_KEY_OpenSSL()
{
  return &openssl_ec_key_method;
}

uint64_t EC_KEY_get_default_method()
{
  return default_ec_key_meth;
}

char **EC_KEY_set_default_method(char **result)
{
  uint64_t v1 = &openssl_ec_key_method;
  if (result) {
    uint64_t v1 = result;
  }
  default_ec_key_meth = (uint64_t)v1;
  return result;
}

uint64_t EC_KEY_get_method(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t EC_KEY_set_method(ENGINE **a1, uint64_t a2)
{
  uint64_t v4 = (void (*)(ENGINE **))*((void *)*a1 + 3);
  if (v4) {
    v4(a1);
  }
  ENGINE_finish(a1[1]);
  *a1 = (ENGINE *)a2;
  a1[1] = 0;
  uint64_t v5 = *(uint64_t (**)(ENGINE **))(a2 + 16);
  if (!v5) {
    return 1;
  }
  return v5(a1);
}

uint64_t *EC_KEY_new_method(ENGINE *default_EC)
{
  uint64_t v2 = (uint64_t *)malloc_type_calloc(1uLL, 0x50uLL, 0x1060040AF32F034uLL);
  uint64_t v3 = v2;
  if (!v2)
  {
    ERR_put_error(16, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_kmeth.c", 142);
    return v3;
  }
  *uint64_t v2 = default_ec_key_meth;
  if (default_EC)
  {
    if (!ENGINE_init(default_EC))
    {
      int v6 = 149;
      goto LABEL_14;
    }
    v3[1] = (uint64_t)default_EC;
LABEL_7:
    uint64_t EC = ENGINE_get_EC((uint64_t)default_EC);
    uint64_t *v3 = EC;
    if (EC) {
      goto LABEL_8;
    }
    int v6 = 158;
LABEL_14:
    ERR_put_error(16, 4095, 38, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ec_kmeth.c", v6);
LABEL_15:
    EC_KEY_free((EC_KEY *)v3);
    return 0;
  }
  default_uint64_t EC = (ENGINE *)ENGINE_get_default_EC();
  v3[1] = (uint64_t)default_EC;
  if (default_EC) {
    goto LABEL_7;
  }
LABEL_8:
  *((_DWORD *)v3 + 4) = 1;
  *((_DWORD *)v3 + 15) = 0;
  v3[4] = 0;
  v3[5] = 0;
  _OWORD v3[3] = 0;
  *((_DWORD *)v3 + 12) = 0;
  *(uint64_t *)((char *)v3 + 52) = 0x100000004;
  v3[8] = 0;
  if (!CRYPTO_new_ex_data(6, v3, (CRYPTO_EX_DATA *)(v3 + 9))) {
    goto LABEL_15;
  }
  uint64_t v5 = *(unsigned int (**)(uint64_t *))(*v3 + 16);
  if (v5)
  {
    if (!v5(v3)) {
      goto LABEL_15;
    }
  }
  return v3;
}

_OWORD *EC_KEY_METHOD_new(long long *a1)
{
  uint64_t result = malloc_type_calloc(1uLL, 0x78uLL, 0x10D0040F56C2D54uLL);
  if (result)
  {
    if (a1)
    {
      long long v3 = *a1;
      long long v4 = a1[1];
      long long v5 = a1[3];
      result[2] = a1[2];
      result[3] = v5;
      *uint64_t result = v3;
      result[1] = v4;
      long long v6 = a1[4];
      long long v7 = a1[5];
      long long v8 = a1[6];
      *((void *)result + 14) = *((void *)a1 + 14);
      result[5] = v7;
      result[6] = v8;
      result[4] = v6;
    }
    *((_DWORD *)result + 2) |= 1u;
  }
  return result;
}

void EC_KEY_METHOD_free(void *a1)
{
  if (a1)
  {
    if (*((unsigned char *)a1 + 8)) {
      free(a1);
    }
  }
}

void *EC_KEY_METHOD_set_init(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  result[2] = a2;
  result[3] = a3;
  result[4] = a4;
  result[5] = a5;
  result[6] = a6;
  result[7] = a7;
  return result;
}

uint64_t EC_KEY_METHOD_set_keygen(uint64_t result, uint64_t a2)
{
  *(void *)(result + 64) = a2;
  return result;
}

uint64_t EC_KEY_METHOD_set_compute_key(uint64_t result, uint64_t a2)
{
  *(void *)(result + 72) = a2;
  return result;
}

void *EC_KEY_METHOD_set_sign(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  result[10] = a2;
  result[11] = a3;
  result[12] = a4;
  return result;
}

uint64_t EC_KEY_METHOD_set_verify(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(void *)(result + 104) = a2;
  *(void *)(result + 112) = a3;
  return result;
}

void *EC_KEY_METHOD_get_init(void *result, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7)
{
  if (a2) {
    *a2 = result[2];
  }
  if (a3) {
    *a3 = result[3];
  }
  if (a4) {
    *a4 = result[4];
  }
  if (a5) {
    *a5 = result[5];
  }
  if (a6) {
    *a6 = result[6];
  }
  if (a7) {
    *a7 = result[7];
  }
  return result;
}

uint64_t EC_KEY_METHOD_get_keygen(uint64_t result, void *a2)
{
  if (a2) {
    *a2 = *(void *)(result + 64);
  }
  return result;
}

uint64_t EC_KEY_METHOD_get_compute_key(uint64_t result, void *a2)
{
  if (a2) {
    *a2 = *(void *)(result + 72);
  }
  return result;
}

void *EC_KEY_METHOD_get_sign(void *result, void *a2, void *a3, void *a4)
{
  if (a2) {
    *a2 = result[10];
  }
  if (a3) {
    *a3 = result[11];
  }
  if (a4) {
    *a4 = result[12];
  }
  return result;
}

uint64_t EC_KEY_METHOD_get_verify(uint64_t result, void *a2, void *a3)
{
  if (a2) {
    *a2 = *(void *)(result + 104);
  }
  if (a3) {
    *a3 = *(void *)(result + 112);
  }
  return result;
}

void BF_ofb64_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, const BF_KEY *schedule, unsigned __int8 *ivec, int *num)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  int v7 = *num;
  int v8 = *ivec;
  int v9 = ivec[1];
  int v10 = ivec[2];
  int v11 = ivec[3];
  unsigned int v12 = (v8 << 24) | (v9 << 16) | (v10 << 8) | v11;
  int v13 = ivec[4];
  int v14 = ivec[5];
  int v15 = ivec[6];
  int v16 = ivec[7];
  int v17 = (v13 << 24) | (v14 << 16) | (v15 << 8) | v16;
  unsigned int data = v12;
  int v26 = v17;
  LOBYTE(v27) = v8;
  BYTE1(v27) = v9;
  BYTE2(v27) = v10;
  HIBYTE(v27) = v11;
  LOBYTE(v28) = v13;
  BYTE1(v28) = v14;
  BYTE2(v28) = v15;
  HIBYTE(v28) = v16;
  if (length)
  {
    uint64_t v20 = length;
    int v23 = 0;
    do
    {
      if (!v7)
      {
        BF_encrypt(&data, schedule);
        unsigned int v12 = data;
        int v17 = v26;
        unsigned int v27 = bswap32(data);
        unsigned int v28 = bswap32(v26);
        ++v23;
      }
      char v24 = *in++;
      *out++ = *((unsigned char *)&v27 + v7) ^ v24;
      int v7 = (v7 + 1) & 7;
      --v20;
    }
    while (v20);
    if (v23)
    {
      *ivec = HIBYTE(v12);
      ivec[1] = BYTE2(v12);
      ivec[2] = BYTE1(v12);
      ivec[3] = v12;
      ivec[4] = HIBYTE(v17);
      ivec[5] = BYTE2(v17);
      ivec[6] = BYTE1(v17);
      ivec[7] = v17;
    }
  }
  *uint64_t num = v7;
}

const EVP_CIPHER *EVP_bf_cbc(void)
{
  return (const EVP_CIPHER *)&bf_cbc;
}

const EVP_CIPHER *EVP_bf_cfb64(void)
{
  return (const EVP_CIPHER *)&bf_cfb64;
}

const EVP_CIPHER *EVP_bf_ofb(void)
{
  return (const EVP_CIPHER *)&bf_ofb;
}

const EVP_CIPHER *EVP_bf_ecb(void)
{
  return (const EVP_CIPHER *)&bf_ecb;
}

uint64_t bf_init_key(const EVP_CIPHER_CTX *a1, const unsigned __int8 *a2)
{
  cipher_unsigned int data = (BF_KEY *)a1->cipher_data;
  int v4 = EVP_CIPHER_CTX_key_length(a1);
  BF_set_key(cipher_data, v4, a2);
  return 1;
}

uint64_t bf_cbc_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t length)
{
  for (unint64_t i = length; i > 0x7FFFFFFFFFFFFEFFLL; out += 0x7FFFFFFFFFFFFF00)
  {
    BF_cbc_encrypt(in, out, 0x7FFFFFFFFFFFFF00, *(const BF_KEY **)(a1 + 120), (unsigned __int8 *)(a1 + 40), *(_DWORD *)(a1 + 16));
    i -= 0x7FFFFFFFFFFFFF00;
    in += 0x7FFFFFFFFFFFFF00;
  }
  if (i) {
    BF_cbc_encrypt(in, out, i, *(const BF_KEY **)(a1 + 120), (unsigned __int8 *)(a1 + 40), *(_DWORD *)(a1 + 16));
  }
  return 1;
}

uint64_t bf_cfb64_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t a4)
{
  if (a4)
  {
    unint64_t v4 = a4;
    if (a4 >= 0x7FFFFFFFFFFFFF00) {
      unint64_t v8 = 0x7FFFFFFFFFFFFF00;
    }
    else {
      unint64_t v8 = a4;
    }
    int v9 = (unsigned __int8 *)(a1 + 40);
    int v10 = (int *)(a1 + 88);
    do
    {
      BF_cfb64_encrypt(in, out, v8, *(const BF_KEY **)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16));
      in += v8;
      out += v8;
      v4 -= v8;
      if (v4 < v8) {
        unint64_t v8 = v4;
      }
    }
    while (v4);
  }
  return 1;
}

uint64_t bf_ofb_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t length)
{
  for (unint64_t i = length; i > 0x7FFFFFFFFFFFFEFFLL; out += 0x7FFFFFFFFFFFFF00)
  {
    BF_ofb64_encrypt(in, out, 0x7FFFFFFFFFFFFF00, *(const BF_KEY **)(a1 + 120), (unsigned __int8 *)(a1 + 40), (int *)(a1 + 88));
    i -= 0x7FFFFFFFFFFFFF00;
    in += 0x7FFFFFFFFFFFFF00;
  }
  if (i) {
    BF_ofb64_encrypt(in, out, i, *(const BF_KEY **)(a1 + 120), (unsigned __int8 *)(a1 + 40), (int *)(a1 + 88));
  }
  return 1;
}

uint64_t bf_ecb_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4 = *(int *)(*(void *)a1 + 4);
  unint64_t v5 = a4 - v4;
  if (a4 >= v4)
  {
    unint64_t v9 = 0;
    do
    {
      BF_ecb_encrypt((const unsigned __int8 *)(a3 + v9), (unsigned __int8 *)(a2 + v9), *(const BF_KEY **)(a1 + 120), *(_DWORD *)(a1 + 16));
      v9 += v4;
    }
    while (v9 <= v5);
  }
  return 1;
}

void ERR_load_DH_strings(void)
{
  if (!ERR_func_error_string(DH_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&DH_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&DH_str_reasons);
  }
}

int DH_generate_parameters_ex(DH *dh, int prime_len, int generator, BN_GENCB *cb)
{
  LODWORD(v5) = generator;
  unint64_t v8 = *(uint64_t (**)(void))(*(void *)&dh->ex_data.dummy + 64);
  if (!v8)
  {
    int v10 = BN_CTX_new();
    if (!v10)
    {
      ERR_put_error(5, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_gen.c", 168);
      return 0;
    }
    int v11 = v10;
    BN_CTX_start(v10);
    unsigned int v12 = BN_CTX_get(v11);
    if (!v12) {
      goto LABEL_14;
    }
    int v13 = v12;
    int v14 = BN_CTX_get(v11);
    if (!v14) {
      goto LABEL_14;
    }
    int v15 = v14;
    if (!dh->p)
    {
      int v16 = BN_new();
      dh->unsigned int p = v16;
      if (!v16) {
        goto LABEL_14;
      }
    }
    if (!dh->g)
    {
      int v17 = BN_new();
      dh->g = v17;
      if (!v17) {
        goto LABEL_14;
      }
    }
    if ((int)v5 > 1)
    {
      if (v5 == 5)
      {
        if (!BN_set_word(v13, 0xAuLL) || !BN_set_word(v15, 3uLL)) {
          goto LABEL_14;
        }
        unint64_t v5 = 5;
      }
      else if (v5 == 2)
      {
        if (!BN_set_word(v13, 0x18uLL) || !BN_set_word(v15, 0xBuLL)) {
          goto LABEL_14;
        }
        unint64_t v5 = 2;
      }
      else
      {
        if (!BN_set_word(v13, 2uLL) || !BN_set_word(v15, 1uLL)) {
          goto LABEL_14;
        }
        unint64_t v5 = v5;
      }
      if (BN_generate_prime_ex(dh->p, prime_len, 1, v13, v15, cb) && BN_GENCB_call(cb, 3, 0) && BN_set_word(dh->g, v5))
      {
        int v18 = 1;
        goto LABEL_15;
      }
    }
    else
    {
      ERR_put_error(5, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_gen.c", 128);
    }
LABEL_14:
    ERR_put_error(5, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_gen.c", 168);
    int v18 = 0;
LABEL_15:
    BN_CTX_end(v11);
    BN_CTX_free(v11);
    return v18;
  }
  return v8();
}

DH *__cdecl DH_generate_parameters(int prime_len, int generator, void (__cdecl *callback)(int, int, void *), void *cb_arg)
{
  unint64_t v8 = DH_new();
  if (v8)
  {
    memset(&cb, 0, sizeof(cb));
    BN_GENCB_set_old((uint64_t)&cb, (uint64_t)callback, (uint64_t)cb_arg);
    if (!DH_generate_parameters_ex(v8, prime_len, generator, &cb))
    {
      DH_free(v8);
      return 0;
    }
  }
  return v8;
}

const CRYPTO_EX_DATA_IMPL *CRYPTO_get_ex_data_implementation(void)
{
  uint64_t result = (const CRYPTO_EX_DATA_IMPL *)impl;
  if (!impl)
  {
    impl_check();
    return (const CRYPTO_EX_DATA_IMPL *)impl;
  }
  return result;
}

void impl_check()
{
  CRYPTO_lock(9, 2, 0, 0);
  if (!impl) {
    impl = (uint64_t)impl_default;
  }
  CRYPTO_lock(10, 2, 0, 0);
}

int CRYPTO_set_ex_data_implementation(const CRYPTO_EX_DATA_IMPL *i)
{
  CRYPTO_lock(9, 2, 0, 0);
  int v2 = 0;
  if (!impl)
  {
    impl = (uint64_t)i;
    int v2 = 1;
  }
  CRYPTO_lock(10, 2, 0, 0);
  return v2;
}

int CRYPTO_ex_data_new_class(void)
{
  uint64_t v0 = (uint64_t (**)(void))impl;
  if (!impl)
  {
    impl_check();
    uint64_t v0 = (uint64_t (**)(void))impl;
  }
  uint64_t v1 = *v0;
  return v1();
}

void CRYPTO_cleanup_all_ex_data(void)
{
  uint64_t v0 = impl;
  if (!impl)
  {
    impl_check();
    uint64_t v0 = impl;
  }
  uint64_t v1 = *(void (**)(void))(v0 + 8);
  v1();
}

int CRYPTO_get_ex_new_index(int class_index, uint64_t argl, void *argp, CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
  uint64_t v11 = *(void *)&class_index;
  uint64_t v12 = impl;
  if (!impl)
  {
    impl_check();
    uint64_t v12 = impl;
  }
  int v13 = *(uint64_t (**)(uint64_t, uint64_t, void *, CRYPTO_EX_new *, CRYPTO_EX_dup *, CRYPTO_EX_free *))(v12 + 16);
  return v13(v11, argl, argp, new_func, dup_func, free_func);
}

int CRYPTO_new_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)
{
  uint64_t v5 = *(void *)&class_index;
  uint64_t v6 = impl;
  if (!impl)
  {
    impl_check();
    uint64_t v6 = impl;
  }
  int v7 = *(uint64_t (**)(uint64_t, void *, CRYPTO_EX_DATA *))(v6 + 24);
  return v7(v5, obj, ad);
}

int CRYPTO_dup_ex_data(int class_index, CRYPTO_EX_DATA *to, CRYPTO_EX_DATA *from)
{
  uint64_t v5 = *(void *)&class_index;
  uint64_t v6 = impl;
  if (!impl)
  {
    impl_check();
    uint64_t v6 = impl;
  }
  int v7 = *(uint64_t (**)(uint64_t, CRYPTO_EX_DATA *, CRYPTO_EX_DATA *))(v6 + 32);
  return v7(v5, to, from);
}

void CRYPTO_free_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad)
{
  uint64_t v5 = *(void *)&class_index;
  uint64_t v6 = impl;
  if (!impl)
  {
    impl_check();
    uint64_t v6 = impl;
  }
  int v7 = *(void (**)(uint64_t, void *, CRYPTO_EX_DATA *))(v6 + 40);
  v7(v5, obj, ad);
}

int CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad, int idx, void *val)
{
  uint64_t sk = ad->sk;
  if (sk || (uint64_t sk = sk_new_null(), (ad->uint64_t sk = sk) != 0))
  {
    int v7 = sk_num(sk);
    if (v7 > idx)
    {
LABEL_7:
      sk_set(ad->sk, idx, (char *)val);
      return 1;
    }
    int v8 = idx - v7 + 1;
    while (sk_push(ad->sk, 0))
    {
      if (!--v8) {
        goto LABEL_7;
      }
    }
    int v10 = 619;
  }
  else
  {
    int v10 = 611;
  }
  ERR_put_error(15, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ex_data.c", v10);
  return 0;
}

void *__cdecl CRYPTO_get_ex_data(const CRYPTO_EX_DATA *ad, int idx)
{
  uint64_t sk = ad->sk;
  if (!sk || sk_num(sk) <= idx) {
    return 0;
  }
  uint64_t v5 = ad->sk;
  return sk_value(v5, idx);
}

uint64_t int_new_class()
{
  CRYPTO_lock(9, 2, 0, 0);
  uint64_t v0 = ex_class++;
  CRYPTO_lock(10, 2, 0, 0);
  return v0;
}

void int_cleanup()
{
  uint64_t v0 = (LHASH *)ex_data;
  if (!ex_data)
  {
    if (!ex_data_check()) {
      return;
    }
    uint64_t v0 = (LHASH *)ex_data;
  }
  lh_doall(v0, (LHASH_DOALL_FN_TYPE)def_cleanup_cb);
  lh_free((LHASH *)ex_data);
  ex_unsigned int data = 0;
  impl = 0;
}

uint64_t int_get_new_index(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = def_get_class(a1);
  if (!v11) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v12 = v11;
  int v13 = malloc_type_malloc(0x28uLL, 0x1080040EC4B14DAuLL);
  if (!v13)
  {
    ERR_put_error(15, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ex_data.c", 351);
    return 0xFFFFFFFFLL;
  }
  int v14 = v13;
  void *v13 = a2;
  v13[1] = a3;
  _OWORD v13[3] = a6;
  v13[4] = a5;
  _OWORD v13[2] = a4;
  CRYPTO_lock(9, 2, 0, 0);
  while (1)
  {
    int v15 = sk_num((const STACK *)v12[1]);
    uint64_t v16 = *((unsigned int *)v12 + 4);
    if (v15 > (int)v16) {
      break;
    }
    if (!sk_push((STACK *)v12[1], 0))
    {
      ERR_put_error(15, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ex_data.c", 362);
      free(v14);
      uint64_t v16 = 0xFFFFFFFFLL;
      goto LABEL_10;
    }
  }
  *((_DWORD *)v12 + 4) = v16 + 1;
  sk_set((STACK *)v12[1], v16, (char *)v14);
LABEL_10:
  CRYPTO_lock(10, 2, 0, 0);
  return v16;
}

uint64_t int_new_ex_data(unsigned int a1, uint64_t a2, const CRYPTO_EX_DATA *a3)
{
  uint64_t result = (uint64_t)def_get_class(a1);
  if (result)
  {
    uint64_t v6 = result;
    a3->uint64_t sk = 0;
    CRYPTO_lock(5, 2, 0, 0);
    int v7 = sk_num(*(const STACK **)(v6 + 8));
    if (v7 < 1)
    {
      int v8 = 0;
    }
    else
    {
      int v8 = reallocarray(0, v7, 8uLL);
      if (v8)
      {
        uint64_t v9 = 0;
        do
        {
          v8[v9] = sk_value(*(const STACK **)(v6 + 8), v9);
          ++v9;
        }
        while (v7 != v9);
      }
    }
    CRYPTO_lock(6, 2, 0, 0);
    if (v7 < 1 || v8)
    {
      if (v7 >= 1)
      {
        for (uint64_t i = 0; i != v7; ++i)
        {
          uint64_t v11 = v8[i];
          if (v11)
          {
            if (*(void *)(v11 + 16))
            {
              uint64_t v12 = CRYPTO_get_ex_data(a3, i);
              (*(void (**)(uint64_t, void *, const CRYPTO_EX_DATA *, uint64_t, void, void))(v8[i] + 16))(a2, v12, a3, i, *(void *)v8[i], *(void *)(v8[i] + 8));
            }
          }
        }
      }
      free(v8);
      return 1;
    }
    else
    {
      ERR_put_error(15, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ex_data.c", 439);
      return 0;
    }
  }
  return result;
}

uint64_t int_dup_ex_data(unsigned int a1, CRYPTO_EX_DATA *a2, const CRYPTO_EX_DATA *a3)
{
  if (a3->sk)
  {
    uint64_t result = (uint64_t)def_get_class(a1);
    if (!result) {
      return result;
    }
    uint64_t v6 = result;
    unint64_t val = 0;
    CRYPTO_lock(5, 2, 0, 0);
    LODWORD(v7) = sk_num(*(const STACK **)(v6 + 8));
    int v8 = sk_num(a3->sk);
    if (v8 >= (int)v7) {
      unint64_t v7 = v7;
    }
    else {
      unint64_t v7 = v8;
    }
    if ((int)v7 < 1)
    {
      uint64_t v9 = 0;
    }
    else
    {
      uint64_t v9 = reallocarray(0, v7, 8uLL);
      if (v9)
      {
        for (uint64_t i = 0; i != v7; ++i)
          v9[i] = sk_value(*(const STACK **)(v6 + 8), i);
      }
    }
    CRYPTO_lock(6, 2, 0, 0);
    if ((int)v7 >= 1 && !v9)
    {
      ERR_put_error(15, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ex_data.c", 483);
      return 0;
    }
    if ((int)v7 >= 1)
    {
      for (uint64_t j = 0; j != v7; ++j)
      {
        uint64_t v12 = CRYPTO_get_ex_data(a3, j);
        unint64_t val = v12;
        int v13 = (void *)v9[j];
        if (v13)
        {
          int v14 = (void (*)(CRYPTO_EX_DATA *, const CRYPTO_EX_DATA *, void **, uint64_t, void, void))v13[4];
          if (v14)
          {
            v14(a2, a3, &val, j, *v13, v13[1]);
            uint64_t v12 = val;
          }
        }
        CRYPTO_set_ex_data(a2, j, v12);
      }
    }
    free(v9);
  }
  return 1;
}

void int_free_ex_data(unsigned int a1, uint64_t a2, const CRYPTO_EX_DATA *a3)
{
  uint64_t v5 = def_get_class(a1);
  if (v5)
  {
    uint64_t v6 = v5;
    CRYPTO_lock(5, 2, 0, 0);
    int v7 = sk_num((const STACK *)v6[1]);
    if (v7 < 1)
    {
      int v8 = 0;
    }
    else
    {
      int v8 = reallocarray(0, v7, 8uLL);
      if (v8)
      {
        for (uint64_t i = 0; i != v7; ++i)
          v8[i] = sk_value((const STACK *)v6[1], i);
      }
    }
    CRYPTO_lock(6, 2, 0, 0);
    if (v7 < 1 || v8)
    {
      if (v7 >= 1)
      {
        for (uint64_t j = 0; j != v7; ++j)
        {
          uint64_t v11 = v8[j];
          if (v11 && *(void *)(v11 + 24))
          {
            uint64_t v12 = CRYPTO_get_ex_data(a3, j);
            (*(void (**)(uint64_t, void *, const CRYPTO_EX_DATA *, uint64_t, void, void))(v8[j] + 24))(a2, v12, a3, j, *(void *)v8[j], *(void *)(v8[j] + 8));
          }
        }
      }
      free(v8);
      if (a3->sk)
      {
        sk_free(a3->sk);
        a3->uint64_t sk = 0;
      }
    }
    else
    {
      ERR_put_error(15, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ex_data.c", 521);
    }
  }
}

BOOL ex_data_check()
{
  CRYPTO_lock(9, 2, 0, 0);
  if (ex_data)
  {
    BOOL v0 = 1;
  }
  else
  {
    ex_unsigned int data = (uint64_t)lh_new((LHASH_HASH_FN_TYPE)ex_class_item_LHASH_HASH, (LHASH_COMP_FN_TYPE)ex_class_item_LHASH_COMP);
    BOOL v0 = ex_data != 0;
  }
  CRYPTO_lock(10, 2, 0, 0);
  return v0;
}

void def_cleanup_cb(STACK **a1)
{
  sk_pop_free(a1[1], def_cleanup_util_cb);
  free(a1);
}

uint64_t ex_class_item_LHASH_HASH(int *a1)
{
  return *a1;
}

uint64_t ex_class_item_LHASH_COMP(_DWORD *a1, _DWORD *a2)
{
  return (*a1 - *a2);
}

void *def_get_class(unsigned int a1)
{
  if (!ex_data && !ex_data_check()) {
    return 0;
  }
  data[1] = 0;
  unsigned char data[2] = 0;
  data[0] = a1;
  if (!OPENSSL_init_crypto(0)) {
    return 0;
  }
  CRYPTO_lock(9, 2, 0, 0);
  int v2 = lh_retrieve((LHASH *)ex_data, data);
  if (!v2)
  {
    long long v3 = malloc_type_malloc(0x18uLL, 0x1020040903548AEuLL);
    if (v3)
    {
      int v2 = v3;
      _DWORD *v3 = a1;
      v3[4] = 0;
      unint64_t v4 = sk_new_null();
      v2[1] = v4;
      if (v4)
      {
        lh_insert((LHASH *)ex_data, v2);
        goto LABEL_5;
      }
      free(v2);
    }
    CRYPTO_lock(10, 2, 0, 0);
    ERR_put_error(15, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ex_data.c", 337);
    return 0;
  }
LABEL_5:
  CRYPTO_lock(10, 2, 0, 0);
  return v2;
}

void DES_ede3_cfb64_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, DES_key_schedule *ks1, DES_key_schedule *ks2, DES_key_schedule *ks3, DES_cblock *ivec, int *num, int enc)
{
  uint64_t v14 = length;
  v26[1] = *MEMORY[0x263EF8340];
  int v17 = *num;
  if (enc)
  {
    if (length)
    {
      do
      {
        if (!v17)
        {
          v26[0] = *(void *)ivec;
          DES_encrypt3((unsigned int *)v26, ks1, ks2, ks3);
          __int16 v18 = WORD1(v26[0]);
          int v19 = HIDWORD(v26[0]);
          *(_WORD *)ivec = v26[0];
          *(_WORD *)&(*ivec)[2] = v18;
          *(_DWORD *)&(*ivec)[4] = v19;
        }
        char v20 = *in++;
        unsigned __int8 v21 = (*ivec)[v17];
        *out++ = v21 ^ v20;
        (*ivec)[v17] = v21 ^ v20;
        int v17 = (v17 + 1) & 7;
        --v14;
      }
      while (v14);
    }
  }
  else if (length)
  {
    do
    {
      if (!v17)
      {
        v26[0] = *(void *)ivec;
        DES_encrypt3((unsigned int *)v26, ks1, ks2, ks3);
        __int16 v22 = WORD1(v26[0]);
        int v23 = HIDWORD(v26[0]);
        *(_WORD *)ivec = v26[0];
        *(_WORD *)&(*ivec)[2] = v22;
        *(_DWORD *)&(*ivec)[4] = v23;
      }
      unsigned __int8 v24 = *in++;
      unsigned __int8 v25 = (*ivec)[v17];
      (*ivec)[v17] = v24;
      *out++ = v25 ^ v24;
      int v17 = (v17 + 1) & 7;
      --v14;
    }
    while (v14);
  }
  *uint64_t num = v17;
}

void DES_ede3_cfb_encrypt(const unsigned __int8 *in, unsigned __int8 *out, int numbits, uint64_t length, DES_key_schedule *ks1, DES_key_schedule *ks2, DES_key_schedule *ks3, DES_cblock *ivec, int enc)
{
  uint64_t v71 = *MEMORY[0x263EF8340];
  if (numbits <= 64)
  {
    int v10 = ks3;
    unint64_t v11 = length;
    unint64_t v14 = (numbits + 7) >> 3;
    unsigned int v16 = *(_DWORD *)ivec;
    unsigned int v15 = *(_DWORD *)&(*ivec)[4];
    if (enc)
    {
      if (v14 <= length)
      {
        unsigned int v17 = numbits - (v9 & 0xFFFFFFF8);
        uint32x4_t v59 = (uint32x4_t)vnegq_s32(vdupq_n_s32(8 - v17));
        uint32x4_t v61 = (uint32x4_t)vdupq_n_s32(v17);
        do
        {
          unsigned int data = v16;
          unsigned int v70 = v15;
          DES_encrypt3(&data, ks1, ks2, v10);
          int v18 = 0;
          int v19 = &in[v14];
          int v20 = 0;
          int v21 = numbits;
          switch(v14)
          {
            case 1uLL:
              goto LABEL_13;
            case 2uLL:
              goto LABEL_12;
            case 3uLL:
              goto LABEL_11;
            case 4uLL:
              goto LABEL_10;
            case 5uLL:
              goto LABEL_9;
            case 6uLL:
              goto LABEL_8;
            case 7uLL:
              goto LABEL_7;
            case 8uLL:
              int v22 = *--v19;
              int v18 = v22 << 24;
LABEL_7:
              int v23 = *--v19;
              v18 |= v23 << 16;
LABEL_8:
              int v24 = *--v19;
              v18 |= v24 << 8;
LABEL_9:
              int v25 = *--v19;
              v18 |= v25;
LABEL_10:
              int v20 = v18;
              int v26 = *--v19;
              int v18 = v26 << 24;
LABEL_11:
              int v27 = *--v19;
              v18 |= v27 << 16;
LABEL_12:
              int v28 = *--v19;
              v18 |= v28 << 8;
LABEL_13:
              int v29 = *--v19;
              v18 |= v29;
              break;
            default:
              int v21 = numbits;
              break;
          }
          unsigned int v30 = data ^ v18;
          int v31 = v70 ^ v20;
          uint64_t v32 = &out[v14];
          switch(v14)
          {
            case 1uLL:
              goto LABEL_22;
            case 2uLL:
              goto LABEL_21;
            case 3uLL:
              goto LABEL_20;
            case 4uLL:
              goto LABEL_19;
            case 5uLL:
              goto LABEL_18;
            case 6uLL:
              goto LABEL_17;
            case 7uLL:
              goto LABEL_16;
            case 8uLL:
              *--uint64_t v32 = HIBYTE(v31);
LABEL_16:
              *--uint64_t v32 = BYTE2(v31);
LABEL_17:
              *--uint64_t v32 = BYTE1(v31);
LABEL_18:
              *--uint64_t v32 = v31;
LABEL_19:
              *--uint64_t v32 = HIBYTE(v30);
LABEL_20:
              *--uint64_t v32 = BYTE2(v30);
LABEL_21:
              *--uint64_t v32 = BYTE1(v30);
LABEL_22:
              *--uint64_t v32 = v30;
              break;
            default:
              break;
          }
          if (v21 != 32)
          {
            if (v21 == 64)
            {
              unsigned int v15 = v30;
              unsigned int v30 = v31;
            }
            else
            {
              *(_DWORD *)int v67 = v16;
              *(_DWORD *)&v67[4] = v15;
              *(_DWORD *)&v67[8] = v30;
              int v68 = v31;
              __memmove_chk();
              if (v17)
              {
                int v33 = v67;
                int8x8_t v34 = vld1_dup_s8(v33);
                uint16x8_t v35 = vmovl_u8((uint8x8_t)vext_s8(v34, *(int8x8_t *)&v67[1], 7uLL));
                uint16x8_t v36 = vmovl_u8(*(uint8x8_t *)&v67[1]);
                *(int8x8_t *)int v67 = vmovn_s16(vuzp1q_s16((int16x8_t)vorrq_s8((int8x16_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)v36.i8), v59), (int8x16_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)v35.i8), v61)), (int16x8_t)vorrq_s8((int8x16_t)vshlq_u32(vmovl_high_u16(v36), v59), (int8x16_t)vshlq_u32(vmovl_high_u16(v35), v61))));
              }
              unsigned int v15 = *(_DWORD *)v67;
              unsigned int v30 = *(_DWORD *)&v67[4];
            }
          }
          unsigned int v16 = v15;
          v11 -= v14;
          unsigned __int8 in = &v19[v14];
          unsigned __int8 out = &v32[v14];
          unsigned int v15 = v30;
        }
        while (v11 >= v14);
        goto LABEL_60;
      }
    }
    else if (v14 <= length)
    {
      unsigned int v37 = numbits - (v9 & 0xFFFFFFF8);
      uint32x4_t v60 = (uint32x4_t)vdupq_n_s32(v37);
      unsigned int v62 = v37;
      uint32x4_t v57 = (uint32x4_t)vnegq_s32(vdupq_n_s32(8 - v37));
      unsigned int v38 = *(_DWORD *)ivec;
      do
      {
        unsigned int data = v38;
        unsigned int v70 = v15;
        DES_encrypt3(&data, ks1, ks2, v10);
        unsigned int v39 = 0;
        unint64_t v40 = &in[v14];
        unsigned int v41 = 0;
        switch(v14)
        {
          case 1uLL:
            goto LABEL_43;
          case 2uLL:
            goto LABEL_42;
          case 3uLL:
            goto LABEL_41;
          case 4uLL:
            goto LABEL_40;
          case 5uLL:
            goto LABEL_39;
          case 6uLL:
            goto LABEL_38;
          case 7uLL:
            goto LABEL_37;
          case 8uLL:
            int v42 = *--v40;
            unsigned int v39 = v42 << 24;
LABEL_37:
            int v43 = *--v40;
            v39 |= v43 << 16;
LABEL_38:
            int v44 = *--v40;
            v39 |= v44 << 8;
LABEL_39:
            int v45 = *--v40;
            v39 |= v45;
LABEL_40:
            unsigned int v41 = v39;
            int v46 = *--v40;
            unsigned int v39 = v46 << 24;
LABEL_41:
            int v47 = *--v40;
            v39 |= v47 << 16;
LABEL_42:
            int v48 = *--v40;
            v39 |= v48 << 8;
LABEL_43:
            int v49 = *--v40;
            v39 |= v49;
            break;
          default:
            break;
        }
        if (numbits == 32)
        {
          unsigned int v16 = v15;
          unsigned int v30 = v39;
        }
        else
        {
          unsigned int v16 = v39;
          unsigned int v30 = v41;
          if (numbits != 64)
          {
            *(_DWORD *)int v67 = v38;
            *(_DWORD *)&v67[4] = v15;
            *(_DWORD *)&v67[8] = v39;
            int v68 = v41;
            __memmove_chk();
            if (v62)
            {
              int v50 = v67;
              int8x8_t v51 = vld1_dup_s8(v50);
              uint16x8_t v52 = vmovl_u8((uint8x8_t)vext_s8(v51, *(int8x8_t *)&v67[1], 7uLL));
              uint16x8_t v53 = vmovl_u8(*(uint8x8_t *)&v67[1]);
              *(int8x8_t *)int v67 = vmovn_s16(vuzp1q_s16((int16x8_t)vorrq_s8((int8x16_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)v53.i8), v57), (int8x16_t)vshlq_u32(vmovl_u16(*(uint16x4_t *)v52.i8), v60)), (int16x8_t)vorrq_s8((int8x16_t)vshlq_u32(vmovl_high_u16(v53), v57), (int8x16_t)vshlq_u32(vmovl_high_u16(v52), v60))));
            }
            unsigned int v16 = *(_DWORD *)v67;
            unsigned int v30 = *(_DWORD *)&v67[4];
          }
        }
        int v54 = &out[v14];
        unsigned int v55 = data ^ v39;
        int v56 = v70 ^ v41;
        switch(v14)
        {
          case 1uLL:
            goto LABEL_58;
          case 2uLL:
            goto LABEL_57;
          case 3uLL:
            goto LABEL_56;
          case 4uLL:
            goto LABEL_55;
          case 5uLL:
            goto LABEL_54;
          case 6uLL:
            goto LABEL_53;
          case 7uLL:
            goto LABEL_52;
          case 8uLL:
            *--int v54 = HIBYTE(v56);
LABEL_52:
            *--int v54 = BYTE2(v56);
LABEL_53:
            *--int v54 = BYTE1(v56);
LABEL_54:
            *--int v54 = v56;
LABEL_55:
            *--int v54 = HIBYTE(v55);
LABEL_56:
            *--int v54 = BYTE2(v55);
LABEL_57:
            *--int v54 = BYTE1(v55);
LABEL_58:
            *--int v54 = v55;
            break;
          default:
            break;
        }
        int v10 = ks3;
        v11 -= v14;
        unsigned __int8 in = &v40[v14];
        unsigned __int8 out = &v54[v14];
        unsigned int v15 = v30;
        unsigned int v38 = v16;
      }
      while (v11 >= v14);
      goto LABEL_60;
    }
    unsigned int v30 = *(_DWORD *)&(*ivec)[4];
LABEL_60:
    *(_DWORD *)ivec = v16;
    *(_DWORD *)&(*ivec)[4] = v30;
  }
}

uint64_t BIO_new_NDEF(BIO *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v15 = 0;
  uint64_t v16 = a2;
  uint64_t v3 = *(void *)(a3 + 32);
  int v13 = 0;
  uint64_t v14 = 0;
  if (v3 && *(void *)(v3 + 24))
  {
    uint64_t v6 = (BIO_METHOD *)BIO_f_asn1();
    int v7 = BIO_new(v6);
    int v8 = v7;
    if (v7)
    {
      int v7 = BIO_push(v7, a1);
      if (v7)
      {
        if ((int)BIO_asn1_set_prefix(v8, (uint64_t)ndef_prefix, (uint64_t)ndef_prefix_free) >= 1
          && (int)BIO_asn1_set_suffix(v8, (uint64_t)ndef_suffix, (uint64_t)ndef_suffix_free) >= 1)
        {
          int v9 = malloc_type_calloc(1uLL, 0x30uLL, 0xF004056C54A40uLL);
          if (v9)
          {
            int v10 = v9;
            if (BIO_ctrl(v8, 153, 0, v9) <= 0)
            {
              free(v10);
            }
            else
            {
              uint64_t v14 = 0;
              uint64_t v15 = 0;
              int v13 = v8;
              if ((*(int (**)(uint64_t, uint64_t *, uint64_t, BIO **))(v3 + 24))(10, &v16, a3, &v13) >= 1)
              {
                *int v10 = v16;
                v10[1] = a3;
                uint64_t result = v14;
                uint64_t v12 = v15;
                _OWORD v10[3] = v8;
                v10[4] = v12;
                _OWORD v10[2] = result;
                return result;
              }
            }
          }
        }
        int v7 = v8;
      }
    }
  }
  else
  {
    ERR_put_error(13, 4095, 202, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/bio_ndef.c", 111);
    int v8 = 0;
    int v7 = 0;
  }
  BIO_pop(v7);
  BIO_free(v8);
  return 0;
}

uint64_t ndef_prefix(uint64_t a1, unsigned __int8 **a2, _DWORD *a3, ASN1_VALUE ***a4)
{
  if (!a4) {
    return 0;
  }
  uint64_t v6 = *a4;
  int v7 = ASN1_item_ndef_i2d(**a4, 0, (const ASN1_ITEM *)(*a4)[1]);
  int v8 = (unsigned __int8 *)malloc_type_malloc(v7, 0x47FF4798uLL);
  unsigned __int8 out = v8;
  v6[5] = (ASN1_VALUE *)v8;
  *a2 = v8;
  ASN1_item_ndef_i2d(*v6, &out, (const ASN1_ITEM *)v6[1]);
  uint64_t v9 = *(void *)v6[4];
  if (!v9) {
    return 0;
  }
  *a3 = v9 - *(_DWORD *)a2;
  return 1;
}

uint64_t ndef_prefix_free(uint64_t a1, void *a2, _DWORD *a3, uint64_t a4)
{
  if (!a4) {
    return 0;
  }
  if (!*(void *)a4) {
    return 0;
  }
  free(*(void **)(*(void *)a4 + 40));
  *(void *)(*(void *)a4 + 4RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0;
  *a2 = 0;
  *a3 = 0;
  return 1;
}

uint64_t ndef_suffix(uint64_t a1, unsigned __int8 **a2, _DWORD *a3, int8x16_t **a4)
{
  if (!a4) {
    return 0;
  }
  uint64_t v6 = *a4;
  uint64_t v7 = *(void *)((*a4)->i64[1] + 32);
  int8x16_t v13 = vextq_s8((*a4)[1], (*a4)[1], 8uLL);
  uint64_t v14 = v6[2].i64[0];
  if ((*(int (**)(uint64_t, int8x16_t *))(v7 + 24))(11, v6) < 1) {
    return 0;
  }
  int v8 = ASN1_item_ndef_i2d((ASN1_VALUE *)v6->i64[0], 0, (const ASN1_ITEM *)v6->i64[1]);
  uint64_t v9 = (unsigned __int8 *)malloc_type_malloc(v8, 0x8B324E2EuLL);
  unsigned __int8 out = v9;
  v6[2].i64[1] = (uint64_t)v9;
  *a2 = v9;
  int v10 = ASN1_item_ndef_i2d((ASN1_VALUE *)v6->i64[0], &out, (const ASN1_ITEM *)v6->i64[1]);
  unint64_t v11 = *(unsigned __int8 **)v6[2].i64[0];
  if (!v11) {
    return 0;
  }
  *a2 = v11;
  *a3 = v10 + v6[2].i32[2] - *(_DWORD *)v6[2].i64[0];
  return 1;
}

uint64_t ndef_suffix_free(uint64_t a1, void *a2, _DWORD *a3, void **a4)
{
  if (!a4) {
    return 0;
  }
  if (!*a4) {
    return 0;
  }
  free(*((void **)*a4 + 5));
  *((void *)*a4 + 5) = 0;
  *a2 = 0;
  *a3 = 0;
  free(*a4);
  *a4 = 0;
  return 1;
}

EC_GROUP *__cdecl EC_GROUP_new_curve_GFp(const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *a4)
{
  int v8 = EC_GFp_mont_method();
  uint64_t v9 = EC_GROUP_new(v8);
  int v10 = v9;
  if (!v9 || !EC_GROUP_set_curve((uint64_t)v9, (uint64_t)p, (uint64_t)a, (uint64_t)b, a4))
  {
    EC_GROUP_free(v10);
    return 0;
  }
  return v10;
}

char *OPENSSL_asc2uni(char *__s, unsigned int a2, void *a3, _DWORD *a4)
{
  uint64_t v6 = __s;
  if ((a2 & 0x80000000) != 0) {
    size_t v7 = strlen(__s);
  }
  else {
    size_t v7 = a2;
  }
  unint64_t v8 = v7 + 1;
  if (v7 == -1) {
    return 0;
  }
  uint64_t result = (char *)reallocarray(0, v8, 2uLL);
  if (!result) {
    return result;
  }
  if (((v8 >> 30) & 0x1FFFFFFFFLL) != 0)
  {
    free(result);
    return 0;
  }
  uint64_t v10 = 2 * v8;
  unint64_t v11 = 2 * v8 - 2;
  if (2 * v8 != 2)
  {
    unint64_t v12 = 0;
    do
    {
      int8x16_t v13 = &result[v12];
      char *v13 = 0;
      char v14 = *v6++;
      v13[1] = v14;
      v12 += 2;
    }
    while (v12 < v11);
  }
  result[v11] = 0;
  result[v10 - 1] = 0;
  if (a4) {
    *a4 = v10;
  }
  if (a3) {
    *a3 = result;
  }
  return result;
}

unsigned char *OPENSSL_uni2asc(uint64_t a1, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    return 0;
  }
  unint64_t v4 = a2 >> 1;
  if (!a2 || (size_t v5 = a2 >> 1, *(unsigned char *)(a1 + a2 - 1))) {
    size_t v5 = v4 + 1;
  }
  uint64_t result = malloc_type_malloc(v5, 0xAD3C9D9CuLL);
  if (result)
  {
    if (a2 >= 2)
    {
      size_t v7 = (char *)(a1 + 1);
      if (v4 <= 1) {
        uint64_t v8 = 1;
      }
      else {
        uint64_t v8 = v4;
      }
      uint64_t v9 = result;
      do
      {
        char v10 = *v7;
        v7 += 2;
        *v9++ = v10;
        --v8;
      }
      while (v8);
    }
    result[v5 - 1] = 0;
  }
  return result;
}

int i2d_PKCS12_bio(BIO *bp, PKCS12 *p12)
{
  return ASN1_item_i2d_bio(&PKCS12_it, bp, p12);
}

int i2d_PKCS12_fp(FILE *fp, PKCS12 *p12)
{
  return ASN1_item_i2d_fp(&PKCS12_it, fp, p12);
}

PKCS12 *__cdecl d2i_PKCS12_bio(BIO *bp, PKCS12 **p12)
{
  return (PKCS12 *)ASN1_item_d2i_bio(&PKCS12_it, bp, p12);
}

PKCS12 *__cdecl d2i_PKCS12_fp(FILE *fp, PKCS12 **p12)
{
  return (PKCS12 *)ASN1_item_d2i_fp(&PKCS12_it, fp, p12);
}

void gost_key_wrap_crypto_pro(uint64_t a1)
{
  int v1 = MEMORY[0x270FA5388](a1);
  uint64_t v3 = v2;
  size_t v5 = v4;
  size_t v7 = v6;
  uint64_t v9 = v8;
  uint64_t v12 = *MEMORY[0x263EF8340];
  memset(v10, 0, 512);
  Gost2814789_set_sbox((uint64_t)v10, v1);
  key_diversify_crypto_pro((uint64_t)v10, v9, (uint64_t)v7, (uint64_t)v11);
  Gost2814789_set_key((uint64_t)v10, (uint64_t)v11, 256);
  *(void *)uint64_t v3 = *v7;
  Gost2814789_encrypt(v5, (int *)(v3 + 8), (int *)v10);
  Gost2814789_encrypt(v5 + 2, (int *)(v3 + 16), (int *)v10);
  Gost2814789_encrypt(v5 + 4, (int *)(v3 + 24), (int *)v10);
  Gost2814789_encrypt(v5 + 6, (int *)(v3 + 32), (int *)v10);
  GOST2814789IMIT((uint64_t)v5);
}

uint64_t key_diversify_crypto_pro(uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = 0;
  uint64_t v20 = *MEMORY[0x263EF8340];
  long long v8 = a2[1];
  *(_OWORD *)a4 = *a2;
  *(_OWORD *)(a4 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = v8;
  do
  {
    int v9 = 0;
    int v10 = 0;
    int v11 = *(unsigned __int8 *)(a3 + v7);
    int v12 = 1;
    int8x16_t v13 = (int *)a4;
    do
    {
      int v15 = *v13++;
      int v14 = v15;
      if ((v12 & v11) != 0) {
        int v16 = v14;
      }
      else {
        int v16 = 0;
      }
      v10 += v16;
      if ((v12 & v11) != 0) {
        int v14 = 0;
      }
      v9 += v14;
      v12 *= 2;
    }
    while (v12 < 256);
    unsigned int v18 = 256;
    v19[0] = v10;
    v19[1] = v9;
    Gost2814789_set_key(a1, a4, 256);
    unsigned int v18 = 0;
    uint64_t result = Gost2814789_cfb64_encrypt(a4, (unsigned char *)a4, 0x20uLL, a1, v19, &v18, 1);
    ++v7;
  }
  while (v7 != 8);
  return result;
}

void gost_key_unwrap_crypto_pro(uint64_t a1)
{
  int v1 = MEMORY[0x270FA5388](a1);
  uint64_t v3 = v2;
  size_t v5 = v4;
  uint64_t v7 = v6;
  uint64_t v10 = *MEMORY[0x263EF8340];
  memset(v8, 0, 512);
  Gost2814789_set_sbox((uint64_t)v8, v1);
  key_diversify_crypto_pro((uint64_t)v8, v7, (uint64_t)v5, (uint64_t)v9);
  Gost2814789_set_key((uint64_t)v8, (uint64_t)v9, 256);
  Gost2814789_decrypt(v5 + 2, v3, (int *)v8);
  Gost2814789_decrypt(v5 + 4, v3 + 2, (int *)v8);
  Gost2814789_decrypt(v5 + 6, v3 + 4, (int *)v8);
  Gost2814789_decrypt(v5 + 8, v3 + 6, (int *)v8);
  GOST2814789IMIT((uint64_t)v3);
}

void DES_xcbc_encrypt(const unsigned __int8 *input, unsigned __int8 *output, uint64_t length, DES_key_schedule *schedule, DES_cblock *ivec, const_DES_cblock *inw, const_DES_cblock *outw, int enc)
{
  long long v8 = ivec;
  int v9 = schedule;
  uint64_t v10 = length;
  uint64_t v58 = *MEMORY[0x263EF8340];
  int v14 = *(_DWORD *)inw;
  int v13 = *(_DWORD *)&(*inw)[4];
  int v15 = *(_DWORD *)outw;
  unsigned int v16 = *(_DWORD *)&(*outw)[4];
  unsigned int v17 = *(_DWORD *)ivec;
  unsigned int v18 = *(_DWORD *)&(*ivec)[4];
  int v54 = v13;
  int v55 = *(_DWORD *)outw;
  int v19 = *(_DWORD *)inw;
  if (!enc)
  {
    if (length < 9)
    {
      if (!length)
      {
LABEL_32:
        *(_DWORD *)long long v8 = v17;
        *(_WORD *)&(*v8)[4] = v18;
        unsigned int v38 = HIBYTE(v18);
        (*v8)[6] = BYTE2(v18);
        goto LABEL_33;
      }
    }
    else
    {
      unsigned int v52 = *(_DWORD *)&(*outw)[4];
      do
      {
        unsigned int v39 = output;
        unsigned int v40 = v17;
        unsigned int v41 = v18;
        unint64_t v42 = v10;
        v10 -= 8;
        unsigned int v17 = *(_DWORD *)input;
        unsigned int v18 = *((_DWORD *)input + 1);
        int v43 = input + 8;
        unsigned int data = *(_DWORD *)input ^ v55;
        int v57 = v18 ^ v52;
        DES_encrypt1(&data, schedule, 0);
        int v44 = v41 ^ v54 ^ v57;
        *(_DWORD *)unsigned int v39 = v40 ^ v19 ^ data;
        *((_DWORD *)v39 + engine_free_util((CRYPTO_EX_DATA *)e, 1) = v44;
        output = v39 + 8;
        int v15 = v55;
        input += 8;
      }
      while (v42 > 0x10);
      input = v43;
      long long v8 = ivec;
      unsigned int v16 = v52;
      int v9 = schedule;
    }
    unsigned int v46 = *(_DWORD *)input;
    unsigned int v45 = *((_DWORD *)input + 1);
    unsigned int data = v46 ^ v15;
    int v57 = v45 ^ v16;
    DES_encrypt1(&data, v9, 0);
    unsigned int v47 = data ^ v17 ^ v19;
    int v48 = v57 ^ v18 ^ v54;
    int v49 = &output[v10];
    switch(v10)
    {
      case 1:
        goto LABEL_30;
      case 2:
        goto LABEL_29;
      case 3:
        goto LABEL_28;
      case 4:
        goto LABEL_27;
      case 5:
        goto LABEL_26;
      case 6:
        goto LABEL_25;
      case 7:
        goto LABEL_24;
      case 8:
        *--int v49 = HIBYTE(v48);
LABEL_24:
        *--int v49 = BYTE2(v48);
LABEL_25:
        *--int v49 = BYTE1(v48);
LABEL_26:
        *--int v49 = v48;
LABEL_27:
        *--int v49 = HIBYTE(v47);
LABEL_28:
        *--int v49 = BYTE2(v47);
LABEL_29:
        *--int v49 = BYTE1(v47);
LABEL_30:
        *(v49 - engine_free_util((CRYPTO_EX_DATA *)e, 1) = v47;
        break;
      default:
        break;
    }
    unsigned int v17 = v46;
    unsigned int v18 = v45;
    goto LABEL_32;
  }
  if (length >= 8)
  {
    do
    {
      uint64_t v20 = output;
      unint64_t v21 = v10;
      v10 -= 8;
      unsigned int v22 = *(_DWORD *)input;
      int v23 = *((_DWORD *)input + 1);
      input += 8;
      unsigned int data = v17 ^ v14 ^ v22;
      int v57 = v18 ^ v13 ^ v23;
      DES_encrypt1(&data, v9, 1);
      int v14 = v19;
      int v13 = v54;
      unsigned int v17 = data ^ v55;
      unsigned int v18 = v57 ^ v16;
      output += 8;
      *(_DWORD *)uint64_t v20 = data ^ v55;
      *((_DWORD *)v20 + engine_free_util((CRYPTO_EX_DATA *)e, 1) = v18;
    }
    while (v21 > 0xF);
    long long v8 = ivec;
  }
  if (v10)
  {
    int v24 = 0;
    int v25 = &input[v10];
    int v26 = 0;
    switch(v10)
    {
      case 1:
        goto LABEL_13;
      case 2:
        goto LABEL_12;
      case 3:
        goto LABEL_11;
      case 4:
        goto LABEL_10;
      case 5:
        goto LABEL_9;
      case 6:
        goto LABEL_8;
      case 7:
        int v27 = *--v25;
        int v24 = v27 << 16;
LABEL_8:
        int v28 = *--v25;
        v24 |= v28 << 8;
LABEL_9:
        int v29 = *--v25;
        v24 |= v29;
LABEL_10:
        int v26 = v24;
        int v30 = *--v25;
        int v24 = v30 << 24;
LABEL_11:
        int v31 = *--v25;
        v24 |= v31 << 16;
LABEL_12:
        int v32 = *--v25;
        v24 |= v32 << 8;
LABEL_13:
        v24 |= *(v25 - 1);
        break;
      default:
        int v26 = 0;
        break;
    }
    unsigned int data = v14 ^ v24 ^ v17;
    int v57 = v13 ^ v26 ^ v18;
    DES_encrypt1(&data, v9, 1);
    LOBYTE(v17) = data ^ v55;
    unsigned int v33 = (data ^ v55) >> 8;
    unsigned int v34 = (data ^ v55) >> 16;
    unsigned int v35 = (data ^ v55) >> 24;
    unsigned int v18 = v57 ^ v16;
    unsigned int v36 = (v57 ^ v16) >> 8;
    unsigned int v37 = (v57 ^ v16) >> 16;
    unsigned int v38 = (v57 ^ v16) >> 24;
    *(_DWORD *)output = data ^ v55;
    *((_DWORD *)output + engine_free_util((CRYPTO_EX_DATA *)e, 1) = v18;
  }
  else
  {
    unsigned int v33 = v17 >> 8;
    unsigned int v34 = HIWORD(v17);
    unsigned int v35 = HIBYTE(v17);
    unsigned int v36 = v18 >> 8;
    unsigned int v37 = HIWORD(v18);
    unsigned int v38 = HIBYTE(v18);
  }
  *(unsigned char *)long long v8 = v17;
  (*v8)[1] = v33;
  (*v8)[2] = v34;
  (*v8)[3] = v35;
  (*v8)[4] = v18;
  (*v8)[5] = v36;
  (*v8)[6] = v37;
LABEL_33:
  (*v8)[7] = v38;
}

X509_REQ *__cdecl PEM_read_X509_REQ(FILE *fp, X509_REQ **x, pem_password_cb *cb, void *u)
{
  return (X509_REQ *)PEM_ASN1_read((d2i_of_void *)d2i_X509_REQ, "CERTIFICATE REQUEST", fp, (void **)x, cb, u);
}

int PEM_write_X509_REQ(FILE *fp, X509_REQ *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_X509_REQ, "CERTIFICATE REQUEST", fp, (char *)x, 0, 0, 0, 0, 0);
}

X509_REQ *__cdecl PEM_read_bio_X509_REQ(BIO *bp, X509_REQ **x, pem_password_cb *cb, void *u)
{
  return (X509_REQ *)PEM_ASN1_read_bio((d2i_of_void *)d2i_X509_REQ, "CERTIFICATE REQUEST", bp, (void **)x, cb, u);
}

int PEM_write_bio_X509_REQ(BIO *bp, X509_REQ *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_X509_REQ, "CERTIFICATE REQUEST", bp, (char *)x, 0, 0, 0, 0, 0);
}

int PEM_write_X509_REQ_NEW(FILE *fp, X509_REQ *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_X509_REQ, "NEW CERTIFICATE REQUEST", fp, (char *)x, 0, 0, 0, 0, 0);
}

int PEM_write_bio_X509_REQ_NEW(BIO *bp, X509_REQ *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_X509_REQ, "NEW CERTIFICATE REQUEST", bp, (char *)x, 0, 0, 0, 0, 0);
}

X509_CRL *__cdecl PEM_read_X509_CRL(FILE *fp, X509_CRL **x, pem_password_cb *cb, void *u)
{
  return (X509_CRL *)PEM_ASN1_read((d2i_of_void *)d2i_X509_CRL, "X509 CRL", fp, (void **)x, cb, u);
}

int PEM_write_X509_CRL(FILE *fp, X509_CRL *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_X509_CRL, "X509 CRL", fp, (char *)x, 0, 0, 0, 0, 0);
}

X509_CRL *__cdecl PEM_read_bio_X509_CRL(BIO *bp, X509_CRL **x, pem_password_cb *cb, void *u)
{
  return (X509_CRL *)PEM_ASN1_read_bio((d2i_of_void *)d2i_X509_CRL, "X509 CRL", bp, (void **)x, cb, u);
}

int PEM_write_bio_X509_CRL(BIO *bp, X509_CRL *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_X509_CRL, "X509 CRL", bp, (char *)x, 0, 0, 0, 0, 0);
}

PKCS7 *__cdecl PEM_read_PKCS7(FILE *fp, PKCS7 **x, pem_password_cb *cb, void *u)
{
  return (PKCS7 *)PEM_ASN1_read((d2i_of_void *)d2i_PKCS7, "PKCS7", fp, (void **)x, cb, u);
}

int PEM_write_PKCS7(FILE *fp, PKCS7 *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_PKCS7, "PKCS7", fp, (char *)x, 0, 0, 0, 0, 0);
}

PKCS7 *__cdecl PEM_read_bio_PKCS7(BIO *bp, PKCS7 **x, pem_password_cb *cb, void *u)
{
  return (PKCS7 *)PEM_ASN1_read_bio((d2i_of_void *)d2i_PKCS7, "PKCS7", bp, (void **)x, cb, u);
}

int PEM_write_bio_PKCS7(BIO *bp, PKCS7 *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_PKCS7, "PKCS7", bp, (char *)x, 0, 0, 0, 0, 0);
}

RSA *__cdecl PEM_read_RSAPrivateKey(FILE *fp, RSA **x, pem_password_cb *cb, void *u)
{
  PrivateKey = PEM_read_PrivateKey(fp, 0, cb, u);
  return pkey_get_rsa(PrivateKey, x);
}

rsa_st *pkey_get_rsa(EVP_PKEY *a1, RSA **a2)
{
  if (!a1) {
    return 0;
  }
  unint64_t v4 = EVP_PKEY_get1_RSA(a1);
  EVP_PKEY_free(a1);
  if (v4 && a2)
  {
    RSA_free(*a2);
    *a2 = v4;
  }
  return v4;
}

int PEM_write_RSAPrivateKey(FILE *fp, RSA *x, const EVP_CIPHER *enc, unsigned __int8 *kstr, int klen, pem_password_cb *cb, void *u)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_RSAPrivateKey, "RSA PRIVATE KEY", fp, (char *)x, enc, kstr, klen, cb, u);
}

RSA *__cdecl PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **x, pem_password_cb *cb, void *u)
{
  bio_PrivateKey = PEM_read_bio_PrivateKey(bp, 0, cb, u);
  return pkey_get_rsa(bio_PrivateKey, x);
}

int PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x, const EVP_CIPHER *enc, unsigned __int8 *kstr, int klen, pem_password_cb *cb, void *u)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_RSAPrivateKey, "RSA PRIVATE KEY", bp, (char *)x, enc, kstr, klen, cb, u);
}

RSA *__cdecl PEM_read_RSAPublicKey(FILE *fp, RSA **x, pem_password_cb *cb, void *u)
{
  return (RSA *)PEM_ASN1_read((d2i_of_void *)d2i_RSAPublicKey, "RSA PUBLIC KEY", fp, (void **)x, cb, u);
}

int PEM_write_RSAPublicKey(FILE *fp, const RSA *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_RSAPublicKey, "RSA PUBLIC KEY", fp, (char *)x, 0, 0, 0, 0, 0);
}

RSA *__cdecl PEM_read_bio_RSAPublicKey(BIO *bp, RSA **x, pem_password_cb *cb, void *u)
{
  return (RSA *)PEM_ASN1_read_bio((d2i_of_void *)d2i_RSAPublicKey, "RSA PUBLIC KEY", bp, (void **)x, cb, u);
}

int PEM_write_bio_RSAPublicKey(BIO *bp, const RSA *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_RSAPublicKey, "RSA PUBLIC KEY", bp, (char *)x, 0, 0, 0, 0, 0);
}

RSA *__cdecl PEM_read_RSA_PUBKEY(FILE *fp, RSA **x, pem_password_cb *cb, void *u)
{
  return (RSA *)PEM_ASN1_read((d2i_of_void *)d2i_RSA_PUBKEY, "PUBLIC KEY", fp, (void **)x, cb, u);
}

int PEM_write_RSA_PUBKEY(FILE *fp, RSA *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_RSA_PUBKEY, "PUBLIC KEY", fp, (char *)x, 0, 0, 0, 0, 0);
}

RSA *__cdecl PEM_read_bio_RSA_PUBKEY(BIO *bp, RSA **x, pem_password_cb *cb, void *u)
{
  return (RSA *)PEM_ASN1_read_bio((d2i_of_void *)d2i_RSA_PUBKEY, "PUBLIC KEY", bp, (void **)x, cb, u);
}

int PEM_write_bio_RSA_PUBKEY(BIO *bp, RSA *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_RSA_PUBKEY, "PUBLIC KEY", bp, (char *)x, 0, 0, 0, 0, 0);
}

DSA *__cdecl PEM_read_DSAPrivateKey(FILE *fp, DSA **x, pem_password_cb *cb, void *u)
{
  PrivateKey = PEM_read_PrivateKey(fp, 0, cb, u);
  return pkey_get_dsa(PrivateKey, x);
}

dsa_st *pkey_get_dsa(EVP_PKEY *a1, DSA **a2)
{
  if (!a1) {
    return 0;
  }
  unint64_t v4 = EVP_PKEY_get1_DSA(a1);
  EVP_PKEY_free(a1);
  if (v4 && a2)
  {
    DSA_free(*a2);
    *a2 = v4;
  }
  return v4;
}

int PEM_write_DSAPrivateKey(FILE *fp, DSA *x, const EVP_CIPHER *enc, unsigned __int8 *kstr, int klen, pem_password_cb *cb, void *u)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_DSAPrivateKey, "DSA PRIVATE KEY", fp, (char *)x, enc, kstr, klen, cb, u);
}

DSA *__cdecl PEM_read_bio_DSAPrivateKey(BIO *bp, DSA **x, pem_password_cb *cb, void *u)
{
  bio_PrivateKey = PEM_read_bio_PrivateKey(bp, 0, cb, u);
  return pkey_get_dsa(bio_PrivateKey, x);
}

int PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x, const EVP_CIPHER *enc, unsigned __int8 *kstr, int klen, pem_password_cb *cb, void *u)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_DSAPrivateKey, "DSA PRIVATE KEY", bp, (char *)x, enc, kstr, klen, cb, u);
}

DSA *__cdecl PEM_read_DSA_PUBKEY(FILE *fp, DSA **x, pem_password_cb *cb, void *u)
{
  return (DSA *)PEM_ASN1_read((d2i_of_void *)d2i_DSA_PUBKEY, "PUBLIC KEY", fp, (void **)x, cb, u);
}

int PEM_write_DSA_PUBKEY(FILE *fp, DSA *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_DSA_PUBKEY, "PUBLIC KEY", fp, (char *)x, 0, 0, 0, 0, 0);
}

int PEM_write_bio_DSA_PUBKEY(BIO *bp, DSA *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_DSA_PUBKEY, "PUBLIC KEY", bp, (char *)x, 0, 0, 0, 0, 0);
}

DSA *__cdecl PEM_read_bio_DSA_PUBKEY(BIO *bp, DSA **x, pem_password_cb *cb, void *u)
{
  return (DSA *)PEM_ASN1_read_bio((d2i_of_void *)d2i_DSA_PUBKEY, "PUBLIC KEY", bp, (void **)x, cb, u);
}

DSA *__cdecl PEM_read_DSAparams(FILE *fp, DSA **x, pem_password_cb *cb, void *u)
{
  return (DSA *)PEM_ASN1_read((d2i_of_void *)d2i_DSAparams, "DSA PARAMETERS", fp, (void **)x, cb, u);
}

int PEM_write_DSAparams(FILE *fp, const DSA *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_DSAparams, "DSA PARAMETERS", fp, (char *)x, 0, 0, 0, 0, 0);
}

DSA *__cdecl PEM_read_bio_DSAparams(BIO *bp, DSA **x, pem_password_cb *cb, void *u)
{
  return (DSA *)PEM_ASN1_read_bio((d2i_of_void *)d2i_DSAparams, "DSA PARAMETERS", bp, (void **)x, cb, u);
}

int PEM_write_bio_DSAparams(BIO *bp, const DSA *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_DSAparams, "DSA PARAMETERS", bp, (char *)x, 0, 0, 0, 0, 0);
}

EC_GROUP *__cdecl PEM_read_ECPKParameters(FILE *fp, EC_GROUP **x, pem_password_cb *cb, void *u)
{
  return (EC_GROUP *)PEM_ASN1_read((d2i_of_void *)d2i_ECPKParameters, "EC PARAMETERS", fp, (void **)x, cb, u);
}

int PEM_write_ECPKParameters(FILE *fp, const EC_GROUP *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_ECPKParameters, "EC PARAMETERS", fp, (char *)x, 0, 0, 0, 0, 0);
}

EC_GROUP *__cdecl PEM_read_bio_ECPKParameters(BIO *bp, EC_GROUP **x, pem_password_cb *cb, void *u)
{
  return (EC_GROUP *)PEM_ASN1_read_bio((d2i_of_void *)d2i_ECPKParameters, "EC PARAMETERS", bp, (void **)x, cb, u);
}

int PEM_write_bio_ECPKParameters(BIO *bp, const EC_GROUP *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_ECPKParameters, "EC PARAMETERS", bp, (char *)x, 0, 0, 0, 0, 0);
}

EC_KEY *__cdecl PEM_read_ECPrivateKey(FILE *fp, EC_KEY **x, pem_password_cb *cb, void *u)
{
  PrivateKey = PEM_read_PrivateKey(fp, 0, cb, u);
  return pkey_get_eckey(PrivateKey, x);
}

ec_key_st *pkey_get_eckey(EVP_PKEY *a1, EC_KEY **a2)
{
  if (!a1) {
    return 0;
  }
  unint64_t v4 = EVP_PKEY_get1_EC_KEY(a1);
  EVP_PKEY_free(a1);
  if (v4 && a2)
  {
    EC_KEY_free(*a2);
    *a2 = v4;
  }
  return v4;
}

int PEM_write_ECPrivateKey(FILE *fp, EC_KEY *x, const EVP_CIPHER *enc, unsigned __int8 *kstr, int klen, pem_password_cb *cb, void *u)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_ECPrivateKey, "EC PRIVATE KEY", fp, (char *)x, enc, kstr, klen, cb, u);
}

EC_KEY *__cdecl PEM_read_bio_ECPrivateKey(BIO *bp, EC_KEY **x, pem_password_cb *cb, void *u)
{
  bio_PrivateKey = PEM_read_bio_PrivateKey(bp, 0, cb, u);
  return pkey_get_eckey(bio_PrivateKey, x);
}

int PEM_write_bio_ECPrivateKey(BIO *bp, EC_KEY *x, const EVP_CIPHER *enc, unsigned __int8 *kstr, int klen, pem_password_cb *cb, void *u)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_ECPrivateKey, "EC PRIVATE KEY", bp, (char *)x, enc, kstr, klen, cb, u);
}

EC_KEY *__cdecl PEM_read_EC_PUBKEY(FILE *fp, EC_KEY **x, pem_password_cb *cb, void *u)
{
  return (EC_KEY *)PEM_ASN1_read((d2i_of_void *)d2i_EC_PUBKEY, "PUBLIC KEY", fp, (void **)x, cb, u);
}

int PEM_write_EC_PUBKEY(FILE *fp, EC_KEY *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_EC_PUBKEY, "PUBLIC KEY", fp, (char *)x, 0, 0, 0, 0, 0);
}

EC_KEY *__cdecl PEM_read_bio_EC_PUBKEY(BIO *bp, EC_KEY **x, pem_password_cb *cb, void *u)
{
  return (EC_KEY *)PEM_ASN1_read_bio((d2i_of_void *)d2i_EC_PUBKEY, "PUBLIC KEY", bp, (void **)x, cb, u);
}

int PEM_write_bio_EC_PUBKEY(BIO *bp, EC_KEY *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_EC_PUBKEY, "PUBLIC KEY", bp, (char *)x, 0, 0, 0, 0, 0);
}

DH *__cdecl PEM_read_DHparams(FILE *fp, DH **x, pem_password_cb *cb, void *u)
{
  return (DH *)PEM_ASN1_read((d2i_of_void *)d2i_DHparams, "DH PARAMETERS", fp, (void **)x, cb, u);
}

int PEM_write_DHparams(FILE *fp, const DH *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_DHparams, "DH PARAMETERS", fp, (char *)x, 0, 0, 0, 0, 0);
}

DH *__cdecl PEM_read_bio_DHparams(BIO *bp, DH **x, pem_password_cb *cb, void *u)
{
  return (DH *)PEM_ASN1_read_bio((d2i_of_void *)d2i_DHparams, "DH PARAMETERS", bp, (void **)x, cb, u);
}

int PEM_write_bio_DHparams(BIO *bp, const DH *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_DHparams, "DH PARAMETERS", bp, (char *)x, 0, 0, 0, 0, 0);
}

EVP_PKEY *__cdecl PEM_read_PUBKEY(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u)
{
  return (EVP_PKEY *)PEM_ASN1_read((d2i_of_void *)d2i_PUBKEY, "PUBLIC KEY", fp, (void **)x, cb, u);
}

int PEM_write_PUBKEY(FILE *fp, EVP_PKEY *x)
{
  return PEM_ASN1_write((i2d_of_void *)i2d_PUBKEY, "PUBLIC KEY", fp, (char *)x, 0, 0, 0, 0, 0);
}

EVP_PKEY *__cdecl PEM_read_bio_PUBKEY(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u)
{
  return (EVP_PKEY *)PEM_ASN1_read_bio((d2i_of_void *)d2i_PUBKEY, "PUBLIC KEY", bp, (void **)x, cb, u);
}

int PEM_write_bio_PUBKEY(BIO *bp, EVP_PKEY *x)
{
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_PUBKEY, "PUBLIC KEY", bp, (char *)x, 0, 0, 0, 0, 0);
}

uint64_t pkey_dh_init(uint64_t a1)
{
  uint64_t result = (uint64_t)malloc_type_malloc(0x14uLL, 0x1000040A86A77D5uLL);
  if (result)
  {
    *(void *)uint64_t result = 0x200000400;
    *(_DWORD *)(result + 8) = 0;
    *(void *)(a1 + 4RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = result;
    *(void *)(a1 + 64) = result + 12;
    *(_DWORD *)(a1 + 72) = 2;
    return 1;
  }
  return result;
}

uint64_t pkey_dh_copy(uint64_t a1, uint64_t a2)
{
  uint64_t result = (uint64_t)malloc_type_malloc(0x14uLL, 0x1000040A86A77D5uLL);
  if (result)
  {
    *(void *)uint64_t result = 0x200000400;
    *(_DWORD *)(result + 8) = 0;
    *(void *)(a1 + 4RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = result;
    *(void *)(a1 + 64) = result + 12;
    *(_DWORD *)(a1 + 72) = 2;
    uint64_t v5 = *(void *)(a2 + 40);
    *(void *)uint64_t result = *(void *)v5;
    *(_DWORD *)(result + 8) = *(_DWORD *)(v5 + 8);
    return 1;
  }
  return result;
}

void pkey_dh_cleanup(uint64_t a1)
{
}

uint64_t pkey_dh_paramgen(uint64_t a1, EVP_PKEY *a2)
{
  uint64_t v3 = *(int **)(a1 + 40);
  memset(v9, 0, sizeof(v9));
  if (*(void *)(a1 + 56))
  {
    unint64_t v4 = (BN_GENCB *)v9;
    evp_pkey_set_cb_translate((uint64_t)v9, a1);
  }
  else
  {
    unint64_t v4 = 0;
  }
  uint64_t v5 = DH_new();
  if (!v5) {
    return 0;
  }
  uint64_t v6 = (char *)v5;
  parameterunsigned int s = DH_generate_parameters_ex(v5, *v3, v3[1], v4);
  if (parameters) {
    EVP_PKEY_assign(a2, 28, v6);
  }
  else {
    DH_free((DH *)v6);
  }
  return parameters;
}

uint64_t pkey_dh_keygen(uint64_t a1, EVP_PKEY *a2)
{
  if (!*(void *)(a1 + 16))
  {
    ERR_put_error(5, 4095, 107, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_pmeth.c", 220);
    return 0;
  }
  unint64_t v4 = (char *)DH_new();
  if (!v4) {
    return 0;
  }
  EVP_PKEY_assign(a2, 28, v4);
  if (!EVP_PKEY_copy_parameters(a2, *(const EVP_PKEY **)(a1 + 16))) {
    return 0;
  }
  attributeunsigned int s = (DH *)a2->attributes;
  return DH_generate_key(attributes);
}

uint64_t pkey_dh_derive(uint64_t a1, unsigned __int8 *key, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3 && (uint64_t v4 = *(void *)(a1 + 24)) != 0)
  {
    uint64_t result = DH_compute_key(key, *(const BIGNUM **)(*(void *)(v4 + 32) + 32), *(DH **)(v3 + 32));
    if ((result & 0x80000000) == 0)
    {
      *a3 = result;
      return 1;
    }
  }
  else
  {
    ERR_put_error(5, 4095, 108, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_pmeth.c", 239);
    return 0;
  }
  return result;
}

uint64_t pkey_dh_ctrl(uint64_t a1, int a2, int a3)
{
  if (a2 != 2)
  {
    uint64_t v3 = *(int **)(a1 + 40);
    if (a2 == 4098)
    {
      v3[1] = a3;
    }
    else
    {
      if (a2 != 4097 || a3 < 256) {
        return 4294967294;
      }
      int *v3 = a3;
    }
  }
  return 1;
}

uint64_t pkey_dh_ctrl_str(uint64_t *a1, char *__s1, const char *a3)
{
  __endptr = 0;
  if (strcmp(__s1, "dh_paramgen_prime_len"))
  {
    if (!strcmp(__s1, "dh_paramgen_generator"))
    {
      *__error() = 0;
      uint64_t v6 = strtol(a3, &__endptr, 10);
      if (*a3)
      {
        if (!*__endptr)
        {
          uint64_t v7 = v6;
          __error();
          if (v7 == (int)v7) {
            goto LABEL_11;
          }
        }
      }
    }
    return 4294967294;
  }
  *__error() = 0;
  uint64_t v8 = strtol(a3, &__endptr, 10);
  if (!*a3) {
    return 4294967294;
  }
  if (*__endptr) {
    return 4294967294;
  }
  uint64_t v9 = v8;
  __error();
  if (v9 != (int)v9) {
    return 4294967294;
  }
LABEL_11:
  return EVP_PKEY_CTX_ctrl(a1, 28, 2);
}

BIGNUM *GOST_le2bn(unsigned __int8 *a1, unint64_t a2, BIGNUM *a3)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (a2 > 0x40) {
    return 0;
  }
  if (a2)
  {
    unint64_t v4 = a2;
    do
    {
      unsigned __int8 v5 = *a1++;
      s[--v4] = v5;
    }
    while (v4);
  }
  return BN_bin2bn(s, a2, a3);
}

uint64_t GOST_bn2le(const BIGNUM *a1, uint64_t a2, int a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  int v6 = BN_num_bits(a1);
  uint64_t result = 0;
  int v8 = v6 + 7;
  if (v6 < -7) {
    int v8 = v6 + 14;
  }
  if (a3 <= 64)
  {
    int v9 = v8 >> 3;
    BOOL v10 = __OFSUB__(a3, v8 >> 3);
    int v11 = a3 - (v8 >> 3);
    if (v11 < 0 == v10)
    {
      BN_bn2bin(a1, to);
      if (v6 >= 1)
      {
        if (v9 <= 1) {
          uint64_t v12 = 1;
        }
        else {
          uint64_t v12 = v9;
        }
        int v13 = (unsigned char *)(v9 + a2 - 1);
        int v14 = to;
        do
        {
          char v15 = *v14++;
          *v13-- = v15;
          --v12;
        }
        while (v12);
      }
      bzero((void *)(a2 + v9), v11);
      return 1;
    }
  }
  return result;
}

uint64_t gost2001_compute_public(const EC_GROUP **a1)
{
  uint64_t v2 = GOST_KEY_get0_group((uint64_t)a1);
  if (v2)
  {
    uint64_t v3 = (const EC_GROUP *)v2;
    unint64_t v4 = BN_CTX_new();
    if (v4)
    {
      unsigned __int8 v5 = v4;
      BN_CTX_start(v4);
      uint64_t v6 = GOST_KEY_get0_private_key((uint64_t)a1);
      if (v6)
      {
        uint64_t v7 = (const BIGNUM *)v6;
        int v8 = EC_POINT_new(v3);
        if (v8 && EC_POINT_mul(v3, v8, v7, 0, 0, v5) && GOST_KEY_set_public_key(a1, v8))
        {
          uint64_t v9 = 1;
LABEL_13:
          EC_POINT_free(v8);
          BN_CTX_end(v5);
          BN_CTX_free(v5);
          return v9;
        }
      }
      else
      {
        int v8 = 0;
      }
      ERR_put_error(50, 4095, 16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001.c", 136);
      uint64_t v9 = 0;
      goto LABEL_13;
    }
    int v10 = 65;
    int v11 = 118;
  }
  else
  {
    int v10 = 112;
    int v11 = 113;
  }
  ERR_put_error(50, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001.c", v11);
  return 0;
}

ECDSA_SIG *gost2001_do_sign(const BIGNUM *a1, uint64_t a2)
{
  unint64_t v4 = BN_CTX_new();
  if (v4)
  {
    unsigned __int8 v5 = v4;
    BN_CTX_start(v4);
    uint64_t v6 = ECDSA_SIG_new();
    uint64_t v7 = v6;
    if (v6)
    {
      uint64_t v9 = v6->r;
      unsigned int s = v6->s;
      int v10 = (const EC_GROUP *)GOST_KEY_get0_group(a2);
      int v11 = BN_CTX_get(v5);
      if (v11)
      {
        uint64_t v12 = v11;
        if (EC_GROUP_get_order(v10, v11, v5))
        {
          uint64_t v13 = GOST_KEY_get0_private_key(a2);
          int v14 = BN_CTX_get(v5);
          if (v14)
          {
            char v15 = v14;
            if (BN_mod_ct(v14, a1, v12, v5))
            {
              if (!BN_is_zero((uint64_t)v15) || BN_one((uint64_t)v15))
              {
                EVP_CIPHER_CTX a = (BIGNUM *)v13;
                int v31 = s;
                unsigned int v16 = BN_CTX_get(v5);
                if (v16)
                {
                  uint64_t v17 = v16;
                  unsigned int v18 = BN_CTX_get(v5);
                  if (v18)
                  {
                    int v19 = v18;
                    uint64_t v20 = EC_POINT_new(v10);
                    if (v20)
                    {
                      r = 0;
                      int v29 = 0;
                      while (1)
                      {
                        if (!BN_rand_range(v17, v12))
                        {
                          int v26 = 120;
                          int v27 = 194;
                          goto LABEL_39;
                        }
                        if (!BN_add(v17, v17, v12)) {
                          goto LABEL_33;
                        }
                        unint64_t v21 = v19;
                        int v22 = BN_num_bits(v17);
                        if (v22 <= BN_num_bits(v12) && !BN_add(v17, v17, v12)) {
                          goto LABEL_33;
                        }
                        if (!EC_POINT_mul(v10, v20, v17, 0, 0, v5))
                        {
                          int v26 = 16;
                          int v27 = 209;
                          goto LABEL_39;
                        }
                        int v19 = v21;
                        if (!EC_POINT_get_affine_coordinates((uint64_t)v10, v20, (uint64_t)v21, 0, v5)) {
                          break;
                        }
                        if (!BN_nnmod(v9, v21, v12, v5)) {
                          goto LABEL_33;
                        }
                        if (!BN_is_zero((uint64_t)v9))
                        {
                          int v23 = v29;
                          if (!v29)
                          {
                            int v23 = BN_CTX_get(v5);
                            if (!v23) {
                              goto LABEL_33;
                            }
                          }
                          int v29 = v23;
                          if (!BN_mod_mul(v23, a, v9, v12, v5)) {
                            goto LABEL_33;
                          }
                          int v24 = r;
                          if (!r)
                          {
                            int v24 = BN_CTX_get(v5);
                            if (!v24) {
                              goto LABEL_33;
                            }
                          }
                          if (!BN_mod_mul(v24, v17, v15, v12, v5)) {
                            goto LABEL_33;
                          }
                          r = v24;
                          if (!BN_mod_add(v31, v29, v24, v12, v5)) {
                            goto LABEL_33;
                          }
                          if (!BN_is_zero((uint64_t)v31))
                          {
                            EC_POINT_free(v20);
                            BN_CTX_end(v5);
                            BN_CTX_free(v5);
                            return v7;
                          }
                        }
                      }
                      int v26 = 16;
                      int v27 = 214;
LABEL_39:
                      ERR_put_error(50, 4095, v26, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001.c", v27);
                    }
                    goto LABEL_33;
                  }
                }
              }
            }
          }
        }
      }
    }
    else
    {
      ERR_put_error(50, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001.c", 166);
    }
    uint64_t v20 = 0;
LABEL_33:
    EC_POINT_free(v20);
    BN_CTX_end(v5);
    BN_CTX_free(v5);
    ECDSA_SIG_free(v7);
    return 0;
  }
  ERR_put_error(50, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001.c", 160);
  return 0;
}

uint64_t gost2001_do_verify(const BIGNUM *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = BN_CTX_new();
  uint64_t v7 = GOST_KEY_get0_group(a3);
  if (!v6)
  {
    EC_POINT_free(0);
    return 0;
  }
  int v8 = (const EC_GROUP *)v7;
  BN_CTX_start(v6);
  uint64_t v9 = (EC_POINT *)BN_CTX_get(v6);
  if (!v9) {
    goto LABEL_17;
  }
  int v10 = (BIGNUM *)v9;
  uint64_t v9 = (EC_POINT *)BN_CTX_get(v6);
  if (!v9) {
    goto LABEL_17;
  }
  int v11 = (BIGNUM *)v9;
  uint64_t v9 = (EC_POINT *)BN_CTX_get(v6);
  if (!v9) {
    goto LABEL_17;
  }
  uint64_t v12 = (BIGNUM *)v9;
  uint64_t v9 = (EC_POINT *)BN_CTX_get(v6);
  if (!v9) {
    goto LABEL_17;
  }
  uint64_t v13 = (BIGNUM *)v9;
  uint64_t v9 = (EC_POINT *)BN_CTX_get(v6);
  if (!v9) {
    goto LABEL_17;
  }
  int v14 = (BIGNUM *)v9;
  uint64_t v9 = (EC_POINT *)BN_CTX_get(v6);
  if (!v9) {
    goto LABEL_17;
  }
  int v24 = (const BIGNUM *)v9;
  uint64_t v9 = (EC_POINT *)BN_CTX_get(v6);
  if (!v9) {
    goto LABEL_17;
  }
  EVP_CIPHER_CTX a = (BIGNUM *)v9;
  uint64_t v9 = (EC_POINT *)BN_CTX_get(v6);
  if (!v9) {
    goto LABEL_17;
  }
  int v22 = (BIGNUM *)v9;
  if (!EC_GROUP_get_order(v8, v10, v6)) {
    goto LABEL_16;
  }
  char v15 = (const EC_POINT *)GOST_KEY_get0_public_key(a3);
  if (BN_is_zero(a2[1])
    || BN_is_zero(*a2)
    || BN_cmp((const BIGNUM *)a2[1], v10) > 0
    || BN_cmp((const BIGNUM *)*a2, v10) >= 1)
  {
    ERR_put_error(50, 4095, 122, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001.c", 288);
    goto LABEL_16;
  }
  if (BN_mod_ct(v11, a1, v10, v6) && (!BN_is_zero((uint64_t)v11) || BN_one((uint64_t)v11)))
  {
    uint64_t v9 = (EC_POINT *)BN_mod_inverse_ct(v22, v11, v10, v6);
    if (!v9) {
      goto LABEL_17;
    }
    unsigned int v18 = (const BIGNUM *)v9;
    if (BN_mod_mul(v12, (const BIGNUM *)a2[1], (const BIGNUM *)v9, v10, v6))
    {
      if (BN_sub(v14, v10, (const BIGNUM *)*a2) && BN_mod_mul(v13, v14, v18, v10, v6))
      {
        uint64_t v9 = EC_POINT_new(v8);
        if (!v9) {
          goto LABEL_17;
        }
        int v19 = v9;
        if (EC_POINT_mul(v8, v9, v12, v15, v13, v6))
        {
          if (EC_POINT_get_affine_coordinates((uint64_t)v8, v19, (uint64_t)v24, 0, v6))
          {
            if (!BN_mod_ct(a, v24, v10, v6))
            {
LABEL_37:
              uint64_t v16 = 0;
LABEL_38:
              uint64_t v9 = v19;
              goto LABEL_18;
            }
            if (!BN_cmp(a, (const BIGNUM *)*a2))
            {
              uint64_t v16 = 1;
              goto LABEL_38;
            }
            int v20 = 121;
            int v21 = 319;
          }
          else
          {
            int v20 = 16;
            int v21 = 313;
          }
        }
        else
        {
          int v20 = 16;
          int v21 = 309;
        }
        ERR_put_error(50, 4095, v20, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001.c", v21);
        goto LABEL_37;
      }
    }
  }
LABEL_16:
  uint64_t v9 = 0;
LABEL_17:
  uint64_t v16 = 0;
LABEL_18:
  EC_POINT_free(v9);
  BN_CTX_end(v6);
  BN_CTX_free(v6);
  return v16;
}

BOOL VKO_compute_key(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const BIGNUM *a5)
{
  int v10 = (const BIGNUM *)GOST_KEY_get0_private_key(a4);
  int v11 = (const EC_GROUP *)GOST_KEY_get0_group(a4);
  uint64_t v12 = (const EC_POINT *)GOST_KEY_get0_public_key(a3);
  uint64_t v13 = EC_POINT_new(v11);
  if (v13 && (int v14 = BN_CTX_new()) != 0)
  {
    char v15 = v14;
    BN_CTX_start(v14);
    uint64_t v16 = BN_CTX_get(v15);
    BOOL v20 = v16
       && (uint64_t v17 = v16, (v18 = BN_CTX_get(v15)) != 0)
       && (int v19 = v18, EC_GROUP_get_order(v11, v18, v15))
       && BN_mod_mul(v17, v10, a5, v19, v15)
       && EC_POINT_mul(v11, v13, 0, v12, v17, v15)
       && EC_POINT_get_affine_coordinates((uint64_t)v11, v13, a1, a2, v15) != 0;
    BN_CTX_end(v15);
    BN_CTX_free(v15);
  }
  else
  {
    BOOL v20 = 0;
  }
  EC_POINT_free(v13);
  return v20;
}

uint64_t gost2001_keygen(const EC_GROUP **a1)
{
  uint64_t v2 = BN_new();
  uint64_t v3 = BN_new();
  unint64_t v4 = (const EC_GROUP *)GOST_KEY_get0_group((uint64_t)a1);
  uint64_t v5 = 0;
  if (v2 && v3)
  {
    if (EC_GROUP_get_order(v4, v2, 0))
    {
      do
      {
        if (!BN_rand_range(v3, v2))
        {
          ERR_put_error(50, 4095, 120, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001.c", 389);
          goto LABEL_9;
        }
      }
      while (BN_is_zero((uint64_t)v3));
      if (!GOST_KEY_set_private_key((uint64_t)a1, v3)) {
        goto LABEL_9;
      }
      uint64_t v5 = gost2001_compute_public(a1);
    }
    else
    {
LABEL_9:
      uint64_t v5 = 0;
    }
  }
  BN_free(v3);
  BN_free(v2);
  return v5;
}

const EVP_MD *EVP_ripemd160(void)
{
  return (const EVP_MD *)&ripemd160_md;
}

uint64_t init_2(uint64_t a1)
{
  return RIPEMD160_Init(*(RIPEMD160_CTX **)(a1 + 24));
}

uint64_t update_2(uint64_t a1, const void *a2, size_t a3)
{
  return RIPEMD160_Update(*(RIPEMD160_CTX **)(a1 + 24), a2, a3);
}

uint64_t final_2(uint64_t a1, unsigned __int8 *md)
{
  return RIPEMD160_Final(md, *(RIPEMD160_CTX **)(a1 + 24));
}

uint64_t pkey_gost_mac_init(uint64_t a1)
{
  uint64_t result = (uint64_t)malloc_type_calloc(1uLL, 0x30uLL, 0x102004094E2EAF5uLL);
  if (result)
  {
    EVP_PKEY_CTX_set_data(a1, result);
    return 1;
  }
  return result;
}

uint64_t pkey_gost_mac_copy(uint64_t a1, uint64_t a2)
{
  uint64_t result = pkey_gost_mac_init(a1);
  if (result)
  {
    unsigned int data = (_OWORD *)EVP_PKEY_CTX_get_data(a2);
    uint64_t v6 = (_OWORD *)EVP_PKEY_CTX_get_data(a1);
    long long v8 = data[1];
    long long v7 = data[2];
    *uint64_t v6 = *data;
    v6[1] = v8;
    unint64_t v6[2] = v7;
    return 1;
  }
  return result;
}

void pkey_gost_mac_cleanup(uint64_t a1)
{
  unsigned int data = (void *)EVP_PKEY_CTX_get_data(a1);
  free(data);
}

uint64_t pkey_gost_mac_keygen(uint64_t a1, EVP_PKEY *a2)
{
  uint64_t data = EVP_PKEY_CTX_get_data(a1);
  if (*(unsigned char *)(data + 40))
  {
    uint64_t v6 = data;
    long long v7 = (char *)malloc_type_malloc(0x20uLL, 0x5F953470uLL);
    if (v7)
    {
      long long v8 = *(_OWORD *)(v6 + 24);
      *(_OWORD *)long long v7 = *(_OWORD *)(v6 + 8);
      *((_OWORD *)v7 + engine_free_util((CRYPTO_EX_DATA *)e, 1) = v8;
      EVP_PKEY_assign(a2, 815, v7);
      return 1;
    }
    int v4 = 65;
    int v5 = 119;
  }
  else
  {
    int v4 = 102;
    int v5 = 113;
  }
  ERR_put_error(50, 4095, v4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gost89imit_pmeth.c", v5);
  return 0;
}

uint64_t pkey_gost_mac_signctx_init()
{
  return 1;
}

uint64_t pkey_gost_mac_signctx(int a1, unsigned __int8 *a2, uint64_t *a3, EVP_MD_CTX *ctx)
{
  unsigned int s = *a3;
  if (a2)
  {
    uint64_t result = EVP_DigestFinal_ex(ctx, a2, &s);
    uint64_t v6 = s;
  }
  else
  {
    uint64_t result = 1;
    uint64_t v6 = 4;
  }
  *a3 = v6;
  return result;
}

uint64_t pkey_gost_mac_ctrl(uint64_t a1, int a2, int a3, const EVP_MD *a4)
{
  uint64_t data = EVP_PKEY_CTX_get_data(a1);
  uint64_t v9 = (void *)data;
  if (a2 != 7)
  {
    if (a2 == 6)
    {
      if (a3 == 32)
      {
        long long v14 = *(_OWORD *)&a4->type;
        *(_OWORD *)(data + 24) = *(_OWORD *)&a4->flags;
        *(_OWORD *)(data + 8) = v14;
        *(unsigned char *)(data + 40) |= 1u;
        return 1;
      }
      int v12 = 101;
      int v13 = 144;
    }
    else
    {
      if (a2 != 1) {
        return 4294967294;
      }
      if (EVP_MD_type(a4) == 815)
      {
        void *v9 = a4;
        return 1;
      }
      int v12 = 100;
      int v13 = 136;
    }
    goto LABEL_22;
  }
  if (*(unsigned char *)(data + 40))
  {
    uint64_t v11 = data + 8;
  }
  else
  {
    uint64_t v10 = EVP_PKEY_CTX_get0_pkey(a1);
    if (!v10)
    {
      int v12 = 102;
      int v13 = 160;
      goto LABEL_22;
    }
    uint64_t v11 = EVP_PKEY_get0(v10);
    if (!v11)
    {
      int v12 = 102;
      int v13 = 165;
LABEL_22:
      ERR_put_error(50, 4095, v12, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gost89imit_pmeth.c", v13);
      return 0;
    }
  }
  uint64_t v16 = *(uint64_t (**)(const EVP_MD *, uint64_t, uint64_t, uint64_t))(*(void *)&a4->type + 72);
  if (!v16) {
    return 0;
  }
  return v16(a4, 3, 256, v11);
}

uint64_t pkey_gost_mac_ctrl_str(uint64_t a1, char *__s1, char *a3)
{
  if (!a3) {
    return 0;
  }
  if (strcmp(__s1, "key"))
  {
    if (strcmp(__s1, "hexkey")) {
      return 4294967294;
    }
    uint64_t len = 0;
    uint64_t v9 = string_to_hex(a3, &len);
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v6 = pkey_gost_mac_ctrl(a1, 6, len, (const EVP_MD *)v9);
      free(v10);
      return v6;
    }
    return 0;
  }
  int v7 = strlen(a3);
  return pkey_gost_mac_ctrl(a1, 6, v7, (const EVP_MD *)a3);
}

int RSA_verify_PKCS1_PSS(RSA *rsa, const unsigned __int8 *mHash, const EVP_MD *Hash, const unsigned __int8 *EM, int sLen)
{
  return RSA_verify_PKCS1_PSS_mgf1(rsa, mHash, Hash, 0, (char *)EM, sLen);
}

uint64_t RSA_verify_PKCS1_PSS_mgf1(const RSA *a1, const void *a2, const EVP_MD *a3, const EVP_MD *a4, char *a5, int a6)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  long long v40 = 0u;
  memset(&ctx, 0, sizeof(ctx));
  EVP_MD_CTX_init(&ctx);
  if (a4) {
    int v12 = a4;
  }
  else {
    int v12 = a3;
  }
  int v13 = EVP_MD_size(a3);
  if (v13 < 0) {
    goto LABEL_38;
  }
  unsigned int v14 = v13;
  if (a6 == -1)
  {
    a6 = v13;
LABEL_9:
    int v17 = (BN_num_bits(a1->n) - 1) & 7;
    int v18 = RSA_size(a1);
    if (*a5 >> v17)
    {
      int v15 = 133;
      int v16 = 120;
      goto LABEL_37;
    }
    int v19 = v18;
    if (v17) {
      BOOL v20 = a5;
    }
    else {
      BOOL v20 = a5 + 1;
    }
    if (v17) {
      int v21 = 0;
    }
    else {
      int v21 = -1;
    }
    int v22 = (__PAIR64__(v18, v17) - 1) >> 32;
    if (v22 < (int)(v14 + a6 + 2))
    {
      int v15 = 109;
      int v16 = 129;
      goto LABEL_37;
    }
    if (v20[v22 - 1] != 188)
    {
      int v15 = 134;
      int v16 = 133;
      goto LABEL_37;
    }
    int v37 = v21;
    int v23 = v22 + ~v14;
    uint64_t len = v23;
    int v24 = (unsigned __int8 *)malloc_type_malloc(v23, 0x2AA7D4E2uLL);
    int v25 = v24;
    if (v24)
    {
      int v26 = (const unsigned __int8 *)&v20[v23];
      if (PKCS1_MGF1(v24, len, v26, v14, v12) < 0)
      {
LABEL_43:
        uint64_t v35 = 0;
        goto LABEL_39;
      }
      if ((int)len >= 1)
      {
        uint64_t v27 = len;
        int v28 = v25;
        do
        {
          char v29 = *v20++;
          *v28++ ^= v29;
          --v27;
        }
        while (v27);
      }
      if (v17) {
        *v25 &= 0xFFu >> (8 - v17);
      }
      uint64_t v30 = 0;
      do
      {
        int v31 = v25[v30];
        if (v25[v30]) {
          BOOL v32 = 0;
        }
        else {
          BOOL v32 = v30 < (int)len - 1;
        }
        ++v30;
      }
      while (v32);
      if (v31 == 1)
      {
        if (a6 < 0 || ~v14 + v19 + v37 - a6 == v30)
        {
          if (!EVP_DigestInit_ex(&ctx, a3, 0)
            || !EVP_DigestUpdate(&ctx, &zeroes, 8uLL)
            || !EVP_DigestUpdate(&ctx, a2, v14)
            || len != v30 && !EVP_DigestUpdate(&ctx, &v25[v30], (int)len - (int)v30)
            || !EVP_DigestFinal_ex(&ctx, md, 0))
          {
            goto LABEL_43;
          }
          if (!timingsafe_bcmp(md, v26, v14))
          {
            uint64_t v35 = 1;
            goto LABEL_39;
          }
          int v33 = 104;
          int v34 = 170;
        }
        else
        {
          int v33 = 136;
          int v34 = 156;
        }
      }
      else
      {
        int v33 = 135;
        int v34 = 152;
      }
    }
    else
    {
      int v33 = 65;
      int v34 = 140;
    }
    ERR_put_error(4, 4095, v33, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pss.c", v34);
    goto LABEL_43;
  }
  if (a6 > -3) {
    goto LABEL_9;
  }
  int v15 = 136;
  int v16 = 113;
LABEL_37:
  ERR_put_error(4, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pss.c", v16);
LABEL_38:
  uint64_t v35 = 0;
  int v25 = 0;
LABEL_39:
  free(v25);
  EVP_MD_CTX_cleanup(&ctx);
  return v35;
}

int RSA_padding_add_PKCS1_PSS(RSA *rsa, unsigned __int8 *EM, const unsigned __int8 *mHash, const EVP_MD *Hash, int sLen)
{
  return RSA_padding_add_PKCS1_PSS_mgf1(rsa, EM, mHash, Hash, 0, sLen);
}

uint64_t RSA_padding_add_PKCS1_PSS_mgf1(const RSA *a1, unsigned __int8 *a2, const void *a3, const EVP_MD *a4, const EVP_MD *a5, int a6)
{
  long long v32 = 0u;
  memset(&v31, 0, sizeof(v31));
  EVP_MD_CTX_init(&v31);
  if (a5) {
    int v12 = a5;
  }
  else {
    int v12 = a4;
  }
  int v13 = EVP_MD_size(a4);
  if (v13 < 0) {
    goto LABEL_18;
  }
  unsigned int v14 = v13;
  if (a6 == -1)
  {
    a6 = v13;
  }
  else if (a6 == -2)
  {
    a6 = -2;
  }
  else if (a6 <= -3)
  {
    int v15 = 136;
    int v16 = 219;
LABEL_17:
    ERR_put_error(4, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pss.c", v16);
LABEL_18:
    uint64_t v20 = 0;
    int v21 = 0;
    goto LABEL_38;
  }
  int v17 = (BN_num_bits(a1->n) - 1) & 7;
  int v18 = RSA_size(a1);
  int v19 = v18;
  if (!v17)
  {
    *a2++ = 0;
    int v19 = v18 - 1;
  }
  if (a6 == -2)
  {
    a6 = v19 - v14 - 2;
    goto LABEL_19;
  }
  if (v19 < (int)(v14 + a6 + 2))
  {
    int v15 = 110;
    int v16 = 232;
    goto LABEL_17;
  }
LABEL_19:
  if (a6 < 1)
  {
    int v21 = 0;
  }
  else
  {
    int v22 = malloc_type_malloc(a6, 0x2133C23DuLL);
    int v21 = v22;
    if (!v22)
    {
      ERR_put_error(4, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_pss.c", 238);
LABEL_37:
      uint64_t v20 = 0;
      goto LABEL_38;
    }
    arc4random_buf(v22, a6);
  }
  if (!EVP_DigestInit_ex(&v31, a4, 0)
    || !EVP_DigestUpdate(&v31, &zeroes, 8uLL)
    || !EVP_DigestUpdate(&v31, a3, v14)
    || a6 && !EVP_DigestUpdate(&v31, v21, a6))
  {
    goto LABEL_37;
  }
  int v23 = v19 + ~v14;
  if (!EVP_DigestFinal_ex(&v31, &a2[v23], 0) || PKCS1_MGF1(a2, v23, &a2[v23], v14, v12)) {
    goto LABEL_37;
  }
  int v24 = v19 - a6 - v14 - 2;
  a2[v24] ^= 1u;
  if (a6 >= 1)
  {
    uint64_t v25 = v24;
    uint64_t v26 = a6;
    uint64_t v27 = &a2[v25 + 1];
    int v28 = (char *)v21;
    do
    {
      char v29 = *v28++;
      *v27++ ^= v29;
      --v26;
    }
    while (v26);
  }
  if (v17) {
    *a2 &= 0xFFu >> (8 - v17);
  }
  a2[v19 - 1] = -68;
  uint64_t v20 = 1;
LABEL_38:
  free(v21);
  EVP_MD_CTX_cleanup(&v31);
  return v20;
}

uint64_t EVP_PKEY_sign_init(uint64_t *a1)
{
  if (a1 && (uint64_t v2 = *a1) != 0 && *(void *)(v2 + 72))
  {
    *((_DWORD *)a1 + 8) = 8;
    uint64_t v3 = *(uint64_t (**)(uint64_t *))(v2 + 64);
    if (v3)
    {
      uint64_t result = v3(a1);
      if ((int)result <= 0) {
        *((_DWORD *)a1 + 8) = 0;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 90);
    return 4294967294;
  }
  return result;
}

uint64_t EVP_PKEY_sign(uint64_t *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  if (!a1
    || (uint64_t v6 = *a1) == 0
    || (int v7 = *(uint64_t (**)(uint64_t *, uint64_t, void *, uint64_t, uint64_t))(v6 + 72)) == 0)
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 107);
    return 4294967294;
  }
  if (*((_DWORD *)a1 + 8) != 8)
  {
    ERR_put_error(6, 4095, 151, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 111);
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned char *)(v6 + 4) & 2) != 0)
  {
    int v12 = EVP_PKEY_size((EVP_PKEY *)a1[2]);
    if (!a2)
    {
      *a3 = v12;
      return 1;
    }
    if (*a3 < (unint64_t)v12)
    {
      ERR_put_error(6, 4095, 155, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 114);
      return 0;
    }
    int v7 = *(uint64_t (**)(uint64_t *, uint64_t, void *, uint64_t, uint64_t))(*a1 + 72);
  }
  return v7(a1, a2, a3, a4, a5);
}

uint64_t EVP_PKEY_verify_init(uint64_t *a1)
{
  if (a1 && (uint64_t v2 = *a1) != 0 && *(void *)(v2 + 88))
  {
    *((_DWORD *)a1 + 8) = 16;
    uint64_t v3 = *(uint64_t (**)(uint64_t *))(v2 + 80);
    if (v3)
    {
      uint64_t result = v3(a1);
      if ((int)result <= 0) {
        *((_DWORD *)a1 + 8) = 0;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 124);
    return 4294967294;
  }
  return result;
}

uint64_t EVP_PKEY_verify(_DWORD *a1)
{
  if (a1 && *(void *)a1 && (int v1 = *(uint64_t (**)(void))(*(void *)a1 + 88)) != 0)
  {
    if (a1[8] == 16)
    {
      return v1();
    }
    else
    {
      ERR_put_error(6, 4095, 151, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 145);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 141);
    return 4294967294;
  }
}

uint64_t EVP_PKEY_verify_recover_init(uint64_t *a1)
{
  if (a1 && (uint64_t v2 = *a1) != 0 && *(void *)(v2 + 104))
  {
    *((_DWORD *)a1 + 8) = 32;
    uint64_t v3 = *(uint64_t (**)(uint64_t *))(v2 + 96);
    if (v3)
    {
      uint64_t result = v3(a1);
      if ((int)result <= 0) {
        *((_DWORD *)a1 + 8) = 0;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 157);
    return 4294967294;
  }
  return result;
}

uint64_t EVP_PKEY_verify_recover(uint64_t *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  if (!a1
    || (uint64_t v6 = *a1) == 0
    || (int v7 = *(uint64_t (**)(uint64_t *, uint64_t, void *, uint64_t, uint64_t))(v6 + 104)) == 0)
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 174);
    return 4294967294;
  }
  if (*((_DWORD *)a1 + 8) != 32)
  {
    ERR_put_error(6, 4095, 151, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 178);
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned char *)(v6 + 4) & 2) != 0)
  {
    int v12 = EVP_PKEY_size((EVP_PKEY *)a1[2]);
    if (!a2)
    {
      *a3 = v12;
      return 1;
    }
    if (*a3 < (unint64_t)v12)
    {
      ERR_put_error(6, 4095, 155, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 181);
      return 0;
    }
    int v7 = *(uint64_t (**)(uint64_t *, uint64_t, void *, uint64_t, uint64_t))(*a1 + 104);
  }
  return v7(a1, a2, a3, a4, a5);
}

uint64_t EVP_PKEY_encrypt_init(uint64_t *a1)
{
  if (a1 && (uint64_t v2 = *a1) != 0 && *(void *)(v2 + 152))
  {
    *((_DWORD *)a1 + 8) = 256;
    uint64_t v3 = *(uint64_t (**)(uint64_t *))(v2 + 144);
    if (v3)
    {
      uint64_t result = v3(a1);
      if ((int)result <= 0) {
        *((_DWORD *)a1 + 8) = 0;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 191);
    return 4294967294;
  }
  return result;
}

int EVP_PKEY_encrypt(unsigned __int8 *enc_key, const unsigned __int8 *key, int key_len, EVP_PKEY *pub_key)
{
  if (!enc_key
    || (uint64_t v6 = *(void *)enc_key) == 0
    || (int v7 = *(uint64_t (**)(unsigned __int8 *, const unsigned __int8 *, void *, EVP_PKEY *, uint64_t))(v6 + 152)) == 0)
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 208);
    return -2;
  }
  if (*((_DWORD *)enc_key + 8) != 256)
  {
    ERR_put_error(6, 4095, 151, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 212);
    return -1;
  }
  uint64_t v8 = v4;
  uint64_t v10 = *(void **)&key_len;
  if ((*(unsigned char *)(v6 + 4) & 2) != 0)
  {
    int v12 = EVP_PKEY_size(*((EVP_PKEY **)enc_key + 2));
    if (!key)
    {
      *uint64_t v10 = v12;
      return 1;
    }
    if (*v10 < (unint64_t)v12)
    {
      ERR_put_error(6, 4095, 155, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 215);
      return 0;
    }
    int v7 = *(uint64_t (**)(unsigned __int8 *, const unsigned __int8 *, void *, EVP_PKEY *, uint64_t))(*(void *)enc_key + 152);
  }
  return v7(enc_key, key, v10, pub_key, v8);
}

uint64_t EVP_PKEY_decrypt_init(uint64_t *a1)
{
  if (a1 && (uint64_t v2 = *a1) != 0 && *(void *)(v2 + 168))
  {
    *((_DWORD *)a1 + 8) = 512;
    uint64_t v3 = *(uint64_t (**)(uint64_t *))(v2 + 160);
    if (v3)
    {
      uint64_t result = v3(a1);
      if ((int)result <= 0) {
        *((_DWORD *)a1 + 8) = 0;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 225);
    return 4294967294;
  }
  return result;
}

int EVP_PKEY_decrypt(unsigned __int8 *dec_key, const unsigned __int8 *enc_key, int enc_key_len, EVP_PKEY *private_key)
{
  if (!dec_key
    || (uint64_t v6 = *(void *)dec_key) == 0
    || (int v7 = *(uint64_t (**)(unsigned __int8 *, const unsigned __int8 *, void *, EVP_PKEY *, uint64_t))(v6 + 168)) == 0)
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 242);
    return -2;
  }
  if (*((_DWORD *)dec_key + 8) != 512)
  {
    ERR_put_error(6, 4095, 151, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 246);
    return -1;
  }
  uint64_t v8 = v4;
  uint64_t v10 = *(void **)&enc_key_len;
  if ((*(unsigned char *)(v6 + 4) & 2) != 0)
  {
    int v12 = EVP_PKEY_size(*((EVP_PKEY **)dec_key + 2));
    if (!enc_key)
    {
      *uint64_t v10 = v12;
      return 1;
    }
    if (*v10 < (unint64_t)v12)
    {
      ERR_put_error(6, 4095, 155, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 249);
      return 0;
    }
    int v7 = *(uint64_t (**)(unsigned __int8 *, const unsigned __int8 *, void *, EVP_PKEY *, uint64_t))(*(void *)dec_key + 168);
  }
  return v7(dec_key, enc_key, v10, private_key, v8);
}

uint64_t EVP_PKEY_derive_init(uint64_t *a1)
{
  if (a1 && (uint64_t v2 = *a1) != 0 && *(void *)(v2 + 184))
  {
    *((_DWORD *)a1 + 8) = 1024;
    uint64_t v3 = *(uint64_t (**)(uint64_t *))(v2 + 176);
    if (v3)
    {
      uint64_t result = v3(a1);
      if ((int)result <= 0) {
        *((_DWORD *)a1 + 8) = 0;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 259);
    return 4294967294;
  }
  return result;
}

uint64_t EVP_PKEY_derive_set_peer(uint64_t a1, const EVP_PKEY *a2)
{
  if (!a1
    || (uint64_t v3 = *(void **)a1) == 0
    || !v3[23] && !v3[19] && !v3[21]
    || (int v5 = (uint64_t (*)(uint64_t, uint64_t, void, const EVP_PKEY *))v3[24]) == 0)
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 279);
    return 4294967294;
  }
  int v6 = *(_DWORD *)(a1 + 32);
  if (v6 != 256 && v6 != 512 && v6 != 1024)
  {
    int v10 = 151;
    int v11 = 285;
LABEL_24:
    ERR_put_error(6, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", v11);
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = v5(a1, 2, 0, a2);
  uint64_t v8 = v7;
  if ((int)v7 < 1) {
    return v8;
  }
  if (v7 == 2) {
    return 1;
  }
  int v12 = *(_DWORD **)(a1 + 16);
  if (!v12)
  {
    int v10 = 154;
    int v11 = 298;
    goto LABEL_24;
  }
  if (*v12 != a2->type)
  {
    int v10 = 101;
    int v11 = 303;
    goto LABEL_24;
  }
  if (!EVP_PKEY_missing_parameters(a2) && !EVP_PKEY_cmp_parameters(*(const EVP_PKEY **)(a1 + 16), a2))
  {
    int v10 = 153;
    int v11 = 314;
    goto LABEL_24;
  }
  EVP_PKEY_free(*(EVP_PKEY **)(a1 + 24));
  *(void *)(a1 + 24) = a2;
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const EVP_PKEY *))(*(void *)a1 + 192))(a1, 2, 1, a2);
  if ((int)v13 <= 0)
  {
    uint64_t v8 = v13;
    *(void *)(a1 + 24) = 0;
  }
  else
  {
    uint64_t v8 = 1;
    CRYPTO_add_lock(&a2->references, 1, 10, 0, 0);
  }
  return v8;
}

uint64_t EVP_PKEY_derive(uint64_t *a1, uint64_t a2, void *a3)
{
  if (!a1 || (uint64_t v4 = *a1) == 0 || (v5 = *(uint64_t (**)(uint64_t *, uint64_t, void *))(v4 + 184)) == 0)
  {
    ERR_put_error(6, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 336);
    return 4294967294;
  }
  if (*((_DWORD *)a1 + 8) != 1024)
  {
    ERR_put_error(6, 4095, 151, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 340);
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned char *)(v4 + 4) & 2) != 0)
  {
    int v8 = EVP_PKEY_size((EVP_PKEY *)a1[2]);
    if (!a2)
    {
      *a3 = v8;
      return 1;
    }
    if (*a3 < (unint64_t)v8)
    {
      ERR_put_error(6, 4095, 155, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/pmeth_fn.c", 343);
      return 0;
    }
    int v5 = *(uint64_t (**)(uint64_t *, uint64_t, void *))(*a1 + 184);
  }
  return v5(a1, a2, a3);
}

uint64_t RSA_bits(uint64_t a1)
{
  return BN_num_bits(*(const BIGNUM **)(a1 + 32));
}

int RSA_size(const RSA *a1)
{
  int v1 = BN_num_bits(a1->n);
  int v2 = v1 + 7;
  if (v1 < -7) {
    int v2 = v1 + 14;
  }
  return v2 >> 3;
}

int RSA_public_encrypt(int flen, const unsigned __int8 *from, unsigned __int8 *to, RSA *rsa, int padding)
{
  return ((uint64_t (*)(void, const unsigned __int8 *, unsigned __int8 *))rsa->meth->rsa_pub_enc)(*(void *)&flen, from, to);
}

int RSA_private_encrypt(int flen, const unsigned __int8 *from, unsigned __int8 *to, RSA *rsa, int padding)
{
  return ((uint64_t (*)(void, const unsigned __int8 *, unsigned __int8 *))rsa->meth->rsa_priv_enc)(*(void *)&flen, from, to);
}

int RSA_private_decrypt(int flen, const unsigned __int8 *from, unsigned __int8 *to, RSA *rsa, int padding)
{
  return ((uint64_t (*)(void, const unsigned __int8 *, unsigned __int8 *))rsa->meth->rsa_priv_dec)(*(void *)&flen, from, to);
}

int RSA_public_decrypt(int flen, const unsigned __int8 *from, unsigned __int8 *to, RSA *rsa, int padding)
{
  return ((uint64_t (*)(void, const unsigned __int8 *, unsigned __int8 *))rsa->meth->rsa_pub_dec)(*(void *)&flen, from, to);
}

int RSA_flags(const RSA *r)
{
  if (r) {
    LODWORD(r) = r->meth->flags;
  }
  return (int)r;
}

void RSA_blinding_off(RSA *rsa)
{
  rsa->bignum_uint64_t data = 0;
  rsa->flags |= 0x80u;
}

int RSA_blinding_on(RSA *rsa, BN_CTX *ctx)
{
  bignum_uint64_t data = rsa->bignum_data;
  if (bignum_data)
  {
    BN_BLINDING_free((BN_BLINDING *)bignum_data);
    rsa->bignum_uint64_t data = 0;
    rsa->flags |= 0x80u;
  }
  int v5 = (char *)RSA_setup_blinding(rsa, ctx);
  rsa->bignum_uint64_t data = v5;
  if (v5)
  {
    rsa->flags &= ~0x80u;
    LODWORD(v5) = 1;
  }
  return (int)v5;
}

BN_BLINDING *__cdecl RSA_setup_blinding(RSA *rsa, BN_CTX *ctx)
{
  uint64_t v4 = ctx;
  if (!ctx)
  {
    uint64_t v4 = BN_CTX_new();
    if (!v4) {
      return 0;
    }
  }
  memset(&m, 0, sizeof(m));
  BN_CTX_start(v4);
  e = rsa->e;
  if (e) {
    goto LABEL_4;
  }
  unsigned int d = rsa->d;
  if (d)
  {
    unsigned int p = rsa->p;
    if (p)
    {
      q = rsa->q;
      if (q)
      {
        BN_CTX_start(v4);
        int v12 = BN_CTX_get(v4);
        if (v12
          && (uint64_t v13 = v12, (v14 = BN_CTX_get(v4)) != 0)
          && (int v15 = v14, (v16 = BN_CTX_get(v4)) != 0)
          && (int v17 = v16, v18 = BN_value_one(), BN_sub(v15, p, v18))
          && (int v19 = BN_value_one(), BN_sub(v17, q, v19))
          && BN_mul(v13, v15, v17, v4))
        {
          e = BN_mod_inverse_ct(0, d, v13, v4);
          BN_CTX_end(v4);
          if (e)
          {
LABEL_4:
            BN_init(&m);
            BN_with_flags((__n128 *)&m, (__n128 *)rsa->n, 4);
            int v6 = BN_BLINDING_create_param(0, e, &m, v4, rsa->meth->bn_mod_exp, rsa->_method_mod_n);
            uint64_t v7 = v6;
            if (v6)
            {
              int v8 = (void *)BN_BLINDING_thread_id((uint64_t)v6);
              CRYPTO_THREADID_current(v8);
            }
            else
            {
              ERR_put_error(4, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_crpt.c", 210);
            }
            goto LABEL_20;
          }
        }
        else
        {
          BN_CTX_end(v4);
        }
      }
    }
  }
  ERR_put_error(4, 4095, 140, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_crpt.c", 197);
  e = 0;
  uint64_t v7 = 0;
LABEL_20:
  BN_CTX_end(v4);
  if (!ctx) {
    BN_CTX_free(v4);
  }
  if (!rsa->e) {
    BN_free(e);
  }
  return v7;
}

ASN1_VALUE *rsa_pss_params_create(EVP_MD *a1, EVP_MD *a2, int a3)
{
  int v6 = RSA_PSS_PARAMS_new();
  if (!v6) {
    goto LABEL_10;
  }
  if (a3 != 20)
  {
    uint64_t v7 = ASN1_INTEGER_new();
    *((void *)v6 + 2) = v7;
    if (!v7 || !ASN1_INTEGER_set(v7, a3)) {
      goto LABEL_10;
    }
  }
  if (!rsa_md_to_algor(v6, a1)) {
    goto LABEL_10;
  }
  if (!a2) {
    a2 = a1;
  }
  if (!rsa_md_to_mgf1((X509_ALGOR **)v6 + 1, a2) || !rsa_md_to_algor((void *)v6 + 4, a2))
  {
LABEL_10:
    RSA_PSS_PARAMS_free(v6);
    return 0;
  }
  return v6;
}

uint64_t rsa_md_to_algor(void *a1, EVP_MD *md)
{
  if (!md) {
    return 1;
  }
  if (EVP_MD_type(md) != 64)
  {
    uint64_t result = (uint64_t)X509_ALGOR_new();
    *a1 = result;
    if (!result) {
      return result;
    }
    X509_ALGOR_set_md((X509_ALGOR *)result, md);
  }
  return 1;
}

BOOL rsa_md_to_mgf1(X509_ALGOR **a1, EVP_MD *md)
{
  punint64_t val = 0;
  obuint64_t j = 0;
  *a1 = 0;
  if (!md || EVP_MD_type(md) == 64) {
    return 1;
  }
  int v5 = rsa_md_to_algor(&obj, md);
  int v6 = (X509_ALGOR *)obj;
  if (v5 && ASN1_item_pack(obj, &X509_ALGOR_it, (ASN1_OCTET_STRING **)&pval))
  {
    uint64_t v7 = X509_ALGOR_new();
    *a1 = v7;
    if (v7)
    {
      int v8 = v7;
      uint64_t v9 = OBJ_nid2obj(911);
      X509_ALGOR_set0(v8, v9, 16, pval);
      punint64_t val = 0;
    }
  }
  ASN1_STRING_free((ASN1_STRING *)pval);
  X509_ALGOR_free(v6);
  return *a1 != 0;
}

uint64_t rsa_pss_get_param(uint64_t result, uint64_t *a2, uint64_t *a3, _DWORD *a4)
{
  if (result)
  {
    uint64_t v7 = result;
    uint64_t result = (uint64_t)rsa_algor_to_md(*(const ASN1_OBJECT ***)result);
    *a2 = result;
    if (result)
    {
      uint64_t result = (uint64_t)rsa_algor_to_md(*(const ASN1_OBJECT ***)(v7 + 32));
      *a3 = result;
      if (result)
      {
        int v8 = *(ASN1_INTEGER **)(v7 + 16);
        if (v8)
        {
          int v9 = ASN1_INTEGER_get(v8);
          *a4 = v9;
          if (v9 < 0)
          {
            int v10 = 150;
            int v11 = 797;
LABEL_11:
            ERR_put_error(4, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", v11);
            return 0;
          }
        }
        else
        {
          *a4 = 20;
        }
        int v12 = *(ASN1_INTEGER **)(v7 + 24);
        if (v12)
        {
          uint64_t result = ASN1_INTEGER_get(v12);
          if (result == 1) {
            return result;
          }
          int v10 = 139;
          int v11 = 809;
          goto LABEL_11;
        }
        return 1;
      }
    }
  }
  return result;
}

const EVP_MD *rsa_algor_to_md(const ASN1_OBJECT **a1)
{
  if (a1)
  {
    int v2 = OBJ_obj2nid(*a1);
    uint64_t v3 = OBJ_nid2sn(v2);
    uint64_t result = EVP_get_digestbyname(v3);
    if (!result)
    {
      ERR_put_error(4, 4095, 166, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", 648);
      return 0;
    }
  }
  else
  {
    return EVP_sha1();
  }
  return result;
}

uint64_t rsa_pub_decode(uint64_t a1, uint64_t a2)
{
  memset(len, 0, sizeof(len));
  algor = 0;
  uint64_t result = X509_PUBKEY_get0_param(0, &len[1], len, &algor, a2);
  if (result)
  {
    uint64_t v4 = d2i_RSAPublicKey(0, (const unsigned __int8 **)&len[1], len[0]);
    if (v4)
    {
      int v5 = (char *)v4;
      if (rsa_param_decode((uint64_t)v4, algor) && EVP_PKEY_assign((EVP_PKEY *)a1, **(_DWORD **)(a1 + 16), v5)) {
        return 1;
      }
      RSA_free((RSA *)v5);
    }
    else
    {
      ERR_put_error(4, 4095, 4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", 168);
    }
    return 0;
  }
  return result;
}

uint64_t rsa_pub_encode(uint64_t a1, uint64_t a2)
{
  oct = 0;
  unsigned __int8 out = 0;
  int v8 = 0;
  uint64_t result = rsa_param_encode(a2, &oct, &v8);
  if (result)
  {
    int v5 = i2d_RSAPublicKey(*(const RSA **)(a2 + 32), &out);
    if (v5 >= 1)
    {
      int v6 = v5;
      uint64_t v7 = OBJ_nid2obj(**(_DWORD **)(a2 + 16));
      if (X509_PUBKEY_set0_param(a1, v7, v8, oct, out, v6)) {
        return 1;
      }
      free(out);
    }
    return 0;
  }
  return result;
}

BOOL rsa_pub_cmp(uint64_t a1, uint64_t a2)
{
  return !BN_cmp(*(const BIGNUM **)(*(void *)(a2 + 32) + 32), *(const BIGNUM **)(*(void *)(a1 + 32) + 32))
      && BN_cmp(*(const BIGNUM **)(*(void *)(a2 + 32) + 40), *(const BIGNUM **)(*(void *)(a1 + 32) + 40)) == 0;
}

uint64_t rsa_pub_print(BIO *a1, uint64_t a2, int a3)
{
  return pkey_rsa_print(a1, a2, a3, 0);
}

uint64_t rsa_priv_decode(uint64_t a1, uint64_t a2)
{
  memset(len, 0, sizeof(len));
  algor = 0;
  uint64_t result = PKCS8_pkey_get0(0, (unsigned __int8 **)&len[1], len, &algor, a2);
  if (result)
  {
    uint64_t v4 = d2i_RSAPrivateKey(0, (const unsigned __int8 **)&len[1], len[0]);
    if (v4)
    {
      int v5 = (char *)v4;
      if (rsa_param_decode((uint64_t)v4, algor))
      {
        EVP_PKEY_assign((EVP_PKEY *)a1, **(_DWORD **)(a1 + 16), v5);
        return 1;
      }
      RSA_free((RSA *)v5);
    }
    else
    {
      ERR_put_error(4, 4095, 4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", 251);
    }
    return 0;
  }
  return result;
}

uint64_t rsa_priv_encode(uint64_t a1, uint64_t a2)
{
  EVP_CIPHER_CTX a = 0;
  unsigned __int8 out = 0;
  pint type = 0;
  uint64_t result = rsa_param_encode(a2, &a, &ptype);
  if (result)
  {
    int v5 = i2d_RSAPrivateKey(*(const RSA **)(a2 + 32), &out);
    if (v5 < 1)
    {
      int v8 = 224;
    }
    else
    {
      int v6 = v5;
      uint64_t v7 = OBJ_nid2obj(**(_DWORD **)(a2 + 16));
      if (PKCS8_pkey_set0(a1, v7, 0, ptype, a, out, v6)) {
        return 1;
      }
      int v8 = 231;
    }
    ERR_put_error(4, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", v8);
    ASN1_STRING_free(a);
    return 0;
  }
  return result;
}

uint64_t rsa_priv_print(BIO *a1, uint64_t a2, int a3)
{
  return pkey_rsa_print(a1, a2, a3, 1);
}

uint64_t int_rsa_size(uint64_t a1)
{
  return RSA_size(*(const RSA **)(a1 + 32));
}

uint64_t rsa_bits(uint64_t a1)
{
  return BN_num_bits(*(const BIGNUM **)(*(void *)(a1 + 32) + 32));
}

uint64_t rsa_security_bits(uint64_t a1)
{
  return RSA_security_bits(*(void *)(a1 + 32));
}

uint64_t rsa_sig_print(BIO *a1, const ASN1_OBJECT **a2, unsigned int *a3, int a4)
{
  if (OBJ_obj2nid(*a2) == 912)
  {
    int v8 = rsa_pss_decode((uint64_t)a2);
    BOOL v9 = rsa_pss_param_print(a1, 0, (uint64_t)v8, a4);
    RSA_PSS_PARAMS_free(v8);
    if (!v9) {
      return 0;
    }
    if (!a3) {
      return 1;
    }
  }
  else if (!a3)
  {
    return BIO_puts(a1, "\n") > 0;
  }
  return X509_signature_dump(a1, a3, a4);
}

void int_rsa_free(uint64_t a1)
{
}

uint64_t rsa_pkey_ctrl(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  munsigned int d = 0;
  v31[0] = 0;
  uint64_t v29 = 0;
  int v28 = 0;
  uint64_t v4 = 4294967294;
  switch(a2)
  {
    case 1:
      if (!a3) {
        PKCS7_SIGNER_INFO_get0_algs(a4, 0, 0, v31);
      }
      goto LABEL_22;
    case 2:
      if (**(_DWORD **)(a1 + 16) == 912) {
        return v4;
      }
      if (!a3) {
        PKCS7_RECIP_INFO_get0_alg((uint64_t)a4, v31);
      }
      goto LABEL_22;
    case 3:
      uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 96);
      if (!v6)
      {
        *(_DWORD *)a4 = 672;
        return 1;
      }
      if (rsa_pss_get_param(v6, (uint64_t *)&md, &v29, &v28))
      {
        *(_DWORD *)a4 = EVP_MD_type(md);
        return 2;
      }
      int v14 = 68;
      int v15 = 576;
      goto LABEL_43;
    case 5:
      if (a3 != 1)
      {
        if (a3) {
          goto LABEL_22;
        }
        LODWORD(v34) = 1;
        uint64_t v35 = 0;
        uint64_t v7 = (uint64_t *)CMS_SignerInfo_get0_pkey_ctx((uint64_t)a4);
        CMS_SignerInfo_get0_algs(a4, 0, 0, 0, &v35);
        if (!v7 || (int)RSA_pkey_ctx_ctrl(v7, -1) >= 1)
        {
          int v8 = v35;
          goto LABEL_23;
        }
        return 0;
      }
      LODWORD(v34) = 0;
      uint64_t v35 = 0;
      int v12 = (uint64_t *)CMS_SignerInfo_get0_pkey_ctx((uint64_t)a4);
      CMS_SignerInfo_get0_algs(a4, 0, 0, 0, &v35);
      int v13 = OBJ_obj2nid(*(const ASN1_OBJECT **)&v35->type);
      if (v13 == 912) {
        return rsa_pss_to_ctx(0, v12, (const ASN1_OBJECT **)v35, 0);
      }
      if (*(_DWORD *)*v12 == 912)
      {
        int v14 = 144;
        int v15 = 830;
LABEL_43:
        ERR_put_error(4, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", v15);
        return 0;
      }
      if (v13 == 6) {
        return 1;
      }
      return OBJ_find_sigid_algs(v13, 0, &v34) && v34 == 6;
    case 7:
      if (**(_DWORD **)(a1 + 16) == 912) {
        return v4;
      }
      if (a3 != 1)
      {
        if (a3)
        {
LABEL_22:
          int v8 = (EVP_MD *)v31[0];
          if (!v31[0]) {
            return 1;
          }
LABEL_23:
          int v10 = OBJ_nid2obj(6);
          X509_ALGOR_set0((X509_ALGOR *)v8, v10, 5, 0);
          return 1;
        }
        int v34 = 0;
        uint64_t v35 = 0;
        v33[0] = 0;
        v33[1] = 0;
        BOOL v9 = (uint64_t *)CMS_RecipientInfo_get0_pkey_ctx((uint64_t)a4);
        int v32 = 1;
        v31[1] = 0;
        if ((int)CMS_RecipientInfo_ktri_get0_algs((uint64_t)a4, 0, 0, v33) >= 1
          && (!v9 || (int)RSA_pkey_ctx_ctrl(v9, -1) >= 1))
        {
          int v8 = (EVP_MD *)v33[0];
          goto LABEL_23;
        }
        return 0;
      }
      uint64_t v16 = CMS_RecipientInfo_get0_pkey_ctx((uint64_t)a4);
      if (!v16) {
        return 0;
      }
      int v17 = (uint64_t *)v16;
      uint64_t v35 = 0;
      if (!CMS_RecipientInfo_ktri_get0_algs((uint64_t)a4, 0, 0, &v35)) {
        return 0xFFFFFFFFLL;
      }
      int v18 = OBJ_obj2nid(*(const ASN1_OBJECT **)&v35->type);
      if (v18 == 6) {
        return 1;
      }
      if (v18 == 919)
      {
        int v19 = (ASN1_VALUE *)ASN1_TYPE_unpack_sequence(&RSA_OAEP_PARAMS_it, *(void *)&v35->md_size);
        if (!v19)
        {
LABEL_40:
          ERR_put_error(4, 4095, 161, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", 980);
          uint64_t v20 = 0;
LABEL_70:
          uint64_t v4 = 0xFFFFFFFFLL;
LABEL_71:
          RSA_OAEP_PARAMS_free(v20);
          return v4;
        }
        uint64_t v20 = v19;
        uint64_t v21 = *((void *)v19 + 1);
        if (v21)
        {
          int v22 = (const ASN1_OBJECT **)rsa_mgf1_decode(v21);
          *((void *)v20 + 3) = v22;
          if (!v22)
          {
            RSA_OAEP_PARAMS_free(v20);
            goto LABEL_40;
          }
        }
        else
        {
          int v22 = (const ASN1_OBJECT **)*((void *)v20 + 3);
        }
        if (!rsa_algor_to_md(v22) || !rsa_algor_to_md(*(const ASN1_OBJECT ***)v20)) {
          goto LABEL_70;
        }
        uint64_t v24 = *((void *)v20 + 2);
        if (v24)
        {
          if (OBJ_obj2nid(*(const ASN1_OBJECT **)v24) == 992)
          {
            uint64_t v25 = *(void *)(v24 + 8);
            if (*(_DWORD *)v25 == 4)
            {
              *(void *)(*(void *)(v25 + 8) + 8) = 0;
              goto LABEL_61;
            }
            int v26 = 160;
            int v27 = 999;
          }
          else
          {
            int v26 = 163;
            int v27 = 995;
          }
          ERR_put_error(4, 4095, v26, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", v27);
          goto LABEL_70;
        }
LABEL_61:
        uint64_t v4 = 0xFFFFFFFFLL;
        if ((int)RSA_pkey_ctx_ctrl(v17, -1) >= 1
          && (int)EVP_PKEY_CTX_ctrl(v17, 6, 768) >= 1
          && (int)RSA_pkey_ctx_ctrl(v17, 1016) >= 1)
        {
          if ((int)EVP_PKEY_CTX_ctrl(v17, 6, 768) < 1) {
            uint64_t v4 = 0xFFFFFFFFLL;
          }
          else {
            uint64_t v4 = 1;
          }
        }
        goto LABEL_71;
      }
      ERR_put_error(4, 4095, 162, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", 973);
      return 0xFFFFFFFFLL;
    case 8:
      if (**(_DWORD **)(a1 + 16) == 912) {
        return v4;
      }
      *(_DWORD *)a4 = 0;
      return 1;
    default:
      return v4;
  }
}

uint64_t old_rsa_priv_decode(uint64_t a1, const unsigned __int8 **a2, int a3)
{
  uint64_t v4 = (char *)d2i_RSAPrivateKey(0, a2, a3);
  if (v4)
  {
    EVP_PKEY_assign((EVP_PKEY *)a1, **(_DWORD **)(a1 + 16), v4);
    return 1;
  }
  else
  {
    ERR_put_error(4, 4095, 4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", 198);
    return 0;
  }
}

uint64_t old_rsa_priv_encode(uint64_t a1, unsigned __int8 **a2)
{
  return i2d_RSAPrivateKey(*(const RSA **)(a1 + 32), a2);
}

uint64_t rsa_item_verify(uint64_t a1, uint64_t a2, uint64_t a3, const ASN1_OBJECT **a4, uint64_t a5, uint64_t a6)
{
  if (OBJ_obj2nid(*a4) == 912)
  {
    if ((int)rsa_pss_to_ctx(a1, 0, a4, a6) <= 0) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 2;
    }
  }
  else
  {
    ERR_put_error(4, 4095, 155, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", 854);
    return 0xFFFFFFFFLL;
  }
}

uint64_t rsa_item_sign(uint64_t a1)
{
  if ((int)RSA_pkey_ctx_ctrl(*(uint64_t **)(a1 + 32), -1) < 1) {
    return 0;
  }
  else {
    return 2;
  }
}

uint64_t rsa_pkey_check(uint64_t a1)
{
  return RSA_check_key(*(const RSA **)(a1 + 32));
}

BOOL rsa_param_decode(uint64_t a1, X509_ALGOR *algor)
{
  ppunint64_t val = 0;
  paobuint64_t j = 0;
  int pptype = 0;
  X509_ALGOR_get0(&paobj, &pptype, &ppval, algor);
  if (OBJ_obj2nid(paobj) != 912 || pptype == -1) {
    return 1;
  }
  if (pptype == 16)
  {
    uint64_t v4 = rsa_pss_decode((uint64_t)algor);
    *(void *)(a1 + 96) = v4;
    return v4 != 0;
  }
  else
  {
    ERR_put_error(4, 4095, 149, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", 126);
    return 0;
  }
}

ASN1_VALUE *rsa_pss_decode(uint64_t a1)
{
  uint64_t v1 = (ASN1_VALUE *)ASN1_TYPE_unpack_sequence(&RSA_PSS_PARAMS_it, *(void *)(a1 + 8));
  int v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((void *)v1 + 1);
    if (v3)
    {
      uint64_t v4 = rsa_mgf1_decode(v3);
      *((void *)v2 + 4) = v4;
      if (!v4)
      {
        RSA_PSS_PARAMS_free(v2);
        return 0;
      }
    }
  }
  return v2;
}

void *rsa_mgf1_decode(uint64_t a1)
{
  if (OBJ_obj2nid(*(const ASN1_OBJECT **)a1) != 911) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 8);
  return ASN1_TYPE_unpack_sequence((ASN1_ITEM *)&X509_ALGOR_it, v2);
}

uint64_t rsa_param_encode(uint64_t a1, ASN1_OCTET_STRING **oct, int *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  ASN1_OCTET_STRING *oct = 0;
  if (**(_DWORD **)(a1 + 16) == 912)
  {
    int v5 = *(void **)(v4 + 96);
    if (v5)
    {
      uint64_t result = (uint64_t)ASN1_item_pack(v5, &RSA_PSS_PARAMS_it, oct);
      if (!result) {
        return result;
      }
      int v7 = 16;
    }
    else
    {
      int v7 = -1;
    }
  }
  else
  {
    int v7 = 5;
  }
  *a3 = v7;
  return 1;
}

uint64_t pkey_rsa_print(BIO *a1, uint64_t a2, int a3, int a4)
{
  uint64_t v8 = *(void *)(a2 + 32);
  BOOL v9 = *(const BIGNUM **)(v8 + 32);
  if (v9)
  {
    int v10 = BN_num_bits(v9);
    int v11 = v10 + 7;
    if (v10 < -7) {
      int v11 = v10 + 14;
    }
    int v12 = v11 >> 3;
    if ((v10 + 14) < 0xF) {
      int v12 = 0;
    }
    unint64_t v13 = v12;
  }
  else
  {
    unint64_t v13 = 0;
  }
  int v14 = *(const BIGNUM **)(v8 + 40);
  if (v14)
  {
    int v15 = BN_num_bits(v14);
    int v16 = v15 + 7;
    if (v15 < -7) {
      int v16 = v15 + 14;
    }
    int v17 = v16 >> 3;
    uint64_t v18 = (uint64_t)v16 >> 3;
    if (v13 <= v17) {
      unint64_t v13 = v18;
    }
  }
  if (a4)
  {
    int v19 = *(const BIGNUM **)(v8 + 48);
    if (v19)
    {
      int v20 = BN_num_bits(v19);
      int v21 = v20 + 7;
      if (v20 < -7) {
        int v21 = v20 + 14;
      }
      int v22 = v21 >> 3;
      uint64_t v23 = (uint64_t)v21 >> 3;
      if (v13 <= v22) {
        unint64_t v13 = v23;
      }
    }
    uint64_t v24 = *(const BIGNUM **)(v8 + 56);
    if (v24)
    {
      int v25 = BN_num_bits(v24);
      int v26 = v25 + 7;
      if (v25 < -7) {
        int v26 = v25 + 14;
      }
      int v27 = v26 >> 3;
      uint64_t v28 = (uint64_t)v26 >> 3;
      if (v13 <= v27) {
        unint64_t v13 = v28;
      }
    }
    uint64_t v29 = *(const BIGNUM **)(v8 + 64);
    if (v29)
    {
      int v30 = BN_num_bits(v29);
      int v31 = v30 + 7;
      if (v30 < -7) {
        int v31 = v30 + 14;
      }
      int v32 = v31 >> 3;
      uint64_t v33 = (uint64_t)v31 >> 3;
      if (v13 <= v32) {
        unint64_t v13 = v33;
      }
    }
    int v34 = *(const BIGNUM **)(v8 + 72);
    if (v34)
    {
      int v35 = BN_num_bits(v34);
      int v36 = v35 + 7;
      if (v35 < -7) {
        int v36 = v35 + 14;
      }
      int v37 = v36 >> 3;
      uint64_t v38 = (uint64_t)v36 >> 3;
      if (v13 <= v37) {
        unint64_t v13 = v38;
      }
    }
    unsigned int v39 = *(const BIGNUM **)(v8 + 80);
    if (v39)
    {
      int v40 = BN_num_bits(v39);
      int v41 = v40 + 7;
      if (v40 < -7) {
        int v41 = v40 + 14;
      }
      int v42 = v41 >> 3;
      uint64_t v43 = (uint64_t)v41 >> 3;
      if (v13 <= v42) {
        unint64_t v13 = v43;
      }
    }
    int v44 = *(const BIGNUM **)(v8 + 88);
    if (v44)
    {
      int v45 = BN_num_bits(v44);
      int v46 = v45 + 7;
      if (v45 < -7) {
        int v46 = v45 + 14;
      }
      int v47 = v46 >> 3;
      uint64_t v48 = (uint64_t)v46 >> 3;
      if (v13 <= v47) {
        unint64_t v13 = v48;
      }
    }
  }
  int v49 = (unsigned __int8 *)malloc_type_malloc(v13 + 10, 0xD5BF1E8EuLL);
  if (!v49)
  {
    ERR_put_error(4, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", 446);
    goto LABEL_72;
  }
  int v50 = *(const BIGNUM **)(v8 + 32);
  if (v50) {
    int v51 = BN_num_bits(v50);
  }
  else {
    int v51 = 0;
  }
  if (!BIO_indent(a1, a3, 128)) {
    goto LABEL_72;
  }
  unsigned int v52 = **(_DWORD **)(a2 + 16) == 912 ? "RSA-PSS" : "RSA";
  if (BIO_printf(a1, "%s ", v52) < 1) {
    goto LABEL_72;
  }
  if (a4 && *(void *)(v8 + 48))
  {
    if (BIO_printf(a1, "Private-Key: (%d bit)\n", v51) >= 1)
    {
      uint16x8_t v53 = "publicExponent:";
      int v54 = "modulus:";
      goto LABEL_60;
    }
LABEL_72:
    uint64_t v55 = 0;
    goto LABEL_73;
  }
  if (BIO_printf(a1, "Public-Key: (%d bit)\n", v51) < 1) {
    goto LABEL_72;
  }
  uint16x8_t v53 = "Exponent:";
  int v54 = "Modulus:";
LABEL_60:
  if (!ASN1_bn_print(a1, v54, *(const BIGNUM **)(v8 + 32), v49, a3)
    || !ASN1_bn_print(a1, v53, *(const BIGNUM **)(v8 + 40), v49, a3)
    || a4
    && (!ASN1_bn_print(a1, "privateExponent:", *(const BIGNUM **)(v8 + 48), v49, a3)
     || !ASN1_bn_print(a1, "prime1:", *(const BIGNUM **)(v8 + 56), v49, a3)
     || !ASN1_bn_print(a1, "prime2:", *(const BIGNUM **)(v8 + 64), v49, a3)
     || !ASN1_bn_print(a1, "exponent1:", *(const BIGNUM **)(v8 + 72), v49, a3)
     || !ASN1_bn_print(a1, "exponent2:", *(const BIGNUM **)(v8 + 80), v49, a3)
     || !ASN1_bn_print(a1, "coefficient:", *(const BIGNUM **)(v8 + 88), v49, a3))
    || **(_DWORD **)(a2 + 16) == 912 && !rsa_pss_param_print(a1, 1, *(void *)(v8 + 96), a3))
  {
    goto LABEL_72;
  }
  uint64_t v55 = 1;
LABEL_73:
  free(v49);
  return v55;
}

BOOL rsa_pss_param_print(BIO *a1, int a2, uint64_t a3, int indent)
{
  if (!BIO_indent(a1, indent, 128)) {
    goto LABEL_28;
  }
  if (!a2)
  {
    if (a3) {
      goto LABEL_7;
    }
    int v11 = "(INVALID PSS PARAMETERS)\n";
    return BIO_puts(a1, v11) > 0;
  }
  if (!a3)
  {
    int v11 = "No PSS parameter restrictions\n";
    return BIO_puts(a1, v11) > 0;
  }
  if (BIO_puts(a1, "PSS parameter restrictions:") >= 1)
  {
LABEL_7:
    if (BIO_puts(a1, "\n") >= 1)
    {
      int v9 = a2 ? indent + 2 : indent;
      if (BIO_indent(a1, v9, 128) && BIO_puts(a1, "Hash Algorithm: ") >= 1)
      {
        int v10 = *(void *)a3 ? i2a_ASN1_OBJECT(a1, **(ASN1_OBJECT ***)a3) : BIO_puts(a1, "sha1 (default)");
        if (v10 >= 1 && BIO_puts(a1, "\n") >= 1 && BIO_indent(a1, v9, 128) && BIO_puts(a1, "Mask Algorithm: ") >= 1)
        {
          int v12 = *(ASN1_OBJECT ***)(a3 + 8);
          if (!v12)
          {
            int v15 = BIO_puts(a1, "mgf1 with sha1 (default)");
            int v14 = 0;
            if (v15 < 1) {
              goto LABEL_49;
            }
            BIO_puts(a1, "\n");
            if (!BIO_indent(a1, v9, 128)) {
              goto LABEL_49;
            }
LABEL_32:
            int v17 = "Minimum";
            if (!a2) {
              int v17 = "";
            }
            if (BIO_printf(a1, "%s Salt Length: 0x", v17) >= 1
              && ((uint64_t v18 = *(ASN1_INTEGER **)(a3 + 16)) == 0
                ? (int v19 = BIO_puts(a1, "14 (default)"))
                : (int v19 = i2a_ASN1_INTEGER(a1, v18)),
                  v19 >= 1
               && (BIO_puts(a1, "\n"), BIO_indent(a1, v9, 128))
               && BIO_puts(a1, "Trailer Field: 0x") >= 1
               && ((int v20 = *(ASN1_INTEGER **)(a3 + 24)) == 0
                 ? (int v21 = BIO_puts(a1, "BC (default)"))
                 : (int v21 = i2a_ASN1_INTEGER(a1, v20)),
                   v21 >= 1)))
            {
              BIO_puts(a1, "\n");
              uint64_t v8 = 1;
            }
            else
            {
LABEL_49:
              uint64_t v8 = 0;
            }
            goto LABEL_29;
          }
          if (i2a_ASN1_OBJECT(a1, *v12) >= 1 && BIO_puts(a1, " with ") >= 1)
          {
            unint64_t v13 = (ASN1_OBJECT **)rsa_mgf1_decode(*(void *)(a3 + 8));
            int v14 = (X509_ALGOR *)v13;
            if (v13) {
              int v15 = i2a_ASN1_OBJECT(a1, *v13);
            }
            else {
              int v15 = BIO_puts(a1, "INVALID");
            }
            goto LABEL_32;
          }
        }
      }
    }
LABEL_28:
    uint64_t v8 = 0;
    int v14 = 0;
LABEL_29:
    X509_ALGOR_free(v14);
    return v8;
  }
  return 0;
}

ASN1_STRING *rsa_ctx_to_pss_string(uint64_t *a1)
{
  EVP_PKEY_CTX_get0_pkey((uint64_t)a1);
  if ((int)EVP_PKEY_CTX_ctrl(a1, -1, 248) < 1) {
    return 0;
  }
  if ((int)RSA_pkey_ctx_ctrl(a1, 1016) < 1) {
    return 0;
  }
  if (!RSA_pkey_ctx_ctrl(a1, 24)) {
    return 0;
  }
  uint64_t v2 = rsa_pss_params_create(0, 0, 0);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v2;
  uint64_t v4 = ASN1_item_pack(v2, &RSA_PSS_PARAMS_it, 0);
  RSA_PSS_PARAMS_free(v3);
  return v4;
}

uint64_t rsa_pss_to_ctx(uint64_t a1, uint64_t *a2, const ASN1_OBJECT **a3, uint64_t a4)
{
  uint64_t v6 = a2;
  int v17 = a2;
  munsigned int d = 0;
  uint64_t v15 = 0;
  if (OBJ_obj2nid(*a3) == 912)
  {
    int v16 = 0;
    uint64_t v8 = rsa_pss_decode((uint64_t)a3);
    if (rsa_pss_get_param((uint64_t)v8, (uint64_t *)&md, &v15, &v16))
    {
      if (a4)
      {
        if (EVP_DigestVerifyInit(a1, &v17, md, 0, a4))
        {
          uint64_t v6 = v17;
LABEL_14:
          uint64_t v9 = 0xFFFFFFFFLL;
          if ((int)RSA_pkey_ctx_ctrl(v6, -1) >= 1 && (int)RSA_pkey_ctx_ctrl(v17, 24) >= 1)
          {
            if ((int)RSA_pkey_ctx_ctrl(v17, 1016) < 1) {
              uint64_t v9 = 0xFFFFFFFFLL;
            }
            else {
              uint64_t v9 = 1;
            }
          }
          goto LABEL_10;
        }
LABEL_9:
        uint64_t v9 = 0xFFFFFFFFLL;
LABEL_10:
        RSA_PSS_PARAMS_free(v8);
        return v9;
      }
      if ((int)EVP_PKEY_CTX_ctrl(v6, -1, 248) < 1) {
        goto LABEL_9;
      }
      int v13 = EVP_MD_type(md);
      if (v13 == EVP_MD_type(0)) {
        goto LABEL_14;
      }
      int v10 = 158;
      int v11 = 761;
    }
    else
    {
      int v10 = 149;
      int v11 = 748;
    }
    ERR_put_error(4, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", v11);
    goto LABEL_9;
  }
  ERR_put_error(4, 4095, 155, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_ameth.c", 741);
  return 0xFFFFFFFFLL;
}

ASN1_VALUE *d2i_CMS_ContentInfo(ASN1_VALUE **a1, const unsigned __int8 **a2, uint64_t a3)
{
  return ASN1_item_d2i(a1, a2, a3, &CMS_ContentInfo_it);
}

uint64_t i2d_CMS_ContentInfo(ASN1_VALUE *a1, unsigned __int8 **a2)
{
  return ASN1_item_i2d(a1, a2, &CMS_ContentInfo_it);
}

ASN1_VALUE *CMS_ContentInfo_new()
{
  return ASN1_item_new(&CMS_ContentInfo_it);
}

void CMS_ContentInfo_free(ASN1_VALUE *a1)
{
}

uint64_t CMS_ContentInfo_print_ctx(BIO *a1, ASN1_VALUE *a2, uint64_t a3, uint64_t *a4)
{
  return ASN1_item_print(a1, a2, a3, &CMS_ContentInfo_it, a4);
}

uint64_t CMS_get0_type(uint64_t a1)
{
  return *(void *)a1;
}

ASN1_VALUE *cms_Data_create()
{
  BOOL v0 = ASN1_item_new(&CMS_ContentInfo_it);
  if (v0)
  {
    *(void *)BOOL v0 = OBJ_nid2obj(21);
    CMS_set_detached((uint64_t)v0, 0);
  }
  return v0;
}

uint64_t CMS_set_detached(uint64_t a1, int a2)
{
  uint64_t result = (uint64_t)CMS_get0_content(a1);
  if (result)
  {
    uint64_t v4 = (ASN1_OCTET_STRING **)result;
    int v5 = *(ASN1_OCTET_STRING **)result;
    if (a2)
    {
      ASN1_OCTET_STRING_free(v5);
      ASN1_STRING *v4 = 0;
    }
    else
    {
      if (!v5)
      {
        int v5 = ASN1_OCTET_STRING_new();
        ASN1_STRING *v4 = v5;
        if (!v5)
        {
          ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", 375);
          return 0;
        }
      }
      v5->flags |= 0x20uLL;
    }
    return 1;
  }
  return result;
}

BIO *cms_content_bio(uint64_t a1)
{
  uint64_t result = (BIO *)CMS_get0_content(a1);
  if (!result) {
    return result;
  }
  int method = result->method;
  if (!result->method)
  {
    uint64_t v3 = BIO_s_null();
    goto LABEL_7;
  }
  if (method->bwrite == (int (__cdecl *)(BIO *, const char *, int))32)
  {
    uint64_t v3 = BIO_s_mem();
LABEL_7:
    return BIO_new(v3);
  }
  name = (char *)method->name;
  int type = method->type;
  return BIO_new_mem_buf(name, type);
}

_DWORD *CMS_get0_content(uint64_t a1)
{
  int v2 = OBJ_obj2nid(*(const ASN1_OBJECT **)a1);
  switch(v2)
  {
    case 21:
      return (_DWORD *)(a1 + 8);
    case 22:
    case 25:
      uint64_t v3 = *(_DWORD **)(*(void *)(a1 + 8) + 16);
      return v3 + 2;
    case 23:
      uint64_t v5 = *(void *)(*(void *)(a1 + 8) + 24);
      return (_DWORD *)(v5 + 16);
    case 24:
      goto LABEL_6;
    case 26:
      uint64_t v5 = *(void *)(*(void *)(a1 + 8) + 8);
      return (_DWORD *)(v5 + 16);
    default:
      if (v2 == 205)
      {
        uint64_t v3 = *(_DWORD **)(*(void *)(a1 + 8) + 40);
      }
      else if (v2 == 786)
      {
        uint64_t v3 = *(_DWORD **)(*(void *)(a1 + 8) + 24);
      }
      else
      {
LABEL_6:
        uint64_t v3 = *(_DWORD **)(a1 + 8);
        if (*v3 != 4)
        {
          ERR_put_error(46, 4095, 152, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", 270);
          return 0;
        }
      }
      return v3 + 2;
  }
}

BIO *CMS_dataInit(const ASN1_OBJECT **a1, BIO *a2)
{
  uint64_t v4 = a2;
  if (a2 || (uint64_t v4 = cms_content_bio((uint64_t)a1)) != 0)
  {
    switch(OBJ_obj2nid(*a1))
    {
      case 21:
        return v4;
      case 22:
        initeunsigned int d = cms_SignedData_init_bio((uint64_t)a1);
        if (!inited) {
          goto LABEL_14;
        }
        goto LABEL_10;
      case 23:
        initeunsigned int d = cms_EnvelopedData_init_bio((uint64_t)a1);
        if (!inited) {
          goto LABEL_14;
        }
        goto LABEL_10;
      case 25:
        initeunsigned int d = cms_DigestedData_init_bio((uint64_t)a1);
        if (inited) {
          goto LABEL_10;
        }
        goto LABEL_14;
      case 26:
        initeunsigned int d = cms_EncryptedData_init_bio((uint64_t)a1);
        if (inited)
        {
LABEL_10:
          return BIO_push(inited, v4);
        }
LABEL_14:
        if (!a2) {
          BIO_free(v4);
        }
LABEL_16:
        uint64_t v4 = 0;
        break;
      default:
        ERR_put_error(46, 4095, 156, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", 178);
        goto LABEL_16;
    }
  }
  else
  {
    ERR_put_error(46, 4095, 127, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", 148);
  }
  return v4;
}

uint64_t CMS_dataFinal(const ASN1_OBJECT **a1, BIO *a2)
{
  uint64_t result = (uint64_t)CMS_get0_content((uint64_t)a1);
  if (result)
  {
    uint64_t v5 = (ASN1_STRING **)result;
    if (*(void *)result && (*(unsigned char *)(*(void *)result + 16) & 0x20) != 0)
    {
      plong long arg = 0;
      int type = BIO_find_type(a2, 1025);
      if (!type)
      {
        int v10 = 105;
        int v11 = 205;
LABEL_11:
        ERR_put_error(46, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", v11);
        return 0;
      }
      int v7 = type;
      int v8 = BIO_ctrl(type, 3, 0, &parg);
      BIO_set_flags(v7, 512);
      BIO_ctrl(v7, 130, 0, 0);
      ASN1_STRING_set0(*v5, parg, v8);
      (*v5)->flags &= ~0x20uLL;
    }
    int v9 = OBJ_obj2nid(*a1);
    uint64_t result = 1;
    switch(v9)
    {
      case 21:
      case 23:
      case 26:
        return result;
      case 22:
        return cms_SignedData_final((uint64_t)a1, a2);
      case 24:
        goto LABEL_9;
      case 25:
        return cms_DigestedData_do_final((uint64_t)a1, a2, 0);
      default:
        if (v9 == 786) {
          return result;
        }
LABEL_9:
        int v10 = 156;
        int v11 = 232;
        break;
    }
    goto LABEL_11;
  }
  return result;
}

uint64_t CMS_get0_eContentType(uint64_t a1)
{
  uint64_t result = cms_get0_econtent_type(a1);
  if (result) {
    return *(void *)result;
  }
  return result;
}

uint64_t cms_get0_econtent_type(uint64_t a1)
{
  int v2 = OBJ_obj2nid(*(const ASN1_OBJECT **)a1);
  switch(v2)
  {
    case 22:
    case 25:
      return *(void *)(*(void *)(a1 + 8) + 16);
    case 23:
      return *(void *)(*(void *)(a1 + 8) + 24);
    case 24:
      goto LABEL_6;
    case 26:
      return *(void *)(*(void *)(a1 + 8) + 8);
    default:
      if (v2 == 205) {
        return *(void *)(*(void *)(a1 + 8) + 40);
      }
      if (v2 == 786) {
        return *(void *)(*(void *)(a1 + 8) + 24);
      }
LABEL_6:
      ERR_put_error(46, 4095, 152, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", 303);
      return 0;
  }
}

uint64_t CMS_set1_eContentType(uint64_t a1, const ASN1_OBJECT *a2)
{
  uint64_t result = cms_get0_econtent_type(a1);
  if (result)
  {
    if (a2)
    {
      uint64_t v4 = (ASN1_OBJECT **)result;
      uint64_t result = (uint64_t)OBJ_dup(a2);
      if (!result) {
        return result;
      }
      uint64_t v5 = (ASN1_OBJECT *)result;
      ASN1_OBJECT_free(*v4);
      BIO *v4 = v5;
    }
    return 1;
  }
  return result;
}

uint64_t CMS_is_detached(uint64_t a1)
{
  uint64_t v1 = CMS_get0_content(a1);
  if (v1) {
    return *(void *)v1 == 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

BIO *cms_DigestAlgorithm_init_bio(X509_ALGOR *algor)
{
  paobuint64_t j = 0;
  X509_ALGOR_get0(&paobj, 0, 0, algor);
  int v1 = OBJ_obj2nid(paobj);
  int v2 = OBJ_nid2sn(v1);
  digestbyname = EVP_get_digestbyname(v2);
  if (!digestbyname)
  {
    ERR_put_error(46, 4095, 149, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", 392);
    int v7 = 0;
    goto LABEL_6;
  }
  uint64_t v4 = (EVP_MD *)digestbyname;
  uint64_t v5 = BIO_f_md();
  uint64_t v6 = BIO_new(v5);
  int v7 = v6;
  if (!v6 || !BIO_ctrl(v6, 111, 0, v4))
  {
    ERR_put_error(46, 4095, 119, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", 397);
LABEL_6:
    BIO_free(v7);
    return 0;
  }
  return v7;
}

uint64_t cms_DigestAlgorithm_find_ctx(EVP_MD_CTX *a1, BIO *a2, X509_ALGOR *algor)
{
  paobuint64_t j = 0;
  X509_ALGOR_get0(&paobj, 0, 0, algor);
  int v5 = OBJ_obj2nid(paobj);
  EVP_MD_CTX ctx = 0;
  int type = BIO_find_type(a2, 520);
  if (type)
  {
    int v7 = type;
    while (1)
    {
      BIO_ctrl(v7, 120, 0, &ctx);
      int v8 = EVP_MD_CTX_md(ctx);
      if (EVP_MD_type(v8) == v5) {
        break;
      }
      int v9 = EVP_MD_CTX_md(ctx);
      if (EVP_MD_pkey_type(v9) == v5) {
        break;
      }
      int v10 = BIO_next(v7);
      EVP_MD_CTX ctx = 0;
      int v7 = BIO_find_type(v10, 520);
      if (!v7) {
        goto LABEL_6;
      }
    }
    return EVP_MD_CTX_copy_ex(a1, ctx);
  }
  else
  {
LABEL_6:
    ERR_put_error(46, 4095, 131, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", 423);
    return 0;
  }
}

ASN1_VALUE *CMS_add0_CertificateChoices(uint64_t a1)
{
  int v1 = (STACK **)cms_get0_certificate_choices(a1);
  if (!v1) {
    return 0;
  }
  int v2 = v1;
  if (!*v1)
  {
    uint64_t v3 = sk_new_null();
    *int v2 = v3;
    if (!v3) {
      return 0;
    }
  }
  uint64_t v4 = ASN1_item_new(&CMS_CertificateChoices_it);
  if (v4 && !sk_push(*v2, (char *)v4))
  {
    ASN1_item_free(v4, &CMS_CertificateChoices_it);
    return 0;
  }
  return v4;
}

uint64_t cms_get0_certificate_choices(uint64_t a1)
{
  int v2 = OBJ_obj2nid(*(const ASN1_OBJECT **)a1);
  if (v2 == 23) {
    return *(void *)(*(void *)(a1 + 8) + 8);
  }
  if (v2 == 22) {
    return *(void *)(a1 + 8) + 24;
  }
  ERR_put_error(46, 4095, 152, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", 451);
  return 0;
}

uint64_t CMS_add0_cert(uint64_t a1, const X509 *a2)
{
  uint64_t result = cms_get0_certificate_choices(a1);
  if (result)
  {
    int v5 = (const STACK **)result;
    if (sk_num(*(const STACK **)result) < 1)
    {
LABEL_7:
      uint64_t result = (uint64_t)CMS_add0_CertificateChoices(a1);
      if (result)
      {
        *(_DWORD *)uint64_t result = 0;
        *(void *)(result + 8) = a2;
        return 1;
      }
    }
    else
    {
      int v6 = 0;
      while (1)
      {
        int v7 = sk_value(*v5, v6);
        if (!*(_DWORD *)v7 && !X509_cmp(*((const X509 **)v7 + 1), a2)) {
          break;
        }
        if (++v6 >= sk_num(*v5)) {
          goto LABEL_7;
        }
      }
      ERR_put_error(46, 4095, 175, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", 494);
      return 0;
    }
  }
  return result;
}

uint64_t CMS_add1_cert(uint64_t a1, const X509 *a2)
{
  uint64_t v3 = CMS_add0_cert(a1, a2);
  if (v3) {
    X509_up_ref((uint64_t)a2);
  }
  return v3;
}

ASN1_VALUE *CMS_add0_RevocationInfoChoice(uint64_t a1)
{
  int v1 = (STACK **)cms_get0_revocation_choices(a1);
  if (!v1) {
    return 0;
  }
  int v2 = v1;
  if (!*v1)
  {
    uint64_t v3 = sk_new_null();
    *int v2 = v3;
    if (!v3) {
      return 0;
    }
  }
  uint64_t v4 = ASN1_item_new(&CMS_RevocationInfoChoice_it);
  if (v4 && !sk_push(*v2, (char *)v4))
  {
    ASN1_item_free(v4, &CMS_RevocationInfoChoice_it);
    return 0;
  }
  return v4;
}

uint64_t cms_get0_revocation_choices(uint64_t a1)
{
  int v2 = OBJ_obj2nid(*(const ASN1_OBJECT **)a1);
  if (v2 == 23)
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 8) + 8);
    if (v4) {
      return v4 + 8;
    }
    else {
      return 0;
    }
  }
  else if (v2 == 22)
  {
    return *(void *)(a1 + 8) + 32;
  }
  else
  {
    ERR_put_error(46, 4095, 152, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", 533);
    return 0;
  }
}

ASN1_VALUE *CMS_add0_crl(uint64_t a1, uint64_t a2)
{
  uint64_t result = CMS_add0_RevocationInfoChoice(a1);
  if (result)
  {
    *(_DWORD *)uint64_t result = 0;
    *((void *)result + engine_free_util((CRYPTO_EX_DATA *)e, 1) = a2;
    return (ASN1_VALUE *)1;
  }
  return result;
}

ASN1_VALUE *CMS_add1_crl(uint64_t a1, uint64_t a2)
{
  uint64_t result = CMS_add0_RevocationInfoChoice(a1);
  if (result)
  {
    *(_DWORD *)uint64_t result = 0;
    *((void *)result + engine_free_util((CRYPTO_EX_DATA *)e, 1) = a2;
    X509_CRL_up_ref(a2);
    return (ASN1_VALUE *)1;
  }
  return result;
}

STACK *CMS_get1_certs(uint64_t a1)
{
  int v1 = (const STACK **)cms_get0_certificate_choices(a1);
  if (!v1) {
    return 0;
  }
  int v2 = v1;
  if (sk_num(*v1) < 1) {
    return 0;
  }
  int v3 = 0;
  uint64_t v4 = 0;
  while (1)
  {
    int v5 = sk_value(*v2, v3);
    if (!*(_DWORD *)v5) {
      break;
    }
LABEL_9:
    if (++v3 >= sk_num(*v2)) {
      return v4;
    }
  }
  int v6 = v5;
  if (!v4)
  {
    uint64_t v4 = sk_new_null();
    if (!v4) {
      return v4;
    }
  }
  if (sk_push(v4, *((char **)v6 + 1)))
  {
    X509_up_ref(*((void *)v6 + 1));
    goto LABEL_9;
  }
  sk_pop_free(v4, (void (__cdecl *)(void *))X509_free);
  return 0;
}

STACK *CMS_get1_crls(uint64_t a1)
{
  int v1 = (const STACK **)cms_get0_revocation_choices(a1);
  if (!v1) {
    return 0;
  }
  int v2 = v1;
  if (sk_num(*v1) < 1) {
    return 0;
  }
  int v3 = 0;
  uint64_t v4 = 0;
  while (1)
  {
    int v5 = sk_value(*v2, v3);
    if (!*(_DWORD *)v5) {
      break;
    }
LABEL_9:
    if (++v3 >= sk_num(*v2)) {
      return v4;
    }
  }
  int v6 = v5;
  if (!v4)
  {
    uint64_t v4 = sk_new_null();
    if (!v4) {
      return v4;
    }
  }
  if (sk_push(v4, *((char **)v6 + 1)))
  {
    X509_CRL_up_ref(*((void *)v6 + 1));
    goto LABEL_9;
  }
  sk_pop_free(v4, (void (__cdecl *)(void *))X509_CRL_free);
  return 0;
}

uint64_t cms_ias_cert_cmp(uint64_t a1, X509 *a)
{
  uint64_t v4 = *(const X509_NAME **)a1;
  issuer_name = X509_get_issuer_name(a);
  uint64_t result = X509_NAME_cmp(v4, issuer_name);
  if (!result)
  {
    int v7 = *(ASN1_INTEGER **)(a1 + 8);
    serialNumber = X509_get_serialNumber(a);
    return ASN1_INTEGER_cmp(v7, serialNumber);
  }
  return result;
}

uint64_t cms_keyid_cert_cmp(ASN1_OCTET_STRING *a1, X509 *x)
{
  X509_check_purpose(x, -1, -1);
  ex_xkusage = (ASN1_OCTET_STRING *)x->ex_xkusage;
  if (!ex_xkusage) {
    return 0xFFFFFFFFLL;
  }
  return ASN1_OCTET_STRING_cmp(a1, ex_xkusage);
}

uint64_t cms_set1_ias(ASN1_VALUE **a1, X509 *a2)
{
  uint64_t v4 = ASN1_item_new(&CMS_IssuerAndSerialNumber_it);
  if (v4
    && (issuer_name = X509_get_issuer_name(a2), X509_NAME_set((X509_NAME **)v4, issuer_name))
    && (int v6 = (ASN1_STRING *)*((void *)v4 + 1),
        serialNumber = X509_get_serialNumber(a2),
        ASN1_STRING_copy(v6, (uint64_t)serialNumber)))
  {
    ASN1_item_free(*a1, &CMS_IssuerAndSerialNumber_it);
    *a1 = v4;
    return 1;
  }
  else
  {
    ASN1_item_free(v4, &CMS_IssuerAndSerialNumber_it);
    ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", 696);
    return 0;
  }
}

uint64_t cms_set1_keyid(ASN1_OCTET_STRING **a1, X509 *x)
{
  X509_check_purpose(x, -1, -1);
  ex_xkusage = (ASN1_STRING *)x->ex_xkusage;
  if (ex_xkusage)
  {
    int v5 = ASN1_STRING_dup(ex_xkusage);
    if (v5)
    {
      int v6 = v5;
      ASN1_OCTET_STRING_free(*a1);
      *a1 = v6;
      return 1;
    }
    int v8 = 65;
    int v9 = 714;
  }
  else
  {
    int v8 = 160;
    int v9 = 709;
  }
  ERR_put_error(46, 4095, v8, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_lib.c", v9);
  return 0;
}

char *__cdecl X509_NAME_oneline(X509_NAME *a, char *buf, int size)
{
  uint64_t data = buf;
  uint64_t v4 = a;
  uint64_t v39 = *MEMORY[0x263EF8340];
  if (buf)
  {
    if (a)
    {
      uint64_t str = 0;
      goto LABEL_4;
    }
LABEL_60:
    strlcpy(data, "NO X509_NAME", size);
    return data;
  }
  int v31 = BUF_MEM_new();
  if (!v31)
  {
    ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_obj.c", 177);
    return 0;
  }
  int v32 = v31;
  if (!BUF_MEM_grow(v31, 200))
  {
    uint64_t str = v32;
LABEL_57:
    ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_obj.c", 177);
    BUF_MEM_free(str);
    return 0;
  }
  *v32->uint64_t data = 0;
  if (!v4)
  {
    uint64_t data = v32->data;
    free(v32);
    size_t size = 200;
    goto LABEL_60;
  }
  uint64_t str = v32;
  size_t size = 200;
LABEL_4:
  if (sk_num(v4->entries) < 1)
  {
    int v6 = 0;
  }
  else
  {
    int v5 = 0;
    int v6 = 0;
    p_entrieunsigned int s = (const STACK **)&v4->entries;
    do
    {
      int v7 = sk_value(v4->entries, v6);
      int v8 = OBJ_obj2nid(*(const ASN1_OBJECT **)v7);
      if (!v8 || (int v9 = OBJ_nid2sn(v8)) == 0)
      {
        int v9 = bufa;
        i2t_ASN1_OBJECT(bufa, 80, *(ASN1_OBJECT **)v7);
      }
      int v10 = strlen(v9);
      int v11 = v10;
      int v12 = (unsigned int *)*((void *)v7 + 1);
      uint64_t v14 = *v12;
      unsigned int v13 = v12[1];
      uint64_t v15 = *((void *)v12 + 1);
      if (v13 == 27 && (v14 & 3) == 0)
      {
        long long v38 = 0uLL;
        uint64_t v18 = str;
        if ((int)v14 < 1) {
          goto LABEL_21;
        }
        for (uint64_t i = 0; i != v14; ++i)
        {
          if (*(unsigned char *)(v15 + i)) {
            *(_DWORD *)((unint64_t)&v38 & 0xFFFFFFFFFFFFFFF3 | (4 * (i & 3))) = 1;
          }
        }
        if (DWORD1(v38) | v38 | DWORD2(v38))
        {
          *(void *)&long long v20 = 0x100000001;
          *((void *)&v20 + engine_free_util((CRYPTO_EX_DATA *)e, 1) = 0x100000001;
        }
        else
        {
LABEL_21:
          long long v20 = xmmword_23C7151B0;
        }
        long long v38 = v20;
      }
      else
      {
        *(void *)&long long v17 = 0x100000001;
        *((void *)&v17 + engine_free_util((CRYPTO_EX_DATA *)e, 1) = 0x100000001;
        long long v38 = v17;
        uint64_t v18 = str;
      }
      if ((int)v14 < 1)
      {
        int v22 = 0;
      }
      else
      {
        uint64_t v21 = 0;
        int v22 = 0;
        do
        {
          if (*(_DWORD *)((unint64_t)&v38 & 0xFFFFFFFFFFFFFFF3 | (4 * (v21 & 3))))
          {
            if (*(unsigned __int8 *)(v15 + v21) - 127 >= 0xFFFFFFA1) {
              ++v22;
            }
            else {
              v22 += 4;
            }
          }
          ++v21;
        }
        while (v14 != v21);
      }
      int v23 = v5 + v10 + v22 + 2;
      if (v18)
      {
        if (!BUF_MEM_grow(v18, v5 + v10 + v22 + 3)) {
          goto LABEL_57;
        }
        uint64_t v24 = v18->data;
      }
      else
      {
        uint64_t v24 = data;
        if (v23 >= size) {
          goto LABEL_53;
        }
      }
      int v25 = &v24[v5];
      *v25++ = 47;
      memcpy(v25, v9, v11);
      int v26 = &v25[v11];
      char *v26 = 61;
      int v27 = v26 + 1;
      if ((int)v14 >= 1)
      {
        uint64_t v28 = 0;
        uint64_t v29 = *(void *)(*((void *)v7 + 1) + 8);
        do
        {
          if (*(_DWORD *)((unint64_t)&v38 & 0xFFFFFFFFFFFFFFF3 | (4 * (v28 & 3))))
          {
            unint64_t v30 = *(unsigned __int8 *)(v29 + v28);
            if ((v30 - 127) > 0xFFFFFFA0)
            {
              *v27++ = v30;
            }
            else
            {
              *(_WORD *)int v27 = 30812;
              v27[2] = X509_NAME_oneline_hex[v30 >> 4];
              void v27[3] = X509_NAME_oneline_hex[v30 & 0xF];
              v27 += 4;
            }
          }
          ++v28;
        }
        while (v14 != v28);
      }
      *int v27 = 0;
      ++v6;
      uint64_t v4 = (X509_NAME *)p_entries;
      int v5 = v23;
    }
    while (v6 < sk_num(*p_entries));
  }
  if (str)
  {
    uint64_t data = str->data;
    free(str);
    if (!v6) {
      goto LABEL_54;
    }
  }
  else
  {
LABEL_53:
    if (!v6) {
LABEL_54:
    }
      char *data = 0;
  }
  return data;
}

ASN1_TYPE *__cdecl ASN1_generate_nconf(char *str, CONF *nconf)
{
  if (nconf)
  {
    memset(&v4, 0, sizeof(v4));
    X509V3_set_nconf(&v4, nconf);
    return ASN1_generate_v3(str, &v4);
  }
  else
  {
    return ASN1_generate_v3(str, 0);
  }
}

ASN1_TYPE *__cdecl ASN1_generate_v3(char *str, X509V3_CTX *cnf)
{
  memset(v55, 0, sizeof(v55));
  memset(&arg[1], 0, 32);
  punsigned int p = 0;
  unsigned __int8 out = 0;
  unsigned __int8 in = 0;
  int v51 = 0;
  *(void *)pclasunsigned int s = 0;
  pint length = 0;
  arg[0] = -1;
  HIDWORD(arg[1]) = 1;
  uint64_t v56 = 0;
  int v3 = 0;
  if (!CONF_parse_list(str, 44, 1, (int (__cdecl *)(const char *, int, void *))asn1_cb, arg))
  {
    int v5 = arg[1];
    if ((arg[1] & 0xFFFFFFFE) == 0x10)
    {
      if (!cnf)
      {
        ERR_put_error(13, 4095, 192, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_gen.c", 165);
        return 0;
      }
      int v6 = (char *)arg[2];
      value.sectioint n = 0;
      int v7 = sk_new_null();
      if (v7)
      {
        int v8 = v7;
        if (!v6)
        {
          int v10 = 0;
          goto LABEL_25;
        }
        sectioint n = X509V3_get_section(cnf, v6);
        if (section)
        {
          int v10 = section;
          if (sk_num(section) >= 1)
          {
            int v11 = 0;
            do
            {
              int v12 = sk_value(v10, v11);
              unsigned int v13 = (char *)ASN1_generate_v3(*((char **)v12 + 2), cnf);
              if (!v13 || !sk_push(v8, v13)) {
                goto LABEL_32;
              }
            }
            while (++v11 < sk_num(v10));
          }
LABEL_25:
          if (v5 == 17) {
            int v18 = i2d_ASN1_SET_ANY((ASN1_VALUE *)v8, (unsigned __int8 **)&value);
          }
          else {
            int v18 = i2d_ASN1_SEQUENCE_ANY((ASN1_VALUE *)v8, (unsigned __int8 **)&value);
          }
          int v19 = v18;
          if ((v18 & 0x80000000) == 0)
          {
            int v3 = ASN1_TYPE_new();
            if (v3)
            {
              long long v20 = ASN1_STRING_type_new(v5);
              v3->value.ptr = (char *)v20;
              if (v20)
              {
                v3->int type = v5;
                v20->uint64_t data = (unsigned __int8 *)value.section;
                *(_DWORD *)v3->value.ptr = v19;
                value.sectioint n = 0;
              }
            }
            goto LABEL_33;
          }
LABEL_32:
          int v3 = 0;
LABEL_33:
          free(value.section);
          sk_pop_free(v8, (void (__cdecl *)(void *))ASN1_TYPE_free);
          if (v10) {
            X509V3_section_free(cnf, v10);
          }
LABEL_86:
          if (!v3 || LODWORD(arg[0]) == -1 && !v56) {
            return v3;
          }
          int v31 = i2d_ASN1_TYPE(v3, &out);
          ASN1_TYPE_free(v3);
          punsigned int p = out;
          if (LODWORD(arg[0]) == -1)
          {
            int v34 = 0;
            int v36 = v31;
            int v33 = v31;
          }
          else
          {
            char object = ASN1_get_object((const unsigned __int8 **)&pp, &plength, &pclass[1], pclass, v31);
            if (object < 0)
            {
              int v3 = 0;
              int v37 = 0;
LABEL_116:
              free(out);
              free(v37);
              return v3;
            }
            int v33 = v31 + out - pp;
            if (object)
            {
              int v35 = 0;
              pint length = 0;
              int v34 = 2;
            }
            else
            {
              int v34 = object & 0x20;
              int v35 = plength;
            }
            int v36 = ASN1_object_size(0, v35, arg[0]);
          }
          if ((int)v56 >= 1)
          {
            int v38 = 0;
            uint64_t v39 = &arg[3 * v56 + 2];
            do
            {
              uint64_t v40 = *((int *)v39 - 1) + (uint64_t)v36;
              *uint64_t v39 = v40;
              int v36 = ASN1_object_size(0, v40, *((_DWORD *)v39 - 4));
              ++v38;
              v39 -= 3;
            }
            while (v38 < (int)v56);
          }
          uint64_t v41 = v36;
          int v42 = (unsigned __int8 *)malloc_type_malloc(v36, 0xB672B555uLL);
          int v37 = v42;
          if (v42)
          {
            int v51 = v42;
            if ((int)v56 >= 1)
            {
              int v43 = 0;
              int v44 = (int *)v55;
              do
              {
                ASN1_put_object(&v51, *(v44 - 2), *v44, *(v44 - 4), *(v44 - 3));
                if (*(v44 - 1))
                {
                  int v45 = v51++;
                  *int v45 = 0;
                }
                v44 += 6;
                ++v43;
              }
              while (v43 < (int)v56);
            }
            if (LODWORD(arg[0]) != -1)
            {
              if (HIDWORD(arg[0])) {
                BOOL v46 = 0;
              }
              else {
                BOOL v46 = (arg[0] & 0xFFFFFFFE) == 16;
              }
              if (v46) {
                int v47 = 32;
              }
              else {
                int v47 = v34;
              }
              ASN1_put_object(&v51, v47, plength, arg[0], SHIDWORD(arg[0]));
            }
            memcpy(v51, pp, v33);
            unsigned __int8 in = v37;
            int v3 = d2i_ASN1_TYPE(0, (const unsigned __int8 **)&in, v41);
          }
          else
          {
            int v3 = 0;
          }
          goto LABEL_116;
        }
        free(value.section);
        sk_pop_free(v8, (void (__cdecl *)(void *))ASN1_TYPE_free);
      }
      else
      {
        free(value.section);
      }
    }
    else
    {
      uint64_t v14 = (char *)arg[2];
      int v15 = HIDWORD(arg[1]);
      int v16 = ASN1_TYPE_new();
      int v3 = v16;
      if (!v16)
      {
        ERR_put_error(13, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_gen.c", 618);
        goto LABEL_86;
      }
      memset(&value, 0, sizeof(value));
      uint64_t len = 0;
      if (!v14) {
        uint64_t v14 = "";
      }
      switch(v5)
      {
        case 1:
          if (v15 != 1)
          {
            int v22 = 190;
            int v23 = 636;
            goto LABEL_79;
          }
          value.sectioint n = 0;
          value.name = 0;
          value.CONF_VALUE value = v14;
          if (X509V3_get_value_BOOL(&value, (int *)&v16->value)) {
            goto LABEL_37;
          }
          int v24 = 176;
          int v25 = 643;
          goto LABEL_82;
        case 2:
        case 10:
          if (v15 != 1)
          {
            int v22 = 185;
            int v23 = 651;
            goto LABEL_79;
          }
          int v26 = s2i_ASN1_INTEGER(0, v14);
          v3->value.ptr = (char *)v26;
          if (v26) {
            goto LABEL_37;
          }
          int v24 = 180;
          int v25 = 656;
          goto LABEL_82;
        case 3:
        case 4:
          int v27 = ASN1_STRING_new();
          v3->value.ptr = (char *)v27;
          if (!v27)
          {
            int v22 = 65;
            int v23 = 723;
            goto LABEL_79;
          }
          if (v15 == 1)
          {
            if (!ASN1_STRING_set(v27, v14, -1))
            {
              int v24 = 65;
              int v25 = 741;
              goto LABEL_82;
            }
          }
          else
          {
            if (v15 != 3)
            {
              if (v5 != 3 || v15 != 4)
              {
                int v22 = 175;
                int v23 = 754;
                goto LABEL_79;
              }
              if (CONF_parse_list(v14, 44, 1, (int (__cdecl *)(const char *, int, void *))bitstr_cb, v27)) {
                goto LABEL_37;
              }
              int v24 = 188;
              int v25 = 748;
              goto LABEL_82;
            }
            uint64_t v28 = string_to_hex(v14, &len);
            if (!v28)
            {
              int v24 = 178;
              int v25 = 730;
              goto LABEL_82;
            }
            *((void *)v3->value.ptr + engine_free_util((CRYPTO_EX_DATA *)e, 1) = v28;
            *(_DWORD *)v3->value.ptr = len;
            *((_DWORD *)v3->value.ptr + engine_free_util((CRYPTO_EX_DATA *)e, 1) = v5;
          }
          if (v5 != 3 || asn1_abs_set_unused_bits((uint64_t)v3->value.ptr, 0)) {
            goto LABEL_37;
          }
          goto LABEL_83;
        case 5:
          if (!*v14) {
            goto LABEL_37;
          }
          int v22 = 182;
          int v23 = 629;
          goto LABEL_79;
        case 6:
          if (v15 != 1)
          {
            int v22 = 191;
            int v23 = 663;
            goto LABEL_79;
          }
          unint64_t v30 = OBJ_txt2obj(v14, 0);
          v3->value.ptr = (char *)v30;
          if (v30) {
            goto LABEL_37;
          }
          int v24 = 183;
          int v25 = 667;
          goto LABEL_82;
        case 12:
        case 18:
        case 19:
        case 20:
        case 22:
        case 26:
        case 27:
        case 28:
        case 30:
          if (v15 == 1)
          {
            int v17 = 4097;
          }
          else
          {
            if (v15 != 2)
            {
              int v22 = 177;
              int v23 = 708;
              goto LABEL_79;
            }
            int v17 = 4096;
          }
          unint64_t v21 = ASN1_tag2bit(v5);
          if (ASN1_mbstring_copy((ASN1_STRING **)&v3->value, (const unsigned __int8 *)v14, -1, v17, v21) > 0) {
            goto LABEL_37;
          }
          int v24 = 65;
          int v25 = 715;
          goto LABEL_82;
        case 23:
        case 24:
          if (v15 == 1)
          {
            uint64_t v29 = ASN1_STRING_new();
            v3->value.ptr = (char *)v29;
            if (v29)
            {
              if (ASN1_STRING_set(v29, v14, -1))
              {
                *((_DWORD *)v3->value.ptr + engine_free_util((CRYPTO_EX_DATA *)e, 1) = v5;
                if (ASN1_TIME_check(v3->value.asn1_string))
                {
LABEL_37:
                  v3->int type = v5;
                  goto LABEL_86;
                }
                int v24 = 184;
                int v25 = 688;
              }
              else
              {
                int v24 = 65;
                int v25 = 683;
              }
            }
            else
            {
              int v24 = 65;
              int v25 = 679;
            }
LABEL_82:
            ERR_put_error(13, 4095, v24, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_gen.c", v25);
LABEL_83:
            ERR_asprintf_error_data("string=%s", v14);
          }
          else
          {
            int v22 = 193;
            int v23 = 675;
LABEL_79:
            ERR_put_error(13, 4095, v22, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_gen.c", v23);
          }
          ASN1_TYPE_free(v3);
          break;
        default:
          int v24 = 196;
          int v25 = 767;
          goto LABEL_82;
      }
    }
    int v3 = 0;
    goto LABEL_86;
  }
  return v3;
}

uint64_t asn1_cb(char *__s2, int a2, uint64_t a3)
{
  int v5 = a2;
  if (a2 <= 0)
  {
LABEL_5:
    int v7 = 0;
    int v8 = 0;
  }
  else
  {
    uint64_t v6 = 0;
    while (__s2[v6] != 58)
    {
      if (a2 == ++v6) {
        goto LABEL_5;
      }
    }
    int v7 = ~v6 + a2;
    int v8 = &__s2[v6 + 1];
    int v5 = v6;
  }
  int v9 = v5;
  if (v5 == -1) {
    int v9 = strlen(__s2);
  }
  uint64_t v10 = 0;
  size_t v11 = v9;
  while (v11 != LODWORD((&asn1_str2tag_tnst)[v10 + 1]) || strncmp((&asn1_str2tag_tnst)[v10], __s2, v11))
  {
    v10 += 2;
    if ((v10 * 8) == 784) {
      goto LABEL_13;
    }
  }
  asn1_str2tag_tntmunsigned int p = (uint64_t)&(&asn1_str2tag_tnst)[v10];
  int v13 = *((_DWORD *)&asn1_str2tag_tnst + 2 * v10 + 3);
  if (v13 == -1)
  {
LABEL_13:
    ERR_put_error(13, 4095, 194, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_gen.c", 294);
    ERR_asprintf_error_data("tag=%s", __s2);
    return 0xFFFFFFFFLL;
  }
  if ((v13 & 0x10000) != 0)
  {
    switch(v13)
    {
      case 65537:
        if (*(_DWORD *)a3 != -1)
        {
          int v14 = 181;
          int v15 = 316;
          goto LABEL_24;
        }
        if (!parse_tagging((uint64_t)v8, v7, (_DWORD *)a3, (int *)(a3 + 4))) {
          return 0xFFFFFFFFLL;
        }
        goto LABEL_35;
      case 65538:
        uint64_t v23 = 0;
        if (!parse_tagging((uint64_t)v8, v7, (_DWORD *)&v23 + 1, (int *)&v23)) {
          return 0xFFFFFFFFLL;
        }
        int v17 = v23;
        int v16 = HIDWORD(v23);
        int v18 = (int *)a3;
        int v19 = 1;
        int v20 = 0;
        int v21 = 0;
        goto LABEL_34;
      case 65540:
        int v18 = (int *)a3;
        int v16 = 3;
        int v17 = 0;
        int v19 = 0;
        int v20 = 1;
        goto LABEL_33;
      case 65541:
        int v18 = (int *)a3;
        int v16 = 4;
        int v17 = 0;
        int v19 = 0;
        goto LABEL_32;
      case 65542:
        int v18 = (int *)a3;
        int v16 = 16;
        goto LABEL_31;
      case 65543:
        int v18 = (int *)a3;
        int v16 = 17;
LABEL_31:
        int v17 = 0;
        int v19 = 1;
LABEL_32:
        int v20 = 0;
LABEL_33:
        int v21 = 1;
LABEL_34:
        if (append_exp(v18, v16, v17, v19, v20, v21)) {
          goto LABEL_35;
        }
        return 0xFFFFFFFFLL;
      case 65544:
        if (!v8)
        {
          int v14 = 177;
          int v15 = 353;
          goto LABEL_24;
        }
        if (!strncmp(v8, "ASCII", 5uLL))
        {
          int v22 = 1;
        }
        else if (!strncmp(v8, "UTF8", 4uLL))
        {
          int v22 = 2;
        }
        else
        {
          int v22 = 3;
          if (strncmp(v8, "HEX", 3uLL))
          {
            if (strncmp(v8, "BITLIST", 7uLL))
            {
              int v14 = 195;
              int v15 = 365;
              goto LABEL_24;
            }
            int v22 = 4;
          }
        }
        *(_DWORD *)(a3 + 12) = v22;
LABEL_35:
        uint64_t result = 1;
        break;
      default:
        goto LABEL_35;
    }
  }
  else
  {
    *(_DWORD *)(a3 + 8) = v13;
    *(void *)(a3 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = v8;
    if (!v8 && __s2[v5])
    {
      int v14 = 189;
      int v15 = 305;
LABEL_24:
      ERR_put_error(13, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_gen.c", v15);
      return 0xFFFFFFFFLL;
    }
    return 0;
  }
  return result;
}

uint64_t parse_tagging(uint64_t result, int a2, _DWORD *a3, int *a4)
{
  if (result)
  {
    uint64_t v7 = result;
    __endptr = 0;
    unint64_t v8 = strtoul((const char *)result, &__endptr, 10);
    int v9 = __endptr;
    if (!__endptr || (*__endptr ? (BOOL v10 = (unint64_t)__endptr > v7 + a2) : (BOOL v10 = 0), !v10))
    {
      if ((v8 & 0x8000000000000000) != 0)
      {
        ERR_put_error(13, 4095, 187, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_gen.c", 388);
      }
      else
      {
        *a3 = v8;
        if (!v9 || v7 - v9 == -a2) {
          goto LABEL_13;
        }
        int v11 = *v9;
        if (v11 > 79)
        {
          if (v11 == 80)
          {
            int v12 = 192;
            goto LABEL_14;
          }
          if (v11 == 85)
          {
            *a4 = 0;
            return 1;
          }
        }
        else
        {
          if (v11 == 65)
          {
            int v12 = 64;
            goto LABEL_14;
          }
          if (v11 == 67)
          {
LABEL_13:
            int v12 = 128;
LABEL_14:
            *a4 = v12;
            return 1;
          }
        }
        ERR_put_error(13, 4095, 186, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_gen.c", 417);
        ERR_asprintf_error_data("Char=%c", *v9);
      }
    }
    return 0;
  }
  return result;
}

uint64_t append_exp(int *a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6 = *a1;
  if (!a6 && v6 != -1)
  {
    int v7 = 179;
    int v8 = 501;
LABEL_6:
    ERR_put_error(13, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_gen.c", v8);
    return 0;
  }
  int v9 = a1[126];
  if (v9 == 20)
  {
    int v7 = 174;
    int v8 = 506;
    goto LABEL_6;
  }
  a1[126] = v9 + 1;
  if (v6 != -1)
  {
    a3 = a1[1];
    *(void *)a1 = -1;
    a2 = v6;
  }
  a1[6 * v9 + 6] = a2;
  int v11 = &a1[6 * v9];
  v11[7] = a3;
  v11[8] = a4;
  v11[9] = a5;
  return 1;
}

uint64_t bitstr_cb(const char *a1, int a2, ASN1_BIT_STRING *a3)
{
  if (!a1) {
    return 0;
  }
  __endptr = 0;
  unint64_t v6 = strtoul(a1, &__endptr, 10);
  if (__endptr)
  {
    if (*__endptr && __endptr != &a1[a2]) {
      return 0;
    }
  }
  if ((v6 & 0x8000000000000000) != 0)
  {
    int v9 = 187;
    int v10 = 794;
    goto LABEL_12;
  }
  uint64_t v8 = 1;
  if (!ASN1_BIT_STRING_set_bit(a3, v6, 1))
  {
    int v9 = 65;
    int v10 = 798;
LABEL_12:
    ERR_put_error(13, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/asn1_gen.c", v10);
    return 0;
  }
  return v8;
}

int MD4_Update(MD4_CTX *c, const void *data, size_t len)
{
  if (len)
  {
    size_t v3 = len;
    X509V3_CTX v4 = data;
    *(void *)&c->Nl += 8 * len;
    uint64_t num = c->num;
    if (num)
    {
      int v7 = c->data;
      uint64_t v8 = (char *)c->data + num;
      if (len <= 0x3F && num + len < 0x40)
      {
        memcpy(v8, data, len);
        c->num += v3;
        return 1;
      }
      uint64_t v9 = 64 - num;
      memcpy(v8, data, 64 - num);
      md4_block_data_order((unint64_t)c, c->data, 1);
      X509V3_CTX v4 = (_DWORD *)((char *)v4 + v9);
      v3 -= v9;
      c->uint64_t num = 0;
      *(_OWORD *)int v7 = 0u;
      *(_OWORD *)&c->unsigned __int8 data[4] = 0u;
      *(_OWORD *)&c->char data[8] = 0u;
      *(_OWORD *)&c->data[12] = 0u;
    }
    if (v3 >= 0x40)
    {
      md4_block_data_order((unint64_t)c, v4, v3 >> 6);
      X509V3_CTX v4 = (_DWORD *)((char *)v4 + (v3 & 0xFFFFFFFFFFFFFFC0));
      v3 &= 0x3Fu;
    }
    if (v3)
    {
      c->uint64_t num = v3;
      memcpy(c->data, v4, v3);
    }
  }
  return 1;
}

unint64_t md4_block_data_order(unint64_t result, _DWORD *a2, uint64_t a3)
{
  int v183 = (_DWORD *)result;
  if (a3)
  {
    int v4 = *(_DWORD *)(result + 8);
    int v3 = *(_DWORD *)(result + 12);
    int v6 = *(_DWORD *)result;
    int v5 = *(_DWORD *)(result + 4);
    do
    {
      uint64_t v184 = a3;
      int v7 = a2[1];
      int v9 = __ROR4__((v4 & v5 | v3 & ~v5) + v6 + *a2, 29);
      int v8 = v4 & ~v9;
      int v10 = v5 & v9;
      HIDWORD(v12) = (v4 & v5 | v3 & ~v5) + v6 + *a2;
      LODWORD(v12) = HIDWORD(v12);
      int v11 = v12 >> 29;
      int v14 = a2[2];
      int v13 = a2[3];
      HIDWORD(v12) = v7 + v3 + (v10 | v8);
      LODWORD(v12) = HIDWORD(v12);
      int v15 = v12 >> 25;
      LODWORD(v12) = v14 + v4 + (v11 & __ROR4__(HIDWORD(v12), 25) | v5 & ~__ROR4__(HIDWORD(v12), 25));
      HIDWORD(v12) = v12;
      int v16 = v12 >> 21;
      LODWORD(v12) = v13 + v5 + (v15 & __ROR4__(v12, 21) | v11 & ~__ROR4__(v12, 21));
      HIDWORD(v12) = v12;
      int v17 = v12 >> 13;
      int v19 = a2[4];
      int v18 = a2[5];
      LODWORD(v12) = v19 + v11 + (v16 & __ROR4__(v12, 13) | v15 & ~__ROR4__(v12, 13));
      HIDWORD(v12) = v12;
      int v20 = v12 >> 29;
      int v21 = v18 + v15 + (v17 & __ROR4__(v12, 29) | v16 & ~__ROR4__(v12, 29));
      int v22 = a2[6];
      int v23 = a2[7];
      unint64_t v25 = __PAIR64__(v21, __ROR4__(v21, 25));
      int v24 = v20 & v25;
      LODWORD(v25) = v21;
      int v26 = v25 >> 25;
      HIDWORD(v25) = v22 + v16 + (v24 | v17 & ~__ROR4__(v21, 25));
      LODWORD(v25) = HIDWORD(v25);
      int v27 = v25 >> 21;
      LODWORD(v25) = v23 + v17 + (v26 & __ROR4__(HIDWORD(v25), 21) | v20 & ~__ROR4__(HIDWORD(v25), 21));
      HIDWORD(v25) = v25;
      int v28 = v25 >> 13;
      int v30 = a2[8];
      int v29 = a2[9];
      int v31 = v30 + v20 + (v27 & __ROR4__(v25, 13) | v26 & ~__ROR4__(v25, 13));
      unint64_t v33 = __PAIR64__(v31, __ROR4__(v31, 29));
      int v32 = v28 & v33;
      LODWORD(v33) = v31;
      int v34 = v33 >> 29;
      int v35 = v29 + v26 + (v32 | v27 & ~__ROR4__(v31, 29));
      int v37 = a2[10];
      int v36 = a2[11];
      HIDWORD(v33) = v35;
      LODWORD(v33) = v35;
      int v38 = v33 >> 25;
      LODWORD(v33) = v37 + v27 + (v34 & __ROR4__(v35, 25) | v28 & ~__ROR4__(v35, 25));
      HIDWORD(v33) = v33;
      int v39 = v33 >> 21;
      LODWORD(v33) = v36 + v28 + (v38 & __ROR4__(v33, 21) | v34 & ~__ROR4__(v33, 21));
      HIDWORD(v33) = v33;
      int v40 = v33 >> 13;
      int v42 = a2[12];
      int v41 = a2[13];
      LODWORD(v33) = v42 + v34 + (v39 & __ROR4__(v33, 13) | v38 & ~__ROR4__(v33, 13));
      HIDWORD(v33) = v33;
      int v43 = v33 >> 29;
      int v44 = v41 + v38 + (v40 & __ROR4__(v33, 29) | v39 & ~__ROR4__(v33, 29));
      int v46 = a2[14];
      int v45 = a2[15];
      int v47 = v46 + v39 + (v43 & __ROR4__(v44, 25) | v40 & ~__ROR4__(v44, 25));
      HIDWORD(v33) = v47;
      LODWORD(v33) = v47;
      int v48 = v33 >> 21;
      unint64_t v50 = __PAIR64__(v44, __ROR4__(v44, 25));
      int v49 = v48 & v50;
      unsigned int v51 = v45 + v40 + (v48 & v50 | v43 & ~__ROR4__(v47, 21));
      LODWORD(v5RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = v44;
      int v52 = v50 >> 25;
      unint64_t v53 = __PAIR64__(v51, __ROR4__(v51, 13));
      int v54 = (v48 | __ROR4__(v44, 25)) & v53 | v49;
      LODWORD(v53) = v51;
      int v55 = v53 >> 13;
      unsigned int v56 = *a2 + 1518500249 + v43 + v54;
      int v57 = v19 + 1518500249 + v52;
      unint64_t v58 = __PAIR64__(v56, __ROR4__(v56, 29));
      int v59 = (v55 | __ROR4__(v47, 21)) & v58 | v55 & __ROR4__(v47, 21);
      LODWORD(v58) = v56;
      int v60 = v58 >> 29;
      unsigned int v61 = v57 + v59;
      unint64_t v62 = __PAIR64__(v61, __ROR4__(v61, 27));
      int v63 = (v60 | __ROR4__(v51, 13)) & v62 | v60 & __ROR4__(v51, 13);
      LODWORD(v62) = v61;
      int v64 = v62 >> 27;
      unsigned int v65 = v30 + 1518500249 + v48 + v63;
      int v66 = v42 + 1518500249 + v55;
      unint64_t v67 = __PAIR64__(v65, __ROR4__(v65, 23));
      int v68 = (v64 | __ROR4__(v56, 29)) & v67 | v64 & __ROR4__(v56, 29);
      LODWORD(v67) = v65;
      int v69 = v67 >> 23;
      unsigned int v70 = v66 + v68;
      unint64_t v71 = __PAIR64__(v70, __ROR4__(v70, 19));
      int v72 = (v69 | __ROR4__(v61, 27)) & v71 | v69 & __ROR4__(v61, 27);
      int v73 = v7 + 1518500249 + v60;
      LODWORD(v7engine_free_util((CRYPTO_EX_DATA *)e, 1) = v70;
      int v74 = v71 >> 19;
      unsigned int v75 = v73 + v72;
      int v76 = v18 + 1518500249 + v64;
      unint64_t v77 = __PAIR64__(v75, __ROR4__(v75, 29));
      int v78 = (v74 | __ROR4__(v65, 23)) & v77 | v74 & __ROR4__(v65, 23);
      LODWORD(v77) = v75;
      int v79 = v77 >> 29;
      unsigned int v80 = v76 + v78;
      unint64_t v81 = __PAIR64__(v80, __ROR4__(v80, 27));
      int v82 = (v79 | __ROR4__(v70, 19)) & v81 | v79 & __ROR4__(v70, 19);
      int v83 = v29 + 1518500249 + v69;
      LODWORD(v8engine_free_util((CRYPTO_EX_DATA *)e, 1) = v80;
      int v84 = v81 >> 27;
      unsigned int v85 = v83 + v82;
      int v86 = v41 + 1518500249 + v74;
      unint64_t v87 = __PAIR64__(v85, __ROR4__(v85, 23));
      int v88 = (v84 | __ROR4__(v75, 29)) & v87 | v84 & __ROR4__(v75, 29);
      LODWORD(v87) = v85;
      int v89 = v87 >> 23;
      unsigned int v90 = v86 + v88;
      unint64_t v91 = __PAIR64__(v90, __ROR4__(v90, 19));
      int v92 = (v89 | __ROR4__(v80, 27)) & v91 | v89 & __ROR4__(v80, 27);
      int v93 = v14 + 1518500249 + v79;
      LODWORD(v9engine_free_util((CRYPTO_EX_DATA *)e, 1) = v90;
      int v94 = v91 >> 19;
      unsigned int v95 = v93 + v92;
      int v96 = v22 + 1518500249 + v84;
      unint64_t v97 = __PAIR64__(v95, __ROR4__(v95, 29));
      int v98 = (v94 | __ROR4__(v85, 23)) & v97 | v94 & __ROR4__(v85, 23);
      LODWORD(v97) = v95;
      int v99 = v97 >> 29;
      unsigned int v100 = v96 + v98;
      unint64_t v101 = __PAIR64__(v100, __ROR4__(v100, 27));
      int v102 = (v99 | __ROR4__(v90, 19)) & v101 | v99 & __ROR4__(v90, 19);
      int v103 = v37 + 1518500249 + v89;
      LODWORD(v10engine_free_util((CRYPTO_EX_DATA *)e, 1) = v100;
      int v104 = v101 >> 27;
      unsigned int v105 = v103 + v102;
      int v106 = v46 + 1518500249 + v94;
      unint64_t v107 = __PAIR64__(v105, __ROR4__(v105, 23));
      int v108 = (v104 | __ROR4__(v95, 29)) & v107 | v104 & __ROR4__(v95, 29);
      LODWORD(v107) = v105;
      int v109 = v107 >> 23;
      unsigned int v110 = v106 + v108;
      unint64_t v111 = __PAIR64__(v110, __ROR4__(v110, 19));
      int v112 = (v109 | __ROR4__(v100, 27)) & v111 | v109 & __ROR4__(v100, 27);
      int v113 = v13 + 1518500249 + v99;
      LODWORD(v11engine_free_util((CRYPTO_EX_DATA *)e, 1) = v110;
      int v114 = v111 >> 19;
      unsigned int v115 = v113 + v112;
      int v116 = v23 + 1518500249 + v104;
      unint64_t v117 = __PAIR64__(v115, __ROR4__(v115, 29));
      int v118 = (v114 | __ROR4__(v105, 23)) & v117 | v114 & __ROR4__(v105, 23);
      LODWORD(v117) = v115;
      int v119 = v117 >> 29;
      unsigned int v120 = v116 + v118;
      unint64_t v121 = __PAIR64__(v120, __ROR4__(v120, 27));
      int v122 = (v119 | __ROR4__(v110, 19)) & v121 | v119 & __ROR4__(v110, 19);
      int v123 = v36 + 1518500249 + v109;
      LODWORD(v12engine_free_util((CRYPTO_EX_DATA *)e, 1) = v120;
      int v124 = v121 >> 27;
      unsigned int v125 = v123 + v122;
      int v126 = v45 + 1518500249 + v114 + ((v124 | __ROR4__(v115, 29)) & __ROR4__(v125, 23) | v124 & __ROR4__(v115, 29));
      HIDWORD(v12engine_free_util((CRYPTO_EX_DATA *)e, 1) = v126;
      LODWORD(v12engine_free_util((CRYPTO_EX_DATA *)e, 1) = v126;
      int v127 = v121 >> 19;
      int v128 = *a2 + 1859775393 + v119;
      int v129 = v127 ^ __ROR4__(v125, 23);
      int v130 = v128 + (v129 ^ __ROR4__(v120, 27));
      unint64_t v131 = __PAIR64__(v125, __ROR4__(v130, 29));
      unsigned int v132 = v30 + 1859775393 + v124 + (v129 ^ v131);
      LODWORD(v13engine_free_util((CRYPTO_EX_DATA *)e, 1) = v125;
      int v133 = v19 + 1859775393 + (v131 >> 23);
      HIDWORD(v13engine_free_util((CRYPTO_EX_DATA *)e, 1) = v130;
      LODWORD(v13engine_free_util((CRYPTO_EX_DATA *)e, 1) = v130;
      int v134 = v131 >> 29;
      unint64_t v135 = __PAIR64__(v132, __ROR4__(v132, 23));
      unsigned int v136 = v133 + (v134 ^ __ROR4__(v126, 19) ^ v135);
      int v137 = v14 + 1859775393 + v134;
      LODWORD(v135) = v132;
      int v138 = v135 >> 23;
      unint64_t v139 = __PAIR64__(v136, __ROR4__(v136, 21));
      unsigned int v140 = v42 + 1859775393 + v127 + (v138 ^ __ROR4__(v130, 29) ^ v139);
      LODWORD(v139) = v136;
      int v141 = v139 >> 21;
      unint64_t v142 = __PAIR64__(v140, __ROR4__(v140, 17));
      unsigned int v143 = v137 + (v141 ^ __ROR4__(v132, 23) ^ v142);
      int v144 = v37 + 1859775393 + v138;
      LODWORD(v142) = v140;
      int v145 = v142 >> 17;
      unint64_t v146 = __PAIR64__(v143, __ROR4__(v143, 29));
      unsigned int v147 = v144 + (v145 ^ __ROR4__(v136, 21) ^ v146);
      int v148 = v22 + 1859775393 + v141;
      LODWORD(v146) = v143;
      int v149 = v146 >> 29;
      unint64_t v150 = __PAIR64__(v147, __ROR4__(v147, 23));
      unsigned int v151 = v148 + (v149 ^ __ROR4__(v140, 17) ^ v150);
      LODWORD(v15RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = v147;
      int v152 = v150 >> 23;
      unint64_t v153 = __PAIR64__(v151, __ROR4__(v151, 21));
      unsigned int v154 = v46 + 1859775393 + v145 + (v152 ^ __ROR4__(v143, 29) ^ v153);
      int v155 = v7 + 1859775393 + v149;
      LODWORD(v153) = v151;
      int v156 = v153 >> 21;
      unint64_t v157 = __PAIR64__(v154, __ROR4__(v154, 17));
      unsigned int v158 = v155 + (v156 ^ __ROR4__(v147, 23) ^ v157);
      int v159 = v18 + 1859775393 + v156;
      LODWORD(v157) = v154;
      int v160 = v157 >> 17;
      unint64_t v161 = __PAIR64__(v158, __ROR4__(v158, 29));
      unsigned int v162 = v29 + 1859775393 + v152 + (v160 ^ __ROR4__(v151, 21) ^ v161);
      LODWORD(v16engine_free_util((CRYPTO_EX_DATA *)e, 1) = v158;
      int v163 = v161 >> 29;
      unint64_t v164 = __PAIR64__(v162, __ROR4__(v162, 23));
      unsigned int v165 = v159 + (v163 ^ __ROR4__(v154, 17) ^ v164);
      int v166 = v41 + 1859775393 + v160;
      LODWORD(v164) = v162;
      int v167 = v164 >> 23;
      unint64_t v168 = __PAIR64__(v165, __ROR4__(v165, 21));
      unsigned int v169 = v166 + (v167 ^ __ROR4__(v158, 29) ^ v168);
      int v170 = v13 + 1859775393 + v163;
      LODWORD(v168) = v165;
      uint64_t result = (v168 >> 21);
      unint64_t v171 = __PAIR64__(v169, __ROR4__(v169, 17));
      unsigned int v172 = v170 + (result ^ __ROR4__(v162, 23) ^ v171);
      int v173 = v36 + 1859775393 + v167;
      LODWORD(v17engine_free_util((CRYPTO_EX_DATA *)e, 1) = v169;
      int v174 = v171 >> 17;
      unint64_t v175 = __PAIR64__(v172, __ROR4__(v172, 29));
      unsigned int v176 = v173 + (v174 ^ __ROR4__(v165, 21) ^ v175);
      LODWORD(v175) = v172;
      int v177 = v175 >> 29;
      unint64_t v178 = __PAIR64__(v176, __ROR4__(v176, 23));
      unsigned int v179 = v23 + 1859775393 + result + (v177 ^ __ROR4__(v169, 17) ^ v178);
      LODWORD(v178) = v176;
      int v180 = v178 >> 23;
      unint64_t v181 = __PAIR64__(v179, __ROR4__(v179, 21));
      int v182 = v45 + 1859775393 + v174 + (v180 ^ __ROR4__(v172, 29) ^ v181);
      LODWORD(v18engine_free_util((CRYPTO_EX_DATA *)e, 1) = v179;
      v6 += v177;
      v4 += v181 >> 21;
      v3 += v180;
      HIDWORD(v18engine_free_util((CRYPTO_EX_DATA *)e, 1) = v182;
      LODWORD(v18engine_free_util((CRYPTO_EX_DATA *)e, 1) = v182;
      v5 += v181 >> 17;
      *int v183 = v6;
      v183[1] = v5;
      v183[2] = v4;
      v183[3] = v3;
      a2 += 16;
      a3 = v184 - 1;
    }
    while (v184 != 1);
  }
  return result;
}

void MD4_Transform(MD4_CTX *c, const unsigned __int8 *b)
{
}

int MD4_Final(unsigned __int8 *md, MD4_CTX *c)
{
  uint64_t data = c->data;
  uint64_t num = c->num;
  *((unsigned char *)c->data + num) = 0x80;
  uint64_t v6 = num + 1;
  if (num >= 0x38)
  {
    bzero((char *)data + v6, 63 - num);
    md4_block_data_order((unint64_t)c, data, 1);
    uint64_t v6 = 0;
  }
  bzero((char *)data + v6, 56 - v6);
  unsigned int Nh = c->Nh;
  c->data[14] = c->Nl;
  c->data[15] = Nh;
  md4_block_data_order((unint64_t)c, data, 1);
  c->uint64_t num = 0;
  *(_OWORD *)uint64_t data = 0u;
  *((_OWORD *)data + md4_block_data_order((unint64_t)c, b, 1) = 0u;
  *((_OWORD *)data + 2) = 0u;
  *((_OWORD *)data + 3) = 0u;
  *(_DWORD *)munsigned int d = c->A;
  *((_DWORD *)md + md4_block_data_order((unint64_t)c, b, 1) = c->B;
  *((_DWORD *)md + 2) = c->C;
  *((_DWORD *)md + 3) = c->D;
  return 1;
}

int MD4_Init(MD4_CTX *c)
{
  *(_OWORD *)&c->data[13] = 0u;
  *(_OWORD *)&c->data[6] = 0u;
  *(_OWORD *)&c->data[10] = 0u;
  *(_OWORD *)&c->Nl = 0u;
  *(_OWORD *)&c->unsigned char data[2] = 0u;
  *(_OWORD *)&c->A = xmmword_23C70F740;
  return 1;
}

uint64_t ecdh_KDF_X9_63(char *a1, unint64_t a2, const void *a3, size_t a4, const void *a5, size_t a6, const EVP_MD *a7)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  if (a4 > 0x40000000 || a2 > 0x40000000 || a6 > 0x40000000) {
    return 0;
  }
  size_t v14 = a2;
  int v16 = (EVP_MD_CTX *)EVP_MD_CTX_new();
  if (!v16) {
    return 0;
  }
  int v17 = v16;
  int v18 = EVP_MD_size(a7);
  if (EVP_DigestInit_ex(v17, a7, 0))
  {
    unsigned int v19 = 1;
    do
    {
      unsigned int d = bswap32(v19);
      if (!EVP_DigestUpdate(v17, a3, a4) || !EVP_DigestUpdate(v17, &d, 4uLL) || !EVP_DigestUpdate(v17, a5, a6)) {
        break;
      }
      if (v14 < v18)
      {
        if (EVP_DigestFinal(v17, md, 0))
        {
          memcpy(a1, md, v14);
          explicit_bzero(md, v18);
        }
        break;
      }
      if (!EVP_DigestFinal(v17, (unsigned __int8 *)a1, 0)) {
        break;
      }
      v14 -= v18;
      if (!v14)
      {
        uint64_t v20 = 1;
        goto LABEL_24;
      }
      a1 += v18;
      ++v19;
    }
    while (EVP_DigestInit_ex(v17, a7, 0));
  }
  uint64_t v20 = 0;
LABEL_24:
  EVP_MD_CTX_free(v17);
  return v20;
}

void DES_cfb_encrypt(const unsigned __int8 *in, unsigned __int8 *out, int numbits, uint64_t length, DES_key_schedule *schedule, DES_cblock *ivec, int enc)
{
  uint64_t v63 = *MEMORY[0x263EF8340];
  int v7 = numbits + 7;
  if (numbits >= 0) {
    int v8 = numbits;
  }
  else {
    int v8 = numbits + 7;
  }
  if (v7 < 0) {
    int v7 = numbits + 14;
  }
  if ((numbits - 65) >= 0xFFFFFFC0)
  {
    unint64_t v9 = length;
    int v12 = v8 >> 3;
    int v13 = v7 >> 3;
    unsigned int v14 = numbits - (v8 & 0xFFFFFFF8);
    LODWORD(v15) = *(_DWORD *)ivec;
    LODWORD(v++*(_DWORD *)(*(void *)(result + 8) + 16) = *(_DWORD *)&(*ivec)[4];
    unint64_t v17 = v13;
    if (enc)
    {
      if (v13 <= (unint64_t)length)
      {
        int v18 = (unint64_t *)((char *)&v58 + v12);
        int v19 = v13 - 1;
        do
        {
          unsigned int data = v15;
          int v62 = v16;
          DES_encrypt1(&data, schedule, 1);
          int v20 = 0;
          int v21 = &in[v17];
          int v22 = 0;
          switch(v19)
          {
            case 0:
              goto LABEL_18;
            case 1:
              goto LABEL_17;
            case 2:
              goto LABEL_16;
            case 3:
              goto LABEL_15;
            case 4:
              goto LABEL_14;
            case 5:
              goto LABEL_13;
            case 6:
              goto LABEL_12;
            case 7:
              int v23 = *--v21;
              int v20 = v23 << 24;
LABEL_12:
              int v24 = *--v21;
              v20 |= v24 << 16;
LABEL_13:
              int v25 = *--v21;
              v20 |= v25 << 8;
LABEL_14:
              int v26 = *--v21;
              v20 |= v26;
LABEL_15:
              int v22 = v20;
              int v27 = *--v21;
              int v20 = v27 << 24;
LABEL_16:
              int v28 = *--v21;
              v20 |= v28 << 16;
LABEL_17:
              int v29 = *--v21;
              v20 |= v29 << 8;
LABEL_18:
              int v30 = *--v21;
              v20 |= v30;
              break;
            default:
              break;
          }
          LODWORD(v3md4_block_data_order((unint64_t)c, b, 1) = data ^ v20;
          int v32 = v62 ^ v22;
          unint64_t v33 = &out[v17];
          switch(v19)
          {
            case 0:
              goto LABEL_27;
            case 1:
              goto LABEL_26;
            case 2:
              goto LABEL_25;
            case 3:
              goto LABEL_24;
            case 4:
              goto LABEL_23;
            case 5:
              goto LABEL_22;
            case 6:
              goto LABEL_21;
            case 7:
              *--unint64_t v33 = HIBYTE(v32);
LABEL_21:
              *--unint64_t v33 = BYTE2(v32);
LABEL_22:
              *--unint64_t v33 = BYTE1(v32);
LABEL_23:
              *--unint64_t v33 = v32;
LABEL_24:
              *--unint64_t v33 = BYTE3(v31);
LABEL_25:
              *--unint64_t v33 = BYTE2(v31);
LABEL_26:
              *--unint64_t v33 = BYTE1(v31);
LABEL_27:
              *--unint64_t v33 = v31;
              break;
            default:
              break;
          }
          if (numbits != 32)
          {
            if (numbits == 64)
            {
              LODWORD(v++*(_DWORD *)(*(void *)(result + 8) + 16) = v31;
              LODWORD(v3md4_block_data_order((unint64_t)c, b, 1) = v32;
            }
            else
            {
              unint64_t v58 = __PAIR64__(v16, v15);
              int v59 = v31;
              int v60 = v32;
              if (v14)
              {
                for (uint64_t i = 0; i != 8; ++i)
                  *((unsigned char *)&v58 + i) = (*((unsigned __int8 *)v18 + i + 1) >> (8 - v14)) | (*((unsigned __int8 *)v18 + i) << v14);
                LODWORD(v++*(_DWORD *)(*(void *)(result + 8) + 16) = v58;
                LODWORD(v3md4_block_data_order((unint64_t)c, b, 1) = HIDWORD(v58);
              }
              else
              {
                unint64_t v16 = *v18;
                unint64_t v58 = v16;
                unint64_t v31 = HIDWORD(v16);
              }
            }
          }
          LODWORD(v15) = v16;
          v9 -= v17;
          unsigned __int8 in = &v21[v17];
          unsigned __int8 out = &v33[v17];
          LODWORD(v++*(_DWORD *)(*(void *)(result + 8) + 16) = v31;
        }
        while (v9 >= v17);
        goto LABEL_41;
      }
    }
    else if (v13 <= (unint64_t)length)
    {
      int v35 = (unint64_t *)((char *)&v58 + v12);
      uint64_t v36 = (v13 - 1);
      unsigned int v37 = *(_DWORD *)ivec;
      do
      {
        unsigned int data = v37;
        int v62 = v16;
        uint64_t v38 = v36;
        DES_encrypt1(&data, schedule, 1);
        uint64_t v36 = v38;
        int v39 = 0;
        int v40 = &in[v17];
        int v41 = 0;
        int v42 = numbits;
        switch((int)v38)
        {
          case 0:
            goto LABEL_51;
          case 1:
            goto LABEL_50;
          case 2:
            goto LABEL_49;
          case 3:
            goto LABEL_48;
          case 4:
            goto LABEL_47;
          case 5:
            goto LABEL_46;
          case 6:
            goto LABEL_45;
          case 7:
            int v43 = *--v40;
            int v39 = v43 << 24;
LABEL_45:
            int v44 = *--v40;
            v39 |= v44 << 16;
LABEL_46:
            int v45 = *--v40;
            v39 |= v45 << 8;
LABEL_47:
            int v46 = *--v40;
            v39 |= v46;
LABEL_48:
            int v41 = v39;
            int v47 = *--v40;
            int v39 = v47 << 24;
LABEL_49:
            int v48 = *--v40;
            v39 |= v48 << 16;
LABEL_50:
            int v49 = *--v40;
            v39 |= v49 << 8;
LABEL_51:
            int v50 = *--v40;
            v39 |= v50;
            break;
          default:
            int v42 = numbits;
            break;
        }
        if (v42 == 32)
        {
          LODWORD(v15) = v16;
          LODWORD(v3md4_block_data_order((unint64_t)c, b, 1) = v39;
        }
        else
        {
          LODWORD(v15) = v39;
          LODWORD(v3md4_block_data_order((unint64_t)c, b, 1) = v41;
          if (v42 != 64)
          {
            unint64_t v58 = __PAIR64__(v16, v37);
            int v59 = v39;
            int v60 = v41;
            if (v14)
            {
              for (uint64_t j = 0; j != 8; ++j)
                *((unsigned char *)&v58 + j) = (*((unsigned __int8 *)v35 + j + 1) >> (8 - v14)) | (*((unsigned __int8 *)v35 + j) << v14);
              LODWORD(v15) = v58;
              LODWORD(v3md4_block_data_order((unint64_t)c, b, 1) = HIDWORD(v58);
            }
            else
            {
              unint64_t v15 = *v35;
              unint64_t v58 = v15;
              unint64_t v31 = HIDWORD(v15);
            }
          }
        }
        int v52 = &out[v17];
        unsigned int v53 = data ^ v39;
        int v54 = v62 ^ v41;
        switch((int)v36)
        {
          case 0:
            goto LABEL_68;
          case 1:
            goto LABEL_67;
          case 2:
            goto LABEL_66;
          case 3:
            goto LABEL_65;
          case 4:
            goto LABEL_64;
          case 5:
            goto LABEL_63;
          case 6:
            goto LABEL_62;
          case 7:
            *--int v52 = HIBYTE(v54);
LABEL_62:
            *--int v52 = BYTE2(v54);
LABEL_63:
            *--int v52 = BYTE1(v54);
LABEL_64:
            *--int v52 = v54;
LABEL_65:
            *--int v52 = HIBYTE(v53);
LABEL_66:
            *--int v52 = BYTE2(v53);
LABEL_67:
            *--int v52 = BYTE1(v53);
LABEL_68:
            *--int v52 = v53;
            break;
          default:
            break;
        }
        v9 -= v17;
        unsigned __int8 in = &v40[v17];
        unsigned __int8 out = &v52[v17];
        LODWORD(v++*(_DWORD *)(*(void *)(result + 8) + 16) = v31;
        unsigned int v37 = v15;
      }
      while (v9 >= v17);
      goto LABEL_41;
    }
    LODWORD(v3md4_block_data_order((unint64_t)c, b, 1) = *(_DWORD *)&(*ivec)[4];
LABEL_41:
    *(_WORD *)ivec = v15;
    (*ivec)[2] = BYTE2(v15);
    (*ivec)[3] = BYTE3(v15);
    *(_WORD *)&(*ivec)[4] = v31;
    (*ivec)[6] = BYTE2(v31);
    (*ivec)[7] = BYTE3(v31);
  }
}

int ENGINE_ctrl(ENGINE *e, int cmd, uint64_t i, void *p, void (*f)(void))
{
  if (!e)
  {
    int v14 = 67;
    int v15 = 198;
    goto LABEL_14;
  }
  uint64_t v8 = *(void *)&cmd;
  CRYPTO_lock(9, 30, 0, 0);
  int v10 = *((_DWORD *)e + 45);
  CRYPTO_lock(10, 30, 0, 0);
  if (v10 <= 0)
  {
    int v14 = 130;
    int v15 = 206;
    goto LABEL_14;
  }
  int v11 = (uint64_t (*)(ENGINE *, uint64_t, uint64_t, void *, void (*)(void)))*((void *)e + 17);
  LODWORD(v12) = v11 != 0;
  if ((v8 - 11) >= 8)
  {
    if (v8 == 10) {
      return (int)v12;
    }
    if (v11)
    {
LABEL_21:
      LODWORD(v12) = v11(e, v8, i, p, f);
      return (int)v12;
    }
    int v14 = 120;
    int v15 = 236;
LABEL_14:
    ERR_put_error(38, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_ctrl.c", v15);
    goto LABEL_15;
  }
  if (!v11)
  {
    int v16 = 120;
    int v17 = 225;
LABEL_18:
    ERR_put_error(38, 4095, v16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_ctrl.c", v17);
    LODWORD(v12) = -1;
    return (int)v12;
  }
  if ((*((unsigned char *)e + 176) & 2) != 0) {
    goto LABEL_21;
  }
  if (v8 == 11)
  {
    uint64_t v13 = *((void *)e + 21);
    if (v13 && *(_DWORD *)v13)
    {
      if (*(void *)(v13 + 8)) {
        LODWORD(v12) = *(_DWORD *)v13;
      }
      else {
        LODWORD(v12) = 0;
      }
      return (int)v12;
    }
LABEL_15:
    LODWORD(v12) = 0;
    return (int)v12;
  }
  BOOL v19 = v8 == 17 || v8 == 15 || v8 == 13;
  if (v19 && !p)
  {
    int v16 = 67;
    int v17 = 128;
    goto LABEL_18;
  }
  uint64_t v20 = *((void *)e + 21);
  if (v8 == 13)
  {
    if (v20 && *(_DWORD *)v20)
    {
      do
      {
        int v21 = *(const char **)(v20 + 8);
        if (!v21) {
          break;
        }
        if (!strcmp(v21, (const char *)p))
        {
          LODWORD(v12) = *(_DWORD *)v20;
          return (int)v12;
        }
        int v22 = *(_DWORD *)(v20 + 32);
        v20 += 32;
      }
      while (v22);
    }
    int v16 = 137;
    int v17 = 136;
    goto LABEL_18;
  }
  if (!v20) {
    goto LABEL_56;
  }
  unsigned int v23 = *(_DWORD *)v20;
  if (*(_DWORD *)v20)
  {
    unsigned int v24 = 0;
    int v25 = (_DWORD *)(v20 + 32);
    do
    {
      if (v23 >= i) {
        break;
      }
      if (!*((void *)v25 - 3)) {
        break;
      }
      ++v24;
      unsigned int v26 = *v25;
      v25 += 8;
      unsigned int v23 = v26;
    }
    while (v26);
  }
  else
  {
    unsigned int v24 = 0;
  }
  if (v23 != i)
  {
LABEL_56:
    int v16 = 138;
    int v17 = 145;
    goto LABEL_18;
  }
  switch((int)v8)
  {
    case 12:
      uint64_t v27 = v24 + 1;
      if (!*(_DWORD *)(v20 + 32 * v27)) {
        goto LABEL_15;
      }
      if (*(void *)(v20 + 32 * v27 + 8)) {
        LODWORD(v12) = *(_DWORD *)(v20 + 32 * v27);
      }
      else {
        LODWORD(v12) = 0;
      }
      return (int)v12;
    case 14:
      LODWORD(v12) = strlen(*(const char **)(v20 + 32 * v24 + 8));
      return (int)v12;
    case 15:
      uint64_t v28 = v24;
      int v29 = *(const char **)(v20 + 32 * v24 + 8);
      size_t v30 = strlen(v29);
      int v31 = snprintf((char *)p, v30 + 1, "%s", v29);
      int v32 = *(const char **)(*((void *)e + 21) + 32 * v28 + 8);
      goto LABEL_65;
    case 16:
      int v12 = *(const char **)(v20 + 32 * v24 + 16);
      if (v12) {
        LODWORD(v12) = strlen(v12);
      }
      return (int)v12;
    case 17:
      uint64_t v33 = v24;
      uint64_t v34 = v20 + 32 * v24;
      int v35 = *(const char **)(v34 + 16);
      if (v35)
      {
        size_t v36 = strlen(*(const char **)(v34 + 16));
        int v31 = snprintf((char *)p, v36 + 1, "%s", v35);
        int v32 = *(const char **)(*((void *)e + 21) + 32 * v33 + 16);
LABEL_65:
        if (strlen(v32) + 1 <= v31) {
          LODWORD(v12) = -1;
        }
        else {
          LODWORD(v12) = v31;
        }
      }
      else
      {
        LODWORD(v12) = 0;
        *(unsigned char *)unsigned int p = 0;
      }
      break;
    case 18:
      LODWORD(v12) = *(_DWORD *)(v20 + 32 * v24 + 24);
      return (int)v12;
    default:
      int v16 = 110;
      int v17 = 188;
      goto LABEL_18;
  }
  return (int)v12;
}

int ENGINE_cmd_is_executable(ENGINE *e, int cmd)
{
  int v2 = ENGINE_ctrl(e, 18, cmd, 0, 0);
  if ((v2 & 0x80000000) == 0) {
    return (v2 & 7) != 0;
  }
  ERR_put_error(38, 4095, 138, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_ctrl.c", 249);
  return 0;
}

int ENGINE_ctrl_cmd(ENGINE *e, const char *cmd_name, uint64_t i, void *p, void (*f)(void), int cmd_optional)
{
  if (!e || !cmd_name)
  {
    int v13 = 67;
    int v14 = 266;
LABEL_7:
    ERR_put_error(38, 4095, v13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_ctrl.c", v14);
    return 0;
  }
  if (*((void *)e + 17))
  {
    int v11 = ENGINE_ctrl(e, 13, 0, (void *)cmd_name, 0);
    if (v11 > 0) {
      return ENGINE_ctrl(e, v11, i, p, f) > 0;
    }
  }
  if (!cmd_optional)
  {
    int v13 = 137;
    int v14 = 282;
    goto LABEL_7;
  }
  ERR_clear_error();
  return 1;
}

int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg, int cmd_optional)
{
  if (!e || !cmd_name)
  {
    int v10 = 67;
    int v11 = 303;
    goto LABEL_13;
  }
  if (!*((void *)e + 17) || (int v7 = ENGINE_ctrl(e, 13, 0, (void *)cmd_name, 0), v7 <= 0))
  {
    if (cmd_optional)
    {
      ERR_clear_error();
      return 1;
    }
    int v10 = 137;
    int v11 = 319;
    goto LABEL_13;
  }
  unsigned int v8 = v7;
  if (!ENGINE_cmd_is_executable(e, v7))
  {
    int v10 = 134;
    int v11 = 323;
    goto LABEL_13;
  }
  int v9 = ENGINE_ctrl(e, 18, v8, 0, 0);
  if (v9 < 0)
  {
    int v10 = 110;
    int v11 = 330;
    goto LABEL_13;
  }
  if ((v9 & 4) != 0)
  {
    if (arg)
    {
      int v10 = 136;
      int v11 = 337;
      goto LABEL_13;
    }
    int v13 = e;
    int v14 = v8;
    uint64_t v15 = 0;
    goto LABEL_24;
  }
  if (!arg)
  {
    int v10 = 135;
    int v11 = 351;
    goto LABEL_13;
  }
  if ((v9 & 2) != 0)
  {
    int v13 = e;
    int v14 = v8;
    uint64_t v15 = 0;
    int v16 = (char *)arg;
    return ENGINE_ctrl(v13, v14, v15, v16, 0) > 0;
  }
  if (v9)
  {
    __endptr = 0;
    uint64_t v17 = strtol(arg, &__endptr, 10);
    if (__endptr == arg || *__endptr)
    {
      int v10 = 133;
      int v11 = 371;
      goto LABEL_13;
    }
    uint64_t v15 = v17;
    int v13 = e;
    int v14 = v8;
LABEL_24:
    int v16 = 0;
    return ENGINE_ctrl(v13, v14, v15, v16, 0) > 0;
  }
  int v10 = 110;
  int v11 = 366;
LABEL_13:
  ERR_put_error(38, 4095, v10, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_ctrl.c", v11);
  return 0;
}

int ASN1_PRINTABLE_type(const unsigned __int8 *s, int max)
{
  if (!s || max < 1) {
    return 19;
  }
  int v2 = 0;
  int v3 = 0;
  unsigned int v4 = max + 1;
  do
  {
    signed __int8 v5 = *s;
    if (!*s) {
      break;
    }
    if ((v5 - 97) >= 0x1A && (v5 - 43) >= 0x10u)
    {
      BOOL v6 = v5 != 32 && (v5 - 65) >= 0x1Au;
      if (v6 && (v5 > 0x3F || ((1 << v5) & 0xA000038000000000) == 0)) {
        int v3 = 1;
      }
    }
    ++s;
    if (v5 < 0) {
      int v2 = 1;
    }
    --v4;
  }
  while (v4 > 1);
  if (v2) {
    return 20;
  }
  if (v3) {
    return 22;
  }
  else {
    return 19;
  }
}

int ASN1_UNIVERSALSTRING_to_string(ASN1_UNIVERSALSTRING *s)
{
  if (s->type != 28) {
    return 0;
  }
  int length = s->length;
  if ((s->length & 3) != 0) {
    return 0;
  }
  unsigned int data = s->data;
  if (length >= 1)
  {
    uint64_t v4 = 0;
    while (1)
    {
      signed __int8 v5 = &data[v4];
      if (data[v4] || v5[1] || v5[2]) {
        return 0;
      }
      v4 += 4;
      if ((int)v4 >= length)
      {
        if (length >= 4)
        {
          uint64_t v6 = 3;
          do
          {
            *data++ = s->data[v6];
            v6 += 4;
          }
          while (v6 < s->length);
        }
        break;
      }
    }
  }
  unsigned __int8 *data = 0;
  int v7 = s->length;
  s->length /= 4;
  s->int type = ASN1_PRINTABLE_type(s->data, v7 / 4);
  return 1;
}

ASN1_TYPE *ASN1_TYPE_new(void)
{
  return (ASN1_TYPE *)ASN1_item_new(&ASN1_ANY_it);
}

void ASN1_TYPE_free(ASN1_TYPE *a)
{
}

int ASN1_TYPE_get(ASN1_TYPE *a)
{
  int result = a->type;
  if ((result | 4) != 5 && !a->value.ptr) {
    return 0;
  }
  return result;
}

void ASN1_TYPE_set(ASN1_TYPE *a, int type, void *value)
{
  punint64_t val = (ASN1_VALUE *)a;
  if (a->value.ptr)
  {
    ASN1_primitive_free(&pval, 0);
    EVP_CIPHER_CTX a = (ASN1_TYPE *)pval;
  }
  a->int type = type;
  if (type == 1)
  {
    if (value) {
      ASN1_BOOLEAN v5 = 255;
    }
    else {
      ASN1_BOOLEAN v5 = 0;
    }
    a->value.BOOLeaint n = v5;
  }
  else
  {
    a->value.ptr = (char *)value;
  }
}

int ASN1_TYPE_set1(ASN1_TYPE *a, int type, const void *value)
{
  if (type == 1 || !value) {
    goto LABEL_10;
  }
  if (type != 6)
  {
    ASN1_BOOLEAN v5 = ASN1_STRING_dup((ASN1_STRING *)value);
    if (!v5) {
      return (int)v5;
    }
    CONF_VALUE value = v5;
LABEL_10:
    ASN1_TYPE_set(a, type, (void *)value);
LABEL_11:
    LODWORD(v5) = 1;
    return (int)v5;
  }
  ASN1_BOOLEAN v5 = OBJ_dup((const ASN1_OBJECT *)value);
  if (v5)
  {
    uint64_t v6 = (char *)v5;
    punint64_t val = (ASN1_VALUE *)a;
    if (a->value.ptr)
    {
      ASN1_primitive_free(&pval, 0);
      EVP_CIPHER_CTX a = (ASN1_TYPE *)pval;
    }
    a->int type = 6;
    a->value.ptr = v6;
    goto LABEL_11;
  }
  return (int)v5;
}

uint64_t ASN1_TYPE_cmp(const ASN1_OBJECT **a1, uint64_t a2)
{
  uint64_t v2 = 0xFFFFFFFFLL;
  if (!a1 || !a2) {
    return v2;
  }
  int v3 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 != *(_DWORD *)a2) {
    return 0xFFFFFFFFLL;
  }
  switch(v3)
  {
    case 1:
      return (*((_DWORD *)a1 + 2) - *(_DWORD *)(a2 + 8));
    case 5:
      return 0;
    case 6:
      return OBJ_cmp(a1[1], *(const ASN1_OBJECT **)(a2 + 8));
    default:
      return ASN1_STRING_cmp((ASN1_STRING *)a1[1], *(ASN1_STRING **)(a2 + 8));
  }
}

int ASN1_TYPE_set_octetstring(ASN1_TYPE *a, unsigned __int8 *data, int len)
{
  uint64_t v6 = ASN1_OCTET_STRING_new();
  if (v6)
  {
    int v7 = (char *)v6;
    if (ASN1_STRING_set(v6, data, len))
    {
      punint64_t val = (ASN1_VALUE *)a;
      if (a->value.ptr)
      {
        ASN1_primitive_free(&pval, 0);
        EVP_CIPHER_CTX a = (ASN1_TYPE *)pval;
      }
      a->int type = 4;
      a->value.ptr = v7;
      LODWORD(v6) = 1;
    }
    else
    {
      ASN1_OCTET_STRING_free((ASN1_OCTET_STRING *)v7);
      LODWORD(v6) = 0;
    }
  }
  return (int)v6;
}

int ASN1_TYPE_get_octetstring(ASN1_TYPE *a, unsigned __int8 *data, int max_len)
{
  if (a->type == 4 && (ptr = a->value.ptr) != 0)
  {
    int v7 = ASN1_STRING_data((ASN1_STRING *)ptr);
    int v8 = ASN1_STRING_length(a->value.asn1_string);
    int v9 = v8;
    if (v8 >= max_len) {
      int v10 = max_len;
    }
    else {
      int v10 = v8;
    }
    memcpy(data, v7, v10);
  }
  else
  {
    ERR_put_error(13, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_type.c", 225);
    return -1;
  }
  return v9;
}

int ASN1_TYPE_set_int_octetstring(ASN1_TYPE *a, uint64_t num, unsigned __int8 *data, int len)
{
  int v8 = (ASN1_INTEGER **)ASN1_item_new(&ASN1_INT_OCTETSTRING_it);
  int v9 = v8;
  if (v8
    && ASN1_INTEGER_set(*v8, num)
    && ASN1_OCTET_STRING_set(v9[1], data, len)
    && (int v10 = ASN1_item_pack(v9, &ASN1_INT_OCTETSTRING_it, 0)) != 0)
  {
    int v11 = (char *)v10;
    punint64_t val = (ASN1_VALUE *)a;
    if (a->value.ptr)
    {
      ASN1_primitive_free(&pval, 0);
      EVP_CIPHER_CTX a = (ASN1_TYPE *)pval;
    }
    a->int type = 16;
    a->value.ptr = v11;
    int v12 = 1;
  }
  else
  {
    int v12 = 0;
  }
  ASN1_item_free((ASN1_VALUE *)v9, &ASN1_INT_OCTETSTRING_it);
  ASN1_STRING_free(0);
  return v12;
}

int ASN1_TYPE_get_int_octetstring(ASN1_TYPE *a, uint64_t *num, unsigned __int8 *data, int max_len)
{
  ptr = a->value.ptr;
  BOOL v6 = a->type != 16 || ptr == 0;
  if (v6 || (int v10 = (ASN1_INTEGER **)ASN1_item_unpack((ASN1_STRING *)ptr, &ASN1_INT_OCTETSTRING_it)) == 0)
  {
    ASN1_item_free(0, &ASN1_INT_OCTETSTRING_it);
LABEL_15:
    ERR_put_error(13, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_type.c", 299);
    return -1;
  }
  int v11 = v10;
  if (num) {
    *uint64_t num = ASN1_INTEGER_get(*v10);
  }
  if (data)
  {
    int v12 = ASN1_STRING_length(v11[1]);
    if (v12 < max_len) {
      max_uint64_t len = v12;
    }
    int v13 = ASN1_STRING_data(v11[1]);
    memcpy(data, v13, max_len);
  }
  int v14 = ASN1_STRING_length(v11[1]);
  ASN1_item_free((ASN1_VALUE *)v11, &ASN1_INT_OCTETSTRING_it);
  if (v14 == -1) {
    goto LABEL_15;
  }
  return v14;
}

ASN1_VALUE *ASN1_TYPE_pack_sequence(ASN1_ITEM *it, void *obj, ASN1_VALUE **a3)
{
  uint64_t v4 = ASN1_item_pack(obj, it, 0);
  if (!v4) {
    return 0;
  }
  ASN1_BOOLEAN v5 = v4;
  if (!a3)
  {
    BOOL v6 = ASN1_item_new(&ASN1_ANY_it);
    if (v6) {
      goto LABEL_7;
    }
LABEL_10:
    ASN1_OCTET_STRING_free(v5);
    return 0;
  }
  BOOL v6 = *a3;
  if (!*a3)
  {
    int v7 = ASN1_item_new(&ASN1_ANY_it);
    if (v7)
    {
      BOOL v6 = v7;
      *a3 = v7;
      goto LABEL_7;
    }
    goto LABEL_10;
  }
LABEL_7:
  punint64_t val = v6;
  int v8 = v6;
  if (*((void *)v6 + 1))
  {
    ASN1_primitive_free(&pval, 0);
    int v8 = pval;
  }
  *(_DWORD *)int v8 = 16;
  *((void *)v8 + md4_block_data_order((unint64_t)c, b, 1) = v5;
  return v6;
}

void *ASN1_TYPE_unpack_sequence(ASN1_ITEM *it, uint64_t a2)
{
  if (a2 && *(_DWORD *)a2 == 16 && (int v3 = *(ASN1_STRING **)(a2 + 8)) != 0) {
    return ASN1_item_unpack(v3, it);
  }
  else {
    return 0;
  }
}

int i2d_ASN1_TYPE(ASN1_TYPE *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_ANY_it);
}

ASN1_TYPE *__cdecl d2i_ASN1_TYPE(ASN1_TYPE **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_TYPE *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_ANY_it);
}

BN_MONT_CTX *BN_MONT_CTX_new(void)
{
  BOOL v0 = (BN_MONT_CTX *)malloc_type_calloc(1uLL, 0x50uLL, 0x1010040E9A11DBBuLL);
  int v1 = v0;
  if (v0)
  {
    v0->Ni.int neg = 1;
    BN_init(&v0->RR);
    BN_init(&v1->N);
  }
  return v1;
}

void BN_MONT_CTX_free(BN_MONT_CTX *mont)
{
  if (mont)
  {
    BN_free(&mont->RR);
    BN_free(&mont->N);
    if (mont->Ni.neg)
    {
      free(mont);
    }
  }
}

BN_MONT_CTX *__cdecl BN_MONT_CTX_copy(BN_MONT_CTX *to, BN_MONT_CTX *from)
{
  uint64_t v2 = to;
  if (to != from)
  {
    if (bn_copy(&to->RR, &from->RR) && bn_copy(&v2->N, &from->N))
    {
      v2->ruint64_t i = from->ri;
      v2->Ni.unsigned int d = from->Ni.d;
      *(void *)&v2->Ni.tounsigned int p = *(void *)&from->Ni.top;
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *mod, BN_CTX *ctx)
{
  BN_CTX_start(ctx);
  BOOL v6 = BN_CTX_get(ctx);
  if (!v6
    || (int v7 = v6, (v8 = BN_CTX_get(ctx)) == 0)
    || (v9 = (uint64_t)v8, (int v10 = BN_CTX_get(ctx)) == 0)
    || (int v11 = v10, (v12 = BN_CTX_get(ctx)) == 0)
    || (int v13 = v12, BN_is_zero((uint64_t)mod))
    || !bn_copy(&mont->N, mod))
  {
LABEL_6:
    BOOL v14 = 0;
    goto LABEL_7;
  }
  mont->N.int neg = 0;
  int v16 = BN_num_bits(mod);
  BOOL v14 = 0;
  unsigned int v17 = v16 + 63;
  if (v16 < -63) {
    unsigned int v17 = v16 + 126;
  }
  mont->ruint64_t i = v17 & 0xFFFFFFC0;
  if ((int)(v17 & 0xFFFFFFC0) <= (int)(v17 >> 6 << 7))
  {
    BN_zero((uint64_t)v11);
    if (BN_set_bit(v11, 64)
      && bn_wexpand((uint64_t)v7, 2uLL)
      && BN_set_word(v7, *mod->d)
      && BN_mod_inverse_ct(v13, v11, v7, ctx)
      && BN_lshift((BIGNUM *)v9, v13, 64)
      && (!BN_is_zero(v9) || BN_set_bit((BIGNUM *)v9, 64))
      && BN_sub_word((BIGNUM *)v9, 1uLL)
      && BN_div_ct(v9, 0, (const BIGNUM *)v9, v7, ctx))
    {
      mont->Ni.unsigned int d = 0;
      *(void *)&mont->Ni.tounsigned int p = 0;
      if (*(int *)(v9 + 8) >= 1) {
        mont->Ni.unsigned int d = **(unint64_t ***)v9;
      }
      BN_zero((uint64_t)&mont->RR);
      if (BN_set_bit(&mont->RR, 2 * mont->ri))
      {
        BOOL v14 = BN_mod_ct(&mont->RR, &mont->RR, &mont->N, ctx) != 0;
        goto LABEL_7;
      }
    }
    goto LABEL_6;
  }
LABEL_7:
  BN_CTX_end(ctx);
  return v14;
}

BN_MONT_CTX *__cdecl BN_MONT_CTX_set_locked(BN_MONT_CTX **pmont, int lock, const BIGNUM *mod, BN_CTX *ctx)
{
  CRYPTO_lock(5, lock, 0, 0);
  int v8 = *pmont;
  CRYPTO_lock(6, lock, 0, 0);
  if (!v8)
  {
    uint64_t v9 = BN_MONT_CTX_new();
    int v8 = v9;
    if (v9 && BN_MONT_CTX_set(v9, mod, ctx))
    {
      CRYPTO_lock(9, lock, 0, 0);
      if (*pmont)
      {
        BN_MONT_CTX_free(v8);
        int v8 = *pmont;
      }
      else
      {
        *pmont = v8;
      }
      CRYPTO_lock(10, lock, 0, 0);
    }
    else
    {
      BN_MONT_CTX_free(v8);
      return 0;
    }
  }
  return v8;
}

unint64_t bn_montgomery_multiply_words(unint64_t *a1, uint64_t *a2, uint64_t a3, const unint64_t *a4, unint64_t *a5, uint64_t a6, int a7)
{
  int v7 = a7;
  int v8 = a5;
  if (a7 <= 0)
  {
    unint64_t v17 = 0;
    uint64_t v14 = a7;
  }
  else
  {
    uint64_t v14 = a7;
    size_t v15 = 8 * a7;
    bzero(a5, v15);
    uint64_t v16 = 0;
    unint64_t v17 = 0;
    uint64_t v18 = *a2;
    do
    {
      unint64_t v19 = 0;
      unint64_t v20 = 0;
      unint64_t v21 = 0;
      uint64_t v22 = *(void *)(a3 + 8 * v16);
      unint64_t v23 = (*v8 + v22 * v18) * a6;
      do
      {
        uint64_t v24 = a2[v19 / 8];
        unint64_t v25 = v8[v19 / 8];
        unint64_t v26 = v24 * (unint64_t)v22;
        unint64_t v27 = HIDWORD(v24) * (unint64_t)v22;
        unint64_t v28 = HIDWORD(v27) + HIDWORD(v24) * (unint64_t)HIDWORD(v22);
        unint64_t v29 = v26 | (v27 << 32);
        unint64_t v30 = v26 & (v27 << 32);
        unint64_t v31 = (v27 << 32) + v24 * (unint64_t)v22;
        unint64_t v32 = v29 & ~v31 | v30;
        unint64_t v33 = v24 * (unint64_t)HIDWORD(v22);
        unint64_t v34 = v31 | (v33 << 32);
        unint64_t v35 = v31 & (v33 << 32);
        unint64_t v36 = v31 + (v33 << 32);
        unint64_t v37 = v28 + HIDWORD(v33) + (v32 >> 63) + ((v34 & ~v36 | v35) >> 63);
        unint64_t v38 = v36 | v25;
        unint64_t v39 = v36 & v25;
        unint64_t v40 = v36 + v25;
        unint64_t v41 = v37 + ((v38 & ~v40 | v39) >> 63);
        unint64_t v42 = v40 | v21;
        unint64_t v43 = v40 & v21;
        unint64_t v44 = v40 + v21;
        unint64_t v21 = v41 + ((v42 & ~v44 | v43) >> 63);
        unint64_t v45 = a4[v19 / 8];
        unint64_t v46 = v45 * (unint64_t)v23;
        unint64_t v47 = HIDWORD(v45) * (unint64_t)v23;
        unint64_t v48 = HIDWORD(v47) + HIDWORD(v45) * (unint64_t)HIDWORD(v23);
        unint64_t v49 = v46 | (v47 << 32);
        unint64_t v50 = v46 & (v47 << 32);
        unint64_t v51 = (v47 << 32) + v45 * (unint64_t)v23;
        unint64_t v52 = v49 & ~v51 | v50;
        unint64_t v53 = v45 * (unint64_t)HIDWORD(v23);
        unint64_t v54 = v51 | (v53 << 32);
        unint64_t v55 = v51 & (v53 << 32);
        unint64_t v56 = v51 + (v53 << 32);
        unint64_t v57 = v48 + HIDWORD(v53) + (v52 >> 63) + ((v54 & ~v56 | v55) >> 63);
        unint64_t v58 = v56 | v44;
        unint64_t v59 = v56 & v44;
        unint64_t v60 = v56 + v44;
        unint64_t v61 = v57 + ((v58 & ~v60 | v59) >> 63);
        uint64_t v62 = v60 | v20;
        uint64_t v63 = v60 & v20;
        unint64_t v64 = v60 + v20;
        unint64_t v20 = v61 + ((v62 & ~v64 | v63) >> 63);
        v8[v19 / 8] = v64;
        v19 += 8;
      }
      while (v15 != v19);
      uint64_t v65 = v20 | v21;
      uint64_t v66 = v20 & v21;
      unint64_t v67 = v20 + v21;
      unint64_t v68 = v65 & ~v67 | v66;
      unint64_t v69 = v67 | v17;
      unint64_t v70 = v67 & v17;
      unint64_t v71 = v67 + v17;
      unint64_t v17 = ((v69 & ~v71 | v70) >> 63) + (v68 >> 63);
      v8[v7] = v71;
      ++v8;
      ++v16;
    }
    while (v16 != v7);
  }
  v8[v14] = v17;
  BOOL v72 = v17 != 0;
  unint64_t result = bn_sub_words(a1, v8, a4, v7);
  if (v7 >= 1)
  {
    do
    {
      unint64_t v74 = *v8++;
      *a1 = v74 & (v72 - result) | *a1 & ~(v72 - result);
      ++a1;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t bn_montgomery_multiply(BIGNUM *a1, uint64_t a2, uint64_t a3, uint64_t a4, BN_CTX *ctx)
{
  BN_CTX_start(ctx);
  size_t v10 = *(unsigned int *)(a4 + 40);
  if ((int)v10 >= 2
    && *(_DWORD *)(a2 + 8) == v10
    && *(_DWORD *)(a3 + 8) == v10
    && bn_wexpand((uint64_t)a1, v10)
    && (int v11 = BN_CTX_get(ctx)) != 0
    && (p_unsigned int d = &v11->d, bn_wexpand((uint64_t)v11, (2 * *(_DWORD *)(a4 + 40) + 2))))
  {
    bn_montgomery_multiply_words(a1->d, *(uint64_t **)a2, *(void *)a3, *(const unint64_t **)(a4 + 32), *p_d, *(void *)(a4 + 56), *(_DWORD *)(a4 + 40));
    a1->tounsigned int p = *(_DWORD *)(a4 + 40);
    bn_correct_top((uint64_t *)a1);
    BN_set_negative(a1, *(_DWORD *)(a3 + 16) ^ *(_DWORD *)(a2 + 16));
    uint64_t v13 = 1;
  }
  else
  {
    uint64_t v13 = 0;
  }
  BN_CTX_end(ctx);
  return v13;
}

uint64_t bn_mod_mul_montgomery(BIGNUM *a1, const BIGNUM *a2, const BIGNUM *a3, uint64_t a4, BN_CTX *ctx)
{
  int v10 = *(_DWORD *)(a4 + 40);
  if (v10 < 2 || a2->top != v10 || a3->top != v10)
  {
    BN_CTX_start(ctx);
    int v12 = BN_CTX_get(ctx);
    if (v12)
    {
      uint64_t v13 = (uint64_t)v12;
      if (a2 == a3)
      {
        if (BN_sqr(v12, a2, ctx)) {
          goto LABEL_10;
        }
      }
      else if (BN_mul(v12, a2, a3, ctx))
      {
LABEL_10:
        uint64_t v14 = bn_montgomery_reduce(a1, v13, a4);
LABEL_13:
        BN_CTX_end(ctx);
        return v14;
      }
    }
    uint64_t v14 = 0;
    goto LABEL_13;
  }
  return bn_montgomery_multiply(a1, (uint64_t)a2, (uint64_t)a3, a4, ctx);
}

uint64_t BN_to_montgomery(BIGNUM *a1, const BIGNUM *a2, uint64_t a3, BN_CTX *ctx)
{
  return bn_mod_mul_montgomery(a1, a2, (const BIGNUM *)(a3 + 8), a3, ctx);
}

int BN_from_montgomery(BIGNUM *r, const BIGNUM *a, BN_MONT_CTX *mont, BN_CTX *ctx)
{
  BN_CTX_start(ctx);
  int v8 = BN_CTX_get(ctx);
  if (v8 && (uint64_t v9 = (uint64_t)v8, bn_copy(v8, a))) {
    int v10 = bn_montgomery_reduce(r, v9, (uint64_t)mont);
  }
  else {
    int v10 = 0;
  }
  BN_CTX_end(ctx);
  return v10;
}

uint64_t bn_montgomery_reduce(BIGNUM *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(unsigned int *)(a3 + 40);
  if (!v4)
  {
    BN_zero((uint64_t)a1);
    return 1;
  }
  uint64_t result = bn_wexpand((uint64_t)a1, *(unsigned int *)(a3 + 40));
  if (!result) {
    return result;
  }
  int v8 = 2 * v4;
  if (2 * (int)v4 < (int)v4) {
    return 0;
  }
  uint64_t result = bn_wexpand(a2, (2 * v4));
  if (result)
  {
    uint64_t v9 = *(int *)(a2 + 8);
    uint64_t v10 = *(void *)a2;
    if ((int)v9 < v8) {
      bzero((void *)(v10 + 8 * v9), 8 * (v8 + ~v9) + 8);
    }
    if ((int)v4 <= 0)
    {
      unint64_t v12 = 0;
      uint64_t v25 = (int)v4;
    }
    else
    {
      uint64_t v11 = 0;
      unint64_t v12 = 0;
      uint64_t v13 = *(void *)(a3 + 56);
      uint64_t v14 = 8 * v4;
      do
      {
        unint64_t v15 = bn_mul_add_words((unint64_t *)(v10 + v11), *(const unint64_t **)(a3 + 32), v4, *(void *)(v10 + v11) * v13);
        uint64_t v10 = *(void *)a2;
        uint64_t v16 = *(void *)a2 + v14;
        uint64_t v17 = *(void *)(v16 + v11);
        unint64_t v18 = v17 | v15;
        unint64_t v19 = v17 & v15;
        uint64_t v20 = v17 + v15;
        unint64_t v21 = v18 & ~v20 | v19;
        uint64_t v22 = v20 | v12;
        uint64_t v23 = v20 & v12;
        uint64_t v24 = v20 + v12;
        unint64_t v12 = ((v22 & ~v24 | (unint64_t)v23) >> 63) + (v21 >> 63);
        *(void *)(v16 + v1md4_block_data_order((unint64_t)c, b, 1) = v24;
        v11 += 8;
      }
      while (v14 != v11);
      uint64_t v25 = v4;
    }
    unint64_t v26 = (const unint64_t *)(v10 + 8 * v25);
    unint64_t v27 = bn_sub_words(a1->d, v26, *(const unint64_t **)(a3 + 32), v4);
    if ((int)v4 >= 1)
    {
      unsigned int d = a1->d;
      int v29 = v4;
      do
      {
        unint64_t v30 = *v26++;
        *unsigned int d = v30 & (v12 - v27) | *d & ~(v12 - v27);
        ++d;
        --v29;
      }
      while (v29);
    }
    a1->tounsigned int p = v4;
    bn_correct_top((uint64_t *)a1);
    BN_set_negative(a1, *(_DWORD *)(a3 + 48) ^ *(_DWORD *)(a2 + 16));
    return 1;
  }
  return result;
}

int DHparams_print(BIO *bp, const DH *x)
{
  return do_dh_print(bp, (uint64_t)x, 4, 0);
}

uint64_t do_dh_print(BIO *a1, uint64_t a2, int a3, int a4)
{
  if (a4 == 2)
  {
    int v8 = *(const BIGNUM **)(a2 + 40);
LABEL_4:
    uint64_t v10 = *(const BIGNUM **)(a2 + 32);
    uint64_t v9 = v8;
    goto LABEL_5;
  }
  int v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  if (a4 >= 1) {
    goto LABEL_4;
  }
LABEL_5:
  uint64_t v11 = *(const BIGNUM **)(a2 + 8);
  if (!v11) {
    goto LABEL_9;
  }
  int v12 = BN_num_bits(v11);
  int v13 = v12 + 7;
  if (v12 < -7) {
    int v13 = v12 + 14;
  }
  if ((v12 + 14) < 0xF)
  {
LABEL_9:
    uint64_t v14 = 0;
    int v15 = 67;
LABEL_43:
    ERR_put_error(5, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_ameth.c", 382);
    uint64_t v29 = 0;
    goto LABEL_44;
  }
  unsigned int v16 = v13 >> 3;
  uint64_t v17 = *(const BIGNUM **)(a2 + 16);
  if (v17)
  {
    int v18 = BN_num_bits(v17);
    int v19 = v18 + 7;
    if (v18 < -7) {
      int v19 = v18 + 14;
    }
    if (v16 <= v19 >> 3) {
      unsigned int v16 = v19 >> 3;
    }
  }
  if (v10)
  {
    int v20 = BN_num_bits(v10);
    int v21 = v20 + 7;
    if (v20 < -7) {
      int v21 = v20 + 14;
    }
    if (v16 <= v21 >> 3) {
      unsigned int v16 = v21 >> 3;
    }
  }
  if (v9)
  {
    int v22 = BN_num_bits(v9);
    int v23 = v22 + 7;
    if (v22 < -7) {
      int v23 = v22 + 14;
    }
    if (v16 <= v23 >> 3) {
      unsigned int v16 = v23 >> 3;
    }
  }
  uint64_t v24 = (int)v16;
  uint64_t v25 = "PKCS#3 DH Parameters";
  if (a4 == 1) {
    uint64_t v25 = "PKCS#3 DH Public-Key";
  }
  if (a4 == 2) {
    unint64_t v26 = "PKCS#3 DH Private-Key";
  }
  else {
    unint64_t v26 = v25;
  }
  uint64_t v14 = (unsigned __int8 *)malloc_type_malloc(v24 + 10, 0x5C59B9FuLL);
  if (!v14)
  {
    int v15 = 65;
    goto LABEL_43;
  }
  if (!BIO_indent(a1, a3, 128)
    || (int v27 = BN_num_bits(*(const BIGNUM **)(a2 + 8)), BIO_printf(a1, "%s: (%d bit)\n", v26, v27) < 1)
    || (int v28 = a3 + 4, !ASN1_bn_print(a1, "private-key:", v9, v14, v28))
    || !ASN1_bn_print(a1, "public-key:", v10, v14, v28)
    || !ASN1_bn_print(a1, "prime:", *(const BIGNUM **)(a2 + 8), v14, v28)
    || !ASN1_bn_print(a1, "generator:", *(const BIGNUM **)(a2 + 16), v14, v28)
    || *(void *)(a2 + 24)
    && (!BIO_indent(a1, v28, 128) || BIO_printf(a1, "recommended-private-length: %d bits\n", *(void *)(a2 + 24)) <= 0))
  {
    int v15 = 7;
    goto LABEL_43;
  }
  uint64_t v29 = 1;
LABEL_44:
  free(v14);
  return v29;
}

int DHparams_print_fp(FILE *fp, const DH *x)
{
  uint64_t v4 = BIO_s_file();
  ASN1_BOOLEAN v5 = BIO_new(v4);
  if (v5)
  {
    BOOL v6 = v5;
    BIO_ctrl(v5, 106, 0, fp);
    int v7 = do_dh_print(v6, (uint64_t)x, 4, 0);
    BIO_free(v6);
    return v7;
  }
  else
  {
    ERR_put_error(5, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_ameth.c", 484);
    return 0;
  }
}

uint64_t dh_pub_decode(EVP_PKEY *a1, uint64_t a2)
{
  punsigned int p = 0;
  unsigned __int8 in = 0;
  ppunint64_t val = 0;
  *(void *)int pptype = 0;
  algor = 0;
  uint64_t result = X509_PUBKEY_get0_param(0, &in, &pptype[1], &algor, a2);
  if (result)
  {
    X509_ALGOR_get0(0, pptype, &ppval, algor);
    if (pptype[0] == 16)
    {
      punsigned int p = (unsigned __int8 *)*((void *)ppval + 1);
      uint64_t v4 = d2i_DHparams(0, (const unsigned __int8 **)&pp, *(int *)ppval);
      if (v4)
      {
        ASN1_BOOLEAN v5 = d2i_ASN1_INTEGER(0, (const unsigned __int8 **)&in, pptype[1]);
        if (v5)
        {
          BOOL v6 = v5;
          int v7 = ASN1_INTEGER_to_BN(v5, 0);
          v4->pub_uint64_t key = v7;
          if (v7)
          {
            ASN1_INTEGER_free(v6);
            EVP_PKEY_assign(a1, 28, (char *)v4);
            return 1;
          }
          ERR_put_error(5, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_ameth.c", 114);
          ASN1_INTEGER_free(v6);
          goto LABEL_12;
        }
        int v8 = 108;
      }
      else
      {
        int v8 = 103;
      }
      ERR_put_error(5, 4095, 104, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_ameth.c", v8);
    }
    else
    {
      ERR_put_error(5, 4095, 105, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_ameth.c", 94);
      uint64_t v4 = 0;
    }
LABEL_12:
    DH_free(v4);
    return 0;
  }
  return result;
}

uint64_t dh_pub_encode(uint64_t a1, uint64_t a2)
{
  unsigned __int8 out = 0;
  int v3 = *(const DH **)(a2 + 32);
  uint64_t v4 = ASN1_STRING_new();
  ASN1_BOOLEAN v5 = v4;
  if (!v4)
  {
    int v12 = 143;
LABEL_10:
    ERR_put_error(5, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_ameth.c", v12);
    goto LABEL_11;
  }
  int v6 = i2d_DHparams(v3, &v4->data);
  v5->int length = v6;
  if (v6 <= 0)
  {
    int v12 = 149;
    goto LABEL_10;
  }
  int v7 = BN_to_ASN1_INTEGER(v3->pub_key, 0);
  if (!v7) {
    goto LABEL_11;
  }
  int v8 = v7;
  int v9 = i2d_ASN1_INTEGER(v7, &out);
  ASN1_INTEGER_free(v8);
  if (v9 <= 0)
  {
    int v12 = 163;
    goto LABEL_10;
  }
  uint64_t v10 = OBJ_nid2obj(28);
  if (X509_PUBKEY_set0_param(a1, v10, 16, v5, out, v9)) {
    return 1;
  }
LABEL_11:
  free(out);
  ASN1_STRING_free(v5);
  return 0;
}

BOOL dh_pub_cmp(uint64_t a1, uint64_t a2)
{
  BOOL result = dh_cmp_parameters(a1, a2);
  if (result) {
    return BN_cmp(*(const BIGNUM **)(*(void *)(a2 + 32) + 32), *(const BIGNUM **)(*(void *)(a1 + 32) + 32)) == 0;
  }
  return result;
}

uint64_t dh_public_print(BIO *a1, uint64_t a2, int a3)
{
  return do_dh_print(a1, *(void *)(a2 + 32), a3, 1);
}

uint64_t dh_priv_decode(EVP_PKEY *a1, uint64_t a2)
{
  punsigned int p = 0;
  unsigned __int8 in = 0;
  ppunint64_t val = 0;
  *(void *)int pptype = 0;
  algor = 0;
  uint64_t result = PKCS8_pkey_get0(0, &in, &pptype[1], &algor, a2);
  if (result)
  {
    X509_ALGOR_get0(0, pptype, &ppval, algor);
    uint64_t v4 = 0;
    if (pptype[0] == 16
      && (uint64_t v4 = d2i_ASN1_INTEGER(0, (const unsigned __int8 **)&in, pptype[1])) != 0
      && (punsigned int p = (unsigned __int8 *)*((void *)ppval + 1),
          (ASN1_BOOLEAN v5 = d2i_DHparams(0, (const unsigned __int8 **)&pp, *(int *)ppval)) != 0))
    {
      int v6 = v5;
      int v7 = ASN1_INTEGER_to_BN(v4, 0);
      v6->priv_uint64_t key = v7;
      if (v7)
      {
        if (DH_generate_key(v6))
        {
          EVP_PKEY_assign(a1, 28, (char *)v6);
          ASN1_INTEGER_free(v4);
          return 1;
        }
      }
      else
      {
        ERR_put_error(5, 4095, 106, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_ameth.c", 214);
      }
    }
    else
    {
      ERR_put_error(5, 4095, 114, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_ameth.c", 228);
      int v6 = 0;
    }
    ASN1_INTEGER_free(v4);
    DH_free(v6);
    return 0;
  }
  return result;
}

uint64_t dh_priv_encode(uint64_t a1, uint64_t a2)
{
  unsigned __int8 out = 0;
  uint64_t v4 = ASN1_STRING_new();
  if (!v4)
  {
    int v11 = 65;
    int v12 = 246;
LABEL_9:
    ERR_put_error(5, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_ameth.c", v12);
    int v13 = 0;
    goto LABEL_10;
  }
  int v5 = i2d_DHparams(*(const DH **)(a2 + 32), &v4->data);
  v4->int length = v5;
  if (v5 <= 0)
  {
    int v11 = 65;
    int v12 = 252;
    goto LABEL_9;
  }
  v4->int type = 16;
  int v6 = BN_to_ASN1_INTEGER(*(BIGNUM **)(*(void *)(a2 + 32) + 40), 0);
  if (!v6)
  {
    int v11 = 106;
    int v12 = 261;
    goto LABEL_9;
  }
  int v7 = v6;
  int v8 = i2d_ASN1_INTEGER(v6, &out);
  ASN1_INTEGER_free(v7);
  int v9 = OBJ_nid2obj(28);
  if (PKCS8_pkey_set0(a1, v9, 0, 16, v4, out, v8)) {
    return 1;
  }
  int v13 = out;
LABEL_10:
  free(v13);
  ASN1_STRING_free(v4);
  ASN1_INTEGER_free(0);
  return 0;
}

uint64_t dh_private_print(BIO *a1, uint64_t a2, int a3)
{
  return do_dh_print(a1, *(void *)(a2 + 32), a3, 2);
}

uint64_t int_dh_size(uint64_t a1)
{
  return DH_size(*(const DH **)(a1 + 32));
}

uint64_t dh_bits(uint64_t a1)
{
  return BN_num_bits(*(const BIGNUM **)(*(void *)(a1 + 32) + 8));
}

uint64_t dh_security_bits(uint64_t a1)
{
  return DH_security_bits(*(void *)(a1 + 32));
}

uint64_t dh_param_decode(EVP_PKEY *a1, const unsigned __int8 **a2, int a3)
{
  uint64_t v4 = (char *)d2i_DHparams(0, a2, a3);
  if (v4)
  {
    EVP_PKEY_assign(a1, 28, v4);
    return 1;
  }
  else
  {
    ERR_put_error(5, 4095, 5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_ameth.c", 300);
    return 0;
  }
}

uint64_t dh_param_encode(uint64_t a1, unsigned __int8 **a2)
{
  return i2d_DHparams(*(const DH **)(a1 + 32), a2);
}

BOOL dh_missing_parameters(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  return !*(void *)(v1 + 8) || *(void *)(v1 + 16) == 0;
}

BIGNUM *dh_copy_parameters(uint64_t a1, uint64_t a2)
{
  uint64_t result = BN_dup(*(const BIGNUM **)(*(void *)(a2 + 32) + 8));
  if (result)
  {
    int v5 = result;
    BN_free(*(BIGNUM **)(*(void *)(a1 + 32) + 8));
    *(void *)(*(void *)(a1 + 32) + 8) = v5;
    uint64_t result = BN_dup(*(const BIGNUM **)(*(void *)(a2 + 32) + 16));
    if (result)
    {
      int v6 = result;
      BN_free(*(BIGNUM **)(*(void *)(a1 + 32) + 16));
      *(void *)(*(void *)(a1 + 32) + ++*(_DWORD *)(*(void *)(result + 8) + 16) = v6;
      return (BIGNUM *)1;
    }
  }
  return result;
}

BOOL dh_cmp_parameters(uint64_t a1, uint64_t a2)
{
  return !BN_cmp(*(const BIGNUM **)(*(void *)(a1 + 32) + 8), *(const BIGNUM **)(*(void *)(a2 + 32) + 8))
      && BN_cmp(*(const BIGNUM **)(*(void *)(a1 + 32) + 16), *(const BIGNUM **)(*(void *)(a2 + 32) + 16)) == 0;
}

uint64_t dh_param_print(BIO *a1, uint64_t a2, int a3)
{
  return do_dh_print(a1, *(void *)(a2 + 32), a3, 0);
}

void int_dh_free(uint64_t a1)
{
}

uint64_t dh_pkey_public_check(uint64_t a1)
{
  uint64_t v1 = *(const DH **)(a1 + 32);
  pub_uint64_t key = v1->pub_key;
  if (pub_key)
  {
    return DH_check_pub_key_ex(v1, pub_key);
  }
  else
  {
    ERR_put_error(5, 4095, 125, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dh/dh_ameth.c", 501);
    return 0;
  }
}

uint64_t dh_pkey_param_check(uint64_t a1)
{
  return DH_check_ex(*(const DH **)(a1 + 32));
}

void ENGINE_unregister_pkey_meths(void *a1)
{
}

uint64_t ENGINE_register_pkey_meths(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(a1 + 96);
  if (v1 && (int v3 = v1(), v3 > 0)) {
    return engine_table_register(&pkey_meth_table, (uint64_t)engine_unregister_all_pkey_meths, (char *)a1, 0, v3, 0);
  }
  else {
    return 1;
  }
}

void engine_unregister_all_pkey_meths()
{
}

ENGINE *ENGINE_register_all_pkey_meths()
{
  uint64_t result = ENGINE_get_first();
  if (result)
  {
    uint64_t v1 = result;
    do
    {
      ENGINE_register_pkey_meths((uint64_t)v1);
      uint64_t result = ENGINE_get_next(v1);
      uint64_t v1 = result;
    }
    while (result);
  }
  return result;
}

uint64_t ENGINE_set_default_pkey_meths(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(a1 + 96);
  if (v1 && (int v3 = v1(), v3 > 0)) {
    return engine_table_register(&pkey_meth_table, (uint64_t)engine_unregister_all_pkey_meths, (char *)a1, 0, v3, 1);
  }
  else {
    return 1;
  }
}

uint64_t ENGINE_get_pkey_meth_engine(int a1)
{
  return engine_table_select(&pkey_meth_table, a1);
}

uint64_t ENGINE_get_pkey_meth(uint64_t a1)
{
  uint64_t v3 = 0;
  uint64_t v1 = *(unsigned int (**)(void))(a1 + 96);
  if (v1 && v1()) {
    return v3;
  }
  ERR_put_error(38, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/tb_pkmeth.c", 134);
  return 0;
}

uint64_t ENGINE_get_pkey_meths(uint64_t a1)
{
  return *(void *)(a1 + 96);
}

uint64_t ENGINE_set_pkey_meths(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 96) = a2;
  return 1;
}

void engine_pkey_meths_free(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(a1 + 96);
  if (v1)
  {
    int v6 = 0;
    int v3 = v1();
    if (v3 >= 1)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 4 * v3;
      do
      {
        if ((*(unsigned int (**)(uint64_t, void **, void, void))(a1 + 96))(a1, &v6, 0, *v4)) {
          EVP_PKEY_meth_free(v6);
        }
        ++v4;
      }
      while ((unsigned int *)v5 != v4);
    }
  }
}

int RSA_padding_add_none(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl)
{
  if (fl <= tlen)
  {
    if (fl >= tlen)
    {
      memcpy(to, f, fl);
      return 1;
    }
    int v4 = 122;
    int v5 = 76;
  }
  else
  {
    int v4 = 110;
    int v5 = 71;
  }
  ERR_put_error(4, 4095, v4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_none.c", v5);
  return 0;
}

int RSA_padding_check_none(unsigned __int8 *to, int tlen, const unsigned __int8 *f, int fl, int rsa_len)
{
  if (tlen >= fl)
  {
    int v5 = tlen;
    bzero(to, tlen - fl);
    memcpy(&to[v5 - fl], f, fl);
  }
  else
  {
    ERR_put_error(4, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_none.c", 89);
    return -1;
  }
  return v5;
}

BN_CTX *BN_CTX_new(void)
{
  return (BN_CTX *)malloc_type_calloc(1uLL, 0x30uLL, 0x1090040EFEC1FD7uLL);
}

void BN_CTX_free(BN_CTX *c)
{
  if (c)
  {
    if (*((void *)c + 4))
    {
      unint64_t v2 = 0;
      do
      {
        BN_free(*(BIGNUM **)(*(void *)c + 8 * v2));
        *(void *)(*(void *)c + 8 * v2++) = 0;
      }
      while (v2 < *((void *)c + 4));
    }
    free(*(void **)c);
    free(*((void **)c + 1));
    freezero(c, 0x30uLL);
  }
}

void BN_CTX_start(BN_CTX *ctx)
{
  __int16 v1 = (*((unsigned char *)ctx + 16))++ + 1;
  if ((v1 & 0x100) != 0)
  {
    ERR_put_error(3, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_ctx.c", 99);
    *((_DWORD *)ctx + 1RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 1;
  }
}

BIGNUM *__cdecl BN_CTX_get(BN_CTX *ctx)
{
  if (!*((_DWORD *)ctx + 10))
  {
    if (!*((unsigned char *)ctx + 16))
    {
      int v5 = 66;
      int v6 = 114;
LABEL_18:
      ERR_put_error(3, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_ctx.c", v6);
      __int16 v1 = 0;
      goto LABEL_19;
    }
    unint64_t v3 = *((void *)ctx + 3);
    if (v3 != *((void *)ctx + 4))
    {
LABEL_13:
      __int16 v1 = *(BIGNUM **)(*(void *)ctx + 8 * v3);
      if (v1)
      {
LABEL_16:
        *(unsigned char *)(*((void *)ctx + 1) + v3) = *((unsigned char *)ctx + 16);
        ++*((void *)ctx + 3);
        BN_zero((uint64_t)v1);
        return v1;
      }
      int v9 = BN_new();
      __int16 v1 = v9;
      if (v9)
      {
        unint64_t v3 = *((void *)ctx + 3);
        *(void *)(*(void *)ctx + 8 * v3) = v9;
        goto LABEL_16;
      }
      ERR_put_error(3, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/bn/bn_ctx.c", 129);
LABEL_19:
      *((_DWORD *)ctx + 1RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 1;
      return v1;
    }
    if (v3)
    {
      if (__CFADD__(v3, v3))
      {
LABEL_17:
        int v5 = 109;
        int v6 = 121;
        goto LABEL_18;
      }
      size_t v4 = 2 * v3;
    }
    else
    {
      size_t v4 = 8;
    }
    int v7 = recallocarray(*(char **)ctx, v3, v4, 8uLL);
    if (v7)
    {
      *(void *)EVP_MD_CTX ctx = v7;
      int v8 = reallocarray(*((void **)ctx + 1), v4, 1uLL);
      if (v8)
      {
        *((void *)ctx + md4_block_data_order((unint64_t)c, b, 1) = v8;
        *((void *)ctx + 4) = v4;
        unint64_t v3 = *((void *)ctx + 3);
        goto LABEL_13;
      }
    }
    goto LABEL_17;
  }
  return 0;
}

void BN_CTX_end(BN_CTX *ctx)
{
  if (ctx)
  {
    if (!*((_DWORD *)ctx + 10))
    {
      LOBYTE(v2) = *((unsigned char *)ctx + 16);
      if ((_BYTE)v2)
      {
        uint64_t v3 = *((void *)ctx + 3);
        if (v3)
        {
          while (1)
          {
            uint64_t v4 = v3 - 1;
            int v2 = *((unsigned __int8 *)ctx + 16);
            if (*(unsigned __int8 *)(*((void *)ctx + 1) + v4) != v2) {
              break;
            }
            BN_zero(*(void *)(*(void *)ctx + 8 * v4));
            *(unsigned char *)(*((void *)ctx + 3) + *((void *)ctx + 1) - md4_block_data_order((unint64_t)c, b, 1) = 0;
            uint64_t v5 = *((void *)ctx + 3);
            uint64_t v3 = v5 - 1;
            *((void *)ctx + 3) = v5 - 1;
            if (v5 == 1)
            {
              LOBYTE(v2) = *((unsigned char *)ctx + 16);
              break;
            }
          }
        }
        *((unsigned char *)ctx + ++*(_DWORD *)(*(void *)(result + 8) + 16) = v2 - 1;
      }
    }
  }
}

void ERR_load_CRYPTO_strings(void)
{
  if (!ERR_func_error_string(CRYPTO_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&CRYPTO_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&CRYPTO_str_reasons);
  }
}

uint64_t GOSTR341194_Init(void *a1, int a2)
{
  bzero(a1, 0x1094uLL);
  return Gost2814789_set_sbox((uint64_t)a1 + 44, a2);
}

uint64_t GOSTR341194_Update(uint64_t a1, char *__src, size_t __n)
{
  if (__n)
  {
    size_t v3 = __n;
    uint64_t v4 = __src;
    *(void *)a1 += 8 * __n;
    uint64_t v6 = *(unsigned int *)(a1 + 40);
    if (v6)
    {
      int v7 = (_OWORD *)(a1 + 8);
      int v8 = (void *)(a1 + 8 + v6);
      if (__n <= 0x1F && v6 + __n < 0x20)
      {
        memcpy(v8, __src, __n);
        *(_DWORD *)(a1 + 40) += v3;
        return 1;
      }
      uint64_t v9 = 32 - v6;
      memcpy(v8, __src, 32 - v6);
      GOSTR341194_block_data_order(a1, a1 + 8, 1);
      v4 += v9;
      v3 -= v9;
      *(_DWORD *)(a1 + 4RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0;
      *int v7 = 0u;
      *(_OWORD *)(a1 + 24) = 0u;
    }
    if (v3 >= 0x20)
    {
      GOSTR341194_block_data_order(a1, (uint64_t)v4, v3 >> 5);
      v4 += v3 & 0xFFFFFFFFFFFFFFE0;
      v3 &= 0x1Fu;
    }
    if (v3)
    {
      *(_DWORD *)(a1 + 4RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = v3;
      memcpy((void *)(a1 + 8), v4, v3);
    }
  }
  return 1;
}

void GOSTR341194_block_data_order(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v6 = 0;
    int v7 = (int *)(a1 + 4180);
    uint64_t v8 = a1 + 4212;
    do
    {
      hash_step(a1, v7, a2);
      uint64_t v9 = 0;
      unsigned int v10 = 0;
      do
      {
        unsigned int v11 = v10 + *(unsigned __int8 *)(v8 + v9) + *(unsigned __int8 *)(a2 + v9);
        *(unsigned char *)(v8 + v9) = v11;
        unsigned int v10 = v11 >> 8;
        ++v9;
      }
      while (v9 != 32);
      a2 += 32;
      ++v6;
    }
    while (v6 != a3);
  }
}

void GOSTR341194_Transform(uint64_t a1, uint64_t a2)
{
}

uint64_t GOSTR341194_Final(_OWORD *a1, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(unsigned int *)(a2 + 40);
  if (v4)
  {
    uint64_t v5 = a2 + 8;
    bzero((void *)(a2 + 8 + v4), (32 - v4));
    hash_step(a2, (int *)(a2 + 4180), a2 + 8);
    uint64_t v6 = 0;
    unsigned int v7 = 0;
    uint64_t v8 = a2 + 4212;
    do
    {
      unsigned int v9 = v7 + *(unsigned __int8 *)(v8 + v6) + *(unsigned __int8 *)(v5 + v6);
      *(unsigned char *)(v8 + v6) = v9;
      unsigned int v7 = v9 >> 8;
      ++v6;
    }
    while (v6 != 32);
  }
  int v10 = *(_DWORD *)(a2 + 4);
  v13[0] = *(_DWORD *)a2;
  v13[1] = v10;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v14 = 0;
  hash_step(a2, (int *)(a2 + 4180), (uint64_t)v13);
  hash_step(a2, (int *)(a2 + 4180), a2 + 4212);
  long long v11 = *(_OWORD *)(a2 + 4196);
  *a1 = *(_OWORD *)(a2 + 4180);
  a1[1] = v11;
  return 1;
}

double hash_step(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t v5 = 0;
  uint64_t v54 = *MEMORY[0x263EF8340];
  do
  {
    *(int8x16_t *)&v40[v5 * 4] = veorq_s8(*(int8x16_t *)(a3 + v5 * 4), *(int8x16_t *)&a2[v5]);
    v5 += 4;
  }
  while (v5 != 8);
  uint64_t v6 = 0;
  unsigned int v7 = v40;
  do
  {
    uint64_t v8 = 0;
    unsigned int v9 = v7;
    do
    {
      char v10 = *v9++;
      v36[v6 + v8] = v10;
      v8 += 4;
    }
    while (v8 != 32);
    ++v6;
    v7 += 8;
  }
  while (v6 != 4);
  long long v11 = (int *)(a1 + 44);
  Gost2814789_set_key(a1 + 44, (uint64_t)v36, 256);
  Gost2814789_encrypt(a2, (int *)&v37, v11);
  circle_xor8((uint64_t)a2, &v41);
  circle_xor8(a3, v39);
  circle_xor8((uint64_t)v39, v39);
  for (uint64_t i = 0; i != 4; i += 2)
    *(int8x16_t *)&v40[i * 8] = veorq_s8(*(int8x16_t *)v39[i].i8, *(int8x16_t *)&v41.i8[i * 8]);
  uint64_t v13 = 0;
  uint64_t v14 = v40;
  do
  {
    uint64_t v15 = 0;
    uint64_t v16 = v14;
    do
    {
      char v17 = *v16++;
      v36[v13 + v15] = v17;
      v15 += 4;
    }
    while (v15 != 32);
    ++v13;
    v14 += 8;
  }
  while (v13 != 4);
  Gost2814789_set_key((uint64_t)v11, (uint64_t)v36, 256);
  Gost2814789_encrypt(a2 + 2, (int *)&v37 + 2, v11);
  circle_xor8((uint64_t)&v41, &v41);
  char v53 = ~v53;
  char v52 = ~v52;
  char v51 = ~v51;
  char v50 = ~v50;
  char v49 = ~v49;
  char v48 = ~v48;
  char v47 = ~v47;
  char v46 = ~v46;
  char v45 = ~v45;
  char v44 = ~v44;
  char v43 = ~v43;
  char v42 = ~v42;
  v41.i8[7] = ~v41.i8[7];
  v41.i8[5] = ~v41.i8[5];
  v41.i8[3] = ~v41.i8[3];
  v41.i8[1] = ~v41.i8[1];
  circle_xor8((uint64_t)v39, v39);
  circle_xor8((uint64_t)v39, v39);
  for (uint64_t j = 0; j != 4; j += 2)
    *(int8x16_t *)&v40[j * 8] = veorq_s8(*(int8x16_t *)v39[j].i8, *(int8x16_t *)&v41.i8[j * 8]);
  uint64_t v19 = 0;
  int v20 = v40;
  do
  {
    uint64_t v21 = 0;
    int v22 = v20;
    do
    {
      char v23 = *v22++;
      v36[v19 + v21] = v23;
      v21 += 4;
    }
    while (v21 != 32);
    ++v19;
    v20 += 8;
  }
  while (v19 != 4);
  Gost2814789_set_key((uint64_t)v11, (uint64_t)v36, 256);
  Gost2814789_encrypt(a2 + 4, (int *)&v38, v11);
  circle_xor8((uint64_t)&v41, &v41);
  circle_xor8((uint64_t)v39, v39);
  circle_xor8((uint64_t)v39, v39);
  for (uint64_t k = 0; k != 4; k += 2)
    *(int8x16_t *)&v40[k * 8] = veorq_s8(*(int8x16_t *)v39[k].i8, *(int8x16_t *)&v41.i8[k * 8]);
  uint64_t v25 = 0;
  unint64_t v26 = v40;
  do
  {
    uint64_t v27 = 0;
    int v28 = v26;
    do
    {
      char v29 = *v28++;
      v36[v25 + v27] = v29;
      v27 += 4;
    }
    while (v27 != 32);
    ++v25;
    v26 += 8;
  }
  while (v25 != 4);
  Gost2814789_set_key((uint64_t)v11, (uint64_t)v36, 256);
  Gost2814789_encrypt(a2 + 6, (int *)&v38 + 2, v11);
  int v30 = 12;
  do
  {
    transform_3((uint64_t)&v37);
    --v30;
  }
  while (v30);
  for (uint64_t m = 0; m != 32; m += 16)
    *(long long *)((char *)&v37 + m) = (__int128)veorq_s8(*(int8x16_t *)(a3 + m), *(int8x16_t *)((char *)&v37 + m));
  transform_3((uint64_t)&v37);
  for (uint64_t n = 0; n != 8; n += 4)
    *(long long *)((char *)&v37 + n * 4) = (__int128)veorq_s8(*(int8x16_t *)&a2[n], *(int8x16_t *)((char *)&v37 + n * 4));
  int v33 = 61;
  do
  {
    transform_3((uint64_t)&v37);
    --v33;
  }
  while (v33);
  double result = *(double *)&v37;
  long long v35 = v38;
  *(_OWORD *)a2 = v37;
  *((_OWORD *)a2 + md4_block_data_order((unint64_t)c, b, 1) = v35;
  return result;
}

uint64_t GOSTR341194(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x270FA5388](a1);
  int v3 = v2;
  uint64_t v5 = v4;
  size_t v7 = v6;
  uint64_t v8 = (char *)v1;
  v11[525] = *MEMORY[0x263EF8340];
  bzero(v10, 0x1094uLL);
  if (Gost2814789_set_sbox((uint64_t)v11, v3))
  {
    if (!v5) {
      uint64_t v5 = &GOSTR341194_m;
    }
    GOSTR341194_Update((uint64_t)v10, v8, v7);
    GOSTR341194_Final(v5, (uint64_t)v10);
    explicit_bzero(v10, 0x1094uLL);
  }
  return 0;
}

int8x8_t circle_xor8(uint64_t a1, int8x8_t *a2)
{
  int8x8_t v2 = *(int8x8_t *)a1;
  int8x8_t v3 = *(int8x8_t *)(a1 + 24);
  *(_OWORD *)a2->i8 = *(_OWORD *)(a1 + 8);
  a2[2] = v3;
  int8x8_t result = veor_s8(*a2, v2);
  a2[3] = result;
  return result;
}

__n128 transform_3(uint64_t a1)
{
  char v1 = *(unsigned char *)(a1 + 2) ^ *(unsigned char *)a1 ^ *(unsigned char *)(a1 + 4) ^ *(unsigned char *)(a1 + 6) ^ *(unsigned char *)(a1 + 24) ^ *(unsigned char *)(a1 + 30);
  char v2 = *(unsigned char *)(a1 + 3) ^ *(unsigned char *)(a1 + 1) ^ *(unsigned char *)(a1 + 5) ^ *(unsigned char *)(a1 + 7) ^ *(unsigned char *)(a1 + 25) ^ *(unsigned char *)(a1 + 31);
  __n128 result = *(__n128 *)(a1 + 2);
  *(void *)(a1 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = *(void *)(a1 + 18);
  *(__n128 *)a1 = result;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 26);
  *(_WORD *)(a1 + 28) = *(_WORD *)(a1 + 30);
  *(unsigned char *)(a1 + 3RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = v1;
  *(unsigned char *)(a1 + 3md4_block_data_order((unint64_t)c, b, 1) = v2;
  return result;
}

uint64_t OBJ_find_sigid_algs(int a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v8 = 0;
  *(_DWORD *)unsigned int data = a1;
  if (sig_app
    && (int v5 = sk_find((STACK *)sig_app, data), (v5 & 0x80000000) == 0)
    && (uint64_t result = (uint64_t)sk_value((const STACK *)sig_app, v5)) != 0
    || (uint64_t result = (uint64_t)OBJ_bsearch_(data, "\a", 42, 12, (int (__cdecl *)(const void *, const void *))sig_cmp_BSEARCH_CMP_FN)) != 0)
  {
    if (a2) {
      *a2 = *(_DWORD *)(result + 4);
    }
    if (a3) {
      *a3 = *(_DWORD *)(result + 8);
    }
    return 1;
  }
  return result;
}

uint64_t OBJ_find_sigid_by_algs(_DWORD *a1, int a2, int a3)
{
  *(void *)uint64_t key = data;
  *(_DWORD *)unsigned int data = 0;
  int v8 = a2;
  int v9 = a3;
  if (!sigx_app || (int v4 = sk_find((STACK *)sigx_app, data), v4 < 0))
  {
    uint64_t result = (uint64_t)OBJ_bsearch_(key, (const char *)&sigoid_srt_xref, 42, 8, (int (__cdecl *)(const void *, const void *))sigx_cmp_BSEARCH_CMP_FN);
    if (!result) {
      return result;
    }
  }
  else
  {
    *(void *)uint64_t key = sk_value((const STACK *)sigx_app, v4);
    uint64_t result = (uint64_t)key;
  }
  if (a1) {
    *a1 = **(_DWORD **)result;
  }
  return 1;
}

uint64_t OBJ_add_sigid(int a1, int a2, int a3)
{
  if (sig_app
    || (uint64_t result = (uint64_t)sk_new((int (__cdecl *)(const char *const *, const char *const *))sig_sk_cmp),
        (sig_apunsigned int p = result) != 0))
  {
    if (sigx_app
      || (uint64_t result = (uint64_t)sk_new((int (__cdecl *)(const char *const *, const char *const *))sigx_cmp),
          (sigx_apunsigned int p = result) != 0))
    {
      uint64_t result = (uint64_t)reallocarray(0, 3uLL, 4uLL);
      if (result)
      {
        size_t v7 = (char *)result;
        *(_DWORD *)uint64_t result = a1;
        *(_DWORD *)(result + 4) = a2;
        *(_DWORD *)(result + 8) = a3;
        if (sk_push((STACK *)sig_app, (char *)result))
        {
          uint64_t result = sk_push((STACK *)sigx_app, v7);
          if (result)
          {
            sk_sort((STACK *)sig_app);
            sk_sort((STACK *)sigx_app);
            return 1;
          }
        }
        else
        {
          free(v7);
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t sig_sk_cmp(_DWORD **a1, _DWORD **a2)
{
  return (**a1 - **a2);
}

uint64_t sigx_cmp(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  int v3 = *(_DWORD *)(*a1 + 4);
  int v4 = *(_DWORD *)(*(void *)a2 + 4);
  uint64_t result = (v3 - v4);
  if (v3 == v4) {
    return (*(_DWORD *)(v2 + 8) - *(_DWORD *)(*(void *)a2 + 8));
  }
  return result;
}

void OBJ_sigid_free()
{
  if (sig_app)
  {
    sk_pop_free((STACK *)sig_app, sid_free);
    sig_apunsigned int p = 0;
  }
  if (sigx_app)
  {
    sk_free((STACK *)sigx_app);
    sigx_apunsigned int p = 0;
  }
}

uint64_t sig_cmp_BSEARCH_CMP_FN(_DWORD *a1, _DWORD *a2)
{
  return (*a1 - *a2);
}

uint64_t sigx_cmp_BSEARCH_CMP_FN(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  int v3 = *(_DWORD *)(*a1 + 4);
  int v4 = *(_DWORD *)(*(void *)a2 + 4);
  uint64_t result = (v3 - v4);
  if (v3 == v4) {
    return (*(_DWORD *)(v2 + 8) - *(_DWORD *)(*(void *)a2 + 8));
  }
  return result;
}

void ENGINE_unregister_ciphers(ENGINE *e)
{
}

int ENGINE_register_ciphers(ENGINE *e)
{
  char v1 = (uint64_t (*)(void))*((void *)e + 10);
  if (v1 && (int v3 = v1(), v3 > 0)) {
    return engine_table_register(&cipher_table, (uint64_t)engine_unregister_all_ciphers, (char *)e, 0, v3, 0);
  }
  else {
    return 1;
  }
}

void engine_unregister_all_ciphers()
{
}

void ENGINE_register_all_ciphers(void)
{
  first = ENGINE_get_first();
  if (first)
  {
    next = first;
    do
    {
      ENGINE_register_ciphers(next);
      next = ENGINE_get_next(next);
    }
    while (next);
  }
}

int ENGINE_set_default_ciphers(ENGINE *e)
{
  char v1 = (uint64_t (*)(void))*((void *)e + 10);
  if (v1 && (int v3 = v1(), v3 > 0)) {
    return engine_table_register(&cipher_table, (uint64_t)engine_unregister_all_ciphers, (char *)e, 0, v3, 1);
  }
  else {
    return 1;
  }
}

ENGINE *__cdecl ENGINE_get_cipher_engine(int nid)
{
  return (ENGINE *)engine_table_select(&cipher_table, nid);
}

const EVP_CIPHER *__cdecl ENGINE_get_cipher(ENGINE *e, int nid)
{
  int v4 = 0;
  uint64_t v2 = (unsigned int (*)(void))*((void *)e + 10);
  if (v2 && v2()) {
    return v4;
  }
  ERR_put_error(38, 4095, 146, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/tb_cipher.c", 133);
  return 0;
}

ENGINE_CIPHERS_PTR ENGINE_get_ciphers(const ENGINE *e)
{
  return (ENGINE_CIPHERS_PTR)*((void *)e + 10);
}

int ENGINE_set_ciphers(ENGINE *e, ENGINE_CIPHERS_PTR f)
{
  *((void *)e + 1RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = f;
  return 1;
}

int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
{
  set_asn1_parameterunsigned int s = (uint64_t (*)(void))c->cipher->set_asn1_parameters;
  if (set_asn1_parameters) {
    return set_asn1_parameters();
  }
  if ((c->cipher->flags & 0x1000) != 0) {
    return EVP_CIPHER_set_asn1_iv(c, type);
  }
  return -1;
}

int EVP_CIPHER_set_asn1_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
{
  if (!type) {
    return 0;
  }
  unsigned int iv_len = c->cipher->iv_len;
  if (iv_len >= 0x11)
  {
    ERR_put_error(6, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_lib.c", 127);
    return 0;
  }
  return ASN1_TYPE_set_octetstring(type, c->oiv, iv_len);
}

int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
{
  get_asn1_parameterunsigned int s = (uint64_t (*)(void))c->cipher->get_asn1_parameters;
  if (get_asn1_parameters) {
    return get_asn1_parameters();
  }
  if ((c->cipher->flags & 0x1000) != 0) {
    return EVP_CIPHER_get_asn1_iv(c, type);
  }
  return -1;
}

int EVP_CIPHER_get_asn1_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type)
{
  if (!type) {
    goto LABEL_4;
  }
  size_t iv_len = c->cipher->iv_len;
  if (iv_len >= 0x11)
  {
    ERR_put_error(6, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_lib.c", 106);
LABEL_4:
    LODWORD(iv_SHA512_Update(c, data, len) = 0;
    return iv_len;
  }
  if (ASN1_TYPE_get_octetstring(type, c->oiv, iv_len) == iv_len)
  {
    if (iv_len) {
      memcpy(c->iv, c->oiv, iv_len);
    }
  }
  else
  {
    LODWORD(iv_SHA512_Update(c, data, len) = -1;
  }
  return iv_len;
}

int EVP_CIPHER_CTX_iv_length(const EVP_CIPHER_CTX *ctx)
{
  return ctx->cipher->iv_len;
}

int EVP_CIPHER_type(const EVP_CIPHER *ctx)
{
  niunsigned int d = ctx->nid;
  if (ctx->nid <= 424)
  {
    int result = 37;
    if (nid > 96)
    {
      if (nid > 165)
      {
        if (nid == 166) {
          return result;
        }
        if (nid == 421) {
          return 421;
        }
        goto LABEL_23;
      }
      if (nid != 97)
      {
        if (nid == 98) {
          return result;
        }
        goto LABEL_23;
      }
    }
    else
    {
      if (nid > 36)
      {
        if (nid == 37) {
          return result;
        }
        if (nid != 61) {
          goto LABEL_23;
        }
        return 30;
      }
      if (nid != 5)
      {
        if (nid != 30)
        {
LABEL_23:
          int v3 = OBJ_nid2obj(nid);
          if (!v3 || !v3->data) {
            niunsigned int d = 0;
          }
          ASN1_OBJECT_free(v3);
          return nid;
        }
        return 30;
      }
    }
    return 5;
  }
  switch(nid)
  {
    case 650:
    case 653:
      return 421;
    case 651:
    case 654:
      goto LABEL_22;
    case 652:
    case 655:
      goto LABEL_21;
    case 656:
    case 657:
    case 658:
    case 659:
      return 30;
    default:
      if (nid == 425)
      {
LABEL_22:
        int result = 425;
      }
      else
      {
        if (nid != 429) {
          goto LABEL_23;
        }
LABEL_21:
        int result = 429;
      }
      break;
  }
  return result;
}

int EVP_CIPHER_nid(const EVP_CIPHER *cipher)
{
  return cipher->nid;
}

int EVP_CIPHER_block_size(const EVP_CIPHER *cipher)
{
  return cipher->block_size;
}

int EVP_CIPHER_CTX_block_size(const EVP_CIPHER_CTX *ctx)
{
  return ctx->cipher->block_size;
}

int EVP_Cipher(EVP_CIPHER_CTX *c, unsigned __int8 *out, const unsigned __int8 *in, unsigned int inl)
{
  return ((uint64_t (*)(EVP_CIPHER_CTX *, unsigned __int8 *, const unsigned __int8 *, void))c->cipher->do_cipher)(c, out, in, inl);
}

const EVP_CIPHER *__cdecl EVP_CIPHER_CTX_cipher(const EVP_CIPHER_CTX *ctx)
{
  return ctx->cipher;
}

uint64_t EVP_CIPHER_CTX_encrypting(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

unint64_t EVP_CIPHER_flags(const EVP_CIPHER *cipher)
{
  return cipher->flags;
}

unint64_t EVP_CIPHER_CTX_flags(const EVP_CIPHER_CTX *ctx)
{
  return ctx->cipher->flags;
}

void *__cdecl EVP_CIPHER_CTX_get_app_data(const EVP_CIPHER_CTX *ctx)
{
  return ctx->app_data;
}

void EVP_CIPHER_CTX_set_app_data(EVP_CIPHER_CTX *ctx, void *data)
{
  ctx->app_unsigned int data = data;
}

uint64_t EVP_CIPHER_CTX_get_cipher_data(uint64_t a1)
{
  return *(void *)(a1 + 120);
}

uint64_t EVP_CIPHER_CTX_set_cipher_data(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 120);
  *(void *)(a1 + 12RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = a2;
  return v2;
}

int EVP_CIPHER_iv_length(const EVP_CIPHER *cipher)
{
  return cipher->iv_len;
}

uint64_t EVP_CIPHER_CTX_buf_noconst(uint64_t a1)
{
  return a1 + 56;
}

int EVP_CIPHER_key_length(const EVP_CIPHER *cipher)
{
  return cipher->key_len;
}

int EVP_CIPHER_CTX_key_length(const EVP_CIPHER_CTX *ctx)
{
  return ctx->key_len;
}

int EVP_CIPHER_CTX_nid(const EVP_CIPHER_CTX *ctx)
{
  return ctx->cipher->nid;
}

uint64_t EVP_CIPHER_CTX_get_iv(uint64_t result, void *__dst, size_t a3)
{
  if (result)
  {
    uint64_t v3 = result;
    int result = 0;
    if (a3 <= 0x10 && *(_DWORD *)(*(void *)v3 + 12) == a3)
    {
      if (!a3) {
        return 1;
      }
      if (__dst)
      {
        memcpy(__dst, (const void *)(v3 + 40), a3);
        return 1;
      }
      return 0;
    }
  }
  return result;
}

uint64_t EVP_CIPHER_CTX_set_iv(uint64_t result, const void *a2, size_t a3)
{
  if (result)
  {
    uint64_t v3 = result;
    int result = 0;
    if (a3 <= 0x10 && *(_DWORD *)(*(void *)v3 + 12) == a3)
    {
      if (!a3) {
        return 1;
      }
      if (a2)
      {
        memcpy((void *)(v3 + 40), a2, a3);
        return 1;
      }
      return 0;
    }
  }
  return result;
}

int EVP_MD_block_size(const EVP_MD *md)
{
  return (int)md->sign;
}

int EVP_MD_type(const EVP_MD *md)
{
  return md->type;
}

int EVP_MD_pkey_type(const EVP_MD *md)
{
  return md->pkey_type;
}

int EVP_MD_size(const EVP_MD *md)
{
  if (md) {
    return md->md_size;
  }
  ERR_put_error(6, 4095, 159, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/evp_lib.c", 362);
  return -1;
}

uint64_t EVP_MD_flags(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

_DWORD *EVP_MD_meth_new(int a1, int a2)
{
  int result = malloc_type_calloc(1uLL, 0x50uLL, 0x1080040DE93153CuLL);
  if (result)
  {
    *int result = a1;
    result[1] = a2;
  }
  return result;
}

_OWORD *EVP_MD_meth_dup(uint64_t *a1)
{
  uint64_t v2 = *a1;
  int result = malloc_type_calloc(1uLL, 0x50uLL, 0x1080040DE93153CuLL);
  if (result)
  {
    *(void *)int result = v2;
    *int result = *(_OWORD *)a1;
    long long v4 = *((_OWORD *)a1 + 1);
    long long v5 = *((_OWORD *)a1 + 2);
    long long v6 = *((_OWORD *)a1 + 4);
    result[3] = *((_OWORD *)a1 + 3);
    result[4] = v6;
    result[1] = v4;
    result[2] = v5;
  }
  return result;
}

void *EVP_MD_meth_free(void *a1)
{
  return freezero(a1, 0x50uLL);
}

uint64_t EVP_MD_meth_set_input_blocksize(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 64) = a2;
  return 1;
}

uint64_t EVP_MD_meth_set_result_size(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 8) = a2;
  return 1;
}

uint64_t EVP_MD_meth_set_app_datasize(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 68) = a2;
  return 1;
}

uint64_t EVP_MD_meth_set_flags(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = a2;
  return 1;
}

uint64_t EVP_MD_meth_set_init(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 24) = a2;
  return 1;
}

uint64_t EVP_MD_meth_set_update(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 32) = a2;
  return 1;
}

uint64_t EVP_MD_meth_set_final(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 4RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = a2;
  return 1;
}

uint64_t EVP_MD_meth_set_copy(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 48) = a2;
  return 1;
}

uint64_t EVP_MD_meth_set_cleanup(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 56) = a2;
  return 1;
}

uint64_t EVP_MD_meth_set_ctrl(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = a2;
  return 1;
}

const EVP_MD *__cdecl EVP_MD_CTX_md(const EVP_MD *ctx)
{
  if (ctx) {
    return *(const EVP_MD **)&ctx->type;
  }
  return ctx;
}

uint64_t EVP_MD_CTX_md_data(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t EVP_MD_CTX_pkey_ctx(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

void EVP_MD_CTX_set_pkey_ctx(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  if ((v4 & 0x400) != 0) {
    *(void *)(a1 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = v4 & 0xFFFFFFFFFFFFFBFFLL;
  }
  else {
    EVP_PKEY_CTX_free(*(EVP_PKEY ***)(a1 + 32));
  }
  *(void *)(a1 + 32) = a2;
  if (a2) {
    *(void *)(a1 + 16) |= 0x400uLL;
  }
}

int EVP_MD_CTX_test_flags(const EVP_MD_CTX *ctx, int flags)
{
  return ctx->flags & flags;
}

void EVP_MD_CTX_clear_flags(EVP_MD_CTX *ctx, int flags)
{
  ctx->flags &= ~flags;
}

void EVP_MD_CTX_set_flags(EVP_MD_CTX *ctx, int flags)
{
  ctx->flags |= flags;
}

void EVP_CIPHER_CTX_set_flags(EVP_CIPHER_CTX *ctx, int flags)
{
  ctx->flags |= flags;
}

void EVP_CIPHER_CTX_clear_flags(EVP_CIPHER_CTX *ctx, int flags)
{
  ctx->flags &= ~flags;
}

int EVP_CIPHER_CTX_test_flags(const EVP_CIPHER_CTX *ctx, int flags)
{
  return ctx->flags & flags;
}

unsigned char *i2s_ASN1_IA5STRING(uint64_t a1, const void **a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v3 = *(int *)a2;
  if (!v3) {
    return 0;
  }
  uint64_t v4 = malloc_type_malloc(v3 + 1, 0x20A82302uLL);
  long long v5 = v4;
  if (v4)
  {
    memcpy(v4, a2[1], *(int *)a2);
    v5[*(int *)a2] = 0;
  }
  else
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_ia5.c", 210);
  }
  return v5;
}

ASN1_STRING *s2i_ASN1_IA5STRING(uint64_t a1, uint64_t a2, const char *a3)
{
  if (!a3)
  {
    int v7 = 107;
    int v8 = 223;
    goto LABEL_7;
  }
  uint64_t v4 = ASN1_IA5STRING_new();
  if (!v4)
  {
LABEL_5:
    int v7 = 65;
    int v8 = 236;
LABEL_7:
    ERR_put_error(34, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_ia5.c", v8);
    return 0;
  }
  long long v5 = v4;
  int v6 = strlen(a3);
  if (!ASN1_STRING_set(v5, a3, v6))
  {
    ASN1_IA5STRING_free(v5);
    goto LABEL_5;
  }
  return v5;
}

uint64_t Camellia_Ekeygen(int a1, unsigned __int8 *a2, unsigned int *a3)
{
  int v3 = (*a2 << 24) | (a2[1] << 16);
  unsigned int v4 = v3 | (bswap32(*((unsigned __int16 *)a2 + 1)) >> 16);
  *a3 = v4;
  int v5 = (a2[4] << 24) | (a2[5] << 16);
  unsigned int v6 = v5 | (bswap32(*((unsigned __int16 *)a2 + 3)) >> 16);
  a3[1] = v6;
  int v7 = (a2[8] << 24) | (a2[9] << 16);
  unsigned int v8 = v7 | (bswap32(*((unsigned __int16 *)a2 + 5)) >> 16);
  a3[2] = v8;
  int v9 = (a2[12] << 24) | (a2[13] << 16);
  unsigned int v10 = v9 | (bswap32(*((unsigned __int16 *)a2 + 7)) >> 16);
  a3[3] = v10;
  if (a1 == 128)
  {
    int v11 = v10;
    int v12 = v8;
    int v13 = v6;
    int v14 = v4;
  }
  else
  {
    unsigned int v15 = bswap32(*((_DWORD *)a2 + 4));
    a3[8] = v15;
    unsigned int v16 = bswap32(*((_DWORD *)a2 + 5));
    a3[9] = v16;
    if (a1 == 192)
    {
      int v17 = ~v15;
      a3[10] = ~v15;
      int v18 = ~v16;
    }
    else
    {
      int v17 = bswap32(*((_DWORD *)a2 + 6));
      a3[10] = v17;
      int v18 = bswap32(*((_DWORD *)a2 + 7));
    }
    a3[11] = v18;
    int v14 = v15 ^ v4;
    int v13 = v16 ^ v6;
    int v12 = v17 ^ v8;
    int v11 = v18 ^ v10;
  }
  int v19 = Camellia_SBOX[((unsigned __int16)(v14 ^ 0x667F) >> 8) + 768] ^ Camellia_SBOX[(v14 ^ 0x7F) + 256] ^ Camellia_SBOX[((v14 ^ 0xA09E667F) >> 16) + 512] ^ Camellia_SBOX[(v14 ^ 0xA09E667F) >> 24];
  int v20 = __ROR4__(v19, 8);
  int v21 = Camellia_SBOX[((unsigned __int16)(v13 ^ 0x908B) >> 8) + 256] ^ Camellia_SBOX[v13 ^ 0x8B] ^ Camellia_SBOX[((v13 ^ 0x3BCC908Bu) >> 16) + 768] ^ Camellia_SBOX[((v13 ^ 0x3BCC908Bu) >> 24) + 512] ^ v19;
  int v22 = v21 ^ v12;
  int v23 = v11 ^ v20 ^ v21;
  int v24 = Camellia_SBOX[((unsigned __int16)(v21 ^ v12 ^ 0xE858) >> 8) + 768] ^ Camellia_SBOX[((v21 ^ v12) ^ 0x58) + 256] ^ Camellia_SBOX[((v21 ^ v12 ^ 0xB67AE858) >> 16) + 512] ^ Camellia_SBOX[(v21 ^ v12 ^ 0xB67AE858) >> 24];
  int v25 = Camellia_SBOX[((unsigned __int16)(v23 ^ 0x73B2) >> 8) + 256] ^ Camellia_SBOX[v23 ^ 0xB2] ^ Camellia_SBOX[((v23 ^ 0x4CAA73B2u) >> 16) + 768] ^ Camellia_SBOX[((v23 ^ 0x4CAA73B2u) >> 24) + 512] ^ v24;
  int v26 = v14 ^ v4 ^ v25;
  int v27 = v6 ^ __ROR4__(v24, 8) ^ v13 ^ v25;
  int v28 = v22 ^ v8;
  int v29 = Camellia_SBOX[((unsigned __int16)(v26 ^ 0x372F) >> 8) + 768] ^ Camellia_SBOX[(v26 ^ 0x2F) + 256] ^ Camellia_SBOX[((v26 ^ 0xC6EF372F) >> 16) + 512] ^ Camellia_SBOX[(v26 ^ 0xC6EF372F) >> 24];
  int v30 = Camellia_SBOX[((unsigned __int16)(v27 ^ 0x82BE) >> 8) + 256] ^ Camellia_SBOX[v27 ^ 0xBE] ^ Camellia_SBOX[((v27 ^ 0xE94F82BE) >> 16) + 768] ^ Camellia_SBOX[((v27 ^ 0xE94F82BE) >> 24) + 512] ^ v29;
  int v31 = v28 ^ v30;
  int v32 = __ROR4__(v29, 8);
  int v33 = v10 ^ v32 ^ v23 ^ v30;
  int v34 = Camellia_SBOX[((unsigned __int16)(v10 ^ v32 ^ v23 ^ v30 ^ 0x6F1C) >> 8) + 256] ^ Camellia_SBOX[(v10 ^ v32 ^ v23 ^ v30) ^ 0x1C];
  int v35 = Camellia_SBOX[((unsigned __int16)(v31 ^ 0x53A5) >> 8) + 768] ^ Camellia_SBOX[(v31 ^ 0xA5) + 256] ^ Camellia_SBOX[((v31 ^ 0x54FF53A5u) >> 16) + 512] ^ Camellia_SBOX[(v31 ^ 0x54FF53A5u) >> 24];
  int v36 = __ROR4__(v35, 8);
  int v37 = v34 ^ Camellia_SBOX[((v33 ^ 0xF1D36F1C) >> 16) + 768] ^ Camellia_SBOX[((v33 ^ 0xF1D36F1C) >> 24)
                                                                                             + 512] ^ v35;
  int v38 = v37 ^ v26;
  int v39 = v27 ^ v36 ^ v37;
  if (a1 == 128)
  {
    unsigned int v40 = __PAIR64__(v38, v39) >> 17;
    unsigned int v41 = __PAIR64__(v39, v31) >> 17;
    unsigned int v42 = __PAIR64__(v31, v33) >> 17;
    unsigned int v43 = __PAIR64__(v33, v38) >> 17;
    unsigned int v44 = __PAIR64__(v40, v41) >> 17;
    unsigned int v45 = __PAIR64__(v41, v42) >> 17;
    a3[4] = v38;
    a3[5] = v39;
    unsigned int v46 = __PAIR64__(v42, v43) >> 17;
    unsigned int v47 = __PAIR64__(v43, v40) >> 17;
    a3[6] = v31;
    a3[7] = v33;
    unsigned int v48 = __PAIR64__(__PAIR64__(v40, v41) >> 17, v45) >> 17;
    a3[12] = v40;
    a3[13] = v41;
    a3[14] = v42;
    a3[15] = v43;
    HIDWORD(v5RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = v48;
    LODWORD(v5RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = __PAIR64__(__PAIR64__(v41, v42) >> 17, v46) >> 17;
    unsigned int v49 = v50 >> 17;
    HIDWORD(v5RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = v50;
    LODWORD(v5RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = __PAIR64__(v46, v47) >> 17;
    unsigned int v51 = v50 >> 17;
    a3[16] = v44;
    a3[17] = v45;
    HIDWORD(v5RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = v50;
    LODWORD(v5RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = __PAIR64__(v47, v44) >> 17;
    unsigned int v52 = v50 >> 17;
    a3[18] = v46;
    a3[19] = v47;
    unsigned int v54 = __PAIR64__(v51, v52) >> 30;
    a3[24] = v48;
    a3[25] = __PAIR64__(v45, v46) >> 17;
    HIDWORD(v5RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = __PAIR64__(v50, v48) >> 17;
    unsigned int v53 = HIDWORD(v50);
    LODWORD(v5RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = v49;
    unsigned int v55 = v50 >> 30;
    unsigned int v56 = __PAIR64__(v49, v51) >> 30;
    a3[28] = v49;
    a3[29] = v51;
    HIDWORD(v5RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = v54;
    LODWORD(v5RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = __PAIR64__(v52, v53) >> 30;
    a3[30] = v52;
    a3[31] = v53;
    unsigned int v57 = __PAIR64__(v4, v5) >> 17;
    a3[40] = v54;
    a3[41] = v50;
    unsigned int v58 = __PAIR64__(v6, v7) >> 17;
    a3[42] = v55;
    a3[43] = v56;
    unsigned int v59 = __PAIR64__(v8, v9) >> 17;
    unsigned int v60 = __PAIR64__(v10, v3) >> 17;
    a3[48] = v50 >> 15;
    a3[49] = __PAIR64__(v50, v55) >> 15;
    unsigned int v61 = __PAIR64__(v57, v58) >> 2;
    unsigned int v62 = __PAIR64__(v58, v59) >> 2;
    a3[50] = __PAIR64__(v55, v56) >> 15;
    a3[51] = __PAIR64__(__PAIR64__(v49, v51) >> 30, v54) >> 15;
    unsigned int v63 = __PAIR64__(v59, v60) >> 2;
    unsigned int v64 = __PAIR64__(v60, v57) >> 2;
    a3[8] = v57;
    a3[9] = v58;
    unsigned int v65 = __PAIR64__(v61, v62) >> 17;
    a3[10] = v59;
    a3[11] = v60;
    unsigned int v66 = __PAIR64__(v63, v64) >> 17;
    unsigned int v67 = __PAIR64__(v64, v61) >> 17;
    a3[20] = v61;
    a3[21] = v62;
    unsigned int v68 = __PAIR64__(__PAIR64__(v61, v62) >> 17, __PAIR64__(v62, v63) >> 17) >> 15;
    unsigned int v69 = __PAIR64__(__PAIR64__(v62, v63) >> 17, v66) >> 15;
    a3[22] = v63;
    a3[23] = v64;
    unsigned int v70 = __PAIR64__(v66, v67) >> 15;
    unsigned int v71 = __PAIR64__(v67, v65) >> 15;
    a3[26] = v66;
    a3[27] = v67;
    unsigned int v72 = __PAIR64__(v68, v69) >> 15;
    unsigned int v73 = __PAIR64__(v69, v70) >> 15;
    a3[32] = v68;
    a3[33] = v69;
    unsigned int v74 = __PAIR64__(v70, v71) >> 15;
    unsigned int v75 = __PAIR64__(v71, v68) >> 15;
    a3[34] = v70;
    a3[35] = v71;
    unsigned int v76 = __PAIR64__(v72, v73) >> 15;
    uint64_t result = 3;
    unsigned int v78 = __PAIR64__(v73, v74) >> 15;
    a3[36] = v72;
    a3[37] = v73;
    a3[38] = v74;
    a3[39] = v75;
    unsigned int v79 = __PAIR64__(v74, v75) >> 15;
    uint64_t v80 = 47;
    uint64_t v81 = 46;
    uint64_t v82 = 45;
    uint64_t v83 = 44;
    unsigned int v84 = __PAIR64__(v75, v72) >> 15;
  }
  else
  {
    unsigned int v85 = a3[8];
    unsigned int v86 = a3[9];
    int v138 = v5;
    int v139 = v3;
    unsigned int v88 = a3[10];
    unsigned int v87 = a3[11];
    int v89 = Camellia_SBOX[((unsigned __int16)(v85 ^ v38 ^ 0x27FA) >> 8) + 768] ^ Camellia_SBOX[((v85 ^ v38) ^ 0xFA) + 256] ^ Camellia_SBOX[((v85 ^ v38 ^ 0x10E527FA) >> 16) + 512] ^ Camellia_SBOX[(v85 ^ v38 ^ 0x10E527FA) >> 24];
    int v90 = Camellia_SBOX[((unsigned __int16)(v86 ^ v39 ^ 0x2D1D) >> 8) + 256] ^ Camellia_SBOX[(v86 ^ v39) ^ 0x1D] ^ Camellia_SBOX[((v86 ^ v39 ^ 0xDE682D1D) >> 16) + 768] ^ Camellia_SBOX[((v86 ^ v39 ^ 0xDE682D1D) >> 24) + 512] ^ v89;
    int v91 = v88 ^ v31 ^ v90;
    int v92 = v33 ^ __ROR4__(v89, 8) ^ v87 ^ v90;
    int v93 = Camellia_SBOX[((unsigned __int16)(v91 ^ 0x88C2) >> 8) + 768] ^ Camellia_SBOX[(v91 ^ 0xC2) + 256] ^ Camellia_SBOX[((v91 ^ 0xB05688C2) >> 16) + 512] ^ Camellia_SBOX[(v91 ^ 0xB05688C2) >> 24];
    unint64_t v94 = __PAIR64__(v91, __ROR4__(v93, 8));
    int v95 = Camellia_SBOX[((unsigned __int16)(v92 ^ 0xC1FD) >> 8) + 256] ^ Camellia_SBOX[v92 ^ 0xFD] ^ Camellia_SBOX[((v92 ^ 0xB3E6C1FD) >> 16) + 768] ^ Camellia_SBOX[((v92 ^ 0xB3E6C1FD) >> 24) + 512] ^ v93;
    int v96 = v95 ^ v85 ^ v38;
    unsigned int v97 = v86 ^ v39 ^ v94 ^ v95;
    unsigned int v98 = __PAIR64__(v96, v97) >> 2;
    a3[4] = v96;
    a3[5] = v97;
    unsigned int v99 = __PAIR64__(v97, v91) >> 2;
    LODWORD(v94) = v92;
    unsigned int v100 = v94 >> 2;
    a3[6] = v91;
    a3[7] = v92;
    unsigned int v101 = __PAIR64__(v92, v96) >> 2;
    unsigned int v102 = __PAIR64__(v98, v99) >> 2;
    a3[20] = v98;
    a3[21] = v99;
    unsigned int v103 = __PAIR64__(v99, v100) >> 2;
    unsigned int v104 = __PAIR64__(v100, v101) >> 2;
    a3[22] = v100;
    a3[23] = v101;
    unsigned int v105 = __PAIR64__(v101, v98) >> 2;
    a3[40] = v102;
    a3[41] = v103;
    unint64_t v106 = __PAIR64__(v104, v105);
    unsigned int v107 = __PAIR64__(v105, v102) >> 13;
    a3[42] = v104;
    a3[43] = v105;
    unsigned int v108 = __PAIR64__(v102, v103) >> 13;
    a3[64] = __PAIR64__(v103, v104) >> 13;
    a3[65] = v106 >> 13;
    a3[66] = v107;
    unsigned int v109 = __PAIR64__(v85, v86) >> 17;
    a3[67] = v108;
    unsigned int v110 = __PAIR64__(v87, v85) >> 17;
    HIDWORD(v106) = v109;
    LODWORD(v106) = __PAIR64__(v86, v88) >> 17;
    unsigned int v111 = v106 >> 17;
    a3[8] = v109;
    a3[9] = v106;
    HIDWORD(v106) = v106;
    LODWORD(v106) = __PAIR64__(v88, v87) >> 17;
    unsigned int v112 = v106 >> 17;
    unsigned int v113 = __PAIR64__(v106, v110) >> 17;
    a3[10] = v106;
    a3[11] = v110;
    unsigned int v114 = __PAIR64__(v110, v109) >> 17;
    unsigned int v115 = __PAIR64__(v111, v112) >> 2;
    a3[16] = v111;
    a3[17] = v112;
    unsigned int v116 = __PAIR64__(v106 >> 17, v113) >> 2;
    unint64_t v117 = __PAIR64__(v113, v114);
    a3[18] = v113;
    a3[19] = v114;
    unsigned int v118 = __PAIR64__(v114, v111) >> 2;
    a3[36] = v115;
    a3[37] = v116;
    HIDWORD(v117) = v117 >> 2;
    LODWORD(v117) = v118;
    a3[38] = HIDWORD(v117);
    a3[39] = v118;
    a3[52] = __PAIR64__(v116, HIDWORD(v117)) >> 30;
    a3[53] = v117 >> 30;
    unsigned int v119 = __PAIR64__(v39, v31) >> 17;
    unsigned int v120 = __PAIR64__(v31, v33) >> 17;
    a3[54] = __PAIR64__(v118, v115) >> 30;
    a3[55] = __PAIR64__(v115, v116) >> 30;
    unsigned int v121 = __PAIR64__(v33, v38) >> 17;
    HIDWORD(v117) = __PAIR64__(v38, v39) >> 17;
    LODWORD(v117) = v119;
    unsigned int v122 = v117 >> 2;
    a3[12] = HIDWORD(v117);
    a3[13] = v119;
    unsigned int v123 = __PAIR64__(v119, v120) >> 2;
    unsigned int v124 = __PAIR64__(v120, v121) >> 2;
    a3[14] = v120;
    a3[15] = v121;
    HIDWORD(v117) = v121;
    LODWORD(v117) = __PAIR64__(v38, v39) >> 17;
    unsigned int v125 = v117 >> 2;
    a3[28] = v122;
    a3[29] = v123;
    a3[30] = v124;
    a3[31] = v125;
    unsigned int v126 = __PAIR64__(v124, v125) >> 15;
    a3[48] = v123;
    a3[49] = v124;
    unint64_t v127 = __PAIR64__(v125, v122);
    a3[50] = v125;
    a3[51] = v122;
    unsigned int v128 = __PAIR64__(v6, v7) >> 19;
    unsigned int v129 = __PAIR64__(v8, v9) >> 19;
    a3[56] = __PAIR64__(v123, v124) >> 15;
    a3[57] = v126;
    unsigned int v130 = __PAIR64__(v4, v138) >> 19;
    a3[58] = v127 >> 15;
    a3[59] = __PAIR64__(v122, v123) >> 15;
    unsigned int v131 = __PAIR64__(v128, v129) >> 17;
    HIDWORD(v127) = v129;
    LODWORD(v127) = __PAIR64__(v10, v139) >> 19;
    unsigned int v132 = v127 >> 17;
    a3[24] = v128;
    a3[25] = v129;
    unsigned int v133 = __PAIR64__(v130, v128) >> 17;
    a3[26] = v127;
    a3[27] = v130;
    unsigned int v134 = __PAIR64__(v131, v132) >> 15;
    HIDWORD(v127) = v132;
    LODWORD(v127) = __PAIR64__(__PAIR64__(v10, v139) >> 19, v130) >> 17;
    unsigned int v135 = v127 >> 15;
    a3[32] = v131;
    a3[33] = v132;
    unsigned int v136 = __PAIR64__(v127, v133) >> 15;
    unsigned int v137 = __PAIR64__(v133, v131) >> 15;
    a3[34] = v127;
    a3[35] = v133;
    unsigned int v76 = __PAIR64__(v127 >> 15, v136) >> 30;
    uint64_t result = 4;
    unsigned int v78 = __PAIR64__(v136, v137) >> 30;
    a3[44] = v134;
    a3[45] = v135;
    a3[46] = v136;
    a3[47] = v137;
    unsigned int v79 = __PAIR64__(v137, v134) >> 30;
    uint64_t v80 = 63;
    uint64_t v81 = 62;
    uint64_t v82 = 61;
    uint64_t v83 = 60;
    unsigned int v84 = __PAIR64__(v134, v135) >> 30;
  }
  a3[v83] = v76;
  a3[v82] = v78;
  a3[v81] = v79;
  a3[v80] = v84;
  return result;
}

uint64_t Camellia_EncryptBlock_Rounds(int a1, unsigned int *a2, _DWORD *a3, unsigned char *a4)
{
  uint64_t v4 = 16 * a1;
  unsigned int v5 = bswap32(*a2) ^ *a3;
  unsigned int v6 = bswap32(a2[1]) ^ a3[1];
  unsigned int v7 = bswap32(a2[2]) ^ a3[2];
  unsigned int v8 = bswap32(a2[3]) ^ a3[3];
  int v9 = a3 + 19;
  for (uint64_t i = 4 * v4 - 64; ; i -= 64)
  {
    int v11 = Camellia_SBOX[((unsigned __int16)(*((_WORD *)v9 - 30) ^ v5) >> 8) + 768] ^ Camellia_SBOX[(*((unsigned char *)v9 - 60) ^ v5) + 256] ^ Camellia_SBOX[((*(v9 - 15) ^ v5) >> 16) + 512] ^ Camellia_SBOX[(*(v9 - 15) ^ v5) >> 24];
    int v12 = __ROR4__(v11, 8);
    int v13 = Camellia_SBOX[((unsigned __int16)(*((_WORD *)v9 - 28) ^ v6) >> 8) + 256] ^ Camellia_SBOX[(*((unsigned char *)v9 - 56) ^ v6)] ^ Camellia_SBOX[((*(v9 - 14) ^ v6) >> 16) + 768] ^ Camellia_SBOX[((*(v9 - 14) ^ v6) >> 24) + 512] ^ v11;
    int v14 = v13 ^ v7;
    int v15 = v8 ^ v12 ^ v13;
    int v16 = Camellia_SBOX[((unsigned __int16)(v14 ^ *((_WORD *)v9 - 26)) >> 8) + 768] ^ Camellia_SBOX[(v14 ^ *((unsigned char *)v9 - 52)) + 256] ^ Camellia_SBOX[((v14 ^ *(v9 - 13)) >> 16) + 512] ^ Camellia_SBOX[(v14 ^ *(v9 - 13)) >> 24];
    int v17 = __ROR4__(v16, 8);
    int v18 = Camellia_SBOX[((unsigned __int16)(v15 ^ *((_WORD *)v9 - 24)) >> 8) + 256] ^ Camellia_SBOX[(v15 ^ *((unsigned char *)v9 - 48))] ^ Camellia_SBOX[((v15 ^ *(v9 - 12)) >> 16) + 768] ^ Camellia_SBOX[((v15 ^ *(v9 - 12)) >> 24) + 512] ^ v16;
    int v19 = v18 ^ v5;
    int v20 = v6 ^ v17 ^ v18;
    int v21 = Camellia_SBOX[((unsigned __int16)(v19 ^ *((_WORD *)v9 - 22)) >> 8) + 768] ^ Camellia_SBOX[(v19 ^ *((unsigned char *)v9 - 44)) + 256] ^ Camellia_SBOX[((v19 ^ *(v9 - 11)) >> 16) + 512] ^ Camellia_SBOX[(v19 ^ *(v9 - 11)) >> 24];
    int v22 = __ROR4__(v21, 8);
    int v23 = Camellia_SBOX[((unsigned __int16)(v20 ^ *((_WORD *)v9 - 20)) >> 8) + 256] ^ Camellia_SBOX[(v20 ^ *((unsigned char *)v9 - 40))] ^ Camellia_SBOX[((v20 ^ *(v9 - 10)) >> 16) + 768] ^ Camellia_SBOX[((v20 ^ *(v9 - 10)) >> 24) + 512] ^ v21;
    int v24 = v23 ^ v14;
    int v25 = v15 ^ v22 ^ v23;
    int v26 = Camellia_SBOX[((unsigned __int16)(v24 ^ *((_WORD *)v9 - 18)) >> 8) + 768] ^ Camellia_SBOX[(v24 ^ *((unsigned char *)v9 - 36)) + 256] ^ Camellia_SBOX[((v24 ^ *(v9 - 9)) >> 16) + 512] ^ Camellia_SBOX[(v24 ^ *(v9 - 9)) >> 24];
    int v27 = __ROR4__(v26, 8);
    int v28 = Camellia_SBOX[((unsigned __int16)(v25 ^ *((_WORD *)v9 - 16)) >> 8) + 256] ^ Camellia_SBOX[(v25 ^ *((unsigned char *)v9 - 32))] ^ Camellia_SBOX[((v25 ^ *(v9 - 8)) >> 16) + 768] ^ Camellia_SBOX[((v25 ^ *(v9 - 8)) >> 24) + 512] ^ v26;
    int v29 = v28 ^ v19;
    int v30 = v20 ^ v27 ^ v28;
    int v31 = Camellia_SBOX[((unsigned __int16)(v29 ^ *((_WORD *)v9 - 14)) >> 8) + 768] ^ Camellia_SBOX[(v29 ^ *((unsigned char *)v9 - 28)) + 256] ^ Camellia_SBOX[((v29 ^ *(v9 - 7)) >> 16) + 512] ^ Camellia_SBOX[(v29 ^ *(v9 - 7)) >> 24];
    int v32 = v25 ^ __ROR4__(v31, 8);
    int v33 = Camellia_SBOX[((unsigned __int16)(v30 ^ *((_WORD *)v9 - 12)) >> 8) + 256] ^ Camellia_SBOX[(v30 ^ *((unsigned char *)v9 - 24))] ^ Camellia_SBOX[((v30 ^ *(v9 - 6)) >> 16) + 768] ^ Camellia_SBOX[((v30 ^ *(v9 - 6)) >> 24) + 512] ^ v31;
    int v34 = v33 ^ v24;
    uint64_t result = v32 ^ v33;
    int v36 = Camellia_SBOX[((unsigned __int16)(v34 ^ *((_WORD *)v9 - 10)) >> 8) + 768] ^ Camellia_SBOX[(v34 ^ *((unsigned char *)v9 - 20)) + 256] ^ Camellia_SBOX[((v34 ^ *(v9 - 5)) >> 16) + 512] ^ Camellia_SBOX[(v34 ^ *(v9 - 5)) >> 24];
    int v37 = Camellia_SBOX[((unsigned __int16)(result ^ *((_WORD *)v9 - 8)) >> 8) + 256] ^ Camellia_SBOX[(result ^ *((unsigned char *)v9 - 16))] ^ Camellia_SBOX[((result ^ *(v9 - 4)) >> 16) + 768] ^ Camellia_SBOX[((result ^ *(v9 - 4)) >> 24) + 512] ^ v36;
    int v38 = v37 ^ v29;
    int v39 = v30 ^ __ROR4__(v36, 8) ^ v37;
    if (!i) {
      break;
    }
    int v40 = *(v9 - 2);
    unsigned int v6 = v39 ^ __ROR4__(*(v9 - 3) & v38, 31);
    unsigned int v7 = (*v9 | result) ^ v34;
    int v41 = *(v9 - 1);
    v9 += 16;
    unsigned int v5 = (v6 | v40) ^ v38;
    unsigned int v8 = result ^ __ROR4__(v7 & v41, 31);
  }
  int v42 = a3[v4] ^ v34;
  int v43 = *(v9 - 2) ^ result;
  int v44 = *(v9 - 1) ^ v38;
  int v45 = *v9 ^ v39;
  *a4 = HIBYTE(v42);
  a4[1] = BYTE2(v42);
  a4[2] = BYTE1(v42);
  a4[3] = v42;
  a4[4] = HIBYTE(v43);
  a4[5] = BYTE2(v43);
  a4[6] = BYTE1(v43);
  a4[7] = v43;
  a4[8] = HIBYTE(v44);
  a4[9] = BYTE2(v44);
  a4[10] = BYTE1(v44);
  a4[11] = v44;
  a4[12] = HIBYTE(v45);
  a4[13] = BYTE2(v45);
  a4[14] = BYTE1(v45);
  a4[15] = v45;
  return result;
}

uint64_t Camellia_EncryptBlock(int a1, unsigned int *a2, _DWORD *a3, unsigned char *a4)
{
  if (a1 == 128) {
    int v4 = 3;
  }
  else {
    int v4 = 4;
  }
  return Camellia_EncryptBlock_Rounds(v4, a2, a3, a4);
}

uint64_t Camellia_DecryptBlock_Rounds(int a1, unsigned int *a2, _DWORD *a3, unsigned char *a4)
{
  int v4 = &a3[16 * a1];
  unsigned int v5 = bswap32(*a2) ^ *v4;
  unsigned int v6 = bswap32(a2[1]) ^ v4[1];
  unsigned int v7 = bswap32(a2[2]) ^ v4[2];
  unsigned int v8 = bswap32(a2[3]) ^ v4[3];
  uint64_t v9 = 16 * a1 - 16;
  for (uint64_t i = v4 - 8; ; i -= 32)
  {
    int v11 = Camellia_SBOX[((unsigned __int16)(i[12] ^ v5) >> 8) + 768] ^ Camellia_SBOX[(*((unsigned char *)i + 24) ^ v5) + 256] ^ Camellia_SBOX[((*((_DWORD *)i + 6) ^ v5) >> 16) + 512] ^ Camellia_SBOX[(*((_DWORD *)i + 6) ^ v5) >> 24];
    int v12 = __ROR4__(v11, 8);
    int v13 = Camellia_SBOX[((unsigned __int16)(i[14] ^ v6) >> 8) + 256] ^ Camellia_SBOX[(*((unsigned char *)i + 28) ^ v6)] ^ Camellia_SBOX[((*((_DWORD *)i + 7) ^ v6) >> 16) + 768] ^ Camellia_SBOX[((*((_DWORD *)i + 7) ^ v6) >> 24) + 512] ^ v11;
    int v14 = v13 ^ v7;
    int v15 = v8 ^ v12 ^ v13;
    int v16 = Camellia_SBOX[((unsigned __int16)(v14 ^ i[8]) >> 8) + 768] ^ Camellia_SBOX[(v14 ^ *((unsigned char *)i + 16)) + 256] ^ Camellia_SBOX[((v14 ^ *((_DWORD *)i + 4)) >> 16) + 512] ^ Camellia_SBOX[(v14 ^ *((_DWORD *)i + 4)) >> 24];
    int v17 = __ROR4__(v16, 8);
    int v18 = Camellia_SBOX[((unsigned __int16)(v15 ^ i[10]) >> 8) + 256] ^ Camellia_SBOX[(v15 ^ *((unsigned char *)i + 20))] ^ Camellia_SBOX[((v15 ^ *((_DWORD *)i + 5)) >> 16) + 768] ^ Camellia_SBOX[((v15 ^ *((_DWORD *)i + 5)) >> 24) + 512] ^ v16;
    int v19 = v18 ^ v5;
    int v20 = v6 ^ v17 ^ v18;
    int v21 = Camellia_SBOX[((unsigned __int16)(v19 ^ i[4]) >> 8) + 768] ^ Camellia_SBOX[(v19 ^ *((unsigned char *)i + 8)) + 256] ^ Camellia_SBOX[((v19 ^ *((_DWORD *)i + 2)) >> 16) + 512] ^ Camellia_SBOX[(v19 ^ *((_DWORD *)i + 2)) >> 24];
    int v22 = __ROR4__(v21, 8);
    int v23 = Camellia_SBOX[((unsigned __int16)(v20 ^ i[6]) >> 8) + 256] ^ Camellia_SBOX[(v20 ^ *((unsigned char *)i + 12))] ^ Camellia_SBOX[((v20 ^ *((_DWORD *)i + 3)) >> 16) + 768] ^ Camellia_SBOX[((v20 ^ *((_DWORD *)i + 3)) >> 24) + 512] ^ v21;
    int v24 = v23 ^ v14;
    int v25 = v15 ^ v22 ^ v23;
    int v26 = Camellia_SBOX[((unsigned __int16)(v24 ^ *i) >> 8) + 768] ^ Camellia_SBOX[(v24 ^ *(unsigned char *)i) + 256] ^ Camellia_SBOX[((v24 ^ *(_DWORD *)i) >> 16) + 512] ^ Camellia_SBOX[(v24 ^ *(_DWORD *)i) >> 24];
    int v27 = __ROR4__(v26, 8);
    int v28 = Camellia_SBOX[((unsigned __int16)(v25 ^ i[2]) >> 8) + 256] ^ Camellia_SBOX[(v25 ^ *((unsigned char *)i + 4))] ^ Camellia_SBOX[((v25 ^ *((_DWORD *)i + 1)) >> 16) + 768] ^ Camellia_SBOX[((v25 ^ *((_DWORD *)i + 1)) >> 24) + 512] ^ v26;
    int v29 = v28 ^ v19;
    int v30 = v20 ^ v27 ^ v28;
    int v31 = Camellia_SBOX[((unsigned __int16)(v29 ^ *(i - 4)) >> 8) + 768] ^ Camellia_SBOX[(v29 ^ *((unsigned char *)i - 8)) + 256] ^ Camellia_SBOX[((v29 ^ *((_DWORD *)i - 2)) >> 16) + 512] ^ Camellia_SBOX[(v29 ^ *((_DWORD *)i - 2)) >> 24];
    int v32 = v25 ^ __ROR4__(v31, 8);
    int v33 = Camellia_SBOX[((unsigned __int16)(v30 ^ *(i - 2)) >> 8) + 256] ^ Camellia_SBOX[(v30 ^ *((unsigned char *)i - 4))] ^ Camellia_SBOX[((v30 ^ *((_DWORD *)i - 1)) >> 16) + 768] ^ Camellia_SBOX[((v30 ^ *((_DWORD *)i - 1)) >> 24) + 512] ^ v31;
    int v34 = v33 ^ v24;
    int v35 = v32 ^ v33;
    int v36 = Camellia_SBOX[((unsigned __int16)(v34 ^ *(i - 8)) >> 8) + 768] ^ Camellia_SBOX[(v34 ^ *((unsigned char *)i - 16)) + 256] ^ Camellia_SBOX[((v34 ^ *((_DWORD *)i - 4)) >> 16) + 512] ^ Camellia_SBOX[(v34 ^ *((_DWORD *)i - 4)) >> 24];
    uint64_t result = v30 ^ __ROR4__(v36, 8);
    int v38 = Camellia_SBOX[((unsigned __int16)(v35 ^ *(i - 6)) >> 8) + 256] ^ Camellia_SBOX[(v35 ^ *((unsigned char *)i - 12))] ^ Camellia_SBOX[((v35 ^ *((_DWORD *)i - 3)) >> 16) + 768] ^ Camellia_SBOX[((v35 ^ *((_DWORD *)i - 3)) >> 24) + 512] ^ v36;
    int v39 = v38 ^ v29;
    int v40 = result ^ v38;
    if (!v9) {
      break;
    }
    unsigned int v6 = v40 ^ __ROR4__(*((_DWORD *)i - 6) & v39, 31);
    unsigned int v7 = (*((_DWORD *)i - 7) | v35) ^ v34;
    unsigned int v5 = (v6 | *((_DWORD *)i - 5)) ^ v39;
    unsigned int v8 = v35 ^ __ROR4__(v7 & *((_DWORD *)i - 8), 31);
    v9 -= 16;
  }
  int v41 = *a3 ^ v34;
  int v42 = a3[1] ^ v35;
  int v43 = a3[2] ^ v39;
  int v44 = a3[3] ^ v40;
  *a4 = HIBYTE(v41);
  a4[1] = BYTE2(v41);
  a4[2] = BYTE1(v41);
  a4[3] = v41;
  a4[4] = HIBYTE(v42);
  a4[5] = BYTE2(v42);
  a4[6] = BYTE1(v42);
  a4[7] = v42;
  a4[8] = HIBYTE(v43);
  a4[9] = BYTE2(v43);
  a4[10] = BYTE1(v43);
  a4[11] = v43;
  a4[12] = HIBYTE(v44);
  a4[13] = BYTE2(v44);
  a4[14] = BYTE1(v44);
  a4[15] = v44;
  return result;
}

uint64_t Camellia_DecryptBlock(int a1, unsigned int *a2, _DWORD *a3, unsigned char *a4)
{
  if (a1 == 128) {
    int v4 = 3;
  }
  else {
    int v4 = 4;
  }
  return Camellia_DecryptBlock_Rounds(v4, a2, a3, a4);
}

int RSA_sign(int type, const unsigned __int8 *m, unsigned int m_length, unsigned __int8 *sigret, unsigned int *siglen, RSA *rsa)
{
  uint64_t v9 = m;
  int v18 = 0;
  int v17 = 0;
  if ((rsa->flags & 0x40) == 0 || (rsa_siguint64_t n = rsa->meth->rsa_sign) == 0)
  {
    if (type == 114)
    {
      if (m_length != 36)
      {
        ERR_put_error(4, 4095, 143, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_sign.c", 144);
        return 0;
      }
      int v12 = 0;
      int v13 = 36;
    }
    else
    {
      int v14 = encode_pkcs1(&v18, &v17, type, (uint64_t)m, m_length);
      int v12 = v18;
      int v13 = v17;
      if (!v14) {
        goto LABEL_15;
      }
      uint64_t v9 = (const unsigned __int8 *)v18;
    }
    if (v13 <= RSA_size(rsa) - 11)
    {
      signed int v15 = RSA_private_encrypt(v13, v9, sigret, rsa, 1);
      if (v15 >= 1)
      {
        *siguint64_t len = v15;
        int v16 = 1;
LABEL_16:
        freezero(v12, v13);
        return v16;
      }
    }
    else
    {
      ERR_put_error(4, 4095, 112, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_sign.c", 155);
    }
LABEL_15:
    int v16 = 0;
    goto LABEL_16;
  }
  return ((uint64_t (*)(void, const unsigned __int8 *, void, unsigned __int8 *, unsigned int *))rsa_sign)(*(void *)&type, m, *(void *)&m_length, sigret, siglen);
}

uint64_t encode_pkcs1(void *a1, int *a2, int n, uint64_t a4, int a5)
{
  int v19 = 0;
  int v20 = 0;
  uint64_t v17 = 0;
  v18[0] = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  int v14 = 0;
  a.algor = (X509_ALGOR *)&v19;
  uint64_t v9 = OBJ_nid2obj(n);
  int v19 = v9;
  if (!v9)
  {
    int v12 = 117;
    int v13 = 100;
LABEL_7:
    ERR_put_error(4, 4095, v12, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_sign.c", v13);
    return 0;
  }
  if (!v9->length)
  {
    int v12 = 116;
    int v13 = 105;
    goto LABEL_7;
  }
  LODWORD(v18[0]) = 5;
  v18[1] = 0;
  int v20 = v18;
  a.int digest = (ASN1_OCTET_STRING *)&v15;
  uint64_t v16 = a4;
  LODWORD(v15) = a5;
  int v10 = i2d_X509_SIG(&a, &v14);
  if ((v10 & 0x80000000) == 0)
  {
    *a1 = v14;
    *a2 = v10;
    return 1;
  }
  return 0;
}

uint64_t int_rsa_verify(int a1, unsigned __int8 *a2, unsigned int a3, _DWORD *a4, void *a5, const unsigned __int8 *a6, size_t a7, RSA *a8)
{
  __b1 = 0;
  int v30 = 0;
  if (RSA_size(a8) == a7)
  {
    uint64_t v16 = (unsigned __int8 *)malloc_type_malloc(a7, 0x653958A5uLL);
    if (v16)
    {
      int v17 = RSA_public_decrypt(a7, a6, v16, a8, 1);
      if (v17 < 1)
      {
LABEL_27:
        int v19 = 0;
LABEL_28:
        uint64_t v22 = 0;
        goto LABEL_29;
      }
      unsigned int v18 = v17;
      if (a1 == 114)
      {
        if (v17 == 36)
        {
          if (a4)
          {
            int v19 = 0;
            long long v20 = *(_OWORD *)v16;
            long long v21 = *((_OWORD *)v16 + 1);
            a4[8] = *((_DWORD *)v16 + 8);
            *(_OWORD *)a4 = v20;
            *((_OWORD *)a4 + md4_block_data_order((unint64_t)c, b, 1) = v21;
            *a5 = 36;
LABEL_8:
            uint64_t v22 = 1;
LABEL_29:
            freezero(__b1, v19);
            freezero(v16, a7);
            return v22;
          }
          if (a3 == 36)
          {
            if (!timingsafe_bcmp(v16, a2, 0x24uLL))
            {
              int v19 = 0;
              goto LABEL_8;
            }
            int v23 = 104;
            int v24 = 221;
          }
          else
          {
            int v23 = 131;
            int v24 = 216;
          }
        }
        else
        {
          int v23 = 143;
          int v24 = 207;
        }
        goto LABEL_26;
      }
      if (a4)
      {
        int v25 = OBJ_nid2sn(a1);
        digestbyname = EVP_get_digestbyname(v25);
        if (!digestbyname)
        {
          int v23 = 117;
          int v24 = 235;
          goto LABEL_26;
        }
        unsigned int v27 = EVP_MD_size(digestbyname);
        if (v27 > v18)
        {
          int v23 = 143;
          int v24 = 239;
          goto LABEL_26;
        }
        a3 = v27;
        a2 = &v16[v18 - v27];
      }
      int v28 = encode_pkcs1(&__b1, &v30, a1, (uint64_t)a2, a3);
      int v19 = v30;
      if (v28)
      {
        if (v30 == v18 && !timingsafe_bcmp(__b1, v16, v18))
        {
          if (a4)
          {
            memcpy(a4, a2, a3);
            *a5 = a3;
          }
          uint64_t v22 = 1;
          int v19 = v18;
          goto LABEL_29;
        }
        ERR_put_error(4, 4095, 104, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_sign.c", 251);
      }
      goto LABEL_28;
    }
    int v23 = 65;
    int v24 = 193;
LABEL_26:
    ERR_put_error(4, 4095, v23, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_sign.c", v24);
    goto LABEL_27;
  }
  ERR_put_error(4, 4095, 119, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/rsa/rsa_sign.c", 187);
  return 0;
}

int RSA_verify(int type, const unsigned __int8 *m, unsigned int m_length, unsigned __int8 *sigbuf, unsigned int siglen, RSA *rsa)
{
  if ((rsa->flags & 0x40) != 0 && (rsa_verify = rsa->meth->rsa_verify) != 0) {
    return ((uint64_t (*)(void, const unsigned __int8 *, void, unsigned __int8 *, void, RSA *))rsa_verify)(*(void *)&type, m, *(void *)&m_length, sigbuf, *(void *)&siglen, rsa);
  }
  else {
    return int_rsa_verify(type, (unsigned __int8 *)m, m_length, 0, 0, sigbuf, siglen, rsa);
  }
}

void ERR_load_DSA_strings(void)
{
  if (!ERR_func_error_string(DSA_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&DSA_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&DSA_str_reasons);
  }
}

void ENGINE_unregister_digests(ENGINE *e)
{
}

int ENGINE_register_digests(ENGINE *e)
{
  char v1 = (uint64_t (*)(void))*((void *)e + 11);
  if (v1 && (int v3 = v1(), v3 > 0)) {
    return engine_table_register(&digest_table, (uint64_t)engine_unregister_all_digests, (char *)e, 0, v3, 0);
  }
  else {
    return 1;
  }
}

void engine_unregister_all_digests()
{
}

void ENGINE_register_all_digests(void)
{
  first = ENGINE_get_first();
  if (first)
  {
    next = first;
    do
    {
      ENGINE_register_digests(next);
      next = ENGINE_get_next(next);
    }
    while (next);
  }
}

int ENGINE_set_default_digests(ENGINE *e)
{
  char v1 = (uint64_t (*)(void))*((void *)e + 11);
  if (v1 && (int v3 = v1(), v3 > 0)) {
    return engine_table_register(&digest_table, (uint64_t)engine_unregister_all_digests, (char *)e, 0, v3, 1);
  }
  else {
    return 1;
  }
}

ENGINE *__cdecl ENGINE_get_digest_engine(int nid)
{
  return (ENGINE *)engine_table_select(&digest_table, nid);
}

const EVP_MD *__cdecl ENGINE_get_digest(ENGINE *e, int nid)
{
  int v4 = 0;
  uint64_t v2 = (unsigned int (*)(void))*((void *)e + 11);
  if (v2 && v2()) {
    return v4;
  }
  ERR_put_error(38, 4095, 147, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/tb_digest.c", 133);
  return 0;
}

ENGINE_DIGESTS_PTR ENGINE_get_digests(const ENGINE *e)
{
  return (ENGINE_DIGESTS_PTR)*((void *)e + 11);
}

int ENGINE_set_digests(ENGINE *e, ENGINE_DIGESTS_PTR f)
{
  *((void *)e + 1md4_block_data_order((unint64_t)c, b, 1) = f;
  return 1;
}

uint64_t bn_is_prime_bpsw(int *a1, const BIGNUM *a2, BN_CTX *a3, uint64_t a4)
{
  if (BN_is_word((uint64_t)a2, 2))
  {
    is_odunsigned int d = 1;
    goto LABEL_3;
  }
  int v12 = BN_value_one();
  if (BN_cmp(a2, v12) < 1)
  {
    is_odunsigned int d = 0;
    goto LABEL_3;
  }
  is_odunsigned int d = BN_is_odd((uint64_t)a2);
  if (!is_odd)
  {
LABEL_3:
    uint64_t v9 = 0;
    *a1 = is_odd;
    goto LABEL_4;
  }
  for (uint64_t i = 0; i != 2048; ++i)
  {
    unint64_t v14 = (unsigned __int16)primes[i];
    unint64_t v15 = BN_mod_word(a2, v14);
    if (v15 == -1)
    {
      uint64_t v9 = 0;
      goto LABEL_51;
    }
    if (!v15)
    {
      is_odunsigned int d = BN_is_word((uint64_t)a2, v14);
      goto LABEL_3;
    }
  }
  uint64_t v9 = a3;
  if (!a3)
  {
    uint64_t v9 = BN_CTX_new();
    if (!v9) {
      goto LABEL_51;
    }
  }
  BN_CTX_start(v9);
  uint64_t v16 = BN_CTX_get(v9);
  if (!v16) {
    goto LABEL_49;
  }
  int v17 = v16;
  unsigned int v18 = BN_CTX_get(v9);
  if (!v18) {
    goto LABEL_49;
  }
  int v19 = v18;
  long long v20 = BN_CTX_get(v9);
  if (!v20) {
    goto LABEL_49;
  }
  long long v21 = v20;
  uint64_t v22 = BN_CTX_get(v9);
  if (!v22) {
    goto LABEL_49;
  }
  int v23 = v22;
  if (BN_is_word((uint64_t)a2, 2) || BN_is_word((uint64_t)a2, 3))
  {
    int v24 = 0;
    goto LABEL_23;
  }
  int v26 = BN_value_one();
  if (BN_cmp(a2, v26) < 1 || !BN_is_odd((uint64_t)a2))
  {
    int v25 = 0;
    int v24 = 0;
LABEL_24:
    *a1 = v25;
    goto LABEL_25;
  }
  unsigned int v27 = BN_value_one();
  if (!BN_sub(v21, a2, v27)) {
    goto LABEL_49;
  }
  X509_SIG a = v23;
  int v28 = -1;
  do
    ++v28;
  while (!BN_is_bit_set(v21, v28));
  if (!BN_rshift(v19, v21, v28))
  {
LABEL_49:
    int v24 = 0;
    goto LABEL_50;
  }
  int v29 = BN_MONT_CTX_new();
  int v24 = v29;
  if (!v29
    || !BN_MONT_CTX_set(v29, a2, v9)
    || !BN_set_word(v17, 2uLL)
    || !bn_fermat(a1, a2, v21, v19, v28, v17, v9, v24))
  {
    goto LABEL_50;
  }
  if (*a1)
  {
    if (!BN_set_word(a, 3uLL)) {
      goto LABEL_50;
    }
    if (a4)
    {
      while (bn_rand_interval(v17, a, v21) && bn_fermat(a1, a2, v21, v19, v28, v17, v9, v24))
      {
        if (!*a1) {
          goto LABEL_25;
        }
        int v25 = 1;
        if (!--a4) {
          goto LABEL_24;
        }
      }
LABEL_50:
      BN_MONT_CTX_free(v24);
      BN_CTX_end(v9);
LABEL_51:
      uint64_t v10 = 0;
      goto LABEL_5;
    }
LABEL_23:
    int v25 = 1;
    goto LABEL_24;
  }
LABEL_25:
  BN_MONT_CTX_free(v24);
  BN_CTX_end(v9);
  if (*a1 && !bn_strong_lucas_selfridge(a1, a2, v9)) {
    goto LABEL_51;
  }
LABEL_4:
  uint64_t v10 = 1;
LABEL_5:
  if (v9 != a3) {
    BN_CTX_free(v9);
  }
  return v10;
}

uint64_t bn_strong_lucas_selfridge(int *a1, const BIGNUM *a2, BN_CTX *ctx)
{
  BOOL v16 = 0;
  BN_CTX_start(ctx);
  if (!bn_is_perfect_square(&v16, a2, ctx))
  {
LABEL_16:
    uint64_t v6 = 0;
    goto LABEL_17;
  }
  if (!v16)
  {
    unsigned int v7 = BN_CTX_get(ctx);
    if (v7)
    {
      unsigned int v8 = v7;
      uint64_t v9 = BN_CTX_get(ctx);
      if (v9)
      {
        uint64_t v10 = v9;
        if (BN_set_word(v8, 5uLL))
        {
          if (BN_set_word(v10, 2uLL))
          {
            uint64_t v11 = 1;
            uint64_t v12 = 0xFFFFFFFFLL;
            while (1)
            {
              uint64_t v13 = v12;
              int v14 = BN_kronecker(v8, a2, ctx);
              if (v14 == -2) {
                break;
              }
              if (v14 == -1)
              {
                if (bn_strong_lucas_test(a1, a2, v8, ctx)) {
                  goto LABEL_4;
                }
                goto LABEL_16;
              }
              if (!v14) {
                goto LABEL_3;
              }
              if (!BN_uadd(v8, v8, v10)) {
                goto LABEL_16;
              }
              BN_set_negative(v8, v13 == -1);
              uint64_t v12 = v11;
              uint64_t v11 = v13;
            }
          }
        }
      }
    }
    goto LABEL_16;
  }
LABEL_3:
  *a1 = 0;
LABEL_4:
  uint64_t v6 = 1;
LABEL_17:
  BN_CTX_end(ctx);
  return v6;
}

uint64_t bn_fermat(int *a1, const BIGNUM *a2, const BIGNUM *a3, const BIGNUM *a4, int a5, const BIGNUM *a6, BN_CTX *ctx, BN_MONT_CTX *a8)
{
  BN_CTX_start(ctx);
  BOOL v16 = BN_CTX_get(ctx);
  if (v16)
  {
    int v17 = v16;
    unsigned int v18 = BN_value_one();
    if (BN_cmp(a6, v18) >= 1 && BN_cmp(a6, a3) < 0 && BN_mod_exp_mont_ct(v17, a6, a4, a2, ctx, a8))
    {
      if (BN_is_one((uint64_t)v17) || !BN_cmp(v17, a3))
      {
LABEL_8:
        int v21 = 1;
      }
      else
      {
        int v22 = a5 - 2;
        if (a5 >= 2)
        {
          while (1)
          {
            int v23 = v22;
            if (!BN_mod_sqr(v17, v17, a2, ctx)) {
              goto LABEL_4;
            }
            if (!BN_cmp(v17, a3)) {
              goto LABEL_8;
            }
            BOOL is_one = BN_is_one((uint64_t)v17);
            int v21 = 0;
            if (!is_one)
            {
              int v22 = v23 - 1;
              if (v23) {
                continue;
              }
            }
            goto LABEL_9;
          }
        }
        int v21 = 0;
      }
LABEL_9:
      *a1 = v21;
      uint64_t v19 = 1;
      goto LABEL_5;
    }
  }
LABEL_4:
  uint64_t v19 = 0;
LABEL_5:
  BN_CTX_end(ctx);
  return v19;
}

uint64_t bn_strong_lucas_test(int *a1, const BIGNUM *a2, const BIGNUM *a3, BN_CTX *ctx)
{
  BN_CTX_start(ctx);
  unsigned int v8 = BN_CTX_get(ctx);
  if (!v8) {
    goto LABEL_23;
  }
  uint64_t v9 = v8;
  uint64_t v10 = BN_CTX_get(ctx);
  if (!v10) {
    goto LABEL_23;
  }
  uint64_t v11 = v10;
  uint64_t v12 = BN_CTX_get(ctx);
  if (!v12) {
    goto LABEL_23;
  }
  uint64_t v13 = v12;
  int v14 = -2;
  do
  {
    int is_bit_set = BN_is_bit_set(a2, v14 + 2);
    ++v14;
  }
  while (is_bit_set);
  if (!BN_rshift(v9, a2, v14 + 1)
    || !BN_set_bit(v9, 0)
    || !BN_one((uint64_t)v11)
    || !BN_one((uint64_t)v13))
  {
    goto LABEL_23;
  }
  int v16 = BN_num_bits(v9);
  if (v16 >= 2)
  {
    int v17 = v16 - 1;
    do
    {
      int v18 = BN_is_bit_set(v9, --v17);
      if (!bn_lucas_step(v11, v13, v18, a3, a2, ctx)) {
        goto LABEL_23;
      }
    }
    while (v17 >= 1);
  }
  if (!BN_is_zero((uint64_t)v11) && !BN_is_zero((uint64_t)v13))
  {
    if ((v14 + 1) < 2)
    {
      int v19 = 0;
      goto LABEL_17;
    }
    while (bn_lucas_step(v11, v13, 0, a3, a2, ctx))
    {
      if (BN_is_zero((uint64_t)v13)) {
        goto LABEL_16;
      }
      int v19 = 0;
      if (!--v14) {
        goto LABEL_17;
      }
    }
LABEL_23:
    uint64_t v20 = 0;
    goto LABEL_24;
  }
LABEL_16:
  int v19 = 1;
LABEL_17:
  *a1 = v19;
  uint64_t v20 = 1;
LABEL_24:
  BN_CTX_end(ctx);
  return v20;
}

BOOL bn_lucas_step(BIGNUM *a1, BIGNUM *a2, int a3, const BIGNUM *a4, const BIGNUM *a5, BN_CTX *ctx)
{
  BN_CTX_start(ctx);
  uint64_t v12 = BN_CTX_get(ctx);
  BOOL v14 = 0;
  if (v12)
  {
    uint64_t v13 = v12;
    if (BN_sqr(v12, a1, ctx))
    {
      if (BN_mul(v13, a4, v13, ctx)
        && BN_mod_mul(a1, a1, a2, a5, ctx)
        && BN_sqr(a2, a2, ctx)
        && BN_add(a2, a2, v13)
        && bn_div_by_two_mod_odd_n(a2, a5, ctx)
        && (a3 != 1
         || BN_mul(v13, a4, a1, ctx)
         && BN_add(a1, a1, a2)
         && bn_div_by_two_mod_odd_n(a1, a5, ctx)
         && BN_add(a2, a2, v13)
         && bn_div_by_two_mod_odd_n(a2, a5, ctx)))
      {
        BOOL v14 = 1;
      }
    }
  }
  BN_CTX_end(ctx);
  return v14;
}

uint64_t bn_div_by_two_mod_odd_n(BIGNUM *a1, const BIGNUM *a2, BN_CTX *a3)
{
  uint64_t result = BN_is_odd((uint64_t)a2);
  if (result)
  {
    if (!BN_is_odd((uint64_t)a1) || (uint64_t result = BN_add(a1, a1, a2), result))
    {
      uint64_t result = BN_rshift1(a1, a1);
      if (result) {
        return BN_mod_ct(a1, a1, a2, a3) != 0;
      }
    }
  }
  return result;
}

void ERR_load_BIO_strings(void)
{
  if (!ERR_func_error_string(BIO_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&BIO_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&BIO_str_reasons);
  }
}

void *EVP_gost2814789imit()
{
  return &gost2814789imit_md;
}

uint64_t gost2814789_init(uint64_t a1)
{
  return GOST2814789IMIT_Init(*(void *)(a1 + 24), 824);
}

uint64_t gost2814789_update(uint64_t a1, char *a2, size_t a3)
{
  return GOST2814789IMIT_Update(*(void *)(a1 + 24), a2, a3);
}

uint64_t gost2814789_final(uint64_t a1, _DWORD *a2)
{
  return GOST2814789IMIT_Final(a2, *(void *)(a1 + 24));
}

uint64_t gost2814789_md_ctrl(uint64_t a1, int a2, int a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 24);
  if (a2 == 4) {
    return Gost2814789_set_sbox(v4 + 20, a3);
  }
  if (a2 == 3) {
    return Gost2814789_set_key(v4 + 20, a4, a3);
  }
  return 4294967294;
}

EVP_PKEY *__cdecl PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  pnuint64_t m = 0;
  puint64_t len = 0;
  punsigned int data = 0;
  if (PEM_bytes_read_bio(&pdata, &plen, &pnm, "ANY PRIVATE KEY", bp, cb, u))
  {
    punsigned int p = pdata;
    unsigned int v7 = pnm;
    if (!strcmp(pnm, "PRIVATE KEY"))
    {
      uint64_t v11 = d2i_PKCS8_PRIV_KEY_INFO(0, (const unsigned __int8 **)&pp, plen);
      if (!v11) {
        goto LABEL_22;
      }
      uint64_t v12 = v11;
    }
    else
    {
      if (strcmp(v7, "ENCRYPTED PRIVATE KEY"))
      {
        signed int v8 = pem_check_suffix(v7, "PRIVATE KEY");
        if (v8 >= 1)
        {
          uint64_t str = EVP_PKEY_asn1_find_str(0, pnm, v8);
          if (str)
          {
            if (*((void *)str + 23))
            {
              uint64_t v10 = d2i_PrivateKey(*(_DWORD *)str, x, (const unsigned __int8 **)&pp, plen);
              if (v10) {
                goto LABEL_24;
              }
            }
          }
        }
        goto LABEL_22;
      }
      uint64_t v13 = d2i_X509_SIG(0, (const unsigned __int8 **)&pp, plen);
      if (!v13) {
        goto LABEL_22;
      }
      BOOL v14 = v13;
      if (cb) {
        int v15 = ((uint64_t (*)(char *, uint64_t, void, void *))cb)(buf, 1024, 0, u);
      }
      else {
        int v15 = PEM_def_callback(buf, 1024, 0, u);
      }
      if (v15 < 1)
      {
        ERR_put_error(9, 4095, 104, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_pkey.c", 120);
        X509_SIG_free(v14);
        goto LABEL_23;
      }
      uint64_t v12 = PKCS8_decrypt(v14, buf, v15);
      X509_SIG_free(v14);
      if (!v12)
      {
LABEL_22:
        ERR_put_error(9, 4095, 13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_pkey.c", 144);
LABEL_23:
        uint64_t v10 = 0;
LABEL_24:
        free(pnm);
        freezero(pdata, plen);
        return v10;
      }
    }
    uint64_t v10 = EVP_PKCS82PKEY(v12);
    if (x)
    {
      EVP_PKEY_free(*x);
      *x = v10;
    }
    PKCS8_PRIV_KEY_INFO_free(v12);
    if (v10) {
      goto LABEL_24;
    }
    goto LABEL_22;
  }
  return 0;
}

int PEM_write_bio_PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc, unsigned __int8 *kstr, int klen, pem_password_cb *cb, void *u)
{
  ptr = x->pkey.ptr;
  if (ptr && !*((void *)ptr + 9)) {
    return PEM_write_bio_PrivateKey_traditional(bp, (uint64_t)x, enc, kstr, klen, cb, u);
  }
  else {
    return PEM_write_bio_PKCS8PrivateKey(bp, x, enc, (char *)kstr, klen, cb, u);
  }
}

uint64_t PEM_write_bio_PrivateKey_traditional(BIO *a1, uint64_t a2, const EVP_CIPHER *a3, unsigned __int8 *a4, int a5, pem_password_cb *a6, void *a7)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  snprintf(__str, 0x50uLL, "%s PRIVATE KEY", *(const char **)(*(void *)(a2 + 16) + 16));
  return PEM_ASN1_write_bio((i2d_of_void *)i2d_PrivateKey, __str, a1, (char *)a2, a3, a4, a5, a6, a7);
}

EVP_PKEY *PEM_read_bio_Parameters(BIO *bp, EVP_PKEY **a2)
{
  pnuint64_t m = 0;
  uint64_t v9 = 0;
  punsigned int data = 0;
  if (PEM_bytes_read_bio(&pdata, &v9, &pnm, "PARAMETERS", bp, 0, 0))
  {
    uint64_t v11 = pdata;
    int v3 = pem_check_suffix(pnm, "PARAMETERS");
    if (v3 >= 1)
    {
      signed int v4 = v3;
      unsigned int v5 = EVP_PKEY_new();
      if (v5)
      {
        uint64_t v6 = v5;
        if (EVP_PKEY_set_type_str((uint64_t)v5, pnm, v4))
        {
          unsigned int v7 = (unsigned int (*)(EVP_PKEY *, unsigned __int8 **, void))*((void *)v6->pkey.ptr + 14);
          if (v7)
          {
            if (v7(v6, &v11, v9))
            {
              if (a2)
              {
                EVP_PKEY_free(*a2);
                *a2 = v6;
              }
              goto LABEL_12;
            }
          }
        }
        EVP_PKEY_free(v6);
      }
    }
    ERR_put_error(9, 4095, 13, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_pkey.c", 210);
    uint64_t v6 = 0;
LABEL_12:
    free(pnm);
    free(pdata);
    return v6;
  }
  return 0;
}

uint64_t PEM_write_bio_Parameters(BIO *a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a2 + 16);
  if (!v2 || !*(void *)(v2 + 120)) {
    return 0;
  }
  snprintf(__str, 0x50uLL, "%s PARAMETERS", *(const char **)(v2 + 16));
  return PEM_ASN1_write_bio(*(i2d_of_void **)(*(void *)(a2 + 16) + 120), __str, a1, (char *)a2, 0, 0, 0, 0, 0);
}

EVP_PKEY *__cdecl PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u)
{
  signed int v8 = BIO_s_file();
  uint64_t v9 = BIO_new(v8);
  if (v9)
  {
    uint64_t v10 = v9;
    BIO_ctrl(v9, 106, 0, fp);
    bio_PrivateKey = PEM_read_bio_PrivateKey(v10, x, cb, u);
    BIO_free(v10);
    return bio_PrivateKey;
  }
  else
  {
    ERR_put_error(9, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_pkey.c", 237);
    return 0;
  }
}

int PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc, unsigned __int8 *kstr, int klen, pem_password_cb *cb, void *u)
{
  uint64_t v13 = BIO_new_fp(fp, 0);
  if (v13)
  {
    BOOL v14 = v13;
    int v15 = PEM_write_bio_PrivateKey(v13, x, enc, kstr, klen, cb, u);
    BIO_free(v14);
    return v15;
  }
  else
  {
    ERR_put_error(9, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pem/pem_pkey.c", 254);
    return 0;
  }
}

void explicit_bzero(void *a1, size_t a2)
{
  bzero(a1, a2);
  j____explicit_bzero_hook();
}

const EVP_CIPHER *EVP_rc4(void)
{
  return (const EVP_CIPHER *)&r4_cipher;
}

const EVP_CIPHER *EVP_rc4_40(void)
{
  return (const EVP_CIPHER *)&r4_40_cipher;
}

uint64_t rc4_init_key(const EVP_CIPHER_CTX *a1, const unsigned __int8 *a2)
{
  cipher_unsigned int data = (RC4_KEY *)a1->cipher_data;
  int v4 = EVP_CIPHER_CTX_key_length(a1);
  RC4_set_key(cipher_data, v4, a2);
  return 1;
}

uint64_t rc4_cipher(uint64_t a1, unsigned __int8 *outdata, const unsigned __int8 *a3, unint64_t len)
{
  return 1;
}

void ENGINE_unregister_RAND(ENGINE *e)
{
}

int ENGINE_register_RAND(ENGINE *e)
{
  if (*((void *)e + 8)) {
    return engine_table_register(&rand_table, (uint64_t)engine_unregister_all_RAND, (char *)e, dummy_nid_4, 1, 0);
  }
  else {
    return 1;
  }
}

void engine_unregister_all_RAND()
{
}

void ENGINE_register_all_RAND(void)
{
  first = ENGINE_get_first();
  if (first)
  {
    next = first;
    do
    {
      if (*((void *)next + 8)) {
        engine_table_register(&rand_table, (uint64_t)engine_unregister_all_RAND, (char *)next, dummy_nid_4, 1, 0);
      }
      next = ENGINE_get_next(next);
    }
    while (next);
  }
}

int ENGINE_set_default_RAND(ENGINE *e)
{
  if (*((void *)e + 8)) {
    return engine_table_register(&rand_table, (uint64_t)engine_unregister_all_RAND, (char *)e, dummy_nid_4, 1, 1);
  }
  else {
    return 1;
  }
}

ENGINE *ENGINE_get_default_RAND(void)
{
  return (ENGINE *)engine_table_select(&rand_table, 1);
}

const RAND_METHOD *__cdecl ENGINE_get_RAND(const ENGINE *e)
{
  return (const RAND_METHOD *)*((void *)e + 8);
}

int ENGINE_set_RAND(ENGINE *e, const RAND_METHOD *rand_meth)
{
  *((void *)e + 8) = rand_meth;
  return 1;
}

void *EVP_sm4_cbc()
{
  return &sm4_cbc;
}

void *EVP_sm4_cfb128()
{
  return &sm4_cfb128;
}

void *EVP_sm4_ofb()
{
  return &sm4_ofb;
}

void *EVP_sm4_ecb()
{
  return &sm4_ecb;
}

void *EVP_sm4_ctr()
{
  return &sm4_ctr_mode;
}

uint64_t sm4_init_key(uint64_t a1, unsigned int *a2)
{
  return 1;
}

uint64_t sm4_cbc_cipher(uint64_t a1, uint64_t *a2, void *a3, unint64_t a4)
{
  uint64_t v4 = a4;
  if (!(a4 >> 62))
  {
    unint64_t v8 = a4;
    if (!a4) {
      return 1;
    }
    goto LABEL_4;
  }
  do
  {
    sm4_cbc_encrypt(a3, a2, 0x4000000000000000uLL, *(void *)(a1 + 120), (_OWORD *)(a1 + 40), *(_DWORD *)(a1 + 16));
    unint64_t v8 = v4 - 0x4000000000000000;
    a3 += 0x800000000000000;
    a2 += 0x800000000000000;
    BOOL v9 = v4 < 0x4000000000000000;
    v4 -= 0x4000000000000000;
  }
  while (v9);
  if (v8) {
LABEL_4:
  }
    sm4_cbc_encrypt(a3, a2, v8, *(void *)(a1 + 120), (_OWORD *)(a1 + 40), *(_DWORD *)(a1 + 16));
  return 1;
}

void sm4_cbc_encrypt(void *a1, uint64_t *a2, unint64_t a3, uint64_t a4, _OWORD *a5, int a6)
{
  if (a6) {
    CRYPTO_cbc128_encrypt(a1, a2, a3, a4, a5, (void (*)(void *, void *, uint64_t))SM4_encrypt);
  }
  else {
    CRYPTO_cbc128_decrypt((uint64_t)a1, a2, a3, a4, a5, (uint64_t (*)(void *, uint64_t *, uint64_t))SM4_decrypt);
  }
}

uint64_t sm4_cfb128_cipher(uint64_t a1, unsigned char *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v4 = a4;
    if (a4 >= 0x4000000000000000) {
      unint64_t v8 = 0x4000000000000000;
    }
    else {
      unint64_t v8 = a4;
    }
    uint64_t v9 = a1 + 40;
    uint64_t v10 = (unsigned int *)(a1 + 88);
    do
    {
      CRYPTO_cfb128_encrypt(a3, a2, v8, *(void *)(a1 + 120), v9, v10, *(_DWORD *)(a1 + 16), (uint64_t (*)(uint64_t, uint64_t, uint64_t))SM4_encrypt);
      a3 += v8;
      a2 += v8;
      v4 -= v8;
      if (v4 < v8) {
        unint64_t v8 = v4;
      }
    }
    while (v4);
  }
  return 1;
}

uint64_t sm4_ofb_cipher(uint64_t a1, unsigned char *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4 = a4;
  if (!(a4 >> 62))
  {
    unint64_t v8 = a4;
    if (!a4) {
      return 1;
    }
    goto LABEL_4;
  }
  do
  {
    CRYPTO_ofb128_encrypt(a3, a2, 0x4000000000000000uLL, *(void *)(a1 + 120), a1 + 40, (unsigned int *)(a1 + 88), (uint64_t (*)(uint64_t, uint64_t, uint64_t))SM4_encrypt);
    unint64_t v8 = v4 - 0x4000000000000000;
    a3 += 0x4000000000000000;
    a2 += 0x4000000000000000;
    BOOL v9 = v4 < 0x4000000000000000;
    v4 -= 0x4000000000000000;
  }
  while (v9);
  if (v8) {
LABEL_4:
  }
    CRYPTO_ofb128_encrypt(a3, a2, v8, *(void *)(a1 + 120), a1 + 40, (unsigned int *)(a1 + 88), (uint64_t (*)(uint64_t, uint64_t, uint64_t))SM4_encrypt);
  return 1;
}

uint64_t sm4_ecb_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4 = *(int *)(*(void *)a1 + 4);
  unint64_t v5 = a4 - v4;
  if (a4 >= v4)
  {
    unint64_t v9 = 0;
    do
    {
      uint64_t v10 = (unsigned int *)(a3 + v9);
      uint64_t v11 = (unsigned char *)(a2 + v9);
      uint64_t v12 = *(_DWORD **)(a1 + 120);
      if (*(_DWORD *)(a1 + 16)) {
        SM4_encrypt(v10, v11, v12);
      }
      else {
        SM4_decrypt(v10, v11, v12);
      }
      v9 += v4;
    }
    while (v9 <= v5);
  }
  return 1;
}

uint64_t sm4_ctr_cipher(uint64_t a1, unsigned char *a2, uint64_t a3, unint64_t a4)
{
  return 1;
}

const char *idea_options()
{
  return "idea(int)";
}

unint64_t *idea_ecb_encrypt(unsigned int *a1, _DWORD *a2, unsigned int *a3)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v4 = bswap32(a1[1]);
  unint64_t v7 = bswap32(*a1);
  uint64_t v8 = v4;
  uint64_t result = idea_encrypt(&v7, a3);
  unsigned int v6 = bswap32(v8);
  *a2 = bswap32(v7);
  a2[1] = v6;
  return result;
}

uint64_t pkey_hkdf_init(uint64_t a1)
{
  uint64_t v2 = malloc_type_calloc(1uLL, 0x438uLL, 0x10700401EDF281CuLL);
  if (v2)
  {
    *(void *)(a1 + 4RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = v2;
    return 1;
  }
  else
  {
    ERR_put_error(52, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/kdf/hkdf_evp.c", 80);
    return 0;
  }
}

void *pkey_hkdf_cleanup(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  freezero(*(void **)(v1 + 16), *(void *)(v1 + 24));
  freezero(*(void **)(v1 + 32), *(void *)(v1 + 40));
  return freezero((void *)v1, 0x438uLL);
}

void pkey_hkdf_derive_init(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  freezero(*(void **)(v1 + 32), *(void *)(v1 + 40));
  freezero(*(void **)(v1 + 16), *(void *)(v1 + 24));
  explicit_bzero((void *)v1, 0x438uLL);
}

uint64_t pkey_hkdf_derive(uint64_t a1, unsigned __int8 *a2, size_t *a3)
{
  uint64_t v4 = *(int **)(a1 + 40);
  unint64_t v5 = (EVP_MD *)*((void *)v4 + 1);
  if (!v5)
  {
    int v9 = 105;
    int v10 = 227;
LABEL_9:
    ERR_put_error(52, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/kdf/hkdf_evp.c", v10);
    return 0;
  }
  unsigned int v6 = (const void *)*((void *)v4 + 4);
  if (!v6)
  {
    int v9 = 104;
    int v10 = 231;
    goto LABEL_9;
  }
  int v7 = *v4;
  if (*v4 == 2)
  {
    uint64_t v11 = *((void *)v4 + 5);
    size_t v12 = *((void *)v4 + 134);
    size_t v14 = *a3;
    return HKDF_expand((uint64_t)a2, v14, v5, v6, v11, (const unsigned __int8 *)v4 + 48, v12);
  }
  else
  {
    if (v7 != 1)
    {
      if (!v7) {
        return HKDF((uint64_t)a2, *a3, v5, (const unsigned __int8 *)v6, *((void *)v4 + 5), *((void **)v4 + 2), *((void *)v4 + 3), (const unsigned __int8 *)v4 + 48, *((void *)v4 + 134));
      }
      return 0;
    }
    if (a2)
    {
      size_t v15 = *((void *)v4 + 5);
      uint64_t v16 = (void *)*((void *)v4 + 2);
      uint64_t v17 = *((void *)v4 + 3);
      return HKDF_extract(a2, a3, v5, (const unsigned __int8 *)v6, v15, v16, v17);
    }
    else
    {
      *a3 = EVP_MD_size(*((const EVP_MD **)v4 + 1));
      return 1;
    }
  }
}

uint64_t pkey_hkdf_ctrl(uint64_t a1, int a2, size_t __n, void *__src)
{
  unsigned int v5 = __n;
  uint64_t v6 = *(void *)(a1 + 40);
  switch(a2)
  {
    case 4099:
      if (!__src) {
        return 0;
      }
      *(void *)(v6 + 8) = __src;
      return 1;
    case 4100:
      uint64_t result = 1;
      if (!__n || !__src) {
        return result;
      }
      if ((__n & 0x80000000) != 0) {
        return 0;
      }
      freezero(*(void **)(v6 + 16), *(void *)(v6 + 24));
      uint64_t result = (uint64_t)malloc_type_malloc(v5, 0xE46B6C7uLL);
      *(void *)(v6 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = result;
      if (!result) {
        return result;
      }
      memcpy((void *)result, __src, v5);
      *(void *)(v6 + 24) = v5;
      return 1;
    case 4101:
      if ((int)__n < 1) {
        return 0;
      }
      freezero(*(void **)(v6 + 32), *(void *)(v6 + 40));
      uint64_t result = (uint64_t)malloc_type_malloc(v5, 0xB1C071E9uLL);
      *(void *)(v6 + 32) = result;
      if (!result) {
        return result;
      }
      memcpy((void *)result, __src, v5);
      *(void *)(v6 + 4RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = v5;
      return 1;
    case 4102:
      uint64_t result = 1;
      if (!__n || !__src) {
        return result;
      }
      if ((__n & 0x80000000) != 0) {
        return 0;
      }
      uint64_t v8 = *(void *)(v6 + 1072);
      if (1024 - (int)v8 < (int)__n) {
        return 0;
      }
      memcpy((void *)(v6 + v8 + 48), __src, __n);
      *(void *)(v6 + 1072) += v5;
      return 1;
    case 4103:
      *(_DWORD *)uint64_t v6 = __n;
      return 1;
    default:
      return 4294967294;
  }
}

uint64_t pkey_hkdf_ctrl_str(uint64_t *a1, char *__s1, char *a3)
{
  if (!strcmp(__s1, "mode"))
  {
    if (!strcmp(a3, "EXTRACT_AND_EXPAND") || !strcmp(a3, "EXTRACT_ONLY") || !strcmp(a3, "EXPAND_ONLY"))
    {
      return EVP_PKEY_CTX_ctrl(a1, -1, 1024);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    if (strcmp(__s1, "md"))
    {
      if (!strcmp(__s1, "salt"))
      {
        uint64_t v7 = (uint64_t)a1;
        uint64_t v8 = 4100;
      }
      else
      {
        if (!strcmp(__s1, "hexsalt"))
        {
          uint64_t v9 = (uint64_t)a1;
          uint64_t v10 = 4100;
          goto LABEL_31;
        }
        if (strcmp(__s1, "key"))
        {
          if (strcmp(__s1, "hexkey"))
          {
            if (strcmp(__s1, "info"))
            {
              if (strcmp(__s1, "hexinfo"))
              {
                ERR_put_error(52, 4095, 103, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/kdf/hkdf_evp.c", 204);
                return 4294967294;
              }
              uint64_t v9 = (uint64_t)a1;
              uint64_t v10 = 4102;
              goto LABEL_31;
            }
            uint64_t v7 = (uint64_t)a1;
            uint64_t v8 = 4102;
            goto LABEL_27;
          }
          uint64_t v9 = (uint64_t)a1;
          uint64_t v10 = 4101;
LABEL_31:
          return EVP_PKEY_CTX_hex2ctrl(v9, v10, a3);
        }
        uint64_t v7 = (uint64_t)a1;
        uint64_t v8 = 4101;
      }
LABEL_27:
      return EVP_PKEY_CTX_str2ctrl(v7, v8, a3);
    }
    return EVP_PKEY_CTX_md(a1, 1024, 4099, a3);
  }
}

int CRYPTO_mem_ctrl(int mode)
{
  return 0;
}

int CRYPTO_is_mem_check_on(void)
{
  return 0;
}

uint64_t CRYPTO_dbg_get_options(void)
{
  return 0;
}

int CRYPTO_push_info_(const char *info, const char *file, int line)
{
  return 0;
}

int CRYPTO_pop_info(void)
{
  return 0;
}

int CRYPTO_remove_all_info(void)
{
  return 0;
}

BOOL ec_GFp_simple_set_compressed_coordinates(const EC_GROUP *a1, const EC_POINT *a2, const BIGNUM *a3, int a4, BN_CTX *a5)
{
  ERR_clear_error();
  int v10 = a4 != 0;
  BN_CTX_start(a5);
  uint64_t v11 = BN_CTX_get(a5);
  if (!v11) {
    goto LABEL_37;
  }
  size_t v12 = v11;
  uint64_t v13 = BN_CTX_get(a5);
  if (!v13) {
    goto LABEL_37;
  }
  size_t v14 = v13;
  size_t v15 = BN_CTX_get(a5);
  if (!v15) {
    goto LABEL_37;
  }
  uint64_t v16 = v15;
  uint64_t v17 = BN_CTX_get(a5);
  if (!v17) {
    goto LABEL_37;
  }
  int v18 = v17;
  if (!BN_nnmod(v16, a3, (const BIGNUM *)((char *)a1 + 104), a5)) {
    goto LABEL_37;
  }
  if (*(void *)(*(void *)a1 + 296))
  {
    if (!BN_mod_sqr(v14, a3, (const BIGNUM *)((char *)a1 + 104), a5)
      || !BN_mod_mul(v12, v14, a3, (const BIGNUM *)((char *)a1 + 104), a5))
    {
      goto LABEL_37;
    }
  }
  else if (!(*(unsigned int (**)(const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *))(*(void *)a1 + 272))(a1, v14, a3, a5)|| !(*(unsigned int (**)(const EC_GROUP *, BIGNUM *, BIGNUM *, const BIGNUM *, BN_CTX *))(*(void *)a1 + 264))(a1, v12, v14, a3, a5))
  {
    goto LABEL_37;
  }
  if (*((_DWORD *)a1 + 50))
  {
    if (!BN_mod_lshift1_quick(v14, v16, (const BIGNUM *)((char *)a1 + 104))
      || !BN_mod_add_quick(v14, v14, v16, (const BIGNUM *)((char *)a1 + 104))
      || !BN_mod_sub_quick(v12, v12, v14, (const BIGNUM *)((char *)a1 + 104)))
    {
      goto LABEL_37;
    }
  }
  else
  {
    int v19 = *(unsigned int (**)(const EC_GROUP *, BIGNUM *, char *, BN_CTX *))(*(void *)a1 + 296);
    if (v19)
    {
      if (!v19(a1, v14, (char *)a1 + 152, a5) || !BN_mod_mul(v14, v14, v16, (const BIGNUM *)((char *)a1 + 104), a5)) {
        goto LABEL_37;
      }
    }
    else if (!(*(unsigned int (**)(const EC_GROUP *, BIGNUM *, uint64_t, BIGNUM *, BN_CTX *))(*(void *)a1 + 264))(a1, v14, (uint64_t)a1 + 152, v16, a5))
    {
      goto LABEL_37;
    }
    if (!BN_mod_add_quick(v12, v12, v14, (const BIGNUM *)((char *)a1 + 104))) {
      goto LABEL_37;
    }
  }
  uint64_t v20 = (const BIGNUM *)((char *)a1 + 176);
  int v21 = *(unsigned int (**)(const EC_GROUP *, BIGNUM *, const BIGNUM *, BN_CTX *))(*(void *)a1 + 296);
  if (v21)
  {
    if (v21(a1, v14, v20, a5))
    {
      uint64_t v22 = v12;
      int v23 = v12;
      uint64_t v20 = v14;
      goto LABEL_27;
    }
LABEL_37:
    BOOL v24 = 0;
    goto LABEL_38;
  }
  uint64_t v22 = v12;
  int v23 = v12;
LABEL_27:
  if (!BN_mod_add_quick(v22, v23, v20, (const BIGNUM *)((char *)a1 + 104))) {
    goto LABEL_37;
  }
  if (!BN_mod_sqrt(v18, v12, (const BIGNUM *)((char *)a1 + 104), a5))
  {
    if ((ERR_peek_last_error() & 0xFF000FFF) == 0x300006F)
    {
      ERR_clear_error();
      int v25 = 110;
      int v26 = 153;
    }
    else
    {
      int v25 = 3;
      int v26 = 155;
    }
LABEL_36:
    ERR_put_error(16, 4095, v25, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_oct.c", v26);
    goto LABEL_37;
  }
  if (BN_is_odd((uint64_t)v18) != v10)
  {
    if (BN_is_zero((uint64_t)v18))
    {
      int v25 = 109;
      int v26 = 160;
    }
    else
    {
      if (!BN_usub(v18, (const BIGNUM *)((char *)a1 + 104), v18)) {
        goto LABEL_37;
      }
      if (BN_is_odd((uint64_t)v18) == v10) {
        goto LABEL_30;
      }
      int v25 = 68;
      int v26 = 166;
    }
    goto LABEL_36;
  }
LABEL_30:
  BOOL v24 = EC_POINT_set_affine_coordinates(a1, a2, (uint64_t)v16, (uint64_t)v18, a5) != 0;
LABEL_38:
  BN_CTX_end(a5);
  return v24;
}

uint64_t ec_GFp_simple_point2oct(uint64_t a1, const EC_POINT *a2, unsigned int a3, unsigned char *a4, unint64_t a5, BN_CTX *a6)
{
  if (a3 > 6 || ((1 << a3) & 0x54) == 0)
  {
    int v18 = 104;
    int v19 = 192;
    goto LABEL_19;
  }
  if (EC_POINT_is_at_infinity((const EC_GROUP *)a1, a2) < 1)
  {
    int v13 = BN_num_bits((const BIGNUM *)(a1 + 104));
    int v14 = v13 + 7;
    if (v13 < -7) {
      int v14 = v13 + 14;
    }
    uint64_t v15 = (uint64_t)v14 >> 3;
    if (a3 == 2) {
      unint64_t v12 = v15 + 1;
    }
    else {
      unint64_t v12 = (2 * v15) | 1;
    }
    BN_CTX_start(a6);
    if (!a4) {
      goto LABEL_45;
    }
    if (v12 <= a5)
    {
      uint64_t v20 = BN_CTX_get(a6);
      if (!v20) {
        goto LABEL_45;
      }
      int v21 = v20;
      uint64_t v22 = BN_CTX_get(a6);
      if (!v22) {
        goto LABEL_45;
      }
      int v23 = v22;
      if (!EC_POINT_get_affine_coordinates(a1, a2, (uint64_t)v21, (uint64_t)v22, a6)) {
        goto LABEL_45;
      }
      char v24 = a3;
      if ((a3 | 4) == 6)
      {
        if (BN_is_odd((uint64_t)v23)) {
          char v24 = a3 + 1;
        }
        else {
          char v24 = a3;
        }
      }
      *a4 = v24;
      int v25 = BN_num_bits(v21);
      int v26 = v25 + 7;
      if (v25 < -7) {
        int v26 = v25 + 14;
      }
      signed int v27 = v15 - (v26 >> 3);
      if (v27 <= v15)
      {
        uint64_t v28 = v15 + 1;
        if (v27)
        {
          uint64_t v29 = v27;
          bzero(a4 + 1, v27);
          uint64_t v30 = v29 + 1;
        }
        else
        {
          uint64_t v30 = 1;
        }
        if (v30 + BN_bn2bin(v21, &a4[v30]) != v28)
        {
          int v16 = 68;
          int v17 = 248;
          goto LABEL_16;
        }
        if ((a3 | 2) == 6)
        {
          int v31 = BN_num_bits(v23);
          int v32 = v31 + 7;
          if (v31 < -7) {
            int v32 = v31 + 14;
          }
          unsigned int v33 = v15 - (v32 >> 3);
          if (v33 > v15)
          {
            int v16 = 68;
            int v17 = 254;
            goto LABEL_16;
          }
          if (v33)
          {
            int v34 = -(v32 >> 3);
            bzero(&a4[v28], (int)v33);
            v28 += v15 + v34;
          }
          v28 += BN_bn2bin(v23, &a4[v28]);
        }
        if (v28 == v12) {
          goto LABEL_45;
        }
        int v16 = 68;
        int v17 = 265;
      }
      else
      {
        int v16 = 68;
        int v17 = 238;
      }
    }
    else
    {
      int v16 = 100;
      int v17 = 217;
    }
LABEL_16:
    ERR_put_error(16, 4095, v16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_oct.c", v17);
LABEL_45:
    BN_CTX_end(a6);
    return v12;
  }
  if (a4)
  {
    if (a5)
    {
      *a4 = 0;
      return 1;
    }
    int v18 = 100;
    int v19 = 200;
LABEL_19:
    ERR_put_error(16, 4095, v18, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_oct.c", v19);
    return 0;
  }
  return 1;
}

uint64_t ec_GFp_simple_oct2point(EC_GROUP *a1, EC_POINT *a2, unsigned __int8 *a3, uint64_t a4, BN_CTX *a5)
{
  if (!a4)
  {
    int v28 = 100;
    int v29 = 287;
    goto LABEL_39;
  }
  unsigned int v6 = *a3;
  if (v6 >= 4 && (v6 & 0xFC) != 4)
  {
    int v28 = 102;
    int v29 = 296;
LABEL_39:
    ERR_put_error(16, 4095, v28, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_oct.c", v29);
    return 0;
  }
  uint64_t v8 = v6 & 1;
  int v9 = v6 & 0xFE;
  BOOL v11 = (v6 & 0xFE) == 0 || v9 == 4;
  if (v8) {
    BOOL v12 = !v11;
  }
  else {
    BOOL v12 = 1;
  }
  if (!v12)
  {
    int v28 = 102;
    int v29 = 300;
    goto LABEL_39;
  }
  if (v9)
  {
    int v17 = BN_num_bits((const BIGNUM *)((char *)a1 + 104));
    int v18 = v17 + 7;
    if (v17 < -7) {
      int v18 = v17 + 14;
    }
    uint64_t v19 = (uint64_t)v18 >> 3;
    uint64_t v20 = (2 * v19) | 1;
    if (v9 == 2) {
      uint64_t v20 = v19 + 1;
    }
    if (v20 != a4)
    {
      int v28 = 102;
      int v29 = 314;
      goto LABEL_39;
    }
    BN_CTX_start(a5);
    int v21 = BN_CTX_get(a5);
    if (!v21) {
      goto LABEL_30;
    }
    uint64_t v22 = v21;
    int v23 = BN_CTX_get(a5);
    if (!v23) {
      goto LABEL_30;
    }
    char v24 = v23;
    int v25 = a3 + 1;
    if (!BN_bin2bn(v25, v19, v22)) {
      goto LABEL_30;
    }
    if ((BN_ucmp(v22, (const BIGNUM *)((char *)a1 + 104)) & 0x80000000) == 0)
    {
      int v26 = 328;
LABEL_29:
      ERR_put_error(16, 4095, 102, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_oct.c", v26);
LABEL_30:
      uint64_t v27 = 0;
LABEL_31:
      BN_CTX_end(a5);
      return v27;
    }
    if (v9 == 2)
    {
      if (!EC_POINT_set_compressed_coordinates((uint64_t)a1, a2, (uint64_t)v22, v8, a5)) {
        goto LABEL_30;
      }
    }
    else
    {
      if (!BN_bin2bn(&v25[v19], v19, v24)) {
        goto LABEL_30;
      }
      if ((BN_ucmp(v24, (const BIGNUM *)((char *)a1 + 104)) & 0x80000000) == 0)
      {
        int v26 = 342;
        goto LABEL_29;
      }
      if (v9 == 6 && v8 != BN_is_odd((uint64_t)v24))
      {
        int v26 = 347;
        goto LABEL_29;
      }
      if (!EC_POINT_set_affine_coordinates(a1, a2, (uint64_t)v22, (uint64_t)v24, a5)) {
        goto LABEL_30;
      }
    }
    uint64_t v27 = 1;
    goto LABEL_31;
  }
  if (a4 != 1)
  {
    int v28 = 102;
    int v29 = 305;
    goto LABEL_39;
  }
  return EC_POINT_set_to_infinity(a1, a2);
}

void *EVP_whirlpool()
{
  return &whirlpool_md;
}

uint64_t init_3(uint64_t a1)
{
  return WHIRLPOOL_Init(*(void *)(a1 + 24));
}

uint64_t update_3(uint64_t a1, unsigned __int8 *a2, unint64_t a3)
{
  return WHIRLPOOL_Update(*(void *)(a1 + 24), a2, a3);
}

uint64_t final_3(uint64_t a1, _OWORD *a2)
{
  return WHIRLPOOL_Final(a2, *(long long **)(a1 + 24));
}

DSO *DSO_new(void)
{
  return DSO_new_method(0);
}

DSO *__cdecl DSO_new_method(DSO_METHOD *method)
{
  if (!default_DSO_meth) {
    default_DSO_meth = (uint64_t)DSO_METHOD_openssl();
  }
  uint64_t v2 = (DSO *)malloc_type_calloc(1uLL, 0x40uLL, 0x10B0040507EF262uLL);
  if (v2)
  {
    int v3 = sk_new_null();
    v2->meth_unsigned int data = v3;
    if (!v3)
    {
      ERR_put_error(37, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", 120);
LABEL_12:
      free(v2);
      return 0;
    }
    uint64_t v4 = (DSO_METHOD *)default_DSO_meth;
    if (method) {
      uint64_t v4 = method;
    }
    v2->meth = v4;
    v2->referenceunsigned int s = 1;
    init = v4->init;
    if (init && !((unsigned int (*)(DSO *))init)(v2)) {
      goto LABEL_12;
    }
  }
  else
  {
    ERR_put_error(37, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", 114);
  }
  return v2;
}

void DSO_set_default_method(DSO_METHOD *meth)
{
  default_DSO_meth = (uint64_t)meth;
}

DSO_METHOD *DSO_get_default_method(void)
{
  return (DSO_METHOD *)default_DSO_meth;
}

DSO_METHOD *__cdecl DSO_get_method(DSO *dso)
{
  return dso->meth;
}

DSO_METHOD *__cdecl DSO_set_method(DSO *dso, DSO_METHOD *meth)
{
  uint64_t v2 = dso->meth;
  dso->meth = meth;
  return v2;
}

int DSO_free(DSO *dso)
{
  if (dso)
  {
    if (CRYPTO_add_lock(&dso->references, -1, 28, 0, 0) > 0) {
      return 1;
    }
    meth = dso->meth;
    dso_unloaunsigned int d = dso->meth->dso_unload;
    if (dso_unload)
    {
      if (!((unsigned int (*)(DSO *))dso_unload)(dso))
      {
        int v6 = 107;
        int v7 = 151;
        goto LABEL_11;
      }
      meth = dso->meth;
    }
    finish = meth->finish;
    if (!finish || ((unsigned int (*)(DSO *))finish)(dso))
    {
      sk_free(dso->meth_data);
      free(dso->merger);
      free(dso->filename);
      free(dso);
      return 1;
    }
    int v6 = 102;
    int v7 = 156;
  }
  else
  {
    int v6 = 67;
    int v7 = 142;
  }
LABEL_11:
  ERR_put_error(37, 4095, v6, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", v7);
  return 0;
}

int DSO_flags(DSO *dso)
{
  if (dso) {
    LODWORD(dso) = dso->flags;
  }
  return (int)dso;
}

int DSO_up_ref(DSO *dso)
{
  if (dso) {
    return CRYPTO_add_lock(&dso->references, 1, 28, 0, 0) > 1;
  }
  ERR_put_error(37, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", 180);
  return 0;
}

DSO *__cdecl DSO_load(DSO *dso, const char *filename, DSO_METHOD *meth, int flags)
{
  int v6 = dso;
  if (!dso)
  {
    uint64_t v8 = DSO_new_method(meth);
    int v6 = v8;
    if (!v8)
    {
      ERR_put_error(37, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", 197);
      return v6;
    }
    v8->int flags = flags;
  }
  if (v6->merger)
  {
    int v9 = 110;
    int v10 = 210;
  }
  else
  {
    if (!filename) {
      goto LABEL_12;
    }
    if (!DSO_set_filename(v6, filename))
    {
      int v9 = 112;
      int v10 = 217;
      goto LABEL_16;
    }
    if (v6->merger)
    {
      dso_loaunsigned int d = v6->meth->dso_load;
      if (dso_load)
      {
        if (((unsigned int (*)(DSO *))dso_load)(v6)) {
          return v6;
        }
        int v9 = 103;
        int v10 = 230;
      }
      else
      {
        int v9 = 108;
        int v10 = 226;
      }
    }
    else
    {
LABEL_12:
      int v9 = 111;
      int v10 = 222;
    }
  }
LABEL_16:
  ERR_put_error(37, 4095, v9, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", v10);
  if (!dso) {
    DSO_free(v6);
  }
  return 0;
}

uint64_t DSO_ctrl(DSO *dso, int cmd, uint64_t larg, void *parg)
{
  if (!dso)
  {
    int v5 = 67;
    int v6 = 296;
LABEL_15:
    ERR_put_error(37, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", v6);
    return -1;
  }
  switch(cmd)
  {
    case 3:
      uint64_t v4 = 0;
      dso->flags |= larg;
      return v4;
    case 2:
      uint64_t v4 = 0;
      dso->int flags = larg;
      return v4;
    case 1:
      return dso->flags;
  }
  if (!dso->meth || (dso_ctrl = (uint64_t (*)(void))dso->meth->dso_ctrl) == 0)
  {
    int v5 = 108;
    int v6 = 315;
    goto LABEL_15;
  }
  return dso_ctrl();
}

int DSO_set_filename(DSO *dso, const char *filename)
{
  if (!dso || !filename)
  {
    int v3 = 67;
    int v4 = 351;
    goto LABEL_6;
  }
  if (dso->filename)
  {
    int v3 = 110;
    int v4 = 355;
LABEL_6:
    ERR_put_error(37, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", v4);
    return 0;
  }
  int v6 = strdup(filename);
  if (!v6)
  {
    int v3 = 65;
    int v4 = 361;
    goto LABEL_6;
  }
  int v7 = (char *(__cdecl *)(DSO *, const char *, const char *))v6;
  free(dso->merger);
  dso->merger = v7;
  return 1;
}

void *__cdecl DSO_bind_var(DSO *dso, const char *symname)
{
  if (dso && symname)
  {
    dso_bind_var = (uint64_t (*)(void))dso->meth->dso_bind_var;
    if (dso_bind_var)
    {
      uint64_t result = (void *)dso_bind_var();
      if (result) {
        return result;
      }
      int v4 = 106;
      int v5 = 256;
    }
    else
    {
      int v4 = 108;
      int v5 = 252;
    }
  }
  else
  {
    int v4 = 67;
    int v5 = 248;
  }
  ERR_put_error(37, 4095, v4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", v5);
  return 0;
}

DSO_FUNC_TYPE DSO_bind_func(DSO *dso, const char *symname)
{
  if (dso && symname)
  {
    dso_bind_func = (uint64_t (*)(void))dso->meth->dso_bind_func;
    if (dso_bind_func)
    {
      DSO_FUNC_TYPE result = (DSO_FUNC_TYPE)dso_bind_func();
      if (result) {
        return result;
      }
      int v4 = 106;
      int v5 = 277;
    }
    else
    {
      int v4 = 108;
      int v5 = 273;
    }
  }
  else
  {
    int v4 = 67;
    int v5 = 269;
  }
  ERR_put_error(37, 4095, v4, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", v5);
  return 0;
}

int DSO_set_name_converter(DSO *dso, DSO_NAME_CONVERTER_FUNC cb, DSO_NAME_CONVERTER_FUNC *oldcb)
{
  if (dso)
  {
    if (oldcb) {
      *oldcint b = *(DSO_NAME_CONVERTER_FUNC *)&dso->ex_data.dummy;
    }
    *(void *)&dso->ex_data.dummy = cb;
    return 1;
  }
  else
  {
    ERR_put_error(37, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", 326);
    return 0;
  }
}

const char *__cdecl DSO_get_filename(DSO *dso)
{
  if (dso) {
    return (const char *)dso->merger;
  }
  ERR_put_error(37, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", 339);
  return 0;
}

char *__cdecl DSO_merge(DSO *dso, const char *filespec1, const char *filespec2)
{
  if (!dso || !filespec1)
  {
    ERR_put_error(37, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", 375);
    return 0;
  }
  if (dso->flags) {
    return 0;
  }
  name_converter = (uint64_t (*)(void))dso->name_converter;
  if (!name_converter)
  {
    name_converter = (uint64_t (*)(void))dso->meth->dso_merger;
    if (!name_converter) {
      return 0;
    }
  }
  return (char *)name_converter();
}

char *__cdecl DSO_convert_filename(DSO *dso, const char *filename)
{
  if (!dso)
  {
    int v5 = 67;
    int v6 = 394;
    goto LABEL_12;
  }
  merger = filename;
  if (!filename)
  {
    merger = (const char *)dso->merger;
    if (!merger)
    {
      int v5 = 111;
      int v6 = 400;
      goto LABEL_12;
    }
  }
  if ((dso->flags & 1) != 0
    || (dso_name_converter = *(uint64_t (**)(void))&dso->ex_data.dummy) == 0
    && (dso_name_converter = (uint64_t (*)(void))dso->meth->dso_name_converter) == 0
    || (DSO_FUNC_TYPE result = (char *)dso_name_converter()) == 0)
  {
    DSO_FUNC_TYPE result = strdup(merger);
    if (!result)
    {
      int v5 = 65;
      int v6 = 412;
LABEL_12:
      ERR_put_error(37, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", v6);
      return 0;
    }
  }
  return result;
}

const char *__cdecl DSO_get_loaded_filename(DSO *dso)
{
  if (dso) {
    return dso->filename;
  }
  ERR_put_error(37, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", 423);
  return 0;
}

uint64_t DSO_pathbyaddr(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (DSO_METHOD *)default_DSO_meth;
  if (!default_DSO_meth) {
    int v6 = DSO_METHOD_openssl();
  }
  name = v6[1].name;
  if (name)
  {
    return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))name)(a1, a2, a3);
  }
  else
  {
    ERR_put_error(37, 4095, 108, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", 436);
    return 0xFFFFFFFFLL;
  }
}

uint64_t DSO_global_lookup(uint64_t a1)
{
  uint64_t v2 = (DSO_METHOD *)default_DSO_meth;
  if (!default_DSO_meth) {
    uint64_t v2 = DSO_METHOD_openssl();
  }
  dso_loaunsigned int d = v2[1].dso_load;
  if (dso_load)
  {
    return ((uint64_t (*)(uint64_t))dso_load)(a1);
  }
  else
  {
    ERR_put_error(37, 4095, 108, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dso/dso_lib.c", 449);
    return 0;
  }
}

int ECPKParameters_print_fp(FILE *fp, const EC_GROUP *x, int off)
{
  int v6 = BIO_s_file();
  int v7 = BIO_new(v6);
  if (v7)
  {
    uint64_t v8 = v7;
    BIO_ctrl(v7, 106, 0, fp);
    int v9 = ECPKParameters_print(v8, x, off);
    BIO_free(v8);
    return v9;
  }
  else
  {
    ERR_put_error(16, 4095, 7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/eck_prn.c", 79);
    return 0;
  }
}

int ECPKParameters_print(BIO *bp, const EC_GROUP *x, int off)
{
  if (!x)
  {
    BOOL v12 = 0;
    int v6 = 0;
    int v10 = 0;
    int v17 = 0;
    int v16 = 0;
    uint64_t v15 = 0;
    int v14 = 0;
    uint64_t v19 = 0;
    int v20 = 67;
LABEL_18:
    int v18 = (unsigned __int8 *)v12;
    ERR_put_error(16, 4095, v20, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/eck_prn.c", 324);
    int v13 = 0;
    BOOL v12 = v19;
    goto LABEL_19;
  }
  int v6 = BN_CTX_new();
  if (!v6)
  {
    BOOL v12 = 0;
    int v10 = 0;
    goto LABEL_14;
  }
  if (!EC_GROUP_get_asn1_flag(x))
  {
    uint64_t v22 = EC_GROUP_method_of(x);
    int field_type = EC_METHOD_get_field_type(v22);
    int v10 = BN_new();
    if (v10)
    {
      int v17 = BN_new();
      if (v17)
      {
        int v16 = BN_new();
        if (v16)
        {
          order = BN_new();
          if (order)
          {
            uint64_t v19 = BN_new();
            if (!v19)
            {
              BOOL v12 = 0;
              uint64_t v15 = 0;
LABEL_60:
              int v20 = 65;
LABEL_64:
              int v14 = order;
              goto LABEL_18;
            }
            if (EC_GROUP_get_curve((uint64_t)x, (uint64_t)v10, (uint64_t)v17, (uint64_t)v16, v6))
            {
              uint64_t v15 = EC_GROUP_get0_generator(x);
              if (!v15)
              {
LABEL_62:
                BOOL v12 = 0;
                goto LABEL_63;
              }
              if (EC_GROUP_get_order(x, order, 0) && EC_GROUP_get_cofactor(x, v19, 0))
              {
                int n = field_type;
                point_conversion_form_t point_conversion_form = EC_GROUP_get_point_conversion_form(x);
                uint64_t v15 = (const EC_POINT *)EC_POINT_point2bn(x, v15, point_conversion_form, 0, v6);
                if (v15)
                {
                  point_conversion_form_t v47 = point_conversion_form;
                  int v25 = BN_num_bits(v10);
                  int v26 = v25 + 7;
                  if (v25 < -7) {
                    int v26 = v25 + 14;
                  }
                  unsigned int v27 = v26 >> 3;
                  int v28 = BN_num_bits(v17);
                  int v29 = v28 + 7;
                  if (v28 < -7) {
                    int v29 = v28 + 14;
                  }
                  if (v27 <= v29 >> 3) {
                    unsigned int v27 = v29 >> 3;
                  }
                  int v30 = BN_num_bits(v16);
                  int v31 = v30 + 7;
                  if (v30 < -7) {
                    int v31 = v30 + 14;
                  }
                  if (v27 <= v31 >> 3) {
                    unsigned int v27 = v31 >> 3;
                  }
                  int v32 = BN_num_bits((const BIGNUM *)v15);
                  int v33 = v32 + 7;
                  if (v32 < -7) {
                    int v33 = v32 + 14;
                  }
                  if (v27 <= v33 >> 3) {
                    unsigned int v27 = v33 >> 3;
                  }
                  int v34 = BN_num_bits(order);
                  int v35 = v34 + 7;
                  if (v34 < -7) {
                    int v35 = v34 + 14;
                  }
                  if (v27 <= v35 >> 3) {
                    unsigned int v27 = v35 >> 3;
                  }
                  int v36 = BN_num_bits(v19);
                  int v37 = v36 + 7;
                  if (v36 < -7) {
                    int v37 = v36 + 14;
                  }
                  if (v27 <= v37 >> 3) {
                    unsigned int v27 = v37 >> 3;
                  }
                  unsigned int v46 = EC_GROUP_get0_seed(x);
                  if (v46) {
                    seed_uint64_t len = EC_GROUP_get_seed_len(x);
                  }
                  else {
                    seed_uint64_t len = 0;
                  }
                  int v38 = (unsigned __int8 *)malloc_type_malloc((int)(v27 + 10), 0xA629628CuLL);
                  if (v38)
                  {
                    int v18 = v38;
                    if (BIO_indent(bp, off, 128))
                    {
                      int v39 = OBJ_nid2sn(n);
                      if (BIO_printf(bp, "Field Type: %s\n", v39) >= 1)
                      {
                        if (n != 407)
                        {
                          int v43 = "Prime:";
LABEL_76:
                          if (ASN1_bn_print(bp, v43, v10, v18, off)
                            && ASN1_bn_print(bp, "A:   ", v17, v18, off)
                            && ASN1_bn_print(bp, "B:   ", v16, v18, off))
                          {
                            if (v47 == POINT_CONVERSION_UNCOMPRESSED) {
                              int v44 = "Generator (uncompressed):";
                            }
                            else {
                              int v44 = v47 == POINT_CONVERSION_COMPRESSED
                            }
                                  ? "Generator (compressed):"
                                  : "Generator (hybrid):";
                            if (ASN1_bn_print(bp, v44, (const BIGNUM *)v15, v18, off)
                              && ASN1_bn_print(bp, "Order: ", order, v18, off)
                              && ASN1_bn_print(bp, "Cofactor: ", v19, v18, off)
                              && (!v46 || print_bin(bp, v46, seed_len, off)))
                            {
                              int v13 = 1;
                              BOOL v12 = v19;
                              int v14 = order;
                              goto LABEL_19;
                            }
                          }
                          goto LABEL_90;
                        }
                        basis_int type = EC_GROUP_get_basis_type(x);
                        if (basis_type)
                        {
                          int v41 = basis_type;
                          if (BIO_indent(bp, off, 128))
                          {
                            int v42 = OBJ_nid2sn(v41);
                            if (BIO_printf(bp, "Basis Type: %s\n", v42) >= 1)
                            {
                              int v43 = "Polynomial:";
                              goto LABEL_76;
                            }
                          }
                        }
                      }
                    }
LABEL_90:
                    int v20 = 32;
                    BOOL v12 = (BIGNUM *)v18;
                    goto LABEL_64;
                  }
                  BOOL v12 = 0;
                  goto LABEL_60;
                }
                goto LABEL_62;
              }
            }
            BOOL v12 = 0;
            uint64_t v15 = 0;
LABEL_63:
            int v20 = 16;
            goto LABEL_64;
          }
        }
        BOOL v12 = 0;
        goto LABEL_16;
      }
      BOOL v12 = 0;
LABEL_15:
      int v16 = 0;
LABEL_16:
      uint64_t v15 = 0;
      int v14 = 0;
      uint64_t v19 = 0;
      int v20 = 65;
      goto LABEL_18;
    }
    BOOL v12 = 0;
LABEL_14:
    int v17 = 0;
    goto LABEL_15;
  }
  if (!BIO_indent(bp, off, 128)) {
    goto LABEL_17;
  }
  int curve_name = EC_GROUP_get_curve_name(x);
  if (!curve_name) {
    goto LABEL_17;
  }
  int v8 = curve_name;
  int v9 = OBJ_nid2sn(curve_name);
  if (BIO_printf(bp, "ASN1 OID: %s", v9) < 1 || BIO_printf(bp, "\n") < 1) {
    goto LABEL_17;
  }
  int v10 = (BIGNUM *)EC_curve_nid2nist(v8);
  if (!v10)
  {
    BOOL v12 = 0;
    int v14 = 0;
    uint64_t v15 = 0;
    int v16 = 0;
    int v17 = 0;
    int v18 = 0;
    int v13 = 1;
    goto LABEL_19;
  }
  if (!BIO_indent(bp, off, 128))
  {
LABEL_17:
    BOOL v12 = 0;
    int v10 = 0;
    int v17 = 0;
    int v16 = 0;
    uint64_t v15 = 0;
    int v14 = 0;
    uint64_t v19 = 0;
    int v20 = 32;
    goto LABEL_18;
  }
  int v11 = BIO_printf(bp, "NIST CURVE: %s\n", (const char *)v10);
  BOOL v12 = 0;
  if (v11 < 1)
  {
    int v20 = 32;
    int v10 = 0;
    int v17 = 0;
    int v16 = 0;
    uint64_t v15 = 0;
    int v14 = 0;
    uint64_t v19 = 0;
    goto LABEL_18;
  }
  int v13 = 1;
  int v14 = 0;
  uint64_t v15 = 0;
  int v16 = 0;
  int v17 = 0;
  int v10 = 0;
  int v18 = 0;
LABEL_19:
  BN_free(v10);
  BN_free(v17);
  BN_free(v16);
  BN_free((BIGNUM *)v15);
  BN_free(v14);
  BN_free(v12);
  BN_CTX_free(v6);
  free(v18);
  return v13;
}

int EC_KEY_print_fp(FILE *fp, const EC_KEY *x, int off)
{
  int v6 = BIO_s_file();
  int v7 = BIO_new(v6);
  if (v7)
  {
    int v8 = v7;
    BIO_ctrl(v7, 106, 0, fp);
    int v9 = EC_KEY_print(v8, x, off);
    BIO_free(v8);
    return v9;
  }
  else
  {
    ERR_put_error(16, 4095, 32, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/eck_prn.c", 95);
    return 0;
  }
}

int EC_KEY_print(BIO *bp, const EC_KEY *x, int off)
{
  int v6 = EVP_PKEY_new();
  int v7 = v6;
  if (v6 && EVP_PKEY_set1_EC_KEY(v6, x)) {
    int v8 = EVP_PKEY_print_private(bp, (uint64_t)v7, off);
  }
  else {
    int v8 = 0;
  }
  EVP_PKEY_free(v7);
  return v8;
}

int ECParameters_print_fp(FILE *fp, const EC_KEY *x)
{
  int v4 = BIO_s_file();
  int v5 = BIO_new(v4);
  if (v5)
  {
    int v6 = v5;
    BIO_ctrl(v5, 106, 0, fp);
    int v7 = ECParameters_print(v6, x);
    BIO_free(v6);
    return v7;
  }
  else
  {
    ERR_put_error(16, 4095, 32, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/eck_prn.c", 111);
    return 0;
  }
}

int ECParameters_print(BIO *bp, const EC_KEY *x)
{
  int v4 = EVP_PKEY_new();
  int v5 = v4;
  if (v4 && EVP_PKEY_set1_EC_KEY(v4, x)) {
    int v6 = EVP_PKEY_print_params(bp, (uint64_t)v5, 4);
  }
  else {
    int v6 = 0;
  }
  EVP_PKEY_free(v5);
  return v6;
}

BOOL print_bin(BIO *a1, unsigned __int8 *a2, uint64_t a3, int a4)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  if (a4)
  {
    if (a4 >= 128) {
      int v7 = 128;
    }
    else {
      int v7 = a4;
    }
    __memset_chk();
    if (BIO_write(a1, data, v7) < 1) {
      return 0;
    }
  }
  else
  {
    int v7 = 0;
  }
  if (BIO_printf(a1, "%s", "Seed:") < 1) {
    return 0;
  }
  uint64_t v8 = 0;
  unint64_t v9 = 0;
  int v10 = v7 + 5;
  while (a3)
  {
    if (v8 - v9 / 0xF + 16 * (v9 / 0xF) || (data[0] = 10, __memset_chk(), BIO_write(a1, data, v10) >= 1))
    {
      int v12 = *a2++;
      int v11 = v12;
      ++v9;
      int v13 = --a3 ? ":" : "";
      --v8;
      if (BIO_printf(a1, "%02x%s", v11, v13) >= 1) {
        continue;
      }
    }
    return 0;
  }
  return BIO_write(a1, "\n", 1) > 0;
}

STACK *i2v_BASIC_CONSTRAINTS(uint64_t a1, uint64_t a2, STACK *a3)
{
  extlist = a3;
  if (a3)
  {
    int v4 = 0;
  }
  else
  {
    DSO_FUNC_TYPE result = sk_new_null();
    int v4 = result;
    extlist = result;
    if (!result) {
      return result;
    }
  }
  if (X509V3_add_value_BOOL("CA", *(_DWORD *)a2, &extlist)
    && X509V3_add_value_int("pathlen", *(ASN1_INTEGER **)(a2 + 8), &extlist))
  {
    return extlist;
  }
  sk_pop_free(v4, (void (__cdecl *)(void *))X509V3_conf_free);
  return 0;
}

ASN1_VALUE *v2i_BASIC_CONSTRAINTS(uint64_t a1, uint64_t a2, const STACK *a3)
{
  int v4 = ASN1_item_new(&BASIC_CONSTRAINTS_it);
  if (!v4)
  {
    ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_bcons.c", 181);
    return v4;
  }
  if (sk_num(a3) >= 1)
  {
    for (int i = 0; i < sk_num(a3); ++i)
    {
      int v6 = (CONF_VALUE *)sk_value(a3, i);
      name = v6->name;
      if (!strcmp(name, "CA"))
      {
        if (!X509V3_get_value_BOOL(v6, (int *)v4)) {
          goto LABEL_13;
        }
      }
      else
      {
        if (strcmp(name, "pathlen"))
        {
          ERR_put_error(34, 4095, 106, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_bcons.c", 193);
          ERR_asprintf_error_data("section:%s,name:%s,value:%s", v6->section, v6->name, v6->value);
LABEL_13:
          ASN1_item_free(v4, &BASIC_CONSTRAINTS_it);
          return 0;
        }
        if (!X509V3_get_value_int(v6, (ASN1_INTEGER **)v4 + 1)) {
          goto LABEL_13;
        }
      }
    }
  }
  return v4;
}

BASIC_CONSTRAINTS *__cdecl d2i_BASIC_CONSTRAINTS(BASIC_CONSTRAINTS **a, const unsigned __int8 **in, uint64_t len)
{
  return (BASIC_CONSTRAINTS *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &BASIC_CONSTRAINTS_it);
}

int i2d_BASIC_CONSTRAINTS(BASIC_CONSTRAINTS *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &BASIC_CONSTRAINTS_it);
}

BASIC_CONSTRAINTS *BASIC_CONSTRAINTS_new(void)
{
  return (BASIC_CONSTRAINTS *)ASN1_item_new(&BASIC_CONSTRAINTS_it);
}

void BASIC_CONSTRAINTS_free(BASIC_CONSTRAINTS *a)
{
}

void *CRYPTO_ccm128_init(void *result, char a2, char a3, uint64_t a4, uint64_t a5)
{
  *DSO_FUNC_TYPE result = 0;
  result[1] = 0;
  *(unsigned char *)DSO_FUNC_TYPE result = (4 * a2 + 56) & 0x38 | (a3 - 1) & 7;
  result[4] = 0;
  result[5] = a5;
  result[6] = a4;
  return result;
}

uint64_t CRYPTO_ccm128_setiv(char *a1, const void *a2, size_t a3, uint64_t a4)
{
  char v5 = *a1;
  size_t v6 = 14 - (*a1 & 7);
  if (v6 > a3) {
    return 0xFFFFFFFFLL;
  }
  if ((*a1 & 7u) < 3)
  {
    *((void *)a1 + md4_block_data_order((unint64_t)c, b, 1) = 0;
  }
  else
  {
    a1[8] = HIBYTE(a4);
    a1[9] = BYTE6(a4);
    a1[10] = BYTE5(a4);
    a1[11] = BYTE4(a4);
  }
  *((_DWORD *)a1 + 3) = bswap32(a4);
  *a1 = v5 & 0xBF;
  memcpy(a1 + 1, a2, v6);
  return 0;
}

uint64_t CRYPTO_ccm128_aad(uint64_t result, char *a2, unint64_t a3)
{
  if (a3)
  {
    unint64_t v3 = a3;
    uint64_t v5 = result;
    *(unsigned char *)result |= 0x40u;
    size_t v6 = (unsigned char *)(result + 16);
    int v7 = *(void (**)(uint64_t, uint64_t, void))(result + 40);
    v7(result, result + 16, *(void *)(result + 48));
    ++*(void *)(v5 + 32);
    if (v3 >> 8 > 0xFE)
    {
      *(unsigned char *)(v5 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = ~*(unsigned char *)(v5 + 16);
      char v10 = *(unsigned char *)(v5 + 17);
      if (HIDWORD(v3))
      {
        *(unsigned char *)(v5 + 17) = ~v10;
        uint64x2_t v11 = (uint64x2_t)vdupq_n_s64(v3);
        int32x4_t v12 = (int32x4_t)vshlq_u64(v11, (uint64x2_t)xmmword_23C701660);
        int16x8_t v13 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v11, (uint64x2_t)xmmword_23C701670), v12);
        v12.i32[0] = *(_DWORD *)(v5 + 18);
        *(int8x8_t *)v13.i8 = veor_s8((int8x8_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)v12.i8), (int8x8_t)vmovn_s32((int32x4_t)v13));
        *(_DWORD *)(v5 + 18) = vmovn_s16(v13).u32[0];
        *(unsigned char *)(v5 + 22) ^= BYTE3(v3);
        *(unsigned char *)(v5 + 23) ^= BYTE2(v3);
        *(unsigned char *)(v5 + 24) ^= BYTE1(v3);
        unint64_t v8 = 10;
        uint64_t v9 = 25;
      }
      else
      {
        *(unsigned char *)(v5 + 17) = v10 ^ 0xFE;
        *(unsigned char *)(v5 + 18) ^= BYTE3(v3);
        *(unsigned char *)(v5 + 19) ^= BYTE2(v3);
        *(unsigned char *)(v5 + 20) ^= BYTE1(v3);
        unint64_t v8 = 6;
        uint64_t v9 = 21;
      }
    }
    else
    {
      *v6 ^= BYTE1(v3);
      unint64_t v8 = 2;
      uint64_t v9 = 17;
    }
    *(unsigned char *)(v5 + v9) ^= v3;
    do
    {
      if (v3)
      {
        do
        {
          char v14 = *a2++;
          v6[v8] ^= v14;
          unint64_t v15 = v3 - 1;
          BOOL v16 = v3 != 1;
          if (v8 > 0xE) {
            break;
          }
          ++v8;
          --v3;
        }
        while (v3);
      }
      else
      {
        unint64_t v15 = 0;
        BOOL v16 = 0;
      }
      DSO_FUNC_TYPE result = ((uint64_t (*)(unsigned char *, unsigned char *, void))v7)(v6, v6, *(void *)(v5 + 48));
      unint64_t v8 = 0;
      ++*(void *)(v5 + 32);
      unint64_t v3 = v15;
    }
    while (v16);
  }
  return result;
}

int8x16_t CRYPTO_ccm128_encrypt(int8x16_t *a1, void *a2, uint64_t *a3, unint64_t a4)
{
  __int8 v8 = a1->i8[0];
  char v10 = (void (*)(int8x16_t *, int8x16_t *, uint64_t))a1[2].i64[1];
  uint64_t v9 = a1[3].i64[0];
  if ((a1->i8[0] & 0x40) == 0)
  {
    v10(a1, a1 + 1, a1[3].i64[0]);
    ++a1[2].i64[0];
  }
  a1->i8[0] = v8 & 7;
  unint64_t v12 = v8 & 7 ^ 0xFLL;
  if ((v8 & 7) != 0)
  {
    uint64_t v13 = 0;
    char v14 = &a1->u8[v12];
    unint64_t v15 = 14 - v12;
    if (v12 > 0xE) {
      unint64_t v15 = 0;
    }
    unint64_t v16 = v15 + 1;
    do
    {
      uint64_t v17 = *v14;
      *v14++ = 0;
      uint64_t v13 = (v13 | v17) << 8;
      --v16;
    }
    while (v16);
  }
  else
  {
    uint64_t v13 = 0;
  }
  uint64_t v18 = v13 | a1->u8[15];
  a1->i8[15] = 1;
  if (v18 == a4)
  {
    unint64_t v19 = a1[2].i64[0] + (((a4 + 15) >> 3) | 1);
    a1[2].i64[0] = v19;
    if (v19 <= 0x2000000000000000)
    {
      int8x16_t v26 = 0uLL;
      if (a4 >= 0x10)
      {
        do
        {
          uint64_t v20 = a1[1].i64[1];
          a1[1].i64[0] ^= *a2;
          a1[1].i64[1] = v20 ^ a2[1];
          v10(a1 + 1, a1 + 1, v9);
          v10(a1, &v26, v9);
          uint64_t v21 = 15;
          do
          {
            __int8 v22 = a1->i8[v21] + 1;
            a1->i8[v21] = v22;
            if (v21 == 8) {
              break;
            }
            --v21;
          }
          while (!v22);
          uint64_t v23 = v26.i64[1];
          *a3 = *a2 ^ v26.i64[0];
          a3[1] = a2[1] ^ v23;
          a2 += 2;
          a3 += 2;
          a4 -= 16;
        }
        while (a4 > 0xF);
      }
      if (a4)
      {
        uint64_t v24 = 0;
        do
        {
          a1[1].i8[v24] ^= *((unsigned char *)a2 + v24);
          ++v24;
        }
        while (a4 > v24);
        v10(a1 + 1, a1 + 1, v9);
        v10(a1, &v26, v9);
        uint64_t v25 = 0;
        do
        {
          *((unsigned char *)a3 + v25) = *((unsigned char *)a2 + v25) ^ v26.i8[v25];
          ++v25;
        }
        while (a4 > v25);
      }
      bzero(&a1->i8[v12], (16 - v12));
      v10(a1, &v26, v9);
      int8x16_t result = veorq_s8(a1[1], v26);
      a1[1] = result;
      a1->i8[0] = v8;
    }
  }
  return result;
}

uint64_t CRYPTO_ccm128_decrypt(int8x16_t *a1, void *a2, uint64_t *a3, unint64_t a4)
{
  __int8 v8 = a1->i8[0];
  char v10 = (void (*)(int8x16_t *, int8x16_t *, uint64_t))a1[2].i64[1];
  uint64_t v9 = a1[3].i64[0];
  if ((a1->i8[0] & 0x40) == 0) {
    v10(a1, a1 + 1, a1[3].i64[0]);
  }
  a1->i8[0] = v8 & 7;
  unint64_t v11 = v8 & 7 ^ 0xFLL;
  if ((v8 & 7) != 0)
  {
    uint64_t v12 = 0;
    uint64_t v13 = &a1->u8[v11];
    unint64_t v14 = 14 - v11;
    if (v11 > 0xE) {
      unint64_t v14 = 0;
    }
    unint64_t v15 = v14 + 1;
    do
    {
      uint64_t v16 = *v13;
      *v13++ = 0;
      uint64_t v12 = (v12 | v16) << 8;
      --v15;
    }
    while (v15);
  }
  else
  {
    uint64_t v12 = 0;
  }
  uint64_t v17 = v12 | a1->u8[15];
  a1->i8[15] = 1;
  if (v17 != a4) {
    return 0xFFFFFFFFLL;
  }
  int8x16_t v27 = 0uLL;
  if (a4 >= 0x10)
  {
    do
    {
      v10(a1, &v27, v9);
      uint64_t v18 = 15;
      do
      {
        __int8 v19 = a1->i8[v18] + 1;
        a1->i8[v18] = v19;
        if (v18 == 8) {
          break;
        }
        --v18;
      }
      while (!v19);
      uint64_t v20 = v27.i64[1];
      uint64_t v21 = *a2 ^ v27.i64[0];
      *a3 = v21;
      a1[1].i64[0] ^= v21;
      uint64_t v22 = a2[1] ^ v20;
      a3[1] = v22;
      a1[1].i64[1] ^= v22;
      v10(a1 + 1, a1 + 1, v9);
      a2 += 2;
      a3 += 2;
      a4 -= 16;
    }
    while (a4 > 0xF);
  }
  if (a4)
  {
    v10(a1, &v27, v9);
    uint64_t v23 = 0;
    uint64_t v24 = a1 + 1;
    do
    {
      char v25 = *((unsigned char *)a2 + v23) ^ v27.i8[v23];
      *((unsigned char *)a3 + v23) = v25;
      v24->i8[v23++] ^= v25;
    }
    while (a4 > v23);
    v10(v24, a1 + 1, v9);
  }
  bzero(&a1->i8[v11], (16 - v11));
  v10(a1, &v27, v9);
  uint64_t result = 0;
  a1[1] = veorq_s8(a1[1], v27);
  a1->i8[0] = v8;
  return result;
}

int8x16_t CRYPTO_ccm128_encrypt_ccm64(int8x16_t *a1, char *a2, unsigned char *a3, unint64_t a4, void (*a5)(char *, unsigned char *, unint64_t, uint64_t, int8x16_t *, int8x16_t *))
{
  __int8 v10 = a1->i8[0];
  uint64_t v12 = (void (*)(int8x16_t *, int8x16_t *, uint64_t))a1[2].i64[1];
  uint64_t v11 = a1[3].i64[0];
  if ((a1->i8[0] & 0x40) == 0)
  {
    v12(a1, a1 + 1, a1[3].i64[0]);
    ++a1[2].i64[0];
  }
  a1->i8[0] = v10 & 7;
  unint64_t v14 = v10 & 7 ^ 0xFLL;
  if ((v10 & 7) != 0)
  {
    uint64_t v15 = 0;
    uint64_t v16 = &a1->u8[v14];
    unint64_t v17 = 14 - v14;
    if (v14 > 0xE) {
      unint64_t v17 = 0;
    }
    unint64_t v18 = v17 + 1;
    do
    {
      uint64_t v19 = *v16;
      *v16++ = 0;
      uint64_t v15 = (v15 | v19) << 8;
      --v18;
    }
    while (v18);
  }
  else
  {
    uint64_t v15 = 0;
  }
  uint64_t v20 = v15 | a1->u8[15];
  a1->i8[15] = 1;
  if (v20 == a4)
  {
    unint64_t v21 = a1[2].i64[0] + (((a4 + 15) >> 3) | 1);
    a1[2].i64[0] = v21;
    if (v21 <= 0x2000000000000000)
    {
      int8x16_t v33 = 0uLL;
      if (a4 >= 0x10)
      {
        unint64_t v22 = a4 >> 4;
        a5(a2, a3, a4 >> 4, v11, a1, a1 + 1);
        if ((a4 & 0xF) == 0)
        {
LABEL_26:
          bzero(&a1->i8[v14], (16 - v14));
          v12(a1, &v33, v11);
          int8x16_t result = veorq_s8(a1[1], v33);
          a1[1] = result;
          a1->i8[0] = v10;
          return result;
        }
        unint64_t v23 = 0;
        a2 += a4 & 0xFFFFFFFFFFFFFFF0;
        a3 += a4 & 0xFFFFFFFFFFFFFFF0;
        uint64_t v24 = 15;
        while (1)
        {
          unint64_t v25 = v23 + v22 + a1->u8[v24];
          a1->i8[v24] = v25;
          if (v24 == 8) {
            break;
          }
          unint64_t v26 = v22 >> 8;
          unint64_t v23 = v25 >> 8;
          --v24;
          BOOL v27 = v22 > 0xFF;
          v22 >>= 8;
          if (!v27)
          {
            unint64_t v22 = v26;
            if (v25 <= 0xFF) {
              break;
            }
          }
        }
        a4 &= 0xFu;
      }
      if (a4)
      {
        uint64_t v28 = 0;
        do
        {
          a1[1].i8[v28] ^= a2[v28];
          ++v28;
        }
        while (a4 != v28);
        v12(a1 + 1, a1 + 1, v11);
        int v29 = &v33;
        v12(a1, &v33, v11);
        do
        {
          __int8 v31 = v29->i8[0];
          int v29 = (int8x16_t *)((char *)v29 + 1);
          __int8 v30 = v31;
          char v32 = *a2++;
          *a3++ = v32 ^ v30;
          --a4;
        }
        while (a4);
      }
      goto LABEL_26;
    }
  }
  return result;
}

uint64_t CRYPTO_ccm128_decrypt_ccm64(int8x16_t *a1, char *a2, unsigned char *a3, unint64_t a4, void (*a5)(char *, unsigned char *, unint64_t, uint64_t, int8x16_t *, int8x16_t *))
{
  __int8 v10 = a1->i8[0];
  uint64_t v12 = (void (*)(int8x16_t *, int8x16_t *, uint64_t))a1[2].i64[1];
  uint64_t v11 = a1[3].i64[0];
  if ((a1->i8[0] & 0x40) == 0) {
    v12(a1, a1 + 1, a1[3].i64[0]);
  }
  a1->i8[0] = v10 & 7;
  unint64_t v13 = v10 & 7 ^ 0xFLL;
  if ((v10 & 7) != 0)
  {
    uint64_t v14 = 0;
    uint64_t v15 = &a1->u8[v13];
    unint64_t v16 = 14 - v13;
    if (v13 > 0xE) {
      unint64_t v16 = 0;
    }
    unint64_t v17 = v16 + 1;
    do
    {
      uint64_t v18 = *v15;
      *v15++ = 0;
      uint64_t v14 = (v14 | v18) << 8;
      --v17;
    }
    while (v17);
  }
  else
  {
    uint64_t v14 = 0;
  }
  uint64_t v19 = v14 | a1->u8[15];
  a1->i8[15] = 1;
  if (v19 == a4)
  {
    int8x16_t v33 = 0uLL;
    if (a4 >= 0x10)
    {
      unint64_t v20 = a4 >> 4;
      a5(a2, a3, a4 >> 4, v11, a1, a1 + 1);
      if ((a4 & 0xF) == 0)
      {
LABEL_22:
        bzero(&a1->i8[v13], (16 - v13));
        v12(a1, &v33, v11);
        uint64_t result = 0;
        a1[1] = veorq_s8(a1[1], v33);
        a1->i8[0] = v10;
        return result;
      }
      unint64_t v21 = 0;
      a2 += a4 & 0xFFFFFFFFFFFFFFF0;
      a3 += a4 & 0xFFFFFFFFFFFFFFF0;
      uint64_t v22 = 15;
      while (1)
      {
        unint64_t v23 = v21 + v20 + a1->u8[v22];
        a1->i8[v22] = v23;
        if (v22 == 8) {
          break;
        }
        unint64_t v24 = v20 >> 8;
        unint64_t v21 = v23 >> 8;
        --v22;
        BOOL v25 = v20 > 0xFF;
        v20 >>= 8;
        if (!v25)
        {
          unint64_t v20 = v24;
          if (v23 <= 0xFF) {
            break;
          }
        }
      }
      a4 &= 0xFu;
    }
    if (a4)
    {
      unint64_t v26 = &v33;
      v12(a1, &v33, v11);
      BOOL v27 = a1 + 1;
      do
      {
        __int8 v29 = v26->i8[0];
        unint64_t v26 = (int8x16_t *)((char *)v26 + 1);
        __int8 v28 = v29;
        char v30 = *a2++;
        char v31 = v30 ^ v28;
        *a3++ = v31;
        v27->i8[0] ^= v31;
        BOOL v27 = (int8x16_t *)((char *)v27 + 1);
        --a4;
      }
      while (a4);
      v12(a1 + 1, a1 + 1, v11);
    }
    goto LABEL_22;
  }
  return 0xFFFFFFFFLL;
}

size_t CRYPTO_ccm128_tag(unsigned __int8 *a1, void *__dst, size_t a3)
{
  if ((((unint64_t)*a1 >> 2) & 0xE) + 2 != a3) {
    return 0;
  }
  size_t v3 = a3;
  memcpy(__dst, a1 + 16, a3);
  return v3;
}

ASN1_ENUMERATED *ASN1_ENUMERATED_new(void)
{
  return (ASN1_ENUMERATED *)ASN1_item_new(&ASN1_ENUMERATED_it);
}

void ASN1_ENUMERATED_free(ASN1_ENUMERATED *a)
{
}

uint64_t ASN1_ENUMERATED_get_int64(uint64_t *a1, unsigned int *a2)
{
  *a1 = 0;
  if (a2)
  {
    uint64_t v3 = *a2;
    if ((v3 & 0x80000000) == 0)
    {
      if ((a2[1] | 0x100) == 0x10A)
      {
        memset(v6, 0, sizeof(v6));
        CBS_init(v6, *((void *)a2 + 1), v3);
        return asn1_aint_get_int64(v6, a2[1] == 266, a1);
      }
      ERR_put_error(13, 4095, 225, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_enum.c", 116);
    }
  }
  return 0;
}

uint64_t ASN1_ENUMERATED_set_int64(int *a1, unint64_t a2)
{
  int v4 = a1 + 2;
  freezero(*((void **)a1 + 1), *a1);
  *(void *)a1 = 0;
  void *v4 = 0;
  *((void *)a1 + 2) = 0;
  a1[1] = 10;
  if ((a2 & 0x8000000000000000) != 0)
  {
    a1[1] = 266;
    a2 = -(uint64_t)a2;
  }
  return asn1_aint_set_uint64(a2, v4, a1);
}

uint64_t ASN1_ENUMERATED_get(uint64_t a)
{
  if (a)
  {
    uint64_t v1 = 0;
    if (ASN1_ENUMERATED_get_int64(&v1, (unsigned int *)a)) {
      return v1;
    }
    else {
      return -1;
    }
  }
  return a;
}

ASN1_ENUMERATED *__cdecl BN_to_ASN1_ENUMERATED(BIGNUM *bn, ASN1_ENUMERATED *ai)
{
  int v4 = ai;
  if (ai || (int v4 = (ASN1_ENUMERATED *)ASN1_item_new(&ASN1_ENUMERATED_it)) != 0)
  {
    if (BN_is_negative((uint64_t)bn)) {
      int v5 = 266;
    }
    else {
      int v5 = 10;
    }
    v4->int type = v5;
    int v6 = BN_num_bits(bn);
    int v7 = v6 / 8 + 5;
    if (!v6) {
      int v7 = 4;
    }
    unsigned int data = v4->data;
    if (v4->length >= v7) {
      goto LABEL_11;
    }
    uint64_t v9 = (unsigned __int8 *)malloc_type_realloc(v4->data, v7, 0x20ECF1CEuLL);
    if (v9)
    {
      unsigned int data = v9;
      v4->unsigned int data = v9;
LABEL_11:
      int v10 = BN_bn2bin(bn, data);
      v4->int length = v10;
      if (!v10)
      {
        *v4->unsigned int data = 0;
        v4->int length = 1;
      }
      return v4;
    }
    int v11 = 65;
    int v12 = 189;
  }
  else
  {
    int v11 = 58;
    int v12 = 177;
  }
  ERR_put_error(13, 4095, v11, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_enum.c", v12);
  if (v4 != ai) {
    ASN1_item_free((ASN1_VALUE *)v4, &ASN1_ENUMERATED_it);
  }
  return 0;
}

BIGNUM *__cdecl ASN1_ENUMERATED_to_BN(ASN1_ENUMERATED *ai, BIGNUM *bn)
{
  uint64_t v3 = BN_bin2bn(ai->data, ai->length, bn);
  int v4 = v3;
  if (v3)
  {
    if (ai->type == 266) {
      BN_set_negative(v3, 1);
    }
  }
  else
  {
    ERR_put_error(13, 4095, 105, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_enum.c", 215);
  }
  return v4;
}

int i2a_ASN1_ENUMERATED(BIO *bp, ASN1_ENUMERATED *a)
{
  if (!a) {
    return 0;
  }
  if (a->length)
  {
    if (a->length >= 1)
    {
      uint64_t v4 = 0;
      int v5 = 0;
      while (1)
      {
        if (v4 && !(v4 % 0x23))
        {
          if (BIO_write(bp, "\\\n", 2) != 2) {
            return -1;
          }
          v5 += 2;
        }
        int v6 = a->data;
        data[0] = i2a_ASN1_ENUMERATED_h[(unint64_t)v6[v4] >> 4];
        data[1] = i2a_ASN1_ENUMERATED_h[v6[v4] & 0xF];
        if (BIO_write(bp, data, 2) != 2) {
          break;
        }
        v5 += 2;
        if (++v4 >= a->length) {
          return v5;
        }
      }
      return -1;
    }
    return 0;
  }
  int v5 = 2;
  if (BIO_write(bp, "00", 2) != 2) {
    return -1;
  }
  return v5;
}

int a2i_ASN1_ENUMERATED(BIO *bp, ASN1_ENUMERATED *bs, char *buf, int size)
{
  bs->int type = 10;
  int v6 = BIO_gets(bp, buf, size);
  if (v6 >= 1)
  {
    int8x16_t v33 = bs;
    unint64_t v7 = 0;
    uint64_t v8 = 0;
    char v9 = 0;
    int v10 = 0;
    while (1)
    {
      uint64_t v11 = (v6 - 1);
      int v12 = v11;
      if (buf[v11] == 10)
      {
        buf[v11] = 0;
        if (v6 == 1) {
          goto LABEL_47;
        }
        uint64_t v11 = (v6 - 2);
        unsigned int v13 = v6 - 2;
      }
      else
      {
        unsigned int v13 = v6 - 1;
        int v12 = v6;
      }
      if (buf[v11] == 13)
      {
        buf[v11] = 0;
        if (!v13) {
          goto LABEL_47;
        }
        uint64_t v11 = v13 - 1;
        unsigned int v14 = v13 - 1;
      }
      else
      {
        unsigned int v14 = v13;
        unsigned int v13 = v12;
      }
      int v15 = buf[v11];
      if (v15 == 92) {
        unsigned int v16 = v14;
      }
      else {
        unsigned int v16 = v13;
      }
      buf[v16] = 0;
      if (v16 < 2)
      {
LABEL_47:
        uint64_t v19 = v10;
        goto LABEL_44;
      }
      if (v9)
      {
        unint64_t v17 = buf;
      }
      else
      {
        unint64_t v17 = buf;
        if (*buf == 48)
        {
          if (buf[1] == 48) {
            v16 -= 2;
          }
          unint64_t v17 = &buf[2 * (buf[1] == 48)];
        }
      }
      if (v16) {
        break;
      }
      uint64_t v18 = v16 >> 1;
      if (v8 + v18 <= v7)
      {
        uint64_t v19 = v10;
      }
      else
      {
        uint64_t v19 = (unsigned __int8 *)malloc_type_realloc(v10, v8 + v18, 0x9E905177uLL);
        unint64_t v7 = v8 + v18;
        if (!v19)
        {
          int v31 = 65;
          int v32 = 308;
LABEL_49:
          ERR_put_error(13, 4095, v31, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_enum.c", v32);
          goto LABEL_46;
        }
      }
      if (v16 >= 2)
      {
        uint64_t v20 = 0;
        uint64_t v21 = 0;
        if (v18 <= 1) {
          uint64_t v22 = 1;
        }
        else {
          uint64_t v22 = v18;
        }
        while (2)
        {
          uint64_t v23 = 0;
          char v24 = 1;
          do
          {
            char v25 = v24;
            int v26 = v17[v23 | v21];
            char v27 = v26 - 48;
            if ((v26 - 48) >= 0xA)
            {
              if ((v26 - 97) > 5)
              {
                if ((v26 - 65) > 5)
                {
                  int v28 = 141;
                  int v29 = 324;
                  goto LABEL_45;
                }
                char v27 = v26 - 55;
              }
              else
              {
                char v27 = v26 - 87;
              }
            }
            char v24 = 0;
            v19[v8 + v20] = v27 | (16 * v19[v8 + v20]);
            uint64_t v23 = 1;
          }
          while ((v25 & 1) != 0);
          ++v20;
          v21 += 2;
          if (v20 != v22) {
            continue;
          }
          break;
        }
      }
      if (v15 != 92)
      {
        v33->int length = v8 + v18;
        v33->unsigned int data = v19;
        return 1;
      }
      int v6 = BIO_gets(bp, buf, size);
      char v9 = 1;
      v8 += v18;
      int v10 = v19;
      if (v6 < 1) {
        goto LABEL_44;
      }
    }
    int v31 = 145;
    int v32 = 301;
    goto LABEL_49;
  }
  uint64_t v19 = 0;
LABEL_44:
  int v28 = 150;
  int v29 = 342;
LABEL_45:
  ERR_put_error(13, 4095, v28, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/a_enum.c", v29);
  int v10 = v19;
LABEL_46:
  free(v10);
  return 0;
}

uint64_t c2i_ASN1_ENUMERATED_cbs(uint64_t result, void *a2)
{
  int v6 = 0;
  if (result)
  {
    uint64_t v3 = (void *)result;
    uint64_t v4 = *(ASN1_INTEGER **)result;
    if (v4)
    {
      ASN1_INTEGER_free(v4);
      void *v3 = 0;
    }
    uint64_t result = c2i_ASN1_INTEGER_cbs(&v6, a2);
    if (result)
    {
      int v5 = v6;
      *((_DWORD *)v6 + md4_block_data_order((unint64_t)c, b, 1) = *((_DWORD *)v6 + 1) & 0x100 | 0xA;
      void *v3 = v5;
      return 1;
    }
  }
  return result;
}

int i2d_ASN1_ENUMERATED(ASN1_ENUMERATED *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &ASN1_ENUMERATED_it);
}

ASN1_ENUMERATED *__cdecl d2i_ASN1_ENUMERATED(ASN1_ENUMERATED **a, const unsigned __int8 **in, uint64_t len)
{
  return (ASN1_ENUMERATED *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &ASN1_ENUMERATED_it);
}

const EVP_CIPHER *EVP_rc2_cbc(void)
{
  return (const EVP_CIPHER *)&rc2_cbc;
}

const EVP_CIPHER *EVP_rc2_cfb64(void)
{
  return (const EVP_CIPHER *)&rc2_cfb64;
}

const EVP_CIPHER *EVP_rc2_ofb(void)
{
  return (const EVP_CIPHER *)&rc2_ofb;
}

const EVP_CIPHER *EVP_rc2_ecb(void)
{
  return (const EVP_CIPHER *)&rc2_ecb;
}

const EVP_CIPHER *EVP_rc2_64_cbc(void)
{
  return (const EVP_CIPHER *)&r2_64_cbc_cipher;
}

const EVP_CIPHER *EVP_rc2_40_cbc(void)
{
  return (const EVP_CIPHER *)&r2_40_cbc_cipher;
}

uint64_t rc2_init_key(uint64_t a1, const unsigned __int8 *a2)
{
  uint64_t v4 = (RC2_KEY *)(*(void *)(a1 + 120) + 4);
  int v5 = EVP_CIPHER_CTX_key_length((const EVP_CIPHER_CTX *)a1);
  RC2_set_key(v4, v5, a2, **(_DWORD **)(a1 + 120));
  return 1;
}

uint64_t rc2_cbc_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t length)
{
  for (unint64_t i = length; i > 0x7FFFFFFFFFFFFEFFLL; out += 0x7FFFFFFFFFFFFF00)
  {
    RC2_cbc_encrypt(in, out, 0x7FFFFFFFFFFFFF00, (RC2_KEY *)(*(void *)(a1 + 120) + 4), (unsigned __int8 *)(a1 + 40), *(_DWORD *)(a1 + 16));
    i -= 0x7FFFFFFFFFFFFF00;
    in += 0x7FFFFFFFFFFFFF00;
  }
  if (i) {
    RC2_cbc_encrypt(in, out, i, (RC2_KEY *)(*(void *)(a1 + 120) + 4), (unsigned __int8 *)(a1 + 40), *(_DWORD *)(a1 + 16));
  }
  return 1;
}

uint64_t rc2_set_asn1_type_and_iv(EVP_CIPHER_CTX *a1, ASN1_TYPE *a2)
{
  if (!a2) {
    return 0;
  }
  int ptr = 0;
  if (EVP_CIPHER_CTX_ctrl(a1, 2, 0, &ptr) < 1)
  {
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v4 = 58;
    uint64_t v5 = 120;
    if (ptr != 64) {
      uint64_t v5 = 0;
    }
    if (ptr != 128) {
      uint64_t v4 = v5;
    }
    if (ptr == 40) {
      uint64_t v6 = 160;
    }
    else {
      uint64_t v6 = v4;
    }
  }
  int v8 = EVP_CIPHER_CTX_iv_length(a1);
  return ASN1_TYPE_set_int_octetstring(a2, v6, a1->oiv, v8);
}

uint64_t rc2_get_asn1_type_and_iv(EVP_CIPHER_CTX *a1, ASN1_TYPE *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v10 = 0;
  if (!a2) {
    return 0;
  }
  uint64_t v4 = EVP_CIPHER_CTX_iv_length(a1);
  if (v4 >= 0x11)
  {
    int v5 = 102;
    int v6 = 347;
LABEL_4:
    ERR_put_error(6, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/evp/e_rc2.c", v6);
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = v4;
  if (ASN1_TYPE_get_int_octetstring(a2, &v10, data, v4) != v4) {
    return 0xFFFFFFFFLL;
  }
  switch(v10)
  {
    case 0x3A:
      unsigned int v8 = 128;
      if (v7) {
        goto LABEL_15;
      }
      break;
    case 0xA0:
      unsigned int v8 = 40;
      if (v7)
      {
LABEL_15:
        if (!EVP_CipherInit_ex(a1, 0, 0, 0, data, -1)) {
          return 0xFFFFFFFFLL;
        }
      }
      break;
    case 0x78:
      unsigned int v8 = 64;
      if (!v7) {
        break;
      }
      goto LABEL_15;
    default:
      int v5 = 108;
      int v6 = 330;
      goto LABEL_4;
  }
  if (EVP_CIPHER_CTX_ctrl(a1, 3, v8, 0) < 1 || !EVP_CIPHER_CTX_set_key_length(a1, v8 >> 3)) {
    return 0xFFFFFFFFLL;
  }
  return v7;
}

uint64_t rc2_ctrl(EVP_CIPHER_CTX *ctx, int a2, int a3, _DWORD *a4)
{
  switch(a2)
  {
    case 3:
      if (a3 >= 1)
      {
        *(_DWORD *)ctx->cipher_unsigned int data = a3;
        return 1;
      }
      return 0;
    case 2:
      *a4 = *(_DWORD *)ctx->cipher_data;
      return 1;
    case 0:
      *(_DWORD *)ctx->cipher_unsigned int data = 8 * EVP_CIPHER_CTX_key_length(ctx);
      return 1;
    default:
      return 0xFFFFFFFFLL;
  }
}

uint64_t rc2_cfb64_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t a4)
{
  if (a4)
  {
    unint64_t v4 = a4;
    if (a4 >= 0x7FFFFFFFFFFFFF00) {
      unint64_t v8 = 0x7FFFFFFFFFFFFF00;
    }
    else {
      unint64_t v8 = a4;
    }
    char v9 = (unsigned __int8 *)(a1 + 40);
    uint64_t v10 = (int *)(a1 + 88);
    do
    {
      RC2_cfb64_encrypt(in, out, v8, (RC2_KEY *)(*(void *)(a1 + 120) + 4), v9, v10, *(_DWORD *)(a1 + 16));
      in += v8;
      out += v8;
      v4 -= v8;
      if (v4 < v8) {
        unint64_t v8 = v4;
      }
    }
    while (v4);
  }
  return 1;
}

uint64_t rc2_ofb_cipher(uint64_t a1, unsigned __int8 *out, unsigned __int8 *in, unint64_t length)
{
  for (unint64_t i = length; i > 0x7FFFFFFFFFFFFEFFLL; out += 0x7FFFFFFFFFFFFF00)
  {
    RC2_ofb64_encrypt(in, out, 0x7FFFFFFFFFFFFF00, (RC2_KEY *)(*(void *)(a1 + 120) + 4), (unsigned __int8 *)(a1 + 40), (int *)(a1 + 88));
    i -= 0x7FFFFFFFFFFFFF00;
    in += 0x7FFFFFFFFFFFFF00;
  }
  if (i) {
    RC2_ofb64_encrypt(in, out, i, (RC2_KEY *)(*(void *)(a1 + 120) + 4), (unsigned __int8 *)(a1 + 40), (int *)(a1 + 88));
  }
  return 1;
}

uint64_t rc2_ecb_cipher(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4 = *(int *)(*(void *)a1 + 4);
  unint64_t v5 = a4 - v4;
  if (a4 >= v4)
  {
    unint64_t v9 = 0;
    do
    {
      RC2_ecb_encrypt((const unsigned __int8 *)(a3 + v9), (unsigned __int8 *)(a2 + v9), (RC2_KEY *)(*(void *)(a1 + 120) + 4), *(_DWORD *)(a1 + 16));
      v9 += v4;
    }
    while (v9 <= v5);
  }
  return 1;
}

void DES_ecb3_encrypt(const_DES_cblock *input, DES_cblock *output, DES_key_schedule *ks1, DES_key_schedule *ks2, DES_key_schedule *ks3, int enc)
{
  v9[1] = *MEMORY[0x263EF8340];
  v9[0] = *(void *)input;
  if (enc) {
    DES_encrypt3((unsigned int *)v9, ks1, ks2, ks3);
  }
  else {
    DES_decrypt3((unsigned int *)v9, ks1, ks2, ks3);
  }
  __int16 v7 = WORD1(v9[0]);
  int v8 = HIDWORD(v9[0]);
  *(_WORD *)output = v9[0];
  *(_WORD *)&(*output)[2] = v7;
  *(_DWORD *)&(*output)[4] = v8;
}

void *EVP_chacha20()
{
  return &chacha20_cipher;
}

uint64_t chacha_init(EVP_CIPHER_CTX *ctx, _DWORD *a2, _DWORD *a3)
{
  if (a2)
  {
    cipher_unsigned int data = ctx->cipher_data;
    int v7 = EVP_CIPHER_CTX_key_length(ctx);
    ChaCha_set_key((uint64_t)cipher_data, a2, 8 * v7);
  }
  if (a3) {
    ChaCha_set_iv((uint64_t)ctx->cipher_data, a3 + 2, a3);
  }
  return 1;
}

uint64_t chacha_cipher(uint64_t a1, int *a2, char *a3, unint64_t a4)
{
  return 1;
}

ENGINE *ENGINE_get_first(void)
{
  CRYPTO_lock(9, 30, 0, 0);
  BOOL v0 = (ENGINE *)engine_list_head;
  if (engine_list_head) {
    ++*(_DWORD *)(engine_list_head + 180);
  }
  CRYPTO_lock(10, 30, 0, 0);
  return v0;
}

ENGINE *ENGINE_get_last(void)
{
  CRYPTO_lock(9, 30, 0, 0);
  BOOL v0 = (ENGINE *)engine_list_tail;
  if (engine_list_tail) {
    ++*(_DWORD *)(engine_list_tail + 180);
  }
  CRYPTO_lock(10, 30, 0, 0);
  return v0;
}

ENGINE *__cdecl ENGINE_get_next(ENGINE *e)
{
  if (e)
  {
    CRYPTO_lock(9, 30, 0, 0);
    uint64_t v2 = *((void *)e + 26);
    if (v2) {
      ++*(_DWORD *)(v2 + 180);
    }
    CRYPTO_lock(10, 30, 0, 0);
    ENGINE_free(e);
  }
  else
  {
    ERR_put_error(38, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_list.c", 220);
    return 0;
  }
  return (ENGINE *)v2;
}

ENGINE *__cdecl ENGINE_get_prev(ENGINE *e)
{
  if (e)
  {
    CRYPTO_lock(9, 30, 0, 0);
    uint64_t v2 = *((void *)e + 25);
    if (v2) {
      ++*(_DWORD *)(v2 + 180);
    }
    CRYPTO_lock(10, 30, 0, 0);
    ENGINE_free(e);
  }
  else
  {
    ERR_put_error(38, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_list.c", 242);
    return 0;
  }
  return (ENGINE *)v2;
}

int ENGINE_add(ENGINE *e)
{
  uint64_t v1 = e;
  if (e)
  {
    if (!*(void *)e || !*((void *)e + 1)) {
      ERR_put_error(38, 4095, 108, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_list.c", 269);
    }
    CRYPTO_lock(9, 30, 0, 0);
    uint64_t v2 = engine_list_head;
    if (engine_list_head)
    {
      uint64_t v3 = *(const char **)v1;
      do
      {
        int v4 = strcmp(*(const char **)v2, v3);
        uint64_t v2 = *(void *)(v2 + 208);
        if (v2) {
          BOOL v5 = v4 == 0;
        }
        else {
          BOOL v5 = 1;
        }
      }
      while (!v5);
      if (!v4)
      {
        int v7 = 103;
        int v8 = 117;
        goto LABEL_20;
      }
      uint64_t v6 = engine_list_tail;
      if (!engine_list_tail || *(void *)(engine_list_tail + 208))
      {
        int v7 = 110;
        int v8 = 135;
LABEL_20:
        ERR_put_error(38, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_list.c", v8);
        ERR_put_error(38, 4095, 110, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_list.c", 273);
        LODWORD(vmd4_block_data_order((unint64_t)c, b, 1) = 0;
LABEL_24:
        CRYPTO_lock(10, 30, 0, 0);
        return (int)v1;
      }
      *(void *)(engine_list_tail + 208) = v1;
      *((void *)v1 + 25) = v6;
    }
    else
    {
      if (engine_list_tail)
      {
        int v7 = 110;
        int v8 = 123;
        goto LABEL_20;
      }
      engine_list_heaunsigned int d = (uint64_t)v1;
      *((void *)v1 + 25) = 0;
      engine_cleanup_add_last((uint64_t)engine_list_cleanup);
    }
    ++*((_DWORD *)v1 + 45);
    engine_list_tail = (uint64_t)v1;
    *((void *)v1 + 26) = 0;
    LODWORD(vmd4_block_data_order((unint64_t)c, b, 1) = 1;
    goto LABEL_24;
  }
  ERR_put_error(38, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_list.c", 265);
  return (int)v1;
}

int ENGINE_remove(ENGINE *e)
{
  uint64_t v1 = e;
  if (e)
  {
    CRYPTO_lock(9, 30, 0, 0);
    uint64_t v2 = &engine_list_head;
    do
    {
      uint64_t v3 = (ENGINE *)*v2;
      uint64_t v2 = (uint64_t *)(*v2 + 208);
      if (v3) {
        BOOL v4 = v3 == v1;
      }
      else {
        BOOL v4 = 1;
      }
    }
    while (!v4);
    if (v3)
    {
      uint64_t v5 = *((void *)v1 + 26);
      if (v5) {
        *(void *)(v5 + 20RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = *((void *)v1 + 25);
      }
      uint64_t v6 = *((void *)v1 + 25);
      if (v6) {
        *(void *)(v6 + 208) = v5;
      }
      if ((ENGINE *)engine_list_head == v1) {
        engine_list_heaunsigned int d = *((void *)v1 + 26);
      }
      if ((ENGINE *)engine_list_tail == v1) {
        engine_list_tail = v6;
      }
      engine_free_util((CRYPTO_EX_DATA *)v1, 0);
      LODWORD(vmd4_block_data_order((unint64_t)c, b, 1) = 1;
    }
    else
    {
      ERR_put_error(38, 4095, 105, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_list.c", 165);
      ERR_put_error(38, 4095, 110, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_list.c", 292);
      LODWORD(vmd4_block_data_order((unint64_t)c, b, 1) = 0;
    }
    CRYPTO_lock(10, 30, 0, 0);
  }
  else
  {
    ERR_put_error(38, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_list.c", 287);
  }
  return (int)v1;
}

ENGINE *__cdecl ENGINE_by_id(const char *id)
{
  if (id)
  {
    CRYPTO_lock(9, 30, 0, 0);
    uint64_t v2 = engine_list_head;
    if (engine_list_head)
    {
      while (strcmp(id, *(const char **)v2))
      {
        uint64_t v2 = *(void *)(v2 + 208);
        if (!v2) {
          goto LABEL_5;
        }
      }
      if ((*(unsigned char *)(v2 + 176) & 4) == 0)
      {
        ++*(_DWORD *)(v2 + 180);
LABEL_13:
        CRYPTO_lock(10, 30, 0, 0);
        return (ENGINE *)v2;
      }
      BOOL v4 = ENGINE_new();
      if (v4)
      {
        *(_OWORD *)BOOL v4 = *(_OWORD *)v2;
        *((_OWORD *)v4 + md4_block_data_order((unint64_t)c, b, 1) = *(_OWORD *)(v2 + 16);
        *((_OWORD *)v4 + 2) = *(_OWORD *)(v2 + 32);
        *((_OWORD *)v4 + 3) = *(_OWORD *)(v2 + 48);
        *((_OWORD *)v4 + 4) = *(_OWORD *)(v2 + 64);
        *((_OWORD *)v4 + 5) = *(_OWORD *)(v2 + 80);
        *((void *)v4 + 12) = *(void *)(v2 + 96);
        *((_OWORD *)v4 + 7) = *(_OWORD *)(v2 + 112);
        *((_OWORD *)v4 + 8) = *(_OWORD *)(v2 + 128);
        *((_OWORD *)v4 + 9) = *(_OWORD *)(v2 + 144);
        *((void *)v4 + 2md4_block_data_order((unint64_t)c, b, 1) = *(void *)(v2 + 168);
        *((_DWORD *)v4 + 44) = *(_DWORD *)(v2 + 176);
        uint64_t v2 = (uint64_t)v4;
        goto LABEL_13;
      }
    }
LABEL_5:
    CRYPTO_lock(10, 30, 0, 0);
    ERR_put_error(38, 4095, 116, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_list.c", 370);
    ERR_asprintf_error_data("id=%s", id);
  }
  else
  {
    ERR_put_error(38, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_list.c", 343);
  }
  return 0;
}

int ENGINE_up_ref(ENGINE *e)
{
  if (e) {
    return CRYPTO_add_lock((int *)e + 45, 1, 30, 0, 0) > 1;
  }
  ERR_put_error(38, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/engine/eng_list.c", 382);
  return 0;
}

uint64_t engine_list_cleanup()
{
  do
  {
    uint64_t result = engine_list_head;
    if (!engine_list_head) {
      break;
    }
    uint64_t result = ENGINE_remove((ENGINE *)engine_list_head);
  }
  while (result);
  return result;
}

X509_ATTRIBUTE *__cdecl d2i_X509_ATTRIBUTE(X509_ATTRIBUTE **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_ATTRIBUTE *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_ATTRIBUTE_it);
}

int i2d_X509_ATTRIBUTE(X509_ATTRIBUTE *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_ATTRIBUTE_it);
}

X509_ATTRIBUTE *X509_ATTRIBUTE_new(void)
{
  return (X509_ATTRIBUTE *)ASN1_item_new(&X509_ATTRIBUTE_it);
}

void X509_ATTRIBUTE_free(X509_ATTRIBUTE *a)
{
}

X509_ATTRIBUTE *__cdecl X509_ATTRIBUTE_dup(X509_ATTRIBUTE *xa)
{
  return (X509_ATTRIBUTE *)ASN1_item_dup(&X509_ATTRIBUTE_it, xa);
}

X509_ATTRIBUTE *__cdecl X509_ATTRIBUTE_create(int nid, int atrtype, void *value)
{
  uint64_t v5 = OBJ_nid2obj(nid);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v5;
  int v7 = ASN1_item_new(&X509_ATTRIBUTE_it);
  int v8 = v7;
  if (v7)
  {
    *(void *)int v7 = v6;
    unint64_t v9 = (char *)ASN1_TYPE_new();
    if (v9)
    {
      uint64_t v10 = (ASN1_TYPE *)v9;
      if (sk_push(*((STACK **)v8 + 1), v9))
      {
        ASN1_TYPE_set(v10, atrtype, value);
        return (X509_ATTRIBUTE *)v8;
      }
      ASN1_item_free(v8, &X509_ATTRIBUTE_it);
      ASN1_TYPE_free(v10);
    }
    else
    {
      ASN1_item_free(v8, &X509_ATTRIBUTE_it);
    }
    return 0;
  }
  return (X509_ATTRIBUTE *)v8;
}

const char *RC4_options(void)
{
  return "rc4(ptr,int)";
}

void RC4_set_key(RC4_KEY *key, int len, const unsigned __int8 *data)
{
  uint64_t v3 = 0;
  BOOL v4 = &key->data[6];
  *(void *)&key->x = 0;
  int32x4_t v5 = (int32x4_t)xmmword_23C7163C0;
  v6.i64[0] = 0x400000004;
  v6.i64[1] = 0x400000004;
  do
  {
    *(int32x4_t *)&v4[v3] = v5;
    int32x4_t v5 = vaddq_s32(v5, v6);
    v3 += 16;
  }
  while (v3 != 1024);
  unint64_t v7 = 0;
  unsigned __int8 v8 = 0;
  int v9 = 0;
  do
  {
    uint64_t v10 = &key->x + 4 * v7;
    int v11 = *((_DWORD *)v10 + 2);
    unsigned __int8 v12 = v11 + v8 + data[v9];
    if (v9 + 1 == len) {
      int v13 = 0;
    }
    else {
      int v13 = v9 + 1;
    }
    *((_DWORD *)v10 + 2) = *(_DWORD *)&v4[4 * v12];
    *(_DWORD *)&v4[4 * v12] = v11;
    int v14 = *((_DWORD *)v10 + 3);
    unsigned __int8 v15 = v14 + v12 + data[v13];
    if (v13 + 1 == len) {
      int v16 = 0;
    }
    else {
      int v16 = v13 + 1;
    }
    *((_DWORD *)v10 + 3) = *(_DWORD *)&v4[4 * v15];
    *(_DWORD *)&v4[4 * v15] = v14;
    int v17 = *((_DWORD *)v10 + 4);
    unsigned __int8 v18 = v17 + v15 + data[v16];
    if (v16 + 1 == len) {
      int v19 = 0;
    }
    else {
      int v19 = v16 + 1;
    }
    *((_DWORD *)v10 + 4) = *(_DWORD *)&v4[4 * v18];
    *(_DWORD *)&v4[4 * v18] = v17;
    int v20 = *((_DWORD *)v10 + 5);
    unsigned __int8 v21 = data[v19] + v20 + v18;
    unsigned __int8 v8 = v21;
    if (v19 + 1 == len) {
      int v9 = 0;
    }
    else {
      int v9 = v19 + 1;
    }
    *((_DWORD *)v10 + 5) = *(_DWORD *)&v4[4 * v21];
    *(_DWORD *)&v4[4 * v21] = v20;
    BOOL v22 = v7 >= 0xFC;
    v7 += 4;
  }
  while (!v22);
}

int DES_random_key(DES_cblock *ret)
{
  do
  {
    arc4random_buf(ret, 8uLL);
    DES_set_odd_parity(ret);
  }
  while (DES_is_weak_key(ret));
  return 1;
}

uint64_t OPENSSL_init_crypto(char a1)
{
  if (crypto_init_cleaned_up == 1)
  {
    ERR_put_error(15, 4095, 70, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/crypto_init.c", 54);
    return 0;
  }
  uint64_t v3 = pthread_self();
  if (pthread_equal(v3, (pthread_t)crypto_init_thread)) {
    return 1;
  }
  if (pthread_once(&crypto_init_once, OPENSSL_init_crypto_internal)) {
    return 0;
  }
  if ((a1 & 1) == 0 || (uint64_t result = OpenSSL_no_config(), result))
  {
    if ((a1 & 2) == 0) {
      return 1;
    }
    uint64_t result = OpenSSL_config(0);
    if (result) {
      return 1;
    }
  }
  return result;
}

void OPENSSL_init_crypto_internal()
{
  crypto_init_threaunsigned int d = (uint64_t)pthread_self();
  OPENSSL_cpuid_setup();
  ERR_load_crypto_strings();
  OpenSSL_add_all_ciphers();
  OpenSSL_add_all_digests();
}

uint64_t OPENSSL_cleanup()
{
  ERR_free_strings();
  CRYPTO_cleanup_all_ex_data();
  ENGINE_cleanup();
  EVP_cleanup();
  uint64_t result = x509_issuer_cache_free();
  crypto_init_cleaned_uunsigned int p = 1;
  return result;
}

void DES_ofb64_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, DES_key_schedule *schedule, DES_cblock *ivec, int *num)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  int v7 = *num;
  int v8 = (*ivec)[0];
  int v9 = (*ivec)[1];
  int v10 = (*ivec)[2];
  int v11 = (*ivec)[3];
  unsigned int v12 = v8 | (v9 << 8) | (v10 << 16) | (v11 << 24);
  int v13 = (*ivec)[4];
  int v14 = (*ivec)[5];
  int v15 = (*ivec)[6];
  int v16 = (*ivec)[7];
  int v17 = v13 | (v14 << 8) | (v15 << 16) | (v16 << 24);
  unsigned int data = v12;
  int v26 = v17;
  LOBYTE(v27) = v8;
  BYTE1(v27) = v9;
  BYTE2(v27) = v10;
  HIBYTE(v27) = v11;
  LOBYTE(v28) = v13;
  BYTE1(v28) = v14;
  BYTE2(v28) = v15;
  HIBYTE(v28) = v16;
  if (length)
  {
    uint64_t v20 = length;
    int v23 = 0;
    do
    {
      if (!v7)
      {
        DES_encrypt1(&data, schedule, 1);
        unsigned int v12 = data;
        int v17 = v26;
        unsigned int v27 = data;
        int v28 = v26;
        ++v23;
      }
      char v24 = *in++;
      *out++ = *((unsigned char *)&v27 + v7) ^ v24;
      int v7 = (v7 + 1) & 7;
      --v20;
    }
    while (v20);
    if (v23)
    {
      *(_DWORD *)ivec = v12;
      *(_DWORD *)&(*ivec)[4] = v17;
    }
  }
  *uint64_t num = v7;
}

unsigned int *idea_cbc_encrypt(unsigned int *result, _DWORD *a2, uint64_t a3, unsigned int *a4, uint64_t a5, int a6)
{
  unint64_t v8 = a3;
  uint64_t v48 = *MEMORY[0x263EF8340];
  unint64_t v10 = bswap32(*(_DWORD *)a5);
  unint64_t v11 = bswap32(*(_DWORD *)(a5 + 4));
  if (a6)
  {
    if (a3 >= 8)
    {
      do
      {
        unsigned int v12 = a2;
        unint64_t v13 = v8;
        v8 -= 8;
        int v14 = result + 2;
        uint64_t v15 = bswap32(result[1]);
        unint64_t v46 = bswap32(*result) ^ v10;
        unint64_t v47 = v15 ^ v11;
        idea_encrypt(&v46, a4);
        unint64_t v10 = v46;
        unint64_t v11 = v47;
        a2 += 2;
        unsigned int v16 = bswap32(v47);
        _DWORD *v12 = bswap32(v46);
        v12[1] = v16;
        uint64_t result = v14;
      }
      while (v13 > 0xF);
      uint64_t result = v14;
    }
    if (v8)
    {
      unint64_t v17 = 0;
      unsigned __int8 v18 = (char *)result + v8;
      unint64_t v19 = 0;
      switch(v8)
      {
        case 1uLL:
          goto LABEL_13;
        case 2uLL:
          goto LABEL_12;
        case 3uLL:
          goto LABEL_11;
        case 4uLL:
          goto LABEL_10;
        case 5uLL:
          goto LABEL_9;
        case 6uLL:
          goto LABEL_8;
        case 7uLL:
          unsigned int v20 = *--v18;
          unint64_t v17 = (unint64_t)v20 << 8;
LABEL_8:
          unsigned int v21 = *--v18;
          v17 |= (unint64_t)v21 << 16;
LABEL_9:
          unsigned int v22 = *--v18;
          v17 |= (unint64_t)v22 << 24;
LABEL_10:
          unint64_t v19 = v17;
          unsigned int v23 = *--v18;
          unint64_t v17 = v23;
LABEL_11:
          unsigned int v24 = *--v18;
          v17 |= (unint64_t)v24 << 8;
LABEL_12:
          unsigned int v25 = *--v18;
          v17 |= (unint64_t)v25 << 16;
LABEL_13:
          v17 |= (unint64_t)*(v18 - 1) << 24;
          break;
        default:
          unint64_t v19 = 0;
          break;
      }
      unint64_t v46 = v17 ^ v10;
      unint64_t v47 = v19 ^ v11;
      uint64_t result = (unsigned int *)idea_encrypt(&v46, a4);
      char v26 = v46;
      LOBYTE(v27) = v47;
      unint64_t v28 = v46 >> 24;
      unint64_t v29 = v46 >> 16;
      unint64_t v30 = v46 >> 8;
      unint64_t v31 = v47 >> 24;
      unint64_t v32 = v47 >> 16;
      unint64_t v33 = v47 >> 8;
      unsigned int v34 = bswap32(v47);
      *a2 = bswap32(v46);
      a2[1] = v34;
    }
    else
    {
      unint64_t v28 = v10 >> 24;
      unint64_t v31 = v11 >> 24;
      unint64_t v32 = v11 >> 16;
      unint64_t v33 = v11 >> 8;
      LOBYTE(v27) = v11;
      unint64_t v29 = v10 >> 16;
      char v26 = v10;
      unint64_t v30 = v10 >> 8;
    }
    *(unsigned char *)a5 = v28;
    *(unsigned char *)(a5 + md4_block_data_order((unint64_t)c, b, 1) = v29;
    *(unsigned char *)(a5 + 2) = v30;
    *(unsigned char *)(a5 + 3) = v26;
    *(unsigned char *)(a5 + 4) = v31;
    *(unsigned char *)(a5 + 5) = v32;
    *(unsigned char *)(a5 + 6) = v33;
  }
  else
  {
    if (a3 >= 8)
    {
      do
      {
        int v35 = a2;
        int v36 = v10;
        int v37 = v11;
        unint64_t v38 = v8;
        v8 -= 8;
        unint64_t v10 = bswap32(*result);
        int v39 = result + 2;
        unint64_t v11 = bswap32(result[1]);
        unint64_t v46 = v10;
        unint64_t v47 = v11;
        idea_encrypt(&v46, a4);
        int v40 = v46 ^ v36;
        int v41 = v47 ^ v37;
        *int v35 = (v46 ^ v36) >> 24;
        v35[1] = BYTE2(v40);
        v35[2] = BYTE1(v40);
        v35[3] = v40;
        v35[4] = HIBYTE(v41);
        v35[5] = BYTE2(v41);
        v35[6] = BYTE1(v41);
        a2 = v35 + 8;
        v35[7] = v41;
        uint64_t result = v39;
      }
      while (v38 > 0xF);
      uint64_t result = v39;
    }
    if (v8)
    {
      unint64_t v42 = bswap32(*result);
      unint64_t v46 = v42;
      unint64_t v27 = bswap32(result[1]);
      unint64_t v47 = v27;
      uint64_t result = (unsigned int *)idea_encrypt(&v46, a4);
      int v43 = v46 ^ v10;
      int v44 = v47 ^ v11;
      int v45 = (char *)a2 + v8;
      switch(v8)
      {
        case 1uLL:
          goto LABEL_26;
        case 2uLL:
          goto LABEL_25;
        case 3uLL:
          goto LABEL_24;
        case 4uLL:
          goto LABEL_23;
        case 5uLL:
          goto LABEL_22;
        case 6uLL:
          goto LABEL_21;
        case 7uLL:
          *--int v45 = BYTE1(v44);
LABEL_21:
          *--int v45 = BYTE2(v44);
LABEL_22:
          *--int v45 = HIBYTE(v44);
LABEL_23:
          *--int v45 = v43;
LABEL_24:
          *--int v45 = BYTE1(v43);
LABEL_25:
          *--int v45 = BYTE2(v43);
LABEL_26:
          *(v45 - md4_block_data_order((unint64_t)c, b, 1) = HIBYTE(v43);
          break;
        default:
          break;
      }
    }
    else
    {
      LODWORD(v42) = v10;
      LODWORD(v27) = v11;
    }
    *(unsigned char *)a5 = BYTE3(v42);
    *(unsigned char *)(a5 + md4_block_data_order((unint64_t)c, b, 1) = BYTE2(v42);
    *(unsigned char *)(a5 + 2) = BYTE1(v42);
    *(unsigned char *)(a5 + 3) = v42;
    *(unsigned char *)(a5 + 4) = BYTE3(v27);
    *(unsigned char *)(a5 + 5) = BYTE2(v27);
    *(unsigned char *)(a5 + 6) = BYTE1(v27);
  }
  *(unsigned char *)(a5 + 7) = v27;
  return result;
}

unint64_t *idea_encrypt(unint64_t *result, unsigned int *a2)
{
  unint64_t v2 = WORD1(*result) * (unint64_t)*a2;
  unsigned int v3 = 1 - *a2 - WORD1(*result);
  unint64_t v4 = (unsigned __int16)(WORD1(*result) * *a2) - (v2 >> 16);
  unint64_t v5 = v4 - (v4 >> 16);
  if (v2) {
    LOWORD(v3) = v5;
  }
  unint64_t v6 = *result + a2[1];
  unsigned int v7 = a2[3];
  unint64_t v8 = (result[1] >> 16) + a2[2];
  unint64_t v9 = (unsigned __int16)result[1] * (unint64_t)v7;
  LOWORD(v1RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 1 - v7 - result[1];
  if (v9) {
    unint64_t v10 = (unsigned __int16)v9 - (v9 >> 16) - (((unsigned __int16)v9 - (v9 >> 16)) >> 16);
  }
  unsigned int v11 = a2[4];
  unsigned int v12 = a2[5];
  unint64_t v13 = (unsigned __int16)(v8 ^ v3) * (unint64_t)v11;
  int v14 = 1 - v11 - (unsigned __int16)(v8 ^ v3);
  unint64_t v15 = (unsigned __int16)((v8 ^ v3) * v11) - (v13 >> 16);
  unint64_t v16 = v15 - (v15 >> 16);
  if (v13) {
    int v14 = v16;
  }
  unint64_t v17 = (unsigned __int16)(v14 + (v10 ^ v6)) * (unint64_t)v12;
  int v18 = 1 - v12 - (unsigned __int16)(v14 + (v10 ^ v6));
  unint64_t v19 = (unsigned __int16)((v14 + (v10 ^ v6)) * v12) - (v17 >> 16);
  unint64_t v20 = v19 - (v19 >> 16);
  if (v17) {
    int v18 = v20;
  }
  int v21 = v18 + v14;
  unsigned __int16 v22 = v21 ^ v10;
  int v23 = v21 ^ v6;
  int v24 = v18 ^ v8;
  LODWORD(v27) = (unsigned __int16)(v18 ^ v3);
  unsigned int v25 = a2[6];
  unint64_t v26 = v27 * (unint64_t)v25;
  LOWORD(v27) = 1 - v25 - v27;
  if (v26) {
    unint64_t v27 = (unsigned __int16)v26 - (v26 >> 16) - (((unsigned __int16)v26 - (v26 >> 16)) >> 16);
  }
  int v28 = v24 + a2[7];
  unsigned int v29 = a2[9];
  int v30 = v23 + a2[8];
  unint64_t v31 = v22 * (unint64_t)v29;
  LOWORD(v32) = 1 - v29 - v22;
  if (v31) {
    unint64_t v32 = (unsigned __int16)v31 - (v31 >> 16) - (((unsigned __int16)v31 - (v31 >> 16)) >> 16);
  }
  unsigned int v33 = a2[10];
  unsigned int v34 = a2[11];
  unint64_t v35 = (unsigned __int16)(v30 ^ v27) * (unint64_t)v33;
  int v36 = 1 - v33 - (unsigned __int16)(v30 ^ v27);
  unint64_t v37 = (unsigned __int16)((v30 ^ v27) * v33) - (v35 >> 16);
  unint64_t v38 = v37 - (v37 >> 16);
  if (v35) {
    int v36 = v38;
  }
  unint64_t v39 = (unsigned __int16)(v36 + (v32 ^ v28)) * (unint64_t)v34;
  int v40 = 1 - v34 - (unsigned __int16)(v36 + (v32 ^ v28));
  unint64_t v41 = (unsigned __int16)((v36 + (v32 ^ v28)) * v34) - (v39 >> 16);
  unint64_t v42 = v41 - (v41 >> 16);
  if (v39) {
    int v40 = v42;
  }
  int v43 = v40 + v36;
  unsigned __int16 v44 = v43 ^ v32;
  int v45 = v43 ^ v28;
  int v46 = v40 ^ v30;
  LODWORD(v27) = (unsigned __int16)(v40 ^ v27);
  unsigned int v47 = a2[12];
  unint64_t v48 = v27 * (unint64_t)v47;
  LOWORD(v27) = 1 - v47 - v27;
  if (v48) {
    unint64_t v27 = (unsigned __int16)v48 - (v48 >> 16) - (((unsigned __int16)v48 - (v48 >> 16)) >> 16);
  }
  unsigned int v49 = v46 + a2[13];
  unsigned int v50 = a2[15];
  unsigned int v51 = v45 + a2[14];
  unint64_t v52 = v44 * (unint64_t)v50;
  LOWORD(v53) = 1 - v50 - v44;
  if (v52) {
    unint64_t v53 = (unsigned __int16)v52 - (v52 >> 16) - (((unsigned __int16)v52 - (v52 >> 16)) >> 16);
  }
  unsigned int v54 = a2[16];
  unsigned int v55 = a2[17];
  unint64_t v56 = (unsigned __int16)(v51 ^ v27) * (unint64_t)v54;
  int v57 = 1 - v54 - (unsigned __int16)(v51 ^ v27);
  unint64_t v58 = (unsigned __int16)((v51 ^ v27) * v54) - (v56 >> 16);
  unint64_t v59 = v58 - (v58 >> 16);
  if (v56) {
    int v57 = v59;
  }
  unint64_t v60 = (unsigned __int16)(v57 + (v53 ^ v49)) * (unint64_t)v55;
  int v61 = 1 - v55 - (unsigned __int16)(v57 + (v53 ^ v49));
  unint64_t v62 = (unsigned __int16)((v57 + (v53 ^ v49)) * v55) - (v60 >> 16);
  unint64_t v63 = v62 - (v62 >> 16);
  if (v60) {
    int v61 = v63;
  }
  int v64 = v61 + v57;
  unsigned __int16 v65 = v64 ^ v53;
  int v66 = v64 ^ v49;
  int v67 = v61 ^ v51;
  LODWORD(v27) = (unsigned __int16)(v61 ^ v27);
  unsigned int v68 = a2[18];
  unint64_t v69 = v27 * (unint64_t)v68;
  LOWORD(v27) = 1 - v68 - v27;
  if (v69) {
    unint64_t v27 = (unsigned __int16)v69 - (v69 >> 16) - (((unsigned __int16)v69 - (v69 >> 16)) >> 16);
  }
  unsigned int v70 = v67 + a2[19];
  unsigned int v71 = a2[21];
  unsigned int v72 = v66 + a2[20];
  unint64_t v73 = v65 * (unint64_t)v71;
  LOWORD(v74) = 1 - v71 - v65;
  if (v73) {
    unint64_t v74 = (unsigned __int16)v73 - (v73 >> 16) - (((unsigned __int16)v73 - (v73 >> 16)) >> 16);
  }
  unsigned int v75 = a2[22];
  unsigned int v76 = a2[23];
  unint64_t v77 = (unsigned __int16)(v72 ^ v27) * (unint64_t)v75;
  int v78 = 1 - v75 - (unsigned __int16)(v72 ^ v27);
  unint64_t v79 = (unsigned __int16)((v72 ^ v27) * v75) - (v77 >> 16);
  unint64_t v80 = v79 - (v79 >> 16);
  if (v77) {
    int v78 = v80;
  }
  unint64_t v81 = (unsigned __int16)(v78 + (v74 ^ v70)) * (unint64_t)v76;
  int v82 = 1 - v76 - (unsigned __int16)(v78 + (v74 ^ v70));
  unint64_t v83 = (unsigned __int16)((v78 + (v74 ^ v70)) * v76) - (v81 >> 16);
  unint64_t v84 = v83 - (v83 >> 16);
  if (v81) {
    int v82 = v84;
  }
  int v85 = v82 + v78;
  unsigned __int16 v86 = v85 ^ v74;
  int v87 = v85 ^ v70;
  int v88 = v82 ^ v72;
  LODWORD(v27) = (unsigned __int16)(v82 ^ v27);
  unsigned int v89 = a2[24];
  unint64_t v90 = v27 * (unint64_t)v89;
  LOWORD(v27) = 1 - v89 - v27;
  if (v90) {
    unint64_t v27 = (unsigned __int16)v90 - (v90 >> 16) - (((unsigned __int16)v90 - (v90 >> 16)) >> 16);
  }
  unsigned int v91 = v88 + a2[25];
  unsigned int v92 = a2[27];
  unsigned int v93 = v87 + a2[26];
  unint64_t v94 = v86 * (unint64_t)v92;
  LOWORD(v95) = 1 - v92 - v86;
  if (v94) {
    unint64_t v95 = (unsigned __int16)v94 - (v94 >> 16) - (((unsigned __int16)v94 - (v94 >> 16)) >> 16);
  }
  unsigned int v96 = a2[28];
  unsigned int v97 = a2[29];
  unint64_t v98 = (unsigned __int16)(v93 ^ v27) * (unint64_t)v96;
  int v99 = 1 - v96 - (unsigned __int16)(v93 ^ v27);
  unint64_t v100 = (unsigned __int16)((v93 ^ v27) * v96) - (v98 >> 16);
  unint64_t v101 = v100 - (v100 >> 16);
  if (v98) {
    int v99 = v101;
  }
  unint64_t v102 = (unsigned __int16)(v99 + (v95 ^ v91)) * (unint64_t)v97;
  int v103 = 1 - v97 - (unsigned __int16)(v99 + (v95 ^ v91));
  unint64_t v104 = (unsigned __int16)((v99 + (v95 ^ v91)) * v97) - (v102 >> 16);
  unint64_t v105 = v104 - (v104 >> 16);
  if (v102) {
    int v103 = v105;
  }
  int v106 = v103 + v99;
  unsigned __int16 v107 = v106 ^ v95;
  int v108 = v106 ^ v91;
  int v109 = v103 ^ v93;
  LODWORD(v27) = (unsigned __int16)(v103 ^ v27);
  unsigned int v110 = a2[30];
  unint64_t v111 = v27 * (unint64_t)v110;
  LOWORD(v27) = 1 - v110 - v27;
  if (v111) {
    unint64_t v27 = (unsigned __int16)v111 - (v111 >> 16) - (((unsigned __int16)v111 - (v111 >> 16)) >> 16);
  }
  unsigned int v112 = v109 + a2[31];
  unsigned int v113 = a2[33];
  unsigned int v114 = v108 + a2[32];
  unint64_t v115 = v107 * (unint64_t)v113;
  LOWORD(v1++*(_DWORD *)(*(void *)(result + 8) + 16) = 1 - v113 - v107;
  if (v115) {
    unint64_t v116 = (unsigned __int16)v115 - (v115 >> 16) - (((unsigned __int16)v115 - (v115 >> 16)) >> 16);
  }
  unsigned int v117 = a2[34];
  unsigned int v118 = a2[35];
  unint64_t v119 = (unsigned __int16)(v114 ^ v27) * (unint64_t)v117;
  int v120 = 1 - v117 - (unsigned __int16)(v114 ^ v27);
  unint64_t v121 = (unsigned __int16)((v114 ^ v27) * v117) - (v119 >> 16);
  unint64_t v122 = v121 - (v121 >> 16);
  if (v119) {
    int v120 = v122;
  }
  unint64_t v123 = (unsigned __int16)(v120 + (v116 ^ v112)) * (unint64_t)v118;
  int v124 = 1 - v118 - (unsigned __int16)(v120 + (v116 ^ v112));
  unint64_t v125 = (unsigned __int16)((v120 + (v116 ^ v112)) * v118) - (v123 >> 16);
  unint64_t v126 = v125 - (v125 >> 16);
  if (v123) {
    int v124 = v126;
  }
  int v127 = v124 + v120;
  unsigned __int16 v128 = v127 ^ v116;
  int v129 = v127 ^ v112;
  int v130 = v124 ^ v114;
  LODWORD(v27) = (unsigned __int16)(v124 ^ v27);
  unsigned int v131 = a2[36];
  unint64_t v132 = v27 * (unint64_t)v131;
  LOWORD(v27) = 1 - v131 - v27;
  if (v132) {
    unint64_t v27 = (unsigned __int16)v132 - (v132 >> 16) - (((unsigned __int16)v132 - (v132 >> 16)) >> 16);
  }
  unsigned int v133 = v130 + a2[37];
  unsigned int v134 = a2[39];
  unsigned int v135 = v129 + a2[38];
  unint64_t v136 = v128 * (unint64_t)v134;
  LOWORD(v137) = 1 - v134 - v128;
  if (v136) {
    unint64_t v137 = (unsigned __int16)v136 - (v136 >> 16) - (((unsigned __int16)v136 - (v136 >> 16)) >> 16);
  }
  unsigned int v138 = a2[40];
  unsigned int v139 = a2[41];
  unint64_t v140 = (unsigned __int16)(v135 ^ v27) * (unint64_t)v138;
  int v141 = 1 - v138 - (unsigned __int16)(v135 ^ v27);
  unint64_t v142 = (unsigned __int16)((v135 ^ v27) * v138) - (v140 >> 16);
  unint64_t v143 = v142 - (v142 >> 16);
  if (v140) {
    int v141 = v143;
  }
  unint64_t v144 = (unsigned __int16)(v141 + (v137 ^ v133)) * (unint64_t)v139;
  int v145 = 1 - v139 - (unsigned __int16)(v141 + (v137 ^ v133));
  unint64_t v146 = (unsigned __int16)((v141 + (v137 ^ v133)) * v139) - (v144 >> 16);
  unint64_t v147 = v146 - (v146 >> 16);
  if (v144) {
    int v145 = v147;
  }
  int v148 = v145 + v141;
  unsigned __int16 v149 = v148 ^ v137;
  int v150 = v148 ^ v133;
  int v151 = v145 ^ v135;
  unsigned int v152 = (unsigned __int16)(v145 ^ v27);
  unsigned int v153 = a2[42];
  unint64_t v154 = v152 * (unint64_t)v153;
  __int16 v155 = 1 - v153 - v152;
  unint64_t v156 = (unsigned __int16)v154 - (v154 >> 16) - (((unsigned __int16)v154 - (v154 >> 16)) >> 16);
  if (!v154) {
    LOWORD(v156) = v155;
  }
  unsigned int v157 = v151 + a2[43];
  unsigned int v158 = a2[45];
  unsigned int v159 = v150 + a2[44];
  unint64_t v160 = v149 * (unint64_t)v158;
  LOWORD(v16md4_block_data_order((unint64_t)c, b, 1) = 1 - v158 - v149;
  if (v160) {
    unint64_t v161 = (unsigned __int16)v160 - (v160 >> 16) - (((unsigned __int16)v160 - (v160 >> 16)) >> 16);
  }
  unsigned int v162 = a2[46];
  unsigned int v163 = a2[47];
  unint64_t v164 = (unsigned __int16)(v159 ^ v156) * (unint64_t)v162;
  __int16 v165 = 1 - v162 - (v159 ^ v156);
  unint64_t v166 = (unsigned __int16)((v159 ^ v156) * v162) - (v164 >> 16);
  unint64_t v167 = v166 - (v166 >> 16);
  if (v164) {
    __int16 v165 = v167;
  }
  unint64_t v168 = (unsigned __int16)(v165 + (v161 ^ v157)) * (unint64_t)v163;
  int v169 = 1 - v163 - (unsigned __int16)(v165 + (v161 ^ v157));
  unint64_t v170 = (unsigned __int16)((v165 + (v161 ^ v157)) * v163) - (v168 >> 16);
  unint64_t v171 = v170 - (v170 >> 16);
  if (v168) {
    int v169 = v171;
  }
  __int16 v172 = v169 + v165;
  unsigned __int16 v173 = v172 ^ v161;
  unsigned int v174 = (unsigned __int16)(v169 ^ v156);
  unsigned int v175 = a2[48];
  unsigned int v176 = a2[49];
  unint64_t v177 = v174 * (unint64_t)v175;
  LODWORD(v156) = 1 - v175 - v174;
  if (v177) {
    unint64_t v156 = (unsigned __int16)v177 - (v177 >> 16) - (((unsigned __int16)v177 - (v177 >> 16)) >> 16);
  }
  unsigned int v178 = a2[50];
  unsigned int v179 = a2[51];
  unint64_t v180 = v173 * (unint64_t)v179;
  unsigned __int16 v181 = 1 - v179 - v173;
  unint64_t v182 = (unsigned __int16)(v173 * v179) - (v180 >> 16) - (((unsigned __int16)(v173 * v179) - (v180 >> 16)) >> 16);
  if (v180) {
    unsigned __int16 v181 = v182;
  }
  *uint64_t result = (v156 << 16) | (unint64_t)(unsigned __int16)((v172 ^ v157) + v176);
  result[1] = (((v169 ^ v159) + v178) << 16) | (unint64_t)v181;
  return result;
}

void DSA_set_default_method(const DSA_METHOD *a1)
{
  default_DSA_int method = (uint64_t)a1;
}

const DSA_METHOD *DSA_get_default_method(void)
{
  uint64_t result = (const DSA_METHOD *)default_DSA_method;
  if (!default_DSA_method)
  {
    uint64_t result = DSA_OpenSSL();
    default_DSA_int method = (uint64_t)result;
  }
  return result;
}

DSA *DSA_new(void)
{
  return DSA_new_method(0);
}

DSA *__cdecl DSA_new_method(ENGINE *engine)
{
  unint64_t v2 = (char *)malloc_type_malloc(0x78uLL, 0x106004072515E81uLL);
  if (!v2)
  {
    ERR_put_error(10, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_lib.c", 130);
    return (DSA *)v2;
  }
  unsigned int v3 = (const DSA_METHOD *)default_DSA_method;
  if (!default_DSA_method)
  {
    unsigned int v3 = DSA_OpenSSL();
    default_DSA_int method = (uint64_t)v3;
  }
  *((void *)v2 + 13) = v3;
  if (engine)
  {
    if (!ENGINE_init(engine))
    {
      ERR_put_error(10, 4095, 38, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_lib.c", 137);
      goto LABEL_16;
    }
    *((void *)v2 + 14) = engine;
    goto LABEL_9;
  }
  engine = ENGINE_get_default_DSA();
  *((void *)v2 + 14) = engine;
  if (engine)
  {
LABEL_9:
    DSA = ENGINE_get_DSA(engine);
    *((void *)v2 + 13) = DSA;
    if (!DSA)
    {
      ERR_put_error(10, 4095, 38, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_lib.c", 147);
      ENGINE_finish(*((ENGINE **)v2 + 14));
LABEL_16:
      free(v2);
      return 0;
    }
    goto LABEL_13;
  }
  DSA = (const DSA_METHOD *)*((void *)v2 + 13);
LABEL_13:
  *(_DWORD *)unint64_t v2 = 0;
  *((void *)v2 + 1RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0;
  *(_OWORD *)(v2 + 8) = 0u;
  *(_OWORD *)(v2 + 24) = 0u;
  *(_OWORD *)(v2 + 4RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0u;
  *(_OWORD *)(v2 + 56) = 0u;
  *((_DWORD *)v2 + 22) = 1;
  *((_DWORD *)v2 + 18) = DSA->flags & 0xFFFFFBFF;
  CRYPTO_new_ex_data(7, v2, (CRYPTO_EX_DATA *)v2 + 6);
  unint64_t v5 = *(unsigned int (**)(char *))(*((void *)v2 + 13) + 48);
  if (v5 && !v5(v2))
  {
    ENGINE_finish(*((ENGINE **)v2 + 14));
    CRYPTO_free_ex_data(7, v2, (CRYPTO_EX_DATA *)v2 + 6);
    goto LABEL_16;
  }
  return (DSA *)v2;
}

int DSA_set_method(DSA *dsa, const DSA_METHOD *a2)
{
  comunsigned int p = dsa->ex_data.sk[1].comp;
  if (comp) {
    ((void (*)(DSA *))comp)(dsa);
  }
  ENGINE_finish(*(ENGINE **)&dsa->ex_data.dummy);
  dsa->ex_data.uint64_t sk = (STACK *)a2;
  *(void *)&dsa->ex_data.dummy = 0;
  init = a2->init;
  if (init) {
    ((void (*)(DSA *))init)(dsa);
  }
  return 1;
}

void DSA_free(DSA *r)
{
  if (r && CRYPTO_add_lock((int *)&r->method_mont_p, -1, 8, 0, 0) <= 0)
  {
    comunsigned int p = r->ex_data.sk[1].comp;
    if (comp) {
      ((void (*)(DSA *))comp)(r);
    }
    ENGINE_finish(*(ENGINE **)&r->ex_data.dummy);
    CRYPTO_free_ex_data(7, r, (CRYPTO_EX_DATA *)&r->references);
    BN_free(*(BIGNUM **)&r->write_params);
    BN_free(r->p);
    BN_free(r->q);
    BN_free(r->g);
    BN_free(r->pub_key);
    BN_free(r->priv_key);
    BN_free(r->kinv);
    free(r);
  }
}

int DSA_up_ref(DSA *r)
{
  return CRYPTO_add_lock((int *)&r->method_mont_p, 1, 8, 0, 0) > 1;
}

int DSA_size(const DSA *a1)
{
  v3.r = a1->p;
  v3.unsigned int s = v3.r;
  int v1 = i2d_DSA_SIG(&v3, 0);
  return v1 & ~(v1 >> 31);
}

int DSA_get_ex_new_index(uint64_t argl, void *argp, CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
{
  return CRYPTO_get_ex_new_index(7, argl, argp, new_func, dup_func, free_func);
}

int DSA_set_ex_data(DSA *d, int idx, void *arg)
{
  return CRYPTO_set_ex_data((CRYPTO_EX_DATA *)&d->references, idx, arg);
}

void *__cdecl DSA_get_ex_data(DSA *d, int idx)
{
  return CRYPTO_get_ex_data((const CRYPTO_EX_DATA *)&d->references, idx);
}

uint64_t DSA_security_bits(uint64_t a1)
{
  unint64_t v2 = *(const BIGNUM **)(a1 + 16);
  if (!v2 || !*(void *)(a1 + 24)) {
    return 0xFFFFFFFFLL;
  }
  int v3 = BN_num_bits(v2);
  int v4 = BN_num_bits(*(const BIGNUM **)(a1 + 24));
  return BN_security_bits(v3, v4);
}

DH *__cdecl DSA_dup_DH(const DSA *r)
{
  if (!r)
  {
    unint64_t v2 = 0;
LABEL_15:
    DH_free(v2);
    return 0;
  }
  unint64_t v2 = DH_new();
  if (!v2) {
    goto LABEL_15;
  }
  int v3 = *(const BIGNUM **)&r->write_params;
  if (v3)
  {
    int v4 = BN_dup(v3);
    v2->unsigned int p = v4;
    if (!v4) {
      goto LABEL_15;
    }
  }
  unsigned int p = r->p;
  if (p)
  {
    v2->int length = BN_num_bits(p);
    unint64_t v6 = BN_dup(r->p);
    v2->q = v6;
    if (!v6) {
      goto LABEL_15;
    }
  }
  q = r->q;
  if (q)
  {
    unint64_t v8 = BN_dup(q);
    v2->g = v8;
    if (!v8) {
      goto LABEL_15;
    }
  }
  g = r->g;
  if (g)
  {
    unint64_t v10 = BN_dup(g);
    v2->pub_uint64_t key = v10;
    if (!v10) {
      goto LABEL_15;
    }
  }
  pub_uint64_t key = r->pub_key;
  if (pub_key)
  {
    unsigned int v12 = BN_dup(pub_key);
    v2->priv_uint64_t key = v12;
    if (!v12) {
      goto LABEL_15;
    }
  }
  return v2;
}

void *DSA_get0_pqg(void *result, void *a2, void *a3, void *a4)
{
  if (a2) {
    *a2 = result[2];
  }
  if (a3) {
    *a3 = result[3];
  }
  if (a4) {
    *a4 = result[4];
  }
  return result;
}

uint64_t DSA_set0_pqg(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5 = *(BIGNUM **)(a1 + 16);
  if (!(a2 | (unint64_t)v5) || !(a3 | *(void *)(a1 + 24)) || !(a4 | *(void *)(a1 + 32))) {
    return 0;
  }
  if (a2)
  {
    BN_free(v5);
    *(void *)(a1 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = a2;
  }
  if (a3)
  {
    BN_free(*(BIGNUM **)(a1 + 24));
    *(void *)(a1 + 24) = a3;
  }
  if (a4)
  {
    BN_free(*(BIGNUM **)(a1 + 32));
    *(void *)(a1 + 32) = a4;
  }
  return 1;
}

uint64_t DSA_get0_key(uint64_t result, void *a2, void *a3)
{
  if (a2) {
    *a2 = *(void *)(result + 40);
  }
  if (a3) {
    *a3 = *(void *)(result + 48);
  }
  return result;
}

uint64_t DSA_set0_key(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(BIGNUM **)(a1 + 40);
  if (!(a2 | (unint64_t)v4)) {
    return 0;
  }
  if (a2)
  {
    BN_free(v4);
    *(void *)(a1 + 4RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = a2;
  }
  if (a3)
  {
    BN_free(*(BIGNUM **)(a1 + 48));
    *(void *)(a1 + 48) = a3;
  }
  return 1;
}

uint64_t DSA_get0_p(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t DSA_get0_q(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t DSA_get0_g(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t DSA_get0_pub_key(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t DSA_get0_priv_key(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

uint64_t DSA_clear_flags(uint64_t result, int a2)
{
  *(_DWORD *)(result + 72) &= ~a2;
  return result;
}

uint64_t DSA_test_flags(uint64_t a1, unsigned int a2)
{
  return *(_DWORD *)(a1 + 72) & a2;
}

uint64_t DSA_set_flags(uint64_t result, int a2)
{
  *(_DWORD *)(result + 72) |= a2;
  return result;
}

uint64_t DSA_get0_engine(uint64_t a1)
{
  return *(void *)(a1 + 112);
}

uint64_t DSA_bits(uint64_t a1)
{
  return BN_num_bits(*(const BIGNUM **)(a1 + 16));
}

uint64_t dsa_check_key(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (!v2 || !*(void *)(a1 + 24) || !*(void *)(a1 + 32))
  {
    int v5 = 101;
    int v6 = 433;
    goto LABEL_10;
  }
  if (!BN_is_odd(v2) || !BN_is_odd(*(void *)(a1 + 24)))
  {
    int v5 = 112;
    int v6 = 439;
    goto LABEL_10;
  }
  int v3 = *(const BIGNUM **)(a1 + 32);
  int v4 = BN_value_one();
  if (BN_cmp(v3, v4) < 1 || (BN_cmp(*(const BIGNUM **)(a1 + 32), *(const BIGNUM **)(a1 + 16)) & 0x80000000) == 0)
  {
    int v5 = 112;
    int v6 = 446;
LABEL_10:
    ERR_put_error(10, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_lib.c", v6);
    return 0;
  }
  if (BN_is_negative(*(void *)(a1 + 24)))
  {
    int v5 = 102;
    int v6 = 452;
    goto LABEL_10;
  }
  int v8 = BN_num_bits(*(const BIGNUM **)(a1 + 24));
  if (v8 != 160 && v8 != 224 && v8 != 256)
  {
    int v5 = 102;
    int v6 = 459;
    goto LABEL_10;
  }
  int v9 = BN_num_bits(*(const BIGNUM **)(a1 + 16));
  if (v9 >= 10001)
  {
    int v5 = 103;
    int v6 = 471;
    goto LABEL_10;
  }
  if (v9 <= 511)
  {
    int v5 = 112;
    int v6 = 475;
    goto LABEL_10;
  }
  unint64_t v10 = *(const BIGNUM **)(a1 + 40);
  if (v10)
  {
    unsigned int v11 = BN_value_one();
    if (BN_cmp(v10, v11) < 1 || (BN_cmp(*(const BIGNUM **)(a1 + 40), *(const BIGNUM **)(a1 + 16)) & 0x80000000) == 0)
    {
      int v5 = 112;
      int v6 = 483;
      goto LABEL_10;
    }
  }
  unsigned int v12 = *(const BIGNUM **)(a1 + 48);
  if (v12)
  {
    unint64_t v13 = BN_value_one();
    if (BN_cmp(v12, v13) < 0 || (BN_cmp(*(const BIGNUM **)(a1 + 48), *(const BIGNUM **)(a1 + 24)) & 0x80000000) == 0)
    {
      int v5 = 112;
      int v6 = 492;
      goto LABEL_10;
    }
  }
  return 1;
}

PKCS12 *__cdecl d2i_PKCS12(PKCS12 **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS12 *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS12_it);
}

int i2d_PKCS12(PKCS12 *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS12_it);
}

PKCS12 *PKCS12_new(void)
{
  return (PKCS12 *)ASN1_item_new(&PKCS12_it);
}

void PKCS12_free(PKCS12 *a)
{
}

PKCS12_MAC_DATA *__cdecl d2i_PKCS12_MAC_DATA(PKCS12_MAC_DATA **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS12_MAC_DATA *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS12_MAC_DATA_it);
}

int i2d_PKCS12_MAC_DATA(PKCS12_MAC_DATA *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS12_MAC_DATA_it);
}

PKCS12_MAC_DATA *PKCS12_MAC_DATA_new(void)
{
  return (PKCS12_MAC_DATA *)ASN1_item_new(&PKCS12_MAC_DATA_it);
}

void PKCS12_MAC_DATA_free(PKCS12_MAC_DATA *a)
{
}

PKCS12_BAGS *__cdecl d2i_PKCS12_BAGS(PKCS12_BAGS **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS12_BAGS *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS12_BAGS_it);
}

int i2d_PKCS12_BAGS(PKCS12_BAGS *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS12_BAGS_it);
}

PKCS12_BAGS *PKCS12_BAGS_new(void)
{
  return (PKCS12_BAGS *)ASN1_item_new(&PKCS12_BAGS_it);
}

void PKCS12_BAGS_free(PKCS12_BAGS *a)
{
}

PKCS12_SAFEBAG *__cdecl d2i_PKCS12_SAFEBAG(PKCS12_SAFEBAG **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKCS12_SAFEBAG *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKCS12_SAFEBAG_it);
}

int i2d_PKCS12_SAFEBAG(PKCS12_SAFEBAG *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKCS12_SAFEBAG_it);
}

PKCS12_SAFEBAG *PKCS12_SAFEBAG_new(void)
{
  return (PKCS12_SAFEBAG *)ASN1_item_new(&PKCS12_SAFEBAG_it);
}

void PKCS12_SAFEBAG_free(PKCS12_SAFEBAG *a)
{
}

void CAST_encrypt(unint64_t *data, const CAST_KEY *key)
{
  int v2 = *((_DWORD *)data + 1);
  unsigned int v3 = __ROR4__(LODWORD(key->data[0]) + v2, -BYTE4(key->data[0]));
  int v4 = ((CAST_S_table1[v3] ^ CAST_S_table0[BYTE1(v3)])
      - CAST_S_table2[HIBYTE(v3)]
      + CAST_S_table3[BYTE2(v3)]) ^ *(_DWORD *)data;
  unsigned int v5 = __ROR4__(v4 ^ LODWORD(key->data[1]), -BYTE4(key->data[1]));
  int v6 = CAST_S_table3[BYTE2(v5)] ^ v2 ^ (CAST_S_table0[BYTE1(v5)]
                                      - CAST_S_table1[v5]
                                      + CAST_S_table2[HIBYTE(v5)]);
  unsigned int v7 = __ROR4__(LODWORD(key->data[2]) - v6, -BYTE4(key->data[2]));
  int v8 = (((CAST_S_table1[v7] + CAST_S_table0[BYTE1(v7)]) ^ CAST_S_table2[HIBYTE(v7)])
      - CAST_S_table3[BYTE2(v7)]) ^ v4;
  unsigned int v9 = __ROR4__(v8 + LODWORD(key->data[3]), -BYTE4(key->data[3]));
  int v10 = ((CAST_S_table1[v9] ^ CAST_S_table0[BYTE1(v9)])
       - CAST_S_table2[HIBYTE(v9)]
       + CAST_S_table3[BYTE2(v9)]) ^ v6;
  unsigned int v11 = __ROR4__(v10 ^ LODWORD(key->data[4]), -BYTE4(key->data[4]));
  int v12 = CAST_S_table3[BYTE2(v11)] ^ v8 ^ (CAST_S_table0[BYTE1(v11)]
                                        - CAST_S_table1[v11]
                                        + CAST_S_table2[HIBYTE(v11)]);
  unsigned int v13 = __ROR4__(LODWORD(key->data[5]) - v12, -BYTE4(key->data[5]));
  int v14 = (((CAST_S_table1[v13] + CAST_S_table0[BYTE1(v13)]) ^ CAST_S_table2[HIBYTE(v13)])
       - CAST_S_table3[BYTE2(v13)]) ^ v10;
  unsigned int v15 = __ROR4__(v14 + LODWORD(key->data[6]), -BYTE4(key->data[6]));
  int v16 = ((CAST_S_table1[v15] ^ CAST_S_table0[BYTE1(v15)])
       - CAST_S_table2[HIBYTE(v15)]
       + CAST_S_table3[BYTE2(v15)]) ^ v12;
  unsigned int v17 = __ROR4__(v16 ^ LODWORD(key->data[7]), -BYTE4(key->data[7]));
  int v18 = CAST_S_table3[BYTE2(v17)] ^ v14 ^ (CAST_S_table0[BYTE1(v17)]
                                         - CAST_S_table1[v17]
                                         + CAST_S_table2[HIBYTE(v17)]);
  unsigned int v19 = __ROR4__(LODWORD(key->data[8]) - v18, -BYTE4(key->data[8]));
  int v20 = (((CAST_S_table1[v19] + CAST_S_table0[BYTE1(v19)]) ^ CAST_S_table2[HIBYTE(v19)])
       - CAST_S_table3[BYTE2(v19)]) ^ v16;
  unsigned int v21 = __ROR4__(v20 + LODWORD(key->data[9]), -BYTE4(key->data[9]));
  int v22 = ((CAST_S_table1[v21] ^ CAST_S_table0[BYTE1(v21)])
       - CAST_S_table2[HIBYTE(v21)]
       + CAST_S_table3[BYTE2(v21)]) ^ v18;
  unsigned int v23 = __ROR4__(v22 ^ LODWORD(key->data[10]), -BYTE4(key->data[10]));
  int v24 = CAST_S_table3[BYTE2(v23)] ^ v20 ^ (CAST_S_table0[BYTE1(v23)]
                                         - CAST_S_table1[v23]
                                         + CAST_S_table2[HIBYTE(v23)]);
  unsigned int v25 = __ROR4__(LODWORD(key->data[11]) - v24, -BYTE4(key->data[11]));
  int v26 = (((CAST_S_table1[v25] + CAST_S_table0[BYTE1(v25)]) ^ CAST_S_table2[HIBYTE(v25)])
       - CAST_S_table3[BYTE2(v25)]) ^ v22;
  if (!LODWORD(key->data[16]))
  {
    unsigned int v27 = __ROR4__(LODWORD(key->data[12]) + v26, -BYTE4(key->data[12]));
    int v28 = ((CAST_S_table1[v27] ^ CAST_S_table0[BYTE1(v27)])
         - CAST_S_table2[HIBYTE(v27)]
         + CAST_S_table3[BYTE2(v27)]) ^ v24;
    unsigned int v29 = __ROR4__(v28 ^ LODWORD(key->data[13]), -BYTE4(key->data[13]));
    int v30 = CAST_S_table3[BYTE2(v29)] ^ v26 ^ (CAST_S_table0[BYTE1(v29)]
                                           - CAST_S_table1[v29]
                                           + CAST_S_table2[HIBYTE(v29)]);
    unsigned int v31 = __ROR4__(LODWORD(key->data[14]) - v30, -BYTE4(key->data[14]));
    int v24 = (((CAST_S_table1[v31] + CAST_S_table0[BYTE1(v31)]) ^ CAST_S_table2[HIBYTE(v31)])
         - CAST_S_table3[BYTE2(v31)]) ^ v28;
    unsigned int v32 = __ROR4__(v24 + LODWORD(key->data[15]), -BYTE4(key->data[15]));
    int v26 = ((CAST_S_table1[v32] ^ CAST_S_table0[BYTE1(v32)])
         - CAST_S_table2[HIBYTE(v32)]
         + CAST_S_table3[BYTE2(v32)]) ^ v30;
  }
  *(_DWORD *)unsigned int data = v26;
  *((_DWORD *)data + md4_block_data_order((unint64_t)c, b, 1) = v24;
}

void CAST_decrypt(unint64_t *data, const CAST_KEY *key)
{
  int v3 = *(_DWORD *)data;
  int v2 = *((_DWORD *)data + 1);
  if (!LODWORD(key->data[16]))
  {
    unsigned int v4 = __ROR4__(LODWORD(key->data[15]) + v2, -BYTE4(key->data[15]));
    int v5 = ((CAST_S_table1[v4] ^ CAST_S_table0[BYTE1(v4)])
        - CAST_S_table2[HIBYTE(v4)]
        + CAST_S_table3[BYTE2(v4)]) ^ v3;
    unsigned int v6 = __ROR4__(LODWORD(key->data[14]) - v5, -BYTE4(key->data[14]));
    int v7 = (((CAST_S_table1[v6] + CAST_S_table0[BYTE1(v6)]) ^ CAST_S_table2[HIBYTE(v6)])
        - CAST_S_table3[BYTE2(v6)]) ^ v2;
    unsigned int v8 = __ROR4__(v7 ^ LODWORD(key->data[13]), -BYTE4(key->data[13]));
    int v3 = CAST_S_table3[BYTE2(v8)] ^ v5 ^ (CAST_S_table0[BYTE1(v8)]
                                        - CAST_S_table1[v8]
                                        + CAST_S_table2[HIBYTE(v8)]);
    unsigned int v9 = __ROR4__(v3 + LODWORD(key->data[12]), -BYTE4(key->data[12]));
    int v2 = ((CAST_S_table1[v9] ^ CAST_S_table0[BYTE1(v9)])
        - CAST_S_table2[HIBYTE(v9)]
        + CAST_S_table3[BYTE2(v9)]) ^ v7;
  }
  unsigned int v10 = __ROR4__(LODWORD(key->data[11]) - v2, -BYTE4(key->data[11]));
  int v11 = (((CAST_S_table1[v10] + CAST_S_table0[BYTE1(v10)]) ^ CAST_S_table2[HIBYTE(v10)])
       - CAST_S_table3[BYTE2(v10)]) ^ v3;
  unsigned int v12 = __ROR4__(v11 ^ LODWORD(key->data[10]), -BYTE4(key->data[10]));
  int v13 = CAST_S_table3[BYTE2(v12)] ^ v2 ^ (CAST_S_table0[BYTE1(v12)]
                                        - CAST_S_table1[v12]
                                        + CAST_S_table2[HIBYTE(v12)]);
  unsigned int v14 = __ROR4__(v13 + LODWORD(key->data[9]), -BYTE4(key->data[9]));
  int v15 = ((CAST_S_table1[v14] ^ CAST_S_table0[BYTE1(v14)])
       - CAST_S_table2[HIBYTE(v14)]
       + CAST_S_table3[BYTE2(v14)]) ^ v11;
  unsigned int v16 = __ROR4__(LODWORD(key->data[8]) - v15, -BYTE4(key->data[8]));
  int v17 = (((CAST_S_table1[v16] + CAST_S_table0[BYTE1(v16)]) ^ CAST_S_table2[HIBYTE(v16)])
       - CAST_S_table3[BYTE2(v16)]) ^ v13;
  unsigned int v18 = __ROR4__(v17 ^ LODWORD(key->data[7]), -BYTE4(key->data[7]));
  int v19 = CAST_S_table3[BYTE2(v18)] ^ v15 ^ (CAST_S_table0[BYTE1(v18)]
                                         - CAST_S_table1[v18]
                                         + CAST_S_table2[HIBYTE(v18)]);
  unsigned int v20 = __ROR4__(v19 + LODWORD(key->data[6]), -BYTE4(key->data[6]));
  int v21 = ((CAST_S_table1[v20] ^ CAST_S_table0[BYTE1(v20)])
       - CAST_S_table2[HIBYTE(v20)]
       + CAST_S_table3[BYTE2(v20)]) ^ v17;
  unsigned int v22 = __ROR4__(LODWORD(key->data[5]) - v21, -BYTE4(key->data[5]));
  int v23 = (((CAST_S_table1[v22] + CAST_S_table0[BYTE1(v22)]) ^ CAST_S_table2[HIBYTE(v22)])
       - CAST_S_table3[BYTE2(v22)]) ^ v19;
  unsigned int v24 = __ROR4__(v23 ^ LODWORD(key->data[4]), -BYTE4(key->data[4]));
  int v25 = CAST_S_table3[BYTE2(v24)] ^ v21 ^ (CAST_S_table0[BYTE1(v24)]
                                         - CAST_S_table1[v24]
                                         + CAST_S_table2[HIBYTE(v24)]);
  unsigned int v26 = __ROR4__(v25 + LODWORD(key->data[3]), -BYTE4(key->data[3]));
  int v27 = ((CAST_S_table1[v26] ^ CAST_S_table0[BYTE1(v26)])
       - CAST_S_table2[HIBYTE(v26)]
       + CAST_S_table3[BYTE2(v26)]) ^ v23;
  unsigned int v28 = __ROR4__(LODWORD(key->data[2]) - v27, -BYTE4(key->data[2]));
  int v29 = (((CAST_S_table1[v28] + CAST_S_table0[BYTE1(v28)]) ^ CAST_S_table2[HIBYTE(v28)])
       - CAST_S_table3[BYTE2(v28)]) ^ v25;
  unsigned int v30 = __ROR4__(v29 ^ LODWORD(key->data[1]), -BYTE4(key->data[1]));
  int v31 = CAST_S_table3[BYTE2(v30)] ^ v27 ^ (CAST_S_table0[BYTE1(v30)]
                                         - CAST_S_table1[v30]
                                         + CAST_S_table2[HIBYTE(v30)]);
  unsigned int v32 = __ROR4__(v31 + LODWORD(key->data[0]), -BYTE4(key->data[0]));
  *(_DWORD *)unsigned int data = ((CAST_S_table1[v32] ^ CAST_S_table0[BYTE1(v32)])
                   - CAST_S_table2[HIBYTE(v32)]
                   + CAST_S_table3[BYTE2(v32)]) ^ v29;
  *((_DWORD *)data + md4_block_data_order((unint64_t)c, b, 1) = v31;
}

void CAST_cbc_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, const CAST_KEY *ks, unsigned __int8 *iv, int enc)
{
  uint64_t v8 = length;
  v43[1] = *MEMORY[0x263EF8340];
  unsigned int v10 = bswap32(*(_DWORD *)iv);
  unsigned int v11 = bswap32(*((_DWORD *)iv + 1));
  if (enc)
  {
    if (length >= 8)
    {
      do
      {
        unsigned int v12 = out;
        unint64_t v13 = v8;
        v8 -= 8;
        unsigned int v14 = in + 8;
        unsigned int v15 = bswap32(*((_DWORD *)in + 1));
        LODWORD(v43[0]) = bswap32(*(_DWORD *)in) ^ v10;
        HIDWORD(v43[0]) = v15 ^ v11;
        CAST_encrypt(v43, ks);
        unsigned int v10 = v43[0];
        unsigned int v11 = HIDWORD(v43[0]);
        unsigned __int8 *out = BYTE3(v43[0]);
        out[1] = BYTE2(v10);
        out[2] = BYTE1(v10);
        out[3] = v10;
        out[4] = HIBYTE(v11);
        out[5] = BYTE2(v11);
        out[6] = BYTE1(v11);
        out += 8;
        v12[7] = v11;
        unsigned __int8 in = v14;
      }
      while (v13 > 0xF);
      unsigned __int8 in = v14;
    }
    if (v8)
    {
      int v16 = 0;
      int v17 = &in[v8];
      int v18 = 0;
      switch(v8)
      {
        case 1:
          goto LABEL_13;
        case 2:
          goto LABEL_12;
        case 3:
          goto LABEL_11;
        case 4:
          goto LABEL_10;
        case 5:
          goto LABEL_9;
        case 6:
          goto LABEL_8;
        case 7:
          int v19 = *--v17;
          int v16 = v19 << 8;
LABEL_8:
          int v20 = *--v17;
          v16 |= v20 << 16;
LABEL_9:
          int v21 = *--v17;
          v16 |= v21 << 24;
LABEL_10:
          int v18 = v16;
          int v22 = *--v17;
          int v16 = v22;
LABEL_11:
          int v23 = *--v17;
          v16 |= v23 << 8;
LABEL_12:
          int v24 = *--v17;
          v16 |= v24 << 16;
LABEL_13:
          v16 |= *(v17 - 1) << 24;
          break;
        default:
          int v18 = 0;
          break;
      }
      LODWORD(v43[0]) = v16 ^ v10;
      HIDWORD(v43[0]) = v18 ^ v11;
      CAST_encrypt(v43, ks);
      unsigned int v10 = v43[0];
      unsigned int v25 = HIDWORD(v43[0]);
      int v26 = HIBYTE(LODWORD(v43[0]));
      unsigned __int8 *out = BYTE3(v43[0]);
      unsigned int v27 = HIWORD(v10);
      out[1] = BYTE2(v10);
      unsigned int v28 = v10 >> 8;
      out[2] = BYTE1(v10);
      out[3] = v10;
      unsigned int v29 = HIBYTE(v25);
      out[4] = HIBYTE(v25);
      unsigned int v30 = HIWORD(v25);
      out[5] = BYTE2(v25);
      unsigned int v31 = v25 >> 8;
      out[6] = BYTE1(v25);
      out[7] = v25;
    }
    else
    {
      int v26 = HIBYTE(v10);
      unsigned int v27 = HIWORD(v10);
      unsigned int v28 = v10 >> 8;
      unsigned int v29 = HIBYTE(v11);
      unsigned int v30 = HIWORD(v11);
      LOBYTE(v25) = v11;
      unsigned int v31 = v11 >> 8;
    }
    unsigned __int8 *iv = v26;
    iv[1] = v27;
    iv[2] = v28;
    iv[3] = v10;
    iv[4] = v29;
    iv[5] = v30;
    iv[6] = v31;
  }
  else
  {
    if (length >= 8)
    {
      do
      {
        unsigned int v32 = out;
        unsigned int v33 = v10;
        unsigned int v34 = v11;
        unint64_t v35 = v8;
        v8 -= 8;
        unsigned int v10 = bswap32(*(_DWORD *)in);
        int v36 = in + 8;
        unsigned int v11 = bswap32(*((_DWORD *)in + 1));
        v43[0] = __PAIR64__(v11, v10);
        CAST_decrypt(v43, ks);
        int v37 = LODWORD(v43[0]) ^ v33;
        int v38 = HIDWORD(v43[0]) ^ v34;
        unsigned __int8 *v32 = (LODWORD(v43[0]) ^ v33) >> 24;
        v32[1] = BYTE2(v37);
        v32[2] = BYTE1(v37);
        v32[3] = v37;
        v32[4] = HIBYTE(v38);
        v32[5] = BYTE2(v38);
        v32[6] = BYTE1(v38);
        unsigned __int8 out = v32 + 8;
        v32[7] = v38;
        unsigned __int8 in = v36;
      }
      while (v35 > 0xF);
      unsigned __int8 in = v36;
    }
    if (v8)
    {
      unsigned int v39 = bswap32(*(_DWORD *)in);
      unsigned int v25 = bswap32(*((_DWORD *)in + 1));
      v43[0] = __PAIR64__(v25, v39);
      CAST_decrypt(v43, ks);
      int v40 = LODWORD(v43[0]) ^ v10;
      int v41 = HIDWORD(v43[0]) ^ v11;
      unint64_t v42 = &out[v8];
      switch(v8)
      {
        case 1:
          goto LABEL_26;
        case 2:
          goto LABEL_25;
        case 3:
          goto LABEL_24;
        case 4:
          goto LABEL_23;
        case 5:
          goto LABEL_22;
        case 6:
          goto LABEL_21;
        case 7:
          *--unint64_t v42 = BYTE1(v41);
LABEL_21:
          *--unint64_t v42 = BYTE2(v41);
LABEL_22:
          *--unint64_t v42 = HIBYTE(v41);
LABEL_23:
          *--unint64_t v42 = v40;
LABEL_24:
          *--unint64_t v42 = BYTE1(v40);
LABEL_25:
          *--unint64_t v42 = BYTE2(v40);
LABEL_26:
          *(v42 - md4_block_data_order((unint64_t)c, b, 1) = HIBYTE(v40);
          break;
        default:
          break;
      }
    }
    else
    {
      unsigned int v39 = v10;
      unsigned int v25 = v11;
    }
    unsigned __int8 *iv = HIBYTE(v39);
    iv[1] = BYTE2(v39);
    iv[2] = BYTE1(v39);
    iv[3] = v39;
    iv[4] = HIBYTE(v25);
    iv[5] = BYTE2(v25);
    iv[6] = BYTE1(v25);
  }
  iv[7] = v25;
}

int PKCS12_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen, ASN1_TYPE *param, const EVP_CIPHER *cipher, const EVP_MD *md_type, int en_de)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  if (param && param->type == 16 && (int ptr = param->value.ptr) != 0)
  {
    unsigned __int8 in = (unsigned __int8 *)*((void *)ptr + 1);
    unsigned int v14 = d2i_PBEPARAM(0, (const unsigned __int8 **)&in, *(int *)ptr);
    if (v14)
    {
      unsigned int v15 = v14;
      iter = v14->iter;
      if (iter)
      {
        int v17 = ASN1_INTEGER_get(iter);
        if (v17 <= 0)
        {
          int v18 = 101;
          int v19 = 99;
LABEL_18:
          ERR_put_error(35, 4095, v18, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs12/p12_crpt.c", v19);
          PBEPARAM_free(v15);
          return 0;
        }
      }
      else
      {
        int v17 = 1;
      }
      unsigned int data = v15->salt->data;
      int length = v15->salt->length;
      int v24 = EVP_CIPHER_key_length(cipher);
      if (PKCS12_key_gen_asc(pass, passlen, data, length, 1, v17, v24, out, md_type))
      {
        int v25 = EVP_CIPHER_iv_length(cipher);
        if (PKCS12_key_gen_asc(pass, passlen, data, length, 2, v17, v25, iv, md_type))
        {
          PBEPARAM_free(v15);
          EVP_CipherInit_ex(ctx, cipher, 0, out, iv, en_de);
          explicit_bzero(out, 0x40uLL);
        }
        int v18 = 106;
        int v19 = 113;
      }
      else
      {
        int v18 = 107;
        int v19 = 107;
      }
      goto LABEL_18;
    }
    int v20 = 92;
  }
  else
  {
    int v20 = 86;
  }
  ERR_put_error(35, 4095, 101, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/pkcs12/p12_crpt.c", v20);
  return 0;
}

uint64_t pkey_gost01_decrypt(uint64_t *a1, uint64_t a2, void *a3, const unsigned __int8 *a4, uint64_t a5)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  unsigned int v28 = a4;
  uint64_t v9 = EVP_PKEY_CTX_get0_pkey((uint64_t)a1);
  if (a2)
  {
    uint64_t v10 = v9;
    unsigned int v11 = d2i_GOST_KEY_TRANSPORT(0, &v28, a5);
    if (v11)
    {
      unsigned int v12 = v11;
      unint64_t v13 = X509_PUBKEY_get(*(X509_PUBKEY **)(*((void *)v11 + 1) + 8));
      if (v13)
      {
        if ((int)EVP_PKEY_derive_set_peer((uint64_t)a1, v13) <= 0)
        {
          int v14 = 111;
          int v15 = 401;
          goto LABEL_20;
        }
      }
      else if ((int)EVP_PKEY_CTX_ctrl(a1, -1, -1) <= 0)
      {
        int v14 = 107;
        int v15 = 408;
        goto LABEL_20;
      }
      uint64_t v17 = EVP_PKEY_CTX_get0_peerkey((uint64_t)a1);
      if (v17)
      {
        uint64_t v18 = v17;
        uint64_t v19 = OBJ_obj2nid(**((const ASN1_OBJECT ***)v12 + 1));
        uint64_t v20 = *(void *)(*((void *)v12 + 1) + 16);
        if (*(_DWORD *)v20 == 8)
        {
          uint64_t v30 = **(void **)(v20 + 8);
          int v21 = *(uint64_t **)v12;
          uint64_t v22 = **(void **)v12;
          if (*(_DWORD *)v22 == 32)
          {
            int v23 = *(long long **)(v22 + 8);
            long long v24 = v23[1];
            long long v31 = *v23;
            long long v32 = v24;
            uint64_t v25 = v21[1];
            if (*(_DWORD *)v25 == 4)
            {
              uint64_t v26 = v19;
              int v33 = **(_DWORD **)(v25 + 8);
              if ((int)gost01_VKO_key(v18, v10, (unsigned __int8 *)&v30, v29) >= 1) {
                gost_key_unwrap_crypto_pro(v26);
              }
              goto LABEL_21;
            }
            int v14 = 68;
            int v15 = 431;
          }
          else
          {
            int v14 = 137;
            int v15 = 426;
          }
        }
        else
        {
          int v14 = 103;
          int v15 = 421;
        }
      }
      else
      {
        int v14 = 116;
        int v15 = 414;
      }
LABEL_20:
      ERR_put_error(50, 4095, v14, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_pmeth.c", v15);
LABEL_21:
      uint64_t v16 = 0;
      EVP_PKEY_free(v13);
      GOST_KEY_TRANSPORT_free(v12);
      return v16;
    }
    ERR_put_error(50, 4095, 109, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_pmeth.c", 393);
    return 0xFFFFFFFFLL;
  }
  else
  {
    *a3 = 32;
    return 1;
  }
}

uint64_t gost01_VKO_key(uint64_t a1, uint64_t a2, unsigned __int8 *a3, void *a4)
{
  v22[8] = *MEMORY[0x263EF8340];
  uint64_t v8 = BN_CTX_new();
  if (!v8) {
    return 0;
  }
  uint64_t v9 = v8;
  BN_CTX_start(v8);
  uint64_t v10 = BN_CTX_get(v9);
  if (v10)
  {
    unsigned int v11 = v10;
    unsigned int v12 = BN_CTX_get(v9);
    if (v12)
    {
      unint64_t v13 = v12;
      int v14 = BN_CTX_get(v9);
      if (v14)
      {
        int v15 = v14;
        GOST_le2bn(a3, 8uLL, v11);
        int digest = GOST_KEY_get_digest(*(void *)(a2 + 32));
        if (VKO_compute_key((uint64_t)v13, (uint64_t)v15, *(void *)(a1 + 32), *(void *)(a2 + 32), v11))
        {
          if (digest == 942)
          {
            GOST_bn2le(v13, (uint64_t)__src, 64);
            GOST_bn2le(v15, (uint64_t)v22, 64);
            size_t v18 = 128;
          }
          else
          {
            if (digest != 941)
            {
              if (digest == 822)
              {
                GOST_bn2le(v13, (uint64_t)__src, 32);
                GOST_bn2le(v15, (uint64_t)v21, 32);
                GOSTR341194((uint64_t)__src);
                uint64_t v19 = 1;
              }
              else
              {
                uint64_t v19 = 4294967294;
              }
              goto LABEL_11;
            }
            GOST_bn2le(v13, (uint64_t)__src, 32);
            GOST_bn2le(v15, (uint64_t)v21, 32);
            size_t v18 = 64;
          }
          STREEBOG256(__src, v18, a4);
        }
      }
    }
  }
  uint64_t v19 = 0;
LABEL_11:
  BN_CTX_end(v9);
  BN_CTX_free(v9);
  return v19;
}

uint64_t pkey_gost01_derive(uint64_t a1, void *a2, void *a3)
{
  uint64_t v6 = EVP_PKEY_CTX_get0_pkey(a1);
  uint64_t v7 = EVP_PKEY_CTX_get0_peerkey(a1);
  uint64_t v8 = *(unsigned __int8 **)(EVP_PKEY_CTX_get_data(a1) + 16);
  if (!v8)
  {
    ERR_put_error(50, 4095, 123, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_pmeth.c", 462);
    return 0;
  }
  if (a2)
  {
    if ((int)gost01_VKO_key(v7, v6, v8, a2) >= 1)
    {
      *a3 = 32;
      return 1;
    }
    return 0;
  }
  uint64_t result = 32;
  *a3 = 32;
  return result;
}

uint64_t pkey_gost01_encrypt(uint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t v4 = a2;
  __buf[1] = *MEMORY[0x263EF8340];
  uint64_t v23 = a2;
  uint64_t v6 = (EVP_PKEY *)EVP_PKEY_CTX_get0_pkey((uint64_t)a1);
  uint64_t data = EVP_PKEY_CTX_get_data((uint64_t)a1);
  uint64_t v8 = EVP_PKEY_CTX_get0_peerkey((uint64_t)a1);
  uint64_t v9 = v8;
  uint64_t v10 = *(void **)(data + 16);
  if (v10)
  {
    __buf[0] = *v10;
    if (v8)
    {
LABEL_3:
      if (!GOST_KEY_get0_private_key(*(void *)(v9 + 32)))
      {
        ERR_put_error(50, 4095, 117, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_pmeth.c", 500);
        uint64_t v16 = 0;
LABEL_30:
        GOST_KEY_TRANSPORT_free(v16);
        return 0xFFFFFFFFLL;
      }
      int v11 = 0;
      unsigned int v12 = (EVP_PKEY *)v9;
      if (v4)
      {
LABEL_5:
        if ((int)gost01_VKO_key((uint64_t)v6, (uint64_t)v12, (unsigned __int8 *)__buf, v26) >= 1) {
          gost_key_wrap_crypto_pro(824);
        }
        uint64_t v16 = 0;
LABEL_25:
        if (!v11) {
          goto LABEL_30;
        }
        goto LABEL_29;
      }
      goto LABEL_17;
    }
  }
  else
  {
    arc4random_buf(__buf, 8uLL);
    if (v9) {
      goto LABEL_3;
    }
  }
  if (v4)
  {
    unsigned int v12 = EVP_PKEY_new();
    if (v12)
    {
      unint64_t v13 = GOST_KEY_new();
      if (v13)
      {
        int v14 = v13;
        int v15 = EVP_PKEY_base_id(&v6->type);
        if (EVP_PKEY_assign(v12, v15, (char *)v14))
        {
          if (EVP_PKEY_copy_parameters(v12, v6) && gost2001_keygen((const EC_GROUP **)v12->attributes))
          {
            int v11 = 1;
            goto LABEL_5;
          }
        }
        else
        {
          GOST_KEY_free(v14);
        }
      }
    }
    uint64_t v16 = 0;
    goto LABEL_29;
  }
  unsigned int v12 = 0;
  int v11 = 1;
LABEL_17:
  uint64_t v17 = GOST_KEY_TRANSPORT_new();
  uint64_t v16 = v17;
  if (!v17
    || !ASN1_OCTET_STRING_set(*(ASN1_OCTET_STRING **)(*((void *)v17 + 1) + 16), (const unsigned __int8 *)__buf, 8)
    || !ASN1_OCTET_STRING_set(*(ASN1_OCTET_STRING **)(*(void *)v16 + 8), v25, 4)
    || !ASN1_OCTET_STRING_set(**(ASN1_OCTET_STRING ***)v16, v24, 32))
  {
    goto LABEL_25;
  }
  uint64_t v18 = *((void *)v16 + 1);
  if (!v9)
  {
    if (X509_PUBKEY_set((X509_PUBKEY **)(v18 + 8), v6))
    {
      ASN1_OBJECT_free(**((ASN1_OBJECT ***)v16 + 1));
      **((void **)v16 + md4_block_data_order((unint64_t)c, b, 1) = OBJ_nid2obj(824);
      EVP_PKEY_free(v12);
      uint64_t v4 = v23;
      goto LABEL_34;
    }
    ERR_put_error(50, 4095, 106, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_pmeth.c", 547);
LABEL_29:
    EVP_PKEY_free(v12);
    goto LABEL_30;
  }
  ASN1_OBJECT_free(*(ASN1_OBJECT **)v18);
  **((void **)v16 + md4_block_data_order((unint64_t)c, b, 1) = OBJ_nid2obj(824);
  if ((int)EVP_PKEY_CTX_ctrl(a1, -1, -1) <= 0)
  {
    ERR_put_error(50, 4095, 107, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_pmeth.c", 559);
    goto LABEL_30;
  }
LABEL_34:
  if (v4) {
    int v21 = (unsigned __int8 **)&v23;
  }
  else {
    int v21 = 0;
  }
  int v22 = i2d_GOST_KEY_TRANSPORT(v16, v21);
  *a3 = v22;
  BOOL v19 = v22 != 0;
  GOST_KEY_TRANSPORT_free(v16);
  return v19;
}

uint64_t pkey_gost01_init(uint64_t a1)
{
  uint64_t v2 = EVP_PKEY_CTX_get0_pkey(a1);
  uint64_t result = (uint64_t)malloc_type_calloc(1uLL, 0x20uLL, 0x103004075AECAACuLL);
  if (result)
  {
    uint64_t v4 = (_DWORD *)result;
    if (v2)
    {
      uint64_t v5 = *(void *)(v2 + 32);
      if (v5)
      {
        uint64_t v6 = (const EC_GROUP *)GOST_KEY_get0_group(v5);
        _DWORD *v4 = EC_GROUP_get_curve_name(v6);
        v4[1] = GOST_KEY_get_digest(*(void *)(v2 + 32));
      }
    }
    EVP_PKEY_CTX_set_data(a1, (uint64_t)v4);
    return 1;
  }
  return result;
}

uint64_t pkey_gost01_copy(uint64_t a1, uint64_t a2)
{
  uint64_t result = pkey_gost01_init(a1);
  if (result)
  {
    uint64_t data = (_OWORD *)EVP_PKEY_CTX_get_data(a2);
    uint64_t v6 = (_OWORD *)EVP_PKEY_CTX_get_data(a1);
    long long v7 = data[1];
    *uint64_t v6 = *data;
    v6[1] = v7;
    if (*((void *)data + 2)) {
      *((void *)v6 + 2) = 0;
    }
    return 1;
  }
  return result;
}

void pkey_gost01_cleanup(uint64_t a1)
{
  uint64_t data = EVP_PKEY_CTX_get_data(a1);
  if (data)
  {
    uint64_t v2 = (void *)data;
    free(*(void **)(data + 16));
    free(v2);
  }
}

uint64_t pkey_gost01_paramgen(uint64_t a1, EVP_PKEY *a2)
{
  uint64_t data = (int *)EVP_PKEY_CTX_get_data(a1);
  if (*data && data[1])
  {
    uint64_t v4 = EC_GROUP_new_by_curve_name(*data);
    uint64_t v5 = v4;
    if (v4)
    {
      EC_GROUP_set_asn1_flag(v4, 1);
      uint64_t v6 = (char *)GOST_KEY_new();
      long long v7 = v6;
      if (v6)
      {
        if (GOST_KEY_set_digest((uint64_t)v6, data[1]))
        {
          if (GOST_KEY_set_group((EC_GROUP **)v7, v5))
          {
            uint64_t v8 = EVP_PKEY_assign(a2, 811, v7);
            if (v8) {
              goto LABEL_12;
            }
          }
        }
      }
    }
    else
    {
      long long v7 = 0;
    }
    GOST_KEY_free(v7);
    uint64_t v8 = 0;
LABEL_12:
    EC_GROUP_free(v5);
    return v8;
  }
  ERR_put_error(50, 4095, 115, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_pmeth.c", 197);
  return 0;
}

uint64_t pkey_gost01_keygen(uint64_t a1, uint64_t a2)
{
  uint64_t result = pkey_gost01_paramgen(a1, (EVP_PKEY *)a2);
  if (result) {
    return gost2001_keygen(*(const EC_GROUP ***)(a2 + 32)) != 0;
  }
  return result;
}

uint64_t pkey_gost01_sign(uint64_t a1, void *a2, uint64_t a3, unsigned __int8 *a4, unint64_t a5)
{
  uint64_t v10 = EVP_PKEY_CTX_get0_pkey(a1);
  uint64_t data = EVP_PKEY_CTX_get_data(a1);
  if (!v10) {
    return 0;
  }
  uint64_t v12 = data;
  unint64_t v13 = *(BIGNUM **)(v10 + 32);
  if (!v13) {
    return 0;
  }
  size_t size = GOST_KEY_get_size(v13);
  if (a3)
  {
    int v15 = (int)size;
    if (a2)
    {
      if (*(void *)a3 < (unint64_t)(2 * (void)size))
      {
        int v16 = 100;
        int v17 = 253;
LABEL_17:
        ERR_put_error(50, 4095, v16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_pmeth.c", v17);
        return 0;
      }
      if (a5 != 32 && a5 != 64)
      {
        int v16 = 136;
        int v17 = 257;
        goto LABEL_17;
      }
      uint64_t v18 = GOST_le2bn(a4, a5, 0);
      if (!v18) {
        return 0;
      }
      BOOL v19 = v18;
      uint64_t v20 = gost2001_do_sign(v18, *(void *)(v10 + 32));
      BN_free(v19);
      if (!v20) {
        return 0;
      }
      int v21 = *(_DWORD *)(v12 + 28);
      if (v21)
      {
        if (v21 == 1)
        {
          pack_signature_le(v20, v15, a2, (size_t *)a3);
          return 1;
        }
        a3 = 0xFFFFFFFFLL;
      }
      else
      {
        if (pack_signature_cp(v20, v15, a2, (size_t *)a3)) {
          return 1;
        }
        a3 = 0;
      }
      ECDSA_SIG_free(v20);
      return a3;
    }
    *(void *)a3 = 2 * (void)size;
    return 1;
  }
  return a3;
}

uint64_t pkey_gost01_verify(uint64_t a1, unsigned __int8 *a2, unint64_t a3, unsigned __int8 *a4, unint64_t a5)
{
  uint64_t v10 = EVP_PKEY_CTX_get0_pkey(a1);
  uint64_t data = EVP_PKEY_CTX_get_data(a1);
  if (!v10) {
    return 0;
  }
  int v12 = *(_DWORD *)(data + 28);
  if (v12 == 1)
  {
    int v15 = ECDSA_SIG_new();
    if (v15)
    {
      int v14 = v15;
      GOST_le2bn(a2, a3 >> 1, v15->r);
      GOST_le2bn(&a2[a3 >> 1], a3 >> 1, v14->s);
      goto LABEL_8;
    }
    int v19 = 110;
    goto LABEL_14;
  }
  if (v12) {
    return 0;
  }
  unint64_t v13 = ECDSA_SIG_new();
  if (!v13)
  {
    int v19 = 77;
LABEL_14:
    ERR_put_error(50, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_pmeth.c", v19);
    return 0;
  }
  int v14 = v13;
  BN_bin2bn(a2, a3 >> 1, v13->s);
  BN_bin2bn(&a2[a3 >> 1], a3 >> 1, v14->r);
LABEL_8:
  int v16 = GOST_le2bn(a4, a5, 0);
  int v17 = v16;
  if (v16) {
    uint64_t v18 = gost2001_do_verify(v16, (uint64_t *)v14, *(void *)(v10 + 32));
  }
  else {
    uint64_t v18 = 0;
  }
  BN_free(v17);
  ECDSA_SIG_free(v14);
  return v18;
}

uint64_t pkey_gost01_ctrl(uint64_t a1, int a2, unsigned int a3, EVP_MD *a4)
{
  uint64_t data = EVP_PKEY_CTX_get_data(a1);
  uint64_t result = 1;
  switch(a2)
  {
    case 1:
      int v9 = EVP_MD_type(a4);
      if (v9 == GostR3410_get_md_digest(*(unsigned int *)(data + 4)))
      {
        *(void *)(data + 8) = a4;
        goto LABEL_17;
      }
      int v12 = 100;
      int v13 = 585;
      goto LABEL_20;
    case 2:
      if (a3 < 2) {
        return result;
      }
      if (a3 == 3)
      {
        *(_DWORD *)(data + 24) = 1;
      }
      else if (a3 == 2)
      {
        uint64_t result = *(unsigned int *)(data + 24);
      }
      else
      {
LABEL_10:
        uint64_t result = 4294967294;
      }
      break;
    case 3:
    case 4:
    case 5:
    case 7:
      return result;
    case 6:
      goto LABEL_10;
    case 8:
      uint64_t v10 = malloc_type_malloc((int)a3, 0xB322FC91uLL);
      if (v10)
      {
        int v11 = v10;
        memcpy(v10, a4, (int)a3);
        free(*(void **)(data + 16));
        *(void *)(data + ++*(_DWORD *)(*(void *)(result + 8) + 16) = v11;
LABEL_17:
        uint64_t result = 1;
      }
      else
      {
        int v12 = 65;
        int v13 = 605;
LABEL_20:
        ERR_put_error(50, 4095, v12, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/gost/gostr341001_pmeth.c", v13);
LABEL_21:
        uint64_t result = 0;
      }
      break;
    default:
      switch(a2)
      {
        case 4097:
          *(_DWORD *)uint64_t data = a3;
          goto LABEL_17;
        case 4098:
          if (a3 > 1) {
            goto LABEL_21;
          }
          *(_DWORD *)(data + 28) = a3;
          break;
        case 4099:
          *(_DWORD *)(data + 4) = a3;
          goto LABEL_17;
        case 4100:
          a4->int type = *(_DWORD *)(data + 4);
          goto LABEL_17;
        default:
          goto LABEL_10;
      }
      goto LABEL_17;
  }
  return result;
}

uint64_t pkey_gost01_ctrl_str(uint64_t a1, char *__s1, char *a3)
{
  if (strcmp(__s1, "paramset"))
  {
    if (strcmp(__s1, "dgst")) {
      return 4294967294;
    }
    if (!a3) {
      return 0;
    }
    if (!strcmp(a3, "gost94") || !strcmp(a3, "md_gost94"))
    {
      int v9 = 822;
    }
    else if (!strcmp(a3, "streebog256"))
    {
      int v9 = 941;
    }
    else
    {
      if (strcmp(a3, "streebog512")) {
        return 0;
      }
      int v9 = 942;
    }
    *(_DWORD *)(EVP_PKEY_CTX_get_data(a1) + 4) = v9;
    return 1;
  }
  if (!a3) {
    return 0;
  }
  if (*(_DWORD *)(EVP_PKEY_CTX_get_data(a1) + 4) == 942) {
    int v7 = GostR3410_512_param_id(a3);
  }
  else {
    int v7 = GostR3410_256_param_id(a3);
  }
  int v8 = v7;
  if (v7 || (result = OBJ_txt2nid(a3), (int v8 = result) != 0))
  {
    *(_DWORD *)EVP_PKEY_CTX_get_data(amd4_block_data_order((unint64_t)c, b, 1) = v8;
    return 1;
  }
  return result;
}

uint64_t pack_signature_cp(ECDSA_SIG *a1, int a2, void *a3, size_t *a4)
{
  int v8 = BN_num_bits(a1->r);
  int v9 = v8 + 7;
  if (v8 < -7) {
    int v9 = v8 + 14;
  }
  int v10 = v9 >> 3;
  int v11 = BN_num_bits(a1->s);
  int v12 = v11 + 7;
  if (v11 < -7) {
    int v12 = v11 + 14;
  }
  int v13 = v12 >> 3;
  if (v10 > a2 || v13 > a2) {
    return 0;
  }
  size_t v16 = 2 * a2;
  *a4 = v16;
  bzero(a3, v16);
  BN_bn2bin(a1->s, (unsigned __int8 *)a3 + a2 - v13);
  BN_bn2bin(a1->r, (unsigned __int8 *)a3 + 2 * a2 - v10);
  ECDSA_SIG_free(a1);
  return 1;
}

void pack_signature_le(ECDSA_SIG *a1, int a2, void *a3, size_t *a4)
{
  size_t v7 = 2 * a2;
  *a4 = v7;
  bzero(a3, v7);
  GOST_bn2le(a1->r, (uint64_t)a3, a2);
  GOST_bn2le(a1->s, (uint64_t)a3 + a2, a2);
  ECDSA_SIG_free(a1);
}

const DSA_METHOD *DSA_OpenSSL(void)
{
  return (const DSA_METHOD *)&openssl_dsa_meth;
}

DSA_SIG *DSA_SIG_new(void)
{
  return (DSA_SIG *)malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
}

void DSA_SIG_free(DSA_SIG *a)
{
  if (a)
  {
    BN_free(a->r);
    BN_free(a->s);
    free(a);
  }
}

int DSA_sign_setup(DSA *dsa, BN_CTX *ctx_in, BIGNUM **kinvp, BIGNUM **rp)
{
  return (*(uint64_t (**)(void))&dsa->ex_data.sk->sorted)();
}

DSA_SIG *__cdecl DSA_do_sign(const unsigned __int8 *dgst, int dlen, DSA *dsa)
{
  return (DSA_SIG *)((uint64_t (*)(const unsigned __int8 *, void))dsa->ex_data.sk->data)(dgst, *(void *)&dlen);
}

int DSA_do_verify(const unsigned __int8 *dgst, int dgst_len, DSA_SIG *sig, DSA *dsa)
{
  return ((uint64_t (*)(const unsigned __int8 *, void, DSA_SIG *))dsa->ex_data.sk->comp)(dgst, *(void *)&dgst_len, sig);
}

void *dsa_do_sign(const unsigned __int8 *a1, int a2, uint64_t a3)
{
  int b = 0;
  X509_SIG a = 0;
  if (dsa_check_key(a3))
  {
    uint64_t v6 = BN_new();
    if (v6)
    {
      size_t v7 = BN_CTX_new();
      int v8 = v7;
      if (v7)
      {
        BN_CTX_start(v7);
        int v9 = BN_CTX_get(v8);
        if (v9)
        {
          int v10 = v9;
          int v11 = BN_CTX_get(v8);
          if (v11)
          {
            int v12 = v11;
            int v13 = BN_CTX_get(v8);
            if (v13)
            {
              int v14 = v13;
              int v15 = BN_CTX_get(v8);
              if (v15)
              {
                size_t v16 = v15;
                int v17 = BN_CTX_get(v8);
                if (v17)
                {
                  uint64_t v18 = v17;
                  int v19 = BN_num_bits(*(const BIGNUM **)(a3 + 24));
                  int v20 = v19 + 7;
                  if (v19 < -7) {
                    int v20 = v19 + 14;
                  }
                  if (a2 > v20 >> 3)
                  {
                    int v21 = BN_num_bits(*(const BIGNUM **)(a3 + 24));
                    int v22 = v21 + 7;
                    if (v21 < -7) {
                      int v22 = v21 + 14;
                    }
                    a2 = v22 >> 3;
                  }
                  if (BN_bin2bn(a1, a2, v18))
                  {
                    int v23 = 33;
                    while (1)
                    {
                      long long v24 = *(BIGNUM **)(a3 + 56);
                      if (v24 && *(void *)(a3 + 64))
                      {
                        int v25 = 0;
                        int b = *(BIGNUM **)(a3 + 64);
                        X509_SIG a = v24;
                        *(void *)(a3 + 56) = 0;
                        *(void *)(a3 + 64) = 0;
                      }
                      else
                      {
                        if (!(*(unsigned int (**)(uint64_t, BN_CTX *, BIGNUM **, BIGNUM **))(*(void *)(a3 + 104) + 16))(a3, v8, &a, &b))break; {
                        int v25 = 1;
                        }
                      }
                      uint64_t v26 = (BIGNUM *)BN_value_one();
                      if (!bn_rand_interval(v10, v26, *(BIGNUM **)(a3 + 24))
                        || !BN_mod_inverse_ct(v12, v10, *(const BIGNUM **)(a3 + 24), v8)
                        || !BN_mod_mul(v16, v10, *(const BIGNUM **)(a3 + 48), *(const BIGNUM **)(a3 + 24), v8)
                        || !BN_mod_mul(v16, v16, b, *(const BIGNUM **)(a3 + 24), v8)
                        || !BN_mod_mul(v14, v10, v18, *(const BIGNUM **)(a3 + 24), v8)
                        || !BN_mod_add(v6, v16, v14, *(const BIGNUM **)(a3 + 24), v8)
                        || !BN_mod_mul(v6, v6, a, *(const BIGNUM **)(a3 + 24), v8)
                        || !BN_mod_mul(v6, v6, v12, *(const BIGNUM **)(a3 + 24), v8))
                      {
                        break;
                      }
                      if (!BN_is_zero((uint64_t)b) && !BN_is_zero((uint64_t)v6))
                      {
                        uint64_t v30 = malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
                        if (v30)
                        {
                          unsigned int v28 = v30;
                          void *v30 = b;
                          v30[1] = v6;
                          goto LABEL_39;
                        }
                        int v27 = 65;
                        goto LABEL_38;
                      }
                      if (!v25)
                      {
                        int v27 = 110;
                        goto LABEL_38;
                      }
                      int v27 = 112;
                      if (!--v23) {
                        goto LABEL_38;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else
    {
      int v8 = 0;
    }
    int v27 = 3;
  }
  else
  {
    uint64_t v6 = 0;
    int v8 = 0;
    int v27 = 112;
  }
LABEL_38:
  ERR_put_error(10, 4095, v27, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_ossl.c", 217);
  BN_free(b);
  BN_free(v6);
  unsigned int v28 = 0;
LABEL_39:
  BN_CTX_end(v8);
  BN_CTX_free(v8);
  BN_free(a);
  return v28;
}

uint64_t dsa_sign_setup(uint64_t a1, BN_CTX *a2, BIGNUM **a3, BIGNUM **a4)
{
  if (!dsa_check_key(a1))
  {
    int v8 = 0;
    goto LABEL_24;
  }
  int v8 = BN_new();
  if (!v8)
  {
LABEL_24:
    int v9 = 0;
    goto LABEL_25;
  }
  int v9 = a2;
  if (!a2)
  {
    int v9 = BN_CTX_new();
    if (!v9) {
      goto LABEL_25;
    }
  }
  BN_CTX_start(v9);
  int v10 = BN_CTX_get(v9);
  if (!v10) {
    goto LABEL_25;
  }
  int v11 = v10;
  int v12 = BN_CTX_get(v9);
  if (!v12) {
    goto LABEL_25;
  }
  int v13 = v12;
  int v14 = BN_CTX_get(v9);
  if (!v14) {
    goto LABEL_25;
  }
  int v15 = v14;
  int v16 = BN_num_bits(*(const BIGNUM **)(a1 + 24));
  if (!BN_set_bit(v11, v16)) {
    goto LABEL_25;
  }
  if (!BN_set_bit(v13, v16)) {
    goto LABEL_25;
  }
  if (!BN_set_bit(v15, v16)) {
    goto LABEL_25;
  }
  int v17 = (BIGNUM *)BN_value_one();
  if (!bn_rand_interval(v11, v17, *(BIGNUM **)(a1 + 24))) {
    goto LABEL_25;
  }
  BN_set_flags((uint64_t)v11, 4);
  if ((*(unsigned char *)(a1 + 72) & 1) != 0
    && !BN_MONT_CTX_set_locked((BN_MONT_CTX **)(a1 + 80), 8, *(const BIGNUM **)(a1 + 16), v9))
  {
    goto LABEL_25;
  }
  if (!BN_add(v13, v11, *(const BIGNUM **)(a1 + 24)) || !BN_add(v15, v13, *(const BIGNUM **)(a1 + 24))) {
    goto LABEL_25;
  }
  uint64_t v18 = BN_num_bits(v13) <= v16 ? v15 : v13;
  if (!bn_copy(v11, v18)) {
    goto LABEL_25;
  }
  int v19 = *(unsigned int (**)(uint64_t, BIGNUM *, void, BIGNUM *, void, BN_CTX *, void))(*(void *)(a1 + 104) + 40);
  if (!v19)
  {
    if (BN_mod_exp_mont_ct(v8, *(const BIGNUM **)(a1 + 32), v11, *(const BIGNUM **)(a1 + 16), v9, *(BN_MONT_CTX **)(a1 + 80)))
    {
      goto LABEL_30;
    }
LABEL_25:
    ERR_put_error(10, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_ossl.c", 322);
    BN_free(v8);
    uint64_t v20 = 0;
    goto LABEL_26;
  }
  if (!v19(a1, v8, *(void *)(a1 + 32), v11, *(void *)(a1 + 16), v9, *(void *)(a1 + 80))) {
    goto LABEL_25;
  }
LABEL_30:
  if (!BN_mod_ct(v8, v8, *(const BIGNUM **)(a1 + 24), v9)) {
    goto LABEL_25;
  }
  int v22 = BN_mod_inverse_ct(0, v11, *(const BIGNUM **)(a1 + 24), v9);
  if (!v22) {
    goto LABEL_25;
  }
  int v23 = v22;
  BN_free(*a3);
  *a3 = v23;
  BN_free(*a4);
  *a4 = v8;
  uint64_t v20 = 1;
LABEL_26:
  BN_CTX_end(v9);
  if (v9 != a2) {
    BN_CTX_free(v9);
  }
  return v20;
}

uint64_t dsa_do_verify(const unsigned __int8 *a1, int a2, const BIGNUM **a3, uint64_t a4)
{
  if (!dsa_check_key(a4))
  {
    int v9 = 0;
    goto LABEL_14;
  }
  int v8 = BN_CTX_new();
  int v9 = v8;
  if (!v8) {
    goto LABEL_14;
  }
  BN_CTX_start(v8);
  int v10 = BN_CTX_get(v9);
  if (!v10) {
    goto LABEL_14;
  }
  int v11 = v10;
  int v12 = BN_CTX_get(v9);
  if (!v12) {
    goto LABEL_14;
  }
  int v13 = v12;
  int v14 = BN_CTX_get(v9);
  if (!v14) {
    goto LABEL_14;
  }
  int v15 = v14;
  if (!BN_is_zero((uint64_t)*a3)
    && !BN_is_negative((uint64_t)*a3)
    && BN_ucmp(*a3, *(const BIGNUM **)(a4 + 24)) < 0
    && !BN_is_zero((uint64_t)a3[1])
    && !BN_is_negative((uint64_t)a3[1])
    && BN_ucmp(a3[1], *(const BIGNUM **)(a4 + 24)) < 0)
  {
    if (!BN_mod_inverse_ct(v13, a3[1], *(const BIGNUM **)(a4 + 24), v9)) {
      goto LABEL_14;
    }
    int v18 = BN_num_bits(*(const BIGNUM **)(a4 + 24)) >> 3;
    int v19 = v18 >= a2 ? a2 : v18;
    if (!BN_bin2bn(a1, v19, v11)
      || !BN_mod_mul(v11, v11, v13, *(const BIGNUM **)(a4 + 24), v9)
      || !BN_mod_mul(v13, *a3, v13, *(const BIGNUM **)(a4 + 24), v9))
    {
      goto LABEL_14;
    }
    if (*(unsigned char *)(a4 + 72))
    {
      uint64_t v20 = BN_MONT_CTX_set_locked((BN_MONT_CTX **)(a4 + 80), 8, *(const BIGNUM **)(a4 + 16), v9);
      if (!v20) {
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t v20 = 0;
    }
    int v21 = *(unsigned int (**)(uint64_t, BIGNUM *, void, BIGNUM *, void, BIGNUM *, void, BN_CTX *, BN_MONT_CTX *))(*(void *)(a4 + 104) + 32);
    if (v21)
    {
      if (!v21(a4, v15, *(void *)(a4 + 32), v11, *(void *)(a4 + 40), v13, *(void *)(a4 + 16), v9, v20)) {
        goto LABEL_14;
      }
LABEL_30:
      if (BN_mod_ct(v11, v15, *(const BIGNUM **)(a4 + 24), v9))
      {
        uint64_t v16 = BN_ucmp(v11, *a3) == 0;
        goto LABEL_15;
      }
      goto LABEL_14;
    }
    if (BN_mod_exp2_mont(v15, *(const BIGNUM **)(a4 + 32), v11, *(const BIGNUM **)(a4 + 40), v13, *(const BIGNUM **)(a4 + 16), v9, v20))
    {
      goto LABEL_30;
    }
LABEL_14:
    ERR_put_error(10, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/dsa/dsa_ossl.c", 417);
    uint64_t v16 = 0xFFFFFFFFLL;
    goto LABEL_15;
  }
  uint64_t v16 = 0;
LABEL_15:
  BN_CTX_end(v9);
  BN_CTX_free(v9);
  return v16;
}

uint64_t dsa_init(uint64_t a1)
{
  *(_DWORD *)(a1 + 72) |= 1u;
  return 1;
}

uint64_t dsa_finish(uint64_t a1)
{
  return 1;
}

STACK *i2v_AUTHORITY_KEYID(uint64_t a1, int **a2, STACK *a3)
{
  extlist = a3;
  if (a3)
  {
    uint64_t v4 = 0;
  }
  else
  {
    uint64_t result = sk_new_null();
    uint64_t v4 = result;
    extlist = result;
    if (!result) {
      return result;
    }
  }
  if (*a2)
  {
    uint64_t v6 = hex_to_string(*((unsigned __int8 **)*a2 + 1), **a2);
    if (!v6 || !X509V3_add_value("keyid", v6, &extlist)) {
      goto LABEL_17;
    }
    free(v6);
  }
  size_t v7 = (GENERAL_NAMES *)a2[1];
  if (!v7 || (extlist = i2v_GENERAL_NAMES(0, v7, extlist)) != 0)
  {
    int v8 = (unsigned __int8 **)a2[2];
    if (v8)
    {
      uint64_t v6 = hex_to_string(v8[1], *(int *)v8);
      if (!v6 || !X509V3_add_value("serial", v6, &extlist)) {
        goto LABEL_17;
      }
      free(v6);
    }
    if (sk_num(extlist) >= 1) {
      return extlist;
    }
  }
  uint64_t v6 = 0;
LABEL_17:
  free(v6);
  sk_pop_free(v4, (void (__cdecl *)(void *))X509V3_conf_free);
  return 0;
}

AUTHORITY_KEYID *v2i_AUTHORITY_KEYID(int a1, uint64_t a2, STACK *a3)
{
  if (sk_num(a3) >= 1)
  {
    int v4 = 0;
    char v5 = 0;
    char v6 = 0;
    while (1)
    {
      size_t v7 = sk_value(a3, v4);
      int v8 = (const char *)*((void *)v7 + 1);
      if (!strcmp(v8, "keyid"))
      {
        int v10 = (const char *)*((void *)v7 + 2);
        if (v10)
        {
          if (!strcmp(v10, "always")) {
            char v6 = 2;
          }
          else {
            char v6 = 1;
          }
        }
        else
        {
          char v6 = 1;
        }
      }
      else
      {
        if (strcmp(v8, "issuer"))
        {
          ERR_put_error(34, 4095, 120, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_akey.c", 175);
          ERR_asprintf_error_data("name=%s", *((const char **)v7 + 1));
          return 0;
        }
        int v9 = (const char *)*((void *)v7 + 2);
        if (v9)
        {
          if (!strcmp(v9, "always")) {
            char v5 = 2;
          }
          else {
            char v5 = 1;
          }
        }
        else
        {
          char v5 = 1;
        }
      }
      if (++v4 >= sk_num(a3)) {
        goto LABEL_18;
      }
    }
  }
  char v6 = 0;
  char v5 = 0;
LABEL_18:
  if (!a2) {
    goto LABEL_29;
  }
  int v11 = *(X509 **)(a2 + 8);
  if (v11)
  {
    if (v6)
    {
      int ext_by_NID = X509_get_ext_by_NID(*(X509 **)(a2 + 8), 82, -1);
      if (ext_by_NID < 0 || (ext = X509_get_ext(v11, ext_by_NID)) == 0) {
        int v14 = 0;
      }
      else {
        int v14 = (ASN1_OCTET_STRING *)X509V3_EXT_d2i(ext);
      }
      if (v6 == 2 && !v14)
      {
        int v16 = 123;
        int v17 = 195;
        goto LABEL_30;
      }
    }
    else
    {
      int v14 = 0;
    }
    BOOL v18 = v5 != 0;
    if (v14) {
      BOOL v18 = 0;
    }
    if (v5 == 2 || v18)
    {
      issuer_name = X509_get_issuer_name(v11);
      int v21 = X509_NAME_dup(issuer_name);
      serialNumber = X509_get_serialNumber(v11);
      uint64_t v26 = ASN1_INTEGER_dup(serialNumber);
      int v19 = v26;
      if (v21 && v26)
      {
        int v23 = AUTHORITY_KEYID_new();
        if (v23)
        {
          uint64_t v20 = sk_new_null();
          if (v20)
          {
            int v22 = GENERAL_NAME_new();
            if (v22 && sk_push(v20, (char *)v22))
            {
              v22->int type = 4;
              v22->d.int ptr = (char *)v21;
              uint64_t result = v23;
              goto LABEL_41;
            }
          }
          else
          {
            int v22 = 0;
          }
          ERR_put_error(34, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_akey.c", 216);
        }
        else
        {
          uint64_t v20 = 0;
          int v22 = 0;
        }
      }
      else
      {
        ERR_put_error(34, 4095, 122, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_akey.c", 204);
        uint64_t v20 = 0;
        int v22 = 0;
        int v23 = 0;
      }
    }
    else
    {
      uint64_t result = AUTHORITY_KEYID_new();
      int v19 = 0;
      uint64_t v20 = 0;
      int v21 = 0;
      int v22 = 0;
      int v23 = 0;
      if (result)
      {
LABEL_41:
        result->issuer = v20;
        result->serial = v19;
        result->keyiunsigned int d = v14;
        return result;
      }
    }
    AUTHORITY_KEYID_free(v23);
    GENERAL_NAME_free(v22);
    sk_free(v20);
    X509_NAME_free(v21);
    ASN1_INTEGER_free(v19);
    ASN1_OCTET_STRING_free(v14);
    return 0;
  }
  if (*(_DWORD *)a2 != 1)
  {
LABEL_29:
    int v16 = 121;
    int v17 = 184;
LABEL_30:
    ERR_put_error(34, 4095, v16, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_akey.c", v17);
    return 0;
  }
  return AUTHORITY_KEYID_new();
}

void DES_cfb64_encrypt(const unsigned __int8 *in, unsigned __int8 *out, uint64_t length, DES_key_schedule *schedule, DES_cblock *ivec, int *num, int enc)
{
  uint64_t v10 = length;
  v20[1] = *MEMORY[0x263EF8340];
  int v13 = *num;
  if (enc)
  {
    if (length)
    {
      do
      {
        if (!v13)
        {
          v20[0] = *(void *)ivec;
          DES_encrypt1((unsigned int *)v20, schedule, 1);
          int v14 = HIDWORD(v20[0]);
          *(_DWORD *)ivec = v20[0];
          *(_DWORD *)&(*ivec)[4] = v14;
        }
        char v15 = *in++;
        unsigned __int8 v16 = (*ivec)[v13];
        *out++ = v16 ^ v15;
        (*ivec)[v13] = v16 ^ v15;
        int v13 = (v13 + 1) & 7;
        --v10;
      }
      while (v10);
    }
  }
  else if (length)
  {
    do
    {
      if (!v13)
      {
        v20[0] = *(void *)ivec;
        DES_encrypt1((unsigned int *)v20, schedule, 1);
        int v17 = HIDWORD(v20[0]);
        *(_DWORD *)ivec = v20[0];
        *(_DWORD *)&(*ivec)[4] = v17;
      }
      unsigned __int8 v18 = *in++;
      unsigned __int8 v19 = (*ivec)[v13];
      (*ivec)[v13] = v18;
      *out++ = v19 ^ v18;
      int v13 = (v13 + 1) & 7;
      --v10;
    }
    while (v10);
  }
  *uint64_t num = v13;
}

X509_REQ *__cdecl X509_to_X509_REQ(X509 *x, EVP_PKEY *pkey, const EVP_MD *md)
{
  char v6 = X509_REQ_new();
  size_t v7 = v6;
  if (!v6)
  {
    ERR_put_error(11, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_req.c", 85);
LABEL_10:
    X509_REQ_free(v7);
    return 0;
  }
  if (!X509_REQ_set_version(v6, 0)) {
    goto LABEL_10;
  }
  uint64_t subject_name = X509_get_subject_name(x);
  if (!X509_REQ_set_subject_name(v7, subject_name)) {
    goto LABEL_10;
  }
  pubuint64_t key = X509_get_pubkey(x);
  if (!pubkey) {
    goto LABEL_10;
  }
  uint64_t v10 = pubkey;
  int v11 = X509_REQ_set_pubkey(v7, pubkey);
  EVP_PKEY_free(v10);
  if (!v11 || pkey && !X509_REQ_sign(v7, pkey, md)) {
    goto LABEL_10;
  }
  return v7;
}

EVP_PKEY *__cdecl X509_REQ_get_pubkey(X509_REQ *req)
{
  if (req && req->req_info) {
    return X509_PUBKEY_get(req->req_info->pubkey);
  }
  else {
    return 0;
  }
}

EVP_PKEY *X509_REQ_get0_pubkey(uint64_t a1)
{
  if (a1 && *(void *)a1) {
    return X509_PUBKEY_get0(*(void *)(*(void *)a1 + 40));
  }
  else {
    return 0;
  }
}

int X509_REQ_check_private_key(X509_REQ *x509, EVP_PKEY *pkey)
{
  if (x509)
  {
    if (x509->req_info)
    {
      x509 = (X509_REQ *)X509_PUBKEY_get0((uint64_t)x509->req_info->pubkey);
      if (x509)
      {
        switch(EVP_PKEY_cmp((const EVP_PKEY *)x509, pkey))
        {
          case -2:
            if (pkey->type == 28)
            {
              int v3 = 114;
              int v4 = 162;
            }
            else if (pkey->type == 408)
            {
              int v3 = 16;
              int v4 = 155;
            }
            else
            {
              int v3 = 117;
              int v4 = 166;
            }
            goto LABEL_13;
          case -1:
            int v3 = 115;
            int v4 = 150;
            goto LABEL_13;
          case 0:
            int v3 = 116;
            int v4 = 147;
LABEL_13:
            ERR_put_error(11, 4095, v3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/x509/x509_req.c", v4);
            goto LABEL_14;
          case 1:
            LODWORD(x509) = 1;
            return (int)x509;
          default:
            goto LABEL_14;
        }
      }
    }
    else
    {
LABEL_14:
      LODWORD(x509) = 0;
    }
  }
  return (int)x509;
}

int X509_REQ_extension_nid(int nid)
{
  int v1 = *ext_nids;
  if (!*ext_nids) {
    return 0;
  }
  uint64_t v2 = ext_nids + 1;
  while (v1 != nid)
  {
    int v3 = *v2++;
    int v1 = v3;
    if (!v3) {
      return 0;
    }
  }
  return 1;
}

int *X509_REQ_get_extension_nids(void)
{
  return ext_nids;
}

void X509_REQ_set_extension_nids(int *nids)
{
  ext_nidunsigned int s = nids;
}

STACK *__cdecl X509_REQ_get_extensions(STACK *req)
{
  if (req)
  {
    int v1 = req;
    if (*(void *)&req->num) {
      BOOL v2 = ext_nids == 0;
    }
    else {
      BOOL v2 = 1;
    }
    if (v2) {
      return 0;
    }
    int v3 = *ext_nids;
    if (*ext_nids)
    {
      int v4 = ext_nids + 1;
      while (1)
      {
        int attr_by_NID = X509at_get_attr_by_NID(*(const STACK **)(*(void *)&v1->num + 48), v3, -1);
        if (attr_by_NID != -1) {
          break;
        }
        int v6 = *v4++;
        int v3 = v6;
        if (!v6) {
          goto LABEL_17;
        }
      }
      attr = X509at_get_attr(*(const STACK **)(*(void *)&v1->num + 48), attr_by_NID);
      int v8 = X509_ATTRIBUTE_get0_type(attr, 0);
      if (v8)
      {
        if (v8->type == 16)
        {
          int ptr = v8->value.ptr;
          unsigned __int8 in = (unsigned __int8 *)*((void *)ptr + 1);
          return d2i_X509_EXTENSIONS(0, (const unsigned __int8 **)&in, *(int *)ptr);
        }
        return 0;
      }
    }
LABEL_17:
    return sk_new_null();
  }
  return req;
}

int X509_REQ_get_attr_by_NID(const X509_REQ *req, int nid, int lastpos)
{
  return X509at_get_attr_by_NID(req->req_info->attributes, nid, lastpos);
}

X509_ATTRIBUTE *__cdecl X509_REQ_get_attr(const X509_REQ *req, int loc)
{
  return X509at_get_attr(req->req_info->attributes, loc);
}

int X509_REQ_add_extensions_nid(X509_REQ *req, STACK *exts, int nid)
{
  unsigned __int8 out = 0;
  int v5 = i2d_X509_EXTENSIONS(exts, &out);
  if (v5 < 1) {
    return 0;
  }
  BOOL v6 = X509at_add1_attr_by_NID(&req->req_info->attributes, nid, 16, out, v5) != 0;
  free(out);
  return v6;
}

int X509_REQ_add1_attr_by_NID(X509_REQ *req, int nid, int type, const unsigned __int8 *bytes, int len)
{
  return X509at_add1_attr_by_NID(&req->req_info->attributes, nid, type, bytes, len) != 0;
}

int X509_REQ_add_extensions(X509_REQ *req, STACK *exts)
{
  return X509_REQ_add_extensions_nid(req, exts, 172);
}

int X509_REQ_get_attr_count(const X509_REQ *req)
{
  return X509at_get_attr_count(req->req_info->attributes);
}

int X509_REQ_get_attr_by_OBJ(const X509_REQ *req, ASN1_OBJECT *obj, int lastpos)
{
  return X509at_get_attr_by_OBJ(req->req_info->attributes, obj, lastpos);
}

X509_ATTRIBUTE *__cdecl X509_REQ_delete_attr(X509_REQ *req, int loc)
{
  return X509at_delete_attr(req->req_info->attributes, loc);
}

int X509_REQ_add1_attr(X509_REQ *req, X509_ATTRIBUTE *attr)
{
  return X509at_add1_attr(&req->req_info->attributes, attr) != 0;
}

int X509_REQ_add1_attr_by_OBJ(X509_REQ *req, const ASN1_OBJECT *obj, int type, const unsigned __int8 *bytes, int len)
{
  return X509at_add1_attr_by_OBJ(&req->req_info->attributes, obj, type, bytes, len) != 0;
}

int X509_REQ_add1_attr_by_txt(X509_REQ *req, const char *attrname, int type, const unsigned __int8 *bytes, int len)
{
  return X509at_add1_attr_by_txt(&req->req_info->attributes, attrname, type, bytes, len) != 0;
}

uint64_t i2d_re_X509_REQ_tbs(X509_REQ_INFO **a1, unsigned __int8 **a2)
{
  BOOL v2 = *a1;
  v2->enc.modifieunsigned int d = 1;
  return i2d_X509_REQ_INFO(v2, a2);
}

uint64_t ec_GFp_simple_group_init(uint64_t a1)
{
  *(_DWORD *)(a1 + 20RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0;
  return 1;
}

void ec_GFp_simple_group_finish(uint64_t a1)
{
  BN_free((BIGNUM *)(a1 + 104));
  BN_free((BIGNUM *)(a1 + 152));
  BN_free((BIGNUM *)(a1 + 176));
}

BOOL ec_GFp_simple_group_copy(uint64_t a1, uint64_t a2)
{
  BOOL result = bn_copy((BIGNUM *)(a1 + 104), (const BIGNUM *)(a2 + 104));
  if (result)
  {
    BOOL result = bn_copy((BIGNUM *)(a1 + 152), (const BIGNUM *)(a2 + 152));
    if (result)
    {
      BOOL result = bn_copy((BIGNUM *)(a1 + 176), (const BIGNUM *)(a2 + 176));
      if (result)
      {
        *(_DWORD *)(a1 + 20RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = *(_DWORD *)(a2 + 200);
        return 1;
      }
    }
  }
  return result;
}

uint64_t ec_GFp_simple_group_set_curve(uint64_t a1, BIGNUM *a, const BIGNUM *a3, const BIGNUM *a4, BN_CTX *a5)
{
  if (BN_num_bits(a) >= 3 && BN_is_odd((uint64_t)a))
  {
    BN_CTX_start(a5);
    uint64_t v10 = BN_CTX_get(a5);
    if (!v10) {
      goto LABEL_16;
    }
    int v11 = v10;
    if (!bn_copy((BIGNUM *)(a1 + 104), a)) {
      goto LABEL_16;
    }
    BN_set_negative((BIGNUM *)(a1 + 104), 0);
    if (!BN_nnmod(v11, a3, a, a5)) {
      goto LABEL_16;
    }
    int v12 = *(unsigned int (**)(uint64_t, uint64_t, BIGNUM *, BN_CTX *))(*(void *)a1 + 288);
    if (v12)
    {
      if (!v12(a1, a1 + 152, v11, a5)) {
        goto LABEL_16;
      }
    }
    else if (!bn_copy((BIGNUM *)(a1 + 152), v11))
    {
      goto LABEL_16;
    }
    if (BN_nnmod((BIGNUM *)(a1 + 176), a4, a, a5))
    {
      int v14 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t, BN_CTX *))(*(void *)a1 + 288);
      if (!v14 || v14(a1, a1 + 176, a1 + 176, a5))
      {
        if (BN_add_word(v11, 3uLL))
        {
          *(_DWORD *)(a1 + 20RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = BN_cmp(v11, (const BIGNUM *)(a1 + 104)) == 0;
          uint64_t v13 = 1;
LABEL_17:
          BN_CTX_end(a5);
          return v13;
        }
      }
    }
LABEL_16:
    uint64_t v13 = 0;
    goto LABEL_17;
  }
  ERR_put_error(16, 4095, 103, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_smpl.c", 126);
  return 0;
}

uint64_t ec_GFp_simple_group_get_curve(uint64_t a1, BIGNUM *a2, BIGNUM *a3, BIGNUM *a4, uint64_t a5)
{
  if (a2)
  {
    uint64_t result = bn_copy(a2, (const BIGNUM *)(a1 + 104));
    if (!result) {
      return result;
    }
  }
  uint64_t v10 = *(uint64_t (**)(uint64_t, BIGNUM *, uint64_t, uint64_t))(*(void *)a1 + 296);
  if (v10)
  {
    if (a3)
    {
      uint64_t result = v10(a1, a3, a1 + 152, a5);
      if (!result) {
        return result;
      }
    }
    if (a4)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, BIGNUM *, uint64_t, uint64_t))(*(void *)a1 + 296))(a1, a4, a1 + 176, a5);
      if (!result) {
        return result;
      }
    }
    return 1;
  }
  if (!a3 || (uint64_t result = bn_copy(a3, (const BIGNUM *)(a1 + 152)), result))
  {
    if (!a4) {
      return 1;
    }
    uint64_t result = bn_copy(a4, (const BIGNUM *)(a1 + 176));
    if (result) {
      return 1;
    }
  }
  return result;
}

uint64_t ec_GFp_simple_group_get_degree(uint64_t a1)
{
  return BN_num_bits((const BIGNUM *)(a1 + 104));
}

BIGNUM *ec_GFp_simple_group_check_discriminant(uint64_t a1, BN_CTX *ctx)
{
  BN_CTX_start(ctx);
  int v4 = BN_CTX_get(ctx);
  if (v4)
  {
    int v5 = BN_CTX_get(ctx);
    if (!v5) {
      goto LABEL_14;
    }
    BOOL v6 = v5;
    size_t v7 = BN_CTX_get(ctx);
    if (!v7) {
      goto LABEL_14;
    }
    int v8 = v7;
    int v9 = BN_CTX_get(ctx);
    if (!v9) {
      goto LABEL_14;
    }
    uint64_t v10 = v9;
    if (!BN_CTX_get(ctx)) {
      goto LABEL_14;
    }
    int v11 = *(unsigned int (**)(uint64_t, BIGNUM *, uint64_t, BN_CTX *))(*(void *)a1 + 296);
    if (v11)
    {
      if (!v11(a1, v4, a1 + 152, ctx)
        || !(*(unsigned int (**)(uint64_t, BIGNUM *, uint64_t, BN_CTX *))(*(void *)a1 + 296))(a1, v6, a1 + 176, ctx))
      {
        goto LABEL_14;
      }
    }
    else if (!bn_copy(v4, (const BIGNUM *)(a1 + 152)) || !bn_copy(v6, (const BIGNUM *)(a1 + 176)))
    {
      goto LABEL_14;
    }
    is_zerASN1_OBJECT o = BN_is_zero((uint64_t)v4);
    BOOL v13 = BN_is_zero((uint64_t)v6);
    if (is_zero)
    {
      if (v13)
      {
LABEL_14:
        int v4 = 0;
        goto LABEL_15;
      }
    }
    else if (!v13)
    {
      char v15 = (const BIGNUM *)(a1 + 104);
      if (!BN_mod_sqr(v8, v4, v15, ctx)
        || !BN_mod_mul(v10, v8, v4, v15, ctx)
        || !BN_lshift(v8, v10, 2)
        || !BN_mod_sqr(v10, v6, v15, ctx)
        || !BN_mul_word(v10, 0x1BuLL)
        || !BN_mod_add(v4, v8, v10, v15, ctx)
        || BN_is_zero((uint64_t)v4))
      {
        goto LABEL_14;
      }
    }
    int v4 = (BIGNUM *)1;
  }
LABEL_15:
  BN_CTX_end(ctx);
  return v4;
}

uint64_t ec_GFp_simple_point_init(uint64_t a1)
{
  *(_DWORD *)(a1 + 8RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0;
  return 1;
}

void ec_GFp_simple_point_finish(uint64_t a1)
{
  *(_DWORD *)(a1 + 8RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0;
}

BOOL ec_GFp_simple_point_copy(uint64_t a1, uint64_t a2)
{
  BOOL result = bn_copy((BIGNUM *)(a1 + 8), (const BIGNUM *)(a2 + 8));
  if (result)
  {
    BOOL result = bn_copy((BIGNUM *)(a1 + 32), (const BIGNUM *)(a2 + 32));
    if (result)
    {
      BOOL result = bn_copy((BIGNUM *)(a1 + 56), (const BIGNUM *)(a2 + 56));
      if (result)
      {
        *(_DWORD *)(a1 + 8RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = *(_DWORD *)(a2 + 80);
        return 1;
      }
    }
  }
  return result;
}

uint64_t ec_GFp_simple_point_set_to_infinity(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 8RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0;
  BN_zero(a2 + 56);
  return 1;
}

uint64_t ec_GFp_simple_set_Jprojective_coordinates(uint64_t a1, uint64_t a2, BIGNUM *m, BIGNUM *a4, BIGNUM *a5, BN_CTX *ctx)
{
  if (!m
    || (uint64_t result = BN_nnmod((BIGNUM *)(a2 + 8), m, (const BIGNUM *)(a1 + 104), ctx), result)
    && ((int v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, BN_CTX *))(*(void *)a1 + 288)) == 0
     || (uint64_t result = v12(a1, a2 + 8, a2 + 8, ctx), result)))
  {
    if (!a4
      || (uint64_t result = BN_nnmod((BIGNUM *)(a2 + 32), a4, (const BIGNUM *)(a1 + 104), ctx), result)
      && ((BOOL v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, BN_CTX *))(*(void *)a1 + 288)) == 0
       || (uint64_t result = v13(a1, a2 + 32, a2 + 32, ctx), result)))
    {
      if (a5)
      {
        uint64_t result = BN_nnmod((BIGNUM *)(a2 + 56), a5, (const BIGNUM *)(a1 + 104), ctx);
        if (!result) {
          return result;
        }
        BOOL is_one = BN_is_one(a2 + 56);
        BOOL v15 = is_one;
        unsigned __int8 v16 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, BN_CTX *))(*(void *)a1 + 288);
        if (v16)
        {
          if (is_one && (int v17 = *(uint64_t (**)(uint64_t, uint64_t, BN_CTX *))(*(void *)a1 + 304)) != 0)
          {
            uint64_t result = v17(a1, a2 + 56, ctx);
            if (!result) {
              return result;
            }
          }
          else
          {
            uint64_t result = v16(a1, a2 + 56, a2 + 56, ctx);
            if (!result) {
              return result;
            }
          }
        }
        *(_DWORD *)(a2 + 8RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = v15;
      }
      return 1;
    }
  }
  return result;
}

uint64_t ec_GFp_simple_get_Jprojective_coordinates(uint64_t a1, uint64_t a2, BIGNUM *a3, BIGNUM *a4, BIGNUM *a5, uint64_t a6)
{
  int v9 = *(uint64_t (**)(uint64_t, BIGNUM *, uint64_t, uint64_t))(*(void *)a1 + 296);
  if (v9)
  {
    if (a3)
    {
      uint64_t result = v9(a1, a3, a2 + 8, a6);
      if (!result) {
        return result;
      }
    }
    if (a4)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, BIGNUM *, uint64_t, uint64_t))(*(void *)a1 + 296))(a1, a4, a2 + 32, a6);
      if (!result) {
        return result;
      }
    }
    if (a5)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, BIGNUM *, uint64_t, uint64_t))(*(void *)a1 + 296))(a1, a5, a2 + 56, a6);
      if (!result) {
        return result;
      }
    }
    return 1;
  }
  if (!a3 || (uint64_t result = bn_copy(a3, (const BIGNUM *)(a2 + 8)), result))
  {
    if (!a4 || (uint64_t result = bn_copy(a4, (const BIGNUM *)(a2 + 32)), result))
    {
      if (!a5) {
        return 1;
      }
      uint64_t result = bn_copy(a5, (const BIGNUM *)(a2 + 56));
      if (result) {
        return 1;
      }
    }
  }
  return result;
}

uint64_t ec_GFp_simple_point_set_affine_coordinates(const EC_GROUP *a1, const EC_POINT *a2, uint64_t a3, uint64_t a4, BN_CTX *a5)
{
  if (a3 && a4)
  {
    uint64_t v10 = BN_value_one();
    return EC_POINT_set_Jprojective_coordinates(a1, a2, a3, a4, (uint64_t)v10, a5);
  }
  else
  {
    ERR_put_error(16, 4095, 67, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_smpl.c", 406);
    return 0;
  }
}

uint64_t ec_GFp_simple_point_get_affine_coordinates(const EC_GROUP *a1, uint64_t a2, BIGNUM *a3, BIGNUM *a4, BN_CTX *a5)
{
  if (EC_POINT_is_at_infinity(a1, (const EC_POINT *)a2) < 1)
  {
    BN_CTX_start(a5);
    int v11 = BN_CTX_get(a5);
    if (!v11) {
      goto LABEL_26;
    }
    int v12 = v11;
    BOOL v13 = BN_CTX_get(a5);
    if (!v13) {
      goto LABEL_26;
    }
    int v14 = v13;
    BOOL v15 = BN_CTX_get(a5);
    if (!v15) {
      goto LABEL_26;
    }
    unsigned __int8 v16 = v15;
    int v17 = BN_CTX_get(a5);
    if (!v17) {
      goto LABEL_26;
    }
    unsigned __int8 v18 = v17;
    unsigned __int8 v19 = *(unsigned int (**)(const EC_GROUP *, BIGNUM *, uint64_t, BN_CTX *))(*(void *)a1 + 296);
    uint64_t v20 = (const BIGNUM *)(a2 + 56);
    if (v19)
    {
      uint64_t v20 = v12;
      if (!v19(a1, v12, a2 + 56, a5)) {
        goto LABEL_26;
      }
    }
    if (BN_is_one((uint64_t)v20))
    {
      int v21 = *(unsigned int (**)(const EC_GROUP *, BIGNUM *, uint64_t, BN_CTX *))(*(void *)a1 + 296);
      if (v21)
      {
        if (a3 && !v21(a1, a3, a2 + 8, a5)
          || a4
          && !(*(unsigned int (**)(const EC_GROUP *, BIGNUM *, uint64_t, BN_CTX *))(*(void *)a1 + 296))(a1, a4, a2 + 32, a5))
        {
          goto LABEL_26;
        }
      }
      else if (a3 && !bn_copy(a3, (const BIGNUM *)(a2 + 8)) || a4 && !bn_copy(a4, (const BIGNUM *)(a2 + 32)))
      {
        goto LABEL_26;
      }
LABEL_38:
      uint64_t v10 = 1;
      goto LABEL_27;
    }
    if (BN_mod_inverse_ct(v14, v20, (const BIGNUM *)((char *)a1 + 104), a5))
    {
      if (*(void *)(*(void *)a1 + 288))
      {
        if (!BN_mod_sqr(v16, v14, (const BIGNUM *)((char *)a1 + 104), a5)) {
          goto LABEL_26;
        }
      }
      else if (!(*(unsigned int (**)(const EC_GROUP *, BIGNUM *, BIGNUM *, BN_CTX *))(*(void *)a1 + 272))(a1, v16, v14, a5))
      {
        goto LABEL_26;
      }
      if (a3
        && !(*(unsigned int (**)(const EC_GROUP *, BIGNUM *, uint64_t, BIGNUM *, BN_CTX *))(*(void *)a1 + 264))(a1, a3, a2 + 8, v16, a5))
      {
        goto LABEL_26;
      }
      if (!a4) {
        goto LABEL_38;
      }
      if (*(void *)(*(void *)a1 + 288))
      {
        if (!BN_mod_mul(v18, v16, v14, (const BIGNUM *)((char *)a1 + 104), a5)) {
          goto LABEL_26;
        }
      }
      else if (!(*(unsigned int (**)(const EC_GROUP *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *))(*(void *)a1 + 264))(a1, v18, v16, v14, a5))
      {
        goto LABEL_26;
      }
      if ((*(unsigned int (**)(const EC_GROUP *, BIGNUM *, uint64_t, BIGNUM *, BN_CTX *))(*(void *)a1 + 264))(a1, a4, a2 + 32, v18, a5))
      {
        goto LABEL_38;
      }
    }
    else
    {
      ERR_put_error(16, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_smpl.c", 469);
    }
LABEL_26:
    uint64_t v10 = 0;
LABEL_27:
    BN_CTX_end(a5);
    return v10;
  }
  ERR_put_error(16, 4095, 106, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_smpl.c", 422);
  return 0;
}

uint64_t ec_GFp_simple_add(EC_GROUP *a1, EC_POINT *r, EC_POINT *a, uint64_t a4, BN_CTX *a5)
{
  int v5 = a5;
  if (a != (EC_POINT *)a4)
  {
    if (EC_POINT_is_at_infinity(a1, a) >= 1)
    {
      uint64_t v10 = r;
      int v11 = (const EC_POINT *)a4;
LABEL_9:
      return EC_POINT_copy(v10, v11);
    }
    if (EC_POINT_is_at_infinity(a1, (const EC_POINT *)a4) >= 1)
    {
      uint64_t v10 = r;
      int v11 = a;
      goto LABEL_9;
    }
    int v14 = *(unsigned int (**)(EC_GROUP *, BIGNUM *, char *, BIGNUM *, BN_CTX *))(*(void *)a1 + 264);
    BOOL v13 = *(unsigned int (**)(EC_GROUP *, BIGNUM *))(*(void *)a1 + 272);
    BN_CTX_start(v5);
    BOOL v15 = BN_CTX_get(v5);
    if (!v15) {
      goto LABEL_67;
    }
    unsigned __int8 v16 = v15;
    int v17 = BN_CTX_get(v5);
    if (!v17) {
      goto LABEL_67;
    }
    unsigned __int8 v18 = v17;
    unsigned __int8 v19 = BN_CTX_get(v5);
    if (!v19) {
      goto LABEL_67;
    }
    aX509_SIG a = v19;
    uint64_t v20 = BN_CTX_get(v5);
    if (!v20) {
      goto LABEL_67;
    }
    int b = v20;
    int v21 = BN_CTX_get(v5);
    if (!v21) {
      goto LABEL_67;
    }
    uint64_t v30 = v21;
    int v22 = BN_CTX_get(v5);
    if (!v22) {
      goto LABEL_67;
    }
    rX509_SIG a = v22;
    int v23 = BN_CTX_get(v5);
    if (!v23) {
      goto LABEL_67;
    }
    unsigned int v28 = v23;
    if (*(_DWORD *)(a4 + 80))
    {
      if (!bn_copy(v18, (const BIGNUM *)((char *)a + 8)) || !bn_copy(aa, (const BIGNUM *)((char *)a + 32))) {
        goto LABEL_67;
      }
    }
    else if (!v13(a1, v16) {
           || !v14(a1, v18, (char *)a + 8, v16, v5)
    }
           || !v14(a1, v16, (char *)v16, (BIGNUM *)(a4 + 56), v5)
           || !v14(a1, aa, (char *)a + 32, v16, v5))
    {
      goto LABEL_67;
    }
    if (*((_DWORD *)a + 20))
    {
      if (!bn_copy(b, (const BIGNUM *)(a4 + 8)) || !bn_copy(v30, (const BIGNUM *)(a4 + 32))) {
        goto LABEL_67;
      }
    }
    else if (!v13(a1, v16) {
           || !v14(a1, b, (char *)(a4 + 8), v16, v5)
    }
           || !v14(a1, v16, (char *)v16, (BIGNUM *)((char *)a + 56), v5)
           || !v14(a1, v30, (char *)(a4 + 32), v16, v5))
    {
      goto LABEL_67;
    }
    if (!BN_mod_sub_quick(ra, v18, b, (const BIGNUM *)((char *)a1 + 104))
      || !BN_mod_sub_quick(v28, aa, v30, (const BIGNUM *)((char *)a1 + 104)))
    {
      goto LABEL_67;
    }
    if (BN_is_zero((uint64_t)ra))
    {
      if (BN_is_zero((uint64_t)v28))
      {
        BN_CTX_end(v5);
        uint64_t v24 = EC_POINT_dbl(a1, r, a, v5);
        int v5 = 0;
      }
      else
      {
        BN_zero((uint64_t)r + 56);
        *((_DWORD *)r + 2RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0;
        uint64_t v24 = 1;
      }
      goto LABEL_68;
    }
    if (!BN_mod_add_quick(v18, v18, b, (const BIGNUM *)((char *)a1 + 104))
      || !BN_mod_add_quick(aa, aa, v30, (const BIGNUM *)((char *)a1 + 104)))
    {
      goto LABEL_67;
    }
    int v25 = *(_DWORD *)(a4 + 80);
    if (*((_DWORD *)a + 20))
    {
      if (v25)
      {
        if (!bn_copy((BIGNUM *)((char *)r + 56), ra)) {
          goto LABEL_67;
        }
LABEL_54:
        *((_DWORD *)r + 2RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0;
        if (((unsigned int (*)(EC_GROUP *, BIGNUM *, BIGNUM *, BN_CTX *))v13)(a1, v16, v28, v5)
          && ((unsigned int (*)(EC_GROUP *, BIGNUM *, BIGNUM *, BN_CTX *))v13)(a1, v30, ra, v5)
          && v14(a1, b, (char *)v18, v30, v5)
          && BN_mod_sub_quick((BIGNUM *)((char *)r + 8), v16, b, (const BIGNUM *)((char *)a1 + 104))
          && BN_mod_lshift1_quick(v16, (const BIGNUM *)((char *)r + 8), (const BIGNUM *)((char *)a1 + 104))
          && BN_mod_sub_quick(v16, b, v16, (const BIGNUM *)((char *)a1 + 104))
          && v14(a1, v16, (char *)v16, v28, v5)
          && v14(a1, ra, (char *)v30, ra, v5)
          && v14(a1, v18, (char *)aa, ra, v5)
          && BN_mod_sub_quick(v16, v16, v18, (const BIGNUM *)((char *)a1 + 104))
          && (!BN_is_odd((uint64_t)v16) || BN_add(v16, v16, (const BIGNUM *)((char *)a1 + 104))))
        {
          uint64_t v24 = BN_rshift1((BIGNUM *)((char *)r + 32), v16) != 0;
LABEL_68:
          BN_CTX_end(v5);
          return v24;
        }
LABEL_67:
        uint64_t v24 = 0;
        goto LABEL_68;
      }
      int v27 = (const BIGNUM *)(a4 + 56);
      uint64_t v26 = v16;
    }
    else
    {
      if (!v25)
      {
        if (!v14(a1, v16, (char *)a + 56, (BIGNUM *)(a4 + 56), v5)) {
          goto LABEL_67;
        }
        goto LABEL_53;
      }
      uint64_t v26 = v16;
      int v27 = (const BIGNUM *)((char *)a + 56);
    }
    if (!bn_copy(v26, v27)) {
      goto LABEL_67;
    }
LABEL_53:
    if (!v14(a1, (BIGNUM *)((char *)r + 56), (char *)v16, ra, v5)) {
      goto LABEL_67;
    }
    goto LABEL_54;
  }
  return EC_POINT_dbl(a1, r, a, a5);
}

BOOL ec_GFp_simple_dbl(const EC_GROUP *a1, uint64_t a2, EC_POINT *a3, BN_CTX *a4)
{
  if (EC_POINT_is_at_infinity(a1, a3) < 1)
  {
    int v9 = *(unsigned int (**)(const EC_GROUP *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *))(*(void *)a1 + 264);
    uint64_t v10 = *(unsigned int (**)(const EC_GROUP *, BIGNUM *, char *, BN_CTX *))(*(void *)a1 + 272);
    BN_CTX_start(a4);
    int v11 = BN_CTX_get(a4);
    if (!v11) {
      goto LABEL_43;
    }
    int v12 = v11;
    BOOL v13 = BN_CTX_get(a4);
    if (!v13) {
      goto LABEL_43;
    }
    int v14 = v13;
    BOOL v15 = BN_CTX_get(a4);
    if (!v15) {
      goto LABEL_43;
    }
    unsigned __int8 v16 = v15;
    int v17 = BN_CTX_get(a4);
    if (!v17) {
      goto LABEL_43;
    }
    r = v17;
    if (*((_DWORD *)a3 + 20))
    {
      if (!v10(a1, v12, (char *)a3 + 8, a4)
        || !BN_mod_lshift1_quick(v14, v12, (const BIGNUM *)((char *)a1 + 104))
        || !BN_mod_add_quick(v12, v12, v14, (const BIGNUM *)((char *)a1 + 104)))
      {
        goto LABEL_43;
      }
      unsigned __int8 v18 = (const BIGNUM *)((char *)a1 + 152);
      unsigned __int8 v19 = v14;
      uint64_t v20 = v12;
    }
    else if (*((_DWORD *)a1 + 50))
    {
      if (!v10(a1, v14, (char *)a3 + 56, a4)
        || !BN_mod_add_quick(v12, (const BIGNUM *)((char *)a3 + 8), v14, (const BIGNUM *)((char *)a1 + 104))
        || !BN_mod_sub_quick(v16, (const BIGNUM *)((char *)a3 + 8), v14, (const BIGNUM *)((char *)a1 + 104))
        || !v9(a1, v14, v12, v16, a4)
        || !BN_mod_lshift1_quick(v12, v14, (const BIGNUM *)((char *)a1 + 104)))
      {
        goto LABEL_43;
      }
      unsigned __int8 v19 = v14;
      uint64_t v20 = v12;
      unsigned __int8 v18 = v14;
    }
    else
    {
      if (!v10(a1, v12, (char *)a3 + 8, a4)
        || !BN_mod_lshift1_quick(v14, v12, (const BIGNUM *)((char *)a1 + 104))
        || !BN_mod_add_quick(v12, v12, v14, (const BIGNUM *)((char *)a1 + 104))
        || !v10(a1, v14, (char *)a3 + 56, a4)
        || !v10(a1, v14, (char *)v14, a4)
        || !v9(a1, v14, v14, (BIGNUM *)((char *)a1 + 152), a4))
      {
        goto LABEL_43;
      }
      unsigned __int8 v19 = v14;
      uint64_t v20 = v14;
      unsigned __int8 v18 = v12;
    }
    if (BN_mod_add_quick(v19, v20, v18, (const BIGNUM *)((char *)a1 + 104)))
    {
      if (*((_DWORD *)a3 + 20))
      {
        if (!bn_copy(v12, (const BIGNUM *)((char *)a3 + 32))) {
          goto LABEL_43;
        }
      }
      else if (!v9(a1, v12, (BIGNUM *)((char *)a3 + 32), (BIGNUM *)((char *)a3 + 56), a4))
      {
        goto LABEL_43;
      }
      if (BN_mod_lshift1_quick((BIGNUM *)(a2 + 56), v12, (const BIGNUM *)((char *)a1 + 104)))
      {
        *(_DWORD *)(a2 + 8RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0;
        if (v10(a1, r, (char *)a3 + 32, a4))
        {
          if (v9(a1, v16, (BIGNUM *)((char *)a3 + 8), r, a4)
            && BN_mod_lshift_quick(v16, v16, 2, (const BIGNUM *)((char *)a1 + 104))
            && BN_mod_lshift1_quick(v12, v16, (const BIGNUM *)((char *)a1 + 104))
            && v10(a1, (BIGNUM *)(a2 + 8), (char *)v14, a4)
            && BN_mod_sub_quick((BIGNUM *)(a2 + 8), (const BIGNUM *)(a2 + 8), v12, (const BIGNUM *)((char *)a1 + 104))
            && v10(a1, v12, (char *)r, a4)
            && BN_mod_lshift_quick(r, v12, 3, (const BIGNUM *)((char *)a1 + 104))
            && BN_mod_sub_quick(v12, v16, (const BIGNUM *)(a2 + 8), (const BIGNUM *)((char *)a1 + 104))
            && v9(a1, v12, v14, v12, a4))
          {
            BOOL v8 = BN_mod_sub_quick((BIGNUM *)(a2 + 32), v12, r, (const BIGNUM *)((char *)a1 + 104)) != 0;
LABEL_44:
            BN_CTX_end(a4);
            return v8;
          }
        }
      }
    }
LABEL_43:
    BOOL v8 = 0;
    goto LABEL_44;
  }
  BN_zero(a2 + 56);
  *(_DWORD *)(a2 + 8RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0;
  return 1;
}

uint64_t ec_GFp_simple_invert(uint64_t a1, const EC_POINT *a2)
{
  if (EC_POINT_is_at_infinity((const EC_GROUP *)a1, a2) > 0) {
    return 1;
  }
  int v4 = (BIGNUM *)((char *)a2 + 32);
  if (BN_is_zero((uint64_t)v4)) {
    return 1;
  }
  return BN_usub(v4, (const BIGNUM *)(a1 + 104), v4);
}

BOOL ec_GFp_simple_is_at_infinity(uint64_t a1, uint64_t a2)
{
  return BN_is_zero(a2 + 56);
}

uint64_t ec_GFp_simple_is_on_curve(const EC_GROUP *a1, uint64_t a2, BN_CTX *a3)
{
  if (EC_POINT_is_at_infinity(a1, (const EC_POINT *)a2) <= 0)
  {
    size_t v7 = *(unsigned int (**)(const EC_GROUP *, BIGNUM *, BIGNUM *, uint64_t, BN_CTX *))(*(void *)a1 + 264);
    BOOL v8 = *(unsigned int (**)(const EC_GROUP *, BIGNUM *))(*(void *)a1 + 272);
    BN_CTX_start(a3);
    int v9 = BN_CTX_get(a3);
    if (!v9) {
      goto LABEL_28;
    }
    uint64_t v10 = v9;
    int v11 = BN_CTX_get(a3);
    if (!v11) {
      goto LABEL_28;
    }
    int v12 = v11;
    BOOL v13 = BN_CTX_get(a3);
    if (!v13) {
      goto LABEL_28;
    }
    int v14 = v13;
    BOOL v15 = BN_CTX_get(a3);
    if (!v15) {
      goto LABEL_28;
    }
    unsigned __int8 v16 = v15;
    uint64_t v21 = a2 + 8;
    if (!v8(a1, v10)) {
      goto LABEL_28;
    }
    if (*(_DWORD *)(a2 + 80))
    {
      if (!BN_mod_add_quick(v10, v10, (const BIGNUM *)((char *)a1 + 152), (const BIGNUM *)((char *)a1 + 104))
        || !v7(a1, v10, v10, v21, a3))
      {
        goto LABEL_28;
      }
      int v17 = (const BIGNUM *)((char *)a1 + 176);
      unsigned __int8 v18 = v10;
      unsigned __int8 v19 = v10;
    }
    else
    {
      if (!((unsigned int (*)(const EC_GROUP *, BIGNUM *, uint64_t, BN_CTX *))v8)(a1, v12, a2 + 56, a3)
        || !((unsigned int (*)(const EC_GROUP *, const BIGNUM *, BIGNUM *, BN_CTX *))v8)(a1, v14, v12, a3)
        || !v7(a1, v16, (BIGNUM *)v14, (uint64_t)v12, a3))
      {
        goto LABEL_28;
      }
      if (*((_DWORD *)a1 + 50))
      {
        if (!BN_mod_lshift1_quick(v12, v14, (const BIGNUM *)((char *)a1 + 104))
          || !BN_mod_add_quick(v12, v12, v14, (const BIGNUM *)((char *)a1 + 104))
          || !BN_mod_sub_quick(v10, v10, v12, (const BIGNUM *)((char *)a1 + 104)))
        {
          goto LABEL_28;
        }
      }
      else if (!v7(a1, v12, (BIGNUM *)v14, (uint64_t)a1 + 152, a3) {
             || !BN_mod_add_quick(v10, v10, v12, (const BIGNUM *)((char *)a1 + 104)))
      }
      {
        goto LABEL_28;
      }
      if (!v7(a1, v10, v10, v21, a3) || !v7(a1, v12, (BIGNUM *)((char *)a1 + 176), (uint64_t)v16, a3))
      {
LABEL_28:
        uint64_t v6 = 0xFFFFFFFFLL;
        goto LABEL_29;
      }
      unsigned __int8 v18 = v10;
      unsigned __int8 v19 = v10;
      int v17 = v12;
    }
    if (BN_mod_add_quick(v18, v19, v17, (const BIGNUM *)((char *)a1 + 104))
      && ((unsigned int (*)(const EC_GROUP *, BIGNUM *, uint64_t, BN_CTX *))v8)(a1, v12, a2 + 32, a3))
    {
      uint64_t v6 = BN_ucmp(v12, v10) == 0;
LABEL_29:
      BN_CTX_end(a3);
      return v6;
    }
    goto LABEL_28;
  }
  return 1;
}

BOOL ec_GFp_simple_cmp(const EC_GROUP *a1, uint64_t a2, uint64_t a3, BN_CTX *a4)
{
  int v8 = EC_POINT_is_at_infinity(a1, (const EC_POINT *)a2);
  int v9 = EC_POINT_is_at_infinity(a1, (const EC_POINT *)a3);
  if (v8 < 1)
  {
    if (v9 > 0) {
      return 1;
    }
    if (*(_DWORD *)(a2 + 80) && *(_DWORD *)(a3 + 80))
    {
      if (!BN_cmp((const BIGNUM *)(a2 + 8), (const BIGNUM *)(a3 + 8))) {
        return BN_cmp((const BIGNUM *)(a2 + 32), (const BIGNUM *)(a3 + 32)) != 0;
      }
      return 1;
    }
    int v11 = *(uint64_t (**)(const EC_GROUP *, BIGNUM *, uint64_t, BIGNUM *, BN_CTX *))(*(void *)a1 + 264);
    int v12 = *(unsigned int (**)(const EC_GROUP *, BIGNUM *, uint64_t, BN_CTX *))(*(void *)a1 + 272);
    BN_CTX_start(a4);
    BOOL v13 = BN_CTX_get(a4);
    if (!v13) {
      goto LABEL_35;
    }
    int v14 = v13;
    BOOL v15 = BN_CTX_get(a4);
    if (!v15) {
      goto LABEL_35;
    }
    unsigned __int8 v16 = v15;
    int v17 = BN_CTX_get(a4);
    if (!v17) {
      goto LABEL_35;
    }
    unsigned __int8 v18 = v17;
    unsigned __int8 v19 = BN_CTX_get(a4);
    if (!v19) {
      goto LABEL_35;
    }
    uint64_t v20 = v19;
    if (*(_DWORD *)(a3 + 80))
    {
      uint64_t v21 = (const BIGNUM *)(a2 + 8);
    }
    else
    {
      if (!v12(a1, v19, a3 + 56, a4)) {
        goto LABEL_35;
      }
      int v23 = v11(a1, v14, a2 + 8, v20, a4);
      uint64_t v21 = v14;
      if (!v23) {
        goto LABEL_35;
      }
    }
    long long v31 = v21;
    if (*(_DWORD *)(a2 + 80))
    {
      int v22 = (const BIGNUM *)(a3 + 8);
    }
    else
    {
      if (!v12(a1, v18, a2 + 56, a4)) {
        goto LABEL_35;
      }
      int v24 = v11(a1, v16, a3 + 8, v18, a4);
      int v22 = v16;
      uint64_t v21 = v31;
      if (!v24) {
        goto LABEL_35;
      }
    }
    if (BN_cmp(v21, v22))
    {
      uint64_t v10 = 1;
LABEL_36:
      BN_CTX_end(a4);
      return v10;
    }
    if (*(_DWORD *)(a3 + 80))
    {
      int v25 = (const BIGNUM *)(a2 + 32);
    }
    else
    {
      if (!v11(a1, v20, (uint64_t)v20, (BIGNUM *)(a3 + 56), a4)) {
        goto LABEL_35;
      }
      int v27 = v11(a1, v14, a2 + 32, v20, a4);
      int v25 = v31;
      if (!v27) {
        goto LABEL_35;
      }
    }
    if (*(_DWORD *)(a2 + 80))
    {
      uint64_t v26 = (const BIGNUM *)(a3 + 32);
LABEL_29:
      uint64_t v10 = BN_cmp(v25, v26) != 0;
      goto LABEL_36;
    }
    unsigned int v28 = v25;
    if (v11(a1, v18, (uint64_t)v18, (BIGNUM *)(a2 + 56), a4))
    {
      int v29 = v11(a1, v16, a3 + 32, v18, a4);
      int v25 = v28;
      uint64_t v26 = v22;
      if (v29) {
        goto LABEL_29;
      }
    }
LABEL_35:
    uint64_t v10 = 0xFFFFFFFFLL;
    goto LABEL_36;
  }
  return v9 < 1;
}

uint64_t ec_GFp_simple_make_affine(const EC_GROUP *a1, uint64_t a2, BN_CTX *a3)
{
  if (!*(_DWORD *)(a2 + 80) && EC_POINT_is_at_infinity(a1, (const EC_POINT *)a2) <= 0)
  {
    BN_CTX_start(a3);
    int v8 = BN_CTX_get(a3);
    if (v8)
    {
      uint64_t v9 = (uint64_t)v8;
      uint64_t v10 = BN_CTX_get(a3);
      if (v10)
      {
        uint64_t v11 = (uint64_t)v10;
        if (EC_POINT_get_affine_coordinates((uint64_t)a1, (void *)a2, v9, (uint64_t)v10, a3))
        {
          if (EC_POINT_set_affine_coordinates(a1, (const EC_POINT *)a2, v9, v11, a3))
          {
            if (*(_DWORD *)(a2 + 80))
            {
              uint64_t v6 = 1;
LABEL_13:
              BN_CTX_end(a3);
              return v6;
            }
            ERR_put_error(16, 4095, 68, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_smpl.c", 1064);
          }
        }
      }
    }
    uint64_t v6 = 0;
    goto LABEL_13;
  }
  return 1;
}

uint64_t ec_GFp_simple_points_make_affine(uint64_t a1, unint64_t a2, uint64_t *a3, BN_CTX *ctx)
{
  if (!a2) {
    return 1;
  }
  unint64_t v6 = a2;
  BN_CTX_start(ctx);
  int v8 = BN_CTX_get(ctx);
  if (!v8) {
    goto LABEL_27;
  }
  uint64_t v9 = v8;
  uint64_t v10 = BN_CTX_get(ctx);
  if (!v10) {
    goto LABEL_27;
  }
  uint64_t v11 = v10;
  unint64_t v12 = 1;
  do
  {
    unint64_t v13 = v12;
    v12 *= 2;
  }
  while (v13 < v6);
  int v14 = (uint64_t *)reallocarray(0, v12, 8uLL);
  if (!v14)
  {
LABEL_27:
    BN_CTX_end(ctx);
    return 0;
  }
  BOOL v15 = v14;
  int v40 = v9;
  uint64_t *v14 = 0;
  uint64_t v16 = v13 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v17 = (v13 & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if ((v13 & 0x7FFFFFFFFFFFFFFFLL) != 1) {
    bzero(v14 + 1, 8 * v13 - 8);
  }
  uint64_t v18 = v13;
  unsigned __int8 v19 = a3;
  unint64_t v20 = v6;
  do
  {
    uint64_t v21 = *v19++;
    v15[v18++] = v21 + 56;
    --v20;
  }
  while (v20);
  int v41 = v11;
  unint64_t v42 = v16 + v6;
  if (v12 > v16 + v6) {
    bzero(&v15[v42], 8 * (v12 - (v16 + v6)));
  }
  if ((v13 & 0x7FFFFFFFFFFFFFFFLL) != 1)
  {
    int v22 = &v15[2 * v13 - 2];
    for (uint64_t i = (v13 & 0x7FFFFFFFFFFFFFFFLL) - 1; i; --i)
    {
      int v24 = BN_new();
      v15[i] = (uint64_t)v24;
      if (!v24) {
        goto LABEL_58;
      }
      int v25 = (const BIGNUM *)*v22;
      if (*v22)
      {
        if (!v22[1]) {
          goto LABEL_22;
        }
        if (BN_is_zero(v22[1]))
        {
          int v24 = (BIGNUM *)v15[i];
          int v25 = (const BIGNUM *)*v22;
          goto LABEL_22;
        }
        if (BN_is_zero(*v22))
        {
          int v24 = (BIGNUM *)v15[i];
          int v25 = (const BIGNUM *)v22[1];
LABEL_22:
          if (!bn_copy(v24, v25)) {
            goto LABEL_58;
          }
          goto LABEL_23;
        }
        if (!(*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t, BN_CTX *))(*(void *)a1 + 264))(a1, v15[i], *v22, v22[1], ctx))goto LABEL_58; {
      }
        }
LABEL_23:
      v22 -= 2;
    }
  }
  if (BN_is_zero(v15[1])
    || BN_mod_inverse_ct((BIGNUM *)v15[1], (const BIGNUM *)v15[1], (const BIGNUM *)(a1 + 104), ctx))
  {
    int v27 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t, BN_CTX *))(*(void *)a1 + 288);
    unsigned int v28 = v41;
    if (!v27
      || v27(a1, v15[1], v15[1], ctx)
      && (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, BN_CTX *))(*(void *)a1 + 288))(a1, v15[1], v15[1], ctx))
    {
      if (v42 < 3) {
        goto LABEL_45;
      }
      uint64_t v29 = 0;
      do
      {
        uint64_t v30 = &v15[v29];
        uint64_t v31 = v30[3];
        uint64_t v32 = 4 * (v29 + 2);
        if (v31 && !BN_is_zero(v31))
        {
          if (!(*(unsigned int (**)(uint64_t, const BIGNUM *, void, uint64_t, BN_CTX *))(*(void *)a1 + 264))(a1, v40, *(uint64_t *)((char *)v15 + v32), v30[3], ctx))goto LABEL_58; {
          uint64_t v34 = &v15[v29];
          }
          unsigned int v28 = v41;
          if (!(*(unsigned int (**)(uint64_t, const BIGNUM *, uint64_t, uint64_t, BN_CTX *))(*(void *)a1 + 264))(a1, v41, v15[(unint64_t)(v29 + 2) >> 1], v34[2], ctx)|| !bn_copy((BIGNUM *)v34[2], v40)|| !bn_copy((BIGNUM *)v30[3], v41))
          {
            goto LABEL_58;
          }
        }
        else
        {
          BOOL v33 = bn_copy((BIGNUM *)v30[2], *(const BIGNUM **)((char *)v15 + v32));
          unsigned int v28 = v41;
          if (!v33) {
            goto LABEL_58;
          }
        }
        unint64_t v35 = v29 + 4;
        v29 += 2;
      }
      while (v35 < v42);
      do
      {
LABEL_45:
        uint64_t v36 = *a3;
        uint64_t v37 = *a3 + 56;
        if (!BN_is_zero(v37))
        {
          if (!(*(unsigned int (**)(uint64_t, const BIGNUM *, uint64_t, BN_CTX *))(*(void *)a1 + 272))(a1, v28, v37, ctx)|| !(*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const BIGNUM *, BN_CTX *))(*(void *)a1 + 264))(a1, v36 + 8, v36 + 8, v28, ctx)|| !(*(unsigned int (**)(uint64_t, const BIGNUM *, const BIGNUM *, uint64_t, BN_CTX *))(*(void *)a1 + 264))(a1, v28, v28, v37, ctx)|| !(*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const BIGNUM *, BN_CTX *))(*(void *)a1 + 264))(a1, v36 + 32,
                  v36 + 32,
                  v28,
                  ctx))
          {
            goto LABEL_58;
          }
          int v38 = *(unsigned int (**)(uint64_t, uint64_t, BN_CTX *))(*(void *)a1 + 304);
          if (v38)
          {
            if (!v38(a1, v37, ctx)) {
              goto LABEL_58;
            }
          }
          else if (!BN_one(v37))
          {
            goto LABEL_58;
          }
          *(_DWORD *)(v36 + 8RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 1;
        }
        ++a3;
        --v6;
      }
      while (v6);
      uint64_t v26 = 1;
      goto LABEL_59;
    }
  }
  else
  {
    ERR_put_error(16, 4095, 3, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/ec/ecp_smpl.c", 1161);
  }
LABEL_58:
  uint64_t v26 = 0;
LABEL_59:
  BN_CTX_end(ctx);
  for (; v17; --v17)
    BN_free((BIGNUM *)v15[v17]);
  free(v15);
  return v26;
}

uint64_t ec_GFp_simple_field_mul(uint64_t a1, BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *a5)
{
  return BN_mod_mul(r, a, b, (const BIGNUM *)(a1 + 104), a5);
}

uint64_t ec_GFp_simple_field_sqr(uint64_t a1, BIGNUM *r, BIGNUM *a, BN_CTX *a4)
{
  return BN_mod_sqr(r, a, (const BIGNUM *)(a1 + 104), a4);
}

uint64_t ec_GFp_simple_blind_coordinates(uint64_t *a1, uint64_t a2, BN_CTX *ctx)
{
  BN_CTX_start(ctx);
  unint64_t v6 = BN_CTX_get(ctx);
  if (!v6) {
    goto LABEL_13;
  }
  size_t v7 = v6;
  int v8 = BN_CTX_get(ctx);
  if (!v8) {
    goto LABEL_13;
  }
  uint64_t v9 = v8;
  uint64_t v10 = (BIGNUM *)BN_value_one();
  if (!bn_rand_interval(v7, v10, (BIGNUM *)(a1 + 13))) {
    goto LABEL_13;
  }
  uint64_t v11 = *a1;
  unint64_t v12 = *(unsigned int (**)(uint64_t *, BIGNUM *, BIGNUM *, BN_CTX *))(*a1 + 288);
  if (v12)
  {
    if (!v12(a1, v7, v7, ctx))
    {
LABEL_13:
      uint64_t v13 = 0;
      goto LABEL_14;
    }
    uint64_t v11 = *a1;
  }
  if (!(*(unsigned int (**)(uint64_t *, uint64_t, BIGNUM *, uint64_t, BN_CTX *))(v11 + 264))(a1, a2 + 56, v7, a2 + 56, ctx)|| !(*(unsigned int (**)(uint64_t *, BIGNUM *, BIGNUM *, BN_CTX *))(*a1 + 272))(a1, v9, v7, ctx)|| !(*(unsigned int (**)(uint64_t *, uint64_t, BIGNUM *, uint64_t, BN_CTX *))(*a1 + 264))(a1, a2 + 8, v9, a2 + 8, ctx)|| !(*(unsigned int (**)(uint64_t *, BIGNUM *, BIGNUM *, BIGNUM *, BN_CTX *))(*a1 + 264))(a1, v9, v9, v7, ctx)|| !(*(unsigned int (**)(uint64_t *, uint64_t, BIGNUM *, uint64_t, BN_CTX *))(*a1 + 264))(
          a1,
          a2 + 32,
          v9,
          a2 + 32,
          ctx))
  {
    goto LABEL_13;
  }
  *(_DWORD *)(a2 + 8RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0;
  uint64_t v13 = 1;
LABEL_14:
  BN_CTX_end(ctx);
  return v13;
}

BIGNUM *ec_GFp_simple_mul_generator_ct(uint64_t a1, uint64_t a2, const BIGNUM *a3, BN_CTX *ctx)
{
  return ec_GFp_simple_mul_ct(a1, a2, a3, 0, ctx);
}

BIGNUM *ec_GFp_simple_mul_ct(uint64_t a1, uint64_t a2, const BIGNUM *a3, uint64_t a4, BN_CTX *ctx)
{
  BN_CTX_start(ctx);
  uint64_t v10 = EC_POINT_new((const EC_GROUP *)a1);
  uint64_t v11 = v10;
  if (!v10) {
    goto LABEL_40;
  }
  unint64_t v12 = a4 ? (const EC_POINT *)a4 : *(const EC_POINT **)(a1 + 8);
  if (!EC_POINT_copy(v10, v12)) {
    goto LABEL_40;
  }
  BN_set_flags((uint64_t)v11 + 8, 4);
  BN_set_flags((uint64_t)v11 + 32, 4);
  BN_set_flags((uint64_t)v11 + 56, 4);
  uint64_t v13 = BN_CTX_get(ctx);
  if (v13)
  {
    int v14 = BN_CTX_get(ctx);
    if (v14)
    {
      BOOL v15 = v14;
      X509_SIG a = BN_CTX_get(ctx);
      if (a)
      {
        if (BN_mul(v13, (const BIGNUM *)(a1 + 16), (const BIGNUM *)(a1 + 40), ctx))
        {
          uint64_t v33 = (uint64_t)v11 + 32;
          int n = BN_num_bits(v13);
          size_t v16 = v13->top + 2;
          if (bn_wexpand((uint64_t)a, v16))
          {
            if (bn_wexpand((uint64_t)v15, v16))
            {
              uint64_t v31 = (uint64_t)v11 + 56;
              if (bn_copy(a, a3))
              {
                if ((BN_set_flags((uint64_t)a, 4), BN_num_bits(a) <= n) && !BN_is_negative((uint64_t)a)
                  || BN_nnmod(a, a, v13, ctx))
                {
                  if (BN_add(v15, a, v13))
                  {
                    BN_set_flags((uint64_t)v15, 4);
                    if (BN_add(a, v15, v13))
                    {
                      int is_bit_set = BN_is_bit_set(v15, n);
                      if (BN_swap_ct(is_bit_set, (uint64_t)a, (uint64_t)v15, v16))
                      {
                        unsigned int v18 = *(_DWORD *)(a1 + 112);
                        if (bn_wexpand((uint64_t)v11 + 8, v18))
                        {
                          size_t v19 = (int)v18;
                          if (bn_wexpand(v33, (int)v18))
                          {
                            if (bn_wexpand(v31, (int)v18))
                            {
                              if (bn_wexpand(a2 + 8, (int)v18))
                              {
                                if (bn_wexpand(a2 + 32, (int)v18))
                                {
                                  if (bn_wexpand(a2 + 56, (int)v18))
                                  {
                                    if (ec_point_blind_coordinates(a1))
                                    {
                                      if (EC_POINT_copy((EC_POINT *)a2, v11))
                                      {
                                        uint64_t v30 = a2 + 8;
                                        BN_set_flags(a2 + 8, 4);
                                        uint64_t v29 = a2 + 32;
                                        BN_set_flags(a2 + 32, 4);
                                        uint64_t v28 = a2 + 56;
                                        BN_set_flags(a2 + 56, 4);
                                        if (EC_POINT_dbl((const EC_GROUP *)a1, v11, v11, ctx))
                                        {
                                          int count = 0;
                                          while (1)
                                          {
                                            int v20 = n - 1;
                                            if (n < 1) {
                                              break;
                                            }
                                            --n;
                                            int v21 = BN_is_bit_set(a, v20);
                                            uint64_t v22 = v21 ^ count;
                                            if (!BN_swap_ct(v22, v30, (uint64_t)v11 + 8, v19)) {
                                              goto LABEL_40;
                                            }
                                            if (!BN_swap_ct(v22, v29, v33, v19)) {
                                              goto LABEL_40;
                                            }
                                            if (!BN_swap_ct(v22, v28, v31, v19)) {
                                              goto LABEL_40;
                                            }
                                            int v23 = *(_DWORD *)(a2 + 80);
                                            int v24 = (*((_DWORD *)v11 + 20) ^ v23) & v22;
                                            *(_DWORD *)(a2 + 8RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = v24 ^ v23;
                                            *((_DWORD *)v11 + 20) ^= v24;
                                            if (!EC_POINT_add((const EC_GROUP *)a1, v11, (const EC_POINT *)a2, v11, ctx))goto LABEL_40; {
                                            uint64_t v13 = 0;
                                            }
                                            int count = v21;
                                            if (!EC_POINT_dbl((const EC_GROUP *)a1, (EC_POINT *)a2, (const EC_POINT *)a2, ctx))goto LABEL_41; {
                                          }
                                            }
                                          if (BN_swap_ct(count, v30, (uint64_t)v11 + 8, v19)
                                            && BN_swap_ct(count, v29, v33, v19)
                                            && BN_swap_ct(count, v28, v31, v19))
                                          {
                                            int v25 = *(_DWORD *)(a2 + 80);
                                            int v26 = (*((_DWORD *)v11 + 20) ^ v25) & count;
                                            *(_DWORD *)(a2 + 8RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = v26 ^ v25;
                                            *((_DWORD *)v11 + 20) ^= v26;
                                            uint64_t v13 = (BIGNUM *)1;
                                            goto LABEL_41;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_40:
    uint64_t v13 = 0;
  }
LABEL_41:
  EC_POINT_free(v11);
  BN_CTX_end(ctx);
  return v13;
}

uint64_t ec_GFp_simple_mul_double_nonct(EC_GROUP *a1, EC_POINT *a2, const BIGNUM *a3, uint64_t a4, void *a5, BN_CTX *a6)
{
  size_t v7 = a5;
  uint64_t v8 = a4;
  return ec_wNAF_mul(a1, a2, a3, 1uLL, &v7, (uint64_t)&v8, a6);
}

const EC_METHOD *EC_GFp_simple_method(void)
{
  return (const EC_METHOD *)&ec_GFp_simple_method;
}

X509_PUBKEY *__cdecl d2i_X509_PUBKEY(X509_PUBKEY **a, const unsigned __int8 **in, uint64_t len)
{
  return (X509_PUBKEY *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &X509_PUBKEY_it);
}

int i2d_X509_PUBKEY(X509_PUBKEY *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &X509_PUBKEY_it);
}

X509_PUBKEY *X509_PUBKEY_new(void)
{
  return (X509_PUBKEY *)ASN1_item_new(&X509_PUBKEY_it);
}

void X509_PUBKEY_free(X509_PUBKEY *a)
{
}

int X509_PUBKEY_set(X509_PUBKEY **x, EVP_PKEY *pkey)
{
  if (!x) {
    return (int)x;
  }
  int v3 = (ASN1_VALUE **)x;
  x = (X509_PUBKEY **)ASN1_item_new(&X509_PUBKEY_it);
  if (!x) {
    return (int)x;
  }
  int v4 = x;
  int ptr = pkey->pkey.ptr;
  if (!ptr)
  {
    int v7 = 111;
    int v8 = 161;
LABEL_12:
    ERR_put_error(11, 4095, v7, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/x_pubkey.c", v8);
    ASN1_item_free((ASN1_VALUE *)v4, &X509_PUBKEY_it);
    LODWORD(x) = 0;
    return (int)x;
  }
  unint64_t v6 = (unsigned int (*)(X509_PUBKEY **, EVP_PKEY *))*((void *)ptr + 5);
  if (!v6)
  {
    int v7 = 124;
    int v8 = 157;
    goto LABEL_12;
  }
  if (!v6(x, pkey))
  {
    int v7 = 126;
    int v8 = 153;
    goto LABEL_12;
  }
  if (*v3) {
    ASN1_item_free(*v3, &X509_PUBKEY_it);
  }
  const BIGNUM *v3 = (ASN1_VALUE *)v4;
  LODWORD(x) = 1;
  return (int)x;
}

EVP_PKEY *X509_PUBKEY_get0(uint64_t a1)
{
  if (!a1) {
    goto LABEL_10;
  }
  BOOL v2 = *(EVP_PKEY **)(a1 + 16);
  if (v2) {
    return v2;
  }
  if (!*(void *)(a1 + 8))
  {
LABEL_10:
    BOOL v2 = 0;
LABEL_16:
    EVP_PKEY_free(v2);
    return 0;
  }
  BOOL v2 = EVP_PKEY_new();
  if (!v2)
  {
    int v5 = 65;
    int v6 = 193;
LABEL_15:
    ERR_put_error(11, 4095, v5, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/asn1/x_pubkey.c", v6);
    goto LABEL_16;
  }
  int v3 = OBJ_obj2nid(**(const ASN1_OBJECT ***)a1);
  if (!EVP_PKEY_set_type((uint64_t)v2, v3))
  {
    int v5 = 111;
    int v6 = 198;
    goto LABEL_15;
  }
  int v4 = (unsigned int (*)(EVP_PKEY *, uint64_t))*((void *)v2->pkey.ptr + 4);
  if (!v4)
  {
    int v5 = 124;
    int v6 = 208;
    goto LABEL_15;
  }
  if (!v4(v2, a1))
  {
    int v5 = 125;
    int v6 = 204;
    goto LABEL_15;
  }
  CRYPTO_lock(9, 10, 0, 0);
  if (*(void *)(a1 + 16))
  {
    CRYPTO_lock(10, 10, 0, 0);
    EVP_PKEY_free(v2);
    return *(EVP_PKEY **)(a1 + 16);
  }
  else
  {
    *(void *)(a1 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = v2;
    CRYPTO_lock(10, 10, 0, 0);
  }
  return v2;
}

EVP_PKEY *__cdecl X509_PUBKEY_get(X509_PUBKEY *key)
{
  int v1 = X509_PUBKEY_get0((uint64_t)key);
  BOOL v2 = v1;
  if (v1) {
    CRYPTO_add_lock(&v1->references, 1, 10, 0, 0);
  }
  return v2;
}

BOOL pkey_pubkey_ex_new(EVP_PKEY **a1)
{
  BOOL v2 = EVP_PKEY_new();
  *a1 = v2;
  return v2 != 0;
}

void pkey_pubkey_ex_free(EVP_PKEY **a1)
{
  *a1 = 0;
}

uint64_t pkey_pubkey_ex_d2i(EVP_PKEY **a1, unsigned __int8 **a2, uint64_t len, uint64_t a4)
{
  return pubkey_ex_d2i(0, a1, a2, len, a4);
}

uint64_t pkey_pubkey_ex_i2d(dsa_st **a1, unsigned __int8 **a2)
{
  return pubkey_ex_i2d(0, a1, a2);
}

EVP_PKEY *__cdecl d2i_PUBKEY(EVP_PKEY **a, const unsigned __int8 **pp, uint64_t length)
{
  return (EVP_PKEY *)ASN1_item_d2i((ASN1_VALUE **)a, pp, length, &EVP_PKEY_PUBKEY_it);
}

int i2d_PUBKEY(EVP_PKEY *a, unsigned __int8 **pp)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, pp, &EVP_PKEY_PUBKEY_it);
}

EVP_PKEY *__cdecl d2i_PUBKEY_bio(BIO *bp, EVP_PKEY **a)
{
  return (EVP_PKEY *)ASN1_item_d2i_bio(&EVP_PKEY_PUBKEY_it, bp, a);
}

int i2d_PUBKEY_bio(BIO *bp, EVP_PKEY *pkey)
{
  return ASN1_item_i2d_bio(&EVP_PKEY_PUBKEY_it, bp, pkey);
}

EVP_PKEY *__cdecl d2i_PUBKEY_fp(FILE *fp, EVP_PKEY **a)
{
  return (EVP_PKEY *)ASN1_item_d2i_fp(&EVP_PKEY_PUBKEY_it, fp, a);
}

int i2d_PUBKEY_fp(FILE *fp, EVP_PKEY *pkey)
{
  return ASN1_item_i2d_fp(&EVP_PKEY_PUBKEY_it, fp, pkey);
}

BOOL rsa_pubkey_ex_new(RSA **a1)
{
  BOOL v2 = RSA_new();
  *a1 = v2;
  return v2 != 0;
}

void rsa_pubkey_ex_free(RSA **a1)
{
  *a1 = 0;
}

uint64_t rsa_pubkey_ex_d2i(EVP_PKEY **a1, unsigned __int8 **a2, uint64_t len, uint64_t a4)
{
  return pubkey_ex_d2i(6, a1, a2, len, a4);
}

uint64_t rsa_pubkey_ex_i2d(dsa_st **a1, unsigned __int8 **a2)
{
  return pubkey_ex_i2d(6, a1, a2);
}

RSA *__cdecl d2i_RSA_PUBKEY(RSA **a, const unsigned __int8 **pp, uint64_t length)
{
  return (RSA *)ASN1_item_d2i((ASN1_VALUE **)a, pp, length, &RSA_PUBKEY_it);
}

int i2d_RSA_PUBKEY(RSA *a, unsigned __int8 **pp)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, pp, &RSA_PUBKEY_it);
}

RSA *__cdecl d2i_RSA_PUBKEY_bio(BIO *bp, RSA **rsa)
{
  return (RSA *)ASN1_item_d2i_bio(&RSA_PUBKEY_it, bp, rsa);
}

int i2d_RSA_PUBKEY_bio(BIO *bp, RSA *rsa)
{
  return ASN1_item_i2d_bio(&RSA_PUBKEY_it, bp, rsa);
}

RSA *__cdecl d2i_RSA_PUBKEY_fp(FILE *fp, RSA **rsa)
{
  return (RSA *)ASN1_item_d2i_fp(&RSA_PUBKEY_it, fp, rsa);
}

int i2d_RSA_PUBKEY_fp(FILE *fp, RSA *rsa)
{
  return ASN1_item_i2d_fp(&RSA_PUBKEY_it, fp, rsa);
}

BOOL dsa_pubkey_ex_new(DSA **a1)
{
  BOOL v2 = DSA_new();
  *a1 = v2;
  return v2 != 0;
}

void dsa_pubkey_ex_free(DSA **a1)
{
  *a1 = 0;
}

uint64_t dsa_pubkey_ex_d2i(EVP_PKEY **a1, unsigned __int8 **a2, uint64_t len, uint64_t a4)
{
  return pubkey_ex_d2i(116, a1, a2, len, a4);
}

uint64_t dsa_pubkey_ex_i2d(dsa_st **a1, unsigned __int8 **a2)
{
  return pubkey_ex_i2d(116, a1, a2);
}

DSA *__cdecl d2i_DSA_PUBKEY(DSA **a, const unsigned __int8 **pp, uint64_t length)
{
  return (DSA *)ASN1_item_d2i((ASN1_VALUE **)a, pp, length, &DSA_PUBKEY_it);
}

int i2d_DSA_PUBKEY(DSA *a, unsigned __int8 **pp)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, pp, &DSA_PUBKEY_it);
}

DSA *__cdecl d2i_DSA_PUBKEY_bio(BIO *bp, DSA **dsa)
{
  return (DSA *)ASN1_item_d2i_bio(&DSA_PUBKEY_it, bp, dsa);
}

int i2d_DSA_PUBKEY_bio(BIO *bp, DSA *dsa)
{
  return ASN1_item_i2d_bio(&DSA_PUBKEY_it, bp, dsa);
}

DSA *__cdecl d2i_DSA_PUBKEY_fp(FILE *fp, DSA **dsa)
{
  return (DSA *)ASN1_item_d2i_fp(&DSA_PUBKEY_it, fp, dsa);
}

int i2d_DSA_PUBKEY_fp(FILE *fp, DSA *dsa)
{
  return ASN1_item_i2d_fp(&DSA_PUBKEY_it, fp, dsa);
}

BOOL ec_pubkey_ex_new(EC_KEY **a1)
{
  BOOL v2 = EC_KEY_new();
  *a1 = v2;
  return v2 != 0;
}

void ec_pubkey_ex_free(EC_KEY **a1)
{
  *a1 = 0;
}

uint64_t ec_pubkey_ex_d2i(EVP_PKEY **a1, unsigned __int8 **a2, uint64_t len, uint64_t a4)
{
  return pubkey_ex_d2i(408, a1, a2, len, a4);
}

uint64_t ec_pubkey_ex_i2d(dsa_st **a1, unsigned __int8 **a2)
{
  return pubkey_ex_i2d(408, a1, a2);
}

EC_KEY *__cdecl d2i_EC_PUBKEY(EC_KEY **a, const unsigned __int8 **pp, uint64_t length)
{
  return ASN1_item_d2i(a, pp, length, &EC_PUBKEY_it);
}

int i2d_EC_PUBKEY(EC_KEY *a, unsigned __int8 **pp)
{
  return ASN1_item_i2d(a, pp, &EC_PUBKEY_it);
}

EC_KEY *__cdecl d2i_EC_PUBKEY_bio(BIO *bp, EC_KEY **eckey)
{
  return (EC_KEY *)ASN1_item_d2i_bio(&EC_PUBKEY_it, bp, eckey);
}

int i2d_EC_PUBKEY_bio(BIO *bp, EC_KEY *eckey)
{
  return ASN1_item_i2d_bio(&EC_PUBKEY_it, bp, eckey);
}

EC_KEY *__cdecl d2i_EC_PUBKEY_fp(FILE *fp, EC_KEY **eckey)
{
  return (EC_KEY *)ASN1_item_d2i_fp(&EC_PUBKEY_it, fp, eckey);
}

int i2d_EC_PUBKEY_fp(FILE *fp, EC_KEY *eckey)
{
  return ASN1_item_i2d_fp(&EC_PUBKEY_it, fp, eckey);
}

uint64_t X509_PUBKEY_set0_param(uint64_t a1, ASN1_OBJECT *a2, int a3, void *a4, void *a5, int a6)
{
  uint64_t result = X509_ALGOR_set0(*(X509_ALGOR **)a1, a2, a3, a4);
  if (result)
  {
    if (a5)
    {
      ASN1_STRING_set0(*(ASN1_STRING **)(a1 + 8), a5, a6);
      uint64_t v10 = *(void *)(a1 + 8);
      return asn1_abs_set_unused_bits(v10, 0);
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t X509_PUBKEY_get0_param(void *a1, void *a2, _DWORD *a3, void *a4, uint64_t a5)
{
  if (a1) {
    *a1 = **(void **)a5;
  }
  if (a2)
  {
    *a2 = *(void *)(*(void *)(a5 + 8) + 8);
    *a3 = **(_DWORD **)(a5 + 8);
  }
  if (a4) {
    *a4 = *(void *)a5;
  }
  return 1;
}

uint64_t pubkey_cb(int a1, uint64_t a2)
{
  if (a1 == 3) {
    EVP_PKEY_free(*(EVP_PKEY **)(*(void *)a2 + 16));
  }
  return 1;
}

uint64_t pubkey_ex_d2i(int a1, EVP_PKEY **a2, unsigned __int8 **a3, uint64_t len, uint64_t a5)
{
  uint64_t v9 = *(void *)(a5 + 32);
  unsigned __int8 in = *a3;
  uint64_t v10 = ASN1_item_d2i(0, (const unsigned __int8 **)&in, len, &X509_PUBKEY_it);
  uint64_t v11 = v10;
  if (!v10)
  {
    uint64_t v13 = 0;
    goto LABEL_16;
  }
  unint64_t v12 = X509_PUBKEY_get((X509_PUBKEY *)v10);
  uint64_t v13 = v12;
  if (!v12)
  {
LABEL_16:
    uint64_t v14 = 0;
    goto LABEL_17;
  }
  uint64_t v14 = 0;
  if (a1 > 115)
  {
    if (a1 == 408)
    {
      BOOL v15 = (EVP_PKEY *)EVP_PKEY_get1_EC_KEY(v12);
      if (v15) {
        goto LABEL_12;
      }
    }
    else
    {
      if (a1 != 116) {
        goto LABEL_17;
      }
      BOOL v15 = (EVP_PKEY *)EVP_PKEY_get1_DSA(v12);
      if (v15)
      {
LABEL_12:
        size_t v16 = v13;
        uint64_t v13 = v15;
LABEL_14:
        (*(void (**)(EVP_PKEY **, uint64_t))(v9 + 16))(a2, a5);
        *a2 = v13;
        *a3 = in;
        uint64_t v14 = 1;
        uint64_t v13 = v16;
        goto LABEL_17;
      }
    }
    goto LABEL_16;
  }
  if (!a1)
  {
    size_t v16 = 0;
    goto LABEL_14;
  }
  if (a1 == 6)
  {
    BOOL v15 = (EVP_PKEY *)EVP_PKEY_get1_RSA(v12);
    if (!v15) {
      goto LABEL_16;
    }
    goto LABEL_12;
  }
LABEL_17:
  EVP_PKEY_free(v13);
  ASN1_item_free(v11, &X509_PUBKEY_it);
  return v14;
}

uint64_t pubkey_ex_i2d(int a1, dsa_st **a2, unsigned __int8 **a3)
{
  x = 0;
  int v6 = EVP_PKEY_new();
  int v7 = v6;
  uint64_t v8 = 0xFFFFFFFFLL;
  if (!v6) {
    goto LABEL_14;
  }
  if (a1 > 115)
  {
    if (a1 == 116)
    {
      int v9 = EVP_PKEY_set1_DSA(v6, *a2);
    }
    else
    {
      if (a1 != 408) {
        goto LABEL_14;
      }
      int v9 = EVP_PKEY_set1_EC_KEY(v6, (ec_key_st *)*a2);
    }
LABEL_11:
    uint64_t v10 = (dsa_st *)v7;
    if (!v9) {
      goto LABEL_14;
    }
    goto LABEL_12;
  }
  if (a1)
  {
    if (a1 != 6) {
      goto LABEL_14;
    }
    int v9 = EVP_PKEY_set1_RSA(v6, (rsa_st *)*a2);
    goto LABEL_11;
  }
  uint64_t v10 = *a2;
LABEL_12:
  if (X509_PUBKEY_set(&x, (EVP_PKEY *)v10)) {
    uint64_t v8 = ASN1_item_i2d((ASN1_VALUE *)x, a3, &X509_PUBKEY_it);
  }
LABEL_14:
  EVP_PKEY_free(v7);
  ASN1_item_free((ASN1_VALUE *)x, &X509_PUBKEY_it);
  return v8;
}

uint64_t STREEBOG512_Final(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  memset(v11, 0, sizeof(v11));
  int v4 = *(_DWORD *)(a2 + 64);
  if (v4 == 64)
  {
    streebog_single_block((void *)a2, (_OWORD *)a2, 0x200uLL);
    int v4 = *(_DWORD *)(a2 + 64) - 64;
    *(_DWORD *)(a2 + 64) = v4;
  }
  int v5 = (unsigned char *)(a2 + v4);
  unsigned char *v5 = 1;
  bzero(v5 + 1, 63 - v4);
  streebog_single_block((void *)a2, (_OWORD *)a2, (8 * *(_DWORD *)(a2 + 64)));
  gN((void *)(a2 + 72), (void *)(a2 + 136), v11);
  gN((void *)(a2 + 72), (void *)(a2 + 200), v11);
  for (uint64_t i = 0; i != 64; i += 8)
    *(void *)(a2 + i + 72) = bswap64(*(void *)(a2 + i + 72));
  if (!a1) {
    return 0;
  }
  int v7 = *(_DWORD *)(a2 + 68);
  if (v7 == 32)
  {
    for (uint64_t j = 0; j != 32; j += 8)
      *(void *)(a1 + j) = bswap64(*(void *)(a2 + 104 + j));
    return 1;
  }
  if (v7 != 64) {
    return 0;
  }
  for (uint64_t k = 0; k != 64; k += 8)
    *(void *)(a1 + k) = bswap64(*(void *)(a2 + 72 + k));
  return 1;
}

uint64_t *streebog_single_block(void *a1, _OWORD *a2, unint64_t a3)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  long long v5 = a2[1];
  v21[0] = *a2;
  v21[1] = v5;
  long long v6 = a2[3];
  v21[2] = a2[2];
  uint64_t v21[3] = v6;
  uint64_t result = gN(a1 + 9, v21, a1 + 17);
  uint64_t v8 = a1[17];
  BOOL v9 = __CFADD__(v8, a3);
  unint64_t v10 = v8 + a3;
  a1[17] = v10;
  if (v9 || v10 < a3)
  {
    uint64_t v11 = 0;
    uint64_t v12 = a1 + 18;
    do
    {
      uint64_t v13 = v12[v11] + 1;
      v12[v11] = v13;
      if (v13) {
        break;
      }
      BOOL v14 = v11++ == 6;
    }
    while (!v14);
  }
  uint64_t v15 = 0;
  BOOL v16 = 0;
  unint64_t v17 = *(void *)&v21[0];
  unint64_t v18 = a1[25] + *(void *)&v21[0];
  a1[25] = v18;
  size_t v19 = a1 + 26;
  do
  {
    BOOL v14 = v18 == v17;
    BOOL v20 = v18 < v17;
    if (!v14) {
      BOOL v16 = v20;
    }
    unint64_t v17 = *(void *)((char *)v21 + v15 * 8 + 8);
    unint64_t v18 = v19[v15] + v16 + v17;
    v19[v15++] = v18;
  }
  while (v15 != 7);
  return result;
}

uint64_t *gN(void *a1, void *a2, void *a3)
{
  v20[8] = *MEMORY[0x263EF8340];
  transform(v20, a1, a3);
  transform(v19, v20, a2);
  transform(v20, v20, C16);
  uint64_t v5 = 8u;
  do
  {
    transform(v19, v20, v19);
    uint64_t result = transform(v20, v20, &C16[v5]);
    v5 += 8;
  }
  while (v5 != 96);
  uint64_t v7 = v19[1];
  uint64_t v8 = v20[1];
  uint64_t v9 = a1[1];
  *a1 ^= v20[0] ^ v19[0] ^ *a2;
  a1[1] = v8 ^ v7 ^ a2[1] ^ v9;
  uint64_t v10 = v19[3];
  uint64_t v11 = v20[3];
  uint64_t v12 = a1[3];
  a1[2] ^= v20[2] ^ v19[2] ^ a2[2];
  a1[3] = v11 ^ v10 ^ a2[3] ^ v12;
  uint64_t v13 = v19[5];
  uint64_t v14 = v20[5];
  uint64_t v15 = a1[5];
  a1[4] ^= v20[4] ^ v19[4] ^ a2[4];
  a1[5] = v14 ^ v13 ^ a2[5] ^ v15;
  uint64_t v16 = v19[7];
  uint64_t v17 = v20[7];
  uint64_t v18 = a1[7];
  a1[6] ^= v20[6] ^ v19[6] ^ a2[6];
  a1[7] = v17 ^ v16 ^ a2[7] ^ v18;
  return result;
}

uint64_t STREEBOG512_Update(_DWORD *__dst, char *__src, size_t __n)
{
  if (__n)
  {
    size_t v3 = __n;
    int v4 = __src;
    uint64_t v6 = __dst[16];
    if (v6)
    {
      size_t v7 = (64 - v6);
      uint64_t v8 = (char *)__dst + v6;
      if (__n < v7)
      {
        memcpy(v8, __src, __n);
        LODWORD(v3) = __dst[16] + v3;
LABEL_12:
        char __dst[16] = v3;
        return 1;
      }
      memcpy(v8, __src, (64 - v6));
      char __dst[16] = 0;
      v4 += v7;
      streebog_single_block(__dst, __dst, 0x200uLL);
      v3 -= v7;
    }
    if (v3 >= 0x40)
    {
      size_t v9 = v3 >> 6;
      uint64_t v10 = v4;
      do
      {
        streebog_single_block(__dst, v10, 0x200uLL);
        v10 += 64;
        --v9;
      }
      while (v9);
      uint64_t v11 = &v4[v3];
      v3 &= 0x3Fu;
      int v4 = &v11[-v3];
    }
    if (v3)
    {
      memcpy(__dst, v4, v3);
      goto LABEL_12;
    }
  }
  return 1;
}

uint64_t STREEBOG256_Update(_DWORD *a1, char *a2, size_t a3)
{
  return 1;
}

uint64_t *STREEBOG512_Transform(void *a1, _OWORD *a2)
{
  return streebog_single_block(a1, a2, 0x200uLL);
}

uint64_t STREEBOG256_Init(uint64_t a1)
{
  *(void *)(a1 + 256) = 0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 24RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 16RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = 0u;
  *(void *)&long long v1 = 0x101010101010101;
  *((void *)&v1 + md4_block_data_order((unint64_t)c, b, 1) = 0x101010101010101;
  *(_OWORD *)(a1 + 12RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = v1;
  *(_OWORD *)(a1 + 104) = v1;
  *(_OWORD *)(a1 + 88) = v1;
  *(_OWORD *)(a1 + 72) = v1;
  *(_DWORD *)(a1 + 68) = 32;
  return 1;
}

uint64_t STREEBOG512_Init(uint64_t a1)
{
  *(void *)(a1 + 256) = 0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 24RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 16RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 8RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(result + 8) + 16) = 0u;
  *(_OWORD *)(a1 + 12RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 64) = 0x4000000000;
  return 1;
}

void STREEBOG256(char *__src, size_t __n, void *a3)
{
  uint64_t v19 = 0;
  long long v17 = 0u;
  long long v18 = 0u;
  if (a3) {
    size_t v3 = a3;
  }
  else {
    size_t v3 = &STREEBOG256_m;
  }
  long long v15 = 0uLL;
  long long v16 = 0uLL;
  long long v13 = 0uLL;
  long long v14 = 0uLL;
  uint64_t v11 = 0;
  long long v12 = 0uLL;
  uint64_t v6 = 0x2000000000;
  memset(v5, 0, sizeof(v5));
  *(void *)&long long v4 = 0x101010101010101;
  *((void *)&v4 + md4_block_data_order((unint64_t)c, b, 1) = 0x101010101010101;
  long long v10 = v4;
  long long v9 = v4;
  long long v8 = v4;
  long long v7 = v4;
  STREEBOG512_Update(v5, __src, __n);
  STREEBOG512_Final((uint64_t)v3, (uint64_t)v5);
  explicit_bzero(v5, 0x108uLL);
}

void STREEBOG512(char *a1, size_t a2, void *a3)
{
  uint64_t v7 = 0;
  memset(&v6[2], 0, 224);
  if (a3) {
    uint64_t v5 = a3;
  }
  else {
    uint64_t v5 = &STREEBOG512_m;
  }
  memset(v6, 0, 32);
  STREEBOG512_Init((uint64_t)v6);
  STREEBOG512_Update(v6, a1, a2);
  STREEBOG512_Final((uint64_t)v5, (uint64_t)v6);
  explicit_bzero(v6, 0x108uLL);
}

uint64_t *transform(uint64_t *result, void *a2, void *a3)
{
  unint64_t v3 = *a3 ^ *a2;
  unint64_t v4 = a3[1] ^ a2[1];
  unint64_t v5 = a3[2] ^ a2[2];
  unint64_t v6 = a3[3] ^ a2[3];
  unint64_t v7 = a3[4] ^ a2[4];
  unint64_t v8 = a3[5] ^ a2[5];
  unint64_t v9 = a3[6] ^ a2[6];
  unint64_t v10 = a3[7] ^ a2[7];
  uint64_t v11 = A_PI_table[(*((unsigned char *)a3 + 8) ^ *((unsigned char *)a2 + 8)) + 256] ^ A_PI_table[(*(unsigned char *)a3 ^ *(unsigned char *)a2)];
  uint64_t v12 = A_PI_table[(*((unsigned char *)a3 + 16) ^ *((unsigned char *)a2 + 16)) + 512];
  long long v13 = (char *)&A_PI_table[768];
  uint64_t v14 = v12 ^ *(void *)&v13[8 * v6];
  long long v15 = (char *)&A_PI_table[1280];
  uint64_t v16 = v11 ^ v14;
  long long v17 = (char *)&A_PI_table[1792];
  *uint64_t result = v16 ^ qword_23C7186D8[v7] ^ *(void *)&v15[8 * v8] ^ qword_23C7196D8[v9] ^ *(void *)&v17[8 * v10];
  result[1] = A_PI_table[BYTE1(v4) + 256] ^ A_PI_table[BYTE1(v3)] ^ A_PI_table[BYTE1(v5) + 512] ^ *(void *)&v13[8 * BYTE1(v6)] ^ qword_23C7186D8[BYTE1(v7)] ^ *(void *)&v15[8 * BYTE1(v8)] ^ qword_23C7196D8[BYTE1(v9)] ^ *(void *)&v17[8 * BYTE1(v10)];
  result[2] = A_PI_table[BYTE2(v4) + 256] ^ A_PI_table[BYTE2(v3)] ^ A_PI_table[BYTE2(v5) + 512] ^ *(void *)&v13[8 * BYTE2(v6)] ^ qword_23C7186D8[BYTE2(v7)] ^ *(void *)&v15[8 * BYTE2(v8)] ^ qword_23C7196D8[BYTE2(v9)] ^ *(void *)&v17[8 * BYTE2(v10)];
  result[3] = A_PI_table[BYTE3(v4) + 256] ^ A_PI_table[BYTE3(v3)] ^ A_PI_table[BYTE3(v5) + 512] ^ *(void *)&v13[8 * BYTE3(v6)] ^ qword_23C7186D8[BYTE3(v7)] ^ *(void *)&v15[8 * BYTE3(v8)] ^ qword_23C7196D8[BYTE3(v9)] ^ *(void *)&v17[8 * BYTE3(v10)];
  result[4] = A_PI_table[BYTE4(v4) + 256] ^ A_PI_table[BYTE4(v3)] ^ A_PI_table[BYTE4(v5) + 512] ^ *(void *)&v13[8 * BYTE4(v6)] ^ qword_23C7186D8[BYTE4(v7)] ^ *(void *)&v15[8 * BYTE4(v8)] ^ qword_23C7196D8[BYTE4(v9)] ^ *(void *)&v17[8 * BYTE4(v10)];
  result[5] = A_PI_table[BYTE5(v4) + 256] ^ A_PI_table[BYTE5(v3)] ^ A_PI_table[BYTE5(v5) + 512] ^ *(void *)&v13[8 * BYTE5(v6)] ^ qword_23C7186D8[BYTE5(v7)] ^ *(void *)&v15[8 * BYTE5(v8)] ^ qword_23C7196D8[BYTE5(v9)] ^ *(void *)&v17[8 * BYTE5(v10)];
  result[6] = A_PI_table[BYTE6(v4) + 256] ^ A_PI_table[BYTE6(v3)] ^ A_PI_table[BYTE6(v5) + 512] ^ *(void *)&v13[8 * BYTE6(v6)] ^ qword_23C7186D8[BYTE6(v7)] ^ *(void *)&v15[8 * BYTE6(v8)] ^ qword_23C7196D8[BYTE6(v9)] ^ *(void *)&v17[8 * BYTE6(v10)];
  result[7] = *(void *)((char *)&A_PI_table[256] + ((v4 >> 53) & 0x7F8)) ^ *(void *)((char *)A_PI_table
                                                                                       + ((v3 >> 53) & 0x7F8)) ^ *(void *)((char *)&A_PI_table[512] + ((v5 >> 53) & 0x7F8)) ^ *(void *)&v13[(v6 >> 53) & 0x7F8] ^ *(void *)((char *)qword_23C7186D8 + ((v7 >> 53) & 0x7F8)) ^ *(void *)&v15[(v8 >> 53) & 0x7F8] ^ *(void *)((char *)qword_23C7196D8 + ((v9 >> 53) & 0x7F8)) ^ *(void *)&v17[(v10 >> 53) & 0x7F8];
  return result;
}

void ERR_load_RSA_strings(void)
{
  if (!ERR_func_error_string(RSA_str_functs))
  {
    ERR_load_strings(0, (ERR_STRING_DATA *)&RSA_str_functs);
    ERR_load_strings(0, (ERR_STRING_DATA *)&RSA_str_reasons);
  }
}

uint64_t i2r_PKEY_USAGE_PERIOD(int a1, ASN1_GENERALIZEDTIME **a2, BIO *bio, int a4)
{
  if (*a2)
  {
    BIO_write(bio, "Not Before: ", 12);
    ASN1_GENERALIZEDTIME_print(bio, *a2);
    if (a2[1]) {
      BIO_write(bio, ", ", 2);
    }
  }
  if (a2[1])
  {
    BIO_write(bio, "Not After: ", 11);
    ASN1_GENERALIZEDTIME_print(bio, a2[1]);
  }
  return 1;
}

PKEY_USAGE_PERIOD *__cdecl d2i_PKEY_USAGE_PERIOD(PKEY_USAGE_PERIOD **a, const unsigned __int8 **in, uint64_t len)
{
  return (PKEY_USAGE_PERIOD *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, &PKEY_USAGE_PERIOD_it);
}

int i2d_PKEY_USAGE_PERIOD(PKEY_USAGE_PERIOD *a, unsigned __int8 **out)
{
  return ASN1_item_i2d((ASN1_VALUE *)a, out, &PKEY_USAGE_PERIOD_it);
}

PKEY_USAGE_PERIOD *PKEY_USAGE_PERIOD_new(void)
{
  return (PKEY_USAGE_PERIOD *)ASN1_item_new(&PKEY_USAGE_PERIOD_it);
}

void PKEY_USAGE_PERIOD_free(PKEY_USAGE_PERIOD *a)
{
}

BOOL CMS_SignedData_init(ASN1_OBJECT **a1)
{
  return cms_signed_data_init(a1) != 0;
}

uint64_t cms_signed_data_init(ASN1_OBJECT **a1)
{
  if (a1[1])
  {
    return cms_get0_signed((uint64_t)a1);
  }
  else
  {
    unint64_t v3 = ASN1_item_new(&CMS_SignedData_it);
    a1[1] = (ASN1_OBJECT *)v3;
    if (v3)
    {
      *(void *)unint64_t v3 = 1;
      unint64_t v4 = OBJ_nid2obj(21);
      unint64_t v5 = *a1;
      **(void **)&a1[1]->niunsigned int d = v4;
      *(_DWORD *)(*(void *)&a1[1]->nid + ++*(_DWORD *)(*(void *)(result + 8) + 16) = 1;
      ASN1_OBJECT_free(v5);
      *a1 = OBJ_nid2obj(22);
      return (uint64_t)a1[1];
    }
    else
    {
      ERR_put_error(46, 4095, 65, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_sd.c", 86);
      return 0;
    }
  }
}

uint64_t cms_set1_SignerIdentifier(uint64_t a1, X509 *a2, int a3)
{
  if (a3 == 1)
  {
    uint64_t result = cms_set1_keyid((ASN1_OCTET_STRING **)(a1 + 8), a2);
    if (!result) {
      return result;
    }
    goto LABEL_6;
  }
  if (a3)
  {
    ERR_put_error(46, 4095, 150, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_sd.c", 216);
    return 0;
  }
  uint64_t result = cms_set1_ias((ASN1_VALUE **)(a1 + 8), a2);
  if (result)
  {
LABEL_6:
    *(_DWORD *)a1 = a3;
    return 1;
  }
  return result;
}

uint64_t cms_SignerIdentifier_get0_signer_id(uint64_t a1, void *a2, void *a3, void *a4)
{
  if (*(_DWORD *)a1 == 1)
  {
    if (!a2) {
      return 1;
    }
    unint64_t v4 = (void *)(a1 + 8);
    a4 = a2;
LABEL_9:
    *a4 = *v4;
    return 1;
  }
  if (!*(_DWORD *)a1)
  {
    if (a3) {
      *a3 = **(void **)(a1 + 8);
    }
    if (!a4) {
      return 1;
    }
    unint64_t v4 = (void *)(*(void *)(a1 + 8) + 8);
    goto LABEL_9;
  }
  return 0;
}

uint64_t cms_SignerIdentifier_cert_cmp(uint64_t a1, X509 *a2)
{
  if (*(_DWORD *)a1 == 1) {
    return cms_keyid_cert_cmp(*(ASN1_OCTET_STRING **)(a1 + 8), a2);
  }
  if (*(_DWORD *)a1) {
    return 0xFFFFFFFFLL;
  }
  return cms_ias_cert_cmp(*(void *)(a1 + 8), a2);
}

ASN1_VALUE *CMS_add1_signer(ASN1_OBJECT **a1, X509 *x509, EVP_PKEY *pkey, const EVP_MD *a4, int a5)
{
  if (!X509_check_private_key(x509, pkey))
  {
    ERR_put_error(46, 4095, 136, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_sd.c", 285);
    return 0;
  }
  uint64_t v10 = cms_signed_data_init(a1);
  if (!v10)
  {
    uint64_t v12 = 0;
    goto LABEL_57;
  }
  uint64_t v11 = v10;
  uint64_t v12 = ASN1_item_new(&CMS_SignerInfo_it);
  if (!v12) {
    goto LABEL_55;
  }
  X509_check_purpose(x509, -1, -1);
  X509_up_ref((uint64_t)x509);
  EVP_PKEY_up_ref((uint64_t)pkey);
  *((void *)v12 + 7) = x509;
  *((void *)v12 + 8) = pkey;
  long long v13 = EVP_MD_CTX_new();
  *((void *)v12 + 1RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = 0;
  *((void *)v12 + 9) = v13;
  if (!v13)
  {
    int v15 = 65;
    int v16 = 306;
    goto LABEL_56;
  }
  if ((a5 & 0x10000) != 0)
  {
    *(void *)uint64_t v12 = 3;
    if (*(uint64_t *)v11 <= 2) {
      *(void *)uint64_t v11 = 3;
    }
    int v14 = 1;
  }
  else
  {
    int v14 = 0;
    *(void *)uint64_t v12 = 1;
  }
  if (!cms_set1_SignerIdentifier(*((void *)v12 + 1), x509, v14)) {
    goto LABEL_57;
  }
  if (!a4)
  {
    LODWORD(paobj) = 0;
    if ((int)EVP_PKEY_get_default_digest_nid((uint64_t)pkey) < 1) {
      goto LABEL_57;
    }
    BOOL v20 = OBJ_nid2sn((int)paobj);
    digestbyname = EVP_get_digestbyname(v20);
    if (digestbyname)
    {
      a4 = digestbyname;
      goto LABEL_15;
    }
    int v15 = 128;
    int v16 = 329;
LABEL_56:
    ERR_put_error(46, 4095, v15, "/Library/Caches/com.apple.xbs/Sources/Shortcuts/ShortcutsActions/ActionKit/External/libressl/libressl/crypto/cms/cms_sd.c", v16);
    goto LABEL_57;
  }
LABEL_15:
  X509_ALGOR_set_md(*((X509_ALGOR **)v12 + 2), a4);
  if (sk_num(*(const STACK **)(v11 + 8)) < 1)
  {
    int v17 = 0;
  }
  else
  {
    int v17 = 0;
    do
    {
      paobuint64_t j = 0;
      long long v18 = sk_value(*(const STACK **)(v11 + 8), v17);
      X509_ALGOR_get0(&paobj, 0, 0, (X509_ALGOR *)v18);
      int v19 = OBJ_obj2nid(paobj);
      if (v19 == EVP_MD_type(a4)) {
        break;
      }
      ++v17;
    }
    while (v17 < sk_num(*(const STACK **)(v11 + 8)));
  }
  if (v17 == sk_num(*(const STACK **)(v11 + 8)))
  {
    uint64_t v22 = X509_ALGOR_new();
    if (!v22) {
      goto LABEL_55;
    }
    int v23 = v22;
    X509_ALGOR_set_md(v22, a4);
    if (!sk_push(*(STACK **)(v11 + 8), (char *)v23))
    {
      X509_ALGOR_free(v23);
      goto LABEL_55;
    }
  }
  if ((a5 & 0x40000) == 0 && !cms_sd_asn1_ctrl((uint64_t)v12)) {
    goto LABEL_57;
  }
  if ((a5 & 0x100) != 0) {
    goto LABEL_39;
  }
  if (!*((void *)v12 + 3))
  {
    int v24 = sk_new_null();
    *((void *)v12 + 3) = v24;
    if (!v24) {
      goto LABEL_55;
    }
  }
  if ((a5 & 0x200) == 0)
  {
    paobuint64_t j = 0;
    unsigned int v25 = CMS_add_standard_smimecap((STACK **)&paobj);
    int v26 = (STACK *)paobj;
    if (v25)
    {
      BOOL v27 = CMS_add_smimecap((uint64_t)v12, (X509_ALGORS *)paobj);
      sk_pop_free(v26, (void (__cdecl *)(void *))X509_ALGOR_free);
      if (v27) {
        goto LABEL_35;
      }
    }
    else
    {
      sk_pop_free((STACK *)paobj, (void (__cdecl *)(void *))X509_ALGOR_free);
    }
LABEL_55:
    int v15 = 65;
    int v16 = 421;
    goto LABEL_56;
  }
LABEL_35:
  if ((a5 & 0x8000) != 0
    && (!cms_copy_messageDigest((uint64_t)a1, (uint64_t)v12)
     || (a5 & 0x44000) == 0 && !CMS_SignerInfo_sign((uint64_t)v12)))
  {
    goto LABEL_57;
  }
LABEL_39:
  if ((a5 & 2) == 0 && !CMS_add1_cert((uint64_t)a1, x509)) {
    goto LABEL_55;
  }
  if ((a5 & 0x40000) != 0)
  {
    if ((a5 & 0x100) != 0)
    {
      uint64_t v29 = (uint64_t *)EVP_PKEY_CTX_new(*((void *)v12 + 8), 0);
      *((void *)v12 + 1RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = v29;
      if (!v29 || (int)EVP_PKEY_sign_init(v29) < 1) {
        goto LABEL_57;
      }
      int v28 = EVP_PKEY_CTX_ctrl(*((uint64_t **)v12 + 10), -1, 248);
    }
    else
    {
      int v28 = EVP_DigestSignInit(*((void *)v12 + 9), (void *)v12 + 10, a4, 0, (uint64_t)pkey);
    }
    if (v28 < 1)
    {
LABEL_57:
      ASN1_item_free(v12, &CMS_SignerInfo_it);
      return 0;
    }
  }
  uint64_t v30 = *(STACK **)(v11 + 40);
  if (!v30)
  {
    uint64_t v30 = sk_new_null();
    *(void *)(v11 + 4RSA_padding_add_PKCS1_OAEP_mgf1(to, tlen, f, fl, p, pl, 0, 0) = v30;
    if (!v30) {
      goto LABEL_55;
    }
  }
  if (!sk_push(v30, (char *)v12)) {
    goto LABEL_55;
  }
  return v12;
}