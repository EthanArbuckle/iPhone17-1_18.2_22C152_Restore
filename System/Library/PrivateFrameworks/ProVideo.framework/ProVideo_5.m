void *std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int const*,unsigned int const*>(void *result, char *__src, char *a3, size_t __sz)
{
  char *v6;
  void *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  BOOL v11;
  unint64_t v12;
  uint64_t v13;
  size_t v14;
  void **v15;
  unsigned char *v16;
  unint64_t v17;
  char *v18;
  void *v19;

  v6 = __src;
  v7 = result;
  v8 = result[2];
  v9 = (char *)*result;
  if (__sz > (v8 - *result) >> 2)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (__sz >> 62) {
      goto LABEL_22;
    }
    v10 = v8 >> 1;
    if (v8 >> 1 <= __sz) {
      v10 = __sz;
    }
    v11 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL;
    v12 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v11) {
      v12 = v10;
    }
    if (v12 >> 62) {
LABEL_22:
    }
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v13 = 4 * v12;
    result = operator new(4 * v12);
    v9 = (char *)result;
    *v7 = result;
    v7[1] = result;
    v7[2] = (char *)result + v13;
    v14 = a3 - v6;
    if (v14) {
      result = memcpy(result, v6, v14);
    }
    v15 = (void **)(v7 + 1);
    goto LABEL_21;
  }
  v15 = (void **)(result + 1);
  v16 = (unsigned char *)result[1];
  v17 = (v16 - v9) >> 2;
  if (v17 >= __sz)
  {
    v14 = a3 - __src;
    if (a3 == __src) {
      goto LABEL_21;
    }
    v19 = (void *)*result;
LABEL_20:
    result = memmove(v19, __src, v14);
    goto LABEL_21;
  }
  v18 = &__src[4 * v17];
  if (v16 != v9)
  {
    result = memmove((void *)*result, __src, v16 - v9);
    v9 = (char *)*v15;
  }
  v14 = a3 - v18;
  if (v14)
  {
    v19 = v9;
    __src = v18;
    goto LABEL_20;
  }
LABEL_21:
  *v15 = &v9[v14];
  return result;
}

void *std::vector<HGRef<HGBitmap>>::__push_back_slow_path<HGRef<HGBitmap>>(void **a1, void *a2)
{
  v4 = *a1;
  v3 = a1[1];
  uint64_t v5 = (v3 - (unsigned char *)*a1) >> 3;
  unint64_t v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) >> 61) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v8 = (unsigned char *)a1[2] - v4;
  if (v8 >> 2 > v6) {
    unint64_t v6 = v8 >> 2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v6;
  }
  if (v9)
  {
    if (v9 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    v10 = (char *)operator new(8 * v9);
  }
  else
  {
    v10 = 0;
  }
  v11 = &v10[8 * v5];
  *(void *)v11 = *a2;
  v12 = v11 + 8;
  v13 = &v10[8 * v9];
  *a2 = 0;
  v21 = v13;
  if (v3 != v4)
  {
    uint64_t v14 = 0;
    do
    {
      uint64_t v15 = *(void *)&v3[v14 - 8];
      *(void *)&v11[v14 - 8] = v15;
      if (v15) {
        (*(void (**)(uint64_t))(*(void *)v15 + 16))(v15);
      }
      v14 -= 8;
    }
    while (&v3[v14] != v4);
    v12 = v11 + 8;
    v13 = v21;
    v11 += v14;
  }
  v16 = (char *)*a1;
  v17 = (char *)a1[1];
  *a1 = v11;
  a1[1] = v12;
  a1[2] = v13;
  while (v17 != v16)
  {
    uint64_t v19 = *((void *)v17 - 1);
    v17 -= 8;
    uint64_t v18 = v19;
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v18 + 24))(v18);
    }
  }
  if (v16) {
    operator delete(v16);
  }
  return v12;
}

uint64_t std::__split_buffer<HGRef<HGBitmap>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    uint64_t v5 = *(void *)(v2 - 8);
    v2 -= 8;
    uint64_t v4 = v5;
    *(void *)(a1 + 16) = v2;
    if (v5)
    {
      (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__tree<std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>,std::__map_value_compare<HGMetalDeviceInfo const*,std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>,std::less<HGMetalDeviceInfo const*>,true>,std::allocator<std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>,std::__map_value_compare<HGMetalDeviceInfo const*,std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>,std::less<HGMetalDeviceInfo const*>,true>,std::allocator<std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>,std::__map_value_compare<HGMetalDeviceInfo const*,std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>,std::less<HGMetalDeviceInfo const*>,true>,std::allocator<std::__value_type<HGMetalDeviceInfo const*,HGRef<HGMetalContext>>>>::destroy(a1, a2[1]);
    uint64_t v4 = a2[5];
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
    }
    operator delete(a2);
  }
}

void *std::vector<HGRef<HGPixelBufferObj>>::__push_back_slow_path<HGRef<HGPixelBufferObj>>(void **a1, void *a2)
{
  uint64_t v4 = *a1;
  uint64_t v3 = a1[1];
  uint64_t v5 = (v3 - (unsigned char *)*a1) >> 3;
  unint64_t v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) >> 61) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v8 = (unsigned char *)a1[2] - v4;
  if (v8 >> 2 > v6) {
    unint64_t v6 = v8 >> 2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v6;
  }
  if (v9)
  {
    if (v9 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    v10 = (char *)operator new(8 * v9);
  }
  else
  {
    v10 = 0;
  }
  v11 = &v10[8 * v5];
  *(void *)v11 = *a2;
  v12 = v11 + 8;
  v13 = &v10[8 * v9];
  *a2 = 0;
  v21 = v13;
  if (v3 != v4)
  {
    uint64_t v14 = 0;
    do
    {
      uint64_t v15 = *(void *)&v3[v14 - 8];
      *(void *)&v11[v14 - 8] = v15;
      if (v15) {
        (*(void (**)(uint64_t))(*(void *)v15 + 16))(v15);
      }
      v14 -= 8;
    }
    while (&v3[v14] != v4);
    v12 = v11 + 8;
    v13 = v21;
    v11 += v14;
  }
  v16 = (char *)*a1;
  v17 = (char *)a1[1];
  *a1 = v11;
  a1[1] = v12;
  a1[2] = v13;
  while (v17 != v16)
  {
    uint64_t v19 = *((void *)v17 - 1);
    v17 -= 8;
    uint64_t v18 = v19;
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v18 + 24))(v18);
    }
  }
  if (v16) {
    operator delete(v16);
  }
  return v12;
}

uint64_t std::__split_buffer<HGRef<HGPixelBufferObj>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    uint64_t v5 = *(void *)(v2 - 8);
    v2 -= 8;
    uint64_t v4 = v5;
    *(void *)(a1 + 16) = v2;
    if (v5)
    {
      (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(HGROIsInfo const&,HGROIsInfo const&),HGROIsInfo*,false>(unint64_t a1, __n128 *a2, unsigned int (**a3)(char *, long long *), uint64_t a4, char a5)
{
BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(HGROIsInfo const&,HGROIsInfo const&),HGROIsInfo*>(__n128 *a1, __n128 *a2, uint64_t (**a3)(__n128 *, __n128 *))
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(0x8E38E38E38E38E39 * v6)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      uint64_t v8 = a2 - 9;
      if (!(*a3)(a2 - 9, a1)) {
        return 1;
      }
      __n128 v9 = a1[7];
      __n128 v215 = a1[6];
      __n128 v216 = v9;
      __n128 v217 = a1[8];
      __n128 v10 = a1[3];
      __n128 v211 = a1[2];
      __n128 v212 = v10;
      __n128 v11 = a1[5];
      __n128 v213 = a1[4];
      __n128 v214 = v11;
      __n128 v12 = a1[1];
      __n128 v209 = *a1;
      __n128 v210 = v12;
      *a1 = *v8;
      __n128 v13 = a2[-8];
      __n128 v14 = a2[-7];
      __n128 v15 = a2[-5];
      a1[3] = a2[-6];
      a1[4] = v15;
      a1[1] = v13;
      a1[2] = v14;
      __n128 v16 = a2[-4];
      __n128 v17 = a2[-3];
      __n128 v18 = a2[-1];
      a1[7] = a2[-2];
      a1[8] = v18;
      a1[5] = v16;
      a1[6] = v17;
      __n128 v19 = v216;
      a2[-3] = v215;
      a2[-2] = v19;
      a2[-1] = v217;
      __n128 v20 = v212;
      a2[-7] = v211;
      a2[-6] = v20;
      __n128 v21 = v214;
      a2[-5] = v213;
      a2[-4] = v21;
      __n128 v22 = v210;
      BOOL result = 1;
      *uint64_t v8 = v209;
      a2[-8] = v22;
      return result;
    case 3uLL:
      __n128 v23 = a1 + 9;
      long long v24 = a2 - 9;
      char v25 = (*a3)(a1 + 9, a1);
      int v26 = (*a3)(v24, a1 + 9);
      if ((v25 & 1) == 0)
      {
        if (!v26) {
          return 1;
        }
        __n128 v91 = a1[16];
        __n128 v215 = a1[15];
        __n128 v216 = v91;
        __n128 v217 = a1[17];
        __n128 v92 = a1[12];
        __n128 v211 = a1[11];
        __n128 v212 = v92;
        __n128 v93 = a1[14];
        __n128 v213 = a1[13];
        __n128 v214 = v93;
        __n128 v94 = a1[10];
        __n128 v209 = *v23;
        __n128 v210 = v94;
        *__n128 v23 = *v24;
        __n128 v95 = v24[1];
        __n128 v96 = v24[2];
        __n128 v97 = v24[4];
        a1[12] = v24[3];
        a1[13] = v97;
        a1[10] = v95;
        a1[11] = v96;
        __n128 v98 = v24[5];
        __n128 v99 = v24[6];
        __n128 v100 = v24[8];
        a1[16] = v24[7];
        a1[17] = v100;
        a1[14] = v98;
        a1[15] = v99;
        __n128 v101 = v216;
        v24[6] = v215;
        v24[7] = v101;
        v24[8] = v217;
        __n128 v102 = v212;
        v24[2] = v211;
        v24[3] = v102;
        __n128 v103 = v214;
        v24[4] = v213;
        v24[5] = v103;
        __n128 v104 = v210;
        *long long v24 = v209;
        v24[1] = v104;
        goto LABEL_17;
      }
      if (v26)
      {
        __n128 v27 = a1[7];
        __n128 v215 = a1[6];
        __n128 v216 = v27;
        __n128 v217 = a1[8];
        __n128 v28 = a1[3];
        __n128 v211 = a1[2];
        __n128 v212 = v28;
        __n128 v29 = a1[5];
        __n128 v213 = a1[4];
        __n128 v214 = v29;
        __n128 v30 = a1[1];
        __n128 v209 = *a1;
        __n128 v210 = v30;
        *a1 = *v24;
        __n128 v31 = v24[1];
        __n128 v32 = v24[2];
        __n128 v33 = v24[4];
        a1[3] = v24[3];
        a1[4] = v33;
        a1[1] = v31;
        a1[2] = v32;
        __n128 v34 = v24[5];
        __n128 v35 = v24[6];
        __n128 v36 = v24[8];
        a1[7] = v24[7];
        a1[8] = v36;
        a1[5] = v34;
        a1[6] = v35;
      }
      else
      {
        __n128 v141 = a1[7];
        __n128 v215 = a1[6];
        __n128 v216 = v141;
        __n128 v217 = a1[8];
        __n128 v142 = a1[3];
        __n128 v211 = a1[2];
        __n128 v212 = v142;
        __n128 v143 = a1[5];
        __n128 v213 = a1[4];
        __n128 v214 = v143;
        __n128 v144 = a1[1];
        __n128 v209 = *a1;
        __n128 v210 = v144;
        __n128 v145 = a1[14];
        a1[4] = a1[13];
        a1[5] = v145;
        __n128 v146 = a1[16];
        a1[6] = a1[15];
        a1[7] = v146;
        a1[8] = a1[17];
        __n128 v147 = a1[12];
        a1[2] = a1[11];
        a1[3] = v147;
        __n128 v148 = a1[10];
        *a1 = *v23;
        a1[1] = v148;
        __n128 v149 = v214;
        a1[13] = v213;
        a1[14] = v149;
        __n128 v150 = v216;
        a1[15] = v215;
        a1[16] = v150;
        a1[17] = v217;
        __n128 v151 = v212;
        a1[11] = v211;
        a1[12] = v151;
        __n128 v152 = v210;
        *__n128 v23 = v209;
        a1[10] = v152;
        if (!(*a3)(v24, a1 + 9)) {
          return 1;
        }
        __n128 v153 = a1[16];
        __n128 v215 = a1[15];
        __n128 v216 = v153;
        __n128 v217 = a1[17];
        __n128 v154 = a1[12];
        __n128 v211 = a1[11];
        __n128 v212 = v154;
        __n128 v155 = a1[14];
        __n128 v213 = a1[13];
        __n128 v214 = v155;
        __n128 v156 = a1[10];
        __n128 v209 = *v23;
        __n128 v210 = v156;
        *__n128 v23 = *v24;
        __n128 v157 = v24[1];
        __n128 v158 = v24[2];
        __n128 v159 = v24[4];
        a1[12] = v24[3];
        a1[13] = v159;
        a1[10] = v157;
        a1[11] = v158;
        __n128 v160 = v24[5];
        __n128 v161 = v24[6];
        __n128 v162 = v24[8];
        a1[16] = v24[7];
        a1[17] = v162;
        a1[14] = v160;
        a1[15] = v161;
      }
      __n128 v163 = v216;
      v24[6] = v215;
      v24[7] = v163;
      v24[8] = v217;
      __n128 v164 = v212;
      v24[2] = v211;
      v24[3] = v164;
      __n128 v165 = v214;
      v24[4] = v213;
      v24[5] = v165;
      __n128 v166 = v210;
      BOOL result = 1;
      *long long v24 = v209;
      v24[1] = v166;
      return result;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(HGROIsInfo const&,HGROIsInfo const&),HGROIsInfo*>(a1, a1 + 9, a1 + 18, a2 - 9, a3);
      return 1;
    case 5uLL:
      __n128 v23 = a1 + 9;
      long long v37 = a1 + 18;
      long long v38 = a1 + 27;
      long long v39 = a2 - 9;
      __n128 v40 = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(HGROIsInfo const&,HGROIsInfo const&),HGROIsInfo*>(a1, a1 + 9, a1 + 18, a1 + 27, a3);
      if (!((unsigned int (*)(__n128 *, __n128 *, __n128))*a3)(v39, &a1[27], v40)) {
        return 1;
      }
      __n128 v41 = a1[34];
      __n128 v215 = a1[33];
      __n128 v216 = v41;
      __n128 v217 = a1[35];
      __n128 v42 = a1[30];
      __n128 v211 = a1[29];
      __n128 v212 = v42;
      __n128 v43 = a1[32];
      __n128 v213 = a1[31];
      __n128 v214 = v43;
      __n128 v44 = a1[28];
      __n128 v209 = *v38;
      __n128 v210 = v44;
      *long long v38 = *v39;
      __n128 v45 = v39[1];
      __n128 v46 = v39[2];
      __n128 v47 = v39[4];
      a1[30] = v39[3];
      a1[31] = v47;
      a1[28] = v45;
      a1[29] = v46;
      __n128 v48 = v39[5];
      __n128 v49 = v39[6];
      __n128 v50 = v39[8];
      a1[34] = v39[7];
      a1[35] = v50;
      a1[32] = v48;
      a1[33] = v49;
      __n128 v51 = v216;
      v39[6] = v215;
      v39[7] = v51;
      v39[8] = v217;
      __n128 v52 = v212;
      v39[2] = v211;
      v39[3] = v52;
      __n128 v53 = v214;
      v39[4] = v213;
      v39[5] = v53;
      __n128 v54 = v210;
      *long long v39 = v209;
      v39[1] = v54;
      if (!(*a3)(a1 + 27, a1 + 18)) {
        return 1;
      }
      __n128 v55 = a1[25];
      __n128 v215 = a1[24];
      __n128 v216 = v55;
      __n128 v217 = a1[26];
      __n128 v56 = a1[21];
      __n128 v211 = a1[20];
      __n128 v212 = v56;
      __n128 v57 = a1[23];
      __n128 v213 = a1[22];
      __n128 v214 = v57;
      __n128 v58 = a1[19];
      __n128 v209 = *v37;
      __n128 v210 = v58;
      __n128 v59 = a1[32];
      a1[22] = a1[31];
      a1[23] = v59;
      __n128 v60 = a1[34];
      a1[24] = a1[33];
      a1[25] = v60;
      a1[26] = a1[35];
      __n128 v61 = a1[30];
      a1[20] = a1[29];
      a1[21] = v61;
      __n128 v62 = a1[28];
      *long long v37 = *v38;
      a1[19] = v62;
      __n128 v63 = v214;
      a1[31] = v213;
      a1[32] = v63;
      __n128 v64 = v216;
      a1[33] = v215;
      a1[34] = v64;
      a1[35] = v217;
      __n128 v65 = v212;
      a1[29] = v211;
      a1[30] = v65;
      __n128 v66 = v210;
      *long long v38 = v209;
      a1[28] = v66;
      if (!(*a3)(a1 + 18, a1 + 9)) {
        return 1;
      }
      __n128 v67 = a1[16];
      __n128 v215 = a1[15];
      __n128 v216 = v67;
      __n128 v217 = a1[17];
      __n128 v68 = a1[12];
      __n128 v211 = a1[11];
      __n128 v212 = v68;
      __n128 v69 = a1[14];
      __n128 v213 = a1[13];
      __n128 v214 = v69;
      __n128 v70 = a1[10];
      __n128 v209 = *v23;
      __n128 v210 = v70;
      __n128 v71 = a1[23];
      a1[13] = a1[22];
      a1[14] = v71;
      __n128 v72 = a1[25];
      a1[15] = a1[24];
      a1[16] = v72;
      a1[17] = a1[26];
      __n128 v73 = a1[21];
      a1[11] = a1[20];
      a1[12] = v73;
      __n128 v74 = a1[19];
      *__n128 v23 = *v37;
      a1[10] = v74;
      __n128 v75 = v214;
      a1[22] = v213;
      a1[23] = v75;
      __n128 v76 = v216;
      a1[24] = v215;
      a1[25] = v76;
      a1[26] = v217;
      __n128 v77 = v212;
      a1[20] = v211;
      a1[21] = v77;
      __n128 v78 = v210;
      *long long v37 = v209;
      a1[19] = v78;
LABEL_17:
      if (!(*a3)(v23, a1)) {
        return 1;
      }
      __n128 v105 = a1[7];
      __n128 v215 = a1[6];
      __n128 v216 = v105;
      __n128 v217 = a1[8];
      __n128 v106 = a1[3];
      __n128 v211 = a1[2];
      __n128 v212 = v106;
      __n128 v107 = a1[5];
      __n128 v213 = a1[4];
      __n128 v214 = v107;
      __n128 v108 = a1[1];
      __n128 v209 = *a1;
      __n128 v210 = v108;
      __n128 v109 = v23[5];
      a1[4] = v23[4];
      a1[5] = v109;
      __n128 v110 = v23[7];
      a1[6] = v23[6];
      a1[7] = v110;
      a1[8] = v23[8];
      __n128 v111 = v23[3];
      a1[2] = v23[2];
      a1[3] = v111;
      __n128 v112 = v23[1];
      *a1 = *v23;
      a1[1] = v112;
      __n128 v113 = v214;
      v23[4] = v213;
      v23[5] = v113;
      __n128 v114 = v216;
      v23[6] = v215;
      v23[7] = v114;
      v23[8] = v217;
      __n128 v115 = v212;
      v23[2] = v211;
      v23[3] = v115;
      __n128 v116 = v210;
      BOOL result = 1;
      *__n128 v23 = v209;
      v23[1] = v116;
      return result;
    default:
      long long v79 = a1 + 18;
      long long v80 = a1 + 9;
      char v81 = (*a3)(a1 + 9, a1);
      int v82 = (*a3)(a1 + 18, a1 + 9);
      if (v81)
      {
        if (v82)
        {
          __n128 v83 = a1[7];
          __n128 v215 = a1[6];
          __n128 v216 = v83;
          __n128 v217 = a1[8];
          __n128 v84 = a1[3];
          __n128 v211 = a1[2];
          __n128 v212 = v84;
          __n128 v85 = a1[5];
          __n128 v213 = a1[4];
          __n128 v214 = v85;
          __n128 v86 = a1[1];
          __n128 v209 = *a1;
          __n128 v210 = v86;
          __n128 v87 = a1[23];
          a1[4] = a1[22];
          a1[5] = v87;
          __n128 v88 = a1[25];
          a1[6] = a1[24];
          a1[7] = v88;
          a1[8] = a1[26];
          __n128 v89 = a1[21];
          a1[2] = a1[20];
          a1[3] = v89;
          __n128 v90 = a1[19];
          *a1 = *v79;
          a1[1] = v90;
        }
        else
        {
          __n128 v167 = a1[7];
          __n128 v215 = a1[6];
          __n128 v216 = v167;
          __n128 v217 = a1[8];
          __n128 v168 = a1[3];
          __n128 v211 = a1[2];
          __n128 v212 = v168;
          __n128 v169 = a1[5];
          __n128 v213 = a1[4];
          __n128 v214 = v169;
          __n128 v170 = a1[1];
          __n128 v209 = *a1;
          __n128 v210 = v170;
          __n128 v171 = a1[14];
          a1[4] = a1[13];
          a1[5] = v171;
          __n128 v172 = a1[16];
          a1[6] = a1[15];
          a1[7] = v172;
          a1[8] = a1[17];
          __n128 v173 = a1[12];
          a1[2] = a1[11];
          a1[3] = v173;
          __n128 v174 = a1[10];
          *a1 = *v80;
          a1[1] = v174;
          __n128 v175 = v214;
          a1[13] = v213;
          a1[14] = v175;
          __n128 v176 = v216;
          a1[15] = v215;
          a1[16] = v176;
          a1[17] = v217;
          __n128 v177 = v212;
          a1[11] = v211;
          a1[12] = v177;
          __n128 v178 = v210;
          *long long v80 = v209;
          a1[10] = v178;
          if (!(*a3)(a1 + 18, a1 + 9)) {
            goto LABEL_28;
          }
          __n128 v179 = a1[16];
          __n128 v215 = a1[15];
          __n128 v216 = v179;
          __n128 v217 = a1[17];
          __n128 v180 = a1[12];
          __n128 v211 = a1[11];
          __n128 v212 = v180;
          __n128 v181 = a1[14];
          __n128 v213 = a1[13];
          __n128 v214 = v181;
          __n128 v182 = a1[10];
          __n128 v209 = *v80;
          __n128 v210 = v182;
          __n128 v183 = a1[23];
          a1[13] = a1[22];
          a1[14] = v183;
          __n128 v184 = a1[25];
          a1[15] = a1[24];
          a1[16] = v184;
          a1[17] = a1[26];
          __n128 v185 = a1[21];
          a1[11] = a1[20];
          a1[12] = v185;
          __n128 v186 = a1[19];
          *long long v80 = *v79;
          a1[10] = v186;
        }
        __n128 v187 = v214;
        a1[22] = v213;
        a1[23] = v187;
        __n128 v188 = v216;
        a1[24] = v215;
        a1[25] = v188;
        a1[26] = v217;
        __n128 v189 = v212;
        a1[20] = v211;
        a1[21] = v189;
        __n128 v190 = v210;
        *long long v79 = v209;
        a1[19] = v190;
      }
      else if (v82)
      {
        __n128 v117 = a1[16];
        __n128 v215 = a1[15];
        __n128 v216 = v117;
        __n128 v217 = a1[17];
        __n128 v118 = a1[12];
        __n128 v211 = a1[11];
        __n128 v212 = v118;
        __n128 v119 = a1[14];
        __n128 v213 = a1[13];
        __n128 v214 = v119;
        __n128 v120 = a1[10];
        __n128 v209 = *v80;
        __n128 v210 = v120;
        __n128 v121 = a1[23];
        a1[13] = a1[22];
        a1[14] = v121;
        __n128 v122 = a1[25];
        a1[15] = a1[24];
        a1[16] = v122;
        a1[17] = a1[26];
        __n128 v123 = a1[21];
        a1[11] = a1[20];
        a1[12] = v123;
        __n128 v124 = a1[19];
        *long long v80 = *v79;
        a1[10] = v124;
        __n128 v125 = v214;
        a1[22] = v213;
        a1[23] = v125;
        __n128 v126 = v216;
        a1[24] = v215;
        a1[25] = v126;
        a1[26] = v217;
        __n128 v127 = v212;
        a1[20] = v211;
        a1[21] = v127;
        __n128 v128 = v210;
        *long long v79 = v209;
        a1[19] = v128;
        if ((*a3)(a1 + 9, a1))
        {
          __n128 v129 = a1[7];
          __n128 v215 = a1[6];
          __n128 v216 = v129;
          __n128 v217 = a1[8];
          __n128 v130 = a1[3];
          __n128 v211 = a1[2];
          __n128 v212 = v130;
          __n128 v131 = a1[5];
          __n128 v213 = a1[4];
          __n128 v214 = v131;
          __n128 v132 = a1[1];
          __n128 v209 = *a1;
          __n128 v210 = v132;
          __n128 v133 = a1[14];
          a1[4] = a1[13];
          a1[5] = v133;
          __n128 v134 = a1[16];
          a1[6] = a1[15];
          a1[7] = v134;
          a1[8] = a1[17];
          __n128 v135 = a1[12];
          a1[2] = a1[11];
          a1[3] = v135;
          __n128 v136 = a1[10];
          *a1 = *v80;
          a1[1] = v136;
          __n128 v137 = v214;
          a1[13] = v213;
          a1[14] = v137;
          __n128 v138 = v216;
          a1[15] = v215;
          a1[16] = v138;
          a1[17] = v217;
          __n128 v139 = v212;
          a1[11] = v211;
          a1[12] = v139;
          __n128 v140 = v210;
          *long long v80 = v209;
          a1[10] = v140;
        }
      }
LABEL_28:
      long long v191 = a1 + 27;
      if (&a1[27] == a2) {
        return 1;
      }
      uint64_t v192 = 0;
      int v193 = 0;
      break;
  }
  while (1)
  {
    if ((*a3)(v191, v79))
    {
      __n128 v199 = v191[7];
      __n128 v215 = v191[6];
      __n128 v216 = v199;
      __n128 v217 = v191[8];
      __n128 v200 = v191[3];
      __n128 v211 = v191[2];
      __n128 v212 = v200;
      __n128 v201 = v191[5];
      __n128 v213 = v191[4];
      __n128 v214 = v201;
      __n128 v202 = v191[1];
      uint64_t v203 = v192;
      __n128 v209 = *v191;
      __n128 v210 = v202;
      do
      {
        __n128 v204 = (__n128 *)((char *)a1 + v203);
        __n128 v205 = *(__n128 *)((char *)a1 + v203 + 400);
        v204[33] = *(__n128 *)((char *)a1 + v203 + 384);
        v204[34] = v205;
        v204[35] = *(__n128 *)((char *)a1 + v203 + 416);
        __n128 v206 = *(__n128 *)((char *)a1 + v203 + 336);
        v204[29] = *(__n128 *)((char *)a1 + v203 + 320);
        v204[30] = v206;
        __n128 v207 = *(__n128 *)((char *)a1 + v203 + 368);
        v204[31] = *(__n128 *)((char *)a1 + v203 + 352);
        v204[32] = v207;
        __n128 v208 = *(__n128 *)((char *)a1 + v203 + 304);
        v204[27] = *(__n128 *)((char *)a1 + v203 + 288);
        v204[28] = v208;
        if (v203 == -288)
        {
          long long v194 = a1;
          goto LABEL_31;
        }
        v203 -= 144;
      }
      while (((*a3)(&v209, v204 + 9) & 1) != 0);
      long long v194 = (__n128 *)((char *)a1 + v203 + 432);
LABEL_31:
      __n128 v195 = v216;
      v194[6] = v215;
      v194[7] = v195;
      v194[8] = v217;
      __n128 v196 = v212;
      v194[2] = v211;
      v194[3] = v196;
      __n128 v197 = v214;
      v194[4] = v213;
      v194[5] = v197;
      __n128 v198 = v210;
      ++v193;
      *long long v194 = v209;
      v194[1] = v198;
      if (v193 == 8) {
        return &v191[9] == a2;
      }
    }
    long long v79 = v191;
    v192 += 144;
    v191 += 9;
    if (v191 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(HGROIsInfo const&,HGROIsInfo const&),HGROIsInfo*>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, uint64_t (**a5)(__n128 *, __n128 *))
{
  char v10 = (*a5)(a2, a1);
  int v11 = (*a5)(a3, a2);
  if (v10)
  {
    if (v11)
    {
      __n128 v103 = a1[6];
      __n128 v110 = a1[7];
      __n128 v117 = a1[8];
      __n128 v75 = a1[2];
      __n128 v82 = a1[3];
      __n128 v89 = a1[4];
      __n128 v96 = a1[5];
      __n128 v61 = *a1;
      __n128 v68 = a1[1];
      *a1 = *a3;
      __n128 v12 = a3[1];
      __n128 v13 = a3[2];
      __n128 v14 = a3[4];
      a1[3] = a3[3];
      a1[4] = v14;
      a1[1] = v12;
      a1[2] = v13;
      __n128 v15 = a3[5];
      __n128 v16 = a3[6];
      __n128 v17 = a3[8];
      a1[7] = a3[7];
      a1[8] = v17;
      a1[5] = v15;
      a1[6] = v16;
LABEL_9:
      a3[6] = v103;
      a3[7] = v110;
      a3[8] = v117;
      a3[2] = v75;
      a3[3] = v82;
      a3[4] = v89;
      a3[5] = v96;
      *a3 = v61;
      a3[1] = v68;
      goto LABEL_10;
    }
    __n128 v106 = a1[6];
    __n128 v113 = a1[7];
    __n128 v120 = a1[8];
    __n128 v78 = a1[2];
    __n128 v85 = a1[3];
    __n128 v92 = a1[4];
    __n128 v99 = a1[5];
    __n128 v64 = *a1;
    __n128 v71 = a1[1];
    *a1 = *a2;
    __n128 v30 = a2[1];
    __n128 v31 = a2[2];
    __n128 v32 = a2[4];
    a1[3] = a2[3];
    a1[4] = v32;
    a1[1] = v30;
    a1[2] = v31;
    __n128 v33 = a2[5];
    __n128 v34 = a2[6];
    __n128 v35 = a2[8];
    a1[7] = a2[7];
    a1[8] = v35;
    a1[5] = v33;
    a1[6] = v34;
    a2[6] = v106;
    a2[7] = v113;
    a2[8] = v120;
    a2[2] = v78;
    a2[3] = v85;
    a2[4] = v92;
    a2[5] = v99;
    *a2 = v64;
    a2[1] = v71;
    if ((*a5)(a3, a2))
    {
      __n128 v103 = a2[6];
      __n128 v110 = a2[7];
      __n128 v117 = a2[8];
      __n128 v75 = a2[2];
      __n128 v82 = a2[3];
      __n128 v89 = a2[4];
      __n128 v96 = a2[5];
      __n128 v61 = *a2;
      __n128 v68 = a2[1];
      *a2 = *a3;
      __n128 v36 = a3[1];
      __n128 v37 = a3[2];
      __n128 v38 = a3[4];
      a2[3] = a3[3];
      a2[4] = v38;
      a2[1] = v36;
      a2[2] = v37;
      __n128 v39 = a3[5];
      __n128 v40 = a3[6];
      __n128 v41 = a3[8];
      a2[7] = a3[7];
      a2[8] = v41;
      a2[5] = v39;
      a2[6] = v40;
      goto LABEL_9;
    }
  }
  else if (v11)
  {
    __n128 v104 = a2[6];
    __n128 v111 = a2[7];
    __n128 v118 = a2[8];
    __n128 v76 = a2[2];
    __n128 v83 = a2[3];
    __n128 v90 = a2[4];
    __n128 v97 = a2[5];
    __n128 v62 = *a2;
    __n128 v69 = a2[1];
    *a2 = *a3;
    __n128 v18 = a3[1];
    __n128 v19 = a3[2];
    __n128 v20 = a3[4];
    a2[3] = a3[3];
    a2[4] = v20;
    a2[1] = v18;
    a2[2] = v19;
    __n128 v21 = a3[5];
    __n128 v22 = a3[6];
    __n128 v23 = a3[8];
    a2[7] = a3[7];
    a2[8] = v23;
    a2[5] = v21;
    a2[6] = v22;
    a3[6] = v104;
    a3[7] = v111;
    a3[8] = v118;
    a3[2] = v76;
    a3[3] = v83;
    a3[4] = v90;
    a3[5] = v97;
    *a3 = v62;
    a3[1] = v69;
    if ((*a5)(a2, a1))
    {
      __n128 v105 = a1[6];
      __n128 v112 = a1[7];
      __n128 v119 = a1[8];
      __n128 v77 = a1[2];
      __n128 v84 = a1[3];
      __n128 v91 = a1[4];
      __n128 v98 = a1[5];
      __n128 v63 = *a1;
      __n128 v70 = a1[1];
      *a1 = *a2;
      __n128 v24 = a2[1];
      __n128 v25 = a2[2];
      __n128 v26 = a2[4];
      a1[3] = a2[3];
      a1[4] = v26;
      a1[1] = v24;
      a1[2] = v25;
      __n128 v27 = a2[5];
      __n128 v28 = a2[6];
      __n128 v29 = a2[8];
      a1[7] = a2[7];
      a1[8] = v29;
      a1[5] = v27;
      a1[6] = v28;
      a2[6] = v105;
      a2[7] = v112;
      a2[8] = v119;
      a2[2] = v77;
      a2[3] = v84;
      a2[4] = v91;
      a2[5] = v98;
      *a2 = v63;
      a2[1] = v70;
    }
  }
LABEL_10:
  if ((*a5)(a4, a3))
  {
    __n128 v107 = a3[6];
    __n128 v114 = a3[7];
    __n128 v121 = a3[8];
    __n128 v79 = a3[2];
    __n128 v86 = a3[3];
    __n128 v93 = a3[4];
    __n128 v100 = a3[5];
    __n128 v65 = *a3;
    __n128 v72 = a3[1];
    *a3 = *a4;
    __n128 v43 = a4[1];
    __n128 v44 = a4[2];
    __n128 v45 = a4[4];
    a3[3] = a4[3];
    a3[4] = v45;
    a3[1] = v43;
    a3[2] = v44;
    __n128 v46 = a4[5];
    __n128 v47 = a4[6];
    __n128 v48 = a4[8];
    a3[7] = a4[7];
    a3[8] = v48;
    a3[5] = v46;
    a3[6] = v47;
    a4[6] = v107;
    a4[7] = v114;
    a4[8] = v121;
    a4[2] = v79;
    a4[3] = v86;
    a4[4] = v93;
    a4[5] = v100;
    *a4 = v65;
    a4[1] = v72;
    if ((*a5)(a3, a2))
    {
      __n128 v108 = a2[6];
      __n128 v115 = a2[7];
      __n128 v122 = a2[8];
      __n128 v80 = a2[2];
      __n128 v87 = a2[3];
      __n128 v94 = a2[4];
      __n128 v101 = a2[5];
      __n128 v66 = *a2;
      __n128 v73 = a2[1];
      *a2 = *a3;
      __n128 v49 = a3[1];
      __n128 v50 = a3[2];
      __n128 v51 = a3[4];
      a2[3] = a3[3];
      a2[4] = v51;
      a2[1] = v49;
      a2[2] = v50;
      __n128 v52 = a3[5];
      __n128 v53 = a3[6];
      __n128 v54 = a3[8];
      a2[7] = a3[7];
      a2[8] = v54;
      a2[5] = v52;
      a2[6] = v53;
      a3[6] = v108;
      a3[7] = v115;
      a3[8] = v122;
      a3[2] = v80;
      a3[3] = v87;
      a3[4] = v94;
      a3[5] = v101;
      *a3 = v66;
      a3[1] = v73;
      if ((*a5)(a2, a1))
      {
        __n128 v109 = a1[6];
        __n128 v116 = a1[7];
        __n128 v123 = a1[8];
        __n128 v81 = a1[2];
        __n128 v88 = a1[3];
        __n128 v95 = a1[4];
        __n128 v102 = a1[5];
        __n128 v67 = *a1;
        __n128 v74 = a1[1];
        *a1 = *a2;
        __n128 v55 = a2[1];
        __n128 v56 = a2[2];
        __n128 v57 = a2[4];
        a1[3] = a2[3];
        a1[4] = v57;
        a1[1] = v55;
        a1[2] = v56;
        __n128 v58 = a2[5];
        __n128 v59 = a2[6];
        __n128 v60 = a2[8];
        a1[7] = a2[7];
        a1[8] = v60;
        a1[5] = v58;
        a1[6] = v59;
        a2[6] = v109;
        a2[7] = v116;
        a2[8] = v123;
        a2[2] = v81;
        a2[3] = v88;
        a2[4] = v95;
        a2[5] = v102;
        __n128 result = v74;
        *a2 = v67;
        a2[1] = v74;
      }
    }
  }
  return result;
}

char *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(HGROIsInfo const&,HGROIsInfo const&),HGROIsInfo*,HGROIsInfo*>(char *a1, char *a2, char *a3, unsigned int (**a4)(char *, long long *))
{
  if (a1 == a2) {
    return a3;
  }
  uint64_t v152 = v4;
  uint64_t v153 = v5;
  __n128 v129 = a3;
  uint64_t v132 = 0x8E38E38E38E38E39 * ((a2 - a1) >> 4);
  uint64_t v128 = a2 - a1;
  if (a2 - a1 >= 145 && (unint64_t)v128 >= 0x120)
  {
    int64_t v104 = (unint64_t)(v132 - 2) >> 1;
    int64_t v105 = v104;
    do
    {
      if (v104 >= v105)
      {
        uint64_t v112 = (2 * v105) | 1;
        __n128 v113 = &a1[144 * v112];
        if (2 * v105 + 2 < v132 && (*a4)(&a1[144 * v112], (long long *)v113 + 9))
        {
          v113 += 144;
          uint64_t v112 = 2 * v105 + 2;
        }
        __n128 v114 = &a1[144 * v105];
        if ((((uint64_t (*)(char *, char *))*a4)(v113, v114) & 1) == 0)
        {
          long long v115 = *((_OWORD *)v114 + 7);
          long long v149 = *((_OWORD *)v114 + 6);
          long long v150 = v115;
          long long v151 = *((_OWORD *)v114 + 8);
          long long v116 = *((_OWORD *)v114 + 3);
          long long v145 = *((_OWORD *)v114 + 2);
          long long v146 = v116;
          long long v117 = *((_OWORD *)v114 + 5);
          long long v147 = *((_OWORD *)v114 + 4);
          long long v148 = v117;
          long long v118 = *((_OWORD *)v114 + 1);
          long long v143 = *(_OWORD *)v114;
          long long v144 = v118;
          do
          {
            __n128 v119 = v113;
            *(_OWORD *)__n128 v114 = *(_OWORD *)v113;
            long long v120 = *((_OWORD *)v113 + 1);
            long long v121 = *((_OWORD *)v113 + 2);
            long long v122 = *((_OWORD *)v113 + 4);
            *((_OWORD *)v114 + 3) = *((_OWORD *)v113 + 3);
            *((_OWORD *)v114 + 4) = v122;
            *((_OWORD *)v114 + 1) = v120;
            *((_OWORD *)v114 + 2) = v121;
            long long v123 = *((_OWORD *)v113 + 5);
            long long v124 = *((_OWORD *)v113 + 6);
            long long v125 = *((_OWORD *)v113 + 8);
            *((_OWORD *)v114 + 7) = *((_OWORD *)v113 + 7);
            *((_OWORD *)v114 + 8) = v125;
            *((_OWORD *)v114 + 5) = v123;
            *((_OWORD *)v114 + 6) = v124;
            if (v104 < v112) {
              break;
            }
            uint64_t v126 = (2 * v112) | 1;
            __n128 v113 = &a1[144 * v126];
            uint64_t v127 = 2 * v112 + 2;
            if (v127 < v132 && (*a4)(&a1[144 * v126], (long long *)v113 + 9))
            {
              v113 += 144;
              uint64_t v126 = v127;
            }
            __n128 v114 = v119;
            uint64_t v112 = v126;
          }
          while (!(*a4)(v113, &v143));
          *(_OWORD *)__n128 v119 = v143;
          long long v106 = v144;
          long long v107 = v145;
          long long v108 = v147;
          *((_OWORD *)v119 + 3) = v146;
          *((_OWORD *)v119 + 4) = v108;
          *((_OWORD *)v119 + 1) = v106;
          *((_OWORD *)v119 + 2) = v107;
          long long v109 = v148;
          long long v110 = v149;
          long long v111 = v151;
          *((_OWORD *)v119 + 7) = v150;
          *((_OWORD *)v119 + 8) = v111;
          *((_OWORD *)v119 + 5) = v109;
          *((_OWORD *)v119 + 6) = v110;
        }
      }
      BOOL v65 = v105-- <= 0;
    }
    while (!v65);
  }
  uint64_t v8 = v129;
  __n128 v9 = a2;
  a3 = a2;
  unint64_t v10 = v128;
  if (a2 != v129)
  {
    if (v128 < 288)
    {
      int v11 = a2;
      do
      {
        if (((unsigned int (*)(char *, char *, char *))*a4)(v11, a1, a3))
        {
          long long v12 = *((_OWORD *)v11 + 7);
          long long v149 = *((_OWORD *)v11 + 6);
          long long v150 = v12;
          long long v151 = *((_OWORD *)v11 + 8);
          long long v13 = *((_OWORD *)v11 + 3);
          long long v145 = *((_OWORD *)v11 + 2);
          long long v146 = v13;
          long long v14 = *((_OWORD *)v11 + 5);
          long long v147 = *((_OWORD *)v11 + 4);
          long long v148 = v14;
          long long v15 = *((_OWORD *)v11 + 1);
          long long v143 = *(_OWORD *)v11;
          long long v144 = v15;
          *(_OWORD *)int v11 = *(_OWORD *)a1;
          long long v16 = *((_OWORD *)a1 + 1);
          long long v17 = *((_OWORD *)a1 + 2);
          long long v18 = *((_OWORD *)a1 + 4);
          *((_OWORD *)v11 + 3) = *((_OWORD *)a1 + 3);
          *((_OWORD *)v11 + 4) = v18;
          *((_OWORD *)v11 + 1) = v16;
          *((_OWORD *)v11 + 2) = v17;
          long long v19 = *((_OWORD *)a1 + 5);
          long long v20 = *((_OWORD *)a1 + 6);
          long long v21 = *((_OWORD *)a1 + 8);
          *((_OWORD *)v11 + 7) = *((_OWORD *)a1 + 7);
          *((_OWORD *)v11 + 8) = v21;
          *((_OWORD *)v11 + 5) = v19;
          *((_OWORD *)v11 + 6) = v20;
          long long v22 = v150;
          *((_OWORD *)a1 + 6) = v149;
          *((_OWORD *)a1 + 7) = v22;
          *((_OWORD *)a1 + 8) = v151;
          long long v23 = v146;
          *((_OWORD *)a1 + 2) = v145;
          *((_OWORD *)a1 + 3) = v23;
          long long v24 = v148;
          *((_OWORD *)a1 + 4) = v147;
          *((_OWORD *)a1 + 5) = v24;
          long long v25 = v144;
          *(_OWORD *)a1 = v143;
          *((_OWORD *)a1 + 1) = v25;
        }
        v11 += 144;
      }
      while (v11 != v129);
      a3 = v129;
      goto LABEL_32;
    }
    __n128 v26 = a1 + 144;
    while (1)
    {
      if (((unsigned int (*)(char *, char *, char *))*a4)(v9, a1, a3))
      {
        long long v33 = *((_OWORD *)v9 + 7);
        long long v149 = *((_OWORD *)v9 + 6);
        long long v150 = v33;
        long long v151 = *((_OWORD *)v9 + 8);
        long long v34 = *((_OWORD *)v9 + 3);
        long long v145 = *((_OWORD *)v9 + 2);
        long long v146 = v34;
        long long v35 = *((_OWORD *)v9 + 5);
        long long v147 = *((_OWORD *)v9 + 4);
        long long v148 = v35;
        long long v36 = *((_OWORD *)v9 + 1);
        long long v143 = *(_OWORD *)v9;
        long long v144 = v36;
        *(_OWORD *)__n128 v9 = *(_OWORD *)a1;
        long long v37 = *((_OWORD *)a1 + 1);
        long long v38 = *((_OWORD *)a1 + 2);
        long long v39 = *((_OWORD *)a1 + 4);
        *((_OWORD *)v9 + 3) = *((_OWORD *)a1 + 3);
        *((_OWORD *)v9 + 4) = v39;
        *((_OWORD *)v9 + 1) = v37;
        *((_OWORD *)v9 + 2) = v38;
        long long v40 = *((_OWORD *)a1 + 5);
        long long v41 = *((_OWORD *)a1 + 6);
        long long v42 = *((_OWORD *)a1 + 8);
        *((_OWORD *)v9 + 7) = *((_OWORD *)a1 + 7);
        *((_OWORD *)v9 + 8) = v42;
        *((_OWORD *)v9 + 5) = v40;
        *((_OWORD *)v9 + 6) = v41;
        long long v43 = v150;
        *((_OWORD *)a1 + 6) = v149;
        *((_OWORD *)a1 + 7) = v43;
        *((_OWORD *)a1 + 8) = v151;
        long long v44 = v146;
        *((_OWORD *)a1 + 2) = v145;
        *((_OWORD *)a1 + 3) = v44;
        long long v45 = v148;
        *((_OWORD *)a1 + 4) = v147;
        *((_OWORD *)a1 + 5) = v45;
        long long v46 = v144;
        *(_OWORD *)a1 = v143;
        *((_OWORD *)a1 + 1) = v46;
        if ((unint64_t)v132 < 3)
        {
          __n128 v48 = a1 + 144;
          int64_t v49 = 1;
          if ((((uint64_t (*)(char *, char *))*a4)(v26, a1) & 1) == 0) {
            goto LABEL_24;
          }
        }
        else
        {
          unsigned int v47 = (*a4)(v26, (long long *)a1 + 18);
          if (v47) {
            __n128 v48 = a1 + 288;
          }
          else {
            __n128 v48 = a1 + 144;
          }
          if (v47) {
            int64_t v49 = 2;
          }
          else {
            int64_t v49 = 1;
          }
          if ((((uint64_t (*)(char *, char *))*a4)(v48, a1) & 1) == 0)
          {
LABEL_24:
            long long v50 = *((_OWORD *)a1 + 7);
            long long v149 = *((_OWORD *)a1 + 6);
            long long v150 = v50;
            long long v151 = *((_OWORD *)a1 + 8);
            long long v51 = *((_OWORD *)a1 + 3);
            long long v145 = *((_OWORD *)a1 + 2);
            long long v146 = v51;
            long long v52 = *((_OWORD *)a1 + 5);
            long long v147 = *((_OWORD *)a1 + 4);
            long long v148 = v52;
            long long v53 = *((_OWORD *)a1 + 1);
            __n128 v54 = a1;
            long long v143 = *(_OWORD *)a1;
            long long v144 = v53;
            do
            {
              __n128 v56 = v48;
              *(_OWORD *)__n128 v54 = *(_OWORD *)v48;
              long long v57 = *((_OWORD *)v48 + 1);
              long long v58 = *((_OWORD *)v48 + 2);
              long long v59 = *((_OWORD *)v48 + 4);
              *((_OWORD *)v54 + 3) = *((_OWORD *)v48 + 3);
              *((_OWORD *)v54 + 4) = v59;
              *((_OWORD *)v54 + 1) = v57;
              *((_OWORD *)v54 + 2) = v58;
              long long v60 = *((_OWORD *)v48 + 5);
              long long v61 = *((_OWORD *)v48 + 6);
              long long v62 = *((_OWORD *)v48 + 8);
              *((_OWORD *)v54 + 7) = *((_OWORD *)v48 + 7);
              *((_OWORD *)v54 + 8) = v62;
              *((_OWORD *)v54 + 5) = v60;
              *((_OWORD *)v54 + 6) = v61;
              if ((uint64_t)((unint64_t)(v132 - 2) >> 1) < v49) {
                break;
              }
              uint64_t v63 = (2 * v49) | 1;
              __n128 v48 = &a1[144 * v63];
              if (2 * v49 + 2 < v132 && (*a4)(&a1[144 * v63], (long long *)v48 + 9))
              {
                v48 += 144;
                uint64_t v63 = 2 * v49 + 2;
              }
              unsigned int v55 = (*a4)(v48, &v143);
              __n128 v54 = v56;
              int64_t v49 = v63;
            }
            while (!v55);
            *(_OWORD *)__n128 v56 = v143;
            long long v27 = v144;
            long long v28 = v145;
            long long v29 = v147;
            *((_OWORD *)v56 + 3) = v146;
            *((_OWORD *)v56 + 4) = v29;
            *((_OWORD *)v56 + 1) = v27;
            *((_OWORD *)v56 + 2) = v28;
            long long v30 = v148;
            long long v31 = v149;
            long long v32 = v151;
            *((_OWORD *)v56 + 7) = v150;
            *((_OWORD *)v56 + 8) = v32;
            *((_OWORD *)v56 + 5) = v30;
            *((_OWORD *)v56 + 6) = v31;
            uint64_t v8 = v129;
          }
        }
      }
      v9 += 144;
      if (v9 == v8)
      {
        a3 = v8;
        __n128 v9 = a2;
        unint64_t v10 = v128;
        goto LABEL_35;
      }
    }
  }
LABEL_32:
  if (v128 >= 145)
  {
LABEL_35:
    __n128 v133 = a3;
    int64_t v64 = v10 / 0x90;
    do
    {
      __n128 v131 = v9;
      uint64_t v66 = 0;
      long long v140 = *((_OWORD *)a1 + 6);
      long long v141 = *((_OWORD *)a1 + 7);
      long long v142 = *((_OWORD *)a1 + 8);
      long long v136 = *((_OWORD *)a1 + 2);
      long long v137 = *((_OWORD *)a1 + 3);
      long long v138 = *((_OWORD *)a1 + 4);
      long long v139 = *((_OWORD *)a1 + 5);
      __n128 v67 = a1;
      long long v134 = *(_OWORD *)a1;
      long long v135 = *((_OWORD *)a1 + 1);
      do
      {
        __n128 v74 = &v67[144 * v66 + 144];
        uint64_t v75 = (2 * v66) | 1;
        uint64_t v76 = 2 * v66 + 2;
        if (v76 < v64 && (*a4)(&v67[144 * v66 + 144], (long long *)&v67[144 * v66 + 288]))
        {
          v74 += 144;
          uint64_t v75 = v76;
        }
        *(_OWORD *)__n128 v67 = *(_OWORD *)v74;
        long long v68 = *((_OWORD *)v74 + 1);
        long long v69 = *((_OWORD *)v74 + 2);
        long long v70 = *((_OWORD *)v74 + 4);
        *((_OWORD *)v67 + 3) = *((_OWORD *)v74 + 3);
        *((_OWORD *)v67 + 4) = v70;
        *((_OWORD *)v67 + 1) = v68;
        *((_OWORD *)v67 + 2) = v69;
        long long v71 = *((_OWORD *)v74 + 5);
        long long v72 = *((_OWORD *)v74 + 6);
        long long v73 = *((_OWORD *)v74 + 8);
        *((_OWORD *)v67 + 7) = *((_OWORD *)v74 + 7);
        *((_OWORD *)v67 + 8) = v73;
        *((_OWORD *)v67 + 5) = v71;
        *((_OWORD *)v67 + 6) = v72;
        __n128 v67 = v74;
        uint64_t v66 = v75;
      }
      while (v75 <= (uint64_t)((unint64_t)(v64 - 2) >> 1));
      __n128 v9 = v131 - 144;
      if (v74 == v131 - 144)
      {
        *(_OWORD *)__n128 v74 = v134;
        *((_OWORD *)v74 + 3) = v137;
        *((_OWORD *)v74 + 4) = v138;
        *((_OWORD *)v74 + 1) = v135;
        *((_OWORD *)v74 + 2) = v136;
        *((_OWORD *)v74 + 7) = v141;
        *((_OWORD *)v74 + 8) = v142;
        *((_OWORD *)v74 + 5) = v139;
        *((_OWORD *)v74 + 6) = v140;
      }
      else
      {
        *(_OWORD *)__n128 v74 = *(_OWORD *)v9;
        long long v77 = *((_OWORD *)v131 - 8);
        long long v78 = *((_OWORD *)v131 - 7);
        long long v79 = *((_OWORD *)v131 - 5);
        *((_OWORD *)v74 + 3) = *((_OWORD *)v131 - 6);
        *((_OWORD *)v74 + 4) = v79;
        *((_OWORD *)v74 + 1) = v77;
        *((_OWORD *)v74 + 2) = v78;
        long long v80 = *((_OWORD *)v131 - 4);
        long long v81 = *((_OWORD *)v131 - 3);
        long long v82 = *((_OWORD *)v131 - 1);
        *((_OWORD *)v74 + 7) = *((_OWORD *)v131 - 2);
        *((_OWORD *)v74 + 8) = v82;
        *((_OWORD *)v74 + 5) = v80;
        *((_OWORD *)v74 + 6) = v81;
        *((_OWORD *)v131 - 3) = v140;
        *((_OWORD *)v131 - 2) = v141;
        *((_OWORD *)v131 - 1) = v142;
        *((_OWORD *)v131 - 7) = v136;
        *((_OWORD *)v131 - 6) = v137;
        *((_OWORD *)v131 - 5) = v138;
        *((_OWORD *)v131 - 4) = v139;
        *(_OWORD *)__n128 v9 = v134;
        *((_OWORD *)v131 - 8) = v135;
        uint64_t v83 = v74 - a1 + 144;
        if (v83 >= 145)
        {
          unint64_t v84 = (v83 / 0x90uLL - 2) >> 1;
          __n128 v85 = &a1[144 * v84];
          if ((*a4)(v85, (long long *)v74))
          {
            long long v143 = *(_OWORD *)v74;
            long long v86 = *((_OWORD *)v74 + 1);
            long long v87 = *((_OWORD *)v74 + 2);
            long long v88 = *((_OWORD *)v74 + 4);
            long long v146 = *((_OWORD *)v74 + 3);
            long long v147 = v88;
            long long v144 = v86;
            long long v145 = v87;
            long long v89 = *((_OWORD *)v74 + 5);
            long long v90 = *((_OWORD *)v74 + 6);
            long long v91 = *((_OWORD *)v74 + 8);
            long long v150 = *((_OWORD *)v74 + 7);
            long long v151 = v91;
            long long v148 = v89;
            long long v149 = v90;
            do
            {
              __n128 v92 = v85;
              *(_OWORD *)__n128 v74 = *(_OWORD *)v85;
              long long v93 = *((_OWORD *)v85 + 1);
              long long v94 = *((_OWORD *)v85 + 2);
              long long v95 = *((_OWORD *)v85 + 4);
              *((_OWORD *)v74 + 3) = *((_OWORD *)v85 + 3);
              *((_OWORD *)v74 + 4) = v95;
              *((_OWORD *)v74 + 1) = v93;
              *((_OWORD *)v74 + 2) = v94;
              long long v96 = *((_OWORD *)v85 + 5);
              long long v97 = *((_OWORD *)v85 + 6);
              long long v98 = *((_OWORD *)v85 + 8);
              *((_OWORD *)v74 + 7) = *((_OWORD *)v85 + 7);
              *((_OWORD *)v74 + 8) = v98;
              *((_OWORD *)v74 + 5) = v96;
              *((_OWORD *)v74 + 6) = v97;
              if (!v84) {
                break;
              }
              unint64_t v84 = (v84 - 1) >> 1;
              __n128 v85 = &a1[144 * v84];
              __n128 v74 = v92;
            }
            while ((((uint64_t (*)(char *, long long *))*a4)(v85, &v143) & 1) != 0);
            long long v99 = v150;
            *((_OWORD *)v92 + 6) = v149;
            *((_OWORD *)v92 + 7) = v99;
            *((_OWORD *)v92 + 8) = v151;
            long long v100 = v146;
            *((_OWORD *)v92 + 2) = v145;
            *((_OWORD *)v92 + 3) = v100;
            long long v101 = v148;
            *((_OWORD *)v92 + 4) = v147;
            *((_OWORD *)v92 + 5) = v101;
            long long v102 = v144;
            *(_OWORD *)__n128 v92 = v143;
            *((_OWORD *)v92 + 1) = v102;
          }
        }
      }
      BOOL v65 = v64-- <= 2;
    }
    while (!v65);
    return v133;
  }
  return a3;
}

void std::deque<HGBitmap *>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    uint64_t v6 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_80:
      *(void *)uint64_t v5 = v8;
      *(void *)(a1 + 16) += 8;
      return;
    }
    __n128 v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v31 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v31 = 1;
      }
      if (!(v31 >> 61))
      {
        unint64_t v32 = v31 >> 2;
        uint64_t v33 = 8 * v31;
        long long v34 = (char *)operator new(8 * v31);
        long long v35 = &v34[8 * v32];
        long long v36 = &v34[v33];
        int64_t v38 = v5 - v7;
        BOOL v37 = v5 == v7;
        uint64_t v5 = v35;
        if (!v37)
        {
          uint64_t v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            __n128 v74 = &v34[8 * v32];
            long long v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              uint64_t v75 = (v39 >> 3) + 1;
              uint64_t v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              long long v40 = &v35[v76];
              v7 += v76;
              long long v77 = (long long *)(v6 + 3);
              long long v78 = v74 + 16;
              uint64_t v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v80 = *v77;
                *(v78 - 1) = *(v77 - 1);
                *long long v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            long long v40 = &v34[8 * v32];
          }
          do
          {
            uint64_t v81 = *(void *)v7;
            v7 += 8;
            *(void *)long long v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_78;
      }
LABEL_89:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    long long v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      v7 = *(char **)(a1 + 8);
    }
    uint64_t v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_80;
  }
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 24);
  uint64_t v19 = *(void *)(a1 + 8);
  uint64_t v20 = v18 - v19;
  uint64_t v21 = (v18 - v19) >> 3;
  uint64_t v22 = v17 - *(void *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      long long v91 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    long long v91 = operator new(0x1000uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    long long v41 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    v7 = (char *)(v41 + 1);
    uint64_t v8 = *v41;
    *(void *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24)) {
      goto LABEL_80;
    }
    __n128 v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v42 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v42 = 1;
      }
      if (!(v42 >> 61))
      {
        unint64_t v43 = v42 >> 2;
        uint64_t v44 = 8 * v42;
        long long v34 = (char *)operator new(8 * v42);
        long long v35 = &v34[8 * v43];
        long long v36 = &v34[v44];
        int64_t v45 = v5 - v7;
        BOOL v37 = v5 == v7;
        uint64_t v5 = v35;
        if (!v37)
        {
          uint64_t v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            long long v82 = &v34[8 * v43];
            unsigned int v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              uint64_t v83 = (v46 >> 3) + 1;
              uint64_t v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              unsigned int v47 = &v35[v84];
              v7 += v84;
              __n128 v85 = (long long *)(v41 + 3);
              long long v86 = v82 + 16;
              uint64_t v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v88 = *v85;
                *(v86 - 1) = *(v85 - 1);
                *long long v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            unsigned int v47 = &v34[8 * v43];
          }
          do
          {
            uint64_t v89 = *(void *)v7;
            v7 += 8;
            *(void *)unsigned int v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_78:
        *(void *)a1 = v34;
        *(void *)(a1 + 8) = v35;
        *(void *)(a1 + 16) = v5;
        *(void *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          uint64_t v5 = *(char **)(a1 + 16);
        }
        goto LABEL_80;
      }
      goto LABEL_89;
    }
    goto LABEL_5;
  }
  uint64_t v23 = v22 >> 2;
  if (v17 == *(void *)a1) {
    unint64_t v24 = 1;
  }
  else {
    unint64_t v24 = v23;
  }
  if (v24 >> 61) {
    goto LABEL_89;
  }
  long long v25 = (char *)operator new(8 * v24);
  __n128 v26 = operator new(0x1000uLL);
  long long v27 = &v25[8 * v21];
  long long v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    long long v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19) {
        unint64_t v48 = 1;
      }
      else {
        unint64_t v48 = v20 >> 2;
      }
      if (v48 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      int64_t v49 = (char *)operator new(8 * v48);
      long long v27 = &v49[8 * (v48 >> 2)];
      long long v28 = &v49[8 * v48];
      operator delete(v25);
      uint64_t v50 = *(void *)(a1 + 8);
      uint64_t v18 = *(void *)(a1 + 16);
      long long v25 = v49;
      *(void *)long long v27 = v90;
      long long v29 = v27 + 8;
      if (v18 == v50) {
        goto LABEL_45;
      }
    }
    else
    {
      unint64_t v30 = v21 + 2;
      if (v21 >= -1) {
        unint64_t v30 = v21 + 1;
      }
      v27 -= 8 * (v30 >> 1);
      *(void *)long long v27 = v26;
      long long v29 = v27 + 8;
      if (v18 == v19) {
        goto LABEL_45;
      }
    }
    do
    {
LABEL_52:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27) {
            unint64_t v59 = 1;
          }
          else {
            unint64_t v59 = (v28 - v27) >> 2;
          }
          if (v59 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          long long v60 = (char *)operator new(8 * v59);
          long long v25 = v60;
          unint64_t v61 = (v59 + 3) >> 2;
          long long v53 = &v60[8 * v61];
          int64_t v62 = v29 - v27;
          BOOL v37 = v29 == v27;
          long long v29 = v53;
          if (!v37)
          {
            long long v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v63 = v62 - 8;
            int64_t v64 = &v60[8 * v61];
            BOOL v65 = v27;
            if (v63 < 0x38) {
              goto LABEL_93;
            }
            uint64_t v66 = 8 * v61;
            int64_t v64 = &v60[8 * v61];
            BOOL v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20) {
              goto LABEL_93;
            }
            uint64_t v67 = (v63 >> 3) + 1;
            uint64_t v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            int64_t v64 = &v53[v68];
            BOOL v65 = &v27[v68];
            long long v69 = (long long *)(v27 + 16);
            long long v70 = &v60[v66 + 16];
            uint64_t v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v72 = *v69;
              *((_OWORD *)v70 - 1) = *(v69 - 1);
              *(_OWORD *)long long v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_93:
              do
              {
                uint64_t v73 = *(void *)v65;
                v65 += 8;
                *(void *)int64_t v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          long long v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          uint64_t v55 = (v28 - v29) >> 3;
          if (v55 >= -1) {
            unint64_t v56 = v55 + 1;
          }
          else {
            unint64_t v56 = v55 + 2;
          }
          long long v57 = &v29[8 * (v56 >> 1)];
          long long v53 = &v57[-(v29 - v27)];
          size_t v58 = v29 - v27;
          BOOL v37 = v29 == v27;
          long long v29 = v57;
          if (!v37) {
            memmove(v53, v27, v58);
          }
          long long v25 = v27;
        }
      }
      else
      {
        long long v53 = v27;
      }
      uint64_t v54 = *(void *)(v18 - 8);
      v18 -= 8;
      *((void *)v53 - 1) = v54;
      long long v51 = v53 - 8;
      long long v27 = v51;
    }
    while (v18 != *(void *)(a1 + 8));
    goto LABEL_46;
  }
  *(void *)long long v27 = v26;
  long long v29 = v27 + 8;
  if (v18 != v19) {
    goto LABEL_52;
  }
LABEL_45:
  long long v51 = v27;
LABEL_46:
  long long v52 = *(char **)a1;
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v51;
  *(void *)(a1 + 16) = v29;
  *(void *)(a1 + 24) = v28;
  if (v52)
  {
    operator delete(v52);
  }
}

void sub_1B777B320(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B777B33C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B777B350(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B777B368(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void HGGLShaderCache::HGGLShaderCache(HGGLShaderCache *this)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 4) = 0xFFFFFFFFLL;
  strcpy((char *)this + 104, "mediump");
  *((unsigned char *)this + 127) = 7;
  *((void *)this + 16) = 0;
  HGProfiler::HGProfiler((HGGLShaderCache *)((char *)this + 136));
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
}

void sub_1B777B404(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 127) < 0) {
    operator delete(*v2);
  }
  HGGLShaderCache::HGGLShaderCache((void **)v1);
  _Unwind_Resume(a1);
}

void HGGLShaderCache::ClearAllShaders(HGGLShaderCache *this)
{
  if (*((void *)this + 1))
  {
    unint64_t v2 = 0;
    do
    {
      uint64_t v3 = *(void *)(*(void *)this + 8 * v2);
      if (*(void *)(v3 + 120)) {
        operator new();
      }
      HGString::~HGString((HGString *)(v3 + 64));
      MEMORY[0x1BA9BFBA0](v3, 0x10B0C408CB6F79ELL);
      ++v2;
    }
    while (v2 < *((void *)this + 1));
  }
  if (*((void *)this + 2)) {
    free(*(void **)this);
  }
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
}

void HGGLShaderCache::~HGGLShaderCache(void **this)
{
  if (*((char *)this + 127) < 0) {
    operator delete(this[13]);
  }
  if (this[2]) {
    free(*this);
  }
}

double HGGLShaderCache::GetShaderCompileTime(HGGLShaderCache *this)
{
  return HGProfiler::getTime((HGGLShaderCache *)((char *)this + 136));
}

uint64_t HGGLShaderCache::ClearStats(HGGLShaderCache *this)
{
  *((void *)this + 16) = 0;
  return HGProfiler::init((uint64_t)this + 136);
}

uint64_t HGGLShaderCache::SetCapacity(HGGLShaderCache *this, uint64_t a2)
{
  *((void *)this + 4) = a2;
  return a2;
}

unint64_t HGGLShaderCache::ClearShaders(HGGLShaderCache *this, int a2)
{
  unint64_t result = *((void *)this + 1);
  if (!result) {
    return result;
  }
  for (unint64_t i = 0; i < result; ++i)
  {
    uint64_t v6 = *(void *)(*(void *)this + 8 * i);
    if (*(_DWORD *)(v6 + 112) == a2)
    {
      *(void *)(*(void *)this + 8 * i) = 0;
      if (*(void *)(v6 + 120)) {
        operator new();
      }
      HGString::~HGString((HGString *)(v6 + 64));
      MEMORY[0x1BA9BFBA0](v6, 0x10B0C408CB6F79ELL);
      unint64_t result = *((void *)this + 1);
    }
  }
  if (!result) {
    return result;
  }
  unint64_t v7 = 0;
  while (2)
  {
    uint64_t v8 = *(void *)this;
    unint64_t v9 = v7 + 1;
    if (result <= v7 + 1) {
      unint64_t v10 = v7 + 1;
    }
    else {
      unint64_t v10 = result;
    }
    if (*(void *)(v8 + 8 * v7)) {
      goto LABEL_11;
    }
    unint64_t v11 = v10 - v7;
    if (v10 - v7 == 1)
    {
      uint64_t v12 = 1;
      unint64_t v13 = result - v9;
      if (result != v9) {
        goto LABEL_26;
      }
      goto LABEL_10;
    }
    uint64_t v12 = 1;
    unint64_t v14 = v7;
    do
    {
      if (*(void *)(v8 + 8 * v7 + 8 * v12))
      {
        unint64_t v10 = v7 + v12;
        if (v12) {
          goto LABEL_25;
        }
LABEL_28:
        unint64_t v7 = v10;
        goto LABEL_11;
      }
      if (!v12) {
        unint64_t v14 = v7;
      }
      ++v12;
    }
    while (v11 != v12);
    uint64_t v12 = v10 - v7;
    if (!v11) {
      goto LABEL_28;
    }
LABEL_25:
    unint64_t v9 = v14 + v12;
    unint64_t v7 = v14;
    unint64_t v13 = result - (v14 + v12);
    if (result == v14 + v12) {
      goto LABEL_10;
    }
LABEL_26:
    memmove((void *)(v8 + 8 * v7), (const void *)(v8 + 8 * v9), 8 * v13);
    unint64_t result = *((void *)this + 1);
LABEL_10:
    result -= v12;
    *((void *)this + 1) = result;
LABEL_11:
    if (++v7 < result) {
      continue;
    }
    return result;
  }
}

uint64_t HGGLShaderCache::ResetMetal(HGGLShaderCache *this, const HGMetalContext *a2)
{
  if (a2) {
    HGMetalRenderPipelineStateCache::clear(*(HGMetalRenderPipelineStateCache **)(*((void *)a2 + 3) + 144));
  }
  unint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    for (unint64_t i = 0; i < v3; ++i)
    {
      uint64_t v5 = *(void *)(*(void *)this + 8 * i);
      uint64_t v6 = *(void *)(v5 + 120);
      if (v6 && *(_DWORD *)(v5 + 112) == 3)
      {
        uint64_t v7 = *(void *)(v5 + 120);
        uint64_t v8 = *(void *)(v6 + 32);
LABEL_10:
        uint64_t v9 = *(void *)(v7 + 8);
        if (v9)
        {
          MEMORY[0x1BA9BFBA0](v9, 0x1000C4052888210);
          --*((void *)this + 3);
          uint64_t v6 = *(void *)(v5 + 120);
        }
        *(void *)(v7 + 8) = 0;
        while (v8 != v6)
        {
          uint64_t v7 = v8;
          uint64_t v8 = *(void *)(v8 + 32);
          if (*(_DWORD *)(v5 + 112) == 3) {
            goto LABEL_10;
          }
        }
        unint64_t v3 = *((void *)this + 1);
      }
    }
  }
  if (*((void *)this + 11)) {
    operator new();
  }
  *((void *)this + 3) = HGGLShaderCache::ClearShaders(this, 3);
  uint64_t result = *((void *)this + 12);
  if (result)
  {
    uint64_t result = MEMORY[0x1BA9BFBA0](result, 0x1000C4052888210);
    *((void *)this + 12) = 0;
  }
  return result;
}

void HGGLShaderCache::ResetGLSL(HGGLShaderCache *this)
{
  unint64_t v2 = *((void *)this + 1);
  if (v2)
  {
    for (unint64_t i = 0; i < v2; ++i)
    {
      uint64_t v4 = *(void *)(*(void *)this + 8 * i);
      uint64_t v5 = *(void *)(v4 + 120);
      if (v5)
      {
        uint64_t v6 = *(void *)(v4 + 120);
        do
        {
          uint64_t v7 = *(void *)(v6 + 32);
          if ((*(_DWORD *)(v4 + 112) - 1) <= 1)
          {
            uint64_t v8 = *(void *)(v6 + 8);
            if (v8)
            {
              GLuint shaders = 0;
              glGetAttachedShaders(v8, 1, 0, &shaders);
              glDeleteShader(shaders);
              glDeleteProgram(v8);
              --*((void *)this + 3);
              uint64_t v5 = *(void *)(v4 + 120);
            }
            *(void *)(v6 + 8) = 0;
          }
          uint64_t v6 = v7;
        }
        while (v7 != v5);
        unint64_t v2 = *((void *)this + 1);
      }
    }
  }
  if (*((void *)this + 7)) {
    operator new();
  }
  if (*((void *)this + 9)) {
    operator new();
  }
  *((void *)this + 3) = HGGLShaderCache::ClearShaders(this, 1);
  *((void *)this + 3) = HGGLShaderCache::ClearShaders(this, 2);
  uint64_t v9 = *((void *)this + 8);
  if (v9)
  {
    glDeleteShader(v9);
    *((void *)this + 8) = 0;
  }
  uint64_t v10 = *((void *)this + 10);
  if (v10)
  {
    glDeleteShader(v10);
    *((void *)this + 10) = 0;
  }
}

unint64_t HGGLShaderCache::ResetARB(HGGLShaderCache *this)
{
  unint64_t v2 = *((void *)this + 1);
  if (v2)
  {
    for (unint64_t i = 0; i < v2; ++i)
    {
      uint64_t v4 = *(void *)(*(void *)this + 8 * i);
      uint64_t v5 = *(void *)(v4 + 120);
      if (v5 && !*(_DWORD *)(v4 + 112))
      {
        uint64_t v6 = *(void *)(v4 + 120);
        uint64_t v7 = *(void *)(v5 + 32);
LABEL_8:
        uint64_t v8 = *(void *)(v6 + 8);
        if (v8)
        {
          GLuint shaders = 0;
          glGetAttachedShaders(v8, 1, 0, &shaders);
          glDeleteShader(shaders);
          glDeleteProgram(v8);
          --*((void *)this + 3);
          uint64_t v5 = *(void *)(v4 + 120);
        }
        *(void *)(v6 + 8) = 0;
        while (v7 != v5)
        {
          uint64_t v6 = v7;
          uint64_t v7 = *(void *)(v7 + 32);
          if (!*(_DWORD *)(v4 + 112)) {
            goto LABEL_8;
          }
        }
        unint64_t v2 = *((void *)this + 1);
      }
    }
  }
  if (*((void *)this + 5)) {
    operator new();
  }
  unint64_t result = HGGLShaderCache::ClearShaders(this, 0);
  *((void *)this + 3) = result;
  return result;
}

void HGGLShaderCache::AddEntry(HGGLShaderCache *this, unint64_t a2, const HGString *a3, const HGString::Digest *a4)
{
}

void sub_1B777BED0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B0C408CB6F79ELL);
  _Unwind_Resume(a1);
}

uint64_t HGGLShaderCache::CreateShader(HGGLShaderCache *this, int a2)
{
  unint64_t v3 = (char *)this + 16 * a2;
  uint64_t v6 = *((void *)v3 + 6);
  uint64_t v5 = v3 + 48;
  uint64_t result = v6;
  if (v6)
  {
    *uint64_t v5 = 0;
  }
  else if (*((void *)this + 3) >= *((void *)this + 4))
  {
    uint64_t v7 = *(void *)(*((void *)this + 2 * a2 + 5) + 48);
    if (v7)
    {
      uint64_t v8 = *(void *)(v7 + 48);
      uint64_t v9 = v8;
      while (1)
      {
        uint64_t result = *(void *)(v9 + 8);
        if (result) {
          break;
        }
        uint64_t v9 = *(void *)(v9 + 48);
        if (v9 == v8) {
          return 0;
        }
      }
      *(void *)(v9 + 8) = 0;
    }
    else
    {
      return 0;
    }
  }
  else if (a2 == 1)
  {
    GLuint Program = glCreateProgram();
    GLuint Shader = glCreateShader(0x8B30u);
    glAttachShader(Program, Shader);
    uint64_t result = Program;
    ++*((void *)this + 3);
  }
  else
  {
    if (a2 == 3) {
      operator new();
    }
    uint64_t result = glCreateShader(0x8B31u);
    ++*((void *)this + 3);
  }
  return result;
}

uint64_t HGGLShaderCache::CancelShader(HGGLShaderCache *this, uint64_t program, int a3)
{
  if (program)
  {
    GLuint v3 = program;
    uint64_t v5 = (char *)this + 16 * a3;
    uint64_t v7 = *((void *)v5 + 6);
    uint64_t v6 = v5 + 48;
    if (v7)
    {
      if (a3 == 3)
      {
        MEMORY[0x1BA9BFBA0](program, 0x1000C4052888210);
      }
      else
      {
        GLuint shaders = 0;
        glGetAttachedShaders(program, 1, 0, &shaders);
        glDeleteShader(shaders);
        glDeleteProgram(v3);
      }
      --*((void *)this + 3);
    }
    else
    {
      *uint64_t v6 = program;
    }
  }
  return 0;
}

uint64_t HGGLShaderCache::CompileShader(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v31, "concat", 1, "HGGLShaderCache::CompileShader");
  if (a2 && !HGLimits::ismetal((HGLimits *)(a2 + 8))) {
    HGProfiler::start((HGProfiler *)(a1 + 136));
  }
  PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)(a2 + 32));
  GLint params = 0;
  if (!a3)
  {
    uint64_t v6 = 4294967263;
    goto LABEL_8;
  }
  if (!HGLimits::ismetal((HGLimits *)(a2 + 8)) && HGLimits::isfragment((HGLimits *)(a2 + 8)))
  {
    GLuint shaders = 0;
    if (*(char *)(a1 + 127) < 0)
    {
      int v8 = **(unsigned __int8 **)(a1 + 104);
      if (v8 == 108) {
        goto LABEL_15;
      }
    }
    else
    {
      int v8 = *(unsigned __int8 *)(a1 + 104);
      if (v8 == 108)
      {
LABEL_15:
        uint64_t v9 = 0;
LABEL_20:
        HGString::setp((HGString *)(a2 + 32), v9);
        string = (GLchar *)PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)(a2 + 32));
        GLint length = OZFactoryBase::getFactoryForSerialization((uint64_t)(a2 + 32));
        glGetAttachedShaders(a3, 1, 0, &shaders);
        glShaderSource(shaders, 1, (const GLchar *const *)&string, &length);
        glCompileShader(shaders);
        glGetShaderiv(shaders, 0x8B81u, &params);
        if (!params)
        {
          bufsize[0] = 0;
          glGetShaderiv(shaders, 0x8B84u, bufsize);
          operator new[]();
        }
        int v10 = a2[26];
        HGString::transform((HGString *)0x50610, v10, bufsize);
        Entry = HGGLShaderCache::GetEntry((HGGLShaderCache *)a1, (const HGString *)bufsize);
        HGString::~HGString((HGString *)bufsize);
        if (Entry)
        {
          uint64_t v12 = *((void *)Entry + 15);
          int v13 = Entry[29];
          if (v13 == -1)
          {
            *(void *)bufsize = 0;
            *(void *)bufsize = PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)(Entry + 16));
            GLint FactoryForSerialization = OZFactoryBase::getFactoryForSerialization((uint64_t)(Entry + 16));
            GLuint Shader = glCreateShader(0x8B31u);
            *(void *)(v12 + 8) = Shader;
            glShaderSource(Shader, 1, (const GLchar *const *)bufsize, &FactoryForSerialization);
            glCompileShader(Shader);
            glGetShaderiv(Shader, 0x8B81u, &params);
            int v13 = 0;
            GLint v15 = params;
            int v16 = params ? 0 : -48;
            Entry[29] = v16;
            if (!v15)
            {
              HGGLShaderCache::CancelShader((HGGLShaderCache *)a1, *(void *)(v12 + 8), Entry[28]);
              *(void *)(v12 + 8) = 0;
              int v13 = Entry[29];
            }
          }
          if (!v13) {
            glAttachShader(a3, *(_DWORD *)(v12 + 8));
          }
        }
        glBindAttribLocation(a3, 0, "hg_Position");
        switch(v10)
        {
          case 1:
            goto LABEL_38;
          case 2:
            goto LABEL_37;
          case 3:
            goto LABEL_36;
          case 4:
            goto LABEL_35;
          case 5:
            goto LABEL_34;
          case 6:
            goto LABEL_33;
          case 7:
            goto LABEL_32;
          case 8:
            glBindAttribLocation(a3, 0xFu, "hg_MultiTexCoord7");
LABEL_32:
            glBindAttribLocation(a3, 0xEu, "hg_MultiTexCoord6");
LABEL_33:
            glBindAttribLocation(a3, 0xDu, "hg_MultiTexCoord5");
LABEL_34:
            glBindAttribLocation(a3, 0xCu, "hg_MultiTexCoord4");
LABEL_35:
            glBindAttribLocation(a3, 0xBu, "hg_MultiTexCoord3");
LABEL_36:
            glBindAttribLocation(a3, 0xAu, "hg_MultiTexCoord2");
LABEL_37:
            glBindAttribLocation(a3, 9u, "hg_MultiTexCoord1");
LABEL_38:
            glBindAttribLocation(a3, 8u, "hg_MultiTexCoord0");
            break;
          default:
            break;
        }
        glLinkProgram(a3);
        GLint params = -1;
        glGetProgramiv(a3, 0x8B82u, &params);
        if (!params)
        {
          bufsize[0] = 0;
          glGetShaderiv(a3, 0x8B84u, bufsize);
          operator new[]();
        }
        bufsize[0] = 0;
        glGetIntegerv(0x8B8Du, bufsize);
        glUseProgram(a3);
        GLint UniformLocation = glGetUniformLocation(a3, "hg_Texture0");
        glUniform1i(UniformLocation, 0);
        GLint v18 = glGetUniformLocation(a3, "hg_Texture1");
        glUniform1i(v18, 1);
        GLint v19 = glGetUniformLocation(a3, "hg_Texture2");
        glUniform1i(v19, 2);
        GLint v20 = glGetUniformLocation(a3, "hg_Texture3");
        glUniform1i(v20, 3);
        GLint v21 = glGetUniformLocation(a3, "hg_Texture4");
        glUniform1i(v21, 4);
        GLint v22 = glGetUniformLocation(a3, "hg_Texture5");
        glUniform1i(v22, 5);
        GLint v23 = glGetUniformLocation(a3, "hg_Texture6");
        glUniform1i(v23, 6);
        GLint v24 = glGetUniformLocation(a3, "hg_Texture7");
        glUniform1i(v24, 7);
        glUseProgram(bufsize[0]);
        goto LABEL_6;
      }
    }
    if (v8 == 104) {
      uint64_t v9 = 2;
    }
    else {
      uint64_t v9 = 1;
    }
    goto LABEL_20;
  }
LABEL_6:
  uint64_t v6 = 0;
LABEL_8:
  if (a2 && !HGLimits::ismetal((HGLimits *)(a2 + 8)))
  {
    HGProfiler::stop((HGProfiler *)(a1 + 136));
    ++*(void *)(a1 + 128);
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v31);
  return v6;
}

void sub_1B777C618(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B777C62C(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B777C640(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B777C654(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B777C668(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B777C67C(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B777C690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  HGString::~HGString((HGString *)va);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v4 - 80));
  _Unwind_Resume(a1);
}

void sub_1B777C6AC(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B777C6C0(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B777C6D4(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B777C6E8(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B777C6FC(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B777C710(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B777C724(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B777C738(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B777C74C(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B777C760(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

void sub_1B777C774(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 80));
  _Unwind_Resume(a1);
}

int *HGGLShaderCache::GetEntry(HGGLShaderCache *this, const HGString *a2)
{
  HGString::digest(a2, (uint64_t)v15);
  unint64_t v4 = *((void *)this + 1);
  if (!v4) {
LABEL_28:
  }
    HGGLShaderCache::AddEntry(this, v4, a2, (const HGString::Digest *)v15);
  unint64_t v5 = *((void *)this + 1);
  uint64_t v6 = *(void *)this;
  while (1)
  {
    unint64_t v9 = v5 >> 1;
    int v10 = (int **)(v6 + 8 * (v5 >> 1));
    unint64_t v11 = *v10;
    uint64_t v12 = v15[0] - (uint64_t)**v10;
    if (!v12)
    {
      uint64_t v12 = v15[1] - (uint64_t)v11[1];
      if (!v12)
      {
        uint64_t v12 = v15[2] - (uint64_t)v11[2];
        if (!v12)
        {
          uint64_t v12 = v15[3] - (uint64_t)v11[3];
          if (!v12)
          {
            uint64_t v12 = v15[4] - (uint64_t)v11[4];
            if (!v12)
            {
              uint64_t v12 = v15[5] - (uint64_t)v11[5];
              if (!v12)
              {
                uint64_t v12 = v15[6] - (uint64_t)v11[6];
                if (!v12)
                {
                  uint64_t v12 = v15[7] - (uint64_t)v11[7];
                  if (!v12)
                  {
                    uint64_t v12 = v15[8] - (uint64_t)v11[8];
                    if (!v12)
                    {
                      uint64_t v12 = v15[9] - (uint64_t)v11[9];
                      if (!v12)
                      {
                        uint64_t v12 = v15[10] - (uint64_t)v11[10];
                        if (!v12)
                        {
                          uint64_t v12 = v15[11] - (uint64_t)v11[11];
                          if (!v12)
                          {
                            uint64_t v12 = v15[12] - (uint64_t)v11[12];
                            if (!v12)
                            {
                              uint64_t v12 = v15[13] - (uint64_t)v11[13];
                              if (!v12)
                              {
                                uint64_t v12 = v15[14] - (uint64_t)v11[14];
                                if (!v12)
                                {
                                  uint64_t v13 = v11[15];
                                  if (v16 == v13) {
                                    break;
                                  }
                                  uint64_t v12 = v16 - v13;
                                  if (!v12) {
                                    break;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    unint64_t v7 = v5 - (v9 + 1);
    if (v12 > 0)
    {
      unint64_t v8 = v9 + 1;
    }
    else
    {
      unint64_t v4 = ((uint64_t)v10 - *(void *)this) >> 3;
      unint64_t v8 = 0;
    }
    v6 += 8 * v8;
    if (v12 <= 0) {
      unint64_t v5 = v9;
    }
    else {
      unint64_t v5 = v7;
    }
    if (!v5) {
      goto LABEL_28;
    }
  }
  return *v10;
}

uint64_t HGGLShaderCache::TestShader(HGGLShaderCache *this, uint64_t a2, _OWORD *a3)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = *(unsigned int *)(a2 + 116);
  if (result == -1
    && (uint64_t v11 = *(void *)(a2 + 120),
        uint64_t Shader = HGGLShaderCache::CreateShader(this, *(_DWORD *)(a2 + 112)),
        *(void *)(v11 + 8) = Shader,
        uint64_t result = HGGLShaderCache::CompileShader((uint64_t)this, (unsigned __int16 *)a2, Shader),
        (*(_DWORD *)(a2 + 116) = result) != 0))
  {
    uint64_t v13 = *(void *)(v11 + 8);
    if (v13)
    {
      uint64_t v14 = *(int *)(a2 + 112);
      GLint v15 = (char *)this + 16 * v14;
      uint64_t v17 = *((void *)v15 + 6);
      int v16 = v15 + 48;
      if (v17)
      {
        if (v14 == 3)
        {
          MEMORY[0x1BA9BFBA0](*(void *)(v11 + 8), 0x1000C4052888210);
        }
        else
        {
          GLuint shaders = 0;
          glGetAttachedShaders(v13, 1, 0, &shaders);
          glDeleteShader(shaders);
          glDeleteProgram(v13);
        }
        --*((void *)this + 3);
      }
      else
      {
        void *v16 = v13;
      }
    }
    *(void *)(v11 + 8) = 0;
  }
  else
  {
    if (!a3) {
      return result;
    }
    unint64_t v7 = (long long *)(a2 + 128);
    if (!*(_DWORD *)(a2 + 128))
    {
      long long v8 = *(_OWORD *)(a2 + 32);
      long long *v7 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(a2 + 144) = v8;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)(a2 + 48);
    }
    long long v9 = *v7;
    long long v10 = *(_OWORD *)(a2 + 160);
    a3[1] = *(_OWORD *)(a2 + 144);
    a3[2] = v10;
    *a3 = v9;
  }
  return *(unsigned int *)(a2 + 116);
}

uint64_t HGGLShaderCache::TestShader(HGGLShaderCache *a1, HGString *this, _OWORD *a3, void *a4)
{
  HGString::digest(this, (uint64_t)v31);
  unint64_t v8 = *((void *)a1 + 1);
  if (!v8) {
LABEL_28:
  }
    HGGLShaderCache::AddEntry(a1, v8, this, (const HGString::Digest *)v31);
  unint64_t v9 = *((void *)a1 + 1);
  uint64_t v10 = *(void *)a1;
  while (1)
  {
    unint64_t v13 = v9 >> 1;
    uint64_t v14 = (int **)(v10 + 8 * (v9 >> 1));
    uint64_t v15 = (uint64_t)*v14;
    uint64_t v16 = v31[0] - (uint64_t)**v14;
    if (!v16)
    {
      uint64_t v16 = v31[1] - (uint64_t)*(int *)(v15 + 4);
      if (!v16)
      {
        uint64_t v16 = v31[2] - (uint64_t)*(int *)(v15 + 8);
        if (!v16)
        {
          uint64_t v16 = v31[3] - (uint64_t)*(int *)(v15 + 12);
          if (!v16)
          {
            uint64_t v16 = v31[4] - (uint64_t)*(int *)(v15 + 16);
            if (!v16)
            {
              uint64_t v16 = v31[5] - (uint64_t)*(int *)(v15 + 20);
              if (!v16)
              {
                uint64_t v16 = v31[6] - (uint64_t)*(int *)(v15 + 24);
                if (!v16)
                {
                  uint64_t v16 = v31[7] - (uint64_t)*(int *)(v15 + 28);
                  if (!v16)
                  {
                    uint64_t v16 = v31[8] - (uint64_t)*(int *)(v15 + 32);
                    if (!v16)
                    {
                      uint64_t v16 = v31[9] - (uint64_t)*(int *)(v15 + 36);
                      if (!v16)
                      {
                        uint64_t v16 = v31[10] - (uint64_t)*(int *)(v15 + 40);
                        if (!v16)
                        {
                          uint64_t v16 = v31[11] - (uint64_t)*(int *)(v15 + 44);
                          if (!v16)
                          {
                            uint64_t v16 = v31[12] - (uint64_t)*(int *)(v15 + 48);
                            if (!v16)
                            {
                              uint64_t v16 = v31[13] - (uint64_t)*(int *)(v15 + 52);
                              if (!v16)
                              {
                                uint64_t v16 = v31[14] - (uint64_t)*(int *)(v15 + 56);
                                if (!v16)
                                {
                                  uint64_t v17 = *(int *)(v15 + 60);
                                  if (v32 == v17) {
                                    break;
                                  }
                                  uint64_t v16 = v32 - v17;
                                  if (!v16) {
                                    break;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    unint64_t v11 = v9 - (v13 + 1);
    if (v16 > 0)
    {
      unint64_t v12 = v13 + 1;
    }
    else
    {
      unint64_t v8 = ((uint64_t)v14 - *(void *)a1) >> 3;
      unint64_t v12 = 0;
    }
    v10 += 8 * v12;
    if (v16 <= 0) {
      unint64_t v9 = v13;
    }
    else {
      unint64_t v9 = v11;
    }
    if (!v9) {
      goto LABEL_28;
    }
  }
  uint64_t v18 = *(void *)(v15 + 120);
  if (*(_DWORD *)(v15 + 116) == -1
    && (uint64_t Shader = HGGLShaderCache::CreateShader(a1, *(_DWORD *)(v15 + 112)),
        *(void *)(v18 + 8) = Shader,
        int v24 = HGGLShaderCache::CompileShader((uint64_t)a1, (unsigned __int16 *)v15, Shader),
        (*(_DWORD *)(v15 + 116) = v24) != 0))
  {
    uint64_t v25 = *(void *)(v18 + 8);
    if (v25)
    {
      uint64_t v26 = *(int *)(v15 + 112);
      long long v27 = (void *)((char *)a1 + 16 * v26);
      uint64_t v29 = v27[6];
      long long v28 = v27 + 6;
      if (v29)
      {
        if (v26 == 3)
        {
          MEMORY[0x1BA9BFBA0](*(void *)(v18 + 8), 0x1000C4052888210);
        }
        else
        {
          GLuint shaders = 0;
          glGetAttachedShaders(v25, 1, 0, &shaders);
          glDeleteShader(shaders);
          glDeleteProgram(v25);
        }
        --*((void *)a1 + 3);
      }
      else
      {
        *long long v28 = v25;
      }
    }
    *(void *)(v18 + 8) = 0;
  }
  else
  {
    if (a3)
    {
      GLint v19 = (long long *)(v15 + 128);
      if (!*(_DWORD *)(v15 + 128))
      {
        long long v20 = *(_OWORD *)(v15 + 32);
        *GLint v19 = *(_OWORD *)(v15 + 16);
        *(_OWORD *)(v15 + 144) = v20;
        *(_OWORD *)(v15 + 160) = *(_OWORD *)(v15 + 48);
      }
      long long v21 = *v19;
      long long v22 = *(_OWORD *)(v15 + 160);
      a3[1] = *(_OWORD *)(v15 + 144);
      a3[2] = v22;
      *a3 = v21;
    }
    if (a4) {
      *a4 = v15;
    }
  }
  return *(unsigned int *)(v15 + 116);
}

uint64_t HGGLShaderCache::TestShader(HGGLShaderCache *a1, int *a2, _OWORD *a3, uint64_t *a4)
{
  unint64_t v4 = *((void *)a1 + 1);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = *(void *)a1;
  while (1)
  {
    unint64_t v10 = v4 >> 1;
    uint64_t v11 = cmp(a2, *(int **)(v9 + 8 * (v4 >> 1)));
    if (!v11) {
      break;
    }
    if (v11 > 0) {
      unint64_t v12 = v10 + 1;
    }
    else {
      unint64_t v12 = 0;
    }
    v9 += 8 * v12;
    if (v11 <= 0) {
      v4 >>= 1;
    }
    else {
      v4 -= v10 + 1;
    }
    if (!v4) {
      return 0xFFFFFFFFLL;
    }
  }
  uint64_t v13 = *(void *)(v9 + 8 * v10);
  if (!v13) {
    return 0xFFFFFFFFLL;
  }
  if (a4) {
    *a4 = v13;
  }

  return HGGLShaderCache::TestShader(a1, v13, a3);
}

int *HGGLShaderCache::GetEntry(HGGLShaderCache *this, const char *a2)
{
  HGString::HGString((HGString *)v16, a2, 0, 0xFFu);
  HGString::digest((HGString *)v16, (uint64_t)v14);
  unint64_t v3 = *((void *)this + 1);
  if (!v3) {
LABEL_28:
  }
    HGGLShaderCache::AddEntry(this, v3, (const HGString *)v16, (const HGString::Digest *)v14);
  unint64_t v4 = *((void *)this + 1);
  uint64_t v5 = *(void *)this;
  while (1)
  {
    unint64_t v8 = v4 >> 1;
    uint64_t v9 = (int **)(v5 + 8 * (v4 >> 1));
    unint64_t v10 = *v9;
    uint64_t v11 = v14[0] - (uint64_t)**v9;
    if (!v11)
    {
      uint64_t v11 = v14[1] - (uint64_t)v10[1];
      if (!v11)
      {
        uint64_t v11 = v14[2] - (uint64_t)v10[2];
        if (!v11)
        {
          uint64_t v11 = v14[3] - (uint64_t)v10[3];
          if (!v11)
          {
            uint64_t v11 = v14[4] - (uint64_t)v10[4];
            if (!v11)
            {
              uint64_t v11 = v14[5] - (uint64_t)v10[5];
              if (!v11)
              {
                uint64_t v11 = v14[6] - (uint64_t)v10[6];
                if (!v11)
                {
                  uint64_t v11 = v14[7] - (uint64_t)v10[7];
                  if (!v11)
                  {
                    uint64_t v11 = v14[8] - (uint64_t)v10[8];
                    if (!v11)
                    {
                      uint64_t v11 = v14[9] - (uint64_t)v10[9];
                      if (!v11)
                      {
                        uint64_t v11 = v14[10] - (uint64_t)v10[10];
                        if (!v11)
                        {
                          uint64_t v11 = v14[11] - (uint64_t)v10[11];
                          if (!v11)
                          {
                            uint64_t v11 = v14[12] - (uint64_t)v10[12];
                            if (!v11)
                            {
                              uint64_t v11 = v14[13] - (uint64_t)v10[13];
                              if (!v11)
                              {
                                uint64_t v11 = v14[14] - (uint64_t)v10[14];
                                if (!v11)
                                {
                                  uint64_t v12 = v10[15];
                                  if (v15 == v12) {
                                    break;
                                  }
                                  uint64_t v11 = v15 - v12;
                                  if (!v11) {
                                    break;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    unint64_t v6 = v4 - (v8 + 1);
    if (v11 > 0)
    {
      unint64_t v7 = v8 + 1;
    }
    else
    {
      unint64_t v3 = ((uint64_t)v9 - *(void *)this) >> 3;
      unint64_t v7 = 0;
    }
    v5 += 8 * v7;
    if (v11 <= 0) {
      unint64_t v4 = v8;
    }
    else {
      unint64_t v4 = v6;
    }
    if (!v4) {
      goto LABEL_28;
    }
  }
  HGString::~HGString((HGString *)v16);
  return v10;
}

void sub_1B777D0E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  HGString::~HGString((HGString *)va);
  _Unwind_Resume(a1);
}

void sub_1B777D0FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  HGString::~HGString((HGString *)va);
  _Unwind_Resume(a1);
}

uint64_t HGGLShaderCache::Enable(HGGLShaderCache *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = *(unsigned int *)(a2 + 116);
  if ((int)result >= -1)
  {
    uint64_t v7 = *(void *)(a2 + 120);
    uint64_t v8 = v7;
    while (*(void *)(v8 + 16) != a4)
    {
      uint64_t v8 = *(void *)(v8 + 24);
      if (v8 == v7 || v8 == 0)
      {
        uint64_t v8 = *(void *)(v7 + 40);
        if ((unint64_t)(a3 - *(void *)v8) <= 1 && *((void *)a1 + 3) < *((void *)a1 + 4)) {
          operator new();
        }
        *(void *)(v8 + 16) = a4;
        *(void *)(a2 + 120) = *(void *)(v7 + 40);
        *(void *)uint64_t v8 = a3;
        if (!*(void *)(v8 + 8)) {
          goto LABEL_22;
        }
LABEL_37:
        if (!HGLimits::ismetal((HGLimits *)(a2 + 16))) {
          glUseProgram(*(_DWORD *)(v8 + 8));
        }
        return *(unsigned int *)(a2 + 116);
      }
    }
    if (*(void *)(v8 + 8))
    {
      if (v7 != v8)
      {
        *(void *)(*(void *)(v8 + 40) + 24) = *(void *)(v8 + 24);
        *(void *)(*(void *)(v8 + 24) + 40) = *(void *)(v8 + 40);
        *(void *)(v8 + 40) = *(void *)(*(void *)(a2 + 120) + 40);
        *(void *)(*(void *)(*(void *)(a2 + 120) + 40) + 24) = v8;
        *(void *)(v8 + 24) = *(void *)(a2 + 120);
        *(void *)(*(void *)(a2 + 120) + 40) = v8;
        *(void *)(a2 + 120) = v8;
      }
      unint64_t v10 = (void *)((char *)a1 + 16 * *(int *)(a2 + 112));
      uint64_t v12 = v10[5];
      uint64_t v11 = v10 + 5;
      if (v12 != v8)
      {
        *(void *)(*(void *)(v8 + 48) + 32) = *(void *)(v8 + 32);
        *(void *)(*(void *)(v8 + 32) + 48) = *(void *)(v8 + 48);
        *(void *)(v8 + 48) = *(void *)(*v11 + 48);
        *(void *)(*(void *)(*v11 + 48) + 32) = v8;
        *(void *)(v8 + 32) = *v11;
        *(void *)(*v11 + 48) = v8;
        void *v11 = v8;
      }
    }
    *(void *)uint64_t v8 = a3;
    if (*(void *)(v8 + 8)) {
      goto LABEL_37;
    }
LABEL_22:
    if (*(_DWORD *)(a2 + 116) != -1)
    {
      uint64_t v13 = *(void **)(*(void *)(a2 + 120) + 40);
      if ((unint64_t)(a3 - *v13) >= 2 && (uint64_t v14 = v13[1]) != 0)
      {
        int v15 = v13 + 1;
      }
      else
      {
        if (*((void *)a1 + 3) < *((void *)a1 + 4))
        {
          uint64_t Shader = HGGLShaderCache::CreateShader(a1, *(_DWORD *)(a2 + 112));
          *(void *)(v8 + 8) = Shader;
          if (HGGLShaderCache::CompileShader((uint64_t)a1, (unsigned __int16 *)a2, Shader) == *(_DWORD *)(a2 + 116)) {
            goto LABEL_36;
          }
          HGGLShaderCache::CancelShader(a1, *(void *)(v8 + 8), *(_DWORD *)(a2 + 112));
          uint64_t v13 = *(void **)(*(void *)(a2 + 120) + 40);
        }
        uint64_t v17 = v13[1];
        int v15 = v13 + 1;
        uint64_t v14 = v17;
      }
      *(void *)(v8 + 8) = v14;
      *int v15 = 0;
LABEL_36:
      if (!*(void *)(v8 + 8)) {
        return *(unsigned int *)(a2 + 116);
      }
      goto LABEL_37;
    }
    uint64_t v18 = HGGLShaderCache::CreateShader(a1, *(_DWORD *)(a2 + 112));
    *(void *)(v8 + 8) = v18;
    int v19 = HGGLShaderCache::CompileShader((uint64_t)a1, (unsigned __int16 *)a2, v18);
    *(_DWORD *)(a2 + 116) = v19;
    if (!v19) {
      goto LABEL_36;
    }
    uint64_t v20 = *(void *)(v8 + 8);
    if (v20)
    {
      uint64_t v21 = *(int *)(a2 + 112);
      long long v22 = (void *)((char *)a1 + 16 * v21);
      uint64_t v24 = v22[6];
      GLint v23 = v22 + 6;
      if (!v24)
      {
        *GLint v23 = v20;
        *(void *)(v8 + 8) = 0;
        return *(unsigned int *)(a2 + 116);
      }
      if (v21 == 3)
      {
        MEMORY[0x1BA9BFBA0](*(void *)(v8 + 8), 0x1000C4052888210);
      }
      else
      {
        GLuint shaders = 0;
        glGetAttachedShaders(v20, 1, 0, &shaders);
        glDeleteShader(shaders);
        glDeleteProgram(v20);
      }
      --*((void *)a1 + 3);
    }
    *(void *)(v8 + 8) = 0;
    return *(unsigned int *)(a2 + 116);
  }
  return result;
}

void HGGLShaderCache::DisableEntry(uint64_t a1, uint64_t a2, int a3)
{
  if (a2) {
    *(_DWORD *)(a2 + 116) = a3;
  }
}

std::string *HGGLShaderCache::SetPrecisionKeyword(uint64_t a1, const std::string *a2)
{
  return std::string::operator=((std::string *)(a1 + 104), a2);
}

uint64_t cmp(int *a1, int *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *a2;
  uint64_t result = v3 - v4;
  if (v3 == v4)
  {
    uint64_t v6 = a1[1];
    uint64_t v7 = a2[1];
    uint64_t result = v6 - v7;
    if (v6 == v7)
    {
      uint64_t v8 = a1[2];
      uint64_t v9 = a2[2];
      uint64_t result = v8 - v9;
      if (v8 == v9)
      {
        uint64_t v10 = a1[3];
        uint64_t v11 = a2[3];
        uint64_t result = v10 - v11;
        if (v10 == v11)
        {
          uint64_t v12 = a1[4];
          uint64_t v13 = a2[4];
          uint64_t result = v12 - v13;
          if (v12 == v13)
          {
            uint64_t v14 = a1[5];
            uint64_t v15 = a2[5];
            uint64_t result = v14 - v15;
            if (v14 == v15)
            {
              uint64_t v16 = a1[6];
              uint64_t v17 = a2[6];
              uint64_t result = v16 - v17;
              if (v16 == v17)
              {
                uint64_t v18 = a1[7];
                uint64_t v19 = a2[7];
                uint64_t result = v18 - v19;
                if (v18 == v19)
                {
                  uint64_t v20 = a1[8];
                  uint64_t v21 = a2[8];
                  uint64_t result = v20 - v21;
                  if (v20 == v21)
                  {
                    uint64_t v22 = a1[9];
                    uint64_t v23 = a2[9];
                    uint64_t result = v22 - v23;
                    if (v22 == v23)
                    {
                      uint64_t v24 = a1[10];
                      uint64_t v25 = a2[10];
                      uint64_t result = v24 - v25;
                      if (v24 == v25)
                      {
                        uint64_t v26 = a1[11];
                        uint64_t v27 = a2[11];
                        uint64_t result = v26 - v27;
                        if (v26 == v27)
                        {
                          uint64_t v28 = a1[12];
                          uint64_t v29 = a2[12];
                          uint64_t result = v28 - v29;
                          if (v28 == v29)
                          {
                            uint64_t v30 = a1[13];
                            uint64_t v31 = a2[13];
                            uint64_t result = v30 - v31;
                            if (v30 == v31)
                            {
                              uint64_t v32 = a1[14];
                              uint64_t v33 = a2[14];
                              uint64_t result = v32 - v33;
                              if (v32 == v33)
                              {
                                uint64_t v34 = a1[15];
                                uint64_t v35 = a2[15];
                                if (v34 == v35) {
                                  return 0;
                                }
                                else {
                                  return v34 - v35;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void OUTLINED_FUNCTION_0_2(void **a1)
{
}

void HGGLShaderCache::HGGLShaderCache(void **a1)
{
  if (a1[2]) {
    OUTLINED_FUNCTION_0_2(a1);
  }
}

void HFGrabCut::HFGrabCut(HFGrabCut *this)
{
  *(void *)this = &unk_1F10D4870;
  *((void *)this + 1) = 0;
  *((unsigned char *)this + 16) = 1;
  *((_DWORD *)this + 5) = 0;
  *((_DWORD *)this + 6) = 0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
}

HFGrabCut *HFGrabCut::Reset(HFGrabCut *this)
{
  *((unsigned char *)this + 16) = 1;
  return this;
}

void HFGrabCut::~HFGrabCut(HFGrabCut *this, void *a2)
{
  *(void *)this = &unk_1F10D4870;
  *((unsigned char *)this + 16) = 1;
  uint64_t v3 = (HGMemory *)*((void *)this + 4);
  if (v3)
  {
    HGMemory::release(v3, a2);
    *((void *)this + 4) = 0;
  }
  uint64_t v4 = (HGMemory *)*((void *)this + 5);
  if (v4)
  {
    HGMemory::release(v4, a2);
    *((void *)this + 5) = 0;
  }
  uint64_t v5 = (HGMemory *)*((void *)this + 6);
  if (v5)
  {
    HGMemory::release(v5, a2);
    *((void *)this + 6) = 0;
  }
}

{
  HGMemory *v3;
  HGMemory *v4;
  HGMemory *v5;
  uint64_t vars8;

  *(void *)this = &unk_1F10D4870;
  *((unsigned char *)this + 16) = 1;
  uint64_t v3 = (HGMemory *)*((void *)this + 4);
  if (v3)
  {
    HGMemory::release(v3, a2);
    *((void *)this + 4) = 0;
  }
  uint64_t v4 = (HGMemory *)*((void *)this + 5);
  if (v4)
  {
    HGMemory::release(v4, a2);
    *((void *)this + 5) = 0;
  }
  uint64_t v5 = (HGMemory *)*((void *)this + 6);
  if (v5)
  {
    HGMemory::release(v5, a2);
    *((void *)this + 6) = 0;
  }

  JUMPOUT(0x1BA9BFBA0);
}

HFGrabCut *HFGrabCut::InitDataModels(HFGrabCut *this, HGBitmap *a2, HGBitmap *a3, unint64_t a4)
{
  unint64_t v4 = (*((_DWORD *)a2 + 7) - *((_DWORD *)a2 + 5));
  if (v4 == *((_DWORD *)a3 + 7) - *((_DWORD *)a3 + 5))
  {
    uint64_t v5 = (unint64_t *)(*((_DWORD *)a2 + 8) - *((_DWORD *)a2 + 6));
    if (v5 == *((_DWORD *)a3 + 8) - *((_DWORD *)a3 + 6)
      && (*((_DWORD *)a2 + 4) - 23) <= 1
      && *((_DWORD *)a3 + 4) == 1)
    {
      uint64_t v7 = this;
      if (*((_DWORD *)this + 6) * *((_DWORD *)this + 5) < (v5 * v4))
      {
        *((_DWORD *)this + 5) = (v4 + 31) & 0xFFFFFFE0;
        *((_DWORD *)this + 6) = (v5 + 31) & 0xFFFFFFE0;
        uint64_t v8 = (HGMemory *)*((void *)this + 4);
        if (v8)
        {
          HGMemory::release(v8, a2);
          *((void *)v7 + 4) = 0;
        }
        uint64_t v9 = (HGMemory *)*((void *)v7 + 5);
        if (v9)
        {
          HGMemory::release(v9, a2);
          *((void *)v7 + 5) = 0;
        }
        uint64_t v10 = (HGMemory *)*((void *)v7 + 6);
        if (v10)
        {
          HGMemory::release(v10, a2);
          *((void *)v7 + 6) = 0;
        }
        unsigned int v11 = *((_DWORD *)v7 + 5) * HGFormatUtils::bytesPerPixel(13);
        unsigned int v12 = *((_DWORD *)v7 + 5) * HGFormatUtils::bytesPerPixel(28);
        unsigned int v13 = *((_DWORD *)v7 + 5) * HGFormatUtils::bytesPerPixel(1);
        *((void *)v7 + 4) = HGMemory::allocate((HGMemory *)(*((unsigned int *)v7 + 6) * (unint64_t)v11), 0, v14);
        *((void *)v7 + 5) = HGMemory::allocate((HGMemory *)(*((unsigned int *)v7 + 6) * (unint64_t)v12), 0, v15);
        *((void *)v7 + 6) = HGMemory::allocate((HGMemory *)(*((unsigned int *)v7 + 6) * (unint64_t)v13), 0, v16);
      }
      uint64_t v17 = (soKMeansClassifier *)*((void *)v7 + 1);
      if (!v17) {
        operator new();
      }
      return (HFGrabCut *)soKMeansClassifier::Init(v17, (void *)v4, v5, a4, 1);
    }
  }
  return this;
}

void sub_1B777D8CC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B0C40BA4AE0DALL);
  _Unwind_Resume(a1);
}

void SetupEdges(HGBitmap *a1, HGBitmap *a2, float a3)
{
  int v3 = *((_DWORD *)a1 + 6);
  int v4 = *((_DWORD *)a1 + 8);
  uint64_t v5 = (v4 - v3);
  if (v4 == v3) {
    return;
  }
  int v7 = *((_DWORD *)a1 + 7);
  int v8 = *((_DWORD *)a1 + 5);
  float v9 = 0.0;
  unint64_t v10 = (v7 - v8);
  if (v7 == v8) {
    goto LABEL_22;
  }
  int v11 = 0;
  int v12 = 0;
  unsigned int v13 = (unsigned __int8 *)*((void *)a1 + 10);
  int v14 = v7 + ~v8;
  float v15 = 0.0;
  uint64_t v16 = v13;
  do
  {
    if (v11)
    {
      int v17 = *v16;
      int v18 = v16[1];
      float v19 = (float)(v18 - v13[1]);
      int v20 = v16[2];
      float v15 = v15
          + (float)((float)((float)((float)(v17 - *v13) * (float)(v17 - *v13)) + (float)(v19 * v19))
                  + (float)((float)(v20 - v13[2]) * (float)(v20 - v13[2])));
      if (v10 >= 2)
      {
        float v26 = (float)(v17 - v13[4]);
        float v27 = (float)(v18 - v13[5]);
        float v28 = (float)(v20 - v13[6]);
        float v15 = v15 + (float)((float)((float)(v26 * v26) + (float)(v27 * v27)) + (float)(v28 * v28));
        v12 += 2;
      }
      else
      {
        ++v12;
        if (v10 == 1) {
          goto LABEL_4;
        }
      }
      int v29 = 0;
      unint64_t v30 = 1;
      do
      {
        while (1)
        {
          uint64_t v34 = (v29 + 4);
          int v35 = v16[v34];
          float v36 = (float)(v35 - v16[v29]);
          uint64_t v37 = (v29 + 5);
          int v38 = v16[v37];
          uint64_t v39 = v29 + 1;
          float v40 = (float)(v38 - v16[v39]);
          ++v30;
          uint64_t v41 = (v29 + 6);
          int v42 = v16[v41];
          uint64_t v43 = v29 + 2;
          float v44 = v15
              + (float)((float)((float)(v36 * v36) + (float)(v40 * v40))
                      + (float)((float)(v42 - v16[v43]) * (float)(v42 - v16[v43])));
          float v45 = (float)(v35 - v13[v29]);
          float v46 = (float)(v38 - v13[v39]);
          float v47 = (float)(v42 - v13[v43]);
          float v48 = (float)((float)(v45 * v45) + (float)(v46 * v46)) + (float)(v47 * v47);
          float v49 = (float)(v35 - v13[v34]);
          float v50 = v44 + v48;
          float v51 = (float)(v38 - v13[v37]);
          float v15 = v50
              + (float)((float)((float)(v49 * v49) + (float)(v51 * v51))
                      + (float)((float)(v42 - v13[v41]) * (float)(v42 - v13[v41])));
          if (v30 >= v10) {
            break;
          }
          float v31 = (float)(v35 - v13[v29 + 8]);
          int v32 = v38 - v13[v29 + 9];
          float v33 = (float)(v42 - v13[v29 + 10]);
          float v15 = v15 + (float)((float)((float)(v31 * v31) + (float)((float)v32 * (float)v32)) + (float)(v33 * v33));
          v12 += 4;
          v29 += 4;
          if (v10 == v30) {
            goto LABEL_4;
          }
        }
        v12 += 3;
        v29 += 4;
      }
      while (v10 != v30);
    }
    else if (v10 != 1)
    {
      unsigned int v21 = 6;
      unint64_t v22 = v10 - 1;
      do
      {
        float v23 = (float)(v16[v21 - 2] - v16[v21 - 6]);
        float v24 = (float)(v16[v21 - 1] - v16[v21 - 5]);
        float v25 = (float)(v16[v21] - v16[v21 - 4]);
        float v15 = v15 + (float)((float)((float)(v23 * v23) + (float)(v24 * v24)) + (float)(v25 * v25));
        v21 += 4;
        --v22;
      }
      while (v22);
      v12 += v14;
    }
LABEL_4:
    unsigned int v13 = v16;
    v16 += *((void *)a1 + 8);
    ++v11;
  }
  while (v11 != v5);
  if (v12)
  {
    float v52 = 1.0 / (float)v12;
    float v9 = 0.0;
    if (v15 > 0.00000011921) {
      goto LABEL_21;
    }
  }
  else
  {
    float v52 = 1.0;
    float v9 = 0.0;
    if (v15 > 0.00000011921) {
LABEL_21:
    }
      float v9 = 1.0 / (float)((float)(v15 + v15) * v52);
  }
LABEL_22:
  unint64_t v90 = (*((_DWORD *)a1 + 7) - *((_DWORD *)a1 + 5));
  if (v90)
  {
    uint64_t v53 = 0;
    uint64_t v86 = *((void *)a2 + 8);
    uint64_t v87 = *((void *)a2 + 10);
    float v54 = -v9;
    uint64_t v85 = *((void *)a1 + 8);
    uint64_t v55 = (unsigned __int8 *)*((void *)a1 + 10);
    unint64_t v56 = v55;
    uint64_t v88 = v5;
    do
    {
      uint64_t v57 = v87 + v86 * v53;
      *(void *)uint64_t v57 = 0;
      uint64_t v89 = v53;
      if (v53)
      {
        int v58 = *v56 - *v55;
        int v59 = v56[1] - v55[1];
        float v60 = (float)(v56[2] - v55[2]);
        *(float *)(v57 + 8) = expf((float)((float)((float)((float)v58 * (float)v58) + (float)((float)v59 * (float)v59))+ (float)(v60 * v60))* v54)* a3;
        if (v90 >= 2)
        {
          float v61 = (float)(*v56 - v55[4]);
          float v62 = (float)(v56[1] - v55[5]);
          float v63 = (float)(v56[2] - v55[6]);
          *(float *)(v57 + 12) = (float)(expf((float)((float)((float)(v61 * v61) + (float)(v62 * v62)) + (float)(v63 * v63))* v54)* a3)* 0.70711;
LABEL_31:
          int v64 = 0;
          unint64_t v65 = 1;
          do
          {
            uint64_t v67 = (v64 + 4);
            uint64_t v68 = v64;
            float v69 = (float)(v56[v67] - v56[v64]);
            uint64_t v70 = (v64 + 5);
            ++v65;
            uint64_t v71 = v64 + 1;
            float v72 = (float)(v56[v70] - v56[v71]);
            uint64_t v73 = (v64 + 6);
            uint64_t v74 = v64 + 2;
            float v75 = (float)(v56[v73] - v56[v74]);
            *(float *)(v57 + 4 * v67) = expf((float)((float)((float)(v69 * v69) + (float)(v72 * v72))+ (float)(v75 * v75))* v54)* a3;
            if (v89)
            {
              float v76 = (float)(v56[v67] - v55[v68]);
              float v77 = (float)(v56[v70] - v55[v71]);
              float v78 = (float)(v56[v73] - v55[v74]);
              *(float *)(v57 + 4 * v70) = (float)(expf((float)((float)((float)(v76 * v76) + (float)(v77 * v77))+ (float)(v78 * v78))* v54)* a3)* 0.70711;
              float v79 = (float)(v56[v67] - v55[v67]);
              float v80 = (float)(v56[v70] - v55[v70]);
              float v81 = (float)(v56[v73] - v55[v73]);
              *(float *)(v57 + 4 * v73) = expf((float)((float)((float)(v79 * v79) + (float)(v80 * v80)) + (float)(v81 * v81))* v54)* a3;
              float v66 = 0.0;
              if (v65 < v90)
              {
                float v82 = (float)(v56[v67] - v55[(v68 + 8)]);
                float v83 = (float)(v56[v70] - v55[(v68 + 9)]);
                float v84 = (float)(v56[v73] - v55[(v68 + 10)]);
                float v66 = (float)(expf((float)((float)((float)(v82 * v82) + (float)(v83 * v83)) + (float)(v84 * v84)) * v54)
                            * a3)
                    * 0.70711;
              }
            }
            else
            {
              *(void *)(v57 + 4 * v70) = 0;
              float v66 = 0.0;
            }
            *(float *)(v57 + 4 * (v68 + 7)) = v66;
            int v64 = v68 + 4;
          }
          while (v90 != v65);
          goto LABEL_25;
        }
      }
      else
      {
        *(_DWORD *)(v57 + 8) = 0;
      }
      *(_DWORD *)(v57 + 12) = 0;
      if (v90 != 1) {
        goto LABEL_31;
      }
LABEL_25:
      uint64_t v55 = v56;
      v56 += v85;
      uint64_t v53 = v89 + 1;
    }
    while (v89 + 1 != v88);
  }
}

soMaxFlow *SetupGraph(soMaxFlow *this, HGBitmap *a2, HGBitmap *a3, HGBitmap *a4, float a5)
{
  uint64_t v16 = (*((_DWORD *)a2 + 8) - *((_DWORD *)a2 + 6));
  if (v16)
  {
    uint64_t v15 = (*((_DWORD *)a2 + 7) - *((_DWORD *)a2 + 5));
    if (v15)
    {
      uint64_t v5 = this;
      for (uint64_t i = 0; i != v16; ++i)
      {
        int v7 = (float *)(*((void *)a4 + 10) + *((void *)a4 + 8) * i);
        uint64_t v8 = *((void *)a3 + 10) + *((void *)a3 + 8) * i;
        int v9 = -1;
        unsigned int v10 = 3;
        uint64_t v11 = v15;
        do
        {
          float v12 = *v7;
          float v13 = v7[1];
          v7 += 2;
          soMaxFlow::SetNodeWeights(v5, v9 + 1, i, v12, v13);
          soMaxFlow::SetEdgeCapacity((uint64_t)v5, 0, v9 + 1, i, *(float *)(v8 + 4 * (v10 - 3)));
          soMaxFlow::SetEdgeCapacity((uint64_t)v5, 4, v9, i, *(float *)(v8 + 4 * (v10 - 3)));
          soMaxFlow::SetEdgeCapacity((uint64_t)v5, 1, v9 + 1, i, *(float *)(v8 + 4 * (v10 - 2)));
          soMaxFlow::SetEdgeCapacity((uint64_t)v5, 5, v9, i - 1, *(float *)(v8 + 4 * (v10 - 2)));
          soMaxFlow::SetEdgeCapacity((uint64_t)v5, 2, v9 + 1, i, *(float *)(v8 + 4 * (v10 - 1)));
          soMaxFlow::SetEdgeCapacity((uint64_t)v5, 6, v9 + 1, i - 1, *(float *)(v8 + 4 * (v10 - 1)));
          uint64_t v14 = 4 * v10;
          soMaxFlow::SetEdgeCapacity((uint64_t)v5, 3, v9 + 1, i, *(float *)(v8 + v14));
          this = (soMaxFlow *)soMaxFlow::SetEdgeCapacity((uint64_t)v5, 7, v9 + 2, (int)i - 1, *(float *)(v8 + v14));
          v10 += 4;
          ++v9;
          --v11;
        }
        while (v11);
      }
    }
  }
  return this;
}

void *HFGrabCut::GenerateMask(HFGrabCut *this, HGBitmap *a2, HGBitmap *a3, HGBitmap *a4, double a5, double a6, __n128 a7)
{
  float v7 = *(float *)&a5;
  int v29 = 0;
  soKMeansClassifier::LoadBuffer(*((void **)this + 1), *((unsigned __int8 **)a2 + 10), *((void *)a2 + 8), a5, a6, a7);
  uint64_t result = soKMeansClassifier::LoadMask(*((void **)this + 1), *((void *)a3 + 10), *((void *)a3 + 8), &v29);
  if ((v29 - 1) > 1)
  {
    if (*((unsigned char *)this + 16))
    {
      soKMeansClassifier::Cluster(*((soKMeansClassifier **)this + 1), 5, 1, 0, 0, 0, 0, 0, v13, 0, 0);
      *((unsigned char *)this + 16) = 0;
    }
    uint64_t v22 = *(void *)((char *)a4 + 20);
    uint64_t v23 = *(void *)((char *)a4 + 28);
    uint64_t v24 = *(void *)((char *)a2 + 20);
    uint64_t v25 = *(void *)((char *)a2 + 28);
    HGObject::operator new(0x80uLL);
    ((void (*)(void))HGBitmap::HGBitmap)();
    float v26 = (HGBitmap *)HGObject::operator new(0x80uLL);
    HGBitmap::HGBitmap(v26, v24, v25, 28, *((void *)this + 5));
    float v27 = HGObject::operator new(0x80uLL);
    HGBitmap::HGBitmap(v27, v22, v23, 1, *((void *)this + 6));
    SetupEdges(a2, v26, v7);
    soMaxFlow::soMaxFlow((soMaxFlow *)v28);
  }
  int v14 = *((_DWORD *)a4 + 6);
  int v15 = *((_DWORD *)a4 + 8);
  if (v29 == 2) {
    int v16 = -1;
  }
  else {
    int v16 = 0;
  }
  int v17 = v15 - v14;
  if (v15 != v14)
  {
    int v18 = *((_DWORD *)a4 + 7);
    int v19 = *((_DWORD *)a4 + 5);
    if (v18 != v19)
    {
      int v20 = (char *)*((void *)a4 + 10);
      size_t v21 = (v18 + ~v19) + 1;
      do
      {
        uint64_t result = memset(v20, v16, v21);
        v20 += *((void *)a4 + 8);
        --v17;
      }
      while (v17);
    }
  }
  return result;
}

void sub_1B777E638(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p)
{
}

void sub_1B777E64C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B777E660(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B777E674(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  soMaxFlow::~soMaxFlow((soMaxFlow *)va, a2);
  _Unwind_Resume(a1);
}

void sub_1B777E688(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  soMaxFlow::~soMaxFlow((soMaxFlow *)va, a2);
  _Unwind_Resume(a1);
}

void sub_1B777E69C(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  soMaxFlow::~soMaxFlow((soMaxFlow *)va, a2);
  _Unwind_Resume(a1);
}

uint64_t HGGLTexture::HGGLTexture(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, int a6, uint64_t a7, char a8)
{
  __n128 v13 = HGTexture::HGTexture(a1, a2, a3, a4, 0);
  void *v13 = &unk_1F10D48A0;
  v13[16] = a5;
  v13[17] = 0;
  *((_OWORD *)v13 + 9) = HGRectNull;
  *((_DWORD *)v13 + 40) = a6;
  v13[22] = 0;
  v13[23] = 0;
  v13[21] = a7;
  *((unsigned char *)v13 + 192) = a8;
  *((unsigned char *)v13 + 193) = 0;
  *((_DWORD *)v13 + 3) |= 0x210u;
  if (a5)
  {
    (*(void (**)(uint64_t))(*(void *)a5 + 16))(a5);
    *(unsigned char *)(a1 + 193) = 1;
  }
  return a1;
}

void sub_1B777E784(_Unwind_Exception *a1)
{
  HGBuffer::~HGBuffer(v1);
  _Unwind_Resume(a1);
}

uint64_t HGGLTexture::HGGLTexture(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, char a7)
{
  uint64_t v11 = HGTexture::HGTexture(a1, a2, a3, a4, 0);
  void *v11 = &unk_1F10D48A0;
  v11[16] = a5;
  v11[17] = 0;
  *((_OWORD *)v11 + 9) = HGRectNull;
  *((_DWORD *)v11 + 40) = 3553;
  v11[22] = 0;
  v11[23] = 0;
  v11[21] = a6;
  *((unsigned char *)v11 + 192) = a7;
  *((unsigned char *)v11 + 193) = 0;
  *((_DWORD *)v11 + 3) |= 0x210u;
  if (a5)
  {
    (*(void (**)(uint64_t))(*(void *)a5 + 16))(a5);
    *(unsigned char *)(a1 + 193) = 1;
  }
  return a1;
}

void sub_1B777E864(_Unwind_Exception *a1)
{
  HGBuffer::~HGBuffer(v1);
  _Unwind_Resume(a1);
}

void HGGLTexture::HGGLTexture(HGGLTexture *this, HGRect a2, HGBitmap *a3, HGGPURenderer *a4)
{
  HGTexture::HGTexture((HGTexture *)this, a2, a3);
  *(void *)uint64_t v6 = &unk_1F10D48A0;
  *(void *)(v6 + 128) = a4;
  *(void *)(v6 + 136) = 0;
  *(_OWORD *)(v6 + 144) = HGRectNull;
  *(_DWORD *)(v6 + 160) = 0;
  *(void *)(v6 + 176) = 0;
  *(void *)(v6 + 184) = 0;
  *(void *)(v6 + 168) = 0;
  *(_WORD *)(v6 + 192) = 1;
  *(_DWORD *)(v6 + 12) |= 0x210u;
  if (a4)
  {
    (*(void (**)(HGGPURenderer *))(*(void *)a4 + 16))(a4);
    *((unsigned char *)this + 193) = 1;
  }
}

void sub_1B777E92C(_Unwind_Exception *a1)
{
  HGBuffer::~HGBuffer(v1);
  _Unwind_Resume(a1);
}

void HGGLTexture::~HGGLTexture(HGGLTexture *this)
{
  *(void *)this = &unk_1F10D48A0;
  uint64_t v2 = *((void *)this + 16);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
    *((void *)this + 16) = 0;
  }
  uint64_t v3 = *((void *)this + 17);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
    *((void *)this + 17) = 0;
  }

  HGBuffer::~HGBuffer((HGBuffer *)this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1F10D48A0;
  uint64_t v2 = *((void *)this + 16);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
    *((void *)this + 16) = 0;
  }
  uint64_t v3 = *((void *)this + 17);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
    *((void *)this + 17) = 0;
  }
  HGBuffer::~HGBuffer((HGBuffer *)this);

  HGObject::operator delete(v4);
}

HGGLTexture *HGGLTexture::AssignRenderer(HGGLTexture *this, HGGPURenderer *a2)
{
  if (a2)
  {
    uint64_t v2 = this;
    if (!*((void *)this + 16))
    {
      *((void *)this + 16) = a2;
      this = (HGGLTexture *)(*(uint64_t (**)(HGGPURenderer *))(*(void *)a2 + 16))(a2);
      *((_WORD *)v2 + 96) = 257;
    }
  }
  return this;
}

atomic_uint *HGGLTexture::Release(HGGLTexture *this)
{
  if (*((void *)this + 16))
  {
    unsigned int v2 = atomic_load((unsigned int *)this + 2);
    if (v2 == 1)
    {
      HGGPURenderer::ReleaseTexture(*((int64x2_t **)this + 16), this, (char *)1);
      uint64_t v3 = *((void *)this + 16);
      if (v3)
      {
        (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
        *((void *)this + 16) = 0;
      }
    }
  }

  return HGObject::Release((atomic_uint *)this);
}

uint64_t HGGLTexture::GetTextureRect(HGGLTexture *this)
{
  BOOL IsZero = HGRect::IsZero((HGRect *)this + 9);
  uint64_t v3 = 144;
  if (IsZero) {
    uint64_t v3 = 20;
  }
  return *(void *)((char *)this + v3);
}

void *HGGLTexture::CreateTexture(HGGLTexture *this, HGGLBuffer *a2, HGGPURenderer *a3)
{
  uint64_t v5 = HGObject::operator new(0xC8uLL);
  HGTexture::HGTexture((uint64_t)v5, *(void *)((char *)this + 20), *(void *)((char *)this + 28), *((_DWORD *)this + 4), 0);
  *uint64_t v5 = &unk_1F10D48A0;
  v5[16] = a2;
  v5[17] = 0;
  *((_OWORD *)v5 + 9) = HGRectNull;
  *((_DWORD *)v5 + 40) = 0;
  v5[22] = 0;
  v5[23] = 0;
  v5[21] = 0;
  *((_WORD *)v5 + 96) = 1;
  *((_DWORD *)v5 + 3) |= 0x210u;
  if (a2)
  {
    (*(void (**)(HGGLBuffer *))(*(void *)a2 + 16))(a2);
    *((unsigned char *)v5 + 193) = 1;
  }
  v5[17] = this;
  uint64_t v6 = *((unsigned int *)this + 39);
  *((_DWORD *)v5 + 40) = *((_DWORD *)this + 38);
  v5[21] = v6;
  EdgePolicy = (const HGEdgePolicy *)HGBitmap::GetEdgePolicy((HGBitmap *)this);
  HGBitmap::SetEdgePolicy((HGBitmap *)v5, EdgePolicy);
  *((_OWORD *)v5 + 9) = *(_OWORD *)((char *)this + 136);
  (*(void (**)(HGGLTexture *))(*(void *)this + 16))(this);
  return v5;
}

void sub_1B777ED18(_Unwind_Exception *a1)
{
  HGBuffer::~HGBuffer(v1);
  HGObject::operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1B777ED30(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HGGLTexture::ReadPixels(HGGLTexture *this, HGPixelBufferObj *a2, HGRect a3)
{
  uint64_t v3 = *(void *)&a3.var2;
  uint64_t v4 = *(void *)&a3.var0;
  BOOL IsZero = HGRect::IsZero((HGRect *)this + 9);
  uint64_t v8 = 144;
  if (IsZero) {
    uint64_t v8 = 20;
  }
  HGPixelBufferObj::ReadPixels((uint64_t)a2, v4, v3, *(void *)((char *)this + 20), *(void *)((char *)this + 28), (*((_DWORD *)this + 5) - *(_DWORD *)((char *)this + v8)), (*((_DWORD *)this + 6) - *(_DWORD *)((char *)this + v8 + 4)), *((_DWORD *)this + 4));
}

HGGLTexture *HGGLTexture::AttachRenderer(HGGLTexture *this, HGGPURenderer *a2)
{
  if (!*((unsigned char *)this + 193) && a2 && !*((void *)this + 16))
  {
    *((void *)this + 16) = a2;
    return (HGGLTexture *)(*(uint64_t (**)(HGGPURenderer *))(*(void *)a2 + 16))(a2);
  }
  return this;
}

HGGLTexture *HGGLTexture::DetachRenderer(HGGLTexture *this)
{
  if (!*((unsigned char *)this + 193))
  {
    uint64_t v1 = this;
    this = (HGGLTexture *)*((void *)this + 16);
    if (this)
    {
      this = (HGGLTexture *)(*(uint64_t (**)(HGGLTexture *))(*(void *)this + 24))(this);
      *((void *)v1 + 16) = 0;
    }
  }
  return this;
}

void HGEdgePolicy::HGEdgePolicy(HGEdgePolicy *this)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
}

uint64_t HGEdgePolicy::HGEdgePolicy(uint64_t result, int a2)
{
  *(_DWORD *)uint64_t result = a2;
  *(void *)(result + 12) = 0;
  *(void *)(result + 4) = 0;
  return result;
}

BOOL HGEdgePolicy::isDefault(HGEdgePolicy *this)
{
  return !*(_DWORD *)this
      && *((float *)this + 1) == 0.0
      && *((float *)this + 2) == 0.0
      && *((float *)this + 3) == 0.0
      && *((float *)this + 4) == 0.0;
}

uint64_t HGBitmap::HGBitmap(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  HGObject::HGObject((HGObject *)a1);
  *(void *)uint64_t v8 = &unk_1F10D4920;
  *(_DWORD *)(v8 + 12) = 0;
  *(_DWORD *)(v8 + 16) = a4;
  *(void *)(v8 + 20) = a2;
  *(void *)(a1 + 28) = a3;
  *(void *)(a1 + 36) = a2;
  *(void *)(a1 + 44) = a3;
  *(void *)(a1 + 120) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 100) = 0u;
  if (!HGRect::IsNull((HGRect *)(v8 + 20)))
  {
    int v9 = *(_DWORD *)(a1 + 16);
    if (v9)
    {
      *(void *)(a1 + 56) = HGFormatUtils::bytesPerPixel(v9);
      unsigned int v11 = HGFormatUtils::rowBytesHint(a4, (const char *)(*(_DWORD *)(a1 + 28) - *(_DWORD *)(a1 + 20)), v10);
      *(void *)(a1 + 64) = v11;
      uint64_t v13 = HGMemory::allocate((HGMemory *)((*(int *)(a1 + 32) - (uint64_t)*(int *)(a1 + 24)) * v11), &v16, v12);
      unint64_t v14 = v16;
      *(void *)(a1 + 80) = v13;
      *(void *)(a1 + 88) = v13;
      *(void *)(a1 + 72) = v14;
    }
  }
  return a1;
}

void sub_1B777EFC8(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void sub_1B777EFDC(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

uint64_t HGBitmap::HGBitmap(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  HGObject::HGObject((HGObject *)a1);
  *(void *)uint64_t v10 = &unk_1F10D4920;
  *(_DWORD *)(v10 + 12) = 0;
  *(_DWORD *)(v10 + 16) = a4;
  *(void *)(v10 + 20) = a2;
  *(void *)(a1 + 28) = a3;
  *(void *)(a1 + 36) = a2;
  *(void *)(a1 + 44) = a3;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = a5;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 112) = 0;
  if (!HGRect::IsNull((HGRect *)(v10 + 20)))
  {
    int v11 = *(_DWORD *)(a1 + 16);
    if (v11)
    {
      unsigned int v12 = HGFormatUtils::bytesPerPixel(v11);
      uint64_t v13 = *(int *)(a1 + 32);
      uint64_t v14 = *(int *)(a1 + 24);
      uint64_t v15 = (*(int *)(a1 + 28) - (uint64_t)*(int *)(a1 + 20)) * v12;
      *(void *)(a1 + 56) = v12;
      *(void *)(a1 + 64) = v15;
      *(void *)(a1 + 72) = v15 * (v13 - v14);
    }
  }
  return a1;
}

void sub_1B777F0BC(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

uint64_t HGBitmap::HGBitmap(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, unint64_t a6)
{
  HGObject::HGObject((HGObject *)a1);
  *(void *)uint64_t v12 = &unk_1F10D4920;
  *(_DWORD *)(v12 + 12) = 0;
  *(_DWORD *)(v12 + 16) = a4;
  *(void *)(v12 + 20) = a2;
  uint64_t v13 = (_OWORD *)(v12 + 20);
  *(void *)(v12 + 28) = a3;
  *(void *)(v12 + 36) = a2;
  uint64_t v14 = (_OWORD *)(v12 + 36);
  *(void *)(v12 + 44) = a3;
  *(void *)(v12 + 56) = 0;
  uint64_t v15 = v12 + 56;
  *(void *)(v12 + 64) = 0;
  *(void *)(v12 + 72) = 0;
  *(void *)(v12 + 120) = 0;
  *(void *)(v12 + 80) = a5;
  *(void *)(v12 + 88) = 0;
  *(void *)(v12 + 96) = 0;
  *(void *)(v12 + 104) = 0;
  *(_DWORD *)(v12 + 112) = 0;
  if (HGRect::IsNull((HGRect *)(v12 + 20)))
  {
    uint64_t v16 = *(void *)(a1 + 56);
    a6 = *(void *)(a1 + 64);
    uint64_t v17 = (*(_DWORD *)(a1 + 28) - *(_DWORD *)(a1 + 20));
    if (*(_DWORD *)(a1 + 16) != 31) {
      goto LABEL_8;
    }
LABEL_6:
    BOOL v19 = a6 >= 4 * v16 * v17 / 6uLL;
    goto LABEL_9;
  }
  int v18 = *(_DWORD *)(a1 + 16);
  if (v18)
  {
    uint64_t v16 = HGFormatUtils::bytesPerPixel(v18);
    *(void *)(a1 + 56) = v16;
    *(void *)(a1 + 64) = a6;
    *(void *)(a1 + 72) = (*(int *)(a1 + 32) - (uint64_t)*(int *)(a1 + 24)) * a6;
    uint64_t v17 = (*(_DWORD *)(a1 + 28) - *(_DWORD *)(a1 + 20));
    if (*(_DWORD *)(a1 + 16) == 31) {
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v17 = (*(_DWORD *)(a1 + 28) - *(_DWORD *)(a1 + 20));
    uint64_t v16 = *(void *)(a1 + 56);
    a6 = *(void *)(a1 + 64);
  }
LABEL_8:
  BOOL v19 = v17 * v16 <= a6;
LABEL_9:
  if (!v19 || a6 * (*(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 24)) > *(void *)(a1 + 72))
  {
    *(_DWORD *)(a1 + 16) = 0;
    *uint64_t v14 = HGRectNull;
    _OWORD *v13 = HGRectNull;
    *(_OWORD *)uint64_t v15 = 0u;
    *(_OWORD *)(v15 + 16) = 0u;
    *(void *)(v15 + 32) = 0;
  }
  return a1;
}

void sub_1B777F260(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

uint64_t HGBitmap::HGBitmap(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, unint64_t a6, uint64_t a7)
{
  HGObject::HGObject((HGObject *)a1);
  *(void *)uint64_t v14 = &unk_1F10D4920;
  *(_DWORD *)(v14 + 12) = 0;
  *(_DWORD *)(v14 + 16) = a4;
  *(void *)(v14 + 20) = a2;
  uint64_t v15 = (_OWORD *)(v14 + 20);
  *(void *)(v14 + 28) = a3;
  *(void *)(v14 + 36) = a2;
  uint64_t v16 = (_OWORD *)(v14 + 36);
  *(void *)(v14 + 44) = a3;
  *(void *)(v14 + 56) = 0;
  uint64_t v17 = v14 + 56;
  *(void *)(v14 + 64) = 0;
  *(void *)(v14 + 72) = 0;
  *(void *)(v14 + 120) = 0;
  *(void *)(v14 + 80) = a5;
  *(void *)(v14 + 88) = 0;
  *(void *)(v14 + 96) = 0;
  *(void *)(v14 + 104) = 0;
  *(_DWORD *)(v14 + 112) = 0;
  if (HGRect::IsNull((HGRect *)(v14 + 20)))
  {
    uint64_t v18 = *(void *)(a1 + 56);
    a6 = *(void *)(a1 + 64);
    uint64_t v19 = (*(_DWORD *)(a1 + 28) - *(_DWORD *)(a1 + 20));
    if (*(_DWORD *)(a1 + 16) != 31) {
      goto LABEL_8;
    }
LABEL_6:
    BOOL v21 = a6 >= 4 * v18 * v19 / 6uLL;
    goto LABEL_9;
  }
  int v20 = *(_DWORD *)(a1 + 16);
  if (v20)
  {
    uint64_t v18 = HGFormatUtils::bytesPerPixel(v20);
    *(void *)(a1 + 56) = v18;
    *(void *)(a1 + 64) = a6;
    *(void *)(a1 + 72) = a7;
    uint64_t v19 = (*(_DWORD *)(a1 + 28) - *(_DWORD *)(a1 + 20));
    if (*(_DWORD *)(a1 + 16) == 31) {
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v19 = (*(_DWORD *)(a1 + 28) - *(_DWORD *)(a1 + 20));
    uint64_t v18 = *(void *)(a1 + 56);
    a6 = *(void *)(a1 + 64);
  }
LABEL_8:
  BOOL v21 = v19 * v18 <= a6;
LABEL_9:
  if (!v21 || a6 * (*(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 24)) > *(void *)(a1 + 72))
  {
    *(_DWORD *)(a1 + 16) = 0;
    _OWORD *v16 = HGRectNull;
    *uint64_t v15 = HGRectNull;
    *(_OWORD *)uint64_t v17 = 0u;
    *(_OWORD *)(v17 + 16) = 0u;
    *(void *)(v17 + 32) = 0;
  }
  return a1;
}

void sub_1B777F3F8(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGBitmap::HGBitmap(HGBitmap *this, HGRect a2, HGBitmap *a3)
{
  uint64_t v4 = *(void *)&a2.var2;
  uint64_t v5 = *(void *)&a2.var0;
  HGObject::HGObject((HGObject *)this);
  *(void *)uint64_t v7 = &unk_1F10D4920;
  *(_DWORD *)(v7 + 12) = 0;
  *(_DWORD *)(v7 + 16) = 0;
  *(_OWORD *)(v7 + 20) = HGRectNull;
  *(_OWORD *)(v7 + 36) = HGRectNull;
  *(void *)(v7 + 120) = 0;
  *(_OWORD *)(v7 + 56) = 0u;
  *(_OWORD *)(v7 + 72) = 0u;
  *(_OWORD *)(v7 + 88) = 0u;
  *(_OWORD *)(v7 + 100) = 0u;
  if (a3)
  {
    *(void *)&v18.var0 = HGRectIntersection(*(void *)((char *)a3 + 20), *(void *)((char *)a3 + 28), v5, v4);
    *(void *)&v18.var2 = v8;
    if (!HGRect::IsNull(&v18))
    {
      *((void *)this + 15) = a3;
      (*(void (**)(HGBitmap *))(*(void *)a3 + 16))(a3);
      *(HGRect *)((char *)this + 20) = v18;
      int v9 = *((_DWORD *)a3 + 4);
      *((_DWORD *)this + 4) = v9;
      *(_OWORD *)((char *)this + 36) = *(_OWORD *)((char *)a3 + 36);
      uint64_t v10 = *((void *)a3 + 8);
      *((void *)this + 8) = v10;
      uint64_t v11 = *((void *)a3 + 7);
      *((void *)this + 7) = v11;
      long long v12 = *((_OWORD *)a3 + 6);
      *((_DWORD *)this + 28) = *((_DWORD *)a3 + 28);
      *((_OWORD *)this + 6) = v12;
      *((_DWORD *)this + 3) = *((_DWORD *)a3 + 3);
      uint64_t v13 = *((void *)a3 + 10);
      if (v13)
      {
        uint64_t v14 = v10 * (*((int *)this + 6) - (uint64_t)*((int *)a3 + 6));
        uint64_t v15 = *((int *)this + 5) - (uint64_t)*((int *)a3 + 5);
        if (v9 == 31) {
          unint64_t v16 = v11 * 4 * (int)v15 / 6uLL;
        }
        else {
          unint64_t v16 = v11 * v15;
        }
        unint64_t v17 = v16 + v14;
        *((void *)this + 10) = v13 + v17;
        *((void *)this + 9) = *((void *)a3 + 9) - v17;
      }
    }
  }
}

void sub_1B777F5A0(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGBitmap::~HGBitmap(HGBitmap *this, void *a2)
{
  *(void *)this = &unk_1F10D4920;
  uint64_t v3 = *((void *)this + 15);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  else
  {
    uint64_t v4 = (HGMemory *)*((void *)this + 11);
    if (v4) {
      HGMemory::release(v4, a2);
    }
  }
  *((_DWORD *)this + 4) = 0;
  *(_OWORD *)((char *)this + 36) = HGRectNull;
  *(_OWORD *)((char *)this + 20) = HGRectNull;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((void *)this + 11) = 0;

  HGObject::~HGObject((HGObject *)this);
}

{
  uint64_t v3;
  HGMemory *v4;
  uint64_t vars8;

  *(void *)this = &unk_1F10D4920;
  uint64_t v3 = *((void *)this + 15);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  else
  {
    uint64_t v4 = (HGMemory *)*((void *)this + 11);
    if (v4) {
      HGMemory::release(v4, a2);
    }
  }
  *((_DWORD *)this + 4) = 0;
  *(_OWORD *)((char *)this + 36) = HGRectNull;
  *(_OWORD *)((char *)this + 20) = HGRectNull;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((void *)this + 11) = 0;

  HGObject::~HGObject((HGObject *)this);
}

{
  uint64_t v3;
  HGMemory *v4;
  void *v5;
  uint64_t vars8;

  *(void *)this = &unk_1F10D4920;
  uint64_t v3 = *((void *)this + 15);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  else
  {
    uint64_t v4 = (HGMemory *)*((void *)this + 11);
    if (v4) {
      HGMemory::release(v4, a2);
    }
  }
  *((_DWORD *)this + 4) = 0;
  *(_OWORD *)((char *)this + 36) = HGRectNull;
  *(_OWORD *)((char *)this + 20) = HGRectNull;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((void *)this + 11) = 0;
  HGObject::~HGObject((HGObject *)this);

  HGObject::operator delete(v5);
}

unint64_t HGBitmap::byteOffset(HGBitmap *this, int a2, int a3)
{
  unint64_t v3 = *((void *)this + 7) * (a2 - (uint64_t)*((int *)this + 5));
  if (*((_DWORD *)this + 4) == 31) {
    unint64_t v3 = 4 * v3 / 6;
  }
  return v3 + *((void *)this + 8) * (a3 - (uint64_t)*((int *)this + 6));
}

HGObject *HGBitmap::SetStorage(HGBitmap *this, HGObject *a2)
{
  uint64_t result = (HGObject *)*((void *)this + 15);
  if (result != a2)
  {
    if (result) {
      uint64_t result = (HGObject *)(*(uint64_t (**)(HGObject *))(*(void *)result + 24))(result);
    }
    *((void *)this + 15) = a2;
    if (a2)
    {
      uint64_t v5 = *(uint64_t (**)(HGObject *))(*(void *)a2 + 16);
      return (HGObject *)v5(a2);
    }
  }
  return result;
}

uint64_t HGBitmap::GetStorage(HGBitmap *this)
{
  return *((void *)this + 15);
}

uint64_t HGBitmap::GetEdgePolicy(HGBitmap *this)
{
  return (uint64_t)this + 96;
}

__n128 HGBitmap::SetEdgePolicy(HGBitmap *this, const HGEdgePolicy *a2)
{
  __n128 result = *(__n128 *)a2;
  *((_DWORD *)this + 28) = *((_DWORD *)a2 + 4);
  *((__n128 *)this + 6) = result;
  return result;
}

void HGBitmap::ReadTile(HGBitmap *this, char *a2, HGRect a3, int a4)
{
  int var2 = a3.var2;
  int var0 = a3.var0;
  int var1 = a3.var1;
  int var3 = a3.var3;
  uint64_t v11 = HGRectIntersection(*(uint64_t *)&a3.var0, *(uint64_t *)&a3.var2, *(void *)((char *)this + 20), *(void *)((char *)this + 28));
  if (!*((void *)this + 10) || (v13 = v11, unint64_t v14 = v12, HGRectIsNull(v11, v12)))
  {
    int v15 = var2 - var0;
    int v16 = var3 - var1;
    if (a4)
    {
      if (v16 >= 1 && v15 >= 1)
      {
        uint64_t v17 = 16 * (v15 + a4);
        do
        {
          bzero(a2, 16 * (var2 - var0));
          a2 += v17;
          --v16;
        }
        while (v16);
      }
    }
    else
    {
      int v18 = v16 * v15;
      if (v18 >= 1)
      {
        bzero(a2, 16 * v18);
      }
    }
    return;
  }
  int v50 = a4;
  unint64_t v19 = HIDWORD(v13);
  int v48 = v14;
  int v52 = v13;
  unint64_t v53 = HIDWORD(v14);
  BOOL v20 = __OFSUB__(var3, HIDWORD(v14));
  int v21 = var3 - HIDWORD(v14);
  if (!((v21 < 0) ^ v20 | (v21 == 0)))
  {
    int v22 = var2 - var0;
    int v23 = var2 - var0 + a4;
    uint64_t v24 = (HIDWORD(v14) - var1) * (uint64_t)v23;
    uint64_t v25 = &a2[16 * v24];
    if (v50)
    {
      if (v21 >= 1 && v22 >= 1)
      {
        uint64_t v27 = 16 * v23;
        do
        {
          bzero(v25, 16 * (var2 - var0));
          v25 += v27;
          --v21;
        }
        while (v21);
      }
    }
    else
    {
      int v28 = v21 * v22;
      if (v28 >= 1) {
        bzero(&a2[16 * v24], 16 * v28);
      }
    }
  }
  int v29 = v19 - var1;
  if ((int)v19 <= var1)
  {
    int v33 = v50;
    int v34 = v14;
    if ((int)v19 >= SHIDWORD(v14)) {
      return;
    }
    goto LABEL_36;
  }
  int v30 = var2 - var0;
  int v46 = var2 - var0;
  if (v50)
  {
    if (v29 >= 1 && v46 >= 1)
    {
      float v31 = a2;
      int v32 = v19 - var1;
      do
      {
        bzero(v31, 16 * (var2 - var0));
        v31 += 16 * v46 + 16 * v50;
        --v32;
      }
      while (v32);
    }
  }
  else if (v29 * v30 >= 1)
  {
    bzero(a2, 16 * (v29 * v30));
  }
  int v33 = v50;
  int v34 = v48;
  a2 += 16 * v29 * (v46 + v50);
  if ((int)v19 < (int)v53)
  {
LABEL_36:
    uint64_t v35 = (v34 - v52);
    int v36 = v33 - var0;
    BOOL v38 = v52 <= var0 || v52 - var0 < 1;
    size_t v49 = 16 * (var2 - v34);
    uint64_t v51 = 16 * (v52 - var0);
    int v39 = v36 + var2;
    BOOL v41 = var2 <= v34 || var2 - v34 < 1;
    uint64_t v47 = 16 * (v34 - var0);
    uint64_t v42 = 16 * v39;
    uint64_t v43 = 16 * (v52 - var0);
    do
    {
      if (v38)
      {
        if (v41) {
          goto LABEL_53;
        }
      }
      else
      {
        bzero(a2, v51);
        if (v41)
        {
LABEL_53:
          uint64_t v45 = *((unsigned int *)this + 4);
          if (v45 == 31) {
            goto LABEL_57;
          }
          goto LABEL_49;
        }
      }
      bzero(&a2[v47], v49);
      uint64_t v45 = *((unsigned int *)this + 4);
      if (v45 == 31)
      {
LABEL_57:
        uint64_t v44 = *((void *)this + 10)
            + *((void *)this + 8) * ((int)v19 - *((_DWORD *)this + 6))
            + *((void *)this + 7) * (4 * ((v52 - *((_DWORD *)this + 5)) / 6))
            + _4b10BitYXZX_OffsetList[4 * ((v52 - *((_DWORD *)this + 5)) % 6)];
        goto LABEL_50;
      }
LABEL_49:
      uint64_t v44 = *((void *)this + 10)
          + *((void *)this + 8) * ((int)v19 - *((_DWORD *)this + 6))
          + *((void *)this + 7) * (v52 - (uint64_t)*((int *)this + 5));
LABEL_50:
      ((void (*)(char *, uint64_t, uint64_t))hg_span_read[v45])(&a2[v43], v35, v44);
      LODWORD(v19) = v19 + 1;
      a2 += v42;
    }
    while (v53 != v19);
  }
}

void HGBitmap::WriteTile(HGBitmap *this, char *a2, HGRect a3)
{
  unint64_t v3 = *((void *)this + 10);
  if (!v3) {
    return;
  }
  uint64_t v4 = *(void *)&a3.var0;
  uint64_t v5 = a2;
  if (*((_DWORD *)this + 4) == 31)
  {
    uint64_t v7 = *((void *)this + 7);
    unint64_t v8 = 715827883 * (a3.var0 - *((_DWORD *)this + 5));
    int v9 = (char *)(v3
                + *((void *)this + 8) * (a3.var1 - (uint64_t)*((int *)this + 6))
                + v7 * 4 * (HIDWORD(v8) + (v8 >> 63)));
    unint64_t v3 = v7 * (unint64_t)(4 * (a3.var2 - a3.var0)) / 6;
    if (a2) {
      goto LABEL_4;
    }
  }
  else
  {
    uint64_t v13 = *((void *)this + 7);
    int v9 = (char *)(v3
                + *((void *)this + 8) * (a3.var1 - (uint64_t)*((int *)this + 6))
                + v13 * (a3.var0 - (uint64_t)*((int *)this + 5)));
    LODWORD(v3) = (a3.var2 - a3.var0) * v13;
    if (a2)
    {
LABEL_4:
      int v10 = a3.var3 - a3.var1;
      if (a3.var3 > a3.var1)
      {
        uint64_t v11 = (a3.var2 - a3.var0);
        uint64_t v12 = 16 * a3.var2 - 16 * a3.var0;
        do
        {
          ((void (*)(char *, uint64_t, char *, uint64_t))hg_span_write[*((unsigned int *)this + 4)])(v9, v11, v5, v4);
          v9 += *((void *)this + 8);
          v5 += v12;
          --v10;
        }
        while (v10);
      }
      return;
    }
  }
  int v14 = a3.var3 - a3.var1;
  if (a3.var3 > a3.var1 && (int)v3 >= 1)
  {
    size_t v15 = v3;
    do
    {
      bzero(v9, v15);
      v9 += *((void *)this + 8);
      --v14;
    }
    while (v14);
  }
}

void hg_span_read_null(void *a1, int a2)
{
  if (a2 >= 1) {
    bzero(a1, 16 * a2);
  }
}

_OWORD *hg_span_read_1b(_OWORD *result, int a2, unsigned __int8 *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    do
    {
      unsigned int v4 = *a3++;
      *(float *)&long long v5 = (float)v4 * 0.0039216;
      DWORD1(v5) = 0;
      DWORD2(v5) = 0;
      HIDWORD(v5) = 1.0;
      *result++ = v5;
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

_OWORD *hg_span_read_1b_m(_OWORD *result, int a2, unsigned __int8 *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    do
    {
      unsigned int v4 = *a3++;
      *(void *)&long long v5 = 0;
      DWORD2(v5) = 0;
      *((float *)&v5 + 3) = (float)v4 * 0.0039216;
      *result++ = v5;
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

_OWORD *hg_span_read_1s(_OWORD *result, int a2, unsigned __int16 *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    do
    {
      unsigned int v4 = *a3++;
      *(float *)&long long v5 = (float)v4 * 0.000015259;
      DWORD1(v5) = 0;
      DWORD2(v5) = 0;
      HIDWORD(v5) = 1.0;
      *result++ = v5;
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

_OWORD *hg_span_read_1s_m(_OWORD *result, int a2, unsigned __int16 *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    do
    {
      unsigned int v4 = *a3++;
      *(void *)&long long v5 = 0;
      DWORD2(v5) = 0;
      *((float *)&v5 + 3) = (float)v4 * 0.000015259;
      *result++ = v5;
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

float32x4_t *hg_span_read_1h(float32x4_t *result, int a2, __int16 *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    do
    {
      unsigned int v4 = *a3++;
      v5.i64[0] = v4;
      v5.i64[1] = 0x3C0000000000;
      *result++ = vcvtq_f32_f16((float16x4_t)vqmovn_s32(v5));
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

float32x4_t *hg_span_read_1h_m(float32x4_t *result, int a2, __int16 *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    do
    {
      __int32 v4 = *a3++;
      v5.i64[0] = 0;
      v5.i32[2] = 0;
      v5.i32[3] = v4;
      *result++ = vcvtq_f32_f16((float16x4_t)vqmovn_s32(v5));
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

_OWORD *hg_span_read_1f(_OWORD *result, int a2, unsigned int *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    do
    {
      unsigned int v4 = *a3++;
      *(void *)&long long v5 = v4;
      DWORD2(v5) = 0;
      HIDWORD(v5) = 1.0;
      *result++ = v5;
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

_OWORD *hg_span_read_1f_m(_OWORD *result, int a2, _DWORD *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    do
    {
      *(void *)&long long v4 = 0;
      DWORD2(v4) = 0;
      HIDWORD(v4) = *a3++;
      *result++ = v4;
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

_OWORD *hg_span_read_2b(_OWORD *result, int a2, unsigned __int8 *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    float32x2_t v4 = (float32x2_t)vdup_n_s32(0x3B808081u);
    do
    {
      v5.i32[0] = *a3;
      v5.i32[1] = a3[1];
      *(float32x2_t *)&long long v6 = vmul_f32(vcvt_f32_u32(v5), v4);
      *((void *)&v6 + 1) = 0x3F80000000000000;
      *result++ = v6;
      a3 += 2;
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

_OWORD *hg_span_read_2s(_OWORD *result, int a2, unsigned __int16 *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    float32x2_t v4 = (float32x2_t)vdup_n_s32(0x37800080u);
    do
    {
      v5.i32[0] = *a3;
      v5.i32[1] = a3[1];
      *(float32x2_t *)&long long v6 = vmul_f32(vcvt_f32_u32(v5), v4);
      *((void *)&v6 + 1) = 0x3F80000000000000;
      *result++ = v6;
      a3 += 2;
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

float32x4_t *hg_span_read_2h(float32x4_t *result, int a2, __int16 *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    do
    {
      v4.i32[0] = *a3;
      v4.i32[1] = a3[1];
      v4.i64[1] = 0x3C0000000000;
      *result++ = vcvtq_f32_f16((float16x4_t)vqmovn_s32(v4));
      --v3;
      a3 += 2;
    }
    while (v3 > 1);
  }
  return result;
}

_OWORD *hg_span_read_2f(_OWORD *result, int a2, uint64_t *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    do
    {
      uint64_t v4 = *a3++;
      *(void *)&long long v5 = v4;
      *((void *)&v5 + 1) = 0x3F80000000000000;
      *result++ = v5;
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

float32x4_t hg_span_read_2b_yxzx(uint64_t a1, int a2, int8x16_t *_X2, float32x4_t result, float a5, __n128 a6, float32x4_t a7, float a8, __n128 a9)
{
  if ((_X2 & 3) != 0)
  {
    result.i8[0] = _X2[-1].i8[14];
    LOBYTE(a5) = _X2->i8[0];
    a6.n128_u8[0] = _X2->u8[1];
    a6.n128_f32[0] = (float)a6.n128_u32[0];
    a7.i32[3] = 0;
    a7.i32[0] = a6.n128_u32[0];
    a7.f32[1] = (float)result.u32[0];
    a7.f32[2] = (float)LODWORD(a5);
    a5 = 0.0;
    __n128 result = vaddq_f32(vmulq_f32(a7, (float32x4_t)xmmword_1B8343540), (float32x4_t)xmmword_1B7E734D0);
    *(float32x4_t *)a1 = result;
    a1 += 16;
    _X2 = (int8x16_t *)((char *)_X2 + 2);
    --a2;
  }
  if (a2 >= 2 && (_X2 & 0xF) != 0)
  {
    int v9 = &_X2->i8[4];
    __n128 result = (float32x4_t)xmmword_1B8343540;
    a5 = 0.0;
    do
    {
      unsigned int v10 = a2;
      a6.n128_u8[0] = _X2->i8[0];
      a7.i8[0] = _X2->i8[1];
      LOBYTE(a8) = _X2->i8[2];
      a8 = (float)LODWORD(a8);
      a9.n128_u8[0] = _X2->u8[3];
      v11.f32[0] = (float)a7.u32[0];
      v11.f32[1] = (float)a6.n128_u32[0];
      v11.i64[1] = LODWORD(a8);
      a7.f32[0] = (float)a9.n128_u32[0];
      a9 = (__n128)vaddq_f32(vmulq_f32(v11, (float32x4_t)xmmword_1B8343540), (float32x4_t)xmmword_1B7E734D0);
      v11.i32[3] = 0;
      v11.i32[0] = a7.i32[0];
      a6 = (__n128)vaddq_f32(vmulq_f32(v11, (float32x4_t)xmmword_1B8343540), (float32x4_t)xmmword_1B7E734D0);
      *(__n128 *)a1 = a9;
      *(__n128 *)(a1 + 16) = a6;
      a1 += 32;
      _X2 = (int8x16_t *)((char *)_X2 + 4);
      a2 -= 2;
      if (v10 < 4) {
        break;
      }
      uint64_t v12 = v9 & 0xF;
      v9 += 4;
    }
    while (v12);
  }
  if (a2 >= 8)
  {
    result.i64[0] = 0xFFFFFF01FFFFFF00;
    a5 = NAN;
    a6.n128_u32[0] = 998277249;
    a7.i32[0] = 998277249;
    a8 = 0.0;
    a9.n128_u32[0] = -248;
    uint64_t v13 = _X2;
    do
    {
      int8x16_t v14 = *v13++;
      unsigned int v15 = a2;
      __asm { PRFM            #0, [X2,#0x80] }
      float32x4_t v21 = vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v14, (int8x16_t)xmmword_1B8343550));
      int32x4_t v22 = (int32x4_t)vaddq_f32(vmulq_f32(v21, (float32x4_t)xmmword_1B8343540), (float32x4_t)xmmword_1B7E734D0);
      *(void *)&long long v23 = vrev64q_s32(v22).u64[0];
      *((void *)&v23 + 1) = v22.i64[1];
      int32x4_t v24 = (int32x4_t)vaddq_f32(vmulq_f32(v21, (float32x4_t)xmmword_1B8343570), (float32x4_t)xmmword_1B7E736C0);
      *(_OWORD *)a1 = v23;
      *(int8x16_t *)(a1 + 16) = vextq_s8((int8x16_t)v24, (int8x16_t)vuzp1q_s32(v24, vdupq_lane_s32(*(int32x2_t *)v24.i8, 1)), 0xCuLL);
      float32x4_t v25 = vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v14, (int8x16_t)xmmword_1B8343560));
      int32x4_t v26 = (int32x4_t)vaddq_f32(vmulq_f32(v25, (float32x4_t)xmmword_1B8343540), (float32x4_t)xmmword_1B7E734D0);
      v22.i64[0] = vrev64q_s32(v26).u64[0];
      v22.i64[1] = v26.i64[1];
      int32x4_t v27 = (int32x4_t)vaddq_f32(vmulq_f32(v25, (float32x4_t)xmmword_1B8343570), (float32x4_t)xmmword_1B7E736C0);
      *(int32x4_t *)(a1 + 32) = v22;
      *(int8x16_t *)(a1 + 48) = vextq_s8((int8x16_t)v27, (int8x16_t)vuzp1q_s32(v27, vdupq_lane_s32(*(int32x2_t *)v27.i8, 1)), 0xCuLL);
      float32x4_t v28 = vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v14, (int8x16_t)xmmword_1B8343580));
      int32x4_t v29 = (int32x4_t)vaddq_f32(vmulq_f32(v28, (float32x4_t)xmmword_1B8343540), (float32x4_t)xmmword_1B7E734D0);
      v22.i64[0] = vrev64q_s32(v29).u64[0];
      v22.i64[1] = v29.i64[1];
      int32x4_t v30 = (int32x4_t)vaddq_f32(vmulq_f32(v28, (float32x4_t)xmmword_1B8343570), (float32x4_t)xmmword_1B7E736C0);
      *(int32x4_t *)(a1 + 64) = v22;
      *(int8x16_t *)(a1 + 80) = vextq_s8((int8x16_t)v30, (int8x16_t)vuzp1q_s32(v30, vdupq_lane_s32(*(int32x2_t *)v30.i8, 1)), 0xCuLL);
      float32x4_t v31 = vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v14, (int8x16_t)xmmword_1B8343590));
      int32x4_t v32 = (int32x4_t)vaddq_f32(vmulq_f32(v31, (float32x4_t)xmmword_1B8343540), (float32x4_t)xmmword_1B7E734D0);
      v29.i64[0] = vrev64q_s32(v32).u64[0];
      v29.i64[1] = v32.i64[1];
      int32x4_t v33 = (int32x4_t)vaddq_f32(vmulq_f32(v31, (float32x4_t)xmmword_1B8343570), (float32x4_t)xmmword_1B7E736C0);
      *(int32x4_t *)(a1 + 96) = v29;
      *(int8x16_t *)(a1 + 112) = vextq_s8((int8x16_t)v33, (int8x16_t)vuzp1q_s32(v33, vdupq_lane_s32(*(int32x2_t *)v33.i8, 1)), 0xCuLL);
      _X2 = v13;
      a1 += 128;
      a2 -= 8;
    }
    while (v15 > 0xF);
  }
  if (a2 >= 2)
  {
    __n128 result = (float32x4_t)xmmword_1B8343540;
    a5 = 0.0;
    do
    {
      a6.n128_u8[0] = _X2->i8[0];
      a7.i8[0] = _X2->i8[1];
      LOBYTE(a8) = _X2->i8[2];
      a8 = (float)LODWORD(a8);
      a9.n128_u8[0] = _X2->u8[3];
      a9.n128_f32[0] = (float)a9.n128_u32[0];
      v34.f32[0] = (float)a7.u32[0];
      v34.f32[1] = (float)a6.n128_u32[0];
      v34.i64[1] = LODWORD(a8);
      v35.i32[0] = a9.n128_u32[0];
      v35.f32[1] = (float)a6.n128_u32[0];
      a6 = (__n128)vaddq_f32(vmulq_f32(v34, (float32x4_t)xmmword_1B8343540), (float32x4_t)xmmword_1B7E734D0);
      v35.i64[1] = LODWORD(a8);
      a7 = vaddq_f32(vmulq_f32(v35, (float32x4_t)xmmword_1B8343540), (float32x4_t)xmmword_1B7E734D0);
      unsigned int v36 = a2;
      *(__n128 *)a1 = a6;
      *(float32x4_t *)(a1 + 16) = a7;
      a1 += 32;
      _X2 = (int8x16_t *)((char *)_X2 + 4);
      a2 -= 2;
    }
    while (v36 > 3);
  }
  if (a2 == 1)
  {
    result.i8[0] = _X2->i8[0];
    LOBYTE(a5) = _X2->i8[1];
    a6.n128_u8[0] = _X2->u8[2];
    v37.f32[0] = (float)LODWORD(a5);
    v37.f32[1] = (float)result.u32[0];
    v37.i64[1] = COERCE_UNSIGNED_INT((float)a6.n128_u32[0]);
    __n128 result = vaddq_f32(vmulq_f32(v37, (float32x4_t)xmmword_1B8343540), (float32x4_t)xmmword_1B7E734D0);
    *(float32x4_t *)a1 = result;
  }
  return result;
}

float32x4_t hg_span_read_2b_xyxz(uint64_t a1, int a2, int8x16_t *_X2, float32x4_t result, float a5, __n128 a6, float32x4_t a7, float a8)
{
  if ((_X2 & 3) != 0)
  {
    result.i8[0] = _X2[-1].i8[15];
    LOBYTE(a5) = _X2->i8[1];
    a6.n128_u8[0] = _X2->i8[0];
    a6.n128_f32[0] = (float)a6.n128_u32[0];
    a7.i32[3] = 0;
    a7.i32[0] = a6.n128_u32[0];
    a7.f32[1] = (float)result.u32[0];
    a7.f32[2] = (float)LODWORD(a5);
    a5 = 0.0;
    __n128 result = vaddq_f32(vmulq_f32(a7, (float32x4_t)xmmword_1B8343540), (float32x4_t)xmmword_1B7E734D0);
    *(float32x4_t *)a1 = result;
    a1 += 16;
    _X2 = (int8x16_t *)((char *)_X2 + 2);
    --a2;
  }
  if (a2 >= 2 && (_X2 & 0xF) != 0)
  {
    unint64_t v8 = &_X2->u8[4];
    __n128 result = (float32x4_t)xmmword_1B8343540;
    a5 = 0.0;
    do
    {
      unsigned int v9 = a2;
      v10.i32[0] = _X2->u8[0];
      v10.i32[1] = _X2->u8[1];
      *(float32x2_t *)v11.f32 = vcvt_f32_u32(v10);
      a7.i8[0] = _X2->i8[3];
      LOBYTE(a8) = _X2->i8[2];
      a8 = (float)LODWORD(a8);
      v12.i64[0] = __PAIR64__(v11.u32[1], LODWORD(a8));
      *(float *)&unsigned int v13 = (float)a7.u32[0];
      v11.i64[1] = v13;
      a6 = (__n128)vaddq_f32(vmulq_f32(v11, (float32x4_t)xmmword_1B8343540), (float32x4_t)xmmword_1B7E734D0);
      v12.i64[1] = v13;
      a7 = vaddq_f32(vmulq_f32(v12, (float32x4_t)xmmword_1B8343540), (float32x4_t)xmmword_1B7E734D0);
      *(__n128 *)a1 = a6;
      *(float32x4_t *)(a1 + 16) = a7;
      a1 += 32;
      _X2 = (int8x16_t *)((char *)_X2 + 4);
      a2 -= 2;
      if (v9 < 4) {
        break;
      }
      uint64_t v14 = v8 & 0xF;
      v8 += 4;
    }
    while (v14);
  }
  if (a2 >= 8)
  {
    result.i64[0] = 0xFFFFFF01FFFFFF00;
    a5 = NAN;
    a6.n128_u32[0] = 998277249;
    a7.i32[0] = 0;
    a8 = 0.0;
    unsigned int v15 = _X2;
    do
    {
      int8x16_t v16 = *v15++;
      unsigned int v17 = a2;
      __asm { PRFM            #0, [X2,#0x80] }
      float32x4_t v23 = vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v16, (int8x16_t)xmmword_1B8343550));
      int32x4_t v24 = (int32x4_t)vaddq_f32(vmulq_f32(v23, (float32x4_t)xmmword_1B83435A0), (float32x4_t)xmmword_1B7E736D0);
      int32x4_t v25 = vrev64q_s32(v24);
      v25.i64[0] = v24.i64[0];
      int32x4_t v26 = (int32x4_t)vaddq_f32(vmulq_f32(v23, (float32x4_t)xmmword_1B83435B0), (float32x4_t)xmmword_1B7E736B0);
      *(int32x4_t *)a1 = v25;
      *(int32x4_t *)(a1 + 16) = vzip2q_s32(v26, vzip1q_s32(v26, vdupq_lane_s32(*(int32x2_t *)v26.i8, 0)));
      float32x4_t v27 = vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v16, (int8x16_t)xmmword_1B8343560));
      int32x4_t v28 = (int32x4_t)vaddq_f32(vmulq_f32(v27, (float32x4_t)xmmword_1B83435A0), (float32x4_t)xmmword_1B7E736D0);
      int32x4_t v29 = vrev64q_s32(v28);
      v29.i64[0] = v28.i64[0];
      int32x4_t v30 = (int32x4_t)vaddq_f32(vmulq_f32(v27, (float32x4_t)xmmword_1B83435B0), (float32x4_t)xmmword_1B7E736B0);
      *(int32x4_t *)(a1 + 32) = v29;
      *(int32x4_t *)(a1 + 48) = vzip2q_s32(v30, vzip1q_s32(v30, vdupq_lane_s32(*(int32x2_t *)v30.i8, 0)));
      float32x4_t v31 = vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v16, (int8x16_t)xmmword_1B8343580));
      int32x4_t v32 = (int32x4_t)vaddq_f32(vmulq_f32(v31, (float32x4_t)xmmword_1B83435A0), (float32x4_t)xmmword_1B7E736D0);
      int32x4_t v33 = vrev64q_s32(v32);
      v33.i64[0] = v32.i64[0];
      int32x4_t v34 = (int32x4_t)vaddq_f32(vmulq_f32(v31, (float32x4_t)xmmword_1B83435B0), (float32x4_t)xmmword_1B7E736B0);
      *(int32x4_t *)(a1 + 64) = v33;
      *(int32x4_t *)(a1 + 80) = vzip2q_s32(v34, vzip1q_s32(v34, vdupq_lane_s32(*(int32x2_t *)v34.i8, 0)));
      float32x4_t v35 = vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v16, (int8x16_t)xmmword_1B8343590));
      int32x4_t v36 = (int32x4_t)vaddq_f32(vmulq_f32(v35, (float32x4_t)xmmword_1B83435A0), (float32x4_t)xmmword_1B7E736D0);
      int32x4_t v37 = vrev64q_s32(v36);
      v37.i64[0] = v36.i64[0];
      int32x4_t v38 = (int32x4_t)vaddq_f32(vmulq_f32(v35, (float32x4_t)xmmword_1B83435B0), (float32x4_t)xmmword_1B7E736B0);
      *(int32x4_t *)(a1 + 96) = v37;
      *(int32x4_t *)(a1 + 112) = vzip2q_s32(v38, vzip1q_s32(v38, vdupq_lane_s32(*(int32x2_t *)v38.i8, 0)));
      _X2 = v15;
      a1 += 128;
      a2 -= 8;
    }
    while (v17 > 0xF);
  }
  if (a2 >= 2)
  {
    __n128 result = (float32x4_t)xmmword_1B8343540;
    a5 = 0.0;
    do
    {
      v39.i32[0] = _X2->u8[0];
      v39.i32[1] = _X2->u8[1];
      a7.i8[0] = _X2->i8[3];
      *(float *)&unsigned int v40 = (float)a7.u32[0];
      LOBYTE(a8) = _X2->i8[2];
      *(float32x2_t *)v41.f32 = vcvt_f32_u32(v39);
      a8 = (float)LODWORD(a8);
      v42.i64[0] = __PAIR64__(v41.u32[1], LODWORD(a8));
      v41.i64[1] = v40;
      a6 = (__n128)vaddq_f32(vmulq_f32(v41, (float32x4_t)xmmword_1B8343540), (float32x4_t)xmmword_1B7E734D0);
      v42.i64[1] = v40;
      a7 = vaddq_f32(vmulq_f32(v42, (float32x4_t)xmmword_1B8343540), (float32x4_t)xmmword_1B7E734D0);
      unsigned int v43 = a2;
      *(__n128 *)a1 = a6;
      *(float32x4_t *)(a1 + 16) = a7;
      a1 += 32;
      _X2 = (int8x16_t *)((char *)_X2 + 4);
      a2 -= 2;
    }
    while (v43 > 3);
  }
  if (a2 == 1)
  {
    result.i8[0] = _X2->i8[1];
    LOBYTE(a5) = _X2->i8[0];
    a6.n128_u8[0] = _X2->u8[3];
    v44.f32[0] = (float)LODWORD(a5);
    v44.f32[1] = (float)result.u32[0];
    v44.i64[1] = COERCE_UNSIGNED_INT((float)a6.n128_u32[0]);
    __n128 result = vaddq_f32(vmulq_f32(v44, (float32x4_t)xmmword_1B8343540), (float32x4_t)xmmword_1B7E734D0);
    *(float32x4_t *)a1 = result;
  }
  return result;
}

float32x4_t hg_span_read_2s_yxzx(uint64_t a1, int a2, _WORD *a3, float32x4_t result, float a5, __n128 a6, float32x4_t a7, float a8, __n128 a9)
{
  if ((a3 & 7) != 0)
  {
    result.i16[0] = *(a3 - 2);
    LOWORD(a5) = *a3;
    a6.n128_u16[0] = a3[1];
    a6.n128_f32[0] = (float)a6.n128_u32[0];
    a7.i32[3] = 0;
    a7.i32[0] = a6.n128_u32[0];
    a7.f32[1] = (float)result.u32[0];
    a7.f32[2] = (float)LODWORD(a5);
    HIWORD(a5) = 0;
    __n128 result = vaddq_f32(vmulq_f32(a7, (float32x4_t)xmmword_1B83435C0), (float32x4_t)xmmword_1B7E734D0);
    *(float32x4_t *)a1 = result;
    a1 += 16;
    a3 += 2;
    --a2;
  }
  if (a2 >= 2 && (a3 & 0xF) != 0)
  {
    unsigned int v9 = a3 + 4;
    __n128 result = (float32x4_t)xmmword_1B83435C0;
    HIWORD(a5) = 0;
    do
    {
      unsigned int v10 = a2;
      a6.n128_u16[0] = *a3;
      a7.i16[0] = a3[1];
      LOWORD(a8) = a3[2];
      a8 = (float)LODWORD(a8);
      a9.n128_u16[0] = a3[3];
      v11.f32[0] = (float)a7.u32[0];
      v11.f32[1] = (float)a6.n128_u32[0];
      v11.i64[1] = LODWORD(a8);
      a7.f32[0] = (float)a9.n128_u32[0];
      a9 = (__n128)vaddq_f32(vmulq_f32(v11, (float32x4_t)xmmword_1B83435C0), (float32x4_t)xmmword_1B7E734D0);
      v11.i32[3] = 0;
      v11.i32[0] = a7.i32[0];
      a6 = (__n128)vaddq_f32(vmulq_f32(v11, (float32x4_t)xmmword_1B83435C0), (float32x4_t)xmmword_1B7E734D0);
      *(__n128 *)a1 = a9;
      *(__n128 *)(a1 + 16) = a6;
      a1 += 32;
      a3 += 4;
      a2 -= 2;
      if (v10 < 4) {
        break;
      }
      uint64_t v12 = v9 & 0xF;
      v9 += 4;
    }
    while (v12);
  }
  if (a2 >= 4)
  {
    __n128 result = 0uLL;
    HIWORD(a5) = -1;
    a6.n128_u16[1] = 14208;
    a7.i16[1] = 0;
    HIWORD(a8) = 14208;
    a9.n128_u16[1] = 0;
    do
    {
      int16x8_t v13 = *(int16x8_t *)a3;
      a3 += 8;
      float32x4_t v14 = vcvtq_f32_s32((int32x4_t)vzip1q_s16(v13, (int16x8_t)0));
      float32x4_t v15 = vcvtq_f32_s32((int32x4_t)vqtbl1q_s8((int8x16_t)v13, (int8x16_t)xmmword_1B83435D0));
      int32x4_t v16 = (int32x4_t)vaddq_f32(vmulq_f32(v14, (float32x4_t)xmmword_1B83435C0), (float32x4_t)xmmword_1B7E734D0);
      *(void *)&long long v17 = vrev64q_s32(v16).u64[0];
      *((void *)&v17 + 1) = v16.i64[1];
      int32x4_t v18 = (int32x4_t)vaddq_f32(vmulq_f32(v14, (float32x4_t)xmmword_1B83435E0), (float32x4_t)xmmword_1B7E736C0);
      int32x4_t v19 = (int32x4_t)vaddq_f32(vmulq_f32(v15, (float32x4_t)xmmword_1B83435C0), (float32x4_t)xmmword_1B7E734D0);
      *(void *)&long long v20 = vrev64q_s32(v19).u64[0];
      *((void *)&v20 + 1) = v19.i64[1];
      unsigned int v21 = a2;
      *(_OWORD *)a1 = v17;
      *(int8x16_t *)(a1 + 16) = vextq_s8((int8x16_t)v18, (int8x16_t)vuzp1q_s32(v18, vdupq_lane_s32(*(int32x2_t *)v18.i8, 1)), 0xCuLL);
      int32x4_t v22 = (int32x4_t)vaddq_f32(vmulq_f32(v15, (float32x4_t)xmmword_1B83435E0), (float32x4_t)xmmword_1B7E736C0);
      *(_OWORD *)(a1 + 32) = v20;
      *(int8x16_t *)(a1 + 48) = vextq_s8((int8x16_t)v22, (int8x16_t)vuzp1q_s32(v22, vdupq_lane_s32(*(int32x2_t *)v22.i8, 1)), 0xCuLL);
      a1 += 64;
      a2 -= 4;
    }
    while (v21 > 7);
  }
  if (a2 >= 2)
  {
    __n128 result = (float32x4_t)xmmword_1B83435C0;
    HIWORD(a5) = 0;
    do
    {
      a6.n128_u16[0] = *a3;
      a7.i16[0] = a3[1];
      LOWORD(a8) = a3[2];
      a8 = (float)LODWORD(a8);
      a9.n128_u16[0] = a3[3];
      a9.n128_f32[0] = (float)a9.n128_u32[0];
      v23.f32[0] = (float)a7.u32[0];
      v23.f32[1] = (float)a6.n128_u32[0];
      v23.i64[1] = LODWORD(a8);
      v24.i32[0] = a9.n128_u32[0];
      v24.f32[1] = (float)a6.n128_u32[0];
      a6 = (__n128)vaddq_f32(vmulq_f32(v23, (float32x4_t)xmmword_1B83435C0), (float32x4_t)xmmword_1B7E734D0);
      v24.i64[1] = LODWORD(a8);
      a7 = vaddq_f32(vmulq_f32(v24, (float32x4_t)xmmword_1B83435C0), (float32x4_t)xmmword_1B7E734D0);
      unsigned int v25 = a2;
      *(__n128 *)a1 = a6;
      *(float32x4_t *)(a1 + 16) = a7;
      a1 += 32;
      a3 += 4;
      a2 -= 2;
    }
    while (v25 > 3);
  }
  if (a2 == 1)
  {
    result.i16[0] = *a3;
    LOWORD(a5) = a3[1];
    a6.n128_u16[0] = a3[2];
    v26.f32[0] = (float)LODWORD(a5);
    v26.f32[1] = (float)result.u32[0];
    v26.i64[1] = COERCE_UNSIGNED_INT((float)a6.n128_u32[0]);
    __n128 result = vaddq_f32(vmulq_f32(v26, (float32x4_t)xmmword_1B83435C0), (float32x4_t)xmmword_1B7E734D0);
    *(float32x4_t *)a1 = result;
  }
  return result;
}

uint64_t hg_span_read_3b(uint64_t result, int a2, int8x16_t *a3, double a4, double a5, __n128 a6, float a7, float32x4_t a8)
{
  if (a2 >= 1 && (a3 & 0xF) != 0)
  {
    unint64_t v8 = &a3->i8[3];
    float32x4_t v9 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    do
    {
      unsigned int v10 = a2;
      a6.n128_u8[0] = a3->i8[0];
      LOBYTE(a7) = a3->i8[1];
      a7 = (float)LODWORD(a7);
      a8.i8[0] = a3->i8[2];
      v11.i32[3] = 0;
      v11.f32[0] = (float)a6.n128_u32[0];
      v11.f32[1] = a7;
      v11.f32[2] = (float)a8.u32[0];
      a6 = (__n128)vaddq_f32(vmulq_f32(v11, v9), (float32x4_t)xmmword_1B7E734D0);
      *(__n128 *)__n128 result = a6;
      result += 16;
      a3 = (int8x16_t *)((char *)a3 + 3);
      --a2;
      if (v10 < 2) {
        break;
      }
      uint64_t v12 = v8 & 0xF;
      v8 += 3;
    }
    while (v12);
  }
  if (a2 >= 16)
  {
    a6.n128_u32[0] = -248;
    a7 = NAN;
    a8 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    do
    {
      unsigned int v13 = a2;
      float32x4_t v14 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(*a3, (int8x16_t)xmmword_1B8343550)), a8);
      int8x16_t v15 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(*a3, (int8x16_t)xmmword_1B8343560)), a8);
      float32x4_t v16 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(*a3, (int8x16_t)xmmword_1B8343580)), a8);
      float32x4_t v17 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(*a3, (int8x16_t)xmmword_1B8343590)), a8);
      float32x4_t v18 = vaddq_f32(vmulq_f32(v14, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
      int8x16_t v19 = (int8x16_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v14, v15, 8uLL), (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0);
      *(float32x4_t *)__n128 result = v18;
      *(int8x16_t *)(result + 16) = vextq_s8(v19, v19, 4uLL);
      float32x4_t v20 = vaddq_f32(vmulq_f32((float32x4_t)vextq_s8(v15, (int8x16_t)v16, 8uLL), (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
      int8x16_t v21 = (int8x16_t)vaddq_f32(vmulq_f32(v16, (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0);
      *(float32x4_t *)(result + 32) = v20;
      *(int8x16_t *)(result + 48) = vextq_s8(v21, v21, 4uLL);
      *(float32x4_t *)(result + 64) = vaddq_f32(vmulq_f32(v17, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
      int8x16_t v22 = a3[1];
      int8x16_t v23 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v22, (int8x16_t)xmmword_1B8343550)), a8);
      float32x4_t v24 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v22, (int8x16_t)xmmword_1B8343560)), a8);
      float32x4_t v25 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v22, (int8x16_t)xmmword_1B8343580)), a8);
      int8x16_t v26 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v22, (int8x16_t)xmmword_1B8343590)), a8);
      int8x16_t v27 = (int8x16_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v17, v23, 8uLL), (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0);
      *(int8x16_t *)(result + 80) = vextq_s8(v27, v27, 4uLL);
      *(float32x4_t *)(result + 96) = vaddq_f32(vmulq_f32((float32x4_t)vextq_s8(v23, (int8x16_t)v24, 8uLL), (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
      int8x16_t v28 = (int8x16_t)vaddq_f32(vmulq_f32(v24, (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0);
      *(int8x16_t *)(result + 112) = vextq_s8(v28, v28, 4uLL);
      *(float32x4_t *)(result + 128) = vaddq_f32(vmulq_f32(v25, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
      int8x16_t v29 = (int8x16_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v25, v26, 8uLL), (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0);
      *(int8x16_t *)(result + 144) = vextq_s8(v29, v29, 4uLL);
      int8x16_t v30 = a3[2];
      float32x4_t v31 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v30, (int8x16_t)xmmword_1B8343550)), a8);
      float32x4_t v32 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v30, (int8x16_t)xmmword_1B8343560)), a8);
      int8x16_t v33 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v30, (int8x16_t)xmmword_1B8343580)), a8);
      float32x4_t v34 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v30, (int8x16_t)xmmword_1B8343590)), a8);
      float32x4_t v35 = vaddq_f32(vmulq_f32((float32x4_t)vextq_s8(v26, (int8x16_t)v31, 8uLL), (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
      int8x16_t v36 = (int8x16_t)vaddq_f32(vmulq_f32(v31, (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0);
      *(float32x4_t *)(result + 160) = v35;
      *(int8x16_t *)(result + 176) = vextq_s8(v36, v36, 4uLL);
      int8x16_t v37 = (int8x16_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v32, v33, 8uLL), (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0);
      *(float32x4_t *)(result + 192) = vaddq_f32(vmulq_f32(v32, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
      *(int8x16_t *)(result + 208) = vextq_s8(v37, v37, 4uLL);
      float32x4_t v38 = vaddq_f32(vmulq_f32((float32x4_t)vextq_s8(v33, (int8x16_t)v34, 8uLL), (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
      int8x16_t v39 = (int8x16_t)vaddq_f32(vmulq_f32(v34, (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0);
      *(float32x4_t *)(result + 224) = v38;
      *(int8x16_t *)(result + 240) = vextq_s8(v39, v39, 4uLL);
      a3 += 3;
      result += 256;
      a2 -= 16;
    }
    while (v13 > 0x1F);
  }
  if (a2 >= 1)
  {
    unsigned int v40 = a2 + 1;
    float32x4_t v41 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    do
    {
      a6.n128_u8[0] = a3->i8[0];
      LOBYTE(a7) = a3->i8[1];
      a7 = (float)LODWORD(a7);
      a8.i8[0] = a3->i8[2];
      v42.i32[3] = 0;
      v42.f32[0] = (float)a6.n128_u32[0];
      v42.f32[1] = a7;
      v42.f32[2] = (float)a8.u32[0];
      a6 = (__n128)vaddq_f32(vmulq_f32(v42, v41), (float32x4_t)xmmword_1B7E734D0);
      *(__n128 *)__n128 result = a6;
      result += 16;
      a3 = (int8x16_t *)((char *)a3 + 3);
      --v40;
    }
    while (v40 > 1);
  }
  return result;
}

uint64_t hg_span_read_3b_zyx(uint64_t result, int a2, int8x16_t *a3, double a4, double a5, __n128 a6, float a7, float32x4_t a8)
{
  if (a2 >= 1 && (a3 & 0xF) != 0)
  {
    unint64_t v8 = &a3->i8[3];
    float32x4_t v9 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    do
    {
      unsigned int v10 = a2;
      a6.n128_u8[0] = a3->u8[2];
      LOBYTE(a7) = a3->i8[1];
      a7 = (float)LODWORD(a7);
      a8.i8[0] = a3->i8[0];
      v11.i32[3] = 0;
      v11.f32[0] = (float)a6.n128_u32[0];
      v11.f32[1] = a7;
      v11.f32[2] = (float)a8.u32[0];
      a6 = (__n128)vaddq_f32(vmulq_f32(v11, v9), (float32x4_t)xmmword_1B7E734D0);
      *(__n128 *)__n128 result = a6;
      result += 16;
      a3 = (int8x16_t *)((char *)a3 + 3);
      --a2;
      if (v10 < 2) {
        break;
      }
      uint64_t v12 = v8 & 0xF;
      v8 += 3;
    }
    while (v12);
  }
  if (a2 >= 16)
  {
    a6.n128_u32[0] = -248;
    a7 = NAN;
    a8 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    do
    {
      unsigned int v13 = a2;
      float32x4_t v14 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(*a3, (int8x16_t)xmmword_1B8343550)), a8);
      int8x16_t v15 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(*a3, (int8x16_t)xmmword_1B8343560)), a8);
      float32x4_t v16 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(*a3, (int8x16_t)xmmword_1B8343580)), a8);
      float32x4_t v17 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(*a3, (int8x16_t)xmmword_1B8343590)), a8);
      int8x16_t v18 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32(v14, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0));
      int8x16_t v19 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v14, v15, 8uLL), (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0));
      *(int8x16_t *)__n128 result = vextq_s8(v18, v18, 0xCuLL);
      *(int8x16_t *)(result + 16) = vextq_s8(v19, v19, 8uLL);
      int8x16_t v20 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8(v15, (int8x16_t)v16, 8uLL), (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0));
      int8x16_t v21 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32(v16, (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0));
      *(int8x16_t *)(result + 32) = vextq_s8(v20, v20, 0xCuLL);
      *(int8x16_t *)(result + 48) = vextq_s8(v21, v21, 8uLL);
      int8x16_t v22 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32(v17, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0));
      *(int8x16_t *)(result + 64) = vextq_s8(v22, v22, 0xCuLL);
      int8x16_t v23 = a3[1];
      int8x16_t v24 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v23, (int8x16_t)xmmword_1B8343550)), a8);
      float32x4_t v25 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v23, (int8x16_t)xmmword_1B8343560)), a8);
      float32x4_t v26 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v23, (int8x16_t)xmmword_1B8343580)), a8);
      int8x16_t v27 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v23, (int8x16_t)xmmword_1B8343590)), a8);
      int8x16_t v28 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v17, v24, 8uLL), (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0));
      int8x16_t v29 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8(v24, (int8x16_t)v25, 8uLL), (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0));
      *(int8x16_t *)(result + 80) = vextq_s8(v28, v28, 8uLL);
      *(int8x16_t *)(result + 96) = vextq_s8(v29, v29, 0xCuLL);
      int8x16_t v30 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32(v25, (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0));
      int8x16_t v31 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32(v26, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0));
      *(int8x16_t *)(result + 112) = vextq_s8(v30, v30, 8uLL);
      *(int8x16_t *)(result + 128) = vextq_s8(v31, v31, 0xCuLL);
      int8x16_t v32 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v26, v27, 8uLL), (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0));
      *(int8x16_t *)(result + 144) = vextq_s8(v32, v32, 8uLL);
      int8x16_t v33 = a3[2];
      float32x4_t v34 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v33, (int8x16_t)xmmword_1B8343550)), a8);
      float32x4_t v35 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v33, (int8x16_t)xmmword_1B8343560)), a8);
      int8x16_t v36 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v33, (int8x16_t)xmmword_1B8343580)), a8);
      float32x4_t v37 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(v33, (int8x16_t)xmmword_1B8343590)), a8);
      int8x16_t v38 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8(v27, (int8x16_t)v34, 8uLL), (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0));
      int8x16_t v39 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32(v34, (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0));
      *(int8x16_t *)(result + 160) = vextq_s8(v38, v38, 0xCuLL);
      *(int8x16_t *)(result + 176) = vextq_s8(v39, v39, 8uLL);
      int8x16_t v40 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32(v35, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0));
      int8x16_t v41 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v35, v36, 8uLL), (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0));
      *(int8x16_t *)(result + 192) = vextq_s8(v40, v40, 0xCuLL);
      *(int8x16_t *)(result + 208) = vextq_s8(v41, v41, 8uLL);
      int8x16_t v42 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8(v36, (int8x16_t)v37, 8uLL), (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0));
      int8x16_t v43 = (int8x16_t)vrev64q_s32((int32x4_t)vaddq_f32(vmulq_f32(v37, (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0));
      *(int8x16_t *)(result + 224) = vextq_s8(v42, v42, 0xCuLL);
      *(int8x16_t *)(result + 240) = vextq_s8(v43, v43, 8uLL);
      a3 += 3;
      result += 256;
      a2 -= 16;
    }
    while (v13 > 0x1F);
  }
  if (a2 >= 1)
  {
    unsigned int v44 = a2 + 1;
    uint64_t v45 = &a3->u8[2];
    float32x4_t v46 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    do
    {
      a6.n128_u8[0] = *v45;
      LOBYTE(a7) = *(v45 - 1);
      a7 = (float)LODWORD(a7);
      a8.i8[0] = *(v45 - 2);
      v47.i32[3] = 0;
      v47.f32[0] = (float)a6.n128_u32[0];
      v47.f32[1] = a7;
      v47.f32[2] = (float)a8.u32[0];
      a6 = (__n128)vaddq_f32(vmulq_f32(v47, v46), (float32x4_t)xmmword_1B7E734D0);
      *(__n128 *)__n128 result = a6;
      result += 16;
      --v44;
      v45 += 3;
    }
    while (v44 > 1);
  }
  return result;
}

uint64_t hg_span_read_3s(uint64_t result, int a2, int16x8_t *a3, double a4, double a5, float32x4_t a6, float a7, float a8)
{
  if (a2 >= 1 && (a3 & 0xF) != 0)
  {
    unint64_t v8 = &a3->i8[6];
    float32x4_t v9 = (float32x4_t)vdupq_n_s32(0x37800080u);
    do
    {
      unsigned int v10 = a2;
      a6.i16[0] = a3->i16[0];
      LOWORD(a7) = a3->i16[1];
      a7 = (float)LODWORD(a7);
      LOWORD(a8) = a3->i16[2];
      v11.i32[3] = 0;
      v11.f32[0] = (float)a6.u32[0];
      v11.f32[1] = a7;
      v11.f32[2] = (float)LODWORD(a8);
      a6 = vaddq_f32(vmulq_f32(v11, v9), (float32x4_t)xmmword_1B7E734D0);
      *(float32x4_t *)__n128 result = a6;
      result += 16;
      a3 = (int16x8_t *)((char *)a3 + 6);
      --a2;
      if (v10 < 2) {
        break;
      }
      uint64_t v12 = v8 & 0xF;
      v8 += 6;
    }
    while (v12);
  }
  if (a2 >= 8)
  {
    a6 = (float32x4_t)vdupq_n_s32(0x37800080u);
    HIWORD(a7) = 16256;
    HIWORD(a8) = 0;
    do
    {
      unsigned int v13 = a2;
      float32x4_t v14 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vzip1q_s16(*a3, (int16x8_t)0)), a6);
      int8x16_t v15 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(*(int8x16_t *)a3, (int8x16_t)xmmword_1B83435D0)), a6);
      float32x4_t v16 = vaddq_f32(vmulq_f32(v14, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
      int8x16_t v17 = (int8x16_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v14, v15, 8uLL), (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0);
      *(float32x4_t *)__n128 result = v16;
      *(int8x16_t *)(result + 16) = vextq_s8(v17, v17, 4uLL);
      int16x8_t v18 = a3[1];
      float32x4_t v19 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vzip1q_s16(v18, (int16x8_t)0)), a6);
      float32x4_t v20 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8((int8x16_t)v18, (int8x16_t)xmmword_1B83435D0)), a6);
      float32x4_t v21 = vaddq_f32(vmulq_f32((float32x4_t)vextq_s8(v15, (int8x16_t)v19, 8uLL), (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
      int8x16_t v22 = (int8x16_t)vaddq_f32(vmulq_f32(v19, (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0);
      *(float32x4_t *)(result + 32) = v21;
      *(int8x16_t *)(result + 48) = vextq_s8(v22, v22, 4uLL);
      *(float32x4_t *)(result + 64) = vaddq_f32(vmulq_f32(v20, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
      int16x8_t v23 = a3[2];
      int8x16_t v24 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vzip1q_s16(v23, (int16x8_t)0)), a6);
      float32x4_t v25 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8((int8x16_t)v23, (int8x16_t)xmmword_1B83435D0)), a6);
      int8x16_t v26 = (int8x16_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)v20, v24, 8uLL), (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0);
      *(int8x16_t *)(result + 80) = vextq_s8(v26, v26, 4uLL);
      *(float32x4_t *)(result + 96) = vaddq_f32(vmulq_f32((float32x4_t)vextq_s8(v24, (int8x16_t)v25, 8uLL), (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
      int8x16_t v27 = (int8x16_t)vaddq_f32(vmulq_f32(v25, (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0);
      *(int8x16_t *)(result + 112) = vextq_s8(v27, v27, 4uLL);
      a3 += 3;
      result += 128;
      a2 -= 8;
    }
    while (v13 > 0xF);
  }
  if (a2 >= 1)
  {
    unsigned int v28 = a2 + 1;
    float32x4_t v29 = (float32x4_t)vdupq_n_s32(0x37800080u);
    do
    {
      a6.i16[0] = a3->i16[0];
      LOWORD(a7) = a3->i16[1];
      a7 = (float)LODWORD(a7);
      LOWORD(a8) = a3->i16[2];
      v30.i32[3] = 0;
      v30.f32[0] = (float)a6.u32[0];
      v30.f32[1] = a7;
      v30.f32[2] = (float)LODWORD(a8);
      a6 = vaddq_f32(vmulq_f32(v30, v29), (float32x4_t)xmmword_1B7E734D0);
      *(float32x4_t *)__n128 result = a6;
      result += 16;
      --v28;
      a3 = (int16x8_t *)((char *)a3 + 6);
    }
    while (v28 > 1);
  }
  return result;
}

uint64_t hg_span_read_3f(uint64_t result, int a2, uint64_t a3)
{
  if (a2 >= 1 && (a3 & 0xF) != 0)
  {
    uint64_t v3 = a3 + 12;
    do
    {
      unsigned int v4 = a2;
      v5.i64[0] = *(void *)a3;
      v5.i64[1] = *(unsigned int *)(a3 + 8);
      *(float32x4_t *)__n128 result = vaddq_f32(v5, (float32x4_t)xmmword_1B7E734D0);
      result += 16;
      a3 += 12;
      --a2;
      if (v4 < 2) {
        break;
      }
      uint64_t v6 = v3 & 0xF;
      v3 += 12;
    }
    while (v6);
  }
  if (a2 >= 4)
  {
    do
    {
      unsigned int v7 = a2;
      int8x16_t v8 = *(int8x16_t *)a3;
      *(float32x4_t *)__n128 result = vaddq_f32(vmulq_f32(*(float32x4_t *)a3, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
      int8x16_t v9 = *(int8x16_t *)(a3 + 16);
      int8x16_t v10 = (int8x16_t)vaddq_f32(vmulq_f32((float32x4_t)vextq_s8(v8, v9, 8uLL), (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0);
      *(int8x16_t *)(result + 16) = vextq_s8(v10, v10, 4uLL);
      float32x4_t v11 = *(float32x4_t *)(a3 + 32);
      float32x4_t v12 = vaddq_f32(vmulq_f32((float32x4_t)vextq_s8(v9, (int8x16_t)v11, 8uLL), (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
      int8x16_t v13 = (int8x16_t)vaddq_f32(vmulq_f32(v11, (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0);
      *(float32x4_t *)(result + 32) = v12;
      *(int8x16_t *)(result + 48) = vextq_s8(v13, v13, 4uLL);
      a3 += 48;
      result += 64;
      a2 -= 4;
    }
    while (v7 > 7);
  }
  if (a2 >= 1)
  {
    unsigned int v14 = a2 + 1;
    do
    {
      v15.i64[0] = *(void *)a3;
      v15.i64[1] = *(unsigned int *)(a3 + 8);
      *(float32x4_t *)__n128 result = vaddq_f32(v15, (float32x4_t)xmmword_1B7E734D0);
      result += 16;
      --v14;
      a3 += 12;
    }
    while (v14 > 1);
  }
  return result;
}

int32x4_t hg_span_read_4b_wxyz(int8x16_t *a1, int a2, const float *a3, int32x4_t result)
{
  if (a2 >= 1 && (a3 & 0xF) != 0)
  {
    unsigned int v4 = a3 + 1;
    __n128 result = vdupq_n_s32(0x3B808081u);
    do
    {
      unsigned int v5 = a2;
      uint8x8_t v6 = (uint8x8_t)vld1_dup_f32(a3++);
      int8x16_t v7 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(v6))), (float32x4_t)result);
      *a1++ = vextq_s8(v7, v7, 4uLL);
      --a2;
      if (v5 < 2) {
        break;
      }
    }
    while (v4++ & 0xF);
  }
  if (a2 >= 4)
  {
    __n128 result = vdupq_n_s32(0x3B808081u);
    do
    {
      unsigned int v9 = a2;
      uint8x16_t v10 = *(uint8x16_t *)a3;
      a3 += 4;
      uint16x8_t v11 = vmovl_u8(*(uint8x8_t *)v10.i8);
      uint16x8_t v12 = vmovl_high_u8(v10);
      int8x16_t v13 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v11.i8)), (float32x4_t)result);
      int8x16_t v14 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_high_u16(v11)), (float32x4_t)result);
      int8x16_t v15 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v12.i8)), (float32x4_t)result);
      int8x16_t v16 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_high_u16(v12)), (float32x4_t)result);
      *a1 = vextq_s8(v13, v13, 4uLL);
      a1[1] = vextq_s8(v14, v14, 4uLL);
      a1[2] = vextq_s8(v15, v15, 4uLL);
      a1[3] = vextq_s8(v16, v16, 4uLL);
      a1 += 4;
      a2 -= 4;
    }
    while (v9 > 7);
  }
  if (a2 >= 1)
  {
    __n128 result = *(int32x4_t *)a3;
    unsigned int v17 = a2 + 1;
    float32x4_t v18 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    do
    {
      int8x16_t v19 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)result.i8))), v18);
      *a1++ = vextq_s8(v19, v19, 4uLL);
      __n128 result = (int32x4_t)vextq_s8((int8x16_t)result, (int8x16_t)result, 4uLL);
      --v17;
    }
    while (v17 > 1);
  }
  return result;
}

int32x4_t hg_span_read_4b_zyxw(int32x4_t *a1, int a2, const float *a3, int32x4_t result)
{
  if (a2 >= 1 && (a3 & 0xF) != 0)
  {
    unsigned int v4 = a3 + 1;
    __n128 result = vdupq_n_s32(0x3B808081u);
    do
    {
      uint8x8_t v5 = (uint8x8_t)vld1_dup_f32(a3++);
      unsigned int v6 = a2;
      int8x16_t v7 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(v5))), (float32x4_t)result);
      *a1++ = vrev64q_s32((int32x4_t)vextq_s8(v7, v7, 4uLL));
      --a2;
      if (v6 < 2) {
        break;
      }
    }
    while (v4++ & 0xF);
  }
  if (a2 >= 4)
  {
    __n128 result = vdupq_n_s32(0x3B808081u);
    do
    {
      uint8x16_t v9 = *(uint8x16_t *)a3;
      a3 += 4;
      unsigned int v10 = a2;
      uint16x8_t v11 = vmovl_u8(*(uint8x8_t *)v9.i8);
      uint16x8_t v12 = vmovl_high_u8(v9);
      int8x16_t v13 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v11.i8)), (float32x4_t)result);
      int8x16_t v14 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_high_u16(v11)), (float32x4_t)result);
      int8x16_t v15 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v12.i8)), (float32x4_t)result);
      int8x16_t v16 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_high_u16(v12)), (float32x4_t)result);
      *a1 = vrev64q_s32((int32x4_t)vextq_s8(v13, v13, 4uLL));
      a1[1] = vrev64q_s32((int32x4_t)vextq_s8(v14, v14, 4uLL));
      a1[2] = vrev64q_s32((int32x4_t)vextq_s8(v15, v15, 4uLL));
      a1[3] = vrev64q_s32((int32x4_t)vextq_s8(v16, v16, 4uLL));
      a1 += 4;
      a2 -= 4;
    }
    while (v10 > 7);
  }
  if (a2 >= 1)
  {
    __n128 result = *(int32x4_t *)a3;
    unsigned int v17 = a2 + 1;
    float32x4_t v18 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    do
    {
      int8x16_t v19 = (int8x16_t)vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)result.i8))), v18);
      *a1++ = vrev64q_s32((int32x4_t)vextq_s8(v19, v19, 4uLL));
      __n128 result = (int32x4_t)vextq_s8((int8x16_t)result, (int8x16_t)result, 4uLL);
      --v17;
    }
    while (v17 > 1);
  }
  return result;
}

int32x4_t hg_span_read_4b_xyzw(float32x4_t *a1, int a2, const float *a3, int32x4_t result)
{
  if (a2 >= 1 && (a3 & 0xF) != 0)
  {
    unsigned int v4 = a3 + 1;
    __n128 result = vdupq_n_s32(0x3B808081u);
    do
    {
      unsigned int v5 = a2;
      uint8x8_t v6 = (uint8x8_t)vld1_dup_f32(a3++);
      *a1++ = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(v6))), (float32x4_t)result);
      --a2;
      if (v5 < 2) {
        break;
      }
    }
    while (v4++ & 0xF);
  }
  if (a2 >= 4)
  {
    __n128 result = vdupq_n_s32(0x3B808081u);
    do
    {
      unsigned int v8 = a2;
      uint8x16_t v9 = *(uint8x16_t *)a3;
      a3 += 4;
      uint16x8_t v10 = vmovl_u8(*(uint8x8_t *)v9.i8);
      uint16x8_t v11 = vmovl_high_u8(v9);
      *a1 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v10.i8)), (float32x4_t)result);
      a1[1] = vmulq_f32(vcvtq_f32_u32(vmovl_high_u16(v10)), (float32x4_t)result);
      a1[2] = vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)v11.i8)), (float32x4_t)result);
      a1[3] = vmulq_f32(vcvtq_f32_u32(vmovl_high_u16(v11)), (float32x4_t)result);
      a1 += 4;
      a2 -= 4;
    }
    while (v8 > 7);
  }
  if (a2 >= 1)
  {
    __n128 result = *(int32x4_t *)a3;
    unsigned int v12 = a2 + 1;
    float32x4_t v13 = (float32x4_t)vdupq_n_s32(0x3B808081u);
    do
    {
      *a1++ = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)result.i8))), v13);
      __n128 result = (int32x4_t)vextq_s8((int8x16_t)result, (int8x16_t)result, 4uLL);
      --v12;
    }
    while (v12 > 1);
  }
  return result;
}

float32x4_t hg_span_read_4s(float32x4_t *a1, int a2, int16x8_t *a3)
{
  if (a2 >= 1 && (a3 & 0xF) != 0)
  {
    float32x4_t result = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(*(int8x16_t *)((char *)&a3[-1] + 8), (int8x16_t)xmmword_1B83435D0)), (float32x4_t)vdupq_n_s32(0x37800080u));
    *a1++ = result;
    a3 = (int16x8_t *)((char *)a3 + 8);
    --a2;
  }
  if (a2 > 1)
  {
    float32x4_t result = 0uLL;
    float32x4_t v4 = (float32x4_t)vdupq_n_s32(0x37800080u);
    do
    {
      int16x8_t v5 = *a3++;
      unsigned int v6 = a2;
      *a1 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vzip1q_s16(v5, (int16x8_t)0)), v4);
      a1[1] = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8((int8x16_t)v5, (int8x16_t)xmmword_1B83435D0)), v4);
      a1 += 2;
      a2 -= 2;
    }
    while (v6 > 3);
  }
  if (a2)
  {
    float32x4_t result = vmulq_f32(vcvtq_f32_s32((int32x4_t)vzip1q_s16(*a3, (int16x8_t)0)), (float32x4_t)vdupq_n_s32(0x37800080u));
    *a1 = result;
  }
  return result;
}

int8x16_t hg_span_read_4s_wxyz(int8x16_t *a1, int a2, int16x8_t *a3)
{
  if (a2 >= 1 && (a3 & 0xF) != 0)
  {
    int8x16_t v3 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(*(int8x16_t *)((char *)&a3[-1] + 8), (int8x16_t)xmmword_1B83435D0)), (float32x4_t)vdupq_n_s32(0x37800080u));
    int8x16_t result = vextq_s8(v3, v3, 4uLL);
    *a1++ = result;
    a3 = (int16x8_t *)((char *)a3 + 8);
    --a2;
  }
  if (a2 > 1)
  {
    int8x16_t result = 0uLL;
    float32x4_t v5 = (float32x4_t)vdupq_n_s32(0x37800080u);
    do
    {
      unsigned int v6 = a2;
      int16x8_t v7 = *a3++;
      int8x16_t v8 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vzip1q_s16(v7, (int16x8_t)0)), v5);
      int8x16_t v9 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8((int8x16_t)v7, (int8x16_t)xmmword_1B83435D0)), v5);
      *a1 = vextq_s8(v8, v8, 4uLL);
      a1[1] = vextq_s8(v9, v9, 4uLL);
      a1 += 2;
      a2 -= 2;
    }
    while (v6 > 3);
  }
  if (a2)
  {
    int8x16_t v10 = (int8x16_t)vmulq_f32(vcvtq_f32_s32((int32x4_t)vzip1q_s16(*a3, (int16x8_t)0)), (float32x4_t)vdupq_n_s32(0x37800080u));
    int8x16_t result = vextq_s8(v10, v10, 4uLL);
    *a1 = result;
  }
  return result;
}

float32x4_t *hg_span_read_4h(float32x4_t *result, int a2, float16x4_t *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    do
    {
      float16x4_t v4 = *a3++;
      *result++ = vcvtq_f32_f16(v4);
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

_OWORD *hg_span_read_4f_xyzw(_OWORD *result, int a2, long long *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    do
    {
      long long v4 = *a3++;
      *result++ = v4;
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

int8x16_t *hg_span_read_4f_wxyz(int8x16_t *result, int a2, int8x16_t *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    do
    {
      int8x16_t v4 = *a3++;
      *result++ = vextq_s8(v4, v4, 4uLL);
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

float32x4_t hg_span_read_4b_10bit_yxzx_little_endian(float32x4_t *a1, int a2, uint64_t _X2, float32x4_t result)
{
  if (a2 >= 1)
  {
    if (_X2 <= 0) {
      uint64_t v4 = -(-_X2 & 0xF);
    }
    else {
      LOBYTE(v4) = _X2 & 0xF;
    }
    int v5 = v4;
    if ((_BYTE)v4)
    {
      int v6 = v4 - 2;
      int16x8_t v7 = (int8x16_t *)(_X2 - v4);
      v8.i64[0] = 0x300000003;
      v8.i64[1] = 0x300000003;
      int8x16_t result = vcvtq_f32_s32((int32x4_t)vandq_s8(*v7, v8));
      int32x4_t v9 = (int32x4_t)vcvtq_f32_s32((int32x4_t)vandq_s8((int8x16_t)vshrq_n_u32(*(uint32x4_t *)v7, 0xAuLL), v8));
      int32x4_t v10 = (int32x4_t)vcvtq_f32_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32(*(uint32x4_t *)v7, 0x14uLL) & __PAIR128__(0xFFFFF3FFFFFFF3FFLL, 0xFFFFF3FFFFFFF3FFLL)));
      switch(v6)
      {
        case 0:
          int8x16_t v11 = vextq_s8((int8x16_t)v9, (int8x16_t)vtrn1q_s32(v9, v10), 0xCuLL);
          v12.i64[0] = result.i64[0];
          v12.i64[1] = __PAIR64__(v11.u32[1], v11.u32[2]);
          int32x4_t v13 = (int32x4_t)vaddq_f32(vmulq_f32(vmulq_f32(v12, (float32x4_t)vdupq_n_s32(0x3A802008u)), (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
          int32x4_t v14 = vtrn1q_s32(v13, (int32x4_t)vextq_s8((int8x16_t)v13, (int8x16_t)v13, 0xCuLL));
          v12.i64[0] = vrev64q_s32(v14).u64[0];
          v12.i64[1] = v14.i64[1];
          float32x4_t v15 = v12;
          v15.i32[0] = v12.i32[3];
          v15.i32[3] = v12.i32[0];
          *a1++ = v15;
          --a2;
          goto LABEL_8;
        case 3:
        case 6:
LABEL_8:
          int32x4_t v16 = vuzp2q_s32(vuzp1q_s32((int32x4_t)result, (int32x4_t)result), v10);
          int32x4_t v17 = (int32x4_t)vmulq_f32((float32x4_t)vzip2q_s32(vzip1q_s32(v9, v16), vtrn1q_s32(v9, v16)), (float32x4_t)vdupq_n_s32(0x3A802008u));
          int32x4_t v18 = vtrn1q_s32(v17, (int32x4_t)vextq_s8((int8x16_t)v17, (int8x16_t)v17, 0xCuLL));
          v19.i64[0] = vrev64q_s32(v18).u64[0];
          v19.i64[1] = v18.i64[1];
          float32x4_t v20 = vaddq_f32(vmulq_f32(v19, (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0);
          float32x4_t v21 = v20;
          v21.i32[0] = v20.i32[3];
          v21.i32[3] = v20.i32[0];
          if (v5 == 8)
          {
            int v22 = -1;
            uint64_t v23 = 1;
            int8x16_t v24 = a1;
          }
          else
          {
            *a1 = vaddq_f32(vmulq_f32(v19, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
            int8x16_t v24 = a1 + 1;
            int v22 = -2;
            uint64_t v23 = 2;
          }
          *int8x16_t v24 = v21;
          a1 += v23;
          a2 += v22;
          goto LABEL_12;
        case 8:
        case 11:
LABEL_12:
          int8x16_t v25 = vextq_s8((int8x16_t)vtrn2q_s32((int32x4_t)result, v9), (int8x16_t)result, 4uLL);
          float32x4_t v26 = (float32x4_t)vextq_s8((int8x16_t)v10, v25, 8uLL);
          v26.i32[2] = v25.i32[2];
          int32x4_t v27 = (int32x4_t)vmulq_f32(v26, (float32x4_t)vdupq_n_s32(0x3A802008u));
          int32x4_t v28 = vtrn1q_s32(v27, (int32x4_t)vextq_s8((int8x16_t)v27, (int8x16_t)v27, 0xCuLL));
          v29.i64[0] = vrev64q_s32(v28).u64[0];
          v29.i64[1] = v28.i64[1];
          float32x4_t v30 = vaddq_f32(vmulq_f32(v29, (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0);
          int8x16_t result = v30;
          result.i32[0] = v30.i32[3];
          result.i32[3] = v30.i32[0];
          if (v5 == 13)
          {
            int v31 = -1;
            uint64_t v32 = 1;
            int8x16_t v33 = a1;
          }
          else
          {
            *a1 = vaddq_f32(vmulq_f32(v29, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
            int8x16_t v33 = a1 + 1;
            int v31 = -2;
            uint64_t v32 = 2;
          }
          *int8x16_t v33 = result;
          a1 += v32;
          a2 += v31;
          break;
        default:
          break;
      }
      _X2 += 16 - v5;
    }
    if (a2 >= 6)
    {
      int8x16_t v34 = *(int8x16_t *)_X2;
      int8x16_t v35 = 0uLL;
      result.i64[0] = 0x300000003;
      result.i64[1] = 0x300000003;
      float32x4_t v36 = (float32x4_t)vdupq_n_s32(0x3A802008u);
      do
      {
        if (a2 >= 0xC)
        {
          int8x16_t v35 = *(int8x16_t *)(_X2 + 16);
          __asm { PRFM            #0, [X2,#0x40] }
        }
        int32x4_t v37 = (int32x4_t)vcvtq_f32_s32((int32x4_t)vandq_s8(v34, (int8x16_t)result));
        float32x4_t v38 = vcvtq_f32_s32((int32x4_t)vandq_s8((int8x16_t)vshrq_n_u32((uint32x4_t)v34, 0xAuLL), (int8x16_t)result));
        int32x4_t v39 = (int32x4_t)vcvtq_f32_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v34, 0x14uLL) & __PAIR128__(0xFFFFF3FFFFFFF3FFLL, 0xFFFFF3FFFFFFF3FFLL)));
        int8x16_t v40 = vextq_s8((int8x16_t)v38, (int8x16_t)vtrn1q_s32((int32x4_t)v38, v39), 0xCuLL);
        v41.i64[0] = v37.i64[0];
        v41.i64[1] = __PAIR64__(v40.u32[1], v40.u32[2]);
        int32x4_t v42 = (int32x4_t)vmulq_f32(v41, v36);
        int32x4_t v43 = vtrn1q_s32(v42, (int32x4_t)vextq_s8((int8x16_t)v42, (int8x16_t)v42, 0xCuLL));
        v41.i64[0] = vrev64q_s32(v43).u64[0];
        v41.i64[1] = v43.i64[1];
        int8x16_t v44 = vextq_s8((int8x16_t)vtrn2q_s32(v37, (int32x4_t)v38), (int8x16_t)v37, 4uLL);
        float32x4_t v45 = vaddq_f32(vmulq_f32(v41, (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0);
        float32x4_t v46 = v45;
        v46.i32[0] = v45.i32[3];
        v46.i32[3] = v45.i32[0];
        a2 -= 6;
        *a1 = vaddq_f32(vmulq_f32(v41, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
        a1[1] = v46;
        int32x4_t v47 = vuzp2q_s32(vuzp1q_s32(v37, v37), v39);
        int32x4_t v48 = (int32x4_t)vmulq_f32((float32x4_t)vzip2q_s32(vzip1q_s32((int32x4_t)v38, v47), vtrn1q_s32((int32x4_t)v38, v47)), v36);
        int32x4_t v49 = vtrn1q_s32(v48, (int32x4_t)vextq_s8((int8x16_t)v48, (int8x16_t)v48, 0xCuLL));
        v38.i64[0] = vrev64q_s32(v49).u64[0];
        v38.i64[1] = v49.i64[1];
        float32x4_t v50 = vmulq_f32(v38, (float32x4_t)xmmword_1B7E75890);
        float32x4_t v51 = vaddq_f32(vmulq_f32(v38, (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0);
        float32x4_t v52 = v51;
        v52.i32[0] = v51.i32[3];
        v52.i32[3] = v51.i32[0];
        a1[2] = vaddq_f32(v50, (float32x4_t)xmmword_1B7E734D0);
        a1[3] = v52;
        float32x4_t v53 = (float32x4_t)vextq_s8((int8x16_t)v39, v44, 8uLL);
        v53.i32[2] = v44.i32[2];
        int32x4_t v54 = (int32x4_t)vmulq_f32(v53, v36);
        int32x4_t v55 = vtrn1q_s32(v54, (int32x4_t)vextq_s8((int8x16_t)v54, (int8x16_t)v54, 0xCuLL));
        v50.i64[0] = vrev64q_s32(v55).u64[0];
        v50.i64[1] = v55.i64[1];
        float32x4_t v56 = vaddq_f32(vmulq_f32(v50, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
        float32x4_t v57 = vaddq_f32(vmulq_f32(v50, (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0);
        float32x4_t v58 = v57;
        v58.i32[0] = v57.i32[3];
        v58.i32[3] = v57.i32[0];
        a1[4] = v56;
        a1[5] = v58;
        _X2 += 16;
        a1 += 6;
        int8x16_t v34 = v35;
      }
      while ((a2 + 6) > 0xB);
    }
    if (a2 >= 1)
    {
      v64.i64[0] = 0x300000003;
      v64.i64[1] = 0x300000003;
      int8x16_t result = vcvtq_f32_s32((int32x4_t)vandq_s8(*(int8x16_t *)_X2, v64));
      int32x4_t v65 = (int32x4_t)vcvtq_f32_s32((int32x4_t)vandq_s8((int8x16_t)vshrq_n_u32(*(uint32x4_t *)_X2, 0xAuLL), v64));
      int32x4_t v66 = (int32x4_t)vcvtq_f32_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32(*(uint32x4_t *)_X2, 0x14uLL) & __PAIR128__(0xFFFFF3FFFFFFF3FFLL, 0xFFFFF3FFFFFFF3FFLL)));
      if ((a2 - 1) >= 2)
      {
        if ((a2 - 3) >= 2)
        {
          if (a2 != 5) {
            return result;
          }
          int8x16_t v67 = vextq_s8((int8x16_t)vtrn2q_s32((int32x4_t)result, v65), (int8x16_t)result, 4uLL);
          float32x4_t v68 = (float32x4_t)vextq_s8((int8x16_t)v66, v67, 8uLL);
          v68.i32[2] = v67.i32[2];
          int32x4_t v69 = (int32x4_t)vaddq_f32(vmulq_f32(vmulq_f32(v68, (float32x4_t)vdupq_n_s32(0x3A802008u)), (float32x4_t)xmmword_1B7E76EF0), (float32x4_t)xmmword_1B7E736C0);
          int32x4_t v70 = vtrn1q_s32(v69, (int32x4_t)vextq_s8((int8x16_t)v69, (int8x16_t)v69, 0xCuLL));
          v68.i64[0] = vrev64q_s32(v70).u64[0];
          v68.i64[1] = v70.i64[1];
          a1[4] = v68;
        }
        int32x4_t v71 = vuzp2q_s32(vuzp1q_s32((int32x4_t)result, (int32x4_t)result), v66);
        int32x4_t v72 = (int32x4_t)vmulq_f32((float32x4_t)vzip2q_s32(vzip1q_s32(v65, v71), vtrn1q_s32(v65, v71)), (float32x4_t)vdupq_n_s32(0x3A802008u));
        int32x4_t v73 = vtrn1q_s32(v72, (int32x4_t)vextq_s8((int8x16_t)v72, (int8x16_t)v72, 0xCuLL));
        v74.i64[0] = vrev64q_s32(v73).u64[0];
        v74.i64[1] = v73.i64[1];
        a1[2] = vaddq_f32(vmulq_f32(v74, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
        if (a2 >= 4)
        {
          float32x4_t v75 = vaddq_f32(vmulq_f32(v74, (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0);
          float32x4_t v76 = v75;
          v76.i32[0] = v75.i32[3];
          v76.i32[3] = v75.i32[0];
          a1[3] = v76;
        }
      }
      int8x16_t v77 = vextq_s8((int8x16_t)v65, (int8x16_t)vtrn1q_s32(v65, v66), 0xCuLL);
      result.i64[1] = __PAIR64__(v77.u32[1], v77.u32[2]);
      int32x4_t v78 = (int32x4_t)vmulq_f32(result, (float32x4_t)vdupq_n_s32(0x3A802008u));
      int32x4_t v79 = vtrn1q_s32(v78, (int32x4_t)vextq_s8((int8x16_t)v78, (int8x16_t)v78, 0xCuLL));
      result.i64[0] = vrev64q_s32(v79).u64[0];
      result.i64[1] = v79.i64[1];
      *a1 = vaddq_f32(vmulq_f32(result, (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
      if (a2 >= 2)
      {
        int8x16_t result = vaddq_f32(vmulq_f32(result, (float32x4_t)xmmword_1B83435F0), (float32x4_t)xmmword_1B7E736B0);
        float32x4_t v80 = result;
        v80.i32[0] = result.i32[3];
        v80.i32[3] = result.i32[0];
        a1[1] = v80;
      }
    }
  }
  return result;
}

float32x4_t hg_span_read_4b_10bit_big_endian(float32x4_t *a1, int a2, uint64_t _X2, float32x4_t result)
{
  if (a2 < 1) {
    return result;
  }
  LOBYTE(v4) = _X2 & 0xF;
  if (_X2 <= 0) {
    uint64_t v4 = -(-_X2 & 0xF);
  }
  if ((_BYTE)v4)
  {
    uint32x4_t v5 = (uint32x4_t)vrev32q_s8(*(int8x16_t *)(_X2 - v4));
    v6.i64[0] = 0x300000003;
    v6.i64[1] = 0x300000003;
    int32x4_t v7 = (int32x4_t)vandq_s8((int8x16_t)vshrq_n_u32(v5, 2uLL), v6);
    int32x4_t v8 = (int32x4_t)vandq_s8((int8x16_t)vshrq_n_u32(v5, 0xCuLL), v6);
    int32x4_t v9 = (int32x4_t)vshrq_n_u32(v5, 0x16uLL);
    int8x16_t result = vcvtq_f32_s32(v7);
    int32x4_t v10 = (int32x4_t)vcvtq_f32_s32(v8);
    int32x4_t v11 = (int32x4_t)vcvtq_f32_s32(v9);
    if (v4 != 12)
    {
      if (v4 != 8)
      {
        if (v4 != 4)
        {
LABEL_11:
          _X2 += 16 - v4;
          goto LABEL_12;
        }
        *a1++ = vaddq_f32(vmulq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vrev64q_s32(vuzp2q_s32(v11, v10)), vdupq_lane_s32(*(int32x2_t *)result.f32, 1)), (float32x4_t)xmmword_1B8343600), (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
        --a2;
      }
      int32x4_t v12 = v10;
      v12.i32[0] = v11.i32[2];
      *a1++ = vaddq_f32(vmulq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vrev64q_s32(v12), vdupq_laneq_s32((int32x4_t)result, 2)), (float32x4_t)xmmword_1B8343600), (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
      --a2;
    }
    int8x16_t result = vaddq_f32(vmulq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vrev64q_s32(vtrn2q_s32(vuzp2q_s32(v11, v10), v11)), vdupq_laneq_s32((int32x4_t)result, 3)), (float32x4_t)xmmword_1B8343600), (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
    *a1++ = result;
    --a2;
    goto LABEL_11;
  }
LABEL_12:
  if (a2 >= 4)
  {
    int8x16_t v13 = *(int8x16_t *)_X2;
    int8x16_t v14 = 0uLL;
    result.i64[0] = 0x300000003;
    result.i64[1] = 0x300000003;
    do
    {
      if (a2 >= 8)
      {
        int8x16_t v14 = *(int8x16_t *)(_X2 + 16);
        __asm { PRFM            #0, [X2,#0x40] }
      }
      uint32x4_t v15 = (uint32x4_t)vrev32q_s8(v13);
      int32x4_t v16 = (int32x4_t)vcvtq_f32_s32((int32x4_t)vandq_s8((int8x16_t)vshrq_n_u32(v15, 2uLL), (int8x16_t)result));
      int32x4_t v17 = (int32x4_t)vcvtq_f32_s32((int32x4_t)vandq_s8((int8x16_t)vshrq_n_u32(v15, 0xCuLL), (int8x16_t)result));
      int32x4_t v18 = (int32x4_t)vcvtq_f32_s32((int32x4_t)vshrq_n_u32(v15, 0x16uLL));
      int32x4_t v19 = vuzp2q_s32(v18, v17);
      a2 -= 4;
      *a1 = vaddq_f32(vmulq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vrev64q_s32(vuzp1q_s32(v18, v17)), vdupq_lane_s32(*(int32x2_t *)v16.i8, 0)), (float32x4_t)xmmword_1B8343600), (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
      a1[1] = vaddq_f32(vmulq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vrev64q_s32(v19), vdupq_lane_s32(*(int32x2_t *)v16.i8, 1)), (float32x4_t)xmmword_1B8343600), (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
      v17.i32[0] = v18.i32[2];
      a1[2] = vaddq_f32(vmulq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vrev64q_s32(v17), vdupq_laneq_s32(v16, 2)), (float32x4_t)xmmword_1B8343600), (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
      a1[3] = vaddq_f32(vmulq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vrev64q_s32(vtrn2q_s32(v19, v18)), vdupq_laneq_s32(v16, 3)), (float32x4_t)xmmword_1B8343600), (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
      _X2 += 16;
      a1 += 4;
      int8x16_t v13 = v14;
    }
    while ((a2 + 4) > 7);
  }
  if (a2 >= 1)
  {
    uint32x4_t v25 = (uint32x4_t)vrev32q_s8(*(int8x16_t *)_X2);
    v26.i64[0] = 0x300000003;
    v26.i64[1] = 0x300000003;
    int32x4_t v27 = (int32x4_t)vandq_s8((int8x16_t)vshrq_n_u32(v25, 2uLL), v26);
    int32x4_t v28 = (int32x4_t)vandq_s8((int8x16_t)vshrq_n_u32(v25, 0xCuLL), v26);
    int32x4_t v29 = (int32x4_t)vshrq_n_u32(v25, 0x16uLL);
    int8x16_t result = vcvtq_f32_s32(v27);
    int32x4_t v30 = (int32x4_t)vcvtq_f32_s32(v28);
    int32x4_t v31 = (int32x4_t)vcvtq_f32_s32(v29);
    if (a2 != 1)
    {
      if (a2 != 2)
      {
        if (a2 != 3) {
          return result;
        }
        int32x4_t v32 = v30;
        v32.i32[0] = v31.i32[2];
        a1[2] = vaddq_f32(vmulq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vrev64q_s32(v32), vdupq_laneq_s32((int32x4_t)result, 2)), (float32x4_t)xmmword_1B8343600), (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
      }
      a1[1] = vaddq_f32(vmulq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vrev64q_s32(vuzp2q_s32(v31, v30)), vdupq_lane_s32(*(int32x2_t *)result.f32, 1)), (float32x4_t)xmmword_1B8343600), (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
    }
    int8x16_t result = vaddq_f32(vmulq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vrev64q_s32(vuzp1q_s32(v31, v30)), vdupq_lane_s32(*(int32x2_t *)result.f32, 0)), (float32x4_t)xmmword_1B8343600), (float32x4_t)xmmword_1B7E75890), (float32x4_t)xmmword_1B7E734D0);
    *a1 = result;
  }
  return result;
}

float32x4_t hg_span_read_4s_wxyz_big_endian(float32x4_t *a1, int a2, int8x16_t *a3)
{
  if (a2 >= 1 && (a3 & 0xF) != 0)
  {
    float32x4_t result = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8(vqtbl1q_s8(*(int8x16_t *)((char *)a3 - 8), (int8x16_t)xmmword_1B8343610), (int8x16_t)xmmword_1B83435D0)), (float32x4_t)vdupq_n_s32(0x37800080u));
    *a1++ = result;
    a3 = (int8x16_t *)((char *)a3 + 8);
    --a2;
  }
  if (a2 > 1)
  {
    result.i64[0] = 0x1060704050203;
    float32x4_t v4 = (float32x4_t)vdupq_n_s32(0x37800080u);
    do
    {
      unsigned int v5 = a2;
      int8x16_t v6 = *a3++;
      int16x8_t v7 = (int16x8_t)vqtbl1q_s8(v6, (int8x16_t)xmmword_1B8343620);
      *a1 = vmulq_f32(vcvtq_f32_s32((int32x4_t)vzip1q_s16(v7, (int16x8_t)0)), v4);
      a1[1] = vmulq_f32(vcvtq_f32_s32((int32x4_t)vqtbl1q_s8((int8x16_t)v7, (int8x16_t)xmmword_1B83435D0)), v4);
      a1 += 2;
      a2 -= 2;
    }
    while (v5 > 3);
  }
  if (a2)
  {
    float32x4_t result = vmulq_f32(vcvtq_f32_s32((int32x4_t)vzip1q_s16((int16x8_t)vqtbl1q_s8(*a3, (int8x16_t)xmmword_1B8343630), (int16x8_t)0)), (float32x4_t)vdupq_n_s32(0x37800080u));
    *a1 = result;
  }
  return result;
}

unsigned char *hg_span_write_1b(unsigned char *result, int a2, float *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    do
    {
      float v4 = *a3;
      a3 += 4;
      *result++ = (uint64_t)rintf(fminf(fmaxf(v4, 0.0), 1.0) * 255.0);
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

_WORD *hg_span_write_1s(_WORD *result, int a2, float *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    do
    {
      float v4 = *a3;
      a3 += 4;
      *result++ = (uint64_t)rintf(fminf(fmaxf(v4, 0.0), 1.0) * 65535.0);
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

_WORD *hg_span_write_1h(_WORD *result, int a2, _DWORD *a3)
{
  if (a2 >= 1)
  {
    int v3 = a2 + 1;
    while (1)
    {
      int v5 = HIWORD(*a3) & 0x8000;
      unsigned int v6 = (*a3 >> 23);
      unsigned int v7 = *a3 & 0x7FFFFF;
      unsigned int v8 = v6 - 112;
      if (v6 <= 0x70)
      {
        if (v6 >= 0x66)
        {
          unsigned int v4 = (v7 | 0x800000) >> (113 - v6);
          if ((v4 & 0x1000) != 0) {
            v4 += 0x2000;
          }
          v5 |= v4 >> 13;
        }
        else
        {
          LOWORD(v5) = 0;
        }
        goto LABEL_6;
      }
      if (v6 != 255) {
        break;
      }
      if (!v7) {
        goto LABEL_22;
      }
      v5 |= (v7 < 0x2000) | (v7 >> 13) | 0x7C00;
LABEL_6:
      *result++ = v5;
      a3 += 4;
      if (--v3 <= 1) {
        return result;
      }
    }
    unsigned int v9 = v7 + 0x2000;
    unsigned int v10 = v6 - 111;
    if (v7 >= 0x7FE000) {
      unsigned int v9 = 0;
    }
    else {
      unsigned int v10 = v8;
    }
    if ((*a3 & 0x1000) != 0) {
      unsigned int v11 = v10;
    }
    else {
      unsigned int v11 = v8;
    }
    if ((*a3 & 0x1000) != 0) {
      unsigned int v7 = v9;
    }
    if (v11 < 0x1F)
    {
      v5 |= (v11 << 10) | (v7 >> 13);
      goto LABEL_6;
    }
LABEL_22:
    LOWORD(v5) = v5 | 0x7C00;
    goto LABEL_6;
  }
  return result;
}

_DWORD *hg_span_write_1f(_DWORD *result, int a2, _DWORD *a3)
{
  int v3 = a2 - 1;
  if (a2 >= 1)
  {
    if (a2 >= 0x11 && (&a3[4 * v3 + 1] <= result || &result[v3 + 1] <= a3))
    {
      uint64_t v4 = a2 & 7;
      if (!v4) {
        uint64_t v4 = 8;
      }
      uint64_t v5 = a2 - v4;
      unsigned int v6 = &a3[4 * v5];
      unsigned int v7 = &result[v5];
      a2 -= v5;
      unsigned int v8 = (unsigned long long *)(result + 4);
      unsigned int v9 = (const float *)(a3 + 16);
      do
      {
        unsigned int v10 = v9 - 16;
        unsigned long long v11 = (unsigned __int128)vld4q_f32(v10);
        unsigned long long v12 = (unsigned __int128)vld4q_f32(v9);
        *(v8 - 1) = v11;
        *unsigned int v8 = v12;
        v8 += 2;
        v9 += 32;
        v5 -= 8;
      }
      while (v5);
      a3 = v6;
      float32x4_t result = v7;
    }
    unsigned int v13 = a2 + 1;
    do
    {
      int v14 = *a3;
      a3 += 4;
      *result++ = v14;
      --v13;
    }
    while (v13 > 1);
  }
  return result;
}

unsigned char *hg_span_write_2b(unsigned char *result, int a2, float *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    do
    {
      float v4 = *a3;
      float v5 = a3[1];
      a3 += 4;
      *float32x4_t result = (uint64_t)rintf(fminf(fmaxf(v4, 0.0), 1.0) * 255.0);
      result[1] = (uint64_t)rintf(fminf(fmaxf(v5, 0.0), 1.0) * 255.0);
      result += 2;
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

_WORD *hg_span_write_2s(_WORD *result, int a2, float *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    do
    {
      float v4 = *a3;
      float v5 = a3[1];
      a3 += 4;
      *float32x4_t result = (uint64_t)rintf(fminf(fmaxf(v4, 0.0), 1.0) * 65535.0);
      result[1] = (uint64_t)rintf(fminf(fmaxf(v5, 0.0), 1.0) * 65535.0);
      --v3;
      result += 2;
    }
    while (v3 > 1);
  }
  return result;
}

_WORD *hg_span_write_2h(_WORD *result, int a2, _DWORD *a3)
{
  if (a2 >= 1)
  {
    int v3 = a2 + 1;
    do
    {
      int v11 = HIWORD(*a3) & 0x8000;
      unsigned int v12 = (*a3 >> 23);
      unsigned int v13 = *a3 & 0x7FFFFF;
      unsigned int v14 = v12 - 112;
      if (v12 > 0x70)
      {
        unsigned int v17 = v13 + 0x2000;
        unsigned int v18 = v12 - 111;
        if (v13 >= 0x7FE000) {
          unsigned int v17 = 0;
        }
        else {
          unsigned int v18 = v14;
        }
        if ((*a3 & 0x1000) != 0)
        {
          unsigned int v19 = v17;
        }
        else
        {
          unsigned int v18 = v14;
          unsigned int v19 = *a3 & 0x7FFFFF;
        }
        BOOL v7 = v18 >= 0x1F;
        int v20 = (v18 << 10) | (v19 >> 13) | v11;
        __int16 v21 = v11 | 0x7C00;
        if (v7) {
          LOWORD(v20) = v11 | 0x7C00;
        }
        int v16 = (v13 < 0x2000) | (v13 >> 13) | v11 | 0x7C00;
        if (!v13) {
          LOWORD(v16) = v21;
        }
        if (v14 != 143) {
          LOWORD(v16) = v20;
        }
      }
      else
      {
        unsigned int v15 = (v13 | 0x800000) >> (113 - v12);
        if ((v15 & 0x1000) != 0) {
          v15 += 0x2000;
        }
        int v16 = v11 | (v15 >> 13);
        if (v12 < 0x66) {
          LOWORD(v16) = 0;
        }
      }
      unsigned int v22 = a3[1];
      int v23 = HIWORD(v22) & 0x8000;
      unsigned int v24 = (v22 >> 23);
      unsigned int v25 = v22 & 0x7FFFFF;
      unsigned int v26 = v24 - 112;
      if (v24 > 0x70)
      {
        unsigned int v4 = v25 + 0x2000;
        unsigned int v5 = v24 - 111;
        if (v25 >= 0x7FE000) {
          unsigned int v4 = 0;
        }
        else {
          unsigned int v5 = v26;
        }
        if ((v22 & 0x1000) != 0)
        {
          unsigned int v6 = v4;
        }
        else
        {
          unsigned int v5 = v26;
          unsigned int v6 = v22 & 0x7FFFFF;
        }
        BOOL v7 = v5 >= 0x1F;
        int v8 = (v5 << 10) | (v6 >> 13) | v23;
        __int16 v9 = v23 | 0x7C00;
        if (v7) {
          LOWORD(v8) = v23 | 0x7C00;
        }
        int v10 = (v25 < 0x2000) | (v25 >> 13) | v23 | 0x7C00;
        if (!v25) {
          LOWORD(v10) = v9;
        }
        if (v26 != 143) {
          LOWORD(v10) = v8;
        }
      }
      else
      {
        unsigned int v27 = (v25 | 0x800000) >> (113 - v24);
        if ((v27 & 0x1000) != 0) {
          v27 += 0x2000;
        }
        int v10 = v23 | (v27 >> 13);
        if (v24 < 0x66) {
          LOWORD(v10) = 0;
        }
      }
      *float32x4_t result = v16;
      result[1] = v10;
      --v3;
      a3 += 4;
      result += 2;
    }
    while (v3 > 1);
  }
  return result;
}

_DWORD *hg_span_write_2f(_DWORD *result, int a2, _DWORD *a3)
{
  int v3 = a2 - 1;
  if (a2 >= 1)
  {
    if (a2 >= 9 && (&a3[4 * v3 + 2] <= result || &result[2 * v3 + 2] <= a3))
    {
      uint64_t v4 = a2 & 7;
      if (!v4) {
        uint64_t v4 = 8;
      }
      uint64_t v5 = a2 - v4;
      unsigned int v6 = &a3[4 * v5];
      BOOL v7 = &result[2 * v5];
      a2 -= v5;
      int v8 = (float *)(result + 8);
      __int16 v9 = (const float *)(a3 + 16);
      do
      {
        int v10 = v9 - 16;
        float32x4x4_t v13 = vld4q_f32(v10);
        float32x4x4_t v14 = vld4q_f32(v9);
        int v11 = v8 - 8;
        vst2q_f32(v11, *(float32x4x2_t *)v13.val[0].f32);
        vst2q_f32(v8, *(float32x4x2_t *)v14.val[0].f32);
        v8 += 16;
        v9 += 32;
        v5 -= 8;
      }
      while (v5);
      a3 = v6;
      float32x4_t result = v7;
    }
    unsigned int v12 = a2 + 1;
    do
    {
      *float32x4_t result = *a3;
      result[1] = a3[1];
      --v12;
      a3 += 4;
      result += 2;
    }
    while (v12 > 1);
  }
  return result;
}

double hg_span_write_2b_yxzx(int8x16_t *a1, int a2, int32x4_t *a3, char a4, int32x4_t a5)
{
  if ((a1 & 1) == 0 && (a4 & 1) == 0)
  {
    if (a2 >= 1 && (a1 & 0xF) != 0)
    {
      uint64_t v5 = &a1->i32[1];
      a5 = vdupq_n_s32(0x437F0000u);
      do
      {
        int32x4_t v6 = *a3;
        int32x4_t v7 = a3[1];
        a3 += 2;
        int8x16_t v8 = vextq_s8((int8x16_t)vuzp1q_s32(v6, v7), (int8x16_t)v6, 4uLL);
        float32x4_t v9 = (float32x4_t)vextq_s8(v8, v8, 8uLL);
        v9.i32[0] = v6.i32[1];
        unsigned int v10 = a2;
        int16x8_t v11 = (int16x8_t)vcvtnq_s32_f32(vminq_f32(vmulq_f32(v9, (float32x4_t)a5), (float32x4_t)a5));
        *(int16x4_t *)v11.i8 = vqmovun_s32((int32x4_t)v11);
        a1->i32[0] = vqmovun_s16(v11).u32[0];
        a1 = (int8x16_t *)((char *)a1 + 4);
        a2 -= 2;
        if (v10 < 3) {
          break;
        }
      }
      while (v5++ & 0xF);
    }
    if (a2 >= 8)
    {
      a5 = vdupq_n_s32(0x437F0000u);
      do
      {
        int8x16_t v13 = vextq_s8((int8x16_t)vuzp1q_s32(*a3, a3[1]), *(int8x16_t *)a3, 4uLL);
        float32x4_t v14 = (float32x4_t)vextq_s8(v13, v13, 8uLL);
        v14.i32[0] = HIDWORD(a3->i64[0]);
        int8x16_t v15 = vextq_s8((int8x16_t)vuzp1q_s32(a3[2], a3[3]), (int8x16_t)a3[2], 4uLL);
        float32x4_t v16 = (float32x4_t)vextq_s8(v15, v15, 8uLL);
        v16.i32[0] = HIDWORD(a3[2].i64[0]);
        int8x16_t v17 = vextq_s8((int8x16_t)vuzp1q_s32(a3[4], a3[5]), (int8x16_t)a3[4], 4uLL);
        float32x4_t v18 = (float32x4_t)vextq_s8(v17, v17, 8uLL);
        v18.i32[0] = HIDWORD(a3[4].i64[0]);
        int8x16_t v19 = vextq_s8((int8x16_t)vuzp1q_s32(a3[6], a3[7]), (int8x16_t)a3[6], 4uLL);
        float32x4_t v20 = (float32x4_t)vextq_s8(v19, v19, 8uLL);
        v20.i32[0] = HIDWORD(a3[6].i64[0]);
        unsigned int v21 = a2;
        *a1++ = vqmovun_high_s16(vqmovun_s16(vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32(v14, (float32x4_t)a5), (float32x4_t)a5))), vcvtnq_s32_f32(vminq_f32(vmulq_f32(v16, (float32x4_t)a5), (float32x4_t)a5)))), vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32(v18, (float32x4_t)a5), (float32x4_t)a5))), vcvtnq_s32_f32(vminq_f32(vmulq_f32(v20, (float32x4_t)a5), (float32x4_t)a5))));
        a3 += 8;
        a2 -= 8;
      }
      while (v21 > 0xF);
    }
    if (a2 > 1)
    {
      a5 = vdupq_n_s32(0x437F0000u);
      do
      {
        int32x4_t v22 = *a3;
        int32x4_t v23 = a3[1];
        a3 += 2;
        int8x16_t v24 = vextq_s8((int8x16_t)vuzp1q_s32(v22, v23), (int8x16_t)v22, 4uLL);
        float32x4_t v25 = (float32x4_t)vextq_s8(v24, v24, 8uLL);
        v25.i32[0] = v22.i32[1];
        unsigned int v26 = a2;
        int16x8_t v27 = (int16x8_t)vcvtnq_s32_f32(vminq_f32(vmulq_f32(v25, (float32x4_t)a5), (float32x4_t)a5));
        *(int16x4_t *)v27.i8 = vqmovun_s32((int32x4_t)v27);
        a1->i32[0] = vqmovun_s16(v27).u32[0];
        a1 = (int8x16_t *)((char *)a1 + 4);
        a2 -= 2;
      }
      while (v26 > 3);
    }
    if (a2 >= 1)
    {
      float32x4_t v28 = (float32x4_t)vdupq_n_s32(0x437F0000u);
      v29.i64[0] = vmulq_f32(*(float32x4_t *)a3, v28).u64[0];
      v29.i64[1] = v29.i64[0];
      a5 = vcvtnq_s32_f32(vminq_f32((float32x4_t)vrev64q_s32(v29), v28));
      *(int16x4_t *)a5.i8 = vqmovun_s32(a5);
      *(int8x8_t *)a5.i8 = vqmovun_s16((int16x8_t)a5);
      a1->i32[0] = a5.i32[0];
    }
  }
  return *(double *)a5.i64;
}

double hg_span_write_2b_xyxz(int8x16_t *a1, int a2, uint64_t a3, char a4, int32x4_t a5)
{
  if ((a1 & 1) == 0 && (a4 & 1) == 0)
  {
    if (a2 >= 1 && (a1 & 0xF) != 0)
    {
      uint64_t v5 = &a1->i32[1];
      a5 = vdupq_n_s32(0x437F0000u);
      do
      {
        float32x4_t v6 = *(float32x4_t *)a3;
        int32x4_t v7 = *(int32x4_t *)(a3 + 16);
        a3 += 32;
        int32x4_t v8 = vuzp1q_s32((int32x4_t)v6, v7);
        v6.i64[1] = __PAIR64__(v8.u32[1], v8.u32[2]);
        unsigned int v9 = a2;
        int16x8_t v10 = (int16x8_t)vcvtnq_s32_f32(vminq_f32(vmulq_f32(v6, (float32x4_t)a5), (float32x4_t)a5));
        *(int16x4_t *)v10.i8 = vqmovun_s32((int32x4_t)v10);
        a1->i32[0] = vqmovun_s16(v10).u32[0];
        a1 = (int8x16_t *)((char *)a1 + 4);
        a2 -= 2;
        if (v9 < 3) {
          break;
        }
      }
      while (v5++ & 0xF);
    }
    if (a2 >= 8)
    {
      a5 = vdupq_n_s32(0x437F0000u);
      do
      {
        float32x4_t v12 = *(float32x4_t *)a3;
        float32x4_t v13 = *(float32x4_t *)(a3 + 32);
        int32x4_t v14 = vuzp1q_s32(*(int32x4_t *)a3, *(int32x4_t *)(a3 + 16));
        int32x4_t v15 = vuzp1q_s32((int32x4_t)v13, *(int32x4_t *)(a3 + 48));
        v12.i64[1] = __PAIR64__(v14.u32[1], v14.u32[2]);
        v13.i64[1] = __PAIR64__(v15.u32[1], v15.u32[2]);
        float32x4_t v16 = vmulq_f32(v13, (float32x4_t)a5);
        float32x4_t v17 = *(float32x4_t *)(a3 + 64);
        int32x4_t v18 = vuzp1q_s32((int32x4_t)v17, *(int32x4_t *)(a3 + 80));
        v17.i64[1] = __PAIR64__(v18.u32[1], v18.u32[2]);
        float32x4_t v19 = *(float32x4_t *)(a3 + 96);
        int32x4_t v20 = vuzp1q_s32((int32x4_t)v19, *(int32x4_t *)(a3 + 112));
        v19.i64[1] = __PAIR64__(v20.u32[1], v20.u32[2]);
        unsigned int v21 = a2;
        *a1++ = vqmovun_high_s16(vqmovun_s16(vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32(v12, (float32x4_t)a5), (float32x4_t)a5))), vcvtnq_s32_f32(vminq_f32(v16, (float32x4_t)a5)))), vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32(v17, (float32x4_t)a5), (float32x4_t)a5))), vcvtnq_s32_f32(vminq_f32(vmulq_f32(v19, (float32x4_t)a5), (float32x4_t)a5))));
        a3 += 128;
        a2 -= 8;
      }
      while (v21 > 0xF);
    }
    if (a2 > 1)
    {
      a5 = vdupq_n_s32(0x437F0000u);
      do
      {
        float32x4_t v22 = *(float32x4_t *)a3;
        int32x4_t v23 = *(int32x4_t *)(a3 + 16);
        a3 += 32;
        int32x4_t v24 = vuzp1q_s32((int32x4_t)v22, v23);
        v22.i64[1] = __PAIR64__(v24.u32[1], v24.u32[2]);
        unsigned int v25 = a2;
        int16x8_t v26 = (int16x8_t)vcvtnq_s32_f32(vminq_f32(vmulq_f32(v22, (float32x4_t)a5), (float32x4_t)a5));
        *(int16x4_t *)v26.i8 = vqmovun_s32((int32x4_t)v26);
        a1->i32[0] = vqmovun_s16(v26).u32[0];
        a1 = (int8x16_t *)((char *)a1 + 4);
        a2 -= 2;
      }
      while (v25 > 3);
    }
    if (a2 >= 1)
    {
      float32x4_t v27 = (float32x4_t)vdupq_n_s32(0x437F0000u);
      a5 = vcvtnq_s32_f32(vminq_f32((float32x4_t)vdupq_lane_s64(vmulq_f32(*(float32x4_t *)a3, v27).i64[0], 0), v27));
      *(int16x4_t *)a5.i8 = vqmovun_s32(a5);
      *(int8x8_t *)a5.i8 = vqmovun_s16((int16x8_t)a5);
      a1->i32[0] = a5.i32[0];
    }
  }
  return *(double *)a5.i64;
}

double hg_span_write_2s_yxzx(int16x4_t *a1, int a2, int32x4_t *a3, char a4, int32x4_t a5)
{
  if ((a1 & 1) == 0 && (a4 & 1) == 0)
  {
    if (a2 >= 1 && (a1 & 0xF) != 0)
    {
      uint64_t v5 = a1 + 1;
      a5 = vdupq_n_s32(0x477FFF00u);
      do
      {
        unsigned int v6 = a2;
        int32x4_t v7 = *a3;
        int32x4_t v8 = a3[1];
        a3 += 2;
        *a1++ = vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vzip1q_s32(v7, v7), (int8x16_t)vuzp1q_s32(v7, v8), 0xCuLL), (float32x4_t)a5), (float32x4_t)a5)));
        a2 -= 2;
        if (v6 < 3) {
          break;
        }
      }
      while (v5++ & 0xF);
    }
    if (a2 >= 4)
    {
      a5 = vdupq_n_s32(0x477FFF00u);
      do
      {
        unsigned int v10 = a2;
        *(int16x8_t *)a1->i8 = vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vzip1q_s32(*a3, *a3), (int8x16_t)vuzp1q_s32(*a3, a3[1]), 0xCuLL), (float32x4_t)a5), (float32x4_t)a5))), vcvtnq_s32_f32(vminq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vzip1q_s32(a3[2], a3[2]), (int8x16_t)vuzp1q_s32(a3[2], a3[3]), 0xCuLL), (float32x4_t)a5), (float32x4_t)a5)));
        a1 += 2;
        a3 += 4;
        a2 -= 4;
      }
      while (v10 > 7);
    }
    if (a2 > 1)
    {
      int32x4_t v11 = *a3;
      int32x4_t v12 = a3[1];
      a3 += 2;
      a5 = (int32x4_t)vextq_s8((int8x16_t)vzip1q_s32(v11, v11), (int8x16_t)vuzp1q_s32(v11, v12), 0xCuLL);
      float32x4_t v13 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
      *(int16x4_t *)a5.i8 = vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32((float32x4_t)a5, v13), v13)));
      *a1++ = *(int16x4_t *)a5.i8;
      a2 -= 2;
    }
    if (a2 >= 1)
    {
      float32x4_t v14 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
      int32x4_t v15 = (int32x4_t)vmulq_f32(*(float32x4_t *)a3, v14);
      a5 = vuzp1q_s32(v15, vzip1q_s32(v15, v15));
      *(int16x4_t *)a5.i8 = vqmovun_s32(vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8((int8x16_t)a5, (int8x16_t)a5, 0xCuLL), v14)));
      *a1 = *(int16x4_t *)a5.i8;
    }
  }
  return *(double *)a5.i64;
}

unsigned char *hg_span_write_3b(unsigned char *result, int a2, float *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    do
    {
      uint64_t v4 = (uint64_t)rintf(fminf(fmaxf(a3[1], 0.0), 1.0) * 255.0);
      uint64_t v5 = (uint64_t)rintf(fminf(fmaxf(a3[2], 0.0), 1.0) * 255.0);
      *float32x4_t result = (uint64_t)rintf(fminf(fmaxf(*a3, 0.0), 1.0) * 255.0);
      result[1] = v4;
      result[2] = v5;
      result += 3;
      --v3;
      a3 += 4;
    }
    while (v3 > 1);
  }
  return result;
}

unsigned char *hg_span_write_3b_zyx(unsigned char *result, int a2, float *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    do
    {
      uint64_t v4 = (uint64_t)rintf(fminf(fmaxf(*a3, 0.0), 1.0) * 255.0);
      uint64_t v5 = (uint64_t)rintf(fminf(fmaxf(a3[1], 0.0), 1.0) * 255.0);
      *float32x4_t result = (uint64_t)rintf(fminf(fmaxf(a3[2], 0.0), 1.0) * 255.0);
      result[1] = v5;
      result[2] = v4;
      result += 3;
      --v3;
      a3 += 4;
    }
    while (v3 > 1);
  }
  return result;
}

_WORD *hg_span_write_3s(_WORD *result, int a2, float *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    do
    {
      uint64_t v4 = (uint64_t)rintf(fminf(fmaxf(a3[1], 0.0), 1.0) * 65535.0);
      uint64_t v5 = (uint64_t)rintf(fminf(fmaxf(a3[2], 0.0), 1.0) * 65535.0);
      *float32x4_t result = (uint64_t)rintf(fminf(fmaxf(*a3, 0.0), 1.0) * 65535.0);
      result[1] = v4;
      result[2] = v5;
      --v3;
      a3 += 4;
      result += 3;
    }
    while (v3 > 1);
  }
  return result;
}

unint64_t hg_span_write_3f(unint64_t result, int a2, _DWORD *a3)
{
  unsigned int v3 = a2 - 1;
  if (a2 >= 1)
  {
    if (a2 >= 9
      && ((unint64_t)&a3[4 * v3 + 3] <= result || result + 12 * v3 + 12 <= (unint64_t)a3))
    {
      uint64_t v4 = a2 & 7;
      if (!v4) {
        uint64_t v4 = 8;
      }
      uint64_t v5 = a2 - v4;
      unsigned int v6 = &a3[4 * v5];
      unint64_t v7 = result + 12 * v5;
      a2 -= v5;
      int32x4_t v8 = (const float *)(a3 + 16);
      do
      {
        unsigned int v9 = v8 - 16;
        float32x4x4_t v13 = vld4q_f32(v9);
        float32x4x4_t v14 = vld4q_f32(v8);
        unint64_t v10 = result + 96;
        vst3q_f32((float *)result, *(float32x4x3_t *)v13.val[0].f32);
        int32x4_t v11 = (float *)(result + 48);
        vst3q_f32(v11, *(float32x4x3_t *)v14.val[0].f32);
        v8 += 32;
        float32x4_t result = v10;
        v5 -= 8;
      }
      while (v5);
      a3 = v6;
      float32x4_t result = v7;
    }
    unsigned int v12 = a2 + 1;
    do
    {
      *(_DWORD *)float32x4_t result = *a3;
      *(_DWORD *)(result + 4) = a3[1];
      *(_DWORD *)(result + 8) = a3[2];
      --v12;
      a3 += 4;
      result += 12;
    }
    while (v12 > 1);
  }
  return result;
}

uint8x16_t *hg_span_write_4b_wxyz(uint8x16_t *result, int a2, float32x4_t *a3)
{
  if (a2 >= 1 && (result & 0xF) != 0)
  {
    unsigned int v3 = &result->i32[1];
    float32x4_t v4 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    do
    {
      float32x4_t v5 = *a3++;
      unsigned int v6 = a2;
      int8x16_t v7 = (int8x16_t)vmulq_f32(v5, v4);
      int32x4_t v8 = vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v7, v7, 0xCuLL), v4));
      *(int16x4_t *)v8.i8 = vqmovun_s32(v8);
      result->i32[0] = vqmovn_u16((uint16x8_t)v8).u32[0];
      float32x4_t result = (uint8x16_t *)((char *)result + 4);
      --a2;
      if (v6 < 2) {
        break;
      }
    }
    while (v3++ & 0xF);
  }
  if (a2 >= 4)
  {
    float32x4_t v10 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    do
    {
      unsigned int v11 = a2;
      int8x16_t v12 = (int8x16_t)vmulq_f32(*a3, v10);
      int8x16_t v13 = (int8x16_t)vmulq_f32(a3[1], v10);
      int8x16_t v14 = (int8x16_t)vmulq_f32(a3[2], v10);
      int8x16_t v15 = (int8x16_t)vmulq_f32(a3[3], v10);
      *result++ = vqmovn_high_u16(vqmovn_u16((uint16x8_t)vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v12, v12, 0xCuLL), v10))), vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v13, v13, 0xCuLL), v10)))), (uint16x8_t)vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v14, v14, 0xCuLL), v10))), vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v15, v15, 0xCuLL), v10))));
      a3 += 4;
      a2 -= 4;
    }
    while (v11 > 7);
  }
  if (a2 >= 1)
  {
    unsigned int v16 = a2 + 1;
    float32x4_t v17 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    do
    {
      float32x4_t v18 = *a3++;
      int8x16_t v19 = (int8x16_t)vmulq_f32(v18, v17);
      int32x4_t v20 = vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v19, v19, 0xCuLL), v17));
      *(int16x4_t *)v20.i8 = vqmovun_s32(v20);
      result->i32[0] = vqmovn_u16((uint16x8_t)v20).u32[0];
      float32x4_t result = (uint8x16_t *)((char *)result + 4);
      --v16;
    }
    while (v16 > 1);
  }
  return result;
}

uint8x16_t *hg_span_write_4b_zyxw(uint8x16_t *result, int a2, float32x4_t *a3)
{
  if (a2 >= 1 && (result & 0xF) != 0)
  {
    unsigned int v3 = &result->i32[1];
    float32x4_t v4 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    do
    {
      unsigned int v5 = a2;
      float32x4_t v6 = *a3++;
      int8x16_t v7 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_f32(v6, v4));
      int32x4_t v8 = vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v7, v7, 0xCuLL), v4));
      *(int16x4_t *)v8.i8 = vqmovun_s32(v8);
      result->i32[0] = vqmovn_u16((uint16x8_t)v8).u32[0];
      float32x4_t result = (uint8x16_t *)((char *)result + 4);
      --a2;
      if (v5 < 2) {
        break;
      }
    }
    while (v3++ & 0xF);
  }
  if (a2 >= 4)
  {
    float32x4_t v10 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    do
    {
      int8x16_t v11 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_f32(*a3, v10));
      int8x16_t v12 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_f32(a3[1], v10));
      int8x16_t v13 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_f32(a3[2], v10));
      int8x16_t v14 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_f32(a3[3], v10));
      unsigned int v15 = a2;
      *result++ = vqmovn_high_u16(vqmovn_u16((uint16x8_t)vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v11, v11, 0xCuLL), v10))), vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v12, v12, 0xCuLL), v10)))), (uint16x8_t)vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v13, v13, 0xCuLL), v10))), vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v14, v14, 0xCuLL), v10))));
      a3 += 4;
      a2 -= 4;
    }
    while (v15 > 7);
  }
  if (a2 >= 1)
  {
    unsigned int v16 = a2 + 1;
    float32x4_t v17 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    do
    {
      float32x4_t v18 = *a3++;
      int8x16_t v19 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_f32(v18, v17));
      int32x4_t v20 = vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v19, v19, 0xCuLL), v17));
      *(int16x4_t *)v20.i8 = vqmovun_s32(v20);
      result->i32[0] = vqmovn_u16((uint16x8_t)v20).u32[0];
      float32x4_t result = (uint8x16_t *)((char *)result + 4);
      --v16;
    }
    while (v16 > 1);
  }
  return result;
}

uint8x16_t *hg_span_write_4b_xyzw(uint8x16_t *result, int a2, float32x4_t *a3)
{
  if (a2 >= 1 && (result & 0xF) != 0)
  {
    unsigned int v3 = &result->i32[1];
    float32x4_t v4 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    do
    {
      unsigned int v5 = a2;
      float32x4_t v6 = *a3++;
      int32x4_t v7 = vcvtnq_s32_f32(vminq_f32(vmulq_f32(v6, v4), v4));
      *(int16x4_t *)v7.i8 = vqmovun_s32(v7);
      result->i32[0] = vqmovn_u16((uint16x8_t)v7).u32[0];
      float32x4_t result = (uint8x16_t *)((char *)result + 4);
      --a2;
      if (v5 < 2) {
        break;
      }
    }
    while (v3++ & 0xF);
  }
  if (a2 >= 4)
  {
    float32x4_t v9 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    do
    {
      unsigned int v10 = a2;
      *result++ = vqmovn_high_u16(vqmovn_u16((uint16x8_t)vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32(*a3, v9), v9))), vcvtnq_s32_f32(vminq_f32(vmulq_f32(a3[1], v9), v9)))), (uint16x8_t)vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32(a3[2], v9), v9))), vcvtnq_s32_f32(vminq_f32(vmulq_f32(a3[3], v9), v9))));
      a3 += 4;
      a2 -= 4;
    }
    while (v10 > 7);
  }
  if (a2 >= 1)
  {
    unsigned int v11 = a2 + 1;
    float32x4_t v12 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    do
    {
      float32x4_t v13 = *a3++;
      int32x4_t v14 = vcvtnq_s32_f32(vminq_f32(vmulq_f32(v13, v12), v12));
      *(int16x4_t *)v14.i8 = vqmovun_s32(v14);
      result->i32[0] = vqmovn_u16((uint16x8_t)v14).u32[0];
      float32x4_t result = (uint8x16_t *)((char *)result + 4);
      --v11;
    }
    while (v11 > 1);
  }
  return result;
}

double hg_span_write_4s(int16x8_t *a1, int a2, float32x4_t *a3, float32x4_t a4)
{
  if (a2 >= 1 && (a1 & 0xF) != 0)
  {
    float32x4_t v4 = *a3++;
    float32x4_t v5 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
    *(int16x4_t *)a4.f32 = vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32(v4, v5), v5)));
    a1->i64[0] = a4.i64[0];
    a1 = (int16x8_t *)((char *)a1 + 8);
    --a2;
  }
  if (a2 > 1)
  {
    a4 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
    do
    {
      unsigned int v6 = a2;
      float32x4_t v7 = *a3;
      float32x4_t v8 = a3[1];
      a3 += 2;
      *a1++ = vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32(v7, a4), a4))), vcvtnq_s32_f32(vminq_f32(vmulq_f32(v8, a4), a4)));
      a2 -= 2;
    }
    while (v6 > 3);
  }
  if (a2 == 1)
  {
    a4 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
    *(int16x4_t *)a4.f32 = vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32(*a3, a4), a4)));
    a1->i64[0] = a4.i64[0];
  }
  return *(double *)a4.i64;
}

double hg_span_write_4s_wxyz(int16x8_t *a1, int a2, float32x4_t *a3, float32x4_t a4)
{
  if (a2 >= 1 && (a1 & 0xF) != 0)
  {
    float32x4_t v4 = *a3++;
    float32x4_t v5 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
    a4 = vmulq_f32(v4, v5);
    *(int16x4_t *)a4.f32 = vqmovun_s32(vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8((int8x16_t)a4, (int8x16_t)a4, 0xCuLL), v5)));
    a1->i64[0] = a4.i64[0];
    a1 = (int16x8_t *)((char *)a1 + 8);
    --a2;
  }
  if (a2 > 1)
  {
    a4 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
    do
    {
      unsigned int v6 = a2;
      float32x4_t v7 = *a3;
      float32x4_t v8 = a3[1];
      a3 += 2;
      int8x16_t v9 = (int8x16_t)vmulq_f32(v7, a4);
      int8x16_t v10 = (int8x16_t)vmulq_f32(v8, a4);
      *a1++ = vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v9, v9, 0xCuLL), a4))), vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8(v10, v10, 0xCuLL), a4)));
      a2 -= 2;
    }
    while (v6 > 3);
  }
  if (a2 == 1)
  {
    float32x4_t v11 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
    a4 = vmulq_f32(*a3, v11);
    *(int16x4_t *)a4.f32 = vqmovun_s32(vcvtnq_s32_f32(vminq_f32((float32x4_t)vextq_s8((int8x16_t)a4, (int8x16_t)a4, 0xCuLL), v11)));
    a1->i64[0] = a4.i64[0];
  }
  return *(double *)a4.i64;
}

float16x4_t *hg_span_write_4h(float16x4_t *result, int a2, float32x4_t *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    do
    {
      float32x4_t v4 = *a3++;
      *result++ = vcvt_f16_f32(v4);
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

_OWORD *hg_span_write_4f_xyzw(_OWORD *result, int a2, long long *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    do
    {
      long long v4 = *a3++;
      *result++ = v4;
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

int8x16_t *hg_span_write_4f_wxyz(int8x16_t *result, int a2, int8x16_t *a3)
{
  if (a2 >= 1)
  {
    unsigned int v3 = a2 + 1;
    do
    {
      int8x16_t v4 = *a3++;
      *result++ = vextq_s8(v4, v4, 0xCuLL);
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

float32x4_t hg_span_write_4b_10bit_yxzx_little_endian(int8x16_t *a1, int a2, int32x4_t *a3, int a4, float32x4_t result)
{
  if ((a1 & 0xF) == 0 && !(a4 % 6))
  {
    if (a2 >= 6)
    {
      float32x4_t result = (float32x4_t)vdupq_n_s32(0x447FC000u);
      v5.i64[0] = 0x300000003;
      v5.i64[1] = 0x300000003;
      int8x16_t v6 = (int8x16_t)vdupq_n_s32(0xFFC00u);
      do
      {
        int8x16_t v7 = vextq_s8((int8x16_t)vuzp1q_s32(*a3, a3[1]), *(int8x16_t *)a3, 4uLL);
        float32x4_t v8 = (float32x4_t)vextq_s8(v7, v7, 8uLL);
        v8.i32[0] = HIDWORD(a3->i64[0]);
        int8x16_t v9 = vextq_s8((int8x16_t)vuzp1q_s32(a3[2], a3[3]), (int8x16_t)a3[2], 4uLL);
        float32x4_t v10 = (float32x4_t)vextq_s8(v9, v9, 8uLL);
        v10.i32[0] = HIDWORD(a3[2].i64[0]);
        int32x4_t v11 = vcvtnq_s32_f32(vminq_f32(vmaxq_f32(vmulq_f32(v8, result), (float32x4_t)0), result));
        int8x16_t v12 = vextq_s8((int8x16_t)vuzp1q_s32(a3[4], a3[5]), (int8x16_t)a3[4], 4uLL);
        float32x4_t v13 = (float32x4_t)vextq_s8(v12, v12, 8uLL);
        int32x4_t v14 = vcvtnq_s32_f32(vminq_f32(vmaxq_f32(vmulq_f32(v10, result), (float32x4_t)0), result));
        v13.i32[0] = HIDWORD(a3[4].i64[0]);
        int32x4_t v15 = vcvtnq_s32_f32(vminq_f32(vmaxq_f32(vmulq_f32(v13, result), (float32x4_t)0), result));
        int32x4_t v16 = (int32x4_t)vextq_s8((int8x16_t)vuzp2q_s32(vuzp1q_s32(v14, v14), v15), (int8x16_t)v11, 4uLL);
        int32x4_t v17 = vuzp1q_s32(v11, v11);
        int8x16_t v18 = vextq_s8((int8x16_t)vtrn2q_s32(v16, v11), (int8x16_t)v16, 8uLL);
        v11.i32[2] = v15.i32[2];
        int32x4_t v19 = (int32x4_t)vextq_s8((int8x16_t)v11, (int8x16_t)v14, 4uLL);
        int8x16_t v20 = (int8x16_t)vtrn2q_s32(v19, v14);
        int32x4_t v21 = (int32x4_t)vextq_s8((int8x16_t)v15, (int8x16_t)vuzp2q_s32(v17, v14), 0xCuLL);
        int32x4_t v22 = (int32x4_t)vandq_s8((int8x16_t)vshlq_n_s32((int32x4_t)vextq_s8(v20, (int8x16_t)v19, 8uLL), 0xAuLL), v6);
        unsigned int v23 = a2;
        *a1++ = vorrq_s8(vorrq_s8((int8x16_t)(*(_OWORD *)&vshlq_n_s32((int32x4_t)vextq_s8((int8x16_t)v21, (int8x16_t)vzip1q_s32(v15, v21), 8uLL), 0x14uLL) & __PAIR128__(0x3FFFFFFF3FFFFFFFLL, 0x3FFFFFFF3FFFFFFFLL)), vandq_s8(v18, v5)), (int8x16_t)vuzp2q_s32((int32x4_t)vextq_s8((int8x16_t)v22, (int8x16_t)v22, 4uLL), v22));
        a3 += 6;
        a2 -= 6;
      }
      while (v23 > 0xB);
    }
    if (a2 >= 1)
    {
      int32x4_t v24 = 0uLL;
      int32x4_t v25 = 0uLL;
      int32x4_t v26 = 0uLL;
      int32x4_t v27 = 0uLL;
      if (a2 != 1)
      {
        int32x4_t v26 = a3[1];
        if (a2 >= 3)
        {
          int32x4_t v25 = a3[2];
          if (a2 != 3) {
            int32x4_t v27 = a3[3];
          }
        }
      }
      int8x16_t v28 = vextq_s8((int8x16_t)vuzp1q_s32(*a3, v26), *(int8x16_t *)a3, 4uLL);
      float32x4_t v29 = (float32x4_t)vextq_s8(v28, v28, 8uLL);
      v29.i32[0] = HIDWORD(a3->i64[0]);
      int8x16_t v30 = vextq_s8((int8x16_t)vuzp1q_s32(v25, v27), (int8x16_t)v25, 4uLL);
      float32x4_t v31 = (float32x4_t)vextq_s8(v30, v30, 8uLL);
      v31.i32[0] = v25.i32[1];
      float32x4_t v32 = (float32x4_t)vdupq_n_s32(0x447FC000u);
      int32x4_t v33 = vcvtnq_s32_f32(vminq_f32(vmaxq_f32(vmulq_f32(v29, v32), (float32x4_t)0), v32));
      int32x4_t v34 = vcvtnq_s32_f32(vminq_f32(vmaxq_f32(vmulq_f32(v31, v32), (float32x4_t)0), v32));
      if (a2 >= 5) {
        int32x4_t v24 = a3[4];
      }
      int8x16_t v35 = vextq_s8((int8x16_t)vuzp1q_s32(v24, (int32x4_t)0), (int8x16_t)v24, 4uLL);
      float32x4_t v36 = (float32x4_t)vextq_s8(v35, v35, 8uLL);
      v36.i32[0] = v24.i32[1];
      int32x4_t v37 = vcvtnq_s32_f32(vminq_f32(vmaxq_f32(vmulq_f32(v36, v32), (float32x4_t)0), v32));
      int32x4_t v38 = (int32x4_t)vextq_s8((int8x16_t)vuzp2q_s32(vuzp1q_s32(v34, v34), v37), (int8x16_t)v33, 4uLL);
      int8x16_t v39 = vextq_s8((int8x16_t)vtrn2q_s32(v38, v33), (int8x16_t)v38, 8uLL);
      int32x4_t v40 = vuzp1q_s32(v33, v33);
      v33.i32[2] = v37.i32[2];
      int32x4_t v41 = (int32x4_t)vextq_s8((int8x16_t)v33, (int8x16_t)v34, 4uLL);
      int32x4_t v42 = (int32x4_t)vextq_s8((int8x16_t)vtrn2q_s32(v41, v34), (int8x16_t)v41, 8uLL);
      int32x4_t v43 = (int32x4_t)vextq_s8((int8x16_t)v37, (int8x16_t)vuzp2q_s32(v40, v34), 0xCuLL);
      int32x4_t v44 = (int32x4_t)vextq_s8((int8x16_t)v43, (int8x16_t)vzip1q_s32(v37, v43), 8uLL);
      int8x16_t v45 = (int8x16_t)vshlq_n_s32(v42, 0xAuLL);
      v42.i64[0] = 0x300000003;
      v42.i64[1] = 0x300000003;
      int32x4_t v46 = (int32x4_t)vandq_s8(v45, (int8x16_t)vdupq_n_s32(0xFFC00u));
      float32x4_t result = (float32x4_t)vorrq_s8(vorrq_s8((int8x16_t)(*(_OWORD *)&vshlq_n_s32(v44, 0x14uLL) & __PAIR128__(0x3FFFFFFF3FFFFFFFLL, 0x3FFFFFFF3FFFFFFFLL)), vandq_s8(v39, (int8x16_t)v42)), (int8x16_t)vuzp2q_s32((int32x4_t)vextq_s8((int8x16_t)v46, (int8x16_t)v46, 4uLL), v46));
      *a1 = (int8x16_t)result;
    }
  }
  return result;
}

int8x16_t *hg_span_write_4b_10bit_big_endian(int8x16_t *result, int a2, float32x4_t *a3)
{
  if (a2 >= 1)
  {
    if ((result & 0xF) != 0)
    {
      unsigned int v3 = &result->i32[1];
      float32x4_t v4 = (float32x4_t)vdupq_n_s32(0x447FC000u);
      v5.i64[0] = 0x300000003;
      v5.i64[1] = 0x300000003;
      do
      {
        float32x4_t v6 = *a3++;
        int8x16_t v7 = (int8x16_t)vcvtnq_s32_f32(vminq_f32(vmaxq_f32(vmulq_f32(v6, (float32x4_t)xmmword_1B8343640), (float32x4_t)0), v4));
        int32x4_t v8 = (int32x4_t)vandq_s8(v7, (int8x16_t)xmmword_1B8343650);
        int32x4_t v9 = (int32x4_t)vandq_s8(v7, v5);
        result->i32[0] = vrev32q_s8(vorrq_s8(vorrq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vshlq_n_s32(v9, 0xCuLL), 1), (int8x16_t)vshlq_n_s32(v8, 0x16uLL)), (int8x16_t)vdupq_laneq_s32(vshlq_n_s32(v9, 2uLL), 2))).u32[0];
        float32x4_t result = (int8x16_t *)((char *)result + 4);
        if (!--a2) {
          break;
        }
      }
      while (v3++ & 0xF);
    }
    if (a2 >= 4)
    {
      float32x4_t v11 = (float32x4_t)vdupq_n_s32(0x447FC000u);
      do
      {
        int8x16_t v12 = (int8x16_t)vcvtnq_s32_f32(vminq_f32(vmaxq_f32(vmulq_f32(*a3, (float32x4_t)xmmword_1B8343640), (float32x4_t)0), v11));
        int8x16_t v13 = (int8x16_t)vcvtnq_s32_f32(vminq_f32(vmaxq_f32(vmulq_f32(a3[1], (float32x4_t)xmmword_1B8343640), (float32x4_t)0), v11));
        int8x16_t v14 = (int8x16_t)vcvtnq_s32_f32(vminq_f32(vmaxq_f32(vmulq_f32(a3[2], (float32x4_t)xmmword_1B8343640), (float32x4_t)0), v11));
        int8x16_t v15 = (int8x16_t)vcvtnq_s32_f32(vminq_f32(vmaxq_f32(vmulq_f32(a3[3], (float32x4_t)xmmword_1B8343640), (float32x4_t)0), v11));
        int32x2_t v16 = (int32x2_t)vorrq_s8(vorrq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vshlq_n_s32((int32x4_t)vandq_s8(v14, (int8x16_t)xmmword_1B8343660), 0xCuLL), 1), (int8x16_t)vshlq_n_s32((int32x4_t)vandq_s8(v14, (int8x16_t)xmmword_1B8343650), 0x16uLL)), (int8x16_t)vdupq_laneq_s32(vshlq_n_s32((int32x4_t)vandq_s8(v14, (int8x16_t)xmmword_1B8343670), 2uLL), 2)).u64[0];
        v14.i32[0] = 0;
        v14.i32[1] = vdupq_lane_s32((int32x2_t)vorrq_s8(vorrq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)vshlq_n_s32((int32x4_t)vandq_s8(v13, (int8x16_t)xmmword_1B8343660), 0xCuLL), 1), (int8x16_t)vshlq_n_s32((int32x4_t)vandq_s8(v13, (int8x16_t)xmmword_1B8343650), 0x16uLL)), (int8x16_t)vdupq_laneq_s32(vshlq_n_s32((int32x4_t)vandq_s8(v13, (int8x16_t)xmmword_1B8343670), 2uLL), 2)), 0).i32[1];
        v13.i64[0] = 0;
        v13.i64[1] = vdupq_lane_s32(v16, 0).u32[2];
        v17.i64[0] = 0;
        v17.i32[2] = 0;
        v17.i32[3] = vdupq_lane_s32((int32x2_t)vorrq_s8(vorrq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)vshlq_n_s32((int32x4_t)vandq_s8(v15, (int8x16_t)xmmword_1B8343660), 0xCuLL), 1), (int8x16_t)vshlq_n_s32((int32x4_t)vandq_s8(v15, (int8x16_t)xmmword_1B8343650), 0x16uLL)), (int8x16_t)vdupq_laneq_s32(vshlq_n_s32((int32x4_t)vandq_s8(v15, (int8x16_t)xmmword_1B8343670), 2uLL), 2)), 0).i32[3];
        *result++ = vrev32q_s8(vorrq_s8(vorrq_s8((int8x16_t)v14.u64[0], (int8x16_t)vorrq_s8(vorrq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vshlq_n_s32((int32x4_t)vandq_s8(v12, (int8x16_t)xmmword_1B8343660), 0xCuLL), 1), (int8x16_t)vshlq_n_s32((int32x4_t)vandq_s8(v12, (int8x16_t)xmmword_1B8343650), 0x16uLL)), (int8x16_t)vdupq_laneq_s32(vshlq_n_s32((int32x4_t)vandq_s8(v12, (int8x16_t)xmmword_1B8343670), 2uLL),
                                                    2)).u32[0]),
                        vorrq_s8(v13, v17)));
        a3 += 4;
        a2 -= 4;
      }
      while (a2 > 3);
    }
    if (a2)
    {
      unsigned int v18 = a2 + 1;
      float32x4_t v19 = (float32x4_t)vdupq_n_s32(0x447FC000u);
      v20.i64[0] = 0x300000003;
      v20.i64[1] = 0x300000003;
      do
      {
        float32x4_t v21 = *a3++;
        int8x16_t v22 = (int8x16_t)vcvtnq_s32_f32(vminq_f32(vmaxq_f32(vmulq_f32(v21, (float32x4_t)xmmword_1B8343640), (float32x4_t)0), v19));
        int32x4_t v23 = (int32x4_t)vandq_s8(v22, (int8x16_t)xmmword_1B8343650);
        int32x4_t v24 = (int32x4_t)vandq_s8(v22, v20);
        result->i32[0] = vrev32q_s8(vorrq_s8(vorrq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vshlq_n_s32(v24, 0xCuLL), 1), (int8x16_t)vshlq_n_s32(v23, 0x16uLL)), (int8x16_t)vdupq_laneq_s32(vshlq_n_s32(v24, 2uLL), 2))).u32[0];
        float32x4_t result = (int8x16_t *)((char *)result + 4);
        --v18;
      }
      while (v18 > 1);
    }
  }
  return result;
}

double hg_span_write_4s_wxyz_big_endian(int8x16_t *a1, int a2, float32x4_t *a3, int32x4_t a4)
{
  if (a2 >= 1 && (a1 & 0xF) != 0)
  {
    float32x4_t v4 = *a3++;
    float32x4_t v5 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
    int32x4_t v6 = vcvtnq_s32_f32(vminq_f32(vmulq_f32(v4, v5), v5));
    a4 = (int32x4_t)vqtbl1q_s8((int8x16_t)vqmovun_high_s32(*(int16x4_t *)v6.i8, v6), (int8x16_t)xmmword_1B8343680);
    a4.i64[0] = vextq_s8((int8x16_t)a4, (int8x16_t)a4, 8uLL).u64[0];
    a1->i64[0] = a4.i64[0];
    a1 = (int8x16_t *)((char *)a1 + 8);
    --a2;
  }
  if (a2 > 1)
  {
    a4 = vdupq_n_s32(0x477FFF00u);
    do
    {
      unsigned int v7 = a2;
      float32x4_t v8 = *a3;
      float32x4_t v9 = a3[1];
      a3 += 2;
      *a1++ = vqtbl1q_s8((int8x16_t)vqmovun_high_s32(vqmovun_s32(vcvtnq_s32_f32(vminq_f32(vmulq_f32(v8, (float32x4_t)a4), (float32x4_t)a4))), vcvtnq_s32_f32(vminq_f32(vmulq_f32(v9, (float32x4_t)a4), (float32x4_t)a4))), (int8x16_t)xmmword_1B8343690);
      a2 -= 2;
    }
    while (v7 > 3);
  }
  if (a2 == 1)
  {
    float32x4_t v10 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
    a4 = vcvtnq_s32_f32(vminq_f32(vmulq_f32(*a3, v10), v10));
    *(int8x8_t *)a4.i8 = vqtbl1_s8((int8x16_t)vqmovun_high_s32(vqmovun_s32(a4), a4), (int8x8_t)0x405020300010607);
    a1->i64[0] = a4.i64[0];
  }
  return *(double *)a4.i64;
}

void HGHandler::HGHandler(HGHandler *this)
{
  *(void *)this = &unk_1F10D4C40;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = xmmword_1B7E736B0;
  *((_OWORD *)this + 6) = xmmword_1B7E736C0;
  *((_OWORD *)this + 7) = xmmword_1B7E736D0;
  *((_OWORD *)this + 8) = xmmword_1B7E734D0;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *(_OWORD *)((char *)this + 172) = 0u;
}

uint64_t HGHandler::Reset(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 144) = a2;
  *(_DWORD *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(_DWORD *)(a1 + 176) = 0;
  int v3 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 128))(a2, 23);
  *(void *)(a1 + 240) = 0;
  *(_DWORD *)(a1 + 236) = v3;
  v5[0] = xmmword_1B7E736B0;
  v5[1] = xmmword_1B7E736C0;
  v5[2] = xmmword_1B7E736D0;
  v5[3] = xmmword_1B7E734D0;
  (*(void (**)(uint64_t, _OWORD *))(*(void *)a1 + 176))(a1, v5);
  return a1;
}

uint64_t HGHandler::LoadIdentityModelViewMatrix(HGHandler *this)
{
  v2[0] = xmmword_1B7E736B0;
  v2[1] = xmmword_1B7E736C0;
  v2[2] = xmmword_1B7E736D0;
  v2[3] = xmmword_1B7E734D0;
  return (*(uint64_t (**)(HGHandler *, _OWORD *))(*(void *)this + 176))(this, v2);
}

uint64_t HGHandler::Init(uint64_t this, HGRect a2, HGRect a3, int a4, int a5)
{
  *(HGRect *)(this + 188) = a2;
  *(HGRect *)(this + 204) = a3;
  *(HGRect *)(this + 220) = a3;
  *(_DWORD *)(this + 240) = a4;
  *(_DWORD *)(this + 244) = a5;
  return this;
}

uint64_t HGHandler::InitTexture(uint64_t this, int a2, HGRect a3, HGRect a4, HGRect a5, int a6, int a7)
{
  *(HGRect *)(this + 188) = a3;
  *(HGRect *)(this + 204) = a4;
  *(HGRect *)(this + 220) = a5;
  *(_DWORD *)(this + 240) = a4.var0 + a6 - a5.var0;
  *(_DWORD *)(this + 244) = a4.var1 + a7 - a5.var1;
  return this;
}

int32x4_t HGHandler::Push(int32x4_t *this, const HGShaderBinding *a2)
{
  this[9].i32[2] += *(_DWORD *)a2;
  int32x4_t result = vaddq_s32(this[10], *(int32x4_t *)((char *)a2 + 8));
  this[10] = result;
  this[11].i32[0] += *((_DWORD *)a2 + 6);
  return result;
}

int32x4_t HGHandler::Pop(int32x4_t *this, const HGShaderBinding *a2)
{
  this[9].i32[2] -= *(_DWORD *)a2;
  int32x4_t result = vsubq_s32(this[10], *(int32x4_t *)((char *)a2 + 8));
  this[10] = result;
  this[11].i32[0] -= *((_DWORD *)a2 + 6);
  return result;
}

uint64_t HGHandler::TexCoord(HGHandler *this, int a2, int a3, int a4, const double *a5)
{
  uint64_t v9 = (*(uint64_t (**)(HGHandler *))(*(void *)this + 80))(this);
  (*(void (**)(HGHandler *, double, double, double))(*(void *)this + 96))(this, (double)(*((_DWORD *)this + 60) + a3), (double)(*((_DWORD *)this + 61) + a4), 0.0);
  if (a5) {
    (*(void (**)(HGHandler *, const double *))(*(void *)this + 112))(this, a5);
  }
  return v9;
}

uint64_t HGHandler::TexOffset(HGHandler *this, int a2, int a3, int a4)
{
  uint64_t v7 = (*(uint64_t (**)(HGHandler *))(*(void *)this + 80))(this);
  (*(void (**)(HGHandler *, double, double, double))(*(void *)this + 96))(this, (double)(*((_DWORD *)this + 60) + a3), (double)(*((_DWORD *)this + 61) + a4), 0.0);
  (*(void (**)(HGHandler *, double, double, double))(*(void *)this + 104))(this, 0.0, 0.0, 0.0);
  return v7;
}

__n128 HGHandler::LoadModelViewMatrix(HGHandler *this, const simd::float4x4 *a2)
{
  __n128 result = (__n128)a2->columns[0];
  simd_float4 v3 = a2->columns[1];
  simd_float4 v4 = a2->columns[3];
  *((_OWORD *)this + 3) = a2->columns[2];
  *((simd_float4 *)this + 4) = v4;
  *((__n128 *)this + 1) = result;
  *((simd_float4 *)this + 2) = v3;
  return result;
}

__n128 HGHandler::LoadProjectionMatrix(HGHandler *this, const simd::float4x4 *a2)
{
  __n128 result = (__n128)a2->columns[0];
  simd_float4 v3 = a2->columns[1];
  simd_float4 v4 = a2->columns[3];
  *((_OWORD *)this + 7) = a2->columns[2];
  *((simd_float4 *)this + 8) = v4;
  *((__n128 *)this + 5) = result;
  *((simd_float4 *)this + 6) = v3;
  return result;
}

uint64_t HGHandler::EnvParameters(HGHandler *this, int a2, const float *a3)
{
  return 0xFFFFFFFFLL;
}

void HGLinearFilter2D::HGLinearFilter2D(HGLinearFilter2D *this)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
}

uint64_t HGLinearFilter2D::operator=(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  int v4 = *(_DWORD *)(a2 + 16);
  int v5 = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a1 + 16) = v4;
  *(_DWORD *)(a1 + 20) = v5;
  if ((*(unsigned char *)(a2 + 28) & 2) != 0)
  {
    int v6 = v5 * v4;
    if (*(_DWORD *)(a1 + 24) < v5 * v4)
    {
      if ((*(unsigned char *)(a1 + 28) & 2) != 0 && *(void *)a1) {
        MEMORY[0x1BA9BFB70]();
      }
      *(_DWORD *)(a1 + 24) = v6;
      operator new[]();
    }
    if (v6 >= 1)
    {
      uint64_t v7 = 0;
      do
      {
        *(_OWORD *)(*(void *)a1 + v7) = *(_OWORD *)(*(void *)a2 + v7);
        v7 += 16;
      }
      while (16 * v6 != v7);
    }
  }
  else
  {
    if ((*(unsigned char *)(a1 + 28) & 2) != 0)
    {
      if (*(void *)a1) {
        MEMORY[0x1BA9BFB70]();
      }
      *(void *)a1 = 0;
      *(_DWORD *)(a1 + 24) = 0;
    }
    *(void *)a1 = *(void *)a2;
  }
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  return a1;
}

uint64_t HGLinearFilter2D::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    return 0;
  }
  if (*(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)) {
    return 0;
  }
  int v2 = *(_DWORD *)(a1 + 16);
  if (v2 != *(_DWORD *)(a2 + 16)) {
    return 0;
  }
  int v3 = *(_DWORD *)(a1 + 20);
  if (v3 != *(_DWORD *)(a2 + 20)) {
    return 0;
  }
  if (*(void *)a1 == *(void *)a2) {
    return 1;
  }
  if ((*(_DWORD *)(a1 + 28) & *(_DWORD *)(a2 + 28) & 2) == 0) {
    return 0;
  }
  unint64_t v4 = (v3 * v2);
  if ((int)v4 < 1) {
    return 1;
  }
  uint64_t v5 = 0;
  BOOL v6 = 0;
  do
  {
    int8x16_t v7 = vmvnq_s8((int8x16_t)vceqq_f32(*(float32x4_t *)(*(void *)a1 + 16 * v5), *(float32x4_t *)(*(void *)a2 + 16 * v5)));
    *(int32x2_t *)v7.i8 = vpmin_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
    if (vpmin_s32(*(int32x2_t *)v7.i8, *(int32x2_t *)v7.i8).u32[0]) {
      break;
    }
    BOOL v6 = ++v5 >= v4;
  }
  while (v4 != v5);
  return v6;
}

BOOL HGLinearFilter2D::setType(HGLinearFilter2D *this, unsigned int a2, int a3)
{
  if (a2 <= 0x39)
  {
    uint64_t v6 = 4 * (int)a2;
    uint64_t v7 = *(unsigned int *)((char *)&unk_1B8345988 + v6);
    int v8 = *(_DWORD *)((char *)&unk_1B8345A70 + v6);
    uint64_t v9 = (uint64_t)*(&off_1E616CBD8 + (int)a2);
    signed int v10 = (v7 - 1) >> 1;
    signed int v11 = (v8 - 1) >> 1;
    if (a3 == 4)
    {
      int v12 = *((_DWORD *)this + 7);
      if ((v12 & 2) != 0 && *(void *)this)
      {
        MEMORY[0x1BA9BFB70]();
        int v12 = *((_DWORD *)this + 7);
      }
      *((_DWORD *)this + 4) = v7;
      *((_DWORD *)this + 5) = v8;
      *(void *)this = v9;
      *((_DWORD *)this + 7) = v12 & 0xFFFFFFFD;
      *((_DWORD *)this + 2) = -v10;
      *((_DWORD *)this + 3) = -v11;
    }
    else
    {
      signed int v13 = *((_DWORD *)this + 2);
      signed int v14 = *((_DWORD *)this + 3);
      if (v10 >= v13) {
        unsigned int v15 = *((_DWORD *)this + 2);
      }
      else {
        unsigned int v15 = (v7 - 1) >> 1;
      }
      int v16 = *((_DWORD *)this + 5);
      int v17 = v13 + *((_DWORD *)this + 4);
      if (v11 >= v14) {
        unsigned int v18 = *((_DWORD *)this + 3);
      }
      else {
        unsigned int v18 = (v8 - 1) >> 1;
      }
      int v19 = v17 - 1;
      if ((int)v7 - 1 + v10 <= v19) {
        int v20 = v19;
      }
      else {
        int v20 = v7 - 1 + v10;
      }
      if (v8 - 1 + v11 <= v14 + v16 - 1) {
        int v21 = v14 + v16 - 1;
      }
      else {
        int v21 = v8 - 1 + v11;
      }
      HGLinearFilter2D::resize(this, v15, v18, v20, v21, 0);
      int v22 = 0;
      uint64_t v23 = *(void *)this
          + 16 * (v10 - *((_DWORD *)this + 2) + (v11 - *((_DWORD *)this + 3)) * *((_DWORD *)this + 4));
      int8x16_t v24 = g_Mask[a3];
      do
      {
        uint64_t v25 = 0;
        do
        {
          *(int8x16_t *)(v23 + 16 * v25) = vbslq_s8(v24, *(int8x16_t *)(v9 + 16 * v25), *(int8x16_t *)(v23 + 16 * v25));
          ++v25;
        }
        while (v7 != v25);
        v23 += 16 * *((int *)this + 4);
        ++v22;
        v9 += 16 * v7;
      }
      while (v22 != v8);
    }
  }
  return a2 < 0x3A;
}

HGLinearFilter2D *HGLinearFilter2D::HGLinearFilter2D(HGLinearFilter2D *a1, unsigned int a2)
{
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  HGLinearFilter2D::setType(a1, a2, 4);
  return a1;
}

void HGLinearFilter2D::~HGLinearFilter2D(HGLinearFilter2D *this)
{
  if ((*((unsigned char *)this + 28) & 2) != 0)
  {
    if (*(void *)this) {
      MEMORY[0x1BA9BFB70]();
    }
  }
}

uint64_t HGLinearFilter2D::resize(HGLinearFilter2D *this, int a2, int a3, int a4, int a5, int a6)
{
  int v7 = a4 - a2 + 1;
  int v8 = a5 - a3 + 1;
  if (v7 < 1 || v8 < 1)
  {
    if ((*((unsigned char *)this + 28) & 2) != 0 && *(void *)this) {
      MEMORY[0x1BA9BFB70]();
    }
    uint64_t v10 = 0;
    *(void *)this = 0;
    *((void *)this + 1) = 0;
    *((void *)this + 2) = 0;
  }
  else
  {
    int v11 = v8 * v7;
    if (a6
      || *((_DWORD *)this + 2) != a2
      || *((_DWORD *)this + 3) != a3
      || v7 != *((_DWORD *)this + 4)
      || v8 != *((_DWORD *)this + 5))
    {
      *((_DWORD *)this + 6) = v11 + a6;
      operator new[]();
    }
    if ((*((unsigned char *)this + 28) & 2) == 0)
    {
      *((_DWORD *)this + 6) = v11;
      operator new[]();
    }
    if (v11 > *((_DWORD *)this + 6))
    {
      *((_DWORD *)this + 6) = v11;
      operator new[]();
    }
    return *(void *)this;
  }
  return v10;
}

int8x16_t HGLinearFilter2D::set(HGLinearFilter2D *this, int a2, int a3, int32x2_t a4, int a5)
{
  int v6 = a3;
  int v7 = a2;
  if (!*(void *)this)
  {
    *((_DWORD *)this + 6) = 1;
    operator new[]();
  }
  int v9 = *((_DWORD *)this + 2);
  int v10 = *((_DWORD *)this + 3);
  if (a2 >= v9) {
    a2 = *((_DWORD *)this + 2);
  }
  int v12 = v9 + *((_DWORD *)this + 4);
  if (a3 >= v10) {
    a3 = *((_DWORD *)this + 3);
  }
  int v13 = v12 - 1;
  if (v7 <= v13) {
    int v14 = v13;
  }
  else {
    int v14 = v7;
  }
  int v11 = *((_DWORD *)this + 5);
  if (v6 <= v10 + v11 - 1) {
    int v15 = v10 + v11 - 1;
  }
  else {
    int v15 = v6;
  }
  HGLinearFilter2D::resize(this, a2, a3, v14, v15, 0);
  uint64_t v16 = 16 * (v7 - *((_DWORD *)this + 2) + (v6 - *((_DWORD *)this + 3)) * *((_DWORD *)this + 4));
  int8x16_t result = vbslq_s8(g_Mask[a5], (int8x16_t)vdupq_lane_s32(a4, 0), *(int8x16_t *)(*(void *)this + v16));
  *(int8x16_t *)(*(void *)this + v16) = result;
  return result;
}

uint64_t HGLinearFilter2D::reset(uint64_t this, int a2, int a3)
{
  uint64_t v3 = this;
  if (a2 && a3)
  {
    int v4 = a3 * a2;
    if (*(_DWORD *)(this + 20) * *(_DWORD *)(this + 16) != a3 * a2)
    {
      if ((*(unsigned char *)(this + 28) & 2) != 0)
      {
        if (*(void *)this) {
          MEMORY[0x1BA9BFB70]();
        }
      }
      *(_DWORD *)(v3 + 24) = v4;
      operator new[]();
    }
    *(void *)(this + 8) = 0;
    *(_DWORD *)(this + 16) = a2;
    *(_DWORD *)(this + 20) = a3;
    if (v4 >= 1)
    {
      uint64_t v5 = 0;
      do
      {
        int v6 = (void *)(*(void *)this + v5);
        *int v6 = 0;
        v6[1] = 0;
        v5 += 16;
      }
      while (16 * (a3 * a2) != v5);
    }
  }
  else
  {
    if ((*(unsigned char *)(this + 28) & 2) != 0)
    {
      this = *(void *)this;
      if (*(void *)v3) {
        this = MEMORY[0x1BA9BFB70]();
      }
    }
    *(void *)uint64_t v3 = 0;
    *(void *)(v3 + 8) = 0;
    *(void *)(v3 + 16) = 0;
  }
  return this;
}

_DWORD *HGLinearFilter2D::translate(_DWORD *this, int a2, int a3)
{
  if (a3 | a2) {
    this[7] &= ~1u;
  }
  int v3 = this[3] + a3;
  this[2] += a2;
  this[3] = v3;
  return this;
}

uint64_t HGLinearFilter2D::transpose(uint64_t this)
{
  if (*(void *)this)
  {
    *(_DWORD *)(this + 24) = *(_DWORD *)(this + 20) * *(_DWORD *)(this + 16);
    operator new[]();
  }
  return this;
}

int32x2_t *HGLinearFilter2D::mirror(int32x2_t *this, int a2, int a3)
{
  if ((this[3].i8[4] & 2) == 0) {
    HGLinearFilter2D::resize((HGLinearFilter2D *)this, this[1].i32[0], this[1].i32[1], this[1].i32[0] + this[2].i32[0] - 1, this[1].i32[1] + this[2].i32[1] - 1, 0);
  }
  if (a3)
  {
    if (a2)
    {
      int v6 = 0;
      int32x2_t v7 = *this;
      int v9 = this[2].i32[0];
      __int32 v8 = this[2].i32[1];
      uint64_t v10 = *(void *)this + 16 * (v8 - 1) * v9;
      if (v9 >= 2) {
        goto LABEL_6;
      }
LABEL_10:
      LODWORD(v11) = 0;
      if (v9 != 1) {
        goto LABEL_12;
      }
LABEL_11:
      uint64_t v16 = 16 * v11;
      long long v17 = *(_OWORD *)(*(void *)&v7 + v16);
      uint64_t v18 = 16 * (int)v11;
      *(_OWORD *)(*(void *)&v7 + v16) = *(_OWORD *)(v10 + v18);
      *(_OWORD *)(v10 + v18) = v17;
LABEL_12:
      while (v6 != --v8)
      {
        ++v6;
        int v9 = this[2].i32[0];
        if (v6 == v8) {
          goto LABEL_34;
        }
        uint64_t v19 = 16 * v9;
        *(void *)&v7 += v19;
        v10 -= v19;
        if (v9 < 2) {
          goto LABEL_10;
        }
LABEL_6:
        uint64_t v11 = 0;
        uint64_t v12 = v9;
        uint64_t v13 = v10 - 16;
        do
        {
          long long v14 = *(_OWORD *)(*(void *)&v7 + 16 * v11);
          *(_OWORD *)(*(void *)&v7 + 16 * v11) = *(_OWORD *)(v13 + 16 * v12);
          *(_OWORD *)(v13 + 16 * v12) = v14;
          ++v11;
          uint64_t v15 = v12 - 2;
          --v12;
        }
        while (v11 < v15);
        if (v11 == ~v11 + v9) {
          goto LABEL_11;
        }
      }
      int v9 = this[2].i32[0];
LABEL_34:
      v38.i32[0] = v9;
      v38.i32[1] = this[2].i32[1];
      this[1] = vsub_s32((int32x2_t)0x100000001, vadd_s32(this[1], v38));
      return this;
    }
    int v27 = this[2].i32[1];
    if (v27 >= 2)
    {
      int v28 = this[2].i32[0];
      if (v28 >= 1)
      {
        int v29 = 0;
        int v30 = v27 - 1;
        int32x2_t v31 = *this;
        uint64_t v32 = *(void *)this + 16 * v30 * v28;
        do
        {
          if (v28 < 1)
          {
            uint64_t v33 = v28;
          }
          else
          {
            uint64_t v35 = 0;
            do
            {
              uint64_t v36 = 16 * v35;
              long long v37 = *(_OWORD *)(*(void *)&v31 + 16 * v35);
              *(_OWORD *)(*(void *)&v31 + v36) = *(_OWORD *)(v32 + 16 * v35);
              *(_OWORD *)(v32 + v36) = v37;
              ++v35;
              uint64_t v33 = this[2].i32[0];
            }
            while (v35 < v33);
            int v28 = this[2].i32[0];
          }
          uint64_t v34 = 16 * v33;
          *(void *)&v31 += v34;
          v32 -= v34;
          ++v29;
          --v30;
        }
        while (v29 < v30);
        int v27 = this[2].i32[1];
      }
    }
    this[1].i32[1] = 1 - v27 - this[1].i32[1];
    return this;
  }
  else
  {
    if (!a2) {
      return this;
    }
    int v20 = this[2].i32[1];
    if (v20 <= 0)
    {
      int v23 = this[2].i32[0];
    }
    else
    {
      int v21 = 0;
      int32x2_t v22 = *this;
      int v23 = this[2].i32[0];
      do
      {
        if (v23 >= 2)
        {
          uint64_t v24 = 0;
          uint64_t v25 = v23 - 1;
          do
          {
            long long v26 = *(_OWORD *)(*(void *)&v22 + 16 * v24);
            *(_OWORD *)(*(void *)&v22 + 16 * v24) = *(_OWORD *)(*(void *)&v22 + 16 * v25);
            *(_OWORD *)(*(void *)&v22 + 16 * v25) = v26;
            ++v24;
            --v25;
          }
          while (v24 < v25);
          int v23 = this[2].i32[0];
          int v20 = this[2].i32[1];
        }
        *(void *)&v22 += 16 * v23;
        ++v21;
      }
      while (v21 < v20);
    }
    this[1].i32[0] = 1 - v23 - this[1].i32[0];
    return this;
  }
}

uint64_t HGLinearFilter2D::normalize(uint64_t result, unsigned int a2, float32x4_t a3)
{
  int v3 = *(_DWORD *)(result + 20);
  float32x4_t v4 = 0uLL;
  if (v3 >= 1)
  {
    uint64_t v5 = *(int *)(result + 16);
    if ((int)v5 >= 1)
    {
      int v6 = 0;
      int32x2_t v7 = *(float32x4_t **)result;
      uint64_t v8 = 16 * v5;
      do
      {
        uint64_t v9 = 0;
        do
          float32x4_t v4 = vaddq_f32(v4, v7[v9++]);
        while (*(unsigned int *)(result + 16) != v9);
        ++v6;
        int32x2_t v7 = (float32x4_t *)((char *)v7 + v8);
      }
      while (v6 != v3);
    }
  }
  if (v3 >= 1)
  {
    int v10 = *(_DWORD *)(result + 16);
    if (v10 >= 1)
    {
      int v11 = 0;
      __asm { FMOV            V3.4S, #1.0 }
      v17.i64[0] = 0x80000000800000;
      v17.i64[1] = 0x80000000800000;
      float32x4_t v18 = vmaxq_f32(vaddq_f32(v4, (float32x4_t)vandq_s8(_Q3, (int8x16_t)vceqzq_f32(v4))), v17);
      float32x4_t v19 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
      float32x4_t v20 = vminq_f32(v18, v19);
      float32x4_t v21 = vminq_f32(vmaxq_f32(vrecpeq_f32(v20), v17), v19);
      float32x4_t v22 = vmulq_f32(v21, vrecpsq_f32(v20, v21));
      int8x16_t v23 = g_Mask[a2];
      float32x4_t v24 = vminq_f32(vmaxq_f32(v22, v17), v19);
      float32x4_t v25 = vmulq_f32(vmulq_f32(v24, vrecpsq_f32(v20, v24)), a3);
      long long v26 = *(float32x4_t **)result;
      do
      {
        while (v10 < 1)
        {
          v26 += v10;
          if (++v11 >= v3) {
            return result;
          }
        }
        uint64_t v27 = 0;
        int v28 = v26;
        do
        {
          *(int8x16_t *)int v28 = vbslq_s8(v23, (int8x16_t)vmulq_f32(v25, *v28), *(int8x16_t *)v28);
          ++v28;
          ++v27;
          int v29 = *(_DWORD *)(result + 16);
        }
        while (v27 < v29);
        int v3 = *(_DWORD *)(result + 20);
        int v10 = *(_DWORD *)(result + 16);
        v26 += v29;
        ++v11;
      }
      while (v11 < v3);
    }
  }
  return result;
}

HGLinearFilter2D *HGLinearFilter2D::convolve(int32x2_t *this, const HGLinearFilter2D *a2)
{
  if (!*(void *)this || !*(void *)a2) {
    return (HGLinearFilter2D *)this;
  }
  int v4 = *((_DWORD *)a2 + 7);
  if ((v4 & 1) == 0)
  {
    int32x2_t v6 = *(int32x2_t *)a2;
    long long v7 = *(_OWORD *)((char *)a2 + 8);
    int v8 = 0;
    int v9 = v4;
    HGLinearFilter2D::mirror(&v6, 1, 1);
    HGLinearFilter2D::correlate(this, &v6);
    if (*(void *)&v6 == *(void *)a2)
    {
      HGLinearFilter2D::mirror(&v6, 1, 1);
    }
    else if ((v9 & 2) != 0)
    {
      if (v6) {
        MEMORY[0x1BA9BFB70]();
      }
    }
    return (HGLinearFilter2D *)this;
  }
  return HGLinearFilter2D::correlate(this, (int32x2_t *)a2);
}

void sub_1B7784ABC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
  if ((a13 & 2) != 0) {
    HGLinearFilter2D::convolve(&a9);
  }
  _Unwind_Resume(exception_object);
}

HGLinearFilter2D *HGLinearFilter2D::correlate(int32x2_t *this, int32x2_t *a2)
{
  if (*this) {
    BOOL v3 = *a2 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    int v5 = *(void *)&a2[2] - 1;
    __int32 v6 = v5 + this[2].i32[0];
    int v7 = HIDWORD(*(void *)&a2[2]) - 1;
    __int32 v8 = v7 + this[2].i32[1];
    int32x2_t v9 = this[1];
    int32x2_t v10 = vadd_s32(vsub_s32(v9, vadd_s32(a2[2], a2[1])), (int32x2_t)0x100000001);
    uint64_t v11 = HGLinearFilter2D::resize((HGLinearFilter2D *)this, v9.i32[0] - v5, v9.i32[1] - v7, v6 + v9.i32[0] - 1, v8 + v9.i32[1] - 1, v8 * v6);
    uint64_t v12 = this[2].i32[0];
    int v13 = this[1].i32[0] + this[1].i32[1] * v12;
    int32x2_t v14 = *this;
    uint64_t v33 = 0;
    int v34 = v6;
    int v35 = v8;
    int32x2_t v36 = v14;
    int v37 = v6;
    uint64_t v38 = v11 + 16 * -v13;
    int v39 = v12;
    uint64_t v15 = (float32x4_t *)*a2;
    uint64_t v16 = a2[2].u32[0];
    uint64_t v17 = a2[2].i32[1];
    __int32 v31 = v8;
    __int32 v32 = v6;
    int32x2_t v30 = v14;
    if ((int)v16 < 2)
    {
      if ((int)v17 < 7)
      {
        ((void (*)(uint64_t *, float32x4_t *, void))cy[v17])(&v33, v15, v13);
      }
      else
      {
        int v22 = ((uint64_t (*)(uint64_t, float32x4_t *, int))off_1F10DE078[0])((uint64_t)&v33, v15, v13);
        int v23 = v17 - v22;
        if ((int)v17 - v22 >= 7)
        {
          float32x4_t v24 = (uint64_t (*)(uint64_t, float32x4_t *, int))off_1F10DE0B8[0];
          do
          {
            v22 += v24((uint64_t)&v33, &v15[v22], v13 + v22 * (int)v12);
            int v23 = v17 - v22;
          }
          while ((int)v17 - v22 > 6);
        }
        ((void (*)(uint64_t *, float32x4_t *, void))caddy[v23])(&v33, &v15[v22], v13 + v22 * (int)v12);
      }
      goto LABEL_27;
    }
    if (v16 < 7)
    {
      ((void (*)(uint64_t *, float32x4_t *, void))cx[v16])(&v33, v15, v13);
      int v21 = v17 - 1;
      if (!v21)
      {
LABEL_27:
        *this = v30;
        this[2].i32[0] = v32;
        this[2].i32[1] = v31;
        this[1] = v10;
        this[3].i32[1] = this[3].i32[1] & a2[3].i32[1] & 1 | 2;
        return (HGLinearFilter2D *)this;
      }
    }
    else
    {
      LODWORD(v18) = ((uint64_t (*)(uint64_t, float32x4_t *, int))off_1F10DDFF8[0])((uint64_t)&v33, v15, v13);
      int v19 = v16 - v18;
      if ((int)v16 - (int)v18 >= 7)
      {
        float32x4_t v20 = (uint64_t (*)(uint64_t, float32x4_t *, int))off_1F10DE038[0];
        do
        {
          uint64_t v18 = v20((uint64_t)&v33, &v15[(int)v18], (int)v18 + v13) + (int)v18;
          int v19 = v16 - v18;
        }
        while ((int)v16 - (int)v18 > 6);
      }
      ((void (*)(uint64_t *, float32x4_t *, void))caddx[v19])(&v33, &v15[(int)v18], (int)v18 + v13);
      int v21 = v17 - 1;
      if (!v21) {
        goto LABEL_27;
      }
    }
    if ((int)v16 < 7)
    {
      uint64_t v27 = caddx[(int)v16];
      uint64_t v28 = v12 + v13;
      do
      {
        v15 += a2[2].i32[0];
        ((void (*)(uint64_t *, float32x4_t *, uint64_t))v27)(&v33, v15, v28);
        v28 += v12;
        --v21;
      }
      while (v21);
    }
    else
    {
      float32x4_t v25 = (uint64_t (*)(uint64_t, float32x4_t *, int))off_1F10DE038[0];
      do
      {
        int v26 = 0;
        v13 += v12;
        v15 += a2[2].i32[0];
        do
          v26 += v25((uint64_t)&v33, &v15[v26], v26 + v13);
        while ((int)v16 - v26 > 6);
        ((void (*)(uint64_t *, float32x4_t *, void))caddx[(int)v16 - v26])(&v33, &v15[v26], v26 + v13);
        --v21;
      }
      while (v21);
    }
    goto LABEL_27;
  }
  return (HGLinearFilter2D *)this;
}

float HGLinearFilter::rect(HGLinearFilter *this, float a2, float a3, float a4)
{
  BOOL v4 = fabsf(a2) < 1.0;
  float result = 0.0;
  if (v4) {
    return 1.0;
  }
  return result;
}

float HGLinearFilter::bicubic(HGLinearFilter *this, float a2, float a3, float a4)
{
  float v4 = fabsf(a2);
  if (v4 < 1.0) {
    return (float)((float)(a3 * -0.33333) + 1.0)
  }
         + (float)(v4
                 * (float)((float)(v4 * (float)((float)((float)(a3 + a3) + a4) + -3.0))
                         + (float)(v4 * (float)(v4 * (float)((float)((float)(a3 * -1.5) + 2.0) - a4)))));
  float result = 0.0;
  if (v4 < 2.0) {
    return (float)((float)(a3 * 1.3333) + (float)(a4 * 4.0))
  }
         + (float)(v4
                 * (float)((float)((float)(a4 * -8.0) - (float)(a3 + a3))
                         + (float)(v4
                                 * (float)((float)(v4 * (float)((float)(a3 * -0.16667) - a4))
                                         + (float)((float)(a4 * 5.0) + a3)))));
  return result;
}

void HGLinearFilter::lanczos(HGLinearFilter *this, float a2, float a3, float a4)
{
  if (fabsf(a2) < a3)
  {
    if ((float)((float)((float)(a2 * 3.1416) * (float)(a2 * 3.1416)) + 1.0) != 1.0) {
      sinf(a2 * 3.1416);
    }
    float v6 = (float)(a2 / a3) * 3.1416;
    if ((float)((float)(v6 * v6) + 1.0) != 1.0) {
      sinf(v6);
    }
  }
}

uint64_t HGLinearFilter2D::convolve(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result) {
    return MEMORY[0x1BA9BFB70](result, 0x1000C80451B5BE8);
  }
  return result;
}

void *HGLUTCache::LUTEntry::LUTEntry(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = &unk_1F10D4D30;
  a1[1] = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
  a1[2] = a3;
  return a1;
}

void HGLUTCache::LUTEntry::~LUTEntry(HGLUTCache::LUTEntry *this)
{
  *(void *)this = &unk_1F10D4D30;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
}

BOOL HGLUTCache::isLUTCached(uint64_t a1, uint64_t a2)
{
  int v2 = *(uint64_t **)(a1 + 8);
  uint64_t v3 = *v2;
  uint64_t v4 = v2[1];
  if (*v2 == v4) {
    return 0;
  }
  while (((*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(*(void *)v3 + 8)) & 1) == 0)
  {
    v3 += 8;
    if (v3 == v4)
    {
      uint64_t v3 = v4;
      return v3 != *(void *)(*(void *)(a1 + 8) + 8);
    }
  }
  return v3 != *(void *)(*(void *)(a1 + 8) + 8);
}

uint64_t HGLUTCache::getNewLUT(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(uint64_t ***)(a1 + 8);
  int v5 = *v4;
  float v6 = v4[1];
  if (*v4 != v6)
  {
    while (((*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(*v5 + 8)) & 1) == 0)
    {
      if (++v5 == v6)
      {
        int v5 = v6;
        break;
      }
    }
    if (v5 != *(uint64_t **)(*(void *)(a1 + 8) + 8))
    {
      uint64_t v7 = *v5;
      goto LABEL_30;
    }
  }
  uint64_t v8 = (*(uint64_t (**)(void, uint64_t, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), a2, *(void *)a1);
  uint64_t v7 = v8;
  int32x2_t v9 = *(uint64_t ***)(a1 + 8);
  uint64_t v11 = v9[1];
  unint64_t v10 = (unint64_t)v9[2];
  if ((unint64_t)v11 >= v10)
  {
    int v13 = *v9;
    uint64_t v14 = (char *)v11 - (char *)*v9;
    uint64_t v15 = v14 >> 3;
    unint64_t v16 = (v14 >> 3) + 1;
    if (v16 >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v17 = v10 - (void)v13;
    if (v17 >> 2 > v16) {
      unint64_t v16 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v16;
    }
    if (v18)
    {
      if (v18 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      int v19 = operator new(8 * v18);
      float32x4_t v20 = (uint64_t *)&v19[8 * v15];
      int v21 = (uint64_t *)&v19[8 * v18];
      *float32x4_t v20 = v7;
      uint64_t v12 = (uint64_t)(v20 + 1);
      int v22 = (char *)((char *)v11 - (char *)v13);
      if (v11 == v13) {
        goto LABEL_27;
      }
    }
    else
    {
      int v19 = 0;
      float32x4_t v20 = (uint64_t *)(8 * v15);
      int v21 = 0;
      *(void *)(8 * v15) = v7;
      uint64_t v12 = 8 * v15 + 8;
      int v22 = (char *)((char *)v11 - (char *)v13);
      if (v11 == v13)
      {
LABEL_27:
        *int32x2_t v9 = v20;
        v9[1] = (uint64_t *)v12;
        v9[2] = v21;
        if (v11) {
          operator delete(v11);
        }
        goto LABEL_29;
      }
    }
    unint64_t v23 = (unint64_t)(v22 - 8);
    if (v23 < 0x58) {
      goto LABEL_37;
    }
    if ((unint64_t)((char *)v11 - &v19[v14]) < 0x20) {
      goto LABEL_37;
    }
    uint64_t v24 = (v23 >> 3) + 1;
    uint64_t v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
    int v26 = &v11[v25 / 0xFFFFFFFFFFFFFFF8];
    float32x4_t v20 = (uint64_t *)((char *)v20 - v25);
    uint64_t v27 = &v19[8 * v15 - 16];
    uint64_t v28 = v11 - 2;
    uint64_t v29 = v24 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v30 = *(_OWORD *)v28;
      *(v27 - 1) = *((_OWORD *)v28 - 1);
      *uint64_t v27 = v30;
      v27 -= 2;
      v28 -= 4;
      v29 -= 4;
    }
    while (v29);
    uint64_t v11 = v26;
    if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_37:
      do
      {
        uint64_t v31 = *--v11;
        *--float32x4_t v20 = v31;
      }
      while (v11 != v13);
    }
    uint64_t v11 = *v9;
    goto LABEL_27;
  }
  uint64_t *v11 = v8;
  uint64_t v12 = (uint64_t)(v11 + 1);
LABEL_29:
  v9[1] = (uint64_t *)v12;
LABEL_30:
  __int32 v32 = *(uint64_t (**)(uint64_t))(*(void *)v7 + 16);

  return v32(v7);
}

void *HGLUTCacheManager::HGLUTCacheManager(void *result, uint64_t a2)
{
  result[3] = 0;
  result[2] = 0;
  *uint64_t result = a2;
  result[1] = result + 2;
  return result;
}

void HGLUTCacheManager::clear(HGLUTCacheManager *this)
{
  while (*((void *)this + 3))
  {
    uint64_t v3 = (uint64_t *)*((void *)this + 1);
    uint64_t v4 = v3[5];
    if (v4)
    {
LABEL_5:
      uint64_t v5 = *(void *)(v4 + 8);
      float v6 = *(void **)v5;
      while (1)
      {
        uint64_t v7 = *(void **)(v5 + 8);
        if (v6 == v7) {
          break;
        }
        uint64_t v8 = *(v7 - 1);
        *(void *)(v5 + 8) = v7 - 1;
        if (v8)
        {
          (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
          goto LABEL_5;
        }
      }
      if (v6)
      {
        *(void *)(v5 + 8) = v6;
        operator delete(v6);
      }
      MEMORY[0x1BA9BFBA0](v5, 0x80C40D6874129);
      MEMORY[0x1BA9BFBA0](v4, 0x20C40960023A9);
    }
    int32x2_t v9 = (uint64_t *)v3[1];
    unint64_t v10 = v3;
    if (v9)
    {
      do
      {
        uint64_t v11 = v9;
        int32x2_t v9 = (uint64_t *)*v9;
      }
      while (v9);
    }
    else
    {
      do
      {
        uint64_t v11 = (uint64_t *)v10[2];
        BOOL v12 = *v11 == (void)v10;
        unint64_t v10 = v11;
      }
      while (!v12);
    }
    if (*((uint64_t **)this + 1) == v3) {
      *((void *)this + 1) = v11;
    }
    int v2 = (uint64_t *)*((void *)this + 2);
    --*((void *)this + 3);
    std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v2, v3);
    operator delete(v3);
  }
}

void HGLUTCacheManager::~HGLUTCacheManager(HGLUTCacheManager *this)
{
}

uint64_t HGLUTCacheManager::getLUTCache(uint64_t a1, uint64_t *a2)
{
  uint64_t v5 = (void *)(a1 + 16);
  uint64_t v4 = *(uint64_t **)(a1 + 16);
  float v6 = (uint64_t **)(a1 + 16);
  uint64_t v7 = (uint64_t **)(a1 + 16);
  if (v4)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v4;
        unint64_t v8 = v4[4];
        if (v8 <= (unint64_t)a2) {
          break;
        }
        uint64_t v4 = *v7;
        float v6 = v7;
        if (!*v7) {
          goto LABEL_8;
        }
      }
      if (v8 >= (unint64_t)a2) {
        break;
      }
      uint64_t v4 = v7[1];
      if (!v4)
      {
        float v6 = v7 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    int32x2_t v9 = (uint64_t *)v7;
    uint64_t v7 = (uint64_t **)operator new(0x30uLL);
    v7[4] = a2;
    v7[5] = 0;
    void *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *float v6 = (uint64_t *)v7;
    uint64_t v10 = **(void **)(a1 + 8);
    uint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *(void *)(a1 + 8) = v10;
      uint64_t v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 16), v11);
    ++*(void *)(a1 + 24);
  }
  if (!v7[5]) {
    operator new();
  }
  BOOL v12 = (void *)*v5;
  int v13 = v5;
  if (*v5)
  {
    while (1)
    {
      while (1)
      {
        int v13 = v12;
        unint64_t v14 = v12[4];
        if (v14 <= (unint64_t)a2) {
          break;
        }
        BOOL v12 = (void *)*v13;
        uint64_t v5 = v13;
        if (!*v13) {
          goto LABEL_20;
        }
      }
      if (v14 >= (unint64_t)a2) {
        break;
      }
      BOOL v12 = (void *)v13[1];
      if (!v12)
      {
        uint64_t v5 = v13 + 1;
        goto LABEL_20;
      }
    }
  }
  else
  {
LABEL_20:
    uint64_t v15 = v13;
    int v13 = operator new(0x30uLL);
    v13[4] = a2;
    v13[5] = 0;
    void *v13 = 0;
    v13[1] = 0;
    v13[2] = v15;
    *uint64_t v5 = v13;
    uint64_t v16 = **(void **)(a1 + 8);
    uint64_t v17 = v13;
    if (v16)
    {
      *(void *)(a1 + 8) = v16;
      uint64_t v17 = (uint64_t *)*v5;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 16), v17);
    ++*(void *)(a1 + 24);
  }
  return v13[5];
}

void sub_1B7785774(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x20C40960023A9);
  _Unwind_Resume(a1);
}

void HGGradientLinear::HGGradientLinear(HGGradientLinear *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v2 = &unk_1F10D4D68;
  *(void *)(v2 + 416) = 0;
  HGNode::SetFlags((HGNode *)v2, 0, 5);
  *((_DWORD *)this + 4) |= 0x621u;
  *((_DWORD *)this + 102) = 3;
}

void sub_1B7785804(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 416);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

void HGGradientLinear::~HGGradientLinear(HGNode *this)
{
  *(void *)this = &unk_1F10D4D68;
  uint64_t v2 = *((void *)this + 52);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10D4D68;
  uint64_t v2 = *((void *)this + 52);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGGradientLinear::GetOutput(HGNode *this, HGRenderer *a2)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  Input = HGRenderer::GetInput(a2, this, 0);
  if (!(*(unsigned int (**)(HGRenderer *))(*(void *)a2 + 304))(a2)
    || (uint64_t DOD = HGRenderer::GetDOD(a2, Input), (HIDWORD(v6) - HIDWORD(DOD)) > 1))
  {
    (*(void (**)(HGNode *, uint64_t, HGRect *))(*(void *)this + 104))(this, 3, &v48);
    (*(void (**)(HGNode *, uint64_t, float *))(*(void *)this + 104))(this, 4, &v45);
    (*(void (**)(HGNode *, uint64_t, float *))(*(void *)this + 104))(this, 5, &v42);
    BOOL v10 = *(float *)&v48.var0 == 1.0;
    if (*(float *)&v48.var1 != 0.0) {
      BOOL v10 = 0;
    }
    v9.n128_f32[0] = v42;
    v8.n128_f32[0] = v43;
    v7.n128_f32[0] = v44;
    if (v10
      && *(float *)&v48.var3 == 0.0
      && v45 == 0.0
      && v46 == 1.0
      && v47 == 0.0
      && v42 == 0.0
      && v43 == 0.0
      && v44 == 1.0)
    {
      int v11 = 0;
LABEL_33:
      *((_DWORD *)this + 102) = v11;
      (*(void (**)(HGNode *, void, float *, __n128, __n128, __n128))(*(void *)this + 104))(this, 0, v41, v7, v8, v9);
      (*(void (**)(HGNode *, uint64_t, float *))(*(void *)this + 104))(this, 1, &v37);
      (*(void (**)(HGNode *, uint64_t, int32x4_t *))(*(void *)this + 104))(this, 2, &v36);
      float v21 = (float)(v41[0] * *(float *)v36.i32) - (float)(v37 * v41[0]);
      *(float *)v22.i32 = 1.0
                        / (float)((float)((float)((float)(v21 * v21)
                                                + (float)((float)(*(float *)&v36.i32[1] - v38)
                                                        * (float)(*(float *)&v36.i32[1] - v38)))
                                        + (float)((float)(*(float *)&v36.i32[2] - v39)
                                                * (float)(*(float *)&v36.i32[2] - v39)))
                                + (float)((float)(*(float *)&v36.i32[3] - v40) * (float)(*(float *)&v36.i32[3] - v40)));
      v41[0] = v37 * v41[0];
      v41[1] = v38;
      v41[2] = v39;
      v41[3] = v40;
      float v37 = v21;
      float v38 = *(float *)&v36.i32[1] - v38;
      float v39 = *(float *)&v36.i32[2] - v39;
      float v40 = *(float *)&v36.i32[3] - v40;
      int32x4_t v36 = vdupq_lane_s32(v22, 0);
      (*(void (**)(HGNode *, void))(*(void *)this + 96))(this, 0);
      (*(void (**)(HGNode *, uint64_t, float, float, float, float))(*(void *)this + 96))(this, 1, v37, v38, v39, v40);
      (*(void (**)(HGNode *, uint64_t, float, float, float, float))(*(void *)this + 96))(this, 2, *(float *)v36.i32, *(float *)&v36.i32[1], *(float *)&v36.i32[2], *(float *)((unint64_t)&v36 | 0xC));
      int v23 = *((_DWORD *)this + 102) - 1;
      if (v23 > 2) {
        uint64_t v24 = 3;
      }
      else {
        uint64_t v24 = dword_1B8345B84[v23];
      }
      (*(void (**)(HGNode *, uint64_t, float, float, double, double))(*(void *)this + 96))(this, v24, 0.99708, 0.001462, 0.0, 0.0);
      switch(*((_DWORD *)this + 102))
      {
        case 0:
          uint64_t v25 = (HgcGradientLinearIdentity *)HGObject::operator new(0x1A0uLL);
          HgcGradientLinearIdentity::HgcGradientLinearIdentity(v25);
        case 1:
          int v26 = (HgcGradientLinearTranslate *)HGObject::operator new(0x1A0uLL);
          HgcGradientLinearTranslate::HgcGradientLinearTranslate(v26);
        case 2:
          uint64_t v27 = (HgcGradientLinearAffine *)HGObject::operator new(0x1A0uLL);
          HgcGradientLinearAffine::HgcGradientLinearAffine(v27);
        case 3:
          uint64_t v28 = (HgcGradientLinearPerspective *)HGObject::operator new(0x1A0uLL);
          HgcGradientLinearPerspective::HgcGradientLinearPerspective(v28);
        default:
          (*(void (**)(void, void, HGNode *))(**((void **)this + 52) + 120))(*((void *)this + 52), 0, Input);
          (*(void (**)(HGNode *, void, float *))(*(void *)this + 104))(this, 0, &v32);
          uint64_t v29 = (void *)((char *)this + 416);
          (*(void (**)(void, void, float, float, float, float))(**((void **)this + 52) + 96))(*((void *)this + 52), 0, v32, v33, v34, v35);
          (*(void (**)(HGNode *, uint64_t, float *))(*(void *)this + 104))(this, 1, &v32);
          (*(void (**)(void, uint64_t, float, float, float, float))(*(void *)*v29 + 96))(*v29, 1, v32, v33, v34, v35);
          (*(void (**)(HGNode *, uint64_t, float *))(*(void *)this + 104))(this, 2, &v32);
          (*(void (**)(void, uint64_t, float, float, float, float))(*(void *)*v29 + 96))(*v29, 2, v32, v33, v34, v35);
          (*(void (**)(HGNode *, uint64_t, float *))(*(void *)this + 104))(this, 3, &v32);
          (*(void (**)(void, uint64_t, float, float, float, float))(*(void *)*v29 + 96))(*v29, 3, v32, v33, v34, v35);
          (*(void (**)(HGNode *, uint64_t, float *))(*(void *)this + 104))(this, 4, &v32);
          (*(void (**)(void, uint64_t, float, float, float, float))(*(void *)*v29 + 96))(*v29, 4, v32, v33, v34, v35);
          (*(void (**)(HGNode *, uint64_t, float *))(*(void *)this + 104))(this, 5, &v32);
          (*(void (**)(void, uint64_t, float, float, float, float))(*(void *)*v29 + 96))(*v29, 5, v32, v33, v34, v35);
          (*(void (**)(HGNode *, uint64_t, float *))(*(void *)this + 104))(this, 6, &v32);
          (*(void (**)(void, uint64_t, float, float, float, float))(*(void *)*v29 + 96))(*v29, 6, v32, v33, v34, v35);
          uint64_t v30 = *((void *)this + 52);
          break;
      }
      return v30;
    }
    if (v45 != 0.0) {
      BOOL v10 = 0;
    }
    if (v10 && v46 == 1.0)
    {
      if (v42 != 0.0) {
        goto LABEL_32;
      }
      if (v43 == 0.0 && v44 == 1.0)
      {
        int v11 = 1;
        goto LABEL_33;
      }
    }
    if (v42 == 0.0 && v43 == 0.0)
    {
      v8.n128_u32[0] = 1.0;
      if (v44 == 1.0)
      {
        int v11 = 2;
        goto LABEL_33;
      }
    }
LABEL_32:
    int v11 = 3;
    goto LABEL_33;
  }
  uint64_t v13 = DOD;
  uint64_t v14 = v6;
  uint64_t v15 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v15);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v15, (const char *)3, v16);
  uint64_t v17 = HGRectMake4i(0, 0, 0, 1u);
  *(void *)&v48.int var0 = HGRectGrow(v13, v14, v17);
  *(void *)&v48.int var2 = v18;
  HGTextureWrap::SetCropRect(v15, &v48);
  (*(void (**)(HGTextureWrap *, void, HGNode *))(*(void *)v15 + 120))(v15, 0, Input);
  int v19 = (HGNode *)HGObject::operator new(0x1B0uLL);
  HGNode::HGNode(v19);
  *(void *)int v19 = &unk_1F10D4D68;
  *((void *)v19 + 52) = 0;
  HGNode::SetFlags(v19, 0, 5);
  *((_DWORD *)v19 + 4) |= 0x621u;
  *((_DWORD *)v19 + 102) = 3;
  float32x4_t v20 = (HGNode *)*((void *)this + 52);
  if (v20 == v19)
  {
    (*(void (**)(HGNode *))(*(void *)v19 + 24))(v19);
    int v19 = (HGNode *)*((void *)this + 52);
  }
  else
  {
    if (v20) {
      (*(void (**)(HGNode *))(*(void *)v20 + 24))(v20);
    }
    *((void *)this + 52) = v19;
  }
  (*(void (**)(HGNode *, void, HGTextureWrap *))(*(void *)v19 + 120))(v19, 0, v15);
  (*(void (**)(HGNode *, void, HGRect *))(*(void *)this + 104))(this, 0, &v48);
  (*(void (**)(void, void, float, float, float, float))(**((void **)this + 52) + 96))(*((void *)this + 52), 0, *(float *)&v48.var0, *(float *)&v48.var1, *(float *)&v48.var2, *(float *)&v48.var3);
  (*(void (**)(HGNode *, uint64_t, HGRect *))(*(void *)this + 104))(this, 1, &v48);
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 52) + 96))(*((void *)this + 52), 1, *(float *)&v48.var0, *(float *)&v48.var1, *(float *)&v48.var2, *(float *)&v48.var3);
  (*(void (**)(HGNode *, uint64_t, HGRect *))(*(void *)this + 104))(this, 2, &v48);
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 52) + 96))(*((void *)this + 52), 2, *(float *)&v48.var0, *(float *)&v48.var1, *(float *)&v48.var2, *(float *)&v48.var3);
  (*(void (**)(HGNode *, uint64_t, HGRect *))(*(void *)this + 104))(this, 3, &v48);
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 52) + 96))(*((void *)this + 52), 3, *(float *)&v48.var0, *(float *)&v48.var1, *(float *)&v48.var2, *(float *)&v48.var3);
  (*(void (**)(HGNode *, uint64_t, HGRect *))(*(void *)this + 104))(this, 4, &v48);
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 52) + 96))(*((void *)this + 52), 4, *(float *)&v48.var0, *(float *)&v48.var1, *(float *)&v48.var2, *(float *)&v48.var3);
  (*(void (**)(HGNode *, uint64_t, HGRect *))(*(void *)this + 104))(this, 5, &v48);
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 52) + 96))(*((void *)this + 52), 5, *(float *)&v48.var0, *(float *)&v48.var1, *(float *)&v48.var2, *(float *)&v48.var3);
  (*(void (**)(HGNode *, uint64_t, HGRect *))(*(void *)this + 104))(this, 6, &v48);
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 52) + 96))(*((void *)this + 52), 6, *(float *)&v48.var0, *(float *)&v48.var1, *(float *)&v48.var2, *(float *)&v48.var3);
  uint64_t v30 = *((void *)this + 52);
  (*(void (**)(HGTextureWrap *))(*(void *)v15 + 24))(v15);
  return v30;
}

void sub_1B7786760(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const char *HGGradientLinear::label_B(HGGradientLinear *this)
{
  uint64_t v1 = *((int *)this + 102);
  if (v1 > 2) {
    return "kXFormPerspective";
  }
  else {
    return off_1E616CDA8[v1];
  }
}

void HGGradientLinear::info(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void HGMetalHandler::HGMetalHandler(HGMetalHandler *this, HGMetalContext *a2)
{
  HGHandler::HGHandler(this);
  void *v4 = &unk_1F10D4FD0;
  if (a2) {
    (*(void (**)(HGMetalContext *))(*(void *)a2 + 16))(a2);
  }
  *((void *)this + 31) = a2;
  *((void *)this + 32) = 0;
  *((void *)this + 33) = 0;
  *((void *)this + 34) = 0;
  *((void *)this + 35) = (char *)this + 288;
  *((void *)this + 36) = 0;
  *((_DWORD *)this + 122) = 0;
  *((void *)this + 38) = 0;
  *((void *)this + 39) = 0;
  *((void *)this + 37) = 0;
  *((unsigned char *)this + 320) = 0;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  *(_OWORD *)((char *)this + 440) = 0u;
  *(_OWORD *)((char *)this + 456) = 0u;
  HGEdgePolicy::HGEdgePolicy((HGMetalHandler *)((char *)this + 508));
  HGEdgePolicy::HGEdgePolicy((HGMetalHandler *)((char *)this + 540));
  HGEdgePolicy::HGEdgePolicy((HGMetalHandler *)((char *)this + 572));
  HGEdgePolicy::HGEdgePolicy((HGMetalHandler *)((char *)this + 604));
  HGEdgePolicy::HGEdgePolicy((HGMetalHandler *)((char *)this + 636));
  HGEdgePolicy::HGEdgePolicy((HGMetalHandler *)((char *)this + 668));
  HGEdgePolicy::HGEdgePolicy((HGMetalHandler *)((char *)this + 700));
  HGEdgePolicy::HGEdgePolicy((HGMetalHandler *)((char *)this + 732));
  bzero((char *)this + 752, 0x270uLL);
  *((_DWORD *)this + 350) = 1;
  *((void *)this + 183) = 0;
  *((_OWORD *)this + 88) = 0u;
  *((_OWORD *)this + 89) = 0u;
  *((_OWORD *)this + 90) = 0u;
  *((unsigned char *)this + 1456) = 0;
  *((void *)this + 184) = 1;
  *((_DWORD *)this + 370) = 1;
  *(_OWORD *)((char *)this + 1484) = 0u;
  *((_DWORD *)this + 375) = 0;
  *((void *)this + 188) = 1;
  *((_DWORD *)this + 378) = 1;
  *(_OWORD *)((char *)this + 1516) = 0u;
  *((_DWORD *)this + 383) = 0;
  *((void *)this + 192) = 1;
  *((_DWORD *)this + 386) = 1;
  *((_DWORD *)this + 391) = 0;
  *(_OWORD *)((char *)this + 1548) = 0u;
  *((void *)this + 196) = 1;
  *((_DWORD *)this + 394) = 1;
  *((_DWORD *)this + 399) = 0;
  *(_OWORD *)((char *)this + 1580) = 0u;
  *((void *)this + 200) = 1;
  *((_DWORD *)this + 402) = 1;
  *((_DWORD *)this + 407) = 0;
  *(_OWORD *)((char *)this + 1612) = 0u;
  *((void *)this + 204) = 1;
  *((_DWORD *)this + 410) = 1;
  *((_DWORD *)this + 415) = 0;
  *(_OWORD *)((char *)this + 1644) = 0u;
  *((void *)this + 208) = 1;
  *((_DWORD *)this + 418) = 1;
  *((_DWORD *)this + 423) = 0;
  *(_OWORD *)((char *)this + 1676) = 0u;
  *((_OWORD *)this + 106) = xmmword_1B7EBF8F0;
  *((void *)this + 214) = 0;
  *((unsigned char *)this + 1744) = 0;
  *((_DWORD *)this + 445) = 0;
  *(_OWORD *)((char *)this + 1764) = 0u;
  *((_WORD *)this + 892) = 257;
  *((unsigned char *)this + 1786) = 0;
  *((_OWORD *)this + 112) = 0u;
  *((void *)this + 226) = 850045863;
  *((void *)this + 233) = 0;
  *(_OWORD *)((char *)this + 1848) = 0u;
  *(_OWORD *)((char *)this + 1832) = 0u;
  *(_OWORD *)((char *)this + 1816) = 0u;
  *((void *)this + 234) = 1018212795;
  *((void *)this + 239) = 0;
  *(_OWORD *)((char *)this + 1896) = 0u;
  *(_OWORD *)((char *)this + 1880) = 0u;
  operator new();
}

void sub_1B7786C58(_Unwind_Exception *a1, const PCString *a2)
{
  OZChannelBase::setRangeName(v2, a2);
  _Unwind_Resume(a1);
}

void sub_1B7786C6C()
{
  std::condition_variable::~condition_variable(v1);
  std::mutex::~mutex(v2);
  uint64_t v4 = *(void **)(v0 + 1432);
  if (v4)
  {
    *(void *)(v0 + 1440) = v4;
    operator delete(v4);
    if ((*(char *)(v0 + 1367) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*(char *)(v0 + 1343) & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else if ((*(char *)(v0 + 1367) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)(v0 + 1344));
  if ((*(char *)(v0 + 1343) & 0x80000000) == 0)
  {
LABEL_4:
    if ((*(char *)(v0 + 1319) & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_10;
  }
LABEL_9:
  operator delete(*(void **)(v0 + 1320));
  if ((*(char *)(v0 + 1319) & 0x80000000) == 0)
  {
LABEL_5:
    uint64_t v5 = *(void *)(v0 + 1288);
    if (!v5)
    {
LABEL_12:
      uint64_t v6 = *(void *)(v0 + 464);
      if (v6) {
        (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
      }
      uint64_t v7 = *(void *)(v0 + 456);
      if (v7) {
        (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
      }
      uint64_t v8 = *(void *)(v0 + 448);
      if (v8) {
        (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
      }
      uint64_t v9 = *(void *)(v0 + 440);
      if (v9) {
        (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
      }
      uint64_t v10 = *(void *)(v0 + 432);
      if (v10) {
        (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
      }
      uint64_t v11 = *(void *)(v0 + 424);
      if (v11) {
        (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
      }
      uint64_t v12 = *(void *)(v0 + 416);
      if (v12) {
        (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
      }
      uint64_t v13 = *(void *)(v0 + 408);
      if (v13) {
        (*(void (**)(uint64_t))(*(void *)v13 + 24))(v13);
      }
      uint64_t v14 = *(void *)(v0 + 400);
      if (v14) {
        (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);
      }
      uint64_t v15 = *(void *)(v0 + 392);
      if (v15) {
        (*(void (**)(uint64_t))(*(void *)v15 + 24))(v15);
      }
      uint64_t v16 = *(void *)(v0 + 384);
      if (v16) {
        (*(void (**)(uint64_t))(*(void *)v16 + 24))(v16);
      }
      uint64_t v17 = *(void *)(v0 + 376);
      if (v17) {
        (*(void (**)(uint64_t))(*(void *)v17 + 24))(v17);
      }
      uint64_t v18 = *(void *)(v0 + 368);
      if (v18) {
        (*(void (**)(uint64_t))(*(void *)v18 + 24))(v18);
      }
      uint64_t v19 = *(void *)(v0 + 360);
      if (v19) {
        (*(void (**)(uint64_t))(*(void *)v19 + 24))(v19);
      }
      uint64_t v20 = *(void *)(v0 + 352);
      if (v20) {
        (*(void (**)(uint64_t))(*(void *)v20 + 24))(v20);
      }
      uint64_t v21 = *(void *)(v0 + 344);
      if (v21) {
        (*(void (**)(uint64_t))(*(void *)v21 + 24))(v21);
      }
      uint64_t v22 = *(void *)(v0 + 336);
      if (v22) {
        (*(void (**)(uint64_t))(*(void *)v22 + 24))(v22);
      }
      if (*v3) {
        (*(void (**)(void))(*(void *)*v3 + 24))(*v3);
      }
      std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v0 + 280, *(void **)(v0 + 288));
      uint64_t v23 = *(void *)(v0 + 248);
      if (v23) {
        (*(void (**)(uint64_t))(*(void *)v23 + 24))(v23);
      }
      JUMPOUT(0x1B7786C5CLL);
    }
LABEL_11:
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
    goto LABEL_12;
  }
LABEL_10:
  operator delete(*(void **)(v0 + 1296));
  uint64_t v5 = *(void *)(v0 + 1288);
  if (!v5) {
    goto LABEL_12;
  }
  goto LABEL_11;
}

void HGMetalHandler::~HGMetalHandler(HGMetalHandler *this)
{
  *(void *)this = &unk_1F10D4FD0;
  uint64_t v2 = (HGMetalHandler::CommandEncoderCargo *)*((void *)this + 39);
  if (v2)
  {
    HGMetalHandler::CommandEncoderCargo::~CommandEncoderCargo(v2);
    MEMORY[0x1BA9BFBA0]();
  }
  uint64_t v3 = *((void *)this + 34);
  if (v3)
  {
    uint64_t v4 = *(void **)v3;
    if (*(void *)v3)
    {
      *(void *)(v3 + 8) = v4;
      operator delete(v4);
    }
    MEMORY[0x1BA9BFBA0](v3, 0x80C40D6874129);
  }
  uint64_t v5 = (void *)*((void *)this + 159);
  if (v5) {
    free(v5);
  }
  uint64_t v6 = (void *)*((void *)this + 176);
  if (v6) {

  }
  *((void *)this + 176) = 0;
  uint64_t v7 = (void *)*((void *)this + 177);
  if (v7) {

  }
  *((void *)this + 177) = 0;
  uint64_t v8 = (void *)*((void *)this + 178);
  if (v8) {

  }
  *((void *)this + 178) = 0;
  uint64_t v9 = (id *)*((void *)this + 179);
  uint64_t v10 = (id *)*((void *)this + 180);
  if (v9 != v10)
  {
    do

    while (v9 != v10);
    uint64_t v9 = (id *)*((void *)this + 179);
  }
  *((void *)this + 180) = v9;
  std::condition_variable::~condition_variable((std::condition_variable *)this + 39);
  std::mutex::~mutex((std::mutex *)((char *)this + 1808));
  uint64_t v11 = (void *)*((void *)this + 179);
  if (v11)
  {
    *((void *)this + 180) = v11;
    operator delete(v11);
  }
  if (*((char *)this + 1367) < 0)
  {
    operator delete(*((void **)this + 168));
    if ((*((char *)this + 1343) & 0x80000000) == 0)
    {
LABEL_22:
      if ((*((char *)this + 1319) & 0x80000000) == 0) {
        goto LABEL_23;
      }
LABEL_27:
      operator delete(*((void **)this + 162));
      uint64_t v12 = *((void *)this + 161);
      if (!v12) {
        goto LABEL_29;
      }
      goto LABEL_28;
    }
  }
  else if ((*((char *)this + 1343) & 0x80000000) == 0)
  {
    goto LABEL_22;
  }
  operator delete(*((void **)this + 165));
  if (*((char *)this + 1319) < 0) {
    goto LABEL_27;
  }
LABEL_23:
  uint64_t v12 = *((void *)this + 161);
  if (v12) {
LABEL_28:
  }
    (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
LABEL_29:
  uint64_t v13 = *((void *)this + 58);
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 24))(v13);
  }
  uint64_t v14 = *((void *)this + 57);
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);
  }
  uint64_t v15 = *((void *)this + 56);
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 24))(v15);
  }
  uint64_t v16 = *((void *)this + 55);
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 24))(v16);
  }
  uint64_t v17 = *((void *)this + 54);
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 24))(v17);
  }
  uint64_t v18 = *((void *)this + 53);
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 24))(v18);
  }
  uint64_t v19 = *((void *)this + 52);
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 24))(v19);
  }
  uint64_t v20 = *((void *)this + 51);
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 24))(v20);
  }
  uint64_t v21 = *((void *)this + 50);
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 24))(v21);
  }
  uint64_t v22 = *((void *)this + 49);
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 24))(v22);
  }
  uint64_t v23 = *((void *)this + 48);
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 24))(v23);
  }
  uint64_t v24 = *((void *)this + 47);
  if (v24) {
    (*(void (**)(uint64_t))(*(void *)v24 + 24))(v24);
  }
  uint64_t v25 = *((void *)this + 46);
  if (v25) {
    (*(void (**)(uint64_t))(*(void *)v25 + 24))(v25);
  }
  uint64_t v26 = *((void *)this + 45);
  if (v26) {
    (*(void (**)(uint64_t))(*(void *)v26 + 24))(v26);
  }
  uint64_t v27 = *((void *)this + 44);
  if (v27) {
    (*(void (**)(uint64_t))(*(void *)v27 + 24))(v27);
  }
  uint64_t v28 = *((void *)this + 43);
  if (v28) {
    (*(void (**)(uint64_t))(*(void *)v28 + 24))(v28);
  }
  uint64_t v29 = *((void *)this + 42);
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 24))(v29);
  }
  uint64_t v30 = *((void *)this + 41);
  if (v30) {
    (*(void (**)(uint64_t))(*(void *)v30 + 24))(v30);
  }
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 280, *((void **)this + 36));
  uint64_t v32 = *((void *)this + 31);
  if (v32) {
    (*(void (**)(uint64_t))(*(void *)v32 + 24))(v32);
  }

  OZChannelBase::setRangeName((OZChannelBase *)this, v31);
}

{
  uint64_t vars8;

  HGMetalHandler::~HGMetalHandler(this);

  JUMPOUT(0x1BA9BFBA0);
}

HGBitmap *HGMetalHandler::BindBuffer(HGMetalHandler *this, HGBitmap *a2)
{
  HGMetalHandler::BindBuffer(this, 0, a2, (const char *)1);
  HGMetalHandler::BindBuffer(this, 1, 0, (const char *)1);
  HGMetalHandler::BindBuffer(this, 2, 0, (const char *)1);
  HGMetalHandler::BindBuffer(this, 3, 0, (const char *)1);
  HGMetalHandler::BindBuffer(this, 4, 0, (const char *)1);
  HGMetalHandler::BindBuffer(this, 5, 0, (const char *)1);
  HGMetalHandler::BindBuffer(this, 6, 0, (const char *)1);

  return HGMetalHandler::BindBuffer(this, 7, 0, (const char *)1);
}

HGBitmap *HGMetalHandler::BindBuffer(HGMetalHandler *this, HGBitmap *a2, const char *a3)
{
  HGMetalHandler::BindBuffer(this, 0, a2, a3);
  HGMetalHandler::BindBuffer(this, 1, 0, (const char *)1);
  HGMetalHandler::BindBuffer(this, 2, 0, (const char *)1);
  HGMetalHandler::BindBuffer(this, 3, 0, (const char *)1);
  HGMetalHandler::BindBuffer(this, 4, 0, (const char *)1);
  HGMetalHandler::BindBuffer(this, 5, 0, (const char *)1);
  HGMetalHandler::BindBuffer(this, 6, 0, (const char *)1);

  return HGMetalHandler::BindBuffer(this, 7, 0, (const char *)1);
}

HGBitmap *HGMetalHandler::BindBuffer(HGMetalHandler *this, int a2, HGBitmap *a3, const char *a4)
{
  uint64_t v8 = (void *)*((void *)this + 39);
  uint64_t v9 = v8;
  if (*v8)
  {
    (*(void (**)(void))(*(void *)*v8 + 24))(*v8);
    uint64_t v9 = (void *)*((void *)this + 39);
  }
  *uint64_t v8 = 0;
  uint64_t v10 = v9[1];
  uint64_t v11 = v9;
  if (v10)
  {
    (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
    uint64_t v11 = (void *)*((void *)this + 39);
  }
  v9[1] = 0;
  uint64_t v12 = v11[2];
  uint64_t v13 = v11;
  if (v12)
  {
    (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
    uint64_t v13 = (void *)*((void *)this + 39);
  }
  v11[2] = 0;
  uint64_t v14 = v13[3];
  uint64_t v15 = v13;
  if (v14)
  {
    (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);
    uint64_t v15 = (void *)*((void *)this + 39);
  }
  v13[3] = 0;
  uint64_t v16 = v15[4];
  uint64_t v17 = v15;
  if (v16)
  {
    (*(void (**)(uint64_t))(*(void *)v16 + 24))(v16);
    uint64_t v17 = (void *)*((void *)this + 39);
  }
  v15[4] = 0;
  uint64_t v18 = v17[5];
  uint64_t v19 = v17;
  if (v18)
  {
    (*(void (**)(uint64_t))(*(void *)v18 + 24))(v18);
    uint64_t v19 = (void *)*((void *)this + 39);
  }
  v17[5] = 0;
  uint64_t v20 = v19[6];
  uint64_t v21 = v19;
  if (v20)
  {
    (*(void (**)(uint64_t))(*(void *)v20 + 24))(v20);
    uint64_t v21 = (void *)*((void *)this + 39);
  }
  v19[6] = 0;
  uint64_t v22 = v21[7];
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 24))(v22);
  }
  v21[7] = 0;
  if (a3)
  {
    LUTEnd = (HGMetalDeviceInfo *)PCICCTransferFunctionLUT::getLUTEnd(*((PCICCTransferFunctionLUT **)this + 31));
    uint64_t result = (HGBitmap *)HGMetalDeviceInfo::validateTextureSampleCount(LUTEnd, a4, v24);
    int v26 = (int)result;
    uint64_t v27 = (HGBitmap **)((char *)this + 8 * a2);
    if (v27[41] != a3 || result != *((_DWORD *)this + 118))
    {
      uint64_t v28 = v27 + 41;
      HGMetalHandler::FinalizeCommandEncoder(this, *(_DWORD *)(*((void *)this + 31) + 64), *(void *)(*((void *)this + 31) + 72), *(void *)(*((void *)this + 31) + 88));
      *((_DWORD *)this + 118) = v26;
      (*(void (**)(HGBitmap *))(*(void *)a3 + 16))(a3);
      uint64_t v29 = *v28;
      if (*v28 == a3)
      {
        (*(void (**)(HGBitmap *))(*(void *)a3 + 24))(a3);
      }
      else
      {
        if (v29) {
          (*(void (**)(HGBitmap *))(*(void *)v29 + 24))(v29);
        }
        *uint64_t v28 = a3;
      }
      float v33 = HGGPURenderer::ConvertToMetalTexture(*((HGMetalTexture ***)this + 18), a3);
      float v34 = (uint64_t *)((char *)this + 8 * a2 + 392);
      uint64_t v35 = *v34;
      if ((HGBitmap *)*v34 == v33)
      {
        if (v33) {
          (*(void (**)(HGBitmap *))(*(void *)v33 + 24))(v33);
        }
      }
      else
      {
        if (v35) {
          (*(void (**)(uint64_t))(*(void *)v35 + 24))(v35);
        }
        *float v34 = (uint64_t)v33;
      }
      *(void *)&v63.int var0 = 0;
      *(void *)&v63.int var2 = 0;
      NodeMetalTexture = HGGPURenderer::GetNodeMetalTexture(*((HGGPURenderer **)this + 18), 0, v63, 0, 1u);
      uint64_t result = (HGBitmap *)*v34;
      if (!*v34 || result == NodeMetalTexture)
      {
        if (*v28)
        {
          (*(void (**)(HGBitmap *))(*(void *)*v28 + 24))(*v28);
          uint64_t result = (HGBitmap *)*v34;
        }
        *uint64_t v28 = 0;
        if (result) {
          (*(void (**)(HGBitmap *))(*(void *)result + 24))(result);
        }
        *float v34 = 0;
        *((unsigned char *)this + 1785) = 0;
        uint64_t result = (HGBitmap *)HGLogger::warning((HGLogger *)"HGMetalHandler::BindBuffer -- null buffer target!!", v36, v37);
      }
      else
      {
        float32x2_t v39 = vcvt_f32_s32(*(int32x2_t *)((char *)result + 28));
        float32x2_t v40 = vcvt_f32_s32(*(int32x2_t *)((char *)result + 20));
        float32x2_t v41 = (float32x2_t)__PAIR64__(v39.u32[1], v40.u32[0]);
        float32x2_t v42 = vadd_f32(v39, v40);
        v39.i32[1] = v40.i32[1];
        __asm { FMOV            V1.2S, #1.0 }
        float32x2_t v48 = vdiv_f32(_D1, vsub_f32(v39, v41));
        v41.i32[0] = 0;
        *(float *)&unsigned int v49 = v48.f32[0] + v48.f32[0];
        v41.f32[1] = v48.f32[1] + v48.f32[1];
        *(float32x2_t *)&long long v50 = vmul_f32(v42, vneg_f32(v48));
        *((void *)&v50 + 1) = 0x3F8000003F000000;
        *((_OWORD *)this + 5) = v49;
        *((_OWORD *)this + 6) = (unint64_t)v41;
        *((_OWORD *)this + 7) = xmmword_1B8345BA0;
        *((_OWORD *)this + 8) = v50;
      }
      if (*((unsigned char *)this + 1785) && *((_DWORD *)this + 118) >= 2u)
      {
        uint64_t v51 = *((void *)this + 58);
        uint64_t v52 = *((void *)this + 49);
        if (v51 != v52)
        {
          if (v51)
          {
            (*(void (**)(void))(*(void *)v51 + 24))(*((void *)this + 58));
            uint64_t v52 = *((void *)this + 49);
          }
          *((void *)this + 58) = v52;
          if (v52) {
            (*(void (**)(uint64_t))(*(void *)v52 + 16))(v52);
          }
        }
        float32x4_t v53 = (HGMetalContext *)*((void *)this + 31);
        int32x4_t v54 = *(void **)(*((void *)v53 + 2) + 16);
        int32x4_t v55 = (uint64_t *)HGMetalContext::texturePool(v53);
        TextureRect = (char *)HGMetalTexture::GetTextureRect(*((HGMetalTexture **)this + 58));
        HGMetalTexture::createMSAA(v54, v55, TextureRect, v57, *(_DWORD *)(*((void *)this + 58) + 16), *((_DWORD *)this + 118), &v62);
        float32x4_t v58 = *v28;
        uint64_t v59 = v62;
        if (*v28 != (HGBitmap *)v62)
        {
          if (v58)
          {
            (*(void (**)(HGBitmap *))(*(void *)v58 + 24))(*v28);
            uint64_t v59 = v62;
          }
          *uint64_t v28 = (HGBitmap *)v59;
          if (v59)
          {
            (*(void (**)(uint64_t))(*(void *)v59 + 16))(v59);
            float32x4_t v58 = (HGBitmap *)v62;
          }
          else
          {
            float32x4_t v58 = 0;
          }
        }
        float v60 = HGGPURenderer::ConvertToMetalTexture(*((HGMetalTexture ***)this + 18), v58);
        uint64_t v61 = *v34;
        if ((HGBitmap *)*v34 == v60)
        {
          if (v60) {
            (*(void (**)(HGBitmap *))(*(void *)v60 + 24))(v60);
          }
        }
        else
        {
          if (v61) {
            (*(void (**)(uint64_t))(*(void *)v61 + 24))(v61);
          }
          *float v34 = (uint64_t)v60;
        }
        uint64_t result = (HGBitmap *)v62;
        if (v62) {
          uint64_t result = (HGBitmap *)(*(uint64_t (**)(uint64_t))(*(void *)v62 + 24))(v62);
        }
      }
      if (NodeMetalTexture) {
        return (HGBitmap *)(*(uint64_t (**)(HGBitmap *))(*(void *)NodeMetalTexture + 24))(NodeMetalTexture);
      }
    }
  }
  else
  {
    uint64_t v30 = a2;
    uint64_t v31 = (void *)((char *)this + 8 * a2 + 328);
    if (*v31) {
      (*(void (**)(void))(*(void *)*v31 + 24))(*v31);
    }
    *uint64_t v31 = 0;
    uint64_t v32 = (uint64_t *)((char *)this + 8 * v30 + 392);
    uint64_t result = (HGBitmap *)*v32;
    if (*v32) {
      uint64_t result = (HGBitmap *)(*(uint64_t (**)(HGBitmap *))(*(void *)result + 24))(result);
    }
    *uint64_t v32 = 0;
  }
  return result;
}

void sub_1B7787E84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
  }
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  }
  _Unwind_Resume(exception_object);
}

__n128 HGMetalHandler::BindTexture(HGMetalTexture ***this, int a2, HGBitmap *a3)
{
  if (a3)
  {
    *(void *)&v15.int var0 = *(void *)((char *)a3 + 20);
    *(void *)&v15.int var2 = *(void *)((char *)a3 + 28);
    uint64_t v6 = HGGPURenderer::ConvertToMetalTexture(this[18], v15, a3, 0);
    uint64_t v7 = this[39];
    uint64_t v8 = (HGBitmap *)v7[a2];
    if (v8 == v6)
    {
      if (v6) {
        (*(void (**)(HGBitmap *))(*(void *)v6 + 24))(v6);
      }
    }
    else
    {
      if (v8) {
        (*(void (**)(HGBitmap *))(*(void *)v8 + 24))(v8);
      }
      v7[a2] = (HGMetalTexture *)v6;
    }
    EdgePolicy = (__n128 *)HGBitmap::GetEdgePolicy(a3);
    uint64_t v13 = &this[4 * a2];
    unsigned __int32 v14 = EdgePolicy[1].n128_u32[0];
    __n128 result = *EdgePolicy;
    *(__n128 *)((char *)v13 + 508) = *EdgePolicy;
    *((_DWORD *)v13 + 131) = v14;
  }
  else
  {
    uint64_t v9 = this[39];
    uint64_t v10 = v9[a2];
    if (v10) {
      (*(void (**)(HGMetalTexture *))(*(void *)v10 + 24))(v10);
    }
    v9[a2] = 0;
  }
  return result;
}

void sub_1B77880F0(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

HGMetalHandler *HGMetalHandler::Reset(HGMetalHandler *this, HGRenderer *a2)
{
  HGHandler::Reset((uint64_t)this, (uint64_t)a2);
  *((_DWORD *)this + 124) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 23);
  *((_DWORD *)this + 125) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 23);
  *((unsigned char *)this + 504) = (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46) == 0;
  HGEdgePolicy::HGEdgePolicy((HGEdgePolicy *)&v14);
  *(_OWORD *)((char *)this + 508) = v14;
  *((_DWORD *)this + 131) = v15;
  *((_DWORD *)this + 132) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 23);
  *((_DWORD *)this + 133) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 23);
  *((unsigned char *)this + 536) = (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46) == 0;
  HGEdgePolicy::HGEdgePolicy((HGEdgePolicy *)&v14);
  *(_OWORD *)((char *)this + 540) = v14;
  *((_DWORD *)this + 139) = v15;
  *((_DWORD *)this + 140) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 23);
  *((_DWORD *)this + 141) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 23);
  *((unsigned char *)this + 568) = (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46) == 0;
  HGEdgePolicy::HGEdgePolicy((HGEdgePolicy *)&v14);
  *(_OWORD *)((char *)this + 572) = v14;
  *((_DWORD *)this + 147) = v15;
  *((_DWORD *)this + 148) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 23);
  *((_DWORD *)this + 149) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 23);
  *((unsigned char *)this + 600) = (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46) == 0;
  HGEdgePolicy::HGEdgePolicy((HGEdgePolicy *)&v14);
  *(_OWORD *)((char *)this + 604) = v14;
  *((_DWORD *)this + 155) = v15;
  *((_DWORD *)this + 156) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 23);
  *((_DWORD *)this + 157) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 23);
  *((unsigned char *)this + 632) = (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46) == 0;
  HGEdgePolicy::HGEdgePolicy((HGEdgePolicy *)&v14);
  *(_OWORD *)((char *)this + 636) = v14;
  *((_DWORD *)this + 163) = v15;
  *((_DWORD *)this + 164) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 23);
  *((_DWORD *)this + 165) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 23);
  *((unsigned char *)this + 664) = (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46) == 0;
  HGEdgePolicy::HGEdgePolicy((HGEdgePolicy *)&v14);
  *(_OWORD *)((char *)this + 668) = v14;
  *((_DWORD *)this + 171) = v15;
  *((_DWORD *)this + 172) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 23);
  *((_DWORD *)this + 173) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 23);
  *((unsigned char *)this + 696) = (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46) == 0;
  HGEdgePolicy::HGEdgePolicy((HGEdgePolicy *)&v14);
  *(_OWORD *)((char *)this + 700) = v14;
  *((_DWORD *)this + 179) = v15;
  *((_DWORD *)this + 180) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 23);
  *((_DWORD *)this + 181) = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 23);
  *((unsigned char *)this + 728) = (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46) == 0;
  HGEdgePolicy::HGEdgePolicy((HGEdgePolicy *)&v14);
  *(_OWORD *)((char *)this + 732) = v14;
  *((_DWORD *)this + 187) = v15;
  uint64_t v4 = *((void *)this + 58);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
    *((void *)this + 58) = 0;
  }
  *((_DWORD *)this + 118) = 1;
  *(void *)((char *)this + 484) = 0;
  *(void *)((char *)this + 476) = 0;
  uint64_t v5 = (void *)*((void *)this + 159);
  if (v5)
  {
    size_t v6 = *((void *)this + 158);
    if (v6) {
      bzero(v5, v6);
    }
  }
  uint64_t v7 = *((void *)this + 161);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
  }
  *((void *)this + 161) = 0;
  *((void *)this + 158) = 0;
  *((unsigned char *)this + 492) = 0;
  uint64_t v8 = (void *)*((void *)this + 177);
  if (v8) {

  }
  *((void *)this + 177) = 0;
  uint64_t v9 = (void *)*((void *)this + 178);
  if (v9) {

  }
  *((void *)this + 178) = 0;
  uint64_t v10 = (void **)*((void *)this + 179);
  uint64_t v11 = (void **)*((void *)this + 180);
  if (v10 != v11)
  {
    do
    {
      uint64_t v12 = *v10++;
    }
    while (v10 != v11);
    uint64_t v10 = (void **)*((void *)this + 179);
  }
  *((void *)this + 180) = v10;
  *((_OWORD *)this + 47) = xmmword_1B7E736B0;
  *((_OWORD *)this + 48) = xmmword_1B7E736C0;
  *((_OWORD *)this + 49) = xmmword_1B7E736D0;
  *((_OWORD *)this + 50) = xmmword_1B7E734D0;
  *((_OWORD *)this + 51) = xmmword_1B7E736B0;
  *((_OWORD *)this + 52) = xmmword_1B7E736C0;
  *((_OWORD *)this + 53) = xmmword_1B7E736D0;
  *((_OWORD *)this + 54) = xmmword_1B7E734D0;
  *((_OWORD *)this + 55) = xmmword_1B7E736B0;
  *((_OWORD *)this + 56) = xmmword_1B7E736C0;
  *((_OWORD *)this + 57) = xmmword_1B7E736D0;
  *((_OWORD *)this + 58) = xmmword_1B7E734D0;
  *((_OWORD *)this + 59) = xmmword_1B7E736B0;
  *((_OWORD *)this + 60) = xmmword_1B7E736C0;
  *((_OWORD *)this + 61) = xmmword_1B7E736D0;
  *((_OWORD *)this + 62) = xmmword_1B7E734D0;
  *((_OWORD *)this + 63) = xmmword_1B7E736B0;
  *((_OWORD *)this + 64) = xmmword_1B7E736C0;
  *((_OWORD *)this + 65) = xmmword_1B7E736D0;
  *((_OWORD *)this + 66) = xmmword_1B7E734D0;
  *((_OWORD *)this + 67) = xmmword_1B7E736B0;
  *((_OWORD *)this + 68) = xmmword_1B7E736C0;
  *((_OWORD *)this + 69) = xmmword_1B7E736D0;
  *((_OWORD *)this + 70) = xmmword_1B7E734D0;
  *((_OWORD *)this + 71) = xmmword_1B7E736B0;
  *((_OWORD *)this + 72) = xmmword_1B7E736C0;
  *((_OWORD *)this + 73) = xmmword_1B7E736D0;
  *((_OWORD *)this + 74) = xmmword_1B7E734D0;
  *((_OWORD *)this + 75) = xmmword_1B7E736B0;
  *((_OWORD *)this + 76) = xmmword_1B7E736C0;
  *((_OWORD *)this + 77) = xmmword_1B7E736D0;
  *((_OWORD *)this + 78) = xmmword_1B7E734D0;
  *((unsigned char *)this + 1456) = 0;
  if (*((char *)this + 1319) < 0) {
    operator delete(*((void **)this + 162));
  }
  strcpy((char *)this + 1296, "HGMetalHandler");
  *((unsigned char *)this + 1319) = 14;
  *((_WORD *)this + 892) = 257;
  return this;
}

HGMetalHandler *HGMetalHandler::InitTextureUnit(HGMetalHandler *this, HGRect a2, int a3)
{
  uint64_t v4 = *((void *)this + 39);
  uint64_t v5 = *(void *)(v4 + 8 * a3);
  if (v5)
  {
    uint64_t v6 = *(void *)&a2.var2;
    uint64_t v7 = *(void *)&a2.var0;
    uint64_t v8 = *(void *)(v5 + 20);
    uint64_t v9 = *(void *)(v5 + 28);
    *(void *)&v14.int var0 = HGMetalTexture::GetTextureRect(*(HGMetalTexture **)(v4 + 8 * a3));
    *(void *)&v14.int var2 = v10;
    *(void *)&v12.int var0 = v7;
    *(void *)&v12.int var2 = v6;
    *(void *)&v13.int var0 = v8;
    *(void *)&v13.int var2 = v9;
    HGHandler::InitTexture((uint64_t)this, 0, v12, v13, v14, -*(_DWORD *)(v5 + 20), -*(_DWORD *)(v5 + 24));
  }
  return this;
}

int32x2_t HGMetalHandler::SetFilter(int32x2_t *this, unsigned int a2, unsigned int a3)
{
  int32x2_t v3 = vcltz_s32((int32x2_t)__PAIR64__(a3, a2));
  int32x2_t result = vsub_s32((int32x2_t)vbic_s8((int8x8_t)__PAIR64__(a3, a2), (int8x8_t)v3), v3);
  this[4 * this[59].u32[1] + 62] = result;
  return result;
}

__n128 HGMetalHandler::SetEdgePolicy(HGMetalHandler *this, const HGEdgePolicy *a2)
{
  uint64_t v2 = (char *)this + 32 * *((unsigned int *)this + 119);
  __n128 result = *(__n128 *)a2;
  *((_DWORD *)v2 + 131) = *((_DWORD *)a2 + 4);
  *(__n128 *)(v2 + 508) = result;
  return result;
}

uint64_t HGMetalHandler::SetTextureCoordinateNormalization(uint64_t this, char a2)
{
  *(unsigned char *)(this + 32 * *(unsigned int *)(this + 476) + 504) = a2;
  return this;
}

uint64_t HGMetalHandler::SetParamBufferDesc(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 1288);
  uint64_t result = *a2;
  if (v3 != *a2)
  {
    if (v3)
    {
      (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
      uint64_t result = *a2;
    }
    *(void *)(a1 + 1288) = result;
    if (result)
    {
      uint64_t v6 = *(uint64_t (**)(void))(*(void *)result + 16);
      return v6();
    }
  }
  return result;
}

uint64_t HGMetalHandler::ActiveTexture(HGMetalHandler *this, int a2)
{
  uint64_t v2 = (*((_DWORD *)this + 44) + a2);
  *((_DWORD *)this + 119) = v2;
  return v2;
}

uint64_t HGMetalHandler::ActiveTextureMatrix(HGMetalHandler *this, int a2)
{
  uint64_t v2 = (*((_DWORD *)this + 40) + a2);
  *((_DWORD *)this + 120) = v2;
  return v2;
}

double HGMetalHandler::LoadIdentity(HGMetalHandler *this)
{
  uint64_t v1 = *((unsigned int *)this + 120);
  uint64_t v2 = (_OWORD *)((char *)this + 64 * v1);
  v2[47] = xmmword_1B7E736B0;
  v2[48] = xmmword_1B7E736C0;
  double result = 0.0;
  v2[49] = xmmword_1B7E736D0;
  v2[50] = xmmword_1B7E734D0;
  *((_DWORD *)this + 121) |= 1 << v1;
  return result;
}

float32x4_t HGMetalHandler::Translate(HGMetalHandler *this, double a2, double a3, double a4)
{
  float v4 = a2;
  float v5 = a3;
  float v6 = a4;
  uint64_t v7 = *((unsigned int *)this + 120);
  uint64_t v8 = (float32x4_t *)((char *)this + 64 * v7);
  float32x4_t result = vaddq_f32(v8[50], vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v8[47], v4), v8[48], v5), v8[49], v6));
  v8[50] = result;
  *((_DWORD *)this + 121) |= 1 << v7;
  return result;
}

float32x4_t HGMetalHandler::Scale(HGMetalHandler *this, double a2, double a3, double a4)
{
  float v4 = a2;
  float v5 = a3;
  float v6 = a4;
  uint64_t v7 = *((unsigned int *)this + 120);
  uint64_t v8 = (float32x4_t *)((char *)this + 64 * v7);
  float32x4_t result = vmulq_n_f32(v8[47], v4);
  float32x4_t v10 = vmulq_n_f32(v8[48], v5);
  float32x4_t v11 = vmulq_n_f32(v8[49], v6);
  v8[47] = result;
  v8[48] = v10;
  v8[49] = v11;
  *((_DWORD *)this + 121) |= 1 << v7;
  return result;
}

float32x4_t HGMetalHandler::MultMatrix(HGMetalHandler *this, const double *a2)
{
  float v2 = *a2;
  float v3 = a2[1];
  float v4 = a2[2];
  float v5 = a2[3];
  float v6 = a2[4];
  float v7 = a2[5];
  float v8 = a2[6];
  float v9 = a2[7];
  float v10 = a2[8];
  float v11 = a2[9];
  float v12 = a2[10];
  float v13 = a2[11];
  float v14 = a2[12];
  float v15 = a2[13];
  float v16 = a2[14];
  float v17 = a2[15];
  uint64_t v18 = *((unsigned int *)this + 120);
  uint64_t v19 = (float32x4_t *)((char *)this + 64 * v18);
  float32x4_t v20 = v19[47];
  float32x4_t v21 = v19[48];
  float32x4_t v22 = v19[49];
  float32x4_t v23 = v19[50];
  float32x4_t result = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v20, v2), v21, v3), v22, v4), v23, v5);
  v19[47] = result;
  v19[48] = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v20, v6), v21, v7), v22, v8), v23, v9);
  v19[49] = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v20, v10), v21, v11), v22, v12), v23, v13);
  v19[50] = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v20, v14), v21, v15), v22, v16), v23, v17);
  *((_DWORD *)this + 121) |= 1 << v18;
  return result;
}

float32x4_t HGMetalHandler::MultMatrix(HGMetalHandler *this, float *a2)
{
  uint64_t v2 = *((unsigned int *)this + 120);
  float v3 = (float32x4_t *)((char *)this + 64 * v2);
  float32x4_t v4 = v3[47];
  float32x4_t v5 = v3[48];
  float32x4_t v6 = v3[49];
  float32x4_t v7 = v3[50];
  float32x4_t result = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v4, *a2), v5, a2[1]), v6, a2[2]), v7, a2[3]);
  float32x4_t v9 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v4, a2[4]), v5, a2[5]), v6, a2[6]), v7, a2[7]);
  float32x4_t v10 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v4, a2[8]), v5, a2[9]), v6, a2[10]), v7, a2[11]);
  float32x4_t v11 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v4, a2[12]), v5, a2[13]), v6, a2[14]), v7, a2[15]);
  v3[47] = result;
  v3[48] = v9;
  v3[49] = v10;
  v3[50] = v11;
  *((_DWORD *)this + 121) |= 1 << v2;
  return result;
}

uint64_t HGMetalHandler::LocalParameter(HGMetalHandler *this, uint64_t a2, float a3, float a4, float a5, float a6)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  *(float *)float32x4_t v7 = a3;
  *(float *)&v7[1] = a4;
  *(float *)&v7[2] = a5;
  *(float *)&v7[3] = a6;
  return (*(uint64_t (**)(HGMetalHandler *, uint64_t, _DWORD *, uint64_t))(*(void *)this + 144))(this, a2, v7, 1);
}

uint64_t HGMetalHandler::LocalParameters(HGMetalHandler *this, int a2, const float *a3, int a4)
{
  return (*(uint64_t (**)(HGMetalHandler *, const float *, uint64_t, uint64_t))(*(void *)this + 152))(this, a3, 16 * a4, 16 * a2);
}

uint64_t HGMetalHandler::LocalParametersBuffer(HGMetalHandler *this, void *__src, size_t __n, uint64_t a4)
{
  uint64_t result = 0;
  if (!__src || !__n) {
    return result;
  }
  uint64_t v8 = *((int *)this + 43) + a4;
  size_t v9 = v8 + __n;
  if (*((void *)this + 160) <= v8 + __n)
  {
    float32x4_t v10 = (void *)*((void *)this + 159);
    if (v10)
    {
      float32x4_t v11 = malloc_type_realloc(v10, (v9 & 0xFFFFFFFFFFFFFF80) + 128, 0x38661485uLL);
      if (v11)
      {
LABEL_6:
        *((void *)this + 159) = v11;
        *((void *)this + 160) = (v9 & 0xFFFFFFFFFFFFFF80) + 128;
        goto LABEL_7;
      }
    }
    else
    {
      float32x4_t v11 = malloc_type_malloc((v9 & 0xFFFFFFFFFFFFFF80) + 128, 0xF7309BC3uLL);
      if (v11) {
        goto LABEL_6;
      }
    }
    HGLogger::warning((HGLogger *)"HGMetalHandler::LocalParametersBuffer -- failed to allocate memory", v12, v13);
    return 0xFFFFFFFFLL;
  }
LABEL_7:
  if (*((void *)this + 158) < v9) {
    *((void *)this + 158) = v9;
  }
  memcpy((void *)(*((void *)this + 159) + v8), __src, __n);
  return 0;
}

float32x4_t HGMetalHandler::Normalize(HGMetalHandler *this)
{
  int32x2_t v1 = vsub_s32(*(int32x2_t *)((char *)this + 228), *(int32x2_t *)((char *)this + 220));
  v2.i64[0] = v1.u32[0];
  v2.i64[1] = v1.u32[1];
  __asm { FMOV            V1.2D, #1.0 }
  *(float32x2_t *)v8.f32 = vcvt_f32_f64(vdivq_f64(_Q1, vcvtq_f64_u64(v2)));
  __asm { FMOV            V1.2S, #1.0 }
  v8.i64[1] = *(void *)&_Q1.f64[0];
  uint64_t v9 = *((unsigned int *)this + 120);
  float32x4_t v10 = (float32x4_t *)((char *)this + 64 * v9);
  float32x4_t v11 = vmulq_f32(v10[47], v8);
  float32x4_t v12 = vmulq_f32(v10[48], v8);
  float32x4_t v13 = vmulq_f32(v10[49], v8);
  float32x4_t result = vmulq_f32(v10[50], v8);
  v10[47] = v11;
  v10[48] = v12;
  v10[49] = v13;
  v10[50] = result;
  *((_DWORD *)this + 121) |= 1 << v9;
  return result;
}

uint64_t HGMetalHandler::Rect(HGMetalHandler *this, HGRect a2, const char *a3, char *a4)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  HGRect v14 = a2;
  uint64_t v6 = *((void *)this + 41);
  if (v6)
  {
    unint64_t v7 = HGFormatUtils::collapseRectForFormat((uint64_t *)&v14.var0, *(_DWORD *)(v6 + 16));
    *(void *)&a2.int var2 = *(void *)&a2.var0;
    *(void *)&v14.int var0 = v7;
    *(void *)&v14.int var2 = *(void *)&a2.var0;
  }
  else
  {
    unint64_t v7 = *(void *)&a2.var0;
  }
  long long v8 = xmmword_1B7E734D0;
  long long v9 = xmmword_1B7E734D0;
  *(float *)&long long v9 = (float)(int)v7;
  long long v10 = v9;
  *((float *)&v10 + 1) = (float)a2.var3;
  *((float *)&v9 + 1) = (float)SHIDWORD(v7);
  *(float *)&long long v8 = (float)a2.var2;
  long long v11 = v8;
  *((float *)&v11 + 1) = (float)a2.var3;
  v16[0] = v10;
  v16[1] = v9;
  *((float *)&v8 + 1) = (float)SHIDWORD(v7);
  v16[2] = v11;
  v16[3] = v8;
  v15[0] = v10;
  v15[1] = v9;
  v15[2] = v11;
  v15[3] = v8;
  unsigned __int8 v12 = atomic_load(HGLogger::_enabled);
  if (v12) {
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"rect[0..%d]: { %d, %d, %d, %d }\n", a3, a4, a3, v14.var0, v14.var1, v14.var2, v14.var3);
  }
  return HGMetalHandler::PrimitivesDraw((uint64_t)this, 4u, v16, 4u, v15);
}

uint64_t HGMetalHandler::PrimitivesDraw(uint64_t result, unsigned int a2, void *a3, unsigned int a4, void *a5)
{
  if (*(unsigned char *)(result + 1785))
  {
    uint64_t v9 = result;
    MEMORY[0x1BA9C0A20]();
    *(void *)(v9 + 1368) = a4;
    uint64_t v10 = 16 * a4;
    *(void *)(v9 + 1376) = v10;
    *(void *)(v9 + 1392) = v10;
    *(unsigned char *)(v9 + 320) = a4 > 4;
    HGMetalHandler::_updateBuffers((HGMetalHandler *)v9, a3, a5);
    HGMetalHandler::_startEncoding((HGMetalHandler *)v9);
    if (*(unsigned char *)(v9 + 1785))
    {
      uint64_t v14 = **(void **)(v9 + 312);
      if (v14)
      {
        [*(id *)(v9 + 264) setFragmentTexture:*(void *)(v14 + 144) atIndex:0];
        unsigned __int8 v15 = atomic_load(HGLogger::_enabled);
        if (v15)
        {
          float v16 = *(uint64_t **)(v9 + 312);
          uint64_t v17 = *v16;
          uint64_t v18 = objc_msgSend((id)objc_msgSend(*(id *)(*v16 + 144), "label"), "UTF8String");
          HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v19, v20, 0, v17, v18);
        }
      }
      HGMetalHandler::_encodeSourceSampler((HGMetalHandler *)v9, 0, v11, v12, v13);
      uint64_t v24 = *(void *)(*(void *)(v9 + 312) + 8);
      if (v24)
      {
        [*(id *)(v9 + 264) setFragmentTexture:*(void *)(v24 + 144) atIndex:1];
        unsigned __int8 v25 = atomic_load(HGLogger::_enabled);
        if (v25)
        {
          uint64_t v26 = *(void *)(*(void *)(v9 + 312) + 8);
          uint64_t v27 = objc_msgSend((id)objc_msgSend(*(id *)(v26 + 144), "label"), "UTF8String");
          HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v28, v29, 1, v26, v27);
        }
      }
      HGMetalHandler::_encodeSourceSampler((HGMetalHandler *)v9, 1, v21, v22, v23);
      uint64_t v33 = *(void *)(*(void *)(v9 + 312) + 16);
      if (v33)
      {
        [*(id *)(v9 + 264) setFragmentTexture:*(void *)(v33 + 144) atIndex:2];
        unsigned __int8 v34 = atomic_load(HGLogger::_enabled);
        if (v34)
        {
          uint64_t v35 = *(void *)(*(void *)(v9 + 312) + 16);
          uint64_t v36 = objc_msgSend((id)objc_msgSend(*(id *)(v35 + 144), "label"), "UTF8String");
          HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v37, v38, 2, v35, v36);
        }
      }
      HGMetalHandler::_encodeSourceSampler((HGMetalHandler *)v9, 2, v30, v31, v32);
      uint64_t v42 = *(void *)(*(void *)(v9 + 312) + 24);
      if (v42)
      {
        [*(id *)(v9 + 264) setFragmentTexture:*(void *)(v42 + 144) atIndex:3];
        unsigned __int8 v43 = atomic_load(HGLogger::_enabled);
        if (v43)
        {
          uint64_t v44 = *(void *)(*(void *)(v9 + 312) + 24);
          uint64_t v45 = objc_msgSend((id)objc_msgSend(*(id *)(v44 + 144), "label"), "UTF8String");
          HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v46, v47, 3, v44, v45);
        }
      }
      HGMetalHandler::_encodeSourceSampler((HGMetalHandler *)v9, 3, v39, v40, v41);
      uint64_t v51 = *(void *)(*(void *)(v9 + 312) + 32);
      if (v51)
      {
        [*(id *)(v9 + 264) setFragmentTexture:*(void *)(v51 + 144) atIndex:4];
        unsigned __int8 v52 = atomic_load(HGLogger::_enabled);
        if (v52)
        {
          uint64_t v53 = *(void *)(*(void *)(v9 + 312) + 32);
          uint64_t v54 = objc_msgSend((id)objc_msgSend(*(id *)(v53 + 144), "label"), "UTF8String");
          HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v55, v56, 4, v53, v54);
        }
      }
      HGMetalHandler::_encodeSourceSampler((HGMetalHandler *)v9, 4, v48, v49, v50);
      uint64_t v60 = *(void *)(*(void *)(v9 + 312) + 40);
      if (v60)
      {
        [*(id *)(v9 + 264) setFragmentTexture:*(void *)(v60 + 144) atIndex:5];
        unsigned __int8 v61 = atomic_load(HGLogger::_enabled);
        if (v61)
        {
          uint64_t v62 = *(void *)(*(void *)(v9 + 312) + 40);
          uint64_t v63 = objc_msgSend((id)objc_msgSend(*(id *)(v62 + 144), "label"), "UTF8String");
          HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v64, v65, 5, v62, v63);
        }
      }
      HGMetalHandler::_encodeSourceSampler((HGMetalHandler *)v9, 5, v57, v58, v59);
      uint64_t v69 = *(void *)(*(void *)(v9 + 312) + 48);
      if (v69)
      {
        [*(id *)(v9 + 264) setFragmentTexture:*(void *)(v69 + 144) atIndex:6];
        unsigned __int8 v70 = atomic_load(HGLogger::_enabled);
        if (v70)
        {
          uint64_t v71 = *(void *)(*(void *)(v9 + 312) + 48);
          uint64_t v72 = objc_msgSend((id)objc_msgSend(*(id *)(v71 + 144), "label"), "UTF8String");
          HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v73, v74, 6, v71, v72);
        }
      }
      HGMetalHandler::_encodeSourceSampler((HGMetalHandler *)v9, 6, v66, v67, v68);
      uint64_t v78 = *(void *)(*(void *)(v9 + 312) + 56);
      if (v78)
      {
        [*(id *)(v9 + 264) setFragmentTexture:*(void *)(v78 + 144) atIndex:7];
        unsigned __int8 v79 = atomic_load(HGLogger::_enabled);
        if (v79)
        {
          uint64_t v80 = *(void *)(*(void *)(v9 + 312) + 56);
          uint64_t v81 = objc_msgSend((id)objc_msgSend(*(id *)(v80 + 144), "label"), "UTF8String");
          HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v82, v83, 7, v80, v81);
        }
      }
      HGMetalHandler::_encodeSourceSampler((HGMetalHandler *)v9, 7, v75, v76, v77);
    }
    HGMetalHandler::_encodeBuffers((const char *)v9);
    HGMetalHandler::_encodeDraw(v9, a2);
    HGMetalHandler::_finalizeSourceTextures((HGMetalHandler *)v9);
    HGMetalHandler::_transferEncoderResourcesToCommandBuffer((HGMetalHandler *)v9);
  }
  return result;
}

void HGMetalHandler::_updateBuffers(HGMetalHandler *a1, void *a2, void *a3)
{
  if (*((unsigned char *)a1 + 1785))
  {
    HGMetalHandler::_createBuffers(a1);
    if (*((unsigned char *)a1 + 1785))
    {
      HGTraceGuard::HGTraceGuard((HGTraceGuard *)v10, "metal", 2, "HGMetalHandler::updateBuffers()");
      HGMetalHandler::_updateModelViewProjectionMatrix(a1);
      HGMetalHandler::_updateTextureMatrices(a1, v6, v7, v8, v9);
      HGMetalHandler::_updateParametersBuffer(a1);
      HGMetalHandler::_updateVerticesBuffer((uint64_t)a1, a2);
      HGMetalHandler::_updateTexCoordsBuffer((char *)a1, a3);
      HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v10);
    }
  }
}

void sub_1B77894A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HGMetalHandler::_startEncoding(HGMetalHandler *this)
{
  if (!*((void *)this + 32) && *((unsigned char *)this + 1785))
  {
    uint64x2_t v2 = (void *)[*(id *)(*((void *)this + 31) + 32) commandBuffer];
    *((void *)this + 32) = v2;
    id v3 = v2;
    *((_DWORD *)this + 442) = 0;
    HGMetalHandler::_setCommandBufferDebugLabel(this);
  }
  HGMetalHandler::_setupCommandEncoder(this);
  HGMetalHandler::_validateMetalFunctions(this, v4, v5);
  HGMetalHandler::_updatePipelineState(this);
  LODWORD(v6) = *((_DWORD *)this + 432);
  LODWORD(v7) = *((_DWORD *)this + 433);
  LODWORD(v8) = *((_DWORD *)this + 434);
  LODWORD(v9) = *((_DWORD *)this + 435);
  [*((id *)this + 33) setBlendColorRed:v6 green:v7 blue:v8 alpha:v9];

  return HGMetalHandler::_setupScissorRect((uint64_t)this);
}

const char *HGMetalHandler::_encodeBuffers(const char *this)
{
  if (!this[1785]) {
    return this;
  }
  int32x2_t v1 = this;
  uint64_t v2 = *(void *)(*(void *)(*((void *)this + 39) + 64) + 144);
  [*((id *)this + 33) setVertexBuffer:v2 offset:0 atIndex:0];
  uint64_t v3 = *((void *)v1 + 39);
  uint64_t v4 = *(void *)(v3 + 160);
  if (v4)
  {
    this = (const char *)[*((id *)v1 + 33) setVertexBuffer:*(void *)(v4 + 144) offset:0 atIndex:1];
    double v7 = (void *)*((void *)v1 + 39);
    if (!v7[20]) {
      goto LABEL_12;
    }
  }
  else if (v1[320] && (uint64_t v8 = *(void *)(v3 + 72)) != 0)
  {
    this = (const char *)[*((id *)v1 + 33) setVertexBuffer:*(void *)(v8 + 144) offset:0 atIndex:1];
    double v7 = (void *)*((void *)v1 + 39);
    if (!v7[20]) {
      goto LABEL_12;
    }
  }
  else
  {
    this = (const char *)[*((id *)v1 + 33) setVertexBuffer:v2 offset:576 atIndex:1];
    double v7 = (void *)*((void *)v1 + 39);
    if (!v7[20]) {
      goto LABEL_12;
    }
  }
  uint64_t v9 = v7[21];
  if (v9)
  {
    uint64_t v10 = (void *)*((void *)v1 + 33);
    uint64_t v11 = *(void *)(v9 + 144);
    goto LABEL_15;
  }
LABEL_12:
  if (!v1[320] || (uint64_t v12 = v7[10]) == 0)
  {
    if (v1[492])
    {
      *((unsigned char *)v1 + 1785) = 0;
      this = HGLogger::warning((HGLogger *)"vertex shader needs color data.", v5, v6);
    }
    goto LABEL_18;
  }
  uint64_t v10 = (void *)*((void *)v1 + 33);
  uint64_t v11 = *(void *)(v12 + 144);
LABEL_15:
  this = (const char *)[v10 setVertexBuffer:v11 offset:0 atIndex:2];
LABEL_18:
  if (*((_DWORD *)v1 + 122))
  {
    unint64_t v13 = 0;
    uint64_t v14 = 640;
    do
    {
      while (1)
      {
        uint64_t v15 = *((void *)v1 + 39);
        if (!*(void *)(v15 + 160)) {
          break;
        }
        uint64_t v16 = *(void *)(v15 + 8 * v13 + 176);
        if (!v16) {
          break;
        }
        uint64_t v17 = (void *)*((void *)v1 + 33);
        uint64_t v18 = *(void *)(v16 + 144);
LABEL_27:
        this = (const char *)[v17 setVertexBuffer:v18 offset:0 atIndex:v13 + 3];
        ++v13;
        v14 += 64;
        if (v13 >= *((unsigned int *)v1 + 122)) {
          goto LABEL_28;
        }
      }
      if (v1[320])
      {
        uint64_t v19 = *(void *)(v15 + 8 * v13 + 88);
        if (v19)
        {
          uint64_t v17 = (void *)*((void *)v1 + 33);
          uint64_t v18 = *(void *)(v19 + 144);
          goto LABEL_27;
        }
      }
      this = (const char *)[*((id *)v1 + 33) setVertexBuffer:v2 offset:v14 atIndex:v13 + 3];
      ++v13;
      v14 += 64;
    }
    while (v13 < *((unsigned int *)v1 + 122));
  }
LABEL_28:
  if (*((void *)v1 + 158))
  {
    float32x4_t v20 = (void *)*((void *)v1 + 33);
    return (const char *)[v20 setFragmentBuffer:v2 offset:1152 atIndex:0];
  }
  return this;
}

void HGMetalHandler::_encodeDraw(uint64_t a1, unsigned int a2)
{
  if (!*(unsigned char *)(a1 + 1785)) {
    return;
  }
  [*(id *)(a1 + 264) drawPrimitives:a2 vertexStart:0 vertexCount:*(void *)(a1 + 1368) instanceCount:1];
  ++*(_DWORD *)(a1 + 1764);
  ++*(_DWORD *)(a1 + 1772);
  kdebug_trace();
  int v3 = *(char *)(a1 + 1319);
  if (v3 >= 0) {
    size_t v4 = *(unsigned __int8 *)(a1 + 1319);
  }
  else {
    size_t v4 = *(void *)(a1 + 1304);
  }
  unint64_t v5 = v4 + 3;
  if (v4 + 3 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v5 >= 0x17)
  {
    uint64_t v7 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v7 = v5 | 7;
    }
    uint64_t v8 = v7 + 1;
    p_dst = (void **)operator new(v7 + 1);
    std::string::size_type v13 = v4 + 3;
    int64_t v14 = v8 | 0x8000000000000000;
    __dst = p_dst;
    goto LABEL_12;
  }
  std::string::size_type v13 = 0;
  int64_t v14 = 0;
  __dst = 0;
  p_dst = (void **)&__dst;
  HIBYTE(v14) = v4 + 3;
  if (v4)
  {
LABEL_12:
    if (v3 >= 0) {
      uint64_t v9 = (const void *)(a1 + 1296);
    }
    else {
      uint64_t v9 = *(const void **)(a1 + 1296);
    }
    memmove(p_dst, v9, v4);
  }
  *(_DWORD *)((char *)p_dst + v4) = 2128928;
  if (v14 >= 0) {
    uint64_t v10 = (const std::string::value_type *)&__dst;
  }
  else {
    uint64_t v10 = (const std::string::value_type *)__dst;
  }
  if (v14 >= 0) {
    std::string::size_type v11 = HIBYTE(v14);
  }
  else {
    std::string::size_type v11 = v13;
  }
  std::string::append((std::string *)(a1 + 1320), v10, v11);
  if (SHIBYTE(v14) < 0) {
    operator delete(__dst);
  }
}

void sub_1B77898C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void HGMetalHandler::_finalizeSourceTextures(HGMetalHandler *this)
{
  if (*((unsigned char *)this + 1785))
  {
    uint64_t v2 = (HGMetalTexture **)*((void *)this + 39);
    if (*v2)
    {
      HGMetalTexture::WaitForCopy(*v2);
      uint64_t v2 = (HGMetalTexture **)*((void *)this + 39);
    }
    int v3 = v2[1];
    if (v3)
    {
      HGMetalTexture::WaitForCopy(v3);
      uint64_t v2 = (HGMetalTexture **)*((void *)this + 39);
    }
    size_t v4 = v2[2];
    if (v4)
    {
      HGMetalTexture::WaitForCopy(v4);
      uint64_t v2 = (HGMetalTexture **)*((void *)this + 39);
    }
    unint64_t v5 = v2[3];
    if (v5)
    {
      HGMetalTexture::WaitForCopy(v5);
      uint64_t v2 = (HGMetalTexture **)*((void *)this + 39);
    }
    double v6 = v2[4];
    if (v6)
    {
      HGMetalTexture::WaitForCopy(v6);
      uint64_t v2 = (HGMetalTexture **)*((void *)this + 39);
    }
    uint64_t v7 = v2[5];
    if (v7)
    {
      HGMetalTexture::WaitForCopy(v7);
      uint64_t v2 = (HGMetalTexture **)*((void *)this + 39);
    }
    uint64_t v8 = v2[6];
    if (v8)
    {
      HGMetalTexture::WaitForCopy(v8);
      uint64_t v2 = (HGMetalTexture **)*((void *)this + 39);
    }
    uint64_t v9 = v2[7];
    if (v9)
    {
      HGMetalTexture::WaitForCopy(v9);
    }
  }
}

void HGMetalHandler::_transferEncoderResourcesToCommandBuffer(HGMetalHandler *this)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)&v44, "metal", 2, "HGMetalHandler::_transferEncoderResourcesToCommandBuffer()");
  uint64_t v2 = 0;
  uint64_t v3 = *((void *)this + 39);
  size_t v4 = (uint64_t **)((char *)this + 288);
  while (1)
  {
    unint64_t v5 = *(void *)(v3 + 8 * v2);
    if (v5)
    {
      (*(void (**)(void))(*(void *)v5 + 16))(*(void *)(v3 + 8 * v2));
      double v6 = *v4;
      uint64_t v7 = (uint64_t **)((char *)this + 288);
      uint64_t v8 = (uint64_t **)((char *)this + 288);
      if (*v4)
      {
        do
        {
          while (1)
          {
            uint64_t v8 = (uint64_t **)v6;
            unint64_t v9 = v6[4];
            if (v5 >= v9) {
              break;
            }
            double v6 = *v8;
            uint64_t v7 = v8;
            if (!*v8) {
              goto LABEL_13;
            }
          }
          if (v9 >= v5) {
            goto LABEL_3;
          }
          double v6 = v8[1];
        }
        while (v6);
        uint64_t v7 = v8 + 1;
      }
LABEL_13:
      uint64_t v10 = (uint64_t *)operator new(0x28uLL);
      v10[4] = v5;
      uint64_t *v10 = 0;
      v10[1] = 0;
      v10[2] = (uint64_t)v8;
      HGMetalTexture *v7 = v10;
      uint64_t v11 = **((void **)this + 35);
      if (v11)
      {
        *((void *)this + 35) = v11;
        uint64_t v10 = *v7;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 36), v10);
      ++*((void *)this + 37);
LABEL_3:
      (*(void (**)(unint64_t))(*(void *)v5 + 24))(v5);
    }
    if (++v2 == 8)
    {
      *((void *)this + 38) = 0;
      uint64_t v12 = (uint64_t **)*((void *)this + 35);
      if (v12 != v4)
      {
        do
        {
          uint64_t v17 = (int *)v12[4];
          int v18 = v17[7];
          int v19 = v17[8];
          int v20 = v17[5];
          int v21 = v17[6];
          *((void *)this + 38) += (v19 - v21) * (v18 - v20) * HGFormatUtils::bytesPerPixel(v17[4]);
          float32x4_t v22 = v12[1];
          if (v22)
          {
            do
            {
              float32x4_t v23 = (uint64_t **)v22;
              float32x4_t v22 = (uint64_t *)*v22;
            }
            while (v22);
          }
          else
          {
            do
            {
              float32x4_t v23 = (uint64_t **)v12[2];
              BOOL v24 = *v23 == (uint64_t *)v12;
              uint64_t v12 = v23;
            }
            while (!v24);
          }
          uint64_t v12 = v23;
        }
        while (v23 != v4);
      }
      std::string::size_type v13 = (char **)*((void *)this + 34);
      uint64_t v15 = v13[1];
      unint64_t v14 = (unint64_t)v13[2];
      if ((unint64_t)v15 >= v14)
      {
        unsigned __int8 v25 = *v13;
        uint64_t v26 = v15 - *v13;
        uint64_t v27 = v26 >> 3;
        unint64_t v28 = (v26 >> 3) + 1;
        if (v28 >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v29 = v14 - (void)v25;
        if (v29 >> 2 > v28) {
          unint64_t v28 = v29 >> 2;
        }
        if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v30 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v30 = v28;
        }
        if (v30)
        {
          if (v30 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v31 = operator new(8 * v30);
        }
        else
        {
          uint64_t v31 = 0;
        }
        uint64_t v32 = &v31[8 * v27];
        uint64_t v33 = &v31[8 * v30];
        *(void *)uint64_t v32 = *((void *)this + 39);
        uint64_t v16 = v32 + 8;
        if (v15 != v25)
        {
          unint64_t v34 = v15 - v25 - 8;
          if (v34 < 0x58) {
            goto LABEL_52;
          }
          if ((unint64_t)(v15 - v31 - v26) < 0x20) {
            goto LABEL_52;
          }
          uint64_t v35 = (v34 >> 3) + 1;
          uint64_t v36 = 8 * (v35 & 0x3FFFFFFFFFFFFFFCLL);
          float v37 = &v15[-v36];
          v32 -= v36;
          float v38 = &v31[8 * v27 - 16];
          uint64_t v39 = v15 - 16;
          uint64_t v40 = v35 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v41 = *(_OWORD *)v39;
            *(v38 - 1) = *((_OWORD *)v39 - 1);
            *float v38 = v41;
            v38 -= 2;
            v39 -= 32;
            v40 -= 4;
          }
          while (v40);
          uint64_t v15 = v37;
          if (v35 != (v35 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_52:
            do
            {
              uint64_t v42 = *((void *)v15 - 1);
              v15 -= 8;
              *((void *)v32 - 1) = v42;
              v32 -= 8;
            }
            while (v15 != v25);
          }
          uint64_t v15 = *v13;
        }
        char *v13 = v32;
        v13[1] = v16;
        v13[2] = v33;
        if (v15) {
          operator delete(v15);
        }
      }
      else
      {
        *(void *)uint64_t v15 = *((void *)this + 39);
        uint64_t v16 = v15 + 8;
      }
      v13[1] = v16;
      *((void *)this + 39) = 0;
      HGTraceGuard::HGTraceGuard((HGTraceGuard *)v45, "metal", 2, "HGMetalHandler::releaseBuffers()");
      unsigned __int8 v43 = (HGMetalHandler::CommandEncoderCargo *)*((void *)this + 39);
      if (v43)
      {
        HGMetalHandler::CommandEncoderCargo::~CommandEncoderCargo(v43);
        MEMORY[0x1BA9BFBA0]();
      }
      operator new();
    }
  }
}

void sub_1B7789D4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_1B7789D68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

char *HGMetalHandler::SetVertices(HGMetalHandler *this, const void *a2, uint64_t a3, unsigned int a4)
{
  uint64_t v7 = a4;
  *((void *)this + 171) = a4;
  uint64_t v8 = 16 * a4;
  *((void *)this + 172) = v8;
  *((void *)this + 174) = v8;
  *((unsigned char *)this + 320) = 1;
  unint64_t v9 = (HGMetalContext *)*((void *)this + 31);
  uint64_t v10 = *(void **)(*((void *)v9 + 2) + 16);
  uint64_t v11 = (uint64_t *)HGMetalContext::bufferPool(v9);
  *((void *)this + 172) = v7 * a3;
  HGMetalBuffer::create(v10, v11, v7 * a3, &v16);
  uint64_t v12 = *((void *)this + 39);
  uint64_t v13 = *(void *)(v12 + 72);
  uint64_t v14 = v16;
  if (v13 == v16)
  {
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 24))(v13);
    }
  }
  else
  {
    if (v13)
    {
      (*(void (**)(uint64_t))(*(void *)v13 + 24))(v13);
      uint64_t v14 = v16;
    }
    *(void *)(v12 + 72) = v14;
  }
  return HGMetalBuffer::ModifyRangeAndMarkAsDirty(*(id **)(*((void *)this + 39) + 72), 0, *((void *)this + 172), a2);
}

void sub_1B7789ECC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGMetalHandler::SetVertices(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *a2;
  *(void *)(a1 + 1368) = (*(_DWORD *)(*a2 + 28) - *(_DWORD *)(*a2 + 20));
  uint64_t v4 = *(void *)(a1 + 312);
  uint64_t v5 = *(void *)(v4 + 160);
  if (v5 != result)
  {
    if (v5)
    {
      (*(void (**)(void))(*(void *)v5 + 24))(*(void *)(v4 + 160));
      uint64_t result = *a2;
      *(void *)(v4 + 160) = *a2;
      if (!result) {
        return result;
      }
    }
    else
    {
      *(void *)(v4 + 160) = result;
    }
    uint64_t v7 = *(uint64_t (**)(void))(*(void *)result + 16);
    return v7();
  }
  return result;
}

char *HGMetalHandler::SetColors(HGMetalHandler *this, const void *a2, uint64_t a3, unsigned int a4)
{
  uint64_t v7 = a4;
  *((void *)this + 171) = a4;
  uint64_t v8 = 16 * a4;
  *((void *)this + 172) = v8;
  *((void *)this + 174) = v8;
  *((unsigned char *)this + 320) = 1;
  unint64_t v9 = (HGMetalContext *)*((void *)this + 31);
  uint64_t v10 = *(void **)(*((void *)v9 + 2) + 16);
  uint64_t v11 = (uint64_t *)HGMetalContext::bufferPool(v9);
  *((void *)this + 173) = v7 * a3;
  HGMetalBuffer::create(v10, v11, v7 * a3, &v16);
  uint64_t v12 = *((void *)this + 39);
  uint64_t v13 = *(void *)(v12 + 80);
  uint64_t v14 = v16;
  if (v13 == v16)
  {
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 24))(v13);
    }
  }
  else
  {
    if (v13)
    {
      (*(void (**)(uint64_t))(*(void *)v13 + 24))(v13);
      uint64_t v14 = v16;
    }
    *(void *)(v12 + 80) = v14;
  }
  return HGMetalBuffer::ModifyRangeAndMarkAsDirty(*(id **)(*((void *)this + 39) + 80), 0, *((void *)this + 173), a2);
}

void sub_1B778A0D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGMetalHandler::SetColors(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 312);
  uint64_t v3 = *(void *)(v2 + 168);
  uint64_t result = *a2;
  if (v3 != *a2)
  {
    if (v3)
    {
      (*(void (**)(void))(*(void *)v3 + 24))(*(void *)(v2 + 168));
      uint64_t result = *a2;
    }
    *(void *)(v2 + 168) = result;
    if (result)
    {
      double v6 = *(uint64_t (**)(void))(*(void *)result + 16);
      return v6();
    }
  }
  return result;
}

char *HGMetalHandler::SetTextureCoords(HGMetalHandler *this, const void *a2, uint64_t a3, unsigned int a4, unsigned int a5)
{
  uint64_t v9 = a4;
  *((void *)this + 171) = a4;
  uint64_t v10 = 16 * a4;
  *((void *)this + 172) = v10;
  *((void *)this + 174) = v10;
  *((unsigned char *)this + 320) = 1;
  uint64_t v11 = (HGMetalContext *)*((void *)this + 31);
  uint64_t v12 = *(void **)(*((void *)v11 + 2) + 16);
  uint64_t v13 = (uint64_t *)HGMetalContext::bufferPool(v11);
  *((void *)this + 174) = v9 * a3;
  HGMetalBuffer::create(v12, v13, v9 * a3, &v20);
  uint64_t v14 = *((void *)this + 39) + 8 * a5;
  uint64_t v17 = *(void *)(v14 + 88);
  uint64_t v16 = (void *)(v14 + 88);
  uint64_t v15 = v17;
  uint64_t v18 = v20;
  if (v17 == v20)
  {
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 24))(v15);
    }
  }
  else
  {
    if (v15)
    {
      (*(void (**)(uint64_t))(*(void *)v15 + 24))(v15);
      uint64_t v18 = v20;
    }
    void *v16 = v18;
  }
  return HGMetalBuffer::ModifyRangeAndMarkAsDirty(*(id **)(*((void *)this + 39) + 8 * a5 + 88), 0, *((void *)this + 174), a2);
}

void sub_1B778A2DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGMetalHandler::SetTextureCoords(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  uint64_t v3 = *(void *)(a1 + 312) + 8 * a3;
  uint64_t v6 = *(void *)(v3 + 176);
  uint64_t v5 = (uint64_t *)(v3 + 176);
  uint64_t v4 = v6;
  uint64_t result = *a2;
  if (v6 != *a2)
  {
    if (v4)
    {
      (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
      uint64_t result = *a2;
    }
    *uint64_t v5 = result;
    if (result)
    {
      uint64_t v9 = *(uint64_t (**)(void))(*(void *)result + 16);
      return v9();
    }
  }
  return result;
}

uint64_t HGMetalHandler::SetTextureCoords(uint64_t this, int a2)
{
  *(_DWORD *)(this + 488) = a2;
  return this;
}

char *HGMetalHandler::SetIndices(HGMetalHandler *this, const void *a2, unint64_t a3, unsigned int a4)
{
  *((_DWORD *)this + 350) = a3 > 2;
  size_t v6 = a4 * a3;
  uint64_t v7 = (HGMetalContext *)*((void *)this + 31);
  uint64_t v8 = *(void **)(*((void *)v7 + 2) + 16);
  uint64_t v9 = (uint64_t *)HGMetalContext::bufferPool(v7);
  HGMetalBuffer::create(v8, v9, v6, &v14);
  uint64_t v10 = *((void *)this + 39);
  uint64_t v11 = *(void *)(v10 + 152);
  uint64_t v12 = v14;
  if (v11 == v14)
  {
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
    }
  }
  else
  {
    if (v11)
    {
      (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
      uint64_t v12 = v14;
    }
    *(void *)(v10 + 152) = v12;
  }
  return HGMetalBuffer::ModifyRangeAndMarkAsDirty(*(id **)(*((void *)this + 39) + 152), 0, v6, a2);
}

void sub_1B778A4C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGMetalHandler::SetIndices(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *a2;
  *(_DWORD *)(a1 + 1400) = *(_DWORD *)(*a2 + 16) != 3;
  uint64_t v4 = *(void *)(a1 + 312);
  uint64_t v5 = *(void *)(v4 + 240);
  if (v5 != result)
  {
    if (v5)
    {
      (*(void (**)(void))(*(void *)v5 + 24))(*(void *)(v4 + 240));
      uint64_t result = *a2;
      *(void *)(v4 + 240) = *a2;
      if (!result) {
        return result;
      }
    }
    else
    {
      *(void *)(v4 + 240) = result;
    }
    uint64_t v7 = *(uint64_t (**)(void))(*(void *)result + 16);
    return v7();
  }
  return result;
}

void HGMetalHandler::PrimitivesStart(HGMetalHandler *this)
{
  *((unsigned char *)this + 1786) = 1;
  uint64_t v2 = (void *)MEMORY[0x1BA9C0A20]();
  HGMetalHandler::_createBuffers(this);
  HGMetalHandler::_updateModelViewProjectionMatrix(this);
  HGMetalHandler::_updateTextureMatrices(this, v3, v4, v5, v6);
  HGMetalHandler::_updateParametersBuffer(this);
  HGMetalHandler::_startEncoding(this);
  if (*((unsigned char *)this + 1785))
  {
    uint64_t v10 = **((void **)this + 39);
    if (v10)
    {
      [*((id *)this + 33) setFragmentTexture:*(void *)(v10 + 144) atIndex:0];
      unsigned __int8 v11 = atomic_load(HGLogger::_enabled);
      if (v11)
      {
        uint64_t v12 = (uint64_t *)*((void *)this + 39);
        uint64_t v13 = *v12;
        uint64_t v14 = objc_msgSend((id)objc_msgSend(*(id *)(*v12 + 144), "label"), "UTF8String");
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v15, v16, 0, v13, v14);
      }
    }
    HGMetalHandler::_encodeSourceSampler(this, 0, v7, v8, v9);
    uint64_t v20 = *(void *)(*((void *)this + 39) + 8);
    if (v20)
    {
      [*((id *)this + 33) setFragmentTexture:*(void *)(v20 + 144) atIndex:1];
      unsigned __int8 v21 = atomic_load(HGLogger::_enabled);
      if (v21)
      {
        uint64_t v22 = *(void *)(*((void *)this + 39) + 8);
        uint64_t v23 = objc_msgSend((id)objc_msgSend(*(id *)(v22 + 144), "label"), "UTF8String");
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v24, v25, 1, v22, v23);
      }
    }
    HGMetalHandler::_encodeSourceSampler(this, 1, v17, v18, v19);
    uint64_t v29 = *(void *)(*((void *)this + 39) + 16);
    if (v29)
    {
      [*((id *)this + 33) setFragmentTexture:*(void *)(v29 + 144) atIndex:2];
      unsigned __int8 v30 = atomic_load(HGLogger::_enabled);
      if (v30)
      {
        uint64_t v31 = *(void *)(*((void *)this + 39) + 16);
        uint64_t v32 = objc_msgSend((id)objc_msgSend(*(id *)(v31 + 144), "label"), "UTF8String");
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v33, v34, 2, v31, v32);
      }
    }
    HGMetalHandler::_encodeSourceSampler(this, 2, v26, v27, v28);
    uint64_t v38 = *(void *)(*((void *)this + 39) + 24);
    if (v38)
    {
      [*((id *)this + 33) setFragmentTexture:*(void *)(v38 + 144) atIndex:3];
      unsigned __int8 v39 = atomic_load(HGLogger::_enabled);
      if (v39)
      {
        uint64_t v40 = *(void *)(*((void *)this + 39) + 24);
        uint64_t v41 = objc_msgSend((id)objc_msgSend(*(id *)(v40 + 144), "label"), "UTF8String");
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v42, v43, 3, v40, v41);
      }
    }
    HGMetalHandler::_encodeSourceSampler(this, 3, v35, v36, v37);
    uint64_t v47 = *(void *)(*((void *)this + 39) + 32);
    if (v47)
    {
      [*((id *)this + 33) setFragmentTexture:*(void *)(v47 + 144) atIndex:4];
      unsigned __int8 v48 = atomic_load(HGLogger::_enabled);
      if (v48)
      {
        uint64_t v49 = *(void *)(*((void *)this + 39) + 32);
        uint64_t v50 = objc_msgSend((id)objc_msgSend(*(id *)(v49 + 144), "label"), "UTF8String");
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v51, v52, 4, v49, v50);
      }
    }
    HGMetalHandler::_encodeSourceSampler(this, 4, v44, v45, v46);
    uint64_t v56 = *(void *)(*((void *)this + 39) + 40);
    if (v56)
    {
      [*((id *)this + 33) setFragmentTexture:*(void *)(v56 + 144) atIndex:5];
      unsigned __int8 v57 = atomic_load(HGLogger::_enabled);
      if (v57)
      {
        uint64_t v58 = *(void *)(*((void *)this + 39) + 40);
        uint64_t v59 = objc_msgSend((id)objc_msgSend(*(id *)(v58 + 144), "label"), "UTF8String");
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v60, v61, 5, v58, v59);
      }
    }
    HGMetalHandler::_encodeSourceSampler(this, 5, v53, v54, v55);
    uint64_t v65 = *(void *)(*((void *)this + 39) + 48);
    if (v65)
    {
      [*((id *)this + 33) setFragmentTexture:*(void *)(v65 + 144) atIndex:6];
      unsigned __int8 v66 = atomic_load(HGLogger::_enabled);
      if (v66)
      {
        uint64_t v67 = *(void *)(*((void *)this + 39) + 48);
        uint64_t v68 = objc_msgSend((id)objc_msgSend(*(id *)(v67 + 144), "label"), "UTF8String");
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v69, v70, 6, v67, v68);
      }
    }
    HGMetalHandler::_encodeSourceSampler(this, 6, v62, v63, v64);
    uint64_t v74 = *(void *)(*((void *)this + 39) + 56);
    if (v74)
    {
      [*((id *)this + 33) setFragmentTexture:*(void *)(v74 + 144) atIndex:7];
      unsigned __int8 v75 = atomic_load(HGLogger::_enabled);
      if (v75)
      {
        uint64_t v76 = *(void *)(*((void *)this + 39) + 56);
        uint64_t v77 = objc_msgSend((id)objc_msgSend(*(id *)(v76 + 144), "label"), "UTF8String");
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%d: source texture (%p, %s)\n", v78, v79, 7, v76, v77);
      }
    }
    HGMetalHandler::_encodeSourceSampler(this, 7, v71, v72, v73);
  }
  HGMetalHandler::_encodeBuffers((const char *)this);
}

void HGMetalHandler::PrimitivesEnd(HGMetalHandler *this)
{
}

void HGMetalHandler::_createBuffers(HGMetalHandler *this)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v13, "metal", 2, "HGMetalHandler::createBuffers()");
  unint64_t v2 = *((void *)this + 158) + 1152;
  int v3 = *(_DWORD **)(*((void *)this + 39) + 64);
  if (!v3 || v2 > ((v3[8] - v3[6]) * (v3[7] - v3[5])))
  {
    uint64_t v4 = (HGMetalContext *)*((void *)this + 31);
    uint64_t v5 = *(void **)(*((void *)v4 + 2) + 16);
    size_t v6 = (uint64_t *)HGMetalContext::bufferPool(v4);
    HGMetalBuffer::create(v5, v6, v2, &v12);
    uint64_t v9 = *((void *)this + 39);
    uint64_t v10 = *(void *)(v9 + 64);
    uint64_t v11 = v12;
    if (v10 == v12)
    {
      if (v10) {
        (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
      }
    }
    else
    {
      if (v10)
      {
        (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
        uint64_t v11 = v12;
      }
      *(void *)(v9 + 64) = v11;
    }
    if (!*(void *)(*((void *)this + 39) + 64))
    {
      *((unsigned char *)this + 1785) = 0;
      HGLogger::warning((HGLogger *)"HGMetalHandler::_createBuffers -- null buffer!!", v7, v8);
    }
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v13);
}

void sub_1B778AB38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void HGMetalHandler::_updateModelViewProjectionMatrix(HGMetalHandler *this)
{
  int32x2_t v1 = (float *)((char *)this + 16);
  unint64_t v2 = (float *)((char *)this + 80);
  float32x4_t v3 = *((float32x4_t *)this + 5);
  float32x4_t v4 = *((float32x4_t *)this + 6);
  float32x4_t v5 = *((float32x4_t *)this + 7);
  float32x4_t v6 = *((float32x4_t *)this + 8);
  float32x4_t v7 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v3, COERCE_FLOAT(*((_OWORD *)this + 1))), v4, *(float32x2_t *)((char *)this + 16), 1), v5, *((float32x4_t *)this + 1), 2), v6, *((float32x4_t *)this + 1), 3);
  float32x4_t v8 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v3, COERCE_FLOAT(*((_OWORD *)this + 2))), v4, *(float32x2_t *)((char *)this + 32), 1), v5, *((float32x4_t *)this + 2), 2), v6, *((float32x4_t *)this + 2), 3);
  float32x4_t v9 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v3, COERCE_FLOAT(*((_OWORD *)this + 3))), v4, *(float32x2_t *)((char *)this + 48), 1), v5, *((float32x4_t *)this + 3), 2), v6, *((float32x4_t *)this + 3), 3);
  float32x4_t v10 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v3, COERCE_FLOAT(*((_OWORD *)this + 4))), v4, *(float32x2_t *)((char *)this + 64), 1), v5, *((float32x4_t *)this + 4), 2), v6, *((float32x4_t *)this + 4), 3);
  v38[0] = v7;
  v38[1] = v8;
  v38[2] = v9;
  v38[3] = v10;
  HGMetalBuffer::ModifyRangeAndMarkAsDirty(*(id **)(*((void *)this + 39) + 64), 0, 0x40uLL, v38);
  unsigned __int8 v12 = atomic_load(HGLogger::_enabled);
  if ((v12 & 1) != 0 && (int)HGLogger::getLevel((HGLogger *)"gpu", v11) >= 1)
  {
    unsigned __int8 v17 = atomic_load(HGLogger::_enabled);
    if (v17)
    {
      HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"projection matrix :\n", v15, v16);
      log_matrix(v2, v28, v29, v30, v31);
      unsigned __int8 v32 = atomic_load(HGLogger::_enabled);
      if ((v32 & 1) == 0)
      {
LABEL_5:
        log_matrix(v1, v18, v19, v20, v21);
        unsigned __int8 v27 = atomic_load(HGLogger::_enabled);
        if ((v27 & 1) == 0)
        {
LABEL_7:
          log_matrix((float *)v38, v23, v24, v25, v26);
          return;
        }
LABEL_6:
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"model view projection matrix :\n", v25, v26);
        goto LABEL_7;
      }
    }
    else
    {
      log_matrix(v2, v13, v14, v15, v16);
      unsigned __int8 v22 = atomic_load(HGLogger::_enabled);
      if ((v22 & 1) == 0) {
        goto LABEL_5;
      }
    }
    HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"model view matrix :\n", v20, v21);
    log_matrix(v1, v33, v34, v35, v36);
    unsigned __int8 v37 = atomic_load(HGLogger::_enabled);
    if ((v37 & 1) == 0) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
}

void HGMetalHandler::_updateTextureMatrices(HGMetalHandler *this, int a2, const float *a3, const char *a4, char *a5)
{
  unint64_t v5 = *((unsigned int *)this + 122);
  if (v5)
  {
    for (unint64_t i = 0; i < v5; ++i)
    {
      while (((*((_DWORD *)this + 121) >> i) & 1) != 0)
      {
        unint64_t v8 = i + 1;
        HGMetalBuffer::ModifyRangeAndMarkAsDirty(*(id **)(*((void *)this + 39) + 64), (i + 1) << 6, 0x40uLL, (char *)this + 64 * i + 752);
        unint64_t v5 = *((unsigned int *)this + 122);
        unint64_t i = v8;
        if (v8 >= v5) {
          goto LABEL_6;
        }
      }
    }
LABEL_6:
    if (v5)
    {
      unint64_t v9 = 0;
      float32x4_t v10 = (float *)((char *)this + 752);
      do
      {
        if ((*((_DWORD *)this + 121) >> v9))
        {
          unsigned __int8 v11 = atomic_load(HGLogger::_enabled);
          if (v11) {
            HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"texture matrix %d :\n", a4, a5, v9);
          }
          log_matrix(v10, a2, a3, a4, a5);
          unint64_t v5 = *((unsigned int *)this + 122);
        }
        ++v9;
        v10 += 16;
      }
      while (v9 < v5);
    }
  }
}

void HGMetalHandler::_updateParametersBuffer(HGMetalHandler *this)
{
  size_t v1 = *((void *)this + 158);
  if (!v1) {
    return;
  }
  HGMetalBuffer::ModifyRangeAndMarkAsDirty(*(id **)(*((void *)this + 39) + 64), 1152, v1, *((const void **)this + 159));
  unsigned __int8 v4 = atomic_load(HGLogger::_enabled);
  if ((v4 & 1) == 0 || (int)HGLogger::getLevel((HGLogger *)"gpu", v3) < 1) {
    return;
  }
  float32x4_t v7 = (HGParamBufferDesc *)*((void *)this + 161);
  if (v7)
  {
    HGParamBufferDesc::printParamValuesFromBuffer(v7, *((unsigned __int8 **)this + 159), *((void *)this + 158), &v36);
    unint64_t v8 = std::string::insert(&v36, 0, "parameter buffer 0 :\n");
    long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v45.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v36.__r_.__value_.__l.__data_);
    }
    std::istringstream::basic_istringstream[abi:ne180100]((uint64_t)&v36, (uint64_t)&v45, 8);
    memset(&v44, 0, sizeof(v44));
    float32x4_t v10 = (std::locale::id *)MEMORY[0x1E4FBA258];
    while (1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)&v36 + *(void *)(v36.__r_.__value_.__r.__words[0] - 24)));
      unsigned __int8 v11 = std::locale::use_facet(&v46, v10);
      unsigned __int8 v12 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
      std::locale::~locale(&v46);
      int v13 = std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&v36, (uint64_t)&v44, v12);
      if ((*((unsigned char *)v13 + *(void *)(*v13 - 24) + 32) & 5) != 0) {
        break;
      }
      std::string::append(&v44, "\n");
      unsigned __int8 v16 = atomic_load(HGLogger::_enabled);
      if (v16)
      {
        if ((v44.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          unsigned __int8 v17 = &v44;
        }
        else {
          unsigned __int8 v17 = (std::string *)v44.__r_.__value_.__r.__words[0];
        }
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%s", v14, v15, v17);
      }
    }
    if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v44.__r_.__value_.__l.__data_);
    }
    v36.__r_.__value_.__r.__words[0] = *MEMORY[0x1E4FBA410];
    *(std::string::size_type *)((char *)v36.__r_.__value_.__r.__words
                              + *(void *)(v36.__r_.__value_.__r.__words[0] - 24)) = *(void *)(MEMORY[0x1E4FBA410]
                                                                                                + 24);
    v36.__r_.__value_.__r.__words[2] = MEMORY[0x1E4FBA470] + 16;
    if (v40 < 0) {
      operator delete(__p);
    }
    std::streambuf::~streambuf();
    std::istream::~istream();
    MEMORY[0x1BA9BFAB0](&v42);
    if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v45.__r_.__value_.__l.__data_);
    }
    return;
  }
  unsigned __int8 v18 = atomic_load(HGLogger::_enabled);
  if (v18) {
    HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%s", v5, v6, "parameter buffer 0 :\n");
  }
  unint64_t v19 = *((void *)this + 158);
  if ((int)(v19 >> 4) >= 1)
  {
    int v20 = 0;
    uint64_t v21 = 0;
    std::string::size_type v35 = *MEMORY[0x1E4FBA408];
    std::string::size_type v33 = *(void *)(MEMORY[0x1E4FBA408] + 72);
    std::string::size_type v34 = *(void *)(MEMORY[0x1E4FBA408] + 64);
    uint64_t v22 = v19 & 0xFFFFFFFF0;
    do
    {
      std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v36);
      memset(&v45, 0, sizeof(v45));
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v36.__r_.__value_.__r.__words[2], (uint64_t)"parameter(", 10);
      int v23 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)"): {", 4);
      BOOL v24 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)", ", 2);
      unsigned __int8 v25 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)", ", 2);
      uint64_t v26 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)", ", 2);
      unsigned __int8 v27 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)"} \n", 3);
      std::stringbuf::str();
      if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v45.__r_.__value_.__l.__data_);
        std::string v45 = v44;
        unsigned __int8 v31 = atomic_load(HGLogger::_enabled);
        if (v31)
        {
LABEL_29:
          unsigned __int8 v32 = &v45;
          if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            unsigned __int8 v32 = (std::string *)v45.__r_.__value_.__r.__words[0];
          }
          HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"%s", v28, v29, v32);
        }
      }
      else
      {
        std::string v45 = v44;
        unsigned __int8 v30 = atomic_load(HGLogger::_enabled);
        if (v30) {
          goto LABEL_29;
        }
      }
      if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v45.__r_.__value_.__l.__data_);
      }
      v36.__r_.__value_.__r.__words[0] = v35;
      *(std::string::size_type *)((char *)v36.__r_.__value_.__r.__words + *(void *)(v35 - 24)) = v34;
      v36.__r_.__value_.__r.__words[2] = v33;
      uint64_t v37 = MEMORY[0x1E4FBA470] + 16;
      if (v41 < 0) {
        operator delete(v39);
      }
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      MEMORY[0x1BA9BFAB0](&v43);
      v21 += 16;
      ++v20;
    }
    while (v22 != v21);
  }
}

void sub_1B778B3C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (*(char *)(v20 - 137) < 0)
  {
    operator delete(*(void **)(v20 - 160));
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGMetalHandler::_encodeDrawIndexed(uint64_t result, unsigned int a2, unsigned int a3, unsigned int a4)
{
  if (!*(unsigned char *)(result + 1785)) {
    return result;
  }
  uint64_t v7 = result;
  unint64_t v8 = *(void **)(result + 312);
  if (v8[20] && (uint64_t v9 = v8[30]) != 0 || (uint64_t v9 = v8[19]) != 0) {
    (*(void (**)(uint64_t))(*(void *)v9 + 16))(v9);
  }
  if (!a4) {
    a4 = *(_DWORD *)(v9 + 28) - *(_DWORD *)(v9 + 20);
  }
  [*(id *)(v7 + 264) drawIndexedPrimitives:a2 indexCount:a4 indexType:*(unsigned int *)(v7 + 1400) indexBuffer:*(void *)(v9 + 144) indexBufferOffset:a3];
  ++*(_DWORD *)(v7 + 1764);
  ++*(_DWORD *)(v7 + 1772);
  kdebug_trace();
  int v10 = *(char *)(v7 + 1319);
  if (v10 >= 0) {
    size_t v11 = *(unsigned __int8 *)(v7 + 1319);
  }
  else {
    size_t v11 = *(void *)(v7 + 1304);
  }
  unint64_t v12 = v11 + 3;
  if (v11 + 3 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v12 >= 0x17)
  {
    uint64_t v14 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v12 | 7) != 0x17) {
      uint64_t v14 = v12 | 7;
    }
    uint64_t v15 = v14 + 1;
    p_dst = (void **)operator new(v14 + 1);
    std::string::size_type v20 = v11 + 3;
    int64_t v21 = v15 | 0x8000000000000000;
    __dst = p_dst;
    goto LABEL_18;
  }
  std::string::size_type v20 = 0;
  int64_t v21 = 0;
  __dst = 0;
  p_dst = (void **)&__dst;
  HIBYTE(v21) = v11 + 3;
  if (v11)
  {
LABEL_18:
    if (v10 >= 0) {
      unsigned __int8 v16 = (const void *)(v7 + 1296);
    }
    else {
      unsigned __int8 v16 = *(const void **)(v7 + 1296);
    }
    memmove(p_dst, v16, v11);
  }
  *(_DWORD *)((char *)p_dst + v11) = 2128928;
  if (v21 >= 0) {
    unsigned __int8 v17 = (const std::string::value_type *)&__dst;
  }
  else {
    unsigned __int8 v17 = (const std::string::value_type *)__dst;
  }
  if (v21 >= 0) {
    std::string::size_type v18 = HIBYTE(v21);
  }
  else {
    std::string::size_type v18 = v20;
  }
  std::string::append((std::string *)(v7 + 1320), v17, v18);
  if (SHIBYTE(v21) < 0) {
    operator delete(__dst);
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v9 + 24))(v9);
}

void sub_1B778B65C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v15 + 24))(v15);
  _Unwind_Resume(a1);
}

char *HGMetalHandler::AddMTLFunction(void *a1, void *a2)
{
  uint64_t v3 = [a2 functionType];
  if (v3 == 5)
  {
    float32x4_t v6 = (char *)a1[180];
    unint64_t v7 = a1[181];
    if ((unint64_t)v6 >= v7)
    {
      unint64_t v12 = (char *)a1[179];
      uint64_t v13 = (v6 - v12) >> 3;
      unint64_t v14 = v13 + 1;
      if ((unint64_t)(v13 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v15 = v7 - (void)v12;
      if (v15 >> 2 > v14) {
        unint64_t v14 = v15 >> 2;
      }
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v16 = v14;
      }
      if (v16)
      {
        if (v16 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        unsigned __int8 v17 = (char *)operator new(8 * v16);
      }
      else
      {
        unsigned __int8 v17 = 0;
      }
      std::string::size_type v18 = &v17[8 * v13];
      unint64_t v19 = &v17[8 * v16];
      *(void *)std::string::size_type v18 = a2;
      std::string::size_type v20 = v18 + 8;
      if (v6 != v12)
      {
        unint64_t v21 = v6 - v12 - 8;
        if (v21 < 0x58) {
          goto LABEL_46;
        }
        if ((unint64_t)(v12 - v17) < 0x20) {
          goto LABEL_46;
        }
        uint64_t v22 = (v21 >> 3) + 1;
        uint64_t v23 = 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
        BOOL v24 = &v6[-v23];
        v18 -= v23;
        unsigned __int8 v25 = &v17[8 * v13 - 16];
        uint64_t v26 = v6 - 16;
        uint64_t v27 = v22 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *((_OWORD *)v25 - 1) = *((_OWORD *)v26 - 1);
          *(_OWORD *)unsigned __int8 v25 = v28;
          v25 -= 32;
          v26 -= 32;
          v27 -= 4;
        }
        while (v27);
        float32x4_t v6 = v24;
        if (v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_46:
          do
          {
            uint64_t v29 = *((void *)v6 - 1);
            v6 -= 8;
            *((void *)v18 - 1) = v29;
            v18 -= 8;
          }
          while (v6 != v12);
        }
        float32x4_t v6 = (char *)a1[179];
      }
      a1[179] = v18;
      a1[180] = v20;
      a1[181] = v19;
      if (v6) {
        operator delete(v6);
      }
      uint64_t result = (char *)a2;
      a1[180] = v20;
    }
    else
    {
      uint64_t result = (char *)a2;
      *(void *)float32x4_t v6 = a2;
      a1[180] = v6 + 8;
    }
    goto LABEL_39;
  }
  if (v3 == 2)
  {
    unint64_t v8 = (void *)a1[178];
    uint64_t result = (char *)a2;
    if (v8 == a2) {
      return result;
    }
    if (v8)
    {

      uint64_t result = (char *)a2;
    }
    a1[178] = result;
    if (!result) {
      return result;
    }
LABEL_39:
    return result;
  }
  if (v3 != 1)
  {
    uint64_t v9 = objc_msgSend((id)objc_msgSend(a2, "name"), "UTF8String");
    return (char *)HGLogger::warning((HGLogger *)"Metal function %s is not supported", v10, v11, v9);
  }
  unsigned __int8 v4 = (void *)a1[177];
  uint64_t result = (char *)a2;
  if (v4 != a2)
  {
    if (v4)
    {

      uint64_t result = (char *)a2;
    }
    a1[177] = result;
    if (result) {
      goto LABEL_39;
    }
  }
  return result;
}

uint64_t HGMetalHandler::SetAttributeFlags(uint64_t this, __int16 a2)
{
  *(unsigned char *)(this + 492) = (a2 & 0x200) != 0;
  return this;
}

std::string *HGMetalHandler::SetDebugLabel(std::string *a1, const std::string *a2)
{
  return std::string::operator=(a1 + 54, a2);
}

__n128 HGMetalHandler::SetBlendingInfo(HGMetalHandler *this, const HGBlendingInfo *a2)
{
  unsigned __int8 v4 = (_OWORD *)((char *)this + 1464);
  if (!HGBlendingInfo::operator==((uint64_t)a2, (uint64_t)this + 1464))
  {
    __n128 result = *(__n128 *)a2;
    long long v6 = *((_OWORD *)a2 + 1);
    _OWORD *v4 = *(_OWORD *)a2;
    v4[1] = v6;
    *((unsigned char *)this + 1784) = 1;
  }
  return result;
}

uint64_t HGMetalHandler::EnableBlending(uint64_t this)
{
  if ((*(unsigned char *)(this + 1456) & 1) == 0)
  {
    *(unsigned char *)(this + 1456) |= 1u;
    *(unsigned char *)(this + 1784) = 1;
  }
  return this;
}

uint64_t HGMetalHandler::DisableBlending(uint64_t this)
{
  if (*(unsigned char *)(this + 1456))
  {
    *(unsigned char *)(this + 1456) &= ~1u;
    *(unsigned char *)(this + 1784) = 1;
  }
  return this;
}

void *HGMetalHandler::EnableDepthBuffer(void *this)
{
  if (!this[57])
  {
    size_t v1 = this;
    HGMetalHandler::FinalizeCommandEncoder((HGMetalHandler *)this, *(_DWORD *)(this[31] + 64), *(void *)(this[31] + 72), *(void *)(this[31] + 88));
    MetalContext = (HGMetalContext *)HGGPURenderer::GetMetalContext((HGGPURenderer *)v1[18]);
    uint64_t v3 = v1[49];
    uint64_t v4 = *(void *)(v3 + 20);
    uint64_t v5 = *(void *)(v3 + 28);
    long long v6 = *(void **)(*((void *)MetalContext + 2) + 16);
    unint64_t v7 = (uint64_t *)HGMetalContext::texturePool(MetalContext);
    HGMetalTexture::createDepth(v6, v7, v4, v5, *((_DWORD *)v1 + 118), &v9);
    this = (void *)v1[57];
    unint64_t v8 = v9;
    if (this == v9)
    {
      if (this) {
        this = (void *)(*(uint64_t (**)(void *))(*this + 24))(this);
      }
    }
    else
    {
      if (this)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 24))(this);
        unint64_t v8 = v9;
      }
      v1[57] = v8;
    }
    *((unsigned char *)v1 + 1784) = 1;
  }
  return this;
}

void sub_1B778BAA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGMetalHandler::DisableDepthBuffer(HGMetalHandler *this)
{
  uint64_t result = *((void *)this + 57);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
    *((void *)this + 57) = 0;
    *((unsigned char *)this + 1784) = 1;
  }
  return result;
}

uint64_t HGMetalHandler::SetScissorTest(uint64_t this, char a2)
{
  *(unsigned char *)(this + 1744) = a2;
  return this;
}

__n128 HGMetalHandler::SetScissorRect(HGMetalHandler *this, __n128 *a2)
{
  __n128 result = *a2;
  *(__n128 *)((char *)this + 1748) = *a2;
  return result;
}

__n128 HGMetalHandler::SetBlendingColor(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[108] = *a2;
  return result;
}

void HGMetalHandler::FinalizeCommandEncoder(HGMetalHandler *this, unsigned int a2, unint64_t a3, unint64_t a4)
{
  if (*((void *)this + 33))
  {
    HGMetalHandler::_setCommandEncoderDebugLabel(this);
    [*((id *)this + 33) endEncoding];
    ++*((_DWORD *)this + 442);
    ++*((_DWORD *)this + 444);
    kdebug_trace();

    *((void *)this + 33) = 0;
  }
  if (*((void *)this + 32))
  {
    if (*((_DWORD *)this + 442) >= a2
      || *((void *)this + 38) >= a3
      || (unint64_t v8 = atomic_load((unint64_t *)this + 225), *((void *)this + 38) + v8 >= a4))
    {
      HGMetalHandler::_commitCommandBuffer(this);
    }
  }
}

void HGMetalHandler::_commitCommandBuffer(HGMetalHandler *this)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v3, "metal", 2, "HGMetalHandler::_commitCommandBuffer()");
  v2[0] = 0;
  v2[1] = v2;
  v2[2] = 0x2020000000;
  v2[3] = *((void *)this + 34);
  operator new();
}

void sub_1B778BE9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a9);
  _Block_object_dispose(&a19, 8);
  _Block_object_dispose((const void *)(v19 - 96), 8);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v19 - 64));
  _Unwind_Resume(a1);
}

void HGMetalHandler::FinalizeCommandBuffer(HGMetalHandler *this)
{
}

uint64_t HGMetalHandler::FrameEnd(uint64_t this)
{
  *(void *)(this + 1772) = 0;
  *(_DWORD *)(this + 1780) = 0;
  if (*(void *)(this + 144))
  {
    kdebug_trace();
    kdebug_trace();
    return kdebug_trace();
  }
  return this;
}

_DWORD *HGMetalHandler::GetFrameCounters(_DWORD *this, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  *a2 = this[443];
  *a3 = this[444];
  *a4 = this[445];
  return this;
}

uint64_t HGMetalHandler::WaitForCommandBuffersCount(HGMetalHandler *this, unint64_t a2)
{
  return kdebug_trace();
}

void sub_1B778C058(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

void HGMetalHandler::_waitForCommandBuffers(HGMetalHandler *this, unint64_t a2, unint64_t a3, unint64_t a4)
{
  v13.__m_ = (std::unique_lock<std::mutex>::mutex_type *)((char *)this + 1808);
  v13.__owns_ = 1;
  std::mutex::lock((std::mutex *)((char *)this + 1808));
  while (1)
  {
    unint64_t v9 = atomic_load((unint64_t *)this + 224);
    if (v9 <= a3)
    {
      unint64_t v10 = atomic_load((unint64_t *)this + 224);
      if (v10 <= a2) {
        break;
      }
      unint64_t v11 = atomic_load((unint64_t *)this + 225);
      if (v11 <= a4) {
        break;
      }
    }
    std::chrono::steady_clock::now();
    v12.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
    v8.__d_.__rep_ = 15000000;
    if (!v12.__d_.__rep_) {
      goto LABEL_3;
    }
    if (v12.__d_.__rep_ < 1)
    {
      if ((unint64_t)v12.__d_.__rep_ < 0xFFDF3B645A1CAC09)
      {
        v8.__d_.__rep_ = 0x8000000000E4E1C0;
        goto LABEL_3;
      }
    }
    else if ((unint64_t)v12.__d_.__rep_ > 0x20C49BA5E353F7)
    {
      goto LABEL_2;
    }
    if (v12.__d_.__rep_ >= 0x20C49BA5E31960)
    {
LABEL_2:
      v8.__d_.__rep_ = 0x7FFFFFFFFFFFFFFFLL;
      goto LABEL_3;
    }
    v8.__d_.__rep_ = 1000 * v12.__d_.__rep_ + 15000000;
LABEL_3:
    std::condition_variable::__do_timed_wait((std::condition_variable *)this + 39, &v13, v8);
    std::chrono::steady_clock::now();
  }
  if (v13.__owns_) {
    std::mutex::unlock(v13.__m_);
  }
}

char *HGMetalHandler::_updateVerticesBuffer(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 312);
  if (*(unsigned char *)(a1 + 320))
  {
    uint64_t v5 = *(id **)(v4 + 72);
    if (!v5)
    {
      long long v6 = *(HGMetalContext **)(a1 + 248);
      unint64_t v7 = *(void **)(*((void *)v6 + 2) + 16);
      std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> v8 = (uint64_t *)HGMetalContext::bufferPool(v6);
      HGMetalBuffer::create(v7, v8, *(void *)(a1 + 1376), &v15);
      uint64_t v9 = *(void *)(a1 + 312);
      uint64_t v10 = *(void *)(v9 + 72);
      uint64_t v11 = v15;
      if (v10 == v15)
      {
        if (v10) {
          (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
        }
      }
      else
      {
        if (v10)
        {
          (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
          uint64_t v11 = v15;
        }
        *(void *)(v9 + 72) = v11;
      }
      uint64_t v5 = *(id **)(*(void *)(a1 + 312) + 72);
    }
    return HGMetalBuffer::ModifyRangeAndMarkAsDirty(v5, 0, *(void *)(a1 + 1376), a2);
  }
  else
  {
    std::chrono::system_clock::time_point v12 = *(id **)(v4 + 64);
    size_t v13 = *(void *)(a1 + 1376);
    return HGMetalBuffer::ModifyRangeAndMarkAsDirty(v12, 576, v13, a2);
  }
}

void sub_1B778C2E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(exception_object);
}

char *HGMetalHandler::_updateTexCoordsBuffer(char *result, void *a2)
{
  uint64_t v3 = (uint64_t)result;
  unint64_t v4 = *((unsigned int *)result + 122);
  if (result[320])
  {
    if (*((_DWORD *)result + 122))
    {
      uint64_t v5 = 11;
      do
      {
        if ((*(_DWORD *)(v3 + 484) >> (v5 - 11)))
        {
          long long v6 = *(id **)(*(void *)(v3 + 312) + 8 * v5);
          if (!v6)
          {
            std::chrono::time_point<std::chrono::system_clock, std::chrono::duration<long long, std::ratio<1, 1000000000>>> v8 = *(HGMetalContext **)(v3 + 248);
            uint64_t v9 = *(void **)(*((void *)v8 + 2) + 16);
            uint64_t v10 = (uint64_t *)HGMetalContext::bufferPool(v8);
            HGMetalBuffer::create(v9, v10, *(void *)(v3 + 1392), &v16);
            uint64_t v11 = *(void *)(v3 + 312);
            uint64_t v12 = *(void *)(v11 + 8 * v5);
            uint64_t v13 = v16;
            if (v12 == v16)
            {
              if (v12) {
                (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
              }
            }
            else
            {
              if (v12)
              {
                (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
                uint64_t v13 = v16;
              }
              *(void *)(v11 + 8 * v5) = v13;
            }
            long long v6 = *(id **)(*(void *)(v3 + 312) + 8 * v5);
          }
          __n128 result = HGMetalBuffer::ModifyRangeAndMarkAsDirty(v6, 0, *(void *)(v3 + 1392), a2);
          unint64_t v4 = *(unsigned int *)(v3 + 488);
        }
        unint64_t v7 = v5 - 10;
        ++v5;
      }
      while (v7 < v4);
    }
  }
  else if (*((_DWORD *)result + 122))
  {
    unint64_t v14 = 0;
    uint64_t v15 = 640;
    do
    {
      if ((*(_DWORD *)(v3 + 484) >> v14))
      {
        __n128 result = HGMetalBuffer::ModifyRangeAndMarkAsDirty(*(id **)(*(void *)(v3 + 312) + 64), v15, *(void *)(v3 + 1392), a2);
        unint64_t v4 = *(unsigned int *)(v3 + 488);
      }
      ++v14;
      v15 += 64;
    }
    while (v14 < v4);
  }
  return result;
}

void sub_1B778C49C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(exception_object);
}

void HGMetalHandler::_setCommandBufferDebugLabel(HGMetalHandler *this)
{
  std::to_string(&v4, *((_DWORD *)this + 445) + 1);
  unint64_t v2 = (void **)((char *)this + 1344);
  if (*((char *)this + 1367) < 0) {
    operator delete(*v2);
  }
  *(_OWORD *)unint64_t v2 = *(_OWORD *)&v4.__r_.__value_.__l.__data_;
  *((void *)this + 170) = *((void *)&v4.__r_.__value_.__l + 2);
  std::operator+<char>();
  if ((v4.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v3 = &v4;
  }
  else {
    uint64_t v3 = (std::string *)v4.__r_.__value_.__r.__words[0];
  }
  objc_msgSend(*((id *)this + 32), "setLabel:", objc_msgSend(NSString, "stringWithUTF8String:", v3));
  if (SHIBYTE(v4.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v4.__r_.__value_.__l.__data_);
  }
}

void sub_1B778C5A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void HGMetalHandler::_setupCommandEncoder(HGMetalHandler *this)
{
  v59[2] = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 33) || !*((unsigned char *)this + 1785)) {
    return;
  }
  if (!HGRectIsNull(*(void *)(*((void *)this + 41) + 20), *(void *)(*((void *)this + 41) + 28)))
  {
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v58, "metal", 2, "HGMetalHandler::_createCommandBufferAndEncoder()");
    std::string v4 = (void *)[MEMORY[0x1E4F352E0] renderPassDescriptor];
    uint64_t v5 = 0;
    long long v6 = (char *)this + 392;
    do
    {
      if (*(void *)&v6[8 * v5])
      {
        unint64_t v7 = objc_msgSend((id)objc_msgSend(v4, "colorAttachments"), "objectAtIndexedSubscript:", v5);
        [v7 setTexture:*(void *)(*(void *)&v6[8 * v5] + 144)];
        unsigned __int8 v10 = atomic_load(HGLogger::_enabled);
        if (v10) {
          HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"destination texture [%d] (%p)\n", v8, v9, v5, *(void *)&v6[8 * v5]);
        }
        std::operator+<char>();
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        objc_msgSend((id)objc_msgSend(v7, "texture"), "setLabel:", objc_msgSend(NSString, "stringWithUTF8String:", p_p));
        if (*((void *)this + 58)) {
          uint64_t v12 = 2;
        }
        else {
          uint64_t v12 = 1;
        }
        [v7 setStoreAction:v12];
        if (*(unsigned char *)(*(void *)&v6[8 * v5] + 168)) {
          uint64_t v13 = 1;
        }
        else {
          uint64_t v13 = 2;
        }
        [v7 setLoadAction:v13];
        objc_msgSend(v7, "setClearColor:", 0.0, 0.0, 0.0, 0.0);
        *(unsigned char *)(*(void *)&v6[8 * v5] + 168) = 1;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
      ++v5;
    }
    while (v5 != 8);
    uint64_t v14 = *((void *)this + 58);
    if (v14)
    {
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v4, "colorAttachments"), "objectAtIndexedSubscript:", 0), "setResolveTexture:", *(void *)(v14 + 144));
      unsigned __int8 v17 = atomic_load(HGLogger::_enabled);
      if (v17) {
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"destination resolve texture (%p)\n", v15, v16, *((void *)this + 58));
      }
      unsigned __int8 v18 = atomic_load(HGLogger::_enabled);
      if (v18) {
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"MSAA samples: %d\n", v15, v16, *((unsigned int *)this + 118));
      }
    }
    if (*((void *)this + 57))
    {
      uint64_t v19 = (void *)[v4 depthAttachment];
      [v19 setStoreAction:0];
      [v19 setLoadAction:2];
      [v19 setClearDepth:1.0];
      [v19 setTexture:*(void *)(*((void *)this + 57) + 144)];
      unsigned __int8 v22 = atomic_load(HGLogger::_enabled);
      if (v22) {
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"depth texture (%p)\n", v20, v21, *((void *)this + 57));
      }
    }
    uint64_t v23 = (void *)[*((id *)this + 32) renderCommandEncoderWithDescriptor:v4];
    *((void *)this + 33) = v23;
    id v24 = v23;
    [*((id *)this + 33) setFrontFacingWinding:1];
    uint64_t v25 = *((void *)this + 58);
    if (!v25) {
      uint64_t v25 = *((void *)this + 49);
    }
    int v26 = *(_DWORD *)(v25 + 20);
    int TextureRect = HGMetalTexture::GetTextureRect((HGMetalTexture *)v25);
    int v28 = *(_DWORD *)(v25 + 24);
    int v29 = v28 - ((unint64_t)HGMetalTexture::GetTextureRect((HGMetalTexture *)v25) >> 32);
    unsigned __int8 v30 = (void *)*((void *)this + 33);
    v54[0] = (double)(v26 - TextureRect);
    v54[1] = (double)v29;
    int32x2_t v31 = vsub_s32(*(int32x2_t *)(v25 + 28), *(int32x2_t *)(v25 + 20));
    v32.i64[0] = v31.u32[0];
    v32.i64[1] = v31.u32[1];
    float64x2_t v55 = vcvtq_f64_u64(v32);
    long long v56 = xmmword_1B7E733E0;
    [v30 setViewport:v54];
    if (*((void *)this + 57))
    {
      __p.__r_.__value_.__s.__data_[0] = 1;
      unsigned __int8 v35 = atomic_load(HGLogger::_enabled);
      if (v35) {
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"depth writing: enabled\n", v33, v34);
      }
      __p.__r_.__value_.__l.__size_ = 1;
      unsigned __int8 v36 = atomic_load(HGLogger::_enabled);
      if (v36) {
        HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"depth compare function: less\n", v33, v34);
      }
      DepthStencilState = HGMetalDepthStencilStateCache::getDepthStencilState(*(void *)(*(void *)(*((void *)this + 31) + 24) + 160), (unsigned __int8 *)&__p);
      [*((id *)this + 33) setDepthStencilState:DepthStencilState];
    }
    int v38 = *((char *)this + 1367);
    if (v38 >= 0) {
      size_t v39 = *((unsigned __int8 *)this + 1367);
    }
    else {
      size_t v39 = *((void *)this + 169);
    }
    unint64_t v40 = v39 + 1;
    if (v39 + 1 >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    if (v40 >= 0x17)
    {
      uint64_t v42 = (v40 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v40 | 7) != 0x17) {
        uint64_t v42 = v40 | 7;
      }
      uint64_t v43 = v42 + 1;
      p_dst = (std::string *)operator new(v42 + 1);
      __dst.__r_.__value_.__l.__size_ = v39 + 1;
      __dst.__r_.__value_.__r.__words[2] = v43 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      memset(&__dst, 0, sizeof(__dst));
      p_dst = &__dst;
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v39 + 1;
      if (!v39) {
        goto LABEL_54;
      }
    }
    if (v38 >= 0) {
      std::string v44 = (char *)this + 1344;
    }
    else {
      std::string v44 = (char *)*((void *)this + 168);
    }
    memmove(p_dst, v44, v39);
LABEL_54:
    *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v39) = 46;
    std::to_string(&v52, *((_DWORD *)this + 442) + 1);
    if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string v45 = &v52;
    }
    else {
      std::string v45 = (std::string *)v52.__r_.__value_.__r.__words[0];
    }
    if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v52.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v52.__r_.__value_.__l.__size_;
    }
    uint64_t v47 = std::string::append(&__dst, (const std::string::value_type *)v45, size);
    long long v48 = *(_OWORD *)&v47->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__r.__words[2] = v47->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v48;
    v47->__r_.__value_.__l.__size_ = 0;
    v47->__r_.__value_.__r.__words[2] = 0;
    v47->__r_.__value_.__r.__words[0] = 0;
    uint64_t v49 = std::string::append(&__p, " ");
    std::string::size_type v50 = v49->__r_.__value_.__r.__words[0];
    v59[0] = v49->__r_.__value_.__l.__size_;
    *(void *)((char *)v59 + 7) = *(std::string::size_type *)((char *)&v49->__r_.__value_.__r.__words[1] + 7);
    char v51 = HIBYTE(v49->__r_.__value_.__r.__words[2]);
    v49->__r_.__value_.__l.__size_ = 0;
    v49->__r_.__value_.__r.__words[2] = 0;
    v49->__r_.__value_.__r.__words[0] = 0;
    if (*((char *)this + 1343) < 0) {
      operator delete(*((void **)this + 165));
    }
    *((void *)this + 165) = v50;
    *((void *)this + 166) = v59[0];
    *(void *)((char *)this + 1335) = *(void *)((char *)v59 + 7);
    *((unsigned char *)this + 1343) = v51;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v52.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_64:
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_65:
          *((unsigned char *)this + 1784) = 1;
          *((_DWORD *)this + 441) = 0;
          HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v58);
          return;
        }
LABEL_68:
        operator delete(__dst.__r_.__value_.__l.__data_);
        goto LABEL_65;
      }
    }
    else if ((SHIBYTE(v52.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_64;
    }
    operator delete(v52.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_65;
    }
    goto LABEL_68;
  }
  *((unsigned char *)this + 1785) = 0;

  HGLogger::warning((HGLogger *)"HGMetalHandler::_setupCommandEncoder -- null buffer target!!", v2, v3);
}

void sub_1B778CBB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_1B778CBC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_1B778CBDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35)
{
  if (a34 < 0)
  {
    operator delete(__p);
    if ((a16 & 0x80000000) == 0)
    {
LABEL_3:
      if ((a22 & 0x80000000) == 0)
      {
LABEL_8:
        HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a35);
        _Unwind_Resume(a1);
      }
LABEL_7:
      operator delete(a17);
      goto LABEL_8;
    }
  }
  else if ((a16 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a11);
  if ((a22 & 0x80000000) == 0) {
    goto LABEL_8;
  }
  goto LABEL_7;
}

void HGMetalHandler::_updatePipelineState(HGMetalHandler *this)
{
  if (*((unsigned char *)this + 1784))
  {
    unint64_t v2 = (void *)*((void *)this + 176);
    if (v2) {

    }
    *((void *)this + 176) = 0;
  }
  if (*((unsigned char *)this + 1785) && !*((void *)this + 176))
  {
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v50, "metal", 2, "HGMetalHandler::_createPipelineState()");
    LODWORD(v23) = 0;
    *(void *)&long long v24 = 0;
    *((void *)&v24 + 1) = 1;
    *(_DWORD *)uint64_t v25 = 1;
    *(void *)&v25[4] = 0;
    *(void *)&v25[9] = 0;
    LODWORD(v26) = 0;
    *(void *)&long long v27 = 0;
    *((void *)&v27 + 1) = 1;
    *(_DWORD *)int v28 = 1;
    *(void *)&v28[4] = 0;
    *(void *)&v28[9] = 0;
    LODWORD(v29) = 0;
    *(void *)&long long v30 = 0;
    *((void *)&v30 + 1) = 1;
    *(_DWORD *)int32x2_t v31 = 1;
    *(void *)&v31[4] = 0;
    *(void *)&v31[9] = 0;
    LODWORD(v32) = 0;
    *(void *)std::string::size_type v33 = 0;
    *(void *)&v33[8] = 1;
    *(void *)&v33[25] = 0;
    *(void *)&v33[20] = 0;
    *(_DWORD *)&v33[16] = 1;
    LODWORD(v34) = 0;
    *(void *)&long long v35 = 0;
    *((void *)&v35 + 1) = 1;
    *(void *)&v36[4] = 0;
    *(void *)&v36[9] = 0;
    *(_DWORD *)unsigned __int8 v36 = 1;
    LODWORD(v37) = 0;
    *(void *)&long long v38 = 0;
    *((void *)&v38 + 1) = 1;
    *(_DWORD *)size_t v39 = 1;
    *(void *)&v39[4] = 0;
    *(void *)&v39[9] = 0;
    LODWORD(v40) = 0;
    *(void *)char v41 = 0;
    *(void *)&v41[8] = 1;
    *(_DWORD *)&v41[16] = 1;
    *(void *)&v41[25] = 0;
    *(void *)&v41[20] = 0;
    LODWORD(v42) = 0;
    *(void *)&long long v43 = 0;
    *((void *)&v43 + 1) = 1;
    *(_DWORD *)std::string v44 = 1;
    *(void *)&v44[4] = 0;
    *(void *)&v44[9] = 0;
    std::string __p = 0;
    long long v48 = 0;
    *(_DWORD *)&v44[24] = *((_DWORD *)this + 118);
    v44[28] = *((void *)this + 57) != 0;
    uint64_t v3 = *((void *)this + 178);
    uint64_t v45 = *((void *)this + 177);
    uint64_t v46 = v3;
    uint64_t v49 = 0;
    if (&__p != (void **)((char *)this + 1432)) {
      std::vector<HGMTLFunctionType>::__assign_with_size[abi:ne180100]<HGMTLFunctionType*,HGMTLFunctionType*>(&__p, *((char **)this + 179), *((char **)this + 180), (uint64_t)(*((void *)this + 180) - *((void *)this + 179)) >> 3);
    }
    char v4 = *((unsigned char *)this + 1456);
    uint64_t v5 = *((void *)this + 49);
    if (v5) {
      LODWORD(v5) = *(_DWORD *)(v5 + 16);
    }
    LODWORD(v23) = v5;
    if (v4)
    {
      v25[16] = 1;
      long long v6 = *(_OWORD *)((char *)this + 1480);
      long long v24 = *(_OWORD *)((char *)this + 1464);
      *(_OWORD *)uint64_t v25 = v6;
    }
    uint64_t v7 = *((void *)this + 50);
    if (v7) {
      LODWORD(v7) = *(_DWORD *)(v7 + 16);
    }
    LODWORD(v26) = v7;
    if ((v4 & 2) != 0)
    {
      v28[16] = 1;
      long long v8 = *(_OWORD *)((char *)this + 1512);
      long long v27 = *(_OWORD *)((char *)this + 1496);
      *(_OWORD *)int v28 = v8;
    }
    uint64_t v9 = *((void *)this + 51);
    if (v9) {
      LODWORD(v9) = *(_DWORD *)(v9 + 16);
    }
    LODWORD(v29) = v9;
    if ((v4 & 4) != 0)
    {
      unsigned char v31[16] = 1;
      long long v10 = *(_OWORD *)((char *)this + 1544);
      long long v30 = *(_OWORD *)((char *)this + 1528);
      *(_OWORD *)int32x2_t v31 = v10;
    }
    uint64_t v11 = *((void *)this + 52);
    if (v11) {
      LODWORD(v11) = *(_DWORD *)(v11 + 16);
    }
    LODWORD(v32) = v11;
    if ((v4 & 8) != 0)
    {
      v33[32] = 1;
      long long v12 = *(_OWORD *)((char *)this + 1576);
      *(_OWORD *)std::string::size_type v33 = *(_OWORD *)((char *)this + 1560);
      *(_OWORD *)&v33[16] = v12;
    }
    uint64_t v13 = *((void *)this + 53);
    if (v13) {
      LODWORD(v13) = *(_DWORD *)(v13 + 16);
    }
    LODWORD(v34) = v13;
    if ((v4 & 0x10) != 0)
    {
      v36[16] = 1;
      long long v14 = *(_OWORD *)((char *)this + 1608);
      long long v35 = *(_OWORD *)((char *)this + 1592);
      *(_OWORD *)unsigned __int8 v36 = v14;
    }
    uint64_t v15 = *((void *)this + 54);
    if (v15) {
      LODWORD(v15) = *(_DWORD *)(v15 + 16);
    }
    LODWORD(v37) = v15;
    if ((v4 & 0x20) != 0)
    {
      v39[16] = 1;
      long long v16 = *(_OWORD *)((char *)this + 1640);
      long long v38 = *(_OWORD *)((char *)this + 1624);
      *(_OWORD *)size_t v39 = v16;
    }
    uint64_t v17 = *((void *)this + 55);
    if (v17) {
      LODWORD(v17) = *(_DWORD *)(v17 + 16);
    }
    LODWORD(v40) = v17;
    if ((v4 & 0x40) != 0)
    {
      v41[32] = 1;
      long long v18 = *(_OWORD *)((char *)this + 1672);
      *(_OWORD *)char v41 = *(_OWORD *)((char *)this + 1656);
      *(_OWORD *)&v41[16] = v18;
    }
    uint64_t v19 = *((void *)this + 56);
    if (v19) {
      LODWORD(v19) = *(_DWORD *)(v19 + 16);
    }
    LODWORD(v42) = v19;
    if (v4 < 0)
    {
      v44[16] = 1;
      long long v20 = *(_OWORD *)((char *)this + 1704);
      long long v43 = *(_OWORD *)((char *)this + 1688);
      *(_OWORD *)std::string v44 = v20;
    }
    RenderPipelineState = HGMetalRenderPipelineStateCache::getRenderPipelineState(*(void *)(*(void *)(*((void *)this + 31) + 24) + 144), (int *)&v23);
    *((void *)this + 176) = RenderPipelineState;
    if (RenderPipelineState)
    {
      objc_msgSend(*((id *)this + 33), "setRenderPipelineState:", RenderPipelineState, v23, v24, *(_OWORD *)v25, *(void *)&v25[16], v26, v27, *(_OWORD *)v28, *(void *)&v28[16], v29, v30, *(_OWORD *)v31, *(void *)&v31[16], v32, *(void *)v33, *(_OWORD *)&v33[8], *(_OWORD *)&v33[24],
        v34,
        v35,
        *(_OWORD *)v36,
        *(void *)&v36[16],
        v37,
        v38,
        *(_OWORD *)v39,
        *(void *)&v39[16],
        v40,
        *(void *)v41,
        *(_OWORD *)&v41[8],
        *(_OWORD *)&v41[24],
        v42,
        v43,
        *(_OWORD *)v44,
        *(_OWORD *)&v44[16],
        v45,
        v46);
    }
    else
    {
      *((unsigned char *)this + 1785) = 0;
      HGLogger::warning((HGLogger *)"nil pipeline state.", v21, 0, v23, v24, *(_OWORD *)v25, *(void *)&v25[16], v26, v27, *(_OWORD *)v28, *(void *)&v28[16], v29, v30, *(_OWORD *)v31, *(void *)&v31[16], v32, *(void *)v33, *(_OWORD *)&v33[8], *(_OWORD *)&v33[24],
        v34,
        v35,
        *(_OWORD *)v36,
        *(void *)&v36[16],
        v37,
        v38,
        *(_OWORD *)v39,
        *(void *)&v39[16],
        v40,
        *(void *)v41,
        *(_OWORD *)&v41[8],
        *(_OWORD *)&v41[24],
        v42,
        v43,
        *(_OWORD *)v44,
        *(_OWORD *)&v44[16],
        v45,
        v46);
    }
    if (__p)
    {
      long long v48 = __p;
      operator delete(__p);
    }
    HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v50);
    *((unsigned char *)this + 1784) = 0;
  }
  else
  {
    *((unsigned char *)this + 1784) = 0;
  }
}

void sub_1B778D0AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,void *__p,uint64_t a61)
{
  if (__p) {
    operator delete(__p);
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v61 - 48));
  _Unwind_Resume(a1);
}

void HGMetalHandler::_validateMetalFunctions(HGMetalHandler *this, const char *a2, char *a3)
{
  if (*((void *)this + 178))
  {
    if (*((void *)this + 177)) {
      return;
    }
  }
  else
  {
    HGLogger::warning((HGLogger *)"missing fragment function.", a2, a3);
    if (*((void *)this + 177)) {
      return;
    }
  }
  std::to_string(&v32, *((_DWORD *)this + 122));
  char v4 = std::string::insert(&v32, 0, "NumTexcoords:");
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v33.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    long long v6 = &v33;
  }
  else {
    long long v6 = (std::string *)v33.__r_.__value_.__r.__words[0];
  }
  if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v33.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v33.__r_.__value_.__l.__size_;
  }
  unint64_t v8 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&v31, (uint64_t *)v6, size);
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v33.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v32.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_13;
    }
  }
  else if ((SHIBYTE(v32.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_13;
  }
  operator delete(v32.__r_.__value_.__l.__data_);
LABEL_13:
  std::to_string(&v32, *((unsigned __int8 *)this + 492));
  uint64_t v9 = std::string::insert(&v32, 0, "UseVertexColors:");
  long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  v33.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v11 = &v33;
  }
  else {
    uint64_t v11 = (std::string *)v33.__r_.__value_.__r.__words[0];
  }
  if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v12 = HIBYTE(v33.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v12 = v33.__r_.__value_.__l.__size_;
  }
  unint64_t v13 = v8 ^ (2
            * std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&v31, (uint64_t *)v11, v12));
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v33.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v32.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_21;
    }
  }
  else if ((SHIBYTE(v32.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_21;
  }
  operator delete(v32.__r_.__value_.__l.__data_);
LABEL_21:
  *((unsigned char *)&v33.__r_.__value_.__s + 23) = 10;
  strcpy((char *)&v33, "vertexFunc");
  uint64_t v14 = *(void *)(*(void *)(*((void *)this + 31) + 24) + 168);
  Function = HGMetalFunctionCache::getFunction(v14, &v33, v13);
  if (!Function)
  {
    HGMetalUtils::stringForMetalHeader((uint64_t)&v30);
    HGMetalUtils::stringForMetalVertexOutputStruct((HGMetalUtils *)*((unsigned int *)this + 122), *((unsigned char *)this + 492), (uint64_t)v28);
    if ((v29 & 0x80u) == 0) {
      long long v16 = v28;
    }
    else {
      long long v16 = (void **)v28[0];
    }
    if ((v29 & 0x80u) == 0) {
      std::string::size_type v17 = v29;
    }
    else {
      std::string::size_type v17 = (std::string::size_type)v28[1];
    }
    long long v18 = std::string::append(&v30, (const std::string::value_type *)v16, v17);
    long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      long long v20 = (HGMetalUtils *)&v33;
    }
    else {
      long long v20 = (HGMetalUtils *)v33.__r_.__value_.__r.__words[0];
    }
    HGMetalUtils::stringForMetalVertexShader(v20, (const char *)*((unsigned int *)this + 122), *((unsigned char *)this + 492), (uint64_t)__p);
    if ((v27 & 0x80u) == 0) {
      unint64_t v21 = __p;
    }
    else {
      unint64_t v21 = (void **)__p[0];
    }
    if ((v27 & 0x80u) == 0) {
      std::string::size_type v22 = v27;
    }
    else {
      std::string::size_type v22 = (std::string::size_type)__p[1];
    }
    uint64_t v23 = std::string::append(&v31, (const std::string::value_type *)v21, v22);
    long long v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    if ((char)v27 < 0)
    {
      operator delete(__p[0]);
      if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_39:
        if (((char)v29 & 0x80000000) == 0) {
          goto LABEL_40;
        }
        goto LABEL_51;
      }
    }
    else if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_39;
    }
    operator delete(v31.__r_.__value_.__l.__data_);
    if (((char)v29 & 0x80000000) == 0)
    {
LABEL_40:
      if ((SHIBYTE(v30.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_41;
      }
LABEL_52:
      operator delete(v30.__r_.__value_.__l.__data_);
LABEL_41:
      Function = HGMetalFunctionCache::getFunctionWithSource(v14, &v33, v13, (uint64_t *)&v32);
      if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v32.__r_.__value_.__l.__data_);
      }
      goto LABEL_43;
    }
LABEL_51:
    operator delete(v28[0]);
    if ((SHIBYTE(v30.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_41;
    }
    goto LABEL_52;
  }
LABEL_43:
  *((void *)this + 177) = Function;
  uint64_t v25 = Function;
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v33.__r_.__value_.__l.__data_);
  }
}

void sub_1B778D3F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (*(char *)(v33 - 73) < 0) {
    operator delete(*(void **)(v33 - 96));
  }
  if (*(char *)(v33 - 41) < 0) {
    operator delete(*(void **)(v33 - 64));
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGMetalHandler::_setupScissorRect(uint64_t this)
{
  if (*(unsigned char *)(this + 1785))
  {
    uint64_t v1 = this;
    if (*(unsigned char *)(this + 1744))
    {
      *(void *)&long long v13 = HGRectIntersection(*(void *)(this + 1748), *(void *)(this + 1756), *(void *)(*(void *)(this + 328) + 20), *(void *)(*(void *)(this + 328) + 28));
      *((void *)&v13 + 1) = v2;
      uint64_t v3 = *(void *)(v1 + 328);
    }
    else
    {
      uint64_t v3 = *(void *)(this + 328);
      long long v13 = *(_OWORD *)(v3 + 20);
    }
    unint64_t v4 = HGFormatUtils::collapseRectForFormat((uint64_t *)&v13, *(_DWORD *)(v3 + 16));
    int v5 = v4;
    uint64_t v7 = v6;
    unint64_t v8 = HIDWORD(v4);
    uint64_t v9 = v4 - HGMetalTexture::GetTextureRect(*(HGMetalTexture **)(v1 + 392));
    uint64_t v10 = (v8 - ((unint64_t)HGMetalTexture::GetTextureRect(*(HGMetalTexture **)(v1 + 392)) >> 32));
    uint64_t v11 = *(void **)(v1 + 264);
    v12[0] = v9;
    v12[1] = v10;
    v12[2] = (v7 - v5);
    v12[3] = (HIDWORD(v7) - v8);
    return [v11 setScissorRect:v12];
  }
  return this;
}

void HGMetalHandler::_setCommandEncoderDebugLabel(HGMetalHandler *this)
{
  if ((*((char *)this + 1343) & 0x80000000) == 0)
  {
    uint64_t v2 = (char *)this + 1320;
    unint64_t v3 = *((unsigned __int8 *)this + 1343);
    unint64_t v4 = (char *)this + v3 + 1320;
    if (*((unsigned char *)this + 1343)) {
      goto LABEL_3;
    }
LABEL_14:
    uint64_t v6 = v4;
    goto LABEL_15;
  }
  uint64_t v2 = (const std::string::value_type *)*((void *)this + 165);
  unint64_t v3 = *((void *)this + 166);
  unint64_t v4 = &v2[v3];
  if (!v3) {
    goto LABEL_14;
  }
LABEL_3:
  int v5 = v2;
  uint64_t v6 = v4;
  while (1)
  {
    ++v5;
    while (*(v5 - 1) != 124)
    {
      BOOL v7 = v5++ == v4;
      if (v7) {
        goto LABEL_15;
      }
    }
    if (v5 == v4) {
      break;
    }
    if (*v5 == 32) {
      uint64_t v6 = v5 - 1;
    }
  }
LABEL_15:
  BOOL v7 = v6 - v2 == -1 || v6 == v4;
  if (v7) {
    unint64_t v8 = v3;
  }
  else {
    unint64_t v8 = v6 - v2;
  }
  if (v8 >= 0x32) {
    std::string::size_type v9 = 50;
  }
  else {
    std::string::size_type v9 = v8;
  }
  *((unsigned char *)&v22.__r_.__value_.__s + 23) = 5;
  strcpy((char *)&v22, "HGCE ");
  std::string::append(&v22, v2, v9);
  if (v8 >= 0x33) {
    std::string::append(&v22, " ... ");
  }
  unsigned int v10 = *((_DWORD *)this + 441);
  if (v10 >= 2)
  {
    std::to_string(&v18, v10);
    uint64_t v11 = std::string::insert(&v18, 0, "(");
    long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    v19.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v19.__r_.__value_.__l.__data_ = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    long long v13 = std::string::append(&v19, ")");
    long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    int64_t v21 = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    if (v21 >= 0) {
      uint64_t v15 = __p;
    }
    else {
      uint64_t v15 = (void **)__p[0];
    }
    if (v21 >= 0) {
      std::string::size_type v16 = HIBYTE(v21);
    }
    else {
      std::string::size_type v16 = (std::string::size_type)__p[1];
    }
    std::string::append(&v22, (const std::string::value_type *)v15, v16);
    if (SHIBYTE(v21) < 0)
    {
      operator delete(__p[0]);
      if ((SHIBYTE(v19.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_35:
        if ((SHIBYTE(v18.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_36;
        }
LABEL_43:
        operator delete(v18.__r_.__value_.__l.__data_);
        goto LABEL_36;
      }
    }
    else if ((SHIBYTE(v19.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_35;
    }
    operator delete(v19.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v18.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_36;
    }
    goto LABEL_43;
  }
LABEL_36:
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v17 = &v22;
  }
  else {
    std::string::size_type v17 = (std::string *)v22.__r_.__value_.__r.__words[0];
  }
  objc_msgSend(*((id *)this + 33), "setLabel:", objc_msgSend(NSString, "stringWithUTF8String:", v17));
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v22.__r_.__value_.__l.__data_);
  }
}

void sub_1B778D7BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0)
  {
    operator delete(__p);
    if ((a21 & 0x80000000) == 0)
    {
LABEL_3:
      if ((a15 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else if ((a21 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a16);
  if ((a15 & 0x80000000) == 0)
  {
LABEL_4:
    if ((*(char *)(v28 - 17) & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_9;
  }
LABEL_8:
  operator delete(a10);
  if ((*(char *)(v28 - 17) & 0x80000000) == 0) {
LABEL_5:
  }
    _Unwind_Resume(exception_object);
LABEL_9:
  operator delete(*(void **)(v28 - 40));
  _Unwind_Resume(exception_object);
}

HGMetalHandler::CommandEncoderCargo *___ZN14HGMetalHandler20_commitCommandBufferEv_block_invoke(void *a1)
{
  uint64_t v2 = a1[6];
  std::mutex::lock((std::mutex *)(v2 + 1808));
  atomic_fetch_add((atomic_ullong *volatile)(v2 + 1792), 0xFFFFFFFFFFFFFFFFLL);
  atomic_fetch_add((atomic_ullong *volatile)(v2 + 1800), -*(void *)(*(void *)(a1[4] + 8) + 24));
  std::mutex::unlock((std::mutex *)(v2 + 1808));
  std::condition_variable::notify_all((std::condition_variable *)(v2 + 1872));
  atomic_load((unint64_t *)(v2 + 1792));
  atomic_load((unint64_t *)(v2 + 1800));
  kdebug_trace();
  unint64_t v3 = *(HGMetalHandler::CommandEncoderCargo ****)(*(void *)(a1[5] + 8) + 24);
  unint64_t v4 = *v3;
  int v5 = v3[1];
  if (*v3 == v5)
  {
    if (!v4) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  do
  {
    __n128 result = *v4;
    if (*v4)
    {
      HGMetalHandler::CommandEncoderCargo::~CommandEncoderCargo(result);
      __n128 result = (HGMetalHandler::CommandEncoderCargo *)MEMORY[0x1BA9BFBA0]();
    }
    ++v4;
  }
  while (v4 != v5);
  unint64_t v3 = *(HGMetalHandler::CommandEncoderCargo ****)(*(void *)(a1[5] + 8) + 24);
  if (v3)
  {
    unint64_t v4 = *v3;
    if (!*v3)
    {
LABEL_4:
      JUMPOUT(0x1BA9BFBA0);
    }
LABEL_3:
    v3[1] = v4;
    operator delete(v4);
    goto LABEL_4;
  }
  return result;
}

void HGMetalHandler::_encodeSourceSampler(HGMetalHandler *this, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  uint64_t v7 = (int)a2;
  unint64_t v8 = (int32x2_t *)((char *)this + 32 * (int)a2);
  int32x2_t v9 = vtst_s32(v8[62], v8[62]);
  v10.i64[0] = v9.u32[0];
  v10.i64[1] = v9.u32[1];
  int8x16_t v23 = vandq_s8(v10, (int8x16_t)vdupq_n_s64(1uLL));
  unsigned __int8 v11 = atomic_load(HGLogger::_enabled);
  if (v11)
  {
    long long v12 = "linear";
    if (v23.i64[0]) {
      long long v13 = "linear";
    }
    else {
      long long v13 = "nearest";
    }
    if (!v23.i64[1]) {
      long long v12 = "nearest";
    }
    HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"%d: %s / %s\n", a4, a5, a2, v13, v12);
  }
  __int32 v14 = v8[63].i32[1];
  if (!*(unsigned char *)(PCICCTransferFunctionLUT::getLUTEnd(*((PCICCTransferFunctionLUT **)this + 31)) + 56))
  {
    uint64_t v21 = *(void *)(*((void *)this + 39) + 8 * v7);
    if (v21)
    {
      if (!*(unsigned char *)(v21 + 169))
      {
        uint64_t v24 = 0;
        unsigned __int8 v22 = atomic_load(HGLogger::_enabled);
        if ((v22 & 1) == 0) {
          goto LABEL_12;
        }
LABEL_11:
        HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"sampler address mode : ClampToEdge\n", v15, v16);
        goto LABEL_12;
      }
    }
  }
  uint64_t v24 = 4 * (v14 != 1);
  if (v14 == 1)
  {
    unsigned __int8 v17 = atomic_load(HGLogger::_enabled);
    if (v17) {
      goto LABEL_11;
    }
  }
LABEL_12:
  char v25 = *((unsigned char *)this + 32 * v7 + 504);
  unsigned __int8 v18 = atomic_load(HGLogger::_enabled);
  if (v18)
  {
    if (v25) {
      std::string v19 = "normalized";
    }
    else {
      std::string v19 = "rectangular";
    }
    HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"%d: %s\n", v15, v16, a2, v19);
  }
  SamplerState = HGMetalSamplerStateCache::getSamplerState(*(void *)(*(void *)(*((void *)this + 31) + 24) + 152), (uint64_t)&v23);
  [*((id *)this + 33) setFragmentSamplerState:SamplerState atIndex:v7];
}

void HGMetalHandler::CommandEncoderCargo::~CommandEncoderCargo(HGMetalHandler::CommandEncoderCargo *this)
{
  uint64_t v2 = *((void *)this + 30);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 29);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  uint64_t v4 = *((void *)this + 28);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  uint64_t v5 = *((void *)this + 27);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  uint64_t v6 = *((void *)this + 26);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
  }
  uint64_t v7 = *((void *)this + 25);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
  }
  uint64_t v8 = *((void *)this + 24);
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
  }
  uint64_t v9 = *((void *)this + 23);
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
  }
  uint64_t v10 = *((void *)this + 22);
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  }
  uint64_t v11 = *((void *)this + 21);
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
  }
  uint64_t v12 = *((void *)this + 20);
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
  }
  uint64_t v13 = *((void *)this + 19);
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 24))(v13);
  }
  uint64_t v14 = *((void *)this + 18);
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);
  }
  uint64_t v15 = *((void *)this + 17);
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 24))(v15);
  }
  uint64_t v16 = *((void *)this + 16);
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 24))(v16);
  }
  uint64_t v17 = *((void *)this + 15);
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 24))(v17);
  }
  uint64_t v18 = *((void *)this + 14);
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 24))(v18);
  }
  uint64_t v19 = *((void *)this + 13);
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 24))(v19);
  }
  uint64_t v20 = *((void *)this + 12);
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 24))(v20);
  }
  uint64_t v21 = *((void *)this + 11);
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 24))(v21);
  }
  uint64_t v22 = *((void *)this + 10);
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 24))(v22);
  }
  uint64_t v23 = *((void *)this + 9);
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 24))(v23);
  }
  uint64_t v24 = *((void *)this + 8);
  if (v24) {
    (*(void (**)(uint64_t))(*(void *)v24 + 24))(v24);
  }
  uint64_t v25 = *((void *)this + 7);
  if (v25) {
    (*(void (**)(uint64_t))(*(void *)v25 + 24))(v25);
  }
  uint64_t v26 = *((void *)this + 6);
  if (v26) {
    (*(void (**)(uint64_t))(*(void *)v26 + 24))(v26);
  }
  uint64_t v27 = *((void *)this + 5);
  if (v27) {
    (*(void (**)(uint64_t))(*(void *)v27 + 24))(v27);
  }
  uint64_t v28 = *((void *)this + 4);
  if (v28) {
    (*(void (**)(uint64_t))(*(void *)v28 + 24))(v28);
  }
  uint64_t v29 = *((void *)this + 3);
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 24))(v29);
  }
  uint64_t v30 = *((void *)this + 2);
  if (v30) {
    (*(void (**)(uint64_t))(*(void *)v30 + 24))(v30);
  }
  uint64_t v31 = *((void *)this + 1);
  if (v31) {
    (*(void (**)(uint64_t))(*(void *)v31 + 24))(v31);
  }
  if (*(void *)this) {
    (*(void (**)(void))(**(void **)this + 24))(*(void *)this);
  }
}

void *std::vector<HGMTLFunctionType>::__assign_with_size[abi:ne180100]<HGMTLFunctionType*,HGMTLFunctionType*>(void *result, char *__src, char *a3, size_t __sz)
{
  uint64_t v6 = __src;
  uint64_t v7 = result;
  uint64_t v8 = result[2];
  uint64_t v9 = (char *)*result;
  if (__sz > (v8 - *result) >> 3)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (__sz >> 61) {
      goto LABEL_22;
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= __sz) {
      uint64_t v10 = __sz;
    }
    BOOL v11 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8;
    unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v11) {
      unint64_t v12 = v10;
    }
    if (v12 >> 61) {
LABEL_22:
    }
      std::vector<double>::__throw_length_error[abi:ne180100]();
    uint64_t v13 = v12;
    __n128 result = operator new(8 * v12);
    uint64_t v9 = (char *)result;
    void *v7 = result;
    v7[1] = result;
    v7[2] = &result[v13];
    size_t v14 = a3 - v6;
    if (v14) {
      __n128 result = memcpy(result, v6, v14);
    }
    uint64_t v15 = (void **)(v7 + 1);
    goto LABEL_21;
  }
  uint64_t v15 = (void **)(result + 1);
  uint64_t v16 = (unsigned char *)result[1];
  unint64_t v17 = (v16 - v9) >> 3;
  if (v17 >= __sz)
  {
    size_t v14 = a3 - __src;
    if (a3 == __src) {
      goto LABEL_21;
    }
    uint64_t v19 = (void *)*result;
LABEL_20:
    __n128 result = memmove(v19, __src, v14);
    goto LABEL_21;
  }
  uint64_t v18 = &__src[8 * v17];
  if (v16 != v9)
  {
    __n128 result = memmove((void *)*result, __src, v16 - v9);
    uint64_t v9 = (char *)*v15;
  }
  size_t v14 = a3 - v18;
  if (v14)
  {
    uint64_t v19 = v9;
    __src = v18;
    goto LABEL_20;
  }
LABEL_21:
  *uint64_t v15 = &v9[v14];
  return result;
}

uint64_t HGTile::Renderer(HGTile *this)
{
  return *(void *)(*((void *)this + 42) + 152);
}

uint64_t HGPage::ReleaseTextures(HGPage *this)
{
  uint64_t v2 = *((void *)this + 21);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
    *((void *)this + 21) = 0;
  }
  uint64_t v3 = *((void *)this + 22);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
    *((void *)this + 22) = 0;
  }
  uint64_t v4 = *((void *)this + 23);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
    *((void *)this + 23) = 0;
  }
  uint64_t v5 = *((void *)this + 24);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
    *((void *)this + 24) = 0;
  }
  uint64_t v6 = *((void *)this + 25);
  if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
    *((void *)this + 25) = 0;
  }
  uint64_t v7 = *((void *)this + 26);
  if (v7)
  {
    (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
    *((void *)this + 26) = 0;
  }
  uint64_t v8 = *((void *)this + 27);
  if (v8)
  {
    (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
    *((void *)this + 27) = 0;
  }
  uint64_t result = *((void *)this + 28);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
    *((void *)this + 28) = 0;
  }
  return result;
}

void HGPagePullTexturesGuard::HGPagePullTexturesGuard(HGPagePullTexturesGuard *this, HGNode *a2, HGPage *a3)
{
  *(void *)this = a3;
  if (a2) {
    (*(void (**)(HGNode *, HGPage *, void))(*(void *)a2 + 472))(a2, a3, 0);
  }
}

void HGPagePullTexturesGuard::~HGPagePullTexturesGuard(HGPage **this)
{
  uint64_t v1 = *this;
  if (v1) {
    HGPage::ReleaseTextures(v1);
  }
}

void HGPagePullMetalTexturesGuard::HGPagePullMetalTexturesGuard(HGPagePullMetalTexturesGuard *this, HGNode *a2, HGPage *a3)
{
  *(void *)this = a3;
  if (a2) {
    (*(void (**)(HGNode *, HGPage *, void))(*(void *)a2 + 480))(a2, a3, 0);
  }
}

void HGPagePullMetalTexturesGuard::~HGPagePullMetalTexturesGuard(HGPage **this)
{
  uint64_t v1 = *this;
  if (v1) {
    HGPage::ReleaseTextures(v1);
  }
}

HGNode *HGNode::ClearNodeChain(HGNode *this)
{
  *((void *)this + 38) = *((void *)this + 37);
  return this;
}

void HGNode::HGNode(HGNode *this)
{
  HGObject::HGObject((HGObject *)this);
  *(void *)uint64_t v1 = &unk_1F10D50D0;
  *(_DWORD *)(v1 + 12) = 0;
  *(void *)(v1 + 24) = 0;
  *(void *)(v1 + 32) = 0xF00000004;
  *(void *)(v1 + 120) = 0;
  *(void *)(v1 + 112) = v1 + 120;
  *(void *)(v1 + 128) = 0;
  *(void *)(v1 + 40) = 0;
  *(void *)(v1 + 72) = 0;
  *(void *)(v1 + 80) = 0;
  *(void *)(v1 + 64) = 0;
  *(_DWORD *)(v1 + 88) = 0;
  *(void *)(v1 + 96) = 0;
  *(void *)(v1 + 101) = 0;
  *(_DWORD *)(v1 + 136) = 0;
  *(void *)(v1 + 144) = 0;
  *(_OWORD *)(v1 + 152) = HGRectNull;
  *(_OWORD *)(v1 + 168) = HGRectNull;
  *(_OWORD *)(v1 + 248) = 0u;
  *(_DWORD *)(v1 + 216) = 0;
  *(_OWORD *)(v1 + 184) = 0u;
  *(_OWORD *)(v1 + 200) = 0u;
  *(_OWORD *)(v1 + 220) = HGRectNull;
  *(void *)(v1 + 236) = 0;
  *(_OWORD *)(v1 + 264) = 0u;
  *(_OWORD *)(v1 + 280) = 0u;
  *(_OWORD *)(v1 + 296) = 0u;
  *(_OWORD *)(v1 + 312) = 0u;
  *(_DWORD *)(v1 + 328) = -1;
  *(unsigned char *)(v1 + 332) = 0;
  *(void *)(v1 + 336) = 0;
  *(_OWORD *)(v1 + 344) = xmmword_1B7EBF8F0;
  *(void *)(v1 + 360) = 0;
  *(_DWORD *)(v1 + 368) = 1065353216;
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)(v1 + 384) = _Q0;
  *(void *)(v1 + 400) = 0;
  *(_DWORD *)(v1 + 16) = 512;
  *(void *)(v1 + 48) = 0;
  *(_DWORD *)(v1 + 56) = 2;
  HGShaderBinding::reset((HGShaderBinding *)(v1 + 260));
}

void sub_1B778E62C(_Unwind_Exception *a1)
{
  uint64_t v4 = *(void *)(v1 + 400);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  uint64_t v5 = *(void **)(v1 + 296);
  if (v5)
  {
    *(void *)(v1 + 304) = v5;
    operator delete(v5);
  }
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v2, *(void **)(v1 + 120));
  HGObject::~HGObject((HGObject *)v1);
  _Unwind_Resume(a1);
}

void HGNode::~HGNode(HGNode *this)
{
  *(void *)this = &unk_1F10D50D0;
  uint64_t v2 = *((void *)this + 24);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
    *((void *)this + 24) = 0;
  }
  uint64_t v3 = *((void *)this + 31);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
    *((void *)this + 31) = 0;
  }
  uint64_t v4 = *((void *)this + 12);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
    *((void *)this + 12) = 0;
  }
  if (*((int *)this + 22) >= 1)
  {
    uint64_t v5 = 0;
    do
    {
      if (*(void *)(*((void *)this + 10) + 8 * v5))
      {
        (*(void (**)(HGNode *, uint64_t, void))(*(void *)this + 120))(this, v5, 0);
        uint64_t v6 = *(void *)(*((void *)this + 10) + 8 * v5);
        if (v6) {
          MEMORY[0x1BA9BFBA0](v6, 0x1020C402AEDCB0CLL);
        }
      }
      ++v5;
    }
    while (v5 < *((int *)this + 22));
  }
  uint64_t v7 = (void *)*((void *)this + 10);
  if (v7) {
    free(v7);
  }
  if (*((_DWORD *)this + 14))
  {
    uint64_t v8 = *((void *)this + 6);
    if (v8) {
      HGFree(v8);
    }
  }
  *((_DWORD *)this + 4) |= 0x80000000;
  uint64_t v9 = *((void *)this + 50);
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
  }
  uint64_t v10 = (void *)*((void *)this + 37);
  if (v10)
  {
    *((void *)this + 38) = v10;
    operator delete(v10);
  }
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 112, *((void **)this + 15));

  HGObject::~HGObject((HGObject *)this);
}

{
  void *v1;
  uint64_t vars8;

  HGNode::~HGNode(this);

  HGObject::operator delete(v1);
}

uint64_t HGNode::dotLabel(HGNode *this)
{
  return 0;
}

uint64_t HGNode::label_A(HGNode *this)
{
  if (!this) {
    __cxa_bad_typeid();
  }
  uint64_t result = (*(void *)(*(void *)(*(void *)this - 8) + 8) & 0x7FFFFFFFFFFFFFFFLL) - 1;
  do
    int v2 = *(unsigned __int8 *)++result;
  while ((v2 - 48) < 0xA);
  return result;
}

uint64_t HGNode::label_B(HGNode *this)
{
  return 0;
}

void HGNode::info(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

uint64_t HGNode::debugDescription(HGNode *this)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v23);
  HGObject::debugDescription(&__p);
  if ((v22 & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  if ((v22 & 0x80u) == 0) {
    uint64_t v3 = v22;
  }
  else {
    uint64_t v3 = v21;
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)p_p, v3);
  if ((char)v22 < 0) {
    operator delete(__p);
  }
  uint64_t v4 = (const char *)(*(uint64_t (**)(HGNode *))(*(void *)this + 48))(this);
  size_t v5 = strlen(v4);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)v4, v5);
  uint64_t v6 = (const char *)(*(uint64_t (**)(HGNode *))(*(void *)this + 56))(this);
  if (v6)
  {
    uint64_t v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)", ", 2);
    size_t v8 = strlen(v6);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)v6, v8);
  }
  char v19 = 0;
  LOBYTE(v18.__locale_) = 0;
  char v17 = 0;
  LOBYTE(v16) = 0;
  (*(void (**)(void **__return_ptr, HGNode *, uint64_t, std::locale *, void **))(*(void *)this + 64))(&__p, this, 3, &v18, &v16);
  if (v17 < 0)
  {
    operator delete(v16);
    if ((v19 & 0x80000000) == 0)
    {
LABEL_13:
      uint64_t v9 = v22;
      if ((v22 & 0x80u) != 0) {
        uint64_t v9 = v21;
      }
      if (!v9) {
        goto LABEL_28;
      }
LABEL_21:
      std::ios_base::getloc((const std::ios_base *)((char *)v24 + *(void *)(v24[0] - 24)));
      BOOL v11 = std::locale::use_facet(&v18, MEMORY[0x1E4FBA258]);
      ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
      std::locale::~locale(&v18);
      std::ostream::put();
      std::ostream::flush();
      if ((v22 & 0x80u) == 0) {
        unint64_t v12 = &__p;
      }
      else {
        unint64_t v12 = __p;
      }
      if ((v22 & 0x80u) == 0) {
        uint64_t v13 = v22;
      }
      else {
        uint64_t v13 = v21;
      }
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)v12, v13);
      goto LABEL_28;
    }
  }
  else if ((v19 & 0x80000000) == 0)
  {
    goto LABEL_13;
  }
  operator delete(v18.__locale_);
  uint64_t v10 = v22;
  if ((v22 & 0x80u) != 0) {
    uint64_t v10 = v21;
  }
  if (v10) {
    goto LABEL_21;
  }
LABEL_28:
  std::stringbuf::str();
  if ((char)v22 < 0) {
    operator delete(__p);
  }
  v23[0] = *MEMORY[0x1E4FBA408];
  uint64_t v14 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v23 + *(void *)(v23[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  v24[0] = v14;
  v24[1] = MEMORY[0x1E4FBA470] + 16;
  if (v25 < 0) {
    operator delete((void *)v24[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BA9BFAB0](&v26);
}

void sub_1B778ECA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::locale a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15.__locale_);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a27);
  _Unwind_Resume(a1);
}

uint64_t HGNode::shaderDescription(HGNode *this)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v22);
  HGObject::HGObject((HGObject *)v6);
  v6[0] = &unk_1F10D55B0;
  memset(&v16[32], 0, 32);
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  memset(v16, 0, 28);
  long long v20 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  int v17 = 1;
  int v21 = 0;
  (*(void (**)(HGNode *, void *))(*(void *)this + 328))(this, v6);
  FragmentFunctionName = HGProgramDescriptor::GetFragmentFunctionName((HGProgramDescriptor *)v6);
  size_t v3 = strlen(FragmentFunctionName);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)FragmentFunctionName, v3);
  std::stringbuf::str();
  HGProgramDescriptor::~HGProgramDescriptor((HGProgramDescriptor *)v6);
  v22[0] = *MEMORY[0x1E4FBA408];
  uint64_t v4 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v22 + *(void *)(v22[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  v23[0] = v4;
  v23[1] = MEMORY[0x1E4FBA470] + 16;
  if (v24 < 0) {
    operator delete((void *)v23[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BA9BFAB0](&v25);
}

void sub_1B778EF6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
}

void sub_1B778EF80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
}

uint64_t HGNode::SetInput(HGNode *this, unsigned int a2, HGNode *a3)
{
  if ((a2 & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  if (*((_DWORD *)this + 22) > (signed int)a2)
  {
    uint64_t v6 = a2;
    unint64_t v7 = *(void *)(*((void *)this + 10) + 8 * a2);
    if (v7) {
      goto LABEL_4;
    }
LABEL_25:
    operator new();
  }
  uint64_t v18 = (a2 & 0xFFFFFFF8) + 8;
  long long v19 = (void *)*((void *)this + 10);
  if (v19)
  {
    *((void *)this + 10) = malloc_type_realloc(v19, 8 * v18, 0x2004093837F09uLL);
    uint64_t v20 = *((int *)this + 22);
    if ((int)v20 >= (int)v18) {
      goto LABEL_24;
    }
  }
  else
  {
    *((void *)this + 10) = malloc_type_malloc(8 * ((a2 & 0xFFFFFFF8) + 8), 0x2004093837F09uLL);
    uint64_t v20 = *((int *)this + 22);
    if ((int)v20 >= (int)v18) {
      goto LABEL_24;
    }
  }
  do
    *(void *)(*((void *)this + 10) + 8 * v20++) = 0;
  while (v18 != v20);
LABEL_24:
  *((_DWORD *)this + 22) = v18;
  uint64_t v6 = a2;
  unint64_t v7 = *(void *)(*((void *)this + 10) + 8 * a2);
  if (!v7) {
    goto LABEL_25;
  }
LABEL_4:
  uint64_t v8 = *(void *)(v7 + 16);
  if ((HGNode *)v8 == a3) {
    return 0;
  }
  if (v8)
  {
    long long v9 = *(uint64_t **)(v8 + 120);
    if (v9)
    {
      long long v10 = (uint64_t *)(v8 + 120);
      long long v11 = *(void **)(v8 + 120);
      do
      {
        unint64_t v12 = v11[4];
        BOOL v13 = v12 >= v7;
        if (v12 >= v7) {
          long long v14 = v11;
        }
        else {
          long long v14 = v11 + 1;
        }
        if (v13) {
          long long v10 = v11;
        }
        long long v11 = (void *)*v14;
      }
      while (*v14);
      if (v10 != (uint64_t *)(v8 + 120) && v7 >= v10[4])
      {
        long long v15 = (uint64_t *)v10[1];
        if (v15)
        {
          do
          {
            uint64_t v16 = v15;
            long long v15 = (uint64_t *)*v15;
          }
          while (v15);
        }
        else
        {
          int v21 = v10;
          do
          {
            uint64_t v16 = (uint64_t *)v21[2];
            BOOL v22 = *v16 == (void)v21;
            int v21 = v16;
          }
          while (!v22);
        }
        if (*(uint64_t **)(v8 + 112) == v10) {
          *(void *)(v8 + 112) = v16;
        }
        --*(void *)(v8 + 128);
        std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v9, v10);
        operator delete(v10);
        uint64_t v8 = *(void *)(*(void *)(*((void *)this + 10) + 8 * v6) + 16);
      }
    }
    (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
    unint64_t v7 = *(void *)(*((void *)this + 10) + 8 * v6);
  }
  *(void *)(v7 + 16) = a3;
  if (a3)
  {
    (*(void (**)(HGNode *))(*(void *)a3 + 16))(a3);
    char v24 = (uint64_t **)((char *)a3 + 120);
    uint64_t v23 = (uint64_t *)*((void *)a3 + 15);
    unint64_t v25 = *(void *)(*((void *)this + 10) + 8 * v6);
    if (v23)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v26 = (uint64_t **)v23;
          unint64_t v27 = v23[4];
          if (v25 >= v27) {
            break;
          }
          uint64_t v23 = *v26;
          char v24 = v26;
          if (!*v26) {
            goto LABEL_44;
          }
        }
        if (v27 >= v25) {
          break;
        }
        uint64_t v23 = v26[1];
        if (!v23)
        {
          char v24 = v26 + 1;
          goto LABEL_44;
        }
      }
    }
    else
    {
      uint64_t v26 = (uint64_t **)((char *)a3 + 120);
LABEL_44:
      uint64_t v28 = (uint64_t *)operator new(0x28uLL);
      v28[4] = v25;
      *uint64_t v28 = 0;
      v28[1] = 0;
      v28[2] = (uint64_t)v26;
      *char v24 = v28;
      uint64_t v29 = **((void **)a3 + 14);
      if (v29)
      {
        *((void *)a3 + 14) = v29;
        uint64_t v30 = *v24;
      }
      else
      {
        uint64_t v30 = v28;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)a3 + 15), v30);
      ++*((void *)a3 + 16);
    }
  }
  HGNode::ClearBits(this, (const char *)0xFFFF, (char *)a3);
  return 1;
}

HGNode *HGNode::ClearBits(HGNode *this, uint64_t a2, char *a3)
{
  return HGNode::ClearBits(this, (const char *)0xFFFF, a3);
}

uint64_t HGNode::GetNumInputs(HGNode *this)
{
  return *((unsigned int *)this + 22);
}

uint64_t HGNode::GetInput(HGNode *this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    return 0;
  }
  if (*((_DWORD *)this + 22) <= (signed int)a2) {
    return 0;
  }
  uint64_t v2 = *(void *)(*((void *)this + 10) + 8 * a2);
  if (!v2) {
    return 0;
  }
  else {
    return *(void *)(v2 + 16);
  }
}

uint64_t HGNode::SetFlags(HGNode *this, uint64_t a2, int a3)
{
  if ((a3 & 0x80) != 0)
  {
    uint64_t v10 = *((unsigned int *)this + 4);
    int v11 = *((_DWORD *)this + 4);
    if (a3 != 128)
    {
      (*(void (**)(HGNode *, uint64_t, void))(*(void *)this + 136))(this, a2, a3 & 0xFFFFFF7F);
      int v11 = *((_DWORD *)this + 4);
    }
    *((_DWORD *)this + 4) = v11 | 0x94;
    return v10;
  }
  else if ((a2 & 0x80000000) != 0)
  {
    uint64_t v12 = *((unsigned int *)this + 4);
    *((_DWORD *)this + 4) = v12 | a3;
    return v12;
  }
  else
  {
    uint64_t v5 = *((void *)this + 10);
    uint64_t v6 = a2;
    if (!v5 || (uint64_t v7 = *(void *)(v5 + 8 * a2)) == 0)
    {
      (*(void (**)(HGNode *))(*(void *)this + 120))(this);
      uint64_t v7 = *(void *)(*((void *)this + 10) + 8 * v6);
    }
    uint64_t v8 = *(unsigned int *)(v7 + 12);
    *(_DWORD *)(v7 + 12) = v8 | a3;
    return v8;
  }
}

uint64_t HGNode::ClearFlags(HGNode *this, uint64_t a2, int a3)
{
  if ((a3 & 0x80) != 0)
  {
    uint64_t v10 = *((unsigned int *)this + 4);
    int v11 = *((_DWORD *)this + 4);
    if (a3 != 128)
    {
      (*(void (**)(HGNode *, uint64_t, void))(*(void *)this + 144))(this, a2, a3 & 0xFFFFFF7F);
      int v11 = *((_DWORD *)this + 4);
    }
    *((_DWORD *)this + 4) = v11 & 0xFFFFFF7F;
    return v10;
  }
  else if ((a2 & 0x80000000) != 0)
  {
    uint64_t v12 = *((unsigned int *)this + 4);
    *((_DWORD *)this + 4) = v12 & ~a3;
    return v12;
  }
  else
  {
    uint64_t v5 = *((void *)this + 10);
    uint64_t v6 = a2;
    if (!v5 || (uint64_t v7 = *(void *)(v5 + 8 * a2)) == 0)
    {
      (*(void (**)(HGNode *))(*(void *)this + 120))(this);
      uint64_t v7 = *(void *)(*((void *)this + 10) + 8 * v6);
    }
    uint64_t v8 = *(unsigned int *)(v7 + 12);
    *(_DWORD *)(v7 + 12) = v8 & ~a3;
    return v8;
  }
}

uint64_t HGNode::GetFlags(HGNode *this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    return *((unsigned int *)this + 4);
  }
  if (*((_DWORD *)this + 22) > (signed int)a2)
  {
    uint64_t v2 = *(void *)(*((void *)this + 10) + 8 * a2);
    if (v2) {
      return *(unsigned int *)(v2 + 12);
    }
  }
  return 0;
}

uint64_t HGNode::GetParameterCount(HGNode *this)
{
  return *((unsigned int *)this + 11);
}

char *HGNode::GetParameterName(HGNode *this, int a2)
{
  int v3 = (*(uint64_t (**)(HGNode *))(*(void *)this + 80))(this);
  uint64_t v4 = (char *)&unk_1B8345BFC;
  if (a2 < 9) {
    uint64_t v4 = (char *)&HGNode::GetParameterName(int)::names + 4 * a2;
  }
  if (v3 <= a2) {
    return 0;
  }
  else {
    return v4;
  }
}

uint64_t HGNode::SetParameter(HGNode *this, int a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 < 0) {
    return 0xFFFFFFFFLL;
  }
  int v13 = *((_DWORD *)this + 14);
  if (v13 < 2)
  {
    if (*((_DWORD *)this + 11) <= a2) {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    unsigned int v14 = (a2 & 0xFFFFFFFC) + 4;
    if (v14 > v13)
    {
      long long v15 = (const void *)*((void *)this + 6);
      if (v15) {
        int v16 = v13;
      }
      else {
        int v16 = 0;
      }
      int v17 = (char *)HGRealloc(v15, (int)(16 * v14));
      *((void *)this + 6) = v17;
      bzero(&v17[16 * v16], 16 * (v14 - v16));
      *((_DWORD *)this + 14) = v14;
    }
    if (*((_DWORD *)this + 11) <= a2) {
      *((_DWORD *)this + 11) = a2 + 1;
    }
  }
  long long v19 = (float *)(*((void *)this + 6) + 16 * a2);
  if (*v19 == a3 && v19[1] == a4 && v19[2] == a5 && v19[3] == a6) {
    return 0;
  }
  *long long v19 = a3;
  v19[1] = a4;
  v19[2] = a5;
  v19[3] = a6;
  HGNode::ClearBits(this, (const char *)0xFFFF, a7);
  return 1;
}

uint64_t HGNode::GetParameter(HGNode *this, int a2, float *a3)
{
  if (a2 < 0 || *((_DWORD *)this + 11) <= a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 6) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

void HGNode::WriteDotGraph(uint64_t a1, uint64_t a2, int a3)
{
  HGDotGraph::HGDotGraph((HGDotGraph *)v298);
  PCImage::setIsPremultiplied(v6, 1);
  HGDotGraph::footnode((uint64_t)v298, 0);
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v7 = (const char *)a2;
  }
  else {
    uint64_t v7 = *(const char **)a2;
  }
  HGDotGraph::begin((HGDotGraph *)v298, v7);
  if (a3 == 2)
  {
    long long v293 = 0u;
    long long v294 = 0u;
    long long v292 = 0u;
    long long v289 = 0u;
    long long v290 = 0u;
    int v291 = 1065353216;
    unsigned __int8 v66 = (char *)operator new(8uLL);
    *(void *)unsigned __int8 v66 = a1;
    uint64_t v67 = v66 + 8;
    __n128 v296 = v66 + 8;
    __n128 v297 = v66 + 8;
    __n128 v295 = v66;
    while (1)
    {
      v276.__locale_ = 0;
      v276.__locale_ = (std::locale::__imp *)*((void *)v67 - 1);
      __n128 v296 = v67 - 8;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&v276;
      if (!*((unsigned char *)std::__hash_table<std::__hash_value_type<HGNode const*,BOOL>,std::__unordered_map_hasher<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::hash<HGNode const*>,std::equal_to<HGNode const*>,true>,std::__unordered_map_equal<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::equal_to<HGNode const*>,std::hash<HGNode const*>,true>,std::allocator<std::__hash_value_type<HGNode const*,BOOL>>>::__emplace_unique_key_args<HGNode const*,std::piecewise_construct_t const&,std::tuple<HGNode const* const&>,std::tuple<>>((uint64_t)&v289, (uint64_t *)&v276, (uint64_t)&std::piecewise_construct, &__dst)+ 24))break; {
LABEL_102:
      }
      uint64_t v67 = v296;
      if (v295 == v296)
      {
        long long v120 = (void *)(*((void *)&v292 + 1) + 8 * ((unint64_t)v294 >> 9));
        if ((void)v293 == *((void *)&v292 + 1))
        {
          long long v121 = 0;
          long long v123 = 0;
          long long v122 = (void *)(*((void *)&v292 + 1) + 8 * ((*((void *)&v294 + 1) + (void)v294) >> 9));
        }
        else
        {
          long long v121 = (unint64_t *)(*v120 + 8 * (v294 & 0x1FF));
          long long v122 = (void *)(*((void *)&v292 + 1) + 8 * ((*((void *)&v294 + 1) + (void)v294) >> 9));
          long long v123 = (unint64_t *)(*v122 + 8 * ((*((void *)&v294 + 1) + v294) & 0x1FF));
        }
        uint64_t v203 = (char *)hgstd::stable_unique<std::__deque_iterator<HGNode const*,HGNode const**,HGNode const*&,HGNode const***,long,512l>>(v120, v121, (uint64_t)v122, v123);
        __n128 v205 = (char *)(*((void *)&v292 + 1) + 8 * ((unint64_t)v294 >> 9));
        if ((void)v293 == *((void *)&v292 + 1))
        {
          uint64_t v206 = 0;
          if (!v204) {
            goto LABEL_286;
          }
LABEL_284:
          unint64_t v207 = ((v204 - *(void *)v203) >> 3) + ((v203 - v205) << 6) - ((v206 - *(void *)v205) >> 3);
        }
        else
        {
          uint64_t v206 = *(void *)v205 + 8 * (v294 & 0x1FF);
          if (v204 != v206) {
            goto LABEL_284;
          }
LABEL_286:
          unint64_t v207 = 0;
        }
        std::deque<HGNode const*>::resize(&v292, v207);
        uint64_t v208 = *((void *)&v292 + 1);
        uint64_t v209 = v293;
        __n128 v210 = (void *)(*((void *)&v292 + 1) + 8 * ((unint64_t)v294 >> 9));
        if ((void)v293 == *((void *)&v292 + 1)) {
          __n128 v211 = 0;
        }
        else {
          __n128 v211 = (unint64_t *)(*v210 + 8 * (v294 & 0x1FF));
        }
        __n128 v263 = *(std::locale::__imp **)(MEMORY[0x1E4FBA408] + 16);
        long long v261 = *(std::locale::__imp **)(MEMORY[0x1E4FBA408] + 24);
        uint64_t v259 = *(void *)(MEMORY[0x1E4FBA408] + 32);
        uint64_t v257 = *(void *)(MEMORY[0x1E4FBA408] + 40);
        long long v255 = *(std::locale::__imp **)(MEMORY[0x1E4FBA408] + 48);
        __n128 v253 = *(std::locale::__imp **)(MEMORY[0x1E4FBA408] + 8);
        __n128 v272 = (std::locale::__imp *)*MEMORY[0x1E4FBA408];
        __n128 v269 = *(std::locale::__imp **)(MEMORY[0x1E4FBA408] + 64);
        std::string::size_type v266 = *(void *)(MEMORY[0x1E4FBA408] + 72);
        while (2)
        {
          if (v209 == v208)
          {
            if (!v211)
            {
LABEL_336:
              __n128 v236 = (void *)v290;
              if ((void)v290)
              {
                do
                {
                  __n128 v237 = (void *)*v236;
                  operator delete(v236);
                  __n128 v236 = v237;
                }
                while (v237);
              }
              __n128 v238 = (void *)v289;
              *(void *)&long long v289 = 0;
              if (v238) {
                operator delete(v238);
              }
              __n128 v239 = (void **)*((void *)&v292 + 1);
              __n128 v240 = (void **)v293;
              *((void *)&v294 + 1) = 0;
              unint64_t v241 = v293 - *((void *)&v292 + 1);
              if ((void)v293 - *((void *)&v292 + 1) >= 0x11uLL)
              {
                do
                {
                  operator delete(*v239);
                  __n128 v240 = (void **)v293;
                  __n128 v239 = (void **)(*((void *)&v292 + 1) + 8);
                  *((void *)&v292 + 1) = v239;
                  unint64_t v241 = v293 - (void)v239;
                }
                while ((void)v293 - (void)v239 > 0x10uLL);
              }
              unint64_t v242 = v241 >> 3;
              if (v242 == 1)
              {
                uint64_t v243 = 256;
LABEL_366:
                *(void *)&long long v294 = v243;
              }
              else if (v242 == 2)
              {
                uint64_t v243 = 512;
                goto LABEL_366;
              }
              if (v239 != v240)
              {
                do
                {
                  long long v247 = *v239++;
                  operator delete(v247);
                }
                while (v239 != v240);
                if ((void)v293 != *((void *)&v292 + 1)) {
                  *(void *)&long long v293 = v293 + ((*((void *)&v292 + 1) - v293 + 7) & 0xFFFFFFFFFFFFFFF8);
                }
              }
              if ((void)v292) {
                operator delete((void *)v292);
              }
              long long v245 = v295;
              if (!v295) {
                goto LABEL_376;
              }
              __n128 v296 = v295;
              goto LABEL_375;
            }
          }
          else if (v211 == (unint64_t *)(*(void *)(v208 {
                                                           + (((*((void *)&v294 + 1) + (void)v294) >> 6) & 0x3FFFFFFFFFFFFF8))
          }
                                               + 8 * ((*((void *)&v294 + 1) + v294) & 0x1FF)))
          {
            goto LABEL_336;
          }
          unint64_t v212 = *v211;
          std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&__dst);
          __n128 v213 = (const char *)(*(uint64_t (**)(unint64_t))(*(void *)v212 + 48))(v212);
          size_t v214 = strlen(v213);
          __n128 v215 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__dst.__r_.__value_.__r.__words[2], (uint64_t)v213, v214);
          std::ios_base::getloc((const std::ios_base *)((char *)v215 + *(void *)(*v215 - 24)));
          __n128 v216 = std::locale::use_facet(&v276, MEMORY[0x1E4FBA258]);
          ((void (*)(const std::locale::facet *, uint64_t))v216->__vftable[2].~facet_0)(v216, 10);
          std::locale::~locale(&v276);
          std::ostream::put();
          std::ostream::flush();
          *(_DWORD *)((char *)v285 + *(void *)(__dst.__r_.__value_.__r.__words[2] - 24)) = *(_DWORD *)((unsigned char *)v285 + *(void *)(__dst.__r_.__value_.__r.__words[2] - 24)) & 0xFFFFFFB5 | 8;
          __n128 v217 = (void *)std::ostream::operator<<();
          *(_DWORD *)((char *)v217 + *(void *)(*v217 - 24) + 8) = *(_DWORD *)((unsigned char *)v217
                                                                                + *(void *)(*v217 - 24)
                                                                                + 8) & 0xFFFFFFB5 | 2;
          std::stringbuf::str();
          if (v278 >= 0) {
            locale = &v276;
          }
          else {
            locale = v276.__locale_;
          }
          HGDotGraph::node((uint64_t *)v298, v212, (uint64_t)locale, 0);
          if (SHIBYTE(v278) < 0)
          {
            operator delete(v276.__locale_);
            int v219 = *(_DWORD *)(v212 + 88);
            if (v219 < 1)
            {
LABEL_307:
              if (*(void *)(v212 + 128))
              {
                __n128 v222 = *(void **)(v212 + 112);
                HGDotGraph::beginRank((uint64_t)v298);
                if (v222 != (void *)(v212 + 120))
                {
                  do
                  {
                    HGDotGraph::link((uint64_t *)v298, v212, v222[4], 0, 0);
                    HGDotGraph::rank(v298, (const void *)v222[4]);
                    long long v226 = (void *)v222[1];
                    if (v226)
                    {
                      do
                      {
                        __n128 v227 = v226;
                        long long v226 = (void *)*v226;
                      }
                      while (v226);
                    }
                    else
                    {
                      do
                      {
                        __n128 v227 = (void *)v222[2];
                        BOOL v228 = *v227 == (void)v222;
                        __n128 v222 = v227;
                      }
                      while (!v228);
                    }
                    __n128 v222 = v227;
                  }
                  while (v227 != (void *)(v212 + 120));
                }
                HGDotGraph::endRank((uint64_t)v298);
              }
              unint64_t v223 = *(void *)(v212 + 144);
              if (v223)
              {
                HGDotGraph::link((uint64_t *)v298, v223, v212, 0, 1);
                HGDotGraph::linkStyle((uint64_t *)v298, *(uint64_t **)(v212 + 144), (uint64_t *)v212, 1, 1);
                HGDotGraph::filled((uint64_t)v298, *(void *)(v212 + 144), 0);
              }
              long long v251 = v211;
              long long v252 = v210;
              int v224 = *(_DWORD *)(v212 + 88);
              if (v224 >= 1)
              {
                for (uint64_t i = 0; i < v224; ++i)
                {
                  unint64_t v229 = *(void *)(*(void *)(v212 + 80) + 8 * i);
                  if (v229 && *(void *)(v229 + 16))
                  {
                    uint64_t v230 = MEMORY[0x1E4FBA488] + 104;
                    v283[0] = MEMORY[0x1E4FBA488] + 104;
                    uint64_t v231 = MEMORY[0x1E4FBA488] + 64;
                    uint64_t v278 = MEMORY[0x1E4FBA488] + 64;
                    v276.__locale_ = v263;
                    *(std::locale::__imp **)((char *)&v276.__locale_ + *((void *)v263 - 3)) = v261;
                    uint64_t v277 = 0;
                    __n128 v232 = (std::ios_base *)((char *)&v276 + *((void *)v276.__locale_ - 3));
                    std::ios_base::init(v232, v279);
                    __n128 v233 = (std::locale::__imp *)(MEMORY[0x1E4FBA488] + 24);
                    v232[1].__vftable = 0;
                    v232[1].__fmtflags_ = -1;
                    uint64_t v278 = v259;
                    *(void *)((char *)&v279[-1] + *(void *)(v259 - 24)) = v257;
                    v276.__locale_ = v253;
                    *(std::locale::__imp **)((char *)&v276.__locale_ + *((void *)v253 - 3)) = v255;
                    v283[0] = v230;
                    v276.__locale_ = v233;
                    uint64_t v278 = v231;
                    std::streambuf::basic_streambuf();
                    uint64_t v234 = MEMORY[0x1E4FBA470] + 16;
                    v279[0] = MEMORY[0x1E4FBA470] + 16;
                    long long v280 = 0u;
                    long long v281 = 0u;
                    int v282 = 24;
                    std::ostream::operator<<();
                    std::stringbuf::str();
                    if (v275 >= 0) {
                      __n128 v235 = __p;
                    }
                    else {
                      __n128 v235 = (void **)__p[0];
                    }
                    HGDotGraph::link((uint64_t *)v298, v229, v212, (const char *)v235, 0);
                    if (v275 < 0) {
                      operator delete(__p[0]);
                    }
                    v276.__locale_ = v272;
                    *(std::locale::__imp **)((char *)&v276.__locale_ + *((void *)v272 - 3)) = v269;
                    uint64_t v278 = v266;
                    v279[0] = v234;
                    if (SBYTE7(v281) < 0) {
                      operator delete((void *)v280);
                    }
                    std::streambuf::~streambuf();
                    std::iostream::~basic_iostream();
                    MEMORY[0x1BA9BFAB0](v283);
                    int v224 = *(_DWORD *)(v212 + 88);
                  }
                }
              }
              __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v272;
              *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + *((void *)v272 - 3)) = (std::string::size_type)v269;
              __dst.__r_.__value_.__r.__words[2] = v266;
              v285[0] = MEMORY[0x1E4FBA470] + 16;
              if (v287 < 0) {
                operator delete(v286);
              }
              std::streambuf::~streambuf();
              std::iostream::~basic_iostream();
              MEMORY[0x1BA9BFAB0](v288);
              __n128 v210 = v252;
              __n128 v211 = v251 + 1;
              if ((unint64_t *)((char *)v251 - *v252 + 8) == (unint64_t *)4096)
              {
                __n128 v210 = v252 + 1;
                __n128 v211 = (unint64_t *)v252[1];
              }
              uint64_t v208 = *((void *)&v292 + 1);
              uint64_t v209 = v293;
              continue;
            }
          }
          else
          {
            int v219 = *(_DWORD *)(v212 + 88);
            if (v219 < 1) {
              goto LABEL_307;
            }
          }
          break;
        }
        for (uint64_t j = 0; j < v219; ++j)
        {
          unint64_t v221 = *(void *)(*(void *)(v212 + 80) + 8 * j);
          if (v221)
          {
            HGDotGraph::node((uint64_t *)v298, v221, 0, 3);
            int v219 = *(_DWORD *)(v212 + 88);
          }
        }
        goto LABEL_307;
      }
    }
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&v276;
    *((unsigned char *)std::__hash_table<std::__hash_value_type<HGNode const*,BOOL>,std::__unordered_map_hasher<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::hash<HGNode const*>,std::equal_to<HGNode const*>,true>,std::__unordered_map_equal<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::equal_to<HGNode const*>,std::hash<HGNode const*>,true>,std::allocator<std::__hash_value_type<HGNode const*,BOOL>>>::__emplace_unique_key_args<HGNode const*,std::piecewise_construct_t const&,std::tuple<HGNode const* const&>,std::tuple<>>((uint64_t)&v289, (uint64_t *)&v276, (uint64_t)&std::piecewise_construct, &__dst)+ 24) = 1;
    unint64_t v68 = v294;
    if (!(void)v294)
    {
      std::deque<HGNode const*>::__add_front_capacity((uint64_t)&v292);
      unint64_t v68 = v294;
    }
    uint64_t v69 = (void *)(*((void *)&v292 + 1) + 8 * (v68 >> 9));
    if ((void)v293 == *((void *)&v292 + 1)) {
      uint64_t v70 = 0;
    }
    else {
      uint64_t v70 = *v69 + 8 * (v68 & 0x1FF);
    }
    if (v70 == *v69) {
      uint64_t v70 = *(v69 - 1) + 4096;
    }
    *(std::locale *)(v70 - 8) = v276;
    *(void *)&long long v294 = v68 - 1;
    ++*((void *)&v294 + 1);
    uint64_t v71 = v276.__locale_;
    uint64_t v72 = (std::locale::__imp *)*((void *)v276.__locale_ + 18);
    if (!v72 || v72 == v276.__locale_)
    {
LABEL_136:
      if (*((int *)v71 + 22) >= 1)
      {
        uint64_t v91 = 0;
        while (2)
        {
          uint64_t v93 = *(void *)(*((void *)v71 + 10) + 8 * v91);
          if (!v93) {
            goto LABEL_140;
          }
          uint64_t v94 = *(void *)(v93 + 16);
          if (!v94) {
            goto LABEL_140;
          }
          long long v95 = v296;
          if (v296 >= v297)
          {
            long long v96 = v295;
            uint64_t v97 = (v296 - v295) >> 3;
            unint64_t v98 = v97 + 1;
            if ((unint64_t)(v97 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v99 = v297 - v295;
            if ((v297 - v295) >> 2 > v98) {
              unint64_t v98 = v99 >> 2;
            }
            if ((unint64_t)v99 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v100 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v100 = v98;
            }
            if (v100)
            {
              if (v100 >> 61) {
                std::__throw_bad_array_new_length[abi:ne180100]();
              }
              long long v101 = (char *)operator new(8 * v100);
              long long v102 = &v101[8 * v97];
              *(void *)long long v102 = *(void *)(v93 + 16);
              uint64_t v92 = (uint64_t)(v102 + 8);
              if (v95 == v96)
              {
LABEL_162:
                __n128 v295 = v102;
                __n128 v296 = (char *)v92;
                __n128 v297 = &v101[8 * v100];
                if (v95) {
                  operator delete(v95);
                }
LABEL_139:
                __n128 v296 = (char *)v92;
                uint64_t v71 = v276.__locale_;
LABEL_140:
                if (++v91 >= *((int *)v71 + 22)) {
                  goto LABEL_102;
                }
                continue;
              }
            }
            else
            {
              long long v101 = 0;
              long long v102 = (char *)(8 * v97);
              *(void *)(8 * v97) = v94;
              uint64_t v92 = 8 * v97 + 8;
              if (v95 == v96) {
                goto LABEL_162;
              }
            }
            unint64_t v103 = v95 - 8 - v96;
            if (v103 < 0x58) {
              goto LABEL_388;
            }
            if ((unint64_t)(v96 - v101) < 0x20) {
              goto LABEL_388;
            }
            uint64_t v104 = (v103 >> 3) + 1;
            uint64_t v105 = 8 * (v104 & 0x3FFFFFFFFFFFFFFCLL);
            long long v106 = &v95[-v105];
            v102 -= v105;
            long long v107 = &v101[8 * v97 - 16];
            long long v108 = v95 - 16;
            uint64_t v109 = v104 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v110 = *(_OWORD *)v108;
              *((_OWORD *)v107 - 1) = *((_OWORD *)v108 - 1);
              *(_OWORD *)long long v107 = v110;
              v107 -= 32;
              v108 -= 32;
              v109 -= 4;
            }
            while (v109);
            long long v95 = v106;
            if (v104 != (v104 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_388:
              do
              {
                uint64_t v111 = *((void *)v95 - 1);
                v95 -= 8;
                *((void *)v102 - 1) = v111;
                v102 -= 8;
              }
              while (v95 != v96);
            }
            long long v95 = v295;
            goto LABEL_162;
          }
          break;
        }
        *(void *)__n128 v296 = v94;
        uint64_t v92 = (uint64_t)(v95 + 8);
        goto LABEL_139;
      }
      goto LABEL_102;
    }
    int32x4_t v73 = v296;
    if (v296 < v297)
    {
      *(void *)__n128 v296 = v72;
      uint64_t v74 = (uint64_t)(v73 + 8);
LABEL_135:
      __n128 v296 = (char *)v74;
      uint64_t v71 = v276.__locale_;
      goto LABEL_136;
    }
    unsigned __int8 v75 = v295;
    uint64_t v76 = (v296 - v295) >> 3;
    unint64_t v77 = v76 + 1;
    if ((unint64_t)(v76 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v78 = v297 - v295;
    if ((v297 - v295) >> 2 > v77) {
      unint64_t v77 = v78 >> 2;
    }
    if ((unint64_t)v78 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v79 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v79 = v77;
    }
    if (v79)
    {
      if (v79 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v80 = (char *)operator new(8 * v79);
      uint64_t v81 = &v80[8 * v76];
      *(void *)uint64_t v81 = *((void *)v71 + 18);
      uint64_t v74 = (uint64_t)(v81 + 8);
      if (v73 == v75) {
        goto LABEL_133;
      }
    }
    else
    {
      uint64_t v80 = 0;
      uint64_t v81 = (char *)(8 * v76);
      *(void *)(8 * v76) = v72;
      uint64_t v74 = 8 * v76 + 8;
      if (v73 == v75)
      {
LABEL_133:
        __n128 v295 = v81;
        __n128 v296 = (char *)v74;
        __n128 v297 = &v80[8 * v79];
        if (v73) {
          operator delete(v73);
        }
        goto LABEL_135;
      }
    }
    unint64_t v82 = v73 - 8 - v75;
    if (v82 < 0x58) {
      goto LABEL_389;
    }
    if ((unint64_t)(v75 - v80) < 0x20) {
      goto LABEL_389;
    }
    uint64_t v83 = (v82 >> 3) + 1;
    uint64_t v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v85 = &v73[-v84];
    v81 -= v84;
    uint64_t v86 = &v80[8 * v76 - 16];
    uint64_t v87 = v73 - 16;
    uint64_t v88 = v83 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v89 = *(_OWORD *)v87;
      *((_OWORD *)v86 - 1) = *((_OWORD *)v87 - 1);
      *(_OWORD *)uint64_t v86 = v89;
      v86 -= 32;
      v87 -= 32;
      v88 -= 4;
    }
    while (v88);
    int32x4_t v73 = v85;
    if (v83 != (v83 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_389:
      do
      {
        uint64_t v90 = *((void *)v73 - 1);
        v73 -= 8;
        *((void *)v81 - 1) = v90;
        v81 -= 8;
      }
      while (v73 != v75);
    }
    int32x4_t v73 = v295;
    goto LABEL_133;
  }
  if (a3 == 1)
  {
    __n128 v296 = 0;
    long long v293 = 0u;
    long long v294 = 0u;
    long long v292 = 0u;
    long long v289 = 0u;
    long long v290 = 0u;
    int v291 = 1065353216;
    long long v38 = (char *)operator new(8uLL);
    *(void *)long long v38 = a1;
    size_t v39 = v38 + 8;
    __n128 v295 = v38;
    __n128 v297 = v38 + 8;
    while (1)
    {
      v276.__locale_ = 0;
      uint64_t v40 = (std::locale::__imp *)*((void *)v39 - 1);
      v39 -= 8;
      v276.__locale_ = v40;
      __n128 v296 = v39;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&v276;
      if (!*((unsigned char *)std::__hash_table<std::__hash_value_type<HGNode const*,BOOL>,std::__unordered_map_hasher<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::hash<HGNode const*>,std::equal_to<HGNode const*>,true>,std::__unordered_map_equal<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::equal_to<HGNode const*>,std::hash<HGNode const*>,true>,std::allocator<std::__hash_value_type<HGNode const*,BOOL>>>::__emplace_unique_key_args<HGNode const*,std::piecewise_construct_t const&,std::tuple<HGNode const* const&>,std::tuple<>>((uint64_t)&v289, (uint64_t *)&v276, (uint64_t)&std::piecewise_construct, &__dst)+ 24))
      {
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&v276;
        *((unsigned char *)std::__hash_table<std::__hash_value_type<HGNode const*,BOOL>,std::__unordered_map_hasher<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::hash<HGNode const*>,std::equal_to<HGNode const*>,true>,std::__unordered_map_equal<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::equal_to<HGNode const*>,std::hash<HGNode const*>,true>,std::allocator<std::__hash_value_type<HGNode const*,BOOL>>>::__emplace_unique_key_args<HGNode const*,std::piecewise_construct_t const&,std::tuple<HGNode const* const&>,std::tuple<>>((uint64_t)&v289, (uint64_t *)&v276, (uint64_t)&std::piecewise_construct, &__dst)+ 24) = 1;
        unint64_t v41 = v294;
        if (!(void)v294)
        {
          std::deque<HGNode const*>::__add_front_capacity((uint64_t)&v292);
          unint64_t v41 = v294;
        }
        uint64_t v42 = (void *)(*((void *)&v292 + 1) + 8 * (v41 >> 9));
        if ((void)v293 == *((void *)&v292 + 1)) {
          uint64_t v43 = 0;
        }
        else {
          uint64_t v43 = *v42 + 8 * (v41 & 0x1FF);
        }
        if (v43 == *v42) {
          uint64_t v43 = *(v42 - 1) + 4096;
        }
        *(std::locale *)(v43 - 8) = v276;
        *(void *)&long long v294 = v41 - 1;
        ++*((void *)&v294 + 1);
        if ((*((unsigned char *)v276.__locale_ + 136) & 2) != 0)
        {
          std::string v44 = (std::locale::__imp *)*((void *)v276.__locale_ + 18);
          v276.__locale_ = v44;
          if (*((int *)v44 + 22) >= 1) {
            break;
          }
        }
      }
LABEL_56:
      if (v38 == v39)
      {
        uint64_t v112 = (void *)(*((void *)&v292 + 1) + 8 * ((unint64_t)v294 >> 9));
        if ((void)v293 == *((void *)&v292 + 1))
        {
          __n128 v113 = 0;
          long long v115 = 0;
          __n128 v114 = (void *)(*((void *)&v292 + 1) + 8 * ((*((void *)&v294 + 1) + (void)v294) >> 9));
        }
        else
        {
          __n128 v113 = (unint64_t *)(*v112 + 8 * (v294 & 0x1FF));
          __n128 v114 = (void *)(*((void *)&v292 + 1) + 8 * ((*((void *)&v294 + 1) + (void)v294) >> 9));
          long long v115 = (unint64_t *)(*v114 + 8 * ((*((void *)&v294 + 1) + v294) & 0x1FF));
        }
        long long v124 = (char *)hgstd::stable_unique<std::__deque_iterator<HGNode const*,HGNode const**,HGNode const*&,HGNode const***,long,512l>>(v112, v113, (uint64_t)v114, v115);
        uint64_t v126 = (char *)(*((void *)&v292 + 1) + 8 * ((unint64_t)v294 >> 9));
        if ((void)v293 == *((void *)&v292 + 1))
        {
          uint64_t v127 = 0;
          if (!v125) {
            goto LABEL_175;
          }
LABEL_173:
          unint64_t v128 = ((v125 - *(void *)v124) >> 3) + ((v124 - v126) << 6) - ((v127 - *(void *)v126) >> 3);
        }
        else
        {
          uint64_t v127 = *(void *)v126 + 8 * (v294 & 0x1FF);
          if (v125 != v127) {
            goto LABEL_173;
          }
LABEL_175:
          unint64_t v128 = 0;
        }
        std::deque<HGNode const*>::resize(&v292, v128);
        uint64_t v129 = *((void *)&v292 + 1);
        uint64_t v130 = v293;
        __n128 v131 = (void *)(*((void *)&v292 + 1) + 8 * ((unint64_t)v294 >> 9));
        if ((void)v293 == *((void *)&v292 + 1)) {
          uint64_t v132 = 0;
        }
        else {
          uint64_t v132 = *v131 + 8 * (v294 & 0x1FF);
        }
        __n128 v133 = &__dst.__r_.__value_.__r.__words[2];
        long long v134 = v285;
        __n128 v270 = (std::locale::__imp *)*MEMORY[0x1E4FBA408];
        std::string::size_type v264 = *(void *)(MEMORY[0x1E4FBA408] + 72);
        __n128 v267 = *(std::locale::__imp **)(MEMORY[0x1E4FBA408] + 64);
        while (2)
        {
          if (v130 == v129)
          {
            if (!v132)
            {
LABEL_225:
              __n128 v160 = (void *)v290;
              if ((void)v290)
              {
                do
                {
                  __n128 v161 = (void *)*v160;
                  operator delete(v160);
                  __n128 v160 = v161;
                }
                while (v161);
              }
              __n128 v162 = (void *)v289;
              *(void *)&long long v289 = 0;
              if (v162) {
                operator delete(v162);
              }
              __n128 v163 = (void **)*((void *)&v292 + 1);
              __n128 v164 = (void **)v293;
              *((void *)&v294 + 1) = 0;
              unint64_t v165 = v293 - *((void *)&v292 + 1);
              if ((void)v293 - *((void *)&v292 + 1) >= 0x11uLL)
              {
                do
                {
                  operator delete(*v163);
                  __n128 v164 = (void **)v293;
                  __n128 v163 = (void **)(*((void *)&v292 + 1) + 8);
                  *((void *)&v292 + 1) = v163;
                  unint64_t v165 = v293 - (void)v163;
                }
                while ((void)v293 - (void)v163 > 0x10uLL);
              }
              unint64_t v166 = v165 >> 3;
              if (v166 == 1)
              {
                uint64_t v167 = 256;
LABEL_346:
                *(void *)&long long v294 = v167;
              }
              else if (v166 == 2)
              {
                uint64_t v167 = 512;
                goto LABEL_346;
              }
              if (v163 != v164)
              {
                do
                {
                  long long v244 = *v163++;
                  operator delete(v244);
                }
                while (v163 != v164);
                if ((void)v293 != *((void *)&v292 + 1)) {
                  *(void *)&long long v293 = v293 + ((*((void *)&v292 + 1) - v293 + 7) & 0xFFFFFFFFFFFFFFF8);
                }
              }
              if ((void)v292) {
                operator delete((void *)v292);
              }
              long long v245 = v295;
              if (!v295) {
                goto LABEL_376;
              }
LABEL_375:
              operator delete(v245);
              goto LABEL_376;
            }
          }
          else if (v132 == *(void *)(v129 + (((*((void *)&v294 + 1) + (void)v294) >> 6) & 0x3FFFFFFFFFFFFF8)) {
                          + 8 * ((*((void *)&v294 + 1) + (void)v294) & 0x1FFLL))
          }
          {
            goto LABEL_225;
          }
          long long v136 = *(void **)v132;
          if ((*(unsigned char *)(*(void *)v132 + 136) & 2) == 0)
          {
            uint64_t v137 = v132;
            long long v138 = v134;
            long long v139 = v133;
            long long v140 = v131;
            long long v141 = (const char *)(*(uint64_t (**)(void *))(*v136 + 48))(v136);
            size_t v142 = strlen(v141);
            if (v142 >= 0x7FFFFFFFFFFFFFF8) {
              std::string::__throw_length_error[abi:ne180100]();
            }
            std::string::size_type v143 = v142;
            if (v142 >= 0x17)
            {
              uint64_t v153 = (v142 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v142 | 7) != 0x17) {
                uint64_t v153 = v142 | 7;
              }
              uint64_t v154 = v153 + 1;
              p_dst = (std::string *)operator new(v153 + 1);
              __dst.__r_.__value_.__l.__size_ = v143;
              __dst.__r_.__value_.__r.__words[2] = v154 | 0x8000000000000000;
              __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
            }
            else
            {
              *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v142;
              p_dst = &__dst;
              if (!v142)
              {
LABEL_201:
                p_dst->__r_.__value_.__s.__data_[v143] = 0;
                std::string::append(&__dst, "\n[kRendererOutput flag is NOT set. Call GetOutput()]");
                if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  __n128 v155 = &__dst;
                }
                else {
                  __n128 v155 = (std::string *)__dst.__r_.__value_.__r.__words[0];
                }
                HGDotGraph::node((uint64_t *)v298, (unint64_t)v136, (uint64_t)v155, 0);
                __n128 v131 = v140;
                if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__dst.__r_.__value_.__l.__data_);
                }
                __n128 v133 = v139;
                long long v134 = v138;
                uint64_t v132 = v137 + 8;
                if (v137 + 8 - *v131 == 4096) {
                  goto LABEL_180;
                }
                goto LABEL_181;
              }
            }
            memmove(p_dst, v141, v143);
            goto LABEL_201;
          }
          unint64_t v145 = v136[18];
          std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&__dst);
          long long v146 = (const char *)(*(uint64_t (**)(unint64_t))(*(void *)v145 + 48))(v145);
          size_t v147 = strlen(v146);
          long long v148 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v133, (uint64_t)v146, v147);
          std::ios_base::getloc((const std::ios_base *)((char *)v148 + *(void *)(*v148 - 24)));
          long long v149 = std::locale::use_facet(&v276, MEMORY[0x1E4FBA258]);
          ((void (*)(const std::locale::facet *, uint64_t))v149->__vftable[2].~facet_0)(v149, 10);
          std::locale::~locale(&v276);
          std::ostream::put();
          std::ostream::flush();
          *(_DWORD *)((char *)v134 + *(void *)(__dst.__r_.__value_.__r.__words[2] - 24)) = *(_DWORD *)((unsigned char *)v134 + *(void *)(__dst.__r_.__value_.__r.__words[2] - 24)) & 0xFFFFFFB5 | 8;
          long long v150 = (void *)std::ostream::operator<<();
          *(_DWORD *)((char *)v150 + *(void *)(*v150 - 24) + 8) = *(_DWORD *)((unsigned char *)v150
                                                                                + *(void *)(*v150 - 24)
                                                                                + 8) & 0xFFFFFFB5 | 2;
          std::stringbuf::str();
          if (v278 >= 0) {
            long long v151 = &v276;
          }
          else {
            long long v151 = v276.__locale_;
          }
          HGDotGraph::node((uint64_t *)v298, v145, (uint64_t)v151, 0);
          if (SHIBYTE(v278) < 0)
          {
            operator delete(v276.__locale_);
            int v152 = *(_DWORD *)(v145 + 88);
            if (v152 < 1) {
              goto LABEL_221;
            }
          }
          else
          {
            int v152 = *(_DWORD *)(v145 + 88);
            if (v152 < 1) {
              goto LABEL_221;
            }
          }
          for (uint64_t k = 0; k < v152; ++k)
          {
            uint64_t v157 = *(void *)(*(void *)(v145 + 80) + 8 * k);
            if (v157 && *(void *)(v157 + 16))
            {
              std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v276);
              std::ostream::operator<<();
              unint64_t v158 = *(void *)(*(void *)(v157 + 16) + 144);
              std::stringbuf::str();
              if (v275 >= 0) {
                __n128 v159 = __p;
              }
              else {
                __n128 v159 = (void **)__p[0];
              }
              HGDotGraph::link((uint64_t *)v298, v158, v145, (const char *)v159, 0);
              if (v275 < 0) {
                operator delete(__p[0]);
              }
              v276.__locale_ = v270;
              *(std::locale::__imp **)((char *)&v276.__locale_ + *((void *)v270 - 3)) = v267;
              uint64_t v278 = v264;
              v279[0] = MEMORY[0x1E4FBA470] + 16;
              if (SBYTE7(v281) < 0) {
                operator delete((void *)v280);
              }
              std::streambuf::~streambuf();
              std::iostream::~basic_iostream();
              MEMORY[0x1BA9BFAB0](v283);
              int v152 = *(_DWORD *)(v145 + 88);
            }
          }
LABEL_221:
          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v270;
          *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + *((void *)v270 - 3)) = (std::string::size_type)v267;
          __dst.__r_.__value_.__r.__words[2] = v264;
          v285[0] = MEMORY[0x1E4FBA470] + 16;
          if (v287 < 0) {
            operator delete(v286);
          }
          std::streambuf::~streambuf();
          std::iostream::~basic_iostream();
          MEMORY[0x1BA9BFAB0](v288);
          v132 += 8;
          if (v132 - *v131 == 4096)
          {
LABEL_180:
            uint64_t v135 = v131[1];
            ++v131;
            uint64_t v132 = v135;
          }
LABEL_181:
          uint64_t v129 = *((void *)&v292 + 1);
          uint64_t v130 = v293;
          continue;
        }
      }
    }
    uint64_t v45 = 0;
    while (1)
    {
      uint64_t v47 = *(void *)(*((void *)v44 + 10) + 8 * v45);
      if (!v47) {
        goto LABEL_70;
      }
      uint64_t v48 = *(void *)(v47 + 16);
      if (!v48) {
        goto LABEL_70;
      }
      if (v39 >= v297) {
        break;
      }
      *(void *)size_t v39 = v48;
      uint64_t v46 = (uint64_t)(v39 + 8);
LABEL_69:
      __n128 v296 = (char *)v46;
      std::string v44 = v276.__locale_;
      size_t v39 = (char *)v46;
LABEL_70:
      if (++v45 >= *((int *)v44 + 22))
      {
        long long v38 = v295;
        goto LABEL_56;
      }
    }
    uint64_t v49 = v295;
    std::string::size_type v50 = (char *)(v39 - v295);
    uint64_t v51 = (v39 - v295) >> 3;
    unint64_t v52 = v51 + 1;
    if ((unint64_t)(v51 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v53 = v297 - v295;
    if ((v297 - v295) >> 2 > v52) {
      unint64_t v52 = v53 >> 2;
    }
    if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v54 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v54 = v52;
    }
    if (v54)
    {
      if (v54 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      float64x2_t v55 = (char *)operator new(8 * v54);
      long long v56 = &v55[8 * v51];
      *(void *)long long v56 = *(void *)(v47 + 16);
      uint64_t v46 = (uint64_t)(v56 + 8);
      if (v39 == v49) {
        goto LABEL_89;
      }
    }
    else
    {
      float64x2_t v55 = 0;
      long long v56 = (char *)(8 * v51);
      *(void *)(8 * v51) = v48;
      uint64_t v46 = 8 * v51 + 8;
      if (v39 == v49) {
        goto LABEL_89;
      }
    }
    unint64_t v57 = v39 - 8 - v49;
    if (v57 >= 0x168)
    {
      if (&v50[(void)v55 - 8 - (v57 & 0xFFFFFFFFFFFFFFF8)] > &v50[(void)v55 - 8])
      {
        uint64_t v58 = v39;
      }
      else if (&v39[-(v57 & 0xFFFFFFFFFFFFFFF8) - 8] > v39 - 8)
      {
        uint64_t v58 = v39;
      }
      else if ((unint64_t)(v49 - v55) >= 0x20)
      {
        uint64_t v60 = (v57 >> 3) + 1;
        uint64_t v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v58 = &v39[-v61];
        v56 -= v61;
        uint64_t v62 = &v55[8 * v51 - 16];
        uint64_t v63 = v39 - 16;
        uint64_t v64 = v60 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v65 = *(_OWORD *)v63;
          *((_OWORD *)v62 - 1) = *((_OWORD *)v63 - 1);
          *(_OWORD *)uint64_t v62 = v65;
          v62 -= 32;
          v63 -= 32;
          v64 -= 4;
        }
        while (v64);
        if (v60 == (v60 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_88;
        }
      }
      else
      {
        uint64_t v58 = v39;
      }
    }
    else
    {
      uint64_t v58 = v39;
    }
    do
    {
      uint64_t v59 = *((void *)v58 - 1);
      v58 -= 8;
      *((void *)v56 - 1) = v59;
      v56 -= 8;
    }
    while (v58 != v49);
LABEL_88:
    size_t v39 = v295;
LABEL_89:
    __n128 v295 = v56;
    __n128 v297 = &v55[8 * v54];
    if (v39) {
      operator delete(v39);
    }
    goto LABEL_69;
  }
  if (a3) {
    goto LABEL_376;
  }
  __n128 v296 = 0;
  long long v293 = 0u;
  long long v294 = 0u;
  long long v292 = 0u;
  long long v289 = 0u;
  long long v290 = 0u;
  int v291 = 1065353216;
  uint64_t v8 = (char *)operator new(8uLL);
  *(void *)uint64_t v8 = a1;
  long long v9 = v8 + 8;
  __n128 v295 = v8;
  __n128 v297 = v8 + 8;
  do
  {
    v276.__locale_ = 0;
    v276.__locale_ = (std::locale::__imp *)*((void *)v9 - 1);
    uint64_t v10 = v9 - 8;
    __n128 v296 = v9 - 8;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&v276;
    if (*((unsigned char *)std::__hash_table<std::__hash_value_type<HGNode const*,BOOL>,std::__unordered_map_hasher<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::hash<HGNode const*>,std::equal_to<HGNode const*>,true>,std::__unordered_map_equal<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::equal_to<HGNode const*>,std::hash<HGNode const*>,true>,std::allocator<std::__hash_value_type<HGNode const*,BOOL>>>::__emplace_unique_key_args<HGNode const*,std::piecewise_construct_t const&,std::tuple<HGNode const* const&>,std::tuple<>>((uint64_t)&v289, (uint64_t *)&v276, (uint64_t)&std::piecewise_construct, &__dst)+ 24))
    {
      long long v9 = v10;
      continue;
    }
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&v276;
    *((unsigned char *)std::__hash_table<std::__hash_value_type<HGNode const*,BOOL>,std::__unordered_map_hasher<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::hash<HGNode const*>,std::equal_to<HGNode const*>,true>,std::__unordered_map_equal<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::equal_to<HGNode const*>,std::hash<HGNode const*>,true>,std::allocator<std::__hash_value_type<HGNode const*,BOOL>>>::__emplace_unique_key_args<HGNode const*,std::piecewise_construct_t const&,std::tuple<HGNode const* const&>,std::tuple<>>((uint64_t)&v289, (uint64_t *)&v276, (uint64_t)&std::piecewise_construct, &__dst)+ 24) = 1;
    unint64_t v11 = v294;
    if (!(void)v294)
    {
      std::deque<HGNode const*>::__add_front_capacity((uint64_t)&v292);
      unint64_t v11 = v294;
    }
    uint64_t v12 = (void *)(*((void *)&v292 + 1) + 8 * (v11 >> 9));
    if ((void)v293 == *((void *)&v292 + 1)) {
      uint64_t v13 = 0;
    }
    else {
      uint64_t v13 = *v12 + 8 * (v11 & 0x1FF);
    }
    if (v13 == *v12) {
      uint64_t v13 = *(v12 - 1) + 4096;
    }
    *(std::locale *)(v13 - 8) = v276;
    *(void *)&long long v294 = v11 - 1;
    ++*((void *)&v294 + 1);
    unsigned int v14 = v276.__locale_;
    long long v9 = v10;
    if (*((int *)v276.__locale_ + 22) >= 1)
    {
      uint64_t v15 = 0;
      while (1)
      {
        uint64_t v17 = *(void *)(*((void *)v14 + 10) + 8 * v15);
        if (!v17) {
          goto LABEL_22;
        }
        uint64_t v18 = *(void *)(v17 + 16);
        if (!v18) {
          goto LABEL_22;
        }
        if (v9 >= v297) {
          break;
        }
        *(void *)long long v9 = v18;
        uint64_t v16 = (uint64_t)(v9 + 8);
LABEL_21:
        __n128 v296 = (char *)v16;
        unsigned int v14 = v276.__locale_;
        long long v9 = (char *)v16;
LABEL_22:
        if (++v15 >= *((int *)v14 + 22))
        {
          uint64_t v8 = v295;
          goto LABEL_9;
        }
      }
      long long v19 = v295;
      uint64_t v20 = v9;
      int v21 = (char *)(v9 - v295);
      uint64_t v22 = (v9 - v295) >> 3;
      unint64_t v23 = v22 + 1;
      if ((unint64_t)(v22 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v24 = v297 - v295;
      if ((v297 - v295) >> 2 > v23) {
        unint64_t v23 = v24 >> 2;
      }
      if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v25 = v23;
      }
      if (v25)
      {
        if (v25 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v26 = operator new(8 * v25);
        unint64_t v27 = v20;
        uint64_t v28 = (char *)v26 + 8 * v22;
        *(void *)uint64_t v28 = *(void *)(v17 + 16);
        uint64_t v16 = (uint64_t)(v28 + 8);
        if (v20 == v19) {
          goto LABEL_41;
        }
      }
      else
      {
        uint64_t v26 = 0;
        unint64_t v27 = v20;
        uint64_t v28 = (char *)(8 * v22);
        *(void *)(8 * v22) = v18;
        uint64_t v16 = 8 * v22 + 8;
        if (v20 == v19) {
          goto LABEL_41;
        }
      }
      unint64_t v29 = v27 - 8 - v19;
      if (v29 >= 0x168)
      {
        if (&v21[(void)v26 - 8 - (v29 & 0xFFFFFFFFFFFFFFF8)] > &v21[(void)v26 - 8])
        {
          uint64_t v30 = v20;
        }
        else if (&v27[-(v29 & 0xFFFFFFFFFFFFFFF8) - 8] > v27 - 8)
        {
          uint64_t v30 = v20;
        }
        else if ((unint64_t)(v27 - &v21[(void)v26]) >= 0x20)
        {
          uint64_t v32 = (v29 >> 3) + 1;
          uint64_t v33 = 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v30 = &v20[-v33];
          v28 -= v33;
          uint64_t v34 = (char *)v26 + 8 * v22 - 16;
          long long v35 = (long long *)(v20 - 16);
          uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v37 = *v35;
            *(v34 - 1) = *(v35 - 1);
            *uint64_t v34 = v37;
            v34 -= 2;
            v35 -= 2;
            v36 -= 4;
          }
          while (v36);
          if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_40;
          }
        }
        else
        {
          uint64_t v30 = v20;
        }
      }
      else
      {
        uint64_t v30 = v27;
      }
      do
      {
        uint64_t v31 = *((void *)v30 - 1);
        v30 -= 8;
        *((void *)v28 - 1) = v31;
        v28 -= 8;
      }
      while (v30 != v19);
LABEL_40:
      unint64_t v27 = v295;
LABEL_41:
      __n128 v295 = v28;
      __n128 v297 = (char *)v26 + 8 * v25;
      if (v27) {
        operator delete(v27);
      }
      goto LABEL_21;
    }
LABEL_9:
    ;
  }
  while (v8 != v9);
  long long v248 = v9;
  long long v116 = (void *)(*((void *)&v292 + 1) + 8 * ((unint64_t)v294 >> 9));
  if ((void)v293 == *((void *)&v292 + 1))
  {
    long long v117 = 0;
    __n128 v119 = 0;
    long long v118 = (void *)(*((void *)&v292 + 1) + 8 * ((*((void *)&v294 + 1) + (void)v294) >> 9));
  }
  else
  {
    long long v117 = (unint64_t *)(*v116 + 8 * (v294 & 0x1FF));
    long long v118 = (void *)(*((void *)&v292 + 1) + 8 * ((*((void *)&v294 + 1) + (void)v294) >> 9));
    __n128 v119 = (unint64_t *)(*v118 + 8 * ((*((void *)&v294 + 1) + v294) & 0x1FF));
  }
  __n128 v168 = (char *)hgstd::stable_unique<std::__deque_iterator<HGNode const*,HGNode const**,HGNode const*&,HGNode const***,long,512l>>(v116, v117, (uint64_t)v118, v119);
  __n128 v170 = (char *)(*((void *)&v292 + 1) + 8 * ((unint64_t)v294 >> 9));
  if ((void)v293 == *((void *)&v292 + 1))
  {
    uint64_t v171 = 0;
    if (!v169) {
      goto LABEL_239;
    }
LABEL_237:
    unint64_t v172 = ((v169 - *(void *)v168) >> 3) + ((v168 - v170) << 6) - ((v171 - *(void *)v170) >> 3);
  }
  else
  {
    uint64_t v171 = *(void *)v170 + 8 * (v294 & 0x1FF);
    if (v169 != v171) {
      goto LABEL_237;
    }
LABEL_239:
    unint64_t v172 = 0;
  }
  std::deque<HGNode const*>::resize(&v292, v172);
  uint64_t v173 = *((void *)&v292 + 1);
  uint64_t v174 = v293;
  __n128 v175 = (void *)(*((void *)&v292 + 1) + 8 * ((unint64_t)v294 >> 9));
  if ((void)v293 == *((void *)&v292 + 1)) {
    __n128 v176 = 0;
  }
  else {
    __n128 v176 = (unint64_t *)(*v175 + 8 * (v294 & 0x1FF));
  }
  __n128 v262 = *(std::locale::__imp **)(MEMORY[0x1E4FBA408] + 24);
  __n128 v265 = *(std::locale::__imp **)(MEMORY[0x1E4FBA408] + 16);
  uint64_t v258 = *(void *)(MEMORY[0x1E4FBA408] + 40);
  uint64_t v260 = *(void *)(MEMORY[0x1E4FBA408] + 32);
  __n128 v254 = *(std::locale::__imp **)(MEMORY[0x1E4FBA408] + 8);
  __n128 v256 = *(std::locale::__imp **)(MEMORY[0x1E4FBA408] + 48);
  __n128 v271 = *(std::locale::__imp **)(MEMORY[0x1E4FBA408] + 64);
  __n128 v273 = (std::locale::__imp *)*MEMORY[0x1E4FBA408];
  std::string::size_type v268 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  while (2)
  {
    if (v174 != v173)
    {
      if (v176 == (unint64_t *)(*(void *)(v173
                                                  + (((*((void *)&v294 + 1) + (void)v294) >> 6) & 0x3FFFFFFFFFFFFF8))
                                      + 8 * ((*((void *)&v294 + 1) + v294) & 0x1FF)))
        goto LABEL_272;
LABEL_249:
      long long v250 = v176;
      unint64_t v177 = *v176;
      std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&__dst);
      __n128 v178 = (const char *)(*(uint64_t (**)(unint64_t))(*(void *)v177 + 48))(v177);
      size_t v179 = strlen(v178);
      __n128 v180 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&__dst.__r_.__value_.__r.__words[2], (uint64_t)v178, v179);
      std::ios_base::getloc((const std::ios_base *)((char *)v180 + *(void *)(*v180 - 24)));
      __n128 v181 = std::locale::use_facet(&v276, MEMORY[0x1E4FBA258]);
      ((void (*)(const std::locale::facet *, uint64_t))v181->__vftable[2].~facet_0)(v181, 10);
      std::locale::~locale(&v276);
      std::ostream::put();
      std::ostream::flush();
      *(_DWORD *)((char *)v285 + *(void *)(__dst.__r_.__value_.__r.__words[2] - 24)) = *(_DWORD *)((unsigned char *)v285 + *(void *)(__dst.__r_.__value_.__r.__words[2] - 24)) & 0xFFFFFFB5 | 8;
      __n128 v182 = (void *)std::ostream::operator<<();
      *(_DWORD *)((char *)v182 + *(void *)(*v182 - 24) + 8) = *(_DWORD *)((unsigned char *)v182
                                                                            + *(void *)(*v182 - 24)
                                                                            + 8) & 0xFFFFFFB5 | 2;
      std::stringbuf::str();
      if (v278 >= 0) {
        __n128 v183 = &v276;
      }
      else {
        __n128 v183 = v276.__locale_;
      }
      HGDotGraph::node((uint64_t *)v298, v177, (uint64_t)v183, 0);
      long long v249 = v175;
      if (SHIBYTE(v278) < 0)
      {
        operator delete(v276.__locale_);
        int v184 = *(_DWORD *)(v177 + 88);
        if (v184 < 1)
        {
LABEL_268:
          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v273;
          *(std::string::size_type *)((char *)__dst.__r_.__value_.__r.__words + *((void *)v273 - 3)) = (std::string::size_type)v271;
          __dst.__r_.__value_.__r.__words[2] = v268;
          v285[0] = MEMORY[0x1E4FBA470] + 16;
          if (v287 < 0) {
            operator delete(v286);
          }
          std::streambuf::~streambuf();
          std::iostream::~basic_iostream();
          MEMORY[0x1BA9BFAB0](v288);
          __n128 v175 = v249;
          __n128 v176 = v250 + 1;
          if ((unint64_t *)((char *)v250 - *v249 + 8) == (unint64_t *)4096)
          {
            __n128 v175 = v249 + 1;
            __n128 v176 = (unint64_t *)v249[1];
          }
          uint64_t v173 = *((void *)&v292 + 1);
          uint64_t v174 = v293;
          continue;
        }
      }
      else
      {
        int v184 = *(_DWORD *)(v177 + 88);
        if (v184 < 1) {
          goto LABEL_268;
        }
      }
      for (uint64_t m = 0; m < v184; ++m)
      {
        uint64_t v186 = *(void *)(*(void *)(v177 + 80) + 8 * m);
        if (v186 && *(void *)(v186 + 16))
        {
          uint64_t v187 = MEMORY[0x1E4FBA488] + 104;
          v283[0] = MEMORY[0x1E4FBA488] + 104;
          uint64_t v188 = MEMORY[0x1E4FBA488] + 64;
          uint64_t v278 = MEMORY[0x1E4FBA488] + 64;
          v276.__locale_ = v265;
          *(std::locale::__imp **)((char *)&v276.__locale_ + *((void *)v265 - 3)) = v262;
          uint64_t v277 = 0;
          __n128 v189 = (std::ios_base *)((char *)&v276 + *((void *)v276.__locale_ - 3));
          std::ios_base::init(v189, v279);
          __n128 v190 = (std::locale::__imp *)(MEMORY[0x1E4FBA488] + 24);
          v189[1].__vftable = 0;
          v189[1].__fmtflags_ = -1;
          uint64_t v278 = v260;
          *(void *)((char *)&v279[-1] + *(void *)(v260 - 24)) = v258;
          v276.__locale_ = v254;
          *(std::locale::__imp **)((char *)&v276.__locale_ + *((void *)v254 - 3)) = v256;
          v283[0] = v187;
          v276.__locale_ = v190;
          uint64_t v278 = v188;
          std::streambuf::basic_streambuf();
          uint64_t v191 = MEMORY[0x1E4FBA470] + 16;
          v279[0] = MEMORY[0x1E4FBA470] + 16;
          long long v280 = 0u;
          long long v281 = 0u;
          int v282 = 24;
          std::ostream::operator<<();
          unint64_t v192 = *(void *)(v186 + 16);
          std::stringbuf::str();
          if (v275 >= 0) {
            int v193 = __p;
          }
          else {
            int v193 = (void **)__p[0];
          }
          HGDotGraph::link((uint64_t *)v298, v192, v177, (const char *)v193, 0);
          if (v275 < 0) {
            operator delete(__p[0]);
          }
          v276.__locale_ = v273;
          *(std::locale::__imp **)((char *)&v276.__locale_ + *((void *)v273 - 3)) = v271;
          uint64_t v278 = v268;
          v279[0] = v191;
          if (SBYTE7(v281) < 0) {
            operator delete((void *)v280);
          }
          std::streambuf::~streambuf();
          std::iostream::~basic_iostream();
          MEMORY[0x1BA9BFAB0](v283);
          int v184 = *(_DWORD *)(v177 + 88);
        }
      }
      goto LABEL_268;
    }
    break;
  }
  if (v176) {
    goto LABEL_249;
  }
LABEL_272:
  long long v194 = (void *)v290;
  if ((void)v290)
  {
    do
    {
      __n128 v195 = (void *)*v194;
      operator delete(v194);
      long long v194 = v195;
    }
    while (v195);
  }
  __n128 v196 = (void *)v289;
  *(void *)&long long v289 = 0;
  if (v196) {
    operator delete(v196);
  }
  __n128 v197 = (void **)*((void *)&v292 + 1);
  __n128 v198 = (void **)v293;
  *((void *)&v294 + 1) = 0;
  unint64_t v199 = v293 - *((void *)&v292 + 1);
  if ((void)v293 - *((void *)&v292 + 1) >= 0x11uLL)
  {
    do
    {
      operator delete(*v197);
      __n128 v198 = (void **)v293;
      __n128 v197 = (void **)(*((void *)&v292 + 1) + 8);
      *((void *)&v292 + 1) = v197;
      unint64_t v199 = v293 - (void)v197;
    }
    while ((void)v293 - (void)v197 > 0x10uLL);
  }
  unint64_t v200 = v199 >> 3;
  __n128 v201 = v248;
  if (v200 == 1)
  {
    uint64_t v202 = 256;
LABEL_356:
    *(void *)&long long v294 = v202;
  }
  else if (v200 == 2)
  {
    uint64_t v202 = 512;
    goto LABEL_356;
  }
  if (v197 != v198)
  {
    do
    {
      long long v246 = *v197++;
      operator delete(v246);
    }
    while (v197 != v198);
    __n128 v201 = v248;
    if ((void)v293 != *((void *)&v292 + 1)) {
      *(void *)&long long v293 = v293 + ((*((void *)&v292 + 1) - v293 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if ((void)v292)
  {
    operator delete((void *)v292);
    __n128 v201 = v248;
  }
  if (v201)
  {
    long long v245 = v201;
    goto LABEL_375;
  }
LABEL_376:
  HGDotGraph::end((HGDotGraph *)v298);
  HGDotGraph::~HGDotGraph((HGDotGraph *)v298);
}

void sub_1B7791C9C(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<OZSceneNode *,std::__list_iterator<OZSceneNode *,void *>>,std::__unordered_map_hasher<OZSceneNode *,std::__hash_value_type<OZSceneNode *,std::__list_iterator<OZSceneNode *,void *>>,std::hash<OZSceneNode *>,std::equal_to<OZSceneNode *>,true>,std::__unordered_map_equal<OZSceneNode *,std::__hash_value_type<OZSceneNode *,std::__list_iterator<OZSceneNode *,void *>>,std::equal_to<OZSceneNode *>,std::hash<OZSceneNode *>,true>,std::allocator<std::__hash_value_type<OZSceneNode *,std::__list_iterator<OZSceneNode *,void *>>>>::~__hash_table((uint64_t)&STACK[0x2D0]);
  std::deque<HGNode *>::~deque[abi:ne180100](v1 - 256);
  int v3 = *(void **)(v1 - 208);
  if (v3)
  {
    *(void *)(v1 - 200) = v3;
    operator delete(v3);
  }
  HGDotGraph::~HGDotGraph((HGDotGraph *)(v1 - 184));
  _Unwind_Resume(a1);
}

void *hgstd::stable_unique<std::__deque_iterator<HGNode const*,HGNode const**,HGNode const*&,HGNode const***,long,512l>>(void *a1, unint64_t *a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v4 = a2;
  uint64_t v5 = a1;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  unint64_t v25 = &v26;
  if (a2 != a4)
  {
    uint64_t v7 = 0;
    uint64_t v8 = a2;
    long long v9 = a1;
    while (1)
    {
      unint64_t v10 = *v8;
      unint64_t v11 = &v26;
      uint64_t v12 = &v26;
      if (v7)
      {
        uint64_t v13 = &v26;
        unsigned int v14 = v7;
        do
        {
          uint64_t v15 = v14;
          uint64_t v16 = v13;
          unint64_t v17 = v14[4];
          if (v17 >= v10) {
            uint64_t v13 = (uint64_t **)v14;
          }
          else {
            ++v14;
          }
          unsigned int v14 = (uint64_t *)*v14;
        }
        while (v14);
        if (v13 != &v26)
        {
          if (v17 < v10) {
            uint64_t v15 = (uint64_t *)v16;
          }
          if (v10 >= v15[4]) {
            goto LABEL_26;
          }
        }
        uint64_t v18 = v7;
        while (1)
        {
          while (1)
          {
            uint64_t v12 = (uint64_t **)v18;
            unint64_t v19 = v18[4];
            if (v10 >= v19) {
              break;
            }
            uint64_t v18 = *v12;
            unint64_t v11 = v12;
            if (!*v12) {
              goto LABEL_20;
            }
          }
          if (v19 >= v10) {
            break;
          }
          uint64_t v18 = v12[1];
          if (!v18)
          {
            unint64_t v11 = v12 + 1;
            goto LABEL_20;
          }
        }
      }
      else
      {
LABEL_20:
        uint64_t v20 = (uint64_t *)operator new(0x28uLL);
        v20[4] = v10;
        *uint64_t v20 = 0;
        v20[1] = 0;
        v20[2] = (uint64_t)v12;
        void *v11 = v20;
        if (*v25)
        {
          unint64_t v25 = (uint64_t **)*v25;
          uint64_t v20 = *v11;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v26, v20);
        ++v27;
        unint64_t v10 = *v8;
      }
      int v21 = v4 + 1;
      if ((unint64_t *)((char *)v4 - *v5 + 8) == (unint64_t *)4096)
      {
        uint64_t v22 = (unint64_t *)v5[1];
        ++v5;
        int v21 = v22;
      }
      unint64_t *v4 = v10;
      uint64_t v4 = v21;
LABEL_26:
      if ((unint64_t *)((char *)++v8 - *v9) == (unint64_t *)4096)
      {
        unint64_t v23 = (unint64_t *)v9[1];
        ++v9;
        uint64_t v8 = v23;
      }
      uint64_t v7 = v26;
      if (v8 == a4) {
        goto LABEL_29;
      }
    }
  }
  uint64_t v7 = 0;
LABEL_29:
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)&v25, v7);
  return v5;
}

void sub_1B7792018(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)va, v2);
  _Unwind_Resume(a1);
}

void std::deque<HGNode const*>::resize(void *a1, unint64_t a2)
{
  unint64_t v3 = a1[5];
  if (a2 > v3)
  {
    unint64_t v4 = a2 - v3;
    std::deque<HGNode const*>::__append(a1, v4);
    return;
  }
  if (a2 >= v3) {
    return;
  }
  unint64_t v5 = a1[4];
  uint64_t v7 = a1[1];
  uint64_t v6 = a1[2];
  uint64_t v8 = (char *)(v7 + 8 * (v5 >> 9));
  if (v6 == v7)
  {
    uint64_t v9 = 0;
    if (!a2) {
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v9 = *(void *)v8 + 8 * (a1[4] & 0x1FFLL);
    if (!a2)
    {
LABEL_12:
      __int16 v11 = v5 + v3;
      uint64_t v12 = (char *)(v7 + 8 * ((v5 + v3) >> 9));
      uint64_t v13 = v6 - v7;
      if (v6 != v7) {
        goto LABEL_13;
      }
      goto LABEL_16;
    }
  }
  uint64_t v10 = a2 + ((v9 - *(void *)v8) >> 3);
  if (v10 >= 1)
  {
    v8 += 8 * ((unint64_t)v10 >> 9);
    uint64_t v9 = *(void *)v8 + 8 * (v10 & 0x1FF);
    goto LABEL_12;
  }
  unint64_t v15 = 511 - v10;
  v8 -= 8 * (v15 >> 9);
  uint64_t v9 = *(void *)v8 + 8 * (~(_WORD)v15 & 0x1FF);
  __int16 v11 = v5 + v3;
  uint64_t v12 = (char *)(v7 + 8 * ((v5 + v3) >> 9));
  uint64_t v13 = v6 - v7;
  if (v6 != v7)
  {
LABEL_13:
    uint64_t v14 = *(void *)v12 + 8 * (v11 & 0x1FF);
    if (v9 == v14) {
      return;
    }
    goto LABEL_17;
  }
LABEL_16:
  uint64_t v14 = 0;
  if (!v9) {
    return;
  }
LABEL_17:
  uint64_t v16 = ((v14 - *(void *)v12) >> 3) + ((v12 - v8) << 6) - ((v9 - *(void *)v8) >> 3);
  if (v16 >= 1)
  {
    uint64_t v17 = v6 == v7 ? 0 : (v13 << 6) - 1;
    unint64_t v18 = v3 - v16;
    a1[5] = v18;
    if (v17 - v5 - v18 >= 0x400)
    {
      do
      {
        operator delete(*(void **)(v6 - 8));
        uint64_t v19 = a1[1];
        uint64_t v6 = a1[2] - 8;
        a1[2] = v6;
        if (v6 == v19) {
          uint64_t v20 = 0;
        }
        else {
          uint64_t v20 = ((v6 - v19) << 6) - 1;
        }
      }
      while ((unint64_t)(v20 - (a1[5] + a1[4])) > 0x3FF);
    }
  }
}

uint64_t HGNode::SetState(uint64_t result, uint64_t a2, int a3)
{
  *(_DWORD *)(result + 40) = a3;
  return result;
}

const char *HGNode::SetOutputFormatComponents(const char *result, const char *a2, char *a3)
{
  if (a2 > 4 || ((1 << (char)a2) & 0x16) == 0) {
    return HGLogger::warning((HGLogger *)"HGNode::SetOutputFormatComponents -- invalid HGFormatComponents value", a2, a3);
  }
  *((_DWORD *)result + 8) = a2;
  return result;
}

HGNode *HGNode::SetSupportedFormatPrecisions(HGNode *this, const char *a2, char *a3)
{
  if ((a2 & 0xF) == 0) {
    return (HGNode *)HGLogger::warning((HGLogger *)"HGNode::SetSupportedFormatPrecisions -- invalid precision mask value", a2, a3);
  }
  *((_DWORD *)this + 9) = a2;
  return this;
}

void HGNode::EnableGLHardwareBlending(HGNode *this)
{
  if (*((unsigned char *)this + 332))
  {
    glEnable(0xBE2u);
    uint64_t v2 = (const HGBlendingInfo *)(*(uint64_t (**)(HGNode *))(*(void *)this + 256))(this);
    HGGLBlendingInfo::HGGLBlendingInfo((HGGLBlendingInfo *)v10, v2);
    GLenum Size = PVPerfStats::FrameStats::GetSize((PVPerfStats::FrameStats *)v10);
    GLenum DstRGBFactor = HGGLBlendingInfo::GetDstRGBFactor((HGGLBlendingInfo *)v10);
    GLenum v5 = LiImageSource::imageSpace((LiImageSource *)v10);
    GLenum DstAlphaFactor = HGGLBlendingInfo::GetDstAlphaFactor((HGGLBlendingInfo *)v10);
    glBlendFuncSeparate(Size, DstRGBFactor, v5, DstAlphaFactor);
    GLenum RGBOperation = HGGLBlendingInfo::GetRGBOperation((HGGLBlendingInfo *)v10);
    GLenum AlphaOperation = HGGLBlendingInfo::GetAlphaOperation((HGGLBlendingInfo *)v10);
    glBlendEquationSeparate(RGBOperation, AlphaOperation);
    uint64_t v9 = (GLfloat *)(*(uint64_t (**)(HGNode *))(*(void *)this + 272))(this);
    glBlendColor(*v9, v9[1], v9[2], v9[3]);
  }
}

uint64_t HGNode::IsInPlaceHardwareBlendingEnabled(HGNode *this)
{
  return *((unsigned __int8 *)this + 332);
}

void HGNode::DisableGLHardwareBlending(HGNode *this)
{
}

uint64_t HGNode::SupportsEarlyConcatenation(HGNode *this)
{
  return 0;
}

HGNode *HGNode::GetGuardedOutput(HGNode *this, HGRenderer *a2)
{
  uint64_t result = (HGNode *)(*(uint64_t (**)(HGNode *, HGRenderer *))(*(void *)this + 384))(this, a2);
  unint64_t v4 = result;
  if (result) {
    BOOL v5 = result == this;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    if ((*((_DWORD *)result + 4) & 0x80000000) != 0)
    {
      unint64_t v4 = 0;
      uint64_t v6 = "HGNode::GetOutput (%s) received a de-allocated HGNode.";
    }
    else
    {
      if ((*((_DWORD *)result + 34) & 0x80000000) == 0) {
        return result;
      }
      *((_DWORD *)result + 34) = 0;
      uint64_t v6 = "HGNode::GetOutput (%s) received an invalid HGNode.";
    }
    uint64_t v7 = (*(uint64_t (**)(HGNode *))(*(void *)this + 48))(this);
    HGLogger::error((HGLogger *)v6, v8, v9, v7);
    return v4;
  }
  return result;
}

HGNode *HGNode::GetOutput(HGNode *this, HGRenderer *a2)
{
  if (!this) {
    __cxa_bad_typeid();
  }
  unint64_t v4 = *(void *)(*(void *)(*(void *)this - 8) + 8);
  if ((char *)v4 != "6HGNode"
    && (((v4 & (unint64_t)"6HGNode" & 0x8000000000000000) != 0) == __OFSUB__(v4, "6HGNode")
     || strcmp((const char *)(v4 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"6HGNode" & 0x7FFFFFFFFFFFFFFFLL))))
  {
    return this;
  }
  int v5 = *((_DWORD *)this + 4);
  *((_DWORD *)this + 4) = v5 | 0x400;
  if ((v5 & 6) != 0) {
    return this;
  }

  return HGRenderer::GetInput(a2, this, 0);
}

uint64_t HGNode::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

uint64_t HGNode::GetROI(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

uint64_t HGNode::GetProgram()
{
  return 0;
}

uint64_t HGNode::GetUserRegion()
{
  return 0;
}

HGNode *HGNode::ClearBits(HGNode *this, const char *a2, char *a3)
{
  int v3 = (int)a2;
  unint64_t v4 = this;
  if (*((_DWORD *)this + 10) == 1) {
    this = (HGNode *)HGLogger::warning((HGLogger *)"ClearBits() : called during render\n", a2, a3);
  }
  int v5 = *((_DWORD *)v4 + 34);
  if ((v5 & v3) != 0)
  {
    *((_DWORD *)v4 + 34) = v5 & ~v3;
    uint64_t v6 = (void *)*((void *)v4 + 14);
    uint64_t v7 = (void *)((char *)v4 + 120);
    if (v6 != v7)
    {
      do
      {
        this = (HGNode *)HGNode::ClearBits(*(HGNode **)v6[4], 255);
        uint64_t v8 = (void *)v6[1];
        if (v8)
        {
          do
          {
            uint64_t v9 = v8;
            uint64_t v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            uint64_t v9 = (void *)v6[2];
            BOOL v10 = *v9 == (void)v6;
            uint64_t v6 = v9;
          }
          while (!v10);
        }
        uint64_t v6 = v9;
      }
      while (v9 != v7);
    }
  }
  return this;
}

uint64_t HGNode::RenderTileDispatch(HGNode *this, HGTile *a2, char *a3)
{
  int v5 = *((_DWORD *)this + 4);
  if ((v5 & 0x20000) != 0)
  {
    if ((~v5 & 0x82) != 0)
    {
      HGLogger::warning((HGLogger *)"HGNode::RenderTileDispatch - improper flags for RenderSingleBufferedTile!", (const char *)a2, a3);
    }
    else if ((int)atomic_fetch_add((atomic_uint *volatile)this + 64, 1u) >= 1)
    {
      return 0;
    }
  }
  HGStats::ProfilerScopeGuard::ProfilerScopeGuard((HGStats::ProfilerScopeGuard *)v138, *(HGStats::UnitStatsImpl ***)(*((void *)a2 + 42) + 424), this, (*((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1)) * (*((_DWORD *)a2 + 2) - *(_DWORD *)a2));
  uint64_t v7 = (void (*)(long long *, void *, uint64_t *, void *, void *))*((void *)this + 9);
  if (v7)
  {
    v33[0] = 0x100000001;
    long long v53 = 0u;
    long long v54 = 0u;
    *(void *)uint64_t v31 = 0;
    uint64_t v9 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    *(void *)&long long v10 = (int)v8;
    *((void *)&v10 + 1) = SHIDWORD(v8);
    *(_OWORD *)&v31[8] = v10;
    *(void *)&unsigned char v31[24] = 1;
    v32[0] = v33;
    long long v53 = *(_OWORD *)v31;
    long long v54 = *(_OWORD *)&v31[16];
    v33[2] = 0x10DE000010B5;
    v38[0] = 0x100000001;
    v38[2] = 0x10DE000010B5;
    v43[0] = 0x100000001;
    v43[2] = 0x10DE000010B5;
    long long v46 = 0u;
    long long v45 = 0u;
    v32[3] = v50;
    long long v52 = 0u;
    v50[0] = 0x100000001;
    v50[2] = 0x10DE000010B5;
    v58[0] = 0x100000001;
    v58[2] = 0x10DE000010B5;
    long long v61 = 0u;
    long long v62 = 0u;
    long long v60 = 0u;
    v65[0] = 0x100000001;
    memset(v67, 0, 48);
    v65[2] = 0x10DE000010B5;
    v69[0] = 0x100000001;
    v69[2] = 0x10DE000010B5;
    long long v72 = 0u;
    long long v73 = 0u;
    long long v71 = 0u;
    v76[0] = 0x100000001;
    memset(v80, 0, sizeof(v80));
    v57[3] = v76;
    uint64_t v79 = 0;
    long long v78 = 0u;
    v76[2] = 0x10DE000010B5;
    v83[0] = 0x100000001;
    v83[2] = 0x10DE000010B5;
    long long v85 = 0u;
    long long v86 = 0u;
    long long v87 = 0u;
    v90[0] = 0x100000001;
    v90[2] = 0x10DE000010B5;
    memset(&v92[2], 0, 32);
    memset(v92, 0, 24);
    v94[0] = 0x100000001;
    v94[2] = 0x10DE000010B5;
    long long v98 = 0u;
    long long v97 = 0u;
    long long v96 = 0u;
    v101[0] = 0x100000001;
    v101[2] = 0x10DE000010B5;
    memset(&v103[2], 0, 32);
    memset(v103, 0, 24);
    *(void *)&long long v10 = (int)v9;
    *((void *)&v10 + 1) = SHIDWORD(v9);
    long long v30 = v10;
    v35[1] = *(_OWORD *)v31;
    v35[2] = *(_OWORD *)&v31[16];
    v40[2] = *(_OWORD *)&v31[16];
    v40[1] = *(_OWORD *)v31;
    v35[0] = v10;
    v40[0] = v10;
    long long v47 = *(_OWORD *)&v31[16];
    v33[1] = v35;
    int v34 = 3;
    v38[1] = v40;
    int v39 = 3;
    v43[1] = &v45;
    int v44 = 3;
    v50[1] = &v52;
    int v51 = 3;
    v32[1] = v38;
    v32[2] = v43;
    v58[1] = &v60;
    int v59 = 3;
    uint64_t v63 = v64;
    int v66 = 3;
    v67[6] = v68;
    v69[1] = &v71;
    int v70 = 3;
    uint64_t v74 = v75;
    int v77 = 3;
    uint64_t v81 = v82;
    v83[1] = &v85;
    uint64_t v88 = v89;
    v90[1] = v92;
    v92[6] = v93;
    v94[1] = &v96;
    uint64_t v99 = v100;
    v101[1] = v103;
    int v84 = 3;
    int v91 = 3;
    int v95 = 3;
    int v102 = 3;
    v103[6] = v104;
    v57[1] = v65;
    v57[2] = v69;
    v57[4] = v83;
    v57[6] = v94;
    int v108 = 2080374784;
    v109 &= 0x7Cu;
    char v107 = 16;
    __int16 v106 = -24503;
    v105[0] = &v106;
    int v112 = 2080374784;
    v113 &= 0x7Cu;
    __int16 v110 = -24503;
    char v111 = 16;
    v105[1] = &v110;
    int v116 = 2080374784;
    v117 &= 0x7Cu;
    __int16 v114 = -24503;
    v121 &= 0x7Cu;
    v125 &= 0x7Cu;
    v129 &= 0x7Cu;
    v133 &= 0x7Cu;
    char v115 = 16;
    v105[2] = &v114;
    int v120 = 2080374784;
    __int16 v118 = -24503;
    v65[1] = v67;
    char v119 = 16;
    v105[3] = &v118;
    int v124 = 2080374784;
    __int16 v122 = -24503;
    v76[1] = &v78;
    char v123 = 16;
    v105[4] = &v122;
    int v128 = 2080374784;
    __int16 v126 = -24503;
    v57[5] = v90;
    char v127 = 16;
    v105[5] = &v126;
    int v132 = 2080374784;
    __int16 v130 = -24503;
    v57[7] = v101;
    char v131 = 16;
    v105[6] = &v130;
    int v136 = 2080374784;
    v137 &= 0x7Cu;
    __int16 v134 = -24503;
    char v135 = 16;
    v105[7] = &v134;
    uint64_t v11 = *((void *)a2 + 2);
    uint64_t v12 = 16 * *((int *)a2 + 6);
    uint64_t v36 = v37;
    v37[0] = v12;
    v37[1] = v11;
    uint64_t v13 = *((void *)a2 + 4);
    uint64_t v14 = 16 * *((int *)a2 + 10);
    unint64_t v41 = v42;
    v42[0] = v14;
    v42[1] = v13;
    long long v45 = v10;
    long long v46 = *(_OWORD *)v31;
    v49[1] = *((void *)a2 + 6);
    uint64_t v15 = 16 * *((int *)a2 + 14);
    uint64_t v48 = v49;
    v49[0] = v15;
    long long v52 = v10;
    v56[1] = *((void *)a2 + 8);
    v57[0] = v58;
    uint64_t v16 = 16 * *((int *)a2 + 18);
    float64x2_t v55 = v56;
    v56[0] = v16;
    uint64_t v17 = *((void *)a2 + 26);
    *(void *)&long long v10 = (int)v17;
    *((void *)&v10 + 1) = SHIDWORD(v17);
    long long v60 = v10;
    *(void *)&long long v61 = 0;
    uint64_t v18 = *((int *)a2 + 55);
    *((void *)&v61 + 1) = *((int *)a2 + 54);
    *(void *)&long long v62 = v18;
    *((void *)&v62 + 1) = 1;
    v64[1] = *((void *)a2 + 10);
    v64[0] = 16 * *((int *)a2 + 22);
    uint64_t v19 = *((int *)a2 + 57);
    v67[0] = *((int *)a2 + 56);
    v67[1] = v19;
    v67[2] = 0;
    uint64_t v20 = *((void *)a2 + 29);
    uint64_t v21 = *((void *)a2 + 30);
    *(void *)&long long v10 = (int)v20;
    *((void *)&v10 + 1) = SHIDWORD(v20);
    *(_OWORD *)&v67[3] = v10;
    v67[5] = 1;
    v68[1] = *((void *)a2 + 12);
    v68[0] = 16 * *((int *)a2 + 26);
    *(void *)&long long v10 = (int)v21;
    *((void *)&v10 + 1) = SHIDWORD(v21);
    long long v71 = v10;
    *(void *)&long long v72 = 0;
    uint64_t v22 = *((int *)a2 + 63);
    *((void *)&v72 + 1) = *((int *)a2 + 62);
    *(void *)&long long v73 = v22;
    *((void *)&v73 + 1) = 1;
    v75[1] = *((void *)a2 + 14);
    v75[0] = 16 * *((int *)a2 + 30);
    *(void *)&long long v78 = *((int *)a2 + 64);
    *((void *)&v78 + 1) = *((int *)a2 + 65);
    uint64_t v23 = *((void *)a2 + 33);
    uint64_t v24 = *((void *)a2 + 34);
    *(void *)&long long v10 = (int)v23;
    *((void *)&v10 + 1) = SHIDWORD(v23);
    *(_OWORD *)uint64_t v80 = v10;
    *(void *)&v80[16] = 1;
    v82[1] = *((void *)a2 + 16);
    v82[0] = 16 * *((int *)a2 + 34);
    *(void *)&long long v10 = (int)v24;
    *((void *)&v10 + 1) = SHIDWORD(v24);
    long long v85 = v10;
    *(void *)&long long v86 = 0;
    *((void *)&v86 + 1) = *((int *)a2 + 70);
    *(void *)&long long v87 = *((int *)a2 + 71);
    *((void *)&v87 + 1) = 1;
    v89[1] = *((void *)a2 + 18);
    v89[0] = 16 * *((int *)a2 + 38);
    v92[0] = *((int *)a2 + 72);
    v92[1] = *((int *)a2 + 73);
    uint64_t v25 = *((void *)a2 + 37);
    uint64_t v26 = *((void *)a2 + 38);
    *(void *)&long long v10 = (int)v25;
    *((void *)&v10 + 1) = SHIDWORD(v25);
    *(_OWORD *)&v92[3] = v10;
    v92[5] = 1;
    v93[1] = *((void *)a2 + 20);
    v93[0] = 16 * *((int *)a2 + 42);
    *(void *)&long long v10 = (int)v26;
    *((void *)&v10 + 1) = SHIDWORD(v26);
    long long v96 = v10;
    *(void *)&long long v97 = 0;
    *((void *)&v97 + 1) = *((int *)a2 + 78);
    *(void *)&long long v98 = *((int *)a2 + 79);
    *((void *)&v98 + 1) = 1;
    v100[1] = *((void *)a2 + 22);
    v100[0] = 16 * *((int *)a2 + 46);
    v103[0] = *((int *)a2 + 80);
    v103[1] = *((int *)a2 + 81);
    uint64_t v27 = *((void *)a2 + 41);
    *(void *)&long long v10 = (int)v27;
    *((void *)&v10 + 1) = SHIDWORD(v27);
    *(_OWORD *)&v103[3] = v10;
    v103[5] = 1;
    v104[1] = *((void *)a2 + 24);
    v104[0] = 16 * *((int *)a2 + 50);
    uint64_t v29 = (*(uint64_t (**)(HGNode *, void))(*(void *)this + 320))(this, 0);
    v7(&v30, v32, &v29, v105, v57);
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = (*(uint64_t (**)(HGNode *, HGTile *))(*(void *)this + 176))(this, a2);
  }
  HGStats::ProfilerScopeGuard::~ProfilerScopeGuard((HGStats::ProfilerScopeGuard *)v138);
  return v6;
}

void sub_1B7792CB4(_Unwind_Exception *a1)
{
  HGStats::ProfilerScopeGuard::~ProfilerScopeGuard((HGStats::ProfilerScopeGuard *)(v1 - 64));
  _Unwind_Resume(a1);
}

void sub_1B7792CC8(_Unwind_Exception *a1)
{
  HGStats::ProfilerScopeGuard::~ProfilerScopeGuard((HGStats::ProfilerScopeGuard *)(v1 - 64));
  _Unwind_Resume(a1);
}

uint64_t HGNode::RenderTile(HGNode *this, HGTile *a2)
{
  return 0;
}

uint64_t HGNode::GetProperty(HGNode *this, int a2, uint64_t a3)
{
  unsigned int v3 = a3;
  uint64_t result = 1;
  switch(a2)
  {
    case 0:
      return result;
    case 2:
      uint64_t v6 = *((void *)this + 40);
      if (v6) {
        goto LABEL_19;
      }
      return 0;
    case 3:
      uint64_t v7 = *((void *)this + 40);
      if (!v7) {
        return result;
      }
      return *(unsigned __int16 *)(v7 + 52);
    case 4:
      uint64_t v8 = *((void *)this + 40);
      if (!v8) {
        return result;
      }
      return *(unsigned __int8 *)(v8 + 56);
    case 5:
      uint64_t v9 = *((void *)this + 40);
      if (!v9) {
        goto LABEL_37;
      }
      unsigned int v10 = *(unsigned __int16 *)(v9 + 52);
      if (v10 >= a3) {
        return a3;
      }
      else {
        return v10;
      }
    case 6:
      uint64_t v11 = *((void *)this + 40);
      if (v11)
      {
        unsigned int v12 = *(unsigned __int8 *)(v11 + 56);
        if (v12 >= a3) {
          return a3;
        }
        else {
          return v12;
        }
      }
      else
      {
LABEL_37:
        if (a3 <= 1) {
          return a3;
        }
        else {
          return 1;
        }
      }
    case 7:
      uint64_t v6 = *((void *)this + 8);
      if (!v6) {
        return 0;
      }
LABEL_19:
      return HGLimits::isenv((HGLimits *)(v6 + 16));
    case 8:
      uint64_t v7 = *((void *)this + 8);
      if (!v7) {
        return result;
      }
      return *(unsigned __int16 *)(v7 + 52);
    case 9:
      uint64_t v8 = *((void *)this + 8);
      if (!v8) {
        return result;
      }
      return *(unsigned __int8 *)(v8 + 56);
    case 10:
      uint64_t v7 = *((void *)this + 8);
      if (!v7) {
        return a3 != 0;
      }
      uint64_t v13 = *((void *)this + 40);
      if (v13) {
        unsigned int v14 = *(unsigned __int16 *)(v13 + 52);
      }
      else {
        unsigned int v14 = 1;
      }
      if (v14 <= a3) {
        return *(unsigned __int16 *)(v7 + 52);
      }
      uint64_t v18 = *((void *)this + 37);
      if (0x6DB6DB6DB6DB6DB7 * ((*((void *)this + 38) - v18) >> 3) > (unint64_t)a3
        && *(void *)(v18 + 56 * a3))
      {
        return *(unsigned int *)(v18 + 56 * a3 + 24);
      }
      else
      {
        return (*((_DWORD *)this + 67) + a3);
      }
    case 11:
      uint64_t v8 = *((void *)this + 8);
      if (!v8) {
        return a3 != 0;
      }
      uint64_t v15 = *((void *)this + 40);
      if (v15) {
        unsigned int v16 = *(unsigned __int8 *)(v15 + 56);
      }
      else {
        unsigned int v16 = 1;
      }
      if (v16 <= a3) {
        return *(unsigned __int8 *)(v8 + 56);
      }
      uint64_t v19 = *((void *)this + 37);
      if (0x6DB6DB6DB6DB6DB7 * ((*((void *)this + 38) - v19) >> 3) > (unint64_t)a3
        && *(void *)(v19 + 56 * a3))
      {
        return *(unsigned int *)(v19 + 56 * a3 + 40);
      }
      else
      {
        return (*((_DWORD *)this + 71) + a3);
      }
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
      return 0xFFFFFFFFLL;
    case 23:
      uint64_t result = (*(uint64_t (**)(HGNode *, uint64_t))(*(void *)this + 128))(this, a3);
      if (!result) {
        return result;
      }
      uint64_t v17 = *((void *)this + 37);
      return 0x6DB6DB6DB6DB6DB7 * ((*((void *)this + 38) - v17) >> 3) > (unint64_t)v3
          && *(void *)(v17 + 56 * v3) != 0;
    default:
      return 0;
  }
}

BOOL HGNode::IsMergedWithInput(HGNode *this, unint64_t a2)
{
  uint64_t v2 = *((void *)this + 37);
  return 0x6DB6DB6DB6DB6DB7 * ((*((void *)this + 38) - v2) >> 3) > a2 && *(void *)(v2 + 56 * a2) != 0;
}

HGNode *HGNode::PreBuffering(HGNode *this, HGRenderer *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!*((unsigned char *)this + 105))
  {
    unsigned int v3 = this;
    *((unsigned char *)this + 105) = 1;
    this = (HGNode *)(*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2);
    if (this)
    {
      this = (HGNode *)HGRenderer::DepthManager(a2, 0);
      if (*((unsigned char *)this + 40))
      {
        int v4 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 1);
        int v5 = *((_DWORD *)v3 + 42);
        int v6 = *((_DWORD *)v3 + 43);
        int v7 = *((_DWORD *)v3 + 44);
        int v8 = *((_DWORD *)v3 + 45);
        HGTraceGuard::HGTraceGuard((HGTraceGuard *)v22, "depth", 1, "HGNode::BufferingNode");
        unsigned __int8 v11 = atomic_load(HGLogger::_enabled);
        if (v11) {
          HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"node will be cached! pre-alloc the depth buffer...\n", v9, v10);
        }
        uint64_t v12 = (v5 - v4);
        uint64_t v13 = (v4 + v7);
        uint64_t v14 = (v6 - v4);
        uint64_t v15 = (v4 + v8);
        unsigned __int8 v16 = atomic_load(HGLogger::_enabled);
        if (v16) {
          HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"allocated depth : %d %d %d %d\n", v9, v10, v12, v14, v13, v15);
        }
        uint64_t v17 = HGObject::operator new(0x80uLL);
        HGBuffer::HGBuffer((uint64_t)v17, v12 | (v14 << 32), v13 | (v15 << 32), 28);
        *((void *)v3 + 12) = v17;
        unsigned __int8 v20 = atomic_load(HGLogger::_enabled);
        if (v20) {
          HGLogger::log((HGLogger *)"depth", (const char *)1, (HGLogger *)"cached : %p\n", v18, v19, *((void *)v3 + 12));
        }
        *(_OWORD *)uint64_t v23 = xmmword_1B7E75890;
        HGRenderUtils::BufferFiller::BufferFiller((HGRenderUtils::BufferFiller *)v21);
      }
    }
  }
  return this;
}

void sub_1B7793278(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  uint64_t v7 = va_arg(va1, void);
  HGRenderUtils::BufferFiller::~BufferFiller((HGRenderUtils::BufferFiller *)va);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va1);
  _Unwind_Resume(a1);
}

void sub_1B7793294(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77932A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  HGObject::operator delete(v15);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a15);
  _Unwind_Resume(a1);
}

void sub_1B77932C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t HGNode::PreTileBuffering(uint64_t result)
{
  if (!*(unsigned char *)(result + 106)) {
    *(unsigned char *)(result + 106) = 1;
  }
  return result;
}

uint64_t HGNode::RenderInputOrder(HGNode *this, uint64_t a2)
{
  return a2;
}

uint64_t HGNode::PullTextures(HGNode *this, HGGPURenderer **a2, int a3)
{
  if (!*((void *)this + 10) || (*((unsigned char *)this + 18) & 1) != 0) {
    return 0;
  }
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  int v8 = *((_DWORD *)this + 71) + a3;
  do
  {
    uint64_t v10 = (*(uint64_t (**)(HGNode *, uint64_t))(*(void *)this + 440))(this, v7);
    uint64_t v11 = (*(uint64_t (**)(HGNode *, uint64_t))(*(void *)this + 128))(this, v10);
    if (v11)
    {
      uint64_t v12 = *(void *)(*((void *)this + 10) + 8 * (int)v10);
      if (v12)
      {
        if ((*(unsigned char *)(v12 + 14) & 1) == 0)
        {
          uint64_t v13 = *((void *)this + 37);
          if (0x6DB6DB6DB6DB6DB7 * ((*((void *)this + 38) - v13) >> 3) > (unint64_t)(int)v10
            && (uint64_t v9 = *(void *)(v13 + 56 * (int)v10)) != 0)
          {
            uint64_t v6 = (*(unsigned int (**)(uint64_t, HGGPURenderer **, void))(*(void *)v9 + 472))(v9, a2, (*(_DWORD *)(v13 + 56 * (int)v10 + 40) + a3))+ v6;
          }
          else
          {
            int v14 = v8 + v10;
            uint64_t v15 = &a2[v8] + (int)v10;
            uint64_t v17 = v15[21];
            unsigned __int8 v16 = (unsigned int **)(v15 + 21);
            if (!v17)
            {
              uint64_t v18 = v14;
              uint64_t v19 = *(void *)(v11 + 144);
              uint64_t *v16 = HGGPURenderer::GetNodeTexture(*a2, (HGNode *)v19, *(HGRect *)((char *)&a2[2 * v14 + 4] + 4), 0, 1u);
              unsigned __int8 v22 = atomic_load(HGLogger::_enabled);
              if (v22) {
                HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"rendering leaf (%p, %x) to texture(%p, %d)\n", v20, v21, v19, *(unsigned int *)(v19 + 12), *v16, v18);
              }
              uint64_t v6 = (v6 + 1);
            }
          }
        }
      }
    }
    uint64_t v7 = (v7 + 1);
  }
  while (v7 != 8);
  return v6;
}

uint64_t HGNode::PullMetalTextures(HGNode *this, HGRenderer **a2, int a3)
{
  if (*((void *)this + 10) && (*((unsigned char *)this + 18) & 1) == 0)
  {
    int v4 = a3;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    int v8 = *((_DWORD *)this + 71) + a3;
    int v34 = v8;
    while (1)
    {
      uint64_t v10 = (*(uint64_t (**)(HGNode *, uint64_t))(*(void *)this + 440))(this, v7);
      uint64_t v11 = (*(uint64_t (**)(HGNode *, uint64_t))(*(void *)this + 128))(this, v10);
      if (v11)
      {
        uint64_t v12 = *(void *)(*((void *)this + 10) + 8 * (int)v10);
        if (v12)
        {
          if ((*(unsigned char *)(v12 + 14) & 1) == 0)
          {
            uint64_t v13 = (HGNode *)v11;
            uint64_t v14 = *((void *)this + 37);
            if (0x6DB6DB6DB6DB6DB7 * ((*((void *)this + 38) - v14) >> 3) > (unint64_t)(int)v10
              && (uint64_t v15 = *(void *)(v14 + 56 * (int)v10)) != 0)
            {
              uint64_t v6 = (*(unsigned int (**)(uint64_t, HGRenderer **, void))(*(void *)v15 + 480))(v15, a2, (*(_DWORD *)(v14 + 56 * (int)v10 + 40) + v4))+ v6;
            }
            else
            {
              unsigned __int8 v16 = &a2[v8] + (int)v10;
              uint64_t v18 = v16[21];
              uint64_t v17 = v16 + 21;
              if (!v18)
              {
                uint64_t v19 = v8 + (int)v10;
                Output = HGRenderer::GetOutput(*a2, v13);
                uint64_t v21 = &a2[2 * v19];
                uint64_t v23 = *(uint64_t *)((char *)v21 + 36);
                unsigned __int8 v22 = (uint64_t *)((char *)v21 + 36);
                *(void *)&v36.int var0 = v23;
                *(void *)&v36.int var2 = v22[1];
                NodeBitmap = HGGPURenderer::GetNodeBitmap(*a2, Output, v36, 0, 1u);
                uint64_t v25 = HGGPURenderer::ConvertToNonGLTexture(*a2, NodeBitmap);
                uint64_t v26 = v25;
                int v27 = *((_DWORD *)v25 + 3);
                uint64_t v33 = v19;
                if ((v27 & 0x30) != 0)
                {
                  if ((~v27 & 0x120) != 0) {
                    goto LABEL_23;
                  }
LABEL_22:
                  if (HGRectIsNull(*v22, v22[1])) {
                    goto LABEL_23;
                  }
                  uint64_t v29 = (HGTexture *)HGObject::operator new(0x80uLL);
                  HGTexture::HGTexture(v29, *(HGRect *)v22, v26);
                }
                else
                {
                  if ((~v27 & 0x120) == 0 || *((void *)v25 + 10) != 0) {
                    goto LABEL_22;
                  }
LABEL_23:
                  uint64_t v29 = (HGTexture *)HGObject::operator new(0x80uLL);
                  HGTexture::HGTexture(v29, *(HGRect *)((char *)v26 + 20), v26);
                }
                HGGPURenderer *v17 = v29;
                (*(void (**)(HGBitmap *))(*(void *)v26 + 24))(v26);
                (*(void (**)(HGBitmap *))(*(void *)NodeBitmap + 24))(NodeBitmap);
                unsigned __int8 v32 = atomic_load(HGLogger::_enabled);
                if (v32) {
                  HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"rendering leaf (%p, %x) to texture(%p, %d)\n", v30, v31, Output, *((unsigned int *)Output + 3), *v17, v33);
                }
                uint64_t v6 = (v6 + 1);
                int v8 = v34;
                int v4 = a3;
              }
            }
          }
        }
      }
      uint64_t v7 = (v7 + 1);
      if (v7 == 8) {
        return v6;
      }
    }
  }
  return 0;
}

void sub_1B7793814(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B7793828(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGNode::PageBegin(HGNode *this, HGPage *a2, int a3, int32x4_t *a4)
{
  if (!a4) {
    return 0;
  }
  if ((*(unsigned int (**)(HGNode *, uint64_t, void))(*(void *)this + 168))(this, 2, 0)) {
    *((void *)a2 + 30) = this;
  }
  uint64_t v63 = (HGShaderBinding *)((char *)this + 260);
  HGHandler::Push(a4, (const HGShaderBinding *)((char *)this + 260));
  uint64_t DOD = HGRenderer::GetDOD(*(HGRenderer **)a2, this);
  (*(void (**)(int32x4_t *, uint64_t, uint64_t, void, void, void, void))(a4->i64[0] + 24))(a4, DOD, v9, *((void *)a2 + 2), *((void *)a2 + 3), 0, 0);
  (*(void (**)(HGNode *, int32x4_t *))(*(void *)this + 200))(this, a4);
  unint64_t v10 = 0;
  uint64_t v11 = 0;
  char v12 = 0;
  int v13 = a4[11].i32[0] + a3;
  uint64_t v62 = v13;
  int v65 = v13 + 1;
  int v66 = a2;
  uint64_t v67 = (char *)a2 + 8 * v13 + 176;
  do
  {
    uint64_t v16 = (*(uint64_t (**)(HGNode *, unint64_t))(*(void *)this + 128))(this, v10);
    if (v16)
    {
      uint64_t v17 = (HGNode *)v16;
      uint64_t v18 = *((void *)this + 37);
      if (0x6DB6DB6DB6DB6DB7 * ((*((void *)this + 38) - v18) >> 3) > v10 && *(void *)(v18 + 56 * v10))
      {
        if (v12)
        {
LABEL_5:
          int32x4_t v14 = HGHandler::Push(a4, (const HGShaderBinding *)(v18 + 56 * v10 + 16));
          uint64_t v11 = (*(unsigned int (**)(__n128))(**(void **)(*((void *)this + 37) + 56 * v10) + 488))((__n128)v14)
              + v11;
          int32x4_t v15 = HGHandler::Pop(a4, (const HGShaderBinding *)(*((void *)this + 37) + 56 * v10 + 16));
          char v12 = 1;
          goto LABEL_6;
        }
      }
      else
      {
        unsigned int v64 = v11;
        if (v12) {
          int32x4_t v15 = HGHandler::Push(a4, v63);
        }
        uint64_t v19 = (unsigned char *)*((void *)a2 + v10 + v62 + 21);
        unsigned __int8 v20 = v67;
        if (v19)
        {
          if ((v19[12] & 0x10) != 0)
          {
            uint64_t v27 = v26[40];
            uint64_t v28 = a2;
            uint64_t v29 = HGRenderer::GetDOD(*(HGRenderer **)a2, v17);
            uint64_t v31 = v30;
            uint64_t v32 = *(void *)(v26 + 5);
            uint64_t v33 = *(void *)(v26 + 7);
            uint64_t TextureRect = HGGLTexture::GetTextureRect((HGGLTexture *)v26);
            unsigned int v35 = v26[5];
            unsigned int v36 = v26[6];
            unsigned __int8 v20 = v67;
            LODWORD(v60) = -v35;
            HIDWORD(v60) = -v36;
            uint64_t v37 = v29;
            a2 = v28;
            (*(void (**)(int32x4_t *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a4->i64[0] + 32))(a4, v27, v37, v31, v32, v33, TextureRect, v38, v60);
          }
          else
          {
            if (v21)
            {
              unsigned __int8 v22 = v21;
              uint64_t v23 = HGRenderer::GetDOD(*(HGRenderer **)a2, v17);
              uint64_t v25 = v24;
              *(void *)&v69.int var0 = v23;
              *(void *)&v69.int var2 = v25;
              HGMetalHandler::InitTextureUnit(v22, v69, v10 + v62);
            }
          }
        }
        else
        {
          (*(void (**)(int32x4_t *, void, void, void, void, void, void, void, int32x4_t, void))(a4->i64[0] + 32))(a4, 0, 0, 0, 0, 0, 0, 0, v15, 0);
        }
        (*(void (**)(HGNode *, int32x4_t *, unint64_t))(*(void *)this + 208))(this, a4, v10);
        if (v10 == 7)
        {
LABEL_35:
          uint64_t v11 = v64;
LABEL_36:
          int32x4_t v15 = HGHandler::Pop(a4, v63);
          goto LABEL_37;
        }
        uint64_t v39 = 56 * v10 + 56;
        while (1)
        {
          uint64_t v40 = (*(uint64_t (**)(HGNode *, unint64_t))(*(void *)this + 128))(this, v10 + 1);
          if (!v40)
          {
            char v12 = 0;
            ++v10;
            uint64_t v11 = v64;
            goto LABEL_6;
          }
          unint64_t v41 = (HGNode *)v40;
          uint64_t v42 = *((void *)this + 37);
          if (0x6DB6DB6DB6DB6DB7 * ((*((void *)this + 38) - v42) >> 3) > v10 + 1)
          {
            if (*(void *)(v42 + v39)) {
              break;
            }
          }
          uint64_t v43 = *(unsigned char **)&v20[8 * v10];
          if (v43)
          {
            if ((v43[12] & 0x10) != 0)
            {
              unsigned int v68 = *((_DWORD *)v49 + 40);
              uint64_t v50 = HGRenderer::GetDOD(*(HGRenderer **)a2, v41);
              uint64_t v52 = v51;
              uint64_t v53 = *(void *)(v49 + 20);
              uint64_t v54 = *(void *)(v49 + 28);
              uint64_t v55 = HGGLTexture::GetTextureRect((HGGLTexture *)v49);
              LODWORD(v61) = -*((_DWORD *)v49 + 5);
              HIDWORD(v61) = -*((_DWORD *)v49 + 6);
              uint64_t v56 = v52;
              uint64_t v57 = v53;
              a2 = v66;
              unsigned __int8 v20 = v67;
              (*(void (**)(int32x4_t *, void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a4->i64[0] + 32))(a4, v68, v50, v56, v57, v54, v55, v58, v61);
            }
            else
            {
              if (v44)
              {
                long long v45 = v44;
                uint64_t v46 = HGRenderer::GetDOD(*(HGRenderer **)a2, v41);
                uint64_t v48 = v47;
                *(void *)&v70.int var0 = v46;
                *(void *)&v70.int var2 = v48;
                HGMetalHandler::InitTextureUnit(v45, v70, v65 + v10);
              }
            }
          }
          else
          {
            (*(void (**)(int32x4_t *, void, void, void, void, void, void, void, void))(a4->i64[0] + 32))(a4, 0, 0, 0, 0, 0, 0, 0, 0);
          }
          (*(void (**)(HGNode *, int32x4_t *, unint64_t))(*(void *)this + 208))(this, a4, ++v10);
          v39 += 56;
          if (v10 == 7) {
            goto LABEL_35;
          }
        }
        ++v10;
        LODWORD(v11) = v64;
      }
      HGHandler::Pop(a4, v63);
      uint64_t v18 = *((void *)this + 37);
      goto LABEL_5;
    }
LABEL_6:
    ++v10;
  }
  while (v10 != 8);
  if ((v12 & 1) == 0) {
    goto LABEL_36;
  }
LABEL_37:
  (*(void (**)(int32x4_t *, int32x4_t))(a4->i64[0] + 40))(a4, v15);
  return v11;
}

HGNode *HGNode::PageEnd(HGNode *this, HGPage *a2, int a3, HGHandler *a4)
{
  if (a4)
  {
    if (*((void *)a2 + 30)) {
      this = (HGNode *)*((void *)a2 + 30);
    }
    (*(void (**)(HGNode *, HGHandler *))(*(void *)this + 216))(this, a4);
    int v5 = *(uint64_t (**)(void))(**(void **)a2 + 392);
    return (HGNode *)v5();
  }
  return this;
}

uint64_t HGNode::RenderPage(HGNode *this, HGRect *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  unint64_t v10 = a2;
  if (this) {
    (*(void (**)(HGNode *, HGRect *, void))(*(void *)this + 472))(this, a2, 0);
  }
  int v4 = (const char *)(*(uint64_t (**)(HGNode *))(*(void *)this + 48))(this);
  snprintf(__str, 0x100uLL, "%s::RenderPage( [%d %d %d %d])", v4, a2[1].var0, a2[1].var1, a2[1].var2, a2[1].var3);
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v9, "gpu", 1, __str);
  uint64_t v5 = (*(uint64_t (**)(HGNode *, HGRect *, void))(*(void *)this + 504))(this, a2, 0);
  uint64_t v6 = v5;
  if (*(void *)&a2->var2 != v5) {
    *(void *)&a2->int var2 = v5;
  }
  (*(void (**)(void, uint64_t))(**(void **)&a2->var0 + 144))(*(void *)&a2->var0, v5);
  (*(void (**)(void, void, void, void, void))(**(void **)&a2->var0 + 152))(*(void *)&a2->var0, 0, *(void *)&a2[10].var2, 0, 0);
  (*(void (**)(void, uint64_t, void, void, void))(**(void **)&a2->var0 + 152))(*(void *)&a2->var0, 1, *(void *)&a2[11].var0, 0, 0);
  (*(void (**)(void, uint64_t, void, void, void))(**(void **)&a2->var0 + 152))(*(void *)&a2->var0, 2, *(void *)&a2[11].var2, 0, 0);
  (*(void (**)(void, uint64_t, void, void, void))(**(void **)&a2->var0 + 152))(*(void *)&a2->var0, 3, *(void *)&a2[12].var0, 0, 0);
  (*(void (**)(void, uint64_t, void, void, void))(**(void **)&a2->var0 + 152))(*(void *)&a2->var0, 4, *(void *)&a2[12].var2, 0, 0);
  (*(void (**)(void, uint64_t, void, void, void))(**(void **)&a2->var0 + 152))(*(void *)&a2->var0, 5, *(void *)&a2[13].var0, 0, 0);
  (*(void (**)(void, uint64_t, void, void, void))(**(void **)&a2->var0 + 152))(*(void *)&a2->var0, 6, *(void *)&a2[13].var2, 0, 0);
  (*(void (**)(void, uint64_t, void, void, void))(**(void **)&a2->var0 + 152))(*(void *)&a2->var0, 7, *(void *)&a2[14].var0, 0, 0);
  uint64_t v7 = (HGHandler *)(*(uint64_t (**)(void, void, HGNode *))(**(void **)&a2->var0 + 368))(*(void *)&a2->var0, *((void *)this + 8), this);
  (*(void (**)(HGNode *, HGRect *, void, HGHandler *))(*(void *)this + 488))(this, a2, 0, v7);
  (*(void (**)(HGNode *))(*(void *)this + 344))(this);
  HGGPURenderer::Rect(*(HGGPURenderer **)&a2->var0, v7, a2[1], 8);
  (*(void (**)(HGNode *))(*(void *)this + 352))(this);
  (*(void (**)(HGNode *, HGRect *, void, HGHandler *))(*(void *)this + 496))(this, a2, 0, v7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v9);
  HGPage::ReleaseTextures((HGPage *)a2);
  return v6;
}

void sub_1B77944B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, char a17)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGNode::RenderPageMetal(HGNode *this, HGPage *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  int v13 = a2;
  if (this) {
    (*(void (**)(HGNode *, HGPage *, void))(*(void *)this + 480))(this, a2, 0);
  }
  (*(void (**)(void, void))(**(void **)a2 + 144))(*(void *)a2, 0);
  int v4 = (const char *)(*(uint64_t (**)(HGNode *))(*(void *)this + 48))(this);
  snprintf(__str, 0x100uLL, "%s::RenderPageMetal( [%d %d %d %d])", v4, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 5), *((_DWORD *)a2 + 6), *((_DWORD *)a2 + 7));
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v12, "gpu", 1, __str);
  uint64_t v5 = (*(uint64_t (**)(HGNode *, HGPage *, uint64_t))(*(void *)this + 504))(this, a2, 1);
  uint64_t v6 = v5;
  if (*((void *)a2 + 1) != v5) {
    *((void *)a2 + 1) = v5;
  }
  unsigned int v7 = (*(uint64_t (**)(HGNode *))(*(void *)this + 520))(this);
  if (v7 > 1)
  {
    if (*((void *)a2 + 1)) {
      HGNode::RenderPageDeluxe(this, a2);
    }
    else {
      HGLogger::warning((HGLogger *)"HGNode::RenderPageMetal() could not find a valid rendering path.", v8, v9);
    }
  }
  else if (v7 || (uint64_t v10 = (*(uint64_t (**)(HGNode *, HGPage *))(*(void *)this + 512))(this, a2)) == 0)
  {
    (*(void (**)(HGNode *, HGPage *))(*(void *)this + 536))(this, a2);
  }
  else
  {
    (*(void (**)(HGNode *, HGPage *, uint64_t))(*(void *)this + 528))(this, a2, v10);
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v12);
  HGPage::ReleaseTextures(a2);
  return v6;
}

void sub_1B779479C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  HGPagePullMetalTexturesGuard::~HGPagePullMetalTexturesGuard((HGPage **)va1);
  _Unwind_Resume(a1);
}

const char *HGNode::RenderPageDeluxe(HGNode *this, const HGPage *a2)
{
  HGGPURenderer::FlushMetalCommandBuffer(*(HGGPURenderer **)a2);
  if ((*(unsigned int (**)(HGNode *))(*(void *)this + 520))(this) == 5)
  {
    uint64_t v5 = (HGBitmap *)*((void *)a2 + 1);
    uint64_t v33 = *(HGGPURenderer **)a2;
    long long v34 = *((_OWORD *)a2 + 1);
    CVBitmapStorage = HGCVBitmap::getCVBitmapStorage(v5, v4);
    unsigned int v7 = (HGBitmap *)*((void *)a2 + 21);
    if (v7) {
      unsigned int v36 = HGCVBitmap::getCVBitmapStorage(v7, v6);
    }
    uint64_t v8 = (HGBitmap *)*((void *)a2 + 22);
    if (v8) {
      uint64_t v37 = HGCVBitmap::getCVBitmapStorage(v8, v6);
    }
    uint64_t v9 = (HGBitmap *)*((void *)a2 + 23);
    if (v9) {
      uint64_t v38 = HGCVBitmap::getCVBitmapStorage(v9, v6);
    }
    uint64_t v10 = (HGBitmap *)*((void *)a2 + 24);
    if (v10) {
      uint64_t v39 = HGCVBitmap::getCVBitmapStorage(v10, v6);
    }
    uint64_t v11 = (HGBitmap *)*((void *)a2 + 25);
    if (v11) {
      uint64_t v40 = HGCVBitmap::getCVBitmapStorage(v11, v6);
    }
    uint64_t v12 = (HGBitmap *)*((void *)a2 + 26);
    if (v12) {
      unint64_t v41 = HGCVBitmap::getCVBitmapStorage(v12, v6);
    }
    int v13 = (HGBitmap *)*((void *)a2 + 27);
    if (v13) {
      uint64_t v42 = HGCVBitmap::getCVBitmapStorage(v13, v6);
    }
    int32x4_t v14 = (HGBitmap *)*((void *)a2 + 28);
    if (v14) {
      uint64_t v43 = HGCVBitmap::getCVBitmapStorage(v14, v6);
    }
    return (const char *)(*(uint64_t (**)(HGNode *, HGGPURenderer **))(*(void *)this + 544))(this, &v33);
  }
  uint64_t v32 = HGGPURenderer::ConvertToMetalTexture(*(HGMetalTexture ***)a2, *((HGBitmap **)a2 + 1));
  uint64_t v16 = (HGBitmap *)*((void *)a2 + 21);
  if (v16)
  {
    uint64_t v17 = HGGPURenderer::ConvertToMetalTexture(*(HGMetalTexture ***)a2, v16);
    uint64_t v18 = (HGBitmap *)*((void *)a2 + 22);
    if (v18) {
      goto LABEL_21;
    }
  }
  else
  {
    uint64_t v17 = 0;
    uint64_t v18 = (HGBitmap *)*((void *)a2 + 22);
    if (v18)
    {
LABEL_21:
      uint64_t v19 = HGGPURenderer::ConvertToMetalTexture(*(HGMetalTexture ***)a2, v18);
      unsigned __int8 v20 = (HGBitmap *)*((void *)a2 + 23);
      if (v20) {
        goto LABEL_22;
      }
      goto LABEL_30;
    }
  }
  uint64_t v19 = 0;
  unsigned __int8 v20 = (HGBitmap *)*((void *)a2 + 23);
  if (v20)
  {
LABEL_22:
    uint64_t v21 = HGGPURenderer::ConvertToMetalTexture(*(HGMetalTexture ***)a2, v20);
    unsigned __int8 v22 = (HGBitmap *)*((void *)a2 + 24);
    if (v22) {
      goto LABEL_23;
    }
    goto LABEL_31;
  }
LABEL_30:
  uint64_t v21 = 0;
  unsigned __int8 v22 = (HGBitmap *)*((void *)a2 + 24);
  if (v22)
  {
LABEL_23:
    uint64_t v23 = HGGPURenderer::ConvertToMetalTexture(*(HGMetalTexture ***)a2, v22);
    uint64_t v24 = (HGBitmap *)*((void *)a2 + 25);
    if (v24) {
      goto LABEL_24;
    }
    goto LABEL_32;
  }
LABEL_31:
  uint64_t v23 = 0;
  uint64_t v24 = (HGBitmap *)*((void *)a2 + 25);
  if (v24)
  {
LABEL_24:
    uint64_t v25 = HGGPURenderer::ConvertToMetalTexture(*(HGMetalTexture ***)a2, v24);
    uint64_t v26 = (HGBitmap *)*((void *)a2 + 26);
    if (v26) {
      goto LABEL_25;
    }
    goto LABEL_33;
  }
LABEL_32:
  uint64_t v25 = 0;
  uint64_t v26 = (HGBitmap *)*((void *)a2 + 26);
  if (v26)
  {
LABEL_25:
    uint64_t v27 = HGGPURenderer::ConvertToMetalTexture(*(HGMetalTexture ***)a2, v26);
    uint64_t v28 = (HGBitmap *)*((void *)a2 + 27);
    if (v28) {
      goto LABEL_26;
    }
LABEL_34:
    uint64_t v29 = 0;
    uint64_t v30 = (HGBitmap *)*((void *)a2 + 28);
    if (v30) {
      goto LABEL_27;
    }
LABEL_35:
    uint64_t v31 = 0;
    goto LABEL_36;
  }
LABEL_33:
  uint64_t v27 = 0;
  uint64_t v28 = (HGBitmap *)*((void *)a2 + 27);
  if (!v28) {
    goto LABEL_34;
  }
LABEL_26:
  uint64_t v29 = HGGPURenderer::ConvertToMetalTexture(*(HGMetalTexture ***)a2, v28);
  uint64_t v30 = (HGBitmap *)*((void *)a2 + 28);
  if (!v30) {
    goto LABEL_35;
  }
LABEL_27:
  uint64_t v31 = HGGPURenderer::ConvertToMetalTexture(*(HGMetalTexture ***)a2, v30);
LABEL_36:
  uint64_t v33 = *(HGGPURenderer **)a2;
  long long v34 = *((_OWORD *)a2 + 1);
  CVBitmapStorage = v32;
  unsigned int v36 = v17;
  uint64_t v37 = v19;
  uint64_t v38 = v21;
  uint64_t v39 = v23;
  uint64_t v40 = v25;
  unint64_t v41 = v27;
  uint64_t v42 = v29;
  uint64_t v43 = v31;
  uint64_t result = HGNode::RenderPageDeluxeMetalTextures((uint64_t)this, &v33);
  if (v31) {
    uint64_t result = (const char *)(*(uint64_t (**)(HGBitmap *))(*(void *)v31 + 24))(v31);
  }
  if (v29) {
    uint64_t result = (const char *)(*(uint64_t (**)(HGBitmap *))(*(void *)v29 + 24))(v29);
  }
  if (v27) {
    uint64_t result = (const char *)(*(uint64_t (**)(HGBitmap *))(*(void *)v27 + 24))(v27);
  }
  if (v25) {
    uint64_t result = (const char *)(*(uint64_t (**)(HGBitmap *))(*(void *)v25 + 24))(v25);
  }
  if (v23) {
    uint64_t result = (const char *)(*(uint64_t (**)(HGBitmap *))(*(void *)v23 + 24))(v23);
  }
  if (v21) {
    uint64_t result = (const char *)(*(uint64_t (**)(HGBitmap *))(*(void *)v21 + 24))(v21);
  }
  if (v19) {
    uint64_t result = (const char *)(*(uint64_t (**)(HGBitmap *))(*(void *)v19 + 24))(v19);
  }
  if (v17) {
    uint64_t result = (const char *)(*(uint64_t (**)(HGBitmap *))(*(void *)v17 + 24))(v17);
  }
  if (v32) {
    return (const char *)(*(uint64_t (**)(HGBitmap *))(*(void *)v32 + 24))(v32);
  }
  return result;
}

void sub_1B7794C84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
  }
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 24))(v16);
  }
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 24))(v15);
  }
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);
  }
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 24))(v13);
  }
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
  }
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
  }
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  }
  if (a9) {
    (*(void (**)(uint64_t))(*(void *)a9 + 24))(a9);
  }
  _Unwind_Resume(exception_object);
}

char *HGNode::CreateOutputBuffer(uint64_t a1, uint64_t a2, int a3)
{
  int v6 = 0;
  uint64_t v7 = *(void *)(a2 + 8);
  if ((*(unsigned char *)(a1 + 17) & 0x40) != 0 && v7) {
    int v6 = !HGRectIsEqual(*(void *)(v7 + 20), *(void *)(v7 + 28), *(void *)(a2 + 16), *(void *)(a2 + 24));
  }
  if (!v6 && v7 && (~*(_DWORD *)(v7 + 12) & 0x220) == 0)
  {
    MetalStorage = (HGMetalTexture *)HGMetalTexture::getMetalStorage((HGBitmap *)v7, (HGBitmap *)a2);
    uint64_t v9 = MetalStorage;
    int v10 = *(_DWORD *)(a1 + 16);
    if ((v10 & 0x8000) != 0)
    {
      unsigned int v11 = HGMetalTexture::hasComputeUsage(MetalStorage) ^ 1;
      if ((*(_DWORD *)(a1 + 16) & 0x1000) != 0) {
        goto LABEL_9;
      }
    }
    else
    {
      unsigned int v11 = 0;
      if ((v10 & 0x1000) != 0)
      {
LABEL_9:
        BOOL v12 = (*((unsigned char *)v9 + 12) & 1) == 0;
LABEL_12:
        int v6 = v11 | v12;
        goto LABEL_13;
      }
    }
    BOOL v12 = 0;
    goto LABEL_12;
  }
LABEL_13:
  if (v7) {
    BOOL v13 = v6 == 0;
  }
  else {
    BOOL v13 = 0;
  }
  if (v13)
  {
    (*(void (**)(uint64_t))(*(void *)v7 + 16))(v7);
    return (char *)v7;
  }
  else
  {
    uint64_t v14 = *(void *)a2;
    HGRect v15 = *(HGRect *)(a2 + 16);
    uint64_t v16 = *(unsigned int *)(a2 + 32);
    unsigned int v17 = *(_DWORD *)(a1 + 16);
    uint64_t v18 = *(unsigned __int8 *)(a2 + 248);
    return HGGPURenderer::CreateBuffer(v14, v15, v16, a3, (v17 >> 12) & 1, v18, (v17 >> 15) & 1);
  }
}

void *HGNode::PrepareMetalHandler(HGNode *this, const HGPage *a2)
{
  uint64_t result = (void *)(*(uint64_t (**)(void, void))(**(void **)a2 + 368))(*(void *)a2, *((void *)this + 8));
  if (result)
  {
  }
  return result;
}

uint64_t HGNode::RenderPageClassic(HGNode *this, HGBitmap **a2, std::string *a3)
{
  int v6 = (const char *)(*(uint64_t (**)(HGNode *))(*(void *)this + 48))(this);
  size_t v7 = strlen(v6);
  if (v7 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::string::size_type v8 = v7;
  if (v7 >= 0x17)
  {
    uint64_t v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v10 = v7 | 7;
    }
    uint64_t v11 = v10 + 1;
    p_dst = (std::string *)operator new(v10 + 1);
    __dst.__r_.__value_.__l.__size_ = v8;
    __dst.__r_.__value_.__r.__words[2] = v11 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_8;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v7;
  p_dst = &__dst;
  if (v7) {
LABEL_8:
  }
    memmove(p_dst, v6, v8);
  p_dst->__r_.__value_.__s.__data_[v8] = 0;
  HGMetalHandler::SetDebugLabel(a3, &__dst);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  HGMetalHandler::BindBuffer((HGMetalHandler *)a3, a2[1]);
  BOOL v13 = a2[21];
  if (v13) {
    __n128 v12 = HGMetalHandler::BindTexture((HGMetalTexture ***)a3, 0, v13);
  }
  uint64_t v14 = a2[22];
  if (v14) {
    __n128 v12 = HGMetalHandler::BindTexture((HGMetalTexture ***)a3, 1, v14);
  }
  HGRect v15 = a2[23];
  if (v15) {
    __n128 v12 = HGMetalHandler::BindTexture((HGMetalTexture ***)a3, 2, v15);
  }
  uint64_t v16 = a2[24];
  if (v16) {
    __n128 v12 = HGMetalHandler::BindTexture((HGMetalTexture ***)a3, 3, v16);
  }
  unsigned int v17 = a2[25];
  if (v17) {
    __n128 v12 = HGMetalHandler::BindTexture((HGMetalTexture ***)a3, 4, v17);
  }
  uint64_t v18 = a2[26];
  if (v18) {
    __n128 v12 = HGMetalHandler::BindTexture((HGMetalTexture ***)a3, 5, v18);
  }
  uint64_t v19 = a2[27];
  if (v19) {
    __n128 v12 = HGMetalHandler::BindTexture((HGMetalTexture ***)a3, 6, v19);
  }
  unsigned __int8 v20 = a2[28];
  if (v20) {
    __n128 v12 = HGMetalHandler::BindTexture((HGMetalTexture ***)a3, 7, v20);
  }
  (*(void (**)(HGNode *, HGBitmap **, void, std::string *, __n128))(*(void *)this + 488))(this, a2, 0, a3, v12);
  if (*((unsigned char *)this + 332))
  {
    HGMetalHandler::EnableBlending((uint64_t)a3);
    unsigned __int8 v22 = (const HGBlendingInfo *)(*(uint64_t (**)(HGNode *))(*(void *)this + 256))(this);
    __n128 v23 = HGMetalHandler::SetBlendingInfo((HGMetalHandler *)a3, v22);
    uint64_t v24 = (__n128 *)(*(uint64_t (**)(HGNode *, __n128))(*(void *)this + 272))(this, v23);
    __n128 v21 = HGMetalHandler::SetBlendingColor((__n128 *)a3, v24);
  }
  (*(void (**)(std::string *, HGBitmap *, HGBitmap *, uint64_t, __n128))(a3->__r_.__value_.__r.__words[0] + 192))(a3, a2[2], a2[3], 8, v21);
  return (*(uint64_t (**)(HGNode *, HGBitmap **, void, std::string *))(*(void *)this + 496))(this, a2, 0, a3);
}

void sub_1B7795310(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

std::string *HGNode::RenderPageCustom(HGNode *this, const HGPage *a2)
{
  return HGGPURenderer::CopyMetal(*(HGGPURenderer **)a2, *((HGBitmap **)a2 + 1), *((HGRect *)a2 + 1), *((HGBitmap **)a2 + 21));
}

const char *HGNode::RenderPageIOSurfaces(uint64_t a1, const char *a2, char *a3)
{
  return HGLogger::error((HGLogger *)"HGNode::RenderPageIOSurfaces is NOT implemented!", a2, a3);
}

const char *HGNode::RenderPageWithCommandBuffer(uint64_t a1, const char *a2, char *a3)
{
  return HGLogger::error((HGLogger *)"HGNode::RenderPageWithCommandBuffer is NOT implemented!", a2, a3);
}

const char *HGNode::RenderPageWithCommandEncoder(uint64_t a1, const char *a2, char *a3)
{
  return HGLogger::error((HGLogger *)"HGNode::RenderPageWithCommandEncoder is NOT implemented!", a2, a3);
}

const char *HGNode::RenderPageMetalTextures(uint64_t a1, const char *a2, char *a3)
{
  return HGLogger::error((HGLogger *)"HGNode::RenderPageMetalTextures is NOT implemented!", a2, a3);
}

uint64_t HGNode::SetFilter(uint64_t a1, int a2, char *a3)
{
  if (*(_DWORD *)(a1 + 328) == a2) {
    return 0;
  }
  *(_DWORD *)(a1 + 328) = a2;
  HGNode::ClearBits((HGNode *)a1, (const char *)0xFFFF, a3);
  return 1;
}

uint64_t HGNode::GetFilter(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(unsigned int *)(a1 + 328);
  if (a2)
  {
    if (result == -1) {
      return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 128))(a2, 23);
    }
  }
  return result;
}

uint64_t HGNode::BindTexture(HGNode *this, HGHandler *a2, int a3)
{
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  return 0;
}

uint64_t HGNode::Bind(HGNode *this, HGHandler *a2)
{
  return 0;
}

uint64_t HGNode::UnBind(HGNode *this, HGHandler *a2)
{
  return 0;
}

uint64_t HGNode::DoInplaceHardwareBlending(HGNode *this, HGGPURenderer *a2, HGNode *a3, float a4)
{
  int NodeRenderAPI = HGGPURenderer::GetNodeRenderAPI(a2, this);
  int v9 = HGGPURenderer::GetNodeRenderAPI(a2, a3);
  if (*((unsigned char *)this + 105)) {
    BOOL v11 = 0;
  }
  else {
    BOOL v11 = NodeRenderAPI == v9;
  }
  if (!v11) {
    return 0;
  }
  BOOL v13 = *(uint64_t (**)(HGNode *, __n128))(*(void *)this + 232);
  v10.n128_f32[0] = a4;

  return v13(this, v10);
}

uint64_t HGNode::SupportsInplaceHardwareBlending(HGNode *this, float a2)
{
  return 0;
}

HGNode *HGNode::EnableInplaceHardwareBlending(HGNode *this)
{
  *((unsigned char *)this + 332) = 1;
  return this;
}

HGNode *HGNode::DisableInplaceHardwareBlending(HGNode *this)
{
  *((unsigned char *)this + 332) = 0;
  return this;
}

__n128 HGNode::SetInPlaceHardwareBlendingInfo(HGNode *this, const HGBlendingInfo *a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *((_OWORD *)a2 + 1);
  *((_OWORD *)this + 21) = *(_OWORD *)a2;
  *((_OWORD *)this + 22) = v3;
  return result;
}

uint64_t HGNode::GetInPlaceHardwareBlendingInfo(HGNode *this)
{
  return (uint64_t)this + 336;
}

__n128 HGNode::SetInPlaceHardwareBlendingColor(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[24] = *a2;
  return result;
}

uint64_t HGNode::GetInPlaceHardwareBlendingColor(HGNode *this)
{
  return (uint64_t)this + 384;
}

HGNode *HGNode::SetInPlaceHardwareBlendingOpacity(HGNode *this, float a2)
{
  *((float *)this + 92) = a2;
  return this;
}

float HGNode::GetInPlaceHardwareBlendingOpacity(HGNode *this)
{
  return *((float *)this + 92);
}

uint64_t HGNode::IntermediateFormat(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t HGNode::CanBypassTiling()
{
  return 0;
}

uint64_t HGNode::SupportsGLSL(HGNode *this)
{
  return (*((unsigned __int8 *)this + 17) >> 1) & 1;
}

uint64_t HGNode::SupportsMetal(HGNode *this)
{
  return (*((unsigned __int8 *)this + 17) >> 2) & 1;
}

uint64_t HGNode::SupportsSWAIR(HGNode *this)
{
  return (*((unsigned __int8 *)this + 17) >> 3) & 1;
}

uint64_t HGNode::GetSWAIRProgram(HGNode *this)
{
  return 0;
}

uint64_t HGNode::GetParameterBuffer(HGNode *this, int a2)
{
  if (*((_DWORD *)this + 11) <= a2) {
    return 0;
  }
  else {
    return *((void *)this + 6) + 4 * a2;
  }
}

void HGNode3D::HGNode3D(HGNode3D *this)
{
  HGNode::HGNode((HGNode *)this);
  void *v1 = &unk_1F10D5338;
}

void HGNode3D::~HGNode3D(HGNode *this)
{
  HGNode::~HGNode(this);

  HGObject::operator delete(v1);
}

uint64_t HGNode3D::RenderFragment(uint64_t a1, const char *a2, char *a3)
{
  return 0;
}

uint64_t HGNode3D::RenderFragment_DEBUG(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 576))();
}

uint64_t HGNode3D::RenderTile(HGNode3D *this, int32x2_t *a2)
{
  __int32 v3 = a2[1].i32[0];
  int32x2_t v22 = *a2;
  int v4 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  __asm { FMOV            V0.4S, #1.0 }
  v25[9] = _Q0;
  v25[10] = xmmword_1B7E734D0;
  v25[11] = xmmword_1B7E77190;
  v25[12] = xmmword_1B7E73E70;
  memcpy(__dst, a2, sizeof(__dst));
  __dst[1] = vadd_s32(__dst[0], (int32x2_t)0x100000001);
  if (v4 >= 1)
  {
    int v10 = v3 - v22.i32[0];
    if (v10 >= 1)
    {
      int v11 = 0;
      *(float32x2_t *)v12.f32 = vadd_f32(vcvt_f32_s32(v22), (float32x2_t)0x3F0000003F000000);
      v12.i64[1] = 0x3F80000000000000;
      do
      {
        int v13 = v10;
        float32x4_t v21 = v12;
        do
        {
          float32x4_t v23 = v12;
          v25[0] = v12;
          v25[1] = v12;
          v25[2] = v12;
          v25[3] = v12;
          v25[4] = v12;
          v25[5] = v12;
          v25[6] = v12;
          v25[7] = v12;
          v25[8] = v12;
          (*(void (**)(HGNode3D *, _OWORD *, int32x2_t *))(*(void *)this + 576))(this, v25, __dst);
          int32x2_t v14 = __dst[2];
          int32x2_t v15 = __dst[4];
          *(void *)&__dst[2] += 16;
          *(void *)&__dst[4] += 16;
          int32x2_t v16 = __dst[6];
          int32x2_t v17 = __dst[8];
          *(void *)&__dst[6] += 16;
          *(void *)&__dst[8] += 16;
          __int32 v18 = __dst[0].i32[0] + 1;
          __int32 v19 = __dst[1].i32[0] + 1;
          ++__dst[0].i32[0];
          ++__dst[1].i32[0];
          float32x4_t v12 = vaddq_f32(v23, (float32x4_t)xmmword_1B7E736B0);
          --v13;
        }
        while (v13);
        __dst[2] = (int32x2_t)(*(void *)&v14 - 16 * v10 + 16 * __dst[3].i32[0] + 16);
        __dst[4] = (int32x2_t)(*(void *)&v15 - 16 * v10 + 16 * __dst[5].i32[0] + 16);
        __dst[6] = (int32x2_t)(*(void *)&v16 - 16 * v10 + 16 * __dst[7].i32[0] + 16);
        __dst[8] = (int32x2_t)(*(void *)&v17 - 16 * v10 + 16 * __dst[9].i32[0] + 16);
        __dst[0] = (int32x2_t)(__PAIR64__(__dst[0].u32[1], v18 - v10) + 0x100000000);
        __dst[1] = (int32x2_t)(__PAIR64__(__dst[1].u32[1], v19 - v10) + 0x100000000);
        float32x4_t v12 = vaddq_f32(v21, (float32x4_t)xmmword_1B7E736C0);
        ++v11;
      }
      while (v11 != v4);
    }
  }
  return 0;
}

uint64_t HGNode::GetProgramDescriptor@<X0>(HGNode *this@<X0>, void *a2@<X8>)
{
  uint64_t result = *((void *)this + 50);
  if (result)
  {
    *a2 = result;
LABEL_9:
    size_t v7 = *(uint64_t (**)(void))(*(void *)result + 16);
    return v7();
  }
  uint64_t v5 = (char *)HGObject::operator new(0x118uLL);
  HGObject::HGObject((HGObject *)v5);
  *(void *)uint64_t v5 = &unk_1F10D55B0;
  *((_OWORD *)v5 + 12) = 0u;
  *((_OWORD *)v5 + 13) = 0u;
  *(_OWORD *)(v5 + 172) = 0u;
  *((_OWORD *)v5 + 9) = 0u;
  *((_OWORD *)v5 + 10) = 0u;
  *((_OWORD *)v5 + 7) = 0u;
  *((_OWORD *)v5 + 8) = 0u;
  *((_OWORD *)v5 + 5) = 0u;
  *((_OWORD *)v5 + 6) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  *((_OWORD *)v5 + 4) = 0u;
  *((_OWORD *)v5 + 1) = 0u;
  *((_OWORD *)v5 + 2) = 0u;
  *((_DWORD *)v5 + 56) = 1;
  *(_OWORD *)(v5 + 228) = 0u;
  *(_OWORD *)(v5 + 244) = 0u;
  *((_DWORD *)v5 + 69) = 0;
  *(_OWORD *)(v5 + 260) = 0u;
  int v6 = (char *)*((void *)this + 50);
  if (v6 == v5)
  {
    HGObject::Release((atomic_uint *)v5);
    uint64_t v5 = (char *)*((void *)this + 50);
  }
  else
  {
    if (v6) {
      (*(void (**)(char *))(*(void *)v6 + 24))(v6);
    }
    *((void *)this + 50) = v5;
  }
  (*(void (**)(HGNode *, char *))(*(void *)this + 328))(this, v5);
  uint64_t result = *((void *)this + 50);
  *a2 = result;
  if (result) {
    goto LABEL_9;
  }
  return result;
}

void sub_1B7795AD8(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void HGNode::InitNodeChain(HGNode *this, unint64_t a2)
{
  if (!a2)
  {
    uint64_t v4 = *((void *)this + 37);
LABEL_6:
    *((void *)this + 38) = v4;
    return;
  }
  uint64_t v2 = *((void *)this + 37);
  unint64_t v3 = 0x6DB6DB6DB6DB6DB7 * ((*((void *)this + 38) - v2) >> 3);
  if (a2 != v3)
  {
    if (a2 > v3)
    {
      std::vector<HGNodeChain>::__append((char **)this + 37, a2 - v3);
      return;
    }
    if (a2 < v3)
    {
      uint64_t v4 = v2 + 56 * a2;
      goto LABEL_6;
    }
  }
}

void HGProgramDescriptor::~HGProgramDescriptor(HGProgramDescriptor *this)
{
  HGProgramDescriptor::~HGProgramDescriptor(this);

  HGObject::operator delete(v1);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  char *v8;
  HGObject *v9;
  char *v10;
  uint64_t v11;
  void *v12;
  uint64_t vars8;

  *(void *)this = &unk_1F10D55B0;
  uint64_t v2 = *((void *)this + 32);
  if (v2)
  {
    unint64_t v3 = *((void *)this + 33);
    uint64_t v4 = (void *)*((void *)this + 32);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 17) < 0) {
          operator delete(*(void **)(v3 - 40));
        }
        v3 -= 48;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 32);
    }
    *((void *)this + 33) = v2;
    operator delete(v4);
  }
  uint64_t v5 = *((void *)this + 29);
  if (v5)
  {
    int v6 = *((void *)this + 30);
    size_t v7 = (void *)*((void *)this + 29);
    if (v6 != v5)
    {
      do
      {
        if (*(char *)(v6 - 17) < 0) {
          operator delete(*(void **)(v6 - 40));
        }
        v6 -= 48;
      }
      while (v6 != v5);
      size_t v7 = (void *)*((void *)this + 29);
    }
    *((void *)this + 30) = v5;
    operator delete(v7);
  }
  if (*((char *)this + 215) < 0)
  {
    operator delete(*((void **)this + 24));
    if ((*((char *)this + 183) & 0x80000000) == 0)
    {
LABEL_19:
      if ((*((char *)this + 159) & 0x80000000) == 0) {
        goto LABEL_20;
      }
      goto LABEL_30;
    }
  }
  else if ((*((char *)this + 183) & 0x80000000) == 0)
  {
    goto LABEL_19;
  }
  operator delete(*((void **)this + 20));
  if ((*((char *)this + 159) & 0x80000000) == 0)
  {
LABEL_20:
    std::string::size_type v8 = (char *)*((void *)this + 14);
    if (!v8) {
      goto LABEL_21;
    }
LABEL_31:
    int v10 = (char *)*((void *)this + 15);
    if (v10 == v8)
    {
      *((void *)this + 15) = v8;
      operator delete(v8);
      if (*((char *)this + 111) < 0) {
        goto LABEL_38;
      }
    }
    else
    {
      do
      {
        int v11 = *((void *)v10 - 1);
        if (v11) {
          (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
        }
        v10 -= 16;
      }
      while (v10 != v8);
      float32x4_t v12 = (void *)*((void *)this + 14);
      *((void *)this + 15) = v8;
      operator delete(v12);
      if (*((char *)this + 111) < 0) {
        goto LABEL_38;
      }
    }
LABEL_22:
    if ((*((char *)this + 87) & 0x80000000) == 0) {
      goto LABEL_23;
    }
    goto LABEL_39;
  }
LABEL_30:
  operator delete(*((void **)this + 17));
  std::string::size_type v8 = (char *)*((void *)this + 14);
  if (v8) {
    goto LABEL_31;
  }
LABEL_21:
  if ((*((char *)this + 111) & 0x80000000) == 0) {
    goto LABEL_22;
  }
LABEL_38:
  operator delete(*((void **)this + 11));
  if ((*((char *)this + 87) & 0x80000000) == 0)
  {
LABEL_23:
    if ((*((char *)this + 63) & 0x80000000) == 0) {
      goto LABEL_24;
    }
    goto LABEL_40;
  }
LABEL_39:
  operator delete(*((void **)this + 8));
  if ((*((char *)this + 63) & 0x80000000) == 0)
  {
LABEL_24:
    if ((*((char *)this + 39) & 0x80000000) == 0) {
      goto LABEL_25;
    }
    goto LABEL_41;
  }
LABEL_40:
  operator delete(*((void **)this + 5));
  if ((*((char *)this + 39) & 0x80000000) == 0)
  {
LABEL_25:
    int v9 = this;
    goto LABEL_27;
  }
LABEL_41:
  operator delete(*((void **)this + 2));
  int v9 = this;

LABEL_27:
  HGObject::~HGObject(v9);
}

void *std::__hash_table<std::__hash_value_type<HGNode const*,BOOL>,std::__unordered_map_hasher<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::hash<HGNode const*>,std::equal_to<HGNode const*>,true>,std::__unordered_map_equal<HGNode const*,std::__hash_value_type<HGNode const*,BOOL>,std::equal_to<HGNode const*>,std::hash<HGNode const*>,true>,std::allocator<std::__hash_value_type<HGNode const*,BOOL>>>::__emplace_unique_key_args<HGNode const*,std::piecewise_construct_t const&,std::tuple<HGNode const* const&>,std::tuple<>>(uint64_t a1, uint64_t *a2, uint64_t a3, void **a4)
{
  uint64_t v7 = *a2;
  unint64_t v8 = HIDWORD(*a2);
  unint64_t v9 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ v8);
  unint64_t v10 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
    }
    else
    {
      unint64_t v4 = v10 & (v11 - 1);
    }
    int v13 = *(void **)(*(void *)a1 + 8 * v4);
    if (v13)
    {
      int32x2_t v14 = (void *)*v13;
      if (*v13)
      {
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v16 = v14[1];
            if (v16 == v10)
            {
              if (v14[2] == v7) {
                return v14;
              }
            }
            else if ((v16 & (v11 - 1)) != v4)
            {
              goto LABEL_23;
            }
            int32x2_t v14 = (void *)*v14;
            if (!v14) {
              goto LABEL_23;
            }
          }
        }
        do
        {
          unint64_t v15 = v14[1];
          if (v15 == v10)
          {
            if (v14[2] == v7) {
              return v14;
            }
          }
          else
          {
            if (v15 >= v11) {
              v15 %= v11;
            }
            if (v15 != v4) {
              break;
            }
          }
          int32x2_t v14 = (void *)*v14;
        }
        while (v14);
      }
    }
  }
LABEL_23:
  __int32 v18 = operator new(0x20uLL);
  *__int32 v18 = 0;
  v18[1] = v10;
  v18[2] = **a4;
  *((unsigned char *)v18 + 24) = 0;
  float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v20 = *(float *)(a1 + 32);
  if (v11 && (float)(v20 * (float)v11) >= v19)
  {
    uint64_t v21 = *(void *)a1;
    int32x2_t v22 = *(void **)(*(void *)a1 + 8 * v4);
    if (v22)
    {
LABEL_26:
      *__int32 v18 = *v22;
LABEL_61:
      *int32x2_t v22 = v18;
      goto LABEL_62;
    }
  }
  else
  {
    BOOL v23 = 1;
    if (v11 >= 3) {
      BOOL v23 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v24 = v23 | (2 * v11);
    unint64_t v25 = vcvtps_u32_f32(v19 / v20);
    if (v24 <= v25) {
      size_t prime = v25;
    }
    else {
      size_t prime = v24;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v11 = *(void *)(a1 + 8);
    }
    if (prime > v11) {
      goto LABEL_37;
    }
    if (prime < v11)
    {
      unint64_t v27 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v11 < 3 || (uint8x8_t v28 = (uint8x8_t)vcnt_s8((int8x8_t)v11), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
      {
        unint64_t v27 = std::__next_prime(v27);
      }
      else
      {
        uint64_t v29 = 1 << -(char)__clz(v27 - 1);
        if (v27 >= 2) {
          unint64_t v27 = v29;
        }
      }
      if (prime <= v27) {
        size_t prime = v27;
      }
      if (prime < v11) {
LABEL_37:
      }
        std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v11 = *(void *)(a1 + 8);
    unint64_t v30 = v11 - 1;
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11)
      {
        unint64_t v4 = v10 % v11;
        uint64_t v21 = *(void *)a1;
        int32x2_t v22 = *(void **)(*(void *)a1 + 8 * (v10 % v11));
        if (v22) {
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v4 = v10;
        uint64_t v21 = *(void *)a1;
        int32x2_t v22 = *(void **)(*(void *)a1 + 8 * v10);
        if (v22) {
          goto LABEL_26;
        }
      }
    }
    else
    {
      unint64_t v4 = v30 & v10;
      uint64_t v21 = *(void *)a1;
      int32x2_t v22 = *(void **)(*(void *)a1 + 8 * (v30 & v10));
      if (v22) {
        goto LABEL_26;
      }
    }
  }
  *__int32 v18 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v18;
  *(void *)(v21 + 8 * v4) = a1 + 16;
  if (*v18)
  {
    unint64_t v31 = *(void *)(*v18 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v31 >= v11) {
        v31 %= v11;
      }
    }
    else
    {
      v31 &= v11 - 1;
    }
    int32x2_t v22 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_61;
  }
LABEL_62:
  ++*(void *)(a1 + 24);
  return v18;
}

void sub_1B7796124(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::deque<HGNode const*>::__add_front_capacity(uint64_t a1)
{
  unint64_t v3 = *(char **)(a1 + 8);
  uint64_t v2 = *(char **)(a1 + 16);
  if (v2 == v3) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = ((v2 - v3) << 6) - 1;
  }
  uint64_t v5 = *(void *)(a1 + 32);
  if ((unint64_t)(v4 - (*(void *)(a1 + 40) + v5)) >= 0x200)
  {
    *(void *)(a1 + 32) = v5 + 512;
    uint64_t v47 = (void *)*((void *)v2 - 1);
    *(void *)(a1 + 16) = v2 - 8;
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
    return;
  }
  int v6 = *(char **)(a1 + 24);
  uint64_t v7 = *(char **)a1;
  uint64_t v8 = (uint64_t)&v6[-*(void *)a1];
  if (v2 - v3 < (unint64_t)v8)
  {
    if (v3 == v7)
    {
      uint64_t v47 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v47);
      uint64_t v17 = *(void *)(a1 + 16);
      uint64_t v47 = *(void **)(v17 - 8);
      *(void *)(a1 + 16) = v17 - 8;
      std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
      if (*(void *)(a1 + 16) - *(void *)(a1 + 8) == 8) {
        goto LABEL_9;
      }
    }
    else
    {
      uint64_t v47 = operator new(0x1000uLL);
      std::__split_buffer<HGNode **>::push_front((void **)a1, &v47);
      if (*(void *)(a1 + 16) - *(void *)(a1 + 8) == 8)
      {
LABEL_9:
        uint64_t v9 = 256;
LABEL_19:
        *(void *)(a1 + 32) = v9;
        return;
      }
    }
    uint64_t v9 = *(void *)(a1 + 32) + 512;
    goto LABEL_19;
  }
  if (v6 == v7) {
    unint64_t v10 = 1;
  }
  else {
    unint64_t v10 = v8 >> 2;
  }
  if (v10 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  unint64_t v11 = (char *)operator new(8 * v10);
  uint8x8_t v12 = operator new(0x1000uLL);
  int v13 = v12;
  if (v10)
  {
    int32x2_t v14 = &v11[8 * v10];
    *(void *)unint64_t v11 = v12;
    unint64_t v15 = v11 + 8;
    uint64_t v16 = v11;
    if (v3 != v2) {
      goto LABEL_29;
    }
    goto LABEL_21;
  }
  __int32 v18 = (char *)operator new(8uLL);
  int32x2_t v14 = v18 + 8;
  operator delete(v11);
  unint64_t v3 = *(char **)(a1 + 8);
  float v19 = *(char **)(a1 + 16);
  unint64_t v11 = v18;
  *(void *)__int32 v18 = v13;
  unint64_t v15 = v18 + 8;
  uint64_t v16 = v18;
  if (v3 != v19)
  {
    while (1)
    {
LABEL_29:
      if (v15 == v14)
      {
        if (v11 <= v16)
        {
          if (v15 == v16) {
            unint64_t v31 = 1;
          }
          else {
            unint64_t v31 = (v15 - v16) >> 2;
          }
          if (v31 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v32 = (char *)operator new(8 * v31);
          uint64_t v33 = v32;
          unint64_t v34 = v31 >> 2;
          float v20 = &v32[8 * (v31 >> 2)];
          BOOL v23 = v20;
          int64_t v35 = v15 - v11;
          if (v15 != v11)
          {
            BOOL v23 = &v20[v35 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v36 = v35 - 8;
            if (v36 < 0x38 || (uint64_t v37 = 8 * v34, (unint64_t)(&v32[8 * v34] - v11) < 0x20))
            {
              uint64_t v38 = &v32[8 * (v31 >> 2)];
              uint64_t v39 = v11;
              goto LABEL_45;
            }
            uint64_t v41 = (v36 >> 3) + 1;
            uint64_t v42 = 8 * (v41 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v38 = &v20[v42];
            uint64_t v39 = &v11[v42];
            uint64_t v43 = (long long *)(v11 + 16);
            int v44 = &v32[v37 + 16];
            uint64_t v45 = v41 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v46 = *v43;
              *((_OWORD *)v44 - 1) = *(v43 - 1);
              *(_OWORD *)int v44 = v46;
              v43 += 2;
              v44 += 32;
              v45 -= 4;
            }
            while (v45);
            if (v41 != (v41 & 0x3FFFFFFFFFFFFFFCLL))
            {
              do
              {
LABEL_45:
                uint64_t v40 = *(void *)v39;
                v39 += 8;
                *(void *)uint64_t v38 = v40;
                v38 += 8;
              }
              while (v38 != v23);
            }
          }
          unint64_t v15 = &v32[8 * v31];
          if (v16) {
            operator delete(v16);
          }
          uint64_t v16 = v33;
          goto LABEL_28;
        }
        uint64_t v25 = (v11 - v16) >> 3;
        if (v25 >= -1) {
          uint64_t v26 = v25 + 1;
        }
        else {
          uint64_t v26 = v25 + 2;
        }
        uint64_t v27 = v26 >> 1;
        uint8x8_t v28 = &v11[-8 * (v26 >> 1)];
        uint64_t v29 = v15;
        if (v15 != v11)
        {
          memmove(v28, v11, v15 - v11);
          uint64_t v29 = v11;
        }
        uint64_t v30 = -v27;
        BOOL v23 = &v28[v15 - v11];
        float v20 = &v29[8 * v30];
      }
      else
      {
        float v20 = v11;
        BOOL v23 = v15;
        unint64_t v15 = v14;
      }
LABEL_28:
      int32x2_t v14 = v15;
      uint64_t v24 = *(void *)v3;
      v3 += 8;
      *(void *)BOOL v23 = v24;
      uint64_t v21 = v23 + 8;
      unint64_t v15 = v21;
      unint64_t v11 = v20;
      if (v3 == *(char **)(a1 + 16)) {
        goto LABEL_22;
      }
    }
  }
LABEL_21:
  float v20 = v11;
  uint64_t v21 = v15;
LABEL_22:
  int32x2_t v22 = *(void **)a1;
  *(void *)a1 = v16;
  *(void *)(a1 + 8) = v20;
  *(void *)(a1 + 16) = v21;
  *(void *)(a1 + 24) = v14;
  if (v21 - v20 == 8)
  {
    *(void *)(a1 + 32) = 256;
    if (!v22) {
      return;
    }
  }
  else
  {
    *(void *)(a1 + 32) += 512;
    if (!v22) {
      return;
    }
  }

  operator delete(v22);
}

void sub_1B77964C0(_Unwind_Exception *a1)
{
  operator delete(v1);
  operator delete(v2);
  _Unwind_Resume(a1);
}

void std::deque<HGNode const*>::__append(void *a1, unint64_t a2)
{
  uint64_t v4 = a1[1];
  uint64_t v5 = a1[2];
  if (v5 == v4) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = ((v5 - v4) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  unint64_t v9 = v6 - v8;
  BOOL v10 = a2 > v9;
  unint64_t v11 = a2 - v9;
  if (v10)
  {
    std::deque<HGNode const*>::__add_back_capacity((uint64_t)a1, v11);
    uint64_t v7 = a1[5];
    uint64_t v4 = a1[1];
    uint64_t v5 = a1[2];
    unint64_t v8 = a1[4] + v7;
  }
  uint8x8_t v12 = (void *)(v4 + 8 * (v8 >> 9));
  if (v5 == v4)
  {
    int v13 = 0;
    if (!a2) {
      return;
    }
  }
  else
  {
    int v13 = (void *)(*v12 + 8 * (v8 & 0x1FF));
    if (!a2) {
      return;
    }
  }
  uint64_t v14 = a2 + (((uint64_t)v13 - *v12) >> 3);
  if (v14 < 1)
  {
    unint64_t v17 = 511 - v14;
    unint64_t v15 = &v12[-(v17 >> 9)];
    uint64_t v16 = *v15 + 8 * (~(_WORD)v17 & 0x1FF);
    if (v13 != (void *)v16)
    {
      do
      {
LABEL_15:
        uint64_t v18 = v16;
        if (v12 != v15) {
          uint64_t v18 = *v12 + 4096;
        }
        if (v13 == (void *)v18)
        {
          if (v12 == v15) {
            break;
          }
        }
        else
        {
          int64_t v19 = ((v18 - (void)v13 - 8) & 0xFFFFFFFFFFFFFFF8) + 8;
          bzero(v13, v19);
          v7 += v19 >> 3;
          if (v12 == v15) {
            break;
          }
        }
        float v20 = (void *)v12[1];
        ++v12;
        int v13 = v20;
      }
      while (v20 != (void *)v16);
      a1[5] = v7;
    }
  }
  else
  {
    unint64_t v15 = &v12[(unint64_t)v14 >> 9];
    uint64_t v16 = *v15 + 8 * (v14 & 0x1FF);
    if (v13 != (void *)v16) {
      goto LABEL_15;
    }
  }
}

void std::deque<HGNode const*>::__add_back_capacity(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = *(char **)(a1 + 16);
  uint64_t v4 = (uint64_t)&v3[-*(void *)(a1 + 8)];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if ((v5 & 0x1FF) != 0) {
    unint64_t v6 = (v5 >> 9) + 1;
  }
  else {
    unint64_t v6 = v5 >> 9;
  }
  unint64_t v7 = *(void *)(a1 + 32);
  if (v6 >= v7 >> 9) {
    unint64_t v8 = v7 >> 9;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 >> 9)
  {
    *(void *)(a1 + 32) = v7 - (v8 << 9);
    if (!v8) {
      return;
    }
    while (1)
    {
      unint64_t v15 = *(void **)(a1 + 8);
      uint64_t v16 = (char *)(v15 + 1);
      uint64_t v17 = *v15;
      *(void *)(a1 + 8) = v15 + 1;
      if (v3 == *(char **)(a1 + 24))
      {
        uint64_t v18 = *(char **)a1;
        if ((unint64_t)v16 <= *(void *)a1)
        {
          unint64_t v24 = (v3 - v18) >> 2;
          if (v3 == v18) {
            unint64_t v24 = 1;
          }
          if (v24 >> 61) {
            goto LABEL_161;
          }
          unint64_t v25 = v24 >> 2;
          uint64_t v26 = 8 * v24;
          uint64_t v27 = (char *)operator new(8 * v24);
          uint8x8_t v28 = &v27[8 * v25];
          int64_t v30 = v3 - v16;
          BOOL v29 = v3 == v16;
          unint64_t v3 = v28;
          if (!v29)
          {
            unint64_t v3 = &v28[v30 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v31 = v30 - 8;
            if ((unint64_t)(v30 - 8) < 0x38)
            {
              uint64_t v32 = &v27[8 * v25];
              goto LABEL_39;
            }
            uint64_t v32 = &v27[8 * v25];
            if ((unint64_t)(v32 - v16) < 0x20) {
              goto LABEL_167;
            }
            uint64_t v33 = (v31 >> 3) + 1;
            uint64_t v34 = 8 * (v33 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v32 = &v28[v34];
            v16 += v34;
            int64_t v35 = (long long *)(v15 + 3);
            unint64_t v36 = &v27[8 * v25 + 16];
            uint64_t v37 = v33 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v38 = *v35;
              *((_OWORD *)v36 - 1) = *(v35 - 1);
              *(_OWORD *)unint64_t v36 = v38;
              v35 += 2;
              v36 += 32;
              v37 -= 4;
            }
            while (v37);
            if (v33 != (v33 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_167:
              do
              {
LABEL_39:
                uint64_t v39 = *(void *)v16;
                v16 += 8;
                *(void *)uint64_t v32 = v39;
                v32 += 8;
              }
              while (v32 != v3);
            }
          }
          *(void *)a1 = v27;
          *(void *)(a1 + 8) = v28;
          *(void *)(a1 + 16) = v3;
          *(void *)(a1 + 24) = &v27[v26];
          if (v18)
          {
            operator delete(v18);
            unint64_t v3 = *(char **)(a1 + 16);
          }
          goto LABEL_21;
        }
        uint64_t v19 = (uint64_t)&v16[-*(void *)a1] >> 3;
        if (v19 >= -1) {
          uint64_t v20 = v19 + 1;
        }
        else {
          uint64_t v20 = v19 + 2;
        }
        uint64_t v21 = v20 >> 1;
        int32x2_t v22 = &v16[-8 * (v20 >> 1)];
        int64_t v23 = v3 - v16;
        if (v3 != v16)
        {
          memmove(&v16[-8 * (v20 >> 1)], v16, v3 - v16);
          unint64_t v3 = *(char **)(a1 + 8);
        }
        uint64_t v14 = &v3[-8 * v21];
        unint64_t v3 = &v22[v23];
        *(void *)(a1 + 8) = v14;
        *(void *)(a1 + 16) = &v22[v23];
      }
LABEL_21:
      *(void *)unint64_t v3 = v17;
      unint64_t v3 = (char *)(*(void *)(a1 + 16) + 8);
      *(void *)(a1 + 16) = v3;
      if (!--v8) {
        return;
      }
    }
  }
  unint64_t v9 = v6 - v8;
  uint64_t v10 = *(void *)(a1 + 24) - *(void *)a1;
  uint64_t v11 = v4 >> 3;
  if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
  {
    if (v9)
    {
      while (*(void *)(a1 + 24) != *(void *)(a1 + 16))
      {
        unint64_t v145 = operator new(0x1000uLL);
        std::__split_buffer<HGNode **>::push_back((char **)a1, &v145);
        --v6;
        if (!--v9) {
          goto LABEL_136;
        }
      }
      for (uint64_t i = 0; i != v9; ++i)
      {
        unint64_t v145 = operator new(0x1000uLL);
        std::__split_buffer<HGNode **>::push_front((void **)a1, &v145);
        if (*(void *)(a1 + 16) - *(void *)(a1 + 8) == 8) {
          uint64_t v116 = 511;
        }
        else {
          uint64_t v116 = 512;
        }
        uint64_t v117 = v116 + *(void *)(a1 + 32);
        *(void *)(a1 + 32) = v117;
      }
      unint64_t v8 = v6;
      *(void *)(a1 + 32) = v117 - (v6 << 9);
      if (!v6) {
        return;
      }
    }
    else
    {
LABEL_136:
      *(void *)(a1 + 32) -= v8 << 9;
      if (!v8) {
        return;
      }
    }
    __int16 v118 = *(char **)(a1 + 16);
    while (1)
    {
      int v120 = *(void **)(a1 + 8);
      char v121 = (char *)(v120 + 1);
      uint64_t v122 = *v120;
      *(void *)(a1 + 8) = v120 + 1;
      if (v118 == *(char **)(a1 + 24))
      {
        char v123 = *(char **)a1;
        if ((unint64_t)v121 <= *(void *)a1)
        {
          unint64_t v129 = (v118 - v123) >> 2;
          if (v118 == v123) {
            unint64_t v129 = 1;
          }
          if (v129 >> 61) {
            goto LABEL_161;
          }
          unint64_t v130 = v129 >> 2;
          uint64_t v131 = 8 * v129;
          int v132 = (char *)operator new(8 * v129);
          char v133 = &v132[8 * v130];
          int64_t v134 = v118 - v121;
          BOOL v29 = v118 == v121;
          __int16 v118 = v133;
          if (!v29)
          {
            __int16 v118 = &v133[v134 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v135 = v134 - 8;
            if ((unint64_t)(v134 - 8) < 0x38)
            {
              int v136 = &v132[8 * v130];
              goto LABEL_157;
            }
            int v136 = &v132[8 * v130];
            if ((unint64_t)(v136 - v121) < 0x20) {
              goto LABEL_168;
            }
            uint64_t v137 = (v135 >> 3) + 1;
            uint64_t v138 = 8 * (v137 & 0x3FFFFFFFFFFFFFFCLL);
            int v136 = &v133[v138];
            v121 += v138;
            long long v139 = (long long *)(v120 + 3);
            long long v140 = &v132[8 * v130 + 16];
            uint64_t v141 = v137 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v142 = *v139;
              *((_OWORD *)v140 - 1) = *(v139 - 1);
              *(_OWORD *)long long v140 = v142;
              v139 += 2;
              v140 += 32;
              v141 -= 4;
            }
            while (v141);
            if (v137 != (v137 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_168:
              do
              {
LABEL_157:
                uint64_t v143 = *(void *)v121;
                v121 += 8;
                *(void *)int v136 = v143;
                v136 += 8;
              }
              while (v136 != v118);
            }
          }
          *(void *)a1 = v132;
          *(void *)(a1 + 8) = v133;
          *(void *)(a1 + 16) = v118;
          *(void *)(a1 + 24) = &v132[v131];
          if (v123)
          {
            operator delete(v123);
            __int16 v118 = *(char **)(a1 + 16);
          }
          goto LABEL_139;
        }
        uint64_t v124 = (uint64_t)&v121[-*(void *)a1] >> 3;
        if (v124 >= -1) {
          uint64_t v125 = v124 + 1;
        }
        else {
          uint64_t v125 = v124 + 2;
        }
        uint64_t v126 = v125 >> 1;
        char v127 = &v121[-8 * (v125 >> 1)];
        int64_t v128 = v118 - v121;
        if (v118 != v121)
        {
          memmove(&v121[-8 * (v125 >> 1)], v121, v118 - v121);
          __int16 v118 = *(char **)(a1 + 8);
        }
        char v119 = &v118[-8 * v126];
        __int16 v118 = &v127[v128];
        *(void *)(a1 + 8) = v119;
        *(void *)(a1 + 16) = &v127[v128];
      }
LABEL_139:
      *(void *)__int16 v118 = v122;
      __int16 v118 = (char *)(*(void *)(a1 + 16) + 8);
      *(void *)(a1 + 16) = v118;
      if (!--v8) {
        return;
      }
    }
  }
  if (v10 >> 2 <= v9 + v11) {
    unint64_t v12 = v9 + v11;
  }
  else {
    unint64_t v12 = v10 >> 2;
  }
  if (v12)
  {
    if (v12 >> 61) {
LABEL_161:
    }
      std::__throw_bad_array_new_length[abi:ne180100]();
    int v13 = (char *)operator new(8 * v12);
  }
  else
  {
    int v13 = 0;
  }
  uint64_t v144 = v8 << 9;
  uint64_t v40 = &v13[8 * (v11 - v8)];
  uint64_t v41 = &v13[8 * v12];
  uint64_t v42 = v40;
  uint64_t v43 = v13;
  do
  {
    int v44 = operator new(0x1000uLL);
    if (v42 != v41) {
      goto LABEL_49;
    }
    if (v40 > v43)
    {
      uint64_t v45 = v43;
      uint64_t v46 = (v40 - v43) >> 3;
      if (v46 >= -1) {
        uint64_t v47 = v46 + 1;
      }
      else {
        uint64_t v47 = v46 + 2;
      }
      uint64_t v48 = v47 >> 1;
      uint64_t v49 = &v40[-8 * (v47 >> 1)];
      uint64_t v50 = v41;
      if (v41 != v40)
      {
        memmove(v49, v40, v41 - v40);
        uint64_t v50 = v40;
      }
      uint64_t v42 = &v49[v41 - v40];
      uint64_t v40 = &v50[-8 * v48];
      uint64_t v43 = v45;
      goto LABEL_49;
    }
    if (v41 == v43) {
      unint64_t v51 = 1;
    }
    else {
      unint64_t v51 = (v41 - v43) >> 2;
    }
    if (v51 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v52 = (char *)operator new(8 * v51);
    uint64_t v53 = v43;
    unint64_t v54 = v51 >> 2;
    uint64_t v55 = &v52[8 * (v51 >> 2)];
    uint64_t v42 = v55;
    int64_t v56 = v41 - v40;
    if (v41 != v40)
    {
      uint64_t v42 = &v55[v56 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v57 = v56 - 8;
      if (v57 >= 0x38 && (uint64_t v58 = 8 * v54, (unint64_t)(&v52[8 * v54] - v40) >= 0x20))
      {
        uint64_t v62 = (v57 >> 3) + 1;
        uint64_t v63 = 8 * (v62 & 0x3FFFFFFFFFFFFFFCLL);
        int v59 = &v55[v63];
        uint64_t v60 = &v40[v63];
        unsigned int v64 = (long long *)(v40 + 16);
        int v65 = &v52[v58 + 16];
        uint64_t v66 = v62 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v67 = *v64;
          *((_OWORD *)v65 - 1) = *(v64 - 1);
          *(_OWORD *)int v65 = v67;
          v64 += 2;
          v65 += 32;
          v66 -= 4;
        }
        while (v66);
        if (v62 == (v62 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_66;
        }
      }
      else
      {
        int v59 = &v52[8 * (v51 >> 2)];
        uint64_t v60 = v40;
      }
      do
      {
        uint64_t v61 = *(void *)v60;
        v60 += 8;
        *(void *)int v59 = v61;
        v59 += 8;
      }
      while (v59 != v42);
    }
LABEL_66:
    uint64_t v41 = &v52[8 * v51];
    if (v53) {
      operator delete(v53);
    }
    uint64_t v40 = &v52[8 * (v51 >> 2)];
    uint64_t v43 = v52;
LABEL_49:
    *(void *)uint64_t v42 = v44;
    v42 += 8;
    --v9;
  }
  while (v9);
  unsigned int v68 = *(void **)(a1 + 8);
  if (v8)
  {
    while (1)
    {
      if (v42 == v41)
      {
        if (v40 <= v43)
        {
          if (v41 == v43) {
            unint64_t v78 = 1;
          }
          else {
            unint64_t v78 = (v41 - v43) >> 2;
          }
          if (v78 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v79 = (char *)operator new(8 * v78);
          uint64_t v80 = v79;
          unint64_t v81 = v78 >> 2;
          HGRect v69 = &v79[8 * (v78 >> 2)];
          uint64_t v42 = v69;
          int64_t v82 = v41 - v40;
          if (v41 != v40)
          {
            uint64_t v42 = &v69[v82 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v83 = v82 - 8;
            if (v83 < 0x38 || (uint64_t v84 = 8 * v81, (unint64_t)(&v79[8 * v81] - v40) < 0x20))
            {
              long long v85 = &v79[8 * (v78 >> 2)];
              long long v86 = v40;
              goto LABEL_98;
            }
            uint64_t v88 = (v83 >> 3) + 1;
            uint64_t v89 = 8 * (v88 & 0x3FFFFFFFFFFFFFFCLL);
            long long v85 = &v69[v89];
            long long v86 = &v40[v89];
            uint64_t v90 = (long long *)(v40 + 16);
            int v91 = &v79[v84 + 16];
            uint64_t v92 = v88 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v93 = *v90;
              *((_OWORD *)v91 - 1) = *(v90 - 1);
              *(_OWORD *)int v91 = v93;
              v90 += 2;
              v91 += 32;
              v92 -= 4;
            }
            while (v92);
            if (v88 != (v88 & 0x3FFFFFFFFFFFFFFCLL))
            {
              do
              {
LABEL_98:
                uint64_t v87 = *(void *)v86;
                v86 += 8;
                *(void *)long long v85 = v87;
                v85 += 8;
              }
              while (v85 != v42);
            }
          }
          uint64_t v41 = &v79[8 * v78];
          if (v43) {
            operator delete(v43);
          }
          uint64_t v43 = v80;
          goto LABEL_81;
        }
        long long v72 = v43;
        uint64_t v73 = (v40 - v43) >> 3;
        if (v73 >= -1) {
          uint64_t v74 = v73 + 1;
        }
        else {
          uint64_t v74 = v73 + 2;
        }
        uint64_t v75 = v74 >> 1;
        uint64_t v76 = &v40[-8 * (v74 >> 1)];
        int v77 = v41;
        if (v41 != v40)
        {
          memmove(v76, v40, v41 - v40);
          int v77 = v40;
        }
        uint64_t v42 = &v76[v41 - v40];
        HGRect v69 = &v77[-8 * v75];
        uint64_t v43 = v72;
      }
      else
      {
        HGRect v69 = v40;
      }
LABEL_81:
      *(void *)uint64_t v42 = *v68;
      v42 += 8;
      unsigned int v68 = (void *)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v68;
      uint64_t v40 = v69;
      if (!--v8) {
        goto LABEL_75;
      }
    }
  }
  HGRect v69 = v40;
LABEL_75:
  HGRect v70 = *(void **)(a1 + 16);
  if (v70 != v68)
  {
    do
    {
      if (v69 == v43)
      {
        if (v42 >= v41)
        {
          if (v41 == v43) {
            unint64_t v100 = 1;
          }
          else {
            unint64_t v100 = (v41 - v43) >> 2;
          }
          if (v100 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          long long v101 = (char *)operator new(8 * v100);
          long long v97 = v101;
          unint64_t v102 = (v100 + 3) >> 2;
          HGRect v69 = &v101[8 * v102];
          int64_t v103 = v42 - v43;
          BOOL v29 = v42 == v43;
          uint64_t v42 = v69;
          if (!v29)
          {
            uint64_t v42 = &v69[v103 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v104 = v103 - 8;
            uint64_t v105 = &v101[8 * v102];
            __int16 v106 = v43;
            if (v104 < 0x38) {
              goto LABEL_169;
            }
            uint64_t v107 = 8 * v102;
            uint64_t v105 = &v101[8 * v102];
            __int16 v106 = v43;
            if ((unint64_t)(v105 - v43) < 0x20) {
              goto LABEL_169;
            }
            uint64_t v108 = (v104 >> 3) + 1;
            uint64_t v109 = 8 * (v108 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v105 = &v69[v109];
            __int16 v106 = &v43[v109];
            __int16 v110 = (long long *)(v43 + 16);
            char v111 = &v101[v107 + 16];
            uint64_t v112 = v108 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v113 = *v110;
              *((_OWORD *)v111 - 1) = *(v110 - 1);
              *(_OWORD *)char v111 = v113;
              v110 += 2;
              v111 += 32;
              v112 -= 4;
            }
            while (v112);
            if (v108 != (v108 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_169:
              do
              {
                uint64_t v114 = *(void *)v106;
                v106 += 8;
                *(void *)uint64_t v105 = v114;
                v105 += 8;
              }
              while (v105 != v42);
            }
          }
          uint64_t v41 = &v101[8 * v100];
          if (v43) {
            operator delete(v43);
          }
        }
        else
        {
          uint64_t v95 = (v41 - v42) >> 3;
          if (v95 >= -1) {
            uint64_t v96 = v95 + 1;
          }
          else {
            uint64_t v96 = v95 + 2;
          }
          long long v97 = v43;
          uint64_t v98 = v96 >> 1;
          HGRect v69 = &v97[8 * (v96 >> 1)];
          uint64_t v99 = v97;
          if (v42 != v97)
          {
            memmove(v69, v97, v42 - v97);
            uint64_t v99 = v42;
          }
          uint64_t v42 = &v99[8 * v98];
        }
        uint64_t v43 = v97;
      }
      uint64_t v94 = *--v70;
      *((void *)v69 - 1) = v94;
      v69 -= 8;
    }
    while (v70 != *(void **)(a1 + 8));
  }
  long long v71 = *(char **)a1;
  *(void *)a1 = v43;
  *(void *)(a1 + 8) = v69;
  *(void *)(a1 + 16) = v42;
  *(void *)(a1 + 24) = v41;
  *(void *)(a1 + 32) -= v144;
  if (v71)
  {
    operator delete(v71);
  }
}

void sub_1B7796F98(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B7796FE4()
{
}

void std::vector<HGNodeChain>::__append(char **a1, unint64_t a2)
{
  unint64_t v5 = a1[1];
  uint64_t v4 = a1[2];
  if (0x6DB6DB6DB6DB6DB7 * ((v4 - v5) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v12 = 56 * ((56 * a2 - 56) / 0x38) + 56;
      bzero(a1[1], v12);
      v5 += v12;
    }
    a1[1] = v5;
  }
  else
  {
    unint64_t v6 = *a1;
    uint64_t v7 = 0x6DB6DB6DB6DB6DB7 * ((v5 - *a1) >> 3);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0x492492492492492) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v9 = 0x6DB6DB6DB6DB6DB7 * ((v4 - v6) >> 3);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x249249249249249) {
      unint64_t v10 = 0x492492492492492;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 > 0x492492492492492) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v11 = (char *)operator new(56 * v10);
    }
    else
    {
      uint64_t v11 = 0;
    }
    int v13 = &v11[56 * v7];
    uint64_t v14 = &v11[56 * v10];
    size_t v15 = 56 * ((56 * a2 - 56) / 0x38) + 56;
    bzero(v13, v15);
    uint64_t v16 = &v13[v15];
    if (v5 != v6)
    {
      do
      {
        long long v17 = *(_OWORD *)(v5 - 56);
        long long v18 = *(_OWORD *)(v5 - 40);
        long long v19 = *(_OWORD *)(v5 - 24);
        *((_DWORD *)v13 - 2) = *((_DWORD *)v5 - 2);
        *(_OWORD *)(v13 - 24) = v19;
        *(_OWORD *)(v13 - 40) = v18;
        *(_OWORD *)(v13 - 56) = v17;
        v13 -= 56;
        v5 -= 56;
      }
      while (v5 != v6);
      unint64_t v5 = *a1;
    }
    *a1 = v13;
    a1[1] = v16;
    a1[2] = v14;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void HGComicColorStroke::HGComicColorStroke(HGComicColorStroke *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v1 = &unk_1F10D5600;
  *(_DWORD *)(v1 + 408) = 1065353216;
  *(_DWORD *)(v1 + 16) |= 0x600u;
}

void HGComicColorStroke::~HGComicColorStroke(HGNode *this)
{
  HGNode::~HGNode(this);

  HGObject::operator delete(v1);
}

uint64_t HGComicColorStroke::SetParameter(HGComicColorStroke *this, int a2, float a3, float a4, float a5, float a6)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  if (*((float *)this + 102) == a3) {
    return 0;
  }
  *((float *)this + 102) = a3;
  return 1;
}

uint64_t HGComicColorStroke::GetDOD(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a3) {
    return 0;
  }
  else {
    return a4;
  }
}

uint64_t HGComicColorStroke::GetROI(HGComicColorStroke *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var2;
  unint64_t v5 = *(void *)&a4.var0;
  if (a3 == 1)
  {
    double v10 = *((float *)this + 102);
    HGTransform::HGTransform((HGTransform *)v17);
    HGTransform::Scale((HGTransform *)v17, v10, v10, 1.0);
    *(void *)&v18.int var0 = 0;
    *(void *)&v18.int var2 = 0;
    float v12 = HGTransformUtils::MinW(v11);
    *(void *)&v23.int var0 = v4;
    *(void *)&v18.int var0 = HGTransformUtils::GetROI((HGTransformUtils *)v17, v5, v23, 0.5, v12);
    *(void *)&v18.int var2 = v13;
    *(void *)&v21.int var0 = 0xFFFFFFF8FFFFFFF8;
    *(void *)&v21.int var2 = 0x800000008;
    HGRect::Grow(&v18, v21);
    uint64_t v14 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    uint64_t v16 = v15;
    *(void *)&v22.int var0 = v14;
    *(void *)&v22.int var2 = v16;
    HGRect::Grow(&v18, v22);
    HGTransform::~HGTransform((HGTransform *)v17);
    return *(void *)&v18.var0;
  }
  else if (a3)
  {
    return HGRectNull;
  }
  else
  {
    HGRect v18 = a4;
    *(void *)&v19.int var0 = 0xFFFFFFF8FFFFFFF8;
    *(void *)&v19.int var2 = 0x800000008;
    HGRect::Grow(&v18, v19);
    uint64_t v6 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    uint64_t v8 = v7;
    *(void *)&v20.int var0 = v6;
    *(void *)&v20.int var2 = v8;
    HGRect::Grow(&v18, v20);
    return *(void *)&v18.var0;
  }
}

void sub_1B7797404(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B7797418(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HGComicColorStroke::IntermediateFormat()
{
  return 24;
}

uint64_t HGComicColorStroke::RenderTile(HGComicColorStroke *this, int32x2_t *a2)
{
  uint64_t v2 = a2;
  float v102 = *((float *)this + 102);
  uint64_t v4 = HGTile::Renderer((HGTile *)a2);
  int v5 = (*(uint64_t (**)(HGComicColorStroke *, uint64_t))(*(void *)this + 312))(this, v4);
  float v6 = v102;
  int v95 = v2[1].i32[1] - HIDWORD(*(unint64_t *)v2);
  uint64_t v99 = v2[1].i32[0] - v2->u32[0];
  if (v95 >= 1 && (int)(v2[1].i32[0] - *(void *)v2) >= 1)
  {
    int v9 = v5;
    int v10 = 0;
    *(float32x2_t *)v11.f32 = vadd_f32(vcvt_f32_s32(*v2), (float32x2_t)0x3F0000003F000000);
    v11.i64[1] = 0x3F80000000000000;
    int32x2_t v100 = v2[2];
    int8x16_t v12 = 0uLL;
    __asm { FMOV            V0.4S, #-1.0 }
    float32x4_t v103 = _Q0;
    __asm { FMOV            V0.4S, #1.0 }
    float32x4_t v106 = _Q0;
    float32x4_t v19 = v11;
    uint64_t v98 = v2;
    float32x4_t v104 = v11;
    do
    {
      int v97 = v10;
      uint64_t v20 = 0;
      float32x4_t v96 = v19;
      float32x4_t v21 = v19;
      do
      {
        int32x2_t v24 = v2[12];
        uint64_t v25 = v2[13].i32[0];
        float32x4_t v26 = vsubq_f32(vmulq_n_f32(v21, v6), v11);
        if (v9)
        {
          int32x4_t v27 = vaddq_s32(vcvtq_s32_f32(v26), vcltzq_f32(v26));
          float32x2_t v28 = (float32x2_t)vsubq_f32(v26, vcvtq_f32_s32(v27)).u64[0];
          BOOL v29 = (float32x4_t *)(*(void *)&v24 + 16 * (v27.i32[0] + v27.i32[1] * (int)v25));
          float32x4_t v30 = vaddq_f32(*v29, vmulq_n_f32(vsubq_f32(v29[1], *v29), v28.f32[0]));
          int8x16_t v31 = (int8x16_t)vaddq_f32(v30, vmulq_lane_f32(vsubq_f32(vaddq_f32(v29[v25], vmulq_n_f32(vsubq_f32(v29[(int)v25 + 1], v29[v25]), v28.f32[0])), v30), v28, 1));
          int32x2_t v32 = v2[10];
          uint64_t v33 = v2[11].i32[0];
          float32x4_t v34 = vsubq_f32(v21, v11);
          float32x4_t v105 = v21;
          int32x4_t v35 = vaddq_s32(vcvtq_s32_f32(v34), vcltzq_f32(v34));
          v34.i64[0] = vsubq_f32(v34, vcvtq_f32_s32(v35)).u64[0];
          unint64_t v36 = (float32x4_t *)(*(void *)&v32 + 16 * (v35.i32[0] + v35.i32[1] * (int)v33));
          float32x4_t v37 = vaddq_f32(*v36, vmulq_n_f32(vsubq_f32(v36[1], *v36), v34.f32[0]));
          uint64_t v38 = v33 + 1;
          float32x4_t v39 = vsubq_f32(vaddq_f32(v36[v33], vmulq_n_f32(vsubq_f32(v36[v33 + 1], v36[v33]), v34.f32[0])), v37);
          float32x4_t v40 = vaddq_f32(v37, vmulq_lane_f32(v39, *(float32x2_t *)v34.f32, 1));
        }
        else
        {
          v41.i64[0] = 0x3F0000003F000000;
          v41.i64[1] = 0x3F0000003F000000;
          float32x4_t v42 = vaddq_f32(v26, v41);
          int32x4_t v43 = vcvtq_s32_f32(v42);
          v42.i64[0] = vaddq_s32(v43, vcgtq_f32(vcvtq_f32_s32(v43), v42)).u64[0];
          int8x16_t v31 = *(int8x16_t *)(*(void *)&v24 + 16 * (v42.i32[0] + v42.i32[1] * (int)v25));
          int32x2_t v32 = v2[10];
          uint64_t v33 = v2[11].i32[0];
          float32x4_t v105 = v21;
          v44.i64[0] = 0x3F0000003F000000;
          v44.i64[1] = 0x3F0000003F000000;
          float32x4_t v45 = vaddq_f32(vsubq_f32(v21, v11), v44);
          int32x4_t v46 = vcvtq_s32_f32(v45);
          float32x4_t v39 = vcvtq_f32_s32(v46);
          v45.i64[0] = vaddq_s32(v46, vcgtq_f32(v39, v45)).u64[0];
          float32x4_t v40 = *(float32x4_t *)(*(void *)&v32 + 16 * (v45.i32[0] + v45.i32[1] * (int)v33));
          uint64_t v38 = (int)v33 + 1;
        }
        float32x4_t v47 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v31.i8, 1);
        v39.i64[0] = 0;
        int8x16_t v48 = v31;
        v48.i32[1] = 0;
        int8x16_t v49 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8(vorrq_s8((int8x16_t)vcgtq_f32(v39, v47), (int8x16_t)vcgeq_f32(v47, v39))), 0), v48, v31);
        float32x4_t v50 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v49, 2);
        int8x16_t v51 = v49;
        v51.i32[2] = 0;
        v49.i64[0] = vextq_s8(vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8(vorrq_s8((int8x16_t)vcgtq_f32(v39, v50), (int8x16_t)vcgeq_f32(v50, v39))), 0), v51, v49), v12, 4uLL).u64[0];
        v49.i64[1] = v12.i64[1];
        float32x4_t v52 = vminnmq_f32(vmaxnmq_f32(vaddq_f32(vaddq_f32((float32x4_t)v49, (float32x4_t)v49), v103), v103), v106);
        float32x4_t v53 = vnegq_f32(v52);
        uint64_t v54 = (int)v25 + 1;
        int v55 = -1;
        __int32 v101 = v40.i32[3];
        float32x4_t v56 = v40;
        float32x4_t v57 = (float32x4_t)xmmword_1B7E75840;
        do
        {
          float32x4_t v107 = v57;
          float32x4_t v108 = v56;
          float32x4_t v109 = v53;
          float32x4_t v110 = v52;
          *(float *)v62.i32 = expf((float)v55 / 48.0);
          int8x16_t v12 = 0uLL;
          float32x4_t v63 = vaddq_f32(v105, (float32x4_t)v110.u64[0]);
          float32x4_t v64 = vsubq_f32(v63, v104);
          if (v9)
          {
            int32x4_t v65 = vaddq_s32(vcvtq_s32_f32(v64), vcltzq_f32(v64));
            float32x2_t v66 = (float32x2_t)vsubq_f32(v64, vcvtq_f32_s32(v65)).u64[0];
            long long v67 = (float32x4_t *)(*(void *)&v32 + 16 * (v65.i32[0] + v65.i32[1] * (int)v33));
            float32x4_t v68 = vaddq_f32(*v67, vmulq_n_f32(vsubq_f32(v67[1], *v67), v66.f32[0]));
            float32x4_t v69 = vaddq_f32(v68, vmulq_lane_f32(vsubq_f32(vaddq_f32(v67[v33], vmulq_n_f32(vsubq_f32(v67[v38], v67[v33]), v66.f32[0])), v68), v66, 1));
            float32x4_t v70 = vaddq_f32(v105, (float32x4_t)v109.u64[0]);
            float32x4_t v71 = vsubq_f32(v70, v104);
            int32x4_t v72 = vaddq_s32(vcvtq_s32_f32(v71), vcltzq_f32(v71));
            v71.i64[0] = vsubq_f32(v71, vcvtq_f32_s32(v72)).u64[0];
            uint64_t v73 = (float32x4_t *)(*(void *)&v32 + 16 * (v72.i32[0] + v72.i32[1] * (int)v33));
            float32x4_t v74 = vaddq_f32(*v73, vmulq_n_f32(vsubq_f32(v73[1], *v73), v71.f32[0]));
            float32x4_t v75 = vaddq_f32(v69, vaddq_f32(v74, vmulq_lane_f32(vsubq_f32(vaddq_f32(v73[v33], vmulq_n_f32(vsubq_f32(v73[v38], v73[v33]), v71.f32[0])), v74), *(float32x2_t *)v71.f32, 1)));
            float v6 = v102;
            float32x4_t v76 = vsubq_f32(vmulq_n_f32(v63, v102), v104);
            int32x4_t v77 = vaddq_s32(vcvtq_s32_f32(v76), vcltzq_f32(v76));
            v76.i64[0] = vsubq_f32(v76, vcvtq_f32_s32(v77)).u64[0];
            unint64_t v78 = (float32x4_t *)(*(void *)&v24 + 16 * (v77.i32[0] + v77.i32[1] * (int)v25));
            float32x4_t v79 = vaddq_f32(*v78, vmulq_n_f32(vsubq_f32(v78[1], *v78), v76.f32[0]));
            int8x16_t v80 = (int8x16_t)vaddq_f32(v79, vmulq_lane_f32(vsubq_f32(vaddq_f32(v78[v25], vmulq_n_f32(vsubq_f32(v78[v54], v78[v25]), v76.f32[0])), v79), *(float32x2_t *)v76.f32, 1));
            float32x4_t v81 = vsubq_f32(vmulq_n_f32(v70, v102), v104);
            int32x4_t v91 = vaddq_s32(vcvtq_s32_f32(v81), vcltzq_f32(v81));
            v81.i64[0] = vsubq_f32(v81, vcvtq_f32_s32(v91)).u64[0];
            uint64_t v92 = (float32x4_t *)(*(void *)&v24 + 16 * (v91.i32[0] + v91.i32[1] * (int)v25));
            float32x4_t v93 = vaddq_f32(*v92, vmulq_n_f32(vsubq_f32(v92[1], *v92), v81.f32[0]));
            int8x16_t v94 = (int8x16_t)vaddq_f32(v93, vmulq_lane_f32(vsubq_f32(vaddq_f32(v92[v25], vmulq_n_f32(vsubq_f32(v92[v54], v92[v25]), v81.f32[0])), v93), *(float32x2_t *)v81.f32, 1));
          }
          else
          {
            v82.i64[0] = 0x3F0000003F000000;
            v82.i64[1] = 0x3F0000003F000000;
            float32x4_t v83 = vaddq_f32(v64, v82);
            int32x4_t v84 = vcvtq_s32_f32(v83);
            v83.i64[0] = vaddq_s32(v84, vcgtq_f32(vcvtq_f32_s32(v84), v83)).u64[0];
            float32x4_t v85 = *(float32x4_t *)(*(void *)&v32 + 16 * (v83.i32[0] + v83.i32[1] * (int)v33));
            float32x4_t v86 = vaddq_f32(v105, (float32x4_t)v109.u64[0]);
            float32x4_t v87 = vaddq_f32(vsubq_f32(v86, v104), v82);
            int32x4_t v88 = vcvtq_s32_f32(v87);
            v87.i64[0] = vaddq_s32(v88, vcgtq_f32(vcvtq_f32_s32(v88), v87)).u64[0];
            float32x4_t v75 = vaddq_f32(v85, *(float32x4_t *)(*(void *)&v32 + 16 * (v87.i32[0] + v87.i32[1] * (int)v33)));
            float v6 = v102;
            float32x4_t v89 = vaddq_f32(vsubq_f32(vmulq_n_f32(v63, v102), v104), v82);
            float32x4_t v90 = (float32x4_t)vcvtq_s32_f32(v89);
            v89.i64[0] = vaddq_s32((int32x4_t)v90, vcgtq_f32(vcvtq_f32_s32((int32x4_t)v90), v89)).u64[0];
            int8x16_t v80 = *(int8x16_t *)(*(void *)&v24 + 16 * (v89.i32[0] + v89.i32[1] * (int)v25));
            v90.i64[0] = 0x3F0000003F000000;
            v90.i64[1] = 0x3F0000003F000000;
            float32x4_t v58 = vaddq_f32(vsubq_f32(vmulq_n_f32(v86, v102), v104), v90);
            int32x4_t v59 = vcvtq_s32_f32(v58);
            v58.i64[0] = vaddq_s32(v59, vcgtq_f32(vcvtq_f32_s32(v59), v58)).u64[0];
            int8x16_t v94 = *(int8x16_t *)(*(void *)&v24 + 16 * (v58.i32[0] + v58.i32[1] * (int)v25));
          }
          float32x4_t v57 = vaddq_f32(v107, (float32x4_t)vdupq_lane_s32(v62, 0));
          float32x4_t v56 = vaddq_f32(v108, vmulq_n_f32(v75, *(float *)v62.i32));
          unint64_t v60 = vextq_s8(v80, (int8x16_t)0, 4uLL).u64[0];
          float32x4_t v52 = vaddq_f32(v110, vminnmq_f32(vmaxnmq_f32(vaddq_f32(vaddq_f32((float32x4_t)v60, (float32x4_t)v60), v103), v103), v106));
          unint64_t v61 = vextq_s8(v94, (int8x16_t)0, 4uLL).u64[0];
          float32x4_t v53 = vaddq_f32(v109, vminnmq_f32(vmaxnmq_f32(vaddq_f32(vaddq_f32((float32x4_t)v61, (float32x4_t)v61), v103), v103), v106));
          --v55;
        }
        while (v55 != -8);
        v22.i64[0] = 0x3F0000003F000000;
        v22.i64[1] = 0x3F0000003F000000;
        float32x4_t v23 = vdivq_f32(vmulq_f32(v56, v22), v57);
        v23.i32[3] = v101;
        *(float32x4_t *)(*(void *)&v100 + 16 * v20) = vmaxnmq_f32(vminnmq_f32(v23, v106), (float32x4_t)0);
        float32x4_t v11 = v104;
        float32x4_t v21 = vaddq_f32(v105, (float32x4_t)xmmword_1B7E736B0);
        ++v20;
        uint64_t v2 = v98;
      }
      while (v20 != v99);
      float32x4_t v19 = vaddq_f32(v96, (float32x4_t)xmmword_1B7E736C0);
      *(void *)&v100 += 16 * v98[3].i32[0];
      int v10 = v97 + 1;
    }
    while (v97 + 1 != v95);
  }
  return 0;
}

const char *HGComicColorStroke::GetProgram(HGComicColorStroke *this, HGRenderer *a2)
{
  if (HGRenderer::GetTarget(a2, 393216) > 0x60B0F) {
    return "//Metal1.0     \n"
  }
           "//LEN=00000008b5\n"
           "fragment FragmentOut fragmentFunc(VertexInOut            frag        [[ stage_in ]],\n"
           "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
           "                                  texture2d< half >      hg_Texture0 [[ texture(0) ]],\n"
           "                                  sampler                hg_Sampler0 [[ sampler(0) ]],\n"
           "                                  texture2d< half >      hg_Texture1 [[ texture(1) ]],\n"
           "                                  sampler                hg_Sampler1 [[ sampler(1) ]])\n"
           "{\n"
           "    // Get the 0'th normal (e0, for an exponent value of 0, so the coeff is 1.0)\n"
           "    float2 pointer = static_cast<float2>(hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy).yz * 2.0f) - 1.0"
           "f;\n"
           "    float2 pointerRBacuint64_t k = -pointer;\n"
           "    \n"
           "    half4 acc = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
           "    half3 norma = {0.5h, 0.5h, 0.5h};\n"
           "\n"
           "    for (int i {1}; i < 8; ++i)\n"
           "    {\n"
           "        half coeff = exp(static_cast<half>(-i) / 48.0h);\n"
           "        norma += coeff;\n"
           "        \n"
           "        const float2 uPos0 = frag._texCoord0.xy + pointer;\n"
           "        const float2 uNeg0 = frag._texCoord0.xy + pointerRBack;\n"
           "        \n"
           "        const float2 uPos1 = frag._texCoord1.xy + pointer;\n"
           "        const float2 uNeg1 = frag._texCoord1.xy + pointerRBack;\n"
           "        \n"
           "        float2 acc_ptrTexCoord = uPos0;\n"
           "        float2 acc_ptrBackTexCoord = uNeg0;\n"
           "        \n"
           "        float2 grad_ptrTexCoord = uPos1;\n"
           "        float2 grad_ptrBackTexCoord = uNeg1;\n"
           "    \n"
           "        acc.rgb += coeff * (hg_Texture0.sample(hg_Sampler0, acc_ptrTexCoord).xyz +\n"
           "                            hg_Texture0.sample(hg_Sampler0, acc_ptrBackTexCoord).xyz);\n"
           "\n"
           "        pointer += static_cast<float2>(hg_Texture1.sample(hg_Sampler1, grad_ptrTexCoord).yz * 2.0f) - 1.0f;\n"
           "        pointerRBack -= static_cast<float2>(hg_Texture1.sample(hg_Sampler1, grad_ptrBackTexCoord).yz * 2.0f) "
           "- 1.0f;\n"
           "    }\n"
           "\n"
           "    FragmentOut out {float4(float3(acc.xyz * 0.5h / norma), acc.a)};\n"
           "    \n"
           "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
           "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
           "    out.color0 = clamp(out.color0, 0.0f, 1.0f);\n"
           "    \n"
           "    return out;\n"
           "}\n"
           "//MD5=4e997c85:a0f6903a:77463274:2dba1821\n"
           "//SIG=00000000:00000000:00000000:00000003:000f:0000:0000:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46)) {
    return "//GLfs1.0      \n"
  }
           "//LEN=000000079c\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#define precision\n"
           "#define defaultp mediump\n"
           "#endif\n"
           "\n"
           " \n"
           "precision highp float;\n"
           "precision highp int;\n"
           "\n"
           "uniform defaultp sampler2DRect hg_Texture0;\n"
           "uniform defaultp sampler2DRect hg_Texture1;\n"
           "\n"
           "void main (void) \n"
           "{\n"
           "    float alpha = texture2DRect( hg_Texture0, gl_TexCoord[0].xy).a;\n"
           "    vec3 acc  =  texture2DRect( hg_Texture0, gl_TexCoord[0].xy).xyz; //L de LAB\n"
           "    vec3 norma  =  vec3(0.5,0.5,0.5) ;\n"
           "    \n"
           "    vec2 gradient = texture2DRect(hg_Texture1, gl_TexCoord[1].xy).yz; //DIRECCIONES\n"
           "    vec2 vdire = vec2( gradient.x*2.0-1.0 , gradient.y*2.0-1.0) ;\n"
           "    vec2 pointer = vec2( vdire.x  , vdire.y ) ;\n"
           "\n"
           "    vdire =   vec2( -(gradient.x*2.0-1.0) , -(gradient.y*2.0-1.0)) ;\n"
           "    vec2 pointerRBacuint64_t k =   vec2(  vdire.x  ,  vdire.y ) ;\n"
           "\n"
           "    for (float  i=1.0 ;i < 8.0 ;i++)    // direccion normal   1 - 7\n"
           "    {\n"
           "        float coeff =  exp(  - i / 48.0) ;\n"
           "        \n"
           "        vec2 uPos0 = gl_TexCoord[0].xy + pointer;\n"
           "        vec2 uNeg0 = gl_TexCoord[0].xy + pointerRBack;\n"
           "\n"
           "        vec2 uPos1 = gl_TexCoord[1].xy + pointer;\n"
           "        vec2 uNeg1 = gl_TexCoord[1].xy + pointerRBack;\n"
           "\n"
           "        acc  +=coeff * (texture2DRect(hg_Texture0, uPos0).xyz +\n"
           "                        texture2DRect(hg_Texture0, uNeg0).xyz);\n"
           "\n"
           "        norma += coeff;\n"
           "\n"
           "        gradient  = texture2DRect(hg_Texture1, uPos1).yz; //DIRECCIONES\n"
           "        vdire =   vec2( gradient.x*2.0-1.0 , gradient.y*2.0-1.0);\n"
           "        pointer +=  vdire  ;\n"
           "\n"
           "        gradient  = texture2DRect(hg_Texture1, uNeg1).yz; //DIRECCIONES\n"
           "        vdire =   vec2(-( gradient.x*2.0-1.0) , -(gradient.y*2.0-1.0));\n"
           "        pointerRBack +=  vdire  ;\n"
           "    }\n"
           "    \n"
           "    // Ensure the result is clamped [0..1]; this is the default behavior of the original\n"
           "    // comic effect - this was implicit due to non-float, 8-bit, intermediate buffers.\n"
           "    gl_FragColor = clamp(vec4( acc*0.5/norma, alpha), 0.0, 1.0);\n"
           "}\n"
           "//MD5=3f48c7c9:9fb108b9:ab3c5d18:9729c820\n"
           "//SIG=00000000:00000000:00000000:00000000:0032:0000:0000:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  return 0;
}

uint64_t HGComicColorStroke::BindTexture(HGComicColorStroke *this, HGHandler *a2, uint64_t a3)
{
  if (a3 == 1)
  {
    HGHandler::TexCoord(a2, 1, 0, 0, 0);
    (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 104))(a2, *((float *)this + 102), *((float *)this + 102), 1.0);
  }
  else if (!a3)
  {
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
  }
  (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, a3, 0);
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 56))(a2, 0);
  (*(void (**)(HGHandler *, uint64_t, uint64_t))(*(void *)a2 + 48))(a2, 1, 1);
  return 0;
}

uint64_t HGMetalFunctionCache::HGMetalFunctionCache(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_DWORD *)(a1 + 40) = 1065353216;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 48), 0);
  return a1;
}

void sub_1B7797CC8(_Unwind_Exception *a1)
{
  uint64_t v4 = *(void ***)(v2 + 24);
  if (v4) {
    HGMetalFunctionCache::HGMetalFunctionCache(v4);
  }
  HGMetalFunctionCache::HGMetalFunctionCache(v1);
  _Unwind_Resume(a1);
}

uint64_t *HGMetalFunctionCache::getFunction(uint64_t a1, const std::string *a2, uint64_t a3)
{
  memset(&__p, 0, sizeof(__p));
  std::string::operator=(&__p, a2);
  uint64_t v10 = a3;
  int v5 = (pthread_mutex_t *)(a1 + 48);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 48));
  float v6 = std::__hash_table<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::__unordered_map_hasher<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,HGMetalFunctionCache::InfoHash,std::equal_to<HGMetalFunctionCache::Info>,true>,std::__unordered_map_equal<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::equal_to<HGMetalFunctionCache::Info>,HGMetalFunctionCache::InfoHash,true>,std::allocator<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>>>::find<HGMetalFunctionCache::Info>((void *)(a1 + 8), (uint64_t)&__p);
  if (v6) {
    uint64_t v7 = v6[6];
  }
  else {
    uint64_t v7 = 0;
  }
  pthread_mutex_unlock(v5);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v7;
}

void sub_1B7797D80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *HGMetalFunctionCache::getFunctionWithSource(uint64_t a1, std::string *a2, uint64_t a3, uint64_t *a4)
{
  memset(&__p, 0, sizeof(__p));
  std::string::operator=(&__p, a2);
  uint64_t v12 = a3;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 48));
  uint64_t v8 = std::__hash_table<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::__unordered_map_hasher<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,HGMetalFunctionCache::InfoHash,std::equal_to<HGMetalFunctionCache::Info>,true>,std::__unordered_map_equal<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::equal_to<HGMetalFunctionCache::Info>,HGMetalFunctionCache::InfoHash,true>,std::allocator<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>>>::find<HGMetalFunctionCache::Info>((void *)(a1 + 8), (uint64_t)&__p);
  if (v8)
  {
    FunctionWithSource = v8[6];
  }
  else
  {
    FunctionWithSource = (uint64_t *)HGMetalFunctionCache::_createFunctionWithSource((id *)a1, (uint64_t *)a2, a4);
    if (FunctionWithSource)
    {
      p_p = &__p;
      std::__hash_table<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::__unordered_map_hasher<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,HGMetalFunctionCache::InfoHash,std::equal_to<HGMetalFunctionCache::Info>,true>,std::__unordered_map_equal<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::equal_to<HGMetalFunctionCache::Info>,HGMetalFunctionCache::InfoHash,true>,std::allocator<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>>>::__emplace_unique_key_args<HGMetalFunctionCache::Info,std::piecewise_construct_t const&,std::tuple<HGMetalFunctionCache::Info const&>,std::tuple<>>(a1 + 8, (uint64_t)&__p, (uint64_t)&std::piecewise_construct, (long long **)&p_p)[6] = FunctionWithSource;
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 48));
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return FunctionWithSource;
}

void sub_1B7797E7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGMetalFunctionCache::_createFunctionWithSource(id *a1, uint64_t *a2, uint64_t *a3)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v22, "metal", 2, "HGMetalFunctionCache::_createFunctionWithSource()");
  if (*((char *)a3 + 23) >= 0) {
    float v6 = a3;
  }
  else {
    float v6 = (uint64_t *)*a3;
  }
  uint64_t v7 = [NSString stringWithUTF8String:v6];
  id v8 = objc_alloc_init(MEMORY[0x1E4F351F8]);
  [v8 setLanguageVersion:131075];
  [v8 setFastMathEnabled:1];
  id v21 = 0;
  int v9 = (void *)[*a1 newLibraryWithSource:v7 options:v8 error:&v21];

  if (v21
    && ((uint64_t v10 = objc_msgSend((id)objc_msgSend(v21, "localizedDescription"), "UTF8String"), *((char *)a3 + 23) >= 0)
      ? (uint64_t v13 = a3)
      : (uint64_t v13 = (uint64_t *)*a3),
        HGLogger::warning((HGLogger *)"Failed to compile metal shader library!\n\n%s\n\n%s\n", v11, v12, v10, v13),
        [v21 code] != 4))
  {
    if (v9) {

    }
    uint64_t v17 = 0;
  }
  else
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v14 = a2;
    }
    else {
      uint64_t v14 = (uint64_t *)*a2;
    }
    uint64_t v17 = objc_msgSend(v9, "newFunctionWithName:", objc_msgSend(NSString, "stringWithUTF8String:", v14));
    if (!v17)
    {
      unsigned __int8 v18 = atomic_load(HGLogger::_enabled);
      if (v18)
      {
        if (*((char *)a2 + 23) >= 0) {
          float32x4_t v19 = a2;
        }
        else {
          float32x4_t v19 = (uint64_t *)*a2;
        }
        HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"failed to retrieve %s from compiler shader!\n", v15, v16, v19);
      }
    }
    if (v9) {
  }
    }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v22);
  return v17;
}

void sub_1B7798030(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7798044(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7798058(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B779806C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t *HGMetalFunctionCache::getFunctionWithLibrary(uint64_t a1, std::string *a2, uint64_t a3)
{
  memset(&__p, 0, sizeof(__p));
  std::string::operator=(&__p, a2);
  int v6 = *(char *)(a3 + 23);
  if (v6 >= 0) {
    uint64_t v7 = (uint64_t *)a3;
  }
  else {
    uint64_t v7 = *(uint64_t **)a3;
  }
  if (v6 >= 0) {
    unint64_t v8 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    unint64_t v8 = *(void *)(a3 + 8);
  }
  unint64_t v13 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&p_p, v7, v8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 48));
  int v9 = std::__hash_table<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::__unordered_map_hasher<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,HGMetalFunctionCache::InfoHash,std::equal_to<HGMetalFunctionCache::Info>,true>,std::__unordered_map_equal<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::equal_to<HGMetalFunctionCache::Info>,HGMetalFunctionCache::InfoHash,true>,std::allocator<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>>>::find<HGMetalFunctionCache::Info>((void *)(a1 + 8), (uint64_t)&__p);
  if (v9)
  {
    FunctionWithLibrary = v9[6];
  }
  else
  {
    FunctionWithLibrary = (uint64_t *)HGMetalFunctionCache::_createFunctionWithLibrary((id *)a1, (uint64_t *)a2, (uint64_t *)a3);
    if (FunctionWithLibrary)
    {
      p_p = &__p;
      std::__hash_table<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::__unordered_map_hasher<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,HGMetalFunctionCache::InfoHash,std::equal_to<HGMetalFunctionCache::Info>,true>,std::__unordered_map_equal<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::equal_to<HGMetalFunctionCache::Info>,HGMetalFunctionCache::InfoHash,true>,std::allocator<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>>>::__emplace_unique_key_args<HGMetalFunctionCache::Info,std::piecewise_construct_t const&,std::tuple<HGMetalFunctionCache::Info const&>,std::tuple<>>(a1 + 8, (uint64_t)&__p, (uint64_t)&std::piecewise_construct, (long long **)&p_p)[6] = FunctionWithLibrary;
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 48));
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return FunctionWithLibrary;
}

void sub_1B7798178(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *HGMetalFunctionCache::_createFunctionWithLibrary(id *a1, uint64_t *a2, uint64_t *a3)
{
  unint64_t v3 = a3;
  if (*((char *)a3 + 23) < 0)
  {
    if (!a3[1]) {
      goto LABEL_7;
    }
    a3 = (uint64_t *)*a3;
LABEL_6:
    int v6 = (void *)[NSString stringWithUTF8String:a3];
    goto LABEL_8;
  }
  if (*((unsigned char *)a3 + 23)) {
    goto LABEL_6;
  }
LABEL_7:
  int v6 = objc_msgSend((id)objc_msgSend(MEMORY[0x1E4F28B50], "mainBundle"), "pathForResource:ofType:", @"default", @"metallib");
  if (!v6)
  {
    HGLogger::warning((HGLogger *)"Failed to retrieve path for library default.metallib\n", v7, v8);
    return v6;
  }
LABEL_8:
  id v21 = 0;
  int v9 = objc_msgSend(*a1, "newLibraryWithURL:error:", objc_msgSend(MEMORY[0x1E4F1CB10], "fileURLWithPath:", v6), &v21);
  if (v21)
  {
    uint64_t v10 = [v6 UTF8String];
    uint64_t v11 = objc_msgSend((id)objc_msgSend(v21, "localizedDescription"), "UTF8String");
    HGLogger::warning((HGLogger *)"Failed to create new metal library from %s:\\n\n%s\n\n", v12, v13, v10, v11);
    if ([v21 code] != 4)
    {
      int v6 = 0;
      if (!v9) {
        return v6;
      }
LABEL_25:

      return v6;
    }
  }
  if (*((char *)a2 + 23) >= 0) {
    uint64_t v14 = a2;
  }
  else {
    uint64_t v14 = (uint64_t *)*a2;
  }
  int v6 = objc_msgSend(v9, "newFunctionWithName:", objc_msgSend(NSString, "stringWithUTF8String:", v14));
  if (!v6)
  {
    unsigned __int8 v17 = atomic_load(HGLogger::_enabled);
    if (v17)
    {
      if (*((char *)a2 + 23) >= 0) {
        unsigned __int8 v18 = a2;
      }
      else {
        unsigned __int8 v18 = (uint64_t *)*a2;
      }
      if (*((char *)v3 + 23) >= 0) {
        float32x4_t v19 = v3;
      }
      else {
        float32x4_t v19 = (uint64_t *)*v3;
      }
      HGLogger::log((HGLogger *)"metal", (const char *)1, (HGLogger *)"failed to retrieve %s from metal library %s!\n", v15, v16, v18, v19);
    }
  }
  if (v9) {
    goto LABEL_25;
  }
  return v6;
}

uint64_t HGMetalRenderPipelineStateCache::Info::operator<(int *a1, int *a2)
{
  unint64_t v2 = *((void *)a1 + 49);
  unint64_t v3 = *((void *)a2 + 49);
  if (v2 < v3) {
    return 1;
  }
  if (v3 < v2) {
    return 0;
  }
  unint64_t v6 = *((void *)a1 + 50);
  unint64_t v7 = *((void *)a2 + 50);
  if (v6 >= v7)
  {
    if (v7 >= v6)
    {
      uint64_t v20 = (unint64_t *)*((void *)a2 + 51);
      id v21 = (unint64_t *)*((void *)a2 + 52);
      float32x4_t v23 = (unint64_t *)*((void *)a1 + 51);
      float32x4_t v22 = (unint64_t *)*((void *)a1 + 52);
      if (v20 != v21)
      {
        int32x2_t v24 = v20 + 1;
        uint64_t v25 = (unint64_t *)*((void *)a1 + 51);
        while (v25 != v22)
        {
          unint64_t v26 = *v25;
          unint64_t v27 = *(v24 - 1);
          if (*v25 < v27) {
            break;
          }
          ++v25;
          if (v27 < v26 || v24++ == v21) {
            goto LABEL_36;
          }
        }
        return 1;
      }
LABEL_36:
      if (v23 == v22)
      {
LABEL_45:
        unsigned int v33 = a1[96];
        unsigned int v34 = a2[96];
        if (v33 < v34) {
          return 1;
        }
        if (v34 >= v33)
        {
          unsigned int v35 = *((unsigned __int8 *)a1 + 388);
          unsigned int v36 = *((unsigned __int8 *)a2 + 388);
          BOOL v37 = v35 >= v36;
          BOOL v4 = v35 < v36;
          if (!v37) {
            return v4;
          }
        }
      }
      else
      {
        BOOL v29 = v23 + 1;
        while (v20 != v21)
        {
          unint64_t v30 = *v20;
          unint64_t v31 = *(v29 - 1);
          if (*v20 < v31) {
            break;
          }
          ++v20;
          if (v31 < v30 || v29++ == v22) {
            goto LABEL_45;
          }
        }
      }
    }
    unint64_t v8 = *((void *)a2 + 50);
    unint64_t v9 = *((void *)a1 + 50);
    if (v8 >= v9)
    {
      if (v9 >= v8)
      {
        uint64_t v38 = (unint64_t *)*((void *)a1 + 51);
        float32x4_t v39 = (unint64_t *)*((void *)a1 + 52);
        float32x4_t v41 = (unint64_t *)*((void *)a2 + 51);
        float32x4_t v40 = (unint64_t *)*((void *)a2 + 52);
        if (v38 != v39)
        {
          float32x4_t v42 = v38 + 1;
          int32x4_t v43 = (unint64_t *)*((void *)a2 + 51);
          while (v43 != v40)
          {
            unint64_t v44 = *v43;
            unint64_t v45 = *(v42 - 1);
            if (*v43 < v45) {
              break;
            }
            ++v43;
            if (v45 < v44 || v42++ == v39) {
              goto LABEL_59;
            }
          }
          return 0;
        }
LABEL_59:
        if (v41 == v40)
        {
LABEL_68:
          unsigned int v51 = a2[96];
          unsigned int v52 = a1[96];
          if (v51 < v52 || v52 >= v51 && *((unsigned __int8 *)a2 + 388) < *((unsigned __int8 *)a1 + 388)) {
            return 0;
          }
        }
        else
        {
          float32x4_t v47 = v41 + 1;
          while (v38 != v39)
          {
            unint64_t v48 = *v38;
            unint64_t v49 = *(v47 - 1);
            if (*v38 < v49) {
              break;
            }
            ++v38;
            if (v49 < v48 || v47++ == v40) {
              goto LABEL_68;
            }
          }
        }
      }
      int v10 = *a1;
      int v11 = *a2;
      if (*a1 < *a2) {
        return 1;
      }
      unint64_t v12 = 0;
      unint64_t v13 = (unsigned __int8 *)(a2 + 10);
      for (uint64_t i = (unsigned __int8 *)(a1 + 10); ; i += 48)
      {
        if (v11 >= v10)
        {
          unsigned int v15 = *i;
          unsigned int v16 = *v13;
          if (v15 < v16) {
            return 1;
          }
          if (v16 > (v15 - 1))
          {
            if (HGBlendingInfo::operator<((uint64_t)(i - 32), (uint64_t)(v13 - 32))) {
              return 1;
            }
            int v11 = *((_DWORD *)v13 - 10);
            int v10 = *((_DWORD *)i - 10);
          }
        }
        if (v11 < v10) {
          break;
        }
        if (v10 < v11) {
          goto LABEL_13;
        }
        unsigned int v17 = *v13;
        unsigned int v18 = *i;
        if (v17 < v18) {
          return 0;
        }
        if (v18 <= (v17 - 1))
        {
LABEL_13:
          if (v12 > 6) {
            return 0;
          }
        }
        else
        {
          BOOL v19 = HGBlendingInfo::operator<((uint64_t)(v13 - 32), (uint64_t)(i - 32));
          BOOL v4 = 0;
          if (v19 || v12 > 6) {
            return v4;
          }
        }
        ++v12;
        int v10 = *((_DWORD *)i + 2);
        int v11 = *((_DWORD *)v13 + 2);
        v13 += 48;
        BOOL v4 = 1;
        if (v10 < v11) {
          return v4;
        }
      }
    }
    return 0;
  }
  return 1;
}

uint64_t HGMetalRenderPipelineStateCache::HGMetalRenderPipelineStateCache(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a1 + 16;
  *(void *)(a1 + 24) = 0;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 32), 0);
  return a1;
}

void sub_1B7798660(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::__map_value_compare<HGMetalRenderPipelineStateCache::Info,std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::less<HGMetalRenderPipelineStateCache::Info>,true>,std::allocator<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>>>::destroy(v1, *v2);
  _Unwind_Resume(a1);
}

uint64_t HGMetalRenderPipelineStateCache::clear(HGMetalRenderPipelineStateCache *this)
{
  unint64_t v2 = (pthread_mutex_t *)((char *)this + 32);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  unint64_t v3 = (uint64_t *)*((void *)this + 1);
  if (v3 != (uint64_t *)((char *)this + 16))
  {
    do
    {
      int v5 = (void *)v3[58];
      if (v5) {

      }
      unint64_t v6 = (HGMetalRenderPipelineStateCache *)v3[1];
      unint64_t v7 = v3;
      if (v6)
      {
        do
        {
          unint64_t v8 = v6;
          unint64_t v6 = *(HGMetalRenderPipelineStateCache **)v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          unint64_t v8 = (HGMetalRenderPipelineStateCache *)*((void *)v7 + 2);
          BOOL v9 = *(void *)v8 == (void)v7;
          unint64_t v7 = v8;
        }
        while (!v9);
      }
      if (*((uint64_t **)this + 1) == v3) {
        *((void *)this + 1) = v8;
      }
      int v10 = (uint64_t *)*((void *)this + 2);
      --*((void *)this + 3);
      std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v10, v3);
      int v11 = (void *)v3[55];
      if (v11)
      {
        v3[56] = (uint64_t)v11;
        operator delete(v11);
      }
      operator delete(v3);
      unint64_t v3 = (uint64_t *)v8;
    }
    while (v8 != (HGMetalRenderPipelineStateCache *)((char *)this + 16));
  }

  return pthread_mutex_unlock(v2);
}

void *HGMetalRenderPipelineStateCache::getRenderPipelineState(uint64_t a1, int *a2)
{
  BOOL v4 = (pthread_mutex_t *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = a1 + 8;
  if (!v5) {
    goto LABEL_8;
  }
  uint64_t v7 = a1 + 16;
  do
  {
    int v8 = HGMetalRenderPipelineStateCache::Info::operator<((int *)(v5 + 32), a2);
    BOOL v9 = (uint64_t *)(v5 + 8);
    if (!v8)
    {
      BOOL v9 = (uint64_t *)v5;
      uint64_t v7 = v5;
    }
    uint64_t v5 = *v9;
  }
  while (*v9);
  if (v7 == a1 + 16 || HGMetalRenderPipelineStateCache::Info::operator<(a2, (int *)(v7 + 32)))
  {
LABEL_8:
    RenderPipelineState = HGMetalRenderPipelineStateCache::_createRenderPipelineState((id *)a1, (uint64_t)a2);
    uint64_t v14 = a2;
    std::__tree<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::__map_value_compare<HGMetalRenderPipelineStateCache::Info,std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::less<HGMetalRenderPipelineStateCache::Info>,true>,std::allocator<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>>>::__emplace_unique_key_args<HGMetalRenderPipelineStateCache::Info,std::piecewise_construct_t const&,std::tuple<HGMetalRenderPipelineStateCache::Info const&>,std::tuple<>>(v6, a2, (uint64_t)&std::piecewise_construct, (const void **)&v14)[58] = (uint64_t)RenderPipelineState;
  }
  uint64_t v14 = a2;
  int v11 = (void *)std::__tree<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::__map_value_compare<HGMetalRenderPipelineStateCache::Info,std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::less<HGMetalRenderPipelineStateCache::Info>,true>,std::allocator<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>>>::__emplace_unique_key_args<HGMetalRenderPipelineStateCache::Info,std::piecewise_construct_t const&,std::tuple<HGMetalRenderPipelineStateCache::Info const&>,std::tuple<>>(v6, a2, (uint64_t)&std::piecewise_construct, (const void **)&v14)[58];
  pthread_mutex_unlock(v4);
  id v12 = v11;
  return v11;
}

void *HGMetalRenderPipelineStateCache::_createRenderPipelineState(id *a1, uint64_t a2)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v28, "mtl_utils", 2, "HGMetalRenderPipelineStateCache::_createRenderPipelineState()");
  BOOL v4 = objc_opt_new();
  [v4 setStencilAttachmentPixelFormat:0];
  [v4 setRasterSampleCount:*(unsigned int *)(a2 + 384)];
  [v4 setVertexFunction:*(void *)(a2 + 392)];
  [v4 setFragmentFunction:*(void *)(a2 + 400)];
  id v5 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  uint64_t v6 = *(void **)(a2 + 408);
  for (uint64_t i = *(void **)(a2 + 416); v6 != i; ++v6)
    [v5 addObject:*v6];
  unint64_t v26 = a1;
  if ([v5 count])
  {
    int v8 = (void *)[MEMORY[0x1E4F352B0] linkedFunctions];
    [v8 setPrivateFunctions:v5];
    [v4 setFragmentLinkedFunctions:v8];
  }
  uint64_t v9 = 0;
  int v10 = (_DWORD *)a2;
  int v11 = (_DWORD *)a2;
  do
  {
    int v12 = *v11;
    v11 += 12;
    if (*((unsigned char *)v10 + 40))
    {
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v4, "colorAttachments"), "objectAtIndexedSubscript:", v9), "setBlendingEnabled:", 1);
      unsigned __int8 v15 = atomic_load(HGLogger::_enabled);
      if (v15) {
        HGLogger::log((HGLogger *)"mtl_utils", (const char *)3, (HGLogger *)"[BLENDING ON] for unit: %d\n", v13, v14, v9);
      }
      HGMetalBlendingInfo::HGMetalBlendingInfo((HGMetalBlendingInfo *)v27, (const HGBlendingInfo *)(v10 + 2));
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v4, "colorAttachments"), "objectAtIndexedSubscript:", v9), "setAlphaBlendOperation:", HGPool::FixedTotalUsageServicingPolicy::maxObjectAgeNS((HGPool::FixedTotalUsageServicingPolicy *)v27, v16));
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v4, "colorAttachments"), "objectAtIndexedSubscript:", v9), "setRgbBlendOperation:", HGParamField::fieldSize((HGParamField *)v27));
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v4, "colorAttachments"), "objectAtIndexedSubscript:", v9), "setDestinationAlphaBlendFactor:", PVInstructionGraphContext::HGNodeCache((PVInstructionGraphContext *)v27));
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v4, "colorAttachments"), "objectAtIndexedSubscript:", v9), "setDestinationRGBBlendFactor:", OZFactoryBase::getFactoryForSerialization((uint64_t)v27));
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v4, "colorAttachments"), "objectAtIndexedSubscript:", v9), "setSourceAlphaBlendFactor:", PCICCTransferFunctionLUT::getLUTEnd((PCICCTransferFunctionLUT *)v27));
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v4, "colorAttachments"), "objectAtIndexedSubscript:", v9), "setSourceRGBBlendFactor:", PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)v27));
    }
    else
    {
      objc_msgSend((id)objc_msgSend((id)objc_msgSend(v4, "colorAttachments"), "objectAtIndexedSubscript:", v9), "setBlendingEnabled:", 0);
    }
    ++v9;
    int v10 = v11;
  }
  while (v9 != 8);
  if (*(unsigned char *)(a2 + 388)) {
    uint64_t v17 = 252;
  }
  else {
    uint64_t v17 = 0;
  }
  [v4 setDepthAttachmentPixelFormat:v17];
  v27[0] = 0;
  unsigned int v18 = (void *)[*v26 newRenderPipelineStateWithDescriptor:v4 error:v27];

  if (v27[0])
  {
    unsigned __int8 v21 = atomic_load(HGLogger::_enabled);
    if (v21) {
      HGLogger::log((HGLogger *)"mtl_utils", (const char *)1, (HGLogger *)"failed to create pipeline state! boo!\n", v19, v20);
    }
    uint64_t v22 = objc_msgSend((id)objc_msgSend(v27[0], "localizedDescription"), "UTF8String");
    HGLogger::warning((HGLogger *)"MTLPipelineState error: %s", v23, v24, v22);
    if (v18)
    {

      unsigned int v18 = 0;
    }
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v28);
  return v18;
}

void sub_1B7798BA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7798BBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7798BD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7798BE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7798BF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7798C0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B7798C20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t HGMetalUtils::metalFormat(int a1)
{
}

uint64_t HGMetalSamplerStateCache::HGMetalSamplerStateCache(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a1 + 16;
  *(void *)(a1 + 24) = 0;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 32), 0);
  return a1;
}

void sub_1B7798C94(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v1, *v2);
  _Unwind_Resume(a1);
}

void *HGMetalSamplerStateCache::getSamplerState(uint64_t a1, uint64_t a2)
{
  BOOL v4 = (pthread_mutex_t *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
  id v5 = *(uint64_t **)(a1 + 16);
  uint64_t v6 = (uint64_t **)(a1 + 8);
  if (!v5) {
    goto LABEL_20;
  }
  unint64_t v8 = *(void *)a2;
  unint64_t v7 = *(void *)(a2 + 8);
  unint64_t v9 = *(void *)(a2 + 16);
  int v10 = (uint64_t *)(a1 + 16);
  unsigned int v11 = *(unsigned __int8 *)(a2 + 24);
  do
  {
    while (1)
    {
      unint64_t v12 = v5[4];
      if (v12 >= v8)
      {
        if (v12 > v8) {
          break;
        }
        unint64_t v13 = v5[5];
        if (v13 >= v7)
        {
          if (v13 > v7) {
            break;
          }
          unint64_t v14 = v5[6];
          if (v14 >= v9 && (v14 > v9 || *((unsigned __int8 *)v5 + 56) >= v11)) {
            break;
          }
        }
      }
      id v5 = (uint64_t *)v5[1];
      if (!v5) {
        goto LABEL_12;
      }
    }
    int v10 = v5;
    id v5 = (uint64_t *)*v5;
  }
  while (v5);
LABEL_12:
  if (v10 == (uint64_t *)(a1 + 16)
    || (unint64_t v15 = v10[4], v8 < v15)
    || v8 <= v15
    && ((unint64_t v16 = v10[5], v7 < v16)
     || v7 <= v16 && ((unint64_t v17 = v10[6], v9 < v17) || v9 <= v17 && v11 < *((unsigned __int8 *)v10 + 56))))
  {
LABEL_20:
    uint64_t SamplerState = HGMetalSamplerStateCache::_createSamplerState((id *)a1, a2);
    uint64_t v22 = (_OWORD *)a2;
    std::__tree<std::__value_type<HGMetalSamplerStateCache::Info,HGMTLSamplerStateType>,std::__map_value_compare<HGMetalSamplerStateCache::Info,std::__value_type<HGMetalSamplerStateCache::Info,HGMTLSamplerStateType>,std::less<HGMetalSamplerStateCache::Info>,true>,std::allocator<std::__value_type<HGMetalSamplerStateCache::Info,HGMTLSamplerStateType>>>::__emplace_unique_key_args<HGMetalSamplerStateCache::Info,std::piecewise_construct_t const&,std::tuple<HGMetalSamplerStateCache::Info const&>,std::tuple<>>(v6, (unint64_t *)a2, (uint64_t)&std::piecewise_construct, &v22)[8] = SamplerState;
  }
  uint64_t v22 = (_OWORD *)a2;
  BOOL v19 = (void *)std::__tree<std::__value_type<HGMetalSamplerStateCache::Info,HGMTLSamplerStateType>,std::__map_value_compare<HGMetalSamplerStateCache::Info,std::__value_type<HGMetalSamplerStateCache::Info,HGMTLSamplerStateType>,std::less<HGMetalSamplerStateCache::Info>,true>,std::allocator<std::__value_type<HGMetalSamplerStateCache::Info,HGMTLSamplerStateType>>>::__emplace_unique_key_args<HGMetalSamplerStateCache::Info,std::piecewise_construct_t const&,std::tuple<HGMetalSamplerStateCache::Info const&>,std::tuple<>>(v6, (unint64_t *)a2, (uint64_t)&std::piecewise_construct, &v22)[8];
  pthread_mutex_unlock(v4);
  id v20 = v19;
  return v19;
}

uint64_t HGMetalSamplerStateCache::_createSamplerState(id *a1, uint64_t a2)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v7, "metal", 2, "HGMetalSamplerStateCache::_createSamplerState()");
  BOOL v4 = objc_opt_new();
  [v4 setMinFilter:*(void *)a2];
  [v4 setMagFilter:*(void *)(a2 + 8)];
  [v4 setRAddressMode:*(void *)(a2 + 16)];
  [v4 setSAddressMode:*(void *)(a2 + 16)];
  [v4 setTAddressMode:*(void *)(a2 + 16)];
  [v4 setNormalizedCoordinates:*(unsigned __int8 *)(a2 + 24)];
  uint64_t v5 = [*a1 newSamplerStateWithDescriptor:v4];

  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v7);
  return v5;
}

void sub_1B7798ED4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B7798EE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HGMetalDepthStencilStateCache::HGMetalDepthStencilStateCache(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a1 + 16;
  *(void *)(a1 + 24) = 0;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 32), 0);
  return a1;
}

void sub_1B7798F4C(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v1, *v2);
  _Unwind_Resume(a1);
}

uint64_t *HGMetalDepthStencilStateCache::getDepthStencilState(uint64_t a1, unsigned __int8 *a2)
{
  BOOL v4 = (pthread_mutex_t *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
  uint64_t v6 = (uint64_t **)(a1 + 16);
  uint64_t v5 = *(uint64_t **)(a1 + 16);
  if (!v5) {
    goto LABEL_15;
  }
  unsigned int v7 = *a2;
  unint64_t v8 = *((void *)a2 + 1);
  unint64_t v9 = (uint64_t **)(a1 + 16);
  int v10 = *(uint64_t ***)(a1 + 16);
  do
  {
    unsigned int v11 = *((unsigned __int8 *)v10 + 32);
    if (v11 < v7)
    {
      ++v10;
    }
    else if (v11 <= v7)
    {
      if ((unint64_t)v10[5] < v8) {
        ++v10;
      }
      else {
        unint64_t v9 = v10;
      }
    }
    else
    {
      unint64_t v9 = v10;
    }
    int v10 = (uint64_t **)*v10;
  }
  while (v10);
  if (v9 == v6 || (unsigned int v12 = *((unsigned __int8 *)v9 + 32), v7 < v12) || v7 <= v12 && v8 < (unint64_t)v9[5])
  {
LABEL_15:
    uint64_t DepthStencilState = HGMetalDepthStencilStateCache::_createDepthStencilState((id *)a1, a2);
    unint64_t v14 = *(unsigned __int8 **)(a1 + 16);
    unint64_t v15 = (uint64_t **)(a1 + 16);
    unint64_t v16 = (void *)(a1 + 16);
    if (v14)
    {
      unsigned int v17 = *a2;
      unint64_t v18 = *((void *)a2 + 1);
      while (1)
      {
        unint64_t v16 = v14;
        unsigned int v19 = v14[32];
        if (v17 < v19) {
          goto LABEL_17;
        }
        if (v17 > v19)
        {
LABEL_22:
          unint64_t v14 = (unsigned __int8 *)v16[1];
          if (!v14)
          {
            unint64_t v15 = (uint64_t **)(v16 + 1);
            break;
          }
        }
        else
        {
          unint64_t v20 = v16[5];
          if (v18 >= v20)
          {
            if (v20 >= v18) {
              goto LABEL_27;
            }
            goto LABEL_22;
          }
LABEL_17:
          unint64_t v14 = (unsigned __int8 *)*v16;
          unint64_t v15 = (uint64_t **)v16;
          if (!*v16) {
            break;
          }
        }
      }
    }
    unsigned __int8 v21 = v16;
    unint64_t v16 = operator new(0x38uLL);
    *((_OWORD *)v16 + 2) = *(_OWORD *)a2;
    v16[6] = 0;
    void *v16 = 0;
    v16[1] = 0;
    v16[2] = v21;
    *unint64_t v15 = v16;
    uint64_t v22 = **(void **)(a1 + 8);
    float32x4_t v23 = v16;
    if (v22)
    {
      *(void *)(a1 + 8) = v22;
      float32x4_t v23 = *v15;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 16), v23);
    ++*(void *)(a1 + 24);
LABEL_27:
    v16[6] = DepthStencilState;
    uint64_t v5 = *v6;
  }
  int32x2_t v24 = (uint64_t **)(a1 + 16);
  if (v5)
  {
    unsigned int v25 = *a2;
    unint64_t v26 = *((void *)a2 + 1);
    while (1)
    {
      int32x2_t v24 = (uint64_t **)v5;
      unsigned int v27 = *((unsigned __int8 *)v5 + 32);
      if (v25 < v27) {
        goto LABEL_30;
      }
      if (v25 > v27)
      {
LABEL_35:
        uint64_t v5 = v24[1];
        if (!v5)
        {
          uint64_t v6 = v24 + 1;
          break;
        }
      }
      else
      {
        float32x2_t v28 = v24[5];
        if (v26 >= (unint64_t)v28)
        {
          if ((unint64_t)v28 >= v26) {
            goto LABEL_40;
          }
          goto LABEL_35;
        }
LABEL_30:
        uint64_t v5 = *v24;
        uint64_t v6 = v24;
        if (!*v24) {
          break;
        }
      }
    }
  }
  BOOL v29 = (uint64_t *)v24;
  int32x2_t v24 = (uint64_t **)operator new(0x38uLL);
  *((_OWORD *)v24 + 2) = *(_OWORD *)a2;
  v24[6] = 0;
  *int32x2_t v24 = 0;
  v24[1] = 0;
  v24[2] = v29;
  *uint64_t v6 = (uint64_t *)v24;
  uint64_t v30 = **(void **)(a1 + 8);
  unint64_t v31 = (uint64_t *)v24;
  if (v30)
  {
    *(void *)(a1 + 8) = v30;
    unint64_t v31 = *v6;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 16), v31);
  ++*(void *)(a1 + 24);
LABEL_40:
  int32x2_t v32 = v24[6];
  pthread_mutex_unlock(v4);
  unsigned int v33 = v32;
  return v32;
}

uint64_t HGMetalDepthStencilStateCache::_createDepthStencilState(id *a1, unsigned __int8 *a2)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v7, "metal", 2, "HGMetalDepthStencilStateCache::_createDepthStencilState()");
  BOOL v4 = objc_opt_new();
  [v4 setDepthWriteEnabled:*a2];
  [v4 setDepthCompareFunction:*((void *)a2 + 1)];
  uint64_t v5 = [*a1 newDepthStencilStateWithDescriptor:v4];

  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v7);
  return v5;
}

void sub_1B779924C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B7799260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HGMetalUtils::hgFormat(HGMetalUtils *this)
{
  uint64_t v1 = (char *)this - 10;
  uint64_t result = 0;
  switch((unint64_t)v1)
  {
    case 0uLL:
      uint64_t result = 1;
      break;
    case 1uLL:
    case 2uLL:
    case 3uLL:
    case 4uLL:
    case 5uLL:
    case 6uLL:
    case 7uLL:
    case 8uLL:
    case 9uLL:
    case 0xBuLL:
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0x10uLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x13uLL:
    case 0x15uLL:
    case 0x16uLL:
    case 0x17uLL:
    case 0x18uLL:
    case 0x19uLL:
    case 0x1AuLL:
    case 0x1BuLL:
    case 0x1CuLL:
    case 0x1DuLL:
    case 0x1EuLL:
    case 0x1FuLL:
    case 0x20uLL:
    case 0x21uLL:
    case 0x22uLL:
    case 0x23uLL:
    case 0x24uLL:
    case 0x25uLL:
    case 0x26uLL:
    case 0x27uLL:
    case 0x28uLL:
    case 0x29uLL:
    case 0x2AuLL:
    case 0x2BuLL:
    case 0x2CuLL:
    case 0x2EuLL:
    case 0x2FuLL:
    case 0x30uLL:
    case 0x31uLL:
    case 0x33uLL:
    case 0x34uLL:
    case 0x35uLL:
    case 0x36uLL:
    case 0x38uLL:
    case 0x39uLL:
    case 0x3AuLL:
    case 0x3BuLL:
    case 0x3DuLL:
    case 0x3EuLL:
    case 0x3FuLL:
    case 0x40uLL:
    case 0x41uLL:
    case 0x42uLL:
    case 0x43uLL:
    case 0x44uLL:
    case 0x45uLL:
    case 0x47uLL:
    case 0x48uLL:
    case 0x49uLL:
    case 0x4AuLL:
    case 0x4BuLL:
    case 0x4CuLL:
    case 0x4DuLL:
    case 0x4EuLL:
    case 0x4FuLL:
    case 0x50uLL:
    case 0x51uLL:
    case 0x52uLL:
    case 0x53uLL:
    case 0x54uLL:
    case 0x55uLL:
    case 0x56uLL:
    case 0x57uLL:
    case 0x58uLL:
    case 0x59uLL:
    case 0x5AuLL:
    case 0x5BuLL:
    case 0x5CuLL:
    case 0x5DuLL:
    case 0x5EuLL:
    case 0x60uLL:
    case 0x61uLL:
    case 0x62uLL:
    case 0x63uLL:
    case 0x65uLL:
    case 0x66uLL:
    case 0x67uLL:
    case 0x68uLL:
    case 0x6AuLL:
    case 0x6BuLL:
    case 0x6CuLL:
    case 0x6DuLL:
    case 0x6EuLL:
    case 0x6FuLL:
    case 0x70uLL:
    case 0x71uLL:
    case 0x72uLL:
      return result;
    case 0xAuLL:
      uint64_t result = 3;
      break;
    case 0xFuLL:
      uint64_t result = 5;
      break;
    case 0x14uLL:
      uint64_t result = 10;
      break;
    case 0x2DuLL:
      uint64_t result = 7;
      break;
    case 0x32uLL:
      uint64_t result = 11;
      break;
    case 0x37uLL:
      uint64_t result = 12;
      break;
    case 0x3CuLL:
      uint64_t result = 24;
      break;
    case 0x46uLL:
      uint64_t result = 23;
      break;
    case 0x5FuLL:
      uint64_t result = 13;
      break;
    case 0x64uLL:
      uint64_t result = 25;
      break;
    case 0x69uLL:
      uint64_t result = 27;
      break;
    case 0x73uLL:
      uint64_t result = 28;
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t HGMetalUtils::bytesPerPixel(HGMetalUtils *this)
{
  uint64_t result = 0;
  switch((unint64_t)this)
  {
    case 1uLL:
    case 0xAuLL:
      uint64_t result = 1;
      break;
    case 2uLL:
    case 3uLL:
    case 4uLL:
    case 5uLL:
    case 6uLL:
    case 7uLL:
    case 8uLL:
    case 9uLL:
    case 0xBuLL:
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0xFuLL:
    case 0x10uLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x13uLL:
    case 0x15uLL:
    case 0x16uLL:
    case 0x17uLL:
    case 0x18uLL:
    case 0x1AuLL:
    case 0x1BuLL:
    case 0x1CuLL:
    case 0x1DuLL:
    case 0x1FuLL:
    case 0x20uLL:
    case 0x21uLL:
    case 0x22uLL:
    case 0x23uLL:
    case 0x24uLL:
    case 0x25uLL:
    case 0x26uLL:
    case 0x27uLL:
    case 0x28uLL:
    case 0x29uLL:
    case 0x2AuLL:
    case 0x2BuLL:
    case 0x2CuLL:
    case 0x2DuLL:
    case 0x2EuLL:
    case 0x2FuLL:
    case 0x30uLL:
    case 0x31uLL:
    case 0x32uLL:
    case 0x33uLL:
    case 0x34uLL:
    case 0x35uLL:
    case 0x36uLL:
    case 0x38uLL:
    case 0x39uLL:
    case 0x3AuLL:
    case 0x3BuLL:
    case 0x3DuLL:
    case 0x3EuLL:
    case 0x3FuLL:
    case 0x40uLL:
    case 0x42uLL:
    case 0x43uLL:
    case 0x44uLL:
    case 0x45uLL:
    case 0x47uLL:
    case 0x48uLL:
    case 0x49uLL:
    case 0x4AuLL:
    case 0x4BuLL:
    case 0x4CuLL:
    case 0x4DuLL:
    case 0x4EuLL:
    case 0x4FuLL:
    case 0x51uLL:
    case 0x52uLL:
    case 0x53uLL:
    case 0x54uLL:
    case 0x55uLL:
    case 0x56uLL:
    case 0x57uLL:
    case 0x58uLL:
    case 0x59uLL:
    case 0x5BuLL:
    case 0x5CuLL:
    case 0x5DuLL:
    case 0x5EuLL:
    case 0x5FuLL:
    case 0x60uLL:
    case 0x61uLL:
    case 0x62uLL:
    case 0x63uLL:
    case 0x64uLL:
    case 0x65uLL:
    case 0x66uLL:
    case 0x67uLL:
    case 0x68uLL:
    case 0x6AuLL:
    case 0x6BuLL:
    case 0x6CuLL:
    case 0x6DuLL:
    case 0x6FuLL:
    case 0x70uLL:
    case 0x71uLL:
    case 0x72uLL:
    case 0x74uLL:
    case 0x75uLL:
    case 0x76uLL:
    case 0x77uLL:
    case 0x78uLL:
    case 0x79uLL:
    case 0x7AuLL:
    case 0x7BuLL:
    case 0x7CuLL:
      return result;
    case 0x14uLL:
    case 0x19uLL:
    case 0x1EuLL:
      uint64_t result = 2;
      break;
    case 0x37uLL:
    case 0x3CuLL:
    case 0x41uLL:
    case 0x46uLL:
    case 0x50uLL:
    case 0x5AuLL:
      goto LABEL_2;
    case 0x69uLL:
    case 0x6EuLL:
    case 0x73uLL:
      uint64_t result = 8;
      break;
    case 0x7DuLL:
      uint64_t result = 16;
      break;
    default:
      if (this == (HGMetalUtils *)252) {
LABEL_2:
      }
        uint64_t result = 4;
      break;
  }
  return result;
}

const char *HGMetalUtils::toString(HGMetalUtils *this)
{
  uint64_t v1 = (char *)this - 1;
  uint64_t result = "A8";
  switch((unint64_t)v1)
  {
    case 0uLL:
      return result;
    case 1uLL:
    case 2uLL:
    case 3uLL:
    case 4uLL:
    case 5uLL:
    case 6uLL:
    case 7uLL:
    case 8uLL:
    case 0xAuLL:
    case 0xBuLL:
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0xFuLL:
    case 0x10uLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x14uLL:
    case 0x15uLL:
    case 0x16uLL:
    case 0x17uLL:
    case 0x19uLL:
    case 0x1AuLL:
    case 0x1BuLL:
    case 0x1CuLL:
    case 0x1EuLL:
    case 0x1FuLL:
    case 0x20uLL:
    case 0x21uLL:
    case 0x22uLL:
    case 0x23uLL:
    case 0x24uLL:
    case 0x25uLL:
    case 0x26uLL:
    case 0x27uLL:
    case 0x28uLL:
    case 0x29uLL:
    case 0x2AuLL:
    case 0x2BuLL:
    case 0x2CuLL:
    case 0x2DuLL:
    case 0x2EuLL:
    case 0x2FuLL:
    case 0x30uLL:
    case 0x31uLL:
    case 0x32uLL:
    case 0x33uLL:
    case 0x34uLL:
    case 0x35uLL:
    case 0x37uLL:
    case 0x38uLL:
    case 0x39uLL:
    case 0x3AuLL:
    case 0x3CuLL:
    case 0x3DuLL:
    case 0x3EuLL:
    case 0x3FuLL:
    case 0x41uLL:
    case 0x42uLL:
    case 0x43uLL:
    case 0x44uLL:
    case 0x46uLL:
    case 0x47uLL:
    case 0x48uLL:
    case 0x49uLL:
    case 0x4AuLL:
    case 0x4BuLL:
    case 0x4CuLL:
    case 0x4DuLL:
    case 0x4EuLL:
    case 0x50uLL:
    case 0x51uLL:
    case 0x52uLL:
    case 0x53uLL:
    case 0x54uLL:
    case 0x55uLL:
    case 0x56uLL:
    case 0x57uLL:
    case 0x58uLL:
    case 0x59uLL:
    case 0x5AuLL:
    case 0x5BuLL:
    case 0x5CuLL:
    case 0x5DuLL:
    case 0x5EuLL:
    case 0x5FuLL:
    case 0x60uLL:
    case 0x61uLL:
    case 0x62uLL:
    case 0x63uLL:
    case 0x64uLL:
    case 0x65uLL:
    case 0x66uLL:
    case 0x67uLL:
    case 0x69uLL:
    case 0x6AuLL:
    case 0x6BuLL:
    case 0x6CuLL:
    case 0x6EuLL:
    case 0x6FuLL:
    case 0x70uLL:
    case 0x71uLL:
    case 0x73uLL:
    case 0x74uLL:
    case 0x75uLL:
    case 0x76uLL:
    case 0x77uLL:
    case 0x78uLL:
    case 0x79uLL:
    case 0x7AuLL:
    case 0x7BuLL:
      goto LABEL_5;
    case 9uLL:
      uint64_t result = "R8";
      break;
    case 0x13uLL:
      uint64_t result = "R16";
      break;
    case 0x18uLL:
      uint64_t result = "R16F";
      break;
    case 0x1DuLL:
      uint64_t result = "RG8";
      break;
    case 0x36uLL:
      uint64_t result = "R32F";
      break;
    case 0x3BuLL:
      uint64_t result = "RG16";
      break;
    case 0x40uLL:
      uint64_t result = "RG16F";
      break;
    case 0x45uLL:
      uint64_t result = "RGBA8";
      break;
    case 0x4FuLL:
      uint64_t result = "BGRA8";
      break;
    case 0x68uLL:
      uint64_t result = "RG32F";
      break;
    case 0x6DuLL:
      uint64_t result = "RGBA16";
      break;
    case 0x72uLL:
      uint64_t result = "RGBA16F";
      break;
    case 0x7CuLL:
      uint64_t result = "RGBA32F";
      break;
    default:
      if ("A8" == (char *)252) {
        uint64_t result = "D32F";
      }
      else {
LABEL_5:
      }
        uint64_t result = "(fmt)";
      break;
  }
  return result;
}

void *HGMetalCommandBufferRef::HGMetalCommandBufferRef(void *a1, void *a2)
{
  *a1 = a2;
  id v3 = a2;
  return a1;
}

void HGMetalCommandBufferRef::~HGMetalCommandBufferRef(id *this)
{
  *this = 0;
}

void HGMetalCommandBufferRef::waitUntilScheduled(id *this)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v2, "gpu", 1, "HGMetalCommandBufferRef::waitUntilScheduled");
  kdebug_trace();
  [*this waitUntilScheduled];
  kdebug_trace();
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v2);
}

void sub_1B7799B24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11, __int16 a12, char a13)
{
}

void sub_1B7799B40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void HGMetalCommandBufferRef::waitUntilCompleted(id *this)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v2, "gpu", 1, "HGMetalCommandBufferRef::waitUntilCompleted");
  kdebug_trace();
  [*this waitUntilCompleted];
  kdebug_trace();
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v2);
}

void sub_1B7799BEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11, __int16 a12, char a13)
{
}

void sub_1B7799C08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

char *HGMetalUtils::stringForMetalHeader@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x58uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1B8345C40;
  strcpy(result, "#include <metal_stdlib>    \n                           \nusing namespace metal;     \n\n");
  return result;
}

std::string *HGMetalUtils::stringForMetalVertexOutputStruct@<X0>(HGMetalUtils *this@<X0>, char a2@<W1>, uint64_t a3@<X8>)
{
  int v4 = (int)this;
  *(unsigned char *)(a3 + 23) = 0;
  *(unsigned char *)a3 = 0;
  std::string::append((std::string *)a3, "struct VertexInOut {\n");
  std::string::append((std::string *)a3, "    float4 _position  [[ position ]];\n");
  if (v4)
  {
    for (unint64_t i = 0; v4 != i; ++i)
    {
      std::to_string(&v23, i);
      std::operator+<char>();
      unsigned int v7 = std::string::append(&v18, " [[ user(texcoord");
      long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
      v19.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v19.__r_.__value_.__l.__data_ = v8;
      v7->__r_.__value_.__l.__size_ = 0;
      v7->__r_.__value_.__r.__words[2] = 0;
      v7->__r_.__value_.__r.__words[0] = 0;
      if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        unint64_t v9 = &v23;
      }
      else {
        unint64_t v9 = (std::string *)v23.__r_.__value_.__r.__words[0];
      }
      if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v23.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v23.__r_.__value_.__l.__size_;
      }
      unsigned int v11 = std::string::append(&v19, (const std::string::value_type *)v9, size);
      long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
      v20.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v20.__r_.__value_.__l.__data_ = v12;
      v11->__r_.__value_.__l.__size_ = 0;
      v11->__r_.__value_.__r.__words[2] = 0;
      v11->__r_.__value_.__r.__words[0] = 0;
      unint64_t v13 = std::string::append(&v20, ") ]]; \n");
      long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
      int64_t v22 = v13->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = v14;
      v13->__r_.__value_.__l.__size_ = 0;
      v13->__r_.__value_.__r.__words[2] = 0;
      v13->__r_.__value_.__r.__words[0] = 0;
      if (v22 >= 0) {
        unint64_t v15 = __p;
      }
      else {
        unint64_t v15 = (void **)__p[0];
      }
      if (v22 >= 0) {
        std::string::size_type v16 = HIBYTE(v22);
      }
      else {
        std::string::size_type v16 = (std::string::size_type)__p[1];
      }
      std::string::append((std::string *)a3, (const std::string::value_type *)v15, v16);
      if (SHIBYTE(v22) < 0)
      {
        operator delete(__p[0]);
        if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_18:
          if ((SHIBYTE(v19.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_19;
          }
          goto LABEL_24;
        }
      }
      else if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        goto LABEL_18;
      }
      operator delete(v20.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v19.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_19:
        if ((SHIBYTE(v18.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_20;
        }
        goto LABEL_25;
      }
LABEL_24:
      operator delete(v19.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v18.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_20:
        if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_26;
        }
        continue;
      }
LABEL_25:
      operator delete(v18.__r_.__value_.__l.__data_);
      if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
LABEL_26:
      }
        operator delete(v23.__r_.__value_.__l.__data_);
    }
  }
  if (a2) {
    std::string::append((std::string *)a3, "    float4 _color     [[ user(primary) ]];\n");
  }
  return std::string::append((std::string *)a3, "};\n\n");
}

void sub_1B7799E8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (*(char *)(v35 + 23) < 0)
  {
    operator delete(*(void **)v35);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

std::string *HGMetalUtils::stringForMetalVertexShader@<X0>(HGMetalUtils *this@<X0>, const char *a2@<X1>, char a3@<W2>, uint64_t a4@<X8>)
{
  int v4 = (int)a2;
  *(unsigned char *)(a4 + 23) = 0;
  *(unsigned char *)a4 = 0;
  std::string::append((std::string *)a4, "[[ vertex ]]\n");
  std::string::append((std::string *)a4, "VertexInOut ");
  size_t v7 = strlen((const char *)this);
  if (v7 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::string::size_type v8 = v7;
  if (v7 >= 0x17)
  {
    uint64_t v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v10 = v7 | 7;
    }
    uint64_t v11 = v10 + 1;
    p_dst = (std::string *)operator new(v10 + 1);
    __dst.__r_.__value_.__l.__size_ = v8;
    __dst.__r_.__value_.__r.__words[2] = v11 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_8;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v7;
  p_dst = &__dst;
  if (v7) {
LABEL_8:
  }
    memcpy(p_dst, this, v8);
  p_dst->__r_.__value_.__s.__data_[v8] = 0;
  long long v12 = std::string::append(&__dst, "(constant float4x4 *matrices [[ buffer(0) ]], \n");
  long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v56.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    long long v14 = &v56;
  }
  else {
    long long v14 = (std::string *)v56.__r_.__value_.__r.__words[0];
  }
  if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v56.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v56.__r_.__value_.__l.__size_;
  }
  std::string::append((std::string *)a4, (const std::string::value_type *)v14, size);
  if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v56.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_17;
    }
  }
  else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_17;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_17:
  std::string::append((std::string *)a4, "    const device float4 *positions [[ buffer(1) ]], \n");
  std::string::append((std::string *)a4, "    const device float4 *colors [[ buffer(2) ]], \n");
  uint64_t v16 = v4;
  if (v4)
  {
    unint64_t v17 = 0;
    while (1)
    {
      std::to_string(&v52, v17);
      std::string v18 = std::string::insert(&v52, 0, "    const device float4 *texCoords");
      long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v19;
      v18->__r_.__value_.__l.__size_ = 0;
      v18->__r_.__value_.__r.__words[2] = 0;
      v18->__r_.__value_.__r.__words[0] = 0;
      std::string v20 = std::string::append(&__p, " [[ buffer(");
      long long v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
      v54.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v21;
      v20->__r_.__value_.__l.__size_ = 0;
      v20->__r_.__value_.__r.__words[2] = 0;
      v20->__r_.__value_.__r.__words[0] = 0;
      unint64_t v22 = v17 + 3;
      std::to_string(&v51, v22);
      if ((v51.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string v23 = &v51;
      }
      else {
        std::string v23 = (std::string *)v51.__r_.__value_.__r.__words[0];
      }
      if ((v51.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v24 = HIBYTE(v51.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v24 = v51.__r_.__value_.__l.__size_;
      }
      unsigned int v25 = std::string::append(&v54, (const std::string::value_type *)v23, v24);
      long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
      __dst.__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v26;
      v25->__r_.__value_.__l.__size_ = 0;
      v25->__r_.__value_.__r.__words[2] = 0;
      v25->__r_.__value_.__r.__words[0] = 0;
      unsigned int v27 = std::string::append(&__dst, ") ]], \n");
      long long v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
      v56.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v28;
      v27->__r_.__value_.__l.__size_ = 0;
      v27->__r_.__value_.__r.__words[2] = 0;
      v27->__r_.__value_.__r.__words[0] = 0;
      if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        BOOL v29 = &v56;
      }
      else {
        BOOL v29 = (std::string *)v56.__r_.__value_.__r.__words[0];
      }
      if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v30 = HIBYTE(v56.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v30 = v56.__r_.__value_.__l.__size_;
      }
      std::string::append((std::string *)a4, (const std::string::value_type *)v29, v30);
      if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v56.__r_.__value_.__l.__data_);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_40;
        }
LABEL_35:
        if ((SHIBYTE(v51.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_36;
        }
LABEL_41:
        operator delete(v51.__r_.__value_.__l.__data_);
        if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_42;
        }
LABEL_37:
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_43;
        }
LABEL_19:
        operator delete(__p.__r_.__value_.__l.__data_);
        if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_44;
        }
LABEL_20:
        unint64_t v17 = v22 - 2;
        if (v17 == v4) {
          break;
        }
      }
      else
      {
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_35;
        }
LABEL_40:
        operator delete(__dst.__r_.__value_.__l.__data_);
        if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_41;
        }
LABEL_36:
        if ((SHIBYTE(v54.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_37;
        }
LABEL_42:
        operator delete(v54.__r_.__value_.__l.__data_);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_19;
        }
LABEL_43:
        if ((SHIBYTE(v52.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_20;
        }
LABEL_44:
        operator delete(v52.__r_.__value_.__l.__data_);
        unint64_t v17 = v22 - 2;
        if (v17 == v4) {
          break;
        }
      }
    }
  }
  std::string::append((std::string *)a4, "    uint vid [[ vertex_id ]])\n{\n");
  std::string::append((std::string *)a4, "    constant float4x4 *projectionMatrix = matrices;\n");
  if (v4) {
    std::string::append((std::string *)a4, "    constant float4x4 *textureMatrices = matrices+1;\n");
  }
  std::string::append((std::string *)a4, "    VertexInOut vertices;\n");
  std::string::append((std::string *)a4, "    vertices._position  = *projectionMatrix * positions[vid];\n");
  if (v4)
  {
    unint64_t v31 = 0;
    while (1)
    {
      std::to_string(&v56, v31);
      std::operator+<char>();
      int32x2_t v32 = std::string::append(&v50, " = textureMatrices[");
      long long v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
      v51.__r_.__value_.__r.__words[2] = v32->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v33;
      v32->__r_.__value_.__l.__size_ = 0;
      v32->__r_.__value_.__r.__words[2] = 0;
      v32->__r_.__value_.__r.__words[0] = 0;
      if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        unsigned int v34 = &v56;
      }
      else {
        unsigned int v34 = (std::string *)v56.__r_.__value_.__r.__words[0];
      }
      if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v35 = HIBYTE(v56.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v35 = v56.__r_.__value_.__l.__size_;
      }
      unsigned int v36 = std::string::append(&v51, (const std::string::value_type *)v34, v35);
      long long v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
      v52.__r_.__value_.__r.__words[2] = v36->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v37;
      v36->__r_.__value_.__l.__size_ = 0;
      v36->__r_.__value_.__r.__words[2] = 0;
      v36->__r_.__value_.__r.__words[0] = 0;
      uint64_t v38 = std::string::append(&v52, "] * texCoords");
      long long v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v39;
      v38->__r_.__value_.__l.__size_ = 0;
      v38->__r_.__value_.__r.__words[2] = 0;
      v38->__r_.__value_.__r.__words[0] = 0;
      if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        float32x4_t v40 = &v56;
      }
      else {
        float32x4_t v40 = (std::string *)v56.__r_.__value_.__r.__words[0];
      }
      if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v41 = HIBYTE(v56.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v41 = v56.__r_.__value_.__l.__size_;
      }
      float32x4_t v42 = std::string::append(&__p, (const std::string::value_type *)v40, v41);
      long long v43 = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
      v54.__r_.__value_.__r.__words[2] = v42->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v43;
      v42->__r_.__value_.__l.__size_ = 0;
      v42->__r_.__value_.__r.__words[2] = 0;
      v42->__r_.__value_.__r.__words[0] = 0;
      unint64_t v44 = std::string::append(&v54, "[vid];\n");
      long long v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
      __dst.__r_.__value_.__r.__words[2] = v44->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v45;
      v44->__r_.__value_.__l.__size_ = 0;
      v44->__r_.__value_.__r.__words[2] = 0;
      v44->__r_.__value_.__r.__words[0] = 0;
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int32x4_t v46 = &__dst;
      }
      else {
        int32x4_t v46 = (std::string *)__dst.__r_.__value_.__r.__words[0];
      }
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v47 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v47 = __dst.__r_.__value_.__l.__size_;
      }
      std::string::append((std::string *)a4, (const std::string::value_type *)v46, v47);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__dst.__r_.__value_.__l.__data_);
        if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_77;
        }
LABEL_71:
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_72;
        }
LABEL_78:
        operator delete(__p.__r_.__value_.__l.__data_);
        if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_79;
        }
LABEL_73:
        if ((SHIBYTE(v51.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_74;
        }
LABEL_80:
        operator delete(v51.__r_.__value_.__l.__data_);
        if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_49;
        }
LABEL_81:
        if ((SHIBYTE(v56.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_50;
        }
LABEL_82:
        operator delete(v56.__r_.__value_.__l.__data_);
        if (v16 == ++v31) {
          break;
        }
      }
      else
      {
        if ((SHIBYTE(v54.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_71;
        }
LABEL_77:
        operator delete(v54.__r_.__value_.__l.__data_);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_78;
        }
LABEL_72:
        if ((SHIBYTE(v52.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_73;
        }
LABEL_79:
        operator delete(v52.__r_.__value_.__l.__data_);
        if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_80;
        }
LABEL_74:
        if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_81;
        }
LABEL_49:
        operator delete(v50.__r_.__value_.__l.__data_);
        if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_82;
        }
LABEL_50:
        if (v16 == ++v31) {
          break;
        }
      }
    }
  }
  if (a3) {
    std::string::append((std::string *)a4, "    vertices._color = colors[vid]; \n");
  }
  std::string::append((std::string *)a4, "    return vertices;\n");
  return std::string::append((std::string *)a4, "}\n\n");
}

void sub_1B779A560(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,void *__p,uint64_t a45,int a46,__int16 a47,char a48,char a49)
{
  if (*(char *)(v50 - 105) < 0) {
    operator delete(*(void **)(v50 - 128));
  }
  if (a49 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v49 + 23) < 0) {
    operator delete(*(void **)v49);
  }
  _Unwind_Resume(exception_object);
}

std::string *HGMetalUtils::stringForMetalFragmentOutputStruct@<X0>(HGMetalUtils *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned int v4 = this;
  *(unsigned char *)(a3 + 23) = 0;
  *(unsigned char *)a3 = 0;
  std::string::append((std::string *)a3, "struct FragmentOut {\n");
  if (v4)
  {
    int v6 = 0;
    while (1)
    {
      if ((v4 & 1) == 0) {
        goto LABEL_3;
      }
      std::to_string(&v24, v6);
      std::operator+<char>();
      std::string::size_type v8 = std::string::append(&v19, " [[ color(");
      long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
      v20.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v20.__r_.__value_.__l.__data_ = v9;
      v8->__r_.__value_.__l.__size_ = 0;
      v8->__r_.__value_.__r.__words[2] = 0;
      v8->__r_.__value_.__r.__words[0] = 0;
      if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v10 = &v24;
      }
      else {
        uint64_t v10 = (std::string *)v24.__r_.__value_.__r.__words[0];
      }
      if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v24.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v24.__r_.__value_.__l.__size_;
      }
      long long v12 = std::string::append(&v20, (const std::string::value_type *)v10, size);
      long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
      v21.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v13;
      v12->__r_.__value_.__l.__size_ = 0;
      v12->__r_.__value_.__r.__words[2] = 0;
      v12->__r_.__value_.__r.__words[0] = 0;
      long long v14 = std::string::append(&v21, ") ]];\n");
      long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
      int64_t v23 = v14->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = v15;
      v14->__r_.__value_.__l.__size_ = 0;
      v14->__r_.__value_.__r.__words[2] = 0;
      v14->__r_.__value_.__r.__words[0] = 0;
      if (v23 >= 0) {
        uint64_t v16 = __p;
      }
      else {
        uint64_t v16 = (void **)__p[0];
      }
      if (v23 >= 0) {
        std::string::size_type v17 = HIBYTE(v23);
      }
      else {
        std::string::size_type v17 = (std::string::size_type)__p[1];
      }
      std::string::append((std::string *)a3, (const std::string::value_type *)v16, v17);
      if (SHIBYTE(v23) < 0)
      {
        operator delete(__p[0]);
        if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_20:
          if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_21;
          }
          goto LABEL_26;
        }
      }
      else if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        goto LABEL_20;
      }
      operator delete(v21.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_21:
        if ((SHIBYTE(v19.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_22;
        }
        goto LABEL_27;
      }
LABEL_26:
      operator delete(v20.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v19.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_22:
        if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_28;
        }
        goto LABEL_3;
      }
LABEL_27:
      operator delete(v19.__r_.__value_.__l.__data_);
      if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
LABEL_28:
      }
        operator delete(v24.__r_.__value_.__l.__data_);
LABEL_3:
      ++v6;
      BOOL v7 = v4 > 1;
      v4 >>= 1;
      if (!v7) {
        goto LABEL_30;
      }
    }
  }
  std::string::append((std::string *)a3, "    float4 color0 [[ color(0) ]];\n");
LABEL_30:
  if (a2) {
    std::string::append((std::string *)a3, "    float  depth  [[ depth(any) ]];\n");
  }
  return std::string::append((std::string *)a3, "};\n\n");
}

void sub_1B779A9B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (*(char *)(v35 + 23) < 0)
  {
    operator delete(*(void **)v35);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *HGMetalUtils::blitBufferToTexture(void *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  BOOL v7 = 0;
  if (a2 && a3)
  {
    int v36 = 4658;
    kdebug_trace();
    long long v15 = (void *)[a1 commandBuffer];
    [v15 setLabel:@"HG BufferToTexture blit"];
    uint64_t v16 = [v15 blitCommandEncoder];
    BOOL v7 = 0;
    uint64_t v17 = *(void *)(a2 + 144);
    if (v17)
    {
      int v31 = a6;
      uint64_t v18 = a3[18];
      if (v18)
      {
        std::string v19 = (void *)v16;
        uint64_t v20 = HGRectIntersection(*(void *)(a2 + 20), *(void *)(a2 + 28), *(void *)((char *)a3 + 20), *(void *)((char *)a3 + 28));
        v35[0] = HGRectIntersection(v20, v21, a4, a5);
        v35[1] = v22;
        unint64_t v30 = HGBitmap::byteOffset((HGBitmap *)a2, v35[0], SHIDWORD(v35[0]));
        unint64_t v23 = HGFormatUtils::collapseRectForFormat(v35, *(_DWORD *)(a2 + 16));
        uint64_t v25 = v24;
        int TextureRect = HGMetalTexture::GetTextureRect((HGMetalTexture *)a3);
        uint64_t v27 = HGMetalTexture::GetTextureRect((HGMetalTexture *)a3);
        uint64_t v28 = *(void *)(a2 + 64);
        v34[0] = (v25 - v23);
        v34[1] = (HIDWORD(v25) - HIDWORD(v23));
        v34[2] = 1;
        v33[0] = (int)v23 - TextureRect;
        v33[1] = HIDWORD(v23) - HIDWORD(v27);
        v33[2] = 0;
        [v19 copyFromBuffer:v17 sourceOffset:v30 sourceBytesPerRow:v28 sourceBytesPerImage:0 sourceSize:v34 toTexture:v18 destinationSlice:0 destinationLevel:0 destinationOrigin:v33];
        [v19 endEncoding];
        if (a7 && (v31 & 1) == 0)
        {
          (*(void (**)(uint64_t))(*(void *)a2 + 16))(a2);
          v32[0] = MEMORY[0x1E4F143A8];
          v32[1] = *(void *)"";
          v32[2] = ___ZN12HGMetalUtils19blitBufferToTextureE21HGMTLCommandQueueTypeP13HGMetalBufferP14HGMetalTexture6HGRectbb_block_invoke;
          v32[3] = &__block_descriptor_40_e28_v16__0___MTLCommandBuffer__8l;
          void v32[4] = a2;
          [v15 addCompletedHandler:v32];
        }
        [v15 commit];
        if (v31) {
          [v15 waitUntilCompleted];
        }
        else {
          [v15 waitUntilScheduled];
        }
        BOOL v7 = v15;
      }
    }
    kdebug_trace();
  }
  return v7;
}

void sub_1B779AD10(_Unwind_Exception *a1)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B779AD24(_Unwind_Exception *a1)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B779AD38(_Unwind_Exception *a1)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B779AD4C(_Unwind_Exception *a1)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B779AD60(_Unwind_Exception *a1)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B779AD74(_Unwind_Exception *a1)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B779AD8C(_Unwind_Exception *a1)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B779ADA0(_Unwind_Exception *a1)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B779ADB4(_Unwind_Exception *a1)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

uint64_t ___ZN12HGMetalUtils19blitBufferToTextureE21HGMTLCommandQueueTypeP13HGMetalBufferP14HGMetalTexture6HGRectbb_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 24))();
}

void *HGMetalUtils::blitTextureToBuffer(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  BOOL v7 = 0;
  if (a2 && a3)
  {
    int v33 = 4660;
    kdebug_trace();
    long long v15 = (void *)[a1 commandBuffer];
    [v15 setLabel:@"HG TextureToBuffer blit"];
    uint64_t v16 = [v15 blitCommandEncoder];
    BOOL v7 = 0;
    uint64_t v17 = a2[18];
    if (v17)
    {
      int v28 = a6;
      uint64_t v18 = *(void *)(a3 + 144);
      if (v18)
      {
        std::string v19 = (void *)v16;
        uint64_t v20 = HGRectIntersection(*(void *)((char *)a2 + 20), *(void *)((char *)a2 + 28), *(void *)(a3 + 20), *(void *)(a3 + 28));
        v32[0] = HGRectIntersection(v20, v21, a4, a5);
        v32[1] = v22;
        unint64_t v27 = HGBitmap::byteOffset((HGBitmap *)a3, v32[0], SHIDWORD(v32[0]));
        unint64_t v23 = HGFormatUtils::collapseRectForFormat(v32, *(_DWORD *)(a3 + 16));
        uint64_t v25 = v24;
        v31[0] = (int)(v23 - HGMetalTexture::GetTextureRect((HGMetalTexture *)a2));
        v31[1] = (int)(HIDWORD(v23) - ((unint64_t)HGMetalTexture::GetTextureRect((HGMetalTexture *)a2) >> 32));
        v31[2] = 0;
        v30[0] = (v25 - v23);
        v30[1] = (HIDWORD(v25) - HIDWORD(v23));
        v30[2] = 1;
        [v19 copyFromTexture:v17 sourceSlice:0 sourceLevel:0 sourceOrigin:v31 sourceSize:v30 toBuffer:v18 destinationOffset:v27 destinationBytesPerRow:*(void *)(a3 + 64) destinationBytesPerImage:0];
        [v19 endEncoding];
        if (a7 && (v28 & 1) == 0)
        {
          (*(void (**)(void *))(*a2 + 16))(a2);
          v29[0] = MEMORY[0x1E4F143A8];
          v29[1] = *(void *)"";
          v29[2] = ___ZN12HGMetalUtils19blitTextureToBufferE21HGMTLCommandQueueTypeP14HGMetalTextureP13HGMetalBuffer6HGRectbb_block_invoke;
          v29[3] = &__block_descriptor_40_e28_v16__0___MTLCommandBuffer__8l;
          v29[4] = a2;
          [v15 addCompletedHandler:v29];
        }
        [v15 commit];
        if (v28) {
          [v15 waitUntilCompleted];
        }
        else {
          [v15 waitUntilScheduled];
        }
        BOOL v7 = v15;
      }
    }
    kdebug_trace();
  }
  return v7;
}

void sub_1B779B05C(_Unwind_Exception *a1)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B779B070(_Unwind_Exception *a1)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B779B084(_Unwind_Exception *a1)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B779B098(_Unwind_Exception *a1)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B779B0AC(_Unwind_Exception *a1)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B779B0C0(_Unwind_Exception *a1)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B779B0D8(_Unwind_Exception *a1)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B779B0EC(_Unwind_Exception *a1)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

void sub_1B779B100(_Unwind_Exception *a1)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 92));
  _Unwind_Resume(a1);
}

uint64_t ___ZN12HGMetalUtils19blitTextureToBufferE21HGMTLCommandQueueTypeP14HGMetalTextureP13HGMetalBuffer6HGRectbb_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 24))();
}

void *HGMetalUtils::tiledBlitBufferToTexture(void *a1, uint64_t a2, void *a3, unint64_t a4, unint64_t a5, int a6, int a7, unint64_t a8)
{
  int v10 = HIDWORD(a5);
  std::string __p = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  long long v14 = (uint64_t *)__p;
  long long v15 = v22;
  if (__p == v22)
  {
    std::string v19 = 0;
    if (!__p) {
      return v19;
    }
    goto LABEL_7;
  }
  do
  {
    uint64_t v16 = v14[1];
    if (HIDWORD(v16) == v10) {
      int v17 = a6;
    }
    else {
      int v17 = 0;
    }
    uint64_t v18 = HGMetalUtils::blitBufferToTexture(a1, a2, a3, *v14, v16, v17, a7);
    v14 += 2;
  }
  while (v14 != v15);
  std::string v19 = v18;
  long long v14 = (uint64_t *)__p;
  if (__p)
  {
LABEL_7:
    uint64_t v22 = v14;
    operator delete(v14);
  }
  return v19;
}

void sub_1B779B224(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::buildTilesList(uint64_t *a1, unint64_t a2, unint64_t a3, int a4, unint64_t a5)
{
  unint64_t v5 = a3;
  unint64_t v6 = a2;
  int v8 = 0;
  unint64_t v9 = HIDWORD(a2);
  unint64_t v11 = HIDWORD(a3);
  unsigned int v12 = HIDWORD(a3) - HIDWORD(a2);
  switch(v10)
  {
    case 1:
    case 10:
      int v8 = 1;
      break;
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 21:
    case 22:
    case 23:
    case 24:
    case 26:
    case 27:
    case 28:
    case 29:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 56:
    case 57:
    case 58:
    case 59:
    case 61:
    case 62:
    case 63:
    case 64:
    case 66:
    case 67:
    case 68:
    case 69:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 106:
    case 107:
    case 108:
    case 109:
    case 111:
    case 112:
    case 113:
    case 114:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
      break;
    case 20:
    case 25:
    case 30:
      int v8 = 2;
      break;
    case 55:
    case 60:
    case 65:
    case 70:
    case 80:
    case 90:
      goto LABEL_2;
    case 105:
    case 110:
    case 115:
      int v8 = 8;
      break;
    case 125:
      int v8 = 16;
      break;
    default:
      if (v10 == 252) {
LABEL_2:
      }
        int v8 = 4;
      break;
  }
  unint64_t v13 = (((HIDWORD(a3) - HIDWORD(a2)) * (a3 - a2) * v8) >> 20) / a5;
  if (v12 >= (int)v13 + 1) {
    unsigned int v14 = v13 + 1;
  }
  else {
    unsigned int v14 = HIDWORD(a3) - HIDWORD(a2);
  }
  unsigned int v39 = v14;
  if (v14)
  {
    int v15 = 0;
    int v37 = v12 / v14;
    unsigned int v38 = v14 - 1;
    unint64_t v35 = HIDWORD(a3);
    unint64_t v36 = HIDWORD(a2);
    while (1)
    {
      while (1)
      {
        unsigned int v16 = v9 + v15 * v37;
        BOOL v17 = v15++ == v38;
        unsigned int v18 = v17 ? v11 : (int)v9 + v15 * v37;
        uint64_t v19 = HGRectMake4i(v6, v16, v5, v18);
        uint64_t v21 = v19;
        uint64_t v22 = v20;
        uint64_t v24 = (uint64_t *)a1[1];
        unint64_t v23 = a1[2];
        if ((unint64_t)v24 >= v23) {
          break;
        }
        *uint64_t v24 = v19;
        v24[1] = v20;
        a1[1] = (uint64_t)(v24 + 2);
        if (v15 == v39) {
          return;
        }
      }
      unint64_t v9 = v6;
      unint64_t v25 = v5;
      long long v26 = (uint64_t *)*a1;
      uint64_t v27 = ((uint64_t)v24 - *a1) >> 4;
      unint64_t v28 = v27 + 1;
      if ((unint64_t)(v27 + 1) >> 60) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v29 = v23 - (void)v26;
      if (v29 >> 3 > v28) {
        unint64_t v28 = v29 >> 3;
      }
      unint64_t v30 = (unint64_t)v29 >= 0x7FFFFFFFFFFFFFF0 ? 0xFFFFFFFFFFFFFFFLL : v28;
      if (v30) {
        break;
      }
      int v31 = 0;
      int32x2_t v32 = (uint64_t *)(16 * v27);
      *int32x2_t v32 = v21;
      v32[1] = v20;
      uint64_t v33 = 16 * v27;
      unint64_t v5 = v25;
      if (v24 != v26) {
        goto LABEL_30;
      }
LABEL_32:
      unint64_t v6 = v9;
      unsigned int v34 = v32 + 2;
      *a1 = v33;
      a1[1] = (uint64_t)(v32 + 2);
      a1[2] = (uint64_t)&v31[16 * v30];
      LODWORD(v9) = v36;
      if (v24) {
        operator delete(v24);
      }
      LODWORD(v11) = v35;
      a1[1] = (uint64_t)v34;
      if (v15 == v39) {
        return;
      }
    }
    if (v30 >> 60) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    int v31 = (char *)operator new(16 * v30);
    int32x2_t v32 = (uint64_t *)&v31[16 * v27];
    *int32x2_t v32 = v21;
    v32[1] = v22;
    uint64_t v33 = (uint64_t)v32;
    unint64_t v5 = v25;
    if (v24 == v26) {
      goto LABEL_32;
    }
    do
    {
LABEL_30:
      *(_OWORD *)(v33 - 16) = *((_OWORD *)v24 - 1);
      v33 -= 16;
      v24 -= 2;
    }
    while (v24 != v26);
    uint64_t v24 = (uint64_t *)*a1;
    goto LABEL_32;
  }
}

uint64_t **std::__hash_table<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::__unordered_map_hasher<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,HGMetalFunctionCache::InfoHash,std::equal_to<HGMetalFunctionCache::Info>,true>,std::__unordered_map_equal<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::equal_to<HGMetalFunctionCache::Info>,HGMetalFunctionCache::InfoHash,true>,std::allocator<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>>>::find<HGMetalFunctionCache::Info>(void *a1, uint64_t a2)
{
  unint64_t v2 = (void *)a2;
  unint64_t v4 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    unint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(void *)a2;
    unint64_t v5 = v4;
  }
  unint64_t v6 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&v30, (uint64_t *)a2, v5);
  int8x8_t v7 = (int8x8_t)a1[1];
  if (!*(void *)&v7) {
    return 0;
  }
  int v8 = (uint64_t *)v2[3];
  unint64_t v9 = ((unint64_t)&v8[8 * v6 - 0xC3910C8D016B07DLL] + (v6 >> 2) - 3) ^ v6;
  uint8x8_t v10 = (uint8x8_t)vcnt_s8(v7);
  v10.i16[0] = vaddlv_u8(v10);
  if (v10.u32[0] > 1uLL)
  {
    uint64_t v11 = ((unint64_t)&v8[8 * v6 - 0xC3910C8D016B07DLL] + (v6 >> 2) - 3) ^ v6;
    if (v9 >= *(void *)&v7) {
      uint64_t v11 = v9 % *(void *)&v7;
    }
  }
  else
  {
    uint64_t v11 = (*(void *)&v7 - 1) & v9;
  }
  unsigned int v12 = *(uint64_t ****)(*a1 + 8 * v11);
  if (!v12) {
    return 0;
  }
  unint64_t v13 = *v12;
  if (*v12)
  {
    int v14 = *((char *)v2 + 23);
    if (v14 >= 0) {
      unint64_t v15 = *((unsigned __int8 *)v2 + 23);
    }
    else {
      unint64_t v15 = v2[1];
    }
    if (v14 < 0) {
      unint64_t v2 = (void *)*v2;
    }
    if (v10.u32[0] < 2uLL)
    {
      uint64_t v16 = *(void *)&v7 - 1;
      while (1)
      {
        unint64_t v23 = v13[1];
        if (v23 == (uint64_t *)v9)
        {
          if (v13[5] == v8)
          {
            int v24 = *((char *)v13 + 39);
            unint64_t v25 = v24 >= 0 ? *((unsigned __int8 *)v13 + 39) : (unint64_t)v13[3];
            long long v26 = v24 >= 0 ? (uint64_t *)(v13 + 2) : v13[2];
            size_t v27 = v15 >= v25 ? v25 : v15;
            if (!memcmp(v26, v2, v27) && v15 == v25) {
              return v13;
            }
          }
        }
        else if (((unint64_t)v23 & v16) != v11)
        {
          return 0;
        }
        unint64_t v13 = (uint64_t **)*v13;
        if (!v13) {
          return v13;
        }
      }
    }
    do
    {
      unint64_t v17 = (unint64_t)v13[1];
      if (v17 == v9)
      {
        if (v13[5] == v8)
        {
          int v18 = *((char *)v13 + 39);
          unint64_t v19 = v18 >= 0 ? *((unsigned __int8 *)v13 + 39) : (unint64_t)v13[3];
          uint64_t v20 = v18 >= 0 ? (uint64_t *)(v13 + 2) : v13[2];
          size_t v21 = v15 >= v19 ? v19 : v15;
          if (!memcmp(v20, v2, v21) && v15 == v19) {
            return v13;
          }
        }
      }
      else
      {
        if (v17 >= *(void *)&v7) {
          v17 %= *(void *)&v7;
        }
        if (v17 != v11) {
          return 0;
        }
      }
      unint64_t v13 = (uint64_t **)*v13;
    }
    while (v13);
  }
  return v13;
}

uint64_t **std::__hash_table<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::__unordered_map_hasher<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,HGMetalFunctionCache::InfoHash,std::equal_to<HGMetalFunctionCache::Info>,true>,std::__unordered_map_equal<HGMetalFunctionCache::Info,std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>,std::equal_to<HGMetalFunctionCache::Info>,HGMetalFunctionCache::InfoHash,true>,std::allocator<std::__hash_value_type<HGMetalFunctionCache::Info,HGMTLFunctionType>>>::__emplace_unique_key_args<HGMetalFunctionCache::Info,std::piecewise_construct_t const&,std::tuple<HGMetalFunctionCache::Info const&>,std::tuple<>>(uint64_t a1, uint64_t a2, uint64_t a3, long long **a4)
{
  unint64_t v6 = (void *)a2;
  unint64_t v8 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    unint64_t v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(void *)a2;
    unint64_t v9 = v8;
  }
  unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)v50, (uint64_t *)a2, v9);
  uint64_t v11 = (uint64_t *)v6[3];
  unint64_t v12 = ((unint64_t)&v11[8 * v10 - 0xC3910C8D016B07DLL] + (v10 >> 2) - 3) ^ v10;
  unint64_t v13 = *(void *)(a1 + 8);
  if (v13)
  {
    uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
    v14.i16[0] = vaddlv_u8(v14);
    if (v14.u32[0] > 1uLL)
    {
      uint64_t v4 = ((unint64_t)&v11[8 * v10 - 0xC3910C8D016B07DLL] + (v10 >> 2) - 3) ^ v10;
      if (v12 >= v13) {
        uint64_t v4 = v12 % v13;
      }
    }
    else
    {
      uint64_t v4 = (v13 - 1) & v12;
    }
    unint64_t v15 = *(uint64_t ****)(*(void *)a1 + 8 * v4);
    if (v15)
    {
      uint64_t v16 = *v15;
      if (*v15)
      {
        int v17 = *((char *)v6 + 23);
        if (v17 >= 0) {
          unint64_t v18 = *((unsigned __int8 *)v6 + 23);
        }
        else {
          unint64_t v18 = v6[1];
        }
        if (v17 < 0) {
          unint64_t v6 = (void *)*v6;
        }
        if (v14.u32[0] < 2uLL)
        {
          while (1)
          {
            unint64_t v25 = v16[1];
            if (v25 == (uint64_t *)v12)
            {
              if (v16[5] == v11)
              {
                int v26 = *((char *)v16 + 39);
                unint64_t v27 = v26 >= 0 ? *((unsigned __int8 *)v16 + 39) : (unint64_t)v16[3];
                unint64_t v28 = v26 >= 0 ? (uint64_t *)(v16 + 2) : v16[2];
                size_t v29 = v18 >= v27 ? v27 : v18;
                if (!memcmp(v28, v6, v29) && v18 == v27) {
                  return v16;
                }
              }
            }
            else if (((unint64_t)v25 & (v13 - 1)) != v4)
            {
              goto LABEL_59;
            }
            uint64_t v16 = (uint64_t **)*v16;
            if (!v16) {
              goto LABEL_59;
            }
          }
        }
        do
        {
          unint64_t v19 = (unint64_t)v16[1];
          if (v19 == v12)
          {
            if (v16[5] == v11)
            {
              int v20 = *((char *)v16 + 39);
              unint64_t v21 = v20 >= 0 ? *((unsigned __int8 *)v16 + 39) : (unint64_t)v16[3];
              uint64_t v22 = v20 >= 0 ? (uint64_t *)(v16 + 2) : v16[2];
              size_t v23 = v18 >= v21 ? v21 : v18;
              if (!memcmp(v22, v6, v23) && v18 == v21) {
                return v16;
              }
            }
          }
          else
          {
            if (v19 >= v13) {
              v19 %= v13;
            }
            if (v19 != v4) {
              break;
            }
          }
          uint64_t v16 = (uint64_t **)*v16;
        }
        while (v16);
      }
    }
  }
LABEL_59:
  int v31 = operator new(0x38uLL);
  v50[0] = v31;
  v50[1] = a1 + 16;
  char v51 = 0;
  *int v31 = 0;
  v31[1] = v12;
  int32x2_t v32 = (std::string *)(v31 + 2);
  uint64_t v33 = *a4;
  if (*((char *)*a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v32, *(const std::string::value_type **)v33, *((void *)v33 + 1));
  }
  else
  {
    long long v34 = *v33;
    v31[4] = *((void *)v33 + 2);
    *(_OWORD *)&v32->__r_.__value_.__l.__data_ = v34;
  }
  v31[5] = *((void *)v33 + 3);
  v31[6] = 0;
  char v51 = 1;
  float v35 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v36 = *(float *)(a1 + 32);
  if (!v13 || (float)(v36 * (float)v13) < v35)
  {
    BOOL v39 = 1;
    if (v13 >= 3) {
      BOOL v39 = (v13 & (v13 - 1)) != 0;
    }
    unint64_t v40 = v39 | (2 * v13);
    unint64_t v41 = vcvtps_u32_f32(v35 / v36);
    if (v40 <= v41) {
      size_t prime = v41;
    }
    else {
      size_t prime = v40;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    int8x8_t v43 = *(int8x8_t *)(a1 + 8);
    if (prime > *(void *)&v43) {
      goto LABEL_76;
    }
    if (prime < *(void *)&v43)
    {
      unint64_t v44 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (*(void *)&v43 < 3uLL || (uint8x8_t v45 = (uint8x8_t)vcnt_s8(v43), v45.i16[0] = vaddlv_u8(v45), v45.u32[0] > 1uLL))
      {
        unint64_t v44 = std::__next_prime(v44);
      }
      else
      {
        uint64_t v46 = 1 << -(char)__clz(v44 - 1);
        if (v44 >= 2) {
          unint64_t v44 = v46;
        }
      }
      if (prime <= v44) {
        size_t prime = v44;
      }
      if (prime < *(void *)&v43) {
LABEL_76:
      }
        std::__hash_table<std::__hash_value_type<unsigned long,std::string>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::string>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::string>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v13 = *(void *)(a1 + 8);
    unint64_t v47 = v13 - 1;
    if ((v13 & (v13 - 1)) != 0)
    {
      if (v12 >= v13)
      {
        uint64_t v4 = v12 % v13;
        int v37 = *(void **)(*(void *)a1 + 8 * (v12 % v13));
        unsigned int v38 = (void *)v50[0];
        if (v37) {
          goto LABEL_65;
        }
      }
      else
      {
        uint64_t v4 = v12;
        int v37 = *(void **)(*(void *)a1 + 8 * v12);
        unsigned int v38 = (void *)v50[0];
        if (v37) {
          goto LABEL_65;
        }
      }
    }
    else
    {
      uint64_t v4 = v47 & v12;
      int v37 = *(void **)(*(void *)a1 + 8 * (v47 & v12));
      unsigned int v38 = (void *)v50[0];
      if (v37) {
        goto LABEL_65;
      }
    }
LABEL_89:
    *unsigned int v38 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v50[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v50[0])
    {
      unint64_t v48 = *(void *)(*(void *)v50[0] + 8);
      if ((v13 & (v13 - 1)) != 0)
      {
        if (v48 >= v13) {
          v48 %= v13;
        }
      }
      else
      {
        v48 &= v13 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v48) = v50[0];
    }
    goto LABEL_100;
  }
  int v37 = *(void **)(*(void *)a1 + 8 * v4);
  unsigned int v38 = (void *)v50[0];
  if (!v37) {
    goto LABEL_89;
  }
LABEL_65:
  *unsigned int v38 = *v37;
  *int v37 = v50[0];
LABEL_100:
  uint64_t v16 = (uint64_t **)v50[0];
  ++*(void *)(a1 + 24);
  return v16;
}

void sub_1B779BCD0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,BOOL>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,BOOL>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1B779BCE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,BOOL>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,BOOL>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::__map_value_compare<HGMetalRenderPipelineStateCache::Info,std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::less<HGMetalRenderPipelineStateCache::Info>,true>,std::allocator<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::__map_value_compare<HGMetalRenderPipelineStateCache::Info,std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::less<HGMetalRenderPipelineStateCache::Info>,true>,std::allocator<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::__map_value_compare<HGMetalRenderPipelineStateCache::Info,std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::less<HGMetalRenderPipelineStateCache::Info>,true>,std::allocator<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>>>::destroy(a1, a2[1]);
    uint64_t v4 = (void *)a2[55];
    if (v4)
    {
      a2[56] = v4;
      operator delete(v4);
    }
    operator delete(a2);
  }
}

uint64_t *std::__tree<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::__map_value_compare<HGMetalRenderPipelineStateCache::Info,std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::less<HGMetalRenderPipelineStateCache::Info>,true>,std::allocator<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>>>::__emplace_unique_key_args<HGMetalRenderPipelineStateCache::Info,std::piecewise_construct_t const&,std::tuple<HGMetalRenderPipelineStateCache::Info const&>,std::tuple<>>(uint64_t a1, int *a2, uint64_t a3, const void **a4)
{
  int8x8_t v7 = (uint64_t **)(a1 + 8);
  unint64_t v6 = *(uint64_t **)(a1 + 8);
  if (!v6)
  {
    unint64_t v9 = (uint64_t **)(a1 + 8);
LABEL_9:
    std::__tree<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::__map_value_compare<HGMetalRenderPipelineStateCache::Info,std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::less<HGMetalRenderPipelineStateCache::Info>,true>,std::allocator<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<HGMetalRenderPipelineStateCache::Info const&>,std::tuple<>>(a1, a4, (uint64_t)&v14);
    uint64_t v11 = v14;
    *uint8x8_t v14 = 0;
    v11[1] = 0;
    v11[2] = (uint64_t)v9;
    void *v7 = v11;
    uint64_t v12 = **(void **)a1;
    if (v12)
    {
      *(void *)a1 = v12;
      uint64_t v11 = *v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 8), v11);
    ++*(void *)(a1 + 16);
    return v14;
  }
  while (1)
  {
    while (1)
    {
      unint64_t v9 = (uint64_t **)v6;
      unint64_t v10 = (int *)(v6 + 4);
      if (!HGMetalRenderPipelineStateCache::Info::operator<(a2, (int *)v6 + 8)) {
        break;
      }
      unint64_t v6 = *v9;
      int8x8_t v7 = v9;
      if (!*v9) {
        goto LABEL_9;
      }
    }
    if (!HGMetalRenderPipelineStateCache::Info::operator<(v10, a2)) {
      break;
    }
    int8x8_t v7 = v9 + 1;
    unint64_t v6 = v9[1];
    if (!v6) {
      goto LABEL_9;
    }
  }
  uint64_t result = *v7;
  if (!*v7) {
    goto LABEL_9;
  }
  return result;
}

void *std::__tree<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::__map_value_compare<HGMetalRenderPipelineStateCache::Info,std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,std::less<HGMetalRenderPipelineStateCache::Info>,true>,std::allocator<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<HGMetalRenderPipelineStateCache::Info const&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, const void **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  unint64_t v6 = operator new(0x1D8uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  int8x8_t v7 = *a2;
  uint64_t result = memcpy(v6 + 4, *a2, 0x198uLL);
  v6[56] = 0;
  v6[57] = 0;
  v6[55] = 0;
  unint64_t v10 = (unsigned char *)v7[51];
  unint64_t v9 = (unsigned char *)v7[52];
  int64_t v11 = v9 - v10;
  if (v9 != v10)
  {
    if (v11 < 0) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = (char *)operator new(v9 - v10);
    v6[55] = v12;
    v6[56] = v12;
    unint64_t v13 = &v12[8 * (v11 >> 3)];
    v6[57] = v13;
    uint64_t result = memcpy(v12, v10, v11);
    v6[56] = v13;
  }
  v6[58] = 0;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_1B779BF2C(_Unwind_Exception *a1)
{
  uint64_t v5 = *v3;
  if (*v3)
  {
    *(void *)(v2 + 448) = v5;
    operator delete(v5);
  }
  std::unique_ptr<std::__tree_node<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,void *>>>>::~unique_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t std::unique_ptr<std::__tree_node<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<HGMetalRenderPipelineStateCache::Info,HGMTLRenderPipelineStateType>,void *>>>>::~unique_ptr[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      id v3 = (void *)v2[55];
      if (v3)
      {
        v2[56] = v3;
        operator delete(v3);
      }
    }
    operator delete(v2);
  }
  return a1;
}

uint64_t *std::__tree<std::__value_type<HGMetalSamplerStateCache::Info,HGMTLSamplerStateType>,std::__map_value_compare<HGMetalSamplerStateCache::Info,std::__value_type<HGMetalSamplerStateCache::Info,HGMTLSamplerStateType>,std::less<HGMetalSamplerStateCache::Info>,true>,std::allocator<std::__value_type<HGMetalSamplerStateCache::Info,HGMTLSamplerStateType>>>::__emplace_unique_key_args<HGMetalSamplerStateCache::Info,std::piecewise_construct_t const&,std::tuple<HGMetalSamplerStateCache::Info const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, _OWORD **a4)
{
  int8x8_t v7 = a1 + 1;
  unint64_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    unint64_t v9 = a2[1];
    unint64_t v10 = a2[2];
    unsigned int v11 = *((unsigned __int8 *)a2 + 24);
    while (1)
    {
      uint64_t v12 = v6;
      unint64_t v13 = v6[4];
      if (v8 < v13) {
        goto LABEL_3;
      }
      if (v8 > v13) {
        goto LABEL_6;
      }
      unint64_t v14 = v12[5];
      if (v9 < v14) {
        goto LABEL_3;
      }
      if (v9 > v14) {
        goto LABEL_6;
      }
      unint64_t v15 = v12[6];
      if (v10 < v15) {
        goto LABEL_3;
      }
      if (v10 > v15) {
        goto LABEL_6;
      }
      unsigned int v16 = *((unsigned __int8 *)v12 + 56);
      if (v11 < v16)
      {
LABEL_3:
        unint64_t v6 = (uint64_t *)*v12;
        int8x8_t v7 = (uint64_t **)v12;
        if (!*v12) {
          goto LABEL_16;
        }
      }
      else
      {
        if (v16 >= v11) {
          return v12;
        }
LABEL_6:
        unint64_t v6 = (uint64_t *)v12[1];
        if (!v6)
        {
          int8x8_t v7 = (uint64_t **)(v12 + 1);
          goto LABEL_16;
        }
      }
    }
  }
  uint64_t v12 = (uint64_t *)(a1 + 1);
LABEL_16:
  unint64_t v18 = v12;
  unint64_t v19 = operator new(0x48uLL);
  long long v20 = (*a4)[1];
  v19[2] = **a4;
  v19[3] = v20;
  *((void *)v19 + 8) = 0;
  *(void *)unint64_t v19 = 0;
  *((void *)v19 + 1) = 0;
  *((void *)v19 + 2) = v18;
  void *v7 = (uint64_t *)v19;
  unint64_t v21 = (uint64_t *)**a1;
  uint64_t v22 = (uint64_t *)v19;
  if (v21)
  {
    *a1 = v21;
    uint64_t v22 = *v7;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v22);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return (uint64_t *)v19;
}

void HGMetalFunctionCache::HGMetalFunctionCache(void **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2) {
    operator delete(v2);
  }
}

void HGMetalFunctionCache::HGMetalFunctionCache(void **__p)
{
  do
  {
    uint64_t v2 = (void **)*__p;
    if (*((char *)__p + 39) < 0) {
      operator delete(__p[2]);
    }
    operator delete(__p);
    std::string __p = v2;
  }
  while (v2);
}

HGComic *HGComicDesignerInterfaceImplementation::GenerateGraph(HGComicDesignerInterfaceImplementation *this, HGNode *a2)
{
  uint64_t v4 = (HGComic *)HGObject::operator new(0x1A0uLL);
  HGComic::HGComic(v4);
  (*(void (**)(HGComic *, void, HGNode *))(*(void *)v4 + 120))(v4, 0, a2);
  uint64_t v5 = *((void *)this + 5);
  if (v5 == -1)
  {
    unint64_t v6 = 0;
  }
  else
  {
    unint64_t v6 = HGObject::operator new(0x1B0uLL);
    HGComicLookupFilterLUTBitmapResource::HGComicLookupFilterLUTBitmapResource(v6, v5);
  }
  (*(void (**)(HGComic *, uint64_t, void *))(*(void *)v4 + 120))(v4, 1, v6);
  if (v6) {
    (*(void (**)(void *))(*(void *)v6 + 24))(v6);
  }
  (*(void (**)(HGComic *, void, float, double, double, double))(*(void *)v4 + 96))(v4, 0, (float)*((unint64_t *)this + 7), 0.0, 0.0, 0.0);
  (*(void (**)(HGComic *, uint64_t, float, double, double, double))(*(void *)v4 + 96))(v4, 8, (float)*((uint64_t *)this + 6), 0.0, 0.0, 0.0);
  (*(void (**)(HGComic *, uint64_t, float, double, double, double))(*(void *)v4 + 96))(v4, 9, (float)*((int *)this + 16), 0.0, 0.0, 0.0);
  (*(void (**)(HGComic *, uint64_t, float, float, float, float))(*(void *)v4 + 96))(v4, 10, (float)*((int *)this + 20), (float)*((int *)this + 21), (float)*((int *)this + 22), (float)*((int *)this + 23));
  (*(void (**)(HGComic *, uint64_t, double, float, double, double))(*(void *)v4 + 96))(v4, 11, *((double *)this + 12), COERCE_FLOAT(HIDWORD(*((void *)this + 12))), 0.0, 0.0);
  float v8 = 1.0;
  if (*((unsigned char *)this + 104)) {
    v7.n128_f32[0] = 1.0;
  }
  else {
    v7.n128_f32[0] = 0.0;
  }
  (*(void (**)(HGComic *, uint64_t, __n128, double, double, double))(*(void *)v4 + 96))(v4, 12, v7, 0.0, 0.0, 0.0);
  if (*((unsigned char *)this + 105)) {
    v9.n128_f32[0] = 1.0;
  }
  else {
    v9.n128_f32[0] = 0.0;
  }
  (*(void (**)(HGComic *, uint64_t, __n128, double, double, double))(*(void *)v4 + 96))(v4, 13, v9, 0.0, 0.0, 0.0);
  if (*((unsigned char *)this + 106)) {
    v10.n128_f32[0] = 1.0;
  }
  else {
    v10.n128_f32[0] = 0.0;
  }
  (*(void (**)(HGComic *, uint64_t, __n128, double, double, double))(*(void *)v4 + 96))(v4, 14, v10, 0.0, 0.0, 0.0);
  int v11 = *((_DWORD *)this + 16);
  if (v11 == 7)
  {
    (*(void (**)(HGComic *, uint64_t, float, double, double, double))(*(void *)v4 + 96))(v4, 3, 1.0, 0.0, 0.0, 0.0);
    uint64_t v13 = 4;
    float v8 = 0.0005;
  }
  else
  {
    if (v11 == 17)
    {
      float v12 = (float)((float)((float)((float)*((uint64_t *)this + 3) * 0.01) / -3.0) + 1.0)
          + ((float)((float)*((uint64_t *)this + 9) * 0.01) + -0.5) * -0.5;
      (*(void (**)(HGComic *, uint64_t, float, double, double, double))(*(void *)v4 + 96))(v4, 3, fmaxf(fminf(v12, 1.0), 0.0), 0.0, 0.0, 0.0);
      (*(void (**)(HGComic *, uint64_t, double, double, double, double))(*(void *)v4 + 96))(v4, 4, 0.0, 0.0, 0.0, 0.0);
      goto LABEL_21;
    }
    uint64_t v13 = 3;
  }
  (*(void (**)(HGComic *, uint64_t, float, double, double, double))(*(void *)v4 + 96))(v4, v13, v8, 0.0, 0.0, 0.0);
LABEL_21:
  (*(void (**)(HGComic *, uint64_t, float, double, double, double))(*(void *)v4 + 96))(v4, 3, (float)((float)((float)*((uint64_t *)this + 9) * -0.01) * 0.65) + 1.0, 0.0, 0.0, 0.0);
  (*(void (**)(HGComic *, uint64_t, float, double, double, double))(*(void *)v4 + 96))(v4, 1, 1.0/ (float)((float)((float)((float)*((uint64_t *)this + 2) * 0.01) + (float)((float)*((uint64_t *)this + 2) * 0.01)) + 1.0), 0.0, 0.0, 0.0);
  (*(void (**)(HGComic *, uint64_t, float, double, double, double))(*(void *)v4 + 96))(v4, 2, (float)((float)((float)((float)*((uint64_t *)this + 3) * -0.01) + 1.0) * 3.807) + 1.6, 0.0, 0.0, 0.0);
  (*(void (**)(HGComic *, uint64_t, float, double, double, double))(*(void *)v4 + 96))(v4, 5, (float)((float)((float)*((uint64_t *)this + 4) * 0.01) * 32.0) + 4.8, 0.0, 0.0, 0.0);
  (*(void (**)(HGComic *, uint64_t, float, double, double, double))(*(void *)v4 + 96))(v4, 6, (float)((float)((float)*((uint64_t *)this + 4) * 0.01) * 6.0) + 2.3406, 0.0, 0.0, 0.0);
  (*(void (**)(HGComic *, uint64_t, float, double, double, double))(*(void *)v4 + 96))(v4, 7, (float)((float)((float)*((uint64_t *)this + 4) * 0.01) * 12.0) + 4.0, 0.0, 0.0, 0.0);
  unint64_t v14 = (HGComic *)*((void *)this + 14);
  unint64_t v15 = v4;
  if (v14 != v4)
  {
    if (v14) {
      (*(void (**)(HGComic *))(*(void *)v14 + 24))(v14);
    }
    *((void *)this + 14) = v4;
    (*(void (**)(HGComic *))(*(void *)v4 + 16))(v4);
    unint64_t v15 = (HGComic *)*((void *)this + 14);
  }
  (*(void (**)(HGComic *))(*(void *)v4 + 24))(v4);
  return v15;
}

void sub_1B779C8B4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void HGComicDesignerInterface::HGComicDesignerInterface(HGComicDesignerInterface *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v2 = &unk_1F10D5868;
  id v3 = (char *)HGObject::operator new(0x78uLL);
  HGObject::HGObject((HGObject *)v3);
  *(void *)id v3 = &unk_1F10D5AD0;
  *((void *)v3 + 3) = 0;
  *((void *)v3 + 4) = 0;
  *((void *)v3 + 2) = 0;
  *(_OWORD *)(v3 + 40) = xmmword_1B8345DB0;
  *((void *)v3 + 7) = 720;
  *((_DWORD *)v3 + 16) = 0;
  *((void *)v3 + 9) = 0;
  *((_OWORD *)v3 + 5) = xmmword_1B8345DC0;
  __asm { FMOV            V0.2S, #1.0 }
  *((void *)v3 + 12) = _D0;
  *((_WORD *)v3 + 52) = 256;
  v3[106] = 1;
  *((void *)v3 + 14) = 0;
  *((void *)this + 51) = v3;
}

void sub_1B779CA34(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B779CA50(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGComicDesignerInterface::~HGComicDesignerInterface(HGNode *this)
{
  *(void *)this = &unk_1F10D5868;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10D5868;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGComicDesignerInterface::SetParameter(HGComicDesignerInterface *this, int a2, double a3, float a4, float a5, float a6)
{
  switch(a2)
  {
    case 0:
      uint64_t v7 = *((void *)this + 51);
      if ((float)*(uint64_t *)(v7 + 16) == *(float *)&a3) {
        goto LABEL_41;
      }
      *(void *)(v7 + 16) = (uint64_t)*(float *)&a3;
      uint64_t result = 1;
      break;
    case 1:
      uint64_t v9 = *((void *)this + 51);
      if ((float)*(uint64_t *)(v9 + 24) == *(float *)&a3) {
        goto LABEL_41;
      }
      *(void *)(v9 + 24) = (uint64_t)*(float *)&a3;
      uint64_t result = 1;
      break;
    case 2:
      uint64_t v10 = *((void *)this + 51);
      if ((float)*(uint64_t *)(v10 + 32) == *(float *)&a3) {
        goto LABEL_41;
      }
      *(void *)(v10 + 32) = (uint64_t)*(float *)&a3;
      uint64_t result = 1;
      break;
    case 3:
      uint64_t v11 = *((void *)this + 51);
      if ((float)*(uint64_t *)(v11 + 40) == *(float *)&a3) {
        goto LABEL_41;
      }
      *(void *)(v11 + 40) = (uint64_t)*(float *)&a3;
      uint64_t result = 1;
      break;
    case 4:
      uint64_t v12 = *((void *)this + 51);
      if ((float)*(uint64_t *)(v12 + 48) == *(float *)&a3) {
        goto LABEL_41;
      }
      *(void *)(v12 + 48) = (uint64_t)*(float *)&a3;
      uint64_t result = 1;
      break;
    case 5:
      uint64_t v13 = *((void *)this + 51);
      if ((float)*(unint64_t *)(v13 + 56) == *(float *)&a3) {
        goto LABEL_41;
      }
      *(void *)(v13 + 56) = (unint64_t)*(float *)&a3;
      uint64_t result = 1;
      break;
    case 6:
      uint64_t v14 = *((void *)this + 51);
      if (*(_DWORD *)(v14 + 64) == (int)*(float *)&a3) {
        goto LABEL_41;
      }
      *(_DWORD *)(v14 + 64) = (int)*(float *)&a3;
      uint64_t result = 1;
      break;
    case 7:
      uint64_t v15 = *((void *)this + 51);
      if ((float)*(uint64_t *)(v15 + 72) == *(float *)&a3) {
        goto LABEL_41;
      }
      *(void *)(v15 + 72) = (int)*(float *)&a3;
      uint64_t result = 1;
      break;
    case 8:
      uint64_t v21 = *((void *)this + 51);
      int v23 = *(_DWORD *)(v21 + 80);
      int v22 = *(_DWORD *)(v21 + 84);
      uint64_t v24 = *(void *)(v21 + 88);
      uint64_t v25 = HGRectMake4i((int)*(float *)&a3, (int)a4, (int)a5, (int)a6);
      if (v25 == v23 && v26 == v24 && HIDWORD(v25) == v22 && HIDWORD(v26) == HIDWORD(v24)) {
        goto LABEL_41;
      }
      uint64_t v30 = *((void *)this + 51);
      *(void *)(v30 + 80) = v25;
      *(void *)(v30 + 88) = v26;
      uint64_t result = 1;
      break;
    case 9:
      uint64_t v16 = *((void *)this + 51);
      if (COERCE_FLOAT(*(void *)(v16 + 96)) == *(float *)&a3 && COERCE_FLOAT(HIDWORD(*(void *)(v16 + 96))) == a4) {
        goto LABEL_41;
      }
      *((float *)&a3 + 1) = a4;
      *(double *)(v16 + 96) = a3;
      uint64_t result = 1;
      break;
    case 10:
      uint64_t v18 = *((void *)this + 51);
      if ((*(float *)&a3 == 1.0) == (*(unsigned char *)(v18 + 104) != 0)) {
        goto LABEL_41;
      }
      *(unsigned char *)(v18 + 104) = *(float *)&a3 == 1.0;
      uint64_t result = 1;
      break;
    case 11:
      uint64_t v19 = *((void *)this + 51);
      if ((*(float *)&a3 == 1.0) == (*(unsigned char *)(v19 + 105) != 0)) {
        goto LABEL_41;
      }
      *(unsigned char *)(v19 + 105) = *(float *)&a3 == 1.0;
      uint64_t result = 1;
      break;
    case 12:
      uint64_t v20 = *((void *)this + 51);
      if ((*(float *)&a3 == 1.0) == (*(unsigned char *)(v20 + 106) != 0))
      {
LABEL_41:
        uint64_t result = 0;
      }
      else
      {
        *(unsigned char *)(v20 + 106) = *(float *)&a3 == 1.0;
        uint64_t result = 1;
      }
      break;
    default:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

HGComic *HGComicDesignerInterface::GetOutput(HGNode *this, HGRenderer *a2)
{
  Input = HGRenderer::GetInput(a2, this, 0);
  uint64_t v4 = (HGComicDesignerInterfaceImplementation *)*((void *)this + 51);

  return HGComicDesignerInterfaceImplementation::GenerateGraph(v4, Input);
}

void HGComicDesignerInterfaceImplementation::~HGComicDesignerInterfaceImplementation(HGComicDesignerInterfaceImplementation *this)
{
  *(void *)this = &unk_1F10D5AD0;
  uint64_t v2 = *((void *)this + 14);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGObject::~HGObject(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10D5AD0;
  uint64_t v2 = *((void *)this + 14);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGObject::~HGObject(this);

  HGObject::operator delete(v3);
}

std::string *HGBufferDumper::_updateNodeFilename(HGBufferDumper *this, int a2, const char *a3, int a4, HGRect a5)
{
  uint64_t v5 = *(void *)&a5.var2;
  uint64_t v6 = *(void *)&a5.var0;
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  snprintf(__str, 8uLL, "%03d", a2);
  uint64_t v10 = (std::string *)((char *)this + 48);
  MEMORY[0x1BA9BF660](v10, __str);
  std::string::append(v10, ".");
  std::string::append(v10, a3);
  if (a4 == -1)
  {
    uint64_t v11 = "_out";
  }
  else
  {
    snprintf(__s, 8uLL, "_in%d", a4);
    uint64_t v11 = __s;
  }
  std::string::append(v10, v11);
  std::string::append(v10, ".");
  snprintf(__s, 0x20uLL, "%dx%d+%d+%d", v5 - v6, HIDWORD(v5) - HIDWORD(v6), v6, HIDWORD(v6));
  return std::string::append(v10, __s);
}

void HGBufferDumper::HGBufferDumper(HGBufferDumper *this)
{
  *(_OWORD *)((char *)this + 60) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 19) = -1;
  *((unsigned char *)this + 80) = 0;
}

void HGBufferDumper::~HGBufferDumper(void **this)
{
  if (*((char *)this + 71) < 0)
  {
    operator delete(this[6]);
    if ((*((char *)this + 47) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*((char *)this + 23) & 0x80000000) == 0) {
        return;
      }
LABEL_7:
      operator delete(*this);
      return;
    }
  }
  else if ((*((char *)this + 47) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(this[3]);
  if (*((char *)this + 23) < 0) {
    goto LABEL_7;
  }
}

uint64_t HGBufferDumper::setPath(HGBufferDumper *this, const char *a2)
{
  uint64_t result = MEMORY[0x1BA9BF660](this, a2);
  *((_DWORD *)this + 19) = -1;
  return result;
}

std::string *HGBufferDumper::enable(HGBufferDumper *this, int a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t result = (std::string *)HGLogger::setLevel((HGLogger *)"bufferdump", (const char *)1);
  if (*((unsigned __int8 *)this + 80) != a2)
  {
    *((unsigned char *)this + 80) = a2;
    *((void *)this + 9) = 0xFFFFFFFF00000000;
    gettimeofday(&v9, &v8);
    time_t tv_sec = v9.tv_sec;
    uint64_t v5 = localtime(&tv_sec);
    strftime(__s, 0x20uLL, "%Y%m%d.%H%M%S", v5);
    snprintf(__str, 0x10uLL, "%02d", v9.tv_usec / 10000);
    uint64_t v6 = (std::string *)((char *)this + 24);
    MEMORY[0x1BA9BF660](v6, "bufferdump.");
    std::string::append(v6, __s);
    return std::string::append(v6, __str);
  }
  return result;
}

std::string *HGBufferDumper::reset(std::string *this)
{
  uint64_t v1 = this;
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  this[3].__r_.__value_.__r.__words[0] = 0xFFFFFFFF00000000;
  gettimeofday(&v6, &v5);
  time_t tv_sec = v6.tv_sec;
  uint64_t v2 = localtime(&tv_sec);
  strftime(__s, 0x20uLL, "%Y%m%d.%H%M%S", v2);
  snprintf(__str, 0x10uLL, "%02d", v6.tv_usec / 10000);
  MEMORY[0x1BA9BF660](++v1, "bufferdump.");
  std::string::append(v1, __s);
  return std::string::append(v1, __str);
}

uint64_t HGBufferDumper::on(HGBufferDumper *this)
{
  return *((unsigned __int8 *)this + 80);
}

FILE *HGBufferDumper::write(HGBufferDumper *this, const char *a2, int a3, HGBitmap *a4)
{
  int v8 = *((_DWORD *)this + 19);
  if (v8 == -1)
  {
    if (*((char *)this + 23) < 0)
    {
      int v12 = access(*(const char **)this, 0);
      *((_DWORD *)this + 19) = v12 != -1;
      if (v12 != -1) {
        goto LABEL_15;
      }
    }
    else
    {
      int v9 = access((const char *)this, 0);
      *((_DWORD *)this + 19) = v9 != -1;
      if (v9 != -1) {
        goto LABEL_15;
      }
    }
    unsigned __int8 v13 = atomic_load(HGLogger::_enabled);
    if (v13)
    {
      uint64_t v14 = this;
      if (*((char *)this + 23) < 0) {
        uint64_t v14 = *(HGBufferDumper **)this;
      }
      HGLogger::log((HGLogger *)"bufferdump", (const char *)1, (HGLogger *)"ERROR - invalid path for buffer dump files : %s\n", v10, v11, v14);
    }
    unsigned __int8 v15 = atomic_load(HGLogger::_enabled);
    if (v15) {
      HGLogger::log((HGLogger *)"bufferdump", (const char *)1, (HGLogger *)"  Use HG_ENV_BUFFER_DUMP_DIR or HGRenderer::SetBufferDumpDir() with a valid directory.\n", v10, v11);
    }
    if (*((_DWORD *)this + 19) != 1) {
      return 0;
    }
  }
  else if (v8 != 1)
  {
    return 0;
  }
LABEL_15:
  if (!*((unsigned char *)this + 80)) {
    return 0;
  }
  int v16 = *((_DWORD *)this + 18) + 1;
  *((_DWORD *)this + 18) = v16;
  HGBufferDumper::_updateNodeFilename(this, v16, a2, a3, *(HGRect *)((char *)a4 + 20));
  int v17 = *((char *)this + 23);
  if (v17 >= 0) {
    size_t v18 = *((unsigned __int8 *)this + 23);
  }
  else {
    size_t v18 = *((void *)this + 1);
  }
  unint64_t v19 = v18 + 1;
  if (v18 + 1 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v19 >= 0x17)
  {
    uint64_t v22 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v19 | 7) != 0x17) {
      uint64_t v22 = v19 | 7;
    }
    uint64_t v23 = v22 + 1;
    p_dst = (std::string *)operator new(v22 + 1);
    __dst.__r_.__value_.__l.__size_ = v18 + 1;
    __dst.__r_.__value_.__r.__words[2] = v23 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v18 + 1;
    if (!v18) {
      goto LABEL_31;
    }
  }
  if (v17 >= 0) {
    uint64_t v24 = this;
  }
  else {
    uint64_t v24 = *(HGBufferDumper **)this;
  }
  memmove(p_dst, v24, v18);
LABEL_31:
  *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v18) = 47;
  int v25 = *((char *)this + 47);
  if (v25 >= 0) {
    uint64_t v26 = (char *)this + 24;
  }
  else {
    uint64_t v26 = (const std::string::value_type *)*((void *)this + 3);
  }
  if (v25 >= 0) {
    std::string::size_type v27 = *((unsigned __int8 *)this + 47);
  }
  else {
    std::string::size_type v27 = *((void *)this + 4);
  }
  unint64_t v28 = std::string::append(&__dst, v26, v27);
  long long v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
  v53.__r_.__value_.__r.__words[2] = v28->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v29;
  v28->__r_.__value_.__l.__size_ = 0;
  v28->__r_.__value_.__r.__words[2] = 0;
  v28->__r_.__value_.__r.__words[0] = 0;
  uint64_t v30 = std::string::append(&v53, ".");
  long long v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
  v54.__r_.__value_.__r.__words[2] = v30->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v31;
  v30->__r_.__value_.__l.__size_ = 0;
  v30->__r_.__value_.__r.__words[2] = 0;
  v30->__r_.__value_.__r.__words[0] = 0;
  long long v34 = (const std::string::value_type *)*((void *)this + 6);
  uint64_t v33 = (char *)this + 48;
  int32x2_t v32 = v34;
  int v35 = v33[23];
  if (v35 >= 0) {
    float v36 = v33;
  }
  else {
    float v36 = v32;
  }
  if (v35 >= 0) {
    std::string::size_type v37 = v33[23];
  }
  else {
    std::string::size_type v37 = *((void *)v33 + 1);
  }
  unsigned int v38 = std::string::append(&v54, v36, v37);
  long long v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
  v55.__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v55.__r_.__value_.__l.__data_ = v39;
  v38->__r_.__value_.__l.__size_ = 0;
  v38->__r_.__value_.__r.__words[2] = 0;
  v38->__r_.__value_.__r.__words[0] = 0;
  unint64_t v40 = std::string::append(&v55, ".iqa");
  long long v43 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
  int64_t v57 = v40->__r_.__value_.__r.__words[2];
  long long v56 = v43;
  v40->__r_.__value_.__l.__size_ = 0;
  v40->__r_.__value_.__r.__words[2] = 0;
  v40->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v55.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v54.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_45:
      if ((SHIBYTE(v53.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_46;
      }
      goto LABEL_51;
    }
  }
  else if ((SHIBYTE(v54.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_45;
  }
  operator delete(v54.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v53.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_46:
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_47;
    }
    goto LABEL_52;
  }
LABEL_51:
  operator delete(v53.__r_.__value_.__l.__data_);
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_47:
    unsigned __int8 v44 = atomic_load(HGLogger::_enabled);
    if ((v44 & 1) == 0) {
      goto LABEL_56;
    }
LABEL_53:
    uint64_t v46 = &v56;
    if (v57 < 0) {
      uint64_t v46 = (long long *)v56;
    }
    HGLogger::log((HGLogger *)"bufferdump", (const char *)1, (HGLogger *)"dumping buffered bitmap to disk : %s\n", v41, v42, v46);
    goto LABEL_56;
  }
LABEL_52:
  operator delete(__dst.__r_.__value_.__l.__data_);
  unsigned __int8 v45 = atomic_load(HGLogger::_enabled);
  if (v45) {
    goto LABEL_53;
  }
LABEL_56:
  if (v57 >= 0) {
    unint64_t v47 = (HGIQA *)&v56;
  }
  else {
    unint64_t v47 = (HGIQA *)v56;
  }
  uint64_t v21 = HGIQA::WriteBitmap(v47, (const char *)a4, 0);
  if ((v21 & 1) == 0)
  {
    unsigned __int8 v50 = atomic_load(HGLogger::_enabled);
    if (v50) {
      HGLogger::log((HGLogger *)"bufferdump", (const char *)1, (HGLogger *)"ERROR writing buffer dump.\n", v48, v49);
    }
  }
  if (SHIBYTE(v57) < 0) {
    operator delete((void *)v56);
  }
  return v21;
}

void sub_1B779D818(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (*(char *)(v35 - 73) < 0) {
    operator delete(*(void **)(v35 - 96));
  }
  _Unwind_Resume(exception_object);
}

void HGPBOBitmap::HGPBOBitmap(HGPBOBitmap *this, HGPixelBufferObj *a2)
{
  uint64_t v4 = HGPixelBufferObj::rect(a2);
  uint64_t v6 = v5;
  int v7 = HGPixelBufferObj::format(a2);
  uint64_t DataPtr = HGPixelBufferObj::GetDataPtr(a2);
  unsigned int v9 = HGPixelBufferObj::rowBytes(a2);
  HGBitmap::HGBitmap((uint64_t)this, v4, v6, v7, DataPtr, v9);
  *(void *)this = &unk_1F10D5B20;
  *((void *)this + 16) = a2;
  (*(void (**)(HGPixelBufferObj *))(*(void *)a2 + 16))(a2);
}

void sub_1B779D994(_Unwind_Exception *a1, void *a2)
{
  HGBitmap::~HGBitmap(v2, a2);
  _Unwind_Resume(a1);
}

void HGPBOBitmap::~HGPBOBitmap(HGPBOBitmap *this)
{
  *(void *)this = &unk_1F10D5B20;
  (*(void (**)(void))(**((void **)this + 16) + 24))(*((void *)this + 16));

  HGBitmap::~HGBitmap((HGBitmap *)this, v2);
}

{
  void *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10D5B20;
  (*(void (**)(void))(**((void **)this + 16) + 24))(*((void *)this + 16));
  HGBitmap::~HGBitmap((HGBitmap *)this, v2);

  HGObject::operator delete(v3);
}

void HGPBOBitmap::ReadTile(HGPBOBitmap *this, char *a2, HGRect a3, int a4)
{
  uint64_t v5 = *(void *)&a3.var2;
  uint64_t v6 = *(void *)&a3.var0;
  if (HGPixelBufferObj::GetDataPtr(*((HGPixelBufferObj **)this + 16)))
  {
    *(void *)&v11.int var0 = v6;
    *(void *)&v11.int var2 = v5;
    HGBitmap::ReadTile((HGBitmap *)this, a2, v11, a4);
  }
  else
  {
    HGLogger::warning((HGLogger *)"reading tile from unmapped PBO", v9, v10);
  }
}

const char *HGPBOBitmap::WriteTile(HGPBOBitmap *this, const char *a2, HGRect a3)
{
  return HGLogger::warning((HGLogger *)"writing tile into PBO bitmap -- undefined!!", a2, *(char **)&a3.var0, *(void *)&a3.var2);
}

void HGCVGLTextureFactory::HGCVGLTextureFactory(HGObject *a1, PC_Sp_counted_base **a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  HGObject::HGObject(a1);
  void *v3 = &unk_1F10D5BA0;
  v3[2] = 0;
  v3[3] = 0;
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v5, "hgcv", 1, "CVOpenGLESTextureCacheCreate");
  v4.int var0 = *a2;
  HGGLContext::Create();
}

void sub_1B779DD68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCSharedCount a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void HGCVGLTextureFactory::~HGCVGLTextureFactory(HGCVGLTextureFactory *this)
{
  *(void *)this = &unk_1F10D5BA0;
  uint64_t v2 = (const void *)*((void *)this + 3);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *((void *)this + 2);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }

  HGObject::~HGObject(this);
}

{
  const void *v2;
  uint64_t v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1F10D5BA0;
  uint64_t v2 = (const void *)*((void *)this + 3);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *((void *)this + 2);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  HGObject::~HGObject(this);

  HGObject::operator delete(v4);
}

void HGCVGLTextureFactory::_createTexture(uint64_t a1@<X0>, HGCVBitmap **a2@<X1>, HGBitmap **a3@<X8>)
{
  *a3 = 0;
  if (HGGLContext::ptr(*(HGGLContext **)(a1 + 16)) && *(void *)(a1 + 24))
  {
    HGGLContext::context((uint64_t *)&v31, *(HGGLContext **)(a1 + 16));
    HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v32, &v31.var0);
    PCSharedCount::PCSharedCount(&v31);
    uint64_t v6 = *((void *)*a2 + 16);
    long long v29 = a3;
    CVOpenGLESTextureRef image = 0;
    kdebug_trace();
    HGGLContext::isES2(*(HGGLContext **)(a1 + 16));
    int v8 = *((_DWORD *)*a2 + 7);
    int v7 = *((_DWORD *)*a2 + 8);
    int v9 = *((_DWORD *)*a2 + 5);
    int v10 = *((_DWORD *)*a2 + 6);
    GLint v11 = HGFormatUtils::toGLInternalFormat(*((_DWORD *)*a2 + 4));
    GLenum format = HGFormatUtils::toGLFormat(*((_DWORD *)*a2 + 4));
    GLenum v13 = HGFormatUtils::toGLType(*((_DWORD *)*a2 + 4));
    uint64_t v14 = CVOpenGLESTextureCacheCreateTextureFromImage((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CVOpenGLESTextureCacheRef *)(a1 + 24), *(CVImageBufferRef *)(v6 + 24), 0, 0xDE1u, v11, v8 - v9, v7 - v10, format, v13, *((void *)*a2 + 17), &image);
    kdebug_trace();
    if (v14)
    {
      unsigned __int8 v17 = atomic_load(HGLogger::_enabled);
      if (v17) {
        HGLogger::log((HGLogger *)"hgcv", (const char *)1, (HGLogger *)" **** CVOpenGLESTextureCacheCreateTextureFromImage() error! booo! (%d)\n", v15, v16, v14);
      }
    }
    else
    {
      uint64_t Target = CVOpenGLESTextureGetTarget(image);
      uint64_t Name = CVOpenGLESTextureGetName(image);
      unsigned int v22 = Name;
      unsigned __int8 v23 = atomic_load(HGLogger::_enabled);
      if (v23) {
        HGLogger::log((HGLogger *)"hgcv", (const char *)1, (HGLogger *)"created CVGLES texture (%d, %d) for pixelbuffer (%p)\n", v20, v21, Target, Name, *(void *)(v6 + 24));
      }
      uint64_t v24 = *a2;
      int v25 = (HGCVBufferPairStorage *)HGObject::operator new(0x20uLL);
      HGCVBufferPairStorage::HGCVBufferPairStorage(v25, v24, image);
      uint64_t v26 = *a2;
      std::string::size_type v27 = (HGBitmap *)HGObject::operator new(0xC8uLL);
      HGGLTexture::HGGLTexture((uint64_t)v27, *(void *)((char *)v26 + 20), *(void *)((char *)v26 + 28), *((_DWORD *)v26 + 4), 0, Target, v22, 0);
      unint64_t v28 = *v29;
      if (*v29 == v27)
      {
        if (v27) {
          (*(void (**)(HGBitmap *))(*(void *)v27 + 24))(v27);
        }
      }
      else
      {
        if (v28) {
          (*(void (**)(HGBitmap *))(*(void *)v28 + 24))(v28);
        }
        *long long v29 = v27;
      }
      *((_DWORD *)v27 + 3) |= 1u;
      HGBitmap::SetStorage(v27, v25);
      CFRelease(image);
      if (v25) {
        (*(void (**)(HGCVBufferPairStorage *))(*(void *)v25 + 24))(v25);
      }
    }
    HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v32);
  }
}

void sub_1B779E234(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, PCSharedCount a14, char a15)
{
  uint64_t v17 = v15;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 24))(v17);
  }
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 24))(v16);
  }
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)&a15);
  if (*a12) {
    (*(void (**)(void))(*(void *)*a12 + 24))(*a12);
  }
  _Unwind_Resume(a1);
}

void HGCVGLTextureFactory::flush(CVOpenGLESTextureCacheRef *this)
{
}

void HGGPUReadbackJob::HGGPUReadbackJob(HGObject *a1, uint64_t *a2, uint64_t *a3)
{
  HGObject::HGObject(a1);
  *uint64_t v6 = &unk_1F10D5BF0;
  void v6[2] = 0;
  v6[3] = 0;
  v6[4] = 0;
  uint64_t v8 = *a2;
  uint64_t v7 = a2[1];
  if (v7)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
    int v9 = (std::__shared_weak_count *)*((void *)a1 + 3);
    *((void *)a1 + 2) = v8;
    *((void *)a1 + 3) = v7;
    if (v9)
    {
      if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }
  else
  {
    *((void *)a1 + 2) = v8;
    *((void *)a1 + 3) = 0;
  }
  uint64_t v10 = *a3;
  HGGLContext::Share();
}

void sub_1B779E4FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  PCSharedCount::PCSharedCount((PCSharedCount *)&a9);
  uint64_t v13 = *((void *)v10 + 4);
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 24))(v13);
  }
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100](v11);
  HGObject::~HGObject(v10);
  _Unwind_Resume(a1);
}

void HGGPUReadbackJob::~HGGPUReadbackJob(HGGPUReadbackJob *this)
{
  *(void *)this = &unk_1F10D5BF0;
  uint64_t v2 = *((void *)this + 5);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 4);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  PCSharedCount v4 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    uint64_t v5 = this;
  }
  else
  {
    uint64_t v5 = this;
  }
  HGObject::~HGObject(v5);
}

{
  void *v1;
  uint64_t vars8;

  HGGPUReadbackJob::~HGGPUReadbackJob(this);

  HGObject::operator delete(v1);
}

void HGGPUReadbackExecUnit::HGGPUReadbackExecUnit(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  *(void *)a1 = &unk_1F10D5C28;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 48) = 0;
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  if (v5)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
    uint64_t v7 = *(std::__shared_weak_count **)(a1 + 24);
    *(void *)(a1 + 16) = v6;
    *(void *)(a1 + 24) = v5;
    if (v7)
    {
      if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }
  else
  {
    *(void *)(a1 + 16) = v6;
    *(void *)(a1 + 24) = 0;
  }
  *(_DWORD *)(a1 + 12) = 0;
  uint64_t v8 = *a3;
  HGGLContext::Share();
}

void sub_1B779E87C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  PCSharedCount::PCSharedCount((PCSharedCount *)&a9);
  uint64_t v13 = *(void *)(v11 + 48);
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 24))(v13);
  }
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100](v10);
  _Unwind_Resume(a1);
}

void HGGPUReadbackExecUnit::~HGGPUReadbackExecUnit(HGGPUReadbackExecUnit *this)
{
  *(void *)this = &unk_1F10D5C28;
  uint64_t v2 = *((void *)this + 8);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 4);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  uint64_t v4 = *((void *)this + 5);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  uint64_t v5 = *((void *)this + 6);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v6)
  {
    if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

{
  uint64_t vars8;

  HGGPUReadbackExecUnit::~HGGPUReadbackExecUnit(this);

  JUMPOUT(0x1BA9BFBA0);
}

HGGPUReadbackExecUnit *StartGPUReadbackExecUnitFunc(HGGPUReadbackExecUnit *a1)
{
  return a1;
}

BOOL HGGPUReadbackExecUnit::RunLoop(HGGPUReadbackExecUnit *this)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  int VirtualScreen = HGGLContext::getVirtualScreen(*((HGGLContext **)this + 6));
  snprintf(__str, 0x200uLL, "com.apple.helium.rq.rbu%d.vs%d", *((_DWORD *)this + 2), VirtualScreen);
  pthread_setname_np(__str);
  BOOL result = HGRenderQueue::IsShuttingDown(*((HGRenderQueue **)this + 7));
  if (!result)
  {
    while (1)
    {
      HGAutoReleasePoolScopeGuard::HGAutoReleasePoolScopeGuard((HGAutoReleasePoolScopeGuard *)&v29);
      unint64_t v28 = 0;
      if (HGRenderQueue::GetGPUReadbackJob(*((HGRenderQueue **)this + 7), (HGGLContext **)this, &v28)) {
        break;
      }
LABEL_63:
      HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard(&v29);
      BOOL result = HGRenderQueue::IsShuttingDown(*((HGRenderQueue **)this + 7));
      if (result) {
        goto LABEL_64;
      }
    }
    *((_DWORD *)this + 3) = 2;
    uint64_t v4 = *((void *)v28 + 5);
    uint64_t v5 = mach_absolute_time();
    int v6 = *(_DWORD *)(*(void *)(v4 + 24) + 12);
    if (v6)
    {
      int v8 = 6;
      if (*(_DWORD *)(v4 + 56) != 5) {
        goto LABEL_14;
      }
    }
    else
    {
      if ((v6 & 0x10) != 0) {
        int v7 = 3;
      }
      else {
        int v7 = 5;
      }
      if ((v6 & 0x20) != 0) {
        int v8 = 5;
      }
      else {
        int v8 = v7;
      }
      if (*(_DWORD *)(v4 + 56) != 5) {
        goto LABEL_14;
      }
    }
    if (!*(_DWORD *)(v4 + 60))
    {
      *(_DWORD *)(v4 + 6CVOpenGLESTextureCacheFlush(this[3], 0) = v8;
      if ((*(unsigned char *)(*((void *)this + 7) + 70) & 2) == 0) {
        goto LABEL_22;
      }
      goto LABEL_15;
    }
LABEL_14:
    if ((*(unsigned char *)(*((void *)this + 7) + 70) & 2) == 0) {
      goto LABEL_22;
    }
LABEL_15:
    if (v8 == 3)
    {
      printf("Executing GPU-to-PBO Buffer Copy Job <%p>:    %llu   GL Texture\n");
    }
    else if (v8 == 5)
    {
      printf("Executing GPU-to-CPU Buffer Copy Job <%p>:    %llu   Metal Texture\n");
    }
    else
    {
      printf("Executing GPU-to-CPU Buffer Copy Job <%p>:    %llu   IOSurface\n");
    }
LABEL_22:
    kdebug_trace();
    uint64_t v10 = *(void *)(v4 + 24);
    int v11 = *(_DWORD *)(v10 + 12);
    if (v11)
    {
      CVBitmapStorage = (char *)HGCVBitmap::getCVBitmapStorage((HGBitmap *)v10, v9);
      HGCVBitmap::lock((HGCVBitmap *)CVBitmapStorage, 0);
      HGCVBitmap::unlock((HGCVBitmap *)CVBitmapStorage, 0);
      (*(void (**)(char *))(*(void *)CVBitmapStorage + 16))(CVBitmapStorage);
      uint64_t v13 = *(void *)(v4 + 24);
      if ((*(unsigned char *)(v13 + 12) & 0x10) != 0) {
        HGRenderQueue::EnqueueDeleteHGGLTexture(*((HGRenderQueue **)this + 7), (HGGLTexture *)v13);
      }
      else {
        (*(void (**)(void))(*(void *)v13 + 24))(*(void *)(v4 + 24));
      }
      if (*(_DWORD *)(v4 + 60) == 1)
      {
        uint64_t v16 = HGObject::operator new(0x80uLL);
        HGBitmap::HGBitmap(v16, *(void *)(CVBitmapStorage + 20), *(void *)(CVBitmapStorage + 28), *((unsigned int *)CVBitmapStorage + 4));
        HGCVBitmap::lock((HGCVBitmap *)CVBitmapStorage, 1uLL);
        HGRenderUtils::BufferCopier::BufferCopier((HGRenderUtils::BufferCopier *)&v26);
      }
    }
    else
    {
      if ((v11 & 0x20) == 0)
      {
        if ((v11 & 0x10) != 0) {
          HGGPUReadbackExecUnit::ExecutePBOReadback(this, v28);
        }
LABEL_36:
        size_t v18 = (HGTiming *)mach_absolute_time();
        double v19 = HGTiming::GetMachTimeConversionFactor(v18) * (double)((unint64_t)v18 - v5);
        *(double *)(v4 + 104) = v19 + *(double *)(v4 + 104);
        *(double *)(v4 + 112) = v19;
        uint64_t v26 = *(HGSynchronizable **)(*((void *)this + 7) + 584);
        char v27 = 0;
        HGSynchronizable::Lock(v26);
        std::list<HGGPUReadbackJob *>::remove((void *)(*((void *)this + 7) + 592), &v28);
        HGSynchronizable::Unlock(v26);
        kdebug_trace();
        if ((*(unsigned char *)(*((void *)this + 7) + 70) & 2) != 0)
        {
          if (v8 == 3)
          {
            printf("Completed GPU-to-PBO Buffer Copy Job <%p>: GLTexture     :  %llu  ");
          }
          else if (v8 == 5)
          {
            printf("Completed GPU-to-CPU Buffer Copy Job <%p>: MTLTexture    :  %llu  ");
          }
          else if (*(_DWORD *)(*(void *)(v4 + 192) + 100) == 1)
          {
            printf("Completed GPU-to-CPU Buffer Copy Job <%p>: GL-IOSurface  :  %llu  ");
          }
          else
          {
            printf("Completed GPU-to-CPU Buffer Copy Job <%p>: MTL-IOSurface :  %llu  ");
          }
          printf("%5.1f ms\n", *(double *)(v4 + 112) * 1000.0);
        }
        if (*(_DWORD *)(v4 + 56) != 5)
        {
          *(_DWORD *)(v4 + 56) = 9;
          HGRenderNode::CallNotifyFunc((const char *)v4);
          HGRenderNode::NotifyRenderJobFinished((HGRenderJob **)v4);
LABEL_62:
          (*(void (**)(HGGPUReadbackJob *))(*(void *)v28 + 24))(v28);
          *((_DWORD *)this + 3) = 1;
          goto LABEL_63;
        }
        uint64_t v20 = (HGRenderJob *)HGObject::operator new(0x160uLL);
        HGRenderJob::HGRenderJob(v20);
        HGRenderJob::AddRenderNodeInternal(v20, (HGRenderNode *)v4);
        HGUserJob::SetPriority((uint64_t)v20, 2);
        HGUserJob::SetState((uint64_t)v20, 2);
        HGRenderJob::SetPriority((uint64_t)v20, 11);
        int v21 = *(_DWORD *)(v4 + 60);
        switch(v21)
        {
          case 3:
            int v22 = 1;
            break;
          case 5:
            int v22 = 2;
            break;
          case 6:
            int v22 = 0;
            break;
          default:
            goto LABEL_54;
        }
        HGRenderJob::SetGPUGraphicsAPI((uint64_t)v20, v22);
LABEL_54:
        uint64_t v23 = *(void *)(v4 + 72);
        if (v23 && *(_DWORD *)(v23 + 8) == 1)
        {
          HGRenderJob::SetComputeDevice((uint64_t)v20, (uint64_t *)(v4 + 72));
        }
        else
        {
          uint64_t v24 = *(HGGLContext **)(v4 + 88);
          if (v24)
          {
            int v25 = HGGLContext::getVirtualScreen(v24);
            HGRenderJob::SetVirtualScreen(v20, v25);
          }
        }
        HGRenderNode::CallNotifyFunc((const char *)v4);
        if (HGRenderQueue::EnqueueRenderJob(*((HGRenderQueue **)this + 7), v20))
        {
          *(_DWORD *)(v4 + 56) = -997;
          HGRenderNode::CallNotifyFunc((const char *)v4);
          HGRenderNode::NotifyRenderJobFinished((HGRenderJob **)v4);
        }
        (*(void (**)(HGRenderJob *))(*(void *)v20 + 24))(v20);
        goto LABEL_62;
      }
      MetalStorage = (HGMetalTexture *)HGMetalTexture::getMetalStorage((HGBitmap *)v10, v9);
      CVBitmapStorage = (char *)HGObject::operator new(0x80uLL);
      HGBitmap::HGBitmap(CVBitmapStorage, *(void *)(*(void *)(v4 + 24) + 20), *(void *)(*(void *)(v4 + 24) + 28), *(unsigned int *)(*(void *)(v4 + 24) + 16));
      uint64_t v15 = (id *)*((void *)this + 4);
      if (v15)
      {
        HGMetalTexture::CopyTexture(MetalStorage, v15, (HGBitmap *)CVBitmapStorage, *(HGRect *)(CVBitmapStorage + 20));
      }
      else
      {
        MetalContext = (id *)HGGPURenderer::GetMetalContext(*(HGGPURenderer **)(v4 + 184));
        HGMetalTexture::CopyTexture(MetalStorage, MetalContext, (HGBitmap *)CVBitmapStorage, *(HGRect *)(CVBitmapStorage + 20));
      }
      (*(void (**)(void))(**(void **)(v4 + 24) + 24))(*(void *)(v4 + 24));
    }
    *(void *)(v4 + 24) = CVBitmapStorage;
    *(_DWORD *)(v4 + 64) = 1;
    goto LABEL_36;
  }
LABEL_64:
  *((_DWORD *)this + 3) = 3;
  return result;
}

void sub_1B779F0F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B779F10C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B779F120(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id a14)
{
  HGObject::operator delete(v14);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard(&a14);
  _Unwind_Resume(a1);
}

void sub_1B779F13C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B779F150(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id a14)
{
  HGObject::operator delete(v14);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard(&a14);
  _Unwind_Resume(a1);
}

void sub_1B779F16C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B779F180(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B779F194(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id a14)
{
  HGObject::operator delete(v14);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard(&a14);
  _Unwind_Resume(a1);
}

void sub_1B779F1B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B779F1C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B779F1D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  HGRenderUtils::BufferCopier::~BufferCopier((HGRenderUtils::BufferCopier *)va);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va1);
  _Unwind_Resume(a1);
}

void sub_1B779F1F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, char a14)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B779F27C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

void sub_1B779F290(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  HGAutoReleasePoolScopeGuard::~HGAutoReleasePoolScopeGuard((id *)va);
  _Unwind_Resume(a1);
}

uint64_t HGGPUReadbackExecUnit::StartRunLoop(HGGPUReadbackExecUnit *this)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = (pthread_t *)((char *)this + 80);
  if (*((void *)this + 10)) {
    return 0;
  }
  pthread_attr_init(&v5);
  pthread_attr_setdetachstate(&v5, 2);
  uint64_t v2 = pthread_create(v1, &v5, (void *(__cdecl *)(void *))StartGPUReadbackExecUnitFunc, this);
  pthread_attr_destroy(&v5);
  return v2;
}

HGSynchronizable *HGGPUReadbackExecUnit::ExecutePBOReadback(HGGPUReadbackExecUnit *this, HGGPUReadbackJob *a2)
{
  uint64_t v3 = *((void *)a2 + 5);
  HGGLTexture::ReadPixels((HGGLTexture *)v4, *((HGPixelBufferObj **)this + 8), *(HGRect *)(v4 + 20));
  uint64_t DataPtr = HGPixelBufferObj::GetDataPtr(*((HGPixelBufferObj **)this + 8));
  ++*((void *)this + 11);
  if (DataPtr)
  {
    uint64_t v6 = (HGPixelBufferObj *)*((void *)this + 8);
    if (*(_DWORD *)(v3 + 60) == 1)
    {
      *(void *)(v3 + 24) = HGPixelBufferObj::CreateBitmap(v6);
      *(_DWORD *)(v3 + 64) = 1;
      HGPixelBufferObj::ReleaseDataPtr(*((HGPixelBufferObj **)this + 8));
      HGRenderQueue::ReleasePBOToSharedPool(*((HGRenderQueue **)this + 7), *((HGPixelBufferObj **)this + 8));
    }
    else
    {
      *(void *)(v3 + 136) = v6;
      *(_DWORD *)(v3 + 64) = 2;
      *(void *)(v3 + 24) = 0;
    }
    BOOL result = (HGSynchronizable *)HGRenderQueue::EnqueueDeleteHGGLTexture(*((HGRenderQueue **)this + 7), (HGGLTexture *)v4);
    *((void *)this + 8) = 0;
  }
  else
  {
    *(_DWORD *)(v3 + 56) = -997;
    BOOL result = HGRenderQueue::ReleasePBOToSharedPool(*((HGRenderQueue **)this + 7), *((HGPixelBufferObj **)this + 8));
    *((void *)this + 8) = 0;
  }
  return result;
}

void *std::list<HGGPUReadbackJob *>::remove(void *result, void *a2)
{
  int v21 = &v21;
  int v22 = &v21;
  uint64_t v2 = (void *)result[1];
  if (v2 == result) {
    return result;
  }
  if (&v21 == result)
  {
    while (1)
    {
      int v12 = (void *)v2[1];
      uint64_t v13 = v2[2];
      if (v13 == *a2) {
        break;
      }
LABEL_19:
      uint64_t v2 = v12;
      if (v12 == result) {
        return result;
      }
    }
    if (v12 == result)
    {
      BOOL v14 = 1;
    }
    else
    {
      if (v12[2] != v13)
      {
LABEL_25:
        BOOL v14 = 0;
        if (v2 == v12)
        {
LABEL_30:
          if (!v14) {
            int v12 = (void *)v12[1];
          }
          goto LABEL_19;
        }
LABEL_29:
        uint64_t v15 = *v12;
        uint64_t v16 = *v2;
        *(void *)(v16 + 8) = *(void *)(*v12 + 8);
        **(void **)(v15 + 8) = v16;
        uint64_t v17 = *result;
        *(void *)(v17 + 8) = v2;
        *uint64_t v2 = v17;
        *BOOL result = v15;
        *(void *)(v15 + 8) = result;
        goto LABEL_30;
      }
      while (1)
      {
        int v12 = (void *)v12[1];
        BOOL v14 = v12 == result;
        if (v12 == result) {
          break;
        }
        if (v12[2] != v13) {
          goto LABEL_25;
        }
      }
    }
    int v12 = result;
    if (v2 == result) {
      goto LABEL_30;
    }
    goto LABEL_29;
  }
  uint64_t v3 = 0;
  do
  {
    uint64_t v4 = (void *)v2[1];
    uint64_t v5 = v2[2];
    if (v5 == *a2)
    {
      while (v4 != result)
      {
        BOOL v6 = v4[2] == v5;
        if (v4[2] != v5)
        {
          if (v2 != v4) {
            goto LABEL_11;
          }
LABEL_17:
          if (v6) {
            goto LABEL_4;
          }
          goto LABEL_18;
        }
        uint64_t v4 = (void *)v4[1];
      }
      BOOL v6 = 1;
      uint64_t v4 = result;
      if (v2 == result) {
        goto LABEL_17;
      }
LABEL_11:
      uint64_t v7 = (void *)*v4;
      uint64_t v8 = 1;
      if ((void *)*v4 != v2)
      {
        int v9 = v2;
        do
        {
          int v9 = (void *)v9[1];
          ++v8;
        }
        while (v9 != v7);
      }
      result[2] -= v8;
      v3 += v8;
      uint64_t v10 = *v2;
      *(void *)(v10 + 8) = v7[1];
      *(void *)v7[1] = v10;
      int v11 = v21;
      v21[1] = v2;
      *uint64_t v2 = v11;
      int v21 = v7;
      v7[1] = &v21;
      if (!v6) {
LABEL_18:
      }
        uint64_t v4 = (void *)v4[1];
    }
LABEL_4:
    uint64_t v2 = v4;
  }
  while (v4 != result);
  if (v3)
  {
    size_t v18 = v21;
    BOOL result = v22;
    uint64_t v19 = *v22;
    *(void *)(v19 + 8) = v21[1];
    *(void *)v18[1] = v19;
    uint64_t v23 = 0;
    if (result != &v21)
    {
      do
      {
        uint64_t v20 = (void *)result[1];
        operator delete(result);
        BOOL result = v20;
      }
      while (v20 != &v21);
    }
  }
  return result;
}

float HGComicImplementation::GetSmallToLargeScale(HGComicImplementation *this, HGRect *a2)
{
  float v4 = 1.0;
  float v5 = 1.0;
  if (!HGRect::IsInfinite(a2))
  {
    BOOL IsInfinite = HGRect::IsInfinite(a2);
    float v7 = 1.0;
    if (!IsInfinite)
    {
      float v8 = *((float *)this + 3);
      float v9 = 1.0;
      if (v8 != 0.0)
      {
        float v10 = fminf((float)(a2->var2 - a2->var0), (float)(a2->var3 - a2->var1));
        float v11 = v10 * 0.76;
        float v9 = v8 / v10;
        if (v11 <= v8) {
          float v9 = 0.76;
        }
      }
      if (v9 <= 0.9) {
        float v7 = v9;
      }
    }
    float v12 = *((float *)this + 4);
    if (v12 == 0.0) {
      float v12 = 1.0;
    }
    float v13 = v7 * v12;
    if (v13 <= 0.9) {
      float v5 = v13;
    }
    else {
      float v5 = 1.0;
    }
  }
  if (!HGRect::IsInfinite(a2))
  {
    float v14 = *((float *)this + 3);
    float v15 = 1.0;
    if (v14 != 0.0)
    {
      float v16 = fminf((float)(a2->var2 - a2->var0), (float)(a2->var3 - a2->var1));
      float v17 = v16 * 0.76;
      float v15 = v14 / v16;
      if (v17 <= v14) {
        float v15 = 0.76;
      }
    }
    if (v15 <= 0.9) {
      float v4 = v15;
    }
    else {
      float v4 = 1.0;
    }
  }
  return (float)(1.0 / v5) * v4;
}

float HGComicImplementation::GetLargeToSmallScale(HGComicImplementation *this, HGRect *a2)
{
  float v4 = 1.0;
  float v5 = 1.0;
  if (!HGRect::IsInfinite(a2))
  {
    float v6 = *((float *)this + 3);
    float v7 = 1.0;
    if (v6 != 0.0)
    {
      float v8 = fminf((float)(a2->var2 - a2->var0), (float)(a2->var3 - a2->var1));
      float v9 = v8 * 0.76;
      float v7 = v6 / v8;
      if (v9 <= v6) {
        float v7 = 0.76;
      }
    }
    if (v7 <= 0.9) {
      float v5 = v7;
    }
    else {
      float v5 = 1.0;
    }
  }
  if (!HGRect::IsInfinite(a2))
  {
    BOOL IsInfinite = HGRect::IsInfinite(a2);
    float v11 = 1.0;
    if (!IsInfinite)
    {
      float v12 = *((float *)this + 3);
      float v13 = 1.0;
      if (v12 != 0.0)
      {
        float v14 = fminf((float)(a2->var2 - a2->var0), (float)(a2->var3 - a2->var1));
        float v15 = v14 * 0.76;
        float v13 = v12 / v14;
        if (v15 <= v12) {
          float v13 = 0.76;
        }
      }
      if (v13 <= 0.9) {
        float v11 = v13;
      }
    }
    float v16 = *((float *)this + 4);
    if (v16 == 0.0) {
      float v16 = 1.0;
    }
    float v17 = v11 * v16;
    if (v17 <= 0.9) {
      float v4 = v17;
    }
    else {
      float v4 = 1.0;
    }
  }
  return (float)(1.0 / v5) * v4;
}

uint64_t HGComicImplementation::GenerateSobelNode@<X0>(HGComicImplementation *this@<X0>, HGNode *a2@<X1>, float a3@<S0>, int a4@<W2>, HGTextureWrap **a5@<X8>)
{
  if (a2) {
    (*(void (**)(HGNode *))(*(void *)a2 + 16))(a2);
  }
  float v10 = (HGComicSobelOperator *)HGObject::operator new(0x1A0uLL);
  HGComicSobelOperator::HGComicSobelOperator(v10);
  (*(void (**)(HGComicSobelOperator *, void, HGNode *))(*(void *)v10 + 120))(v10, 0, a2);
  float v11 = 0.0;
  (*(void (**)(HGComicSobelOperator *, uint64_t, float, double, double, double))(*(void *)v10 + 96))(v10, 1, a3, 0.0, 0.0, 0.0);
  if (a4)
  {
    if (*((unsigned char *)this + 97)) {
      float v11 = 1.0;
    }
    else {
      float v11 = 0.0;
    }
  }
  (*(void (**)(HGComicSobelOperator *, void, float, double, double, double))(*(void *)v10 + 96))(v10, 0, v11, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicSobelOperator *))(*(void *)v10 + 16))(v10);
  float v12 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v12);
  (*(void (**)(HGTextureWrap *, void, HGComicSobelOperator *))(*(void *)v12 + 120))(v12, 0, v10);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v12, (const char *)1, v13);
  *a5 = v12;
  (*(void (**)(HGComicSobelOperator *))(*(void *)v10 + 24))(v10);
  uint64_t result = (*(uint64_t (**)(HGComicSobelOperator *))(*(void *)v10 + 24))(v10);
  if (a2) {
    return (*(uint64_t (**)(HGNode *))(*(void *)a2 + 24))(a2);
  }
  return result;
}

void sub_1B779FB4C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v3);
  (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t HGComicImplementation::GenerateGaussBlurXNode@<X0>(HGComicImplementation *this@<X0>, HGNode *a2@<X1>, float a3@<S0>, HGTextureWrap **a4@<X8>)
{
  if (a2) {
    (*(void (**)(HGNode *))(*(void *)a2 + 16))(a2);
  }
  float v8 = (HGComicGaussianBlurAndGradientGeneration *)HGObject::operator new(0x1B0uLL);
  HGComicGaussianBlurAndGradientGeneration::HGComicGaussianBlurAndGradientGeneration(v8);
  (*(void (**)(HGComicGaussianBlurAndGradientGeneration *, void, HGNode *))(*(void *)v8 + 120))(v8, 0, a2);
  (*(void (**)(HGComicGaussianBlurAndGradientGeneration *, void, float, double, double, double))(*(void *)v8 + 96))(v8, 0, a3 * COERCE_FLOAT(*((void *)this + 9)), 0.0, 0.0, 0.0);
  (*(void (**)(HGComicGaussianBlurAndGradientGeneration *, uint64_t, float, double, double, double))(*(void *)v8 + 96))(v8, 1, 1.0, 0.0, 0.0, 0.0);
  if (*((unsigned char *)this + 96)) {
    v9.n128_f32[0] = 1.0;
  }
  else {
    v9.n128_f32[0] = 0.0;
  }
  (*(void (**)(HGComicGaussianBlurAndGradientGeneration *, uint64_t, __n128, double, double, double))(*(void *)v8 + 96))(v8, 2, v9, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicGaussianBlurAndGradientGeneration *))(*(void *)v8 + 16))(v8);
  float v10 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v10);
  (*(void (**)(HGTextureWrap *, void, HGComicGaussianBlurAndGradientGeneration *))(*(void *)v10 + 120))(v10, 0, v8);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v10, (const char *)1, v11);
  *a4 = v10;
  (*(void (**)(HGComicGaussianBlurAndGradientGeneration *))(*(void *)v8 + 24))(v8);
  uint64_t result = (*(uint64_t (**)(HGComicGaussianBlurAndGradientGeneration *))(*(void *)v8 + 24))(v8);
  if (a2) {
    return (*(uint64_t (**)(HGNode *))(*(void *)a2 + 24))(a2);
  }
  return result;
}

void sub_1B779FEB4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v3);
  (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t HGComicImplementation::GenerateGaussBlurYAndGradNode@<X0>(HGComicImplementation *this@<X0>, HGNode *a2@<X1>, float a3@<S0>, HGTextureWrap **a4@<X8>)
{
  if (a2) {
    (*(void (**)(HGNode *))(*(void *)a2 + 16))(a2);
  }
  float v8 = (HGComicGaussianBlurAndGradientGeneration *)HGObject::operator new(0x1B0uLL);
  HGComicGaussianBlurAndGradientGeneration::HGComicGaussianBlurAndGradientGeneration(v8);
  (*(void (**)(HGComicGaussianBlurAndGradientGeneration *, void, HGNode *))(*(void *)v8 + 120))(v8, 0, a2);
  (*(void (**)(HGComicGaussianBlurAndGradientGeneration *, void, float, double, double, double))(*(void *)v8 + 96))(v8, 0, *((float *)this + 19) * a3, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicGaussianBlurAndGradientGeneration *, uint64_t, double, float, double, double))(*(void *)v8 + 96))(v8, 1, 0.0, 1.0, 0.0, 0.0);
  if (*((unsigned char *)this + 96)) {
    v9.n128_f32[0] = 1.0;
  }
  else {
    v9.n128_f32[0] = 0.0;
  }
  (*(void (**)(HGComicGaussianBlurAndGradientGeneration *, uint64_t, __n128, double, double, double))(*(void *)v8 + 96))(v8, 2, v9, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicGaussianBlurAndGradientGeneration *))(*(void *)v8 + 16))(v8);
  float v10 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v10);
  (*(void (**)(HGTextureWrap *, void, HGComicGaussianBlurAndGradientGeneration *))(*(void *)v10 + 120))(v10, 0, v8);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v10, (const char *)1, v11);
  *a4 = v10;
  (*(void (**)(HGComicGaussianBlurAndGradientGeneration *))(*(void *)v8 + 24))(v8);
  uint64_t result = (*(uint64_t (**)(HGComicGaussianBlurAndGradientGeneration *))(*(void *)v8 + 24))(v8);
  if (a2) {
    return (*(uint64_t (**)(HGNode *))(*(void *)a2 + 24))(a2);
  }
  return result;
}

void sub_1B77A0220(_Unwind_Exception *a1)
{
  HGObject::operator delete(v3);
  (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t HGComicImplementation::GenerateBilateralXNode@<X0>(HGComicImplementation *this@<X0>, HGNode *a2@<X1>, HGNode *a3@<X2>, float a4@<S0>, HGTextureWrap **a5@<X8>)
{
  if (a2) {
    (*(void (**)(HGNode *))(*(void *)a2 + 16))(a2);
  }
  if (a3) {
    (*(void (**)(HGNode *))(*(void *)a3 + 16))(a3);
  }
  float v10 = (HGComicBilateralFilter *)HGObject::operator new(0x1B0uLL);
  HGComicBilateralFilter::HGComicBilateralFilter(v10);
  (*(void (**)(HGComicBilateralFilter *, void, HGNode *))(*(void *)v10 + 120))(v10, 0, a2);
  (*(void (**)(HGComicBilateralFilter *, uint64_t, HGNode *))(*(void *)v10 + 120))(v10, 1, a3);
  (*(void (**)(HGComicBilateralFilter *, void, float, float, double, double))(*(void *)v10 + 96))(v10, 0, 6.51 * COERCE_FLOAT(*((void *)this + 9)), 0.10846, 0.0, 0.0);
  (*(void (**)(HGComicBilateralFilter *, uint64_t, float, double, double, double))(*(void *)v10 + 96))(v10, 1, 1.0, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicBilateralFilter *, uint64_t, float, double, double, double))(*(void *)v10 + 96))(v10, 2, a4, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicBilateralFilter *))(*(void *)v10 + 16))(v10);
  float v11 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v11);
  (*(void (**)(HGTextureWrap *, void, HGComicBilateralFilter *))(*(void *)v11 + 120))(v11, 0, v10);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v11, (const char *)1, v12);
  *a5 = v11;
  (*(void (**)(HGComicBilateralFilter *))(*(void *)v10 + 24))(v10);
  uint64_t result = (*(uint64_t (**)(HGComicBilateralFilter *))(*(void *)v10 + 24))(v10);
  if (a3) {
    uint64_t result = (*(uint64_t (**)(HGNode *))(*(void *)a3 + 24))(a3);
  }
  if (a2) {
    return (*(uint64_t (**)(HGNode *))(*(void *)a2 + 24))(a2);
  }
  return result;
}

void sub_1B77A0620(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGComicImplementation::GenerateBilateralYNode@<X0>(HGComicImplementation *this@<X0>, HGNode *a2@<X1>, HGNode *a3@<X2>, HGTextureWrap **a4@<X8>)
{
  if (a2) {
    (*(void (**)(HGNode *))(*(void *)a2 + 16))(a2);
  }
  if (a3) {
    (*(void (**)(HGNode *))(*(void *)a3 + 16))(a3);
  }
  float v8 = (HGComicBilateralFilter *)HGObject::operator new(0x1B0uLL);
  HGComicBilateralFilter::HGComicBilateralFilter(v8);
  (*(void (**)(HGComicBilateralFilter *, void, HGNode *))(*(void *)v8 + 120))(v8, 0, a2);
  (*(void (**)(HGComicBilateralFilter *, uint64_t, HGNode *))(*(void *)v8 + 120))(v8, 1, a3);
  (*(void (**)(HGComicBilateralFilter *, void, float, float, double, double))(*(void *)v8 + 96))(v8, 0, *((float *)this + 19) * 6.51, 0.10846, 0.0, 0.0);
  (*(void (**)(HGComicBilateralFilter *, uint64_t, double, float, double, double))(*(void *)v8 + 96))(v8, 1, 0.0, 1.0, 0.0, 0.0);
  (*(void (**)(HGComicBilateralFilter *))(*(void *)v8 + 16))(v8);
  __n128 v9 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v9);
  (*(void (**)(HGTextureWrap *, void, HGComicBilateralFilter *))(*(void *)v9 + 120))(v9, 0, v8);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v9, (const char *)1, v10);
  *a4 = v9;
  (*(void (**)(HGComicBilateralFilter *))(*(void *)v8 + 24))(v8);
  uint64_t result = (*(uint64_t (**)(HGComicBilateralFilter *))(*(void *)v8 + 24))(v8);
  if (a3) {
    uint64_t result = (*(uint64_t (**)(HGNode *))(*(void *)a3 + 24))(a3);
  }
  if (a2) {
    return (*(uint64_t (**)(HGNode *))(*(void *)a2 + 24))(a2);
  }
  return result;
}

void sub_1B77A0A18(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGComicImplementation::GenerateQuantizeNode@<X0>(HGComicImplementation *this@<X0>, HGNode *a2@<X1>, float a3@<S0>, HGTextureWrap **a4@<X8>)
{
  float v8 = (HGComicQuantize *)HGObject::operator new(0x1A0uLL);
  HGComicQuantize::HGComicQuantize(v8);
  (*(void (**)(HGComicQuantize *, void, HGNode *))(*(void *)v8 + 120))(v8, 0, a2);
  (*(void (**)(HGComicQuantize *, void, float, double, double, double))(*(void *)v8 + 96))(v8, 0, (float)*((int *)this + 11), 0.0, 0.0, 0.0);
  (*(void (**)(HGComicQuantize *, uint64_t, float, double, double, double))(*(void *)v8 + 96))(v8, 1, a3, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicQuantize *))(*(void *)v8 + 16))(v8);
  __n128 v9 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v9);
  (*(void (**)(HGTextureWrap *, void, HGComicQuantize *))(*(void *)v9 + 120))(v9, 0, v8);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v9, (const char *)1, v10);
  *a4 = v9;
  (*(void (**)(HGComicQuantize *))(*(void *)v8 + 24))(v8);
  return (*(uint64_t (**)(HGComicQuantize *))(*(void *)v8 + 24))(v8);
}

void sub_1B77A0D1C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t HGComicImplementation::GenerateColorStrokeNode@<X0>(HGNode *a1@<X1>, HGNode *a2@<X2>, float a3@<S0>, HGTextureWrap **a4@<X8>)
{
  if (a1) {
    (*(void (**)(HGNode *))(*(void *)a1 + 16))(a1);
  }
  if (a2) {
    (*(void (**)(HGNode *))(*(void *)a2 + 16))(a2);
  }
  __n128 v9 = (HGComicColorStroke *)HGObject::operator new(0x1A0uLL);
  HGComicColorStroke::HGComicColorStroke(v9);
  (*(void (**)(HGComicColorStroke *, void, HGNode *))(*(void *)v9 + 120))(v9, 0, a1);
  (*(void (**)(HGComicColorStroke *, uint64_t, HGNode *))(*(void *)v9 + 120))(v9, 1, a2);
  (*(void (**)(HGComicColorStroke *, void, float, double, double, double))(*(void *)v9 + 96))(v9, 0, a3, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicColorStroke *))(*(void *)v9 + 16))(v9);
  float v10 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v10);
  (*(void (**)(HGTextureWrap *, void, HGComicColorStroke *))(*(void *)v10 + 120))(v10, 0, v9);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v10, (const char *)1, v11);
  *a4 = v10;
  (*(void (**)(HGComicColorStroke *))(*(void *)v9 + 24))(v9);
  uint64_t result = (*(uint64_t (**)(HGComicColorStroke *))(*(void *)v9 + 24))(v9);
  if (a2) {
    uint64_t result = (*(uint64_t (**)(HGNode *))(*(void *)a2 + 24))(a2);
  }
  if (a1) {
    return (*(uint64_t (**)(HGNode *))(*(void *)a1 + 24))(a1);
  }
  return result;
}

void sub_1B77A1050(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGComicImplementation::GenerateEdgesNode@<X0>(float32x2_t *this@<X0>, HGNode *a2@<X1>, HGNode *a3@<X2>, HGTextureWrap **a4@<X8>)
{
  if (a2) {
    (*(void (**)(HGNode *))(*(void *)a2 + 16))(a2);
  }
  float v8 = (HGComicEdges *)HGObject::operator new(0x1B0uLL);
  HGComicEdges::HGComicEdges(v8);
  (*(void (**)(HGComicEdges *, void, HGNode *))(*(void *)v8 + 120))(v8, 0, a2);
  (*(void (**)(HGComicEdges *, uint64_t, HGNode *))(*(void *)v8 + 120))(v8, 1, a3);
  float v9 = vaddv_f32(this[9]);
  if (v9 > 1.0) {
    float v9 = 1.0;
  }
  (*(void (**)(HGComicEdges *, void, float, double, double, double))(*(void *)v8 + 96))(v8, 0, this[2].f32[1] * v9, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicEdges *, uint64_t, float32_t, double, double, double))(*(void *)v8 + 96))(v8, 1, this[3].f32[0], 0.0, 0.0, 0.0);
  (*(void (**)(HGComicEdges *, uint64_t, float32_t, double, double, double))(*(void *)v8 + 96))(v8, 3, this[3].f32[1], 0.0, 0.0, 0.0);
  (*(void (**)(HGComicEdges *, uint64_t, float, double, double, double))(*(void *)v8 + 96))(v8, 2, 0.5, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicEdges *))(*(void *)v8 + 16))(v8);
  float v10 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v10);
  (*(void (**)(HGTextureWrap *, void, HGComicEdges *))(*(void *)v10 + 120))(v10, 0, v8);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v10, (const char *)1, v11);
  *a4 = v10;
  (*(void (**)(HGComicEdges *))(*(void *)v8 + 24))(v8);
  uint64_t result = (*(uint64_t (**)(HGComicEdges *))(*(void *)v8 + 24))(v8);
  if (a2) {
    return (*(uint64_t (**)(HGNode *))(*(void *)a2 + 24))(a2);
  }
  return result;
}

void sub_1B77A1468(_Unwind_Exception *a1)
{
  HGObject::operator delete(v3);
  (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t HGComicImplementation::GenerateStrokeAndBlendNode@<X0>(float32x2_t *this@<X0>, HGNode *a2@<X1>, HGNode *a3@<X2>, HGNode *a4@<X3>, HGNode *a5@<X4>, float a6@<S0>, float a7@<S1>, int a8@<W5>, HGTextureWrap **a9@<X8>)
{
  if (a2) {
    (*(void (**)(HGNode *))(*(void *)a2 + 16))(a2);
  }
  if (a3) {
    (*(void (**)(HGNode *))(*(void *)a3 + 16))(a3);
  }
  if (a4) {
    (*(void (**)(HGNode *))(*(void *)a4 + 16))(a4);
  }
  if (a5) {
    (*(void (**)(HGNode *))(*(void *)a5 + 16))(a5);
  }
  size_t v18 = (HGComicStrokeAndBlend *)HGObject::operator new(0x1C0uLL);
  HGComicStrokeAndBlend::HGComicStrokeAndBlend(v18);
  (*(void (**)(HGComicStrokeAndBlend *, void, HGNode *))(*(void *)v18 + 120))(v18, 0, a3);
  (*(void (**)(HGComicStrokeAndBlend *, uint64_t, HGNode *))(*(void *)v18 + 120))(v18, 1, a2);
  (*(void (**)(HGComicStrokeAndBlend *, uint64_t, HGNode *))(*(void *)v18 + 120))(v18, 2, a4);
  (*(void (**)(HGComicStrokeAndBlend *, uint64_t, HGNode *))(*(void *)v18 + 120))(v18, 3, a5);
  float v19 = vaddv_f32(this[9]);
  if (v19 > 1.0) {
    float v19 = 1.0;
  }
  (*(void (**)(HGComicStrokeAndBlend *, void, float, double, double, double))(*(void *)v18 + 96))(v18, 0, this[4].f32[0] * v19, 0.0, 0.0, 0.0);
  if (a8) {
    v20.n128_f32[0] = 1.0;
  }
  else {
    v20.n128_f32[0] = 0.0;
  }
  (*(void (**)(HGComicStrokeAndBlend *, uint64_t, __n128, double, double, double))(*(void *)v18 + 96))(v18, 1, v20, 0.0, 0.0, 0.0);
  if (a4) {
    v21.n128_f32[0] = 1.0;
  }
  else {
    v21.n128_f32[0] = 0.0;
  }
  (*(void (**)(HGComicStrokeAndBlend *, uint64_t, __n128, double, double, double))(*(void *)v18 + 96))(v18, 2, v21, 0.0, 0.0, 0.0);
  if (a5) {
    v22.n128_f32[0] = 1.0;
  }
  else {
    v22.n128_f32[0] = 0.0;
  }
  (*(void (**)(HGComicStrokeAndBlend *, uint64_t, __n128, double, double, double))(*(void *)v18 + 96))(v18, 4, v22, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicStrokeAndBlend *, uint64_t, float, double, double, double))(*(void *)v18 + 96))(v18, 5, a7, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicStrokeAndBlend *, uint64_t, float, double, double, double))(*(void *)v18 + 96))(v18, 6, a6, 0.0, 0.0, 0.0);
  v23.n128_u32[0] = 1.0;
  if (!this[12].i8[2]) {
    v23.n128_f32[0] = 0.0;
  }
  (*(void (**)(HGComicStrokeAndBlend *, uint64_t, __n128, double, double, double))(*(void *)v18 + 96))(v18, 3, v23, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicStrokeAndBlend *))(*(void *)v18 + 16))(v18);
  uint64_t v24 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v24);
  (*(void (**)(HGTextureWrap *, void, HGComicStrokeAndBlend *))(*(void *)v24 + 120))(v24, 0, v18);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v24, (const char *)1, v25);
  *a9 = v24;
  (*(void (**)(HGComicStrokeAndBlend *))(*(void *)v18 + 24))(v18);
  uint64_t result = (*(uint64_t (**)(HGComicStrokeAndBlend *))(*(void *)v18 + 24))(v18);
  if (a5) {
    uint64_t result = (*(uint64_t (**)(HGNode *))(*(void *)a5 + 24))(a5);
  }
  if (a4) {
    uint64_t result = (*(uint64_t (**)(HGNode *))(*(void *)a4 + 24))(a4);
  }
  if (a3) {
    uint64_t result = (*(uint64_t (**)(HGNode *))(*(void *)a3 + 24))(a3);
  }
  if (a2) {
    return (*(uint64_t (**)(HGNode *))(*(void *)a2 + 24))(a2);
  }
  return result;
}

void sub_1B77A1AB0(_Unwind_Exception *exception_object)
{
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGComicImplementation::GenerateStrokeNode@<X0>(float32x2_t *this@<X0>, HGNode *a2@<X1>, HGNode *a3@<X2>, float a4@<S0>, HGTextureWrap **a5@<X8>)
{
  if (a2) {
    (*(void (**)(HGNode *))(*(void *)a2 + 16))(a2);
  }
  if (a3) {
    (*(void (**)(HGNode *))(*(void *)a3 + 16))(a3);
  }
  float v10 = (HGComicStroke *)HGObject::operator new(0x1B0uLL);
  HGComicStroke::HGComicStroke(v10);
  (*(void (**)(HGComicStroke *, void, HGNode *))(*(void *)v10 + 120))(v10, 0, a2);
  (*(void (**)(HGComicStroke *, uint64_t, HGNode *))(*(void *)v10 + 120))(v10, 1, a3);
  float v11 = vaddv_f32(this[9]);
  if (v11 > 1.0) {
    float v11 = 1.0;
  }
  (*(void (**)(HGComicStroke *, void, float, double, double, double))(*(void *)v10 + 96))(v10, 0, this[5].f32[0] * v11, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicStroke *, uint64_t, float, double, double, double))(*(void *)v10 + 96))(v10, 3, a4, 0.0, 0.0, 0.0);
  if (a3) {
    v12.n128_f32[0] = 1.0;
  }
  else {
    v12.n128_f32[0] = 0.0;
  }
  (*(void (**)(HGComicStroke *, uint64_t, __n128, double, double, double))(*(void *)v10 + 96))(v10, 2, v12, 0.0, 0.0, 0.0);
  v13.n128_u64[0] = 0;
  if (this[12].i8[2]) {
    v13.n128_f32[0] = 1.0;
  }
  (*(void (**)(HGComicStroke *, uint64_t, __n128, double, double, double))(*(void *)v10 + 96))(v10, 1, v13, 0.0, 0.0, 0.0);
  (*(void (**)(HGComicStroke *))(*(void *)v10 + 16))(v10);
  float v14 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v14);
  (*(void (**)(HGTextureWrap *, void, HGComicStroke *))(*(void *)v14 + 120))(v14, 0, v10);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v14, (const char *)1, v15);
  *a5 = v14;
  (*(void (**)(HGComicStroke *))(*(void *)v10 + 24))(v10);
  uint64_t result = (*(uint64_t (**)(HGComicStroke *))(*(void *)v10 + 24))(v10);
  if (a3) {
    uint64_t result = (*(uint64_t (**)(HGNode *))(*(void *)a3 + 24))(a3);
  }
  if (a2) {
    return (*(uint64_t (**)(HGNode *))(*(void *)a2 + 24))(a2);
  }
  return result;
}

void sub_1B77A1FB4(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGComicImplementation::GenerateSobelGradients@<X0>(HGComicImplementation *this@<X0>, HGNode *a2@<X1>, float a3@<S0>, float a4@<S1>, int a5@<W2>, HGTextureWrap **a6@<X8>)
{
  HGComicImplementation::GenerateSobelNode(this, a2, a4, a5, (HGTextureWrap **)&v12);
  float v9 = v12;
  HGComicImplementation::GenerateGaussBlurXNode(this, v12, a3, (HGTextureWrap **)&v13);
  float v10 = v13;
  uint64_t result = HGComicImplementation::GenerateGaussBlurYAndGradNode(this, v13, a3, a6);
  if (v10) {
    uint64_t result = (*(uint64_t (**)(HGNode *))(*(void *)v10 + 24))(v10);
  }
  if (v9) {
    return (*(uint64_t (**)(HGNode *))(*(void *)v9 + 24))(v9);
  }
  return result;
}

void sub_1B77A21CC(_Unwind_Exception *exception_object)
{
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

HGXForm *HGComicImplementation::GenerateGraph(HGComicImplementation *this, HGRenderer *a2, HGNode *a3, HGNode *a4)
{
  if (a3)
  {
    (*(void (**)(HGNode *))(*(void *)a3 + 16))(a3);
    (*(void (**)(HGNode *))(*(void *)a3 + 16))(a3);
  }
  float v8 = a3;
  if (!HGRect::IsInfinite((HGRect *)((char *)this + 52)))
  {
    float v9 = (HGCrop *)HGObject::operator new(0x1A0uLL);
    HGCrop::HGCrop(v9);
    (*(void (**)(HGCrop *, void, HGNode *))(*(void *)v9 + 120))(v9, 0, a3);
    (*(void (**)(HGCrop *, void, float, float, float, float))(*(void *)v9 + 96))(v9, 0, (float)*((int *)this + 13), (float)*((int *)this + 14), (float)*((int *)this + 15), (float)*((int *)this + 16));
    float v8 = a3;
    if (v9 != (HGCrop *)a3)
    {
      if (a3) {
        (*(void (**)(HGNode *))(*(void *)a3 + 24))(a3);
      }
      float v8 = (HGNode *)v9;
      (*(void (**)(HGCrop *))(*(void *)v9 + 16))(v9);
    }
    (*(void (**)(HGCrop *))(*(void *)v9 + 24))(v9);
  }
  *(void *)&v32.int var0 = HGRenderer::GetDOD(a2, v8);
  *(void *)&v32.int var2 = v10;
  float v11 = 1.0;
  if (HGRect::IsInfinite(&v32))
  {
    int v12 = 0;
  }
  else
  {
    float v13 = *((float *)this + 3);
    int v12 = 0;
    if (v13 != 0.0)
    {
      float v14 = v13 + v13;
      float v15 = fminf((float)(v32.var2 - v32.var0), (float)(v32.var3 - v32.var1));
      if (v15 > v14)
      {
        float v16 = v14 / v15;
        if ((float)(v14 / v15) <= 0.9 && v16 != 1.0)
        {
          HGTransform::HGTransform((HGTransform *)v31);
          HGTransform::Scale((HGTransform *)v31, v16, v16, 1.0);
          size_t v18 = (HGXForm *)HGObject::operator new(0x210uLL);
          HGXForm::HGXForm(v18);
          (*(void (**)(HGXForm *, void, HGNode *))(*(void *)v18 + 120))(v18, 0, v8);
          (*(void (**)(HGXForm *, HGTextureWrap **))(*(void *)v18 + 576))(v18, v31);
          (*(void (**)(HGXForm *, uint64_t, float))(*(void *)v18 + 592))(v18, 6, 1.0);
          if (v8 != (HGNode *)v18)
          {
            if (v8) {
              (*(void (**)(HGNode *))(*(void *)v8 + 24))(v8);
            }
            float v8 = (HGNode *)v18;
            (*(void (**)(HGXForm *))(*(void *)v18 + 16))(v18);
          }
          (*(void (**)(HGXForm *))(*(void *)v18 + 24))(v18);
          HGTransform::~HGTransform((HGTransform *)v31);
          int v12 = 1;
          float v11 = v16;
        }
      }
    }
  }
  *(void *)&v30.int var0 = HGRenderer::GetDOD(a2, v8);
  *(void *)&v30.int var2 = v19;
  __n128 v20 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
  HGTextureWrap::HGTextureWrap(v20);
  (*(void (**)(HGTextureWrap *, void, HGNode *))(*(void *)v20 + 120))(v20, 0, v8);
  HGTextureWrap::SetTextureWrapMode((uint64_t)v20, (const char *)1, v21);
  switch(*((_DWORD *)this + 12))
  {
    case 0:
      HGComicImplementation::GenerateGraphStyleClassicParent((float32x2_t *)this, (HGNode *)v20, &v30, 0, 1, v31);
      goto LABEL_31;
    case 1:
    case 2:
      HGComicImplementation::GenerateGraphStylePosterParent((float32x2_t *)this, (HGNode *)v20, &v30, a4, 1, 0, v31);
      goto LABEL_31;
    case 5:
      HGComicImplementation::GenerateGraphStyleClassicParent((float32x2_t *)this, (HGNode *)v20, &v30, a4, 0, v31);
      goto LABEL_31;
    case 7:
      HGComicImplementation::GenerateGraphStylePosterParent((float32x2_t *)this, (HGNode *)v20, &v30, a4, 0, 0, v31);
      goto LABEL_31;
    case 0xA:
      HGComicImplementation::GenerateGraphStylePosterParent((float32x2_t *)this, (HGNode *)v20, &v30, 0, 0, 1, v31);
      goto LABEL_31;
    case 0x11:
    case 0x18:
      HGComicImplementation::GenerateGraphStyleInk((float32x2_t *)this, (HGNode *)v20, &v30, v31);
LABEL_31:
      uint64_t v24 = v31[0];
      if (v12) {
        goto LABEL_32;
      }
      if (v31[0])
      {
        int v25 = (HGXForm *)v31[0];
        (*(void (**)(HGTextureWrap *))(*(void *)v31[0] + 16))(v31[0]);
      }
      else
      {
        int v25 = 0;
      }
      break;
    default:
      HGLogger::error((HGLogger *)"Unsupported style detected in HGComic.  No HGComic graph generated.", v22, v23, *(void *)&v30.var0, *(void *)&v30.var2);
      uint64_t v24 = 0;
      int v25 = 0;
      if (!v12) {
        break;
      }
LABEL_32:
      HGTransform::HGTransform((HGTransform *)v31);
      HGTransform::Scale((HGTransform *)v31, (float)(1.0 / v11), (float)(1.0 / v11), 1.0);
      int v25 = (HGXForm *)HGObject::operator new(0x210uLL);
      HGXForm::HGXForm(v25);
      (*(void (**)(HGXForm *, void, HGTextureWrap *))(*(void *)v25 + 120))(v25, 0, v24);
      (*(void (**)(HGXForm *, HGTextureWrap **))(*(void *)v25 + 576))(v25, v31);
      (*(void (**)(HGXForm *))(*(void *)v25 + 16))(v25);
      (*(void (**)(HGXForm *))(*(void *)v25 + 24))(v25);
      HGTransform::~HGTransform((HGTransform *)v31);
      break;
  }
  if (!HGRect::IsInfinite((HGRect *)((char *)this + 52)))
  {
    uint64_t v26 = (HGCrop *)HGObject::operator new(0x1A0uLL);
    HGCrop::HGCrop(v26);
    (*(void (**)(HGCrop *, void, HGXForm *))(*(void *)v26 + 120))(v26, 0, v25);
    (*(void (**)(HGCrop *, void, float, float, float, float))(*(void *)v26 + 96))(v26, 0, (float)*((int *)this + 13), (float)*((int *)this + 14), (float)*((int *)this + 15), (float)*((int *)this + 16));
    if (v25 != (HGXForm *)v26)
    {
      if (v25) {
        (*(void (**)(HGXForm *))(*(void *)v25 + 24))(v25);
      }
      int v25 = (HGXForm *)v26;
      (*(void (**)(HGCrop *))(*(void *)v26 + 16))(v26);
    }
    (*(void (**)(HGCrop *))(*(void *)v26 + 24))(v26);
  }
  char v27 = (HGXForm *)*((void *)this + 13);
  if (v27 != v25)
  {
    if (v27) {
      (*(void (**)(HGXForm *))(*(void *)v27 + 24))(v27);
    }
    *((void *)this + 13) = v25;
    if (v25)
    {
      (*(void (**)(HGXForm *))(*(void *)v25 + 16))(v25);
      unint64_t v28 = (HGXForm *)*((void *)this + 13);
      goto LABEL_49;
    }
    unint64_t v28 = 0;
    if (!v24) {
      goto LABEL_51;
    }
LABEL_50:
    (*(void (**)(HGTextureWrap *))(*(void *)v24 + 24))(v24);
    goto LABEL_51;
  }
  if (v25)
  {
    unint64_t v28 = v25;
LABEL_49:
    (*(void (**)(HGXForm *))(*(void *)v25 + 24))(v25);
    if (!v24) {
      goto LABEL_51;
    }
    goto LABEL_50;
  }
  unint64_t v28 = 0;
  if (v24) {
    goto LABEL_50;
  }
LABEL_51:
  (*(void (**)(HGTextureWrap *))(*(void *)v20 + 24))(v20);
  if (v8) {
    (*(void (**)(HGNode *))(*(void *)v8 + 24))(v8);
  }
  if (a3) {
    (*(void (**)(HGNode *))(*(void *)a3 + 24))(a3);
  }
  return v28;
}

void sub_1B77A2B3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  HGObject::operator delete(v13);
  HGTransform::~HGTransform((HGTransform *)&a11);
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
  }
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
  }
  _Unwind_Resume(a1);
}

HGNode *HGComicImplementation::GenerateGraphStyleClassicParent@<X0>(float32x2_t *this@<X0>, HGNode *a2@<X1>, HGRect *a3@<X2>, HGNode *a4@<X3>, int a5@<W4>, HGLegacyBlend **a6@<X8>)
{
  float v12 = this[4].f32[1];
  BOOL IsInfinite = HGRect::IsInfinite(a3);
  float v14 = 1.0;
  if (!IsInfinite)
  {
    BOOL v15 = HGRect::IsInfinite(a3);
    float v16 = 1.0;
    if (!v15)
    {
      float v17 = this[1].f32[1];
      float v18 = 1.0;
      if (v17 != 0.0)
      {
        float v19 = fminf((float)(a3->var2 - a3->var0), (float)(a3->var3 - a3->var1));
        float v20 = v19 * 0.76;
        float v18 = v17 / v19;
        if (v20 <= v17) {
          float v18 = 0.76;
        }
      }
      if (v18 <= 0.9) {
        float v16 = v18;
      }
    }
    float v21 = this[2].f32[0];
    if (v21 == 0.0) {
      float v21 = 1.0;
    }
    float v14 = v16 * v21;
    if (v14 > 0.9) {
      float v14 = 1.0;
    }
  }
  HGComicImplementation::GenerateSobelGradients((HGComicImplementation *)this, a2, v12, v14, 1, (HGTextureWrap **)&v63);
  __n128 v22 = v63;
  long long v56 = (HGTextureWrap *)v63;
  BOOL v23 = HGRect::IsInfinite(a3);
  float v24 = 1.0;
  if (!v23)
  {
    BOOL v25 = HGRect::IsInfinite(a3);
    float v24 = 1.0;
    float v26 = 1.0;
    if (!v25)
    {
      float v27 = this[1].f32[1];
      float v28 = 1.0;
      if (v27 != 0.0)
      {
        float v29 = fminf((float)(a3->var2 - a3->var0), (float)(a3->var3 - a3->var1));
        float v30 = v29 * 0.76;
        float v28 = v27 / v29;
        if (v30 <= v27) {
          float v28 = 0.76;
        }
      }
      if (v28 <= 0.9) {
        float v26 = v28;
      }
    }
    float v31 = this[2].f32[0];
    if (v31 == 0.0) {
      float v31 = 1.0;
    }
    float v32 = v26 * v31;
    if (v32 <= 0.9) {
      float v24 = v32;
    }
  }
  HGComicImplementation::GenerateBilateralXNode((HGComicImplementation *)this, a2, v22, v24, (HGTextureWrap **)&v64);
  uint64_t v33 = v64;
  HGComicImplementation::GenerateBilateralYNode((HGComicImplementation *)this, v64, v22, (HGTextureWrap **)&v62);
  if (v33) {
    (*(void (**)(HGNode *))(*(void *)v33 + 24))(v33);
  }
  long long v34 = v62;
  int64_t v57 = v62;
  float SmallToLargeScale = HGComicImplementation::GetSmallToLargeScale((HGComicImplementation *)this, a3);
  HGComicImplementation::GenerateQuantizeNode((HGComicImplementation *)this, v34, SmallToLargeScale, (HGTextureWrap **)&v64);
  float v36 = v64;
  float LargeToSmallScale = HGComicImplementation::GetLargeToSmallScale((HGComicImplementation *)this, a3);
  HGComicImplementation::GenerateSobelGradients((HGComicImplementation *)this, v36, 2.1875, LargeToSmallScale, 0, (HGTextureWrap **)&v61);
  unsigned int v38 = v61;
  float v39 = HGComicImplementation::GetLargeToSmallScale((HGComicImplementation *)this, a3);
  HGComicImplementation::GenerateColorStrokeNode(v36, v38, v39, (HGTextureWrap **)&v60);
  unint64_t v40 = a4;
  HGComicImplementation::GenerateEdgesNode(this, v57, v22, (HGTextureWrap **)&v59);
  if (this[12].i8[0]) {
    unint64_t v41 = a2;
  }
  else {
    unint64_t v41 = 0;
  }
  float v42 = HGComicImplementation::GetLargeToSmallScale((HGComicImplementation *)this, a3);
  BOOL v43 = HGRect::IsInfinite(a3);
  float v44 = 1.0;
  if (!v43)
  {
    float v45 = this[1].f32[1];
    float v46 = 1.0;
    if (v45 != 0.0)
    {
      float v47 = fminf((float)(a3->var2 - a3->var0), (float)(a3->var3 - a3->var1));
      float v48 = v47 * 0.76;
      float v46 = v45 / v47;
      if (v48 <= v45) {
        float v46 = 0.76;
      }
    }
    if (v46 <= 0.9) {
      float v44 = v46;
    }
  }
  uint64_t v49 = a6;
  unsigned __int8 v50 = v59;
  char v51 = v60;
  HGComicImplementation::GenerateStrokeAndBlendNode(this, v60, v59, v40, v41, 1.0 / v44, v42, 0, &v58);
  if (!a5)
  {
    *uint64_t v49 = v58;
    std::string v54 = v56;
    if (!v50) {
      goto LABEL_41;
    }
    goto LABEL_40;
  }
  std::string v52 = (HGLegacyBlend *)HGObject::operator new(0x1C0uLL);
  HGLegacyBlend::HGLegacyBlend(v52);
  *uint64_t v49 = v52;
  (*(void (**)(HGLegacyBlend *, void, HGNode *))(*(void *)v52 + 120))(v52, 0, a2);
  std::string v53 = v58;
  (*(void (**)(HGLegacyBlend *, uint64_t, HGTextureWrap *))(*(void *)v52 + 120))(v52, 1, v58);
  (*(void (**)(HGLegacyBlend *, void, float, double, double, double))(*(void *)v52 + 96))(v52, 0, 8.0, 0.0, 0.0, 0.0);
  (*(void (**)(HGLegacyBlend *, uint64_t, float, double, double, double))(*(void *)v52 + 96))(v52, 1, 0.5, 0.0, 0.0, 0.0);
  std::string v54 = v56;
  if (v53) {
    (*(void (**)(HGTextureWrap *))(*(void *)v53 + 24))(v53);
  }
  if (v50) {
LABEL_40:
  }
    (*(void (**)(HGNode *))(*(void *)v50 + 24))(v50);
LABEL_41:
  if (v51) {
    (*(void (**)(HGNode *))(*(void *)v51 + 24))(v51);
  }
  if (v38) {
    (*(void (**)(HGNode *))(*(void *)v38 + 24))(v38);
  }
  if (v36) {
    (*(void (**)(HGNode *))(*(void *)v36 + 24))(v36);
  }
  uint64_t result = v57;
  if (v57) {
    uint64_t result = (HGNode *)(*(uint64_t (**)(HGNode *))(*(void *)v57 + 24))(v57);
  }
  if (v54) {
    return (HGNode *)(*(uint64_t (**)(HGTextureWrap *))(*(void *)v54 + 24))(v54);
  }
  return result;
}

void sub_1B77A3438(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  HGObject::operator delete(v16);
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 24))(a12);
  }
  if (a13) {
    (*(void (**)(uint64_t))(*(void *)a13 + 24))(a13);
  }
  if (a14) {
    (*(void (**)(uint64_t))(*(void *)a14 + 24))(a14);
  }
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 24))(v15);
  }
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);
  }
  if (a11) {
    (*(void (**)(uint64_t))(*(void *)a11 + 24))(a11);
  }
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(a1);
}

HGTextureWrap *HGComicImplementation::GenerateGraphStylePosterParent@<X0>(float32x2_t *this@<X0>, HGNode *a2@<X1>, HGRect *a3@<X2>, HGNode *a4@<X3>, int a5@<W4>, int a6@<W5>, HGLegacyBlend **a7@<X8>)
{
  float v13 = this[4].f32[1];
  BOOL IsInfinite = HGRect::IsInfinite(a3);
  float v15 = 1.0;
  if (!IsInfinite)
  {
    BOOL v16 = HGRect::IsInfinite(a3);
    float v17 = 1.0;
    if (!v16)
    {
      float v18 = this[1].f32[1];
      float v19 = 1.0;
      if (v18 != 0.0)
      {
        float v20 = fminf((float)(a3->var2 - a3->var0), (float)(a3->var3 - a3->var1));
        float v21 = v20 * 0.76;
        float v19 = v18 / v20;
        if (v21 <= v18) {
          float v19 = 0.76;
        }
      }
      if (v19 <= 0.9) {
        float v17 = v19;
      }
    }
    float v22 = this[2].f32[0];
    if (v22 == 0.0) {
      float v22 = 1.0;
    }
    float v15 = v17 * v22;
    if (v15 > 0.9) {
      float v15 = 1.0;
    }
  }
  HGComicImplementation::GenerateSobelGradients((HGComicImplementation *)this, a2, v13, v15, 1, (HGTextureWrap **)&v65);
  BOOL v23 = v65;
  BOOL v24 = HGRect::IsInfinite(a3);
  float v25 = 1.0;
  if (!v24)
  {
    BOOL v26 = HGRect::IsInfinite(a3);
    float v25 = 1.0;
    float v27 = 1.0;
    if (!v26)
    {
      float v28 = this[1].f32[1];
      float v29 = 1.0;
      if (v28 != 0.0)
      {
        float v30 = fminf((float)(a3->var2 - a3->var0), (float)(a3->var3 - a3->var1));
        float v31 = v30 * 0.76;
        float v29 = v28 / v30;
        if (v31 <= v28) {
          float v29 = 0.76;
        }
      }
      if (v29 <= 0.9) {
        float v27 = v29;
      }
    }
    float v32 = this[2].f32[0];
    if (v32 == 0.0) {
      float v32 = 1.0;
    }
    float v33 = v27 * v32;
    if (v33 <= 0.9) {
      float v25 = v33;
    }
  }
  HGComicImplementation::GenerateBilateralXNode((HGComicImplementation *)this, a2, v23, v25, (HGTextureWrap **)&v66);
  long long v34 = v66;
  HGComicImplementation::GenerateBilateralYNode((HGComicImplementation *)this, v66, v23, (HGTextureWrap **)&v64);
  if (v34) {
    (*(void (**)(HGNode *))(*(void *)v34 + 24))(v34);
  }
  uint64_t v35 = v64;
  HGComicImplementation::GenerateEdgesNode(this, v64, v23, (HGTextureWrap **)&v66);
  int64_t v57 = v23;
  float SmallToLargeScale = HGComicImplementation::GetSmallToLargeScale((HGComicImplementation *)this, a3);
  HGComicImplementation::GenerateQuantizeNode((HGComicImplementation *)this, v35, SmallToLargeScale, (HGTextureWrap **)&v63);
  std::string::size_type v37 = a4;
  unsigned int v38 = v63;
  float LargeToSmallScale = HGComicImplementation::GetLargeToSmallScale((HGComicImplementation *)this, a3);
  HGComicImplementation::GenerateSobelGradients((HGComicImplementation *)this, v38, 2.1875, LargeToSmallScale, 0, (HGTextureWrap **)&v62);
  int v40 = a6;
  unint64_t v41 = v62;
  float32x4_t v58 = (HGTextureWrap *)v62;
  float v42 = HGComicImplementation::GetLargeToSmallScale((HGComicImplementation *)this, a3);
  HGComicImplementation::GenerateColorStrokeNode(v38, v41, v42, (HGTextureWrap **)&v61);
  if (this[12].i8[0]) {
    BOOL v43 = a2;
  }
  else {
    BOOL v43 = 0;
  }
  float v44 = HGComicImplementation::GetLargeToSmallScale((HGComicImplementation *)this, a3);
  BOOL v45 = HGRect::IsInfinite(a3);
  float v46 = 1.0;
  if (!v45)
  {
    float v47 = this[1].f32[1];
    float v48 = 1.0;
    if (v47 != 0.0)
    {
      float v49 = fminf((float)(a3->var2 - a3->var0), (float)(a3->var3 - a3->var1));
      float v50 = v49 * 0.76;
      float v48 = v47 / v49;
      if (v50 <= v47) {
        float v48 = 0.76;
      }
    }
    if (v48 <= 0.9) {
      float v46 = v48;
    }
  }
  char v51 = a2;
  std::string v52 = v61;
  std::string v53 = v66;
  HGComicImplementation::GenerateStrokeAndBlendNode(this, v61, v66, v37, v43, 1.0 / v46, v44, v40, &v60);
  std::string v54 = v60;
  *a7 = v60;
  if (v54) {
    (*(void (**)(HGTextureWrap *))(*(void *)v54 + 16))(v54);
  }
  if (a5)
  {
    std::string v55 = (HGLegacyBlend *)HGObject::operator new(0x1C0uLL);
    HGLegacyBlend::HGLegacyBlend(v55);
    (*(void (**)(HGLegacyBlend *, void, HGNode *))(*(void *)v55 + 120))(v55, 0, v51);
    (*(void (**)(HGLegacyBlend *, uint64_t, HGTextureWrap *))(*(void *)v55 + 120))(v55, 1, v54);
    (*(void (**)(HGLegacyBlend *, void, float, double, double, double))(*(void *)v55 + 96))(v55, 0, 8.0, 0.0, 0.0, 0.0);
    (*(void (**)(HGLegacyBlend *, uint64_t, float, double, double, double))(*(void *)v55 + 96))(v55, 1, 0.5, 0.0, 0.0, 0.0);
    if (v54 != v55)
    {
      if (v54) {
        (*(void (**)(HGTextureWrap *))(*(void *)v54 + 24))(v54);
      }
      *a7 = v55;
      (*(void (**)(HGLegacyBlend *))(*(void *)v55 + 16))(v55);
    }
    (*(void (**)(HGLegacyBlend *))(*(void *)v55 + 24))(v55);
  }
  if (v54) {
    (*(void (**)(HGTextureWrap *))(*(void *)v54 + 24))(v54);
  }
  if (v52) {
    (*(void (**)(HGNode *))(*(void *)v52 + 24))(v52);
  }
  uint64_t result = v58;
  if (v58) {
    uint64_t result = (HGTextureWrap *)(*(uint64_t (**)(HGTextureWrap *))(*(void *)v58 + 24))(v58);
  }
  if (v38) {
    uint64_t result = (HGTextureWrap *)(*(uint64_t (**)(HGNode *))(*(void *)v38 + 24))(v38);
  }
  if (v53) {
    uint64_t result = (HGTextureWrap *)(*(uint64_t (**)(HGNode *))(*(void *)v53 + 24))(v53);
  }
  if (v35) {
    uint64_t result = (HGTextureWrap *)(*(uint64_t (**)(HGNode *))(*(void *)v35 + 24))(v35);
  }
  if (v57) {
    return (HGTextureWrap *)(*(uint64_t (**)(HGNode *))(*(void *)v57 + 24))(v57);
  }
  return result;
}

void sub_1B77A3CF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  HGObject::operator delete(v19);
  if (v18)
  {
    (*(void (**)(uint64_t))(*(void *)v18 + 24))(v18);
    (*(void (**)(uint64_t))(*(void *)v18 + 24))(v18);
  }
  if (a13) {
    (*(void (**)(uint64_t))(*(void *)a13 + 24))(a13);
  }
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  if (a15) {
    (*(void (**)(uint64_t))(*(void *)a15 + 24))(a15);
  }
  if (a18) {
    (*(void (**)(uint64_t))(*(void *)a18 + 24))(a18);
  }
  if (a16) {
    (*(void (**)(uint64_t))(*(void *)a16 + 24))(a16);
  }
  if (a17) {
    (*(void (**)(uint64_t))(*(void *)a17 + 24))(a17);
  }
  _Unwind_Resume(a1);
}

uint64_t HGComicImplementation::GenerateGraphStyleInk@<X0>(float32x2_t *this@<X0>, HGNode *a2@<X1>, HGRect *a3@<X2>, HGTextureWrap **a4@<X8>)
{
  float v9 = this[4].f32[1];
  BOOL IsInfinite = HGRect::IsInfinite(a3);
  float v11 = 1.0;
  if (!IsInfinite)
  {
    BOOL v12 = HGRect::IsInfinite(a3);
    float v13 = 1.0;
    if (!v12)
    {
      float v14 = this[1].f32[1];
      float v15 = 1.0;
      if (v14 != 0.0)
      {
        float v16 = fminf((float)(a3->var2 - a3->var0), (float)(a3->var3 - a3->var1));
        float v17 = v16 * 0.76;
        float v15 = v14 / v16;
        if (v17 <= v14) {
          float v15 = 0.76;
        }
      }
      if (v15 <= 0.9) {
        float v13 = v15;
      }
    }
    float v18 = this[2].f32[0];
    if (v18 == 0.0) {
      float v18 = 1.0;
    }
    float v11 = v13 * v18;
    if (v11 > 0.9) {
      float v11 = 1.0;
    }
  }
  HGComicImplementation::GenerateSobelGradients((HGComicImplementation *)this, a2, v9, v11, 1, (HGTextureWrap **)&v47);
  float v19 = v47;
  BOOL v20 = HGRect::IsInfinite(a3);
  float v21 = 1.0;
  if (!v20)
  {
    BOOL v22 = HGRect::IsInfinite(a3);
    float v21 = 1.0;
    float v23 = 1.0;
    if (!v22)
    {
      float v24 = this[1].f32[1];
      float v25 = 1.0;
      if (v24 != 0.0)
      {
        float v26 = fminf((float)(a3->var2 - a3->var0), (float)(a3->var3 - a3->var1));
        float v27 = v26 * 0.76;
        float v25 = v24 / v26;
        if (v27 <= v24) {
          float v25 = 0.76;
        }
      }
      if (v25 <= 0.9) {
        float v23 = v25;
      }
    }
    float v28 = this[2].f32[0];
    if (v28 == 0.0) {
      float v28 = 1.0;
    }
    float v29 = v23 * v28;
    if (v29 <= 0.9) {
      float v21 = v29;
    }
  }
  HGComicImplementation::GenerateBilateralXNode((HGComicImplementation *)this, a2, v19, v21, (HGTextureWrap **)&v48);
  float v30 = v48;
  HGComicImplementation::GenerateBilateralYNode((HGComicImplementation *)this, v48, v19, (HGTextureWrap **)&v46);
  if (v30) {
    (*(void (**)(HGNode *))(*(void *)v30 + 24))(v30);
  }
  float v31 = v46;
  HGComicImplementation::GenerateEdgesNode(this, v46, v19, (HGTextureWrap **)&v48);
  int v32 = this[12].u8[0];
  float v33 = v48;
  BOOL v34 = HGRect::IsInfinite(a3);
  float v35 = 1.0;
  if (!v34)
  {
    BOOL v36 = HGRect::IsInfinite(a3);
    float v35 = 1.0;
    float v37 = 1.0;
    if (!v36)
    {
      float v38 = this[1].f32[1];
      float v39 = 1.0;
      if (v38 != 0.0)
      {
        float v40 = fminf((float)(a3->var2 - a3->var0), (float)(a3->var3 - a3->var1));
        float v41 = v40 * 0.76;
        float v39 = v38 / v40;
        if (v41 <= v38) {
          float v39 = 0.76;
        }
      }
      if (v39 <= 0.9) {
        float v37 = v39;
      }
    }
    float v42 = this[2].f32[0];
    if (v42 == 0.0) {
      float v42 = 1.0;
    }
    float v43 = v37 * v42;
    if (v43 <= 0.9) {
      float v35 = v43;
    }
  }
  if (v32) {
    float v44 = a2;
  }
  else {
    float v44 = 0;
  }
  uint64_t result = HGComicImplementation::GenerateStrokeNode(this, v33, v44, 1.0 / v35, a4);
  if (v33) {
    uint64_t result = (*(uint64_t (**)(HGNode *))(*(void *)v33 + 24))(v33);
  }
  if (v31) {
    uint64_t result = (*(uint64_t (**)(HGNode *))(*(void *)v31 + 24))(v31);
  }
  if (v19) {
    return (*(uint64_t (**)(HGNode *))(*(void *)v19 + 24))(v19);
  }
  return result;
}

void sub_1B77A42F0(_Unwind_Exception *exception_object)
{
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

void HGComic::HGComic(HGComic *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v2 = &unk_1F10D5C70;
  uint64_t v3 = (char *)HGObject::operator new(0x70uLL);
  HGObject::HGObject((HGObject *)v3);
  *(void *)uint64_t v3 = &unk_1F10D5ED8;
  *(_OWORD *)(v3 + 12) = 0u;
  *(_OWORD *)(v3 + 28) = 0u;
  *(_OWORD *)(v3 + 44) = xmmword_1B8345E70;
  *(void *)(v3 + 6CVOpenGLESTextureCacheFlush(this[3], 0) = 0x8000000080000000;
  __asm { FMOV            V0.2S, #1.0 }
  *((void *)v3 + 9) = _D0;
  *((int32x2_t *)v3 + 1CVOpenGLESTextureCacheFlush(this[3], 0) = vdup_n_s32(0x3D4CCCCDu);
  *((void *)v3 + 11) = _D0;
  *((_WORD *)v3 + 48) = 256;
  v3[98] = 1;
  *((void *)v3 + 13) = 0;
  *((void *)this + 51) = v3;
}

void sub_1B77A449C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B77A44B8(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGComic::~HGComic(HGNode *this)
{
  *(void *)this = &unk_1F10D5C70;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10D5C70;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGComic::SetParameter(HGComic *this, int a2, float a3, float32_t a4, float a5, float a6, uint64_t a7, const char *a8, char *a9)
{
  switch(a2)
  {
    case 0:
      uint64_t v11 = *((void *)this + 51);
      if (*(float *)(v11 + 12) == a3) {
        return 0;
      }
      *(float *)(v11 + 12) = ceilf(a3);
      return 1;
    case 1:
      uint64_t v14 = *((void *)this + 51);
      if (*(float *)(v14 + 16) == a3) {
        return 0;
      }
      *(float *)(v14 + 16) = a3;
      return 1;
    case 2:
      uint64_t v15 = *((void *)this + 51);
      if (*(float *)(v15 + 20) == a3) {
        return 0;
      }
      *(float *)(v15 + 2CVOpenGLESTextureCacheFlush(this[3], 0) = a3;
      return 1;
    case 3:
      uint64_t v16 = *((void *)this + 51);
      if (*(float *)(v16 + 24) == a3) {
        return 0;
      }
      *(float *)(v16 + 24) = a3;
      return 1;
    case 4:
      uint64_t v17 = *((void *)this + 51);
      if (*(float *)(v17 + 28) == a3) {
        return 0;
      }
      *(float *)(v17 + 28) = a3;
      return 1;
    case 5:
      uint64_t v18 = *((void *)this + 51);
      if (*(float *)(v18 + 32) == a3) {
        return 0;
      }
      *(float *)(v18 + 32) = a3;
      return 1;
    case 6:
      uint64_t v19 = *((void *)this + 51);
      if (*(float *)(v19 + 36) == a3) {
        return 0;
      }
      *(float *)(v19 + 36) = a3;
      return 1;
    case 7:
      uint64_t v20 = *((void *)this + 51);
      if (*(float *)(v20 + 40) == a3) {
        return 0;
      }
      *(float *)(v20 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = a3;
      return 1;
    case 8:
      uint64_t v21 = *((void *)this + 51);
      if ((float)*(int *)(v21 + 44) == a3) {
        return 0;
      }
      *(_DWORD *)(v21 + 44) = (int)a3;
      return 1;
    case 9:
      uint64_t v22 = *((void *)this + 51);
      if (*(_DWORD *)(v22 + 48) == (int)a3) {
        return 0;
      }
      *(_DWORD *)(v22 + 48) = (int)a3;
      return 1;
    case 10:
      uint64_t v23 = *((void *)this + 51);
      int v25 = *(_DWORD *)(v23 + 52);
      int v24 = *(_DWORD *)(v23 + 56);
      uint64_t v26 = *(void *)(v23 + 60);
      uint64_t v27 = HGRectMake4i((int)a3, (int)a4, (int)a5, (int)a6);
      if (v27 == v25 && v28 == v26 && HIDWORD(v27) == v24 && HIDWORD(v28) == HIDWORD(v26)) {
        return 0;
      }
      uint64_t v32 = *((void *)this + 51);
      *(void *)(v32 + 52) = v27;
      *(void *)(v32 + 6CVOpenGLESTextureCacheFlush(this[3], 0) = v28;
      return 1;
    case 11:
      float v33 = (float32x2_t *)*((void *)this + 51);
      if (COERCE_FLOAT(*(void *)&v33[9]) == a3 && COERCE_FLOAT(HIDWORD(*(void *)&v33[9])) == a4) {
        return 0;
      }
      v35.f32[0] = a3;
      if (COERCE_FLOAT(*(void *)&v33[10]) > a3)
      {
        unsigned __int8 v36 = atomic_load(HGLogger::_enabled);
        if (v36)
        {
          float v42 = a4;
          HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"proxy scale x value out of bounds :%f, clamped to minimum: %f\n", a8, a9, a3, COERCE_FLOAT(*(void *)&v33[10]));
          a4 = v42;
          v35.f32[0] = a3;
        }
      }
      if (v33[10].f32[1] > a4)
      {
        unsigned __int8 v37 = atomic_load(HGLogger::_enabled);
        if (v37)
        {
          float v43 = a4;
          __int32 v46 = v35.i32[0];
          HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"proxy scale y value out of bounds :%f, clamped to minimum: %f\n", a8, a9, a4, v33[10].f32[1]);
          a4 = v43;
          v35.i32[0] = v46;
        }
      }
      v35.f32[1] = a4;
      if (COERCE_FLOAT(*(void *)&v33[11]) < a3)
      {
        unsigned __int8 v38 = atomic_load(HGLogger::_enabled);
        if (v38)
        {
          float v44 = a4;
          float32x2_t v47 = v35;
          HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"proxy scale x value out of bounds :%f, clamped to maximum: %f\n", a8, a9, a3, COERCE_FLOAT(*(void *)&v33[11]));
          a4 = v44;
          float32x2_t v35 = v47;
        }
      }
      if (v33[11].f32[1] < a4)
      {
        unsigned __int8 v39 = atomic_load(HGLogger::_enabled);
        if (v39)
        {
          float32x2_t v48 = v35;
          HGLogger::log((HGLogger *)"gpu", (const char *)2, (HGLogger *)"proxy scale y value out of bounds :%f, clamped to maximum: %f\n", a8, a9, a4, v33[11].f32[1]);
          float32x2_t v35 = v48;
        }
      }
      v33[9] = vminnm_f32(vmaxnm_f32(v35, v33[10]), v33[11]);
      return 1;
    case 12:
      uint64_t v40 = *((void *)this + 51);
      if ((a3 == 1.0) == (*(unsigned char *)(v40 + 96) != 0)) {
        return 0;
      }
      *(unsigned char *)(v40 + 96) = a3 == 1.0;
      return 1;
    case 13:
      uint64_t v41 = *((void *)this + 51);
      if ((a3 == 1.0) == (*(unsigned char *)(v41 + 97) != 0)) {
        return 0;
      }
      *(unsigned char *)(v41 + 97) = a3 == 1.0;
      return 1;
    case 14:
      uint64_t v12 = *((void *)this + 51);
      if ((a3 == 1.0) == (*(unsigned char *)(v12 + 98) != 0)) {
        return 0;
      }
      *(unsigned char *)(v12 + 98) = a3 == 1.0;
      return 1;
    default:
      return 0xFFFFFFFFLL;
  }
}

HGXForm *HGComic::GetOutput(HGNode *this, HGRenderer *a2)
{
  Input = HGRenderer::GetInput(a2, this, 0);
  if (!Input) {
    return (HGXForm *)Input;
  }
  float v5 = HGRenderer::GetInput(a2, this, 1u);
  if (((*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2) & 1) == 0
    && !(*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 43))
  {
    HGLogger::warning((HGLogger *)"No GLES support in HGComic - use Metal on iOS", v6, v7);
    return (HGXForm *)Input;
  }
  float v8 = (HGComicImplementation *)*((void *)this + 51);

  return HGComicImplementation::GenerateGraph(v8, a2, Input, v5);
}

void HGComicImplementation::~HGComicImplementation(HGComicImplementation *this)
{
  *(void *)this = &unk_1F10D5ED8;
  uint64_t v2 = *((void *)this + 13);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGObject::~HGObject(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10D5ED8;
  uint64_t v2 = *((void *)this + 13);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGObject::~HGObject(this);

  HGObject::operator delete(v3);
}

void HG_RENDERER_ENV::HG_RENDERER_ENV(HG_RENDERER_ENV *this)
{
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  __n128 v164 = (void *)((char *)this + 24);
  *(_OWORD *)this = 0u;
  HGLogger::setLevel((HGLogger *)"envInit", 0);
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v185, "envInit", 1, "HG_RENDERER_ENV::HG_RENDERER_ENV()");
  uint64_t v2 = getenv("HG_ENABLE_LOGGER");
  if (v2) {
    atomic_store(atoi(v2) != 0, HGLogger::_enabled);
  }
  uint64_t v3 = getenv("HG_ENV_NO_FLUSH_OPT");
  if (v3) {
    HG_RENDERER_ENV::NO_FLUSH_OPT = atoi(v3);
  }
  float v4 = getenv("HG_ENV_LOW_MEMORY_USAGE");
  if (v4) {
    HG_RENDERER_ENV::LOW_MEMORY_USAGE = atoi(v4);
  }
  float v5 = getenv("HG_ENV_TRACK_TEXTURE_USAGE");
  if (v5) {
    HG_RENDERER_ENV::TRACK_TEXTURE_USAGE = atoi(v5);
  }
  float v6 = getenv("HG_ENV_VALIDATE_CURRENT_GL_CONTEXT");
  if (v6) {
    HG_RENDERER_ENV::VALIDATE_CURRENT_GL_CONTEXT = atoi(v6);
  }
  if (getenv("HG_ENV_USE_V210_BGRA_FORMAT")) {
    HGLogger::warning((HGLogger *)"HG_ENV_USE_V210_BGRA_FORMAT is deprecated.", v7, v8);
  }
  float v9 = getenv("HG_ENV_SCISSORED_LARGE_TRI_TILES");
  if (v9) {
    HG_RENDERER_ENV::SCISSORED_LARGE_TRI_TILES = atoi(v9);
  }
  uint64_t v10 = getenv("HG_ENV_SCISSORED_LARGE_TRI_TILES_WIDTH");
  if (v10) {
    HG_RENDERER_ENV::SCISSORED_LARGE_TRI_TILES_WIDTH = atoi(v10);
  }
  uint64_t v11 = getenv("HG_ENV_FORCE_PAGE_SIZE");
  if (v11) {
    HG_RENDERER_ENV::FORCE_PAGE_SIZE = atoi(v11);
  }
  uint64_t v12 = getenv("HG_ENV_FORCE_NO_PBO_READBACK");
  if (v12) {
    HG_RENDERER_ENV::FORCE_NO_PBO_READBACK = atoi(v12);
  }
  if (getenv("HG_ENV_FORCE_INTERLEAVED_RENDER_READBACK")) {
    HGLogger::warning((HGLogger *)"HG_ENV_FORCE_INTERLEAVED_RENDER_READBACK is deprecated.", v13, v14);
  }
  uint64_t v15 = getenv("HG_ENV_FORCE_TEXTURE_STORAGE_HINT");
  if (v15)
  {
    uint64_t v16 = v15;
    size_t v17 = strlen(v15);
    if (v17 > 0x7FFFFFFFFFFFFFF7) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    size_t v20 = v17;
    if (v17 >= 0x17)
    {
      uint64_t v22 = (v17 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v17 | 7) != 0x17) {
        uint64_t v22 = v17 | 7;
      }
      uint64_t v23 = v22 + 1;
      p_dst = (void **)operator new(v22 + 1);
      size_t v183 = v20;
      int64_t v184 = v23 | 0x8000000000000000;
      std::string __dst = p_dst;
    }
    else
    {
      HIBYTE(v184) = v17;
      p_dst = (void **)&__dst;
      if (!v17)
      {
LABEL_32:
        *((unsigned char *)p_dst + v2CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
        char v181 = 7;
        strcpy((char *)__c, "PRIVATE");
        char v177 = 6;
        strcpy(v175, "CACHED");
        char v174 = 6;
        strcpy(v172, "SHARED");
        if (v184 >= 0) {
          int v24 = (void **)&__dst;
        }
        else {
          int v24 = __dst;
        }
        int v25 = v24;
        if (v184 >= 0) {
          uint64_t v26 = HIBYTE(v184);
        }
        else {
          uint64_t v26 = v183;
        }
        uint64_t v27 = (char *)v24 + v26;
        if (v26 > 6)
        {
          uint64_t v28 = v26;
          float v29 = v24;
          do
          {
            float v30 = (char *)memchr(v29, SLOBYTE(__c[0]), v28 - 6);
            if (!v30) {
              break;
            }
            if (*(_DWORD *)v30 == __c[0] && *(_DWORD *)(v30 + 3) == *(int *)((char *)__c + 3))
            {
              if (v30 != v27 && v30 - (char *)v24 != -1)
              {
                int v32 = 0;
                goto LABEL_72;
              }
              break;
            }
            float v29 = (void **)(v30 + 1);
            uint64_t v28 = v27 - (char *)v29;
          }
          while (v27 - (char *)v29 > 6);
        }
        if (v26 >= 6)
        {
          uint64_t v33 = v26;
          BOOL v34 = v24;
          while (1)
          {
            float32x2_t v35 = (char *)memchr(v34, v175[0], v33 - 5);
            if (!v35) {
              goto LABEL_62;
            }
            if (*(_DWORD *)v35 == *(_DWORD *)v175 && *((unsigned __int16 *)v35 + 2) == *(unsigned __int16 *)&v175[4]) {
              break;
            }
            BOOL v34 = (void **)(v35 + 1);
            uint64_t v33 = v27 - (char *)v34;
            if (v27 - (char *)v34 < 6) {
              goto LABEL_62;
            }
          }
          if (v35 != v27 && v35 - (char *)v24 != -1)
          {
            int v32 = 1;
LABEL_72:
            HG_RENDERER_ENV::FORCE_TEXTURE_STORAGE_HINT = v32;
            goto LABEL_74;
          }
LABEL_62:
          do
          {
            unsigned __int8 v37 = (char *)memchr(v25, v172[0], v26 - 5);
            if (!v37) {
              break;
            }
            if (*(_DWORD *)v37 == *(_DWORD *)v172 && *((unsigned __int16 *)v37 + 2) == *(unsigned __int16 *)&v172[4])
            {
              if (v37 != v27 && v37 - (char *)v24 != -1)
              {
                int v32 = 2;
                goto LABEL_72;
              }
              break;
            }
            int v25 = (void **)(v37 + 1);
            uint64_t v26 = v27 - (v37 + 1);
          }
          while (v26 >= 6);
        }
        HGLogger::warning((HGLogger *)"invalid FORCE_TEXTURE_STORAGE_HINT value", v18, v19);
LABEL_74:
        if (SHIBYTE(v184) < 0) {
          operator delete(__dst);
        }
        goto LABEL_76;
      }
    }
    memmove(p_dst, v16, v20);
    goto LABEL_32;
  }
LABEL_76:
  unsigned __int8 v39 = getenv("HG_ENV_FORCE_FULLSIZE_TEXTURE_UPLOAD");
  if (v39) {
    HG_RENDERER_ENV::FORCE_FULLSIZE_TEXTURE_UPLOAD = atoi(v39);
  }
  uint64_t v40 = getenv("HG_ENV_METAL_BLIT_MAX_TILE_SIZE_MB");
  if (v40) {
    HG_RENDERER_ENV::METAL_BLIT_MAX_TILE_SIZE_MB = atoi(v40);
  }
  uint64_t v41 = getenv("HG_ENV_WAIT_FOR_QUEUED_TEXTURE_ONE_BY_ONE");
  if (v41) {
    HG_RENDERER_ENV::WAIT_FOR_QUEUED_TEXTURE_ONE_BY_ONE = atoi(v41);
  }
  float v42 = getenv("HG_ENV_METAL_MAX_ENCODERS_PER_BUFFER");
  if (v42) {
    HG_RENDERER_ENV::METAL_MAX_ENCODERS_PER_BUFFER = atoi(v42);
  }
  float v43 = getenv("HG_ENV_METAL_MAX_COMMAND_BUFFERS_COUNT");
  if (v43) {
    HG_RENDERER_ENV::METAL_MAX_COMMAND_BUFFERS_COUNT = atoi(v43);
  }
  float v44 = getenv("HG_ENV_METAL_MAX_COMMAND_BUFFERS_MEMORY");
  if (v44) {
    HG_RENDERER_ENV::METAL_MAX_COMMAND_BUFFERS_MEMORY = atoi(v44);
  }
  BOOL v45 = getenv("HG_ENV_FORCE_CLUSTERED_TEXTURE_PADDING");
  if (v45) {
    HG_RENDERER_ENV::FORCE_CLUSTERED_TEXTURE_PADDING = atoi(v45);
  }
  __int32 v46 = getenv("HG_ENV_TEX_PADDING_REMEMBRANCE");
  if (v46) {
    HG_RENDERER_ENV::TEX_PADDING_REMEMBRANCE = atoi(v46);
  }
  float32x2_t v47 = getenv("HG_ENV_TEX_PADDING_CUSHIONING");
  if (v47) {
    HG_RENDERER_ENV::TEX_PADDING_CUSHIONING = atoi(v47);
  }
  float32x2_t v48 = getenv("HG_ENV_TEX_PADDING_CLUMPING");
  if (v48) {
    HG_RENDERER_ENV::TEX_PADDING_CLUMPING = atoi(v48);
  }
  float v49 = getenv("HG_ENV_FORCE_LEGACY_TEXTURE_POOLING");
  if (v49) {
    HG_RENDERER_ENV::FORCE_LEGACY_TEXTURE_POOLING = atoi(v49);
  }
  float v50 = getenv("HG_ENV_TEXTURE_POOL_STRATEGY");
  if (!v50) {
    goto LABEL_176;
  }
  char v51 = v50;
  size_t v52 = strlen(v50);
  if (v52 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v53 = v52;
  if (v52 >= 0x17)
  {
    uint64_t v55 = (v52 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v52 | 7) != 0x17) {
      uint64_t v55 = v52 | 7;
    }
    uint64_t v56 = v55 + 1;
    std::string v54 = (void **)operator new(v55 + 1);
    size_t v183 = v53;
    int64_t v184 = v56 | 0x8000000000000000;
    std::string __dst = v54;
    goto LABEL_106;
  }
  HIBYTE(v184) = v52;
  std::string v54 = (void **)&__dst;
  if (v52) {
LABEL_106:
  }
    memmove(v54, v51, v53);
  *((unsigned char *)v54 + v53) = 0;
  char v181 = 10;
  unsigned __int16 v179 = 22862;
  *(void *)__c = *(void *)"OLDEST_ANY";
  char v177 = 21;
  qmemcpy(v175, "OLDEST_CLIENT_STORAGE", sizeof(v175));
  char v174 = 19;
  qmemcpy(v172, "OLDEST_INTERMEDIATE", sizeof(v172));
  char v171 = 18;
  unsigned __int16 v169 = 17735;
  long long v168 = *(_OWORD *)"ALL_CLIENT_STORAGE";
  char v167 = 16;
  if (v184 >= 0) {
    int64_t v57 = (void **)&__dst;
  }
  else {
    int64_t v57 = __dst;
  }
  char v180 = 0;
  char v176 = 0;
  char v173 = 0;
  char v170 = 0;
  *(_OWORD *)std::string __p = *(_OWORD *)"ALL_INTERMEDIATE";
  if (v184 >= 0) {
    uint64_t v58 = HIBYTE(v184);
  }
  else {
    uint64_t v58 = v183;
  }
  char v166 = 0;
  if (v58 >= 10)
  {
    int32x4_t v59 = (char *)v57 + v58;
    uint64_t v60 = v58;
    unint64_t v61 = v57;
    do
    {
      int32x2_t v62 = (char *)memchr(v61, 79, v60 - 9);
      if (!v62) {
        break;
      }
      if (*(void *)v62 == *(void *)__c && *((unsigned __int16 *)v62 + 4) == (unint64_t)v179)
      {
        if (v62 != v59 && v62 - (char *)v57 != -1)
        {
          int v64 = 0;
          goto LABEL_172;
        }
        break;
      }
      unint64_t v61 = (void **)(v62 + 1);
      uint64_t v60 = v59 - (char *)v61;
    }
    while (v59 - (char *)v61 >= 10);
    if (v58 >= 21)
    {
      uint64_t v65 = v58;
      float32x2_t v66 = v57;
      do
      {
        long long v67 = (char *)memchr(v66, 79, v65 - 20);
        if (!v67) {
          break;
        }
        if (*(void *)v67 == *(void *)v175
          && *((void *)v67 + 1) == *(void *)&v175[8]
          && *(void *)(v67 + 13) == *(void *)&v175[13])
        {
          if (v67 != v59 && v67 - (char *)v57 != -1)
          {
            int v64 = 1;
            goto LABEL_172;
          }
          break;
        }
        float32x2_t v66 = (void **)(v67 + 1);
        uint64_t v65 = v59 - (char *)v66;
      }
      while (v59 - (char *)v66 >= 21);
    }
    if (v58 > 18)
    {
      uint64_t v70 = v58;
      float32x4_t v71 = v57;
      do
      {
        int32x4_t v72 = (char *)memchr(v71, 79, v70 - 18);
        if (!v72) {
          break;
        }
        if (*(void *)v72 == *(void *)v172
          && *((void *)v72 + 1) == *(void *)&v172[8]
          && *(void *)(v72 + 11) == *(void *)&v172[11])
        {
          if (v72 != v59 && v72 - (char *)v57 != -1)
          {
            int v64 = 2;
            goto LABEL_172;
          }
          break;
        }
        float32x4_t v71 = (void **)(v72 + 1);
        uint64_t v70 = v59 - (char *)v71;
      }
      while (v59 - (char *)v71 > 18);
    }
    if (v58 >= 18)
    {
      float32x4_t v75 = v57;
      do
      {
        float32x4_t v76 = (char *)memchr(v75, 65, v58 - 17);
        if (!v76) {
          break;
        }
        if (*(void *)v76 == (void)v168
          && *((void *)v76 + 1) == *((void *)&v168 + 1)
          && *((unsigned __int16 *)v76 + 8) == (unint64_t)v169)
        {
          if (v76 != v59 && v76 - (char *)v57 != -1)
          {
            int v64 = 3;
            goto LABEL_172;
          }
          break;
        }
        float32x4_t v75 = (void **)(v76 + 1);
        uint64_t v58 = v59 - (char *)v75;
      }
      while (v59 - (char *)v75 >= 18);
    }
  }
  if (std::string::find[abi:ne180100]((uint64_t *)&__dst, (char *)__p, 0) == -1)
  {
    HGLogger::warning((HGLogger *)"invalid TEXTURE_POOL_STRATEGY value", v79, v80);
  }
  else
  {
    int v64 = 4;
LABEL_172:
    HG_RENDERER_ENV::TEXTURE_POOL_STRATEGY = v64;
  }
  if (v167 < 0)
  {
    operator delete(__p[0]);
    if (SHIBYTE(v184) < 0) {
      goto LABEL_327;
    }
LABEL_176:
    float32x4_t v81 = getenv("HG_ENV_MAX_TEXTURE_AGE_MS");
    float32x4_t v82 = &unk_1E9EDE000;
    if (!v81) {
      goto LABEL_178;
    }
    goto LABEL_177;
  }
  if ((SHIBYTE(v184) & 0x80000000) == 0) {
    goto LABEL_176;
  }
LABEL_327:
  operator delete(__dst);
  float32x4_t v81 = getenv("HG_ENV_MAX_TEXTURE_AGE_MS");
  float32x4_t v82 = (_DWORD *)&unk_1E9EDE000;
  if (v81) {
LABEL_177:
  }
    v82[774] = atoi(v81);
LABEL_178:
  float32x4_t v83 = getenv("HG_ENV_MAX_TEXTURE_POOL_SIZE_PERCENT");
  if (v83) {
    HG_RENDERER_ENV::MAX_TEXTURE_POOL_SIZE_PERCENT = atoi(v83);
  }
  int32x4_t v84 = getenv("HG_ENV_MAX_TEXTURE_QUEUE_SIZE_PERCENT");
  if (v84) {
    HG_RENDERER_ENV::MAX_TEXTURE_QUEUE_SIZE_PERCENT = atoi(v84);
  }
  float32x4_t v85 = getenv("HG_ENV_MAX_TEXTURE_UNUSED_SIZE_PERCENT");
  if (v85) {
    HG_RENDERER_ENV::MAX_TEXTURE_UNUSED_SIZE_PERCENT = atoi(v85);
  }
  float32x4_t v86 = getenv("HG_ENV_MAX_TEXTURE_TOTAL_SIZE_PERCENT");
  if (v86) {
    HG_RENDERER_ENV::MAX_TEXTURE_TOTAL_SIZE_PERCENT = atoi(v86);
  }
  float32x4_t v87 = getenv("HG_ENV_IGNORE_LOADER_CHECK_FOR_CVCACHE");
  if (v87) {
    HG_RENDERER_ENV::IGNORE_LOADER_CHECK_FOR_CVCACHE = atoi(v87);
  }
  int32x4_t v88 = getenv("HG_ENV_METAL_UPLOAD_TEXTURE_CREATION_STRATEGY");
  if (v88) {
    HG_RENDERER_ENV::METAL_UPLOAD_TEXTURE_CREATION_STRATEGY = atoi(v88);
  }
  float32x4_t v89 = getenv("HG_ENV_CLIENT_STORAGE_RECYCLING_POLICY");
  if (v89) {
    HG_RENDERER_ENV::CLIENT_STORAGE_RECYCLING_POLICY = atoi(v89);
  }
  float32x4_t v90 = getenv("HG_ENV_FORCE_RECYCLE_SHARED_TEXTURES");
  if (v90) {
    HG_RENDERER_ENV::FORCE_RECYCLE_SHARED_TEXTURES = atoi(v90);
  }
  int32x4_t v91 = getenv("HG_ENV_LOAD_TEXTURE_TILE_ALIGNMENT");
  if (v91) {
    HG_RENDERER_ENV::LOAD_TEXTURE_TILE_ALIGNMENT = atoi(v91);
  }
  uint64_t v92 = getenv("HG_ENV_FORCE_POST_RENDER_FINISH");
  if (v92) {
    HG_RENDERER_ENV::FORCE_POST_RENDER_FINISH = atoi(v92);
  }
  float32x4_t v93 = getenv("HG_ENV_FORCE_POST_READPIXELS_FINISH");
  if (v93) {
    HG_RENDERER_ENV::FORCE_POST_READPIXELS_FINISH = atoi(v93);
  }
  int8x16_t v94 = getenv("HG_ENV_FORCE_POST_READPIXELS_FENCE");
  if (v94) {
    HG_RENDERER_ENV::FORCE_POST_READPIXELS_FENCE = atoi(v94);
  }
  int v95 = getenv("HG_ENV_FORCE_DEFAULT_METAL_DEVICE");
  if (v95) {
    HG_RENDERER_ENV::FORCE_DEFAULT_METAL_DEVICE = atoi(v95);
  }
  float32x4_t v96 = getenv("HG_ENV_FORCE_NATIVE_TEXTURE_OUTPUT");
  if (v96) {
    HG_RENDERER_ENV::FORCE_NATIVE_TEXTURE_OUTPUT = atoi(v96);
  }
  int v97 = getenv("HG_ENV_LOG_LEVEL_INIT");
  if (v97) {
    HG_RENDERER_ENV::LOG_LEVEL_INIT = atoi(v97);
  }
  uint64_t v98 = getenv("HG_ENV_LOG_LEVEL_TEXMANAGER");
  if (v98) {
    HG_RENDERER_ENV::LOG_LEVEL_TEXMANAGER = atoi(v98);
  }
  uint64_t v99 = getenv("HG_ENV_LOG_LEVEL_GRAPH_DUMP");
  if (v99) {
    HG_RENDERER_ENV::LOG_LEVEL_GRAPH_DUMP = atoi(v99);
  }
  int32x2_t v100 = getenv("HG_ENV_LOG_LEVEL_GPU_TRACE");
  if (v100) {
    HG_RENDERER_ENV::LOG_LEVEL_GPU_TRACE = atoi(v100);
  }
  __int32 v101 = getenv("HG_ENV_LOG_LEVEL_GL_TRACE");
  if (v101)
  {
    float32x4_t v104 = v101;
    HGLogger::warning((HGLogger *)"HG_ENV_LOG_LEVEL_GL_TRACE is deprecated. Use HG_ENV_LOG_LEVEL_GPU_TRACE.", v102, v103);
    HG_RENDERER_ENV::LOG_LEVEL_GPU_TRACE = atoi(v104);
  }
  float32x4_t v105 = getenv("HG_ENV_FORCE_SINGLE_DOT_FILE");
  if (v105) {
    HG_RENDERER_ENV::FORCE_SINGLE_DOT_FILE = atoi(v105);
  }
  float32x4_t v106 = getenv("HG_ENV_DOT_GRAPH_OUTPUT_DIR");
  if (v106) {
    MEMORY[0x1BA9BF660](this, v106);
  }
  float32x4_t v107 = getenv("HG_ENV_BUFFER_DUMP_DIR");
  if (v107) {
    MEMORY[0x1BA9BF660](v164, v107);
  }
  float32x4_t v108 = getenv("HG_ENV_LOG_LEVEL_COLORCONFORM_DUMP");
  if (v108) {
    HG_RENDERER_ENV::LOG_LEVEL_COLORCONFORM_DUMP = atoi(v108);
  }
  float32x4_t v109 = getenv("HG_ENV_LOG_LEVEL_MTL_PERF_VALIDATION");
  if (v109) {
    HG_RENDERER_ENV::LOG_LEVEL_MTL_PERF_VALIDATION = atoi(v109);
  }
  float32x4_t v110 = getenv("SENSO_GENERAL_LOGLEVEL");
  if (v110)
  {
    char v111 = (const char *)strtol(v110, 0, 0);
    uint64_t v112 = getenv("SENSO_PERFORMANCE_LOGLEVEL");
    if (v112) {
      goto LABEL_228;
    }
LABEL_231:
    char v115 = 0;
    unsigned __int8 v117 = atomic_load(HGLogger::_enabled);
    if ((v117 & 1) == 0) {
      goto LABEL_233;
    }
    goto LABEL_232;
  }
  char v111 = 0;
  uint64_t v112 = getenv("SENSO_PERFORMANCE_LOGLEVEL");
  if (!v112) {
    goto LABEL_231;
  }
LABEL_228:
  char v115 = (const char *)strtol(v112, 0, 0);
  unsigned __int8 v116 = atomic_load(HGLogger::_enabled);
  if (v116) {
LABEL_232:
  }
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  NO_FLUSH_OPT                  : %d\n", v113, v114, HG_RENDERER_ENV::NO_FLUSH_OPT);
LABEL_233:
  unsigned __int8 v118 = atomic_load(HGLogger::_enabled);
  if (v118) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  LOW_MEMORY_USAGE              : %d\n", v113, v114, HG_RENDERER_ENV::LOW_MEMORY_USAGE);
  }
  unsigned __int8 v119 = atomic_load(HGLogger::_enabled);
  if (v119) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  TRACK_TEXTURE_USAGE           : %d\n", v113, v114, HG_RENDERER_ENV::TRACK_TEXTURE_USAGE);
  }
  unsigned __int8 v120 = atomic_load(HGLogger::_enabled);
  if (v120) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  VALIDATE_CURRENT_GL_CONTEXT   : %d\n", v113, v114, HG_RENDERER_ENV::VALIDATE_CURRENT_GL_CONTEXT);
  }
  unsigned __int8 v121 = atomic_load(HGLogger::_enabled);
  if (v121) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  SCISSORED_LARGE_TRI_TILES     : %d\n", v113, v114, HG_RENDERER_ENV::SCISSORED_LARGE_TRI_TILES);
  }
  unsigned __int8 v122 = atomic_load(HGLogger::_enabled);
  if (v122) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  SCISSORED_LARGE_TRI_TILES_WIDTH : %d\n", v113, v114, HG_RENDERER_ENV::SCISSORED_LARGE_TRI_TILES_WIDTH);
  }
  unsigned __int8 v123 = atomic_load(HGLogger::_enabled);
  if (v123) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_PAGE_SIZE               : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_PAGE_SIZE);
  }
  unsigned __int8 v124 = atomic_load(HGLogger::_enabled);
  if (v124) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_NO_PBO_READBACK         : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_NO_PBO_READBACK);
  }
  unsigned __int8 v125 = atomic_load(HGLogger::_enabled);
  if (v125) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_TEXTURE_STORAGE_HINT    : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_TEXTURE_STORAGE_HINT);
  }
  unsigned __int8 v126 = atomic_load(HGLogger::_enabled);
  if (v126) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_FULLSIZE_TEXTURE_UPLOAD : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_FULLSIZE_TEXTURE_UPLOAD);
  }
  unsigned __int8 v127 = atomic_load(HGLogger::_enabled);
  if (v127) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  METAL_BLIT_MAX_TILE_SIZE_MB   : %d\n", v113, v114, HG_RENDERER_ENV::METAL_BLIT_MAX_TILE_SIZE_MB);
  }
  unsigned __int8 v128 = atomic_load(HGLogger::_enabled);
  if (v128) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  WAIT_FOR_QUEUED_TEXTURE_ONE_BY_ONE : %d\n", v113, v114, HG_RENDERER_ENV::WAIT_FOR_QUEUED_TEXTURE_ONE_BY_ONE);
  }
  unsigned __int8 v129 = atomic_load(HGLogger::_enabled);
  if (v129) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  METAL_MAX_ENCODERS_PER_BUFFER : %d\n", v113, v114, HG_RENDERER_ENV::METAL_MAX_ENCODERS_PER_BUFFER);
  }
  unsigned __int8 v130 = atomic_load(HGLogger::_enabled);
  if (v130) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  METAL_MAX_COMMAND_BUFFERS_COUNT : %d\n", v113, v114, HG_RENDERER_ENV::METAL_MAX_COMMAND_BUFFERS_COUNT);
  }
  unsigned __int8 v131 = atomic_load(HGLogger::_enabled);
  if (v131) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  METAL_MAX_COMMAND_BUFFERS_MEMORY : %d\n", v113, v114, HG_RENDERER_ENV::METAL_MAX_COMMAND_BUFFERS_MEMORY);
  }
  unsigned __int8 v132 = atomic_load(HGLogger::_enabled);
  if (v132) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_CLUSTERED_TEXTURE_PADDING  : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_CLUSTERED_TEXTURE_PADDING);
  }
  unsigned __int8 v133 = atomic_load(HGLogger::_enabled);
  if (v133) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  TEX_PADDING_REMEMBRANCE       : %d\n", v113, v114, HG_RENDERER_ENV::TEX_PADDING_REMEMBRANCE);
  }
  unsigned __int8 v134 = atomic_load(HGLogger::_enabled);
  if (v134) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  TEX_PADDING_CUSHIONING        : %d\n", v113, v114, HG_RENDERER_ENV::TEX_PADDING_CUSHIONING);
  }
  unsigned __int8 v135 = atomic_load(HGLogger::_enabled);
  if (v135) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  TEX_PADDING_CLUMPING          : %d\n", v113, v114, HG_RENDERER_ENV::TEX_PADDING_CLUMPING);
  }
  unsigned __int8 v136 = atomic_load(HGLogger::_enabled);
  if (v136) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_LEGACY_TEXTURE_POOLING  : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_LEGACY_TEXTURE_POOLING);
  }
  unsigned __int8 v137 = atomic_load(HGLogger::_enabled);
  if (v137) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  TEXTURE_POOL_STRATEGY         : %d\n", v113, v114, HG_RENDERER_ENV::TEXTURE_POOL_STRATEGY);
  }
  unsigned __int8 v138 = atomic_load(HGLogger::_enabled);
  if (v138) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  MAX_TEXTURE_AGE_MS            : %d\n", v113, v114, HG_RENDERER_ENV::MAX_TEXTURE_AGE_MS);
  }
  unsigned __int8 v139 = atomic_load(HGLogger::_enabled);
  if (v139) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  MAX_TEXTURE_POOL_SIZE_PERCENT   : %d\n", v113, v114, HG_RENDERER_ENV::MAX_TEXTURE_POOL_SIZE_PERCENT);
  }
  unsigned __int8 v140 = atomic_load(HGLogger::_enabled);
  if (v140) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  MAX_TEXTURE_QUEUE_SIZE_PERCENT  : %d\n", v113, v114, HG_RENDERER_ENV::MAX_TEXTURE_QUEUE_SIZE_PERCENT);
  }
  unsigned __int8 v141 = atomic_load(HGLogger::_enabled);
  if (v141) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  MAX_TEXTURE_UNUSED_SIZE_PERCENT : %d\n", v113, v114, HG_RENDERER_ENV::MAX_TEXTURE_UNUSED_SIZE_PERCENT);
  }
  unsigned __int8 v142 = atomic_load(HGLogger::_enabled);
  if (v142) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  MAX_TEXTURE_TOTAL_SIZE_PERCENT  : %d\n", v113, v114, HG_RENDERER_ENV::MAX_TEXTURE_TOTAL_SIZE_PERCENT);
  }
  unsigned __int8 v143 = atomic_load(HGLogger::_enabled);
  if (v143) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  IGNORE_LOADER_CHECK_FOR_CVCACHE : %d\n", v113, v114, HG_RENDERER_ENV::IGNORE_LOADER_CHECK_FOR_CVCACHE);
  }
  unsigned __int8 v144 = atomic_load(HGLogger::_enabled);
  if (v144) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  METAL_UPLOAD_TEXTURE_CREATION_STRATEGY : %d\n", v113, v114, HG_RENDERER_ENV::METAL_UPLOAD_TEXTURE_CREATION_STRATEGY);
  }
  unsigned __int8 v145 = atomic_load(HGLogger::_enabled);
  if (v145) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  CLIENT_STORAGE_RECYCLING_POLICY : %d\n", v113, v114, HG_RENDERER_ENV::CLIENT_STORAGE_RECYCLING_POLICY);
  }
  unsigned __int8 v146 = atomic_load(HGLogger::_enabled);
  if (v146) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_RECYCLE_SHARED_TEXTURES : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_RECYCLE_SHARED_TEXTURES);
  }
  unsigned __int8 v147 = atomic_load(HGLogger::_enabled);
  if (v147) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  LOAD_TEXTURE_TILE_ALIGNMENT   : %d\n", v113, v114, HG_RENDERER_ENV::LOAD_TEXTURE_TILE_ALIGNMENT);
  }
  unsigned __int8 v148 = atomic_load(HGLogger::_enabled);
  if (v148) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_POST_RENDER_FINISH      : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_POST_RENDER_FINISH);
  }
  unsigned __int8 v149 = atomic_load(HGLogger::_enabled);
  if (v149) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_POST_READPIXELS_FINISH  : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_POST_READPIXELS_FINISH);
  }
  unsigned __int8 v150 = atomic_load(HGLogger::_enabled);
  if (v150) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_POST_READPIXELS_FENCE   : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_POST_READPIXELS_FENCE);
  }
  unsigned __int8 v151 = atomic_load(HGLogger::_enabled);
  if (v151) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_DEFAULT_METAL_DEVICE    : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_DEFAULT_METAL_DEVICE);
  }
  unsigned __int8 v152 = atomic_load(HGLogger::_enabled);
  if (v152) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_NATIVE_TEXTURE_OUTPUT   : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_NATIVE_TEXTURE_OUTPUT);
  }
  unsigned __int8 v153 = atomic_load(HGLogger::_enabled);
  if (v153) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  LOG_LEVEL_INIT                : %d\n", v113, v114, HG_RENDERER_ENV::LOG_LEVEL_INIT);
  }
  unsigned __int8 v154 = atomic_load(HGLogger::_enabled);
  if (v154) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  LOG_LEVEL_TEXMANAGER          : %d\n", v113, v114, HG_RENDERER_ENV::LOG_LEVEL_TEXMANAGER);
  }
  unsigned __int8 v155 = atomic_load(HGLogger::_enabled);
  if (v155) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  LOG_LEVEL_GRAPH_DUMP          : %d\n", v113, v114, HG_RENDERER_ENV::LOG_LEVEL_GRAPH_DUMP);
  }
  unsigned __int8 v156 = atomic_load(HGLogger::_enabled);
  if (v156) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  LOG_LEVEL_GPU_TRACE           : %d\n", v113, v114, HG_RENDERER_ENV::LOG_LEVEL_GPU_TRACE);
  }
  unsigned __int8 v157 = atomic_load(HGLogger::_enabled);
  if (v157) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  LOG_LEVEL_COLORCONFORM_DUMP   : %d\n", v113, v114, HG_RENDERER_ENV::LOG_LEVEL_COLORCONFORM_DUMP);
  }
  unsigned __int8 v158 = atomic_load(HGLogger::_enabled);
  if (v158) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  LOG_LEVEL_MTL_PERF_VALIDATION : %d\n", v113, v114, HG_RENDERER_ENV::LOG_LEVEL_MTL_PERF_VALIDATION);
  }
  unsigned __int8 v159 = atomic_load(HGLogger::_enabled);
  if (v159) {
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  FORCE_SINGLE_DOT_FILE         : %d\n", v113, v114, HG_RENDERER_ENV::FORCE_SINGLE_DOT_FILE);
  }
  unsigned __int8 v160 = atomic_load(HGLogger::_enabled);
  if (v160)
  {
    __n128 v161 = this;
    if (*((char *)this + 23) < 0) {
      __n128 v161 = *(HG_RENDERER_ENV **)this;
    }
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  DOT_GRAPH_OUTPUT_DIR          : %s\n", v113, v114, v161);
  }
  unsigned __int8 v162 = atomic_load(HGLogger::_enabled);
  if (v162)
  {
    __n128 v163 = v164;
    if (*((char *)this + 47) < 0) {
      __n128 v163 = (void *)*v164;
    }
    HGLogger::log((HGLogger *)"envInit", (const char *)1, (HGLogger *)"  BUFFER_DUMP_DIR               : %s\n", v113, v114, v163);
  }
  HGLogger::setLevel((HGLogger *)"init", (const char *)HG_RENDERER_ENV::LOG_LEVEL_INIT);
  HGLogger::setLevel((HGLogger *)"texManager", (const char *)HG_RENDERER_ENV::LOG_LEVEL_TEXMANAGER);
  HGLogger::setLevel((HGLogger *)"graph", (const char *)HG_RENDERER_ENV::LOG_LEVEL_GRAPH_DUMP);
  HGLogger::setLevel((HGLogger *)"gpu", (const char *)HG_RENDERER_ENV::LOG_LEVEL_GPU_TRACE);
  HGLogger::setLevel((HGLogger *)"colorConform", (const char *)HG_RENDERER_ENV::LOG_LEVEL_COLORCONFORM_DUMP);
  HGLogger::setLevel((HGLogger *)"mtl_perf_validation", (const char *)HG_RENDERER_ENV::LOG_LEVEL_MTL_PERF_VALIDATION);
  HGLogger::setLevel((HGLogger *)HGSensoLogging::sGeneral[0], v111);
  HGLogger::setLevel((HGLogger *)HGSensoLogging::sPerformance[0], v115);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v185);
}

void sub_1B77A6054(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v17 - 113) < 0) {
    operator delete(*(void **)(v17 - 136));
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v17 - 112));
  if (*(char *)(v16 + 47) < 0)
  {
    operator delete(*a10);
    if ((*(char *)(v16 + 23) & 0x80000000) == 0) {
LABEL_7:
    }
      _Unwind_Resume(a1);
  }
  else if ((*(char *)(v16 + 23) & 0x80000000) == 0)
  {
    goto LABEL_7;
  }
  operator delete(*(void **)v16);
  _Unwind_Resume(a1);
}

uint64_t std::string::find[abi:ne180100](uint64_t *a1, char *a2, unint64_t a3)
{
  uint64_t v3 = (uint64_t)a1;
  if (*((char *)a1 + 23) < 0)
  {
    uint64_t v3 = *a1;
    unint64_t v4 = a1[1];
  }
  else
  {
    unint64_t v4 = *((unsigned __int8 *)a1 + 23);
  }
  int v5 = a2[23];
  if (v5 >= 0) {
    float v6 = a2;
  }
  else {
    float v6 = *(char **)a2;
  }
  if (v5 >= 0) {
    int64_t v7 = a2[23];
  }
  else {
    int64_t v7 = *((void *)a2 + 1);
  }
  if (v4 < a3) {
    return -1;
  }
  if (v7)
  {
    float v9 = (void *)(v3 + a3);
    uint64_t v10 = (char *)(v3 + v4);
    int64_t v11 = v4 - a3;
    if (v11 >= v7)
    {
      int v13 = *v6;
      do
      {
        uint64_t v14 = v11 - v7;
        if (v14 == -1) {
          break;
        }
        uint64_t v15 = (char *)memchr(v9, v13, v14 + 1);
        if (!v15) {
          break;
        }
        uint64_t v12 = v15;
        if (!memcmp(v15, v6, v7)) {
          goto LABEL_16;
        }
        float v9 = v12 + 1;
        int64_t v11 = v10 - (v12 + 1);
      }
      while (v11 >= v7);
    }
    uint64_t v12 = v10;
LABEL_16:
    if (v12 == v10) {
      return -1;
    }
    else {
      return (uint64_t)&v12[-v3];
    }
  }
  return a3;
}

void HG_RENDERER_ENV::DOT_GRAPH_OUTPUT_DIR(std::string *a1@<X8>)
{
  if ((atomic_load_explicit(&byte_1EB9A1FF0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire((__guard *)&byte_1EB9A1FF0))
  {
    HG_RENDERER_ENV::HG_RENDERER_ENV((HG_RENDERER_ENV *)&xmmword_1EB9A2028);
    __cxa_atexit((void (*)(void *))HGProgramDescriptor::Dependency::~Dependency, &xmmword_1EB9A2028, &dword_1B73F3000);
    __cxa_guard_release((__guard *)&byte_1EB9A1FF0);
  }
  if (byte_1EB9A203F < 0)
  {
    long long v3 = xmmword_1EB9A2028;
    std::string::__init_copy_ctor_external(a1, (const std::string::value_type *)v3, *((std::string::size_type *)&v3 + 1));
  }
  else
  {
    *(_OWORD *)&a1->__r_.__value_.__l.__data_ = xmmword_1EB9A2028;
    a1->__r_.__value_.__r.__words[2] = unk_1EB9A2038;
  }
}

void sub_1B77A62A0(_Unwind_Exception *a1)
{
}

void HG_RENDERER_ENV::BUFFER_DUMP_DIR(std::string *a1@<X8>)
{
  if ((atomic_load_explicit(&byte_1EB9A1FF0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire((__guard *)&byte_1EB9A1FF0))
  {
    HG_RENDERER_ENV::HG_RENDERER_ENV((HG_RENDERER_ENV *)&xmmword_1EB9A2028);
    __cxa_atexit((void (*)(void *))HGProgramDescriptor::Dependency::~Dependency, &xmmword_1EB9A2028, &dword_1B73F3000);
    __cxa_guard_release((__guard *)&byte_1EB9A1FF0);
  }
  if (byte_1EB9A2057 < 0)
  {
    long long v3 = xmmword_1EB9A2040;
    std::string::__init_copy_ctor_external(a1, (const std::string::value_type *)v3, *((std::string::size_type *)&v3 + 1));
  }
  else
  {
    *(_OWORD *)&a1->__r_.__value_.__l.__data_ = xmmword_1EB9A2040;
    a1->__r_.__value_.__r.__words[2] = unk_1EB9A2050;
  }
}

void sub_1B77A6384(_Unwind_Exception *a1)
{
}

void HG_RENDERER_ENV::Init(HG_RENDERER_ENV *this)
{
  if ((atomic_load_explicit(&byte_1EB9A1FF0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire((__guard *)&byte_1EB9A1FF0))
  {
    HG_RENDERER_ENV::HG_RENDERER_ENV((HG_RENDERER_ENV *)&xmmword_1EB9A2028);
    __cxa_atexit((void (*)(void *))HGProgramDescriptor::Dependency::~Dependency, &xmmword_1EB9A2028, &dword_1B73F3000);
    __cxa_guard_release((__guard *)&byte_1EB9A1FF0);
  }
}

void sub_1B77A6428(_Unwind_Exception *a1)
{
}

void HGRendererOutput::HGRendererOutput(HGRendererOutput *this, HGNode *a2, HGBitmap *a3)
{
  *(void *)this = a2;
  *((void *)this + 1) = a3;
  long long v3 = (long long *)((char *)a3 + 20);
  if (!a3) {
    long long v3 = &HGRectNull;
  }
  *((_OWORD *)this + 1) = *v3;
  if (a3)
  {
    *((void *)this + 4) = *((unsigned int *)a3 + 4);
  }
  else
  {
    *((_DWORD *)this + 8) = 0;
    *((_DWORD *)this + 9) = 0;
  }
}

uint64_t HGRendererOutput::HGRendererOutput(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  *(void *)uint64_t result = a2;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = a3;
  *(void *)(result + 24) = a4;
  *(_DWORD *)(result + 32) = a5;
  *(_DWORD *)(result + 36) = a6;
  return result;
}

void HGRenderer::HGRenderer(HGRenderer *this)
{
  HGObject::HGObject(this);
  *(void *)uint64_t v2 = &unk_1F10D5F28;
  *(_OWORD *)(v2 + 56) = 0u;
  *(_DWORD *)(v2 + 72) = 0;
  *(_OWORD *)(v2 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = 0u;
  *(_DWORD *)(v2 + 96) = 0;
  *(_OWORD *)(v2 + 104) = 0u;
  *(_DWORD *)(v2 + 12CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *(_OWORD *)(v2 + 128) = 0u;
  *(_DWORD *)(v2 + 144) = 0;
  *(_OWORD *)(v2 + 152) = 0u;
  *(_DWORD *)(v2 + 168) = 0;
  *(_DWORD *)(v2 + 192) = 0;
  *(_OWORD *)(v2 + 176) = 0u;
  *(_OWORD *)(v2 + 20CVOpenGLESTextureCacheFlush(this[3], 0) = 0u;
  *(_DWORD *)(v2 + 216) = 0;
  *(_DWORD *)(v2 + 48) = 0;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 224) = 0u;
  *(_OWORD *)(v2 + 256) = 0u;
  *(_OWORD *)(v2 + 272) = 0u;
  *(_OWORD *)(v2 + 24CVOpenGLESTextureCacheFlush(this[3], 0) = 0u;
  *(void *)(v2 + 568) = 0;
  *(_OWORD *)(v2 + 552) = 0u;
  *(_OWORD *)(v2 + 576) = xmmword_1B8345EB0;
  *(_OWORD *)(v2 + 592) = xmmword_1B8345EC0;
  *(_OWORD *)(v2 + 608) = xmmword_1B8345ED0;
  *(_OWORD *)(v2 + 624) = 0u;
  *(_OWORD *)(v2 + 64CVOpenGLESTextureCacheFlush(this[3], 0) = 0u;
  *(void *)(v2 + 656) = 0x4B000000000;
  *(void *)(v2 + 664) = 0x200000001;
  *(_OWORD *)(v2 + 672) = 0u;
  *(_OWORD *)(v2 + 688) = xmmword_1B7E751A0;
  HGCache::HGCache((HGCache *)(v2 + 704));
  *((_WORD *)this + 404) = 256;
  *((unsigned char *)this + 81CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *((_DWORD *)this + 208) = 1;
  HGDotGraph::HGDotGraph((HGRenderer *)((char *)this + 840));
  HGBufferDumper::HGBufferDumper((HGRenderer *)((char *)this + 928));
  *((_DWORD *)this + 254) = 0;
  *((void *)this + 128) = 0;
  *((_DWORD *)this + 262) = 0;
  *(_OWORD *)((char *)this + 1032) = 0u;
  *((_OWORD *)this + 66) = 0u;
  *((_DWORD *)this + 268) = 0;
  *((void *)this + 135) = 0;
  *((void *)this + 137) = 0;
  *((void *)this + 136) = 0;
  if ((atomic_load_explicit(&byte_1EB9A1FF0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire((__guard *)&byte_1EB9A1FF0))
  {
    HG_RENDERER_ENV::HG_RENDERER_ENV((HG_RENDERER_ENV *)&xmmword_1EB9A2028);
    __cxa_atexit((void (*)(void *))HGProgramDescriptor::Dependency::~Dependency, &xmmword_1EB9A2028, &dword_1B73F3000);
    __cxa_guard_release((__guard *)&byte_1EB9A1FF0);
  }
  *((_DWORD *)this + 149) = HGGetActiveCPU();
  *((_DWORD *)this + 268) = 0;
  long long v3 = getenv("ROI_DEBUG");
  if (v3) {
    *((_DWORD *)this + 169) = atoi(v3);
  }
  operator new();
}

void sub_1B77A6864(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  __cxa_guard_abort((__guard *)&byte_1EB9A1FF0);
  if (*(char *)(v15 + 1047) < 0) {
    operator delete(*v19);
  }
  HGBufferDumper::~HGBufferDumper(v18);
  HGDotGraph::~HGDotGraph(v17);
  HGCache::~HGCache(v16);
  uint64_t v22 = *(void **)(v15 + 248);
  if (v22)
  {
    *(void *)(v15 + 256) = v22;
    operator delete(v22);
    uint64_t v23 = *v20;
    if (!*v20)
    {
LABEL_5:
      HGObject::~HGObject((HGObject *)v15);
      _Unwind_Resume(a1);
    }
  }
  else
  {
    uint64_t v23 = *v20;
    if (!*v20) {
      goto LABEL_5;
    }
  }
  *(void *)(v15 + 232) = v23;
  operator delete(v23);
  HGObject::~HGObject((HGObject *)v15);
  _Unwind_Resume(a1);
}

uint64_t HGRenderer::GetCachedLimits(HGRenderer *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 135);
  uint64_t v5 = *(void *)(v2 + 8);
  uint64_t v3 = v2 + 8;
  uint64_t v4 = v5;
  if (!v5) {
    goto LABEL_12;
  }
  uint64_t v6 = v3;
  do
  {
    unsigned int v7 = *(_DWORD *)(v4 + 32);
    BOOL v8 = v7 >= a2;
    if (v7 >= a2) {
      float v9 = (uint64_t *)v4;
    }
    else {
      float v9 = (uint64_t *)(v4 + 8);
    }
    if (v8) {
      uint64_t v6 = v4;
    }
    uint64_t v4 = *v9;
  }
  while (*v9);
  if (v6 == v3 || *(_DWORD *)(v6 + 32) > a2) {
LABEL_12:
  }
    operator new();
  return *(void *)(v6 + 40);
}

void HGRenderer::~HGRenderer(HGRenderer *this)
{
  *(void *)this = &unk_1F10D5F28;
  uint64_t v2 = *((void *)this + 135);
  uint64_t v3 = *(void **)v2;
  if (*(void *)v2 == v2 + 8) {
    goto LABEL_13;
  }
  do
  {
    uint64_t v4 = v3[5];
    if (v4) {
      MEMORY[0x1BA9BFBA0](v4, 0x1000C40EED21634);
    }
    v3[5] = 0;
    uint64_t v5 = (void *)v3[1];
    if (v5)
    {
      do
      {
        uint64_t v6 = v5;
        uint64_t v5 = (void *)*v5;
      }
      while (v5);
    }
    else
    {
      do
      {
        uint64_t v6 = (void *)v3[2];
        BOOL v7 = *v6 == (void)v3;
        uint64_t v3 = v6;
      }
      while (!v7);
    }
    uint64_t v3 = v6;
  }
  while (v6 != (void *)(v2 + 8));
  uint64_t v2 = *((void *)this + 135);
  if (v2)
  {
LABEL_13:
    std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v2, *(void **)(v2 + 8));
    MEMORY[0x1BA9BFBA0](v2, 0x1020C4062D53EE8);
  }
  *((_OWORD *)this + 51) = 0u;
  BOOL v8 = (HGStats::GraphStats *)*((void *)this + 70);
  if (v8)
  {
    HGStats::GraphStats::~GraphStats(v8);
    MEMORY[0x1BA9BFBA0]();
  }
  float v9 = (HGStats::RendererStats *)*((void *)this + 71);
  if (v9)
  {
    HGStats::RendererStats::~RendererStats(v9);
    MEMORY[0x1BA9BFBA0]();
  }
  uint64_t v10 = (HGLUTCacheManager *)*((void *)this + 69);
  if (v10)
  {
    HGLUTCacheManager::~HGLUTCacheManager(v10);
    MEMORY[0x1BA9BFBA0]();
  }
  (*(void (**)(HGRenderer *, void))(*(void *)this + 144))(this, 0);
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((_DWORD *)this + 12) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 1CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *((void *)this + 11) = 0;
  *((_DWORD *)this + 24) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((_DWORD *)this + 3CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 17) = 0;
  *((_DWORD *)this + 36) = 0;
  *((_DWORD *)this + 42) = 0;
  *((void *)this + 19) = 0;
  *((void *)this + 2CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *((void *)this + 22) = 0;
  *((void *)this + 23) = 0;
  *((_DWORD *)this + 48) = 0;
  *((_DWORD *)this + 54) = 0;
  unint64_t v11 = *((void *)this + 29) - *((void *)this + 28);
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0;
  if ((int)(v11 >> 3) >= 1)
  {
    unint64_t v12 = (v11 >> 3) + 1;
    do
    {
      uint64_t v13 = *(void *)(*((void *)this + 28) + 8 * (v12 - 2));
      if (v13) {
        (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
      }
      --v12;
    }
    while (v12 > 1);
  }
  unint64_t v14 = *((void *)this + 32) - *((void *)this + 31);
  if ((int)(v14 >> 3) >= 1)
  {
    unint64_t v15 = (v14 >> 3) + 1;
    do
    {
      uint64_t v16 = *(HGExecutionUnit **)(*((void *)this + 31) + 8 * (v15 - 2));
      if (v16)
      {
        HGExecutionUnit::~HGExecutionUnit(v16);
        MEMORY[0x1BA9BFBA0]();
      }
      --v15;
    }
    while (v15 > 1);
  }
  HGFree(*((void *)this + 35));
  pthread_rwlock_destroy((pthread_rwlock_t *)((char *)this + 288));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 488));
  if (*((char *)this + 1047) < 0) {
    operator delete(*((void **)this + 128));
  }
  HGBufferDumper::~HGBufferDumper((void **)this + 116);
  HGDotGraph::~HGDotGraph((HGRenderer *)((char *)this + 840));
  HGCache::~HGCache((HGRenderer *)((char *)this + 704));
  uint64_t v17 = (void *)*((void *)this + 31);
  if (v17)
  {
    *((void *)this + 32) = v17;
    operator delete(v17);
  }
  uint64_t v18 = (void *)*((void *)this + 28);
  if (v18)
  {
    *((void *)this + 29) = v18;
    operator delete(v18);
  }

  HGObject::~HGObject(this);
}

{
  void *v1;
  uint64_t vars8;

  HGRenderer::~HGRenderer(this);

  HGObject::operator delete(v1);
}

uint64_t HGRenderer::label(HGRenderer *this)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v7);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"Renderer #", 10);
  uint64_t v2 = (void *)std::ostream::operator<<();
  uint64_t v3 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, (uint64_t)": ", 2);
  if ((*(unsigned int (**)(HGRenderer *))(*(void *)this + 304))(this)) {
    uint64_t v4 = "CPU";
  }
  else {
    uint64_t v4 = "GPU";
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)v4, 3);
  std::stringbuf::str();
  v7[0] = *MEMORY[0x1E4FBA408];
  uint64_t v5 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v7 + *(void *)(v7[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  v8[0] = v5;
  v8[1] = MEMORY[0x1E4FBA470] + 16;
  if (v9 < 0) {
    operator delete((void *)v8[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BA9BFAB0](&v10);
}

void sub_1B77A7010(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t HGRenderer::debugDescription(HGRenderer *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 40))();
}

uint64_t HGRenderer::IsCPU(HGRenderer *this)
{
  return 1;
}

uint64_t HGRenderer::RenderFullROI_Default(HGRenderer *this)
{
  return 1;
}

void *HGRenderer::CreateBuffer(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  BOOL v7 = HGObject::operator new(0x80uLL);
  HGBuffer::HGBuffer((uint64_t)v7, a2, a3, a4);
  return v7;
}

void sub_1B77A70A8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGRenderer::BindBuffer(HGBitmap **this, HGBitmap *a2)
{
  if (a2 && this[3] == a2) {
    return 0;
  }
  (*((void (**)(HGBitmap **, void, void, void, void))*this + 19))(this, 0, 0, 0, 0);
  (*((void (**)(HGBitmap **, uint64_t, void, void, void))*this + 19))(this, 1, 0, 0, 0);
  (*((void (**)(HGBitmap **, uint64_t, void, void, void))*this + 19))(this, 2, 0, 0, 0);
  (*((void (**)(HGBitmap **, uint64_t, void, void, void))*this + 19))(this, 3, 0, 0, 0);
  (*((void (**)(HGBitmap **, uint64_t, void, void, void))*this + 19))(this, 4, 0, 0, 0);
  (*((void (**)(HGBitmap **, uint64_t, void, void, void))*this + 19))(this, 5, 0, 0, 0);
  (*((void (**)(HGBitmap **, uint64_t, void, void, void))*this + 19))(this, 6, 0, 0, 0);
  (*((void (**)(HGBitmap **, uint64_t, void, void, void))*this + 19))(this, 7, 0, 0, 0);
  uint64_t v4 = this[3];
  if (v4)
  {
    (*(void (**)(HGBitmap *))(*(void *)v4 + 24))(v4);
    this[3] = 0;
  }
  if (!a2) {
    return 0;
  }
  if (*((void *)a2 + 10))
  {
    this[3] = a2;
    (*(void (**)(HGBitmap *))(*(void *)a2 + 16))(a2);
    return 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t HGRenderer::BindTexture(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, int a5)
{
  if (a2 > 7) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = a1 + 24 * a2;
  uint64_t v13 = *(void *)(v10 + 32);
  unint64_t v11 = (void *)(v10 + 32);
  uint64_t v12 = v13;
  unint64_t v15 = v11 + 1;
  uint64_t v14 = v11[1];
  if (v13 != a3)
  {
    void *v11 = a3;
    if (a3) {
      (*(void (**)(uint64_t))(*(void *)a3 + 16))(a3);
    }
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
    }
  }
  if (v14 != a4)
  {
    *unint64_t v15 = a4;
    if (a4) {
      (*(void (**)(uint64_t))(*(void *)a4 + 16))(a4);
    }
    if (v14) {
      (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);
    }
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 24 * a2 + 48) = a5;
  return result;
}

uint64_t HGRenderer::SetParameter(uint64_t this, int a2, char *a3)
{
  unsigned int v3 = a3;
  uint64_t v4 = this;
  switch(a2)
  {
    case 0:
      *(_DWORD *)(this + 584) = a3;
      return this;
    case 1:
      if ((int)a3 <= 8) {
        unsigned int v5 = 8;
      }
      else {
        unsigned int v5 = a3;
      }
      if (v5 >= 0x100) {
        unsigned int v5 = 256;
      }
      *(_DWORD *)(this + 588) = v5;
      return this;
    case 2:
      if ((int)a3 <= 8) {
        unsigned int v6 = 8;
      }
      else {
        unsigned int v6 = a3;
      }
      if (v6 >= 0x100) {
        unsigned int v6 = 256;
      }
      *(_DWORD *)(this + 592) = v6;
      return this;
    case 4:
      *(_DWORD *)(this + 628) = a3;
      return this;
    case 5:
      if ((int)a3 <= 1) {
        int v7 = 1;
      }
      else {
        int v7 = (int)a3;
      }
      *(_DWORD *)(this + 596) = v7;
      return this;
    case 6:
      signed int v8 = a3 & ~((int)a3 >> 31);
      if (v8 >= 4) {
        signed int v8 = 4;
      }
      *(_DWORD *)(this + 60CVOpenGLESTextureCacheFlush(this[3], 0) = v8;
      return this;
    case 7:
      *(_DWORD *)(this + 604) = (int)a3 > 0;
      return this;
    case 8:
      *(_DWORD *)(this + 608) = (int)a3 > 0;
      return this;
    case 9:
      *(_DWORD *)(this + 612) = a3;
      return this;
    case 10:
      *(_DWORD *)(this + 616) = a3;
      return this;
    case 11:
      *(_DWORD *)(this + 62CVOpenGLESTextureCacheFlush(this[3], 0) = a3;
      return this;
    case 13:
      *(_DWORD *)(this + 636) = a3;
      return this;
    case 14:
      if (*(_DWORD *)(this + 640))
      {
        if (!a3)
        {
          *(_DWORD *)(this + 64CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
          char v9 = (pthread_rwlock_t *)(this + 288);
          return pthread_rwlock_unlock(v9);
        }
      }
      else if (a3)
      {
        this = pthread_rwlock_wrlock((pthread_rwlock_t *)(this + 288));
        *(_DWORD *)(v4 + 64CVOpenGLESTextureCacheFlush(this[3], 0) = 1;
      }
      return this;
    case 15:
      *(_DWORD *)(this + 644) = a3;
      return this;
    case 16:
      *(_DWORD *)(this + 648) = a3;
      return this;
    case 17:
      *(_DWORD *)(this + 652) = a3;
      return this;
    case 18:
      *(_DWORD *)(this + 66CVOpenGLESTextureCacheFlush(this[3], 0) = a3;
      return this;
    case 19:
      if ((a3 - 1) <= 0x20) {
        *(_DWORD *)(this + 576) = a3;
      }
      return this;
    case 20:
      if ((a3 - 1) <= 0x20) {
        *(_DWORD *)(this + 58CVOpenGLESTextureCacheFlush(this[3], 0) = a3;
      }
      return this;
    case 22:
      *(_DWORD *)(this + 832) = a3 != 0;
      return this;
    case 23:
      switch(a3)
      {
        case 2:
          *(_DWORD *)(this + 664) = 2;
          break;
        case 1:
          *(_DWORD *)(this + 664) = 1;
          break;
        case 0:
          *(_DWORD *)(this + 664) = 0;
          break;
      }
      return this;
    case 24:
      *(_DWORD *)(this + 668) = a3;
      return this;
    case 28:
      *(_DWORD *)(this + 672) = a3 != 0;
      return this;
    case 29:
      return HGLogger::setLevel((HGLogger *)"gpu", a3);
    case 30:
      *(_DWORD *)(this + 656) = a3;
      uint64_t v10 = this + 840;
      return PCImage::setIsPremultiplied(v10, a3 != 0);
    case 31:
      unint64_t v11 = (HGBufferDumper *)(this + 928);
      return (uint64_t)HGBufferDumper::enable(v11, a3 != 0);
    case 32:
      if ((int)a3 > 394255)
      {
        if (a3 == 394272) {
          goto LABEL_85;
        }
        if (a3 != 394256) {
          goto LABEL_93;
        }
LABEL_84:
        int v25 = 394256;
        *(void *)(this + 816) = HGRenderer::GetCachedLimits((HGRenderer *)this, 0x60410u);
        int v26 = 328736;
        uint64_t v27 = (HGRenderer *)v4;
        unsigned int v28 = 328736;
LABEL_86:
        this = HGRenderer::GetCachedLimits(v27, v28);
        *(void *)(v4 + 824) = this;
        **(_DWORD **)(v4 + 816) = v25;
        *(_DWORD *)this = v26;
        return this;
      }
      if (a3 == 328736) {
        goto LABEL_84;
      }
      if (a3 == 328752)
      {
LABEL_85:
        int v25 = 394272;
        *(void *)(this + 816) = HGRenderer::GetCachedLimits((HGRenderer *)this, 0x60420u);
        int v26 = 328752;
        uint64_t v27 = (HGRenderer *)v4;
        unsigned int v28 = 328752;
        goto LABEL_86;
      }
LABEL_93:
      if ((*(uint64_t (**)(uint64_t))(*(void *)this + 304))(this))
      {
        int v29 = v3 | 0x1000000;
        if (v3 >= 0x100000) {
          int v29 = v3;
        }
        dword_1EB9A1FEC = v29;
        *(_DWORD *)(v4 + 812) = v29;
        *(void *)(v4 + 816) = HGRenderer::GetCachedLimits((HGRenderer *)v4, v29 | 0x60000u);
        this = HGRenderer::GetCachedLimits((HGRenderer *)v4, *(_DWORD *)(v4 + 812) | 0x50000u);
        *(void *)(v4 + 824) = this;
        int v30 = *(_DWORD *)(v4 + 812);
        **(_DWORD **)(v4 + 816) = v30;
        *(_DWORD *)this = v30;
      }
      else
      {
        *(void *)(v4 + 816) = HGRenderer::GetCachedLimits((HGRenderer *)v4, (unsigned __int16)v3 | 0x60000u);
        this = HGRenderer::GetCachedLimits((HGRenderer *)v4, (unsigned __int16)v3 | 0x50000u);
        *(void *)(v4 + 824) = this;
        **(_DWORD **)(v4 + 816) = (unsigned __int16)v3 | 0x60000;
        *(_DWORD *)this = (unsigned __int16)v3 | 0x50000;
      }
      return this;
    case 33:
      BOOL v16 = a3 != 0;
      *(unsigned char *)(this + 81CVOpenGLESTextureCacheFlush(this[3], 0) = a3 != 0;
      uint64_t v17 = *(void *)(this + 224);
      unint64_t v18 = *(void *)(this + 232) - v17;
      if ((int)(v18 >> 3) >= 1)
      {
        unint64_t v19 = (v18 >> 3);
        uint64_t v20 = v19;
        if (v19 < 2) {
          goto LABEL_78;
        }
        uint64_t v20 = (v18 >> 3) & 1;
        unint64_t v21 = v19 - v20;
        unint64_t v22 = v19 + 4294967294u;
        do
        {
          uint64_t v23 = *(void *)(v17 + 8 * v22);
          *(unsigned char *)(*(void *)(v17 + 8 * (v22 + 1)) + 4CVOpenGLESTextureCacheFlush(this[3], 0) = v16;
          *(unsigned char *)(v23 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = v16;
          v22 -= 2;
          v21 -= 2;
        }
        while (v21);
        if (v20)
        {
LABEL_78:
          unint64_t v24 = v20 + 1;
          do
            *(unsigned char *)(*(void *)(v17 + 8 * (v24-- - 2)) + 4CVOpenGLESTextureCacheFlush(this[3], 0) = v16;
          while (v24 > 1);
        }
      }
      return this;
    case 34:
      switch((int)a3)
      {
        case 0:
        case 1:
        case 2:
        case 3:
          int v12 = *(_DWORD *)(this + 1072);
          *(_DWORD *)(this + 1072) = 0;
          if (v12)
          {
            uint64_t v13 = *(void *)(this + 248);
            unint64_t v14 = *(void *)(this + 256) - v13;
            if ((int)(v14 >> 3) >= 1)
            {
              unint64_t v15 = (v14 >> 3) + 1;
              do
                *(_DWORD *)(*(void *)(v13 + 8 * (v15-- - 2)) + 44CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
              while (v15 > 1);
            }
          }
          break;
        default:
          return this;
      }
      return this;
    case 36:
      if (a3 == -1)
      {
        this = (uint64_t)getenv("ROI_DEBUG");
        if (this)
        {
          this = atoi((const char *)this);
          *(_DWORD *)(v4 + 676) = this;
        }
      }
      else
      {
        *(_DWORD *)(this + 676) = a3;
      }
      return this;
    case 40:
      *(_DWORD *)(this + 68CVOpenGLESTextureCacheFlush(this[3], 0) = a3;
      return this;
    case 41:
      *(_DWORD *)(this + 684) = a3;
      return this;
    case 42:
      *(_DWORD *)(this + 688) = a3;
      return this;
    default:
      return this;
  }
}

uint64_t HGRenderer::GetParameter(uint64_t a1, int a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0x2000;
  switch(a2)
  {
    case 0:
      return *(unsigned int *)(a1 + 584);
    case 1:
      return *(unsigned int *)(a1 + 588);
    case 2:
      return *(unsigned int *)(a1 + 592);
    case 3:
      return (*(_DWORD *)(a1 + 592) * *(_DWORD *)(a1 + 588));
    case 4:
      return *(unsigned int *)(a1 + 628);
    case 5:
      return *(unsigned int *)(a1 + 596);
    case 6:
      return *(unsigned int *)(a1 + 600);
    case 7:
      return *(unsigned int *)(a1 + 604);
    case 8:
      return *(unsigned int *)(a1 + 608);
    case 9:
      return *(unsigned int *)(a1 + 612);
    case 10:
      return *(unsigned int *)(a1 + 616);
    case 11:
      return *(unsigned int *)(a1 + 620);
    case 13:
      return *(unsigned int *)(a1 + 636);
    case 14:
      return *(unsigned int *)(a1 + 640);
    case 15:
      return *(unsigned int *)(a1 + 644);
    case 16:
      return *(unsigned int *)(a1 + 648);
    case 17:
      return *(unsigned int *)(a1 + 652);
    case 18:
      return *(unsigned int *)(a1 + 660);
    case 19:
      return *(unsigned int *)(a1 + 576);
    case 20:
      return *(unsigned int *)(a1 + 580);
    case 22:
      return *(unsigned int *)(a1 + 832);
    case 23:
      return *(unsigned int *)(a1 + 664);
    case 24:
      return *(unsigned int *)(a1 + 668);
    case 27:
      return v3;
    case 28:
      return *(unsigned int *)(a1 + 672);
    case 32:
      return **(unsigned int **)(a1 + 816);
    case 34:
      if (*(_DWORD *)(a1 + 1072)) {
        return 3;
      }
      else {
        return 0;
      }
    case 36:
      return *(unsigned int *)(a1 + 676);
    case 40:
      return *(unsigned int *)(a1 + 680);
    case 41:
      return *(unsigned int *)(a1 + 684);
    case 42:
      return *(unsigned int *)(a1 + 688);
    case 46:
      return HGLimits::texturerect(*(HGLimits **)(a1 + 816));
    default:
      return v2;
  }
}

uint64_t HGRenderer::GetTarget(HGRenderer *this, int a2)
{
  switch(a2)
  {
    case 0:
      return dword_1EB9A1FEC;
    case 327680:
      return **((unsigned int **)this + 103);
    case 393216:
      return **((unsigned int **)this + 102);
  }
  return 0;
}

uint64_t HGRenderer::RenderCheckPoint(HGRenderer *this)
{
  if (*((_DWORD *)this + 160))
  {
    pthread_rwlock_rdlock((pthread_rwlock_t *)((char *)this + 288));
    pthread_rwlock_unlock((pthread_rwlock_t *)((char *)this + 288));
  }
  if (*((_DWORD *)this + 159)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

void HGRenderer::RenderInput(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, unint64_t a6, unint64_t a7, int a8)
{
  if (*(_DWORD *)(a3 + 88) <= a4 || (uint64_t v9 = *(void *)(*(void *)(a3 + 80) + 8 * a4)) == 0)
  {
    *(_DWORD *)(a5 + 8) = 0;
    *(void *)a5 = 0;
    return;
  }
  if ((*(unsigned char *)(v9 + 12) & 6) != 0)
  {
    unint64_t v14 = *(void **)(v9 + 48);
    if (v14)
    {
      *(void *)a5 = v14[10];
      *(_DWORD *)(a5 + 8) = v14[8] / v14[7];
    }
    uint64_t v15 = *(int *)(a2 + 160);
    uint64_t v16 = *(void *)(a1 + 224);
    if ((int)v15 < (int)((unint64_t)(*(void *)(a1 + 232) - v16) >> 3)
      && (uint64_t v17 = *(const void **)(v16 + 8 * v15)) != 0)
    {
      if (!*(void *)(*(void *)(*(void *)(v9 + 16) + 144) + 96)) {
        return;
      }
    }
    else
    {
      unint64_t v18 = 0;
      if (!*(void *)(*(void *)(*(void *)(v9 + 16) + 144) + 96)) {
        return;
      }
    }
    if (DepthBufferManager::hasDepthBuffer(v18))
    {
      unint64_t v19 = *(HGBitmap **)(*(void *)(*(void *)(v9 + 16) + 144) + 96);
      *(void *)&v20.int var0 = a6;
      *(void *)&v20.int var2 = a7;
      DBM_cpu::setDepthBuffer(v18, v19, v20);
    }
  }
  else if (!HGRectIsNull(a6, a7))
  {
    uint64_t v22 = (int)((a7 - (a6 & 0xFFFFFFFF00000000)) >> 32) * (uint64_t)((int)a7 - (int)a6);
    Stacuint64_t k = (int8x16_t *)HGExecutionUnit::GetStack((char ****)a2, v22);
    uint64_t v24 = *(void *)(v9 + 16);
    if (v24)
    {
      uint64_t v25 = *(void *)(v24 + 144);
      uint64_t v26 = *(void *)(v25 + 192);
      if (v26)
      {
        *(_DWORD *)(a2 + 36) = 0;
        *(_DWORD *)(a2 + 112) = *(_DWORD *)(a1 + 628);
        HGStats::ProfilerScopeGuard::ProfilerScopeGuard(v31, *(void *)(a2 + 424), 1, v22, *(void *)(v26 + 56) * v22);
        HGSampler::ReadTile((float32x4_t *)a2, *(_DWORD **)(v25 + 192), 0, Stack, a6, a7, 0);
        HGStats::ProfilerScopeGuard::~ProfilerScopeGuard((HGStats::ProfilerScopeGuard *)v31);
        uint64_t v27 = *(int *)(a2 + 160);
        uint64_t v28 = *(void *)(a1 + 224);
        if ((int)v27 < (int)((unint64_t)(*(void *)(a1 + 232) - v28) >> 3)
          && (int v29 = *(const void **)(v28 + 8 * v27)) != 0)
        {
        }
        else
        {
          int v30 = 0;
        }
        if (*(void *)(v25 + 96) && DepthBufferManager::hasDepthBuffer(v30))
        {
          *(void *)&v33.int var0 = a6;
          *(void *)&v33.int var2 = a7;
          DBM_cpu::setDepthBuffer(v30, *(HGBitmap **)(v25 + 96), v33);
        }
      }
      else
      {
        HGRenderer::RenderTile(a1, (int *)a2, Stack->i8, a6, a7, v25, 0);
      }
    }
    *(_DWORD *)(a5 + 8) = a7 - a6;
    *(void *)a5 = Stack;
    if (!a8) {
      HGExecutionUnit::CommitStack(a2, (uint64_t)Stack, v22);
    }
  }
}

void sub_1B77A8190(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HGRenderer::DepthManager(HGRenderer *this, int a2)
{
  uint64_t v2 = *((void *)this + 28);
  if ((int)((unint64_t)(*((void *)this + 29) - v2) >> 3) <= a2) {
    return 0;
  }
  else {
    return *(void *)(v2 + 8 * a2);
  }
}

void HGRenderer::RenderTile(uint64_t a1, int *a2, char *a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7)
{
  if (*(_DWORD *)(a1 + 640))
  {
    pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 288));
    pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 288));
  }
  if (*(_DWORD *)(a1 + 636)) {
    return;
  }
  uint64_t v14 = *(void *)(a6 + 192);
  if (!v14)
  {
    unint64_t v65 = HIDWORD(a5);
    uint64_t v66 = (a5 - a4);
    unint64_t v67 = HIDWORD(a4);
    float32x4_t v68 = (HGExecutionUnit *)a2;
    int v21 = HIDWORD(a5) - HIDWORD(a4);
    unint64_t v22 = (HIDWORD(a5) - HIDWORD(a4)) * (unint64_t)v66;
    unint64_t v23 = HGRectIntersection(a4, a5, *(void *)(a6 + 168), *(void *)(a6 + 176));
    uint64_t v25 = v24;
    if (HGRectIsNull(v23, v24))
    {
      HGStats::ProfilerScopeGuard::ProfilerScopeGuard(&v71, *((void *)v68 + 53), 3, v22, 16 * v22);
      if (a7)
      {
        int v26 = HIDWORD(a5) - HIDWORD(a4);
        if (SHIDWORD(a5) > (int)v67)
        {
          do
          {
            bzero(a3, 16 * v66);
            a3 += 16 * (v66 + a7);
            --v26;
          }
          while (v26);
        }
      }
      else
      {
        bzero(a3, 16 * v22);
      }
      int v32 = (HGStats::ProfilerScopeGuard *)&v71;
LABEL_36:
      HGStats::ProfilerScopeGuard::~ProfilerScopeGuard(v32);
      return;
    }
    if (HGRectIsEqual(v23, v25, a4, a5))
    {
      if ((*(unsigned char *)(a6 + 16) & 0x80) != 0
        || v22 < 2 * *(_DWORD *)(*((void *)v68 + 19) + 588) * *(_DWORD *)(*((void *)v68 + 19) + 592))
      {
        uint64_t v101 = 0;
        long long v99 = 0u;
        long long v100 = 0u;
        HGExecutionUnit::GetStackState((uint64_t)v68, (uint64_t)&v99);
        uint64_t v98 = v68;
        *(void *)&long long v71 = a4;
        *((void *)&v71 + 1) = a5;
        *(void *)&long long v72 = a3;
        DWORD2(v72) = v66 + a7;
        if (!*(void *)(a6 + 80) || (*(unsigned char *)(a6 + 16) & 0x10) != 0)
        {
          uint64_t v74 = 0;
          int v75 = 0;
          uint64_t v76 = 0;
          int v77 = 0;
          long long v90 = HGRectNull;
          long long v91 = HGRectNull;
          uint64_t v78 = 0;
          int v79 = 0;
          uint64_t v80 = 0;
          int v81 = 0;
          long long v92 = HGRectNull;
          long long v93 = HGRectNull;
          uint64_t v82 = 0;
          int v83 = 0;
          uint64_t v84 = 0;
          int v85 = 0;
          long long v94 = HGRectNull;
          long long v95 = HGRectNull;
          uint64_t v86 = 0;
          int v87 = 0;
          uint64_t v88 = 0;
          int v89 = 0;
          long long v96 = HGRectNull;
          long long v97 = HGRectNull;
        }
        else
        {
          uint64_t v28 = 0;
          do
          {
            while (1)
            {
              signed int v30 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a6 + 440))(a6, v28);
              uint64_t v31 = *(void *)(*(void *)(a6 + 80) + 8 * v30);
              if (v31)
              {
                if (*(void *)(v31 + 16) && (*(unsigned char *)(v31 + 12) & 0x10) == 0) {
                  break;
                }
              }
              int v29 = &v71 + v30;
              *((void *)v29 + 1CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
              *((_DWORD *)v29 + 22) = 0;
              v29[13] = HGRectNull;
              uint64_t v28 = (v28 + 1);
              if (v28 == 8) {
                goto LABEL_48;
              }
            }
            if (HGRenderer::RenderInputTile(a1, (uint64_t)v68, a3, a4, a5, a6, a7, (uint64_t)&v71, v30)) {
              a3 = 0;
            }
            uint64_t v28 = (v28 + 1);
          }
          while (v28 != 8);
        }
LABEL_48:
        HGNode::RenderTileDispatch((HGNode *)a6, (HGTile *)&v71, v27);
        v69[0] = v99;
        v69[1] = v100;
        uint64_t v70 = v101;
        uint64_t v40 = v69;
      }
      else
      {
        uint64_t v73 = 0;
        long long v71 = 0u;
        long long v72 = 0u;
        HGExecutionUnit::GetStackState((uint64_t)v68, (uint64_t)&v71);
        if (v21 >= (int)v66)
        {
          unsigned int v52 = (HIDWORD(a5) + HIDWORD(a4)) >> 1;
          uint64_t v53 = HGRectMake4i(a4, HIDWORD(a4), a5, v52);
          HGRenderer::RenderTile(a1, v68, a3, v53, v54, a6, a7);
          uint64_t v55 = (v52 - HIDWORD(a4)) * (v66 + a7);
          HGExecutionUnit::CommitStack((uint64_t)v68, (uint64_t)a3, v55);
          uint64_t v44 = HGRectMake4i(a4, v52, a5, HIDWORD(a5));
          uint64_t v46 = v56;
          uint64_t v48 = a1;
          float v49 = v68;
          uint64_t v50 = (uint64_t)&a3[16 * v55];
          uint64_t v51 = a6;
          uint64_t v47 = a7;
        }
        else
        {
          signed int v41 = ((int)a5 + (int)a4) >> 1;
          HGExecutionUnit::CommitStack((uint64_t)v68, (uint64_t)a3, ((v66 + a7) * v21));
          uint64_t v42 = HGRectMake4i(a4, HIDWORD(a4), v41, HIDWORD(a5));
          HGRenderer::RenderTile(a1, v68, a3, v42, v43, a6, (a5 + a7 - v41));
          uint64_t v44 = HGRectMake4i(v41, HIDWORD(a4), a5, HIDWORD(a5));
          uint64_t v46 = v45;
          uint64_t v47 = (a7 - a4 + v41);
          uint64_t v48 = a1;
          float v49 = v68;
          uint64_t v50 = (uint64_t)&a3[16 * v41 + -16 * (int)a4];
          uint64_t v51 = a6;
        }
        HGRenderer::RenderTile(v48, v49, v50, v44, v46, v51, v47);
        v102[0] = v71;
        v102[1] = v72;
        uint64_t v103 = v73;
        uint64_t v40 = v102;
      }
      HGExecutionUnit::SetStackState((uint64_t)v68, v40);
      return;
    }
    unint64_t v64 = HIDWORD(v23);
    uint64_t v73 = 0;
    long long v71 = 0u;
    long long v72 = 0u;
    HGExecutionUnit::GetStackState((uint64_t)v68, (uint64_t)&v71);
    unsigned int v62 = v66 + a7;
    int v63 = a5 - v25;
    HGExecutionUnit::CommitStack((uint64_t)v68, (uint64_t)a3, v21 * ((int)v66 + (int)a7));
    int v61 = (HIDWORD(v23) - HIDWORD(a4)) * (v66 + a7);
    HGRenderer::RenderTile(a1, v68, &a3[16 * v61 + 16 * ((int)v23 - (int)a4)], v23, v25, a6, (v23 - a4 + a7 + a5 - v25));
    uint64_t v33 = (v21 * v66 + (HIDWORD(v25) - HIDWORD(v23)) * (v23 - v25));
    HGStats::ProfilerScopeGuard::ProfilerScopeGuard(&v99, *((void *)v68 + 53), 3, v33, 16 * v33);
    int v34 = HIDWORD(v23) - HIDWORD(a4);
    if (HIDWORD(v23) != HIDWORD(a4))
    {
      if (!a7)
      {
        bzero(a3, 16 * (v34 * v66));
        int v36 = HIDWORD(a5);
        uint64_t v37 = (int)v23 - (int)a4;
        if (HIDWORD(a5) == HIDWORD(v25)) {
          goto LABEL_57;
        }
        unsigned __int8 v38 = &a3[16 * (HIDWORD(v25) - HIDWORD(a4)) * v62];
LABEL_56:
        bzero(v38, 16 * ((v36 - HIDWORD(v25)) * v66));
LABEL_57:
        if ((int)v37 >= 1)
        {
          int v57 = HIDWORD(v25) - v64;
          if (SHIDWORD(v25) > (int)v64)
          {
            uint64_t v58 = &a3[16 * v61];
            do
            {
              bzero(v58, 16 * v37);
              v58 += 16 * v62;
              --v57;
            }
            while (v57);
          }
        }
        if (v63 >= 1)
        {
          int v59 = HIDWORD(v25) - v64;
          if (SHIDWORD(v25) > (int)v64)
          {
            uint64_t v60 = &a3[16 * v61 + 16 * ((int)v25 - (int)a4)];
            do
            {
              bzero(v60, 16 * v63);
              v60 += 16 * v62;
              --v59;
            }
            while (v59);
          }
        }
        v104[0] = v71;
        v104[1] = v72;
        uint64_t v105 = v73;
        HGExecutionUnit::SetStackState((uint64_t)v68, v104);
        int v32 = (HGStats::ProfilerScopeGuard *)&v99;
        goto LABEL_36;
      }
      if (SHIDWORD(v23) > SHIDWORD(a4))
      {
        float32x2_t v35 = a3;
        do
        {
          bzero(v35, 16 * v66);
          v35 += 16 * (v66 + a7);
          --v34;
        }
        while (v34);
      }
    }
    int v36 = v65;
    uint64_t v37 = (int)v23 - (int)a4;
    if (v65 == HIDWORD(v25)) {
      goto LABEL_57;
    }
    unsigned __int8 v38 = &a3[16 * (HIDWORD(v25) - HIDWORD(a4)) * v62];
    if (a7)
    {
      int v39 = v65 - HIDWORD(v25);
      if ((int)v65 > SHIDWORD(v25))
      {
        do
        {
          bzero(v38, 16 * v66);
          v38 += 16 * (v66 + a7);
          --v39;
        }
        while (v39);
      }
      goto LABEL_57;
    }
    goto LABEL_56;
  }
  (*(void (**)(uint64_t, char *, unint64_t, unint64_t, uint64_t))(*(void *)v14 + 72))(v14, a3, a4, a5, a7);
  uint64_t v15 = a2[40];
  uint64_t v16 = *(void *)(a1 + 224);
  if ((int)v15 < (int)((unint64_t)(*(void *)(a1 + 232) - v16) >> 3)
    && (uint64_t v17 = *(const void **)(v16 + 8 * v15)) != 0)
  {
    if (!*(void *)(a6 + 96)) {
      return;
    }
  }
  else
  {
    unint64_t v18 = 0;
    if (!*(void *)(a6 + 96)) {
      return;
    }
  }
  if (DepthBufferManager::hasDepthBuffer(v18))
  {
    unint64_t v19 = *(HGBitmap **)(a6 + 96);
    *(void *)&v20.int var0 = a4;
    *(void *)&v20.int var2 = a5;
    DBM_cpu::setDepthBuffer(v18, v19, v20);
  }
}

void sub_1B77A89C4(_Unwind_Exception *a1)
{
  HGStats::ProfilerScopeGuard::~ProfilerScopeGuard((HGStats::ProfilerScopeGuard *)(v1 - 224));
  _Unwind_Resume(a1);
}

uint64_t HGRenderer::RenderInputTile(uint64_t a1, uint64_t a2, char *a3, unint64_t a4, unint64_t a5, uint64_t a6, unsigned int a7, uint64_t a8, signed int a9)
{
  uint64_t v9 = a8 + 16 * a9;
  if (*(_DWORD *)(a6 + 88) <= a9)
  {
    uint64_t v20 = 0;
    *(void *)(v9 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
    *(_DWORD *)(v9 + 88) = 0;
    return v20;
  }
  uint64_t v11 = *(void *)(*(void *)(a6 + 80) + 8 * a9);
  *(void *)(v9 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  uint64_t v12 = v9 + 80;
  *(_DWORD *)(v12 + 8) = 0;
  if (!v11) {
    return 0;
  }
  int v15 = *(_DWORD *)(v11 + 12);
  if ((v15 & 6) != 0)
  {
    uint64_t v16 = *(void *)(v11 + 48);
    if (v16)
    {
      if ((v15 & 4) != 0)
      {
        uint64_t v19 = 0;
        unint64_t v18 = *(void *)(v16 + 56);
        unint64_t v17 = *(void *)(v16 + 64);
      }
      else
      {
        unint64_t v18 = *(void *)(v16 + 56);
        unint64_t v17 = *(void *)(v16 + 64);
        uint64_t v19 = v17 * (SHIDWORD(a4) - (uint64_t)*(int *)(v16 + 24)) + v18 * ((int)a4 - (uint64_t)*(int *)(v16 + 20));
      }
      *(void *)uint64_t v12 = *(void *)(v16 + 80) + v19;
      *(_DWORD *)(v12 + 8) = v17 / v18;
      *(_OWORD *)(a8 + 16 * a9 + 208) = *(_OWORD *)(v16 + 20);
    }
    uint64_t v36 = *(int *)(a2 + 160);
    uint64_t v37 = *(void *)(a1 + 224);
    if ((int)v36 < (int)((unint64_t)(*(void *)(a1 + 232) - v37) >> 3)
      && (int v39 = *(const void **)(v37 + 8 * v36)) != 0)
    {
      if (!*(void *)(*(void *)(*(void *)(v11 + 16) + 144) + 96)) {
        return 0;
      }
    }
    else
    {
      uint64_t v40 = 0;
      if (!*(void *)(*(void *)(*(void *)(v11 + 16) + 144) + 96)) {
        return 0;
      }
    }
    if (DepthBufferManager::hasDepthBuffer(v40))
    {
      *(void *)&v71.int var0 = a4;
      *(void *)&v71.int var2 = a5;
      DBM_cpu::setDepthBuffer(v40, *(HGBitmap **)(*(void *)(*(void *)(v11 + 16) + 144) + 96), v71);
      return 0;
    }
    return 0;
  }
  unint64_t v67 = HIDWORD(a5);
  unint64_t v69 = HIDWORD(a4);
  unint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t, void, unint64_t))(*(void *)a6 + 400))(a6, a1, a9, a4);
  uint64_t v25 = v24;
  uint64_t v61 = a2;
  unint64_t v62 = HIDWORD(v23);
  int v26 = *(uint64_t **)(a2 + 424);
  int v27 = HIDWORD(v24) - HIDWORD(v23);
  int v63 = v24 - v23;
  uint64_t v28 = ((HIDWORD(v24) - HIDWORD(v23)) * (v24 - v23));
  unint64_t v65 = a4;
  uint64_t v29 = v23;
  HGStats::UnitStats::in_n_out(v26, (HGNode *)a6, a9, v28, ((v67 - HIDWORD(a4)) * (a5 - a4)));
  uint64_t v30 = a8 + 16 * a9;
  *(void *)(v30 + 208) = v29;
  *(void *)(v30 + 216) = v25;
  if (HGRectIsNull(v29, v25)) {
    return 0;
  }
  int v31 = v27;
  if (*(_DWORD *)(a1 + 624) == 2)
  {
    BOOL v32 = 0;
    uint64_t v33 = a5;
    int v34 = a3;
    int v35 = v63;
  }
  else
  {
    char v42 = *(unsigned char *)(a6 + 16);
    uint64_t v33 = a5;
    int v34 = a3;
    int v35 = v63;
    BOOL v32 = (v42 & 1) == 0 && (*(_DWORD *)(v11 + 12) & 1) == 0;
  }
  uint64_t v68 = v31 * (uint64_t)v35;
  uint64_t v59 = v33;
  if (!v34)
  {
    unint64_t v43 = v25;
    uint64_t v20 = 1;
LABEL_33:
    Stacuint64_t k = HGExecutionUnit::GetStack((char ****)v61, v68);
    a7 = 0;
    goto LABEL_34;
  }
  if (!v32 || !HGRectIsEqualSize(v29, v25, a4, v33))
  {
    unint64_t v43 = v25;
    if (HGExecutionUnit::GetStack((char ****)v61, 0) == a3) {
      HGExecutionUnit::SwapStack(v61);
    }
    uint64_t v20 = 0;
    goto LABEL_33;
  }
  unint64_t v43 = v25;
  uint64_t v20 = 1;
  Stacuint64_t k = a3;
LABEL_34:
  uint64_t v45 = v28;
  uint64_t v46 = *(void *)(v11 + 16);
  int v47 = v62;
  if (v46)
  {
    uint64_t v48 = *(void *)(v46 + 144);
    uint64_t v49 = *(void *)(v48 + 192);
    if (v49)
    {
      *(_DWORD *)(v61 + 36) = 0;
      *(_DWORD *)(v61 + 112) = *(_DWORD *)(a1 + 628);
      unint64_t v50 = v29;
      uint64_t v29 = (uint64_t)Stack;
      HGStats::ProfilerScopeGuard::ProfilerScopeGuard(v70, *(void *)(v61 + 424), 1, v45, *(void *)(v49 + 56) * v45);
      uint64_t v51 = (char *)v29;
      unsigned int v52 = (int8x16_t *)v29;
      LODWORD(v29) = v50;
      HGSampler::ReadTile((float32x4_t *)v61, *(_DWORD **)(v48 + 192), 0, v52, v50, v43, a7);
      HGStats::ProfilerScopeGuard::~ProfilerScopeGuard((HGStats::ProfilerScopeGuard *)v70);
      uint64_t v53 = *(int *)(v61 + 160);
      uint64_t v54 = *(void *)(a1 + 224);
      int v35 = v63;
      if ((int)v53 >= (int)((unint64_t)(*(void *)(a1 + 232) - v54) >> 3))
      {
        uint64_t v56 = 0;
        int v47 = v62;
      }
      else
      {
        uint64_t v55 = *(const void **)(v54 + 8 * v53);
        int v47 = v62;
        if (v55) {
        else
        }
          uint64_t v56 = 0;
      }
      Stacuint64_t k = v51;
      if (*(void *)(v48 + 96))
      {
        BOOL hasDepthBuffer = DepthBufferManager::hasDepthBuffer(v56);
        Stacuint64_t k = v51;
        if (hasDepthBuffer)
        {
          *(void *)&v72.int var0 = v65;
          *(void *)&v72.int var2 = v59;
          DBM_cpu::setDepthBuffer(v56, *(HGBitmap **)(v48 + 96), v72);
          Stacuint64_t k = v51;
        }
      }
    }
    else
    {
      int v57 = Stack;
      HGRenderer::RenderTile(a1, v61, Stack, v29, v43, v48, a7);
      Stacuint64_t k = v57;
      int v35 = v63;
    }
  }
  *(_DWORD *)(v12 + 8) = a7 + v35;
  *(void *)uint64_t v12 = &Stack[16 * ((int)v65 - (int)v29) + 16 * ((int)v69 - v47) * (uint64_t)v35];
  HGExecutionUnit::CommitStack(v61, (uint64_t)Stack, v68);
  return v20;
}

void sub_1B77A8F08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  HGStats::ProfilerScopeGuard::~ProfilerScopeGuard((HGStats::ProfilerScopeGuard *)va);
  _Unwind_Resume(a1);
}

HGBuffer *HGRenderer::RenderTiles(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, HGBitmap *a6, int a7)
{
  uint64_t v10 = a4;
  uint64_t v11 = a3;
  if (!HGRectIsNull(a3, a4))
  {
    if (*(_DWORD *)(a1 + 640))
    {
      pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 288));
      pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 288));
    }
    if (!*(_DWORD *)(a1 + 636))
    {
      if (a7 && !*(unsigned char *)(a1 + 808))
      {
        uint64_t v11 = HGRectIntersection(*(void *)(a2 + 152), *(void *)(a2 + 160), v11, v10);
        uint64_t v10 = v16;
      }
      if (a6)
      {
        uint64_t v14 = (HGBuffer *)HGObject::operator new(0x80uLL);
        *(void *)&v31.int var0 = v11;
        *(void *)&v31.int var2 = v10;
        HGBuffer::HGBuffer(v14, v31, a6);
        if (*(unsigned char *)(a2 + 105))
        {
LABEL_12:
          BOOL v17 = *(unsigned char *)(a1 + 810) != 0;
          goto LABEL_15;
        }
      }
      else
      {
        uint64_t v14 = (HGBuffer *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 136))(a1, v11, v10, a5);
        if (*(unsigned char *)(a2 + 105)) {
          goto LABEL_12;
        }
      }
      BOOL v17 = 0;
LABEL_15:
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 488));
      v30[0] = v11;
      v30[1] = v10;
      v30[2] = v14;
      void v30[3] = a2;
      *(void *)(a1 + 272) = v30;
      LODWORD(v18) = *(_DWORD *)(a1 + 596);
      if (v17)
      {
        if ((int)v18 < 1)
        {
LABEL_39:
          *(void *)(a1 + 272) = 0;
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 488));
          return v14;
        }
        uint64_t v19 = 0;
        do
        {
          uint64_t v21 = *(void *)(a1 + 224);
          if (v19 < (int)((unint64_t)(*(void *)(a1 + 232) - v21) >> 3)
            && (unint64_t v22 = *(const void **)(v21 + 8 * v19)) != 0)
          {
          }
          else
          {
            uint64_t v20 = 0;
          }
          (*(void (**)(void *))(*(void *)v20 + 24))(v20);
          DBM_cpu::bufferHint((uint64_t)v20, *(void *)(a2 + 96));
          ++v19;
          uint64_t v18 = *(int *)(a1 + 596);
        }
        while (v19 < v18);
      }
      if ((int)v18 >= 1)
      {
        uint64_t v23 = 0;
        do
        {
          HGExecutionUnit::BgnExec(*(HGExecutionUnit **)(*(void *)(a1 + 248) + 8 * v23++));
          uint64_t v18 = *(int *)(a1 + 596);
        }
        while (v23 < v18);
        if ((int)v18 >= 1)
        {
          for (uint64_t i = 0; i < v18; ++i)
          {
            HGExecutionUnit::EndExec(*(pthread_cond_t **)(*(void *)(a1 + 248) + 8 * i));
            uint64_t v18 = *(int *)(a1 + 596);
          }
        }
      }
      BOOL v25 = (int)v18 < 1;
      char v26 = !v17;
      if (v25) {
        char v26 = 1;
      }
      if ((v26 & 1) == 0)
      {
        uint64_t v27 = 0;
        do
        {
          uint64_t v29 = *(void *)(a1 + 224);
          if (v27 >= (int)((unint64_t)(*(void *)(a1 + 232) - v29) >> 3))
          {
            uint64_t v28 = 0;
          }
          else
          {
            uint64_t v28 = *(void **)(v29 + 8 * v27);
            if (v28) {
          }
            }
          (*(void (**)(void *))(*(void *)v28 + 32))(v28);
          ++v27;
        }
        while (v27 < *(int *)(a1 + 596));
      }
      goto LABEL_39;
    }
  }
  return 0;
}

void sub_1B77A9258(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

_DWORD *HGRenderer::MarkBufferedOutput(_DWORD *this, HGNode *a2)
{
  int v3 = this[153];
  if (v3 == 2)
  {
    *((unsigned char *)a2 + 104) = 0;
    return this;
  }
  uint64_t v4 = *((int *)a2 + 44) - (uint64_t)*((int *)a2 + 42);
  uint64_t v5 = *((int *)a2 + 45) - (uint64_t)*((int *)a2 + 43);
  if (v3 == 1)
  {
    if ((*((unsigned char *)a2 + 16) & 0x84) == 0) {
      goto LABEL_20;
    }
LABEL_24:
    *((unsigned char *)a2 + 104) = 1;
    return this;
  }
  int v6 = *((_DWORD *)a2 + 4);
  if ((v6 & 8) != 0) {
    goto LABEL_17;
  }
  if ((v6 & 2) != 0)
  {
    LOBYTE(v3) = 1;
    if ((*((unsigned char *)a2 + 16) & 0x84) == 0) {
      goto LABEL_20;
    }
    goto LABEL_24;
  }
  if (*((int *)a2 + 52) < 2)
  {
LABEL_17:
    LOBYTE(v3) = 0;
    if ((*((unsigned char *)a2 + 16) & 0x84) != 0) {
      goto LABEL_24;
    }
  }
  else
  {
    this = (_DWORD *)(*(uint64_t (**)(_DWORD *, uint64_t))(*(void *)this + 128))(this, 27);
    LOBYTE(v3) = v4 <= (int)this && v5 <= (int)this;
    if ((*((unsigned char *)a2 + 16) & 0x84) != 0) {
      goto LABEL_24;
    }
  }
LABEL_20:
  if (*((_DWORD *)a2 + 54) == -1) {
    goto LABEL_24;
  }
  if (v5 * v4 < 1) {
    LOBYTE(v3) = 1;
  }
  *((unsigned char *)a2 + 104) = v3;
  return this;
}

uint64_t HGRenderer::RenderBufferedInput(HGRenderer *this, HGNode *a2, int a3)
{
  uint64_t v3 = *(void *)(*((void *)a2 + 10) + 8 * a3);
  if (!v3 || (*(unsigned char *)(v3 + 12) & 6) == 0 || HGRectIsNull(*(void *)(v3 + 32), *(void *)(v3 + 40))) {
    return 0;
  }
  uint64_t v7 = *(void *)(v3 + 16);
  uint64_t v9 = *(void *)(v3 + 32);
  uint64_t v8 = *(void *)(v3 + 40);
  uint64_t v10 = HGFormatUtils::buildFormat(*((_DWORD *)a2 + 8), 8);
  if (v7)
  {
    uint64_t v11 = v10;
    uint64_t v12 = *(void *)(*(void *)(v7 + 144) + 192);
    if (v12
      && *(_DWORD *)(v12 + 16) == v10
      && (*(void *)&v14.var0 = v9, *(void *)&v14.int var2 = v8, HGRect::ContainsRect((HGRect *)(v12 + 20), v14))
      && (*(unsigned char *)(v12 + 80) & 0xF) == 0)
    {
      uint64_t v13 = (HGBuffer *)HGObject::operator new(0x80uLL);
      *(void *)&v15.int var0 = v9;
      *(void *)&v15.int var2 = v8;
      HGBuffer::HGBuffer(v13, v15, (HGBitmap *)v12);
    }
    else
    {
      (*(void (**)(void, HGRenderer *))(**(void **)(v7 + 144) + 416))(*(void *)(v7 + 144), this);
      uint64_t v13 = (HGBuffer *)(*(uint64_t (**)(HGRenderer *, void, uint64_t, uint64_t, uint64_t, void, void, BOOL))(*(void *)this + 168))(this, *(void *)(v7 + 144), v9, v8, v11, 0, 0, (*(_DWORD *)(v3 + 12) & 0x2000) == 0);
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  *(void *)(v3 + 48) = v13;
  return 1;
}

void sub_1B77A952C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

BOOL HGRenderer::RenderBufferedOutput(HGRenderer *this, HGNode *a2)
{
  int v2 = *((unsigned __int8 *)a2 + 104);
  if (!*((unsigned char *)a2 + 104)) {
    return v2 != 0;
  }
  int v5 = *((_DWORD *)a2 + 8);
  if ((*((unsigned char *)a2 + 16) & 0x84) != 0
    || (*((int *)a2 + 45) - (uint64_t)*((int *)a2 + 43)) * (*((int *)a2 + 44) - (uint64_t)*((int *)a2 + 42)) <= 0)
  {
    int v7 = 8;
  }
  else
  {
    if (v5 == 4 && *((_DWORD *)a2 + 9) == 15)
    {
      uint64_t v8 = (*(uint64_t (**)(HGNode *, void))(*(void *)a2 + 296))(a2, *((unsigned int *)this + 144));
      goto LABEL_13;
    }
    uint64_t v9 = (HGFormatUtils *)HGFormatUtils::precision(*((_DWORD *)this + 144));
    int v7 = HGFormatUtils::adjustPrecision(v9, *((_DWORD *)a2 + 9));
    int v5 = *((_DWORD *)a2 + 8);
  }
  uint64_t v8 = HGFormatUtils::buildFormat(v5, v7);
LABEL_13:
  uint64_t v10 = v8;
  (*(void (**)(HGNode *, HGRenderer *))(*(void *)a2 + 416))(a2, this);
  (*(void (**)(HGNode *, HGRenderer *, uint64_t))(*(void *)a2 + 336))(a2, this, 1);
  uint64_t v11 = *((void *)a2 + 24);
  if (v11)
  {
    (*(void (**)(uint64_t))(*(void *)v11 + 16))(v11);
    return v2 != 0;
  }
  *((void *)a2 + 24) = (*(uint64_t (**)(HGRenderer *, HGNode *, void, void, uint64_t, void, void, BOOL))(*(void *)this + 168))(this, a2, *((void *)a2 + 21), *((void *)a2 + 22), v10, 0, 0, (*((_DWORD *)a2 + 4) & 0x2000) == 0);
  return v2 != 0;
}

uint64_t HGRenderer::GetOutputFormat(HGRenderer *this, HGNode *a2)
{
  if (*((_DWORD *)a2 + 8) == 4 && *((_DWORD *)a2 + 9) == 15)
  {
    uint64_t v3 = *((unsigned int *)this + 144);
    uint64_t v4 = *(uint64_t (**)(HGNode *, uint64_t))(*(void *)a2 + 296);
    return v4(a2, v3);
  }
  else
  {
    int v6 = (HGFormatUtils *)HGFormatUtils::precision(*((_DWORD *)this + 144));
    int v7 = HGFormatUtils::adjustPrecision(v6, *((_DWORD *)a2 + 9));
    int v8 = *((_DWORD *)a2 + 8);
    return HGFormatUtils::buildFormat(v8, v7);
  }
}

uint64_t HGRenderer::ReleaseBufferedInput(HGRenderer *this, HGNode *a2, int a3)
{
  uint64_t v3 = *(void *)(*((void *)a2 + 10) + 8 * a3);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(v3 + 48);
  if (!v4) {
    return 0;
  }
  unint64_t v8 = *(void *)(*(void *)(v3 + 16) + 144);
  unsigned int v9 = *(_DWORD *)(v4 + 16) - 24;
  if (v9 <= 4) {
    HGDotGraph::filled((uint64_t)this + 840, *(void *)(*(void *)(v3 + 16) + 144), HGRenderer::DotLogNodeBufferFormat(HGNode *,HGBitmap *)::formatString[v9]);
  }
  if (*(unsigned char *)(v4 + 12)) {
    HGDotGraph::outline((uint64_t)this + 840, v8, "limegreen");
  }
  HGRenderer::DotLogBufferOutput((uint64_t *)this, *(HGBitmap **)(*(void *)(v3 + 16) + 144), *(HGBitmap **)(v3 + 48));
  if ((*(unsigned char *)(*(void *)(v3 + 48) + 12) & 0x30) == 0)
  {
    uint64_t v10 = (HGRenderer *)((char *)this + 928);
    if (HGBufferDumper::on(v10))
    {
      uint64_t v11 = (const char *)(*(uint64_t (**)(HGNode *))(*(void *)a2 + 48))(a2);
      HGBufferDumper::write(v10, v11, a3, *(HGBitmap **)(v3 + 48));
    }
  }
  (*(void (**)(void))(**(void **)(v3 + 48) + 24))(*(void *)(v3 + 48));
  *(void *)(v3 + 48) = 0;
  return 1;
}

uint64_t HGRenderer::DotLogNodeBufferFormat(uint64_t this, HGNode *a2, HGBitmap *a3)
{
  uint64_t v5 = this;
  unsigned int v6 = *((_DWORD *)a3 + 4) - 24;
  if (v6 <= 4) {
    this = HGDotGraph::filled(this + 840, (unint64_t)a2, HGRenderer::DotLogNodeBufferFormat(HGNode *,HGBitmap *)::formatString[v6]);
  }
  if (*((unsigned char *)a3 + 12))
  {
    return HGDotGraph::outline(v5 + 840, (unint64_t)a2, "limegreen");
  }
  return this;
}

uint64_t *HGRenderer::DotLogBufferOutput(uint64_t *this, HGBitmap *a2, HGBitmap *a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (*((int *)this + 164) < 3) {
    return this;
  }
  uint64_t v5 = this;
  int v6 = *((_DWORD *)a3 + 3);
  if (v6)
  {
    CVBitmapStorage = (uint64_t *)HGCVBitmap::getCVBitmapStorage(a3, a2);
    goto LABEL_6;
  }
  int v7 = (uint64_t *)a3;
  if ((v6 & 0x20) != 0)
  {
    CVBitmapStorage = (uint64_t *)HGMetalTexture::getMetalStorage(a3, a2);
LABEL_6:
    int v7 = CVBitmapStorage;
  }
  unsigned int v9 = "GL";
  int v11 = *((_DWORD *)a3 + 3);
  int v10 = *((_DWORD *)a3 + 4);
  if ((v11 & 0x10) == 0) {
    unsigned int v9 = "(bmp)";
  }
  if ((v11 & 0x20) != 0) {
    unsigned int v9 = "MTL";
  }
  if ((v11 & 0x30) == 0) {
    unsigned int v9 = "CPU";
  }
  if (v11) {
    uint64_t v12 = "IOS";
  }
  else {
    uint64_t v12 = v9;
  }
  int v13 = *((_DWORD *)a3 + 8);
  int v14 = *((_DWORD *)a3 + 6);
  int v15 = *((_DWORD *)a3 + 7) - *((_DWORD *)a3 + 5);
  int v16 = v13 - v14;
  BOOL v17 = (const char *)HGFormatUtils::toString(v10);
  snprintf(__str, 0x40uLL, "{ %s | %dx%d | %s }", v12, v15, v16, v17);
  uint64_t v18 = v5 + 105;
  HGDotGraph::node(v18, (unint64_t)v7, (uint64_t)"bitmap", 0);
  HGDotGraph::filled((uint64_t)v18, (unint64_t)v7, "#e0e0e0");
  HGDotGraph::fontSize(v18, (unint64_t)v7, 9);
  HGDotGraph::link(v18, (unint64_t)a2, (unint64_t)v7, "", 1);
  HGDotGraph::linkStyle(v18, (uint64_t *)a2, v7, 1, 0);
  return HGDotGraph::record(v18, (unint64_t)v7, __str);
}

BOOL HGRenderer::ReleaseBufferedOutput(HGRenderer *this, HGNode *a2)
{
  uint64_t v2 = *((void *)a2 + 24);
  if (v2)
  {
    unsigned int v5 = *(_DWORD *)(v2 + 16) - 24;
    if (v5 <= 4) {
      HGDotGraph::filled((uint64_t)this + 840, (unint64_t)a2, HGRenderer::DotLogNodeBufferFormat(HGNode *,HGBitmap *)::formatString[v5]);
    }
    if (*(unsigned char *)(v2 + 12)) {
      HGDotGraph::outline((uint64_t)this + 840, (unint64_t)a2, "limegreen");
    }
    HGRenderer::DotLogBufferOutput((uint64_t *)this, (HGBitmap *)a2, *((HGBitmap **)a2 + 24));
    if (HGBufferDumper::on((HGRenderer *)((char *)this + 928)))
    {
      uint64_t v6 = (*(uint64_t (**)(HGRenderer *, void, void))(*(void *)this + 96))(this, *((void *)a2 + 24), *(unsigned int *)(*((void *)a2 + 24) + 16));
      CVBitmapStorage = (HGCVBitmap *)HGCVBitmap::getCVBitmapStorage((HGBitmap *)v6, v7);
      if (CVBitmapStorage)
      {
        unsigned int v9 = (HGBitmap *)CVBitmapStorage;
        HGCVBitmap::lock(CVBitmapStorage, 1uLL);
        int v10 = (const char *)(*(uint64_t (**)(HGNode *))(*(void *)a2 + 48))(a2);
        HGBufferDumper::write((HGRenderer *)((char *)this + 928), v10, -1, v9);
        HGCVBitmap::unlock((HGCVBitmap *)v9, 1uLL);
      }
      else if (*(void *)(v6 + 80))
      {
        int v11 = (const char *)(*(uint64_t (**)(HGNode *))(*(void *)a2 + 48))(a2);
        HGBufferDumper::write((HGRenderer *)((char *)this + 928), v11, -1, (HGBitmap *)v6);
      }
      (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
    }
    (*(void (**)(HGNode *, HGRenderer *, void))(*(void *)a2 + 424))(a2, this, *((void *)a2 + 24));
    (*(void (**)(void))(**((void **)a2 + 24) + 24))(*((void *)a2 + 24));
    *((void *)a2 + 24) = 0;
  }
  return v2 != 0;
}

uint64_t HGRenderer::FinalizeInputsOfBufferedNodes(uint64_t this, HGNode *a2)
{
  int v2 = *((_DWORD *)a2 + 22);
  if (v2 >= 1)
  {
    uint64_t v4 = this;
    for (uint64_t i = 0; i < v2; ++i)
    {
      uint64_t v6 = *(void *)(*((void *)a2 + 10) + 8 * i);
      if (v6)
      {
        uint64_t v7 = *(void *)(v6 + 16);
        if (v7)
        {
          if (*((void *)a2 + 24) || *(void *)(v6 + 48))
          {
            this = (*(uint64_t (**)(uint64_t, void))(*(void *)v4 + 248))(v4, *(void *)(v7 + 144));
            int v2 = *((_DWORD *)a2 + 22);
          }
        }
      }
    }
  }
  return this;
}

uint64_t HGRenderer::RenderTilesBegin(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 212);
  *(_DWORD *)(a2 + 212) = v2 + 1;
  if (!v2)
  {
    uint64_t v4 = (unsigned int *)result;
    ++*(_DWORD *)(result + 696);
    int v5 = *(_DWORD *)(a2 + 16);
    if ((v5 & 0x20000) != 0) {
      *(_DWORD *)(a2 + 16) = v5 | 0x82;
    }
    int v6 = *(_DWORD *)(a2 + 88);
    if (v6 > 0)
    {
      for (uint64_t i = 0; i < v6; ++i)
      {
        uint64_t v8 = *(void *)(*(void *)(a2 + 80) + 8 * i);
        if (v8)
        {
          uint64_t v9 = *(void *)(v8 + 16);
          if (v9)
          {
            if ((*(unsigned char *)(a2 + 18) & 2) != 0) {
              *(_DWORD *)(v8 + 12) |= 2u;
            }
            (*(void (**)(unsigned int *, void, void, void, void))(*(void *)v4 + 240))(v4, *(void *)(v9 + 144), *(void *)(v8 + 32), *(void *)(v8 + 40), v4[144]);
            int v6 = *(_DWORD *)(a2 + 88);
          }
        }
      }
    }
    (*(void (**)(unsigned int *, uint64_t, void))(*(void *)v4 + 320))(v4, a2, 0);
    if (HGRectIsNull(*(void *)(a2 + 168), *(void *)(a2 + 176)))
    {
      int v10 = *(uint64_t (**)(unsigned int *, uint64_t))(*(void *)v4 + 232);
      return v10(v4, a2);
    }
    else
    {
      if (*(int *)(a2 + 88) >= 1)
      {
        uint64_t v11 = 0;
        do
        {
          (*(void (**)(unsigned int *, uint64_t, uint64_t))(*(void *)v4 + 200))(v4, a2, v11);
          uint64_t v11 = (v11 + 1);
        }
        while ((int)v11 < *(_DWORD *)(a2 + 88));
      }
      (*(void (**)(unsigned int *, uint64_t))(*(void *)v4 + 192))(v4, a2);
      (*(void (**)(unsigned int *, uint64_t))(*(void *)v4 + 208))(v4, a2);
      uint64_t result = (*(uint64_t (**)(unsigned int *, uint64_t))(*(void *)v4 + 232))(v4, a2);
      if (*(_DWORD *)(a2 + 40) != 1)
      {
        uint64_t v12 = *(uint64_t (**)(uint64_t, unsigned int *, uint64_t))(*(void *)a2 + 336);
        return v12(a2, v4, 1);
      }
    }
  }
  return result;
}

uint64_t HGRenderer::GenProgram(HGRenderer *this, HGNode *a2)
{
  uint64_t result = HGNode::SupportsSWAIR(a2);
  if (result)
  {
    uint64_t v4 = (*(uint64_t (**)(HGNode *))(*(void *)a2 + 224))(a2);
    *((void *)a2 + 9) = v4;
    if (v4)
    {
      return 0;
    }
    else
    {
      int v5 = (const char *)(*(uint64_t (**)(HGNode *))(*(void *)a2 + 48))(a2);
      int v6 = strdup(v5);
      HGLogger::warning((HGLogger *)"Missing swair program for node: %s", v7, v8, v6);
      free(v6);
      return 1;
    }
  }
  return result;
}

uint64_t *HGRenderer::RenderTilesEnd(uint64_t *this, HGNode *a2)
{
  int v2 = *((_DWORD *)a2 + 52) - 1;
  *((_DWORD *)a2 + 52) = v2;
  if (!v2)
  {
    uint64_t v4 = this;
    *((_DWORD *)a2 + 53) = 0;
    if (*((int *)a2 + 22) > 0)
    {
      uint64_t v5 = 0;
      do
      {
        uint64_t v6 = *(void *)(*((void *)a2 + 10) + 8 * v5);
        if (v6)
        {
          if (*(void *)(v6 + 48))
          {
            (*(void (**)(uint64_t *, HGNode *, uint64_t))(*v4 + 216))(v4, a2, v5);
          }
          else if (!*((void *)a2 + 24))
          {
            uint64_t v7 = *(void *)(v6 + 16);
            if (v7) {
              (*(void (**)(uint64_t *, void))(*v4 + 248))(v4, *(void *)(v7 + 144));
            }
          }
        }
        ++v5;
      }
      while (v5 < *((int *)a2 + 22));
    }
    this = (uint64_t *)(*(uint64_t (**)(uint64_t *, HGNode *))(*v4 + 224))(v4, a2);
    if (*((_DWORD *)a2 + 10) != 2)
    {
      (*(void (**)(HGNode *, uint64_t *, uint64_t))(*(void *)a2 + 336))(a2, v4, 2);
      uint64_t v8 = (uint64_t *)v4[70];
      uint64_t v9 = (uint64_t *)((*((_DWORD *)a2 + 45) - *((_DWORD *)a2 + 43))
                                   * (*((_DWORD *)a2 + 44) - *((_DWORD *)a2 + 42)));
      return HGStats::GraphStats::roiPixels(v8, a2, v9);
    }
  }
  return this;
}

uint64_t HGRenderer::RenderNode(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  a1[2] = a2;
  (*(void (**)(void *))(*a1 + 184))(a1);
  (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(*a1 + 240))(a1, a2, a3, a4, a5);
  uint64_t v12 = (*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, BOOL))(*a1 + 168))(a1, a2, a3, a4, a5, a6, 1, (*(_DWORD *)(a2 + 16) & 0x2000) == 0);
  (*(void (**)(void *, uint64_t))(*a1 + 248))(a1, a2);
  return v12;
}

HGRenderer *HGRenderer::RenderNodeBgn(HGRenderer *this, HGNode *a2, int a3)
{
  uint64_t v5 = this;
  while (1)
  {
    int v6 = *((_DWORD *)a2 + 52);
    if (v6) {
      break;
    }
    *((_DWORD *)a2 + 54) = a3;
    *((void *)a2 + 26) = 1;
    uint64_t v7 = *((unsigned int *)a2 + 22);
    if ((int)v7 >= 2)
    {
      unint64_t v8 = v7 + 1;
      do
      {
        uint64_t v9 = *(void *)(*((void *)a2 + 10) + 8 * (v8 - 2));
        if (v9)
        {
          uint64_t v10 = *(void *)(v9 + 16);
          if (v10) {
            this = (HGRenderer *)HGRenderer::RenderNodeBgn(v5, *(HGNode **)(v10 + 144), a3);
          }
        }
        --v8;
      }
      while (v8 > 2);
    }
    uint64_t v11 = (uint64_t *)*((void *)a2 + 10);
    if (v11)
    {
      uint64_t v12 = *v11;
      if (v12)
      {
        uint64_t v13 = *(void *)(v12 + 16);
        if (v13)
        {
          a2 = *(HGNode **)(v13 + 144);
          if (a2) {
            continue;
          }
        }
      }
    }
    return this;
  }
  if (*((_DWORD *)a2 + 54) != a3) {
    *((_DWORD *)a2 + 54) = -1;
  }
  *((_DWORD *)a2 + 52) = v6 + 1;
  return this;
}

HGRenderer *HGRenderer::RenderNodeEnd(HGRenderer *this, HGNode *a2)
{
  uint64_t v3 = this;
  do
  {
    if (!*((_DWORD *)a2 + 52)) {
      break;
    }
    *((void *)a2 + 26) = 0;
    *((_DWORD *)a2 + 34) &= ~8u;
    uint64_t v4 = *((unsigned int *)a2 + 22);
    if ((int)v4 >= 2)
    {
      unint64_t v5 = v4 + 1;
      do
      {
        uint64_t v6 = *(void *)(*((void *)a2 + 10) + 8 * (v5 - 2));
        if (v6)
        {
          uint64_t v7 = *(void *)(v6 + 16);
          if (v7) {
            this = (HGRenderer *)HGRenderer::RenderNodeEnd(v3, *(HGNode **)(v7 + 144));
          }
        }
        --v5;
      }
      while (v5 > 2);
    }
    unint64_t v8 = (uint64_t *)*((void *)a2 + 10);
    if (v8)
    {
      uint64_t v9 = *v8;
      if (v9)
      {
        a2 = *(HGNode **)(v9 + 16);
        if (!a2) {
          break;
        }
      }
    }
    a2 = (HGNode *)*((void *)a2 + 18);
  }
  while (a2);
  return this;
}

uint64_t HGRenderer::SetROI(HGRenderer *this, HGNode *a2, HGRect a3, int a4, uint64_t a5)
{
  uint64_t v7 = *(void *)&a3.var2;
  uint64_t v8 = *(void *)&a3.var0;
  uint64_t v11 = 0;
  do
  {
    uint64_t DOD = HGRenderer::GetDOD(this, a2);
    uint64_t v14 = HGRectIntersection(v8, v7, DOD, v13);
    unint64_t v18 = v14;
    unint64_t v19 = v15;
    if (*((_DWORD *)a2 + 53))
    {
      *((void *)a2 + 21) = HGRectUnion(*((void *)a2 + 21), *((void *)a2 + 22), v14, v15);
      *((void *)a2 + 22) = v20;
      ++*((_DWORD *)a2 + 53);
      if (*((int *)this + 161) < 1) {
        goto LABEL_15;
      }
    }
    else
    {
      *((void *)a2 + 21) = v14;
      *((void *)a2 + 22) = v15;
      *((_DWORD *)a2 + 53) = 1;
      if (*((int *)this + 161) < 1) {
        goto LABEL_15;
      }
    }
    uint64_t v21 = (*(uint64_t (**)(HGNode *))(*(void *)a2 + 48))(a2);
    HGLogger::log((HGLogger *)"graph", (const char *)1, (HGLogger *)"%d: %p = %s: ROI [%d %d %d %d] DOD [%d %d %d %d]\n", v22, v23, a5, a2, v21, v18, HIDWORD(v18), v19, HIDWORD(v19), *((unsigned int *)a2 + 38), *((unsigned int *)a2 + 39), *((unsigned int *)a2 + 40), *((unsigned int *)a2 + 41));
    int v25 = *((_DWORD *)this + 161);
    if (v25 < 2)
    {
LABEL_15:
      uint64_t v27 = *((unsigned int *)a2 + 53);
      if (v27 != *((_DWORD *)a2 + 52)) {
        return HGLogger::indent(v11);
      }
      goto LABEL_16;
    }
    char v44 = 0;
    LOBYTE(v43) = 0;
    HGLogger::getNewlinePreamble((uint64_t *)v41, v24);
    (*(void (**)(void **__return_ptr, HGNode *, void, void **, void **))(*(void *)a2 + 64))(__p, a2, (v25 - 1), &v43, v41);
    if (v40 < 0)
    {
      if (!__p[1]) {
        goto LABEL_29;
      }
      char v26 = (void **)__p[0];
    }
    else
    {
      if (!v40) {
        goto LABEL_13;
      }
      char v26 = __p;
    }
    HGLogger::log((HGLogger *)"graph", (const char *)*((unsigned int *)this + 161), (HGLogger *)"%s\n", v16, v17, v26);
    if ((v40 & 0x80000000) == 0)
    {
LABEL_13:
      if ((v42 & 0x80000000) == 0) {
        goto LABEL_14;
      }
      goto LABEL_30;
    }
LABEL_29:
    operator delete(__p[0]);
    if ((v42 & 0x80000000) == 0)
    {
LABEL_14:
      if ((v44 & 0x80000000) == 0) {
        goto LABEL_15;
      }
      goto LABEL_31;
    }
LABEL_30:
    operator delete(v41[0]);
    if ((v44 & 0x80000000) == 0) {
      goto LABEL_15;
    }
LABEL_31:
    operator delete(v43);
    uint64_t v27 = *((unsigned int *)a2 + 53);
    if (v27 != *((_DWORD *)a2 + 52)) {
      return HGLogger::indent(v11);
    }
LABEL_16:
    *((_DWORD *)a2 + 53) = 0;
    *((_DWORD *)a2 + 34) |= 8u;
    if ((int)v27 >= 2 && *((int *)this + 161) >= 1) {
      HGLogger::log((HGLogger *)"graph", (const char *)1, (HGLogger *)" + Total ROI from %d branches [%d %d %d %d]\n", v16, v17, v27, *((unsigned int *)a2 + 42), *((unsigned int *)a2 + 43), *((unsigned int *)a2 + 44), *((unsigned int *)a2 + 45));
    }
    HGLogger::indent(1);
    ++a4;
    uint64_t v28 = *((unsigned int *)a2 + 22);
    if ((int)v28 > 1)
    {
      do
      {
        uint64_t v35 = *(void *)(*((void *)a2 + 10) + 8 * --v28);
        if (v35 && *(void *)(v35 + 16))
        {
          *(void *)&v45.int var0 = (*(uint64_t (**)(HGNode *, HGRenderer *, uint64_t, void, void))(*(void *)a2 + 400))(a2, this, v28, *((void *)a2 + 21), *((void *)a2 + 22));
          *(void *)&v45.int var2 = v36;
          uint64_t v37 = *(void *)(*((void *)a2 + 10) + 8 * v28);
          *(void *)(v37 + 32) = *(void *)&v45.var0;
          *(void *)(v37 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = v36;
          HGRenderer::SetROI(this, *(HGNode **)(*(void *)(*(void *)(*((void *)a2 + 10) + 8 * v28) + 16) + 144), v45, a4, v28);
        }
      }
      while ((unint64_t)(v28 + 1) > 2);
    }
    uint64_t v11 = (v11 - 1);
    uint64_t v29 = (uint64_t *)*((void *)a2 + 10);
    if (!v29) {
      break;
    }
    uint64_t v30 = *v29;
    if (!v30) {
      break;
    }
    uint64_t v31 = *(void *)(v30 + 16);
    if (!v31) {
      break;
    }
    BOOL v32 = *(HGNode **)(v31 + 144);
    uint64_t v8 = (*(uint64_t (**)(HGNode *, HGRenderer *, void, void, void))(*(void *)a2 + 400))(a2, this, 0, *((void *)a2 + 21), *((void *)a2 + 22));
    uint64_t v7 = v33;
    a5 = 0;
    uint64_t v34 = **((void **)a2 + 10);
    *(void *)(v34 + 32) = v8;
    *(void *)(v34 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = v33;
    a2 = v32;
  }
  while (v32);
  return HGLogger::indent(v11);
}

void sub_1B77AA97C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a26 < 0)
  {
    operator delete(__p);
    if ((a32 & 0x80000000) == 0)
    {
LABEL_3:
      if ((*(char *)(v32 - 89) & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else if ((a32 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a27);
  if ((*(char *)(v32 - 89) & 0x80000000) == 0) {
LABEL_4:
  }
    _Unwind_Resume(exception_object);
LABEL_7:
  operator delete(*(void **)(v32 - 112));
  _Unwind_Resume(exception_object);
}

uint64_t HGRenderer::GetDOD(HGRenderer *this, HGNode *a2)
{
  Output = HGRenderer::GetOutput(this, a2);
  uint64_t v4 = &HGRectNull;
  if (Output)
  {
    unint64_t v5 = Output;
    if ((*((unsigned char *)Output + 136) & 4) == 0)
    {
      int v6 = *((_DWORD *)Output + 22);
      if (v6 < 1) {
        goto LABEL_13;
      }
      uint64_t v7 = 0;
      int v8 = 0;
      do
      {
        uint64_t v9 = *(void *)(*((void *)v5 + 10) + 8 * v7);
        if (v9)
        {
          uint64_t v10 = *(void *)(v9 + 16);
          if (v10)
          {
            uint64_t DOD = HGRenderer::GetDOD(this, *(HGNode **)(v10 + 144));
            uint64_t v14 = (*(uint64_t (**)(HGNode *, HGRenderer *, uint64_t, uint64_t, uint64_t))(*(void *)v5 + 392))(v5, this, v7, DOD, v12);
            uint64_t v15 = v13;
            if (v8)
            {
              uint64_t v14 = HGRectUnion(*((void *)v5 + 19), *((void *)v5 + 20), v14, v13);
              uint64_t v15 = v16;
            }
            *((void *)v5 + 19) = v14;
            *((void *)v5 + 2CVOpenGLESTextureCacheFlush(this[3], 0) = v15;
            int v8 = 1;
            int v6 = *((_DWORD *)v5 + 22);
          }
        }
        ++v7;
      }
      while (v7 < v6);
      if (!v8)
      {
LABEL_13:
        *((void *)v5 + 19) = (*(uint64_t (**)(HGNode *, HGRenderer *, void, void, void))(*(void *)v5 + 392))(v5, this, 0, 0, 0);
        *((void *)v5 + 2CVOpenGLESTextureCacheFlush(this[3], 0) = v17;
      }
      *((_DWORD *)v5 + 34) |= 4u;
    }
    uint64_t v4 = (long long *)((char *)v5 + 152);
  }
  return *(void *)v4;
}

uint64_t HGRenderer::SetTilesROI(HGRenderer *this, HGNode *a2, HGRect a3)
{
  uint64_t v3 = *(void *)&a3.var2;
  uint64_t v4 = *(void *)&a3.var0;
  uint64_t DOD = HGRenderer::GetDOD(this, a2);
  uint64_t result = HGRectIntersection(v4, v3, DOD, v8);
  if (*((_DWORD *)a2 + 60))
  {
    uint64_t result = HGRectUnion(*(void *)((char *)a2 + 220), *(void *)((char *)a2 + 228), result, v10);
    *(void *)((char *)a2 + 22CVOpenGLESTextureCacheFlush(this[3], 0) = result;
    *(void *)((char *)a2 + 228) = v11;
    int v12 = *((_DWORD *)a2 + 59);
    int v13 = *((_DWORD *)a2 + 60) + 1;
    *((_DWORD *)a2 + 6CVOpenGLESTextureCacheFlush(this[3], 0) = v13;
    if (v13 != v12) {
      return result;
    }
  }
  else
  {
    *(void *)((char *)a2 + 22CVOpenGLESTextureCacheFlush(this[3], 0) = result;
    *(void *)((char *)a2 + 228) = v10;
    *((_DWORD *)a2 + 6CVOpenGLESTextureCacheFlush(this[3], 0) = 1;
    if (*((_DWORD *)a2 + 59) != 1) {
      return result;
    }
  }
  *((_DWORD *)a2 + 6CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  uint64_t v14 = *((unsigned int *)a2 + 22);
  if ((int)v14 >= 1)
  {
    do
    {
      uint64_t v15 = *(void *)(*((void *)a2 + 10) + 8 * --v14);
      if (v15)
      {
        if (*(void *)(v15 + 16))
        {
          *(void *)&v17.int var0 = (*(uint64_t (**)(HGNode *, HGRenderer *, uint64_t, void, void))(*(void *)a2 + 400))(a2, this, v14, *(void *)((char *)a2 + 220), *(void *)((char *)a2 + 228));
          *(void *)&v17.int var2 = v16;
          uint64_t result = HGRenderer::SetTilesROI(this, *(HGNode **)(*(void *)(*(void *)(*((void *)a2 + 10) + 8 * v14) + 16) + 144), v17);
        }
      }
    }
    while ((unint64_t)(v14 + 1) > 1);
  }
  return result;
}

void HGRenderer::DotNode(HGRenderer *this, HGNode *a2)
{
  uint64_t v33 = (uint64_t *)((char *)this + 840);
  if (!HGDotGraph::on((HGRenderer *)((char *)this + 840))) {
    return;
  }
  uint64_t v4 = (const char *)(*(uint64_t (**)(HGNode *))(*(void *)a2 + 48))(a2);
  size_t v5 = strlen(v4);
  if (v5 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::string::size_type v6 = v5;
  if (v5 >= 0x17)
  {
    uint64_t v8 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v8 = v5 | 7;
    }
    uint64_t v9 = v8 + 1;
    p_dst = (std::string *)operator new(v8 + 1);
    __dst.__r_.__value_.__l.__size_ = v6;
    __dst.__r_.__value_.__r.__words[2] = v9 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_9;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v5;
  p_dst = &__dst;
  if (v5) {
LABEL_9:
  }
    memmove(p_dst, v4, v6);
  p_dst->__r_.__value_.__s.__data_[v6] = 0;
  if ((*(uint64_t (**)(HGNode *))(*(void *)a2 + 56))(a2))
  {
    std::string::append(&__dst, "\\n");
    uint64_t v10 = (const std::string::value_type *)(*(uint64_t (**)(HGNode *))(*(void *)a2 + 56))(a2);
    std::string::append(&__dst, v10);
  }
  if (*((int *)this + 164) >= 2)
  {
    snprintf(HGRenderer::DotNode(HGNode *)::str, 0x100uLL, "DOD [%d %d %d %d]\\nROI [%d %d %d %d]", *((_DWORD *)a2 + 38), *((_DWORD *)a2 + 39), *((_DWORD *)a2 + 40), *((_DWORD *)a2 + 41), *((_DWORD *)a2 + 42), *((_DWORD *)a2 + 43), *((_DWORD *)a2 + 44), *((_DWORD *)a2 + 45));
    std::string::append(&__dst, "\\n");
    std::string::append(&__dst, HGRenderer::DotNode(HGNode *)::str);
  }
  if ((*(unsigned int (**)(HGRenderer *))(*(void *)this + 304))(this) && *((_DWORD *)this + 162))
  {
    if (*((int *)this + 164) < 2) {
      goto LABEL_42;
    }
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v34);
    uint64_t v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v34, (uint64_t)"\\n", 2);
    uint64_t v12 = *v11;
    *(_DWORD *)((char *)v11 + *(void *)(*v11 - 24) + 8) = *(_DWORD *)((unsigned char *)v11 + *(void *)(*v11 - 24) + 8) & 0xFFFFFEFB | 4;
    *(uint64_t *)((char *)v11 + *(void *)(v12 - 24) + 24) = 7;
    *(uint64_t *)((char *)v11 + *(void *)(v12 - 24) + 16) = 2;
    HGStats::GraphStats::getNodeTime(*((HGStats::GraphStats **)this + 70), a2);
    int v13 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)" ms", 3);
    std::stringbuf::str();
    if ((v46 & 0x80u) == 0) {
      uint64_t v14 = (const std::string::value_type *)v45;
    }
    else {
      uint64_t v14 = (const std::string::value_type *)v45[0];
    }
    if ((v46 & 0x80u) == 0) {
      std::string::size_type v15 = v46;
    }
    else {
      std::string::size_type v15 = (std::string::size_type)v45[1];
    }
    std::string::append(&__dst, v14, v15);
    if ((char)v46 < 0) {
      operator delete(v45[0]);
    }
    v34[0] = *(void **)MEMORY[0x1E4FBA418];
    *(void **)((char *)v34 + *((void *)v34[0] - 3)) = *(void **)(MEMORY[0x1E4FBA418] + 24);
    v34[1] = (void *)(MEMORY[0x1E4FBA470] + 16);
    if (SHIBYTE(v38) < 0) {
      operator delete(__p);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    MEMORY[0x1BA9BFAB0](&v40);
  }
  int v16 = *((_DWORD *)this + 164);
  if (v16 >= 3)
  {
    HIBYTE(v35) = 0;
    LOBYTE(v34[0]) = 0;
    unsigned __int8 v46 = 0;
    LOBYTE(v45[0]) = 0;
    (*(void (**)(std::string::value_type **__return_ptr, HGNode *, void, void **, void **))(*(void *)a2 + 64))(&v42, a2, (v16 - 2), v34, v45);
    std::string::size_type v17 = v44;
    unsigned __int8 v18 = v44;
    if ((v44 & 0x80u) != 0) {
      std::string::size_type v17 = v43;
    }
    if (v17)
    {
      std::string::append(&__dst, "\\n");
      if ((v44 & 0x80u) == 0) {
        unint64_t v19 = (const std::string::value_type *)&v42;
      }
      else {
        unint64_t v19 = v42;
      }
      if ((v44 & 0x80u) == 0) {
        std::string::size_type v20 = v44;
      }
      else {
        std::string::size_type v20 = v43;
      }
      std::string::append(&__dst, v19, v20);
      unsigned __int8 v18 = v44;
    }
    if ((v18 & 0x80) != 0)
    {
      operator delete(v42);
      if (((char)v46 & 0x80000000) == 0)
      {
LABEL_41:
        if ((SHIBYTE(v35) & 0x80000000) == 0) {
          goto LABEL_42;
        }
LABEL_66:
        operator delete(v34[0]);
        goto LABEL_42;
      }
    }
    else if (((char)v46 & 0x80000000) == 0)
    {
      goto LABEL_41;
    }
    operator delete(v45[0]);
    if ((SHIBYTE(v35) & 0x80000000) == 0) {
      goto LABEL_42;
    }
    goto LABEL_66;
  }
LABEL_42:
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v21 = &__dst;
  }
  else {
    uint64_t v21 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  if (*((unsigned char *)a2 + 105)) {
    int v22 = 2;
  }
  else {
    int v22 = *((unsigned __int8 *)a2 + 106);
  }
  HGDotGraph::node(v33, (unint64_t)a2, (uint64_t)v21, v22);
  uint64_t v23 = *((unsigned int *)a2 + 22);
  if ((int)v23 >= 1)
  {
    uint64_t v31 = *(void **)(MEMORY[0x1E4FBA408] + 64);
    uint64_t v32 = (void *)*MEMORY[0x1E4FBA408];
    uint64_t v30 = *(void *)(MEMORY[0x1E4FBA408] + 72);
    do
    {
      uint64_t v24 = *(void *)(*((void *)a2 + 10) + 8 * --v23);
      if (v24 && *(void *)(v24 + 16))
      {
        std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v34);
        std::ostream::operator<<();
        unint64_t v25 = *(void *)(*(void *)(*(void *)(*((void *)a2 + 10) + 8 * v23) + 16) + 144);
        std::stringbuf::str();
        int v26 = (char)v46;
        uint64_t v27 = (const char *)v45[0];
        char IsMergedWithInput = HGNode::IsMergedWithInput(a2, v23);
        if (v26 >= 0) {
          uint64_t v29 = (const char *)v45;
        }
        else {
          uint64_t v29 = v27;
        }
        HGDotGraph::link(v33, v25, (unint64_t)a2, v29, IsMergedWithInput);
        if ((char)v46 < 0) {
          operator delete(v45[0]);
        }
        v34[0] = v32;
        *(void **)((char *)v34 + *((void *)v32 - 3)) = v31;
        uint64_t v35 = v30;
        uint64_t v36 = MEMORY[0x1E4FBA470] + 16;
        if (v39 < 0) {
          operator delete(v38);
        }
        std::streambuf::~streambuf();
        std::iostream::~basic_iostream();
        MEMORY[0x1BA9BFAB0](&v41);
      }
    }
    while ((unint64_t)(v23 + 1) > 1);
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
}

void sub_1B77AB394(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (*(char *)(v27 - 113) < 0) {
    operator delete(*(void **)(v27 - 136));
  }
  std::ostringstream::~ostringstream((uint64_t)&__p);
  if (*(char *)(v27 - 89) < 0)
  {
    operator delete(*(void **)(v27 - 112));
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void HGRenderer::SetBufferDumpDir(uint64_t a1, const char *a2)
{
  HG_RENDERER_ENV::BUFFER_DUMP_DIR(&v5);
  if (SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type size = v5.__r_.__value_.__l.__size_;
    operator delete(v5.__r_.__value_.__l.__data_);
    if (size) {
      return;
    }
  }
  else if (*((unsigned char *)&v5.__r_.__value_.__s + 23))
  {
    return;
  }
  if (a2[23] < 0) {
    a2 = *(const char **)a2;
  }
  HGBufferDumper::setPath((HGBufferDumper *)(a1 + 928), a2);
}

void HGRenderer::SetDotGraphOutputDir(uint64_t a1, const void **a2)
{
  HG_RENDERER_ENV::DOT_GRAPH_OUTPUT_DIR(&v15);
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type size = v15.__r_.__value_.__l.__size_;
    operator delete(v15.__r_.__value_.__l.__data_);
    if (size) {
      return;
    }
  }
  else if (*((unsigned char *)&v15.__r_.__value_.__s + 23))
  {
    return;
  }
  std::string v5 = (std::string *)(a1 + 1024);
  char v6 = *((unsigned char *)a2 + 23);
  if (*(char *)(a1 + 1047) < 0)
  {
    size_t v7 = *(void *)(a1 + 1032);
    uint64_t v8 = *(const void **)(a1 + 1024);
  }
  else
  {
    size_t v7 = *(unsigned __int8 *)(a1 + 1047);
    uint64_t v8 = (const void *)(a1 + 1024);
  }
  if (v6 >= 0) {
    size_t v9 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v9 = (size_t)a2[1];
  }
  if (v6 >= 0) {
    uint64_t v10 = a2;
  }
  else {
    uint64_t v10 = *a2;
  }
  if (v9 >= v7) {
    size_t v11 = v7;
  }
  else {
    size_t v11 = v9;
  }
  if (memcmp(v8, v10, v11) || v9 != v7) {
    HGLogger::print((HGLogger *)"Helium Dot Graph Output Directory: %s", v12, v13, v10);
  }
  std::string::operator=(v5, (const std::string *)a2);
}

uint64_t HGRenderer::DumpPreRenderDotTree(HGRenderer *this, HGNode *a2, const char *a3)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v17);
  int v6 = *((char *)this + 1047);
  if (v6 >= 0) {
    size_t v7 = (char *)this + 1024;
  }
  else {
    size_t v7 = (char *)*((void *)this + 128);
  }
  if (v6 >= 0) {
    uint64_t v8 = *((unsigned __int8 *)this + 1047);
  }
  else {
    uint64_t v8 = *((void *)this + 129);
  }
  size_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)v7, v8);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"/helium.", 8);
  if (!HG_RENDERER_ENV::FORCE_SINGLE_DOT_FILE)
  {
    uint64_t v10 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)".", 1);
  }
  size_t v11 = strlen(a3);
  uint64_t v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)a3, v11);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)".dot", 4);
  std::stringbuf::str();
  HGNode::WriteDotGraph((uint64_t)a2, (uint64_t)&__p, 2);
  if (v16 < 0) {
    operator delete(__p);
  }
  v17[0] = *MEMORY[0x1E4FBA408];
  uint64_t v13 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v17 + *(void *)(v17[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  v18[0] = v13;
  v18[1] = MEMORY[0x1E4FBA470] + 16;
  if (v19 < 0) {
    operator delete((void *)v18[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BA9BFAB0](&v20);
}

void sub_1B77AB810(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0)
  {
    operator delete(__p);
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a15);
    _Unwind_Resume(a1);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t *HGRenderer::DotLogInplaceRendering(HGRenderer *this, HGNode *a2)
{
  return HGDotGraph::dashed((uint64_t *)this + 105, (unint64_t)a2);
}

uint64_t *HGRenderer::DotLogHWBlending(HGRenderer *this, HGNode *a2, HGNode *a3, int a4)
{
  std::string v5 = (uint64_t *)((char *)this + 840);
  int v6 = (uint64_t *)((char *)this + 840);
  if (a4)
  {
    HGDotGraph::linkStyle(v6, (uint64_t *)a2, (uint64_t *)a3, 0, 3);
    return HGDotGraph::dashed(v5, (unint64_t)a2);
  }
  else
  {
    return HGDotGraph::linkStyle(v6, (uint64_t *)a2, (uint64_t *)a3, 0, 2);
  }
}

uint64_t HGRenderer::GetOwningRenderQueue(HGRenderer *this)
{
  return *((void *)this + 136);
}

uint64_t HGRenderer::SetOwningRenderQueue(uint64_t this, HGRenderQueue *a2)
{
  *(void *)(this + 1088) = a2;
  return this;
}

void HGRenderer::RenderBgn(HGRenderer *this, int a2)
{
  kdebug_trace();
  if (HGDotGraph::on((HGRenderer *)((char *)this + 840)))
  {
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v15);
    int v4 = *((char *)this + 1047);
    if (v4 >= 0) {
      std::string v5 = (char *)this + 1024;
    }
    else {
      std::string v5 = (char *)*((void *)this + 128);
    }
    if (v4 >= 0) {
      uint64_t v6 = *((unsigned __int8 *)this + 1047);
    }
    else {
      uint64_t v6 = *((void *)this + 129);
    }
    size_t v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)v5, v6);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)"/helium.", 8);
    if (!HG_RENDERER_ENV::FORCE_SINGLE_DOT_FILE)
    {
      uint64_t v8 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)".", 1);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)"tree.dot", 8);
    std::stringbuf::str();
    if (v14 >= 0) {
      p_p = (const char *)&__p;
    }
    else {
      p_p = (const char *)__p;
    }
    HGDotGraph::begin((HGRenderer *)((char *)this + 840), p_p);
    if (v14 < 0) {
      operator delete(__p);
    }
    v15[0] = *MEMORY[0x1E4FBA408];
    uint64_t v10 = *(void *)(MEMORY[0x1E4FBA408] + 72);
    *(void *)((char *)v15 + *(void *)(v15[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
    v16[0] = v10;
    v16[1] = MEMORY[0x1E4FBA470] + 16;
    if (v17 < 0) {
      operator delete((void *)v16[9]);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1BA9BFAB0](&v18);
  }
  HGBufferDumper::reset((std::string *)((char *)this + 928));
  if (*((_DWORD *)this + 149) > (int)((*((void *)this + 32) - *((void *)this + 31)) >> 3)) {
    operator new();
  }
  (*(void (**)(HGRenderer *))(*(void *)this + 288))(this);
  if (a2)
  {
    *((_DWORD *)this + 262) = 0;
    if (!*((_DWORD *)this + 158)) {
      *((void *)this + 132) = HGGetTBC();
    }
    HGStats::GraphStats::clear(*((uint64_t ***)this + 70));
    HGStats::GraphStats::start(*((HGProfiler ****)this + 70));
    if (*((int *)this + 149) >= 1)
    {
      uint64_t v11 = 0;
      do
      {
        HGStats::UnitStats::clear(*(HGStats::UnitStats **)(*(void *)(*((void *)this + 31) + 8 * v11) + 424));
        HGStats::UnitStats::enable(*(void *)(*(void *)(*((void *)this + 31) + 8 * v11) + 424), *((_DWORD *)this + 162) != 0);
        HGStats::UnitStats::start(*(HGStats::UnitStatsImpl ***)(*(void *)(*((void *)this + 31) + 8 * v11) + 424), 0);
        uint64_t v12 = *(HGExecutionUnit **)(*((void *)this + 31) + 8 * v11);
        if (*((int *)this + 158) >= 1) {
          HGExecutionUnit::PushStats(v12);
        }
        HGExecutionUnit::ClearStats(v12);
        ++v11;
      }
      while (v11 < *((int *)this + 149));
    }
    *(void *)((char *)this + 692) = 0;
  }
  ++*((_DWORD *)this + 158);
}

void sub_1B77ABDE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0)
  {
    operator delete(__p);
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a16);
    _Unwind_Resume(a1);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void sub_1B77ABE30(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A0C408E851C7FLL);
  _Unwind_Resume(a1);
}

uint64_t HGRenderer::RenderEnd(HGRenderer *this, int a2)
{
  uint64_t v3 = this;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A1FF8, memory_order_acquire) & 1) == 0)
  {
    this = (HGRenderer *)__cxa_guard_acquire(&qword_1EB9A1FF8);
    if (this)
    {
      LOBYTE(_MergedGlobals_11) = 0;
      __cxa_atexit((void (*)(void *))StaticInitTracker::~StaticInitTracker, &_MergedGlobals_11, &dword_1B73F3000);
      __cxa_guard_release(&qword_1EB9A1FF8);
    }
  }
  if ((_BYTE)_MergedGlobals_11)
  {
    puts("-------------------------------------------------------------------");
    puts("Helium ERROR : C++ teardown in progress!!");
    puts("               Accessing Helium during static objects destruction!!");
    this = (HGRenderer *)puts("-------------------------------------------------------------------");
  }
  HGMemory::renderEnd(this);
  --*((_DWORD *)v3 + 158);
  if (a2)
  {
    uint64_t v4 = HGGetTBC();
    HGStats::GraphStats::stop(*((HGProfiler ****)v3 + 70));
    if (*((int *)v3 + 149) <= 0)
    {
      *((void *)v3 + 133) = v4;
    }
    else
    {
      uint64_t v5 = 0;
      do
      {
        uint64_t v7 = *((void *)v3 + 31);
        if (*((int *)v3 + 158) >= 1)
        {
          HGExecutionUnit::PopStats(*(HGExecutionUnit **)(v7 + 8 * v5));
          uint64_t v7 = *((void *)v3 + 31);
        }
        HGStats::UnitStats::stop(*(void **)(*(void *)(v7 + 8 * v5) + 424), 0);
        if (!*((_DWORD *)v3 + 262)) {
          *((_DWORD *)v3 + 262) = *(_DWORD *)(*(void *)(*(void *)(*((void *)v3 + 31) + 8 * v5) + 416) + 100);
        }
        ++v5;
        uint64_t v6 = *((int *)v3 + 149);
      }
      while (v5 < v6);
      *((void *)v3 + 133) = v4;
      if ((int)v6 >= 1)
      {
        uint64_t v8 = 0;
        do
          HGStats::GraphStats::merge(*((HGStats::GraphStatsImpl ***)v3 + 70), *(const HGStats::UnitStatsImpl ***)(*(void *)(*((void *)v3 + 31) + 8 * v8++) + 424));
        while (v8 < *((int *)v3 + 149));
      }
    }
    HGStats::RendererStats::merge(*((HGStats::RendererStatsImpl ***)v3 + 71), *((HGProfiler ****)v3 + 70));
  }
  HGRenderer::StatsProbes((HGProfiler ****)v3);
  HGRenderer::DumpStats((unint64_t)v3);

  return kdebug_trace();
}

void StaticInitTracker::~StaticInitTracker(StaticInitTracker *this)
{
  *(unsigned char *)this = 1;
}

uint64_t HGRenderer::StatsProbes(HGProfiler ****this)
{
  if (((unsigned int (*)(HGProfiler ****))(*this)[38])(this)) {
    uint64_t v2 = *((unsigned int *)this + 149);
  }
  else {
    uint64_t v2 = 0;
  }
  unint64_t v3 = (unint64_t)(HGStats::GraphStats::time(this[70]) * 1000.0);
  ((void (*)(HGProfiler ****, uint64_t, unint64_t))(*this)[38])(this, v2, v3);
  if (((unsigned int (*)(HGProfiler ****))(*this)[38])(this)) {
    uint64_t v4 = *((unsigned int *)this + 149);
  }
  else {
    uint64_t v4 = 0;
  }
  unint64_t v5 = (unint64_t)(HGStats::RendererStats::time((HGStats::RendererStats *)this[71]) * 1000.0);
  uint64_t v6 = HGStats::RendererStats::count((HGStats::RendererStats *)this[71]);
  uint64_t result = ((uint64_t (*)(HGProfiler ****, uint64_t, unint64_t, uint64_t))(*this)[38])(this, v4, v5, v6);
  if (result) {
    return 0;
  }
  return result;
}

unint64_t HGRenderer::DumpStats(unint64_t this)
{
  unsigned __int8 v1 = atomic_load(HGLogger::_enabled);
  if (v1)
  {
    uint64_t v2 = this;
    int v3 = *(_DWORD *)(this + 652);
    if (v3 >= 1)
    {
      if (v3 == 1) {
        int v4 = 256;
      }
      else {
        int v4 = 65792;
      }
      if (v3 >= 3 && (*(unsigned int (**)(unint64_t))(*(void *)this + 304))(this)) {
        int v4 = 394752;
      }
      std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v76);
      if (*(int *)(v2 + 596) >= 1)
      {
        uint64_t v5 = 0;
        do
          HGStats::UnitStats::dump(*(uint64_t ***)(*(void *)(*(void *)(v2 + 248) + 8 * v5++) + 424), v76, v4);
        while (v5 < *(int *)(v2 + 596));
      }
      HGStats::GraphStats::dump(*(uint64_t **)(v2 + 560), v76, v4);
      HGStats::RendererStats::dump(*(void ***)(v2 + 568), v76, v4);
      std::stringbuf::str();
      if (v75 >= 0) {
        p_p = (const char *)&__p;
      }
      else {
        p_p = (const char *)__p;
      }
      printf("%s", p_p);
      if (v75 < 0) {
        operator delete(__p);
      }
      v76[0] = *MEMORY[0x1E4FBA418];
      *(void *)((char *)v76 + *(void *)(v76[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
      v76[1] = MEMORY[0x1E4FBA470] + 16;
      if (v77 < 0) {
        operator delete((void *)v76[9]);
      }
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      this = MEMORY[0x1BA9BFAB0](&v78);
      if (*(int *)(v2 + 652) >= 1)
      {
        double v7 = (double)(unint64_t)(*(void *)(v2 + 1064) - *(void *)(v2 + 1056)) * 1000.0;
        this = HGGetTBCFrequency();
        double v8 = v7 / (double)this;
        int v9 = *(_DWORD *)(v2 + 652);
        if (v9 >= 3)
        {
          this = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 304))(v2);
          if (this)
          {
            unint64_t v10 = *(void *)(v2 + 1064) - *(void *)(v2 + 1056);
            unint64_t v11 = *(int *)(v2 + 596);
            if ((int)v11 <= 0)
            {
              unint64_t v13 = 0;
            }
            else
            {
              uint64_t v12 = 0;
              unint64_t v13 = 0;
              do
              {
                v13 += HGExecutionUnit::StackSize(*(HGExecutionUnit **)(*(void *)(v2 + 248) + 8 * v12++));
                unint64_t v11 = *(int *)(v2 + 596);
              }
              while (v12 < (uint64_t)v11);
            }
            double v71 = (double)v10 * 1000.0;
            unint64_t v72 = v13 / v11;
            double v73 = v71 / (double)HGGetTBCFrequency();
            printf("\n- Helium Render Stats:");
            printf("\n  +   Wall Time (ms)        : %6.2f", v73);
            printf("\n  +   Mem Used              : %lu", v72);
            this = puts("\n");
            if (*(int *)(v2 + 652) <= 1) {
              return this;
            }
LABEL_30:
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2000, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_1EB9A2000))
            {
              StatsAccumulator::StatsAccumulator((StatsAccumulator *)&qword_1EB9A2008);
              __cxa_atexit((void (*)(void *))StatsAccumulator::~StatsAccumulator, &qword_1EB9A2008, &dword_1B73F3000);
              __cxa_guard_release(&qword_1EB9A2000);
            }
            float v14 = v8;
            int v15 = dword_1EB9A2020++;
            unint64_t v16 = dword_1EB9A2020;
            uint64_t v17 = qword_1EB9A2008;
            *(float *)(qword_1EB9A2008 + 4 * v15) = v14;
            int v18 = ((unint64_t)(qword_1EB9A2010 - v17) >> 2) - 1;
            if (v16 >= (qword_1EB9A2010 - v17) >> 2)
            {
              dword_1EB9A2020 = 0;
            }
            else if ((v15 & 0x80000000) == 0)
            {
LABEL_36:
              float v19 = *(float *)(v17 + 4 * v15);
              float v20 = 0.0;
              int v21 = v15 - 1;
              if (v21 < 0) {
                int v21 = ((unint64_t)(qword_1EB9A2010 - v17) >> 2) - 1;
              }
              float v22 = *(float *)(v17 + 4 * v21);
              int v23 = v21 - 1;
              if (v23 < 0) {
                int v23 = ((unint64_t)(qword_1EB9A2010 - v17) >> 2) - 1;
              }
              float v24 = *(float *)(v17 + 4 * v23);
              int v25 = v23 - 1;
              if (v25 < 0) {
                int v25 = ((unint64_t)(qword_1EB9A2010 - v17) >> 2) - 1;
              }
              float v26 = *(float *)(v17 + 4 * v25);
              int v27 = v25 - 1;
              if (v27 >= 0) {
                int v18 = v27;
              }
              float v28 = *(float *)(v17 + 4 * v18);
              float v29 = (float)((float)((float)((float)(v19 + 0.0) + v22) + v24) + v26) + v28;
              float v30 = fmaxf(v19, 0.0);
              if (v30 < v22) {
                float v30 = v22;
              }
              if (v30 < v24) {
                float v30 = v24;
              }
              if (v30 < v26) {
                float v30 = v26;
              }
              if (v30 < v28) {
                float v30 = *(float *)(v17 + 4 * v18);
              }
              float v31 = 10000000.0;
              float v32 = fminf(v19, 10000000.0);
              if (v32 > v22) {
                float v32 = v22;
              }
              if (v32 > v24) {
                float v32 = v24;
              }
              if (v32 > v26) {
                float v32 = v26;
              }
              if (v32 > v28) {
                float v32 = *(float *)(v17 + 4 * v18);
              }
              printf("last %2d : %.2f ms (%.2f / %.2f)\n", 5, (float)(v29 / 5.0), v32, v30);
              int v33 = dword_1EB9A2020 - 1;
              int v34 = ((unint64_t)(qword_1EB9A2010 - qword_1EB9A2008) >> 2) - 1;
              if (dword_1EB9A2020 - 1 < 0) {
                int v33 = ((unint64_t)(qword_1EB9A2010 - qword_1EB9A2008) >> 2) - 1;
              }
              float v35 = *(float *)(qword_1EB9A2008 + 4 * v33);
              int v36 = v33 - 1;
              if (v36 < 0) {
                int v36 = ((unint64_t)(qword_1EB9A2010 - qword_1EB9A2008) >> 2) - 1;
              }
              float v37 = *(float *)(qword_1EB9A2008 + 4 * v36);
              int v38 = v36 - 1;
              if (v38 < 0) {
                int v38 = ((unint64_t)(qword_1EB9A2010 - qword_1EB9A2008) >> 2) - 1;
              }
              float v39 = *(float *)(qword_1EB9A2008 + 4 * v38);
              int v40 = v38 - 1;
              if (v40 < 0) {
                int v40 = ((unint64_t)(qword_1EB9A2010 - qword_1EB9A2008) >> 2) - 1;
              }
              float v41 = *(float *)(qword_1EB9A2008 + 4 * v40);
              int v42 = v40 - 1;
              if (v42 < 0) {
                int v42 = ((unint64_t)(qword_1EB9A2010 - qword_1EB9A2008) >> 2) - 1;
              }
              float v43 = *(float *)(qword_1EB9A2008 + 4 * v42);
              int v44 = v42 - 1;
              if (v44 < 0) {
                int v44 = ((unint64_t)(qword_1EB9A2010 - qword_1EB9A2008) >> 2) - 1;
              }
              float v45 = *(float *)(qword_1EB9A2008 + 4 * v44);
              int v46 = v44 - 1;
              if (v46 < 0) {
                int v46 = ((unint64_t)(qword_1EB9A2010 - qword_1EB9A2008) >> 2) - 1;
              }
              float v47 = *(float *)(qword_1EB9A2008 + 4 * v46);
              int v48 = v46 - 1;
              if (v48 < 0) {
                int v48 = ((unint64_t)(qword_1EB9A2010 - qword_1EB9A2008) >> 2) - 1;
              }
              float v49 = *(float *)(qword_1EB9A2008 + 4 * v48);
              int v50 = v48 - 1;
              if (v50 < 0) {
                int v50 = ((unint64_t)(qword_1EB9A2010 - qword_1EB9A2008) >> 2) - 1;
              }
              float v51 = *(float *)(qword_1EB9A2008 + 4 * v50);
              int v52 = v50 - 1;
              if (v52 < 0) {
                int v52 = ((unint64_t)(qword_1EB9A2010 - qword_1EB9A2008) >> 2) - 1;
              }
              float v53 = *(float *)(qword_1EB9A2008 + 4 * v52);
              int v54 = v52 - 1;
              if (v54 < 0) {
                int v54 = ((unint64_t)(qword_1EB9A2010 - qword_1EB9A2008) >> 2) - 1;
              }
              float v55 = *(float *)(qword_1EB9A2008 + 4 * v54);
              int v56 = v54 - 1;
              if (v56 < 0) {
                int v56 = ((unint64_t)(qword_1EB9A2010 - qword_1EB9A2008) >> 2) - 1;
              }
              float v57 = *(float *)(qword_1EB9A2008 + 4 * v56);
              int v58 = v56 - 1;
              if (v58 < 0) {
                int v58 = ((unint64_t)(qword_1EB9A2010 - qword_1EB9A2008) >> 2) - 1;
              }
              float v59 = *(float *)(qword_1EB9A2008 + 4 * v58);
              int v60 = v58 - 1;
              if (v60 < 0) {
                int v60 = ((unint64_t)(qword_1EB9A2010 - qword_1EB9A2008) >> 2) - 1;
              }
              float v61 = *(float *)(qword_1EB9A2008 + 4 * v60);
              int v62 = v60 - 1;
              if (v62 >= 0) {
                int v34 = v62;
              }
              float v63 = *(float *)(qword_1EB9A2008 + 4 * v34);
              float v64 = (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v35 + 0.0) + v37) + v39) + v41)
                                                                                                  + v43)
                                                                                          + v45)
                                                                                  + v47)
                                                                          + v49)
                                                                  + v51)
                                                          + v53)
                                                  + v55)
                                          + v57)
                                  + v59)
                          + v61)
                  + v63;
              float v65 = fmaxf(v35, 0.0);
              if (v65 < v37) {
                float v65 = v37;
              }
              if (v65 < v39) {
                float v65 = v39;
              }
              if (v65 < v41) {
                float v65 = v41;
              }
              if (v65 < v43) {
                float v65 = v43;
              }
              if (v65 < v45) {
                float v65 = v45;
              }
              if (v65 < v47) {
                float v65 = v47;
              }
              if (v65 < v49) {
                float v65 = v49;
              }
              if (v65 < v51) {
                float v65 = v51;
              }
              if (v65 < v53) {
                float v65 = v53;
              }
              if (v65 < v55) {
                float v65 = v55;
              }
              if (v65 < v57) {
                float v65 = v57;
              }
              if (v65 < v59) {
                float v65 = v59;
              }
              if (v65 < v61) {
                float v65 = v61;
              }
              if (v65 < v63) {
                float v65 = *(float *)(qword_1EB9A2008 + 4 * v34);
              }
              float v66 = fminf(v35, 10000000.0);
              if (v66 > v37) {
                float v66 = v37;
              }
              if (v66 > v39) {
                float v66 = v39;
              }
              if (v66 > v41) {
                float v66 = v41;
              }
              if (v66 > v43) {
                float v66 = v43;
              }
              if (v66 > v45) {
                float v66 = v45;
              }
              if (v66 > v47) {
                float v66 = v47;
              }
              if (v66 > v49) {
                float v66 = v49;
              }
              if (v66 > v51) {
                float v66 = v51;
              }
              if (v66 > v53) {
                float v66 = v53;
              }
              if (v66 > v55) {
                float v66 = v55;
              }
              if (v66 > v57) {
                float v66 = v57;
              }
              if (v66 > v59) {
                float v66 = v59;
              }
              if (v66 > v61) {
                float v66 = v61;
              }
              if (v66 > v63) {
                float v66 = *(float *)(qword_1EB9A2008 + 4 * v34);
              }
              printf("last %2d : %.2f ms (%.2f / %.2f)\n", 15, (float)(v64 / 15.0), v66, v65);
              int v67 = dword_1EB9A2020;
              unsigned int v68 = 51;
              float v69 = 0.0;
              do
              {
                if (--v67 < 0) {
                  int v67 = ((unint64_t)(qword_1EB9A2010 - qword_1EB9A2008) >> 2) - 1;
                }
                float v70 = *(float *)(qword_1EB9A2008 + 4 * v67);
                if (v31 > v70) {
                  float v31 = *(float *)(qword_1EB9A2008 + 4 * v67);
                }
                if (v69 < v70) {
                  float v69 = *(float *)(qword_1EB9A2008 + 4 * v67);
                }
                float v20 = v20 + v70;
                --v68;
              }
              while (v68 > 1);
              return printf("last %2d : %.2f ms (%.2f / %.2f)\n", 50, (float)(v20 / 50.0), v31, v69);
            }
            int v15 = ((unint64_t)(qword_1EB9A2010 - v17) >> 2) - 1;
            goto LABEL_36;
          }
          int v9 = *(_DWORD *)(v2 + 652);
        }
        if (v9 >= 1) {
          this = printf("\nHelium Time (ms) : %6.2f\n", v8);
        }
        if (*(int *)(v2 + 652) > 1) {
          goto LABEL_30;
        }
      }
    }
  }
  return this;
}

void sub_1B77ACA10(_Unwind_Exception *a1)
{
}

void sub_1B77ACA28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B77ACA3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B77ACA50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void HGRenderer::AdjustForBufferLocation(uint64_t a1, const char *a2, char *a3)
{
  if ((a3 - 3) < 3)
  {
    int v3 = "GPU buffer location destination provided for CPU renderer.";
LABEL_3:
    HGLogger::warning((HGLogger *)v3, a2, a3);
    return;
  }
  if (a3 == 1)
  {
    int v3 = "kRenderBufferIOSurface location for CPU renderer: not yet unimplemented, sorry.";
    goto LABEL_3;
  }
}

uint64_t HGRenderer::AdjustForBufferLocation(uint64_t a1, uint64_t a2)
{
  if (a2) {
    (*(void (**)(uint64_t))(*(void *)a2 + 16))(a2);
  }
  return a2;
}

uint64_t HGRenderer::PreRenderTraversal(HGRenderer *this, HGNode *a2)
{
  int v7 = 4098;
  kdebug_trace();
  if ((*((unsigned char *)a2 + 136) & 2) != 0)
  {
    uint64_t v6 = &unk_1F10D60D0;
    HGTraversal::IterativeUniqueTraversal<(HGTraversal::NodeInput)1,(HGTraversal::IteratorOrder)0,(HGTraversal::TraversalOrder)0,(HGTraversal::InputOrder)0>::operator()((uint64_t)&v5, this, (uint64_t)a2, (uint64_t)&v6);
  }
  else
  {
    uint64_t v6 = &unk_1F10D6098;
    HGTraversal::IterativeUniqueTraversal<(HGTraversal::NodeInput)0,(HGTraversal::IteratorOrder)0,(HGTraversal::TraversalOrder)0,(HGTraversal::InputOrder)0>::operator()((uint64_t)&v5, (uint64_t)this, (uint64_t)a2, (uint64_t)&v6);
  }
  return kdebug_trace();
}

void sub_1B77ACBC4(_Unwind_Exception *a1)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 20));
  _Unwind_Resume(a1);
}

void sub_1B77ACBD8(_Unwind_Exception *a1)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 20));
  _Unwind_Resume(a1);
}

uint64_t HGRenderer::Render(HGRenderer *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, char *a6)
{
  v9[0] = a5;
  v9[1] = 0;
  v9[2] = a2;
  v9[3] = a3;
  int v10 = a4;
  int v11 = 0;
  HGRenderer::RenderNode(a1, (const HGRendererOutput *)v9, a6, &v8);
  uint64_t v6 = v8;
  if (v8)
  {
    (*(void (**)(uint64_t))(*(void *)v8 + 16))(v8);
    (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
  }
  return v6;
}

void sub_1B77ACC90(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void HGRenderer::RenderNode(HGRenderer *this@<X0>, const HGRendererOutput *a2@<X1>, char *a3@<X2>, void *a4@<X8>)
{
  uint64_t v8 = operator new(0x28uLL);
  v20[1] = (char *)v8 + 40;
  v20[2] = (char *)v8 + 40;
  long long v9 = *((_OWORD *)a2 + 1);
  *uint64_t v8 = *(_OWORD *)a2;
  v8[1] = v9;
  *((void *)v8 + 4) = *((void *)a2 + 4);
  v20[0] = v8;
  HGRenderer::RenderNodes((uint64_t)this, (const char *)v20, a3, v10, v11, &__p);
  uint64_t v12 = (char *)__p;
  if (__p == v19)
  {
    *a4 = 0;
    if (!v12) {
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v13 = *(void *)__p;
    *a4 = *(void *)__p;
    if (v13)
    {
      (*(void (**)(uint64_t))(*(void *)v13 + 16))(v13);
      uint64_t v12 = (char *)__p;
      if (!__p) {
        goto LABEL_13;
      }
    }
  }
  float v14 = v19;
  int v15 = v12;
  if (v19 != v12)
  {
    do
    {
      uint64_t v17 = *((void *)v14 - 1);
      v14 -= 8;
      uint64_t v16 = v17;
      if (v17) {
        (*(void (**)(uint64_t))(*(void *)v16 + 24))(v16);
      }
    }
    while (v14 != v12);
    int v15 = __p;
  }
  float v19 = v12;
  operator delete(v15);
LABEL_13:
  operator delete(v8);
}

void sub_1B77ACDF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  std::vector<HGRef<HGBitmap>>::~vector[abi:ne180100](&a9);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B77ACE14(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

const char *HGRenderer::RenderBitmap(HGRenderer *this, HGBitmap *a2, HGNode *a3)
{
  if ((*((unsigned char *)a2 + 12) & 0x30) != 0)
  {
    return HGLogger::warning((HGLogger *)"  ERROR : bitmap is on GPU (with CPU renderer).", (const char *)a2, (char *)a3);
  }
  else
  {
    v5[0] = a3;
    v5[1] = a2;
    long long v6 = *(_OWORD *)((char *)a2 + 20);
    int v7 = *((_DWORD *)a2 + 4);
    int v8 = 0;
    HGRenderer::RenderNode(this, (const HGRendererOutput *)v5, (char *)1, &v4);
    uint64_t result = (const char *)v4;
    if (v4) {
      return (const char *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 24))(v4);
    }
  }
  return result;
}

uint64_t HGRenderer::RenderBitmap(HGRenderer *this, HGBitmap *a2, HGNode *a3)
{
  HGLogger::warning((HGLogger *)"  WARNING : calling obsolete HGRenderer function:\n  void HGRenderer::RenderBitmap(HGBitmap *bmp, HGNode *node, BOOL fullROI)\n  instead, use:\n  void HGRenderer::RenderBitmap(HGBitmap *bmp, HGNode *node)\n  (fullROI is always 'on' when providing a destination bitmap)\n", (const char *)a2, (char *)a3);
  long long v6 = *(uint64_t (**)(HGRenderer *, HGBitmap *, HGNode *))(*(void *)this + 64);

  return v6(this, a2, a3);
}

void HGRenderer::RenderNodes(uint64_t a1, int a2, uint64_t a3, const char *a4, char *a5, uint64_t a6, unsigned int a7)
{
  int v42 = 0;
  float v43 = 0;
  int v44 = 0;
  uint64_t v7 = a2;
  if (a2 >= 1)
  {
    int v8 = 0;
    uint64_t v9 = 0;
    int v38 = a5;
    uint64_t v39 = a6;
    float v37 = a4;
    do
    {
      while (1)
      {
        uint64_t v10 = *(void *)&a4[8 * v9];
        int v11 = &a5[16 * v9];
        uint64_t v13 = *(void *)v11;
        uint64_t v12 = *((void *)v11 + 1);
        int v14 = *(_DWORD *)(a6 + 4 * v9);
        if (v8 >= v44) {
          break;
        }
        *(void *)int v8 = v10;
        *((void *)v8 + 1) = 0;
        *((void *)v8 + 2) = v13;
        *((void *)v8 + 3) = v12;
        *((_DWORD *)v8 + 8) = v14;
        *((_DWORD *)v8 + 9) = 0;
        float v43 = v8 + 40;
        ++v9;
        v8 += 40;
        if (v9 == v7) {
          goto LABEL_21;
        }
      }
      int v15 = (char *)v42;
      unint64_t v16 = 0xCCCCCCCCCCCCCCCDLL * ((v8 - (unsigned char *)v42) >> 3);
      unint64_t v17 = v16 + 1;
      if (v16 + 1 > 0x666666666666666) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      if (0x999999999999999ALL * ((v44 - (unsigned char *)v42) >> 3) > v17) {
        unint64_t v17 = 0x999999999999999ALL * ((v44 - (unsigned char *)v42) >> 3);
      }
      if (0xCCCCCCCCCCCCCCCDLL * ((v44 - (unsigned char *)v42) >> 3) >= 0x333333333333333) {
        unint64_t v18 = 0x666666666666666;
      }
      else {
        unint64_t v18 = v17;
      }
      if (v18)
      {
        if (v18 > 0x666666666666666) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        float v19 = (char *)operator new(40 * v18);
      }
      else
      {
        float v19 = 0;
      }
      float v20 = &v19[8 * ((v8 - (unsigned char *)v42) >> 3)];
      *(void *)float v20 = v10;
      *((void *)v20 + 1) = 0;
      *((void *)v20 + 2) = v13;
      *((void *)v20 + 3) = v12;
      *((_DWORD *)v20 + 8) = v14;
      *((_DWORD *)v20 + 9) = 0;
      int v21 = &v19[40 * v16];
      if (v8 != v15)
      {
        do
        {
          long long v22 = *(_OWORD *)(v8 - 40);
          long long v23 = *(_OWORD *)(v8 - 24);
          *((void *)v21 - 1) = *((void *)v8 - 1);
          *(_OWORD *)(v21 - 24) = v23;
          *(_OWORD *)(v21 - 4CVOpenGLESTextureCacheFlush(this[3], 0) = v22;
          v21 -= 40;
          v8 -= 40;
        }
        while (v8 != v15);
        int v8 = v15;
      }
      float v24 = v20 + 40;
      int v42 = v21;
      int v44 = &v19[40 * v18];
      if (v8) {
        operator delete(v8);
      }
      a5 = v38;
      a6 = v39;
      a4 = v37;
      float v43 = v24;
      ++v9;
      int v8 = v24;
    }
    while (v9 != v7);
  }
LABEL_21:
  HGRenderer::RenderNodes(a1, (const char *)&v42, (char *)a7, a4, a5, &__p);
  if (a2 >= 1)
  {
    unint64_t v25 = 0;
    do
    {
      while (1)
      {
        float v26 = __p;
        if (v25 < (v41 - (unsigned char *)__p) >> 3)
        {
          uint64_t v27 = *((void *)__p + v25);
          if (v27) {
            break;
          }
        }
        *(void *)(a3 + 8 * v25++) = 0;
        if (v7 == v25) {
          goto LABEL_27;
        }
      }
      (*(void (**)(uint64_t))(*(void *)v27 + 16))(v27);
      *(void *)(a3 + 8 * v25) = v26[v25];
      ++v25;
    }
    while (v7 != v25);
  }
LABEL_27:
  float v28 = (char *)__p;
  if (__p)
  {
    float v29 = v41;
    float v30 = __p;
    if (v41 != __p)
    {
      do
      {
        uint64_t v32 = *((void *)v29 - 1);
        v29 -= 8;
        uint64_t v31 = v32;
        if (v32) {
          (*(void (**)(uint64_t))(*(void *)v31 + 24))(v31);
        }
      }
      while (v29 != v28);
      float v30 = __p;
    }
    float v41 = v28;
    operator delete(v30);
  }
  if (v42) {
    operator delete(v42);
  }
}

void sub_1B77AD21C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void HGRenderer::RenderNodes(uint64_t a1@<X0>, const char *a2@<X1>, char *a3@<X2>, const char *a4@<X3>, char *a5@<X4>, void **a6@<X8>)
{
  long long v6 = a6;
  *a6 = 0;
  a6[1] = 0;
  a6[2] = 0;
  if (*(unsigned char *)(a1 + 809))
  {
    char v7 = (char)a3;
    int v8 = a2;
    unsigned __int8 v10 = atomic_load(HGLogger::_enabled);
    if (v10) {
      HGLogger::log((HGLogger *)"gpu", (const char *)1, (HGLogger *)"\n\n", a4, a5);
    }
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v117, "gpu", 1, "----- HGRenderer::Render() -----");
    int v11 = *(HGNode ***)v8;
    uint64_t v12 = (HGNode **)*((void *)v8 + 1);
    if (*(HGNode ***)v8 != v12)
    {
      do
      {
        (*(void (**)(HGNode *, uint64_t, HGNode *, HGNode *, void))(*(void *)*v11 + 376))(*v11, a1, v11[2], v11[3], *((unsigned int *)v11 + 8));
        v11 += 5;
      }
      while (v11 != v12);
    }
    *(unsigned char *)(a1 + 808) = v7;
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 256))(a1, 1);
    if (*(_DWORD *)(a1 + 640))
    {
      pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 288));
      pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 288));
    }
    if (!*(_DWORD *)(a1 + 636))
    {
      uint64_t v13 = *(HGNode ***)v8;
      int v14 = (HGNode **)*((void *)v8 + 1);
      if (*(HGNode ***)v8 != v14)
      {
        do
        {
          HGRenderer::GetOutput((HGRenderer *)a1, *v13);
          v13 += 5;
        }
        while (v13 != v14);
      }
      int v15 = *(HGNode ***)v8;
      unint64_t v16 = (HGNode **)*((void *)v8 + 1);
      if (*(HGNode ***)v8 != v16)
      {
        int v17 = 0;
        do
        {
          unint64_t v18 = (HGNode *)*((void *)*v15 + 18);
          if (v18) {
            HGRenderer::RenderNodeBgn((HGRenderer *)a1, v18, v17);
          }
          ++v17;
          v15 += 5;
        }
        while (v15 != v16);
        float v19 = *(unsigned int **)v8;
        float v20 = (unsigned int *)*((void *)v8 + 1);
        if (*(unsigned int **)v8 != v20)
        {
          do
          {
            uint64_t v21 = *(void *)(*(void *)v19 + 144);
            if (v21) {
              (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 272))(a1, v21, v19[9]);
            }
            v19 += 10;
          }
          while (v19 != v20);
          long long v23 = *(HGNode ***)v8;
          long long v22 = (HGNode **)*((void *)v8 + 1);
          if (*(HGNode ***)v8 != v22)
          {
            float v24 = "HGRenderer::SetROI()";
            float32x4_t v110 = v6;
            do
            {
              unint64_t v25 = *v23;
              float v26 = (HGNode *)*((void *)*v23 + 18);
              if (v26)
              {
                uint64_t v27 = v23[2];
                float v28 = v23[3];
                if (*(int *)(a1 + 644) < 1)
                {
                  HGRenderer::SetROI((HGRenderer *)a1, v26, *((HGRect *)v23 + 1), 0, 0);
                }
                else
                {
                  unsigned __int8 v29 = atomic_load(HGLogger::_enabled);
                  if (v29)
                  {
                    float v30 = v8;
                    uint64_t v31 = v24;
                    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a1 + 40))(&__p, a1);
                    int v32 = SHIBYTE(v116);
                    int v33 = (void **)__p;
                    int v34 = HGFormat_repr(*(_DWORD *)(a1 + 576));
                    p_p = &__p;
                    if (v32 < 0) {
                      p_p = v33;
                    }
                    HGLogger::log((HGLogger *)"graph", (const char *)1, (HGLogger *)"%s.  Intermediate format: %s\n", v35, v36, p_p, v34);
                    float v24 = v31;
                    if (SHIBYTE(v116) < 0) {
                      operator delete(__p);
                    }
                    int v8 = v30;
                    long long v6 = v110;
                  }
                  HGTraceGuard::HGTraceGuard((HGTraceGuard *)&__p, "graph", 1, v24);
                  *(void *)&v118.int var0 = v27;
                  *(void *)&v118.int var2 = v28;
                  HGRenderer::SetROI((HGRenderer *)a1, *((HGNode **)v25 + 18), v118, 0, 0);
                  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&__p);
                }
              }
              v23 += 5;
            }
            while (v23 != v22);
          }
        }
      }
      if (*(int *)(a1 + 656) > 2) {
        HGRenderer::DumpPreRenderDotTree((HGRenderer *)a1, **(HGNode ***)v8, "getoutput");
      }
      std::string __p = 0;
      char v115 = 0;
      unint64_t v116 = 0;
      uint64_t v38 = *((void *)v8 + 1);
      if (*(void *)v8 != v38)
      {
        uint64_t v39 = *(void *)v8 + 24;
        while (1)
        {
          uint64_t v40 = v39 - 24;
          uint64_t v41 = *(unsigned int *)(v39 + 8);
          uint64_t v42 = *(void *)(*(void *)(v39 - 24) + 144);
          if (v42) {
            break;
          }
          float v47 = (uint64_t **)HGObject::operator new(0x80uLL);
          HGBitmap::HGBitmap(v47, 0, 0, v41);
          char v111 = v47;
          int v48 = v115;
          if ((unint64_t)v115 < v116) {
            goto LABEL_39;
          }
          float v49 = std::vector<HGRef<HGBitmap>>::__push_back_slow_path<HGRef<HGBitmap>>(&__p, &v111);
          int v50 = v111;
          char v115 = v49;
          if (v111) {
            goto LABEL_47;
          }
LABEL_40:
          v39 += 40;
          if (v40 + 40 == v38) {
            goto LABEL_60;
          }
        }
        uint64_t v43 = *(void *)(v39 - 16);
        uint64_t v44 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void, uint64_t))(*(void *)a1 + 160))(a1, v42, *(void *)(v39 - 8), *(void *)v39, *(unsigned int *)(v39 + 8), v43);
        uint64_t v45 = v44;
        if (v43)
        {
          (*(void (**)(uint64_t))(*(void *)v43 + 16))(v43);
          char v111 = (uint64_t **)v43;
          int v46 = v115;
          if ((unint64_t)v115 >= v116)
          {
            char v115 = std::vector<HGRef<HGBitmap>>::__push_back_slow_path<HGRef<HGBitmap>>(&__p, &v111);
            if (v111) {
              ((void (*)(uint64_t **))(*v111)[3])(v111);
            }
          }
          else
          {
            *char v115 = v43;
            char v115 = v46 + 1;
          }
          if (!v45) {
            goto LABEL_40;
          }
          goto LABEL_54;
        }
        if (v44)
        {
          (*(void (**)(uint64_t))(*(void *)v44 + 16))(v44);
          char v111 = (uint64_t **)v45;
          float v51 = v115;
          if ((unint64_t)v115 >= v116)
          {
            char v115 = std::vector<HGRef<HGBitmap>>::__push_back_slow_path<HGRef<HGBitmap>>(&__p, &v111);
            if (v111) {
              ((void (*)(uint64_t **))(*v111)[3])(v111);
            }
          }
          else
          {
            *char v115 = v45;
            char v115 = v51 + 1;
          }
LABEL_54:
          (*(void (**)(uint64_t))(*(void *)v45 + 24))(v45);
          goto LABEL_40;
        }
        float v47 = (uint64_t **)HGObject::operator new(0x80uLL);
        HGBitmap::HGBitmap(v47, 0, 0, v41);
        char v111 = v47;
        int v48 = v115;
        if ((unint64_t)v115 >= v116)
        {
          int v52 = std::vector<HGRef<HGBitmap>>::__push_back_slow_path<HGRef<HGBitmap>>(&__p, &v111);
          int v50 = v111;
          char v115 = v52;
          if (!v111) {
            goto LABEL_40;
          }
LABEL_47:
          ((void (*)(uint64_t **))(*v111)[3])(v50);
          goto LABEL_40;
        }
LABEL_39:
        *int v48 = (uint64_t)v47;
        char v115 = v48 + 1;
        goto LABEL_40;
      }
LABEL_60:
      float v53 = *(HGNode ***)v8;
      int v54 = (HGNode **)*((void *)v8 + 1);
      if (*(HGNode ***)v8 != v54)
      {
        do
        {
          float v55 = (HGNode *)*((void *)*v53 + 18);
          if (v55) {
            HGRenderer::RenderNodeEnd((HGRenderer *)a1, v55);
          }
          v53 += 5;
        }
        while (v53 != v54);
        int v56 = *(unsigned int **)v8;
        float v57 = (unsigned int *)*((void *)v8 + 1);
        if (*(unsigned int **)v8 != v57)
        {
          uint64_t v58 = 0;
          while (*(void *)(*(void *)v56 + 144))
          {
            uint64_t v60 = (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 280))(a1, *(void *)((char *)__p + v58), v56[9]);
            char v111 = (uint64_t **)v60;
            float v61 = (uint64_t *)v6[1];
            if (v61 < v6[2])
            {
              *float v61 = v60;
              float v59 = v61 + 1;
LABEL_68:
              v6[1] = v59;
              goto LABEL_69;
            }
            int v62 = std::vector<HGRef<HGBitmap>>::__push_back_slow_path<HGRef<HGBitmap>>(v6, &v111);
            float v63 = v111;
            v6[1] = v62;
            if (v63) {
              goto LABEL_73;
            }
LABEL_69:
            v58 += 8;
            v56 += 10;
            if (v56 == v57) {
              goto LABEL_78;
            }
          }
          uint64_t v64 = v56[8];
          float v65 = (uint64_t **)HGObject::operator new(0x80uLL);
          HGBitmap::HGBitmap(v65, 0, 0, v64);
          char v111 = v65;
          float v66 = (uint64_t ***)v6[1];
          if (v66 >= v6[2])
          {
            int v67 = std::vector<HGRef<HGBitmap>>::__push_back_slow_path<HGRef<HGBitmap>>(v6, &v111);
            float v63 = v111;
            v6[1] = v67;
            if (!v63) {
              goto LABEL_69;
            }
LABEL_73:
            ((void (*)(uint64_t **))(*v63)[3])(v63);
            goto LABEL_69;
          }
          *float v66 = v65;
          float v59 = v66 + 1;
          goto LABEL_68;
        }
      }
LABEL_78:
      unsigned int v68 = (uint64_t *)__p;
      if (__p)
      {
        float v69 = v115;
        float v70 = __p;
        if (v115 != __p)
        {
          do
          {
            uint64_t v72 = *--v69;
            uint64_t v71 = v72;
            if (v72) {
              (*(void (**)(uint64_t))(*(void *)v71 + 24))(v71);
            }
          }
          while (v69 != v68);
          float v70 = __p;
        }
        char v115 = v68;
        operator delete(v70);
      }
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 264))(a1, 1);
    double v73 = (HGDotGraph *)(a1 + 840);
    if (HGDotGraph::on((HGDotGraph *)(a1 + 840)))
    {
      if (*(_DWORD *)(a1 + 640))
      {
        pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 288));
        pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 288));
      }
      if (!*(_DWORD *)(a1 + 636))
      {
        char v115 = 0;
        unint64_t v116 = 0;
        uint64_t v113 = 0;
        std::string __p = &v115;
        char v111 = &v112;
        uint64_t v112 = 0;
        char v75 = *(HGNode ***)v8;
        uint64_t v74 = (HGNode **)*((void *)v8 + 1);
        if (v75 != v74)
        {
          uint64_t v76 = 0;
          do
          {
            unint64_t v77 = *((void *)*v75 + 18);
            uint64_t v78 = &v112;
            int v79 = &v112;
            if (v112)
            {
              uint64_t v80 = v112;
              while (1)
              {
                while (1)
                {
                  int v79 = (uint64_t **)v80;
                  unint64_t v81 = v80[4];
                  if (v77 >= v81) {
                    break;
                  }
                  uint64_t v80 = *v79;
                  uint64_t v78 = v79;
                  if (!*v79) {
                    goto LABEL_101;
                  }
                }
                if (v81 >= v77) {
                  break;
                }
                uint64_t v80 = v79[1];
                if (!v80)
                {
                  uint64_t v78 = v79 + 1;
                  goto LABEL_101;
                }
              }
            }
            else
            {
LABEL_101:
              uint64_t v82 = (uint64_t *)operator new(0x28uLL);
              v82[4] = v77;
              *uint64_t v82 = 0;
              v82[1] = 0;
              void v82[2] = (uint64_t)v79;
              *uint64_t v78 = v82;
              if (*v111)
              {
                char v111 = (uint64_t **)*v111;
                uint64_t v82 = *v78;
              }
              std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v112, v82);
              uint64_t v76 = ++v113;
            }
            v75 += 5;
          }
          while (v75 != v74);
          if (v76)
          {
            do
            {
              int v83 = (uint64_t *)v111;
              uint64_t v84 = v111[1];
              int v85 = v111;
              if (v84)
              {
                do
                {
                  uint64_t v86 = (uint64_t **)v84;
                  uint64_t v84 = (uint64_t *)*v84;
                }
                while (v84);
              }
              else
              {
                do
                {
                  uint64_t v86 = (uint64_t **)v85[2];
                  BOOL v87 = *v86 == (uint64_t *)v85;
                  int v85 = v86;
                }
                while (!v87);
              }
              uint64_t v88 = v111[4];
              char v111 = v86;
              uint64_t v113 = v76 - 1;
              std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v112, v83);
              operator delete(v83);
              int v89 = v115;
              long long v90 = &v115;
              long long v91 = &v115;
              if (v115)
              {
                while (1)
                {
                  while (1)
                  {
                    long long v91 = (uint64_t **)v89;
                    unint64_t v92 = v89[4];
                    if ((unint64_t)v88 >= v92) {
                      break;
                    }
                    int v89 = *v91;
                    long long v90 = v91;
                    if (!*v91) {
                      goto LABEL_119;
                    }
                  }
                  if (v92 >= (unint64_t)v88) {
                    break;
                  }
                  int v89 = v91[1];
                  if (!v89)
                  {
                    long long v90 = v91 + 1;
                    goto LABEL_119;
                  }
                }
              }
              else
              {
LABEL_119:
                long long v93 = (uint64_t *)operator new(0x28uLL);
                v93[4] = (uint64_t)v88;
                *long long v93 = 0;
                v93[1] = 0;
                void v93[2] = (uint64_t)v91;
                *long long v90 = v93;
                if (*(void *)__p)
                {
                  std::string __p = *(void **)__p;
                  long long v93 = *v90;
                }
                std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v115, v93);
                ++v116;
              }
              HGRenderer::DotNode((HGRenderer *)a1, (HGNode *)v88);
              int v94 = *((_DWORD *)v88 + 22);
              if (v94 >= 1)
              {
                for (uint64_t i = 0; i < v94; ++i)
                {
                  uint64_t v96 = *(void *)(v88[10] + 8 * i);
                  if (v96)
                  {
                    uint64_t v97 = *(void *)(v96 + 16);
                    if (v97)
                    {
                      uint64_t v98 = v115;
                      unint64_t v99 = *(void *)(v97 + 144);
                      if (!v115) {
                        goto LABEL_137;
                      }
                      long long v100 = &v115;
                      do
                      {
                        uint64_t v101 = v98;
                        float v102 = v100;
                        unint64_t v103 = v98[4];
                        float32x4_t v104 = (uint64_t **)(v98 + 1);
                        if (v103 >= v99)
                        {
                          float32x4_t v104 = (uint64_t **)v101;
                          long long v100 = (uint64_t **)v101;
                        }
                        uint64_t v98 = *v104;
                      }
                      while (v98);
                      if (v100 == &v115) {
                        goto LABEL_137;
                      }
                      if (v103 < v99) {
                        uint64_t v101 = (uint64_t *)v102;
                      }
                      if (v99 < v101[4])
                      {
LABEL_137:
                        uint64_t v105 = &v112;
                        float32x4_t v106 = &v112;
                        if (v112)
                        {
                          float32x4_t v107 = v112;
                          while (1)
                          {
                            while (1)
                            {
                              float32x4_t v106 = (uint64_t **)v107;
                              unint64_t v108 = v107[4];
                              if (v99 >= v108) {
                                break;
                              }
                              float32x4_t v107 = *v106;
                              uint64_t v105 = v106;
                              if (!*v106) {
                                goto LABEL_144;
                              }
                            }
                            if (v108 >= v99) {
                              break;
                            }
                            float32x4_t v107 = v106[1];
                            if (!v107)
                            {
                              uint64_t v105 = v106 + 1;
                              goto LABEL_144;
                            }
                          }
                        }
                        else
                        {
LABEL_144:
                          float32x4_t v109 = (uint64_t *)operator new(0x28uLL);
                          v109[4] = v99;
                          *float32x4_t v109 = 0;
                          v109[1] = 0;
                          v109[2] = (uint64_t)v106;
                          *uint64_t v105 = v109;
                          if (*v111)
                          {
                            char v111 = (uint64_t **)*v111;
                            float32x4_t v109 = *v105;
                          }
                          std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v112, v109);
                          ++v113;
                          int v94 = *((_DWORD *)v88 + 22);
                        }
                      }
                    }
                  }
                }
              }
              uint64_t v76 = v113;
            }
            while (v113);
          }
        }
        std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)&v111, v112);
        std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)&__p, v115);
        double v73 = (HGDotGraph *)(a1 + 840);
      }
    }
    HGDotGraph::end(v73);
    HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v117);
  }
  else
  {
    HGLogger::warning((HGLogger *)"Invalid Renderer", a2, a3);
  }
}

void sub_1B77ADDE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a13) {
    (*(void (**)(uint64_t))(*(void *)a13 + 24))(a13);
  }
  std::vector<HGRef<HGBitmap>>::~vector[abi:ne180100](&__p);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a22);
  std::vector<HGRef<HGBitmap>>::~vector[abi:ne180100](v22);
  _Unwind_Resume(a1);
}

void HGRenderer::RenderBitmaps(HGRenderer *this, int a2, HGBitmap **a3, HGNode **a4, char *a5)
{
  int v36 = 0;
  float v37 = 0;
  uint64_t v38 = 0;
  if (a2 >= 1)
  {
    char v7 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = a2;
    uint64_t v32 = a2;
    while (1)
    {
      unsigned __int8 v10 = a4[v8];
      int v11 = a3[v8];
      uint64_t v12 = (long long *)((char *)v11 + 20);
      if (!v11) {
        uint64_t v12 = &HGRectNull;
      }
      long long v35 = *v12;
      if (v11)
      {
        int v13 = *((_DWORD *)v11 + 4);
        int v14 = v38;
        if (v7 >= (HGNode **)v38) {
          goto LABEL_10;
        }
LABEL_3:
        void *v7 = v10;
        v7[1] = (HGNode *)v11;
        *((_OWORD *)v7 + 1) = v35;
        *((_DWORD *)v7 + 8) = v13;
        *((_DWORD *)v7 + 9) = 0;
        float v37 = (char *)(v7 + 5);
        ++v8;
        v7 += 5;
        if (v8 == v9) {
          break;
        }
      }
      else
      {
        int v13 = 0;
        int v14 = v38;
        if (v7 < (HGNode **)v38) {
          goto LABEL_3;
        }
LABEL_10:
        int v15 = (HGNode **)v36;
        unint64_t v16 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v7 - (unsigned char *)v36) >> 3);
        unint64_t v17 = v16 + 1;
        if (v16 + 1 > 0x666666666666666) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v18 = 0xCCCCCCCCCCCCCCCDLL * ((v14 - (unsigned char *)v36) >> 3);
        if (2 * v18 > v17) {
          unint64_t v17 = 2 * v18;
        }
        if (v18 >= 0x333333333333333) {
          unint64_t v19 = 0x666666666666666;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          if (v19 > 0x666666666666666) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          float v20 = (char *)operator new(40 * v19);
        }
        else
        {
          float v20 = 0;
        }
        uint64_t v21 = &v20[8 * (((char *)v7 - (unsigned char *)v36) >> 3)];
        *(void *)uint64_t v21 = v10;
        *((void *)v21 + 1) = v11;
        *((_OWORD *)v21 + 1) = v35;
        *((_DWORD *)v21 + 8) = v13;
        *((_DWORD *)v21 + 9) = 0;
        long long v22 = &v20[40 * v16];
        if (v7 != v15)
        {
          do
          {
            long long v23 = *(_OWORD *)(v7 - 5);
            long long v24 = *(_OWORD *)(v7 - 3);
            *((void *)v22 - 1) = *(v7 - 1);
            *(_OWORD *)(v22 - 24) = v24;
            *(_OWORD *)(v22 - 4CVOpenGLESTextureCacheFlush(this[3], 0) = v23;
            v22 -= 40;
            v7 -= 5;
          }
          while (v7 != v15);
          char v7 = v15;
        }
        unint64_t v25 = v21 + 40;
        int v36 = v22;
        uint64_t v38 = &v20[40 * v19];
        if (v7) {
          operator delete(v7);
        }
        uint64_t v9 = v32;
        float v37 = v25;
        ++v8;
        char v7 = (HGNode **)v25;
        if (v8 == v32) {
          break;
        }
      }
    }
  }
  HGRenderer::RenderNodes((uint64_t)this, (const char *)&v36, (char *)1, (const char *)a4, a5, &__p);
  float v26 = (char *)__p;
  if (__p)
  {
    uint64_t v27 = v34;
    float v28 = __p;
    if (v34 != __p)
    {
      do
      {
        uint64_t v30 = *((void *)v27 - 1);
        v27 -= 8;
        uint64_t v29 = v30;
        if (v30) {
          (*(void (**)(uint64_t))(*(void *)v29 + 24))(v29);
        }
      }
      while (v27 != v26);
      float v28 = __p;
    }
    int v34 = v26;
    operator delete(v28);
  }
  if (v36) {
    operator delete(v36);
  }
}

void sub_1B77AE364(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGRenderer::GetBitmap(uint64_t a1, uint64_t a2, char *a3)
{
  if ((*(unsigned char *)(a2 + 12) & 0x30) != 0)
  {
    HGLogger::warning((HGLogger *)"  ERROR : bitmap is on GPU (with CPU renderer).", (const char *)a2, a3);
    return 0;
  }
  if (*(_DWORD *)(a2 + 16) != a3)
  {
    uint64_t v8 = (HGBitmap *)HGObject::operator new(0x80uLL);
    HGBitmap::HGBitmap(v8, *(HGRect *)(a2 + 20), (HGBitmap *)a2);
    uint64_t v9 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
    HGBitmapLoader::HGBitmapLoader(v9, v8);
    uint64_t v3 = (*(uint64_t (**)(uint64_t, void, void, char *, HGBitmapLoader *, uint64_t))(*(void *)a1 + 56))(a1, *(void *)(a2 + 20), *(void *)(a2 + 28), a3, v9, 1);
    if (v9) {
      (*(void (**)(HGBitmapLoader *))(*(void *)v9 + 24))(v9);
    }
    if (v8) {
      (*(void (**)(HGBitmap *))(*(void *)v8 + 24))(v8);
    }
    return v3;
  }
  (*(void (**)(uint64_t))(*(void *)a2 + 16))(a2);
  return a2;
}

void sub_1B77AE504(_Unwind_Exception *exception_object)
{
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGRenderer::GetTexture(HGRenderer *this, HGBitmap *a2, char *a3)
{
  return 0;
}

HGNode *HGRenderer::GetOutput(HGRenderer *this, HGNode *a2)
{
  if (!a2) {
    return 0;
  }
  if ((*((unsigned char *)a2 + 136) & 2) != 0) {
    return (HGNode *)*((void *)a2 + 18);
  }
  if (*((int *)a2 + 22) >= 1)
  {
    uint64_t v4 = **((void **)a2 + 10);
    if (v4)
    {
      if (*(void *)(v4 + 16))
      {
        if ((*(unsigned int (**)(HGNode *))(*(void *)a2 + 360))(a2))
        {
          uint64_t v5 = *(void *)(**((void **)a2 + 10) + 16);
          if ((*(unsigned int (**)(uint64_t))(*(void *)v5 + 360))(v5))
          {
            if (HGRenderer::IsMergeable(this, a2, 0, 0))
            {
              uint64_t v6 = *(void *)(**((void **)a2 + 10) + 16);
              (*(void (**)(uint64_t))(*(void *)v6 + 16))(v6);
              (*(void (**)(HGNode *, uint64_t))(*(void *)a2 + 368))(a2, v6);
              (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
            }
          }
        }
      }
    }
    int v7 = *((_DWORD *)a2 + 22);
    if (v7 >= 1)
    {
      for (uint64_t i = 0; i < v7; ++i)
      {
        uint64_t v9 = *(void *)(*((void *)a2 + 10) + 8 * i);
        if (v9)
        {
          unsigned __int8 v10 = *(HGNode **)(v9 + 16);
          if (v10)
          {
            HGRenderer::GetOutput(this, v10);
            int v7 = *((_DWORD *)a2 + 22);
          }
        }
      }
    }
  }
  GuardedOutput = HGNode::GetGuardedOutput(a2, this);
  Output = a2;
  if (GuardedOutput)
  {
    Output = a2;
    if (GuardedOutput != a2) {
      Output = (HGNode *)HGRenderer::GetOutput(this, GuardedOutput);
    }
  }
  *((void *)a2 + 18) = Output;
  *((void *)a2 + 23) = this;
  *((_DWORD *)a2 + 34) |= 2u;
  ++*((_DWORD *)this + 173);
  (*(void (**)(HGRenderer *, HGNode *))(*(void *)this + 176))(this, Output);
  return Output;
}

double HGRenderer::GetShaderCompileTime(HGRenderer *this)
{
  return 0.0;
}

unint64_t HGRenderer::GetStats(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
      unint64_t v3 = *(int *)(a1 + 596);
      if ((int)v3 <= 0) {
        return 0 / v3;
      }
      uint64_t v4 = 0;
      unint64_t v5 = 0;
      do
      {
        v5 += HGExecutionUnit::StackSize(*(HGExecutionUnit **)(*(void *)(a1 + 248) + 8 * v4++));
        unint64_t v6 = *(int *)(a1 + 596);
      }
      while (v4 < (uint64_t)v6);
      return v5 / v6;
    case 1:
      uint64_t v8 = *(unsigned int *)(a1 + 596);
      if ((int)v8 < 1) {
        return 0;
      }
      uint64_t v9 = *(void *)(a1 + 248);
      if (v8 == 1)
      {
        uint64_t v10 = 0;
        unint64_t result = 0;
LABEL_48:
        uint64_t v45 = (uint64_t *)(v9 + 8 * v10);
        uint64_t v46 = v8 - v10;
        do
        {
          uint64_t v47 = *v45++;
          result += **(void **)(v47 + 416);
          --v46;
        }
        while (v46);
        return result;
      }
      uint64_t v41 = 0;
      uint64_t v42 = 0;
      uint64_t v10 = v8 & 0xFFFFFFFE;
      uint64_t v43 = v9 + 8;
      uint64_t v44 = v10;
      do
      {
        v41 += **(void **)(*(void *)(v43 - 8) + 416);
        v42 += **(void **)(*(void *)v43 + 416);
        v43 += 16;
        v44 -= 2;
      }
      while (v44);
      unint64_t result = v42 + v41;
      if (v10 != v8) {
        goto LABEL_48;
      }
      return result;
    case 2:
      uint64_t v11 = *(unsigned int *)(a1 + 596);
      if ((int)v11 < 1) {
        return 0;
      }
      uint64_t v12 = *(void *)(a1 + 248);
      if (v11 == 1)
      {
        uint64_t v13 = 0;
        unint64_t result = 0;
LABEL_54:
        int v52 = (uint64_t *)(v12 + 8 * v13);
        uint64_t v53 = v11 - v13;
        do
        {
          uint64_t v54 = *v52++;
          result += *(void *)(*(void *)(v54 + 416) + 8);
          --v53;
        }
        while (v53);
        return result;
      }
      uint64_t v48 = 0;
      uint64_t v49 = 0;
      uint64_t v13 = v11 & 0xFFFFFFFE;
      uint64_t v50 = v12 + 8;
      uint64_t v51 = v13;
      do
      {
        v48 += *(void *)(*(void *)(*(void *)(v50 - 8) + 416) + 8);
        v49 += *(void *)(*(void *)(*(void *)v50 + 416) + 8);
        v50 += 16;
        v51 -= 2;
      }
      while (v51);
      unint64_t result = v49 + v48;
      if (v13 != v11) {
        goto LABEL_54;
      }
      return result;
    case 3:
      uint64_t v14 = *(unsigned int *)(a1 + 596);
      if ((int)v14 < 1) {
        return 0;
      }
      uint64_t v15 = *(void *)(a1 + 248);
      if (v14 == 1)
      {
        uint64_t v16 = 0;
        unint64_t result = 0;
LABEL_60:
        float v59 = (uint64_t *)(v15 + 8 * v16);
        uint64_t v60 = v14 - v16;
        do
        {
          uint64_t v61 = *v59++;
          result += *(void *)(*(void *)(v61 + 416) + 16);
          --v60;
        }
        while (v60);
        return result;
      }
      uint64_t v55 = 0;
      uint64_t v56 = 0;
      uint64_t v16 = v14 & 0xFFFFFFFE;
      uint64_t v57 = v15 + 8;
      uint64_t v58 = v16;
      do
      {
        v55 += *(void *)(*(void *)(*(void *)(v57 - 8) + 416) + 16);
        v56 += *(void *)(*(void *)(*(void *)v57 + 416) + 16);
        v57 += 16;
        v58 -= 2;
      }
      while (v58);
      unint64_t result = v56 + v55;
      if (v16 != v14) {
        goto LABEL_60;
      }
      return result;
    case 4:
      uint64_t v17 = *(unsigned int *)(a1 + 596);
      if ((int)v17 < 1) {
        return 0;
      }
      uint64_t v18 = *(void *)(a1 + 248);
      if (v17 == 1)
      {
        uint64_t v19 = 0;
        unint64_t result = 0;
LABEL_66:
        float v66 = (uint64_t *)(v18 + 8 * v19);
        uint64_t v67 = v17 - v19;
        do
        {
          uint64_t v68 = *v66++;
          result += *(void *)(*(void *)(v68 + 416) + 24);
          --v67;
        }
        while (v67);
        return result;
      }
      uint64_t v62 = 0;
      uint64_t v63 = 0;
      uint64_t v19 = v17 & 0xFFFFFFFE;
      uint64_t v64 = v18 + 8;
      uint64_t v65 = v19;
      do
      {
        v62 += *(void *)(*(void *)(*(void *)(v64 - 8) + 416) + 24);
        v63 += *(void *)(*(void *)(*(void *)v64 + 416) + 24);
        v64 += 16;
        v65 -= 2;
      }
      while (v65);
      unint64_t result = v63 + v62;
      if (v19 != v17) {
        goto LABEL_66;
      }
      return result;
    case 5:
      uint64_t v20 = *(unsigned int *)(a1 + 596);
      if ((int)v20 < 1) {
        return 0;
      }
      uint64_t v21 = *(void *)(a1 + 248);
      if (v20 == 1)
      {
        uint64_t v22 = 0;
        unint64_t result = 0;
LABEL_72:
        double v73 = (uint64_t *)(v21 + 8 * v22);
        uint64_t v74 = v20 - v22;
        do
        {
          uint64_t v75 = *v73++;
          result += *(void *)(*(void *)(v75 + 416) + 32);
          --v74;
        }
        while (v74);
        return result;
      }
      uint64_t v69 = 0;
      uint64_t v70 = 0;
      uint64_t v22 = v20 & 0xFFFFFFFE;
      uint64_t v71 = v21 + 8;
      uint64_t v72 = v22;
      do
      {
        v69 += *(void *)(*(void *)(*(void *)(v71 - 8) + 416) + 32);
        v70 += *(void *)(*(void *)(*(void *)v71 + 416) + 32);
        v71 += 16;
        v72 -= 2;
      }
      while (v72);
      unint64_t result = v70 + v69;
      if (v22 != v20) {
        goto LABEL_72;
      }
      return result;
    case 6:
      uint64_t v23 = *(unsigned int *)(a1 + 596);
      if ((int)v23 < 1) {
        return 0;
      }
      uint64_t v24 = *(void *)(a1 + 248);
      if (v23 == 1)
      {
        uint64_t v25 = 0;
        unint64_t result = 0;
LABEL_78:
        uint64_t v80 = (uint64_t *)(v24 + 8 * v25);
        uint64_t v81 = v23 - v25;
        do
        {
          uint64_t v82 = *v80++;
          result += *(void *)(*(void *)(v82 + 416) + 40);
          --v81;
        }
        while (v81);
        return result;
      }
      uint64_t v76 = 0;
      uint64_t v77 = 0;
      uint64_t v25 = v23 & 0xFFFFFFFE;
      uint64_t v78 = v24 + 8;
      uint64_t v79 = v25;
      do
      {
        v76 += *(void *)(*(void *)(*(void *)(v78 - 8) + 416) + 40);
        v77 += *(void *)(*(void *)(*(void *)v78 + 416) + 40);
        v78 += 16;
        v79 -= 2;
      }
      while (v79);
      unint64_t result = v77 + v76;
      if (v25 != v23) {
        goto LABEL_78;
      }
      return result;
    case 7:
      uint64_t v26 = *(unsigned int *)(a1 + 596);
      if ((int)v26 < 1) {
        return 0;
      }
      uint64_t v27 = *(void *)(a1 + 248);
      if (v26 == 1)
      {
        uint64_t v28 = 0;
        unint64_t result = 0;
LABEL_84:
        BOOL v87 = (uint64_t *)(v27 + 8 * v28);
        uint64_t v88 = v26 - v28;
        do
        {
          uint64_t v89 = *v87++;
          result += *(void *)(*(void *)(v89 + 416) + 48);
          --v88;
        }
        while (v88);
        return result;
      }
      uint64_t v83 = 0;
      uint64_t v84 = 0;
      uint64_t v28 = v26 & 0xFFFFFFFE;
      uint64_t v85 = v27 + 8;
      uint64_t v86 = v28;
      do
      {
        v83 += *(void *)(*(void *)(*(void *)(v85 - 8) + 416) + 48);
        v84 += *(void *)(*(void *)(*(void *)v85 + 416) + 48);
        v85 += 16;
        v86 -= 2;
      }
      while (v86);
      unint64_t result = v84 + v83;
      if (v28 != v26) {
        goto LABEL_84;
      }
      return result;
    case 8:
      uint64_t v29 = *(unsigned int *)(a1 + 596);
      if ((int)v29 < 1) {
        return 0;
      }
      uint64_t v30 = *(void *)(a1 + 248);
      if (v29 == 1)
      {
        uint64_t v31 = 0;
        unint64_t result = 0;
LABEL_90:
        int v94 = (uint64_t *)(v30 + 8 * v31);
        uint64_t v95 = v29 - v31;
        do
        {
          uint64_t v96 = *v94++;
          result += *(void *)(*(void *)(v96 + 416) + 56);
          --v95;
        }
        while (v95);
        return result;
      }
      uint64_t v90 = 0;
      uint64_t v91 = 0;
      uint64_t v31 = v29 & 0xFFFFFFFE;
      uint64_t v92 = v30 + 8;
      uint64_t v93 = v31;
      do
      {
        v90 += *(void *)(*(void *)(*(void *)(v92 - 8) + 416) + 56);
        v91 += *(void *)(*(void *)(*(void *)v92 + 416) + 56);
        v92 += 16;
        v93 -= 2;
      }
      while (v93);
      unint64_t result = v91 + v90;
      if (v31 != v29) {
        goto LABEL_90;
      }
      return result;
    case 9:
      uint64_t v32 = *(unsigned int *)(a1 + 596);
      if ((int)v32 < 1) {
        return 0;
      }
      uint64_t v33 = *(void *)(a1 + 248);
      if (v32 == 1)
      {
        uint64_t v34 = 0;
        unint64_t result = 0;
LABEL_96:
        uint64_t v101 = (uint64_t *)(v33 + 8 * v34);
        uint64_t v102 = v32 - v34;
        do
        {
          uint64_t v103 = *v101++;
          result += *(void *)(*(void *)(v103 + 416) + 72);
          --v102;
        }
        while (v102);
        return result;
      }
      uint64_t v97 = 0;
      uint64_t v98 = 0;
      uint64_t v34 = v32 & 0xFFFFFFFE;
      uint64_t v99 = v33 + 8;
      uint64_t v100 = v34;
      do
      {
        v97 += *(void *)(*(void *)(*(void *)(v99 - 8) + 416) + 72);
        v98 += *(void *)(*(void *)(*(void *)v99 + 416) + 72);
        v99 += 16;
        v100 -= 2;
      }
      while (v100);
      unint64_t result = v98 + v97;
      if (v34 != v32) {
        goto LABEL_96;
      }
      return result;
    case 10:
      return *(int *)(a1 + 692);
    case 11:
      return *(int *)(a1 + 696);
    case 12:
      return *(void *)(a1 + 1064) - *(void *)(a1 + 1056);
    case 13:
      uint64_t v35 = *(unsigned int *)(a1 + 596);
      if ((int)v35 < 1) {
        return 0;
      }
      uint64_t v36 = *(void *)(a1 + 248);
      if (v35 == 1)
      {
        uint64_t v37 = 0;
        unint64_t result = 0;
LABEL_102:
        unint64_t v108 = (uint64_t *)(v36 + 8 * v37);
        uint64_t v109 = v35 - v37;
        do
        {
          uint64_t v110 = *v108++;
          result += *(void *)(*(void *)(v110 + 416) + 80);
          --v109;
        }
        while (v109);
        return result;
      }
      uint64_t v104 = 0;
      uint64_t v105 = 0;
      uint64_t v37 = v35 & 0xFFFFFFFE;
      uint64_t v106 = v36 + 8;
      uint64_t v107 = v37;
      do
      {
        v104 += *(void *)(*(void *)(*(void *)(v106 - 8) + 416) + 80);
        v105 += *(void *)(*(void *)(*(void *)v106 + 416) + 80);
        v106 += 16;
        v107 -= 2;
      }
      while (v107);
      unint64_t result = v105 + v104;
      if (v37 != v35) {
        goto LABEL_102;
      }
      return result;
    case 14:
      uint64_t v38 = *(unsigned int *)(a1 + 596);
      if ((int)v38 < 1) {
        return 0;
      }
      uint64_t v39 = *(void *)(a1 + 248);
      if (v38 == 1)
      {
        uint64_t v40 = 0;
        unint64_t result = 0;
LABEL_108:
        char v115 = (uint64_t *)(v39 + 8 * v40);
        uint64_t v116 = v38 - v40;
        do
        {
          uint64_t v117 = *v115++;
          result += *(void *)(*(void *)(v117 + 416) + 88);
          --v116;
        }
        while (v116);
        return result;
      }
      uint64_t v111 = 0;
      uint64_t v112 = 0;
      uint64_t v40 = v38 & 0xFFFFFFFE;
      uint64_t v113 = v39 + 8;
      uint64_t v114 = v40;
      do
      {
        v111 += *(void *)(*(void *)(*(void *)(v113 - 8) + 416) + 88);
        v112 += *(void *)(*(void *)(*(void *)v113 + 416) + 88);
        v113 += 16;
        v114 -= 2;
      }
      while (v114);
      unint64_t result = v112 + v111;
      if (v40 != v38) {
        goto LABEL_108;
      }
      return result;
    default:
      return 0;
  }
}

uint64_t HGRenderer::GetLimits(HGRenderer *this, int a2)
{
  if (a2 == 327680) {
    return *((void *)this + 103);
  }
  if (a2 == 393216) {
    return *((void *)this + 102);
  }
  return 0;
}

BOOL HGRenderer::IsMergeable(HGRenderer *this, HGNode *a2, unsigned int a3, int a4)
{
  if ((a3 & 0x80000000) != 0)
  {
    int v8 = *((_DWORD *)a2 + 4);
    if ((v8 & 0x26) != 0) {
      return 0;
    }
  }
  else
  {
    if (*((_DWORD *)a2 + 22) > (signed int)a3)
    {
      uint64_t v7 = *(void *)(*((void *)a2 + 10) + 8 * a3);
      if (v7)
      {
        int v8 = *(_DWORD *)(v7 + 12);
        uint64_t v9 = *(void *)(v7 + 16);
        if (v9)
        {
          int v10 = *(_DWORD *)(v9 + 16);
          v8 |= v10 | *(_DWORD *)(HGRenderer::GetOutput(this, (HGNode *)v9) + 16);
        }
        if ((v8 & 0x26) == 0) {
          goto LABEL_11;
        }
        return 0;
      }
    }
    LOBYTE(v8) = 0;
  }
LABEL_11:
  int v12 = *((_DWORD *)this + 208) | v8 & 0x40;
  BOOL result = v12 != 0;
  if (v12) {
    BOOL v13 = a4 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (!v13)
  {
    if (*((void *)a2 + 16) < 2uLL) {
      return 1;
    }
    uint64_t v14 = (char *)*((void *)a2 + 14);
    uint64_t v15 = (char *)a2 + 120;
    if (v14 == v15)
    {
      return 1;
    }
    else
    {
      unsigned int v16 = 0;
      do
      {
        if (HGRenderer::GetOutput(this, **((HGNode ***)v14 + 4)) == **((void **)v14 + 4)) {
          ++v16;
        }
        uint64_t v17 = (char *)*((void *)v14 + 1);
        if (v17)
        {
          do
          {
            uint64_t v18 = v17;
            uint64_t v17 = *(char **)v17;
          }
          while (v17);
        }
        else
        {
          do
          {
            uint64_t v18 = (char *)*((void *)v14 + 2);
            BOOL v13 = *(void *)v18 == (void)v14;
            uint64_t v14 = v18;
          }
          while (!v13);
        }
        uint64_t v14 = v18;
      }
      while (v18 != v15);
      return v16 < 2;
    }
  }
  return result;
}

uint64_t HGRenderer::GetROI(HGRenderer *this, HGNode *a2)
{
  Output = HGRenderer::GetOutput(this, a2);
  unint64_t v3 = &HGRectNull;
  if (Output && (*((unsigned char *)Output + 136) & 8) != 0) {
    unint64_t v3 = (long long *)((char *)Output + 168);
  }
  return *(void *)v3;
}

HGNode *HGRenderer::GetInput(HGRenderer *this, HGNode *a2, unsigned int a3)
{
  if (a2
    && (a3 & 0x80000000) == 0
    && *((_DWORD *)a2 + 22) > (signed int)a3
    && (uint64_t v3 = *(void *)(*((void *)a2 + 10) + 8 * a3)) != 0)
  {
    return HGRenderer::GetOutput(this, *(HGNode **)(v3 + 16));
  }
  else
  {
    return 0;
  }
}

uint64_t HGRenderer::GetProgram(HGRenderer *this, HGNode *a2)
{
  return (*(uint64_t (**)(HGNode *, HGRenderer *))(*(void *)a2 + 184))(a2, this);
}

uint64_t HGRenderer::CreateDepthBufferManagers(uint64_t this)
{
  if (*(_DWORD *)(this + 596) > (int)((*(void *)(this + 232) - *(void *)(this + 224)) >> 3)) {
    operator new();
  }
  return this;
}

void sub_1B77AF49C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C402DBA53A3);
  _Unwind_Resume(a1);
}

void StatsAccumulator::StatsAccumulator(StatsAccumulator *this)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 6) = 0;
  *((void *)this + 2) = 0;
  HGLogger::setLevel((HGLogger *)"stats", (const char *)1);
  unint64_t v2 = *((void *)this + 1) - *(void *)this;
  if (v2 > 0xC7)
  {
    if (v2 != 200) {
      *((void *)this + 1) = *(void *)this + 200;
    }
  }
  else
  {
    std::vector<float>::__append((char **)this, 50 - (v2 >> 2));
  }
  int v3 = *((_DWORD *)this + 6);
  if (v3 >= 49) {
    int v3 = 49;
  }
  *((_DWORD *)this + 6) = v3;
}

void sub_1B77AF548(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void StatsAccumulator::~StatsAccumulator(StatsAccumulator *this)
{
  unint64_t v2 = *(void **)this;
  if (v2)
  {
    *((void *)this + 1) = v2;
    operator delete(v2);
  }
}

uint64_t HGRenderer::UpdateLimits(HGRenderer *this, HGLimits *a2, int a3)
{
  *((void *)a2 + 4) = 0;
  *(_OWORD *)a2 = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  *((_DWORD *)a2 + 5) = -1;
  *((_DWORD *)a2 + 11) = -1;
  int v3 = 74448896;
  if ((a3 & 0x4700000) != 0 || (int v3 = 75497472, (a3 & 0x4800000) != 0))
  {
    *(_DWORD *)a2 = v3;
    char v4 = 16;
    *((_WORD *)a2 + 12) = 16;
    *((unsigned char *)a2 + 27) = 8;
  }
  else if ((a3 & 0x8100000) != 0)
  {
    char v4 = 32;
    *((_WORD *)a2 + 12) = 32;
    *((unsigned char *)a2 + 26) = 0;
  }
  else
  {
    *(_DWORD *)a2 = 0x1000000;
    *((_WORD *)a2 + 12) = -1;
    char v4 = -1;
    *((unsigned char *)a2 + 27) = -1;
  }
  *((unsigned char *)a2 + 28) = v4;
  *((unsigned char *)a2 + 29) = v4;
  *(_DWORD *)((char *)a2 + 34) = 0x80000;
  *((unsigned char *)a2 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = 8 * ((a3 & 0xF0000) == 393216);
  *((unsigned char *)a2 + 41) = 0;
  if ((a3 & 0xF0000) == 0x60000) {
    char v5 = 1;
  }
  else {
    char v5 = 8;
  }
  *((unsigned char *)a2 + 42) = v5;
  *((unsigned char *)a2 + 43) = 0;
  return HGLimits::setnormalized((uint64_t)a2, 0);
}

uint64_t HGRenderer::PreRenderTraversal(HGNode *)::PreRenderUserGraphTraversalVisitor::visitNode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a3 + 448))(a3);
}

uint64_t HGRenderer::PreRenderTraversal(HGNode *)::PreRenderRenderGraphTraversalVisitor::visitNode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a3 + 448))(a3);
}

void HGSampler::HGSampler(HGSampler *this, HGExecutionUnit *a2)
{
  HGObject::HGObject(this);
  *(void *)uint64_t v3 = &unk_1F10D6108;
  *(_DWORD *)(v3 + 112) = 0;
  *(void *)(v3 + 24) = 0;
  *(void *)(v3 + 32) = 0;
  *(void *)(v3 + 16) = a2;
  *(_OWORD *)(v3 + 48) = xmmword_1B7E736C0;
  *(_OWORD *)(v3 + 64) = xmmword_1B8345FA0;
  *(_OWORD *)(v3 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = xmmword_1B8345FB0;
  *(_OWORD *)(v3 + 96) = xmmword_1B8345FC0;
  HgcSampler::Create((HgcSampler *)v3);
}

void sub_1B77AF73C(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGSampler::~HGSampler(HGSampler *this)
{
  *(void *)this = &unk_1F10D6108;
  HgcSampler::Destroy(*((void *)this + 15));
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    HGFree(v2);
  }

  HGObject::~HGObject(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10D6108;
  HgcSampler::Destroy(*((void *)this + 15));
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    HGFree(v2);
  }
  HGObject::~HGObject(this);

  HGObject::operator delete(v3);
}

void HGSampler::ReadTile(float32x4_t *a1, _DWORD *a2, uint64_t a3, int8x16_t *a4, unint64_t a5, unint64_t a6, uint64_t a7)
{
  if (a3) {
    HGSampler::GetTile(a1, a2, a3, a4, a5, a6, a7);
  }
  else {
    (*(void (**)(_DWORD *, int8x16_t *, unint64_t, unint64_t, uint64_t))(*(void *)a2 + 72))(a2, a4, a5, a6, a7);
  }
}

void HGSampler::GetTile(float32x4_t *a1, _DWORD *a2, uint64_t a3, int8x16_t *a4, unint64_t a5, unint64_t a6, uint64_t a7)
{
  unint64_t v14 = HIDWORD(a6);
  v322.i64[0] = a5;
  v322.i64[1] = 0x100000000;
  v323.i64[0] = __PAIR64__(HIDWORD(a5), a6);
  unint64_t v307 = HIDWORD(a5);
  v323.i64[1] = 0x100000000;
  v324.i64[0] = a6;
  v324.i64[1] = 0x100000000;
  v325.i64[0] = __PAIR64__(HIDWORD(a6), a5);
  v325.i64[1] = 0x100000000;
  int32x4_t v322 = (int32x4_t)vaddq_f32(vcvtq_f32_s32(v322), (float32x4_t)xmmword_1B7E76310);
  int32x4_t v323 = (int32x4_t)vaddq_f32(vcvtq_f32_s32(v323), (float32x4_t)xmmword_1B7E75550);
  int32x4_t v324 = (int32x4_t)vaddq_f32(vcvtq_f32_s32(v324), (float32x4_t)xmmword_1B8345FD0);
  float32x4_t v325 = vaddq_f32(vcvtq_f32_s32((int32x4_t)v325), (float32x4_t)xmmword_1B8345FE0);
  (*(void (**)(uint64_t, int32x4_t *, int32x4_t *, uint64_t))(*(void *)a3 + 208))(a3, &v322, &v322, 4);
  v15.i32[0] = v322.i32[3];
  v16.i32[0] = v323.i32[3];
  v17.i32[0] = v324.i32[3];
  _Q0.i32[0] = v325.i32[3];
  if (((*(float *)&v322.i32[3] < 0.00024414) | (8 * (v325.f32[3] < 0.00024414)) | (4
                                                                                  * (*(float *)&v324.i32[3] < 0.00024414)) | (2 * (*(float *)&v323.i32[3] < 0.00024414))) == 0xF)
  {
LABEL_54:
    int v70 = (*(float *)&v322.i32[3] < 0.00024414) | (8 * (v325.f32[3] < 0.00024414)) | (4
                                                                                    * (*(float *)&v324.i32[3] < 0.00024414)) | (2 * (*(float *)&v323.i32[3] < 0.00024414));
    int v71 = a7;
    if (a7)
    {
      int v72 = a5;
      int v73 = a6;
      int v74 = v14 - v307;
      if ((int)v14 > (int)v307)
      {
        size_t v75 = 16 * (v73 - (int)a5);
        uint64_t v76 = a4;
        do
        {
          bzero(v76, v75);
          v76 += v73 - v72 + v71;
          --v74;
        }
        while (v74);
      }
      if ((a1[7].i8[0] & 1) == 0) {
        return;
      }
    }
    else
    {
      int v73 = a6;
      int v72 = a5;
      bzero(a4, 16 * ((int)a6 - (int)a5) * ((int)v14 - (int)v307));
      if ((a1[7].i8[0] & 1) == 0) {
        return;
      }
    }
    _Q0.i32[0] = 0;
    v15.i32[0] = 15;
    v17.i32[0] = v70;
    a4[(((int)v14 - (int)v307) >> 1) * (v73 - v72 + v71) + ((v73 - v72) >> 1)] = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v17, (int32x4_t)_Q0), 0), (int8x16_t)xmmword_1B7E75640, vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v17, (int32x4_t)v15), 0), (int8x16_t)xmmword_1B7E73E70, (int8x16_t)xmmword_1B7E74540));
    return;
  }
  if (*(float *)&v322.i32[3] >= 0.00024414)
  {
    *(float32x2_t *)v22.f32 = vdiv_f32(*(float32x2_t *)v322.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v15.f32, 0));
    v22.f32[2] = *(float *)&v322.i32[2] / *(float *)&v322.i32[3];
    v22.i32[3] = v322.i32[3];
    if (*(float *)&v323.i32[3] < 0.00024414) {
      goto LABEL_8;
    }
LABEL_22:
    *(float32x2_t *)v26.f32 = vdiv_f32(*(float32x2_t *)v323.i8, (float32x2_t)vdup_lane_s32(v16, 0));
    v26.f32[2] = *(float *)&v323.i32[2] / *(float *)&v323.i32[3];
    v26.i32[3] = v323.i32[3];
    if (*(float *)&v324.i32[3] >= 0.00024414) {
      goto LABEL_13;
    }
    goto LABEL_23;
  }
  uint64_t v19 = 2;
  if (v325.f32[3] >= 0.00024414) {
    uint64_t v19 = 3;
  }
  if (*(float *)&v323.i32[3] >= 0.00024414) {
    uint64_t v19 = 1;
  }
  uint64_t v20 = (float32x2_t *)(&v322 + v19);
  float v21 = (float)(0.00024414 - *(float *)&v322.i32[3]) / (float)(v20[1].f32[1] - *(float *)&v322.i32[3]);
  *(float32x2_t *)v22.f32 = vmul_f32(vadd_f32(*(float32x2_t *)v322.i8, vmul_n_f32(vsub_f32(*v20, *(float32x2_t *)v322.i8), v21)), (float32x2_t)vdup_n_s32(0x45800000u));
  v22.f32[2] = (float)(*(float *)&v322.i32[2] + (float)(v21 * (float)(v20[1].f32[0] - *(float *)&v322.i32[2]))) * 4096.0;
  v22.i32[3] = 964689920;
  if (*(float *)&v323.i32[3] >= 0.00024414) {
    goto LABEL_22;
  }
LABEL_8:
  uint64_t v23 = 3;
  if (*(float *)&v322.i32[3] >= 0.00024414) {
    uint64_t v23 = 0;
  }
  if (*(float *)&v324.i32[3] >= 0.00024414) {
    uint64_t v23 = 2;
  }
  uint64_t v24 = (float32x2_t *)(&v322 + v23);
  float v25 = (float)(0.00024414 - *(float *)&v323.i32[3]) / (float)(v24[1].f32[1] - *(float *)&v323.i32[3]);
  *(float32x2_t *)v26.f32 = vmul_f32(vadd_f32(*(float32x2_t *)v323.i8, vmul_n_f32(vsub_f32(*v24, *(float32x2_t *)v323.i8), v25)), (float32x2_t)vdup_n_s32(0x45800000u));
  v26.f32[2] = (float)(*(float *)&v323.i32[2] + (float)(v25 * (float)(v24[1].f32[0] - *(float *)&v323.i32[2]))) * 4096.0;
  v26.i32[3] = 964689920;
  if (*(float *)&v324.i32[3] >= 0.00024414)
  {
LABEL_13:
    *(float32x2_t *)v27.f32 = vdiv_f32(*(float32x2_t *)v324.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v17.f32, 0));
    v27.f32[2] = *(float *)&v324.i32[2] / *(float *)&v324.i32[3];
    v27.i32[3] = v324.i32[3];
    if (v325.f32[3] < 0.00024414) {
      goto LABEL_14;
    }
    goto LABEL_26;
  }
LABEL_23:
  uint64_t v35 = *(float *)&v323.i32[3] >= 0.00024414;
  if (v325.f32[3] >= 0.00024414) {
    uint64_t v35 = 3;
  }
  uint64_t v36 = (float32x2_t *)(&v322 + v35);
  float v37 = (float)(0.00024414 - *(float *)&v324.i32[3]) / (float)(v36[1].f32[1] - *(float *)&v324.i32[3]);
  *(float32x2_t *)v27.f32 = vmul_f32(vadd_f32(*(float32x2_t *)v324.i8, vmul_n_f32(vsub_f32(*v36, *(float32x2_t *)v324.i8), v37)), (float32x2_t)vdup_n_s32(0x45800000u));
  v27.f32[2] = (float)(*(float *)&v324.i32[2] + (float)(v37 * (float)(v36[1].f32[0] - *(float *)&v324.i32[2]))) * 4096.0;
  v27.i32[3] = 964689920;
  if (v325.f32[3] < 0.00024414)
  {
LABEL_14:
    uint64_t v28 = 2;
    if (*(float *)&v324.i32[3] < 0.00024414) {
      uint64_t v28 = 1;
    }
    if (*(float *)&v322.i32[3] >= 0.00024414) {
      uint64_t v28 = 0;
    }
    uint64_t v29 = (float32x2_t *)(&v322 + v28);
    float v30 = (float)(0.00024414 - v325.f32[3]) / (float)(v29[1].f32[1] - v325.f32[3]);
    *(float32x2_t *)v31.f32 = vmul_f32(vadd_f32(*(float32x2_t *)v325.f32, vmul_n_f32(vsub_f32(*v29, *(float32x2_t *)v325.f32), v30)), (float32x2_t)vdup_n_s32(0x45800000u));
    v31.f32[2] = (float)(v325.f32[2] + (float)(v30 * (float)(v29[1].f32[0] - v325.f32[2]))) * 4096.0;
    v31.i32[3] = 964689920;
    __int32 v32 = a1[2].i32[1];
    float32x4_t v33 = (float32x4_t)xmmword_1B7E76310;
    if (v32) {
      goto LABEL_19;
    }
LABEL_27:
    float32x4_t v33 = 0uLL;
    __asm { FMOV            V0.4S, #1.0 }
    unsigned int v34 = 1;
    goto LABEL_29;
  }
LABEL_26:
  *(float32x2_t *)v31.f32 = vdiv_f32(*(float32x2_t *)v325.f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)_Q0.f32, 0));
  v31.f32[2] = v325.f32[2] / v325.f32[3];
  v31.i32[3] = v325.i32[3];
  __int32 v32 = a1[2].i32[1];
  float32x4_t v33 = (float32x4_t)xmmword_1B7E76310;
  if (!v32) {
    goto LABEL_27;
  }
LABEL_19:
  if (v32 == 1)
  {
    _Q0.i64[0] = 0x4000000040000000;
    _Q0.i64[1] = 0x4000000040000000;
    unsigned int v34 = 2;
  }
  else
  {
    float32x4_t v33 = (float32x4_t)xmmword_1B8345FF0;
    __asm { FMOV            V0.4S, #4.0 }
    unsigned int v34 = 4;
  }
LABEL_29:
  float32x4_t v305 = v33;
  float32x4_t v42 = vsubq_f32(vminq_f32(v22, vminq_f32(v26, vminq_f32(v27, v31))), v33);
  float32x4_t v17 = vcvtq_f32_s32(vcvtq_s32_f32(v42));
  float32x4_t v15 = vaddq_f32(v17, vcvtq_f32_s32(vcgtq_f32(v17, v42)));
  unint64_t v43 = vcvtq_s32_f32(v15).u64[0];
  int v44 = v43;
  if ((int)v43 >= a2[7]) {
    goto LABEL_54;
  }
  int v45 = HIDWORD(v43);
  if (SHIDWORD(v43) >= a2[8]) {
    goto LABEL_54;
  }
  float32x4_t v46 = vsubq_f32(vmaxq_f32(v22, vmaxq_f32(v26, vmaxq_f32(v27, v31))), v305);
  float32x4_t v17 = vcvtq_f32_s32(vcvtq_s32_f32(v46));
  float32x4_t v15 = vsubq_f32(v17, vcvtq_f32_s32(vcgtq_f32(v46, v17)));
  _Q0 = vaddq_f32(_Q0, v15);
  unint64_t v47 = vcvtq_s32_f32(_Q0).u64[0];
  if ((int)v47 <= a2[5] || SHIDWORD(v47) <= a2[6]) {
    goto LABEL_54;
  }
  __n128 v304 = a2;
  float v48 = v22.f32[3] / v31.f32[3];
  if (v31.f32[3] > v22.f32[3]) {
    float v48 = v31.f32[3] / v22.f32[3];
  }
  float v49 = v26.f32[3] / v27.f32[3];
  if (v27.f32[3] > v26.f32[3]) {
    float v49 = v27.f32[3] / v26.f32[3];
  }
  float v50 = v26.f32[3] / v22.f32[3];
  if (v26.f32[3] <= v22.f32[3]) {
    float v50 = v22.f32[3] / v26.f32[3];
  }
  float v51 = v27.f32[3] / v31.f32[3];
  if (v27.f32[3] <= v31.f32[3]) {
    float v51 = v31.f32[3] / v27.f32[3];
  }
  *((void *)&v303 + 1) = a6;
  if ((int)v14 - (int)v307 >= 2)
  {
    int v52 = a6 - a5;
    if ((int)a6 - (int)a5 >= 2)
    {
      BOOL v53 = v48 <= 1.0625 && v49 <= 1.0625;
      BOOL v54 = v53 && v50 <= 1.0625;
      if (!v54 || v51 > 1.0625)
      {
        unsigned int v56 = a6;
        int v290 = a7;
        signed int v57 = ((int)a6 + (int)a5) >> 1;
        uint64_t v310 = 0;
        long long v308 = 0u;
        long long v309 = 0u;
        HGExecutionUnit::GetStackState(a1[1].i64[0], (uint64_t)&v308);
        uint64_t v58 = HGRectMake4i(a5, v307, v57, ((int)v14 + (int)v307) >> 1);
        unsigned int v306 = v56 - v57 + a7;
        HGSampler::GetTile(a1, v304, a3, a4, v58, v59, v306);
        LODWORD(v303) = v52 + a7;
        int v60 = ((((int)v14 + (int)v307) >> 1) - v307) * (v52 + a7);
        HGExecutionUnit::CommitStack(a1[1].i64[0], (uint64_t)a4, v60);
        unsigned int v61 = ((int)v14 + (int)v307) >> 1;
        uint64_t v62 = HGRectMake4i(v57, v307, v56, v61);
        HGSampler::GetTile(a1, v304, a3, &a4[v57 - (int)a5], v62, v63, (v57 - a5 + v290));
        uint64_t i64 = (uint64_t)a4[v60].i64;
        uint64_t v65 = HGRectMake4i(a5, v61, v57, v14);
        HGSampler::GetTile(a1, v304, a3, i64, v65, v66, v306);
        HGExecutionUnit::CommitStack(a1[1].i64[0], i64, (int)((v14 - v61) * v303));
        uint64_t v67 = HGRectMake4i(v57, v61, DWORD2(v303), v14);
        HGSampler::GetTile(a1, v304, a3, i64 + 16 * (v57 - (int)a5), v67, v68, (v57 - a5 + v290));
        uint64_t v69 = a1[1].i64[0];
        v320[0] = v308;
        v320[1] = v309;
        uint64_t v321 = v310;
        HGExecutionUnit::SetStackState(v69, v320);
        return;
      }
    }
  }
  int v298 = v14 - v307;
  *(void *)&long long v303 = a5;
  v322.i64[0] = v22.i64[0];
  float32x2_t v296 = *(float32x2_t *)v26.f32;
  float32x4_t v297 = v22;
  v322.i64[1] = v22.u32[2] | 0x3F80000000000000;
  v323.i64[0] = v26.i64[0];
  v323.i64[1] = v26.u32[2] | 0x3F80000000000000;
  v324.i64[0] = v27.i64[0];
  float32x4_t v294 = v31;
  float32x4_t v295 = v27;
  v324.i64[1] = v27.u32[2] | 0x3F80000000000000;
  v325.i64[0] = v31.i64[0];
  v325.i64[1] = v31.u32[2] | 0x3F80000000000000;
  uint64_t v77 = *(void *)(v304 + 5);
  uint64_t v78 = *(void *)(v304 + 7);
  unsigned int v79 = v34;
  int32x2_t v299 = (int32x2_t)v43;
  int32x2_t v301 = (int32x2_t)v47;
  uint64_t v80 = HGRectMake4i(-v34, -v34, v34, v34);
  uint64_t v81 = HGRectGrow(v77, v78, v80);
  if (v44 <= (int)v81) {
    unsigned int v84 = v81;
  }
  else {
    unsigned int v84 = v44;
  }
  unsigned int v293 = v79;
  int32x2_t v85 = vadd_s32(v299, vdup_n_s32(v79));
  if (v45 <= SHIDWORD(v81)) {
    unsigned int v86 = HIDWORD(v81);
  }
  else {
    unsigned int v86 = v45;
  }
  *(int32x2_t *)v83.i8 = vmax_s32(vmin_s32(v301, v82), v85);
  __int32 v87 = v83.i32[0];
  int32x4_t v300 = v83;
  __int32 v88 = v83.i32[1];
  uint64_t v89 = HGRectMake4i(v84, v86, v83.u32[0], v83.u32[1]);
  uint64_t v302 = v90;
  unsigned int v291 = v84;
  unsigned __int32 v91 = v88 - v86;
  unsigned __int32 v292 = v87 - v84;
  unint64_t v92 = (int)v91 * (uint64_t)(int)(v87 - v84);
  if (v92 < (int)(2
                 * (*(uint64_t (**)(void, uint64_t))(**(void **)(a1[1].i64[0] + 152) + 128))(*(void *)(a1[1].i64[0] + 152), 3)))goto LABEL_70;
  int v100 = DWORD2(v303) - v303;
  if (v298 >= DWORD2(v303) - (int)v303 && v298 >= 2)
  {
    unsigned int v101 = ((int)v14 + (int)v307) >> 1;
    uint64_t v310 = 0;
    long long v308 = 0u;
    long long v309 = 0u;
    HGExecutionUnit::GetStackState(a1[1].i64[0], (uint64_t)&v308);
    uint64_t v102 = HGRectMake4i(v303, v307, DWORD2(v303), v101);
    HGSampler::GetTile(a1, v304, a3, a4, v102, v103, a7);
    unsigned int v104 = v14;
    int v105 = (v101 - v307) * (v100 + a7);
    HGExecutionUnit::CommitStack(a1[1].i64[0], (uint64_t)a4, v105);
    uint64_t v106 = HGRectMake4i(v303, v101, DWORD2(v303), v104);
    HGSampler::GetTile(a1, v304, a3, &a4[v105], v106, v107, a7);
    uint64_t v108 = a1[1].i64[0];
    v318[0] = v308;
    v318[1] = v309;
    uint64_t v319 = v310;
    HGExecutionUnit::SetStackState(v108, v318);
    return;
  }
  if (v100 < 2)
  {
LABEL_70:
    unsigned int v93 = v86;
    Stacuint64_t k = HGExecutionUnit::GetStack((char ****)a1[1].i64[0], 0);
    if (Stack == (char *)a4) {
      HGExecutionUnit::SwapStack(a1[1].i64[0]);
    }
    uint64_t v95 = HGExecutionUnit::GetStack((char ****)a1[1].i64[0], v92);
    (*(void (**)(_DWORD *, char *, uint64_t, uint64_t, void))(*(void *)v304 + 72))(v304, v95, v89, v302, 0);
    a1[8].i64[0] = (uint64_t)HgcSampler::Init(a1[7].i64[1], a3, a1[2].i32[1]);
    if (Stack == (char *)a4) {
      HGExecutionUnit::SwapStack(a1[1].i64[0]);
    }
    int v99 = a1[2].i32[1];
    if (v99 <= 1)
    {
      long long v308 = v303;
      *(void *)&long long v309 = a4;
      DWORD2(v309) = a7 - v303 + DWORD2(v303);
      int v312 = v302 - v89;
      __n128 v311 = &v95[-16 * ((int)v89 - (int)v303) + -16 * (HIDWORD(v89) - (int)v307) * ((int)v302 - (int)v89)];
      uint64_t v313 = v89;
      uint64_t v314 = v302;
      uint64_t v315 = a1[1].i64[0];
      ((void (*)(long long *, uint64_t, void))a1[8].i64[0])(&v308, a1[7].i64[1], 0);
      return;
    }
    int v109 = DWORD2(v303) - v303;
    int v110 = DWORD2(v303) - v303 - 1;
    if (DWORD2(v303) - (int)v303 <= 1) {
      int v110 = 1;
    }
    int v111 = v298 - 1;
    if (v298 < 2) {
      int v111 = 1;
    }
    if (v99 == 2 && (int)v14 > (int)v307)
    {
      uint64_t v112 = (float32x4_t *)a4;
      v98.i32[0] = 0;
      v97.i64[0] = __PAIR64__(v93, v291);
      float32x4_t v113 = v297;
      v113.i32[3] = 1.0;
      float32x4_t v115 = v294;
      float32x4_t v114 = v295;
      v114.i32[3] = 1.0;
      v115.i32[3] = 1.0;
      float32x4_t v116 = vcvtq_f32_s32(v97);
      *(float *)v96.i32 = (float)v110;
      float32x4_t v117 = (float32x4_t)vdupq_lane_s32(v96, 0);
      *(float *)v96.i32 = (float)v111;
      float32x4_t v118 = (float32x4_t)vdupq_lane_s32(v96, 0);
      float v119 = (float)(unint64_t)(int)v292;
      *(float *)v97.i32 = (float)(v292 - (unint64_t)v293);
      float32x4_t v120 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v97.i8, 0);
      v121.i64[0] = 0x80000000800000;
      v121.i64[1] = 0x80000000800000;
      float32x4_t v122 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
      float32x4_t v123 = vminq_f32(vmaxq_f32(v117, v121), v122);
      float32x4_t v124 = vminq_f32(vmaxq_f32(vrecpeq_f32(v123), v121), v122);
      float32x4_t v125 = vminq_f32(vmaxq_f32(vmulq_f32(v124, vrecpsq_f32(v123, v124)), v121), v122);
      float32x4_t v126 = vmulq_f32(v125, vrecpsq_f32(v123, v125));
      float32x4_t v127 = vminq_f32(vmaxq_f32(v118, v121), v122);
      float32x4_t v128 = vminq_f32(vmaxq_f32(vrecpeq_f32(v127), v121), v122);
      float32x4_t v129 = vmulq_f32(v128, vrecpsq_f32(v127, v128));
      v128.f32[0] = (float)(v91 - (unint64_t)v293);
      float32x4_t v130 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v128.f32, 0);
      int8x16_t v131 = (int8x16_t)vminq_f32(vmaxq_f32(v129, v121), v122);
      float32x4_t v132 = vmulq_f32((float32x4_t)v131, vrecpsq_f32(v127, (float32x4_t)v131));
      *(float32x2_t *)v131.i8 = vmul_f32(vsub_f32(v296, *(float32x2_t *)v297.f32), *(float32x2_t *)v126.f32);
      v131.u64[1] = (unint64_t)vmul_f32(vsub_f32(*(float32x2_t *)v294.f32, *(float32x2_t *)v297.f32), *(float32x2_t *)v132.f32);
      float32x4_t v133 = vsubq_f32(vmulq_f32(v126, vsubq_f32(v114, v115)), (float32x4_t)v131);
      int8x16_t v134 = (int8x16_t)vmulq_f32(v132, v133);
      v133.i32[0] = a1[7].i32[0] & 1;
      int8x16_t v135 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v133, v98), 0);
      float32x4_t v136 = (float32x4_t)vandq_s8(v134, v135);
      float32x4_t v137 = (float32x4_t)vandq_s8(v131, v135);
      v131.i64[0] = 0x3F0000003F000000;
      v131.i64[1] = 0x3F0000003F000000;
      float32x4_t v138 = (float32x4_t)vbslq_s8(v135, (int8x16_t)vdupq_lane_s64(vsubq_f32(vsubq_f32(v113, v305), v116).i64[0], 0), (int8x16_t)vdupq_lane_s64(vmulq_f32(vsubq_f32(vcvtq_f32_s32(v300), v116), (float32x4_t)v131).i64[0], 0));
      uint64_t v139 = 16 * (int)v292;
      uint64_t v140 = 32 * (int)v292;
      uint64_t v141 = 48 * (int)v292;
      __asm
      {
        FMOV            V7.4S, #1.0
        FMOV            V17.4S, #4.0
      }
      float32x4_t v144 = 0uLL;
      do
      {
        float32x2_t v177 = (float32x2_t)vaddq_f32(v137, vmulq_f32(v136, v144)).u64[0];
        int32x4_t v178 = (int32x4_t)vaddq_f32(v138, vmulq_f32(v137, v144));
        float32x4_t v179 = (float32x4_t)vdupq_laneq_s32(v178, 2);
        float32x4_t v180 = (float32x4_t)vdupq_laneq_s32(v178, 3);
        if (v109 < 4)
        {
          signed int v182 = DWORD2(v303) - v303;
          float32x4_t v181 = (float32x4_t)xmmword_1B7E740F0;
          int v258 = v14;
          if (!v109) {
            goto LABEL_88;
          }
        }
        else
        {
          float32x4_t v181 = (float32x4_t)xmmword_1B7E740F0;
          signed int v182 = DWORD2(v303) - v303;
          do
          {
            float32x4_t v183 = vmaxq_f32(vminq_f32(vaddq_f32(v179, vmulq_n_f32(v181, v177.f32[0])), v120), (float32x4_t)0);
            float32x4_t v184 = vmaxq_f32(vminq_f32(vaddq_f32(v180, vmulq_lane_f32(v181, v177, 1)), v130), (float32x4_t)0);
            float32x4_t v185 = vcvtq_f32_s32(vcvtq_s32_f32(v183));
            float32x4_t v186 = vcvtq_f32_s32(vcvtq_s32_f32(v184));
            int32x4_t v187 = vcvtq_s32_f32(vaddq_f32(vmulq_n_f32(v186, v119), v185));
            float32x4_t v188 = vsubq_f32(v183, v185);
            float32x4_t v189 = vsubq_f32(v184, v186);
            int32x4_t v190 = vshlq_n_s32(v187, 4uLL);
            float32x4_t v191 = a1[5];
            float32x4_t v192 = a1[6];
            float32x4_t v193 = vaddq_f32(v191, vmulq_n_f32(v192, v188.f32[0]));
            float32x4_t v194 = vaddq_f32(v191, vmulq_n_f32(v192, v189.f32[0]));
            float32x4_t v195 = vmulq_n_f32(v193, v188.f32[0]);
            float32x4_t v197 = a1[3];
            float32x4_t v196 = a1[4];
            float32x4_t v198 = vaddq_f32(v197, vmulq_n_f32(vaddq_f32(v196, v195), v188.f32[0]));
            float32x4_t v199 = vaddq_f32(v197, vmulq_n_f32(vaddq_f32(v196, vmulq_n_f32(v194, v189.f32[0])), v189.f32[0]));
            unint64_t v200 = (float32x4_t *)&v95[v190.i32[0]];
            float32x4_t v201 = vmulq_n_f32(v198, v199.f32[0]);
            float32x4_t v202 = vaddq_f32(vmulq_laneq_f32(v200[2], v201, 2), vaddq_f32(vmulq_lane_f32(v200[1], *(float32x2_t *)v201.f32, 1), vmulq_n_f32(*v200, v201.f32[0])));
            float32x4_t v203 = vmulq_laneq_f32(v200[3], v201, 3);
            uint64_t v204 = (float32x4_t *)&v95[v139 + v190.i32[0]];
            float32x4_t v205 = vaddq_f32(v203, v202);
            float32x4_t v206 = vmulq_lane_f32(v198, *(float32x2_t *)v199.f32, 1);
            float32x4_t v207 = vmulq_laneq_f32(v198, v199, 2);
            uint64_t v208 = (float32x4_t *)&v95[v141 + v190.i32[0]];
            float32x4_t v209 = vmulq_laneq_f32(v198, v199, 3);
            *uint64_t v112 = vaddq_f32(vmulq_laneq_f32(v208[3], v209, 3), vaddq_f32(vmulq_laneq_f32(v208[2], v209, 2), vaddq_f32(vmulq_lane_f32(v208[1], *(float32x2_t *)v209.f32, 1), vaddq_f32(vmulq_n_f32(*v208, v209.f32[0]), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v140 + 48 + v190.i32[0]], v207, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v140 + 32 + v190.i32[0]], v207, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)&v95[v140 + 16 + v190.i32[0]], *(float32x2_t *)v207.f32, 1), vaddq_f32(vmulq_n_f32(*(float32x4_t *)&v95[v140 + v190.i32[0]], v207.f32[0]), vaddq_f32(
                                      vmulq_laneq_f32(v204[3], v206, 3),
                                      vaddq_f32(vmulq_laneq_f32(v204[2], v206, 2), vaddq_f32(vmulq_lane_f32(v204[1], *(float32x2_t *)v206.f32, 1), vaddq_f32(vmulq_n_f32(*v204, v206.f32[0]), v205))))))))))));
            float32x4_t v210 = a1[5];
            float32x4_t v211 = a1[6];
            float32x4_t v212 = vaddq_f32(v210, vmulq_lane_f32(v211, *(float32x2_t *)v188.f32, 1));
            float32x4_t v213 = vaddq_f32(v210, vmulq_lane_f32(v211, *(float32x2_t *)v189.f32, 1));
            float32x4_t v215 = a1[3];
            float32x4_t v214 = a1[4];
            float32x4_t v216 = vaddq_f32(v214, vmulq_lane_f32(v213, *(float32x2_t *)v189.f32, 1));
            float32x4_t v217 = vaddq_f32(v215, vmulq_lane_f32(vaddq_f32(v214, vmulq_lane_f32(v212, *(float32x2_t *)v188.f32, 1)), *(float32x2_t *)v188.f32, 1));
            float32x4_t v218 = vaddq_f32(v215, vmulq_lane_f32(v216, *(float32x2_t *)v189.f32, 1));
            float32x4_t v219 = vmulq_n_f32(v217, v218.f32[0]);
            long long v220 = (float32x4_t *)&v95[v139 + v190.i32[1]];
            float32x4_t v221 = vmulq_lane_f32(v217, *(float32x2_t *)v218.f32, 1);
            float32x4_t v222 = vmulq_laneq_f32(v217, v218, 2);
            unint64_t v223 = (float32x4_t *)&v95[v141 + v190.i32[1]];
            float32x4_t v224 = vmulq_laneq_f32(v217, v218, 3);
            v112[1] = vaddq_f32(vmulq_laneq_f32(v223[3], v224, 3), vaddq_f32(vmulq_laneq_f32(v223[2], v224, 2), vaddq_f32(vmulq_lane_f32(v223[1], *(float32x2_t *)v224.f32, 1), vaddq_f32(vmulq_n_f32(*v223, v224.f32[0]), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v140 + 48 + v190.i32[1]], v222, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v140 + 32 + v190.i32[1]], v222, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)&v95[v140 + 16 + v190.i32[1]], *(float32x2_t *)v222.f32, 1), vaddq_f32(vmulq_n_f32(*(float32x4_t *)&v95[v140 + v190.i32[1]], v222.f32[0]), vaddq_f32(
                                        vmulq_laneq_f32(v220[3], v221, 3),
                                        vaddq_f32(vmulq_laneq_f32(v220[2], v221, 2), vaddq_f32(vmulq_lane_f32(v220[1], *(float32x2_t *)v221.f32, 1), vaddq_f32(vmulq_n_f32(*v220, v221.f32[0]), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v190.i32[1] + 48], v219, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v190.i32[1] + 32], v219, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)&v95[v190.i32[1] + 16], *(float32x2_t *)v219.f32, 1), vmulq_n_f32(*(float32x4_t *)&v95[v190.i32[1]], v219.f32[0]))))))))))))))));
            float32x4_t v225 = a1[5];
            float32x4_t v226 = a1[6];
            float32x4_t v227 = vaddq_f32(v225, vmulq_laneq_f32(v226, v188, 2));
            float32x4_t v228 = vaddq_f32(v225, vmulq_laneq_f32(v226, v189, 2));
            float32x4_t v230 = a1[3];
            float32x4_t v229 = a1[4];
            float32x4_t v231 = vaddq_f32(v229, vmulq_laneq_f32(v228, v189, 2));
            float32x4_t v232 = vaddq_f32(v230, vmulq_laneq_f32(vaddq_f32(v229, vmulq_laneq_f32(v227, v188, 2)), v188, 2));
            float32x4_t v233 = vaddq_f32(v230, vmulq_laneq_f32(v231, v189, 2));
            uint64_t v234 = (float32x4_t *)&v95[v190.i32[2]];
            float32x4_t v235 = vmulq_n_f32(v232, v233.f32[0]);
            float32x4_t v236 = vmulq_lane_f32(v232, *(float32x2_t *)v233.f32, 1);
            float32x4_t v237 = vmulq_laneq_f32(v232, v233, 2);
            __n128 v238 = (float32x4_t *)&v95[v141 + v190.i32[2]];
            float32x4_t v239 = vmulq_laneq_f32(v232, v233, 3);
            v112[2] = vaddq_f32(vmulq_laneq_f32(v238[3], v239, 3), vaddq_f32(vmulq_laneq_f32(v238[2], v239, 2), vaddq_f32(vmulq_lane_f32(v238[1], *(float32x2_t *)v239.f32, 1), vaddq_f32(vmulq_n_f32(*v238, v239.f32[0]), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v140 + 48 + v190.i32[2]], v237, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v140 + 32 + v190.i32[2]], v237, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)&v95[v140 + 16 + v190.i32[2]], *(float32x2_t *)v237.f32, 1), vaddq_f32(vmulq_n_f32(*(float32x4_t *)&v95[v140 + v190.i32[2]], v237.f32[0]), vaddq_f32(
                                        vmulq_laneq_f32(*(float32x4_t *)&v95[v139 + 48 + v190.i32[2]], v236, 3),
                                        vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v139 + 32 + v190.i32[2]], v236, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)&v95[v139 + 16 + v190.i32[2]], *(float32x2_t *)v236.f32, 1), vaddq_f32(vmulq_n_f32(*(float32x4_t *)&v95[v139 + v190.i32[2]], v236.f32[0]), vaddq_f32(vmulq_laneq_f32(v234[3], v235, 3), vaddq_f32(vmulq_laneq_f32(v234[2], v235, 2), vaddq_f32(vmulq_lane_f32(v234[1], *(float32x2_t *)v235.f32, 1), vmulq_n_f32(*v234, v235.f32[0]))))))))))))))));
            float32x4_t v240 = a1[5];
            float32x4_t v241 = a1[6];
            float32x4_t v242 = vaddq_f32(v240, vmulq_laneq_f32(v241, v188, 3));
            float32x4_t v243 = vaddq_f32(v240, vmulq_laneq_f32(v241, v189, 3));
            float32x4_t v244 = vmulq_laneq_f32(v242, v188, 3);
            float32x4_t v246 = a1[3];
            float32x4_t v245 = a1[4];
            float32x4_t v247 = vaddq_f32(v246, vmulq_laneq_f32(vaddq_f32(v245, v244), v188, 3));
            float32x4_t v248 = vaddq_f32(v246, vmulq_laneq_f32(vaddq_f32(v245, vmulq_laneq_f32(v243, v189, 3)), v189, 3));
            uint64_t v249 = v190.i32[3];
            unsigned int v250 = v182;
            float32x4_t v251 = vmulq_n_f32(v247, v248.f32[0]);
            long long v252 = (float32x4_t *)&v95[v139 + v190.i32[3]];
            float32x4_t v253 = vmulq_lane_f32(v247, *(float32x2_t *)v248.f32, 1);
            float32x4_t v254 = vaddq_f32(vmulq_laneq_f32(v252[3], v253, 3), vaddq_f32(vmulq_laneq_f32(v252[2], v253, 2), vaddq_f32(vmulq_lane_f32(v252[1], *(float32x2_t *)v253.f32, 1), vaddq_f32(vmulq_n_f32(*v252, v253.f32[0]), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v190.i32[3] + 48], v251, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v190.i32[3] + 32], v251, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)&v95[v190.i32[3] + 16], *(float32x2_t *)v251.f32, 1), vmulq_n_f32(*(float32x4_t *)&v95[v190.i32[3]], v251.f32[0]))))))));
            long long v255 = (float32x4_t *)&v95[v140 + v249];
            float32x4_t v256 = vmulq_laneq_f32(v247, v248, 2);
            float32x4_t v257 = vmulq_laneq_f32(v247, v248, 3);
            float32x4_t v181 = vaddq_f32(v181, _Q17);
            v112[3] = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v141 + 48 + v249], v257, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v141 + 32 + v249], v257, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)&v95[v141 + 16 + v249], *(float32x2_t *)v257.f32, 1), vaddq_f32(vmulq_n_f32(*(float32x4_t *)&v95[v141 + v249], v257.f32[0]), vaddq_f32(vmulq_laneq_f32(v255[3], v256, 3), vaddq_f32(vmulq_laneq_f32(v255[2], v256, 2), vaddq_f32(vmulq_lane_f32(v255[1], *(float32x2_t *)v256.f32, 1), vaddq_f32(vmulq_n_f32(*v255, v256.f32[0]), v254))))))));
            v112 += 4;
            signed int v182 = v250 - 4;
          }
          while (v250 > 7);
          int v258 = v14;
          if (v250 == 4) {
            goto LABEL_88;
          }
        }
        float32x4_t v259 = vaddq_f32(v179, vmulq_n_f32(v181, v177.f32[0]));
        float32x4_t v260 = vaddq_f32(v180, vmulq_lane_f32(v181, v177, 1));
        float32x4_t v261 = vmaxq_f32(vminq_f32(v259, v120), (float32x4_t)0);
        float32x4_t v262 = vmaxq_f32(vminq_f32(v260, v130), (float32x4_t)0);
        float32x4_t v263 = vcvtq_f32_s32(vcvtq_s32_f32(v261));
        float32x4_t v264 = vcvtq_f32_s32(vcvtq_s32_f32(v262));
        int32x4_t v265 = vshlq_n_s32(vcvtq_s32_f32(vaddq_f32(vmulq_n_f32(v264, v119), v263)), 4uLL);
        float32x4_t v266 = vsubq_f32(v261, v263);
        float32x4_t v267 = vsubq_f32(v262, v264);
        if (v182 != 2)
        {
          if (v182 != 3) {
            goto LABEL_87;
          }
          float32x4_t v268 = a1[5];
          float32x4_t v269 = a1[6];
          float32x4_t v270 = vaddq_f32(v268, vmulq_laneq_f32(v269, v266, 2));
          float32x4_t v271 = vaddq_f32(v268, vmulq_laneq_f32(v269, v267, 2));
          float32x4_t v272 = vmulq_laneq_f32(v270, v266, 2);
          float32x4_t v274 = a1[3];
          float32x4_t v273 = a1[4];
          float32x4_t v275 = vaddq_f32(v274, vmulq_laneq_f32(vaddq_f32(v273, v272), v266, 2));
          float32x4_t v276 = vaddq_f32(v274, vmulq_laneq_f32(vaddq_f32(v273, vmulq_laneq_f32(v271, v267, 2)), v267, 2));
          float32x4_t v277 = vmulq_n_f32(v275, v276.f32[0]);
          uint64_t v278 = (float32x4_t *)&v95[v139 + v265.i32[2]];
          float32x4_t v279 = vmulq_lane_f32(v275, *(float32x2_t *)v276.f32, 1);
          float32x4_t v280 = vaddq_f32(vmulq_laneq_f32(v278[3], v279, 3), vaddq_f32(vmulq_laneq_f32(v278[2], v279, 2), vaddq_f32(vmulq_lane_f32(v278[1], *(float32x2_t *)v279.f32, 1), vaddq_f32(vmulq_n_f32(*v278, v279.f32[0]), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v265.i32[2] + 48], v277, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v265.i32[2] + 32], v277, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)&v95[v265.i32[2] + 16], *(float32x2_t *)v277.f32, 1), vmulq_n_f32(*(float32x4_t *)&v95[v265.i32[2]], v277.f32[0]))))))));
          float32x4_t v281 = vmulq_laneq_f32(v275, v276, 2);
          int v282 = (float32x4_t *)&v95[v141 + v265.i32[2]];
          float32x4_t v283 = vmulq_laneq_f32(v275, v276, 3);
          v112[2] = vaddq_f32(vmulq_laneq_f32(v282[3], v283, 3), vaddq_f32(vmulq_laneq_f32(v282[2], v283, 2), vaddq_f32(vmulq_lane_f32(v282[1], *(float32x2_t *)v283.f32, 1), vaddq_f32(vmulq_n_f32(*v282, v283.f32[0]), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v140 + 48 + v265.i32[2]], v281, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v140 + 32 + v265.i32[2]], v281, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)&v95[v140 + 16 + v265.i32[2]], *(float32x2_t *)v281.f32, 1), vaddq_f32(vmulq_n_f32(*(float32x4_t *)&v95[v140 + v265.i32[2]], v281.f32[0]), v280))))))));
        }
        float32x4_t v145 = a1[5];
        float32x4_t v146 = a1[6];
        float32x4_t v147 = vaddq_f32(v145, vmulq_lane_f32(v146, *(float32x2_t *)v266.f32, 1));
        float32x4_t v148 = vaddq_f32(v145, vmulq_lane_f32(v146, *(float32x2_t *)v267.f32, 1));
        float32x4_t v149 = vmulq_lane_f32(v147, *(float32x2_t *)v266.f32, 1);
        float32x4_t v151 = a1[3];
        float32x4_t v150 = a1[4];
        float32x4_t v152 = vaddq_f32(v151, vmulq_lane_f32(vaddq_f32(v150, v149), *(float32x2_t *)v266.f32, 1));
        float32x4_t v153 = vaddq_f32(v151, vmulq_lane_f32(vaddq_f32(v150, vmulq_lane_f32(v148, *(float32x2_t *)v267.f32, 1)), *(float32x2_t *)v267.f32, 1));
        float32x4_t v154 = vmulq_n_f32(v152, v153.f32[0]);
        unsigned __int8 v155 = (float32x4_t *)&v95[v139 + v265.i32[1]];
        float32x4_t v156 = vmulq_lane_f32(v152, *(float32x2_t *)v153.f32, 1);
        float32x4_t v157 = vaddq_f32(vmulq_laneq_f32(v155[3], v156, 3), vaddq_f32(vmulq_laneq_f32(v155[2], v156, 2), vaddq_f32(vmulq_lane_f32(v155[1], *(float32x2_t *)v156.f32, 1), vaddq_f32(vmulq_n_f32(*v155, v156.f32[0]), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v265.i32[1] + 48], v154, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v265.i32[1] + 32], v154, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)&v95[v265.i32[1] + 16], *(float32x2_t *)v154.f32, 1), vmulq_n_f32(*(float32x4_t *)&v95[v265.i32[1]], v154.f32[0]))))))));
        float32x4_t v158 = vmulq_laneq_f32(v152, v153, 2);
        unsigned __int8 v159 = (float32x4_t *)&v95[v141 + v265.i32[1]];
        float32x4_t v160 = vmulq_laneq_f32(v152, v153, 3);
        v112[1] = vaddq_f32(vmulq_laneq_f32(v159[3], v160, 3), vaddq_f32(vmulq_laneq_f32(v159[2], v160, 2), vaddq_f32(vmulq_lane_f32(v159[1], *(float32x2_t *)v160.f32, 1), vaddq_f32(vmulq_n_f32(*v159, v160.f32[0]), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v140 + 48 + v265.i32[1]], v158, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v140 + 32 + v265.i32[1]], v158, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)&v95[v140 + 16 + v265.i32[1]], *(float32x2_t *)v158.f32, 1), vaddq_f32(vmulq_n_f32(*(float32x4_t *)&v95[v140 + v265.i32[1]], v158.f32[0]), v157))))))));
LABEL_87:
        float32x4_t v161 = a1[5];
        float32x4_t v162 = a1[6];
        float32x4_t v163 = vaddq_f32(v161, vmulq_n_f32(v162, v266.f32[0]));
        float32x4_t v164 = vaddq_f32(v161, vmulq_n_f32(v162, v267.f32[0]));
        float32x4_t v165 = vmulq_n_f32(v163, v266.f32[0]);
        float32x4_t v167 = a1[3];
        float32x4_t v166 = a1[4];
        float32x4_t v168 = vaddq_f32(v167, vmulq_n_f32(vaddq_f32(v166, v165), v266.f32[0]));
        float32x4_t v169 = vaddq_f32(v167, vmulq_n_f32(vaddq_f32(v166, vmulq_n_f32(v164, v267.f32[0])), v267.f32[0]));
        uint64_t v170 = v265.i32[0];
        float32x4_t v171 = vmulq_n_f32(v168, v169.f32[0]);
        unint64_t v172 = (float32x4_t *)&v95[v139 + v265.i32[0]];
        float32x4_t v173 = vmulq_lane_f32(v168, *(float32x2_t *)v169.f32, 1);
        float32x4_t v174 = vaddq_f32(vmulq_laneq_f32(v172[3], v173, 3), vaddq_f32(vmulq_laneq_f32(v172[2], v173, 2), vaddq_f32(vmulq_lane_f32(v172[1], *(float32x2_t *)v173.f32, 1), vaddq_f32(vmulq_n_f32(*v172, v173.f32[0]), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v265.i32[0] + 48], v171, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v265.i32[0] + 32], v171, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)&v95[v265.i32[0] + 16], *(float32x2_t *)v171.f32, 1), vmulq_n_f32(*(float32x4_t *)&v95[v265.i32[0]], v171.f32[0]))))))));
        float32x4_t v175 = vmulq_laneq_f32(v168, v169, 2);
        float32x4_t v176 = vmulq_laneq_f32(v168, v169, 3);
        *uint64_t v112 = vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v141 + 48 + v170], v176, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v141 + 32 + v170], v176, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)&v95[v141 + 16 + v170], *(float32x2_t *)v176.f32, 1), vaddq_f32(vmulq_n_f32(*(float32x4_t *)&v95[v141 + v170], v176.f32[0]), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v140 + 48 + v170], v175, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)&v95[v140 + 32 + v170], v175, 2), vaddq_f32(vmulq_lane_f32(*(float32x4_t *)&v95[v140 + 16 + v170], *(float32x2_t *)v175.f32, 1), vaddq_f32(vmulq_n_f32(*(float32x4_t *)&v95[v140 + v170], v175.f32[0]), v174))))))));
        v112 += v182;
LABEL_88:
        float32x4_t v144 = vaddq_f32(v144, _Q7);
        v112 += (int)a7;
        LODWORD(v307) = v307 + 1;
      }
      while (v307 != v258);
    }
  }
  else
  {
    signed int v284 = (DWORD2(v303) + (int)v303) >> 1;
    uint64_t v310 = 0;
    long long v308 = 0u;
    long long v309 = 0u;
    HGExecutionUnit::GetStackState(a1[1].i64[0], (uint64_t)&v308);
    uint64_t v285 = HGRectMake4i(v303, v307, v284, v14);
    HGSampler::GetTile(a1, v304, a3, a4, v285, v286, (DWORD2(v303) + a7 - v284));
    HGExecutionUnit::CommitStack(a1[1].i64[0], (uint64_t)a4, (v100 + (int)a7) * v298);
    uint64_t v287 = HGRectMake4i(v284, v307, DWORD2(v303), v14);
    HGSampler::GetTile(a1, v304, a3, &a4[v284 - (int)v303], v287, v288, (a7 - v303 + v284));
    uint64_t v289 = a1[1].i64[0];
    v316[0] = v308;
    v316[1] = v309;
    uint64_t v317 = v310;
    HGExecutionUnit::SetStackState(v289, v316);
  }
}

uint64_t HGSampler::ReadTile(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 40))();
}

uint64_t HGSampler::ReadTileIndirect(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, unint64_t a5, unint64_t a6)
{
  unint64_t v6 = a4;
  unint64_t v8 = HIDWORD(a5);
  unint64_t v9 = HIDWORD(a6);
  int32x4_t v10 = (int32x4_t)a5;
  v10.i32[1] = HIDWORD(a5);
  float32x4_t v11 = vcvtq_f32_s32(vcvtq_s32_f32(*a4));
  int32x2_t v12 = (int32x2_t)vaddq_s32(vcvtq_s32_f32(vaddq_f32(v11, vcvtq_f32_s32(vcgtq_f32(v11, *a4)))), v10).u64[0];
  int32x4_t v13 = vdupq_lane_s32(v12, 0);
  int32x4_t v14 = vdupq_lane_s32(v12, 1);
  if (SHIDWORD(a5) >= SHIDWORD(a6) || a6 == a5)
  {
    v17.i32[0] = v14.i32[0];
    v16.i32[0] = v13.i32[0];
  }
  else
  {
    float32x4_t v15 = a4;
    int32x4_t v16 = v13;
    int32x4_t v17 = v14;
    unint64_t v18 = HIDWORD(a5);
    do
    {
      int32x4_t v19 = (int32x4_t)a5;
      v19.i32[1] = v18;
      int v20 = a5 - a6;
      do
      {
        float32x4_t v21 = vcvtq_f32_s32(vcvtq_s32_f32(*v15));
        int32x4_t v22 = vaddq_s32(vcvtq_s32_f32(vaddq_f32(v21, vcvtq_f32_s32(vcgtq_f32(v21, *v15)))), v19);
        int32x4_t v23 = vdupq_lane_s32(*(int32x2_t *)v22.i8, 0);
        int32x4_t v13 = vminq_s32(v13, v23);
        int32x4_t v16 = vmaxq_s32(v16, v23);
        int32x4_t v24 = vdupq_lane_s32(*(int32x2_t *)v22.i8, 1);
        int32x4_t v14 = vminq_s32(v14, v24);
        int32x4_t v17 = vmaxq_s32(v17, v24);
        int32x4_t v19 = vaddq_s32(v19, (int32x4_t)xmmword_1B7E7A9D0);
        *v15++ = (float32x4_t)v22;
      }
      while (!__CFADD__(v20++, 1));
      LODWORD(v18) = v18 + 1;
    }
    while (v18 != HIDWORD(a6));
  }
  int v40 = a5;
  int v41 = a6;
  __int32 v26 = v13.i32[0];
  __int32 v27 = v14.i32[0];
  uint64_t v28 = (v16.i32[0] + 1);
  uint64_t v29 = (v17.i32[0] + 1);
  unint64_t v30 = v13.u32[0] | ((unint64_t)v14.u32[0] << 32);
  uint64_t v31 = v28 | (v29 << 32);
  int v32 = v28 - v13.i32[0];
  int v33 = (v28 - v13.i32[0]) * (v29 - v14.i32[0]);
  unint64_t v34 = *(void *)(a1 + 24);
  if (v33 > *(_DWORD *)(a1 + 32))
  {
    uint64_t v38 = a2;
    uint64_t v39 = a3;
    if (v34) {
      HGFree(v34);
    }
    unint64_t v34 = HGMalloc(16 * v33);
    *(void *)(a1 + 24) = v34;
    *(_DWORD *)(a1 + 32) = v33;
    a2 = v38;
    a3 = v39;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t, unint64_t, uint64_t, void))(*(void *)a1 + 40))(a1, a2, a3, v34, v30, v31, 0);
  if (v41 > v40 && (int)v8 < (int)v9)
  {
    uint64_t v36 = *(void *)(a1 + 24);
    do
    {
      int v37 = v41 - v40;
      do
      {
        *unint64_t v6 = *(float32x4_t *)(v36 + 16 * (v6->i32[0] - v26 + (v6->i32[1] - v27) * v32));
        ++v6;
        --v37;
      }
      while (v37);
      LODWORD(v8) = v8 + 1;
    }
    while (v8 != v9);
  }
  return result;
}

HGNode *HGRenderCinema::HGRenderCinema(HGNode *a1, int a2)
{
  HGNode::HGNode(a1);
  *(void *)uint64_t v6 = &unk_1F10D6170;
  uint64_t v7 = (HGCinematic **)(v6 + 408);
  *(void *)(v6 + 408) = 0;
  *(void *)(v6 + 416) = 0;
  *(_DWORD *)(v6 + 424) = a2;
  *(unsigned char *)(v6 + 428) = 0;
  *(_DWORD *)(v6 + 432) = 100;
  switch(a2)
  {
    case 0:
      unint64_t v8 = (HGCinematic *)HGObject::operator new(0x1E0uLL);
      HGCinematic::HGCinematic(v8);
      unint64_t v9 = *v7;
      if (*v7 != v8)
      {
        if (!v9) {
          goto LABEL_20;
        }
        goto LABEL_19;
      }
      if (!v8) {
        return a1;
      }
      goto LABEL_13;
    case 1:
      int32x4_t v10 = (HgcCinematicDepthFX_Fog *)HGObject::operator new(0x1A0uLL);
      HgcCinematicDepthFX_Fog::HgcCinematicDepthFX_Fog(v10);
    case 2:
      float32x4_t v11 = (HgcCinematicDepthFX_ColorPop *)HGObject::operator new(0x1A0uLL);
      HgcCinematicDepthFX_ColorPop::HgcCinematicDepthFX_ColorPop(v11);
    case 3:
      int32x2_t v12 = (HgcCinematicDepthFX_FadeOut *)HGObject::operator new(0x1A0uLL);
      HgcCinematicDepthFX_FadeOut::HgcCinematicDepthFX_FadeOut(v12);
    case 4:
      int32x4_t v13 = (HGCinematic *)HGObject::operator new(0x1E0uLL);
      HGCinematic::HGCinematic(v13);
      HGCinematic::setRenderDisparity((uint64_t)v13);
      int32x4_t v14 = *v7;
      if (*v7 == v13)
      {
        if (v13) {
          (*(void (**)(HGCinematic *))(*(void *)v13 + 24))(v13);
        }
      }
      else
      {
        if (v14) {
          (*(void (**)(HGCinematic *))(*(void *)v14 + 24))(v14);
        }
        void *v7 = v13;
      }
      goto LABEL_17;
    default:
LABEL_17:
      HGLogger::error((HGLogger *)"HGRenderCinema : Render FX Type not specified in initialization of node.", v4, v5);
      unint64_t v8 = (HGCinematic *)HGObject::operator new(0x1E0uLL);
      HGCinematic::HGCinematic(v8);
      unint64_t v9 = *v7;
      if (*v7 == v8)
      {
        if (v8) {
LABEL_13:
        }
          (*(void (**)(HGCinematic *))(*(void *)v8 + 24))(v8);
        return a1;
      }
      else
      {
        if (v9) {
LABEL_19:
        }
          (*(void (**)(HGCinematic *))(*(void *)v9 + 24))(v9);
LABEL_20:
        void *v7 = v8;
        return a1;
      }
  }
}

void sub_1B77B146C(_Unwind_Exception *a1)
{
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v5 = *(void *)(v1 + 416);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  if (*v3) {
    (*(void (**)(void))(*(void *)*v3 + 24))(*v3);
  }
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

uint64_t HGRenderCinema::SetFXParameter(uint64_t result, const char *a2, char *a3, __n128 a4, __n128 a5, __n128 a6, __n128 a7)
{
  float v7 = a4.n128_f32[0];
  switch((int)a2)
  {
    case 0:
      unint64_t v8 = *(const void **)(result + 408);
      if (!v8
      {
        int32x4_t v13 = "HGRenderCinema : Aperture not set.";
        goto LABEL_23;
      }
      uint64_t result = HGCinematic::setAperture((uint64_t)v9, v7);
      break;
    case 1:
      int32x4_t v10 = *(const void **)(result + 408);
      if (v10
      {
        uint64_t result = HGCinematic::setFocusDistance((uint64_t)v11, v7);
      }
      else
      {
        int32x4_t v13 = "HGRenderCinema : Focus distance not set.";
LABEL_23:
        uint64_t result = (uint64_t)HGLogger::warning((HGLogger *)v13, a2, a3);
      }
      break;
    case 2:
      if ((*(_DWORD *)(result + 424) | 2) == 3) {
        goto LABEL_16;
      }
      break;
    case 3:
      if (*(_DWORD *)(result + 424) == 2)
      {
LABEL_16:
        int32x2_t v12 = *(uint64_t (**)(__n128, __n128, __n128, __n128))(**(void **)(result + 408) + 96);
        a5.n128_u64[0] = 0;
        a6.n128_u64[0] = 0;
        a7.n128_u64[0] = 0;
        uint64_t result = v12(a4, a5, a6, a7);
      }
      break;
    default:
      uint64_t result = (uint64_t)HGLogger::error((HGLogger *)"HGRenderCinema : Valid FX Parameter type not provided while setting parameter value.", a2, a3);
      break;
  }
  return result;
}

const char *HGRenderCinema::SetRenderQuality(HGRenderCinema *this, const char *a2, char *a3)
{
  uint64_t v3 = (const void *)*((void *)this + 51);
  if (v3 {
    && (int v4 = (int)a2,
  }
  {
    return (const char *)HGCinematic::SetRenderQuality((uint64_t)v5, v4);
  }
  else
  {
    return HGLogger::warning((HGLogger *)"HGRenderCinema : Render quality not set.", a2, a3);
  }
}

void HGRenderCinema::SetTransferFunction(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v3 = *(const void **)(a1 + 408);
  if (v3
  {
    uint64_t v6 = v5;
    if (*(char *)(a2 + 23) < 0) {
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
    }
    else {
      std::string __p = *(std::string *)a2;
    }
    std::string::operator=(v6 + 18, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    HGLogger::warning((HGLogger *)"HGRenderCinema : Transfer function not set.", (const char *)a2, a3);
  }
}

void sub_1B77B1A30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const char *HGRenderCinema::SetDisplayMode(HGRenderCinema *this, const char *a2, char *a3)
{
  uint64_t v3 = (const void *)*((void *)this + 51);
  if (v3 {
    && (int v4 = (int)a2,
  }
  {
    return (const char *)HGCinematic::setDisplayMode((uint64_t)v5, v4);
  }
  else
  {
    return HGLogger::warning((HGLogger *)"HGRenderCinema : Display mode not set.", a2, a3);
  }
}

uint64_t HGRenderCinema::GetOutput(HGNode *this, HGRenderer *a2)
{
  uint64_t v4 = *((void *)this + 51);
  Input = HGRenderer::GetInput(a2, this, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v4 + 120))(v4, 0, Input);
  if ((*((_DWORD *)this + 106) | 4) == 4)
  {
    uint64_t v6 = *((void *)this + 51);
    float v7 = HGRenderer::GetInput(a2, this, 1u);
    (*(void (**)(uint64_t, uint64_t, HGNode *))(*(void *)v6 + 120))(v6, 1, v7);
  }
  else
  {
    unint64_t v9 = (HGCinematic *)HGObject::operator new(0x1E0uLL);
    HGCinematic::HGCinematic(v9);
    int32x4_t v10 = HGRenderer::GetInput(a2, this, 0);
    (*(void (**)(HGCinematic *, void, HGNode *))(*(void *)v9 + 120))(v9, 0, v10);
    float32x4_t v11 = HGRenderer::GetInput(a2, this, 1u);
    (*(void (**)(HGCinematic *, uint64_t, HGNode *))(*(void *)v9 + 120))(v9, 1, v11);
    HGCinematic::setRenderDisparity((uint64_t)v9);
    (*(void (**)(void, uint64_t, HGCinematic *))(**((void **)this + 51) + 120))(*((void *)this + 51), 1, v9);
  }
  return *((void *)this + 51);
}

void sub_1B77B1C94(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGRenderCinema::SetSingleChannelDepthConversion(uint64_t this)
{
  *(unsigned char *)(this + 428) = 1;
  return this;
}

PTGlobalRenderingMetadata *HGRenderCinema::SetGlobalRenderingMetadata(HGRenderCinema *this, PTGlobalRenderingMetadata *a2, char *a3)
{
  uint64_t v3 = (const void *)*((void *)this + 51);
  if (v3
  {
    return HGCinematic::SetGlobalRenderingMetadata(v5, a2);
  }
  else
  {
    return (PTGlobalRenderingMetadata *)HGLogger::warning((HGLogger *)"HGRenderCinema : GlobalRenderingMetadata not set", (const char *)a2, a3);
  }
}

const char *HGRenderCinema::SetTimedRenderingMetadata(uint64_t a1, void *a2, char *a3)
{
  uint64_t v3 = *(const void **)(a1 + 408);
  if (v3
  {
    return (const char *)HGCinematic::SetTimedRenderingMetadata(v5, a2);
  }
  else
  {
    return HGLogger::warning((HGLogger *)"HGRenderCinema : TimedRenderingMetadata not set", (const char *)a2, a3);
  }
}

void HGRenderCinema::~HGRenderCinema(HGNode *this)
{
  *(void *)this = &unk_1F10D6170;
  uint64_t v2 = *((void *)this + 52);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 51);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1F10D6170;
  uint64_t v2 = *((void *)this + 52);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 51);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v4);
}

void HGMetalTexturePool::HGMetalTexturePool(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = operator new(0x28uLL);
  v3[1] = 0;
  v3[2] = 0;
  void *v3 = &unk_1F10D63D8;
  v3[3] = &unk_1F10D6428;
  v3[4] = a2;
  operator new();
}

void sub_1B77B219C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  MEMORY[0x1BA9BFBA0](v11, 0x10B3C40C3EE8A59);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void sub_1B77B21D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t HGMetalTexturePool::newTexture(uint64_t *a1, long long *a2, char a3)
{
  return HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::newObjectWithRecovery(*a1, a2, a3 ^ 1u);
}

uint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::newObjectWithRecovery(uint64_t a1, long long *a2, char a3)
{
  uint64_t result = HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::newObject(a1, a2, a3);
  if (!result)
  {
    while (1)
    {
      std::mutex::lock((std::mutex *)(a1 + 256));
      if (!*(void *)(a1 + 224)) {
        break;
      }
      HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::_pop_front((int64x2_t *)(a1 + 152));
      std::mutex::unlock((std::mutex *)(a1 + 256));
      uint64_t result = HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::newObject(a1, a2, a3);
      if (result) {
        return result;
      }
    }
    std::mutex::unlock((std::mutex *)(a1 + 256));
    unsigned __int8 v9 = atomic_load(HGLogger::_enabled);
    if (v9)
    {
      int32x4_t v10 = (HGLogger *)(a1 + 344);
      if (*(char *)(a1 + 367) < 0) {
        int32x4_t v10 = *(HGLogger **)v10;
      }
      HGLogger::log(v10, (const char *)1, (HGLogger *)"HGPool::newObjectWithRecovery() - Failed to recycle or allocate object! Oops.", v7, v8);
    }
    return 0;
  }
  return result;
}

void HGMetalTexturePool::releaseTexture(uint64_t *a1, uint64_t a2)
{
}

void HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::releaseObject(uint64_t a1, uint64_t a2)
{
  v34[0] = a2;
  float v25 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,true>::retrieveObject((int64x2_t *)(a1 + 48), v34, (uint64_t)&v28);
  if ((void)v28)
  {
    LOBYTE(v33) = 0;
    *(std::chrono::steady_clock::time_point *)&long long v32 = std::chrono::steady_clock::now();
    HGMetalUtils::bytesPerPixel(v30[0]);
    kdebug_trace();
    uint64_t v3 = *(void *)(a1 + 200);
    uint64_t v4 = *(void *)(a1 + 192);
    uint64_t v5 = 46 * ((v3 - v4) >> 3) - 1;
    if (v3 == v4) {
      uint64_t v5 = 0;
    }
    unint64_t v6 = *(void *)(a1 + 224) + *(void *)(a1 + 216);
    if (v5 == v6)
    {
      std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>>::__add_back_capacity(a1 + 184);
      uint64_t v4 = *(void *)(a1 + 192);
      unint64_t v6 = *(void *)(a1 + 224) + *(void *)(a1 + 216);
    }
    unint64_t v7 = *(void *)(v4 + 8 * (v6 / 0x2E)) + 88 * (v6 % 0x2E);
    long long v8 = v29;
    *(_OWORD *)unint64_t v7 = v28;
    *(_OWORD *)(v7 + 16) = v8;
    long long v9 = *(_OWORD *)v30;
    long long v10 = v31;
    long long v11 = v32;
    *(void *)(v7 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = v33;
    *(_OWORD *)(v7 + 48) = v10;
    *(_OWORD *)(v7 + 64) = v11;
    *(_OWORD *)(v7 + 32) = v9;
    ++*(void *)(a1 + 224);
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 232), 1uLL);
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 240), *((void *)&v29 + 1) * v29 * HGMetalUtils::bytesPerPixel(v30[0]));
    HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::service((int64x2_t *)(a1 + 152), a1);
  }
  else
  {
    HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::retrieveObject((int64x2_t *)(a1 + 152), v34, (uint64_t)v26);
    long long v31 = v26[3];
    long long v32 = v26[4];
    LOBYTE(v33) = v27;
    long long v28 = v26[0];
    long long v29 = v26[1];
    *(_OWORD *)unint64_t v30 = v26[2];
    uint64_t v14 = *(void *)&v26[0];
    if (*(void *)&v26[0])
    {
      uint64_t v15 = *(void *)(a1 + 200);
      uint64_t v16 = *(void *)(a1 + 192);
      uint64_t v17 = 46 * ((v15 - v16) >> 3) - 1;
      if (v15 == v16) {
        uint64_t v17 = 0;
      }
      unint64_t v18 = *(void *)(a1 + 224) + *(void *)(a1 + 216);
      if (v17 == v18)
      {
        std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>>::__add_back_capacity(a1 + 184);
        uint64_t v16 = *(void *)(a1 + 192);
        unint64_t v18 = *(void *)(a1 + 224) + *(void *)(a1 + 216);
      }
      unint64_t v19 = *(void *)(v16 + 8 * (v18 / 0x2E)) + 88 * (v18 % 0x2E);
      long long v20 = v29;
      *(_OWORD *)unint64_t v19 = v28;
      *(_OWORD *)(v19 + 16) = v20;
      long long v21 = *(_OWORD *)v30;
      long long v22 = v31;
      long long v23 = v32;
      *(void *)(v19 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = v33;
      *(_OWORD *)(v19 + 48) = v22;
      *(_OWORD *)(v19 + 64) = v23;
      *(_OWORD *)(v19 + 32) = v21;
      ++*(void *)(a1 + 224);
      atomic_fetch_add((atomic_ullong *volatile)(a1 + 232), 1uLL);
      atomic_fetch_add((atomic_ullong *volatile)(a1 + 240), *((void *)&v29 + 1) * v29 * HGMetalUtils::bytesPerPixel(v30[0]));
      int32x4_t v24 = "HGPool::releaseObject() - Attempting to double-release a free object: <%p>";
      uint64_t v14 = v28;
    }
    else
    {
      int32x4_t v24 = "HGPool::releaseObject() - Attempting to release an unmanaged object: <%p>";
    }
    HGLogger::warning((HGLogger *)v24, v12, v13, v14);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  kdebug_trace();
  std::mutex::unlock(v25);
}

void sub_1B77B267C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11)
{
}

void sub_1B77B2690(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11)
{
}

void HGMetalTexturePool::clear(HGMetalTexturePool *this)
{
}

void HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::clear(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  if (*(void *)(a1 + 224))
  {
    uint64_t v3 = 0;
    do
    {
      HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::_pop_front((int64x2_t *)(a1 + 152));
      --v3;
    }
    while (*(void *)(a1 + 224));
    if (v3)
    {
      (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
      (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
      kdebug_trace();
    }
  }

  std::mutex::unlock(v2);
}

void sub_1B77B27C4(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B77B27D8(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGMetalTextureWrapperInfinipool::HGMetalTextureWrapperInfinipool(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = operator new(0x28uLL);
  v3[1] = 0;
  v3[2] = 0;
  void *v3 = &unk_1F10D6698;
  v3[3] = &unk_1F10D66E8;
  v3[4] = a2;
  operator new();
}

void sub_1B77B2BAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B77B2BC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1B77B2BEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B77B2C00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B77B2C14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  MEMORY[0x1BA9BFBA0](v3, 0x10B3C40C3EE8A59);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1B77B2C48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::newObject(uint64_t a1, uint64_t a2, char a3)
{
  if ((a3 & 1) != 0 || (uint64_t v4 = *(void *)(a1 + 32)) == 0)
  {
    long long v5 = *(_OWORD *)(a2 + 32);
    long long v6 = *(_OWORD *)(a2 + 48);
    long long v7 = *(_OWORD *)a2;
    long long v37 = *(_OWORD *)(a2 + 16);
    long long v38 = v5;
    long long v39 = v6;
    unint64_t v40 = *(void *)(a2 + 64);
    long long v36 = v7;
  }
  else
  {
    (*(void (**)(long long *__return_ptr))(*(void *)v4 + 16))(&v36);
  }
  std::mutex::lock((std::mutex *)(a1 + 256));
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::retrieveObject((int64x2_t *)(a1 + 152), &v36, (uint64_t)&v29);
  std::mutex::unlock((std::mutex *)(a1 + 256));
  if ((void)v29)
  {
    BYTE8(v35) = 1;
    *((std::chrono::steady_clock::time_point *)&v34 + 1) = std::chrono::steady_clock::now();
    *(void *)&long long v35 = v35 + 1;
    HGPool::EntryEventHandler<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::reused(&v29);
    kdebug_trace();
    int v10 = *(_DWORD *)(a1 + 368);
    if (v10 == 1)
    {
      kdebug_trace();
      uint64_t v14 = v29;
      uint64_t v15 = (*(uint64_t (**)(void, long long *))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), &v36);
      HGPool::EntryEventHandler<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::deleted(&v29);
      *(void *)&long long v29 = v15;
      long long v32 = v38;
      long long v33 = v39;
      *(void *)&long long v34 = v40;
      long long v30 = v36;
      long long v31 = v37;
      HGPool::EntryEventHandler<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::allocated(&v29);
      kdebug_trace();
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 16) + 24))(*(void *)(a1 + 16), v14);
      kdebug_trace();
    }
    else if (v10 == 2)
    {
      kdebug_trace();
      long long v11 = v29;
      uint64_t v12 = (*(uint64_t (**)(void, long long *))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), &v36);
      HGPool::EntryEventHandler<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::deleted(&v29);
      *(void *)&long long v29 = v12;
      *((void *)&v29 + 1) = v11;
      long long v32 = v38;
      long long v33 = v39;
      *(void *)&long long v34 = v40;
      long long v30 = v36;
      long long v31 = v37;
      HGPool::EntryEventHandler<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::allocated(&v29);
      kdebug_trace();
      (*(void (**)(void, void))(**(void **)(a1 + 16) + 24))(*(void *)(a1 + 16), *((void *)&v11 + 1));
      kdebug_trace();
    }
  }
  else
  {
    kdebug_trace();
    uint64_t v13 = (*(uint64_t (**)(void, long long *))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), &v36);
    long long v32 = v38;
    long long v33 = v39;
    long long v30 = v36;
    long long v31 = v37;
    *(void *)&long long v35 = 0;
    long long v34 = v40;
    long long v29 = (unint64_t)v13;
    BYTE8(v35) = 1;
    *((std::chrono::steady_clock::time_point *)&v34 + 1) = std::chrono::steady_clock::now();
    *(void *)&long long v35 = v35 + 1;
    HGPool::EntryEventHandler<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::allocated(&v29);
    kdebug_trace();
    kdebug_trace();
  }
  if ((void)v29)
  {
    std::mutex::lock((std::mutex *)(a1 + 256));
    uint64_t v16 = *(void *)(a1 + 96);
    uint64_t v17 = *(void *)(a1 + 88);
    uint64_t v18 = 36 * ((v16 - v17) >> 3) - 1;
    if (v16 == v17) {
      uint64_t v18 = 0;
    }
    unint64_t v19 = *(void *)(a1 + 120) + *(void *)(a1 + 112);
    if (v18 == v19)
    {
      std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>>::__add_back_capacity(a1 + 80);
      uint64_t v17 = *(void *)(a1 + 88);
      unint64_t v19 = *(void *)(a1 + 120) + *(void *)(a1 + 112);
    }
    long long v20 = (_OWORD *)(*(void *)(v17 + 8 * (v19 / 0x24)) + 112 * (v19 % 0x24));
    long long v21 = v29;
    long long v22 = v31;
    v20[1] = v30;
    v20[2] = v22;
    *long long v20 = v21;
    long long v23 = v32;
    long long v24 = v33;
    long long v25 = v35;
    v20[5] = v34;
    v20[6] = v25;
    void v20[3] = v23;
    v20[4] = v24;
    ++*(void *)(a1 + 120);
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 128), 1uLL);
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 136), *((unint64_t *)&v30 + 1));
    (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
    (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
    kdebug_trace();
    std::mutex::unlock((std::mutex *)(a1 + 256));
  }
  else
  {
    unsigned __int8 v26 = atomic_load(HGLogger::_enabled);
    if (v26)
    {
      char v27 = (HGLogger *)(a1 + 344);
      if (*(char *)(a1 + 367) < 0) {
        char v27 = *(HGLogger **)v27;
      }
      HGLogger::log(v27, (const char *)1, (HGLogger *)"HGPool::newObject() - Failed to recycle or allocate object! Oops.", v8, v9);
    }
  }
  return v29;
}

void sub_1B77B3260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

void sub_1B77B3274(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

void sub_1B77B3288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

void sub_1B77B329C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

void sub_1B77B32B0(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::releaseObject(uint64_t a1, uint64_t a2)
{
  uint64_t v36 = a2;
  uint64_t v3 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,true>::retrieveObject((int64x2_t *)(a1 + 48), &v36, (uint64_t)&v30);
  if ((void)v30)
  {
    v35[24] = 0;
    *(std::chrono::steady_clock::time_point *)&v35[8] = std::chrono::steady_clock::now();
    HGPool::EntryEventHandler<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::recycled(&v30);
    kdebug_trace();
    uint64_t v4 = *(void *)(a1 + 200);
    uint64_t v5 = *(void *)(a1 + 192);
    uint64_t v6 = 36 * ((v4 - v5) >> 3) - 1;
    if (v4 == v5) {
      uint64_t v6 = 0;
    }
    unint64_t v7 = *(void *)(a1 + 224) + *(void *)(a1 + 216);
    if (v6 == v7)
    {
      std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>>::__add_back_capacity(a1 + 184);
      uint64_t v5 = *(void *)(a1 + 192);
      unint64_t v7 = *(void *)(a1 + 224) + *(void *)(a1 + 216);
    }
    long long v8 = (_OWORD *)(*(void *)(v5 + 8 * (v7 / 0x24)) + 112 * (v7 % 0x24));
    long long v9 = v30;
    long long v10 = v32;
    v8[1] = v31;
    v8[2] = v10;
    *long long v8 = v9;
    long long v11 = v33;
    long long v12 = v34;
    long long v13 = *(_OWORD *)&v35[16];
    v8[5] = *(_OWORD *)v35;
    v8[6] = v13;
    v8[3] = v11;
    v8[4] = v12;
    ++*(void *)(a1 + 224);
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 232), 1uLL);
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 240), *((unint64_t *)&v31 + 1));
    HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::service((int64x2_t *)(a1 + 152), a1);
  }
  else
  {
    HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::retrieveObject((int64x2_t *)(a1 + 152), &v36, (uint64_t)v28);
    long long v34 = v28[4];
    *(_OWORD *)long long v35 = v29[0];
    *(_OWORD *)&v35[9] = *(_OWORD *)((char *)v29 + 9);
    long long v30 = v28[0];
    long long v31 = v28[1];
    long long v32 = v28[2];
    long long v33 = v28[3];
    uint64_t v16 = *(void *)&v28[0];
    if (*(void *)&v28[0])
    {
      uint64_t v17 = *(void *)(a1 + 200);
      uint64_t v18 = *(void *)(a1 + 192);
      uint64_t v19 = 36 * ((v17 - v18) >> 3) - 1;
      if (v17 == v18) {
        uint64_t v19 = 0;
      }
      unint64_t v20 = *(void *)(a1 + 224) + *(void *)(a1 + 216);
      if (v19 == v20)
      {
        std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>>::__add_back_capacity(a1 + 184);
        uint64_t v18 = *(void *)(a1 + 192);
        unint64_t v20 = *(void *)(a1 + 224) + *(void *)(a1 + 216);
      }
      long long v21 = (_OWORD *)(*(void *)(v18 + 8 * (v20 / 0x24)) + 112 * (v20 % 0x24));
      long long v22 = v30;
      long long v23 = v32;
      v21[1] = v31;
      v21[2] = v23;
      _OWORD *v21 = v22;
      long long v24 = v33;
      long long v25 = v34;
      long long v26 = *(_OWORD *)&v35[16];
      v21[5] = *(_OWORD *)v35;
      v21[6] = v26;
      v21[3] = v24;
      v21[4] = v25;
      ++*(void *)(a1 + 224);
      atomic_fetch_add((atomic_ullong *volatile)(a1 + 232), 1uLL);
      atomic_fetch_add((atomic_ullong *volatile)(a1 + 240), *((unint64_t *)&v31 + 1));
      char v27 = "HGPool::releaseObject() - Attempting to double-release a free object: <%p>";
      uint64_t v16 = v30;
    }
    else
    {
      char v27 = "HGPool::releaseObject() - Attempting to release an unmanaged object: <%p>";
    }
    HGLogger::warning((HGLogger *)v27, v14, v15, v16);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  kdebug_trace();
  std::mutex::unlock(v3);
}

void sub_1B77B35F0(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B77B3604(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGMetalTextureWrapperInfinipool::clear(HGMetalTextureWrapperInfinipool *this)
{
}

void HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::clear(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  if (*(void *)(a1 + 224))
  {
    uint64_t v3 = 0;
    do
    {
      HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::_pop_front((int64x2_t *)(a1 + 152));
      --v3;
    }
    while (*(void *)(a1 + 224));
    if (v3)
    {
      (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
      (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
      kdebug_trace();
    }
  }

  std::mutex::unlock(v2);
}

void sub_1B77B3738(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B77B374C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<anonymous namespace'::TextureAllocator>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10D63D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<anonymous namespace'::TextureAllocator>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10D63D8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<anonymous namespace'::TextureAllocator>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void anonymous namespace'::TextureAllocator::~TextureAllocator(_anonymous_namespace_::TextureAllocator *this)
{
}

uint64_t anonymous namespace'::TextureAllocator::allocate(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (void *)[MEMORY[0x1E4F35330] texture2DDescriptorWithPixelFormat:*(void *)(a2 + 16) width:*(void *)a2 height:*(void *)(a2 + 8) mipmapped:0];
  [v4 setUsage:*(unsigned int *)(a2 + 24)];
  [v4 setStorageMode:*(void *)(a2 + 32)];
  [v4 setTextureType:*(unsigned int *)(a2 + 40)];
  [v4 setSampleCount:*(unsigned int *)(a2 + 44)];
  return [*(id *)(a1 + 8) newTextureWithDescriptor:v4];
}

void anonymous namespace'::TextureAllocator::release(uint64_t a1, void *a2)
{
}

void HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::~Pool(uint64_t a1, HGPool::BasePool *a2)
{
  HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::~Pool(a1, a2);

  JUMPOUT(0x1BA9BFBA0);
}

unint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::usedObjectsCount(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 128));
}

unint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::usedTotalUsage(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 136));
}

unint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::freeObjectsCount(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 232));
}

unint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::freeTotalUsage(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 240));
}

void HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::service(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  if (HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::service((int64x2_t *)(a1 + 152), a1))
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
    (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
    kdebug_trace();
  }

  std::mutex::unlock(v2);
}

void sub_1B77B3A5C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::trace(std::mutex *a1)
{
  uint64_t v2 = a1 + 4;
  std::mutex::lock(a1 + 4);
  sig = a1 + 5;
  if (a1[5].__m_.__opaque[15] < 0) {
    sig = (std::mutex *)sig->__m_.__sig;
  }
  (*(void (**)(std::mutex *, std::mutex *))(a1->__m_.__sig + 24))(a1, sig);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 16))(a1);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 40))(a1);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 32))(a1);
  std::mutex::unlock(v2);
}

void sub_1B77B3D14(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B77B3D28(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B77B3D3C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B77B3D50(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::log(uint64_t a1, const char *a2)
{
  uint64_t v3 = (HGLogger *)(a1 + 344);
  if (*(char *)(a1 + 367) < 0)
  {
    uint64_t v3 = *(HGLogger **)v3;
    if ((int)HGLogger::getLevel(v3, a2) < 2) {
      return;
    }
  }
  else if ((int)HGLogger::getLevel((HGLogger *)(a1 + 344), a2) < 2)
  {
    return;
  }
  std::mutex::lock((std::mutex *)(a1 + 256));
  unsigned __int8 v6 = atomic_load(HGLogger::_enabled);
  if (v6)
  {
    unint64_t v7 = (void *)(a1 + 320);
    if (*(char *)(a1 + 343) < 0) {
      unint64_t v7 = (void *)*v7;
    }
    HGLogger::log(v3, (const char *)2, (HGLogger *)"pool '%s' (%p)\n", v4, v5, v7, a1);
  }
  HGLogger::indent(1);
  unsigned __int8 v10 = atomic_load(HGLogger::_enabled);
  if (v10) {
    HGLogger::log(v3, (const char *)2, (HGLogger *)"live objects:\n", v8, v9);
  }
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,true>::log((void *)(a1 + 48), v3);
  unsigned __int8 v13 = atomic_load(HGLogger::_enabled);
  if (v13) {
    HGLogger::log(v3, (const char *)2, (HGLogger *)"free objects:\n", v11, v12);
  }
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::log((void *)(a1 + 152), v3);
  HGLogger::indent(0xFFFFFFFFLL);

  std::mutex::unlock((std::mutex *)(a1 + 256));
}

void sub_1B77B3E90(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::canService(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 372);
}

uint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::canTrace(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 373);
}

uint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::canLog(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 374);
}

int64x2_t *HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::~List(int64x2_t *a1)
{
  while (a1[4].i64[1])
    HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::_pop_front(a1);
  std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>>::~deque[abi:ne180100]((uint64_t)a1[2].i64);
  uint64_t v2 = (std::__shared_weak_count *)a1[1].i64[1];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1->i64[1];
  if (!v3 || atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  return a1;
}

uint64_t HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::_pop_front(int64x2_t *a1)
{
  uint64_t v2 = (uint64_t *)(*(void *)(a1[2].i64[1] + 8 * (a1[4].i64[0] / 0x2EuLL)) + 88 * (a1[4].i64[0] % 0x2EuLL));
  uint64_t v4 = *v2;
  uint64_t v3 = v2[1];
  uint64_t v5 = v2[2];
  uint64_t v6 = v2[3];
  unint64_t v7 = (HGMetalUtils *)v2[4];
  atomic_fetch_add(a1[5].i64, 0xFFFFFFFFFFFFFFFFLL);
  atomic_fetch_add(&a1[5].i64[1], -(v6 * v5 * HGMetalUtils::bytesPerPixel(v7)));
  long long v8 = (void **)a1[2].i64[1];
  int64x2_t v9 = vaddq_s64(a1[4], (int64x2_t)xmmword_1B7E73580);
  a1[4] = v9;
  if (v9.i64[0] >= 0x5CuLL)
  {
    operator delete(*v8);
    a1[2].i64[1] += 8;
    a1[4].i64[0] -= 46;
  }
  HGMetalUtils::bytesPerPixel(v7);
  kdebug_trace();
  kdebug_trace();
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1->i64[0] + 24))(a1->i64[0], v4);
  if (v3) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1->i64[0] + 24))(a1->i64[0], v3);
  }
  return kdebug_trace();
}

void sub_1B77B418C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

uint64_t std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>>::~deque[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 23;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 46;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      unint64_t v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::~Pool(uint64_t a1, HGPool::BasePool *a2)
{
  *(void *)a1 = &unk_1F10D6480;
  HGPool::unregisterPool((HGPool *)a1, a2);
  if (*(char *)(a1 + 367) < 0)
  {
    operator delete(*(void **)(a1 + 344));
    if ((*(char *)(a1 + 343) & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_16:
    operator delete(*(void **)(a1 + 320));
    goto LABEL_3;
  }
  if (*(char *)(a1 + 343) < 0) {
    goto LABEL_16;
  }
LABEL_3:
  std::mutex::~mutex((std::mutex *)(a1 + 256));
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::~List((int64x2_t *)(a1 + 152));
  std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>>::~deque[abi:ne180100](a1 + 80);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  unint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  unint64_t v5 = *(std::__shared_weak_count **)(a1 + 40);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v6 || atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
  ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
  std::__shared_weak_count::__release_weak(v6);
  return a1;
}

uint64_t HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::service(int64x2_t *a1, uint64_t a2)
{
  if (!a1[1].i64[0] || !a1[4].i64[1]) {
    return 0;
  }
  uint64_t v4 = 0;
  do
  {
    unint64_t v5 = atomic_load((unint64_t *)&a1[5]);
    if (v5 <= (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1[1].i64[0] + 16))(a1[1].i64[0], a2))
    {
      unint64_t v6 = atomic_load(&a1[5].u64[1]);
      if (v6 <= (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1[1].i64[0] + 24))(a1[1].i64[0], a2))
      {
        unint64_t v7 = a1[4].u64[0];
        uint64_t v8 = *(void *)(a1[2].i64[1] + 8 * (v7 / 0x2E));
        unint64_t v9 = std::chrono::steady_clock::now().__d_.__rep_ - *(void *)(v8 + 88 * (v7 % 0x2E) + 64);
        if (v9 <= (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1[1].i64[0] + 32))(a1[1].i64[0], a2)) {
          break;
        }
      }
    }
    HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::_pop_front(a1);
    ++v4;
  }
  while (a1[4].i64[1]);
  return v4;
}

void HGPool::EntryTrace<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::trace(uint64_t a1)
{
  HGPool::DescriptorString<HGMetalTexturePool::Descriptor>::str(a1 + 16);
  HGMetalUtils::bytesPerPixel(*(HGMetalUtils **)(a1 + 32));
  if (*(unsigned char *)(a1 + 80))
  {
    if ((v3 & 0x80000000) == 0) {
      return;
    }
LABEL_5:
    operator delete(__p);
    return;
  }
  std::chrono::steady_clock::now();
  if (v3 < 0) {
    goto LABEL_5;
  }
}

void sub_1B77B4664(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGPool::DescriptorString<HGMetalTexturePool::Descriptor>::str(uint64_t a1)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v9);
  uint64_t v2 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, (uint64_t)" x ", 3);
  char v3 = (void *)std::ostream::operator<<();
  uint64_t v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)", ", 2);
  unint64_t v5 = HGMetalUtils::toString(*(HGMetalUtils **)(a1 + 16));
  size_t v6 = strlen(v5);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)v5, v6);
  std::stringbuf::str();
  v9[0] = *MEMORY[0x1E4FBA408];
  uint64_t v7 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v9 + *(void *)(v9[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  v9[2] = v7;
  v9[3] = MEMORY[0x1E4FBA470] + 16;
  if (v10 < 0) {
    operator delete((void *)v9[11]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BA9BFAB0](&v11);
}

void sub_1B77B4840(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,true>::log(void *a1, HGLogger *a2)
{
  if (a1[9])
  {
    HGLogger::indent(1);
    uint64_t v4 = a1[5];
    if (a1[6] != v4)
    {
      unint64_t v5 = a1[8];
      size_t v6 = (void *)(v4 + 8 * (v5 / 0x2E));
      unint64_t v7 = *v6 + 88 * (v5 % 0x2E);
      unint64_t v8 = *(void *)(v4 + 8 * ((a1[9] + v5) / 0x2E)) + 88 * ((a1[9] + v5) % 0x2E);
      while (v7 != v8)
      {
        long long v9 = *(_OWORD *)(v7 + 16);
        *(_OWORD *)std::string __p = *(_OWORD *)v7;
        long long v21 = v9;
        long long v10 = *(_OWORD *)(v7 + 32);
        long long v11 = *(_OWORD *)(v7 + 48);
        long long v12 = *(_OWORD *)(v7 + 64);
        uint64_t v25 = *(void *)(v7 + 80);
        long long v23 = v11;
        long long v24 = v12;
        long long v22 = v10;
        HGPool::EntryLog<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::log((uint64_t *)__p, a2, (const char *)3);
        v7 += 88;
        if (v7 - *v6 == 4048)
        {
          unint64_t v13 = v6[1];
          ++v6;
          unint64_t v7 = v13;
        }
      }
    }
    HGLogger::indent(0xFFFFFFFFLL);
    uint64_t v14 = (HGLoggerUtils *)atomic_load(a1 + 11);
    HGLoggerUtils::bytesPrettyString(v14);
    unsigned __int8 v17 = atomic_load(HGLogger::_enabled);
    if (v17)
    {
      if ((SBYTE7(v21) & 0x80u) == 0) {
        uint64_t v18 = __p;
      }
      else {
        uint64_t v18 = (void **)__p[0];
      }
      unint64_t v19 = atomic_load(a1 + 10);
      HGLogger::log(a2, (const char *)2, (HGLogger *)"total : %s (%lu)\n", v15, v16, v18, v19);
    }
    if (SBYTE7(v21) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1B77B49D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::log(void *a1, HGLogger *a2)
{
  if (a1[9])
  {
    HGLogger::indent(1);
    uint64_t v4 = a1[5];
    if (a1[6] != v4)
    {
      unint64_t v5 = a1[8];
      size_t v6 = (void *)(v4 + 8 * (v5 / 0x2E));
      unint64_t v7 = *v6 + 88 * (v5 % 0x2E);
      unint64_t v8 = *(void *)(v4 + 8 * ((a1[9] + v5) / 0x2E)) + 88 * ((a1[9] + v5) % 0x2E);
      while (v7 != v8)
      {
        long long v9 = *(_OWORD *)(v7 + 16);
        *(_OWORD *)std::string __p = *(_OWORD *)v7;
        long long v21 = v9;
        long long v10 = *(_OWORD *)(v7 + 32);
        long long v11 = *(_OWORD *)(v7 + 48);
        long long v12 = *(_OWORD *)(v7 + 64);
        uint64_t v25 = *(void *)(v7 + 80);
        long long v23 = v11;
        long long v24 = v12;
        long long v22 = v10;
        HGPool::EntryLog<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::log((uint64_t *)__p, a2, (const char *)3);
        v7 += 88;
        if (v7 - *v6 == 4048)
        {
          unint64_t v13 = v6[1];
          ++v6;
          unint64_t v7 = v13;
        }
      }
    }
    HGLogger::indent(0xFFFFFFFFLL);
    uint64_t v14 = (HGLoggerUtils *)atomic_load(a1 + 11);
    HGLoggerUtils::bytesPrettyString(v14);
    unsigned __int8 v17 = atomic_load(HGLogger::_enabled);
    if (v17)
    {
      if ((SBYTE7(v21) & 0x80u) == 0) {
        uint64_t v18 = __p;
      }
      else {
        uint64_t v18 = (void **)__p[0];
      }
      unint64_t v19 = atomic_load(a1 + 10);
      HGLogger::log(a2, (const char *)2, (HGLogger *)"total : %s (%lu)\n", v15, v16, v18, v19);
    }
    if (SBYTE7(v21) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1B77B4B78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void HGPool::EntryLog<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::log(uint64_t *a1, HGLogger *a2, const char *a3)
{
  uint64_t v6 = *a1;
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[3] * a1[2];
  unsigned int v9 = HGMetalUtils::bytesPerPixel((HGMetalUtils *)a1[4]);
  HGLoggerUtils::bytesPrettyString((HGLoggerUtils *)(v8 * v9));
  HGPool::DescriptorString<HGMetalTexturePool::Descriptor>::str(v7);
  if (*((unsigned char *)a1 + 80))
  {
    unsigned __int8 v12 = atomic_load(HGLogger::_enabled);
    if (v12)
    {
      unint64_t v13 = v26;
      if (v27 < 0) {
        unint64_t v13 = (void **)v26[0];
      }
      uint64_t v14 = v24;
      if (v25 < 0) {
        uint64_t v14 = (void **)v24[0];
      }
      HGLogger::log(a2, a3, (HGLogger *)"%p %10s  %4lu   %s\n", v10, v11, v6, v13, a1[9], v14);
    }
    goto LABEL_17;
  }
  v15.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  HGLoggerUtils::timePrettyString((HGLoggerUtils *)(v15.__d_.__rep_ - a1[8]));
  unsigned __int8 v18 = atomic_load(HGLogger::_enabled);
  if (v18)
  {
    unint64_t v19 = v26;
    if (v27 < 0) {
      unint64_t v19 = (void **)v26[0];
    }
    p_p = &__p;
    if (v23 < 0) {
      p_p = __p;
    }
    long long v21 = v24;
    if (v25 < 0) {
      long long v21 = (void **)v24[0];
    }
    HGLogger::log(a2, a3, (HGLogger *)"%p %10s  %4lu  %10s   %s\n", v16, v17, v6, v19, a1[9], p_p, v21);
  }
  if ((v23 & 0x80000000) == 0)
  {
LABEL_17:
    if ((v25 & 0x80000000) == 0) {
      goto LABEL_18;
    }
    goto LABEL_21;
  }
  operator delete(__p);
  if ((v25 & 0x80000000) == 0)
  {
LABEL_18:
    if ((v27 & 0x80000000) == 0) {
      return;
    }
LABEL_22:
    operator delete(v26[0]);
    return;
  }
LABEL_21:
  operator delete(v24[0]);
  if (v27 < 0) {
    goto LABEL_22;
  }
}

void sub_1B77B4D48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a19 < 0)
  {
    operator delete(__p);
    if ((a25 & 0x80000000) == 0)
    {
LABEL_3:
      if ((*(char *)(v25 - 49) & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else if ((a25 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a20);
  if ((*(char *)(v25 - 49) & 0x80000000) == 0) {
LABEL_4:
  }
    _Unwind_Resume(exception_object);
LABEL_7:
  operator delete(*(void **)(v25 - 72));
  _Unwind_Resume(exception_object);
}

uint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>::newObject(uint64_t a1, long long *a2, char a3)
{
  if ((a3 & 1) != 0 || (uint64_t v4 = *(void *)(a1 + 32)) == 0)
  {
    long long v5 = a2[1];
    long long v33 = *a2;
    long long v34 = v5;
    long long v35 = a2[2];
  }
  else
  {
    (*(void (**)(long long *__return_ptr))(*(void *)v4 + 16))(&v33);
  }
  std::mutex::lock((std::mutex *)(a1 + 256));
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::retrieveObject((int64x2_t *)(a1 + 152), &v33, (uint64_t)&v27);
  std::mutex::unlock((std::mutex *)(a1 + 256));
  if ((void)v27)
  {
    LOBYTE(v32) = 1;
    unsigned long long v31 = __PAIR128__(*((unint64_t *)&v31 + 1), std::chrono::steady_clock::now().__d_.__rep_)
        + __PAIR128__(1, 0);
    HGMetalUtils::bytesPerPixel(v29[0]);
    kdebug_trace();
    int v8 = *(_DWORD *)(a1 + 368);
    if (v8 == 1)
    {
      kdebug_trace();
      uint64_t v25 = v27;
      uint64_t v11 = (*(uint64_t (**)(void, long long *))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), &v33);
      HGMetalUtils::bytesPerPixel(v29[0]);
      *(void *)&long long v27 = v11;
      *(_OWORD *)long long v29 = v34;
      long long v30 = v35;
      long long v28 = v33;
      HGMetalUtils::bytesPerPixel((HGMetalUtils *)v34);
      kdebug_trace();
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 16) + 24))(*(void *)(a1 + 16), v25);
      kdebug_trace();
    }
    else if (v8 == 2)
    {
      kdebug_trace();
      uint64_t v24 = *((void *)&v27 + 1);
      uint64_t v26 = v27;
      uint64_t v9 = (*(uint64_t (**)(void, long long *))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), &v33);
      HGMetalUtils::bytesPerPixel(v29[0]);
      *(void *)&long long v27 = v9;
      *((void *)&v27 + 1) = v26;
      *(_OWORD *)long long v29 = v34;
      long long v30 = v35;
      long long v28 = v33;
      HGMetalUtils::bytesPerPixel((HGMetalUtils *)v34);
      kdebug_trace();
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 16) + 24))(*(void *)(a1 + 16), v24);
      kdebug_trace();
    }
  }
  else
  {
    kdebug_trace();
    uint64_t v10 = (*(uint64_t (**)(void, long long *))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), &v33);
    long long v28 = v33;
    *(_OWORD *)long long v29 = v34;
    long long v30 = v35;
    unsigned long long v31 = 0uLL;
    long long v27 = (unint64_t)v10;
    LOBYTE(v32) = 1;
    unsigned long long v31 = __PAIR128__(1, std::chrono::steady_clock::now().__d_.__rep_) + 0;
    HGMetalUtils::bytesPerPixel(v29[0]);
    kdebug_trace();
    kdebug_trace();
  }
  if ((void)v27)
  {
    std::mutex::lock((std::mutex *)(a1 + 256));
    uint64_t v12 = *(void *)(a1 + 96);
    uint64_t v13 = *(void *)(a1 + 88);
    uint64_t v14 = 46 * ((v12 - v13) >> 3) - 1;
    if (v12 == v13) {
      uint64_t v14 = 0;
    }
    unint64_t v15 = *(void *)(a1 + 120) + *(void *)(a1 + 112);
    if (v14 == v15)
    {
      std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>>::__add_back_capacity(a1 + 80);
      uint64_t v13 = *(void *)(a1 + 88);
      unint64_t v15 = *(void *)(a1 + 120) + *(void *)(a1 + 112);
    }
    unint64_t v16 = *(void *)(v13 + 8 * (v15 / 0x2E)) + 88 * (v15 % 0x2E);
    long long v17 = v28;
    *(_OWORD *)unint64_t v16 = v27;
    *(_OWORD *)(v16 + 16) = v17;
    long long v18 = *(_OWORD *)v29;
    long long v19 = v30;
    unsigned long long v20 = v31;
    *(void *)(v16 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = v32;
    *(_OWORD *)(v16 + 48) = v19;
    *(_OWORD *)(v16 + 64) = v20;
    *(_OWORD *)(v16 + 32) = v18;
    ++*(void *)(a1 + 120);
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 128), 1uLL);
    atomic_fetch_add((atomic_ullong *volatile)(a1 + 136), *((void *)&v28 + 1) * v28 * HGMetalUtils::bytesPerPixel(v29[0]));
    (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
    (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
    kdebug_trace();
    std::mutex::unlock((std::mutex *)(a1 + 256));
  }
  else
  {
    unsigned __int8 v21 = atomic_load(HGLogger::_enabled);
    if (v21)
    {
      long long v22 = (HGLogger *)(a1 + 344);
      if (*(char *)(a1 + 367) < 0) {
        long long v22 = *(HGLogger **)v22;
      }
      HGLogger::log(v22, (const char *)1, (HGLogger *)"HGPool::newObject() - Failed to recycle or allocate object! Oops.", v6, v7);
    }
  }
  return v27;
}

void sub_1B77B5504(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, char a14)
{
}

void sub_1B77B5518(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, char a14)
{
}

void sub_1B77B552C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, char a14)
{
}

void sub_1B77B5540(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, char a14)
{
}

void sub_1B77B5554(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::retrieveObject@<X0>(int64x2_t *a1@<X0>, long long *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  long long v19 = 0;
  long long v6 = a2[1];
  long long v20 = *a2;
  long long v21 = v6;
  long long v22 = a2[2];
  uint64_t v12 = 0;
  long long v13 = v20;
  long long v14 = v6;
  long long v15 = v22;
  long long v17 = 0;
  uint64_t v7 = (char *)operator new(0x58uLL);
  *(void *)uint64_t v7 = &unk_1F10D6508;
  *((void *)v7 + 4) = 0;
  long long v8 = a2[1];
  *(_OWORD *)(v7 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = *a2;
  *(_OWORD *)(v7 + 56) = v8;
  *(_OWORD *)(v7 + 72) = a2[2];
  long long v17 = v7;
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::_retrieve(a1, v16, a3);
  if (v17 == v16)
  {
    (*(void (**)(void *))(v16[0] + 32))(v16);
    uint64_t v9 = v12;
    if (v12 != v11) {
      goto LABEL_5;
    }
  }
  else
  {
    if (v17) {
      (*(void (**)(void))(*v17 + 40))();
    }
    uint64_t v9 = v12;
    if (v12 != v11)
    {
LABEL_5:
      if (v9) {
        (*(void (**)(void *))(*v9 + 40))(v9);
      }
      uint64_t result = (uint64_t)v19;
      if (v19 != v18) {
        goto LABEL_8;
      }
      return (*(uint64_t (**)(void *))(v18[0] + 32))(v18);
    }
  }
  (*(void (**)(void *))(v11[0] + 32))(v11);
  uint64_t result = (uint64_t)v19;
  if (v19 == v18) {
    return (*(uint64_t (**)(void *))(v18[0] + 32))(v18);
  }
LABEL_8:
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
  }
  return result;
}

void sub_1B77B5790(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v16 = va_arg(va2, void);
  uint64_t v17 = va_arg(va2, void);
  uint64_t v18 = va_arg(va2, void);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor> const&)>::~function((uint64_t *)va1);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor> const&)>::~function((uint64_t *)va);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor> const&)>::~function((uint64_t *)va2);
  _Unwind_Resume(a1);
}

void sub_1B77B57B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor> const&)>::~function((uint64_t *)va);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor> const&)>::~function((uint64_t *)va1);
  _Unwind_Resume(a1);
}

void **HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::_retrieve@<X0>(int64x2_t *a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)(a3 + 28) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(unsigned char *)(a3 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = 1;
  unint64_t v5 = a1[4].u64[0];
  unint64_t v6 = v5 + a1[4].i64[1];
  unint64_t v7 = v6 / 0x2E;
  uint64_t v8 = a1[2].i64[1];
  if (a1[3].i64[0] != v8)
  {
    unint64_t v9 = *(void *)(v8 + 8 * v7) + 88 * (v6 % 0x2E);
    unint64_t v10 = *(void *)(v8 + 8 * (v5 / 0x2E)) + 88 * (v5 % 0x2E);
    uint64_t v11 = (void *)a2[3];
    if (v11) {
      goto LABEL_3;
    }
LABEL_6:
    long long v27 = 0;
    goto LABEL_8;
  }
  unint64_t v9 = 0;
  unint64_t v10 = 0;
  uint64_t v11 = (void *)a2[3];
  if (!v11) {
    goto LABEL_6;
  }
LABEL_3:
  if (v11 == a2)
  {
    long long v27 = (void **)v26;
    (*(void (**)(void *, void *))(*a2 + 24))(a2, v26);
  }
  else
  {
    long long v27 = (void **)(*(uint64_t (**)(void *))(*v11 + 16))(v11);
  }
LABEL_8:
  uint64_t v12 = (uint64_t *)(v8 + 8 * v7);
  if (v9 != v10)
  {
    uint64_t v13 = *v12;
    while (1)
    {
      uint64_t v14 = v9;
      if (v9 == v13) {
        uint64_t v14 = *(v12 - 1) + 4048;
      }
      if (!v27) {
        std::__throw_bad_function_call[abi:ne180100]();
      }
      if ((*((uint64_t (**)(void **, uint64_t))*v27 + 6))(v27, v14 - 88)) {
        break;
      }
      uint64_t v13 = *v12;
      if (v9 == *v12)
      {
        uint64_t v15 = *--v12;
        uint64_t v13 = v15;
        unint64_t v9 = v15 + 4048;
      }
      v9 -= 88;
      if (v9 == v10)
      {
        unint64_t v9 = v10;
        break;
      }
    }
  }
  uint64_t result = v27;
  if (v27 == v26)
  {
    uint64_t result = (void **)(*(uint64_t (**)(void *))(v26[0] + 32))(v26);
    uint64_t v17 = a1[2].i64[1];
    if (a1[3].i64[0] != v17) {
      goto LABEL_22;
    }
LABEL_25:
    if (!v9) {
      return result;
    }
    goto LABEL_26;
  }
  if (v27) {
    uint64_t result = (void **)(*((uint64_t (**)(void))*v27 + 5))();
  }
  uint64_t v17 = a1[2].i64[1];
  if (a1[3].i64[0] == v17) {
    goto LABEL_25;
  }
LABEL_22:
  if (v9 == *(void *)(v17 + 8 * (a1[4].i64[0] / 0x2EuLL)) + 88 * (a1[4].i64[0] % 0x2EuLL)) {
    return result;
  }
LABEL_26:
  uint64_t v18 = v9 - *v12;
  uint64_t v19 = 0x2E8BA2E8BA2E8BA3 * (v18 >> 3);
  if (v18 < 89)
  {
    unint64_t v23 = 46 - v19;
    long long v21 = &v12[-(v23 / 0x2E)];
    unint64_t v22 = *v21 + 88 * (46 * (v23 / 0x2E) - v23) + 3960;
  }
  else
  {
    unint64_t v20 = v19 - 1;
    long long v21 = &v12[v20 / 0x2E];
    unint64_t v22 = *v21 + 88 * (v20 % 0x2E);
  }
  long long v24 = *(_OWORD *)(v22 + 48);
  *(_OWORD *)(a3 + 32) = *(_OWORD *)(v22 + 32);
  *(_OWORD *)(a3 + 48) = v24;
  *(_OWORD *)(a3 + 64) = *(_OWORD *)(v22 + 64);
  *(unsigned char *)(a3 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = *(unsigned char *)(v22 + 80);
  long long v25 = *(_OWORD *)(v22 + 16);
  *(_OWORD *)a3 = *(_OWORD *)v22;
  *(_OWORD *)(a3 + 16) = v25;
  atomic_fetch_add(a1[5].i64, 0xFFFFFFFFFFFFFFFFLL);
  atomic_fetch_add(&a1[5].i64[1], -(*(void *)(a3 + 24)* *(void *)(a3 + 16)* HGMetalUtils::bytesPerPixel(*(HGMetalUtils **)(a3 + 32))));
  return std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>>::erase(a1 + 2, v21, (char *)v22);
}

void sub_1B77B5B90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor> const&)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1B77B5BA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor> const&)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor> const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
    return a1;
  }
  else
  {
    if (v2) {
      (*(void (**)(void *))(*v2 + 40))(v2);
    }
    return a1;
  }
}

void **std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>>::erase(int64x2_t *a1, void *a2, char *a3)
{
  unint64_t v6 = a1[2].u64[0];
  uint64_t v7 = a1->i64[1];
  uint64_t v8 = a1[1].i64[0];
  unint64_t v9 = (const void **)(v7 + 8 * (v6 / 0x2E));
  if (v8 != v7)
  {
    unint64_t v10 = (char *)*v9 + 88 * (v6 % 0x2E);
    if (a3 != v10) {
      goto LABEL_3;
    }
LABEL_9:
    unint64_t v13 = 0;
    uint64_t v12 = *v9;
    goto LABEL_10;
  }
  unint64_t v10 = 0;
  if (!a3) {
    goto LABEL_9;
  }
LABEL_3:
  uint64_t v11 = 46 * ((const void **)a2 - v9) + 0x2E8BA2E8BA2E8BA3 * ((uint64_t)&a3[-*a2] >> 3);
  uint64_t v12 = *v9;
  unint64_t v13 = v11 - 0x2E8BA2E8BA2E8BA3 * ((v10 - (unsigned char *)*v9) >> 3);
  if (!v13)
  {
LABEL_10:
    char v22 = 1;
    uint64_t v14 = (const void **)(v7 + 8 * (v6 / 0x2E));
    uint64_t v15 = (const void **)v10;
    goto LABEL_13;
  }
  if (v11 < 1)
  {
    uint64_t v14 = &v9[-((45 - v11) / 0x2EuLL)];
    uint64_t v12 = *v14;
    uint64_t v15 = (const void **)((char *)*v14 + 88 * (46 * ((45 - v11) / 0x2EuLL) - (45 - v11)) + 3960);
    uint64_t v16 = a1[2].i64[1];
    if (v13 > (unint64_t)(v16 - 1) >> 1) {
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v14 = &v9[v11 / 0x2EuLL];
    uint64_t v12 = *v14;
    uint64_t v15 = (const void **)((char *)*v14 + 88 * (v11 % 0x2EuLL));
    uint64_t v16 = a1[2].i64[1];
    if (v13 > (unint64_t)(v16 - 1) >> 1)
    {
LABEL_6:
      uint64_t v17 = (char *)v15 - v12;
      uint64_t v18 = 0x2E8BA2E8BA2E8BA3 * (((char *)v15 - v12) >> 3);
      if (v17 < -87)
      {
        unint64_t v35 = 44 - v18;
        unint64_t v20 = &v14[-(v35 / 0x2E)];
        long long v21 = (char *)*v20 + 88 * (46 * (v35 / 0x2E) - v35) + 3960;
      }
      else
      {
        unint64_t v19 = v18 + 1;
        unint64_t v20 = &v14[v19 / 0x2E];
        long long v21 = (char *)*v20 + 88 * (v19 % 0x2E);
      }
      unint64_t v36 = v16 + v6;
      unint64_t v37 = (v16 + v6) / 0x2E;
      long long v38 = (const void **)(v7 + 8 * v37);
      if (v8 == v7) {
        long long v39 = 0;
      }
      else {
        long long v39 = (char *)*v38 + 88 * (v36 - 46 * v37);
      }
      v43[0] = v14;
      v43[1] = v15;
      std::__for_each_segment[abi:ne180100]<std::__deque_iterator<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,HGMetalTexturePool::Descriptor*,HGMetalTexturePool::Descriptor&,HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>*,long,46l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>*,HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>*>>(v20, v21, v38, v39, (uint64_t)v43);
      unsigned long long v31 = (void **)a1->i64[1];
      unint64_t v40 = (void **)a1[1].i64[0];
      uint64_t v41 = 46 * (v40 - v31) - 1;
      unint64_t v30 = a1[2].u64[0];
      uint64_t v42 = a1[2].i64[1];
      a1[2].i64[1] = v42 - 1;
      if (v40 == v31) {
        uint64_t v41 = 0;
      }
      if (v41 - (v42 + v30) + 1 >= 0x5C)
      {
        operator delete(*(v40 - 1));
        char v22 = 0;
        unsigned long long v31 = (void **)a1->i64[1];
        a1[1].i64[0] -= 8;
        unint64_t v30 = a1[2].u64[0];
      }
      else
      {
        char v22 = 0;
      }
      goto LABEL_18;
    }
  }
  char v22 = 0;
LABEL_13:
  uint64_t v23 = (char *)v15 - v12;
  uint64_t v24 = 0x2E8BA2E8BA2E8BA3 * (((char *)v15 - v12) >> 3);
  if (v23 < -87)
  {
    unint64_t v28 = 44 - v24;
    uint64_t v26 = &v14[-(v28 / 0x2E)];
    long long v27 = (char *)*v26 + 88 * (46 * (v28 / 0x2E) - v28) + 3960;
  }
  else
  {
    unint64_t v25 = v24 + 1;
    uint64_t v26 = &v14[v25 / 0x2E];
    long long v27 = (char *)*v26 + 88 * (v25 % 0x2E);
  }
  std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,HGMetalTexturePool::Descriptor*,HGMetalTexturePool::Descriptor&,HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>*,long,46l>,HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>*,0>(v9, v10, v14, (char *)v15, v26, v27, v43);
  int64x2_t v29 = vaddq_s64(a1[2], (int64x2_t)xmmword_1B7E73580);
  a1[2] = v29;
  unint64_t v30 = v29.i64[0];
  unsigned long long v31 = (void **)a1->i64[1];
  if (v29.i64[0] >= 0x5CuLL)
  {
    operator delete(*v31);
    unsigned long long v31 = (void **)(a1->i64[1] + 8);
    a1->i64[1] = (uint64_t)v31;
    unint64_t v30 = a1[2].i64[0] - 46;
    a1[2].i64[0] = v30;
  }
LABEL_18:
  uint64_t result = &v31[v30 / 0x2E];
  if ((void **)a1[1].i64[0] == v31)
  {
    unint64_t v33 = 0;
    if (v22) {
      return result;
    }
  }
  else
  {
    unint64_t v33 = (unint64_t)*result + 88 * (v30 % 0x2E);
    if (v22) {
      return result;
    }
  }
  uint64_t v34 = v13 + 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v33 - (void)*result) >> 3);
  if (v34 < 1) {
    result -= (45 - v34) / 0x2EuLL;
  }
  else {
    result += v34 / 0x2EuLL;
  }
  return result;
}

void *std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,HGMetalTexturePool::Descriptor*,HGMetalTexturePool::Descriptor&,HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>*,long,46l>,HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>*,0>@<X0>(const void **a1@<X1>, char *a2@<X2>, const void **a3@<X3>, char *a4@<X4>, const void **a5@<X5>, char *a6@<X6>, const void ***a7@<X8>)
{
  uint64_t v8 = a5;
  unint64_t v9 = (const void **)a4;
  unint64_t v10 = a3;
  uint64_t v12 = a7;
  if (a1 == a3)
  {
    if (a2 != a4)
    {
      uint64_t v34 = (uint64_t)*a5;
      unint64_t v35 = a4;
      while (1)
      {
        uint64_t v36 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)&a6[-v34] >> 3);
        if (0x2E8BA2E8BA2E8BA3 * ((v35 - a2) >> 3) < v36) {
          uint64_t v36 = 0x2E8BA2E8BA2E8BA3 * ((v35 - a2) >> 3);
        }
        v35 -= 88 * v36;
        a6 -= 88 * v36;
        if (v36) {
          uint64_t result = memmove(a6, v35, 88 * v36 - 7);
        }
        if (v35 == a2) {
          break;
        }
        uint64_t v37 = (uint64_t)*--v8;
        uint64_t v34 = v37;
        a6 = (char *)(v37 + 4048);
      }
      if ((char *)*v8 + 4048 == a6)
      {
        long long v38 = (char *)v8[1];
        ++v8;
        a6 = v38;
      }
      unint64_t v10 = a3;
    }
  }
  else
  {
    uint64_t v14 = *a3;
    if (*a3 != a4)
    {
      uint64_t v15 = (uint64_t)*a5;
      uint64_t v16 = a4;
      while (1)
      {
        uint64_t v17 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)&a6[-v15] >> 3);
        if (0x2E8BA2E8BA2E8BA3 * ((v16 - v14) >> 3) < v17) {
          uint64_t v17 = 0x2E8BA2E8BA2E8BA3 * ((v16 - v14) >> 3);
        }
        v16 -= 88 * v17;
        a6 -= 88 * v17;
        if (v17) {
          uint64_t result = memmove(a6, v16, 88 * v17 - 7);
        }
        if (v16 == v14) {
          break;
        }
        uint64_t v19 = (uint64_t)*--v8;
        uint64_t v15 = v19;
        a6 = (char *)(v19 + 4048);
      }
      if ((char *)*v8 + 4048 == a6)
      {
        unint64_t v20 = (char *)v8[1];
        ++v8;
        a6 = v20;
      }
      unint64_t v10 = a3;
    }
    long long v21 = v10 - 1;
    if (v10 - 1 != a1)
    {
      char v22 = (char *)*v8;
      do
      {
        while (1)
        {
          uint64_t v23 = *v21;
          uint64_t v24 = (char *)*v21 + 4048;
          while (1)
          {
            uint64_t v25 = 0x2E8BA2E8BA2E8BA3 * ((a6 - v22) >> 3);
            if (0x2E8BA2E8BA2E8BA3 * ((v24 - v23) >> 3) < v25) {
              uint64_t v25 = 0x2E8BA2E8BA2E8BA3 * ((v24 - v23) >> 3);
            }
            v24 -= 88 * v25;
            a6 -= 88 * v25;
            if (v25) {
              uint64_t result = memmove(a6, v24, 88 * v25 - 7);
            }
            if (v24 == v23) {
              break;
            }
            uint64_t v26 = (char *)*--v8;
            char v22 = v26;
            a6 = v26 + 4048;
          }
          char v22 = (char *)*v8;
          if ((char *)*v8 + 4048 == a6) {
            break;
          }
          if (--v21 == a1) {
            goto LABEL_25;
          }
        }
        long long v27 = (char *)v8[1];
        ++v8;
        char v22 = v27;
        a6 = v27;
        --v21;
      }
      while (v21 != a1);
LABEL_25:
      unint64_t v10 = a3;
    }
    unint64_t v28 = (char *)*a1 + 4048;
    unint64_t v9 = (const void **)a4;
    if (v28 != a2)
    {
      uint64_t v29 = (uint64_t)*v8;
      while (1)
      {
        uint64_t v30 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)&a6[-v29] >> 3);
        if (0x2E8BA2E8BA2E8BA3 * ((v28 - a2) >> 3) < v30) {
          uint64_t v30 = 0x2E8BA2E8BA2E8BA3 * ((v28 - a2) >> 3);
        }
        v28 -= 88 * v30;
        a6 -= 88 * v30;
        if (v30) {
          uint64_t result = memmove(a6, v28, 88 * v30 - 7);
        }
        if (v28 == a2) {
          break;
        }
        uint64_t v31 = (uint64_t)*--v8;
        uint64_t v29 = v31;
        a6 = (char *)(v31 + 4048);
      }
      if ((char *)*v8 + 4048 == a6)
      {
        uint64_t v32 = (char *)v8[1];
        ++v8;
        a6 = v32;
      }
    }
    uint64_t v12 = a7;
  }
  unsigned char *v12 = v10;
  v12[1] = v9;
  v12[2] = v8;
  v12[3] = (const void **)a6;
  return result;
}

const void **std::__for_each_segment[abi:ne180100]<std::__deque_iterator<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,HGMetalTexturePool::Descriptor*,HGMetalTexturePool::Descriptor&,HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>*,long,46l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>*,HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>*>>(const void **result, unsigned char *__src, const void **a3, unsigned char *a4, uint64_t a5)
{
  unint64_t v6 = __src;
  uint64_t v8 = *(void ***)a5;
  uint64_t v7 = *(char **)(a5 + 8);
  if (result == a3)
  {
    if (__src == a4) {
      goto LABEL_48;
    }
    uint64_t v32 = (char *)*v8++;
    uint64_t v31 = v32;
    while (1)
    {
      uint64_t v33 = 0x2E8BA2E8BA2E8BA3 * ((v31 - v7 + 4048) >> 3);
      if (0x2E8BA2E8BA2E8BA3 * ((a4 - v6) >> 3) >= v33) {
        uint64_t v34 = v33;
      }
      else {
        uint64_t v34 = 0x2E8BA2E8BA2E8BA3 * ((a4 - v6) >> 3);
      }
      if (v34) {
        uint64_t result = (const void **)memmove(v7, v6, 88 * v34 - 7);
      }
      v6 += 88 * v34;
      if (v6 == a4) {
        break;
      }
      unint64_t v35 = (char *)*v8++;
      uint64_t v31 = v35;
      uint64_t v7 = v35;
    }
    v7 += 88 * v34;
    uint64_t v30 = v8 - 1;
    if ((char *)*(v8 - 1) + 4048 != v7) {
      goto LABEL_36;
    }
    goto LABEL_47;
  }
  unint64_t v9 = result;
  unint64_t v10 = (char *)*result + 4048;
  if (v10 != __src)
  {
    uint64_t v12 = (char *)*v8++;
    uint64_t v11 = v12;
    while (1)
    {
      uint64_t v13 = 0x2E8BA2E8BA2E8BA3 * ((v11 - v7 + 4048) >> 3);
      if (0x2E8BA2E8BA2E8BA3 * ((v10 - v6) >> 3) >= v13) {
        uint64_t v14 = v13;
      }
      else {
        uint64_t v14 = 0x2E8BA2E8BA2E8BA3 * ((v10 - v6) >> 3);
      }
      if (v14) {
        uint64_t result = (const void **)memmove(v7, v6, 88 * v14 - 7);
      }
      v6 += 88 * v14;
      if (v6 == v10) {
        break;
      }
      uint64_t v15 = (char *)*v8++;
      uint64_t v11 = v15;
      uint64_t v7 = v15;
    }
    v7 += 88 * v14;
    if ((char *)*(v8 - 1) + 4048 == v7)
    {
      uint64_t v7 = (char *)*v8;
      *(void *)a5 = v8;
      *(void *)(a5 + 8) = v7;
      uint64_t v16 = v9 + 1;
      if (v9 + 1 != a3) {
        goto LABEL_16;
      }
      goto LABEL_26;
    }
    --v8;
  }
  *(void *)a5 = v8;
  *(void *)(a5 + 8) = v7;
  uint64_t v16 = v9 + 1;
  if (v9 + 1 != a3)
  {
    do
    {
LABEL_16:
      while (1)
      {
        uint64_t v17 = 0;
        long long v38 = v16;
        uint64_t v18 = *v16;
        unint64_t v20 = (char *)*v8++;
        uint64_t v19 = v20;
        while (1)
        {
          uint64_t v21 = 0x2E8BA2E8BA2E8BA3 * ((v19 - v7 + 4048) >> 3);
          if (0x2E8BA2E8BA2E8BA3 * ((4048 - 88 * v17) >> 3) >= v21) {
            uint64_t v22 = v21;
          }
          else {
            uint64_t v22 = 0x2E8BA2E8BA2E8BA3 * ((4048 - 88 * v17) >> 3);
          }
          if (v22) {
            uint64_t result = (const void **)memmove(v7, (const void *)(v18 + 88 * v17), 88 * v22 - 7);
          }
          v17 += v22;
          if (v17 == 46) {
            break;
          }
          uint64_t v23 = (char *)*v8++;
          uint64_t v19 = v23;
          uint64_t v7 = v23;
        }
        v7 += 88 * v22;
        if ((char *)*(v8 - 1) + 4048 != v7) {
          break;
        }
        uint64_t v7 = (char *)*v8;
        *(void *)a5 = v8;
        *(void *)(a5 + 8) = v7;
        uint64_t v16 = v38 + 1;
        if (v38 + 1 == a3) {
          goto LABEL_26;
        }
      }
      *(void *)a5 = --v8;
      *(void *)(a5 + 8) = v7;
      uint64_t v16 = v38 + 1;
    }
    while (v38 + 1 != a3);
  }
LABEL_26:
  uint64_t v24 = *a3;
  if (*a3 != a4)
  {
    uint64_t v26 = (char *)*v8++;
    uint64_t v25 = v26;
    while (1)
    {
      uint64_t v27 = 0x2E8BA2E8BA2E8BA3 * ((v25 - v7 + 4048) >> 3);
      uint64_t v28 = 0x2E8BA2E8BA2E8BA3 * ((a4 - v24) >> 3) >= v27 ? v27 : 0x2E8BA2E8BA2E8BA3 * ((a4 - v24) >> 3);
      if (v28) {
        uint64_t result = (const void **)memmove(v7, v24, 88 * v28 - 7);
      }
      v24 += 88 * v28;
      if (v24 == a4) {
        break;
      }
      uint64_t v29 = (char *)*v8++;
      uint64_t v25 = v29;
      uint64_t v7 = v29;
    }
    v7 += 88 * v28;
    uint64_t v30 = v8 - 1;
    if ((char *)*(v8 - 1) + 4048 != v7)
    {
LABEL_36:
      uint64_t v8 = v30;
      goto LABEL_48;
    }
LABEL_47:
    uint64_t v7 = (char *)*v8;
  }
LABEL_48:
  *(void *)a5 = v8;
  *(void *)(a5 + 8) = v7;
  return result;
}

void *std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F10D6508;
  uint64_t v2 = a1 + 1;
  uint64_t v3 = (void *)a1[4];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
    return a1;
  }
  else
  {
    if (v3) {
      (*(void (**)(void *))(*v3 + 40))(v3);
    }
    return a1;
  }
}

void std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F10D6508;
  uint64_t v1 = a1 + 1;
  uint64_t v2 = (void *)a1[4];
  if (v2 == v1)
  {
    (*(void (**)(void *))(*v1 + 32))(v1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }

  JUMPOUT(0x1BA9BFBA0);
}

char *std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x58uLL);
  *(void *)uint64_t v2 = &unk_1F10D6508;
  uint64_t v3 = v2 + 8;
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4)
  {
    if (v4 == a1 + 8)
    {
      *((void *)v2 + 4) = v3;
      (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
      goto LABEL_6;
    }
    uint64_t v4 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v4 + 16))(v4, v3);
  }
  *((void *)v2 + 4) = v4;
LABEL_6:
  *(_OWORD *)(v2 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(v2 + 56) = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(v2 + 72) = *(_OWORD *)(a1 + 72);
  return v2;
}

void sub_1B77B69E4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

__n128 std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F10D6508;
  uint64_t v4 = a2 + 8;
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5)
  {
    if (v5 == a1 + 8)
    {
      *(void *)(a2 + 32) = v4;
      (*(void (**)(void))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32));
    }
    else
    {
      *(void *)(a2 + 32) = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 16))(v5, v4);
    }
  }
  else
  {
    *(void *)(a2 + 32) = 0;
  }
  __n128 result = *(__n128 *)(a1 + 40);
  long long v7 = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(a2 + 72) = *(_OWORD *)(a1 + 72);
  *(_OWORD *)(a2 + 56) = v7;
  *(__n128 *)(a2 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = result;
  return result;
}

uint64_t std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::destroy(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t result = *(void *)(a1 + 32);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::destroy_deallocate(char *__p)
{
  uint64_t v2 = __p + 8;
  uint64_t v3 = (char *)*((void *)__p + 4);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
    uint64_t v4 = __p;
  }
  else
  {
    if (v3) {
      (*(void (**)(char *))(*(void *)v3 + 40))(v3);
    }
    uint64_t v4 = __p;
  }
  operator delete(v4);
}

BOOL std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 40) == *(void *)(a2 + 16)
      && *(void *)(a1 + 48) == *(void *)(a2 + 24)
      && *(void *)(a1 + 56) == *(void *)(a2 + 32)
      && *(_DWORD *)(a1 + 64) == *(_DWORD *)(a2 + 40)
      && *(void *)(a1 + 72) == *(void *)(a2 + 48)
      && *(_DWORD *)(a1 + 80) == *(_DWORD *)(a2 + 56)
      && *(_DWORD *)(a1 + 84) == *(_DWORD *)(a2 + 60);
}

uint64_t std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "N6HGPool16MatchDescriptionIPU21objcproto10MTLTexture11objc_objectN18HGMetalTexturePool10DescriptorEEE") {
    return a1 + 8;
  }
  if (((v3 & (unint64_t)"N6HGPool16MatchDescriptionIPU21objcproto10MTLTexture11objc_objectN18HGMetalTexturePool10DescriptorEEE" & 0x8000000000000000) != 0) == __OFSUB__(v3, "N6HGPool16MatchDescriptionIPU21objcproto10MTLTexture11objc_objectN18HGMetalTexturePool10DescriptorEEE"))return 0; {
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"N6HGPool16MatchDescriptionIPU21objcproto10MTLTexture11objc_objectN18HGMetalTexturePool10DescriptorEEE" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8;
  }
  return 0;
}

void *std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::target_type()
{
}

void std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x2E;
  unint64_t v4 = v2 - 46;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    unint64_t v6 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    long long v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_80:
      *(void *)uint64_t v5 = v8;
      *(void *)(a1 + 16) += 8;
      return;
    }
    unint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v31 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v31 = 1;
      }
      if (!(v31 >> 61))
      {
        unint64_t v32 = v31 >> 2;
        uint64_t v33 = 8 * v31;
        uint64_t v34 = (char *)operator new(8 * v31);
        unint64_t v35 = &v34[8 * v32];
        uint64_t v36 = &v34[v33];
        int64_t v38 = v5 - v7;
        BOOL v37 = v5 == v7;
        uint64_t v5 = v35;
        if (!v37)
        {
          uint64_t v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            int v74 = &v34[8 * v32];
            unint64_t v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              uint64_t v75 = (v39 >> 3) + 1;
              uint64_t v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              unint64_t v40 = &v35[v76];
              v7 += v76;
              uint64_t v77 = (long long *)(v6 + 3);
              uint64_t v78 = v74 + 16;
              uint64_t v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v80 = *v77;
                *(v78 - 1) = *(v77 - 1);
                *uint64_t v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            unint64_t v40 = &v34[8 * v32];
          }
          do
          {
            uint64_t v81 = *(void *)v7;
            v7 += 8;
            *(void *)unint64_t v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_78;
      }
LABEL_89:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    uint64_t v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      long long v7 = *(char **)(a1 + 8);
    }
    uint64_t v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_80;
  }
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 24);
  uint64_t v19 = *(void *)(a1 + 8);
  uint64_t v20 = v18 - v19;
  uint64_t v21 = (v18 - v19) >> 3;
  uint64_t v22 = v17 - *(void *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      unsigned __int32 v91 = operator new(0xFD0uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    unsigned __int32 v91 = operator new(0xFD0uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    uint64_t v41 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    long long v7 = (char *)(v41 + 1);
    uint64_t v8 = *v41;
    *(void *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24)) {
      goto LABEL_80;
    }
    unint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v42 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v42 = 1;
      }
      if (!(v42 >> 61))
      {
        unint64_t v43 = v42 >> 2;
        uint64_t v44 = 8 * v42;
        uint64_t v34 = (char *)operator new(8 * v42);
        unint64_t v35 = &v34[8 * v43];
        uint64_t v36 = &v34[v44];
        int64_t v45 = v5 - v7;
        BOOL v37 = v5 == v7;
        uint64_t v5 = v35;
        if (!v37)
        {
          uint64_t v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            int32x2_t v82 = &v34[8 * v43];
            unint64_t v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              uint64_t v83 = (v46 >> 3) + 1;
              uint64_t v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              unint64_t v47 = &v35[v84];
              v7 += v84;
              int32x2_t v85 = (long long *)(v41 + 3);
              unsigned int v86 = v82 + 16;
              uint64_t v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v88 = *v85;
                *(v86 - 1) = *(v85 - 1);
                *unsigned int v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            unint64_t v47 = &v34[8 * v43];
          }
          do
          {
            uint64_t v89 = *(void *)v7;
            v7 += 8;
            *(void *)unint64_t v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_78:
        *(void *)a1 = v34;
        *(void *)(a1 + 8) = v35;
        *(void *)(a1 + 16) = v5;
        *(void *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          uint64_t v5 = *(char **)(a1 + 16);
        }
        goto LABEL_80;
      }
      goto LABEL_89;
    }
    goto LABEL_5;
  }
  uint64_t v23 = v22 >> 2;
  if (v17 == *(void *)a1) {
    unint64_t v24 = 1;
  }
  else {
    unint64_t v24 = v23;
  }
  if (v24 >> 61) {
    goto LABEL_89;
  }
  uint64_t v25 = (char *)operator new(8 * v24);
  uint64_t v26 = operator new(0xFD0uLL);
  uint64_t v27 = &v25[8 * v21];
  uint64_t v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    uint64_t v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19) {
        unint64_t v48 = 1;
      }
      else {
        unint64_t v48 = v20 >> 2;
      }
      if (v48 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      float v49 = (char *)operator new(8 * v48);
      uint64_t v27 = &v49[8 * (v48 >> 2)];
      uint64_t v28 = &v49[8 * v48];
      operator delete(v25);
      uint64_t v50 = *(void *)(a1 + 8);
      uint64_t v18 = *(void *)(a1 + 16);
      uint64_t v25 = v49;
      *(void *)uint64_t v27 = v90;
      uint64_t v29 = v27 + 8;
      if (v18 == v50) {
        goto LABEL_45;
      }
    }
    else
    {
      unint64_t v30 = v21 + 2;
      if (v21 >= -1) {
        unint64_t v30 = v21 + 1;
      }
      v27 -= 8 * (v30 >> 1);
      *(void *)uint64_t v27 = v26;
      uint64_t v29 = v27 + 8;
      if (v18 == v19) {
        goto LABEL_45;
      }
    }
    do
    {
LABEL_52:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27) {
            unint64_t v59 = 1;
          }
          else {
            unint64_t v59 = (v28 - v27) >> 2;
          }
          if (v59 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          int v60 = (char *)operator new(8 * v59);
          uint64_t v25 = v60;
          unint64_t v61 = (v59 + 3) >> 2;
          BOOL v53 = &v60[8 * v61];
          int64_t v62 = v29 - v27;
          BOOL v37 = v29 == v27;
          uint64_t v29 = v53;
          if (!v37)
          {
            uint64_t v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v63 = v62 - 8;
            uint64_t v64 = &v60[8 * v61];
            uint64_t v65 = v27;
            if (v63 < 0x38) {
              goto LABEL_93;
            }
            uint64_t v66 = 8 * v61;
            uint64_t v64 = &v60[8 * v61];
            uint64_t v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20) {
              goto LABEL_93;
            }
            uint64_t v67 = (v63 >> 3) + 1;
            uint64_t v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v64 = &v53[v68];
            uint64_t v65 = &v27[v68];
            uint64_t v69 = (long long *)(v27 + 16);
            int v70 = &v60[v66 + 16];
            uint64_t v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v72 = *v69;
              *((_OWORD *)v70 - 1) = *(v69 - 1);
              *(_OWORD *)int v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_93:
              do
              {
                uint64_t v73 = *(void *)v65;
                v65 += 8;
                *(void *)uint64_t v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          uint64_t v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          uint64_t v55 = (v28 - v29) >> 3;
          if (v55 >= -1) {
            unint64_t v56 = v55 + 1;
          }
          else {
            unint64_t v56 = v55 + 2;
          }
          signed int v57 = &v29[8 * (v56 >> 1)];
          BOOL v53 = &v57[-(v29 - v27)];
          size_t v58 = v29 - v27;
          BOOL v37 = v29 == v27;
          uint64_t v29 = v57;
          if (!v37) {
            memmove(v53, v27, v58);
          }
          uint64_t v25 = v27;
        }
      }
      else
      {
        BOOL v53 = v27;
      }
      uint64_t v54 = *(void *)(v18 - 8);
      v18 -= 8;
      *((void *)v53 - 1) = v54;
      float v51 = v53 - 8;
      uint64_t v27 = v51;
    }
    while (v18 != *(void *)(a1 + 8));
    goto LABEL_46;
  }
  *(void *)uint64_t v27 = v26;
  uint64_t v29 = v27 + 8;
  if (v18 != v19) {
    goto LABEL_52;
  }
LABEL_45:
  float v51 = v27;
LABEL_46:
  int v52 = *(char **)a1;
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v51;
  *(void *)(a1 + 16) = v29;
  *(void *)(a1 + 24) = v28;
  if (v52)
  {
    operator delete(v52);
  }
}

void sub_1B77B7244(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B77B7260(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77B7274(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77B728C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,true>::retrieveObject@<X0>(int64x2_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a2;
  uint64_t v15 = 0;
  uint64_t v16 = v5;
  uint64_t v10 = 0;
  uint64_t v11 = v5;
  unint64_t v6 = operator new(0x30uLL);
  *unint64_t v6 = &unk_1F10D6610;
  v6[4] = 0;
  v6[5] = v5;
  uint64_t v13 = v6;
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,true>::_retrieve(a1, v12, a3);
  if (v13 == v12)
  {
    (*(void (**)(void *))(v12[0] + 32))(v12);
    long long v7 = v10;
    if (v10 != v9) {
      goto LABEL_5;
    }
  }
  else
  {
    if (v13) {
      (*(void (**)(void))(*v13 + 40))();
    }
    long long v7 = v10;
    if (v10 != v9)
    {
LABEL_5:
      if (v7) {
        (*(void (**)(void *))(*v7 + 40))(v7);
      }
      uint64_t result = (uint64_t)v15;
      if (v15 != v14) {
        goto LABEL_8;
      }
      return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
    }
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  uint64_t result = (uint64_t)v15;
  if (v15 == v14) {
    return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
  }
LABEL_8:
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
  }
  return result;
}

void sub_1B77B7498(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor> const&)>::~function((uint64_t *)va1);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor> const&)>::~function((uint64_t *)va);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor> const&)>::~function((uint64_t *)va2);
  _Unwind_Resume(a1);
}

void sub_1B77B74BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor> const&)>::~function((uint64_t *)va);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor> const&)>::~function((uint64_t *)va1);
  _Unwind_Resume(a1);
}

uint64_t HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::retrieveObject@<X0>(int64x2_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a2;
  uint64_t v15 = 0;
  uint64_t v16 = v5;
  uint64_t v10 = 0;
  uint64_t v11 = v5;
  uint64_t v6 = operator new(0x30uLL);
  *uint64_t v6 = &unk_1F10D6610;
  v6[4] = 0;
  v6[5] = v5;
  uint64_t v13 = v6;
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,false>::_retrieve(a1, v12, a3);
  if (v13 == v12)
  {
    (*(void (**)(void *))(v12[0] + 32))(v12);
    uint64_t v7 = v10;
    if (v10 != v9) {
      goto LABEL_5;
    }
  }
  else
  {
    if (v13) {
      (*(void (**)(void))(*v13 + 40))();
    }
    uint64_t v7 = v10;
    if (v10 != v9)
    {
LABEL_5:
      if (v7) {
        (*(void (**)(void *))(*v7 + 40))(v7);
      }
      uint64_t result = (uint64_t)v15;
      if (v15 != v14) {
        goto LABEL_8;
      }
      return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
    }
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  uint64_t result = (uint64_t)v15;
  if (v15 == v14) {
    return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
  }
LABEL_8:
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
  }
  return result;
}

void sub_1B77B76CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor> const&)>::~function((uint64_t *)va1);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor> const&)>::~function((uint64_t *)va);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor> const&)>::~function((uint64_t *)va2);
  _Unwind_Resume(a1);
}

void sub_1B77B76F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor> const&)>::~function((uint64_t *)va);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor> const&)>::~function((uint64_t *)va1);
  _Unwind_Resume(a1);
}

void **HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor,true>::_retrieve@<X0>(int64x2_t *a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)(a3 + 28) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(unsigned char *)(a3 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = 1;
  unint64_t v5 = a1[4].u64[0];
  unint64_t v6 = v5 + a1[4].i64[1];
  unint64_t v7 = v6 / 0x2E;
  uint64_t v8 = a1[2].i64[1];
  if (a1[3].i64[0] != v8)
  {
    unint64_t v9 = *(void *)(v8 + 8 * v7) + 88 * (v6 % 0x2E);
    unint64_t v10 = *(void *)(v8 + 8 * (v5 / 0x2E)) + 88 * (v5 % 0x2E);
    uint64_t v11 = (void *)a2[3];
    if (v11) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t v27 = 0;
    goto LABEL_8;
  }
  unint64_t v9 = 0;
  unint64_t v10 = 0;
  uint64_t v11 = (void *)a2[3];
  if (!v11) {
    goto LABEL_6;
  }
LABEL_3:
  if (v11 == a2)
  {
    uint64_t v27 = (void **)v26;
    (*(void (**)(void *, void *))(*a2 + 24))(a2, v26);
  }
  else
  {
    uint64_t v27 = (void **)(*(uint64_t (**)(void *))(*v11 + 16))(v11);
  }
LABEL_8:
  uint64_t v12 = (uint64_t *)(v8 + 8 * v7);
  if (v9 != v10)
  {
    uint64_t v13 = *v12;
    while (1)
    {
      uint64_t v14 = v9;
      if (v9 == v13) {
        uint64_t v14 = *(v12 - 1) + 4048;
      }
      if (!v27) {
        std::__throw_bad_function_call[abi:ne180100]();
      }
      if ((*((uint64_t (**)(void **, uint64_t))*v27 + 6))(v27, v14 - 88)) {
        break;
      }
      uint64_t v13 = *v12;
      if (v9 == *v12)
      {
        uint64_t v15 = *--v12;
        uint64_t v13 = v15;
        unint64_t v9 = v15 + 4048;
      }
      v9 -= 88;
      if (v9 == v10)
      {
        unint64_t v9 = v10;
        break;
      }
    }
  }
  uint64_t result = v27;
  if (v27 == v26)
  {
    uint64_t result = (void **)(*(uint64_t (**)(void *))(v26[0] + 32))(v26);
    uint64_t v17 = a1[2].i64[1];
    if (a1[3].i64[0] != v17) {
      goto LABEL_22;
    }
LABEL_25:
    if (!v9) {
      return result;
    }
    goto LABEL_26;
  }
  if (v27) {
    uint64_t result = (void **)(*((uint64_t (**)(void))*v27 + 5))();
  }
  uint64_t v17 = a1[2].i64[1];
  if (a1[3].i64[0] == v17) {
    goto LABEL_25;
  }
LABEL_22:
  if (v9 == *(void *)(v17 + 8 * (a1[4].i64[0] / 0x2EuLL)) + 88 * (a1[4].i64[0] % 0x2EuLL)) {
    return result;
  }
LABEL_26:
  uint64_t v18 = v9 - *v12;
  uint64_t v19 = 0x2E8BA2E8BA2E8BA3 * (v18 >> 3);
  if (v18 < 89)
  {
    unint64_t v23 = 46 - v19;
    uint64_t v21 = &v12[-(v23 / 0x2E)];
    unint64_t v22 = *v21 + 88 * (46 * (v23 / 0x2E) - v23) + 3960;
  }
  else
  {
    unint64_t v20 = v19 - 1;
    uint64_t v21 = &v12[v20 / 0x2E];
    unint64_t v22 = *v21 + 88 * (v20 % 0x2E);
  }
  long long v24 = *(_OWORD *)(v22 + 48);
  *(_OWORD *)(a3 + 32) = *(_OWORD *)(v22 + 32);
  *(_OWORD *)(a3 + 48) = v24;
  *(_OWORD *)(a3 + 64) = *(_OWORD *)(v22 + 64);
  *(unsigned char *)(a3 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = *(unsigned char *)(v22 + 80);
  long long v25 = *(_OWORD *)(v22 + 16);
  *(_OWORD *)a3 = *(_OWORD *)v22;
  *(_OWORD *)(a3 + 16) = v25;
  atomic_fetch_add(a1[5].i64, 0xFFFFFFFFFFFFFFFFLL);
  atomic_fetch_add(&a1[5].i64[1], -(*(void *)(a3 + 24)* *(void *)(a3 + 16)* HGMetalUtils::bytesPerPixel(*(HGMetalUtils **)(a3 + 32))));
  return std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>>::erase(a1 + 2, v21, (char *)v22);
}

void sub_1B77B7ACC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor> const&)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1B77B7AE0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor> const&)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F10D6610;
  unint64_t v2 = a1 + 1;
  uint64_t v3 = (void *)a1[4];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
    return a1;
  }
  else
  {
    if (v3) {
      (*(void (**)(void *))(*v3 + 40))(v3);
    }
    return a1;
  }
}

void std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F10D6610;
  uint64_t v1 = a1 + 1;
  unint64_t v2 = (void *)a1[4];
  if (v2 == v1)
  {
    (*(void (**)(void *))(*v1 + 32))(v1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }

  JUMPOUT(0x1BA9BFBA0);
}

void *std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::__clone(uint64_t a1)
{
  unint64_t v2 = operator new(0x30uLL);
  *unint64_t v2 = &unk_1F10D6610;
  uint64_t v3 = v2 + 1;
  uint64_t v4 = *(void *)(a1 + 32);
  if (!v4) {
    goto LABEL_4;
  }
  if (v4 != a1 + 8)
  {
    uint64_t v4 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v4 + 16))(v4, v3);
LABEL_4:
    uint64_t v5 = *(void *)(a1 + 40);
    void v2[4] = v4;
    v2[5] = v5;
    return v2;
  }
  void v2[4] = v3;
  (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  v2[5] = *(void *)(a1 + 40);
  return v2;
}

void sub_1B77B7D38(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F10D6610;
  uint64_t v4 = a2 + 1;
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    if (result == a1 + 8)
    {
      a2[4] = v4;
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32));
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void *))(*(void *)result + 16))(result, v4);
      a2[4] = result;
    }
    a2[5] = *(void *)(a1 + 40);
  }
  else
  {
    a2[4] = 0;
    a2[5] = *(void *)(a1 + 40);
  }
  return result;
}

uint64_t std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::destroy(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t result = *(void *)(a1 + 32);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::destroy_deallocate(char *__p)
{
  unint64_t v2 = __p + 8;
  uint64_t v3 = (char *)*((void *)__p + 4);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
    uint64_t v4 = __p;
  }
  else
  {
    if (v3) {
      (*(void (**)(char *))(*(void *)v3 + 40))(v3);
    }
    uint64_t v4 = __p;
  }
  operator delete(v4);
}

BOOL std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::operator()(uint64_t a1, void *a2)
{
  return *a2 == *(void *)(a1 + 40);
}

uint64_t std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "N6HGPool11MatchObjectIPU21objcproto10MTLTexture11objc_objectN18HGMetalTexturePool10DescriptorEEE") {
    return a1 + 8;
  }
  if (((v3 & (unint64_t)"N6HGPool11MatchObjectIPU21objcproto10MTLTexture11objc_objectN18HGMetalTexturePool10DescriptorEEE" & 0x8000000000000000) != 0) == __OFSUB__(v3, "N6HGPool11MatchObjectIPU21objcproto10MTLTexture11objc_objectN18HGMetalTexturePool10DescriptorEEE"))return 0; {
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"N6HGPool11MatchObjectIPU21objcproto10MTLTexture11objc_objectN18HGMetalTexturePool10DescriptorEEE" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8;
  }
  return 0;
}

void *std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTexturePool::Descriptor>,std::allocator<HGMetalTexturePool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTexturePool> const&)>::target_type()
{
}

void std::__shared_ptr_emplace<anonymous namespace'::TextureWrapperAllocator>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10D6698;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<anonymous namespace'::TextureWrapperAllocator>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F10D6698;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<anonymous namespace'::TextureWrapperAllocator>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void anonymous namespace'::TextureWrapperAllocator::~TextureWrapperAllocator(_anonymous_namespace_::TextureWrapperAllocator *this)
{
}

uint64_t anonymous namespace'::TextureWrapperAllocator::allocate()
{
  return 0;
}

void anonymous namespace'::TextureWrapperAllocator::release(uint64_t a1, void *a2)
{
}

void HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::~Pool(uint64_t a1, HGPool::BasePool *a2)
{
  HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::~Pool(a1, a2);

  JUMPOUT(0x1BA9BFBA0);
}

unint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::usedObjectsCount(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 128));
}

unint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::usedTotalUsage(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 136));
}

unint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::freeObjectsCount(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 232));
}

unint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::freeTotalUsage(uint64_t a1)
{
  return atomic_load((unint64_t *)(a1 + 240));
}

void HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::service(uint64_t a1)
{
  unint64_t v2 = (std::mutex *)(a1 + 256);
  std::mutex::lock((std::mutex *)(a1 + 256));
  if (HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::service((int64x2_t *)(a1 + 152), a1))
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
    (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
    kdebug_trace();
  }

  std::mutex::unlock(v2);
}

void sub_1B77B8234(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::trace(std::mutex *a1)
{
  unint64_t v2 = a1 + 4;
  std::mutex::lock(a1 + 4);
  sig = a1 + 5;
  if (a1[5].__m_.__opaque[15] < 0) {
    sig = (std::mutex *)sig->__m_.__sig;
  }
  (*(void (**)(std::mutex *, std::mutex *))(a1->__m_.__sig + 24))(a1, sig);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 16))(a1);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 40))(a1);
  (*(void (**)(std::mutex *))(a1->__m_.__sig + 32))(a1);
  std::mutex::unlock(v2);
}

void sub_1B77B84DC(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B77B84F0(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B77B8504(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B77B8518(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::log(uint64_t a1, const char *a2)
{
  unint64_t v3 = (HGLogger *)(a1 + 344);
  if (*(char *)(a1 + 367) < 0)
  {
    unint64_t v3 = *(HGLogger **)v3;
    if ((int)HGLogger::getLevel(v3, a2) < 2) {
      return;
    }
  }
  else if ((int)HGLogger::getLevel((HGLogger *)(a1 + 344), a2) < 2)
  {
    return;
  }
  std::mutex::lock((std::mutex *)(a1 + 256));
  unsigned __int8 v6 = atomic_load(HGLogger::_enabled);
  if (v6)
  {
    unint64_t v7 = (void *)(a1 + 320);
    if (*(char *)(a1 + 343) < 0) {
      unint64_t v7 = (void *)*v7;
    }
    HGLogger::log(v3, (const char *)2, (HGLogger *)"pool '%s' (%p)\n", v4, v5, v7, a1);
  }
  HGLogger::indent(1);
  unsigned __int8 v10 = atomic_load(HGLogger::_enabled);
  if (v10) {
    HGLogger::log(v3, (const char *)2, (HGLogger *)"live objects:\n", v8, v9);
  }
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,true>::log((void *)(a1 + 48), v3);
  unsigned __int8 v13 = atomic_load(HGLogger::_enabled);
  if (v13) {
    HGLogger::log(v3, (const char *)2, (HGLogger *)"free objects:\n", v11, v12);
  }
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::log((void *)(a1 + 152), v3);
  HGLogger::indent(0xFFFFFFFFLL);

  std::mutex::unlock((std::mutex *)(a1 + 256));
}

void sub_1B77B8658(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::canService(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 372);
}

uint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::canTrace(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 373);
}

uint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::canLog(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 374);
}

int64x2_t *HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::~List(int64x2_t *a1)
{
  while (a1[4].i64[1])
    HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::_pop_front(a1);
  std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>>::~deque[abi:ne180100]((uint64_t)a1[2].i64);
  unint64_t v2 = (std::__shared_weak_count *)a1[1].i64[1];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  unint64_t v3 = (std::__shared_weak_count *)a1->i64[1];
  if (!v3 || atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  return a1;
}

uint64_t HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::_pop_front(int64x2_t *a1)
{
  unint64_t v2 = (long long *)(*(void *)(a1[2].i64[1] + 8 * (a1[4].i64[0] / 0x24uLL)) + 112 * (a1[4].i64[0] % 0x24uLL));
  long long v4 = v2[1];
  long long v3 = v2[2];
  long long v11 = *v2;
  long long v12 = v4;
  long long v13 = v3;
  long long v5 = v2[6];
  long long v7 = v2[3];
  long long v6 = v2[4];
  long long v16 = v2[5];
  long long v17 = v5;
  long long v14 = v7;
  long long v15 = v6;
  atomic_fetch_add(a1[5].i64, 0xFFFFFFFFFFFFFFFFLL);
  atomic_fetch_add(&a1[5].i64[1], -*((void *)&v12 + 1));
  uint64_t v8 = (void **)a1[2].i64[1];
  int64x2_t v9 = vaddq_s64(a1[4], (int64x2_t)xmmword_1B7E73580);
  a1[4] = v9;
  if (v9.i64[0] >= 0x48uLL)
  {
    operator delete(*v8);
    a1[2].i64[1] += 8;
    a1[4].i64[0] -= 36;
  }
  HGPool::EntryEventHandler<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::deleted(&v11);
  kdebug_trace();
  kdebug_trace();
  (*(void (**)(uint64_t, void))(*(void *)a1->i64[0] + 24))(a1->i64[0], v11);
  if (*((void *)&v11 + 1)) {
    (*(void (**)(void))(*(void *)a1->i64[0] + 24))();
  }
  return kdebug_trace();
}

void sub_1B77B8928(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

void HGPool::EntryEventHandler<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::deleted(void *a1)
{
  HGPool::DescriptorString<HGMetalTextureWrapperInfinipool::Descriptor>::str((uint64_t)(a1 + 2));
  unsigned __int8 v4 = atomic_load(HGLogger::_enabled);
  if (v4)
  {
    if (v7 >= 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    HGLogger::log((HGLogger *)"hgpool", (const char *)1, (HGLogger *)"hgpool entry deleted : %p (%s)\n", v2, v3, *a1, p_p);
  }
  if (v7 < 0) {
    operator delete(__p);
  }
}

void sub_1B77B89E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HGPool::DescriptorString<HGMetalTextureWrapperInfinipool::Descriptor>::str(uint64_t a1)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v10);
  unint64_t v2 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, (uint64_t)" x ", 3);
  long long v3 = (void *)std::ostream::operator<<();
  unsigned __int8 v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)", ", 2);
  long long v5 = HGMetalUtils::toString(*(HGMetalUtils **)(a1 + 48));
  size_t v6 = strlen(v5);
  char v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)v5, v6);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)", ptr=", 6);
  std::ostream::operator<<();
  std::stringbuf::str();
  v10[0] = *MEMORY[0x1E4FBA408];
  uint64_t v8 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v10 + *(void *)(v10[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  v10[2] = v8;
  v10[3] = MEMORY[0x1E4FBA470] + 16;
  if (v11 < 0) {
    operator delete((void *)v10[11]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BA9BFAB0](&v12);
}

void sub_1B77B8BD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>>::~deque[abi:ne180100](uint64_t a1)
{
  unint64_t v2 = *(void ***)(a1 + 8);
  long long v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      long long v3 = *(void ***)(a1 + 16);
      unint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 18;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 36;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      char v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t HGPool::Pool<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::~Pool(uint64_t a1, HGPool::BasePool *a2)
{
  *(void *)a1 = &unk_1F10D6740;
  HGPool::unregisterPool((HGPool *)a1, a2);
  if (*(char *)(a1 + 367) < 0)
  {
    operator delete(*(void **)(a1 + 344));
    if ((*(char *)(a1 + 343) & 0x80000000) == 0) {
      goto LABEL_3;
    }
LABEL_16:
    operator delete(*(void **)(a1 + 320));
    goto LABEL_3;
  }
  if (*(char *)(a1 + 343) < 0) {
    goto LABEL_16;
  }
LABEL_3:
  std::mutex::~mutex((std::mutex *)(a1 + 256));
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::~List((int64x2_t *)(a1 + 152));
  std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>>::~deque[abi:ne180100](a1 + 80);
  long long v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  unint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  unint64_t v5 = *(std::__shared_weak_count **)(a1 + 40);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 24);
  if (!v6 || atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
  ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
  std::__shared_weak_count::__release_weak(v6);
  return a1;
}

uint64_t HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::service(int64x2_t *a1, uint64_t a2)
{
  if (!a1[1].i64[0] || !a1[4].i64[1]) {
    return 0;
  }
  uint64_t v4 = 0;
  do
  {
    unint64_t v5 = atomic_load((unint64_t *)&a1[5]);
    if (v5 <= (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1[1].i64[0] + 16))(a1[1].i64[0], a2))
    {
      unint64_t v6 = atomic_load(&a1[5].u64[1]);
      if (v6 <= (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1[1].i64[0] + 24))(a1[1].i64[0], a2))
      {
        unint64_t v7 = a1[4].u64[0];
        uint64_t v8 = *(void *)(a1[2].i64[1] + 8 * (v7 / 0x24));
        unint64_t v9 = std::chrono::steady_clock::now().__d_.__rep_ - *(void *)(v8 + 112 * (v7 % 0x24) + 88);
        if (v9 <= (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1[1].i64[0] + 32))(a1[1].i64[0], a2)) {
          break;
        }
      }
    }
    HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::_pop_front(a1);
    ++v4;
  }
  while (a1[4].i64[1]);
  return v4;
}

void HGPool::EntryTrace<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::trace(uint64_t a1)
{
  HGPool::DescriptorString<HGMetalTextureWrapperInfinipool::Descriptor>::str(a1 + 16);
  if (*(unsigned char *)(a1 + 104))
  {
    if ((v3 & 0x80000000) == 0) {
      return;
    }
LABEL_5:
    operator delete(__p);
    return;
  }
  std::chrono::steady_clock::now();
  if (v3 < 0) {
    goto LABEL_5;
  }
}

void sub_1B77B9094(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,true>::log(void *a1, HGLogger *a2)
{
  if (a1[9])
  {
    HGLogger::indent(1);
    uint64_t v4 = a1[5];
    if (a1[6] != v4)
    {
      unint64_t v5 = a1[8];
      unint64_t v6 = (void *)(v4 + 8 * (v5 / 0x24));
      unint64_t v7 = (long long *)(*v6 + 112 * (v5 % 0x24));
      unint64_t v8 = *(void *)(v4 + 8 * ((a1[9] + v5) / 0x24)) + 112 * ((a1[9] + v5) % 0x24);
      while (v7 != (long long *)v8)
      {
        long long v9 = *v7;
        long long v10 = v7[2];
        long long v22 = v7[1];
        long long v23 = v10;
        *(_OWORD *)std::string __p = v9;
        long long v11 = v7[3];
        long long v12 = v7[4];
        long long v13 = v7[6];
        long long v26 = v7[5];
        long long v27 = v13;
        long long v24 = v11;
        long long v25 = v12;
        HGPool::EntryLog<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::log((uint64_t *)__p, a2, (const char *)3);
        v7 += 7;
        if ((long long *)((char *)v7 - *v6) == (long long *)4032)
        {
          long long v14 = (long long *)v6[1];
          ++v6;
          unint64_t v7 = v14;
        }
      }
    }
    HGLogger::indent(0xFFFFFFFFLL);
    long long v15 = (HGLoggerUtils *)atomic_load(a1 + 11);
    HGLoggerUtils::bytesPrettyString(v15);
    unsigned __int8 v18 = atomic_load(HGLogger::_enabled);
    if (v18)
    {
      if ((SBYTE7(v22) & 0x80u) == 0) {
        uint64_t v19 = __p;
      }
      else {
        uint64_t v19 = (void **)__p[0];
      }
      unint64_t v20 = atomic_load(a1 + 10);
      HGLogger::log(a2, (const char *)2, (HGLogger *)"total : %s (%lu)\n", v16, v17, v19, v20);
    }
    if (SBYTE7(v22) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1B77B922C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::log(void *a1, HGLogger *a2)
{
  if (a1[9])
  {
    HGLogger::indent(1);
    uint64_t v4 = a1[5];
    if (a1[6] != v4)
    {
      unint64_t v5 = a1[8];
      unint64_t v6 = (void *)(v4 + 8 * (v5 / 0x24));
      unint64_t v7 = (long long *)(*v6 + 112 * (v5 % 0x24));
      unint64_t v8 = *(void *)(v4 + 8 * ((a1[9] + v5) / 0x24)) + 112 * ((a1[9] + v5) % 0x24);
      while (v7 != (long long *)v8)
      {
        long long v9 = *v7;
        long long v10 = v7[2];
        long long v22 = v7[1];
        long long v23 = v10;
        *(_OWORD *)std::string __p = v9;
        long long v11 = v7[3];
        long long v12 = v7[4];
        long long v13 = v7[6];
        long long v26 = v7[5];
        long long v27 = v13;
        long long v24 = v11;
        long long v25 = v12;
        HGPool::EntryLog<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::log((uint64_t *)__p, a2, (const char *)3);
        v7 += 7;
        if ((long long *)((char *)v7 - *v6) == (long long *)4032)
        {
          long long v14 = (long long *)v6[1];
          ++v6;
          unint64_t v7 = v14;
        }
      }
    }
    HGLogger::indent(0xFFFFFFFFLL);
    long long v15 = (HGLoggerUtils *)atomic_load(a1 + 11);
    HGLoggerUtils::bytesPrettyString(v15);
    unsigned __int8 v18 = atomic_load(HGLogger::_enabled);
    if (v18)
    {
      if ((SBYTE7(v22) & 0x80u) == 0) {
        uint64_t v19 = __p;
      }
      else {
        uint64_t v19 = (void **)__p[0];
      }
      unint64_t v20 = atomic_load(a1 + 10);
      HGLogger::log(a2, (const char *)2, (HGLogger *)"total : %s (%lu)\n", v16, v17, v19, v20);
    }
    if (SBYTE7(v22) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1B77B93C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void HGPool::EntryLog<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::log(uint64_t *a1, HGLogger *a2, const char *a3)
{
  uint64_t v6 = *a1;
  uint64_t v7 = (uint64_t)(a1 + 2);
  HGLoggerUtils::bytesPrettyString((HGLoggerUtils *)a1[3]);
  HGPool::DescriptorString<HGMetalTextureWrapperInfinipool::Descriptor>::str(v7);
  if (*((unsigned char *)a1 + 104))
  {
    unsigned __int8 v10 = atomic_load(HGLogger::_enabled);
    if (v10)
    {
      long long v11 = v24;
      if (v25 < 0) {
        long long v11 = (void **)v24[0];
      }
      long long v12 = v22;
      if (v23 < 0) {
        long long v12 = (void **)v22[0];
      }
      HGLogger::log(a2, a3, (HGLogger *)"%p %10s  %4lu   %s\n", v8, v9, v6, v11, a1[12], v12);
    }
    goto LABEL_17;
  }
  v13.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  HGLoggerUtils::timePrettyString((HGLoggerUtils *)(v13.__d_.__rep_ - a1[11]));
  unsigned __int8 v16 = atomic_load(HGLogger::_enabled);
  if (v16)
  {
    long long v17 = v24;
    if (v25 < 0) {
      long long v17 = (void **)v24[0];
    }
    p_p = &__p;
    if (v21 < 0) {
      p_p = __p;
    }
    uint64_t v19 = v22;
    if (v23 < 0) {
      uint64_t v19 = (void **)v22[0];
    }
    HGLogger::log(a2, a3, (HGLogger *)"%p %10s  %4lu  %10s   %s\n", v14, v15, v6, v17, a1[12], p_p, v19);
  }
  if ((v21 & 0x80000000) == 0)
  {
LABEL_17:
    if ((v23 & 0x80000000) == 0) {
      goto LABEL_18;
    }
    goto LABEL_21;
  }
  operator delete(__p);
  if ((v23 & 0x80000000) == 0)
  {
LABEL_18:
    if ((v25 & 0x80000000) == 0) {
      return;
    }
LABEL_22:
    operator delete(v24[0]);
    return;
  }
LABEL_21:
  operator delete(v22[0]);
  if (v25 < 0) {
    goto LABEL_22;
  }
}

void sub_1B77B9580(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a19 < 0)
  {
    operator delete(__p);
    if ((a25 & 0x80000000) == 0)
    {
LABEL_3:
      if ((*(char *)(v25 - 49) & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else if ((a25 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a20);
  if ((*(char *)(v25 - 49) & 0x80000000) == 0) {
LABEL_4:
  }
    _Unwind_Resume(exception_object);
LABEL_7:
  operator delete(*(void **)(v25 - 72));
  _Unwind_Resume(exception_object);
}

uint64_t HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::retrieveObject@<X0>(int64x2_t *a1@<X0>, long long *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  long long v6 = a2[3];
  long long v27 = a2[2];
  long long v28 = v6;
  uint64_t v7 = *((void *)a2 + 8);
  long long v24 = 0;
  uint64_t v29 = v7;
  long long v8 = a2[1];
  long long v25 = *a2;
  long long v26 = v8;
  long long v15 = 0;
  long long v18 = v27;
  long long v19 = v6;
  uint64_t v20 = v7;
  long long v17 = v8;
  long long v16 = v25;
  long long v22 = 0;
  long long v9 = (char *)operator new(0x70uLL);
  long long v10 = *a2;
  *(_OWORD *)(v9 + 56) = a2[1];
  long long v11 = a2[3];
  *(_OWORD *)(v9 + 72) = a2[2];
  *(_OWORD *)(v9 + 88) = v11;
  *(void *)long long v9 = &unk_1F10D6868;
  *((void *)v9 + 4) = 0;
  *((void *)v9 + 13) = *((void *)a2 + 8);
  *(_OWORD *)(v9 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = v10;
  long long v22 = v9;
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::_retrieve(a1, v21, a3);
  if (v22 == v21)
  {
    (*(void (**)(void *))(v21[0] + 32))(v21);
    long long v12 = v15;
    if (v15 != v14) {
      goto LABEL_5;
    }
  }
  else
  {
    if (v22) {
      (*(void (**)(void))(*v22 + 40))();
    }
    long long v12 = v15;
    if (v15 != v14)
    {
LABEL_5:
      if (v12) {
        (*(void (**)(void *))(*v12 + 40))(v12);
      }
      uint64_t result = (uint64_t)v24;
      if (v24 != v23) {
        goto LABEL_8;
      }
      return (*(uint64_t (**)(void *))(v23[0] + 32))(v23);
    }
  }
  (*(void (**)(void *))(v14[0] + 32))(v14);
  uint64_t result = (uint64_t)v24;
  if (v24 == v23) {
    return (*(uint64_t (**)(void *))(v23[0] + 32))(v23);
  }
LABEL_8:
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
  }
  return result;
}

void sub_1B77B98FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
}

void sub_1B77B9920(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
}

void **HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::_retrieve@<X0>(int64x2_t *a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  *(void *)(a3 + 96) = 0;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(unsigned char *)(a3 + 104) = 1;
  unint64_t v5 = a1[4].u64[0];
  unint64_t v6 = v5 + a1[4].i64[1];
  unint64_t v7 = v6 / 0x24;
  uint64_t v8 = a1[2].i64[1];
  if (a1[3].i64[0] != v8)
  {
    unint64_t v9 = *(void *)(v8 + 8 * v7) + 112 * (v6 % 0x24);
    unint64_t v10 = *(void *)(v8 + 8 * (v5 / 0x24)) + 112 * (v5 % 0x24);
    long long v11 = (void *)a2[3];
    if (v11) {
      goto LABEL_3;
    }
LABEL_6:
    long long v28 = 0;
    goto LABEL_8;
  }
  unint64_t v9 = 0;
  unint64_t v10 = 0;
  long long v11 = (void *)a2[3];
  if (!v11) {
    goto LABEL_6;
  }
LABEL_3:
  if (v11 == a2)
  {
    long long v28 = (void **)v27;
    (*(void (**)(void *, void *))(*a2 + 24))(a2, v27);
  }
  else
  {
    long long v28 = (void **)(*(uint64_t (**)(void *))(*v11 + 16))(v11);
  }
LABEL_8:
  long long v12 = (uint64_t *)(v8 + 8 * v7);
  if (v9 != v10)
  {
    uint64_t v13 = *v12;
    while (1)
    {
      uint64_t v14 = v9;
      if (v9 == v13) {
        uint64_t v14 = *(v12 - 1) + 4032;
      }
      if (!v28) {
        std::__throw_bad_function_call[abi:ne180100]();
      }
      if ((*((uint64_t (**)(void **, uint64_t))*v28 + 6))(v28, v14 - 112)) {
        break;
      }
      uint64_t v13 = *v12;
      if (v9 == *v12)
      {
        uint64_t v15 = *--v12;
        uint64_t v13 = v15;
        unint64_t v9 = v15 + 4032;
      }
      v9 -= 112;
      if (v9 == v10)
      {
        unint64_t v9 = v10;
        break;
      }
    }
  }
  uint64_t result = v28;
  if (v28 == v27)
  {
    uint64_t result = (void **)(*(uint64_t (**)(void *))(v27[0] + 32))(v27);
    uint64_t v17 = a1[2].i64[1];
    if (a1[3].i64[0] != v17) {
      goto LABEL_22;
    }
LABEL_25:
    if (!v9) {
      return result;
    }
    goto LABEL_26;
  }
  if (v28) {
    uint64_t result = (void **)(*((uint64_t (**)(void))*v28 + 5))();
  }
  uint64_t v17 = a1[2].i64[1];
  if (a1[3].i64[0] == v17) {
    goto LABEL_25;
  }
LABEL_22:
  if (v9 == *(void *)(v17 + 8 * (a1[4].i64[0] / 0x24uLL)) + 112 * (a1[4].i64[0] % 0x24uLL)) {
    return result;
  }
LABEL_26:
  uint64_t v18 = v9 - *v12;
  uint64_t v19 = 0x6DB6DB6DB6DB6DB7 * (v18 >> 4);
  if (v18 < 113)
  {
    unint64_t v23 = 36 - v19;
    char v21 = &v12[-(v23 / 0x24)];
    unint64_t v22 = *v21 + 112 * (36 * (v23 / 0x24) - v23) + 3920;
  }
  else
  {
    unint64_t v20 = v19 - 1;
    char v21 = &v12[v20 / 0x24];
    unint64_t v22 = *v21 + 112 * (v20 % 0x24);
  }
  long long v24 = *(_OWORD *)(v22 + 80);
  *(_OWORD *)(a3 + 64) = *(_OWORD *)(v22 + 64);
  *(_OWORD *)(a3 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = v24;
  *(_OWORD *)(a3 + 89) = *(_OWORD *)(v22 + 89);
  long long v25 = *(_OWORD *)(v22 + 16);
  *(_OWORD *)a3 = *(_OWORD *)v22;
  *(_OWORD *)(a3 + 16) = v25;
  long long v26 = *(_OWORD *)(v22 + 48);
  *(_OWORD *)(a3 + 32) = *(_OWORD *)(v22 + 32);
  *(_OWORD *)(a3 + 48) = v26;
  atomic_fetch_add(a1[5].i64, 0xFFFFFFFFFFFFFFFFLL);
  atomic_fetch_add(&a1[5].i64[1], -*(void *)(a3 + 24));
  return std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>>::erase(a1 + 2, v21, (char *)v22);
}

void sub_1B77B9CD0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1B77B9CE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor> const&)>::~function(void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
    return a1;
  }
  else
  {
    if (v2) {
      (*(void (**)(void *))(*v2 + 40))(v2);
    }
    return a1;
  }
}

void **std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>>::erase(int64x2_t *a1, void *a2, char *a3)
{
  unint64_t v6 = a1[2].u64[0];
  uint64_t v7 = a1->i64[1];
  uint64_t v8 = a1[1].i64[0];
  unint64_t v9 = (const void **)(v7 + 8 * (v6 / 0x24));
  if (v8 != v7)
  {
    unint64_t v10 = (char *)*v9 + 112 * (v6 % 0x24);
    if (a3 != v10) {
      goto LABEL_3;
    }
LABEL_9:
    unint64_t v13 = 0;
    long long v12 = *v9;
    goto LABEL_10;
  }
  unint64_t v10 = 0;
  if (!a3) {
    goto LABEL_9;
  }
LABEL_3:
  uint64_t v11 = 36 * ((const void **)a2 - v9) + 0x6DB6DB6DB6DB6DB7 * ((uint64_t)&a3[-*a2] >> 4);
  long long v12 = *v9;
  unint64_t v13 = v11 - 0x6DB6DB6DB6DB6DB7 * ((v10 - (unsigned char *)*v9) >> 4);
  if (!v13)
  {
LABEL_10:
    char v22 = 1;
    uint64_t v14 = (const void **)(v7 + 8 * (v6 / 0x24));
    uint64_t v15 = (const void **)v10;
    goto LABEL_13;
  }
  if (v11 < 1)
  {
    uint64_t v14 = &v9[-((35 - v11) / 0x24uLL)];
    long long v12 = *v14;
    uint64_t v15 = (const void **)((char *)*v14 + 112 * (36 * ((35 - v11) / 0x24uLL) - (35 - v11)) + 3920);
    uint64_t v16 = a1[2].i64[1];
    if (v13 > (unint64_t)(v16 - 1) >> 1) {
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v14 = &v9[v11 / 0x24uLL];
    long long v12 = *v14;
    uint64_t v15 = (const void **)((char *)*v14 + 112 * (v11 % 0x24uLL));
    uint64_t v16 = a1[2].i64[1];
    if (v13 > (unint64_t)(v16 - 1) >> 1)
    {
LABEL_6:
      uint64_t v17 = (char *)v15 - v12;
      uint64_t v18 = 0x6DB6DB6DB6DB6DB7 * (((char *)v15 - v12) >> 4);
      if (v17 < -111)
      {
        unint64_t v35 = 34 - v18;
        unint64_t v20 = &v14[-(v35 / 0x24)];
        char v21 = (char *)*v20 + 112 * (36 * (v35 / 0x24) - v35) + 3920;
      }
      else
      {
        unint64_t v19 = v18 + 1;
        unint64_t v20 = &v14[v19 / 0x24];
        char v21 = (char *)*v20 + 112 * (v19 % 0x24);
      }
      unint64_t v36 = v16 + v6;
      unint64_t v37 = (v16 + v6) / 0x24;
      int64_t v38 = (const void **)(v7 + 8 * v37);
      if (v8 == v7) {
        unint64_t v39 = 0;
      }
      else {
        unint64_t v39 = (char *)*v38 + 112 * (v36 - 36 * v37);
      }
      v43[0] = v14;
      v43[1] = v15;
      std::__for_each_segment[abi:ne180100]<std::__deque_iterator<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>,HGMetalTextureWrapperInfinipool::Descriptor*,HGMetalTextureWrapperInfinipool::Descriptor&,HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>*,long,36l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>*,HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>*>>(v20, v21, v38, v39, (uint64_t)v43);
      unint64_t v31 = (void **)a1->i64[1];
      unint64_t v40 = (void **)a1[1].i64[0];
      uint64_t v41 = 36 * (v40 - v31) - 1;
      unint64_t v30 = a1[2].u64[0];
      uint64_t v42 = a1[2].i64[1];
      a1[2].i64[1] = v42 - 1;
      if (v40 == v31) {
        uint64_t v41 = 0;
      }
      if (v41 - (v42 + v30) + 1 >= 0x48)
      {
        operator delete(*(v40 - 1));
        char v22 = 0;
        unint64_t v31 = (void **)a1->i64[1];
        a1[1].i64[0] -= 8;
        unint64_t v30 = a1[2].u64[0];
      }
      else
      {
        char v22 = 0;
      }
      goto LABEL_18;
    }
  }
  char v22 = 0;
LABEL_13:
  uint64_t v23 = (char *)v15 - v12;
  uint64_t v24 = 0x6DB6DB6DB6DB6DB7 * (((char *)v15 - v12) >> 4);
  if (v23 < -111)
  {
    unint64_t v28 = 34 - v24;
    long long v26 = &v14[-(v28 / 0x24)];
    long long v27 = (char *)*v26 + 112 * (36 * (v28 / 0x24) - v28) + 3920;
  }
  else
  {
    unint64_t v25 = v24 + 1;
    long long v26 = &v14[v25 / 0x24];
    long long v27 = (char *)*v26 + 112 * (v25 % 0x24);
  }
  std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>,HGMetalTextureWrapperInfinipool::Descriptor*,HGMetalTextureWrapperInfinipool::Descriptor&,HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>*,long,36l>,HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>*,0>(v9, v10, v14, (char *)v15, v26, v27, v43);
  int64x2_t v29 = vaddq_s64(a1[2], (int64x2_t)xmmword_1B7E73580);
  a1[2] = v29;
  unint64_t v30 = v29.i64[0];
  unint64_t v31 = (void **)a1->i64[1];
  if (v29.i64[0] >= 0x48uLL)
  {
    operator delete(*v31);
    unint64_t v31 = (void **)(a1->i64[1] + 8);
    a1->i64[1] = (uint64_t)v31;
    unint64_t v30 = a1[2].i64[0] - 36;
    a1[2].i64[0] = v30;
  }
LABEL_18:
  uint64_t result = &v31[v30 / 0x24];
  if ((void **)a1[1].i64[0] == v31)
  {
    unint64_t v33 = 0;
    if (v22) {
      return result;
    }
  }
  else
  {
    unint64_t v33 = (unint64_t)*result + 112 * (v30 % 0x24);
    if (v22) {
      return result;
    }
  }
  uint64_t v34 = v13 + 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v33 - (void)*result) >> 4);
  if (v34 < 1) {
    result -= (35 - v34) / 0x24uLL;
  }
  else {
    result += v34 / 0x24uLL;
  }
  return result;
}

void *std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>,HGMetalTextureWrapperInfinipool::Descriptor*,HGMetalTextureWrapperInfinipool::Descriptor&,HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>*,long,36l>,HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>*,0>@<X0>(const void **a1@<X1>, char *a2@<X2>, const void **a3@<X3>, char *a4@<X4>, const void **a5@<X5>, char *a6@<X6>, const void ***a7@<X8>)
{
  uint64_t v8 = a5;
  unint64_t v9 = (const void **)a4;
  unint64_t v10 = a3;
  long long v12 = a7;
  if (a1 == a3)
  {
    if (a2 != a4)
    {
      uint64_t v34 = (uint64_t)*a5;
      unint64_t v35 = a4;
      while (1)
      {
        uint64_t v36 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)&a6[-v34] >> 4);
        if (0x6DB6DB6DB6DB6DB7 * ((v35 - a2) >> 4) < v36) {
          uint64_t v36 = 0x6DB6DB6DB6DB6DB7 * ((v35 - a2) >> 4);
        }
        v35 -= 112 * v36;
        a6 -= 112 * v36;
        if (v36) {
          uint64_t result = memmove(a6, v35, 112 * v36 - 7);
        }
        if (v35 == a2) {
          break;
        }
        uint64_t v37 = (uint64_t)*--v8;
        uint64_t v34 = v37;
        a6 = (char *)(v37 + 4032);
      }
      if ((char *)*v8 + 4032 == a6)
      {
        int64_t v38 = (char *)v8[1];
        ++v8;
        a6 = v38;
      }
      unint64_t v10 = a3;
    }
  }
  else
  {
    uint64_t v14 = *a3;
    if (*a3 != a4)
    {
      uint64_t v15 = (uint64_t)*a5;
      uint64_t v16 = a4;
      while (1)
      {
        uint64_t v17 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)&a6[-v15] >> 4);
        if (0x6DB6DB6DB6DB6DB7 * ((v16 - v14) >> 4) < v17) {
          uint64_t v17 = 0x6DB6DB6DB6DB6DB7 * ((v16 - v14) >> 4);
        }
        v16 -= 112 * v17;
        a6 -= 112 * v17;
        if (v17) {
          uint64_t result = memmove(a6, v16, 112 * v17 - 7);
        }
        if (v16 == v14) {
          break;
        }
        uint64_t v19 = (uint64_t)*--v8;
        uint64_t v15 = v19;
        a6 = (char *)(v19 + 4032);
      }
      if ((char *)*v8 + 4032 == a6)
      {
        unint64_t v20 = (char *)v8[1];
        ++v8;
        a6 = v20;
      }
      unint64_t v10 = a3;
    }
    char v21 = v10 - 1;
    if (v10 - 1 != a1)
    {
      char v22 = (char *)*v8;
      do
      {
        while (1)
        {
          uint64_t v23 = *v21;
          uint64_t v24 = (char *)*v21 + 4032;
          while (1)
          {
            uint64_t v25 = 0x6DB6DB6DB6DB6DB7 * ((a6 - v22) >> 4);
            if (0x6DB6DB6DB6DB6DB7 * ((v24 - v23) >> 4) < v25) {
              uint64_t v25 = 0x6DB6DB6DB6DB6DB7 * ((v24 - v23) >> 4);
            }
            v24 -= 112 * v25;
            a6 -= 112 * v25;
            if (v25) {
              uint64_t result = memmove(a6, v24, 112 * v25 - 7);
            }
            if (v24 == v23) {
              break;
            }
            long long v26 = (char *)*--v8;
            char v22 = v26;
            a6 = v26 + 4032;
          }
          char v22 = (char *)*v8;
          if ((char *)*v8 + 4032 == a6) {
            break;
          }
          if (--v21 == a1) {
            goto LABEL_25;
          }
        }
        long long v27 = (char *)v8[1];
        ++v8;
        char v22 = v27;
        a6 = v27;
        --v21;
      }
      while (v21 != a1);
LABEL_25:
      unint64_t v10 = a3;
    }
    unint64_t v28 = (char *)*a1 + 4032;
    unint64_t v9 = (const void **)a4;
    if (v28 != a2)
    {
      uint64_t v29 = (uint64_t)*v8;
      while (1)
      {
        uint64_t v30 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)&a6[-v29] >> 4);
        if (0x6DB6DB6DB6DB6DB7 * ((v28 - a2) >> 4) < v30) {
          uint64_t v30 = 0x6DB6DB6DB6DB6DB7 * ((v28 - a2) >> 4);
        }
        v28 -= 112 * v30;
        a6 -= 112 * v30;
        if (v30) {
          uint64_t result = memmove(a6, v28, 112 * v30 - 7);
        }
        if (v28 == a2) {
          break;
        }
        uint64_t v31 = (uint64_t)*--v8;
        uint64_t v29 = v31;
        a6 = (char *)(v31 + 4032);
      }
      if ((char *)*v8 + 4032 == a6)
      {
        unint64_t v32 = (char *)v8[1];
        ++v8;
        a6 = v32;
      }
    }
    long long v12 = a7;
  }
  unsigned char *v12 = v10;
  v12[1] = v9;
  v12[2] = v8;
  void v12[3] = (const void **)a6;
  return result;
}

const void **std::__for_each_segment[abi:ne180100]<std::__deque_iterator<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>,HGMetalTextureWrapperInfinipool::Descriptor*,HGMetalTextureWrapperInfinipool::Descriptor&,HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>*,long,36l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>*,HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>*>>(const void **result, unsigned char *__src, const void **a3, unsigned char *a4, uint64_t a5)
{
  unint64_t v6 = __src;
  uint64_t v8 = *(void ***)a5;
  uint64_t v7 = *(char **)(a5 + 8);
  if (result == a3)
  {
    if (__src == a4) {
      goto LABEL_48;
    }
    unint64_t v32 = (char *)*v8++;
    uint64_t v31 = v32;
    while (1)
    {
      uint64_t v33 = 0x6DB6DB6DB6DB6DB7 * ((v31 - v7 + 4032) >> 4);
      if (0x6DB6DB6DB6DB6DB7 * ((a4 - v6) >> 4) >= v33) {
        uint64_t v34 = v33;
      }
      else {
        uint64_t v34 = 0x6DB6DB6DB6DB6DB7 * ((a4 - v6) >> 4);
      }
      if (v34) {
        uint64_t result = (const void **)memmove(v7, v6, 112 * v34 - 7);
      }
      v6 += 112 * v34;
      if (v6 == a4) {
        break;
      }
      unint64_t v35 = (char *)*v8++;
      uint64_t v31 = v35;
      uint64_t v7 = v35;
    }
    v7 += 112 * v34;
    uint64_t v30 = v8 - 1;
    if ((char *)*(v8 - 1) + 4032 != v7) {
      goto LABEL_36;
    }
    goto LABEL_47;
  }
  unint64_t v9 = result;
  unint64_t v10 = (char *)*result + 4032;
  if (v10 != __src)
  {
    long long v12 = (char *)*v8++;
    uint64_t v11 = v12;
    while (1)
    {
      uint64_t v13 = 0x6DB6DB6DB6DB6DB7 * ((v11 - v7 + 4032) >> 4);
      if (0x6DB6DB6DB6DB6DB7 * ((v10 - v6) >> 4) >= v13) {
        uint64_t v14 = v13;
      }
      else {
        uint64_t v14 = 0x6DB6DB6DB6DB6DB7 * ((v10 - v6) >> 4);
      }
      if (v14) {
        uint64_t result = (const void **)memmove(v7, v6, 112 * v14 - 7);
      }
      v6 += 112 * v14;
      if (v6 == v10) {
        break;
      }
      uint64_t v15 = (char *)*v8++;
      uint64_t v11 = v15;
      uint64_t v7 = v15;
    }
    v7 += 112 * v14;
    if ((char *)*(v8 - 1) + 4032 == v7)
    {
      uint64_t v7 = (char *)*v8;
      *(void *)a5 = v8;
      *(void *)(a5 + 8) = v7;
      uint64_t v16 = v9 + 1;
      if (v9 + 1 != a3) {
        goto LABEL_16;
      }
      goto LABEL_26;
    }
    --v8;
  }
  *(void *)a5 = v8;
  *(void *)(a5 + 8) = v7;
  uint64_t v16 = v9 + 1;
  if (v9 + 1 != a3)
  {
    do
    {
LABEL_16:
      while (1)
      {
        uint64_t v17 = 0;
        int64_t v38 = v16;
        uint64_t v18 = *v16;
        unint64_t v20 = (char *)*v8++;
        uint64_t v19 = v20;
        while (1)
        {
          uint64_t v21 = 0x6DB6DB6DB6DB6DB7 * ((v19 - v7 + 4032) >> 4);
          if (0x6DB6DB6DB6DB6DB7 * ((4032 - 112 * v17) >> 4) >= v21) {
            uint64_t v22 = v21;
          }
          else {
            uint64_t v22 = 0x6DB6DB6DB6DB6DB7 * ((4032 - 112 * v17) >> 4);
          }
          if (v22) {
            uint64_t result = (const void **)memmove(v7, (const void *)(v18 + 112 * v17), 112 * v22 - 7);
          }
          v17 += v22;
          if (v17 == 36) {
            break;
          }
          uint64_t v23 = (char *)*v8++;
          uint64_t v19 = v23;
          uint64_t v7 = v23;
        }
        v7 += 112 * v22;
        if ((char *)*(v8 - 1) + 4032 != v7) {
          break;
        }
        uint64_t v7 = (char *)*v8;
        *(void *)a5 = v8;
        *(void *)(a5 + 8) = v7;
        uint64_t v16 = v38 + 1;
        if (v38 + 1 == a3) {
          goto LABEL_26;
        }
      }
      *(void *)a5 = --v8;
      *(void *)(a5 + 8) = v7;
      uint64_t v16 = v38 + 1;
    }
    while (v38 + 1 != a3);
  }
LABEL_26:
  uint64_t v24 = *a3;
  if (*a3 != a4)
  {
    long long v26 = (char *)*v8++;
    uint64_t v25 = v26;
    while (1)
    {
      uint64_t v27 = 0x6DB6DB6DB6DB6DB7 * ((v25 - v7 + 4032) >> 4);
      uint64_t v28 = 0x6DB6DB6DB6DB6DB7 * ((a4 - v24) >> 4) >= v27 ? v27 : 0x6DB6DB6DB6DB6DB7 * ((a4 - v24) >> 4);
      if (v28) {
        uint64_t result = (const void **)memmove(v7, v24, 112 * v28 - 7);
      }
      v24 += 112 * v28;
      if (v24 == a4) {
        break;
      }
      uint64_t v29 = (char *)*v8++;
      uint64_t v25 = v29;
      uint64_t v7 = v29;
    }
    v7 += 112 * v28;
    uint64_t v30 = v8 - 1;
    if ((char *)*(v8 - 1) + 4032 != v7)
    {
LABEL_36:
      uint64_t v8 = v30;
      goto LABEL_48;
    }
LABEL_47:
    uint64_t v7 = (char *)*v8;
  }
LABEL_48:
  *(void *)a5 = v8;
  *(void *)(a5 + 8) = v7;
  return result;
}

void *std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>,std::allocator<HGMetalTextureWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTextureWrapperInfinipool> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F10D6868;
  unint64_t v2 = a1 + 1;
  char v3 = (void *)a1[4];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
    return a1;
  }
  else
  {
    if (v3) {
      (*(void (**)(void *))(*v3 + 40))(v3);
    }
    return a1;
  }
}

void std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>,std::allocator<HGMetalTextureWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTextureWrapperInfinipool> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F10D6868;
  uint64_t v1 = a1 + 1;
  unint64_t v2 = (void *)a1[4];
  if (v2 == v1)
  {
    (*(void (**)(void *))(*v1 + 32))(v1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }

  JUMPOUT(0x1BA9BFBA0);
}

char *std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>,std::allocator<HGMetalTextureWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTextureWrapperInfinipool> const&)>::__clone(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x70uLL);
  *(void *)unint64_t v2 = &unk_1F10D6868;
  char v3 = v2 + 8;
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4)
  {
    if (v4 == a1 + 8)
    {
      *((void *)v2 + 4) = v3;
      (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
      goto LABEL_6;
    }
    uint64_t v4 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v4 + 16))(v4, v3);
  }
  *((void *)v2 + 4) = v4;
LABEL_6:
  *(_OWORD *)(v2 + 56) = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(v2 + 72) = *(_OWORD *)(a1 + 72);
  *(_OWORD *)(v2 + 88) = *(_OWORD *)(a1 + 88);
  *((void *)v2 + 13) = *(void *)(a1 + 104);
  *(_OWORD *)(v2 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = *(_OWORD *)(a1 + 40);
  return v2;
}

void sub_1B77BAB28(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

__n128 std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>,std::allocator<HGMetalTextureWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTextureWrapperInfinipool> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F10D6868;
  uint64_t v4 = a2 + 8;
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5)
  {
    if (v5 == a1 + 8)
    {
      *(void *)(a2 + 32) = v4;
      (*(void (**)(void))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32));
    }
    else
    {
      *(void *)(a2 + 32) = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 16))(v5, v4);
    }
  }
  else
  {
    *(void *)(a2 + 32) = 0;
  }
  *(_OWORD *)(a2 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = *(_OWORD *)(a1 + 40);
  __n128 result = *(__n128 *)(a1 + 56);
  long long v7 = *(_OWORD *)(a1 + 72);
  long long v8 = *(_OWORD *)(a1 + 88);
  *(void *)(a2 + 104) = *(void *)(a1 + 104);
  *(_OWORD *)(a2 + 88) = v8;
  *(_OWORD *)(a2 + 72) = v7;
  *(__n128 *)(a2 + 56) = result;
  return result;
}

uint64_t std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>,std::allocator<HGMetalTextureWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTextureWrapperInfinipool> const&)>::destroy(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t result = *(void *)(a1 + 32);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>,std::allocator<HGMetalTextureWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTextureWrapperInfinipool> const&)>::destroy_deallocate(char *__p)
{
  unint64_t v2 = __p + 8;
  char v3 = (char *)*((void *)__p + 4);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
    uint64_t v4 = __p;
  }
  else
  {
    if (v3) {
      (*(void (**)(char *))(*(void *)v3 + 40))(v3);
    }
    uint64_t v4 = __p;
  }
  operator delete(v4);
}

BOOL std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>,std::allocator<HGMetalTextureWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTextureWrapperInfinipool> const&)>::operator()(void *a1, void *a2)
{
  return a1[5] == a2[2] && a1[6] == a2[3] && a1[8] == a2[5] && a1[11] == a2[8] && a1[12] == a2[9] && a1[13] == a2[10];
}

uint64_t std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>,std::allocator<HGMetalTextureWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTextureWrapperInfinipool> const&)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "N6HGPool16MatchDescriptionIPU21objcproto10MTLTexture11objc_objectN31HGMetalTextureWrapperInfinipool10DescriptorEEE") {
    return a1 + 8;
  }
  if (((v3 & (unint64_t)"N6HGPool16MatchDescriptionIPU21objcproto10MTLTexture11objc_objectN31HGMetalTextureWrappe"
                                "rInfinipool10DescriptorEEE" & 0x8000000000000000) != 0) == __OFSUB__(v3, "N6HGPool16MatchDescriptionIPU21objcproto10MTLTexture11objc_objectN31HGMetalTextureWrapperInfinipool10DescriptorEEE"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"N6HGPool16MatchDescriptionIPU21objcproto10MTLTexture11objc_objectN31HGMetalTextureWrapperInfinipool10DescriptorEEE" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8; {
  return 0;
  }
}

void *std::__function::__func<HGPool::MatchDescription<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>,std::allocator<HGMetalTextureWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTextureWrapperInfinipool> const&)>::target_type()
{
}

void HGPool::EntryEventHandler<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::reused(void *a1)
{
  HGPool::DescriptorString<HGMetalTextureWrapperInfinipool::Descriptor>::str((uint64_t)(a1 + 2));
  unsigned __int8 v4 = atomic_load(HGLogger::_enabled);
  if (v4)
  {
    if (v7 >= 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    HGLogger::log((HGLogger *)"hgpool", (const char *)1, (HGLogger *)"hgpool entry reused : %p (%s)\n", v2, v3, *a1, p_p);
  }
  if (v7 < 0) {
    operator delete(__p);
  }
}

void sub_1B77BAEBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void HGPool::EntryEventHandler<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::allocated(void *a1)
{
  HGPool::DescriptorString<HGMetalTextureWrapperInfinipool::Descriptor>::str((uint64_t)(a1 + 2));
  unsigned __int8 v4 = atomic_load(HGLogger::_enabled);
  if (v4)
  {
    if (v7 >= 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    HGLogger::log((HGLogger *)"hgpool", (const char *)1, (HGLogger *)"hgpool entry allocated : %p (%s)\n", v2, v3, *a1, p_p);
  }
  if (v7 < 0) {
    operator delete(__p);
  }
}

void sub_1B77BAF7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x24;
  unint64_t v4 = v2 - 36;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    unint64_t v6 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    char v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_80:
      *(void *)uint64_t v5 = v8;
      *(void *)(a1 + 16) += 8;
      return;
    }
    unint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v31 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v31 = 1;
      }
      if (!(v31 >> 61))
      {
        unint64_t v32 = v31 >> 2;
        uint64_t v33 = 8 * v31;
        uint64_t v34 = (char *)operator new(8 * v31);
        unint64_t v35 = &v34[8 * v32];
        uint64_t v36 = &v34[v33];
        int64_t v38 = v5 - v7;
        BOOL v37 = v5 == v7;
        uint64_t v5 = v35;
        if (!v37)
        {
          uint64_t v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            int v74 = &v34[8 * v32];
            unint64_t v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              uint64_t v75 = (v39 >> 3) + 1;
              uint64_t v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              unint64_t v40 = &v35[v76];
              v7 += v76;
              uint64_t v77 = (long long *)(v6 + 3);
              uint64_t v78 = v74 + 16;
              uint64_t v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v80 = *v77;
                *(v78 - 1) = *(v77 - 1);
                *uint64_t v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            unint64_t v40 = &v34[8 * v32];
          }
          do
          {
            uint64_t v81 = *(void *)v7;
            v7 += 8;
            *(void *)unint64_t v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_78;
      }
LABEL_89:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    uint64_t v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      char v7 = *(char **)(a1 + 8);
    }
    uint64_t v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_80;
  }
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 24);
  uint64_t v19 = *(void *)(a1 + 8);
  uint64_t v20 = v18 - v19;
  uint64_t v21 = (v18 - v19) >> 3;
  uint64_t v22 = v17 - *(void *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      unsigned __int32 v91 = operator new(0xFC0uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    unsigned __int32 v91 = operator new(0xFC0uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    uint64_t v41 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    char v7 = (char *)(v41 + 1);
    uint64_t v8 = *v41;
    *(void *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24)) {
      goto LABEL_80;
    }
    unint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v42 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v42 = 1;
      }
      if (!(v42 >> 61))
      {
        unint64_t v43 = v42 >> 2;
        uint64_t v44 = 8 * v42;
        uint64_t v34 = (char *)operator new(8 * v42);
        unint64_t v35 = &v34[8 * v43];
        uint64_t v36 = &v34[v44];
        int64_t v45 = v5 - v7;
        BOOL v37 = v5 == v7;
        uint64_t v5 = v35;
        if (!v37)
        {
          uint64_t v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            int32x2_t v82 = &v34[8 * v43];
            unint64_t v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              uint64_t v83 = (v46 >> 3) + 1;
              uint64_t v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              unint64_t v47 = &v35[v84];
              v7 += v84;
              int32x2_t v85 = (long long *)(v41 + 3);
              unsigned int v86 = v82 + 16;
              uint64_t v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v88 = *v85;
                *(v86 - 1) = *(v85 - 1);
                *unsigned int v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            unint64_t v47 = &v34[8 * v43];
          }
          do
          {
            uint64_t v89 = *(void *)v7;
            v7 += 8;
            *(void *)unint64_t v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_78:
        *(void *)a1 = v34;
        *(void *)(a1 + 8) = v35;
        *(void *)(a1 + 16) = v5;
        *(void *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          uint64_t v5 = *(char **)(a1 + 16);
        }
        goto LABEL_80;
      }
      goto LABEL_89;
    }
    goto LABEL_5;
  }
  uint64_t v23 = v22 >> 2;
  if (v17 == *(void *)a1) {
    unint64_t v24 = 1;
  }
  else {
    unint64_t v24 = v23;
  }
  if (v24 >> 61) {
    goto LABEL_89;
  }
  uint64_t v25 = (char *)operator new(8 * v24);
  long long v26 = operator new(0xFC0uLL);
  uint64_t v27 = &v25[8 * v21];
  uint64_t v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    uint64_t v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19) {
        unint64_t v48 = 1;
      }
      else {
        unint64_t v48 = v20 >> 2;
      }
      if (v48 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      float v49 = (char *)operator new(8 * v48);
      uint64_t v27 = &v49[8 * (v48 >> 2)];
      uint64_t v28 = &v49[8 * v48];
      operator delete(v25);
      uint64_t v50 = *(void *)(a1 + 8);
      uint64_t v18 = *(void *)(a1 + 16);
      uint64_t v25 = v49;
      *(void *)uint64_t v27 = v90;
      uint64_t v29 = v27 + 8;
      if (v18 == v50) {
        goto LABEL_45;
      }
    }
    else
    {
      unint64_t v30 = v21 + 2;
      if (v21 >= -1) {
        unint64_t v30 = v21 + 1;
      }
      v27 -= 8 * (v30 >> 1);
      *(void *)uint64_t v27 = v26;
      uint64_t v29 = v27 + 8;
      if (v18 == v19) {
        goto LABEL_45;
      }
    }
    do
    {
LABEL_52:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27) {
            unint64_t v59 = 1;
          }
          else {
            unint64_t v59 = (v28 - v27) >> 2;
          }
          if (v59 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          int v60 = (char *)operator new(8 * v59);
          uint64_t v25 = v60;
          unint64_t v61 = (v59 + 3) >> 2;
          BOOL v53 = &v60[8 * v61];
          int64_t v62 = v29 - v27;
          BOOL v37 = v29 == v27;
          uint64_t v29 = v53;
          if (!v37)
          {
            uint64_t v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v63 = v62 - 8;
            uint64_t v64 = &v60[8 * v61];
            uint64_t v65 = v27;
            if (v63 < 0x38) {
              goto LABEL_93;
            }
            uint64_t v66 = 8 * v61;
            uint64_t v64 = &v60[8 * v61];
            uint64_t v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20) {
              goto LABEL_93;
            }
            uint64_t v67 = (v63 >> 3) + 1;
            uint64_t v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v64 = &v53[v68];
            uint64_t v65 = &v27[v68];
            uint64_t v69 = (long long *)(v27 + 16);
            int v70 = &v60[v66 + 16];
            uint64_t v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v72 = *v69;
              *((_OWORD *)v70 - 1) = *(v69 - 1);
              *(_OWORD *)int v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_93:
              do
              {
                uint64_t v73 = *(void *)v65;
                v65 += 8;
                *(void *)uint64_t v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          uint64_t v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          uint64_t v55 = (v28 - v29) >> 3;
          if (v55 >= -1) {
            unint64_t v56 = v55 + 1;
          }
          else {
            unint64_t v56 = v55 + 2;
          }
          signed int v57 = &v29[8 * (v56 >> 1)];
          BOOL v53 = &v57[-(v29 - v27)];
          size_t v58 = v29 - v27;
          BOOL v37 = v29 == v27;
          uint64_t v29 = v57;
          if (!v37) {
            memmove(v53, v27, v58);
          }
          uint64_t v25 = v27;
        }
      }
      else
      {
        BOOL v53 = v27;
      }
      uint64_t v54 = *(void *)(v18 - 8);
      v18 -= 8;
      *((void *)v53 - 1) = v54;
      float v51 = v53 - 8;
      uint64_t v27 = v51;
    }
    while (v18 != *(void *)(a1 + 8));
    goto LABEL_46;
  }
  *(void *)uint64_t v27 = v26;
  uint64_t v29 = v27 + 8;
  if (v18 != v19) {
    goto LABEL_52;
  }
LABEL_45:
  float v51 = v27;
LABEL_46:
  int v52 = *(char **)a1;
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v51;
  *(void *)(a1 + 16) = v29;
  *(void *)(a1 + 24) = v28;
  if (v52)
  {
    operator delete(v52);
  }
}

void sub_1B77BB508(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B77BB524(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77BB538(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77BB550(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,true>::retrieveObject@<X0>(int64x2_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a2;
  uint64_t v15 = 0;
  uint64_t v16 = v5;
  uint64_t v10 = 0;
  uint64_t v11 = v5;
  unint64_t v6 = operator new(0x30uLL);
  *unint64_t v6 = &unk_1F10D6970;
  v6[4] = 0;
  v6[5] = v5;
  uint64_t v13 = v6;
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,true>::_retrieve(a1, v12, a3);
  if (v13 == v12)
  {
    (*(void (**)(void *))(v12[0] + 32))(v12);
    char v7 = v10;
    if (v10 != v9) {
      goto LABEL_5;
    }
  }
  else
  {
    if (v13) {
      (*(void (**)(void))(*v13 + 40))();
    }
    char v7 = v10;
    if (v10 != v9)
    {
LABEL_5:
      if (v7) {
        (*(void (**)(void *))(*v7 + 40))(v7);
      }
      uint64_t result = (uint64_t)v15;
      if (v15 != v14) {
        goto LABEL_8;
      }
      return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
    }
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  uint64_t result = (uint64_t)v15;
  if (v15 == v14) {
    return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
  }
LABEL_8:
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
  }
  return result;
}

void sub_1B77BB75C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va1);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va2);
  _Unwind_Resume(a1);
}

void sub_1B77BB780(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va1);
  _Unwind_Resume(a1);
}

uint64_t HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::retrieveObject@<X0>(int64x2_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a2;
  uint64_t v15 = 0;
  uint64_t v16 = v5;
  uint64_t v10 = 0;
  uint64_t v11 = v5;
  uint64_t v6 = operator new(0x30uLL);
  *uint64_t v6 = &unk_1F10D6970;
  v6[4] = 0;
  v6[5] = v5;
  uint64_t v13 = v6;
  HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,false>::_retrieve(a1, v12, a3);
  if (v13 == v12)
  {
    (*(void (**)(void *))(v12[0] + 32))(v12);
    uint64_t v7 = v10;
    if (v10 != v9) {
      goto LABEL_5;
    }
  }
  else
  {
    if (v13) {
      (*(void (**)(void))(*v13 + 40))();
    }
    uint64_t v7 = v10;
    if (v10 != v9)
    {
LABEL_5:
      if (v7) {
        (*(void (**)(void *))(*v7 + 40))(v7);
      }
      uint64_t result = (uint64_t)v15;
      if (v15 != v14) {
        goto LABEL_8;
      }
      return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
    }
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  uint64_t result = (uint64_t)v15;
  if (v15 == v14) {
    return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
  }
LABEL_8:
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
  }
  return result;
}

void sub_1B77BB990(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va1);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va2);
  _Unwind_Resume(a1);
}

void sub_1B77BB9B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va1);
  _Unwind_Resume(a1);
}

void **HGPool::List<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor,true>::_retrieve@<X0>(int64x2_t *a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  *(void *)(a3 + 96) = 0;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(unsigned char *)(a3 + 104) = 1;
  unint64_t v5 = a1[4].u64[0];
  unint64_t v6 = v5 + a1[4].i64[1];
  unint64_t v7 = v6 / 0x24;
  uint64_t v8 = a1[2].i64[1];
  if (a1[3].i64[0] != v8)
  {
    unint64_t v9 = *(void *)(v8 + 8 * v7) + 112 * (v6 % 0x24);
    unint64_t v10 = *(void *)(v8 + 8 * (v5 / 0x24)) + 112 * (v5 % 0x24);
    uint64_t v11 = (void *)a2[3];
    if (v11) {
      goto LABEL_3;
    }
LABEL_6:
    uint64_t v28 = 0;
    goto LABEL_8;
  }
  unint64_t v9 = 0;
  unint64_t v10 = 0;
  uint64_t v11 = (void *)a2[3];
  if (!v11) {
    goto LABEL_6;
  }
LABEL_3:
  if (v11 == a2)
  {
    uint64_t v28 = (void **)v27;
    (*(void (**)(void *, void *))(*a2 + 24))(a2, v27);
  }
  else
  {
    uint64_t v28 = (void **)(*(uint64_t (**)(void *))(*v11 + 16))(v11);
  }
LABEL_8:
  uint64_t v12 = (uint64_t *)(v8 + 8 * v7);
  if (v9 != v10)
  {
    uint64_t v13 = *v12;
    while (1)
    {
      uint64_t v14 = v9;
      if (v9 == v13) {
        uint64_t v14 = *(v12 - 1) + 4032;
      }
      if (!v28) {
        std::__throw_bad_function_call[abi:ne180100]();
      }
      if ((*((uint64_t (**)(void **, uint64_t))*v28 + 6))(v28, v14 - 112)) {
        break;
      }
      uint64_t v13 = *v12;
      if (v9 == *v12)
      {
        uint64_t v15 = *--v12;
        uint64_t v13 = v15;
        unint64_t v9 = v15 + 4032;
      }
      v9 -= 112;
      if (v9 == v10)
      {
        unint64_t v9 = v10;
        break;
      }
    }
  }
  uint64_t result = v28;
  if (v28 == v27)
  {
    uint64_t result = (void **)(*(uint64_t (**)(void *))(v27[0] + 32))(v27);
    uint64_t v17 = a1[2].i64[1];
    if (a1[3].i64[0] != v17) {
      goto LABEL_22;
    }
LABEL_25:
    if (!v9) {
      return result;
    }
    goto LABEL_26;
  }
  if (v28) {
    uint64_t result = (void **)(*((uint64_t (**)(void))*v28 + 5))();
  }
  uint64_t v17 = a1[2].i64[1];
  if (a1[3].i64[0] == v17) {
    goto LABEL_25;
  }
LABEL_22:
  if (v9 == *(void *)(v17 + 8 * (a1[4].i64[0] / 0x24uLL)) + 112 * (a1[4].i64[0] % 0x24uLL)) {
    return result;
  }
LABEL_26:
  uint64_t v18 = v9 - *v12;
  uint64_t v19 = 0x6DB6DB6DB6DB6DB7 * (v18 >> 4);
  if (v18 < 113)
  {
    unint64_t v23 = 36 - v19;
    uint64_t v21 = &v12[-(v23 / 0x24)];
    unint64_t v22 = *v21 + 112 * (36 * (v23 / 0x24) - v23) + 3920;
  }
  else
  {
    unint64_t v20 = v19 - 1;
    uint64_t v21 = &v12[v20 / 0x24];
    unint64_t v22 = *v21 + 112 * (v20 % 0x24);
  }
  long long v24 = *(_OWORD *)(v22 + 80);
  *(_OWORD *)(a3 + 64) = *(_OWORD *)(v22 + 64);
  *(_OWORD *)(a3 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = v24;
  *(_OWORD *)(a3 + 89) = *(_OWORD *)(v22 + 89);
  long long v25 = *(_OWORD *)(v22 + 16);
  *(_OWORD *)a3 = *(_OWORD *)v22;
  *(_OWORD *)(a3 + 16) = v25;
  long long v26 = *(_OWORD *)(v22 + 48);
  *(_OWORD *)(a3 + 32) = *(_OWORD *)(v22 + 32);
  *(_OWORD *)(a3 + 48) = v26;
  atomic_fetch_add(a1[5].i64, 0xFFFFFFFFFFFFFFFFLL);
  atomic_fetch_add(&a1[5].i64[1], -*(void *)(a3 + 24));
  return std::deque<HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>>::erase(a1 + 2, v21, (char *)v22);
}

void sub_1B77BBD64(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1B77BBD78(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor> const&)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>,std::allocator<HGMetalTextureWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTextureWrapperInfinipool> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F10D6970;
  unint64_t v2 = a1 + 1;
  uint64_t v3 = (void *)a1[4];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
    return a1;
  }
  else
  {
    if (v3) {
      (*(void (**)(void *))(*v3 + 40))(v3);
    }
    return a1;
  }
}

void std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>,std::allocator<HGMetalTextureWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTextureWrapperInfinipool> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F10D6970;
  uint64_t v1 = a1 + 1;
  unint64_t v2 = (void *)a1[4];
  if (v2 == v1)
  {
    (*(void (**)(void *))(*v1 + 32))(v1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }

  JUMPOUT(0x1BA9BFBA0);
}

void *std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>,std::allocator<HGMetalTextureWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTextureWrapperInfinipool> const&)>::__clone(uint64_t a1)
{
  unint64_t v2 = operator new(0x30uLL);
  *unint64_t v2 = &unk_1F10D6970;
  uint64_t v3 = v2 + 1;
  uint64_t v4 = *(void *)(a1 + 32);
  if (!v4) {
    goto LABEL_4;
  }
  if (v4 != a1 + 8)
  {
    uint64_t v4 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v4 + 16))(v4, v3);
LABEL_4:
    uint64_t v5 = *(void *)(a1 + 40);
    void v2[4] = v4;
    v2[5] = v5;
    return v2;
  }
  void v2[4] = v3;
  (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  v2[5] = *(void *)(a1 + 40);
  return v2;
}

void sub_1B77BBFD0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>,std::allocator<HGMetalTextureWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTextureWrapperInfinipool> const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F10D6970;
  uint64_t v4 = a2 + 1;
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    if (result == a1 + 8)
    {
      a2[4] = v4;
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32));
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void *))(*(void *)result + 16))(result, v4);
      a2[4] = result;
    }
    a2[5] = *(void *)(a1 + 40);
  }
  else
  {
    a2[4] = 0;
    a2[5] = *(void *)(a1 + 40);
  }
  return result;
}

uint64_t std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>,std::allocator<HGMetalTextureWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTextureWrapperInfinipool> const&)>::destroy(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t result = *(void *)(a1 + 32);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>,std::allocator<HGMetalTextureWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTextureWrapperInfinipool> const&)>::destroy_deallocate(char *__p)
{
  unint64_t v2 = __p + 8;
  uint64_t v3 = (char *)*((void *)__p + 4);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
    uint64_t v4 = __p;
  }
  else
  {
    if (v3) {
      (*(void (**)(char *))(*(void *)v3 + 40))(v3);
    }
    uint64_t v4 = __p;
  }
  operator delete(v4);
}

BOOL std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>,std::allocator<HGMetalTextureWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTextureWrapperInfinipool> const&)>::operator()(uint64_t a1, void *a2)
{
  return *a2 == *(void *)(a1 + 40);
}

uint64_t std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>,std::allocator<HGMetalTextureWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTextureWrapperInfinipool> const&)>::target(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "N6HGPool11MatchObjectIPU21objcproto10MTLTexture11objc_objectN31HGMetalTextureWrapperInfinipool10DescriptorEEE") {
    return a1 + 8;
  }
  if (((v3 & (unint64_t)"N6HGPool11MatchObjectIPU21objcproto10MTLTexture11objc_objectN31HGMetalTextureWrapperInfi"
                                "nipool10DescriptorEEE" & 0x8000000000000000) != 0) == __OFSUB__(v3, "N6HGPool11MatchObjectIPU21objcproto10MTLTexture11objc_objectN31HGMetalTextureWrapperInfinipool10DescriptorEEE"))return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"N6HGPool11MatchObjectIPU21objcproto10MTLTexture11objc_objectN31HGMetalTextureWrapperInfinipool10DescriptorEEE" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 8; {
  return 0;
  }
}

void *std::__function::__func<HGPool::MatchObject<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>,std::allocator<HGMetalTextureWrapperInfinipool::Descriptor>,BOOL ()(HGPool::Entry<objc_object  {objcproto10MTLTexture},HGMetalTextureWrapperInfinipool> const&)>::target_type()
{
}

void HGPool::EntryEventHandler<objc_object  {objcproto10MTLTexture}*,HGMetalTextureWrapperInfinipool::Descriptor>::recycled(void *a1)
{
  HGPool::DescriptorString<HGMetalTextureWrapperInfinipool::Descriptor>::str((uint64_t)(a1 + 2));
  unsigned __int8 v4 = atomic_load(HGLogger::_enabled);
  if (v4)
  {
    if (v7 >= 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    HGLogger::log((HGLogger *)"hgpool", (const char *)1, (HGLogger *)"hgpool entry recycled : %p (%s)\n", v2, v3, *a1, p_p);
  }
  if (v7 < 0) {
    operator delete(__p);
  }
}

void sub_1B77BC30C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void HGBlur::HGBlur(HGBlur *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v2 = &unk_1F10D69F8;
  *(void *)(v2 + 512) = 0x300000001;
  *(_DWORD *)(v2 + 52CVOpenGLESTextureCacheFlush(this[3], 0) = 1;
  unint64_t v3 = (HGObject *)HGObject::operator new(0x20uLL);
  HGObject::HGObject(v3);
  *(void *)unint64_t v3 = &unk_1F10D6F18;
  *((void *)v3 + 2) = 0;
  *((void *)v3 + 3) = 0;
  *((void *)this + 66) = v3;
  *((void *)this + 52) = 0;
  *((void *)this + 54) = 0;
  *((void *)this + 55) = this;
  *((void *)this + 53) = 0x100000000;
  unsigned __int8 v4 = (void *)HGMalloc(512);
  *((void *)this + 56) = v4;
  void *v4 = 0;
  *(void *)(*((void *)this + 56) + 8) = 0;
  *(void *)(*((void *)this + 56) + 16) = 0;
  *(void *)(*((void *)this + 56) + 24) = 0;
  *(void *)(*((void *)this + 56) + 32) = 0;
  *(void *)(*((void *)this + 56) + 4CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *(void *)(*((void *)this + 56) + 48) = 0;
  *(void *)(*((void *)this + 56) + 56) = 0;
  *(void *)(*((void *)this + 56) + 64) = 0;
  *(void *)(*((void *)this + 56) + 72) = 0;
  *(void *)(*((void *)this + 56) + 8CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *(void *)(*((void *)this + 56) + 88) = 0;
  *(void *)(*((void *)this + 56) + 96) = 0;
  *(void *)(*((void *)this + 56) + 104) = 0;
  *(void *)(*((void *)this + 56) + 112) = 0;
  *(void *)(*((void *)this + 56) + 12CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *(void *)(*((void *)this + 56) + 128) = 0;
  *(void *)(*((void *)this + 56) + 136) = 0;
  *(void *)(*((void *)this + 56) + 144) = 0;
  *(void *)(*((void *)this + 56) + 152) = 0;
  *(void *)(*((void *)this + 56) + 16CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *(void *)(*((void *)this + 56) + 168) = 0;
  *(void *)(*((void *)this + 56) + 176) = 0;
  *(void *)(*((void *)this + 56) + 184) = 0;
  *(void *)(*((void *)this + 56) + 192) = 0;
  *(void *)(*((void *)this + 56) + 20CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *(void *)(*((void *)this + 56) + 208) = 0;
  *(void *)(*((void *)this + 56) + 216) = 0;
  *(void *)(*((void *)this + 56) + 224) = 0;
  *(void *)(*((void *)this + 56) + 232) = 0;
  *(void *)(*((void *)this + 56) + 24CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *(void *)(*((void *)this + 56) + 248) = 0;
  *(void *)(*((void *)this + 56) + 256) = 0;
  *(void *)(*((void *)this + 56) + 264) = 0;
  *(void *)(*((void *)this + 56) + 272) = 0;
  *(void *)(*((void *)this + 56) + 28CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *(void *)(*((void *)this + 56) + 288) = 0;
  *(void *)(*((void *)this + 56) + 296) = 0;
  *(void *)(*((void *)this + 56) + 304) = 0;
  *(void *)(*((void *)this + 56) + 312) = 0;
  *(void *)(*((void *)this + 56) + 32CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *(void *)(*((void *)this + 56) + 328) = 0;
  *(void *)(*((void *)this + 56) + 336) = 0;
  *(void *)(*((void *)this + 56) + 344) = 0;
  *(void *)(*((void *)this + 56) + 352) = 0;
  *(void *)(*((void *)this + 56) + 36CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *(void *)(*((void *)this + 56) + 368) = 0;
  *(void *)(*((void *)this + 56) + 376) = 0;
  *(void *)(*((void *)this + 56) + 384) = 0;
  *(void *)(*((void *)this + 56) + 392) = 0;
  *(void *)(*((void *)this + 56) + 40CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *(void *)(*((void *)this + 56) + 408) = 0;
  *(void *)(*((void *)this + 56) + 416) = 0;
  *(void *)(*((void *)this + 56) + 424) = 0;
  *(void *)(*((void *)this + 56) + 432) = 0;
  *(void *)(*((void *)this + 56) + 44CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *(void *)(*((void *)this + 56) + 448) = 0;
  *(void *)(*((void *)this + 56) + 456) = 0;
  *(void *)(*((void *)this + 56) + 464) = 0;
  *(void *)(*((void *)this + 56) + 472) = 0;
  *(void *)(*((void *)this + 56) + 48CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *(void *)(*((void *)this + 56) + 488) = 0;
  *(void *)(*((void *)this + 56) + 496) = 0;
  *(void *)(*((void *)this + 56) + 504) = 0;
  *((_DWORD *)this + 125) = 1;
  *((unsigned char *)this + 488) = 0;
  *((void *)this + 63) = 3;
  *(void *)((char *)this + 492) = 0x3F8000003F800000;
}

void sub_1B77BC5F4(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 528);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  HGNode::~HGNode((HGNode *)v1);
  _Unwind_Resume(a1);
}

void HGBlur::~HGBlur(HGBlur *this)
{
  uint64_t v2 = 0;
  *(void *)this = &unk_1F10D69F8;
  do
  {
    uint64_t v3 = *(void *)(*((void *)this + 56) + v2);
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
    }
    v2 += 8;
  }
  while (v2 != 512);
  HGFree(*((void *)this + 56));
  uint64_t v4 = *((void *)this + 66);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }

  HGNode::~HGNode((HGNode *)this);
}

{
  void *v1;
  uint64_t vars8;

  HGBlur::~HGBlur(this);

  HGObject::operator delete(v1);
}

uint64_t HGBlur::SetParameter(HGBlur *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 == 2)
  {
    int v10 = a3 != 0.0;
    int v11 = (int)a4;
    int v12 = (int)a5;
    if ((int)a4)
    {
      if (v12) {
        goto LABEL_13;
      }
    }
    else
    {
      int v11 = *((_DWORD *)this + 128);
      if (v12)
      {
LABEL_13:
        if (*((unsigned __int8 *)this + 488) != v10) {
          goto LABEL_21;
        }
LABEL_18:
        if (*((_DWORD *)this + 125) == v11 && *((_DWORD *)this + 126) == v12) {
          return 0;
        }
LABEL_21:
        *((unsigned char *)this + 488) = v10;
        *((_DWORD *)this + 125) = v11;
        *((_DWORD *)this + 126) = v12;
        goto LABEL_22;
      }
    }
    int v12 = *((_DWORD *)this + 129);
    if (*((unsigned __int8 *)this + 488) != v10) {
      goto LABEL_21;
    }
    goto LABEL_18;
  }
  if (a2 == 1)
  {
    int v7 = *((_DWORD *)this + 130);
    int v8 = (int)a4;
    if (a3 == 0.0) {
      int v8 = 0;
    }
    *((_DWORD *)this + 13CVOpenGLESTextureCacheFlush(this[3], 0) = v8;
    if (v7 == v8) {
      return 0;
    }
    goto LABEL_22;
  }
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  if (*((float *)this + 104) == a3 && *((float *)this + 105) == a4) {
    return 0;
  }
  *((float *)this + 104) = a3;
  *((float *)this + 105) = a4;
LABEL_22:
  *((_DWORD *)this + 107) = 1;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HGBlur::ComputeDecimation(uint64_t this, int a2)
{
  float v2 = 41.0;
  if (*(_DWORD *)(this + 424)) {
    float v2 = 25.0;
  }
  float v3 = *(float *)(this + 416) * *(float *)(this + 416);
  float v4 = fmaxf(v2 + -5.0, 0.0);
  if (a2) {
    float v5 = v4;
  }
  else {
    float v5 = v2;
  }
  if (v3 <= v5)
  {
    unsigned int v9 = 0;
    float v7 = 1.0;
  }
  else
  {
    unsigned int v6 = 0;
    float v7 = 1.0;
    if (a2)
    {
      float v8 = v4;
      do
      {
        unsigned int v9 = v6 + 1;
        float v3 = v3 - v8;
        float v7 = v7 * 4.0;
        float v8 = fmaxf((float)(v2 * v7) + -5.0, 0.0);
      }
      while (v3 > v8 && v6++ < 0xE);
    }
    else
    {
      float v11 = v2;
      do
      {
        unsigned int v9 = v6 + 1;
        float v3 = v3 - v11;
        float v7 = v7 * 4.0;
        float v11 = v2 * v7;
      }
      while (v3 > (float)(v2 * v7) && v6++ < 0xE);
    }
  }
  float v13 = v3 / v7;
  if ((float)(v3 / v7) < 25.0) {
    float v14 = 0.0;
  }
  else {
    float v14 = v7 * 25.0;
  }
  float v15 = v3 - v14;
  float v16 = v15;
  if (v15 > 0.0)
  {
    float v16 = sqrtf(v15 / v7);
    if (v16 > 5.0) {
      float v16 = 5.0;
    }
  }
  *(float *)(this + 468) = v16;
  *(_DWORD *)(this + 456) = v9;
  *(_DWORD *)(this + 46CVOpenGLESTextureCacheFlush(this[3], 0) = v13 >= 25.0;
  *(_DWORD *)(this + 464) = v15 > 0.0;
  float v17 = *(float *)(this + 420) * *(float *)(this + 420);
  if (v17 <= v5)
  {
    unsigned int v20 = 0;
    float v19 = 1.0;
  }
  else
  {
    unsigned int v18 = 0;
    float v19 = 1.0;
    if (a2)
    {
      do
      {
        unsigned int v20 = v18 + 1;
        float v17 = v17 - v4;
        float v19 = v19 * 4.0;
        float v4 = fmaxf((float)(v2 * v19) + -5.0, 0.0);
      }
      while (v17 > v4 && v18++ < 0xE);
    }
    else
    {
      float v22 = v2;
      do
      {
        unsigned int v20 = v18 + 1;
        float v17 = v17 - v22;
        float v19 = v19 * 4.0;
        float v22 = v2 * v19;
      }
      while (v17 > (float)(v2 * v19) && v18++ < 0xE);
    }
  }
  float v24 = v17 / v19;
  float v25 = v19 * 25.0;
  if ((float)(v17 / v19) < 25.0) {
    float v25 = 0.0;
  }
  float v26 = v17 - v25;
  float v27 = v26;
  if (v26 > 0.0)
  {
    float v28 = sqrtf(v26 / v19);
    float v27 = 5.0;
    if (v28 <= 5.0) {
      float v27 = v28;
    }
  }
  *(float *)(this + 484) = v27;
  *(_DWORD *)(this + 472) = v20;
  *(_DWORD *)(this + 476) = v24 >= 25.0;
  *(_DWORD *)(this + 48CVOpenGLESTextureCacheFlush(this[3], 0) = v26 > 0.0;
  return this;
}

float HGBlur::GetDecimation(HGBlur *this, float a2)
{
  float result = a2 * a2;
  int v3 = 0;
  if (result >= 25.0)
  {
    float v4 = 1.0;
    float v5 = 25.0;
    do
    {
      ++v3;
      float result = result - v5;
      float v4 = v4 * 4.0;
      float v5 = v4 * 25.0;
    }
    while (result >= (float)(v4 * 25.0));
  }
  return result;
}

HGNode *HGBlur::fastDecimateDown(HGBlur *this, HGNode *a2)
{
  if (a2) {
    (*(void (**)(HGNode *))(*(void *)a2 + 16))(a2);
  }
  float v4 = (const float *)((char *)this + 500);
  float v5 = (const float *)((char *)this + 504);
  v6.i32[0] = *((_DWORD *)this + 118);
  v6.i32[1] = *((_DWORD *)this + 114);
  int32x2_t v7 = (int32x2_t)vld1_dup_f32(v5);
  int32x2_t v8 = vmin_s32(v6, v7);
  int32x2_t v9 = (int32x2_t)vld1_dup_f32(v4);
  int32x2_t v10 = vmax_s32(v9, v8);
  __int32 v11 = v10.i32[1];
  int v12 = v10.i32[0];
  if (v10.i32[1] <= v10.i32[0]) {
    int v13 = v10.i32[0];
  }
  else {
    int v13 = v10.i32[1];
  }
  *((_DWORD *)this + 127) = v13;
  float v14 = a2;
  if (v13 >= 1)
  {
    int32x2_t v32 = v10;
    *((float *)this + 123) = exp2f(-(float)v10.i32[1]);
    *((float *)this + 124) = exp2f(-(float)v12);
    uint64_t v15 = *((void *)this + 66);
    float v16 = *(HGNode **)(v15 + 16);
    if (v16 != a2)
    {
      if (v16) {
        (*(void (**)(HGNode *))(*(void *)v16 + 24))(v16);
      }
      *(void *)(v15 + 16) = a2;
      if (a2) {
        (*(void (**)(HGNode *))(*(void *)a2 + 16))(a2);
      }
    }
    HGTransform::HGTransform((HGTransform *)v33);
    double v17 = 0.5;
    if (v11) {
      double v18 = 0.5;
    }
    else {
      double v18 = 1.0;
    }
    if (!v12) {
      double v17 = 1.0;
    }
    HGTransform::Scale((HGTransform *)v33, v18, v17, 1.0);
    float v19 = (HGXForm *)HGObject::operator new(0x210uLL);
    HGXForm::HGXForm(v19);
    (*(void (**)(HGXForm *, void, void))(*(void *)v19 + 120))(v19, 0, *(void *)(*((void *)this + 66) + 16));
    (*(void (**)(HGXForm *, unsigned char *))(*(void *)v19 + 576))(v19, v33);
    (*(void (**)(HGXForm *, void, double))(*(void *)v19 + 592))(v19, 0, 0.0);
    (*(void (**)(HGXForm *, uint64_t, float, double, double, double))(*(void *)v19 + 96))(v19, 1, 27.0, 0.0, 0.0, 0.0);
    (*(void (**)(HGXForm *))(*(void *)v19 + 16))(v19);
    uint64_t v20 = *((void *)this + 66);
    uint64_t v21 = *(HGXForm **)(v20 + 16);
    if (v21 == v19)
    {
      (*(void (**)(HGXForm *))(*(void *)v19 + 24))(v19);
    }
    else
    {
      if (v21) {
        (*(void (**)(HGXForm *))(*(void *)v21 + 24))(v21);
      }
      *(void *)(v20 + 16) = v19;
    }
    (*(void (**)(HGXForm *))(*(void *)v19 + 24))(v19);
    HGTransform::~HGTransform((HGTransform *)v33);
    if (*((int *)this + 127) >= 2)
    {
      int32x2_t v22 = vmax_s32(v32, (int32x2_t)0x100000001);
      int v23 = 1;
      do
      {
        HGTransform::HGTransform((HGTransform *)v33);
        int32x2_t v24 = vadd_s32(v22, (int32x2_t)-1);
        int32x2_t v25 = vceqz_s32(v24);
        if (v25.i8[4]) {
          double v26 = 1.0;
        }
        else {
          double v26 = 0.5;
        }
        if (v25.i8[0]) {
          double v27 = 1.0;
        }
        else {
          double v27 = 0.5;
        }
        HGTransform::Scale((HGTransform *)v33, v26, v27, 1.0);
        float v28 = (HGXForm *)HGObject::operator new(0x210uLL);
        HGXForm::HGXForm(v28);
        (*(void (**)(HGXForm *, void, void))(*(void *)v28 + 120))(v28, 0, *(void *)(*((void *)this + 66) + 16));
        (*(void (**)(HGXForm *, unsigned char *))(*(void *)v28 + 576))(v28, v33);
        (*(void (**)(HGXForm *, void, double))(*(void *)v28 + 592))(v28, 0, 0.0);
        (*(void (**)(HGXForm *, uint64_t, float, double, double, double))(*(void *)v28 + 96))(v28, 1, 27.0, 0.0, 0.0, 0.0);
        (*(void (**)(HGXForm *, void, uint64_t))(*(void *)v28 + 136))(v28, 0, 32);
        (*(void (**)(HGXForm *))(*(void *)v28 + 16))(v28);
        uint64_t v29 = *((void *)this + 66);
        unint64_t v30 = *(HGXForm **)(v29 + 16);
        if (v30 == v28)
        {
          (*(void (**)(HGXForm *))(*(void *)v28 + 24))(v28);
        }
        else
        {
          if (v30) {
            (*(void (**)(HGXForm *))(*(void *)v30 + 24))(v30);
          }
          *(void *)(v29 + 16) = v28;
        }
        (*(void (**)(HGXForm *))(*(void *)v28 + 24))(v28);
        int32x2_t v22 = vmax_s32(v24, (int32x2_t)0x100000001);
        HGTransform::~HGTransform((HGTransform *)v33);
        ++v23;
      }
      while (v23 < *((_DWORD *)this + 127));
    }
    *((float32x2_t *)this + 52) = vmul_f32(*(float32x2_t *)((char *)this + 416), *(float32x2_t *)((char *)this + 492));
    float v14 = *(HGNode **)(*((void *)this + 66) + 16);
  }
  if (a2) {
    (*(void (**)(HGNode *))(*(void *)a2 + 24))(a2);
  }
  return v14;
}

void sub_1B77BD090(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  HGTransform::~HGTransform((HGTransform *)va);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  _Unwind_Resume(a1);
}

HGNode *HGBlur::fastDecimateUp(HGBlur *this, HGNode *a2)
{
  if (*((float *)this + 123) == 1.0 && *((float *)this + 124) == 1.0) {
    return a2;
  }
  if (a2) {
    (*(void (**)(HGNode *))(*(void *)a2 + 16))(a2);
  }
  HGTransform::HGTransform((HGTransform *)v9);
  float v5 = (HGXForm *)HGObject::operator new(0x210uLL);
  HGXForm::HGXForm(v5);
  HGTransform::Scale((HGTransform *)v9, 1.0 / *((float *)this + 123), 1.0 / *((float *)this + 124), 1.0);
  (*(void (**)(HGXForm *, void, HGNode *))(*(void *)v5 + 120))(v5, 0, a2);
  (*(void (**)(HGXForm *, unsigned char *))(*(void *)v5 + 576))(v5, v9);
  (*(void (**)(HGXForm *))(*(void *)v5 + 16))(v5);
  uint64_t v6 = *((void *)this + 66);
  int32x2_t v7 = *(HGXForm **)(v6 + 24);
  if (v7 == v5)
  {
    (*(void (**)(HGXForm *))(*(void *)v5 + 24))(v5);
  }
  else
  {
    if (v7) {
      (*(void (**)(HGXForm *))(*(void *)v7 + 24))(v7);
    }
    *(void *)(v6 + 24) = v5;
  }
  uint64_t v4 = *(void *)(*((void *)this + 66) + 24);
  (*(void (**)(HGXForm *))(*(void *)v5 + 24))(v5);
  HGTransform::~HGTransform((HGTransform *)v9);
  if (a2) {
    (*(void (**)(HGNode *))(*(void *)a2 + 24))(a2);
  }
  return (HGNode *)v4;
}

void sub_1B77BD3B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  HGTransform::~HGTransform((HGTransform *)&a9);
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
  }
  _Unwind_Resume(a1);
}

void HGBlur::CreateDownShaderHorz(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a2 + 128))(a2, 43) == 1)
  {
    uint64_t v3 = (HgcBlur_cs9s_rect *)HGObject::operator new(0x1C0uLL);
    HGG9X<HgcBlur_cs9s_rect>::HGG9X(v3);
  }
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a2 + 128))(a2, 46))
  {
    uint64_t v4 = (HgcBlur_cs9s_rect *)HGObject::operator new(0x1C0uLL);
    HGG9X<HgcBlur_cs9s_rect>::HGG9X(v4);
  }
  int v5 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 128))(a2, 21);
  uint64_t v6 = (HgcBlur_cs9s *)HGObject::operator new(0x1C0uLL);
  if (v5) {
    HGG9X<HgcBlur_cs9s>::HGG9X(v6);
  }
  HGG9X<HgcBlur_cs9s_es_noborder>::HGG9X(v6);
}

void sub_1B77BD5AC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77BD5C0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77BD5D4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77BD5E8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HGBlur::CreateDownShaderVert(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a2 + 128))(a2, 43) == 1)
  {
    uint64_t v3 = (HgcBlur_cs9s_rect *)HGObject::operator new(0x1C0uLL);
    HGG9X<HgcBlur_cs9s_rect>::HGG9X(v3);
  }
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a2 + 128))(a2, 46))
  {
    uint64_t v4 = (HgcBlur_cs9s_rect *)HGObject::operator new(0x1C0uLL);
    HGG9X<HgcBlur_cs9s_rect>::HGG9X(v4);
  }
  int v5 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 128))(a2, 21);
  uint64_t v6 = (HgcBlur_cs9s *)HGObject::operator new(0x1C0uLL);
  if (v5) {
    HGG9X<HgcBlur_cs9s>::HGG9X(v6);
  }
  HGG9X<HgcBlur_cs9s_es_noborder>::HGG9X(v6);
}

void sub_1B77BDA0C(_Unwind_Exception *a1)
{
  HgcBlur_cs9s_es_noborder::~HgcBlur_cs9s_es_noborder(v1);
  HGObject::operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1B77BDA58(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77BDA70(_Unwind_Exception *a1)
{
  HgcBlur_cs9s_rect::~HgcBlur_cs9s_rect(v1);
  HGObject::operator delete(v3);
  _Unwind_Resume(a1);
}

void HGBlur::CreateDownShaderDoubleHorz(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a2 + 128))(a2, 43) == 1)
  {
    uint64_t v3 = (HgcBlur_cs9s_rect *)HGObject::operator new(0x1C0uLL);
    HGG9X<HgcBlur_cs9s_rect>::HGG9X(v3);
  }
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a2 + 128))(a2, 46))
  {
    uint64_t v4 = (HgcBlur_cs9s_rect *)HGObject::operator new(0x1C0uLL);
    HGG9X<HgcBlur_cs9s_rect>::HGG9X(v4);
  }
  int v5 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 128))(a2, 21);
  uint64_t v6 = (HgcBlur_cs9s *)HGObject::operator new(0x1C0uLL);
  if (v5) {
    HGG9X<HgcBlur_cs9s>::HGG9X(v6);
  }
  HGG9X<HgcBlur_cs9s_es_noborder>::HGG9X(v6);
}

void sub_1B77BDCA8(_Unwind_Exception *a1)
{
  HgcBlur_cs9s_es_noborder::~HgcBlur_cs9s_es_noborder(v1);
  HGObject::operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1B77BDCC0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77BDCD4(_Unwind_Exception *a1)
{
  HgcBlur_cs9s::~HgcBlur_cs9s(v1);
  HGObject::operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1B77BDCEC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77BDD00(_Unwind_Exception *a1)
{
  HgcBlur_cs9s_rect::~HgcBlur_cs9s_rect(v1);
  HGObject::operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1B77BDD30(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HGBlur::CreateDownShaderDoubleVert(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a2 + 128))(a2, 43) == 1)
  {
    uint64_t v3 = (HgcBlur_cs9s_rect *)HGObject::operator new(0x1C0uLL);
    HGG9D2Y<HgcBlur_cs9s_rect>::HGG9D2Y(v3);
  }
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a2 + 128))(a2, 46))
  {
    uint64_t v4 = (HgcBlur_cs9s_rect *)HGObject::operator new(0x1C0uLL);
    HGG9D2Y<HgcBlur_cs9s_rect>::HGG9D2Y(v4);
  }
  int v5 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 128))(a2, 21);
  uint64_t v6 = (HgcBlur_cs9s *)HGObject::operator new(0x1C0uLL);
  if (v5) {
    HGG9D2Y<HgcBlur_cs9s>::HGG9D2Y(v6);
  }
  HGG9D2Y<HgcBlur_cs9s_es_noborder>::HGG9D2Y(v6);
}

void sub_1B77BDE64(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77BDE78(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77BDE8C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77BDEA0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HGBlur::CreateUpShaderHorz(HGBlur *this, HGRenderer *a2)
{
  if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 43) == 1)
  {
    uint64_t v3 = (HgcBlur_g4u2_rect *)HGObject::operator new(0x1C0uLL);
    HGG4U2X<HgcBlur_g4u2_rect>::HGG4U2X(v3);
  }
  if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  {
    uint64_t v4 = (HgcBlur_g4u2_rect *)HGObject::operator new(0x1C0uLL);
    HGG4U2X<HgcBlur_g4u2_rect>::HGG4U2X(v4);
  }
  int v5 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 21);
  uint64_t v6 = (HgcBlur_g4u2 *)HGObject::operator new(0x1C0uLL);
  if (v5) {
    HGG4U2X<HgcBlur_g4u2>::HGG4U2X(v6);
  }
  HGG4U2X<HgcBlur_g4u2_noborder>::HGG4U2X(v6);
}

void sub_1B77BDFB8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77BDFCC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77BDFE0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77BDFF4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HGBlur::CreateUpShaderVet(HGBlur *this, HGRenderer *a2)
{
  if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 43) == 1)
  {
    uint64_t v3 = (HgcBlur_g4u2_rect *)HGObject::operator new(0x1C0uLL);
    HGG4U2Y<HgcBlur_g4u2_rect>::HGG4U2Y(v3);
  }
  if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  {
    uint64_t v4 = (HgcBlur_g4u2_rect *)HGObject::operator new(0x1C0uLL);
    HGG4U2Y<HgcBlur_g4u2_rect>::HGG4U2Y(v4);
  }
  int v5 = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 21);
  uint64_t v6 = (HgcBlur_g4u2 *)HGObject::operator new(0x1C0uLL);
  if (v5) {
    HGG4U2Y<HgcBlur_g4u2>::HGG4U2Y(v6);
  }
  HGG4U2Y<HgcBlur_g4u2_noborder>::HGG4U2Y(v6);
}

void sub_1B77BE10C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77BE120(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77BE134(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77BE148(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

BOOL HGG9B<HgcBlur_cs9s>::SetRadius(uint64_t a1, double a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2060, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A2060))
  {
    _MergedGlobals_12 = 0xBFE0000000000000;
    __cxa_guard_release(&qword_1EB9A2060);
  }
  double v4 = *(double *)&_MergedGlobals_12;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2060, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A2060))
  {
    _MergedGlobals_12 = 0xBFE0000000000000;
    __cxa_guard_release(&qword_1EB9A2060);
  }
  double v5 = *(double *)&_MergedGlobals_12;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2060, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A2060))
  {
    _MergedGlobals_12 = 0xBFE0000000000000;
    __cxa_guard_release(&qword_1EB9A2060);
  }
  double v6 = *(double *)&_MergedGlobals_12;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2060, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A2060))
  {
    _MergedGlobals_12 = 0xBFE0000000000000;
    __cxa_guard_release(&qword_1EB9A2060);
  }
  double v7 = *(double *)&_MergedGlobals_12;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EB9A2060, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EB9A2060))
  {
    _MergedGlobals_12 = 0xBFE0000000000000;
    __cxa_guard_release(&qword_1EB9A2060);
  }
  long double v8 = exp(9.0 / a2 * (9.0 / a2 * v7));
  long double v9 = exp(6.0 / a2 * (6.0 / a2 * v6));
  long double v10 = exp(3.0 / a2 * (3.0 / a2 * v5));
  double v11 = exp(0.0 / a2 * (0.0 / a2 * v4));
  long double v12 = exp(12.0 / a2 * (12.0 / a2 * *(double *)&_MergedGlobals_12));
  long double v13 = v11 + v10 + v9 + v8 + v12 + v10 + v9 + v8 + v12;
  float v14 = v10 / v13;
  float v15 = v9 / v13;
  float v16 = v8 / v13;
  *(float *)&long double v12 = v12 / v13;
  float v17 = (float)(v14 + 256.0) + -256.0;
  *(float *)&long double v9 = (float)(v15 + 256.0) + -256.0;
  *(float *)&long double v10 = (float)(v16 + 256.0) + -256.0;
  *(float *)&long double v8 = (float)(*(float *)&v12 + 256.0) + -256.0;
  (*(void (**)(uint64_t, void, float, float, float, float))(*(void *)a1 + 96))(a1, 0, 1.0- (float)((float)(*(float *)&v8 + (float)(*(float *)&v10 + (float)(v17 + *(float *)&v9)))+ (float)(*(float *)&v8 + (float)(*(float *)&v10 + (float)(v17 + *(float *)&v9)))), 1.0- (float)((float)(*(float *)&v8 + (float)(*(float *)&v10 + (float)(v17 + *(float *)&v9)))+ (float)(*(float *)&v8 + (float)(*(float *)&v10 + (float)(v17 + *(float *)&v9)))), 1.0- (float)((float)(*(float *)&v8 + (float)(*(float *)&v10 + (float)(v17 + *(float *)&v9)))+ (float)(*(float *)&v8 + (float)(*(float *)&v10 + (float)(v17 + *(float *)&v9)))), 1.0- (float)((float)(*(float *)&v8 + (float)(*(float *)&v10 + (float)(v17 + *(float *)&v9)))+ (float)(*(float *)&v8 + (float)(*(float *)&v10 + (float)(v17 + *(float *)&v9)))));
  (*(void (**)(uint64_t, uint64_t, float, float, float, float))(*(void *)a1 + 96))(a1, 1, v17, v17, v17, v17);
  (*(void (**)(uint64_t, uint64_t, float, float, float, float))(*(void *)a1 + 96))(a1, 2, *(float *)&v9, *(float *)&v9, *(float *)&v9, *(float *)&v9);
  (*(void (**)(uint64_t, uint64_t, float, float, float, float))(*(void *)a1 + 96))(a1, 3, *(float *)&v10, *(float *)&v10, *(float *)&v10, *(float *)&v10);
  (*(void (**)(uint64_t, uint64_t, float, float, float, float))(*(void *)a1 + 96))(a1, 4, *(float *)&v8, *(float *)&v8, *(float *)&v8, *(float *)&v8);
  return v17 > 0.0;
}

HGNode *HGBlur::GetOutput(HGNode *this, HGRenderer *a2)
{
  Input = HGRenderer::GetInput(a2, this, 0);
  if (*((_DWORD *)this + 107))
  {
    *((_DWORD *)this + 107) = 0;
    if (*((float *)this + 104) <= 0.0 && *((float *)this + 105) <= 0.0) {
      return Input;
    }
    if (*((unsigned char *)this + 488))
    {
      HGBlur::ComputeDecimation((uint64_t)this, 1);
      Input = HGBlur::fastDecimateDown((HGBlur *)this, Input);
    }
    HGBlur::ComputeDecimation((uint64_t)this, 0);
    *((void *)this + 54) = 0;
    *((void *)this + 55) = Input;
    int v5 = *((_DWORD *)this + 130);
    uint64_t DeviceInfo = (*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2);
    if ((DeviceInfo & 1) != 0
      || HGBlur::m_ForceOneForOneTapMethod
      || v5 != 1
      || (uint64_t DeviceInfo = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 43),
          DeviceInfo != 1))
    {
      if (*((int *)this + 114) >= 1) {
        goto LABEL_14;
      }
    }
    else
    {
      uint64_t MetalContext = HGGPURenderer::GetMetalContext(a2);
      uint64_t DeviceInfo = HGMetalDeviceInfo::getDeviceInfo(*(void *)(*(void *)(MetalContext + 16) + 16));
      if (*(unsigned char *)(DeviceInfo + 57))
      {
        if (*((int *)this + 114) < 1) {
          goto LABEL_21;
        }
LABEL_14:
        uint64_t v8 = 0;
        do
        {
          long double v9 = *(_DWORD **)(*((void *)this + 56) + 8 * v8);
          if (!v9) {
            HGBlur::CreateDownShaderDoubleHorz(DeviceInfo, (uint64_t)a2);
          }
          v9[4] &= ~2u;
          if (!*((void *)this + 54)) {
            *((void *)this + 54) = v9;
          }
          uint64_t DeviceInfo = (*(uint64_t (**)(_DWORD *, void, void))(*(void *)v9 + 120))(v9, 0, *((void *)this + 55));
          *((void *)this + 55) = v9;
          ++v8;
        }
        while (v8 < *((int *)this + 114));
        goto LABEL_21;
      }
      if (*((int *)this + 114) >= 1) {
        goto LABEL_14;
      }
    }
LABEL_21:
    LODWORD(v1CVOpenGLESTextureCacheFlush(this[3], 0) = *((_DWORD *)this + 118);
    if ((int)v10 >= 1)
    {
      uint64_t v11 = 16;
      do
      {
        long double v13 = *(_DWORD **)(*((void *)this + 56) + 8 * v11);
        if (!v13) {
          HGBlur::CreateDownShaderDoubleVert(DeviceInfo, (uint64_t)a2);
        }
        v13[4] &= ~2u;
        if (!*((void *)this + 54)) {
          *((void *)this + 54) = v13;
        }
        uint64_t DeviceInfo = (*(uint64_t (**)(_DWORD *, void, void))(*(void *)v13 + 120))(v13, 0, *((void *)this + 55));
        *((void *)this + 55) = v13;
        uint64_t v10 = *((int *)this + 118);
        uint64_t v12 = v11 - 15;
        ++v11;
      }
      while (v12 < v10);
      if ((int)v10 >= 1)
      {
        unsigned int v14 = v10 + 15;
        if (v10 > 3) {
          unsigned int v14 = 19;
        }
        uint64_t v15 = *(void *)(*((void *)this + 56) + 8 * v14);
        *(_DWORD *)(v15 + 16) |= 2u;
      }
    }
    int v16 = *((_DWORD *)this + 114);
    unsigned int v17 = v16 - 1;
    if (v16 >= 1 && (!v10 || (int)v10 >= 2))
    {
      if (v16 > 3) {
        unsigned int v17 = 3;
      }
      uint64_t v18 = *(void *)(*((void *)this + 56) + 8 * v17);
      *(_DWORD *)(v18 + 16) |= 2u;
    }
    if (*((_DWORD *)this + 115))
    {
      uint64_t v19 = *(void *)(*((void *)this + 56) + 120);
      if (!v19) {
        HGBlur::CreateDownShaderHorz(DeviceInfo, (uint64_t)a2);
      }
      if (!*((void *)this + 54)) {
        *((void *)this + 54) = v19;
      }
      uint64_t DeviceInfo = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v19 + 120))(v19, 0, *((void *)this + 55));
      *((void *)this + 55) = v19;
    }
    if (*((_DWORD *)this + 119))
    {
      uint64_t v20 = *(void *)(*((void *)this + 56) + 248);
      if (!v20) {
        HGBlur::CreateDownShaderVert(DeviceInfo, (uint64_t)a2);
      }
      if (!*((void *)this + 54)) {
        *((void *)this + 54) = v20;
      }
      uint64_t DeviceInfo = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v20 + 120))(v20, 0, *((void *)this + 55));
      *((void *)this + 55) = v20;
    }
    if (*((_DWORD *)this + 116))
    {
      uint64_t v21 = *(void *)(*((void *)this + 56) + 376);
      if (!v21) {
        HGBlur::CreateDownShaderHorz(0, (uint64_t)a2);
      }
      uint64_t DeviceInfo = HGG9B<HgcBlur_cs9s>::SetRadius(v21, *((float *)this + 117));
      if (DeviceInfo)
      {
        uint64_t v22 = *(void *)(*((void *)this + 56) + 376);
        if (v22)
        {
          if (!*((void *)this + 54)) {
            *((void *)this + 54) = v22;
          }
          uint64_t DeviceInfo = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v22 + 120))(v22, 0, *((void *)this + 55));
          *((void *)this + 55) = v22;
        }
      }
    }
    if (*((_DWORD *)this + 120))
    {
      uint64_t v23 = *(void *)(*((void *)this + 56) + 504);
      if (!v23) {
        HGBlur::CreateDownShaderVert(0, (uint64_t)a2);
      }
      uint64_t DeviceInfo = HGG9B<HgcBlur_cs9s>::SetRadius(v23, *((float *)this + 121));
      if (DeviceInfo)
      {
        uint64_t v24 = *(void *)(*((void *)this + 56) + 504);
        if (v24)
        {
          if (!*((void *)this + 54)) {
            *((void *)this + 54) = v24;
          }
          uint64_t DeviceInfo = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v24 + 120))(v24, 0, *((void *)this + 55));
          *((void *)this + 55) = v24;
        }
      }
    }
    if (!*((_DWORD *)this + 106))
    {
      if (*((int *)this + 114) >= 1)
      {
        uint64_t v27 = 32;
        do
        {
          uint64_t v29 = *(void *)(*((void *)this + 56) + 8 * v27);
          if (!v29) {
            HGBlur::CreateUpShaderHorz((HGBlur *)DeviceInfo, a2);
          }
          if (!*((void *)this + 54)) {
            *((void *)this + 54) = v29;
          }
          uint64_t DeviceInfo = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v29 + 120))(v29, 0, *((void *)this + 55));
          *((void *)this + 55) = v29;
          uint64_t v28 = v27 - 31;
          ++v27;
        }
        while (v28 < *((int *)this + 114));
      }
      if (*((int *)this + 118) >= 1)
      {
        uint64_t v30 = 48;
        do
        {
          uint64_t v32 = *(void *)(*((void *)this + 56) + 8 * v30);
          if (!v32) {
            HGBlur::CreateUpShaderVet((HGBlur *)DeviceInfo, a2);
          }
          if (!*((void *)this + 54)) {
            *((void *)this + 54) = v32;
          }
          uint64_t DeviceInfo = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v32 + 120))(v32, 0, *((void *)this + 55));
          *((void *)this + 55) = v32;
          uint64_t v31 = v30 - 47;
          ++v30;
        }
        while (v31 < *((int *)this + 118));
      }
    }
    if (*((unsigned char *)this + 488)) {
      *((void *)this + 55) = HGBlur::fastDecimateUp((HGBlur *)this, *((HGNode **)this + 55));
    }
  }
  uint64_t v25 = *((void *)this + 54);
  if (v25) {
    (*(void (**)(uint64_t, void, HGNode *))(*(void *)v25 + 120))(v25, 0, Input);
  }
  return (HGNode *)*((void *)this + 55);
}

void HGBS::HGBlurShared::~HGBlurShared(HGBS::HGBlurShared *this)
{
  *(void *)this = &unk_1F10D6C48;
  uint64_t v2 = *((void *)this + 67);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGBlur::~HGBlur(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10D6C48;
  uint64_t v2 = *((void *)this + 67);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGBlur::~HGBlur(this);

  HGObject::operator delete(v3);
}

HGNode *HGBS::HGBlurShared::GetOutput(HGNode *this, HGRenderer *a2)
{
  uint64_t v4 = *((void *)this + 67);
  if (v4)
  {
    HGRenderer::GetOutput(a2, (HGNode *)v4);
    Input = HGRenderer::GetInput(a2, this, 0);
    if (!*((_DWORD *)this + 107))
    {
LABEL_76:
      uint64_t v24 = *((void *)this + 54);
      if (v24) {
        (*(void (**)(uint64_t, void, HGNode *))(*(void *)v24 + 120))(v24, 0, Input);
      }
      return (HGNode *)*((void *)this + 55);
    }
    *((_DWORD *)this + 107) = 0;
    if (*((float *)this + 104) <= 0.0 && *((float *)this + 105) <= 0.0) {
      return Input;
    }
    HGBlur::ComputeDecimation((uint64_t)this, 0);
    *((void *)this + 54) = 0;
    *((void *)this + 55) = Input;
    if (*((int *)this + 114) >= 1)
    {
      uint64_t v6 = 0;
      double v7 = Input;
      while (1)
      {
        if (v6 >= *((int *)this + 118)) {
          goto LABEL_26;
        }
        uint64_t v8 = *(void *)(v4 + 448);
        long double v9 = *(HGNode **)(v8 + 8 * v6);
        if (v9) {
          *((_DWORD *)v9 + 4) &= ~2u;
        }
        uint64_t v10 = *(HGNode **)(v8 + 8 * v6 + 128);
        if (v10) {
          *((_DWORD *)v10 + 4) &= ~2u;
        }
        if (v9)
        {
          if (!*((void *)this + 54)) {
            *((void *)this + 54) = v9;
          }
          (*(void (**)(HGNode *, void, HGNode *))(*(void *)v9 + 120))(v9, 0, v7);
          *((void *)this + 55) = v9;
          uint64_t v10 = *(HGNode **)(*(void *)(v4 + 448) + 8 * v6 + 128);
          if (v10) {
            goto LABEL_17;
          }
LABEL_20:
          ++v6;
          double v7 = v9;
          if (v6 >= *((int *)this + 114)) {
            goto LABEL_26;
          }
        }
        else
        {
          long double v9 = v7;
          if (!v10) {
            goto LABEL_20;
          }
LABEL_17:
          if (!*((void *)this + 54)) {
            *((void *)this + 54) = v10;
          }
          (*(void (**)(HGNode *, void, HGNode *))(*(void *)v10 + 120))(v10, 0, v9);
          *((void *)this + 55) = v10;
          ++v6;
          double v7 = v10;
          if (v6 >= *((int *)this + 114)) {
            goto LABEL_26;
          }
        }
      }
    }
    LODWORD(v6) = 0;
LABEL_26:
    int v12 = *((_DWORD *)this + 130);
    uint64_t DeviceInfo = (*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2);
    if ((DeviceInfo & 1) != 0
      || HGBlur::m_ForceOneForOneTapMethod
      || v12 != 1
      || (uint64_t DeviceInfo = (*(uint64_t (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 43),
          DeviceInfo != 1))
    {
      if ((int)v6 >= *((_DWORD *)this + 114))
      {
LABEL_40:
        if ((int)v6 < *((_DWORD *)this + 118))
        {
          uint64_t v16 = 8 * v6 + 128;
          do
          {
            unsigned int v17 = *(_DWORD **)(*((void *)this + 56) + v16);
            if (!v17) {
              HGBlur::CreateDownShaderDoubleVert(DeviceInfo, (uint64_t)a2);
            }
            v17[4] &= ~2u;
            if (!*((void *)this + 54)) {
              *((void *)this + 54) = v17;
            }
            uint64_t DeviceInfo = (*(uint64_t (**)(_DWORD *, void, void))(*(void *)v17 + 120))(v17, 0, *((void *)this + 55));
            *((void *)this + 55) = v17;
            v16 += 8;
            LODWORD(v6) = v6 + 1;
          }
          while (*((_DWORD *)this + 118) > (int)v6);
        }
        if (*((_DWORD *)this + 115))
        {
          uint64_t v18 = *(void *)(*((void *)this + 56) + 120);
          if (!v18) {
            HGBlur::CreateDownShaderHorz(DeviceInfo, (uint64_t)a2);
          }
          if (!*((void *)this + 54)) {
            *((void *)this + 54) = v18;
          }
          uint64_t DeviceInfo = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v18 + 120))(v18, 0, *((void *)this + 55));
          *((void *)this + 55) = v18;
        }
        if (*((_DWORD *)this + 119))
        {
          uint64_t v19 = *(void *)(*((void *)this + 56) + 248);
          if (!v19) {
            HGBlur::CreateDownShaderVert(DeviceInfo, (uint64_t)a2);
          }
          if (!*((void *)this + 54)) {
            *((void *)this + 54) = v19;
          }
          uint64_t DeviceInfo = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v19 + 120))(v19, 0, *((void *)this + 55));
          *((void *)this + 55) = v19;
        }
        if (*((_DWORD *)this + 116))
        {
          uint64_t v20 = *(void *)(*((void *)this + 56) + 376);
          if (!v20) {
            HGBlur::CreateDownShaderHorz(0, (uint64_t)a2);
          }
          uint64_t DeviceInfo = HGG9B<HgcBlur_cs9s>::SetRadius(v20, *((float *)this + 117));
          if (DeviceInfo)
          {
            uint64_t v21 = *(void *)(*((void *)this + 56) + 376);
            if (v21)
            {
              if (!*((void *)this + 54)) {
                *((void *)this + 54) = v21;
              }
              uint64_t DeviceInfo = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v21 + 120))(v21, 0, *((void *)this + 55));
              *((void *)this + 55) = v21;
            }
          }
        }
        if (*((_DWORD *)this + 120))
        {
          uint64_t v22 = *(void *)(*((void *)this + 56) + 504);
          if (!v22) {
            HGBlur::CreateDownShaderVert(0, (uint64_t)a2);
          }
          uint64_t DeviceInfo = HGG9B<HgcBlur_cs9s>::SetRadius(v22, *((float *)this + 121));
          if (DeviceInfo)
          {
            uint64_t v23 = *(void *)(*((void *)this + 56) + 504);
            if (v23)
            {
              if (!*((void *)this + 54)) {
                *((void *)this + 54) = v23;
              }
              uint64_t DeviceInfo = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v23 + 120))(v23, 0, *((void *)this + 55));
              *((void *)this + 55) = v23;
            }
          }
        }
        if (!*((_DWORD *)this + 106))
        {
          if (*((int *)this + 114) >= 1)
          {
            uint64_t v25 = 32;
            do
            {
              uint64_t v27 = *(void *)(*((void *)this + 56) + 8 * v25);
              if (!v27) {
                HGBlur::CreateUpShaderHorz((HGBlur *)DeviceInfo, a2);
              }
              if (!*((void *)this + 54)) {
                *((void *)this + 54) = v27;
              }
              uint64_t DeviceInfo = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v27 + 120))(v27, 0, *((void *)this + 55));
              *((void *)this + 55) = v27;
              uint64_t v26 = v25 - 31;
              ++v25;
            }
            while (v26 < *((int *)this + 114));
          }
          if (*((int *)this + 118) >= 1)
          {
            uint64_t v28 = 48;
            do
            {
              uint64_t v30 = *(void *)(*((void *)this + 56) + 8 * v28);
              if (!v30) {
                HGBlur::CreateUpShaderVet((HGBlur *)DeviceInfo, a2);
              }
              if (!*((void *)this + 54)) {
                *((void *)this + 54) = v30;
              }
              uint64_t DeviceInfo = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v30 + 120))(v30, 0, *((void *)this + 55));
              *((void *)this + 55) = v30;
              uint64_t v29 = v28 - 47;
              ++v28;
            }
            while (v29 < *((int *)this + 118));
          }
        }
        goto LABEL_76;
      }
    }
    else
    {
      uint64_t MetalContext = HGGPURenderer::GetMetalContext(a2);
      uint64_t DeviceInfo = HGMetalDeviceInfo::getDeviceInfo(*(void *)(*(void *)(MetalContext + 16) + 16));
      if (*(unsigned char *)(DeviceInfo + 57))
      {
        if ((int)v6 >= *((_DWORD *)this + 114)) {
          goto LABEL_40;
        }
      }
      else if ((int)v6 >= *((_DWORD *)this + 114))
      {
        goto LABEL_40;
      }
    }
    uint64_t v6 = v6;
    do
    {
      uint64_t v15 = *(_DWORD **)(*((void *)this + 56) + 8 * v6);
      if (!v15) {
        HGBlur::CreateDownShaderDoubleHorz(DeviceInfo, (uint64_t)a2);
      }
      v15[4] &= ~2u;
      if (!*((void *)this + 54)) {
        *((void *)this + 54) = v15;
      }
      uint64_t DeviceInfo = (*(uint64_t (**)(_DWORD *, void, void))(*(void *)v15 + 120))(v15, 0, *((void *)this + 55));
      *((void *)this + 55) = v15;
      ++v6;
    }
    while (*((_DWORD *)this + 114) > (int)v6);
    goto LABEL_40;
  }

  return HGBlur::GetOutput(this, a2);
}

void HGBS::createColorMaskNode(HGBS *this, float a2, float a3, float a4)
{
  uint64_t v4 = (HGColorMatrix *)HGObject::operator new(0x1F0uLL);
  HGColorMatrix::HGColorMatrix(v4);
}

void sub_1B77BF5DC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HGBlurGroup::HGBlurGroup(HGBlurGroup *this, HGNode *a2, char a3)
{
  HGObject::HGObject(this);
  *uint64_t v6 = &unk_1F10D6E98;
  if (a2) {
    (*(void (**)(HGNode *))(*(void *)a2 + 16))(a2);
  }
  *(_OWORD *)((char *)this + 24) = 0u;
  *((void *)this + 2) = a2;
  *(_OWORD *)((char *)this + 4CVOpenGLESTextureCacheFlush(this[3], 0) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((unsigned char *)this + 104) = 1;
  *((unsigned char *)this + 105) = a3;
  *((unsigned char *)this + 106) = 0;
  double v7 = operator new(8uLL);
  void *v7 = 0;
  *((void *)this + 5) = v7 + 1;
  *((void *)this + 6) = v7 + 1;
  *((void *)this + 4) = v7;
}

void sub_1B77BF6B0(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void sub_1B77BF6C4(_Unwind_Exception *a1)
{
  std::vector<HGRef<HGNode>>::~vector[abi:ne180100]((void **)(v1 + 80));
  std::vector<HGRef<HGNode>>::~vector[abi:ne180100]((void **)(v1 + 56));
  uint64_t v4 = *(void **)(v1 + 32);
  if (v4)
  {
    *(void *)(v1 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = v4;
    operator delete(v4);
  }
  if (*v2) {
    (*(void (**)(void))(*(void *)*v2 + 24))(*v2);
  }
  uint64_t v5 = *(void *)(v1 + 16);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  HGObject::~HGObject((HGObject *)v1);
  _Unwind_Resume(a1);
}

void **std::vector<HGRef<HGNode>>::~vector[abi:ne180100](void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *((void *)v3 - 1);
        v3 -= 8;
        uint64_t v5 = v6;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void HGBlurGroup::~HGBlurGroup(HGBlurGroup *this)
{
  *(void *)this = &unk_1F10D6E98;
  uint64_t v2 = *((void *)this + 10);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 11);
    uint64_t v4 = (void *)*((void *)this + 10);
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *(void *)(v3 - 8);
        v3 -= 8;
        uint64_t v5 = v6;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 10);
    }
    *((void *)this + 11) = v2;
    operator delete(v4);
  }
  uint64_t v7 = *((void *)this + 7);
  if (v7)
  {
    uint64_t v8 = *((void *)this + 8);
    long double v9 = (void *)*((void *)this + 7);
    if (v8 != v7)
    {
      do
      {
        uint64_t v11 = *(void *)(v8 - 8);
        v8 -= 8;
        uint64_t v10 = v11;
        if (v11) {
          (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
        }
      }
      while (v8 != v7);
      long double v9 = (void *)*((void *)this + 7);
    }
    *((void *)this + 8) = v7;
    operator delete(v9);
  }
  int v12 = (void *)*((void *)this + 4);
  if (v12)
  {
    *((void *)this + 5) = v12;
    operator delete(v12);
  }
  uint64_t v13 = *((void *)this + 3);
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 24))(v13);
  }
  uint64_t v14 = *((void *)this + 2);
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);
  }

  HGObject::~HGObject(this);
}

{
  void *v1;
  uint64_t vars8;

  HGBlurGroup::~HGBlurGroup(this);

  HGObject::operator delete(v1);
}

void HGBlurGroup::setBlurValues(HGBlurGroup *this, const float *a2, const float *a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v8 = 0;
    long double v9 = (float *)*((void *)this + 4);
    uint64_t v32 = (float **)((char *)this + 32);
    *((void *)this + 5) = v9;
    while (1)
    {
      float v11 = a2[v8];
      float v12 = a3[v8];
      unint64_t v13 = *((void *)this + 6);
      if ((unint64_t)v9 < v13)
      {
        *long double v9 = v11;
        v9[1] = v12;
        uint64_t v10 = v9 + 2;
      }
      else
      {
        uint64_t v14 = *v32;
        uint64_t v15 = (char *)v9 - (char *)*v32;
        uint64_t v16 = v15 >> 3;
        unint64_t v17 = (v15 >> 3) + 1;
        if (v17 >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v18 = v13 - (void)v14;
        if (v18 >> 2 > v17) {
          unint64_t v17 = v18 >> 2;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          if (v19 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v20 = operator new(8 * v19);
          uint64_t v21 = (float *)&v20[8 * v16];
          float *v21 = v11;
          v21[1] = v12;
          if (v9 != v14)
          {
LABEL_15:
            unint64_t v22 = (char *)(v9 - 2) - (char *)v14;
            if (v22 < 0x168
              || &v20[v15 - 8 - (v22 & 0xFFFFFFFFFFFFFFF8)] > &v20[v15 - 8]
              || (float *)((char *)v9 - (v22 & 0xFFFFFFFFFFFFFFF8) - 8) > v9 - 2
              || (unint64_t)((char *)v9 - v20 - v15) < 0x20)
            {
              uint64_t v23 = v9;
              uint64_t v24 = v21;
              goto LABEL_20;
            }
            uint64_t v26 = (v22 >> 3) + 1;
            uint64_t v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v23 = &v9[v27 / 0xFFFFFFFFFFFFFFFCLL];
            uint64_t v24 = &v21[v27 / 0xFFFFFFFFFFFFFFFCLL];
            uint64_t v28 = &v20[8 * v16 - 16];
            uint64_t v29 = v9 - 4;
            uint64_t v30 = v26 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v31 = *(_OWORD *)v29;
              *(v28 - 1) = *((_OWORD *)v29 - 1);
              *uint64_t v28 = v31;
              v28 -= 2;
              v29 -= 8;
              v30 -= 4;
            }
            while (v30);
            if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
            {
              do
              {
LABEL_20:
                uint64_t v25 = *((void *)v23 - 1);
                v23 -= 2;
                *((void *)v24 - 1) = v25;
                v24 -= 2;
              }
              while (v23 != v14);
            }
            long double v9 = *v32;
            uint64_t v10 = v21 + 2;
            *((void *)this + 4) = v24;
            *((void *)this + 5) = v21 + 2;
            *((void *)this + 6) = &v20[8 * v19];
            if (!v9) {
              goto LABEL_4;
            }
LABEL_25:
            operator delete(v9);
            goto LABEL_4;
          }
        }
        else
        {
          uint64_t v20 = 0;
          uint64_t v21 = (float *)(8 * v16);
          float *v21 = v11;
          v21[1] = v12;
          if (v9 != v14) {
            goto LABEL_15;
          }
        }
        uint64_t v10 = v21 + 2;
        *((void *)this + 4) = v21;
        *((void *)this + 5) = v21 + 2;
        *((void *)this + 6) = &v20[8 * v19];
        if (v9) {
          goto LABEL_25;
        }
      }
LABEL_4:
      *((void *)this + 5) = v10;
      ++v8;
      long double v9 = v10;
      if (v8 == a4)
      {
        *((unsigned char *)this + 104) = 1;
        return;
      }
    }
  }
}

uint64_t HGBlurGroup::level(HGBlurGroup *this, unsigned int a2)
{
  if (*((unsigned char *)this + 104))
  {
    uint64_t v4 = *((void *)this + 7);
    for (uint64_t i = *((void *)this + 8); i != v4; i -= 8)
    {
      uint64_t v7 = *(void *)(i - 8);
      uint64_t v6 = v7;
      if (v7) {
        (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
      }
    }
    uint64_t v8 = *((void *)this + 10);
    *((void *)this + 8) = v4;
    for (uint64_t j = *((void *)this + 11); j != v8; j -= 8)
    {
      uint64_t v11 = *(void *)(j - 8);
      uint64_t v10 = v11;
      if (v11) {
        (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
      }
    }
    *((void *)this + 11) = v8;
    uint64_t v12 = *((void *)this + 5);
    float v13 = *(float *)(v12 - 8);
    float v14 = *(float *)(v12 - 4);
    uint64_t v15 = (HGBlur *)HGObject::operator new(0x220uLL);
    HGBlur::HGBlur(v15);
    uint64_t v16 = (HGBlur *)*((void *)this + 3);
    unsigned int v37 = a2;
    if (v16 == v15)
    {
      if (v15)
      {
        (*(void (**)(HGBlur *))(*(void *)v15 + 24))(v15);
        uint64_t v15 = (HGBlur *)*((void *)this + 3);
      }
    }
    else
    {
      if (v16) {
        (*(void (**)(HGBlur *))(*(void *)v16 + 24))(v16);
      }
      *((void *)this + 3) = v15;
    }
    (*(void (**)(HGBlur *, void, float, float, double, double))(*(void *)v15 + 96))(v15, 0, v13, v14, 0.0, 0.0);
    (*(void (**)(void, void, void))(**((void **)this + 3) + 120))(*((void *)this + 3), 0, *((void *)this + 2));
    unint64_t v17 = (float *)*((void *)this + 4);
    if (v17 != *((float **)this + 5))
    {
      uint64_t v19 = *((void *)this + 7);
      uint64_t v18 = *((void *)this + 8);
      float v20 = *v17;
      float v21 = v17[1];
      unint64_t v22 = (HGBlur *)HGObject::operator new(0x220uLL);
      HGBlur::HGBlur(v22);
      uint64_t v25 = &unk_1F10D6C48;
      *(void *)unint64_t v22 = &unk_1F10D6C48;
      *((void *)v22 + 67) = 0;
      if (*((float *)v22 + 104) != v20 || *((float *)v22 + 105) != v21)
      {
        *((float *)v22 + 104) = v20;
        *((float *)v22 + 105) = v21;
        *((_DWORD *)v22 + 107) = 1;
        HGNode::ClearBits((HGNode *)v22, v23, v24);
        uint64_t v25 = *(void **)v22;
      }
      (*((void (**)(HGBlur *, void, void))v25 + 15))(v22, 0, *((void *)this + 2));
      if (!*((unsigned char *)this + 106))
      {
        uint64_t v33 = *((void *)v22 + 67);
        uint64_t v34 = *((void *)this + 3);
        if (v33 != v34)
        {
          if (v33)
          {
            (*(void (**)(void))(*(void *)v33 + 24))(*((void *)v22 + 67));
            uint64_t v34 = *((void *)this + 3);
          }
          *((void *)v22 + 67) = v34;
          if (v34) {
            (*(void (**)(uint64_t))(*(void *)v34 + 16))(v34);
          }
        }
      }
      int64_t v38 = v22;
      uint64_t v26 = (HGBS *)(*(uint64_t (**)(HGBlur *))(*(void *)v22 + 16))(v22);
      uint64_t v27 = (HGBS **)*((void *)this + 8);
      if ((unint64_t)v27 >= *((void *)this + 9))
      {
        uint64_t v28 = std::vector<HGRef<HGNode>>::__push_back_slow_path<HGRef<HGNode>>((void **)this + 7, &v38);
        uint64_t v26 = v38;
        *((void *)this + 8) = v28;
        if (v26) {
          uint64_t v26 = (HGBS *)(*(uint64_t (**)(HGBS *))(*(void *)v26 + 24))(v26);
        }
      }
      else
      {
        *uint64_t v27 = v38;
        *((void *)this + 8) = v27 + 1;
      }
      int v29 = (int)(((unint64_t)(v18 - v19) >> 3) - 1) % 3;
      float v30 = 0.4;
      if (v29) {
        float v31 = 0.4;
      }
      else {
        float v31 = 1.0;
      }
      if (v29 == 1) {
        float v32 = 1.0;
      }
      else {
        float v32 = 0.4;
      }
      if (v29 == 2) {
        float v30 = 1.0;
      }
      HGBS::createColorMaskNode(v26, v31, v32, v30);
    }
    *((unsigned char *)this + 104) = 0;
    a2 = v37;
  }
  uint64_t v35 = 80;
  if (!*((unsigned char *)this + 105)) {
    uint64_t v35 = 56;
  }
  return *(void *)(*(void *)((char *)this + v35) + 8 * a2);
}

void sub_1B77C00BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  }
  _Unwind_Resume(exception_object);
}

void HGDecimationImplementation::~HGDecimationImplementation(HGDecimationImplementation *this)
{
  *(void *)this = &unk_1F10D6F18;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 2);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }

  HGObject::~HGObject(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1F10D6F18;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 2);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  HGObject::~HGObject(this);

  HGObject::operator delete(v4);
}

void HGG9X<HgcBlur_cs9s_rect>::HGG9X(HgcBlur_cs9s_rect *a1)
{
}

void sub_1B77C0498(_Unwind_Exception *a1)
{
  HgcBlur_cs9s_rect::~HgcBlur_cs9s_rect(v1);
  _Unwind_Resume(a1);
}

void sub_1B77C04AC(_Unwind_Exception *a1)
{
  HgcBlur_cs9s_rect::~HgcBlur_cs9s_rect(v1);
  _Unwind_Resume(a1);
}

void HGG9X<HgcBlur_cs9s_rect>::~HGG9X(HGNode *a1)
{
  HgcBlur_cs9s_rect::~HgcBlur_cs9s_rect(a1);

  HGObject::operator delete(v1);
}

const char *HGG9X<HgcBlur_cs9s_rect>::label_A()
{
  return "HGG9X";
}

uint64_t HGG9X<HgcBlur_cs9s_rect>::RenderTile(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = HGGetTBC();
  uint64_t v5 = *(float32x4_t **)(a1 + 48);
  if (v5[4].f32[0] == 0.0)
  {
    if (v5[3].f32[0] != 0.0)
    {
      int v40 = *(_DWORD *)(a2 + 8);
      int v41 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
      if (v41 >= 1 && v40 != *(_DWORD *)a2)
      {
        int v43 = 0;
        float32x4_t v44 = *v5;
        float32x4_t v45 = v5[1];
        int v46 = *(_DWORD *)a2 - v40;
        float32x4_t v47 = v5[2];
        float32x4_t v48 = v5[3];
        do
        {
          float v49 = (float32x4_t *)(*(void *)(a2 + 16) + 16 * *(_DWORD *)(a2 + 24) * v43);
          uint64_t v50 = (float32x4_t *)(*(void *)(a2 + 80) + 16 * *(_DWORD *)(a2 + 88) * v43);
          float32x4_t v52 = v50[-3];
          float32x4_t v51 = v50[-2];
          float32x4_t v53 = v50[-1];
          float32x4_t v54 = *v50;
          float32x4_t v55 = v50[1];
          float32x4_t v56 = v50[2];
          signed int v57 = v50 + 3;
          int v58 = v46;
          do
          {
            float32x4_t v59 = *v57++;
            *v49++ = vaddq_f32(vaddq_f32(vmulq_f32(v47, vaddq_f32(v56, v51)), vaddq_f32(vmulq_f32(v44, v54), vmulq_f32(v45, vaddq_f32(v55, v53)))), vmulq_f32(v48, vaddq_f32(v52, v59)));
            float32x4_t v52 = v51;
            float32x4_t v51 = v53;
            float32x4_t v53 = v54;
            float32x4_t v54 = v55;
            float32x4_t v55 = v56;
            float32x4_t v56 = v59;
          }
          while (!__CFADD__(v58++, 1));
          ++v43;
        }
        while (v43 != v41);
      }
      goto LABEL_50;
    }
    float32x4_t v61 = *v5;
    float32x4_t v62 = v5[1];
    if (v5[2].f32[0] != 0.0)
    {
      int v63 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
      if (v63 < 1) {
        goto LABEL_50;
      }
      int v64 = 0;
      float32x4_t v65 = v5[2];
      int v66 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
      while (1)
      {
        uint64_t v67 = (float32x4_t *)(*(void *)(a2 + 16) + 16 * *(_DWORD *)(a2 + 24) * v64);
        uint64_t v68 = (float32x4_t *)(*(void *)(a2 + 80) + 16 * *(_DWORD *)(a2 + 88) * v64);
        float32x4_t v70 = v68[-2];
        float32x4_t v69 = v68[-1];
        float32x4_t v71 = *v68;
        float32x4_t v72 = v68[1];
        if (v66 >= 2) {
          break;
        }
        uint64_t v79 = (uint64_t)&v68[4];
        unsigned int v74 = v66;
        if (v66) {
          goto LABEL_35;
        }
LABEL_28:
        if (++v64 == v63) {
          goto LABEL_50;
        }
      }
      uint64_t v73 = 0;
      unsigned int v74 = v66;
      do
      {
        float32x4_t v75 = v72;
        unsigned int v76 = v74;
        float32x4_t v77 = v71;
        uint64_t v78 = &v67[v73];
        float32x4_t v71 = v68[v73 + 2];
        float32x4_t v72 = v68[v73 + 3];
        v74 -= 2;
        *uint64_t v78 = vaddq_f32(vaddq_f32(vmulq_f32(v61, v77), vmulq_f32(v62, vaddq_f32(v75, v69))), vmulq_f32(v65, vaddq_f32(v70, v71)));
        v78[1] = vaddq_f32(vmulq_f32(v65, vaddq_f32(v69, v72)), vaddq_f32(vmulq_f32(v61, v75), vmulq_f32(v62, vaddq_f32(v77, v71))));
        v73 += 2;
        float32x4_t v70 = v77;
        float32x4_t v69 = v75;
      }
      while (v76 > 3);
      uint64_t v67 = (float32x4_t *)((char *)v67 + v73 * 16);
      uint64_t v79 = (uint64_t)&v68[v73 + 4];
      float32x4_t v69 = v75;
      float32x4_t v70 = v77;
      if (!v74) {
        goto LABEL_28;
      }
LABEL_35:
      long long v80 = (float32x4_t *)(v79 - 32);
      do
      {
        float32x4_t v81 = *v80++;
        *v67++ = vaddq_f32(vaddq_f32(vmulq_f32(v61, v71), vmulq_f32(v62, vaddq_f32(v72, v69))), vmulq_f32(v65, vaddq_f32(v70, v81)));
        float32x4_t v70 = v69;
        float32x4_t v69 = v71;
        float32x4_t v71 = v72;
        float32x4_t v72 = v81;
        --v74;
      }
      while (v74);
      goto LABEL_28;
    }
    int v82 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
    if (v82 < 1) {
      goto LABEL_50;
    }
    int v83 = 0;
    int v84 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
    while (1)
    {
      int32x2_t v85 = (float32x4_t *)(*(void *)(a2 + 16) + 16 * *(_DWORD *)(a2 + 24) * v83);
      unsigned int v86 = (float32x4_t *)(*(void *)(a2 + 80) + 16 * *(_DWORD *)(a2 + 88) * v83);
      float32x4_t v88 = v86[-1];
      float32x4_t v87 = *v86;
      if (v84 >= 2) {
        break;
      }
      uint64_t v95 = (uint64_t)&v86[3];
      unsigned int v90 = v84;
      if (v84) {
        goto LABEL_47;
      }
LABEL_40:
      if (++v83 == v82) {
        goto LABEL_50;
      }
    }
    uint64_t v89 = 0;
    unsigned int v90 = v84;
    do
    {
      float32x4_t v91 = v88;
      float32x4_t v92 = v87;
      unsigned int v93 = v90;
      int v94 = &v85[v89];
      float32x4_t v88 = v86[v89 + 1];
      float32x4_t v87 = v86[v89 + 2];
      *int v94 = vaddq_f32(vmulq_f32(v61, v92), vmulq_f32(v62, vaddq_f32(v91, v88)));
      v94[1] = vaddq_f32(vmulq_f32(v61, v88), vmulq_f32(v62, vaddq_f32(v92, v87)));
      unsigned int v90 = v93 - 2;
      v89 += 2;
    }
    while (v93 > 3);
    uint64_t v95 = (uint64_t)&v86[v89 + 3];
    int32x2_t v85 = (float32x4_t *)((char *)v85 + v89 * 16);
    if (v93 == 2) {
      goto LABEL_40;
    }
LABEL_47:
    int32x2_t v96 = (float32x4_t *)(v95 - 32);
    do
    {
      float32x4_t v97 = v87;
      float32x4_t v98 = *v96++;
      float32x4_t v87 = v98;
      *v85++ = vaddq_f32(vmulq_f32(v61, v97), vmulq_f32(v62, vaddq_f32(v88, v98)));
      float32x4_t v88 = v97;
      --v90;
    }
    while (v90);
    goto LABEL_40;
  }
  int v6 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
  if (v6 >= 1)
  {
    int v7 = 0;
    float32x4_t v8 = *v5;
    float32x4_t v9 = v5[1];
    float32x4_t v10 = v5[2];
    float32x4_t v11 = v5[3];
    float32x4_t v12 = v5[4];
    int v13 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
    while (1)
    {
      float v14 = (float32x4_t *)(*(void *)(a2 + 16) + 16 * *(_DWORD *)(a2 + 24) * v7);
      uint64_t v15 = (float32x4_t *)(*(void *)(a2 + 80) + 16 * *(_DWORD *)(a2 + 88) * v7);
      float32x4_t v17 = v15[-4];
      float32x4_t v16 = v15[-3];
      float32x4_t v18 = v15[-2];
      float32x4_t v19 = v15[-1];
      float32x4_t v20 = *v15;
      float32x4_t v21 = v15[1];
      float32x4_t v22 = v15[2];
      float32x4_t v23 = v15[3];
      if (v13 >= 2) {
        break;
      }
      uint64_t v37 = (uint64_t)&v15[6];
      unsigned int v25 = v13;
      if (v13) {
        goto LABEL_11;
      }
LABEL_4:
      if (++v7 == v6) {
        goto LABEL_50;
      }
    }
    uint64_t v24 = 0;
    unsigned int v25 = v13;
    do
    {
      unsigned int v26 = v25;
      float32x4_t v27 = v23;
      float32x4_t v28 = v22;
      float32x4_t v29 = v21;
      float32x4_t v30 = v20;
      float32x4_t v31 = v19;
      float32x4_t v32 = v18;
      uint64_t v33 = &v14[v24];
      float32x4_t v22 = v15[v24 + 4];
      float32x4_t v23 = v15[v24 + 5];
      float32x4_t v34 = vaddq_f32(vaddq_f32(vmulq_f32(v10, vaddq_f32(v27, v19)), vaddq_f32(vmulq_f32(v8, v21), vmulq_f32(v9, vaddq_f32(v28, v20)))), vmulq_f32(v11, vaddq_f32(v18, v22)));
      float32x4_t v35 = vaddq_f32(vaddq_f32(vmulq_f32(v11, vaddq_f32(v27, v16)), vaddq_f32(vmulq_f32(v10, vaddq_f32(v28, v18)), vaddq_f32(vmulq_f32(v8, v20), vmulq_f32(v9, vaddq_f32(v21, v31))))), vmulq_f32(v12, vaddq_f32(v17, v22)));
      v25 -= 2;
      float32x4_t v36 = vaddq_f32(vmulq_f32(v12, vaddq_f32(v16, v23)), v34);
      v24 += 2;
      float32x4_t v17 = v18;
      float32x4_t v16 = v31;
      float32x4_t v18 = v30;
      *uint64_t v33 = v35;
      v33[1] = v36;
      float32x4_t v19 = v21;
      float32x4_t v20 = v28;
      float32x4_t v21 = v27;
    }
    while (v26 > 3);
    float v14 = (float32x4_t *)((char *)v14 + v24 * 16);
    uint64_t v37 = (uint64_t)&v15[v24 + 6];
    float32x4_t v21 = v27;
    float32x4_t v20 = v28;
    float32x4_t v19 = v29;
    float32x4_t v18 = v30;
    float32x4_t v16 = v31;
    float32x4_t v17 = v32;
    if (!v25) {
      goto LABEL_4;
    }
LABEL_11:
    int64_t v38 = (float32x4_t *)(v37 - 32);
    do
    {
      float32x4_t v39 = *v38++;
      *v14++ = vaddq_f32(vaddq_f32(vmulq_f32(v11, vaddq_f32(v23, v16)), vaddq_f32(vmulq_f32(v10, vaddq_f32(v22, v18)), vaddq_f32(vmulq_f32(v8, v20), vmulq_f32(v9, vaddq_f32(v21, v19))))), vmulq_f32(v12, vaddq_f32(v17, v39)));
      float32x4_t v17 = v16;
      float32x4_t v16 = v18;
      float32x4_t v18 = v19;
      float32x4_t v19 = v20;
      float32x4_t v20 = v21;
      float32x4_t v21 = v22;
      float32x4_t v22 = v23;
      float32x4_t v23 = v39;
      --v25;
    }
    while (v25);
    goto LABEL_4;
  }
LABEL_50:
  *(void *)(*(void *)(*(void *)(a2 + 336) + 416) + 80) += HGGetTBC() - v4;
  return 0;
}

const char *HGG9B<HgcBlur_cs9s_rect>::GetProgram(uint64_t a1, HGRenderer *a2)
{
  if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 43) != 1) {
    goto LABEL_11;
  }
  float v4 = *(float *)(a1 + 436) - *(float *)(a1 + 428);
  if ((float)(*(float *)(a1 + 432) - *(float *)(a1 + 424)) <= 0.0)
  {
    if (v4 <= 0.0) {
      goto LABEL_11;
    }
    goto LABEL_7;
  }
  float v5 = *(float *)(a1 + 416);
  BOOL v6 = v5 == 1.0;
  if (v5 != 1.0 && v4 > 0.0) {
LABEL_7:
  }
    BOOL v6 = *(float *)(a1 + 420) == 1.0;
  if (*(_DWORD *)(a1 + 440) == 1 && v6) {
    return "//Metal1.0     \n"
  }
           "//LEN=0000000e18\n"
           "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]],\n"
           "                                  const constant float4* hg_Params [[ buffer(0) ]],\n"
           "                                  texture2d< half > hg_Texture0 [[ texture(0) ]],\n"
           "                                  sampler hg_Sampler0 [[ sampler(0) ]])\n"
           "{\n"
           "    // Cast params to consts to workaround backend compiler issue\n"
           "    const float4 gaussianWeight0    (hg_Params[0]);\n"
           "    const float4 gaussianWeight1    (hg_Params[1]);\n"
           "    const float4 gaussianWeight2    (hg_Params[2]);\n"
           "    const float4 gaussianWeight3    (hg_Params[3]);\n"
           "    const float4 gaussianWeight4    (hg_Params[4]);\n"
           "    const float2 uvSet1Weight       (hg_Params[5].xy);\n"
           "    const float2 uvOffset           (hg_Params[6].xy);\n"
           "    const float2 blurDirection      (hg_Params[7].xy);\n"
           "    \n"
           "    const ushort2 screenPosition = ushort2(frag._position.xy);\n"
           "    const ushort isInRightColumn = screenPosition.x & 1;\n"
           "    const ushort isInLowerRow    = screenPosition.y & 1;\n"
           "    \n"
           "    const float2 uvCenter =  frag._texCoord0.xy + frag._texCoord1.xy * uvSet1Weight;\n"
           "    \n"
           "    const float2 L4coord = uvCenter + uvOffset;\n"
           "    const float2 L2coord = L4coord  + blurDirection * 2.0;\n"
           "    const float2 CCoord  = L2coord  + blurDirection * 2.0;\n"
           "    const float2 R2Coord = CCoord   + blurDirection * 2.0;\n"
           "    const float2 R4Coord = R2Coord  + blurDirection * 2.0;\n"
           "    const half4 tapL4 = hg_Texture0.sample(hg_Sampler0, L4coord);\n"
           "    const half4 tapL2 = hg_Texture0.sample(hg_Sampler0, L2coord);\n"
           "    const half4 tapC  = hg_Texture0.sample(hg_Sampler0, CCoord);\n"
           "    const half4 tapR2 = hg_Texture0.sample(hg_Sampler0, R2Coord);\n"
           "    const half4 tapR4 = hg_Texture0.sample(hg_Sampler0, R4Coord);\n"
           "    \n"
           "    // My lane               Vertical Blur Lanes   Horizontal Blur Lanes\n"
           "    // +--------+--------+   +--------+--------+   +--------+--------+\n"
           "    // | Lane 0 | Lane 1 |   | Lane 2 | Lane 3 |   | Lane 1 | Lane 0 |\n"
           "    // +--------+--------+   +--------+--------+   +--------+--------+\n"
           "    // | Lane 2 | Lane 3 |   | Lane 1 | Lane 0 |   | Lane 3 | Lane 2 |\n"
           "    // +--------+--------+   +--------+--------+   +--------+--------+\n"
           "    \n"
           "    const ushort isOddPixel = (uvOffset.x == 0) ? isInLowerRow : isInRightColumn;\n"
           "    const ushort otherLane  = ((uvOffset.x == 0) ?\n"
           "                               (isInRightColumn + (1 - isInLowerRow) * 2) :\n"
           "                               (1 - isInRightColumn + isInLowerRow * 2));\n"
           "    float4 accum(0);\n"
           "    \n"
           "    accum += float4(tapL4) * gaussianWeight4;\n"
           "    float4 otherValueL4 = float4(quad_shuffle(tapL4, otherLane));\n"
           "    accum += otherValueL4 * (isOddPixel ?               0 : gaussianWeight3);\n"
           "    \n"
           "    accum += float4(tapL2) * gaussianWeight2;\n"
           "    float4 otherValueL2 = float4(quad_shuffle(tapL2, otherLane));\n"
           "    accum += otherValueL2 * (isOddPixel ? gaussianWeight3 : gaussianWeight1);\n"
           "    \n"
           "    accum += float4(tapC)  * gaussianWeight0;\n"
           "    float4 otherValueC = float4(quad_shuffle(tapC, otherLane));\n"
           "    accum += otherValueC * gaussianWeight1;\n"
           "    \n"
           "    accum += float4(tapR2) * gaussianWeight2;\n"
           "    float4 otherValueR2 = float4(quad_shuffle(tapR2, otherLane));\n"
           "    accum += otherValueR2 * (isOddPixel ? gaussianWeight1 : gaussianWeight3);\n"
           "    \n"
           "    accum += float4(tapR4) * gaussianWeight4;\n"
           "    float4 otherValueR4 = float4(quad_shuffle(tapR4, otherLane));\n"
           "    accum += otherValueR4 * (isOddPixel ? gaussianWeight3 :               0);\n"
           "    \n"
           "    FragmentOut out;\n"
           "    out.color0 = accum;\n"
           "    return out;\n"
           "}\n"
           "//MD5=c152bbe4:3e592d82:afebeded:d45efc4f\n"
           "//SIG=00000000:00000000:00000000:00000001:000f:0008:0000:0000:0000:0000:0007:0000:0002:01:0:1:0\n";
LABEL_11:

  return HgcBlur_cs9s_rect::GetProgram((HgcBlur_cs9s_rect *)a1, a2);
}

uint64_t HGG9X<HgcBlur_cs9s_rect>::Bind(HGNode *a1, HGHandler *a2)
{
  uint64_t v3 = HGNode::Bind(a1, a2);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  return v3;
}

uint64_t HGG9X<HgcBlur_cs9s_rect>::BindTexture(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 144) + 128))(*(void *)(a2 + 144), 43) == 1)
  {
    HGHandler::TexCoord((HGHandler *)a2, a3, 0, 0, 0);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)a2 + 72))(a2, a3, 0);
    (*(void (**)(uint64_t, void))(*(void *)a2 + 56))(a2, 0);
    (*(void (**)(uint64_t, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    float v6 = *(float *)(a1 + 436) - *(float *)(a1 + 428);
    if ((float)(*(float *)(a1 + 432) - *(float *)(a1 + 424)) > 0.0)
    {
      float v7 = *(float *)(a1 + 416);
      BOOL v8 = v7 == 1.0;
      if (v7 == 1.0 || v6 <= 0.0)
      {
LABEL_10:
        if (*(_DWORD *)(a1 + 440) == 1 && v8) {
          return 0;
        }
        goto LABEL_13;
      }
LABEL_9:
      BOOL v8 = *(float *)(a1 + 420) == 1.0;
      goto LABEL_10;
    }
    if (v6 > 0.0) {
      goto LABEL_9;
    }
LABEL_13:
    (*(void (**)(uint64_t, uint64_t, double, double, float, float))(*(void *)a2 + 136))(a2, 8, 0.0, 0.0, 1.0, 1.0);
    return 0;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 144) + 128))(*(void *)(a2 + 144), 46))
  {
    HGHandler::TexCoord((HGHandler *)a2, a3, 0, 0, 0);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)a2 + 72))(a2, a3, 0);
    (*(void (**)(uint64_t, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    goto LABEL_13;
  }
  (*(void (**)(uint64_t, uint64_t, float, float, float, float))(*(void *)a2 + 136))(a2, 8, (float)*(int *)(a2 + 240), (float)*(int *)(a2 + 244), 1.0 / (float)(*(_DWORD *)(a2 + 228) - *(_DWORD *)(a2 + 220)), 1.0 / (float)(*(_DWORD *)(a2 + 232) - *(_DWORD *)(a2 + 224)));
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 144) + 128))(*(void *)(a2 + 144), 21)) {
    return 0;
  }
  unsigned int v10 = *(_DWORD *)(a2 + 228) - *(_DWORD *)(a2 + 220);
  unsigned int v11 = *(_DWORD *)(a2 + 232) - *(_DWORD *)(a2 + 224);
  (*(void (**)(uint64_t, uint64_t, float, float, float, float))(*(void *)a2 + 136))(a2, 9, (float)(v10 + 1) * 0.5, (float)(v11 + 1) * 0.5, (float)v10, (float)v11);
  return 0;
}

uint64_t HGG9B<HgcBlur_cs9s_rect>::IntermediateFormat(uint64_t a1, int a2)
{
  if (a2 <= 27) {
    return 27;
  }
  else {
    return a2;
  }
}

void HGG9B<HgcBlur_cs9s_rect>::InitProgramDescriptor(uint64_t a1, HGProgramDescriptor *a2)
{
  float v3 = *(float *)(a1 + 436) - *(float *)(a1 + 428);
  if ((float)(*(float *)(a1 + 432) - *(float *)(a1 + 424)) <= 0.0)
  {
    if (v3 <= 0.0) {
      goto LABEL_15;
    }
  }
  else
  {
    float v4 = *(float *)(a1 + 416);
    if (v4 == 1.0 || v3 <= 0.0)
    {
      if (*(_DWORD *)(a1 + 440) == 1 && v4 == 1.0) {
        goto LABEL_18;
      }
      goto LABEL_15;
    }
  }
  if (*(_DWORD *)(a1 + 440) == 1 && *(float *)(a1 + 420) == 1.0)
  {
LABEL_18:
    HGMetalUtils::stringForMetalHeader((uint64_t)&v29);
    HGMetalUtils::stringForMetalVertexOutputStruct((HGMetalUtils *)2, 0, (uint64_t)v27);
    if ((v28 & 0x80u) == 0) {
      float v7 = v27;
    }
    else {
      float v7 = (void **)v27[0];
    }
    if ((v28 & 0x80u) == 0) {
      std::string::size_type v8 = v28;
    }
    else {
      std::string::size_type v8 = (std::string::size_type)v27[1];
    }
    float32x4_t v9 = std::string::append(&v29, (const std::string::value_type *)v7, v8);
    long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    HGMetalUtils::stringForMetalVertexShader((HGMetalUtils *)"vertexFunc", (const char *)2, 0, (uint64_t)v25);
    if ((v26 & 0x80u) == 0) {
      unsigned int v11 = v25;
    }
    else {
      unsigned int v11 = (void **)v25[0];
    }
    if ((v26 & 0x80u) == 0) {
      std::string::size_type v12 = v26;
    }
    else {
      std::string::size_type v12 = (std::string::size_type)v25[1];
    }
    int v13 = std::string::append(&v30, (const std::string::value_type *)v11, v12);
    long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    HGMetalUtils::stringForMetalFragmentOutputStruct((HGMetalUtils *)1, 0, (uint64_t)__p);
    if ((v24 & 0x80u) == 0) {
      uint64_t v15 = __p;
    }
    else {
      uint64_t v15 = (void **)__p[0];
    }
    if ((v24 & 0x80u) == 0) {
      std::string::size_type v16 = v24;
    }
    else {
      std::string::size_type v16 = (std::string::size_type)__p[1];
    }
    float32x4_t v17 = std::string::append(&v31, (const std::string::value_type *)v15, v16);
    long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
    v22.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v18;
    v17->__r_.__value_.__l.__size_ = 0;
    v17->__r_.__value_.__r.__words[2] = 0;
    v17->__r_.__value_.__r.__words[0] = 0;
    float32x4_t v19 = std::string::append(&v22, "//Metal1.0     \n//LEN=0000000e18\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]],\n                                  const constant float4* hg_Params [[ buffer(0) ]],\n                                  texture2d< half > hg_Texture0 [[ texture(0) ]],\n                                  sampler hg_Sampler0 [[ sampler(0) ]])\n{\n    // Cast params to consts to workaround backend compiler issue\n    const float4 gaussianWeight0    (hg_Params[0]);\n"
            "    const float4 gaussianWeight1    (hg_Params[1]);\n"
            "    const float4 gaussianWeight2    (hg_Params[2]);\n"
            "    const float4 gaussianWeight3    (hg_Params[3]);\n"
            "    const float4 gaussianWeight4    (hg_Params[4]);\n"
            "    const float2 uvSet1Weight       (hg_Params[5].xy);\n"
            "    const float2 uvOffset           (hg_Params[6].xy);\n"
            "    const float2 blurDirection      (hg_Params[7].xy);\n"
            "    \n"
            "    const ushort2 screenPosition = ushort2(frag._position.xy);\n"
            "    const ushort isInRightColumn = screenPosition.x & 1;\n"
            "    const ushort isInLowerRow    = screenPosition.y & 1;\n"
            "    \n"
            "    const float2 uvCenter =  frag._texCoord0.xy + frag._texCoord1.xy * uvSet1Weight;\n"
            "    \n"
            "    const float2 L4coord = uvCenter + uvOffset;\n"
            "    const float2 L2coord = L4coord  + blurDirection * 2.0;\n"
            "    const float2 CCoord  = L2coord  + blurDirection * 2.0;\n"
            "    const float2 R2Coord = CCoord   + blurDirection * 2.0;\n"
            "    const float2 R4Coord = R2Coord  + blurDirection * 2.0;\n"
            "    const half4 tapL4 = hg_Texture0.sample(hg_Sampler0, L4coord);\n"
            "    const half4 tapL2 = hg_Texture0.sample(hg_Sampler0, L2coord);\n"
            "    const half4 tapC  = hg_Texture0.sample(hg_Sampler0, CCoord);\n"
            "    const half4 tapR2 = hg_Texture0.sample(hg_Sampler0, R2Coord);\n"
            "    const half4 tapR4 = hg_Texture0.sample(hg_Sampler0, R4Coord);\n"
            "    \n"
            "    // My lane               Vertical Blur Lanes   Horizontal Blur Lanes\n"
            "    // +--------+--------+   +--------+--------+   +--------+--------+\n"
            "    // | Lane 0 | Lane 1 |   | Lane 2 | Lane 3 |   | Lane 1 | Lane 0 |\n"
            "    // +--------+--------+   +--------+--------+   +--------+--------+\n"
            "    // | Lane 2 | Lane 3 |   | Lane 1 | Lane 0 |   | Lane 3 | Lane 2 |\n"
            "    // +--------+--------+   +--------+--------+   +--------+--------+\n"
            "    \n"
            "    const ushort isOddPixel = (uvOffset.x == 0) ? isInLowerRow : isInRightColumn;\n"
            "    const ushort otherLane  = ((uvOffset.x == 0) ?\n"
            "                               (isInRightColumn + (1 - isInLowerRow) * 2) :\n"
            "                               (1 - isInRightColumn + isInLowerRow * 2));\n"
            "    float4 accum(0);\n"
            "    \n"
            "    accum += float4(tapL4) * gaussianWeight4;\n"
            "    float4 otherValueL4 = float4(quad_shuffle(tapL4, otherLane));\n"
            "    accum += otherValueL4 * (isOddPixel ?               0 : gaussianWeight3);\n"
            "    \n"
            "    accum += float4(tapL2) * gaussianWeight2;\n"
            "    float4 otherValueL2 = float4(quad_shuffle(tapL2, otherLane));\n"
            "    accum += otherValueL2 * (isOddPixel ? gaussianWeight3 : gaussianWeight1);\n"
            "    \n"
            "    accum += float4(tapC)  * gaussianWeight0;\n"
            "    float4 otherValueC = float4(quad_shuffle(tapC, otherLane));\n"
            "    accum += otherValueC * gaussianWeight1;\n"
            "    \n"
            "    accum += float4(tapR2) * gaussianWeight2;\n"
            "    float4 otherValueR2 = float4(quad_shuffle(tapR2, otherLane));\n"
            "    accum += otherValueR2 * (isOddPixel ? gaussianWeight1 : gaussianWeight3);\n"
            "    \n"
            "    accum += float4(tapR4) * gaussianWeight4;\n"
            "    float4 otherValueR4 = float4(quad_shuffle(tapR4, otherLane));\n"
            "    accum += otherValueR4 * (isOddPixel ? gaussianWeight3 :               0);\n"
            "    \n"
            "    FragmentOut out;\n"
            "    out.color0 = accum;\n"
            "    return out;\n"
            "}\n"
            "//MD5=c152bbe4:3e592d82:afebeded:d45efc4f\n"
            "//SIG=00000000:00000000:00000000:00000001:000f:0008:0000:0000:0000:0000:0007:0000:0002:01:0:1:0\n");
    long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    int64_t v33 = v19->__r_.__value_.__r.__words[2];
    long long v32 = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v22.__r_.__value_.__l.__data_);
      if (((char)v24 & 0x80000000) == 0)
      {
LABEL_38:
        if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_39;
        }
        goto LABEL_49;
      }
    }
    else if (((char)v24 & 0x80000000) == 0)
    {
      goto LABEL_38;
    }
    operator delete(__p[0]);
    if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_39:
      if (((char)v26 & 0x80000000) == 0) {
        goto LABEL_40;
      }
      goto LABEL_50;
    }
LABEL_49:
    operator delete(v31.__r_.__value_.__l.__data_);
    if (((char)v26 & 0x80000000) == 0)
    {
LABEL_40:
      if ((SHIBYTE(v30.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_41;
      }
      goto LABEL_51;
    }
LABEL_50:
    operator delete(v25[0]);
    if ((SHIBYTE(v30.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_41:
      if (((char)v28 & 0x80000000) == 0) {
        goto LABEL_42;
      }
      goto LABEL_52;
    }
LABEL_51:
    operator delete(v30.__r_.__value_.__l.__data_);
    if (((char)v28 & 0x80000000) == 0)
    {
LABEL_42:
      if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_43;
      }
LABEL_53:
      operator delete(v29.__r_.__value_.__l.__data_);
LABEL_43:
      if (v33 >= 0) {
        float32x4_t v21 = (const char *)&v32;
      }
      else {
        float32x4_t v21 = (const char *)v32;
      }
      HGProgramDescriptor::SetShaderProgram(a2, v21);
    }
LABEL_52:
    operator delete(v27[0]);
    if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_43;
    }
    goto LABEL_53;
  }
LABEL_15:

  HgcBlur_cs9s_rect::InitProgramDescriptor((HgcBlur_cs9s_rect *)a1, a2);
}

void sub_1B77C1684(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *__p, int a13, __int16 a14, char a15, char a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100]((void **)(v46 - 96));
  if (*(char *)(v46 - 41) < 0) {
    operator delete(*(void **)(v46 - 64));
  }
  _Unwind_Resume(a1);
}

uint64_t HGG9B<HgcBlur_cs9s_rect>::GetDOD(float *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  return HGRectIntegral(HIDWORD(a4), (float)((float)(a1[106] + (float)(int)a4) / a1[104]) + 0.5, (float)((float)(a1[107] + (float)SHIDWORD(a4)) / a1[105]) + 0.5, (float)((float)((float)((float)(int)a5 + -1.0) + a1[108]) / a1[104]) + 0.5, (float)((float)((float)((float)SHIDWORD(a5) + -1.0) + a1[109]) / a1[105]) + 0.5);
}

uint64_t HGG9B<HgcBlur_cs9s_rect>::GetROI(float *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  return HGRectIntegral(HIDWORD(a4), a1[106] + (float)((float)(a1[104] * (float)(int)a4) + 0.5), a1[107] + (float)((float)(a1[105] * (float)SHIDWORD(a4)) + 0.5), (float)((float)((float)((float)(int)a5 + -1.0) * a1[104]) + 0.5) + a1[108], (float)((float)((float)((float)SHIDWORD(a5) + -1.0) * a1[105]) + 0.5) + a1[109]);
}

uint64_t HGG9X<HgcBlur_cs9s_rect>::GetFilterMode()
{
  return 0;
}

void HGG9X<HgcBlur_cs9s_es_noborder>::HGG9X(HgcBlur_cs9s_es_noborder *a1)
{
}

void sub_1B77C1A40(_Unwind_Exception *a1)
{
  HgcBlur_cs9s_es_noborder::~HgcBlur_cs9s_es_noborder(v1);
  _Unwind_Resume(a1);
}

void sub_1B77C1A54(_Unwind_Exception *a1)
{
  HgcBlur_cs9s_es_noborder::~HgcBlur_cs9s_es_noborder(v1);
  _Unwind_Resume(a1);
}

void HGG9X<HgcBlur_cs9s_es_noborder>::~HGG9X(HGNode *a1)
{
  HgcBlur_cs9s_es_noborder::~HgcBlur_cs9s_es_noborder(a1);

  HGObject::operator delete(v1);
}

const char *HGG9X<HgcBlur_cs9s_es_noborder>::label_A()
{
  return "HGG9X";
}

uint64_t HGG9X<HgcBlur_cs9s_es_noborder>::RenderTile(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = HGGetTBC();
  float v5 = *(float32x4_t **)(a1 + 48);
  if (v5[4].f32[0] == 0.0)
  {
    if (v5[3].f32[0] != 0.0)
    {
      int v40 = *(_DWORD *)(a2 + 8);
      int v41 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
      if (v41 >= 1 && v40 != *(_DWORD *)a2)
      {
        int v43 = 0;
        float32x4_t v44 = *v5;
        float32x4_t v45 = v5[1];
        int v46 = *(_DWORD *)a2 - v40;
        float32x4_t v47 = v5[2];
        float32x4_t v48 = v5[3];
        do
        {
          float v49 = (float32x4_t *)(*(void *)(a2 + 16) + 16 * *(_DWORD *)(a2 + 24) * v43);
          uint64_t v50 = (float32x4_t *)(*(void *)(a2 + 80) + 16 * *(_DWORD *)(a2 + 88) * v43);
          float32x4_t v52 = v50[-3];
          float32x4_t v51 = v50[-2];
          float32x4_t v53 = v50[-1];
          float32x4_t v54 = *v50;
          float32x4_t v55 = v50[1];
          float32x4_t v56 = v50[2];
          signed int v57 = v50 + 3;
          int v58 = v46;
          do
          {
            float32x4_t v59 = *v57++;
            *v49++ = vaddq_f32(vaddq_f32(vmulq_f32(v47, vaddq_f32(v56, v51)), vaddq_f32(vmulq_f32(v44, v54), vmulq_f32(v45, vaddq_f32(v55, v53)))), vmulq_f32(v48, vaddq_f32(v52, v59)));
            float32x4_t v52 = v51;
            float32x4_t v51 = v53;
            float32x4_t v53 = v54;
            float32x4_t v54 = v55;
            float32x4_t v55 = v56;
            float32x4_t v56 = v59;
          }
          while (!__CFADD__(v58++, 1));
          ++v43;
        }
        while (v43 != v41);
      }
      goto LABEL_50;
    }
    float32x4_t v61 = *v5;
    float32x4_t v62 = v5[1];
    if (v5[2].f32[0] != 0.0)
    {
      int v63 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
      if (v63 < 1) {
        goto LABEL_50;
      }
      int v64 = 0;
      float32x4_t v65 = v5[2];
      int v66 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
      while (1)
      {
        uint64_t v67 = (float32x4_t *)(*(void *)(a2 + 16) + 16 * *(_DWORD *)(a2 + 24) * v64);
        uint64_t v68 = (float32x4_t *)(*(void *)(a2 + 80) + 16 * *(_DWORD *)(a2 + 88) * v64);
        float32x4_t v70 = v68[-2];
        float32x4_t v69 = v68[-1];
        float32x4_t v71 = *v68;
        float32x4_t v72 = v68[1];
        if (v66 >= 2) {
          break;
        }
        uint64_t v79 = (uint64_t)&v68[4];
        unsigned int v74 = v66;
        if (v66) {
          goto LABEL_35;
        }
LABEL_28:
        if (++v64 == v63) {
          goto LABEL_50;
        }
      }
      uint64_t v73 = 0;
      unsigned int v74 = v66;
      do
      {
        float32x4_t v75 = v72;
        unsigned int v76 = v74;
        float32x4_t v77 = v71;
        uint64_t v78 = &v67[v73];
        float32x4_t v71 = v68[v73 + 2];
        float32x4_t v72 = v68[v73 + 3];
        v74 -= 2;
        *uint64_t v78 = vaddq_f32(vaddq_f32(vmulq_f32(v61, v77), vmulq_f32(v62, vaddq_f32(v75, v69))), vmulq_f32(v65, vaddq_f32(v70, v71)));
        v78[1] = vaddq_f32(vmulq_f32(v65, vaddq_f32(v69, v72)), vaddq_f32(vmulq_f32(v61, v75), vmulq_f32(v62, vaddq_f32(v77, v71))));
        v73 += 2;
        float32x4_t v70 = v77;
        float32x4_t v69 = v75;
      }
      while (v76 > 3);
      uint64_t v67 = (float32x4_t *)((char *)v67 + v73 * 16);
      uint64_t v79 = (uint64_t)&v68[v73 + 4];
      float32x4_t v69 = v75;
      float32x4_t v70 = v77;
      if (!v74) {
        goto LABEL_28;
      }
LABEL_35:
      long long v80 = (float32x4_t *)(v79 - 32);
      do
      {
        float32x4_t v81 = *v80++;
        *v67++ = vaddq_f32(vaddq_f32(vmulq_f32(v61, v71), vmulq_f32(v62, vaddq_f32(v72, v69))), vmulq_f32(v65, vaddq_f32(v70, v81)));
        float32x4_t v70 = v69;
        float32x4_t v69 = v71;
        float32x4_t v71 = v72;
        float32x4_t v72 = v81;
        --v74;
      }
      while (v74);
      goto LABEL_28;
    }
    int v82 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
    if (v82 < 1) {
      goto LABEL_50;
    }
    int v83 = 0;
    int v84 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
    while (1)
    {
      int32x2_t v85 = (float32x4_t *)(*(void *)(a2 + 16) + 16 * *(_DWORD *)(a2 + 24) * v83);
      unsigned int v86 = (float32x4_t *)(*(void *)(a2 + 80) + 16 * *(_DWORD *)(a2 + 88) * v83);
      float32x4_t v88 = v86[-1];
      float32x4_t v87 = *v86;
      if (v84 >= 2) {
        break;
      }
      uint64_t v95 = (uint64_t)&v86[3];
      unsigned int v90 = v84;
      if (v84) {
        goto LABEL_47;
      }
LABEL_40:
      if (++v83 == v82) {
        goto LABEL_50;
      }
    }
    uint64_t v89 = 0;
    unsigned int v90 = v84;
    do
    {
      float32x4_t v91 = v88;
      float32x4_t v92 = v87;
      unsigned int v93 = v90;
      int v94 = &v85[v89];
      float32x4_t v88 = v86[v89 + 1];
      float32x4_t v87 = v86[v89 + 2];
      *int v94 = vaddq_f32(vmulq_f32(v61, v92), vmulq_f32(v62, vaddq_f32(v91, v88)));
      v94[1] = vaddq_f32(vmulq_f32(v61, v88), vmulq_f32(v62, vaddq_f32(v92, v87)));
      unsigned int v90 = v93 - 2;
      v89 += 2;
    }
    while (v93 > 3);
    uint64_t v95 = (uint64_t)&v86[v89 + 3];
    int32x2_t v85 = (float32x4_t *)((char *)v85 + v89 * 16);
    if (v93 == 2) {
      goto LABEL_40;
    }
LABEL_47:
    int32x2_t v96 = (float32x4_t *)(v95 - 32);
    do
    {
      float32x4_t v97 = v87;
      float32x4_t v98 = *v96++;
      float32x4_t v87 = v98;
      *v85++ = vaddq_f32(vmulq_f32(v61, v97), vmulq_f32(v62, vaddq_f32(v88, v98)));
      float32x4_t v88 = v97;
      --v90;
    }
    while (v90);
    goto LABEL_40;
  }
  int v6 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
  if (v6 >= 1)
  {
    int v7 = 0;
    float32x4_t v8 = *v5;
    float32x4_t v9 = v5[1];
    float32x4_t v10 = v5[2];
    float32x4_t v11 = v5[3];
    float32x4_t v12 = v5[4];
    int v13 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
    while (1)
    {
      long long v14 = (float32x4_t *)(*(void *)(a2 + 16) + 16 * *(_DWORD *)(a2 + 24) * v7);
      uint64_t v15 = (float32x4_t *)(*(void *)(a2 + 80) + 16 * *(_DWORD *)(a2 + 88) * v7);
      float32x4_t v17 = v15[-4];
      float32x4_t v16 = v15[-3];
      float32x4_t v18 = v15[-2];
      float32x4_t v19 = v15[-1];
      float32x4_t v20 = *v15;
      float32x4_t v21 = v15[1];
      float32x4_t v22 = v15[2];
      float32x4_t v23 = v15[3];
      if (v13 >= 2) {
        break;
      }
      uint64_t v37 = (uint64_t)&v15[6];
      unsigned int v25 = v13;
      if (v13) {
        goto LABEL_11;
      }
LABEL_4:
      if (++v7 == v6) {
        goto LABEL_50;
      }
    }
    uint64_t v24 = 0;
    unsigned int v25 = v13;
    do
    {
      unsigned int v26 = v25;
      float32x4_t v27 = v23;
      float32x4_t v28 = v22;
      float32x4_t v29 = v21;
      float32x4_t v30 = v20;
      float32x4_t v31 = v19;
      float32x4_t v32 = v18;
      int64_t v33 = &v14[v24];
      float32x4_t v22 = v15[v24 + 4];
      float32x4_t v23 = v15[v24 + 5];
      float32x4_t v34 = vaddq_f32(vaddq_f32(vmulq_f32(v10, vaddq_f32(v27, v19)), vaddq_f32(vmulq_f32(v8, v21), vmulq_f32(v9, vaddq_f32(v28, v20)))), vmulq_f32(v11, vaddq_f32(v18, v22)));
      float32x4_t v35 = vaddq_f32(vaddq_f32(vmulq_f32(v11, vaddq_f32(v27, v16)), vaddq_f32(vmulq_f32(v10, vaddq_f32(v28, v18)), vaddq_f32(vmulq_f32(v8, v20), vmulq_f32(v9, vaddq_f32(v21, v31))))), vmulq_f32(v12, vaddq_f32(v17, v22)));
      v25 -= 2;
      float32x4_t v36 = vaddq_f32(vmulq_f32(v12, vaddq_f32(v16, v23)), v34);
      v24 += 2;
      float32x4_t v17 = v18;
      float32x4_t v16 = v31;
      float32x4_t v18 = v30;
      *int64_t v33 = v35;
      v33[1] = v36;
      float32x4_t v19 = v21;
      float32x4_t v20 = v28;
      float32x4_t v21 = v27;
    }
    while (v26 > 3);
    long long v14 = (float32x4_t *)((char *)v14 + v24 * 16);
    uint64_t v37 = (uint64_t)&v15[v24 + 6];
    float32x4_t v21 = v27;
    float32x4_t v20 = v28;
    float32x4_t v19 = v29;
    float32x4_t v18 = v30;
    float32x4_t v16 = v31;
    float32x4_t v17 = v32;
    if (!v25) {
      goto LABEL_4;
    }
LABEL_11:
    int64_t v38 = (float32x4_t *)(v37 - 32);
    do
    {
      float32x4_t v39 = *v38++;
      *v14++ = vaddq_f32(vaddq_f32(vmulq_f32(v11, vaddq_f32(v23, v16)), vaddq_f32(vmulq_f32(v10, vaddq_f32(v22, v18)), vaddq_f32(vmulq_f32(v8, v20), vmulq_f32(v9, vaddq_f32(v21, v19))))), vmulq_f32(v12, vaddq_f32(v17, v39)));
      float32x4_t v17 = v16;
      float32x4_t v16 = v18;
      float32x4_t v18 = v19;
      float32x4_t v19 = v20;
      float32x4_t v20 = v21;
      float32x4_t v21 = v22;
      float32x4_t v22 = v23;
      float32x4_t v23 = v39;
      --v25;
    }
    while (v25);
    goto LABEL_4;
  }
LABEL_50:
  *(void *)(*(void *)(*(void *)(a2 + 336) + 416) + 80) += HGGetTBC() - v4;
  return 0;
}

const char *HGG9B<HgcBlur_cs9s_es_noborder>::GetProgram(uint64_t a1, HGRenderer *a2)
{
  if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 43) != 1) {
    goto LABEL_11;
  }
  float v4 = *(float *)(a1 + 436) - *(float *)(a1 + 428);
  if ((float)(*(float *)(a1 + 432) - *(float *)(a1 + 424)) <= 0.0)
  {
    if (v4 <= 0.0) {
      goto LABEL_11;
    }
    goto LABEL_7;
  }
  float v5 = *(float *)(a1 + 416);
  BOOL v6 = v5 == 1.0;
  if (v5 != 1.0 && v4 > 0.0) {
LABEL_7:
  }
    BOOL v6 = *(float *)(a1 + 420) == 1.0;
  if (*(_DWORD *)(a1 + 440) == 1 && v6) {
    return "//Metal1.0     \n"
  }
           "//LEN=0000000e18\n"
           "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]],\n"
           "                                  const constant float4* hg_Params [[ buffer(0) ]],\n"
           "                                  texture2d< half > hg_Texture0 [[ texture(0) ]],\n"
           "                                  sampler hg_Sampler0 [[ sampler(0) ]])\n"
           "{\n"
           "    // Cast params to consts to workaround backend compiler issue\n"
           "    const float4 gaussianWeight0    (hg_Params[0]);\n"
           "    const float4 gaussianWeight1    (hg_Params[1]);\n"
           "    const float4 gaussianWeight2    (hg_Params[2]);\n"
           "    const float4 gaussianWeight3    (hg_Params[3]);\n"
           "    const float4 gaussianWeight4    (hg_Params[4]);\n"
           "    const float2 uvSet1Weight       (hg_Params[5].xy);\n"
           "    const float2 uvOffset           (hg_Params[6].xy);\n"
           "    const float2 blurDirection      (hg_Params[7].xy);\n"
           "    \n"
           "    const ushort2 screenPosition = ushort2(frag._position.xy);\n"
           "    const ushort isInRightColumn = screenPosition.x & 1;\n"
           "    const ushort isInLowerRow    = screenPosition.y & 1;\n"
           "    \n"
           "    const float2 uvCenter =  frag._texCoord0.xy + frag._texCoord1.xy * uvSet1Weight;\n"
           "    \n"
           "    const float2 L4coord = uvCenter + uvOffset;\n"
           "    const float2 L2coord = L4coord  + blurDirection * 2.0;\n"
           "    const float2 CCoord  = L2coord  + blurDirection * 2.0;\n"
           "    const float2 R2Coord = CCoord   + blurDirection * 2.0;\n"
           "    const float2 R4Coord = R2Coord  + blurDirection * 2.0;\n"
           "    const half4 tapL4 = hg_Texture0.sample(hg_Sampler0, L4coord);\n"
           "    const half4 tapL2 = hg_Texture0.sample(hg_Sampler0, L2coord);\n"
           "    const half4 tapC  = hg_Texture0.sample(hg_Sampler0, CCoord);\n"
           "    const half4 tapR2 = hg_Texture0.sample(hg_Sampler0, R2Coord);\n"
           "    const half4 tapR4 = hg_Texture0.sample(hg_Sampler0, R4Coord);\n"
           "    \n"
           "    // My lane               Vertical Blur Lanes   Horizontal Blur Lanes\n"
           "    // +--------+--------+   +--------+--------+   +--------+--------+\n"
           "    // | Lane 0 | Lane 1 |   | Lane 2 | Lane 3 |   | Lane 1 | Lane 0 |\n"
           "    // +--------+--------+   +--------+--------+   +--------+--------+\n"
           "    // | Lane 2 | Lane 3 |   | Lane 1 | Lane 0 |   | Lane 3 | Lane 2 |\n"
           "    // +--------+--------+   +--------+--------+   +--------+--------+\n"
           "    \n"
           "    const ushort isOddPixel = (uvOffset.x == 0) ? isInLowerRow : isInRightColumn;\n"
           "    const ushort otherLane  = ((uvOffset.x == 0) ?\n"
           "                               (isInRightColumn + (1 - isInLowerRow) * 2) :\n"
           "                               (1 - isInRightColumn + isInLowerRow * 2));\n"
           "    float4 accum(0);\n"
           "    \n"
           "    accum += float4(tapL4) * gaussianWeight4;\n"
           "    float4 otherValueL4 = float4(quad_shuffle(tapL4, otherLane));\n"
           "    accum += otherValueL4 * (isOddPixel ?               0 : gaussianWeight3);\n"
           "    \n"
           "    accum += float4(tapL2) * gaussianWeight2;\n"
           "    float4 otherValueL2 = float4(quad_shuffle(tapL2, otherLane));\n"
           "    accum += otherValueL2 * (isOddPixel ? gaussianWeight3 : gaussianWeight1);\n"
           "    \n"
           "    accum += float4(tapC)  * gaussianWeight0;\n"
           "    float4 otherValueC = float4(quad_shuffle(tapC, otherLane));\n"
           "    accum += otherValueC * gaussianWeight1;\n"
           "    \n"
           "    accum += float4(tapR2) * gaussianWeight2;\n"
           "    float4 otherValueR2 = float4(quad_shuffle(tapR2, otherLane));\n"
           "    accum += otherValueR2 * (isOddPixel ? gaussianWeight1 : gaussianWeight3);\n"
           "    \n"
           "    accum += float4(tapR4) * gaussianWeight4;\n"
           "    float4 otherValueR4 = float4(quad_shuffle(tapR4, otherLane));\n"
           "    accum += otherValueR4 * (isOddPixel ? gaussianWeight3 :               0);\n"
           "    \n"
           "    FragmentOut out;\n"
           "    out.color0 = accum;\n"
           "    return out;\n"
           "}\n"
           "//MD5=c152bbe4:3e592d82:afebeded:d45efc4f\n"
           "//SIG=00000000:00000000:00000000:00000001:000f:0008:0000:0000:0000:0000:0007:0000:0002:01:0:1:0\n";
LABEL_11:

  return HgcBlur_cs9s_es_noborder::GetProgram((HgcBlur_cs9s_es_noborder *)a1, a2);
}

uint64_t HGG9X<HgcBlur_cs9s_es_noborder>::Bind(HGNode *a1, HGHandler *a2)
{
  uint64_t v3 = HGNode::Bind(a1, a2);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  return v3;
}

uint64_t HGG9X<HgcBlur_cs9s_es_noborder>::BindTexture(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 144) + 128))(*(void *)(a2 + 144), 43) == 1)
  {
    HGHandler::TexCoord((HGHandler *)a2, a3, 0, 0, 0);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)a2 + 72))(a2, a3, 0);
    (*(void (**)(uint64_t, void))(*(void *)a2 + 56))(a2, 0);
    (*(void (**)(uint64_t, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    float v6 = *(float *)(a1 + 436) - *(float *)(a1 + 428);
    if ((float)(*(float *)(a1 + 432) - *(float *)(a1 + 424)) > 0.0)
    {
      float v7 = *(float *)(a1 + 416);
      BOOL v8 = v7 == 1.0;
      if (v7 == 1.0 || v6 <= 0.0)
      {
LABEL_10:
        if (*(_DWORD *)(a1 + 440) == 1 && v8) {
          return 0;
        }
        goto LABEL_13;
      }
LABEL_9:
      BOOL v8 = *(float *)(a1 + 420) == 1.0;
      goto LABEL_10;
    }
    if (v6 > 0.0) {
      goto LABEL_9;
    }
LABEL_13:
    (*(void (**)(uint64_t, uint64_t, double, double, float, float))(*(void *)a2 + 136))(a2, 8, 0.0, 0.0, 1.0, 1.0);
    return 0;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 144) + 128))(*(void *)(a2 + 144), 46))
  {
    HGHandler::TexCoord((HGHandler *)a2, a3, 0, 0, 0);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)a2 + 72))(a2, a3, 0);
    (*(void (**)(uint64_t, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    goto LABEL_13;
  }
  (*(void (**)(uint64_t, uint64_t, float, float, float, float))(*(void *)a2 + 136))(a2, 8, (float)*(int *)(a2 + 240), (float)*(int *)(a2 + 244), 1.0 / (float)(*(_DWORD *)(a2 + 228) - *(_DWORD *)(a2 + 220)), 1.0 / (float)(*(_DWORD *)(a2 + 232) - *(_DWORD *)(a2 + 224)));
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 144) + 128))(*(void *)(a2 + 144), 21)) {
    return 0;
  }
  unsigned int v10 = *(_DWORD *)(a2 + 228) - *(_DWORD *)(a2 + 220);
  unsigned int v11 = *(_DWORD *)(a2 + 232) - *(_DWORD *)(a2 + 224);
  (*(void (**)(uint64_t, uint64_t, float, float, float, float))(*(void *)a2 + 136))(a2, 9, (float)(v10 + 1) * 0.5, (float)(v11 + 1) * 0.5, (float)v10, (float)v11);
  return 0;
}

uint64_t HGG9B<HgcBlur_cs9s_es_noborder>::IntermediateFormat(uint64_t a1, int a2)
{
  if (a2 <= 27) {
    return 27;
  }
  else {
    return a2;
  }
}

void HGG9B<HgcBlur_cs9s_es_noborder>::InitProgramDescriptor(uint64_t a1, HGProgramDescriptor *a2)
{
  float v3 = *(float *)(a1 + 436) - *(float *)(a1 + 428);
  if ((float)(*(float *)(a1 + 432) - *(float *)(a1 + 424)) <= 0.0)
  {
    if (v3 <= 0.0) {
      goto LABEL_15;
    }
  }
  else
  {
    float v4 = *(float *)(a1 + 416);
    if (v4 == 1.0 || v3 <= 0.0)
    {
      if (*(_DWORD *)(a1 + 440) == 1 && v4 == 1.0) {
        goto LABEL_18;
      }
      goto LABEL_15;
    }
  }
  if (*(_DWORD *)(a1 + 440) == 1 && *(float *)(a1 + 420) == 1.0)
  {
LABEL_18:
    HGMetalUtils::stringForMetalHeader((uint64_t)&v29);
    HGMetalUtils::stringForMetalVertexOutputStruct((HGMetalUtils *)2, 0, (uint64_t)v27);
    if ((v28 & 0x80u) == 0) {
      float v7 = v27;
    }
    else {
      float v7 = (void **)v27[0];
    }
    if ((v28 & 0x80u) == 0) {
      std::string::size_type v8 = v28;
    }
    else {
      std::string::size_type v8 = (std::string::size_type)v27[1];
    }
    float32x4_t v9 = std::string::append(&v29, (const std::string::value_type *)v7, v8);
    long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    HGMetalUtils::stringForMetalVertexShader((HGMetalUtils *)"vertexFunc", (const char *)2, 0, (uint64_t)v25);
    if ((v26 & 0x80u) == 0) {
      unsigned int v11 = v25;
    }
    else {
      unsigned int v11 = (void **)v25[0];
    }
    if ((v26 & 0x80u) == 0) {
      std::string::size_type v12 = v26;
    }
    else {
      std::string::size_type v12 = (std::string::size_type)v25[1];
    }
    int v13 = std::string::append(&v30, (const std::string::value_type *)v11, v12);
    long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    HGMetalUtils::stringForMetalFragmentOutputStruct((HGMetalUtils *)1, 0, (uint64_t)__p);
    if ((v24 & 0x80u) == 0) {
      uint64_t v15 = __p;
    }
    else {
      uint64_t v15 = (void **)__p[0];
    }
    if ((v24 & 0x80u) == 0) {
      std::string::size_type v16 = v24;
    }
    else {
      std::string::size_type v16 = (std::string::size_type)__p[1];
    }
    float32x4_t v17 = std::string::append(&v31, (const std::string::value_type *)v15, v16);
    long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
    v22.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v18;
    v17->__r_.__value_.__l.__size_ = 0;
    v17->__r_.__value_.__r.__words[2] = 0;
    v17->__r_.__value_.__r.__words[0] = 0;
    float32x4_t v19 = std::string::append(&v22, "//Metal1.0     \n//LEN=0000000e18\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]],\n                                  const constant float4* hg_Params [[ buffer(0) ]],\n                                  texture2d< half > hg_Texture0 [[ texture(0) ]],\n                                  sampler hg_Sampler0 [[ sampler(0) ]])\n{\n    // Cast params to consts to workaround backend compiler issue\n    const float4 gaussianWeight0    (hg_Params[0]);\n"
            "    const float4 gaussianWeight1    (hg_Params[1]);\n"
            "    const float4 gaussianWeight2    (hg_Params[2]);\n"
            "    const float4 gaussianWeight3    (hg_Params[3]);\n"
            "    const float4 gaussianWeight4    (hg_Params[4]);\n"
            "    const float2 uvSet1Weight       (hg_Params[5].xy);\n"
            "    const float2 uvOffset           (hg_Params[6].xy);\n"
            "    const float2 blurDirection      (hg_Params[7].xy);\n"
            "    \n"
            "    const ushort2 screenPosition = ushort2(frag._position.xy);\n"
            "    const ushort isInRightColumn = screenPosition.x & 1;\n"
            "    const ushort isInLowerRow    = screenPosition.y & 1;\n"
            "    \n"
            "    const float2 uvCenter =  frag._texCoord0.xy + frag._texCoord1.xy * uvSet1Weight;\n"
            "    \n"
            "    const float2 L4coord = uvCenter + uvOffset;\n"
            "    const float2 L2coord = L4coord  + blurDirection * 2.0;\n"
            "    const float2 CCoord  = L2coord  + blurDirection * 2.0;\n"
            "    const float2 R2Coord = CCoord   + blurDirection * 2.0;\n"
            "    const float2 R4Coord = R2Coord  + blurDirection * 2.0;\n"
            "    const half4 tapL4 = hg_Texture0.sample(hg_Sampler0, L4coord);\n"
            "    const half4 tapL2 = hg_Texture0.sample(hg_Sampler0, L2coord);\n"
            "    const half4 tapC  = hg_Texture0.sample(hg_Sampler0, CCoord);\n"
            "    const half4 tapR2 = hg_Texture0.sample(hg_Sampler0, R2Coord);\n"
            "    const half4 tapR4 = hg_Texture0.sample(hg_Sampler0, R4Coord);\n"
            "    \n"
            "    // My lane               Vertical Blur Lanes   Horizontal Blur Lanes\n"
            "    // +--------+--------+   +--------+--------+   +--------+--------+\n"
            "    // | Lane 0 | Lane 1 |   | Lane 2 | Lane 3 |   | Lane 1 | Lane 0 |\n"
            "    // +--------+--------+   +--------+--------+   +--------+--------+\n"
            "    // | Lane 2 | Lane 3 |   | Lane 1 | Lane 0 |   | Lane 3 | Lane 2 |\n"
            "    // +--------+--------+   +--------+--------+   +--------+--------+\n"
            "    \n"
            "    const ushort isOddPixel = (uvOffset.x == 0) ? isInLowerRow : isInRightColumn;\n"
            "    const ushort otherLane  = ((uvOffset.x == 0) ?\n"
            "                               (isInRightColumn + (1 - isInLowerRow) * 2) :\n"
            "                               (1 - isInRightColumn + isInLowerRow * 2));\n"
            "    float4 accum(0);\n"
            "    \n"
            "    accum += float4(tapL4) * gaussianWeight4;\n"
            "    float4 otherValueL4 = float4(quad_shuffle(tapL4, otherLane));\n"
            "    accum += otherValueL4 * (isOddPixel ?               0 : gaussianWeight3);\n"
            "    \n"
            "    accum += float4(tapL2) * gaussianWeight2;\n"
            "    float4 otherValueL2 = float4(quad_shuffle(tapL2, otherLane));\n"
            "    accum += otherValueL2 * (isOddPixel ? gaussianWeight3 : gaussianWeight1);\n"
            "    \n"
            "    accum += float4(tapC)  * gaussianWeight0;\n"
            "    float4 otherValueC = float4(quad_shuffle(tapC, otherLane));\n"
            "    accum += otherValueC * gaussianWeight1;\n"
            "    \n"
            "    accum += float4(tapR2) * gaussianWeight2;\n"
            "    float4 otherValueR2 = float4(quad_shuffle(tapR2, otherLane));\n"
            "    accum += otherValueR2 * (isOddPixel ? gaussianWeight1 : gaussianWeight3);\n"
            "    \n"
            "    accum += float4(tapR4) * gaussianWeight4;\n"
            "    float4 otherValueR4 = float4(quad_shuffle(tapR4, otherLane));\n"
            "    accum += otherValueR4 * (isOddPixel ? gaussianWeight3 :               0);\n"
            "    \n"
            "    FragmentOut out;\n"
            "    out.color0 = accum;\n"
            "    return out;\n"
            "}\n"
            "//MD5=c152bbe4:3e592d82:afebeded:d45efc4f\n"
            "//SIG=00000000:00000000:00000000:00000001:000f:0008:0000:0000:0000:0000:0007:0000:0002:01:0:1:0\n");
    long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    int64_t v33 = v19->__r_.__value_.__r.__words[2];
    long long v32 = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v22.__r_.__value_.__l.__data_);
      if (((char)v24 & 0x80000000) == 0)
      {
LABEL_38:
        if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_39;
        }
        goto LABEL_49;
      }
    }
    else if (((char)v24 & 0x80000000) == 0)
    {
      goto LABEL_38;
    }
    operator delete(__p[0]);
    if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_39:
      if (((char)v26 & 0x80000000) == 0) {
        goto LABEL_40;
      }
      goto LABEL_50;
    }
LABEL_49:
    operator delete(v31.__r_.__value_.__l.__data_);
    if (((char)v26 & 0x80000000) == 0)
    {
LABEL_40:
      if ((SHIBYTE(v30.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_41;
      }
      goto LABEL_51;
    }
LABEL_50:
    operator delete(v25[0]);
    if ((SHIBYTE(v30.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_41:
      if (((char)v28 & 0x80000000) == 0) {
        goto LABEL_42;
      }
      goto LABEL_52;
    }
LABEL_51:
    operator delete(v30.__r_.__value_.__l.__data_);
    if (((char)v28 & 0x80000000) == 0)
    {
LABEL_42:
      if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_43;
      }
LABEL_53:
      operator delete(v29.__r_.__value_.__l.__data_);
LABEL_43:
      if (v33 >= 0) {
        float32x4_t v21 = (const char *)&v32;
      }
      else {
        float32x4_t v21 = (const char *)v32;
      }
      HGProgramDescriptor::SetShaderProgram(a2, v21);
    }
LABEL_52:
    operator delete(v27[0]);
    if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_43;
    }
    goto LABEL_53;
  }
LABEL_15:

  HgcBlur_cs9s_es_noborder::InitProgramDescriptor((HgcBlur_cs9s_es_noborder *)a1, a2);
}

void sub_1B77C2C2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *__p, int a13, __int16 a14, char a15, char a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100]((void **)(v46 - 96));
  if (*(char *)(v46 - 41) < 0) {
    operator delete(*(void **)(v46 - 64));
  }
  _Unwind_Resume(a1);
}

uint64_t HGG9B<HgcBlur_cs9s_es_noborder>::GetDOD(float *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  return HGRectIntegral(HIDWORD(a4), (float)((float)(a1[106] + (float)(int)a4) / a1[104]) + 0.5, (float)((float)(a1[107] + (float)SHIDWORD(a4)) / a1[105]) + 0.5, (float)((float)((float)((float)(int)a5 + -1.0) + a1[108]) / a1[104]) + 0.5, (float)((float)((float)((float)SHIDWORD(a5) + -1.0) + a1[109]) / a1[105]) + 0.5);
}

uint64_t HGG9B<HgcBlur_cs9s_es_noborder>::GetROI(float *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  return HGRectIntegral(HIDWORD(a4), a1[106] + (float)((float)(a1[104] * (float)(int)a4) + 0.5), a1[107] + (float)((float)(a1[105] * (float)SHIDWORD(a4)) + 0.5), (float)((float)((float)((float)(int)a5 + -1.0) * a1[104]) + 0.5) + a1[108], (float)((float)((float)((float)SHIDWORD(a5) + -1.0) * a1[105]) + 0.5) + a1[109]);
}

uint64_t HGG9X<HgcBlur_cs9s_es_noborder>::GetFilterMode()
{
  return 0;
}

void HGG9X<HgcBlur_cs9s>::HGG9X(HgcBlur_cs9s *a1)
{
}

void sub_1B77C2FE8(_Unwind_Exception *a1)
{
  HgcBlur_cs9s::~HgcBlur_cs9s(v1);
  _Unwind_Resume(a1);
}

void sub_1B77C2FFC(_Unwind_Exception *a1)
{
  HgcBlur_cs9s::~HgcBlur_cs9s(v1);
  _Unwind_Resume(a1);
}

void HGG9X<HgcBlur_cs9s>::~HGG9X(HGNode *a1)
{
  HgcBlur_cs9s::~HgcBlur_cs9s(a1);

  HGObject::operator delete(v1);
}

const char *HGG9X<HgcBlur_cs9s>::label_A()
{
  return "HGG9X";
}

uint64_t HGG9X<HgcBlur_cs9s>::RenderTile(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = HGGetTBC();
  float v5 = *(float32x4_t **)(a1 + 48);
  if (v5[4].f32[0] == 0.0)
  {
    if (v5[3].f32[0] != 0.0)
    {
      int v40 = *(_DWORD *)(a2 + 8);
      int v41 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
      if (v41 >= 1 && v40 != *(_DWORD *)a2)
      {
        int v43 = 0;
        float32x4_t v44 = *v5;
        float32x4_t v45 = v5[1];
        int v46 = *(_DWORD *)a2 - v40;
        float32x4_t v47 = v5[2];
        float32x4_t v48 = v5[3];
        do
        {
          float v49 = (float32x4_t *)(*(void *)(a2 + 16) + 16 * *(_DWORD *)(a2 + 24) * v43);
          uint64_t v50 = (float32x4_t *)(*(void *)(a2 + 80) + 16 * *(_DWORD *)(a2 + 88) * v43);
          float32x4_t v52 = v50[-3];
          float32x4_t v51 = v50[-2];
          float32x4_t v53 = v50[-1];
          float32x4_t v54 = *v50;
          float32x4_t v55 = v50[1];
          float32x4_t v56 = v50[2];
          signed int v57 = v50 + 3;
          int v58 = v46;
          do
          {
            float32x4_t v59 = *v57++;
            *v49++ = vaddq_f32(vaddq_f32(vmulq_f32(v47, vaddq_f32(v56, v51)), vaddq_f32(vmulq_f32(v44, v54), vmulq_f32(v45, vaddq_f32(v55, v53)))), vmulq_f32(v48, vaddq_f32(v52, v59)));
            float32x4_t v52 = v51;
            float32x4_t v51 = v53;
            float32x4_t v53 = v54;
            float32x4_t v54 = v55;
            float32x4_t v55 = v56;
            float32x4_t v56 = v59;
          }
          while (!__CFADD__(v58++, 1));
          ++v43;
        }
        while (v43 != v41);
      }
      goto LABEL_50;
    }
    float32x4_t v61 = *v5;
    float32x4_t v62 = v5[1];
    if (v5[2].f32[0] != 0.0)
    {
      int v63 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
      if (v63 < 1) {
        goto LABEL_50;
      }
      int v64 = 0;
      float32x4_t v65 = v5[2];
      int v66 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
      while (1)
      {
        uint64_t v67 = (float32x4_t *)(*(void *)(a2 + 16) + 16 * *(_DWORD *)(a2 + 24) * v64);
        uint64_t v68 = (float32x4_t *)(*(void *)(a2 + 80) + 16 * *(_DWORD *)(a2 + 88) * v64);
        float32x4_t v70 = v68[-2];
        float32x4_t v69 = v68[-1];
        float32x4_t v71 = *v68;
        float32x4_t v72 = v68[1];
        if (v66 >= 2) {
          break;
        }
        uint64_t v79 = (uint64_t)&v68[4];
        unsigned int v74 = v66;
        if (v66) {
          goto LABEL_35;
        }
LABEL_28:
        if (++v64 == v63) {
          goto LABEL_50;
        }
      }
      uint64_t v73 = 0;
      unsigned int v74 = v66;
      do
      {
        float32x4_t v75 = v72;
        unsigned int v76 = v74;
        float32x4_t v77 = v71;
        uint64_t v78 = &v67[v73];
        float32x4_t v71 = v68[v73 + 2];
        float32x4_t v72 = v68[v73 + 3];
        v74 -= 2;
        *uint64_t v78 = vaddq_f32(vaddq_f32(vmulq_f32(v61, v77), vmulq_f32(v62, vaddq_f32(v75, v69))), vmulq_f32(v65, vaddq_f32(v70, v71)));
        v78[1] = vaddq_f32(vmulq_f32(v65, vaddq_f32(v69, v72)), vaddq_f32(vmulq_f32(v61, v75), vmulq_f32(v62, vaddq_f32(v77, v71))));
        v73 += 2;
        float32x4_t v70 = v77;
        float32x4_t v69 = v75;
      }
      while (v76 > 3);
      uint64_t v67 = (float32x4_t *)((char *)v67 + v73 * 16);
      uint64_t v79 = (uint64_t)&v68[v73 + 4];
      float32x4_t v69 = v75;
      float32x4_t v70 = v77;
      if (!v74) {
        goto LABEL_28;
      }
LABEL_35:
      long long v80 = (float32x4_t *)(v79 - 32);
      do
      {
        float32x4_t v81 = *v80++;
        *v67++ = vaddq_f32(vaddq_f32(vmulq_f32(v61, v71), vmulq_f32(v62, vaddq_f32(v72, v69))), vmulq_f32(v65, vaddq_f32(v70, v81)));
        float32x4_t v70 = v69;
        float32x4_t v69 = v71;
        float32x4_t v71 = v72;
        float32x4_t v72 = v81;
        --v74;
      }
      while (v74);
      goto LABEL_28;
    }
    int v82 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
    if (v82 < 1) {
      goto LABEL_50;
    }
    int v83 = 0;
    int v84 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
    while (1)
    {
      int32x2_t v85 = (float32x4_t *)(*(void *)(a2 + 16) + 16 * *(_DWORD *)(a2 + 24) * v83);
      unsigned int v86 = (float32x4_t *)(*(void *)(a2 + 80) + 16 * *(_DWORD *)(a2 + 88) * v83);
      float32x4_t v88 = v86[-1];
      float32x4_t v87 = *v86;
      if (v84 >= 2) {
        break;
      }
      uint64_t v95 = (uint64_t)&v86[3];
      unsigned int v90 = v84;
      if (v84) {
        goto LABEL_47;
      }
LABEL_40:
      if (++v83 == v82) {
        goto LABEL_50;
      }
    }
    uint64_t v89 = 0;
    unsigned int v90 = v84;
    do
    {
      float32x4_t v91 = v88;
      float32x4_t v92 = v87;
      unsigned int v93 = v90;
      int v94 = &v85[v89];
      float32x4_t v88 = v86[v89 + 1];
      float32x4_t v87 = v86[v89 + 2];
      *int v94 = vaddq_f32(vmulq_f32(v61, v92), vmulq_f32(v62, vaddq_f32(v91, v88)));
      v94[1] = vaddq_f32(vmulq_f32(v61, v88), vmulq_f32(v62, vaddq_f32(v92, v87)));
      unsigned int v90 = v93 - 2;
      v89 += 2;
    }
    while (v93 > 3);
    uint64_t v95 = (uint64_t)&v86[v89 + 3];
    int32x2_t v85 = (float32x4_t *)((char *)v85 + v89 * 16);
    if (v93 == 2) {
      goto LABEL_40;
    }
LABEL_47:
    int32x2_t v96 = (float32x4_t *)(v95 - 32);
    do
    {
      float32x4_t v97 = v87;
      float32x4_t v98 = *v96++;
      float32x4_t v87 = v98;
      *v85++ = vaddq_f32(vmulq_f32(v61, v97), vmulq_f32(v62, vaddq_f32(v88, v98)));
      float32x4_t v88 = v97;
      --v90;
    }
    while (v90);
    goto LABEL_40;
  }
  int v6 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
  if (v6 >= 1)
  {
    int v7 = 0;
    float32x4_t v8 = *v5;
    float32x4_t v9 = v5[1];
    float32x4_t v10 = v5[2];
    float32x4_t v11 = v5[3];
    float32x4_t v12 = v5[4];
    int v13 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
    while (1)
    {
      long long v14 = (float32x4_t *)(*(void *)(a2 + 16) + 16 * *(_DWORD *)(a2 + 24) * v7);
      uint64_t v15 = (float32x4_t *)(*(void *)(a2 + 80) + 16 * *(_DWORD *)(a2 + 88) * v7);
      float32x4_t v17 = v15[-4];
      float32x4_t v16 = v15[-3];
      float32x4_t v18 = v15[-2];
      float32x4_t v19 = v15[-1];
      float32x4_t v20 = *v15;
      float32x4_t v21 = v15[1];
      float32x4_t v22 = v15[2];
      float32x4_t v23 = v15[3];
      if (v13 >= 2) {
        break;
      }
      uint64_t v37 = (uint64_t)&v15[6];
      unsigned int v25 = v13;
      if (v13) {
        goto LABEL_11;
      }
LABEL_4:
      if (++v7 == v6) {
        goto LABEL_50;
      }
    }
    uint64_t v24 = 0;
    unsigned int v25 = v13;
    do
    {
      unsigned int v26 = v25;
      float32x4_t v27 = v23;
      float32x4_t v28 = v22;
      float32x4_t v29 = v21;
      float32x4_t v30 = v20;
      float32x4_t v31 = v19;
      float32x4_t v32 = v18;
      int64_t v33 = &v14[v24];
      float32x4_t v22 = v15[v24 + 4];
      float32x4_t v23 = v15[v24 + 5];
      float32x4_t v34 = vaddq_f32(vaddq_f32(vmulq_f32(v10, vaddq_f32(v27, v19)), vaddq_f32(vmulq_f32(v8, v21), vmulq_f32(v9, vaddq_f32(v28, v20)))), vmulq_f32(v11, vaddq_f32(v18, v22)));
      float32x4_t v35 = vaddq_f32(vaddq_f32(vmulq_f32(v11, vaddq_f32(v27, v16)), vaddq_f32(vmulq_f32(v10, vaddq_f32(v28, v18)), vaddq_f32(vmulq_f32(v8, v20), vmulq_f32(v9, vaddq_f32(v21, v31))))), vmulq_f32(v12, vaddq_f32(v17, v22)));
      v25 -= 2;
      float32x4_t v36 = vaddq_f32(vmulq_f32(v12, vaddq_f32(v16, v23)), v34);
      v24 += 2;
      float32x4_t v17 = v18;
      float32x4_t v16 = v31;
      float32x4_t v18 = v30;
      *int64_t v33 = v35;
      v33[1] = v36;
      float32x4_t v19 = v21;
      float32x4_t v20 = v28;
      float32x4_t v21 = v27;
    }
    while (v26 > 3);
    long long v14 = (float32x4_t *)((char *)v14 + v24 * 16);
    uint64_t v37 = (uint64_t)&v15[v24 + 6];
    float32x4_t v21 = v27;
    float32x4_t v20 = v28;
    float32x4_t v19 = v29;
    float32x4_t v18 = v30;
    float32x4_t v16 = v31;
    float32x4_t v17 = v32;
    if (!v25) {
      goto LABEL_4;
    }
LABEL_11:
    int64_t v38 = (float32x4_t *)(v37 - 32);
    do
    {
      float32x4_t v39 = *v38++;
      *v14++ = vaddq_f32(vaddq_f32(vmulq_f32(v11, vaddq_f32(v23, v16)), vaddq_f32(vmulq_f32(v10, vaddq_f32(v22, v18)), vaddq_f32(vmulq_f32(v8, v20), vmulq_f32(v9, vaddq_f32(v21, v19))))), vmulq_f32(v12, vaddq_f32(v17, v39)));
      float32x4_t v17 = v16;
      float32x4_t v16 = v18;
      float32x4_t v18 = v19;
      float32x4_t v19 = v20;
      float32x4_t v20 = v21;
      float32x4_t v21 = v22;
      float32x4_t v22 = v23;
      float32x4_t v23 = v39;
      --v25;
    }
    while (v25);
    goto LABEL_4;
  }
LABEL_50:
  *(void *)(*(void *)(*(void *)(a2 + 336) + 416) + 80) += HGGetTBC() - v4;
  return 0;
}

const char *HGG9B<HgcBlur_cs9s>::GetProgram(uint64_t a1, HGRenderer *a2)
{
  if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 43) != 1) {
    goto LABEL_11;
  }
  float v4 = *(float *)(a1 + 436) - *(float *)(a1 + 428);
  if ((float)(*(float *)(a1 + 432) - *(float *)(a1 + 424)) <= 0.0)
  {
    if (v4 <= 0.0) {
      goto LABEL_11;
    }
    goto LABEL_7;
  }
  float v5 = *(float *)(a1 + 416);
  BOOL v6 = v5 == 1.0;
  if (v5 != 1.0 && v4 > 0.0) {
LABEL_7:
  }
    BOOL v6 = *(float *)(a1 + 420) == 1.0;
  if (*(_DWORD *)(a1 + 440) == 1 && v6) {
    return "//Metal1.0     \n"
  }
           "//LEN=0000000e18\n"
           "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]],\n"
           "                                  const constant float4* hg_Params [[ buffer(0) ]],\n"
           "                                  texture2d< half > hg_Texture0 [[ texture(0) ]],\n"
           "                                  sampler hg_Sampler0 [[ sampler(0) ]])\n"
           "{\n"
           "    // Cast params to consts to workaround backend compiler issue\n"
           "    const float4 gaussianWeight0    (hg_Params[0]);\n"
           "    const float4 gaussianWeight1    (hg_Params[1]);\n"
           "    const float4 gaussianWeight2    (hg_Params[2]);\n"
           "    const float4 gaussianWeight3    (hg_Params[3]);\n"
           "    const float4 gaussianWeight4    (hg_Params[4]);\n"
           "    const float2 uvSet1Weight       (hg_Params[5].xy);\n"
           "    const float2 uvOffset           (hg_Params[6].xy);\n"
           "    const float2 blurDirection      (hg_Params[7].xy);\n"
           "    \n"
           "    const ushort2 screenPosition = ushort2(frag._position.xy);\n"
           "    const ushort isInRightColumn = screenPosition.x & 1;\n"
           "    const ushort isInLowerRow    = screenPosition.y & 1;\n"
           "    \n"
           "    const float2 uvCenter =  frag._texCoord0.xy + frag._texCoord1.xy * uvSet1Weight;\n"
           "    \n"
           "    const float2 L4coord = uvCenter + uvOffset;\n"
           "    const float2 L2coord = L4coord  + blurDirection * 2.0;\n"
           "    const float2 CCoord  = L2coord  + blurDirection * 2.0;\n"
           "    const float2 R2Coord = CCoord   + blurDirection * 2.0;\n"
           "    const float2 R4Coord = R2Coord  + blurDirection * 2.0;\n"
           "    const half4 tapL4 = hg_Texture0.sample(hg_Sampler0, L4coord);\n"
           "    const half4 tapL2 = hg_Texture0.sample(hg_Sampler0, L2coord);\n"
           "    const half4 tapC  = hg_Texture0.sample(hg_Sampler0, CCoord);\n"
           "    const half4 tapR2 = hg_Texture0.sample(hg_Sampler0, R2Coord);\n"
           "    const half4 tapR4 = hg_Texture0.sample(hg_Sampler0, R4Coord);\n"
           "    \n"
           "    // My lane               Vertical Blur Lanes   Horizontal Blur Lanes\n"
           "    // +--------+--------+   +--------+--------+   +--------+--------+\n"
           "    // | Lane 0 | Lane 1 |   | Lane 2 | Lane 3 |   | Lane 1 | Lane 0 |\n"
           "    // +--------+--------+   +--------+--------+   +--------+--------+\n"
           "    // | Lane 2 | Lane 3 |   | Lane 1 | Lane 0 |   | Lane 3 | Lane 2 |\n"
           "    // +--------+--------+   +--------+--------+   +--------+--------+\n"
           "    \n"
           "    const ushort isOddPixel = (uvOffset.x == 0) ? isInLowerRow : isInRightColumn;\n"
           "    const ushort otherLane  = ((uvOffset.x == 0) ?\n"
           "                               (isInRightColumn + (1 - isInLowerRow) * 2) :\n"
           "                               (1 - isInRightColumn + isInLowerRow * 2));\n"
           "    float4 accum(0);\n"
           "    \n"
           "    accum += float4(tapL4) * gaussianWeight4;\n"
           "    float4 otherValueL4 = float4(quad_shuffle(tapL4, otherLane));\n"
           "    accum += otherValueL4 * (isOddPixel ?               0 : gaussianWeight3);\n"
           "    \n"
           "    accum += float4(tapL2) * gaussianWeight2;\n"
           "    float4 otherValueL2 = float4(quad_shuffle(tapL2, otherLane));\n"
           "    accum += otherValueL2 * (isOddPixel ? gaussianWeight3 : gaussianWeight1);\n"
           "    \n"
           "    accum += float4(tapC)  * gaussianWeight0;\n"
           "    float4 otherValueC = float4(quad_shuffle(tapC, otherLane));\n"
           "    accum += otherValueC * gaussianWeight1;\n"
           "    \n"
           "    accum += float4(tapR2) * gaussianWeight2;\n"
           "    float4 otherValueR2 = float4(quad_shuffle(tapR2, otherLane));\n"
           "    accum += otherValueR2 * (isOddPixel ? gaussianWeight1 : gaussianWeight3);\n"
           "    \n"
           "    accum += float4(tapR4) * gaussianWeight4;\n"
           "    float4 otherValueR4 = float4(quad_shuffle(tapR4, otherLane));\n"
           "    accum += otherValueR4 * (isOddPixel ? gaussianWeight3 :               0);\n"
           "    \n"
           "    FragmentOut out;\n"
           "    out.color0 = accum;\n"
           "    return out;\n"
           "}\n"
           "//MD5=c152bbe4:3e592d82:afebeded:d45efc4f\n"
           "//SIG=00000000:00000000:00000000:00000001:000f:0008:0000:0000:0000:0000:0007:0000:0002:01:0:1:0\n";
LABEL_11:

  return HgcBlur_cs9s::GetProgram((HgcBlur_cs9s *)a1, a2);
}

uint64_t HGG9X<HgcBlur_cs9s>::Bind(HGNode *a1, HGHandler *a2)
{
  uint64_t v3 = HGNode::Bind(a1, a2);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  return v3;
}

uint64_t HGG9X<HgcBlur_cs9s>::BindTexture(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 144) + 128))(*(void *)(a2 + 144), 43) == 1)
  {
    HGHandler::TexCoord((HGHandler *)a2, a3, 0, 0, 0);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)a2 + 72))(a2, a3, 0);
    (*(void (**)(uint64_t, void))(*(void *)a2 + 56))(a2, 0);
    (*(void (**)(uint64_t, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    float v6 = *(float *)(a1 + 436) - *(float *)(a1 + 428);
    if ((float)(*(float *)(a1 + 432) - *(float *)(a1 + 424)) > 0.0)
    {
      float v7 = *(float *)(a1 + 416);
      BOOL v8 = v7 == 1.0;
      if (v7 == 1.0 || v6 <= 0.0)
      {
LABEL_10:
        if (*(_DWORD *)(a1 + 440) == 1 && v8) {
          return 0;
        }
        goto LABEL_13;
      }
LABEL_9:
      BOOL v8 = *(float *)(a1 + 420) == 1.0;
      goto LABEL_10;
    }
    if (v6 > 0.0) {
      goto LABEL_9;
    }
LABEL_13:
    (*(void (**)(uint64_t, uint64_t, double, double, float, float))(*(void *)a2 + 136))(a2, 8, 0.0, 0.0, 1.0, 1.0);
    return 0;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 144) + 128))(*(void *)(a2 + 144), 46))
  {
    HGHandler::TexCoord((HGHandler *)a2, a3, 0, 0, 0);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)a2 + 72))(a2, a3, 0);
    (*(void (**)(uint64_t, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    goto LABEL_13;
  }
  (*(void (**)(uint64_t, uint64_t, float, float, float, float))(*(void *)a2 + 136))(a2, 8, (float)*(int *)(a2 + 240), (float)*(int *)(a2 + 244), 1.0 / (float)(*(_DWORD *)(a2 + 228) - *(_DWORD *)(a2 + 220)), 1.0 / (float)(*(_DWORD *)(a2 + 232) - *(_DWORD *)(a2 + 224)));
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 144) + 128))(*(void *)(a2 + 144), 21)) {
    return 0;
  }
  unsigned int v10 = *(_DWORD *)(a2 + 228) - *(_DWORD *)(a2 + 220);
  unsigned int v11 = *(_DWORD *)(a2 + 232) - *(_DWORD *)(a2 + 224);
  (*(void (**)(uint64_t, uint64_t, float, float, float, float))(*(void *)a2 + 136))(a2, 9, (float)(v10 + 1) * 0.5, (float)(v11 + 1) * 0.5, (float)v10, (float)v11);
  return 0;
}

uint64_t HGG9B<HgcBlur_cs9s>::IntermediateFormat(uint64_t a1, int a2)
{
  if (a2 <= 27) {
    return 27;
  }
  else {
    return a2;
  }
}

void HGG9B<HgcBlur_cs9s>::InitProgramDescriptor(uint64_t a1, HGProgramDescriptor *a2)
{
  float v3 = *(float *)(a1 + 436) - *(float *)(a1 + 428);
  if ((float)(*(float *)(a1 + 432) - *(float *)(a1 + 424)) <= 0.0)
  {
    if (v3 <= 0.0) {
      goto LABEL_15;
    }
  }
  else
  {
    float v4 = *(float *)(a1 + 416);
    if (v4 == 1.0 || v3 <= 0.0)
    {
      if (*(_DWORD *)(a1 + 440) == 1 && v4 == 1.0) {
        goto LABEL_18;
      }
      goto LABEL_15;
    }
  }
  if (*(_DWORD *)(a1 + 440) == 1 && *(float *)(a1 + 420) == 1.0)
  {
LABEL_18:
    HGMetalUtils::stringForMetalHeader((uint64_t)&v29);
    HGMetalUtils::stringForMetalVertexOutputStruct((HGMetalUtils *)2, 0, (uint64_t)v27);
    if ((v28 & 0x80u) == 0) {
      float v7 = v27;
    }
    else {
      float v7 = (void **)v27[0];
    }
    if ((v28 & 0x80u) == 0) {
      std::string::size_type v8 = v28;
    }
    else {
      std::string::size_type v8 = (std::string::size_type)v27[1];
    }
    float32x4_t v9 = std::string::append(&v29, (const std::string::value_type *)v7, v8);
    long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    HGMetalUtils::stringForMetalVertexShader((HGMetalUtils *)"vertexFunc", (const char *)2, 0, (uint64_t)v25);
    if ((v26 & 0x80u) == 0) {
      unsigned int v11 = v25;
    }
    else {
      unsigned int v11 = (void **)v25[0];
    }
    if ((v26 & 0x80u) == 0) {
      std::string::size_type v12 = v26;
    }
    else {
      std::string::size_type v12 = (std::string::size_type)v25[1];
    }
    int v13 = std::string::append(&v30, (const std::string::value_type *)v11, v12);
    long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    HGMetalUtils::stringForMetalFragmentOutputStruct((HGMetalUtils *)1, 0, (uint64_t)__p);
    if ((v24 & 0x80u) == 0) {
      uint64_t v15 = __p;
    }
    else {
      uint64_t v15 = (void **)__p[0];
    }
    if ((v24 & 0x80u) == 0) {
      std::string::size_type v16 = v24;
    }
    else {
      std::string::size_type v16 = (std::string::size_type)__p[1];
    }
    float32x4_t v17 = std::string::append(&v31, (const std::string::value_type *)v15, v16);
    long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
    v22.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v18;
    v17->__r_.__value_.__l.__size_ = 0;
    v17->__r_.__value_.__r.__words[2] = 0;
    v17->__r_.__value_.__r.__words[0] = 0;
    float32x4_t v19 = std::string::append(&v22, "//Metal1.0     \n//LEN=0000000e18\nfragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]],\n                                  const constant float4* hg_Params [[ buffer(0) ]],\n                                  texture2d< half > hg_Texture0 [[ texture(0) ]],\n                                  sampler hg_Sampler0 [[ sampler(0) ]])\n{\n    // Cast params to consts to workaround backend compiler issue\n    const float4 gaussianWeight0    (hg_Params[0]);\n"
            "    const float4 gaussianWeight1    (hg_Params[1]);\n"
            "    const float4 gaussianWeight2    (hg_Params[2]);\n"
            "    const float4 gaussianWeight3    (hg_Params[3]);\n"
            "    const float4 gaussianWeight4    (hg_Params[4]);\n"
            "    const float2 uvSet1Weight       (hg_Params[5].xy);\n"
            "    const float2 uvOffset           (hg_Params[6].xy);\n"
            "    const float2 blurDirection      (hg_Params[7].xy);\n"
            "    \n"
            "    const ushort2 screenPosition = ushort2(frag._position.xy);\n"
            "    const ushort isInRightColumn = screenPosition.x & 1;\n"
            "    const ushort isInLowerRow    = screenPosition.y & 1;\n"
            "    \n"
            "    const float2 uvCenter =  frag._texCoord0.xy + frag._texCoord1.xy * uvSet1Weight;\n"
            "    \n"
            "    const float2 L4coord = uvCenter + uvOffset;\n"
            "    const float2 L2coord = L4coord  + blurDirection * 2.0;\n"
            "    const float2 CCoord  = L2coord  + blurDirection * 2.0;\n"
            "    const float2 R2Coord = CCoord   + blurDirection * 2.0;\n"
            "    const float2 R4Coord = R2Coord  + blurDirection * 2.0;\n"
            "    const half4 tapL4 = hg_Texture0.sample(hg_Sampler0, L4coord);\n"
            "    const half4 tapL2 = hg_Texture0.sample(hg_Sampler0, L2coord);\n"
            "    const half4 tapC  = hg_Texture0.sample(hg_Sampler0, CCoord);\n"
            "    const half4 tapR2 = hg_Texture0.sample(hg_Sampler0, R2Coord);\n"
            "    const half4 tapR4 = hg_Texture0.sample(hg_Sampler0, R4Coord);\n"
            "    \n"
            "    // My lane               Vertical Blur Lanes   Horizontal Blur Lanes\n"
            "    // +--------+--------+   +--------+--------+   +--------+--------+\n"
            "    // | Lane 0 | Lane 1 |   | Lane 2 | Lane 3 |   | Lane 1 | Lane 0 |\n"
            "    // +--------+--------+   +--------+--------+   +--------+--------+\n"
            "    // | Lane 2 | Lane 3 |   | Lane 1 | Lane 0 |   | Lane 3 | Lane 2 |\n"
            "    // +--------+--------+   +--------+--------+   +--------+--------+\n"
            "    \n"
            "    const ushort isOddPixel = (uvOffset.x == 0) ? isInLowerRow : isInRightColumn;\n"
            "    const ushort otherLane  = ((uvOffset.x == 0) ?\n"
            "                               (isInRightColumn + (1 - isInLowerRow) * 2) :\n"
            "                               (1 - isInRightColumn + isInLowerRow * 2));\n"
            "    float4 accum(0);\n"
            "    \n"
            "    accum += float4(tapL4) * gaussianWeight4;\n"
            "    float4 otherValueL4 = float4(quad_shuffle(tapL4, otherLane));\n"
            "    accum += otherValueL4 * (isOddPixel ?               0 : gaussianWeight3);\n"
            "    \n"
            "    accum += float4(tapL2) * gaussianWeight2;\n"
            "    float4 otherValueL2 = float4(quad_shuffle(tapL2, otherLane));\n"
            "    accum += otherValueL2 * (isOddPixel ? gaussianWeight3 : gaussianWeight1);\n"
            "    \n"
            "    accum += float4(tapC)  * gaussianWeight0;\n"
            "    float4 otherValueC = float4(quad_shuffle(tapC, otherLane));\n"
            "    accum += otherValueC * gaussianWeight1;\n"
            "    \n"
            "    accum += float4(tapR2) * gaussianWeight2;\n"
            "    float4 otherValueR2 = float4(quad_shuffle(tapR2, otherLane));\n"
            "    accum += otherValueR2 * (isOddPixel ? gaussianWeight1 : gaussianWeight3);\n"
            "    \n"
            "    accum += float4(tapR4) * gaussianWeight4;\n"
            "    float4 otherValueR4 = float4(quad_shuffle(tapR4, otherLane));\n"
            "    accum += otherValueR4 * (isOddPixel ? gaussianWeight3 :               0);\n"
            "    \n"
            "    FragmentOut out;\n"
            "    out.color0 = accum;\n"
            "    return out;\n"
            "}\n"
            "//MD5=c152bbe4:3e592d82:afebeded:d45efc4f\n"
            "//SIG=00000000:00000000:00000000:00000001:000f:0008:0000:0000:0000:0000:0007:0000:0002:01:0:1:0\n");
    long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    int64_t v33 = v19->__r_.__value_.__r.__words[2];
    long long v32 = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v22.__r_.__value_.__l.__data_);
      if (((char)v24 & 0x80000000) == 0)
      {
LABEL_38:
        if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_39;
        }
        goto LABEL_49;
      }
    }
    else if (((char)v24 & 0x80000000) == 0)
    {
      goto LABEL_38;
    }
    operator delete(__p[0]);
    if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_39:
      if (((char)v26 & 0x80000000) == 0) {
        goto LABEL_40;
      }
      goto LABEL_50;
    }
LABEL_49:
    operator delete(v31.__r_.__value_.__l.__data_);
    if (((char)v26 & 0x80000000) == 0)
    {
LABEL_40:
      if ((SHIBYTE(v30.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_41;
      }
      goto LABEL_51;
    }
LABEL_50:
    operator delete(v25[0]);
    if ((SHIBYTE(v30.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_41:
      if (((char)v28 & 0x80000000) == 0) {
        goto LABEL_42;
      }
      goto LABEL_52;
    }
LABEL_51:
    operator delete(v30.__r_.__value_.__l.__data_);
    if (((char)v28 & 0x80000000) == 0)
    {
LABEL_42:
      if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_43;
      }
LABEL_53:
      operator delete(v29.__r_.__value_.__l.__data_);
LABEL_43:
      if (v33 >= 0) {
        float32x4_t v21 = (const char *)&v32;
      }
      else {
        float32x4_t v21 = (const char *)v32;
      }
      HGProgramDescriptor::SetShaderProgram(a2, v21);
    }
LABEL_52:
    operator delete(v27[0]);
    if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_43;
    }
    goto LABEL_53;
  }
LABEL_15:

  HgcBlur_cs9s::InitProgramDescriptor((HgcBlur_cs9s *)a1, a2);
}

void sub_1B77C41D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *__p, int a13, __int16 a14, char a15, char a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,int a43,__int16 a44,char a45,char a46)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100]((void **)(v46 - 96));
  if (*(char *)(v46 - 41) < 0) {
    operator delete(*(void **)(v46 - 64));
  }
  _Unwind_Resume(a1);
}

uint64_t HGG9B<HgcBlur_cs9s>::GetDOD(float *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  return HGRectIntegral(HIDWORD(a4), (float)((float)(a1[106] + (float)(int)a4) / a1[104]) + 0.5, (float)((float)(a1[107] + (float)SHIDWORD(a4)) / a1[105]) + 0.5, (float)((float)((float)((float)(int)a5 + -1.0) + a1[108]) / a1[104]) + 0.5, (float)((float)((float)((float)SHIDWORD(a5) + -1.0) + a1[109]) / a1[105]) + 0.5);
}

uint64_t HGG9B<HgcBlur_cs9s>::GetROI(float *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  return HGRectIntegral(HIDWORD(a4), a1[106] + (float)((float)(a1[104] * (float)(int)a4) + 0.5), a1[107] + (float)((float)(a1[105] * (float)SHIDWORD(a4)) + 0.5), (float)((float)((float)((float)(int)a5 + -1.0) * a1[104]) + 0.5) + a1[108], (float)((float)((float)((float)SHIDWORD(a5) + -1.0) * a1[105]) + 0.5) + a1[109]);
}

uint64_t HGG9X<HgcBlur_cs9s>::GetFilterMode()
{
  return 0;
}

void HGG9Y<HgcBlur_cs9s_rect>::~HGG9Y(HGNode *a1)
{
  HgcBlur_cs9s_rect::~HgcBlur_cs9s_rect(a1);

  HGObject::operator delete(v1);
}

const char *HGG9Y<HgcBlur_cs9s_rect>::label_A()
{
  return "HGG9Y";
}

uint64_t HGG9Y<HgcBlur_cs9s_rect>::RenderTile(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = HGGetTBC();
  float v5 = *(float32x4_t **)(a1 + 48);
  int8x16_t v6 = (int8x16_t)vceqzq_f32(v5[2]);
  *(int32x2_t *)v6.i8 = vpmax_s32(*(int32x2_t *)v6.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  if (vpmax_s32(*(int32x2_t *)v6.i8, *(int32x2_t *)v6.i8).u32[0])
  {
    uint64_t v7 = 0xFFFFFFFFLL;
    int v8 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
    if (v8 < 1) {
      goto LABEL_34;
    }
    goto LABEL_10;
  }
  int8x16_t v9 = (int8x16_t)vceqzq_f32(v5[3]);
  *(int32x2_t *)v9.i8 = vpmax_s32(*(int32x2_t *)v9.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL));
  if (vpmax_s32(*(int32x2_t *)v9.i8, *(int32x2_t *)v9.i8).u32[0])
  {
    uint64_t v7 = 4294967294;
    int v8 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
    if (v8 < 1) {
      goto LABEL_34;
    }
    goto LABEL_10;
  }
  int8x16_t v10 = (int8x16_t)vceqzq_f32(v5[4]);
  *(int32x2_t *)v10.i8 = vpmax_s32(*(int32x2_t *)v10.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v10, v10, 8uLL));
  uint64_t v7 = 4294967292;
  if (vpmax_s32(*(int32x2_t *)v10.i8, *(int32x2_t *)v10.i8).u32[0]) {
    uint64_t v7 = 4294967293;
  }
  int v8 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
  if (v8 >= 1)
  {
LABEL_10:
    int v11 = 0;
    int v12 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
    int v13 = -(int)v7;
    int v14 = v7;
    do
    {
      int v15 = v13;
      int v16 = v14;
      uint64_t v17 = v7;
      do
      {
        float32x4_t v18 = *(float32x4_t *)(*(void *)(a1 + 48) + ((-16 * v17) & 0xFFFFFFFF0));
        uint64_t v19 = *(void *)(a2 + 16);
        int v20 = *(_DWORD *)(a2 + 24);
        float32x4_t v21 = (float32x4_t *)(v19 + 16 * v20 * v11);
        uint64_t v22 = *(void *)(a2 + 80);
        int v23 = *(_DWORD *)(a2 + 88);
        unsigned __int8 v24 = (float32x4_t *)(v22 + 16 * v23 * (v11 + (int)v17));
        unsigned int v25 = (float32x4_t *)(v22 + 16 * v23 * (v11 - (int)v17));
        unsigned int v26 = v12;
        if (v17 == v7)
        {
          if (v12 >= 4)
          {
            uint64_t v27 = 0;
            uint64_t v28 = v19 + 16 * v11 * v20;
            uint64_t v29 = v22 + 16 * v23 * v16;
            uint64_t v30 = v22 + 16 * v23 * v15;
            unsigned int v26 = v12;
            do
            {
              unsigned int v31 = v26;
              long long v32 = (float32x4_t *)(v28 + v27);
              float32x4_t v33 = vmulq_f32(v18, vaddq_f32(*(float32x4_t *)(v29 + v27 + 16), *(float32x4_t *)(v30 + v27 + 16)));
              float32x4_t v34 = vmulq_f32(v18, vaddq_f32(*(float32x4_t *)(v29 + v27 + 32), *(float32x4_t *)(v30 + v27 + 32)));
              float32x4_t v35 = vmulq_f32(v18, vaddq_f32(*(float32x4_t *)(v29 + v27 + 48), *(float32x4_t *)(v30 + v27 + 48)));
              *long long v32 = vmulq_f32(v18, vaddq_f32(*(float32x4_t *)(v29 + v27), *(float32x4_t *)(v30 + v27)));
              v32[1] = v33;
              uint64_t v32[2] = v34;
              v32[3] = v35;
              unsigned int v26 = v31 - 4;
              v27 += 64;
            }
            while (v31 > 7);
            float32x4_t v21 = (float32x4_t *)(v28 + v27);
            unsigned __int8 v24 = (float32x4_t *)(v29 + v27);
            unsigned int v25 = (float32x4_t *)(v30 + v27);
          }
          for (; v26; --v26)
          {
            float32x4_t v36 = *v24++;
            float32x4_t v37 = v36;
            float32x4_t v38 = *v25++;
            *v21++ = vmulq_f32(v18, vaddq_f32(v37, v38));
          }
        }
        else
        {
          if (v12 >= 4)
          {
            uint64_t v39 = 0;
            uint64_t v40 = v19 + 16 * v11 * v20;
            uint64_t v41 = v22 + 16 * v23 * v16;
            uint64_t v42 = v22 + 16 * v23 * v15;
            unsigned int v26 = v12;
            do
            {
              unsigned int v43 = v26;
              float32x4_t v44 = (float32x4_t *)(v40 + v39);
              float32x4_t v45 = vaddq_f32(vmulq_f32(v18, vaddq_f32(*(float32x4_t *)(v41 + v39 + 16), *(float32x4_t *)(v42 + v39 + 16))), *(float32x4_t *)(v40 + v39 + 16));
              float32x4_t v46 = vaddq_f32(vmulq_f32(v18, vaddq_f32(*(float32x4_t *)(v41 + v39 + 32), *(float32x4_t *)(v42 + v39 + 32))), *(float32x4_t *)(v40 + v39 + 32));
              float32x4_t v47 = vaddq_f32(vmulq_f32(v18, vaddq_f32(*(float32x4_t *)(v41 + v39 + 48), *(float32x4_t *)(v42 + v39 + 48))), *(float32x4_t *)(v40 + v39 + 48));
              *float32x4_t v44 = vaddq_f32(vmulq_f32(v18, vaddq_f32(*(float32x4_t *)(v41 + v39), *(float32x4_t *)(v42 + v39))), *(float32x4_t *)(v40 + v39));
              v44[1] = v45;
              v44[2] = v46;
              v44[3] = v47;
              unsigned int v26 = v43 - 4;
              v39 += 64;
            }
            while (v43 > 7);
            float32x4_t v21 = (float32x4_t *)(v40 + v39);
            unsigned __int8 v24 = (float32x4_t *)(v41 + v39);
            unsigned int v25 = (float32x4_t *)(v42 + v39);
          }
          for (; v26; --v26)
          {
            float32x4_t v48 = *v24++;
            float32x4_t v49 = v48;
            float32x4_t v50 = *v25++;
            float32x4_t *v21 = vaddq_f32(*v21, vmulq_f32(v18, vaddq_f32(v49, v50)));
            ++v21;
          }
        }
        ++v16;
        --v15;
        ++v17;
      }
      while (v17);
      float32x4_t v51 = *(float32x4_t *)*(void *)(a1 + 48);
      float32x4_t v52 = (float32x4_t *)(*(void *)(a2 + 16) + 16 * *(_DWORD *)(a2 + 24) * v11);
      float32x4_t v53 = (float32x4_t *)(*(void *)(a2 + 80) + 16 * *(_DWORD *)(a2 + 88) * v11);
      unsigned int v54 = v12;
      if (v12 >= 4)
      {
        do
        {
          unsigned int v55 = v54;
          float32x4_t v56 = vaddq_f32(vmulq_f32(v51, v53[1]), v52[1]);
          float32x4_t v57 = vaddq_f32(vmulq_f32(v51, v53[2]), v52[2]);
          float32x4_t v58 = vaddq_f32(vmulq_f32(v51, v53[3]), v52[3]);
          *float32x4_t v52 = vaddq_f32(vmulq_f32(v51, *v53), *v52);
          v52[1] = v56;
          v52[2] = v57;
          v52[3] = v58;
          v53 += 4;
          v52 += 4;
          v54 -= 4;
        }
        while (v55 > 7);
      }
      for (; v54; --v54)
      {
        float32x4_t v59 = *v53++;
        *float32x4_t v52 = vaddq_f32(vmulq_f32(v51, v59), *v52);
        ++v52;
      }
      ++v11;
      ++v14;
      ++v13;
    }
    while (v11 != v8);
  }
LABEL_34:
  *(void *)(*(void *)(*(void *)(a2 + 336) + 416) + 80) += HGGetTBC() - v4;
  return 0;
}

uint64_t HGG9Y<HgcBlur_cs9s_rect>::GetFilterMode()
{
  return 0;
}

void HGG9Y<HgcBlur_cs9s_es_noborder>::~HGG9Y(HGNode *a1)
{
  HgcBlur_cs9s_es_noborder::~HgcBlur_cs9s_es_noborder(a1);

  HGObject::operator delete(v1);
}

const char *HGG9Y<HgcBlur_cs9s_es_noborder>::label_A()
{
  return "HGG9Y";
}

uint64_t HGG9Y<HgcBlur_cs9s_es_noborder>::RenderTile(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = HGGetTBC();
  float v5 = *(float32x4_t **)(a1 + 48);
  int8x16_t v6 = (int8x16_t)vceqzq_f32(v5[2]);
  *(int32x2_t *)v6.i8 = vpmax_s32(*(int32x2_t *)v6.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  if (vpmax_s32(*(int32x2_t *)v6.i8, *(int32x2_t *)v6.i8).u32[0])
  {
    uint64_t v7 = 0xFFFFFFFFLL;
    int v8 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
    if (v8 < 1) {
      goto LABEL_34;
    }
    goto LABEL_10;
  }
  int8x16_t v9 = (int8x16_t)vceqzq_f32(v5[3]);
  *(int32x2_t *)v9.i8 = vpmax_s32(*(int32x2_t *)v9.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL));
  if (vpmax_s32(*(int32x2_t *)v9.i8, *(int32x2_t *)v9.i8).u32[0])
  {
    uint64_t v7 = 4294967294;
    int v8 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
    if (v8 < 1) {
      goto LABEL_34;
    }
    goto LABEL_10;
  }
  int8x16_t v10 = (int8x16_t)vceqzq_f32(v5[4]);
  *(int32x2_t *)v10.i8 = vpmax_s32(*(int32x2_t *)v10.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v10, v10, 8uLL));
  uint64_t v7 = 4294967292;
  if (vpmax_s32(*(int32x2_t *)v10.i8, *(int32x2_t *)v10.i8).u32[0]) {
    uint64_t v7 = 4294967293;
  }
  int v8 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
  if (v8 >= 1)
  {
LABEL_10:
    int v11 = 0;
    int v12 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
    int v13 = -(int)v7;
    int v14 = v7;
    do
    {
      int v15 = v13;
      int v16 = v14;
      uint64_t v17 = v7;
      do
      {
        float32x4_t v18 = *(float32x4_t *)(*(void *)(a1 + 48) + ((-16 * v17) & 0xFFFFFFFF0));
        uint64_t v19 = *(void *)(a2 + 16);
        int v20 = *(_DWORD *)(a2 + 24);
        float32x4_t v21 = (float32x4_t *)(v19 + 16 * v20 * v11);
        uint64_t v22 = *(void *)(a2 + 80);
        int v23 = *(_DWORD *)(a2 + 88);
        unsigned __int8 v24 = (float32x4_t *)(v22 + 16 * v23 * (v11 + (int)v17));
        unsigned int v25 = (float32x4_t *)(v22 + 16 * v23 * (v11 - (int)v17));
        unsigned int v26 = v12;
        if (v17 == v7)
        {
          if (v12 >= 4)
          {
            uint64_t v27 = 0;
            uint64_t v28 = v19 + 16 * v11 * v20;
            uint64_t v29 = v22 + 16 * v23 * v16;
            uint64_t v30 = v22 + 16 * v23 * v15;
            unsigned int v26 = v12;
            do
            {
              unsigned int v31 = v26;
              long long v32 = (float32x4_t *)(v28 + v27);
              float32x4_t v33 = vmulq_f32(v18, vaddq_f32(*(float32x4_t *)(v29 + v27 + 16), *(float32x4_t *)(v30 + v27 + 16)));
              float32x4_t v34 = vmulq_f32(v18, vaddq_f32(*(float32x4_t *)(v29 + v27 + 32), *(float32x4_t *)(v30 + v27 + 32)));
              float32x4_t v35 = vmulq_f32(v18, vaddq_f32(*(float32x4_t *)(v29 + v27 + 48), *(float32x4_t *)(v30 + v27 + 48)));
              *long long v32 = vmulq_f32(v18, vaddq_f32(*(float32x4_t *)(v29 + v27), *(float32x4_t *)(v30 + v27)));
              v32[1] = v33;
              uint64_t v32[2] = v34;
              v32[3] = v35;
              unsigned int v26 = v31 - 4;
              v27 += 64;
            }
            while (v31 > 7);
            float32x4_t v21 = (float32x4_t *)(v28 + v27);
            unsigned __int8 v24 = (float32x4_t *)(v29 + v27);
            unsigned int v25 = (float32x4_t *)(v30 + v27);
          }
          for (; v26; --v26)
          {
            float32x4_t v36 = *v24++;
            float32x4_t v37 = v36;
            float32x4_t v38 = *v25++;
            *v21++ = vmulq_f32(v18, vaddq_f32(v37, v38));
          }
        }
        else
        {
          if (v12 >= 4)
          {
            uint64_t v39 = 0;
            uint64_t v40 = v19 + 16 * v11 * v20;
            uint64_t v41 = v22 + 16 * v23 * v16;
            uint64_t v42 = v22 + 16 * v23 * v15;
            unsigned int v26 = v12;
            do
            {
              unsigned int v43 = v26;
              float32x4_t v44 = (float32x4_t *)(v40 + v39);
              float32x4_t v45 = vaddq_f32(vmulq_f32(v18, vaddq_f32(*(float32x4_t *)(v41 + v39 + 16), *(float32x4_t *)(v42 + v39 + 16))), *(float32x4_t *)(v40 + v39 + 16));
              float32x4_t v46 = vaddq_f32(vmulq_f32(v18, vaddq_f32(*(float32x4_t *)(v41 + v39 + 32), *(float32x4_t *)(v42 + v39 + 32))), *(float32x4_t *)(v40 + v39 + 32));
              float32x4_t v47 = vaddq_f32(vmulq_f32(v18, vaddq_f32(*(float32x4_t *)(v41 + v39 + 48), *(float32x4_t *)(v42 + v39 + 48))), *(float32x4_t *)(v40 + v39 + 48));
              *float32x4_t v44 = vaddq_f32(vmulq_f32(v18, vaddq_f32(*(float32x4_t *)(v41 + v39), *(float32x4_t *)(v42 + v39))), *(float32x4_t *)(v40 + v39));
              v44[1] = v45;
              v44[2] = v46;
              v44[3] = v47;
              unsigned int v26 = v43 - 4;
              v39 += 64;
            }
            while (v43 > 7);
            float32x4_t v21 = (float32x4_t *)(v40 + v39);
            unsigned __int8 v24 = (float32x4_t *)(v41 + v39);
            unsigned int v25 = (float32x4_t *)(v42 + v39);
          }
          for (; v26; --v26)
          {
            float32x4_t v48 = *v24++;
            float32x4_t v49 = v48;
            float32x4_t v50 = *v25++;
            float32x4_t *v21 = vaddq_f32(*v21, vmulq_f32(v18, vaddq_f32(v49, v50)));
            ++v21;
          }
        }
        ++v16;
        --v15;
        ++v17;
      }
      while (v17);
      float32x4_t v51 = *(float32x4_t *)*(void *)(a1 + 48);
      float32x4_t v52 = (float32x4_t *)(*(void *)(a2 + 16) + 16 * *(_DWORD *)(a2 + 24) * v11);
      float32x4_t v53 = (float32x4_t *)(*(void *)(a2 + 80) + 16 * *(_DWORD *)(a2 + 88) * v11);
      unsigned int v54 = v12;
      if (v12 >= 4)
      {
        do
        {
          unsigned int v55 = v54;
          float32x4_t v56 = vaddq_f32(vmulq_f32(v51, v53[1]), v52[1]);
          float32x4_t v57 = vaddq_f32(vmulq_f32(v51, v53[2]), v52[2]);
          float32x4_t v58 = vaddq_f32(vmulq_f32(v51, v53[3]), v52[3]);
          *float32x4_t v52 = vaddq_f32(vmulq_f32(v51, *v53), *v52);
          v52[1] = v56;
          v52[2] = v57;
          v52[3] = v58;
          v53 += 4;
          v52 += 4;
          v54 -= 4;
        }
        while (v55 > 7);
      }
      for (; v54; --v54)
      {
        float32x4_t v59 = *v53++;
        *float32x4_t v52 = vaddq_f32(vmulq_f32(v51, v59), *v52);
        ++v52;
      }
      ++v11;
      ++v14;
      ++v13;
    }
    while (v11 != v8);
  }
LABEL_34:
  *(void *)(*(void *)(*(void *)(a2 + 336) + 416) + 80) += HGGetTBC() - v4;
  return 0;
}

uint64_t HGG9Y<HgcBlur_cs9s_es_noborder>::GetFilterMode()
{
  return 0;
}

void HGG9Y<HgcBlur_cs9s>::~HGG9Y(HGNode *a1)
{
  HgcBlur_cs9s::~HgcBlur_cs9s(a1);

  HGObject::operator delete(v1);
}

const char *HGG9Y<HgcBlur_cs9s>::label_A()
{
  return "HGG9Y";
}

uint64_t HGG9Y<HgcBlur_cs9s>::RenderTile(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = HGGetTBC();
  float v5 = *(float32x4_t **)(a1 + 48);
  int8x16_t v6 = (int8x16_t)vceqzq_f32(v5[2]);
  *(int32x2_t *)v6.i8 = vpmax_s32(*(int32x2_t *)v6.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  if (vpmax_s32(*(int32x2_t *)v6.i8, *(int32x2_t *)v6.i8).u32[0])
  {
    uint64_t v7 = 0xFFFFFFFFLL;
    int v8 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
    if (v8 < 1) {
      goto LABEL_34;
    }
    goto LABEL_10;
  }
  int8x16_t v9 = (int8x16_t)vceqzq_f32(v5[3]);
  *(int32x2_t *)v9.i8 = vpmax_s32(*(int32x2_t *)v9.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL));
  if (vpmax_s32(*(int32x2_t *)v9.i8, *(int32x2_t *)v9.i8).u32[0])
  {
    uint64_t v7 = 4294967294;
    int v8 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
    if (v8 < 1) {
      goto LABEL_34;
    }
    goto LABEL_10;
  }
  int8x16_t v10 = (int8x16_t)vceqzq_f32(v5[4]);
  *(int32x2_t *)v10.i8 = vpmax_s32(*(int32x2_t *)v10.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v10, v10, 8uLL));
  uint64_t v7 = 4294967292;
  if (vpmax_s32(*(int32x2_t *)v10.i8, *(int32x2_t *)v10.i8).u32[0]) {
    uint64_t v7 = 4294967293;
  }
  int v8 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
  if (v8 >= 1)
  {
LABEL_10:
    int v11 = 0;
    int v12 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
    int v13 = -(int)v7;
    int v14 = v7;
    do
    {
      int v15 = v13;
      int v16 = v14;
      uint64_t v17 = v7;
      do
      {
        float32x4_t v18 = *(float32x4_t *)(*(void *)(a1 + 48) + ((-16 * v17) & 0xFFFFFFFF0));
        uint64_t v19 = *(void *)(a2 + 16);
        int v20 = *(_DWORD *)(a2 + 24);
        float32x4_t v21 = (float32x4_t *)(v19 + 16 * v20 * v11);
        uint64_t v22 = *(void *)(a2 + 80);
        int v23 = *(_DWORD *)(a2 + 88);
        unsigned __int8 v24 = (float32x4_t *)(v22 + 16 * v23 * (v11 + (int)v17));
        unsigned int v25 = (float32x4_t *)(v22 + 16 * v23 * (v11 - (int)v17));
        unsigned int v26 = v12;
        if (v17 == v7)
        {
          if (v12 >= 4)
          {
            uint64_t v27 = 0;
            uint64_t v28 = v19 + 16 * v11 * v20;
            uint64_t v29 = v22 + 16 * v23 * v16;
            uint64_t v30 = v22 + 16 * v23 * v15;
            unsigned int v26 = v12;
            do
            {
              unsigned int v31 = v26;
              long long v32 = (float32x4_t *)(v28 + v27);
              float32x4_t v33 = vmulq_f32(v18, vaddq_f32(*(float32x4_t *)(v29 + v27 + 16), *(float32x4_t *)(v30 + v27 + 16)));
              float32x4_t v34 = vmulq_f32(v18, vaddq_f32(*(float32x4_t *)(v29 + v27 + 32), *(float32x4_t *)(v30 + v27 + 32)));
              float32x4_t v35 = vmulq_f32(v18, vaddq_f32(*(float32x4_t *)(v29 + v27 + 48), *(float32x4_t *)(v30 + v27 + 48)));
              *long long v32 = vmulq_f32(v18, vaddq_f32(*(float32x4_t *)(v29 + v27), *(float32x4_t *)(v30 + v27)));
              v32[1] = v33;
              uint64_t v32[2] = v34;
              v32[3] = v35;
              unsigned int v26 = v31 - 4;
              v27 += 64;
            }
            while (v31 > 7);
            float32x4_t v21 = (float32x4_t *)(v28 + v27);
            unsigned __int8 v24 = (float32x4_t *)(v29 + v27);
            unsigned int v25 = (float32x4_t *)(v30 + v27);
          }
          for (; v26; --v26)
          {
            float32x4_t v36 = *v24++;
            float32x4_t v37 = v36;
            float32x4_t v38 = *v25++;
            *v21++ = vmulq_f32(v18, vaddq_f32(v37, v38));
          }
        }
        else
        {
          if (v12 >= 4)
          {
            uint64_t v39 = 0;
            uint64_t v40 = v19 + 16 * v11 * v20;
            uint64_t v41 = v22 + 16 * v23 * v16;
            uint64_t v42 = v22 + 16 * v23 * v15;
            unsigned int v26 = v12;
            do
            {
              unsigned int v43 = v26;
              float32x4_t v44 = (float32x4_t *)(v40 + v39);
              float32x4_t v45 = vaddq_f32(vmulq_f32(v18, vaddq_f32(*(float32x4_t *)(v41 + v39 + 16), *(float32x4_t *)(v42 + v39 + 16))), *(float32x4_t *)(v40 + v39 + 16));
              float32x4_t v46 = vaddq_f32(vmulq_f32(v18, vaddq_f32(*(float32x4_t *)(v41 + v39 + 32), *(float32x4_t *)(v42 + v39 + 32))), *(float32x4_t *)(v40 + v39 + 32));
              float32x4_t v47 = vaddq_f32(vmulq_f32(v18, vaddq_f32(*(float32x4_t *)(v41 + v39 + 48), *(float32x4_t *)(v42 + v39 + 48))), *(float32x4_t *)(v40 + v39 + 48));
              *float32x4_t v44 = vaddq_f32(vmulq_f32(v18, vaddq_f32(*(float32x4_t *)(v41 + v39), *(float32x4_t *)(v42 + v39))), *(float32x4_t *)(v40 + v39));
              v44[1] = v45;
              v44[2] = v46;
              v44[3] = v47;
              unsigned int v26 = v43 - 4;
              v39 += 64;
            }
            while (v43 > 7);
            float32x4_t v21 = (float32x4_t *)(v40 + v39);
            unsigned __int8 v24 = (float32x4_t *)(v41 + v39);
            unsigned int v25 = (float32x4_t *)(v42 + v39);
          }
          for (; v26; --v26)
          {
            float32x4_t v48 = *v24++;
            float32x4_t v49 = v48;
            float32x4_t v50 = *v25++;
            float32x4_t *v21 = vaddq_f32(*v21, vmulq_f32(v18, vaddq_f32(v49, v50)));
            ++v21;
          }
        }
        ++v16;
        --v15;
        ++v17;
      }
      while (v17);
      float32x4_t v51 = *(float32x4_t *)*(void *)(a1 + 48);
      float32x4_t v52 = (float32x4_t *)(*(void *)(a2 + 16) + 16 * *(_DWORD *)(a2 + 24) * v11);
      float32x4_t v53 = (float32x4_t *)(*(void *)(a2 + 80) + 16 * *(_DWORD *)(a2 + 88) * v11);
      unsigned int v54 = v12;
      if (v12 >= 4)
      {
        do
        {
          unsigned int v55 = v54;
          float32x4_t v56 = vaddq_f32(vmulq_f32(v51, v53[1]), v52[1]);
          float32x4_t v57 = vaddq_f32(vmulq_f32(v51, v53[2]), v52[2]);
          float32x4_t v58 = vaddq_f32(vmulq_f32(v51, v53[3]), v52[3]);
          *float32x4_t v52 = vaddq_f32(vmulq_f32(v51, *v53), *v52);
          v52[1] = v56;
          v52[2] = v57;
          v52[3] = v58;
          v53 += 4;
          v52 += 4;
          v54 -= 4;
        }
        while (v55 > 7);
      }
      for (; v54; --v54)
      {
        float32x4_t v59 = *v53++;
        *float32x4_t v52 = vaddq_f32(vmulq_f32(v51, v59), *v52);
        ++v52;
      }
      ++v11;
      ++v14;
      ++v13;
    }
    while (v11 != v8);
  }
LABEL_34:
  *(void *)(*(void *)(*(void *)(a2 + 336) + 416) + 80) += HGGetTBC() - v4;
  return 0;
}

uint64_t HGG9Y<HgcBlur_cs9s>::GetFilterMode()
{
  return 0;
}

void HGG9D2X<HgcBlur_cs9s_rect>::~HGG9D2X(HGNode *a1)
{
  HgcBlur_cs9s_rect::~HgcBlur_cs9s_rect(a1);

  HGObject::operator delete(v1);
}

const char *HGG9D2X<HgcBlur_cs9s_rect>::label_A()
{
  return "HGG9D2X";
}

uint64_t HGG9D2X<HgcBlur_cs9s_rect>::RenderTile(uint64_t a1, int *a2)
{
  int v2 = a2[2];
  int v3 = a2[3] - a2[1];
  if (v3 >= 1 && v2 != *a2)
  {
    int v5 = 0;
    int8x16_t v6 = *(float32x4_t **)(a1 + 48);
    float32x4_t v7 = *v6;
    float32x4_t v8 = v6[1];
    float32x4_t v9 = v6[2];
    float32x4_t v10 = v6[3];
    float32x4_t v11 = v6[4];
    int v12 = *a2 - v2;
    do
    {
      int v13 = (float32x4_t *)(*((void *)a2 + 2) + 16 * a2[6] * v5);
      int v14 = (float32x4_t *)(*((void *)a2 + 10) + 16 * *a2 + 16 * a2[22] * v5);
      float32x4_t v15 = v14[-4];
      float32x4_t v16 = v14[-3];
      float32x4_t v17 = v14[-2];
      float32x4_t v18 = v14[-1];
      float32x4_t v19 = *v14;
      float32x4_t v20 = v14[1];
      float32x4_t v21 = v14[2];
      uint64_t v22 = v14 + 4;
      int v23 = v12;
      do
      {
        float32x4_t v24 = v21;
        float32x4_t v25 = v22[-1];
        float32x4_t v21 = *v22;
        *v13++ = vaddq_f32(vmulq_f32(v11, vaddq_f32(v15, *v22)), vaddq_f32(vaddq_f32(vmulq_f32(v9, vaddq_f32(v24, v17)), vaddq_f32(vmulq_f32(v7, v19), vmulq_f32(v8, vaddq_f32(v20, v18)))), vmulq_f32(v10, vaddq_f32(v16, v25))));
        v22 += 2;
        float32x4_t v15 = v17;
        float32x4_t v16 = v18;
        float32x4_t v17 = v19;
        float32x4_t v18 = v20;
        float32x4_t v19 = v24;
        float32x4_t v20 = v25;
      }
      while (!__CFADD__(v23++, 1));
      ++v5;
    }
    while (v5 != v3);
  }
  return 0;
}

uint64_t HGG9D2X<HgcBlur_cs9s_rect>::GetFilterMode()
{
  return 0;
}

void HGG9D2X<HgcBlur_cs9s_es_noborder>::~HGG9D2X(HGNode *a1)
{
  HgcBlur_cs9s_es_noborder::~HgcBlur_cs9s_es_noborder(a1);

  HGObject::operator delete(v1);
}

const char *HGG9D2X<HgcBlur_cs9s_es_noborder>::label_A()
{
  return "HGG9D2X";
}

uint64_t HGG9D2X<HgcBlur_cs9s_es_noborder>::RenderTile(uint64_t a1, int *a2)
{
  int v2 = a2[2];
  int v3 = a2[3] - a2[1];
  if (v3 >= 1 && v2 != *a2)
  {
    int v5 = 0;
    int8x16_t v6 = *(float32x4_t **)(a1 + 48);
    float32x4_t v7 = *v6;
    float32x4_t v8 = v6[1];
    float32x4_t v9 = v6[2];
    float32x4_t v10 = v6[3];
    float32x4_t v11 = v6[4];
    int v12 = *a2 - v2;
    do
    {
      int v13 = (float32x4_t *)(*((void *)a2 + 2) + 16 * a2[6] * v5);
      int v14 = (float32x4_t *)(*((void *)a2 + 10) + 16 * *a2 + 16 * a2[22] * v5);
      float32x4_t v15 = v14[-4];
      float32x4_t v16 = v14[-3];
      float32x4_t v17 = v14[-2];
      float32x4_t v18 = v14[-1];
      float32x4_t v19 = *v14;
      float32x4_t v20 = v14[1];
      float32x4_t v21 = v14[2];
      uint64_t v22 = v14 + 4;
      int v23 = v12;
      do
      {
        float32x4_t v24 = v21;
        float32x4_t v25 = v22[-1];
        float32x4_t v21 = *v22;
        *v13++ = vaddq_f32(vmulq_f32(v11, vaddq_f32(v15, *v22)), vaddq_f32(vaddq_f32(vmulq_f32(v9, vaddq_f32(v24, v17)), vaddq_f32(vmulq_f32(v7, v19), vmulq_f32(v8, vaddq_f32(v20, v18)))), vmulq_f32(v10, vaddq_f32(v16, v25))));
        v22 += 2;
        float32x4_t v15 = v17;
        float32x4_t v16 = v18;
        float32x4_t v17 = v19;
        float32x4_t v18 = v20;
        float32x4_t v19 = v24;
        float32x4_t v20 = v25;
      }
      while (!__CFADD__(v23++, 1));
      ++v5;
    }
    while (v5 != v3);
  }
  return 0;
}

uint64_t HGG9D2X<HgcBlur_cs9s_es_noborder>::GetFilterMode()
{
  return 0;
}

void HGG9D2X<HgcBlur_cs9s>::~HGG9D2X(HGNode *a1)
{
  HgcBlur_cs9s::~HgcBlur_cs9s(a1);

  HGObject::operator delete(v1);
}

const char *HGG9D2X<HgcBlur_cs9s>::label_A()
{
  return "HGG9D2X";
}

uint64_t HGG9D2X<HgcBlur_cs9s>::RenderTile(uint64_t a1, int *a2)
{
  int v2 = a2[2];
  int v3 = a2[3] - a2[1];
  if (v3 >= 1 && v2 != *a2)
  {
    int v5 = 0;
    int8x16_t v6 = *(float32x4_t **)(a1 + 48);
    float32x4_t v7 = *v6;
    float32x4_t v8 = v6[1];
    float32x4_t v9 = v6[2];
    float32x4_t v10 = v6[3];
    float32x4_t v11 = v6[4];
    int v12 = *a2 - v2;
    do
    {
      int v13 = (float32x4_t *)(*((void *)a2 + 2) + 16 * a2[6] * v5);
      int v14 = (float32x4_t *)(*((void *)a2 + 10) + 16 * *a2 + 16 * a2[22] * v5);
      float32x4_t v15 = v14[-4];
      float32x4_t v16 = v14[-3];
      float32x4_t v17 = v14[-2];
      float32x4_t v18 = v14[-1];
      float32x4_t v19 = *v14;
      float32x4_t v20 = v14[1];
      float32x4_t v21 = v14[2];
      uint64_t v22 = v14 + 4;
      int v23 = v12;
      do
      {
        float32x4_t v24 = v21;
        float32x4_t v25 = v22[-1];
        float32x4_t v21 = *v22;
        *v13++ = vaddq_f32(vmulq_f32(v11, vaddq_f32(v15, *v22)), vaddq_f32(vaddq_f32(vmulq_f32(v9, vaddq_f32(v24, v17)), vaddq_f32(vmulq_f32(v7, v19), vmulq_f32(v8, vaddq_f32(v20, v18)))), vmulq_f32(v10, vaddq_f32(v16, v25))));
        v22 += 2;
        float32x4_t v15 = v17;
        float32x4_t v16 = v18;
        float32x4_t v17 = v19;
        float32x4_t v18 = v20;
        float32x4_t v19 = v24;
        float32x4_t v20 = v25;
      }
      while (!__CFADD__(v23++, 1));
      ++v5;
    }
    while (v5 != v3);
  }
  return 0;
}

uint64_t HGG9D2X<HgcBlur_cs9s>::GetFilterMode()
{
  return 0;
}

void HGG9D2Y<HgcBlur_cs9s_rect>::HGG9D2Y(HgcBlur_cs9s_rect *a1)
{
}

void sub_1B77C5514(_Unwind_Exception *a1)
{
  HgcBlur_cs9s_rect::~HgcBlur_cs9s_rect(v1);
  _Unwind_Resume(a1);
}

void sub_1B77C5528(_Unwind_Exception *a1)
{
  HgcBlur_cs9s_rect::~HgcBlur_cs9s_rect(v1);
  _Unwind_Resume(a1);
}

void sub_1B77C553C(_Unwind_Exception *a1)
{
  HgcBlur_cs9s_rect::~HgcBlur_cs9s_rect(v1);
  _Unwind_Resume(a1);
}

void HGG9D2Y<HgcBlur_cs9s_rect>::~HGG9D2Y(HGNode *a1)
{
  HgcBlur_cs9s_rect::~HgcBlur_cs9s_rect(a1);

  HGObject::operator delete(v1);
}

const char *HGG9D2Y<HgcBlur_cs9s_rect>::label_A()
{
  return "HGG9D2Y";
}

uint64_t HGG9D2Y<HgcBlur_cs9s_rect>::RenderTile(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
  if (v2 >= 1)
  {
    int v3 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
    if (v3)
    {
      int v4 = 0;
      int v5 = 0;
      int8x16_t v6 = *(float32x4_t **)(a1 + 48);
      float32x4_t v7 = *v6;
      float32x4_t v8 = v6[1];
      float32x4_t v9 = v6[2];
      float32x4_t v10 = v6[3];
      uint64_t v11 = *(int *)(a2 + 88);
      uint64_t v12 = 16 * v11;
      uint64_t v13 = 32 * v11;
      uint64_t v14 = 48 * v11;
      uint64_t v15 = v11 << 6;
      float32x4_t v16 = v6[4];
      do
      {
        uint64_t v17 = 0;
        uint64_t v18 = *(void *)(a2 + 16) + 16 * *(_DWORD *)(a2 + 24) * v5;
        uint64_t v19 = *(void *)(a2 + 80) + 16 * *(_DWORD *)(a2 + 88) * (*(_DWORD *)(a2 + 4) + v4);
        do
        {
          *(float32x4_t *)(v18 + 16 * v17) = vaddq_f32(vmulq_f32(v16, vaddq_f32(*(float32x4_t *)(v19 - v15 + 16 * v17), *(float32x4_t *)(v19 + v15 + 16 * v17))), vaddq_f32(vmulq_f32(v10, vaddq_f32(*(float32x4_t *)(v19 - v14 + 16 * v17), *(float32x4_t *)(v19 + v14 + 16 * v17))), vaddq_f32(vmulq_f32(v9, vaddq_f32(*(float32x4_t *)(v19 - v13 + 16 * v17), *(float32x4_t *)(v19 + v13 + 16 * v17))), vaddq_f32(vmulq_f32(v7, *(float32x4_t *)(v19 + 16 * v17)),
                                                     vmulq_f32(v8, vaddq_f32(*(float32x4_t *)(v19 - v12 + 16 * v17), *(float32x4_t *)(v19 + v12 + 16 * v17)))))));
          ++v17;
        }
        while (v3 != v17);
        ++v5;
        v4 += 2;
      }
      while (v5 != v2);
    }
  }
  return 0;
}

uint64_t HGG9D2Y<HgcBlur_cs9s_rect>::GetFilterMode()
{
  return 0;
}

void HGG9D2Y<HgcBlur_cs9s_es_noborder>::HGG9D2Y(HgcBlur_cs9s_es_noborder *a1)
{
}

void sub_1B77C5808(_Unwind_Exception *a1)
{
  HgcBlur_cs9s_es_noborder::~HgcBlur_cs9s_es_noborder(v1);
  _Unwind_Resume(a1);
}

void sub_1B77C581C(_Unwind_Exception *a1)
{
  HgcBlur_cs9s_es_noborder::~HgcBlur_cs9s_es_noborder(v1);
  _Unwind_Resume(a1);
}

void sub_1B77C5830(_Unwind_Exception *a1)
{
  HgcBlur_cs9s_es_noborder::~HgcBlur_cs9s_es_noborder(v1);
  _Unwind_Resume(a1);
}

void HGG9D2Y<HgcBlur_cs9s_es_noborder>::~HGG9D2Y(HGNode *a1)
{
  HgcBlur_cs9s_es_noborder::~HgcBlur_cs9s_es_noborder(a1);

  HGObject::operator delete(v1);
}

const char *HGG9D2Y<HgcBlur_cs9s_es_noborder>::label_A()
{
  return "HGG9D2Y";
}

uint64_t HGG9D2Y<HgcBlur_cs9s_es_noborder>::RenderTile(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
  if (v2 >= 1)
  {
    int v3 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
    if (v3)
    {
      int v4 = 0;
      int v5 = 0;
      int8x16_t v6 = *(float32x4_t **)(a1 + 48);
      float32x4_t v7 = *v6;
      float32x4_t v8 = v6[1];
      float32x4_t v9 = v6[2];
      float32x4_t v10 = v6[3];
      uint64_t v11 = *(int *)(a2 + 88);
      uint64_t v12 = 16 * v11;
      uint64_t v13 = 32 * v11;
      uint64_t v14 = 48 * v11;
      uint64_t v15 = v11 << 6;
      float32x4_t v16 = v6[4];
      do
      {
        uint64_t v17 = 0;
        uint64_t v18 = *(void *)(a2 + 16) + 16 * *(_DWORD *)(a2 + 24) * v5;
        uint64_t v19 = *(void *)(a2 + 80) + 16 * *(_DWORD *)(a2 + 88) * (*(_DWORD *)(a2 + 4) + v4);
        do
        {
          *(float32x4_t *)(v18 + 16 * v17) = vaddq_f32(vmulq_f32(v16, vaddq_f32(*(float32x4_t *)(v19 - v15 + 16 * v17), *(float32x4_t *)(v19 + v15 + 16 * v17))), vaddq_f32(vmulq_f32(v10, vaddq_f32(*(float32x4_t *)(v19 - v14 + 16 * v17), *(float32x4_t *)(v19 + v14 + 16 * v17))), vaddq_f32(vmulq_f32(v9, vaddq_f32(*(float32x4_t *)(v19 - v13 + 16 * v17), *(float32x4_t *)(v19 + v13 + 16 * v17))), vaddq_f32(vmulq_f32(v7, *(float32x4_t *)(v19 + 16 * v17)),
                                                     vmulq_f32(v8, vaddq_f32(*(float32x4_t *)(v19 - v12 + 16 * v17), *(float32x4_t *)(v19 + v12 + 16 * v17)))))));
          ++v17;
        }
        while (v3 != v17);
        ++v5;
        v4 += 2;
      }
      while (v5 != v2);
    }
  }
  return 0;
}

uint64_t HGG9D2Y<HgcBlur_cs9s_es_noborder>::GetFilterMode()
{
  return 0;
}

void HGG9D2Y<HgcBlur_cs9s>::HGG9D2Y(HgcBlur_cs9s *a1)
{
}

void sub_1B77C5AFC(_Unwind_Exception *a1)
{
  HgcBlur_cs9s::~HgcBlur_cs9s(v1);
  _Unwind_Resume(a1);
}

void sub_1B77C5B10(_Unwind_Exception *a1)
{
  HgcBlur_cs9s::~HgcBlur_cs9s(v1);
  _Unwind_Resume(a1);
}

void sub_1B77C5B24(_Unwind_Exception *a1)
{
  HgcBlur_cs9s::~HgcBlur_cs9s(v1);
  _Unwind_Resume(a1);
}

void HGG9D2Y<HgcBlur_cs9s>::~HGG9D2Y(HGNode *a1)
{
  HgcBlur_cs9s::~HgcBlur_cs9s(a1);

  HGObject::operator delete(v1);
}

const char *HGG9D2Y<HgcBlur_cs9s>::label_A()
{
  return "HGG9D2Y";
}

uint64_t HGG9D2Y<HgcBlur_cs9s>::RenderTile(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
  if (v2 >= 1)
  {
    int v3 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
    if (v3)
    {
      int v4 = 0;
      int v5 = 0;
      int8x16_t v6 = *(float32x4_t **)(a1 + 48);
      float32x4_t v7 = *v6;
      float32x4_t v8 = v6[1];
      float32x4_t v9 = v6[2];
      float32x4_t v10 = v6[3];
      uint64_t v11 = *(int *)(a2 + 88);
      uint64_t v12 = 16 * v11;
      uint64_t v13 = 32 * v11;
      uint64_t v14 = 48 * v11;
      uint64_t v15 = v11 << 6;
      float32x4_t v16 = v6[4];
      do
      {
        uint64_t v17 = 0;
        uint64_t v18 = *(void *)(a2 + 16) + 16 * *(_DWORD *)(a2 + 24) * v5;
        uint64_t v19 = *(void *)(a2 + 80) + 16 * *(_DWORD *)(a2 + 88) * (*(_DWORD *)(a2 + 4) + v4);
        do
        {
          *(float32x4_t *)(v18 + 16 * v17) = vaddq_f32(vmulq_f32(v16, vaddq_f32(*(float32x4_t *)(v19 - v15 + 16 * v17), *(float32x4_t *)(v19 + v15 + 16 * v17))), vaddq_f32(vmulq_f32(v10, vaddq_f32(*(float32x4_t *)(v19 - v14 + 16 * v17), *(float32x4_t *)(v19 + v14 + 16 * v17))), vaddq_f32(vmulq_f32(v9, vaddq_f32(*(float32x4_t *)(v19 - v13 + 16 * v17), *(float32x4_t *)(v19 + v13 + 16 * v17))), vaddq_f32(vmulq_f32(v7, *(float32x4_t *)(v19 + 16 * v17)),
                                                     vmulq_f32(v8, vaddq_f32(*(float32x4_t *)(v19 - v12 + 16 * v17), *(float32x4_t *)(v19 + v12 + 16 * v17)))))));
          ++v17;
        }
        while (v3 != v17);
        ++v5;
        v4 += 2;
      }
      while (v5 != v2);
    }
  }
  return 0;
}

uint64_t HGG9D2Y<HgcBlur_cs9s>::GetFilterMode()
{
  return 0;
}

void HGG4U2X<HgcBlur_g4u2_rect>::HGG4U2X(HgcBlur_g4u2_rect *a1)
{
}

void sub_1B77C6078(_Unwind_Exception *a1)
{
  HgcBlur_g4u2_rect::~HgcBlur_g4u2_rect(v1);
  _Unwind_Resume(a1);
}

void sub_1B77C608C(_Unwind_Exception *a1)
{
  HgcBlur_g4u2_rect::~HgcBlur_g4u2_rect(v1);
  _Unwind_Resume(a1);
}

void HGG4U2X<HgcBlur_g4u2_rect>::~HGG4U2X(HGNode *a1)
{
  HgcBlur_g4u2_rect::~HgcBlur_g4u2_rect(a1);

  HGObject::operator delete(v1);
}

const char *HGG4U2X<HgcBlur_g4u2_rect>::label_A()
{
  return "HGG4U2X";
}

uint64_t HGG4U2X<HgcBlur_g4u2_rect>::RenderTile(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
    int v5 = *(float32x4_t **)(a1 + 48);
    float32x4_t v6 = v5[1];
    float32x4_t v7 = vaddq_f32(*v5, *v5);
    float32x4_t v8 = v5[2];
    float32x4_t v9 = v5[3];
    uint64_t v10 = *(_DWORD *)a2 & 1;
    uint64_t v11 = -(uint64_t)(int)vcvtms_s32_f32((float)*(int *)a2 * 0.5);
    do
    {
      uint64_t v12 = (float32x4_t *)(*(void *)(a2 + 16) + 16 * *(_DWORD *)(a2 + 24) * v3);
      uint64_t v13 = (float32x4_t *)(*(void *)(a2 + 80) + 16 * *(_DWORD *)(a2 + 88) * v3 + 16 * v11 - 16 * v10);
      float32x4_t v15 = v13[-1];
      float32x4_t v14 = *v13;
      float32x4_t v16 = v13[1];
      if (v10)
      {
        float32x4_t v17 = v13[2];
        *v12++ = vaddq_f32(vmulq_f32(v8, vaddq_f32(v14, v16)), vmulq_f32(v9, vaddq_f32(v15, v17)));
        int v18 = v4 - 1;
        ++v13;
        float32x4_t v15 = v14;
        if (v4 - 1 < 4) {
          goto LABEL_7;
        }
      }
      else
      {
        int v18 = v4;
        float32x4_t v17 = v13[1];
        float32x4_t v16 = *v13;
        float32x4_t v14 = v13[-1];
        if (v4 < 4) {
          goto LABEL_7;
        }
      }
      do
      {
        unsigned int v19 = v18;
        float32x4_t v14 = v17;
        float32x4_t v20 = v16;
        float32x4_t v16 = v13[2];
        float32x4_t v17 = v13[3];
        v13 += 2;
        float32x4_t *v12 = vaddq_f32(vmulq_f32(v7, v20), vmulq_f32(v6, vaddq_f32(v14, v15)));
        v12[1] = vaddq_f32(vmulq_f32(v8, vaddq_f32(v14, v20)), vmulq_f32(v9, vaddq_f32(v15, v16)));
        v12[2] = vaddq_f32(vmulq_f32(v7, v14), vmulq_f32(v6, vaddq_f32(v20, v16)));
        void v12[3] = vaddq_f32(vmulq_f32(v8, vaddq_f32(v14, v16)), vmulq_f32(v9, vaddq_f32(v20, v17)));
        v12 += 4;
        v18 -= 4;
        float32x4_t v15 = v14;
      }
      while (v19 > 7);
LABEL_7:
      if (v18 >= 2)
      {
        float32x4_t v21 = v13 + 2;
        do
        {
          unsigned int v22 = v18;
          float32x4_t v23 = v17;
          float32x4_t v24 = v16;
          float32x4_t v25 = *v21++;
          float32x4_t v17 = v25;
          float32x4_t *v12 = vaddq_f32(vmulq_f32(v7, v16), vmulq_f32(v6, vaddq_f32(v23, v14)));
          v12[1] = vaddq_f32(vmulq_f32(v8, vaddq_f32(v23, v16)), vmulq_f32(v9, vaddq_f32(v14, v25)));
          v12 += 2;
          v18 -= 2;
          float32x4_t v14 = v16;
          float32x4_t v16 = v23;
        }
        while (v22 > 3);
        if (!v18) {
          goto LABEL_3;
        }
LABEL_13:
        float32x4_t *v12 = vaddq_f32(vmulq_f32(v7, v23), vmulq_f32(v6, vaddq_f32(v17, v24)));
        goto LABEL_3;
      }
      float32x4_t v23 = v16;
      float32x4_t v24 = v14;
      if (v18) {
        goto LABEL_13;
      }
LABEL_3:
      ++v3;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HGG4U2X<HgcBlur_g4u2_rect>::Bind(HGNode *a1, HGHandler *a2)
{
  uint64_t v3 = HGNode::Bind(a1, a2);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  return v3;
}

uint64_t HGG4U2X<HgcBlur_g4u2_rect>::BindTexture(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 144) + 128))(*(void *)(a2 + 144), 43) == 1)
  {
    HGHandler::TexCoord((HGHandler *)a2, a3, 0, 0, 0);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)a2 + 72))(a2, a3, 0);
    (*(void (**)(uint64_t, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    (*(void (**)(uint64_t, void))(*(void *)a2 + 56))(a2, 0);
LABEL_5:
    v5.n128_u64[0] = 0;
    v6.n128_u64[0] = 0;
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
    (*(void (**)(uint64_t, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 7, v5, v6, v7, v8);
    return 0;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 144) + 128))(*(void *)(a2 + 144), 46))
  {
    HGHandler::TexCoord((HGHandler *)a2, a3, 0, 0, 0);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)a2 + 72))(a2, a3, 0);
    (*(void (**)(uint64_t, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    goto LABEL_5;
  }
  (*(void (**)(uint64_t, uint64_t, float, float, float, float))(*(void *)a2 + 136))(a2, 7, (float)*(int *)(a2 + 240), (float)*(int *)(a2 + 244), 1.0 / (float)(*(_DWORD *)(a2 + 228) - *(_DWORD *)(a2 + 220)), 1.0 / (float)(*(_DWORD *)(a2 + 232) - *(_DWORD *)(a2 + 224)));
  if (!(*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 144) + 128))(*(void *)(a2 + 144), 21))
  {
    unsigned int v14 = *(_DWORD *)(a2 + 228) - *(_DWORD *)(a2 + 220);
    v10.n128_f32[0] = (float)(v14 + 1) * 0.5;
    unsigned int v15 = *(_DWORD *)(a2 + 232) - *(_DWORD *)(a2 + 224);
    v11.n128_f32[0] = (float)(v15 + 1) * 0.5;
    v12.n128_f32[0] = (float)v14;
    v13.n128_f32[0] = (float)v15;
    (*(void (**)(uint64_t, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 8, v10, v11, v12, v13);
  }
  return 0;
}

uint64_t HGG4U2X<HgcBlur_g4u2_rect>::IntermediateFormat(uint64_t a1, int a2)
{
  if (a2 <= 27) {
    return 27;
  }
  else {
    return a2;
  }
}

uint64_t HGG4U2X<HgcBlur_g4u2_rect>::GetDOD(float *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  return HGRectIntegral(HIDWORD(a4), (float)((float)(a1[106] + (float)(int)a4) / a1[104]) + 0.5, (float)((float)(a1[107] + (float)SHIDWORD(a4)) / a1[105]) + 0.5, (float)((float)((float)((float)(int)a5 + -1.0) + a1[108]) / a1[104]) + 0.5, (float)((float)((float)((float)SHIDWORD(a5) + -1.0) + a1[109]) / a1[105]) + 0.5);
}

uint64_t HGG4U2X<HgcBlur_g4u2_rect>::GetROI(float *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  return HGRectIntegral(HIDWORD(a4), a1[106] + (float)((float)(a1[104] * (float)(int)a4) + 0.5), a1[107] + (float)((float)(a1[105] * (float)SHIDWORD(a4)) + 0.5), (float)((float)((float)((float)(int)a5 + -1.0) * a1[104]) + 0.5) + a1[108], (float)((float)((float)((float)SHIDWORD(a5) + -1.0) * a1[105]) + 0.5) + a1[109]);
}

uint64_t HGG4U2X<HgcBlur_g4u2_rect>::GetFilterMode()
{
  return 0;
}

void HGG4U2X<HgcBlur_g4u2_noborder>::HGG4U2X(HgcBlur_g4u2_noborder *a1)
{
}

void sub_1B77C6AA0(_Unwind_Exception *a1)
{
  HgcBlur_g4u2_noborder::~HgcBlur_g4u2_noborder(v1);
  _Unwind_Resume(a1);
}

void sub_1B77C6AB4(_Unwind_Exception *a1)
{
  HgcBlur_g4u2_noborder::~HgcBlur_g4u2_noborder(v1);
  _Unwind_Resume(a1);
}

void HGG4U2X<HgcBlur_g4u2_noborder>::~HGG4U2X(HGNode *a1)
{
  HgcBlur_g4u2_noborder::~HgcBlur_g4u2_noborder(a1);

  HGObject::operator delete(v1);
}

const char *HGG4U2X<HgcBlur_g4u2_noborder>::label_A()
{
  return "HGG4U2X";
}

uint64_t HGG4U2X<HgcBlur_g4u2_noborder>::RenderTile(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
    __n128 v5 = *(float32x4_t **)(a1 + 48);
    float32x4_t v6 = v5[1];
    float32x4_t v7 = vaddq_f32(*v5, *v5);
    float32x4_t v8 = v5[2];
    float32x4_t v9 = v5[3];
    uint64_t v10 = *(_DWORD *)a2 & 1;
    uint64_t v11 = -(uint64_t)(int)vcvtms_s32_f32((float)*(int *)a2 * 0.5);
    do
    {
      __n128 v12 = (float32x4_t *)(*(void *)(a2 + 16) + 16 * *(_DWORD *)(a2 + 24) * v3);
      __n128 v13 = (float32x4_t *)(*(void *)(a2 + 80) + 16 * *(_DWORD *)(a2 + 88) * v3 + 16 * v11 - 16 * v10);
      float32x4_t v15 = v13[-1];
      float32x4_t v14 = *v13;
      float32x4_t v16 = v13[1];
      if (v10)
      {
        float32x4_t v17 = v13[2];
        *v12++ = vaddq_f32(vmulq_f32(v8, vaddq_f32(v14, v16)), vmulq_f32(v9, vaddq_f32(v15, v17)));
        int v18 = v4 - 1;
        ++v13;
        float32x4_t v15 = v14;
        if (v4 - 1 < 4) {
          goto LABEL_7;
        }
      }
      else
      {
        int v18 = v4;
        float32x4_t v17 = v13[1];
        float32x4_t v16 = *v13;
        float32x4_t v14 = v13[-1];
        if (v4 < 4) {
          goto LABEL_7;
        }
      }
      do
      {
        unsigned int v19 = v18;
        float32x4_t v14 = v17;
        float32x4_t v20 = v16;
        float32x4_t v16 = v13[2];
        float32x4_t v17 = v13[3];
        v13 += 2;
        float32x4_t *v12 = vaddq_f32(vmulq_f32(v7, v20), vmulq_f32(v6, vaddq_f32(v14, v15)));
        v12[1] = vaddq_f32(vmulq_f32(v8, vaddq_f32(v14, v20)), vmulq_f32(v9, vaddq_f32(v15, v16)));
        v12[2] = vaddq_f32(vmulq_f32(v7, v14), vmulq_f32(v6, vaddq_f32(v20, v16)));
        void v12[3] = vaddq_f32(vmulq_f32(v8, vaddq_f32(v14, v16)), vmulq_f32(v9, vaddq_f32(v20, v17)));
        v12 += 4;
        v18 -= 4;
        float32x4_t v15 = v14;
      }
      while (v19 > 7);
LABEL_7:
      if (v18 >= 2)
      {
        float32x4_t v21 = v13 + 2;
        do
        {
          unsigned int v22 = v18;
          float32x4_t v23 = v17;
          float32x4_t v24 = v16;
          float32x4_t v25 = *v21++;
          float32x4_t v17 = v25;
          float32x4_t *v12 = vaddq_f32(vmulq_f32(v7, v16), vmulq_f32(v6, vaddq_f32(v23, v14)));
          v12[1] = vaddq_f32(vmulq_f32(v8, vaddq_f32(v23, v16)), vmulq_f32(v9, vaddq_f32(v14, v25)));
          v12 += 2;
          v18 -= 2;
          float32x4_t v14 = v16;
          float32x4_t v16 = v23;
        }
        while (v22 > 3);
        if (!v18) {
          goto LABEL_3;
        }
LABEL_13:
        float32x4_t *v12 = vaddq_f32(vmulq_f32(v7, v23), vmulq_f32(v6, vaddq_f32(v17, v24)));
        goto LABEL_3;
      }
      float32x4_t v23 = v16;
      float32x4_t v24 = v14;
      if (v18) {
        goto LABEL_13;
      }
LABEL_3:
      ++v3;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HGG4U2X<HgcBlur_g4u2_noborder>::Bind(HGNode *a1, HGHandler *a2)
{
  uint64_t v3 = HGNode::Bind(a1, a2);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  return v3;
}

uint64_t HGG4U2X<HgcBlur_g4u2_noborder>::BindTexture(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 144) + 128))(*(void *)(a2 + 144), 43) == 1)
  {
    HGHandler::TexCoord((HGHandler *)a2, a3, 0, 0, 0);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)a2 + 72))(a2, a3, 0);
    (*(void (**)(uint64_t, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    (*(void (**)(uint64_t, void))(*(void *)a2 + 56))(a2, 0);
LABEL_5:
    v5.n128_u64[0] = 0;
    v6.n128_u64[0] = 0;
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
    (*(void (**)(uint64_t, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 7, v5, v6, v7, v8);
    return 0;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 144) + 128))(*(void *)(a2 + 144), 46))
  {
    HGHandler::TexCoord((HGHandler *)a2, a3, 0, 0, 0);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)a2 + 72))(a2, a3, 0);
    (*(void (**)(uint64_t, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    goto LABEL_5;
  }
  (*(void (**)(uint64_t, uint64_t, float, float, float, float))(*(void *)a2 + 136))(a2, 7, (float)*(int *)(a2 + 240), (float)*(int *)(a2 + 244), 1.0 / (float)(*(_DWORD *)(a2 + 228) - *(_DWORD *)(a2 + 220)), 1.0 / (float)(*(_DWORD *)(a2 + 232) - *(_DWORD *)(a2 + 224)));
  if (!(*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 144) + 128))(*(void *)(a2 + 144), 21))
  {
    unsigned int v14 = *(_DWORD *)(a2 + 228) - *(_DWORD *)(a2 + 220);
    v10.n128_f32[0] = (float)(v14 + 1) * 0.5;
    unsigned int v15 = *(_DWORD *)(a2 + 232) - *(_DWORD *)(a2 + 224);
    v11.n128_f32[0] = (float)(v15 + 1) * 0.5;
    v12.n128_f32[0] = (float)v14;
    v13.n128_f32[0] = (float)v15;
    (*(void (**)(uint64_t, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 8, v10, v11, v12, v13);
  }
  return 0;
}

uint64_t HGG4U2X<HgcBlur_g4u2_noborder>::IntermediateFormat(uint64_t a1, int a2)
{
  if (a2 <= 27) {
    return 27;
  }
  else {
    return a2;
  }
}

uint64_t HGG4U2X<HgcBlur_g4u2_noborder>::GetDOD(float *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  return HGRectIntegral(HIDWORD(a4), (float)((float)(a1[106] + (float)(int)a4) / a1[104]) + 0.5, (float)((float)(a1[107] + (float)SHIDWORD(a4)) / a1[105]) + 0.5, (float)((float)((float)((float)(int)a5 + -1.0) + a1[108]) / a1[104]) + 0.5, (float)((float)((float)((float)SHIDWORD(a5) + -1.0) + a1[109]) / a1[105]) + 0.5);
}

uint64_t HGG4U2X<HgcBlur_g4u2_noborder>::GetROI(float *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  return HGRectIntegral(HIDWORD(a4), a1[106] + (float)((float)(a1[104] * (float)(int)a4) + 0.5), a1[107] + (float)((float)(a1[105] * (float)SHIDWORD(a4)) + 0.5), (float)((float)((float)((float)(int)a5 + -1.0) * a1[104]) + 0.5) + a1[108], (float)((float)((float)((float)SHIDWORD(a5) + -1.0) * a1[105]) + 0.5) + a1[109]);
}

uint64_t HGG4U2X<HgcBlur_g4u2_noborder>::GetFilterMode()
{
  return 0;
}

void HGG4U2X<HgcBlur_g4u2>::HGG4U2X(HgcBlur_g4u2 *a1)
{
}

void sub_1B77C74C8(_Unwind_Exception *a1)
{
  HgcBlur_g4u2::~HgcBlur_g4u2(v1);
  _Unwind_Resume(a1);
}

void sub_1B77C74DC(_Unwind_Exception *a1)
{
  HgcBlur_g4u2::~HgcBlur_g4u2(v1);
  _Unwind_Resume(a1);
}

void HGG4U2X<HgcBlur_g4u2>::~HGG4U2X(HGNode *a1)
{
  HgcBlur_g4u2::~HgcBlur_g4u2(a1);

  HGObject::operator delete(v1);
}

const char *HGG4U2X<HgcBlur_g4u2>::label_A()
{
  return "HGG4U2X";
}

uint64_t HGG4U2X<HgcBlur_g4u2>::RenderTile(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 12) - *(_DWORD *)(a2 + 4);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *(_DWORD *)(a2 + 8) - *(_DWORD *)a2;
    __n128 v5 = *(float32x4_t **)(a1 + 48);
    float32x4_t v6 = v5[1];
    float32x4_t v7 = vaddq_f32(*v5, *v5);
    float32x4_t v8 = v5[2];
    float32x4_t v9 = v5[3];
    uint64_t v10 = *(_DWORD *)a2 & 1;
    uint64_t v11 = -(uint64_t)(int)vcvtms_s32_f32((float)*(int *)a2 * 0.5);
    do
    {
      __n128 v12 = (float32x4_t *)(*(void *)(a2 + 16) + 16 * *(_DWORD *)(a2 + 24) * v3);
      __n128 v13 = (float32x4_t *)(*(void *)(a2 + 80) + 16 * *(_DWORD *)(a2 + 88) * v3 + 16 * v11 - 16 * v10);
      float32x4_t v15 = v13[-1];
      float32x4_t v14 = *v13;
      float32x4_t v16 = v13[1];
      if (v10)
      {
        float32x4_t v17 = v13[2];
        *v12++ = vaddq_f32(vmulq_f32(v8, vaddq_f32(v14, v16)), vmulq_f32(v9, vaddq_f32(v15, v17)));
        int v18 = v4 - 1;
        ++v13;
        float32x4_t v15 = v14;
        if (v4 - 1 < 4) {
          goto LABEL_7;
        }
      }
      else
      {
        int v18 = v4;
        float32x4_t v17 = v13[1];
        float32x4_t v16 = *v13;
        float32x4_t v14 = v13[-1];
        if (v4 < 4) {
          goto LABEL_7;
        }
      }
      do
      {
        unsigned int v19 = v18;
        float32x4_t v14 = v17;
        float32x4_t v20 = v16;
        float32x4_t v16 = v13[2];
        float32x4_t v17 = v13[3];
        v13 += 2;
        float32x4_t *v12 = vaddq_f32(vmulq_f32(v7, v20), vmulq_f32(v6, vaddq_f32(v14, v15)));
        v12[1] = vaddq_f32(vmulq_f32(v8, vaddq_f32(v14, v20)), vmulq_f32(v9, vaddq_f32(v15, v16)));
        v12[2] = vaddq_f32(vmulq_f32(v7, v14), vmulq_f32(v6, vaddq_f32(v20, v16)));
        void v12[3] = vaddq_f32(vmulq_f32(v8, vaddq_f32(v14, v16)), vmulq_f32(v9, vaddq_f32(v20, v17)));
        v12 += 4;
        v18 -= 4;
        float32x4_t v15 = v14;
      }
      while (v19 > 7);
LABEL_7:
      if (v18 >= 2)
      {
        float32x4_t v21 = v13 + 2;
        do
        {
          unsigned int v22 = v18;
          float32x4_t v23 = v17;
          float32x4_t v24 = v16;
          float32x4_t v25 = *v21++;
          float32x4_t v17 = v25;
          float32x4_t *v12 = vaddq_f32(vmulq_f32(v7, v16), vmulq_f32(v6, vaddq_f32(v23, v14)));
          v12[1] = vaddq_f32(vmulq_f32(v8, vaddq_f32(v23, v16)), vmulq_f32(v9, vaddq_f32(v14, v25)));
          v12 += 2;
          v18 -= 2;
          float32x4_t v14 = v16;
          float32x4_t v16 = v23;
        }
        while (v22 > 3);
        if (!v18) {
          goto LABEL_3;
        }
LABEL_13:
        float32x4_t *v12 = vaddq_f32(vmulq_f32(v7, v23), vmulq_f32(v6, vaddq_f32(v17, v24)));
        goto LABEL_3;
      }
      float32x4_t v23 = v16;
      float32x4_t v24 = v14;
      if (v18) {
        goto LABEL_13;
      }
LABEL_3:
      ++v3;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HGG4U2X<HgcBlur_g4u2>::Bind(HGNode *a1, HGHandler *a2)
{
  uint64_t v3 = HGNode::Bind(a1, a2);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  return v3;
}

uint64_t HGG4U2X<HgcBlur_g4u2>::BindTexture(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 144) + 128))(*(void *)(a2 + 144), 43) == 1)
  {
    HGHandler::TexCoord((HGHandler *)a2, a3, 0, 0, 0);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)a2 + 72))(a2, a3, 0);
    (*(void (**)(uint64_t, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    (*(void (**)(uint64_t, void))(*(void *)a2 + 56))(a2, 0);
LABEL_5:
    v5.n128_u64[0] = 0;
    v6.n128_u64[0] = 0;
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
    (*(void (**)(uint64_t, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 7, v5, v6, v7, v8);
    return 0;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 144) + 128))(*(void *)(a2 + 144), 46))
  {
    HGHandler::TexCoord((HGHandler *)a2, a3, 0, 0, 0);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)a2 + 72))(a2, a3, 0);
    (*(void (**)(uint64_t, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    goto LABEL_5;
  }
  (*(void (**)(uint64_t, uint64_t, float, float, float, float))(*(void *)a2 + 136))(a2, 7, (float)*(int *)(a2 + 240), (float)*(int *)(a2 + 244), 1.0 / (float)(*(_DWORD *)(a2 + 228) - *(_DWORD *)(a2 + 220)), 1.0 / (float)(*(_DWORD *)(a2 + 232) - *(_DWORD *)(a2 + 224)));
  if (!(*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 144) + 128))(*(void *)(a2 + 144), 21))
  {
    unsigned int v14 = *(_DWORD *)(a2 + 228) - *(_DWORD *)(a2 + 220);
    v10.n128_f32[0] = (float)(v14 + 1) * 0.5;
    unsigned int v15 = *(_DWORD *)(a2 + 232) - *(_DWORD *)(a2 + 224);
    v11.n128_f32[0] = (float)(v15 + 1) * 0.5;
    v12.n128_f32[0] = (float)v14;
    v13.n128_f32[0] = (float)v15;
    (*(void (**)(uint64_t, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 8, v10, v11, v12, v13);
  }
  return 0;
}

uint64_t HGG4U2X<HgcBlur_g4u2>::IntermediateFormat(uint64_t a1, int a2)
{
  if (a2 <= 27) {
    return 27;
  }
  else {
    return a2;
  }
}

uint64_t HGG4U2X<HgcBlur_g4u2>::GetDOD(float *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  return HGRectIntegral(HIDWORD(a4), (float)((float)(a1[106] + (float)(int)a4) / a1[104]) + 0.5, (float)((float)(a1[107] + (float)SHIDWORD(a4)) / a1[105]) + 0.5, (float)((float)((float)((float)(int)a5 + -1.0) + a1[108]) / a1[104]) + 0.5, (float)((float)((float)((float)SHIDWORD(a5) + -1.0) + a1[109]) / a1[105]) + 0.5);
}

uint64_t HGG4U2X<HgcBlur_g4u2>::GetROI(float *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  return HGRectIntegral(HIDWORD(a4), a1[106] + (float)((float)(a1[104] * (float)(int)a4) + 0.5), a1[107] + (float)((float)(a1[105] * (float)SHIDWORD(a4)) + 0.5), (float)((float)((float)((float)(int)a5 + -1.0) * a1[104]) + 0.5) + a1[108], (float)((float)((float)((float)SHIDWORD(a5) + -1.0) * a1[105]) + 0.5) + a1[109]);
}

uint64_t HGG4U2X<HgcBlur_g4u2>::GetFilterMode()
{
  return 0;
}

void HGG4U2Y<HgcBlur_g4u2_rect>::HGG4U2Y(HgcBlur_g4u2_rect *a1)
{
}

void sub_1B77C7C78(_Unwind_Exception *a1)
{
  HgcBlur_g4u2_rect::~HgcBlur_g4u2_rect(v1);
  _Unwind_Resume(a1);
}

void sub_1B77C7C8C(_Unwind_Exception *a1)
{
  HgcBlur_g4u2_rect::~HgcBlur_g4u2_rect(v1);
  _Unwind_Resume(a1);
}

void HGG4U2Y<HgcBlur_g4u2_rect>::~HGG4U2Y(HGNode *a1)
{
  HgcBlur_g4u2_rect::~HgcBlur_g4u2_rect(a1);

  HGObject::operator delete(v1);
}

const char *HGG4U2Y<HgcBlur_g4u2_rect>::label_A()
{
  return "HGG4U2Y";
}

uint64_t HGG4U2Y<HgcBlur_g4u2_rect>::RenderTile(uint64_t a1, int *a2)
{
  int v2 = a2[2];
  int v3 = *a2;
  int v4 = a2[1];
  int v5 = v2 - *a2;
  int v6 = a2[3] - v4;
  __n128 v7 = *(float32x4_t **)(a1 + 48);
  float32x4_t v9 = *v7;
  float32x4_t v8 = v7[1];
  float32x4_t v10 = v7[2];
  float32x4_t v11 = v7[3];
  uint64_t v12 = a2[22];
  __n128 v13 = (float32x4_t *)(*((void *)a2 + 10) - 16 * (int)(v12 * ((v4 & 1) + vcvtms_s32_f32((float)v4 * 0.5))));
  unsigned int v14 = (float32x4_t *)*((void *)a2 + 2);
  uint64_t v15 = v12;
  uint64_t v16 = 2 * v12;
  if (v4)
  {
    if (v5)
    {
      int v17 = v3 - v2;
      int v18 = (float32x4_t *)*((void *)a2 + 2);
      unsigned int v19 = v13;
      do
      {
        *v18++ = vaddq_f32(vmulq_f32(v10, vaddq_f32(*v19, v19[v12])), vmulq_f32(v11, vaddq_f32(v19[-v12], v19[2 * v12])));
        ++v19;
        BOOL v20 = __CFADD__(v17++, 1);
      }
      while (!v20);
      LODWORD(v12) = a2[22];
    }
    v14 += a2[6];
    v13 += (int)v12;
    --v6;
  }
  float32x4_t v21 = vaddq_f32(v9, v9);
  if (v6 < 2)
  {
    if (v6 != 1) {
      return 0;
    }
    goto LABEL_19;
  }
  if (v5)
  {
    LODWORD(v22) = a2[6];
    do
    {
      uint64_t v23 = (int)v22;
      int v24 = v3 - v2;
      float32x4_t v25 = v14;
      unsigned int v26 = v13;
      do
      {
        float32x4_t v27 = *(float32x4_t *)((char *)v26 - (int)(v15 * 16));
        float32x4_t v28 = v26[v15];
        float32x4_t v29 = vaddq_f32(v27, v26[v16]);
        float32x4_t v30 = vaddq_f32(vmulq_f32(v21, *v26), vmulq_f32(v8, vaddq_f32(v27, v28)));
        float32x4_t v31 = vaddq_f32(vmulq_f32(v10, vaddq_f32(*v26, v28)), vmulq_f32(v11, v29));
        *float32x4_t v25 = v30;
        v25[v23] = v31;
        ++v26;
        ++v25;
        BOOL v20 = __CFADD__(v24++, 1);
      }
      while (!v20);
      uint64_t v22 = a2[6];
      v14 += 2 * v22;
      v13 += a2[22];
      int v32 = v6 - 2;
      BOOL v33 = v6 <= 3;
      v6 -= 2;
    }
    while (!v33);
    if (v32 == 1)
    {
LABEL_19:
      if (v5)
      {
        int v34 = v3 - v2;
        do
        {
          *v14++ = vaddq_f32(vmulq_f32(v21, *v13), vmulq_f32(v8, vaddq_f32(*(float32x4_t *)((char *)v13 - (int)(v15 * 16)), v13[v15])));
          ++v13;
          BOOL v20 = __CFADD__(v34++, 1);
        }
        while (!v20);
      }
    }
  }
  return 0;
}

uint64_t HGG4U2Y<HgcBlur_g4u2_rect>::GetFilterMode()
{
  return 0;
}

void HGG4U2Y<HgcBlur_g4u2_noborder>::HGG4U2Y(HgcBlur_g4u2_noborder *a1)
{
}

void sub_1B77C7FC0(_Unwind_Exception *a1)
{
  HgcBlur_g4u2_noborder::~HgcBlur_g4u2_noborder(v1);
  _Unwind_Resume(a1);
}

void sub_1B77C7FD4(_Unwind_Exception *a1)
{
  HgcBlur_g4u2_noborder::~HgcBlur_g4u2_noborder(v1);
  _Unwind_Resume(a1);
}

void HGG4U2Y<HgcBlur_g4u2_noborder>::~HGG4U2Y(HGNode *a1)
{
  HgcBlur_g4u2_noborder::~HgcBlur_g4u2_noborder(a1);

  HGObject::operator delete(v1);
}

const char *HGG4U2Y<HgcBlur_g4u2_noborder>::label_A()
{
  return "HGG4U2Y";
}

uint64_t HGG4U2Y<HgcBlur_g4u2_noborder>::RenderTile(uint64_t a1, int *a2)
{
  int v2 = a2[2];
  int v3 = *a2;
  int v4 = a2[1];
  int v5 = v2 - *a2;
  int v6 = a2[3] - v4;
  __n128 v7 = *(float32x4_t **)(a1 + 48);
  float32x4_t v9 = *v7;
  float32x4_t v8 = v7[1];
  float32x4_t v10 = v7[2];
  float32x4_t v11 = v7[3];
  uint64_t v12 = a2[22];
  __n128 v13 = (float32x4_t *)(*((void *)a2 + 10) - 16 * (int)(v12 * ((v4 & 1) + vcvtms_s32_f32((float)v4 * 0.5))));
  unsigned int v14 = (float32x4_t *)*((void *)a2 + 2);
  uint64_t v15 = v12;
  uint64_t v16 = 2 * v12;
  if (v4)
  {
    if (v5)
    {
      int v17 = v3 - v2;
      int v18 = (float32x4_t *)*((void *)a2 + 2);
      unsigned int v19 = v13;
      do
      {
        *v18++ = vaddq_f32(vmulq_f32(v10, vaddq_f32(*v19, v19[v12])), vmulq_f32(v11, vaddq_f32(v19[-v12], v19[2 * v12])));
        ++v19;
        BOOL v20 = __CFADD__(v17++, 1);
      }
      while (!v20);
      LODWORD(v12) = a2[22];
    }
    v14 += a2[6];
    v13 += (int)v12;
    --v6;
  }
  float32x4_t v21 = vaddq_f32(v9, v9);
  if (v6 < 2)
  {
    if (v6 != 1) {
      return 0;
    }
    goto LABEL_19;
  }
  if (v5)
  {
    LODWORD(v22) = a2[6];
    do
    {
      uint64_t v23 = (int)v22;
      int v24 = v3 - v2;
      float32x4_t v25 = v14;
      unsigned int v26 = v13;
      do
      {
        float32x4_t v27 = *(float32x4_t *)((char *)v26 - (int)(v15 * 16));
        float32x4_t v28 = v26[v15];
        float32x4_t v29 = vaddq_f32(v27, v26[v16]);
        float32x4_t v30 = vaddq_f32(vmulq_f32(v21, *v26), vmulq_f32(v8, vaddq_f32(v27, v28)));
        float32x4_t v31 = vaddq_f32(vmulq_f32(v10, vaddq_f32(*v26, v28)), vmulq_f32(v11, v29));
        *float32x4_t v25 = v30;
        v25[v23] = v31;
        ++v26;
        ++v25;
        BOOL v20 = __CFADD__(v24++, 1);
      }
      while (!v20);
      uint64_t v22 = a2[6];
      v14 += 2 * v22;
      v13 += a2[22];
      int v32 = v6 - 2;
      BOOL v33 = v6 <= 3;
      v6 -= 2;
    }
    while (!v33);
    if (v32 == 1)
    {
LABEL_19:
      if (v5)
      {
        int v34 = v3 - v2;
        do
        {
          *v14++ = vaddq_f32(vmulq_f32(v21, *v13), vmulq_f32(v8, vaddq_f32(*(float32x4_t *)((char *)v13 - (int)(v15 * 16)), v13[v15])));
          ++v13;
          BOOL v20 = __CFADD__(v34++, 1);
        }
        while (!v20);
      }
    }
  }
  return 0;
}

uint64_t HGG4U2Y<HgcBlur_g4u2_noborder>::GetFilterMode()
{
  return 0;
}

void HGG4U2Y<HgcBlur_g4u2>::HGG4U2Y(HgcBlur_g4u2 *a1)
{
}

void sub_1B77C8308(_Unwind_Exception *a1)
{
  HgcBlur_g4u2::~HgcBlur_g4u2(v1);
  _Unwind_Resume(a1);
}

void sub_1B77C831C(_Unwind_Exception *a1)
{
  HgcBlur_g4u2::~HgcBlur_g4u2(v1);
  _Unwind_Resume(a1);
}

void HGG4U2Y<HgcBlur_g4u2>::~HGG4U2Y(HGNode *a1)
{
  HgcBlur_g4u2::~HgcBlur_g4u2(a1);

  HGObject::operator delete(v1);
}

const char *HGG4U2Y<HgcBlur_g4u2>::label_A()
{
  return "HGG4U2Y";
}

uint64_t HGG4U2Y<HgcBlur_g4u2>::RenderTile(uint64_t a1, int *a2)
{
  int v2 = a2[2];
  int v3 = *a2;
  int v4 = a2[1];
  int v5 = v2 - *a2;
  int v6 = a2[3] - v4;
  __n128 v7 = *(float32x4_t **)(a1 + 48);
  float32x4_t v9 = *v7;
  float32x4_t v8 = v7[1];
  float32x4_t v10 = v7[2];
  float32x4_t v11 = v7[3];
  uint64_t v12 = a2[22];
  __n128 v13 = (float32x4_t *)(*((void *)a2 + 10) - 16 * (int)(v12 * ((v4 & 1) + vcvtms_s32_f32((float)v4 * 0.5))));
  unsigned int v14 = (float32x4_t *)*((void *)a2 + 2);
  uint64_t v15 = v12;
  uint64_t v16 = 2 * v12;
  if (v4)
  {
    if (v5)
    {
      int v17 = v3 - v2;
      int v18 = (float32x4_t *)*((void *)a2 + 2);
      unsigned int v19 = v13;
      do
      {
        *v18++ = vaddq_f32(vmulq_f32(v10, vaddq_f32(*v19, v19[v12])), vmulq_f32(v11, vaddq_f32(v19[-v12], v19[2 * v12])));
        ++v19;
        BOOL v20 = __CFADD__(v17++, 1);
      }
      while (!v20);
      LODWORD(v12) = a2[22];
    }
    v14 += a2[6];
    v13 += (int)v12;
    --v6;
  }
  float32x4_t v21 = vaddq_f32(v9, v9);
  if (v6 < 2)
  {
    if (v6 != 1) {
      return 0;
    }
    goto LABEL_19;
  }
  if (v5)
  {
    LODWORD(v22) = a2[6];
    do
    {
      uint64_t v23 = (int)v22;
      int v24 = v3 - v2;
      float32x4_t v25 = v14;
      unsigned int v26 = v13;
      do
      {
        float32x4_t v27 = *(float32x4_t *)((char *)v26 - (int)(v15 * 16));
        float32x4_t v28 = v26[v15];
        float32x4_t v29 = vaddq_f32(v27, v26[v16]);
        float32x4_t v30 = vaddq_f32(vmulq_f32(v21, *v26), vmulq_f32(v8, vaddq_f32(v27, v28)));
        float32x4_t v31 = vaddq_f32(vmulq_f32(v10, vaddq_f32(*v26, v28)), vmulq_f32(v11, v29));
        *float32x4_t v25 = v30;
        v25[v23] = v31;
        ++v26;
        ++v25;
        BOOL v20 = __CFADD__(v24++, 1);
      }
      while (!v20);
      uint64_t v22 = a2[6];
      v14 += 2 * v22;
      v13 += a2[22];
      int v32 = v6 - 2;
      BOOL v33 = v6 <= 3;
      v6 -= 2;
    }
    while (!v33);
    if (v32 == 1)
    {
LABEL_19:
      if (v5)
      {
        int v34 = v3 - v2;
        do
        {
          *v14++ = vaddq_f32(vmulq_f32(v21, *v13), vmulq_f32(v8, vaddq_f32(*(float32x4_t *)((char *)v13 - (int)(v15 * 16)), v13[v15])));
          ++v13;
          BOOL v20 = __CFADD__(v34++, 1);
        }
        while (!v20);
      }
    }
  }
  return 0;
}

uint64_t HGG4U2Y<HgcBlur_g4u2>::GetFilterMode()
{
  return 0;
}

void *std::vector<HGRef<HGNode>>::__push_back_slow_path<HGRef<HGNode>>(void **a1, void *a2)
{
  int v4 = *a1;
  int v3 = a1[1];
  uint64_t v5 = (v3 - (unsigned char *)*a1) >> 3;
  unint64_t v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) >> 61) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v8 = (unsigned char *)a1[2] - v4;
  if (v8 >> 2 > v6) {
    unint64_t v6 = v8 >> 2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v6;
  }
  if (v9)
  {
    if (v9 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    float32x4_t v10 = (char *)operator new(8 * v9);
  }
  else
  {
    float32x4_t v10 = 0;
  }
  float32x4_t v11 = &v10[8 * v5];
  *(void *)float32x4_t v11 = *a2;
  uint64_t v12 = v11 + 8;
  __n128 v13 = &v10[8 * v9];
  *a2 = 0;
  float32x4_t v21 = v13;
  if (v3 != v4)
  {
    uint64_t v14 = 0;
    do
    {
      uint64_t v15 = *(void *)&v3[v14 - 8];
      *(void *)&v11[v14 - 8] = v15;
      if (v15) {
        (*(void (**)(uint64_t))(*(void *)v15 + 16))(v15);
      }
      v14 -= 8;
    }
    while (&v3[v14] != v4);
    uint64_t v12 = v11 + 8;
    __n128 v13 = v21;
    v11 += v14;
  }
  uint64_t v16 = (char *)*a1;
  int v17 = (char *)a1[1];
  *a1 = v11;
  a1[1] = v12;
  a1[2] = v13;
  while (v17 != v16)
  {
    uint64_t v19 = *((void *)v17 - 1);
    v17 -= 8;
    uint64_t v18 = v19;
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v18 + 24))(v18);
    }
  }
  if (v16) {
    operator delete(v16);
  }
  return v12;
}

uint64_t std::__split_buffer<HGRef<HGNode>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    uint64_t v5 = *(void *)(v2 - 8);
    v2 -= 8;
    uint64_t v4 = v5;
    *(void *)(a1 + 16) = v2;
    if (v5)
    {
      (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void HGBitmapUtils::createBitmap(HGBitmapUtils *this@<X0>, HGBitmap **a2@<X8>)
{
  *a2 = 0;
  if (!this) {
    return;
  }
  unsigned int Width = CGImageGetWidth(this);
  unsigned int Height = CGImageGetHeight(this);
  size_t BitsPerComponent = CGImageGetBitsPerComponent(this);
  size_t BitsPerPixel = CGImageGetBitsPerPixel(this);
  size_t BytesPerRow = CGImageGetBytesPerRow(this);
  size_t v10 = BitsPerPixel / BitsPerComponent;
  __int16 BitmapInfo = CGImageGetBitmapInfo(this);
  uint64_t v12 = HGRectMake4i(0, 0, Width, Height);
  uint64_t v14 = v13;
  if (BitsPerComponent != 8)
  {
    if ((BitmapInfo & 0x100) == 0 && BitsPerComponent == 16)
    {
      if (v10 - 1 >= 3) {
        uint64_t v17 = 25;
      }
      else {
        uint64_t v17 = (8 * (v10 - 1)) | 3u;
      }
      goto LABEL_20;
    }
    if ((BitmapInfo & 0x100) != 0 && BitsPerComponent == 16)
    {
      size_t v15 = v10 - 1;
      if (v10 - 1 >= 3)
      {
        uint64_t v17 = 27;
        goto LABEL_20;
      }
      uint64_t v16 = (unsigned int *)&unk_1B8347004;
    }
    else
    {
      if ((BitmapInfo & 0x100) == 0 || BitsPerComponent != 32) {
        return;
      }
      size_t v15 = v10 - 1;
      if (v10 - 1 >= 3)
      {
        uint64_t v17 = 28;
        goto LABEL_20;
      }
      uint64_t v16 = (unsigned int *)&unk_1B8347010;
    }
    goto LABEL_19;
  }
  size_t v15 = v10 - 1;
  if (v10 - 1 < 3)
  {
    uint64_t v16 = (unsigned int *)&unk_1B8346FF8;
LABEL_19:
    uint64_t v17 = v16[v15];
    goto LABEL_20;
  }
  uint64_t v17 = 24;
LABEL_20:
  DataProvider = CGImageGetDataProvider(this);
  CFDataRef v19 = CGDataProviderCopyData(DataProvider);
  BytePtr = CFDataGetBytePtr(v19);
  float32x4_t v21 = (HGBitmap *)HGObject::operator new(0x80uLL);
  HGBitmap::HGBitmap(v21, v12, v14, v17, BytePtr, BytesPerRow);
  if (v21) {
    *a2 = v21;
  }
  uint64_t v22 = (HGCFDataRefHolder *)HGObject::operator new(0x18uLL);
  HGCFDataRefHolder::HGCFDataRefHolder(v22, v19);
  HGBitmap::SetStorage(v21, v22);
  CFRelease(v19);
  if (v22) {
    (*(void (**)(HGCFDataRefHolder *))(*(void *)v22 + 24))(v22);
  }
}

void sub_1B77C8960(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(a1);
}

void HGBitmapUtils::createBitmapLoader(HGBitmapUtils *this@<X0>, HGBitmapLoader **a2@<X8>)
{
  if (this)
  {
    HGBitmapUtils::createBitmap(this, &v7);
    uint64_t v4 = v7;
    if (v7)
    {
      uint64_t v5 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
      HGBitmapLoader::HGBitmapLoader(v5, v4);
      *a2 = v5;
      (*(void (**)(HGBitmap *))(*(void *)v4 + 24))(v4);
      return;
    }
    unint64_t v6 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
    HGBitmapLoader::HGBitmapLoader(v6);
  }
  else
  {
    unint64_t v6 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
    HGBitmapLoader::HGBitmapLoader(v6);
  }
  *a2 = v6;
}

void sub_1B77C8AB8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77C8AD0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77C8AE8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v2);
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

BOOL HGBitmapUtils::isPadded(HGBitmapUtils *this, HGBitmap *a2)
{
  int v3 = *((_DWORD *)this + 3);
  if ((v3 & 0x20) != 0)
  {
    MetalStorage = (HGMetalTexture *)HGMetalTexture::getMetalStorage((HGBitmap *)this, a2);
    if (MetalStorage)
    {
      uint64_t TextureRect = HGMetalTexture::GetTextureRect(MetalStorage);
      goto LABEL_8;
    }
LABEL_9:
    uint64_t v7 = *(void *)((char *)this + 20);
    uint64_t v8 = *(void *)((char *)this + 28);
    goto LABEL_10;
  }
  if ((v3 & 0x10) == 0) {
    goto LABEL_9;
  }
  if ((v3 & 0x100) != 0)
  {
    uint64_t v7 = *((void *)this + 17);
    uint64_t v8 = *((void *)this + 18);
    goto LABEL_10;
  }
  if ((v3 & 0x200) == 0) {
    goto LABEL_9;
  }
  uint64_t TextureRect = HGGLTexture::GetTextureRect((HGGLTexture *)this);
LABEL_8:
  uint64_t v7 = TextureRect;
  uint64_t v8 = v5;
LABEL_10:
  unint64_t v9 = HGFormatUtils::collapseRectForFormat((uint64_t *)((char *)this + 20), *((_DWORD *)this + 4));
  return !HGRectIsEqual(v9, v10, v7, v8);
}

uint64_t *__HGStats_private::operator<<(uint64_t *a1, uint64_t a2)
{
  (*(void (**)(void))(**(void **)(a2 + 8) + 24))(*(void *)(a2 + 8));
  uint64_t v4 = *a1;
  *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 8) = *(_DWORD *)((unsigned char *)a1 + *(void *)(*a1 - 24) + 8) & 0xFFFFFEFB | 4;
  *(uint64_t *)((char *)a1 + *(void *)(v4 - 24) + 24) = 7;
  *(uint64_t *)((char *)a1 + *(void *)(v4 - 24) + 16) = 2;
  uint64_t v5 = (void *)std::ostream::operator<<();
  unint64_t v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)" ms (", 5);
  uint64_t v7 = *v6;
  *(_DWORD *)((char *)v6 + *(void *)(*v6 - 24) + 8) = *(_DWORD *)((unsigned char *)v6 + *(void *)(*v6 - 24) + 8) & 0xFFFFFEFB | 4;
  *(uint64_t *)((char *)v6 + *(void *)(v7 - 24) + 24) = 4;
  *(uint64_t *)((char *)v6 + *(void *)(v7 - 24) + 16) = 1;
  uint64_t v8 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"%)", 2);
  if ((*(uint64_t (**)(void))(**(void **)a2 + 32))())
  {
    unint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)", ", 2);
    uint64_t v10 = *(void *)(a2 + 24);
    *(void *)((char *)v9 + *(void *)(*v9 - 24) + 24) = 10;
    (*(void (**)(uint64_t))(*(void *)v10 + 32))(v10);
    float32x4_t v11 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)" pixels", 7);
    uint64_t v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)", ", 2);
    uint64_t v13 = *(void *)(a2 + 32);
    *(void *)((char *)v12 + *(void *)(*v12 - 24) + 24) = 10;
    (*(void (**)(uint64_t))(*(void *)v13 + 40))(v13);
    uint64_t v14 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)" bytes", 6);
    size_t v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)"  (", 3);
    uint64_t v16 = *(void *)(a2 + 40);
    *(void *)((char *)v15 + *(void *)(*v15 - 24) + 24) = 4;
    (*(void (**)(uint64_t))(*(void *)v16 + 48))(v16);
    uint64_t v17 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)" tiles", 6);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)")", 1);
  }
  return a1;
}

void __HGStats_private::StatsTimer::~StatsTimer(__HGStats_private::StatsTimer *this)
{
}

uint64_t __HGStats_private::StatsTimer::destroy(__HGStats_private::StatsTimer *this)
{
  uint64_t result = *((void *)this + 1);
  if (result) {
    uint64_t result = MEMORY[0x1BA9BFBA0](result, 0x1000C40451B5BE8);
  }
  *((void *)this + 1) = 0;
  return result;
}

double __HGStats_private::StatsTimer::time(__HGStats_private::StatsTimer *this)
{
  uint64_t v1 = (HGProfiler *)*((void *)this + 1);
  if (v1) {
    return HGProfiler::getTime(v1);
  }
  else {
    return 0.0;
  }
}

void __HGStats_private::StatsProfile::~StatsProfile(__HGStats_private::StatsProfile *this)
{
}

uint64_t __HGStats_private::probe(__HGStats_private *this, __HGStats_private::StatsProfile *a2, double a3)
{
  uint64_t v4 = a2;
  (*(void (**)(__HGStats_private *))(*(void *)this + 24))(this);
  (*(void (**)(__HGStats_private *))(*(void *)this + 24))(this);
  (*(void (**)(__HGStats_private *))(*(void *)this + 32))(this);
  (*(void (**)(__HGStats_private *))(*(void *)this + 40))(this);
  (*(void (**)(__HGStats_private *))(*(void *)this + 48))(this);
  return v4;
}

uint64_t __HGStats_private::probe<HGNode>(uint64_t a1, uint64_t a2)
{
  return a1;
}

uint64_t __HGStats_private::probe<std::type_info const>(uint64_t a1, uint64_t a2)
{
  return 0;
}

uint64_t __HGStats_private::probe<HGNode>(void *a1)
{
  uint64_t v1 = *a1;
  (*(void (**)(void))(*(void *)*a1 + 48))(*a1);
  return v1;
}

uint64_t __HGStats_private::probe<std::type_info const>()
{
  return 0;
}

uint64_t *HGStats::UnitStatsImpl::getProfiler(HGStats::UnitStatsImpl *this, HGNode *a2)
{
  uint64_t v5 = (uint64_t **)((char *)this + 32);
  uint64_t v4 = (char *)*((void *)this + 4);
  if (v4)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v6 = (uint64_t **)v4;
        unint64_t v7 = *((void *)v4 + 4);
        if (v7 <= (unint64_t)a2) {
          break;
        }
        uint64_t v4 = (char *)*v6;
        uint64_t v5 = v6;
        if (!*v6) {
          goto LABEL_8;
        }
      }
      if (v7 >= (unint64_t)a2) {
        break;
      }
      uint64_t v4 = (char *)v6[1];
      if (!v4)
      {
        uint64_t v5 = v6 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
    unint64_t v6 = (uint64_t **)((char *)this + 32);
LABEL_8:
    uint64_t v8 = (char *)v6;
    unint64_t v6 = (uint64_t **)operator new(0x50uLL);
    v6[4] = (uint64_t *)a2;
    v6[5] = (uint64_t *)&unk_1F10D9B90;
    *((_OWORD *)v6 + 3) = 0u;
    *((_OWORD *)v6 + 4) = 0u;
    *unint64_t v6 = 0;
    v6[1] = 0;
    void v6[2] = (uint64_t *)v8;
    *uint64_t v5 = (uint64_t *)v6;
    uint64_t v9 = **((void **)this + 3);
    uint64_t v10 = (uint64_t *)v6;
    if (v9)
    {
      *((void *)this + 3) = v9;
      uint64_t v10 = *v5;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 4), v10);
    ++*((void *)this + 5);
  }
  if (!v6[6]) {
    operator new();
  }
  return v6[6];
}

void sub_1B77C9524(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1000C40451B5BE8);
  _Unwind_Resume(a1);
}

void HGStats::UnitStatsImpl::start(HGStats::UnitStatsImpl *this, HGProfiler *a2)
{
  if (*((unsigned char *)this + 120))
  {
    uint64_t v4 = *((void *)this + 13);
    uint64_t v5 = (char **)((char *)this + 96);
    if (*((void *)this + 12) != v4) {
      HGProfiler::stop(*(HGProfiler **)(v4 - 8));
    }
    HGProfiler::start(a2);
    unint64_t v7 = (char *)*((void *)this + 13);
    unint64_t v6 = *((void *)this + 14);
    if ((unint64_t)v7 < v6)
    {
      *(void *)unint64_t v7 = a2;
      uint64_t v8 = (uint64_t)(v7 + 8);
LABEL_26:
      *((void *)this + 13) = v8;
      return;
    }
    uint64_t v9 = *v5;
    uint64_t v10 = v7 - *v5;
    uint64_t v11 = v10 >> 3;
    unint64_t v12 = (v10 >> 3) + 1;
    if (v12 >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v13 = v6 - (void)v9;
    if (v13 >> 2 > v12) {
      unint64_t v12 = v13 >> 2;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v12;
    }
    if (v14)
    {
      if (v14 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      size_t v15 = operator new(8 * v14);
      uint64_t v16 = &v15[8 * v11];
      uint64_t v17 = &v15[8 * v14];
      void *v16 = a2;
      uint64_t v8 = (uint64_t)(v16 + 1);
      uint64_t v18 = (char *)(v7 - v9);
      if (v7 == v9) {
        goto LABEL_24;
      }
    }
    else
    {
      size_t v15 = 0;
      uint64_t v16 = (void *)(8 * v11);
      uint64_t v17 = 0;
      *(void *)(8 * v11) = a2;
      uint64_t v8 = 8 * v11 + 8;
      uint64_t v18 = (char *)(v7 - v9);
      if (v7 == v9)
      {
LABEL_24:
        *((void *)this + 12) = v16;
        *((void *)this + 13) = v8;
        *((void *)this + 14) = v17;
        if (v7) {
          operator delete(v7);
        }
        goto LABEL_26;
      }
    }
    unint64_t v19 = (unint64_t)(v18 - 8);
    if (v19 < 0x58) {
      goto LABEL_32;
    }
    if ((unint64_t)(v7 - &v15[v10]) < 0x20) {
      goto LABEL_32;
    }
    uint64_t v20 = (v19 >> 3) + 1;
    uint64_t v21 = 8 * (v20 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v22 = &v7[-v21];
    uint64_t v16 = (void *)((char *)v16 - v21);
    uint64_t v23 = &v15[8 * v11 - 16];
    int v24 = v7 - 16;
    uint64_t v25 = v20 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v26 = *(_OWORD *)v24;
      *(v23 - 1) = *((_OWORD *)v24 - 1);
      *uint64_t v23 = v26;
      v23 -= 2;
      v24 -= 32;
      v25 -= 4;
    }
    while (v25);
    unint64_t v7 = v22;
    if (v20 != (v20 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_32:
      do
      {
        uint64_t v27 = *((void *)v7 - 1);
        v7 -= 8;
        *--uint64_t v16 = v27;
      }
      while (v7 != v9);
    }
    unint64_t v7 = *v5;
    goto LABEL_24;
  }
}

int64x2_t HGStats::UnitStatsImpl::renderTile(HGStats::UnitStatsImpl *this, HGNode *a2, uint64_t a3)
{
  if (*((unsigned char *)this + 120))
  {
    unint64_t v7 = (uint64_t **)((char *)this + 32);
    unint64_t v6 = (int64x2_t *)*((void *)this + 4);
    if (v6)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v8 = v6;
          unint64_t v9 = v6[2].u64[0];
          if (v9 <= (unint64_t)a2) {
            break;
          }
          unint64_t v6 = (int64x2_t *)v8->i64[0];
          unint64_t v7 = (uint64_t **)v8;
          if (!v8->i64[0]) {
            goto LABEL_9;
          }
        }
        if (v9 >= (unint64_t)a2) {
          break;
        }
        unint64_t v6 = (int64x2_t *)v8->i64[1];
        if (!v6)
        {
          unint64_t v7 = (uint64_t **)&v8->i64[1];
          goto LABEL_9;
        }
      }
    }
    else
    {
      uint64_t v8 = (int64x2_t *)((char *)this + 32);
LABEL_9:
      uint64_t v10 = v8;
      uint64_t v8 = (int64x2_t *)operator new(0x50uLL);
      v8[2].i64[0] = (uint64_t)a2;
      v8[2].i64[1] = (uint64_t)&unk_1F10D9B90;
      v8[3] = 0u;
      v8[4] = 0u;
      v8->i64[0] = 0;
      v8->i64[1] = 0;
      v8[1].i64[0] = (uint64_t)v10;
      char *v7 = (uint64_t *)v8;
      uint64_t v11 = **((void **)this + 3);
      unint64_t v12 = (uint64_t *)v8;
      if (v11)
      {
        *((void *)this + 3) = v11;
        unint64_t v12 = *v7;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 4), v12);
      ++*((void *)this + 5);
    }
    v8[3].i64[1] += a3;
    int64x2_t v13 = vdupq_n_s64(1uLL);
    v13.i64[0] = 16 * a3;
    int64x2_t result = vaddq_s64(v8[4], v13);
    v8[4] = result;
  }
  return result;
}

void HGStats::CoreStats<HGNode,__HGStats_private::StatsTimer>::clear(uint64_t a1)
{
  uint64_t v2 = *(char **)a1;
  int v3 = *(char **)(a1 + 8);
  if (*(char **)a1 == v3)
  {
    unint64_t v7 = *(char **)a1;
  }
  else
  {
    uint64_t v4 = *(char **)a1;
    uint64_t v5 = *(char **)a1;
    do
    {
      uint64_t v6 = *(void *)v5;
      v5 += 40;
      (*(void (**)(char *))(v6 + 16))(v2);
      v4 += 40;
      uint64_t v2 = v5;
    }
    while (v5 != v3);
    uint64_t v2 = *(char **)a1;
    unint64_t v7 = *(char **)(a1 + 8);
    if (v7 == *(char **)a1)
    {
      uint64_t v2 = *(char **)(a1 + 8);
    }
    else
    {
      uint64_t v8 = v7 - 40;
      unint64_t v9 = v7 - 40;
      uint64_t v10 = v7 - 40;
      do
      {
        uint64_t v11 = *(void (***)(char *))v10;
        v10 -= 40;
        (*v11)(v9);
        v8 -= 40;
        BOOL v12 = v9 == v2;
        unint64_t v9 = v10;
      }
      while (!v12);
      unint64_t v7 = *(char **)a1;
    }
  }
  *(void *)(a1 + 8) = v2;
  unint64_t v13 = 0xCCCCCCCCCCCCCCCDLL * ((v2 - v7) >> 3);
  if (v13 > 4)
  {
    if (v2 - v7 != 200)
    {
      unint64_t v14 = v7 + 200;
      if (v2 != v7 + 200)
      {
        size_t v15 = v2 - 40;
        uint64_t v16 = v15;
        uint64_t v17 = v15;
        do
        {
          uint64_t v18 = *(void (***)(char *))v17;
          v17 -= 40;
          (*v18)(v16);
          v15 -= 40;
          BOOL v12 = v16 == v14;
          uint64_t v16 = v17;
        }
        while (!v12);
      }
      *(void *)(a1 + 8) = v14;
    }
  }
  else
  {
    std::vector<__HGStats_private::StatsTimer>::__append((void **)a1, 5 - v13);
  }
  unint64_t v19 = *(void **)(a1 + 24);
  uint64_t v20 = (void *)(a1 + 32);
  if (v19 != (void *)(a1 + 32))
  {
    do
    {
      uint64_t v23 = v19[6];
      if (v23) {
        MEMORY[0x1BA9BFBA0](v23, 0x1000C40451B5BE8);
      }
      v19[6] = 0;
      int v24 = (void *)v19[1];
      if (v24)
      {
        do
        {
          uint64_t v25 = v24;
          int v24 = (void *)*v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          uint64_t v25 = (void *)v19[2];
          BOOL v12 = *v25 == (void)v19;
          unint64_t v19 = v25;
        }
        while (!v12);
      }
      unint64_t v19 = v25;
    }
    while (v25 != v20);
  }
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(a1 + 24, *(void **)(a1 + 32));
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *(void *)(a1 + 24) = v20;
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(a1 + 48, *(void **)(a1 + 56));
  *(void *)(a1 + 48) = a1 + 56;
  *(void *)(a1 + 56) = 0;
  uint64_t v22 = *(void **)(a1 + 80);
  uint64_t v21 = (void *)(a1 + 80);
  *(v21 - 2) = 0;
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)(v21 - 1), v22);
  *(v21 - 1) = v21;
  void *v21 = 0;
  v21[1] = 0;
}

uint64_t *HGStats::UnitStatsImpl::dump(uint64_t *result, void *a2, char a3)
{
  if ((a3 & 0xFE) != 0)
  {
    v67[4] = v6;
    v67[5] = v5;
    v67[16] = v3;
    v67[17] = v4;
    unint64_t v9 = result;
    uint64_t v10 = (void *)result[3];
    int v63 = &unk_1F10D9BD8;
    long long v64 = 0u;
    long long v65 = 0u;
    std::accumulate[abi:ne180100]<std::__map_iterator<std::__tree_iterator<std::__value_type<HGNode *,__HGStats_private::StatsTimer>,std::__tree_node<std::__value_type<HGNode *,__HGStats_private::StatsTimer>,void *> *,long>>,__HGStats_private::StatsProfile,__HGStats_private::TotalAccumulator<HGNode,__HGStats_private::StatsTimer>>(v10, v9 + 4, (uint64_t)&v63, (uint64_t)v61);
    __HGStats_private::OpStats<__HGStats_private::StatsTimer>::getTotalStats(v9, (uint64_t)&v63);
    double v11 = v62;
    double v12 = *(double *)&v64;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"\n", 1);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"/----- exec unit stats:\n", 24);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|\n", 2);
    if ((a3 & 2) != 0)
    {
      double v13 = v11 + v12;
      unint64_t v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|", 1);
      *(void *)((char *)v14 + *(void *)(*v14 - 24) + 24) = 16;
      size_t v15 = strlen(__HGStats_private::opNames[0]);
      uint64_t v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)__HGStats_private::opNames[0], v15);
      uint64_t v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)" : ", 3);
      uint64_t v55 = *v9;
      uint64_t v56 = v55;
      double v57 = v13;
      uint64_t v58 = v55;
      uint64_t v59 = v55;
      uint64_t v60 = v55;
      uint64_t v18 = __HGStats_private::operator<<(v17, (uint64_t)&v55);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)"\n", 1);
      unint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|", 1);
      *(void *)((char *)v19 + *(void *)(*v19 - 24) + 24) = 16;
      size_t v20 = strlen(off_1E9EDEC50[0]);
      uint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)off_1E9EDEC50[0], v20);
      uint64_t v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)" : ", 3);
      uint64_t v55 = *v9 + 40;
      uint64_t v56 = v55;
      double v57 = v13;
      uint64_t v58 = v55;
      uint64_t v59 = v55;
      uint64_t v60 = v55;
      uint64_t v23 = __HGStats_private::operator<<(v22, (uint64_t)&v55);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)"\n", 1);
      int v24 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|", 1);
      *(void *)((char *)v24 + *(void *)(*v24 - 24) + 24) = 16;
      size_t v25 = strlen(off_1E9EDEC58[0]);
      long long v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)off_1E9EDEC58[0], v25);
      uint64_t v27 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)" : ", 3);
      uint64_t v55 = *v9 + 80;
      uint64_t v56 = v55;
      double v57 = v13;
      uint64_t v58 = v55;
      uint64_t v59 = v55;
      uint64_t v60 = v55;
      float32x4_t v28 = __HGStats_private::operator<<(v27, (uint64_t)&v55);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v28, (uint64_t)"\n", 1);
      float32x4_t v29 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|", 1);
      *(void *)((char *)v29 + *(void *)(*v29 - 24) + 24) = 16;
      size_t v30 = strlen(off_1E9EDEC60[0]);
      float32x4_t v31 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v29, (uint64_t)off_1E9EDEC60[0], v30);
      int v32 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)" : ", 3);
      uint64_t v55 = *v9 + 120;
      uint64_t v56 = v55;
      double v57 = v13;
      uint64_t v58 = v55;
      uint64_t v59 = v55;
      uint64_t v60 = v55;
      BOOL v33 = __HGStats_private::operator<<(v32, (uint64_t)&v55);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v33, (uint64_t)"\n", 1);
      int v34 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|", 1);
      *(void *)((char *)v34 + *(void *)(*v34 - 24) + 24) = 16;
      size_t v35 = strlen(off_1E9EDEC68);
      float32x4_t v36 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v34, (uint64_t)off_1E9EDEC68, v35);
      float32x4_t v37 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)" : ", 3);
      uint64_t v55 = *v9 + 160;
      uint64_t v56 = v55;
      double v57 = v13;
      uint64_t v58 = v55;
      uint64_t v59 = v55;
      uint64_t v60 = v55;
      float32x4_t v38 = __HGStats_private::operator<<(v37, (uint64_t)&v55);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)"\n", 1);
      uint64_t v39 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|", 1);
      *(void *)((char *)v39 + *(void *)(*v39 - 24) + 24) = 16;
      uint64_t v40 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v39, (uint64_t)"process", 7);
      uint64_t v41 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v40, (uint64_t)" : ", 3);
      v54[0] = v61;
      v54[1] = v61;
      *(double *)&double v54[2] = v13;
      v54[3] = v61;
      v54[4] = v61;
      v54[5] = v61;
      uint64_t v42 = __HGStats_private::operator<<(v41, (uint64_t)v54);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v42, (uint64_t)"\n", 1);
      unsigned int v43 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|", 1);
      *(void *)((char *)v43 + *(void *)(*v43 - 24) + 24) = 16;
      float32x4_t v44 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v43, (uint64_t)"total time", 10);
      float32x4_t v45 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v44, (uint64_t)" : ", 3);
      uint64_t v46 = *v45;
      *(_DWORD *)((char *)v45 + *(void *)(*v45 - 24) + 8) = *(_DWORD *)((unsigned char *)v45 + *(void *)(*v45 - 24) + 8) & 0xFFFFFEFB | 4;
      *(uint64_t *)((char *)v45 + *(void *)(v46 - 24) + 24) = 7;
      *(uint64_t *)((char *)v45 + *(void *)(v46 - 24) + 16) = 2;
      float32x4_t v47 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v47, (uint64_t)" ms\n", 4);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|\n", 2);
      if ((a3 & 8) == 0)
      {
LABEL_4:
        if ((a3 & 0x20) == 0) {
          return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"\\----------------- \n\n", 21);
        }
        goto LABEL_8;
      }
    }
    else if ((a3 & 8) == 0)
    {
      goto LABEL_4;
    }
    HGStats::CoreStats<HGNode,__HGStats_private::StatsTimer>::printNodeStats((uint64_t)v9, a2, (uint64_t)v61);
    if ((a3 & 0x20) == 0) {
      return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"\\----------------- \n\n", 21);
    }
LABEL_8:
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"| -- node in-N-out ROI ratios (per input):\n", 43);
    float32x4_t v48 = (void *)v9[6];
    float32x4_t v49 = v9 + 7;
    v67[0] = a2;
    v67[1] = 0;
    if (v48 != v49)
    {
      do
      {
        long long v50 = *((_OWORD *)v48 + 3);
        v66[0] = *((_OWORD *)v48 + 2);
        v66[1] = v50;
        __HGStats_private::InOutRoiStatsPrinter<HGNode>::operator()(v67, (uint64_t *)v66);
        float32x4_t v51 = (void *)v48[1];
        if (v51)
        {
          do
          {
            float32x4_t v52 = v51;
            float32x4_t v51 = (void *)*v51;
          }
          while (v51);
        }
        else
        {
          do
          {
            float32x4_t v52 = (void *)v48[2];
            BOOL v53 = *v52 == (void)v48;
            float32x4_t v48 = v52;
          }
          while (!v53);
        }
        float32x4_t v48 = v52;
      }
      while (v52 != v49);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|\n", 2);
    return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"\\----------------- \n\n", 21);
  }
  return result;
}

double __HGStats_private::OpStats<__HGStats_private::StatsTimer>::getTotalStats@<D0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = (void *)*a1;
  uint64_t v4 = (void *)a1[1];
  long long v9 = 0u;
  long long v10 = 0u;
  if ((void *)*a1 != v4)
  {
    uint64_t v5 = (void *)*a1;
    uint64_t v6 = (void *)*a1;
    do
    {
      *(double *)&long long v11 = (*(double (**)(void *))(*v5 + 24))(v5) + *(double *)&v9;
      *((void *)&v11 + 1) = *((void *)&v9 + 1) + (*(uint64_t (**)(void *))(*v5 + 32))(v5);
      *(void *)&long long v12 = v10 + (*(uint64_t (**)(void *))(*v5 + 40))(v5);
      uint64_t v7 = *v6;
      v6 += 5;
      *((void *)&v12 + 1) = *((void *)&v10 + 1) + (*(uint64_t (**)(void *))(v7 + 48))(v5);
      long long v9 = v11;
      long long v10 = v12;
      v3 += 5;
      uint64_t v5 = v6;
    }
    while (v6 != v4);
  }
  *(void *)a2 = &unk_1F10D9BD8;
  double result = *(double *)&v9;
  *(_OWORD *)(a2 + 8) = v9;
  *(_OWORD *)(a2 + 24) = v10;
  return result;
}

double __HGStats_private::StatsProfile::time(__HGStats_private::StatsProfile *this)
{
  return *((double *)this + 1);
}

void *HGStats::CoreStats<HGNode,__HGStats_private::StatsTimer>::printNodeStats(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"| -- per node process times:\n", 29);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"| read:\n", 8);
  uint64_t v7 = *(void **)(a1 + 24);
  uint64_t v8 = (void *)(a1 + 32);
  uint64_t v22 = a2;
  uint64_t v23 = a3;
  if (v7 != (void *)(a1 + 32))
  {
    do
    {
      uint64_t v18 = (void *)v7[4];
      unint64_t v19 = &unk_1F10D9B90;
      long long v9 = *((_OWORD *)v7 + 4);
      long long v20 = *((_OWORD *)v7 + 3);
      long long v21 = v9;
      __HGStats_private::NodeStatsPrinter<HGNode,__HGStats_private::StatsTimer,(__HGStats_private::NodeStatsType)1>::operator()(&v22, &v18);
      long long v10 = (void *)v7[1];
      if (v10)
      {
        do
        {
          long long v11 = v10;
          long long v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          long long v11 = (void *)v7[2];
          BOOL v12 = *v11 == (void)v7;
          uint64_t v7 = v11;
        }
        while (!v12);
      }
      uint64_t v7 = v11;
    }
    while (v11 != v8);
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"| render:\n", 10);
  double v13 = *(void **)(a1 + 24);
  uint64_t v22 = a2;
  uint64_t v23 = a3;
  if (v13 != v8)
  {
    do
    {
      uint64_t v18 = (void *)v13[4];
      unint64_t v19 = &unk_1F10D9B90;
      long long v14 = *((_OWORD *)v13 + 4);
      long long v20 = *((_OWORD *)v13 + 3);
      long long v21 = v14;
      __HGStats_private::NodeStatsPrinter<HGNode,__HGStats_private::StatsTimer,(__HGStats_private::NodeStatsType)0>::operator()(&v22, &v18);
      size_t v15 = (void *)v13[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          size_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)v13[2];
          BOOL v12 = *v16 == (void)v13;
          double v13 = v16;
        }
        while (!v12);
      }
      double v13 = v16;
    }
    while (v16 != v8);
  }
  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|\n", 2);
}

void HGStats::GraphStatsImpl::GraphStatsImpl(HGStats::GraphStatsImpl *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  std::vector<__HGStats_private::StatsProfile>::__append((void **)this + 1, 5uLL);
  *((void *)this + 11) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 4) = (char *)this + 40;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = (char *)this + 64;
  *((void *)this + 12) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 1CVOpenGLESTextureCacheFlush(this[3], 0) = (char *)this + 88;
  operator new();
}

void sub_1B77CA430(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;
  MEMORY[0x1BA9BFBA0](v3, 0x1000C40451B5BE8);
  HGStats::CoreStats<HGNode,__HGStats_private::StatsProfile>::~CoreStats(v1);
  _Unwind_Resume(a1);
}

void sub_1B77CA460(_Unwind_Exception *a1)
{
  HGStats::CoreStats<HGNode,__HGStats_private::StatsProfile>::~CoreStats(v1);
  _Unwind_Resume(a1);
}

void sub_1B77CA474(_Unwind_Exception *exception_object)
{
  if (*v1) {
    HGStats::GraphStatsImpl::GraphStatsImpl(v2, *v1);
  }
  _Unwind_Resume(exception_object);
}

char **HGStats::CoreStats<HGNode,__HGStats_private::StatsProfile>::~CoreStats(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 80);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(a1 + 72, *(void **)(a1 + 80));
  *(void *)(a1 + 72) = v2;
  *(void *)(a1 + 88) = 0;
  *uint64_t v2 = 0;
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(a1 + 48, *(void **)(a1 + 56));
  *(void *)(a1 + 48) = a1 + 56;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 56) = 0;
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(a1 + 24, *(void **)(a1 + 32));
  *(void *)(a1 + 24) = a1 + 32;
  *(void *)(a1 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *(void *)(a1 + 32) = 0;

  return __HGStats_private::OpStats<__HGStats_private::StatsProfile>::~OpStats((char **)a1);
}

void HGStats::GraphStatsImpl::merge(HGStats::GraphStatsImpl *this, const HGStats::UnitStatsImpl *a2)
{
  __HGStats_private::OpStats<__HGStats_private::StatsProfile>::merge<__HGStats_private::StatsTimer>((uint64_t *)this + 1, a2);
  uint64_t v4 = (const HGStats::UnitStatsImpl *)*((void *)a2 + 3);
  uint64_t v17 = (char *)this + 32;
  if (v4 != (const HGStats::UnitStatsImpl *)((char *)a2 + 32))
  {
    do
    {
      v14.i64[0] = *((void *)v4 + 4);
      v14.i64[1] = (uint64_t)&unk_1F10D9B90;
      long long v5 = *((_OWORD *)v4 + 4);
      long long v15 = *((_OWORD *)v4 + 3);
      long long v16 = v5;
      __HGStats_private::MergeNodeStats<HGNode,__HGStats_private::StatsTimer,HGNode,__HGStats_private::StatsProfile>::operator()(&v17, &v14);
      uint64_t v6 = (const HGStats::UnitStatsImpl *)*((void *)v4 + 1);
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          uint64_t v6 = *(const HGStats::UnitStatsImpl **)v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (const HGStats::UnitStatsImpl *)*((void *)v4 + 2);
          BOOL v8 = *(void *)v7 == (void)v4;
          uint64_t v4 = v7;
        }
        while (!v8);
      }
      uint64_t v4 = v7;
    }
    while (v7 != (const HGStats::UnitStatsImpl *)((char *)a2 + 32));
  }
  long long v9 = (char *)*((void *)a2 + 6);
  long long v10 = (char *)a2 + 56;
  uint64_t v17 = (char *)this + 56;
  if (v9 != v10)
  {
    do
    {
      long long v11 = *((_OWORD *)v9 + 3);
      int64x2_t v14 = *((int64x2_t *)v9 + 2);
      long long v15 = v11;
      __HGStats_private::MergeRoiStats<HGNode,HGNode>::operator()(&v17, &v14);
      BOOL v12 = (char *)*((void *)v9 + 1);
      if (v12)
      {
        do
        {
          double v13 = v12;
          BOOL v12 = *(char **)v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          double v13 = (char *)*((void *)v9 + 2);
          BOOL v8 = *(void *)v13 == (void)v9;
          long long v9 = v13;
        }
        while (!v8);
      }
      long long v9 = v13;
    }
    while (v13 != v10);
  }
}

uint64_t __HGStats_private::OpStats<__HGStats_private::StatsProfile>::merge<__HGStats_private::StatsTimer>(uint64_t *a1, void *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *a1;
  *(double *)(v5 + 8) = (*(double (**)(void))(*(void *)*a2 + 24))(*a2) + *(double *)(v5 + 8);
  *(void *)(v5 + 16) += (*(uint64_t (**)(uint64_t))(*(void *)v4 + 32))(v4);
  *(void *)(v5 + 24) += (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4);
  *(void *)(v5 + 32) += (*(uint64_t (**)(uint64_t))(*(void *)v4 + 48))(v4);
  uint64_t v6 = *a1;
  uint64_t v7 = *a2 + 40;
  *(double *)(v6 + 48) = (*(double (**)(uint64_t))(*(void *)v7 + 24))(v7) + *(double *)(v6 + 48);
  *(void *)(v6 + 56) += (*(uint64_t (**)(uint64_t))(*(void *)v7 + 32))(v7);
  *(void *)(v6 + 64) += (*(uint64_t (**)(uint64_t))(*(void *)v7 + 40))(v7);
  *(void *)(v6 + 72) += (*(uint64_t (**)(uint64_t))(*(void *)v7 + 48))(v7);
  uint64_t v8 = *a1;
  uint64_t v9 = *a2 + 80;
  *(double *)(v8 + 88) = (*(double (**)(uint64_t))(*(void *)v9 + 24))(v9) + *(double *)(v8 + 88);
  *(void *)(v8 + 96) += (*(uint64_t (**)(uint64_t))(*(void *)v9 + 32))(v9);
  *(void *)(v8 + 104) += (*(uint64_t (**)(uint64_t))(*(void *)v9 + 40))(v9);
  *(void *)(v8 + 112) += (*(uint64_t (**)(uint64_t))(*(void *)v9 + 48))(v9);
  uint64_t v10 = *a1;
  uint64_t v11 = *a2 + 120;
  *(double *)(v10 + 128) = (*(double (**)(uint64_t))(*(void *)v11 + 24))(v11) + *(double *)(v10 + 128);
  *(void *)(v10 + 136) += (*(uint64_t (**)(uint64_t))(*(void *)v11 + 32))(v11);
  *(void *)(v10 + 144) += (*(uint64_t (**)(uint64_t))(*(void *)v11 + 40))(v11);
  *(void *)(v10 + 152) += (*(uint64_t (**)(uint64_t))(*(void *)v11 + 48))(v11);
  BOOL v12 = (void *)*a2;
  uint64_t v13 = *a1;
  uint64_t v14 = v12[20];
  v12 += 20;
  *(double *)(v13 + 168) = (*(double (**)(void *))(v14 + 24))(v12) + *(double *)(v13 + 168);
  *(void *)(v13 + 176) += (*(uint64_t (**)(void *))(*v12 + 32))(v12);
  *(void *)(v13 + 184) += (*(uint64_t (**)(void *))(*v12 + 40))(v12);
  uint64_t result = (*(uint64_t (**)(void *))(*v12 + 48))(v12);
  *(void *)(v13 + 192) += result;
  return result;
}

void HGStats::CoreStats<HGNode,__HGStats_private::StatsProfile>::clear(uint64_t a1)
{
  uint64_t v2 = *(char **)a1;
  uint64_t v3 = *(char **)(a1 + 8);
  if (*(char **)a1 == v3)
  {
    uint64_t v7 = *(char **)a1;
  }
  else
  {
    uint64_t v4 = *(char **)a1;
    uint64_t v5 = *(char **)a1;
    do
    {
      uint64_t v6 = *(void *)v5;
      v5 += 40;
      (*(void (**)(char *))(v6 + 16))(v2);
      v4 += 40;
      uint64_t v2 = v5;
    }
    while (v5 != v3);
    uint64_t v2 = *(char **)a1;
    uint64_t v7 = *(char **)(a1 + 8);
    if (v7 == *(char **)a1)
    {
      uint64_t v2 = *(char **)(a1 + 8);
    }
    else
    {
      uint64_t v8 = v7 - 40;
      uint64_t v9 = v7 - 40;
      uint64_t v10 = v7 - 40;
      do
      {
        uint64_t v11 = *(void (***)(char *))v10;
        v10 -= 40;
        (*v11)(v9);
        v8 -= 40;
        BOOL v12 = v9 == v2;
        uint64_t v9 = v10;
      }
      while (!v12);
      uint64_t v7 = *(char **)a1;
    }
  }
  *(void *)(a1 + 8) = v2;
  unint64_t v13 = 0xCCCCCCCCCCCCCCCDLL * ((v2 - v7) >> 3);
  if (v13 > 4)
  {
    if (v2 - v7 != 200)
    {
      uint64_t v14 = v7 + 200;
      if (v2 != v7 + 200)
      {
        long long v15 = v2 - 40;
        long long v16 = v15;
        uint64_t v17 = v15;
        do
        {
          uint64_t v18 = *(void (***)(char *))v17;
          v17 -= 40;
          (*v18)(v16);
          v15 -= 40;
          BOOL v12 = v16 == v14;
          long long v16 = v17;
        }
        while (!v12);
      }
      *(void *)(a1 + 8) = v14;
    }
  }
  else
  {
    std::vector<__HGStats_private::StatsProfile>::__append((void **)a1, 5 - v13);
  }
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(a1 + 24, *(void **)(a1 + 32));
  *(void *)(a1 + 24) = a1 + 32;
  *(void *)(a1 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *(void *)(a1 + 32) = 0;
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(a1 + 48, *(void **)(a1 + 56));
  *(void *)(a1 + 48) = a1 + 56;
  *(void *)(a1 + 56) = 0;
  long long v20 = *(void **)(a1 + 80);
  unint64_t v19 = (void *)(a1 + 80);
  *(v19 - 2) = 0;
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)(v19 - 1), v20);
  *(v19 - 1) = v19;
  *unint64_t v19 = 0;
  v19[1] = 0;
}

void HGStats::GraphStatsImpl::dump(uint64_t a1, void *a2, __int16 a3)
{
  HGProfiler::getTime(*(HGProfiler **)a1);
  if ((a3 & 0x100) != 0)
  {
    uint64_t v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"+ Helium Graph Render Time : ", 29);
    uint64_t v7 = *v6;
    *(_DWORD *)((char *)v6 + *(void *)(*v6 - 24) + 8) = *(_DWORD *)((unsigned char *)v6 + *(void *)(*v6 - 24) + 8) & 0xFFFFFEFB | 4;
    *(uint64_t *)((char *)v6 + *(void *)(v7 - 24) + 24) = 7;
    *(uint64_t *)((char *)v6 + *(void *)(v7 - 24) + 16) = 2;
    uint64_t v8 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" ms\n", 4);
  }
  if ((a3 & 0xFE00) != 0)
  {
    uint64_t v9 = a1 + 8;
    uint64_t v10 = *(void **)(a1 + 32);
    *(void *)&v28[0] = &unk_1F10D9C60;
    *((void *)&v28[0] + 1) = &unk_1F10D9BD8;
    memset(&v28[1], 0, 32);
    float32x4_t v29 = &unk_1F10D9BD8;
    long long v30 = 0u;
    long long v31 = 0u;
    int v32 = &unk_1F10D9BD8;
    long long v33 = 0u;
    long long v34 = 0u;
    std::accumulate[abi:ne180100]<std::__map_iterator<std::__tree_iterator<std::__value_type<HGNode *,__HGStats_private::StatsProfile>,std::__tree_node<std::__value_type<HGNode *,__HGStats_private::StatsProfile>,void *> *,long>>,__HGStats_private::RRStatsProfile,__HGStats_private::ReadRenderAccumulator<HGNode,__HGStats_private::StatsProfile>>(v10, (void *)(a1 + 40), v28, (uint64_t)v27);
    __HGStats_private::OpStats<__HGStats_private::StatsTimer>::getTotalStats((void *)(a1 + 8), (uint64_t)v28);
    double v11 = *(double *)&v27[12];
    double v12 = *((double *)v28 + 1);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"\n", 1);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"/----- Graph Render Stats:\n", 27);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|\n", 2);
    if ((a3 & 0x200) != 0)
    {
      unint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|", 1);
      *(void *)((char *)v13 + *(void *)(*v13 - 24) + 24) = 16;
      uint64_t v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"wall time", 9);
      long long v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)" : ", 3);
      uint64_t v16 = *v15;
      *(_DWORD *)((char *)v15 + *(void *)(*v15 - 24) + 8) = *(_DWORD *)((unsigned char *)v15 + *(void *)(*v15 - 24) + 8) & 0xFFFFFEFB | 4;
      *(uint64_t *)((char *)v15 + *(void *)(v16 - 24) + 24) = 7;
      *(uint64_t *)((char *)v15 + *(void *)(v16 - 24) + 16) = 2;
      uint64_t v17 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)" ms\n", 4);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|\n", 2);
      HGStats::CoreStats<HGNode,__HGStats_private::StatsProfile>::printOpStats((uint64_t *)(a1 + 8), a2, (uint64_t)v27, v11 + v12);
      if ((a3 & 0x800) == 0)
      {
LABEL_6:
        if ((a3 & 0x1000) == 0) {
          goto LABEL_7;
        }
        goto LABEL_14;
      }
    }
    else if ((a3 & 0x800) == 0)
    {
      goto LABEL_6;
    }
    HGStats::CoreStats<HGNode,__HGStats_private::StatsProfile>::printNodeStats(a1 + 8, a2, (uint64_t)v27);
    if ((a3 & 0x1000) == 0)
    {
LABEL_7:
      if ((a3 & 0x2000) == 0) {
        goto LABEL_8;
      }
      goto LABEL_24;
    }
LABEL_14:
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"| -- node ROI pixels (defined & used pixels per node):\n", 55);
    uint64_t v18 = *(void **)(a1 + 80);
    v36[0] = a2;
    if (v18 != (void *)(a1 + 88))
    {
      do
      {
        *(void *)&v35[0] = v18[4];
        *(_OWORD *)((char *)v35 + 8) = *(_OWORD *)(v18 + 5);
        __HGStats_private::NodePixelsPrinter<HGNode>::operator()(v36, (uint64_t *)v35);
        unint64_t v19 = (void *)v18[1];
        if (v19)
        {
          do
          {
            long long v20 = v19;
            unint64_t v19 = (void *)*v19;
          }
          while (v19);
        }
        else
        {
          do
          {
            long long v20 = (void *)v18[2];
            BOOL v21 = *v20 == (void)v18;
            uint64_t v18 = v20;
          }
          while (!v21);
        }
        uint64_t v18 = v20;
      }
      while (v20 != (void *)(a1 + 88));
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|\n", 2);
    if ((a3 & 0x2000) == 0)
    {
LABEL_8:
      if ((a3 & 0x400) == 0)
      {
LABEL_10:
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"\\----------------- \n\n", 21);
        return;
      }
LABEL_9:
      HGStats::CoreStats<HGNode,__HGStats_private::StatsProfile>::printCondensed(v9, a2, (uint64_t)v27);
      goto LABEL_10;
    }
LABEL_24:
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"| -- node in-N-out ROI ratios (per input):\n", 43);
    uint64_t v22 = *(void **)(a1 + 56);
    uint64_t v23 = (void *)(a1 + 64);
    v36[0] = a2;
    v36[1] = 0;
    if (v22 != v23)
    {
      do
      {
        long long v24 = *((_OWORD *)v22 + 3);
        v35[0] = *((_OWORD *)v22 + 2);
        v35[1] = v24;
        __HGStats_private::InOutRoiStatsPrinter<HGNode>::operator()(v36, (uint64_t *)v35);
        size_t v25 = (void *)v22[1];
        if (v25)
        {
          do
          {
            long long v26 = v25;
            size_t v25 = (void *)*v25;
          }
          while (v25);
        }
        else
        {
          do
          {
            long long v26 = (void *)v22[2];
            BOOL v21 = *v26 == (void)v22;
            uint64_t v22 = v26;
          }
          while (!v21);
        }
        uint64_t v22 = v26;
      }
      while (v26 != v23);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|\n", 2);
    if ((a3 & 0x400) == 0) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
}

double __HGStats_private::RRStatsProfile::time(__HGStats_private::RRStatsProfile *this)
{
  return *((double *)this + 12);
}

void *HGStats::CoreStats<HGNode,__HGStats_private::StatsProfile>::printOpStats(uint64_t *a1, void *a2, uint64_t a3, double a4)
{
  uint64_t v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|", 1);
  *(void *)((char *)v8 + *(void *)(*v8 - 24) + 24) = 16;
  size_t v9 = strlen(__HGStats_private::opNames[0]);
  uint64_t v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)__HGStats_private::opNames[0], v9);
  double v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)" : ", 3);
  uint64_t v52 = *a1;
  uint64_t v53 = v52;
  double v54 = a4;
  uint64_t v55 = v52;
  uint64_t v56 = v52;
  uint64_t v57 = v52;
  double v12 = __HGStats_private::operator<<(v11, (uint64_t)&v52);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)"\n", 1);
  unint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|", 1);
  *(void *)((char *)v13 + *(void *)(*v13 - 24) + 24) = 16;
  size_t v14 = strlen(off_1E9EDEC50[0]);
  long long v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)off_1E9EDEC50[0], v14);
  uint64_t v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)" : ", 3);
  uint64_t v52 = *a1 + 40;
  uint64_t v53 = v52;
  double v54 = a4;
  uint64_t v55 = v52;
  uint64_t v56 = v52;
  uint64_t v57 = v52;
  uint64_t v17 = __HGStats_private::operator<<(v16, (uint64_t)&v52);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)"\n", 1);
  uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|", 1);
  *(void *)((char *)v18 + *(void *)(*v18 - 24) + 24) = 16;
  size_t v19 = strlen(off_1E9EDEC58[0]);
  long long v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)off_1E9EDEC58[0], v19);
  BOOL v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)" : ", 3);
  uint64_t v52 = *a1 + 80;
  uint64_t v53 = v52;
  double v54 = a4;
  uint64_t v55 = v52;
  uint64_t v56 = v52;
  uint64_t v57 = v52;
  uint64_t v22 = __HGStats_private::operator<<(v21, (uint64_t)&v52);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)"\n", 1);
  uint64_t v23 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|", 1);
  *(void *)((char *)v23 + *(void *)(*v23 - 24) + 24) = 16;
  size_t v24 = strlen(off_1E9EDEC60[0]);
  size_t v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)off_1E9EDEC60[0], v24);
  long long v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)" : ", 3);
  uint64_t v52 = *a1 + 120;
  uint64_t v53 = v52;
  double v54 = a4;
  uint64_t v55 = v52;
  uint64_t v56 = v52;
  uint64_t v57 = v52;
  uint64_t v27 = __HGStats_private::operator<<(v26, (uint64_t)&v52);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)"\n", 1);
  float32x4_t v28 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|", 1);
  *(void *)((char *)v28 + *(void *)(*v28 - 24) + 24) = 16;
  size_t v29 = strlen(off_1E9EDEC68);
  long long v30 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v28, (uint64_t)off_1E9EDEC68, v29);
  long long v31 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v30, (uint64_t)" : ", 3);
  uint64_t v52 = *a1 + 160;
  uint64_t v53 = v52;
  double v54 = a4;
  uint64_t v55 = v52;
  uint64_t v56 = v52;
  uint64_t v57 = v52;
  int v32 = __HGStats_private::operator<<(v31, (uint64_t)&v52);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)"\n", 1);
  long long v33 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|", 1);
  *(void *)((char *)v33 + *(void *)(*v33 - 24) + 24) = 16;
  long long v34 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v33, (uint64_t)"process", 7);
  size_t v35 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v34, (uint64_t)" : ", 3);
  v51[0] = a3 + 88;
  v51[1] = a3 + 88;
  *(double *)&v51[2] = a4;
  v51[3] = a3 + 88;
  v51[4] = a3 + 88;
  v51[5] = a3 + 88;
  float32x4_t v36 = __HGStats_private::operator<<(v35, (uint64_t)v51);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)"\n", 1);
  float32x4_t v37 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|      total time : ", 20);
  uint64_t v38 = *v37;
  *(_DWORD *)((char *)v37 + *(void *)(*v37 - 24) + 8) = *(_DWORD *)((unsigned char *)v37 + *(void *)(*v37 - 24) + 8) & 0xFFFFFEFB | 4;
  *(uint64_t *)((char *)v37 + *(void *)(v38 - 24) + 24) = 7;
  *(uint64_t *)((char *)v37 + *(void *)(v38 - 24) + 16) = 2;
  uint64_t v39 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v39, (uint64_t)" ms\n", 4);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|\n", 2);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"| -- process time breakdown:\n", 29);
  uint64_t v40 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|", 1);
  *(void *)((char *)v40 + *(void *)(*v40 - 24) + 24) = 16;
  uint64_t v41 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v40, (uint64_t)"read", 4);
  uint64_t v42 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v41, (uint64_t)" : ", 3);
  v50[0] = a3 + 48;
  v50[1] = a3 + 48;
  *(double *)&void v50[2] = a4;
  void v50[3] = a3 + 48;
  v50[4] = a3 + 48;
  v50[5] = a3 + 48;
  unsigned int v43 = __HGStats_private::operator<<(v42, (uint64_t)v50);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v43, (uint64_t)"\n", 1);
  float32x4_t v44 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|", 1);
  *(void *)((char *)v44 + *(void *)(*v44 - 24) + 24) = 16;
  float32x4_t v45 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v44, (uint64_t)"render", 6);
  uint64_t v46 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v45, (uint64_t)" : ", 3);
  v49[0] = a3 + 8;
  v49[1] = a3 + 8;
  *(double *)&void v49[2] = a4;
  v49[3] = a3 + 8;
  v49[4] = a3 + 8;
  v49[5] = a3 + 8;
  float32x4_t v47 = __HGStats_private::operator<<(v46, (uint64_t)v49);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v47, (uint64_t)"\n", 1);

  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|\n", 2);
}

void *HGStats::CoreStats<HGNode,__HGStats_private::StatsProfile>::printNodeStats(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"| -- per node process times:\n", 29);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"| read:\n", 8);
  uint64_t v7 = *(void **)(a1 + 24);
  uint64_t v8 = (void *)(a1 + 32);
  uint64_t v22 = a2;
  uint64_t v23 = a3;
  if (v7 != (void *)(a1 + 32))
  {
    do
    {
      uint64_t v18 = (void *)v7[4];
      size_t v19 = &unk_1F10D9BD8;
      long long v9 = *((_OWORD *)v7 + 4);
      long long v20 = *((_OWORD *)v7 + 3);
      long long v21 = v9;
      __HGStats_private::NodeStatsPrinter<HGNode,__HGStats_private::StatsTimer,(__HGStats_private::NodeStatsType)1>::operator()(&v22, &v18);
      uint64_t v10 = (void *)v7[1];
      if (v10)
      {
        do
        {
          double v11 = v10;
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          double v11 = (void *)v7[2];
          BOOL v12 = *v11 == (void)v7;
          uint64_t v7 = v11;
        }
        while (!v12);
      }
      uint64_t v7 = v11;
    }
    while (v11 != v8);
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"| render:\n", 10);
  unint64_t v13 = *(void **)(a1 + 24);
  uint64_t v22 = a2;
  uint64_t v23 = a3;
  if (v13 != v8)
  {
    do
    {
      uint64_t v18 = (void *)v13[4];
      size_t v19 = &unk_1F10D9BD8;
      long long v14 = *((_OWORD *)v13 + 4);
      long long v20 = *((_OWORD *)v13 + 3);
      long long v21 = v14;
      __HGStats_private::NodeStatsPrinter<HGNode,__HGStats_private::StatsTimer,(__HGStats_private::NodeStatsType)0>::operator()(&v22, &v18);
      long long v15 = (void *)v13[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          long long v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)v13[2];
          BOOL v12 = *v16 == (void)v13;
          unint64_t v13 = v16;
        }
        while (!v12);
      }
      unint64_t v13 = v16;
    }
    while (v16 != v8);
  }
  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|\n", 2);
}

void *HGStats::CoreStats<HGNode,__HGStats_private::StatsProfile>::printCondensed(uint64_t a1, void *a2, uint64_t a3)
{
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"| -- per node stats breakdown:\n", 31);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"| read:\n", 8);
  uint64_t v6 = a1 + 72;
  uint64_t v7 = *(void **)(a1 + 24);
  uint64_t v8 = a1 + 48;
  long long v9 = (void *)(a1 + 32);
  size_t v19 = a2;
  uint64_t v20 = a3;
  uint64_t v21 = a1 + 72;
  uint64_t v22 = a1 + 48;
  if (v7 != (void *)(a1 + 32))
  {
    do
    {
      unint64_t v23 = v7[4];
      size_t v24 = &unk_1F10D9BD8;
      long long v10 = *((_OWORD *)v7 + 4);
      long long v25 = *((_OWORD *)v7 + 3);
      long long v26 = v10;
      __HGStats_private::NodeStatsVerbosePrinter<HGNode,__HGStats_private::StatsProfile,(__HGStats_private::NodeStatsType)1>::operator()(&v19, &v23);
      double v11 = (void *)v7[1];
      if (v11)
      {
        do
        {
          BOOL v12 = v11;
          double v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          BOOL v12 = (void *)v7[2];
          BOOL v13 = *v12 == (void)v7;
          uint64_t v7 = v12;
        }
        while (!v13);
      }
      uint64_t v7 = v12;
    }
    while (v12 != v9);
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"| render:\n", 10);
  long long v14 = *(void **)(a1 + 24);
  size_t v19 = a2;
  uint64_t v20 = a3;
  uint64_t v21 = v6;
  uint64_t v22 = v8;
  if (v14 != v9)
  {
    do
    {
      unint64_t v23 = v14[4];
      size_t v24 = &unk_1F10D9BD8;
      long long v15 = *((_OWORD *)v14 + 4);
      long long v25 = *((_OWORD *)v14 + 3);
      long long v26 = v15;
      __HGStats_private::NodeStatsVerbosePrinter<HGNode,__HGStats_private::StatsProfile,(__HGStats_private::NodeStatsType)0>::operator()(&v19, &v23);
      uint64_t v16 = (void *)v14[1];
      if (v16)
      {
        do
        {
          uint64_t v17 = v16;
          uint64_t v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          uint64_t v17 = (void *)v14[2];
          BOOL v13 = *v17 == (void)v14;
          long long v14 = v17;
        }
        while (!v13);
      }
      long long v14 = v17;
    }
    while (v17 != v9);
  }
  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|\n", 2);
}

uint64_t HGStats::CoreStats<HGNode,__HGStats_private::StatsProfile>::probes(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  uint64_t v18 = &unk_1F10D9C60;
  *(void *)size_t v19 = &unk_1F10D9BD8;
  memset(&v19[8], 0, 32);
  uint64_t v20 = &unk_1F10D9BD8;
  long long v21 = 0u;
  long long v22 = 0u;
  unint64_t v23 = &unk_1F10D9BD8;
  long long v24 = 0u;
  long long v25 = 0u;
  std::accumulate[abi:ne180100]<std::__map_iterator<std::__tree_iterator<std::__value_type<HGNode *,__HGStats_private::StatsProfile>,std::__tree_node<std::__value_type<HGNode *,__HGStats_private::StatsProfile>,void *> *,long>>,__HGStats_private::RRStatsProfile,__HGStats_private::ReadRenderAccumulator<HGNode,__HGStats_private::StatsProfile>>(v2, a1 + 4, &v18, (uint64_t)v13);
  __HGStats_private::OpStats<__HGStats_private::StatsTimer>::getTotalStats(a1, (uint64_t)v12);
  uint64_t v3 = (void *)*a1;
  uint64_t v18 = &unk_1F10D9BD8;
  *(_OWORD *)&v19[16] = v15;
  *(_OWORD *)size_t v19 = v14;
  uint64_t v4 = v3[5];
  v3 += 5;
  double v5 = (*(double (**)(void *))(v4 + 24))(v3);
  *(double *)size_t v19 = v5 + *(double *)v19;
  uint64_t v6 = (*(uint64_t (**)(void *))(*v3 + 32))(v3);
  *(void *)&v19[8] += v6;
  uint64_t v7 = (*(uint64_t (**)(void *))(*v3 + 40))(v3);
  *(void *)&v19[16] += v7;
  (*(void (**)(void *))(*v3 + 48))(v3);
  *(_OWORD *)&v19[16] = v17;
  uint64_t v18 = &unk_1F10D9BD8;
  *(_OWORD *)size_t v19 = v16;
  double v8 = (*(double (**)(void *))(v12[0] + 24))(v12);
  *(double *)size_t v19 = v8 + *(double *)v19;
  uint64_t v9 = (*(uint64_t (**)(void *))(v12[0] + 32))(v12);
  *(void *)&v19[8] += v9;
  uint64_t v10 = (*(uint64_t (**)(void *))(v12[0] + 40))(v12);
  *(void *)&v19[16] += v10;
  (*(void (**)(void *))(v12[0] + 48))(v12);
  return 0;
}

void HGStats::RendererStatsImpl::merge(HGStats::RendererStatsImpl *this, HGProfiler **a2)
{
  ++*(void *)this;
  *((double *)this + 1) = HGProfiler::getTime(*a2) + *((double *)this + 1);
  __HGStats_private::OpStats<__HGStats_private::StatsProfile>::merge<__HGStats_private::StatsTimer>((uint64_t *)this + 2, a2 + 1);
  uint64_t v4 = a2[4];
  uint64_t v18 = (char *)this + 40;
  if (v4 != (const HGStats::GraphStatsImpl *)(a2 + 5))
  {
    do
    {
      v17[0].i64[0] = *((void *)v4 + 4);
      v17[0].i64[1] = (uint64_t)&unk_1F10D9BD8;
      int64x2_t v5 = *((int64x2_t *)v4 + 4);
      v17[1] = *((int64x2_t *)v4 + 3);
      void v17[2] = v5;
      __HGStats_private::MergeNodeStats<HGNode,__HGStats_private::StatsProfile,std::type_info const,__HGStats_private::StatsProfile>::operator()(&v18, v17);
      uint64_t v6 = (const HGStats::GraphStatsImpl *)*((void *)v4 + 1);
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          uint64_t v6 = *(const HGStats::GraphStatsImpl **)v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (const HGStats::GraphStatsImpl *)*((void *)v4 + 2);
          BOOL v8 = *(void *)v7 == (void)v4;
          uint64_t v4 = v7;
        }
        while (!v8);
      }
      uint64_t v4 = v7;
    }
    while (v7 != (const HGStats::GraphStatsImpl *)(a2 + 5));
  }
  uint64_t v9 = a2[7];
  uint64_t v18 = (char *)this + 64;
  if (v9 != (const HGStats::GraphStatsImpl *)(a2 + 8))
  {
    do
    {
      int64x2_t v10 = *((int64x2_t *)v9 + 3);
      v17[0] = *((int64x2_t *)v9 + 2);
      v17[1] = v10;
      __HGStats_private::MergeRoiStats<HGNode,std::type_info const>::operator()(&v18, v17);
      double v11 = (const HGStats::GraphStatsImpl *)*((void *)v9 + 1);
      if (v11)
      {
        do
        {
          BOOL v12 = v11;
          double v11 = *(const HGStats::GraphStatsImpl **)v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          BOOL v12 = (const HGStats::GraphStatsImpl *)*((void *)v9 + 2);
          BOOL v8 = *(void *)v12 == (void)v9;
          uint64_t v9 = v12;
        }
        while (!v8);
      }
      uint64_t v9 = v12;
    }
    while (v12 != (const HGStats::GraphStatsImpl *)(a2 + 8));
  }
  BOOL v13 = a2[10];
  long long v14 = (char *)(a2 + 11);
  uint64_t v18 = (char *)this + 88;
  if (v13 != (HGProfiler *)v14)
  {
    do
    {
      v17[0].i64[0] = *((void *)v13 + 4);
      *(int64x2_t *)((char *)v17 + 8) = *(int64x2_t *)((char *)v13 + 40);
      __HGStats_private::MergeNodePixels<HGNode,std::type_info const>::operator()(&v18, (uint64_t)v17);
      long long v15 = (HGProfiler *)*((void *)v13 + 1);
      if (v15)
      {
        do
        {
          long long v16 = v15;
          long long v15 = *(HGProfiler **)v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          long long v16 = (HGProfiler *)*((void *)v13 + 2);
          BOOL v8 = *(void *)v16 == (void)v13;
          BOOL v13 = v16;
        }
        while (!v8);
      }
      BOOL v13 = v16;
    }
    while (v16 != (HGProfiler *)v14);
  }
}

void *HGStats::RendererStatsImpl::dump(void *result, void *a2, int a3)
{
  int64x2_t v5 = result;
  if ((a3 & 0x10000) != 0)
  {
    uint64_t v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"+ Total Renderer Stats (avg time) : ", 36);
    uint64_t v7 = *v6;
    *(_DWORD *)((char *)v6 + *(void *)(*v6 - 24) + 8) = *(_DWORD *)((unsigned char *)v6 + *(void *)(*v6 - 24) + 8) & 0xFFFFFEFB | 4;
    *(uint64_t *)((char *)v6 + *(void *)(v7 - 24) + 24) = 7;
    *(uint64_t *)((char *)v6 + *(void *)(v7 - 24) + 16) = 2;
    BOOL v8 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" ms (", 5);
    uint64_t v9 = (void *)std::ostream::operator<<();
    uint64_t result = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)")\n", 2);
  }
  if ((a3 & 0xFE0000) != 0)
  {
    uint64_t v10 = (uint64_t)(v5 + 2);
    double v11 = (void *)v5[5];
    *(void *)&v31[0] = &unk_1F10D9C60;
    *((void *)&v31[0] + 1) = &unk_1F10D9BD8;
    memset(&v31[1], 0, 32);
    int v32 = &unk_1F10D9BD8;
    long long v33 = 0u;
    long long v34 = 0u;
    size_t v35 = &unk_1F10D9BD8;
    long long v36 = 0u;
    long long v37 = 0u;
    std::accumulate[abi:ne180100]<std::__map_iterator<std::__tree_iterator<std::__value_type<std::type_info const*,__HGStats_private::StatsProfile>,std::__tree_node<std::__value_type<std::type_info const*,__HGStats_private::StatsProfile>,void *> *,long>>,__HGStats_private::RRStatsProfile,__HGStats_private::ReadRenderAccumulator<std::type_info const,__HGStats_private::StatsProfile>>(v11, v5 + 6, v31, (uint64_t)v30);
    __HGStats_private::OpStats<__HGStats_private::StatsTimer>::getTotalStats(v5 + 2, (uint64_t)v31);
    double v12 = *(double *)&v30[12];
    double v13 = *((double *)v31 + 1);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"\n", 1);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"/----- Total Renderer Stats:\n", 29);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|\n", 2);
    if ((a3 & 0x20000) != 0)
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"| # of renders : ", 17);
      long long v14 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"\n", 1);
      uint64_t v15 = *a2;
      *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 8) = *(_DWORD *)((unsigned char *)a2 + *(void *)(*a2 - 24) + 8) & 0xFFFFFEFB | 4;
      *(void *)((char *)a2 + *(void *)(v15 - 24) + 24) = 7;
      *(void *)((char *)a2 + *(void *)(v15 - 24) + 16) = 2;
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|  wall time : ", 15);
      long long v16 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)" ms -> ", 7);
      long long v17 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)" ms/render\n", 11);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"| total time : ", 15);
      uint64_t v18 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" ms -> ", 7);
      size_t v19 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)" ms/render\n", 11);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|\n", 2);
      HGStats::CoreStats<HGNode,__HGStats_private::StatsProfile>::printOpStats(v5 + 2, a2, (uint64_t)v30, v12 + v13);
      if ((a3 & 0x80000) == 0)
      {
LABEL_6:
        if ((a3 & 0x100000) == 0) {
          goto LABEL_7;
        }
        goto LABEL_14;
      }
    }
    else if ((a3 & 0x80000) == 0)
    {
      goto LABEL_6;
    }
    uint64_t v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"| -- per node process times:\n", 29);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)"| read:\n", 8);
    std::for_each[abi:ne180100]<std::__map_iterator<std::__tree_iterator<std::__value_type<std::type_info const*,__HGStats_private::StatsProfile>,std::__tree_node<std::__value_type<std::type_info const*,__HGStats_private::StatsProfile>,void *> *,long>>,__HGStats_private::NodeStatsPrinter<std::type_info const,__HGStats_private::StatsProfile,(__HGStats_private::NodeStatsType)1>>((void *)v5[5], v5 + 6, a2, (uint64_t)v30);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"| render:\n", 10);
    std::for_each[abi:ne180100]<std::__map_iterator<std::__tree_iterator<std::__value_type<std::type_info const*,__HGStats_private::StatsProfile>,std::__tree_node<std::__value_type<std::type_info const*,__HGStats_private::StatsProfile>,void *> *,long>>,__HGStats_private::NodeStatsPrinter<std::type_info const,__HGStats_private::StatsProfile,(__HGStats_private::NodeStatsType)0>>((void *)v5[5], v5 + 6, a2, (uint64_t)v30);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|\n", 2);
    if ((a3 & 0x100000) == 0)
    {
LABEL_7:
      if ((a3 & 0x200000) == 0) {
        goto LABEL_8;
      }
      goto LABEL_24;
    }
LABEL_14:
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"| -- node ROI pixels (defined & used pixels per node):\n", 55);
    long long v21 = (void *)v5[11];
    v39[0] = a2;
    if (v21 != v5 + 12)
    {
      do
      {
        *(void *)&v38[0] = v21[4];
        *(_OWORD *)((char *)v38 + 8) = *(_OWORD *)(v21 + 5);
        __HGStats_private::NodePixelsPrinter<std::type_info const>::operator()(v39, (uint64_t *)v38);
        long long v22 = (void *)v21[1];
        if (v22)
        {
          do
          {
            unint64_t v23 = v22;
            long long v22 = (void *)*v22;
          }
          while (v22);
        }
        else
        {
          do
          {
            unint64_t v23 = (void *)v21[2];
            BOOL v24 = *v23 == (void)v21;
            long long v21 = v23;
          }
          while (!v24);
        }
        long long v21 = v23;
      }
      while (v23 != v5 + 12);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|\n", 2);
    if ((a3 & 0x200000) == 0)
    {
LABEL_8:
      if ((a3 & 0x40000) == 0) {
        return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"\\----------------- \n\n", 21);
      }
LABEL_9:
      HGStats::CoreStats<std::type_info const,__HGStats_private::StatsProfile>::printCondensed(v10, a2, (uint64_t)v30);
      return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"\\----------------- \n\n", 21);
    }
LABEL_24:
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"| -- node in-N-out ROI ratios (per input):\n", 43);
    long long v25 = (void *)v5[8];
    long long v26 = v5 + 9;
    v39[0] = a2;
    v39[1] = 0;
    if (v25 != v26)
    {
      do
      {
        long long v27 = *((_OWORD *)v25 + 3);
        v38[0] = *((_OWORD *)v25 + 2);
        v38[1] = v27;
        __HGStats_private::InOutRoiStatsPrinter<std::type_info const>::operator()(v39, (uint64_t *)v38);
        float32x4_t v28 = (void *)v25[1];
        if (v28)
        {
          do
          {
            size_t v29 = v28;
            float32x4_t v28 = (void *)*v28;
          }
          while (v28);
        }
        else
        {
          do
          {
            size_t v29 = (void *)v25[2];
            BOOL v24 = *v29 == (void)v25;
            long long v25 = v29;
          }
          while (!v24);
        }
        long long v25 = v29;
      }
      while (v29 != v26);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|\n", 2);
    if ((a3 & 0x40000) == 0) {
      return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"\\----------------- \n\n", 21);
    }
    goto LABEL_9;
  }
  return result;
}

void *HGStats::CoreStats<std::type_info const,__HGStats_private::StatsProfile>::printCondensed(uint64_t a1, void *a2, uint64_t a3)
{
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"| -- per node stats breakdown:\n", 31);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"| read:\n", 8);
  uint64_t v6 = a1 + 72;
  uint64_t v7 = *(void **)(a1 + 24);
  uint64_t v8 = a1 + 48;
  uint64_t v9 = (void *)(a1 + 32);
  size_t v19 = a2;
  uint64_t v20 = a3;
  uint64_t v21 = a1 + 72;
  uint64_t v22 = a1 + 48;
  if (v7 != (void *)(a1 + 32))
  {
    do
    {
      unint64_t v23 = v7[4];
      BOOL v24 = &unk_1F10D9BD8;
      long long v10 = *((_OWORD *)v7 + 4);
      long long v25 = *((_OWORD *)v7 + 3);
      long long v26 = v10;
      __HGStats_private::NodeStatsVerbosePrinter<std::type_info const,__HGStats_private::StatsProfile,(__HGStats_private::NodeStatsType)1>::operator()(&v19, &v23);
      double v11 = (void *)v7[1];
      if (v11)
      {
        do
        {
          double v12 = v11;
          double v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          double v12 = (void *)v7[2];
          BOOL v13 = *v12 == (void)v7;
          uint64_t v7 = v12;
        }
        while (!v13);
      }
      uint64_t v7 = v12;
    }
    while (v12 != v9);
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"| render:\n", 10);
  long long v14 = *(void **)(a1 + 24);
  size_t v19 = a2;
  uint64_t v20 = a3;
  uint64_t v21 = v6;
  uint64_t v22 = v8;
  if (v14 != v9)
  {
    do
    {
      unint64_t v23 = v14[4];
      BOOL v24 = &unk_1F10D9BD8;
      long long v15 = *((_OWORD *)v14 + 4);
      long long v25 = *((_OWORD *)v14 + 3);
      long long v26 = v15;
      __HGStats_private::NodeStatsVerbosePrinter<std::type_info const,__HGStats_private::StatsProfile,(__HGStats_private::NodeStatsType)0>::operator()(&v19, &v23);
      long long v16 = (void *)v14[1];
      if (v16)
      {
        do
        {
          long long v17 = v16;
          long long v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          long long v17 = (void *)v14[2];
          BOOL v13 = *v17 == (void)v14;
          long long v14 = v17;
        }
        while (!v13);
      }
      long long v14 = v17;
    }
    while (v17 != v9);
  }
  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|\n", 2);
}

uint64_t HGStats::CoreStats<std::type_info const,__HGStats_private::StatsProfile>::probes(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  uint64_t v18 = &unk_1F10D9C60;
  *(void *)size_t v19 = &unk_1F10D9BD8;
  memset(&v19[8], 0, 32);
  uint64_t v20 = &unk_1F10D9BD8;
  long long v21 = 0u;
  long long v22 = 0u;
  unint64_t v23 = &unk_1F10D9BD8;
  long long v24 = 0u;
  long long v25 = 0u;
  std::accumulate[abi:ne180100]<std::__map_iterator<std::__tree_iterator<std::__value_type<std::type_info const*,__HGStats_private::StatsProfile>,std::__tree_node<std::__value_type<std::type_info const*,__HGStats_private::StatsProfile>,void *> *,long>>,__HGStats_private::RRStatsProfile,__HGStats_private::ReadRenderAccumulator<std::type_info const,__HGStats_private::StatsProfile>>(v2, a1 + 4, &v18, (uint64_t)v13);
  __HGStats_private::OpStats<__HGStats_private::StatsTimer>::getTotalStats(a1, (uint64_t)v12);
  uint64_t v3 = (void *)*a1;
  uint64_t v18 = &unk_1F10D9BD8;
  *(_OWORD *)&v19[16] = v15;
  *(_OWORD *)size_t v19 = v14;
  uint64_t v4 = v3[5];
  v3 += 5;
  double v5 = (*(double (**)(void *))(v4 + 24))(v3);
  *(double *)size_t v19 = v5 + *(double *)v19;
  uint64_t v6 = (*(uint64_t (**)(void *))(*v3 + 32))(v3);
  *(void *)&v19[8] += v6;
  uint64_t v7 = (*(uint64_t (**)(void *))(*v3 + 40))(v3);
  *(void *)&v19[16] += v7;
  (*(void (**)(void *))(*v3 + 48))(v3);
  *(_OWORD *)&v19[16] = v17;
  uint64_t v18 = &unk_1F10D9BD8;
  *(_OWORD *)size_t v19 = v16;
  double v8 = (*(double (**)(void *))(v12[0] + 24))(v12);
  *(double *)size_t v19 = v8 + *(double *)v19;
  uint64_t v9 = (*(uint64_t (**)(void *))(v12[0] + 32))(v12);
  *(void *)&v19[8] += v9;
  uint64_t v10 = (*(uint64_t (**)(void *))(v12[0] + 40))(v12);
  *(void *)&v19[16] += v10;
  (*(void (**)(void *))(v12[0] + 48))(v12);
  return 0;
}

HGStats::ProfilerScopeGuard *HGStats::ProfilerScopeGuard::ProfilerScopeGuard(HGStats::ProfilerScopeGuard *this, HGStats::UnitStatsImpl **a2, HGNode *a3, uint64_t a4)
{
  double v5 = *a2;
  if (*((unsigned char *)*a2 + 120))
  {
    *(void *)this = v5;
    *((void *)this + 1) = HGStats::UnitStatsImpl::getProfiler(v5, a3);
    HGStats::UnitStatsImpl::renderTile(*(HGStats::UnitStatsImpl **)this, a3, a4);
    HGStats::UnitStatsImpl::start(*(HGStats::UnitStatsImpl **)this, *((HGProfiler **)this + 1));
  }
  else
  {
    *(void *)this = 0;
  }
  return this;
}

HGStats::UnitStatsImpl **HGStats::ProfilerScopeGuard::ProfilerScopeGuard(HGStats::UnitStatsImpl **a1, HGStats::UnitStatsImpl **a2, unsigned int a3)
{
  uint64_t v4 = *a2;
  if (*((unsigned char *)*a2 + 120))
  {
    *a1 = v4;
    double v5 = *(HGProfiler **)(*(void *)v4 + 40 * a3 + 8);
    if (!v5) {
      operator new();
    }
    a1[1] = v5;
    HGStats::UnitStatsImpl::start(v4, v5);
    return a1;
  }
  else
  {
    *a1 = 0;
    return a1;
  }
}

void sub_1B77CE4FC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1000C40451B5BE8);
  _Unwind_Resume(a1);
}

HGStats::UnitStatsImpl **HGStats::ProfilerScopeGuard::ProfilerScopeGuard(HGStats::UnitStatsImpl **a1, HGStats::UnitStatsImpl **a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = *a2;
  if (*((unsigned char *)*a2 + 120))
  {
    *a1 = v6;
    uint64_t v7 = *(HGProfiler **)(*(void *)v6 + 40 * a3 + 8);
    if (!v7) {
      operator new();
    }
    a1[1] = v7;
    uint64_t v8 = *(void *)v6 + 40 * a3;
    *(void *)(v8 + 16) += a4;
    int64x2_t v9 = vdupq_n_s64(1uLL);
    v9.i64[0] = a5;
    *(int64x2_t *)(v8 + 24) = vaddq_s64(*(int64x2_t *)(v8 + 24), v9);
    HGStats::UnitStatsImpl::start(v6, v7);
    return a1;
  }
  else
  {
    *a1 = 0;
    return a1;
  }
}

void sub_1B77CE618(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1000C40451B5BE8);
  _Unwind_Resume(a1);
}

void HGStats::ProfilerScopeGuard::~ProfilerScopeGuard(HGStats::ProfilerScopeGuard *this)
{
  uint64_t v1 = *(void *)this;
  if (*(void *)this && *(unsigned char *)(v1 + 120))
  {
    HGProfiler::stop(*(HGProfiler **)(*(void *)(v1 + 104) - 8));
    uint64_t v3 = *(void *)(v1 + 96);
    uint64_t v2 = *(void *)(v1 + 104);
    *(void *)(v1 + 104) = v2 - 8;
    if (v3 != v2 - 8) {
      HGProfiler::start(*(HGProfiler **)(v2 - 16));
    }
  }
}

void HGStats::UnitStats::UnitStats(HGStats::UnitStats *this)
{
}

void sub_1B77CE720(_Unwind_Exception *a1)
{
  if (*v1) {
    HGStats::UnitStats::UnitStats((uint64_t)v1, *v1);
  }
  MEMORY[0x1BA9BFBA0](v1, 0x10A0C40A0517958);
  _Unwind_Resume(a1);
}

void HGStats::UnitStats::~UnitStats(HGStats::UnitStats *this)
{
  uint64_t v1 = *(void *)this;
  if (*(void *)this)
  {
    uint64_t v2 = *(void **)(v1 + 96);
    if (v2)
    {
      *(void *)(v1 + 104) = v2;
      operator delete(v2);
    }
    uint64_t v3 = HGStats::CoreStats<HGNode,__HGStats_private::StatsTimer>::~CoreStats(v1);
    MEMORY[0x1BA9BFBA0](v3, 0x10A0C40A0517958);
  }
}

uint64_t HGStats::UnitStats::enable(uint64_t this, char a2)
{
  *(unsigned char *)(*(void *)this + 12CVOpenGLESTextureCacheFlush(this[3], 0) = a2;
  return this;
}

void HGStats::UnitStats::start(HGStats::UnitStatsImpl **a1, unsigned int a2)
{
  uint64_t v2 = *a1;
  if (!*(void *)(*(void *)v2 + 40 * a2 + 8)) {
    operator new();
  }
  uint64_t v3 = *(HGProfiler **)(*(void *)v2 + 40 * a2 + 8);

  HGStats::UnitStatsImpl::start(v2, v3);
}

void sub_1B77CE85C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1000C40451B5BE8);
  _Unwind_Resume(a1);
}

void *HGStats::UnitStats::stop(void *result, unsigned int a2)
{
  uint64_t v2 = (void *)*result;
  if (!*(void *)(*(void *)*result + 40 * a2 + 8)) {
    operator new();
  }
  if (*((unsigned char *)v2 + 120))
  {
    uint64_t result = (void *)HGProfiler::stop(*(HGProfiler **)(v2[13] - 8));
    uint64_t v4 = v2[12];
    uint64_t v3 = v2[13];
    v2[13] = v3 - 8;
    if (v4 != v3 - 8)
    {
      double v5 = *(HGProfiler **)(v3 - 16);
      return (void *)HGProfiler::start(v5);
    }
  }
  return result;
}

void sub_1B77CE940(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1000C40451B5BE8);
  _Unwind_Resume(a1);
}

uint64_t *HGStats::UnitStats::readTile(uint64_t *this, HGNode *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *this;
  if (*(unsigned char *)(*this + 120))
  {
    int64x2_t v9 = (uint64_t **)(v4 + 32);
    uint64_t v8 = *(unint64_t **)(v4 + 32);
    if (v8)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v10 = v8;
          unint64_t v11 = v8[4];
          if (v11 <= (unint64_t)a2) {
            break;
          }
          uint64_t v8 = (unint64_t *)*v10;
          int64x2_t v9 = (uint64_t **)v10;
          if (!*v10) {
            goto LABEL_9;
          }
        }
        if (v11 >= (unint64_t)a2) {
          break;
        }
        uint64_t v8 = (unint64_t *)v10[1];
        if (!v8)
        {
          int64x2_t v9 = (uint64_t **)(v10 + 1);
          goto LABEL_9;
        }
      }
    }
    else
    {
      uint64_t v10 = (void *)(v4 + 32);
LABEL_9:
      double v12 = v10;
      uint64_t v10 = operator new(0x50uLL);
      v10[4] = a2;
      v10[5] = &unk_1F10D9B90;
      *((_OWORD *)v10 + 3) = 0u;
      *((_OWORD *)v10 + 4) = 0u;
      void *v10 = 0;
      v10[1] = 0;
      v10[2] = v12;
      *int64x2_t v9 = v10;
      uint64_t v13 = **(void **)(v4 + 24);
      long long v14 = v10;
      if (v13)
      {
        *(void *)(v4 + 24) = v13;
        long long v14 = *v9;
      }
      this = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v4 + 32), v14);
      ++*(void *)(v4 + 40);
    }
    v10[8] += a4 - 16 * a3;
  }
  return this;
}

uint64_t *HGStats::UnitStats::in_n_out(uint64_t *this, HGNode *a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *this;
  if (*(unsigned char *)(*this + 120))
  {
    unint64_t v11 = (uint64_t **)(v5 + 56);
    uint64_t v10 = *(HGNode ***)(v5 + 56);
    if (v10)
    {
      while (1)
      {
        while (1)
        {
          double v12 = (char *)v10;
          uint64_t v13 = v10[4];
          unsigned int v14 = *((_DWORD *)v12 + 10);
          BOOL v15 = v14 > a3;
          if (v13 != a2) {
            BOOL v15 = v13 > a2;
          }
          if (!v15) {
            break;
          }
          uint64_t v10 = *(HGNode ***)v12;
          unint64_t v11 = (uint64_t **)v12;
          if (!*(void *)v12) {
            goto LABEL_13;
          }
        }
        BOOL v16 = v14 < a3;
        BOOL v17 = v13 == a2;
        BOOL v18 = v13 < a2;
        if (v17) {
          BOOL v18 = v16;
        }
        if (!v18) {
          break;
        }
        uint64_t v10 = (HGNode **)*((void *)v12 + 1);
        if (!v10)
        {
          unint64_t v11 = (uint64_t **)(v12 + 8);
          goto LABEL_13;
        }
      }
    }
    else
    {
      double v12 = (char *)(v5 + 56);
LABEL_13:
      size_t v19 = v12;
      double v12 = (char *)operator new(0x40uLL);
      *((void *)v12 + 4) = a2;
      *((_DWORD *)v12 + 1CVOpenGLESTextureCacheFlush(this[3], 0) = a3;
      *((void *)v12 + 6) = 0;
      *((void *)v12 + 7) = 0;
      *(void *)double v12 = 0;
      *((void *)v12 + 1) = 0;
      *((void *)v12 + 2) = v19;
      void *v11 = (uint64_t *)v12;
      uint64_t v20 = **(void **)(v5 + 48);
      long long v21 = (uint64_t *)v12;
      if (v20)
      {
        *(void *)(v5 + 48) = v20;
        long long v21 = *v11;
      }
      this = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v5 + 56), v21);
      ++*(void *)(v5 + 64);
    }
    uint64_t v22 = *((void *)v12 + 7) + a5;
    *((void *)v12 + 6) += a4;
    *((void *)v12 + 7) = v22;
  }
  return this;
}

void HGStats::UnitStats::clear(HGStats::UnitStats *this)
{
}

uint64_t *HGStats::UnitStats::dump(uint64_t **a1, void *a2, char a3)
{
  return HGStats::UnitStatsImpl::dump(*a1, a2, a3);
}

void HGStats::GraphStats::GraphStats(HGStats::GraphStats *this)
{
}

void sub_1B77CEBEC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1020C409ABEAE11);
  _Unwind_Resume(a1);
}

void HGStats::GraphStats::~GraphStats(HGStats::GraphStats *this)
{
  uint64_t v1 = *(void *)this;
  if (*(void *)this)
  {
    if (*(void *)v1) {
      MEMORY[0x1BA9BFBA0](*(void *)v1, 0x1000C40451B5BE8);
    }
    std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v1 + 80, *(void **)(v1 + 88));
    *(void *)(v1 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = v1 + 88;
    *(void *)(v1 + 96) = 0;
    *(void *)(v1 + 88) = 0;
    std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v1 + 56, *(void **)(v1 + 64));
    *(void *)(v1 + 56) = v1 + 64;
    *(void *)(v1 + 72) = 0;
    *(void *)(v1 + 64) = 0;
    std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v1 + 32, *(void **)(v1 + 40));
    *(void *)(v1 + 32) = v1 + 40;
    *(void *)(v1 + 48) = 0;
    *(void *)(v1 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
    __HGStats_private::OpStats<__HGStats_private::StatsProfile>::~OpStats((char **)(v1 + 8));
    MEMORY[0x1BA9BFBA0](v1, 0x1020C409ABEAE11);
  }
}

uint64_t HGStats::GraphStats::start(HGProfiler ***this)
{
  return HGProfiler::start(**this);
}

uint64_t HGStats::GraphStats::stop(HGProfiler ***this)
{
  return HGProfiler::stop(**this);
}

uint64_t *HGStats::GraphStats::roiPixels(uint64_t *this, HGNode *a2, uint64_t *a3)
{
  uint64_t v5 = *this;
  uint64_t v7 = (uint64_t **)(*this + 88);
  uint64_t v6 = *v7;
  if (*v7)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v6;
        unint64_t v9 = v6[4];
        if (v9 <= (unint64_t)a2) {
          break;
        }
        uint64_t v6 = *v8;
        uint64_t v7 = v8;
        if (!*v8) {
          goto LABEL_8;
        }
      }
      if (v9 >= (unint64_t)a2) {
        break;
      }
      uint64_t v6 = v8[1];
      if (!v6)
      {
        uint64_t v7 = v8 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
    uint64_t v8 = (uint64_t **)(*this + 88);
LABEL_8:
    uint64_t v10 = (uint64_t *)v8;
    uint64_t v8 = (uint64_t **)operator new(0x38uLL);
    v8[5] = 0;
    v8[6] = 0;
    v8[4] = (uint64_t *)a2;
    *uint64_t v8 = 0;
    v8[1] = 0;
    v8[2] = v10;
    HGProfiler *v7 = (uint64_t *)v8;
    uint64_t v11 = **(void **)(v5 + 80);
    double v12 = (uint64_t *)v8;
    if (v11)
    {
      *(void *)(v5 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = v11;
      double v12 = *v7;
    }
    this = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v5 + 88), v12);
    ++*(void *)(v5 + 96);
  }
  v8[5] = a3;
  v8[6] = (uint64_t *)1;
  return this;
}

void HGStats::GraphStats::merge(HGStats::GraphStatsImpl **this, const HGStats::UnitStatsImpl **a2)
{
}

void HGStats::GraphStats::clear(uint64_t **this)
{
  uint64_t v1 = (uint64_t)(*this + 1);
  HGProfiler::init(**this);

  HGStats::CoreStats<HGNode,__HGStats_private::StatsProfile>::clear(v1);
}

void HGStats::GraphStats::dump(uint64_t *a1, void *a2, __int16 a3)
{
}

uint64_t HGStats::GraphStats::probes(HGStats::GraphStats *this)
{
  return HGStats::CoreStats<HGNode,__HGStats_private::StatsProfile>::probes((void *)(*(void *)this + 8));
}

uint64_t HGStats::GraphStats::getNodeTime(HGStats::GraphStats *this, HGNode *a2)
{
  uint64_t v3 = *(void *)this;
  uint64_t v5 = (uint64_t **)(*(void *)this + 40);
  uint64_t v4 = *v5;
  if (*v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v6 = (uint64_t **)v4;
        unint64_t v7 = v4[4];
        if (v7 <= (unint64_t)a2) {
          break;
        }
        uint64_t v4 = *v6;
        uint64_t v5 = v6;
        if (!*v6) {
          goto LABEL_8;
        }
      }
      if (v7 >= (unint64_t)a2) {
        break;
      }
      uint64_t v4 = v6[1];
      if (!v4)
      {
        uint64_t v5 = v6 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
    uint64_t v6 = (uint64_t **)(*(void *)this + 40);
LABEL_8:
    uint64_t v8 = (uint64_t *)v6;
    uint64_t v6 = (uint64_t **)operator new(0x50uLL);
    v6[4] = (uint64_t *)a2;
    v6[5] = (uint64_t *)&unk_1F10D9BD8;
    *((_OWORD *)v6 + 3) = 0u;
    *((_OWORD *)v6 + 4) = 0u;
    *uint64_t v6 = 0;
    v6[1] = 0;
    void v6[2] = v8;
    *uint64_t v5 = (uint64_t *)v6;
    uint64_t v9 = **(void **)(v3 + 32);
    uint64_t v10 = (uint64_t *)v6;
    if (v9)
    {
      *(void *)(v3 + 32) = v9;
      uint64_t v10 = *v5;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v3 + 40), v10);
    ++*(void *)(v3 + 48);
  }
  uint64_t v11 = (uint64_t (*)(uint64_t **))v6[5][3];

  return v11(v6 + 5);
}

double HGStats::GraphStats::time(HGProfiler ***this)
{
  return HGProfiler::getTime(**this);
}

void HGStats::RendererStats::RendererStats(HGStats::RendererStats *this)
{
}

void sub_1B77CEFD8(_Unwind_Exception *a1)
{
  if (*v2) {
    HGStats::RendererStats::RendererStats(v1, *v2);
  }
  MEMORY[0x1BA9BFBA0](v1, 0x1020C405955F7A7);
  _Unwind_Resume(a1);
}

void HGStats::RendererStats::~RendererStats(HGStats::RendererStats *this)
{
  uint64_t v1 = *(void *)this;
  if (*(void *)this)
  {
    std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v1 + 88, *(void **)(v1 + 96));
    *(void *)(v1 + 88) = v1 + 96;
    *(void *)(v1 + 104) = 0;
    *(void *)(v1 + 96) = 0;
    std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v1 + 64, *(void **)(v1 + 72));
    *(void *)(v1 + 64) = v1 + 72;
    *(void *)(v1 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
    *(void *)(v1 + 72) = 0;
    std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v1 + 40, *(void **)(v1 + 48));
    *(void *)(v1 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = v1 + 48;
    *(void *)(v1 + 56) = 0;
    *(void *)(v1 + 48) = 0;
    __HGStats_private::OpStats<__HGStats_private::StatsProfile>::~OpStats((char **)(v1 + 16));
    MEMORY[0x1BA9BFBA0](v1, 0x1020C405955F7A7);
  }
}

void HGStats::RendererStats::merge(HGStats::RendererStatsImpl **this, HGProfiler ***a2)
{
}

void *HGStats::RendererStats::dump(void **a1, void *a2, int a3)
{
  return HGStats::RendererStatsImpl::dump(*a1, a2, a3);
}

uint64_t HGStats::RendererStats::probes(HGStats::RendererStats *this)
{
  return HGStats::CoreStats<std::type_info const,__HGStats_private::StatsProfile>::probes((void *)(*(void *)this + 16));
}

double HGStats::RendererStats::time(HGStats::RendererStats *this)
{
  return *(double *)(*(void *)this + 8);
}

uint64_t HGStats::RendererStats::count(HGStats::RendererStats *this)
{
  return **(void **)this;
}

uint64_t __HGStats_private::StatsProfile::pixels(__HGStats_private::StatsProfile *this)
{
  return *((void *)this + 2);
}

uint64_t __HGStats_private::StatsProfile::bytes(__HGStats_private::StatsProfile *this)
{
  return *((void *)this + 3);
}

uint64_t __HGStats_private::StatsProfile::tiles(__HGStats_private::StatsProfile *this)
{
  return *((void *)this + 4);
}

uint64_t __HGStats_private::StatsTimer::pixels(__HGStats_private::StatsTimer *this)
{
  return *((void *)this + 2);
}

uint64_t __HGStats_private::StatsTimer::bytes(__HGStats_private::StatsTimer *this)
{
  return *((void *)this + 3);
}

uint64_t __HGStats_private::StatsTimer::tiles(__HGStats_private::StatsTimer *this)
{
  return *((void *)this + 4);
}

void std::vector<__HGStats_private::StatsTimer>::__append(void **a1, unint64_t a2)
{
  uint64_t v4 = (char *)a1[1];
  uint64_t v5 = a1[2];
  if (0xCCCCCCCCCCCCCCCDLL * ((v5 - v4) >> 3) < a2)
  {
    unint64_t v6 = 0xCCCCCCCCCCCCCCCDLL * ((v4 - (unsigned char *)*a1) >> 3);
    unint64_t v7 = v6 + a2;
    if (v6 + a2 > 0x666666666666666) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - (unsigned char *)*a1) >> 3);
    if (2 * v8 > v7) {
      unint64_t v7 = 2 * v8;
    }
    if (v8 >= 0x333333333333333) {
      unint64_t v9 = 0x666666666666666;
    }
    else {
      unint64_t v9 = v7;
    }
    if (v9)
    {
      if (v9 > 0x666666666666666) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v10 = (char *)operator new(40 * v9);
    }
    else
    {
      uint64_t v10 = 0;
    }
    uint64_t v13 = &v10[40 * v6];
    unsigned int v14 = &v10[40 * v9];
    BOOL v15 = &v13[40 * a2];
    BOOL v16 = v13;
    BOOL v17 = v13;
    do
    {
      *(void *)BOOL v17 = &unk_1F10D9B90;
      *(_OWORD *)(v17 + 8) = 0uLL;
      *(_OWORD *)(v17 + 24) = 0uLL;
      v16 += 40;
      v17 += 40;
    }
    while (v17 != v15);
    BOOL v18 = (char *)*a1;
    size_t v19 = (char *)a1[1];
    if (v19 == *a1)
    {
      *a1 = v13;
      a1[1] = v15;
      a1[2] = v14;
    }
    else
    {
      uint64_t v20 = (uint64_t)&v10[40 * v6 - 40];
      do
      {
        *((void *)v13 - 5) = &unk_1F10D9B90;
        v13 -= 40;
        long long v21 = *((_OWORD *)v19 - 2);
        *(_OWORD *)(v13 + 24) = *((_OWORD *)v19 - 1);
        *(_OWORD *)(v13 + 8) = v21;
        v20 -= 40;
        v19 -= 40;
      }
      while (v19 != v18);
      size_t v19 = (char *)*a1;
      uint64_t v22 = (char *)a1[1];
      *a1 = v13;
      a1[1] = v15;
      a1[2] = v14;
      if (v22 == v19)
      {
        size_t v19 = v22;
        if (!v22) {
          return;
        }
        goto LABEL_29;
      }
      unint64_t v23 = v22 - 40;
      long long v24 = v22 - 40;
      long long v25 = (void (***)(char *))(v22 - 40);
      do
      {
        long long v26 = *v25;
        v25 -= 5;
        (*v26)(v24);
        v23 -= 40;
        BOOL v27 = v24 == v19;
        long long v24 = (char *)v25;
      }
      while (!v27);
    }
    if (!v19) {
      return;
    }
LABEL_29:
    operator delete(v19);
    return;
  }
  if (a2)
  {
    uint64_t v11 = &v4[40 * a2];
    double v12 = (char *)a1[1];
    do
    {
      *(void *)uint64_t v4 = &unk_1F10D9B90;
      *(_OWORD *)(v4 + 8) = 0uLL;
      *(_OWORD *)(v4 + 24) = 0uLL;
      v12 += 40;
      v4 += 40;
    }
    while (v4 != v11);
    uint64_t v4 = v11;
  }
  a1[1] = v4;
}

char **__HGStats_private::OpStats<__HGStats_private::StatsTimer>::~OpStats(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  if (*a1 == v3)
  {
    uint64_t v5 = *a1;
  }
  else
  {
    uint64_t v4 = *a1;
    do
    {
      (*(void (**)(char *))(*(void *)v2 + 16))(v2);
      v2 += 40;
      v4 += 40;
    }
    while (v2 != v3);
    uint64_t v2 = *a1;
    uint64_t v5 = a1[1];
    if (v5 == *a1)
    {
      uint64_t v2 = a1[1];
    }
    else
    {
      unint64_t v6 = v5 - 40;
      unint64_t v7 = v5 - 40;
      unint64_t v8 = (void (***)(char *))(v5 - 40);
      do
      {
        unint64_t v9 = *v8;
        v8 -= 5;
        (*v9)(v7);
        v6 -= 40;
        BOOL v10 = v7 == v2;
        unint64_t v7 = (char *)v8;
      }
      while (!v10);
      uint64_t v5 = *a1;
    }
  }
  a1[1] = v2;
  unint64_t v11 = 0xCCCCCCCCCCCCCCCDLL * ((v2 - v5) >> 3);
  if (v11 > 4)
  {
    if (v2 - v5 != 200)
    {
      double v12 = v5 + 200;
      if (v2 != v5 + 200)
      {
        uint64_t v13 = v2 - 40;
        unsigned int v14 = v13;
        BOOL v15 = v13;
        do
        {
          BOOL v16 = *(void (***)(char *))v15;
          v15 -= 40;
          (*v16)(v14);
          v13 -= 40;
          BOOL v10 = v14 == v12;
          unsigned int v14 = v15;
        }
        while (!v10);
      }
      a1[1] = v12;
    }
  }
  else
  {
    std::vector<__HGStats_private::StatsTimer>::__append((void **)a1, 5 - v11);
  }
  BOOL v17 = *a1;
  if (*a1)
  {
    BOOL v18 = a1[1];
    size_t v19 = *a1;
    if (v18 != v17)
    {
      uint64_t v20 = v18 - 40;
      long long v21 = v18 - 40;
      uint64_t v22 = v18 - 40;
      do
      {
        unint64_t v23 = *(void (***)(char *))v22;
        v22 -= 40;
        (*v23)(v21);
        v20 -= 40;
        BOOL v10 = v21 == v17;
        long long v21 = v22;
      }
      while (!v10);
      size_t v19 = *a1;
    }
    a1[1] = v17;
    operator delete(v19);
  }
  return a1;
}

char **HGStats::CoreStats<HGNode,__HGStats_private::StatsTimer>::~CoreStats(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 80);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(a1 + 72, *(void **)(a1 + 80));
  *(void *)(a1 + 72) = v2;
  *(void *)(a1 + 88) = 0;
  *uint64_t v2 = 0;
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(a1 + 48, *(void **)(a1 + 56));
  *(void *)(a1 + 48) = a1 + 56;
  *(void *)(a1 + 56) = 0;
  uint64_t v3 = *(void **)(a1 + 24);
  *(void *)(a1 + 64) = 0;
  uint64_t v4 = (void *)(a1 + 32);
  if (v3 != (void *)(a1 + 32))
  {
    do
    {
      uint64_t v6 = v3[6];
      if (v6) {
        MEMORY[0x1BA9BFBA0](v6, 0x1000C40451B5BE8);
      }
      v3[6] = 0;
      unint64_t v7 = (void *)v3[1];
      if (v7)
      {
        do
        {
          unint64_t v8 = v7;
          unint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          unint64_t v8 = (void *)v3[2];
          BOOL v9 = *v8 == (void)v3;
          uint64_t v3 = v8;
        }
        while (!v9);
      }
      uint64_t v3 = v8;
    }
    while (v8 != v4);
  }
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(a1 + 24, *(void **)(a1 + 32));
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *(void *)(a1 + 24) = v4;

  return __HGStats_private::OpStats<__HGStats_private::StatsTimer>::~OpStats((char **)a1);
}

__n128 std::accumulate[abi:ne180100]<std::__map_iterator<std::__tree_iterator<std::__value_type<HGNode *,__HGStats_private::StatsTimer>,std::__tree_node<std::__value_type<HGNode *,__HGStats_private::StatsTimer>,void *> *,long>>,__HGStats_private::StatsProfile,__HGStats_private::TotalAccumulator<HGNode,__HGStats_private::StatsTimer>>@<Q0>(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  if (a1 != a2)
  {
    unint64_t v7 = a1;
    unint64_t v8 = (long long *)(a3 + 8);
    do
    {
      long long v24 = &unk_1F10D9BD8;
      long long v9 = *(_OWORD *)(a3 + 24);
      long long v25 = *v8;
      long long v26 = v9;
      long long v21 = (uint64_t (**)(void **))&unk_1F10D9B90;
      long long v10 = *((_OWORD *)v7 + 4);
      long long v22 = *((_OWORD *)v7 + 3);
      long long v23 = v10;
      if ((void)v22)
      {
        double Time = HGProfiler::getTime((HGProfiler *)v22);
        double v12 = v21;
      }
      else
      {
        double Time = 0.0;
        double v12 = (uint64_t (**)(void **))&unk_1F10D9B90;
      }
      *(double *)&long long v25 = Time + *(double *)&v25;
      uint64_t v13 = v12[4]((void **)&v21);
      *((void *)&v25 + 1) += v13;
      uint64_t v14 = v21[5]((void **)&v21);
      *(void *)&long long v26 = v26 + v14;
      uint64_t v15 = v21[6]((void **)&v21);
      *((void *)&v26 + 1) += v15;
      long long v16 = v26;
      *unint64_t v8 = v25;
      *(_OWORD *)(a3 + 24) = v16;
      BOOL v17 = (void *)v7[1];
      if (v17)
      {
        do
        {
          BOOL v18 = v17;
          BOOL v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          BOOL v18 = (void *)v7[2];
          BOOL v19 = *v18 == (void)v7;
          unint64_t v7 = v18;
        }
        while (!v19);
      }
      unint64_t v7 = v18;
    }
    while (v18 != a2);
  }
  *(void *)a4 = &unk_1F10D9BD8;
  *(_OWORD *)(a4 + 8) = *(_OWORD *)(a3 + 8);
  __n128 result = *(__n128 *)(a3 + 24);
  *(__n128 *)(a4 + 24) = result;
  return result;
}

void *__HGStats_private::NodeStatsPrinter<HGNode,__HGStats_private::StatsTimer,(__HGStats_private::NodeStatsType)1>::operator()(void *result, void **a2)
{
  uint64_t v2 = *a2;
  if (!*a2) {
    __cxa_bad_typeid();
  }
  uint64_t v4 = result;
  uint64_t v5 = *(char **)(*(void *)(*v2 - 8) + 8);
  if (v5 == off_1F10DC630
    || (((unint64_t)off_1F10DC630 & (unint64_t)v5 & 0x8000000000000000) != 0) != __OFSUB__(v5, off_1F10DC630)&& (__n128 result = (void *)strcmp((const char *)((unint64_t)v5 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)off_1F10DC630 & 0x7FFFFFFFFFFFFFFFLL)), !result)|| v5 == off_1F10D0DF0|| (((unint64_t)off_1F10D0DF0 & (unint64_t)v5 & 0x8000000000000000) != 0) != __OFSUB__(v5, off_1F10D0DF0)&& (__n128 result = (void *)strcmp((const char *)((unint64_t)v5 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)off_1F10D0DF0 & 0x7FFFFFFFFFFFFFFFLL)), !result))
  {
    uint64_t v6 = (void *)*v4;
    uint64_t v7 = v4[1];
    return __HGStats_private::printNodeStats<HGNode,__HGStats_private::StatsTimer const>(v6, (uint64_t)v2, (uint64_t)(a2 + 1), v7);
  }
  return result;
}

void *__HGStats_private::printNodeStats<HGNode,__HGStats_private::StatsTimer const>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 result = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a3 + 32))(a3);
  if (result)
  {
    long long v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"|    ", 5);
    long long v10 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)": ", 2);
    (*(void (**)(uint64_t))(*(void *)a4 + 24))(a4);
    (*(void (**)(uint64_t))(*(void *)a3 + 24))(a3);
    uint64_t v11 = *v9;
    *(_DWORD *)((char *)v9 + *(void *)(*v9 - 24) + 8) = *(_DWORD *)((unsigned char *)v9 + *(void *)(*v9 - 24) + 8) & 0xFFFFFEFB | 4;
    *(uint64_t *)((char *)v9 + *(void *)(v11 - 24) + 24) = 7;
    *(uint64_t *)((char *)v9 + *(void *)(v11 - 24) + 16) = 2;
    double v12 = (void *)std::ostream::operator<<();
    uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" ms (", 5);
    uint64_t v14 = *v13;
    *(_DWORD *)((char *)v13 + *(void *)(*v13 - 24) + 8) = *(_DWORD *)((unsigned char *)v13 + *(void *)(*v13 - 24) + 8) & 0xFFFFFEFB | 4;
    *(uint64_t *)((char *)v13 + *(void *)(v14 - 24) + 24) = 4;
    *(uint64_t *)((char *)v13 + *(void *)(v14 - 24) + 16) = 1;
    uint64_t v15 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)"%)", 2);
    long long v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)", ", 2);
    (*(void (**)(uint64_t))(*(void *)a4 + 32))(a4);
    (*(void (**)(uint64_t))(*(void *)a3 + 32))(a3);
    *(void *)((char *)v16 + *(void *)(*v16 - 24) + 24) = 10;
    BOOL v17 = (void *)std::ostream::operator<<();
    BOOL v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)" pixels (", 9);
    uint64_t v19 = *v18;
    *(_DWORD *)((char *)v18 + *(void *)(*v18 - 24) + 8) = *(_DWORD *)((unsigned char *)v18 + *(void *)(*v18 - 24) + 8) & 0xFFFFFEFB | 4;
    *(uint64_t *)((char *)v18 + *(void *)(v19 - 24) + 24) = 4;
    *(uint64_t *)((char *)v18 + *(void *)(v19 - 24) + 16) = 1;
    uint64_t v20 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)"%)", 2);
    long long v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)", ", 2);
    (*(void (**)(uint64_t))(*(void *)a3 + 24))(a3);
    (*(void (**)(uint64_t))(*(void *)a3 + 32))(a3);
    uint64_t v22 = *v21;
    *(_DWORD *)((char *)v21 + *(void *)(*v21 - 24) + 8) = *(_DWORD *)((unsigned char *)v21 + *(void *)(*v21 - 24) + 8) & 0xFFFFFEFB | 4;
    *(uint64_t *)((char *)v21 + *(void *)(v22 - 24) + 24) = 7;
    *(uint64_t *)((char *)v21 + *(void *)(v22 - 24) + 16) = 2;
    long long v23 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)" ms / MP", 8);
    long long v24 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)" (", 2);
    *(void *)((char *)v24 + *(void *)(*v24 - 24) + 24) = 4;
    (*(void (**)(uint64_t))(*(void *)a3 + 48))(a3);
    long long v25 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)" tiles", 6);
    long long v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)")", 1);
    BOOL v27 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)" (", 2);
    float32x4_t v28 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 48))(a2);
    size_t v29 = strlen(v28);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)v28, v29);
    return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)")\n", 2);
  }
  return result;
}

void *__HGStats_private::NodeStatsPrinter<HGNode,__HGStats_private::StatsTimer,(__HGStats_private::NodeStatsType)0>::operator()(void *result, void **a2)
{
  uint64_t v2 = *a2;
  if (!*a2) {
    __cxa_bad_typeid();
  }
  uint64_t v3 = *(char **)(*(void *)(*v2 - 8) + 8);
  if (v3 != off_1F10DC630)
  {
    uint64_t v5 = result;
    if ((((unint64_t)off_1F10DC630 & (unint64_t)v3 & 0x8000000000000000) != 0) == __OFSUB__(v3, off_1F10DC630)
      || (__n128 result = (void *)strcmp((const char *)((unint64_t)v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)off_1F10DC630 & 0x7FFFFFFFFFFFFFFFLL)), result))
    {
      if (v3 != off_1F10D0DF0)
      {
        if ((((unint64_t)off_1F10D0DF0 & (unint64_t)v3 & 0x8000000000000000) != 0) == __OFSUB__(v3, off_1F10D0DF0)
          || (__n128 result = (void *)strcmp((const char *)((unint64_t)v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)off_1F10D0DF0 & 0x7FFFFFFFFFFFFFFFLL)), result))
        {
          uint64_t v6 = (void *)*v5;
          uint64_t v7 = v5[1];
          return __HGStats_private::printNodeStats<HGNode,__HGStats_private::StatsTimer const>(v6, (uint64_t)v2, (uint64_t)(a2 + 1), v7);
        }
      }
    }
  }
  return result;
}

void *__HGStats_private::InOutRoiStatsPrinter<HGNode>::operator()(void *result, uint64_t *a2)
{
  uint64_t v2 = result[1];
  uint64_t v3 = *a2;
  if (v2) {
    BOOL v4 = v2 == v3;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    uint64_t v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((void *)*result, (uint64_t)"|    ", 5);
    uint64_t v6 = v5;
    if (v2)
    {
      uint64_t v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"         ", 9);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)"in #", 4);
      unint64_t v8 = (void *)std::ostream::operator<<();
      long long v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" ROI ratio : ", 13);
      uint64_t v10 = *v9;
      *(_DWORD *)((char *)v9 + *(void *)(*v9 - 24) + 8) = *(_DWORD *)((unsigned char *)v9 + *(void *)(*v9 - 24) + 8) & 0xFFFFFEFB | 4;
      *(uint64_t *)((char *)v9 + *(void *)(v10 - 24) + 24) = 4;
      *(uint64_t *)((char *)v9 + *(void *)(v10 - 24) + 16) = 2;
      std::ostream::operator<<();
      uint64_t v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)" ", 1);
      double v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)"(", 1);
      *(void *)((char *)v12 + *(void *)(*v12 - 24) + 24) = 10;
      uint64_t v13 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)")", 1);
      uint64_t v14 = "\n";
      uint64_t v15 = v11;
      uint64_t v16 = 1;
    }
    else
    {
      BOOL v17 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)": ", 2);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"in #", 4);
      BOOL v18 = (void *)std::ostream::operator<<();
      uint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" :  ", 4);
      uint64_t v20 = *v19;
      *(_DWORD *)((char *)v19 + *(void *)(*v19 - 24) + 8) = *(_DWORD *)((unsigned char *)v19 + *(void *)(*v19 - 24) + 8) & 0xFFFFFEFB | 4;
      *(uint64_t *)((char *)v19 + *(void *)(v20 - 24) + 24) = 4;
      *(uint64_t *)((char *)v19 + *(void *)(v20 - 24) + 16) = 2;
      std::ostream::operator<<();
      long long v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"  ", 2);
      uint64_t v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)"(input: ", 8);
      *(void *)((char *)v22 + *(void *)(*v22 - 24) + 24) = 10;
      long long v23 = (void *)std::ostream::operator<<();
      long long v24 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)", ouput: ", 9);
      *(void *)((char *)v24 + *(void *)(*v24 - 24) + 24) = 10;
      long long v25 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)")", 1);
      long long v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)"  (", 3);
      BOOL v27 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)v3 + 48))(v3);
      size_t v28 = strlen(v27);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)v27, v28);
      uint64_t v14 = ")\n";
      uint64_t v15 = v26;
      uint64_t v16 = 2;
    }
    return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)v14, v16);
  }
  return result;
}

void std::vector<__HGStats_private::StatsProfile>::__append(void **a1, unint64_t a2)
{
  BOOL v4 = (char *)a1[1];
  uint64_t v5 = a1[2];
  if (0xCCCCCCCCCCCCCCCDLL * ((v5 - v4) >> 3) < a2)
  {
    unint64_t v6 = 0xCCCCCCCCCCCCCCCDLL * ((v4 - (unsigned char *)*a1) >> 3);
    unint64_t v7 = v6 + a2;
    if (v6 + a2 > 0x666666666666666) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - (unsigned char *)*a1) >> 3);
    if (2 * v8 > v7) {
      unint64_t v7 = 2 * v8;
    }
    if (v8 >= 0x333333333333333) {
      unint64_t v9 = 0x666666666666666;
    }
    else {
      unint64_t v9 = v7;
    }
    if (v9)
    {
      if (v9 > 0x666666666666666) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v10 = (char *)operator new(40 * v9);
    }
    else
    {
      uint64_t v10 = 0;
    }
    uint64_t v13 = &v10[40 * v6];
    uint64_t v14 = &v10[40 * v9];
    uint64_t v15 = &v13[40 * a2];
    uint64_t v16 = v13;
    BOOL v17 = v13;
    do
    {
      *(void *)BOOL v17 = &unk_1F10D9BD8;
      *(_OWORD *)(v17 + 8) = 0uLL;
      *(_OWORD *)(v17 + 24) = 0uLL;
      v16 += 40;
      v17 += 40;
    }
    while (v17 != v15);
    BOOL v18 = (char *)*a1;
    uint64_t v19 = (char *)a1[1];
    if (v19 == *a1)
    {
      *a1 = v13;
      a1[1] = v15;
      a1[2] = v14;
    }
    else
    {
      uint64_t v20 = (uint64_t)&v10[40 * v6 - 40];
      do
      {
        *((void *)v13 - 5) = &unk_1F10D9BD8;
        v13 -= 40;
        long long v21 = *((_OWORD *)v19 - 2);
        *(_OWORD *)(v13 + 24) = *((_OWORD *)v19 - 1);
        *(_OWORD *)(v13 + 8) = v21;
        v20 -= 40;
        v19 -= 40;
      }
      while (v19 != v18);
      uint64_t v19 = (char *)*a1;
      uint64_t v22 = (char *)a1[1];
      *a1 = v13;
      a1[1] = v15;
      a1[2] = v14;
      if (v22 == v19)
      {
        uint64_t v19 = v22;
        if (!v22) {
          return;
        }
        goto LABEL_29;
      }
      long long v23 = v22 - 40;
      long long v24 = v22 - 40;
      long long v25 = (void (***)(char *))(v22 - 40);
      do
      {
        long long v26 = *v25;
        v25 -= 5;
        (*v26)(v24);
        v23 -= 40;
        BOOL v27 = v24 == v19;
        long long v24 = (char *)v25;
      }
      while (!v27);
    }
    if (!v19) {
      return;
    }
LABEL_29:
    operator delete(v19);
    return;
  }
  if (a2)
  {
    uint64_t v11 = &v4[40 * a2];
    double v12 = (char *)a1[1];
    do
    {
      *(void *)BOOL v4 = &unk_1F10D9BD8;
      *(_OWORD *)(v4 + 8) = 0uLL;
      *(_OWORD *)(v4 + 24) = 0uLL;
      v12 += 40;
      v4 += 40;
    }
    while (v4 != v11);
    BOOL v4 = v11;
  }
  a1[1] = v4;
}

char **__HGStats_private::OpStats<__HGStats_private::StatsProfile>::~OpStats(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  if (*a1 == v3)
  {
    uint64_t v5 = *a1;
  }
  else
  {
    BOOL v4 = *a1;
    do
    {
      (*(void (**)(char *))(*(void *)v2 + 16))(v2);
      v2 += 40;
      v4 += 40;
    }
    while (v2 != v3);
    uint64_t v2 = *a1;
    uint64_t v5 = a1[1];
    if (v5 == *a1)
    {
      uint64_t v2 = a1[1];
    }
    else
    {
      unint64_t v6 = v5 - 40;
      unint64_t v7 = v5 - 40;
      unint64_t v8 = (void (***)(char *))(v5 - 40);
      do
      {
        unint64_t v9 = *v8;
        v8 -= 5;
        (*v9)(v7);
        v6 -= 40;
        BOOL v10 = v7 == v2;
        unint64_t v7 = (char *)v8;
      }
      while (!v10);
      uint64_t v5 = *a1;
    }
  }
  a1[1] = v2;
  unint64_t v11 = 0xCCCCCCCCCCCCCCCDLL * ((v2 - v5) >> 3);
  if (v11 > 4)
  {
    if (v2 - v5 != 200)
    {
      double v12 = v5 + 200;
      if (v2 != v5 + 200)
      {
        uint64_t v13 = v2 - 40;
        uint64_t v14 = v13;
        uint64_t v15 = v13;
        do
        {
          uint64_t v16 = *(void (***)(char *))v15;
          v15 -= 40;
          (*v16)(v14);
          v13 -= 40;
          BOOL v10 = v14 == v12;
          uint64_t v14 = v15;
        }
        while (!v10);
      }
      a1[1] = v12;
    }
  }
  else
  {
    std::vector<__HGStats_private::StatsProfile>::__append((void **)a1, 5 - v11);
  }
  BOOL v17 = *a1;
  if (*a1)
  {
    BOOL v18 = a1[1];
    uint64_t v19 = *a1;
    if (v18 != v17)
    {
      uint64_t v20 = v18 - 40;
      long long v21 = v18 - 40;
      uint64_t v22 = v18 - 40;
      do
      {
        long long v23 = *(void (***)(char *))v22;
        v22 -= 40;
        (*v23)(v21);
        v20 -= 40;
        BOOL v10 = v21 == v17;
        long long v21 = v22;
      }
      while (!v10);
      uint64_t v19 = *a1;
    }
    a1[1] = v17;
    operator delete(v19);
  }
  return a1;
}

uint64_t __HGStats_private::MergeNodeStats<HGNode,__HGStats_private::StatsTimer,HGNode,__HGStats_private::StatsProfile>::operator()(void *a1, void *a2)
{
  uint64_t v3 = (uint64_t **)*a1;
  BOOL v4 = (uint64_t *)*a2;
  unint64_t v6 = (uint64_t **)(*a1 + 8);
  uint64_t v5 = *v6;
  if (*v6)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if ((unint64_t)v4 >= v8) {
          break;
        }
        uint64_t v5 = *v7;
        unint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_8;
        }
      }
      if (v8 >= (unint64_t)v4) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        unint64_t v6 = v7 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
    unint64_t v7 = (uint64_t **)(*a1 + 8);
LABEL_8:
    unint64_t v9 = (uint64_t *)v7;
    unint64_t v7 = (uint64_t **)operator new(0x50uLL);
    _DWORD v7[4] = v4;
    v7[5] = (uint64_t *)&unk_1F10D9BD8;
    *((_OWORD *)v7 + 3) = 0u;
    *((_OWORD *)v7 + 4) = 0u;
    char *v7 = 0;
    v7[1] = 0;
    void v7[2] = v9;
    *unint64_t v6 = (uint64_t *)v7;
    BOOL v10 = (uint64_t *)**v3;
    unint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      char *v3 = v10;
      unint64_t v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v3[1], v11);
    v3[2] = (uint64_t *)((char *)v3[2] + 1);
  }
  uint64_t v13 = a2[1];
  double v12 = a2 + 1;
  *((double *)v7 + 6) = (*(double (**)(void *))(v13 + 24))(v12) + *((double *)v7 + 6);
  v7[7] = (uint64_t *)((char *)v7[7] + (*(uint64_t (**)(void *))(*v12 + 32))(v12));
  v7[8] = (uint64_t *)((char *)v7[8] + (*(uint64_t (**)(void *))(*v12 + 40))(v12));
  uint64_t result = (*(uint64_t (**)(void *))(*v12 + 48))(v12);
  v7[9] = (uint64_t *)((char *)v7[9] + result);
  return result;
}

int64x2_t __HGStats_private::MergeRoiStats<HGNode,HGNode>::operator()(void *a1, int64x2_t *a2)
{
  uint64_t v3 = (uint64_t **)*a1;
  unint64_t v4 = a2->i64[0];
  uint64_t v5 = a2->u32[2];
  unint64_t v7 = (uint64_t **)(*a1 + 8);
  unint64_t v6 = (int64x2_t *)*v7;
  if (*v7)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v8 = v6;
        unint64_t v9 = v6[2].u64[0];
        unsigned int v10 = v8[2].u32[2];
        BOOL v11 = v10 > v5;
        if (v9 != v4) {
          BOOL v11 = v9 > v4;
        }
        if (!v11) {
          break;
        }
        unint64_t v6 = (int64x2_t *)v8->i64[0];
        unint64_t v7 = (uint64_t **)v8;
        if (!v8->i64[0]) {
          goto LABEL_12;
        }
      }
      BOOL v12 = v10 < v5;
      BOOL v13 = v9 == v4;
      BOOL v14 = v9 < v4;
      if (v13) {
        BOOL v14 = v12;
      }
      if (!v14) {
        break;
      }
      unint64_t v6 = (int64x2_t *)v8->i64[1];
      if (!v6)
      {
        unint64_t v7 = (uint64_t **)&v8->i64[1];
        goto LABEL_12;
      }
    }
  }
  else
  {
    unint64_t v8 = (int64x2_t *)(*a1 + 8);
LABEL_12:
    uint64_t v15 = v8;
    unint64_t v8 = (int64x2_t *)operator new(0x40uLL);
    v8[2].i64[0] = v4;
    v8[2].i64[1] = v5;
    v8[3].i64[0] = 0;
    v8[3].i64[1] = 0;
    v8->i64[0] = 0;
    v8->i64[1] = 0;
    v8[1].i64[0] = (uint64_t)v15;
    char *v7 = (uint64_t *)v8;
    uint64_t v16 = (uint64_t *)**v3;
    BOOL v17 = (uint64_t *)v8;
    if (v16)
    {
      char *v3 = v16;
      BOOL v17 = *v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v3[1], v17);
    v3[2] = (uint64_t *)((char *)v3[2] + 1);
  }
  int64x2_t result = vaddq_s64(v8[3], a2[1]);
  v8[3] = result;
  return result;
}

__n128 std::accumulate[abi:ne180100]<std::__map_iterator<std::__tree_iterator<std::__value_type<HGNode *,__HGStats_private::StatsProfile>,std::__tree_node<std::__value_type<HGNode *,__HGStats_private::StatsProfile>,void *> *,long>>,__HGStats_private::RRStatsProfile,__HGStats_private::ReadRenderAccumulator<HGNode,__HGStats_private::StatsProfile>>@<Q0>(void *a1@<X0>, void *a2@<X1>, _OWORD *a3@<X2>, uint64_t a4@<X8>)
{
  if (a1 != a2)
  {
    unint64_t v4 = a1;
    uint64_t v5 = a3 + 1;
    unint64_t v6 = (_OWORD *)((char *)a3 + 56);
    unint64_t v7 = a3 + 6;
    do
    {
      v27[0] = &unk_1F10D9C60;
      v27[1] = &unk_1F10D9BD8;
      long long v8 = v5[1];
      long long v28 = *v5;
      long long v29 = v8;
      long long v9 = v6[1];
      long long v31 = *v6;
      long long v32 = v9;
      long long v30 = &unk_1F10D9BD8;
      long long v33 = &unk_1F10D9BD8;
      long long v10 = v7[1];
      long long v34 = *v7;
      long long v35 = v10;
      v24[0] = v4[4];
      v24[1] = &unk_1F10D9BD8;
      long long v11 = *((_OWORD *)v4 + 4);
      long long v25 = *((_OWORD *)v4 + 3);
      long long v26 = v11;
      __HGStats_private::ReadRenderAccumulator<HGNode,__HGStats_private::StatsProfile>::operator()((uint64_t)v27, v24, (uint64_t)v36);
      long long v12 = v38;
      *uint64_t v5 = v37;
      v5[1] = v12;
      long long v13 = v40;
      *unint64_t v6 = v39;
      v6[1] = v13;
      long long v14 = v42;
      long long *v7 = v41;
      v7[1] = v14;
      uint64_t v15 = (void *)v4[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)v4[2];
          BOOL v17 = *v16 == (void)v4;
          unint64_t v4 = v16;
        }
        while (!v17);
      }
      unint64_t v4 = v16;
    }
    while (v16 != a2);
  }
  *(void *)a4 = &unk_1F10D9C60;
  *(void *)(a4 + 8) = &unk_1F10D9BD8;
  long long v18 = a3[2];
  *(_OWORD *)(a4 + 16) = a3[1];
  *(_OWORD *)(a4 + 32) = v18;
  *(void *)(a4 + 48) = &unk_1F10D9BD8;
  *(_OWORD *)(a4 + 56) = *(_OWORD *)((char *)a3 + 56);
  *(_OWORD *)(a4 + 72) = *(_OWORD *)((char *)a3 + 72);
  *(void *)(a4 + 88) = &unk_1F10D9BD8;
  __n128 result = *((__n128 *)a3 + 6);
  long long v20 = a3[7];
  *(__n128 *)(a4 + 96) = result;
  *(_OWORD *)(a4 + 112) = v20;
  return result;
}

__n128 __HGStats_private::ReadRenderAccumulator<HGNode,__HGStats_private::StatsProfile>::operator()@<Q0>(uint64_t a1@<X1>, void *a2@<X2>, uint64_t a3@<X8>)
{
  if (!*a2) {
    __cxa_bad_typeid();
  }
  unint64_t v6 = *(char **)(*(void *)(*(void *)*a2 - 8) + 8);
  if (v6 == off_1F10DC630
    || (((unint64_t)off_1F10DC630 & (unint64_t)v6 & 0x8000000000000000) != 0) != __OFSUB__(v6, off_1F10DC630)&& !strcmp((const char *)((unint64_t)v6 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)off_1F10DC630 & 0x7FFFFFFFFFFFFFFFLL))|| v6 == off_1F10D0DF0|| (((unint64_t)off_1F10D0DF0 & (unint64_t)v6 & 0x8000000000000000) != 0) != __OFSUB__(v6, off_1F10D0DF0)&& !strcmp((const char *)((unint64_t)v6 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)off_1F10D0DF0 & 0x7FFFFFFFFFFFFFFFLL)))
  {
    *(double *)(a1 + 56) = (*(double (**)(void *))(a2[1] + 24))(a2 + 1) + *(double *)(a1 + 56);
    *(void *)(a1 + 64) += (*(uint64_t (**)(void *))(a2[1] + 32))(a2 + 1);
    *(void *)(a1 + 72) += (*(uint64_t (**)(void *))(a2[1] + 40))(a2 + 1);
    uint64_t v7 = (*(uint64_t (**)(void *))(a2[1] + 48))(a2 + 1);
    long long v8 = (void *)(a1 + 80);
  }
  else
  {
    *(double *)(a1 + 16) = (*(double (**)(void *))(a2[1] + 24))(a2 + 1) + *(double *)(a1 + 16);
    *(void *)(a1 + 24) += (*(uint64_t (**)(void *))(a2[1] + 32))(a2 + 1);
    *(void *)(a1 + 32) += (*(uint64_t (**)(void *))(a2[1] + 40))(a2 + 1);
    uint64_t v7 = (*(uint64_t (**)(void *))(a2[1] + 48))(a2 + 1);
    long long v8 = (void *)(a1 + 40);
  }
  *v8 += v7;
  uint64_t v10 = a2[1];
  long long v9 = a2 + 1;
  *(double *)(a1 + 96) = (*(double (**)(void *))(v10 + 24))(v9) + *(double *)(a1 + 96);
  *(void *)(a1 + 104) += (*(uint64_t (**)(void *))(*v9 + 32))(v9);
  *(void *)(a1 + 112) += (*(uint64_t (**)(void *))(*v9 + 40))(v9);
  *(void *)(a1 + 120) += (*(uint64_t (**)(void *))(*v9 + 48))(v9);
  *(void *)a3 = &unk_1F10D9C60;
  *(void *)(a3 + 8) = &unk_1F10D9BD8;
  long long v11 = *(_OWORD *)(a1 + 32);
  *(_OWORD *)(a3 + 16) = *(_OWORD *)(a1 + 16);
  *(_OWORD *)(a3 + 32) = v11;
  *(void *)(a3 + 48) = &unk_1F10D9BD8;
  *(_OWORD *)(a3 + 56) = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(a3 + 72) = *(_OWORD *)(a1 + 72);
  *(void *)(a3 + 88) = &unk_1F10D9BD8;
  __n128 result = *(__n128 *)(a1 + 96);
  long long v13 = *(_OWORD *)(a1 + 112);
  *(__n128 *)(a3 + 96) = result;
  *(_OWORD *)(a3 + 112) = v13;
  return result;
}

void __HGStats_private::RRStatsProfile::~RRStatsProfile(__HGStats_private::RRStatsProfile *this)
{
}

uint64_t __HGStats_private::RRStatsProfile::pixels(__HGStats_private::RRStatsProfile *this)
{
  return *((void *)this + 13);
}

uint64_t __HGStats_private::RRStatsProfile::bytes(__HGStats_private::RRStatsProfile *this)
{
  return *((void *)this + 14);
}

uint64_t __HGStats_private::RRStatsProfile::tiles(__HGStats_private::RRStatsProfile *this)
{
  return *((void *)this + 15);
}

void *__HGStats_private::NodePixelsPrinter<HGNode>::operator()(void **a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(*a1, (uint64_t)"|    ", 5);
  unint64_t v4 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)": ", 2);
  uint64_t v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"ROI: ", 5);
  *(void *)((char *)v5 + *(void *)(*v5 - 24) + 24) = 10;
  unint64_t v6 = (void *)std::ostream::operator<<();
  uint64_t v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)" pixels", 7);
  long long v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)", ", 2);
  *(void *)((char *)v8 + *(void *)(*v8 - 24) + 24) = 4;
  long long v9 = (void *)std::ostream::operator<<();
  uint64_t v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)" nodes", 6);
  long long v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)" (", 2);
  long long v12 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 48))(v2);
  size_t v13 = strlen(v12);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)v12, v13);

  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)")\n", 2);
}

void *__HGStats_private::NodeStatsVerbosePrinter<HGNode,__HGStats_private::StatsProfile,(__HGStats_private::NodeStatsType)1>::operator()(void *result, unint64_t *a2)
{
  uint64_t v2 = (void *)*a2;
  if (!*a2) {
    __cxa_bad_typeid();
  }
  unint64_t v4 = result;
  uint64_t v5 = *(char **)(*(void *)(*v2 - 8) + 8);
  if (v5 == off_1F10DC630
    || (((unint64_t)off_1F10DC630 & (unint64_t)v5 & 0x8000000000000000) != 0) != __OFSUB__(v5, off_1F10DC630)&& (__n128 result = (void *)strcmp((const char *)((unint64_t)v5 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)off_1F10DC630 & 0x7FFFFFFFFFFFFFFFLL)), !result)|| v5 == off_1F10D0DF0|| (((unint64_t)off_1F10D0DF0 & (unint64_t)v5 & 0x8000000000000000) != 0) != __OFSUB__(v5, off_1F10D0DF0)&& (__n128 result = (void *)strcmp((const char *)((unint64_t)v5 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)off_1F10D0DF0 & 0x7FFFFFFFFFFFFFFFLL)), !result))
  {
    if (a2[3])
    {
      __HGStats_private::printNodeStats<HGNode,__HGStats_private::StatsTimer const>((void *)*v4, (uint64_t)v2, (uint64_t)(a2 + 1), v4[1]);
      __n128 result = __HGStats_private::NodePixels<HGNode>::outputComputeRatio((uint64_t **)v4[2], (void *)*v4, *a2);
      unint64_t v6 = (void *)v4[3];
      uint64_t v7 = (void *)*v4;
      unint64_t v8 = *a2;
      long long v11 = (void *)*v6;
      uint64_t v10 = v6 + 1;
      long long v9 = v11;
      v17[0] = v7;
      v17[1] = v8;
      if (v11 != v10)
      {
        do
        {
          long long v12 = *((_OWORD *)v9 + 3);
          v16[0] = *((_OWORD *)v9 + 2);
          v16[1] = v12;
          __n128 result = __HGStats_private::InOutRoiStatsPrinter<HGNode>::operator()(v17, (uint64_t *)v16);
          size_t v13 = (void *)v9[1];
          if (v13)
          {
            do
            {
              long long v14 = v13;
              size_t v13 = (void *)*v13;
            }
            while (v13);
          }
          else
          {
            do
            {
              long long v14 = (void *)v9[2];
              BOOL v15 = *v14 == (void)v9;
              long long v9 = v14;
            }
            while (!v15);
          }
          long long v9 = v14;
        }
        while (v14 != v10);
      }
    }
  }
  return result;
}

void *__HGStats_private::NodePixels<HGNode>::outputComputeRatio(uint64_t **a1, void *a2, unint64_t a3)
{
  uint64_t v7 = a1 + 1;
  unint64_t v6 = a1[1];
  if (v6)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v8 = (uint64_t **)v6;
        unint64_t v9 = v6[4];
        if (v9 <= a3) {
          break;
        }
        unint64_t v6 = *v8;
        uint64_t v7 = v8;
        if (!*v8) {
          goto LABEL_8;
        }
      }
      if (v9 >= a3) {
        break;
      }
      unint64_t v6 = v8[1];
      if (!v6)
      {
        uint64_t v7 = v8 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
    unint64_t v8 = a1 + 1;
LABEL_8:
    uint64_t v10 = v8;
    long long v11 = (uint64_t *)operator new(0x38uLL);
    v11[5] = 0;
    v11[6] = 0;
    v11[4] = a3;
    uint64_t *v11 = 0;
    v11[1] = 0;
    v11[2] = (uint64_t)v10;
    void *v7 = v11;
    long long v12 = (uint64_t *)**a1;
    size_t v13 = v11;
    if (v12)
    {
      *a1 = v12;
      size_t v13 = *v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  long long v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"|               out ROI ratio : ", 32);
  uint64_t v15 = *v14;
  *(_DWORD *)((char *)v14 + *(void *)(*v14 - 24) + 8) = *(_DWORD *)((unsigned char *)v14 + *(void *)(*v14 - 24) + 8) & 0xFFFFFEFB | 4;
  *(uint64_t *)((char *)v14 + *(void *)(v15 - 24) + 24) = 4;
  *(uint64_t *)((char *)v14 + *(void *)(v15 - 24) + 16) = 2;
  uint64_t v16 = (void *)std::ostream::operator<<();
  BOOL v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)" (", 2);
  *(void *)((char *)v17 + *(void *)(*v17 - 24) + 24) = 10;
  long long v18 = (void *)std::ostream::operator<<();
  uint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)")", 1);
  long long v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)" (", 2);
  *(void *)((char *)v20 + *(void *)(*v20 - 24) + 24) = 4;
  long long v21 = (void *)std::ostream::operator<<();

  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)" nodes)\n", 8);
}

void *__HGStats_private::NodeStatsVerbosePrinter<HGNode,__HGStats_private::StatsProfile,(__HGStats_private::NodeStatsType)0>::operator()(void *result, unint64_t *a2)
{
  uint64_t v2 = (void *)*a2;
  if (!*a2) {
    __cxa_bad_typeid();
  }
  uint64_t v3 = *(char **)(*(void *)(*v2 - 8) + 8);
  if (v3 != off_1F10DC630)
  {
    uint64_t v5 = result;
    if ((((unint64_t)off_1F10DC630 & (unint64_t)v3 & 0x8000000000000000) != 0) == __OFSUB__(v3, off_1F10DC630)
      || (__n128 result = (void *)strcmp((const char *)((unint64_t)v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)off_1F10DC630 & 0x7FFFFFFFFFFFFFFFLL)), result))
    {
      if (v3 != off_1F10D0DF0)
      {
        if ((((unint64_t)off_1F10D0DF0 & (unint64_t)v3 & 0x8000000000000000) != 0) == __OFSUB__(v3, off_1F10D0DF0)
          || (__n128 result = (void *)strcmp((const char *)((unint64_t)v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)off_1F10D0DF0 & 0x7FFFFFFFFFFFFFFFLL)), result))
        {
          if (a2[3])
          {
            __HGStats_private::printNodeStats<HGNode,__HGStats_private::StatsTimer const>((void *)*v5, (uint64_t)v2, (uint64_t)(a2 + 1), v5[1]);
            __n128 result = __HGStats_private::NodePixels<HGNode>::outputComputeRatio((uint64_t **)v5[2], (void *)*v5, *a2);
            unint64_t v6 = (void *)v5[3];
            uint64_t v7 = (void *)*v5;
            unint64_t v8 = *a2;
            long long v11 = (void *)*v6;
            uint64_t v10 = v6 + 1;
            unint64_t v9 = v11;
            v17[0] = v7;
            v17[1] = v8;
            if (v11 != v10)
            {
              do
              {
                long long v12 = *((_OWORD *)v9 + 3);
                v16[0] = *((_OWORD *)v9 + 2);
                v16[1] = v12;
                __n128 result = __HGStats_private::InOutRoiStatsPrinter<HGNode>::operator()(v17, (uint64_t *)v16);
                size_t v13 = (void *)v9[1];
                if (v13)
                {
                  do
                  {
                    long long v14 = v13;
                    size_t v13 = (void *)*v13;
                  }
                  while (v13);
                }
                else
                {
                  do
                  {
                    long long v14 = (void *)v9[2];
                    BOOL v15 = *v14 == (void)v9;
                    unint64_t v9 = v14;
                  }
                  while (!v15);
                }
                unint64_t v9 = v14;
              }
              while (v14 != v10);
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t __HGStats_private::MergeNodeStats<HGNode,__HGStats_private::StatsProfile,std::type_info const,__HGStats_private::StatsProfile>::operator()(void *a1, void *a2)
{
  if (!*a2) {
    __cxa_bad_typeid();
  }
  uint64_t v3 = (uint64_t **)*a1;
  unint64_t v4 = *(uint64_t **)(*(void *)*a2 - 8);
  unint64_t v6 = (uint64_t **)(*a1 + 8);
  uint64_t v5 = *v6;
  if (*v6)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if ((unint64_t)v4 >= v8) {
          break;
        }
        uint64_t v5 = *v7;
        unint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= (unint64_t)v4) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        unint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = (uint64_t **)(*a1 + 8);
LABEL_9:
    unint64_t v9 = (uint64_t *)v7;
    uint64_t v7 = (uint64_t **)operator new(0x50uLL);
    _DWORD v7[4] = v4;
    v7[5] = (uint64_t *)&unk_1F10D9BD8;
    *((_OWORD *)v7 + 3) = 0u;
    *((_OWORD *)v7 + 4) = 0u;
    void *v7 = 0;
    v7[1] = 0;
    void v7[2] = v9;
    *unint64_t v6 = (uint64_t *)v7;
    uint64_t v10 = (uint64_t *)**v3;
    long long v11 = (uint64_t *)v7;
    if (v10)
    {
      char *v3 = v10;
      long long v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v3[1], v11);
    v3[2] = (uint64_t *)((char *)v3[2] + 1);
  }
  uint64_t v13 = a2[1];
  long long v12 = a2 + 1;
  *((double *)v7 + 6) = (*(double (**)(void *))(v13 + 24))(v12) + *((double *)v7 + 6);
  v7[7] = (uint64_t *)((char *)v7[7] + (*(uint64_t (**)(void *))(*v12 + 32))(v12));
  v7[8] = (uint64_t *)((char *)v7[8] + (*(uint64_t (**)(void *))(*v12 + 40))(v12));
  uint64_t result = (*(uint64_t (**)(void *))(*v12 + 48))(v12);
  v7[9] = (uint64_t *)((char *)v7[9] + result);
  return result;
}

int64x2_t __HGStats_private::MergeRoiStats<HGNode,std::type_info const>::operator()(void *a1, int64x2_t *a2)
{
  if (!a2->i64[0]) {
    __cxa_bad_typeid();
  }
  uint64_t v3 = (uint64_t **)*a1;
  uint64_t v4 = a2->u32[2];
  unint64_t v5 = *(void *)(*(void *)a2->i64[0] - 8);
  uint64_t v7 = (uint64_t **)(*a1 + 8);
  unint64_t v6 = (int64x2_t *)*v7;
  if (*v7)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v8 = v6;
        unint64_t v9 = v6[2].u64[0];
        unsigned int v10 = v8[2].u32[2];
        BOOL v11 = v10 > v4;
        if (v5 != v9) {
          BOOL v11 = v5 < v9;
        }
        if (!v11) {
          break;
        }
        unint64_t v6 = (int64x2_t *)v8->i64[0];
        uint64_t v7 = (uint64_t **)v8;
        if (!v8->i64[0]) {
          goto LABEL_14;
        }
      }
      BOOL v12 = v10 < v4;
      int v13 = v5 == v9 ? v12 : v9 < v5;
      if (v13 != 1) {
        break;
      }
      unint64_t v6 = (int64x2_t *)v8->i64[1];
      if (!v6)
      {
        uint64_t v7 = (uint64_t **)&v8->i64[1];
        goto LABEL_14;
      }
    }
  }
  else
  {
    unint64_t v8 = (int64x2_t *)(*a1 + 8);
LABEL_14:
    long long v14 = v8;
    unint64_t v8 = (int64x2_t *)operator new(0x40uLL);
    v8[2].i64[0] = v5;
    v8[2].i64[1] = v4;
    v8[3].i64[0] = 0;
    v8[3].i64[1] = 0;
    v8->i64[0] = 0;
    v8->i64[1] = 0;
    v8[1].i64[0] = (uint64_t)v14;
    void *v7 = (uint64_t *)v8;
    BOOL v15 = (uint64_t *)**v3;
    uint64_t v16 = (uint64_t *)v8;
    if (v15)
    {
      char *v3 = v15;
      uint64_t v16 = *v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v3[1], v16);
    v3[2] = (uint64_t *)((char *)v3[2] + 1);
  }
  int64x2_t result = vaddq_s64(v8[3], a2[1]);
  v8[3] = result;
  return result;
}

int64x2_t __HGStats_private::MergeNodePixels<HGNode,std::type_info const>::operator()(void *a1, uint64_t a2)
{
  if (!*(void *)a2) {
    __cxa_bad_typeid();
  }
  uint64_t v3 = (uint64_t **)*a1;
  unint64_t v4 = *(void *)(**(void **)a2 - 8);
  unint64_t v6 = (uint64_t **)(*a1 + 8);
  unint64_t v5 = *v6;
  if (*v6)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (char *)v5;
        unint64_t v8 = v5[4];
        if (v4 >= v8) {
          break;
        }
        unint64_t v5 = *(uint64_t **)v7;
        unint64_t v6 = (uint64_t **)v7;
        if (!*(void *)v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= v4) {
        break;
      }
      unint64_t v5 = (uint64_t *)*((void *)v7 + 1);
      if (!v5)
      {
        unint64_t v6 = (uint64_t **)(v7 + 8);
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = (char *)(*a1 + 8);
LABEL_9:
    unint64_t v9 = v7;
    uint64_t v7 = (char *)operator new(0x38uLL);
    *((void *)v7 + 5) = 0;
    *((void *)v7 + 6) = 0;
    *((void *)v7 + 4) = v4;
    *(void *)uint64_t v7 = 0;
    *((void *)v7 + 1) = 0;
    *((void *)v7 + 2) = v9;
    *unint64_t v6 = (uint64_t *)v7;
    unsigned int v10 = (uint64_t *)**v3;
    BOOL v11 = (uint64_t *)v7;
    if (v10)
    {
      char *v3 = v10;
      BOOL v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v3[1], v11);
    v3[2] = (uint64_t *)((char *)v3[2] + 1);
  }
  int64x2_t result = vaddq_s64(*(int64x2_t *)(v7 + 40), *(int64x2_t *)(a2 + 8));
  *(int64x2_t *)(v7 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = result;
  return result;
}

__n128 std::accumulate[abi:ne180100]<std::__map_iterator<std::__tree_iterator<std::__value_type<std::type_info const*,__HGStats_private::StatsProfile>,std::__tree_node<std::__value_type<std::type_info const*,__HGStats_private::StatsProfile>,void *> *,long>>,__HGStats_private::RRStatsProfile,__HGStats_private::ReadRenderAccumulator<std::type_info const,__HGStats_private::StatsProfile>>@<Q0>(void *a1@<X0>, void *a2@<X1>, _OWORD *a3@<X2>, uint64_t a4@<X8>)
{
  if (a1 != a2)
  {
    unint64_t v4 = a1;
    unint64_t v5 = a3 + 1;
    unint64_t v6 = (_OWORD *)((char *)a3 + 56);
    uint64_t v7 = a3 + 6;
    do
    {
      v27[0] = &unk_1F10D9C60;
      v27[1] = &unk_1F10D9BD8;
      long long v8 = v5[1];
      long long v28 = *v5;
      long long v29 = v8;
      long long v9 = v6[1];
      long long v31 = *v6;
      long long v32 = v9;
      long long v30 = &unk_1F10D9BD8;
      long long v33 = &unk_1F10D9BD8;
      long long v10 = v7[1];
      long long v34 = *v7;
      long long v35 = v10;
      v24[0] = v4[4];
      v24[1] = &unk_1F10D9BD8;
      long long v11 = *((_OWORD *)v4 + 4);
      long long v25 = *((_OWORD *)v4 + 3);
      long long v26 = v11;
      __HGStats_private::ReadRenderAccumulator<std::type_info const,__HGStats_private::StatsProfile>::operator()((uint64_t)v27, v24, (uint64_t)v36);
      long long v12 = v38;
      *unint64_t v5 = v37;
      v5[1] = v12;
      long long v13 = v40;
      *unint64_t v6 = v39;
      v6[1] = v13;
      long long v14 = v42;
      long long *v7 = v41;
      v7[1] = v14;
      BOOL v15 = (void *)v4[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          BOOL v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)v4[2];
          BOOL v17 = *v16 == (void)v4;
          unint64_t v4 = v16;
        }
        while (!v17);
      }
      unint64_t v4 = v16;
    }
    while (v16 != a2);
  }
  *(void *)a4 = &unk_1F10D9C60;
  *(void *)(a4 + 8) = &unk_1F10D9BD8;
  long long v18 = a3[2];
  *(_OWORD *)(a4 + 16) = a3[1];
  *(_OWORD *)(a4 + 32) = v18;
  *(void *)(a4 + 48) = &unk_1F10D9BD8;
  *(_OWORD *)(a4 + 56) = *(_OWORD *)((char *)a3 + 56);
  *(_OWORD *)(a4 + 72) = *(_OWORD *)((char *)a3 + 72);
  *(void *)(a4 + 88) = &unk_1F10D9BD8;
  __n128 result = *((__n128 *)a3 + 6);
  long long v20 = a3[7];
  *(__n128 *)(a4 + 96) = result;
  *(_OWORD *)(a4 + 112) = v20;
  return result;
}

__n128 __HGStats_private::ReadRenderAccumulator<std::type_info const,__HGStats_private::StatsProfile>::operator()@<Q0>(uint64_t a1@<X1>, void *a2@<X2>, uint64_t a3@<X8>)
{
  unint64_t v6 = *(char **)(*a2 + 8);
  if (off_1F10DC630 == v6
    || (((unint64_t)off_1F10DC630 & (unint64_t)v6 & 0x8000000000000000) != 0) != __OFSUB__(off_1F10DC630, v6)&& !strcmp((const char *)((unint64_t)v6 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)off_1F10DC630 & 0x7FFFFFFFFFFFFFFFLL))|| off_1F10D0DF0 == v6|| (((unint64_t)off_1F10D0DF0 & (unint64_t)v6 & 0x8000000000000000) != 0) != __OFSUB__(off_1F10D0DF0, v6)&& !strcmp((const char *)((unint64_t)v6 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)off_1F10D0DF0 & 0x7FFFFFFFFFFFFFFFLL)))
  {
    *(double *)(a1 + 56) = (*(double (**)(void *))(a2[1] + 24))(a2 + 1) + *(double *)(a1 + 56);
    *(void *)(a1 + 64) += (*(uint64_t (**)(void *))(a2[1] + 32))(a2 + 1);
    *(void *)(a1 + 72) += (*(uint64_t (**)(void *))(a2[1] + 40))(a2 + 1);
    uint64_t v7 = (*(uint64_t (**)(void *))(a2[1] + 48))(a2 + 1);
    long long v8 = (void *)(a1 + 80);
  }
  else
  {
    *(double *)(a1 + 16) = (*(double (**)(void *))(a2[1] + 24))(a2 + 1) + *(double *)(a1 + 16);
    *(void *)(a1 + 24) += (*(uint64_t (**)(void *))(a2[1] + 32))(a2 + 1);
    *(void *)(a1 + 32) += (*(uint64_t (**)(void *))(a2[1] + 40))(a2 + 1);
    uint64_t v7 = (*(uint64_t (**)(void *))(a2[1] + 48))(a2 + 1);
    long long v8 = (void *)(a1 + 40);
  }
  *v8 += v7;
  uint64_t v10 = a2[1];
  long long v9 = a2 + 1;
  *(double *)(a1 + 96) = (*(double (**)(void *))(v10 + 24))(v9) + *(double *)(a1 + 96);
  *(void *)(a1 + 104) += (*(uint64_t (**)(void *))(*v9 + 32))(v9);
  *(void *)(a1 + 112) += (*(uint64_t (**)(void *))(*v9 + 40))(v9);
  *(void *)(a1 + 120) += (*(uint64_t (**)(void *))(*v9 + 48))(v9);
  *(void *)a3 = &unk_1F10D9C60;
  *(void *)(a3 + 8) = &unk_1F10D9BD8;
  long long v11 = *(_OWORD *)(a1 + 32);
  *(_OWORD *)(a3 + 16) = *(_OWORD *)(a1 + 16);
  *(_OWORD *)(a3 + 32) = v11;
  *(void *)(a3 + 48) = &unk_1F10D9BD8;
  *(_OWORD *)(a3 + 56) = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(a3 + 72) = *(_OWORD *)(a1 + 72);
  *(void *)(a3 + 88) = &unk_1F10D9BD8;
  __n128 result = *(__n128 *)(a1 + 96);
  long long v13 = *(_OWORD *)(a1 + 112);
  *(__n128 *)(a3 + 96) = result;
  *(_OWORD *)(a3 + 112) = v13;
  return result;
}

void *std::for_each[abi:ne180100]<std::__map_iterator<std::__tree_iterator<std::__value_type<std::type_info const*,__HGStats_private::StatsProfile>,std::__tree_node<std::__value_type<std::type_info const*,__HGStats_private::StatsProfile>,void *> *,long>>,__HGStats_private::NodeStatsPrinter<std::type_info const,__HGStats_private::StatsProfile,(__HGStats_private::NodeStatsType)1>>(void *a1, void *a2, void *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    uint64_t v7 = a1;
    long long v8 = off_1F10DC630;
    __s2 = (char *)((unint64_t)off_1F10DC630 & 0x7FFFFFFFFFFFFFFFLL);
    do
    {
      uint64_t v9 = v7[4];
      BOOL v17 = &unk_1F10D9BD8;
      long long v10 = *((_OWORD *)v7 + 4);
      long long v18 = *((_OWORD *)v7 + 3);
      long long v19 = v10;
      long long v11 = *(char **)(v9 + 8);
      if (v8 == v11
        || (((unint64_t)v8 & (unint64_t)v11 & 0x8000000000000000) != 0) != __OFSUB__(v8, v11)
        && !strcmp((const char *)((unint64_t)v11 & 0x7FFFFFFFFFFFFFFFLL), __s2)
        || off_1F10D0DF0 == v11
        || (((unint64_t)off_1F10D0DF0 & (unint64_t)v11 & 0x8000000000000000) != 0) != __OFSUB__(off_1F10D0DF0, v11)
        && !strcmp((const char *)((unint64_t)v11 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)off_1F10D0DF0 & 0x7FFFFFFFFFFFFFFFLL)))
      {
        __HGStats_private::printNodeStats<std::type_info,__HGStats_private::StatsProfile const>(a3, v9, (uint64_t)&v17, a4);
      }
      long long v12 = (void *)v7[1];
      if (v12)
      {
        do
        {
          long long v13 = v12;
          long long v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          long long v13 = (void *)v7[2];
          BOOL v14 = *v13 == (void)v7;
          uint64_t v7 = v13;
        }
        while (!v14);
      }
      uint64_t v7 = v13;
    }
    while (v13 != a2);
  }
  return a3;
}

void *__HGStats_private::printNodeStats<std::type_info,__HGStats_private::StatsProfile const>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 result = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a3 + 32))(a3);
  if (result)
  {
    uint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"|    ", 5);
    (*(void (**)(uint64_t))(*(void *)a4 + 24))(a4);
    (*(void (**)(uint64_t))(*(void *)a3 + 24))(a3);
    uint64_t v10 = *v9;
    *(_DWORD *)((char *)v9 + *(void *)(*v9 - 24) + 8) = *(_DWORD *)((unsigned char *)v9 + *(void *)(*v9 - 24) + 8) & 0xFFFFFEFB | 4;
    *(uint64_t *)((char *)v9 + *(void *)(v10 - 24) + 24) = 7;
    *(uint64_t *)((char *)v9 + *(void *)(v10 - 24) + 16) = 2;
    long long v11 = (void *)std::ostream::operator<<();
    long long v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)" ms (", 5);
    uint64_t v13 = *v12;
    *(_DWORD *)((char *)v12 + *(void *)(*v12 - 24) + 8) = *(_DWORD *)((unsigned char *)v12 + *(void *)(*v12 - 24) + 8) & 0xFFFFFEFB | 4;
    *(uint64_t *)((char *)v12 + *(void *)(v13 - 24) + 24) = 4;
    *(uint64_t *)((char *)v12 + *(void *)(v13 - 24) + 16) = 1;
    BOOL v14 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"%)", 2);
    BOOL v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)", ", 2);
    (*(void (**)(uint64_t))(*(void *)a4 + 32))(a4);
    (*(void (**)(uint64_t))(*(void *)a3 + 32))(a3);
    *(void *)((char *)v15 + *(void *)(*v15 - 24) + 24) = 10;
    uint64_t v16 = (void *)std::ostream::operator<<();
    BOOL v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)" pixels (", 9);
    uint64_t v18 = *v17;
    *(_DWORD *)((char *)v17 + *(void *)(*v17 - 24) + 8) = *(_DWORD *)((unsigned char *)v17 + *(void *)(*v17 - 24) + 8) & 0xFFFFFEFB | 4;
    *(uint64_t *)((char *)v17 + *(void *)(v18 - 24) + 24) = 4;
    *(uint64_t *)((char *)v17 + *(void *)(v18 - 24) + 16) = 1;
    long long v19 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"%)", 2);
    long long v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)", ", 2);
    (*(void (**)(uint64_t))(*(void *)a3 + 24))(a3);
    (*(void (**)(uint64_t))(*(void *)a3 + 32))(a3);
    uint64_t v21 = *v20;
    *(_DWORD *)((char *)v20 + *(void *)(*v20 - 24) + 8) = *(_DWORD *)((unsigned char *)v20 + *(void *)(*v20 - 24) + 8) & 0xFFFFFEFB | 4;
    *(uint64_t *)((char *)v20 + *(void *)(v21 - 24) + 24) = 7;
    *(uint64_t *)((char *)v20 + *(void *)(v21 - 24) + 16) = 2;
    uint64_t v22 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)" ms / MP", 8);
    long long v23 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)" (", 2);
    *(void *)((char *)v23 + *(void *)(*v23 - 24) + 24) = 4;
    (*(void (**)(uint64_t))(*(void *)a3 + 48))(a3);
    long long v24 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)" tiles", 6);
    long long v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)")", 1);
    long long v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)" (", 2);
    BOOL v27 = (const char *)(*(void *)(a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
    size_t v28 = strlen(v27);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)v27, v28);
    return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)")\n", 2);
  }
  return result;
}

void *std::for_each[abi:ne180100]<std::__map_iterator<std::__tree_iterator<std::__value_type<std::type_info const*,__HGStats_private::StatsProfile>,std::__tree_node<std::__value_type<std::type_info const*,__HGStats_private::StatsProfile>,void *> *,long>>,__HGStats_private::NodeStatsPrinter<std::type_info const,__HGStats_private::StatsProfile,(__HGStats_private::NodeStatsType)0>>(void *a1, void *a2, void *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    unint64_t v6 = a1;
    uint64_t v7 = off_1F10DC630;
    __s2 = (char *)((unint64_t)off_1F10DC630 & 0x7FFFFFFFFFFFFFFFLL);
    do
    {
      uint64_t v8 = v6[4];
      BOOL v17 = &unk_1F10D9BD8;
      long long v9 = *((_OWORD *)v6 + 4);
      long long v18 = *((_OWORD *)v6 + 3);
      long long v19 = v9;
      uint64_t v10 = *(char **)(v8 + 8);
      if (v7 != v10
        && ((((unint64_t)v7 & (unint64_t)v10 & 0x8000000000000000) != 0) == __OFSUB__(v7, v10)
         || strcmp((const char *)((unint64_t)v10 & 0x7FFFFFFFFFFFFFFFLL), __s2))
        && off_1F10D0DF0 != v10
        && ((((unint64_t)off_1F10D0DF0 & (unint64_t)v10 & 0x8000000000000000) != 0) == __OFSUB__(off_1F10D0DF0, v10)
         || strcmp((const char *)((unint64_t)v10 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)off_1F10D0DF0 & 0x7FFFFFFFFFFFFFFFLL))))
      {
        __HGStats_private::printNodeStats<std::type_info,__HGStats_private::StatsProfile const>(a3, v8, (uint64_t)&v17, a4);
      }
      long long v11 = (void *)v6[1];
      if (v11)
      {
        do
        {
          long long v12 = v11;
          long long v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          long long v12 = (void *)v6[2];
          BOOL v13 = *v12 == (void)v6;
          unint64_t v6 = v12;
        }
        while (!v13);
      }
      unint64_t v6 = v12;
    }
    while (v12 != a2);
  }
  return a3;
}

void *__HGStats_private::NodePixelsPrinter<std::type_info const>::operator()(void **a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(*a1, (uint64_t)"|    ", 5);
  unint64_t v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"ROI: ", 5);
  *(void *)((char *)v4 + *(void *)(*v4 - 24) + 24) = 10;
  unint64_t v5 = (void *)std::ostream::operator<<();
  unint64_t v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)" pixels", 7);
  uint64_t v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)", ", 2);
  *(void *)((char *)v7 + *(void *)(*v7 - 24) + 24) = 4;
  uint64_t v8 = (void *)std::ostream::operator<<();
  long long v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" nodes", 6);
  uint64_t v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)" (", 2);
  long long v11 = (const char *)(*(void *)(v2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
  size_t v12 = strlen(v11);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)v11, v12);

  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)")\n", 2);
}

void *__HGStats_private::InOutRoiStatsPrinter<std::type_info const>::operator()(void *result, uint64_t *a2)
{
  uint64_t v2 = result[1];
  uint64_t v3 = *a2;
  if (v2) {
    BOOL v4 = v2 == v3;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    unint64_t v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>((void *)*result, (uint64_t)"|    ", 5);
    if (v2)
    {
      unint64_t v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"         ", 9);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"in #", 4);
      uint64_t v7 = (void *)std::ostream::operator<<();
      uint64_t v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)" ROI ratio : ", 13);
      uint64_t v9 = *v8;
      *(_DWORD *)((char *)v8 + *(void *)(*v8 - 24) + 8) = *(_DWORD *)((unsigned char *)v8 + *(void *)(*v8 - 24) + 8) & 0xFFFFFEFB | 4;
      *(uint64_t *)((char *)v8 + *(void *)(v9 - 24) + 24) = 4;
      *(uint64_t *)((char *)v8 + *(void *)(v9 - 24) + 16) = 2;
      std::ostream::operator<<();
      uint64_t v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" ", 1);
      long long v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)"(", 1);
      *(void *)((char *)v11 + *(void *)(*v11 - 24) + 24) = 10;
      size_t v12 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)")", 1);
      BOOL v13 = "\n";
      BOOL v14 = v10;
      uint64_t v15 = 1;
    }
    else
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"in #", 4);
      uint64_t v16 = (void *)std::ostream::operator<<();
      BOOL v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)" :  ", 4);
      uint64_t v18 = *v17;
      *(_DWORD *)((char *)v17 + *(void *)(*v17 - 24) + 8) = *(_DWORD *)((unsigned char *)v17 + *(void *)(*v17 - 24) + 8) & 0xFFFFFEFB | 4;
      *(uint64_t *)((char *)v17 + *(void *)(v18 - 24) + 24) = 4;
      *(uint64_t *)((char *)v17 + *(void *)(v18 - 24) + 16) = 2;
      std::ostream::operator<<();
      long long v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)"  ", 2);
      long long v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"(input: ", 8);
      *(void *)((char *)v20 + *(void *)(*v20 - 24) + 24) = 10;
      uint64_t v21 = (void *)std::ostream::operator<<();
      uint64_t v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)", ouput: ", 9);
      *(void *)((char *)v22 + *(void *)(*v22 - 24) + 24) = 10;
      long long v23 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)")", 1);
      long long v24 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"  (", 3);
      size_t v25 = strlen((const char *)(*(void *)(v3 + 8) & 0x7FFFFFFFFFFFFFFFLL));
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, *(void *)(v3 + 8) & 0x7FFFFFFFFFFFFFFFLL, v25);
      BOOL v13 = ")\n";
      BOOL v14 = v24;
      uint64_t v15 = 2;
    }
    return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)v13, v15);
  }
  return result;
}

void *__HGStats_private::NodeStatsVerbosePrinter<std::type_info const,__HGStats_private::StatsProfile,(__HGStats_private::NodeStatsType)1>::operator()(void *result, unint64_t *a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *a2;
  unint64_t v5 = *(char **)(*a2 + 8);
  if (off_1F10DC630 == v5
    || (((unint64_t)off_1F10DC630 & (unint64_t)v5 & 0x8000000000000000) != 0) != __OFSUB__(off_1F10DC630, v5)&& (__n128 result = (void *)strcmp((const char *)((unint64_t)v5 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)off_1F10DC630 & 0x7FFFFFFFFFFFFFFFLL)), !result)|| off_1F10D0DF0 == v5|| (((unint64_t)off_1F10D0DF0 & (unint64_t)v5 & 0x8000000000000000) != 0) != __OFSUB__(off_1F10D0DF0, v5)&& (__n128 result = (void *)strcmp((const char *)((unint64_t)v5 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)off_1F10D0DF0 & 0x7FFFFFFFFFFFFFFFLL)), !result))
  {
    if (a2[3])
    {
      __HGStats_private::printNodeStats<std::type_info,__HGStats_private::StatsProfile const>((void *)*v3, v4, (uint64_t)(a2 + 1), v3[1]);
      __n128 result = __HGStats_private::NodePixels<HGNode>::outputComputeRatio((uint64_t **)v3[2], (void *)*v3, *a2);
      unint64_t v6 = (void *)v3[3];
      uint64_t v7 = (void *)*v3;
      unint64_t v8 = *a2;
      long long v11 = (void *)*v6;
      uint64_t v10 = v6 + 1;
      uint64_t v9 = v11;
      v17[0] = v7;
      v17[1] = v8;
      if (v11 != v10)
      {
        do
        {
          long long v12 = *((_OWORD *)v9 + 3);
          v16[0] = *((_OWORD *)v9 + 2);
          v16[1] = v12;
          __n128 result = __HGStats_private::InOutRoiStatsPrinter<std::type_info const>::operator()(v17, (uint64_t *)v16);
          BOOL v13 = (void *)v9[1];
          if (v13)
          {
            do
            {
              BOOL v14 = v13;
              BOOL v13 = (void *)*v13;
            }
            while (v13);
          }
          else
          {
            do
            {
              BOOL v14 = (void *)v9[2];
              BOOL v15 = *v14 == (void)v9;
              uint64_t v9 = v14;
            }
            while (!v15);
          }
          uint64_t v9 = v14;
        }
        while (v14 != v10);
      }
    }
  }
  return result;
}

void *__HGStats_private::NodeStatsVerbosePrinter<std::type_info const,__HGStats_private::StatsProfile,(__HGStats_private::NodeStatsType)0>::operator()(void *result, unint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *(char **)(*a2 + 8);
  if (off_1F10DC630 != v3)
  {
    unint64_t v5 = result;
    if ((((unint64_t)off_1F10DC630 & (unint64_t)v3 & 0x8000000000000000) != 0) == __OFSUB__(off_1F10DC630, v3)
      || (__n128 result = (void *)strcmp((const char *)((unint64_t)v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)off_1F10DC630 & 0x7FFFFFFFFFFFFFFFLL)), result))
    {
      if (off_1F10D0DF0 != v3)
      {
        if ((((unint64_t)off_1F10D0DF0 & (unint64_t)v3 & 0x8000000000000000) != 0) == __OFSUB__(off_1F10D0DF0, v3)
          || (__n128 result = (void *)strcmp((const char *)((unint64_t)v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)off_1F10D0DF0 & 0x7FFFFFFFFFFFFFFFLL)), result))
        {
          if (a2[3])
          {
            __HGStats_private::printNodeStats<std::type_info,__HGStats_private::StatsProfile const>((void *)*v5, v2, (uint64_t)(a2 + 1), v5[1]);
            __n128 result = __HGStats_private::NodePixels<HGNode>::outputComputeRatio((uint64_t **)v5[2], (void *)*v5, *a2);
            unint64_t v6 = (void *)v5[3];
            uint64_t v7 = (void *)*v5;
            unint64_t v8 = *a2;
            long long v11 = (void *)*v6;
            uint64_t v10 = v6 + 1;
            uint64_t v9 = v11;
            v17[0] = v7;
            v17[1] = v8;
            if (v11 != v10)
            {
              do
              {
                long long v12 = *((_OWORD *)v9 + 3);
                v16[0] = *((_OWORD *)v9 + 2);
                v16[1] = v12;
                __n128 result = __HGStats_private::InOutRoiStatsPrinter<std::type_info const>::operator()(v17, (uint64_t *)v16);
                BOOL v13 = (void *)v9[1];
                if (v13)
                {
                  do
                  {
                    BOOL v14 = v13;
                    BOOL v13 = (void *)*v13;
                  }
                  while (v13);
                }
                else
                {
                  do
                  {
                    BOOL v14 = (void *)v9[2];
                    BOOL v15 = *v14 == (void)v9;
                    uint64_t v9 = v14;
                  }
                  while (!v15);
                }
                uint64_t v9 = v14;
              }
              while (v14 != v10);
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t OUTLINED_FUNCTION_1_1(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t OUTLINED_FUNCTION_2_0(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t OUTLINED_FUNCTION_3_0()
{
  return v0;
}

uint64_t OUTLINED_FUNCTION_5_0()
{
  return v0;
}

void HGStats::GraphStatsImpl::GraphStatsImpl(uint64_t a1, void *a2)
{
  unint64_t v5 = *(void **)(a1 + 16);
  unint64_t v6 = a2;
  if (v5 != a2)
  {
    OUTLINED_FUNCTION_0_3();
    do
    {
      OUTLINED_FUNCTION_7();
      uint64_t v7 = OUTLINED_FUNCTION_3_0();
      v8(v7);
      OUTLINED_FUNCTION_6();
    }
    while (!v9);
    unint64_t v6 = *v2;
  }
  *(void *)(a1 + 16) = a2;

  operator delete(v6);
}

void HGStats::UnitStats::UnitStats(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = (void *)OUTLINED_FUNCTION_1_1(a1, a2);
  if (!v8)
  {
    OUTLINED_FUNCTION_4_0();
    do
    {
      v6 -= 40;
      uint64_t v9 = OUTLINED_FUNCTION_5_0();
      v10(v9);
      v5 -= 40;
      BOOL v8 = v4 == v2;
      uint64_t v4 = v6;
    }
    while (!v8);
    uint64_t v7 = *(void **)v3;
  }
  *(void *)(v3 + 8) = v2;

  operator delete(v7);
}

void HGStats::RendererStats::RendererStats(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = (void *)OUTLINED_FUNCTION_2_0(a1, a2);
  if (!v6)
  {
    OUTLINED_FUNCTION_0_3();
    do
    {
      OUTLINED_FUNCTION_7();
      uint64_t v7 = OUTLINED_FUNCTION_3_0();
      v8(v7);
      OUTLINED_FUNCTION_6();
    }
    while (!v6);
    uint64_t v5 = *v4;
  }
  *(void *)(v3 + 24) = v2;

  operator delete(v5);
}

void HGTexture::HGTexture(HGTexture *this, HGRect a2, HGBitmap *a3)
{
  HGBitmap::HGBitmap((HGBitmap *)this, a2, a3);
  void *v3 = &unk_1F10D9CC0;
}

void *HGTexture::HGTexture(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  __n128 result = (void *)HGBitmap::HGBitmap(a1, a2, a3, a4, a5);
  *__n128 result = &unk_1F10D9CC0;
  return result;
}

void HGTexture::~HGTexture(HGBitmap *this, void *a2)
{
  HGBitmap::~HGBitmap(this, a2);

  HGObject::operator delete(v2);
}

BOOL TextureDeleteQueue::DeleteRequest::test(TextureDeleteQueue::DeleteRequest *this)
{
  double v2 = (double)(HGGetTBC() - *((void *)this + 15)) * 1000000000.0;
  if ((unint64_t)(v2 / (double)HGGetTBCFrequency()) < 0xF4241) {
    return 0;
  }
  unsigned __int8 v5 = atomic_load(HGLogger::_enabled);
  if (v5) {
    HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"DeleteRequest::test(%d)\n", v3, v4, *((unsigned int *)this + 18));
  }
  int v8 = glClientWaitSyncAPPLE();
  if (v8 == 37149) {
    HGLogger::warning((HGLogger *)"gl sync error -- WAIT_FAILED_APPLE", v6, v7);
  }
  return v8 == 37146;
}

void TextureDeleteQueue::DeleteRequest::execute(TextureDeleteQueue::DeleteRequest *this)
{
  int v2 = glClientWaitSyncAPPLE();
  glDeleteSyncAPPLE();
  if (v2 == 37147)
  {
    uint64_t v7 = "gl sync error -- TIMEOUT_EXPIRED_APPLE";
  }
  else
  {
    if (v2 != 37149) {
      goto LABEL_6;
    }
    uint64_t v7 = "gl sync error -- WAIT_FAILED_APPLE";
  }
  HGLogger::warning((HGLogger *)v7, v3, v4);
LABEL_6:
  if (*((unsigned char *)this + 112))
  {
    int v8 = *((unsigned __int8 *)this + 113);
    unsigned __int8 v9 = atomic_load(HGLogger::_enabled);
    if (v8)
    {
      if (v9) {
        HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"DeleteRequest::execute() -- adding texture %d to free texture pool\n", v5, v6, *((unsigned int *)this + 18));
      }
      unint64_t v10 = *(void *)(*(void *)this + 16);
        operator new();
      if (!v11) {
        goto LABEL_29;
      }
      do
      {
        unint64_t v13 = v11[4];
        BOOL v14 = v13 >= v10;
        if (v13 >= v10) {
          BOOL v15 = v11;
        }
        else {
          BOOL v15 = v11 + 1;
        }
        if (v14) {
          uint64_t v12 = (uint64_t)v11;
        }
        long long v11 = (void *)*v15;
      }
      while (*v15);
LABEL_29:
      uint64_t v17 = *(void *)(v12 + 40);
      pthread_mutex_lock((pthread_mutex_t *)(v17 + 16));
      *((_DWORD *)this + 22) = 1;
      uint64_t v18 = HGGetTBC();
      uint64_t v19 = *(void *)(v17 + 96);
      uint64_t v20 = *(void *)(v17 + 88);
      uint64_t v21 = 42 * ((v19 - v20) >> 3) - 1;
      *((void *)this + 12) = v18;
      if (v19 == v20) {
        uint64_t v21 = 0;
      }
      unint64_t v22 = *(void *)(v17 + 120) + *(void *)(v17 + 112);
      if (v21 == v22)
      {
        std::deque<HGTextureManager::TextureEntry>::__add_back_capacity(v17 + 80);
        uint64_t v20 = *(void *)(v17 + 88);
        unint64_t v22 = *(void *)(v17 + 120) + *(void *)(v17 + 112);
      }
      long long v23 = (_OWORD *)(*(void *)(v20 + 8 * (v22 / 0x2A)) + 96 * (v22 % 0x2A));
      long long v24 = *(_OWORD *)((char *)this + 24);
      *long long v23 = *(_OWORD *)((char *)this + 8);
      v23[1] = v24;
      long long v25 = *(_OWORD *)((char *)this + 40);
      long long v26 = *(_OWORD *)((char *)this + 56);
      long long v27 = *(_OWORD *)((char *)this + 88);
      v23[4] = *(_OWORD *)((char *)this + 72);
      v23[5] = v27;
      void v23[2] = v25;
      void v23[3] = v26;
      ++*(void *)(v17 + 120);
      if (*((unsigned char *)this + 64) == 2)
      {
        unint64_t v28 = *((int *)this + 21);
        long long v29 = (void *)(v17 + 152);
      }
      else
      {
        unint64_t v28 = *((int *)this + 21);
        if (*((unsigned char *)this + 77))
        {
          *(int64x2_t *)(v17 + 128) = vaddq_s64(*(int64x2_t *)(v17 + 128), vdupq_n_s64(v28));
          if (*((char *)this + 76) < 0)
          {
LABEL_41:
            pthread_mutex_unlock((pthread_mutex_t *)(v17 + 16));
            goto LABEL_42;
          }
          long long v29 = (void *)(v17 + 144);
        }
        else
        {
          long long v29 = (void *)(v17 + 160);
        }
      }
      *v29 += v28;
      goto LABEL_41;
    }
    if (v9) {
      HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"DeleteRequest::execute() -- deleting texture %d\n", v5, v6, *((unsigned int *)this + 18));
    }
    unsigned int v30 = *((_DWORD *)this + 18);
    HGTextureManager::deleteTexture(*(HGGLContext ***)this, &v30);
  }
  else
  {
    unsigned __int8 v16 = atomic_load(HGLogger::_enabled);
    if (v16) {
      HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"DeleteRequest::execute() -- finished unowned texture %d\n", v5, v6, *((unsigned int *)this + 18));
    }
  }
LABEL_42:
  HGTextureManager::_dumpTextures(*(HGTextureManager **)this, *(char **)(*(void *)this + 16));
  if (*((void *)this + 13))
  {
    pthread_mutex_lock(*(pthread_mutex_t **)(*(void *)this + 112));
    HGTextureManager::PostTextureDeleteEventList::addEvent(*(HGTextureManager::PostTextureDeleteEventList **)(*(void *)this + 112), *((void **)this + 13));
    pthread_mutex_unlock(*(pthread_mutex_t **)(*(void *)this + 112));
  }
}

void sub_1B77D36D4(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

void HGTextureManager::deleteTexture(HGGLContext **this, const unsigned int *a2)
{
  uint64_t v4 = (pthread_mutex_t *)(this + 6);
  pthread_mutex_lock((pthread_mutex_t *)(this + 6));
  HGGLContext::context((uint64_t *)&v5, this[5]);
  HGGLSetCurrentContextGuard::HGGLSetCurrentContextGuard((HGGLContextPtr *)v6, &v5.var0);
  PCSharedCount::PCSharedCount(&v5);
  glDeleteTextures(1, a2);
  pthread_mutex_unlock(v4);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)v6);
}

void sub_1B77D3768(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

void sub_1B77D377C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)va);
  _Unwind_Resume(a1);
}

void HGTextureManager::PostTextureDeleteEventList::addEvent(HGTextureManager::PostTextureDeleteEventList *this, void *a2)
{
  PCSharedCount v5 = (char *)*((void *)this + 9);
  unint64_t v4 = *((void *)this + 10);
  char v6 = v5;
  if ((unint64_t)v5 < v4)
  {
    *(void *)PCSharedCount v5 = a2;
    uint64_t v7 = (uint64_t)(v5 + 8);
    goto LABEL_23;
  }
  int v8 = (void **)((char *)this + 64);
  unsigned __int8 v9 = (char *)*((void *)this + 8);
  uint64_t v10 = (v5 - v9) >> 3;
  unint64_t v11 = v10 + 1;
  if ((unint64_t)(v10 + 1) >> 61) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v12 = v4 - (void)v9;
  if (v12 >> 2 > v11) {
    unint64_t v11 = v12 >> 2;
  }
  if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v13 = v11;
  }
  if (v13)
  {
    if (v13 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    BOOL v14 = (char *)operator new(8 * v13);
    BOOL v15 = &v14[8 * v10];
    unsigned __int8 v16 = &v14[8 * v13];
    *(void *)BOOL v15 = a2;
    uint64_t v7 = (uint64_t)(v15 + 8);
    uint64_t v17 = (char *)(v5 - v9);
    if (v5 == v9) {
      goto LABEL_21;
    }
    goto LABEL_14;
  }
  BOOL v14 = 0;
  BOOL v15 = (char *)(8 * v10);
  unsigned __int8 v16 = 0;
  *(void *)(8 * v1CVOpenGLESTextureCacheFlush(this[3], 0) = a2;
  uint64_t v7 = 8 * v10 + 8;
  uint64_t v17 = (char *)(v5 - v9);
  if (v5 != v9)
  {
LABEL_14:
    unint64_t v18 = (unint64_t)(v17 - 8);
    if (v18 < 0x58) {
      goto LABEL_28;
    }
    if ((unint64_t)(v9 - v14) < 0x20) {
      goto LABEL_28;
    }
    uint64_t v19 = (v18 >> 3) + 1;
    uint64_t v20 = 8 * (v19 & 0x3FFFFFFFFFFFFFFCLL);
    char v6 = &v5[-v20];
    v15 -= v20;
    uint64_t v21 = &v14[8 * v10 - 16];
    unint64_t v22 = (long long *)(v5 - 16);
    uint64_t v23 = v19 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v24 = *v22;
      *((_OWORD *)v21 - 1) = *(v22 - 1);
      *(_OWORD *)uint64_t v21 = v24;
      v21 -= 32;
      v22 -= 2;
      v23 -= 4;
    }
    while (v23);
    if (v19 != (v19 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_28:
      do
      {
        uint64_t v25 = *((void *)v6 - 1);
        v6 -= 8;
        *((void *)v15 - 1) = v25;
        v15 -= 8;
      }
      while (v6 != v9);
    }
    char v6 = (char *)*v8;
  }
LABEL_21:
  *((void *)this + 8) = v15;
  *((void *)this + 9) = v7;
  *((void *)this + 1CVOpenGLESTextureCacheFlush(this[3], 0) = v16;
  if (v6) {
    operator delete(v6);
  }
LABEL_23:
  *((void *)this + 9) = v7;
}

void TextureDeleteQueue::TextureDeleteQueue(TextureDeleteQueue *this)
{
  HGObject::HGObject(this);
  *(void *)uint64_t v2 = &unk_1F10D9D40;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_OWORD *)(v2 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = 0u;
  *(_OWORD *)(v2 + 96) = 0u;
  *(_OWORD *)(v2 + 112) = 0u;
  *(_DWORD *)(v2 + 40CVOpenGLESTextureCacheFlush(this[3], 0) = 1;
  *(_WORD *)(v2 + 404) = 257;
  uint64_t v3 = (pthread_mutex_t *)(v2 + 128);
  *(unsigned char *)(v2 + 406) = 1;
  pthread_mutex_init((pthread_mutex_t *)(v2 + 128), 0);
  pthread_cond_init((pthread_cond_t *)this + 4, 0);
  pthread_cond_init((pthread_cond_t *)this + 5, 0);
  pthread_cond_init((pthread_cond_t *)this + 6, 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 336), 0);
  *((unsigned char *)this + 405) = 0;
  if (pthread_create((pthread_t *)this + 9, 0, (void *(__cdecl *)(void *))textureFinishThread, this))
  {
    HGLogger::warning((HGLogger *)"ERROR - couldn't create texture finish thread\n", v4, v5);
  }
  else
  {
    unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
    if (v8) {
      HGLogger::log((HGLogger *)"init", (const char *)1, (HGLogger *)"texture finish thread created succesfully\n", v6, v7);
    }
  }
  pthread_mutex_lock(v3);
  while (!*((unsigned char *)this + 405))
    pthread_cond_wait((pthread_cond_t *)this + 5, v3);
  pthread_mutex_unlock(v3);
}

void sub_1B77D3A5C(_Unwind_Exception *a1)
{
  std::deque<TextureDeleteQueue::DeleteRequest>::~deque[abi:ne180100]((uint64_t)v1 + 80);
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

uint64_t textureFinishThread(int64x2_t *a1)
{
  return 0;
}

void TextureDeleteQueue::~TextureDeleteQueue(TextureDeleteQueue *this)
{
  *(void *)this = &unk_1F10D9D40;
  TextureDeleteQueue::finishQueue(this);
  pthread_mutex_lock((pthread_mutex_t *)this + 2);
  *((unsigned char *)this + 406) = 0;
  pthread_cond_signal((pthread_cond_t *)this + 4);
  pthread_mutex_unlock((pthread_mutex_t *)this + 2);
  pthread_join(*((pthread_t *)this + 9), 0);
  pthread_mutex_destroy((pthread_mutex_t *)this + 2);
  pthread_cond_destroy((pthread_cond_t *)this + 4);
  pthread_cond_destroy((pthread_cond_t *)this + 5);
  pthread_cond_destroy((pthread_cond_t *)this + 6);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 336));
  std::deque<TextureDeleteQueue::DeleteRequest>::~deque[abi:ne180100]((uint64_t)this + 80);

  HGObject::~HGObject(this);
}

{
  void *v1;
  uint64_t vars8;

  TextureDeleteQueue::~TextureDeleteQueue(this);

  HGObject::operator delete(v1);
}

void TextureDeleteQueue::finishQueue(TextureDeleteQueue *this)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v2, "texManager", 2, "TextureDeleteQueue::finishQueue()");
  if (*((unsigned char *)this + 404))
  {
    pthread_mutex_lock((pthread_mutex_t *)this + 2);
    while (*((void *)this + 15))
    {
      TextureDeleteQueue::_popFrontRequest(this, (uint64_t)v3);
      pthread_mutex_unlock((pthread_mutex_t *)this + 2);
      TextureDeleteQueue::DeleteRequest::execute((TextureDeleteQueue::DeleteRequest *)v3);
      pthread_mutex_lock((pthread_mutex_t *)this + 2);
    }
  }
  else
  {
    pthread_mutex_lock((pthread_mutex_t *)this + 2);
    *((unsigned char *)this + 404) = 1;
    while (!*((unsigned char *)this + 405))
      pthread_cond_wait((pthread_cond_t *)this + 5, (pthread_mutex_t *)this + 2);
    while (*((void *)this + 15))
    {
      TextureDeleteQueue::_popFrontRequest(this, (uint64_t)v3);
      TextureDeleteQueue::DeleteRequest::execute((TextureDeleteQueue::DeleteRequest *)v3);
    }
    *((unsigned char *)this + 404) = 0;
    pthread_cond_signal((pthread_cond_t *)this + 4);
  }
  pthread_mutex_unlock((pthread_mutex_t *)this + 2);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v2);
}

void sub_1B77D3C70(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77D3C84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77D3C98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77D3CAC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void TextureDeleteQueue::threadLoop(int64x2_t *this)
{
  if (this[25].i8[6])
  {
    char v2 = 0;
    uint64_t v3 = (pthread_mutex_t *)&this[8];
    unint64_t v4 = (pthread_cond_t *)&this[15];
    PCSharedCount v5 = (pthread_cond_t *)&this[12];
    uint64_t v20 = this + 3;
    uint64_t v21 = this + 2;
    unint64_t v22 = &this[2].i8[8];
    uint64_t v23 = (pthread_cond_t *)&this[18];
    while ((v2 & 1) != 0)
    {
      gettimeofday(&v30, 0);
      v31.time_t tv_sec = v30.tv_sec;
      v31.tv_nsec = 1000 * v30.tv_usec + 40000000;
      if (v31.tv_nsec >= 0x3B9ACA00uLL)
      {
        v31.time_t tv_sec = v30.tv_sec + 1;
        v31.tv_nsec = 1000 * v30.tv_usec - 960000000;
      }
      pthread_mutex_lock(v3);
      if (!this[25].i8[6]) {
        goto LABEL_12;
      }
      if (v2)
      {
        this[25].i8[5] = 1;
        pthread_cond_signal(v4);
        pthread_cond_timedwait(v5, v3, &v31);
        if (!this[25].i8[6]) {
          goto LABEL_12;
        }
      }
LABEL_14:
      while (this[25].i8[4] || !this[7].i64[1])
      {
        this[25].i8[5] = 1;
        pthread_cond_signal(v4);
        pthread_cond_wait(v5, v3);
        if (!this[25].i8[6]) {
          goto LABEL_12;
        }
      }
      this[25].i8[5] = 0;
LABEL_17:
      if (TextureDeleteQueue::DeleteRequest::test((TextureDeleteQueue::DeleteRequest *)(*(void *)(this[5].i64[1] + 8 * (this[7].i64[0] / 0x1EuLL))
                                                                                       + 136
                                                                                       * (this[7].i64[0] % 0x1EuLL))))
      {
        uint64_t v7 = (void **)this[5].i64[1];
        unint64_t v8 = this[7].u64[0];
        unint64_t v9 = (unint64_t)v7[v8 / 0x1E] + 136 * (v8 % 0x1E);
        long long v10 = *(_OWORD *)(v9 + 112);
        long long v27 = *(_OWORD *)(v9 + 96);
        long long v28 = v10;
        uint64_t v29 = *(void *)(v9 + 128);
        long long v11 = *(_OWORD *)(v9 + 48);
        void v24[2] = *(_OWORD *)(v9 + 32);
        v24[3] = v11;
        long long v12 = *(_OWORD *)(v9 + 80);
        long long v25 = *(_OWORD *)(v9 + 64);
        long long v26 = v12;
        long long v13 = *(_OWORD *)(v9 + 16);
        v24[0] = *(_OWORD *)v9;
        v24[1] = v13;
        if (v25 == 2)
        {
          uint64_t v14 = SDWORD1(v26);
          uint64_t i64 = v22;
          goto LABEL_29;
        }
        uint64_t v14 = SDWORD1(v26);
        if (!BYTE13(v25))
        {
          uint64_t i64 = v20->i64;
LABEL_29:
          *i64 -= v14;
          uint64_t v18 = this[7].i64[1] - 1;
          unint64_t v19 = v8 + 1;
          this[7].i64[0] = v19;
          this[7].i64[1] = v18;
          if (v19 < 0x3C) {
            goto LABEL_26;
          }
LABEL_25:
          operator delete(*v7);
          this[5].i64[1] += 8;
          this[7].i64[0] -= 30;
          goto LABEL_26;
        }
        this[1] = vsubq_s64(this[1], vdupq_n_s64(SDWORD1(v26)));
        uint64_t i64 = v21->i64;
        if ((SBYTE12(v25) & 0x80000000) == 0) {
          goto LABEL_29;
        }
        uint64_t v16 = this[7].i64[1] - 1;
        unint64_t v17 = v8 + 1;
        this[7].i64[0] = v17;
        this[7].i64[1] = v16;
        if (v17 >= 0x3C) {
          goto LABEL_25;
        }
LABEL_26:
        pthread_cond_broadcast(v23);
        pthread_mutex_unlock(v3);
        TextureDeleteQueue::DeleteRequest::execute((TextureDeleteQueue::DeleteRequest *)v24);
        char v2 = 0;
        if (!this[25].i8[6]) {
          return;
        }
      }
      else
      {
LABEL_3:
        pthread_mutex_unlock(v3);
        char v2 = 1;
        if (!this[25].i8[6]) {
          return;
        }
      }
    }
    pthread_mutex_lock(v3);
    if (this[25].i8[6]) {
      goto LABEL_14;
    }
LABEL_12:
    uint64_t v6 = this[7].i64[1];
    this[25].i8[5] = 0;
    if (!v6) {
      goto LABEL_3;
    }
    goto LABEL_17;
  }
}

uint64_t TextureDeleteQueue::enqueueDelete(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4, char *a5, char a6, char a7)
{
  int v9 = (int)a5;
  unsigned __int8 v14 = atomic_load(HGLogger::_enabled);
  if (v14) {
    HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"TextureDeleteQueue::enqueueDelete(%d)\n", a4, a5, *(unsigned int *)(a3 + 64));
  }
  long long v15 = *(_OWORD *)(a3 + 48);
  *(_OWORD *)&v31[40] = *(_OWORD *)(a3 + 32);
  *(_OWORD *)&v31[56] = v15;
  long long v16 = *(_OWORD *)(a3 + 80);
  *(_OWORD *)&v31[72] = *(_OWORD *)(a3 + 64);
  *(_OWORD *)&v31[88] = v16;
  long long v17 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)&v31[8] = *(_OWORD *)a3;
  *(_OWORD *)&unsigned char v31[24] = v17;
  *(void *)timespec v31 = a2;
  *(void *)&v31[104] = a4;
  LOBYTE(v32) = a6;
  BYTE1(v32) = a7;
  *((void *)&v32 + 1) = HGGetTBC();
  uint64_t v33 = glFenceSyncAPPLE();
  glFlush();
  if (!v9)
  {
    TextureDeleteQueue::DeleteRequest::execute((TextureDeleteQueue::DeleteRequest *)v31);
    return *(unsigned int *)(a3 + 64);
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 128));
  uint64_t v18 = *(void *)(a1 + 96);
  uint64_t v19 = *(void *)(a1 + 88);
  uint64_t v20 = 30 * ((v18 - v19) >> 3) - 1;
  if (v18 == v19) {
    uint64_t v20 = 0;
  }
  unint64_t v21 = *(void *)(a1 + 120) + *(void *)(a1 + 112);
  if (v20 == v21)
  {
    std::deque<TextureDeleteQueue::DeleteRequest>::__add_back_capacity(a1 + 80);
    uint64_t v19 = *(void *)(a1 + 88);
    unint64_t v21 = *(void *)(a1 + 120) + *(void *)(a1 + 112);
  }
  unint64_t v22 = *(void *)(v19 + 8 * (v21 / 0x1E)) + 136 * (v21 % 0x1E);
  long long v23 = *(_OWORD *)&v31[48];
  *(_OWORD *)(v22 + 32) = *(_OWORD *)&v31[32];
  *(_OWORD *)(v22 + 48) = v23;
  long long v24 = v32;
  long long v25 = *(_OWORD *)&v31[80];
  *(_OWORD *)(v22 + 96) = *(_OWORD *)&v31[96];
  *(_OWORD *)(v22 + 112) = v24;
  long long v26 = *(_OWORD *)&v31[64];
  *(void *)(v22 + 128) = v33;
  *(_OWORD *)(v22 + 64) = v26;
  *(_OWORD *)(v22 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = v25;
  long long v27 = *(_OWORD *)&v31[16];
  *(_OWORD *)unint64_t v22 = *(_OWORD *)v31;
  *(_OWORD *)(v22 + 16) = v27;
  ++*(void *)(a1 + 120);
  if (v31[64] == 2)
  {
    uint64_t v28 = *(int *)&v31[84];
    uint64_t v29 = (void *)(a1 + 40);
LABEL_15:
    *v29 += v28;
    goto LABEL_16;
  }
  uint64_t v28 = *(int *)&v31[84];
  if (!v31[77])
  {
    uint64_t v29 = (void *)(a1 + 48);
    goto LABEL_15;
  }
  *(int64x2_t *)(a1 + 16) = vaddq_s64(*(int64x2_t *)(a1 + 16), vdupq_n_s64(*(int *)&v31[84]));
  if ((v31[76] & 0x80000000) == 0)
  {
    uint64_t v29 = (void *)(a1 + 32);
    goto LABEL_15;
  }
LABEL_16:
  if (!*(unsigned char *)(a1 + 404)) {
    pthread_cond_signal((pthread_cond_t *)(a1 + 192));
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 128));
  return *(unsigned int *)(a3 + 64);
}

uint64_t TextureDeleteQueue::_popFrontRequest@<X0>(TextureDeleteQueue *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = (void **)*((void *)this + 11);
  unint64_t v4 = *((void *)this + 14);
  unint64_t v5 = (unint64_t)v3[v4 / 0x1E] + 136 * (v4 % 0x1E);
  long long v6 = *(_OWORD *)(v5 + 112);
  *(_OWORD *)(a2 + 96) = *(_OWORD *)(v5 + 96);
  *(_OWORD *)(a2 + 112) = v6;
  *(void *)(a2 + 128) = *(void *)(v5 + 128);
  long long v7 = *(_OWORD *)(v5 + 48);
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(v5 + 32);
  *(_OWORD *)(a2 + 48) = v7;
  long long v8 = *(_OWORD *)(v5 + 80);
  *(_OWORD *)(a2 + 64) = *(_OWORD *)(v5 + 64);
  *(_OWORD *)(a2 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = v8;
  long long v9 = *(_OWORD *)(v5 + 16);
  *(_OWORD *)a2 = *(_OWORD *)v5;
  *(_OWORD *)(a2 + 16) = v9;
  if (*(unsigned char *)(a2 + 64) == 2)
  {
    unint64_t v10 = *(int *)(a2 + 84);
    long long v11 = (char *)this + 40;
  }
  else
  {
    unint64_t v10 = *(int *)(a2 + 84);
    if (*(unsigned char *)(a2 + 77))
    {
      *((int64x2_t *)this + 1) = vsubq_s64(*((int64x2_t *)this + 1), vdupq_n_s64(v10));
      if (*(char *)(a2 + 76) < 0) {
        goto LABEL_8;
      }
      long long v11 = (char *)this + 32;
    }
    else
    {
      long long v11 = (char *)this + 48;
    }
  }
  *(void *)v11 -= v10;
LABEL_8:
  uint64_t v12 = *((void *)this + 15) - 1;
  unint64_t v13 = v4 + 1;
  *((void *)this + 14) = v13;
  *((void *)this + 15) = v12;
  if (v13 >= 0x3C)
  {
    operator delete(*v3);
    *((void *)this + 11) += 8;
    *((void *)this + 14) -= 30;
  }
  pthread_cond_broadcast((pthread_cond_t *)this + 6);
  return *((unsigned int *)this + 30);
}

uint64_t TextureDeleteQueue::executeFinishedRequests(pthread_mutex_t *this, int a2)
{
  if (!a2)
  {
    if (!*(void *)&this[1].__opaque[48]) {
      return 0;
    }
    uint64_t v4 = 0;
    do
    {
      if (!TextureDeleteQueue::DeleteRequest::test((TextureDeleteQueue::DeleteRequest *)(*(void *)(*(void *)&this[1].__opaque[16] + 8 * (*(void *)&this[1].__opaque[40] / 0x1EuLL))
                                                                                        + 136
                                                                                        * (*(void *)&this[1].__opaque[40]
                                                                                         % 0x1EuLL))))
        break;
      TextureDeleteQueue::_popFrontRequest((TextureDeleteQueue *)this, (uint64_t)v6);
      TextureDeleteQueue::DeleteRequest::execute((TextureDeleteQueue::DeleteRequest *)v6);
      uint64_t v4 = (v4 + 1);
    }
    while (*(void *)&this[1].__opaque[48]);
    goto LABEL_11;
  }
  pthread_mutex_lock(this + 2);
  if (*(void *)&this[1].__opaque[48])
  {
    uint64_t v4 = 0;
    do
    {
      if (!TextureDeleteQueue::DeleteRequest::test((TextureDeleteQueue::DeleteRequest *)(*(void *)(*(void *)&this[1].__opaque[16] + 8 * (*(void *)&this[1].__opaque[40] / 0x1EuLL))
                                                                                        + 136
                                                                                        * (*(void *)&this[1].__opaque[40]
                                                                                         % 0x1EuLL))))
        break;
      TextureDeleteQueue::_popFrontRequest((TextureDeleteQueue *)this, (uint64_t)v6);
      pthread_mutex_unlock(this + 2);
      TextureDeleteQueue::DeleteRequest::execute((TextureDeleteQueue::DeleteRequest *)v6);
      uint64_t v4 = (v4 + 1);
      pthread_mutex_lock(this + 2);
    }
    while (*(void *)&this[1].__opaque[48]);
LABEL_11:
    if (!a2) {
      return v4;
    }
    goto LABEL_14;
  }
  uint64_t v4 = 0;
LABEL_14:
  pthread_mutex_unlock(this + 2);
  return v4;
}

void HGTexturePoolHandleImpl::HGTexturePoolHandleImpl(HGTexturePoolHandleImpl *this, HGTextureManager *a2)
{
  HGObject::HGObject(this);
  void *v4 = &unk_1F10D9D78;
  v4[2] = a2;
  unint64_t v5 = *((void *)a2 + 2);
    operator new();
  if (!v6) {
    goto LABEL_15;
  }
  do
  {
    unint64_t v8 = v6[4];
    BOOL v9 = v8 >= v5;
    if (v8 >= v5) {
      unint64_t v10 = v6;
    }
    else {
      unint64_t v10 = v6 + 1;
    }
    if (v9) {
      uint64_t v7 = (uint64_t)v6;
    }
    long long v6 = (void *)*v10;
  }
  while (*v10);
LABEL_15:
  uint64_t v11 = *(void *)(v7 + 40);
  *((void *)this + 3) = v11;
  pthread_mutex_lock((pthread_mutex_t *)(v11 + 16));
}

void sub_1B77D4528(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  _Unwind_Resume(a1);
}

void HGTexturePoolHandleImpl::~HGTexturePoolHandleImpl(HGTexturePoolHandleImpl *this)
{
  *(void *)this = &unk_1F10D9D78;
  pthread_mutex_unlock((pthread_mutex_t *)(*((void *)this + 3) + 16));

  HGObject::~HGObject(this);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10D9D78;
  pthread_mutex_unlock((pthread_mutex_t *)(*((void *)this + 3) + 16));
  HGObject::~HGObject(this);

  HGObject::operator delete(v2);
}

BOOL HGTexturePoolHandleImpl::empty(HGTexturePoolHandleImpl *this)
{
  return *(void *)(*((void *)this + 3) + 120) == 0;
}

uint64_t HGTexturePoolHandleImpl::size(HGTexturePoolHandleImpl *this)
{
  return *(void *)(*((void *)this + 3) + 120);
}

unint64_t HGTexturePoolHandleImpl::begin(HGTexturePoolHandleImpl *this)
{
  return *(void *)(*((void *)this + 3) + 88) + 8 * (*(void *)(*((void *)this + 3) + 112) / 0x2AuLL);
}

unint64_t HGTexturePoolHandleImpl::end(HGTexturePoolHandleImpl *this)
{
  return *(void *)(*((void *)this + 3) + 88)
       + 8 * ((*(void *)(*((void *)this + 3) + 112) + *(void *)(*((void *)this + 3) + 120)) / 0x2AuLL);
}

void **HGTexturePoolHandleImpl::remove(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = a2;
  v4[1] = a3;
  return HGTextureManager::releaseFromPool(*(void *)(a1 + 16), (uint64_t)v4);
}

void **HGTextureManager::releaseFromPool(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
    operator new();
  if (!v5) {
    goto LABEL_15;
  }
  do
  {
    unint64_t v7 = v5[4];
    BOOL v8 = v7 >= v4;
    if (v7 >= v4) {
      BOOL v9 = v5;
    }
    else {
      BOOL v9 = v5 + 1;
    }
    if (v8) {
      uint64_t v6 = (uint64_t)v5;
    }
    unint64_t v5 = (void *)*v9;
  }
  while (*v9);
LABEL_15:
  unint64_t v10 = *(int64x2_t **)(v6 + 40);
  uint64_t GLState = HGGPURenderer::GetGLState(*(HGGPURenderer **)(a1 + 8));
  HGGPURenderer::GetCurrentContext(*(HGGPURenderer **)(a1 + 8), (uint64_t *)&v17);
  HGGLState::SetCurrentContextGuard::SetCurrentContextGuard(v18, GLState, &v17);
  PCSharedCount::PCSharedCount(&v17);
  glDeleteTextures(1, (const GLuint *)(*(void *)(a2 + 8) + 64));
  uint64_t v12 = *(void *)(a2 + 8);
  if (*(unsigned char *)(v12 + 56) == 2)
  {
    unint64_t v13 = *(int *)(v12 + 76);
    unsigned __int8 v14 = (int64x2_t *)((char *)v10 + 152);
LABEL_22:
    v14->i64[0] -= v13;
    goto LABEL_23;
  }
  unint64_t v13 = *(int *)(v12 + 76);
  if (!*(unsigned char *)(v12 + 69))
  {
    unsigned __int8 v14 = v10 + 10;
    goto LABEL_22;
  }
  v10[8] = vsubq_s64(v10[8], vdupq_n_s64(v13));
  if ((*(char *)(v12 + 68) & 0x80000000) == 0)
  {
    unsigned __int8 v14 = v10 + 9;
    goto LABEL_22;
  }
LABEL_23:
  long long v15 = std::deque<HGTextureManager::TextureEntry>::erase(v10 + 5, *(void **)a2, (char *)v12);
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard(v18);
  return v15;
}

void sub_1B77D4898(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, PCSharedCount a9)
{
}

void sub_1B77D48AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard((PCSharedCount *)va);
  _Unwind_Resume(a1);
}

void HGTexturePoolHandleImpl::clear(HGTextureManager **this)
{
}

void HGTextureManager::emptyTexturePool_NoLock(HGTextureManager *this)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v32, "texManager", 2, "emptyTexturePool()");
  unint64_t v2 = *((void *)this + 2);
    operator new();
  if (!v3) {
    goto LABEL_15;
  }
  do
  {
    unint64_t v5 = v3[4];
    BOOL v6 = v5 >= v2;
    if (v5 >= v2) {
      unint64_t v7 = v3;
    }
    else {
      unint64_t v7 = v3 + 1;
    }
    if (v6) {
      uint64_t v4 = (uint64_t)v3;
    }
    uint64_t v3 = (void *)*v7;
  }
  while (*v7);
LABEL_15:
  BOOL v8 = *(int64x2_t **)(v4 + 40);
  for (uint64_t i = v8[7].i64[1]; i; uint64_t i = v8[7].i64[1])
  {
    uint64_t v10 = v8[7].i64[0];
    uint64_t v11 = v8[5].i64[1];
    uint64_t v12 = (long long *)(*(void *)(v11 + 8 * ((i - 1 + v10) / 0x2AuLL)) + 96 * ((i - 1 + v10) % 0x2AuLL));
    long long v13 = v12[4];
    long long v14 = v12[5];
    long long v15 = v12[2];
    long long v30 = v12[3];
    long long v16 = v12[1];
    long long v27 = *v12;
    long long v28 = v16;
    v31[0] = v13;
    v31[1] = v14;
    long long v29 = v15;
    if (BYTE8(v30) == 2)
    {
      uint64_t v17 = SHIDWORD(v31[0]);
      uint64_t v18 = (int64x2_t *)((char *)v8 + 152);
    }
    else
    {
      uint64_t v17 = SHIDWORD(v31[0]);
      if (BYTE5(v31[0]))
      {
        v8[8] = vsubq_s64(v8[8], vdupq_n_s64(SHIDWORD(v31[0])));
        uint64_t v18 = v8 + 9;
        if (SBYTE4(v31[0]) < 0) {
          goto LABEL_24;
        }
      }
      else
      {
        uint64_t v18 = v8 + 10;
      }
    }
    v18->i64[0] -= v17;
LABEL_24:
    uint64_t v19 = v8[6].i64[0];
    uint64_t v21 = v19 - v11;
    BOOL v20 = v21 == 0;
    uint64_t v22 = 42 * (v21 >> 3) - 1;
    v8[7].i64[1] = i - 1;
    if (v20) {
      uint64_t v23 = 0;
    }
    else {
      uint64_t v23 = v22;
    }
    if ((unint64_t)(v23 - (i + v10) + 1) >= 0x54)
    {
      operator delete(*(void **)(v19 - 8));
      v8[6].i64[0] -= 8;
    }
    uint64_t GLState = HGGPURenderer::GetGLState(*((HGGPURenderer **)this + 1));
    HGGPURenderer::GetCurrentContext(*((HGGPURenderer **)this + 1), (uint64_t *)&v25);
    HGGLState::SetCurrentContextGuard::SetCurrentContextGuard(v26, GLState, &v25);
    PCSharedCount::PCSharedCount(&v25);
    glDeleteTextures(1, (const GLuint *)v31);
    HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard(v26);
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v32);
}

void sub_1B77D4B48(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 104));
  _Unwind_Resume(a1);
}

void sub_1B77D4B5C(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 104));
  _Unwind_Resume(a1);
}

void sub_1B77D4B70(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 104));
  _Unwind_Resume(a1);
}

void sub_1B77D4B84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard((PCSharedCount *)va);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v4 - 104));
  _Unwind_Resume(a1);
}

void sub_1B77D4BA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCSharedCount a11)
{
  PCSharedCount::PCSharedCount(&a11);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v11 - 104));
  _Unwind_Resume(a1);
}

void sub_1B77D4BBC(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 104));
  _Unwind_Resume(a1);
}

void sub_1B77D4BD0(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 104));
  _Unwind_Resume(a1);
}

void HGTextureManagerHandleImpl::~HGTextureManagerHandleImpl(HGTextureManagerHandleImpl *this)
{
  HGObject::~HGObject(this);

  HGObject::operator delete(v1);
}

void HGTextureManagerHandleImpl::lockFreePool(HGTextureManager **this@<X0>, HGTexturePoolHandleImpl **a2@<X8>)
{
  uint64_t v4 = (HGTexturePoolHandleImpl *)HGObject::operator new(0x20uLL);
  HGTexturePoolHandleImpl::HGTexturePoolHandleImpl(v4, this[2]);
  *a2 = v4;
}

void sub_1B77D4C54(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGTextureManagerHandleImpl::getNumTextures(uint64_t a1, int a2, uint64_t a3)
{
  return HGTextureManager::getNumTextures(*(unint64_t **)(a1 + 16), a2, a3);
}

uint64_t HGTextureManager::getNumTextures(unint64_t *a1, int a2, uint64_t a3)
{
  int v3 = a3;
  switch(a2)
  {
    case 0:
      if (a3 == 2)
      {
          operator new();
        {
          uint64_t v17 = 0;
        }
        else
        {
          unint64_t v16 = (unint64_t)v14 - v15 - 8;
          if (v16 >= 8)
          {
            uint64_t v22 = 0;
            uint64_t v23 = 0;
            uint64_t v24 = (v16 >> 3) + 1;
            uint64_t v18 = (uint64_t *)(v15 + 8 * (v24 & 0x3FFFFFFFFFFFFFFELL));
            uint64_t v25 = v15 + 8;
            uint64_t v26 = v24 & 0x3FFFFFFFFFFFFFFELL;
            do
            {
              v22 += *(void *)(*(void *)(*(void *)(v25 - 8) + 32) + 120);
              v23 += *(void *)(*(void *)(*(void *)v25 + 32) + 120);
              v25 += 16;
              v26 -= 2;
            }
            while (v26);
            uint64_t v17 = v23 + v22;
            if (v24 == (v24 & 0x3FFFFFFFFFFFFFFELL)) {
              goto LABEL_44;
            }
          }
          else
          {
            uint64_t v17 = 0;
          }
          do
          {
            uint64_t v27 = *v18++;
            v17 += *(void *)(*(void *)(v27 + 32) + 120);
          }
          while (v18 != v14);
        }
LABEL_44:
        return v17;
      }
      if (a3 == 1)
      {
        unint64_t v19 = a1[2];
          operator new();
        {
          uint64_t v17 = 0;
        }
        else
        {
          uint64_t v17 = 0;
          do
          {
            if (*(void *)(*(void *)v20 + 16) == v19) {
              v17 += *(void *)(*(void *)(*(void *)v20 + 32) + 120);
            }
            v20 += 8;
          }
          while (v20 != v21);
        }
        goto LABEL_44;
      }
      if (a3) {
        return 0;
      }
      return *(unsigned int *)(a1[4] + 120);
    case 1:
      if (a3 == 2) {
        return HGTextureManager::_getFreeTotalTextureCount((HGTextureManager *)a1);
      }
      if (a3 != 1) {
        return 0;
      }
      return HGTextureManager::_getFreeTotalTextureCount((HGTextureManager *)a1, a1[2]);
    case 2:
      if (a3 == 2) {
        return HGTextureManager::_getQueuedTotalTextureCount((HGTextureManager *)a1);
      }
      if (a3 != 1) {
        return 0;
      }
      return HGTextureManager::_getQueuedTotalTextureCount((HGTextureManager *)a1, a1[2]);
    case 3:
      if (a3 == 2)
      {
        FreeTotalTextureCount = (HGTextureManager *)HGTextureManager::_getFreeTotalTextureCount((HGTextureManager *)a1);
        return HGTextureManager::_getQueuedTotalTextureCount(FreeTotalTextureCount)
             + FreeTotalTextureCount;
      }
      else if (a3 == 1)
      {
        BOOL v6 = (HGTextureManager *)HGTextureManager::_getFreeTotalTextureCount((HGTextureManager *)a1, a1[2]);
        return HGTextureManager::_getQueuedTotalTextureCount(v6, a1[2]) + v6;
      }
      else
      {
        return 0;
      }
    case 4:
      NumTextures = (HGTextureManager *)HGTextureManager::getNumTextures(a1, 0, a3);
      int v8 = (int)NumTextures;
      if (v3 == 2)
      {
        long long v13 = (HGTextureManager *)HGTextureManager::_getFreeTotalTextureCount(NumTextures);
        int v9 = (int)v13;
        int QueuedTotalTextureCount = HGTextureManager::_getQueuedTotalTextureCount(v13);
      }
      else
      {
        int v9 = 0;
        int QueuedTotalTextureCount = 0;
        if (v3 == 1)
        {
          uint64_t v11 = (HGTextureManager *)HGTextureManager::_getFreeTotalTextureCount(0, a1[2]);
          int v9 = (int)v11;
          int QueuedTotalTextureCount = HGTextureManager::_getQueuedTotalTextureCount(v11, a1[2]);
        }
      }
      return (v9 + QueuedTotalTextureCount + v8);
    default:
      return 0;
  }
}

uint64_t HGTextureManagerHandleImpl::getNumBytes(uint64_t a1, int a2, uint64_t a3)
{
  return HGTextureManager::getNumBytes(*(void *)(a1 + 16), a2, a3);
}

uint64_t HGTextureManager::getNumBytes(uint64_t a1, int a2, uint64_t a3)
{
  int v3 = a3;
  switch(a2)
  {
    case 0:
      if (a3 == 2)
      {
          operator new();
        {
          unint64_t v15 = (unint64_t)v10 - v11 - 8;
          if (v15 >= 8)
          {
            uint64_t v18 = 0;
            uint64_t v19 = 0;
            uint64_t v20 = (v15 >> 3) + 1;
            uint64_t v17 = (uint64_t *)(v11 + 8 * (v20 & 0x3FFFFFFFFFFFFFFELL));
            uint64_t v21 = v11 + 8;
            uint64_t v22 = v20 & 0x3FFFFFFFFFFFFFFELL;
            do
            {
              v18 += *(void *)(*(void *)(*(void *)(v21 - 8) + 32) + 136);
              v19 += *(void *)(*(void *)(*(void *)v21 + 32) + 136);
              v21 += 16;
              v22 -= 2;
            }
            while (v22);
            uint64_t v16 = v19 + v18;
            if (v20 == (v20 & 0x3FFFFFFFFFFFFFFELL)) {
              goto LABEL_48;
            }
          }
          else
          {
            uint64_t v16 = 0;
          }
          do
          {
            uint64_t v23 = *v17++;
            v16 += *(void *)(*(void *)(v23 + 32) + 136);
          }
          while (v17 != v10);
LABEL_48:
          return v16;
        }
      }
      else
      {
        if (a3 != 1)
        {
          if (a3) {
            return 0;
          }
          return *(void *)(*(void *)(a1 + 32) + 136);
        }
        uint64_t v12 = *(void *)(a1 + 16);
          operator new();
        {
          uint64_t v16 = 0;
          do
          {
            if (*(void *)(*(void *)v13 + 16) == v12) {
              v16 += *(void *)(*(void *)(*(void *)v13 + 32) + 136);
            }
            v13 += 8;
          }
          while (v13 != v14);
          goto LABEL_48;
        }
      }
      uint64_t v16 = 0;
      goto LABEL_48;
    case 1:
      if (a3 == 2)
      {
        HGTextureManager::_getFreeTotalTextureUsage(&v24);
      }
      else
      {
        if (a3 != 1) {
          return 0;
        }
        HGTextureManager::_getFreeTotalTextureUsage(*(void *)(a1 + 16), &v24);
      }
      return v25;
    case 2:
      if (a3 == 2)
      {
        HGTextureManager::_getQueuedTotalTextureUsage(&v24);
      }
      else
      {
        if (a3 != 1) {
          return 0;
        }
        HGTextureManager::_getQueuedTotalTextureUsage(*(void *)(a1 + 16), &v24);
      }
      return v25;
    case 3:
      if (a3 == 2)
      {
        HGTextureManager::_getFreeTotalTextureUsage(&v24);
        uint64_t NumBytes = v25;
        HGTextureManager::_getQueuedTotalTextureUsage(&v24);
        uint64_t v7 = v25;
      }
      else if (a3 == 1)
      {
        HGTextureManager::_getFreeTotalTextureUsage(*(void *)(a1 + 16), &v24);
        uint64_t NumBytes = v25;
        HGTextureManager::_getQueuedTotalTextureUsage(*(void *)(a1 + 16), &v24);
        uint64_t v7 = v25;
      }
      else
      {
        uint64_t NumBytes = 0;
        uint64_t v7 = 0;
      }
      return v7 + NumBytes;
    case 4:
      uint64_t NumBytes = HGTextureManager::getNumBytes(a1, 0, a3);
      if (v3 == 2)
      {
        HGTextureManager::_getFreeTotalTextureUsage(&v24);
        uint64_t v8 = v25;
        HGTextureManager::_getQueuedTotalTextureUsage(&v24);
        goto LABEL_25;
      }
      if (v3 == 1)
      {
        HGTextureManager::_getFreeTotalTextureUsage(*(void *)(a1 + 16), &v24);
        uint64_t v8 = v25;
        HGTextureManager::_getQueuedTotalTextureUsage(*(void *)(a1 + 16), &v24);
LABEL_25:
        uint64_t v9 = v25;
        goto LABEL_27;
      }
      uint64_t v8 = 0;
      uint64_t v9 = 0;
LABEL_27:
      uint64_t v7 = v8 + v9;
      return v7 + NumBytes;
    default:
      return 0;
  }
}

uint64_t HGTextureManagerHandleImpl::getTotalTextureMemory(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 16) + 144);
}

void NoPaddingPolicy::~NoPaddingPolicy(NoPaddingPolicy *this)
{
  HGObject::~HGObject(this);

  HGObject::operator delete(v1);
}

uint64_t NoPaddingPolicy::adjustRect(NoPaddingPolicy *this, HGRect a2)
{
  return *(void *)&a2.var0;
}

void NoPoolingPolicy::~NoPoolingPolicy(NoPoolingPolicy *this)
{
  *(void *)this = &unk_1F10D9E38;
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGObject::~HGObject(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10D9E38;
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGObject::~HGObject(this);

  HGObject::operator delete(v3);
}

uint64_t NoPoolingPolicy::preAllocateTexture(NoPoolingPolicy *this)
{
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 2) + 40))(&v2);
  (*(void (**)(uint64_t))(*(void *)v2 + 80))(v2);
  uint64_t result = v2;
  if (v2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  return result;
}

void sub_1B77D55DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(exception_object);
}

BOOL NoPoolingPolicy::waitForQueuedForDeletionTextures(NoPoolingPolicy *this)
{
  return (*(unsigned int (**)(void, uint64_t, uint64_t))(**((void **)this + 2) + 48))(*((void *)this + 2), 2, 1) > 2;
}

void POTPaddingPolicy::POTPaddingPolicy(POTPaddingPolicy *this)
{
  HGObject::HGObject(this);
  void *v1 = &unk_1F10D9F18;
}

void POTPaddingPolicy::~POTPaddingPolicy(POTPaddingPolicy *this)
{
  HGObject::~HGObject(this);

  HGObject::operator delete(v1);
}

uint64_t POTPaddingPolicy::adjustRect(POTPaddingPolicy *this, HGRect a2)
{
  uint64_t v2 = *(void *)&a2.var0;
  int var1 = a2.var1;
  int var3 = a2.var3;
  log2f((float)(a2.var2 - a2.var0));
  log2f((float)(var3 - var1));
  return v2;
}

void BorderPaddingPolicy::BorderPaddingPolicy(BorderPaddingPolicy *this, int a2)
{
  HGObject::HGObject(this);
  *(void *)uint64_t v3 = &unk_1F10D9F58;
  *(_DWORD *)(v3 + 12) = a2;
}

void BorderPaddingPolicy::~BorderPaddingPolicy(BorderPaddingPolicy *this)
{
  HGObject::~HGObject(this);

  HGObject::operator delete(v1);
}

unint64_t BorderPaddingPolicy::adjustRect(BorderPaddingPolicy *this, HGRect a2)
{
  return (a2.var0 - *((_DWORD *)this + 3)) | ((unint64_t)(a2.var1
                                                                                           - *((_DWORD *)this + 3)) << 32);
}

void ClusteredPaddingPolicy::ClusteredPaddingPolicy(ClusteredPaddingPolicy *this)
{
  HGObject::HGObject(this);
  *(void *)uint64_t v1 = &unk_1F10D9F98;
  *(void *)(v1 + 16) = v1 + 16;
  *(void *)(v1 + 24) = v1 + 16;
  *(void *)(v1 + 32) = 0;
  *(void *)(v1 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = 0x100000002;
  *(_DWORD *)(v1 + 48) = 4;
  if (HG_RENDERER_ENV::TEX_PADDING_REMEMBRANCE != -1) {
    *(_DWORD *)(v1 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = HG_RENDERER_ENV::TEX_PADDING_REMEMBRANCE;
  }
  if (HG_RENDERER_ENV::TEX_PADDING_CUSHIONING != -1) {
    *(_DWORD *)(v1 + 44) = HG_RENDERER_ENV::TEX_PADDING_CUSHIONING;
  }
  if (HG_RENDERER_ENV::TEX_PADDING_CLUMPING != -1) {
    *(_DWORD *)(v1 + 48) = HG_RENDERER_ENV::TEX_PADDING_CLUMPING;
  }
}

void ClusteredPaddingPolicy::~ClusteredPaddingPolicy(ClusteredPaddingPolicy *this)
{
  *(void *)this = &unk_1F10D9F98;
  if (*((void *)this + 4))
  {
    uint64_t v2 = (char *)this + 16;
    uint64_t v4 = *((void *)this + 2);
    uint64_t v3 = (char *)*((void *)this + 3);
    uint64_t v5 = *(void *)v3;
    *(void *)(v5 + 8) = *(void *)(v4 + 8);
    **(void **)(v4 + 8) = v5;
    *((void *)this + 4) = 0;
    if (v3 != (char *)this + 16)
    {
      do
      {
        BOOL v6 = (char *)*((void *)v3 + 1);
        operator delete(v3);
        uint64_t v3 = v6;
      }
      while (v6 != v2);
    }
  }

  HGObject::~HGObject(this);
}

{
  char *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  void *v7;
  uint64_t vars8;

  *(void *)this = &unk_1F10D9F98;
  if (*((void *)this + 4))
  {
    uint64_t v2 = (char *)this + 16;
    uint64_t v4 = *((void *)this + 2);
    uint64_t v3 = (char *)*((void *)this + 3);
    uint64_t v5 = *(void *)v3;
    *(void *)(v5 + 8) = *(void *)(v4 + 8);
    **(void **)(v4 + 8) = v5;
    *((void *)this + 4) = 0;
    if (v3 != (char *)this + 16)
    {
      do
      {
        BOOL v6 = (char *)*((void *)v3 + 1);
        operator delete(v3);
        uint64_t v3 = v6;
      }
      while (v6 != v2);
    }
  }
  HGObject::~HGObject(this);

  HGObject::operator delete(v7);
}

uint64_t ClusteredPaddingPolicy::adjustRect(ClusteredPaddingPolicy *this, HGRect a2)
{
  uint64_t v2 = *(void *)&a2.var0;
  int var3 = a2.var3;
  unsigned int v5 = *((_DWORD *)this + 11);
  if (v5 >= 2)
  {
    a2.int var2 = v5 + v5 * ((~a2.var0 + a2.var2) / v5) + a2.var0;
    int var3 = v5 + v5 * ((~a2.var1 + a2.var3) / v5) + a2.var1;
  }
  unint64_t v6 = *((unsigned int *)this + 12);
  if (v6 >= 2)
  {
    uint64_t v7 = (char *)this + 16;
    unint64_t v8 = (a2.var2 - a2.var0);
    unint64_t v9 = (var3 - a2.var1);
    uint64_t v10 = (uint64_t *)*((void *)this + 3);
    if (v10 == (uint64_t *)((char *)this + 16)) {
      goto LABEL_24;
    }
    uint64_t v11 = (uint64_t *)*((void *)this + 3);
    while (1)
    {
      unint64_t v12 = v11[2];
      unint64_t v13 = v11[3];
      unint64_t v14 = v8 - v12;
      if (v12 >= v8) {
        unint64_t v14 = v12 - v8;
      }
      unint64_t v15 = v9 - v13;
      if (v13 >= v9) {
        unint64_t v15 = v13 - v9;
      }
      if (v14 < v6 && v15 < v6) {
        break;
      }
      uint64_t v11 = (uint64_t *)v11[1];
      if (v11 == (uint64_t *)v7) {
        goto LABEL_24;
      }
    }
    if (v12 > v8) {
      unint64_t v8 = v11[2];
    }
    if (v13 > v9) {
      unint64_t v9 = v11[3];
    }
    if (v11 == (uint64_t *)v7)
    {
LABEL_24:
      uint64_t v21 = operator new(0x20uLL);
      v21[2] = v8;
      void v21[3] = v9;
      void *v21 = v7;
      v21[1] = v10;
      uint64_t *v10 = (uint64_t)v21;
      unint64_t v22 = *((void *)this + 4) + 1;
      *((void *)this + 3) = v21;
      *((void *)this + 4) = v22;
      unint64_t v23 = *((unsigned int *)this + 10);
      if (v22 > v23) {
        std::list<ClusteredPaddingPolicy::Size>::resize((void *)this + 2, v23);
      }
    }
    else if (v11 == v10)
    {
      v10[2] = v8;
      v10[3] = v9;
    }
    else
    {
      uint64_t v17 = *v11;
      *(void *)(v17 + 8) = v11[1];
      *(void *)v11[1] = v17;
      --*((void *)this + 4);
      operator delete(v11);
      uint64_t v18 = operator new(0x20uLL);
      v18[2] = v8;
      PCSharedCount v18[3] = v9;
      uint64_t v19 = (void *)*((void *)this + 3);
      uint64_t v20 = *((void *)this + 4);
      *uint64_t v18 = v7;
      v18[1] = v19;
      *uint64_t v19 = v18;
      *((void *)this + 3) = v18;
      *((void *)this + 4) = v20 + 1;
    }
  }
  return v2;
}

void *std::list<ClusteredPaddingPolicy::Size>::resize(void *result, unint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = result[2];
  uint64_t v5 = v4 - a2;
  if (v4 > a2)
  {
    if (a2 <= v4 >> 1)
    {
      uint64_t result = (void *)result[1];
      if ((a2 & 0x8000000000000000) != 0)
      {
        uint64_t result = (void *)*result;
        if (result == v3) {
          return result;
        }
LABEL_20:
        uint64_t v13 = *v3;
        uint64_t v14 = *result;
        *(void *)(v14 + 8) = *(void *)(*v3 + 8);
        **(void **)(v13 + 8) = v14;
        do
        {
          unint64_t v15 = (void *)result[1];
          --v3[2];
          operator delete(result);
          uint64_t result = v15;
        }
        while (v15 != v3);
        return result;
      }
      if (a2)
      {
        unint64_t v11 = a2 + 1;
        do
        {
          uint64_t result = (void *)result[1];
          --v11;
        }
        while (v11 > 1);
      }
    }
    else if (v5 < 1)
    {
      unint64_t v12 = a2 - v4 + 1;
      do
      {
        uint64_t result = (void *)result[1];
        --v12;
      }
      while (v12 > 1);
    }
    else
    {
      do
      {
        uint64_t result = (void *)*result;
        --v5;
      }
      while (v5);
    }
    if (result == v3) {
      return result;
    }
    goto LABEL_20;
  }
  if (v4 < a2)
  {
    uint64_t result = operator new(0x20uLL);
    unint64_t v6 = result;
    *(_OWORD *)uint64_t result = 0u;
    *((_OWORD *)result + 1) = 0u;
    if (~v4 + a2)
    {
      uint64_t v7 = a2 - v4;
      uint64_t v8 = v5 + 1;
      unint64_t v9 = result;
      do
      {
        uint64_t result = operator new(0x20uLL);
        *uint64_t result = v9;
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        v9[1] = result;
        unint64_t v9 = result;
      }
      while (!__CFADD__(v8++, 1));
    }
    else
    {
      uint64_t v7 = 1;
    }
    result[1] = v3;
    uint64_t v16 = *v3;
    *unint64_t v6 = *v3;
    *(void *)(v16 + 8) = v6;
    void *v3 = result;
    v3[2] = v7 + v4;
  }
  return result;
}

void sub_1B77D5CB8(void *a1)
{
  __cxa_begin_catch(a1);
  do
  {
    uint64_t v2 = (void *)*v1;
    operator delete(v1);
    uint64_t v1 = v2;
  }
  while (v2);
  __cxa_rethrow();
}

void sub_1B77D5CD8(_Unwind_Exception *a1)
{
}

void SimplePoolingPolicy::~SimplePoolingPolicy(SimplePoolingPolicy *this)
{
  *(void *)this = &unk_1F10D9E38;
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGObject::~HGObject(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10D9E38;
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGObject::~HGObject(this);

  HGObject::operator delete(v3);
}

uint64_t SimplePoolingPolicy::preAllocateTexture(SimplePoolingPolicy *this)
{
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 2) + 40))(&v9);
  while (((*(uint64_t (**)(uint64_t))(*(void *)v9 + 40))(v9) & 1) == 0
       && (unint64_t)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)this + 2) + 56))(*((void *)this + 2), 3, 1) > *((void *)this + 3))
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 56))(v9);
    uint64_t v6 = v2;
    unsigned __int8 v7 = atomic_load(HGLogger::_enabled);
    if (v7) {
      HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"pool too large! deleting old texture %d\n", v3, v4, *(unsigned int *)(v2 + 64));
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 72))(v9, v5, v6);
  }
  uint64_t result = v9;
  if (v9) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v9 + 24))(v9);
  }
  return result;
}

void sub_1B77D5F8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(exception_object);
}

BOOL SimplePoolingPolicy::waitForQueuedForDeletionTextures(SimplePoolingPolicy *this)
{
  return (float)(*((float *)this + 8) * (float)*((unint64_t *)this + 3)) < (float)(unint64_t)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)this + 2) + 56))(*((void *)this + 2), 2, 1);
}

void MultiGPUPoolingPolicy::MultiGPUPoolingPolicy(MultiGPUPoolingPolicy *this)
{
  HGObject::HGObject(this);
  *(void *)(v1 + 16) = 0;
  *(void *)uint64_t v1 = &unk_1F10DA028;
  *(_OWORD *)(v1 + 24) = xmmword_1B83470B0;
  *(void *)(v1 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = 1056964608;
  if (HG_RENDERER_ENV::MAX_TEXTURE_AGE_MS != -1)
  {
    if (HG_RENDERER_ENV::MAX_TEXTURE_AGE_MS) {
      float v2 = (float)HG_RENDERER_ENV::MAX_TEXTURE_AGE_MS;
    }
    else {
      float v2 = 3.4028e38;
    }
    *(float *)(v1 + 24) = v2;
  }
  if (HG_RENDERER_ENV::MAX_TEXTURE_POOL_SIZE_PERCENT != -1) {
    *(float *)(v1 + 28) = (float)HG_RENDERER_ENV::MAX_TEXTURE_POOL_SIZE_PERCENT * 0.01;
  }
  if (HG_RENDERER_ENV::MAX_TEXTURE_QUEUE_SIZE_PERCENT != -1) {
    *(float *)(v1 + 32) = (float)HG_RENDERER_ENV::MAX_TEXTURE_QUEUE_SIZE_PERCENT * 0.01;
  }
  if (HG_RENDERER_ENV::MAX_TEXTURE_UNUSED_SIZE_PERCENT != -1) {
    *(float *)(v1 + 36) = (float)HG_RENDERER_ENV::MAX_TEXTURE_UNUSED_SIZE_PERCENT * 0.01;
  }
  if (HG_RENDERER_ENV::MAX_TEXTURE_TOTAL_SIZE_PERCENT != -1) {
    *(float *)(v1 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = (float)HG_RENDERER_ENV::MAX_TEXTURE_TOTAL_SIZE_PERCENT * 0.01;
  }
  if (HG_RENDERER_ENV::TEXTURE_POOL_STRATEGY != -1) {
    *(_DWORD *)(v1 + 44) = HG_RENDERER_ENV::TEXTURE_POOL_STRATEGY;
  }
}

void MultiGPUPoolingPolicy::~MultiGPUPoolingPolicy(MultiGPUPoolingPolicy *this)
{
  *(void *)this = &unk_1F10D9E38;
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGObject::~HGObject(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10D9E38;
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  HGObject::~HGObject(this);

  HGObject::operator delete(v3);
}

uint64_t MultiGPUPoolingPolicy::setMaxPoolSizeRatio(uint64_t this, float a2)
{
  if (HG_RENDERER_ENV::MAX_TEXTURE_POOL_SIZE_PERCENT == -1) {
    *(float *)(this + 28) = a2;
  }
  return this;
}

uint64_t MultiGPUPoolingPolicy::setMaxQueueSizeRatio(uint64_t this, float a2)
{
  if (HG_RENDERER_ENV::MAX_TEXTURE_QUEUE_SIZE_PERCENT == -1) {
    *(float *)(this + 32) = a2;
  }
  return this;
}

uint64_t MultiGPUPoolingPolicy::setMaxUnusedSizeRatio(uint64_t this, float a2)
{
  if (HG_RENDERER_ENV::MAX_TEXTURE_UNUSED_SIZE_PERCENT == -1) {
    *(float *)(this + 36) = a2;
  }
  return this;
}

uint64_t MultiGPUPoolingPolicy::setMaxTotalSizeRatio(uint64_t this, float a2)
{
  if (HG_RENDERER_ENV::MAX_TEXTURE_TOTAL_SIZE_PERCENT == -1) {
    *(float *)(this + 4CVOpenGLESTextureCacheFlush(this[3], 0) = a2;
  }
  return this;
}

void MultiGPUPoolingPolicy::preAllocateTexture(MultiGPUPoolingPolicy *this)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v25, "poolPerf", 1, "preAllocateTexture()");
  uint64_t v2 = (*(void *(**)(uint64_t *__return_ptr))(**((void **)this + 2) + 40))(&v24);
  int v6 = *((_DWORD *)this + 11);
  if ((v6 - 3) <= 1)
  {
    uint64_t v7 = v24;
    uint64_t v23 = v24;
    if (v24)
    {
      uint64_t v2 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v24 + 16))(v24);
      int v6 = *((_DWORD *)this + 11);
    }
    uint64_t v2 = (void *)MultiGPUPoolingPolicy::_removeAllIf((uint64_t)v2, &v23, v6 == 3, v6 == 4);
    if (v7) {
      uint64_t v2 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v7 + 24))(v7);
    }
  }
  uint64_t v8 = v24;
  uint64_t v22 = v24;
  if (v24) {
    uint64_t v2 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v24 + 16))(v24);
  }
  MultiGPUPoolingPolicy::_removeOldestByAge(*((float *)this + 6), (uint64_t)v2, &v22, v3, v4, v5);
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
  }
  if ((*((_DWORD *)this + 11) - 1) <= 1)
  {
    do
    {
      uint64_t v13 = v24;
      uint64_t v21 = v24;
      if (v24) {
        (*(void (**)(uint64_t))(*(void *)v24 + 16))(v24);
      }
      uint64_t v14 = MultiGPUPoolingPolicy::_needsCleaning((uint64_t)this, (uint64_t)&v21);
      int v15 = v14;
      if (v13) {
        uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 24))(v13);
      }
      if (!v15) {
        break;
      }
      uint64_t v16 = v24;
      uint64_t v20 = v24;
      if (v24) {
        uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)v24 + 16))(v24);
      }
      int v17 = MultiGPUPoolingPolicy::_removeOldestIf(v14, &v20, *((_DWORD *)this + 11) == 1, *((_DWORD *)this + 11) == 2);
      if (v16) {
        (*(void (**)(uint64_t))(*(void *)v16 + 24))(v16);
      }
    }
    while (v17);
  }
  while (1)
  {
    uint64_t v9 = v24;
    uint64_t v19 = v24;
    if (v24) {
      (*(void (**)(uint64_t))(*(void *)v24 + 16))(v24);
    }
    uint64_t v10 = MultiGPUPoolingPolicy::_needsCleaning((uint64_t)this, (uint64_t)&v19);
    int v11 = v10;
    if (v9) {
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 24))(v9);
    }
    uint64_t v12 = v24;
    if (!v11) {
      break;
    }
    uint64_t v18 = v24;
    if (v24) {
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v24 + 16))(v24);
    }
    MultiGPUPoolingPolicy::_removeOldestIf(v10, &v18, 1, 1);
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
    }
  }
  if (v24) {
    (*(void (**)(uint64_t))(*(void *)v24 + 24))(v24);
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v25);
}

void sub_1B77D669C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 24))(v16);
  }
  if (a16) {
    (*(void (**)(uint64_t))(*(void *)a16 + 24))(a16);
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v17 - 48));
  _Unwind_Resume(a1);
}

uint64_t MultiGPUPoolingPolicy::_removeAllIf(uint64_t a1, void *a2, int a3, char a4)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v34, "poolPerf", 1, "_removeAllIf()");
  uint64_t v8 = (void *)(*(uint64_t (**)(void))(*(void *)*a2 + 56))();
  uint64_t v9 = v7;
  if (a3)
  {
    if (a4)
    {
      for (uint64_t i = 0; ; uint64_t i = (i + 1))
      {
        (*(void (**)(void))(*(void *)*a2 + 64))();
        if (v9 == v13) {
          break;
        }
        unsigned __int8 v14 = atomic_load(HGLogger::_enabled);
        if (v14) {
          HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"deleting texture %d (all)\n", v11, v12, *(unsigned int *)(v9 + 64));
        }
        uint64_t v8 = (void *)(*(uint64_t (**)(void, void *, uint64_t))(*(void *)*a2 + 72))(*a2, v8, v9);
        uint64_t v9 = v15;
      }
    }
    else
    {
      uint64_t i = 0;
      uint64_t v26 = v7;
      while (1)
      {
        (*(void (**)(void))(*(void *)*a2 + 64))();
        if (v26 == v29) {
          break;
        }
        if (*(unsigned char *)(v26 + 57))
        {
          unsigned __int8 v31 = atomic_load(HGLogger::_enabled);
          if (v31) {
            HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"deleting texture %d (all)\n", v27, v28, *(unsigned int *)(v26 + 64));
          }
          uint64_t v8 = (void *)(*(uint64_t (**)(void, void *, uint64_t))(*(void *)*a2 + 72))(*a2, v8, v9);
          uint64_t v9 = v32;
          uint64_t i = (i + 1);
          uint64_t v26 = v32;
        }
        else
        {
          v9 += 96;
          v26 += 96;
          if (*v8 + 4032 == v9)
          {
            uint64_t v30 = v8[1];
            ++v8;
            uint64_t v9 = v30;
            uint64_t v26 = v30;
          }
        }
      }
    }
  }
  else if (a4)
  {
    uint64_t i = 0;
LABEL_10:
    uint64_t v16 = v9;
    while (1)
    {
      (*(void (**)(void))(*(void *)*a2 + 64))();
      if (v16 == v19) {
        break;
      }
      if (!*(unsigned char *)(v16 + 57))
      {
        unsigned __int8 v21 = atomic_load(HGLogger::_enabled);
        if (v21) {
          HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"deleting texture %d (all)\n", v17, v18, *(unsigned int *)(v16 + 64));
        }
        uint64_t v8 = (void *)(*(uint64_t (**)(void, void *, uint64_t))(*(void *)*a2 + 72))(*a2, v8, v9);
        uint64_t v9 = v22;
        uint64_t i = (i + 1);
        goto LABEL_10;
      }
      v9 += 96;
      v16 += 96;
      if (*v8 + 4032 == v9)
      {
        uint64_t v20 = v8[1];
        ++v8;
        uint64_t v9 = v20;
        goto LABEL_10;
      }
    }
  }
  else
  {
LABEL_18:
    uint64_t v23 = v9 - 4032;
    while (1)
    {
      (*(void (**)(void))(*(void *)*a2 + 64))();
      if (v9 == v24) {
        break;
      }
      v9 += 96;
      v23 += 96;
      if (*v8 == v23)
      {
        uint64_t v25 = v8[1];
        ++v8;
        uint64_t v9 = v25;
        goto LABEL_18;
      }
    }
    uint64_t i = 0;
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v34);
  return i;
}

void sub_1B77D6BC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77D6BDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77D6BF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77D6C04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77D6C18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77D6C2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77D6C40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77D6C54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77D6C68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77D6C7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77D6C90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t MultiGPUPoolingPolicy::_removeOldestByAge(float a1, uint64_t a2, void *a3, uint64_t a4, const char *a5, char *a6)
{
  if (a1 >= 3.4028e38)
  {
    unsigned __int8 v19 = atomic_load(HGLogger::_enabled);
    if (v19) {
      HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"no limits. return.\n", a5, a6);
    }
    return 0;
  }
  else
  {
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v21, "poolPerf", 1, "_removeOldestByAge()");
    uint64_t v8 = HGGetTBC();
    unint64_t v9 = HGGetTBCFrequency();
    uint64_t v10 = (*(uint64_t (**)(void))(*(void *)*a3 + 56))();
    uint64_t v12 = v11;
    for (uint64_t i = 0; ; uint64_t i = (i + 1))
    {
      (*(void (**)(void))(*(void *)*a3 + 64))();
      if (v12 == v16
        || *(void *)(v12 + 88) >= (unint64_t)(float)((float)v8 + (float)((float)((float)v9 * a1) / -1000.0)))
      {
        break;
      }
      unsigned __int8 v17 = atomic_load(HGLogger::_enabled);
      if (v17) {
        HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"deleting texture %d (for age)\n", v14, v15, *(unsigned int *)(v12 + 64));
      }
      uint64_t v10 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)*a3 + 72))(*a3, v10, v12);
      uint64_t v12 = v18;
    }
    HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v21);
  }
  return i;
}

void sub_1B77D6E70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77D6E84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77D6E98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77D6EAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77D6EC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

BOOL MultiGPUPoolingPolicy::_needsCleaning(uint64_t a1, uint64_t a2)
{
  if ((*(uint64_t (**)(void))(**(void **)a2 + 40))()) {
    return 0;
  }
  uint64_t v3 = 1;
  float v4 = (float)(unint64_t)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 16) + 64))(*(void *)(a1 + 16), 1);
  unint64_t v5 = (unint64_t)(float)(*(float *)(a1 + 28) * v4);
  float v7 = *(float *)(a1 + 36);
  float v6 = *(float *)(a1 + 40);
  if ((*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 16) + 56))(*(void *)(a1 + 16), 1, 1) <= v5&& (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 16) + 56))(*(void *)(a1 + 16), 3, 1) <= (unint64_t)(float)(v7 * v4))
  {
    return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 16) + 56))(*(void *)(a1 + 16), 4, 1) > (unint64_t)(float)(v6 * v4);
  }
  return v3;
}

uint64_t MultiGPUPoolingPolicy::_removeOldestIf(uint64_t a1, void *a2, int a3, char a4)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v25, "poolPerf", 1, "_removeOldestIf()");
  float v7 = (void *)(*(uint64_t (**)(void))(*(void *)*a2 + 56))();
  uint64_t v9 = v8;
  if (!a3)
  {
    if (a4)
    {
LABEL_8:
      uint64_t v15 = v9 - 4032;
      while (1)
      {
        (*(void (**)(void))(*(void *)*a2 + 64))();
        if (v9 == v16) {
          break;
        }
        if (!*(unsigned char *)(v9 + 57)) {
          goto LABEL_4;
        }
        v9 += 96;
        v15 += 96;
        if (*v7 == v15)
        {
          uint64_t v17 = v7[1];
          ++v7;
          uint64_t v9 = v17;
          goto LABEL_8;
        }
      }
    }
    else
    {
LABEL_13:
      uint64_t v18 = v9 - 4032;
      while (1)
      {
        (*(void (**)(void))(*(void *)*a2 + 64))();
        if (v9 == v19) {
          break;
        }
        v9 += 96;
        v18 += 96;
        if (*v7 == v18)
        {
          uint64_t v20 = v7[1];
          ++v7;
          uint64_t v9 = v20;
          goto LABEL_13;
        }
      }
    }
    goto LABEL_22;
  }
  if ((a4 & 1) == 0)
  {
LABEL_17:
    uint64_t v21 = v9 - 4032;
    while (1)
    {
      (*(void (**)(void))(*(void *)*a2 + 64))();
      if (v9 == v22) {
        goto LABEL_22;
      }
      if (*(unsigned char *)(v9 + 57)) {
        goto LABEL_4;
      }
      v9 += 96;
      v21 += 96;
      if (*v7 == v21)
      {
        uint64_t v23 = v7[1];
        ++v7;
        uint64_t v9 = v23;
        goto LABEL_17;
      }
    }
  }
  (*(void (**)(void))(*(void *)*a2 + 64))();
  if (v9 == v12)
  {
LABEL_22:
    uint64_t v14 = 0;
    goto LABEL_23;
  }
LABEL_4:
  unsigned __int8 v13 = atomic_load(HGLogger::_enabled);
  if (v13) {
    HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"deleting texture %d (for reason)\n", v10, v11, *(unsigned int *)(v9 + 64));
  }
  (*(void (**)(void, void *, uint64_t))(*(void *)*a2 + 72))(*a2, v7, v9);
  uint64_t v14 = 1;
LABEL_23:
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v25);
  return v14;
}

void sub_1B77D7280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77D7294(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77D72A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77D72BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77D72D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t MultiGPUPoolingPolicy::renderEnd(MultiGPUPoolingPolicy *this)
{
  uint64_t v2 = (*(void *(**)(uint64_t *__return_ptr))(**((void **)this + 2) + 40))(&v13);
  uint64_t v6 = v13;
  uint64_t v12 = v13;
  if (v13) {
    uint64_t v2 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v13 + 16))(v13);
  }
  uint64_t v7 = MultiGPUPoolingPolicy::_removeOldestByAge(*((float *)this + 6), (uint64_t)v2, &v12, v3, v4, v5);
  if (v6) {
    uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 24))(v6);
  }
  int v8 = *((_DWORD *)this + 11);
  if ((v8 - 3) <= 1)
  {
    uint64_t v9 = v13;
    uint64_t v11 = v13;
    if (v13)
    {
      uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 16))(v13);
      int v8 = *((_DWORD *)this + 11);
    }
    MultiGPUPoolingPolicy::_removeAllIf(v7, &v11, v8 == 3, v8 == 4);
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
    }
  }
  uint64_t result = v13;
  if (v13) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v13 + 24))(v13);
  }
  return result;
}

void sub_1B77D7460(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
  }
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 24))(a12);
  }
  _Unwind_Resume(exception_object);
}

BOOL MultiGPUPoolingPolicy::waitForQueuedForDeletionTextures(MultiGPUPoolingPolicy *this)
{
  unint64_t v2 = (unint64_t)(float)(*((float *)this + 8)
                               * (float)(unint64_t)(*(uint64_t (**)(void, uint64_t))(**((void **)this + 2) + 64))(*((void *)this + 2), 1));
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)this + 2) + 56))(*((void *)this + 2), 2, 1) > v2;
}

double HGTextureManager::TextureInfo::TextureInfo(HGTextureManager::TextureInfo *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  *(_DWORD *)this = a2;
  *((_DWORD *)this + 1) = a3;
  *((_DWORD *)this + 2) = a4;
  *((_DWORD *)this + 3) = a5;
  *((_DWORD *)this + 4) = a6;
  *((_DWORD *)this + 5) = a7;
  double result = 0.0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 4CVOpenGLESTextureCacheFlush(this[3], 0) = 0u;
  *((_WORD *)this + 28) = 0;
  return result;
}

void HGTextureManager::TextureEntry::log(HGTextureManager::TextureEntry *this, const char *a2, char *a3)
{
  unsigned __int8 v3 = atomic_load(HGLogger::_enabled);
  if (v3)
  {
    unsigned __int8 v4 = atomic_load(HGLogger::_enabled);
    if (v4)
    {
      uint64_t v7 = "?";
      if (*(_DWORD *)this == 3553) {
        uint64_t v7 = "2";
      }
      long long v34 = v7;
      int v8 = *((_DWORD *)this + 20);
      uint64_t v9 = "Q";
      if (v8 == 1) {
        uint64_t v9 = "F";
      }
      if (v8) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = "U";
      }
      unsigned __int8 v31 = v10;
      uint64_t v32 = *((unsigned int *)this + 1);
      uint64_t v33 = *((unsigned int *)this + 16);
      uint64_t v29 = *((unsigned int *)this + 2);
      uint64_t v30 = *((char *)this + 68);
      uint64_t v11 = HGFormatUtils::GLPixelFormatToString((HGFormatUtils *)*((unsigned int *)this + 4), a2, a3);
      uint64_t v14 = HGFormatUtils::GLPixelTypeToString((HGFormatUtils *)*((unsigned int *)this + 5), v12, v13);
      double v15 = (float)((float)*((int *)this + 19) * 0.00000095367);
      if (*((unsigned char *)this + 69)) {
        uint64_t v16 = "Y";
      }
      else {
        uint64_t v16 = "N";
      }
      if (*((unsigned char *)this + 57)) {
        uint64_t v17 = "Y";
      }
      else {
        uint64_t v17 = "N";
      }
      int v18 = *((unsigned __int8 *)this + 56);
      uint64_t v19 = "P";
      if (v18 == 2) {
        uint64_t v19 = "S";
      }
      if (v18 == 1) {
        uint64_t v20 = "C";
      }
      else {
        uint64_t v20 = v19;
      }
      long long v28 = *(_OWORD *)((char *)this + 24);
      uint64_t v21 = *((void *)this + 5);
      uint64_t v22 = *((void *)this + 6);
      uint64_t v23 = *((unsigned int *)this + 18);
      float v24 = (float)(HGGetTBC() - *((void *)this + 11)) * 1000.0;
      unint64_t v25 = HGGetTBCFrequency();
      HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"id %3d [%s] (%s) unit %2d : %4d x %4d x (%20s, %20s), (%4.1f mb), owned: %s, used: %2d, cs: %s, hint: %s, ptr: %p, %zu, range: %p, %zu, age: %6.1f ms\n", v26, v27, v33, v34, v31, v30, v32, v29, v11, v14, *(void *)&v15, v16, v23, v17, v20,
        v28,
        v21,
        v22,
        (float)(v24 / (float)v25));
    }
  }
}

void HGTextureManager::TextureUsage::logSummary(HGTextureManager::TextureUsage *this, char *a2, int a3, const char *a4, char *a5)
{
  unsigned __int8 v7 = atomic_load(HGLogger::_enabled);
  if (a3)
  {
    if (v7)
    {
      HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"\n", a4, a5);
      unsigned __int8 v16 = atomic_load(HGLogger::_enabled);
      if ((v16 & 1) == 0)
      {
LABEL_4:
        unsigned __int8 v9 = atomic_load(HGLogger::_enabled);
        if ((v9 & 1) == 0) {
          goto LABEL_5;
        }
        goto LABEL_16;
      }
    }
    else
    {
      unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
      if ((v8 & 1) == 0) {
        goto LABEL_4;
      }
    }
    HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"  total   : %3.1f mb\n", a4, a5, (float)((float)*(unint64_t *)this * 0.00000095367));
    unsigned __int8 v17 = atomic_load(HGLogger::_enabled);
    if ((v17 & 1) == 0)
    {
LABEL_5:
      unsigned __int8 v10 = atomic_load(HGLogger::_enabled);
      if ((v10 & 1) == 0) {
        goto LABEL_6;
      }
      goto LABEL_17;
    }
LABEL_16:
    HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"  used    : %3.1f mb\n", a4, a5, (float)((float)*((unint64_t *)this + 1) * 0.00000095367));
    unsigned __int8 v18 = atomic_load(HGLogger::_enabled);
    if ((v18 & 1) == 0)
    {
LABEL_6:
      unsigned __int8 v11 = atomic_load(HGLogger::_enabled);
      if ((v11 & 1) == 0) {
        goto LABEL_7;
      }
      goto LABEL_18;
    }
LABEL_17:
    HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"  active  : %3.1f mb\n", a4, a5, (float)((float)*((unint64_t *)this + 2) * 0.00000095367));
    unsigned __int8 v19 = atomic_load(HGLogger::_enabled);
    if ((v19 & 1) == 0)
    {
LABEL_7:
      unsigned __int8 v12 = atomic_load(HGLogger::_enabled);
      if ((v12 & 1) == 0) {
        goto LABEL_8;
      }
      goto LABEL_19;
    }
LABEL_18:
    HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"  shared  : %3.1f mb\n", a4, a5, (float)((float)*((unint64_t *)this + 3) * 0.00000095367));
    unsigned __int8 v20 = atomic_load(HGLogger::_enabled);
    if ((v20 & 1) == 0)
    {
LABEL_8:
      unsigned __int8 v13 = atomic_load(HGLogger::_enabled);
      if ((v13 & 1) == 0) {
        goto LABEL_9;
      }
      goto LABEL_20;
    }
LABEL_19:
    HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"  unowned : %3.1f mb\n", a4, a5, (float)((float)*((unint64_t *)this + 4) * 0.00000095367));
    unsigned __int8 v21 = atomic_load(HGLogger::_enabled);
    if ((v21 & 1) == 0)
    {
LABEL_9:
      unsigned __int8 v14 = atomic_load(HGLogger::_enabled);
      if ((v14 & 1) == 0) {
        goto LABEL_10;
      }
      goto LABEL_21;
    }
LABEL_20:
    HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"  free    : %3.1f mb\n", a4, a5, (float)((float)*((unint64_t *)this + 5) * 0.00000095367));
    unsigned __int8 v22 = atomic_load(HGLogger::_enabled);
    if ((v22 & 1) == 0)
    {
LABEL_10:
      unsigned __int8 v15 = atomic_load(HGLogger::_enabled);
      if ((v15 & 1) == 0) {
        return;
      }
LABEL_22:
      HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"\n", a4, a5);
      return;
    }
LABEL_21:
    HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"  queued  : %3.1f mb\n", a4, a5, (float)((float)*((unint64_t *)this + 6) * 0.00000095367));
    unsigned __int8 v23 = atomic_load(HGLogger::_enabled);
    if ((v23 & 1) == 0) {
      return;
    }
    goto LABEL_22;
  }
  if (v7) {
    HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"total : %4.1f mb  |  used : %4.1f mb  |  active : %4.1f mb  |  shared : %4.1f mb  |  unowned : %4.1f mb  |  free : %4.1f mb  |  queued : %4.1f mb\n", a4, a5, (float)((float)*(unint64_t *)this * 0.00000095367), (float)((float)*((unint64_t *)this + 1) * 0.00000095367), (float)((float)*((unint64_t *)this + 2) * 0.00000095367), (float)((float)*((unint64_t *)this + 3) * 0.00000095367), (float)((float)*((unint64_t *)this + 4) * 0.00000095367), (float)((float)*((unint64_t *)this + 5) * 0.00000095367), (float)((float)*((unint64_t *)this + 6) * 0.00000095367));
  }
}

void HGTextureManager::TexturePool::~TexturePool(HGTextureManager::TexturePool *this)
{
  *(void *)this = &unk_1F10DA078;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 16));
  std::deque<HGTextureManager::TextureEntry>::~deque[abi:ne180100]((uint64_t)this + 80);

  HGObject::~HGObject(this);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F10DA078;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 16));
  std::deque<HGTextureManager::TextureEntry>::~deque[abi:ne180100]((uint64_t)this + 80);
  HGObject::~HGObject(this);

  HGObject::operator delete(v2);
}

BOOL HGTextureManager::PostTextureDeleteEventList::hasEvent(HGTextureManager::PostTextureDeleteEventList *this)
{
  return *((void *)this + 8) != *((void *)this + 9);
}

uint64_t HGTextureManager::PostTextureDeleteEventList::popEvent(HGTextureManager::PostTextureDeleteEventList *this)
{
  uint64_t v1 = *((void *)this + 9);
  uint64_t v2 = *(void *)(v1 - 8);
  *((void *)this + 9) = v1 - 8;
  return v2;
}

void RenderbufferCache::~RenderbufferCache(RenderbufferCache *this)
{
  uint64_t v2 = *(void **)this;
  if (v2)
  {
    *((void *)this + 1) = v2;
    operator delete(v2);
  }
}

uint64_t RenderbufferCache::createRenderbuffer(RenderbufferCache *this, unsigned int a2, uint64_t a3)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v28, "renderbuffer", 1, "createRenderbuffer()");
  uint64_t v7 = *(void *)this;
  uint64_t v8 = *((void *)this + 1);
  if (*(void *)this != v8)
  {
    while (*(_DWORD *)v7
         || *(_DWORD *)(v7 + 4) != a3
         || *(_DWORD *)(v7 + 8)
         || *(_DWORD *)(v7 + 12)
         || *(unsigned char *)(v7 + 20))
    {
      v7 += 24;
      if (v7 == v8) {
        goto LABEL_12;
      }
    }
  }
  if (v7 == v8)
  {
LABEL_12:
    GLuint renderbuffers = 0;
    glGenRenderbuffers(1, &renderbuffers);
    uint64_t v13 = a3 << 32;
    uint64_t v14 = renderbuffers;
    unsigned __int8 v16 = (uint64_t *)*((void *)this + 1);
    unint64_t v15 = *((void *)this + 2);
    if ((unint64_t)v16 >= v15)
    {
      unsigned __int8 v18 = *(uint64_t **)this;
      unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v16 - *(void *)this) >> 3);
      unint64_t v20 = v19 + 1;
      if (v19 + 1 > 0xAAAAAAAAAAAAAAALL) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v15 - (void)v18) >> 3);
      if (2 * v21 > v20) {
        unint64_t v20 = 2 * v21;
      }
      if (v21 >= 0x555555555555555) {
        unint64_t v22 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v22 = v20;
      }
      if (v22)
      {
        if (v22 > 0xAAAAAAAAAAAAAAALL) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        unsigned __int8 v23 = (char *)operator new(24 * v22);
      }
      else
      {
        unsigned __int8 v23 = 0;
      }
      float v24 = &v23[24 * v19];
      *(void *)float v24 = v13;
      *((void *)v24 + 1) = 0;
      *((_DWORD *)v24 + 4) = v14;
      v24[20] = 1;
      unsigned __int8 v17 = v24 + 24;
      if (v16 != v18)
      {
        do
        {
          long long v25 = *(_OWORD *)(v16 - 3);
          *(void *)(v24 - 11) = *(uint64_t *)((char *)v16 - 11);
          *(_OWORD *)(v24 - 24) = v25;
          v24 -= 24;
          v16 -= 3;
        }
        while (v16 != v18);
        unsigned __int8 v16 = *(uint64_t **)this;
      }
      *(void *)this = v24;
      *((void *)this + 1) = v17;
      *((void *)this + 2) = &v23[24 * v22];
      if (v16) {
        operator delete(v16);
      }
    }
    else
    {
      uint64_t *v16 = v13;
      v16[1] = 0;
      *((_DWORD *)v16 + 4) = v14;
      *((unsigned char *)v16 + 2CVOpenGLESTextureCacheFlush(this[3], 0) = 1;
      unsigned __int8 v17 = v16 + 3;
    }
    *((void *)this + 1) = v17;
    unsigned __int8 v26 = atomic_load(HGLogger::_enabled);
    if (v26) {
      HGLogger::log((HGLogger *)"renderbuffer", (const char *)1, (HGLogger *)"allocating new renderbuffer (%d)\n", v11, v12, v14);
    }
    uint64_t v9 = v14;
  }
  else
  {
    uint64_t v9 = *(unsigned int *)(v7 + 16);
    *(unsigned char *)(v7 + 2CVOpenGLESTextureCacheFlush(this[3], 0) = 1;
    unsigned __int8 v10 = atomic_load(HGLogger::_enabled);
    if (v10) {
      HGLogger::log((HGLogger *)"renderbuffer", (const char *)1, (HGLogger *)"found unused renderbuffer (%d)\n", v5, v6, v9);
    }
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v28);
  return v9;
}

void sub_1B77D7E68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77D7E7C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void HGTextureManager::HGTextureManager(HGTextureManager *this, HGGPURenderer *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a2;
  *((_DWORD *)this + 6) = 0;
  *((void *)this + 4) = 0;
  unsigned __int8 v3 = (void **)((char *)this + 32);
  *((void *)this + 19) = 0;
  unsigned __int8 v4 = (HGObject **)((char *)this + 152);
  *((void *)this + 5) = 0;
  *((void *)this + 2CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *((_DWORD *)this + 42) = 3;
  *((unsigned char *)this + 172) = 1;
  unint64_t v5 = (char *)HGObject::operator new(0xB8uLL);
  HGObject::HGObject((HGObject *)v5);
  *(void *)unint64_t v5 = &unk_1F10DA078;
  *((_OWORD *)v5 + 5) = 0u;
  *((_OWORD *)v5 + 6) = 0u;
  *((_OWORD *)v5 + 7) = 0u;
  *((_OWORD *)v5 + 8) = 0u;
  *((_OWORD *)v5 + 9) = 0u;
  *((_OWORD *)v5 + 1CVOpenGLESTextureCacheFlush(this[3], 0) = 0u;
  *((void *)v5 + 22) = 0;
  pthread_mutex_init((pthread_mutex_t *)(v5 + 16), 0);
  uint64_t v6 = *v3;
  if (*v3 == v5)
  {
    (*(void (**)(char *))(*(void *)v5 + 24))(v5);
  }
  else
  {
    if (v6) {
      (*(void (**)(void *))(*(void *)v6 + 24))(v6);
    }
    const char *v3 = v5;
  }
  uint64_t v7 = (HGObject *)HGObject::operator new(0x10uLL);
  HGObject::HGObject(v7);
  uint64_t v8 = (void (**)(HGObject *))&unk_1F10D9E88;
  *(void *)uint64_t v7 = &unk_1F10D9E88;
  if (HG_RENDERER_ENV::FORCE_CLUSTERED_TEXTURE_PADDING != 1)
  {
    uint64_t v9 = *v4;
    if (*v4 != v7)
    {
      if (v9)
      {
        (*(void (**)(HGObject *))(*(void *)v9 + 24))(v9);
        uint64_t v8 = *(void (***)(HGObject *))v7;
      }
      const char *v4 = v7;
      v8[2](v7);
      uint64_t v8 = *(void (***)(HGObject *))v7;
    }
  }
  v8[3](v7);
  unsigned __int8 v10 = (HGObject *)HGObject::operator new(0x18uLL);
  HGObject::HGObject(v10);
  *((void *)v10 + 2) = 0;
  *(void *)unsigned __int8 v10 = &unk_1F10D9EC8;
  unsigned __int8 v11 = v10;
  HGTextureManager::setTexturePoolingPolicy((uint64_t)this, &v11);
  (*(void (**)(HGObject *))(*(void *)v10 + 24))(v10);
  operator new();
}

void sub_1B77D8148(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  uint64_t v6 = *(void *)(v1 + 160);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
  }
  if (*v4) {
    (*(void (**)(void))(*(void *)*v4 + 24))(*v4);
  }
  uint64_t v7 = *(void *)(v1 + 40);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
  }
  if (*v3) {
    (*(void (**)(void))(*(void *)*v3 + 24))(*v3);
  }
  _Unwind_Resume(a1);
}

void *HGTextureManager::setTexturePaddingPolicy(void *result, void **a2)
{
  if (HG_RENDERER_ENV::FORCE_CLUSTERED_TEXTURE_PADDING != 1)
  {
    unsigned __int8 v3 = result;
    unsigned __int8 v4 = (void *)result[19];
    double result = *a2;
    if (v4 != *a2)
    {
      if (v4)
      {
        (*(void (**)(void *))(*v4 + 24))(v4);
        double result = *a2;
      }
      v3[19] = result;
      if (result)
      {
        unint64_t v5 = *(uint64_t (**)(void))(*result + 16);
        return (void *)v5();
      }
    }
  }
  return result;
}

uint64_t HGTextureManager::setTexturePoolingPolicy(uint64_t result, void *a2)
{
  if (HG_RENDERER_ENV::FORCE_LEGACY_TEXTURE_POOLING != 1)
  {
    uint64_t v3 = result;
    unsigned __int8 v4 = *(void **)(result + 160);
    unint64_t v5 = (void *)*a2;
    if (v4 != (void *)*a2)
    {
      if (v4)
      {
        (*(void (**)(void *))(*v4 + 24))(v4);
        unint64_t v5 = (void *)*a2;
      }
      *(void *)(v3 + 16CVOpenGLESTextureCacheFlush(this[3], 0) = v5;
      if (v5)
      {
        (*(void (**)(void *))(*v5 + 16))(v5);
        unsigned __int8 v4 = *(void **)(v3 + 160);
      }
      else
      {
        unsigned __int8 v4 = 0;
      }
    }
    uint64_t v6 = (HGObject *)HGObject::operator new(0x18uLL);
    HGObject::HGObject(v6);
    uint64_t v7 = (void (**)(void *))&unk_1F10D9DE0;
    *(void *)uint64_t v6 = &unk_1F10D9DE0;
    *((void *)v6 + 2) = v3;
    uint64_t v8 = (HGObject *)v4[2];
    if (v8 != v6)
    {
      if (v8)
      {
        (*(void (**)(HGObject *))(*(void *)v8 + 24))(v8);
        uint64_t v7 = *(void (***)(void *))v6;
      }
      void v4[2] = v6;
      ((void (**)(HGObject *))v7)[2](v6);
      uint64_t v7 = *(void (***)(void *))v6;
    }
    return ((uint64_t (*)(HGObject *))v7[3])(v6);
  }
  return result;
}

void sub_1B77D855C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77D8570(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t HGTextureManager::_initTexManagerList(HGTextureManager *this)
{
    operator new();
  if ((unint64_t)v4 < v3)
  {
    *(void *)unsigned __int8 v4 = this;
    uint64_t v5 = (uint64_t)(v4 + 8);
    goto LABEL_25;
  }
  uint64_t v8 = v7 >> 3;
  unint64_t v9 = (v7 >> 3) + 1;
  if (v9 >> 61) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v10 = v3 - (void)v6;
  if (v10 >> 2 > v9) {
    unint64_t v9 = v10 >> 2;
  }
  if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v11 = v9;
  }
  if (v11)
  {
    if (v11 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    unsigned __int8 v12 = operator new(8 * v11);
    uint64_t v13 = &v12[8 * v8];
    uint64_t v14 = &v12[8 * v11];
    void *v13 = this;
    uint64_t v5 = (uint64_t)(v13 + 1);
    unint64_t v15 = (char *)(v4 - v6);
    if (v4 == v6) {
      goto LABEL_23;
    }
    goto LABEL_16;
  }
  unsigned __int8 v12 = 0;
  uint64_t v13 = (void *)(8 * v8);
  uint64_t v14 = 0;
  *(void *)(8 * v8) = this;
  uint64_t v5 = 8 * v8 + 8;
  unint64_t v15 = (char *)(v4 - v6);
  if (v4 != v6)
  {
LABEL_16:
    unint64_t v16 = (unint64_t)(v15 - 8);
    if (v16 < 0x58) {
      goto LABEL_32;
    }
    if ((unint64_t)(v4 - v12 - v7) < 0x20) {
      goto LABEL_32;
    }
    uint64_t v17 = (v16 >> 3) + 1;
    uint64_t v18 = 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
    unint64_t v19 = &v4[-v18];
    uint64_t v13 = (void *)((char *)v13 - v18);
    unint64_t v20 = &v12[8 * v8 - 16];
    unint64_t v21 = v4 - 16;
    uint64_t v22 = v17 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v23 = *(_OWORD *)v21;
      *(v20 - 1) = *((_OWORD *)v21 - 1);
      *unint64_t v20 = v23;
      v20 -= 2;
      v21 -= 32;
      v22 -= 4;
    }
    while (v22);
    unsigned __int8 v4 = v19;
    if (v17 != (v17 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_32:
      do
      {
        uint64_t v24 = *((void *)v4 - 1);
        v4 -= 8;
        *--uint64_t v13 = v24;
      }
      while (v4 != v6);
    }
    unsigned __int8 v4 = *(char **)v2;
  }
LABEL_23:
  *(void *)uint64_t v2 = v13;
  *(void *)(v2 + 8) = v5;
  *(void *)(v2 + 16) = v14;
  if (v4) {
    operator delete(v4);
  }
LABEL_25:
  *(void *)(v2 + 8) = v5;
}

uint64_t HGTextureManager::_initShareGroup(HGTextureManager *this)
{
    operator new();
    goto LABEL_10;
  while (*(void *)v5 != *((void *)this + 2))
  {
    v5 += 8;
    if (v5 == v4)
    {
      break;
    }
  }
  if (v5 == v4)
  {
LABEL_10:
    if ((unint64_t)v4 >= v6)
    {
      int64_t v8 = v4 - v3;
      uint64_t v9 = (v4 - v3) >> 3;
      unint64_t v10 = v9 + 1;
      if ((unint64_t)(v9 + 1) >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v11 = v6 - (void)v3;
      if (v11 >> 2 > v10) {
        unint64_t v10 = v11 >> 2;
      }
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v12 = v10;
      }
      if (v12)
      {
        if (v12 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v13 = operator new(8 * v12);
      }
      else
      {
        uint64_t v13 = 0;
      }
      uint64_t v14 = &v13[8 * v9];
      *uint64_t v14 = *((void *)this + 2);
      uint64_t v7 = v14 + 1;
      if (v3 != v4)
      {
        if ((unint64_t)(v8 - 8) < 0x58) {
          goto LABEL_40;
        }
        if ((unint64_t)(v3 - v13) < 0x20) {
          goto LABEL_40;
        }
        unint64_t v15 = ((unint64_t)(v8 - 8) >> 3) + 1;
        uint64_t v16 = 8 * (v15 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v17 = &v4[-v16];
        uint64_t v14 = (void *)((char *)v14 - v16);
        uint64_t v18 = &v13[8 * v9 - 16];
        unint64_t v19 = v4 - 16;
        uint64_t v20 = v15 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v21 = *(_OWORD *)v19;
          *(v18 - 1) = *((_OWORD *)v19 - 1);
          *uint64_t v18 = v21;
          v18 -= 2;
          v19 -= 32;
          v20 -= 4;
        }
        while (v20);
        unsigned __int8 v4 = v17;
        if (v15 != (v15 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_40:
          do
          {
            uint64_t v22 = *((void *)v4 - 1);
            v4 -= 8;
            *--uint64_t v14 = v22;
          }
          while (v4 != v3);
        }
        unint64_t v3 = *(char **)v2;
      }
      *(void *)uint64_t v2 = v14;
      *(void *)(v2 + 8) = v7;
      *(void *)(v2 + 16) = &v13[8 * v12];
      if (v3) {
        operator delete(v3);
      }
    }
    else
    {
      *(void *)unsigned __int8 v4 = *((void *)this + 2);
      uint64_t v7 = v4 + 8;
    }
    *(void *)(v2 + 8) = v7;
  }
}

uint64_t HGTextureManager::_initTexturePool(HGTextureManager *this)
{
    operator new();
  unint64_t v3 = (unint64_t *)((char *)this + 16);
  if (v2)
  {
    unint64_t v4 = *v3;
    do
    {
      unint64_t v6 = v2[4];
      BOOL v7 = v6 >= v4;
      if (v6 >= v4) {
        int64_t v8 = v2;
      }
      else {
        int64_t v8 = v2 + 1;
      }
      if (v7) {
        uint64_t v5 = (uint64_t)v2;
      }
      uint64_t v2 = (void *)*v8;
    }
    while (*v8);
    {
      (*(void (**)(void))(**(void **)(v5 + 40) + 16))(*(void *)(v5 + 40));
      goto LABEL_31;
    }
  }
  uint64_t v9 = (char *)HGObject::operator new(0xB8uLL);
  HGObject::HGObject((HGObject *)v9);
  *(void *)uint64_t v9 = &unk_1F10DA078;
  *((_OWORD *)v9 + 5) = 0u;
  *((_OWORD *)v9 + 6) = 0u;
  *((_OWORD *)v9 + 7) = 0u;
  *((_OWORD *)v9 + 8) = 0u;
  *((_OWORD *)v9 + 9) = 0u;
  *((_OWORD *)v9 + 1CVOpenGLESTextureCacheFlush(this[3], 0) = 0u;
  *((void *)v9 + 22) = 0;
  pthread_mutex_init((pthread_mutex_t *)(v9 + 16), 0);
    operator new();
  unint64_t v13 = *v3;
  if (v11)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v16 = (uint64_t **)v11;
        unint64_t v14 = v11[4];
        if (v13 >= v14) {
          break;
        }
        uint64_t v11 = *v16;
        if (!*v16)
        {
          unint64_t v15 = v16;
          goto LABEL_24;
        }
      }
      if (v14 >= v13) {
        break;
      }
      uint64_t v11 = v16[1];
      if (!v11)
      {
        unint64_t v15 = v16 + 1;
        goto LABEL_24;
      }
    }
    uint64_t v17 = (uint64_t *)v16;
    uint64_t v20 = (char *)v16[5];
    if (v20 == v9) {
      goto LABEL_30;
    }
  }
  else
  {
LABEL_24:
    uint64_t v17 = (uint64_t *)operator new(0x30uLL);
    v17[4] = v13;
    v17[5] = 0;
    uint64_t *v17 = 0;
    v17[1] = 0;
    void v17[2] = (uint64_t)v16;
    *unint64_t v15 = v17;
    uint64_t v18 = **(void **)v10;
    unint64_t v19 = v17;
    if (v18)
    {
      *(void *)uint64_t v10 = v18;
      unint64_t v19 = *v15;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*v12, v19);
    ++*(void *)(v10 + 16);
    uint64_t v20 = (char *)v17[5];
    if (v20 == v9) {
      goto LABEL_30;
    }
  }
  if (v20) {
    (*(void (**)(char *))(*(void *)v20 + 24))(v20);
  }
  v17[5] = (uint64_t)v9;
  (*(void (**)(char *))(*(void *)v9 + 16))(v9);
LABEL_30:
  (*(void (**)(char *))(*(void *)v9 + 24))(v9);
LABEL_31:
}

void sub_1B77D8C64(_Unwind_Exception *a1)
{
  std::deque<HGTextureManager::TextureEntry>::~deque[abi:ne180100](v2);
  HGObject::~HGObject(v1);
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77D8C90(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t HGTextureManager::_initDeleteQueue(HGTextureManager *this)
{
  pthread_mutex_lock(&_MergedGlobals);
  if (!qword_1E9EE5870) {
    operator new();
  }
  uint64_t v2 = *(void **)(qword_1E9EE5870 + 8);
  unint64_t v3 = (unint64_t *)((char *)this + 16);
  if (v2)
  {
    unint64_t v4 = *v3;
    uint64_t v5 = qword_1E9EE5870 + 8;
    do
    {
      unint64_t v6 = v2[4];
      BOOL v7 = v6 >= v4;
      if (v6 >= v4) {
        int64_t v8 = v2;
      }
      else {
        int64_t v8 = v2 + 1;
      }
      if (v7) {
        uint64_t v5 = (uint64_t)v2;
      }
      uint64_t v2 = (void *)*v8;
    }
    while (*v8);
    if (v5 != qword_1E9EE5870 + 8 && v4 >= *(void *)(v5 + 32))
    {
      (*(void (**)(void))(**(void **)(v5 + 40) + 16))(*(void *)(v5 + 40));
      goto LABEL_35;
    }
  }
  uint64_t v9 = (TextureDeleteQueue *)HGObject::operator new(0x198uLL);
  TextureDeleteQueue::TextureDeleteQueue(v9);
  uint64_t v10 = qword_1E9EE5870;
  if (!qword_1E9EE5870) {
    operator new();
  }
  unint64_t v12 = (uint64_t **)(qword_1E9EE5870 + 8);
  uint64_t v11 = *(uint64_t **)(qword_1E9EE5870 + 8);
  unint64_t v13 = *v3;
  if (!v11)
  {
    unint64_t v15 = (uint64_t **)(qword_1E9EE5870 + 8);
    uint64_t v16 = (uint64_t **)(qword_1E9EE5870 + 8);
LABEL_24:
    uint64_t v17 = (uint64_t *)operator new(0x30uLL);
    v17[4] = v13;
    v17[5] = 0;
    uint64_t *v17 = 0;
    v17[1] = 0;
    void v17[2] = (uint64_t)v16;
    *unint64_t v15 = v17;
    uint64_t v18 = **(void **)v10;
    unint64_t v19 = v17;
    if (v18)
    {
      *(void *)uint64_t v10 = v18;
      unint64_t v19 = *v15;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*v12, v19);
    ++*(void *)(v10 + 16);
    uint64_t v20 = (TextureDeleteQueue *)v17[5];
    if (v20 != v9) {
      goto LABEL_27;
    }
LABEL_33:
    if (!v9) {
      goto LABEL_35;
    }
    goto LABEL_34;
  }
  while (1)
  {
    while (1)
    {
      uint64_t v16 = (uint64_t **)v11;
      unint64_t v14 = v11[4];
      if (v13 >= v14) {
        break;
      }
      uint64_t v11 = *v16;
      if (!*v16)
      {
        unint64_t v15 = v16;
        goto LABEL_24;
      }
    }
    if (v14 >= v13) {
      break;
    }
    uint64_t v11 = v16[1];
    if (!v11)
    {
      unint64_t v15 = v16 + 1;
      goto LABEL_24;
    }
  }
  uint64_t v17 = (uint64_t *)v16;
  uint64_t v20 = (TextureDeleteQueue *)v16[5];
  if (v20 == v9) {
    goto LABEL_33;
  }
LABEL_27:
  if (v20) {
    (*(void (**)(TextureDeleteQueue *))(*(void *)v20 + 24))(v20);
  }
  v17[5] = (uint64_t)v9;
  if (v9)
  {
    (*(void (**)(TextureDeleteQueue *))(*(void *)v9 + 16))(v9);
LABEL_34:
    (*(void (**)(TextureDeleteQueue *))(*(void *)v9 + 24))(v9);
  }
LABEL_35:

  return pthread_mutex_unlock(&_MergedGlobals);
}

void sub_1B77D8F64(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t HGTextureManager::_initMaxUsageStats(HGTextureManager *this)
{
  pthread_mutex_lock(&stru_1EB9A0498);
  if (!qword_1E9EE5878) {
    operator new();
  }
  uint64_t v2 = *(void **)(qword_1E9EE5878 + 8);
  if (!v2) {
    goto LABEL_15;
  }
  unint64_t v3 = *((void *)this + 2);
  uint64_t v4 = qword_1E9EE5878 + 8;
  do
  {
    unint64_t v5 = v2[4];
    BOOL v6 = v5 >= v3;
    if (v5 >= v3) {
      BOOL v7 = v2;
    }
    else {
      BOOL v7 = v2 + 1;
    }
    if (v6) {
      uint64_t v4 = (uint64_t)v2;
    }
    uint64_t v2 = (void *)*v7;
  }
  while (*v7);
  if (v4 == qword_1E9EE5878 + 8 || v3 < *(void *)(v4 + 32)) {
LABEL_15:
  }
    operator new();

  return pthread_mutex_unlock(&stru_1EB9A0498);
}

void HGTextureManager::HGTextureManager(HGTextureManager *this, HGGPURenderer *a2, void *a3)
{
  *(void *)this = 0;
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((_DWORD *)this + 6) = 0;
  *((void *)this + 4) = 0;
  uint64_t v4 = (void **)((char *)this + 32);
  *((void *)this + 19) = 0;
  unint64_t v5 = (HGObject **)((char *)this + 152);
  *((void *)this + 5) = 0;
  *((void *)this + 2CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *((_DWORD *)this + 42) = 3;
  *((unsigned char *)this + 172) = 1;
  BOOL v6 = (char *)HGObject::operator new(0xB8uLL);
  HGObject::HGObject((HGObject *)v6);
  *(void *)BOOL v6 = &unk_1F10DA078;
  *((_OWORD *)v6 + 5) = 0u;
  *((_OWORD *)v6 + 6) = 0u;
  *((_OWORD *)v6 + 7) = 0u;
  *((_OWORD *)v6 + 8) = 0u;
  *((_OWORD *)v6 + 9) = 0u;
  *((_OWORD *)v6 + 1CVOpenGLESTextureCacheFlush(this[3], 0) = 0u;
  *((void *)v6 + 22) = 0;
  pthread_mutex_init((pthread_mutex_t *)(v6 + 16), 0);
  BOOL v7 = *v4;
  if (*v4 == v6)
  {
    (*(void (**)(char *))(*(void *)v6 + 24))(v6);
  }
  else
  {
    if (v7) {
      (*(void (**)(void *))(*(void *)v7 + 24))(v7);
    }
    char *v4 = v6;
  }
  int64_t v8 = (HGObject *)HGObject::operator new(0x10uLL);
  HGObject::HGObject(v8);
  uint64_t v9 = (void (**)(HGObject *))&unk_1F10D9E88;
  *(void *)int64_t v8 = &unk_1F10D9E88;
  if (HG_RENDERER_ENV::FORCE_CLUSTERED_TEXTURE_PADDING != 1)
  {
    uint64_t v10 = *v5;
    if (*v5 != v8)
    {
      if (v10)
      {
        (*(void (**)(HGObject *))(*(void *)v10 + 24))(v10);
        uint64_t v9 = *(void (***)(HGObject *))v8;
      }
      *unint64_t v5 = v8;
      v9[2](v8);
      uint64_t v9 = *(void (***)(HGObject *))v8;
    }
  }
  v9[3](v8);
  uint64_t v11 = (HGObject *)HGObject::operator new(0x18uLL);
  HGObject::HGObject(v11);
  *((void *)v11 + 2) = 0;
  *(void *)uint64_t v11 = &unk_1F10D9EC8;
  unint64_t v12 = v11;
  HGTextureManager::setTexturePoolingPolicy((uint64_t)this, &v12);
  (*(void (**)(HGObject *))(*(void *)v11 + 24))(v11);
  operator new();
}

void sub_1B77D9468(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  uint64_t v6 = *(void *)(v1 + 160);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
  }
  if (*v4) {
    (*(void (**)(void))(*(void *)*v4 + 24))(*v4);
  }
  uint64_t v7 = *(void *)(v1 + 40);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
  }
  if (*v3) {
    (*(void (**)(void))(*(void *)*v3 + 24))(*v3);
  }
  _Unwind_Resume(a1);
}

void HGTextureManager::~HGTextureManager(HGTextureManager *this)
{
  HGTextureManager::_uninitDeleteQueue(this);
  HGTextureManager::_uninitTexturePool(this);
  if (*(void *)(*((void *)this + 4) + 120)) {
    HGLogger::warning((HGLogger *)"texture manager pool is NOT empty! Textures are still in used.", v2, v3);
  }
    operator new();
  {
    while (*v6 != this)
    {
      if (++v6 == v5)
      {
        break;
      }
    }
  }
  int64_t v7 = (char *)v5 - (char *)(v6 + 1);
  if (v5 != v6 + 1) {
    memmove(v6, v6 + 1, (char *)v5 - (char *)(v6 + 1));
  }
  *(void *)(v4 + 8) = (char *)v6 + v7;
  if (*((void *)this + 5))
  {
    unsigned __int8 v10 = atomic_load(HGLogger::_enabled);
    if (v10) {
      HGLogger::log((HGLogger *)"init", (const char *)1, (HGLogger *)"deleting auxiliary context\n", v8, v9);
    }
    uint64_t v11 = *((void *)this + 5);
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
    }
    *((void *)this + 5) = 0;
    pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 48));
  }
  uint64_t v12 = *((void *)this + 14);
  if (v12)
  {
    pthread_mutex_destroy(*((pthread_mutex_t **)this + 14));
    unint64_t v13 = *(void **)(v12 + 64);
    if (v13)
    {
      *(void *)(v12 + 72) = v13;
      operator delete(v13);
    }
    MEMORY[0x1BA9BFBA0](v12, 0x1080C40D9CAA561);
  }
  *((void *)this + 14) = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  uint64_t v14 = *((void *)this + 20);
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);
  }
  uint64_t v15 = *((void *)this + 19);
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 24))(v15);
  }
  uint64_t v16 = *((void *)this + 5);
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 24))(v16);
  }
  uint64_t v17 = *((void *)this + 4);
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 24))(v17);
  }
}

uint64_t HGTextureManager::_uninitDeleteQueue(HGTextureManager *this)
{
  pthread_mutex_lock(&_MergedGlobals);
  if (!qword_1E9EE5870) {
    operator new();
  }
  uint64_t v2 = *(void **)(qword_1E9EE5870 + 8);
  if (!v2) {
    goto LABEL_20;
  }
  unint64_t v3 = *((void *)this + 2);
  uint64_t v4 = (uint64_t *)(qword_1E9EE5870 + 8);
  do
  {
    unint64_t v5 = v2[4];
    BOOL v6 = v5 >= v3;
    if (v5 >= v3) {
      int64_t v7 = v2;
    }
    else {
      int64_t v7 = v2 + 1;
    }
    if (v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = (void *)*v7;
  }
  while (*v7);
  if (v4 == (uint64_t *)(qword_1E9EE5870 + 8) || v3 < v4[4])
  {
LABEL_20:
  }
  else
  {
    unsigned int v8 = atomic_load((unsigned int *)(v4[5] + 8));
    if (v8 == 1)
    {
      uint64_t v9 = qword_1E9EE5870;
      if (!qword_1E9EE5870) {
        operator new();
      }
      unsigned __int8 v10 = (uint64_t *)v4[1];
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          unsigned __int8 v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
      else
      {
        unint64_t v13 = v4;
        do
        {
          uint64_t v11 = (uint64_t *)v13[2];
          BOOL v14 = *v11 == (void)v13;
          unint64_t v13 = v11;
        }
        while (!v14);
      }
      if (*(uint64_t **)qword_1E9EE5870 == v4) {
        *(void *)qword_1E9EE5870 = v11;
      }
      uint64_t v15 = *(uint64_t **)(v9 + 8);
      --*(void *)(v9 + 16);
      std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v15, v4);
      uint64_t v16 = v4[5];
      if (v16) {
        (*(void (**)(uint64_t))(*(void *)v16 + 24))(v16);
      }
      operator delete(v4);
    }
    else
    {
      (*(void (**)(uint64_t))(*(void *)v4[5] + 24))(v4[5]);
    }
  }
  return pthread_mutex_unlock(&_MergedGlobals);
}

uint64_t HGTextureManager::_uninitTexturePool(HGTextureManager *this)
{
    operator new();
  unint64_t v3 = (unint64_t *)((char *)this + 16);
  if (!v2) {
    goto LABEL_34;
  }
  unint64_t v4 = *v3;
  do
  {
    unint64_t v6 = v2[4];
    BOOL v7 = v6 >= v4;
    if (v6 >= v4) {
      unsigned int v8 = v2;
    }
    else {
      unsigned int v8 = v2 + 1;
    }
    if (v7) {
      uint64_t v5 = (uint64_t)v2;
    }
    uint64_t v2 = (void *)*v8;
  }
  while (*v8);
  {
LABEL_34:
      goto LABEL_16;
LABEL_35:
    operator new();
  }
  unsigned int v9 = atomic_load((unsigned int *)(*(void *)(v5 + 40) + 8));
  if (v9 == 1) {
    HGTextureManager::emptyTexturePool(this);
  }
    goto LABEL_35;
LABEL_16:
  unint64_t v13 = *(void **)(v10 + 8);
  uint64_t v11 = (uint64_t *)(v10 + 8);
  uint64_t v12 = v13;
  if (v13)
  {
    unint64_t v14 = *v3;
    uint64_t v15 = v11;
    do
    {
      unint64_t v16 = v12[4];
      BOOL v17 = v16 >= v14;
      if (v16 >= v14) {
        uint64_t v18 = v12;
      }
      else {
        uint64_t v18 = v12 + 1;
      }
      if (v17) {
        uint64_t v15 = v12;
      }
      uint64_t v12 = (void *)*v18;
    }
    while (*v18);
    if (v15 != v11 && v14 >= v15[4])
    {
      unsigned int v19 = atomic_load((unsigned int *)(v15[5] + 8));
      if (v19 == 1)
      {
          operator new();
        long long v21 = (uint64_t *)v15[1];
        if (v21)
        {
          do
          {
            uint64_t v22 = v21;
            long long v21 = (uint64_t *)*v21;
          }
          while (v21);
        }
        else
        {
          uint64_t v24 = v15;
          do
          {
            uint64_t v22 = (uint64_t *)v24[2];
            BOOL v25 = *v22 == (void)v24;
            uint64_t v24 = v22;
          }
          while (!v25);
        }
        unsigned __int8 v26 = *(uint64_t **)(v20 + 8);
        --*(void *)(v20 + 16);
        std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v26, v15);
        uint64_t v27 = v15[5];
        if (v27) {
          (*(void (**)(uint64_t))(*(void *)v27 + 24))(v27);
        }
        operator delete(v15);
      }
      else
      {
        (*(void (**)(uint64_t))(*(void *)v15[5] + 24))(v15[5]);
      }
    }
  }
}

void HGTextureManager::finishDeleteTextureQueue(HGTextureManager *this)
{
  unint64_t v1 = *((void *)this + 2);
  pthread_mutex_lock(&_MergedGlobals);
  if (!qword_1E9EE5870) {
    operator new();
  }
  uint64_t v2 = *(void **)(qword_1E9EE5870 + 8);
  if (!v2) {
    goto LABEL_15;
  }
  uint64_t v3 = qword_1E9EE5870 + 8;
  do
  {
    unint64_t v4 = v2[4];
    BOOL v5 = v4 >= v1;
    if (v4 >= v1) {
      unint64_t v6 = v2;
    }
    else {
      unint64_t v6 = v2 + 1;
    }
    if (v5) {
      uint64_t v3 = (uint64_t)v2;
    }
    uint64_t v2 = (void *)*v6;
  }
  while (*v6);
  if (v3 == qword_1E9EE5870 + 8 || *(void *)(v3 + 32) > v1) {
LABEL_15:
  }
    uint64_t v3 = qword_1E9EE5870 + 8;
  BOOL v7 = *(TextureDeleteQueue **)(v3 + 40);
  pthread_mutex_unlock(&_MergedGlobals);

  TextureDeleteQueue::finishQueue(v7);
}

BOOL HGTextureManager::init(HGTextureManager *this)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v27, "init", 1, "HGTextureManager::init()");
  uint64_t GLState = HGGPURenderer::GetGLState(*((HGGPURenderer **)this + 1));
  HGGPURenderer::GetContext(*((void *)this + 1), 24, (uint64_t *)&v25);
  HGGLState::SetCurrentContextGuard::SetCurrentContextGuard(v26, GLState, &v25);
  PCSharedCount::PCSharedCount(&v25);
  size_t v28 = 8;
  v29.int var0 = 0;
  *(void *)uint64_t v30 = 0x1800000006;
  sysctl(v30, 2u, &v29, &v28, 0, 0);
  int var0 = v29.var0;
  unsigned __int8 v6 = atomic_load(HGLogger::_enabled);
  if (v6) {
    HGLogger::log((HGLogger *)"init", (const char *)1, (HGLogger *)"getAvailableVideoMemory() : %zu\n", v3, v4, v29.var0);
  }
  *((void *)this + 18) = var0;
  LODWORD(v28) = 0;
  glGetIntegerv(0xD33u, (GLint *)&v28);
  unsigned int v7 = v28;
  *((_DWORD *)this + 3CVOpenGLESTextureCacheFlush(this[3], 0) = v28;
  *(int32x4_t *)((char *)this + 124) = vdupq_n_s32((float)((float)v7 * 0.95));
  HGTextureManager::_createAuxiliaryGLContext((uint64_t)this, v8, v9, v10, v11);
  if (HG_RENDERER_ENV::FORCE_CLUSTERED_TEXTURE_PADDING == 1)
  {
    uint64_t v12 = (HGObject *)HGObject::operator new(0x38uLL);
    HGObject::HGObject(v12);
    *(void *)uint64_t v12 = &unk_1F10D9F98;
    *((void *)v12 + 2) = (char *)v12 + 16;
    *((void *)v12 + 3) = (char *)v12 + 16;
    *((void *)v12 + 4) = 0;
    *((void *)v12 + 5) = 0x100000002;
    *((_DWORD *)v12 + 12) = 4;
    if (HG_RENDERER_ENV::TEX_PADDING_REMEMBRANCE != -1) {
      *((_DWORD *)v12 + 1CVOpenGLESTextureCacheFlush(this[3], 0) = HG_RENDERER_ENV::TEX_PADDING_REMEMBRANCE;
    }
    if (HG_RENDERER_ENV::TEX_PADDING_CUSHIONING != -1) {
      *((_DWORD *)v12 + 11) = HG_RENDERER_ENV::TEX_PADDING_CUSHIONING;
    }
    if (HG_RENDERER_ENV::TEX_PADDING_CLUMPING != -1) {
      *((_DWORD *)v12 + 12) = HG_RENDERER_ENV::TEX_PADDING_CLUMPING;
    }
    unint64_t v13 = (HGObject *)*((void *)this + 19);
    if (v13 == v12)
    {
      HGObject::Release((atomic_uint *)v12);
    }
    else
    {
      if (v13) {
        (*(void (**)(HGObject *))(*(void *)v13 + 24))(v13);
      }
      *((void *)this + 19) = v12;
    }
  }
  if (HG_RENDERER_ENV::FORCE_LEGACY_TEXTURE_POOLING == 1)
  {
    unint64_t v14 = (HGObject *)HGObject::operator new(0x28uLL);
    HGObject::HGObject(v14);
    *((void *)v14 + 2) = 0;
    *((void *)v14 + 3) = 0;
    uint64_t v15 = (void (**)(void *))&unk_1F10D9FD8;
    *(void *)unint64_t v14 = &unk_1F10D9FD8;
    *((_DWORD *)v14 + 8) = 1056964608;
    unint64_t v16 = *((void *)this + 18);
    float v17 = (float)v16;
    if (v16 >> 31)
    {
      *((_DWORD *)v14 + 8) = 1062836634;
      *((void *)v14 + 3) = (unint64_t)(float)(v17 * 0.5);
      uint64_t v18 = (HGObject *)*((void *)this + 20);
      unsigned int v19 = v14;
      if (v18 == v14) {
        goto LABEL_23;
      }
    }
    else
    {
      *((void *)v14 + 3) = (unint64_t)(float)(v17 * 0.25);
      uint64_t v18 = (HGObject *)*((void *)this + 20);
      unsigned int v19 = v14;
      if (v18 == v14)
      {
LABEL_23:
        uint64_t v20 = (HGObject *)HGObject::operator new(0x18uLL);
        HGObject::HGObject(v20);
        long long v21 = (void (**)(void *))&unk_1F10D9DE0;
        *(void *)uint64_t v20 = &unk_1F10D9DE0;
        *((void *)v20 + 2) = this;
        uint64_t v22 = (HGObject *)*((void *)v19 + 2);
        if (v22 != v20)
        {
          if (v22)
          {
            (*(void (**)(HGObject *))(*(void *)v22 + 24))(v22);
            long long v21 = *(void (***)(void *))v20;
          }
          *((void *)v19 + 2) = v20;
          ((void (**)(HGObject *))v21)[2](v20);
          long long v21 = *(void (***)(void *))v20;
        }
        ((void (**)(HGObject *))v21)[3](v20);
        (*(void (**)(HGObject *))(*(void *)v14 + 24))(v14);
        goto LABEL_28;
      }
    }
    if (v18)
    {
      (*(void (**)(HGObject *))(*(void *)v18 + 24))(v18);
      uint64_t v15 = *(void (***)(void *))v14;
    }
    *((void *)this + 2CVOpenGLESTextureCacheFlush(this[3], 0) = v14;
    v15[2](v14);
    unsigned int v19 = (HGObject *)*((void *)this + 20);
    goto LABEL_23;
  }
LABEL_28:
  HGGLContext::context((uint64_t *)&v29, *((HGGLContext **)this + 5));
  BOOL v23 = PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&v29) != 0;
  PCSharedCount::PCSharedCount(&v29);
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard(v26);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v27);
  return v23;
}

void sub_1B77DA280(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCSharedCount a11, char a12, uint64_t a13, uint64_t a14, char a15)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B77DA404(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t HGTextureManager::_createAuxiliaryGLContext(uint64_t this, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  if (!*(void *)(this + 40))
  {
    uint64_t v5 = this;
    unsigned __int8 v6 = atomic_load(HGLogger::_enabled);
    if (v6) {
      HGLogger::log((HGLogger *)"init", (const char *)1, (HGLogger *)"creating auxiliary context for texture delete thread\n", a4, a5);
    }
    HGGPURenderer::GetContext(*(void *)(v5 + 8), 24, &v7);
    HGGLContext::Create();
  }
  return this;
}

void sub_1B77DA53C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  PCSharedCount::PCSharedCount((PCSharedCount *)&a9);
  _Unwind_Resume(a1);
}

uint64_t HGTextureManager::maxTextureSizeGL(uint64_t a1, int a2)
{
  uint64_t v2 = 132;
  if (a2 == 28) {
    uint64_t v2 = 136;
  }
  return *(unsigned int *)(a1 + v2);
}

uint64_t HGTextureManager::renderBgn(HGTextureManager *this)
{
  unint64_t v2 = *((void *)this + 2);
  pthread_mutex_lock(&_MergedGlobals);
  if (!qword_1E9EE5870) {
    operator new();
  }
  uint64_t v3 = *(void **)(qword_1E9EE5870 + 8);
  if (!v3) {
    goto LABEL_15;
  }
  uint64_t v4 = qword_1E9EE5870 + 8;
  do
  {
    unint64_t v5 = v3[4];
    BOOL v6 = v5 >= v2;
    if (v5 >= v2) {
      uint64_t v7 = v3;
    }
    else {
      uint64_t v7 = v3 + 1;
    }
    if (v6) {
      uint64_t v4 = (uint64_t)v3;
    }
    uint64_t v3 = (void *)*v7;
  }
  while (*v7);
  if (v4 == qword_1E9EE5870 + 8 || *(void *)(v4 + 32) > v2) {
LABEL_15:
  }
    uint64_t v4 = qword_1E9EE5870 + 8;
  uint64_t v8 = *(void *)(v4 + 40);
  pthread_mutex_unlock(&_MergedGlobals);
  pthread_mutex_lock((pthread_mutex_t *)(v8 + 336));
  int v9 = *(_DWORD *)(v8 + 400);
  *(_DWORD *)(v8 + 40CVOpenGLESTextureCacheFlush(this[3], 0) = v9 + 1;
  if (!v9)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v8 + 128));
    *(unsigned char *)(v8 + 404) = 1;
    while (!*(unsigned char *)(v8 + 405))
      pthread_cond_wait((pthread_cond_t *)(v8 + 240), (pthread_mutex_t *)(v8 + 128));
    pthread_mutex_unlock((pthread_mutex_t *)(v8 + 128));
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v8 + 336));
  *(void *)this = 0;
  pthread_mutex_lock(&stru_1EB9A0498);
  if (!qword_1E9EE5878) {
    operator new();
  }
  uint64_t v10 = *(void **)(qword_1E9EE5878 + 8);
  if (!v10) {
    goto LABEL_34;
  }
  unint64_t v11 = *((void *)this + 2);
  uint64_t v12 = qword_1E9EE5878 + 8;
  do
  {
    unint64_t v13 = v10[4];
    BOOL v14 = v13 >= v11;
    if (v13 >= v11) {
      uint64_t v15 = v10;
    }
    else {
      uint64_t v15 = v10 + 1;
    }
    if (v14) {
      uint64_t v12 = (uint64_t)v10;
    }
    uint64_t v10 = (void *)*v15;
  }
  while (*v15);
  if (v12 == qword_1E9EE5878 + 8 || v11 < *(void *)(v12 + 32)) {
LABEL_34:
  }
    uint64_t v12 = qword_1E9EE5878 + 8;
  uint64_t v16 = *(void *)(v12 + 40);
  *(void *)(v16 + 48) = 0;
  *(_OWORD *)(v16 + 16) = 0u;
  *(_OWORD *)(v16 + 32) = 0u;
  *(_OWORD *)uint64_t v16 = 0u;

  return pthread_mutex_unlock(&stru_1EB9A0498);
}

uint64_t HGTextureManager::renderEnd(HGTextureManager *this)
{
  (*(void (**)(void))(**((void **)this + 20) + 48))(*((void *)this + 20));
  HGTextureManager::_dumpMaxUsage(this);
  HGTextureManager::_dumpTextures(this, 0);
  unint64_t v2 = *((void *)this + 2);
  pthread_mutex_lock(&_MergedGlobals);
  if (!qword_1E9EE5870) {
    operator new();
  }
  uint64_t v3 = *(void **)(qword_1E9EE5870 + 8);
  if (!v3) {
    goto LABEL_15;
  }
  uint64_t v4 = qword_1E9EE5870 + 8;
  do
  {
    unint64_t v5 = v3[4];
    BOOL v6 = v5 >= v2;
    if (v5 >= v2) {
      uint64_t v7 = v3;
    }
    else {
      uint64_t v7 = v3 + 1;
    }
    if (v6) {
      uint64_t v4 = (uint64_t)v3;
    }
    uint64_t v3 = (void *)*v7;
  }
  while (*v7);
  if (v4 == qword_1E9EE5870 + 8 || *(void *)(v4 + 32) > v2) {
LABEL_15:
  }
    uint64_t v4 = qword_1E9EE5870 + 8;
  uint64_t v8 = *(void *)(v4 + 40);
  pthread_mutex_unlock(&_MergedGlobals);
  pthread_mutex_lock((pthread_mutex_t *)(v8 + 336));
  int v9 = *(_DWORD *)(v8 + 400) - 1;
  *(_DWORD *)(v8 + 40CVOpenGLESTextureCacheFlush(this[3], 0) = v9;
  if (v9)
  {
    uint64_t v10 = (pthread_mutex_t *)(v8 + 336);
  }
  else
  {
    pthread_mutex_lock((pthread_mutex_t *)(v8 + 128));
    *(unsigned char *)(v8 + 404) = 0;
    pthread_cond_signal((pthread_cond_t *)(v8 + 192));
    pthread_mutex_unlock((pthread_mutex_t *)(v8 + 128));
    uint64_t v10 = (pthread_mutex_t *)(v8 + 336);
  }
  return pthread_mutex_unlock(v10);
}

void HGTextureManager::_dumpMaxUsage(HGTextureManager *this)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v16, "texManager", 1, "HGTextureManager::_dumpMaxUsage()");
  HGTextureManager::_dumpMaxUsage(this, *((void *)this + 2));
  unsigned __int8 v3 = atomic_load(HGLogger::_enabled);
  if ((v3 & 1) != 0 && (int)HGLogger::getLevel((HGLogger *)"texManager", v2) >= 1)
  {
    unsigned __int8 v6 = atomic_load(HGLogger::_enabled);
    if (v6) {
      HGLogger::log((HGLogger *)"texManager", (const char *)1, (HGLogger *)"  max usage, per share group :\n", v4, v5);
    }
    pthread_mutex_lock(&stru_1EB9A0498);
    uint64_t v9 = qword_1E9EE5878;
    if (!qword_1E9EE5878) {
      operator new();
    }
    for (uint64_t i = *(void **)qword_1E9EE5878; ; uint64_t i = v14)
    {
      if (!v9) {
        operator new();
      }
      if (i == (void *)(v9 + 8)) {
        break;
      }
      unsigned __int8 v12 = atomic_load(HGLogger::_enabled);
      if (v12)
      {
        unint64_t v11 = (unint64_t *)i[5];
        HGLogger::log((HGLogger *)"texManager", (const char *)1, (HGLogger *)"total : %4.1f mb  |  used : %4.1f mb  |  active : %4.1f mb  |  shared : %4.1f mb  |  unowned : %4.1f mb  |  free : %4.1f mb  |  queued : %4.1f mb\n", v7, v8, (float)((float)*v11 * 0.00000095367), (float)((float)v11[1] * 0.00000095367), (float)((float)v11[2] * 0.00000095367), (float)((float)v11[3] * 0.00000095367), (float)((float)v11[4] * 0.00000095367), (float)((float)v11[5] * 0.00000095367), (float)((float)v11[6] * 0.00000095367));
      }
      unint64_t v13 = (void *)i[1];
      if (v13)
      {
        do
        {
          BOOL v14 = v13;
          unint64_t v13 = (void *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          BOOL v14 = (void *)i[2];
          BOOL v15 = *v14 == (void)i;
          uint64_t i = v14;
        }
        while (!v15);
      }
      uint64_t v9 = qword_1E9EE5878;
    }
    pthread_mutex_unlock(&stru_1EB9A0498);
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v16);
}

void sub_1B77DAB28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77DAB3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77DAB50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77DAB64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void HGTextureManager::_dumpTextures(HGTextureManager *this, char *a2)
{
  unsigned __int8 v18 = atomic_load(HGLogger::_enabled);
  if (v18)
  {
    unsigned __int8 v4 = atomic_load(HGLogger::_enabled);
    if (v4)
    {
      int Level = HGLogger::getLevel((HGLogger *)"texManager", a2);
      if (Level > 0)
      {
        unsigned __int8 v6 = HGTraceGuard::HGTraceGuard((HGTraceGuard *)v23, "texManager", 3, "HGTextureManager::_dumpTextures()");
        unint64_t v22 = 0;
        uint64x2_t v20 = 0u;
        uint64x2_t v21 = 0u;
        uint64x2_t v19 = 0u;
        if (Level < 4)
        {
          unsigned __int8 v9 = atomic_load(HGLogger::_enabled);
          if (v9) {
            HGLogger::log((HGLogger *)"texManager", (const char *)3, (HGLogger *)"usage summary :\n", v7, v8);
          }
          HGTextureManager::_printUsageSummary(v6, (const char *)3, a2, (HGTextureManager::TextureUsage *)&v19);
        }
        else
        {
          HGTextureManager::_printTextureList(this, (char *)4, a2, (HGTextureManager::TextureUsage *)&v19);
        }
        if (a2)
        {
          pthread_mutex_lock(&stru_1EB9A0498);
          if (!qword_1E9EE5878) {
            operator new();
          }
          uint64_t v10 = *(void **)(qword_1E9EE5878 + 8);
          if (!v10) {
            goto LABEL_25;
          }
          uint64_t v11 = qword_1E9EE5878 + 8;
          do
          {
            unint64_t v12 = v10[4];
            BOOL v13 = v12 >= (unint64_t)a2;
            if (v12 >= (unint64_t)a2) {
              BOOL v14 = v10;
            }
            else {
              BOOL v14 = v10 + 1;
            }
            if (v13) {
              uint64_t v11 = (uint64_t)v10;
            }
            uint64_t v10 = (void *)*v14;
          }
          while (*v14);
          if (v11 == qword_1E9EE5878 + 8 || *(void *)(v11 + 32) > (unint64_t)a2) {
LABEL_25:
          }
            uint64_t v11 = qword_1E9EE5878 + 8;
          BOOL v15 = *(uint64x2_t **)(v11 + 40);
          int8x16_t v16 = vbslq_s8((int8x16_t)vcgtq_u64(v15[1], v20), (int8x16_t)v15[1], (int8x16_t)v20);
          *(int8x16_t *)BOOL v15 = vbslq_s8((int8x16_t)vcgtq_u64(*v15, v19), *(int8x16_t *)v15, (int8x16_t)v19);
          v15[1] = (uint64x2_t)v16;
          void v15[2] = (uint64x2_t)vbslq_s8((int8x16_t)vcgtq_u64(v15[2], v21), (int8x16_t)v15[2], (int8x16_t)v21);
          unint64_t v17 = v15[3].u64[0];
          if (v17 <= v22) {
            unint64_t v17 = v22;
          }
          v15[3].i64[0] = v17;
          pthread_mutex_unlock(&stru_1EB9A0498);
        }
        HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v23);
      }
    }
  }
}

void sub_1B77DADF8(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 64));
  _Unwind_Resume(a1);
}

void sub_1B77DAE0C(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 64));
  _Unwind_Resume(a1);
}

void sub_1B77DAE20(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 64));
  _Unwind_Resume(a1);
}

uint64_t HGTextureManager::storageRecyclingPolicy(uint64_t result, int a2)
{
  *(_DWORD *)(result + 168) = a2;
  return result;
}

uint64_t HGTextureManager::recycleClientStorageTextures(uint64_t this, char a2)
{
  *(unsigned char *)(this + 172) = a2;
  return this;
}

uint64_t HGTextureManager::createRenderbuffer(HGTextureManager *this, unsigned int a2, uint64_t a3)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_174, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_174))
  {
    __cxa_guard_release(&_MergedGlobals_174);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9EE5868, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9EE5868))
  {
    qword_1E9EE5888 = 0;
    unk_1E9EE5890 = 0;
    qword_1E9EE5880 = 0;
    __cxa_atexit((void (*)(void *))RenderbufferCache::~RenderbufferCache, &qword_1E9EE5880, &dword_1B73F3000);
    __cxa_guard_release(&qword_1E9EE5868);
  }
  uint64_t Renderbuffer = RenderbufferCache::createRenderbuffer((RenderbufferCache *)&qword_1E9EE5880, v4, a3);
  return Renderbuffer;
}

void sub_1B77DAF40(_Unwind_Exception *a1)
{
}

void HGTextureManager::deleteRenderbuffer(HGTextureManager *this, uint64_t a2)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_174, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_174))
  {
    __cxa_guard_release(&_MergedGlobals_174);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9EE5868, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9EE5868))
  {
    qword_1E9EE5888 = 0;
    unk_1E9EE5890 = 0;
    qword_1E9EE5880 = 0;
    __cxa_atexit((void (*)(void *))RenderbufferCache::~RenderbufferCache, &qword_1E9EE5880, &dword_1B73F3000);
    __cxa_guard_release(&qword_1E9EE5868);
  }
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v9, "renderbuffer", 1, "deleteRenderbuffer()");
  uint64_t v5 = qword_1E9EE5880;
  if (qword_1E9EE5880 != qword_1E9EE5888)
  {
    while (*(_DWORD *)(v5 + 16) != a2)
    {
      v5 += 24;
      if (v5 == qword_1E9EE5888) {
        goto LABEL_10;
      }
    }
  }
  if (v5 == qword_1E9EE5888)
  {
LABEL_10:
    unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
    if (v8)
    {
      uint64_t v7 = "uh oh! unknown renderbuffer (%d)\n";
      goto LABEL_12;
    }
  }
  else
  {
    *(unsigned char *)(v5 + 2CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
    unsigned __int8 v6 = atomic_load(HGLogger::_enabled);
    if (v6)
    {
      uint64_t v7 = "done with renderbuffer (%d) - marking unused\n";
LABEL_12:
      HGLogger::log((HGLogger *)"renderbuffer", (const char *)1, (HGLogger *)v7, v3, v4, a2);
    }
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v9);
}

void sub_1B77DB0EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77DB10C(_Unwind_Exception *a1)
{
}

uint64_t HGTextureManager::adjustTextureSize(HGTextureManager *this, HGRect a2)
{
  return (*(uint64_t (**)(void, void, void))(**((void **)this + 19) + 40))(*((void *)this + 19), *(void *)&a2.var0, *(void *)&a2.var2);
}

void HGTextureManager::createTexture(HGTextureManager *this, unsigned int *a2, int a3)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v13, "texManager", 2, "createTexture()");
  ++*(_DWORD *)this;
  unint64_t v6 = *((void *)this + 2);
  pthread_mutex_lock(&_MergedGlobals);
  if (!qword_1E9EE5870) {
    operator new();
  }
  uint64_t v7 = *(void **)(qword_1E9EE5870 + 8);
  if (!v7) {
    goto LABEL_15;
  }
  uint64_t v8 = qword_1E9EE5870 + 8;
  do
  {
    unint64_t v9 = v7[4];
    BOOL v10 = v9 >= v6;
    if (v9 >= v6) {
      uint64_t v11 = v7;
    }
    else {
      uint64_t v11 = v7 + 1;
    }
    if (v10) {
      uint64_t v8 = (uint64_t)v7;
    }
    uint64_t v7 = (void *)*v11;
  }
  while (*v11);
  if (v8 == qword_1E9EE5870 + 8 || *(void *)(v8 + 32) > v6) {
LABEL_15:
  }
    uint64_t v8 = qword_1E9EE5870 + 8;
  unint64_t v12 = *(pthread_mutex_t **)(v8 + 40);
  pthread_mutex_unlock(&_MergedGlobals);
  if (v12[6].__opaque[12]) {
    TextureDeleteQueue::executeFinishedRequests(v12, 1);
  }
  if (HGTextureManager::_waitForOneQueuedTexture(this))
  {
    while ((HGTextureManager::_waitForOneQueuedTexture(this) & 1) != 0)
      ;
  }
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v14, "texManager", 2, "_poolPreAllocateTexture()");
  (*(void (**)(void, void, void, void, void, void))(**((void **)this + 20) + 40))(*((void *)this + 20), 0, 0, 0, 0, 0);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v14);
  HGTextureManager::_allocateTexture((HGGPURenderer **)this, a2, a3, 0, 0, 0, 0, 0);
  HGTextureManager::_dumpTextures(this, *((char **)this + 2));
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v13);
}

void sub_1B77DB38C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_1B77DB3A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B77DB3BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void HGTextureManager::_poolPreAllocateTexture(HGTextureManager *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v12, "texManager", 2, "_poolPreAllocateTexture()");
  (*(void (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(**((void **)this + 20) + 40))(*((void *)this + 20), a2, a3, a4, a5, a6);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v12);
}

void sub_1B77DB484(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void HGTextureManager::_allocateTexture(HGGPURenderer **this, unsigned int *a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v29, "texManager", 2, "_allocateTexture()");
  uint64_t GLState = HGGPURenderer::GetGLState(this[1]);
  HGGPURenderer::GetCurrentContext(this[1], (uint64_t *)&v27);
  HGGLState::SetCurrentContextGuard::SetCurrentContextGuard(v28, GLState, &v27);
  PCSharedCount::PCSharedCount(&v27);
  glGenTextures(1, a2);
  GLuint v17 = *a2;
  uint64_t v20 = HGGetTBC();
  uint64x2_t v21 = this[4];
  uint64_t v22 = *((void *)v21 + 12);
  uint64_t v23 = *((void *)v21 + 11);
  uint64_t v24 = 42 * ((v22 - v23) >> 3) - 1;
  if (v22 == v23) {
    uint64_t v24 = 0;
  }
  unint64_t v25 = *((void *)v21 + 15) + *((void *)v21 + 14);
  if (v24 == v25)
  {
    std::deque<HGTextureManager::TextureEntry>::__add_back_capacity((uint64_t)v21 + 80);
    uint64_t v23 = *((void *)v21 + 11);
    unint64_t v25 = *((void *)v21 + 15) + *((void *)v21 + 14);
  }
  unint64_t v26 = *(void *)(v23 + 8 * (v25 / 0x2A)) + 96 * (v25 % 0x2A);
  *(_DWORD *)unint64_t v26 = a3;
  *(_DWORD *)(v26 + 4) = a4;
  *(_DWORD *)(v26 + 8) = a5;
  *(_DWORD *)(v26 + 12) = a6;
  *(_DWORD *)(v26 + 16) = a7;
  *(_DWORD *)(v26 + 2CVOpenGLESTextureCacheFlush(this[3], 0) = a8;
  *(_OWORD *)(v26 + 24) = 0u;
  *(_OWORD *)(v26 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = 0u;
  *(_WORD *)(v26 + 56) = 0;
  *(_DWORD *)(v26 + 64) = v17;
  *(_WORD *)(v26 + 68) = 511;
  *(void *)(v26 + 72) = 1;
  *(_DWORD *)(v26 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *(void *)(v26 + 88) = v20;
  ++*((void *)v21 + 15);
  LOBYTE(v26) = atomic_load(HGLogger::_enabled);
  if (v26) {
    HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"allocating texture %d\n", v18, v19, *a2);
  }
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard(v28);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v29);
}

void sub_1B77DB680(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCSharedCount a11, PCSharedCount a12, uint64_t a13, uint64_t a14, char a15)
{
}

void HGTextureManager::createTexture(HGTextureManager *this, unsigned int *a2, const HGTextureManager::TextureInfo *a3)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v18, "texManager", 2, "createTexture( with size)");
  ++*(_DWORD *)this;
  unint64_t v6 = *((void *)this + 2);
  pthread_mutex_lock(&_MergedGlobals);
  if (!qword_1E9EE5870) {
    operator new();
  }
  uint64_t v7 = *(void **)(qword_1E9EE5870 + 8);
  if (!v7) {
    goto LABEL_15;
  }
  uint64_t v8 = qword_1E9EE5870 + 8;
  do
  {
    unint64_t v9 = v7[4];
    BOOL v10 = v9 >= v6;
    if (v9 >= v6) {
      uint64_t v11 = v7;
    }
    else {
      uint64_t v11 = v7 + 1;
    }
    if (v10) {
      uint64_t v8 = (uint64_t)v7;
    }
    uint64_t v7 = (void *)*v11;
  }
  while (*v11);
  if (v8 == qword_1E9EE5870 + 8 || *(void *)(v8 + 32) > v6) {
LABEL_15:
  }
    uint64_t v8 = qword_1E9EE5870 + 8;
  unint64_t v12 = *(pthread_mutex_t **)(v8 + 40);
  pthread_mutex_unlock(&_MergedGlobals);
  if (v12[6].__opaque[12]) {
    TextureDeleteQueue::executeFinishedRequests(v12, 1);
  }
  if ((HGTextureManager::_findTexture(this, a2, a3) & 1) == 0)
  {
    if (HG_RENDERER_ENV::WAIT_FOR_QUEUED_TEXTURE_ONE_BY_ONE)
    {
      while (HGTextureManager::_waitForOneQueuedTexture(this))
      {
        if (HGTextureManager::_findTexture(this, a2, a3)) {
          goto LABEL_26;
        }
      }
      goto LABEL_27;
    }
    if (!HGTextureManager::_waitForOneQueuedTexture(this)) {
      goto LABEL_27;
    }
    while ((HGTextureManager::_waitForOneQueuedTexture(this) & 1) != 0)
      ;
    if ((HGTextureManager::_findTexture(this, a2, a3) & 1) == 0)
    {
LABEL_27:
      uint64_t v13 = *((unsigned int *)a3 + 1);
      uint64_t v14 = *((unsigned int *)a3 + 2);
      uint64_t v15 = *((unsigned int *)a3 + 3);
      uint64_t v16 = *((unsigned int *)a3 + 4);
      uint64_t v17 = *((unsigned int *)a3 + 5);
      HGTraceGuard::HGTraceGuard((HGTraceGuard *)v19, "texManager", 2, "_poolPreAllocateTexture()");
      (*(void (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(**((void **)this + 20) + 40))(*((void *)this + 20), v13, v14, v15, v16, v17);
      HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v19);
      HGTextureManager::_allocateTexture((HGGPURenderer **)this, a2, *(_DWORD *)a3, *((_DWORD *)a3 + 1), *((_DWORD *)a3 + 2), *((_DWORD *)a3 + 3), *((_DWORD *)a3 + 4), *((_DWORD *)a3 + 5));
      goto LABEL_28;
    }
  }
LABEL_26:
  ++*((_DWORD *)this + 1);
LABEL_28:
  HGTextureManager::_dumpTextures(this, *((char **)this + 2));
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v18);
}

void sub_1B77DB924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_1B77DB940(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B77DB954(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B77DB968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HGTextureManager::_findTexture(HGTextureManager *this, unsigned int *a2, const HGTextureManager::TextureInfo *a3)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v76, "texManager", 2, "_findTexture()");
  unint64_t v6 = *((void *)this + 2);
    operator new();
  if (!v7) {
    goto LABEL_15;
  }
  do
  {
    unint64_t v9 = v7[4];
    BOOL v10 = v9 >= v6;
    if (v9 >= v6) {
      uint64_t v11 = v7;
    }
    else {
      uint64_t v11 = v7 + 1;
    }
    if (v10) {
      uint64_t v8 = (uint64_t)v7;
    }
    uint64_t v7 = (void *)*v11;
  }
  while (*v11);
LABEL_15:
  uint64_t v12 = *(void *)(v8 + 40);
  pthread_mutex_lock((pthread_mutex_t *)(v12 + 16));
  uint64_t v13 = *(void *)(v12 + 120);
  if (!v13)
  {
LABEL_100:
    uint64_t v47 = 0;
    goto LABEL_129;
  }
  unsigned int v14 = *((_DWORD *)this + 42);
  if (v14 < 2)
  {
    unint64_t v15 = *(void *)(v12 + 112);
    uint64_t v29 = v15 + v13;
    unint64_t v30 = (v15 + v13) >> 1;
    unint64_t v31 = (v15 + v13) / 0x2A;
    uint64_t v19 = *(void *)(v12 + 88);
    uint64_t v20 = *(void *)(v12 + 96);
    uint64x2_t v21 = (uint64_t *)(v19 + 8 * v31);
    if (v14 == 1)
    {
      if (v20 != v19)
      {
        uint64_t v32 = *v21;
        unint64_t v24 = *v21 + 96 * (v29 - 42 * ((unint64_t)((v30 * (unsigned __int128)0xC30C30C30C30C30DLL) >> 64) >> 4));
        unint64_t v33 = *(void *)(v19 + 8 * (v15 / 0x2A)) + 96 * (v15 % 0x2A);
        if (v24 == v33) {
          goto LABEL_104;
        }
        int v34 = *(_DWORD *)a3;
        while (1)
        {
          uint64_t v35 = v24;
          if (v24 == v32)
          {
            uint64_t v35 = *(v21 - 1) + 4032;
            if (v34 != *(_DWORD *)(*(v21 - 1) + 3936)) {
              goto LABEL_46;
            }
          }
          else if (v34 != *(_DWORD *)(v24 - 96))
          {
            goto LABEL_46;
          }
          if (*((_DWORD *)a3 + 1) == *(_DWORD *)(v35 - 92)
            && *((_DWORD *)a3 + 2) == *(_DWORD *)(v35 - 88)
            && *((_DWORD *)a3 + 4) == *(_DWORD *)(v35 - 80)
            && *((_DWORD *)a3 + 5) == *(_DWORD *)(v35 - 76)
            && (*((void *)a3 + 3) == 0) != (*(void *)(v35 - 72) != 0)
            && *((unsigned __int8 *)a3 + 57) == *(unsigned __int8 *)(v35 - 39)
            && *((unsigned __int8 *)a3 + 56) == *(unsigned __int8 *)(v35 - 40))
          {
            goto LABEL_104;
          }
LABEL_46:
          if (v24 == v32)
          {
            uint64_t v36 = *--v21;
            uint64_t v32 = v36;
            unint64_t v24 = v36 + 3936;
            if (v36 + 3936 == v33) {
              goto LABEL_98;
            }
          }
          else
          {
            v24 -= 96;
            if (v24 == v33) {
              goto LABEL_98;
            }
          }
        }
      }
LABEL_101:
      unint64_t v24 = 0;
      if (v20 != v19) {
        goto LABEL_105;
      }
LABEL_99:
      if (v24) {
        goto LABEL_106;
      }
      goto LABEL_100;
    }
    if (v20 == v19) {
      goto LABEL_101;
    }
    uint64_t v43 = *(void *)(v19 + 8 * v31);
    unint64_t v24 = v43 + 96 * (v29 - 42 * v31);
    unint64_t v33 = *(void *)(v19 + 8 * (v15 / 0x2A)) + 96 * (v15 % 0x2A);
    if (v24 == v33) {
      goto LABEL_104;
    }
    int v44 = *(_DWORD *)a3;
    while (1)
    {
      uint64_t v45 = v24;
      if (v24 == v43)
      {
        uint64_t v45 = *(v21 - 1) + 4032;
        if (v44 != *(_DWORD *)(*(v21 - 1) + 3936)) {
          goto LABEL_86;
        }
      }
      else if (v44 != *(_DWORD *)(v24 - 96))
      {
        goto LABEL_86;
      }
      if (*((_DWORD *)a3 + 1) == *(_DWORD *)(v45 - 92)
        && *((_DWORD *)a3 + 2) == *(_DWORD *)(v45 - 88)
        && *((_DWORD *)a3 + 4) == *(_DWORD *)(v45 - 80)
        && *((_DWORD *)a3 + 5) == *(_DWORD *)(v45 - 76))
      {
        goto LABEL_104;
      }
LABEL_86:
      if (v24 == v43)
      {
        uint64_t v46 = *--v21;
        uint64_t v43 = v46;
        unint64_t v24 = v46 + 3936;
        if (v46 + 3936 == v33)
        {
LABEL_98:
          unint64_t v24 = v33;
          if (v20 == v19) {
            goto LABEL_99;
          }
          goto LABEL_105;
        }
      }
      else
      {
        v24 -= 96;
        if (v24 == v33) {
          goto LABEL_98;
        }
      }
    }
  }
  unint64_t v15 = *(void *)(v12 + 112);
  uint64_t v16 = v15 + v13;
  unint64_t v17 = (v15 + v13) >> 1;
  unint64_t v18 = (v15 + v13) / 0x2A;
  uint64_t v19 = *(void *)(v12 + 88);
  uint64_t v20 = *(void *)(v12 + 96);
  uint64x2_t v21 = (uint64_t *)(v19 + 8 * v18);
  if (v14 != 2 || (uint64_t v22 = *((void *)a3 + 5)) == 0)
  {
    if (v20 == v19)
    {
      unint64_t v24 = 0;
    }
    else
    {
      uint64_t v37 = *(void *)(v19 + 8 * v18);
      unint64_t v24 = v37 + 96 * (v16 - 42 * v18);
      unint64_t v33 = *(void *)(v19 + 8 * (v15 / 0x2A)) + 96 * (v15 % 0x2A);
      if (v24 != v33)
      {
        int v38 = *(_DWORD *)a3;
        uint64_t v39 = *((void *)a3 + 3);
        while (1)
        {
          uint64_t v40 = v24;
          if (v24 == v37)
          {
            uint64_t v40 = *(v21 - 1) + 4032;
            if (v38 != *(_DWORD *)(*(v21 - 1) + 3936)) {
              goto LABEL_65;
            }
          }
          else if (v38 != *(_DWORD *)(v24 - 96))
          {
            goto LABEL_65;
          }
          if (*((_DWORD *)a3 + 1) == *(_DWORD *)(v40 - 92)
            && *((_DWORD *)a3 + 2) == *(_DWORD *)(v40 - 88)
            && *((_DWORD *)a3 + 4) == *(_DWORD *)(v40 - 80)
            && *((_DWORD *)a3 + 5) == *(_DWORD *)(v40 - 76))
          {
            uint64_t v41 = *(void *)(v40 - 72);
            if ((v39 == 0) != (v41 != 0)
              && *((unsigned __int8 *)a3 + 57) == *(unsigned __int8 *)(v40 - 39)
              && v39 == v41
              && *((unsigned __int8 *)a3 + 56) == *(unsigned __int8 *)(v40 - 40)
              && *((void *)a3 + 4) == *(void *)(v40 - 64))
            {
              break;
            }
          }
LABEL_65:
          if (v24 == v37)
          {
            uint64_t v42 = *--v21;
            uint64_t v37 = v42;
            unint64_t v24 = v42 + 3936;
            if (v42 + 3936 == v33) {
              goto LABEL_98;
            }
          }
          else
          {
            v24 -= 96;
            if (v24 == v33) {
              goto LABEL_98;
            }
          }
        }
      }
    }
LABEL_104:
    if (v20 == v19) {
      goto LABEL_99;
    }
    goto LABEL_105;
  }
  if (v20 == v19) {
    goto LABEL_101;
  }
  uint64_t v23 = *v21;
  unint64_t v24 = *v21 + 96 * (v16 - 42 * ((unint64_t)((v17 * (unsigned __int128)0xC30C30C30C30C30DLL) >> 64) >> 4));
  unint64_t v25 = *(void *)(v19 + 8 * (v15 / 0x2A)) + 96 * (v15 % 0x2A);
  if (v24 == v25) {
    goto LABEL_104;
  }
  int v26 = *(_DWORD *)a3;
  do
  {
    while (1)
    {
      uint64_t v27 = v24;
      if (v24 == v23)
      {
        uint64_t v27 = *(v21 - 1) + 4032;
        if (v26 != *(_DWORD *)(*(v21 - 1) + 3936)) {
          goto LABEL_23;
        }
      }
      else if (v26 != *(_DWORD *)(v24 - 96))
      {
        goto LABEL_23;
      }
      if (*((_DWORD *)a3 + 1) == *(_DWORD *)(v27 - 92)
        && *((_DWORD *)a3 + 2) == *(_DWORD *)(v27 - 88)
        && *((_DWORD *)a3 + 4) == *(_DWORD *)(v27 - 80)
        && *((_DWORD *)a3 + 5) == *(_DWORD *)(v27 - 76)
        && (*((void *)a3 + 3) == 0) != (*(void *)(v27 - 72) != 0)
        && *((unsigned __int8 *)a3 + 57) == *(unsigned __int8 *)(v27 - 39)
        && *((unsigned __int8 *)a3 + 56) == *(unsigned __int8 *)(v27 - 40)
        && v22 == *(void *)(v27 - 56)
        && *((void *)a3 + 6) == *(void *)(v27 - 48))
      {
        goto LABEL_104;
      }
LABEL_23:
      if (v24 == v23) {
        break;
      }
      v24 -= 96;
      if (v24 == v25) {
        goto LABEL_40;
      }
    }
    uint64_t v28 = *--v21;
    uint64_t v23 = v28;
    unint64_t v24 = v28 + 3936;
  }
  while (v28 + 3936 != v25);
LABEL_40:
  unint64_t v24 = *(void *)(v19 + 8 * (v15 / 0x2A)) + 96 * (v15 % 0x2A);
  if (v20 == v19) {
    goto LABEL_99;
  }
LABEL_105:
  if (v24 == *(void *)(v19 + 8 * (v15 / 0x2A)) + 96 * (v15 % 0x2A)) {
    goto LABEL_100;
  }
LABEL_106:
  uint64_t v48 = v24 - *v21;
  unint64_t v49 = 0xAAAAAAAAAAAAAAABLL * (v48 >> 5);
  if (v48 < 97)
  {
    unint64_t v55 = 42 - v49;
    float32x4_t v51 = &v21[-(v55 / 0x2A)];
    unint64_t v56 = 42 * (v55 / 0x2A) - v55;
    uint64_t v52 = *v51 + 96 * v56 + 3936;
    *a2 = *(_DWORD *)(*v51 + 96 * v56 + 4000);
    if (*(unsigned char *)(v52 + 56) == 2) {
      goto LABEL_112;
    }
LABEL_108:
    unint64_t v53 = *(int *)(v52 + 76);
    if (!*(unsigned char *)(v52 + 69))
    {
      double v54 = (void *)(v12 + 160);
      goto LABEL_114;
    }
    *(int64x2_t *)(v12 + 128) = vsubq_s64(*(int64x2_t *)(v12 + 128), vdupq_n_s64(v53));
    if ((*(char *)(v52 + 68) & 0x80000000) == 0)
    {
      double v54 = (void *)(v12 + 144);
      goto LABEL_114;
    }
  }
  else
  {
    unint64_t v50 = v49 - 1;
    float32x4_t v51 = &v21[v50 / 0x2A];
    uint64_t v52 = *v51 + 96 * (v50 % 0x2A);
    *a2 = *(_DWORD *)(v52 + 64);
    if (*(unsigned char *)(v52 + 56) != 2) {
      goto LABEL_108;
    }
LABEL_112:
    unint64_t v53 = *(int *)(v52 + 76);
    double v54 = (void *)(v12 + 152);
LABEL_114:
    *v54 -= v53;
  }
  *(unsigned char *)(v52 + 68) = -1;
  ++*(_DWORD *)(v52 + 72);
  *(_DWORD *)(v52 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  uint64_t v57 = HGGetTBC();
  uint64_t v59 = (void *)*((void *)this + 4);
  uint64_t v60 = v59[12];
  uint64_t v61 = v59[11];
  uint64_t v62 = 42 * ((v60 - v61) >> 3) - 1;
  *(void *)(v52 + 88) = v57;
  if (v60 == v61) {
    uint64_t v62 = 0;
  }
  unint64_t v63 = v59[15] + v59[14];
  if (v62 == v63)
  {
    std::deque<HGTextureManager::TextureEntry>::__add_back_capacity((uint64_t)(v59 + 10));
    uint64_t v61 = v59[11];
    unint64_t v63 = v59[15] + v59[14];
  }
  long long v64 = (_OWORD *)(*(void *)(v61 + 8 * (v63 / 0x2A)) + 96 * (v63 % 0x2A));
  long long v65 = *(_OWORD *)(v52 + 16);
  *long long v64 = *(_OWORD *)v52;
  v64[1] = v65;
  long long v66 = *(_OWORD *)(v52 + 32);
  long long v67 = *(_OWORD *)(v52 + 48);
  long long v68 = *(_OWORD *)(v52 + 80);
  v64[4] = *(_OWORD *)(v52 + 64);
  v64[5] = v68;
  void v64[2] = v66;
  v64[3] = v67;
  ++v59[15];
  float32x4_t v69 = (int64x2_t *)*((void *)this + 4);
  if (*(unsigned char *)(v52 + 56) == 2)
  {
    unint64_t v70 = *(int *)(v52 + 76);
    float32x4_t v71 = (int64x2_t *)((char *)v69 + 152);
    goto LABEL_125;
  }
  unint64_t v70 = *(int *)(v52 + 76);
  if (*(unsigned char *)(v52 + 69))
  {
    v69[8] = vaddq_s64(v69[8], vdupq_n_s64(v70));
    if ((*(char *)(v52 + 68) & 0x80000000) == 0)
    {
      float32x4_t v71 = v69 + 9;
      goto LABEL_125;
    }
  }
  else
  {
    float32x4_t v71 = v69 + 10;
LABEL_125:
    v71->i64[0] += v70;
  }
  HGTextureManager::TextureEntry::log((HGTextureManager::TextureEntry *)v52, (const char *)2, v58);
  std::deque<HGTextureManager::TextureEntry>::erase((int64x2_t *)(v12 + 80), v51, (char *)v52);
  unsigned __int8 v74 = atomic_load(HGLogger::_enabled);
  if (v74) {
    HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"re-using texture %d.  GREAT!!\n", v72, v73, *a2);
  }
  uint64_t v47 = 1;
LABEL_129:
  pthread_mutex_unlock((pthread_mutex_t *)(v12 + 16));
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v76);
  return v47;
}

void sub_1B77DC2D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  pthread_mutex_unlock(v11);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a11);
  _Unwind_Resume(a1);
}

uint64_t HGTextureManager::_waitForOneQueuedTexture(HGTextureManager *this)
{
  unint64_t v2 = *((void *)this + 2);
  pthread_mutex_lock(&_MergedGlobals);
  if (!qword_1E9EE5870) {
    operator new();
  }
  unsigned __int8 v3 = *(void **)(qword_1E9EE5870 + 8);
  if (!v3) {
    goto LABEL_15;
  }
  uint64_t v4 = qword_1E9EE5870 + 8;
  do
  {
    unint64_t v5 = v3[4];
    BOOL v6 = v5 >= v2;
    if (v5 >= v2) {
      uint64_t v7 = v3;
    }
    else {
      uint64_t v7 = v3 + 1;
    }
    if (v6) {
      uint64_t v4 = (uint64_t)v3;
    }
    unsigned __int8 v3 = (void *)*v7;
  }
  while (*v7);
  if (v4 == qword_1E9EE5870 + 8 || *(void *)(v4 + 32) > v2) {
LABEL_15:
  }
    uint64_t v4 = qword_1E9EE5870 + 8;
  uint64_t v8 = *(void *)(v4 + 40);
  pthread_mutex_unlock(&_MergedGlobals);
  int v9 = *(unsigned __int8 *)(v8 + 404);
  pthread_mutex_lock((pthread_mutex_t *)(v8 + 128));
  uint64_t v10 = *(void *)(v8 + 120);
  pthread_mutex_unlock((pthread_mutex_t *)(v8 + 128));
  if (v9)
  {
    if (v10)
    {
      HGTextureManager::_getQueuedTotalTextureUsage(*((void *)this + 2), &v12);
      if ((float)((float)*((unint64_t *)this + 18) * 0.8) < (float)v13
        || (*(unsigned int (**)(void))(**((void **)this + 20) + 56))(*((void *)this + 20)))
      {
        pthread_mutex_lock((pthread_mutex_t *)(v8 + 128));
        if (*(void *)(v8 + 120))
        {
          TextureDeleteQueue::_popFrontRequest((TextureDeleteQueue *)v8, (uint64_t)&v12);
          pthread_mutex_unlock((pthread_mutex_t *)(v8 + 128));
          TextureDeleteQueue::DeleteRequest::execute((TextureDeleteQueue::DeleteRequest *)&v12);
          return 1;
        }
LABEL_27:
        pthread_mutex_unlock((pthread_mutex_t *)(v8 + 128));
        return 1;
      }
    }
  }
  else if (v10)
  {
    HGTextureManager::_getQueuedTotalTextureUsage(*((void *)this + 2), &v12);
    if ((float)((float)*((unint64_t *)this + 18) * 0.8) < (float)v13
      || (*(unsigned int (**)(void))(**((void **)this + 20) + 56))(*((void *)this + 20)))
    {
      pthread_mutex_lock((pthread_mutex_t *)(v8 + 128));
      if (*(void *)(v8 + 120)) {
        pthread_cond_wait((pthread_cond_t *)(v8 + 288), (pthread_mutex_t *)(v8 + 128));
      }
      goto LABEL_27;
    }
  }
  return 0;
}

void HGTextureManager::deleteTexture(HGTextureManager *this, const unsigned int *a2, char *a3, const char *a4)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v59, "texManager", 2, "deleteTexture()");
  unsigned __int8 v10 = atomic_load(HGLogger::_enabled);
  if (v10) {
    HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"deleting texture %d\n", v8, v9, *a2);
  }
  unint64_t v11 = *((void *)this + 2);
  pthread_mutex_lock(&_MergedGlobals);
  if (!qword_1E9EE5870) {
    operator new();
  }
  uint64_t v12 = *(void **)(qword_1E9EE5870 + 8);
  if (!v12) {
    goto LABEL_17;
  }
  uint64_t v13 = qword_1E9EE5870 + 8;
  do
  {
    unint64_t v14 = v12[4];
    BOOL v15 = v14 >= v11;
    if (v14 >= v11) {
      uint64_t v16 = v12;
    }
    else {
      uint64_t v16 = v12 + 1;
    }
    if (v15) {
      uint64_t v13 = (uint64_t)v12;
    }
    uint64_t v12 = (void *)*v16;
  }
  while (*v16);
  if (v13 == qword_1E9EE5870 + 8 || *(void *)(v13 + 32) > v11) {
LABEL_17:
  }
    uint64_t v13 = qword_1E9EE5870 + 8;
  unint64_t v17 = *(pthread_mutex_t **)(v13 + 40);
  pthread_mutex_unlock(&_MergedGlobals);
  if (v17[6].__opaque[12]) {
    TextureDeleteQueue::executeFinishedRequests(v17, 1);
  }
  uint64_t v20 = (int64x2_t *)*((void *)this + 4);
  uint64_t v21 = v20[5].i64[1];
  if (v20[6].i64[0] != v21)
  {
    unint64_t v22 = v20[7].u64[0];
    uint64_t v23 = (void *)(v21 + 8 * (v22 / 0x2A));
    unint64_t v24 = *v23 + 96 * (v22 % 0x2A);
    unint64_t v25 = v20[7].i64[1] + v22;
    unint64_t v26 = v25 / 0x2A;
    uint64_t v27 = *(void *)(v21 + 8 * (v25 / 0x2A));
    unint64_t v28 = v25 % 0x2A;
    unint64_t v29 = v27 + 96 * v28;
    if (v24 != v29)
    {
      while (*(_DWORD *)(v24 + 64) != *a2)
      {
        v24 += 96;
        if (v24 - *v23 == 4032)
        {
          unint64_t v30 = v23[1];
          ++v23;
          unint64_t v24 = v30;
        }
        if (v24 == v29)
        {
          unint64_t v24 = v29;
          break;
        }
      }
    }
    if (v24 != *(void *)(v21 + 8 * v26) + 96 * v28)
    {
      if (*(unsigned char *)(v24 + 56) == 2)
      {
        unint64_t v31 = *(int *)(v24 + 76);
        uint64_t v32 = (int64x2_t *)((char *)v20 + 152);
      }
      else
      {
        unint64_t v31 = *(int *)(v24 + 76);
        if (*(unsigned char *)(v24 + 69))
        {
          v20[8] = vsubq_s64(v20[8], vdupq_n_s64(v31));
          if (*(char *)(v24 + 68) < 0) {
            goto LABEL_38;
          }
          uint64_t v32 = v20 + 9;
        }
        else
        {
          uint64_t v32 = v20 + 10;
        }
      }
      v32->i64[0] -= v31;
LABEL_38:
      *(unsigned char *)(v24 + 68) = -1;
      *(_DWORD *)(v24 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = 2;
      *(void *)(v24 + 88) = HGGetTBC();
      if (*(_DWORD *)(v24 + 4)
        && *(_DWORD *)(v24 + 8)
        && *(_DWORD *)(v24 + 16)
        && *(_DWORD *)(v24 + 20)
        && *(_DWORD *)(v24 + 12)
        && (!*(unsigned char *)(v24 + 57) || *((unsigned char *)this + 172)))
      {
        unsigned __int8 v36 = atomic_load(HGLogger::_enabled);
        if (v36) {
          HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"queueing add to free textures pool: %d\n", v34, v35, *(unsigned int *)(v24 + 64));
        }
        unint64_t v37 = *((void *)this + 2);
        pthread_mutex_lock(&_MergedGlobals);
        if (!qword_1E9EE5870) {
          operator new();
        }
        int v38 = *(void **)(qword_1E9EE5870 + 8);
        if (!v38) {
          goto LABEL_81;
        }
        uint64_t v39 = qword_1E9EE5870 + 8;
        do
        {
          unint64_t v40 = v38[4];
          BOOL v41 = v40 >= v37;
          if (v40 >= v37) {
            uint64_t v42 = v38;
          }
          else {
            uint64_t v42 = v38 + 1;
          }
          if (v41) {
            uint64_t v39 = (uint64_t)v38;
          }
          int v38 = (void *)*v42;
        }
        while (*v42);
        if (v39 == qword_1E9EE5870 + 8 || *(void *)(v39 + 32) > v37) {
LABEL_81:
        }
          uint64_t v39 = qword_1E9EE5870 + 8;
        uint64_t v50 = *(void *)(v39 + 40);
        pthread_mutex_unlock(&_MergedGlobals);
        char v51 = 1;
        uint64_t v52 = &v57;
      }
      else
      {
        unsigned __int8 v43 = atomic_load(HGLogger::_enabled);
        if (v43) {
          HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"null size, queueing delete %d\n", v34, v35, *(unsigned int *)(v24 + 64));
        }
        unint64_t v44 = *((void *)this + 2);
        pthread_mutex_lock(&_MergedGlobals);
        if (!qword_1E9EE5870) {
          operator new();
        }
        uint64_t v45 = *(void **)(qword_1E9EE5870 + 8);
        if (!v45) {
          goto LABEL_76;
        }
        uint64_t v46 = qword_1E9EE5870 + 8;
        do
        {
          unint64_t v47 = v45[4];
          BOOL v48 = v47 >= v44;
          if (v47 >= v44) {
            unint64_t v49 = v45;
          }
          else {
            unint64_t v49 = v45 + 1;
          }
          if (v48) {
            uint64_t v46 = (uint64_t)v45;
          }
          uint64_t v45 = (void *)*v49;
        }
        while (*v49);
        if (v46 == qword_1E9EE5870 + 8 || *(void *)(v46 + 32) > v44) {
LABEL_76:
        }
          uint64_t v46 = qword_1E9EE5870 + 8;
        uint64_t v50 = *(void *)(v46 + 40);
        pthread_mutex_unlock(&_MergedGlobals);
        char v51 = 0;
        uint64_t v52 = &v58;
      }
      long long v53 = *(_OWORD *)(v24 + 16);
      *(_OWORD *)uint64_t v52 = *(_OWORD *)v24;
      *((_OWORD *)v52 + 1) = v53;
      long long v54 = *(_OWORD *)(v24 + 32);
      long long v55 = *(_OWORD *)(v24 + 48);
      long long v56 = *(_OWORD *)(v24 + 80);
      *((_OWORD *)v52 + 4) = *(_OWORD *)(v24 + 64);
      *((_OWORD *)v52 + 5) = v56;
      *((_OWORD *)v52 + 2) = v54;
      *((_OWORD *)v52 + 3) = v55;
      TextureDeleteQueue::enqueueDelete(v50, (uint64_t)this, (uint64_t)v52, a4, a3, 1, v51);
      std::deque<HGTextureManager::TextureEntry>::erase(v20 + 5, v23, (char *)v24);
      goto LABEL_79;
    }
  }
  unsigned __int8 v33 = atomic_load(HGLogger::_enabled);
  if (v33) {
    HGLogger::log((HGLogger *)"texManager", (const char *)1, (HGLogger *)"ERROR deleting texture ID %d, texture not found!\n", v18, v19, *a2);
  }
LABEL_79:
  HGTextureManager::_dumpTextures(this, *((char **)this + 2));
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v59);
}

void sub_1B77DCA30(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 96));
  _Unwind_Resume(a1);
}

void sub_1B77DCA44(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 96));
  _Unwind_Resume(a1);
}

void **std::deque<HGTextureManager::TextureEntry>::erase(int64x2_t *a1, void *a2, char *a3)
{
  unint64_t v6 = a1[2].u64[0];
  uint64_t v7 = a1->i64[1];
  uint64_t v8 = a1[1].i64[0];
  int v9 = (const void **)(v7 + 8 * (v6 / 0x2A));
  if (v8 != v7)
  {
    unsigned __int8 v10 = (char *)*v9 + 96 * (v6 % 0x2A);
    if (a3 != v10) {
      goto LABEL_3;
    }
LABEL_9:
    unint64_t v13 = 0;
    uint64_t v12 = *v9;
    goto LABEL_10;
  }
  unsigned __int8 v10 = 0;
  if (!a3) {
    goto LABEL_9;
  }
LABEL_3:
  uint64_t v11 = 42 * ((const void **)a2 - v9) - 0x5555555555555555 * ((uint64_t)&a3[-*a2] >> 5);
  uint64_t v12 = *v9;
  unint64_t v13 = v11 + 0x5555555555555555 * ((v10 - (unsigned char *)*v9) >> 5);
  if (!v13)
  {
LABEL_10:
    char v22 = 1;
    unint64_t v14 = (const void **)(v7 + 8 * (v6 / 0x2A));
    BOOL v15 = (const void **)v10;
    goto LABEL_13;
  }
  if (v11 < 1)
  {
    unint64_t v14 = &v9[-((41 - v11) / 0x2AuLL)];
    uint64_t v12 = *v14;
    BOOL v15 = (const void **)((char *)*v14 + 96 * (42 * ((41 - v11) / 0x2AuLL) - (41 - v11)) + 3936);
    uint64_t v16 = a1[2].i64[1];
    if (v13 > (unint64_t)(v16 - 1) >> 1) {
      goto LABEL_6;
    }
  }
  else
  {
    unint64_t v14 = &v9[v11 / 0x2AuLL];
    uint64_t v12 = *v14;
    BOOL v15 = (const void **)((char *)*v14 + 96 * (v11 % 0x2AuLL));
    uint64_t v16 = a1[2].i64[1];
    if (v13 > (unint64_t)(v16 - 1) >> 1)
    {
LABEL_6:
      uint64_t v17 = (char *)v15 - v12;
      unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * (((char *)v15 - v12) >> 5);
      if (v17 < -95)
      {
        unint64_t v35 = 40 - v18;
        uint64_t v20 = &v14[-(v35 / 0x2A)];
        uint64_t v21 = (char *)*v20 + 96 * (42 * (v35 / 0x2A) - v35) + 3936;
      }
      else
      {
        unint64_t v19 = v18 + 1;
        uint64_t v20 = &v14[v19 / 0x2A];
        uint64_t v21 = (char *)*v20 + 96 * (v19 % 0x2A);
      }
      unint64_t v36 = v16 + v6;
      unint64_t v37 = (v16 + v6) / 0x2A;
      int v38 = (const void **)(v7 + 8 * v37);
      if (v8 == v7) {
        uint64_t v39 = 0;
      }
      else {
        uint64_t v39 = (char *)*v38 + 96 * (v36 - 42 * v37);
      }
      v43[0] = v14;
      v43[1] = v15;
      std::__for_each_segment[abi:ne180100]<std::__deque_iterator<HGTextureManager::TextureEntry,HGTextureManager::TextureEntry*,HGTextureManager::TextureEntry&,HGTextureManager::TextureEntry**,long,42l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<std::__deque_iterator<HGTextureManager::TextureEntry,HGTextureManager::TextureEntry*,HGTextureManager::TextureEntry&,HGTextureManager::TextureEntry**,long,42l>,std::__deque_iterator<HGTextureManager::TextureEntry,HGTextureManager::TextureEntry*,HGTextureManager::TextureEntry&,HGTextureManager::TextureEntry**,long,42l>>>(v20, v21, v38, v39, (uint64_t)v43);
      unint64_t v31 = (void **)a1->i64[1];
      unint64_t v40 = (void **)a1[1].i64[0];
      uint64_t v41 = 42 * (v40 - v31) - 1;
      unint64_t v30 = a1[2].u64[0];
      uint64_t v42 = a1[2].i64[1];
      a1[2].i64[1] = v42 - 1;
      if (v40 == v31) {
        uint64_t v41 = 0;
      }
      if (v41 - (v42 + v30) + 1 >= 0x54)
      {
        operator delete(*(v40 - 1));
        char v22 = 0;
        unint64_t v31 = (void **)a1->i64[1];
        a1[1].i64[0] -= 8;
        unint64_t v30 = a1[2].u64[0];
      }
      else
      {
        char v22 = 0;
      }
      goto LABEL_18;
    }
  }
  char v22 = 0;
LABEL_13:
  uint64_t v23 = (char *)v15 - v12;
  unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * (((char *)v15 - v12) >> 5);
  if (v23 < -95)
  {
    unint64_t v28 = 40 - v24;
    unint64_t v26 = &v14[-(v28 / 0x2A)];
    uint64_t v27 = (char *)*v26 + 96 * (42 * (v28 / 0x2A) - v28) + 3936;
  }
  else
  {
    unint64_t v25 = v24 + 1;
    unint64_t v26 = &v14[v25 / 0x2A];
    uint64_t v27 = (char *)*v26 + 96 * (v25 % 0x2A);
  }
  std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<HGTextureManager::TextureEntry,HGTextureManager::TextureEntry*,HGTextureManager::TextureEntry&,HGTextureManager::TextureEntry**,long,42l>,std::__deque_iterator<HGTextureManager::TextureEntry,HGTextureManager::TextureEntry*,HGTextureManager::TextureEntry&,HGTextureManager::TextureEntry**,long,42l>,0>(v9, v10, v14, (char *)v15, v26, v27, v43);
  int64x2_t v29 = vaddq_s64(a1[2], (int64x2_t)xmmword_1B7E73580);
  a1[2] = v29;
  unint64_t v30 = v29.i64[0];
  unint64_t v31 = (void **)a1->i64[1];
  if (v29.i64[0] >= 0x54uLL)
  {
    operator delete(*v31);
    unint64_t v31 = (void **)(a1->i64[1] + 8);
    a1->i64[1] = (uint64_t)v31;
    unint64_t v30 = a1[2].i64[0] - 42;
    a1[2].i64[0] = v30;
  }
LABEL_18:
  double result = &v31[v30 / 0x2A];
  if ((void **)a1[1].i64[0] == v31)
  {
    unint64_t v33 = 0;
    if (v22) {
      return result;
    }
  }
  else
  {
    unint64_t v33 = (unint64_t)*result + 96 * (v30 % 0x2A);
    if (v22) {
      return result;
    }
  }
  uint64_t v34 = v13 - 0x5555555555555555 * ((uint64_t)(v33 - (void)*result) >> 5);
  if (v34 < 1) {
    result -= (41 - v34) / 0x2AuLL;
  }
  else {
    result += v34 / 0x2AuLL;
  }
  return result;
}

void HGTextureManager::dismissTexture(HGTextureManager *this, const unsigned int *a2, char *a3, const char *a4)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v32, "texManager", 2, "dismissTexture()");
  unsigned __int8 v10 = atomic_load(HGLogger::_enabled);
  if (v10) {
    HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"dismiss texture %d\n", v8, v9, *a2);
  }
  unint64_t v11 = *((void *)this + 2);
  pthread_mutex_lock(&_MergedGlobals);
  if (!qword_1E9EE5870) {
    operator new();
  }
  uint64_t v12 = *(void **)(qword_1E9EE5870 + 8);
  if (!v12) {
    goto LABEL_17;
  }
  uint64_t v13 = qword_1E9EE5870 + 8;
  do
  {
    unint64_t v14 = v12[4];
    BOOL v15 = v14 >= v11;
    if (v14 >= v11) {
      uint64_t v16 = v12;
    }
    else {
      uint64_t v16 = v12 + 1;
    }
    if (v15) {
      uint64_t v13 = (uint64_t)v12;
    }
    uint64_t v12 = (void *)*v16;
  }
  while (*v16);
  if (v13 == qword_1E9EE5870 + 8 || *(void *)(v13 + 32) > v11) {
LABEL_17:
  }
    uint64_t v13 = qword_1E9EE5870 + 8;
  uint64_t v17 = *(pthread_mutex_t **)(v13 + 40);
  pthread_mutex_unlock(&_MergedGlobals);
  if (v17[6].__opaque[12]) {
    TextureDeleteQueue::executeFinishedRequests(v17, 1);
  }
  int v18 = *a2;
  unint64_t v19 = *((void *)this + 2);
  pthread_mutex_lock(&_MergedGlobals);
  if (!qword_1E9EE5870) {
    operator new();
  }
  uint64_t v20 = *(void **)(qword_1E9EE5870 + 8);
  if (!v20) {
    goto LABEL_34;
  }
  uint64_t v21 = qword_1E9EE5870 + 8;
  do
  {
    unint64_t v22 = v20[4];
    BOOL v23 = v22 >= v19;
    if (v22 >= v19) {
      unint64_t v24 = v20;
    }
    else {
      unint64_t v24 = v20 + 1;
    }
    if (v23) {
      uint64_t v21 = (uint64_t)v20;
    }
    uint64_t v20 = (void *)*v24;
  }
  while (*v24);
  if (v21 == qword_1E9EE5870 + 8 || *(void *)(v21 + 32) > v19) {
LABEL_34:
  }
    uint64_t v21 = qword_1E9EE5870 + 8;
  uint64_t v25 = *(void *)(v21 + 40);
  pthread_mutex_unlock(&_MergedGlobals);
  memset(v26, 0, 58);
  int v27 = v18;
  __int16 v28 = 511;
  uint64_t v29 = 0;
  int v30 = 0;
  uint64_t v31 = 0;
  TextureDeleteQueue::enqueueDelete(v25, (uint64_t)this, (uint64_t)v26, a4, a3, 0, 0);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v32);
}

void sub_1B77DD170(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 64));
  _Unwind_Resume(a1);
}

void sub_1B77DD184(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 64));
  _Unwind_Resume(a1);
}

void HGTextureManager::removeTexture(HGTextureManager *this, uint64_t a2)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v21, "texManager", 2, "removeTexture()");
  unsigned __int8 v6 = atomic_load(HGLogger::_enabled);
  if (v6) {
    HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"remove texture %d (delegate ownership)\n", v4, v5, a2);
  }
  uint64_t v7 = (int64x2_t *)*((void *)this + 4);
  uint64_t v8 = v7[5].i64[1];
  if (v7[6].i64[0] != v8)
  {
    unint64_t v9 = v7[7].u64[0];
    unsigned __int8 v10 = (void *)(v8 + 8 * (v9 / 0x2A));
    unint64_t v11 = *v10 + 96 * (v9 % 0x2A);
    unint64_t v12 = v7[7].i64[1] + v9;
    unint64_t v13 = v12 / 0x2A;
    uint64_t v14 = *(void *)(v8 + 8 * (v12 / 0x2A));
    unint64_t v15 = v12 % 0x2A;
    unint64_t v16 = v14 + 96 * v15;
    if (v11 != v16)
    {
      while (*(_DWORD *)(v11 + 64) != a2)
      {
        v11 += 96;
        if (v11 - *v10 == 4032)
        {
          unint64_t v17 = v10[1];
          ++v10;
          unint64_t v11 = v17;
        }
        if (v11 == v16)
        {
          unint64_t v11 = v16;
          break;
        }
      }
    }
    if (v11 != *(void *)(v8 + 8 * v13) + 96 * v15)
    {
      int v18 = (int64x2_t *)*((void *)this + 4);
      if (*(unsigned char *)(v11 + 56) == 2)
      {
        unint64_t v19 = *(int *)(v11 + 76);
        uint64_t v20 = (int64x2_t *)((char *)v18 + 152);
      }
      else
      {
        unint64_t v19 = *(int *)(v11 + 76);
        if (*(unsigned char *)(v11 + 69))
        {
          v18[8] = vsubq_s64(v18[8], vdupq_n_s64(v19));
          if (*(char *)(v11 + 68) < 0)
          {
LABEL_19:
            std::deque<HGTextureManager::TextureEntry>::erase(v7 + 5, v10, (char *)v11);
            goto LABEL_20;
          }
          uint64_t v20 = v18 + 9;
        }
        else
        {
          uint64_t v20 = v18 + 10;
        }
      }
      v20->i64[0] -= v19;
      goto LABEL_19;
    }
  }
LABEL_20:
  HGTextureManager::_dumpTextures(this, *((char **)this + 2));
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v21);
}

void sub_1B77DD360(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77DD374(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t HGTextureManager::emptyTexturePool(HGTextureManager *this)
{
  unint64_t v2 = *((void *)this + 2);
    operator new();
  if (!v3) {
    goto LABEL_15;
  }
  do
  {
    unint64_t v5 = v3[4];
    BOOL v6 = v5 >= v2;
    if (v5 >= v2) {
      uint64_t v7 = v3;
    }
    else {
      uint64_t v7 = v3 + 1;
    }
    if (v6) {
      uint64_t v4 = (uint64_t)v3;
    }
    unsigned __int8 v3 = (void *)*v7;
  }
  while (*v7);
LABEL_15:
  uint64_t v8 = *(pthread_mutex_t **)(v4 + 40);
  uint64_t v8 = (pthread_mutex_t *)((char *)v8 + 16);
  pthread_mutex_lock(v8);
  HGTextureManager::emptyTexturePool_NoLock(this);
  return pthread_mutex_unlock(v8);
}

void sub_1B77DD46C(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t HGTextureManager::activeTexture(HGTextureManager *this, GLenum a2, uint64_t a3, const char *a4, char *a5)
{
  uint64_t v7 = *((unsigned int *)this + 6);
  *((_DWORD *)this + 6) = a2 - 33984;
  unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
  if (v8) {
    HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"active texture %d\n", a4, a5, *((unsigned int *)this + 6));
  }
  uint64_t GLState = HGGPURenderer::GetGLState(*((HGGPURenderer **)this + 1));
  HGGPURenderer::GetCurrentContext(*((HGGPURenderer **)this + 1), (uint64_t *)&v11);
  HGGLState::SetCurrentContextGuard::SetCurrentContextGuard(v12, GLState, &v11);
  PCSharedCount::PCSharedCount(&v11);
  glActiveTexture(a2);
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard(v12);
  return v7;
}

void sub_1B77DD53C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard((PCSharedCount *)va);
  _Unwind_Resume(a1);
}

void sub_1B77DD550(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCSharedCount a11)
{
}

void HGTextureManager::bindTexture(HGTextureManager *this, GLenum a2, uint64_t a3)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v55, "texManager", 2, "bindTexture()");
  unsigned __int8 v9 = atomic_load(HGLogger::_enabled);
  if (v9) {
    HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"binding texture %d in unit %d\n", v7, v8, a3, *((unsigned int *)this + 6));
  }
  unsigned __int8 v10 = (int64x2_t *)*((void *)this + 4);
  uint64_t v11 = v10[5].i64[1];
  if (v10[6].i64[0] == v11)
  {
    unint64_t v12 = &v10[7].i64[1];
    uint64_t v21 = (unsigned int *)((char *)this + 24);
    if (!a3) {
      goto LABEL_64;
    }
    goto LABEL_26;
  }
  unint64_t v12 = &v10[7].i64[1];
  unint64_t v13 = v10[7].u64[0];
  uint64_t v14 = (void *)(v11 + 8 * (v13 / 0x2A));
  unint64_t v15 = *v14 + 96 * (v13 % 0x2A);
  unint64_t v16 = v10[7].i64[1] + v13;
  unint64_t v17 = v16 / 0x2A;
  uint64_t v18 = *(void *)(v11 + 8 * (v16 / 0x2A));
  unint64_t v19 = v16 % 0x2A;
  unint64_t v20 = v18 + 96 * v19;
  uint64_t v21 = (unsigned int *)((char *)this + 24);
  if (v15 != v20)
  {
    while (*((_DWORD *)this + 6) != *(char *)(v15 + 68))
    {
      v15 += 96;
      if (v15 - *v14 == 4032)
      {
        unint64_t v22 = v14[1];
        ++v14;
        unint64_t v15 = v22;
      }
      if (v15 == v20)
      {
        unint64_t v15 = v20;
        break;
      }
    }
  }
  if (v15 == *(void *)(v11 + 8 * v17) + 96 * v19) {
    goto LABEL_25;
  }
  unsigned __int8 v23 = atomic_load(HGLogger::_enabled);
  if (v23) {
    HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"  (...unbinding tex %d from unit %d)\n", v7, v8, *(unsigned int *)(v15 + 64), *v21);
  }
  unint64_t v24 = (int64x2_t *)*((void *)this + 4);
  if (*(unsigned char *)(v15 + 56) == 2)
  {
    uint64_t v25 = v24[9].i64[1];
    v24[9].i64[1] = v25 - *(int *)(v15 + 76);
    *(unsigned char *)(v15 + 68) = -1;
    if (*(unsigned char *)(v15 + 69))
    {
      v24[9].i64[1] = v25;
      if (!a3) {
        goto LABEL_64;
      }
      goto LABEL_26;
    }
    goto LABEL_24;
  }
  unint64_t v26 = *(int *)(v15 + 76);
  if (!*(unsigned char *)(v15 + 69))
  {
    v24[10].i64[0] -= v26;
    *(unsigned char *)(v15 + 68) = -1;
LABEL_24:
    std::deque<HGTextureManager::TextureEntry>::erase(v10 + 5, v14, (char *)v15);
LABEL_25:
    if (!a3) {
      goto LABEL_64;
    }
    goto LABEL_26;
  }
  int64x2_t v27 = vdupq_n_s64(v26);
  int64x2_t v28 = vsubq_s64(v24[8], v27);
  v24[8] = v28;
  if (*(char *)(v15 + 68) < 0)
  {
    *(unsigned char *)(v15 + 68) = -1;
  }
  else
  {
    v24[9].i64[0] -= v26;
    *(unsigned char *)(v15 + 68) = -1;
    int64x2_t v28 = v24[8];
  }
  v24[8] = vaddq_s64(v28, v27);
  if (!a3) {
    goto LABEL_64;
  }
LABEL_26:
  unint64_t v29 = v10[7].u64[0];
  uint64_t v30 = v10[5].i64[1];
  uint64_t v31 = v10[6].i64[0];
  if (v31 == v30)
  {
    unint64_t v33 = 0;
    unint64_t v34 = *v12 + v29;
  }
  else
  {
    uint64_t v32 = (void *)(v30 + 8 * (v29 / 0x2A));
    unint64_t v33 = *v32 + 96 * (v29 % 0x2A);
    unint64_t v34 = *v12 + v29;
    unint64_t v35 = *(void *)(v30 + 8 * (v34 / 0x2A)) + 96 * (v34 % 0x2A);
    if (v33 != v35)
    {
      while (*(_DWORD *)(v33 + 64) != a3)
      {
        v33 += 96;
        if (v33 - *v32 == 4032)
        {
          unint64_t v36 = v32[1];
          ++v32;
          unint64_t v33 = v36;
        }
        if (v33 == v35)
        {
          unint64_t v33 = *(void *)(v30 + 8 * (v34 / 0x2A)) + 96 * (v34 % 0x2A);
          break;
        }
      }
    }
    if (v33 != *(void *)(v30 + 8 * (v34 / 0x2A)) + 96 * (v34 % 0x2A))
    {
      unint64_t v37 = (int64x2_t *)*((void *)this + 4);
      if (*(unsigned char *)(v33 + 56) == 2)
      {
        unint64_t v38 = *(int *)(v33 + 76);
        uint64_t v41 = v37[9].i64[1];
        uint64_t v39 = (int64x2_t *)((char *)v37 + 152);
        uint64_t v40 = v41;
      }
      else
      {
        unint64_t v38 = *(int *)(v33 + 76);
        if (*(unsigned char *)(v33 + 69))
        {
          int64x2_t v48 = vdupq_n_s64(v38);
          v37[8] = vsubq_s64(v37[8], v48);
          if ((*(char *)(v33 + 68) & 0x80000000) == 0) {
            v37[9].i64[0] -= v38;
          }
          int v49 = *(char *)v21;
          *(unsigned char *)(v33 + 68) = *(unsigned char *)v21;
          v37[8] = vaddq_s64(v37[8], v48);
          if (v49 < 0) {
            goto LABEL_63;
          }
          uint64_t v39 = v37 + 9;
LABEL_62:
          v39->i64[0] += v38;
LABEL_63:
          HGTextureManager::TextureEntry::log((HGTextureManager::TextureEntry *)v33, (const char *)2, v6);
          goto LABEL_64;
        }
        uint64_t v51 = v37[10].i64[0];
        uint64_t v39 = v37 + 10;
        uint64_t v40 = v51;
      }
      v39->i64[0] = v40 - v38;
      *(unsigned char *)(v33 + 68) = *v21;
      goto LABEL_62;
    }
  }
  unsigned int v42 = *v21;
  if (v31 == v30) {
    uint64_t v43 = 0;
  }
  else {
    uint64_t v43 = 42 * ((v31 - v30) >> 3) - 1;
  }
  if (v43 == v34)
  {
    std::deque<HGTextureManager::TextureEntry>::__add_back_capacity((uint64_t)v10[5].i64);
    uint64_t v30 = v10[5].i64[1];
    unint64_t v34 = v10[7].i64[1] + v10[7].i64[0];
  }
  unint64_t v44 = *(void *)(v30 + 8 * (v34 / 0x2A)) + 96 * (v34 % 0x2A);
  *(_DWORD *)unint64_t v44 = a2;
  *(_OWORD *)(v44 + 4) = 0u;
  *(_OWORD *)(v44 + 2CVOpenGLESTextureCacheFlush(this[3], 0) = 0u;
  *(_OWORD *)(v44 + 36) = 0u;
  *(void *)(v44 + 5CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *(_DWORD *)(v44 + 64) = a3;
  *(unsigned char *)(v44 + 68) = v42;
  *(unsigned char *)(v44 + 69) = 0;
  *(void *)(v44 + 72) = 0xFFFFFFFFLL;
  *(_DWORD *)(v44 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *(void *)(v44 + 88) = 0;
  ++*v12;
  uint64_t v45 = (int64x2_t *)*((void *)this + 4);
  if (*(unsigned char *)(v33 + 56) == 2)
  {
    unint64_t v46 = *(int *)(v33 + 76);
    unint64_t v47 = (int64x2_t *)((char *)v45 + 152);
  }
  else
  {
    unint64_t v46 = *(int *)(v33 + 76);
    if (*(unsigned char *)(v33 + 69))
    {
      v45[8] = vaddq_s64(v45[8], vdupq_n_s64(v46));
      if (*(char *)(v33 + 68) < 0) {
        goto LABEL_55;
      }
      unint64_t v47 = v45 + 9;
    }
    else
    {
      unint64_t v47 = v45 + 10;
    }
  }
  v47->i64[0] += v46;
LABEL_55:
  unsigned __int8 v50 = atomic_load(HGLogger::_enabled);
  if (v50) {
    HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"id %d in unit %d (app-managed texture)\n", v7, v8, a3, *v21);
  }
LABEL_64:
  uint64_t GLState = HGGPURenderer::GetGLState(*((HGGPURenderer **)this + 1));
  HGGPURenderer::GetCurrentContext(*((HGGPURenderer **)this + 1), (uint64_t *)&v53);
  HGGLState::SetCurrentContextGuard::SetCurrentContextGuard(v54, GLState, &v53);
  PCSharedCount::PCSharedCount(&v53);
  glBindTexture(a2, a3);
  HGTextureManager::_dumpTextures(this, *((char **)this + 2));
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard(v54);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v55);
}

void sub_1B77DDAAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77DDAC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77DDAD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77DDAE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCSharedCount a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

void sub_1B77DDB04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.int var0 = va_arg(va1, PC_Sp_counted_base *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard((PCSharedCount *)va);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va1);
  _Unwind_Resume(a1);
}

void sub_1B77DDB20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void HGTextureManager::framebufferTexture2D(HGTextureManager *this, GLenum a2, uint64_t a3)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v48, "texManager", 2, "framebufferTexture2D()");
  unsigned __int8 v9 = atomic_load(HGLogger::_enabled);
  if (v9) {
    HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"binding buffer %d\n", v7, v8, a3);
  }
  unsigned __int8 v10 = (int64x2_t *)*((void *)this + 4);
  uint64_t v11 = v10[5].i64[1];
  unint64_t v12 = v10;
  if (v10[6].i64[0] != v11)
  {
    unint64_t v13 = v10[7].u64[0];
    uint64_t v14 = (void *)(v11 + 8 * (v13 / 0x2A));
    unint64_t v15 = *v14 + 96 * (v13 % 0x2A);
    unint64_t v16 = v10[7].i64[1] + v13;
    unint64_t v17 = v16 / 0x2A;
    uint64_t v18 = *(void *)(v11 + 8 * (v16 / 0x2A));
    unint64_t v19 = v16 % 0x2A;
    unint64_t v20 = v18 + 96 * v19;
    if (v15 != v20)
    {
      while (*(unsigned char *)(v15 + 68) != 99)
      {
        v15 += 96;
        if (v15 - *v14 == 4032)
        {
          unint64_t v21 = v14[1];
          ++v14;
          unint64_t v15 = v21;
        }
        if (v15 == v20)
        {
          unint64_t v15 = v20;
          break;
        }
      }
    }
    uint64_t v22 = *(void *)(v11 + 8 * v17) + 96 * v19;
    unint64_t v12 = (int64x2_t *)*((void *)this + 4);
    if (v15 != v22)
    {
      unsigned __int8 v23 = atomic_load(HGLogger::_enabled);
      if (v23) {
        HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"  (...unbinding buffer %d from unit %d)\n", v7, v8, *(unsigned int *)(v15 + 64), 99);
      }
      unint64_t v12 = (int64x2_t *)*((void *)this + 4);
      if (*(unsigned char *)(v15 + 56) == 2)
      {
        unint64_t v24 = *(int *)(v15 + 76);
        uint64_t v25 = (int64x2_t *)((char *)v12 + 152);
        uint64_t v26 = v12[9].i64[1];
        goto LABEL_23;
      }
      unint64_t v24 = *(int *)(v15 + 76);
      if (!*(unsigned char *)(v15 + 69))
      {
        uint64_t v25 = v12 + 10;
        uint64_t v26 = v12[10].i64[0];
LABEL_23:
        unint64_t v28 = v26 - v24;
        v25->i64[0] = v28;
        *(unsigned char *)(v15 + 68) = -1;
        v25->i64[0] = v28 + v24;
        if (!a3) {
          goto LABEL_42;
        }
        goto LABEL_24;
      }
      int64x2_t v27 = vdupq_n_s64(v24);
      v12[8] = vsubq_s64(v12[8], v27);
      if ((*(char *)(v15 + 68) & 0x80000000) == 0) {
        v12[9].i64[0] -= v24;
      }
      *(unsigned char *)(v15 + 68) = -1;
      v12[8] = vaddq_s64(v12[8], v27);
    }
  }
  if (!a3) {
    goto LABEL_42;
  }
LABEL_24:
  uint64_t v29 = v10[5].i64[1];
  if (v10[6].i64[0] != v29)
  {
    unint64_t v30 = v10[7].u64[0];
    uint64_t v31 = (void *)(v29 + 8 * (v30 / 0x2A));
    unint64_t v32 = *v31 + 96 * (v30 % 0x2A);
    unint64_t v33 = v10[7].i64[1] + v30;
    unint64_t v34 = v33 / 0x2A;
    uint64_t v35 = *(void *)(v29 + 8 * (v33 / 0x2A));
    unint64_t v36 = v33 % 0x2A;
    unint64_t v37 = v35 + 96 * v36;
    if (v32 != v37)
    {
      while (*(_DWORD *)(v32 + 64) != a3)
      {
        v32 += 96;
        if (v32 - *v31 == 4032)
        {
          unint64_t v38 = v31[1];
          ++v31;
          unint64_t v32 = v38;
        }
        if (v32 == v37)
        {
          unint64_t v32 = v37;
          break;
        }
      }
    }
    if (v32 != *(void *)(v29 + 8 * v34) + 96 * v36)
    {
      a2 = *(_DWORD *)v32;
      if (*(unsigned char *)(v32 + 56) == 2)
      {
        unint64_t v39 = *(int *)(v32 + 76);
        uint64_t v42 = v12[9].i64[1];
        uint64_t v40 = (int64x2_t *)((char *)v12 + 152);
        uint64_t v41 = v42;
      }
      else
      {
        unint64_t v39 = *(int *)(v32 + 76);
        if (*(unsigned char *)(v32 + 69))
        {
          int64x2_t v43 = vdupq_n_s64(v39);
          v12[8] = vsubq_s64(v12[8], v43);
          if ((*(char *)(v32 + 68) & 0x80000000) == 0) {
            v12[9].i64[0] -= v39;
          }
          *(unsigned char *)(v32 + 68) = 99;
          v12[8] = vaddq_s64(v12[8], v43);
          uint64_t v40 = v12 + 9;
          goto LABEL_41;
        }
        uint64_t v44 = v12[10].i64[0];
        uint64_t v40 = v12 + 10;
        uint64_t v41 = v44;
      }
      v40->i64[0] = v41 - v39;
      *(unsigned char *)(v32 + 68) = 99;
LABEL_41:
      v40->i64[0] += v39;
      HGTextureManager::TextureEntry::log((HGTextureManager::TextureEntry *)v32, (const char *)2, v6);
    }
  }
LABEL_42:
  uint64_t GLState = HGGPURenderer::GetGLState(*((HGGPURenderer **)this + 1));
  HGGPURenderer::GetCurrentContext(*((HGGPURenderer **)this + 1), (uint64_t *)&v46);
  HGGLState::SetCurrentContextGuard::SetCurrentContextGuard(v47, GLState, &v46);
  PCSharedCount::PCSharedCount(&v46);
  glFramebufferTexture2D(0x8D40u, 0x8CE0u, a2, a3, 0);
  HGTextureManager::_dumpTextures(this, *((char **)this + 2));
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard(v47);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v48);
}

void sub_1B77DDEE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77DDEF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77DDF08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77DDF1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCSharedCount a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

void sub_1B77DDF38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.int var0 = va_arg(va1, PC_Sp_counted_base *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard((PCSharedCount *)va);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va1);
  _Unwind_Resume(a1);
}

void sub_1B77DDF54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void HGTextureManager::texImage2D(HGTextureManager *this, const HGTextureManager::TextureInfo *a2)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v37, "texManager", 2, "texImage2D()");
  unsigned __int8 v7 = atomic_load(HGLogger::_enabled);
  if (v7) {
    HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"creating texture (%dx%d) in unit %d\n", v5, v6, *((unsigned int *)a2 + 1), *((unsigned int *)a2 + 2), *((unsigned int *)this + 6));
  }
  uint64_t v8 = (int64x2_t *)*((void *)this + 4);
  uint64_t v9 = v8[5].i64[1];
  if (v8[6].i64[0] != v9)
  {
    unint64_t v10 = v8[7].u64[0];
    uint64_t v11 = (void *)(v9 + 8 * (v10 / 0x2A));
    unint64_t v12 = *v11 + 96 * (v10 % 0x2A);
    unint64_t v13 = v8[7].i64[1] + v10;
    unint64_t v14 = v13 / 0x2A;
    uint64_t v15 = *(void *)(v9 + 8 * (v13 / 0x2A));
    unint64_t v16 = v13 % 0x2A;
    unint64_t v17 = v15 + 96 * v16;
    if (v12 != v17)
    {
      while (*((_DWORD *)this + 6) != *(char *)(v12 + 68))
      {
        v12 += 96;
        if (v12 - *v11 == 4032)
        {
          unint64_t v18 = v11[1];
          ++v11;
          unint64_t v12 = v18;
        }
        if (v12 == v17)
        {
          unint64_t v12 = v17;
          break;
        }
      }
    }
    if (v12 != *(void *)(v9 + 8 * v14) + 96 * v16)
    {
      if (*(unsigned char *)(v12 + 56) == 2)
      {
        unint64_t v19 = *(int *)(v12 + 76);
        unint64_t v20 = (int64x2_t *)((char *)v8 + 152);
      }
      else
      {
        unint64_t v19 = *(int *)(v12 + 76);
        if (*(unsigned char *)(v12 + 69))
        {
          v8[8] = vsubq_s64(v8[8], vdupq_n_s64(v19));
          if (*(char *)(v12 + 68) < 0) {
            goto LABEL_19;
          }
          unint64_t v20 = v8 + 9;
        }
        else
        {
          unint64_t v20 = v8 + 10;
        }
      }
      v20->i64[0] -= v19;
LABEL_19:
      long long v22 = *((_OWORD *)a2 + 1);
      long long v21 = *((_OWORD *)a2 + 2);
      long long v23 = *(_OWORD *)((char *)a2 + 42);
      *(_OWORD *)unint64_t v12 = *(_OWORD *)a2;
      *(_OWORD *)(v12 + 16) = v22;
      *(_OWORD *)(v12 + 42) = v23;
      *(_OWORD *)(v12 + 32) = v21;
      int v25 = *(_DWORD *)(v12 + 4);
      int v24 = *(_DWORD *)(v12 + 8);
      int v26 = HGFormatUtils::GLFormatToByteSize((HGFormatUtils *)*(unsigned int *)(v12 + 16), (const char *)*(unsigned int *)(v12 + 20), v4);
      unsigned int v28 = v25 + 127;
      if (v25 < -127) {
        unsigned int v28 = v25 + 254;
      }
      unsigned int v29 = v28 >> 7;
      if (v24 <= 128) {
        int v30 = 128;
      }
      else {
        int v30 = v24;
      }
      LODWORD(v31) = (v29 * v30 * v26) << 7;
      *(_DWORD *)(v12 + 76) = v31;
      unint64_t v32 = (int64x2_t *)*((void *)this + 4);
      if (*(unsigned char *)(v12 + 56) == 2)
      {
        uint64_t v31 = (int)v31;
        unint64_t v33 = (int64x2_t *)((char *)v32 + 152);
      }
      else
      {
        uint64_t v31 = (int)v31;
        if (*(unsigned char *)(v12 + 69))
        {
          v32[8] = vaddq_s64(v32[8], vdupq_n_s64((int)v31));
          if (*(char *)(v12 + 68) < 0)
          {
LABEL_31:
            HGTextureManager::TextureEntry::log((HGTextureManager::TextureEntry *)v12, (const char *)2, v27);
            goto LABEL_32;
          }
          unint64_t v33 = v32 + 9;
        }
        else
        {
          unint64_t v33 = v32 + 10;
        }
      }
      v33->i64[0] += v31;
      goto LABEL_31;
    }
  }
LABEL_32:
  uint64_t GLState = HGGPURenderer::GetGLState(*((HGGPURenderer **)this + 1));
  HGGPURenderer::GetCurrentContext(*((HGGPURenderer **)this + 1), (uint64_t *)&v35);
  HGGLState::SetCurrentContextGuard::SetCurrentContextGuard(v36, GLState, &v35);
  PCSharedCount::PCSharedCount(&v35);
  glTexImage2D(*(_DWORD *)a2, 0, *((_DWORD *)a2 + 3), *((_DWORD *)a2 + 1), *((_DWORD *)a2 + 2), 0, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 5), *((const GLvoid **)a2 + 3));
  HGTextureManager::_dumpTextures(this, *((char **)this + 2));
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard(v36);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v37);
}

void sub_1B77DE228(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77DE23C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77DE250(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, PCSharedCount a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

void sub_1B77DE26C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  v7.int var0 = va_arg(va1, PC_Sp_counted_base *);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  HGGLState::SetCurrentContextGuard::~SetCurrentContextGuard((PCSharedCount *)va);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va1);
  _Unwind_Resume(a1);
}

void sub_1B77DE288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void HGTextureManager::texImage2D(HGTextureManager *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8, unsigned int a9, const void *a10)
{
  v10[0] = a2;
  v10[1] = a5;
  v10[2] = a6;
  v10[3] = a4;
  v10[4] = a8;
  v10[5] = a9;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v11 = a10;
  uint64_t v12 = 0;
  __int16 v15 = 0;
  HGTextureManager::texImage2D(this, (const HGTextureManager::TextureInfo *)v10);
}

void HGTextureManager::sizeHint(HGTextureManager *this, HGGLTexture *a2, BOOL a3, const char *a4, char *a5)
{
  unsigned __int8 v7 = atomic_load(HGLogger::_enabled);
  if (v7) {
    HGLogger::log((HGLogger *)"texManager", (const char *)2, (HGLogger *)"size hint: texture %lu\n", a4, a5, *((void *)a2 + 21));
  }
  uint64_t v8 = (void *)*((void *)this + 4);
  uint64_t v9 = v8[11];
  if (v8[12] != v9)
  {
    unint64_t v10 = v8[14];
    uint64_t v11 = (void *)(v9 + 8 * (v10 / 0x2A));
    unint64_t v12 = *v11 + 96 * (v10 % 0x2A);
    unint64_t v13 = v8[15] + v10;
    unint64_t v14 = v13 / 0x2A;
    uint64_t v15 = *(void *)(v9 + 8 * (v13 / 0x2A));
    unint64_t v16 = v13 % 0x2A;
    unint64_t v17 = v15 + 96 * v16;
    if (v12 != v17)
    {
      while (*(_DWORD *)(v12 + 64) != *((_DWORD *)a2 + 42))
      {
        v12 += 96;
        if (v12 - *v11 == 4032)
        {
          unint64_t v18 = v11[1];
          ++v11;
          unint64_t v12 = v18;
        }
        if (v12 == v17)
        {
          unint64_t v12 = v17;
          break;
        }
      }
    }
    if (v12 != *(void *)(v9 + 8 * v14) + 96 * v16 && !*(unsigned char *)(v12 + 69))
    {
      uint64_t v19 = 20;
      if (*(unsigned char *)(v12 + 56) == 2) {
        uint64_t v19 = 19;
      }
      v8[v19] -= *(int *)(v12 + 76);
      *(int32x2_t *)(v12 + 4) = vsub_s32(*(int32x2_t *)((char *)a2 + 28), *(int32x2_t *)((char *)a2 + 20));
      *(_DWORD *)(v12 + 16) = HGFormatUtils::toGLFormat(*((_DWORD *)a2 + 4));
      *(_DWORD *)(v12 + 2CVOpenGLESTextureCacheFlush(this[3], 0) = HGFormatUtils::toGLType(*((_DWORD *)a2 + 4));
      *(_DWORD *)(v12 + 12) = HGFormatUtils::toGLInternalFormat(*((_DWORD *)a2 + 4));
      int v21 = *(_DWORD *)(v12 + 4);
      int v22 = *(_DWORD *)(v12 + 8);
      int v24 = v21 + 127;
      BOOL v23 = v21 < -127;
      unsigned int v25 = v21 + 254;
      if (!v23) {
        unsigned int v25 = v24;
      }
      unsigned int v26 = v25 >> 7;
      if (v22 <= 128) {
        int v22 = 128;
      }
      LODWORD(v28) = (v26
                    * v22
                    * HGFormatUtils::GLFormatToByteSize((HGFormatUtils *)*(unsigned int *)(v12 + 16), (const char *)*(unsigned int *)(v12 + 20), v20)) << 7;
      *(_DWORD *)(v12 + 76) = v28;
      unsigned int v29 = (int64x2_t *)*((void *)this + 4);
      if (*(unsigned char *)(v12 + 56) == 2)
      {
        uint64_t v28 = (int)v28;
        int v30 = (int64x2_t *)((char *)v29 + 152);
      }
      else
      {
        uint64_t v28 = (int)v28;
        if (*(unsigned char *)(v12 + 69))
        {
          v29[8] = vaddq_s64(v29[8], vdupq_n_s64((int)v28));
          if (*(char *)(v12 + 68) < 0)
          {
LABEL_26:
            HGTextureManager::TextureEntry::log((HGTextureManager::TextureEntry *)v12, (const char *)2, v27);
            goto LABEL_27;
          }
          int v30 = v29 + 9;
        }
        else
        {
          int v30 = v29 + 10;
        }
      }
      v30->i64[0] += v28;
      goto LABEL_26;
    }
  }
LABEL_27:
  uint64_t v31 = (char *)*((void *)this + 2);

  HGTextureManager::_dumpTextures(this, v31);
}

uint64_t HGTextureManager::_getFreeTotalTextureCount(HGTextureManager *this, unint64_t a2)
{
    operator new();
  if (!v3) {
    goto LABEL_16;
  }
  do
  {
    unint64_t v5 = v3[4];
    BOOL v6 = v5 >= a2;
    if (v5 >= a2) {
      unsigned __int8 v7 = v3;
    }
    else {
      unsigned __int8 v7 = v3 + 1;
    }
    if (v6) {
      uint64_t v4 = (uint64_t)v3;
    }
    unsigned __int8 v3 = (void *)*v7;
  }
  while (*v7);
  {
LABEL_16:
    if (!v8) {
      goto LABEL_17;
    }
    goto LABEL_14;
  }
  uint64_t v8 = *(void **)(v4 + 40);
  if (v8) {
LABEL_14:
  }
    (*(void (**)(void *))(*v8 + 16))(v8);
LABEL_17:
  uint64_t v9 = v8[15];
  (*(void (**)(void *))(*v8 + 24))(v8);
  return v9;
}

uint64_t HGTextureManager::_getFreeTotalTextureCount(HGTextureManager *this)
{
    operator new();
  {
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v3 = 0;
    do
    {
      uint64_t v4 = (void *)v1[5];
      if (v4) {
        (*(void (**)(void))(*v4 + 16))(v1[5]);
      }
      uint64_t v5 = v4[15];
      (*(void (**)(void *))(*v4 + 24))(v4);
      BOOL v6 = (void *)v1[1];
      if (v6)
      {
        do
        {
          unsigned __int8 v7 = v6;
          BOOL v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          unsigned __int8 v7 = (void *)v1[2];
          BOOL v8 = *v7 == (void)v1;
          uint64_t v1 = v7;
        }
        while (!v8);
      }
      v3 += v5;
      uint64_t v1 = v7;
    }
    while (v7 != (void *)v2);
  }
  return v3;
}

uint64_t HGTextureManager::_getQueuedTotalTextureCount(HGTextureManager *this, unint64_t a2)
{
  pthread_mutex_lock(&_MergedGlobals);
  if (!qword_1E9EE5870) {
    operator new();
  }
  uint64_t v3 = *(void **)(qword_1E9EE5870 + 8);
  if (!v3) {
    goto LABEL_16;
  }
  uint64_t v4 = qword_1E9EE5870 + 8;
  do
  {
    unint64_t v5 = v3[4];
    BOOL v6 = v5 >= a2;
    if (v5 >= a2) {
      unsigned __int8 v7 = v3;
    }
    else {
      unsigned __int8 v7 = v3 + 1;
    }
    if (v6) {
      uint64_t v4 = (uint64_t)v3;
    }
    uint64_t v3 = (void *)*v7;
  }
  while (*v7);
  if (v4 == qword_1E9EE5870 + 8 || *(void *)(v4 + 32) > a2)
  {
LABEL_16:
    BOOL v8 = *(void **)(qword_1E9EE5870 + 48);
    if (!v8) {
      goto LABEL_17;
    }
    goto LABEL_14;
  }
  BOOL v8 = *(void **)(v4 + 40);
  if (v8) {
LABEL_14:
  }
    (*(void (**)(void *))(*v8 + 16))(v8);
LABEL_17:
  uint64_t v9 = v8[15];
  (*(void (**)(void *))(*v8 + 24))(v8);
  pthread_mutex_unlock(&_MergedGlobals);
  return v9;
}

uint64_t HGTextureManager::_getQueuedTotalTextureCount(HGTextureManager *this)
{
  pthread_mutex_lock(&_MergedGlobals);
  if (!qword_1E9EE5870) {
    operator new();
  }
  uint64_t v1 = *(void **)qword_1E9EE5870;
  uint64_t v2 = qword_1E9EE5870 + 8;
  if (*(void *)qword_1E9EE5870 == qword_1E9EE5870 + 8)
  {
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v3 = 0;
    do
    {
      uint64_t v4 = (void *)v1[5];
      if (v4) {
        (*(void (**)(void))(*v4 + 16))(v1[5]);
      }
      uint64_t v5 = v4[15];
      (*(void (**)(void *))(*v4 + 24))(v4);
      BOOL v6 = (void *)v1[1];
      if (v6)
      {
        do
        {
          unsigned __int8 v7 = v6;
          BOOL v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          unsigned __int8 v7 = (void *)v1[2];
          BOOL v8 = *v7 == (void)v1;
          uint64_t v1 = v7;
        }
        while (!v8);
      }
      v3 += v5;
      uint64_t v1 = v7;
    }
    while (v7 != (void *)v2);
  }
  pthread_mutex_unlock(&_MergedGlobals);
  return v3;
}

uint64_t HGTextureManager::_getFreeTotalTextureUsage@<X0>(unint64_t a1@<X1>, void *a2@<X8>)
{
    operator new();
  if (!v5) {
    goto LABEL_16;
  }
  do
  {
    unint64_t v7 = v5[4];
    BOOL v8 = v7 >= a1;
    if (v7 >= a1) {
      uint64_t v9 = v5;
    }
    else {
      uint64_t v9 = v5 + 1;
    }
    if (v8) {
      uint64_t v6 = (uint64_t)v5;
    }
    uint64_t v5 = (void *)*v9;
  }
  while (*v9);
  {
LABEL_16:
    if (!v10) {
      goto LABEL_17;
    }
    goto LABEL_14;
  }
  unint64_t v10 = *(void **)(v6 + 40);
  if (v10) {
LABEL_14:
  }
    (*(void (**)(void *))(*v10 + 16))(v10);
LABEL_17:
  uint64_t v11 = v10[16];
  uint64_t v12 = v10[17];
  uint64_t v13 = v10[18];
  uint64_t v14 = v10[19];
  uint64_t v15 = v10[20];
  uint64_t v16 = v10[21];
  uint64_t v17 = v10[22];
  (*(void (**)(void *))(*v10 + 24))(v10);
  *a2 = v11;
  a2[1] = v12;
  a2[2] = v13;
  a2[3] = v14;
  a2[4] = v15;
  a2[5] = v16;
  a2[6] = v17;
  return result;
}

uint64_t HGTextureManager::_getFreeTotalTextureUsage@<X0>(void *a1@<X8>)
{
    operator new();
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    do
    {
      uint64_t v29 = v4;
      uint64_t v30 = v3;
      unint64_t v10 = (void *)v2[5];
      uint64_t v27 = v6;
      uint64_t v28 = v5;
      uint64_t v25 = v8;
      uint64_t v26 = v7;
      uint64_t v24 = v9;
      if (v10) {
        (*(void (**)(void *))(*v10 + 16))(v10);
      }
      uint64_t v12 = v10[16];
      uint64_t v11 = v10[17];
      uint64_t v14 = v10[18];
      uint64_t v13 = v10[19];
      uint64_t v16 = v10[20];
      uint64_t v15 = v10[21];
      uint64_t v17 = v10[22];
      (*(void (**)(void *))(*v10 + 24))(v10);
      unint64_t v18 = (void *)v2[1];
      if (v18)
      {
        do
        {
          uint64_t v19 = v18;
          unint64_t v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          uint64_t v19 = (void *)v2[2];
          BOOL v20 = *v19 == (void)v2;
          uint64_t v2 = v19;
        }
        while (!v20);
      }
      uint64_t v9 = v12 + v24;
      uint64_t v8 = v11 + v25;
      uint64_t v7 = v14 + v26;
      uint64_t v6 = v13 + v27;
      uint64_t v5 = v16 + v28;
      uint64_t v4 = v15 + v29;
      uint64_t v3 = v17 + v30;
      uint64_t v2 = v19;
    }
    while (v19 != (void *)v23);
  }
  *a1 = v9;
  a1[1] = v8;
  a1[2] = v7;
  a1[3] = v6;
  a1[4] = v5;
  a1[5] = v4;
  a1[6] = v3;
  return result;
}

uint64_t HGTextureManager::_getQueuedTotalTextureUsage@<X0>(unint64_t a1@<X1>, void *a2@<X8>)
{
  pthread_mutex_lock(&_MergedGlobals);
  if (!qword_1E9EE5870) {
    operator new();
  }
  uint64_t v5 = *(void **)(qword_1E9EE5870 + 8);
  if (!v5) {
    goto LABEL_16;
  }
  uint64_t v6 = qword_1E9EE5870 + 8;
  do
  {
    unint64_t v7 = v5[4];
    BOOL v8 = v7 >= a1;
    if (v7 >= a1) {
      uint64_t v9 = v5;
    }
    else {
      uint64_t v9 = v5 + 1;
    }
    if (v8) {
      uint64_t v6 = (uint64_t)v5;
    }
    uint64_t v5 = (void *)*v9;
  }
  while (*v9);
  if (v6 == qword_1E9EE5870 + 8 || *(void *)(v6 + 32) > a1)
  {
LABEL_16:
    unint64_t v10 = *(void **)(qword_1E9EE5870 + 48);
    if (!v10) {
      goto LABEL_17;
    }
    goto LABEL_14;
  }
  unint64_t v10 = *(void **)(v6 + 40);
  if (v10) {
LABEL_14:
  }
    (*(void (**)(void *))(*v10 + 16))(v10);
LABEL_17:
  uint64_t v11 = v10[2];
  uint64_t v12 = v10[3];
  uint64_t v13 = v10[4];
  uint64_t v14 = v10[5];
  uint64_t v15 = v10[6];
  uint64_t v16 = v10[7];
  uint64_t v17 = v10[8];
  (*(void (**)(void *))(*v10 + 24))(v10);
  uint64_t result = pthread_mutex_unlock(&_MergedGlobals);
  *a2 = v11;
  a2[1] = v12;
  a2[2] = v13;
  a2[3] = v14;
  a2[4] = v15;
  a2[5] = v16;
  a2[6] = v17;
  return result;
}

uint64_t HGTextureManager::_getQueuedTotalTextureUsage@<X0>(void *a1@<X8>)
{
  pthread_mutex_lock(&_MergedGlobals);
  if (!qword_1E9EE5870) {
    operator new();
  }
  uint64_t v2 = *(void **)qword_1E9EE5870;
  uint64_t v23 = qword_1E9EE5870 + 8;
  if (*(void *)qword_1E9EE5870 == qword_1E9EE5870 + 8)
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    do
    {
      uint64_t v29 = v4;
      uint64_t v30 = v3;
      unint64_t v10 = (void *)v2[5];
      uint64_t v27 = v6;
      uint64_t v28 = v5;
      uint64_t v25 = v8;
      uint64_t v26 = v7;
      uint64_t v24 = v9;
      if (v10) {
        (*(void (**)(void *))(*v10 + 16))(v10);
      }
      uint64_t v12 = v10[2];
      uint64_t v11 = v10[3];
      uint64_t v14 = v10[4];
      uint64_t v13 = v10[5];
      uint64_t v16 = v10[6];
      uint64_t v15 = v10[7];
      uint64_t v17 = v10[8];
      (*(void (**)(void *))(*v10 + 24))(v10);
      unint64_t v18 = (void *)v2[1];
      if (v18)
      {
        do
        {
          uint64_t v19 = v18;
          unint64_t v18 = (void *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          uint64_t v19 = (void *)v2[2];
          BOOL v20 = *v19 == (void)v2;
          uint64_t v2 = v19;
        }
        while (!v20);
      }
      uint64_t v9 = v12 + v24;
      uint64_t v8 = v11 + v25;
      uint64_t v7 = v14 + v26;
      uint64_t v6 = v13 + v27;
      uint64_t v5 = v16 + v28;
      uint64_t v4 = v15 + v29;
      uint64_t v3 = v17 + v30;
      uint64_t v2 = v19;
    }
    while (v19 != (void *)v23);
  }
  uint64_t result = pthread_mutex_unlock(&_MergedGlobals);
  *a1 = v9;
  a1[1] = v8;
  a1[2] = v7;
  a1[3] = v6;
  a1[4] = v5;
  a1[5] = v4;
  a1[6] = v3;
  return result;
}

uint64_t HGTextureManager::_poolWaitForQueuedTexture(HGTextureManager *this)
{
  HGTextureManager::_getQueuedTotalTextureUsage(*((void *)this + 2), v3);
  if ((float)((float)*((unint64_t *)this + 18) * 0.8) >= (float)v3[1]) {
    return (*(uint64_t (**)(void))(**((void **)this + 20) + 56))(*((void *)this + 20));
  }
  else {
    return 1;
  }
}

uint64_t std::pair<void *,HGRef<HGTextureManager::TexturePool>>::~pair(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  return a1;
}

uint64_t std::pair<void *,HGRef<TextureDeleteQueue>>::~pair(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  return a1;
}

void HGTextureManager::_dumpMaxUsage(HGTextureManager *this, unint64_t a2)
{
  unsigned __int8 v4 = atomic_load(HGLogger::_enabled);
  if ((v4 & 1) == 0 || (int)HGLogger::getLevel((HGLogger *)"texManager", (const char *)*((unsigned int *)this + 1)) < 1) {
    return;
  }
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v25, "texManager", 1, "------ HGTextureManager::_dumpMaxUsage(shareGroup) ------");
  int v7 = *(_DWORD *)this;
  unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
  if (v7)
  {
    if (v8) {
      HGLogger::log((HGLogger *)"texManager", (const char *)1, (HGLogger *)"  tex recycling : %d re-used / %d new  (%d%% re-usage)\n", v5, v6, *((unsigned int *)this + 1), *(unsigned int *)this, (int)(float)((float)((float)*((unsigned int *)this + 1) * 100.0) / (float)*(unsigned int *)this));
    }
  }
  else if (v8)
  {
    HGLogger::log((HGLogger *)"texManager", (const char *)1, (HGLogger *)"  tex recycling : %d re-used / %d new\n", v5, v6, *((unsigned int *)this + 1), *(unsigned int *)this);
  }
  pthread_mutex_lock(&stru_1EB9A0498);
  if (!qword_1E9EE5878) {
    operator new();
  }
  uint64_t v11 = *(void **)(qword_1E9EE5878 + 8);
  if (v11)
  {
    uint64_t v12 = qword_1E9EE5878 + 8;
    do
    {
      unint64_t v13 = v11[4];
      BOOL v14 = v13 >= a2;
      if (v13 >= a2) {
        uint64_t v15 = v11;
      }
      else {
        uint64_t v15 = v11 + 1;
      }
      if (v14) {
        uint64_t v12 = (uint64_t)v11;
      }
      uint64_t v11 = (void *)*v15;
    }
    while (*v15);
    if (v12 != qword_1E9EE5878 + 8 && *(void *)(v12 + 32) <= a2)
    {
      uint64_t v16 = *(unint64_t **)(v12 + 40);
      unsigned __int8 v17 = atomic_load(HGLogger::_enabled);
      if ((v17 & 1) == 0) {
        goto LABEL_25;
      }
      goto LABEL_24;
    }
  }
  uint64_t v16 = *(unint64_t **)(qword_1E9EE5878 + 48);
  unsigned __int8 v18 = atomic_load(HGLogger::_enabled);
  if (v18) {
LABEL_24:
  }
    HGLogger::log((HGLogger *)"texManager", (const char *)1, (HGLogger *)"  max total   : %3.1f mb\n", v9, v10, (float)((float)*v16 * 0.00000095367));
LABEL_25:
  unsigned __int8 v19 = atomic_load(HGLogger::_enabled);
  if (v19) {
    HGLogger::log((HGLogger *)"texManager", (const char *)1, (HGLogger *)"  max used    : %3.1f mb\n", v9, v10, (float)((float)v16[1] * 0.00000095367));
  }
  unsigned __int8 v20 = atomic_load(HGLogger::_enabled);
  if (v20) {
    HGLogger::log((HGLogger *)"texManager", (const char *)1, (HGLogger *)"  max active  : %3.1f mb\n", v9, v10, (float)((float)v16[2] * 0.00000095367));
  }
  unsigned __int8 v21 = atomic_load(HGLogger::_enabled);
  if (v21) {
    HGLogger::log((HGLogger *)"texManager", (const char *)1, (HGLogger *)"  max shared  : %3.1f mb\n", v9, v10, (float)((float)v16[3] * 0.00000095367));
  }
  unsigned __int8 v22 = atomic_load(HGLogger::_enabled);
  if (v22) {
    HGLogger::log((HGLogger *)"texManager", (const char *)1, (HGLogger *)"  max unowned : %3.1f mb\n", v9, v10, (float)((float)v16[4] * 0.00000095367));
  }
  unsigned __int8 v23 = atomic_load(HGLogger::_enabled);
  if (v23) {
    HGLogger::log((HGLogger *)"texManager", (const char *)1, (HGLogger *)"  max free    : %3.1f mb\n", v9, v10, (float)((float)v16[5] * 0.00000095367));
  }
  unsigned __int8 v24 = atomic_load(HGLogger::_enabled);
  if (v24) {
    HGLogger::log((HGLogger *)"texManager", (const char *)1, (HGLogger *)"  max queued  : %3.1f mb\n", v9, v10, (float)((float)v16[6] * 0.00000095367));
  }
  pthread_mutex_unlock(&stru_1EB9A0498);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v25);
}

void sub_1B77DF668(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77DF67C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void sub_1B77DF690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void HGTextureManager::_printTextureList(HGTextureManager *this, char *a2, void *a3, HGTextureManager::TextureUsage *a4)
{
  int v7 = HGTraceGuard::HGTraceGuard((HGTraceGuard *)v46, "texManager", (int)a2, "HGTextureManager::_printTextureList()");
  unsigned __int8 v10 = atomic_load(HGLogger::_enabled);
  if (a3)
  {
    if (v10) {
      HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"dumping ALL textures from share group %p\n", v8, v9, a3);
    }
  }
  else if (v10)
  {
    HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"dumping ALL textures from ALL share groups\n", v8, v9);
  }
  unsigned __int8 v11 = atomic_load(HGLogger::_enabled);
  if (v11) {
    HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"\n", v8, v9);
  }
  uint64_t v45 = 0;
  memset(v44, 0, sizeof(v44));
  uint64_t v12 = (HGTextureManager *)HGTextureManager::_printUsedTextures(v7, a2, a3, (HGTextureManager::TextureUsage *)v44, v9);
  unsigned __int8 v15 = atomic_load(HGLogger::_enabled);
  if (v15) {
    HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"\n", v13, v14);
  }
  uint64_t v43 = 0;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v40 = 0u;
  uint64_t v16 = (HGTextureManager *)HGTextureManager::_printFreeTextures(v12, a2, (unint64_t)a3, (HGTextureManager::TextureUsage *)&v40, v14);
  unsigned __int8 v19 = atomic_load(HGLogger::_enabled);
  if (v19) {
    HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"\n", v17, v18);
  }
  uint64_t v39 = 0;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v36 = 0u;
  HGTextureManager::_printQueuedTextures(v16, a2, (unint64_t)a3, (HGTextureManager::TextureUsage *)&v36, v18);
  unsigned __int8 v22 = atomic_load(HGLogger::_enabled);
  if (v22) {
    HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"\n", v20, v21);
  }
  unsigned __int8 v23 = atomic_load(HGLogger::_enabled);
  if (v23) {
    HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"ALL TEXTURES :\n", v20, v21);
  }
  HGLogger::indent(1);
  unsigned __int8 v24 = atomic_load(HGLogger::_enabled);
  if (v24) {
    HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"used : %4.1f mb (active : %4.1f mb)  |  shared : %4.1f mb  |  unowned : %4.1f mb  |  (total : %4.1f mb)\n", *((const char **)&v37 + 1), (char *)v38, (float)((float)(unint64_t)(*((void *)&v40 + 1) + v44[0].i64[1] + *((void *)&v36 + 1)) * 0.00000095367), (float)((float)(unint64_t)(v41 + v44[1].i64[0] + v37) * 0.00000095367), (float)((float)(unint64_t)(*((void *)&v41 + 1) + v44[1].i64[1] + *((void *)&v37 + 1)) * 0.00000095367), (float)((float)(unint64_t)(v42 + v44[2].i64[0] + v38) * 0.00000095367), (float)((float)(unint64_t)(v40 + v44[0].i64[0] + v36) * 0.00000095367));
  }
  HGLogger::indent(0xFFFFFFFFLL);
  unsigned __int8 v27 = atomic_load(HGLogger::_enabled);
  if (v27) {
    HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"\n", v25, v26);
  }
  uint64_t v28 = *((void *)&v40 + 1);
  uint64_t v29 = *((void *)&v36 + 1);
  uint64_t v30 = v40 + v44[0].i64[0] + v36;
  *(_OWORD *)a4 = 0u;
  *((_OWORD *)a4 + 1) = 0u;
  *((_OWORD *)a4 + 2) = 0u;
  *(void *)a4 = v30;
  int64x2_t v31 = *(int64x2_t *)((char *)&v44[1] + 8);
  uint64_t v32 = *((void *)a4 + 5) + v28;
  *(int64x2_t *)((char *)a4 + 8) = vaddq_s64(*(int64x2_t *)((char *)a4 + 8), *(int64x2_t *)((char *)v44 + 8));
  *(int64x2_t *)((char *)a4 + 24) = vaddq_s64(*(int64x2_t *)((char *)a4 + 24), v31);
  *((void *)a4 + 5) = v32;
  *((void *)a4 + 6) = 0;
  *((void *)a4 + 6) = v29;
  HGTextureManager::TextureUsage::logSummary(a4, (char *)3, 1, v25, v26);
  unsigned __int8 v35 = atomic_load(HGLogger::_enabled);
  if (v35) {
    HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"\n", v33, v34);
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v46);
}

void sub_1B77DF9D0(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 64));
  _Unwind_Resume(a1);
}

void sub_1B77DF9E4(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 64));
  _Unwind_Resume(a1);
}

void sub_1B77DF9F8(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 64));
  _Unwind_Resume(a1);
}

void sub_1B77DFA0C(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 64));
  _Unwind_Resume(a1);
}

void sub_1B77DFA20(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 64));
  _Unwind_Resume(a1);
}

uint64_t HGTextureManager::_printUsageSummary(HGTextureManager *this, const char *a2, void *a3, HGTextureManager::TextureUsage *a4)
{
  if (a3)
  {
      operator new();
    {
      uint64_t v9 = 0;
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      uint64_t v13 = 0;
    }
    else
    {
      uint64_t v9 = 0;
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      do
      {
        if (*(void **)(*(void *)v7 + 16) == a3)
        {
          BOOL v14 = *(void **)(*(void *)v7 + 32);
          v13 += v14[16];
          v12 += v14[17];
          v11 += v14[18];
          v10 += v14[19];
          v9 += v14[20];
        }
        v7 += 8;
      }
      while (v7 != v8);
    }
    HGTextureManager::_getFreeTotalTextureUsage((unint64_t)a3, &v41);
    HGTextureManager::_getQueuedTotalTextureUsage((unint64_t)a3, &v39);
    uint64_t v24 = v42;
    uint64_t v25 = *((void *)a4 + 1);
    uint64_t v26 = v40;
    *(void *)a4 += v41 + v13 + v39;
    *((void *)a4 + 1) = v25 + v12;
    uint64_t v27 = *((void *)a4 + 3) + v10;
    *((void *)a4 + 2) += v11;
    *((void *)a4 + 3) = v27;
    uint64_t v28 = *((void *)a4 + 5) + v24;
    *((void *)a4 + 4) += v9;
    *((void *)a4 + 5) = v28;
    uint64_t v29 = *((void *)a4 + 6) + v26;
  }
  else
  {
      operator new();
    {
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      uint64_t v20 = 0;
      uint64_t v21 = 0;
    }
    else
    {
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      do
      {
        uint64_t v22 = *v15++;
        unsigned __int8 v23 = *(void **)(v22 + 32);
        v21 += v23[16];
        v20 += v23[17];
        v19 += v23[18];
        v18 += v23[19];
        v17 += v23[20];
      }
      while (v15 != v16);
    }
    HGTextureManager::_getFreeTotalTextureUsage(&v41);
    HGTextureManager::_getQueuedTotalTextureUsage(&v39);
    uint64_t v30 = v40;
    uint64_t v31 = *((void *)a4 + 1);
    uint64_t v32 = v42;
    *(void *)a4 += v41 + v21 + v39;
    *((void *)a4 + 1) = v31 + v20;
    uint64_t v33 = *((void *)a4 + 3) + v18;
    *((void *)a4 + 2) += v19;
    *((void *)a4 + 3) = v33;
    uint64_t v34 = *((void *)a4 + 5) + v32;
    *((void *)a4 + 4) += v17;
    *((void *)a4 + 5) = v34;
    uint64_t v29 = *((void *)a4 + 6) + v30;
  }
  *((void *)a4 + 6) = v29;
  HGLogger::indent(1);
  unsigned __int8 v37 = atomic_load(HGLogger::_enabled);
  if (v37) {
    HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"total : %4.1f mb  |  used : %4.1f mb  |  active : %4.1f mb  |  shared : %4.1f mb  |  unowned : %4.1f mb  |  free : %4.1f mb  |  queued : %4.1f mb\n", v35, v36, (float)((float)*(unint64_t *)a4 * 0.00000095367), (float)((float)*((unint64_t *)a4 + 1) * 0.00000095367), (float)((float)*((unint64_t *)a4 + 2) * 0.00000095367), (float)((float)*((unint64_t *)a4 + 3) * 0.00000095367), (float)((float)*((unint64_t *)a4 + 4) * 0.00000095367), (float)((float)*((unint64_t *)a4 + 5) * 0.00000095367), (float)((float)*((unint64_t *)a4 + 6) * 0.00000095367));
  }

  return HGLogger::indent(0xFFFFFFFFLL);
}

uint64_t HGTextureManager::_printUsedTextures(HGTextureManager *this, char *a2, void *a3, HGTextureManager::TextureUsage *a4, char *a5)
{
  unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
  if (v8) {
    HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"USED textures :\n", (const char *)a4, a5);
  }
  if (a3)
  {
      operator new();
    uint64_t v24 = a2;
    uint64_t v25 = a4;
    while (v12 != v15)
    {
      if (*(void **)(*v12 + 16) == a3) {
      ++v12;
      }
    }
  }
  else
  {
      operator new();
    uint64_t v24 = a2;
    uint64_t v25 = a4;
    while (v13 != v14)
    {
      uint64_t v16 = *v13++;
    }
  }
  unsigned __int8 v19 = atomic_load(HGLogger::_enabled);
  if (v19) {
    HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"all pools : \n", v17, v18);
  }
  HGLogger::indent(1);
  unsigned __int8 v22 = atomic_load(HGLogger::_enabled);
  if (v22) {
    HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"used : %4.1f mb (active : %4.1f mb)  |  shared : %4.1f mb  |  unowned : %4.1f mb  |  (total : %4.1f mb)\n", v20, v21, (float)((float)*((unint64_t *)a4 + 1) * 0.00000095367), (float)((float)*((unint64_t *)a4 + 2) * 0.00000095367), (float)((float)*((unint64_t *)a4 + 3) * 0.00000095367), (float)((float)*((unint64_t *)a4 + 4) * 0.00000095367), (float)((float)*(unint64_t *)a4 * 0.00000095367));
  }

  return HGLogger::indent(0xFFFFFFFFLL);
}

uint64_t HGTextureManager::_printFreeTextures(HGTextureManager *this, char *a2, unint64_t a3, HGTextureManager::TextureUsage *a4, char *a5)
{
  unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
  if (v8) {
    HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"FREE textures :\n", (const char *)a4, a5);
  }
  LODWORD(v31[0]) = a2;
  v31[1] = a4;
  if (a3)
  {
      operator new();
    if (!v12) {
      goto LABEL_24;
    }
    do
    {
      unint64_t v14 = v12[4];
      BOOL v15 = v14 >= a3;
      if (v14 >= a3) {
        uint64_t v16 = v12;
      }
      else {
        uint64_t v16 = v12 + 1;
      }
      if (v15) {
        uint64_t v13 = (uint64_t)v12;
      }
      uint64_t v12 = (void *)*v16;
    }
    while (*v16);
    {
LABEL_24:
      uint64_t v34 = v17;
      if (!v17)
      {
LABEL_18:
        if (v17) {
          (*(void (**)(HGTextureManager::TextureUsage *))(*(void *)v17 + 24))(v17);
        }
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v17 = *(HGTextureManager::TextureUsage **)(v13 + 40);
      uint64_t v33 = *(void *)(v13 + 32);
      uint64_t v34 = v17;
      if (!v17) {
        goto LABEL_18;
      }
    }
    (*(void (**)(HGTextureManager::TextureUsage *))(*(void *)v17 + 16))(v17);
    goto LABEL_18;
  }
    operator new();
  uint64_t v33 = v31[0];
  uint64_t v34 = a4;
  {
    do
    {
      uint64_t v23 = v18[5];
      v32[0] = v18[4];
      v32[1] = v23;
      if (v23) {
        (*(void (**)(uint64_t))(*(void *)v23 + 16))(v23);
      }
      if (v23) {
        (*(void (**)(uint64_t))(*(void *)v23 + 24))(v23);
      }
      uint64_t v24 = (void *)v18[1];
      if (v24)
      {
        do
        {
          uint64_t v25 = v24;
          uint64_t v24 = (void *)*v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          uint64_t v25 = (void *)v18[2];
          BOOL v26 = *v25 == (void)v18;
          uint64_t v18 = v25;
        }
        while (!v26);
      }
      uint64_t v18 = v25;
    }
    while (v25 != (void *)v19);
  }
LABEL_27:
  if (!a3)
  {
    unsigned __int8 v27 = atomic_load(HGLogger::_enabled);
    if (v27) {
      HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"all pools : \n", v21, v22);
    }
    HGLogger::indent(1);
    unsigned __int8 v30 = atomic_load(HGLogger::_enabled);
    if (v30) {
      HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"used : %4.1f mb (active : %4.1f mb)  |  shared : %4.1f mb  |  unowned : %4.1f mb  |  (total : %4.1f mb)\n", v28, v29, (float)((float)*((unint64_t *)a4 + 1) * 0.00000095367), (float)((float)*((unint64_t *)a4 + 2) * 0.00000095367), (float)((float)*((unint64_t *)a4 + 3) * 0.00000095367), (float)((float)*((unint64_t *)a4 + 4) * 0.00000095367), (float)((float)*(unint64_t *)a4 * 0.00000095367));
    }
    return HGLogger::indent(0xFFFFFFFFLL);
  }
  return result;
}

void sub_1B77E0320(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  std::pair<void *,HGRef<HGTextureManager::TexturePool>>::~pair((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B77E0338(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  std::pair<void *,HGRef<HGTextureManager::TexturePool>>::~pair((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t HGTextureManager::_printQueuedTextures(HGTextureManager *this, char *a2, unint64_t a3, HGTextureManager::TextureUsage *a4, char *a5)
{
  unsigned __int8 v8 = atomic_load(HGLogger::_enabled);
  if (v8) {
    HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"QUEUED for deletion :\n", (const char *)a4, a5);
  }
  LODWORD(v31[0]) = a2;
  v31[1] = a4;
  pthread_mutex_lock(&_MergedGlobals);
  if (a3)
  {
    if (!qword_1E9EE5870) {
      operator new();
    }
    uint64_t v12 = *(void **)(qword_1E9EE5870 + 8);
    if (!v12) {
      goto LABEL_24;
    }
    uint64_t v13 = qword_1E9EE5870 + 8;
    do
    {
      unint64_t v14 = v12[4];
      BOOL v15 = v14 >= a3;
      if (v14 >= a3) {
        uint64_t v16 = v12;
      }
      else {
        uint64_t v16 = v12 + 1;
      }
      if (v15) {
        uint64_t v13 = (uint64_t)v12;
      }
      uint64_t v12 = (void *)*v16;
    }
    while (*v16);
    if (v13 == qword_1E9EE5870 + 8 || *(void *)(v13 + 32) > a3)
    {
LABEL_24:
      uint64_t v17 = *(HGTextureManager::TextureUsage **)(qword_1E9EE5870 + 48);
      uint64_t v33 = *(void *)(qword_1E9EE5870 + 40);
      uint64_t v34 = v17;
      if (!v17)
      {
LABEL_18:
        if (v17) {
          (*(void (**)(HGTextureManager::TextureUsage *))(*(void *)v17 + 24))(v17);
        }
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v17 = *(HGTextureManager::TextureUsage **)(v13 + 40);
      uint64_t v33 = *(void *)(v13 + 32);
      uint64_t v34 = v17;
      if (!v17) {
        goto LABEL_18;
      }
    }
    (*(void (**)(HGTextureManager::TextureUsage *))(*(void *)v17 + 16))(v17);
    goto LABEL_18;
  }
  if (!qword_1E9EE5870) {
    operator new();
  }
  uint64_t v18 = *(void **)qword_1E9EE5870;
  uint64_t v19 = qword_1E9EE5870 + 8;
  uint64_t v33 = v31[0];
  uint64_t v34 = a4;
  if (v18 != (void *)(qword_1E9EE5870 + 8))
  {
    do
    {
      uint64_t v23 = v18[5];
      v32[0] = v18[4];
      v32[1] = v23;
      if (v23) {
        (*(void (**)(uint64_t))(*(void *)v23 + 16))(v23);
      }
      if (v23) {
        (*(void (**)(uint64_t))(*(void *)v23 + 24))(v23);
      }
      uint64_t v24 = (void *)v18[1];
      if (v24)
      {
        do
        {
          uint64_t v25 = v24;
          uint64_t v24 = (void *)*v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          uint64_t v25 = (void *)v18[2];
          BOOL v26 = *v25 == (void)v18;
          uint64_t v18 = v25;
        }
        while (!v26);
      }
      uint64_t v18 = v25;
    }
    while (v25 != (void *)v19);
  }
LABEL_27:
  uint64_t result = pthread_mutex_unlock(&_MergedGlobals);
  if (!a3)
  {
    unsigned __int8 v27 = atomic_load(HGLogger::_enabled);
    if (v27) {
      HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"all pools : \n", v21, v22);
    }
    HGLogger::indent(1);
    unsigned __int8 v30 = atomic_load(HGLogger::_enabled);
    if (v30) {
      HGLogger::log((HGLogger *)"texManager", a2, (HGLogger *)"used : %4.1f mb (active : %4.1f mb)  |  shared : %4.1f mb  |  unowned : %4.1f mb  |  (total : %4.1f mb)\n", v28, v29, (float)((float)*((unint64_t *)a4 + 1) * 0.00000095367), (float)((float)*((unint64_t *)a4 + 2) * 0.00000095367), (float)((float)*((unint64_t *)a4 + 3) * 0.00000095367), (float)((float)*((unint64_t *)a4 + 4) * 0.00000095367), (float)((float)*(unint64_t *)a4 * 0.00000095367));
    }
    return HGLogger::indent(0xFFFFFFFFLL);
  }
  return result;
}

void sub_1B77E06C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  std::pair<void *,HGRef<TextureDeleteQueue>>::~pair((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B77E06E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  std::pair<void *,HGRef<TextureDeleteQueue>>::~pair((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::FreeTexturesPrinter::operator()(unsigned int *a1, void *a2, uint64_t a3, const char *a4, char *a5)
{
  uint64_t v6 = a2[1];
  unsigned __int8 v7 = atomic_load(HGLogger::_enabled);
  if (v7) {
    HGLogger::log((HGLogger *)"texManager", (const char *)*a1, (HGLogger *)"texture pool %p (group : %p) :\n", a4, a5, a2[1], *a2);
  }
  HGLogger::indent(1);
  unsigned __int8 v8 = (const char *)*a1;
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 16));
  uint64_t v12 = *(void *)(v6 + 88);
  if (*(void *)(v6 + 96) != v12)
  {
    unint64_t v13 = *(void *)(v6 + 112);
    unint64_t v14 = (void *)(v12 + 8 * (v13 / 0x2A));
    BOOL v15 = (HGTextureManager::TextureEntry *)(*v14 + 96 * (v13 % 0x2A));
    unint64_t v16 = *(void *)(v12 + 8 * ((*(void *)(v6 + 120) + v13) / 0x2A)) + 96 * ((*(void *)(v6 + 120) + v13) % 0x2A);
    while (v15 != (HGTextureManager::TextureEntry *)v16)
    {
      HGTextureManager::TextureEntry::log(v15, v8, v9);
      BOOL v15 = (HGTextureManager::TextureEntry *)((char *)v15 + 96);
      if ((HGTextureManager::TextureEntry *)((char *)v15 - *v14) == (HGTextureManager::TextureEntry *)4032)
      {
        uint64_t v17 = (HGTextureManager::TextureEntry *)v14[1];
        ++v14;
        BOOL v15 = v17;
      }
    }
  }
  unsigned __int8 v18 = atomic_load(HGLogger::_enabled);
  if (v18) {
    HGLogger::log((HGLogger *)"texManager", (const char *)*a1, (HGLogger *)"used : %4.1f mb (active : %4.1f mb)  |  shared : %4.1f mb  |  unowned : %4.1f mb  |  (total : %4.1f mb)\n", v10, v11, (float)((float)*(unint64_t *)(v6 + 136) * 0.00000095367), (float)((float)*(unint64_t *)(v6 + 144) * 0.00000095367), (float)((float)*(unint64_t *)(v6 + 152) * 0.00000095367), (float)((float)*(unint64_t *)(v6 + 160) * 0.00000095367), (float)((float)*(unint64_t *)(v6 + 128) * 0.00000095367));
  }
  HGLogger::indent(0xFFFFFFFFLL);
  uint64_t v19 = (int64x2_t *)*((void *)a1 + 1);
  uint64_t v20 = *(void *)(v6 + 176);
  int64x2_t v21 = vaddq_s64(v19[1], *(int64x2_t *)(v6 + 144));
  int64x2_t v22 = *(int64x2_t *)(v6 + 160);
  *uint64_t v19 = vaddq_s64(*v19, *(int64x2_t *)(v6 + 128));
  v19[1] = v21;
  v19[2] = vaddq_s64(v19[2], v22);
  v19[3].i64[0] += v20;
  return pthread_mutex_unlock((pthread_mutex_t *)(v6 + 16));
}

void sub_1B77E08D8(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::QueuedTexturesPrinter::operator()(unsigned int *a1, void *a2, uint64_t a3, const char *a4, char *a5)
{
  uint64_t v6 = a2[1];
  unsigned __int8 v7 = atomic_load(HGLogger::_enabled);
  if (v7) {
    HGLogger::log((HGLogger *)"texManager", (const char *)*a1, (HGLogger *)"finish queue %p (group : %p) :\n", a4, a5, a2[1], *a2);
  }
  HGLogger::indent(1);
  unsigned __int8 v8 = (const char *)*a1;
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 128));
  uint64_t v12 = *(void *)(v6 + 88);
  if (*(void *)(v6 + 96) != v12)
  {
    unint64_t v13 = *(void *)(v6 + 112);
    unint64_t v14 = (void *)(v12 + 8 * (v13 / 0x1E));
    unint64_t v15 = *v14 + 136 * (v13 % 0x1E);
    unint64_t v16 = *(void *)(v12 + 8 * ((*(void *)(v6 + 120) + v13) / 0x1E)) + 136 * ((*(void *)(v6 + 120) + v13) % 0x1E);
    while (v15 != v16)
    {
      HGTextureManager::TextureEntry::log((HGTextureManager::TextureEntry *)(v15 + 8), v8, v9);
      v15 += 136;
      if (v15 - *v14 == 4080)
      {
        unint64_t v17 = v14[1];
        ++v14;
        unint64_t v15 = v17;
      }
    }
  }
  unsigned __int8 v18 = atomic_load(HGLogger::_enabled);
  if (v18) {
    HGLogger::log((HGLogger *)"texManager", (const char *)*a1, (HGLogger *)"used : %4.1f mb (active : %4.1f mb)  |  shared : %4.1f mb  |  unowned : %4.1f mb  |  (total : %4.1f mb)\n", v10, v11, (float)((float)*(unint64_t *)(v6 + 24) * 0.00000095367), (float)((float)*(unint64_t *)(v6 + 32) * 0.00000095367), (float)((float)*(unint64_t *)(v6 + 40) * 0.00000095367), (float)((float)*(unint64_t *)(v6 + 48) * 0.00000095367), (float)((float)*(unint64_t *)(v6 + 16) * 0.00000095367));
  }
  HGLogger::indent(0xFFFFFFFFLL);
  uint64_t v19 = (int64x2_t *)*((void *)a1 + 1);
  uint64_t v20 = *(void *)(v6 + 64);
  int64x2_t v21 = vaddq_s64(v19[1], *(int64x2_t *)(v6 + 32));
  int64x2_t v22 = *(int64x2_t *)(v6 + 48);
  *uint64_t v19 = vaddq_s64(*v19, *(int64x2_t *)(v6 + 16));
  v19[1] = v21;
  v19[2] = vaddq_s64(v19[2], v22);
  v19[3].i64[0] += v20;
  return pthread_mutex_unlock((pthread_mutex_t *)(v6 + 128));
}

void sub_1B77E0AD0(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

void std::deque<HGTextureManager::TextureEntry>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x2A;
  unint64_t v4 = v2 - 42;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    uint64_t v6 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    unsigned __int8 v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_80:
      *(void *)uint64_t v5 = v8;
      *(void *)(a1 + 16) += 8;
      return;
    }
    uint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v31 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v31 = 1;
      }
      if (!(v31 >> 61))
      {
        unint64_t v32 = v31 >> 2;
        uint64_t v33 = 8 * v31;
        uint64_t v34 = (char *)operator new(8 * v31);
        unsigned __int8 v35 = &v34[8 * v32];
        long long v36 = &v34[v33];
        int64_t v38 = v5 - v7;
        BOOL v37 = v5 == v7;
        uint64_t v5 = v35;
        if (!v37)
        {
          uint64_t v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            unsigned __int8 v74 = &v34[8 * v32];
            uint64_t v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              uint64_t v75 = (v39 >> 3) + 1;
              uint64_t v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              uint64_t v40 = &v35[v76];
              v7 += v76;
              float32x4_t v77 = (long long *)(v6 + 3);
              uint64_t v78 = v74 + 16;
              uint64_t v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v80 = *v77;
                *(v78 - 1) = *(v77 - 1);
                *uint64_t v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            uint64_t v40 = &v34[8 * v32];
          }
          do
          {
            uint64_t v81 = *(void *)v7;
            v7 += 8;
            *(void *)uint64_t v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_78;
      }
LABEL_89:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    unint64_t v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      unsigned __int8 v7 = *(char **)(a1 + 8);
    }
    uint64_t v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_80;
  }
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 24);
  uint64_t v19 = *(void *)(a1 + 8);
  uint64_t v20 = v18 - v19;
  uint64_t v21 = (v18 - v19) >> 3;
  uint64_t v22 = v17 - *(void *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      float32x4_t v91 = operator new(0xFC0uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    float32x4_t v91 = operator new(0xFC0uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    uint64_t v41 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    unsigned __int8 v7 = (char *)(v41 + 1);
    uint64_t v8 = *v41;
    *(void *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24)) {
      goto LABEL_80;
    }
    uint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v42 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v42 = 1;
      }
      if (!(v42 >> 61))
      {
        unint64_t v43 = v42 >> 2;
        uint64_t v44 = 8 * v42;
        uint64_t v34 = (char *)operator new(8 * v42);
        unsigned __int8 v35 = &v34[8 * v43];
        long long v36 = &v34[v44];
        int64_t v45 = v5 - v7;
        BOOL v37 = v5 == v7;
        uint64_t v5 = v35;
        if (!v37)
        {
          uint64_t v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            int v82 = &v34[8 * v43];
            unint64_t v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              uint64_t v83 = (v46 >> 3) + 1;
              uint64_t v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              unint64_t v47 = &v35[v84];
              v7 += v84;
              int32x2_t v85 = (long long *)(v41 + 3);
              unsigned int v86 = v82 + 16;
              uint64_t v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v88 = *v85;
                *(v86 - 1) = *(v85 - 1);
                *unsigned int v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            unint64_t v47 = &v34[8 * v43];
          }
          do
          {
            uint64_t v89 = *(void *)v7;
            v7 += 8;
            *(void *)unint64_t v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_78:
        *(void *)a1 = v34;
        *(void *)(a1 + 8) = v35;
        *(void *)(a1 + 16) = v5;
        *(void *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          uint64_t v5 = *(char **)(a1 + 16);
        }
        goto LABEL_80;
      }
      goto LABEL_89;
    }
    goto LABEL_5;
  }
  uint64_t v23 = v22 >> 2;
  if (v17 == *(void *)a1) {
    unint64_t v24 = 1;
  }
  else {
    unint64_t v24 = v23;
  }
  if (v24 >> 61) {
    goto LABEL_89;
  }
  uint64_t v25 = (char *)operator new(8 * v24);
  BOOL v26 = operator new(0xFC0uLL);
  unsigned __int8 v27 = &v25[8 * v21];
  uint64_t v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    unsigned int v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19) {
        unint64_t v48 = 1;
      }
      else {
        unint64_t v48 = v20 >> 2;
      }
      if (v48 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      int v49 = (char *)operator new(8 * v48);
      unsigned __int8 v27 = &v49[8 * (v48 >> 2)];
      uint64_t v28 = &v49[8 * v48];
      operator delete(v25);
      uint64_t v50 = *(void *)(a1 + 8);
      uint64_t v18 = *(void *)(a1 + 16);
      uint64_t v25 = v49;
      *(void *)unsigned __int8 v27 = v90;
      uint64_t v29 = v27 + 8;
      if (v18 == v50) {
        goto LABEL_45;
      }
    }
    else
    {
      unint64_t v30 = v21 + 2;
      if (v21 >= -1) {
        unint64_t v30 = v21 + 1;
      }
      v27 -= 8 * (v30 >> 1);
      *(void *)unsigned __int8 v27 = v26;
      uint64_t v29 = v27 + 8;
      if (v18 == v19) {
        goto LABEL_45;
      }
    }
    do
    {
LABEL_52:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27) {
            unint64_t v59 = 1;
          }
          else {
            unint64_t v59 = (v28 - v27) >> 2;
          }
          if (v59 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v60 = (char *)operator new(8 * v59);
          uint64_t v25 = v60;
          unint64_t v61 = (v59 + 3) >> 2;
          PCSharedCount v53 = &v60[8 * v61];
          int64_t v62 = v29 - v27;
          BOOL v37 = v29 == v27;
          uint64_t v29 = v53;
          if (!v37)
          {
            uint64_t v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v63 = v62 - 8;
            long long v64 = &v60[8 * v61];
            long long v65 = v27;
            if (v63 < 0x38) {
              goto LABEL_93;
            }
            uint64_t v66 = 8 * v61;
            long long v64 = &v60[8 * v61];
            long long v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20) {
              goto LABEL_93;
            }
            uint64_t v67 = (v63 >> 3) + 1;
            uint64_t v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            long long v64 = &v53[v68];
            long long v65 = &v27[v68];
            float32x4_t v69 = (long long *)(v27 + 16);
            unint64_t v70 = &v60[v66 + 16];
            uint64_t v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v72 = *v69;
              *((_OWORD *)v70 - 1) = *(v69 - 1);
              *(_OWORD *)unint64_t v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_93:
              do
              {
                uint64_t v73 = *(void *)v65;
                v65 += 8;
                *(void *)long long v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          uint64_t v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          uint64_t v55 = (v28 - v29) >> 3;
          if (v55 >= -1) {
            unint64_t v56 = v55 + 1;
          }
          else {
            unint64_t v56 = v55 + 2;
          }
          char v57 = &v29[8 * (v56 >> 1)];
          PCSharedCount v53 = &v57[-(v29 - v27)];
          size_t v58 = v29 - v27;
          BOOL v37 = v29 == v27;
          uint64_t v29 = v57;
          if (!v37) {
            memmove(v53, v27, v58);
          }
          uint64_t v25 = v27;
        }
      }
      else
      {
        PCSharedCount v53 = v27;
      }
      uint64_t v54 = *(void *)(v18 - 8);
      v18 -= 8;
      *((void *)v53 - 1) = v54;
      uint64_t v51 = v53 - 8;
      unsigned __int8 v27 = v51;
    }
    while (v18 != *(void *)(a1 + 8));
    goto LABEL_46;
  }
  *(void *)unsigned __int8 v27 = v26;
  uint64_t v29 = v27 + 8;
  if (v18 != v19) {
    goto LABEL_52;
  }
LABEL_45:
  uint64_t v51 = v27;
LABEL_46:
  uint64_t v52 = *(char **)a1;
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v51;
  *(void *)(a1 + 16) = v29;
  *(void *)(a1 + 24) = v28;
  if (v52)
  {
    operator delete(v52);
  }
}

void sub_1B77E1064(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B77E1080(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77E1094(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77E10AC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::deque<TextureDeleteQueue::DeleteRequest>::~deque[abi:ne180100](uint64_t a1)
{
  unint64_t v2 = *(void ***)(a1 + 8);
  BOOL v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      BOOL v3 = *(void ***)(a1 + 16);
      unint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 15;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 30;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      unsigned __int8 v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::deque<TextureDeleteQueue::DeleteRequest>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x1E;
  unint64_t v4 = v2 - 30;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    uint64_t v6 = *(void **)(a1 + 8);
    unint64_t v5 = *(char **)(a1 + 16);
    unsigned __int8 v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_80:
      *(void *)unint64_t v5 = v8;
      *(void *)(a1 + 16) += 8;
      return;
    }
    uint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v31 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v31 = 1;
      }
      if (!(v31 >> 61))
      {
        unint64_t v32 = v31 >> 2;
        uint64_t v33 = 8 * v31;
        uint64_t v34 = (char *)operator new(8 * v31);
        unsigned __int8 v35 = &v34[8 * v32];
        long long v36 = &v34[v33];
        int64_t v38 = v5 - v7;
        BOOL v37 = v5 == v7;
        unint64_t v5 = v35;
        if (!v37)
        {
          unint64_t v5 = &v35[v38 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v39 = v38 - 8;
          if ((unint64_t)(v38 - 8) >= 0x38)
          {
            unsigned __int8 v74 = &v34[8 * v32];
            uint64_t v40 = v74;
            if ((unint64_t)(v74 - v7) >= 0x20)
            {
              uint64_t v75 = (v39 >> 3) + 1;
              uint64_t v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
              uint64_t v40 = &v35[v76];
              v7 += v76;
              float32x4_t v77 = (long long *)(v6 + 3);
              uint64_t v78 = v74 + 16;
              uint64_t v79 = v75 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v80 = *v77;
                *(v78 - 1) = *(v77 - 1);
                *uint64_t v78 = v80;
                v77 += 2;
                v78 += 2;
                v79 -= 4;
              }
              while (v79);
              if (v75 == (v75 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            uint64_t v40 = &v34[8 * v32];
          }
          do
          {
            uint64_t v81 = *(void *)v7;
            v7 += 8;
            *(void *)uint64_t v40 = v81;
            v40 += 8;
          }
          while (v40 != v5);
        }
        goto LABEL_78;
      }
LABEL_89:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    unint64_t v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      unsigned __int8 v7 = *(char **)(a1 + 8);
    }
    unint64_t v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_80;
  }
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 24);
  uint64_t v19 = *(void *)(a1 + 8);
  uint64_t v20 = v18 - v19;
  uint64_t v21 = (v18 - v19) >> 3;
  uint64_t v22 = v17 - *(void *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      float32x4_t v91 = operator new(0xFF0uLL);
      std::__split_buffer<HGNode **>::push_back((char **)a1, &v91);
      return;
    }
    float32x4_t v91 = operator new(0xFF0uLL);
    std::__split_buffer<HGNode **>::push_front((void **)a1, &v91);
    uint64_t v41 = *(void **)(a1 + 8);
    unint64_t v5 = *(char **)(a1 + 16);
    unsigned __int8 v7 = (char *)(v41 + 1);
    uint64_t v8 = *v41;
    *(void *)(a1 + 8) = v41 + 1;
    if (v5 != *(char **)(a1 + 24)) {
      goto LABEL_80;
    }
    uint64_t v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v42 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v42 = 1;
      }
      if (!(v42 >> 61))
      {
        unint64_t v43 = v42 >> 2;
        uint64_t v44 = 8 * v42;
        uint64_t v34 = (char *)operator new(8 * v42);
        unsigned __int8 v35 = &v34[8 * v43];
        long long v36 = &v34[v44];
        int64_t v45 = v5 - v7;
        BOOL v37 = v5 == v7;
        unint64_t v5 = v35;
        if (!v37)
        {
          unint64_t v5 = &v35[v45 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v46 = v45 - 8;
          if ((unint64_t)(v45 - 8) >= 0x38)
          {
            int v82 = &v34[8 * v43];
            unint64_t v47 = v82;
            if ((unint64_t)(v82 - v7) >= 0x20)
            {
              uint64_t v83 = (v46 >> 3) + 1;
              uint64_t v84 = 8 * (v83 & 0x3FFFFFFFFFFFFFFCLL);
              unint64_t v47 = &v35[v84];
              v7 += v84;
              int32x2_t v85 = (long long *)(v41 + 3);
              unsigned int v86 = v82 + 16;
              uint64_t v87 = v83 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v88 = *v85;
                *(v86 - 1) = *(v85 - 1);
                *unsigned int v86 = v88;
                v85 += 2;
                v86 += 2;
                v87 -= 4;
              }
              while (v87);
              if (v83 == (v83 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_78;
              }
            }
          }
          else
          {
            unint64_t v47 = &v34[8 * v43];
          }
          do
          {
            uint64_t v89 = *(void *)v7;
            v7 += 8;
            *(void *)unint64_t v47 = v89;
            v47 += 8;
          }
          while (v47 != v5);
        }
LABEL_78:
        *(void *)a1 = v34;
        *(void *)(a1 + 8) = v35;
        *(void *)(a1 + 16) = v5;
        *(void *)(a1 + 24) = v36;
        if (v9)
        {
          operator delete(v9);
          unint64_t v5 = *(char **)(a1 + 16);
        }
        goto LABEL_80;
      }
      goto LABEL_89;
    }
    goto LABEL_5;
  }
  uint64_t v23 = v22 >> 2;
  if (v17 == *(void *)a1) {
    unint64_t v24 = 1;
  }
  else {
    unint64_t v24 = v23;
  }
  if (v24 >> 61) {
    goto LABEL_89;
  }
  uint64_t v25 = (char *)operator new(8 * v24);
  BOOL v26 = operator new(0xFF0uLL);
  unsigned __int8 v27 = &v25[8 * v21];
  uint64_t v28 = &v25[8 * v24];
  if (v21 == v24)
  {
    unsigned int v90 = v26;
    if (v20 < 1)
    {
      if (v18 == v19) {
        unint64_t v48 = 1;
      }
      else {
        unint64_t v48 = v20 >> 2;
      }
      if (v48 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      int v49 = (char *)operator new(8 * v48);
      unsigned __int8 v27 = &v49[8 * (v48 >> 2)];
      uint64_t v28 = &v49[8 * v48];
      operator delete(v25);
      uint64_t v50 = *(void *)(a1 + 8);
      uint64_t v18 = *(void *)(a1 + 16);
      uint64_t v25 = v49;
      *(void *)unsigned __int8 v27 = v90;
      uint64_t v29 = v27 + 8;
      if (v18 == v50) {
        goto LABEL_45;
      }
    }
    else
    {
      unint64_t v30 = v21 + 2;
      if (v21 >= -1) {
        unint64_t v30 = v21 + 1;
      }
      v27 -= 8 * (v30 >> 1);
      *(void *)unsigned __int8 v27 = v26;
      uint64_t v29 = v27 + 8;
      if (v18 == v19) {
        goto LABEL_45;
      }
    }
    do
    {
LABEL_52:
      if (v27 == v25)
      {
        if (v29 >= v28)
        {
          if (v28 == v27) {
            unint64_t v59 = 1;
          }
          else {
            unint64_t v59 = (v28 - v27) >> 2;
          }
          if (v59 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v60 = (char *)operator new(8 * v59);
          uint64_t v25 = v60;
          unint64_t v61 = (v59 + 3) >> 2;
          PCSharedCount v53 = &v60[8 * v61];
          int64_t v62 = v29 - v27;
          BOOL v37 = v29 == v27;
          uint64_t v29 = v53;
          if (!v37)
          {
            uint64_t v29 = &v53[v62 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v63 = v62 - 8;
            long long v64 = &v60[8 * v61];
            long long v65 = v27;
            if (v63 < 0x38) {
              goto LABEL_93;
            }
            uint64_t v66 = 8 * v61;
            long long v64 = &v60[8 * v61];
            long long v65 = v27;
            if ((unint64_t)(v64 - v27) < 0x20) {
              goto LABEL_93;
            }
            uint64_t v67 = (v63 >> 3) + 1;
            uint64_t v68 = 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
            long long v64 = &v53[v68];
            long long v65 = &v27[v68];
            float32x4_t v69 = (long long *)(v27 + 16);
            unint64_t v70 = &v60[v66 + 16];
            uint64_t v71 = v67 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v72 = *v69;
              *((_OWORD *)v70 - 1) = *(v69 - 1);
              *(_OWORD *)unint64_t v70 = v72;
              v69 += 2;
              v70 += 32;
              v71 -= 4;
            }
            while (v71);
            if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_93:
              do
              {
                uint64_t v73 = *(void *)v65;
                v65 += 8;
                *(void *)long long v64 = v73;
                v64 += 8;
              }
              while (v64 != v29);
            }
          }
          uint64_t v28 = &v60[8 * v59];
          operator delete(v27);
        }
        else
        {
          uint64_t v55 = (v28 - v29) >> 3;
          if (v55 >= -1) {
            unint64_t v56 = v55 + 1;
          }
          else {
            unint64_t v56 = v55 + 2;
          }
          char v57 = &v29[8 * (v56 >> 1)];
          PCSharedCount v53 = &v57[-(v29 - v27)];
          size_t v58 = v29 - v27;
          BOOL v37 = v29 == v27;
          uint64_t v29 = v57;
          if (!v37) {
            memmove(v53, v27, v58);
          }
          uint64_t v25 = v27;
        }
      }
      else
      {
        PCSharedCount v53 = v27;
      }
      uint64_t v54 = *(void *)(v18 - 8);
      v18 -= 8;
      *((void *)v53 - 1) = v54;
      uint64_t v51 = v53 - 8;
      unsigned __int8 v27 = v51;
    }
    while (v18 != *(void *)(a1 + 8));
    goto LABEL_46;
  }
  *(void *)unsigned __int8 v27 = v26;
  uint64_t v29 = v27 + 8;
  if (v18 != v19) {
    goto LABEL_52;
  }
LABEL_45:
  uint64_t v51 = v27;
LABEL_46:
  uint64_t v52 = *(char **)a1;
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v51;
  *(void *)(a1 + 16) = v29;
  *(void *)(a1 + 24) = v28;
  if (v52)
  {
    operator delete(v52);
  }
}

void sub_1B77E16FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p)
{
  operator delete(__p);
  operator delete(v9);
  _Unwind_Resume(a1);
}

void sub_1B77E1718(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77E172C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77E1744(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::deque<HGTextureManager::TextureEntry>::~deque[abi:ne180100](uint64_t a1)
{
  unint64_t v2 = *(void ***)(a1 + 8);
  BOOL v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      BOOL v3 = *(void ***)(a1 + 16);
      unint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 21;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 42;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      unsigned __int8 v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__deque_iterator<HGTextureManager::TextureEntry,HGTextureManager::TextureEntry*,HGTextureManager::TextureEntry&,HGTextureManager::TextureEntry**,long,42l>,std::__deque_iterator<HGTextureManager::TextureEntry,HGTextureManager::TextureEntry*,HGTextureManager::TextureEntry&,HGTextureManager::TextureEntry**,long,42l>,0>@<X0>(const void **a1@<X1>, char *a2@<X2>, const void **a3@<X3>, char *a4@<X4>, const void **a5@<X5>, char *a6@<X6>, const void ***a7@<X8>)
{
  uint64_t v8 = a5;
  if (a1 == a3)
  {
    if (a2 == a4) {
      goto LABEL_42;
    }
    uint64_t v32 = (uint64_t)*a5;
    uint64_t v33 = a4;
    while (1)
    {
      int64_t v34 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&a6[-v32] >> 5);
      if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((v33 - a2) >> 5)) < v34) {
        int64_t v34 = 0xAAAAAAAAAAAAAAABLL * ((v33 - a2) >> 5);
      }
      v33 -= 96 * v34;
      a6 -= 96 * v34;
      if (v34) {
        uint64_t result = memmove(a6, v33, 96 * v34);
      }
      if (v33 == a2) {
        break;
      }
      uint64_t v35 = (uint64_t)*--v8;
      uint64_t v32 = v35;
      a6 = (char *)(v35 + 4032);
    }
    goto LABEL_40;
  }
  uint64_t v14 = *a3;
  if (*a3 != a4)
  {
    uint64_t v15 = (uint64_t)*a5;
    int64_t v16 = a4;
    while (1)
    {
      int64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&a6[-v15] >> 5);
      if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((v16 - v14) >> 5)) < v17) {
        int64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((v16 - v14) >> 5);
      }
      v16 -= 96 * v17;
      a6 -= 96 * v17;
      if (v17) {
        uint64_t result = memmove(a6, v16, 96 * v17);
      }
      if (v16 == v14) {
        break;
      }
      uint64_t v19 = (uint64_t)*--v8;
      uint64_t v15 = v19;
      a6 = (char *)(v19 + 4032);
    }
    if ((char *)*v8 + 4032 == a6)
    {
      uint64_t v20 = (char *)v8[1];
      ++v8;
      a6 = v20;
    }
  }
  uint64_t v21 = a3 - 1;
  if (a3 - 1 != a1)
  {
    uint64_t v22 = (char *)*v8;
    do
    {
      while (1)
      {
        uint64_t v23 = *v21;
        unint64_t v24 = (char *)*v21 + 4032;
        while (1)
        {
          int64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((a6 - v22) >> 5);
          if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((v24 - v23) >> 5)) < v25) {
            int64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((v24 - v23) >> 5);
          }
          v24 -= 96 * v25;
          a6 -= 96 * v25;
          if (v25) {
            uint64_t result = memmove(a6, v24, 96 * v25);
          }
          if (v24 == v23) {
            break;
          }
          BOOL v26 = (char *)*--v8;
          uint64_t v22 = v26;
          a6 = v26 + 4032;
        }
        uint64_t v22 = (char *)*v8;
        if ((char *)*v8 + 4032 == a6) {
          break;
        }
        if (--v21 == a1) {
          goto LABEL_24;
        }
      }
      unsigned __int8 v27 = (char *)v8[1];
      ++v8;
      uint64_t v22 = v27;
      a6 = v27;
      --v21;
    }
    while (v21 != a1);
  }
LABEL_24:
  uint64_t v28 = (char *)*a1 + 4032;
  if (v28 != a2)
  {
    uint64_t v29 = (uint64_t)*v8;
    while (1)
    {
      int64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&a6[-v29] >> 5);
      if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((v28 - a2) >> 5)) < v30) {
        int64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((v28 - a2) >> 5);
      }
      v28 -= 96 * v30;
      a6 -= 96 * v30;
      if (v30) {
        uint64_t result = memmove(a6, v28, 96 * v30);
      }
      if (v28 == a2) {
        break;
      }
      uint64_t v31 = (uint64_t)*--v8;
      uint64_t v29 = v31;
      a6 = (char *)(v31 + 4032);
    }
LABEL_40:
    if ((char *)*v8 + 4032 == a6)
    {
      long long v36 = (char *)v8[1];
      ++v8;
      a6 = v36;
    }
  }
LABEL_42:
  *a7 = a3;
  a7[1] = (const void **)a4;
  a7[2] = v8;
  a7[3] = (const void **)a6;
  return result;
}

const void **std::__for_each_segment[abi:ne180100]<std::__deque_iterator<HGTextureManager::TextureEntry,HGTextureManager::TextureEntry*,HGTextureManager::TextureEntry&,HGTextureManager::TextureEntry**,long,42l>,std::__move_loop<std::_ClassicAlgPolicy>::_MoveSegment<std::__deque_iterator<HGTextureManager::TextureEntry,HGTextureManager::TextureEntry*,HGTextureManager::TextureEntry&,HGTextureManager::TextureEntry**,long,42l>,std::__deque_iterator<HGTextureManager::TextureEntry,HGTextureManager::TextureEntry*,HGTextureManager::TextureEntry&,HGTextureManager::TextureEntry**,long,42l>>>(const void **result, unsigned char *__src, const void **a3, unsigned char *a4, uint64_t a5)
{
  uint64_t v6 = __src;
  uint64_t v8 = *(void ***)a5;
  unsigned __int8 v7 = *(char **)(a5 + 8);
  if (result == a3)
  {
    if (__src == a4) {
      goto LABEL_47;
    }
    uint64_t v31 = (char *)*v8++;
    int64_t v30 = v31;
    while (1)
    {
      int64_t v32 = 0xAAAAAAAAAAAAAAABLL * ((v30 - v7 + 4032) >> 5);
      if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((a4 - v6) >> 5)) >= v32) {
        unint64_t v28 = v32;
      }
      else {
        unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * ((a4 - v6) >> 5);
      }
      if (v28) {
        uint64_t result = (const void **)memmove(v7, v6, 96 * v28);
      }
      v6 += 96 * v28;
      if (v6 == a4) {
        break;
      }
      uint64_t v33 = (char *)*v8++;
      int64_t v30 = v33;
      unsigned __int8 v7 = v33;
    }
    goto LABEL_44;
  }
  uint64_t v9 = result;
  uint64_t v10 = (char *)*result + 4032;
  if (v10 == __src) {
    goto LABEL_13;
  }
  uint64_t v12 = (char *)*v8++;
  uint64_t v11 = v12;
  while (1)
  {
    int64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((v11 - v7 + 4032) >> 5);
    if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((v10 - v6) >> 5)) >= v13) {
      unint64_t v14 = v13;
    }
    else {
      unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((v10 - v6) >> 5);
    }
    if (v14) {
      uint64_t result = (const void **)memmove(v7, v6, 96 * v14);
    }
    v6 += 96 * v14;
    if (v6 == v10) {
      break;
    }
    uint64_t v15 = (char *)*v8++;
    uint64_t v11 = v15;
    unsigned __int8 v7 = v15;
  }
  v7 += 96 * v14;
  if ((char *)*(v8 - 1) + 4032 != v7)
  {
    --v8;
LABEL_13:
    *(void *)a5 = v8;
    *(void *)(a5 + 8) = v7;
    for (uint64_t i = v9 + 1; i != a3; ++i)
    {
LABEL_16:
      while (1)
      {
        uint64_t v17 = 0;
        uint64_t v18 = (char *)*i;
        uint64_t v20 = (char *)*v8++;
        uint64_t v19 = v20;
        while (1)
        {
          int64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((v19 - v7 + 4032) >> 5);
          if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((4032 - 96 * v17) >> 5)) >= v21) {
            unint64_t v22 = v21;
          }
          else {
            unint64_t v22 = 0xAAAAAAAAAAAAAAABLL * ((4032 - 96 * v17) >> 5);
          }
          if (v22) {
            uint64_t result = (const void **)memmove(v7, &v18[96 * v17], 96 * v22);
          }
          v17 += v22;
          if (v17 == 42) {
            break;
          }
          uint64_t v23 = (char *)*v8++;
          uint64_t v19 = v23;
          unsigned __int8 v7 = v23;
        }
        v7 += 96 * v22;
        if ((char *)*(v8 - 1) + 4032 != v7) {
          break;
        }
        unsigned __int8 v7 = (char *)*v8;
        *(void *)a5 = v8;
        *(void *)(a5 + 8) = v7;
        if (++i == a3) {
          goto LABEL_26;
        }
      }
      *(void *)a5 = --v8;
      *(void *)(a5 + 8) = v7;
    }
    goto LABEL_26;
  }
  unsigned __int8 v7 = (char *)*v8;
  *(void *)a5 = v8;
  *(void *)(a5 + 8) = v7;
  uint64_t i = v9 + 1;
  if (v9 + 1 != a3) {
    goto LABEL_16;
  }
LABEL_26:
  unint64_t v24 = *a3;
  if (*a3 == a4) {
    goto LABEL_47;
  }
  BOOL v26 = (char *)*v8++;
  int64_t v25 = v26;
  while (1)
  {
    int64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v25 - v7 + 4032) >> 5);
    unint64_t v28 = (uint64_t)(0xAAAAAAAAAAAAAAABLL * ((a4 - v24) >> 5)) >= v27 ? v27 : 0xAAAAAAAAAAAAAAABLL * ((a4 - v24) >> 5);
    if (v28) {
      uint64_t result = (const void **)memmove(v7, v24, 96 * v28);
    }
    v24 += 96 * v28;
    if (v24 == a4) {
      break;
    }
    uint64_t v29 = (char *)*v8++;
    int64_t v25 = v29;
    unsigned __int8 v7 = v29;
  }
LABEL_44:
  v7 += 96 * v28;
  if ((char *)*(v8 - 1) + 4032 == v7) {
    unsigned __int8 v7 = (char *)*v8;
  }
  else {
    --v8;
  }
LABEL_47:
  *(void *)a5 = v8;
  *(void *)(a5 + 8) = v7;
  return result;
}

uint64_t anonymous namespace'::UsedTexturesPrinter::operator()(unsigned int *a1, uint64_t a2, uint64_t a3, const char *a4, char *a5)
{
  uint64_t v6 = *(void *)(a2 + 32);
  unsigned __int8 v7 = atomic_load(HGLogger::_enabled);
  if (v7) {
    HGLogger::log((HGLogger *)"texManager", (const char *)*a1, (HGLogger *)"texture pool %p (rnd : %p, group : %p) :\n", a4, a5, v6, a2, *(void *)(a2 + 16));
  }
  HGLogger::indent(1);
  uint64_t v8 = (const char *)*a1;
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 16));
  uint64_t v12 = *(void *)(v6 + 88);
  if (*(void *)(v6 + 96) != v12)
  {
    unint64_t v13 = *(void *)(v6 + 112);
    unint64_t v14 = (void *)(v12 + 8 * (v13 / 0x2A));
    uint64_t v15 = (HGTextureManager::TextureEntry *)(*v14 + 96 * (v13 % 0x2A));
    unint64_t v16 = *(void *)(v12 + 8 * ((*(void *)(v6 + 120) + v13) / 0x2A)) + 96 * ((*(void *)(v6 + 120) + v13) % 0x2A);
    while (v15 != (HGTextureManager::TextureEntry *)v16)
    {
      HGTextureManager::TextureEntry::log(v15, v8, v9);
      uint64_t v15 = (HGTextureManager::TextureEntry *)((char *)v15 + 96);
      if ((HGTextureManager::TextureEntry *)((char *)v15 - *v14) == (HGTextureManager::TextureEntry *)4032)
      {
        uint64_t v17 = (HGTextureManager::TextureEntry *)v14[1];
        ++v14;
        uint64_t v15 = v17;
      }
    }
  }
  unsigned __int8 v18 = atomic_load(HGLogger::_enabled);
  if (v18) {
    HGLogger::log((HGLogger *)"texManager", (const char *)*a1, (HGLogger *)"used : %4.1f mb (active : %4.1f mb)  |  shared : %4.1f mb  |  unowned : %4.1f mb  |  (total : %4.1f mb)\n", v10, v11, (float)((float)*(unint64_t *)(v6 + 136) * 0.00000095367), (float)((float)*(unint64_t *)(v6 + 144) * 0.00000095367), (float)((float)*(unint64_t *)(v6 + 152) * 0.00000095367), (float)((float)*(unint64_t *)(v6 + 160) * 0.00000095367), (float)((float)*(unint64_t *)(v6 + 128) * 0.00000095367));
  }
  HGLogger::indent(0xFFFFFFFFLL);
  uint64_t v19 = (int64x2_t *)*((void *)a1 + 1);
  uint64_t v20 = *(void *)(v6 + 176);
  int64x2_t v21 = vaddq_s64(v19[1], *(int64x2_t *)(v6 + 144));
  int64x2_t v22 = *(int64x2_t *)(v6 + 160);
  *uint64_t v19 = vaddq_s64(*v19, *(int64x2_t *)(v6 + 128));
  v19[1] = v21;
  v19[2] = vaddq_s64(v19[2], v22);
  v19[3].i64[0] += v20;
  return pthread_mutex_unlock((pthread_mutex_t *)(v6 + 16));
}

void sub_1B77E1FEC(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

void HGCPURenderContext::HGCPURenderContext(HGCPURenderContext *this)
{
}

void sub_1B77E2228(_Unwind_Exception *a1)
{
  HGObject::operator delete(v3);
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100](v2);
  HGRenderContext::~HGRenderContext(v1);
  _Unwind_Resume(a1);
}

void sub_1B77E224C(_Unwind_Exception *a1)
{
  std::shared_ptr<HGPool::ServicingPolicy>::~shared_ptr[abi:ne180100](v2);
  HGRenderContext::~HGRenderContext(v1);
  _Unwind_Resume(a1);
}

void HGCPURenderContext::~HGCPURenderContext(std::__shared_weak_count **this)
{
  uint64_t v1 = (HGCPURenderContext *)this;
  *this = (std::__shared_weak_count *)&unk_1F10DA218;
  uint64_t v2 = this[18];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    this = (std::__shared_weak_count **)v1;
  }
  else if (((vars8 ^ (2 * vars8)) & 0x4000000000000000) != 0)
  {
    __break(0xC471u);
  }
  HGRenderContext::~HGRenderContext((HGRenderContext *)this);
}

void HGCPURenderContext::~HGCPURenderContext(HGCPURenderContext *this)
{
  *(void *)this = &unk_1F10DA218;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 18);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    HGRenderContext::~HGRenderContext(this);
  }
  else
  {
    HGRenderContext::~HGRenderContext(this);
  }
  HGObject::operator delete(v3);
}

uint64_t HGCPURenderContext::DumpContext(HGCPURenderContext *this)
{
  puts("-----------------------------------------");
  printf("Dumping HGCPURenderContext: %p\n", this);
  printf("    _state                    : %d\n", *((_DWORD *)this + 8));
  printf("    _type                     : %d\n", *((_DWORD *)this + 9));
  printf("    _numPhysicalCores         : %u\n", *(_DWORD *)(*((void *)this + 17) + 88));
  printf("    _numLogicalCores          : %u\n", *(_DWORD *)(*((void *)this + 17) + 92));
  printf("    _defaultFilteringMode     : %d\n", *((_DWORD *)this + 21));
  printf("    _intermediateBufferFormat : %d\n", *((_DWORD *)this + 20));
  printf("    _numCPURenderThreads      : %lu\n", *((void *)this + 19));
  printf("    _cpuRendererTileSizeX     : %lu\n", *((void *)this + 20));
  printf("    _cpuRendererTileSizeY     : %lu\n", *((void *)this + 21));
  printf("    _renderer                 : %p\n", *((const void **)this + 9));
  printf("    _renderQueue              : %p\n", *((const void **)this + 6));
  printf("    _renderGraphDumpLevel     : %d\n", *((_DWORD *)this + 22));
  printf("    _renderStatsFlag          : %d\n", *((unsigned __int8 *)this + 92));
  printf("    _renderStatsWarmUp        : %lu\n", *((void *)this + 12));
  printf("    _renderStatsMaxVals       : %lu\n", *((void *)this + 13));

  return puts("-----------------------------------------");
}

void HGStackPage::~HGStackPage(HGStackPage *this)
{
  uint64_t v2 = *(void *)this;
  if (v2)
  {
    HGFree(v2);
    *(void *)this = 0;
    *((void *)this + 1) = 0;
    *((void *)this + 2) = 0;
  }
}

void HGExecUnitStack::HGExecUnitStack(HGExecUnitStack *this)
{
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 36) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((void *)this + 14) = 0;
  *((_DWORD *)this + 38) = 0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((_DWORD *)this + 26) = 0;
  *((void *)this + 2CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  *((void *)this + 21) = 0;
  operator new();
}

void sub_1B77E2958(_Unwind_Exception *a1)
{
  HGStackPage::~HGStackPage((HGStackPage *)(v1 + 64));
  HGStackPage::~HGStackPage(v2);
  _Unwind_Resume(a1);
}

void HGExecUnitStack::~HGExecUnitStack(HGExecUnitStack *this)
{
  HGExecUnitStack::resetStack((HGStackPage ****)this);
LABEL_3:
  uint64_t v2 = *(HGStackPage ****)this;
  BOOL v3 = **(HGStackPage ****)this;
  while (1)
  {
    unint64_t v4 = v2[1];
    if (v3 == v4) {
      break;
    }
    unint64_t v5 = (uint64_t *)*(v4 - 1);
    v2[1] = v4 - 1;
    if (v5)
    {
      if (*v5)
      {
        HGFree(*v5);
        *unint64_t v5 = 0;
        v5[1] = 0;
        void v5[2] = 0;
      }
      MEMORY[0x1BA9BFBA0](v5, 0x1080C40347F1BC8);
      goto LABEL_3;
    }
  }
  uint64_t v6 = *((void *)this + 15);
  if (v6)
  {
    unsigned __int8 v7 = *(void **)v6;
    if (*(void *)v6)
    {
      *(void *)(v6 + 8) = v7;
      operator delete(v7);
    }
    MEMORY[0x1BA9BFBA0](v6, 0x80C40D6874129);
  }
  uint64_t v8 = *((void *)this + 16);
  if (v8)
  {
    uint64_t v9 = *(void **)v8;
    if (*(void *)v8)
    {
      *(void *)(v8 + 8) = v9;
      operator delete(v9);
    }
    MEMORY[0x1BA9BFBA0](v8, 0x80C40D6874129);
  }
  uint64_t v10 = *(HGStackPage ****)this;
  if (*(void *)this)
  {
    uint64_t v11 = *v10;
    if (*v10)
    {
      v10[1] = v11;
      operator delete(v11);
    }
    MEMORY[0x1BA9BFBA0](v10, 0x80C40D6874129);
  }
  *(void *)this = 0;
  uint64_t v12 = *((void *)this + 8);
  *(_OWORD *)((char *)this + 12CVOpenGLESTextureCacheFlush(this[3], 0) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  if (v12)
  {
    HGFree(v12);
    *((void *)this + 8) = 0;
    *((void *)this + 9) = 0;
    *((void *)this + 1CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
  }
  uint64_t v13 = *((void *)this + 1);
  if (v13)
  {
    HGFree(v13);
    *((void *)this + 1) = 0;
    *((void *)this + 2) = 0;
    *((void *)this + 3) = 0;
  }
}

void HGExecUnitStack::resetStack(HGStackPage ****this)
{
  HGExecUnitStack::rewindStack((HGExecUnitStack *)this, 0, **this[15]);
  HGExecUnitStack::rewindStack((HGExecUnitStack *)this, 1u, **this[16]);
  uint64_t v2 = (HGStackPage *****)this[16];
  this[17] = (HGStackPage ***)**this[15];
  this[18] = **v2;
  this[20] = 0;
  this[21] = 0;
  while (1)
  {
    BOOL v3 = (uint64_t **)**this;
    unint64_t v5 = (uint64_t ***)(*this + 1);
    unint64_t v4 = *v5;
    if (v3 == *v5) {
      break;
    }
    uint64_t v6 = *v3;
    if ((unint64_t)this[22] - (*v3)[6] < 0x15) {
      break;
    }
    int64_t v7 = (char *)v4 - (char *)(v3 + 1);
    if (v4 != v3 + 1) {
      memmove(**this, v3 + 1, (char *)v4 - (char *)(v3 + 1));
    }
    *unint64_t v5 = (uint64_t **)((char *)v3 + v7);
    if (*v6)
    {
      HGFree(*v6);
      *uint64_t v6 = 0;
      v6[1] = 0;
      void v6[2] = 0;
    }
    MEMORY[0x1BA9BFBA0](v6, 0x1080C40347F1BC8);
  }
}

char *HGExecUnitStack::getStack(char ***this, unint64_t a2)
{
  unint64_t v4 = this[*((unsigned int *)this + 38) + 17];
  if (*v4 && v4[1] - v4[2] >= a2) {
    goto LABEL_46;
  }
  if (a2 >= 0x2401) {
    unint64_t v5 = 9216 * ((a2 - 1) / 0x2400) + 9216;
  }
  else {
    unint64_t v5 = 9216;
  }
  uint64_t v6 = *this;
  uint64_t v8 = **this;
  int64_t v7 = (*this)[1];
  if (v8 == v7) {
    goto LABEL_21;
  }
  uint64_t v9 = (*this)[1];
  uint64_t v10 = **this;
  do
  {
    uint64_t v11 = *(void *)v10;
    v10 += 8;
    unint64_t v12 = *(void *)(v11 + 8);
    if (v12 <= 2 * v5 && v12 >= v5) {
      uint64_t v9 = v8;
    }
    uint64_t v8 = v10;
  }
  while (v10 != v7);
  if (v9 == v7) {
    goto LABEL_21;
  }
  unint64_t v4 = *(char ***)v9;
  int64_t v14 = v7 - (v9 + 8);
  if (v7 != v9 + 8) {
    memmove(v9, v9 + 8, v7 - (v9 + 8));
  }
  v6[1] = &v9[v14];
  if (!v4) {
LABEL_21:
  }
    operator new();
  uint64_t v15 = *((unsigned int *)this + 38);
  unint64_t v16 = this[v15 + 15];
  unsigned __int8 v18 = v16[1];
  unint64_t v17 = (unint64_t)v16[2];
  if ((unint64_t)v18 >= v17)
  {
    uint64_t v20 = *v16;
    uint64_t v21 = v18 - *v16;
    uint64_t v22 = v21 >> 3;
    unint64_t v23 = (v21 >> 3) + 1;
    if (v23 >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v24 = v17 - (void)v20;
    if (v24 >> 2 > v23) {
      unint64_t v23 = v24 >> 2;
    }
    if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v25 = v23;
    }
    if (v25)
    {
      if (v25 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      BOOL v26 = operator new(8 * v25);
      int64_t v27 = &v26[8 * v22];
      unint64_t v28 = &v26[8 * v25];
      *(void *)int64_t v27 = v4;
      uint64_t v19 = (uint64_t)(v27 + 8);
      uint64_t v29 = (char *)(v18 - v20);
      if (v18 == v20) {
        goto LABEL_42;
      }
    }
    else
    {
      BOOL v26 = 0;
      int64_t v27 = (char *)(8 * v22);
      unint64_t v28 = 0;
      *(void *)(8 * v22) = v4;
      uint64_t v19 = 8 * v22 + 8;
      uint64_t v29 = (char *)(v18 - v20);
      if (v18 == v20)
      {
LABEL_42:
        char *v16 = v27;
        v16[1] = (char *)v19;
        _OWORD v16[2] = v28;
        if (v18)
        {
          operator delete(v18);
          uint64_t v15 = *((unsigned int *)this + 38);
        }
        goto LABEL_44;
      }
    }
    unint64_t v30 = (unint64_t)(v29 - 8);
    if (v30 < 0x58) {
      goto LABEL_53;
    }
    if ((unint64_t)(v18 - &v26[v21]) < 0x20) {
      goto LABEL_53;
    }
    uint64_t v31 = (v30 >> 3) + 1;
    uint64_t v32 = 8 * (v31 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v33 = &v18[-v32];
    v27 -= v32;
    int64_t v34 = &v26[8 * v22 - 16];
    uint64_t v35 = v18 - 16;
    uint64_t v36 = v31 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v37 = *(_OWORD *)v35;
      *(v34 - 1) = *((_OWORD *)v35 - 1);
      *int64_t v34 = v37;
      v34 -= 2;
      v35 -= 32;
      v36 -= 4;
    }
    while (v36);
    unsigned __int8 v18 = v33;
    if (v31 != (v31 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_53:
      do
      {
        uint64_t v38 = *((void *)v18 - 1);
        v18 -= 8;
        *((void *)v27 - 1) = v38;
        v27 -= 8;
      }
      while (v18 != v20);
    }
    unsigned __int8 v18 = *v16;
    goto LABEL_42;
  }
  *(void *)unsigned __int8 v18 = v4;
  uint64_t v19 = (uint64_t)(v18 + 8);
LABEL_44:
  v16[1] = (char *)v19;
  this[v15 + 17] = v4;
  unint64_t v39 = (unint64_t)this[21];
  unint64_t v40 = (unint64_t)&this[20][2 * (void)v4[1]];
  this[20] = (char **)v40;
  if (v40 > v39) {
    this[21] = (char **)v40;
  }
LABEL_46:
  if (a2)
  {
    unint64_t v41 = (unint64_t)&v4[4][a2];
    v4[3] = (char *)a2;
    v4[4] = (char *)v41;
    ++*((_DWORD *)v4 + 10);
  }
  return &(*v4)[16 * (void)v4[2]];
}

void sub_1B77E2F18(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x1080C40347F1BC8);
  _Unwind_Resume(a1);
}

void HGExecUnitStack::rewindStack(HGExecUnitStack *this, unsigned int a2, HGStackPage *a3)
{
  unint64_t v4 = (void *)*((void *)this + a2 + 15);
  uint64_t v5 = v4[1];
  if (*v4 != v5)
  {
    uint64_t v31 = (void *)*((void *)this + a2 + 15);
    while (1)
    {
      uint64_t v10 = *(HGStackPage **)(v5 - 8);
      uint64_t v8 = v5 - 8;
      uint64_t v9 = v10;
      if (v10 == a3) {
        goto LABEL_28;
      }
      v4[1] = v8;
      *((void *)v9 + 2) = 0;
      *((void *)v9 + 6) = *((void *)this + 22);
      uint64_t v11 = *(HGStackPage ****)this;
      uint64_t v13 = *(HGStackPage ***)(*(void *)this + 8);
      unint64_t v12 = *(void *)(*(void *)this + 16);
      if ((unint64_t)v13 >= v12) {
        break;
      }
      uint64_t *v13 = v9;
      uint64_t v7 = (uint64_t)(v13 + 1);
LABEL_4:
      v11[1] = (HGStackPage **)v7;
      *((void *)this + 20) -= 16 * *((void *)v9 + 1);
      uint64_t v5 = v4[1];
      if (*v4 == v5) {
        goto LABEL_28;
      }
    }
    int64_t v14 = *v11;
    uint64_t v15 = (char *)v13 - (char *)*v11;
    uint64_t v16 = v15 >> 3;
    unint64_t v17 = (v15 >> 3) + 1;
    if (v17 >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v18 = v12 - (void)v14;
    if (v18 >> 2 > v17) {
      unint64_t v17 = v18 >> 2;
    }
    if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v19 = v17;
    }
    if (v19)
    {
      if (v19 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v20 = operator new(8 * v19);
      uint64_t v21 = (HGStackPage **)&v20[8 * v16];
      const char *v21 = v9;
      uint64_t v7 = (uint64_t)(v21 + 1);
      if (v13 == v14) {
        goto LABEL_25;
      }
    }
    else
    {
      uint64_t v20 = 0;
      uint64_t v21 = (HGStackPage **)(8 * v16);
      *(void *)(8 * v16) = v9;
      uint64_t v7 = 8 * v16 + 8;
      if (v13 == v14)
      {
LABEL_25:
        char *v11 = v21;
        v11[1] = (HGStackPage **)v7;
        v11[2] = (HGStackPage **)&v20[8 * v19];
        if (v13) {
          operator delete(v13);
        }
        unint64_t v4 = v31;
        goto LABEL_4;
      }
    }
    unint64_t v22 = (char *)(v13 - 1) - (char *)v14;
    if (v22 < 0x58) {
      goto LABEL_33;
    }
    if ((unint64_t)((char *)v13 - &v20[v15]) < 0x20) {
      goto LABEL_33;
    }
    uint64_t v23 = (v22 >> 3) + 1;
    uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
    unint64_t v25 = &v13[v24 / 0xFFFFFFFFFFFFFFF8];
    uint64_t v21 = (HGStackPage **)((char *)v21 - v24);
    BOOL v26 = &v20[8 * v16 - 16];
    int64_t v27 = v13 - 2;
    uint64_t v28 = v23 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v29 = *(_OWORD *)v27;
      *(v26 - 1) = *((_OWORD *)v27 - 1);
      *BOOL v26 = v29;
      v26 -= 2;
      v27 -= 4;
      v28 -= 4;
    }
    while (v28);
    uint64_t v13 = v25;
    if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_33:
      do
      {
        unint64_t v30 = *--v13;
        *--uint64_t v21 = v30;
      }
      while (v13 != v14);
    }
    uint64_t v13 = *v11;
    goto LABEL_25;
  }
LABEL_28:
  *((void *)a3 + 2) = 0;
}

void HGExecutionUnit::HGExecutionUnit(HGExecutionUnit *this, HGRenderer *a2)
{
}

void sub_1B77E31FC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v2, 0x20C4093837F09);
  HGSampler::~HGSampler(v1);
  _Unwind_Resume(a1);
}

void sub_1B77E3244(_Unwind_Exception *a1)
{
  HGSampler::~HGSampler(v1);
  _Unwind_Resume(a1);
}

double HGExecutionUnit::ClearStats(HGExecutionUnit *this)
{
  uint64_t v1 = *((void *)this + 52);
  *(void *)(v1 + 96) = 0;
  double result = 0.0;
  *(_OWORD *)(v1 + 64) = 0u;
  *(_OWORD *)(v1 + 8CVOpenGLESTextureCacheFlush(this[3], 0) = 0u;
  *(_OWORD *)(v1 + 32) = 0u;
  *(_OWORD *)(v1 + 48) = 0u;
  *(_OWORD *)uint64_t v1 = 0u;
  *(_OWORD *)(v1 + 16) = 0u;
  return result;
}

void HGExecutionUnit::~HGExecutionUnit(HGExecutionUnit *this)
{
  uint64_t v2 = (_opaque_pthread_t *)*((void *)this + 21);
  if (v2)
  {
    pthread_cancel(v2);
    pthread_cond_signal((pthread_cond_t *)this + 5);
    pthread_join(*((pthread_t *)this + 21), 0);
  }
  pthread_cond_destroy((pthread_cond_t *)this + 5);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 176));
  BOOL v3 = (HGStats::UnitStats *)*((void *)this + 53);
  if (v3)
  {
    HGStats::UnitStats::~UnitStats(v3);
    MEMORY[0x1BA9BFBA0]();
  }
  *((void *)this + 53) = 0;
  unint64_t v4 = (HGExecUnitStack *)*((void *)this + 18);
  if (v4)
  {
    HGExecUnitStack::~HGExecUnitStack(v4);
    MEMORY[0x1BA9BFBA0]();
  }
  *((void *)this + 18) = 0;
  uint64_t v5 = *((void *)this + 54);
  if (v5) {
    HGFree(v5);
  }
  uint64_t v6 = *((void *)this + 37);
  if (v6) {
    dispatch_release(v6);
  }

  HGSampler::~HGSampler(this);
}

char *HGExecutionUnit::GetStack(char ****this, unint64_t a2)
{
  return HGExecUnitStack::getStack(this[18], a2);
}

uint64_t HGExecutionUnit::GetStackState@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 144);
  uint64_t v3 = *(void *)(v2 + 136);
  uint64_t v4 = *(void *)(v2 + 144);
  *(void *)a2 = v3;
  *(void *)(a2 + 8) = v4;
  uint64_t v5 = *(void *)(v4 + 16);
  *(void *)(a2 + 16) = *(void *)(v3 + 16);
  *(void *)(a2 + 24) = v5;
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(v2 + 152);
  return this;
}

void HGExecutionUnit::SetStackState(uint64_t a1, long long *a2)
{
  uint64_t v2 = *(void *)(a1 + 144);
  uint64_t v3 = *((void *)a2 + 2);
  uint64_t v4 = *((void *)a2 + 3);
  int v5 = *((_DWORD *)a2 + 8);
  long long v6 = *a2;
  *(_OWORD *)(v2 + 136) = *a2;
  *(_DWORD *)(v2 + 152) = v5;
  HGExecUnitStack::rewindStack((HGExecUnitStack *)v2, 0, (HGStackPage *)v6);
  HGExecUnitStack::rewindStack((HGExecUnitStack *)v2, 1u, *(HGStackPage **)(v2 + 144));
  uint64_t v7 = *(void *)(v2 + 144);
  *(void *)(*(void *)(v2 + 136) + 16) += v3;
  *(void *)(v7 + 16) += v4;
}

uint64_t HGExecutionUnit::SwapStack(uint64_t this)
{
  *(_DWORD *)(*(void *)(this + 144) + 152) = *(_DWORD *)(*(void *)(this + 144) + 152) == 0;
  return this;
}

uint64_t HGExecutionUnit::CommitStack(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(*(void *)(result + 144) + 8 * *(unsigned int *)(*(void *)(result + 144) + 152) + 136);
  uint64_t v4 = v3[2];
  if (*v3 + 16 * v4 == a2) {
    v3[2] = v4 + a3;
  }
  return result;
}

uint64_t HGExecutionUnit::StackSize(HGExecutionUnit *this)
{
  return *(void *)(*((void *)this + 18) + 168);
}

void HGExecutionUnit::Execute(HGExecutionUnit *this)
{
  ++*(void *)(*((void *)this + 18) + 176);
  uint64_t v2 = *((void *)this + 19);
  uint64_t v3 = *(int **)(v2 + 272);
  int v36 = v3[1];
  int v37 = *v3;
  int v34 = v3[3];
  int v35 = v3[2];
  int v4 = *(_DWORD *)(v2 + 592);
  int v5 = *(_DWORD *)(v2 + 588);
  unsigned int v40 = 0;
  uint64_t v39 = 0;
  unint64_t v6 = 0;
  int v7 = *((_DWORD *)this + 40);
  BOOL v8 = -v7 < 0;
  int v9 = -v7 & 7;
  int v10 = v7 & 7;
  if (!v8) {
    int v10 = -v9;
  }
  long long v33 = hg_eu_color[v10];
  uint64_t v11 = *((void *)v3 + 3);
  if (!*(void *)(v11 + 192) && (*(unsigned char *)(v11 + 16) & 0x80) != 0)
  {
    BOOL IsNull = HGRect::IsNull((HGRect *)v3);
    uint64_t v23 = (_DWORD *)*((void *)this + 19);
    Stacuint64_t k = 0;
    if (IsNull) {
      signed int v17 = 0;
    }
    else {
      signed int v17 = v23[149];
    }
    int v38 = 1;
    signed int v15 = 1;
    if (!(*(unsigned int (**)(_DWORD *, uint64_t))(*(void *)v23 + 128))(v23, 28)) {
      goto LABEL_26;
    }
    goto LABEL_20;
  }
  int v12 = 4 * *(_DWORD *)(v2 + 596);
  int v13 = HGFormatUtils::tileWidthFactorRequirement(*(_DWORD *)(*((void *)v3 + 2) + 16));
  float v14 = (float)(v35 - v37);
  int v5 = v5 / (4 * v13) * 4 * v13;
  signed int v15 = vcvtps_s32_f32(v14 / (float)v5);
  float v16 = (float)(v34 - v36);
  signed int v17 = v15 * vcvtps_s32_f32(v16 / (float)v4);
  if (v17 < v12)
  {
    BOOL v18 = v4 > 1;
    for (BOOL i = v5 > 1; v5 > 1 || v4 >= 2; BOOL i = v5 > 1)
    {
      if (v4 >= v5)
      {
        v4 >>= v18;
      }
      else
      {
        if ((v5 >> 1) % v13) {
          break;
        }
        if (i) {
          v5 >>= 1;
        }
      }
      signed int v15 = vcvtps_s32_f32(v14 / (float)v5);
      signed int v17 = vcvtps_s32_f32(v16 / (float)v4) * v15;
      if (v17 >= v12) {
        break;
      }
      BOOL v18 = v4 > 1;
    }
  }
  Stacuint64_t k = HGExecUnitStack::getStack(*((char ****)this + 18), v4 * v5);
  int v38 = 0;
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)this + 19) + 128))(*((void *)this + 19), 28))
  {
LABEL_20:
    if (!*((void *)this + 54)) {
      *((void *)this + 54) = HGMalloc(0x100000);
    }
  }
LABEL_26:
  for (int j = atomic_fetch_add(*(atomic_uint *volatile *)(*((void *)this + 19) + 280), 1u);
        j < v17;
        int j = atomic_fetch_add(*(atomic_uint *volatile *)(*((void *)this + 19) + 280), 1u))
  {
    if (v38)
    {
      uint64_t v25 = *((void *)v3 + 2);
      HGRenderer::RenderTile(*((void *)this + 19), (int *)this, *(char **)(v25 + 80), *(void *)(v25 + 20), *(void *)(v25 + 28), *((void *)v3 + 3), (*(void *)(v25 + 64) / *(void *)(v25 + 56))- *(void *)(v25 + 28)+ *(void *)(v25 + 20));
      int v26 = *(_DWORD *)(*((void *)this + 52) + 100);
      int64_t v27 = (HGRenderer *)*((void *)this + 19);
      if (v26) {
        goto LABEL_40;
      }
    }
    else
    {
      uint64_t v28 = (v37 + j % v15 * v5);
      uint64_t v29 = (v36 + j / v15 * v4);
      LODWORD(v3CVOpenGLESTextureCacheFlush(this[3], 0) = v29 + v4;
      LODWORD(v31) = v28 + v5;
      if ((int)v29 + v4 >= v34) {
        uint64_t v30 = v34;
      }
      else {
        uint64_t v30 = v30;
      }
      if ((int)v31 >= v35) {
        uint64_t v31 = v35;
      }
      else {
        uint64_t v31 = v31;
      }
      unint64_t v6 = v31 | (v30 << 32);
      unsigned int v40 = v37 + j % v15 * v5;
      HGRenderer::RenderTile(*((void *)this + 19), (int *)this, Stack, v28 | (v29 << 32), v6, *((void *)v3 + 3), 0);
      uint64_t v39 = (v36 + j / v15 * v4);
      int v26 = *(_DWORD *)(*((void *)this + 52) + 100);
      int64_t v27 = (HGRenderer *)*((void *)this + 19);
      if (v26)
      {
LABEL_40:
        int v32 = *((_DWORD *)v27 + 167);
        if (v32 != 2 && (v26 < 0 || v32 == 1)) {
          return;
        }
      }
    }
    if (HGRenderer::RenderCheckPoint(v27)) {
      return;
    }
    *(float *)(*((void *)this + 52) + 96) = (float)j / (float)(v17 - 1);
    if (Stack)
    {
      if (*(_DWORD *)(*((void *)this + 19) + 608)) {
        *(_OWORD *)Stacuint64_t k = v33;
      }
      HGStats::ProfilerScopeGuard::ProfilerScopeGuard(v41, *((void *)this + 53), 2, (HIDWORD(v6) - v39) * (v6 - v40), *(void *)(*((void *)v3 + 2) + 56) * (HIDWORD(v6) - v39) * (v6 - v40));
      (*(void (**)(void, char *, unint64_t, unint64_t))(**((void **)v3 + 2) + 80))(*((void *)v3 + 2), Stack, v40 | (unint64_t)(v39 << 32), v6);
      HGStats::ProfilerScopeGuard::~ProfilerScopeGuard((HGStats::ProfilerScopeGuard *)v41);
    }
  }
  *(_DWORD *)(*((void *)this + 52) + 96) = 1065353216;
}

void sub_1B77E3878(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  HGStats::ProfilerScopeGuard::~ProfilerScopeGuard((HGStats::ProfilerScopeGuard *)va);
  _Unwind_Resume(a1);
}

uint64_t HGExecutionUnit::BgnExec(HGExecutionUnit *this)
{
  HGExecUnitStack::resetStack(*((HGStackPage *****)this + 18));
  if (*((_DWORD *)this + 40))
  {
    uint64_t v2 = (pthread_t *)((char *)this + 168);
    if (*((void *)this + 21)) {
      goto LABEL_7;
    }
  }
  else
  {
    atomic_store(0, *(unsigned int **)(*((void *)this + 19) + 280));
    uint64_t v2 = (pthread_t *)((char *)this + 168);
    if (*((void *)this + 21)) {
      goto LABEL_7;
    }
  }
  uint64_t result = pthread_create(v2, 0, (void *(__cdecl *)(void *))hg_pthread_loop, this);
  if (result)
  {
    *(_DWORD *)(*((void *)this + 19) + 596) = *((_DWORD *)this + 40);
    return result;
  }
LABEL_7:
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 176));
  *((unsigned char *)this + 288) = 1;
  pthread_cond_signal((pthread_cond_t *)this + 5);

  return pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 176));
}

void hg_pthread_loop(char *a1)
{
  snprintf(__str, 0x200uLL, "com.apple.helium-unit.%d.%d", *(_DWORD *)(*((void *)a1 + 19) + 1016), *((_DWORD *)a1 + 40));
  pthread_setname_np(__str);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 176));
  if (!a1[288]) {
    goto LABEL_4;
  }
  while (1)
  {
    do
    {
      (*(void (**)(void, uint64_t))(**((void **)a1 + 19) + 128))(*((void *)a1 + 19), 6);
      dispatch_group_async_f(*((dispatch_group_t *)a1 + 37), 0, a1, (dispatch_function_t)ExecuteUnitGCD);
      dispatch_group_wait(*((dispatch_group_t *)a1 + 37), 0xFFFFFFFFFFFFFFFFLL);
      a1[288] = 0;
      pthread_cond_signal((pthread_cond_t *)a1 + 5);
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 176));
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 176));
    }
    while (a1[288]);
    do
    {
LABEL_4:
      pthread_cond_wait((pthread_cond_t *)a1 + 5, (pthread_mutex_t *)(a1 + 176));
      pthread_testcancel();
    }
    while (!a1[288]);
  }
}

uint64_t HGExecutionUnit::EndExec(pthread_cond_t *this)
{
  uint64_t v2 = (pthread_mutex_t *)&this[3].__opaque[24];
  pthread_mutex_lock((pthread_mutex_t *)&this[3].__opaque[24]);
  while (LOBYTE(this[6].__sig))
    pthread_cond_wait(this + 5, v2);

  return pthread_mutex_unlock(v2);
}

void HGExecutionUnit::RenderTile(uint64_t a1, char *a2, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  HGStats::ProfilerScopeGuard::ProfilerScopeGuard(v12, *(HGStats::UnitStatsImpl ***)(a1 + 424), 0);
  HGRenderer::RenderTile(*(void *)(a1 + 152), (int *)a1, a2, a3, a4, a5, a6);
  HGStats::ProfilerScopeGuard::~ProfilerScopeGuard((HGStats::ProfilerScopeGuard *)v12);
}

{
  HGStats::UnitStatsImpl *v12[2];

  HGStats::ProfilerScopeGuard::ProfilerScopeGuard(v12, *(HGStats::UnitStatsImpl ***)(a1 + 424), 0);
  HGRenderer::RenderTile(*(void *)(a1 + 152), (int *)a1, a2, a3, a4, a5, a6);
  HGStats::ProfilerScopeGuard::~ProfilerScopeGuard((HGStats::ProfilerScopeGuard *)v12);
}

void sub_1B77E3BFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1B77E3C94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void HGExecutionUnit::PushStats(HGExecutionUnit *this)
{
}

int64x2_t *HGExecutionUnit::PopStats(HGExecutionUnit *this)
{
  uint64_t result = (int64x2_t *)*((void *)this + 52);
  uint64_t v3 = (int64x2_t *)result[6].i64[1];
  if (v3)
  {
    int64x2_t v4 = v3[1];
    int64x2_t *v3 = vaddq_s64(*v3, *result);
    v3[1] = vaddq_s64(v4, result[1]);
    int64x2_t v5 = v3[3];
    v3[2] = vaddq_s64(v3[2], result[2]);
    v3[3] = vaddq_s64(v5, result[3]);
    v3[5] = vaddq_s64(v3[5], result[5]);
    __int32 v6 = result[6].i32[1];
    if (v6) {
      v3[6].i32[1] = v6;
    }
    uint64_t result = (int64x2_t *)MEMORY[0x1BA9BFBA0]();
    *((void *)this + 52) = v3;
  }
  return result;
}

float timeDiff@<S0>(const uint64_t *a1@<X0>, const uint64_t *a2@<X1>, _DWORD *a3@<X8>)
{
  int64x2_t v5 = localtime(a1);
  int tm_sec = v5->tm_sec;
  int32x2_t v7 = *(int32x2_t *)&v5->tm_min;
  BOOL v8 = localtime(a2);
  int v9 = v8->tm_sec;
  int32x2_t v10 = *(int32x2_t *)&v8->tm_min;
  a3[1] = 0;
  a3[2] = 0;
  int32x2_t v11 = vmul_s32(vsub_s32(v10, v7), (int32x2_t)0xE100000003CLL);
  int v12 = v9 - tm_sec + v11.i32[0] + v11.i32[1];
  double v13 = (double)v12;
  double __y = 0.0;
  if (v12 >= 3601)
  {
    double v13 = modf(v13 / 3600.0, &__y) * 3600.0;
    float v14 = __y;
    a3[2] = llroundf(v14);
  }
  if (v13 > 60.0)
  {
    double v13 = modf(v13 / 60.0, &__y) * 60.0;
    float v15 = __y;
    a3[1] = llroundf(v15);
  }
  float result = v13;
  *a3 = llroundf(result);
  return result;
}

void ROIStatIO::~ROIStatIO(ROIStatIO *this, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(void *)this = *a2;
  int64x2_t v5 = (ROIStatIO *)a2[5];
  *(void *)((char *)this + *(void *)(v4 - 24)) = v5;
  ROIStatIO::open(v5);
  ROIStatIO::writeList(this);
  if (!std::filebuf::close()) {
    std::ios_base::clear((std::ios_base *)((char *)this + *(void *)(*(void *)this - 24)), *(_DWORD *)((char *)this + *(void *)(*(void *)this - 24) + 32) | 4);
  }
  uint64_t v6 = *((void *)this + 52);
  if (v6)
  {
    uint64_t v7 = *((void *)this + 53);
    BOOL v8 = (void *)*((void *)this + 52);
    if (v7 == v6)
    {
LABEL_13:
      *((void *)this + 53) = v6;
      operator delete(v8);
      goto LABEL_14;
    }
    while (1)
    {
      if (*(char *)(v7 - 1) < 0)
      {
        operator delete(*(void **)(v7 - 24));
        if (*(char *)(v7 - 49) < 0) {
LABEL_11:
        }
          operator delete(*(void **)(v7 - 72));
      }
      else if (*(char *)(v7 - 49) < 0)
      {
        goto LABEL_11;
      }
      v7 -= 72;
      if (v7 == v6)
      {
        BOOL v8 = (void *)*((void *)this + 52);
        goto LABEL_13;
      }
    }
  }
LABEL_14:
  uint64_t v9 = a2[1];
  *(void *)this = v9;
  *(void *)((char *)this + *(void *)(v9 - 24)) = a2[4];
  MEMORY[0x1BA9BF710]((char *)this + 8);

  std::ostream::~ostream();
}

uint64_t ROIStatIO::open(ROIStatIO *this)
{
  uint64_t v1 = getenv("ROI_DATA_PATH");
  if (v1) {
    uint64_t v2 = v1;
  }
  else {
    uint64_t v2 = "./ROIData.txt";
  }
  size_t v3 = strlen(v2);
  if (v3 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint64_t v4 = (void *)v3;
  if (v3 >= 0x17)
  {
    uint64_t v8 = (v3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v3 | 7) != 0x17) {
      uint64_t v8 = v3 | 7;
    }
    uint64_t v9 = v8 + 1;
    int64x2_t v5 = (void **)operator new(v8 + 1);
    __dst[1] = v4;
    unint64_t v11 = v9 | 0x8000000000000000;
    __dst[0] = v5;
  }
  else
  {
    HIBYTE(v11) = v3;
    int64x2_t v5 = __dst;
    if (!v3)
    {
      LOBYTE(__dst[0]) = 0;
      if (ROIStatIO::_pThis) {
        goto LABEL_8;
      }
LABEL_15:
      operator new();
    }
  }
  memmove(v5, v2, (size_t)v4);
  *((unsigned char *)v4 + (void)v5) = 0;
  if (!ROIStatIO::_pThis) {
    goto LABEL_15;
  }
LABEL_8:
  std::ofstream::open();
  uint64_t v6 = ROIStatIO::_pThis;
  if (SHIBYTE(v11) < 0) {
    operator delete(__dst[0]);
  }
  return v6;
}

void ROIStatIO::writeList(ROIStatIO *this)
{
  if (ROIStatIO::_pThis)
  {
    if (!*(_DWORD *)(ROIStatIO::_pThis + *(void *)(*(void *)ROIStatIO::_pThis - 24) + 32))
    {
      if (*(void *)(ROIStatIO::_pThis + 128))
      {
        uint64_t v5 = time(0);
        timeDiff((const uint64_t *)this + 55, &v5, &v4);
        for (uint64_t i = *((void *)this + 52); i != *((void *)this + 53); i += 72)
        {
          if ((*(_DWORD *)(i + 28) & 0x80000000) != 0)
          {
            uint64_t v2 = (ROIStatIO *)ROIStatIO::writePassValue(v2, (const ROIStatIO::ROITestSet *)i, &v4);
          }
          else if (*(double *)(i + 40) / (double)*(int *)(i + 32) >= 1.0)
          {
            uint64_t v2 = (ROIStatIO *)ROIStatIO::writeOverValue(v2, (const ROIStatIO::ROITestSet *)i, &v4);
          }
          else
          {
            uint64_t v2 = (ROIStatIO *)ROIStatIO::writeUnderValue(v2, (const ROIStatIO::ROITestSet *)i, &v4);
          }
        }
      }
    }
  }
}

void ROIStatIO::~ROIStatIO(ROIStatIO *this)
{
  MEMORY[0x1BA9BFAB0](v1 + 448);
}

{
  uint64_t v1;
  uint64_t vars8;

  MEMORY[0x1BA9BFAB0](v1 + 448);

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'ROIStatIO::~ROIStatIO(ROIStatIO *this)
{
  JUMPOUT(0x1BA9BFAB0);
}

{
  ROIStatIO *v1;
  uint64_t vars8;

  uint64_t v1 = (ROIStatIO *)((char *)this + *(void *)(*(void *)this - 24));
  MEMORY[0x1BA9BFAB0]((char *)v1 + 448);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t ROIStatIO::writeUnderValue(ROIStatIO *this, const ROIStatIO::ROITestSet *a2, const tm *a3)
{
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v24);
  tm v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)"under ", 6);
  uint64_t v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)"name ", 5);
  int v6 = *((char *)a2 + 23);
  if (v6 >= 0) {
    uint64_t v7 = a2;
  }
  else {
    uint64_t v7 = *(const ROIStatIO::ROITestSet **)a2;
  }
  if (v6 >= 0) {
    uint64_t v8 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    uint64_t v8 = *((void *)a2 + 1);
  }
  uint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)v7, v8);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)" frame ", 7);
  int32x2_t v10 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)" input ", 7);
  unint64_t v11 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)" time ", 6);
  int v12 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)"H", 1);
  double v13 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"M", 1);
  float v14 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"S", 1);
  std::stringbuf::str();
  if ((v23 & 0x80u) == 0) {
    float v15 = __p;
  }
  else {
    float v15 = (void **)__p[0];
  }
  puts((const char *)v15);
  if ((char)v23 < 0) {
    operator delete(__p[0]);
  }
  float v16 = (void *)ROIStatIO::_pThis;
  std::stringbuf::str();
  if ((v23 & 0x80u) == 0) {
    signed int v17 = __p;
  }
  else {
    signed int v17 = (void **)__p[0];
  }
  if ((v23 & 0x80u) == 0) {
    uint64_t v18 = v23;
  }
  else {
    uint64_t v18 = (uint64_t)__p[1];
  }
  unint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)v17, v18);
  std::ios_base::getloc((const std::ios_base *)((char *)v19 + *(void *)(*v19 - 24)));
  uint64_t v20 = std::locale::use_facet(&v27, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v20->__vftable[2].~facet_0)(v20, 10);
  std::locale::~locale(&v27);
  std::ostream::put();
  std::ostream::flush();
  if ((char)v23 < 0) {
    operator delete(__p[0]);
  }
  v24[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v24 + *(void *)(v24[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v24[1] = MEMORY[0x1E4FBA470] + 16;
  if (v25 < 0) {
    operator delete((void *)v24[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1BA9BFAB0](&v26);
}

void sub_1B77E47BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B77E47D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B77E47E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  std::locale::~locale((std::locale *)(v16 - 40));
  if (a15 < 0)
  {
    operator delete(__p);
    std::ostringstream::~ostringstream((uint64_t)&a16);
    _Unwind_Resume(a1);
  }
  std::ostringstream::~ostringstream((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t ROIStatIO::writeOverValue(ROIStatIO *this, const ROIStatIO::ROITestSet *a2, const tm *a3)
{
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v25);
  tm v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)"over ", 5);
  uint64_t v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)"name ", 5);
  int v6 = *((char *)a2 + 23);
  if (v6 >= 0) {
    uint64_t v7 = a2;
  }
  else {
    uint64_t v7 = *(const ROIStatIO::ROITestSet **)a2;
  }
  if (v6 >= 0) {
    uint64_t v8 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    uint64_t v8 = *((void *)a2 + 1);
  }
  uint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)v7, v8);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)" frame ", 7);
  int32x2_t v10 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)" input ", 7);
  unint64_t v11 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)" ratio ", 7);
  int v12 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" time ", 6);
  double v13 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"H", 1);
  float v14 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"M", 1);
  float v15 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)"S", 1);
  std::stringbuf::str();
  if ((v24 & 0x80u) == 0) {
    uint64_t v16 = __p;
  }
  else {
    uint64_t v16 = (void **)__p[0];
  }
  puts((const char *)v16);
  if ((char)v24 < 0) {
    operator delete(__p[0]);
  }
  signed int v17 = (void *)ROIStatIO::_pThis;
  std::stringbuf::str();
  if ((v24 & 0x80u) == 0) {
    uint64_t v18 = __p;
  }
  else {
    uint64_t v18 = (void **)__p[0];
  }
  if ((v24 & 0x80u) == 0) {
    uint64_t v19 = v24;
  }
  else {
    uint64_t v19 = (uint64_t)__p[1];
  }
  uint64_t v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)v18, v19);
  std::ios_base::getloc((const std::ios_base *)((char *)v20 + *(void *)(*v20 - 24)));
  uint64_t v21 = std::locale::use_facet(&v28, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v21->__vftable[2].~facet_0)(v21, 10);
  std::locale::~locale(&v28);
  std::ostream::put();
  std::ostream::flush();
  if ((char)v24 < 0) {
    operator delete(__p[0]);
  }
  v25[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v25 + *(void *)(v25[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v25[1] = MEMORY[0x1E4FBA470] + 16;
  if (v26 < 0) {
    operator delete((void *)v25[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1BA9BFAB0](&v27);
}

void sub_1B77E4B30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B77E4B44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B77E4B58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  std::locale::~locale((std::locale *)(v16 - 40));
  if (a15 < 0)
  {
    operator delete(__p);
    std::ostringstream::~ostringstream((uint64_t)&a16);
    _Unwind_Resume(a1);
  }
  std::ostringstream::~ostringstream((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t ROIStatIO::writePassValue(ROIStatIO *this, const ROIStatIO::ROITestSet *a2, const tm *a3)
{
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v23);
  tm v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)"pass ", 5);
  uint64_t v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)"name ", 5);
  int v6 = *((char *)a2 + 23);
  if (v6 >= 0) {
    uint64_t v7 = a2;
  }
  else {
    uint64_t v7 = *(const ROIStatIO::ROITestSet **)a2;
  }
  if (v6 >= 0) {
    uint64_t v8 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    uint64_t v8 = *((void *)a2 + 1);
  }
  uint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)v7, v8);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)" frame ", 7);
  int32x2_t v10 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)" time ", 6);
  unint64_t v11 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)"H", 1);
  int v12 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)"M", 1);
  double v13 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)"S", 1);
  std::stringbuf::str();
  if ((v22 & 0x80u) == 0) {
    float v14 = __p;
  }
  else {
    float v14 = (void **)__p[0];
  }
  puts((const char *)v14);
  if ((char)v22 < 0) {
    operator delete(__p[0]);
  }
  float v15 = (void *)ROIStatIO::_pThis;
  std::stringbuf::str();
  if ((v22 & 0x80u) == 0) {
    uint64_t v16 = __p;
  }
  else {
    uint64_t v16 = (void **)__p[0];
  }
  if ((v22 & 0x80u) == 0) {
    uint64_t v17 = v22;
  }
  else {
    uint64_t v17 = (uint64_t)__p[1];
  }
  uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)v16, v17);
  std::ios_base::getloc((const std::ios_base *)((char *)v18 + *(void *)(*v18 - 24)));
  uint64_t v19 = std::locale::use_facet(&v26, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v19->__vftable[2].~facet_0)(v19, 10);
  std::locale::~locale(&v26);
  std::ostream::put();
  std::ostream::flush();
  if ((char)v22 < 0) {
    operator delete(__p[0]);
  }
  v23[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v23 + *(void *)(v23[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v23[1] = MEMORY[0x1E4FBA470] + 16;
  if (v24 < 0) {
    operator delete((void *)v23[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1BA9BFAB0](&v25);
}

void sub_1B77E4E64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B77E4E78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B77E4E8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  std::locale::~locale((std::locale *)(v16 - 40));
  if (a15 < 0)
  {
    operator delete(__p);
    std::ostringstream::~ostringstream((uint64_t)&a16);
    _Unwind_Resume(a1);
  }
  std::ostringstream::~ostringstream((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void ROIStatIO::currNode(ROIStatIO *this, uint64_t a2, int a3)
{
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  *(_DWORD *)uint64_t v17 = a3;
  *(void *)&v17[4] = 0xFFFFFFFFLL;
  uint64_t v18 = 0x3FF0000000000000;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v5 = *((void *)this + 52);
  uint64_t v6 = *((void *)this + 53);
  if (v5 != v6)
  {
    if (*(_DWORD *)(v5 + 24) == a3)
    {
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = __p.__r_.__value_.__l.__size_;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      while (1)
      {
        if ((std::string *)v5 == &__p) {
          goto LABEL_40;
        }
        uint64_t v9 = *(unsigned __int8 *)(v5 + 23);
        if ((v9 & 0x80u) == 0) {
          uint64_t v10 = *(unsigned __int8 *)(v5 + 23);
        }
        else {
          uint64_t v10 = *(void *)(v5 + 8);
        }
        if (v10 == size)
        {
          if ((v9 & 0x80) != 0)
          {
            if (!memcmp(*(const void **)v5, p_p, *(void *)(v5 + 8)))
            {
LABEL_12:
              if (*(_DWORD *)(v5 + 24) == a3) {
                goto LABEL_40;
              }
            }
          }
          else
          {
            if (!*(unsigned char *)(v5 + 23)) {
              goto LABEL_12;
            }
            uint64_t v11 = 0;
            while (*(unsigned __int8 *)(v5 + v11) == p_p->__r_.__value_.__s.__data_[v11])
            {
              if (v9 == ++v11) {
                goto LABEL_12;
              }
            }
          }
        }
        v5 += 72;
        if (v5 == v6) {
          goto LABEL_36;
        }
      }
    }
    ROIStatIO::writeList(this);
    uint64_t v12 = *((void *)this + 52);
    for (uint64_t i = *((void *)this + 53); ; i -= 72)
    {
      if (i == v12)
      {
        *((void *)this + 53) = v12;
        break;
      }
      if (*(char *)(i - 1) < 0)
      {
        operator delete(*(void **)(i - 24));
        if ((*(char *)(i - 49) & 0x80000000) == 0) {
          continue;
        }
      }
      else if ((*(char *)(i - 49) & 0x80000000) == 0)
      {
        continue;
      }
      operator delete(*(void **)(i - 72));
    }
  }
LABEL_36:
  *((void *)this + 55) = time(0);
  unint64_t v14 = *((void *)this + 53);
  if (v14 >= *((void *)this + 54))
  {
    *((void *)this + 53) = std::vector<ROIStatIO::ROITestSet>::__push_back_slow_path<ROIStatIO::ROITestSet const&>((uint64_t *)this + 52, (uint64_t)&__p);
    if (SHIBYTE(v21) < 0) {
      goto LABEL_45;
    }
LABEL_40:
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_41;
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external(*((std::string **)this + 53), __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  }
  else
  {
    long long v15 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    *(void *)(v14 + 16) = *((void *)&__p.__r_.__value_.__l + 2);
    *(_OWORD *)unint64_t v14 = v15;
  }
  *(void *)(v14 + 24) = *(void *)v17;
  *(_DWORD *)(v14 + 32) = *(_DWORD *)&v17[8];
  *(void *)(v14 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = v18;
  *(void *)(v14 + 56) = 0;
  *(void *)(v14 + 64) = 0;
  *(void *)(v14 + 48) = 0;
  *((void *)this + 53) = v14 + 72;
  *((void *)this + 53) = v14 + 72;
  if ((SHIBYTE(v21) & 0x80000000) == 0) {
    goto LABEL_40;
  }
LABEL_45:
  operator delete(v19);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
LABEL_41:
  }
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_1B77E5110(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  *(void *)(v9 + 424) = v10;
  ROIStatIO::ROITestSet::~ROITestSet(&a9);
  _Unwind_Resume(a1);
}

void sub_1B77E5128(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

void ROIStatIO::ROITestSet::~ROITestSet(void **this)
{
  if ((*((char *)this + 71) & 0x80000000) == 0)
  {
    if ((*((char *)this + 23) & 0x80000000) == 0) {
      return;
    }
LABEL_5:
    operator delete(*this);
    return;
  }
  operator delete(this[6]);
  if (*((char *)this + 23) < 0) {
    goto LABEL_5;
  }
}

void ROIStatIO::failed(uint64_t *a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v17, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string v17 = *(std::string *)a2;
  }
  unint64_t v18 = __PAIR64__(a4, a3);
  int v19 = 0;
  unint64_t v20 = 0xBFF0000000000000;
  std::string __p = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v8 = (std::string *)a1[52];
  unint64_t v7 = a1[53];
  if (v8 != (std::string *)v7)
  {
    if (LODWORD(v8[1].__r_.__value_.__l.__data_) != a3) {
      goto LABEL_38;
    }
    while (1)
    {
      while (v8 == &v17)
      {
LABEL_25:
        if (&v8[3] == (std::string *)v7)
        {
          uint64_t v15 = (uint64_t)v8;
        }
        else
        {
          unint64_t v14 = v8;
          do
          {
            std::string::operator=(v14, v14 + 3);
            v14[1].__r_.__value_.__r.__words[0] = v14[4].__r_.__value_.__r.__words[0];
            LODWORD(v14[1].__r_.__value_.__r.__words[1]) = v14[4].__r_.__value_.__r.__words[1];
            v14[1].__r_.__value_.__r.__words[2] = v14[4].__r_.__value_.__r.__words[2];
            v14 += 3;
            uint64_t v15 = (uint64_t)v14;
          }
          while (&v14[3] != (std::string *)v7);
          unint64_t v7 = a1[53];
        }
        while (v7 != v15)
        {
          if (*(char *)(v7 - 1) < 0)
          {
            operator delete(*(void **)(v7 - 24));
            if ((*(char *)(v7 - 49) & 0x80000000) == 0) {
              goto LABEL_30;
            }
          }
          else if ((*(char *)(v7 - 49) & 0x80000000) == 0)
          {
            goto LABEL_30;
          }
          operator delete(*(void **)(v7 - 72));
LABEL_30:
          v7 -= 72;
        }
        a1[53] = v15;
        unint64_t v7 = v15;
        if (v8 == (std::string *)v15)
        {
LABEL_38:
          if (v7 < a1[54]) {
            goto LABEL_39;
          }
LABEL_42:
          a1[53] = std::vector<ROIStatIO::ROITestSet>::__push_back_slow_path<ROIStatIO::ROITestSet const&>(a1 + 52, (uint64_t)&v17);
          if ((SHIBYTE(v23) & 0x80000000) == 0) {
            goto LABEL_43;
          }
LABEL_47:
          operator delete(__p);
          if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
            goto LABEL_48;
          }
          return;
        }
      }
      uint64_t v9 = HIBYTE(v8->__r_.__value_.__r.__words[2]);
      if ((v9 & 0x80u) == 0) {
        std::string::size_type size = HIBYTE(v8->__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v8->__r_.__value_.__l.__size_;
      }
      std::string::size_type v11 = HIBYTE(v17.__r_.__value_.__r.__words[2]);
      if ((v17.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type v11 = v17.__r_.__value_.__l.__size_;
      }
      if (size != v11) {
        goto LABEL_8;
      }
      uint64_t v12 = (v17.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &v17
          : (std::string *)v17.__r_.__value_.__r.__words[0];
      if ((v9 & 0x80) != 0) {
        break;
      }
      if (!*((unsigned char *)&v8->__r_.__value_.__s + 23)) {
        goto LABEL_24;
      }
      double v13 = v8;
      while (v13->__r_.__value_.__s.__data_[0] == v12->__r_.__value_.__s.__data_[0])
      {
        double v13 = (std::string *)((char *)v13 + 1);
        uint64_t v12 = (std::string *)((char *)v12 + 1);
        if (!--v9) {
          goto LABEL_24;
        }
      }
LABEL_8:
      v8 += 3;
      if (v8 == (std::string *)v7) {
        goto LABEL_38;
      }
    }
    if (memcmp(v8->__r_.__value_.__l.__data_, v12, v8->__r_.__value_.__l.__size_)) {
      goto LABEL_8;
    }
LABEL_24:
    if (LODWORD(v8[1].__r_.__value_.__l.__data_) != v18) {
      goto LABEL_8;
    }
    goto LABEL_25;
  }
  unint64_t v7 = a1[52];
  if ((unint64_t)v8 >= a1[54]) {
    goto LABEL_42;
  }
LABEL_39:
  if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)v7, v17.__r_.__value_.__l.__data_, v17.__r_.__value_.__l.__size_);
  }
  else
  {
    long long v16 = *(_OWORD *)&v17.__r_.__value_.__l.__data_;
    *(void *)(v7 + 16) = *((void *)&v17.__r_.__value_.__l + 2);
    *(_OWORD *)unint64_t v7 = v16;
  }
  *(void *)(v7 + 24) = v18;
  *(_DWORD *)(v7 + 32) = v19;
  *(void *)(v7 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = v20;
  *(void *)(v7 + 56) = 0;
  *(void *)(v7 + 64) = 0;
  *(void *)(v7 + 48) = 0;
  a1[53] = v7 + 72;
  a1[53] = v7 + 72;
  if (SHIBYTE(v23) < 0) {
    goto LABEL_47;
  }
LABEL_43:
  if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
LABEL_48:
  }
    operator delete(v17.__r_.__value_.__l.__data_);
}

void sub_1B77E543C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  *(void *)(v9 + 424) = v10;
  ROIStatIO::ROITestSet::~ROITestSet(&a9);
  _Unwind_Resume(a1);
}

void sub_1B77E5454(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

void sub_1B77E5468(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

void ROIStatIO::over(uint64_t *a1, uint64_t a2, unsigned int a3, unsigned int a4, double a5)
{
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__n, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __n = *(std::string *)a2;
  }
  unint64_t v33 = __PAIR64__(a4, a3);
  int v34 = 1;
  double v35 = a5;
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  std::string __p = 0;
  uint64_t v9 = (std::string *)a1[52];
  unint64_t v10 = a1[53];
  if (v9 == (std::string *)v10 || LODWORD(v9[1].__r_.__value_.__l.__data_) != a3)
  {
LABEL_71:
    if (v10 >= a1[54])
    {
      uint64_t v31 = std::vector<ROIStatIO::ROITestSet>::__push_back_slow_path<ROIStatIO::ROITestSet const&>(a1 + 52, (uint64_t)&__n);
    }
    else
    {
      if (SHIBYTE(__n.__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)v10, __n.__r_.__value_.__l.__data_, __n.__r_.__value_.__l.__size_);
      }
      else
      {
        long long v30 = *(_OWORD *)&__n.__r_.__value_.__l.__data_;
        *(void *)(v10 + 16) = *((void *)&__n.__r_.__value_.__l + 2);
        *(_OWORD *)unint64_t v10 = v30;
      }
      *(void *)(v10 + 24) = v33;
      *(_DWORD *)(v10 + 32) = v34;
      *(double *)(v10 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = v35;
      *(void *)(v10 + 56) = 0;
      *(void *)(v10 + 64) = 0;
      *(void *)(v10 + 48) = 0;
      uint64_t v31 = v10 + 72;
      a1[53] = v10 + 72;
    }
    a1[53] = v31;
    goto LABEL_78;
  }
  if ((__n.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__n.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __n.__r_.__value_.__l.__size_;
  }
  if ((__n.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_n = &__n;
  }
  else {
    p_n = (std::string *)__n.__r_.__value_.__r.__words[0];
  }
  double v13 = (std::string *)a1[52];
  do
  {
    if (v13 == &__n)
    {
      double v13 = &__n;
LABEL_29:
      double v17 = *(double *)&v13[1].__r_.__value_.__r.__words[2];
      if (v17 > 0.0)
      {
        ++LODWORD(v13[1].__r_.__value_.__r.__words[1]);
        *(double *)&v13[1].__r_.__value_.__r.__words[2] = v17 + a5;
      }
      goto LABEL_78;
    }
    uint64_t v14 = HIBYTE(v13->__r_.__value_.__r.__words[2]);
    if ((v14 & 0x80u) == 0) {
      std::string::size_type v15 = HIBYTE(v13->__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v15 = v13->__r_.__value_.__l.__size_;
    }
    if (v15 == size)
    {
      if ((v14 & 0x80) != 0)
      {
        if (memcmp(v13->__r_.__value_.__l.__data_, p_n, v13->__r_.__value_.__l.__size_)) {
          goto LABEL_14;
        }
      }
      else if (*((unsigned char *)&v13->__r_.__value_.__s + 23))
      {
        uint64_t v16 = 0;
        while (v13->__r_.__value_.__s.__data_[v16] == p_n->__r_.__value_.__s.__data_[v16])
        {
          if (v14 == ++v16) {
            goto LABEL_25;
          }
        }
        goto LABEL_14;
      }
LABEL_25:
      if (LODWORD(v13[1].__r_.__value_.__l.__data_) == a3 && HIDWORD(v13[1].__r_.__value_.__r.__words[0]) == a4) {
        goto LABEL_29;
      }
    }
LABEL_14:
    v13 += 3;
  }
  while (v13 != (std::string *)v10);
  size_t v18 = __n.__r_.__value_.__l.__size_;
  if ((__n.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v19 = HIBYTE(__n.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v19 = __n.__r_.__value_.__l.__size_;
  }
  if ((*((unsigned char *)&__n.__r_.__value_.__s + 23) & 0x80) != 0)
  {
    uint64_t v25 = (const void *)__n.__r_.__value_.__r.__words[0];
    while (v9 != &__n)
    {
      std::string::size_type v26 = HIBYTE(v9->__r_.__value_.__r.__words[2]);
      int v27 = (char)v26;
      if ((v26 & 0x80u) != 0) {
        std::string::size_type v26 = v9->__r_.__value_.__l.__size_;
      }
      if (v19 == v26)
      {
        std::locale v28 = v27 >= 0 ? v9 : (std::string *)v9->__r_.__value_.__r.__words[0];
        if (!memcmp(v25, v28, v18) && LODWORD(v9[1].__r_.__value_.__l.__data_) == a3)
        {
LABEL_69:
          if (HIDWORD(v9[1].__r_.__value_.__r.__words[0]) != -1) {
            goto LABEL_85;
          }
          std::string::operator=(v9, &__n);
          v9[1].__r_.__value_.__r.__words[0] = v33;
          LODWORD(v9[1].__r_.__value_.__r.__words[1]) = v34;
          *(double *)&v9[1].__r_.__value_.__r.__words[2] = v35;
          goto LABEL_78;
        }
      }
      v9 += 3;
      if (v9 == (std::string *)v10) {
        goto LABEL_71;
      }
    }
  }
  else if (*((unsigned char *)&__n.__r_.__value_.__s + 23))
  {
    while (&__n != v9)
    {
      std::string::size_type v20 = HIBYTE(v9->__r_.__value_.__r.__words[2]);
      int v21 = (char)v20;
      if ((v20 & 0x80u) != 0) {
        std::string::size_type v20 = v9->__r_.__value_.__l.__size_;
      }
      if (v19 == v20)
      {
        if (v21 >= 0) {
          uint64_t v22 = v9;
        }
        else {
          uint64_t v22 = (std::string *)v9->__r_.__value_.__r.__words[0];
        }
        uint64_t v23 = &__n;
        uint64_t v24 = HIBYTE(__n.__r_.__value_.__r.__words[2]);
        while (v23->__r_.__value_.__s.__data_[0] == v22->__r_.__value_.__s.__data_[0])
        {
          uint64_t v23 = (std::string *)((char *)v23 + 1);
          uint64_t v22 = (std::string *)((char *)v22 + 1);
          if (!--v24)
          {
            if (LODWORD(v9[1].__r_.__value_.__l.__data_) != a3) {
              break;
            }
            goto LABEL_69;
          }
        }
      }
      v9 += 3;
      if (v9 == (std::string *)v10) {
        goto LABEL_71;
      }
    }
  }
  else
  {
    while (v9 != &__n)
    {
      std::string::size_type v29 = HIBYTE(v9->__r_.__value_.__r.__words[2]);
      if ((v29 & 0x80u) != 0) {
        std::string::size_type v29 = v9->__r_.__value_.__l.__size_;
      }
      if (v19 == v29 && LODWORD(v9[1].__r_.__value_.__l.__data_) == a3) {
        goto LABEL_69;
      }
      v9 += 3;
      if (v9 == (std::string *)v10) {
        goto LABEL_71;
      }
    }
  }
  if (a4 != -1)
  {
    uint64_t v9 = &__n;
LABEL_85:
    std::vector<ROIStatIO::ROITestSet>::insert(a1 + 52, (uint64_t)v9, &__n);
  }
LABEL_78:
  if ((SHIBYTE(v38) & 0x80000000) == 0)
  {
    if ((SHIBYTE(__n.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
LABEL_82:
    operator delete(__n.__r_.__value_.__l.__data_);
    return;
  }
  operator delete(__p);
  if (SHIBYTE(__n.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_82;
  }
}

void sub_1B77E5840(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

void sub_1B77E5854(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  *(void *)(v9 + 424) = v10;
  ROIStatIO::ROITestSet::~ROITestSet(&a9);
  _Unwind_Resume(a1);
}

void sub_1B77E586C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

std::string *std::vector<ROIStatIO::ROITestSet>::insert(uint64_t *a1, uint64_t a2, std::string *__str)
{
  size_t v3 = __str;
  uint64_t v5 = *a1;
  unint64_t v6 = a1[1];
  uint64_t v7 = (a2 - *a1) / 72;
  uint64_t v8 = (std::string *)(*a1 + 72 * v7);
  unint64_t v9 = a1[2];
  if (v6 < v9)
  {
    if (v8 == (std::string *)v6)
    {
      if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)(*a1 + 72 * v7), __str->__r_.__value_.__l.__data_, __str->__r_.__value_.__l.__size_);
      }
      else
      {
        long long v22 = *(_OWORD *)&__str->__r_.__value_.__l.__data_;
        v8->__r_.__value_.__r.__words[2] = __str->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v22;
      }
      uint64_t v29 = v5 + 72 * v7;
      *(void *)(v29 + 24) = v3[1].__r_.__value_.__l.__data_;
      *(_DWORD *)(v29 + 32) = v3[1].__r_.__value_.__r.__words[1];
      *(void *)(v29 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = *((void *)&v3[1].__r_.__value_.__l + 2);
      *(void *)(v29 + 56) = 0;
      *(void *)(v29 + 64) = 0;
      *(void *)(v29 + 48) = 0;
      a1[1] = (uint64_t)&v8[3];
    }
    else
    {
      uint64_t v31 = (a2 - *a1) / 72;
      unint64_t v10 = v6 - 72;
      uint64_t v11 = a1[1];
      if (v6 >= 0x48)
      {
        uint64_t v12 = 0;
        uint64_t v13 = v5 + 8 * ((uint64_t)(v6 - (void)(v8 + 3)) >> 3) + 72 * v31;
        do
        {
          uint64_t v16 = (long long *)(v10 + v12);
          double v17 = (std::string *)(v6 + v12);
          if (*(char *)(v13 + v12 + 23) < 0)
          {
            std::string::__init_copy_ctor_external(v17, *(const std::string::value_type **)v16, *(void *)(v13 + v12 + 8));
          }
          else
          {
            long long v14 = *v16;
            v17->__r_.__value_.__r.__words[2] = *((void *)v16 + 2);
            *(_OWORD *)&v17->__r_.__value_.__l.__data_ = v14;
          }
          uint64_t v15 = v6 + v12;
          *(void *)(v15 + 24) = *(void *)(v13 + v12 + 24);
          *(_DWORD *)(v15 + 32) = *(_DWORD *)(v13 + v12 + 32);
          *(void *)(v15 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = *(void *)(v13 + v12 + 40);
          *(void *)(v15 + 56) = 0;
          *(void *)(v15 + 64) = 0;
          *(void *)(v15 + 48) = 0;
          v12 += 72;
        }
        while (v10 + v12 < v6);
        uint64_t v11 = v6 + v12;
      }
      a1[1] = v11;
      if ((std::string *)v6 != &v8[3])
      {
        uint64_t v25 = 0;
        uint64_t v26 = v5 + 8 * ((uint64_t)(v6 - (void)(v8 + 3)) >> 3) + 72 * v31;
        do
        {
          if (v26 != v6)
          {
            uint64_t v27 = v6 + v25;
            std::string::operator=((std::string *)(v6 + v25 - 72), (const std::string *)(v26 + v25 - 72));
            *(void *)(v27 - 48) = *(void *)(v26 + v25 - 48);
            *(_DWORD *)(v27 - 4CVOpenGLESTextureCacheFlush(this[3], 0) = *(_DWORD *)(v26 + v25 - 40);
            *(void *)(v27 - 32) = *(void *)(v26 + v25 - 32);
          }
          v25 -= 72;
        }
        while (-8 * ((uint64_t)(v6 - (void)(v8 + 3)) >> 3) != v25);
      }
      if (v8 <= v3) {
        v3 += 3 * (a1[1] > (unint64_t)v3);
      }
      if (v8 != v3)
      {
        std::string::operator=(v8, v3);
        uint64_t v28 = v5 + 72 * v31;
        *(void *)(v28 + 24) = v3[1].__r_.__value_.__l.__data_;
        *(_DWORD *)(v28 + 32) = v3[1].__r_.__value_.__r.__words[1];
        *(void *)(v28 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = *((void *)&v3[1].__r_.__value_.__l + 2);
      }
    }
    return v8;
  }
  unint64_t v18 = 0x8E38E38E38E38E39 * ((uint64_t)(v6 - v5) >> 3) + 1;
  if (v18 > 0x38E38E38E38E38ELL) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  unint64_t v19 = 0x8E38E38E38E38E39 * ((uint64_t)(v9 - v5) >> 3);
  if (2 * v19 > v18) {
    unint64_t v18 = 2 * v19;
  }
  if (v19 >= 0x1C71C71C71C71C7) {
    unint64_t v20 = 0x38E38E38E38E38ELL;
  }
  else {
    unint64_t v20 = v18;
  }
  int v36 = a1 + 2;
  if (v20)
  {
    if (v20 > 0x38E38E38E38E38ELL) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    int v21 = (char *)operator new(72 * v20);
  }
  else
  {
    int v21 = 0;
  }
  std::string __p = v21;
  unint64_t v33 = &v21[72 * v7];
  int v34 = v33;
  double v35 = &v21[72 * v20];
  std::__split_buffer<ROIStatIO::ROITestSet>::push_back[abi:ne180100]((uint64_t)&__p, (long long *)v3);
  uint64_t v8 = (std::string *)std::vector<ROIStatIO::ROITestSet>::__swap_out_circular_buffer(a1, &__p, (uint64_t)v8);
  uint64_t v23 = v33;
  while (1)
  {
    uint64_t v24 = v34;
    if (v34 == v23) {
      break;
    }
    v34 -= 72;
    if (*(v24 - 1) < 0)
    {
      operator delete(*((void **)v24 - 3));
      if (*(v24 - 49) < 0) {
        goto LABEL_27;
      }
    }
    else if (*(v24 - 49) < 0)
    {
LABEL_27:
      operator delete(*((void **)v24 - 9));
    }
  }
  if (__p) {
    operator delete(__p);
  }
  return v8;
}

void sub_1B77E5C20(_Unwind_Exception *a1)
{
  *(void *)(v2 + 8) = v1;
  _Unwind_Resume(a1);
}

void sub_1B77E5C28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<ROIStatIO::ROITestSet>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B77E5C3C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2 + v3;
  _Unwind_Resume(a1);
}

void HGSampleRectStat::HGSampleRectStat(HGSampleRectStat *this, HGRect a2, HGRect a3, const HGNode *lpsrc, int a5)
{
  ActiveShaderNode = lpsrc;
  uint64_t v7 = *(void *)&a3.var2;
  uint64_t v8 = *(void *)&a3.var0;
  uint64_t v9 = *(void *)&a2.var2;
  uint64_t v10 = *(void *)&a2.var0;
  unint64_t v12 = *(void *)(*(void *)(*(void *)lpsrc - 8) + 8);
  if ((char *)v12 == off_1F10C57C8
    || (((unint64_t)off_1F10C57C8 & v12 & 0x8000000000000000) != 0) != __OFSUB__(v12, off_1F10C57C8)
    && !strcmp((const char *)(v12 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)off_1F10C57C8 & 0x7FFFFFFFFFFFFFFFLL)))
  {
    if (!v13) {
      __cxa_bad_cast();
    }
    ActiveShaderNode = (const HGNode *)HGRasterizer::getActiveShaderNode(v13);
  }
  *(void *)this = ActiveShaderNode;
  *((void *)this + 1) = v10;
  *((void *)this + 2) = v9;
  *((void *)this + 3) = v8;
  *((void *)this + 4) = v7;
  *((_DWORD *)this + 1CVOpenGLESTextureCacheFlush(this[3], 0) = a5;
  *(_OWORD *)((char *)this + 44) = xmmword_1B83472C0;
  *((_WORD *)this + 3CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
}

void HGSampleRectStat::~HGSampleRectStat(HGSampleRectStat *this)
{
}

void HGSampleRectStat::analyzeFull(HGSampleRectStat *this)
{
  uint64_t v2 = (const char *)(*(uint64_t (**)(void))(**(void **)this + 48))(*(void *)this);
  size_t v3 = strlen(v2);
  if (v3 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v4 = v3;
  if (v3 >= 0x17)
  {
    uint64_t v6 = (v3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v3 | 7) != 0x17) {
      uint64_t v6 = v3 | 7;
    }
    uint64_t v7 = v6 + 1;
    p_dst = (const void **)operator new(v6 + 1);
    size_t __n = v4;
    int64_t v20 = v7 | 0x8000000000000000;
    std::string __dst = p_dst;
    goto LABEL_8;
  }
  HIBYTE(v2CVOpenGLESTextureCacheFlush(this[3], 0) = v3;
  p_dst = (const void **)&__dst;
  if (v3) {
LABEL_8:
  }
    size_t v3 = (size_t)memmove(p_dst, v2, v4);
  *((unsigned char *)p_dst + v4) = 0;
  v17[23] = 8;
  strcpy(v17, "LiHeEdge");
  char v8 = HIBYTE(v20);
  if (v20 >= 0) {
    size_t v9 = HIBYTE(v20);
  }
  else {
    size_t v9 = __n;
  }
  if (v9 != 8) {
    goto LABEL_20;
  }
  if ((v20 & 0x8000000000000000) == 0)
  {
    if (!HIBYTE(v20)) {
      goto LABEL_34;
    }
    uint64_t v10 = (const void **)&__dst;
    uint64_t v11 = v17;
    uint64_t v12 = HIBYTE(v20);
    while (*(unsigned __int8 *)v10 == *v11)
    {
      uint64_t v10 = (const void **)((char *)v10 + 1);
      ++v11;
      if (!--v12) {
        goto LABEL_34;
      }
    }
LABEL_20:
    uint64_t v13 = (ROIStatIO *)ROIStatIO::open((ROIStatIO *)v3);
    if (!MotionROIFrame::_pThis) {
      operator new();
    }
    ROIStatIO::currNode(v13, (uint64_t)&__dst, *(_DWORD *)MotionROIFrame::_pThis);
    int v14 = *((_DWORD *)this + 11);
    if (v14 != 999999)
    {
      if (*((unsigned char *)this + 60))
      {
        if (!MotionROIFrame::_pThis) {
          operator new();
        }
        ROIStatIO::failed((uint64_t *)v13, (uint64_t)&__dst, *(_DWORD *)MotionROIFrame::_pThis, *((_DWORD *)this + 10));
      }
      else
      {
        float v15 = (float)((float)((float)(*((_DWORD *)this + 8) - *((_DWORD *)this + 6))
                            / (float)(*((_DWORD *)this + 13) - v14))
                    * (float)(*((_DWORD *)this + 9) - *((_DWORD *)this + 7)))
            / (float)(*((_DWORD *)this + 14) - *((_DWORD *)this + 12));
        if (v15 > 1.0)
        {
          if (!MotionROIFrame::_pThis) {
            operator new();
          }
          ROIStatIO::over((uint64_t *)v13, (uint64_t)&__dst, *(_DWORD *)MotionROIFrame::_pThis, *((_DWORD *)this + 10), v15);
        }
      }
    }
    if (!std::filebuf::close()) {
      std::ios_base::clear((std::ios_base *)((char *)v13 + *(void *)(*(void *)v13 - 24)), *(_DWORD *)((char *)v13 + *(void *)(*(void *)v13 - 24) + 32) | 4);
    }
LABEL_34:
    if ((v8 & 0x80) == 0) {
      return;
    }
    goto LABEL_35;
  }
  size_t v3 = memcmp(__dst, v17, __n);
  if (v3) {
    goto LABEL_20;
  }
LABEL_35:
  uint64_t v16 = __dst;

  operator delete(v16);
}

void sub_1B77E6098(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p)
{
  if (v12 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::ofstream::~ofstream(void *a1)
{
  *a1 = MEMORY[0x1E4FBA468] + 24;
  uint64_t v2 = a1 + 52;
  a1[52] = MEMORY[0x1E4FBA468] + 64;
  MEMORY[0x1BA9BF710](a1 + 1);
  std::ostream::~ostream();
  MEMORY[0x1BA9BFAB0](v2);
  return a1;
}

void std::ofstream::~ofstream(void *a1)
{
  *a1 = MEMORY[0x1E4FBA468] + 24;
  uint64_t v1 = a1 + 52;
  a1[52] = MEMORY[0x1E4FBA468] + 64;
  MEMORY[0x1BA9BF710](a1 + 1);
  std::ostream::~ostream();
  MEMORY[0x1BA9BFAB0](v1);

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'std::ofstream::~ofstream(void *a1)
{
  uint64_t v1 = (void *)((char *)a1 + *(void *)(*a1 - 24));
  void *v1 = MEMORY[0x1E4FBA468] + 24;
  v1[52] = MEMORY[0x1E4FBA468] + 64;
  MEMORY[0x1BA9BF710](v1 + 1);
  std::ostream::~ostream();

  JUMPOUT(0x1BA9BFAB0);
}

{
  void *v1;
  uint64_t vars8;

  uint64_t v1 = (void *)((char *)a1 + *(void *)(*a1 - 24));
  void *v1 = MEMORY[0x1E4FBA468] + 24;
  v1[52] = MEMORY[0x1E4FBA468] + 64;
  MEMORY[0x1BA9BF710](v1 + 1);
  std::ostream::~ostream();
  MEMORY[0x1BA9BFAB0](v1 + 52);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t *std::ofstream::basic_ofstream(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *a1 = *a2;
  *(uint64_t *)((char *)a1 + *(void *)(v4 - 24)) = a2[3];
  uint64_t v5 = a2[1];
  *a1 = v5;
  *(uint64_t *)((char *)a1 + *(void *)(v5 - 24)) = a2[2];
  uint64_t v6 = (std::ios_base *)((char *)a1 + *(void *)(*a1 - 24));
  std::ios_base::init(v6, a1 + 1);
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  uint64_t v7 = *a2;
  *a1 = *a2;
  *(uint64_t *)((char *)a1 + *(void *)(v7 - 24)) = a2[3];
  MEMORY[0x1BA9BF700](a1 + 1);
  if (!std::filebuf::open()) {
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 4);
  }
  return a1;
}

void sub_1B77E6570(_Unwind_Exception *a1)
{
}

uint64_t std::vector<ROIStatIO::ROITestSet>::__push_back_slow_path<ROIStatIO::ROITestSet const&>(uint64_t *a1, uint64_t a2)
{
  unint64_t v3 = 0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x38E38E38E38E38ELL) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  if (0x1C71C71C71C71C72 * ((a1[2] - *a1) >> 3) > v4) {
    unint64_t v4 = 0x1C71C71C71C71C72 * ((a1[2] - *a1) >> 3);
  }
  if (0x8E38E38E38E38E39 * ((a1[2] - *a1) >> 3) >= 0x1C71C71C71C71C7) {
    unint64_t v6 = 0x38E38E38E38E38ELL;
  }
  else {
    unint64_t v6 = v4;
  }
  unint64_t v18 = a1 + 2;
  if (v6)
  {
    if (v6 > 0x38E38E38E38E38ELL) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v7 = (char *)operator new(72 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  char v8 = (std::string *)&v7[72 * v3];
  std::string __p = v7;
  float v15 = v8;
  uint64_t v16 = v8;
  double v17 = &v7[72 * v6];
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
    char v8 = v16;
  }
  else
  {
    *(_OWORD *)&v8->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    v8->__r_.__value_.__r.__words[2] = *(void *)(a2 + 16);
  }
  size_t v9 = &v7[72 * v3];
  *((void *)v9 + 3) = *(void *)(a2 + 24);
  *((_DWORD *)v9 + 8) = *(_DWORD *)(a2 + 32);
  *((void *)v9 + 5) = *(void *)(a2 + 40);
  *((void *)v9 + 7) = 0;
  *((void *)v9 + 8) = 0;
  *((void *)v9 + 6) = 0;
  uint64_t v16 = v8 + 3;
  std::vector<ROIStatIO::ROITestSet>::__swap_out_circular_buffer(a1, &__p);
  uint64_t v10 = a1[1];
  uint64_t v11 = v15;
  while (1)
  {
    char v12 = v16;
    if (v16 == v11) {
      break;
    }
    v16 -= 3;
    if (SHIBYTE(v12[-1].__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v12[-1].__r_.__value_.__l.__data_);
      if (SHIBYTE(v12[-3].__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_20;
      }
    }
    else if (SHIBYTE(v12[-3].__r_.__value_.__r.__words[2]) < 0)
    {
LABEL_20:
      operator delete(v12[-3].__r_.__value_.__l.__data_);
    }
  }
  if (__p) {
    operator delete(__p);
  }
  return v10;
}

void sub_1B77E6760(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<ROIStatIO::ROITestSet>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<ROIStatIO::ROITestSet>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v6 = a2[1];
  if (v4 != *a1)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v10 = (std::string *)(v6 + v7 - 72);
      uint64_t v11 = (const std::string::value_type **)(v4 + v7 - 72);
      if (*(char *)(v4 + v7 - 49) < 0)
      {
        std::string::__init_copy_ctor_external(v10, *v11, *(void *)(v4 + v7 - 64));
      }
      else
      {
        long long v8 = *(_OWORD *)v11;
        *(void *)(v6 + v7 - 56) = *(void *)(v4 + v7 - 56);
        *(_OWORD *)&v10->__r_.__value_.__l.__data_ = v8;
      }
      uint64_t v9 = v6 + v7;
      *(void *)(v9 - 48) = *(void *)(v4 + v7 - 48);
      *(_DWORD *)(v9 - 4CVOpenGLESTextureCacheFlush(this[3], 0) = *(_DWORD *)(v4 + v7 - 40);
      *(void *)(v9 - 32) = *(void *)(v4 + v7 - 32);
      *(void *)(v9 - 16) = 0;
      *(void *)(v9 - 8) = 0;
      *(void *)(v9 - 24) = 0;
      v7 -= 72;
    }
    while (v4 + v7 != v5);
    v6 += v7;
  }
  a2[1] = v6;
  uint64_t v12 = *a1;
  *a1 = v6;
  a2[1] = v12;
  uint64_t v13 = a1[1];
  a1[1] = a2[2];
  a2[2] = v13;
  uint64_t v14 = a1[2];
  a1[2] = a2[3];
  a2[3] = v14;
  *a2 = a2[1];
}

void sub_1B77E686C(_Unwind_Exception *exception_object)
{
  if (v2) {
    std::vector<ROIStatIO::ROITestSet>::__swap_out_circular_buffer(v1 + v2, v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<ROIStatIO::ROITestSet>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 72;
    if (*(char *)(i - 1) < 0)
    {
      operator delete(*(void **)(i - 24));
      if ((*(char *)(i - 49) & 0x80000000) == 0) {
        continue;
      }
    }
    else if ((*(char *)(i - 49) & 0x80000000) == 0)
    {
      continue;
    }
    operator delete(*(void **)(i - 72));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

double std::__split_buffer<ROIStatIO::ROITestSet>::push_back[abi:ne180100](uint64_t a1, long long *a2)
{
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 != *(void *)(a1 + 24)) {
    goto LABEL_24;
  }
  uint64_t v6 = *(void **)a1;
  unint64_t v5 = *(void *)(a1 + 8);
  if (v5 > *(void *)a1)
  {
    int64_t v7 = 0x8E38E38E38E38E39 * ((uint64_t)(v5 - *(void *)a1) >> 3);
    if (v7 >= -1) {
      uint64_t v8 = v7 + 1;
    }
    else {
      uint64_t v8 = v7 + 2;
    }
    uint64_t v9 = v8 >> 1;
    uint64_t v10 = -v9;
    if (v5 == v4)
    {
      unint64_t v28 = v5 - 72 * v9;
    }
    else
    {
      uint64_t v11 = -72 * v9;
      do
      {
        if (v11)
        {
          unint64_t v12 = v5 + v11;
          std::string::operator=((std::string *)(v5 + v11), (const std::string *)v5);
          *(void *)(v12 + 24) = *(void *)(v5 + 24);
          *(_DWORD *)(v12 + 32) = *(_DWORD *)(v5 + 32);
          *(void *)(v12 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = *(void *)(v5 + 40);
        }
        v5 += 72;
      }
      while (v5 != v4);
      unint64_t v4 = *(void *)(a1 + 8);
      unint64_t v28 = v5 + 72 * v10;
    }
    *(void *)(a1 + 8) = v4 + 72 * v10;
    *(void *)(a1 + 16) = v28;
    unint64_t v4 = v28;
LABEL_24:
    if (*((char *)a2 + 23) < 0) {
      goto LABEL_38;
    }
    goto LABEL_25;
  }
  unint64_t v13 = 0x1C71C71C71C71C72 * ((uint64_t)(v4 - (void)v6) >> 3);
  if ((void *)v4 == v6) {
    unint64_t v13 = 1;
  }
  if (v13 >= 0x38E38E38E38E38FLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  unint64_t v14 = v13 >> 2;
  uint64_t v15 = 72 * v13;
  uint64_t v16 = (char *)operator new(72 * v13);
  double v17 = &v16[72 * v14];
  unint64_t v18 = &v16[v15];
  uint64_t v19 = v4 - v5;
  if (v4 == v5)
  {
    unint64_t v29 = v4;
    long long v22 = v17;
  }
  else
  {
    uint64_t v20 = 0;
    uint64_t v21 = v19 / 72;
    long long v22 = &v17[72 * v21];
    uint64_t v23 = 72 * v21;
    do
    {
      uint64_t v26 = (std::string *)&v17[v20];
      uint64_t v27 = (long long *)(v5 + v20);
      if (*(char *)(v5 + v20 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v26, *(const std::string::value_type **)v27, *((void *)v27 + 1));
      }
      else
      {
        long long v24 = *v27;
        v26->__r_.__value_.__r.__words[2] = *((void *)v27 + 2);
        *(_OWORD *)&v26->__r_.__value_.__l.__data_ = v24;
      }
      uint64_t v25 = &v17[v20];
      *((void *)v25 + 3) = *(void *)(v5 + v20 + 24);
      *((_DWORD *)v25 + 8) = *(_DWORD *)(v5 + v20 + 32);
      *((void *)v25 + 5) = *(void *)(v5 + v20 + 40);
      *((void *)v25 + 7) = 0;
      *((void *)v25 + 8) = 0;
      *((void *)v25 + 6) = 0;
      v20 += 72;
    }
    while (v23 != v20);
    uint64_t v6 = *(void **)a1;
    unint64_t v29 = *(void *)(a1 + 8);
    unint64_t v4 = *(void *)(a1 + 16);
  }
  *(void *)a1 = v16;
  *(void *)(a1 + 8) = v17;
  *(void *)(a1 + 16) = v22;
  *(void *)(a1 + 24) = v18;
  while (v4 != v29)
  {
    if (*(char *)(v4 - 1) < 0)
    {
      operator delete(*(void **)(v4 - 24));
      if ((*(char *)(v4 - 49) & 0x80000000) == 0) {
        goto LABEL_28;
      }
    }
    else if ((*(char *)(v4 - 49) & 0x80000000) == 0)
    {
      goto LABEL_28;
    }
    operator delete(*(void **)(v4 - 72));
LABEL_28:
    v4 -= 72;
  }
  if (v6) {
    operator delete(v6);
  }
  unint64_t v4 = *(void *)(a1 + 16);
  if (*((char *)a2 + 23) < 0)
  {
LABEL_38:
    std::string::__init_copy_ctor_external((std::string *)v4, *(const std::string::value_type **)a2, *((void *)a2 + 1));
    goto LABEL_39;
  }
LABEL_25:
  long long v30 = *a2;
  *(void *)(v4 + 16) = *((void *)a2 + 2);
  *(_OWORD *)unint64_t v4 = v30;
LABEL_39:
  *(void *)(v4 + 24) = *((void *)a2 + 3);
  *(_DWORD *)(v4 + 32) = *((_DWORD *)a2 + 8);
  double result = *((double *)a2 + 5);
  *(double *)(v4 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = result;
  *(void *)(v4 + 56) = 0;
  *(void *)(v4 + 64) = 0;
  *(void *)(v4 + 48) = 0;
  *(void *)(a1 + 16) += 72;
  return result;
}

void sub_1B77E6BE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  a12 = v13 + v12;
  std::__split_buffer<ROIStatIO::ROITestSet>::~__split_buffer((uint64_t)&a10);
  _Unwind_Resume(a1);
}

uint64_t std::vector<ROIStatIO::ROITestSet>::__swap_out_circular_buffer(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v6 = a2[1];
  uint64_t v7 = *a1;
  uint64_t v8 = v6;
  if (*a1 != a3)
  {
    uint64_t v9 = 0;
    do
    {
      uint64_t v12 = (std::string *)(v6 + v9 - 72);
      uint64_t v13 = (const std::string::value_type **)(a3 + v9 - 72);
      if (*(char *)(a3 + v9 - 49) < 0)
      {
        std::string::__init_copy_ctor_external(v12, *v13, *(void *)(a3 + v9 - 64));
      }
      else
      {
        long long v10 = *(_OWORD *)v13;
        *(void *)(v6 + v9 - 56) = *(void *)(a3 + v9 - 56);
        *(_OWORD *)&v12->__r_.__value_.__l.__data_ = v10;
      }
      uint64_t v11 = v6 + v9;
      *(void *)(v11 - 48) = *(void *)(a3 + v9 - 48);
      *(_DWORD *)(v11 - 4CVOpenGLESTextureCacheFlush(this[3], 0) = *(_DWORD *)(a3 + v9 - 40);
      *(void *)(v11 - 32) = *(void *)(a3 + v9 - 32);
      *(void *)(v11 - 16) = 0;
      *(void *)(v11 - 8) = 0;
      *(void *)(v11 - 24) = 0;
      v9 -= 72;
    }
    while (a3 + v9 != v7);
    uint64_t v8 = v6 + v9;
  }
  a2[1] = v8;
  uint64_t v14 = a1[1];
  uint64_t v15 = a2[2];
  if (v14 != a3)
  {
    uint64_t v16 = 0;
    do
    {
      uint64_t v19 = (std::string *)(v15 + v16);
      uint64_t v20 = (long long *)(a3 + v16);
      if (*(char *)(a3 + v16 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v19, *(const std::string::value_type **)v20, *((void *)v20 + 1));
      }
      else
      {
        long long v17 = *v20;
        v19->__r_.__value_.__r.__words[2] = *((void *)v20 + 2);
        *(_OWORD *)&v19->__r_.__value_.__l.__data_ = v17;
      }
      uint64_t v18 = v15 + v16;
      *(void *)(v18 + 24) = *(void *)(a3 + v16 + 24);
      *(_DWORD *)(v18 + 32) = *(_DWORD *)(a3 + v16 + 32);
      *(void *)(v18 + 4CVOpenGLESTextureCacheFlush(this[3], 0) = *(void *)(a3 + v16 + 40);
      *(void *)(v18 + 56) = 0;
      *(void *)(v18 + 64) = 0;
      *(void *)(v18 + 48) = 0;
      v16 += 72;
    }
    while (a3 + v16 != v14);
    uint64_t v8 = a2[1];
    v15 += v16;
  }
  a2[2] = v15;
  uint64_t v21 = *a1;
  *a1 = v8;
  a2[1] = v21;
  uint64_t v22 = a1[1];
  a1[1] = a2[2];
  a2[2] = v22;
  uint64_t v23 = a1[2];
  a1[2] = a2[3];
  a2[3] = v23;
  *a2 = a2[1];
  return v6;
}

void sub_1B77E6D98(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    std::vector<ROIStatIO::ROITestSet>::__swap_out_circular_buffer(v1 + v2, v1);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<ROIStatIO::ROITestSet>::__swap_out_circular_buffer(uint64_t a1, uint64_t a2)
{
  do
  {
    if (*(char *)(a1 + 71) < 0) {
      operator delete(*(void **)(a1 + 48));
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    a1 += 72;
  }
  while (a1 != a2);
}

{
  do
  {
    if (*(char *)(a1 - 1) < 0) {
      operator delete(*(void **)(a1 - 24));
    }
    if (*(char *)(a1 - 49) < 0) {
      operator delete(*(void **)(a1 - 72));
    }
    a1 -= 72;
  }
  while (a1 != a2);
}

void HGAnisotropicSampler::~HGAnisotropicSampler(HGNode *this)
{
  *(void *)this = &unk_1F10DA3A8;
  uint64_t v2 = (void *)*((void *)this + 63);
  if (v2) {
    free(v2);
  }

  HGNode::~HGNode(this);
}

{
  void *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10DA3A8;
  uint64_t v2 = (void *)*((void *)this + 63);
  if (v2) {
    free(v2);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v3);
}

uint64_t HGAnisotropicSampler::Init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, uint64_t a7, uint64_t a8)
{
  int v16 = a6 - a5 + 1;
  if (*(_DWORD *)(a1 + 500) <= a6 - a5) {
    *(void *)(a1 + 504) = malloc_type_realloc(*(void **)(a1 + 504), 32 * v16, 0x1000040E0EAB150uLL);
  }
  *(void *)(a1 + 48CVOpenGLESTextureCacheFlush(this[3], 0) = a3;
  *(void *)(a1 + 488) = a4;
  *(_DWORD *)(a1 + 496) = a5;
  *(_DWORD *)(a1 + 50CVOpenGLESTextureCacheFlush(this[3], 0) = v16;
  unsigned int v17 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 128))(a2, 27);
  if (a6 >= a5)
  {
    unsigned int v19 = v17;
    uint64_t v34 = a3;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    unsigned int v35 = HIDWORD(a8) - HIDWORD(a7);
    unsigned int v36 = a8 - a7;
    int v33 = a6 + 1;
    int v22 = ~a6 + a5;
    while (1)
    {
      int v18 = a5 + v21;
      uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a4 + 584))(a4, a2, (a5 + v21));
      if (!v23) {
        break;
      }
      uint64_t v24 = v23;
      (*(void (**)(void *__return_ptr, uint64_t, void, void))(*(void *)a4 + 600))(v37, a4, (a5 + v21), 0);
      uint64_t MatrixPtr = HGTransform::GetMatrixPtr((HGTransform *)v37);
      *(float *)&unsigned int v26 = *(double *)MatrixPtr;
      *(float *)&unsigned int v27 = *(double *)(MatrixPtr + 40);
      *(_OWORD *)(*(void *)(a1 + 504) + v2CVOpenGLESTextureCacheFlush(this[3], 0) = __PAIR64__(v27, v26);
      float64x2_t v28 = *(float64x2_t *)(MatrixPtr + 96);
      *(float32x2_t *)&v28.f64[0] = vcvt_f32_f64(v28);
      *(float64x2_t *)(*(void *)(a1 + 504) + v20 + 16) = v28;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 120))(a1, v21, v24);
      if (v35 >> v18 > v19 || v36 >> v18 > v19) {
        uint64_t v30 = 25;
      }
      else {
        uint64_t v30 = 17;
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 136))(a1, v21, v30);
      HGTransform::~HGTransform((HGTransform *)v37);
      uint64_t v21 = (v21 + 1);
      v20 += 32;
      if (!(v22 + v21))
      {
        a3 = v34;
        int v18 = v33;
        goto LABEL_16;
      }
    }
    a3 = v34;
  }
  else
  {
    int v18 = a5;
  }
LABEL_16:
  *(_DWORD *)(a1 + 50CVOpenGLESTextureCacheFlush(this[3], 0) = v18 - a5;
  uint64_t v31 = (float64x2_t *)(*(uint64_t (**)(void))(**(void **)(a3 + 448) + 272))(*(void *)(a3 + 448));
  *(float32x4_t *)(a1 + 416) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*v31), v31[1]);
  *(float32x4_t *)(a1 + 432) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v31[2]), v31[3]);
  *(float32x4_t *)(a1 + 448) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v31[4]), v31[5]);
  *(float32x4_t *)(a1 + 464) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v31[6]), v31[7]);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 136))(a1, 0xFFFFFFFFLL, 32);
  return (v18 - 1);
}

void sub_1B77E7250(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  HGTransform::~HGTransform((HGTransform *)va);
  _Unwind_Resume(a1);
}

HGAnisotropicSampler *HGAnisotropicSampler::GetOutput(HGAnisotropicSampler *this, HGRenderer *a2)
{
  *((unsigned char *)this + 512) = (*(unsigned int (**)(HGAnisotropicSampler *, HGRenderer *))(*(void *)this + 312))(this, a2) == 0;
  return this;
}

uint64_t HGAnisotropicSampler::GetDOD(HGAnisotropicSampler *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (*((_DWORD *)this + 125) <= a3) {
    return 0;
  }
  uint64_t v4 = *(void *)&a4.var2;
  uint64_t v5 = *(void *)&a4.var0;
  uint64_t v9 = *(void *)(*((void *)this + 61) + 740);
  uint64_t v10 = *(void *)(*((void *)this + 61) + 748);
  if ((*(int (**)(HGAnisotropicSampler *))(*(void *)this + 312))(this) >= 1)
  {
    uint64_t v11 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    uint64_t v5 = HGRectGrow(v5, v4, v11);
    uint64_t v4 = v12;
    uint64_t v13 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    uint64_t v9 = HGRectGrow(v9, v10, v13);
    uint64_t v10 = v14;
  }
  uint64_t v15 = *((void *)this + 61);
  uint64_t v16 = (*((_DWORD *)this + 124) + a3);
  uint64_t v17 = (*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2);
  uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, void, uint64_t))(*(void *)v15 + 592))(v15, v16, v5, v4, 0, 0, v17);
  uint64_t v20 = HGRectIntersection(v18, v19, v9, v10);
  uint64_t v22 = v21;
  *(void *)&v29.int var0 = v20;
  *(void *)&v29.int var2 = v22;
  uint64_t v24 = hg_dod(*(HGTransform **)(*((void *)this + 60) + 456), v29, 0.0, v23);
  uint64_t v26 = v25;
  if (*(int *)(*((void *)this + 60) + 436) > 1)
  {
    uint64_t v27 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    return HGRectGrow(v24, v26, v27);
  }
  return v24;
}

uint64_t hg_dod(HGTransform *a1, HGRect a2, double a3, float a4)
{
  float v4 = *(float *)&a3;
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  float v49 = (float)a2.var0 - *(float *)&a3;
  float v50 = (float)a2.var1 - *(float *)&a3;
  uint64_t v51 = 0x3F80000000000000;
  float v52 = (float)a2.var2 + *(float *)&a3;
  float v53 = v50;
  uint64_t v54 = 0x3F80000000000000;
  float v55 = v52;
  float v56 = (float)a2.var3 + *(float *)&a3;
  uint64_t v57 = 0x3F80000000000000;
  float v58 = v49;
  float v59 = v56;
  uint64_t v60 = 0x3F80000000000000;
  (*(void (**)(HGTransform *, unsigned char *, float *, uint64_t))(*(void *)a1 + 208))(a1, v44, &v49, 4);
  v6.n128_u32[0] = 897988541;
  v7.n128_f32[0] = v47;
  v8.n128_f32[0] = v48;
  unsigned int v9 = (v45 < 0.000001) | (2 * (v46 < 0.000001)) | (4 * (v47 < 0.000001)) | (8 * (v48 < 0.000001));
  if (v9 == 15) {
    return 0;
  }
  uint64_t v11 = (*(uint64_t (**)(HGTransform *, __n128, __n128, __n128))(*(void *)a1 + 272))(a1, v6, v7, v8);
  uint64_t v12 = 0;
  v13.f64[0] = *(float64_t *)(v11 + 24);
  double v14 = *(double *)(v11 + 120) + -0.000000999999997;
  double v42 = *(double *)(v11 + 56);
  double v43 = v13.f64[0];
  float v15 = INFINITY;
  float v16 = -INFINITY;
  v13.f64[1] = v42;
  float64x2_t v41 = v13;
  float v17 = -INFINITY;
  float v18 = INFINITY;
  do
  {
    if (((v9 >> v12) & 1) == 0)
    {
      uint64_t v22 = (float *)&v44[16 * v12];
      float v25 = v22[3];
      float v26 = *v22 / v25;
      float v27 = v22[1] / v25;
      *uint64_t v22 = v26;
      v22[1] = v27;
      float v18 = fminf(v18, v26);
      float v17 = fmaxf(v17, v26);
      float v15 = fminf(v15, v27);
      float v16 = fmaxf(v16, v27);
      uint64_t v24 = v12 + 1;
      goto LABEL_7;
    }
    uint64_t v24 = v12 + 1;
    if ((v9 >> ((v12 + 1) & 3)))
    {
      uint64_t v22 = (float *)(((_BYTE)v12 - 1) & 3);
      if ((v9 >> (char)v22)) {
        goto LABEL_7;
      }
LABEL_18:
      float32x2_t v36 = *(float32x2_t *)(&v49 + 4 * v12);
      float64x2_t v37 = vcvtq_f64_f32(v36);
      float32x2_t v38 = *(float32x2_t *)(&v49 + 4 * v22);
      double v39 = v14 + v43 * v37.f64[0] + vmuld_lane_f64(v42, v37, 1);
      double v40 = vaddvq_f64(vmulq_f64(v41, vsubq_f64(v37, vcvtq_f64_f32(v38))));
      if (v40 == 0.0)
      {
        BOOL v19 = v39 < 0.0;
        double v20 = INFINITY;
        if (v19) {
          double v20 = -INFINITY;
        }
      }
      else
      {
        double v20 = v39 / v40;
      }
      uint64_t v21 = (float32x2_t *)&v44[16 * v12];
      float32x2_t *v21 = vcvt_f32_f64(vaddq_f64(vmulq_n_f64(vcvtq_f64_f32(vsub_f32(v38, v36)), v20), v37));
      v21[1] = (float32x2_t)0x3F80000000000000;
      (*(void (**)(HGTransform *, float32x2_t *, float32x2_t *, uint64_t))(*(void *)a1 + 208))(a1, v21, v21, 1);
      v21[1].i32[1] = 897988541;
      float32x2_t v23 = vdiv_f32(*v21, (float32x2_t)vdup_n_s32(0x358637BDu));
      float32x2_t *v21 = v23;
      float v18 = fminf(v18, v23.f32[0]);
      float v17 = fmaxf(v17, v23.f32[0]);
      float v15 = fminf(v15, v23.f32[1]);
      float v16 = fmaxf(v16, v23.f32[1]);
      goto LABEL_7;
    }
    float32x2_t v28 = *(float32x2_t *)(&v49 + 4 * v12);
    float64x2_t v29 = vcvtq_f64_f32(v28);
    float32x2_t v30 = *(float32x2_t *)(&v49 + 4 * (v24 & 3));
    double v31 = v14 + v43 * v29.f64[0] + vmuld_lane_f64(v42, v29, 1);
    double v32 = vaddvq_f64(vmulq_f64(v41, vsubq_f64(v29, vcvtq_f64_f32(v30))));
    if (v32 == 0.0)
    {
      BOOL v19 = v31 < 0.0;
      double v33 = INFINITY;
      if (v19) {
        double v33 = -INFINITY;
      }
    }
    else
    {
      double v33 = v31 / v32;
    }
    uint64_t v34 = (float32x2_t *)&v44[16 * v12];
    *uint64_t v34 = vcvt_f32_f64(vaddq_f64(vmulq_n_f64(vcvtq_f64_f32(vsub_f32(v30, v28)), v33), v29));
    v34[1] = (float32x2_t)0x3F80000000000000;
    (*(void (**)(HGTransform *, float32x2_t *, float32x2_t *, uint64_t))(*(void *)a1 + 208))(a1, v34, v34, 1);
    v34[1].i32[1] = 897988541;
    float32x2_t v35 = vdiv_f32(*v34, (float32x2_t)vdup_n_s32(0x358637BDu));
    *uint64_t v34 = v35;
    float v18 = fminf(v18, v35.f32[0]);
    float v17 = fmaxf(v17, v35.f32[0]);
    float v15 = fminf(v15, v35.f32[1]);
    float v16 = fmaxf(v16, v35.f32[1]);
    uint64_t v22 = (float *)(((_BYTE)v12 - 1) & 3);
    if (((v9 >> (char)v22) & 1) == 0) {
      goto LABEL_18;
    }
LABEL_7:
    uint64_t v12 = v24;
  }
  while (v24 != 4);
  return HGRectMake4f((uint64_t)v22, v18 - v4, v15 - v4, v17 + v4, v16 + v4);
}

uint64_t HGAnisotropicSampler::GetROI(HGAnisotropicSampler *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v104 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)this + 125) <= a3) {
    return 0;
  }
  uint64_t v4 = *(void *)&a4.var2;
  uint64_t v5 = *(void *)&a4.var0;
  int v7 = (*(uint64_t (**)(HGAnisotropicSampler *))(*(void *)this + 312))(this);
  __n128 v8 = *(HGTransform **)(*((void *)this + 60) + 448);
  uint64_t v9 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
  uint64_t v10 = HGRectGrow(v5, v4, v9);
  uint64_t v13 = v12;
  uint64_t v14 = *((void *)this + 60);
  uint64_t v16 = *(void *)(v14 + 464);
  uint64_t v15 = *(void *)(v14 + 472);
  int v83 = v7;
  float v17 = v7 <= 0 ? 0.5 : 1.5;
  float v18 = *(float *)(v14 + 424);
  HIDWORD(v19) = *(int *)(v14 + 436) >> 31;
  double v20 = (double)*(int *)(v14 + 436);
  int v21 = *(_DWORD *)(v14 + 480);
  int v22 = *(_DWORD *)(v14 + 484);
  if (a2
  {
    unsigned int MaxTileArea = HGGPURenderer::GetMaxTileArea(v23);
  }
  else
  {
    unsigned int MaxTileArea = 0x1000000;
  }
  *(void *)&v105.int var0 = v10;
  *(void *)&v105.int var2 = v13;
  *(void *)&v106.int var0 = v16;
  *(void *)&v106.int var2 = v15;
  *(float *)&double v19 = v17;
  uint64_t v25 = hg_clip(v8, v105, v106, v19, v18, v20, v11, v86, v21, v22, MaxTileArea);
  if (HGRectIsNull(v25, v26)) {
    return 0;
  }
  int v29 = a3;
  int v30 = *((_DWORD *)this + 124) + a3;
  if ((a3 != 7 || v30 >= v86[0]) && (v30 < v86[0] || v30 > v86[1])) {
    return 0;
  }
  uint64_t v31 = *((void *)this + 60);
  if (*(int *)(v31 + 436) >= 2)
  {
    uint64_t v32 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    uint64_t v5 = HGRectGrow(v5, v4, v32);
    uint64_t v4 = v33;
    uint64_t v31 = *((void *)this + 60);
  }
  uint64_t v34 = *(void *)(v31 + 448);
  float v92 = (float)(int)v5 + 0.5;
  float v93 = (float)SHIDWORD(v5) + 0.5;
  uint64_t v94 = 0x3F80000000000000;
  float v95 = (float)(int)v4 + -0.5;
  float v96 = v93;
  uint64_t v97 = 0x3F80000000000000;
  float v98 = v95;
  float v99 = (float)SHIDWORD(v4) + -0.5;
  uint64_t v100 = 0x3F80000000000000;
  float v101 = v92;
  float v102 = v99;
  uint64_t v103 = 0x3F80000000000000;
  (*(void (**)(uint64_t, unsigned char *, float *, uint64_t))(*(void *)v34 + 208))(v34, v87, &v92, 4);
  v35.n128_u32[0] = 897988541;
  v36.n128_f32[0] = v90;
  v37.n128_f32[0] = v91;
  unsigned int v38 = (v88 < 0.000001) | (2 * (v89 < 0.000001)) | (4 * (v90 < 0.000001)) | (8 * (v91 < 0.000001));
  if (v38 != 15 && (!v38 || (int)v4 - (uint64_t)(int)v5 > 1 || (v4 >> 32) - (v5 >> 32) > 1))
  {
    uint64_t v42 = (*(uint64_t (**)(uint64_t, __n128, __n128, __n128))(*(void *)v34 + 272))(v34, v35, v36, v37);
    uint64_t v43 = 0;
    v44.f64[0] = *(float64_t *)(v42 + 24);
    double v45 = *(double *)(v42 + 120) + -0.000000999999997;
    double v81 = *(double *)(v42 + 56);
    double v82 = v44.f64[0];
    v44.f64[1] = v81;
    float64x2_t v80 = v44;
    float v46 = INFINITY;
    float v47 = -INFINITY;
    float32x2_t v48 = (float32x2_t)vdup_n_s32(0x358637BDu);
    float v49 = -INFINITY;
    float v50 = INFINITY;
    while (1)
    {
      if ((v38 >> v43))
      {
        uint64_t v55 = v43 + 1;
        if (((v38 >> ((v43 + 1) & 3)) & 1) == 0)
        {
          float32x2_t v56 = *(float32x2_t *)(&v92 + 4 * v43);
          float64x2_t v57 = vcvtq_f64_f32(v56);
          float32x2_t v58 = *(float32x2_t *)(&v92 + 4 * (v55 & 3));
          double v59 = v45 + v82 * v57.f64[0] + vmuld_lane_f64(v81, v57, 1);
          double v60 = vaddvq_f64(vmulq_f64(v80, vsubq_f64(v57, vcvtq_f64_f32(v58))));
          if (v60 == 0.0)
          {
            BOOL v62 = v59 < 0.0;
            double v61 = INFINITY;
            if (v62) {
              double v61 = -INFINITY;
            }
          }
          else
          {
            double v61 = v59 / v60;
          }
          unint64_t v63 = (float32x2_t *)&v87[16 * v43];
          *unint64_t v63 = vcvt_f32_f64(vaddq_f64(vmulq_n_f64(vcvtq_f64_f32(vsub_f32(v58, v56)), v61), v57));
          v63[1] = (float32x2_t)0x3F80000000000000;
          (*(void (**)(uint64_t, float32x2_t *, float32x2_t *, uint64_t))(*(void *)v34 + 208))(v34, v63, v63, 1);
          v63[1].i32[1] = 897988541;
          float32x2_t v64 = vdiv_f32(*v63, v48);
          *unint64_t v63 = v64;
          float v50 = fminf(v50, v64.f32[0]);
          float v49 = fmaxf(v49, v64.f32[0]);
          float v46 = fminf(v46, v64.f32[1]);
          float v47 = fmaxf(v47, v64.f32[1]);
          uint64_t v51 = (float *)(((_BYTE)v43 - 1) & 3);
          if ((v38 >> (char)v51)) {
            goto LABEL_25;
          }
LABEL_35:
          float32x2_t v65 = *(float32x2_t *)(&v92 + 4 * v43);
          float64x2_t v66 = vcvtq_f64_f32(v65);
          float32x2_t v67 = *(float32x2_t *)(&v92 + 4 * v51);
          double v68 = v45 + v82 * v66.f64[0] + vmuld_lane_f64(v81, v66, 1);
          double v69 = vaddvq_f64(vmulq_f64(v80, vsubq_f64(v66, vcvtq_f64_f32(v67))));
          if (v69 == 0.0)
          {
            BOOL v62 = v68 < 0.0;
            double v70 = INFINITY;
            if (v62) {
              double v70 = -INFINITY;
            }
          }
          else
          {
            double v70 = v68 / v69;
          }
          uint64_t v71 = (float32x2_t *)&v87[16 * v43];
          *uint64_t v71 = vcvt_f32_f64(vaddq_f64(vmulq_n_f64(vcvtq_f64_f32(vsub_f32(v67, v65)), v70), v66));
          v71[1] = (float32x2_t)0x3F80000000000000;
          (*(void (**)(uint64_t, float32x2_t *, float32x2_t *, uint64_t))(*(void *)v34 + 208))(v34, v71, v71, 1);
          v71[1].i32[1] = 897988541;
          float32x2_t v72 = vdiv_f32(*v71, v48);
          *uint64_t v71 = v72;
          float v50 = fminf(v50, v72.f32[0]);
          float v49 = fmaxf(v49, v72.f32[0]);
          float v46 = fminf(v46, v72.f32[1]);
          float v47 = fmaxf(v47, v72.f32[1]);
          goto LABEL_25;
        }
        uint64_t v51 = (float *)(((_BYTE)v43 - 1) & 3);
        if (((v38 >> (char)v51) & 1) == 0) {
          goto LABEL_35;
        }
      }
      else
      {
        uint64_t v51 = (float *)&v87[16 * v43];
        float v52 = v51[3];
        float v53 = *v51 / v52;
        float v54 = v51[1] / v52;
        *uint64_t v51 = v53;
        v51[1] = v54;
        float v50 = fminf(v50, v53);
        float v49 = fmaxf(v49, v53);
        float v46 = fminf(v46, v54);
        float v47 = fmaxf(v47, v54);
        uint64_t v55 = v43 + 1;
      }
LABEL_25:
      uint64_t v43 = v55;
      if (v55 == 4)
      {
        uint64_t v39 = HGRectMake4f((uint64_t)v51, v50, v46, v49 + 0.0, v47 + 0.0);
        uint64_t v40 = v73;
        float64x2_t v41 = a2;
        int v29 = a3;
        goto LABEL_41;
      }
    }
  }
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  float64x2_t v41 = a2;
LABEL_41:
  uint64_t v74 = *((void *)this + 61);
  uint64_t v75 = (*((_DWORD *)this + 124) + v29);
  uint64_t v76 = (*(uint64_t (**)(HGRenderer *, __n128, __n128, __n128))(*(void *)v41 + 304))(v41, v35, v36, v37);
  uint64_t v27 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t))(*(void *)v74 + 592))(v74, v75, v39, v40, 1, 0, v76);
  uint64_t v78 = v77;
  if (v83 >= 1)
  {
    uint64_t v79 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    return HGRectGrow(v27, v78, v79);
  }
  return v27;
}

uint64_t hg_clip(HGTransform *a1, HGRect a2, HGRect a3, double a4, float a5, double a6, double a7, int *a8, int a9, int a10, unsigned int a11)
{
  uint64_t v14 = *(void *)&a2.var2;
  float v16 = *(float *)&a4;
  uint64_t v17 = *(void *)&a2.var0;
  uint64_t v136 = *MEMORY[0x1E4F143B8];
  int var1 = a2.var1;
  int var3 = a2.var3;
  int v104 = a3.var1;
  int var0 = a3.var0;
  int var2 = a3.var2;
  int v21 = a3.var3;
  long long v120 = xmmword_1B7E77190;
  (*(void (**)(HGTransform *, float *, long long *, uint64_t))(*(void *)a1 + 208))(a1, &v124, &v120, 1);
  int v102 = v21;
  if (((v14 - v17) < 5 || (var3 - var1) <= 4) && a9 < a10)
  {
    unsigned int v22 = (v21 - v104) * (var2 - var0);
    float v23 = sqrtf((float)((float)((float)(v124 * v124) + (float)(v125 * v125)) + (float)(*(float *)&v126 * *(float *)&v126))+ (float)(*((float *)&v126 + 1) * *((float *)&v126 + 1)));
    if (fabsf((float)(*((float *)&v120 + 2) * (float)((float)(*(float *)&v126 / *((float *)&v126 + 1)) / v23))+ (float)((float)(*((float *)&v120 + 1) * (float)((float)(v125 / *((float *)&v126 + 1)) / v23))+ (float)(*(float *)&v120 * (float)((float)(v124 / *((float *)&v126 + 1)) / v23)))) < 0.00000001&& v22 > a11)
    {
      if (a9 < a10)
      {
        do
        {
          ++a9;
          unsigned int v22 = ((double)v22 * 0.25);
        }
        while (v22 > a11 && a9 < a10);
      }
      if (a9 >= a10) {
        a9 = a10 - 1;
      }
    }
  }
  if ((a10 & ~(a10 >> 31)) >= 0x1F) {
    unsigned int v26 = 31;
  }
  else {
    unsigned int v26 = a10 & ~(a10 >> 31);
  }
  float v124 = (float)(int)v17 + 0.5;
  float v125 = (float)var1 + 0.5;
  uint64_t v126 = 0x3F80000000000000;
  float v127 = (float)(int)v14 + -0.5;
  float v128 = v125;
  uint64_t v129 = 0x3F80000000000000;
  float v130 = v127;
  float v131 = (float)var3 + -0.5;
  uint64_t v132 = 0x3F80000000000000;
  float v133 = v124;
  float v134 = v131;
  uint64_t v135 = 0x3F80000000000000;
  (*(void (**)(HGTransform *, long long *, float *, uint64_t))(*(void *)a1 + 208))(a1, &v120, &v124, 4);
  v27.n128_u32[0] = 897988541;
  v28.n128_f32[0] = v122;
  v29.n128_f32[0] = v123;
  unsigned int v30 = (*((float *)&v120 + 3) < 0.000001) | (2 * (v121 < 0.000001)) | (4 * (v122 < 0.000001)) | (8 * (v123 < 0.000001));
  if ((a9 & ~(a9 >> 31)) >= 0x1F) {
    int v31 = 31;
  }
  else {
    int v31 = a9 & ~(a9 >> 31);
  }
  if (v26 <= v31) {
    int v32 = v31;
  }
  else {
    int v32 = v26;
  }
  if (v30 == 15) {
    return 0;
  }
  BOOL v33 = v30 && (int)v14 - (uint64_t)(int)v17 <= 1;
  if (v33 && (v14 >> 32) - (v17 >> 32) <= 1) {
    return 0;
  }
  float v101 = v16;
  uint64_t v35 = (*(uint64_t (**)(HGTransform *, __n128, __n128, __n128))(*(void *)a1 + 272))(a1, v27, v28, v29);
  uint64_t v36 = 0;
  v37.f64[0] = *(float64_t *)(v35 + 24);
  double v109 = *(double *)(v35 + 120) + -0.000000999999997;
  double v38 = (double)v31;
  double v106 = (double)v32;
  double v107 = a5;
  double v110 = *(double *)(v35 + 56);
  double v111 = v37.f64[0];
  float v39 = INFINITY;
  float v40 = -INFINITY;
  double v41 = INFINITY;
  double v42 = -INFINITY;
  float v43 = -INFINITY;
  float v44 = INFINITY;
  v37.f64[1] = v110;
  float64x2_t v108 = v37;
  float v45 = -INFINITY;
  float v118 = INFINITY;
  float v119 = -INFINITY;
  float v46 = INFINITY;
  double v117 = (double)v31;
  do
  {
    if ((v30 >> v36))
    {
      uint64_t v48 = v36 + 1;
      if ((v30 >> ((v36 + 1) & 3)))
      {
        unsigned int v49 = ((_BYTE)v36 - 1) & 3;
        if ((v30 >> v49)) {
          goto LABEL_36;
        }
LABEL_50:
        float32x2_t v77 = *(float32x2_t *)(&v124 + 4 * v36);
        float64x2_t v78 = vcvtq_f64_f32(v77);
        float32x2_t v79 = *(float32x2_t *)(&v124 + 4 * v49);
        double v80 = v109 + v111 * v78.f64[0] + vmuld_lane_f64(v110, v78, 1);
        double v81 = vaddvq_f64(vmulq_f64(v108, vsubq_f64(v78, vcvtq_f64_f32(v79))));
        float v82 = v44;
        float v83 = v45;
        if (v81 == 0.0)
        {
          BOOL v68 = v80 < 0.0;
          double v84 = INFINITY;
          if (v68) {
            double v84 = -INFINITY;
          }
        }
        else
        {
          double v84 = v80 / v81;
        }
        int32x2_t v85 = (float32x2_t *)(&v120 + v36);
        *int32x2_t v85 = vcvt_f32_f64(vaddq_f64(vmulq_n_f64(vcvtq_f64_f32(vsub_f32(v79, v77)), v84), v78));
        v85[1] = (float32x2_t)0x3F80000000000000;
        (*(void (**)(HGTransform *, float32x2_t *, float32x2_t *, uint64_t))(*(void *)a1 + 208))(a1, v85, v85, 1);
        v85[1].i32[1] = 897988541;
        float32x2_t v86 = vdiv_f32(*v85, (float32x2_t)vdup_n_s32(0x358637BDu));
        *int32x2_t v85 = v86;
        LOBYTE(v87) = v31;
        double v38 = (double)v31;
        double v88 = (double)v31;
        if (v31 < v26)
        {
          float32x2_t v116 = v86;
          double v89 = rho((float *)&v120 + 4 * v36, (const double *)v35, a6);
          long double v90 = log2(v89);
          float32x2_t v86 = v116;
          double v38 = (double)v31;
          double v91 = fmax(fmin(v90 + v107, v106), v117);
          double v88 = fmax(v42, v91);
          uint64_t v87 = (uint64_t)rint(ceil(v91));
        }
        double v42 = fmax(v88, v38);
        float v46 = fminf(v46, v86.f32[0]);
        float v118 = fminf(v118, v86.f32[1]);
        float v119 = fmaxf(v119, v86.f32[0]);
        float v45 = fmaxf(v83, v86.f32[1]);
        float v92 = (float)(1 << v87);
        float v44 = fminf(v82, v86.f32[0] - v92);
        float v43 = fmaxf(v43, v86.f32[0] + v92);
        float v39 = fminf(v39, v86.f32[1] - v92);
        float v40 = fmaxf(v40, v86.f32[1] + v92);
        double v41 = v38;
        goto LABEL_36;
      }
      float32x2_t v60 = *(float32x2_t *)(&v124 + 4 * v36);
      float64x2_t v61 = vcvtq_f64_f32(v60);
      float32x2_t v62 = *(float32x2_t *)(&v124 + 4 * (v48 & 3));
      double v63 = v109 + v111 * v61.f64[0] + vmuld_lane_f64(v110, v61, 1);
      double v64 = vaddvq_f64(vmulq_f64(v108, vsubq_f64(v61, vcvtq_f64_f32(v62))));
      float v65 = v44;
      float v66 = v45;
      if (v64 == 0.0)
      {
        BOOL v68 = v63 < 0.0;
        double v67 = INFINITY;
        if (v68) {
          double v67 = -INFINITY;
        }
      }
      else
      {
        double v67 = v63 / v64;
      }
      double v69 = (float32x2_t *)(&v120 + v36);
      *double v69 = vcvt_f32_f64(vaddq_f64(vmulq_n_f64(vcvtq_f64_f32(vsub_f32(v62, v60)), v67), v61));
      v69[1] = (float32x2_t)0x3F80000000000000;
      (*(void (**)(HGTransform *, float32x2_t *, float32x2_t *, uint64_t))(*(void *)a1 + 208))(a1, v69, v69, 1);
      v69[1].i32[1] = 897988541;
      float32x2_t v70 = vdiv_f32(*v69, (float32x2_t)vdup_n_s32(0x358637BDu));
      *double v69 = v70;
      LOBYTE(v71) = v31;
      double v38 = (double)v31;
      double v72 = (double)v31;
      if (v31 < v26)
      {
        float32x2_t v115 = v70;
        double v73 = rho((float *)&v120 + 4 * v36, (const double *)v35, a6);
        long double v74 = log2(v73);
        float32x2_t v70 = v115;
        double v38 = (double)v31;
        double v75 = fmax(fmin(v74 + v107, v106), v117);
        double v72 = fmax(v42, v75);
        uint64_t v71 = (uint64_t)rint(ceil(v75));
      }
      double v42 = fmax(v72, v38);
      float v46 = fminf(v46, v70.f32[0]);
      float v118 = fminf(v118, v70.f32[1]);
      float v119 = fmaxf(v119, v70.f32[0]);
      float v45 = fmaxf(v66, v70.f32[1]);
      float v76 = (float)(1 << v71);
      float v44 = fminf(v65, v70.f32[0] - v76);
      float v43 = fmaxf(v43, v70.f32[0] + v76);
      float v39 = fminf(v39, v70.f32[1] - v76);
      float v40 = fmaxf(v40, v70.f32[1] + v76);
      double v41 = v38;
      unsigned int v49 = ((_BYTE)v36 - 1) & 3;
      if (((v30 >> v49) & 1) == 0) {
        goto LABEL_50;
      }
    }
    else
    {
      double v113 = v42;
      float v114 = v39;
      float v50 = (float *)(&v120 + v36);
      float v51 = v50[3];
      float v52 = *v50 / v51;
      float v53 = v50[1] / v51;
      *float v50 = v52;
      v50[1] = v53;
      LOBYTE(v54) = v31;
      double v55 = v38;
      double v42 = v38;
      if (v31 < v26)
      {
        float v56 = v45;
        double v57 = rho(v50, (const double *)v35, a6);
        long double v58 = log2(v57);
        double v38 = (double)v31;
        float v45 = v56;
        double v59 = fmax(fmin(v58 + v107, v106), v117);
        double v55 = fmin(v41, v59);
        double v42 = fmax(v113, v59);
        uint64_t v54 = (uint64_t)rint(ceil(v59));
      }
      int v47 = 1 << v54;
      float v46 = fminf(v46, v52);
      float v118 = fminf(v118, v53);
      float v119 = fmaxf(v119, v52);
      float v45 = fmaxf(v45, v53);
      float v44 = fminf(v44, v52 - (float)v47);
      float v43 = fmaxf(v43, v52 + (float)v47);
      float v39 = fminf(v114, v53 - (float)v47);
      float v40 = fmaxf(v40, v53 + (float)v47);
      uint64_t v48 = v36 + 1;
      double v41 = v55;
    }
LABEL_36:
    uint64_t v36 = v48;
  }
  while (v48 != 4);
  double v93 = v101;
  float v94 = fmax((float)(v46 - v44), 1.0) * v101;
  *((float *)&v120 + 3) = v94;
  if (var0 != 0x80000000 && v119 < (float)((float)var0 - v94)) {
    return 0;
  }
  float v95 = fmax((float)(v118 - v39), 1.0) * v93;
  float v121 = v95;
  if (v104 != 0x80000000 && v45 < (float)((float)v104 - v95)) {
    return 0;
  }
  float v96 = fmax((float)(v43 - v119), 1.0) * v93;
  float v122 = v96;
  unint64_t v97 = 0x7FFFFFFFLL;
  if (var2 != 0x7FFFFFFF && v46 > (float)((float)var2 + v96)) {
    return 0;
  }
  float v98 = fmax((float)(v40 - v45), 1.0) * v93;
  float v123 = v98;
  if (v102 != 0x7FFFFFFF && v118 > (float)((float)v102 + v98)) {
    return 0;
  }
  if (a8)
  {
    unint64_t v97 = (uint64_t)rint(floor(v41));
    uint64_t v100 = (uint64_t)rint(ceil(v42));
    *a8 = v97;
    a8[1] = v100;
    if (v97 == v100)
    {
      if (v32 == v97)
      {
        unint64_t v97 = (__PAIR64__(v32, v31) - v26) >> 32;
        *a8 = v97;
      }
      else
      {
        if (v32 <= (int)v97) {
          unint64_t v97 = v97;
        }
        else {
          unint64_t v97 = (v97 + 1);
        }
        a8[1] = v97;
      }
    }
  }
  return HGRectMake4f(v97, floorf(v46), floorf(v118), ceilf(v119), ceilf(v45));
}

uint64_t HGAnisotropicSampler::Bind(HGAnisotropicSampler *this, HGHandler *a2)
{
  return 0;
}

uint64_t HGAnisotropicSampler::BindTexture(HGAnisotropicSampler *this, HGHandler *a2, uint64_t a3)
{
  (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, a3, 0);
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 43) == 1) {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 56))(a2, 0);
  }
  uint64_t v5 = (*(uint64_t (**)(HGAnisotropicSampler *, void))(*(void *)this + 312))(this, 0);
  (*(void (**)(HGHandler *, uint64_t, uint64_t))(*(void *)a2 + 48))(a2, v5, v5);
  return 0;
}

uint64_t HGAnisotropicSampler::UnBind(HGAnisotropicSampler *this, HGHandler *a2)
{
  return 0;
}

const char *HGAnisotropicSampler::GetProgram(HGAnisotropicSampler *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  int v5 = (*(uint64_t (**)(HGAnisotropicSampler *, HGRenderer *))(*(void *)this + 312))(this, a2);
  uint64_t v6 = *((void *)this + 60);
  float v7 = (float)*(int *)(v6 + 436);
  uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(v6 + 448) + 272))();
  v9.n128_u64[0] = *(void *)(v8 + 24);
  if (v9.n128_f64[0] == 0.0)
  {
    v9.n128_u64[0] = *(void *)(v8 + 56);
    if (v9.n128_f64[0] == 0.0)
    {
      v9.n128_u64[0] = *(void *)(v8 + 88);
      if (v9.n128_f64[0] == 0.0)
      {
        v9.n128_u64[0] = *(void *)v8;
        if (*(double *)v8 == *(double *)(v8 + 40) && v9.n128_f64[0] == *(double *)(v8 + 80))
        {
          v9.n128_u64[0] = *(void *)(v8 + 8);
          if (v9.n128_f64[0] == 0.0)
          {
            v9.n128_u64[0] = *(void *)(v8 + 16);
            if (v9.n128_f64[0] == 0.0)
            {
              v9.n128_u64[0] = *(void *)(v8 + 32);
              if (v9.n128_f64[0] == 0.0)
              {
                v9.n128_u64[0] = *(void *)(v8 + 48);
                if (v9.n128_f64[0] == 0.0) {
                  float v7 = 1.0;
                }
              }
            }
          }
        }
      }
    }
  }
  if (Target <= 0x60B0F)
  {
    if (Target > 0x6043F || Target == 394016)
    {
      if (*((_DWORD *)this + 125) == 1)
      {
        return "//GLfs2.0      \n"
               "//LEN=000000029c\n"
               "#ifndef GL_ES\n"
               "#define lowp\n"
               "#define mediump\n"
               "#define highp\n"
               "#endif\n"
               "#define defaultp mediump\n"
               "varying highp vec4 hg_TexCoord0;\n"
               "uniform highp sampler2D hg_Texture0;\n"
               "uniform highp vec4 hg_ProgramLocal0;\n"
               "uniform highp vec4 hg_ProgramLocal9;\n"
               "void main()\n"
               "{\n"
               "\tif (hg_TexCoord0.w > hg_ProgramLocal9.y) {\n"
               "\t\thighp vec4 uv = hg_TexCoord0/hg_TexCoord0.w;\n"
               "\t\thighp vec2 coord = uv.xy*hg_ProgramLocal0.xy + hg_ProgramLocal0.zw;\n"
               "\t\tgl_FragColor = texture2D(hg_Texture0, coord);\n"
               "\t} else {\n"
               "\t\tgl_FragColor = vec4(0.);\n"
               "\t}\n"
               "}\n"
               "//MD5=a7f2e069:2714aa11:2f22558e:c6207705\n"
               "//SIG=00000000:00000000:00000000:00000000:0001:000a:0000:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
      }
      else
      {
        if (v5)
        {
          uint64_t v14 = "//GLfs2.0      \n"
                "//LEN=0000000e0a\n"
                "#ifndef GL_ES\n"
                "#define highp\n"
                "#define mediump\n"
                "#define lowp\n"
                "#endif\n"
                "#define defaultp mediump\n"
                "#extension GL_OES_standard_derivatives : require\n"
                "#define mediump highp\n"
                "varying highp vec4 hg_TexCoord0;\n"
                "uniform highp sampler2D hg_Texture0;\n"
                "uniform highp sampler2D hg_Texture1;\n"
                "uniform highp sampler2D hg_Texture2;\n"
                "uniform highp sampler2D hg_Texture3;\n"
                "uniform highp sampler2D hg_Texture4;\n"
                "uniform highp sampler2D hg_Texture5;\n"
                "uniform highp sampler2D hg_Texture6;\n"
                "uniform highp sampler2D hg_Texture7;\n"
                "uniform highp vec4 hg_ProgramLocal0;\n"
                "uniform highp vec4 hg_ProgramLocal1;\n"
                "uniform highp vec4 hg_ProgramLocal2;\n"
                "uniform highp vec4 hg_ProgramLocal3;\n"
                "uniform highp vec4 hg_ProgramLocal4;\n"
                "uniform highp vec4 hg_ProgramLocal5;\n"
                "uniform highp vec4 hg_ProgramLocal6;\n"
                "uniform highp vec4 hg_ProgramLocal7;\n"
                "uniform highp vec4 hg_ProgramLocal8;\n"
                "uniform highp vec4 hg_ProgramLocal9;\n"
                "void main()\n"
                "{\n"
                "highp vec4 uv = hg_TexCoord0/hg_TexCoord0.w;\n"
                "highp vec4 ddxy = vec4(dFdx(uv.xy), dFdy(uv.xy));\n"
                "if (hg_TexCoord0.w > hg_ProgramLocal9.y) {\n"
                "highp vec4 c;\n"
                "highp vec2 coord;\n"
                "highp float f = log2(max(length(ddxy.xy), length(ddxy.zw))) + hg_ProgramLocal9.x;\n"
                "f = min(max(f, hg_ProgramLocal8.x), hg_ProgramLocal8.y);\n"
                "highp float lod = min(f, hg_ProgramLocal8.y - 1.);\n"
                "lod = floor(lod);\n"
                "if (lod < hg_ProgramLocal8.z || lod >= hg_ProgramLocal8.w) {\n"
                "    discard;\n"
                "} else {\n"
                "f -= lod;\n"
                "lod -= hg_ProgramLocal8.z;\n"
                "if (lod < 4.) {\n"
                "    if (lod < 2.) {\n"
                "        if (lod < 1.) {\n"
                "            coord = uv.xy*hg_ProgramLocal0.xy + hg_ProgramLocal0.zw;\n"
                "            c = texture2D(hg_Texture0, coord);\n"
                "            coord = uv.xy*hg_ProgramLocal1.xy + hg_ProgramLocal1.zw;\n"
                "            gl_FragColor = mix(c, texture2D(hg_Texture1, coord), f);\n"
                "        } else {\n"
                "            coord = uv.xy*hg_ProgramLocal1.xy + hg_ProgramLocal1.zw;\n"
                "            c = texture2D(hg_Texture1, coord);\n"
                "            coord = uv.xy*hg_ProgramLocal2.xy + hg_ProgramLocal2.zw;\n"
                "            gl_FragColor = mix(c, texture2D(hg_Texture2, coord), f);\n"
                "        }\n"
                "    } else {\n"
                "        if (lod < 3.) {\n"
                "            coord = uv.xy*hg_ProgramLocal2.xy + hg_ProgramLocal2.zw;\n"
                "            c = texture2D(hg_Texture2, coord);\n"
                "            coord = uv.xy*hg_ProgramLocal3.xy + hg_ProgramLocal3.zw;\n"
                "            gl_FragColor = mix(c, texture2D(hg_Texture3, coord), f);\n"
                "        } else {\n"
                "            coord = uv.xy*hg_ProgramLocal3.xy + hg_ProgramLocal3.zw;\n"
                "            c = texture2D(hg_Texture3, coord);\n"
                "            coord = uv.xy*hg_ProgramLocal4.xy + hg_ProgramLocal4.zw;\n"
                "            gl_FragColor = mix(c, texture2D(hg_Texture4, coord), f);\n"
                "        }\n"
                "    }\n"
                "} else {\n"
                "    if (lod < 6.) {\n"
                "        if (lod < 5.) {\n"
                "            coord = uv.xy*hg_ProgramLocal4.xy + hg_ProgramLocal4.zw;\n"
                "            c = texture2D(hg_Texture4, coord);\n"
                "            coord = uv.xy*hg_ProgramLocal5.xy + hg_ProgramLocal5.zw;\n"
                "            gl_FragColor = mix(c, texture2D(hg_Texture5, coord), f);\n"
                "        } else {\n"
                "            coord = uv.xy*hg_ProgramLocal5.xy + hg_ProgramLocal5.zw;\n"
                "            c = texture2D(hg_Texture5, coord);\n"
                "            coord = uv.xy*hg_ProgramLocal6.xy + hg_ProgramLocal6.zw;\n"
                "            gl_FragColor = mix(c, texture2D(hg_Texture6, coord), f);\n"
                "        }\n"
                "    } else {\n"
                "        coord = uv.xy*hg_ProgramLocal6.xy + hg_ProgramLocal6.zw;\n"
                "        c = texture2D(hg_Texture6, coord);\n"
                "        coord = uv.xy*hg_ProgramLocal7.xy + hg_ProgramLocal7.zw;\n"
                "        gl_FragColor = mix(c, texture2D(hg_Texture7, coord), f);\n"
                "    }\n"
                "}\n"
                "}\n"
                "} else {\n"
                "gl_FragColor = vec4(0.);\n"
                "}\n"
                "}\n"
                "//MD5=8828affd:84a65bad:f77ba030:c9de33bc\n"
                "//SIG=00000000:00000000:00000000:00000000:0008:000a:0000:0000:0000:0000:0000:0000:0001:08:0:1:0\n";
          uint64_t v15 = aGlfs20Len00000_135;
        }
        else
        {
          uint64_t v14 = "//GLfs2.0      \n"
                "//LEN=0000000a6a\n"
                "#ifndef GL_ES\n"
                "#define lowp\n"
                "#define mediump\n"
                "#define highp\n"
                "#endif\n"
                "#define defaultp mediump\n"
                "#extension GL_OES_standard_derivatives : require\n"
                "varying highp vec4 hg_TexCoord0;\n"
                "uniform highp sampler2D hg_Texture0;\n"
                "uniform highp sampler2D hg_Texture1;\n"
                "uniform highp sampler2D hg_Texture2;\n"
                "uniform highp sampler2D hg_Texture3;\n"
                "uniform highp sampler2D hg_Texture4;\n"
                "uniform highp sampler2D hg_Texture5;\n"
                "uniform highp sampler2D hg_Texture6;\n"
                "uniform highp sampler2D hg_Texture7;\n"
                "uniform highp vec4 hg_ProgramLocal0;\n"
                "uniform highp vec4 hg_ProgramLocal1;\n"
                "uniform highp vec4 hg_ProgramLocal2;\n"
                "uniform highp vec4 hg_ProgramLocal3;\n"
                "uniform highp vec4 hg_ProgramLocal4;\n"
                "uniform highp vec4 hg_ProgramLocal5;\n"
                "uniform highp vec4 hg_ProgramLocal6;\n"
                "uniform highp vec4 hg_ProgramLocal7;\n"
                "uniform highp vec4 hg_ProgramLocal8;\n"
                "uniform highp vec4 hg_ProgramLocal9;\n"
                "void main()\n"
                "{\n"
                "\thighp vec4 uv = hg_TexCoord0/hg_TexCoord0.w;\n"
                "\thighp vec4 ddxy = vec4(dFdx(uv.xy), dFdy(uv.xy));\n"
                "\tif (hg_TexCoord0.w > hg_ProgramLocal9.y) {\n"
                "\thighp vec2 coord;\n"
                "\thighp float lod = log2(max(length(ddxy.xy), length(ddxy.zw))) + hg_ProgramLocal9.x;\n"
                "\tlod = min(max(lod, hg_ProgramLocal8.x), hg_ProgramLocal8.y);\n"
                "\tlod = ceil(lod);\n"
                "\t\n"
                "\tif (lod < hg_ProgramLocal8.z || lod > hg_ProgramLocal8.w) {\n"
                "\t   discard;\n"
                "\t} else {\n"
                "\tlod -= hg_ProgramLocal8.z;\n"
                "\t\tif (lod < 4.) {\n"
                "\t\t\tif (lod < 2.) {\n"
                "\t\t\t\tif (lod < 1.) {\n"
                "\t\t\t\t   coord = uv.xy*hg_ProgramLocal0.xy + hg_ProgramLocal0.zw;\n"
                "\t\t\t\t\tgl_FragColor = texture2D(hg_Texture0, coord);\n"
                "\t\t\t\t} else {\n"
                "\t\t\t\t\tcoord = uv.xy*hg_ProgramLocal1.xy + hg_ProgramLocal1.zw;\n"
                "\t\t\t\t\tgl_FragColor = texture2D(hg_Texture1, coord);\n"
                "\t\t\t\t}\n"
                "\t\t\t} else {\n"
                "\t\t\t\tif (lod < 3.) {\n"
                "\t\t\t\t\tcoord = uv.xy*hg_ProgramLocal2.xy + hg_ProgramLocal2.zw;\n"
                "\t\t\t\t\tgl_FragColor = texture2D(hg_Texture2, coord);\n"
                "\t\t\t   } else {\n"
                "\t\t\t\t\tcoord = uv.xy*hg_ProgramLocal3.xy + hg_ProgramLocal3.zw;\n"
                "\t\t\t\t\tgl_FragColor = texture2D(hg_Texture3, coord);\n"
                "\t\t\t\t}\n"
                "\t\t\t}\n"
                "\t\t} else {\n"
                "\t\t\tif (lod < 6.) {\n"
                "\t\t\t\tif (lod < 5.) {\n"
                "\t\t\t\t\tcoord = uv.xy*hg_ProgramLocal4.xy + hg_ProgramLocal4.zw;\n"
                "\t\t\t\t\tgl_FragColor = texture2D(hg_Texture4, coord);\n"
                "\t\t\t\t} else {\n"
                "\t\t\t\t\tcoord = uv.xy*hg_ProgramLocal5.xy + hg_ProgramLocal5.zw;\n"
                "\t\t\t\t\tgl_FragColor = texture2D(hg_Texture5, coord);\n"
                "\t\t\t\t}\n"
                "\t\t\t} else {\n"
                "\t\t\t\tif (lod < 7.) {\n"
                "\t\t\t\t\tcoord = uv.xy*hg_ProgramLocal6.xy + hg_ProgramLocal6.zw;\n"
                "\t\t\t\t\tgl_FragColor = texture2D(hg_Texture6, coord);\n"
                "\t\t\t\t} else {\n"
                "\t\t\t\t\tcoord = uv.xy*hg_ProgramLocal7.xy + hg_ProgramLocal7.zw;\n"
                "\t\t\t\t\tgl_FragColor = texture2D(hg_Texture7, coord);\n"
                "\t\t\t\t}\n"
                "\t\t\t}\n"
                "\t\t}\n"
                "\t}\n"
                "\t} else {\n"
                "\t\tgl_FragColor = vec4(0.);\n"
                "\t}\n"
                "}\n"
                "//MD5=d39193e9:42f0582f:95174530:f40f17ba\n"
                "//SIG=00000000:00000000:00000000:00000000:0008:000a:0000:0000:0000:0000:0000:0000:0001:08:0:1:0\n";
          uint64_t v15 = aGlfs20Len00000_133;
        }
        if (v7 <= 1.0) {
          return v14;
        }
        else {
          return v15;
        }
      }
    }
    else
    {
      return "!!ARBfp1.0     \n"
             "##LEN=000000072e\n"
             "##                          \n"
             "##                            \n"
             "##                                \n"
             "##                                     \n"
             "##$\n"
             "OUTPUT $o0=result.color;\n"
             "ATTRIB $f0=fragment.texcoord[0];\n"
             "ATTRIB $f1=fragment.texcoord[1];\n"
             "ATTRIB $f2=fragment.texcoord[2];\n"
             "ATTRIB $f3=fragment.texcoord[3];\n"
             "PARAM $p0=program.local[0];\n"
             "PARAM $p1=program.local[1];\n"
             "PARAM $c0={1.5,.5,0,0};\n"
             "PARAM $c1={.5,1.5,0,0};\n"
             "PARAM $c2={1.5,1.5,0,0};\n"
             "PARAM $c3={.5,.5,0,0};\n"
             "##%\n"
             "TEMP r0,r1,r2,r3,r4,r5,r6,r7;\n"
             "##@\n"
             "##3\n"
             "TXP r7,$f3,texture[3],2D;\n"
             "MAD r7.w,$p1.x,r7.w,$p1.w;\n"
             "SUB r6.w,r7,$p0.x;\n"
             "SUB r6.xyz,$p0.z,r7.w;\n"
             "KIL r6;\n"
             "SUB r7.w,$p0.y,r7;\n"
             "MOV_SAT r7.x,r7.w;\n"
             "MOV_SAT r7.w,-r7.w;\n"
             "ADD r7.y,r7.x,r7.w;\n"
             "RCP r6.w,$f3.w;\n"
             "MAD r6.xy,$f1,r6.w,-$c3;\n"
             "FLR r5.xy,r6;\n"
             "SUB r6.xy,r6,r5;\n"
             "ADD r0.xy,r5,$c3;\n"
             "##1\n"
             "TEX r0,r0,texture[1],RECT;\n"
             "ADD r1.xy,r5,$c0;\n"
             "##1\n"
             "TEX r1,r1,texture[1],RECT;\n"
             "ADD r2.xy,r5,$c1;\n"
             "##1\n"
             "TEX r2,r2,texture[1],RECT;\n"
             "ADD r3.xy,r5,$c2;\n"
             "##1\n"
             "TEX r3,r3,texture[1],RECT;\n"
             "LRP r0,r6.x,r1,r0;\n"
             "LRP r2,r6.x,r3,r2;\n"
             "LRP r0,r6.y,r2,r0;\n"
             "MAD r4,-r7.y,r0,r0;\n"
             "MAD r6.xy,$f0,r6.w,-$c3;\n"
             "FLR r5,r6;\n"
             "SUB r6.xy,r6,r5;\n"
             "ADD r0,r5,$c3;\n"
             "##0\n"
             "TEX r0,r0,texture[0],RECT;\n"
             "ADD r1,r5,$c0;\n"
             "##0\n"
             "TEX r1,r1,texture[0],RECT;\n"
             "ADD r2,r5,$c1;\n"
             "##0\n"
             "TEX r2,r2,texture[0],RECT;\n"
             "ADD r3,r5,$c2;\n"
             "##0\n"
             "TEX r3,r3,texture[0],RECT;\n"
             "LRP r0,r6.x,r1,r0;\n"
             "LRP r2,r6.x,r3,r2;\n"
             "LRP r0,r6.y,r2,r0;\n"
             "MAD r4,r7.x,r0,r4;\n"
             "MAD r6.xy,$f2,r6.w,-$c3;\n"
             "FLR r5,r6;\n"
             "SUB r6.xy,r6,r5;\n"
             "ADD r0,r5,$c3;\n"
             "##2\n"
             "TEX r0,r0,texture[2],RECT;\n"
             "ADD r1,r5,$c0;\n"
             "##2\n"
             "TEX r1,r1,texture[2],RECT;\n"
             "ADD r2,r5,$c1;\n"
             "##2\n"
             "TEX r2,r2,texture[2],RECT;\n"
             "ADD r3,r5,$c2;\n"
             "##2\n"
             "TEX r3,r3,texture[2],RECT;\n"
             "LRP r0,r6.x,r1,r0;\n"
             "LRP r2,r6.x,r3,r2;\n"
             "LRP r0,r6.y,r2,r0;\n"
             "MAD r4,r7.w,r0,r4;\n"
             "CMP $o0,$f3.w,0.,r4;\n"
             "END\n"
             "##MD5=ef0fd3e2:cb522fe7:1347379a:8991ea22\n"
             "##SIG=01000000:00000000:00000000:00000000:0004:0002:0008:0000:0000:0000:0000:0000:0004:04:0:1:0\n";
    }
  }
  else
  {
    int v10 = (*(uint64_t (**)(HGRenderer *, uint64_t, __n128))(*(void *)a2 + 128))(a2, 20, v9);
    if (*((_DWORD *)this + 125) == 1)
    {
      double v11 = "//Metal1.0     \n"
            "//LEN=0000000369\n"
            "fragment FragmentOut fragmentFunc(VertexInOut            frag        [[ stage_in ]],\n"
            "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
            "                                  texture2d< float >     hg_Texture0 [[ texture(0) ]],\n"
            "                                  sampler                hg_Sampler0 [[ sampler(0) ]])\n"
            "{\n"
            "    FragmentOut out;\n"
            "    \n"
            "    if (frag._texCoord0.w > hg_Params[9].y)\n"
            "    {\n"
            "        float4 uv = frag._texCoord0 / frag._texCoord0.w;\n"
            "        float2 coordinate = uv.xy * hg_Params[0].xy + hg_Params[0].zw;\n"
            "        out.color0 = hg_Texture0.sample(hg_Sampler0, coordinate);\n"
            "    }\n"
            "    else\n"
            "    {\n"
            "        out.color0 = float4(0.0f);\n"
            "    }\n"
            "    \n"
            "    return out;\n"
            "}\n"
            "//MD5=750a3032:b6067064:6a00a29b:b3c8c145\n"
            "//SIG=00000000:00000000:00000000:00000000:0001:0001:0000:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
      uint64_t v12 = "//Metal1.0     \n"
            "//LEN=0000000372\n"
            "fragment FragmentOut fragmentFunc(VertexInOut            frag        [[ stage_in ]],\n"
            "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
            "                                  texture2d< half >      hg_Texture0 [[ texture(0) ]],\n"
            "                                  sampler                hg_Sampler0 [[ sampler(0) ]])\n"
            "{\n"
            "    FragmentOut out;\n"
            "    \n"
            "    if (frag._texCoord0.w > hg_Params[9].y)\n"
            "    {\n"
            "        float4 uv = frag._texCoord0 / frag._texCoord0.w;\n"
            "        float2 coordinate = uv.xy * hg_Params[0].xy + hg_Params[0].zw;\n"
            "        out.color0 = (float4) hg_Texture0.sample(hg_Sampler0, coordinate);\n"
            "    }\n"
            "    else\n"
            "    {\n"
            "        out.color0 = float4(0.0f);\n"
            "    }\n"
            "    \n"
            "    return out;\n"
            "}\n"
            "//MD5=eb23f2ee:71cb8148:b382db79:f0fcba1b\n"
            "//SIG=00400000:00000000:00000000:00000001:0001:000a:0000:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    }
    else if (v5)
    {
      if (v7 > 1.0)
      {
        double v11 = aMetal10Len0000_400;
        uint64_t v12 = aMetal10Len0000_399;
      }
      else
      {
        double v11 = aMetal10Len0000_398;
        uint64_t v12 = aMetal10Len0000_397;
      }
    }
    else if (v7 > 1.0)
    {
      double v11 = aMetal10Len0000_396;
      uint64_t v12 = aMetal10Len0000_395;
    }
    else
    {
      double v11 = aMetal10Len0000_394;
      uint64_t v12 = aMetal10Len0000_393;
    }
    if (v10 == 27) {
      return v12;
    }
    else {
      return v11;
    }
  }
}

void HGAnisotropicSampler::InitProgramDescriptor(HGAnisotropicSampler *this, HGProgramDescriptor *a2)
{
  uint64_t v4 = *((void *)this + 60);
  float v5 = (float)*(int *)(v4 + 436);
  uint64_t v6 = (double *)(*(uint64_t (**)(void))(**(void **)(v4 + 448) + 272))(*(void *)(v4 + 448));
  if (v6[3] == 0.0
    && v6[7] == 0.0
    && v6[11] == 0.0
    && *v6 == v6[5]
    && *v6 == v6[10]
    && v6[1] == 0.0
    && v6[2] == 0.0
    && v6[4] == 0.0
    && v6[6] == 0.0)
  {
    float v5 = 1.0;
  }
  HGMetalUtils::stringForMetalHeader((uint64_t)&v28);
  HGMetalUtils::stringForMetalVertexOutputStruct((HGMetalUtils *)1, 0, (uint64_t)v26);
  if ((v27 & 0x80u) == 0) {
    float v7 = v26;
  }
  else {
    float v7 = (void **)v26[0];
  }
  if ((v27 & 0x80u) == 0) {
    std::string::size_type v8 = v27;
  }
  else {
    std::string::size_type v8 = (std::string::size_type)v26[1];
  }
  __n128 v9 = std::string::append(&v28, (const std::string::value_type *)v7, v8);
  long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  v29.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  HGMetalUtils::stringForMetalVertexShader((HGMetalUtils *)"vertexFunc", (const char *)1, 0, (uint64_t)v24);
  if ((v25 & 0x80u) == 0) {
    double v11 = v24;
  }
  else {
    double v11 = (void **)v24[0];
  }
  if ((v25 & 0x80u) == 0) {
    std::string::size_type v12 = v25;
  }
  else {
    std::string::size_type v12 = (std::string::size_type)v24[1];
  }
  uint64_t v13 = std::string::append(&v29, (const std::string::value_type *)v11, v12);
  long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v21.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v14;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  HGMetalUtils::stringForMetalFragmentOutputStruct((HGMetalUtils *)1, 0, (uint64_t)__p);
  if ((v23 & 0x80u) == 0) {
    uint64_t v15 = __p;
  }
  else {
    uint64_t v15 = (void **)__p[0];
  }
  if ((v23 & 0x80u) == 0) {
    std::string::size_type v16 = v23;
  }
  else {
    std::string::size_type v16 = (std::string::size_type)__p[1];
  }
  uint64_t v17 = std::string::append(&v21, (const std::string::value_type *)v15, v16);
  long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v30.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  if ((char)v23 < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_31:
      if (((char)v25 & 0x80000000) == 0) {
        goto LABEL_32;
      }
      goto LABEL_39;
    }
  }
  else if ((SHIBYTE(v21.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_31;
  }
  operator delete(v21.__r_.__value_.__l.__data_);
  if (((char)v25 & 0x80000000) == 0)
  {
LABEL_32:
    if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_33;
    }
    goto LABEL_40;
  }
LABEL_39:
  operator delete(v24[0]);
  if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_33:
    if (((char)v27 & 0x80000000) == 0) {
      goto LABEL_34;
    }
    goto LABEL_41;
  }
LABEL_40:
  operator delete(v29.__r_.__value_.__l.__data_);
  if (((char)v27 & 0x80000000) == 0)
  {
LABEL_34:
    if ((SHIBYTE(v28.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_35;
    }
    goto LABEL_42;
  }
LABEL_41:
  operator delete(v26[0]);
  if ((SHIBYTE(v28.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_35:
    if (*((_DWORD *)this + 125) == 1)
    {
LABEL_36:
      double v19 = "//Metal1.0     \n"
            "//LEN=0000000369\n"
            "fragment FragmentOut fragmentFunc(VertexInOut            frag        [[ stage_in ]],\n"
            "                                  const constant float4* hg_Params   [[ buffer(0) ]],\n"
            "                                  texture2d< float >     hg_Texture0 [[ texture(0) ]],\n"
            "                                  sampler                hg_Sampler0 [[ sampler(0) ]])\n"
            "{\n"
            "    FragmentOut out;\n"
            "    \n"
            "    if (frag._texCoord0.w > hg_Params[9].y)\n"
            "    {\n"
            "        float4 uv = frag._texCoord0 / frag._texCoord0.w;\n"
            "        float2 coordinate = uv.xy * hg_Params[0].xy + hg_Params[0].zw;\n"
            "        out.color0 = hg_Texture0.sample(hg_Sampler0, coordinate);\n"
            "    }\n"
            "    else\n"
            "    {\n"
            "        out.color0 = float4(0.0f);\n"
            "    }\n"
            "    \n"
            "    return out;\n"
            "}\n"
            "//MD5=750a3032:b6067064:6a00a29b:b3c8c145\n"
            "//SIG=00000000:00000000:00000000:00000000:0001:0001:0000:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
LABEL_50:
      std::string::append(&v30, v19);
      if ((v30.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        double v20 = &v30;
      }
      else {
        double v20 = (std::string *)v30.__r_.__value_.__r.__words[0];
      }
      HGProgramDescriptor::SetShaderProgram(a2, (const char *)v20);
    }
LABEL_43:
    if (*((unsigned char *)this + 512))
    {
      if (v5 <= 1.0) {
        double v19 = aMetal10Len0000_394;
      }
      else {
        double v19 = aMetal10Len0000_396;
      }
    }
    else if (v5 <= 1.0)
    {
      double v19 = aMetal10Len0000_398;
    }
    else
    {
      double v19 = aMetal10Len0000_400;
    }
    goto LABEL_50;
  }
LABEL_42:
  operator delete(v28.__r_.__value_.__l.__data_);
  if (*((_DWORD *)this + 125) == 1) {
    goto LABEL_36;
  }
  goto LABEL_43;
}

void sub_1B77E9574(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *__p, int a15, __int16 a16, char a17, char a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,int a45,__int16 a46,char a47,char a48)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  std::vector<HGBinding>::~vector[abi:ne180100]((void **)&a43);
  std::vector<HGBinding>::~vector[abi:ne180100]((void **)(v48 - 160));
  if (*(char *)(v48 - 105) < 0) {
    operator delete(*(void **)(v48 - 128));
  }
  _Unwind_Resume(a1);
}

HGRenderer *HGAnisotropicSampler::RenderPageGeneric(uint64_t a1, HGRenderer **a2, int a3)
{
  uint64_t v6 = *a2;
  unint64_t v7 = (unint64_t)a2[2];
  unint64_t v8 = (unint64_t)a2[3];
  uint64_t v9 = (*(uint64_t (**)(uint64_t, HGRenderer *))(*(void *)a1 + 312))(a1, *a2);
  long long v10 = a2[1];
  if (v10)
  {
    (*(void (**)(HGRenderer *))(*(void *)v10 + 16))(v10);
    if (a3 != 1) {
      goto LABEL_3;
    }
LABEL_6:
    Input = HGRenderer::GetInput(v6, (HGNode *)a1, 0);
    uint64_t DOD = HGRenderer::GetDOD(v6, Input);
    HGAnisotropicSampler::GetPageMetal(a1, (HGBitmap **)a2, v7, v8, DOD, v16, v9, 0xFFFFFFFF, v17, v18, v19, v20, 0);
    return a2[1];
  }
  *(void *)&v22.int var0 = v7;
  *(void *)&v22.int var2 = v8;
  a2[1] = (HGRenderer *)HGGPURenderer::CreateBuffer((uint64_t)v6, v22, *((unsigned int *)a2 + 8), a3, (*(_DWORD *)(a1 + 16) >> 12) & 1, *((unsigned __int8 *)a2 + 248));
  if (a3 == 1) {
    goto LABEL_6;
  }
LABEL_3:
  if (!a3)
  {
    double v11 = HGRenderer::GetInput(v6, (HGNode *)a1, 0);
    uint64_t v12 = HGRenderer::GetDOD(v6, v11);
    HGAnisotropicSampler::GetPage(a1, (uint64_t)a2, v7, v8, v12, v13, v9, 0xFFFFFFFF, 0);
    return a2[1];
  }
  return 0;
}

uint64_t HGAnisotropicSampler::GetPage(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8, int a9)
{
  uint64_t v234 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = *(HGRenderer **)a2;
  unsigned int Target = HGRenderer::GetTarget(*(HGRenderer **)a2, 393216);
  uint64_t v17 = *(void *)(a1 + 480);
  int v18 = *(_DWORD *)(v17 + 436);
  double v19 = *(HGTransform **)(v17 + 448);
  unsigned int v228 = Target;
  int v215 = v18;
  if (v18 < 2)
  {
    *(void *)&v26.int var0 = *(void *)(v17 + 464);
    uint64_t v35 = *(void *)(v17 + 472);
    if ((int)a7 <= 0) {
      float v27 = 0.5;
    }
    else {
      float v27 = 1.5;
    }
    float v28 = *(float *)(v17 + 424);
    double v29 = (double)v18;
    int v30 = *(_DWORD *)(v17 + 480);
    int v31 = *(_DWORD *)(v17 + 484);
    if (v13)
    {
      uint64_t v36 = *(void *)(v17 + 464);
      if (v37) {
        int MaxTileArea = HGGPURenderer::GetMaxTileArea(v37);
      }
      else {
        int MaxTileArea = 0x1000000;
      }
      *(void *)&v26.int var0 = v36;
    }
    else
    {
      int MaxTileArea = 0x1000000;
    }
    uint64_t v39 = a7;
    unsigned int v196 = MaxTileArea;
    float v40 = v19;
    *(void *)&v41.int var0 = a3;
    *(void *)&v41.int var2 = a4;
    *(void *)&v26.int var2 = v35;
  }
  else
  {
    uint64_t v20 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    uint64_t v21 = HGRectGrow(a3, a4, v20);
    uint64_t v22 = v21;
    uint64_t v24 = v23;
    uint64_t v25 = *(void *)(a1 + 480);
    HGRect v26 = *(HGRect *)(v25 + 464);
    if ((int)a7 <= 0) {
      float v27 = 0.5;
    }
    else {
      float v27 = 1.5;
    }
    float v28 = *(float *)(v25 + 424);
    double v29 = (double)v18;
    int v30 = *(_DWORD *)(v25 + 480);
    int v31 = *(_DWORD *)(v25 + 484);
    if (v13)
    {
      uint64_t v208 = *(void *)(v25 + 472);
      uint64_t v211 = *(void *)(v25 + 464);
      uint64_t v32 = v21;
      if (v33) {
        int v34 = HGGPURenderer::GetMaxTileArea(v33);
      }
      else {
        int v34 = 0x1000000;
      }
      uint64_t v22 = v32;
      *(void *)&v26.int var2 = v208;
      *(void *)&v26.int var0 = v211;
    }
    else
    {
      int v34 = 0x1000000;
    }
    uint64_t v39 = a7;
    unsigned int v196 = v34;
    float v40 = v19;
    *(void *)&v41.int var0 = v22;
    *(void *)&v41.int var2 = v24;
  }
  *(float *)&double v15 = v27;
  uint64_t v42 = hg_clip(v40, v41, v26, v15, v28, v29, v16, &v232, v30, v31, v196);
  uint64_t v44 = v43;
  uint64_t result = HGRectIsNull(v42, v43);
  if (result) {
    goto LABEL_23;
  }
  unint64_t v49 = HIDWORD(a3);
  unint64_t v50 = HIDWORD(a4);
  int v51 = v232;
  double v52 = (double)a8;
  double v53 = fmax(((double)(int)v44 - (double)(int)v42) * (1.0 / (double)(1 << v51)) / (double)a8, ((double)SHIDWORD(v44) - (double)SHIDWORD(v42)) * (1.0 / (double)(1 << v51)) / (double)a8);
  unint64_t v219 = a4;
  uint64_t v54 = v42;
  if (a4 - a3 == 1 && HIDWORD(a4) - HIDWORD(a3) == 1 && v53 > 1.0)
  {
    unint64_t v214 = a3;
    uint64_t v55 = *(void *)(a1 + 480);
    float v56 = *(HGTransform **)(v55 + 448);
    uint64_t v57 = *(void *)(v55 + 464);
    uint64_t v58 = *(void *)(v55 + 472);
    if ((int)v39 <= 0) {
      float v59 = 0.5;
    }
    else {
      float v59 = 1.5;
    }
    float v60 = *(float *)(v55 + 424);
    int v61 = *(_DWORD *)(v55 + 480);
    int v62 = *(_DWORD *)(v55 + 484);
    if (v13
    {
      unsigned int v64 = HGGPURenderer::GetMaxTileArea(v63);
    }
    else
    {
      unsigned int v64 = 0x1000000;
    }
    *(void *)&v236.int var0 = v214;
    *(void *)&v236.int var2 = a4;
    *(void *)&v239.int var0 = v57;
    *(void *)&v239.int var2 = v58;
    a3 = v214;
    *(float *)&double v53 = v59;
    uint64_t v72 = hg_clip(v56, v236, v239, v53, v60, 1.0, v52, &v232, v61, v62, v64);
    uint64_t v81 = v80;
    uint64_t result = HGRectIsNull(v72, v80);
    if (result)
    {
LABEL_23:
      (*(void (**)(HGRenderer *, void))(*(void *)v13 + 144))(v13, *(void *)(a2 + 8));
      *(void *)&v235.int var0 = a3;
      *(void *)&v235.int var2 = a4;
      return HGGPURenderer::Clear(v13, v235, v47, v48);
    }
    int v51 = v233;
    int v232 = v233;
    int v78 = 1;
    if (v228 > 0x6043F)
    {
      uint64_t v44 = v81;
      uint64_t v54 = v72;
      LODWORD(v72) = 0;
    }
    else
    {
      uint64_t v44 = v81;
      uint64_t v54 = v72;
      LODWORD(v72) = 0;
      if (v228 != 394016) {
        goto LABEL_59;
      }
    }
  }
  else
  {
    unsigned int v212 = v39;
    if (v53 > 2.0)
    {
      if (SHIDWORD(a4) > SHIDWORD(a3) && (int)a4 > (int)a3)
      {
        uint64_t v65 = (uint64_t)rint(fmax(sqrt(((double)(int)a4 - (double)(int)a3) * ((double)SHIDWORD(a4) - (double)SHIDWORD(a3)) / v53), 1.0));
        do
        {
          unsigned int v66 = v49 + v65;
          int v216 = v49 + v65;
          if ((int)v49 + (int)v65 >= (int)v50) {
            unsigned int v66 = v50;
          }
          unsigned int v229 = v66;
          LODWORD(result) = a3;
          do
          {
            uint64_t v67 = (result + v65);
            if ((int)v67 >= (int)a4) {
              unsigned int v68 = a4;
            }
            else {
              unsigned int v68 = result + v65;
            }
            unint64_t v69 = v49;
            uint64_t v70 = HGRectMake4i(result, v49, v68, v229);
            HGAnisotropicSampler::GetPage(a1, a2, v70, v71, a5, a6, v39, a8, a9 + 1);
            unint64_t v49 = v69;
            uint64_t result = v67;
          }
          while ((int)v67 < (int)a4);
          unint64_t v49 = v216;
          LODWORD(v5CVOpenGLESTextureCacheFlush(this[3], 0) = HIDWORD(a4);
        }
        while (v216 < SHIDWORD(a4));
      }
      return result;
    }
    uint64_t v72 = v39;
    if (v53 > 1.0)
    {
      int v73 = a9 + 1;
      if (HIDWORD(a4) - HIDWORD(a3) <= (a4 - a3))
      {
        uint64_t v154 = HGRectMake4i(a3, HIDWORD(a3), ((int)a3 + (int)a4) >> 1, HIDWORD(a4));
        HGAnisotropicSampler::GetPage(a1, a2, v154, v155, a5, a6, v72, a8, a9 + 1);
        uint64_t v76 = HGRectMake4i(((int)a3 + (int)a4) >> 1, HIDWORD(a3), a4, HIDWORD(a4));
      }
      else
      {
        uint64_t v74 = HGRectMake4i(a3, HIDWORD(a3), a4, (HIDWORD(a3) + HIDWORD(a4)) >> 1);
        HGAnisotropicSampler::GetPage(a1, a2, v74, v75, a5, a6, v72, a8, v73);
        uint64_t v76 = HGRectMake4i(a3, (HIDWORD(a3) + HIDWORD(a4)) >> 1, a4, HIDWORD(a4));
      }
      return HGAnisotropicSampler::GetPage(a1, a2, v76, v77, a5, a6, v72, a8, v73);
    }
    unint64_t v214 = a3;
    if (v228 <= 0x6043F && v228 != 394016)
    {
      int v78 = v215;
      if ((int)v39 >= 1)
      {
        LODWORD(v72) = 1;
        uint64_t v79 = v54;
        uint64_t result = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
        uint64_t v226 = result;
        uint64_t v54 = v79;
        int v51 = v232;
        goto LABEL_60;
      }
LABEL_59:
      uint64_t v226 = 0;
LABEL_60:
      int v82 = v233;
      if (v51 <= v233)
      {
        uint64_t v83 = 0;
        float v84 = *(float *)(*(void *)(a1 + 480) + 424);
        v46.f32[0] = (float)(int)v54;
        v46.f32[1] = (float)SHIDWORD(v54);
        float32x4_t v221 = v46;
        v46.f32[0] = (float)(int)v44;
        v46.f32[1] = (float)SHIDWORD(v44);
        float32x4_t v213 = v46;
        if (v72) {
          uint64_t v85 = 2;
        }
        else {
          uint64_t v85 = 3;
        }
        uint64_t v86 = a1 + 416;
        float32x4_t v202 = (_OWORD *)(a2 + 52);
        float32x4_t v203 = (_OWORD *)(a2 + 36);
        int v230 = v51;
        int v200 = v51 - 1;
        uint64_t v201 = v51;
        uint64_t v87 = 32 * v51;
        uint64_t v204 = 32 * v85;
        uint64_t v205 = v85;
        int v88 = v51;
        unsigned int v217 = v78;
        uint64_t v89 = v51;
        uint64_t v206 = a1 + 416;
        do
        {
          uint64_t v90 = v89 + v83;
          uint64_t v91 = *(int *)(a1 + 496);
          if (v89 + v83 - v91 < *(int *)(a1 + 500) && v90 <= v82)
          {
            uint64_t v94 = *(void *)(a1 + 504) - 32 * v91 + v87;
            float32x4_t v95 = *(float32x4_t *)(v94 + 16);
            unint64_t v96 = vaddq_f32(vmulq_f32(v221, *(float32x4_t *)v94), v95).u64[0];
            v95.i64[0] = vaddq_f32(vmulq_f32(v213, *(float32x4_t *)v94), v95).u64[0];
            uint64_t v97 = HGRectIntegral(v94, *(float *)&v96, *((float *)&v96 + 1), v95.f32[0], v95.f32[1]);
            *(void *)(a2 + 36) = HGRectGrow(v97, v98, v226);
            *(void *)(a2 + 44) = v99;
            Input = HGRenderer::GetInput(v13, (HGNode *)a1, v230 + (int)v83 - *(_DWORD *)(a1 + 496));
            *(void *)(a2 + 168) = HGGPURenderer::GetNodeTexture(v13, Input, *(HGRect *)(a2 + 36), 0, 1u);
          }
          else
          {
            *float32x4_t v203 = *(_OWORD *)(a2 + 20);
            uint64_t v93 = *(void *)(a2 + 160);
            *(void *)(a2 + 168) = v93;
            if (v93) {
              (*(void (**)(uint64_t))(*(void *)v93 + 16))(v93);
            }
          }
          uint64_t v101 = *(int *)(a1 + 496);
          if (v89 + v83 - v101 + 1 >= *(int *)(a1 + 500) || v90 >= v233)
          {
            *float32x4_t v202 = *v203;
            uint64_t v110 = *(void *)(a2 + 168);
            *(void *)(a2 + 176) = v110;
            if (v110) {
              (*(void (**)(uint64_t))(*(void *)v110 + 16))(v110);
            }
          }
          else
          {
            uint64_t v102 = *(void *)(a1 + 504) - 32 * v101 + v87;
            float32x4_t v103 = *(float32x4_t *)(v102 + 32);
            float32x4_t v104 = *(float32x4_t *)(v102 + 48);
            unint64_t v105 = vaddq_f32(vmulq_f32(v221, v103), v104).u64[0];
            v104.i64[0] = vaddq_f32(vmulq_f32(v213, v103), v104).u64[0];
            uint64_t v106 = HGRectIntegral(v102, *(float *)&v105, *((float *)&v105 + 1), v104.f32[0], v104.f32[1]);
            *(void *)(a2 + 52) = HGRectGrow(v106, v107, v226);
            *(void *)(a2 + 6CVOpenGLESTextureCacheFlush(this[3], 0) = v108;
            double v109 = HGRenderer::GetInput(v13, (HGNode *)a1, v230 + (int)v83 - *(_DWORD *)(a1 + 496) + 1);
            *(void *)(a2 + 176) = HGGPURenderer::GetNodeTexture(v13, v109, *(HGRect *)(a2 + 52), 0, 1u);
          }
          uint64_t v111 = v89 + v83 + 2;
          uint64_t v112 = *(int *)(a1 + 496);
          if (v111 - v112 >= *(int *)(a1 + 500) || v111 > v233)
          {
            *(_OWORD *)(a2 + 68) = *v202;
            uint64_t v121 = *(void *)(a2 + 176);
            *(void *)(a2 + 184) = v121;
            if (v121) {
              (*(void (**)(uint64_t))(*(void *)v121 + 16))(v121);
            }
          }
          else
          {
            uint64_t v113 = *(void *)(a1 + 504) - 32 * v112 + v87;
            float32x4_t v114 = *(float32x4_t *)(v113 + 64);
            float32x4_t v115 = *(float32x4_t *)(v113 + 80);
            unint64_t v116 = vaddq_f32(vmulq_f32(v221, v114), v115).u64[0];
            v115.i64[0] = vaddq_f32(vmulq_f32(v213, v114), v115).u64[0];
            uint64_t v117 = HGRectIntegral(v113, *(float *)&v116, *((float *)&v116 + 1), v115.f32[0], v115.f32[1]);
            *(void *)(a2 + 68) = HGRectGrow(v117, v118, v226);
            *(void *)(a2 + 76) = v119;
            long long v120 = HGRenderer::GetInput(v13, (HGNode *)a1, v230 + (int)v83 - *(_DWORD *)(a1 + 496) + 2);
            *(void *)(a2 + 184) = HGGPURenderer::GetNodeTexture(v13, v120, *(HGRect *)(a2 + 68), 0, 1u);
          }
          (*(void (**)(HGRenderer *, void))(*(void *)v13 + 144))(v13, *(void *)(a2 + 8));
          (*(void (**)(HGRenderer *, void, void, void, void))(*(void *)v13 + 152))(v13, 0, *(void *)(a2 + 168), 0, 0);
          (*(void (**)(HGRenderer *, uint64_t, void, void, void))(*(void *)v13 + 152))(v13, 1, *(void *)(a2 + 176), 0, 0);
          (*(void (**)(HGRenderer *, uint64_t, void, void, void))(*(void *)v13 + 152))(v13, 2, *(void *)(a2 + 184), 0, 0);
          uint64_t v122 = (*(uint64_t (**)(HGRenderer *, void, uint64_t))(*(void *)v13 + 368))(v13, *(void *)(a1 + 64), a1);
          if (v122)
          {
            float v123 = (HGHandler *)v122;
            float v124 = *(_DWORD **)(a2 + 168);
            if (v124)
            {
              int v125 = v233;
              if (v230 + (int)v83 < v233) {
                int v125 = v230 + v83;
              }
              int v126 = v125 - *(_DWORD *)(a1 + 496);
              int v127 = *(_DWORD *)(a1 + 500);
              if (v126 >= v127) {
                int v128 = v127 - 1;
              }
              else {
                int v128 = v126;
              }
              v197[0] = -v124[5];
              v197[1] = -v124[6];
              (*(void (**)(uint64_t, void, void, void, void, void, void, void, unsigned int *))(*(void *)v122 + 32))(v122, v124[40], 0, 0, 0, 0, 0, 0, *(unsigned int **)v197);
              HGHandler::TexCoord(v123, 0, 0, 0, 0);
              uint64_t v129 = 32 * v128;
              (*(void (**)(HGHandler *, double, double, double))(*(void *)v123 + 96))(v123, COERCE_FLOAT(*(_OWORD *)(*(void *)(a1 + 504) + v129 + 16)), COERCE_FLOAT(HIDWORD(*(void *)(*(void *)(a1 + 504) + v129 + 16))), 0.0);
              long long v130 = *(_OWORD *)(*(void *)(a1 + 504) + v129);
              uint64_t v86 = a1 + 416;
              (*(void (**)(HGHandler *, double, double, double))(*(void *)v123 + 104))(v123, *(float *)&v130, *((float *)&v130 + 1), 1.0);
              (*(void (**)(HGHandler *, uint64_t))(*(void *)v123 + 120))(v123, v206);
            }
            float v131 = *(_DWORD **)(a2 + 176);
            if (v131)
            {
              int v132 = v233;
              if (v230 + (int)v83 + 1 < v233) {
                int v132 = v230 + v83 + 1;
              }
              int v133 = v132 - *(_DWORD *)(a1 + 496);
              int v134 = *(_DWORD *)(a1 + 500);
              if (v133 >= v134) {
                int v135 = v134 - 1;
              }
              else {
                int v135 = v133;
              }
              v198[0] = -v131[5];
              v198[1] = -v131[6];
              (*(void (**)(HGHandler *, void, void, void, void, void, void, void, unsigned int *))(*(void *)v123 + 32))(v123, v131[40], 0, 0, 0, 0, 0, 0, *(unsigned int **)v198);
              HGHandler::TexCoord(v123, 1, 0, 0, 0);
              uint64_t v136 = 32 * v135;
              (*(void (**)(HGHandler *, double, double, double))(*(void *)v123 + 96))(v123, COERCE_FLOAT(*(_OWORD *)(*(void *)(a1 + 504) + v136 + 16)), COERCE_FLOAT(HIDWORD(*(void *)(*(void *)(a1 + 504) + v136 + 16))), 0.0);
              long long v137 = *(_OWORD *)(*(void *)(a1 + 504) + v136);
              uint64_t v86 = a1 + 416;
              (*(void (**)(HGHandler *, double, double, double))(*(void *)v123 + 104))(v123, *(float *)&v137, *((float *)&v137 + 1), 1.0);
              (*(void (**)(HGHandler *, uint64_t))(*(void *)v123 + 120))(v123, v206);
            }
            uint64_t v209 = v89 + v83 + 2;
            float32x4_t v138 = *(_DWORD **)(a2 + 184);
            if (v138)
            {
              int v139 = v88 + 2;
              int v140 = v233;
              if (v230 + (int)v83 + 2 < v233) {
                int v140 = v230 + v83 + 2;
              }
              int v141 = v140 - *(_DWORD *)(a1 + 496);
              int v142 = *(_DWORD *)(a1 + 500);
              if (v141 >= v142) {
                int v143 = v142 - 1;
              }
              else {
                int v143 = v141;
              }
              v199[0] = -v138[5];
              v199[1] = -v138[6];
              (*(void (**)(HGHandler *, void, void, void, void, void, void, void, unsigned int *))(*(void *)v123 + 32))(v123, v138[40], 0, 0, 0, 0, 0, 0, *(unsigned int **)v199);
              HGHandler::TexCoord(v123, 2, 0, 0, 0);
              uint64_t v144 = 32 * v143;
              (*(void (**)(HGHandler *, double, double, double))(*(void *)v123 + 96))(v123, COERCE_FLOAT(*(_OWORD *)(*(void *)(a1 + 504) + v144 + 16)), COERCE_FLOAT(HIDWORD(*(void *)(*(void *)(a1 + 504) + v144 + 16))), 0.0);
              long long v145 = *(_OWORD *)(*(void *)(a1 + 504) + v144);
              uint64_t v86 = a1 + 416;
              (*(void (**)(HGHandler *, double, double, double))(*(void *)v123 + 104))(v123, *(float *)&v145, *((float *)&v145 + 1), 1.0);
              (*(void (**)(HGHandler *, uint64_t))(*(void *)v123 + 120))(v123, v206);
            }
            else
            {
              int v139 = v230 + v83 + 2;
            }
            int v146 = v230 + v83;
            float v147 = (*(float (**)(HGRenderer *, uint64_t, void, void))(*(void *)v13 + 424))(v13, 3, (int)(float)(v84 - (float)(v200 + v83)), v217);
            (*(void (**)(HGHandler *, void, void, void, void, void, void))(*(void *)v123 + 24))(v123, *(void *)(a2 + 16), *(void *)(a2 + 24), *(void *)(a2 + 16), *(void *)(a2 + 24), 0, 0);
            HGHandler::TexCoord(v123, 3, 0, 0, 0);
            (*(void (**)(HGHandler *, uint64_t))(*(void *)v123 + 120))(v123, v86);
            v149.n128_f32[0] = (float)(v230 + v83);
            if (v230 + v83 == v232) {
              v149.n128_f32[0] = -1000.0;
            }
            v148.n128_u32[0] = 1148846080;
            if (v209 < v233) {
              v148.n128_f32[0] = (float)v139;
            }
            if (v146 + 1 < v233) {
              int v150 = v146 + 1;
            }
            else {
              int v150 = v233;
            }
            (*(void (**)(HGHandler *, void, __n128, float, __n128, double))(*(void *)v123 + 136))(v123, 0, v149, (float)v150, v148, 0.0);
            float v151 = (double)v146 + -1.0;
            (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(void *)v123 + 136))(v123, 1, v147, v147, v147, v151);
            (*(void (**)(HGHandler *))(*(void *)v123 + 40))(v123);
            *(void *)&v237.int var0 = v214;
            *(void *)&v237.int var2 = v219;
            HGGPURenderer::Rect(v13, v123, v237, 4);
            (*(void (**)(HGRenderer *, HGHandler *))(*(void *)v13 + 392))(v13, v123);
            uint64_t v89 = v201;
          }
          uint64_t v152 = *(void *)(a2 + 168);
          if (v152) {
            (*(void (**)(uint64_t))(*(void *)v152 + 24))(v152);
          }
          uint64_t v153 = *(void *)(a2 + 176);
          if (v153) {
            (*(void (**)(uint64_t))(*(void *)v153 + 24))(v153);
          }
          uint64_t result = *(void *)(a2 + 184);
          if (result) {
            uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
          }
          v88 += v205;
          v83 += v205;
          v87 += v204;
          int v82 = v233;
        }
        while (v89 + v83 <= v233);
      }
      return result;
    }
    int v78 = v215;
    if ((int)v39 >= 1)
    {
      uint64_t v156 = v54;
      uint64_t result = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
      uint64_t v157 = result;
      uint64_t v54 = v156;
      int v51 = v232;
      goto LABEL_125;
    }
  }
  unsigned int v212 = v72;
  uint64_t v157 = 0;
LABEL_125:
  if (v51 <= v233)
  {
    v46.f32[0] = (float)(int)v54;
    v46.f32[1] = (float)SHIDWORD(v54);
    float32x4_t v224 = v46;
    v46.f32[0] = (float)(int)v44;
    v46.f32[1] = (float)SHIDWORD(v44);
    float32x4_t v222 = v46;
    if (v212) {
      uint64_t v158 = 7;
    }
    else {
      uint64_t v158 = 8;
    }
    float v159 = (float)v78;
    uint64_t v160 = v51;
    int v231 = v51;
    uint64_t v161 = (32 * v51) | 0x10;
    uint64_t v207 = 32 * v158;
    uint64_t v210 = v158;
    uint64_t v162 = a2 + 168;
    do
    {
      uint64_t v163 = 0;
      uint64_t v164 = -128;
      uint64_t v218 = v161;
      uint64_t v165 = v161;
      do
      {
        uint64_t v166 = *(int *)(a1 + 496);
        if (v160 + v163 - v166 >= *(int *)(a1 + 500) || v160 + v163 > v233) {
          break;
        }
        float32x4_t v168 = (float32x4_t *)(*(void *)(a1 + 504) - 32 * v166 + v165);
        float32x4_t v169 = v168[-1];
        unint64_t v170 = vaddq_f32(vmulq_f32(v224, v169), *v168).u64[0];
        unint64_t v171 = vaddq_f32(vmulq_f32(v222, v169), *v168).u64[0];
        uint64_t v172 = HGRectIntegral((uint64_t)v168, *(float *)&v170, *((float *)&v170 + 1), *(float *)&v171, *((float *)&v171 + 1));
        uint64_t v174 = v162 + v164;
        *(void *)(v174 - 4) = HGRectGrow(v172, v173, v157);
        *(void *)(v174 + 4) = v175;
        float32x4_t v176 = HGRenderer::GetInput(v13, (HGNode *)a1, v231 + (int)v163 - *(_DWORD *)(a1 + 496));
        *(void *)(v162 + 8 * v163++) = HGGPURenderer::GetNodeTexture(v13, v176, *(HGRect *)(v162 + v164 - 4), 0, 1u);
        v165 += 32;
        v164 += 16;
      }
      while (v163 != 8);
      (*(void (**)(HGRenderer *, void))(*(void *)v13 + 144))(v13, *(void *)(a2 + 8));
      if ((int)v160 - *(_DWORD *)(a1 + 496) < *(_DWORD *)(a1 + 500) && v160 <= v233)
      {
        (*(void (**)(HGRenderer *, void, void, void, void))(*(void *)v13 + 152))(v13, 0, *(void *)(a2 + 168), 0, 0);
        if ((int)v160 - *(_DWORD *)(a1 + 496) + 1 < *(_DWORD *)(a1 + 500) && v160 < v233)
        {
          (*(void (**)(HGRenderer *, uint64_t, void, void, void))(*(void *)v13 + 152))(v13, 1, *(void *)(a2 + 176), 0, 0);
          if ((int)v160 - *(_DWORD *)(a1 + 496) + 2 < *(_DWORD *)(a1 + 500) && v160 + 2 <= v233)
          {
            (*(void (**)(HGRenderer *, uint64_t, void, void, void))(*(void *)v13 + 152))(v13, 2, *(void *)(a2 + 184), 0, 0);
            if ((int)v160 - *(_DWORD *)(a1 + 496) + 3 < *(_DWORD *)(a1 + 500) && v160 + 3 <= v233)
            {
              (*(void (**)(HGRenderer *, uint64_t, void, void, void))(*(void *)v13 + 152))(v13, 3, *(void *)(a2 + 192), 0, 0);
              if ((int)v160 - *(_DWORD *)(a1 + 496) + 4 < *(_DWORD *)(a1 + 500) && v160 + 4 <= v233)
              {
                (*(void (**)(HGRenderer *, uint64_t, void, void, void))(*(void *)v13 + 152))(v13, 4, *(void *)(a2 + 200), 0, 0);
                if ((int)v160 - *(_DWORD *)(a1 + 496) + 5 < *(_DWORD *)(a1 + 500) && v160 + 5 <= v233)
                {
                  (*(void (**)(HGRenderer *, uint64_t, void, void, void))(*(void *)v13 + 152))(v13, 5, *(void *)(a2 + 208), 0, 0);
                  if ((int)v160 - *(_DWORD *)(a1 + 496) + 6 < *(_DWORD *)(a1 + 500) && v160 + 6 <= v233)
                  {
                    (*(void (**)(HGRenderer *, uint64_t, void, void, void))(*(void *)v13 + 152))(v13, 6, *(void *)(a2 + 216), 0, 0);
                    if ((int)v160 - *(_DWORD *)(a1 + 496) + 7 < *(_DWORD *)(a1 + 500) && v160 + 7 <= v233) {
                      (*(void (**)(HGRenderer *, uint64_t, void, void, void))(*(void *)v13 + 152))(v13, 7, *(void *)(a2 + 224), 0, 0);
                    }
                  }
                }
              }
            }
          }
        }
      }
      uint64_t result = (*(uint64_t (**)(HGRenderer *, void, uint64_t))(*(void *)v13 + 368))(v13, *(void *)(a1 + 64), a1);
      if (result)
      {
        float32x4_t v179 = (HGHandler *)result;
        (*(void (**)(uint64_t, uint64_t, void, void, void, void, void, void, void))(*(void *)result + 32))(result, 3553, 0, 0, 0, 0, 0, 0, 0);
        uint64_t v180 = 0;
        uint64_t v181 = v218;
        do
        {
          if (v231 + (int)v180 - *(_DWORD *)(a1 + 496) >= *(_DWORD *)(a1 + 500) || v160 + v180 > v233) {
            break;
          }
          if (*(void *)(v162 + 8 * v180))
          {
            (*(void (**)(uint64_t, HGHandler *, uint64_t))(*(void *)a1 + 208))(a1, v179, v180);
            (*(void (**)(HGHandler *, uint64_t, void))(*(void *)v179 + 72))(v179, v180, 0);
            (*(void (**)(HGHandler *, void, void))(*(void *)v179 + 48))(v179, v212, v212);
            uint64_t result = *(void *)(v162 + 8 * v180);
            if (!result) {
              return result;
            }
            if (!result) {
              return result;
            }
            uint64_t TextureRect = HGGLTexture::GetTextureRect((HGGLTexture *)result);
            double v184 = 1.0 / (double)(v183 - TextureRect);
            double v186 = 1.0 / (double)(v185 - HIDWORD(TextureRect));
            int32x4_t v187 = (_OWORD *)(*(void *)(a1 + 504) - 32 * *(int *)(a1 + 496) + v181);
            double v188 = v184 * (float)(COERCE_FLOAT(*v187) - (float)(int)TextureRect);
            double v189 = v186 * (float)(COERCE_FLOAT(HIDWORD(*(void *)v187)) - (float)SHIDWORD(TextureRect));
            *(float *)&double v184 = v184 * COERCE_FLOAT(*(v187 - 1));
            *(float *)&double v186 = v186 * COERCE_FLOAT(HIDWORD(*((void *)v187 - 2)));
            float v190 = v188;
            float v191 = v189;
            (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(void *)v179 + 136))(v179, v180, *(float *)&v184, *(float *)&v186, v190, v191);
          }
          ++v180;
          v181 += 32;
        }
        while (v180 != 8);
        (*(void (**)(HGHandler *, void, void, void, void, void, void))(*(void *)v179 + 24))(v179, 0, 0, 0, 0, 0, 0);
        (*(void (**)(uint64_t, HGHandler *))(*(void *)a1 + 200))(a1, v179);
        (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(void *)v179 + 136))(v179, 8, (float)v232, (float)v233, (float)(int)v160, (float)(v160 + 7));
        (*(void (**)(HGHandler *, uint64_t, float, float, float, float))(*(void *)v179 + 136))(v179, 9, *(float *)(*(void *)(a1 + 480) + 424), 0.000001, *(float *)(*(void *)(a1 + 480) + 424), v159);
        (*(void (**)(HGHandler *))(*(void *)v179 + 40))(v179);
        *(void *)&v238.int var0 = v214;
        *(void *)&v238.int var2 = v219;
        HGGPURenderer::Rect(v13, v179, v238, 1);
        uint64_t result = (*(uint64_t (**)(HGRenderer *, HGHandler *))(*(void *)v13 + 392))(v13, v179);
        int v193 = *(_DWORD *)(a1 + 496);
        int v194 = *(_DWORD *)(a1 + 500);
        if ((int)v160 - v193 < v194)
        {
          uint64_t v195 = v233;
          if (v160 <= v233)
          {
            uint64_t result = *(void *)(a2 + 168);
            if (result)
            {
              uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
              int v193 = *(_DWORD *)(a1 + 496);
              int v194 = *(_DWORD *)(a1 + 500);
              uint64_t v195 = v233;
            }
            if ((int)v160 - v193 + 1 < v194 && v160 < v195)
            {
              uint64_t result = *(void *)(a2 + 176);
              if (result)
              {
                uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
                int v193 = *(_DWORD *)(a1 + 496);
                int v194 = *(_DWORD *)(a1 + 500);
                uint64_t v195 = v233;
              }
              if ((int)v160 - v193 + 2 < v194 && v160 + 2 <= v195)
              {
                uint64_t result = *(void *)(a2 + 184);
                if (result)
                {
                  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
                  int v193 = *(_DWORD *)(a1 + 496);
                  int v194 = *(_DWORD *)(a1 + 500);
                  uint64_t v195 = v233;
                }
                if ((int)v160 - v193 + 3 < v194 && v160 + 3 <= v195)
                {
                  uint64_t result = *(void *)(a2 + 192);
                  if (result)
                  {
                    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
                    int v193 = *(_DWORD *)(a1 + 496);
                    int v194 = *(_DWORD *)(a1 + 500);
                    uint64_t v195 = v233;
                  }
                  if ((int)v160 - v193 + 4 < v194 && v160 + 4 <= v195)
                  {
                    uint64_t result = *(void *)(a2 + 200);
                    if (result)
                    {
                      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
                      int v193 = *(_DWORD *)(a1 + 496);
                      int v194 = *(_DWORD *)(a1 + 500);
                      uint64_t v195 = v233;
                    }
                    if ((int)v160 - v193 + 5 < v194 && v160 + 5 <= v195)
                    {
                      uint64_t result = *(void *)(a2 + 208);
                      if (result)
                      {
                        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
                        int v193 = *(_DWORD *)(a1 + 496);
                        int v194 = *(_DWORD *)(a1 + 500);
                        uint64_t v195 = v233;
                      }
                      if ((int)v160 - v193 + 6 < v194 && v160 + 6 <= v195)
                      {
                        uint64_t result = *(void *)(a2 + 216);
                        if (result)
                        {
                          uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
                          int v193 = *(_DWORD *)(a1 + 496);
                          int v194 = *(_DWORD *)(a1 + 500);
                          uint64_t v195 = v233;
                        }
                        if ((int)v160 - v193 + 7 < v194 && v160 + 7 <= v195)
                        {
                          uint64_t result = *(void *)(a2 + 224);
                          if (result) {
                            uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      v160 += v210;
      v231 += v210;
      uint64_t v161 = v218 + v207;
    }
    while (v160 <= v233);
  }
  return result;
}

uint64_t HGAnisotropicSampler::GetPageMetal(uint64_t a1, HGBitmap **a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8, double a9, double a10, double a11, double a12, int a13)
{
  uint64_t v156 = *MEMORY[0x1E4F143B8];
  double v19 = *a2;
  uint64_t v20 = *(void *)(a1 + 480);
  int v21 = *(_DWORD *)(v20 + 436);
  uint64_t v22 = *(HGTransform **)(v20 + 448);
  int v140 = v21;
  if (v21 < 2)
  {
    HGRect v41 = *(HGRect *)(v20 + 464);
    uint64_t v32 = a7;
    if ((int)a7 <= 0) {
      float v42 = 0.5;
    }
    else {
      float v42 = 1.5;
    }
    float v43 = *(float *)(v20 + 424);
    double v44 = (double)v21;
    int v45 = *(_DWORD *)(v20 + 480);
    int v46 = *(_DWORD *)(v20 + 484);
    if (v19)
    {
      uint64_t v144 = *(void *)(v20 + 472);
      float v147 = *(HGTransform **)(v20 + 464);
      int v47 = *(HGTransform **)(v20 + 448);
      if (v48) {
        unsigned int MaxTileArea = HGGPURenderer::GetMaxTileArea(v48);
      }
      else {
        unsigned int MaxTileArea = 0x1000000;
      }
      uint64_t v22 = v47;
      *(void *)&v41.int var2 = v144;
      *(void *)&v41.int var0 = v147;
    }
    else
    {
      unsigned int MaxTileArea = 0x1000000;
    }
    unint64_t v39 = a3;
    *(void *)&v158.int var0 = a3;
    *(void *)&v158.int var2 = a4;
    *(float *)&a9 = v42;
    uint64_t v50 = hg_clip(v22, v158, v41, a9, v43, v44, a12, &v154, v45, v46, MaxTileArea);
  }
  else
  {
    int v146 = *(HGTransform **)(v20 + 448);
    uint64_t v23 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    uint64_t v24 = HGRectGrow(a3, a4, v23);
    uint64_t v27 = v24;
    uint64_t v29 = v28;
    uint64_t v30 = *(void *)(a1 + 480);
    HGRect v31 = *(HGRect *)(v30 + 464);
    uint64_t v32 = a7;
    if ((int)a7 <= 0) {
      float v33 = 0.5;
    }
    else {
      float v33 = 1.5;
    }
    float v34 = *(float *)(v30 + 424);
    double v35 = (double)v21;
    int v36 = *(_DWORD *)(v30 + 480);
    int v37 = *(_DWORD *)(v30 + 484);
    if (v19)
    {
      uint64_t v138 = *(void *)(v30 + 472);
      uint64_t v142 = *(void *)(v30 + 464);
      uint64_t v143 = v24;
      unint64_t v39 = a3;
      if (v38) {
        unsigned int v40 = HGGPURenderer::GetMaxTileArea(v38);
      }
      else {
        unsigned int v40 = 0x1000000;
      }
      *(void *)&v31.int var0 = v142;
      uint64_t v27 = v143;
      *(void *)&v31.int var2 = v138;
    }
    else
    {
      unint64_t v39 = a3;
      unsigned int v40 = 0x1000000;
    }
    *(void *)&v157.int var0 = v27;
    *(void *)&v157.int var2 = v29;
    *(float *)&double v25 = v33;
    uint64_t v50 = hg_clip(v146, v157, v31, v25, v34, v35, v26, &v154, v36, v37, v40);
  }
  uint64_t v52 = v50;
  uint64_t v53 = v51;
  if (HGRectIsNull(v50, v51))
  {
    *(void *)&v161.int var0 = v39;
    *(void *)&v161.int var2 = a4;
    return (uint64_t)HGGPURenderer::ClearMetal((HGGPURenderer *)v19, a2[1], v161, v54);
  }
  uint64_t result = v39;
  unint64_t v57 = HIDWORD(v39);
  unint64_t v58 = a4;
  unint64_t v59 = HIDWORD(a4);
  int v60 = v154;
  double v61 = (double)a8;
  double v62 = fmax(((double)(int)v53 - (double)(int)v52) * (1.0 / (double)(1 << v60)) / (double)a8, ((double)SHIDWORD(v53) - (double)SHIDWORD(v52)) * (1.0 / (double)(1 << v60)) / (double)a8);
  if (a4 - v39 == 1 && HIDWORD(a4) - HIDWORD(v39) == 1 && v62 > 1.0)
  {
    unint64_t v135 = v39;
    uint64_t v63 = *(void *)(a1 + 480);
    unsigned int v64 = *(HGTransform **)(v63 + 448);
    uint64_t v65 = *(void *)(v63 + 464);
    uint64_t v66 = *(void *)(v63 + 472);
    if ((int)v32 <= 0) {
      float v67 = 0.5;
    }
    else {
      float v67 = 1.5;
    }
    float v68 = *(float *)(v63 + 424);
    int v69 = *(_DWORD *)(v63 + 480);
    int v70 = *(_DWORD *)(v63 + 484);
    if (v19
    {
      unsigned int v72 = HGGPURenderer::GetMaxTileArea(v71);
      unint64_t v58 = a4;
    }
    else
    {
      unsigned int v72 = 0x1000000;
    }
    *(void *)&v159.int var0 = v135;
    *(void *)&v159.int var2 = v58;
    *(void *)&v163.int var0 = v65;
    *(void *)&v163.int var2 = v66;
    *(float *)&double v62 = v67;
    uint64_t v52 = hg_clip(v64, v159, v163, v62, v68, 1.0, v61, &v154, v69, v70, v72);
    uint64_t v53 = v87;
    uint64_t result = HGRectIsNull(v52, v87);
    if (result)
    {
      *(void *)&v162.int var0 = v135;
      *(void *)&v162.int var2 = a4;
      return (uint64_t)HGGPURenderer::ClearMetal((HGGPURenderer *)v19, a2[1], v162, v88);
    }
    unsigned int v137 = 0;
    int v60 = v155;
    int v154 = v155;
    int v86 = 1;
  }
  else
  {
    if (v62 > 2.0)
    {
      if (SHIDWORD(a4) > SHIDWORD(v39) && (int)a4 > (int)v39)
      {
        uint64_t v73 = (uint64_t)rint(fmax(sqrt(((double)(int)a4 - (double)(int)v39) * ((double)SHIDWORD(a4) - (double)SHIDWORD(v39)) / v62), 1.0));
        do
        {
          int v74 = v57 + v73;
          if ((int)v57 + (int)v73 >= (int)v59) {
            unsigned int v75 = v59;
          }
          else {
            unsigned int v75 = v57 + v73;
          }
          LODWORD(result) = v39;
          int v76 = a4;
          do
          {
            uint64_t v77 = (result + v73);
            if ((int)v77 >= v76) {
              unsigned int v78 = v76;
            }
            else {
              unsigned int v78 = result + v73;
            }
            uint64_t v79 = HGRectMake4i(result, v57, v78, v75);
            HGAnisotropicSampler::GetPageMetal(a1, a2, v79, v80, a5, a6, v32, a8, a13 + 1);
            uint64_t result = v77;
            int v76 = a4;
          }
          while ((int)v77 < (int)a4);
          LODWORD(v57) = v57 + v73;
          LODWORD(v59) = HIDWORD(a4);
        }
        while (v74 < SHIDWORD(a4));
      }
      return result;
    }
    if (v62 > 1.0)
    {
      int v81 = a13 + 1;
      if (HIDWORD(a4) - HIDWORD(v39) <= (a4 - v39))
      {
        uint64_t v89 = HGRectMake4i(v39, HIDWORD(v39), ((int)v39 + (int)a4) >> 1, HIDWORD(a4));
        HGAnisotropicSampler::GetPageMetal(a1, a2, v89, v90, a5, a6, v32, a8, v81);
        uint64_t v84 = HGRectMake4i(((int)v39 + (int)a4) >> 1, HIDWORD(v39), a4, HIDWORD(a4));
      }
      else
      {
        uint64_t v82 = HGRectMake4i(v39, HIDWORD(v39), a4, (HIDWORD(v39) + HIDWORD(a4)) >> 1);
        HGAnisotropicSampler::GetPageMetal(a1, a2, v82, v83, a5, a6, v32, a8, v81);
        uint64_t v84 = HGRectMake4i(v39, (HIDWORD(v39) + HIDWORD(a4)) >> 1, a4, HIDWORD(a4));
      }
      return HGAnisotropicSampler::GetPageMetal(a1, a2, v84, v85, a5, a6, v32, a8, v81);
    }
    unint64_t v135 = v39;
    unsigned int v137 = v32;
    if ((int)v32 >= 1)
    {
      uint64_t result = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
      uint64_t v145 = result;
      int v60 = v154;
      int v86 = v140;
      if (v154 <= v155) {
        goto LABEL_62;
      }
      return result;
    }
    int v86 = v140;
  }
  uint64_t v145 = 0;
  if (v60 <= v155)
  {
LABEL_62:
    if (v137) {
      uint64_t v91 = 7;
    }
    else {
      uint64_t v91 = 8;
    }
    v55.f32[0] = (float)(int)v52;
    v55.f32[1] = (float)SHIDWORD(v52);
    float32x4_t v141 = v55;
    v55.f32[0] = (float)(int)v53;
    v55.f32[1] = (float)SHIDWORD(v53);
    float32x4_t v139 = v55;
    float v92 = (float)v86;
    uint64_t v93 = (HGTransform *)v60;
    uint64_t v94 = a2 + 21;
    int v151 = v60;
    uint64_t v95 = (32 * v60) | 0x10;
    uint64_t v133 = 32 * v91;
    uint64_t v134 = v91;
    int v132 = (uint64_t *)(a2 + 28);
    while (1)
    {
      uint64_t v96 = 0;
      uint64_t v97 = 0x1FFFFFFFFFFFFFF0;
      uint64_t v136 = v95;
      __n128 v148 = v93;
      do
      {
        uint64_t v98 = *(int *)(a1 + 496);
        if ((uint64_t)v93 + v96 - v98 >= *(int *)(a1 + 500) || (uint64_t)v93 + v96 > v155) {
          break;
        }
        uint64_t v100 = (float32x4_t *)(*(void *)(a1 + 504) - 32 * v98 + v95);
        float32x4_t v101 = v100[-1];
        unint64_t v102 = vaddq_f32(vmulq_f32(v141, v101), *v100).u64[0];
        unint64_t v103 = vaddq_f32(vmulq_f32(v139, v101), *v100).u64[0];
        uint64_t v104 = HGRectIntegral((uint64_t)v100, *(float *)&v102, *((float *)&v102 + 1), *(float *)&v103, *((float *)&v103 + 1));
        *(HGBitmap **)((char *)&v94[v97 - 1] + 4) = (HGBitmap *)HGRectGrow(v104, v105, v145);
        *(HGBitmap **)((char *)&v94[v97] + 4) = v106;
        Input = HGRenderer::GetInput((HGRenderer *)v19, (HGNode *)a1, v151 + (int)v96 - *(_DWORD *)(a1 + 496));
        NodeBitmap = HGGPURenderer::GetNodeBitmap((HGGPURenderer *)v19, Input, *(HGRect *)((char *)&v94[v97 - 1] + 4), 0, 1u);
        double v109 = HGGPURenderer::ConvertToNonGLTexture((HGGPURenderer *)v19, NodeBitmap);
        uint64_t v110 = (HGTexture *)HGObject::operator new(0x80uLL);
        *(void *)&v160.int var0 = *(void *)((char *)v109 + 20);
        *(void *)&v160.int var2 = *(void *)((char *)v109 + 28);
        HGTexture::HGTexture(v110, v160, v109);
        v94[v96] = (HGBitmap *)v110;
        (*(void (**)(HGBitmap *))(*(void *)v109 + 24))(v109);
        (*(void (**)(HGBitmap *))(*(void *)NodeBitmap + 24))(NodeBitmap);
        ++v96;
        v95 += 32;
        v97 += 2;
        uint64_t v93 = v148;
      }
      while (v96 != 8);
      uint64_t result = (*(uint64_t (**)(HGBitmap *, void, uint64_t))(*(void *)*a2 + 368))(*a2, *(void *)(a1 + 64), a1);
      uint64_t v111 = v148;
      if (result)
      {
        if (result) {
          break;
        }
      }
LABEL_66:
      uint64_t v93 = (HGTransform *)((char *)v111 + v134);
      v151 += v134;
      uint64_t v95 = v136 + v133;
      if ((uint64_t)v93 > v155) {
        return result;
      }
    }
    uint64_t v112 = (std::string *)result;
    uint64_t v113 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 48))(a1);
    size_t v114 = strlen(v113);
    if (v114 >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string::size_type v115 = v114;
    if (v114 >= 0x17)
    {
      uint64_t v117 = (v114 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v114 | 7) != 0x17) {
        uint64_t v117 = v114 | 7;
      }
      uint64_t v118 = v117 + 1;
      p_dst = (std::string *)operator new(v117 + 1);
      __dst.__r_.__value_.__l.__size_ = v115;
      __dst.__r_.__value_.__r.__words[2] = v118 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v114;
      p_dst = &__dst;
      if (!v114) {
        goto LABEL_84;
      }
    }
    memmove(p_dst, v113, v115);
LABEL_84:
    p_dst->__r_.__value_.__s.__data_[v115] = 0;
    HGMetalHandler::SetDebugLabel(v112, &__dst);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    HGMetalHandler::BindBuffer((HGMetalHandler *)v112, a2[1]);
    unsigned int v119 = 0;
    if ((int)v148 - *(_DWORD *)(a1 + 496) < *(_DWORD *)(a1 + 500) && (uint64_t)v148 <= v155)
    {
      HGMetalHandler::BindTexture((HGMetalTexture ***)v112, 0, a2[21]);
      unsigned int v119 = 1;
      if ((int)v148 - *(_DWORD *)(a1 + 496) + 1 < *(_DWORD *)(a1 + 500) && (uint64_t)v148 < v155)
      {
        HGMetalHandler::BindTexture((HGMetalTexture ***)v112, 1, a2[22]);
        unsigned int v119 = 2;
        if ((int)v148 - *(_DWORD *)(a1 + 496) + 2 < *(_DWORD *)(a1 + 500) && (uint64_t)v148 + 2 <= v155)
        {
          HGMetalHandler::BindTexture((HGMetalTexture ***)v112, 2, a2[23]);
          unsigned int v119 = 3;
          if ((int)v148 - *(_DWORD *)(a1 + 496) + 3 < *(_DWORD *)(a1 + 500) && (uint64_t)v148 + 3 <= v155)
          {
            HGMetalHandler::BindTexture((HGMetalTexture ***)v112, 3, a2[24]);
            unsigned int v119 = 4;
            if ((int)v148 - *(_DWORD *)(a1 + 496) + 4 < *(_DWORD *)(a1 + 500) && (uint64_t)v148 + 4 <= v155)
            {
              HGMetalHandler::BindTexture((HGMetalTexture ***)v112, 4, a2[25]);
              unsigned int v119 = 5;
              if ((int)v148 - *(_DWORD *)(a1 + 496) + 5 < *(_DWORD *)(a1 + 500) && (uint64_t)v148 + 5 <= v155)
              {
                HGMetalHandler::BindTexture((HGMetalTexture ***)v112, 5, a2[26]);
                unsigned int v119 = 6;
                if ((int)v148 - *(_DWORD *)(a1 + 496) + 6 < *(_DWORD *)(a1 + 500) && (uint64_t)v148 + 6 <= v155)
                {
                  HGMetalHandler::BindTexture((HGMetalTexture ***)v112, 6, a2[27]);
                  unsigned int v119 = 7;
                  if ((int)v148 - *(_DWORD *)(a1 + 496) + 7 < *(_DWORD *)(a1 + 500))
                  {
                    long long v120 = a2 + 28;
                    if ((uint64_t)v148 + 7 <= v155) {
                      goto LABEL_109;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    uint64_t v121 = &a2[v119];
    uint64_t v122 = v121[20];
    long long v120 = v121 + 20;
    __n128 v123 = HGMetalHandler::BindTexture((HGMetalTexture ***)v112, v119, v122);
    if (v119 != 7)
    {
      __n128 v123 = HGMetalHandler::BindTexture((HGMetalTexture ***)v112, v119 + 1, *v120);
      if (v119 != 6)
      {
        __n128 v123 = HGMetalHandler::BindTexture((HGMetalTexture ***)v112, v119 + 2, *v120);
        if (v119 != 5)
        {
          __n128 v123 = HGMetalHandler::BindTexture((HGMetalTexture ***)v112, v119 + 3, *v120);
          if (v119 != 4)
          {
            __n128 v123 = HGMetalHandler::BindTexture((HGMetalTexture ***)v112, v119 + 4, *v120);
            if (v119 != 3)
            {
              __n128 v123 = HGMetalHandler::BindTexture((HGMetalTexture ***)v112, v119 + 5, *v120);
              if (v119 != 2)
              {
                __n128 v123 = HGMetalHandler::BindTexture((HGMetalTexture ***)v112, v119 + 6, *v120);
                v119 += 7;
                if (v119 != 8) {
LABEL_109:
                }
                  __n128 v123 = HGMetalHandler::BindTexture((HGMetalTexture ***)v112, v119, *v120);
              }
            }
          }
        }
      }
    }
    (*(void (**)(std::string *, uint64_t, void, void, void, void, void, void, __n128, void))(v112->__r_.__value_.__r.__words[0] + 32))(v112, 3553, 0, 0, 0, 0, 0, 0, v123, 0);
    uint64_t v124 = 0;
    uint64_t v125 = v136;
    int v126 = v148;
    do
    {
      if (v151 + (int)v124 - *(_DWORD *)(a1 + 496) >= *(_DWORD *)(a1 + 500) || (uint64_t)v126 + v124 > v155) {
        break;
      }
      if (v94[v124])
      {
        (*(void (**)(uint64_t, std::string *, uint64_t))(*(void *)a1 + 208))(a1, v112, v124);
        (*(void (**)(std::string *, uint64_t, void))(v112->__r_.__value_.__r.__words[0] + 72))(v112, v124, 0);
        (*(void (**)(std::string *, void, void))(v112->__r_.__value_.__r.__words[0] + 48))(v112, v137, v137);
        int v128 = (__n128 *)(*(void *)(a1 + 504) - 32 * *(int *)(a1 + 496) + v125);
        (*(void (**)(std::string *, uint64_t, __n128, float, float, float))(v112->__r_.__value_.__r.__words[0]
                                                                                    + 136))(v112, v124, v128[-1], COERCE_FLOAT(HIDWORD(v128[-1].n128_u64[0])), COERCE_FLOAT(*v128) - (float)*((int *)v94[v124] + 5), COERCE_FLOAT(HIDWORD(v128->n128_u64[0])) - (float)*((int *)v94[v124] + 6));
        int v126 = v148;
      }
      ++v124;
      v125 += 32;
    }
    while (v124 != 8);
    (*(void (**)(std::string *, void, void, void, void, void, void))(v112->__r_.__value_.__r.__words[0]
                                                                                          + 24))(v112, 0, 0, 0, 0, 0, 0);
    (*(void (**)(uint64_t, std::string *))(*(void *)a1 + 200))(a1, v112);
    (*(void (**)(std::string *, uint64_t, float, float, float, float))(v112->__r_.__value_.__r.__words[0] + 136))(v112, 8, (float)v154, (float)v155, (float)(int)v148, (float)((int)v148 + 7));
    (*(void (**)(std::string *, uint64_t, float, float, float, float))(v112->__r_.__value_.__r.__words[0] + 136))(v112, 9, *(float *)(*(void *)(a1 + 480) + 424), 0.000001, *(float *)(*(void *)(a1 + 480) + 424), v92);
    (*(void (**)(std::string *))(v112->__r_.__value_.__r.__words[0] + 40))(v112);
    (*(void (**)(std::string *, unint64_t, unint64_t, uint64_t))(v112->__r_.__value_.__r.__words[0]
                                                                                       + 192))(v112, v135, a4, 1);
    uint64_t result = (*(uint64_t (**)(HGBitmap *, std::string *))(*(void *)v19 + 392))(v19, v112);
    int v129 = *(_DWORD *)(a1 + 496);
    uint64_t v111 = v148;
    int v130 = *(_DWORD *)(a1 + 500);
    if ((int)v148 - v129 < v130)
    {
      uint64_t v131 = v155;
      if ((uint64_t)v148 <= v155)
      {
        uint64_t result = (uint64_t)a2[21];
        if (result)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
          int v129 = *(_DWORD *)(a1 + 496);
          int v130 = *(_DWORD *)(a1 + 500);
          uint64_t v131 = v155;
          uint64_t v111 = v148;
        }
        if ((int)v111 - v129 + 1 < v130 && (uint64_t)v111 < v131)
        {
          uint64_t result = (uint64_t)a2[22];
          if (result)
          {
            uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
            int v129 = *(_DWORD *)(a1 + 496);
            int v130 = *(_DWORD *)(a1 + 500);
            uint64_t v131 = v155;
            uint64_t v111 = v148;
          }
          if ((int)v111 - v129 + 2 < v130 && (uint64_t)v111 + 2 <= v131)
          {
            uint64_t result = (uint64_t)a2[23];
            if (result)
            {
              uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
              int v129 = *(_DWORD *)(a1 + 496);
              int v130 = *(_DWORD *)(a1 + 500);
              uint64_t v131 = v155;
              uint64_t v111 = v148;
            }
            if ((int)v111 - v129 + 3 < v130 && (uint64_t)v111 + 3 <= v131)
            {
              uint64_t result = (uint64_t)a2[24];
              if (result)
              {
                uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
                int v129 = *(_DWORD *)(a1 + 496);
                int v130 = *(_DWORD *)(a1 + 500);
                uint64_t v131 = v155;
                uint64_t v111 = v148;
              }
              if ((int)v111 - v129 + 4 < v130 && (uint64_t)v111 + 4 <= v131)
              {
                uint64_t result = (uint64_t)a2[25];
                if (result)
                {
                  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
                  int v129 = *(_DWORD *)(a1 + 496);
                  int v130 = *(_DWORD *)(a1 + 500);
                  uint64_t v131 = v155;
                  uint64_t v111 = v148;
                }
                if ((int)v111 - v129 + 5 < v130 && (uint64_t)v111 + 5 <= v131)
                {
                  uint64_t result = (uint64_t)a2[26];
                  if (result)
                  {
                    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
                    int v129 = *(_DWORD *)(a1 + 496);
                    int v130 = *(_DWORD *)(a1 + 500);
                    uint64_t v131 = v155;
                    uint64_t v111 = v148;
                  }
                  if ((int)v111 - v129 + 6 < v130 && (uint64_t)v111 + 6 <= v131)
                  {
                    uint64_t result = (uint64_t)a2[27];
                    if (result)
                    {
                      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
                      int v129 = *(_DWORD *)(a1 + 496);
                      int v130 = *(_DWORD *)(a1 + 500);
                      uint64_t v131 = v155;
                      uint64_t v111 = v148;
                    }
                    if ((int)v111 - v129 + 7 < v130 && (uint64_t)v148 + 7 <= v131)
                    {
                      uint64_t result = *v132;
                      if (*v132)
                      {
                        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
                        uint64_t v111 = v148;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    goto LABEL_66;
  }
  return result;
}

void sub_1B77EC9A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a32 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

HGRenderer *HGAnisotropicSampler::RenderPage(HGAnisotropicSampler *this, HGRenderer **a2)
{
  return HGAnisotropicSampler::RenderPageGeneric((uint64_t)this, a2, 0);
}

HGRenderer *HGAnisotropicSampler::RenderPageMetal(HGAnisotropicSampler *this, HGRenderer **a2)
{
  return HGAnisotropicSampler::RenderPageGeneric((uint64_t)this, a2, 1);
}

uint64_t HGAnisotropicSampler::RenderTile(HGAnisotropicSampler *this, HGTile *a2)
{
  uint64_t v4 = HGTile::Renderer(a2);
  int v5 = (*(uint64_t (**)(HGAnisotropicSampler *, uint64_t))(*(void *)this + 312))(this, v4);
  uint64_t v6 = *((void *)a2 + 42);
  unint64_t v7 = (*((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1)) * *((_DWORD *)a2 + 6);
  Stacuint64_t k = HGExecutionUnit::GetStack((char ****)v6, v7);
  uint64_t v9 = (float32x4_t *)*((void *)a2 + 2);
  if (Stack == (char *)v9)
  {
    HGExecutionUnit::CommitStack(v6, (uint64_t)Stack, v7);
    uint64_t v9 = (float32x4_t *)*((void *)a2 + 2);
  }
  unint64_t v10 = *(void *)a2;
  unint64_t v11 = *((void *)a2 + 1);
  uint64_t v12 = *((unsigned int *)a2 + 6);
  unsigned int v13 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v6 + 152) + 128))(*(void *)(v6 + 152), 3);
  HGAnisotropicSampler::GetTile((uint64_t)this, (uint64_t)a2, v10, v11, v9, v12, v5, v13, 0);
  return 0;
}

void HGAnisotropicSampler::GetTile(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, float32x4_t *a5, uint64_t a6, int a7, unsigned int a8, int a9)
{
  v649[1] = *MEMORY[0x1E4F143B8];
  unint64_t v591 = HIDWORD(a3);
  unint64_t v597 = HIDWORD(a4);
  int v15 = HIDWORD(a4) - HIDWORD(a3);
  uint64_t v16 = *(void *)(a1 + 480);
  int v17 = *(_DWORD *)(v16 + 436);
  __n128 v635 = *(HGExecutionUnit **)(a2 + 336);
  int v18 = (void *)*((void *)v635 + 19);
  __n128 v614 = *(HGTransform **)(v16 + 448);
  uint64_t v19 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
  uint64_t v622 = a3;
  uint64_t v20 = HGRectGrow(a3, a4, v19);
  uint64_t v24 = v23;
  uint64_t v25 = *(void *)(a1 + 480);
  HGRect v26 = *(HGRect *)(v25 + 464);
  unsigned int v603 = a7;
  if (a7 <= 0) {
    float v27 = 0.5;
  }
  else {
    float v27 = 1.5;
  }
  float v28 = *(float *)(v25 + 424);
  int v586 = v17;
  double v29 = (double)v17;
  int v30 = *(_DWORD *)(v25 + 480);
  int v31 = *(_DWORD *)(v25 + 484);
  lpsrc = v18;
  if (v18)
  {
    uint64_t v32 = v18;
    uint64_t v609 = *(void *)(v25 + 472);
    uint64_t v33 = *(void *)(v25 + 464);
    uint64_t v34 = v20;
    if (v35) {
      unsigned int MaxTileArea = HGGPURenderer::GetMaxTileArea(v35);
    }
    else {
      unsigned int MaxTileArea = 0x1000000;
    }
    uint64_t v20 = v34;
    *(void *)&v26.int var0 = v33;
    *(void *)&v26.int var2 = v609;
  }
  else
  {
    unsigned int MaxTileArea = 0x1000000;
  }
  uint64_t v606 = a4;
  uint64_t v37 = (a4 - v622);
  *(void *)&v650.int var0 = v20;
  *(void *)&v650.int var2 = v24;
  *(float *)&double v21 = v27;
  unint64_t v38 = hg_clip(v614, v650, v26, v21, v28, v29, v22, (int *)v649, v30, v31, MaxTileArea);
  uint64_t v40 = v39;
  if (!HGRectIsNull(v38, v39))
  {
    uint64_t v41 = v40;
    unint64_t v42 = HIDWORD(v38);
    int v43 = v649[0];
    unint64_t v615 = v41;
    double v44 = (double)SHIDWORD(v38);
    double v45 = ((double)(int)v41 - (double)(int)v38)
        * (1.0
         / (double)(1 << v43))
        * (((double)SHIDWORD(v41) - (double)SHIDWORD(v38))
         * (1.0
          / (double)(1 << v43)))
        / (double)a8;
    unsigned int v46 = v603;
    if (v37 == 1 && v15 == 1 && (double v47 = 1.0, v45 > 1.0))
    {
      uint64_t v48 = *(void *)(a1 + 480);
      unint64_t v49 = *(HGTransform **)(v48 + 448);
      uint64_t v50 = *(void *)(v48 + 464);
      uint64_t v51 = *(void *)(v48 + 472);
      float v52 = *(float *)(v48 + 424);
      int v53 = *(_DWORD *)(v48 + 480);
      int v54 = *(_DWORD *)(v48 + 484);
      if (lpsrc
      {
        unsigned int v56 = HGGPURenderer::GetMaxTileArea(v55);
      }
      else
      {
        unsigned int v56 = 0x1000000;
      }
      *(void *)&v651.int var0 = v622;
      *(void *)&v651.int var2 = v606;
      *(void *)&v652.int var0 = v50;
      *(void *)&v652.int var2 = v51;
      *(float *)&double v47 = v27;
      unint64_t v78 = hg_clip(v49, v651, v652, v47, v52, 1.0, v44, (int *)v649, v53, v54, v56);
      uint64_t v80 = v79;
      if (HGRectIsNull(v78, v79)) {
        goto LABEL_13;
      }
      unint64_t v615 = v80;
      unsigned int v46 = 0;
      int v43 = HIDWORD(v649[0]);
      LODWORD(v649[0]) = HIDWORD(v649[0]);
      v75.f32[0] = (float)(int)v622 + 0.5;
      v75.f32[1] = (float)(int)v591 + 0.5;
      v75.i32[2] = 0;
      v75.i32[3] = 1.0;
      int v77 = 1;
      int v598 = v78;
      unint64_t v42 = HIDWORD(v78);
    }
    else
    {
      if (v45 > 2.0)
      {
        uint64_t v648 = 0;
        long long v646 = 0u;
        long long v647 = 0u;
        HGExecutionUnit::GetStackState((uint64_t)v635, (uint64_t)&v646);
        if ((int)v597 > (int)v591 && (int)v606 > (int)v622)
        {
          uint64_t v57 = (uint64_t)rint(fmax(sqrt(((double)(int)v606 - (double)(int)v622) * ((double)(int)v597 - (double)(int)v591) / v45), 1.0));
          uint64_t v577 = (int)v622;
          uint64_t v58 = v622 >> 32;
          do
          {
            unsigned int v623 = v58;
            uint64_t v59 = v58 + (int)v57;
            uint64_t v587 = v59;
            if ((int)v59 >= (int)v597) {
              unsigned int v60 = v597;
            }
            else {
              unsigned int v60 = v59;
            }
            unsigned int v616 = v60;
            long long v592 = a5;
            double v61 = a5;
            uint64_t v62 = v577;
            do
            {
              uint64_t v63 = v62 + (int)v57;
              if ((int)v57 + (int)v62 >= (int)v606) {
                unsigned int v64 = v606;
              }
              else {
                unsigned int v64 = v57 + v62;
              }
              uint64_t v65 = HGRectMake4i(v62, v623, v64, v616);
              HGAnisotropicSampler::GetTile(a1, a2, v65, v66, v61, a6, v603, a8, a9 + 1);
              v644[0] = v646;
              v644[1] = v647;
              uint64_t v645 = v648;
              HGExecutionUnit::SetStackState((uint64_t)v635, v644);
              v61 += (int)v57;
              uint64_t v62 = v63;
            }
            while (v63 < (int)v606);
            a5 = &v592[(int)v57 * (uint64_t)(int)a6];
            uint64_t v58 = v587;
          }
          while (v587 < v606 >> 32);
        }
        return;
      }
      if (v45 > 1.0)
      {
        int v67 = a9 + 1;
        int v617 = a9 + 1;
        if (v15 <= v37)
        {
          unsigned int v81 = ((int)v622 + (int)v606) >> 1;
          uint64_t v648 = 0;
          long long v646 = 0u;
          long long v647 = 0u;
          uint64_t v69 = (uint64_t)v635;
          HGExecutionUnit::GetStackState((uint64_t)v635, (uint64_t)&v646);
          uint64_t v82 = HGRectMake4i(v622, v591, v81, v597);
          HGAnisotropicSampler::GetTile(a1, a2, v82, v83, a5, a6, v603, a8, v67);
          v638[0] = v646;
          v638[1] = v647;
          uint64_t v639 = v648;
          HGExecutionUnit::SetStackState((uint64_t)v635, v638);
          uint64_t v84 = HGRectMake4i(v81, v591, v606, v597);
          HGAnisotropicSampler::GetTile(a1, a2, v84, v85, &a5[(int)(v81 - v622)], a6, v603, a8, v617);
          v636[0] = v646;
          v636[1] = v647;
          uint64_t v637 = v648;
          int v74 = v636;
        }
        else
        {
          unsigned int v68 = ((int)v591 + (int)v597) >> 1;
          uint64_t v648 = 0;
          long long v646 = 0u;
          long long v647 = 0u;
          uint64_t v69 = (uint64_t)v635;
          HGExecutionUnit::GetStackState((uint64_t)v635, (uint64_t)&v646);
          uint64_t v70 = HGRectMake4i(v622, v591, v606, v68);
          HGAnisotropicSampler::GetTile(a1, a2, v70, v71, a5, a6, v603, a8, v67);
          v642[0] = v646;
          v642[1] = v647;
          uint64_t v643 = v648;
          HGExecutionUnit::SetStackState((uint64_t)v635, v642);
          uint64_t v72 = HGRectMake4i(v622, v68, v606, v597);
          HGAnisotropicSampler::GetTile(a1, a2, v72, v73, &a5[(int)((v68 - v591) * a6)], a6, v603, a8, v617);
          v640[0] = v646;
          v640[1] = v647;
          uint64_t v641 = v648;
          int v74 = v640;
        }
        HGExecutionUnit::SetStackState(v69, v74);
        return;
      }
      int v598 = v38;
      v75.f32[0] = (float)(int)v622 + 0.5;
      v75.f32[1] = (float)(int)v591 + 0.5;
      v75.i32[2] = 0;
      v75.i32[3] = 1.0;
      if ((int)v603 >= 1)
      {
        HGRect v624 = (HGRect)v75;
        uint64_t v76 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
        float32x4_t v75 = (float32x4_t)v624;
        uint64_t v607 = v76;
        int v43 = v649[0];
        int v77 = v586;
LABEL_47:
        float32x4_t v86 = *(float32x4_t *)(a1 + 464);
        float32x4_t v87 = vaddq_f32(vmulq_laneq_f32(v86, v75, 3), vaddq_f32(vmulq_laneq_f32(*(float32x4_t *)(a1 + 448), v75, 2), vaddq_f32(vmulq_n_f32(*(float32x4_t *)(a1 + 416), v75.f32[0]), vmulq_lane_f32(*(float32x4_t *)(a1 + 432), *(float32x2_t *)v75.f32, 1))));
        float32x4_t v576 = v87;
        int v88 = HIDWORD(v649[0]);
        if (v43 == HIDWORD(v649[0]))
        {
          float32x4_t v89 = *(float32x4_t *)(*(void *)(a1 + 504) + 32 * (v43 - (uint64_t)*(int *)(a1 + 496)));
          v87.f32[0] = (float)v598;
          v87.f32[1] = (float)(int)v42;
          unint64_t v90 = vaddq_f32(v89, vmulq_f32(v87, v89)).u64[0];
          v86.f32[0] = (float)(int)v615;
          v86.f32[1] = (float)SHIDWORD(v615);
          unint64_t v91 = vaddq_f32(v89, vmulq_f32(v86, v89)).u64[0];
          uint64_t v92 = HGRectIntegral(HIDWORD(v615), *(float *)&v90, *((float *)&v90 + 1), *(float *)&v91, *((float *)&v91 + 1));
          *(void *)(a2 + 208) = HGRectGrow(v92, v93, v607);
          *(void *)(a2 + 216) = v94;
          HGRect v625 = *(HGRect *)(a2 + 208);
          HGRenderer::RenderInput((uint64_t)lpsrc, (uint64_t)v635, a1, 0, a2 + 80, *(void *)(a2 + 208), v94, 0);
          if (v15 >= 1 && (int)v37 >= 1)
          {
            int v95 = 0;
            float32x4_t v96 = vaddq_f32(vmulq_f32(vcvtq_f32_s32((int32x4_t)v625), (float32x4_t)xmmword_1B7E76300), (float32x4_t)xmmword_1B8347300);
            float32x4_t v97 = 0uLL;
            float32x4_t v98 = (float32x4_t)vdupq_n_s32(0x358637BDu);
            v99.i64[0] = 0x3F0000003F000000;
            v99.i64[1] = 0x3F0000003F000000;
            do
            {
              uint64_t v100 = 0;
              float32x4_t v101 = vaddq_f32(v576, vmulq_f32(v97, *(float32x4_t *)(a1 + 432)));
              float32x4_t v102 = 0uLL;
              do
              {
                float32x4_t v111 = vaddq_f32(v101, vmulq_f32(v102, *(float32x4_t *)(a1 + 416)));
                float32x4_t v112 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v111, 3);
                int8x16_t v113 = vmvnq_s8((int8x16_t)vcgtq_f32(v112, v98));
                *(int32x2_t *)v113.i8 = vpmax_s32(*(int32x2_t *)v113.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v113, v113, 8uLL));
                unsigned __int32 v114 = vpmax_s32(*(int32x2_t *)v113.i8, *(int32x2_t *)v113.i8).u32[0];
                float32x4_t v105 = 0uLL;
                if (!v114)
                {
                  float32x4_t v115 = vrecpeq_f32(v112);
                  float32x4_t v116 = vmulq_f32(v115, vrecpsq_f32(v112, v115));
                  float32x4_t v117 = vaddq_f32(*(float32x4_t *)(*(void *)(a1 + 504) + 16), vmulq_f32(vmulq_f32(v111, vmulq_f32(vrecpsq_f32(v112, v116), v116)), *(float32x4_t *)*(void *)(a1 + 504)));
                  int32x4_t v118 = *(int32x4_t *)(a2 + 208);
                  float32x4_t v119 = vaddq_f32(v117, (float32x4_t)xmmword_1B8345FD0);
                  if (v46)
                  {
                    int32x4_t v118 = vaddq_s32(v118, (int32x4_t)xmmword_1B7E74760);
                    int32x4_t v120 = vcvtq_s32_f32(v119);
                    int32x4_t v121 = vcltzq_f32(v119);
                  }
                  else
                  {
                    float32x4_t v122 = vaddq_f32(v119, v99);
                    int32x4_t v120 = vcvtq_s32_f32(v122);
                    int32x4_t v121 = vcgtq_f32(vcvtq_f32_s32(v120), v122);
                  }
                  int8x16_t v123 = (int8x16_t)vsraq_n_s32(v120, vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vmovn_s32(v121)), 0x1FuLL), 0x1FuLL);
                  int8x16_t v124 = vextq_s8((int8x16_t)vcgeq_s32((int32x4_t)vextq_s8(v123, v123, 8uLL), v118), (int8x16_t)vcgtq_s32(v118, (int32x4_t)v123), 8uLL);
                  *(int32x2_t *)v124.i8 = vpmin_s32(*(int32x2_t *)v124.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v124, v124, 8uLL));
                  if (!vpmin_s32(*(int32x2_t *)v124.i8, *(int32x2_t *)v124.i8).u32[0])
                  {
                    uint64_t v125 = *(void *)(a2 + 80);
                    uint64_t v126 = *(int *)(a2 + 88);
                    float32x4_t v127 = vsubq_f32(v117, v96);
                    if (v46)
                    {
                      int32x4_t v128 = vaddq_s32(vcvtq_s32_f32(v127), vcltzq_f32(v127));
                      float32x2_t v129 = (float32x2_t)vsubq_f32(v127, vcvtq_f32_s32(v128)).u64[0];
                      int v130 = (float32x4_t *)(v125 + 16 * (v128.i32[0] + v128.i32[1] * (int)v126));
                      float32x4_t v131 = vaddq_f32(*v130, vmulq_n_f32(vsubq_f32(v130[1], *v130), v129.f32[0]));
                      float32x4_t v105 = vaddq_f32(v131, vmulq_lane_f32(vsubq_f32(vaddq_f32(v130[v126], vmulq_n_f32(vsubq_f32(v130[(int)v126 + 1], v130[v126]), v129.f32[0])), v131), v129, 1));
                    }
                    else
                    {
                      float32x4_t v103 = vaddq_f32(v127, v99);
                      int32x4_t v104 = vcvtq_s32_f32(v103);
                      v103.i64[0] = vaddq_s32(v104, vcgtq_f32(vcvtq_f32_s32(v104), v103)).u64[0];
                      float32x4_t v105 = *(float32x4_t *)(v125 + 16 * (v103.i32[0] + v103.i32[1] * (int)v126));
                    }
                  }
                }
                a5[v100] = v105;
                __asm { FMOV            V7.4S, #1.0 }
                float32x4_t v102 = vaddq_f32(v102, _Q7);
                ++v100;
              }
              while (v37 != v100);
              float32x4_t v97 = vaddq_f32(v97, _Q7);
              ++v95;
              a5 += (int)a6;
            }
            while (v95 != v15);
          }
          return;
        }
        int v132 = (const float *)(*(void *)(a1 + 480) + 424);
        float32x4_t v133 = vld1q_dup_f32(v132);
        int v134 = *(_DWORD *)(a1 + 496);
        if (v43 <= v134) {
          int v43 = *(_DWORD *)(a1 + 496);
        }
        int v135 = v134 + *(_DWORD *)(a1 + 500) - 1;
        if (v43 >= v135) {
          int v43 = v134 + *(_DWORD *)(a1 + 500) - 1;
        }
        if (SHIDWORD(v649[0]) <= v134) {
          int v88 = *(_DWORD *)(a1 + 496);
        }
        if (v88 >= v135) {
          int v88 = v134 + *(_DWORD *)(a1 + 500) - 1;
        }
        v649[0] = __PAIR64__(v88, v43);
        v87.f32[0] = (float)v43;
        int32x4_t v136 = vdupq_lane_s32(*(int32x2_t *)v87.f32, 0);
        float32x4_t v574 = (float32x4_t)v136;
        float32x4_t v575 = v133;
        *(float *)v136.i32 = (float)v88;
        float32x4_t v137 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v136.i8, 0);
        float32x4_t v566 = v137;
        if (v46)
        {
          if (v77 <= 1)
          {
            if (v43 > v88) {
              return;
            }
            v86.f32[0] = (float)v598;
            v86.f32[1] = (float)(int)v42;
            HGRect v626 = (HGRect)v86;
            v86.f32[0] = (float)(int)v615;
            v86.f32[1] = (float)SHIDWORD(v615);
            *(float32x4_t *)__n128 v618 = v86;
            __asm { FMOV            V0.4S, #-1.0 }
            uint64_t v139 = v43;
            uint64_t v140 = (32 * v43) | 0x10;
            float32x4_t v141 = 0uLL;
            float32x4_t v588 = (float32x4_t)vdupq_n_s32(0x358637BDu);
            float32x4_t v593 = vaddq_f32(v137, _Q0);
            uint64_t v599 = 16 * (int)a6;
            float32x4_t v578 = (float32x4_t)vdupq_n_s32(0x3FD92000u);
            int8x16_t v582 = (int8x16_t)vdupq_n_s32(0x7F800000u);
            float32x4_t v567 = (float32x4_t)vdupq_n_s32(0xC0C9A634);
            float32x4_t v570 = (float32x4_t)vdupq_n_s32(0xC2F4531A);
            while (1)
            {
              float32x4_t v631 = v141;
              uint64_t v143 = 0;
              uint64_t v144 = (int32x4_t *)(a2 + 208);
              uint64_t v610 = v140;
              do
              {
                uint64_t v145 = *(int *)(a1 + 496);
                if (v139 + v143 - v145 >= *(int *)(a1 + 500) || v139 + v143 > SHIDWORD(v649[0])) {
                  break;
                }
                float v147 = (float32x4_t *)(*(void *)(a1 + 504) - 32 * v145 + v140);
                float32x4_t v148 = v147[-1];
                unint64_t v149 = vaddq_f32(vmulq_f32((float32x4_t)v626, v148), *v147).u64[0];
                unint64_t v150 = vaddq_f32(vmulq_f32(*(float32x4_t *)v618, v148), *v147).u64[0];
                uint64_t v151 = HGRectIntegral((uint64_t)v147, *(float *)&v149, *((float *)&v149 + 1), *(float *)&v150, *((float *)&v150 + 1));
                v144->i64[0] = HGRectGrow(v151, v152, v607);
                v144->i64[1] = v153;
                int32x4_t v154 = *v144;
                *(&v646 + v143) = (__int128)vaddq_f32(vmulq_f32(vcvtq_f32_s32(*v144), (float32x4_t)xmmword_1B7E76300), (float32x4_t)xmmword_1B8347300);
                HGRenderer::RenderInput((uint64_t)lpsrc, (uint64_t)v635, a1, v139 + v143++ - *(_DWORD *)(a1 + 496), (uint64_t)v144[-8].i64, v154.u64[0], v153, 0);
                v140 += 32;
                ++v144;
              }
              while (v143 != 8);
              if (v15 < 1)
              {
                uint64_t v142 = v610;
                float32x4_t v141 = v631;
              }
              else
              {
                float32x4_t v141 = v631;
                if ((int)v37 > 0)
                {
                  int v155 = 0;
                  uint64_t v142 = v610;
                  v156.i64[0] = 0x3400000034000000;
                  v156.i64[1] = 0x3400000034000000;
                  v157.i64[0] = 0x80000000800000;
                  v157.i64[1] = 0x80000000800000;
                  while (1)
                  {
                    uint64_t v159 = 0;
                    float32x4_t v160 = vaddq_f32(v576, vmulq_f32(v141, *(float32x4_t *)(a1 + 432)));
                    float32x4_t v161 = 0uLL;
                    do
                    {
                      float32x4_t v163 = *(float32x4_t *)(a1 + 416);
                      float32x4_t v164 = vaddq_f32(v160, vmulq_f32(v161, v163));
                      float32x4_t v165 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v164, 3);
                      int8x16_t v166 = vmvnq_s8((int8x16_t)vcgtq_f32(v165, v588));
                      *(int32x2_t *)v166.i8 = vpmax_s32(*(int32x2_t *)v166.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v166, v166, 8uLL));
                      float32x4_t v167 = 0uLL;
                      if (vpmax_s32(*(int32x2_t *)v166.i8, *(int32x2_t *)v166.i8).u32[0]) {
                        goto LABEL_88;
                      }
                      float32x4_t v168 = vrecpeq_f32(v165);
                      float32x4_t v169 = vmulq_f32(v168, vrecpsq_f32(v165, v168));
                      float32x4_t v170 = vmulq_f32(vrecpsq_f32(v165, v169), v169);
                      float32x4_t v171 = vmulq_f32(v164, v170);
                      float32x4_t v172 = vmulq_f32(v170, vsubq_f32(v163, vmulq_laneq_f32(v171, v163, 3)));
                      v172.i64[0] = vmulq_f32(v172, v172).u64[0];
                      float32x4_t v173 = vmulq_f32(v170, vsubq_f32(*(float32x4_t *)(a1 + 432), vmulq_laneq_f32(v171, *(float32x4_t *)(a1 + 432), 3)));
                      v173.i64[0] = vmulq_f32(v173, v173).u64[0];
                      float32x4_t v174 = vmaxq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v172.f32, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v172.f32, 1)), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v173.f32, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v173.f32, 1)));
                      float32x4_t v175 = vrsqrteq_f32(v174);
                      float32x4_t v176 = vmulq_f32(v175, vrsqrtsq_f32(vmulq_f32(v174, v175), v175));
                      float32x4_t v177 = (float32x4_t)vbicq_s8((int8x16_t)vmulq_f32(v174, vmulq_f32(v176, vrsqrtsq_f32(vmulq_f32(v174, v176), v176))), (int8x16_t)vceqzq_f32(v174));
                      float32x4_t v178 = vmulq_f32(vcvtq_f32_s32((int32x4_t)v177), v156);
                      float32x4_t v179 = vcvtq_f32_s32(vcvtq_s32_f32(v178));
                      float32x4_t v180 = vminq_f32(vmaxq_f32(vaddq_f32(v575, vaddq_f32(vaddq_f32(vsubq_f32(v179, (float32x4_t)vandq_s8(v582, (int8x16_t)vcgtq_f32(v157, v177))), v570), vmulq_f32(vrsqrteq_f32(vaddq_f32(vsubq_f32(v178, v179), v578)), v567))), v574), v566);
                      float32x4_t v181 = vminq_f32(v180, v593);
                      float32x4_t v182 = vcvtq_f32_s32(vcvtq_s32_f32(v181));
                      float32x4_t v183 = vaddq_f32(v182, vcvtq_f32_s32(vcgtq_f32(v182, v181)));
                      signed __int32 v184 = vcvtq_s32_f32(v183).u32[0];
                      if (v139 <= v184 && v139 + 6 >= v184)
                      {
                        signed __int32 v186 = v184;
                        uint64_t v187 = *(void *)(a1 + 504);
                        uint64_t v188 = v184 - (uint64_t)*(int *)(a1 + 496);
                        float32x4_t v189 = vaddq_f32(*(float32x4_t *)(v187 + 32 * v188 + 48), vmulq_f32(v171, *(float32x4_t *)(v187 + 32 * v188 + 32)));
                        uint64_t v190 = v186 - (int)v139;
                        float32x4_t v191 = vaddq_f32(v189, (float32x4_t)xmmword_1B8345FD0);
                        int32x4_t v192 = vaddq_s32(*(int32x4_t *)(a2 + 16 * (v190 + 1) + 208), (int32x4_t)xmmword_1B7E74760);
                        int8x16_t v193 = (int8x16_t)vaddq_s32(vcvtq_s32_f32(v191), vcltzq_f32(v191));
                        int8x16_t v194 = vextq_s8((int8x16_t)vcgeq_s32((int32x4_t)vextq_s8(v193, v193, 8uLL), v192), (int8x16_t)vcgtq_s32(v192, (int32x4_t)v193), 8uLL);
                        *(int32x2_t *)v194.i8 = vpmin_s32(*(int32x2_t *)v194.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v194, v194, 8uLL));
                        unsigned __int32 v195 = vpmin_s32(*(int32x2_t *)v194.i8, *(int32x2_t *)v194.i8).u32[0];
                        float32x4_t v167 = 0uLL;
                        if (!v195)
                        {
                          float32x4_t v196 = vsubq_f32(v180, v183);
                          uint64_t v197 = 16 * (v190 + 1);
                          uint64_t v198 = a2 + 80 + v197;
                          float32x4_t v199 = *(float32x4_t *)((char *)&v646 + v197);
                          uint64_t v200 = *(void *)v198;
                          uint64_t v201 = *(int *)(v198 + 8);
                          float32x4_t v202 = vsubq_f32(v189, v199);
                          int32x4_t v203 = vaddq_s32(vcvtq_s32_f32(v202), vcltzq_f32(v202));
                          v202.i64[0] = vsubq_f32(v202, vcvtq_f32_s32(v203)).u64[0];
                          uint64_t v204 = (float32x4_t *)(v200 + 16 * (v203.i32[0] + v203.i32[1] * (int)v201));
                          float32x4_t v205 = vaddq_f32(*v204, vmulq_n_f32(vsubq_f32(v204[1], *v204), v202.f32[0]));
                          float32x4_t v206 = vaddq_f32(v205, vmulq_lane_f32(vsubq_f32(vaddq_f32(v204[v201], vmulq_n_f32(vsubq_f32(v204[(int)v201 + 1], v204[v201]), v202.f32[0])), v205), *(float32x2_t *)v202.f32, 1));
                          float32x4_t v207 = vaddq_f32(*(float32x4_t *)(v187 + 32 * (int)v188 + 16), vmulq_f32(v171, *(float32x4_t *)(v187 + 32 * (int)v188)));
                          uint64_t v208 = a2 + 80 + 16 * v190;
                          uint64_t v209 = *(void *)v208;
                          uint64_t v210 = *(int *)(v208 + 8);
                          float32x4_t v211 = vsubq_f32(v207, *((float32x4_t *)&v646 + v190));
                          int32x4_t v212 = vaddq_s32(vcvtq_s32_f32(v211), vcltzq_f32(v211));
                          v211.i64[0] = vsubq_f32(v211, vcvtq_f32_s32(v212)).u64[0];
                          float32x4_t v213 = (float32x4_t *)(v209 + 16 * (v212.i32[0] + v212.i32[1] * (int)v210));
                          float32x4_t v214 = vaddq_f32(*v213, vmulq_n_f32(vsubq_f32(v213[1], *v213), v211.f32[0]));
                          float32x4_t v215 = vaddq_f32(v214, vmulq_lane_f32(vsubq_f32(vaddq_f32(v213[v210], vmulq_n_f32(vsubq_f32(v213[(int)v210 + 1], v213[v210]), v211.f32[0])), v214), *(float32x2_t *)v211.f32, 1));
                          float32x4_t v167 = vaddq_f32(v215, vmulq_f32(v196, vsubq_f32(v206, v215)));
                        }
LABEL_88:
                        a5[v159] = v167;
                        __asm { FMOV            V2.4S, #1.0 }
                        float32x4_t v161 = vaddq_f32(v161, _Q2);
                      }
                      ++v159;
                    }
                    while (v37 != v159);
                    __asm { FMOV            V0.4S, #1.0 }
                    float32x4_t v141 = vaddq_f32(v141, _Q0);
                    a5 = (float32x4_t *)((char *)a5 + v599);
                    if (++v155 == v15) {
                      goto LABEL_75;
                    }
                  }
                }
                int v216 = v15;
                uint64_t v142 = v610;
                do
                {
                  __asm { FMOV            V0.4S, #1.0 }
                  float32x4_t v141 = vaddq_f32(v141, _Q0);
                  a5 = (float32x4_t *)((char *)a5 + v599);
                  --v216;
                }
                while (v216);
              }
LABEL_75:
              v139 += 7;
              uint64_t v140 = v142 + 224;
              if (v139 > SHIDWORD(v649[0])) {
                return;
              }
            }
          }
          if (v43 > v88) {
            return;
          }
          *(float *)v136.i32 = (float)v77;
          float32x4_t v277 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v136.i8, 0);
          v86.f32[0] = (float)v598;
          v86.f32[1] = (float)(int)v42;
          float32x4_t v584 = v86;
          v86.f32[0] = (float)(int)v615;
          v86.f32[1] = (float)SHIDWORD(v615);
          float32x4_t v580 = v86;
          __asm { FMOV            V0.4S, #-1.0 }
          float32x4_t v279 = vaddq_f32(v137, _Q0);
          uint64_t v280 = (int)a6;
          uint64_t v281 = v43;
          uint64_t v282 = (32 * v43) | 0x10;
          uint64_t v283 = 16 * (int)a6;
          float32x4_t v284 = 0uLL;
          __asm { FMOV            V8.4S, #1.0 }
          HGRect v628 = (HGRect)vdupq_n_s32(0x3FD92000u);
          int8x16_t v633 = (int8x16_t)vdupq_n_s32(0x7F800000u);
          float32x4_t v612 = (float32x4_t)vdupq_n_s32(0xC0C9A634);
          float32x4_t v620 = (float32x4_t)vdupq_n_s32(0xC2F4531A);
          int32x4_t v595 = vdupq_n_s32(0x358637BDu);
          float32x4_t v601 = v279;
          uint64_t v563 = v280;
          uint64_t v561 = v283;
          int32x4_t v590 = vdupq_n_s32(0x7F7FFFFFu);
          float32x4_t v604 = _Q8;
          while (1)
          {
            float32x4_t v572 = v284;
            uint64_t v287 = 0;
            uint64_t v288 = (int32x4_t *)(a2 + 208);
            uint64_t v568 = v282;
            do
            {
              uint64_t v289 = *(int *)(a1 + 496);
              if (v281 + v287 - v289 >= *(int *)(a1 + 500) || v281 + v287 > SHIDWORD(v649[0])) {
                break;
              }
              unsigned int v291 = (float32x4_t *)(*(void *)(a1 + 504) - 32 * v289 + v282);
              float32x4_t v292 = v291[-1];
              unint64_t v293 = vaddq_f32(vmulq_f32(v584, v292), *v291).u64[0];
              unint64_t v294 = vaddq_f32(vmulq_f32(v580, v292), *v291).u64[0];
              uint64_t v295 = HGRectIntegral((uint64_t)v291, *(float *)&v293, *((float *)&v293 + 1), *(float *)&v294, *((float *)&v294 + 1));
              v288->i64[0] = HGRectGrow(v295, v296, v607);
              v288->i64[1] = v297;
              int32x4_t v298 = *v288;
              *(&v646 + v287) = (__int128)vaddq_f32(vmulq_f32(vcvtq_f32_s32(*v288), (float32x4_t)xmmword_1B7E76300), (float32x4_t)xmmword_1B8347300);
              HGRenderer::RenderInput((uint64_t)lpsrc, (uint64_t)v635, a1, v281 + v287++ - *(_DWORD *)(a1 + 496), (uint64_t)v288[-8].i64, v298.u64[0], v297, 0);
              v282 += 32;
              ++v288;
            }
            while (v287 != 8);
            if (v15 < 1)
            {
              uint64_t v286 = v568;
              float32x4_t v284 = v572;
            }
            else
            {
              float32x4_t v284 = v572;
              float32x4_t v299 = v604;
              if ((int)v37 > 0)
              {
                int v300 = 0;
                float32x4_t v302 = (float32x4_t)v595;
                float32x4_t v301 = v601;
                uint64_t v286 = v568;
                v303.i64[0] = 0x80000000800000;
                v303.i64[1] = 0x80000000800000;
                float32x4_t v304 = (float32x4_t)v590;
                v305.i64[0] = 0x3400000034000000;
                v305.i64[1] = 0x3400000034000000;
                v306.i64[0] = 0x80000000800000;
                v306.i64[1] = 0x80000000800000;
                while (1)
                {
                  uint64_t v307 = 0;
                  float32x4_t v308 = v284;
                  float32x4_t v309 = vaddq_f32(v576, vmulq_f32(v284, *(float32x4_t *)(a1 + 432)));
                  float32x4_t v310 = 0uLL;
                  do
                  {
                    float32x4_t v338 = *(float32x4_t *)(a1 + 416);
                    float32x4_t v339 = vaddq_f32(v309, vmulq_f32(v310, v338));
                    float32x4_t v340 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v339, 3);
                    int8x16_t v341 = vmvnq_s8((int8x16_t)vcgtq_f32(v340, v302));
                    *(int32x2_t *)v341.i8 = vpmax_s32(*(int32x2_t *)v341.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v341, v341, 8uLL));
                    float32x4_t v337 = 0uLL;
                    if (vpmax_s32(*(int32x2_t *)v341.i8, *(int32x2_t *)v341.i8).u32[0]) {
                      goto LABEL_147;
                    }
                    float32x4_t v342 = vrecpeq_f32(v340);
                    float32x4_t v343 = vmulq_f32(v342, vrecpsq_f32(v340, v342));
                    float32x4_t v344 = vmulq_f32(vrecpsq_f32(v340, v343), v343);
                    float32x4_t v345 = vmulq_f32(v339, v344);
                    int8x16_t v346 = (int8x16_t)vmulq_f32(v344, vsubq_f32(v338, vmulq_laneq_f32(v345, v338, 3)));
                    int8x16_t v347 = (int8x16_t)vmulq_f32(v344, vsubq_f32(*(float32x4_t *)(a1 + 432), vmulq_laneq_f32(v345, *(float32x4_t *)(a1 + 432), 3)));
                    int8x16_t v348 = (int8x16_t)vaddq_f32((float32x4_t)v346, (float32x4_t)v347);
                    int32x2_t v349 = (int32x2_t)vmulq_f32((float32x4_t)v346, (float32x4_t)v346).u64[0];
                    int8x16_t v350 = (int8x16_t)vsubq_f32((float32x4_t)v346, (float32x4_t)v347);
                    v343.i64[0] = vmulq_f32((float32x4_t)v347, (float32x4_t)v347).u64[0];
                    float32x4_t v351 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v343.f32, 0);
                    int8x16_t v352 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(v349, 0), (float32x4_t)vdupq_lane_s32(v349, 1));
                    float32x4_t v353 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v343.f32, 1);
                    v343.i64[0] = vmulq_f32((float32x4_t)v348, (float32x4_t)v348).u64[0];
                    int8x16_t v354 = (int8x16_t)vaddq_f32(v351, v353);
                    v351.i64[0] = vmulq_f32((float32x4_t)v350, (float32x4_t)v350).u64[0];
                    int8x16_t v355 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v343.f32, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v343.f32, 1));
                    int8x16_t v356 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v351.f32, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v351.f32, 1));
                    int8x16_t v357 = (int8x16_t)vcgtq_f32(vminq_f32((float32x4_t)v352, (float32x4_t)v354), vminq_f32((float32x4_t)v355, (float32x4_t)v356));
                    float32x4_t v358 = (float32x4_t)vbslq_s8(v357, v355, v352);
                    float32x4_t v359 = (float32x4_t)vbslq_s8(v357, v356, v354);
                    float32x4_t v360 = vminq_f32(v358, v359);
                    float32x4_t v361 = vrsqrteq_f32(v360);
                    float32x4_t v362 = vmulq_f32(v361, vrsqrtsq_f32(vmulq_f32(v360, v361), v361));
                    float32x4_t v363 = (float32x4_t)vbicq_s8((int8x16_t)vmulq_f32(v360, vmulq_f32(v362, vrsqrtsq_f32(vmulq_f32(v360, v362), v362))), (int8x16_t)vceqzq_f32(v360));
                    float32x4_t v364 = vmaxq_f32(v358, v359);
                    float32x4_t v365 = vrsqrteq_f32(v364);
                    float32x4_t v366 = vmulq_f32(v365, vrsqrtsq_f32(vmulq_f32(v364, v365), v365));
                    float32x4_t v367 = (float32x4_t)vbicq_s8((int8x16_t)vmulq_f32(v364, vmulq_f32(v366, vrsqrtsq_f32(vmulq_f32(v364, v366), v366))), (int8x16_t)vceqzq_f32(v364));
                    float32x4_t v368 = vminq_f32(vmaxq_f32(v363, v303), v304);
                    float32x4_t v369 = vminq_f32(vmaxq_f32(vrecpeq_f32(v368), v303), v304);
                    float32x4_t v370 = vminq_f32(vmaxq_f32(vmulq_f32(v369, vrecpsq_f32(v368, v369)), v303), v304);
                    float32x4_t v371 = vmaxq_f32(vminq_f32(vmulq_f32(v367, vmulq_f32(v370, vrecpsq_f32(v368, v370))), v277), v299);
                    float32x4_t v372 = vminq_f32(vmaxq_f32(v371, v303), v304);
                    float32x4_t v373 = vminq_f32(vmaxq_f32(vrecpeq_f32(v372), v303), v304);
                    float32x4_t v374 = vminq_f32(vmaxq_f32(vmulq_f32(v373, vrecpsq_f32(v372, v373)), v303), v304);
                    float32x4_t v375 = vmulq_f32(v374, vrecpsq_f32(v372, v374));
                    float32x4_t v376 = vmulq_f32(v367, v375);
                    float32x4_t v377 = vmulq_f32(vcvtq_f32_s32((int32x4_t)v376), v305);
                    float32x4_t v378 = vcvtq_f32_s32(vcvtq_s32_f32(v377));
                    float32x4_t v379 = vminq_f32(vmaxq_f32(vaddq_f32(v575, vaddq_f32(vaddq_f32(vsubq_f32(v378, (float32x4_t)vandq_s8(v633, (int8x16_t)vcgtq_f32(v306, v376))), v620), vmulq_f32(vrsqrteq_f32(vaddq_f32(vsubq_f32(v377, v378), (float32x4_t)v628)), v612))), v574), v566);
                    float32x4_t v380 = vminq_f32(v379, v301);
                    float32x4_t v381 = vcvtq_f32_s32(vcvtq_s32_f32(v380));
                    float32x4_t v382 = vaddq_f32(v381, vcvtq_f32_s32(vcgtq_f32(v381, v380)));
                    signed __int32 v383 = vcvtq_s32_f32(v382).u32[0];
                    if (v281 <= v383 && v281 + 6 >= v383)
                    {
                      signed __int32 v385 = v383;
                      uint64_t v386 = *(void *)(a1 + 504);
                      uint64_t v387 = v383 - (uint64_t)*(int *)(a1 + 496);
                      __n128 v388 = (float32x4_t *)(v386 + 32 * v387);
                      float32x4_t v390 = v388[2];
                      float32x4_t v389 = v388[3];
                      float32x4_t v391 = vaddq_f32(v389, vmulq_f32(v345, v390));
                      uint64_t v392 = v385 - (int)v281;
                      float32x4_t v393 = vaddq_f32(v391, (float32x4_t)xmmword_1B8345FD0);
                      int32x4_t v394 = vaddq_s32(*(int32x4_t *)(a2 + 16 * (v392 + 1) + 208), (int32x4_t)xmmword_1B7E74760);
                      int8x16_t v395 = (int8x16_t)vaddq_s32(vcvtq_s32_f32(v393), vcltzq_f32(v393));
                      int8x16_t v396 = vextq_s8((int8x16_t)vcgeq_s32((int32x4_t)vextq_s8(v395, v395, 8uLL), v394), (int8x16_t)vcgtq_s32(v394, (int32x4_t)v395), 8uLL);
                      *(int32x2_t *)v396.i8 = vpmin_s32(*(int32x2_t *)v396.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v396, v396, 8uLL));
                      LODWORD(v388) = vpmin_s32(*(int32x2_t *)v396.i8, *(int32x2_t *)v396.i8).u32[0];
                      float32x4_t v337 = 0uLL;
                      if (!v388)
                      {
                        float32x4_t v397 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v359, v358), vbslq_s8(v357, v350, v347), vbslq_s8(v357, v348, v346));
                        float32x4_t v398 = vcvtq_f32_s32(vcvtq_s32_f32(v371));
                        float32x4_t v399 = vaddq_f32(v398, vcvtq_f32_s32(vcgtq_f32(v398, v371)));
                        int v400 = vcvtq_s32_f32(v399).u32[0];
                        float32x4_t v401 = vminq_f32(vmaxq_f32(v399, v303), v304);
                        float32x4_t v402 = vminq_f32(vmaxq_f32(vrecpeq_f32(v401), v303), v304);
                        float32x4_t v403 = vminq_f32(vmaxq_f32(vmulq_f32(v402, vrecpsq_f32(v401, v402)), v303), v304);
                        float32x4_t v404 = vmulq_f32(vmulq_f32(vmulq_f32(v375, v399), v397), vmulq_f32(v403, vrecpsq_f32(v401, v403)));
                        uint64_t v405 = 16 * (v392 + 1);
                        uint64_t v406 = a2 + 80 + v405;
                        float32x4_t v407 = *(float32x4_t *)((char *)&v646 + v405);
                        uint64_t v408 = *(void *)v406;
                        uint64_t v409 = *(int *)(v406 + 8);
                        float32x4_t v410 = vsubq_f32(v391, v407);
                        int32x4_t v411 = vaddq_s32(vcvtq_s32_f32(v410), vcltzq_f32(v410));
                        v410.i64[0] = vsubq_f32(v410, vcvtq_f32_s32(v411)).u64[0];
                        __n128 v412 = (float32x4_t *)(v408 + 16 * (v411.i32[0] + v411.i32[1] * (int)v409));
                        float32x4_t v413 = vaddq_f32(*v412, vmulq_n_f32(vsubq_f32(v412[1], *v412), v410.f32[0]));
                        uint64_t v414 = (int)v409 + 1;
                        float32x4_t v415 = vaddq_f32(v413, vmulq_lane_f32(vsubq_f32(vaddq_f32(v412[v409], vmulq_n_f32(vsubq_f32(v412[v414], v412[v409]), v410.f32[0])), v413), *(float32x2_t *)v410.f32, 1));
                        long long v416 = (float32x4_t *)(v386 + 32 * (int)v387);
                        float32x4_t v418 = *v416;
                        float32x4_t v417 = v416[1];
                        float32x4_t v419 = vaddq_f32(v417, vmulq_f32(v345, *v416));
                        float32x4_t v420 = (float32x4_t)*(&v646 + v392);
                        uint64_t v421 = a2 + 80 + 16 * v392;
                        uint64_t v422 = *(void *)v421;
                        uint64_t v423 = *(int *)(v421 + 8);
                        float32x4_t v424 = vsubq_f32(v419, v420);
                        int32x4_t v425 = vaddq_s32(vcvtq_s32_f32(v424), vcltzq_f32(v424));
                        v424.i64[0] = vsubq_f32(v424, vcvtq_f32_s32(v425)).u64[0];
                        long long v426 = (float32x4_t *)(*(void *)v421 + 16 * (v425.i32[0] + v425.i32[1] * (int)v423));
                        float32x4_t v427 = vaddq_f32(*v426, vmulq_n_f32(vsubq_f32(v426[1], *v426), v424.f32[0]));
                        float32x4_t v428 = vaddq_f32(v427, vmulq_lane_f32(vsubq_f32(vaddq_f32(v426[v423], vmulq_n_f32(vsubq_f32(v426[(int)v423 + 1], v426[v423]), v424.f32[0])), v427), *(float32x2_t *)v424.f32, 1));
                        uint64_t v429 = v414;
                        if (v400 < 3)
                        {
                          float32x4_t v311 = v345;
                        }
                        else
                        {
                          unsigned int v430 = v400 + 2;
                          float32x4_t v311 = v345;
                          do
                          {
                            float32x4_t v311 = vaddq_f32(v404, v311);
                            float32x4_t v345 = vsubq_f32(v345, v404);
                            float32x4_t v431 = vsubq_f32(vaddq_f32(v417, vmulq_f32(v418, v311)), v420);
                            int32x4_t v432 = vaddq_s32(vcvtq_s32_f32(v431), vcltzq_f32(v431));
                            v431.i64[0] = vsubq_f32(v431, vcvtq_f32_s32(v432)).u64[0];
                            long long v433 = (float32x4_t *)(v422 + 16 * (v432.i32[0] + v432.i32[1] * (int)v423));
                            float32x4_t v434 = *v433;
                            float32x4_t v435 = v433[v423];
                            float32x4_t v436 = vsubq_f32(vaddq_f32(v417, vmulq_f32(v418, v345)), v420);
                            int32x4_t v437 = vaddq_s32(vcvtq_s32_f32(v436), vcltzq_f32(v436));
                            float32x4_t v438 = vmulq_n_f32(vsubq_f32(v433[1], *v433), v431.f32[0]);
                            v436.i64[0] = vsubq_f32(v436, vcvtq_f32_s32(v437)).u64[0];
                            float32x4_t v439 = vmulq_n_f32(vsubq_f32(v433[(int)v423 + 1], v435), v431.f32[0]);
                            __n128 v440 = (float32x4_t *)(v422 + 16 * (v437.i32[0] + v437.i32[1] * (int)v423));
                            float32x4_t v441 = vaddq_f32(v434, v438);
                            float32x4_t v442 = vaddq_f32(v435, v439);
                            float32x4_t v443 = vaddq_f32(*v440, vmulq_n_f32(vsubq_f32(v440[1], *v440), v436.f32[0]));
                            float32x4_t v444 = vsubq_f32(vaddq_f32(v389, vmulq_f32(v390, v311)), v407);
                            int32x4_t v445 = vaddq_s32(vcvtq_s32_f32(v444), vcltzq_f32(v444));
                            v444.i64[0] = vsubq_f32(v444, vcvtq_f32_s32(v445)).u64[0];
                            float32x4_t v446 = vsubq_f32(vaddq_f32(v440[v423], vmulq_n_f32(vsubq_f32(v440[(int)v423 + 1], v440[v423]), v436.f32[0])), v443);
                            __n128 v447 = (float32x4_t *)(v408 + 16 * (v445.i32[0] + v445.i32[1] * (int)v409));
                            float32x4_t v448 = vmulq_lane_f32(vsubq_f32(v442, v441), *(float32x2_t *)v431.f32, 1);
                            float32x4_t v449 = vaddq_f32(*v447, vmulq_n_f32(vsubq_f32(v447[1], *v447), v444.f32[0]));
                            float32x4_t v450 = vaddq_f32(v441, v448);
                            float32x4_t v451 = vsubq_f32(vaddq_f32(v389, vmulq_f32(v390, v345)), v407);
                            float32x4_t v452 = vaddq_f32(v443, vmulq_lane_f32(v446, *(float32x2_t *)v436.f32, 1));
                            int32x4_t v453 = vaddq_s32(vcvtq_s32_f32(v451), vcltzq_f32(v451));
                            v451.i64[0] = vsubq_f32(v451, vcvtq_f32_s32(v453)).u64[0];
                            float32x4_t v454 = vaddq_f32(v449, vmulq_lane_f32(vsubq_f32(vaddq_f32(v447[v409], vmulq_n_f32(vsubq_f32(v447[v429], v447[v409]), v444.f32[0])), v449), *(float32x2_t *)v444.f32, 1));
                            long long v455 = (float32x4_t *)(v408 + 16 * (v453.i32[0] + v453.i32[1] * (int)v409));
                            float32x4_t v456 = vaddq_f32(v428, v450);
                            float32x4_t v457 = vaddq_f32(*v455, vmulq_n_f32(vsubq_f32(v455[1], *v455), v451.f32[0]));
                            float32x4_t v428 = vaddq_f32(v456, v452);
                            float32x4_t v415 = vaddq_f32(vaddq_f32(v415, v454), vaddq_f32(v457, vmulq_lane_f32(vsubq_f32(vaddq_f32(v455[v409], vmulq_n_f32(vsubq_f32(v455[v429], v455[v409]), v451.f32[0])), v457), *(float32x2_t *)v451.f32, 1)));
                            v430 -= 2;
                          }
                          while (v430 > 4);
                        }
                        float32x4_t v312 = vsubq_f32(v379, v382);
                        float32x4_t v299 = v604;
                        v313.i64[0] = 0x3F0000003F000000;
                        v313.i64[1] = 0x3F0000003F000000;
                        float32x4_t v314 = vmulq_f32(vaddq_f32(v399, v604), v313);
                        float32x4_t v315 = vcvtq_f32_s32(vcvtq_s32_f32(v314));
                        float32x4_t v316 = vaddq_f32(vmulq_f32(vsubq_f32(v371, v399), v313), vsubq_f32(v314, vaddq_f32(v315, vcvtq_f32_s32(vcgtq_f32(v315, v314)))));
                        float32x4_t v317 = vaddq_f32(v404, v311);
                        float32x4_t v318 = vsubq_f32(v345, v404);
                        float32x4_t v319 = vsubq_f32(vaddq_f32(v417, vmulq_f32(v418, v317)), v420);
                        int32x4_t v320 = vaddq_s32(vcvtq_s32_f32(v319), vcltzq_f32(v319));
                        v319.i64[0] = vsubq_f32(v319, vcvtq_f32_s32(v320)).u64[0];
                        uint64_t v321 = (float32x4_t *)(v422 + 16 * (v320.i32[0] + v320.i32[1] * (int)v423));
                        float32x4_t v322 = vaddq_f32(*v321, vmulq_n_f32(vsubq_f32(v321[1], *v321), v319.f32[0]));
                        float32x4_t v323 = vaddq_f32(v428, vmulq_f32(v316, vaddq_f32(v322, vmulq_lane_f32(vsubq_f32(vaddq_f32(v321[v423], vmulq_n_f32(vsubq_f32(v321[(int)v423 + 1], v321[v423]), v319.f32[0])), v322), *(float32x2_t *)v319.f32, 1))));
                        float32x4_t v324 = vsubq_f32(vaddq_f32(v417, vmulq_f32(v418, v318)), v420);
                        int32x4_t v325 = vaddq_s32(vcvtq_s32_f32(v324), vcltzq_f32(v324));
                        v324.i64[0] = vsubq_f32(v324, vcvtq_f32_s32(v325)).u64[0];
                        long long v326 = (float32x4_t *)(v422 + 16 * (v325.i32[0] + v325.i32[1] * (int)v423));
                        float32x4_t v327 = vaddq_f32(*v326, vmulq_n_f32(vsubq_f32(v326[1], *v326), v324.f32[0]));
                        float32x4_t v328 = vaddq_f32(v323, vmulq_f32(v316, vaddq_f32(v327, vmulq_lane_f32(vsubq_f32(vaddq_f32(v326[v423], vmulq_n_f32(vsubq_f32(v326[(int)v423 + 1], v326[v423]), v324.f32[0])), v327), *(float32x2_t *)v324.f32, 1))));
                        float32x4_t v329 = vsubq_f32(vaddq_f32(v389, vmulq_f32(v390, v317)), v407);
                        int32x4_t v330 = vaddq_s32(vcvtq_s32_f32(v329), vcltzq_f32(v329));
                        v329.i64[0] = vsubq_f32(v329, vcvtq_f32_s32(v330)).u64[0];
                        __n128 v331 = (float32x4_t *)(v408 + 16 * (v330.i32[0] + v330.i32[1] * (int)v409));
                        float32x4_t v332 = vaddq_f32(*v331, vmulq_n_f32(vsubq_f32(v331[1], *v331), v329.f32[0]));
                        float32x4_t v333 = vsubq_f32(vaddq_f32(v389, vmulq_f32(v390, v318)), v407);
                        int32x4_t v334 = vaddq_s32(vcvtq_s32_f32(v333), vcltzq_f32(v333));
                        v333.i64[0] = vsubq_f32(v333, vcvtq_f32_s32(v334)).u64[0];
                        __n128 v335 = (float32x4_t *)(v408 + 16 * (v334.i32[0] + v334.i32[1] * (int)v409));
                        float32x4_t v336 = vaddq_f32(*v335, vmulq_n_f32(vsubq_f32(v335[1], *v335), v333.f32[0]));
                        float32x4_t v337 = vmulq_f32(v375, vaddq_f32(v328, vmulq_f32(v312, vsubq_f32(vaddq_f32(vaddq_f32(v415, vmulq_f32(v316, vaddq_f32(v332, vmulq_lane_f32(vsubq_f32(vaddq_f32(v331[v409], vmulq_n_f32(vsubq_f32(v331[v429], v331[v409]), v329.f32[0])), v332),
                                                 *(float32x2_t *)v329.f32,
                                                 1)))),
                                         vmulq_f32(v316, vaddq_f32(v336, vmulq_lane_f32(vsubq_f32(vaddq_f32(v335[v409], vmulq_n_f32(vsubq_f32(v335[v429], v335[v409]), v333.f32[0])), v336), *(float32x2_t *)v333.f32, 1)))), v328))));
                        float32x4_t v302 = (float32x4_t)v595;
                        float32x4_t v301 = v601;
                        v303.i64[0] = 0x80000000800000;
                        v303.i64[1] = 0x80000000800000;
                        float32x4_t v304 = (float32x4_t)v590;
                        v305.i64[0] = 0x3400000034000000;
                        v305.i64[1] = 0x3400000034000000;
                        v306.i64[0] = 0x80000000800000;
                        v306.i64[1] = 0x80000000800000;
                      }
LABEL_147:
                      a5[v307] = v337;
                      float32x4_t v310 = vaddq_f32(v310, v299);
                    }
                    ++v307;
                  }
                  while (v307 != v37);
                  float32x4_t v284 = vaddq_f32(v308, v299);
                  a5 += v563;
                  if (++v300 == v15) {
                    goto LABEL_132;
                  }
                }
              }
              int v458 = v15;
              uint64_t v286 = v568;
              do
              {
                float32x4_t v284 = vaddq_f32(v284, v604);
                a5 = (float32x4_t *)((char *)a5 + v561);
                --v458;
              }
              while (v458);
            }
LABEL_132:
            v281 += 7;
            uint64_t v282 = v286 + 224;
            if (v281 > SHIDWORD(v649[0])) {
              return;
            }
          }
        }
        if (v77 <= 1)
        {
          if (v43 > v88) {
            return;
          }
          v137.f32[0] = (float)v598;
          v137.f32[1] = (float)(int)v42;
          HGRect v627 = (HGRect)v137;
          v137.f32[0] = (float)(int)v615;
          v137.f32[1] = (float)SHIDWORD(v615);
          *(float32x4_t *)__n128 v619 = v137;
          uint64_t v218 = v43;
          uint64_t v219 = (32 * v43) | 0x10;
          float32x4_t v220 = 0uLL;
          uint64_t v600 = 16 * (int)a6;
          int8x16_t v589 = (int8x16_t)vdupq_n_s32(0x7F800000u);
          float32x4_t v594 = (float32x4_t)vdupq_n_s32(0x358637BDu);
          float32x4_t v579 = (float32x4_t)vdupq_n_s32(0xC2F4531A);
          float32x4_t v583 = (float32x4_t)vdupq_n_s32(0x3FD92000u);
          float32x4_t v571 = (float32x4_t)vdupq_n_s32(0xC0C9A634);
          while (1)
          {
            float32x4_t v632 = v220;
            uint64_t v222 = 0;
            unint64_t v223 = (int32x4_t *)(a2 + 208);
            uint64_t v611 = v219;
            do
            {
              uint64_t v224 = *(int *)(a1 + 496);
              if (v218 + v222 - v224 >= *(int *)(a1 + 500) || v218 + v222 > SHIDWORD(v649[0])) {
                break;
              }
              uint64_t v226 = (float32x4_t *)(*(void *)(a1 + 504) - 32 * v224 + v219);
              float32x4_t v227 = v226[-1];
              unint64_t v228 = vaddq_f32(vmulq_f32((float32x4_t)v627, v227), *v226).u64[0];
              unint64_t v229 = vaddq_f32(vmulq_f32(*(float32x4_t *)v619, v227), *v226).u64[0];
              uint64_t v230 = HGRectIntegral((uint64_t)v226, *(float *)&v228, *((float *)&v228 + 1), *(float *)&v229, *((float *)&v229 + 1));
              v223->i64[0] = HGRectGrow(v230, v231, v607);
              v223->i64[1] = v232;
              int32x4_t v233 = *v223;
              *(&v646 + v222) = (__int128)vaddq_f32(vmulq_f32(vcvtq_f32_s32(*v223), (float32x4_t)xmmword_1B7E76300), (float32x4_t)xmmword_1B8347300);
              HGRenderer::RenderInput((uint64_t)lpsrc, (uint64_t)v635, a1, v218 + v222++ - *(_DWORD *)(a1 + 496), (uint64_t)v223[-8].i64, v233.u64[0], v232, 0);
              v219 += 32;
              ++v223;
            }
            while (v222 != 8);
            if (v15 < 1)
            {
              uint64_t v221 = v611;
              float32x4_t v220 = v632;
            }
            else
            {
              float32x4_t v220 = v632;
              if ((int)v37 > 0)
              {
                int v234 = 0;
                uint64_t v221 = v611;
                v235.i64[0] = 0x3400000034000000;
                v235.i64[1] = 0x3400000034000000;
                v236.i64[0] = 0x80000000800000;
                v236.i64[1] = 0x80000000800000;
                v237.i64[0] = 0x3F0000003F000000;
                v237.i64[1] = 0x3F0000003F000000;
                while (1)
                {
                  uint64_t v239 = 0;
                  float32x4_t v240 = vaddq_f32(v576, vmulq_f32(v220, *(float32x4_t *)(a1 + 432)));
                  float32x4_t v241 = 0uLL;
                  do
                  {
                    float32x4_t v243 = *(float32x4_t *)(a1 + 416);
                    float32x4_t v244 = vaddq_f32(v240, vmulq_f32(v241, v243));
                    float32x4_t v245 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v244, 3);
                    int8x16_t v246 = vmvnq_s8((int8x16_t)vcgtq_f32(v245, v594));
                    *(int32x2_t *)v246.i8 = vpmax_s32(*(int32x2_t *)v246.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v246, v246, 8uLL));
                    unsigned __int32 v247 = vpmax_s32(*(int32x2_t *)v246.i8, *(int32x2_t *)v246.i8).u32[0];
                    float32x4_t v248 = 0uLL;
                    if (v247) {
                      goto LABEL_117;
                    }
                    float32x4_t v249 = vrecpeq_f32(v245);
                    float32x4_t v250 = vmulq_f32(v249, vrecpsq_f32(v245, v249));
                    float32x4_t v251 = vmulq_f32(vrecpsq_f32(v245, v250), v250);
                    float32x4_t v252 = vmulq_f32(v244, v251);
                    float32x4_t v253 = vmulq_f32(v251, vsubq_f32(v243, vmulq_laneq_f32(v252, v243, 3)));
                    float32x4_t v254 = vmulq_f32(v251, vsubq_f32(*(float32x4_t *)(a1 + 432), vmulq_laneq_f32(v252, *(float32x4_t *)(a1 + 432), 3)));
                    v253.i64[0] = vmulq_f32(v253, v253).u64[0];
                    v254.i64[0] = vmulq_f32(v254, v254).u64[0];
                    float32x4_t v255 = vmaxq_f32(vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v253.f32, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v253.f32, 1)), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v254.f32, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v254.f32, 1)));
                    float32x4_t v256 = vrsqrteq_f32(v255);
                    float32x4_t v257 = vmulq_f32(v256, vrsqrtsq_f32(vmulq_f32(v255, v256), v256));
                    float32x4_t v258 = (float32x4_t)vbicq_s8((int8x16_t)vmulq_f32(v255, vmulq_f32(v257, vrsqrtsq_f32(vmulq_f32(v255, v257), v257))), (int8x16_t)vceqzq_f32(v255));
                    float32x4_t v259 = vmulq_f32(vcvtq_f32_s32((int32x4_t)v258), v235);
                    float32x4_t v260 = vcvtq_f32_s32(vcvtq_s32_f32(v259));
                    float32x4_t v261 = vminq_f32(vmaxq_f32(vaddq_f32(v575, vaddq_f32(vaddq_f32(vsubq_f32(v260, (float32x4_t)vandq_s8(v589, (int8x16_t)vcgtq_f32(v236, v258))), v579), vmulq_f32(vrsqrteq_f32(vaddq_f32(vsubq_f32(v259, v260), v583)), v571))), v574), v566);
                    float32x4_t v262 = vcvtq_f32_s32(vcvtq_s32_f32(v261));
                    signed __int32 v263 = vcvtq_s32_f32(vsubq_f32(v262, vcvtq_f32_s32(vcgtq_f32(v261, v262)))).u32[0];
                    uint64_t v264 = v263 - v218;
                    if (v263 >= v218 && v218 + 7 >= v263)
                    {
                      float32x4_t v266 = (float32x4_t *)(*(void *)(a1 + 504) + 32 * (v263 - (uint64_t)*(int *)(a1 + 496)));
                      float32x4_t v267 = vaddq_f32(v266[1], vmulq_f32(v252, *v266));
                      float32x4_t v268 = vaddq_f32(vaddq_f32(v267, (float32x4_t)xmmword_1B8345FD0), v237);
                      int32x4_t v269 = vcvtq_s32_f32(v268);
                      int8x16_t v270 = (int8x16_t)vaddq_s32(v269, vcgtq_f32(vcvtq_f32_s32(v269), v268));
                      int8x16_t v271 = vextq_s8((int8x16_t)vcgeq_s32((int32x4_t)vextq_s8(v270, v270, 8uLL), *(int32x4_t *)(a2 + 16 * v264 + 208)), (int8x16_t)vcgtq_s32(*(int32x4_t *)(a2 + 16 * v264 + 208), (int32x4_t)v270), 8uLL);
                      *(int32x2_t *)v271.i8 = vpmin_s32(*(int32x2_t *)v271.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v271, v271, 8uLL));
                      float32x4_t v248 = 0uLL;
                      if (!vpmin_s32(*(int32x2_t *)v271.i8, *(int32x2_t *)v271.i8).u32[0])
                      {
                        uint64_t v272 = 16 * v264;
                        float32x4_t v273 = vaddq_f32(vsubq_f32(v267, *(float32x4_t *)((char *)&v646 + v272)), v237);
                        int32x4_t v274 = vcvtq_s32_f32(v273);
                        v273.i64[0] = vaddq_s32(v274, vcgtq_f32(vcvtq_f32_s32(v274), v273)).u64[0];
                        float32x4_t v248 = *(float32x4_t *)(*(void *)(a2 + v272 + 80)
                                              + 16 * (v273.i32[0] + v273.i32[1] * *(_DWORD *)(a2 + v272 + 88)));
                      }
LABEL_117:
                      a5[v239] = v248;
                      __asm { FMOV            V2.4S, #1.0 }
                      float32x4_t v241 = vaddq_f32(v241, _Q2);
                    }
                    ++v239;
                  }
                  while (v37 != v239);
                  __asm { FMOV            V0.4S, #1.0 }
                  float32x4_t v220 = vaddq_f32(v220, _Q0);
                  a5 = (float32x4_t *)((char *)a5 + v600);
                  if (++v234 == v15) {
                    goto LABEL_104;
                  }
                }
              }
              int v275 = v15;
              uint64_t v221 = v611;
              do
              {
                __asm { FMOV            V0.4S, #1.0 }
                float32x4_t v220 = vaddq_f32(v220, _Q0);
                a5 = (float32x4_t *)((char *)a5 + v600);
                --v275;
              }
              while (v275);
            }
LABEL_104:
            v218 += 8;
            uint64_t v219 = v221 + 256;
            if (v218 > SHIDWORD(v649[0])) {
              return;
            }
          }
        }
        if (v43 > v88) {
          return;
        }
        *(float *)v136.i32 = (float)v77;
        v137.f32[0] = (float)v598;
        v137.f32[1] = (float)(int)v42;
        HGRect v629 = (HGRect)v137;
        v137.f32[0] = (float)(int)v615;
        v137.f32[1] = (float)SHIDWORD(v615);
        *(float32x4_t *)__n128 v621 = v137;
        uint64_t v459 = v43;
        uint64_t v460 = (32 * v43) | 0x10;
        float32x4_t v461 = 0uLL;
        __asm { FMOV            V9.4S, #1.0 }
        float32x4_t v581 = (float32x4_t)vdupq_n_s32(0x358637BDu);
        float32x4_t v585 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v136.i8, 0);
        uint64_t v602 = (int)a6;
        uint64_t v596 = 16 * (int)a6;
        int8x16_t v569 = (int8x16_t)vdupq_n_s32(0x7F800000u);
        float32x4_t v573 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
        float32x4_t v564 = (float32x4_t)vdupq_n_s32(0xC2F4531A);
        float32x4_t v565 = (float32x4_t)vdupq_n_s32(0x3FD92000u);
        float32x4_t v562 = (float32x4_t)vdupq_n_s32(0xC0C9A634);
        while (1)
        {
          float32x4_t v634 = v461;
          uint64_t v464 = 0;
          __n128 v465 = (int32x4_t *)(a2 + 208);
          uint64_t v613 = v460;
          do
          {
            uint64_t v466 = *(int *)(a1 + 496);
            if (v459 + v464 - v466 >= *(int *)(a1 + 500) || v459 + v464 > SHIDWORD(v649[0])) {
              break;
            }
            v468 = (float32x4_t *)(*(void *)(a1 + 504) - 32 * v466 + v460);
            float32x4_t v469 = v468[-1];
            unint64_t v470 = vaddq_f32(vmulq_f32((float32x4_t)v629, v469), *v468).u64[0];
            unint64_t v471 = vaddq_f32(vmulq_f32(*(float32x4_t *)v621, v469), *v468).u64[0];
            uint64_t v472 = HGRectIntegral((uint64_t)v468, *(float *)&v470, *((float *)&v470 + 1), *(float *)&v471, *((float *)&v471 + 1));
            v465->i64[0] = HGRectGrow(v472, v473, v607);
            v465->i64[1] = v474;
            int32x4_t v475 = *v465;
            *(&v646 + v464) = (__int128)vaddq_f32(vmulq_f32(vcvtq_f32_s32(*v465), (float32x4_t)xmmword_1B7E76300), (float32x4_t)xmmword_1B8347300);
            HGRenderer::RenderInput((uint64_t)lpsrc, (uint64_t)v635, a1, v459 + v464++ - *(_DWORD *)(a1 + 496), (uint64_t)v465[-8].i64, v475.u64[0], v474, 0);
            v460 += 32;
            ++v465;
          }
          while (v464 != 8);
          if (v15 < 1)
          {
            uint64_t v463 = v613;
            float32x4_t v461 = v634;
          }
          else
          {
            float32x4_t v461 = v634;
            if ((int)v37 > 0)
            {
              int v476 = 0;
              uint64_t v463 = v613;
              v477.i64[0] = 0x80000000800000;
              v477.i64[1] = 0x80000000800000;
              v478.i64[0] = 0x3400000034000000;
              v478.i64[1] = 0x3400000034000000;
              v479.i64[0] = 0x80000000800000;
              v479.i64[1] = 0x80000000800000;
              v480.i64[0] = 0x3F0000003F000000;
              v480.i64[1] = 0x3F0000003F000000;
              while (1)
              {
                uint64_t v481 = 0;
                float32x4_t v482 = vaddq_f32(v576, vmulq_f32(v461, *(float32x4_t *)(a1 + 432)));
                float32x4_t v483 = 0uLL;
                do
                {
                  float32x4_t v493 = *(float32x4_t *)(a1 + 416);
                  float32x4_t v494 = vaddq_f32(v482, vmulq_f32(v483, v493));
                  float32x4_t v495 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v494, 3);
                  int8x16_t v496 = vmvnq_s8((int8x16_t)vcgtq_f32(v495, v581));
                  *(int32x2_t *)v496.i8 = vpmax_s32(*(int32x2_t *)v496.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v496, v496, 8uLL));
                  float32x4_t v492 = 0uLL;
                  if (vpmax_s32(*(int32x2_t *)v496.i8, *(int32x2_t *)v496.i8).u32[0]) {
                    goto LABEL_180;
                  }
                  float32x4_t v497 = vrecpeq_f32(v495);
                  float32x4_t v498 = vmulq_f32(v497, vrecpsq_f32(v495, v497));
                  float32x4_t v499 = vmulq_f32(vrecpsq_f32(v495, v498), v498);
                  float32x4_t v500 = vmulq_f32(v494, v499);
                  int8x16_t v501 = (int8x16_t)vmulq_f32(v499, vsubq_f32(v493, vmulq_laneq_f32(v500, v493, 3)));
                  v498.i64[0] = vmulq_f32((float32x4_t)v501, (float32x4_t)v501).u64[0];
                  int8x16_t v502 = (int8x16_t)vmulq_f32(v499, vsubq_f32(*(float32x4_t *)(a1 + 432), vmulq_laneq_f32(v500, *(float32x4_t *)(a1 + 432), 3)));
                  v499.i64[0] = vmulq_f32((float32x4_t)v502, (float32x4_t)v502).u64[0];
                  float32x4_t v503 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v498.f32, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v498.f32, 1));
                  float32x4_t v504 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v499.f32, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v499.f32, 1));
                  float32x4_t v505 = vminq_f32(v503, v504);
                  float32x4_t v506 = vrsqrteq_f32(v505);
                  float32x4_t v507 = vmulq_f32(v506, vrsqrtsq_f32(vmulq_f32(v505, v506), v506));
                  float32x4_t v508 = (float32x4_t)vbicq_s8((int8x16_t)vmulq_f32(v505, vmulq_f32(v507, vrsqrtsq_f32(vmulq_f32(v505, v507), v507))), (int8x16_t)vceqzq_f32(v505));
                  float32x4_t v509 = vmaxq_f32(v503, v504);
                  float32x4_t v510 = vrsqrteq_f32(v509);
                  float32x4_t v511 = vmulq_f32(v510, vrsqrtsq_f32(vmulq_f32(v509, v510), v510));
                  float32x4_t v512 = (float32x4_t)vbicq_s8((int8x16_t)vmulq_f32(v509, vmulq_f32(v511, vrsqrtsq_f32(vmulq_f32(v509, v511), v511))), (int8x16_t)vceqzq_f32(v509));
                  float32x4_t v513 = vminq_f32(vmaxq_f32(v508, v477), v573);
                  float32x4_t v514 = vminq_f32(vmaxq_f32(vrecpeq_f32(v513), v477), v573);
                  float32x4_t v515 = vminq_f32(vmaxq_f32(vmulq_f32(v514, vrecpsq_f32(v513, v514)), v477), v573);
                  float32x4_t v516 = vmaxq_f32(vminq_f32(vmulq_f32(v512, vmulq_f32(v515, vrecpsq_f32(v513, v515))), v585), _Q9);
                  float32x4_t v517 = vminq_f32(vmaxq_f32(v516, v477), v573);
                  float32x4_t v518 = vminq_f32(vmaxq_f32(vrecpeq_f32(v517), v477), v573);
                  float32x4_t v519 = vminq_f32(vmaxq_f32(vmulq_f32(v518, vrecpsq_f32(v517, v518)), v477), v573);
                  float32x4_t v520 = vmulq_f32(v519, vrecpsq_f32(v517, v519));
                  float32x4_t v521 = vmulq_f32(v512, v520);
                  float32x4_t v522 = vmulq_f32(vcvtq_f32_s32((int32x4_t)v521), v478);
                  float32x4_t v523 = vcvtq_f32_s32(vcvtq_s32_f32(v522));
                  float32x4_t v524 = vminq_f32(vmaxq_f32(vaddq_f32(v575, vaddq_f32(vaddq_f32(vsubq_f32(v523, (float32x4_t)vandq_s8(v569, (int8x16_t)vcgtq_f32(v479, v521))), v564), vmulq_f32(vrsqrteq_f32(vaddq_f32(vsubq_f32(v522, v523), v565)), v562))), v574), v566);
                  float32x4_t v525 = vcvtq_f32_s32(vcvtq_s32_f32(v524));
                  signed __int32 v526 = vcvtq_s32_f32(vsubq_f32(v525, vcvtq_f32_s32(vcgtq_f32(v524, v525)))).u32[0];
                  uint64_t v527 = v526 - v459;
                  if (v526 >= v459 && v459 + 7 >= v526)
                  {
                    uint64_t v529 = *(void *)(a1 + 504) + 32 * (v526 - (uint64_t)*(int *)(a1 + 496));
                    float32x4_t v531 = *(float32x4_t *)v529;
                    float32x4_t v530 = *(float32x4_t *)(v529 + 16);
                    float32x4_t v532 = vaddq_f32(v530, vmulq_f32(v500, *(float32x4_t *)v529));
                    float32x4_t v533 = vaddq_f32(vaddq_f32(v532, (float32x4_t)xmmword_1B8345FD0), v480);
                    int32x4_t v534 = vcvtq_s32_f32(v533);
                    v480.i64[0] = 0x3F0000003F000000;
                    v480.i64[1] = 0x3F0000003F000000;
                    int8x16_t v535 = (int8x16_t)vaddq_s32(v534, vcgtq_f32(vcvtq_f32_s32(v534), v533));
                    int8x16_t v536 = vextq_s8((int8x16_t)vcgeq_s32((int32x4_t)vextq_s8(v535, v535, 8uLL), *(int32x4_t *)(a2 + 16 * v527 + 208)), (int8x16_t)vcgtq_s32(*(int32x4_t *)(a2 + 16 * v527 + 208), (int32x4_t)v535), 8uLL);
                    *(int32x2_t *)v536.i8 = vpmin_s32(*(int32x2_t *)v536.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v536, v536, 8uLL));
                    LODWORD(v529) = vpmin_s32(*(int32x2_t *)v536.i8, *(int32x2_t *)v536.i8).u32[0];
                    float32x4_t v492 = 0uLL;
                    if (!v529)
                    {
                      float32x4_t v537 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v504, v503), v502, v501);
                      float32x4_t v538 = vcvtq_f32_s32(vcvtq_s32_f32(v516));
                      float32x4_t v539 = vaddq_f32(v538, vcvtq_f32_s32(vcgtq_f32(v538, v516)));
                      int v540 = vcvtq_s32_f32(v539).u32[0];
                      float32x4_t v541 = vminq_f32(vmaxq_f32(v539, v477), v573);
                      float32x4_t v542 = vminq_f32(vmaxq_f32(vrecpeq_f32(v541), v477), v573);
                      float32x4_t v543 = vminq_f32(vmaxq_f32(vmulq_f32(v542, vrecpsq_f32(v541, v542)), v477), v573);
                      float32x4_t v544 = vmulq_f32(vmulq_f32(v537, vmulq_f32(v520, v539)), vmulq_f32(v543, vrecpsq_f32(v541, v543)));
                      uint64_t v545 = 16 * v527;
                      uint64_t v546 = a2 + v545;
                      float32x4_t v547 = *(float32x4_t *)((char *)&v646 + v545);
                      uint64_t v548 = *(void *)(a2 + v545 + 80);
                      float32x4_t v549 = vaddq_f32(vsubq_f32(v532, v547), v480);
                      int32x4_t v550 = vcvtq_s32_f32(v549);
                      v549.i64[0] = vaddq_s32(v550, vcgtq_f32(vcvtq_f32_s32(v550), v549)).u64[0];
                      int v551 = *(_DWORD *)(v546 + 88);
                      float32x4_t v552 = *(float32x4_t *)(v548 + 16 * (v549.i32[0] + v549.i32[1] * v551));
                      if (v540 < 3)
                      {
                        float32x4_t v484 = v500;
                      }
                      else
                      {
                        unsigned int v553 = v540 + 2;
                        float32x4_t v484 = v500;
                        do
                        {
                          float32x4_t v500 = vaddq_f32(v544, v500);
                          float32x4_t v484 = vsubq_f32(v484, v544);
                          float32x4_t v554 = vaddq_f32(vsubq_f32(vaddq_f32(v530, vmulq_f32(v531, v500)), v547), v480);
                          int32x4_t v555 = vcvtq_s32_f32(v554);
                          v554.i64[0] = vaddq_s32(v555, vcgtq_f32(vcvtq_f32_s32(v555), v554)).u64[0];
                          __int32 v556 = v554.i32[1];
                          __int32 v557 = v554.i32[0];
                          float32x4_t v558 = vaddq_f32(vsubq_f32(vaddq_f32(v530, vmulq_f32(v531, v484)), v547), v480);
                          int32x4_t v559 = vcvtq_s32_f32(v558);
                          v558.i64[0] = vaddq_s32(v559, vcgtq_f32(vcvtq_f32_s32(v559), v558)).u64[0];
                          v480.i64[0] = 0x3F0000003F000000;
                          v480.i64[1] = 0x3F0000003F000000;
                          float32x4_t v552 = vaddq_f32(vaddq_f32(v552, *(float32x4_t *)(v548 + 16 * (v557 + v556 * v551))), *(float32x4_t *)(v548 + 16 * (v558.i32[0] + v558.i32[1] * v551)));
                          v553 -= 2;
                        }
                        while (v553 > 4);
                      }
                      float32x4_t v485 = vmulq_f32(vaddq_f32(v539, _Q9), v480);
                      float32x4_t v486 = vcvtq_f32_s32(vcvtq_s32_f32(v485));
                      float32x4_t v487 = vaddq_f32(vmulq_f32(vsubq_f32(v516, v539), v480), vsubq_f32(v485, vaddq_f32(v486, vcvtq_f32_s32(vcgtq_f32(v486, v485)))));
                      float32x4_t v488 = vaddq_f32(vsubq_f32(vaddq_f32(v530, vmulq_f32(v531, vaddq_f32(v544, v500))), v547), v480);
                      int32x4_t v489 = vcvtq_s32_f32(v488);
                      v488.i64[0] = vaddq_s32(v489, vcgtq_f32(vcvtq_f32_s32(v489), v488)).u64[0];
                      float32x4_t v490 = vaddq_f32(vsubq_f32(vaddq_f32(v530, vmulq_f32(v531, vsubq_f32(v484, v544))), v547), v480);
                      int32x4_t v491 = vcvtq_s32_f32(v490);
                      v490.i64[0] = vaddq_s32(v491, vcgtq_f32(vcvtq_f32_s32(v491), v490)).u64[0];
                      float32x4_t v492 = vmulq_f32(v520, vaddq_f32(vaddq_f32(v552, vmulq_f32(v487, *(float32x4_t *)(v548 + 16 * (v488.i32[0] + v488.i32[1] * v551)))), vmulq_f32(v487, *(float32x4_t *)(v548 + 16 * (v490.i32[0] + v490.i32[1] * v551)))));
                    }
LABEL_180:
                    a5[v481] = v492;
                    float32x4_t v483 = vaddq_f32(v483, _Q9);
                  }
                  ++v481;
                }
                while (v481 != v37);
                float32x4_t v461 = vaddq_f32(v461, _Q9);
                a5 += v602;
                if (++v476 == v15) {
                  goto LABEL_165;
                }
              }
            }
            int v560 = v15;
            uint64_t v463 = v613;
            do
            {
              float32x4_t v461 = vaddq_f32(v461, _Q9);
              a5 = (float32x4_t *)((char *)a5 + v596);
              --v560;
            }
            while (v560);
          }
LABEL_165:
          v459 += 8;
          uint64_t v460 = v463 + 256;
          if (v459 > SHIDWORD(v649[0])) {
            return;
          }
        }
      }
      int v77 = v586;
    }
    uint64_t v607 = 0;
    goto LABEL_47;
  }
  if (v15 >= 1 && (int)v37 >= 1)
  {
    do
    {
LABEL_13:
      bzero(a5, 16 * (v606 + ~v622) + 16);
      a5 += (int)a6;
      --v15;
    }
    while (v15);
  }
}

void HGAnisotropicXForm::HGAnisotropicXForm(HGAnisotropicXForm *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v2 = &unk_1F10DA5F8;
  unint64_t v3 = (HGMipmap *)HGObject::operator new(0x300uLL);
  HGMipmap::HGMipmap(v3);
  *((void *)this + 51) = v3;
  HGMipmap::SetLodFilter((uint64_t)v3, 3, v4);
  int v5 = (HGTransform *)HGObject::operator new(0x90uLL);
  HGTransform::HGTransform(v5);
  *((void *)this + 55) = v5;
  uint64_t v6 = (HGTransform *)HGObject::operator new(0x90uLL);
  HGTransform::HGTransform(v6);
  *((void *)this + 57) = v6;
  unint64_t v7 = (HGTransform *)HGObject::operator new(0x90uLL);
  HGTransform::HGTransform(v7);
  *((void *)this + 56) = v7;
  unint64_t v8 = (HGNode *)HGObject::operator new(0x210uLL);
  HGNode::HGNode(v8);
  *(void *)unint64_t v8 = &unk_1F10DA3A8;
  *((void *)v8 + 63) = 0;
  *((_DWORD *)v8 + 125) = 0;
  *((unsigned char *)v8 + 512) = 0;
  *((_DWORD *)v8 + 4) |= 0x600u;
  *((void *)this + 52) = v8;
  *((void *)this + 53) = 0;
  *((void *)this + 54) = 0x141800000;
}

void sub_1B77EF0BC(_Unwind_Exception *a1)
{
  unint64_t v3 = v2;
  HGObject::operator delete(v3);
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void sub_1B77EF0EC(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGAnisotropicXForm::~HGAnisotropicXForm(HGAnisotropicXForm *this)
{
  *(void *)this = &unk_1F10DA5F8;
  uint64_t v2 = *((void *)this + 55);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
    *((void *)this + 55) = 0;
  }
  uint64_t v3 = *((void *)this + 57);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
    *((void *)this + 57) = 0;
  }
  uint64_t v4 = *((void *)this + 56);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
    *((void *)this + 56) = 0;
  }
  (*(void (**)(void))(**((void **)this + 52) + 24))(*((void *)this + 52));
  (*(void (**)(void))(**((void **)this + 51) + 24))(*((void *)this + 51));

  HGNode::~HGNode((HGNode *)this);
}

{
  void *v1;
  uint64_t vars8;

  HGAnisotropicXForm::~HGAnisotropicXForm(this);

  HGObject::operator delete(v1);
}

uint64_t HGAnisotropicXForm::SetParameter(HGAnisotropicXForm *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  if (*((float *)this + 106) != a3)
  {
    *((float *)this + 106) = a3;
    int v8 = 1;
    if (*((float *)this + 107) == a4) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  int v8 = 0;
  if (*((float *)this + 107) != a4)
  {
LABEL_5:
    *((float *)this + 107) = a4;
    int v8 = 1;
  }
LABEL_6:
  if (*((float *)this + 108) != a5)
  {
    *((float *)this + 108) = a5;
    if ((int)a6 <= 1) {
      int v9 = 1;
    }
    else {
      int v9 = (int)a6;
    }
    if (*((_DWORD *)this + 109) == v9) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  int v9 = (int)a6;
  if ((int)a6 <= 1) {
    int v9 = 1;
  }
  if (*((_DWORD *)this + 109) != v9)
  {
LABEL_19:
    *((_DWORD *)this + 109) = v9;
    goto LABEL_20;
  }
  if (!v8) {
    return 0;
  }
LABEL_20:
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HGAnisotropicXForm::SetInput(HGNode *this, int a2, HGNode *a3)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = HGNode::SetInput(this, a2, a3);
  (*(void (**)(void, void, HGNode *))(**((void **)this + 51) + 120))(*((void *)this + 51), 0, a3);
  return v6;
}

uint64_t HGAnisotropicXForm::SetTransform(HGAnisotropicXForm *this, HGTransform *a2)
{
  uint64_t v3 = **((void **)this + 55);
  if (a2)
  {
    if ((*(unsigned int (**)(void))(v3 + 232))())
    {
      return 0;
    }
    else
    {
      (*(void (**)(void, HGTransform *))(**((void **)this + 55) + 96))(*((void *)this + 55), a2);
      HGNode::ClearBits((HGNode *)this, v6, v7);
      return 1;
    }
  }
  else if ((*(unsigned int (**)(void))(v3 + 224))())
  {
    return 0;
  }
  else
  {
    (*(void (**)(void))(**((void **)this + 55) + 56))(*((void *)this + 55));
    HGNode::ClearBits((HGNode *)this, v8, v9);
    return 1;
  }
}

uint64_t HGAnisotropicXForm::GetTransform(HGAnisotropicXForm *this)
{
  return *((void *)this + 55);
}

BOOL HGAnisotropicXForm::setup(uint64_t a1, const void *a2, HGRect a3, HGRect a4, int *a5, int a6, double a7, double a8, double a9, double a10)
{
  *(HGRect *)(a1 + 464) = a4;
  unsigned int v13 = *(HGTransform **)(a1 + 448);
  LODWORD(a7) = 0.5;
  if (a6 > 0) {
    *(float *)&a7 = 1.5;
  }
  LODWORD(a1CVOpenGLESTextureCacheFlush(this[3], 0) = *(_DWORD *)(a1 + 432);
  uint64_t v14 = hg_clip(v13, a3, a4, a7, *(float *)(a1 + 424), (double)*(int *)(a1 + 436), a10, a5, (int)*(float *)(a1 + 428), (int)*(float *)&a10, 0xFFFFFFFF);
  uint64_t v16 = v15;
  if (a2
  {
    unsigned int MaxTileArea = HGGPURenderer::GetMaxTileArea(v17);
  }
  else
  {
    unsigned int MaxTileArea = 0x1000000;
  }
  unsigned int v19 = a5[1];
  unsigned int v20 = *(float *)(a1 + 432);
  for (unsigned int i = (HIDWORD(v16) - HIDWORD(v14)) * (v16 - v14); MaxTileArea < i && v19 < v20; unsigned int i = ((double)i * 0.25))
    ++v19;
  a5[1] = v19;
  return !HGRectIsNull(v14, v16);
}

HGNode *HGAnisotropicXForm::GetOutput(HGNode *this, HGRenderer *a2)
{
  uint64_t v3 = this;
  Input = HGRenderer::GetInput(a2, this, 0);
  (*(void (**)(void, void))(**((void **)v3 + 57) + 96))(*((void *)v3 + 57), *((void *)v3 + 55));
  (*(void (**)(void))(**((void **)v3 + 57) + 184))(*((void *)v3 + 57));
  if ((*(unsigned int (**)(void))(**((void **)v3 + 57) + 224))(*((void *)v3 + 57))) {
    return Input;
  }
  (*(void (**)(void, void))(**((void **)v3 + 56) + 96))(*((void *)v3 + 56), *((void *)v3 + 57));
  (*(void (**)(void))(**((void **)v3 + 56) + 168))(*((void *)v3 + 56));
  uint64_t DOD = HGRenderer::GetDOD(a2, Input);
  uint64_t v7 = v6;
  LODWORD(v8) = 1.5;
  *(void *)&v20.int var0 = DOD;
  *(void *)&v20.int var2 = v7;
  uint64_t v10 = hg_dod(*((HGTransform **)v3 + 57), v20, v8, v9);
  uint64_t v12 = v11;
  double v13 = (*(double (**)(HGNode *, HGRenderer *))(*(void *)v3 + 312))(v3, a2);
  *(void *)&v21.int var0 = v10;
  *(void *)&v21.int var2 = v12;
  *(void *)&v22.int var0 = DOD;
  *(void *)&v22.int var2 = v7;
  if (HGAnisotropicXForm::setup((uint64_t)v3, a2, v21, v22, (int *)v3 + 120, v14, v13, v15, v16, v17))
  {
    (*(void (**)(void, void, void, float))(**((void **)v3 + 51) + 576))(*((void *)v3 + 51), *((void *)v3 + 57), *((void *)v3 + 56), (float)*((int *)v3 + 109));
    int v18 = HGAnisotropicSampler::Init(*((void *)v3 + 52), (uint64_t)a2, (uint64_t)v3, *((void *)v3 + 51), *((_DWORD *)v3 + 120), *((_DWORD *)v3 + 121), DOD, v7);
    if (*((_DWORD *)v3 + 121) > v18) {
      *((_DWORD *)v3 + 121) = v18;
    }
    return (HGNode *)*((void *)v3 + 52);
  }
  else
  {
    *((void *)v3 + 6CVOpenGLESTextureCacheFlush(this[3], 0) = -1;
  }
  return v3;
}

uint64_t HGAnisotropicXForm::GetDOD(HGAnisotropicXForm *this, HGRenderer *a2, int a3, HGRect a4)
{
  return 0;
}

uint64_t HGAnisotropicXForm::GetROI(HGAnisotropicXForm *this, HGRenderer *a2, int a3, HGRect a4)
{
  return 0;
}

uint64_t HGAnisotropicXForm::GetProgram(HGAnisotropicXForm *this, HGRenderer *a2)
{
  return 0;
}

uint64_t HGAnisotropicXForm::RenderTile(HGAnisotropicXForm *this, HGTile *a2)
{
  return 0;
}

uint64_t HGAnisotropicXForm::Bind(HGAnisotropicXForm *this, HGHandler *a2)
{
  return 0;
}

uint64_t HGAnisotropicXForm::BindTexture(HGAnisotropicXForm *this, HGHandler *a2)
{
  return 0;
}

uint64_t HGAnisotropicXForm::SetLodFilter(uint64_t a1, uint64_t a2, char *a3)
{
  if (HGMipmap::SetLodFilter(*(void *)(a1 + 408), a2, a3) != 1) {
    return 0;
  }
  HGNode::ClearBits((HGNode *)a1, v4, v5);
  return 1;
}

double rho(float *a1, const double *a2, double a3)
{
  double v3 = *a1;
  double v4 = a2[3];
  double v5 = a1[3];
  double v6 = (*a2 - v4 * v3) / v5;
  double v7 = a1[1];
  double v8 = (a2[1] - v4 * v7) / v5;
  double v9 = a2[7];
  double v10 = (a2[4] - v9 * v3) / v5;
  double v11 = (a2[5] - v9 * v7) / v5;
  double v12 = v8 + v11;
  double v13 = v8 - v11;
  double v14 = v6 * v6 + v8 * v8;
  double v15 = v10 * v10 + v11 * v11;
  double v16 = (v6 + v10) * (v6 + v10) + v12 * v12;
  double v17 = (v6 - v10) * (v6 - v10) + v13 * v13;
  if (a3 <= 1.0)
  {
    float v24 = fmax(v14, v15);
    float v25 = fmax(v16, v17);
    return sqrtf(fminf(v24, v25));
  }
  else
  {
    double v18 = fmin(v14, v15);
    double v19 = fmin(v16, v17);
    float v20 = a3;
    if (v19 >= v18)
    {
      double v26 = sqrt(fmax(v14, v15));
      float v27 = v26 / sqrt(v18);
      return v26 / fminf(v27, v20);
    }
    else
    {
      double v21 = sqrt(fmax(v16, v17));
      float v22 = v21 / sqrt(v19);
      return v21 / fminf(v22, v20);
    }
  }
}

uint64_t HGApply1DLUT::Init(HGApply1DLUT *this, int a2, float a3, float a4, char a5, char a6, char a7, char a8, char a9, char a10)
{
  *((unsigned char *)this + 44CVOpenGLESTextureCacheFlush(this[3], 0) = 1;
  *((float *)this + 112) = a3;
  *((float *)this + 113) = a4;
  *((unsigned char *)this + 456) = a5;
  *((unsigned char *)this + 457) = a6;
  *((unsigned char *)this + 458) = a7;
  *((unsigned char *)this + 459) = a8;
  *((_DWORD *)this + 111) = a2;
  *((unsigned char *)this + 461) = a10;
  *((unsigned char *)this + 46CVOpenGLESTextureCacheFlush(this[3], 0) = a9;
  uint64_t v12 = *((void *)this + 52);
  if (v12)
  {
    (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
    *((void *)this + 52) = 0;
  }
  uint64_t v13 = *((void *)this + 51);
  if (v13)
  {
    (*(void (**)(uint64_t))(*(void *)v13 + 24))(v13);
    *((void *)this + 51) = 0;
  }
  uint64_t v14 = HGRectMake4i(0, 0, *((_DWORD *)this + 111) + 1, 1u);
  *((void *)this + 53) = v14;
  *((void *)this + 54) = v15;
  if ((v15 - v14) >= 0x801)
  {
    *((void *)this + 53) = HGRectMake4i(0, 0, 0x800u, ((v15 - v14) >> 11) + 1);
    *((void *)this + 54) = v16;
  }
  double v17 = (HGNode *)HGObject::operator new(0x1F0uLL);
  HGNode::HGNode(v17);
  *(void *)double v17 = &unk_1F10DAAF8;
  *((unsigned char *)v17 + 48CVOpenGLESTextureCacheFlush(this[3], 0) = a9;
  HGNode::SetFlags(v17, 1, 4);
  *((_DWORD *)v17 + 4) |= 0x600u;
  *((void *)this + 51) = v17;
  *((_OWORD *)v17 + 29) = *(_OWORD *)((char *)this + 424);
  float v18 = (float)(*((_DWORD *)this + 111) - 1);
  float v19 = *((float *)this + 112);
  float v20 = v18 / v19;
  float v21 = -(v18 * *((float *)this + 113)) / v19;
  v22.n128_u64[0] = 0x4500000045000000;
  v23.n128_u64[0] = 0x3A0000003A000000;
  (*(void (**)(void, void, float, float, __n128, __n128))(**((void **)this + 51) + 96))(*((void *)this + 51), 0, v20, v21, v22, v23);
  (*(void (**)(void, uint64_t, float, float, float, float))(**((void **)this + 51) + 96))(*((void *)this + 51), 1, (float)(*((_DWORD *)this + 111) - 1), (float)(*((_DWORD *)this + 111) - 1), (float)(*((_DWORD *)this + 111) - 1), (float)(*((_DWORD *)this + 111) - 1));
  v24.n128_f32[0] = (float)(char)(*((unsigned char *)this + 456) - 1);
  v25.n128_f32[0] = (float)(char)(*((unsigned char *)this + 457) - 1);
  v26.n128_f32[0] = (float)(char)(*((unsigned char *)this + 458) - 1);
  v27.n128_f32[0] = (float)(char)(*((unsigned char *)this + 459) - 1);
  float v28 = *(uint64_t (**)(__n128, __n128, __n128, __n128))(**((void **)this + 51) + 96);

  return v28(v24, v25, v26, v27);
}

void sub_1B77EFC7C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  HGObject::operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1B77EFC94(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HGApply1DLUT::HGApply1DLUT(HGApply1DLUT *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v1 = &unk_1F10DA890;
  *(void *)(v1 + 408) = 0;
  *(void *)(v1 + 416) = 0;
  *(unsigned char *)(v1 + 46CVOpenGLESTextureCacheFlush(this[3], 0) = 1;
  HGApply1DLUT::Init((HGApply1DLUT *)v1, 256, 1.0, 0.0, 1, 1, 1, 0, 1, 1);
}

void sub_1B77EFD20(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGApply1DLUT::HGApply1DLUT(HGApply1DLUT *this, int a2, float a3, float a4, char a5, char a6, char a7, char a8, char a9, char a10)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)float v19 = &unk_1F10DA890;
  *((void *)v19 + 51) = 0;
  *((void *)v19 + 52) = 0;
  HGApply1DLUT::Init(v19, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

void sub_1B77EFDE8(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGApply1DLUT::~HGApply1DLUT(HGNode *this)
{
  *(void *)this = &unk_1F10DA890;
  uint64_t v2 = *((void *)this + 52);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 51);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1F10DA890;
  uint64_t v2 = *((void *)this + 52);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 51);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v4);
}

uint64_t HGApply1DLUT::CreateBitmap(HGApply1DLUT *this)
{
  uint64_t v2 = *((void *)this + 52);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  if (*((unsigned char *)this + 461)) {
    uint64_t v3 = 27;
  }
  else {
    uint64_t v3 = 28;
  }
  int v4 = (*((_DWORD *)this + 109) - *((_DWORD *)this + 107)) * (*((_DWORD *)this + 108) - *((_DWORD *)this + 106));
  unint64_t v5 = v4 * HGFormatUtils::bytesPerPixel(v3);
  double v6 = (HGMemory::StorageObject *)HGObject::operator new(0x20uLL);
  HGMemory::StorageObject::StorageObject(v6, v5);
  double v7 = (HGBitmap *)HGObject::operator new(0x80uLL);
  HGBitmap::HGBitmap(v7, *((void *)this + 53), *((void *)this + 54), v3, *((void *)v6 + 2));
  *((void *)this + 52) = v7;
  HGBitmap::SetStorage(v7, v6);
  double v8 = *(uint64_t (**)(HGMemory::StorageObject *))(*(void *)v6 + 24);

  return v8(v6);
}

void sub_1B77F0058(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77F0070(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t HGApply1DLUT::SetLUT(HGApply1DLUT *this, uint64_t (*a2)(void *, unsigned int *, unsigned int *, char *, uint64_t *, float), void *a3, float32x4_t a4)
{
  uint64_t v53 = 0;
  *(void *)int v54 = 0;
  float v8 = *((float *)this + 112);
  float v9 = (float)*((int *)this + 111) + -1.0;
  v4.i32[0] = *((_DWORD *)this + 113);
  *((unsigned char *)this + 44CVOpenGLESTextureCacheFlush(this[3], 0) = 1;
  int32x2_t v52 = v4;
  if (!*((void *)this + 52))
  {
    HGApply1DLUT::CreateBitmap(this);
    int32x2_t v4 = v52;
  }
  double v10 = *(__int16 **)(*((void *)this + 52) + 80);
  uint64_t v11 = *((unsigned int *)this + 111);
  float v12 = v8 / v9;
  if (*((unsigned char *)this + 461))
  {
    if (a2)
    {
      if ((int)v11 >= 1)
      {
        int v13 = 0;
        float32x4_t v50 = (float32x4_t)vdupq_n_s32(0x47800000u);
        int8x16_t v51 = (int8x16_t)vdupq_n_s32(0xC7800000);
        int8x16_t v48 = (int8x16_t)vdupq_n_s32(0xF800000u);
        float32x4_t v49 = (float32x4_t)vdupq_n_s32(0x7800000u);
        while (1)
        {
          uint64_t result = a2(a3, &v54[1], v54, (char *)&v53 + 4, &v53, *(float *)v4.i32 + (float)(v12 * (float)v13));
          if (result) {
            return result;
          }
          v15.i64[0] = __PAIR64__(v54[0], v54[1]);
          v15.i64[1] = __PAIR64__(v53, HIDWORD(v53));
          float32x4_t v16 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v51, (float32x4_t)v15), v51, v15);
          uint32x4_t v17 = (uint32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v16, v50), v48, (int8x16_t)vmulq_f32(v16, v49));
          *(int16x4_t *)double v10 = vmovn_s32((int32x4_t)vorrq_s8(vandq_s8((int8x16_t)vshlq_u32(v17, (uint32x4_t)xmmword_1B8347340), (int8x16_t)xmmword_1B8347350), vandq_s8((int8x16_t)vshlq_u32(v17, (uint32x4_t)xmmword_1B8347360), (int8x16_t)xmmword_1B8347370)));
          v10 += 4;
          ++v13;
          float v12 = v8 / v9;
          v4.i32[0] = v52.i32[0];
          if (v13 >= *((_DWORD *)this + 111)) {
            goto LABEL_37;
          }
        }
      }
    }
    else if ((int)v11 >= 1)
    {
      if (v11 >= 8)
      {
        uint64_t v20 = v11 & 0x7FFFFFF8;
        __n128 v24 = &v10[4 * (v11 & 0xFFFFFFF8)];
        a4 = (float32x4_t)vdupq_lane_s32(v4, 0);
        int32x4_t v25 = (int32x4_t)xmmword_1B8347380;
        int32x4_t v26 = (int32x4_t)xmmword_1B7E74440;
        int8x16_t v27 = (int8x16_t)vdupq_n_s32(0xC7800000);
        float32x4_t v28 = (float32x4_t)vdupq_n_s32(0x47800000u);
        float32x4_t v29 = (float32x4_t)vdupq_n_s32(0x7800000u);
        int8x16_t v30 = (int8x16_t)vdupq_n_s32(0xF800000u);
        v31.i64[0] = 0x7F0000007FLL;
        v31.i64[1] = 0x7F0000007FLL;
        v32.i64[0] = 0x800000008000;
        v32.i64[1] = 0x800000008000;
        v33.i64[0] = 0x800000008;
        v33.i64[1] = 0x800000008;
        uint64_t v34 = v11 & 0xFFFFFFF8;
        do
        {
          int8x16_t v35 = (int8x16_t)vaddq_f32(a4, vmulq_n_f32(vcvtq_f32_s32(v25), v12));
          int8x16_t v36 = (int8x16_t)vaddq_f32(a4, vmulq_n_f32(vcvtq_f32_s32(v26), v12));
          float32x4_t v37 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v27, (float32x4_t)v35), v27, v35);
          float32x4_t v38 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v27, (float32x4_t)v36), v27, v36);
          uint32x4_t v39 = (uint32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v37, v28), v30, (int8x16_t)vmulq_f32(v37, v29));
          uint32x4_t v40 = (uint32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v38, v28), v30, (int8x16_t)vmulq_f32(v38, v29));
          v55.val[0] = vuzp1q_s16((int16x8_t)vorrq_s8(vandq_s8((int8x16_t)vshrq_n_u32(v40, 0xDuLL), v31), vandq_s8((int8x16_t)vshrq_n_u32(v40, 0x10uLL), v32)), (int16x8_t)vorrq_s8(vandq_s8((int8x16_t)vshrq_n_u32(v39, 0xDuLL), v31), vandq_s8((int8x16_t)vshrq_n_u32(v39, 0x10uLL), v32)));
          v55.val[1] = v55.val[0];
          v55.val[2] = v55.val[0];
          v55.val[3] = v55.val[0];
          vst4q_s16(v10, v55);
          v10 += 32;
          int32x4_t v26 = vaddq_s32(v26, v33);
          int32x4_t v25 = vaddq_s32(v25, v33);
          v34 -= 8;
        }
        while (v34);
        if (v20 == v11)
        {
          int8x16_t v15 = (int8x16_t)vdupq_laneq_s32((int32x4_t)v35, 3);
          double v10 = v24;
          goto LABEL_37;
        }
        double v10 = v24;
      }
      else
      {
        LODWORD(v2CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
      }
      do
      {
        a4.f32[0] = *(float *)v4.i32 + (float)(v12 * (float)(int)v20);
        float v41 = -65536.0;
        if (a4.f32[0] >= -65536.0) {
          float v41 = *(float *)v4.i32 + (float)(v12 * (float)(int)v20);
        }
        float v42 = v41 * 1.9259e-34;
        BOOL v43 = v41 <= 65536.0;
        float v44 = 1.2622e-29;
        if (v43) {
          float v44 = v42;
        }
        *(int16x4_t *)double v10 = vdup_n_s16(HIWORD(LODWORD(v44)) & 0x8000 | (LODWORD(v44) >> 13) & 0x7FFF);
        v10 += 4;
        LODWORD(v2CVOpenGLESTextureCacheFlush(this[3], 0) = v20 + 1;
      }
      while (v11 != v20);
      int8x16_t v15 = (int8x16_t)vdupq_lane_s32(*(int32x2_t *)a4.f32, 0);
      goto LABEL_37;
    }
    int8x16_t v15 = 0uLL;
LABEL_37:
    uint64_t result = 0;
    int8x16_t v45 = (int8x16_t)vdupq_n_s32(0xC7800000);
    float32x4_t v46 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v45, (float32x4_t)v15), v45, v15);
    uint32x4_t v47 = (uint32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v46, (float32x4_t)vdupq_n_s32(0x47800000u)), (int8x16_t)vdupq_n_s32(0xF800000u), (int8x16_t)vmulq_f32(v46, (float32x4_t)vdupq_n_s32(0x7800000u)));
    *(int16x4_t *)double v10 = vmovn_s32((int32x4_t)vorrq_s8(vandq_s8((int8x16_t)vshlq_u32(v47, (uint32x4_t)xmmword_1B8347340), (int8x16_t)xmmword_1B8347350), vandq_s8((int8x16_t)vshlq_u32(v47, (uint32x4_t)xmmword_1B8347360), (int8x16_t)xmmword_1B8347370)));
    return result;
  }
  if (!a2)
  {
    if ((int)v11 >= 1)
    {
      int v21 = 0;
      do
      {
        *(float *)int v54 = *(float *)v4.i32 + (float)(v12 * (float)v21);
        v54[1] = v54[0];
        *(float *)&uint64_t v53 = *(float *)v54;
        *((float *)&v53 + 1) = *(float *)v54;
        *(_DWORD *)double v10 = v54[0];
        *((_DWORD *)v10 + 1) = v54[0];
        *((_DWORD *)v10 + 2) = HIDWORD(v53);
        __n128 v22 = v10 + 8;
        *((_DWORD *)v10 + 3) = v53;
        ++v21;
        v10 += 8;
      }
      while (v11 != v21);
      double v10 = v22;
    }
    goto LABEL_24;
  }
  if ((int)v11 < 1)
  {
LABEL_24:
    uint64_t result = 0;
    *(_DWORD *)double v10 = v54[1];
    int v23 = HIDWORD(v53);
    *((_DWORD *)v10 + 1) = v54[0];
    *((_DWORD *)v10 + 2) = v23;
    *((_DWORD *)v10 + 3) = v53;
    return result;
  }
  int v18 = 0;
  while (1)
  {
    uint64_t result = a2(a3, &v54[1], v54, (char *)&v53 + 4, &v53, *(float *)v4.i32 + (float)(v12 * (float)v18));
    if (result) {
      return result;
    }
    *(_DWORD *)double v10 = v54[1];
    *((_DWORD *)v10 + 1) = v54[0];
    *((_DWORD *)v10 + 2) = HIDWORD(v53);
    float v19 = v10 + 8;
    *((_DWORD *)v10 + 3) = v53;
    ++v18;
    v10 += 8;
    float v12 = v8 / v9;
    v4.i32[0] = v52.i32[0];
    if (v18 >= *((_DWORD *)this + 111))
    {
      double v10 = v19;
      goto LABEL_24;
    }
  }
}

uint64_t HGApply1DLUT::SetLUTBitmap(HGApply1DLUT *this, HGBitmap *a2)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  if (!HGRect::IsEqual((HGRect *)((char *)a2 + 20), *(HGRect *)((char *)this + 424))
    || (*((_DWORD *)a2 + 4) - 27) > 1)
  {
    return 0xFFFFFFFFLL;
  }
  int32x2_t v4 = (HGBitmap *)*((void *)this + 52);
  if (v4 != a2)
  {
    *((unsigned char *)this + 44CVOpenGLESTextureCacheFlush(this[3], 0) = 1;
    if (v4) {
      (*(void (**)(HGBitmap *))(*(void *)v4 + 24))(v4);
    }
    *((void *)this + 52) = a2;
    (*(void (**)(HGBitmap *))(*(void *)a2 + 16))(a2);
  }
  return 0;
}

uint64_t HGApply1DLUT::GetOutput(HGNode *this, HGRenderer *a2, float32x4_t a3)
{
  if (!*((void *)this + 52)) {
    HGApply1DLUT::SetLUT((HGApply1DLUT *)this, 0, 0, a3);
  }
  uint64_t v5 = *((void *)this + 51);
  Input = HGRenderer::GetInput(a2, this, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v5 + 120))(v5, 0, Input);
  if (*((unsigned char *)this + 440))
  {
    *((unsigned char *)this + 44CVOpenGLESTextureCacheFlush(this[3], 0) = 0;
    double v7 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
    HGBitmapLoader::HGBitmapLoader(v7, *((HGBitmap **)this + 52));
    if (((*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2) & 1) != 0 || !*((unsigned char *)this + 460))
    {
      (*(void (**)(void, uint64_t, HGBitmapLoader *))(**((void **)this + 51) + 120))(*((void *)this + 51), 1, v7);
    }
    else
    {
      float v8 = (HGTextureWrap *)HGObject::operator new(0x1D0uLL);
      HGTextureWrap::HGTextureWrap(v8);
      HGTextureWrap::SetTextureWrapMode((uint64_t)v8, (const char *)2, v9);
      (*(void (**)(HGTextureWrap *, void, HGBitmapLoader *))(*(void *)v8 + 120))(v8, 0, v7);
      (*(void (**)(HGBitmapLoader *))(*(void *)v7 + 24))(v7);
      (*(void (**)(void, uint64_t, HGTextureWrap *))(**((void **)this + 51) + 120))(*((void *)this + 51), 1, v8);
      double v7 = v8;
    }
    (*(void (**)(HGBitmapLoader *))(*(void *)v7 + 24))(v7);
  }
  return *((void *)this + 51);
}

void sub_1B77F07F4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77F080C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HgcApply1DLUT::~HgcApply1DLUT(HGNode *this)
{
  HGNode::~HGNode(this);

  HGObject::operator delete(v1);
}

uint64_t HgcApply1DLUT::SetParameter(HGNode *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  switch(a2)
  {
    case 2:
      double v7 = (float *)((char *)this + 448);
      uint64_t v8 = 460;
      uint64_t v9 = 456;
      uint64_t v10 = 452;
      goto LABEL_7;
    case 1:
      double v7 = (float *)((char *)this + 432);
      uint64_t v8 = 444;
      uint64_t v9 = 440;
      uint64_t v10 = 436;
      goto LABEL_7;
    case 0:
      double v7 = (float *)((char *)this + 416);
      uint64_t v8 = 428;
      uint64_t v9 = 424;
      uint64_t v10 = 420;
LABEL_7:
      float *v7 = a3;
      *(float *)((char *)this + v1CVOpenGLESTextureCacheFlush(this[3], 0) = a4;
      *(float *)((char *)this + v9) = a5;
      *(float *)((char *)this + v8) = a6;
      break;
  }
  HGNode::ClearBits(this, a2, a7);
  return 1;
}

uint64_t HgcApply1DLUT::RenderTile(float32x4_t *this, HGTile *a2)
{
  return 0;
}

const char *HgcApply1DLUT::GetProgram(HgcApply1DLUT *this, HGRenderer *a2)
{
  return GetApply1DProgram(a2, *((float *)this + 115) < 0.0, *((unsigned __int8 *)this + 480));
}

uint64_t HgcApply1DLUT::Bind(HgcApply1DLUT *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcApply1DLUT::BindTexture(HgcApply1DLUT *this, HGHandler *a2, int a3)
{
  if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, *((unsigned __int8 *)this + 480), *((unsigned __int8 *)this + 480));
    if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
    {
      v7.n128_u64[0] = 0;
      v8.n128_u64[0] = 0;
      v9.n128_u32[0] = 1.0;
      v10.n128_u32[0] = 1.0;
    }
    else
    {
      v7.n128_f32[0] = (float)*((int *)a2 + 60);
      v8.n128_f32[0] = (float)*((int *)a2 + 61);
      v9.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
      v10.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
    }
    (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 3, v7, v8, v9, v10);
    return 0;
  }
  else if (a3)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    int v4 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
    uint64_t result = 0;
    if (!v4)
    {
      (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
      return 0;
    }
  }
  return result;
}

void HgcApply1DLUT::InitProgramDescriptor(HgcApply1DLUT *this, HGProgramDescriptor *a2)
{
}

uint64_t HgcApply1DLUT::GetDOD(HgcApply1DLUT *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcApply1DLUT::GetROI(HgcApply1DLUT *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var0;
  uint64_t v7 = *((void *)this + 58);
  if (((*(uint64_t (**)(HGRenderer *))(*(void *)a2 + 304))(a2) & 1) == 0)
  {
    uint64_t v8 = *((void *)this + 58);
    uint64_t v9 = *((void *)this + 59);
    uint64_t v10 = HGRectMake4i(0, 0, 1u, 0);
    uint64_t v7 = HGRectGrow(v8, v9, v10);
  }
  if (!a3) {
    return v4;
  }
  if (a3 != 1) {
    return 0;
  }
  return v7;
}

void HGApply3DLUT::Init(uint64_t a1, int a2, unsigned int a3, char a4, int a5, char a6, char a7, char a8, float a9, float a10, float a11, float a12, float a13, float a14, char a15)
{
  char v18 = 1;
  *(unsigned char *)(a1 + 464) = 1;
  *(unsigned char *)(a1 + 465) = a4;
  *(_DWORD *)(a1 + 516) = a5;
  *(float *)(a1 + 476) = a9;
  *(float *)(a1 + 48CVOpenGLESTextureCacheFlush(this[3], 0) = a10;
  *(float *)(a1 + 484) = a11;
  *(float *)(a1 + 488) = a12;
  *(float *)(a1 + 492) = a13;
  *(float *)(a1 + 496) = a14;
  if (a11 != 0.0 || a12 != 1.0 || a13 != 0.0 || a14 != 0.0) {
    char v18 = 0;
  }
  *(unsigned char *)(a1 + 50CVOpenGLESTextureCacheFlush(this[3], 0) = v18;
  *(unsigned char *)(a1 + 512) = a6;
  *(unsigned char *)(a1 + 513) = a7;
  *(unsigned char *)(a1 + 514) = a8;
  *(unsigned char *)(a1 + 515) = a15;
  uint64_t v19 = *(void *)(a1 + 416);
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 24))(v19);
  }
  uint64_t v20 = *(void *)(a1 + 424);
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 24))(v20);
  }
  uint64_t v21 = *(void *)(a1 + 408);
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 24))(v21);
  }
  if (a3 <= 0x1C && ((1 << a3) & 0x1B3A0000) != 0) {
    *(_DWORD *)(a1 + 468) = a3;
  }
  *(_DWORD *)(a1 + 472) = a2;
  *(void *)(a1 + 432) = HGRectMake4i(0, 0, a2 * a2 + 1, a2 + 1);
  *(void *)(a1 + 44CVOpenGLESTextureCacheFlush(this[3], 0) = v22;
  *(void *)(a1 + 448) = HGRectMake4i(0, 0, *(_DWORD *)(a1 + 472), 1u);
  *(void *)(a1 + 456) = v23;
  if (*(_DWORD *)(a1 + 516))
  {
    if (*(unsigned char *)(a1 + 500))
    {
      __n128 v24 = (HgcApply3DLUTTetrahedralUniform_basekernel *)HGObject::operator new(0x1B0uLL);
      HgcApply3DLUTTetrahedralUniform_basekernel::HgcApply3DLUTTetrahedralUniform_basekernel(v24);
    }
    int v26 = *(unsigned __int8 *)(a1 + 465);
    int8x16_t v27 = (HgcApply3DLUTTetrahedralFast_basekernel *)HGObject::operator new(0x1B0uLL);
    if (v26) {
      HgcApply3DLUTTetrahedralFast_basekernel::HgcApply3DLUTTetrahedralFast_basekernel(v27);
    }
    HgcApply3DLUTTetrahedral_basekernel::HgcApply3DLUTTetrahedral_basekernel(v27);
  }
  if (*(unsigned char *)(a1 + 500))
  {
    int32x4_t v25 = (HgcApply3DLUTTrilinearUniform_basekernel *)HGObject::operator new(0x1B0uLL);
    HgcApply3DLUTTrilinearUniform_basekernel::HgcApply3DLUTTrilinearUniform_basekernel(v25);
  }
  int v28 = *(unsigned __int8 *)(a1 + 465);
  float32x4_t v29 = (HgcApply3DLUTTrilinearFast_basekernel *)HGObject::operator new(0x1B0uLL);
  if (v28) {
    HgcApply3DLUTTrilinearFast_basekernel::HgcApply3DLUTTrilinearFast_basekernel(v29);
  }
  HgcApply3DLUTTrilinear_basekernel::HgcApply3DLUTTrilinear_basekernel(v29);
}

void sub_1B77F15FC(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77F1610(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77F1624(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77F1638(_Unwind_Exception *a1)
{
  HgcApply3DLUTTrilinear_basekernel::~HgcApply3DLUTTrilinear_basekernel(v1);
  HGObject::operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1B77F1650(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77F1664(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77F1678(_Unwind_Exception *a1)
{
  HgcApply3DLUTTetrahedral_basekernel::~HgcApply3DLUTTetrahedral_basekernel(v1);
  HGObject::operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1B77F1690(_Unwind_Exception *a1)
{
  HgcApply3DLUTTrilinearFast_basekernel::~HgcApply3DLUTTrilinearFast_basekernel(v1);
  HGObject::operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1B77F16A8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77F16BC(_Unwind_Exception *a1)
{
  HgcApply3DLUTTetrahedralFast_basekernel::~HgcApply3DLUTTetrahedralFast_basekernel(v1);
  HGObject::operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1B77F16D4(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77F16E8(_Unwind_Exception *a1)
{
  HgcApply3DLUTTrilinearUniform_basekernel::~HgcApply3DLUTTrilinearUniform_basekernel(v1);
  HGObject::operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1B77F1700(_Unwind_Exception *a1)
{
  HGObject::~HGObject(v1);
  HGObject::operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1B77F1718(_Unwind_Exception *a1)
{
  HgcApply3DLUTTetrahedralUniform_basekernel::~HgcApply3DLUTTetrahedralUniform_basekernel(v1);
  HGObject::operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1B77F1730(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77F1744(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B77F175C(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HGApply3DLUT::HGApply3DLUT(HGNode *a1, int a2, unsigned int a3, char a4, int a5, char a6, char a7, char a8, float a9, float a10, float a11, float a12, float a13, float a14, char a15)
{
  HGNode::HGNode(a1);
  *int v28 = &unk_1F10DAD60;
  v28[52] = 0;
  v28[53] = 0;
  v28[51] = 0;
  HGApply3DLUT::Init((uint64_t)v28, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
}

void sub_1B77F1870(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HGApply3DLUT::~HGApply3DLUT(HGNode *this)
{
  *(void *)this = &unk_1F10DAD60;
  uint64_t v2 = *((void *)this + 52);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 53);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  uint64_t v4 = *((void *)this + 51);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }

  HGNode::~HGNode(this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  uint64_t vars8;

  *(void *)this = &unk_1F10DAD60;
  uint64_t v2 = *((void *)this + 52);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 53);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  uint64_t v4 = *((void *)this + 51);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  HGNode::~HGNode(this);

  HGObject::operator delete(v5);
}

float HGApply3DLUT::InvCubic(HGApply3DLUT *this, float a2)
{
  float result = 0.0;
  if (a2 != 0.0)
  {
    double v5 = a2;
    double v6 = (double)*((int *)this + 118) + -1.0;
    float result = 1.0;
    if (v6 != v5)
    {
      double v7 = *((float *)this + 124);
      float v8 = ((*((float *)this + 121) - v5 / v6) * 27.0 / v7 + *((float *)this + 127)) / 27.0;
      double v9 = v8 * -0.5;
      double v10 = sqrt((float)(*((float *)this + 126) * (float)(*((float *)this + 126) * *((float *)this + 126))) / 27.0+ (float)(v8 * v8) * 0.25);
      float v11 = cbrt(v9 + v10);
      float v12 = cbrt(v9 - v10);
      return (float)(v11 + v12) + *((float *)this + 123) / (v7 * -3.0);
    }
  }
  return result;
}

uint64_t HGApply3DLUT::SetLUT(HGApply3DLUT *this, uint64_t (*a2)(void *, char *, unint64_t *, char *, unint64_t *, float, float, float), void *a3)
{
  unsigned int v5 = 0;
  unint64_t v74 = 0;
  unint64_t v75 = 0;
  *((unsigned char *)this + 464) = 1;
  unsigned int v6 = *((_DWORD *)this + 117);
  if (v6 - 17 <= 0xB) {
    unsigned int v5 = dword_1B83474A4[v6 - 17];
  }
  int v7 = *((_DWORD *)this + 118);
  if (v7 < 1) {
    return 0;
  }
  uint64_t v8 = 0;
  uint64_t v9 = 2 * v5;
  uint64_t v73 = v5;
  uint64_t v10 = 3 * v5;
  uint64_t v71 = 4 * v5;
  float v11 = *(float **)(*((void *)this + 53) + 80);
  while (1)
  {
    uint64_t v69 = v8;
    if (v7 >= 1) {
      break;
    }
LABEL_114:
    uint64_t v8 = v69 + 1;
    if (v69 + 1 >= v7) {
      return 0;
    }
  }
  uint64_t v12 = 0;
  uint64_t v13 = (4 * v8);
  uint64_t v14 = (unsigned char *)(*(void *)(*((void *)this + 52) + 80) + *(void *)(*((void *)this + 52) + 64) * v8);
  int v15 = v7;
LABEL_7:
  while (v15 <= 0)
  {
    if (++v12 >= v15) {
      goto LABEL_114;
    }
  }
  uint64_t v16 = 0;
  uint64_t v70 = v12;
  uint64_t v17 = (4 * v12);
  char v18 = v11;
  while (2)
  {
    float v20 = *((float *)this + 119);
    float v21 = *((float *)this + 120);
    float v22 = (float)(v20 * *v18) + v21;
    float v23 = v21 + (float)(v20 * v11[v17]);
    float v24 = v21 + (float)(v20 * v11[v13]);
    if (a2)
    {
      uint64_t result = a2(a3, (char *)&v75 + 4, &v75, (char *)&v74 + 4, &v74, v22, v23, v24);
      unsigned int v6 = *((_DWORD *)this + 117);
      if (v6 <= 0x19 && ((1 << v6) & 0x30A0000) != 0)
      {
LABEL_16:
        float v27 = *((float *)this + 120);
        float v28 = *((float *)this + 119);
        *(float *)&unint64_t v75 = (float)(*(float *)&v75 - v27) / v28;
        *((float *)&v75 + 1) = (float)(*((float *)&v75 + 1) - v27) / v28;
        *(float *)&unint64_t v74 = (float)(*(float *)&v74 - v27) / v28;
        *((float *)&v74 + 1) = (float)(*((float *)&v74 + 1) - v27) / v28;
      }
    }
    else
    {
      uint64_t result = 0;
      unint64_t v75 = __PAIR64__(LODWORD(v22), LODWORD(v23));
      *((float *)&v74 + 1) = v24;
      LODWORD(v74) = 1065353216;
      if (v6 <= 0x19 && ((1 << v6) & 0x30A0000) != 0) {
        goto LABEL_16;
      }
    }
    if (!result)
    {
      switch(v6)
      {
        case 0x11u:
          float v29 = fminf(*((float *)&v75 + 1) * 255.0, 255.0);
          if ((float)(*((float *)&v75 + 1) * 255.0) >= 0.0) {
            float v30 = v29;
          }
          else {
            float v30 = 0.0;
          }
          float v31 = fminf(*(float *)&v75 * 255.0, 255.0);
          if ((float)(*(float *)&v75 * 255.0) >= 0.0) {
            float v32 = v31;
          }
          else {
            float v32 = 0.0;
          }
          unint64_t v75 = __PAIR64__(LODWORD(v30), LODWORD(v32));
          float v33 = fminf(*((float *)&v74 + 1) * 255.0, 255.0);
          if ((float)(*((float *)&v74 + 1) * 255.0) < 0.0) {
            float v33 = 0.0;
          }
          *((float *)&v74 + 1) = v33;
          *uint64_t v14 = (int)v30;
          v14[v73] = (int)*(float *)&v75;
          v14[v9] = (int)*((float *)&v74 + 1);
          unsigned int v6 = *((_DWORD *)this + 117);
          if (v6 <= 0x15) {
            goto LABEL_109;
          }
          goto LABEL_9;
        case 0x13u:
          float v35 = fminf(*((float *)&v75 + 1) * 65535.0, 65535.0);
          if ((float)(*((float *)&v75 + 1) * 65535.0) >= 0.0) {
            float v36 = v35;
          }
          else {
            float v36 = 0.0;
          }
          float v37 = fminf(*(float *)&v75 * 65535.0, 65535.0);
          if ((float)(*(float *)&v75 * 65535.0) >= 0.0) {
            float v38 = v37;
          }
          else {
            float v38 = 0.0;
          }
          unint64_t v75 = __PAIR64__(LODWORD(v36), LODWORD(v38));
          float v39 = fminf(*((float *)&v74 + 1) * 65535.0, 65535.0);
          if ((float)(*((float *)&v74 + 1) * 65535.0) < 0.0) {
            float v39 = 0.0;
          }
          *((float *)&v74 + 1) = v39;
          *(_WORD *)uint64_t v14 = (int)v36;
          *(_WORD *)&v14[v73] = (int)v38;
          *(_WORD *)&v14[v9] = (int)v39;
          unsigned int v6 = *((_DWORD *)this + 117);
          if (v6 > 0x15) {
            goto LABEL_9;
          }
          goto LABEL_109;
        case 0x14u:
          float v40 = *((float *)&v75 + 1);
          float v41 = -65536.0;
          if (*((float *)&v75 + 1) < -65536.0) {
            float v40 = -65536.0;
          }
          float v42 = v40 * 1.9259e-34;
          BOOL v43 = v40 <= 65536.0;
          float v44 = 1.2622e-29;
          if (!v43) {
            float v42 = 1.2622e-29;
          }
          *(_WORD *)uint64_t v14 = HIWORD(v42) & 0x8000 | (LODWORD(v42) >> 13) & 0x7FFF;
          float v45 = *(float *)&v75;
          if (*(float *)&v75 < -65536.0) {
            float v45 = -65536.0;
          }
          if (v45 <= 65536.0) {
            float v46 = v45 * 1.9259e-34;
          }
          else {
            float v46 = 1.2622e-29;
          }
          *(_WORD *)&v14[v73] = HIWORD(v46) & 0x8000 | (LODWORD(v46) >> 13) & 0x7FFF;
          if (*((float *)&v74 + 1) >= -65536.0) {
            float v41 = *((float *)&v74 + 1);
          }
          if (v41 <= 65536.0) {
            float v44 = v41 * 1.9259e-34;
          }
          *(_WORD *)&v14[v9] = HIWORD(v44) & 0x8000 | (LODWORD(v44) >> 13) & 0x7FFF;
          unsigned int v6 = *((_DWORD *)this + 117);
          if (v6 > 0x15) {
            goto LABEL_9;
          }
          goto LABEL_109;
        case 0x15u:
          *(_DWORD *)uint64_t v14 = HIDWORD(v75);
          *(_DWORD *)&v14[v73] = v75;
          *(_DWORD *)&v14[v9] = HIDWORD(v74);
          unsigned int v6 = *((_DWORD *)this + 117);
          if (v6 > 0x15) {
            goto LABEL_9;
          }
          goto LABEL_109;
        case 0x18u:
          float v47 = fminf(*((float *)&v75 + 1) * 255.0, 255.0);
          if ((float)(*((float *)&v75 + 1) * 255.0) >= 0.0) {
            float v48 = v47;
          }
          else {
            float v48 = 0.0;
          }
          float v49 = fminf(*(float *)&v75 * 255.0, 255.0);
          if ((float)(*(float *)&v75 * 255.0) >= 0.0) {
            float v50 = v49;
          }
          else {
            float v50 = 0.0;
          }
          unint64_t v75 = __PAIR64__(LODWORD(v48), LODWORD(v50));
          float v51 = fminf(*((float *)&v74 + 1) * 255.0, 255.0);
          if ((float)(*((float *)&v74 + 1) * 255.0) >= 0.0) {
            float v52 = v51;
          }
          else {
            float v52 = 0.0;
          }
          float v53 = fminf(*(float *)&v74 * 255.0, 255.0);
          if ((float)(*(float *)&v74 * 255.0) < 0.0) {
            float v53 = 0.0;
          }
          unint64_t v74 = __PAIR64__(LODWORD(v52), LODWORD(v53));
          *uint64_t v14 = (int)v48;
          v14[v73] = (int)*(float *)&v75;
          v14[v9] = (int)*((float *)&v74 + 1);
          v14[v10] = (int)*(float *)&v74;
          unsigned int v6 = *((_DWORD *)this + 117);
          if (v6 > 0x15) {
            goto LABEL_9;
          }
          goto LABEL_109;
        case 0x19u:
          float v54 = fminf(*((float *)&v75 + 1) * 65535.0, 65535.0);
          if ((float)(*((float *)&v75 + 1) * 65535.0) >= 0.0) {
            float v55 = v54;
          }
          else {
            float v55 = 0.0;
          }
          float v56 = fminf(*(float *)&v75 * 65535.0, 65535.0);
          if ((float)(*(float *)&v75 * 65535.0) >= 0.0) {
            float v57 = v56;
          }
          else {
            float v57 = 0.0;
          }
          unint64_t v75 = __PAIR64__(LODWORD(v55), LODWORD(v57));
          float v58 = fminf(*((float *)&v74 + 1) * 65535.0, 65535.0);
          if ((float)(*((float *)&v74 + 1) * 65535.0) >= 0.0) {
            float v59 = v58;
          }
          else {
            float v59 = 0.0;
          }
          float v60 = fminf(*(float *)&v74 * 65535.0, 65535.0);
          if ((float)(*(float *)&v74 * 65535.0) < 0.0) {
            float v60 = 0.0;
          }
          unint64_t v74 = __PAIR64__(LODWORD(v59), LODWORD(v60));
          *(_WORD *)uint64_t v14 = (int)v55;
          *(_WORD *)&v14[v73] = (int)v57;
          *(_WORD *)&v14[v9] = (int)v59;
          *(_WORD *)&v14[v10] = (int)v60;
          unsigned int v6 = *((_DWORD *)this + 117);
          if (v6 > 0x15) {
            goto LABEL_9;
          }
          goto LABEL_109;
        case 0x1Bu:
          float v61 = *((float *)&v75 + 1);
          float v62 = -65536.0;
          if (*((float *)&v75 + 1) < -65536.0) {
            float v61 = -65536.0;
          }
          float v63 = v61 * 1.9259e-34;
          BOOL v43 = v61 <= 65536.0;
          float v64 = 1.2622e-29;
          if (!v43) {
            float v63 = 1.2622e-29;
          }
          *(_WORD *)uint64_t v14 = HIWORD(v63) & 0x8000 | (LODWORD(v63) >> 13) & 0x7FFF;
          float v65 = *(float *)&v75;
          if (*(float *)&v75 < -65536.0) {
            float v65 = -65536.0;
          }
          if (v65 <= 65536.0) {
            float v66 = v65 * 1.9259e-34;
          }
          else {
            float v66 = 1.2622e-29;
          }
          *(_WORD *)&v14[v73] = HIWORD(v66) & 0x8000 | (LODWORD(v66) >> 13) & 0x7FFF;
          float v67 = *((float *)&v74 + 1);
          if (*((float *)&v74 + 1) < -65536.0) {
            float v67 = -65536.0;
          }
          if (v67 <= 65536.0) {
            float v68 = v67 * 1.9259e-34;
          }
          else {
            float v68 = 1.2622e-29;
          }
          *(_WORD *)&v14[v9] = HIWORD(v68) & 0x8000 | (LODWORD(v68) >> 13) & 0x7FFF;
          if (*(float *)&v74 >= -65536.0) {
            float v62 = *(float *)&v74;
          }
          if (v62 <= 65536.0) {
            float v64 = v62 * 1.9259e-34;
          }
          *(_WORD *)&v14[v10] = HIWORD(v64) & 0x8000 | (LODWORD(v64) >> 13) & 0x7FFF;
          unsigned int v6 = *((_DWORD *)this + 117);
          if (v6 <= 0x15) {
            goto LABEL_109;
          }
          goto LABEL_9;
        default:
          *(_DWORD *)uint64_t v14 = HIDWORD(v75);
          *(_DWORD *)&v14[v73] = v75;
          *(_DWORD *)&v14[v9] = HIDWORD(v74);
          *(_DWORD *)&v14[v10] = v74;
          unsigned int v6 = *((_DWORD *)this + 117);
          if (v6 > 0x15) {
            goto LABEL_9;
          }
LABEL_109:
          uint64_t v19 = v10;
          if (((1 << v6) & 0x3A0000) == 0) {
LABEL_9:
          }
            uint64_t v19 = v71;
          v14 += v19;
          ++v16;
          int v7 = *((_DWORD *)this + 118);
          v18 += 4;
          if (v16 < v7) {
            continue;
          }
          int v15 = *((_DWORD *)this + 118);
          uint64_t v12 = v70 + 1;
          if (v70 + 1 >= v7) {
            goto LABEL_114;
          }
          goto LABEL_7;
      }
    }
    return result;
  }
}

uint64_t HGApply3DLUT::SetLUT(uint64_t a1, char *__src, int a3, int a4, int a5, int a6)
{
  *(unsigned char *)(a1 + 464) = 1;
  if (*(_DWORD *)(a1 + 472) == a3)
  {
    unsigned int v6 = __src;
    int v8 = *(_DWORD *)(a1 + 468);
    int v9 = a3;
    switch(v8)
    {
      case 17:
        int v9 = 3 * a3;
        if (a6) {
          goto LABEL_14;
        }
        goto LABEL_51;
      case 19:
      case 20:
        int v9 = 6 * a3;
        if (!a6) {
          goto LABEL_51;
        }
        goto LABEL_14;
      case 21:
        int v9 = 12 * a3;
        if (!a6) {
          goto LABEL_51;
        }
        goto LABEL_14;
      case 24:
        int v9 = 4 * a3;
        goto LABEL_13;
      case 25:
      case 27:
        int v9 = 8 * a3;
        if (!a6) {
          goto LABEL_51;
        }
        goto LABEL_14;
      case 28:
        int v9 = 16 * a3;
        if (!a6) {
          goto LABEL_51;
        }
        goto LABEL_14;
      default:
LABEL_13:
        if (!a6) {
          goto LABEL_51;
        }
LABEL_14:
        if (v8 == a6)
        {
LABEL_51:
          if (a3 >= 1)
          {
            uint64_t v96 = 0;
            size_t v97 = v9;
            uint64_t v98 = a4;
            uint64_t v99 = a5;
            do
            {
              while (a3 <= 0)
              {
                ++v96;
                v6 += v99;
                if (v96 >= a3) {
                  return 0;
                }
              }
              uint64_t v100 = 0;
              uint64_t v101 = 0;
              float32x4_t v102 = v6;
              do
              {
                memcpy((void *)(*(void *)(*(void *)(a1 + 416) + 80)+ v96 * *(void *)(*(void *)(a1 + 416) + 64)+ v100), v102, v97);
                ++v101;
                a3 = *(_DWORD *)(a1 + 472);
                v100 += v97;
                v102 += v98;
              }
              while (v101 < a3);
              ++v96;
              v6 += v99;
            }
            while (v96 < a3);
          }
          return 0;
        }
        if (a6 == 28 && v8 == 27)
        {
          if (a3 >= 1)
          {
            uint64_t v11 = 0;
            uint64_t v12 = *(void *)(a1 + 416);
            uint64_t v13 = *(__int16 **)(v12 + 80);
            uint64_t v14 = *(void *)(v12 + 64);
            uint64_t v15 = a4;
            uint64_t v16 = a3 & 0xFFFFFFF8;
            int8x16_t v17 = (int8x16_t)vdupq_n_s32(0xC7800000);
            float32x4_t v18 = (float32x4_t)vdupq_n_s32(0x47800000u);
            float32x4_t v19 = (float32x4_t)vdupq_n_s32(0x7800000u);
            int8x16_t v20 = (int8x16_t)vdupq_n_s32(0xF800000u);
            v21.i64[0] = 0x7F0000007FLL;
            v21.i64[1] = 0x7F0000007FLL;
            v22.i64[0] = 0x800000008000;
            v22.i64[1] = 0x800000008000;
            float v23 = v13;
            do
            {
              uint64_t v24 = 0;
              int32x4_t v25 = v23;
              int v26 = (const float *)__src;
              do
              {
                float v27 = (int8x16_t *)&v6[v11 * a5 + v24 * v15];
                float v28 = (int16x4_t *)((char *)v13 + v14 * v11 + v24 * v9);
                if (a3 < 8)
                {
                  int v29 = 0;
LABEL_27:
                  int v47 = a3 - v29;
                  do
                  {
                    int8x16_t v48 = *v27++;
                    float32x4_t v49 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v17, (float32x4_t)v48), v17, v48);
                    uint32x4_t v50 = (uint32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v49, v18), v20, (int8x16_t)vmulq_f32(v49, v19));
                    *v28++ = vmovn_s32((int32x4_t)vorrq_s8(vandq_s8((int8x16_t)vshlq_u32(v50, (uint32x4_t)xmmword_1B8347340), (int8x16_t)xmmword_1B8347350), vandq_s8((int8x16_t)vshlq_u32(v50, (uint32x4_t)xmmword_1B8347360), (int8x16_t)xmmword_1B8347370)));
                    --v47;
                  }
                  while (v47);
                  goto LABEL_21;
                }
                v28 += v16;
                v27 += v16;
                uint64_t v30 = a3 & 0xFFFFFFF8;
                float v31 = v25;
                float v32 = v26;
                do
                {
                  float v33 = v32;
                  float32x4x4_t v105 = vld4q_f32(v33);
                  v33 += 16;
                  float32x4_t v34 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v17, v105.val[0]), v17, (int8x16_t)v105.val[0]);
                  float32x4x4_t v106 = vld4q_f32(v33);
                  float32x4_t v35 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v17, v106.val[0]), v17, (int8x16_t)v106.val[0]);
                  uint32x4_t v36 = (uint32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v35, v18), v20, (int8x16_t)vmulq_f32(v35, v19));
                  uint32x4_t v37 = (uint32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v34, v18), v20, (int8x16_t)vmulq_f32(v34, v19));
                  float32x4_t v38 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v17, v106.val[1]), v17, (int8x16_t)v106.val[1]);
                  float32x4_t v39 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v17, v105.val[1]), v17, (int8x16_t)v105.val[1]);
                  uint32x4_t v40 = (uint32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v38, v18), v20, (int8x16_t)vmulq_f32(v38, v19));
                  uint32x4_t v41 = (uint32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v39, v18), v20, (int8x16_t)vmulq_f32(v39, v19));
                  float32x4_t v42 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v17, v106.val[2]), v17, (int8x16_t)v106.val[2]);
                  float32x4_t v43 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v17, v105.val[2]), v17, (int8x16_t)v105.val[2]);
                  uint32x4_t v44 = (uint32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v42, v18), v20, (int8x16_t)vmulq_f32(v42, v19));
                  uint32x4_t v45 = (uint32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v43, v18), v20, (int8x16_t)vmulq_f32(v43, v19));
                  v106.val[0] = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v17, v106.val[3]), v17, (int8x16_t)v106.val[3]);
                  v105.val[0] = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v17, v105.val[3]), v17, (int8x16_t)v105.val[3]);
                  v106.val[1] = (float32x4_t)vuzp1q_s16((int16x8_t)vorrq_s8(vandq_s8((int8x16_t)vshrq_n_u32(v37, 0xDuLL), v21), vandq_s8((int8x16_t)vshrq_n_u32(v37, 0x10uLL), v22)), (int16x8_t)vorrq_s8(vandq_s8((int8x16_t)vshrq_n_u32(v36, 0xDuLL), v21), vandq_s8((int8x16_t)vshrq_n_u32(v36, 0x10uLL), v22)));
                  v105.val[2] = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v106.val[0], v18), v20, (int8x16_t)vmulq_f32(v106.val[0], v19));
                  v105.val[0] = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v105.val[0], v18), v20, (int8x16_t)vmulq_f32(v105.val[0], v19));
                  v106.val[2] = (float32x4_t)vuzp1q_s16((int16x8_t)vorrq_s8(vandq_s8((int8x16_t)vshrq_n_u32(v41, 0xDuLL), v21), vandq_s8((int8x16_t)vshrq_n_u32(v41, 0x10uLL), v22)), (int16x8_t)vorrq_s8(vandq_s8((int8x16_t)vshrq_n_u32(v40, 0xDuLL), v21), vandq_s8((int8x16_t)vshrq_n_u32(v40, 0x10uLL), v22)));
                  v106.val[3] = (float32x4_t)vuzp1q_s16((int16x8_t)vorrq_s8(vandq_s8((int8x16_t)vshrq_n_u32(v45, 0xDuLL), v21), vandq_s8((int8x16_t)vshrq_n_u32(v45, 0x10uLL), v22)), (int16x8_t)vorrq_s8(vandq_s8((int8x16_t)vshrq_n_u32(v44, 0xDuLL), v21), vandq_s8((int8x16_t)vshrq_n_u32(v44, 0x10uLL), v22)));
                  int16x8_t v46 = vuzp1q_s16((int16x8_t)vorrq_s8(vandq_s8((int8x16_t)vshrq_n_u32((uint32x4_t)v105.val[0], 0xDuLL), v21), vandq_s8((int8x16_t)vshrq_n_u32((uint32x4_t)v105.val[0], 0x10uLL), v22)), (int16x8_t)vorrq_s8(vandq_s8((int8x16_t)vshrq_n_u32((uint32x4_t)v105.val[2], 0xDuLL), v21), vandq_s8((int8x16_t)vshrq_n_u32((uint32x4_t)v105.val[2], 0x10uLL), v22)));
                  vst4q_s16(v31, *(int16x8x4_t *)((char *)&v106 + 16));
                  v31 += 32;
                  v32 += 32;
                  v30 -= 8;
                }
                while (v30);
                int v29 = a3 & 0x7FFFFFF8;
                if (v16 != a3) {
                  goto LABEL_27;
                }
LABEL_21:
                ++v24;
                int v26 = (const float *)((char *)v26 + v15);
                int32x4_t v25 = (__int16 *)((char *)v25 + v9);
              }
              while (v24 != a3);
              ++v11;
              __src += a5;
              float v23 = (__int16 *)((char *)v23 + v14);
            }
            while (v11 != a3);
          }
          return 0;
        }
        uint64_t result = 0xFFFFFFFFLL;
        if (a6 != 21 || v8 != 20) {
          return result;
        }
        if (a3 <= 0) {
          return 0;
        }
        uint64_t v51 = 0;
        uint64_t v52 = *(void *)(a1 + 416);
        float v53 = *(__int16 **)(v52 + 80);
        uint64_t v54 = *(void *)(v52 + 64);
        uint64_t v55 = a3 & 0xFFFFFFF8;
        float32x2_t v56 = (float32x2_t)vdup_n_s32(0xC7800000);
        float32x2_t v57 = (float32x2_t)vdup_n_s32(0x47800000u);
        float32x2_t v58 = (float32x2_t)vdup_n_s32(0x7800000u);
        int8x8_t v59 = (int8x8_t)vdup_n_s32(0xF800000u);
        int8x16_t v60 = (int8x16_t)vdupq_n_s32(0xC7800000);
        float32x4_t v61 = (float32x4_t)vdupq_n_s32(0x47800000u);
        float32x4_t v62 = (float32x4_t)vdupq_n_s32(0x7800000u);
        int8x16_t v63 = (int8x16_t)vdupq_n_s32(0xF800000u);
        v64.i64[0] = 0x7F0000007FLL;
        v64.i64[1] = 0x7F0000007FLL;
        v65.i64[0] = 0x800000008000;
        v65.i64[1] = 0x800000008000;
        float v66 = v53;
        float v67 = (const float *)__src;
LABEL_35:
        uint64_t v68 = 0;
        uint64_t v69 = v66;
        uint64_t v70 = v67;
        break;
    }
    while (1)
    {
      uint64_t v71 = (float32x2_t *)&__src[v51 * a5 + v68 * a4];
      uint64_t v72 = (__int16 *)((char *)v53 + v54 * v51 + v68 * v9);
      if (a3 < 8) {
        break;
      }
      v72 += 3 * v55;
      uint64_t v71 = (float32x2_t *)((char *)v71 + 12 * v55);
      uint64_t v74 = a3 & 0xFFFFFFF8;
      unint64_t v75 = v69;
      uint64_t v76 = v70;
      do
      {
        int v77 = v76;
        float32x4x3_t v103 = vld3q_f32(v77);
        v77 += 12;
        float32x4_t v78 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v60, v103.val[0]), v60, (int8x16_t)v103.val[0]);
        int16x8x3_t v104 = (int16x8x3_t)vld3q_f32(v77);
        float32x4_t v79 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v60, (float32x4_t)v104.val[0]), v60, (int8x16_t)v104.val[0]);
        uint32x4_t v80 = (uint32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v78, v61), v63, (int8x16_t)vmulq_f32(v78, v62));
        uint32x4_t v81 = (uint32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v79, v61), v63, (int8x16_t)vmulq_f32(v79, v62));
        float32x4_t v82 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v60, (float32x4_t)v104.val[1]), v60, (int8x16_t)v104.val[1]);
        float32x4_t v83 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v60, v103.val[1]), v60, (int8x16_t)v103.val[1]);
        uint32x4_t v84 = (uint32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v82, v61), v63, (int8x16_t)vmulq_f32(v82, v62));
        uint32x4_t v85 = (uint32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v83, v61), v63, (int8x16_t)vmulq_f32(v83, v62));
        v104.val[0] = (int16x8_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v60, (float32x4_t)v104.val[2]), v60, (int8x16_t)v104.val[2]);
        v103.val[0] = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v60, v103.val[2]), v60, (int8x16_t)v103.val[2]);
        v103.val[2] = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)v104.val[0], v61), v63, (int8x16_t)vmulq_f32((float32x4_t)v104.val[0], v62));
        v103.val[0] = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v103.val[0], v61), v63, (int8x16_t)vmulq_f32(v103.val[0], v62));
        int16x8_t v86 = vuzp1q_s16((int16x8_t)vorrq_s8(vandq_s8((int8x16_t)vshrq_n_u32(v80, 0xDuLL), v64), vandq_s8((int8x16_t)vshrq_n_u32(v80, 0x10uLL), v65)), (int16x8_t)vorrq_s8(vandq_s8((int8x16_t)vshrq_n_u32(v81, 0xDuLL), v64), vandq_s8((int8x16_t)vshrq_n_u32(v81, 0x10uLL), v65)));
        int16x8_t v87 = vuzp1q_s16((int16x8_t)vorrq_s8(vandq_s8((int8x16_t)vshrq_n_u32(v85, 0xDuLL), v64), vandq_s8((int8x16_t)vshrq_n_u32(v85, 0x10uLL), v65)), (int16x8_t)vorrq_s8(vandq_s8((int8x16_t)vshrq_n_u32(v84, 0xDuLL), v64), vandq_s8((int8x16_t)vshrq_n_u32(v84, 0x10uLL), v65)));
        v104.val[0] = vuzp1q_s16((int16x8_t)vorrq_s8(vandq_s8((int8x16_t)vshrq_n_u32((uint32x4_t)v103.val[0], 0xDuLL), v64), vandq_s8((int8x16_t)vshrq_n_u32((uint32x4_t)v103.val[0], 0x10uLL), v65)), (int16x8_t)vorrq_s8(vandq_s8((int8x16_t)vshrq_n_u32((uint32x4_t)v103.val[2], 0xDuLL), v64), vandq_s8((int8x16_t)vshrq_n_u32((uint32x4_t)v103.val[2], 0x10uLL), v65)));
        vst3q_s16(v75, v104);
        v75 += 24;
        v76 += 24;
        v74 -= 8;
      }
      while (v74);
      int v73 = a3 & 0x7FFFFFF8;
      if (v55 != a3) {
        goto LABEL_42;
      }
LABEL_36:
      ++v68;
      uint64_t v70 = (const float *)((char *)v70 + a4);
      uint64_t v69 = (__int16 *)((char *)v69 + v9);
      if (v68 == a3)
      {
        ++v51;
        float v67 = (const float *)((char *)v67 + a5);
        float v66 = (__int16 *)((char *)v66 + v54);
        if (v51 == a3) {
          return 0;
        }
        goto LABEL_35;
      }
    }
    int v73 = 0;
LABEL_42:
    int v88 = a3 - v73;
    do
    {
      float32x2_t v89 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v56, *v71), (int8x8_t)v56, (int8x8_t)*v71);
      uint32x2_t v90 = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v89, v57), v59, (int8x8_t)vmul_f32(v89, v58));
      int8x8_t v91 = vorr_s8(vand_s8((int8x8_t)vshl_u32(v90, (uint32x2_t)0xFFFFFFF3FFFFFFF0), (int8x8_t)0x7FFF00008000), vand_s8((int8x8_t)vshl_u32(v90, (uint32x2_t)0xFFFFFFF0FFFFFFF3), (int8x8_t)0x800000007FFFLL));
      v72[1] = v91.i16[2];
      *uint64_t v72 = v91.i16[0];
      float v92 = v71[1].f32[0];
      if (v92 < -65536.0) {
        float v92 = -65536.0;
      }
      float v93 = v92 * 1.9259e-34;
      BOOL v94 = v92 <= 65536.0;
      float v95 = 1.2622e-29;
      if (v94) {
        float v95 = v93;
      }
      v72[2] = HIWORD(v95) & 0x8000 | (LODWORD(v95) >> 13) & 0x7FFF;
      uint64_t v71 = (float32x2_t *)((char *)v71 + 12);
      v72 += 3;
      --v88;
    }
    while (v88);
    goto LABEL_36;
  }
  return 0xFFFFFFFFLL;
}

uint64_t HGApply3DLUT::SetLUTBitmap(HGRect *this, HGBitmap *a2)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  if (!HGRect::IsEqual((HGRect *)((char *)a2 + 20), this[27])) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v4 = *((_DWORD *)a2 + 4);
  BOOL v5 = v4 > 0x1C;
  int v6 = (1 << v4) & 0x1B3A0000;
  if (v5 || v6 == 0) {
    return 0xFFFFFFFFLL;
  }
  int v8 = *(HGBitmap **)&this[26].var0;
  if (v8 != a2)
  {
    LOBYTE(this[29].varCVOpenGLESTextureCacheFlush(this[3], 0) = 1;
    if (v8) {
      (*(void (**)(HGBitmap *))(*(void *)v8 + 24))(v8);
    }
    *(void *)&this[26].int var0 = a2;
    (*(void (**)(HGBitmap *))(*(void *)a2 + 16))(a2);
  }
  return 0;
}

uint64_t HGApply3DLUT::GetOutput(HGNode *this, HGRenderer *a2)
{
  uint64_t v4 = *((void *)this + 51);
  Input = HGRenderer::GetInput(a2, this, 0);
  (*(void (**)(uint64_t, void, HGNode *))(*(void *)v4 + 120))(v4, 0, Input);
  if (HGRenderer::GetInput(a2, this, 1u))
  {
    uint64_t v6 = *((void *)this + 51);
    int v7 = HGRenderer::GetInput(a2, this, 1u);
    (*(void (**)(uint64_t, uint64_t, HGNode *))(*(void *)v6 + 120))(v6, 1, v7);
    return *((void *)this + 51);
  }
  if (!*((unsigned char *)this + 464)) {
    return *((void *)this + 51);
  }
  *((unsigned char *)this + 464) = 0;
  int v9 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
  HGBitmapLoader::HGBitmapLoader(v9, *((HGBitmap **)this + 52));
  (*(void (**)(void, uint64_t, HGBitmapLoader *))(**((void **)this + 51) + 120))(*((void *)this + 51), 1, v9);
  (*(void (**)(HGBitmapLoader *))(*(void *)v9 + 24))(v9);
  return *((void *)this + 51);
}

void sub_1B77F2BD0(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HgcApply3DLUTTrilinearUniform::~HgcApply3DLUTTrilinearUniform(HGNode *this)
{
  HgcApply3DLUTTrilinearUniform_basekernel::~HgcApply3DLUTTrilinearUniform_basekernel(this);

  HGObject::operator delete(v1);
}

uint64_t HgcApply3DLUTTrilinearUniform::GetDOD(HgcApply3DLUTTrilinearUniform *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcApply3DLUTTrilinearUniform::GetROI(HgcApply3DLUTTrilinearUniform *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var0;
  uint64_t result = HGRectMake4i(0, 0, *((_DWORD *)this + 104) * *((_DWORD *)this + 104) + 1, *((_DWORD *)this + 104) + 1);
  if (a3 != 1)
  {
    if (a3) {
      return 0;
    }
    else {
      return v4;
    }
  }
  return result;
}

void HgcApply3DLUTTrilinearFast::~HgcApply3DLUTTrilinearFast(HGNode *this)
{
  HgcApply3DLUTTrilinearFast_basekernel::~HgcApply3DLUTTrilinearFast_basekernel(this);

  HGObject::operator delete(v1);
}

uint64_t HgcApply3DLUTTrilinearFast::GetDOD(HgcApply3DLUTTrilinearFast *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcApply3DLUTTrilinearFast::GetROI(HgcApply3DLUTTrilinearFast *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var0;
  uint64_t result = HGRectMake4i(0, 0, *((_DWORD *)this + 104) * *((_DWORD *)this + 104) + 1, *((_DWORD *)this + 104) + 1);
  if (a3 != 1)
  {
    if (a3) {
      return 0;
    }
    else {
      return v4;
    }
  }
  return result;
}

void HgcApply3DLUTTrilinear::~HgcApply3DLUTTrilinear(HGNode *this)
{
  HgcApply3DLUTTrilinear_basekernel::~HgcApply3DLUTTrilinear_basekernel(this);

  HGObject::operator delete(v1);
}

uint64_t HgcApply3DLUTTrilinear::GetDOD(HgcApply3DLUTTrilinear *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcApply3DLUTTrilinear::GetROI(HgcApply3DLUTTrilinear *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var0;
  uint64_t v7 = HGRectMake4i(0, 0, *((_DWORD *)this + 104) * *((_DWORD *)this + 104) + 1, *((_DWORD *)this + 104) + 1);
  uint64_t v8 = HGRectMake4i(0, 0, *((_DWORD *)this + 104), 1u);
  if (a3 == 2) {
    return v8;
  }
  if (a3 != 1)
  {
    if (a3) {
      return 0;
    }
    else {
      return v4;
    }
  }
  return v7;
}

void HgcApply3DLUTTetrahedralUniform::~HgcApply3DLUTTetrahedralUniform(HGNode *this)
{
  HgcApply3DLUTTetrahedralUniform_basekernel::~HgcApply3DLUTTetrahedralUniform_basekernel(this);

  HGObject::operator delete(v1);
}

uint64_t HgcApply3DLUTTetrahedralUniform::GetDOD(HgcApply3DLUTTetrahedralUniform *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcApply3DLUTTetrahedralUniform::GetROI(HgcApply3DLUTTetrahedralUniform *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var0;
  uint64_t result = HGRectMake4i(0, 0, *((_DWORD *)this + 104) * *((_DWORD *)this + 104) + 1, *((_DWORD *)this + 104) + 1);
  if (a3 != 1)
  {
    if (a3) {
      return 0;
    }
    else {
      return v4;
    }
  }
  return result;
}

void HgcApply3DLUTTetrahedralFast::~HgcApply3DLUTTetrahedralFast(HGNode *this)
{
  HgcApply3DLUTTetrahedralFast_basekernel::~HgcApply3DLUTTetrahedralFast_basekernel(this);

  HGObject::operator delete(v1);
}

uint64_t HgcApply3DLUTTetrahedralFast::GetDOD(HgcApply3DLUTTetrahedralFast *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcApply3DLUTTetrahedralFast::GetROI(HgcApply3DLUTTetrahedralFast *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var0;
  uint64_t result = HGRectMake4i(0, 0, *((_DWORD *)this + 104) * *((_DWORD *)this + 104) + 1, *((_DWORD *)this + 104) + 1);
  if (a3 != 1)
  {
    if (a3) {
      return 0;
    }
    else {
      return v4;
    }
  }
  return result;
}

void HgcApply3DLUTTetrahedral::~HgcApply3DLUTTetrahedral(HGNode *this)
{
  HgcApply3DLUTTetrahedral_basekernel::~HgcApply3DLUTTetrahedral_basekernel(this);

  HGObject::operator delete(v1);
}

uint64_t HgcApply3DLUTTetrahedral::GetDOD(HgcApply3DLUTTetrahedral *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcApply3DLUTTetrahedral::GetROI(HgcApply3DLUTTetrahedral *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var0;
  uint64_t v7 = HGRectMake4i(0, 0, *((_DWORD *)this + 104) * *((_DWORD *)this + 104) + 1, *((_DWORD *)this + 104) + 1);
  uint64_t v8 = HGRectMake4i(0, 0, *((_DWORD *)this + 104), 1u);
  if (a3 == 2) {
    return v8;
  }
  if (a3 != 1)
  {
    if (a3) {
      return 0;
    }
    else {
      return v4;
    }
  }
  return v7;
}

void HGStorage3DLUT::~HGStorage3DLUT(HGStorage3DLUT *this)
{
  *(void *)this = &unk_1F10DBE38;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    MEMORY[0x1BA9BFB70](v2, 0x1000C8077774924);
  }
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;

  HGObject::~HGObject(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F10DBE38;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    MEMORY[0x1BA9BFB70](v2, 0x1000C8077774924);
  }
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  HGObject::~HGObject(this);

  HGObject::operator delete(v3);
}

void HGMetalTexture::~HGMetalTexture(HGMetalTexture *this)
{
  *(void *)this = &unk_1F10DBE88;
  uint64_t v2 = (std::mutex *)((char *)this + 176);
  v6.__m_ = (std::unique_lock<std::mutex>::mutex_type *)((char *)this + 176);
  v6.__owns_ = 1;
  std::mutex::lock((std::mutex *)((char *)this + 176));
  uint64_t m = v2;
  if (!*((unsigned char *)this + 171)) {
    goto LABEL_5;
  }
  do
    std::condition_variable::wait((std::condition_variable *)this + 5, &v6);
  while (*((unsigned char *)this + 171));
  if (v6.__owns_)
  {
    uint64_t m = v6.__m_;
LABEL_5:
    std::mutex::unlock(m);
  }
  uint64_t v4 = (uint64_t *)*((void *)this + 16);
  if (v4) {
    HGMetalTexturePool::releaseTexture(v4, *((void *)this + 18));
  }
  else {

  }
  *((void *)this + 16) = 0;
  *((void *)this + 17) = 0;
  *((void *)this + 18) = 0;
  std::condition_variable::~condition_variable((std::condition_variable *)this + 5);
  std::mutex::~mutex(v2);
  HGBitmap::~HGBitmap((HGBitmap *)this, v5);
}

{
  void *v1;
  uint64_t vars8;

  HGMetalTexture::~HGMetalTexture(this);

  HGObject::operator delete(v1);
}

void HGMetalTexture::WaitForCopy(HGMetalTexture *this)
{
  v2.__m_ = (std::unique_lock<std::mutex>::mutex_type *)((char *)this + 176);
  v2.__owns_ = 1;
  std::mutex::lock((std::mutex *)((char *)this + 176));
  if (!*((unsigned char *)this + 171)) {
    goto LABEL_4;
  }
  do
    std::condition_variable::wait((std::condition_variable *)this + 5, &v2);
  while (*((unsigned char *)this + 171));
  if (v2.__owns_) {
LABEL_4:
  }
    std::mutex::unlock(v2.__m_);
}

void *HGMetalTexture::hasComputeUsage(HGMetalTexture *this)
{
  uint64_t result = (void *)*((void *)this + 18);
  if (result) {
    return (void *)(((unint64_t)[result usage] >> 1) & 1);
  }
  return result;
}

uint64_t HGMetalTexture::GetTextureRect(HGMetalTexture *this)
{
  BOOL IsZero = HGRect::IsZero((HGRect *)((char *)this + 152));
  uint64_t v3 = 152;
  if (IsZero) {
    uint64_t v3 = 20;
  }
  return *(void *)((char *)this + v3);
}

void HGMetalTexture::CopyManagedTextureData(HGMetalTexture *this, HGBitmap *a2, HGRect a3)
{
  uint64_t v3 = *(void *)&a3.var2;
  uint64_t v4 = *(void *)&a3.var0;
  uint64_t v7 = (void *)*((void *)this + 18);
  if (v7 && [v7 storageMode] == 2)
  {
    uint64_t v8 = "HGMetalTexture::CopyTextureData failed. Texture has private storage.";
LABEL_17:
    HGLogger::warning((HGLogger *)v8, (const char *)a2, *(char **)&a3.var0);
    return;
  }
  if (!a2 || !*((void *)a2 + 10))
  {
    uint64_t v8 = "HGMetalTexture::ReplaceManagedTextureData failed. No destination data.";
    goto LABEL_17;
  }
  uint64_t v9 = HGRectIntersection(*(void *)((char *)this + 20), *(void *)((char *)this + 28), *(void *)((char *)a2 + 20), *(void *)((char *)a2 + 28));
  *(void *)&v30.int var0 = HGRectIntersection(v9, v10, v4, v3);
  *(void *)&v30.int var2 = v11;
  if (!HGRect::IsNull(&v30))
  {
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v29, "metal_osx", 1, "HGMetalTexture::CopyManagedTextureData()");
    int v28 = 4612;
    kdebug_trace();
    unint64_t v12 = HGBitmap::byteOffset(a2, v30.var0, v30.var1);
    uint64_t v13 = *((void *)a2 + 10);
    unint64_t v14 = HGFormatUtils::collapseRectForFormat((uint64_t *)&v30.var0, *((_DWORD *)this + 4));
    uint64_t v16 = v15;
    if (HGRect::IsZero((HGRect *)((char *)this + 152))) {
      int8x16_t v17 = (char *)this + 20;
    }
    else {
      int8x16_t v17 = (char *)this + 152;
    }
    uint64_t v18 = *(void *)v17;
    BOOL IsZero = HGRect::IsZero((HGRect *)((char *)this + 152));
    uint64_t v20 = 152;
    if (IsZero) {
      uint64_t v20 = 20;
    }
    int8x16_t v21 = (void *)*((void *)this + 18);
    uint64_t v22 = *((void *)a2 + 8);
    uint64_t v23 = (HIDWORD(v14) - *(_DWORD *)((char *)this + v20 + 4));
    v27[0] = (v14 - v18);
    v27[1] = v23;
    void v27[2] = 0;
    void v27[3] = (v16 - v14);
    v27[4] = (HIDWORD(v16) - HIDWORD(v14));
    v27[5] = 1;
    [v21 getBytes:v13 + v12 bytesPerRow:v22 fromRegion:v27 mipmapLevel:0];
    unsigned __int8 v26 = atomic_load(HGLogger::_enabled);
    if (v26) {
      HGLogger::log((HGLogger *)"mtl_perf_validation", (const char *)1, (HGLogger *)"HGMTL PERF WARNING - MTLTexture.getBytes: slow download from managed texture (prefer a BlitEncoder)\n", v24, v25);
    }
    kdebug_trace();
    HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v29);
  }
}

void sub_1B77F35E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, char a17, __int16 a18, char a19)
{
}

void HGMetalTexture::ReplaceManagedTextureData(HGMetalTexture *this, HGBitmap *a2, HGRect a3, int a4)
{
  uint64_t v5 = *(void *)&a3.var2;
  uint64_t v6 = *(void *)&a3.var0;
  uint64_t v9 = (void *)*((void *)this + 18);
  if (v9 && [v9 storageMode] == 2)
  {
    uint64_t v10 = "HGMetalTexture::ReplaceManagedTextureData failed. Texture has private storage.";
LABEL_16:
    HGLogger::warning((HGLogger *)v10, (const char *)a2, *(char **)&a3.var0);
    return;
  }
  if (!a2 || !*((void *)a2 + 10))
  {
    uint64_t v10 = "HGMetalTexture::ReplaceManagedTextureData failed. No source data.";
    goto LABEL_16;
  }
  uint64_t v11 = HGRectIntersection(*(void *)((char *)this + 20), *(void *)((char *)this + 28), *(void *)((char *)a2 + 20), *(void *)((char *)a2 + 28));
  *(void *)&v38.int var0 = HGRectIntersection(v11, v12, v6, v5);
  *(void *)&v38.int var2 = v13;
  if (!HGRect::IsNull(&v38))
  {
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v37, "metal_osx", 1, "HGMetalTexture::ReplaceManagedTextureData()");
    unint64_t v14 = HGBitmap::byteOffset(a2, v38.var0, v38.var1);
    uint64_t v15 = *((void *)a2 + 10);
    unint64_t v16 = HGFormatUtils::collapseRectForFormat((uint64_t *)&v38.var0, *((_DWORD *)this + 4));
    uint64_t v18 = v17;
    if (HGRect::IsZero((HGRect *)((char *)this + 152))) {
      float32x4_t v19 = (char *)this + 20;
    }
    else {
      float32x4_t v19 = (char *)this + 152;
    }
    int v20 = *(_DWORD *)v19;
    BOOL IsZero = HGRect::IsZero((HGRect *)((char *)this + 152));
    uint64_t v22 = v15 + v14;
    unint64_t v23 = HIDWORD(v16);
    uint64_t v24 = (v16 - v20);
    if (IsZero) {
      int32x4_t v25 = (char *)this + 20;
    }
    else {
      int32x4_t v25 = (char *)this + 152;
    }
    uint64_t v26 = (HIDWORD(v16) - *((_DWORD *)v25 + 1));
    uint64_t v27 = (v18 - v16);
    uint64_t v28 = (HIDWORD(v18) - v23);
    if (a4)
    {
      HGBitmap::SetStorage((HGBitmap *)this, (HGObject *)a2);
      std::mutex::lock((std::mutex *)((char *)this + 176));
      *((unsigned char *)this + 171) = 1;
      std::condition_variable::notify_all((std::condition_variable *)this + 5);
      std::mutex::unlock((std::mutex *)((char *)this + 176));
      global_queue = dispatch_get_global_queue(2, 0);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = *(void *)"";
      block[2] = ___ZN14HGMetalTexture25ReplaceManagedTextureDataEP8HGBitmap6HGRectb_block_invoke;
      block[3] = &__block_descriptor_104_e5_v8__0l;
      block[4] = this;
      block[5] = v24;
      block[6] = v26;
      block[7] = 0;
      block[8] = v27;
      block[9] = v28;
      block[10] = 1;
      block[11] = v22;
      block[12] = a2;
      dispatch_async(global_queue, block);
    }
    else
    {
      int v35 = 4614;
      kdebug_trace();
      float v32 = (void *)*((void *)this + 18);
      v34[0] = v24;
      v34[1] = v26;
      v34[2] = 0;
      uint64_t v34[3] = v27;
      v34[4] = v28;
      v34[5] = 1;
      [v32 replaceRegion:v34 mipmapLevel:0 withBytes:v22 bytesPerRow:*((void *)a2 + 8)];
      kdebug_trace();
    }
    unsigned __int8 v33 = atomic_load(HGLogger::_enabled);
    if (v33) {
      HGLogger::log((HGLogger *)"mtl_perf_validation", (const char *)1, (HGLogger *)"HGMTL PERF WARNING - MTLTexture.replaceRegion: slow upload into managed texture (%d x %d) (data is probably not page-aligned)\n", v30, v31, (*((_DWORD *)a2 + 7) - *((_DWORD *)a2 + 5)), (*((_DWORD *)a2 + 8) - *((_DWORD *)a2 + 6)));
    }
    HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v37);
  }
}

void sub_1B77F38F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, char a19)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a19);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v19 - 120));
  _Unwind_Resume(a1);
}

void sub_1B77F3914(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 120));
  _Unwind_Resume(a1);
}

void sub_1B77F3928(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 120));
  _Unwind_Resume(a1);
}

void sub_1B77F393C(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 120));
  _Unwind_Resume(a1);
}

void sub_1B77F3950(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 120));
  _Unwind_Resume(a1);
}

void sub_1B77F3964(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 120));
  _Unwind_Resume(a1);
}

void sub_1B77F3978(_Unwind_Exception *a1)
{
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v1 - 120));
  _Unwind_Resume(a1);
}

uint64_t ___ZN14HGMetalTexture25ReplaceManagedTextureDataEP8HGBitmap6HGRectb_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v7 = 4614;
  kdebug_trace();
  uint64_t v3 = *(void **)(v2 + 144);
  long long v4 = *(_OWORD *)(a1 + 56);
  v6[0] = *(_OWORD *)(a1 + 40);
  v6[1] = v4;
  void v6[2] = *(_OWORD *)(a1 + 72);
  [v3 replaceRegion:v6 mipmapLevel:0 withBytes:*(void *)(a1 + 88) bytesPerRow:*(void *)(*(void *)(a1 + 96) + 64)];
  std::mutex::lock((std::mutex *)(v2 + 176));
  *(unsigned char *)(v2 + 171) = 0;
  std::condition_variable::notify_all((std::condition_variable *)(v2 + 240));
  std::mutex::unlock((std::mutex *)(v2 + 176));
  return kdebug_trace();
}

void sub_1B77F3A48(_Unwind_Exception *a1)
{
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)(v1 - 20));
  _Unwind_Resume(a1);
}

void HGMetalTexture::InitializeBorders(HGMetalTexture *this)
{
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v93, "metal_osx", 1, "HGMetalTexture::InitializeBorders()");
  unint64_t v2 = HGFormatUtils::collapseRectForFormat((uint64_t *)((char *)this + 20), *((_DWORD *)this + 4));
  unint64_t v4 = v3;
  if (HGRect::IsZero((HGRect *)((char *)this + 152))) {
    uint64_t v5 = (uint64_t *)((char *)this + 20);
  }
  else {
    uint64_t v5 = (uint64_t *)((char *)this + 152);
  }
  uint64_t v6 = *v5;
  unint64_t v7 = v5[1];
  if (HGRectIsEqual(v2, v4, *v5, v7)) {
    goto LABEL_86;
  }
  std::string __p = 0;
  int8x8_t v91 = 0;
  unint64_t v92 = 0;
  unint64_t v84 = HIDWORD(v2);
  if (SHIDWORD(v6) >= SHIDWORD(v2))
  {
    unsigned int v12 = 0;
    unint64_t v13 = HIDWORD(v7);
    unint64_t v14 = HIDWORD(v4);
    unint64_t v82 = HIDWORD(v4);
    if (SHIDWORD(v7) > SHIDWORD(v4)) {
      goto LABEL_22;
    }
LABEL_8:
    if ((int)v6 < (int)v2) {
      goto LABEL_42;
    }
    goto LABEL_9;
  }
  uint64_t v8 = HGRectMake4i(v6, HIDWORD(v6), v7, HIDWORD(v2));
  uint64_t v10 = v8;
  uint64_t v11 = v9;
  uint64_t v15 = (v91 - (unsigned char *)__p) >> 4;
  unint64_t v16 = v15 + 1;
  if ((unint64_t)(v15 + 1) >> 60) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v17 = v92 - (void)__p;
  if ((uint64_t)(v92 - (void)__p) >> 3 > v16) {
    unint64_t v16 = v17 >> 3;
  }
  if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v18 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v18 = v16;
  }
  if (v18)
  {
    uint64_t v83 = v8;
    if (v18 >> 60) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v19 = (char *)operator new(16 * v18);
    uint64_t v10 = v83;
    int v20 = (uint64_t *)&v19[16 * ((v91 - (unsigned char *)__p) >> 4)];
    int8x16_t v21 = &v19[16 * v18];
    *int v20 = v83;
    v20[1] = v11;
    uint64_t v22 = (uint64_t)(v20 + 2);
  }
  else
  {
    int v20 = (uint64_t *)(16 * v15);
    int8x16_t v21 = 0;
    *int v20 = v8;
    v20[1] = v9;
    uint64_t v22 = 16 * v15 + 16;
  }
  std::string __p = v20;
  unint64_t v92 = (unint64_t)v21;
  int8x8_t v91 = (char *)v22;
  unsigned int v12 = (HIDWORD(v11) - HIDWORD(v10)) * (v11 - v10);
  unint64_t v13 = HIDWORD(v7);
  unint64_t v14 = HIDWORD(v4);
  unint64_t v82 = HIDWORD(v4);
  if (SHIDWORD(v7) <= SHIDWORD(v4)) {
    goto LABEL_8;
  }
LABEL_22:
  unsigned int v80 = v12;
  uint64_t v23 = HGRectMake4i(v6, v14, v7, v13);
  uint64_t v25 = v23;
  uint64_t v26 = v24;
  uint64_t v27 = v91;
  if ((unint64_t)v91 < v92)
  {
    *(void *)int8x8_t v91 = v23;
    *((void *)v27 + 1) = v24;
    uint64_t v28 = (uint64_t)(v27 + 16);
    goto LABEL_39;
  }
  int v29 = (char *)__p;
  uint64_t v30 = (v91 - (unsigned char *)__p) >> 4;
  unint64_t v31 = v30 + 1;
  if ((unint64_t)(v30 + 1) >> 60) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v32 = v92 - (void)__p;
  if ((uint64_t)(v92 - (void)__p) >> 3 > v31) {
    unint64_t v31 = v32 >> 3;
  }
  if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v33 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v33 = v31;
  }
  if (v33)
  {
    uint64_t v79 = v23;
    if (v33 >> 60) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    float32x4_t v34 = (char *)operator new(16 * v33);
    uint64_t v25 = v79;
    int v35 = (uint64_t *)&v34[16 * ((v91 - (unsigned char *)__p) >> 4)];
    uint32x4_t v36 = &v34[16 * v33];
    *int v35 = v79;
    v35[1] = v26;
    uint64_t v28 = (uint64_t)(v35 + 2);
    if (v27 == v29) {
      goto LABEL_37;
    }
  }
  else
  {
    int v35 = (uint64_t *)(16 * v30);
    uint32x4_t v36 = 0;
    *int v35 = v23;
    v35[1] = v24;
    uint64_t v28 = 16 * v30 + 16;
    if (v27 == v29) {
      goto LABEL_37;
    }
  }
  do
  {
    *((_OWORD *)v35 - 1) = *((_OWORD *)v27 - 1);
    v35 -= 2;
    v27 -= 16;
  }
  while (v27 != v29);
  uint64_t v27 = (char *)__p;
LABEL_37:
  std::string __p = v35;
  int8x8_t v91 = (char *)v28;
  unint64_t v92 = (unint64_t)v36;
  unsigned int v12 = v80;
  if (v27)
  {
    uint32x4_t v37 = v27;
    uint64_t v38 = v25;
    operator delete(v37);
    uint64_t v25 = v38;
  }
LABEL_39:
  LODWORD(v14) = v82;
  int8x8_t v91 = (char *)v28;
  if (v12 <= (HIDWORD(v26) - HIDWORD(v25)) * ((int)v26 - (int)v25)) {
    unsigned int v12 = (HIDWORD(v26) - HIDWORD(v25)) * (v26 - v25);
  }
  if ((int)v6 < (int)v2)
  {
LABEL_42:
    unsigned int v81 = v12;
    uint64_t v39 = HGRectMake4i(v6, HIDWORD(v2), v2, v14);
    uint64_t v41 = v39;
    uint64_t v42 = v40;
    float32x4_t v43 = v91;
    if ((unint64_t)v91 < v92)
    {
      *(void *)int8x8_t v91 = v39;
      v43[1] = v40;
      uint64_t v44 = (uint64_t)(v43 + 2);
      goto LABEL_59;
    }
    uint32x4_t v45 = __p;
    uint64_t v46 = (v91 - (unsigned char *)__p) >> 4;
    unint64_t v47 = v46 + 1;
    if ((unint64_t)(v46 + 1) >> 60) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v48 = v92 - (void)__p;
    if ((uint64_t)(v92 - (void)__p) >> 3 > v47) {
      unint64_t v47 = v48 >> 3;
    }
    if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v49 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v49 = v47;
    }
    if (v49)
    {
      if (v49 >> 60) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint32x4_t v50 = (char *)operator new(16 * v49);
      uint64_t v51 = (uint64_t *)&v50[16 * ((v91 - (unsigned char *)__p) >> 4)];
      uint64_t v52 = &v50[16 * v49];
      *uint64_t v51 = v41;
      v51[1] = v42;
      uint64_t v44 = (uint64_t)(v51 + 2);
      if (v43 == v45) {
        goto LABEL_57;
      }
    }
    else
    {
      uint64_t v51 = (uint64_t *)(16 * v46);
      uint64_t v52 = 0;
      *uint64_t v51 = v39;
      v51[1] = v40;
      uint64_t v44 = 16 * v46 + 16;
      if (v43 == v45) {
        goto LABEL_57;
      }
    }
    do
    {
      *((_OWORD *)v51 - 1) = *((_OWORD *)v43 - 1);
      v51 -= 2;
      v43 -= 2;
    }
    while (v43 != v45);
    float32x4_t v43 = __p;
LABEL_57:
    std::string __p = v51;
    int8x8_t v91 = (char *)v44;
    unint64_t v92 = (unint64_t)v52;
    unsigned int v12 = v81;
    if (v43) {
      operator delete(v43);
    }
LABEL_59:
    LODWORD(v14) = v82;
    int8x8_t v91 = (char *)v44;
    if (v12 <= (HIDWORD(v42) - HIDWORD(v41)) * ((int)v42 - (int)v41)) {
      unsigned int v12 = (HIDWORD(v42) - HIDWORD(v41)) * (v42 - v41);
    }
    if ((int)v7 <= (int)v4) {
      goto LABEL_82;
    }
LABEL_62:
    unsigned int v53 = v12;
    uint64_t v54 = HGRectMake4i(v4, v84, v7, v14);
    uint64_t v56 = v54;
    uint64_t v57 = v55;
    float32x2_t v58 = v91;
    if ((unint64_t)v91 < v92)
    {
      *(void *)int8x8_t v91 = v54;
      v58[1] = v55;
      uint64_t v59 = (uint64_t)(v58 + 2);
LABEL_79:
      int8x8_t v91 = (char *)v59;
      if (v53 <= (HIDWORD(v57) - HIDWORD(v56)) * ((int)v57 - (int)v56)) {
        unsigned int v12 = (HIDWORD(v57) - HIDWORD(v56)) * (v57 - v56);
      }
      else {
        unsigned int v12 = v53;
      }
      goto LABEL_82;
    }
    int8x16_t v60 = __p;
    uint64_t v61 = (v91 - (unsigned char *)__p) >> 4;
    unint64_t v62 = v61 + 1;
    if ((unint64_t)(v61 + 1) >> 60) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v63 = v92 - (void)__p;
    if ((uint64_t)(v92 - (void)__p) >> 3 > v62) {
      unint64_t v62 = v63 >> 3;
    }
    if ((unint64_t)v63 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v64 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v64 = v62;
    }
    if (v64)
    {
      if (v64 >> 60) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      int8x16_t v65 = (char *)operator new(16 * v64);
      float v66 = (uint64_t *)&v65[16 * v61];
      float v67 = &v65[16 * v64];
      *float v66 = v56;
      v66[1] = v57;
      uint64_t v59 = (uint64_t)(v66 + 2);
      if (v58 == v60) {
        goto LABEL_77;
      }
    }
    else
    {
      float v66 = (uint64_t *)(16 * v61);
      float v67 = 0;
      *float v66 = v54;
      v66[1] = v55;
      uint64_t v59 = 16 * v61 + 16;
      if (v58 == v60) {
        goto LABEL_77;
      }
    }
    do
    {
      *((_OWORD *)v66 - 1) = *((_OWORD *)v58 - 1);
      v66 -= 2;
      v58 -= 2;
    }
    while (v58 != v60);
    float32x2_t v58 = __p;
LABEL_77:
    std::string __p = v66;
    int8x8_t v91 = (char *)v59;
    unint64_t v92 = (unint64_t)v67;
    if (v58) {
      operator delete(v58);
    }
    goto LABEL_79;
  }
LABEL_9:
  if ((int)v7 > (int)v4) {
    goto LABEL_62;
  }
LABEL_82:
  uint64_t v68 = (HGMetalUtils *)HGMetalUtils::metalFormat(*((_DWORD *)this + 4));
  int v69 = HGMetalUtils::bytesPerPixel(v68);
  uint64_t v71 = (void *)HGMemory::allocate((HGMemory *)(v69 * v12), 0, v70);
  bzero(v71, v69 * v12);
  int v73 = (int32x2_t *)__p;
  uint64_t v74 = v91;
  if (__p != v91)
  {
    do
    {
      int32x2_t v75 = v73[1];
      int32x2_t v85 = *v73;
      int v89 = 4614;
      kdebug_trace();
      int32x2_t v76 = vsub_s32(v75, v85);
      *(void *)&long long v77 = v76.u32[0];
      *((void *)&v77 + 1) = v76.u32[1];
      float32x4_t v78 = (void *)*((void *)this + 18);
      v86[0] = (v85.i32[0] - v6);
      v86[1] = (v85.i32[1] - HIDWORD(v6));
      int v86[2] = 0;
      long long v87 = v77;
      uint64_t v88 = 1;
      [v78 replaceRegion:v86 mipmapLevel:0 withBytes:v71 bytesPerRow:(v76.i32[0] * v69)];
      kdebug_trace();
      v73 += 2;
    }
    while (v73 != (int32x2_t *)v74);
  }
  HGMemory::release((HGMemory *)v71, v72);
  if (__p)
  {
    int8x8_t v91 = (char *)__p;
    operator delete(__p);
  }
LABEL_86:
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v93);
}

void sub_1B77F413C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,char a23,void *__p,uint64_t a25)
{
  if (__p) {
    operator delete(__p);
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)(v25 - 120));
  _Unwind_Resume(a1);
}

void HGMetalTexture::CopyTexture(HGMetalTexture *this, id *a2, HGBitmap *a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var2;
  uint64_t v5 = *(void *)&a4.var0;
  HGTraceGuard::HGTraceGuard((HGTraceGuard *)v18, "metal_osx", 1, "HGMetalTexture::CopyTexture() to bitmap");
  uint64_t v9 = (void *)*((void *)this + 18);
  if (!v9)
  {
LABEL_11:
    *(void *)&v19.int var0 = v5;
    *(void *)&v19.int var2 = v4;
    HGMetalTexture::CopyManagedTextureData(this, a3, v19);
    goto LABEL_12;
  }
  if ([v9 storageMode] != 2)
  {
    uint64_t v11 = (void *)*((void *)this + 18);
    if (v11 && ![v11 storageMode])
    {
      unsigned __int8 v14 = atomic_load(HGLogger::_enabled);
      if (v14) {
        HGLogger::log((HGLogger *)"mtl_perf_validation", (const char *)1, (HGLogger *)"HGMTL PERF WARNING - [MTLTexture getBytes] with MTLStorageModeShared texture!? This sync'ed copy should have been avoidable...\n", v12, v13);
      }
      HGMetalContext::synchronizeCommandQueue(a2);
    }
    goto LABEL_11;
  }
  uint64_t v10 = (uint64_t *)HGMetalContext::bufferInfiniPool((HGMetalContext *)a2);
  if (!HGMetalBuffer::canCreateFromBytes(*((void *)a2[2] + 2), a3))
  {
    uint64_t v15 = (HGMetalBuffer *)HGObject::operator new(0x80uLL);
    HGBitmap::HGBitmap(v15, *(void *)((char *)a3 + 20), *(void *)((char *)a3 + 28), *((unsigned int *)a3 + 4));
    HGMetalBuffer::createFromBytes(v15, *((void **)a2[2] + 2), v10, 1, &v17);
    HGMetalUtils::blitTextureToBuffer(a2[4], this, v17, v5, v4, 1, 0);
    HGRenderUtils::BufferCopier::BufferCopier((HGRenderUtils::BufferCopier *)&v16);
  }
  HGMetalBuffer::createFromBytes((HGMetalBuffer *)a3, *((void **)a2[2] + 2), v10, 1, &v17);
  HGMetalUtils::blitTextureToBuffer(a2[4], this, v17, v5, v4, 1, 0);
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 24))(v17);
  }
LABEL_12:
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v18);
}

void sub_1B77F441C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  if (a3) {
    (*(void (**)(uint64_t))(*(void *)a3 + 24))(a3);
  }
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void HGMetalTexture::CreateBitmapCopy(HGMetalTexture *this@<X0>, id *a2@<X1>, HGRect a3@<0:X2, 8:X3>, HGBitmap **a4@<X8>)
{
  uint64_t v7 = HGRectIntersection(*(void *)((char *)this + 20), *(void *)((char *)this + 28), *(uint64_t *)&a3.var0, *(uint64_t *)&a3.var2);
  uint64_t v9 = v8;
  uint64_t v10 = (HGBitmap *)HGObject::operator new(0x80uLL);
  HGBitmap::HGBitmap(v10, v7, v9, *((unsigned int *)this + 4));
  *a4 = v10;
  *(void *)&v11.int var0 = v7;
  *(void *)&v11.int var2 = v9;
  HGMetalTexture::CopyTexture(this, a2, v10, v11);
}

void sub_1B77F459C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL HGMetalTexture::_canCreateLinearTexture<(HGMetalTexture::CreationStrategyFlags)16>(void *a1, HGBitmap *this)
{
  Storage = (const void *)HGBitmap::GetStorage(this);
  if (!Storage
  {
    uint64_t v6 = this;
  }
  uint64_t v7 = HGMetalUtils::metalFormat(*((_DWORD *)v6 + 4));
  uint64_t v8 = [a1 minimumLinearTextureAlignmentForPixelFormat:v7];
  int v9 = getpagesize();
  BOOL v10 = !(*((void *)v6 + 10) % v9) && !(*((void *)v6 + 9) % v9) && *((void *)v6 + 8) % v8 == 0;
  unsigned int v11 = *(_DWORD *)(HGMetalDeviceInfo::getDeviceInfo((uint64_t)a1) + 48);
  if (*((_DWORD *)v6 + 7) - *((_DWORD *)v6 + 5) <= v11)
  {
    BOOL v12 = *((_DWORD *)v6 + 8) - *((_DWORD *)v6 + 6) <= v11;
    if (!v10) {
      return 0;
    }
  }
  else
  {
    BOOL v12 = 0;
    if (!v10) {
      return 0;
    }
  }
  return v7 && v12;
}

id HGMetalTexture::createFromTexture@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  id v4 = a1;
  uint64_t v5 = HGRectMake4i(0, 0, [a1 width], objc_msgSend(a1, "height"));
  uint64_t v7 = v6;
  int v8 = HGMetalUtils::hgFormat((HGMetalUtils *)[a1 pixelFormat]);
  int v9 = (void *)[a1 device];
  BOOL v10 = (char *)HGObject::operator new(0x120uLL);
  id result = (id)HGBitmap::HGBitmap((uint64_t)v10, v5, v7, v8, 0);
  *(void *)BOOL v10 = &unk_1F10DBE88;
  *((void *)v10 + 17) = 0;
  *((void *)v10 + 18) = 0;
  *((void *)v10 + 16) = 0;
  *(_OWORD *)(v10 + 152) = HGRectNull;
  *((_DWORD *)v10 + 42) = 1;
  *((void *)v10 + 22) = 850045863;
  *(_OWORD *)(v10 + 184) = 0u;
  *(_OWORD *)(v10 + 20CVOpenGLESTextureCacheFlush(this[3], 0) = 0u;
  *(_OWORD *)(v10 + 216) = 0u;
  *((void *)v10 + 29) = 0;
  *((void *)v10 + 3CVOpenGLESTextureCacheFlush(this[3], 0) = 1018212795;
  *(_OWORD *)(v10 + 248) = 0u;
  *((void *)v10 + 35) = 0;
  *(_OWORD *)(v10 + 264) = 0u;
  *((_DWORD *)v10 + 3) |= 0x220u;
  if (v9)
  {
    *((void *)v10 + 17) = v9;
    id result = v9;
  }
  *a2 = v10;
  *((void *)v10 + 18) = a1;
  v10[169] = 1;
  return result;
}

void sub_1B77F48A0(_Unwind_Exception *a1)
{
  std::condition_variable::~condition_variable(v3);
  std::mutex::~mutex(v2);
  HGBitmap::~HGBitmap(v1, v5);
  HGObject::operator delete(v6);
  _Unwind_Resume(a1);
}

void sub_1B77F48C8(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void HGMetalTexture::createFromBitmap(HGMetalTexture *this@<X0>, HGMetalContext *a2@<X1>, HGBitmap *a3@<X2>, HGRect a4@<0:X3, 8:X4>, uint64_t a5@<X5>, HGMetalContext **a6@<X8>)
{
}

void HGMetalTexture::createFromBitmap(HGMetalTexture *this@<X0>, HGMetalContext *a2@<X1>, HGBitmap *a3@<X3>, HGRect a4@<0:X4, 8:X5>, uint64_t a5@<X2>, uint64_t a6@<X6>, HGMetalContext **a7@<X8>)
{
  char var2 = a4.var2;
  uint64_t v9 = *(void *)&a4.var0;
  char v12 = (char)a2;
  uint64_t v15 = *(void **)(*((void *)this + 2) + 16);
  uint64_t v16 = HGMetalContext::texturePool(this);
  *a7 = 0;
  if (!a5 || (!*(void *)(a5 + 80) ? (BOOL v19 = (*(_DWORD *)(a5 + 12) & 1) == 0) : (BOOL v19 = 0), v19))
  {
    HGLogger::warning((HGLogger *)"HGMetalTexture::createFromBitmap() failed. HGBitmap doesn't have any data!", v17, v18);
  }
  else if (*(_DWORD *)(a5 + 12))
  {
    CVBitmapStorage = (char *)HGCVBitmap::getCVBitmapStorage((HGBitmap *)a5, (HGBitmap *)v17);
    HGMetalTexture::createFromIOSurface(this, (HGMetalContext *)(v12 & 3), v32, CVBitmapStorage, &v39);
    if (v39) {
      *a7 = v39;
    }
  }
  else
  {
    int v20 = (uint64_t *)v16;
    char v33 = var2;
    (*(void (**)(uint64_t))(*(void *)a5 + 16))(a5);
    uint64_t v39 = (HGMetalContext *)a5;
    uint64_t v22 = v38;
    uint64_t v23 = HGRectIntersection(*(void *)(v38 + 20), *(void *)(v38 + 28), (uint64_t)a3, v9);
    uint64_t v34 = v24;
    int v35 = (HGMetalBuffer *)v23;
    int v25 = *(_DWORD *)(v22 + 16);
    LUTEnd = (HGMetalDeviceInfo *)PCICCTransferFunctionLUT::getLUTEnd(this);
    unsigned int v27 = *((_DWORD *)this + 24);
    if (v27)
    {
      if (LUTEnd)
      {
        if (HGMetalDeviceInfo::isAMD(LUTEnd))
        {
          uint64_t v28 = (HGMetalUtils *)HGMetalUtils::metalFormat(v25);
          if (v27 < ((HIDWORD(v34) - HIDWORD(v35))
                    * (v34 - v35)
                    * HGMetalUtils::bytesPerPixel(v28)) >> 20)
            v12 &= 0xFu;
        }
      }
    }
    if ((v12 & 0x78) != 0
      && HGMetalBuffer::canCreateFromBytes((uint64_t)v15, (HGBitmap *)v22)
      && (int v29 = (uint64_t *)HGMetalContext::bufferInfiniPool(this),
          HGMetalBuffer::createFromBytes((HGMetalBuffer *)v22, v15, v29, 1, &v37),
          v37))
    {
      *(void *)&v41.int var0 = v34;
      *(void *)&v41.char var2 = a6;
      HGMetalTexture::createFromBuffer(this, (HGMetalContext *)(v12 & 0x78), v37, v35, v41, &v36);
      uint64_t v30 = v36;
      if (v36) {
        *a7 = v36;
      }
      if (v37) {
        (*(void (**)(HGMetalContext *))(*(void *)v37 + 24))(v37);
      }
    }
    else
    {
      uint64_t v30 = 0;
    }
    if ((v12 & 4) != 0 && !v30)
    {
      HGMetalTexture::createWithCopy(v15, v20, v22, (uint64_t)v35, v34, v33, a6 ^ 1, &v37);
      if (v37) {
        *a7 = v37;
      }
    }
    (*(void (**)(uint64_t))(*(void *)v22 + 24))(v22);
    (*(void (**)(uint64_t))(*(void *)a5 + 24))(a5);
  }
}

void sub_1B77F4BC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a14) {
    (*(void (**)(uint64_t))(*(void *)a14 + 24))(a14);
  }
  (*(void (**)(uint64_t))(*(void *)v15 + 24))(v15);
  (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);
  _Unwind_Resume(a1);
}

void HGMetalTexture::createFromIOSurface(HGMetalTexture *this@<X0>, HGMetalContext *a2@<X1>, HGCVBitmap *a3@<X3>, char *a4@<X2>, void *a5@<X8>)
{
  *a5 = 0;
  if (!a4) {
    goto LABEL_14;
  }
  char v5 = (char)a2;
  if ((a2 & 3) == 0) {
    goto LABEL_14;
  }
  int v8 = *(void **)(*((void *)this + 2) + 16);
  CVTextureCacheRetainedRef = (__CVMetalTextureCache *)HGMetalContext::getCVTextureCacheRetainedRef((HGGPUResources **)this);
  BOOL v10 = CVTextureCacheRetainedRef;
  unsigned int v11 = 0;
  if (v5)
  {
    if (CVTextureCacheRetainedRef)
    {
      HGMetalTexture::createFromIOSurface(v8, CVTextureCacheRetainedRef, (uint64_t)a4, &v12);
      unsigned int v11 = v12;
      if (v12) {
        *a5 = v12;
      }
    }
  }
  if ((v5 & 2) != 0 && !v11)
  {
    HGMetalTexture::createFromIOSurface(v8, (uint64_t)a4, a4, &v12);
    unsigned int v11 = v12;
    if (v12) {
      *a5 = v12;
    }
  }
  if (v10) {
    CFRelease(v10);
  }
  if (!v11)
  {
LABEL_14:
    HGLogger::warning((HGLogger *)"HGMetalTexture::createFromIOSurface failed. Invalid cvbmp or strategy.", (const char *)a2, a4, a3);
  }
}

void sub_1B77F4D64(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t anonymous namespace'::adjustBitmapForTexture(void *a1, const char *a2, char *a3)
{
  uint64_t v5 = HGFormatUtils::RGBtoRGBA(*(unsigned int *)(*(void *)a2 + 16), a2, a3);
  uint64_t v6 = *(void *)a2;
  if (v5 != *(_DWORD *)(*(void *)a2 + 16))
  {
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v12, "metal_osx", 1, "adjustBitmapForTexture() -- HGMetalTexture reformat");
    uint64_t v9 = *(void *)a2;
    BOOL v10 = HGObject::operator new(0x80uLL);
    HGBitmap::HGBitmap(v10, *(void *)(v9 + 20), *(void *)(v9 + 28), v5);
    *a1 = v10;
    HGRenderUtils::BufferReformatter::BufferReformatter((HGRenderUtils::BufferReformatter *)v11);
  }
  *a1 = v6;
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 16);

  return v7();
}

void sub_1B77F4ED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)va);
  _Unwind_Resume(a1);
}

void HGMetalTexture::createFromBuffer(HGMetalTexture *this@<X0>, HGMetalContext *a2@<X1>, HGMetalContext *a3@<X2>, HGMetalBuffer *a4@<X3>, HGRect a5@<0:X4, 8:X5>, void *a6@<X8>)
{
  uint64_t v6 = *(void *)&a5.var2;
  uint64_t v7 = *(void *)&a5.var0;
  char v10 = (char)a2;
  unint64_t v13 = *(void **)(*((void *)this + 2) + 16);
  *a6 = 0;
  if ((a2 & 0x10) != 0
    && HGMetalTexture::_canCreateLinearTexture<(HGMetalTexture::CreationStrategyFlags)16>(v13, (HGBitmap *)a3)
    && (HGMetalTexture::_createFromBufferStorage<(HGMetalTexture::CreationStrategyFlags)16>(v13, (uint64_t)a3, (char *)a4, v7, &v18), v18))
  {
    *a6 = v18;
  }
  else if ((v10 & 8) != 0)
  {
    int v14 = v10 & 0x70;
    *(void *)&v19.int var0 = v7;
    *(void *)&v19.char var2 = v6;
    HGMetalTexture::createWithBlitEncoder(this, a3, a4, v19, &v18);
    if (v18) {
      *a6 = v18;
    }
    if (v14)
    {
      unsigned __int8 v17 = atomic_load(HGLogger::_enabled);
      if (v17) {
        HGLogger::log((HGLogger *)"mtl_perf_validation", (const char *)1, (HGLogger *)"HGMTL PERF WARNING - HGMetalTexture::createFromBitmap: BlitEncoder isn't the preferred upload path on Intel IG (check rowbytes alignment). Mixed results on discrete GPUs.\n", v15, v16);
      }
    }
  }
}

void sub_1B77F505C(_Unwind_Exception *exception_object)
{
  if (*v1) {
    (*(void (**)(void))(*(void *)*v1 + 24))(*v1);
  }
  _Unwind_Resume(exception_object);
}

const char *HGMetalTexture::createWithCopy@<X0>(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, char a6@<W5>, int a7@<W6>, HGMetalTexture **a8@<X8>)
{
  *a8 = 0;
  if (a3 && *(void *)(a3 + 80))
  {
    int v26 = 4622;
    kdebug_trace();
    (*(void (**)(uint64_t))(*(void *)a3 + 16))(a3);
    *(void *)int v25 = a3;
    uint64_t v17 = v24;
    uint64_t v18 = HGRectIntersection(*(void *)(v24 + 20), *(void *)(v24 + 28), a4, a5);
    uint64_t v20 = v19;
    HGMetalTexture::_create(a1, a2, v18, v19, *(_DWORD *)(v17 + 16), a6, 0, 0, &v23, 0, 1u);
    int8x16_t v21 = v23;
    if (v23)
    {
      *a8 = v23;
      HGMetalTexture::InitializeBorders(v21);
      *(void *)&v28.int var0 = v18;
      *(void *)&v28.char var2 = v20;
      HGMetalTexture::ReplaceManagedTextureData(v21, (HGBitmap *)v17, v28, a7);
      *((unsigned char *)v21 + 168) = 1;
    }
    (*(void (**)(uint64_t))(*(void *)v17 + 24))(v17);
    (*(void (**)(uint64_t))(*(void *)a3 + 24))(a3);
    return (const char *)kdebug_trace();
  }
  else
  {
    return HGLogger::warning((HGLogger *)"HGMetalTexture::createWithCopy() failed. No bitmap provided.", (const char *)a2, (char *)a3);
  }
}

void sub_1B77F52A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, char a15)
{
  (*(void (**)(uint64_t))(*(void *)v16 + 24))(v16);
  (*(void (**)(uint64_t))(*(void *)v15 + 24))(v15);
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a15);
  _Unwind_Resume(a1);
}

const char *HGMetalTexture::createFromIOSurface@<X0>(void *a1@<X0>, __CVMetalTextureCache *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  *a4 = 0;
  if (a3)
  {
    if (a2)
    {
      int v30 = 4630;
      kdebug_trace();
      int v8 = *(__CVBuffer **)(*(void *)(a3 + 128) + 24);
      IOSurface = CVPixelBufferGetIOSurface(v8);
      char v10 = (HGMetalUtils *)HGMetalUtils::metalFormat(*(_DWORD *)(a3 + 16));
      unint64_t v11 = HGFormatUtils::collapseRectForFormat((uint64_t *)(a3 + 20), *(_DWORD *)(a3 + 16));
      uint64_t v13 = v12;
      int v14 = HGMetalUtils::bytesPerPixel(v10);
      if (v14 == HGFormatUtils::bytesPerPixel(*(_DWORD *)(a3 + 16))
        && HGRectIsEqual(v11, v13, *(void *)(a3 + 20), *(void *)(a3 + 28))
        || IOSurfaceAllowsPixelSizeCasting(IOSurface))
      {
        unint64_t v17 = HIDWORD(v11);
        CVMetalTextureRef image = 0;
        size_t v18 = (v13 - v11);
        size_t v19 = (HIDWORD(v13) - v17);
        if (!CVMetalTextureCacheCreateTextureFromImage(0, a2, v8, 0, (MTLPixelFormat)v10, v18, v19, *(void *)(a3 + 136), &image))
        {
          uint64_t v20 = (char *)HGObject::operator new(0x120uLL);
          HGBitmap::HGBitmap((uint64_t)v20, *(void *)(a3 + 20), *(void *)(a3 + 28), *(_DWORD *)(a3 + 16), 0);
          *(void *)uint64_t v20 = &unk_1F10DBE88;
          *((void *)v20 + 17) = 0;
          *((void *)v20 + 18) = 0;
          *((void *)v20 + 16) = 0;
          *(_OWORD *)(v20 + 152) = HGRectNull;
          *((_DWORD *)v20 + 42) = 1;
          *((void *)v20 + 22) = 850045863;
          *(_OWORD *)(v20 + 184) = 0u;
          *(_OWORD *)(v20 + 20CVOpenGLESTextureCacheFlush(this[3], 0) = 0u;
          *(_OWORD *)(v20 + 216) = 0u;
          *((void *)v20 + 29) = 0;
          *((void *)v20 + 3CVOpenGLESTextureCacheFlush(this[3], 0) = 1018212795;
          *(_OWORD *)(v20 + 248) = 0u;
          *((void *)v20 + 35) = 0;
          *(_OWORD *)(v20 + 264) = 0u;
          *((_DWORD *)v20 + 3) |= 0x220u;
          if (a1)
          {
            *((void *)v20 + 17) = a1;
            id v21 = a1;
          }
          *a4 = v20;
          id Texture = CVMetalTextureGetTexture(image);
          *((void *)v20 + 18) = Texture;
          id v23 = Texture;
          *((_DWORD *)v20 + 3) |= 1u;
          uint64_t v24 = (HGCVBufferPairStorage *)HGObject::operator new(0x20uLL);
          HGCVBufferPairStorage::HGCVBufferPairStorage(v24, (HGCVBitmap *)a3, image);
          HGBitmap::SetStorage((HGBitmap *)v20, v24);
          CFRelease(image);
          uint64_t v25 = HGMetalUtils::metalFormat(*(_DWORD *)(a3 + 16));
          uint64_t ID = IOSurfaceGetID(IOSurface);
          if (v24) {
            (*(void (**)(HGCVBufferPairStorage *, size_t, size_t, uint64_t, uint64_t))(*(void *)v24 + 24))(v24, v18, v19, v25, ID);
          }
        }
      }
      else
      {
        HGLogger::warning((HGLogger *)"HGMetalTexture::createFromIOSurface() failed. Pixel size casting is not allowed by IOSurface.", v15, v16);
      }
      return (const char *)kdebug_trace();
    }
    unsigned int v27 = "HGMetalTexture::createFromIOSurface() failed. No HGCVMetalTextureCacheRef provided.";
  }
  else
  {
    unsigned int v27 = "HGMetalTexture::createFromIOSurface() failed. Buffer is not a HGCVBitmap.";
  }

  return HGLogger::warning((HGLogger *)v27, (const char *)a2, (char *)a3);
}

void sub_1B77F567C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
  std::condition_variable::~condition_variable(v15);
  std::mutex::~mutex(v14);
  HGBitmap::~HGBitmap(v13, v17);
  HGObject::operator delete(v13);
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a13);
  _Unwind_Resume(a1);
}

void sub_1B77F56D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
}

void sub_1B77F56EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
}

void sub_1B77F5704(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
}

void sub_1B77F5718(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
}

void sub_1B77F572C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
}

void sub_1B77F5740(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13)
{
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);
  }
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a13);
  (*(void (**)(uint64_t))(*(void *)v13 + 24))(v13);
  _Unwind_Resume(a1);
}

void sub_1B77F57B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, char a13)
{
}

void HGMetalTexture::createFromIOSurface(void *a1@<X0>, uint64_t a2@<X1>, char *a3@<X2>, char **a4@<X8>)
{
  *a4 = 0;
  if (a2)
  {
    HGTraceGuard::HGTraceGuard((HGTraceGuard *)v26, "metal_osx", 1, "HGMetalTexture::createFromIOSurface()");
    kdebug_trace();
    IOSurface = CVPixelBufferGetIOSurface(*(CVPixelBufferRef *)(*(void *)(a2 + 128) + 24));
    unint64_t v8 = HGFormatUtils::collapseRectForFormat((uint64_t *)(a2 + 20), *(_DWORD *)(a2 + 16));
    uint64_t v10 = v9;
    unint64_t v11 = (HGMetalUtils *)HGMetalUtils::metalFormat(*(_DWORD *)(a2 + 16));
    int v12 = HGMetalUtils::bytesPerPixel(v11);
    if ((v12 != HGFormatUtils::bytesPerPixel(*(_DWORD *)(a2 + 16))
       || !HGRectIsEqual(v8, v10, *(void *)(a2 + 20), *(void *)(a2 + 28)))
      && !IOSurfaceAllowsPixelSizeCasting(IOSurface))
    {
      HGLogger::warning((HGLogger *)"HGMetalTexture::createFromIOSurface() failed. Pixel size casting is not allowed by IOSurface.", v13, v14);
      goto LABEL_21;
    }
    unint64_t v15 = HIDWORD(v8);
    uint64_t v16 = (v10 - v8);
    uint64_t v17 = (HIDWORD(v10) - v15);
    size_t v18 = (void *)[MEMORY[0x1E4F35330] texture2DDescriptorWithPixelFormat:v11 width:v16 height:v17 mipmapped:0];
    [v18 setUsage:7];
    uint64_t DeviceInfo = HGMetalDeviceInfo::getDeviceInfo((uint64_t)a1);
    if (DeviceInfo
      && [v18 width]
      && [v18 width] <= (unint64_t)*(unsigned int *)(DeviceInfo + 48)
      && [v18 height]
      && [v18 height] <= (unint64_t)*(unsigned int *)(DeviceInfo + 48)
      && [v18 pixelFormat])
    {
      uint64_t v22 = (char *)HGObject::operator new(0x120uLL);
      HGBitmap::HGBitmap((uint64_t)v22, *(void *)(a2 + 20), *(void *)(a2 + 28), *(_DWORD *)(a2 + 16), 0);
      *(void *)uint64_t v22 = &unk_1F10DBE88;
      *((void *)v22 + 17) = 0;
      *((void *)v22 + 18) = 0;
      *((void *)v22 + 16) = 0;
      *(_OWORD *)(v22 + 152) = HGRectNull;
      *((_DWORD *)v22 + 42) = 1;
      *((void *)v22 + 22) = 850045863;
      *(_OWORD *)(v22 + 184) = 0u;
      *(_OWORD *)(v22 + 20CVOpenGLESTextureCacheFlush(this[3], 0) = 0u;
      *(_OWORD *)(v22 + 216) = 0u;
      *((void *)v22 + 29) = 0;
      *((void *)v22 + 3CVOpenGLESTextureCacheFlush(this[3], 0) = 1018212795;
      *(_OWORD *)(v22 + 248) = 0u;
      *((void *)v22 + 35) = 0;
      *(_OWORD *)(v22 + 264) = 0u;
      *((_DWORD *)v22 + 3) |= 0x220u;
      if (a1)
      {
        *((void *)v22 + 17) = a1;
        id v23 = a1;
      }
      *a4 = v22;
      *((void *)v22 + 18) = objc_msgSend(a1, "newTextureWithDescriptor:iosurface:plane:", v18, IOSurface, *(void *)(a2 + 136), v22 + 176);
      *((_DWORD *)v22 + 3) |= 1u;
      uint64_t ID = IOSurfaceGetID(IOSurface);
      if (*((void *)v22 + 18))
      {
        HGBitmap::SetStorage((HGBitmap *)v22, (HGObject *)a2);
LABEL_21:
        kdebug_trace();
        HGTraceGuard::~HGTraceGuard((HGTraceGuard *)v26);
        return;
      }
      (*(void (**)(char *, uint64_t, uint64_t, HGMetalUtils *, uint64_t))(*(void *)v22 + 24))(v22, v16, v17, v11, ID);
      *a4 = 0;
      uint64_t v25 = "HGMetalTexture::createFromIOSurface() failed. newTextureWithDescriptor failed.";
    }
    else
    {
      uint64_t v25 = "HGMetalTexture::createFromIOSurface() failed. Invalid texture description.";
    }
    HGLogger::warning((HGLogger *)v25, v19, v20);
    goto LABEL_21;
  }

  HGLogger::warning((HGLogger *)"HGMetalTexture::createFromIOSurface() failed. Buffer is not a HGCVBitmap.", 0, a3);
}

void sub_1B77F5B50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::mutex *a9, int a10, char a11, __int16 a12, char a13, char a14)
{
  std::condition_variable::~condition_variable(v15);
  std::mutex::~mutex(a9);
  HGBitmap::~HGBitmap(v14, v17);
  HGObject::operator delete(v14);
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a11);
  HGTraceGuard::~HGTraceGuard((HGTraceGuard *)&a13);
  _Unwind_Resume(a1);
}

HGObject *HGMetalTexture::createWithBlitEncoder@<X0>(HGObject *this@<X0>, HGMetalContext *a2@<X1>, HGMetalBuffer *a3@<X2>, HGRect a4@<0:X3, 8:X4>, HGBitmap **a5@<X8>)
{
  *a5 = 0;
  if (a2)
  {
    int var2 = a4.var2;
    unint64_t v6 = *(void *)&a4.var0;
    uint64_t v9 = this;
    unint64_t v11 = *(void **)(*((void *)this + 2) + 16);
    int v12 = (uint64_t *)HGMetalContext::texturePool(this);
    this = (HGObject *)HGMetalTexture::_create(v11, v12, (uint64_t)a3, v6, *((_DWORD *)a2 + 4), 0, 0, 0, &v15, 2, 1u);
    uint64_t v13 = v15;
    if (v15)
    {
      *a5 = v15;
      unint64_t v14 = *((unsigned int *)v9 + 24);
      if (v14) {
        HGMetalUtils::tiledBlitBufferToTexture(*((void **)v9 + 4), (uint64_t)a2, v13, (unint64_t)a3, v6, var2, 0, v14);
      }
      else {
        HGMetalUtils::blitBufferToTexture(*((void **)v9 + 4), (uint64_t)a2, v13, (uint64_t)a3, v6, var2, 0);
      }
      return HGBitmap::SetStorage(v13, a2);
    }
  }
  return this;
}

void sub_1B77F5D0C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

const char *HGMetalTexture::_createFromBufferStorage<(HGMetalTexture::CreationStrategyFlags)16>@<X0>(void *a1@<X0>, uint64_t a2@<X1>, char *a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  *a5 = 0;
  if (a2)
  {
    *(void *)&v40.int var0 = 0;
    *(void *)&v40.int var2 = 0;
    *(void *)&v40.int var0 = HGRectIntersection(*(void *)(a2 + 20), *(void *)(a2 + 28), (uint64_t)a3, a4);
    *(void *)&v40.int var2 = v8;
    if (HGRect::IsNull(&v40)) {
      return HGLogger::warning((HGLogger *)"HGMetalTexture::_createFromBufferStorage() failed. Empty ROI.", v9, v10);
    }
    kdebug_trace();
    if (HGFormatUtils::isPackedFormat(*(_DWORD *)(a2 + 16))) {
      v40.int var0 = *(_DWORD *)(a2 + 20);
    }
    uint64_t v12 = [a1 minimumLinearTextureAlignmentForPixelFormat:HGMetalUtils::metalFormat(*(_DWORD *)(a2 + 16))];
    int var1 = v40.var1;
    int v14 = *(_DWORD *)(a2 + 20);
    unint64_t v15 = *(void *)(a2 + 56);
    uint64_t v16 = v15 * (v40.var0 - v14);
    if (*(_DWORD *)(a2 + 16) == 31) {
      unint64_t v17 = ((3 * ((uint64_t)(4 * v16 / 6uLL) / v12 * v12 / v15)) >> 1) & 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v16 / v12 * v12 / v15;
    }
    uint64_t v18 = (v14 + v17);
    *(void *)&v40.int var0 = *(void *)&v40.var0 & 0xFFFFFFFF00000000 | v18;
    unint64_t v19 = HGBitmap::byteOffset((HGBitmap *)a2, v18, var1);
    unint64_t v20 = HGFormatUtils::collapseRectForFormat((uint64_t *)&v40.var0, *(_DWORD *)(a2 + 16));
    uint64_t v22 = v21;
    uint64_t v23 = HGMetalUtils::metalFormat(*(_DWORD *)(a2 + 16));
    uint64_t v24 = (char *)(v22 - v20);
    uint64_t v25 = (HIDWORD(v22) - HIDWORD(v20));
    int v26 = (void *)[MEMORY[0x1E4F35330] texture2DDescriptorWithPixelFormat:v23 width:v24 height:v25 mipmapped:0];
    [v26 setUsage:1];
    unint64_t v39 = v20;
    uint64_t DeviceInfo = (HGMetalDeviceInfo *)HGMetalDeviceInfo::getDeviceInfo((uint64_t)a1);
    if (HGMetalDeviceInfo::isApple(DeviceInfo)) {
      objc_msgSend(v26, "setUsage:", objc_msgSend(v26, "usage") | 6);
    }
    HGRect v28 = *(void **)(a2 + 144);
    if (HGMetalTexture::_canCreateLinearTexture<(HGMetalTexture::CreationStrategyFlags)16>(a1, (HGBitmap *)a2))
    {
      kdebug_trace();
      uint64_t v31 = [v28 newTextureWithDescriptor:v26 offset:v19 bytesPerRow:*(void *)(a2 + 64)];
      uint64_t v32 = 0;
      char v33 = v24;
      uint64_t v34 = v25;
      uint64_t v35 = v23;
      uint32x4_t v36 = v28;
      if (v31)
      {
        uint32x4_t v37 = (char *)HGObject::operator new(0x120uLL);
        HGBitmap::HGBitmap((uint64_t)v37, *(uint64_t *)&v40.var0, *(uint64_t *)&v40.var2, *(_DWORD *)(a2 + 16), 0);
        *(void *)uint32x4_t v37 = &unk_1F10DBE88;
        *((void *)v37 + 17) = 0;
        *((void *)v37 + 18) = 0;
        *((void *)v37 + 16) = 0;
        *(_OWORD *)(v37 + 152) = HGRectNull;
        *((_DWORD *)v37 + 42) = 1;
        *((void *)v37 + 22) = 850045863;
        *(_OWORD *)(v37 + 184) = 0u;
        *(_OWORD *)(v37 + 20CVOpenGLESTextureCacheFlush(this[3], 0) = 0u;
        *(_OWORD *)(v37 + 216) = 0u;
        *((void *)v37 + 29) = 0;
        *((void *)v37 + 3CVOpenGLESTextureCacheFlush(this[3], 0) = 1018212795;
        *(_OWORD *)(v37 + 248) = 0u;
        *((void *)v37 + 35) = 0;
        *(_OWORD *)(v37 + 264) = 0u;
        *((_DWORD *)v37 + 3) |= 0x220u;
        if (a1)
        {
          *((void *)v37 + 17) = a1;
          id v38 = a1;
        }
        *a5 = v37;
        *((void *)v37 + 19) = v39;
        *((void *)v37 + 2CVOpenGLESTextureCacheFlush(this[3], 0) = v22;
        *((void *)v37 + 18) = v31;
        HGBitmap::SetStorage((HGBitmap *)v37, (HGObject *)a2);
        return (const char *)kdebug_trace();
      }
    }
    else
    {
      HGLogger::warning((HGLogger *)"HGMetalTexture::_createFromBufferStorage() failed. Bad alignment.", v29, v30);
    }
    HGLogger::warning((HGLogger *)"HGMetalTexture::_createFromBufferStorage() failed. MTLTexture creation failed.", v32, v33, v34, v35, v36, v39);
    return (const char *)kdebug_trace();
  }

  return HGLogger::warning((HGLogger *)"HGMetalTexture::_createFromBufferStorage() failed. No MTLBuffer provided.", 0, a3);
}

void sub_1B77F60B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11)
{
  std::condition_variable::~condition_variable(v13);
  std::mutex::~mutex(v12);
  HGBitmap::~HGBitmap(v11, v15);
  HGObject::operator delete(v11);
  HGSignPost::EventScopeGuard::~EventScopeGuard((HGSignPost::EventScopeGuard *)&a11);
  _Unwind_Resume(a1);
}

void sub_1B77F6130(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

void sub_1B77F6148(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

void sub_1B77F615C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

void sub_1B77F6170(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

void sub_1B77F6184(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

void sub_1B77F6198(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

void sub_1B77F61AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

void sub_1B77F61C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

void sub_1B77F61D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

void sub_1B77F61E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
}

uint64_t HGMetalTexture::create@<X0>(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, char a6@<W5>, int a7@<W6>, int a8@<W7>, void *a9@<X8>, char a10)
{
  uint64_t v10 = 2;
  if (!a10) {
    uint64_t v10 = 0;
  }
  return HGMetalTexture::_create(a1, a2, a3, a4, a5, a6, a7, a8, a9, v10, 1u);
}

uint64_t HGMetalTexture::_create@<X0>(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, char a6@<W5>, int a7@<W6>, int a8@<W7>, void *a9@<X8>, uint64_t a10, unsigned int a11)
{
  uint64_t v57 = a3;
  uint64_t v58 = a4;
  int v56 = 4624;
  kdebug_trace();
  unint64_t v15 = HGFormatUtils::collapseRectForFormat(&v57, a5);
  uint64_t v17 = v16;
  uint64_t v18 = HGRectMake4i(0, 0, 0, 0);
  unint64_t v43 = HGRectGrow(v15, v17, v18);
  unint64_t v45 = HIDWORD(v43);
  unint64_t v20 = (v19 - v43);
  uint64_t v22 = (v21 - HIDWORD(v43));
  *(void *)&long long v50 = v20;
  *((void *)&v50 + 1) = v22;
  uint64_t v23 = HGMetalUtils::metalFormat(a5);
  uint64_t v51 = v23;
  uint64_t v53 = a10;
  if (a11 >= 2) {
    uint64_t v24 = 4;
  }
  else {
    uint64_t v24 = 2;
  }
  int v54 = v24;
  unsigned int v55 = a11;
  if (a7) {
    unsigned int v25 = 5;
  }
  else {
    unsigned int v25 = 1;
  }
  if (a8) {
    uint64_t v26 = v25 | 2;
  }
  else {
    uint64_t v26 = v25;
  }
  int v52 = v26;
  *a9 = 0;
  uint64_t DeviceInfo = HGMetalDeviceInfo::getDeviceInfo((uint64_t)a1);
  if (!DeviceInfo
    || !v20
    || (unint64_t v30 = *(unsigned int *)(DeviceInfo + 48), v20 > v30)
    || v22 - 1 >= v30
    || !v23
    || *(_DWORD *)(DeviceInfo + 52) < a11)
  {
    HGLogger::warning((HGLogger *)"HGMetalTexture::_create() failed. Invalid texture description.", v28, v29, v43, v45);
    return kdebug_trace();
  }
  if (!a2)
  {
    uint64_t v42 = (void *)[MEMORY[0x1E4F35330] texture2DDescriptorWithPixelFormat:v23 width:v20 height:v22 mipmapped:0];
    [v42 setUsage:v26];
    [v42 setStorageMode:a10];
    [v42 setTextureType:v24];
    [v42 setSampleCount:a11];
    uint32x4_t v36 = (void *)[a1 newTextureWithDescriptor:v42];
    uint64_t v32 = 0;
    char v33 = (char *)v20;
    uint64_t v34 = v22;
    uint64_t v35 = v23;
    if (v36) {
      goto LABEL_20;
    }
LABEL_26:
    HGLogger::warning((HGLogger *)"HGMetalTexture::_create() failed. Failed to allocate texture object.", v32, v33, v34, v35, v43, v45);
    return kdebug_trace();
  }
  uint32x4_t v36 = (void *)HGMetalTexturePool::newTexture(a2, &v50, a6);
  if (!v36) {
    goto LABEL_26;
  }
LABEL_20:
  uint32x4_t v37 = (char *)HGObject::operator new(0x120uLL);
  HGBitmap::HGBitmap((uint64_t)v37, v57, v58, a5, 0);
  *(void *)uint32x4_t v37 = &unk_1F10DBE88;
  *((void *)v37 + 17) = 0;
  *((void *)v37 + 18) = 0;
  *((void *)v37 + 16) = 0;
  *(_OWORD *)(v37 + 152) = HGRectNull;
  *((_DWORD *)v37 + 42) = 1;
  *((void *)v37 + 22) = 850045863;
  *(_OWORD *)(v37 + 184) = 0u;
  *(_OWORD *)(v37 + 20CVOpenGLESTextureCacheFlush(this[3], 0) = 0u;
  *(_OWORD *)(v37 + 216) = 0u;
  *((void *)v37 + 29) = 0;
  *((void *)v37 + 3CVOpenGLESTextureCacheFlush(this[3], 0) = 1018212795;
  *(_OWORD *)(v37 + 248) = 0u;
  *((void *)v37 + 35) = 0;
  *(_OWORD *)(v37 + 264) = 0u;
  *((_DWORD *)v37 + 3) |= 0x220u;
  if (a1)
  {
    *((void *)v37 + 17) = a1;
    id v38 = a1;
  }
  *a9 = v37;
  *((void *)v37 + 18) = v36;
  *((void *)v37 + 16) = a2;
  *((_WORD *)v37 + 84) = 256;
  uint64_t v39 = objc_msgSend(v36, "width", v43, v45);
  uint64_t v40 = [v36 height];
  if (v39 != v58 - v57 || v40 != HIDWORD(v58) - HIDWORD(v57))
  {
    *((void *)v37 + 19) = HGRectMake4i(v44, v46, v39 + v44, v40 + v46);
    *((void *)v37 + 2CVOpenGLESTextureCacheFlush(this[3], 0) = v41;
  }
  return kdebug_trace();
}

void sub_1B77F658C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,char a21)
{
}

uint64_t HGMetalTexture::create@<X0>(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, char a6@<W5>, int a7@<W6>, int a8@<W7>, void *a9@<X8>, uint64_t a10, unsigned int a11)
{
  return HGMetalTexture::_create(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t HGMetalTexture::createDepth@<X0>(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unsigned int a5@<W4>, void *a6@<X8>)
{
  return HGMetalTexture::_create(a1, a2, a3, a4, 9, 0, 1, 0, a6, 2, a5);
}

const char *HGMetalTexture::createMSAA@<X0>(void *a1@<X0>, uint64_t *a2@<X1>, char *a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, unsigned int a6@<W5>, void *a7@<X8>)
{
  if (a6 > 1) {
    return (const char *)HGMetalTexture::_create(a1, a2, (uint64_t)a3, a4, a5, 0, 1, 0, a7, 2, a6);
  }
  id result = HGLogger::warning((HGLogger *)"HGMetalTexture::createMSAA failed. 'sampleCount' must be greater than 1.", (const char *)a2, a3);
  *a7 = 0;
  return result;
}

void *HGMetalTexture::getMetalStorage(HGBitmap *this, HGBitmap *a2)
{
  if (!this) {
    return 0;
  }
  unint64_t v2 = this;
  do
  {
    Storage = (const void *)HGBitmap::GetStorage(v2);
    if (!Storage) {
      break;
    }
    unint64_t v2 = v5;
  }
  while (!v3 && v5 != 0);
  return v3;
}

uint64_t project_util::getUniformLocation(project_util *this, const GLchar *a2, const char *a3)
{
  uint64_t result = glGetUniformLocation((GLuint)this, a2);
  uint64_t v5 = result;
  if (result == -1)
  {
    unint64_t v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"no uniform location for: ", 25);
    size_t v7 = strlen(a2);
    uint64_t v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)a2, v7);
    std::ios_base::getloc((const std::ios_base *)((char *)v8 + *(void *)(*v8 - 24)));
    uint64_t v9 = std::locale::use_facet(&v10, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 10);
    std::locale::~locale(&v10);
    std::ostream::put();
    std::ostream::flush();
    return v5;
  }
  return result;
}

void sub_1B77F6904(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

uint64_t project_util::getAttribLocation(project_util *this, const GLchar *a2, const char *a3)
{
  uint64_t result = glGetAttribLocation((GLuint)this, a2);
  uint64_t v5 = result;
  if (result == -1)
  {
    unint64_t v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"no attrib location for: ", 24);
    size_t v7 = strlen(a2);
    uint64_t v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)a2, v7);
    std::ios_base::getloc((const std::ios_base *)((char *)v8 + *(void *)(*v8 - 24)));
    uint64_t v9 = std::locale::use_facet(&v10, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 10);
    std::locale::~locale(&v10);
    std::ostream::put();
    std::ostream::flush();
    return v5;
  }
  return result;
}

void sub_1B77F6A24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

uint64_t project_util::prettyPrintShaderText(project_util *this, const char *a2)
{
  unint64_t v2 = this;
  size_t v3 = strlen((const char *)this);
  id v4 = (void *)MEMORY[0x1E4FBA240];
  if (v3)
  {
    size_t v5 = v3;
    BOOL v6 = 1;
    uint64_t v7 = 1;
    do
    {
      if (v6)
      {
        *(void *)((char *)v4 + *(void *)(*v4 - 24) + 24) = 3;
        std::locale v10 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)": ", 2);
      }
      int v9 = *(unsigned __int8 *)v2;
      unint64_t v2 = (project_util *)((char *)v2 + 1);
      char v8 = v9;
      BOOL v6 = v9 == 10;
      if (v9 == 10) {
        ++v7;
      }
      char v13 = v8;
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v4, (uint64_t)&v13, 1);
      --v5;
    }
    while (v5);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v4 + *(void *)(*v4 - 24)));
  unint64_t v11 = std::locale::use_facet(&v14, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
  std::locale::~locale(&v14);
  std::ostream::put();
  return std::ostream::flush();
}

void sub_1B77F6B8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

uint64_t project_util::compileShaderProgram(GLchar *this, GLchar *a2, const char *a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  int v21 = a2;
  string = this;
  GLuint Shader = glCreateShader(0x8B31u);
  glShaderSource(Shader, 1, (const GLchar *const *)&string, 0);
  glCompileShader(Shader);
  GLint params = 0;
  glGetShaderiv(Shader, 0x8B81u, &params);
  if (params != 1)
  {
    GLsizei length = 0;
    glGetShaderInfoLog(Shader, 2048, &length, infolog);
    size_t v4 = strlen(infolog);
    size_t v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)infolog, v4);
    std::ios_base::getloc((const std::ios_base *)((char *)v5 + *(void *)(*v5 - 24)));
    BOOL v6 = std::locale::use_facet(&v23, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v6->__vftable[2].~facet_0)(v6, 10);
    std::locale::~locale(&v23);
    std::ostream::put();
    std::ostream::flush();
    project_util::prettyPrintShaderText((project_util *)string, v7);
  }
  GLuint v8 = glCreateShader(0x8B30u);
  glShaderSource(v8, 1, (const GLchar *const *)&v21, 0);
  glCompileShader(v8);
  GLint params = 0;
  glGetShaderiv(v8, 0x8B81u, &params);
  if (params != 1)
  {
    GLsizei length = 0;
    glGetShaderInfoLog(v8, 2048, &length, infolog);
    size_t v9 = strlen(infolog);
    std::locale v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)infolog, v9);
    std::ios_base::getloc((const std::ios_base *)((char *)v10 + *(void *)(*v10 - 24)));
    unint64_t v11 = std::locale::use_facet(&v23, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
    std::locale::~locale(&v23);
    std::ostream::put();
    std::ostream::flush();
    project_util::prettyPrintShaderText((project_util *)v21, v12);
  }
  uint64_t Program = glCreateProgram();
  glAttachShader(Program, Shader);
  glAttachShader(Program, v8);
  glLinkProgram(Program);
  GLsizei length = 0;
  glGetProgramiv(Program, 0x8B82u, &length);
  if (length != 1)
  {
    GLsizei v18 = 0;
    glGetProgramInfoLog(Program, 2048, &v18, infolog);
    size_t v14 = strlen(infolog);
    unint64_t v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)infolog, v14);
    std::ios_base::getloc((const std::ios_base *)((char *)v15 + *(void *)(*v15 - 24)));
    uint64_t v16 = std::locale::use_facet(&v23, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v16->__vftable[2].~facet_0)(v16, 10);
    std::locale::~locale(&v23);
    std::ostream::put();
    std::ostream::flush();
  }
  glDeleteShader(Shader);
  glDeleteShader(v8);
  return Program;
}

void sub_1B77F6F04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::locale a13)
{
}

void sub_1B77F6F18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::locale a13)
{
}

void sub_1B77F6F2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::locale a13)
{
}

void project_util::fill_flat_array(void *a1, uint64_t a2)
{
  if (a1[1] != *a1)
  {
    unint64_t v4 = 0;
    size_t v5 = *(char **)(a2 + 8);
    do
    {
      for (uint64_t i = 0; i != 3; ++i)
      {
        float32x4_t v7 = *(float32x4_t *)(*a1 + 48 * v4 + 16 * i);
        int32x4_t v8 = (int32x4_t)vmulq_f32(v7, v7);
        v8.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v8, 2), vadd_f32(*(float32x2_t *)v8.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v8.i8, 1))).u32[0];
        float32x2_t v9 = vrsqrte_f32((float32x2_t)v8.u32[0]);
        float32x2_t v10 = vmul_f32(v9, vrsqrts_f32((float32x2_t)v8.u32[0], vmul_f32(v9, v9)));
        float32x4_t v11 = vmulq_n_f32(v7, vmul_f32(v10, vrsqrts_f32((float32x2_t)v8.u32[0], vmul_f32(v10, v10))).f32[0]);
        uint64_t v12 = *(char **)(a2 + 16);
        float32x4_t v68 = v11;
        if (v5 < v12)
        {
          *(_DWORD *)size_t v5 = v11.i32[0];
          char v13 = v5 + 4;
          goto LABEL_34;
        }
        size_t v14 = *(char **)a2;
        uint64_t v15 = (uint64_t)&v5[-*(void *)a2];
        uint64_t v16 = v15 >> 2;
        unint64_t v17 = (v15 >> 2) + 1;
        if (v17 >> 62) {
          goto LABEL_89;
        }
        uint64_t v18 = v12 - v14;
        if (v18 >> 1 > v17) {
          unint64_t v17 = v18 >> 1;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v19 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          if (v19 >> 62) {
            goto LABEL_90;
          }
          unint64_t v20 = operator new(4 * v19);
          float32x4_t v11 = v68;
          int v21 = &v20[4 * v16];
          _DWORD *v21 = v68.i32[0];
          char v13 = (char *)(v21 + 1);
          if (v5 == v14) {
            goto LABEL_32;
          }
        }
        else
        {
          unint64_t v20 = 0;
          int v21 = (_DWORD *)(4 * v16);
          *(_DWORD *)(4 * v16) = v11.i32[0];
          char v13 = (char *)(4 * v16 + 4);
          if (v5 == v14) {
            goto LABEL_32;
          }
        }
        unint64_t v22 = v5 - 4 - v14;
        if (v22 < 0xBC)
        {
          std::locale v23 = v5;
          goto LABEL_31;
        }
        if (&v20[v15 - 4 - (v22 & 0xFFFFFFFFFFFFFFFCLL)] > &v20[v15 - 4])
        {
          std::locale v23 = v5;
          goto LABEL_31;
        }
        if (&v5[-(v22 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v5 - 4)
        {
          std::locale v23 = v5;
          do
          {
LABEL_31:
            int v30 = *((_DWORD *)v23 - 1);
            v23 -= 4;
            *--int v21 = v30;
          }
          while (v23 != v14);
          goto LABEL_32;
        }
        if ((unint64_t)(v5 - v20 - v15) < 0x20)
        {
          std::locale v23 = v5;
          goto LABEL_31;
        }
        uint64_t v24 = (v22 >> 2) + 1;
        uint64_t v25 = 4 * (v24 & 0x7FFFFFFFFFFFFFF8);
        std::locale v23 = &v5[-v25];
        int v21 = (_DWORD *)((char *)v21 - v25);
        uint64_t v26 = &v20[4 * v16 - 16];
        unsigned int v27 = (long long *)(v5 - 16);
        uint64_t v28 = v24 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v29 = *v27;
          *(v26 - 1) = *(v27 - 1);
          *uint64_t v26 = v29;
          v26 -= 2;
          v27 -= 2;
          v28 -= 8;
        }
        while (v28);
        if (v24 != (v24 & 0x7FFFFFFFFFFFFFF8)) {
          goto LABEL_31;
        }
LABEL_32:
        uint64_t v12 = &v20[4 * v19];
        *(void *)a2 = v21;
        *(void *)(a2 + 8) = v13;
        *(void *)(a2 + 16) = v12;
        if (v14)
        {
          operator delete(v14);
          float32x4_t v11 = v68;
          uint64_t v12 = *(char **)(a2 + 16);
        }
LABEL_34:
        *(void *)(a2 + 8) = v13;
        __int32 v31 = v11.i32[1];
        if (v13 < v12)
        {
          *(_DWORD *)char v13 = v11.i32[1];
          uint64_t v32 = v13 + 4;
          goto LABEL_61;
        }
        char v33 = *(char **)a2;
        uint64_t v34 = (uint64_t)&v13[-*(void *)a2];
        uint64_t v35 = v34 >> 2;
        unint64_t v36 = (v34 >> 2) + 1;
        if (v36 >> 62) {
          goto LABEL_89;
        }
        uint64_t v37 = v12 - v33;
        if (v37 >> 1 > v36) {
          unint64_t v36 = v37 >> 1;
        }
        if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v38 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v38 = v36;
        }
        if (v38)
        {
          if (v38 >> 62) {
            goto LABEL_90;
          }
          uint64_t v39 = operator new(4 * v38);
          v11.i32[2] = v68.i32[2];
          uint64_t v40 = (__int32 *)&v39[4 * v35];
          *uint64_t v40 = v31;
          uint64_t v32 = (char *)(v40 + 1);
          if (v13 == v33) {
            goto LABEL_59;
          }
        }
        else
        {
          uint64_t v39 = 0;
          uint64_t v40 = (__int32 *)(4 * v35);
          *(_DWORD *)(4 * v35) = v11.i32[1];
          uint64_t v32 = (char *)(4 * v35 + 4);
          if (v13 == v33) {
            goto LABEL_59;
          }
        }
        unint64_t v41 = v13 - 4 - v33;
        if (v41 < 0xBC)
        {
          uint64_t v42 = v13;
          goto LABEL_58;
        }
        if (&v39[v34 - 4 - (v41 & 0xFFFFFFFFFFFFFFFCLL)] > &v39[v34 - 4])
        {
          uint64_t v42 = v13;
          goto LABEL_58;
        }
        if (&v13[-(v41 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v13 - 4)
        {
          uint64_t v42 = v13;
          do
          {
LABEL_58:
            __int32 v49 = *((_DWORD *)v42 - 1);
            v42 -= 4;
            *--uint64_t v40 = v49;
          }
          while (v42 != v33);
          goto LABEL_59;
        }
        if ((unint64_t)(v13 - v39 - v34) < 0x20)
        {
          uint64_t v42 = v13;
          goto LABEL_58;
        }
        uint64_t v43 = (v41 >> 2) + 1;
        uint64_t v44 = 4 * (v43 & 0x7FFFFFFFFFFFFFF8);
        uint64_t v42 = &v13[-v44];
        uint64_t v40 = (__int32 *)((char *)v40 - v44);
        unint64_t v45 = &v39[4 * v35 - 16];
        unsigned int v46 = (long long *)(v13 - 16);
        uint64_t v47 = v43 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v48 = *v46;
          *(v45 - 1) = *(v46 - 1);
          *unint64_t v45 = v48;
          v45 -= 2;
          v46 -= 2;
          v47 -= 8;
        }
        while (v47);
        if (v43 != (v43 & 0x7FFFFFFFFFFFFFF8)) {
          goto LABEL_58;
        }
LABEL_59:
        uint64_t v12 = &v39[4 * v38];
        *(void *)a2 = v40;
        *(void *)(a2 + 8) = v32;
        *(void *)(a2 + 16) = v12;
        if (v33)
        {
          operator delete(v33);
          v11.i32[2] = v68.i32[2];
          uint64_t v12 = *(char **)(a2 + 16);
        }
LABEL_61:
        *(void *)(a2 + 8) = v32;
        __int32 v50 = v11.i32[2];
        if (v32 < v12)
        {
          *(_DWORD *)uint64_t v32 = v11.i32[2];
          size_t v5 = v32 + 4;
          goto LABEL_6;
        }
        uint64_t v51 = *(char **)a2;
        uint64_t v52 = (uint64_t)&v32[-*(void *)a2];
        uint64_t v53 = v52 >> 2;
        unint64_t v54 = (v52 >> 2) + 1;
        if (v54 >> 62) {
LABEL_89:
        }
          std::vector<double>::__throw_length_error[abi:ne180100]();
        uint64_t v55 = v12 - v51;
        if (v55 >> 1 > v54) {
          unint64_t v54 = v55 >> 1;
        }
        if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v56 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v56 = v54;
        }
        if (v56)
        {
          if (v56 >> 62) {
LABEL_90:
          }
            std::__throw_bad_array_new_length[abi:ne180100]();
          uint64_t v57 = operator new(4 * v56);
          uint64_t v58 = (__int32 *)&v57[4 * v53];
          *uint64_t v58 = v50;
          size_t v5 = (char *)(v58 + 1);
          if (v32 == v51) {
            goto LABEL_76;
          }
        }
        else
        {
          uint64_t v57 = 0;
          uint64_t v58 = (__int32 *)(4 * v53);
          *(_DWORD *)(4 * v53) = v11.i32[2];
          size_t v5 = (char *)(4 * v53 + 4);
          if (v32 == v51) {
            goto LABEL_76;
          }
        }
        unint64_t v59 = v32 - 4 - v51;
        if (v59 >= 0xBC)
        {
          if (&v57[v52 - 4 - (v59 & 0xFFFFFFFFFFFFFFFCLL)] > &v57[v52 - 4])
          {
            int8x16_t v60 = v32;
          }
          else if (&v32[-(v59 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v32 - 4)
          {
            int8x16_t v60 = v32;
          }
          else if ((unint64_t)(v32 - v57 - v52) >= 0x20)
          {
            uint64_t v62 = (v59 >> 2) + 1;
            uint64_t v63 = 4 * (v62 & 0x7FFFFFFFFFFFFFF8);
            int8x16_t v60 = &v32[-v63];
            uint64_t v58 = (__int32 *)((char *)v58 - v63);
            unint64_t v64 = &v57[4 * v53 - 16];
            int8x16_t v65 = (long long *)(v32 - 16);
            uint64_t v66 = v62 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v67 = *v65;
              *(v64 - 1) = *(v65 - 1);
              *unint64_t v64 = v67;
              v64 -= 2;
              v65 -= 2;
              v66 -= 8;
            }
            while (v66);
            if (v62 == (v62 & 0x7FFFFFFFFFFFFFF8)) {
              goto LABEL_76;
            }
          }
          else
          {
            int8x16_t v60 = v32;
          }
        }
        else
        {
          int8x16_t v60 = v32;
        }
        do
        {
          __int32 v61 = *((_DWORD *)v60 - 1);
          v60 -= 4;
          *--uint64_t v58 = v61;
        }
        while (v60 != v51);
LABEL_76:
        *(void *)a2 = v58;
        *(void *)(a2 + 8) = v5;
        *(void *)(a2 + 16) = &v57[4 * v56];
        if (v51) {
          operator delete(v51);
        }
LABEL_6:
        *(void *)(a2 + 8) = v5;
      }
      ++v4;
    }
    while (v4 < 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[1] - *a1) >> 4));
  }
}

void project_util::generateIcosphere(int a1, uint64_t a2)
{
  float32x4_t v359 = 0;
  size_t v3 = (char *)operator new(0x10uLL);
  *(_OWORD *)size_t v3 = xmmword_1B8347500;
  float32x4_t v358 = v3;
  float32x4_t v360 = v3 + 16;
  unint64_t v4 = (char *)operator new(0x20uLL);
  *(_OWORD *)unint64_t v4 = *(_OWORD *)v3;
  *((_OWORD *)v4 + 1) = xmmword_1B8347510;
  size_t v5 = v358;
  float32x4_t v358 = v4;
  float32x4_t v360 = v4 + 32;
  if (v5) {
    operator delete(v5);
  }
  float32x4_t v359 = v4 + 32;
  BOOL v6 = (char *)operator new(0x40uLL);
  long long v7 = *(_OWORD *)v4;
  *((_OWORD *)v6 + 1) = *((_OWORD *)v4 + 1);
  *((_OWORD *)v6 + 2) = xmmword_1B8347520;
  *(_OWORD *)BOOL v6 = v7;
  int32x4_t v8 = v358;
  float32x4_t v358 = v6;
  float32x4_t v360 = v6 + 64;
  if (v8) {
    operator delete(v8);
  }
  *((_OWORD *)v6 + 3) = xmmword_1B8347530;
  float32x4_t v359 = v6 + 64;
  float32x2_t v9 = operator new(0x80uLL);
  unint64_t v10 = (unint64_t)(v9 + 8);
  float32x4_t v11 = v9 + 5;
  long long v12 = *((_OWORD *)v6 + 2);
  void v9[3] = *((_OWORD *)v6 + 3);
  void v9[4] = xmmword_1B8347540;
  long long v13 = *(_OWORD *)v6;
  v9[1] = *((_OWORD *)v6 + 1);
  v9[2] = v12;
  *float32x2_t v9 = v13;
  size_t v14 = v358;
  float32x4_t v358 = (char *)v9;
  float32x4_t v360 = (char *)(v9 + 8);
  if (v14) {
    operator delete(v14);
  }
  float32x4_t v359 = v9 + 5;
  if ((unint64_t)v11 < v10)
  {
    _OWORD *v11 = xmmword_1B8347550;
    uint64_t v15 = v9 + 6;
    float32x4_t v359 = v9 + 6;
    if ((unint64_t)(v9 + 6) < v10) {
      goto LABEL_9;
    }
LABEL_20:
    uint64_t v25 = v15 - v9;
    unint64_t v26 = v25 + 1;
    if ((unint64_t)(v25 + 1) >> 60) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    if ((uint64_t)(v10 - (void)v9) >> 3 > v26) {
      unint64_t v26 = (uint64_t)(v10 - (void)v9) >> 3;
    }
    if (v10 - (unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v27 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v27 = v26;
    }
    if (v27)
    {
      if (v27 >> 60) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v28 = (char *)operator new(16 * v27);
    }
    else
    {
      uint64_t v28 = 0;
    }
    long long v29 = &v28[16 * v25];
    unint64_t v10 = (unint64_t)&v28[16 * v27];
    *(_OWORD *)long long v29 = xmmword_1B8347560;
    uint64_t v16 = v29 + 16;
    if (v15 == v9)
    {
      float32x4_t v358 = v29;
      float32x4_t v360 = (char *)v10;
    }
    else
    {
      do
      {
        long long v30 = *--v15;
        *((_OWORD *)v29 - 1) = v30;
        v29 -= 16;
      }
      while (v15 != v9);
      float32x2_t v9 = v358;
      float32x4_t v358 = v29;
      float32x4_t v360 = (char *)v10;
      if (!v9)
      {
        float32x2_t v9 = v29;
        float32x4_t v359 = v16;
        if ((unint64_t)v16 >= v10) {
          goto LABEL_34;
        }
        goto LABEL_10;
      }
    }
    operator delete(v9);
    float32x2_t v9 = v29;
    float32x4_t v359 = v16;
    if ((unint64_t)v16 >= v10) {
      goto LABEL_34;
    }
LABEL_10:
    _OWORD *v16 = xmmword_1B8347570;
    unint64_t v17 = v16 + 1;
    float32x4_t v359 = v16 + 1;
    if ((unint64_t)(v16 + 1) < v10) {
      goto LABEL_11;
    }
LABEL_51:
    uint64_t v37 = v17 - v9;
    unint64_t v38 = v37 + 1;
    if ((unint64_t)(v37 + 1) >> 60) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    if ((uint64_t)(v10 - (void)v9) >> 3 > v38) {
      unint64_t v38 = (uint64_t)(v10 - (void)v9) >> 3;
    }
    if (v10 - (unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v39 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v39 = v38;
    }
    if (v39)
    {
      if (v39 >> 60) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v40 = (char *)operator new(16 * v39);
    }
    else
    {
      uint64_t v40 = 0;
    }
    unint64_t v41 = &v40[16 * v37];
    unint64_t v10 = (unint64_t)&v40[16 * v39];
    *(_OWORD *)unint64_t v41 = xmmword_1B8347580;
    uint64_t v18 = v41 + 16;
    if (v17 == v9)
    {
      float32x4_t v358 = v41;
      float32x4_t v360 = (char *)v10;
    }
    else
    {
      do
      {
        long long v42 = *--v17;
        *((_OWORD *)v41 - 1) = v42;
        v41 -= 16;
      }
      while (v17 != v9);
      float32x2_t v9 = v358;
      float32x4_t v358 = v41;
      float32x4_t v360 = (char *)v10;
      if (!v9)
      {
        float32x2_t v9 = v41;
        float32x4_t v359 = v18;
        if ((unint64_t)v18 >= v10) {
          goto LABEL_68;
        }
        goto LABEL_12;
      }
    }
    operator delete(v9);
    float32x2_t v9 = v41;
    float32x4_t v359 = v18;
    if ((unint64_t)v18 >= v10) {
      goto LABEL_68;
    }
LABEL_12:
    *uint64_t v18 = xmmword_1B8347590;
    unint64_t v19 = v18 + 1;
    float32x4_t v359 = v18 + 1;
    if ((unint64_t)(v18 + 1) < v10) {
      goto LABEL_13;
    }
LABEL_85:
    uint64_t v49 = v19 - v9;
    unint64_t v50 = v49 + 1;
    if ((unint64_t)(v49 + 1) >> 60) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    if ((uint64_t)(v10 - (void)v9) >> 3 > v50) {
      unint64_t v50 = (uint64_t)(v10 - (void)v9) >> 3;
    }
    if (v10 - (unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v51 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v51 = v50;
    }
    if (v51)
    {
      if (v51 >> 60) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v52 = (char *)operator new(16 * v51);
    }
    else
    {
      uint64_t v52 = 0;
    }
    uint64_t v53 = &v52[16 * v49];
    unint64_t v10 = (unint64_t)&v52[16 * v51];
    *(_OWORD *)uint64_t v53 = xmmword_1B83475A0;
    unint64_t v20 = v53 + 16;
    if (v19 == v9)
    {
      float32x4_t v358 = v53;
      float32x4_t v360 = (char *)v10;
    }
    else
    {
      do
      {
        long long v54 = *--v19;
        *((_OWORD *)v53 - 1) = v54;
        v53 -= 16;
      }
      while (v19 != v9);
      float32x2_t v9 = v358;
      float32x4_t v358 = v53;
      float32x4_t v360 = (char *)v10;
      if (!v9)
      {
        float32x2_t v9 = v53;
        float32x4_t v359 = v20;
        if ((unint64_t)v20 < v10) {
          goto LABEL_14;
        }
        goto LABEL_102;
      }
    }
    operator delete(v9);
    float32x2_t v9 = v53;
    float32x4_t v359 = v20;
    if ((unint64_t)v20 < v10) {
      goto LABEL_14;
    }
    goto LABEL_102;
  }
  unint64_t v22 = operator new(0x100uLL);
  std::locale v23 = v22 + 5;
  unint64_t v10 = (unint64_t)(v22 + 16);
  v22[5] = xmmword_1B8347550;
  uint64_t v15 = v22 + 6;
  if (v11 == v9)
  {
    float32x4_t v358 = (char *)(v22 + 5);
    float32x4_t v360 = (char *)(v22 + 16);
  }
  else
  {
    for (uint64_t i = 0; i != -5; --i)
      v23[i - 1] = v9[i + 4];
    float32x2_t v9 = v358;
    std::locale v23 = v22;
    float32x4_t v358 = (char *)v22;
    float32x4_t v360 = (char *)(v22 + 16);
    if (!v9)
    {
      float32x2_t v9 = v22;
      float32x4_t v359 = v22 + 6;
      if ((unint64_t)v15 >= v10) {
        goto LABEL_20;
      }
      goto LABEL_9;
    }
  }
  operator delete(v9);
  float32x2_t v9 = v23;
  float32x4_t v359 = v15;
  if ((unint64_t)v15 >= v10) {
    goto LABEL_20;
  }
LABEL_9:
  *uint64_t v15 = xmmword_1B8347560;
  uint64_t v16 = v15 + 1;
  float32x4_t v359 = v15 + 1;
  if ((unint64_t)(v15 + 1) < v10) {
    goto LABEL_10;
  }
LABEL_34:
  uint64_t v31 = v16 - v9;
  unint64_t v32 = v31 + 1;
  if ((unint64_t)(v31 + 1) >> 60) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  if ((uint64_t)(v10 - (void)v9) >> 3 > v32) {
    unint64_t v32 = (uint64_t)(v10 - (void)v9) >> 3;
  }
  if (v10 - (unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v33 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v33 = v32;
  }
  if (v33)
  {
    if (v33 >> 60) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v34 = (char *)operator new(16 * v33);
  }
  else
  {
    uint64_t v34 = 0;
  }
  uint64_t v35 = &v34[16 * v31];
  unint64_t v10 = (unint64_t)&v34[16 * v33];
  *(_OWORD *)uint64_t v35 = xmmword_1B8347570;
  unint64_t v17 = v35 + 16;
  if (v16 == v9)
  {
    float32x4_t v358 = v35;
    float32x4_t v360 = (char *)v10;
  }
  else
  {
    do
    {
      long long v36 = *--v16;
      *((_OWORD *)v35 - 1) = v36;
      v35 -= 16;
    }
    while (v16 != v9);
    float32x2_t v9 = v358;
    float32x4_t v358 = v35;
    float32x4_t v360 = (char *)v10;
    if (!v9)
    {
      float32x2_t v9 = v35;
      float32x4_t v359 = v17;
      if ((unint64_t)v17 >= v10) {
        goto LABEL_51;
      }
      goto LABEL_11;
    }
  }
  operator delete(v9);
  float32x2_t v9 = v35;
  float32x4_t v359 = v17;
  if ((unint64_t)v17 >= v10) {
    goto LABEL_51;
  }
LABEL_11:
  _OWORD *v17 = xmmword_1B8347580;
  uint64_t v18 = v17 + 1;
  float32x4_t v359 = v17 + 1;
  if ((unint64_t)(v17 + 1) < v10) {
    goto LABEL_12;
  }
LABEL_68:
  uint64_t v43 = v18 - v9;
  unint64_t v44 = v43 + 1;
  if ((unint64_t)(v43 + 1) >> 60) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  if ((uint64_t)(v10 - (void)v9) >> 3 > v44) {
    unint64_t v44 = (uint64_t)(v10 - (void)v9) >> 3;
  }
  if (v10 - (unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v45 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v45 = v44;
  }
  if (v45)
  {
    if (v45 >> 60) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    unsigned int v46 = (char *)operator new(16 * v45);
  }
  else
  {
    unsigned int v46 = 0;
  }
  uint64_t v47 = &v46[16 * v43];
  unint64_t v10 = (unint64_t)&v46[16 * v45];
  *(_OWORD *)uint64_t v47 = xmmword_1B8347590;
  unint64_t v19 = v47 + 16;
  if (v18 == v9)
  {
    float32x4_t v358 = v47;
    float32x4_t v360 = (char *)v10;
  }
  else
  {
    do
    {
      long long v48 = *--v18;
      *((_OWORD *)v47 - 1) = v48;
      v47 -= 16;
    }
    while (v18 != v9);
    float32x2_t v9 = v358;
    float32x4_t v358 = v47;
    float32x4_t v360 = (char *)v10;
    if (!v9)
    {
      float32x2_t v9 = v47;
      float32x4_t v359 = v19;
      if ((unint64_t)v19 >= v10) {
        goto LABEL_85;
      }
      goto LABEL_13;
    }
  }
  operator delete(v9);
  float32x2_t v9 = v47;
  float32x4_t v359 = v19;
  if ((unint64_t)v19 >= v10) {
    goto LABEL_85;
  }
LABEL_13:
  *unint64_t v19 = xmmword_1B83475A0;
  unint64_t v20 = v19 + 1;
  float32x4_t v359 = v19 + 1;
  if ((unint64_t)(v19 + 1) < v10)
  {
LABEL_14:
    *unint64_t v20 = xmmword_1B83475B0;
    int v21 = v20 + 1;
    goto LABEL_125;
  }
LABEL_102:
  uint64_t v55 = v20 - v9;
  unint64_t v56 = v55 + 1;
  if ((unint64_t)(v55 + 1) >> 60) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  if ((uint64_t)(v10 - (void)v9) >> 3 > v56) {
    unint64_t v56 = (uint64_t)(v10 - (void)v9) >> 3;
  }
  if (v10 - (unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v57 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v57 = v56;
  }
  if (v57)
  {
    if (v57 >> 60) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v58 = (char *)operator new(16 * v57);
  }
  else
  {
    uint64_t v58 = 0;
  }
  unint64_t v59 = &v58[16 * v55];
  *(_OWORD *)unint64_t v59 = xmmword_1B83475B0;
  int v21 = v59 + 16;
  if (v20 == v9)
  {
    float32x4_t v358 = v59;
    float32x4_t v360 = &v58[16 * v57];
  }
  else
  {
    do
    {
      long long v60 = *--v20;
      *((_OWORD *)v59 - 1) = v60;
      v59 -= 16;
    }
    while (v20 != v9);
    float32x2_t v9 = v358;
    float32x4_t v358 = v59;
    float32x4_t v360 = &v58[16 * v57];
    if (!v9) {
      goto LABEL_124;
    }
  }
  operator delete(v9);
LABEL_124:
  float32x2_t v9 = v59;
LABEL_125:
  float32x4_t v359 = v21;
  std::string __p = 0;
  int8x16_t v356 = 0;
  int8x16_t v357 = 0;
  float32x4_t v313 = *((float32x4_t *)v9 + 11);
  float32x4_t v333 = *(float32x4_t *)v9;
  float32x4_t v292 = *((float32x4_t *)v9 + 5);
  __int32 v61 = (float32x4_t *)operator new(0x30uLL);
  *__int32 v61 = v333;
  v61[1] = v313;
  v61[2] = v292;
  int8x16_t v356 = v61 + 3;
  int8x16_t v357 = (char *)&v61[3];
  float32x4_t v62 = *((float32x4_t *)v9 + 5);
  std::string __p = v61;
  float32x4_t v314 = v62;
  float32x4_t v334 = *(float32x4_t *)v9;
  float32x4_t v293 = *((float32x4_t *)v9 + 1);
  uint64_t v63 = (float32x4_t *)operator new(0x60uLL);
  v63[4] = v314;
  v63[5] = v293;
  float32x4_t v64 = v61[1];
  *uint64_t v63 = *v61;
  v63[1] = v64;
  v63[2] = v61[2];
  v63[3] = v334;
  std::string __p = v63;
  int8x16_t v357 = (char *)&v63[6];
  operator delete(v61);
  int8x16_t v356 = v63 + 6;
  float32x4_t v315 = *((float32x4_t *)v9 + 1);
  float32x4_t v335 = *(float32x4_t *)v9;
  float32x4_t v294 = *((float32x4_t *)v9 + 7);
  int8x16_t v65 = (float32x4_t *)operator new(0xC0uLL);
  v65[6] = v335;
  v65[7] = v315;
  v65[8] = v294;
  float32x4_t v66 = v63[5];
  v65[4] = v63[4];
  v65[5] = v66;
  float32x4_t v67 = v63[1];
  *int8x16_t v65 = *v63;
  v65[1] = v67;
  float32x4_t v68 = v63[3];
  v65[2] = v63[2];
  void v65[3] = v68;
  std::string __p = v65;
  int8x16_t v357 = (char *)&v65[12];
  operator delete(v63);
  int8x16_t v356 = v65 + 9;
  float32x4_t v69 = *((float32x4_t *)v9 + 7);
  float32x4_t v70 = *((float32x4_t *)v9 + 10);
  v65[9] = *(float32x4_t *)v9;
  v65[10] = v69;
  v65[11] = v70;
  int8x16_t v356 = v65 + 12;
  float32x4_t v336 = *((float32x4_t *)v9 + 10);
  float32x4_t v295 = *(float32x4_t *)v9;
  float32x4_t v316 = *((float32x4_t *)v9 + 11);
  uint64_t v71 = (float32x4_t *)operator new(0x180uLL);
  v71[12] = v295;
  f32 = (_OWORD *)v71[12].f32;
  unint64_t v73 = (unint64_t)&v71[24];
  v71[13] = v336;
  v71[14] = v316;
  float32x4_t v74 = v65[11];
  v71[10] = v65[10];
  v71[11] = v74;
  float32x4_t v75 = v65[7];
  v71[6] = v65[6];
  v71[7] = v75;
  float32x4_t v76 = v65[9];
  v71[8] = v65[8];
  v71[9] = v76;
  float32x4_t v77 = v65[5];
  v71[4] = v65[4];
  v71[5] = v77;
  float32x4_t v78 = v65[3];
  v71[2] = v65[2];
  v71[3] = v78;
  float32x4_t v79 = v65[1];
  *uint64_t v71 = *v65;
  v71[1] = v79;
  std::string __p = v71;
  int8x16_t v357 = (char *)&v71[24];
  operator delete(v65);
  int8x16_t v356 = v71 + 15;
  float32x4_t v80 = *((float32x4_t *)v9 + 5);
  float32x4_t v81 = *((float32x4_t *)v9 + 9);
  if (&v71[15] >= &v71[24])
  {
    float32x4_t v296 = *((float32x4_t *)v9 + 1);
    float32x4_t v317 = *((float32x4_t *)v9 + 5);
    float32x4_t v337 = *((float32x4_t *)v9 + 9);
    uint64_t v142 = (float32x4_t *)operator new(0x300uLL);
    unint64_t v82 = v142 + 15;
    unint64_t v73 = (unint64_t)&v142[48];
    v142[15] = v296;
    v142[16] = v317;
    v142[17] = v337;
    uint64_t v143 = v142 + 15;
    if (&v71[15] != v71)
    {
      for (uint64_t j = 0; j != -15; j -= 3)
      {
        uint64_t v145 = (_OWORD *)v142[j].f32;
        long long v146 = f32[j + 1];
        v145[12] = f32[j];
        v145[13] = v146;
        v145[14] = f32[j + 2];
      }
      uint64_t v143 = v142;
    }
    std::string __p = v143;
    int8x16_t v357 = (char *)&v142[48];
    operator delete(v71);
    uint64_t v71 = v143;
    uint64_t v83 = v82 + 3;
    int8x16_t v356 = v82 + 3;
    float32x4_t v84 = *((float32x4_t *)v9 + 11);
    float32x4_t v85 = *((float32x4_t *)v9 + 4);
    float32x4_t v86 = *((float32x4_t *)v9 + 5);
    if ((unint64_t)&v82[3] < v73)
    {
LABEL_127:
      v82[3] = v86;
      v82[4] = v84;
      long long v87 = (char *)v83;
      v82[5] = v85;
      uint64_t v88 = v83 + 3;
      int8x16_t v356 = v88;
      long long v89 = v9[10];
      long long v90 = v9[11];
      long long v91 = v9[2];
      if ((unint64_t)v88 < v73) {
        goto LABEL_128;
      }
      goto LABEL_161;
    }
  }
  else
  {
    v71[15] = *((float32x4_t *)v9 + 1);
    v71[16] = v80;
    unint64_t v82 = v71 + 15;
    v71[17] = v81;
    uint64_t v83 = v71 + 18;
    int8x16_t v356 = v71 + 18;
    float32x4_t v84 = *((float32x4_t *)v9 + 11);
    float32x4_t v85 = *((float32x4_t *)v9 + 4);
    float32x4_t v86 = *((float32x4_t *)v9 + 5);
    if ((unint64_t)&v71[18] < v73) {
      goto LABEL_127;
    }
  }
  unint64_t v147 = 0xAAAAAAAAAAAAAAABLL * (v83 - v71) + 1;
  if (v147 > 0x555555555555555) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  if (0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4) > v147) {
    unint64_t v147 = 0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v73 - (void)v71) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v148 = 0x555555555555555;
  }
  else {
    unint64_t v148 = v147;
  }
  if (v148)
  {
    float32x4_t v297 = v86;
    float32x4_t v318 = v84;
    float32x4_t v338 = v85;
    if (v148 > 0x555555555555555) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    unint64_t v149 = (char *)operator new(48 * v148);
    float32x4_t v84 = v318;
    float32x4_t v85 = v338;
    float32x4_t v86 = v297;
  }
  else
  {
    unint64_t v149 = 0;
  }
  long long v87 = &v149[16 * (v83 - v71)];
  unint64_t v73 = (unint64_t)&v149[48 * v148];
  *(float32x4_t *)long long v87 = v86;
  *((float32x4_t *)v87 + 1) = v84;
  *((float32x4_t *)v87 + 2) = v85;
  unint64_t v150 = v87;
  if (v83 != v71)
  {
    uint64_t v151 = &v149[16 * (v83 - v71)];
    do
    {
      float32x4_t v152 = v83[-3];
      float32x4_t v153 = v83[-1];
      unint64_t v150 = v151 - 48;
      *((float32x4_t *)v151 - 2) = v83[-2];
      *((float32x4_t *)v151 - 1) = v153;
      *((float32x4_t *)v151 - 3) = v152;
      v83 -= 3;
      v151 -= 48;
    }
    while (v83 != v71);
  }
  std::string __p = v150;
  int8x16_t v357 = &v149[48 * v148];
  operator delete(v71);
  uint64_t v71 = (float32x4_t *)v150;
  uint64_t v88 = (float32x4_t *)(v87 + 48);
  int8x16_t v356 = (float32x4_t *)(v87 + 48);
  long long v89 = v9[10];
  long long v90 = v9[11];
  long long v91 = v9[2];
  if ((unint64_t)(v87 + 48) < v73)
  {
LABEL_128:
    *((_OWORD *)v87 + 3) = v90;
    *((_OWORD *)v87 + 4) = v89;
    uint64_t k = (float32x4_t *)(v87 + 96);
    *((_OWORD *)v87 + 5) = v91;
    int8x16_t v356 = (float32x4_t *)(v87 + 96);
    float32x4_t v93 = *((float32x4_t *)v9 + 10);
    float32x4_t v94 = *((float32x4_t *)v9 + 6);
    float32x4_t v95 = *((float32x4_t *)v9 + 7);
    if ((unint64_t)(v87 + 96) < v73) {
      goto LABEL_129;
    }
    goto LABEL_174;
  }
LABEL_161:
  unint64_t v154 = 0xAAAAAAAAAAAAAAABLL * (v88 - v71) + 1;
  if (v154 > 0x555555555555555) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  if (0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4) > v154) {
    unint64_t v154 = 0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v73 - (void)v71) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v155 = 0x555555555555555;
  }
  else {
    unint64_t v155 = v154;
  }
  if (v155)
  {
    long long v298 = v90;
    long long v319 = v89;
    long long v339 = v91;
    if (v155 > 0x555555555555555) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    float32x4_t v156 = (char *)operator new(48 * v155);
    long long v89 = v319;
    long long v91 = v339;
    long long v90 = v298;
  }
  else
  {
    float32x4_t v156 = 0;
  }
  float32x4_t v157 = &v156[16 * (v88 - v71)];
  unint64_t v73 = (unint64_t)&v156[48 * v155];
  *(_OWORD *)float32x4_t v157 = v90;
  *((_OWORD *)v157 + 1) = v89;
  *((_OWORD *)v157 + 2) = v91;
  for (uint64_t k = (float32x4_t *)(v157 + 48); v88 != v71; v88 -= 3)
  {
    float32x4_t v158 = v88[-3];
    float32x4_t v159 = v88[-1];
    *((float32x4_t *)v157 - 2) = v88[-2];
    *((float32x4_t *)v157 - 1) = v159;
    *((float32x4_t *)v157 - 3) = v158;
    v157 -= 48;
  }
  std::string __p = v157;
  int8x16_t v357 = &v156[48 * v155];
  operator delete(v71);
  uint64_t v71 = (float32x4_t *)v157;
  int8x16_t v356 = k;
  float32x4_t v93 = *((float32x4_t *)v9 + 10);
  float32x4_t v94 = *((float32x4_t *)v9 + 6);
  float32x4_t v95 = *((float32x4_t *)v9 + 7);
  if ((unint64_t)k < v73)
  {
LABEL_129:
    *uint64_t k = v93;
    k[1] = v95;
    uint64_t v96 = k + 3;
    k[2] = v94;
    int8x16_t v356 = k + 3;
    float32x4_t v97 = *((float32x4_t *)v9 + 1);
    float32x4_t v99 = *((float32x4_t *)v9 + 7);
    float32x4_t v98 = *((float32x4_t *)v9 + 8);
    if ((unint64_t)&k[3] < v73) {
      goto LABEL_130;
    }
    goto LABEL_191;
  }
LABEL_174:
  unint64_t v160 = 0xAAAAAAAAAAAAAAABLL * (k - v71) + 1;
  if (v160 > 0x555555555555555) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  if (0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4) > v160) {
    unint64_t v160 = 0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v73 - (void)v71) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v161 = 0x555555555555555;
  }
  else {
    unint64_t v161 = v160;
  }
  if (v161)
  {
    float32x4_t v299 = v93;
    float32x4_t v320 = v95;
    float32x4_t v340 = v94;
    if (v161 > 0x555555555555555) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    HGRect v162 = (char *)operator new(48 * v161);
    float32x4_t v95 = v320;
    float32x4_t v94 = v340;
    float32x4_t v93 = v299;
  }
  else
  {
    HGRect v162 = 0;
  }
  float32x4_t v163 = &v162[16 * (k - v71)];
  unint64_t v73 = (unint64_t)&v162[48 * v161];
  *(float32x4_t *)float32x4_t v163 = v93;
  *((float32x4_t *)v163 + 1) = v95;
  *((float32x4_t *)v163 + 2) = v94;
  uint64_t v96 = (float32x4_t *)(v163 + 48);
  if (k == v71)
  {
    std::string __p = &v162[16 * (k - v71)];
    int8x16_t v357 = &v162[48 * v161];
LABEL_189:
    operator delete(v71);
    goto LABEL_190;
  }
  do
  {
    float32x4_t v164 = k[-3];
    float32x4_t v165 = k[-1];
    *((float32x4_t *)v163 - 2) = k[-2];
    *((float32x4_t *)v163 - 1) = v165;
    *((float32x4_t *)v163 - 3) = v164;
    v163 -= 48;
    k -= 3;
  }
  while (k != v71);
  std::string __p = v163;
  int8x16_t v357 = &v162[48 * v161];
  if (v71) {
    goto LABEL_189;
  }
LABEL_190:
  uint64_t v71 = (float32x4_t *)v163;
  int8x16_t v356 = v96;
  float32x4_t v97 = *((float32x4_t *)v9 + 1);
  float32x4_t v99 = *((float32x4_t *)v9 + 7);
  float32x4_t v98 = *((float32x4_t *)v9 + 8);
  if ((unint64_t)v96 < v73)
  {
LABEL_130:
    *uint64_t v96 = v99;
    v96[1] = v97;
    uint64_t v100 = v96 + 3;
    v96[2] = v98;
    int8x16_t v356 = v96 + 3;
    float32x4_t v101 = *((float32x4_t *)v9 + 9);
    float32x4_t v103 = *((float32x4_t *)v9 + 3);
    float32x4_t v102 = *((float32x4_t *)v9 + 4);
    if ((unint64_t)&v96[3] < v73) {
      goto LABEL_131;
    }
    goto LABEL_208;
  }
LABEL_191:
  unint64_t v166 = 0xAAAAAAAAAAAAAAABLL * (v96 - v71) + 1;
  if (v166 > 0x555555555555555) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  if (0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4) > v166) {
    unint64_t v166 = 0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v73 - (void)v71) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v167 = 0x555555555555555;
  }
  else {
    unint64_t v167 = v166;
  }
  if (v167)
  {
    float32x4_t v300 = v99;
    float32x4_t v321 = v97;
    float32x4_t v341 = v98;
    if (v167 > 0x555555555555555) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    float32x4_t v168 = (char *)operator new(48 * v167);
    float32x4_t v97 = v321;
    float32x4_t v98 = v341;
    float32x4_t v99 = v300;
  }
  else
  {
    float32x4_t v168 = 0;
  }
  float32x4_t v169 = &v168[16 * (v96 - v71)];
  unint64_t v73 = (unint64_t)&v168[48 * v167];
  *(float32x4_t *)float32x4_t v169 = v99;
  *((float32x4_t *)v169 + 1) = v97;
  *((float32x4_t *)v169 + 2) = v98;
  uint64_t v100 = (float32x4_t *)(v169 + 48);
  if (v96 == v71)
  {
    std::string __p = &v168[16 * (v96 - v71)];
    int8x16_t v357 = &v168[48 * v167];
LABEL_206:
    operator delete(v71);
    goto LABEL_207;
  }
  do
  {
    float32x4_t v170 = v96[-3];
    float32x4_t v171 = v96[-1];
    *((float32x4_t *)v169 - 2) = v96[-2];
    *((float32x4_t *)v169 - 1) = v171;
    *((float32x4_t *)v169 - 3) = v170;
    v169 -= 48;
    v96 -= 3;
  }
  while (v96 != v71);
  std::string __p = v169;
  int8x16_t v357 = &v168[48 * v167];
  if (v71) {
    goto LABEL_206;
  }
LABEL_207:
  uint64_t v71 = (float32x4_t *)v169;
  int8x16_t v356 = v100;
  float32x4_t v101 = *((float32x4_t *)v9 + 9);
  float32x4_t v103 = *((float32x4_t *)v9 + 3);
  float32x4_t v102 = *((float32x4_t *)v9 + 4);
  if ((unint64_t)v100 < v73)
  {
LABEL_131:
    *uint64_t v100 = v103;
    v100[1] = v101;
    int16x8x3_t v104 = v100 + 3;
    void v100[2] = v102;
    int8x16_t v356 = v100 + 3;
    float32x4_t v106 = *((float32x4_t *)v9 + 3);
    float32x4_t v105 = *((float32x4_t *)v9 + 4);
    float32x4_t v107 = *((float32x4_t *)v9 + 2);
    if ((unint64_t)&v100[3] < v73) {
      goto LABEL_132;
    }
    goto LABEL_225;
  }
LABEL_208:
  unint64_t v172 = 0xAAAAAAAAAAAAAAABLL * (v100 - v71) + 1;
  if (v172 > 0x555555555555555) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  if (0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4) > v172) {
    unint64_t v172 = 0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v73 - (void)v71) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v173 = 0x555555555555555;
  }
  else {
    unint64_t v173 = v172;
  }
  if (v173)
  {
    float32x4_t v301 = v103;
    float32x4_t v322 = v101;
    float32x4_t v342 = v102;
    if (v173 > 0x555555555555555) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    float32x4_t v174 = (char *)operator new(48 * v173);
    float32x4_t v101 = v322;
    float32x4_t v102 = v342;
    float32x4_t v103 = v301;
  }
  else
  {
    float32x4_t v174 = 0;
  }
  float32x4_t v175 = &v174[16 * (v100 - v71)];
  unint64_t v73 = (unint64_t)&v174[48 * v173];
  *(float32x4_t *)float32x4_t v175 = v103;
  *((float32x4_t *)v175 + 1) = v101;
  *((float32x4_t *)v175 + 2) = v102;
  int16x8x3_t v104 = (float32x4_t *)(v175 + 48);
  if (v100 == v71)
  {
    std::string __p = &v174[16 * (v100 - v71)];
    int8x16_t v357 = (char *)v73;
LABEL_223:
    operator delete(v71);
    goto LABEL_224;
  }
  do
  {
    float32x4_t v176 = v100[-3];
    float32x4_t v177 = v100[-1];
    *((float32x4_t *)v175 - 2) = v100[-2];
    *((float32x4_t *)v175 - 1) = v177;
    *((float32x4_t *)v175 - 3) = v176;
    v175 -= 48;
    v100 -= 3;
  }
  while (v100 != v71);
  std::string __p = v175;
  int8x16_t v357 = (char *)v73;
  if (v71) {
    goto LABEL_223;
  }
LABEL_224:
  uint64_t v71 = (float32x4_t *)v175;
  int8x16_t v356 = v104;
  float32x4_t v106 = *((float32x4_t *)v9 + 3);
  float32x4_t v105 = *((float32x4_t *)v9 + 4);
  float32x4_t v107 = *((float32x4_t *)v9 + 2);
  if ((unint64_t)v104 < v73)
  {
LABEL_132:
    *int16x8x3_t v104 = v106;
    v104[1] = v105;
    uint64_t v108 = v104 + 3;
    long long v104[2] = v107;
    int8x16_t v356 = v104 + 3;
    double v109 = (float32x4_t *)v358;
    float32x4_t v110 = *((float32x4_t *)v358 + 2);
    float32x4_t v111 = *((float32x4_t *)v358 + 3);
    float32x4_t v112 = *((float32x4_t *)v358 + 6);
    if ((unint64_t)&v104[3] < v73) {
      goto LABEL_133;
    }
    goto LABEL_242;
  }
LABEL_225:
  unint64_t v178 = 0xAAAAAAAAAAAAAAABLL * (v104 - v71) + 1;
  if (v178 > 0x555555555555555) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  if (0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4) > v178) {
    unint64_t v178 = 0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v73 - (void)v71) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v179 = 0x555555555555555;
  }
  else {
    unint64_t v179 = v178;
  }
  if (v179)
  {
    float32x4_t v302 = v106;
    float32x4_t v323 = v105;
    float32x4_t v343 = v107;
    if (v179 > 0x555555555555555) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    float32x4_t v180 = (char *)operator new(48 * v179);
    float32x4_t v105 = v323;
    float32x4_t v107 = v343;
    float32x4_t v106 = v302;
  }
  else
  {
    float32x4_t v180 = 0;
  }
  float32x4_t v181 = &v180[16 * (v104 - v71)];
  unint64_t v73 = (unint64_t)&v180[48 * v179];
  *(float32x4_t *)float32x4_t v181 = v106;
  *((float32x4_t *)v181 + 1) = v105;
  *((float32x4_t *)v181 + 2) = v107;
  uint64_t v108 = (float32x4_t *)(v181 + 48);
  if (v104 == v71)
  {
    std::string __p = &v180[16 * (v104 - v71)];
    int8x16_t v357 = &v180[48 * v179];
LABEL_240:
    operator delete(v71);
    goto LABEL_241;
  }
  do
  {
    float32x4_t v182 = v104[-3];
    float32x4_t v183 = v104[-1];
    *((float32x4_t *)v181 - 2) = v104[-2];
    *((float32x4_t *)v181 - 1) = v183;
    *((float32x4_t *)v181 - 3) = v182;
    v181 -= 48;
    v104 -= 3;
  }
  while (v104 != v71);
  std::string __p = v181;
  int8x16_t v357 = &v180[48 * v179];
  if (v71) {
    goto LABEL_240;
  }
LABEL_241:
  uint64_t v71 = (float32x4_t *)v181;
  int8x16_t v356 = v108;
  double v109 = (float32x4_t *)v358;
  float32x4_t v110 = *((float32x4_t *)v358 + 2);
  float32x4_t v111 = *((float32x4_t *)v358 + 3);
  float32x4_t v112 = *((float32x4_t *)v358 + 6);
  if ((unint64_t)v108 < v73)
  {
LABEL_133:
    *uint64_t v108 = v111;
    v108[1] = v110;
    int8x16_t v113 = v108 + 3;
    v108[2] = v112;
    int8x16_t v356 = v108 + 3;
    float32x4_t v114 = v109[3];
    float32x4_t v115 = v109[6];
    float32x4_t v116 = v109[8];
    if ((unint64_t)&v108[3] < v73) {
      goto LABEL_134;
    }
    goto LABEL_259;
  }
LABEL_242:
  unint64_t v184 = 0xAAAAAAAAAAAAAAABLL * (v108 - v71) + 1;
  if (v184 > 0x555555555555555) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  if (0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4) > v184) {
    unint64_t v184 = 0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v73 - (void)v71) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v185 = 0x555555555555555;
  }
  else {
    unint64_t v185 = v184;
  }
  if (v185)
  {
    float32x4_t v303 = v111;
    float32x4_t v324 = v110;
    float32x4_t v344 = v112;
    if (v185 > 0x555555555555555) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    signed __int32 v186 = (char *)operator new(48 * v185);
    float32x4_t v110 = v324;
    float32x4_t v112 = v344;
    float32x4_t v111 = v303;
  }
  else
  {
    signed __int32 v186 = 0;
  }
  uint64_t v187 = &v186[16 * (v108 - v71)];
  unint64_t v73 = (unint64_t)&v186[48 * v185];
  *(float32x4_t *)uint64_t v187 = v111;
  *((float32x4_t *)v187 + 1) = v110;
  *((float32x4_t *)v187 + 2) = v112;
  int8x16_t v113 = (float32x4_t *)(v187 + 48);
  if (v108 == v71)
  {
    std::string __p = &v186[16 * (v108 - v71)];
    int8x16_t v357 = &v186[48 * v185];
LABEL_257:
    operator delete(v71);
    goto LABEL_258;
  }
  do
  {
    float32x4_t v188 = v108[-3];
    float32x4_t v189 = v108[-1];
    *((float32x4_t *)v187 - 2) = v108[-2];
    *((float32x4_t *)v187 - 1) = v189;
    *((float32x4_t *)v187 - 3) = v188;
    v187 -= 48;
    v108 -= 3;
  }
  while (v108 != v71);
  std::string __p = v187;
  int8x16_t v357 = &v186[48 * v185];
  if (v71) {
    goto LABEL_257;
  }
LABEL_258:
  uint64_t v71 = (float32x4_t *)v187;
  int8x16_t v356 = v113;
  float32x4_t v114 = v109[3];
  float32x4_t v115 = v109[6];
  float32x4_t v116 = v109[8];
  if ((unint64_t)v113 < v73)
  {
LABEL_134:
    *int8x16_t v113 = v114;
    v113[1] = v115;
    float32x4_t v117 = v113 + 3;
    v113[2] = v116;
    int8x16_t v356 = v113 + 3;
    float32x4_t v118 = v109[3];
    float32x4_t v120 = v109[8];
    float32x4_t v119 = v109[9];
    if ((unint64_t)&v113[3] < v73) {
      goto LABEL_135;
    }
    goto LABEL_276;
  }
LABEL_259:
  unint64_t v190 = 0xAAAAAAAAAAAAAAABLL * (v113 - v71) + 1;
  if (v190 > 0x555555555555555) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  if (0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4) > v190) {
    unint64_t v190 = 0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v73 - (void)v71) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v191 = 0x555555555555555;
  }
  else {
    unint64_t v191 = v190;
  }
  if (v191)
  {
    float32x4_t v304 = v114;
    float32x4_t v325 = v115;
    float32x4_t v345 = v116;
    if (v191 > 0x555555555555555) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    int32x4_t v192 = (char *)operator new(48 * v191);
    float32x4_t v115 = v325;
    float32x4_t v116 = v345;
    float32x4_t v114 = v304;
  }
  else
  {
    int32x4_t v192 = 0;
  }
  int8x16_t v193 = &v192[16 * (v113 - v71)];
  unint64_t v73 = (unint64_t)&v192[48 * v191];
  *(float32x4_t *)int8x16_t v193 = v114;
  *((float32x4_t *)v193 + 1) = v115;
  *((float32x4_t *)v193 + 2) = v116;
  float32x4_t v117 = (float32x4_t *)(v193 + 48);
  if (v113 == v71)
  {
    std::string __p = &v192[16 * (v113 - v71)];
    int8x16_t v357 = &v192[48 * v191];
LABEL_274:
    operator delete(v71);
    goto LABEL_275;
  }
  do
  {
    float32x4_t v194 = v113[-3];
    float32x4_t v195 = v113[-1];
    *((float32x4_t *)v193 - 2) = v113[-2];
    *((float32x4_t *)v193 - 1) = v195;
    *((float32x4_t *)v193 - 3) = v194;
    v193 -= 48;
    v113 -= 3;
  }
  while (v113 != v71);
  std::string __p = v193;
  int8x16_t v357 = &v192[48 * v191];
  if (v71) {
    goto LABEL_274;
  }
LABEL_275:
  uint64_t v71 = (float32x4_t *)v193;
  int8x16_t v356 = v117;
  float32x4_t v118 = v109[3];
  float32x4_t v120 = v109[8];
  float32x4_t v119 = v109[9];
  if ((unint64_t)v117 < v73)
  {
LABEL_135:
    *float32x4_t v117 = v118;
    v117[1] = v120;
    int32x4_t v121 = v117 + 3;
    v117[2] = v119;
    int8x16_t v356 = v117 + 3;
    float32x4_t v122 = v109[9];
    float32x4_t v124 = v109[4];
    float32x4_t v123 = v109[5];
    if ((unint64_t)&v117[3] < v73) {
      goto LABEL_136;
    }
    goto LABEL_293;
  }
LABEL_276:
  unint64_t v196 = 0xAAAAAAAAAAAAAAABLL * (v117 - v71) + 1;
  if (v196 > 0x555555555555555) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  if (0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4) > v196) {
    unint64_t v196 = 0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v73 - (void)v71) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v197 = 0x555555555555555;
  }
  else {
    unint64_t v197 = v196;
  }
  if (v197)
  {
    float32x4_t v305 = v118;
    float32x4_t v326 = v120;
    float32x4_t v346 = v119;
    if (v197 > 0x555555555555555) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v198 = (char *)operator new(48 * v197);
    float32x4_t v120 = v326;
    float32x4_t v119 = v346;
    float32x4_t v118 = v305;
  }
  else
  {
    uint64_t v198 = 0;
  }
  float32x4_t v199 = &v198[16 * (v117 - v71)];
  unint64_t v73 = (unint64_t)&v198[48 * v197];
  *(float32x4_t *)float32x4_t v199 = v118;
  *((float32x4_t *)v199 + 1) = v120;
  *((float32x4_t *)v199 + 2) = v119;
  int32x4_t v121 = (float32x4_t *)(v199 + 48);
  if (v117 == v71)
  {
    std::string __p = &v198[16 * (v117 - v71)];
    int8x16_t v357 = &v198[48 * v197];
LABEL_291:
    operator delete(v71);
    goto LABEL_292;
  }
  do
  {
    float32x4_t v200 = v117[-3];
    float32x4_t v201 = v117[-1];
    *((float32x4_t *)v199 - 2) = v117[-2];
    *((float32x4_t *)v199 - 1) = v201;
    *((float32x4_t *)v199 - 3) = v200;
    v199 -= 48;
    v117 -= 3;
  }
  while (v117 != v71);
  std::string __p = v199;
  int8x16_t v357 = &v198[48 * v197];
  if (v71) {
    goto LABEL_291;
  }
LABEL_292:
  uint64_t v71 = (float32x4_t *)v199;
  int8x16_t v356 = v121;
  float32x4_t v122 = v109[9];
  float32x4_t v124 = v109[4];
  float32x4_t v123 = v109[5];
  if ((unint64_t)v121 < v73)
  {
LABEL_136:
    *int32x4_t v121 = v124;
    v121[1] = v122;
    uint64_t v125 = v121 + 3;
    v121[2] = v123;
    int8x16_t v356 = v121 + 3;
    float32x4_t v126 = v109[2];
    float32x4_t v127 = v109[4];
    float32x4_t v128 = v109[11];
    if ((unint64_t)&v121[3] < v73) {
      goto LABEL_137;
    }
    goto LABEL_310;
  }
LABEL_293:
  unint64_t v202 = 0xAAAAAAAAAAAAAAABLL * (v121 - v71) + 1;
  if (v202 > 0x555555555555555) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  if (0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4) > v202) {
    unint64_t v202 = 0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v73 - (void)v71) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v203 = 0x555555555555555;
  }
  else {
    unint64_t v203 = v202;
  }
  if (v203)
  {
    float32x4_t v306 = v124;
    float32x4_t v327 = v122;
    float32x4_t v347 = v123;
    if (v203 > 0x555555555555555) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v204 = (char *)operator new(48 * v203);
    float32x4_t v122 = v327;
    float32x4_t v123 = v347;
    float32x4_t v124 = v306;
  }
  else
  {
    uint64_t v204 = 0;
  }
  float32x4_t v205 = &v204[16 * (v121 - v71)];
  unint64_t v73 = (unint64_t)&v204[48 * v203];
  *(float32x4_t *)float32x4_t v205 = v124;
  *((float32x4_t *)v205 + 1) = v122;
  *((float32x4_t *)v205 + 2) = v123;
  uint64_t v125 = (float32x4_t *)(v205 + 48);
  if (v121 == v71)
  {
    std::string __p = &v204[16 * (v121 - v71)];
    int8x16_t v357 = &v204[48 * v203];
LABEL_308:
    operator delete(v71);
    goto LABEL_309;
  }
  do
  {
    float32x4_t v206 = v121[-3];
    float32x4_t v207 = v121[-1];
    *((float32x4_t *)v205 - 2) = v121[-2];
    *((float32x4_t *)v205 - 1) = v207;
    *((float32x4_t *)v205 - 3) = v206;
    v205 -= 48;
    v121 -= 3;
  }
  while (v121 != v71);
  std::string __p = v205;
  int8x16_t v357 = &v204[48 * v203];
  if (v71) {
    goto LABEL_308;
  }
LABEL_309:
  uint64_t v71 = (float32x4_t *)v205;
  int8x16_t v356 = v125;
  float32x4_t v126 = v109[2];
  float32x4_t v127 = v109[4];
  float32x4_t v128 = v109[11];
  if ((unint64_t)v125 < v73)
  {
LABEL_137:
    *uint64_t v125 = v126;
    v125[1] = v127;
    float32x2_t v129 = v125 + 3;
    v125[2] = v128;
    int8x16_t v356 = v125 + 3;
    float32x4_t v130 = v109[6];
    float32x4_t v131 = v109[2];
    float32x4_t v132 = v109[10];
    if ((unint64_t)&v125[3] < v73) {
      goto LABEL_138;
    }
    goto LABEL_327;
  }
LABEL_310:
  unint64_t v208 = 0xAAAAAAAAAAAAAAABLL * (v125 - v71) + 1;
  if (v208 > 0x555555555555555) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  if (0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4) > v208) {
    unint64_t v208 = 0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v73 - (void)v71) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v209 = 0x555555555555555;
  }
  else {
    unint64_t v209 = v208;
  }
  if (v209)
  {
    float32x4_t v307 = v126;
    float32x4_t v328 = v127;
    float32x4_t v348 = v128;
    if (v209 > 0x555555555555555) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v210 = (char *)operator new(48 * v209);
    float32x4_t v127 = v328;
    float32x4_t v128 = v348;
    float32x4_t v126 = v307;
  }
  else
  {
    uint64_t v210 = 0;
  }
  float32x4_t v211 = &v210[16 * (v125 - v71)];
  unint64_t v73 = (unint64_t)&v210[48 * v209];
  *(float32x4_t *)float32x4_t v211 = v126;
  *((float32x4_t *)v211 + 1) = v127;
  *((float32x4_t *)v211 + 2) = v128;
  float32x2_t v129 = (float32x4_t *)(v211 + 48);
  if (v125 == v71)
  {
    std::string __p = &v210[16 * (v125 - v71)];
    int8x16_t v357 = &v210[48 * v209];
LABEL_325:
    operator delete(v71);
    goto LABEL_326;
  }
  do
  {
    float32x4_t v212 = v125[-3];
    float32x4_t v213 = v125[-1];
    *((float32x4_t *)v211 - 2) = v125[-2];
    *((float32x4_t *)v211 - 1) = v213;
    *((float32x4_t *)v211 - 3) = v212;
    v211 -= 48;
    v125 -= 3;
  }
  while (v125 != v71);
  std::string __p = v211;
  int8x16_t v357 = &v210[48 * v209];
  if (v71) {
    goto LABEL_325;
  }
LABEL_326:
  uint64_t v71 = (float32x4_t *)v211;
  int8x16_t v356 = v129;
  float32x4_t v130 = v109[6];
  float32x4_t v131 = v109[2];
  float32x4_t v132 = v109[10];
  if ((unint64_t)v129 < v73)
  {
LABEL_138:
    *float32x2_t v129 = v130;
    v129[1] = v131;
    float32x4_t v133 = v129 + 3;
    v129[2] = v132;
    int8x16_t v356 = v129 + 3;
    float32x4_t v134 = v109[7];
    float32x4_t v135 = v109[8];
    float32x4_t v136 = v109[6];
    if ((unint64_t)&v129[3] < v73) {
      goto LABEL_139;
    }
    goto LABEL_344;
  }
LABEL_327:
  unint64_t v214 = 0xAAAAAAAAAAAAAAABLL * (v129 - v71) + 1;
  if (v214 > 0x555555555555555) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  if (0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4) > v214) {
    unint64_t v214 = 0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v73 - (void)v71) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v215 = 0x555555555555555;
  }
  else {
    unint64_t v215 = v214;
  }
  if (v215)
  {
    float32x4_t v308 = v130;
    float32x4_t v329 = v131;
    float32x4_t v349 = v132;
    if (v215 > 0x555555555555555) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    int v216 = (char *)operator new(48 * v215);
    float32x4_t v131 = v329;
    float32x4_t v132 = v349;
    float32x4_t v130 = v308;
  }
  else
  {
    int v216 = 0;
  }
  unsigned int v217 = &v216[16 * (v129 - v71)];
  unint64_t v73 = (unint64_t)&v216[48 * v215];
  *(float32x4_t *)unsigned int v217 = v130;
  *((float32x4_t *)v217 + 1) = v131;
  *((float32x4_t *)v217 + 2) = v132;
  float32x4_t v133 = (float32x4_t *)(v217 + 48);
  if (v129 == v71)
  {
    std::string __p = &v216[16 * (v129 - v71)];
    int8x16_t v357 = &v216[48 * v215];
LABEL_342:
    operator delete(v71);
    goto LABEL_343;
  }
  do
  {
    float32x4_t v218 = v129[-3];
    float32x4_t v219 = v129[-1];
    *((float32x4_t *)v217 - 2) = v129[-2];
    *((float32x4_t *)v217 - 1) = v219;
    *((float32x4_t *)v217 - 3) = v218;
    v217 -= 48;
    v129 -= 3;
  }
  while (v129 != v71);
  std::string __p = v217;
  int8x16_t v357 = &v216[48 * v215];
  if (v71) {
    goto LABEL_342;
  }
LABEL_343:
  uint64_t v71 = (float32x4_t *)v217;
  int8x16_t v356 = v133;
  float32x4_t v134 = v109[7];
  float32x4_t v135 = v109[8];
  float32x4_t v136 = v109[6];
  if ((unint64_t)v133 < v73)
  {
LABEL_139:
    *float32x4_t v133 = v135;
    v133[1] = v136;
    float32x4_t v137 = v133 + 3;
    v133[2] = v134;
    int8x16_t v356 = v133 + 3;
    float32x4_t v138 = v109[8];
    float32x4_t v139 = v109[9];
    float32x4_t v140 = v109[1];
    uint64_t v288 = a2;
    if ((unint64_t)&v133[3] < v73) {
      goto LABEL_140;
    }
    goto LABEL_361;
  }
LABEL_344:
  unint64_t v220 = 0xAAAAAAAAAAAAAAABLL * (v133 - v71) + 1;
  if (v220 > 0x555555555555555) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  if (0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4) > v220) {
    unint64_t v220 = 0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v73 - (void)v71) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v221 = 0x555555555555555;
  }
  else {
    unint64_t v221 = v220;
  }
  if (v221)
  {
    float32x4_t v309 = v135;
    float32x4_t v330 = v136;
    float32x4_t v350 = v134;
    if (v221 > 0x555555555555555) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v222 = (char *)operator new(48 * v221);
    float32x4_t v136 = v330;
    float32x4_t v134 = v350;
    float32x4_t v135 = v309;
  }
  else
  {
    uint64_t v222 = 0;
  }
  unint64_t v223 = &v222[16 * (v133 - v71)];
  unint64_t v73 = (unint64_t)&v222[48 * v221];
  *(float32x4_t *)unint64_t v223 = v135;
  *((float32x4_t *)v223 + 1) = v136;
  *((float32x4_t *)v223 + 2) = v134;
  float32x4_t v137 = (float32x4_t *)(v223 + 48);
  if (v133 == v71)
  {
    std::string __p = &v222[16 * (v133 - v71)];
    int8x16_t v357 = &v222[48 * v221];
LABEL_359:
    operator delete(v71);
    goto LABEL_360;
  }
  do
  {
    float32x4_t v224 = v133[-3];
    float32x4_t v225 = v133[-1];
    *((float32x4_t *)v223 - 2) = v133[-2];
    *((float32x4_t *)v223 - 1) = v225;
    *((float32x4_t *)v223 - 3) = v224;
    v223 -= 48;
    v133 -= 3;
  }
  while (v133 != v71);
  std::string __p = v223;
  int8x16_t v357 = &v222[48 * v221];
  if (v71) {
    goto LABEL_359;
  }
LABEL_360:
  uint64_t v71 = (float32x4_t *)v223;
  int8x16_t v356 = v137;
  float32x4_t v138 = v109[8];
  float32x4_t v139 = v109[9];
  float32x4_t v140 = v109[1];
  uint64_t v288 = a2;
  if ((unint64_t)v137 < v73)
  {
LABEL_140:
    *float32x4_t v137 = v139;
    v137[1] = v138;
    float32x4_t v141 = v137 + 3;
    v137[2] = v140;
    int8x16_t v356 = v137 + 3;
    if (a1 < 1) {
      goto LABEL_458;
    }
    goto LABEL_378;
  }
LABEL_361:
  unint64_t v226 = 0xAAAAAAAAAAAAAAABLL * (v137 - v71) + 1;
  if (v226 > 0x555555555555555) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  if (0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4) > v226) {
    unint64_t v226 = 0x5555555555555556 * ((uint64_t)(v73 - (void)v71) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v73 - (void)v71) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v227 = 0x555555555555555;
  }
  else {
    unint64_t v227 = v226;
  }
  if (v227)
  {
    float32x4_t v310 = v139;
    float32x4_t v331 = v138;
    float32x4_t v351 = v140;
    if (v227 > 0x555555555555555) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    unint64_t v228 = (char *)operator new(48 * v227);
    float32x4_t v138 = v331;
    float32x4_t v140 = v351;
    float32x4_t v139 = v310;
  }
  else
  {
    unint64_t v228 = 0;
  }
  unint64_t v229 = (float32x4_t *)&v228[16 * (v137 - v71)];
  uint64_t v230 = &v228[48 * v227];
  *unint64_t v229 = v139;
  v229[1] = v138;
  v229[2] = v140;
  float32x4_t v141 = v229 + 3;
  if (v137 == v71)
  {
    std::string __p = &v228[16 * (v137 - v71)];
    int8x16_t v357 = v230;
    goto LABEL_377;
  }
  do
  {
    float32x4_t v231 = v137[-3];
    float32x4_t v232 = v137[-1];
    v229[-2] = v137[-2];
    v229[-1] = v232;
    v229[-3] = v231;
    v229 -= 3;
    v137 -= 3;
  }
  while (v137 != v71);
  std::string __p = v229;
  int8x16_t v357 = v230;
  if (v71)
  {
LABEL_377:
    operator delete(v71);
    uint64_t v71 = v229;
    int8x16_t v356 = v141;
    if (a1 < 1) {
      goto LABEL_458;
    }
    goto LABEL_378;
  }
  uint64_t v71 = v229;
  int8x16_t v356 = v141;
  if (a1 >= 1)
  {
LABEL_378:
    for (int m = 0; m != a1; ++m)
    {
      float32x4_t v353 = 0;
      unint64_t v354 = 0;
      if (v141 == v71)
      {
        float32x4_t v141 = 0;
        uint64_t v286 = 0;
        std::string __p = 0;
        int8x16_t v356 = 0;
        int8x16_t v357 = 0;
        if (!v71) {
          goto LABEL_379;
        }
LABEL_457:
        operator delete(v71);
        goto LABEL_379;
      }
      unint64_t v234 = 0;
      float32x4_t v141 = 0;
      unint64_t v235 = 0;
      do
      {
        float32x4_t v236 = &v71[3 * v235];
        float32x4_t v237 = v236[1];
        float32x4_t v238 = vaddq_f32(*v236, v237);
        int32x4_t v239 = (int32x4_t)vmulq_f32(v238, v238);
        v239.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v239, 2), vadd_f32(*(float32x2_t *)v239.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v239.i8, 1))).u32[0];
        float32x2_t v240 = vrsqrte_f32((float32x2_t)v239.u32[0]);
        float32x2_t v241 = vmul_f32(v240, vrsqrts_f32((float32x2_t)v239.u32[0], vmul_f32(v240, v240)));
        float32x4_t v242 = vmulq_n_f32(v238, vmul_f32(v241, vrsqrts_f32((float32x2_t)v239.u32[0], vmul_f32(v241, v241))).f32[0]);
        float32x4_t v243 = v236[2];
        float32x4_t v244 = vaddq_f32(v237, v243);
        int32x4_t v245 = (int32x4_t)vmulq_f32(v244, v244);
        v245.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v245, 2), vadd_f32(*(float32x2_t *)v245.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v245.i8, 1))).u32[0];
        float32x2_t v246 = vrsqrte_f32((float32x2_t)v245.u32[0]);
        float32x2_t v247 = vmul_f32(v246, vrsqrts_f32((float32x2_t)v245.u32[0], vmul_f32(v246, v246)));
        float32x4_t v248 = vmulq_n_f32(v244, vmul_f32(v247, vrsqrts_f32((float32x2_t)v245.u32[0], vmul_f32(v247, v247))).f32[0]);
        float32x4_t v249 = vaddq_f32(*v236, v243);
        int32x4_t v250 = (int32x4_t)vmulq_f32(v249, v249);
        v250.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v250, 2), vadd_f32(*(float32x2_t *)v250.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v250.i8, 1))).u32[0];
        *(float32x2_t *)v243.f32 = vrsqrte_f32((float32x2_t)v250.u32[0]);
        *(float32x2_t *)v243.f32 = vmul_f32(*(float32x2_t *)v243.f32, vrsqrts_f32((float32x2_t)v250.u32[0], vmul_f32(*(float32x2_t *)v243.f32, *(float32x2_t *)v243.f32)));
        float32x4_t v251 = vmulq_n_f32(v249, vmul_f32(*(float32x2_t *)v243.f32, vrsqrts_f32((float32x2_t)v250.u32[0], vmul_f32(*(float32x2_t *)v243.f32, *(float32x2_t *)v243.f32))).f32[0]);
        float32x4_t v332 = v251;
        float32x4_t v352 = v248;
        float32x4_t v311 = v242;
        if ((unint64_t)v141 < v234)
        {
          *float32x4_t v141 = v242;
          v141[1] = v248;
          v141[2] = v251;
          float32x4_t v252 = v141 + 3;
          unint64_t v234 = v354;
          goto LABEL_401;
        }
        unint64_t v253 = 0xAAAAAAAAAAAAAAABLL * (v141 - v353) + 1;
        if (v253 > 0x555555555555555) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        if (0x5555555555555556 * ((uint64_t)(v234 - (void)v353) >> 4) > v253) {
          unint64_t v253 = 0x5555555555555556 * ((uint64_t)(v234 - (void)v353) >> 4);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v234 - (void)v353) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
          unint64_t v254 = 0x555555555555555;
        }
        else {
          unint64_t v254 = v253;
        }
        if (v254)
        {
          if (v254 > 0x555555555555555) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          float32x4_t v255 = (char *)operator new(48 * v254);
          float32x4_t v251 = v332;
          float32x4_t v248 = v352;
          float32x4_t v242 = v311;
          float32x4_t v256 = (float32x4_t *)&v255[16 * (v141 - v353)];
          *float32x4_t v256 = v311;
          v256[1] = v352;
          v256[2] = v332;
          float32x4_t v257 = v256;
          if (v141 == v353) {
            goto LABEL_399;
          }
        }
        else
        {
          float32x4_t v255 = 0;
          float32x4_t v256 = (float32x4_t *)(16 * (v141 - v353));
          *float32x4_t v256 = v242;
          v256[1] = v248;
          v256[2] = v251;
          float32x4_t v257 = v256;
          if (v141 == v353) {
            goto LABEL_399;
          }
        }
        do
        {
          float32x4_t v258 = v141[-3];
          float32x4_t v259 = v141[-1];
          v257[-2] = v141[-2];
          v257[-1] = v259;
          v257[-3] = v258;
          v257 -= 3;
          v141 -= 3;
        }
        while (v141 != v353);
        float32x4_t v141 = v353;
LABEL_399:
        unint64_t v234 = (unint64_t)&v255[48 * v254];
        float32x4_t v252 = v256 + 3;
        float32x4_t v353 = v257;
        unint64_t v354 = v234;
        if (v141)
        {
          operator delete(v141);
          float32x4_t v242 = v311;
          float32x4_t v251 = v332;
          float32x4_t v248 = v352;
        }
LABEL_401:
        float32x4_t v260 = *v236;
        if ((unint64_t)v252 < v234)
        {
          *float32x4_t v252 = v260;
          v252[1] = v242;
          float32x4_t v261 = v252 + 3;
          v252[2] = v251;
          float32x4_t v262 = v236[1];
          if ((unint64_t)&v252[3] < v234) {
            goto LABEL_418;
          }
          goto LABEL_421;
        }
        signed __int32 v263 = v353;
        unint64_t v264 = 0xAAAAAAAAAAAAAAABLL * (v252 - v353) + 1;
        if (v264 > 0x555555555555555) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        if (0x5555555555555556 * ((uint64_t)(v234 - (void)v353) >> 4) > v264) {
          unint64_t v264 = 0x5555555555555556 * ((uint64_t)(v234 - (void)v353) >> 4);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v234 - (void)v353) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
          unint64_t v265 = 0x555555555555555;
        }
        else {
          unint64_t v265 = v264;
        }
        if (v265)
        {
          float32x4_t v290 = *v236;
          if (v265 > 0x555555555555555) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          float32x4_t v266 = (char *)operator new(48 * v265);
          float32x4_t v251 = v332;
          float32x4_t v248 = v352;
          float32x4_t v260 = v290;
          float32x4_t v242 = v311;
        }
        else
        {
          float32x4_t v266 = 0;
        }
        float32x4_t v267 = (float32x4_t *)&v266[16 * (v252 - v353)];
        unint64_t v234 = (unint64_t)&v266[48 * v265];
        *float32x4_t v267 = v260;
        v267[1] = v242;
        v267[2] = v251;
        float32x4_t v261 = v267 + 3;
        if (v252 == v353)
        {
          float32x4_t v353 = (float32x4_t *)&v266[16 * (v252 - v353)];
          unint64_t v354 = v234;
          signed __int32 v263 = v252;
        }
        else
        {
          do
          {
            float32x4_t v268 = v252[-3];
            float32x4_t v269 = v252[-1];
            v267[-2] = v252[-2];
            v267[-1] = v269;
            v267[-3] = v268;
            v267 -= 3;
            v252 -= 3;
          }
          while (v252 != v353);
          float32x4_t v353 = v267;
          unint64_t v354 = v234;
          if (!v263)
          {
            float32x4_t v262 = v236[1];
            if ((unint64_t)v261 < v234) {
              goto LABEL_418;
            }
            goto LABEL_421;
          }
        }
        operator delete(v263);
        float32x4_t v242 = v311;
        float32x4_t v251 = v332;
        float32x4_t v248 = v352;
        float32x4_t v262 = v236[1];
        if ((unint64_t)v261 < v234)
        {
LABEL_418:
          *float32x4_t v261 = v242;
          v261[1] = v262;
          int8x16_t v270 = v261 + 3;
          v261[2] = v248;
          goto LABEL_437;
        }
LABEL_421:
        int8x16_t v271 = v353;
        unint64_t v272 = 0xAAAAAAAAAAAAAAABLL * (v261 - v353) + 1;
        if (v272 > 0x555555555555555) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        if (0x5555555555555556 * ((uint64_t)(v234 - (void)v353) >> 4) > v272) {
          unint64_t v272 = 0x5555555555555556 * ((uint64_t)(v234 - (void)v353) >> 4);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v234 - (void)v353) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
          unint64_t v273 = 0x555555555555555;
        }
        else {
          unint64_t v273 = v272;
        }
        if (v273)
        {
          float32x4_t v291 = v262;
          if (v273 > 0x555555555555555) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          int32x4_t v274 = (char *)operator new(48 * v273);
          float32x4_t v251 = v332;
          float32x4_t v248 = v352;
          float32x4_t v262 = v291;
          float32x4_t v242 = v311;
        }
        else
        {
          int32x4_t v274 = 0;
        }
        int v275 = (float32x4_t *)&v274[16 * (v261 - v353)];
        unint64_t v234 = (unint64_t)&v274[48 * v273];
        *int v275 = v242;
        v275[1] = v262;
        v275[2] = v248;
        int8x16_t v270 = v275 + 3;
        if (v261 == v353)
        {
          float32x4_t v353 = (float32x4_t *)&v274[16 * (v261 - v353)];
          unint64_t v354 = v234;
          int8x16_t v271 = v261;
LABEL_436:
          operator delete(v271);
          float32x4_t v251 = v332;
          float32x4_t v248 = v352;
          goto LABEL_437;
        }
        do
        {
          float32x4_t v276 = v261[-3];
          float32x4_t v277 = v261[-1];
          v275[-2] = v261[-2];
          v275[-1] = v277;
          v275[-3] = v276;
          v275 -= 3;
          v261 -= 3;
        }
        while (v261 != v353);
        float32x4_t v353 = v275;
        unint64_t v354 = v234;
        if (v271) {
          goto LABEL_436;
        }
LABEL_437:
        float32x4_t v278 = v236[2];
        if ((unint64_t)v270 < v234)
        {
          *int8x16_t v270 = v251;
          v270[1] = v248;
          float32x4_t v141 = v270 + 3;
          v270[2] = v278;
          goto LABEL_383;
        }
        float32x4_t v279 = v353;
        unint64_t v280 = 0xAAAAAAAAAAAAAAABLL * (v270 - v353) + 1;
        if (v280 > 0x555555555555555) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        if (0x5555555555555556 * ((uint64_t)(v234 - (void)v353) >> 4) > v280) {
          unint64_t v280 = 0x5555555555555556 * ((uint64_t)(v234 - (void)v353) >> 4);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v234 - (void)v353) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
          unint64_t v281 = 0x555555555555555;
        }
        else {
          unint64_t v281 = v280;
        }
        if (v281)
        {
          float32x4_t v312 = v278;
          if (v281 > 0x555555555555555) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v282 = (char *)operator new(48 * v281);
          float32x4_t v251 = v332;
          float32x4_t v248 = v352;
          float32x4_t v278 = v312;
        }
        else
        {
          uint64_t v282 = 0;
        }
        uint64_t v283 = (float32x4_t *)&v282[16 * (v270 - v353)];
        unint64_t v234 = (unint64_t)&v282[48 * v281];
        *uint64_t v283 = v251;
        v283[1] = v248;
        v283[2] = v278;
        float32x4_t v141 = v283 + 3;
        if (v270 == v353)
        {
          float32x4_t v353 = (float32x4_t *)&v282[16 * (v270 - v353)];
          unint64_t v354 = v234;
          float32x4_t v279 = v270;
LABEL_453:
          operator delete(v279);
          goto LABEL_383;
        }
        do
        {
          float32x4_t v284 = v270[-3];
          float32x4_t v285 = v270[-1];
          v283[-2] = v270[-2];
          v283[-1] = v285;
          v283[-3] = v284;
          v283 -= 3;
          v270 -= 3;
        }
        while (v270 != v353);
        float32x4_t v353 = v283;
        unint64_t v354 = v234;
        if (v279) {
          goto LABEL_453;
        }
LABEL_383:
        ++v235;
        uint64_t v71 = (float32x4_t *)__p;
      }
      while (v235 < 0xAAAAAAAAAAAAAAABLL * (((char *)v356 - (unsigned char *)__p) >> 4));
      uint64_t v286 = v353;
      std::string __p = v353;
      int8x16_t v356 = v141;
      int8x16_t v357 = (char *)v234;
      if (v71) {
        goto LABEL_457;
      }
LABEL_379:
      uint64_t v71 = v286;
    }
  }
LABEL_458:
  project_util::fill_flat_array(&__p, v288);
  if (__p) {
    operator delete(__p);
  }
  uint64_t v287 = v358;
  if (v358)
  {
    operator delete(v287);
  }
}