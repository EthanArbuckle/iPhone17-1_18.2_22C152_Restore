void sub_1B7A345B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,void *__p,uint64_t a57,uint64_t a58,void *a59,uint64_t a60,uint64_t a61,void *a62,uint64_t a63)
{
  void *a65;
  void *a68;

  if (__p) {
    operator delete(__p);
  }
  if (a59) {
    operator delete(a59);
  }
  if (a62) {
    operator delete(a62);
  }
  if (a65) {
    operator delete(a65);
  }
  if (a68) {
    operator delete(a68);
  }
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::chainHull_2D(float32x2_t **a1, uint64_t a2, __n128 a3)
{
  v4 = *a1;
  v5 = a1[1];
  if (v4 == v5) {
    return 0;
  }
  float32x2_t v7 = vadd_f32(*v4, (float32x2_t)vdup_n_s32(0x3A83126Fu));
  v8 = a1[2];
  if (v5 >= v8)
  {
    uint64_t v11 = v5 - v4;
    unint64_t v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) >> 61) {
      goto LABEL_127;
    }
    uint64_t v13 = (char *)v8 - (char *)v4;
    if (v13 >> 2 > v12) {
      unint64_t v12 = v13 >> 2;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v12;
    }
    if (v14)
    {
      v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a1 + 2), v14);
      v4 = *a1;
      v5 = a1[1];
    }
    else
    {
      v15 = 0;
    }
    v16 = (float32x2_t *)&v15[8 * v11];
    v8 = (float32x2_t *)&v15[8 * v14];
    float32x2_t *v16 = v7;
    v9 = v16 + 1;
    while (v5 != v4)
    {
      __int32 v17 = v5[-1].i32[0];
      --v5;
      v16[-1].i32[0] = v17;
      --v16;
      v16->i32[1] = v5->i32[1];
    }
    *a1 = v16;
    a1[1] = v9;
    a1[2] = v8;
    if (v4)
    {
      operator delete(v4);
      v4 = *a1;
      v8 = a1[2];
    }
    else
    {
      v4 = v16;
    }
  }
  else
  {
    float32x2_t *v5 = v7;
    v9 = v5 + 1;
  }
  a1[1] = v9;
  float32x2_t v18 = vadd_f32(*v4, (float32x2_t)0x3A83126FBA83126FLL);
  if (v9 >= v8)
  {
    uint64_t v20 = v9 - v4;
    unint64_t v21 = v20 + 1;
    if ((unint64_t)(v20 + 1) >> 61) {
      goto LABEL_127;
    }
    uint64_t v22 = (char *)v8 - (char *)v4;
    if (v22 >> 2 > v21) {
      unint64_t v21 = v22 >> 2;
    }
    if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v23 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v23 = v21;
    }
    if (v23)
    {
      v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a1 + 2), v23);
      v4 = *a1;
      v9 = a1[1];
    }
    else
    {
      v24 = 0;
    }
    v25 = (float32x2_t *)&v24[8 * v20];
    v8 = (float32x2_t *)&v24[8 * v23];
    float32x2_t *v25 = v18;
    v19 = v25 + 1;
    while (v9 != v4)
    {
      __int32 v26 = v9[-1].i32[0];
      --v9;
      v25[-1].i32[0] = v26;
      --v25;
      v25->i32[1] = v9->i32[1];
    }
    *a1 = v25;
    a1[1] = v19;
    a1[2] = v8;
    if (v4)
    {
      operator delete(v4);
      v4 = *a1;
      v8 = a1[2];
    }
    else
    {
      v4 = v25;
    }
  }
  else
  {
    float32x2_t *v9 = v18;
    v19 = v9 + 1;
  }
  a1[1] = v19;
  float32x2_t v27 = vadd_f32(*v4, (float32x2_t)vdup_n_s32(0xBA83126F));
  if (v19 >= v8)
  {
    uint64_t v29 = v19 - v4;
    unint64_t v30 = v29 + 1;
    if ((unint64_t)(v29 + 1) >> 61) {
      goto LABEL_127;
    }
    uint64_t v31 = (char *)v8 - (char *)v4;
    if (v31 >> 2 > v30) {
      unint64_t v30 = v31 >> 2;
    }
    if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v32 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v32 = v30;
    }
    if (v32)
    {
      v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a1 + 2), v32);
      v4 = *a1;
      v19 = a1[1];
    }
    else
    {
      v33 = 0;
    }
    v34 = (float32x2_t *)&v33[8 * v29];
    v8 = (float32x2_t *)&v33[8 * v32];
    float32x2_t *v34 = v27;
    v28 = v34 + 1;
    while (v19 != v4)
    {
      __int32 v35 = v19[-1].i32[0];
      --v19;
      v34[-1].i32[0] = v35;
      --v34;
      v34->i32[1] = v19->i32[1];
    }
    *a1 = v34;
    a1[1] = v28;
    a1[2] = v8;
    if (v4)
    {
      operator delete(v4);
      v4 = *a1;
      v8 = a1[2];
    }
    else
    {
      v4 = v34;
    }
  }
  else
  {
    float32x2_t *v19 = v27;
    v28 = v19 + 1;
  }
  a1[1] = v28;
  a3.n128_u64[0] = (unint64_t)*v4;
  float32x2_t v36 = vadd_f32(*v4, (float32x2_t)0xBA83126F3A83126FLL);
  if (v28 < v8)
  {
    float32x2_t *v28 = v36;
    v37 = (char *)&v28[1];
    goto LABEL_71;
  }
  uint64_t v38 = v28 - v4;
  unint64_t v39 = v38 + 1;
  if ((unint64_t)(v38 + 1) >> 61) {
LABEL_127:
  }
    std::vector<double>::__throw_length_error[abi:ne180100]();
  uint64_t v40 = (char *)v8 - (char *)v4;
  if (v40 >> 2 > v39) {
    unint64_t v39 = v40 >> 2;
  }
  if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v41 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v41 = v39;
  }
  if (v41)
  {
    v42 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a1 + 2), v41);
    v4 = *a1;
    v28 = a1[1];
  }
  else
  {
    v42 = 0;
  }
  v43 = (float32x2_t *)&v42[8 * v38];
  v44 = (float32x2_t *)&v42[8 * v41];
  float32x2_t *v43 = v36;
  v37 = (char *)&v43[1];
  while (v28 != v4)
  {
    __int32 v45 = v28[-1].i32[0];
    --v28;
    v43[-1].i32[0] = v45;
    --v43;
    a3.n128_u32[0] = v28->u32[1];
    v43->i32[1] = a3.n128_u32[0];
  }
  *a1 = v43;
  a1[1] = (float32x2_t *)v37;
  a1[2] = v44;
  if (v4)
  {
    operator delete(v4);
    v4 = *a1;
  }
  else
  {
    v4 = v43;
  }
LABEL_71:
  unint64_t v46 = 126 - 2 * __clz((v37 - (char *)v4) >> 3);
  a1[1] = (float32x2_t *)v37;
  if (v37 == (char *)v4) {
    uint64_t v47 = 0;
  }
  else {
    uint64_t v47 = v46;
  }
  std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*,false>((unint64_t)v4, v37, (uint64_t (**)(uint64_t *, uint64_t *))&v98, v47, 1, a3);
  if ((float32x2_t **)a2 != a1) {
    std::vector<Vec2f>::__assign_with_size[abi:ne180100]<Vec2f*,Vec2f*>((void *)a2, *a1, a1[1], a1[1] - *a1);
  }
  v48 = *a1;
  unint64_t v49 = (char *)a1[1] - (char *)*a1;
  unint64_t v50 = v49 >> 3;
  float v51 = (*a1)->f32[0];
  int v52 = (v49 >> 3) - 2;
  if ((int)(v49 >> 3) >= 2)
  {
    uint64_t v53 = (v49 >> 3);
    v54 = (float *)&v48[1];
    uint64_t v55 = 1;
    while (*v54 == v51)
    {
      ++v55;
      v54 += 2;
      if (v53 == v55)
      {
        int v56 = v50 - 1;
        goto LABEL_84;
      }
    }
    int v56 = v55 - 1;
    if (v50 == v55) {
      goto LABEL_84;
    }
    uint64_t v60 = (int)v50 - 1;
    v61 = &v48[v60];
    uint64_t v63 = (v50 - 2);
    uint64_t v64 = v63 + 1;
    v65 = (float *)&v48[v63];
    while (*v65 == v61->f32[0])
    {
      v65 -= 2;
      if (v64-- <= 1)
      {
        int v52 = -1;
        goto LABEL_95;
      }
    }
    int v52 = v64 - 1;
LABEL_95:
    int v67 = 0;
    int v68 = v52 + 1;
    uint64_t v69 = *(void *)a2;
    *(float *)uint64_t v69 = v51;
    *(_DWORD *)(v69 + 4) = v48->i32[1];
    int v70 = v56;
LABEL_96:
    uint64_t v71 = v70;
    v72 = &v48[v70 + 1];
    while (v71 <= v52)
    {
      int v70 = v71 + 1;
      float32x2_t v73 = *v72++;
      float32x2_t v74 = v73;
      if (v71 < v52)
      {
        int32x2_t v75 = (int32x2_t)vmul_f32((float32x2_t)vrev64_s32((int32x2_t)vsub_f32(v74, *v48)), vsub_f32(v48[v68], *v48));
        ++v71;
        if (vsub_f32((float32x2_t)v75, (float32x2_t)vdup_lane_s32(v75, 1)).f32[0] >= 0.0) {
          continue;
        }
      }
      int v76 = v67 & (v67 >> 31);
      v77 = (float32x2_t *)(v69 + 8 * v67);
      while (1)
      {
        BOOL v78 = __OFSUB__(v67--, 1);
        if (v67 < 0 != v78) {
          break;
        }
        float32x2_t v79 = *v77;
        float32x2_t v80 = v77[-1];
        --v77;
        int32x2_t v81 = (int32x2_t)vmul_f32((float32x2_t)vrev64_s32((int32x2_t)vsub_f32(v74, v80)), vsub_f32(v79, v80));
        if (vsub_f32((float32x2_t)v81, (float32x2_t)vdup_lane_s32(v81, 1)).f32[0] > 0.0)
        {
          int v76 = v67 + 1;
          break;
        }
      }
      int v67 = v76 + 1;
      v82 = (_DWORD *)(v69 + 8 * (v76 + 1));
      _DWORD *v82 = v74.i32[0];
      v82[1] = v72[-1].i32[1];
      goto LABEL_96;
    }
    if (v60 == v68)
    {
      uint64_t v83 = v67;
    }
    else
    {
      uint64_t v83 = ++v67;
      v84 = (_DWORD *)(v69 + 8 * v67);
      _DWORD *v84 = v61->i32[0];
      v84[1] = v61->i32[1];
    }
    int v85 = v67;
LABEL_109:
    uint64_t v86 = v68;
    v87 = (_DWORD *)&v48[v68] + 1;
    while (v86 >= (int)v55)
    {
      int v68 = v86 - 1;
      float32x2_t v88 = *(float32x2_t *)(v87 - 3);
      v87 -= 2;
      if (v86 > (int)v55)
      {
        int32x2_t v89 = (int32x2_t)vmul_f32((float32x2_t)vrev64_s32((int32x2_t)vsub_f32(v88, *v61)), vsub_f32(v48[v56], *v61));
        --v86;
        if (vsub_f32((float32x2_t)v89, (float32x2_t)vdup_lane_s32(v89, 1)).f32[0] >= 0.0) {
          continue;
        }
      }
      uint64_t v90 = v85;
      if (v85 >= v67) {
        int v91 = v67;
      }
      else {
        int v91 = v85;
      }
      int v92 = v85 + 1;
      while (v90 > v83)
      {
        v93 = (float32x2_t *)(v69 + 8 * v90--);
        int32x2_t v94 = (int32x2_t)vmul_f32((float32x2_t)vrev64_s32((int32x2_t)vsub_f32(v88, v93[-1])), vsub_f32(*v93, v93[-1]));
        --v92;
        if (vsub_f32((float32x2_t)v94, (float32x2_t)vdup_lane_s32(v94, 1)).f32[0] > 0.0) {
          goto LABEL_121;
        }
      }
      int v92 = v91;
LABEL_121:
      int v85 = v92 + 1;
      v95 = (_DWORD *)(v69 + 8 * v85);
      _DWORD *v95 = v88.i32[0];
      v95[1] = *v87;
      goto LABEL_109;
    }
    if (v56)
    {
      uint64_t v96 = v85 + 1;
      v97 = (_DWORD *)(v69 + 8 * v96);
      _DWORD *v97 = v48->i32[0];
      v97[1] = v48->i32[1];
    }
    else
    {
      uint64_t v96 = v85;
    }
    uint64_t v62 = v69 + 8 * v96;
    goto LABEL_126;
  }
  if (v50 != 1)
  {
    int v56 = 0;
    uint64_t v60 = (int)v50 - 1;
    v61 = &v48[v60];
    LODWORD(v55) = 1;
    goto LABEL_95;
  }
  int v56 = 0;
LABEL_84:
  uint64_t v57 = *(void *)a2;
  *(float *)uint64_t v57 = v51;
  *(_DWORD *)(v57 + 4) = v48->i32[1];
  v58 = &v48[v56];
  if (v58->f32[1] == v48->f32[1])
  {
    uint64_t v59 = 1;
  }
  else
  {
    *(_DWORD *)(v57 + 8) = v58->i32[0];
    *(_DWORD *)(v57 + 12) = v58->i32[1];
    uint64_t v59 = 2;
  }
  uint64_t v62 = v57 + 8 * v59;
  *(_DWORD *)uint64_t v62 = v48->i32[0];
  *(_DWORD *)(v62 + 4) = v48->i32[1];
LABEL_126:
  std::vector<Vec2f>::erase(a2, (char *)(v62 + 8), *(char **)(a2 + 8));
  return (*(void *)(a2 + 8) - *(void *)a2) >> 3;
}

BOOL anonymous namespace'::rotateSegmentHAroundM(void *a1, int a2, void *a3, Vec2f *a4, int a5, float a6)
{
  if (a5 < 1)
  {
    return 1;
  }
  else
  {
    BOOL v11 = 0;
    int v12 = 0;
    uint64_t v13 = a2 & ~(a2 >> 31);
    uint64_t v14 = a2 - 1;
LABEL_3:
    uint64_t v15 = 0;
    uint64_t v16 = 4;
    while (v13 != v15)
    {
      uint64_t v17 = v15 + 1;
      if (v14 == v15) {
        uint64_t v18 = 0;
      }
      else {
        uint64_t v18 = v15 + 1;
      }
      v19 = (int *)(*a3 + 8 * v18);
      uint64_t v29 = *(void *)(*a3 + v16 - 4);
      int v30 = *v19;
      int v31 = v19[1];
      *(void *)&long long v20 = *a1;
      *((Vec2f *)&v20 + 1) = *a4;
      long long v28 = v20;
      BOOL IntersectionOfLineSegment = OMUtil::findIntersectionOfLineSegment((float *)&v29, (float *)&v28);
      v16 += 8;
      uint64_t v15 = v17;
      if (IntersectionOfLineSegment)
      {
        uint64_t v29 = 1065353216;
        float v23 = OMUtil::angle((OMUtil *)&v29, a4, v22);
        float v24 = a4->var0[1];
        if ((float)((float)(*(float *)&v29 * v24) - (float)(*((float *)&v29 + 1) * a4->var0[0])) < 0.0) {
          float v23 = 6.2832 - v23;
        }
        float v25 = sqrtf((float)(a4->var0[0] * a4->var0[0]) + (float)(v24 * v24));
        __float2 v26 = __sincosf_stret(v23 + a6);
        a4->var0[0] = v25 * v26.__cosval;
        a4->var0[1] = v25 * v26.__sinval;
        BOOL v11 = ++v12 >= a5;
        if (v12 != a5) {
          goto LABEL_3;
        }
        return v11;
      }
    }
  }
  return v11;
}

void OMKeyer2D::computeSatOffsetVector(OMKeyer2D *this)
{
  v2 = (OMPie *)(*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 96))(this);
  OMPie::computeArc(v2, v3, v4);
  v5 = (float32x2_t **)(*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 96))(this);
  OMPie::getArcOut(v5, 0.5, &v8);
  float v6 = sqrtf((float)(v8.f32[0] * v8.f32[0]) + (float)(v8.f32[1] * v8.f32[1]));
  float v7 = v8.f32[1] / v6;
  *((float *)this + 14) = v8.f32[0] / v6;
  *((float *)this + 15) = v7;
}

void OMKeyer2D::setSoftBasedOnOffsetFromTol(OMKeyer2D *this, float a2, float a3, float a4, float a5)
{
  float v10 = (*(float (**)(OMKeyer2D *))(*(void *)this + 40))(this);
  (*(void (**)(OMKeyer2D *, float))(*(void *)this + 64))(this, v10 - (float)(a2 * a3));
  float v11 = (*(float (**)(OMKeyer2D *))(*(void *)this + 48))(this);
  (*(void (**)(OMKeyer2D *, float))(*(void *)this + 88))(this, (float)(a2 * a4) + v11);
  int v12 = (OMPie *)(*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 112))(this);
  uint64_t v13 = (OMPie *)(*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 96))(this);
  OMPie::setBasedOnOffsetFromOtherPie(v12, v13, a2, a5, (const Vec2f *)1);
  uint64_t v14 = *(float **)((*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 112))(this) + 40);
  uint64_t v15 = *(void *)((*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 112))(this) + 40);
  if (vabds_f32(*v14, *(float *)(v15 + 16)) < 0.02)
  {
    float v16 = v14[1];
    if (vabds_f32(v16, *(float *)(v15 + 20)) < 0.02)
    {
      float v17 = sqrtf((float)(*v14 * *v14) + (float)(v16 * v16));
      OMKeyer2D::makeSoftCircle(this, v17);
    }
  }
}

float OMKeyer2D::makeSoftCircle(OMKeyer2D *this, float a2)
{
  uint64_t v3 = *(void *)((*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 112))(this) + 40);
  v4 = *(float **)((*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 112))(this) + 40);
  uint64_t v5 = *(void *)((*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 112))(this) + 40);
  float v6 = *(float32x2_t **)((*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 112))(this) + 40);
  uint64_t v7 = (*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 112))(this);
  float32x2_t v8 = *(float32x2_t *)(v3 + 8);
  v3 += 8;
  uint64_t v9 = *(void *)(v7 + 40);
  int32x2_t v10 = (int32x2_t)vmul_f32(v8, v8);
  *(float *)v10.i32 = sqrtf(vaddv_f32((float32x2_t)v10));
  float32x2_t v11 = vmul_n_f32(vdiv_f32(v8, (float32x2_t)vdup_lane_s32(v10, 0)), a2);
  v6[3] = v11;
  *(_DWORD *)(v9 + 32) = v11.i32[0];
  *(_DWORD *)(v9 + 36) = v6[3].i32[1];
  *(_DWORD *)uint64_t v3 = v11.i32[0];
  *(_DWORD *)(v3 + 4) = *(_DWORD *)(v9 + 36);
  uint64_t v19 = 1065353216;
  float v13 = OMUtil::angle((OMUtil *)&v19, (const Vec2f *)v3, v12);
  if ((float)((float)(*(float *)&v19 * *(float *)(v3 + 4)) - (float)(*((float *)&v19 + 1) * *(float *)v3)) >= 0.0) {
    float v14 = v13;
  }
  else {
    float v14 = 6.2832 - v13;
  }
  __float2 v15 = __sincosf_stret(v14 + 0.1);
  float *v4 = v15.__cosval * a2;
  v4[1] = v15.__sinval * a2;
  __float2 v16 = __sincosf_stret(v14 + -0.1);
  float result = v16.__sinval * a2;
  *(float *)(v5 + 16) = v16.__cosval * a2;
  *(float *)(v5 + 20) = v16.__sinval * a2;
  return result;
}

uint64_t OMKeyer2D::setSoftBasedOnHisto(OMKeyer2D *this, float a2)
{
  float v3 = a2 * 0.2;
  float v4 = a2 * 0.3 + 1.0;
  float v5 = (*(float (**)(OMKeyer2D *))(*(void *)this + 40))(this);
  (*(void (**)(OMKeyer2D *, float))(*(void *)this + 64))(this, v5 - v4);
  float v6 = (*(float (**)(OMKeyer2D *))(*(void *)this + 48))(this);
  (*(void (**)(OMKeyer2D *, float))(*(void *)this + 88))(this, v6 + v4);
  uint64_t v7 = (OMPie *)(*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 112))(this);
  float32x2_t v8 = (OMPie *)(*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 96))(this);
  OMPie::setBasedOnOffsetFromOtherPie(v7, v8, 0.8, 1.0, (const Vec2f *)1);
  uint64_t v9 = *(void *)((*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 112))(this) + 40);
  float v10 = *(float *)(v9 + 8);
  float v11 = *(float *)(v9 + 12);
  float v12 = sqrtf((float)(v10 * v10) + (float)(v11 * v11));
  float v13 = v10 / v12;
  float v14 = v11 / v12;
  __float2 v15 = *(float **)((*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 112))(this) + 40);
  float v16 = *v15;
  float v17 = v15[1];
  uint64_t v18 = *(void *)((*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 96))(this) + 40);
  float v19 = *(float *)(v18 + 24);
  float v20 = *(float *)(v18 + 28);
  float v21 = sqrtf((float)((float)(v19 - v16) * (float)(v19 - v16)) + (float)((float)(v20 - v17) * (float)(v20 - v17)));
  v32[0] = v16;
  v32[1] = v17;
  v32[2] = v19 + (float)((float)(v19 - v16) / v21);
  v32[3] = v20 + (float)((float)(v20 - v17) / v21);
  v31[0] = -v13;
  v31[1] = -v14;
  v31[2] = v13;
  v31[3] = v14;
  if (OMUtil::findIntersectionOfLineSegment(v32, v31, &v33))
  {
    float v22 = sqrtf((float)(v33 * v33) + (float)(v34 * v34));
    if (sqrtf((float)((float)(v13 + v33) * (float)(v13 + v33)) + (float)((float)(v14 + v34) * (float)(v14 + v34))) >= sqrtf((float)((float)(v13 - v33) * (float)(v13 - v33)) + (float)((float)(v14 - v34) * (float)(v14 - v34)))) {
      float v23 = v22;
    }
    else {
      float v23 = -v22;
    }
    if (v3 < v23) {
      float v3 = v23;
    }
  }
  float v24 = v14 * v3;
  float v25 = (float)(v13 * v3) + 0.0;
  float v26 = v24 + 0.0;
  uint64_t v27 = *(void *)((*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 112))(this) + 40);
  *(float *)(v27 + 8) = v25;
  *(float *)(v27 + 12) = v26;
  uint64_t v28 = *(void *)((*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 112))(this) + 40);
  *(float *)(v28 + 24) = v25;
  *(float *)(v28 + 28) = v26;
  uint64_t result = (*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 112))(this);
  uint64_t v30 = *(void *)(result + 40);
  *(float *)(v30 + 32) = v25;
  *(float *)(v30 + 36) = v26;
  return result;
}

void OMKeyer2D::computeCH(uint64_t a1, uint64_t *a2, void *a3, float *a4, float *a5, _DWORD *a6, float *a7, float *a8, __n128 a9)
{
  uint64_t v9 = *a2;
  uint64_t v10 = a2[1];
  if (*a2 != v10)
  {
    __p = 0;
    uint64_t v59 = 0;
    uint64_t v60 = 0;
    if ((int)(-1431655765 * ((unint64_t)(v10 - v9) >> 2)) < 1)
    {
      float v16 = 0;
      float v19 = 1000.0;
      float v20 = -1000.0;
      float v18 = -1000.0;
    }
    else
    {
      float v16 = 0;
      uint64_t v17 = 0;
      float v18 = -1000.0;
      float v19 = 1000.0;
      float v20 = -1000.0;
      do
      {
        uint64_t v21 = v9 + 12 * v17;
        if ((*(_DWORD *)v21 & 0x7FFFFFFFu) <= 0x7F7FFFFF
          && (*(_DWORD *)(v21 + 4) & 0x7FFFFFFFu) <= 0x7F7FFFFF
          && (*(_DWORD *)(v21 + 8) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
        {
          OMKeyer2DColorUtil::rgb2hsl((uint64_t *)v21, (uint64_t)&v61, *(unsigned int *)(a1 + 232), (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, (uint64_t)a8);
          float v22 = 0.0;
          if ((float)(v63 * 255.0) >= 0.0)
          {
            float v22 = 255.0;
            if ((float)(v63 * 255.0) <= 255.0) {
              float v22 = v63 * 255.0;
            }
          }
          int v23 = (int)v22;
          if (v62 <= 1.0) {
            float v24 = v62;
          }
          else {
            float v24 = 1.0;
          }
          __float2 v25 = __sincosf_stret(v61 * 6.2832);
          float v26 = *(float *)(*(void *)(a1 + 72) + 4 * v23);
          float v27 = (float)(v24 * v25.__cosval) - (float)(v26 * *(float *)(a1 + 56));
          float v28 = (float)(v24 * v25.__sinval) - (float)(v26 * *(float *)(a1 + 60));
          uint64_t v29 = v59;
          if (v59 >= (float *)v60)
          {
            uint64_t v30 = (float *)__p;
            uint64_t v31 = ((char *)v59 - (unsigned char *)__p) >> 3;
            unint64_t v32 = v31 + 1;
            if ((unint64_t)(v31 + 1) >> 61) {
              std::vector<double>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v33 = v60 - (unsigned char *)__p;
            if ((v60 - (unsigned char *)__p) >> 2 > v32) {
              unint64_t v32 = v33 >> 2;
            }
            if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v34 = v32;
            }
            if (v34)
            {
              __int32 v35 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v60, v34);
              uint64_t v30 = (float *)__p;
              uint64_t v29 = v59;
            }
            else
            {
              __int32 v35 = 0;
            }
            float32x2_t v36 = (float *)&v35[8 * v31];
            *float32x2_t v36 = v27;
            v36[1] = v28;
            v37 = v36;
            while (v29 != v30)
            {
              int v38 = *((_DWORD *)v29 - 2);
              v29 -= 2;
              *((_DWORD *)v37 - 2) = v38;
              v37 -= 2;
              v37[1] = v29[1];
            }
            float v16 = v36 + 2;
            __p = v37;
            uint64_t v59 = v36 + 2;
            uint64_t v60 = &v35[8 * v34];
            if (v30) {
              operator delete(v30);
            }
          }
          else
          {
            *uint64_t v59 = v27;
            v29[1] = v28;
            float v16 = v29 + 2;
          }
          uint64_t v59 = v16;
          if (v63 > v18) {
            float v18 = v63;
          }
          if (v63 < v19) {
            float v19 = v63;
          }
          if (v62 > v20) {
            float v20 = v62;
          }
        }
        ++v17;
        uint64_t v9 = *a2;
      }
      while (v17 < (int)(-1431655765 * ((unint64_t)(a2[1] - *a2) >> 2)));
    }
    *a5 = (float)(v18 + v18) + -1.0;
    a9.n128_f32[0] = (float)(v19 + v19) + -1.0;
    *a6 = a9.n128_u32[0];
    *a7 = v20;
    if (a8)
    {
      if (v16 >= (float *)v60)
      {
        uint64_t v40 = (float *)__p;
        uint64_t v41 = ((char *)v16 - (unsigned char *)__p) >> 3;
        unint64_t v42 = v41 + 1;
        if ((unint64_t)(v41 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v43 = v60 - (unsigned char *)__p;
        if ((v60 - (unsigned char *)__p) >> 2 > v42) {
          unint64_t v42 = v43 >> 2;
        }
        if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v44 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v44 = v42;
        }
        if (v44)
        {
          __int32 v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)&v60, v44);
          uint64_t v40 = (float *)__p;
          float v16 = v59;
        }
        else
        {
          __int32 v45 = 0;
        }
        unint64_t v46 = (float *)&v45[8 * v41];
        uint64_t v47 = &v45[8 * v44];
        *unint64_t v46 = *a8;
        a9.n128_f32[0] = a8[1];
        v46[1] = a9.n128_f32[0];
        unint64_t v39 = v46 + 2;
        while (v16 != v40)
        {
          int v48 = *((_DWORD *)v16 - 2);
          v16 -= 2;
          *((_DWORD *)v46 - 2) = v48;
          v46 -= 2;
          a9.n128_f32[0] = v16[1];
          v46[1] = a9.n128_f32[0];
        }
        __p = v46;
        uint64_t v59 = v39;
        uint64_t v60 = v47;
        if (v40) {
          operator delete(v40);
        }
      }
      else
      {
        float *v16 = *a8;
        a9.n128_f32[0] = a8[1];
        v16[1] = a9.n128_f32[0];
        unint64_t v39 = v16 + 2;
      }
      uint64_t v59 = v39;
    }
    float v50 = *a4;
    if (v49 <= 0)
    {
      float v51 = a4[1];
    }
    else
    {
      float v51 = a4[1];
      uint64_t v52 = v49;
      uint64_t v53 = (float *)(*a3 + 4);
      do
      {
        float v50 = *(v53 - 1) + v50;
        *a4 = v50;
        float v54 = *v53;
        v53 += 2;
        float v51 = v54 + v51;
        a4[1] = v51;
        --v52;
      }
      while (v52);
    }
    *a4 = v50 / (float)v49;
    a4[1] = v51 / (float)v49;
    if (__p)
    {
      uint64_t v59 = (float *)__p;
      operator delete(__p);
    }
  }
}

void sub_1B7A35B60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t OMKeyer2D::adjustToRestriction(OMKeyer2D *this)
{
  float v2 = (*(float (**)(OMKeyer2D *))(*(void *)this + 32))(this);
  float v3 = (*(float (**)(OMKeyer2D *))(*(void *)this + 40))(this);
  float v4 = (*(float (**)(OMKeyer2D *))(*(void *)this + 48))(this);
  float v5 = (*(float (**)(OMKeyer2D *))(*(void *)this + 56))(this);
  if (v2 >= v3) {
    (*(void (**)(OMKeyer2D *, float))(*(void *)this + 64))(this, v3 + -0.01);
  }
  if (v5 <= v4) {
    (*(void (**)(OMKeyer2D *, float))(*(void *)this + 88))(this, v4 + 0.01);
  }
  float v6 = (OMPie *)(*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 112))(this);
  uint64_t v7 = (OMPie *)(*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 96))(this);

  return OMPie::offsetSegmentIfNeeded(v6, v7, 0.001);
}

void OMKeyer2D::computeModel(OMKeyer2D *this, int a2, float a3, int a4, OMSamples *a5, float a6, float a7, float a8, BOOL a9, int a10)
{
  if (*((unsigned char *)a5 + 8))
  {
    Description = (void *)ProGL::Private::TextureImpl::getDescription(a5);
    Serializer = (void *)OZSceneNode::getSerializer(a5);
    v86[0].i32[0] = 0;
    v85[0].i32[0] = 0;
    v84[0].i32[0] = 0;
    OMKeyer2D::tolAdd(this, Description, Serializer, 1, v86[0].f32, v85[0].f32, v84[0].f32);
    uint64_t v21 = (OMSpline *)(*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 16))(this);
    *((void *)v21 + 1) = *(void *)v21;
    float v22 = (*(float (**)(OMKeyer2D *))(*(void *)this + 40))(this);
    float v23 = (*(float (**)(OMKeyer2D *))(*(void *)this + 48))(this);
    if (a4)
    {
      float v24 = (float)(v85[0].f32[0] - v86[0].f32[0]) * 0.5;
      float v25 = v84[0].f32[0] - v86[0].f32[0];
      if (v85[0].f32[0] <= v86[0].f32[0]) {
        float v26 = (float)(v85[0].f32[0] - v86[0].f32[0]) * 0.5;
      }
      else {
        float v26 = -v24;
      }
      float v80 = a6;
      float v79 = a8;
      if (v85[0].f32[0] <= v86[0].f32[0]) {
        float v27 = -v24;
      }
      else {
        float v27 = (float)(v85[0].f32[0] - v86[0].f32[0]) * 0.5;
      }
      v86[0].f32[0] = v26;
      v85[0].f32[0] = v27;
      float v28 = a3;
      float v29 = a7;
      float v30 = v25 + v26;
      Vec2f v87 = (Vec2f)3212836864;
      OMSpline::addVertexAtEnd(v21, &v87);
      v87.var0[0] = v22;
      v87.var0[1] = v26;
      OMSpline::addVertexAtEnd(v21, &v87);
      v87.var0[0] = (float)(v22 + v23) * 0.5;
      v87.var0[1] = v30;
      a7 = v29;
      a3 = v28;
      OMSpline::addVertexAtEnd(v21, &v87);
      v87.var0[0] = v23;
      v87.var0[1] = v27;
      a8 = v79;
      a6 = v80;
    }
    else
    {
      Vec2f v87 = (Vec2f)3212836864;
      OMSpline::addVertexAtEnd(v21, &v87);
      v87.var0[0] = v22;
      v87.var0[1] = 0.0;
      OMSpline::addVertexAtEnd(v21, &v87);
      v87.var0[0] = (float)(v22 + v23) * 0.5;
      v87.var0[1] = 0.0;
      OMSpline::addVertexAtEnd(v21, &v87);
      v87.var0[0] = v23;
      v87.var0[1] = 0.0;
    }
    OMSpline::addVertexAtEnd(v21, &v87);
    Vec2f v87 = (Vec2f)1065353216;
    OMSpline::addVertexAtEnd(v21, &v87);
    uint64_t v31 = (uint64_t *)(*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 16))(this);
    LODWORD(v32) = -1.0;
    v33.n128_u32[0] = 1.0;
    OMSpline::computeLinearArray(v31, (uint64_t *)this + 9, v32, v33, -1.0, 1.0, 1.0);
    OMKeyer2D::tolAdd(this, Description, Serializer, 0, 0, 0, 0);
  }
  if (a2)
  {
    if (a10) {
      OMKeyer2D::setSoftBasedOnHisto(this, a3);
    }
    else {
      OMKeyer2D::setSoftBasedOnOffsetFromTol(this, a3 * 0.05, a6, a7, a8);
    }
    EdgeSamples = (uint64_t *)OMSamples::getEdgeSamples(a5);
    uint64_t v44 = *EdgeSamples;
    uint64_t v43 = EdgeSamples[1];
    uint64_t v90 = 0;
    int v91 = 0;
    unint64_t v92 = 0;
    uint64_t v45 = v43 - v44;
    if (v45)
    {
      unint64_t v46 = EdgeSamples;
      uint64_t v47 = 0;
      unint64_t v48 = v45 / 88;
      if (v48 <= 1) {
        unint64_t v48 = 1;
      }
      unint64_t v81 = v48;
      do
      {
        uint64_t v49 = *v46;
        uint64_t v50 = *v46 + 88 * v47;
        uint64_t v53 = *(void *)(v50 + 48);
        float v51 = (uint64_t *)(v50 + 48);
        uint64_t v52 = v53;
        float32x2_t v88 = 0;
        int v89 = 0;
        uint64_t v54 = v51[1];
        unint64_t v55 = (v54 - v53) / 12;
        if (v54 != v53)
        {
          if (v55 <= 1) {
            uint64_t v56 = 1;
          }
          else {
            uint64_t v56 = v55;
          }
          uint64_t v57 = (float *)(v52 + 8);
          float32x2_t v58 = 0;
          double v36 = 0.0;
          do
          {
            int32x2_t v59 = *(int32x2_t *)(v57 - 2);
            float32x2_t v58 = vadd_f32(v58, (float32x2_t)v59);
            float v60 = *v57;
            v57 += 3;
            *(float *)&double v36 = *(float *)&v36 + v60;
            float32x2_t v88 = v58;
            int v89 = LODWORD(v36);
            --v56;
          }
          while (v56);
          *(float *)v59.i32 = (float)v55;
          *(float *)&double v36 = *(float *)&v36 / (float)v55;
          float32x2_t v37 = (float32x2_t)vdup_lane_s32(v59, 0);
          float32x2_t v35 = vdiv_f32(v58, v37);
          float32x2_t v88 = v35;
          int v89 = LODWORD(v36);
        }
        int BoundingBox = OMUtil::getBoundingBox(v51, (uint64_t)&v87, 0, &v88, *(double *)&v35, v36, *(double *)&v37, v38, v39, v40, v41, v42);
        if (BoundingBox)
        {
          fprintf((FILE *)*MEMORY[0x1E4F143D8], "OMUtil::getBoundingBox uint64_t result = %d\n", BoundingBox);
        }
        else
        {
          inv((const Mat4f *)&v87, v86);
          uint64_t v62 = v49 + 88 * v47;
          float v63 = *(float *)(v62 + 76);
          if (*(unsigned char *)(v62 + 84)) {
            float v63 = 1.0 - v63;
          }
          if (v63 >= 0.5) {
            float v64 = (float)(v63 * 8.0) + -3.0;
          }
          else {
            float v64 = v63 + v63;
          }
          v82.var0[0] = v64;
          v82.var0[1] = v64;
          v82.var0[2] = v64;
          Mat4f::MakeHScale((Mat4f *)v83, &v82);
          Mat4f::operator*((float *)&v87, v83, v84);
          float32x2_t v35 = (float32x2_t)Mat4f::operator*(v84[0].f32, v86, v85).u64[0];
          if (v54 != v52)
          {
            uint64_t v65 = 0;
            unsigned int v66 = 1;
            do
            {
              uint64_t v67 = *v51 + 12 * v65;
              v83[0].i64[0] = *(void *)v67;
              v83[0].i32[2] = *(_DWORD *)(v67 + 8);
              v83[0].i32[3] = 1065353216;
              operator*(v85[0].f32, v83[0].f32, v84[0].f32);
              proj((float32x2_t *)v84, (float32x2_t *)&v82, v68);
              uint64_t v69 = v91;
              if ((unint64_t)v91 >= v92)
              {
                uint64_t v70 = std::vector<Vec3f>::__push_back_slow_path<Vec3f const&>((uint64_t *)&v90, &v82);
              }
              else
              {
                *int v91 = v82.var0[0];
                v69[1] = v82.var0[1];
                v35.i32[0] = LODWORD(v82.var0[2]);
                v69[2] = v82.var0[2];
                uint64_t v70 = (uint64_t)(v69 + 3);
              }
              int v91 = (float *)v70;
              uint64_t v65 = v66;
            }
            while (v55 > v66++);
          }
        }
        ++v47;
      }
      while (v47 != v81);
    }
    OMKeyer2D::adjustSoft((uint64_t)this, (uint64_t *)&v90);
    if (v90)
    {
      int v91 = v90;
      operator delete(v90);
    }
  }
  else if (OMKeyer2D::adjustToRestriction(this))
  {
    OMKeyer2D::setSoftBasedOnOffsetFromTol(this, a3 * 0.05, a6, a7, a8);
  }
  v72 = (OMSpline *)(*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 16))(this);
  float32x2_t v73 = v72;
  unint64_t v74 = *((void *)v72 + 1) - *(void *)v72;
  if ((int)(v74 >> 5) < 1)
  {
LABEL_49:
    float v77 = (*(float (**)(OMKeyer2D *))(*(void *)this + 40))(this);
    float v78 = (*(float (**)(OMKeyer2D *))(*(void *)this + 48))(this);
    *((void *)v73 + 1) = *(void *)v73;
    Vec2f v87 = (Vec2f)3212836864;
    OMSpline::addVertexAtEnd(v73, &v87);
    v87.var0[0] = v77;
    v87.var0[1] = 0.0;
    OMSpline::addVertexAtEnd(v73, &v87);
    v87.var0[0] = (float)(v77 + v78) * 0.5;
    v87.var0[1] = 0.0;
    OMSpline::addVertexAtEnd(v73, &v87);
    v87.var0[0] = v78;
    v87.var0[1] = 0.0;
    OMSpline::addVertexAtEnd(v73, &v87);
    Vec2f v87 = (Vec2f)1065353216;
    OMSpline::addVertexAtEnd(v73, &v87);
  }
  else
  {
    uint64_t v75 = (v74 >> 5);
    int v76 = (float *)(*(void *)v72 + 28);
    while (*v76 == 0.0)
    {
      v76 += 8;
      if (!--v75) {
        goto LABEL_49;
      }
    }
  }
}

void sub_1B7A36444(_Unwind_Exception *exception_object)
{
  float v3 = *(void **)(v1 + 80);
  if (v3)
  {
    *(void *)(v1 + 88) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void OMKeyer2D::adjustSoft(uint64_t a1, uint64_t *a2)
{
  if (*a2 != a2[1])
  {
    float v4 = (OMPie *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1);
    float v5 = (float32x2_t *)*((void *)v4 + 5);
    OMPie::computeArc(v4, v6, v7);
    OMPie::getArcOut((float32x2_t **)v4, 0.5, &v37);
    float32x2_t v9 = v5[1];
    float32x2_t v8 = (float *)&v5[1];
    v10.n128_u64[0] = (unint64_t)vmul_f32(vadd_f32(v9, v37), (float32x2_t)0x3F0000003F000000);
    unint64_t v36 = v10.n128_u64[0];
    __n128 v33 = 0;
    unint64_t v34 = 0;
    uint64_t v35 = 0;
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    float v30 = 0.0;
    OMKeyer2D::computeCH(a1, a2, &v33, (float *)&v32, (float *)&v31 + 1, &v31, &v30, (float *)&v36, v10);
    float v11 = (OMPie *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 112))(a1);
    float v12 = v11;
    float v13 = (Vec2f *)*((void *)v11 + 5);
    if (sqrtf((float)(v13->var0[0] * v13->var0[0]) + (float)(v13->var0[1] * v13->var0[1])) < v30
      || sqrtf((float)(v13[2].var0[0] * v13[2].var0[0]) + (float)(v13[2].var0[1] * v13[2].var0[1])) < v30)
    {
      __p = 0;
      float v28 = 0;
      uint64_t v29 = 0;
      v26.var0[0] = v30;
      v26.var0[1] = 0.0;
      int v25 = 11;
      OMPie::move(v11, &v25, &v26, (float32x2_t *)&v26);
      if (__p)
      {
        float v28 = __p;
        operator delete(__p);
      }
    }
    float v14 = *(float *)&v31;
    if (v14 < (*(float (**)(uint64_t))(*(void *)a1 + 32))(a1)) {
      (*(void (**)(uint64_t, float))(*(void *)a1 + 64))(a1, v14);
    }
    float v15 = *((float *)&v31 + 1);
    if (v15 > (*(float (**)(uint64_t))(*(void *)a1 + 56))(a1)) {
      int v16 = (*(uint64_t (**)(uint64_t, float))(*(void *)a1 + 88))(a1, v15);
    }
    __p = 0;
    float v28 = 0;
    unsigned int v17 = 125;
    uint64_t v29 = 0;
    do
    {
      if (__p != v28) {
        break;
      }
      OMKeyer2D::computeCostPie(v16, (uint64_t *)&__p, v8, (float *)&v37, (float *)&v13[1], v13, v13 + 2, v4, v12, &v33, v17 + 25);
      v17 += 25;
    }
    while (v17 <= 0x145);
    OMKeyer2D::computeCostPieAsQuad(v16, (uint64_t *)&__p, (uint64_t)v4, v12, &v33);
    float v18 = __p;
    if (v28 == __p)
    {
      if (!__p) {
        goto LABEL_21;
      }
    }
    else
    {
      unint64_t v19 = 0x2E8BA2E8BA2E8BA3 * ((v28 - (unsigned char *)__p) >> 2);
      float v20 = (float *)((char *)__p + 20);
      unsigned int v21 = 1;
      float v22 = 10000.0;
      do
      {
        float v23 = *(v20 - 5);
        if (v23 < v22)
        {
          v13[1].var0[0] = *(v20 - 4);
          v13[1].var0[1] = *(v20 - 3);
          v13->var0[0] = *(v20 - 2);
          v13->var0[1] = *(v20 - 1);
          v13[2].var0[0] = *v20;
          v13[2].var0[1] = v20[1];
          v13[3].var0[0] = v20[2];
          v13[3].var0[1] = v20[3];
          v13[4].var0[0] = v20[4];
          v13[4].var0[1] = v20[5];
          float v22 = v23;
        }
        BOOL v24 = v19 > v21++;
        v20 += 11;
      }
      while (v24);
    }
    float v28 = v18;
    operator delete(v18);
LABEL_21:
    if (v33)
    {
      unint64_t v34 = v33;
      operator delete(v33);
    }
  }
}

void sub_1B7A367F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  if (a20) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

float32x2_t OMKeyer2D::getTolCenterCbCr@<D0>(OMKeyer2D *this@<X0>, float32x2_t *a2@<X8>)
{
  float v3 = (OMPie *)(*(uint64_t (**)(OMKeyer2D *))(*(void *)this + 96))(this);
  OMPie::computeArc(v3, v4, v5);
  OMPie::getArcIn(v3, 0.5, (float *)&v8);
  OMPie::getArcOut((float32x2_t **)v3, 0.5, &v7);
  float32x2_t result = vmul_f32(vadd_f32(v8, v7), (float32x2_t)0x3F0000003F000000);
  *a2 = result;
  return result;
}

void OMKeyer2D::getSpillSuppressTransf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, float a8, float a9, float a10, float a11, float a12)
{
  float v23 = (OMPie *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1);
  OMPie::computeArc(v23, v24, v25);
  OMPie::getArcIn(v23, 0.5, (float *)&v28);
  OMPie::getArcOut((float32x2_t **)v23, 0.5, &v27);
  float32x2_t v29 = vmul_f32(vadd_f32(v28, v27), (float32x2_t)0x3F0000003F000000);
  OMKeyer2D::getSpillSuppressTransf((float *)&v29, a2, a3, a4, a5, a6, a7, v26, a8, a9, a10, a11, a12);
}

void OMKeyer2D::getSpillSuppressTransf(float *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9, float a10, float a11, float a12, float a13)
{
  float v20 = *a1;
  float v21 = a1[1];
  if (a7)
  {
    OMColorUtil::getRec2020to709Matrix(a2, a3, a4, a5, a6, a7, a8, (Mat4f *)v76);
    {
      OMColorUtil::getRGBToYCbCrMatrix(0, v35, v36, v37, v38, v39, v40, v41, (Mat4f *)v75);
      Mat4f::operator*(v75[0].f32, v76, OMKeyer2D::getSpillSuppressTransf(Vec2f const&,float,Vec3f const&,float,float,float,Mat4f &,Mat4f &,Mat4f &,float,OMColorPrimaries,BOOL)::matrixTunedForRec2020);
    }
    {
      inv((const Mat4f *)OMKeyer2D::getSpillSuppressTransf(Vec2f const&,float,Vec3f const&,float,float,float,Mat4f &,Mat4f &,Mat4f &,float,OMColorPrimaries,BOOL)::matrixTunedForRec2020, OMKeyer2D::getSpillSuppressTransf(Vec2f const&,float,Vec3f const&,float,float,float,Mat4f &,Mat4f &,Mat4f &,float,OMColorPrimaries,BOOL)::inversematrixTunedForRec2020);
    }
    Mat4f::operator=((uint64_t)v78, (uint64_t)OMKeyer2D::getSpillSuppressTransf(Vec2f const&,float,Vec3f const&,float,float,float,Mat4f &,Mat4f &,Mat4f &,float,OMColorPrimaries,BOOL)::matrixTunedForRec2020);
    float v22 = OMKeyer2D::getSpillSuppressTransf(Vec2f const&,float,Vec3f const&,float,float,float,Mat4f &,Mat4f &,Mat4f &,float,OMColorPrimaries,BOOL)::inversematrixTunedForRec2020;
  }
  else
  {
    {
      int v42 = a6;
      {
        OMColorUtil::getRGBToYCbCrMatrix(v42, v43, v44, v45, v46, v47, v48, v49, (Mat4f *)&OMKeyer2D::getSpillSuppressTransf(Vec2f const&,float,Vec3f const&,float,float,float,Mat4f &,Mat4f &,Mat4f &,float,OMColorPrimaries,BOOL)::matrixNormal);
      }
    }
    {
      inv((const Mat4f *)&OMKeyer2D::getSpillSuppressTransf(Vec2f const&,float,Vec3f const&,float,float,float,Mat4f &,Mat4f &,Mat4f &,float,OMColorPrimaries,BOOL)::matrixNormal, OMKeyer2D::getSpillSuppressTransf(Vec2f const&,float,Vec3f const&,float,float,float,Mat4f &,Mat4f &,Mat4f &,float,OMColorPrimaries,BOOL)::inverseMatrixNormal);
    }
    Mat4f::operator=((uint64_t)v78, (uint64_t)&OMKeyer2D::getSpillSuppressTransf(Vec2f const&,float,Vec3f const&,float,float,float,Mat4f &,Mat4f &,Mat4f &,float,OMColorPrimaries,BOOL)::matrixNormal);
    float v22 = OMKeyer2D::getSpillSuppressTransf(Vec2f const&,float,Vec3f const&,float,float,float,Mat4f &,Mat4f &,Mat4f &,float,OMColorPrimaries,BOOL)::inverseMatrixNormal;
  }
  Mat4f::operator=((uint64_t)v77, (uint64_t)v22);
  float v23 = sqrtf((float)(v20 * v20) + (float)(v21 * v21));
  float v24 = atan2f(v21, v20);
  if (v24 >= 0.0) {
    float v25 = v24;
  }
  else {
    float v25 = v24 + 6.2832;
  }
  float v26 = v23 * 0.4;
  float v27 = (float)(a9 / (float)(v26 + a9)) + a12;
  v75[0].i64[0] = *(void *)a2;
  v75[0].i32[2] = *(_DWORD *)(a2 + 8);
  v75[0].i32[3] = 1065353216;
  operator*(v78[0].f32, v75[0].f32, v76[0].f32);
  proj((float32x2_t *)v76, (float32x2_t *)&v73, v28);
  *(void *)v65.var0 = 1065353216;
  v65.var0[2] = 0.0;
  double v29 = (float)(v25 + 1.5708);
  double v30 = (float)(-1.5708 - v25);
  float v31 = (v73 + -0.5) * 0.4;
  float32x2_t v50 = vadd_f32(v74, v74);
  Mat4f::MakeHRot((Mat4f *)v66, &v65, v29);
  Mat4f::operator*(v77, v66, v67);
  *(void *)v63.var0 = 0;
  v63.var0[2] = a9;
  Mat4f::MakeHTrans((Mat4f *)v64, &v63);
  Mat4f::operator*(v67[0].f32, v64, v68);
  v61.var0[0] = 1.0;
  v61.var0[1] = a13;
  v61.var0[2] = v27;
  Mat4f::MakeHScale((Mat4f *)v62, &v61);
  Mat4f::operator*(v68[0].f32, v62, v69);
  *(void *)v59.var0 = 0;
  v59.var0[2] = -a9;
  Mat4f::MakeHTrans((Mat4f *)v60, &v59);
  Mat4f::operator*(v69[0].f32, v60, v70);
  *(void *)v57.var0 = 1065353216;
  v57.var0[2] = 0.0;
  Mat4f::MakeHRot((Mat4f *)v58, &v57, v30);
  Mat4f::operator*(v70[0].f32, v58, v71);
  v55.var0[0] = v31;
  *(float32x2_t *)&v55.var0[1] = v50;
  Mat4f::MakeHTrans((Mat4f *)v56, &v55);
  Mat4f::operator*(v71[0].f32, v56, v72);
  OMColorUtil::Level4f(v32, a10, a11, v54);
  Mat4f::operator*(v72[0].f32, v54, v75);
  Mat4f::operator*(v75[0].f32, v78, v76);
  Mat4f::operator=(a4, (uint64_t)v76);
  *(void *)v65.var0 = 1065353216;
  v65.var0[2] = 0.0;
  Mat4f::MakeHRot((Mat4f *)v66, &v65, v29);
  Mat4f::operator*(v77, v66, v67);
  *(void *)v63.var0 = 0;
  v63.var0[2] = a9;
  Mat4f::MakeHTrans((Mat4f *)v64, &v63);
  Mat4f::operator*(v67[0].f32, v64, v68);
  float v33 = sqrtf((float)(*a1 * *a1) + (float)(a1[1] * a1[1])) * 0.5;
  *(void *)v61.var0 = 0;
  v61.var0[2] = v33;
  Mat4f::MakeHTrans((Mat4f *)v62, &v61);
  Mat4f::operator*(v68[0].f32, v62, v69);
  *(void *)v59.var0 = 0;
  v59.var0[2] = -a9;
  Mat4f::MakeHTrans((Mat4f *)v60, &v59);
  Mat4f::operator*(v69[0].f32, v60, v70);
  *(void *)v57.var0 = 1065353216;
  v57.var0[2] = 0.0;
  Mat4f::MakeHRot((Mat4f *)v58, &v57, v30);
  Mat4f::operator*(v70[0].f32, v58, v71);
  v55.var0[0] = v31;
  *(float32x2_t *)&v55.var0[1] = v50;
  Mat4f::MakeHTrans((Mat4f *)v56, &v55);
  Mat4f::operator*(v71[0].f32, v56, v72);
  OMColorUtil::Level4f(v34, a10, a11, v54);
  Mat4f::operator*(v72[0].f32, v54, v75);
  Mat4f::operator*(v75[0].f32, v78, v76);
  Mat4f::operator=(a5, (uint64_t)v76);
  v70[0].i64[0] = 0;
  v70[0].f32[2] = -a9;
  Mat4f::MakeHTrans((Mat4f *)v72, (const Vec3f *)v70);
  v69[0].i64[0] = 1065353216;
  v69[0].i32[2] = 0;
  Mat4f::MakeHRot((Mat4f *)v71, (const Vec3f *)v69, v30);
  Mat4f::operator*(v72[0].f32, v71, v75);
  Mat4f::operator*(v75[0].f32, v78, v76);
  Mat4f::operator=(a3, (uint64_t)v76);
}

void sub_1B7A36F70(_Unwind_Exception *a1)
{
}

void OMKeyer2D::computeCostPie(int a1, uint64_t *a2, float *a3, float *a4, float *a5, Vec2f *a6, Vec2f *a7, OMPie *this, OMPie *a9, void *a10, int a11)
{
  float v18 = 0.0;
  do
  {
    float v19 = *a3 - *a4;
    float v20 = a3[1] - a4[1];
    float v21 = sqrtf((float)(v19 * v19) + (float)(v20 * v20));
    float v22 = v18 * (float)(v19 / v21);
    float v23 = v18 * (float)(v20 / v21);
    *(float *)uint64_t v43 = v22;
    *((float *)v43 + 1) = v23;
    if ((OMPie::isQuadActive(this)
       || sqrtf((float)(*a5 * *a5) + (float)(a5[1] * a5[1])) > sqrtf((float)(*a3 * *a3) + (float)(a3[1] * a3[1])))
      && (OMPie::isQuadActive(a9)
       || sqrtf((float)(v22 * v22) + (float)(v23 * v23)) > sqrtf((float)(*a5 * *a5) + (float)(a5[1] * a5[1]))))
    {
      Vec2f v42 = *a6;
      {
        Vec2f v41 = *a7;
        {
          OMPie::OMPie((OMPie *)v38, 1);
          float v24 = (Vec2f *)__p;
          *((float *)__p + 2) = v22;
          v24[1].var0[1] = v23;
          Vec2f *v24 = v42;
          v24[2] = v41;
          v24[3].var0[0] = v22;
          v24[3].var0[1] = v23;
          v24[4].var0[0] = v22;
          v24[4].var0[1] = v23;
          OMPie::getArea((OMPie *)v38);
          float v26 = v18 + v18 + v25;
          *(Vec2f *)&long long v27 = v42;
          float v30 = v26;
          float v31 = v22;
          float v32 = v23;
          *((Vec2f *)&v27 + 1) = v41;
          long long v33 = v27;
          float v34 = v22;
          float v35 = v23;
          float v36 = v22;
          float v37 = v23;
          unint64_t v28 = a2[1];
          if (v28 >= a2[2])
          {
            uint64_t v29 = std::vector<OMCostPie>::__push_back_slow_path<OMCostPie>(a2, &v30);
          }
          else
          {
            *(float *)unint64_t v28 = v26;
            *(float *)(v28 + 4) = v31;
            *(float *)(v28 + 8) = v32;
            *(_OWORD *)(v28 + 12) = v33;
            *(float *)(v28 + 28) = v34;
            *(float *)(v28 + 32) = v35;
            *(float *)(v28 + 36) = v36;
            *(float *)(v28 + 40) = v37;
            uint64_t v29 = v28 + 44;
            a2[1] = v28 + 44;
          }
          a2[1] = v29;
          if (__p)
          {
            uint64_t v40 = __p;
            operator delete(__p);
          }
        }
      }
    }
    float v18 = v18 + 0.01;
  }
  while (v18 < 2.0);
}

void sub_1B7A3725C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void OMKeyer2D::computeCostPieAsQuad(int a1, uint64_t *a2, uint64_t a3, OMPie *this, void *a5)
{
  if (!OMPie::isQuadActive(this)) {
    return;
  }
  float32x2_t v9 = (_DWORD *)*((void *)this + 5);
  float v11 = (char **)(a5 + 2);
  __n128 v10 = (char *)a5[2];
  float v12 = (char *)a5[1];
  if (v12 >= v10)
  {
    float v14 = (char *)*a5;
    uint64_t v15 = (uint64_t)&v12[-*a5] >> 3;
    unint64_t v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 61) {
      goto LABEL_123;
    }
    uint64_t v17 = v10 - v14;
    if (v17 >> 2 > v16) {
      unint64_t v16 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v16;
    }
    if (v18)
    {
      float v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a5 + 2), v18);
      float v14 = (char *)*a5;
      float v12 = (char *)a5[1];
    }
    else
    {
      float v19 = 0;
    }
    float v20 = &v19[8 * v15];
    __n128 v10 = &v19[8 * v18];
    *(_DWORD *)float v20 = *v9;
    *((_DWORD *)v20 + 1) = v9[1];
    float v13 = v20 + 8;
    while (v12 != v14)
    {
      int v21 = *((_DWORD *)v12 - 2);
      v12 -= 8;
      *((_DWORD *)v20 - 2) = v21;
      v20 -= 8;
      *((_DWORD *)v20 + 1) = *((_DWORD *)v12 + 1);
    }
    *a5 = v20;
    a5[1] = v13;
    a5[2] = v10;
    if (v14)
    {
      operator delete(v14);
      __n128 v10 = *v11;
    }
  }
  else
  {
    *(_DWORD *)float v12 = *v9;
    *((_DWORD *)v12 + 1) = v9[1];
    float v13 = v12 + 8;
  }
  a5[1] = v13;
  uint64_t v22 = *((void *)this + 5);
  if (v13 >= v10)
  {
    float v24 = (char *)*a5;
    uint64_t v25 = (uint64_t)&v13[-*a5] >> 3;
    unint64_t v26 = v25 + 1;
    if ((unint64_t)(v25 + 1) >> 61) {
      goto LABEL_123;
    }
    uint64_t v27 = v10 - v24;
    if (v27 >> 2 > v26) {
      unint64_t v26 = v27 >> 2;
    }
    if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v28 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v28 = v26;
    }
    if (v28)
    {
      uint64_t v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a5 + 2), v28);
      float v24 = (char *)*a5;
      float v13 = (char *)a5[1];
    }
    else
    {
      uint64_t v29 = 0;
    }
    float v30 = &v29[8 * v25];
    __n128 v10 = &v29[8 * v28];
    *(_DWORD *)float v30 = *(_DWORD *)(v22 + 16);
    *((_DWORD *)v30 + 1) = *(_DWORD *)(v22 + 20);
    float v23 = v30 + 8;
    while (v13 != v24)
    {
      int v31 = *((_DWORD *)v13 - 2);
      v13 -= 8;
      *((_DWORD *)v30 - 2) = v31;
      v30 -= 8;
      *((_DWORD *)v30 + 1) = *((_DWORD *)v13 + 1);
    }
    *a5 = v30;
    a5[1] = v23;
    a5[2] = v10;
    if (v24)
    {
      operator delete(v24);
      __n128 v10 = *v11;
    }
  }
  else
  {
    *(_DWORD *)float v13 = *(_DWORD *)(v22 + 16);
    *((_DWORD *)v13 + 1) = *(_DWORD *)(v22 + 20);
    float v23 = v13 + 8;
  }
  a5[1] = v23;
  uint64_t v32 = *((void *)this + 5);
  if (v23 >= v10)
  {
    float v34 = (char *)*a5;
    uint64_t v35 = (uint64_t)&v23[-*a5] >> 3;
    unint64_t v36 = v35 + 1;
    if ((unint64_t)(v35 + 1) >> 61) {
      goto LABEL_123;
    }
    uint64_t v37 = v10 - v34;
    if (v37 >> 2 > v36) {
      unint64_t v36 = v37 >> 2;
    }
    if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v38 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v38 = v36;
    }
    if (v38)
    {
      uint64_t v39 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a5 + 2), v38);
      float v34 = (char *)*a5;
      float v23 = (char *)a5[1];
    }
    else
    {
      uint64_t v39 = 0;
    }
    uint64_t v40 = &v39[8 * v35];
    __n128 v10 = &v39[8 * v38];
    *(_DWORD *)uint64_t v40 = *(_DWORD *)(v32 + 24);
    *((_DWORD *)v40 + 1) = *(_DWORD *)(v32 + 28);
    long long v33 = v40 + 8;
    while (v23 != v34)
    {
      int v41 = *((_DWORD *)v23 - 2);
      v23 -= 8;
      *((_DWORD *)v40 - 2) = v41;
      v40 -= 8;
      *((_DWORD *)v40 + 1) = *((_DWORD *)v23 + 1);
    }
    *a5 = v40;
    a5[1] = v33;
    a5[2] = v10;
    if (v34)
    {
      operator delete(v34);
      __n128 v10 = *v11;
    }
  }
  else
  {
    *(_DWORD *)float v23 = *(_DWORD *)(v32 + 24);
    *((_DWORD *)v23 + 1) = *(_DWORD *)(v32 + 28);
    long long v33 = v23 + 8;
  }
  a5[1] = v33;
  uint64_t v42 = *((void *)this + 5);
  if (v33 >= v10)
  {
    uint64_t v44 = (char *)*a5;
    uint64_t v45 = (uint64_t)&v33[-*a5] >> 3;
    unint64_t v46 = v45 + 1;
    if (!((unint64_t)(v45 + 1) >> 61))
    {
      uint64_t v47 = v10 - v44;
      if (v47 >> 2 > v46) {
        unint64_t v46 = v47 >> 2;
      }
      if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v48 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v48 = v46;
      }
      if (v48)
      {
        uint64_t v49 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a5 + 2), v48);
        uint64_t v44 = (char *)*a5;
        long long v33 = (char *)a5[1];
      }
      else
      {
        uint64_t v49 = 0;
      }
      float32x2_t v50 = &v49[8 * v45];
      float v51 = &v49[8 * v48];
      *(_DWORD *)float32x2_t v50 = *(_DWORD *)(v42 + 32);
      *((_DWORD *)v50 + 1) = *(_DWORD *)(v42 + 36);
      uint64_t v43 = v50 + 8;
      while (v33 != v44)
      {
        int v52 = *((_DWORD *)v33 - 2);
        v33 -= 8;
        *((_DWORD *)v50 - 2) = v52;
        v50 -= 8;
        *((_DWORD *)v50 + 1) = *((_DWORD *)v33 + 1);
      }
      *a5 = v50;
      a5[1] = v43;
      a5[2] = v51;
      if (v44) {
        operator delete(v44);
      }
      goto LABEL_66;
    }
LABEL_123:
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  *(_DWORD *)long long v33 = *(_DWORD *)(v42 + 32);
  *((_DWORD *)v33 + 1) = *(_DWORD *)(v42 + 36);
  uint64_t v43 = v33 + 8;
LABEL_66:
  a5[1] = v43;
  __x[0] = 0;
  std::vector<int>::vector(&v138, 0x168uLL, __x);
  unint64_t v53 = a5[1] - *a5;
  if ((int)(v53 >> 3) < 1)
  {
    float v58 = 1000.0;
    float v57 = -1000.0;
  }
  else
  {
    std::vector<int>::pointer begin = v138.__begin_;
    uint64_t v55 = (v53 >> 3);
    uint64_t v56 = (float *)(*a5 + 4);
    float v57 = -1000.0;
    float v58 = 1000.0;
    do
    {
      float v59 = *(v56 - 1);
      float v60 = sqrtf((float)(v59 * v59) + (float)(*v56 * *v56));
      float v61 = atan2f(*v56, v59);
      if (v61 < 0.0) {
        float v61 = v61 + 6.2832;
      }
      begin[(float)((float)(v61 / 6.2832) * 360.0)] = 1;
      if (v60 > v57) {
        float v57 = v60;
      }
      if (v60 < v58) {
        float v58 = v60;
      }
      v56 += 2;
      --v55;
    }
    while (v55);
  }
  __x[0] = -1;
  std::vector<int>::vector(&v137, 0x168uLL, __x);
  __x[0] = -1;
  std::vector<int>::vector(&v136, 0x168uLL, __x);
  uint64_t v62 = 0;
  int v63 = 0;
  std::vector<int>::pointer v64 = v137.__begin_;
  int v65 = 10000;
  std::vector<int>::pointer v66 = v136.__begin_;
  do
  {
    std::vector<int>::pointer v67 = v138.__begin_;
    std::vector<int>::pointer v68 = v136.__begin_;
    int v69 = 360;
    unsigned int v70 = v62;
    do
    {
      unsigned int v71 = v70 - 360;
      if (v70 <= 0x167) {
        unsigned int v71 = v70;
      }
      int v72 = v67[v71];
      if (v64[v62] < 0)
      {
        if (!v72) {
          goto LABEL_87;
        }
        v64[v62] = v71;
LABEL_86:
        v68[v62] = v71;
        goto LABEL_87;
      }
      if (v72) {
        goto LABEL_86;
      }
LABEL_87:
      ++v70;
      --v69;
    }
    while (v69);
    int v73 = v66[v62];
    int v74 = v64[v62];
    if (v73 <= v74) {
      v73 += 360;
    }
    int v75 = v73 - v74;
    if (v75 < v65)
    {
      int v65 = v75;
      int v63 = v62;
    }
    ++v62;
  }
  while (v62 != 360);
  BOOL v76 = v58 >= 0.1 || v65 <= 90;
  float v77 = v136.__begin_;
  if (v76 && v58 >= 0.01)
  {
    float v78 = ((double)v136.__begin_[v63] + 1.0) / 360.0;
    float v79 = (float)v64[v63] / 360.0;
    float v80 = (float)(v79 + v79) * 3.14159265;
    __float2 v81 = __sincosf_stret(v80);
    float v82 = (float)(v78 + v78) * 3.14159265;
    __float2 v83 = __sincosf_stret(v82);
    OMPie::OMPie((OMPie *)__x, 1);
    float v84 = v57 * v81.__cosval;
    float v85 = v57 * v81.__sinval;
    float v86 = v57 * v83.__cosval;
    float v87 = v57 * v83.__sinval;
    float v88 = v86;
    int v89 = (float *)__p;
    *((void *)__p + 1) = 0;
    *int v89 = v84;
    v89[1] = v85;
    v89[4] = v86;
    v89[5] = v87;
    float v120 = v58 * v81.__sinval;
    float v121 = v58 * v81.__cosval;
    v89[6] = v58 * v81.__cosval;
    v89[7] = v58 * v81.__sinval;
    v89[8] = v58 * v83.__cosval;
    v89[9] = v58 * v83.__sinval;
    float v90 = sqrtf((float)(v84 * v84) + (float)(v85 * v85));
    float v122 = v84 / v90;
    *(float *)&uint64_t v123 = v85 / v90;
    int v91 = *(float **)(a3 + 40);
    float v92 = v91[1];
    float v93 = sqrtf((float)(*v91 * *v91) + (float)(v92 * v92));
    v132.var0[0] = *v91 / v93;
    v132.var0[1] = v92 / v93;
    float v96 = OMUtil::angle((OMUtil *)&v122, &v132, v94);
    float v116 = v58 * v83.__sinval;
    float v117 = v58 * v83.__cosval;
    if ((float)((float)(v122 * v132.var0[1]) - (float)(*(float *)&v123 * v132.var0[0])) < 0.0) {
      float v96 = 6.2832 - v96;
    }
    float v115 = v96;
    uint64_t v97 = *(void *)(a3 + 40);
    float v98 = *(float *)(v97 + 16);
    float v99 = *(float *)(v97 + 20);
    float v100 = sqrtf((float)(v98 * v98) + (float)(v99 * v99));
    float v122 = v98 / v100;
    *(float *)&uint64_t v123 = v99 / v100;
    float v101 = sqrtf((float)(v88 * v88) + (float)(v87 * v87));
    float v118 = v87;
    float v119 = v88;
    v132.var0[0] = v88 / v101;
    v132.var0[1] = v87 / v101;
    float v102 = OMUtil::angle((OMUtil *)&v122, &v132, v95);
    float v103 = v122;
    float v104 = *(float *)&v123;
    float v105 = v132.var0[0];
    float v106 = v132.var0[1];
    OMPie::getArea((OMPie *)__x);
    if ((float)((float)(v103 * v106) - (float)(v104 * v105)) >= 0.0) {
      float v108 = v102;
    }
    else {
      float v108 = 6.2832 - v102;
    }
    if (v115 <= 1.4) {
      float v109 = 0.0;
    }
    else {
      float v109 = 1000.0;
    }
    float v110 = v109 + v107;
    if (v108 <= 1.4) {
      float v111 = 0.0;
    }
    else {
      float v111 = 1000.0;
    }
    float v112 = v110 + v111;
    float v122 = v112;
    uint64_t v123 = 0;
    float v124 = v84;
    float v125 = v85;
    float v126 = v119;
    float v127 = v118;
    float v128 = v121;
    float v129 = v120;
    float v130 = v117;
    float v131 = v116;
    unint64_t v113 = a2[1];
    if (v113 >= a2[2])
    {
      uint64_t v114 = std::vector<OMCostPie>::__push_back_slow_path<OMCostPie>(a2, &v122);
    }
    else
    {
      *(float *)unint64_t v113 = v112;
      *(_DWORD *)(v113 + 4) = 0;
      *(_DWORD *)(v113 + 8) = 0;
      *(float *)(v113 + 12) = v84;
      *(float *)(v113 + 16) = v85;
      *(float *)(v113 + 20) = v119;
      *(float *)(v113 + 24) = v118;
      *(float *)(v113 + 28) = v121;
      *(float *)(v113 + 32) = v120;
      *(float *)(v113 + 36) = v117;
      *(float *)(v113 + 40) = v116;
      uint64_t v114 = v113 + 44;
      a2[1] = v113 + 44;
    }
    a2[1] = v114;
    if (__p)
    {
      v135 = __p;
      operator delete(__p);
    }
    float v77 = v136.__begin_;
  }
  if (v77)
  {
    v136.__end_ = v77;
    operator delete(v77);
  }
  if (v137.__begin_)
  {
    v137.__end_ = v137.__begin_;
    operator delete(v137.__begin_);
  }
  if (v138.__begin_)
  {
    v138.__end_ = v138.__begin_;
    operator delete(v138.__begin_);
  }
}

void sub_1B7A37A64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,uint64_t a27,void *a28,uint64_t a29)
{
  if (__p) {
    operator delete(__p);
  }
  if (a28) {
    operator delete(a28);
  }
  int v31 = *(void **)v29;
  if (*(void *)v29)
  {
    *(void *)(v29 + 8) = v31;
    operator delete(v31);
  }
  uint64_t v32 = *(void **)(v29 + 24);
  if (v32)
  {
    *(void *)(v29 + 32) = v32;
    operator delete(v32);
  }
  _Unwind_Resume(exception_object);
}

BOOL anonymous namespace'::isVec2fLessThan(_anonymous_namespace_ *this, const Vec2f *a2, const Vec2f *a3)
{
  if (*(float *)this == a2->var0[0]) {
    return *((float *)this + 1) < a2->var0[1];
  }
  else {
    return *(float *)this < a2->var0[0];
  }
}

char *std::vector<Vec2f>::erase(uint64_t a1, char *a2, char *a3)
{
  if (a2 != a3)
  {
    float v3 = *(char **)(a1 + 8);
    uint64_t v4 = a2;
    if (a3 != v3)
    {
      uint64_t v5 = 8 * ((a3 - a2) >> 3);
      uint64_t v4 = a2;
      do
      {
        int v6 = *(_DWORD *)&v4[v5 + 4];
        *(_DWORD *)uint64_t v4 = *(_DWORD *)&v4[v5];
        *((_DWORD *)v4 + 1) = v6;
        v4 += 8;
      }
      while (&v4[v5] != v3);
    }
    *(void *)(a1 + 8) = v4;
  }
  return a2;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*,false>(unint64_t a1, char *a2, uint64_t (**a3)(uint64_t *, uint64_t *), uint64_t a4, char a5, __n128 a6)
{
uint64_t std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>(uint64_t result, void *a2, uint64_t (**a3)(void *, void))
{
  if ((void *)result != a2)
  {
    v17[7] = v3;
    v17[8] = v4;
    char v6 = (_DWORD *)result;
    char v7 = (void *)(result + 8);
    if ((void *)(result + 8) != a2)
    {
      uint64_t v9 = 0;
      __n128 v10 = (void *)result;
      do
      {
        float v11 = v10;
        __n128 v10 = v7;
        float32x2_t result = (*a3)(v7, v11);
        if (result)
        {
          v17[0] = *v10;
          uint64_t v12 = v9;
          while (1)
          {
            uint64_t v13 = (char *)v6 + v12;
            int v14 = *(_DWORD *)((char *)v6 + v12 + 4);
            *((_DWORD *)v13 + 2) = *(_DWORD *)((char *)v6 + v12);
            *((_DWORD *)v13 + 3) = v14;
            if (!v12) {
              break;
            }
            v12 -= 8;
            float32x2_t result = (*a3)(v17, (char *)v6 + v12);
            if ((result & 1) == 0)
            {
              uint64_t v15 = (_DWORD *)((char *)v6 + v12 + 8);
              goto LABEL_10;
            }
          }
          uint64_t v15 = v6;
LABEL_10:
          int v16 = HIDWORD(v17[0]);
          _DWORD *v15 = v17[0];
          v15[1] = v16;
        }
        char v7 = v10 + 1;
        v9 += 8;
      }
      while (v10 + 1 != a2);
    }
  }
  return result;
}

uint64_t std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>(uint64_t result, void *a2, uint64_t (**a3)(void *, _DWORD *))
{
  if ((void *)result != a2)
  {
    v14[7] = v3;
    v14[8] = v4;
    char v6 = (void *)result;
    char v7 = (void *)(result + 8);
    if ((void *)(result + 8) != a2)
    {
      uint64_t v9 = (_DWORD *)(result - 8);
      do
      {
        __n128 v10 = v6;
        char v6 = v7;
        float32x2_t result = (*a3)(v7, v10);
        if (result)
        {
          v14[0] = *v6;
          float v11 = v9;
          do
          {
            int v12 = v11[3];
            v11[4] = v11[2];
            v11[5] = v12;
            float32x2_t result = (*a3)(v14, v11);
            v11 -= 2;
          }
          while ((result & 1) != 0);
          int v13 = HIDWORD(v14[0]);
          v11[4] = v14[0];
          v11[5] = v13;
        }
        char v7 = v6 + 1;
        v9 += 2;
      }
      while (v6 + 1 != a2);
    }
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t (**a4)(uint64_t *, uint64_t *))
{
  char v8 = (*a4)(a2, a1);
  uint64_t result = (*a4)(a3, a2);
  if ((v8 & 1) == 0)
  {
    if (!result) {
      return result;
    }
    uint64_t v12 = *a2;
    *(_DWORD *)a2 = *(_DWORD *)a3;
    *((_DWORD *)a2 + 1) = *((_DWORD *)a3 + 1);
    *a3 = v12;
    if (!(*a4)(a2, a1)) {
      return 1;
    }
    uint64_t v13 = *a1;
    *(_DWORD *)a1 = *(_DWORD *)a2;
    *((_DWORD *)a1 + 1) = *((_DWORD *)a2 + 1);
    *a2 = v13;
    return 2;
  }
  int v11 = *(_DWORD *)a1;
  int v10 = *((_DWORD *)a1 + 1);
  if (!result)
  {
    *(_DWORD *)a1 = *(_DWORD *)a2;
    *((_DWORD *)a1 + 1) = *((_DWORD *)a2 + 1);
    *(_DWORD *)a2 = v11;
    *((_DWORD *)a2 + 1) = v10;
    if (!(*a4)(a3, a2)) {
      return 1;
    }
    uint64_t v14 = *a2;
    *(_DWORD *)a2 = *(_DWORD *)a3;
    *((_DWORD *)a2 + 1) = *((_DWORD *)a3 + 1);
    *a3 = v14;
    return 2;
  }
  *(_DWORD *)a1 = *(_DWORD *)a3;
  *((_DWORD *)a1 + 1) = *((_DWORD *)a3 + 1);
  *(_DWORD *)a3 = v11;
  *((_DWORD *)a3 + 1) = v10;
  return 1;
}

unint64_t std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,Vec2f *,BOOL (*&)(Vec2f const&,Vec2f const&)>(unint64_t a1, _DWORD *a2, uint64_t (**a3)(uint64_t *, unint64_t))
{
  uint64_t v4 = a2;
  uint64_t v11 = *(void *)a1;
  if ((*a3)(&v11, (unint64_t)(a2 - 2)))
  {
    unint64_t v6 = a1;
    do
      v6 += 8;
    while (((*a3)(&v11, v6) & 1) == 0);
  }
  else
  {
    unint64_t v7 = a1 + 8;
    do
    {
      unint64_t v6 = v7;
      if (v7 >= (unint64_t)v4) {
        break;
      }
      int v8 = (*a3)(&v11, v7);
      unint64_t v7 = v6 + 8;
    }
    while (!v8);
  }
  if (v6 < (unint64_t)v4)
  {
    do
      v4 -= 2;
    while (((*a3)(&v11, (unint64_t)v4) & 1) != 0);
  }
  while (v6 < (unint64_t)v4)
  {
    uint64_t v9 = *(void *)v6;
    *(_DWORD *)unint64_t v6 = *v4;
    *(_DWORD *)(v6 + 4) = v4[1];
    *(void *)uint64_t v4 = v9;
    do
      v6 += 8;
    while (!(*a3)(&v11, v6));
    do
      v4 -= 2;
    while (((*a3)(&v11, (unint64_t)v4) & 1) != 0);
  }
  if (v6 - 8 != a1)
  {
    *(_DWORD *)a1 = *(_DWORD *)(v6 - 8);
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(v6 - 4);
  }
  *(void *)(v6 - 8) = v11;
  return v6;
}

float std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,Vec2f *,BOOL (*&)(Vec2f const&,Vec2f const&)>(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t *, uint64_t *))
{
  uint64_t v6 = 0;
  uint64_t v12 = *a1;
  do
    ++v6;
  while (((*a3)(&a1[v6], &v12) & 1) != 0);
  unint64_t v7 = (unint64_t)&a1[v6];
  if (v6 == 1)
  {
    do
    {
      if (v7 >= (unint64_t)a2) {
        break;
      }
      --a2;
    }
    while (((*a3)(a2, &v12) & 1) == 0);
  }
  else
  {
    do
      --a2;
    while (!(*a3)(a2, &v12));
  }
  unint64_t v8 = (unint64_t)&a1[v6];
  if (v7 < (unint64_t)a2)
  {
    uint64_t v9 = a2;
    do
    {
      uint64_t v10 = *(void *)v8;
      *(_DWORD *)unint64_t v8 = *(_DWORD *)v9;
      *(_DWORD *)(v8 + 4) = *((_DWORD *)v9 + 1);
      uint64_t *v9 = v10;
      do
        v8 += 8;
      while (((*a3)((uint64_t *)v8, &v12) & 1) != 0);
      do
        --v9;
      while (!(*a3)(v9, &v12));
    }
    while (v8 < (unint64_t)v9);
  }
  if ((uint64_t *)(v8 - 8) != a1)
  {
    *(_DWORD *)a1 = *(_DWORD *)(v8 - 8);
    *((_DWORD *)a1 + 1) = *(_DWORD *)(v8 - 4);
  }
  *(_DWORD *)(v8 - 8) = v12;
  float result = *((float *)&v12 + 1);
  *(_DWORD *)(v8 - 4) = HIDWORD(v12);
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>(uint64_t a1, uint64_t *a2, uint64_t (**a3)(uint64_t *, uint64_t *))
{
  uint64_t v6 = ((uint64_t)a2 - a1) >> 3;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if ((*a3)(a2 - 1, (uint64_t *)a1))
      {
        uint64_t v8 = *(void *)a1;
        *(_DWORD *)a1 = *((_DWORD *)a2 - 2);
        *(_DWORD *)(a1 + 4) = *((_DWORD *)a2 - 1);
        *(a2 - 1) = v8;
      }
      return 1;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>((uint64_t *)a1, (uint64_t *)(a1 + 8), a2 - 1, a3);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>(a1, a1 + 8, a1 + 16, a2 - 1, a3);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>(a1, a1 + 8, a1 + 16, a1 + 24, (_DWORD *)a2 - 2, a3);
      return 1;
    default:
      uint64_t v9 = (uint64_t *)(a1 + 16);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>((uint64_t *)a1, (uint64_t *)(a1 + 8), (uint64_t *)(a1 + 16), a3);
      uint64_t v10 = (uint64_t *)(a1 + 24);
      if ((uint64_t *)(a1 + 24) == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    if ((*a3)(v10, v9))
    {
      uint64_t v18 = *v10;
      uint64_t v13 = v11;
      while (1)
      {
        uint64_t v14 = a1 + v13;
        int v15 = *(_DWORD *)(a1 + v13 + 20);
        *(_DWORD *)(v14 + 24) = *(_DWORD *)(a1 + v13 + 16);
        *(_DWORD *)(v14 + 28) = v15;
        if (v13 == -16) {
          break;
        }
        v13 -= 8;
        if (((*a3)(&v18, (uint64_t *)(v14 + 8)) & 1) == 0)
        {
          int v16 = (_DWORD *)(a1 + v13 + 24);
          goto LABEL_12;
        }
      }
      int v16 = (_DWORD *)a1;
LABEL_12:
      int v17 = HIDWORD(v18);
      _DWORD *v16 = v18;
      v16[1] = v17;
      if (++v12 == 8) {
        return v10 + 1 == a2;
      }
    }
    uint64_t v9 = v10;
    v11 += 8;
    if (++v10 == a2) {
      return 1;
    }
  }
}

float std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t (**a5)(uint64_t *, uint64_t *))
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>((uint64_t *)a1, (uint64_t *)a2, (uint64_t *)a3, a5);
  if ((*a5)(a4, (uint64_t *)a3))
  {
    uint64_t v11 = *(void *)a3;
    *(_DWORD *)a3 = *(_DWORD *)a4;
    *(_DWORD *)(a3 + 4) = *((_DWORD *)a4 + 1);
    *a4 = v11;
    if ((*a5)((uint64_t *)a3, (uint64_t *)a2))
    {
      uint64_t v12 = *(void *)a2;
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a3 + 4);
      *(void *)a3 = v12;
      if ((*a5)((uint64_t *)a2, (uint64_t *)a1))
      {
        uint64_t v13 = *(void *)a1;
        *(_DWORD *)a1 = *(_DWORD *)a2;
        float result = *(float *)(a2 + 4);
        *(float *)(a1 + 4) = result;
        *(void *)a2 = v13;
      }
    }
  }
  return result;
}

float std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, uint64_t (**a6)(uint64_t *, uint64_t *))
{
  float v12 = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>(a1, a2, a3, (uint64_t *)a4, a6);
  if (((unsigned int (*)(_DWORD *, uint64_t, float))*a6)(a5, a4, v12))
  {
    uint64_t v14 = *(void *)a4;
    *(_DWORD *)a4 = *a5;
    *(_DWORD *)(a4 + 4) = a5[1];
    *(void *)a5 = v14;
    if ((*a6)((uint64_t *)a4, (uint64_t *)a3))
    {
      uint64_t v15 = *(void *)a3;
      *(_DWORD *)a3 = *(_DWORD *)a4;
      *(_DWORD *)(a3 + 4) = *(_DWORD *)(a4 + 4);
      *(void *)a4 = v15;
      if ((*a6)((uint64_t *)a3, (uint64_t *)a2))
      {
        uint64_t v16 = *(void *)a2;
        *(_DWORD *)a2 = *(_DWORD *)a3;
        *(_DWORD *)(a2 + 4) = *(_DWORD *)(a3 + 4);
        *(void *)a3 = v16;
        if ((*a6)((uint64_t *)a2, (uint64_t *)a1))
        {
          uint64_t v17 = *(void *)a1;
          *(_DWORD *)a1 = *(_DWORD *)a2;
          float result = *(float *)(a2 + 4);
          *(float *)(a1 + 4) = result;
          *(void *)a2 = v17;
        }
      }
    }
  }
  return result;
}

char *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*,Vec2f*>(char *a1, char *a2, char *a3, unsigned int (**a4)(uint64_t, uint64_t), __n128 a5)
{
  if (a1 != a2)
  {
    uint64_t v9 = a2 - a1;
    uint64_t v10 = (a2 - a1) >> 3;
    if (a2 - a1 >= 9)
    {
      unint64_t v11 = (unint64_t)(v10 - 2) >> 1;
      unint64_t v12 = v11 + 1;
      uint64_t v13 = &a1[8 * v11];
      do
      {
        a5.n128_f32[0] = std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>((uint64_t)a1, a4, v10, v13);
        v13 -= 8;
        --v12;
      }
      while (v12);
    }
    uint64_t v14 = a2;
    if (a2 != a3)
    {
      uint64_t v15 = a2;
      do
      {
        if (((unsigned int (*)(char *, char *, __n128))*a4)(v15, a1, a5))
        {
          uint64_t v16 = *(void *)v15;
          *(_DWORD *)uint64_t v15 = *(_DWORD *)a1;
          *((_DWORD *)v15 + 1) = *((_DWORD *)a1 + 1);
          *(void *)a1 = v16;
          a5.n128_f32[0] = std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>((uint64_t)a1, a4, v10, a1);
        }
        v15 += 8;
      }
      while (v15 != a3);
      uint64_t v14 = a3;
    }
    if (v9 >= 9)
    {
      uint64_t v17 = (unint64_t)v9 >> 3;
      uint64_t v18 = a2 - 8;
      do
      {
        int v20 = *(_DWORD *)a1;
        int v19 = *((_DWORD *)a1 + 1);
        int v21 = (char *)std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>(a1, a4, v17);
        if (v18 == v21)
        {
          *(_DWORD *)int v21 = v20;
          *((_DWORD *)v21 + 1) = v19;
        }
        else
        {
          *(_DWORD *)int v21 = *(_DWORD *)v18;
          *((_DWORD *)v21 + 1) = *((_DWORD *)v18 + 1);
          *(_DWORD *)uint64_t v18 = v20;
          *((_DWORD *)v18 + 1) = v19;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>((uint64_t)a1, (uint64_t)(v21 + 8), (uint64_t (**)(void, void))a4, (v21 + 8 - a1) >> 3);
        }
        v18 -= 8;
      }
      while (v17-- > 2);
    }
    return v14;
  }
  return a3;
}

float std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>(uint64_t a1, unsigned int (**a2)(void, void), uint64_t a3, _DWORD *a4)
{
  unint64_t v6 = a3 - 2;
  if (a3 >= 2)
  {
    v20[11] = v4;
    v20[12] = v5;
    unint64_t v7 = a4;
    int64_t v9 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) >= ((uint64_t)a4 - a1) >> 3)
    {
      uint64_t v12 = ((uint64_t)a4 - a1) >> 2;
      uint64_t v13 = v12 + 1;
      uint64_t v14 = (_DWORD *)(a1 + 8 * (v12 + 1));
      uint64_t v15 = v12 + 2;
      if (v12 + 2 < a3 && (*a2)(v14, v14 + 2))
      {
        v14 += 2;
        uint64_t v13 = v15;
      }
      if ((((uint64_t (*)(_DWORD *, _DWORD *))*a2)(v14, v7) & 1) == 0)
      {
        v20[0] = *(void *)v7;
        do
        {
          uint64_t v17 = v14;
          *unint64_t v7 = *v14;
          v7[1] = v14[1];
          if (v9 < v13) {
            break;
          }
          uint64_t v18 = (2 * v13) | 1;
          uint64_t v14 = (_DWORD *)(a1 + 8 * v18);
          uint64_t v19 = 2 * v13 + 2;
          if (v19 < a3)
          {
            if ((*a2)(a1 + 8 * v18, v14 + 2))
            {
              v14 += 2;
              uint64_t v18 = v19;
            }
          }
          unint64_t v7 = v17;
          uint64_t v13 = v18;
        }
        while (!(*a2)(v14, v20));
        *uint64_t v17 = v20[0];
        float result = *((float *)v20 + 1);
        v17[1] = HIDWORD(v20[0]);
      }
    }
  }
  return result;
}

_DWORD *std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>(_DWORD *a1, unsigned int (**a2)(uint64_t, uint64_t), uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = a3 - 2;
  if (a3 < 2) {
    uint64_t v7 = a3 - 1;
  }
  uint64_t v8 = v7 >> 1;
  do
  {
    int64_t v9 = &a1[2 * v6 + 2];
    uint64_t v10 = (2 * v6) | 1;
    uint64_t v11 = 2 * v6 + 2;
    if (v11 < a3 && (*a2)((uint64_t)&a1[2 * v6 + 2], (uint64_t)&a1[2 * v6 + 4]))
    {
      v9 += 2;
      uint64_t v10 = v11;
    }
    *a1 = *v9;
    a1[1] = v9[1];
    a1 = v9;
    uint64_t v6 = v10;
  }
  while (v10 <= v8);
  return v9;
}

double std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(Vec2f const&,Vec2f const&),Vec2f*>(uint64_t a1, uint64_t a2, uint64_t (**a3)(void, void), uint64_t a4)
{
  unint64_t v6 = a4 - 2;
  if (a4 >= 2)
  {
    v14[7] = v4;
    v14[8] = v5;
    unint64_t v9 = v6 >> 1;
    uint64_t v10 = (_DWORD *)(a1 + 8 * (v6 >> 1));
    uint64_t v11 = (void *)(a2 - 8);
    if ((*a3)(v10, a2 - 8))
    {
      v14[0] = *v11;
      do
      {
        uint64_t v13 = v10;
        *(_DWORD *)uint64_t v11 = *v10;
        *((_DWORD *)v11 + 1) = v10[1];
        if (!v9) {
          break;
        }
        unint64_t v9 = (v9 - 1) >> 1;
        uint64_t v10 = (_DWORD *)(a1 + 8 * v9);
        uint64_t v11 = v13;
      }
      while (((*a3)(v10, v14) & 1) != 0);
      double result = *(double *)v14;
      *uint64_t v13 = v14[0];
    }
  }
  return result;
}

char *std::vector<Vec2f>::__assign_with_size[abi:ne180100]<Vec2f*,Vec2f*>(void *a1, _DWORD *a2, _DWORD *a3, unint64_t a4)
{
  unint64_t v6 = a2;
  uint64_t v8 = a1[2];
  double result = (char *)*a1;
  if (a4 <= (v8 - (uint64_t)result) >> 3)
  {
    uint64_t v17 = (char *)a1[1];
    uint64_t v13 = a1 + 1;
    uint64_t v12 = v17;
    unint64_t v18 = (v17 - result) >> 3;
    if (v18 >= a4)
    {
      char v22 = result;
      if (a2 != a3)
      {
        BOOL v23 = result;
        do
        {
          *(_DWORD *)BOOL v23 = *v6;
          *((_DWORD *)v23 + 1) = v6[1];
          v22 += 8;
          v6 += 2;
          v23 += 8;
        }
        while (v6 != a3);
      }
      uint64_t v16 = (char *)(v22 - result);
      uint64_t v12 = result;
    }
    else
    {
      uint64_t v19 = &a2[2 * v18];
      if (v12 != result)
      {
        do
        {
          *(_DWORD *)double result = *v6;
          *((_DWORD *)result + 1) = v6[1];
          v6 += 2;
          result += 8;
        }
        while (v6 != v19);
      }
      int v20 = v12;
      if (v19 != a3)
      {
        int v21 = v12;
        do
        {
          *(_DWORD *)int v21 = *v19;
          *((_DWORD *)v21 + 1) = v19[1];
          v20 += 8;
          v19 += 2;
          v21 += 8;
        }
        while (v19 != a3);
      }
      uint64_t v16 = (char *)(v20 - v12);
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    double result = std::vector<double>::__vallocate[abi:ne180100](a1, v11);
    uint64_t v14 = (char *)a1[1];
    uint64_t v13 = a1 + 1;
    uint64_t v12 = v14;
    uint64_t v15 = v14;
    if (v6 != a3)
    {
      uint64_t v15 = v12;
      do
      {
        *(_DWORD *)uint64_t v15 = *v6;
        *((_DWORD *)v15 + 1) = v6[1];
        v15 += 8;
        v6 += 2;
      }
      while (v6 != a3);
    }
    uint64_t v16 = (char *)(v15 - v12);
  }
  *uint64_t v13 = &v16[(void)v12];
  return result;
}

std::vector<int> *__cdecl std::vector<int>::vector(std::vector<int> *this, std::vector<int>::size_type __n, const std::vector<int>::value_type *__x)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<float>::__vallocate[abi:ne180100](this, __n);
    std::vector<int>::pointer end = this->__end_;
    uint64_t v7 = &end[__n];
    std::vector<int>::size_type v8 = 4 * __n;
    do
    {
      *end++ = *__x;
      v8 -= 4;
    }
    while (v8);
    this->__end_ = v7;
  }
  return this;
}

void sub_1B7A38E00(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<OMCostPie>::__push_back_slow_path<OMCostPie>(uint64_t *a1, _DWORD *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x2E8BA2E8BA2E8BA3 * ((a1[1] - *a1) >> 2);
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x5D1745D1745D174) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x2E8BA2E8BA2E8BA3 * ((a1[2] - v3) >> 2);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x2E8BA2E8BA2E8BALL) {
    unint64_t v9 = 0x5D1745D1745D174;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v19 = a1 + 2;
  uint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<OMCostPie>>(v7, v9);
  unint64_t v11 = &v10[44 * v4];
  __p = v10;
  uint64_t v16 = v11;
  unint64_t v18 = &v10[44 * v12];
  *(_DWORD *)unint64_t v11 = *a2;
  *((_DWORD *)v11 + 1) = a2[1];
  *((_DWORD *)v11 + 2) = a2[2];
  *((_DWORD *)v11 + 3) = a2[3];
  *((_DWORD *)v11 + 4) = a2[4];
  *((_DWORD *)v11 + 5) = a2[5];
  *((_DWORD *)v11 + 6) = a2[6];
  *((_DWORD *)v11 + 7) = a2[7];
  *((_DWORD *)v11 + 8) = a2[8];
  *((_DWORD *)v11 + 9) = a2[9];
  *((_DWORD *)v11 + 10) = a2[10];
  uint64_t v17 = v11 + 44;
  std::vector<OMCostPie>::__swap_out_circular_buffer(a1, &__p);
  uint64_t v13 = a1[1];
  if (v17 != v16) {
    uint64_t v17 = &v16[(v17 - v16 - 44) % 0x2CuLL];
  }
  if (__p) {
    operator delete(__p);
  }
  return v13;
}

void sub_1B7A38FA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<OMCostPie>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<OMCostPie>,std::reverse_iterator<OMCostPie*>,std::reverse_iterator<OMCostPie*>,std::reverse_iterator<OMCostPie*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v4;
  uint64_t v5 = *a1;
  *a1 = v4;
  a2[1] = v5;
  uint64_t v6 = a1[1];
  a1[1] = a2[2];
  a2[2] = v6;
  uint64_t v7 = a1[2];
  a1[2] = a2[3];
  a2[3] = v7;
  *a2 = a2[1];
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<OMCostPie>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x5D1745D1745D175) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(44 * a2);
}

float std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<OMCostPie>,std::reverse_iterator<OMCostPie*>,std::reverse_iterator<OMCostPie*>,std::reverse_iterator<OMCostPie*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  if (a3 != a5)
  {
    uint64_t v8 = a7 - 20;
    do
    {
      int v9 = *(_DWORD *)(a3 - 44);
      a3 -= 44;
      *(_DWORD *)(v8 - 24) = v9;
      *(_DWORD *)(v8 - 20) = *(_DWORD *)(a3 + 4);
      *(_DWORD *)(v8 - 16) = *(_DWORD *)(a3 + 8);
      *(_DWORD *)(v8 - 12) = *(_DWORD *)(a3 + 12);
      *(_DWORD *)(v8 - 8) = *(_DWORD *)(a3 + 16);
      *(_DWORD *)(v8 - 4) = *(_DWORD *)(a3 + 20);
      *(_DWORD *)uint64_t v8 = *(_DWORD *)(a3 + 24);
      *(_DWORD *)(v8 + 4) = *(_DWORD *)(a3 + 28);
      *(_DWORD *)(v8 + 8) = *(_DWORD *)(a3 + 32);
      *(_DWORD *)(v8 + 12) = *(_DWORD *)(a3 + 36);
      float result = *(float *)(a3 + 40);
      *(float *)(v8 + 16) = result;
      v8 -= 44;
      v7 -= 44;
    }
    while (a3 != a5);
  }
  return result;
}

_DWORD *std::vector<Vec3f>::__insert_with_size[abi:ne180100]<std::__wrap_iter<Vec3f*>,std::__wrap_iter<Vec3f*>>(uint64_t *a1, uint64_t a2, _DWORD *a3, _DWORD *a4, uint64_t a5)
{
  uint64_t v5 = (_DWORD *)a2;
  if (a5 < 1) {
    return v5;
  }
  uint64_t v11 = a1[2];
  uint64_t v9 = (uint64_t)(a1 + 2);
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - v12) >> 2)) < a5)
  {
    uint64_t v13 = *a1;
    unint64_t v14 = a5 - 0x5555555555555555 * ((uint64_t)(v12 - *a1) >> 2);
    if (v14 > 0x1555555555555555) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((a2 - v13) >> 2);
    unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v10 - v13) >> 2);
    uint64_t v17 = 2 * v16;
    if (2 * v16 <= v14) {
      uint64_t v17 = a5 - 0x5555555555555555 * ((uint64_t)(v12 - *a1) >> 2);
    }
    if (v16 >= 0xAAAAAAAAAAAAAAALL) {
      unint64_t v18 = 0x1555555555555555;
    }
    else {
      unint64_t v18 = v17;
    }
    uint64_t v32 = v9;
    if (v18) {
      uint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Vec3f>>(v9, v18);
    }
    else {
      uint64_t v19 = 0;
    }
    uint64_t v25 = &v19[12 * v15];
    __p = v19;
    uint64_t v29 = v25;
    int v31 = &v19[12 * v18];
    unint64_t v26 = &v25[12 * a5];
    do
    {
      *(_DWORD *)uint64_t v25 = *a3;
      *((_DWORD *)v25 + 1) = a3[1];
      *((_DWORD *)v25 + 2) = a3[2];
      v25 += 12;
      a3 += 3;
    }
    while (v25 != v26);
    float v30 = v26;
    uint64_t v5 = (_DWORD *)std::vector<Vec3f>::__swap_out_circular_buffer(a1, &__p, v5);
    if (v30 != v29) {
      float v30 = &v29[(v30 - v29 - 12) % 0xCuLL];
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }
  if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - a2) >> 2)) >= a5)
  {
    int v20 = &a3[3 * a5];
LABEL_18:
    std::vector<Vec3f>::__move_range((uint64_t)a1, a2, v12, a2 + 12 * a5);
    if (v20 != a3)
    {
      uint64_t v24 = v5;
      do
      {
        _DWORD *v24 = *a3;
        v24[1] = a3[1];
        v24[2] = a3[2];
        a3 += 3;
        v24 += 3;
      }
      while (a3 != v20);
    }
    return v5;
  }
  int v20 = &a3[(uint64_t)(v12 - a2) >> 2];
  uint64_t v21 = *(void *)(v9 - 8);
  if (v20 != a4)
  {
    char v22 = &a3[(uint64_t)(v12 - a2) >> 2];
    BOOL v23 = *(_DWORD **)(v9 - 8);
    do
    {
      *BOOL v23 = *v22;
      v23[1] = v22[1];
      v23[2] = v22[2];
      v21 += 12;
      v22 += 3;
      v23 += 3;
    }
    while (v22 != a4);
  }
  a1[1] = v21;
  if ((uint64_t)(v12 - a2) >= 1) {
    goto LABEL_18;
  }
  return v5;
}

void sub_1B7A39380(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

float std::vector<Vec3f>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = a2 + v4 - a4;
  uint64_t v6 = v4;
  while (v5 < a3)
  {
    *(_DWORD *)uint64_t v6 = *(_DWORD *)v5;
    *(_DWORD *)(v6 + 4) = *(_DWORD *)(v5 + 4);
    float result = *(float *)(v5 + 8);
    *(float *)(v6 + 8) = result;
    v6 += 12;
    v5 += 12;
  }
  *(void *)(a1 + 8) = v6;
  if (v4 != a4)
  {
    uint64_t v8 = 4 * ((v4 - a4) >> 2);
    uint64_t v9 = a2 - 4;
    uint64_t v10 = (float *)(v4 - 4);
    do
    {
      *(v10 - 2) = *(float *)(v9 + v8 - 8);
      *(v10 - 1) = *(float *)(v9 + v8 - 4);
      float result = *(float *)(v9 + v8);
      *uint64_t v10 = result;
      v10 -= 3;
      v8 -= 12;
    }
    while (v8);
  }
  return result;
}

uint64_t std::vector<Vec3f>::__swap_out_circular_buffer(void *a1, void *a2, _DWORD *a3)
{
  uint64_t result = a2[1];
  unint64_t v5 = (_DWORD *)*a1;
  uint64_t v6 = result;
  if ((_DWORD *)*a1 != a3)
  {
    uint64_t v7 = a3;
    uint64_t v6 = a2[1];
    do
    {
      int v8 = *(v7 - 3);
      v7 -= 3;
      *(_DWORD *)(v6 - 12) = v8;
      v6 -= 12;
      *(_DWORD *)(v6 + 4) = v7[1];
      *(_DWORD *)(v6 + 8) = v7[2];
    }
    while (v7 != v5);
  }
  a2[1] = v6;
  uint64_t v9 = (_DWORD *)a1[1];
  for (i = (_DWORD *)a2[2]; a3 != v9; a3 += 3)
  {
    _DWORD *i = *a3;
    i[1] = a3[1];
    i[2] = a3[2];
    i += 3;
  }
  a2[2] = i;
  uint64_t v11 = (_DWORD *)*a1;
  *a1 = v6;
  a2[1] = v11;
  uint64_t v12 = a1[1];
  a1[1] = a2[2];
  a2[2] = v12;
  uint64_t v13 = a1[2];
  a1[2] = a2[3];
  a2[3] = v13;
  *a2 = a2[1];
  return result;
}

void OMSpline::getCurveSamples(uint64_t *a1, uint64_t a2, int a3, int a4, double a5, __n128 a6)
{
  int v6 = ((unint64_t)(a1[1] - *a1) >> 5) - (a4 ^ 1);
  if (v6 >= 1)
  {
    int v10 = 0;
    a6.n128_u32[0] = 1.0;
    float v11 = 1.0 / (float)a3;
    do
      OMSpline::getPartialCurveSamples(a1, a2, v10++, a3, v11, a6);
    while (v6 != v10);
  }
}

void OMSpline::getPartialCurveSamples(uint64_t *a1, uint64_t a2, int a3, int a4, float a5, __n128 a6)
{
  uint64_t v6 = *a1;
  if (((unint64_t)(a1[1] - *a1) >> 5) - 1 == a3) {
    int v7 = 0;
  }
  else {
    int v7 = a3 + 1;
  }
  if (a4 >= 1)
  {
    int v11 = 0;
    uint64_t v12 = (float32x2_t *)(v6 + 32 * a3);
    uint64_t v13 = (float32x2_t *)(v6 + 32 * v7);
    __asm { FMOV            V0.2S, #3.0 }
    float32x2_t v20 = v12[1];
    float32x2_t v19 = v12[2];
    float32x2_t v21 = vmul_f32(v20, _D0);
    float32x2_t v22 = vmul_f32(v19, _D0);
    float32x2_t v23 = vsub_f32(v22, v21);
    __asm { FMOV            V4.2S, #-6.0 }
    float32x2_t v25 = vmul_f32(*v13, _D0);
    float32x2_t v26 = vadd_f32(vadd_f32(v21, vmul_f32(v19, _D4)), v25);
    float32x2_t v27 = vadd_f32(vsub_f32(vsub_f32(v22, v20), v25), v13[1]);
    unint64_t v28 = (void *)(a2 + 16);
    uint64_t v29 = *(float32x2_t **)(a2 + 8);
    a6.n128_u64[0] = 0;
    do
    {
      float32x2_t v30 = vadd_f32(v20, vmul_n_f32(vadd_f32(v23, vmul_n_f32(vadd_f32(v26, vmul_n_f32(v27, a6.n128_f32[0])), a6.n128_f32[0])), a6.n128_f32[0]));
      if ((unint64_t)v29 >= *v28)
      {
        uint64_t v32 = *(float32x2_t **)a2;
        uint64_t v33 = ((uint64_t)v29 - *(void *)a2) >> 3;
        unint64_t v34 = v33 + 1;
        if ((unint64_t)(v33 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        __n128 v40 = a6;
        uint64_t v35 = *v28 - (void)v32;
        if (v35 >> 2 > v34) {
          unint64_t v34 = v35 >> 2;
        }
        if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v36 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v36 = v34;
        }
        if (v36)
        {
          uint64_t v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v28, v36);
          uint64_t v32 = *(float32x2_t **)a2;
          uint64_t v29 = *(float32x2_t **)(a2 + 8);
        }
        else
        {
          uint64_t v37 = 0;
        }
        unint64_t v38 = (float32x2_t *)&v37[8 * v33];
        *unint64_t v38 = v30;
        int v31 = v38 + 1;
        while (v29 != v32)
        {
          __int32 v39 = v29[-1].i32[0];
          --v29;
          v38[-1].i32[0] = v39;
          --v38;
          v38->i32[1] = v29->i32[1];
        }
        *(void *)a2 = v38;
        *(void *)(a2 + 8) = v31;
        *(void *)(a2 + 16) = &v37[8 * v36];
        if (v32) {
          operator delete(v32);
        }
        a6 = v40;
      }
      else
      {
        *uint64_t v29 = v30;
        int v31 = v29 + 1;
      }
      *(void *)(a2 + 8) = v31;
      ++v11;
      a6.n128_f32[0] = a6.n128_f32[0] + a5;
      uint64_t v29 = v31;
    }
    while (v11 != a4);
  }
}

uint64_t OMSpline::recomputeInternalBezier(uint64_t this)
{
  uint64_t v1 = *(float32x2_t **)this;
  unint64_t v2 = *(void *)(this + 8) - *(void *)this;
  unint64_t v3 = v2 >> 5;
  if (v2 >= 0x41 && (int)v3 >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = (v3 - 1);
    int v7 = *(unsigned __int8 *)(this + 33);
    uint64_t v8 = (v2 >> 5);
    uint64_t v9 = v1 + 2;
    float32x2_t v10 = (float32x2_t)vdup_n_s32(0x3F2AAAABu);
    float32x2_t v11 = (float32x2_t)vdup_n_s32(0x3EAAAAABu);
    do
    {
      if (v7)
      {
        int v12 = v5 - (v5 != 0);
        if (v6 == v5) {
          int v13 = v5;
        }
        else {
          int v13 = v5 + 1;
        }
      }
      else
      {
        int v12 = v5 - 1;
        if (!v5) {
          int v12 = v6;
        }
        if (v6 == v5) {
          int v13 = 0;
        }
        else {
          int v13 = v5 + 1;
        }
      }
      float32x2_t v14 = v9[1];
      float32x2_t v15 = v1[4 * v12 + 3];
      float32x2_t v16 = vadd_f32(v15, vmul_f32(vsub_f32(v14, v15), v10));
      v9[-2] = v16;
      float32x2_t v17 = vadd_f32(v14, vmul_f32(vsub_f32(v1[4 * v13 + 3], v14), v11));
      float32x2_t *v9 = v17;
      if (v7 && (!v5 || v6 == v5))
      {
        *(float32x2_t *)&long long v18 = v14;
        *((float32x2_t *)&v18 + 1) = v14;
        *(_OWORD *)v9[-2].f32 = v18;
        float32x2_t *v9 = v14;
      }
      else
      {
        v9[-1] = vadd_f32(v16, vmul_f32(vsub_f32(v17, v16), (float32x2_t)0x3F0000003F000000));
      }
      ++v5;
      v9 += 4;
    }
    while (v8 != v5);
  }
  return this;
}

float OMSpline::move(OMSpline *this, int a2, float *a3, unsigned int a4)
{
  uint64_t v5 = a2;
  uint64_t v6 = *(_DWORD **)this;
  int v7 = (float *)(*(void *)this + 32 * v5);
  float v8 = v7[3];
  float result = *a3 + v7[2];
  v7[2] = result;
  float v10 = a3[1] + v8;
  v7[3] = v10;
  if (!a4)
  {
    *int v7 = result;
    v7[1] = v10;
    v7[4] = result;
    v7[5] = v10;
    return result;
  }
  if (a4 > 2)
  {
    if (a4 != 3) {
      return result;
    }
    goto LABEL_12;
  }
  uint64_t v12 = *((void *)this + 1) - (void)v6;
  if ((unint64_t)v12 <= 0x5F)
  {
LABEL_12:
    float v19 = v7[1];
    *int v7 = *a3 + *v7;
    v7[1] = a3[1] + v19;
    float32x2_t v20 = (float *)&v6[8 * v5];
    float v21 = v20[5];
    v20[4] = *a3 + v20[4];
    float result = a3[1] + v21;
    v20[5] = result;
    return result;
  }
  unint64_t v13 = (unint64_t)v12 >> 5;
  uint64_t v14 = (int)(v12 >> 5) - 1;
  if (a4 == 2)
  {
    if (!a2)
    {
      __p = 0;
      float v58 = 0;
      unint64_t v59 = 0;
      unint64_t v28 = (_DWORD *)std::vector<OMVertex>::__push_back_slow_path<OMVertex>((uint64_t *)&__p, v6);
      uint64_t v29 = *(_DWORD **)this;
      unint64_t v30 = v59;
      float v58 = v28;
      if ((unint64_t)v28 >= v59)
      {
        int v31 = (_DWORD *)std::vector<OMVertex>::__push_back_slow_path<OMVertex>((uint64_t *)&__p, v29);
        uint64_t v29 = *(_DWORD **)this;
        unint64_t v30 = v59;
      }
      else
      {
        _DWORD *v28 = *v29;
        v28[1] = v29[1];
        v28[2] = v29[2];
        v28[3] = v29[3];
        v28[4] = v29[4];
        v28[5] = v29[5];
        v28[6] = v29[6];
        v28[7] = v29[7];
        int v31 = v28 + 8;
      }
      float v58 = v31;
      if ((unint64_t)v31 >= v30)
      {
        unint64_t v38 = (_DWORD *)std::vector<OMVertex>::__push_back_slow_path<OMVertex>((uint64_t *)&__p, v29);
        uint64_t v29 = *(_DWORD **)this;
        unint64_t v30 = v59;
      }
      else
      {
        *int v31 = *v29;
        v31[1] = v29[1];
        v31[2] = v29[2];
        v31[3] = v29[3];
        float v31[4] = v29[4];
        v31[5] = v29[5];
        v31[6] = v29[6];
        v31[7] = v29[7];
        unint64_t v38 = v31 + 8;
      }
      float v58 = v38;
      if ((unint64_t)v38 >= v30)
      {
        __int32 v39 = (_DWORD *)std::vector<OMVertex>::__push_back_slow_path<OMVertex>((uint64_t *)&__p, v29 + 8);
        uint64_t v29 = *(_DWORD **)this;
        unint64_t v30 = v59;
      }
      else
      {
        *unint64_t v38 = v29[8];
        v38[1] = v29[9];
        v38[2] = v29[10];
        v38[3] = v29[11];
        v38[4] = v29[12];
        v38[5] = v29[13];
        v38[6] = v29[14];
        v38[7] = v29[15];
        __int32 v39 = v38 + 8;
      }
      float v58 = v39;
      if ((unint64_t)v39 >= v30)
      {
        uint64_t v40 = std::vector<OMVertex>::__push_back_slow_path<OMVertex>((uint64_t *)&__p, v29 + 16);
      }
      else
      {
        *__int32 v39 = v29[16];
        v39[1] = v29[17];
        v39[2] = v29[18];
        v39[3] = v29[19];
        v39[4] = v29[20];
        v39[5] = v29[21];
        v39[6] = v29[22];
        v39[7] = v29[23];
        uint64_t v40 = (uint64_t)(v39 + 8);
      }
      float v58 = (_DWORD *)v40;
      OMSpline::tangentsAuto((uint64_t)this, (uint64_t *)&__p, 0, 1, 2);
      OMSpline::tangentsAuto((uint64_t)this, (uint64_t *)&__p, 1, 2, 3);
      OMSpline::tangentsAuto((uint64_t)this, (uint64_t *)&__p, 2, 3, 4);
      unint64_t v36 = __p;
      int v41 = *(_DWORD **)this;
      *int v41 = *((_DWORD *)__p + 16);
      v41[1] = v36[17];
      v41[2] = v36[18];
      v41[3] = v36[19];
      v41[4] = v36[20];
      v41[5] = v36[21];
      v41[6] = v36[22];
      v41[7] = v36[23];
      v41[8] = v36[24];
      v41[9] = v36[25];
      v41[10] = v36[26];
      v41[11] = v36[27];
      v41[12] = v36[28];
      v41[13] = v36[29];
      v41[14] = v36[30];
      v41[15] = v36[31];
      v41[16] = v36[32];
      v41[17] = v36[33];
      v41[18] = v36[34];
      v41[19] = v36[35];
      v41[20] = v36[36];
      v41[21] = v36[37];
      v41[22] = v36[38];
      v41[23] = v36[39];
      *(void *)int v41 = *(void *)&v41[8 * v5 + 2];
      goto LABEL_65;
    }
    if (a2 == 1 && (v12 >> 5) == 3)
    {
      __p = 0;
      float v58 = 0;
      unint64_t v59 = 0;
      float32x2_t v15 = (_DWORD *)std::vector<OMVertex>::__push_back_slow_path<OMVertex>((uint64_t *)&__p, v6);
      float32x2_t v16 = *(_DWORD **)this;
      unint64_t v17 = v59;
      float v58 = v15;
      if ((unint64_t)v15 >= v59)
      {
        long long v18 = (_DWORD *)std::vector<OMVertex>::__push_back_slow_path<OMVertex>((uint64_t *)&__p, v16);
        float32x2_t v16 = *(_DWORD **)this;
        unint64_t v17 = v59;
      }
      else
      {
        _DWORD *v15 = *v16;
        v15[1] = v16[1];
        v15[2] = v16[2];
        v15[3] = v16[3];
        v15[4] = v16[4];
        v15[5] = v16[5];
        v15[6] = v16[6];
        v15[7] = v16[7];
        long long v18 = v15 + 8;
      }
      float v58 = v18;
      if ((unint64_t)v18 >= v17)
      {
        unint64_t v48 = (_DWORD *)std::vector<OMVertex>::__push_back_slow_path<OMVertex>((uint64_t *)&__p, v16 + 8);
        float32x2_t v16 = *(_DWORD **)this;
        unint64_t v17 = v59;
      }
      else
      {
        *long long v18 = v16[8];
        v18[1] = v16[9];
        v18[2] = v16[10];
        v18[3] = v16[11];
        v18[4] = v16[12];
        v18[5] = v16[13];
        v18[6] = v16[14];
        v18[7] = v16[15];
        unint64_t v48 = v18 + 8;
      }
      float v58 = v48;
      if ((unint64_t)v48 >= v17)
      {
        uint64_t v49 = (_DWORD *)std::vector<OMVertex>::__push_back_slow_path<OMVertex>((uint64_t *)&__p, v16 + 16);
        float32x2_t v16 = *(_DWORD **)this;
        unint64_t v17 = v59;
      }
      else
      {
        _DWORD *v48 = v16[16];
        v48[1] = v16[17];
        v48[2] = v16[18];
        v48[3] = v16[19];
        v48[4] = v16[20];
        v48[5] = v16[21];
        v48[6] = v16[22];
        v48[7] = v16[23];
        uint64_t v49 = v48 + 8;
      }
      float v58 = v49;
      if ((unint64_t)v49 >= v17)
      {
        uint64_t v50 = std::vector<OMVertex>::__push_back_slow_path<OMVertex>((uint64_t *)&__p, v16 + 16);
      }
      else
      {
        *uint64_t v49 = v16[16];
        v49[1] = v16[17];
        v49[2] = v16[18];
        v49[3] = v16[19];
        v49[4] = v16[20];
        v49[5] = v16[21];
        v49[6] = v16[22];
        v49[7] = v16[23];
        uint64_t v50 = (uint64_t)(v49 + 8);
      }
      float v58 = (_DWORD *)v50;
      OMSpline::tangentsAuto((uint64_t)this, (uint64_t *)&__p, 0, 1, 2);
      OMSpline::tangentsAuto((uint64_t)this, (uint64_t *)&__p, 1, 2, 3);
      OMSpline::tangentsAuto((uint64_t)this, (uint64_t *)&__p, 2, 3, 4);
      unint64_t v36 = __p;
      float v51 = *(_DWORD **)this;
      *float v51 = *((_DWORD *)__p + 8);
      v51[1] = v36[9];
      v51[2] = v36[10];
      v51[3] = v36[11];
      v51[4] = v36[12];
      v51[5] = v36[13];
      v51[6] = v36[14];
      v51[7] = v36[15];
      v51[8] = v36[16];
      v51[9] = v36[17];
      v51[10] = v36[18];
      v51[11] = v36[19];
      v51[12] = v36[20];
      v51[13] = v36[21];
      v51[14] = v36[22];
      v51[15] = v36[23];
      v51[16] = v36[24];
      v51[17] = v36[25];
      v51[18] = v36[26];
      v51[19] = v36[27];
      v51[20] = v36[28];
      v51[21] = v36[29];
      v51[22] = v36[30];
      v51[23] = v36[31];
      goto LABEL_65;
    }
    if (a2 == 1)
    {
      __p = 0;
      float v58 = 0;
      unint64_t v59 = 0;
      std::vector<OMVertex>::push_back[abi:ne180100]((uint64_t *)&__p, v6);
      std::vector<OMVertex>::push_back[abi:ne180100]((uint64_t *)&__p, *(_DWORD **)this);
      std::vector<OMVertex>::push_back[abi:ne180100]((uint64_t *)&__p, (_DWORD *)(*(void *)this + 32));
      std::vector<OMVertex>::push_back[abi:ne180100]((uint64_t *)&__p, (_DWORD *)(*(void *)this + 64));
      std::vector<OMVertex>::push_back[abi:ne180100]((uint64_t *)&__p, (_DWORD *)(*(void *)this + 96));
      OMSpline::tangentsAuto((uint64_t)this, (uint64_t *)&__p, 0, 1, 2);
      OMSpline::tangentsAuto((uint64_t)this, (uint64_t *)&__p, 1, 2, 3);
      OMSpline::tangentsAuto((uint64_t)this, (uint64_t *)&__p, 2, 3, 4);
      unint64_t v36 = __p;
      uint64_t v37 = *(_DWORD **)this;
      _DWORD *v37 = *((_DWORD *)__p + 8);
      v37[1] = v36[9];
      v37[2] = v36[10];
      v37[3] = v36[11];
      v37[4] = v36[12];
      v37[5] = v36[13];
      v37[6] = v36[14];
      v37[7] = v36[15];
      v37[8] = v36[16];
      v37[9] = v36[17];
      v37[10] = v36[18];
      v37[11] = v36[19];
      v37[12] = v36[20];
      v37[13] = v36[21];
      v37[14] = v36[22];
      v37[15] = v36[23];
      v37[16] = v36[24];
      v37[17] = v36[25];
      v37[18] = v36[26];
      v37[19] = v36[27];
      v37[20] = v36[28];
      v37[21] = v36[29];
      v37[22] = v36[30];
      v37[23] = v36[31];
      v37[24] = v36[32];
      v37[25] = v36[33];
      v37[26] = v36[34];
      v37[27] = v36[35];
      v37[28] = v36[36];
      v37[29] = v36[37];
      v37[30] = v36[38];
      v37[31] = v36[39];
LABEL_65:
      float v58 = v36;
      operator delete(v36);
      return result;
    }
    if (v14 == a2)
    {
      __p = 0;
      float v58 = 0;
      unint64_t v59 = 0;
      std::vector<OMVertex>::push_back[abi:ne180100]((uint64_t *)&__p, &v6[8 * v5 - 16]);
      std::vector<OMVertex>::push_back[abi:ne180100]((uint64_t *)&__p, (_DWORD *)(*(void *)this + 32 * (v5 - 1)));
      std::vector<OMVertex>::push_back[abi:ne180100]((uint64_t *)&__p, (_DWORD *)(*(void *)this + 32 * v5));
      std::vector<OMVertex>::push_back[abi:ne180100]((uint64_t *)&__p, (_DWORD *)(*(void *)this + 32 * v5));
      std::vector<OMVertex>::push_back[abi:ne180100]((uint64_t *)&__p, (_DWORD *)(*(void *)this + 32 * v5));
      OMSpline::tangentsAuto((uint64_t)this, (uint64_t *)&__p, 0, 1, 2);
      OMSpline::tangentsAuto((uint64_t)this, (uint64_t *)&__p, 1, 2, 3);
      OMSpline::tangentsAuto((uint64_t)this, (uint64_t *)&__p, 2, 3, 4);
      unint64_t v36 = __p;
      uint64_t v42 = *(void *)this;
      uint64_t v43 = (_DWORD *)(*(void *)this + 32 * (v5 - 2));
      _DWORD *v43 = *(_DWORD *)__p;
      v43[1] = v36[1];
      void v43[2] = v36[2];
      v43[3] = v36[3];
      v43[4] = v36[4];
      v43[5] = v36[5];
      v43[6] = v36[6];
      v43[7] = v36[7];
      uint64_t v44 = (_DWORD *)(v42 + 32 * (v5 - 1));
      _DWORD *v44 = v36[8];
      v44[1] = v36[9];
      v44[2] = v36[10];
      v44[3] = v36[11];
      v44[4] = v36[12];
      v44[5] = v36[13];
      v44[6] = v36[14];
      v44[7] = v36[15];
      uint64_t v45 = (_DWORD *)(v42 + 32 * v5);
      *uint64_t v45 = v36[16];
      v45[1] = v36[17];
      int v46 = v36[18];
      v45[2] = v46;
      int v47 = v36[19];
      v45[3] = v47;
      v45[4] = v36[20];
      v45[5] = v36[21];
      v45[6] = v36[22];
      v45[7] = v36[23];
      v45[4] = v46;
      v45[5] = v47;
      goto LABEL_65;
    }
    if (v13 - 2 == a2)
    {
      __p = 0;
      float v58 = 0;
      unint64_t v59 = 0;
      std::vector<OMVertex>::push_back[abi:ne180100]((uint64_t *)&__p, &v6[8 * v5 - 16]);
      std::vector<OMVertex>::push_back[abi:ne180100]((uint64_t *)&__p, (_DWORD *)(*(void *)this + 32 * (v5 - 1)));
      std::vector<OMVertex>::push_back[abi:ne180100]((uint64_t *)&__p, (_DWORD *)(*(void *)this + 32 * v5));
      std::vector<OMVertex>::push_back[abi:ne180100]((uint64_t *)&__p, (_DWORD *)(*(void *)this + 32 * v14));
      std::vector<OMVertex>::push_back[abi:ne180100]((uint64_t *)&__p, (_DWORD *)(*(void *)this + 32 * v14));
      OMSpline::tangentsAuto((uint64_t)this, (uint64_t *)&__p, 0, 1, 2);
      OMSpline::tangentsAuto((uint64_t)this, (uint64_t *)&__p, 1, 2, 3);
      OMSpline::tangentsAuto((uint64_t)this, (uint64_t *)&__p, 2, 3, 4);
      unint64_t v36 = __p;
      uint64_t v52 = *(void *)this;
      unint64_t v53 = (_DWORD *)(*(void *)this + 32 * (v5 - 2));
      *unint64_t v53 = *(_DWORD *)__p;
      v53[1] = v36[1];
      v53[2] = v36[2];
      v53[3] = v36[3];
      v53[4] = v36[4];
      v53[5] = v36[5];
      v53[6] = v36[6];
      v53[7] = v36[7];
      uint64_t v54 = (_DWORD *)(v52 + 32 * (v5 - 1));
      _DWORD *v54 = v36[8];
      v54[1] = v36[9];
      v54[2] = v36[10];
      v54[3] = v36[11];
      float32x4_t v54[4] = v36[12];
      v54[5] = v36[13];
      v54[6] = v36[14];
      v54[7] = v36[15];
      uint64_t v55 = (_DWORD *)(v52 + 32 * v5);
      *uint64_t v55 = v36[16];
      v55[1] = v36[17];
      v55[2] = v36[18];
      v55[3] = v36[19];
      v55[4] = v36[20];
      v55[5] = v36[21];
      v55[6] = v36[22];
      v55[7] = v36[23];
      uint64_t v56 = (_DWORD *)(v52 + 32 * v14);
      *uint64_t v56 = v36[24];
      v56[1] = v36[25];
      v56[2] = v36[26];
      v56[3] = v36[27];
      float32x4_t v56[4] = v36[28];
      v56[5] = v36[29];
      v56[6] = v36[30];
      v56[7] = v36[31];
      goto LABEL_65;
    }
    OMSpline::tangentsAuto(this, a2 - 2, a2 - 1, a2);
    OMSpline::tangentsAuto(this, a2 - 1, a2, a2 + 1);
    uint64_t v32 = this;
    int v33 = a2;
    int v34 = a2 + 1;
    int v35 = a2 + 2;
  }
  else
  {
    if (a2 == 1)
    {
      int v25 = 0;
      int v27 = 3;
      int v26 = 2;
    }
    else
    {
      int v22 = v13 - 2;
      int v23 = a2 + 2;
      if (v22 == a2) {
        int v24 = (v12 >> 5) - 1;
      }
      else {
        int v24 = a2 + 1;
      }
      if (v22 == a2) {
        int v23 = 0;
      }
      if (v14 == a2)
      {
        int v24 = 0;
        int v23 = 1;
      }
      if (a2) {
        int v25 = a2 - 1;
      }
      else {
        int v25 = (v12 >> 5) - 1;
      }
      if (a2)
      {
        int v22 = a2 - 2;
        int v26 = v24;
      }
      else
      {
        int v26 = 1;
      }
      if (a2) {
        int v27 = v23;
      }
      else {
        int v27 = 2;
      }
      LODWORD(v14) = v22;
    }
    OMSpline::tangentsAuto(this, v14, v25, a2);
    OMSpline::tangentsAuto(this, v25, a2, v26);
    uint64_t v32 = this;
    int v33 = a2;
    int v34 = v26;
    int v35 = v27;
  }

  return OMSpline::tangentsAuto(v32, v33, v34, v35);
}

void sub_1B7A3A500(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<OMVertex>::push_back[abi:ne180100](uint64_t *a1, _DWORD *a2)
{
  unint64_t v3 = (_DWORD *)a1[1];
  if ((unint64_t)v3 >= a1[2])
  {
    uint64_t result = std::vector<OMVertex>::__push_back_slow_path<OMVertex>(a1, a2);
  }
  else
  {
    *unint64_t v3 = *a2;
    v3[1] = a2[1];
    v3[2] = a2[2];
    v3[3] = a2[3];
    v3[4] = a2[4];
    v3[5] = a2[5];
    v3[6] = a2[6];
    v3[7] = a2[7];
    uint64_t result = (uint64_t)(v3 + 8);
  }
  a1[1] = result;
  return result;
}

float OMSpline::tangentsAuto(uint64_t a1, uint64_t *a2, int a3, int a4, int a5)
{
  uint64_t v5 = *a2;
  uint64_t v6 = *a2 + 32 * a4;
  uint64_t v7 = *a2 + 32 * a3;
  float result = *(float *)(v6 + 8);
  float v9 = *(float *)(v6 + 12);
  float v11 = *(float *)(v7 + 8);
  float v10 = *(float *)(v7 + 12);
  float v12 = *(float *)(a1 + 28);
  uint64_t v13 = *a2 + 32 * a5;
  float v14 = *(float *)(v13 + 8);
  float v15 = *(float *)(v13 + 12);
  float v16 = v14 - v11;
  float v17 = v15 - v10;
  float v18 = sqrtf((float)(v16 * v16) + (float)(v17 * v17));
  if (v18 != 0.0)
  {
    float v19 = sqrtf((float)((float)(result - v11) * (float)(result - v11)) + (float)((float)(v9 - v10) * (float)(v9 - v10)))
        / v12;
    if (v19 != 0.0)
    {
      float32x2_t v20 = (float *)(v5 + 32 * a4);
      *float32x2_t v20 = result - (float)((float)(v16 * v19) / v18);
      v20[1] = v9 - (float)((float)(v17 * v19) / v18);
    }
  }
  if (v18 != 0.0)
  {
    float v21 = sqrtf((float)((float)(result - v14) * (float)(result - v14)) + (float)((float)(v9 - v15) * (float)(v9 - v15)))
        / v12;
    if (v21 != 0.0)
    {
      float result = result + (float)((float)(v16 * v21) / v18);
      uint64_t v22 = v5 + 32 * a4;
      *(float *)(v22 + 16) = result;
      *(float *)(v22 + 20) = v9 + (float)((float)(v17 * v21) / v18);
    }
  }
  return result;
}

float OMSpline::tangentsAuto(OMSpline *this, int a2, int a3, int a4)
{
  uint64_t v4 = *(void *)this;
  uint64_t v5 = *(void *)this + 32 * a3;
  uint64_t v6 = *(void *)this + 32 * a2;
  float result = *(float *)(v5 + 8);
  float v8 = *(float *)(v5 + 12);
  float v10 = *(float *)(v6 + 8);
  float v9 = *(float *)(v6 + 12);
  float v11 = *((float *)this + 7);
  uint64_t v12 = *(void *)this + 32 * a4;
  float v13 = *(float *)(v12 + 8);
  float v14 = *(float *)(v12 + 12);
  float v15 = v13 - v10;
  float v16 = v14 - v9;
  float v17 = sqrtf((float)(v15 * v15) + (float)(v16 * v16));
  if (v17 != 0.0)
  {
    float v18 = sqrtf((float)((float)(result - v10) * (float)(result - v10)) + (float)((float)(v8 - v9) * (float)(v8 - v9)))
        / v11;
    if (v18 != 0.0)
    {
      float v19 = (float *)(v4 + 32 * a3);
      float *v19 = result - (float)((float)(v15 * v18) / v17);
      v19[1] = v8 - (float)((float)(v16 * v18) / v17);
    }
  }
  if (v17 != 0.0)
  {
    float v20 = sqrtf((float)((float)(result - v13) * (float)(result - v13)) + (float)((float)(v8 - v14) * (float)(v8 - v14)))
        / v11;
    if (v20 != 0.0)
    {
      float result = result + (float)((float)(v15 * v20) / v17);
      uint64_t v21 = v4 + 32 * a3;
      *(float *)(v21 + 16) = result;
      *(float *)(v21 + 20) = v8 + (float)((float)(v16 * v20) / v17);
    }
  }
  return result;
}

void OMSpline::addVertexAtEnd(OMSpline *this, const Vec2f *a2)
{
  int v3 = *((_DWORD *)this + 6);
  if (v3)
  {
    if (v3 == 1)
    {
      uint64_t v5 = *(float **)this;
      uint64_t v4 = (float *)*((void *)this + 1);
      unint64_t v6 = ((unint64_t)v4 - *(void *)this) >> 5;
      if ((int)v6 < 2)
      {
        if (v6 == 1)
        {
          float v14 = a2->var0[0];
          float v15 = a2->var0[1];
          float v16 = (float)(a2->var0[0] - v5[2]) * 0.1;
          float v17 = (float)(v15 - v5[3]) * 0.1;
          float v18 = a2->var0[0] - v16;
          float v19 = a2->var0[0] + v16;
          *(float *)&unint64_t v27 = v18;
          *((float *)&v27 + 1) = v15 - v17;
          float v28 = v14;
          float v29 = v15;
          float v30 = v19;
          float v31 = v15 + v17;
          if ((unint64_t)v4 >= *((void *)this + 2))
          {
            uint64_t v20 = std::vector<OMVertex>::__push_back_slow_path<OMVertex>((uint64_t *)this, &v27);
            uint64_t v5 = *(float **)this;
          }
          else
          {
            float *v4 = v18;
            v4[1] = v15 - v17;
            v4[2] = v14;
            v4[3] = v15;
            uint64_t v20 = (uint64_t)(v4 + 8);
            v4[4] = v19;
            v4[5] = v15 + v17;
          }
          *((void *)this + 1) = v20;
          float v25 = v5[2];
          float v26 = v5[3];
          v5[4] = v16 + v25;
          v5[5] = v17 + v26;
          float *v5 = v25 - v16;
          v5[1] = v26 - v17;
        }
        else
        {
          float v22 = a2->var0[0];
          float v23 = a2->var0[1];
          unint64_t v27 = __PAIR64__(LODWORD(v23), LODWORD(v22));
          float v28 = v22;
          float v29 = v23;
          float v30 = v22;
          float v31 = v23;
          if ((unint64_t)v4 >= *((void *)this + 2))
          {
            uint64_t v24 = std::vector<OMVertex>::__push_back_slow_path<OMVertex>((uint64_t *)this, &v27);
          }
          else
          {
            float *v4 = v22;
            v4[1] = v23;
            v4[2] = v22;
            v4[3] = v23;
            uint64_t v24 = (uint64_t)(v4 + 8);
            v4[4] = v22;
            v4[5] = v23;
          }
          *((void *)this + 1) = v24;
        }
      }
      else
      {
        float v7 = a2->var0[0];
        float v8 = a2->var0[1];
        unint64_t v27 = __PAIR64__(LODWORD(v8), LODWORD(v7));
        float v28 = v7;
        float v29 = v8;
        float v30 = v7;
        float v31 = v8;
        if ((unint64_t)v4 >= *((void *)this + 2))
        {
          uint64_t v9 = std::vector<OMVertex>::__push_back_slow_path<OMVertex>((uint64_t *)this, &v27);
        }
        else
        {
          float *v4 = v7;
          v4[1] = v8;
          v4[2] = v7;
          v4[3] = v8;
          uint64_t v9 = (uint64_t)(v4 + 8);
          v4[4] = v7;
          v4[5] = v8;
        }
        *((void *)this + 1) = v9;
        if (*((unsigned char *)this + 32))
        {
          int v21 = ((unint64_t)(v9 - *(void *)this) >> 5) - 1;
          unint64_t v27 = 0;
          OMSpline::move(this, v21, (float *)&v27, 2u);
        }
      }
    }
  }
  else
  {
    float v10 = a2->var0[0];
    float v11 = a2->var0[1];
    float v32 = a2->var0[0];
    float v33 = v11;
    unint64_t v12 = *((void *)this + 1);
    if (v12 >= *((void *)this + 2))
    {
      uint64_t v13 = std::vector<OMVertex>::__push_back_slow_path<OMVertex>((uint64_t *)this, &v27);
    }
    else
    {
      *(float *)(v12 + 24) = v10;
      *(float *)(v12 + 28) = v11;
      uint64_t v13 = v12 + 32;
    }
    *((void *)this + 1) = v13;
    OMSpline::recomputeInternalBezier((uint64_t)this);
  }
}

void OMSpline::computeLinearArray(uint64_t *a1, uint64_t *a2, double a3, __n128 a4, float a5, float a6, float a7)
{
  float v10 = a4.n128_f32[0];
  float v11 = *(float *)&a3;
  uint64_t v14 = *a2;
  uint64_t v13 = a2[1];
  float v32 = 0;
  float v33 = 0;
  uint64_t v34 = 0;
  OMSpline::getCurveSamples(a1, (uint64_t)&v32, 64, 0, a3, a4);
  float v15 = v32;
  float v16 = v33;
  if (v32 != v33)
  {
    unint64_t v17 = (unint64_t)(v13 - v14) >> 2;
    if ((int)v17 > 0)
    {
      uint64_t v18 = 0;
      int v19 = 0;
      float v20 = v32[1];
      float v21 = *v32;
      uint64_t v22 = *a2;
      uint64_t v23 = (int)(((char *)v33 - (char *)v32) >> 3);
      float v24 = v11;
      float v25 = v20;
      do
      {
        float v26 = (float)((float)((float)(v10 - v11) * (float)(1.0 / (float)((int)v17 - 1))) * (float)(int)v18) + v11;
        if (v26 >= v21)
        {
          uint64_t v27 = (uint64_t)&v15[2 * v19 + 3];
          uint64_t v28 = v19 + 1;
          do
          {
            float v20 = v25;
            float v24 = v21;
            float v29 = &v15[2 * ((unint64_t)((char *)v16 - (char *)v15) >> 3) - 1];
            float v21 = v10 + 0.0001;
            if (v28 < v23)
            {
              float v21 = *(float *)(v27 - 4);
              float v29 = (float *)v27;
            }
            float v25 = *v29;
            ++v19;
            v27 += 8;
            ++v28;
          }
          while (v26 >= v21);
        }
        float v30 = v20 + (float)((float)((float)(v26 - v24) * (float)(v25 - v20)) / (float)(v21 - v24));
        float v31 = a5;
        if (v30 >= a5)
        {
          float v31 = a6;
          if (v30 <= a6) {
            float v31 = v30;
          }
        }
        *(float *)(v22 + 4 * v18++) = v31 * a7;
      }
      while (v18 != ((unint64_t)(v13 - v14) >> 2));
    }
  }
  if (v15)
  {
    float v33 = v15;
    operator delete(v15);
  }
}

void sub_1B7A3AAE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<OMVertex>::__push_back_slow_path<OMVertex>(uint64_t *a1, _DWORD *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (a1[1] - *a1) >> 5;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 59) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2] - v3;
  if (v8 >> 4 > v5) {
    unint64_t v5 = v8 >> 4;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v9 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  int v19 = a1 + 2;
  float v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<LiPolygon::PosEdge>>(v7, v9);
  float v11 = &v10[32 * v4];
  __p = v10;
  float v16 = v11;
  uint64_t v18 = &v10[32 * v12];
  *(_DWORD *)float v11 = *a2;
  *((_DWORD *)v11 + 1) = a2[1];
  *((_DWORD *)v11 + 2) = a2[2];
  *((_DWORD *)v11 + 3) = a2[3];
  *((_DWORD *)v11 + 4) = a2[4];
  *((_DWORD *)v11 + 5) = a2[5];
  *((_DWORD *)v11 + 6) = a2[6];
  *((_DWORD *)v11 + 7) = a2[7];
  unint64_t v17 = v11 + 32;
  std::vector<OMVertex>::__swap_out_circular_buffer(a1, &__p);
  uint64_t v13 = a1[1];
  if (v17 != v16) {
    v17 += (v16 - v17 + 31) & 0xFFFFFFFFFFFFFFE0;
  }
  if (__p) {
    operator delete(__p);
  }
  return v13;
}

void sub_1B7A3AC1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<OMVertex>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<OMVertex>,std::reverse_iterator<OMVertex*>,std::reverse_iterator<OMVertex*>,std::reverse_iterator<OMVertex*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v4;
  uint64_t v5 = *a1;
  *a1 = v4;
  a2[1] = v5;
  uint64_t v6 = a1[1];
  a1[1] = a2[2];
  a2[2] = v6;
  uint64_t v7 = a1[2];
  a1[2] = a2[3];
  a2[3] = v7;
  *a2 = a2[1];
}

float std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<OMVertex>,std::reverse_iterator<OMVertex*>,std::reverse_iterator<OMVertex*>,std::reverse_iterator<OMVertex*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  if (a3 != a5)
  {
    uint64_t v8 = a7 - 16;
    do
    {
      int v9 = *(_DWORD *)(a3 - 32);
      a3 -= 32;
      *(_DWORD *)(v8 - 16) = v9;
      *(_DWORD *)(v8 - 12) = *(_DWORD *)(a3 + 4);
      *(_DWORD *)(v8 - 8) = *(_DWORD *)(a3 + 8);
      *(_DWORD *)(v8 - 4) = *(_DWORD *)(a3 + 12);
      *(_DWORD *)uint64_t v8 = *(_DWORD *)(a3 + 16);
      *(_DWORD *)(v8 + 4) = *(_DWORD *)(a3 + 20);
      *(_DWORD *)(v8 + 8) = *(_DWORD *)(a3 + 24);
      float result = *(float *)(a3 + 28);
      *(float *)(v8 + 12) = result;
      v8 -= 32;
      v7 -= 32;
    }
    while (a3 != a5);
  }
  return result;
}

uint64_t LiHeEquirectProject::setCanTile(uint64_t this, char a2)
{
  *(unsigned char *)(this + 424) = a2;
  return this;
}

float LiHeEquirectProject::computeDistanceToImagePlane(LiHeEquirectProject *this, float a2, float a3)
{
  return (float)(a2 * 0.5) / tanf(a3 * 0.5);
}

uint64_t LiHeEquirectProject::GetDOD(float32x2_t *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (!this[53].i8[0]) {
    return 0x8000000080000000;
  }
  uint64_t v4 = *(void *)&a4.var0;
  (*(void (**)(float32x2_t *, uint64_t, _OWORD *))(*(void *)this + 104))(this, 6, v18);
  long long v6 = v18[0];
  (*(void (**)(float32x2_t *, uint64_t, _OWORD *))(*(void *)this + 104))(this, 7, v18);
  float32x2_t v7 = *(float32x2_t *)((char *)v18 + 8);
  __asm { FMOV            V3.2D, #-0.5 }
  float64x2_t v13 = vcvtq_f64_f32(this[52]);
  float64x2_t v16 = vmulq_f64(v13, _Q3);
  float64x2_t v17 = v13;
  v18[1] = vcvtq_f64_f32(*(float32x2_t *)((char *)&v6 + 8));
  float64x2_t v14 = vcvtq_f64_f32(*(float32x2_t *)&v18[0]);
  v18[0] = vcvtq_f64_f32(*(float32x2_t *)&v6);
  v18[2] = v14;
  v18[3] = vcvtq_f64_f32(v7);
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v21 = 0x3FF0000000000000;
  long long v22 = 0u;
  long long v23 = 0u;
  uint64_t v24 = 0x3FF0000000000000;
  if (PCMatrix44Tmpl<double>::invert((double *)v18, (double *)v18, 0.0))
  {
    PCMatrix44Tmpl<double>::transformRect<double>((double *)v18, v16.f64, (uint64_t)&v16);
    return HGRectMake4i(vcvtmd_s64_f64(v16.f64[0]), vcvtmd_s64_f64(v16.f64[1]), vcvtpd_s64_f64(v16.f64[0] + v17.f64[0]), vcvtpd_s64_f64(v16.f64[1] + v17.f64[1]));
  }
  else
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"Unable to invert image to pixel space transform in LiHeEquirectProject::GetDOD()\n", 81);
  }
  return v4;
}

uint64_t LiHeEquirectProject::GetROI(LiHeEquirectProject *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var2;
  unint64_t v5 = *(void *)&a4.var0;
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  (*(void (**)(LiHeEquirectProject *, void, long long *))(*(void *)this + 104))(this, 0, &v66);
  LODWORD(v46) = v66;
  (*(void (**)(LiHeEquirectProject *, uint64_t, long long *))(*(void *)this + 104))(this, 1, &v66);
  LODWORD(v47) = v66;
  (*(void (**)(LiHeEquirectProject *, uint64_t, long long *))(*(void *)this + 104))(this, 2, &v66);
  float v7 = *(float *)&v66;
  (*(void (**)(LiHeEquirectProject *, uint64_t, long long *))(*(void *)this + 104))(this, 3, &v66);
  uint64_t v64 = v66;
  int v65 = DWORD2(v66);
  (*(void (**)(LiHeEquirectProject *, uint64_t, long long *))(*(void *)this + 104))(this, 4, &v66);
  uint64_t v62 = v66;
  int v63 = DWORD2(v66);
  (*(void (**)(LiHeEquirectProject *, uint64_t, long long *))(*(void *)this + 104))(this, 5, &v66);
  uint64_t v60 = v66;
  int v61 = DWORD2(v66);
  (*(void (**)(LiHeEquirectProject *, uint64_t, long long *))(*(void *)this + 104))(this, 6, &v66);
  long long v59 = v66;
  (*(void (**)(LiHeEquirectProject *, uint64_t, long long *))(*(void *)this + 104))(this, 7, &v66);
  long long v58 = v66;
  (*(void (**)(LiHeEquirectProject *, uint64_t, long long *))(*(void *)this + 104))(this, 8, &v66);
  long long v8 = v66;
  long long v57 = v66;
  (*(void (**)(LiHeEquirectProject *, uint64_t, long long *))(*(void *)this + 104))(this, 9, &v66);
  long long v9 = v66;
  long long v56 = v66;
  if (!*((unsigned char *)this + 424))
  {
    __asm { FMOV            V5.2D, #-0.5 }
    float64x2_t v53 = vmulq_f64(vcvtq_f64_f32((float32x2_t)__PAIR64__(LODWORD(v47), LODWORD(v46))), _Q5);
    double v54 = v46;
    double v55 = v47;
    *(double *)&long long v66 = *(float *)&v8;
    *((double *)&v66 + 1) = *((float *)&v8 + 1);
    double v67 = *((float *)&v8 + 2);
    double v68 = *((float *)&v8 + 3);
    double v69 = *(float *)&v9;
    double v70 = *((float *)&v9 + 1);
    double v71 = *((float *)&v9 + 2);
    double v72 = *((float *)&v9 + 3);
    uint64_t v73 = 0;
    uint64_t v74 = 0;
    long long v76 = 0u;
    long long v77 = 0u;
    uint64_t v75 = 0x3FF0000000000000;
    uint64_t v78 = 0x3FF0000000000000;
    if (PCMatrix44Tmpl<double>::transformRect<double>((double *)&v66, v53.f64, (uint64_t)&v53)) {
      return HGRectMake4i(vcvtmd_s64_f64(v53.f64[0]), vcvtmd_s64_f64(v53.f64[1]), vcvtpd_s64_f64(v53.f64[0] + v54), vcvtpd_s64_f64(v53.f64[1] + v55));
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"Unable to transform rect. Using default ROI.\n", 45);
    return HGRectMake4i((int)(floor(v46 * -0.5) + -1.0), (int)(floor(v47 * -0.5) + -2.0), (int)(ceil(v46 * 0.5) + 1.0), (int)(ceil(v47 * 0.5) + 1.0));
  }
  long long v66 = xmmword_1B7E74760;
  if (SHIDWORD(v5) <= SHIDWORD(v4))
  {
    unint64_t v10 = HIDWORD(v5);
    do
    {
      getROIPoint((float *)&v64, (float *)&v62, (float *)&v60, (float *)&v59, (float *)&v58, (float *)&v57, (float *)&v56, (int32x2_t *)&v53, (float)(int)v5, (float)(int)v10, v46, v47, v7);
      PCRect<int>::operator|=((int32x2_t *)&v66, (int32x2_t *)&v53);
      getROIPoint((float *)&v64, (float *)&v62, (float *)&v60, (float *)&v59, (float *)&v58, (float *)&v57, (float *)&v56, v52, (float)(int)v4, (float)(int)v10, v46, v47, v7);
      PCRect<int>::operator|=((int32x2_t *)&v66, v52);
      LODWORD(v10) = v10 + 1;
    }
    while (HIDWORD(v4) + 1 != v10);
  }
  float v11 = (float)SHIDWORD(v5);
  float v12 = (float)SHIDWORD(v4);
  if ((int)v5 <= (int)v4)
  {
    int v13 = v5;
    do
    {
      getROIPoint((float *)&v64, (float *)&v62, (float *)&v60, (float *)&v59, (float *)&v58, (float *)&v57, (float *)&v56, (int32x2_t *)&v53, (float)v13, v11, v46, v47, v7);
      PCRect<int>::operator|=((int32x2_t *)&v66, (int32x2_t *)&v53);
      getROIPoint((float *)&v64, (float *)&v62, (float *)&v60, (float *)&v59, (float *)&v58, (float *)&v57, (float *)&v56, v52, (float)v13, v12, v46, v47, v7);
      PCRect<int>::operator|=((int32x2_t *)&v66, v52);
      ++v13;
    }
    while (v4 + 1 != v13);
  }
  getLatLong((float *)&v64, (float *)&v62, (float *)&v60, (float *)&v59, (float *)&v58, (float *)&v53, (float)(int)v5, v11, v7);
  getLatLong((float *)&v64, (float *)&v62, (float *)&v60, (float *)&v59, (float *)&v58, (float *)v52, (float)(int)v4, v11, v7);
  getLatLong((float *)&v64, (float *)&v62, (float *)&v60, (float *)&v59, (float *)&v58, &v50, (float)(int)v4, v12, v7);
  getLatLong((float *)&v64, (float *)&v62, (float *)&v60, (float *)&v59, (float *)&v58, &v48, (float)(int)v5, v12, v7);
  float v14 = *(float *)v52[0].i32 - *(float *)v53.f64;
  double v15 = (float)(*(float *)v52[0].i32 - *(float *)v53.f64);
  if (v15 <= 3.14159265)
  {
    if (v15 >= -3.14159265) {
      goto LABEL_15;
    }
    double v16 = 6.28318531;
  }
  else
  {
    double v16 = -6.28318531;
  }
  float v14 = v15 + v16;
LABEL_15:
  float v23 = v50 - *(float *)v52[0].i32;
  double v24 = (float)(v50 - *(float *)v52[0].i32);
  if (v24 <= 3.14159265)
  {
    if (v24 >= -3.14159265) {
      goto LABEL_20;
    }
    double v25 = 6.28318531;
  }
  else
  {
    double v25 = -6.28318531;
  }
  float v23 = v24 + v25;
LABEL_20:
  float v26 = v48 - v50;
  double v27 = (float)(v48 - v50);
  if (v27 <= 3.14159265)
  {
    if (v27 >= -3.14159265) {
      goto LABEL_25;
    }
    double v28 = 6.28318531;
  }
  else
  {
    double v28 = -6.28318531;
  }
  float v26 = v27 + v28;
LABEL_25:
  float v29 = *(float *)v53.f64 - v48;
  double v30 = (float)(*(float *)v53.f64 - v48);
  if (v30 <= 3.14159265)
  {
    if (v30 >= -3.14159265) {
      goto LABEL_30;
    }
    double v31 = 6.28318531;
  }
  else
  {
    double v31 = -6.28318531;
  }
  float v29 = v30 + v31;
LABEL_30:
  double v32 = (float)((float)((float)(v14 + v23) + v26) + v29);
  if (v32 > 3.14159265 || v32 < -3.14159265)
  {
    float v33 = *((float *)v53.f64 + 1);
    if (*((float *)v53.f64 + 1) >= *(float *)&v52[0].i32[1]) {
      float v34 = *((float *)v53.f64 + 1);
    }
    else {
      float v34 = *(float *)&v52[0].i32[1];
    }
    if (v34 < v51) {
      float v34 = v51;
    }
    if (v34 < v49) {
      float v34 = v49;
    }
    if (*(float *)&v52[0].i32[1] < *((float *)v53.f64 + 1)) {
      float v33 = *(float *)&v52[0].i32[1];
    }
    if (v51 < v33) {
      float v33 = v51;
    }
    if (v49 < v33) {
      float v33 = v49;
    }
    if (3.14159265 - v34 <= v33)
    {
      HIDWORD(v66) += DWORD1(v66) + 1;
      DWORD1(v66) = -1;
    }
    else
    {
      signed int v35 = vcvtps_s32_f32(v47);
      if (HIDWORD(v66) + DWORD1(v66) > v35) {
        signed int v35 = HIDWORD(v66) + DWORD1(v66);
      }
      HIDWORD(v66) = v35 - DWORD1(v66) + 1;
    }
  }
  if (*((unsigned char *)this + 424))
  {
    BOOL v36 = v49 < 4.0;
    float v37 = v47 + -4.0;
    if (v49 > (float)(v47 + -4.0)) {
      BOOL v36 = 1;
    }
    BOOL v38 = v51 < 4.0;
    if (v51 > v37) {
      BOOL v38 = 1;
    }
    BOOL v39 = *(float *)&v52[0].i32[1] < 4.0;
    if (*(float *)&v52[0].i32[1] > v37) {
      BOOL v39 = 1;
    }
    BOOL v40 = *((float *)v53.f64 + 1) < 4.0;
    if (*((float *)v53.f64 + 1) > v37) {
      BOOL v40 = 1;
    }
    unsigned int v41 = v38 + v36 + v39 + v40;
    int v42 = v66;
    int v43 = DWORD2(v66);
    if (v41 >= 2)
    {
      int v44 = DWORD2(v66) + v66;
      int v45 = vcvtps_s32_f32(v46);
      int v42 = -1;
      if (DWORD2(v66) + (int)v66 <= v45) {
        int v44 = v45;
      }
      int v43 = v44 + 2;
      LODWORD(v66) = -1;
      DWORD2(v66) = v43;
    }
  }
  else
  {
    int v42 = v66;
    int v43 = DWORD2(v66);
  }
  return HGRectMake4i((int)(float)((float)v42 + -5.0), (int)(float)((float)SDWORD1(v66) + -5.0), (int)(float)((float)(v43 + v42) + 5.0), (int)(float)((float)(HIDWORD(v66) + DWORD1(v66)) + 5.0));
}

int32x2_t *getROIPoint@<X0>(float *a1@<X0>, float *a2@<X1>, float *a3@<X2>, float *a4@<X3>, float *a5@<X4>, float *a6@<X5>, float *a7@<X6>, int32x2_t *a8@<X8>, float a9@<S0>, float a10@<S1>, float a11@<S2>, float a12@<S3>, float a13@<S4>)
{
  getLatLong(a1, a2, a3, a4, a5, v50, a9, a10, a13);
  float v18 = (float)(v50[0] * a11) / 6.28318531;
  float v19 = a12 * 0.5 + (float)(v50[1] * a12) / -3.14159265;
  float v20 = a11 * 0.5;
  float v21 = fmodf((float)(a11 * 0.5) + (float)((float)(floorf(v18 + -0.5) + 0.5) + -0.5), a11);
  if (v21 >= 0.0) {
    float v22 = -0.0;
  }
  else {
    float v22 = a11;
  }
  float v23 = (float)((float)(v21 + v22) + 0.5) - v20;
  float v24 = fmodf(v20 + (float)((float)(v23 + 1.0) + -0.5), a11);
  if (v24 >= 0.0) {
    float v25 = -0.0;
  }
  else {
    float v25 = a11;
  }
  float v26 = (float)((float)(v24 + v25) + 0.5) - v20;
  float v27 = floorf(v19 + -0.5) + 0.5;
  float v28 = 0.5 - (float)(a12 * 0.5);
  float v29 = (float)(a12 * 0.5) + -0.5;
  if (v29 >= v27) {
    float v30 = v27;
  }
  else {
    float v30 = (float)(a12 * 0.5) + -0.5;
  }
  if (v28 <= v27) {
    float v31 = v30;
  }
  else {
    float v31 = 0.5 - (float)(a12 * 0.5);
  }
  if (v29 >= (float)(v31 + 1.0)) {
    float v29 = v31 + 1.0;
  }
  if (v28 > (float)(v31 + 1.0)) {
    float v29 = 0.5 - (float)(a12 * 0.5);
  }
  float v32 = a6[1];
  float v33 = *a6 * v23;
  float v34 = v31 * v32;
  float v35 = a6[3];
  float32_t v36 = v35 + (float)(v33 + (float)(v31 * v32));
  float v37 = a7[1];
  float v38 = v23 * *a7;
  float v39 = v31 * v37;
  float v40 = a7[3];
  float v41 = v32 * v29;
  float v42 = v29 * v37;
  float v43 = *a6 * v26;
  float v44 = *a7 * v26;
  v49.f32[0] = v36;
  v49.f32[1] = v40 + (float)(v38 + v39);
  v48.f32[0] = v35 + (float)(v33 + v41);
  v48.f32[1] = v40 + (float)(v38 + v42);
  v47.f32[0] = v35 + (float)(v34 + v43);
  v47.f32[1] = v40 + (float)(v39 + v44);
  v46.f32[0] = v35 + (float)(v41 + v43);
  v46.f32[1] = v40 + (float)(v42 + v44);
  *(_OWORD *)a8->i8 = xmmword_1B7E74760;
  addToRect(&v49, a8);
  addToRect(&v48, a8);
  addToRect(&v47, a8);
  return addToRect(&v46, a8);
}

void getLatLong(float *a1@<X0>, float *a2@<X1>, float *a3@<X2>, float *a4@<X3>, float *a5@<X4>, float *a6@<X8>, float a7@<S0>, float a8@<S1>, float a9@<S2>)
{
  float v9 = a9;
  float v11 = a4[3] + (float)(a4[2] + (float)((float)(*a4 * a7) + (float)(a4[1] * a8)));
  float v12 = a5[3] + (float)(a5[2] + (float)((float)(*a5 * a7) + (float)(a5[1] * a8)));
  float v13 = sqrtf((float)(v9 * v9) + (float)((float)(v11 * v11) + (float)(v12 * v12)));
  if (v13 <= -0.00001 || v13 >= 0.00001)
  {
    float v11 = v11 / v13;
    float v12 = v12 / v13;
    float v9 = a9 / v13;
  }
  float v14 = (float)((float)(v11 * *a1) + (float)(v12 * a1[1])) + (float)(v9 * a1[2]);
  float v15 = *a2;
  float v16 = a2[1];
  float v17 = a2[2];
  float v18 = (float)((float)(v11 * *a3) + (float)(v12 * a3[1])) + (float)(v9 * a3[2]);
  if (v18 <= -0.00001 || v18 >= 0.00001) {
    float v19 = atan2f(v14, v18);
  }
  else {
    float v19 = flt_1B837ADB0[v14 < 0.0];
  }
  float v20 = acosf((float)((float)(v11 * v15) + (float)(v12 * v16)) + (float)(v9 * v17));
  *a6 = v19;
  a6[1] = v20;
}

void LiHeEquirectProject::~LiHeEquirectProject(HGNode *this)
{
  LiHgcEquirectProject::~LiHgcEquirectProject(this);

  HGObject::operator delete(v1);
}

int32x2_t *addToRect(float32x2_t *a1, int32x2_t *a2)
{
  int32x2_t v5 = vcvt_s32_f32(vrndm_f32(*a1));
  PCRect<int>::operator|=(a2, &v5);
  int32x2_t v5 = vcvt_s32_f32(vrndp_f32(*a1));
  return PCRect<int>::operator|=(a2, &v5);
}

int32x2_t *PCRect<int>::operator|=(int32x2_t *result, int32x2_t *a2)
{
  __int32 v2 = result[1].i32[0];
  if (v2 < 0 || (__int32 v3 = result[1].i32[1], v3 < 0))
  {
    int32x2_t v5 = 0;
    int32x2_t v4 = *a2;
  }
  else
  {
    int32x2_t v4 = vmin_s32(*result, *a2);
    int32x2_t v5 = vsub_s32(vmax_s32(vadd_s32((int32x2_t)__PAIR64__(v3, v2), *result), *a2), v4);
  }
  *float result = v4;
  result[1] = v5;
  return result;
}

__n128 OMPie::moveAll(OMPie *this, const Vec2f *a2)
{
  uint64_t v3 = *((void *)this + 5);
  if (*((_DWORD *)this + 8))
  {
    result.n128_u32[0] = *(_DWORD *)(v3 + 4);
    float v6 = *(float *)(v3 + 16);
    float v5 = *(float *)(v3 + 20);
    float v8 = *(float *)(v3 + 8);
    float v7 = *(float *)(v3 + 12);
    float v9 = a2->var0[0] + *(float *)v3;
LABEL_3:
    *(float *)uint64_t v3 = v9;
    *(float *)(v3 + 4) = a2->var0[1] + result.n128_f32[0];
    *(float *)(v3 + 16) = a2->var0[0] + v6;
    *(float *)(v3 + 20) = a2->var0[1] + v5;
    *(float *)(v3 + 8) = a2->var0[0] + v8;
    *(float *)(v3 + 12) = a2->var0[1] + v7;
    if (OMPie::isQuadActive(this))
    {
      float v10 = *(float *)(v3 + 36);
      *(float *)(v3 + 32) = a2->var0[0] + *(float *)(v3 + 32);
      *(float *)(v3 + 36) = a2->var0[1] + v10;
      float v11 = *(float *)(v3 + 28);
      *(float *)(v3 + 24) = a2->var0[0] + *(float *)(v3 + 24);
      result.n128_f32[0] = a2->var0[1] + v11;
      *(_DWORD *)(v3 + 28) = result.n128_u32[0];
    }
    else
    {
      result.n128_u64[0] = *(void *)(v3 + 8);
      result.n128_u64[1] = result.n128_u64[0];
      *(__n128 *)(v3 + 24) = result;
    }
    return result;
  }
  result.n128_u32[0] = *(_DWORD *)(v3 + 4);
  float v12 = a2->var0[0];
  float v13 = a2->var0[1];
  float v9 = *(float *)v3 + a2->var0[0];
  if (sqrtf((float)(v9 * v9) + (float)((float)(result.n128_f32[0] + v13) * (float)(result.n128_f32[0] + v13))) <= 1.0)
  {
    float v8 = *(float *)(v3 + 8);
    float v7 = *(float *)(v3 + 12);
    if (sqrtf((float)((float)(v8 + v12) * (float)(v8 + v12)) + (float)((float)(v7 + v13) * (float)(v7 + v13))) <= 1.0)
    {
      float v6 = *(float *)(v3 + 16);
      float v5 = *(float *)(v3 + 20);
      if (sqrtf((float)((float)(v6 + v12) * (float)(v6 + v12)) + (float)((float)(v5 + v13) * (float)(v5 + v13))) <= 1.0) {
        goto LABEL_3;
      }
    }
  }
  return result;
}

BOOL OMPie::isQuadActive(OMPie *this)
{
  uint64_t v1 = *((void *)this + 5);
  float v3 = *(float *)(v1 + 8);
  float v2 = *(float *)(v1 + 12);
  if (sqrtf((float)(v3 * v3) + (float)(v2 * v2)) >= 0.00002) {
    return 0;
  }
  float v4 = *(float *)(v1 + 28);
  BOOL v5 = v3 == *(float *)(v1 + 24) && v2 == v4;
  if (v5 && v3 == *(float *)(v1 + 32) && v2 == *(float *)(v1 + 36)) {
    return 0;
  }
  v9[0] = *(float *)(v1 + 24);
  v9[1] = v4;
  v9[2] = *(float *)v1;
  v9[3] = *(float *)(v1 + 4);
  *(void *)&long long v6 = *(void *)(v1 + 32);
  *((void *)&v6 + 1) = *(void *)(v1 + 16);
  long long v8 = v6;
  return !OMUtil::findIntersectionOfLineSegmentExclusive(v9, (float *)&v8);
}

uint64_t OMPie::moveAroundArc(OMPie *this, float32x2_t *a2, Vec2f *a3)
{
  float32x2_t v5 = *(float32x2_t *)(*((void *)this + 5) + 8);
  float v6 = v5.f32[1];
  int32x2_t v29 = (int32x2_t)v5;
  if (v5.f32[0] == 0.0 && v5.f32[1] == 0.0)
  {
    float32x2_t v7 = vsub_f32(*a2, v5);
    Vec2f v30 = (Vec2f)1065353216;
    float32x2_t v31 = v7;
    float v8 = OMUtil::angle((OMUtil *)&v31, &v30, a3);
    if ((float)((float)(v31.f32[0] * v30.var0[1]) - (float)(v31.f32[1] * v30.var0[0])) < 0.0) {
      float v8 = 6.2832 - v8;
    }
    __float2 v9 = __sincosf_stret(v8);
    uint64_t result = 0;
    float v11 = sqrtf((float)((float)(a3->var0[0] - *(float *)v29.i32) * (float)(a3->var0[0] - *(float *)v29.i32))+ (float)((float)(a3->var0[1] - v6) * (float)(a3->var0[1] - v6)));
    float v12 = *(float *)v29.i32 + (float)(v9.__cosval * v11);
    float v13 = v6 - (float)(v9.__sinval * v11);
  }
  else
  {
    float32x2_t v14 = vsub_f32(*a2, v5);
    Vec2f v30 = (Vec2f)vsub_f32(0, v5);
    float32x2_t v31 = v14;
    float v15 = OMUtil::angle((OMUtil *)&v31, &v30, a3);
    if ((float)((float)(v31.f32[0] * v30.var0[1]) - (float)(v31.f32[1] * v30.var0[0])) >= 0.0) {
      float v16 = v15;
    }
    else {
      float v16 = 6.2832 - v15;
    }
    float32x2_t v17 = (float32x2_t)vdup_lane_s32(v29, 0);
    v17.i32[0] = LODWORD(a3->var0[0]);
    v18.i32[1] = v29.i32[1];
    v18.i32[0] = LODWORD(a3->var0[1]);
    float32x2_t v19 = vsqrt_f32(vadd_f32(vmul_f32(v17, v17), vmul_f32(v18, v18)));
    float v27 = v19.f32[1];
    float32x2_t v28 = vmul_f32(v19, v19);
    float v20 = vmuls_lane_f32(cosf(v16 + v16), v28, 1) + v28.f32[0];
    __float2 v21 = __sincosf_stret(v16);
    float v22 = sqrtf(v20+ (float)((float)((float)(v27 + v27) * v21.__cosval)* sqrtf(v28.f32[0] - vmuls_lane_f32(v21.__sinval * v21.__sinval, v28, 1))));
    float32x2_t v23 = vsub_f32(*a2, (float32x2_t)v29);
    Vec2f v30 = (Vec2f)1065353216;
    float32x2_t v31 = v23;
    float v25 = OMUtil::angle((OMUtil *)&v31, &v30, v24);
    if ((float)((float)(v31.f32[0] * v30.var0[1]) - (float)(v31.f32[1] * v30.var0[0])) < 0.0) {
      float v25 = 6.2832 - v25;
    }
    __float2 v26 = __sincosf_stret(v25);
    float v12 = *(float *)v29.i32 + (float)(v22 * v26.__cosval);
    float v13 = v6 - (float)(v22 * v26.__sinval);
    uint64_t result = 0;
  }
  a3->var0[0] = v12;
  a3->var0[1] = v13;
  return result;
}

void OMPie::computeArc(OMPie *this, uint64_t a2, const Vec2f *a3)
{
  OMPie::computeArcIn(this, a2, a3);

  OMPie::computeArcOut(this, v4, v5);
}

void OMPie::getArcIn(OMPie *this@<X0>, float a2@<S0>, float *a3@<X8>)
{
  if (!OMPie::isQuadActive(this)) {
    goto LABEL_7;
  }
  int v6 = *((_DWORD *)this + 8);
  if (v6 == 1)
  {
    float v16 = *((float *)this + 4);
    float v8 = 1.0 - a2;
    if (v16 != 0.0)
    {
      float v17 = *((float *)this + 5);
      if (v17 != 0.0)
      {
        float v18 = *((float *)this + 6) + (float)(*((float *)this + 7) * a2);
        float v19 = (float)(v8 * v16) + (float)(v17 * a2);
        __float2 v20 = __sincosf_stret(v18);
        uint64_t v21 = *((void *)this + 5);
        float v22 = *(float *)(v21 + 12);
        *a3 = *(float *)(v21 + 8) + (float)(v19 * v20.__cosval);
        float v14 = (float)(v19 * v20.__sinval) + v22;
        goto LABEL_9;
      }
    }
LABEL_13:
    float32x2_t v23 = (float *)*((void *)this + 5);
    float v24 = v23[7] * a2;
    float v25 = v8 * v23[8];
    float v26 = v8 * v23[9];
    *a3 = (float)(v23[6] * a2) + v25;
    float v14 = v24 + v26;
    goto LABEL_9;
  }
  if (v6)
  {
LABEL_7:
    uint64_t v15 = *((void *)this + 5);
    float v13 = *(float *)(v15 + 8);
    float v14 = *(float *)(v15 + 12);
    goto LABEL_8;
  }
  float v7 = *((float *)this + 4);
  float v8 = 1.0 - a2;
  if (v7 == 0.0) {
    goto LABEL_13;
  }
  float v9 = *((float *)this + 5);
  if (v9 == 0.0) {
    goto LABEL_13;
  }
  float v10 = *((float *)this + 6) + (float)(*((float *)this + 7) * a2);
  float v11 = (float)(v8 * v7) + (float)(v9 * a2);
  __float2 v12 = __sincosf_stret(v10);
  float v13 = v11 * v12.__cosval;
  float v14 = v11 * v12.__sinval;
LABEL_8:
  *a3 = v13;
LABEL_9:
  a3[1] = v14;
}

void OMPie::getArcOut(float32x2_t **this@<X0>, float a2@<S0>, float32x2_t *a3@<X8>)
{
  float v4 = 1.0 - a2;
  if (*(float *)this == 0.0 || (float v5 = *((float *)this + 1), v5 == 0.0))
  {
    float32x2_t v7 = vadd_f32(vmul_n_f32(*this[5], a2), vmul_n_f32(this[5][2], v4));
  }
  else
  {
    float v8 = (float)(v4 * *(float *)this) + (float)(v5 * a2);
    __float2 v6 = __sincosf_stret(*((float *)this + 2) + (float)(*((float *)this + 3) * a2));
    float32x2_t v7 = vmul_n_f32((float32x2_t)__PAIR64__(LODWORD(v6.__sinval), LODWORD(v6.__cosval)), v8);
  }
  *a3 = v7;
}

void OMPie::move(OMPie *this, int *a2, Vec2f *a3, float32x2_t *a4)
{
  int v7 = *a2;
  switch(*a2)
  {
    case 0:
      float v16 = (float *)*((void *)this + 5);
      if (*((_DWORD *)this + 8))
      {
        float v17 = v16[1];
        float v18 = a4->f32[0] + *v16;
      }
      else
      {
        float v17 = v16[1];
        float v18 = *v16 + a4->f32[0];
        if (sqrtf((float)(v18 * v18) + (float)((float)(v17 + a4->f32[1]) * (float)(v17 + a4->f32[1]))) > 1.0) {
          return;
        }
      }
      float *v16 = v18;
      v16[1] = a4->f32[1] + v17;
      return;
    case 1:
    case 8:
      uint64_t v9 = *((void *)this + 5);
      *(Vec2f *)(v9 + 8) = *a3;
      OMPie::computeArcIn(this, (uint64_t)a2, a3);
      OMPie::computeArcOut(this, v10, v11);
      OMPie::getArcOut((float32x2_t **)this, 0.5, &v83);
      *(float32x2_t *)v12.f32 = vsub_f32(*(float32x2_t *)(v9 + 16), *(float32x2_t *)v9);
      v12.i64[1] = v12.i64[0];
      float32x4_t v82 = vmulq_f32(v12, (float32x4_t)xmmword_1B837AD80);
      v12.i64[0] = *(void *)(v9 + 8);
      *(float32x2_t *)&v12.u32[2] = v83;
      float32x2_t v80 = v83;
      float32x4_t v81 = v12;
      if (OMUtil::findIntersectionOfLineSegment(v82.f32, v81.f32))
      {
        int v14 = *(_DWORD *)(v9 + 8);
        float v13 = *(float *)(v9 + 12);
        *(_DWORD *)(v9 + 32) = v14;
        *(float *)(v9 + 36) = v13;
        *(_DWORD *)(v9 + 24) = v14;
        uint64_t v15 = 3;
      }
      else
      {
        float v19 = sqrtf(vmul_f32(v80, v80).f32[0] + vmuls_lane_f32(v80.f32[1], v80, 1));
        float v20 = (float)((float)(v80.f32[0] / v19) * a3->var0[0]) + (float)((float)(v80.f32[1] / v19) * a3->var0[1]);
        *(void *)(v9 + 8) = 0;
        float v21 = *(float *)v9;
        float v22 = *(float *)(v9 + 4);
        float v23 = sqrtf((float)(v21 * v21) + (float)(v22 * v22));
        float v24 = v20 * (float)(*(float *)v9 / v23);
        float v25 = v20 * (float)(v22 / v23);
        float v26 = *(float *)(v9 + 16);
        float v13 = *(float *)(v9 + 20);
        if (sqrtf((float)(v24 * v24) + (float)(v25 * v25)) >= v23
          || (float v27 = sqrtf((float)(v26 * v26) + (float)(v13 * v13)),
              float v28 = v20 * (float)(v26 / v27),
              float v29 = v20 * (float)(v13 / v27),
              sqrtf((float)(v28 * v28) + (float)(v29 * v29)) >= v27))
        {
          *(float *)(v9 + 24) = v21;
          *(float *)(v9 + 28) = v22;
          uint64_t v15 = 4;
          *(float *)(v9 + 32) = v26;
        }
        else
        {
          *(float *)(v9 + 24) = v24;
          *(float *)(v9 + 28) = v25;
          uint64_t v15 = 4;
          float v13 = v29;
          *(float *)(v9 + 32) = v28;
        }
      }
      *(float *)(v9 + 8 * v15 + 4) = v13;
      int v7 = *a2;
      goto LABEL_15;
    case 2:
      uint64_t v30 = *((void *)this + 5);
      if (*((_DWORD *)this + 8))
      {
        float v31 = *(float *)(v30 + 20);
        float v32 = a4->f32[0] + *(float *)(v30 + 16);
      }
      else
      {
        float v31 = *(float *)(v30 + 20);
        float v32 = *(float *)(v30 + 16) + a4->f32[0];
        if (sqrtf((float)(v32 * v32) + (float)((float)(v31 + a4->f32[1]) * (float)(v31 + a4->f32[1]))) > 1.0) {
          return;
        }
      }
      *(float *)(v30 + 16) = v32;
      *(float *)(v30 + 20) = a4->f32[1] + v31;
      return;
    case 9:
      *a2 = 11;
LABEL_18:
      float32_t v36 = (float *)*((void *)this + 5);
      OMPie::computeArcIn(this, (uint64_t)a2, a3);
      OMPie::computeArcOut(this, v37, v38);
      OMPie::getArcOut((float32x2_t **)this, 0.5, (float32x2_t *)&v82);
      uint64_t v39 = v82.i64[0];
      float v40 = sqrtf((float)(a3->var0[0] * a3->var0[0]) + (float)(a3->var0[1] * a3->var0[1]));
      if (v40 <= 0.0) {
        float v40 = 0.02;
      }
      float v41 = v36[1];
      float v42 = sqrtf((float)(*v36 * *v36) + (float)(v41 * v41));
      float v43 = v40 * (float)(*v36 / v42);
      float v44 = v40 * (float)(v41 / v42);
      float v45 = v36[4];
      float v46 = v36[5];
      float v47 = sqrtf((float)(v45 * v45) + (float)(v46 * v46));
      float v48 = v40 * (float)(v45 / v47);
      float v49 = v40 * (float)(v46 / v47);
      BOOL isQuadActive = OMPie::isQuadActive(this);
      uint64_t v52 = *((void *)this + 5);
      if (!isQuadActive) {
        goto LABEL_47;
      }
      if (sqrtf((float)(*(float *)(v52 + 24) * *(float *)(v52 + 24)) + (float)(*(float *)(v52 + 28)
                                                                              * *(float *)(v52 + 28))) >= sqrtf((float)(v43 * v43) + (float)(v44 * v44)))
      {
        float v53 = *(float *)(v52 + 36);
      }
      else
      {
        float v53 = *(float *)(v52 + 36);
        if (sqrtf((float)(*(float *)(v52 + 32) * *(float *)(v52 + 32)) + (float)(v53 * v53)) < sqrtf((float)(v48 * v48)+ (float)(v49 * v49)))goto LABEL_47; {
      }
        }
      float v43 = *(float *)(v52 + 24);
      float v44 = *(float *)(v52 + 28);
      float v48 = *(float *)(v52 + 32);
      float v49 = v53;
LABEL_47:
      *(float *)uint64_t v52 = v43;
      *(float *)(v52 + 4) = v44;
      *(float *)(v52 + 16) = v48;
      *(float *)(v52 + 20) = v49;
      float v75 = OMUtil::angle((OMUtil *)v52, (const Vec2f *)(v52 + 16), v51);
      if ((float)((float)(*(float *)v52 * *(float *)(v52 + 20)) - (float)(*(float *)(v52 + 4) * *(float *)(v52 + 16))) < 0.0) {
        float v75 = 6.2832 - v75;
      }
      if (v75 > 3.14159265 && !OMPie::isQuadActive(this))
      {
        OMPie::computeArcIn(this, v76, v77);
        OMPie::computeArcOut(this, v78, v79);
        OMPie::getArcOut((float32x2_t **)this, 0.5, (float32x2_t *)&v81);
        *(float32x2_t *)(v52 + 8) = vmul_n_f32(*(float32x2_t *)(v52 + 8), sqrtf((float)(v81.f32[0] * v81.f32[0]) + (float)(v81.f32[1] * v81.f32[1]))/ sqrtf((float)(*(float *)&v39 * *(float *)&v39)+ (float)(*((float *)&v39 + 1) * *((float *)&v39 + 1))));
      }
      return;
    case 12:
      *a2 = 10;
LABEL_41:
      *(float32x2_t *)v82.f32 = vsub_f32((float32x2_t)*a3, *a4);
      float v72 = OMUtil::angle((OMUtil *)&v82, a3, a3);
      if ((float)((float)(v82.f32[0] * a3->var0[1]) - (float)(v82.f32[1] * a3->var0[0])) < 0.0) {
        float v72 = 6.2832 - v72;
      }
      uint64_t v73 = (int32x2_t *)*((void *)this + 5);
      double v74 = v72;
      Mat2f::MakeRot((Mat2f *)&v82, v72);
      *uint64_t v73 = (int32x2_t)vadd_f32(vmul_f32((float32x2_t)vrev64_s32(*v73), *(float32x2_t *)&v82.i32[1]), vmul_f32((float32x2_t)*v73, (float32x2_t)__PAIR64__(v82.u32[3], v82.u32[0])));
      Mat2f::MakeRot((Mat2f *)&v82, v74);
      v73[1] = (int32x2_t)vadd_f32(vmul_f32((float32x2_t)vrev64_s32(v73[1]), *(float32x2_t *)&v82.i32[1]), vmul_f32((float32x2_t)v73[1], (float32x2_t)__PAIR64__(v82.u32[3], v82.u32[0])));
      Mat2f::MakeRot((Mat2f *)&v82, v74);
      v73[2] = (int32x2_t)vadd_f32(vmul_f32((float32x2_t)vrev64_s32(v73[2]), *(float32x2_t *)&v82.i32[1]), vmul_f32((float32x2_t)v73[2], (float32x2_t)__PAIR64__(v82.u32[3], v82.u32[0])));
      Mat2f::MakeRot((Mat2f *)&v82, v74);
      v73[3] = (int32x2_t)vadd_f32(vmul_f32((float32x2_t)vrev64_s32(v73[3]), *(float32x2_t *)&v82.i32[1]), vmul_f32((float32x2_t)v73[3], (float32x2_t)__PAIR64__(v82.u32[3], v82.u32[0])));
      Mat2f::MakeRot((Mat2f *)&v82, v74);
      v73[4] = (int32x2_t)vadd_f32(vmul_f32((float32x2_t)vrev64_s32(v73[4]), *(float32x2_t *)&v82.i32[1]), vmul_f32((float32x2_t)v73[4], (float32x2_t)__PAIR64__(v82.u32[3], v82.u32[0])));
      return;
    default:
LABEL_15:
      switch(v7)
      {
        case 3:
          uint64_t v33 = *((void *)this + 5);
          if (*((_DWORD *)this + 8))
          {
            float v34 = *(float *)(v33 + 28);
            float v35 = a4->f32[0] + *(float *)(v33 + 24);
          }
          else
          {
            float v34 = *(float *)(v33 + 28);
            float v35 = *(float *)(v33 + 24) + a4->f32[0];
            if (sqrtf((float)(v35 * v35) + (float)((float)(v34 + a4->f32[1]) * (float)(v34 + a4->f32[1]))) > 1.0) {
              return;
            }
          }
          *(float *)(v33 + 24) = v35;
          *(float *)(v33 + 28) = a4->f32[1] + v34;
          return;
        case 4:
          uint64_t v54 = *((void *)this + 5);
          if (*((_DWORD *)this + 8))
          {
            float v55 = *(float *)(v54 + 36);
            float v56 = a4->f32[0] + *(float *)(v54 + 32);
          }
          else
          {
            float v55 = *(float *)(v54 + 36);
            float v56 = *(float *)(v54 + 32) + a4->f32[0];
            if (sqrtf((float)(v56 * v56) + (float)((float)(v55 + a4->f32[1]) * (float)(v55 + a4->f32[1]))) > 1.0) {
              return;
            }
          }
          *(float *)(v54 + 32) = v56;
          *(float *)(v54 + 36) = a4->f32[1] + v55;
          break;
        case 6:
          OMPie::moveAroundArc(this, (float32x2_t *)a3, *((Vec2f **)this + 5));
          if (!OMPie::isQuadActive(this)) {
            goto LABEL_38;
          }
          long long v57 = (float *)*((void *)this + 5);
          long long v58 = (Vec2f *)(v57 + 6);
          if (v57[6] != v57[2]) {
            goto LABEL_37;
          }
          float v59 = v57[7];
          goto LABEL_36;
        case 7:
          OMPie::moveAroundArc(this, (float32x2_t *)a3, (Vec2f *)(*((void *)this + 5) + 16));
          if (!OMPie::isQuadActive(this)) {
            goto LABEL_38;
          }
          long long v57 = (float *)*((void *)this + 5);
          long long v58 = (Vec2f *)(v57 + 8);
          if (v57[8] != v57[2]) {
            goto LABEL_37;
          }
          float v59 = v57[9];
LABEL_36:
          if (v59 != v57[3]) {
LABEL_37:
          }
            OMPie::moveAroundArc(this, (float32x2_t *)a3, v58);
LABEL_38:
          if (!OMPie::isQuadActive(this)) {
            OMPie::testIfShouldBeAQuad(this, v60, v61);
          }
          return;
        case 9:
          uint64_t v62 = (float32x2_t *)*((void *)this + 5);
          float32x2_t v63 = v62[1];
          float32x2_t v64 = vsub_f32(v63, (float32x2_t)*a3);
          int32x2_t v65 = (int32x2_t)vmul_f32(v64, v64);
          *(float *)v65.i32 = sqrtf(vaddv_f32((float32x2_t)v65));
          int32x2_t v66 = (int32x2_t)vmul_f32(*a4, vdiv_f32(v64, (float32x2_t)vdup_lane_s32(v65, 0)));
          v66.i32[0] = vadd_f32((float32x2_t)v66, (float32x2_t)vdup_lane_s32(v66, 1)).u32[0];
          float32x2_t v67 = vsub_f32(v63, *v62);
          int32x2_t v68 = (int32x2_t)vmul_f32(v67, v67);
          *(float *)v68.i32 = sqrtf(vaddv_f32((float32x2_t)v68));
          *uint64_t v62 = vadd_f32(*v62, vmul_n_f32(vdiv_f32(v67, (float32x2_t)vdup_lane_s32(v68, 0)), *(float *)v66.i32));
          float32x2_t v69 = v62[2];
          float32x2_t v70 = vsub_f32(v63, v69);
          int32x2_t v71 = (int32x2_t)vmul_f32(v70, v70);
          *(float *)v71.i32 = sqrtf(vaddv_f32((float32x2_t)v71));
          v62[2] = vadd_f32(v69, vmul_n_f32(vdiv_f32(v70, (float32x2_t)vdup_lane_s32(v71, 0)), *(float *)v66.i32));
          goto LABEL_41;
        case 10:
          goto LABEL_41;
        case 11:
          goto LABEL_18;
        case 12:
          OMPie::moveAll(this, (const Vec2f *)a4);
          return;
        default:
          return;
      }
      return;
  }
}

BOOL OMPie::testIfShouldBeAQuad(OMPie *this, uint64_t a2, const Vec2f *a3)
{
  float v4 = (float32x2_t *)*((void *)this + 5);
  OMPie::computeArcIn(this, a2, a3);
  OMPie::computeArcOut(this, v5, v6);
  OMPie::getArcOut((float32x2_t **)this, 0.5, &v23);
  *(float32x2_t *)v7.f32 = vsub_f32(v4[2], *v4);
  v7.i64[1] = v7.i64[0];
  float32x4_t v22 = vmulq_f32(v7, (float32x4_t)xmmword_1B837AD80);
  *(float32x2_t *)v7.f32 = v4[1];
  *(float32x2_t *)&v7.u32[2] = v23;
  float32x4_t v21 = v7;
  BOOL result = OMUtil::findIntersectionOfLineSegment(v22.f32, v21.f32);
  if (!result)
  {
    float v9 = sqrtf((float)(v4[1].f32[0] * v4[1].f32[0]) + (float)(v4[1].f32[1] * v4[1].f32[1]));
    v4[1] = 0;
    float v10 = v4->f32[1];
    float v11 = sqrtf((float)(v4->f32[0] * v4->f32[0]) + (float)(v10 * v10));
    float v12 = v9 * (float)(v4->f32[0] / v11);
    float v13 = v9 * (float)(v10 / v11);
    float v14 = v4[2].f32[0];
    float v15 = v4[2].f32[1];
    BOOL v20 = sqrtf((float)(v12 * v12) + (float)(v13 * v13)) < v11;
    float v16 = sqrtf((float)(v14 * v14) + (float)(v15 * v15));
    float v17 = v9 * (float)(v15 / v16);
    float v18 = v9 * (float)(v14 / v16);
    float v19 = sqrtf((float)(v18 * v18) + (float)(v17 * v17));
    BOOL v20 = v20 && v19 < v16;
    if (!v20)
    {
      float v12 = v4->f32[0];
      float v13 = v4->f32[1];
      float v18 = v4[2].f32[0];
      float v17 = v4[2].f32[1];
    }
    v4[3].f32[0] = v12;
    v4[3].f32[1] = v13;
    v4[4].f32[0] = v18;
    v4[4].f32[1] = v17;
  }
  return result;
}

void OMPie::computeArcIn(OMPie *this, uint64_t a2, const Vec2f *a3)
{
  float v4 = (float *)*((void *)this + 5);
  float v6 = v4[6];
  float v5 = v4[7];
  float v8 = v4[8];
  float v7 = v4[9];
  if (*((_DWORD *)this + 8) == 1)
  {
    float v10 = v4[2];
    float v9 = v4[3];
    float v11 = v6 - v10;
    float v12 = v5 - v9;
    float v13 = sqrtf((float)(v12 * v12) + (float)(v11 * v11));
    float v8 = v8 - v10;
    float v7 = v7 - v9;
    float v14 = sqrtf((float)(v7 * v7) + (float)(v8 * v8));
    *((float *)this + 4) = v13;
    *((float *)this + 5) = v14;
    unint64_t v22 = 1065353216;
    float v15 = v11 / v13;
    float v16 = v12 / v13;
  }
  else
  {
    float v17 = sqrtf((float)(v6 * v6) + (float)(v5 * v5));
    float v14 = sqrtf((float)(v8 * v8) + (float)(v7 * v7));
    *((float *)this + 4) = v17;
    *((float *)this + 5) = v14;
    unint64_t v22 = 1065353216;
    float v15 = v6 / v17;
    float v16 = v5 / v17;
  }
  v21.var0[0] = v15;
  v21.var0[1] = v16;
  float v19 = OMUtil::angle((OMUtil *)&v22, &v21, a3);
  if ((float)((float)(*(float *)&v22 * v21.var0[1]) - (float)(*((float *)&v22 + 1) * v21.var0[0])) < 0.0) {
    float v19 = 6.2832 - v19;
  }
  *((float *)this + 6) = v19;
  unint64_t v22 = __PAIR64__(LODWORD(v16), LODWORD(v15));
  v21.var0[0] = v8 / v14;
  v21.var0[1] = v7 / v14;
  float v20 = OMUtil::angle((OMUtil *)&v22, &v21, v18);
  if ((float)((float)(*(float *)&v22 * v21.var0[1]) - (float)(*((float *)&v22 + 1) * v21.var0[0])) < 0.0) {
    float v20 = 6.2832 - v20;
  }
  *((float *)this + 7) = v20;
}

void OMPie::computeArcOut(OMPie *this, uint64_t a2, const Vec2f *a3)
{
  float v4 = (float *)*((void *)this + 5);
  *(float *)this = sqrtf((float)(*v4 * *v4) + (float)(v4[1] * v4[1]));
  *((float *)this + 1) = sqrtf((float)(v4[4] * v4[4]) + (float)(v4[5] * v4[5]));
  uint64_t v16 = 1065353216;
  float v5 = v4[1];
  float v6 = sqrtf((float)(*v4 * *v4) + (float)(v5 * v5));
  v15.var0[0] = *v4 / v6;
  v15.var0[1] = v5 / v6;
  float v8 = OMUtil::angle((OMUtil *)&v16, &v15, a3);
  if ((float)((float)(*(float *)&v16 * v15.var0[1]) - (float)(*((float *)&v16 + 1) * v15.var0[0])) < 0.0) {
    float v8 = 6.2832 - v8;
  }
  *((float *)this + 2) = v8;
  float v9 = v4[1];
  float v10 = sqrtf((float)(*v4 * *v4) + (float)(v9 * v9));
  *(float *)&uint64_t v16 = *v4 / v10;
  *((float *)&v16 + 1) = v9 / v10;
  float v11 = v4[4];
  float v12 = v4[5];
  float v13 = sqrtf((float)(v11 * v11) + (float)(v12 * v12));
  v15.var0[0] = v11 / v13;
  v15.var0[1] = v12 / v13;
  float v14 = OMUtil::angle((OMUtil *)&v16, &v15, v7);
  if ((float)((float)(*(float *)&v16 * v15.var0[1]) - (float)(*((float *)&v16 + 1) * v15.var0[0])) < 0.0) {
    float v14 = 6.2832 - v14;
  }
  *((float *)this + 3) = v14;
}

void OMPie::computeOppositeArc(OMPie *this, uint64_t a2, const Vec2f *a3)
{
  float v4 = (float *)*((void *)this + 5);
  float v5 = *v4;
  float v6 = v4[1];
  float v7 = v4[4];
  float v8 = v4[5];
  float v9 = sqrtf((float)(v7 * v7) + (float)(v8 * v8));
  float v10 = sqrtf((float)(v5 * v5) + (float)(v6 * v6));
  *(float *)this = v9;
  *((float *)this + 1) = v10;
  unint64_t v30 = 1065353216;
  float v11 = v7 / v9;
  float v12 = v8 / v9;
  v29.var0[0] = v7 / v9;
  v29.var0[1] = v8 / v9;
  float v14 = OMUtil::angle((OMUtil *)&v30, &v29, a3);
  if ((float)((float)(*(float *)&v30 * v29.var0[1]) - (float)(*((float *)&v30 + 1) * v29.var0[0])) < 0.0) {
    float v14 = 6.2832 - v14;
  }
  *((float *)this + 2) = v14;
  unint64_t v30 = __PAIR64__(LODWORD(v12), LODWORD(v11));
  v29.var0[0] = v5 / v10;
  v29.var0[1] = v6 / v10;
  float v16 = OMUtil::angle((OMUtil *)&v30, &v29, v13);
  if ((float)((float)(*(float *)&v30 * v29.var0[1]) - (float)(*((float *)&v30 + 1) * v29.var0[0])) < 0.0) {
    float v16 = 6.2832 - v16;
  }
  *((float *)this + 3) = v16;
  float v17 = (float *)*((void *)this + 5);
  float v18 = v17[6];
  float v19 = v17[7];
  float v20 = v17[8];
  float v21 = v17[9];
  float v22 = sqrtf((float)(v18 * v18) + (float)(v19 * v19));
  float v23 = sqrtf((float)(v20 * v20) + (float)(v21 * v21));
  *((float *)this + 4) = v22;
  *((float *)this + 5) = v23;
  unint64_t v30 = 1065353216;
  float v24 = v18 / v22;
  float v25 = v19 / v22;
  v29.var0[0] = v18 / v22;
  v29.var0[1] = v19 / v22;
  float v27 = OMUtil::angle((OMUtil *)&v30, &v29, v15);
  if ((float)((float)(*(float *)&v30 * v29.var0[1]) - (float)(*((float *)&v30 + 1) * v29.var0[0])) < 0.0) {
    float v27 = 6.2832 - v27;
  }
  *((float *)this + 6) = v27;
  unint64_t v30 = __PAIR64__(LODWORD(v25), LODWORD(v24));
  v29.var0[0] = v20 / v23;
  v29.var0[1] = v21 / v23;
  float v28 = OMUtil::angle((OMUtil *)&v30, &v29, v26);
  if ((float)((float)(*(float *)&v30 * v29.var0[1]) - (float)(*((float *)&v30 + 1) * v29.var0[0])) < 0.0) {
    float v28 = 6.2832 - v28;
  }
  *((float *)this + 7) = v28;
}

BOOL OMPie::setBasedOnOffsetFromOtherPie(OMPie *this, OMPie *a2, float a3, float a4, const Vec2f *a5)
{
  char v5 = (char)a5;
  float v9 = (Vec2f *)*((void *)a2 + 5);
  if (a3 <= 0.45) {
    float v10 = a3;
  }
  else {
    float v10 = (float)((float)(a3 + -0.45) * 0.333) + 0.45;
  }
  float v13 = OMUtil::angle(*((OMUtil **)a2 + 5), v9 + 2, a5);
  if ((float)((float)(v9->var0[0] * v9[2].var0[1]) - (float)(v9->var0[1] * v9[2].var0[0])) < 0.0) {
    float v13 = 6.2832 - v13;
  }
  if (v13 <= 3.14159265)
  {
    OMPie::computeArcIn(a2, v11, v12);
    OMPie::computeArcOut(a2, v25, v26);
    OMPie::getArcOut((float32x2_t **)a2, 0.5, &v88);
    float v16 = v9[1].var0[0];
    float v17 = v9[1].var0[1];
    BOOL v27 = v16 == v88.f32[0] && v17 == v88.f32[1];
    float v28 = sqrtf((float)(v16 * v16) + (float)(v17 * v17));
    float v29 = v16 - (float)(v10 * (float)(v16 / v28));
    float v30 = v17 - (float)(v10 * (float)(v17 / v28));
    float v31 = sqrtf((float)((float)(v16 - v88.f32[0]) * (float)(v16 - v88.f32[0]))+ (float)((float)(v17 - v88.f32[1]) * (float)(v17 - v88.f32[1])));
    if (v27) {
      float v23 = v29;
    }
    else {
      float v23 = v16 + (float)(v10 * (float)((float)(v16 - v88.f32[0]) / v31));
    }
    if (v27) {
      float v24 = v30;
    }
    else {
      float v24 = v17 + (float)(v10 * (float)((float)(v17 - v88.f32[1]) / v31));
    }
  }
  else
  {
    OMPie::computeOppositeArc(a2, v11, v12);
    OMPie::getArcOut((float32x2_t **)a2, 0.5, &v93);
    float v16 = v9[1].var0[0];
    float v17 = v9[1].var0[1];
    float v18 = v93.f32[0];
    if (v16 == v93.f32[0] && v17 == v93.f32[1]) {
      goto LABEL_12;
    }
    v88.i32[0] = LODWORD(v9[1].var0[0]);
    v88.f32[1] = v17;
    uint64_t v89 = 0;
    *(Vec2f *)&long long v20 = *v9;
    *((Vec2f *)&v20 + 1) = v9[2];
    long long v92 = v20;
    BOOL IntersectionOfLineSegment = OMUtil::findIntersectionOfLineSegment((float *)&v88, (float *)&v92);
    float v16 = v9[1].var0[0];
    float v17 = v9[1].var0[1];
    if (IntersectionOfLineSegment)
    {
LABEL_12:
      float v22 = sqrtf((float)(v16 * v16) + (float)(v17 * v17));
      float v23 = v16 + (float)(v10 * (float)(v16 / v22));
      float v24 = v17 + (float)(v10 * (float)(v17 / v22));
    }
    else
    {
      float v32 = sqrtf((float)((float)(v16 - v18) * (float)(v16 - v18))+ (float)((float)(v17 - v93.f32[1]) * (float)(v17 - v93.f32[1])));
      float v23 = v16 - (float)(v10 * (float)((float)(v16 - v18) / v32));
      float v24 = v17 - (float)(v10 * (float)((float)(v17 - v93.f32[1]) / v32));
    }
  }
  float v87 = sqrtf((float)((float)(v16 - v23) * (float)(v16 - v23)) + (float)((float)(v17 - v24) * (float)(v17 - v24)));
  OMPie::computeArcIn(a2, v14, v15);
  OMPie::computeArcOut(a2, v33, v34);
  float32x2_t v35 = (float32x2_t)*v9;
  *(float *)v36.i32 = sqrtf(vaddv_f32(vmul_f32(v35, v35)));
  float32x2_t v37 = (float32x2_t)v9[2];
  int32x2_t v38 = (int32x2_t)vmul_f32(v37, v37);
  *(float *)v38.i32 = sqrtf(vaddv_f32((float32x2_t)v38));
  float32x2_t v39 = vdiv_f32(v37, (float32x2_t)vdup_lane_s32(v38, 0));
  if (v5)
  {
    float v40 = fmaxf(*(float *)v36.i32, 1.575);
    float32x2_t v41 = vmul_n_f32(vdiv_f32(v35, (float32x2_t)vdup_lane_s32(v36, 0)), v40);
    float32x2_t v42 = vmul_n_f32(v39, v40);
  }
  else
  {
    float32x2_t v41 = vadd_f32(v35, vmul_n_f32(vdiv_f32(v35, (float32x2_t)vdup_lane_s32(v36, 0)), v87));
    float32x2_t v42 = vadd_f32(v37, vmul_n_f32(v39, v87));
  }
  OMPie::OMPie((OMPie *)&v88, 0);
  float v43 = (float32x2_t *)__p;
  *(float32x2_t *)__p = v41;
  void v43[2] = v42;
  v43[1] = 0;
  OMPie::computeArcIn((OMPie *)&v88, v44, v45);
  OMPie::computeArcOut((OMPie *)&v88, v46, v47);
  float v49 = OMUtil::angle((OMUtil *)v9, v9 + 2, v48);
  if ((float)((float)(v9->var0[0] * v9[2].var0[1]) - (float)(v9->var0[1] * v9[2].var0[0])) < 0.0) {
    float v49 = 6.2832 - v49;
  }
  float v50 = (float)((float)(v87 * a4) + (float)(v87 * a4)) * 3.14159265 * 0.200000003 / v49;
  OMPie::getArcOut((float32x2_t **)&v88, 0.0 - v50, (float32x2_t *)&v92);
  __int32 v86 = v92;
  float32x2_t v95 = (float32x2_t)v92;
  OMPie::getArcOut((float32x2_t **)&v88, v50 + 1.0, (float32x2_t *)&v92);
  Vec2f v94 = (Vec2f)v92;
  if (__p)
  {
    int v91 = __p;
    operator delete(__p);
  }
  float v53 = OMUtil::angle((OMUtil *)v9, v9 + 2, v51);
  if ((float)((float)(v9->var0[0] * v9[2].var0[1]) - (float)(v9->var0[1] * v9[2].var0[0])) < 0.0) {
    float v53 = 6.2832 - v53;
  }
  if (v53 <= 3.14159265)
  {
LABEL_38:
    __int32 v55 = v86;
    goto LABEL_39;
  }
  float v54 = OMUtil::angle((OMUtil *)&v95, &v94, v52);
  __int32 v55 = v95.i32[0];
  if ((float)((float)(v95.f32[0] * v94.var0[1]) - (float)(v95.f32[1] * v94.var0[0])) < 0.0) {
    float v54 = 6.2832 - v54;
  }
  if (v54 < 3.14159265)
  {
    OMPie::OMPie((OMPie *)&v88, 0);
    float v56 = (Vec2f *)__p;
    *(float32x2_t *)__p = v95;
    v56[2] = v94;
    v56[1] = 0;
    OMPie::computeArcIn((OMPie *)&v88, v57, v58);
    OMPie::computeArcOut((OMPie *)&v88, v59, v60);
    OMPie::getArcOut((float32x2_t **)&v88, 0.501, (float32x2_t *)&v92);
    __int32 v86 = v92;
    float32x2_t v95 = (float32x2_t)v92;
    OMPie::getArcOut((float32x2_t **)&v88, 0.499, (float32x2_t *)&v92);
    Vec2f v94 = (Vec2f)v92;
    if (__p)
    {
      int v91 = __p;
      operator delete(__p);
      __int32 v55 = v95.i32[0];
      goto LABEL_39;
    }
    goto LABEL_38;
  }
LABEL_39:
  uint64_t v61 = *((void *)this + 5);
  *(_DWORD *)uint64_t v61 = v55;
  *(_DWORD *)(v61 + 4) = v95.i32[1];
  *(float *)(v61 + 8) = v23;
  *(Vec2f *)(v61 + 16) = v94;
  *(float *)(v61 + 24) = v23;
  *(float *)(v61 + 28) = v24;
  *(float *)(v61 + 32) = v23;
  *(float *)(v61 + 36) = v24;
  *(float *)(v61 + 12) = v24;
  BOOL result = OMPie::isQuadActive(a2);
  if (result)
  {
    if ((v5 & 1) == 0)
    {
      float32x2_t v63 = (float *)*((void *)a2 + 5);
      float v64 = v63[8] - v9[2].var0[0];
      float v65 = v63[9] - v9[2].var0[1];
      float v66 = (float)(v87 + v87) + sqrtf((float)(v64 * v64) + (float)(v65 * v65));
      float v67 = sqrtf((float)((float)(0.0 - v94.var0[0]) * (float)(0.0 - v94.var0[0]))+ (float)((float)(0.0 - v94.var0[1]) * (float)(0.0 - v94.var0[1])));
      float v68 = v94.var0[0] + (float)(v66 * (float)((float)(0.0 - v94.var0[0]) / v67));
      float v69 = v63[7] - v9->var0[1];
      float v70 = (float)(v87 + v87)
          + sqrtf((float)((float)(v63[6] - v9->var0[0]) * (float)(v63[6] - v9->var0[0])) + (float)(v69 * v69));
      float v71 = sqrtf((float)((float)(0.0 - v95.f32[0]) * (float)(0.0 - v95.f32[0]))+ (float)((float)(0.0 - v95.f32[1]) * (float)(0.0 - v95.f32[1])));
      float v72 = v95.f32[0] + (float)(v70 * (float)((float)(0.0 - v95.f32[0]) / v71));
      float v73 = v95.f32[1] + (float)(v70 * (float)((float)(0.0 - v95.f32[1]) / v71));
      float32x2_t v88 = v95;
      *(float *)&uint64_t v89 = v72;
      *((float *)&v89 + 1) = v73;
      *(Vec2f *)&long long v92 = v94;
      float v74 = v94.var0[1] + (float)(v66 * (float)((float)(0.0 - v94.var0[1]) / v67));
      *((float *)&v92 + 2) = v68;
      *((float *)&v92 + 3) = v74;
      if (OMUtil::findIntersectionOfLineSegmentExclusive((float *)&v88, (float *)&v92))
      {
        float v75 = sqrtf((float)(v68 * v68) + (float)(v74 * v74)) / v87;
        float v76 = v23 * v75;
        float v77 = v24 * v75;
        float v78 = 1.0 - v75;
        uint64_t v79 = *((void *)this + 5);
        *(float *)(v79 + 8) = v76 + (float)(v78 * (float)((float)(v68 + v72) * 0.5));
        *(float *)(v79 + 12) = v77 + (float)(v78 * (float)((float)(v74 + v73) * 0.5));
      }
      else
      {
        uint64_t v83 = *((void *)this + 5);
        *(void *)(v83 + 8) = 0;
        *(float *)(v83 + 32) = v68;
        *(float *)(v83 + 36) = v74;
        *(float *)(v83 + 24) = v72;
        *(float *)(v83 + 28) = v73;
      }
    }
    BOOL result = OMPie::isQuadActive(this);
    if (!result)
    {
      uint64_t v84 = *((void *)this + 5);
      *(float32x2_t *)&long long v85 = vmul_f32(*(float32x2_t *)(v84 + 8), (float32x2_t)vdup_n_s32(0x3CA3D70Au));
      *(void *)(v84 + 8) = v85;
      *((void *)&v85 + 1) = v85;
      *(_OWORD *)(v84 + 24) = v85;
    }
  }
  else
  {
    float32x2_t v80 = (float *)*((void *)this + 5);
    float v81 = v9[1].var0[0];
    v80[6] = v81;
    float v82 = v9[1].var0[1];
    v80[7] = v82;
    v80[8] = v81;
    v80[9] = v82;
    v80[2] = v81;
    v80[3] = v82;
  }
  return result;
}

void sub_1B7A3D6EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t OMPie::offsetSegment_180more(OMPie *this, float32x2_t *a2, const Vec2f *a3, Vec2f *a4, Vec2f *a5, Vec2f *a6, Vec2f *a7, float32x2_t **a8)
{
  *(Vec2f *)&long long v14 = *a7;
  *((Vec2f *)&v14 + 1) = *a6;
  *(_OWORD *)float v24 = v14;
  *(float32x2_t *)&long long v14 = *a2;
  *((Vec2f *)&v14 + 1) = *a3;
  long long v23 = v14;
  if (OMUtil::findIntersectionOfLineSegment(v24, (float *)&v23, (float *)&v25)) {
    *a6 = v25;
  }
  BOOL isQuadActive = OMPie::isQuadActive(this);
  OMPie::getArcOut(a8, 0.0, &v22);
  __int32 v17 = v22.i32[1];
  __int32 v16 = v22.i32[0];
  float v18 = 0.04;
  while (1)
  {
    OMPie::getArcOut(a8, v18, &v21);
    *(Vec2f *)&long long v19 = *a6;
    *((Vec2f *)&v19 + 1) = *a4;
    *(_OWORD *)float v24 = v19;
    *(void *)&long long v23 = __PAIR64__(v17, v16);
    __int32 v17 = v21.i32[1];
    __int32 v16 = v21.i32[0];
    *((float32x2_t *)&v23 + 1) = v21;
    uint64_t result = OMUtil::findIntersectionOfLineSegment(v24, (float *)&v23);
    if (result) {
      break;
    }
    float v18 = v18 + 0.04;
    if (v18 > 1.0001) {
      return result;
    }
  }
  uint64_t result = OMPie::moveAroundArc(this, a2, a4);
  if (isQuadActive) {
    return OMPie::moveAroundArc(this, a2, a5);
  }
  return result;
}

uint64_t OMPie::offsetSegmentIfNeeded(OMPie *this, OMPie *a2, float a3)
{
  char v5 = (float32x2_t *)*((void *)this + 5);
  long long v6 = *((_OWORD *)a2 + 1);
  v95[0] = *(_OWORD *)a2;
  v95[1] = v6;
  int v96 = *((_DWORD *)a2 + 8);
  float v98 = 0;
  uint64_t v99 = 0;
  __p = 0;
  std::vector<Vec2f>::__init_with_size[abi:ne180100]<Vec2f*,Vec2f*>((char *)&__p, *((_DWORD **)a2 + 5), *((_DWORD **)a2 + 6), (uint64_t)(*((void *)a2 + 6) - *((void *)a2 + 5)) >> 3);
  OMPie::setBasedOnOffsetFromOtherPie((OMPie *)v95, a2, 0.02, 1.0, 0);
  OMPie::computeArcIn((OMPie *)v95, v7, v8);
  OMPie::computeArcOut((OMPie *)v95, v9, v10);
  uint64_t v11 = (char *)__p;
  OMPie::computeArcIn(this, v12, v13);
  OMPie::computeArcOut(this, v14, v15);
  OMPie::getArcOut((float32x2_t **)this, 0.5, (float32x2_t *)&v94);
  unint64_t v17 = v94.n128_u64[0];
  float v18 = sqrtf((float)(*(float *)v11 * *(float *)v11) + (float)(*((float *)v11 + 1) * *((float *)v11 + 1)));
  float v19 = sqrtf((float)(*((float *)v11 + 4) * *((float *)v11 + 4)) + (float)(*((float *)v11 + 5) * *((float *)v11 + 5)));
  if (v18 <= v19) {
    float v18 = v19;
  }
  float32x2_t v20 = *v5;
  int32x2_t v21 = (int32x2_t)vmul_f32(v20, v20);
  *(float *)v21.i32 = sqrtf(vaddv_f32((float32x2_t)v21));
  if (*(float *)v21.i32 < v18) {
    float32x2_t *v5 = vmul_n_f32(vdiv_f32(v20, (float32x2_t)vdup_lane_s32(v21, 0)), v18);
  }
  float32x2_t v22 = v5[2];
  int32x2_t v23 = (int32x2_t)vmul_f32(v22, v22);
  *(float *)v23.i32 = sqrtf(vaddv_f32((float32x2_t)v23));
  if (*(float *)v23.i32 < v18) {
    v5[2] = vmul_n_f32(vdiv_f32(v22, (float32x2_t)vdup_lane_s32(v23, 0)), v18);
  }
  float v24 = OMUtil::angle((OMUtil *)v5, (const Vec2f *)&v5[2], v16);
  Vec2f v25 = v5 + 1;
  if ((float)((float)(v5->f32[0] * v5[2].f32[1]) - (float)(v5->f32[1] * v5[2].f32[0])) < 0.0) {
    float v24 = 6.2832 - v24;
  }
  if (v24 > 3.14159265 && !OMPie::isQuadActive(this))
  {
    OMPie::computeArcIn(this, v26, v27);
    OMPie::computeArcOut(this, v28, v29);
    OMPie::getArcOut((float32x2_t **)this, 0.5, (float32x2_t *)v93);
    float32x2_t *v25 = vmul_n_f32(*v25, sqrtf((float)(v93[0].var0[0] * v93[0].var0[0]) + (float)(v93[0].var0[1] * v93[0].var0[1]))/ sqrtf((float)(*(float *)&v17 * *(float *)&v17) + (float)(*((float *)&v17 + 1) * *((float *)&v17 + 1))));
  }
  float v31 = v5 + 3;
  float v32 = v5 + 4;
  if (OMPie::isQuadActive(a2) && OMPie::isQuadActive(this))
  {
    float v33 = sqrtf((float)(*((float *)v11 + 6) * *((float *)v11 + 6)) + (float)(*((float *)v11 + 7) * *((float *)v11 + 7)));
    float v34 = sqrtf((float)(*((float *)v11 + 8) * *((float *)v11 + 8)) + (float)(*((float *)v11 + 9) * *((float *)v11 + 9)));
    if (v33 >= v34) {
      float v33 = v34;
    }
    float32x2_t v35 = *v31;
    int32x2_t v36 = (int32x2_t)vmul_f32(v35, v35);
    *(float *)v36.i32 = sqrtf(vaddv_f32((float32x2_t)v36));
    if (*(float *)v36.i32 > v33) {
      *float v31 = vmul_n_f32(vdiv_f32(v35, (float32x2_t)vdup_lane_s32(v36, 0)), v33);
    }
    float32x2_t v37 = *v32;
    int32x2_t v38 = (int32x2_t)vmul_f32(v37, v37);
    *(float *)v38.i32 = sqrtf(vaddv_f32((float32x2_t)v38));
    if (*(float *)v38.i32 > v33) {
      *float v32 = vmul_n_f32(vdiv_f32(v37, (float32x2_t)vdup_lane_s32(v38, 0)), v33);
    }
  }
  float32x2_t v39 = v5[1];
  v94.n128_u64[0] = (unint64_t)vsub_f32(*v5, v39);
  v93[0] = (Vec2f)vsub_f32(v5[2], v39);
  float v40 = OMUtil::angle((OMUtil *)&v94, v93, v30);
  unint64_t v41 = v94.n128_u64[0];
  Vec2f v42 = v93[0];
  BOOL isQuadActive = OMPie::isQuadActive(this);
  if ((float)((float)(*(float *)&v41 * v42.var0[1]) - (float)(*((float *)&v41 + 1) * v42.var0[0])) >= 0.0) {
    float v45 = v40;
  }
  else {
    float v45 = 6.2832 - v40;
  }
  char v46 = v45 <= 3.14159265 || isQuadActive;
  if (v46)
  {
    OMPie::adjustSegment(this, (Vec2f *)v5, (Vec2f *)&v5[3], v5 + 2, (float32x2_t *)v11, (float32x2_t *)v11 + 3, (const Vec2f *)v11 + 2, v44, 1, (OMPie *)v95);
    OMPie::adjustSegment(this, (Vec2f *)&v5[2], (Vec2f *)&v5[4], v5, (float32x2_t *)v11 + 2, (float32x2_t *)v11 + 4, (const Vec2f *)v11, v47, 0, (OMPie *)v95);
  }
  else
  {
    OMPie::offsetSegment_180more(this, (float32x2_t *)v11, (const Vec2f *)v11 + 1, (Vec2f *)v5, (Vec2f *)&v5[3], (Vec2f *)&v5[1], (Vec2f *)&v5[2], (float32x2_t **)v95);
    OMPie::offsetSegment_180more(this, (float32x2_t *)v11 + 2, (const Vec2f *)v11 + 1, (Vec2f *)&v5[2], (Vec2f *)&v5[4], (Vec2f *)&v5[1], (Vec2f *)v5, (float32x2_t **)v95);
  }
  OMPie::setBasedOnOffsetFromOtherPie((OMPie *)v95, a2, 0.01, 1.0, 0);
  OMPie::computeArcIn((OMPie *)v95, v48, v49);
  OMPie::computeArcOut((OMPie *)v95, v50, v51);
  if (!OMPie::isQuadActive(a2))
  {
    if (!OMPie::isQuadActive(this))
    {
      __n128 v94 = *(__n128 *)v25->f32;
      *(_OWORD *)v93[0].var0 = *(_OWORD *)(v11 + 8);
      if (OMUtil::findIntersectionOfLineSegmentExclusive((float *)&v94, (float *)v93)
        || (unint64_t v91 = (unint64_t)v5[1],
            float32x2_t v92 = *v5,
            unint64_t v89 = *((void *)v11 + 1),
            float32x2_t v90 = *(float32x2_t *)v11,
            OMUtil::findIntersectionOfLineSegmentExclusive((float *)&v91, (float *)&v89)))
      {
        v5[1].i32[0] = *((_DWORD *)v11 + 2);
        v5[1].i32[1] = *((_DWORD *)v11 + 3);
      }
      OMPie::computeArcIn(this, v52, v53);
      OMPie::computeArcOut(this, v54, v55);
      OMPie::getArcOut((float32x2_t **)this, 0.0, &v88);
      v94.n128_u64[0] = *((void *)v11 + 1);
      v94.n128_u64[1] = *(void *)v11;
      v93[0] = *(Vec2f *)(v11 + 8);
      v93[1] = *(Vec2f *)v11;
      __int32 v57 = v88.i32[1];
      __int32 v56 = v88.i32[0];
      float v58 = 0.04;
      while (1)
      {
        OMPie::getArcOut((float32x2_t **)this, v58, &v87);
        unint64_t v91 = __PAIR64__(v57, v56);
        float32x2_t v59 = v87;
        float32x2_t v92 = v87;
        if (OMUtil::findIntersectionOfLineSegment((float *)&v94, (float *)&v91)) {
          goto LABEL_33;
        }
        unint64_t v89 = __PAIR64__(v57, v56);
        float32x2_t v90 = v59;
        if (OMUtil::findIntersectionOfLineSegment((float *)v93, (float *)&v89)) {
          goto LABEL_33;
        }
        float v58 = v58 + 0.04;
        __int32 v57 = v59.i32[1];
        __int32 v56 = v59.i32[0];
        if (v58 > 1.0001) {
          goto LABEL_41;
        }
      }
    }
    if (OMPie::isQuadActive(this) && !OMPie::isQuadActive(a2))
    {
LABEL_33:
      v5[1].i32[0] = *((_DWORD *)v11 + 2);
      v5[1].i32[1] = *((_DWORD *)v11 + 3);
    }
  }
LABEL_41:
  float32x2_t v60 = *v25;
  int32x2_t v61 = (int32x2_t)vmul_f32(v60, v60);
  *(float *)v61.i32 = sqrtf(vaddv_f32((float32x2_t)v61));
  if (*(float *)v61.i32 > 1.5)
  {
    float32x2_t v62 = vdiv_f32(v60, (float32x2_t)vdup_lane_s32(v61, 0));
    __asm { FMOV            V1.2S, #1.5 }
    float32x2_t *v25 = vmul_f32(v62, _D1);
  }
  BOOL v68 = OMPie::isQuadActive(a2);
  BOOL v69 = OMPie::isQuadActive(this);
  OMPie::computeArcIn(a2, v70, v71);
  OMPie::computeArcOut(a2, v72, v73);
  OMPie::computeArcIn(this, v74, v75);
  OMPie::computeArcOut(this, v76, v77);
  int v78 = 0;
  if (v68) {
    int v79 = 66;
  }
  else {
    int v79 = 34;
  }
  if (v69) {
    int v80 = 66;
  }
  else {
    int v80 = 34;
  }
  while (2)
  {
    OMPie::getNextEdgeTurnAround(this, v69, v78, (int8x16_t *)&v94);
    for (int i = 0; i != v79; ++i)
    {
      OMPie::getNextEdgeTurnAround(a2, v68, i, (int8x16_t *)v93);
      if (OMUtil::findIntersectionOfLineSegmentExclusive((float *)v93, (float *)&v94))
      {
        char v85 = 1;
        goto LABEL_60;
      }
    }
    if (++v78 != v80) {
      continue;
    }
    break;
  }
  BOOL v82 = 0;
  unsigned int v83 = 0;
  while (2)
  {
    OMPie::getNextEdgeSweep((float32x2_t **)this, v69, v83, &v94);
    for (int j = 0; j != v79; ++j)
    {
      OMPie::getNextEdgeTurnAround(a2, v68, j, (int8x16_t *)v93);
      if (OMUtil::findIntersectionOfLineSegmentExclusive((float *)v93, (float *)&v94))
      {
        char v85 = v82;
        goto LABEL_60;
      }
    }
    BOOL v82 = v83 > 0x1E;
    char v85 = 1;
    if (++v83 != 32) {
      continue;
    }
    break;
  }
LABEL_60:
  if (__p)
  {
    float v98 = __p;
    operator delete(__p);
  }
  return v85 & 1;
}

void sub_1B7A3DF38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t OMPie::adjustSegment(OMPie *this, Vec2f *a2, Vec2f *a3, float32x2_t *a4, float32x2_t *a5, float32x2_t *a6, const Vec2f *a7, const Vec2f *a8, BOOL a9, OMPie *a10)
{
  float32x2_t v62 = (float32x2_t *)*((void *)a10 + 5);
  uint64_t v14 = (float32x2_t *)*((void *)this + 5);
  Vec2f v15 = v14 + 1;
  BOOL isQuadActive = OMPie::isQuadActive(this);
  OMPie::getArcOut((float32x2_t **)a10, 0.0, &v68);
  __int32 v18 = v68.i32[1];
  __int32 v17 = v68.i32[0];
  float v19 = 0.04;
  while (1)
  {
    OMPie::getArcOut((float32x2_t **)a10, v19, v65);
    *(float32x2_t *)&long long v20 = *v15;
    *((Vec2f *)&v20 + 1) = *a2;
    long long v67 = v20;
    LODWORD(v66[0].var0[0]) = v17;
    LODWORD(v66[0].var0[1]) = v18;
    __int32 v21 = v65[0].i32[1];
    __int32 v17 = v65[0].i32[0];
    v66[1] = (Vec2f)v65[0];
    if (OMUtil::findIntersectionOfLineSegment((float *)&v67, (float *)v66)) {
      break;
    }
    float v19 = v19 + 0.04;
    __int32 v18 = v21;
    if (v19 > 1.0001)
    {
      v68.i32[1] = v21;
      goto LABEL_7;
    }
  }
  v68.i32[1] = v18;
  OMPie::moveAroundArc(this, a5, a2);
  if (isQuadActive) {
    OMPie::moveAroundArc(this, a5, a3);
  }
LABEL_7:
  OMPie::getArcOut((float32x2_t **)a10, 0.04, (float32x2_t *)&v67);
  __int32 v23 = DWORD1(v67);
  __int32 v22 = v67;
  v68.i32[0] = v67;
  float v24 = 0.04;
  while (1)
  {
    OMPie::getArcOut((float32x2_t **)a10, v24, v65);
    *(float32x2_t *)&long long v25 = *v15;
    *((Vec2f *)&v25 + 1) = *a2;
    long long v67 = v25;
    LODWORD(v66[0].var0[0]) = v22;
    LODWORD(v66[0].var0[1]) = v23;
    __int32 v23 = v65[0].i32[1];
    __int32 v22 = v65[0].i32[0];
    v66[1] = (Vec2f)v65[0];
    if (OMUtil::findIntersectionOfLineSegment((float *)&v67, (float *)v66)) {
      break;
    }
    float v24 = v24 + 0.04;
    if (v24 >= 1.0) {
      goto LABEL_17;
    }
  }
  float v26 = v14[1].f32[0];
  float v27 = v14[1].f32[1];
  float v58 = sqrtf((float)(v26 * v26) + (float)(v27 * v27));
  float v29 = asinf(sqrtf((float)(a5->f32[0] * a5->f32[0]) + (float)(a5->f32[1] * a5->f32[1])) / v58);
  if (a9) {
    float v30 = -v29;
  }
  else {
    float v30 = v29;
  }
  v66[0].var0[0] = -v26;
  v66[0].var0[1] = -v27;
  Vec2f v63 = (Vec2f)1065353216;
  float v31 = OMUtil::angle((OMUtil *)&v63, v66, v28);
  if ((float)((float)(v63.var0[0] * v66[0].var0[1]) - (float)(v63.var0[1] * v66[0].var0[0])) < 0.0) {
    float v31 = 6.2832 - v31;
  }
  __float2 v32 = __sincosf_stret(v30 + v31);
  Vec2f v63 = (Vec2f)vadd_f32(v14[1], vmul_n_f32((float32x2_t)__PAIR64__(LODWORD(v32.__sinval), LODWORD(v32.__cosval)), v58));
  OMPie::moveAroundArc(this, (float32x2_t *)&v63, a2);
LABEL_17:
  uint64_t result = OMPie::isQuadActive(this);
  if ((result & 1) == 0)
  {
    if (OMPie::isQuadActive(a10))
    {
      OMPie::getArcIn(a10, 0.0, (float *)v65);
      *(float32x2_t *)&long long v34 = *v15;
      *((Vec2f *)&v34 + 1) = *a2;
      long long v67 = v34;
      float v36 = v65[0].f32[1];
      float v35 = v65[0].f32[0];
      float v37 = 0.04;
      do
      {
        OMPie::getArcIn(a10, v37, (float *)&v63);
        v66[0].var0[0] = v35;
        v66[0].var0[1] = v36;
        float v35 = v63.var0[0];
        float v36 = v63.var0[1];
        v66[1] = v63;
        if (OMUtil::findIntersectionOfLineSegment((float *)&v67, (float *)v66))
        {
          float v43 = this;
          uint64_t v44 = a6;
          return OMPie::moveAroundArc(v43, v44, a2);
        }
        float v37 = v37 + 0.04;
      }
      while (v37 <= 1.0001);
      float v38 = a5->f32[0] * 0.95;
      float v39 = a5->f32[1] * 0.95;
      float v40 = sqrtf((float)(v38 * v38) + (float)(v39 * v39));
      float v41 = a6->f32[1];
      float v42 = sqrtf((float)(a6->f32[0] * a6->f32[0]) + (float)(v41 * v41));
      if (v40 < v42) {
        float v38 = a6->f32[0];
      }
      LODWORD(v66[0].var0[0]) = a6->i32[0];
      v66[0].var0[1] = v41;
      if (v40 < v42) {
        float v39 = v41;
      }
      v66[1].var0[0] = v38;
      v66[1].var0[1] = v39;
      uint64_t result = OMUtil::findIntersectionOfLineSegment((float *)&v67, (float *)v66);
      if (result)
      {
        float v43 = this;
        uint64_t v44 = a6;
        return OMPie::moveAroundArc(v43, v44, a2);
      }
    }
    else
    {
      *(float32x2_t *)&long long v45 = *v15;
      *((Vec2f *)&v45 + 1) = *a2;
      long long v67 = v45;
      *(float32x2_t *)&long long v45 = v62[1];
      *((Vec2f *)&v45 + 1) = *a7;
      *(_OWORD *)v66[0].var0 = v45;
      uint64_t result = OMUtil::findIntersectionOfLineSegment((float *)&v67, (float *)v66);
      if (result)
      {
        float32x2_t v46 = vsub_f32(v62[1], (float32x2_t)*a2);
        int32x2_t v47 = (int32x2_t)vmul_f32(v46, v46);
        *(float *)v47.i32 = sqrtf(vaddv_f32((float32x2_t)v47));
        float32x2_t v48 = vdiv_f32(v46, (float32x2_t)vdup_lane_s32(v47, 0));
        __asm { FMOV            V2.2S, #5.0 }
        float32x2_t v54 = vadd_f32((float32x2_t)*a2, vmul_f32(v48, _D2));
        v65[0] = (float32x2_t)*a2;
        v65[1] = v54;
        float32x2_t v55 = vsub_f32(*v15, *a4);
        int32x2_t v56 = (int32x2_t)vmul_f32(v55, v55);
        *(float *)v56.i32 = sqrtf(vaddv_f32((float32x2_t)v56));
        float32x2_t v57 = vadd_f32(*a4, vmul_f32(vdiv_f32(v55, (float32x2_t)vdup_lane_s32(v56, 0)), _D2));
        Vec2f v63 = (Vec2f)*a4;
        float32x2_t v64 = v57;
        return OMUtil::findIntersectionOfLineSegment((float *)v65, (float *)&v63, (float *)&v14[1]);
      }
    }
  }
  return result;
}

void OMPie::getNextEdgeTurnAround(OMPie *this@<X0>, int a2@<W1>, int a3@<W2>, int8x16_t *a4@<X8>)
{
  uint64_t v6 = *((void *)this + 5);
  if (a2)
  {
    if (!a3)
    {
      v7.i64[0] = *(void *)(v6 + 24);
      float32x2_t v8 = *(float32x2_t *)v6;
      goto LABEL_15;
    }
    if (a3 > 32)
    {
      if (a3 == 33)
      {
        v7.i64[0] = *(void *)(v6 + 16);
        float32x2_t v8 = *(float32x2_t *)(v6 + 32);
LABEL_15:
        v7.u64[1] = (unint64_t)v8;
        goto LABEL_16;
      }
      float v11 = (float)(a3 - 33) * 0.03125;
      OMPie::getArcIn(this, (float)(a3 - 34) * 0.03125, (float *)&v13);
      OMPie::getArcIn(this, v11, (float *)&v12);
LABEL_14:
      float32x2_t v8 = v12;
      *(float32x2_t *)v7.i8 = v13;
      goto LABEL_15;
    }
LABEL_8:
    float v9 = (float)a3 * 0.03125;
    OMPie::getArcOut((float32x2_t **)this, (float)(a3 - 1) * 0.03125, &v13);
    OMPie::getArcOut((float32x2_t **)this, v9, &v12);
    goto LABEL_14;
  }
  if (a3)
  {
    if (a3 <= 32) {
      goto LABEL_8;
    }
    int8x16_t v10 = *(int8x16_t *)(v6 + 8);
  }
  else
  {
    int8x16_t v10 = *(int8x16_t *)v6;
  }
  int8x16_t v7 = vextq_s8(v10, v10, 8uLL);
LABEL_16:
  *a4 = v7;
}

__n128 OMPie::getNextEdgeSweep@<Q0>(float32x2_t **this@<X0>, int a2@<W1>, int a3@<W2>, __n128 *a4@<X8>)
{
  if (a2)
  {
    float v6 = (float)a3 / 31.0;
    OMPie::getArcOut(this, v6, (float32x2_t *)&v11);
    OMPie::getArcIn((OMPie *)this, v6, (float *)&v10);
    unint64_t v8 = v10;
    result.n128_u64[0] = v11;
  }
  else
  {
    float v9 = this[5];
    OMPie::getArcOut(this, (float)a3 / 31.0, (float32x2_t *)&v11);
    result.n128_u64[0] = v11;
    unint64_t v8 = (unint64_t)v9[1];
  }
  result.n128_u64[1] = v8;
  *a4 = result;
  return result;
}

void OMPie::getArea(OMPie *this)
{
  float v2 = (Vec2f *)*((void *)this + 5);
  if (OMPie::isQuadActive(this))
  {
    OMUtil::angle((OMUtil *)v2, v2 + 2, v3);
    OMUtil::angle((OMUtil *)(*((void *)this + 5) + 24), (const Vec2f *)(*((void *)this + 5) + 32), v4);
  }
  else
  {
    uint64_t v5 = *((void *)this + 5);
    float v6 = *(float *)(v5 + 8);
    float v7 = *(float *)(v5 + 12);
    float v8 = v2->var0[0] - v6;
    float v9 = v2->var0[1] - v7;
    float v10 = v2[2].var0[0] - v6;
    float v11 = v2[2].var0[1] - v7;
    *(float *)float32x2_t v13 = v8;
    *(float *)&v13[1] = v9;
    v12.var0[0] = v10;
    v12.var0[1] = v11;
    OMUtil::angle((OMUtil *)v13, &v12, v3);
  }
}

void OMSamples::syncAutokey()
{
}

void sub_1B7A3EB94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  MEMORY[0x1BA9BFBA0](v13, 0x10A1C40B93B38D7);
  _Unwind_Resume(a1);
}

void OMSamples::updateTolAddSamples(uint64_t a1, uint64_t a2)
{
  __int32 v21 = 0;
  uint64_t v22 = 0;
  __p = 0;
  float v4 = *(uint64_t **)(a1 + 16);
  uint64_t v5 = *v4;
  if (v4[1] != *v4)
  {
    unint64_t v6 = 0;
    unsigned int v7 = 1;
    do
    {
      uint64_t v8 = *(void *)(v5 + 8 * v6);
      if ((*(_DWORD *)(v8 + 8) | 2) == 3)
      {
        std::vector<Vec3f>::__insert_with_size[abi:ne180100]<std::__wrap_iter<Vec3f*>,std::__wrap_iter<Vec3f*>>((uint64_t *)&__p, (uint64_t)v21, *(_DWORD **)(v8 + 48), *(_DWORD **)(v8 + 56), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v8 + 56) - *(void *)(v8 + 48)) >> 2));
        float v4 = *(uint64_t **)(a1 + 16);
        uint64_t v5 = *v4;
        *(unsigned char *)(a1 + 8) = *(unsigned char *)(*(void *)(*v4 + 8 * v6) + 12);
      }
      unint64_t v6 = v7++;
    }
    while (v6 < (v4[1] - v5) >> 3);
  }
  OMUtil::reduceSample((uint64_t *)&__p, (uint64_t *)(a1 + 24), 5.62950094e14);
  *(void *)(a1 + 56) = *(void *)(a1 + 48);
  uint64_t v14 = *(void *)(a1 + 24);
  if ((int)(-1431655765 * ((unint64_t)(*(void *)(a1 + 32) - v14) >> 2)) >= 1)
  {
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    do
    {
      OMKeyer2DColorUtil::rgb2hsl((uint64_t *)(v14 + v15), (uint64_t)v19, a2, v9, v10, v11, v12, v13);
      __int32 v17 = *(_DWORD **)(a1 + 56);
      if ((unint64_t)v17 >= *(void *)(a1 + 64))
      {
        uint64_t v18 = std::vector<Vec3f>::__push_back_slow_path<Vec3f const&>((uint64_t *)(a1 + 48), v19);
      }
      else
      {
        *__int32 v17 = v19[0];
        v17[1] = v19[1];
        v17[2] = v19[2];
        uint64_t v18 = (uint64_t)(v17 + 3);
      }
      *(void *)(a1 + 56) = v18;
      ++v16;
      uint64_t v14 = *(void *)(a1 + 24);
      v15 += 12;
    }
    while (v16 < (int)(-1431655765 * ((unint64_t)(*(void *)(a1 + 32) - v14) >> 2)));
  }
  if (__p)
  {
    __int32 v21 = __p;
    operator delete(__p);
  }
}

void sub_1B7A3ED74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t OMSamples::getEdgeSamples(OMSamples *this)
{
  return (uint64_t)this + 120;
}

void OMSamples::addTolAddSamples()
{
}

void sub_1B7A3EF18(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40B93B38D7);
  _Unwind_Resume(a1);
}

uint64_t OMAutoSamples::OMAutoSamples(uint64_t a1, _DWORD **a2)
{
  *(_DWORD *)(a1 + 8) = 3;
  *(unsigned char *)(a1 + 12) = 1;
  *(_DWORD *)(a1 + 16) = 10;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(unsigned char *)(a1 + 72) = 1;
  *(void *)a1 = &unk_1F1115080;
  float v3 = (void *)(a1 + 48);
  if (v3 != a2) {
    std::vector<Vec3f>::__assign_with_size[abi:ne180100]<Vec3f*,Vec3f*>(v3, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * (a2[1] - *a2));
  }
  return a1;
}

void sub_1B7A3EFD0(_Unwind_Exception *a1)
{
  OMSamplesElem::~OMSamplesElem(v1);
  _Unwind_Resume(a1);
}

void OMRect::OMRect(OMRect *this, float a2, float a3, float a4, float a5, int a6, char a7, int a8)
{
  *((_DWORD *)this + 2) = a6;
  *((unsigned char *)this + 12) = a7;
  *((_DWORD *)this + 4) = a8;
  *(_OWORD *)((char *)this + 24) = 0u;
  uint64_t v13 = (void **)((char *)this + 24);
  *(_OWORD *)((char *)this + 40) = 0u;
  uint64_t v14 = (float **)((char *)this + 40);
  *(_OWORD *)((char *)this + 56) = 0u;
  *((unsigned char *)this + 72) = 1;
  *(void *)this = &unk_1F1114CA0;
  uint64_t v15 = (float *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)this + 40, 1uLL);
  uint64_t v16 = (float *)*((void *)this + 3);
  __int32 v17 = (float *)*((void *)this + 4);
  float v19 = &v15[2 * v18];
  float *v15 = a2;
  v15[1] = a3;
  long long v20 = v15 + 2;
  __int32 v21 = v15;
  while (v17 != v16)
  {
    int v22 = *((_DWORD *)v17 - 2);
    v17 -= 2;
    *((_DWORD *)v21 - 2) = v22;
    v21 -= 2;
    v21[1] = v17[1];
  }
  *((void *)this + 3) = v21;
  *((void *)this + 4) = v20;
  *((void *)this + 5) = v19;
  if (v16)
  {
    operator delete(v16);
    float v19 = *v14;
  }
  *((void *)this + 4) = v20;
  if (v20 >= v19)
  {
    float v24 = (float *)*v13;
    uint64_t v25 = ((char *)v20 - (unsigned char *)*v13) >> 3;
    unint64_t v26 = v25 + 1;
    if ((unint64_t)(v25 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v27 = (char *)v19 - (char *)v24;
    if (v27 >> 2 > v26) {
      unint64_t v26 = v27 >> 2;
    }
    if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v28 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v28 = v26;
    }
    if (v28)
    {
      float v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v14, v28);
      float v24 = (float *)*((void *)this + 3);
      long long v20 = (float *)*((void *)this + 4);
    }
    else
    {
      float v29 = 0;
    }
    float v30 = (float *)&v29[8 * v25];
    float v19 = (float *)&v29[8 * v28];
    *float v30 = a2;
    v30[1] = a5;
    __int32 v23 = v30 + 2;
    while (v20 != v24)
    {
      int v31 = *((_DWORD *)v20 - 2);
      v20 -= 2;
      *((_DWORD *)v30 - 2) = v31;
      v30 -= 2;
      v30[1] = v20[1];
    }
    *((void *)this + 3) = v30;
    *((void *)this + 4) = v23;
    *((void *)this + 5) = v19;
    if (v24)
    {
      operator delete(v24);
      float v19 = *v14;
    }
  }
  else
  {
    v15[2] = a2;
    v15[3] = a5;
    __int32 v23 = v15 + 4;
  }
  *((void *)this + 4) = v23;
  if (v23 >= v19)
  {
    float v33 = (float *)*v13;
    uint64_t v34 = ((char *)v23 - (unsigned char *)*v13) >> 3;
    unint64_t v35 = v34 + 1;
    if ((unint64_t)(v34 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v36 = (char *)v19 - (char *)v33;
    if (v36 >> 2 > v35) {
      unint64_t v35 = v36 >> 2;
    }
    if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v37 = v35;
    }
    if (v37)
    {
      float v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v14, v37);
      float v33 = (float *)*((void *)this + 3);
      __int32 v23 = (float *)*((void *)this + 4);
    }
    else
    {
      float v38 = 0;
    }
    float v39 = (float *)&v38[8 * v34];
    float v19 = (float *)&v38[8 * v37];
    *float v39 = a4;
    v39[1] = a5;
    __float2 v32 = v39 + 2;
    while (v23 != v33)
    {
      int v40 = *((_DWORD *)v23 - 2);
      v23 -= 2;
      *((_DWORD *)v39 - 2) = v40;
      v39 -= 2;
      v39[1] = v23[1];
    }
    *((void *)this + 3) = v39;
    *((void *)this + 4) = v32;
    *((void *)this + 5) = v19;
    if (v33)
    {
      operator delete(v33);
      float v19 = *v14;
    }
  }
  else
  {
    *__int32 v23 = a4;
    v23[1] = a5;
    __float2 v32 = v23 + 2;
  }
  *((void *)this + 4) = v32;
  if (v32 >= v19)
  {
    float v42 = (float *)*v13;
    uint64_t v43 = ((char *)v32 - (unsigned char *)*v13) >> 3;
    unint64_t v44 = v43 + 1;
    if ((unint64_t)(v43 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v45 = (char *)v19 - (char *)v42;
    if (v45 >> 2 > v44) {
      unint64_t v44 = v45 >> 2;
    }
    if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v46 = v44;
    }
    if (v46)
    {
      int32x2_t v47 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v14, v46);
      float v42 = (float *)*((void *)this + 3);
      __float2 v32 = (float *)*((void *)this + 4);
    }
    else
    {
      int32x2_t v47 = 0;
    }
    float32x2_t v48 = (float *)&v47[8 * v43];
    float v49 = &v47[8 * v46];
    float *v48 = a4;
    v48[1] = a3;
    float v41 = v48 + 2;
    while (v32 != v42)
    {
      int v50 = *((_DWORD *)v32 - 2);
      v32 -= 2;
      *((_DWORD *)v48 - 2) = v50;
      v48 -= 2;
      v48[1] = v32[1];
    }
    *((void *)this + 3) = v48;
    *((void *)this + 4) = v41;
    *((void *)this + 5) = v49;
    if (v42) {
      operator delete(v42);
    }
  }
  else
  {
    *__float2 v32 = a4;
    v32[1] = a3;
    float v41 = v32 + 2;
  }
  *((void *)this + 4) = v41;
}

void sub_1B7A3F2FC(_Unwind_Exception *a1)
{
  OMSamplesElem::~OMSamplesElem(v1);
  _Unwind_Resume(a1);
}

char *std::vector<Vec3f>::__assign_with_size[abi:ne180100]<Vec3f*,Vec3f*>(void *a1, _DWORD *a2, _DWORD *a3, unint64_t a4)
{
  unint64_t v6 = a2;
  uint64_t v8 = a1[2];
  __n128 result = (char *)*a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - (uint64_t)result) >> 2) >= a4)
  {
    uint64_t v18 = (char *)a1[1];
    uint64_t v14 = a1 + 1;
    uint64_t v13 = v18;
    unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((v18 - result) >> 2);
    if (v19 >= a4)
    {
      __int32 v23 = result;
      if (a2 != a3)
      {
        float v24 = result;
        do
        {
          *(_DWORD *)float v24 = *v6;
          *((_DWORD *)v24 + 1) = v6[1];
          *((_DWORD *)v24 + 2) = v6[2];
          v23 += 12;
          v6 += 3;
          v24 += 12;
        }
        while (v6 != a3);
      }
      __int32 v17 = (char *)(v23 - result);
      uint64_t v13 = result;
    }
    else
    {
      long long v20 = &a2[3 * v19];
      if (v13 != result)
      {
        do
        {
          *(_DWORD *)__n128 result = *v6;
          *((_DWORD *)result + 1) = v6[1];
          *((_DWORD *)result + 2) = v6[2];
          v6 += 3;
          result += 12;
        }
        while (v6 != v20);
      }
      __int32 v21 = v13;
      if (v20 != a3)
      {
        int v22 = v13;
        do
        {
          *(_DWORD *)int v22 = *v20;
          *((_DWORD *)v22 + 1) = v20[1];
          *((_DWORD *)v22 + 2) = v20[2];
          v21 += 12;
          v20 += 3;
          v22 += 12;
        }
        while (v20 != a3);
      }
      __int32 v17 = (char *)(v21 - v13);
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 > 0x1555555555555555) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 2);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0xAAAAAAAAAAAAAAALL) {
      unint64_t v12 = 0x1555555555555555;
    }
    else {
      unint64_t v12 = v11;
    }
    __n128 result = std::vector<Vec3f>::__vallocate[abi:ne180100](a1, v12);
    uint64_t v15 = (char *)a1[1];
    uint64_t v14 = a1 + 1;
    uint64_t v13 = v15;
    uint64_t v16 = v15;
    if (v6 != a3)
    {
      uint64_t v16 = v13;
      do
      {
        *(_DWORD *)uint64_t v16 = *v6;
        *((_DWORD *)v16 + 1) = v6[1];
        *((_DWORD *)v16 + 2) = v6[2];
        v16 += 12;
        v6 += 3;
      }
      while (v6 != a3);
    }
    __int32 v17 = (char *)(v16 - v13);
  }
  *uint64_t v14 = &v17[(void)v13];
  return result;
}

char *std::vector<Vec3f>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x1555555555555556) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  __n128 result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Vec3f>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[12 * v4];
  return result;
}

char *std::vector<Vec3f>::__init_with_size[abi:ne180100]<Vec3f*,Vec3f*>(char *result, _DWORD *a2, _DWORD *a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    __n128 result = std::vector<Vec3f>::__vallocate[abi:ne180100](result, a4);
    unsigned int v7 = (_DWORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      *unsigned int v7 = *a2;
      v7[1] = a2[1];
      v7[2] = a2[2];
      v7 += 3;
      a2 += 3;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_1B7A3F5C0(_Unwind_Exception *exception_object)
{
  float v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void OMColorUtil::getRGBToYCbCrMatrix(int a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, Mat4f *a9@<X8>)
{
  *(void *)&long long v11 = 0;
  *((void *)&v11 + 1) = 0x3F80000000000000;
  if (a1 == 1)
  {
    *(void *)&long long v9 = 0xBEEB68E03F000000;
    *((void *)&v9 + 1) = 3173300474;
    Mat4f::Mat4f(a9, 0.2627, 0.678, 0.059302, 0.0, -0.13963, -0.36037, 0.5, 0.0, a2, a3, a4, a5, a6, a7, a8, v9, v11);
  }
  else
  {
    *(void *)&long long v10 = 0xBEE887123F000000;
    *((void *)&v10 + 1) = 3174811502;
    Mat4f::Mat4f(a9, 0.21264, 0.71517, 0.072192, 0.0, -0.11459, -0.38541, 0.5, 0.0, a2, a3, a4, a5, a6, a7, a8, v10, v11);
  }
}

void OMColorUtil::getRec2020to709Matrix(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, Mat4f *a8@<X8>)
{
  *(void *)&long long v10 = 0;
  *((void *)&v10 + 1) = 0x3F80000000000000;
  *(void *)&long long v9 = 0xBDCE075FBC95182BLL;
  *((void *)&v9 + 1) = 1066348944;
  Mat4f::Mat4f(a8, 1.6605, -0.5876, -0.0728, 0.0, -0.1246, 1.1329, -0.0083, 0.0, a1, a2, a3, a4, a5, a6, a7, v9, v10);
}

void OMColorUtil::Level4f(OMColorUtil *this@<X0>, float a2@<S0>, float a3@<S1>, float32x4_t *a4@<X8>)
{
  v14.var0[0] = a2;
  *(void *)&v14.var0[1] = 0;
  Mat4f::MakeHTrans((Mat4f *)v15, &v14);
  v12.var0[0] = (float)(a3 + 1.0) - a2;
  __asm { FMOV            V0.2S, #1.0 }
  *(void *)&v12.var0[1] = _D0;
  Mat4f::MakeHScale((Mat4f *)v13, &v12);
  Mat4f::operator*(v15, v13, a4);
}

float OMColorUtil::RGB2LumaHS(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OMColorUtil::getRGBToYCbCrMatrix(a3, a2, a3, a4, a5, a6, a7, a8, (Mat4f *)v19);
  uint64_t v16 = *a1;
  int v17 = *((_DWORD *)a1 + 2);
  int v18 = 1065353216;
  operator*(v19, (float *)&v16, (float *)v20);
  proj(v20, &v21, v10);
  float v11 = v21.f32[1];
  *(_DWORD *)a2 = v21.i32[0];
  float v12 = v22;
  float v13 = atan2f(v22, v11);
  if (v13 < 0.0) {
    float v13 = v13 + 6.2832;
  }
  float result = v13 / 6.2832;
  float v15 = sqrtf((float)(v11 * v11) + (float)(v12 * v12));
  *(float *)(a2 + 4) = result;
  *(float *)(a2 + 8) = v15 + v15;
  return result;
}

float OMKeyer2DColorUtil::rgb2hsl(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OMColorUtil::RGB2LumaHS(a1, (uint64_t)&v10, a3, a4, a5, a6, a7, a8);
  *(void *)a2 = v11;
  float result = v10;
  *(float *)(a2 + 8) = v10;
  return result;
}

void sub_1B7A40630(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

void sub_1B7A40BE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a16) {
    (*(void (**)(uint64_t))(*(void *)a16 + 24))(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B7A40D28(void *a1)
{
}

void sub_1B7A40F0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B7A411E4(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B7A41370(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B7A415F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a9) {
    (*(void (**)(uint64_t))(*(void *)a9 + 24))(a9);
  }
  (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
  if (a11) {
    (*(void (**)(uint64_t))(*(void *)a11 + 24))(a11);
  }
  _Unwind_Resume(a1);
}

const char *HgcRetimeAddBlend2::GetProgram(HgcRetimeAddBlend2 *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000031d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    output.color0 = float4(r0)*hg_Params[0];\n"
             "    output.color0 = float4(r1)*hg_Params[1] + output.color0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=a6f2738f:8a109c49:9f8e303a:93873d7d\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000300\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    output.color0 = r0*hg_Params[0];\n"
             "    output.color0 = r1*hg_Params[1] + output.color0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=1be635f9:660b7dcc:e57c3030:63e78bbe\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0002:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002d4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    gl_FragColor = r0*hg_ProgramLocal0;\n"
           "    gl_FragColor = r1*hg_ProgramLocal1 + gl_FragColor;\n"
           "}\n"
           "//MD5=429bb167:5e6f191c:22f11cc4:fb4e8fd4\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0002:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcRetimeAddBlend2::InitProgramDescriptor(HgcRetimeAddBlend2 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcRetimeAddBlend2_hgc_visible", "//Metal1.0     \n//LEN=0000000161\n[[ visible ]] FragmentOut HgcRetimeAddBlend2_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    output.color0 = r0*hg_Params[0];\n"
    "    output.color0 = r1*hg_Params[1] + output.color0;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcRetimeAddBlend2");
}

void sub_1B7A41810(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75630;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  float v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7A41950(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7A41998()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7A41990);
}

void *HgcRetimeAddBlend2::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcRetimeAddBlend2 [hgc1]");
}

uint64_t HgcRetimeAddBlend2::BindTexture(HgcRetimeAddBlend2 *this, HGHandler *a2, int a3)
{
  if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    uint64_t v4 = a2;
    int v5 = 1;
  }
  else
  {
    if (a3) {
      return 0xFFFFFFFFLL;
    }
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    uint64_t v4 = a2;
    int v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  int v6 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcRetimeAddBlend2::Bind(HgcRetimeAddBlend2 *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcRetimeAddBlend2::RenderTile(HgcRetimeAddBlend2 *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 12);
    uint64_t v7 = 16 * *((int *)a2 + 22);
    uint64_t v8 = *((void *)a2 + 10);
    uint64_t v9 = 16 * *((int *)a2 + 26);
    uint64_t v10 = 16 * *((int *)a2 + 6);
    do
    {
      if (v4 < 4)
      {
        LODWORD(v20) = 0;
      }
      else
      {
        int v11 = 0;
        uint64_t v12 = 32;
        do
        {
          float v13 = (float32x4_t *)*((void *)this + 51);
          float32x4_t v14 = v13[1];
          float32x4_t v15 = vaddq_f32(vmulq_f32(*(float32x4_t *)(v8 + v12 - 32), *v13), vmulq_f32(*(float32x4_t *)(v6 + v12 - 32), v14));
          float32x4_t v16 = vaddq_f32(vmulq_f32(*(float32x4_t *)(v8 + v12 - 16), *v13), vmulq_f32(*(float32x4_t *)(v6 + v12 - 16), v14));
          float32x4_t v17 = vaddq_f32(vmulq_f32(*(float32x4_t *)(v8 + v12), *v13), vmulq_f32(*(float32x4_t *)(v6 + v12), v14));
          float32x4_t v18 = vaddq_f32(vmulq_f32(*(float32x4_t *)(v8 + v12 + 16), *v13), vmulq_f32(*(float32x4_t *)(v6 + v12 + 16), v14));
          unint64_t v19 = (float32x4_t *)(v5 + v12);
          v19[-2] = v15;
          v19[-1] = v16;
          float32x4_t *v19 = v17;
          v19[1] = v18;
          v11 -= 4;
          v12 += 64;
        }
        while (v4 + v11 > 3);
        LODWORD(v20) = -v11;
      }
      if ((int)v20 < v4)
      {
        uint64_t v20 = v20;
        do
        {
          *(float32x4_t *)(v5 + 16 * v20) = vaddq_f32(vmulq_f32(*(float32x4_t *)(v8 + 16 * v20), *(float32x4_t *)*((void *)this + 51)), vmulq_f32(*(float32x4_t *)(v6 + 16 * v20), *(float32x4_t *)(*((void *)this + 51) + 16)));
          ++v20;
        }
        while (v20 < v4);
      }
      ++v3;
      v8 += v7;
      v6 += v9;
      v5 += v10;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcRetimeAddBlend2::GetDOD(HgcRetimeAddBlend2 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcRetimeAddBlend2::GetROI(HgcRetimeAddBlend2 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcRetimeAddBlend2::HgcRetimeAddBlend2(HgcRetimeAddBlend2 *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F11150D8;
  operator new();
}

void sub_1B7A41DD4(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcRetimeAddBlend2::~HgcRetimeAddBlend2(HGNode *this)
{
  *(void *)this = &unk_1F11150D8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40E0EAB150);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcRetimeAddBlend2::~HgcRetimeAddBlend2(this);

  HGObject::operator delete(v1);
}

uint64_t HgcRetimeAddBlend2::SetParameter(HgcRetimeAddBlend2 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  float *v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcRetimeAddBlend2::GetParameter(HgcRetimeAddBlend2 *this, unsigned int a2, float *a3)
{
  if (a2 > 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcInverseSimpleToneCurve::GetProgram(HgcInverseSimpleToneCurve *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000374\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fabs(r0.xyz)*half3(hg_Params[0].xyz);\n"
             "    r1.xyz = pow(r1.xyz, half3(hg_Params[1].xyz));\n"
             "    r2.xyz = r1.xyz*c0.xxx;\n"
             "    r0.xyz = half3(r0.xyz < c0.yyy);\n"
             "    output.color0.xyz = float3(r0.xyz)*float3(r2.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=bd3c0a0c:448bf4c3:fc12ffab:811426d6\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000344\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = fabs(r0.xyz)*hg_Params[0].xyz;\n"
             "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
             "    r2.xyz = r1.xyz*c0.xxx;\n"
             "    r0.xyz = float3(r0.xyz < c0.yyy);\n"
             "    output.color0.xyz = r0.xyz*r2.xyz + r1.xyz;\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=2a737f2f:14893905:3367d370:94190f6c\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000344\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = abs(r0.xyz)*hg_ProgramLocal0.xyz;\n"
           "    r1.xyz = pow(r1.xyz, hg_ProgramLocal1.xyz);\n"
           "    r2.xyz = r1.xyz*c0.xxx;\n"
           "    r0.xyz = vec3(lessThan(r0.xyz, c0.yyy));\n"
           "    gl_FragColor.xyz = r0.xyz*r2.xyz + r1.xyz;\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=25754dcf:39a6290c:71b65a47:d37941f7\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcInverseSimpleToneCurve::InitProgramDescriptor(HgcInverseSimpleToneCurve *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcInverseSimpleToneCurve_hgc_visible", "//Metal1.0     \n//LEN=0000000227\n[[ visible ]] FragmentOut HgcInverseSimpleToneCurve_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = fabs(r0.xyz)*hg_Params[0].xyz;\n"
    "    r1.xyz = pow(r1.xyz, hg_Params[1].xyz);\n"
    "    r2.xyz = r1.xyz*c0.xxx;\n"
    "    r0.xyz = float3(r0.xyz < c0.yyy);\n"
    "    output.color0.xyz = r0.xyz*r2.xyz + r1.xyz;\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcInverseSimpleToneCurve");
}

void sub_1B7A42064(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75630;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  float v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7A42164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7A421A4()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7A4219CLL);
}

void *HgcInverseSimpleToneCurve::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcInverseSimpleToneCurve [hgc1]");
}

uint64_t HgcInverseSimpleToneCurve::BindTexture(HgcInverseSimpleToneCurve *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcInverseSimpleToneCurve::Bind(HgcInverseSimpleToneCurve *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcInverseSimpleToneCurve::RenderTile(HgcInverseSimpleToneCurve *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    do
    {
      if (v4 < 2)
      {
        unsigned int v62 = 0;
      }
      else
      {
        int v9 = 0;
        uint64_t v10 = 16;
        do
        {
          float32x4_t v12 = *(float32x4_t *)(v6 + v10 - 16);
          float32x4_t v11 = *(float32x4_t *)(v6 + v10);
          uint64_t v13 = *((void *)this + 51);
          float32x4_t v14 = *(float32x4_t *)(v13 + 16);
          float32x4_t v15 = vmulq_f32(vabsq_f32(v12), *(float32x4_t *)v13);
          float32x4_t v16 = vmulq_f32(vabsq_f32(v11), *(float32x4_t *)v13);
          int8x16_t v17 = *(int8x16_t *)(v13 + 32);
          float32x4_t v18 = *(float32x4_t *)(v13 + 48);
          float32x4_t v19 = (float32x4_t)vorrq_s8(vandq_s8(v17, (int8x16_t)v15), (int8x16_t)v18);
          float32x4_t v20 = *(float32x4_t *)(v13 + 64);
          int8x16_t v21 = *(int8x16_t *)(v13 + 80);
          float32x4_t v22 = (float32x4_t)vorrq_s8(vandq_s8(v17, (int8x16_t)v16), (int8x16_t)v18);
          float32x4_t v23 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v15, 0x17uLL)), (float32x4_t)vandq_s8(v21, (int8x16_t)vcgtq_f32(v20, v15)));
          float32x4_t v24 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v16, 0x17uLL)), (float32x4_t)vandq_s8(v21, (int8x16_t)vcgtq_f32(v20, v16)));
          float32x4_t v25 = *(float32x4_t *)(v13 + 96);
          float32x4_t v26 = *(float32x4_t *)(v13 + 112);
          float32x4_t v27 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v19, v26));
          float32x4_t v28 = (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v22, v26));
          float32x4_t v29 = *(float32x4_t *)(v13 + 128);
          float32x4_t v30 = *(float32x4_t *)(v13 + 144);
          float32x4_t v31 = vsubq_f32(v24, v25);
          float32x4_t v32 = vaddq_f32(vsubq_f32(v23, v25), v27);
          float32x4_t v33 = vsubq_f32(vsubq_f32(v19, v18), vmulq_f32(vmulq_f32(v29, v27), v19));
          float32x4_t v34 = vsubq_f32(vsubq_f32(v22, v18), vmulq_f32(vmulq_f32(v29, v28), v22));
          float32x4_t v35 = *(float32x4_t *)(v13 + 160);
          float32x4_t v36 = *(float32x4_t *)(v13 + 176);
          float32x4_t v37 = *(float32x4_t *)(v13 + 192);
          float32x4_t v38 = *(float32x4_t *)(v13 + 208);
          float32x4_t v39 = vmaxq_f32(vmulq_f32(v14, vaddq_f32(v32, vmulq_f32(v33, vaddq_f32(vaddq_f32(v36, vmulq_f32(v33, v37)), vmulq_f32(vmulq_f32(v33, v33), vaddq_f32(v30, vmulq_f32(v35, v33))))))), v38);
          float32x4_t v40 = vmaxq_f32(vmulq_f32(v14, vaddq_f32(vaddq_f32(v31, v28), vmulq_f32(v34, vaddq_f32(vaddq_f32(v36, vmulq_f32(v34, v37)), vmulq_f32(vmulq_f32(v34, v34), vaddq_f32(v30, vmulq_f32(v35, v34))))))), v38);
          float32x4_t v41 = vcvtq_f32_s32(vcvtq_s32_f32(v39));
          float32x4_t v42 = vcvtq_f32_s32(vcvtq_s32_f32(v40));
          float32x4_t v43 = vsubq_f32(v41, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v41, v39)));
          float32x4_t v44 = vsubq_f32(v42, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v42, v40)));
          float32x4_t v45 = vsubq_f32(v39, v43);
          float32x4_t v46 = vsubq_f32(v40, v44);
          float32x4_t v47 = *(float32x4_t *)(v13 + 224);
          float32x4_t v48 = *(float32x4_t *)(v13 + 240);
          float32x4_t v49 = vaddq_f32(v47, vmulq_f32(v48, v45));
          float32x4_t v50 = vaddq_f32(v47, vmulq_f32(v48, v46));
          float32x4_t v51 = vmulq_f32(v45, v49);
          float32x4_t v52 = *(float32x4_t *)(v13 + 256);
          int32x4_t v53 = *(int32x4_t *)(v13 + 272);
          float32x4_t v54 = vmulq_f32(vaddq_f32(v18, vmulq_f32(v45, vaddq_f32(v52, v51))), (float32x4_t)vshlq_n_s32(vaddq_s32(v53, vcvtq_s32_f32(v43)), 0x17uLL));
          float32x4_t v55 = vmulq_f32(vaddq_f32(v18, vmulq_f32(v46, vaddq_f32(v52, vmulq_f32(v46, v50)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v53, vcvtq_s32_f32(v44)), 0x17uLL));
          float32x4_t v56 = *(float32x4_t *)(v13 + 288);
          float32x4_t v57 = *(float32x4_t *)(v13 + 304);
          int8x16_t v58 = vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v57, v12));
          int8x16_t v59 = vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v57, v11));
          int8x16_t v60 = *(int8x16_t *)(v13 + 320);
          int32x2_t v61 = (int8x16_t *)(v5 + v10);
          v61[-1] = vbslq_s8(v60, (int8x16_t)v12, (int8x16_t)vaddq_f32(v54, vmulq_f32(vmulq_f32(v56, v54), (float32x4_t)vbslq_s8(v60, (int8x16_t)v12, v58))));
          int8x16_t *v61 = vbslq_s8(v60, (int8x16_t)v11, (int8x16_t)vaddq_f32(v55, vmulq_f32(vmulq_f32(v56, v55), (float32x4_t)vbslq_s8(v60, (int8x16_t)v11, v59))));
          v9 -= 2;
          v10 += 32;
        }
        while (v4 + v9 > 1);
        unsigned int v62 = -v9;
      }
      if ((int)v62 < v4)
      {
        float32x4_t v63 = *(float32x4_t *)(v6 + 16 * v62);
        uint64_t v64 = *((void *)this + 51);
        float32x4_t v65 = vmulq_f32(vabsq_f32(v63), *(float32x4_t *)v64);
        float32x4_t v66 = *(float32x4_t *)(v64 + 48);
        float32x4_t v67 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v64 + 32), (int8x16_t)v65), (int8x16_t)v66);
        float32x4_t v68 = (float32x4_t)vandq_s8((int8x16_t)v66, (int8x16_t)vcgtq_f32(v67, *(float32x4_t *)(v64 + 112)));
        float32x4_t v69 = vsubq_f32(vsubq_f32(v67, v66), vmulq_f32(vmulq_f32(*(float32x4_t *)(v64 + 128), v68), v67));
        float32x4_t v70 = vmaxq_f32(vmulq_f32(*(float32x4_t *)(v64 + 16), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v65, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v64 + 80), (int8x16_t)vcgtq_f32(*(float32x4_t *)(v64 + 64), v65))), *(float32x4_t *)(v64 + 96)), v68), vmulq_f32(v69, vaddq_f32(vaddq_f32(*(float32x4_t *)(v64 + 176), vmulq_f32(v69, *(float32x4_t *)(v64 + 192))), vmulq_f32(vmulq_f32(v69, v69), vaddq_f32(*(float32x4_t *)(v64 + 144), vmulq_f32(*(float32x4_t *)(v64 + 160), v69))))))),
                *(float32x4_t *)(v64 + 208));
        float32x4_t v71 = vcvtq_f32_s32(vcvtq_s32_f32(v70));
        float32x4_t v72 = vsubq_f32(v71, (float32x4_t)vandq_s8((int8x16_t)v66, (int8x16_t)vcgtq_f32(v71, v70)));
        float32x4_t v73 = vsubq_f32(v70, v72);
        float32x4_t v74 = vmulq_f32(vaddq_f32(v66, vmulq_f32(v73, vaddq_f32(*(float32x4_t *)(v64 + 256), vmulq_f32(v73, vaddq_f32(*(float32x4_t *)(v64 + 224), vmulq_f32(*(float32x4_t *)(v64 + 240), v73)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v64 + 272), vcvtq_s32_f32(v72)), 0x17uLL));
        *(int8x16_t *)(v5 + 16 * v62) = vbslq_s8(*(int8x16_t *)(v64 + 320), (int8x16_t)v63, (int8x16_t)vaddq_f32(v74, vmulq_f32(vmulq_f32(*(float32x4_t *)(v64 + 288), v74), (float32x4_t)vbslq_s8(*(int8x16_t *)(v64 + 320), (int8x16_t)v63, vandq_s8((int8x16_t)v66, (int8x16_t)vcgtq_f32(*(float32x4_t *)(v64 + 304), v63))))));
      }
      v6 += v8;
      v5 += v7;
      ++v3;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcInverseSimpleToneCurve::GetDOD(HgcInverseSimpleToneCurve *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcInverseSimpleToneCurve::GetROI(HgcInverseSimpleToneCurve *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcInverseSimpleToneCurve::HgcInverseSimpleToneCurve(HgcInverseSimpleToneCurve *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F1115340;
  operator new();
}

void sub_1B7A4286C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcInverseSimpleToneCurve::~HgcInverseSimpleToneCurve(HGNode *this)
{
  *(void *)this = &unk_1F1115340;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C409BD2D9E4);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcInverseSimpleToneCurve::~HgcInverseSimpleToneCurve(this);

  HGObject::operator delete(v1);
}

uint64_t HgcInverseSimpleToneCurve::SetParameter(HgcInverseSimpleToneCurve *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  if (a2 == 1)
  {
    uint64_t v9 = *((void *)this + 51);
    if (*(float *)(v9 + 16) != a3.n128_f32[0]
      || *(float *)(v9 + 20) != a3.n128_f32[0]
      || *(float *)(v9 + 24) != a3.n128_f32[0]
      || *(float *)(v9 + 28) != 0.0)
    {
      int32x4_t v10 = vzip1q_s32((int32x4_t)a3.n128_u32[0], (int32x4_t)a3.n128_u32[0]);
      v10.i32[2] = a3.n128_u32[0];
      a3.n128_f32[1] = a4;
      *(int32x4_t *)(v9 + 16) = v10;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      *(__n128 *)(v9 + 352) = a3;
      goto LABEL_13;
    }
    return 0;
  }
  if (!a2)
  {
    uint64_t v7 = *((void *)this + 51);
    if (*(float *)v7 != a3.n128_f32[0]
      || *(float *)(v7 + 4) != a3.n128_f32[0]
      || *(float *)(v7 + 8) != a3.n128_f32[0]
      || *(float *)(v7 + 12) != 0.0)
    {
      int32x4_t v8 = vzip1q_s32((int32x4_t)a3.n128_u32[0], (int32x4_t)a3.n128_u32[0]);
      v8.i32[2] = a3.n128_u32[0];
      a3.n128_f32[1] = a4;
      *(int32x4_t *)uint64_t v7 = v8;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      *(__n128 *)(v7 + 336) = a3;
LABEL_13:
      HGNode::ClearBits((HGNode *)this, a2, a7);
      return 1;
    }
    return 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t HgcInverseSimpleToneCurve::GetParameter(HgcInverseSimpleToneCurve *this, int a2, float *a3)
{
  if (a2 == 1)
  {
    uint64_t v5 = (float *)*((void *)this + 51);
    *a3 = v5[88];
    a3[1] = v5[89];
    a3[2] = v5[90];
    int v4 = v5 + 91;
    goto LABEL_5;
  }
  if (!a2)
  {
    int v3 = (float *)*((void *)this + 51);
    *a3 = v3[84];
    a3[1] = v3[85];
    a3[2] = v3[86];
    int v4 = v3 + 87;
LABEL_5:
    uint64_t result = 0;
    a3[3] = *v4;
    return result;
  }
  return 0xFFFFFFFFLL;
}

const char *HgcSimpleToneCurve::GetProgram(HgcSimpleToneCurve *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000374\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(-2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = pow(fabs(r0.xyz), half3(hg_Params[1].xyz));\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[0].xyz);\n"
             "    r2.xyz = r1.xyz*c0.xxx;\n"
             "    r0.xyz = half3(r0.xyz < c0.yyy);\n"
             "    output.color0.xyz = float3(r0.xyz)*float3(r2.xyz) + float3(r1.xyz);\n"
             "    output.color0.w = float(r0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=121c40eb:fea358e3:1c5eacae:1ed8c37c\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000344\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(-2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = pow(fabs(r0.xyz), hg_Params[1].xyz);\n"
             "    r1.xyz = r1.xyz*hg_Params[0].xyz;\n"
             "    r2.xyz = r1.xyz*c0.xxx;\n"
             "    r0.xyz = float3(r0.xyz < c0.yyy);\n"
             "    output.color0.xyz = r0.xyz*r2.xyz + r1.xyz;\n"
             "    output.color0.w = r0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=6df6fe31:0f0f92a3:1cae0ccc:4b490fb3\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0002:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000344\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(-2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = pow(abs(r0.xyz), hg_ProgramLocal1.xyz);\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal0.xyz;\n"
           "    r2.xyz = r1.xyz*c0.xxx;\n"
           "    r0.xyz = vec3(lessThan(r0.xyz, c0.yyy));\n"
           "    gl_FragColor.xyz = r0.xyz*r2.xyz + r1.xyz;\n"
           "    gl_FragColor.w = r0.w;\n"
           "}\n"
           "//MD5=6d930ca3:a6a50e9c:15819e55:a3a8ad06\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0002:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcSimpleToneCurve::InitProgramDescriptor(HgcSimpleToneCurve *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcSimpleToneCurve_hgc_visible", "//Metal1.0     \n//LEN=0000000220\n[[ visible ]] FragmentOut HgcSimpleToneCurve_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(-2.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = pow(fabs(r0.xyz), hg_Params[1].xyz);\n"
    "    r1.xyz = r1.xyz*hg_Params[0].xyz;\n"
    "    r2.xyz = r1.xyz*c0.xxx;\n"
    "    r0.xyz = float3(r0.xyz < c0.yyy);\n"
    "    output.color0.xyz = r0.xyz*r2.xyz + r1.xyz;\n"
    "    output.color0.w = r0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcSimpleToneCurve");
}

void sub_1B7A42B84(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75630;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  float32x4_t v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7A42C84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7A42CC4()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7A42CBCLL);
}

void *HgcSimpleToneCurve::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcSimpleToneCurve [hgc1]");
}

uint64_t HgcSimpleToneCurve::BindTexture(HgcSimpleToneCurve *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcSimpleToneCurve::Bind(HgcSimpleToneCurve *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcSimpleToneCurve::RenderTile(HgcSimpleToneCurve *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    do
    {
      if (v4 < 2)
      {
        unsigned int v66 = 0;
      }
      else
      {
        int v9 = 0;
        uint64_t v10 = 16;
        do
        {
          float32x4_t v12 = *(float32x4_t *)(v6 + v10 - 16);
          float32x4_t v11 = *(float32x4_t *)(v6 + v10);
          float32x4_t v13 = vabsq_f32(v12);
          uint64_t v14 = *((void *)this + 51);
          int8x16_t v16 = *(int8x16_t *)(v14 + 32);
          float32x4_t v15 = *(float32x4_t *)(v14 + 48);
          float32x4_t v17 = vabsq_f32(v11);
          float32x4_t v18 = (float32x4_t)vorrq_s8(vandq_s8(v16, (int8x16_t)v13), (int8x16_t)v15);
          float32x4_t v19 = *(float32x4_t *)(v14 + 64);
          int8x16_t v20 = *(int8x16_t *)(v14 + 80);
          float32x4_t v21 = (float32x4_t)vorrq_s8(vandq_s8(v16, (int8x16_t)v17), (int8x16_t)v15);
          int8x16_t v22 = (int8x16_t)vcgtq_f32(v19, v13);
          float32x4_t v23 = (float32x4_t)vandq_s8(v20, (int8x16_t)vcgtq_f32(v19, v17));
          float32x4_t v24 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v13, 0x17uLL)), (float32x4_t)vandq_s8(v20, v22));
          float32x4_t v25 = *(float32x4_t *)(v14 + 96);
          float32x4_t v26 = *(float32x4_t *)(v14 + 112);
          float32x4_t v27 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)), v23);
          float32x4_t v28 = vsubq_f32(v24, v25);
          float32x4_t v29 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v18, v26));
          float32x4_t v30 = (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v21, v26));
          float32x4_t v31 = vsubq_f32(v27, v25);
          float32x4_t v32 = *(float32x4_t *)(v14 + 128);
          float32x4_t v33 = *(float32x4_t *)(v14 + 144);
          float32x4_t v34 = vsubq_f32(vsubq_f32(v18, v15), vmulq_f32(vmulq_f32(v32, v29), v18));
          float32x4_t v35 = vsubq_f32(vsubq_f32(v21, v15), vmulq_f32(vmulq_f32(v32, v30), v21));
          float32x4_t v36 = *(float32x4_t *)(v14 + 160);
          float32x4_t v37 = *(float32x4_t *)(v14 + 176);
          float32x4_t v38 = vaddq_f32(v33, vmulq_f32(v36, v34));
          float32x4_t v39 = vaddq_f32(v33, vmulq_f32(v36, v35));
          float32x4_t v40 = *(float32x4_t *)(v14 + 192);
          float32x4_t v41 = *(float32x4_t *)(v14 + 208);
          float32x4_t v42 = vaddq_f32(vaddq_f32(v31, v30), vmulq_f32(v35, vaddq_f32(vaddq_f32(v37, vmulq_f32(v35, v40)), vmulq_f32(vmulq_f32(v35, v35), v39))));
          float32x4_t v43 = *(float32x4_t *)(v14 + 16);
          float32x4_t v44 = vmaxq_f32(vmulq_f32(v43, vaddq_f32(vaddq_f32(v28, v29), vmulq_f32(v34, vaddq_f32(vaddq_f32(v37, vmulq_f32(v34, v40)), vmulq_f32(vmulq_f32(v34, v34), v38))))), v41);
          float32x4_t v45 = vmaxq_f32(vmulq_f32(v43, v42), v41);
          float32x4_t v46 = vcvtq_f32_s32(vcvtq_s32_f32(v44));
          float32x4_t v47 = vcvtq_f32_s32(vcvtq_s32_f32(v45));
          float32x4_t v48 = vsubq_f32(v46, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v46, v44)));
          float32x4_t v49 = vsubq_f32(v47, (float32x4_t)vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v47, v45)));
          float32x4_t v50 = vsubq_f32(v44, v48);
          float32x4_t v51 = *(float32x4_t *)(v14 + 224);
          float32x4_t v52 = *(float32x4_t *)(v14 + 240);
          float32x4_t v53 = vsubq_f32(v45, v49);
          float32x4_t v54 = vaddq_f32(v51, vmulq_f32(v52, v50));
          float32x4_t v55 = vaddq_f32(v51, vmulq_f32(v52, v53));
          float32x4_t v56 = *(float32x4_t *)(v14 + 256);
          int32x4_t v57 = *(int32x4_t *)(v14 + 272);
          float32x4_t v58 = vmulq_f32(*(float32x4_t *)v14, vmulq_f32(vaddq_f32(v15, vmulq_f32(v50, vaddq_f32(v56, vmulq_f32(v50, v54)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v57, vcvtq_s32_f32(v48)), 0x17uLL)));
          float32x4_t v59 = vmulq_f32(*(float32x4_t *)v14, vmulq_f32(vaddq_f32(v15, vmulq_f32(v53, vaddq_f32(v56, vmulq_f32(v53, v55)))), (float32x4_t)vshlq_n_s32(vaddq_s32(v57, vcvtq_s32_f32(v49)), 0x17uLL)));
          float32x4_t v60 = *(float32x4_t *)(v14 + 288);
          float32x4_t v61 = *(float32x4_t *)(v14 + 304);
          int8x16_t v62 = vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v61, v12));
          int8x16_t v63 = vandq_s8((int8x16_t)v15, (int8x16_t)vcgtq_f32(v61, v11));
          int8x16_t v64 = *(int8x16_t *)(v14 + 320);
          float32x4_t v65 = (int8x16_t *)(v5 + v10);
          v65[-1] = vbslq_s8(v64, (int8x16_t)v12, (int8x16_t)vaddq_f32(v58, vmulq_f32(vmulq_f32(v60, v58), (float32x4_t)vbslq_s8(v64, (int8x16_t)v12, v62))));
          int8x16_t *v65 = vbslq_s8(v64, (int8x16_t)v11, (int8x16_t)vaddq_f32(v59, vmulq_f32(vmulq_f32(v60, v59), (float32x4_t)vbslq_s8(v64, (int8x16_t)v11, v63))));
          v9 -= 2;
          v10 += 32;
        }
        while (v4 + v9 > 1);
        unsigned int v66 = -v9;
      }
      if ((int)v66 < v4)
      {
        float32x4_t v67 = *(float32x4_t *)(v6 + 16 * v66);
        float32x4_t v68 = vabsq_f32(v67);
        uint64_t v69 = *((void *)this + 51);
        float32x4_t v70 = *(float32x4_t *)(v69 + 48);
        float32x4_t v71 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v69 + 32), (int8x16_t)v68), (int8x16_t)v70);
        float32x4_t v72 = (float32x4_t)vandq_s8((int8x16_t)v70, (int8x16_t)vcgtq_f32(v71, *(float32x4_t *)(v69 + 112)));
        float32x4_t v73 = vsubq_f32(vsubq_f32(v71, v70), vmulq_f32(vmulq_f32(*(float32x4_t *)(v69 + 128), v72), v71));
        float32x4_t v74 = vmaxq_f32(vmulq_f32(*(float32x4_t *)(v69 + 16), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v68, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v69 + 80), (int8x16_t)vcgtq_f32(*(float32x4_t *)(v69 + 64), v68))), *(float32x4_t *)(v69 + 96)), v72), vmulq_f32(v73, vaddq_f32(vaddq_f32(*(float32x4_t *)(v69 + 176), vmulq_f32(v73, *(float32x4_t *)(v69 + 192))), vmulq_f32(vmulq_f32(v73, v73), vaddq_f32(*(float32x4_t *)(v69 + 144), vmulq_f32(*(float32x4_t *)(v69 + 160), v73))))))),
                *(float32x4_t *)(v69 + 208));
        float32x4_t v75 = vcvtq_f32_s32(vcvtq_s32_f32(v74));
        float32x4_t v76 = vsubq_f32(v75, (float32x4_t)vandq_s8((int8x16_t)v70, (int8x16_t)vcgtq_f32(v75, v74)));
        float32x4_t v77 = vsubq_f32(v74, v76);
        float32x4_t v78 = vmulq_f32(*(float32x4_t *)v69, vmulq_f32(vaddq_f32(v70, vmulq_f32(v77, vaddq_f32(*(float32x4_t *)(v69 + 256), vmulq_f32(v77, vaddq_f32(*(float32x4_t *)(v69 + 224), vmulq_f32(*(float32x4_t *)(v69 + 240), v77)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v69 + 272), vcvtq_s32_f32(v76)), 0x17uLL)));
        *(int8x16_t *)(v5 + 16 * v66) = vbslq_s8(*(int8x16_t *)(v69 + 320), (int8x16_t)v67, (int8x16_t)vaddq_f32(v78, vmulq_f32(vmulq_f32(*(float32x4_t *)(v69 + 288), v78), (float32x4_t)vbslq_s8(*(int8x16_t *)(v69 + 320), (int8x16_t)v67, vandq_s8((int8x16_t)v70, (int8x16_t)vcgtq_f32(*(float32x4_t *)(v69 + 304), v67))))));
      }
      v6 += v8;
      v5 += v7;
      ++v3;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcSimpleToneCurve::GetDOD(HgcSimpleToneCurve *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcSimpleToneCurve::GetROI(HgcSimpleToneCurve *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcSimpleToneCurve::HgcSimpleToneCurve(HgcSimpleToneCurve *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F11155A8;
  operator new();
}

void sub_1B7A4338C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcSimpleToneCurve::~HgcSimpleToneCurve(HGNode *this)
{
  *(void *)this = &unk_1F11155A8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C409BD2D9E4);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcSimpleToneCurve::~HgcSimpleToneCurve(this);

  HGObject::operator delete(v1);
}

uint64_t HgcSimpleToneCurve::SetParameter(HgcSimpleToneCurve *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  if (a2 == 1)
  {
    uint64_t v9 = *((void *)this + 51);
    if (*(float *)(v9 + 16) != a3.n128_f32[0]
      || *(float *)(v9 + 20) != a3.n128_f32[0]
      || *(float *)(v9 + 24) != a3.n128_f32[0]
      || *(float *)(v9 + 28) != 0.0)
    {
      int32x4_t v10 = vzip1q_s32((int32x4_t)a3.n128_u32[0], (int32x4_t)a3.n128_u32[0]);
      v10.i32[2] = a3.n128_u32[0];
      a3.n128_f32[1] = a4;
      *(int32x4_t *)(v9 + 16) = v10;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      *(__n128 *)(v9 + 352) = a3;
      goto LABEL_13;
    }
    return 0;
  }
  if (!a2)
  {
    uint64_t v7 = *((void *)this + 51);
    if (*(float *)v7 != a3.n128_f32[0]
      || *(float *)(v7 + 4) != a3.n128_f32[0]
      || *(float *)(v7 + 8) != a3.n128_f32[0]
      || *(float *)(v7 + 12) != 0.0)
    {
      int32x4_t v8 = vzip1q_s32((int32x4_t)a3.n128_u32[0], (int32x4_t)a3.n128_u32[0]);
      v8.i32[2] = a3.n128_u32[0];
      a3.n128_f32[1] = a4;
      *(int32x4_t *)uint64_t v7 = v8;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      *(__n128 *)(v7 + 336) = a3;
LABEL_13:
      HGNode::ClearBits((HGNode *)this, a2, a7);
      return 1;
    }
    return 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t HgcSimpleToneCurve::GetParameter(HgcSimpleToneCurve *this, int a2, float *a3)
{
  if (a2 == 1)
  {
    uint64_t v5 = (float *)*((void *)this + 51);
    *a3 = v5[88];
    a3[1] = v5[89];
    a3[2] = v5[90];
    int v4 = v5 + 91;
    goto LABEL_5;
  }
  if (!a2)
  {
    int v3 = (float *)*((void *)this + 51);
    *a3 = v3[84];
    a3[1] = v3[85];
    a3[2] = v3[86];
    int v4 = v3 + 87;
LABEL_5:
    uint64_t result = 0;
    a3[3] = *v4;
    return result;
  }
  return 0xFFFFFFFFLL;
}

const char *HgcRenderToEquirect::GetProgram(HgcRenderToEquirect *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return aMetal10Len0000_1314;
    }
    else {
      return aMetal10Len0000_1315;
    }
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return aGlfs20Len00000_487;
  }
}

void HgcRenderToEquirect::InitProgramDescriptor(HgcRenderToEquirect *this, HGProgramDescriptor *a2)
{
}

void sub_1B7A436A4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B837AE90;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 9;
  std::string::basic_string[abi:ne180100]<0>(v34, "texture2d<float>");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 6;
  std::string::basic_string[abi:ne180100]<0>(v34, "sampler");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 9;
  std::string::basic_string[abi:ne180100]<0>(v34, "texture2d<float>");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 6;
  std::string::basic_string[abi:ne180100]<0>(v34, "sampler");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 9;
  std::string::basic_string[abi:ne180100]<0>(v34, "texture2d<float>");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 6;
  std::string::basic_string[abi:ne180100]<0>(v34, "sampler");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 9;
  std::string::basic_string[abi:ne180100]<0>(v34, "texture2d<float>");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 6;
  std::string::basic_string[abi:ne180100]<0>(v34, "sampler");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 9;
  std::string::basic_string[abi:ne180100]<0>(v34, "texture2d<float>");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 6;
  std::string::basic_string[abi:ne180100]<0>(v34, "sampler");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 9;
  std::string::basic_string[abi:ne180100]<0>(v34, "texture2d<float>");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 6;
  std::string::basic_string[abi:ne180100]<0>(v34, "sampler");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 8;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  float32x4_t v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7A43AA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7A43B44()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7A43B3CLL);
}

void *HgcRenderToEquirect::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcRenderToEquirect [hgc1]");
}

uint64_t HgcRenderToEquirect::BindTexture(HgcRenderToEquirect *this, HGHandler *a2, int a3)
{
  switch(a3)
  {
    case 0:
      int v4 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
      v7.n128_f32[0] = (float)*((int *)a2 + 60);
      v8.n128_f32[0] = (float)*((int *)a2 + 61);
      if (v4)
      {
        uint64_t v9 = *(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136);
        v5.n128_u32[0] = 1.0;
        v6.n128_u32[0] = 1.0;
      }
      else
      {
        v5.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
        uint64_t v9 = *(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136);
        v6.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
      }
      int8x16_t v16 = a2;
      uint64_t v17 = 19;
      goto LABEL_27;
    case 1:
      int v11 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
      v7.n128_f32[0] = (float)*((int *)a2 + 60);
      v8.n128_f32[0] = (float)*((int *)a2 + 61);
      if (v11)
      {
        uint64_t v9 = *(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136);
        v5.n128_u32[0] = 1.0;
        v6.n128_u32[0] = 1.0;
      }
      else
      {
        v5.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
        uint64_t v9 = *(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136);
        v6.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
      }
      int8x16_t v16 = a2;
      uint64_t v17 = 18;
      goto LABEL_27;
    case 2:
      int v12 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
      v7.n128_f32[0] = (float)*((int *)a2 + 60);
      v8.n128_f32[0] = (float)*((int *)a2 + 61);
      if (v12)
      {
        uint64_t v9 = *(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136);
        v5.n128_u32[0] = 1.0;
        v6.n128_u32[0] = 1.0;
      }
      else
      {
        v5.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
        uint64_t v9 = *(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136);
        v6.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
      }
      int8x16_t v16 = a2;
      uint64_t v17 = 20;
      goto LABEL_27;
    case 3:
      int v13 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
      v7.n128_f32[0] = (float)*((int *)a2 + 60);
      v8.n128_f32[0] = (float)*((int *)a2 + 61);
      if (v13)
      {
        uint64_t v9 = *(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136);
        v5.n128_u32[0] = 1.0;
        v6.n128_u32[0] = 1.0;
      }
      else
      {
        v5.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
        uint64_t v9 = *(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136);
        v6.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
      }
      int8x16_t v16 = a2;
      uint64_t v17 = 21;
      goto LABEL_27;
    case 4:
      int v14 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
      v7.n128_f32[0] = (float)*((int *)a2 + 60);
      v8.n128_f32[0] = (float)*((int *)a2 + 61);
      if (v14)
      {
        uint64_t v9 = *(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136);
        v5.n128_u32[0] = 1.0;
        v6.n128_u32[0] = 1.0;
      }
      else
      {
        v5.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
        uint64_t v9 = *(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136);
        v6.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
      }
      int8x16_t v16 = a2;
      uint64_t v17 = 22;
      goto LABEL_27;
    case 5:
      int v15 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
      v7.n128_f32[0] = (float)*((int *)a2 + 60);
      v8.n128_f32[0] = (float)*((int *)a2 + 61);
      if (v15)
      {
        uint64_t v9 = *(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136);
        v5.n128_u32[0] = 1.0;
        v6.n128_u32[0] = 1.0;
      }
      else
      {
        v5.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
        uint64_t v9 = *(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136);
        v6.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
      }
      int8x16_t v16 = a2;
      uint64_t v17 = 23;
LABEL_27:
      v9(v16, v17, v7, v8, v5, v6);
      uint64_t result = 0;
      break;
    default:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t HgcRenderToEquirect::Bind(HgcRenderToEquirect *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcRenderToEquirect::RenderTile(HgcRenderToEquirect *this, HGTile *a2)
{
  uint64_t v4 = HGTile::Renderer(a2);
  int v5 = (*(uint64_t (**)(HgcRenderToEquirect *, uint64_t))(*(void *)this + 312))(this, v4);
  int32x2_t v6 = *(int32x2_t *)a2;
  int v7 = *((_DWORD *)a2 + 3) - HIDWORD(*(void *)a2);
  if (v7 >= 1)
  {
    int v8 = 0;
    *(float32x2_t *)v9.i8 = vadd_f32(vcvt_f32_s32(v6), (float32x2_t)0x3F0000003F000000);
    v9.i64[1] = 0x3F80000000000000;
    int v10 = *((_DWORD *)a2 + 2) - v6.i32[0];
    uint64_t v11 = *((void *)a2 + 2);
    uint64_t v12 = 16 * *((int *)a2 + 6);
    v13.i64[0] = 0x3F0000003F000000;
    v13.i64[1] = 0x3F0000003F000000;
    float32x4_t v14 = (float32x4_t)v9;
    do
    {
      if (v10 >= 1)
      {
        uint64_t v15 = 0;
        float32x4_t v16 = v14;
        do
        {
          uint64_t v17 = (long long *)*((void *)this + 51);
          int8x16_t v18 = (int8x16_t)*v17;
          float32x4_t v19 = (float32x4_t)vextq_s8(*((int8x16_t *)v17 + 1), *((int8x16_t *)v17 + 1), 8uLL);
          float32x4_t v20 = (float32x4_t)v17[18];
          int8x16_t v22 = (int8x16_t)v17[19];
          float32x4_t v21 = (float32x4_t)v17[20];
          float32x4_t v23 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v19), v20), (float32x4_t)v22), v21);
          int8x16_t v24 = (int8x16_t)vmulq_f32(v23, vrecpsq_f32(v19, v23));
          float32x4_t v25 = (float32x4_t)vextq_s8(*((int8x16_t *)v17 + 2), *((int8x16_t *)v17 + 2), 4uLL);
          float32x4_t v26 = vminq_f32(vmaxq_f32(vmulq_f32((float32x4_t)v22, vrecpeq_f32(v25)), v20), v21);
          int8x16_t v27 = (int8x16_t)vmulq_f32(v26, vrecpsq_f32(v25, v26));
          int8x16_t v28 = (int8x16_t)v17[21];
          int8x16_t v29 = (int8x16_t)v17[22];
          int8x16_t v30 = vbslq_s8(v28, v24, v27);
          int8x16_t v31 = (int8x16_t)vmulq_f32(v16, *((float32x4_t *)v17 + 4));
          int8x16_t v32 = (int8x16_t)vaddq_f32((float32x4_t)v31, (float32x4_t)vextq_s8(v31, v31, 4uLL));
          v32.i64[0] = vaddq_f32((float32x4_t)v32, (float32x4_t)vdupq_laneq_s64((int64x2_t)v32, 1)).u64[0];
          v32.i64[1] = v30.i64[1];
          int8x16_t v33 = (int8x16_t)vmulq_f32(v16, *((float32x4_t *)v17 + 3));
          int8x16_t v34 = (int8x16_t)vaddq_f32((float32x4_t)v33, (float32x4_t)vextq_s8(v33, v33, 4uLL));
          float32x4_t v35 = (float32x4_t)vbslq_s8(v29, (int8x16_t)vaddq_f32((float32x4_t)v34, (float32x4_t)vextq_s8(v34, v34, 8uLL)), v32);
          v36.i64[0] = vaddq_f32(*((float32x4_t *)v17 + 17), v35).u64[0];
          v36.i64[1] = v35.i64[1];
          int8x16_t v37 = (int8x16_t)vmulq_laneq_f32(v36, v35, 2);
          float32x4_t v38 = (float32x4_t)vbslq_s8(v29, v37, (int8x16_t)v36);
          int8x16_t v39 = (int8x16_t)vmulq_laneq_f32(v38, v38, 3);
          v22.i64[0] = vbslq_s8(v29, (int8x16_t)vaddq_f32(v20, vmulq_f32((float32x4_t)v22, (float32x4_t)vbslq_s8(v29, v37, v39))), v39).u64[0];
          float32x4_t v40 = (float32x4_t)v17[23];
          int8x16_t v41 = (int8x16_t)v17[24];
          float32x4_t v42 = vmulq_n_f32(v40, *(float *)v22.i32);
          float32x4_t v43 = vcvtq_f32_s32(vcvtq_s32_f32(v42));
          float32x4_t v44 = vsubq_f32(v42, vsubq_f32(v43, (float32x4_t)vandq_s8(v41, (int8x16_t)vcgtq_f32(v43, v42))));
          float32x4_t v45 = (float32x4_t)v17[25];
          float32x4_t v46 = (float32x4_t)v17[26];
          float32x4_t v47 = vsubq_f32(vabdq_f32(v44, v45), v46);
          float32x4_t v48 = vmulq_f32(v47, v47);
          int8x16_t v50 = (int8x16_t)v17[27];
          float32x4_t v49 = (float32x4_t)v17[28];
          int8x16_t v51 = (int8x16_t)v17[29];
          int8x16_t v52 = (int8x16_t)v17[30];
          v22.i64[1] = vmulq_f32(v47, vaddq_f32(*(float32x4_t *)&v52, vmulq_f32(v48, vaddq_f32(*(float32x4_t *)&v51, vmulq_f32(v48, vaddq_f32(v49, vmulq_f32(*(float32x4_t *)&v50, v48))))))).i64[1];
          int8x16_t v54 = (int8x16_t)v17[31];
          float32x4_t v53 = (float32x4_t)v17[32];
          int8x16_t v55 = vbslq_s8(v54, (int8x16_t)vmulq_laneq_f32((float32x4_t)v22, (float32x4_t)v52, 2), v22);
          float32x4_t v56 = vaddq_f32(v49, vmulq_lane_f32((float32x4_t)v51, *(float32x2_t *)v55.i8, 1));
          float32x4_t v57 = vcvtq_f32_s32(vcvtq_s32_f32(v56));
          float32x4_t v58 = vaddq_f32(v49, vabdq_f32(vsubq_f32(v56, vsubq_f32(v57, (float32x4_t)vandq_s8(v50, (int8x16_t)vcgtq_f32(v57, v56)))), v46));
          float32x4_t v59 = vmulq_f32(v58, v58);
          int8x16_t v60 = vbslq_s8(v28, (int8x16_t)vmulq_f32(v58, vaddq_f32(v53, vmulq_f32(v59, vaddq_f32(v40, vmulq_f32(v59, vaddq_f32((float32x4_t)v41, vmulq_f32(v45, v59))))))), v55);
          float32x4_t v61 = vaddq_f32((float32x4_t)v52, vmulq_f32(v53, (float32x4_t)v60));
          float32x4_t v62 = vcvtq_f32_s32(vcvtq_s32_f32(v61));
          float32x4_t v63 = vaddq_f32((float32x4_t)v52, vabdq_f32(vsubq_f32(v61, vsubq_f32(v62, (float32x4_t)vandq_s8(v51, (int8x16_t)vcgtq_f32(v62, v61)))), v49));
          float32x4_t v64 = vmulq_f32(v63, v63);
          float32x4_t v65 = (float32x4_t)vbslq_s8(v29, (int8x16_t)vmulq_f32(v63, vaddq_f32((float32x4_t)v41, vmulq_f32(v64, vaddq_f32(v45, vmulq_f32(v64, vaddq_f32(v46, vmulq_f32((float32x4_t)v50, v64))))))), v60);
          int8x16_t v66 = vbslq_s8(v29, (int8x16_t)vmulq_laneq_f32(v65, v65, 2), v60);
          v66.i64[1] = vmulq_laneq_f32(*(float32x4_t *)&v66, *(float32x4_t *)&v66, 3).i64[1];
          float32x4_t v67 = vmulq_f32(v53, (float32x4_t)v66);
          float32x4_t v68 = vcvtq_f32_s32(vcvtq_s32_f32(v67));
          float32x4_t v69 = vsubq_f32(vabdq_f32(vsubq_f32(v67, vsubq_f32(v68, (float32x4_t)vandq_s8(v52, (int8x16_t)vcgtq_f32(v68, v67)))), (float32x4_t)v51), v49);
          float32x4_t v70 = vmulq_f32(v69, v69);
          int8x16_t v71 = vbslq_s8(v54, (int8x16_t)vmulq_f32(v69, vaddq_f32((float32x4_t)v41, vmulq_f32(v70, vaddq_f32(v45, vmulq_f32(v70, vaddq_f32(v46, vmulq_f32((float32x4_t)v50, v70))))))), v66);
          int8x16_t v72 = (int8x16_t)vabsq_f32((float32x4_t)v71);
          int8x16_t v74 = (int8x16_t)v17[33];
          int8x16_t v73 = (int8x16_t)v17[34];
          float32x4_t v75 = (float32x4_t)vbslq_s8(v74, (int8x16_t)vmaxq_f32((float32x4_t)vbslq_s8(v74, (int8x16_t)vmaxq_f32((float32x4_t)vextq_s8(v72, v72, 4uLL), (float32x4_t)vextq_s8(v72, v72, 8uLL)), v71), (float32x4_t)vrev64q_s32((int32x4_t)v72)), v71);
          float32x4_t v76 = vminq_f32(vmaxq_f32(vrecpeq_f32(v75), v53), v21);
          float32x4_t v77 = vminq_f32(vmaxq_f32(vmulq_f32(v76, vrecpsq_f32(v75, v76)), v53), v21);
          float32x4_t v78 = (float32x4_t)vbslq_s8(v74, (int8x16_t)vmulq_f32(v77, vrecpsq_f32(v75, v77)), v71);
          int8x16_t v79 = (int8x16_t)vmulq_laneq_f32(v78, v78, 3);
          float32x4_t v80 = vminq_f32(vmaxq_f32(vmulq_n_f32(v46, vaddq_f32((float32x4_t)v51, (float32x4_t)v79).f32[0]), (float32x4_t)v73), (float32x4_t)v50);
          v81.i64[0] = vsubq_f32((float32x4_t)v52, vminq_f32(vmaxq_f32(vmulq_n_f32((float32x4_t)v73, vaddq_f32((float32x4_t)v73, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v79.i8, 1)).f32[0]), v40), (float32x4_t)v52)).u64[0];
          v81.i64[1] = v80.i64[1];
          int8x16_t v82 = vbslq_s8(v74, (int8x16_t)vmulq_n_f32((float32x4_t)v73, COERCE_FLOAT(*v17)), v79);
          float32x4_t v83 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v82, 3);
          v80.i64[0] = vsubq_f32(vmulq_n_f32((float32x4_t)vbslq_s8(v29, (int8x16_t)vsubq_f32((float32x4_t)v73, (float32x4_t)vdupq_laneq_s64((int64x2_t)v80, 1)), v81), COERCE_FLOAT(*v17)), v83).u64[0];
          int8x16_t v84 = (int8x16_t)v17[35];
          v80.i64[1] = *((void *)v17 + 71);
          int8x16_t v85 = (int8x16_t)vmulq_f32(*((float32x4_t *)v17 + 7), v80);
          int8x16_t v86 = (int8x16_t)vaddq_f32((float32x4_t)v85, (float32x4_t)vextq_s8(v85, v85, 4uLL));
          int8x16_t v87 = (int8x16_t)vmulq_f32(*((float32x4_t *)v17 + 8), v80);
          int8x16_t v88 = (int8x16_t)vaddq_f32((float32x4_t)v87, (float32x4_t)vextq_s8(v87, v87, 4uLL));
          uint64_t v89 = *((int *)a2 + 26);
          float32x4_t v90 = vsubq_f32((float32x4_t)vbslq_s8(v29, (int8x16_t)vaddq_f32((float32x4_t)v86, (float32x4_t)vextq_s8(v86, v86, 8uLL)), (int8x16_t)vaddq_f32((float32x4_t)v88, (float32x4_t)vextq_s8(v88, v88, 8uLL))), (float32x4_t)v9);
          uint64_t v91 = *((void *)a2 + 12);
          if (v5)
          {
            int32x4_t v92 = vaddq_s32(vcvtq_s32_f32(v90), vcltzq_f32(v90));
            float32x2_t v93 = (float32x2_t)vsubq_f32(v90, vcvtq_f32_s32(v92)).u64[0];
            __n128 v94 = (float32x4_t *)(v91 + 16 * (v92.i32[0] + v92.i32[1] * (int)v89));
            float32x4_t v95 = vaddq_f32(*v94, vmulq_n_f32(vsubq_f32(v94[1], *v94), v93.f32[0]));
            float32x4_t v96 = vaddq_f32(v95, vmulq_lane_f32(vsubq_f32(vaddq_f32(v94[v89], vmulq_n_f32(vsubq_f32(v94[(int)v89 + 1], v94[v89]), v93.f32[0])), v95), v93, 1));
          }
          else
          {
            float32x4_t v97 = vaddq_f32(v90, v13);
            int32x4_t v98 = vcvtq_s32_f32(v97);
            v97.i64[0] = vaddq_s32(v98, vcgtq_f32(vcvtq_f32_s32(v98), v97)).u64[0];
            float32x4_t v96 = *(float32x4_t *)(v91 + 16 * (v97.i32[0] + v97.i32[1] * (int)v89));
          }
          int8x16_t v99 = vmvnq_s8(v29);
          int8x16_t v100 = vmvnq_s8(v74);
          int8x16_t v101 = vandq_s8(v51, (int8x16_t)vcgeq_f32((float32x4_t)vextq_s8(v79, v79, 8uLL), v40));
          float32x2_t v102 = (float32x2_t)vdupq_lane_s32(*(int32x2_t *)v18.i8, 0).u64[0];
          uint64_t v103 = vextq_s8(v84, v84, 8uLL).u64[0];
          float32x4_t v104 = (float32x4_t)vorrq_s8(vandq_s8(vandq_s8(v84, v99), (int8x16_t)vcgeq_f32((float32x4_t)vrev64q_s32((int32x4_t)v101), (float32x4_t)v84)), vandq_s8(v101, v29));
          float32x4_t v105 = (float32x4_t)vextq_s8(v82, v82, 8uLL);
          float32x4_t v106 = (float32x4_t)vorrq_s8(vandq_s8((int8x16_t)vsubq_f32((float32x4_t)v84, v104), v99), vandq_s8(vandq_s8(v73, v29), (int8x16_t)vcgeq_f32(v105, (float32x4_t)v84)));
          int8x16_t v107 = vorrq_s8(vandq_s8(v29, (int8x16_t)vsubq_f32((float32x4_t)v73, v106)), vbicq_s8(v81, v29));
          int8x16_t v108 = vorrq_s8(vandq_s8(vextq_s8(v107, v107, 8uLL), v74), vandq_s8(v107, v100));
          *(float32x2_t *)v109.f32 = vsub_f32(vmul_f32(v102, (float32x2_t)*(_OWORD *)&vextq_s8(v108, v108, 8uLL)), *(float32x2_t *)v83.f32);
          v109.i64[1] = v103;
          int8x16_t v110 = (int8x16_t)vmulq_f32(v109, *((float32x4_t *)v17 + 6));
          float32x4_t v111 = vaddq_f32((float32x4_t)v110, (float32x4_t)vextq_s8(v110, v110, 4uLL));
          v112.i64[0] = v104.i64[0];
          v112.i64[1] = vaddq_f32(v111, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v111, 0)).i64[1];
          int8x16_t v113 = vmvnq_s8(v28);
          int8x16_t v114 = (int8x16_t)vmulq_f32(v109, *((float32x4_t *)v17 + 5));
          int8x16_t v115 = (int8x16_t)vaddq_f32((float32x4_t)v114, (float32x4_t)vextq_s8(v114, v114, 4uLL));
          int8x16_t v116 = vorrq_s8(vandq_s8(v112, v113), vandq_s8(v28, (int8x16_t)vaddq_f32((float32x4_t)v115, (float32x4_t)vextq_s8(v115, v115, 8uLL))));
          uint64_t v117 = *((int *)a2 + 22);
          float32x4_t v118 = vsubq_f32((float32x4_t)vextq_s8(v116, v116, 8uLL), (float32x4_t)v9);
          uint64_t v119 = *((void *)a2 + 10);
          if (v5)
          {
            int32x4_t v120 = vaddq_s32(vcvtq_s32_f32(v118), vcltzq_f32(v118));
            float32x2_t v121 = (float32x2_t)vsubq_f32(v118, vcvtq_f32_s32(v120)).u64[0];
            float v122 = (float32x4_t *)(v119 + 16 * (v120.i32[0] + v120.i32[1] * (int)v117));
            float32x4_t v123 = vaddq_f32(*v122, vmulq_n_f32(vsubq_f32(v122[1], *v122), v121.f32[0]));
            float32x4_t v124 = vaddq_f32(v123, vmulq_lane_f32(vsubq_f32(vaddq_f32(v122[v117], vmulq_n_f32(vsubq_f32(v122[(int)v117 + 1], v122[v117]), v121.f32[0])), v123), v121, 1));
          }
          else
          {
            float32x4_t v125 = vaddq_f32(v118, v13);
            int32x4_t v126 = vcvtq_s32_f32(v125);
            v125.i64[0] = vaddq_s32(v126, vcgtq_f32(vcvtq_f32_s32(v126), v125)).u64[0];
            float32x4_t v124 = *(float32x4_t *)(v119 + 16 * (v125.i32[0] + v125.i32[1] * (int)v117));
          }
          int8x16_t v127 = vorrq_s8(vandq_s8(v29, (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v104), (float32x4_t)v108)), vandq_s8(v108, v99));
          int8x16_t v128 = vorrq_s8(vandq_s8(vandq_s8(v84, v74), (int8x16_t)vcgeq_f32((float32x4_t)vextq_s8(v127, v127, 4uLL), (float32x4_t)v84)), vandq_s8(v127, v100));
          int8x16_t v129 = (int8x16_t)v17[36];
          int8x16_t v130 = vorrq_s8(vandq_s8(v29, (int8x16_t)vminq_f32(vmaxq_f32(vmulq_lane_f32(vaddq_f32((float32x4_t)v73, v105), *(float32x2_t *)v73.i8, 1), (float32x4_t)v129), (float32x4_t)v73)), vandq_s8(v128, v99));
          float32x4_t v131 = (float32x4_t)vrev64q_s32((int32x4_t)v130);
          int8x16_t v132 = vandq_s8(v82, v113);
          int8x16_t v133 = vorrq_s8(vandq_s8(v28, (int8x16_t)vsubq_f32((float32x4_t)v129, v131)), v132);
          *(float32x2_t *)v134.f32 = vsub_f32(vmul_f32(v102, (float32x2_t)vorr_s8(vand_s8(*(int8x8_t *)v131.f32, *(int8x8_t *)v99.i8), vand_s8((int8x8_t)*(_OWORD *)&vextq_s8(v130, v130, 8uLL), *(int8x8_t *)v29.i8))), (float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v133, 3));
          v134.i64[1] = v103;
          int8x16_t v135 = (int8x16_t)vmulq_f32(*((float32x4_t *)v17 + 10), v134);
          int8x16_t v136 = (int8x16_t)vaddq_f32((float32x4_t)v135, (float32x4_t)vextq_s8(v135, v135, 4uLL));
          int8x16_t v137 = (int8x16_t)vmulq_f32(*((float32x4_t *)v17 + 9), v134);
          int8x16_t v138 = (int8x16_t)vaddq_f32((float32x4_t)v137, (float32x4_t)vextq_s8(v137, v137, 4uLL));
          uint64_t v139 = *((int *)a2 + 30);
          float32x4_t v140 = vsubq_f32((float32x4_t)vorrq_s8(vandq_s8(v29, (int8x16_t)vaddq_f32((float32x4_t)v138, (float32x4_t)vextq_s8(v138, v138, 8uLL))), vandq_s8((int8x16_t)vaddq_f32((float32x4_t)v136, (float32x4_t)vextq_s8(v136, v136, 8uLL)), v99)), (float32x4_t)v9);
          uint64_t v141 = *((void *)a2 + 14);
          if (v5)
          {
            int32x4_t v142 = vaddq_s32(vcvtq_s32_f32(v140), vcltzq_f32(v140));
            float32x2_t v143 = (float32x2_t)vsubq_f32(v140, vcvtq_f32_s32(v142)).u64[0];
            v144 = (float32x4_t *)(v141 + 16 * (v142.i32[0] + v142.i32[1] * (int)v139));
            float32x4_t v145 = vaddq_f32(*v144, vmulq_n_f32(vsubq_f32(v144[1], *v144), v143.f32[0]));
            float32x4_t v146 = vaddq_f32(v145, vmulq_lane_f32(vsubq_f32(vaddq_f32(v144[v139], vmulq_n_f32(vsubq_f32(v144[(int)v139 + 1], v144[v139]), v143.f32[0])), v145), v143, 1));
          }
          else
          {
            float32x4_t v147 = vaddq_f32(v140, v13);
            int32x4_t v148 = vcvtq_s32_f32(v147);
            v147.i64[0] = vaddq_s32(v148, vcgtq_f32(vcvtq_f32_s32(v148), v147)).u64[0];
            float32x4_t v146 = *(float32x4_t *)(v141 + 16 * (v147.i32[0] + v147.i32[1] * (int)v139));
          }
          int8x16_t v149 = (int8x16_t)vmulq_f32(v134, *((float32x4_t *)v17 + 12));
          int8x16_t v150 = (int8x16_t)vaddq_f32((float32x4_t)v149, (float32x4_t)vextq_s8(v149, v149, 4uLL));
          int8x16_t v151 = (int8x16_t)vmulq_f32(v134, *((float32x4_t *)v17 + 11));
          int8x16_t v152 = (int8x16_t)vaddq_f32((float32x4_t)v151, (float32x4_t)vextq_s8(v151, v151, 4uLL));
          uint64_t v153 = *((int *)a2 + 34);
          float32x4_t v154 = vsubq_f32((float32x4_t)vorrq_s8(vandq_s8(v29, (int8x16_t)vaddq_f32((float32x4_t)v152, (float32x4_t)vextq_s8(v152, v152, 8uLL))), vandq_s8((int8x16_t)vaddq_f32((float32x4_t)v150, (float32x4_t)vextq_s8(v150, v150, 8uLL)), v99)), (float32x4_t)v9);
          uint64_t v155 = *((void *)a2 + 16);
          if (v5)
          {
            int32x4_t v156 = vaddq_s32(vcvtq_s32_f32(v154), vcltzq_f32(v154));
            float32x2_t v157 = (float32x2_t)vsubq_f32(v154, vcvtq_f32_s32(v156)).u64[0];
            v158 = (float32x4_t *)(v155 + 16 * (v156.i32[0] + v156.i32[1] * (int)v153));
            float32x4_t v159 = vaddq_f32(*v158, vmulq_n_f32(vsubq_f32(v158[1], *v158), v157.f32[0]));
            float32x4_t v160 = vaddq_f32(v159, vmulq_lane_f32(vsubq_f32(vaddq_f32(v158[v153], vmulq_n_f32(vsubq_f32(v158[(int)v153 + 1], v158[v153]), v157.f32[0])), v159), v157, 1));
          }
          else
          {
            float32x4_t v161 = vaddq_f32(v154, v13);
            int32x4_t v162 = vcvtq_s32_f32(v161);
            v161.i64[0] = vaddq_s32(v162, vcgtq_f32(vcvtq_f32_s32(v162), v161)).u64[0];
            float32x4_t v160 = *(float32x4_t *)(v155 + 16 * (v161.i32[0] + v161.i32[1] * (int)v153));
          }
          int8x16_t v163 = (int8x16_t)v17[37];
          float32x4_t v164 = (float32x4_t)vorrq_s8(vandq_s8(vandq_s8(v129, v28), (int8x16_t)vcgeq_f32((float32x4_t)vextq_s8(v133, v133, 0xCuLL), (float32x4_t)v163)), v132);
          int8x16_t v165 = (int8x16_t)vaddq_f32(v131, v164);
          v165.i64[0] = vandq_s8(v163, (int8x16_t)vcgeq_f32((float32x4_t)vextq_s8(v165, v165, 8uLL), (float32x4_t)v163)).u64[0];
          v165.i64[1] = vsubq_f32(*(float32x4_t *)&v129, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v165, 0)).i64[1];
          int8x16_t v166 = vmvnq_s8(v54);
          int8x16_t v167 = vandq_s8(v165, v166);
          float32x4_t v168 = (float32x4_t)vorrq_s8(vandq_s8(v54, (int8x16_t)vsubq_f32((float32x4_t)v129, (float32x4_t)vorrq_s8(v167, vandq_s8(vandq_s8(v129, v54), (int8x16_t)vcgeq_f32(v164, (float32x4_t)v163))))), v167);
          *(float32x2_t *)v169.i8 = vsub_f32(*(float32x2_t *)v163.i8, *(float32x2_t *)v130.i8);
          v169.i64[1] = v103;
          float32x4_t v170 = (float32x4_t)vorrq_s8(vandq_s8(v169, v166), vandq_s8(v130, v54));
          float32x4_t v171 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v164, 3);
          v172.i64[0] = vsubq_f32(vmulq_n_f32(v170, *(float *)v18.i32), v171).u64[0];
          v172.i64[1] = v170.i64[1];
          int8x16_t v173 = (int8x16_t)vmulq_f32(v172, *((float32x4_t *)v17 + 14));
          int8x16_t v174 = (int8x16_t)vaddq_f32((float32x4_t)v173, (float32x4_t)vextq_s8(v173, v173, 4uLL));
          v174.i64[0] = vaddq_f32((float32x4_t)v174, (float32x4_t)vdupq_laneq_s64((int64x2_t)v174, 1)).u64[0];
          int8x16_t v175 = (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)v168), v168);
          v174.i64[1] = vandq_s8(v129, (int8x16_t)vcgeq_f32((float32x4_t)vextq_s8(v175, v175, 8uLL), *(float32x4_t *)&v129)).i64[1];
          int8x16_t v176 = (int8x16_t)vmulq_f32(v172, *((float32x4_t *)v17 + 13));
          int8x16_t v177 = (int8x16_t)vaddq_f32((float32x4_t)v176, (float32x4_t)vextq_s8(v176, v176, 4uLL));
          int8x16_t v178 = vorrq_s8(vandq_s8(v174, v99), vandq_s8(v29, (int8x16_t)vaddq_f32((float32x4_t)v177, (float32x4_t)vextq_s8(v177, v177, 8uLL))));
          uint64_t v179 = *((int *)a2 + 38);
          float32x4_t v180 = vsubq_f32((float32x4_t)v178, (float32x4_t)v9);
          uint64_t v181 = *((void *)a2 + 18);
          if (v5)
          {
            int32x4_t v182 = vaddq_s32(vcvtq_s32_f32(v180), vcltzq_f32(v180));
            float32x2_t v183 = (float32x2_t)vsubq_f32(v180, vcvtq_f32_s32(v182)).u64[0];
            v184 = (float32x4_t *)(v181 + 16 * (v182.i32[0] + v182.i32[1] * (int)v179));
            float32x4_t v185 = vaddq_f32(*v184, vmulq_n_f32(vsubq_f32(v184[1], *v184), v183.f32[0]));
            float32x4_t v186 = vaddq_f32(v185, vmulq_lane_f32(vsubq_f32(vaddq_f32(v184[v179], vmulq_n_f32(vsubq_f32(v184[(int)v179 + 1], v184[v179]), v183.f32[0])), v185), v183, 1));
          }
          else
          {
            float32x4_t v187 = vaddq_f32(v180, v13);
            int32x4_t v188 = vcvtq_s32_f32(v187);
            v187.i64[0] = vaddq_s32(v188, vcgtq_f32(vcvtq_f32_s32(v188), v187)).u64[0];
            float32x4_t v186 = *(float32x4_t *)(v181 + 16 * (v187.i32[0] + v187.i32[1] * (int)v179));
          }
          v189.i64[0] = vsubq_f32((float32x4_t)v129, (float32x4_t)vextq_s8(v178, v9, 4uLL)).u64[0];
          v189.i64[1] = v178.i64[1];
          int8x16_t v190 = vandq_s8(v163, v29);
          int8x16_t v191 = vorrq_s8(vandq_s8(v189, v99), vandq_s8(v190, (int8x16_t)vcgeq_f32(v164, v40)));
          v192.i64[0] = vorrq_s8(vandq_s8((int8x16_t)vsubq_f32((float32x4_t)v129, (float32x4_t)vrev64q_s32((int32x4_t)vandq_s8(v163, (int8x16_t)vcgeq_f32(vaddq_f32((float32x4_t)vrev64q_s32((int32x4_t)vextq_s8(v191, v191, 4uLL)), (float32x4_t)v191), (float32x4_t)v163)))), v99), vandq_s8(v190, (int8x16_t)vcgeq_f32(v164, (float32x4_t)v84))).u64[0];
          *(float32x2_t *)v193.f32 = vsub_f32(vmul_f32(v102, *(float32x2_t *)v130.i8), *(float32x2_t *)v171.f32);
          v193.i64[1] = v103;
          int8x16_t v194 = (int8x16_t)vmulq_f32(v193, *((float32x4_t *)v17 + 16));
          float32x4_t v195 = vaddq_f32((float32x4_t)v194, (float32x4_t)vextq_s8(v194, v194, 4uLL));
          v192.i64[1] = vaddq_f32(v195, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v195, 0)).i64[1];
          int8x16_t v196 = (int8x16_t)vmulq_f32(v193, *((float32x4_t *)v17 + 15));
          int8x16_t v197 = (int8x16_t)vaddq_f32((float32x4_t)v196, (float32x4_t)vextq_s8(v196, v196, 4uLL));
          int8x16_t v198 = vorrq_s8(vandq_s8(v192, v113), vandq_s8(v28, (int8x16_t)vaddq_f32((float32x4_t)v197, (float32x4_t)vextq_s8(v197, v197, 8uLL))));
          uint64_t v199 = *((int *)a2 + 42);
          float32x4_t v200 = vsubq_f32((float32x4_t)vextq_s8(v198, v198, 8uLL), (float32x4_t)v9);
          uint64_t v201 = *((void *)a2 + 20);
          if (v5)
          {
            int32x4_t v202 = vaddq_s32(vcvtq_s32_f32(v200), vcltzq_f32(v200));
            float32x2_t v203 = (float32x2_t)vsubq_f32(v200, vcvtq_f32_s32(v202)).u64[0];
            v204 = (float32x4_t *)(v201 + 16 * (v202.i32[0] + v202.i32[1] * (int)v199));
            float32x4_t v205 = vaddq_f32(*v204, vmulq_n_f32(vsubq_f32(v204[1], *v204), v203.f32[0]));
            float32x4_t v206 = vaddq_f32(v205, vmulq_lane_f32(vsubq_f32(vaddq_f32(v204[v199], vmulq_n_f32(vsubq_f32(v204[(int)v199 + 1], v204[v199]), v203.f32[0])), v205), v203, 1));
          }
          else
          {
            float32x4_t v207 = vaddq_f32(v200, v13);
            int32x4_t v208 = vcvtq_s32_f32(v207);
            v207.i64[0] = vaddq_s32(v208, vcgtq_f32(vcvtq_f32_s32(v208), v207)).u64[0];
            float32x4_t v206 = *(float32x4_t *)(v201 + 16 * (v207.i32[0] + v207.i32[1] * (int)v199));
          }
          *(float32x4_t *)(v11 + v15) = vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vaddq_f32(vmulq_n_f32(vmulq_lane_f32(v96, *(float32x2_t *)v106.f32, 1), *(float *)v107.i32), vmulq_n_f32(v124, *(float *)v116.i32)), vmulq_laneq_f32(vmulq_laneq_f32(v146, (float32x4_t)v133, 2), v164, 2)), vmulq_lane_f32(vmulq_laneq_f32(v160, v168, 2), *(float32x2_t *)v168.f32, 1)), vmulq_n_f32(vmulq_lane_f32(v186, *(float32x2_t *)v191.i8, 1), *(float *)v191.i32)), vmulq_n_f32(vmulq_lane_f32(v206, *(float32x2_t *)v198.i8, 1), vsubq_f32((float32x4_t)v163, (float32x4_t)v198).f32[0]));
          float32x4_t v16 = vaddq_f32(v16, (float32x4_t)xmmword_1B7E736B0);
          v15 += 16;
        }
        while (16 * v10 != v15);
      }
      float32x4_t v14 = vaddq_f32(v14, (float32x4_t)xmmword_1B7E736C0);
      ++v8;
      v11 += v12;
    }
    while (v8 != v7);
  }
  return 0;
}

uint64_t HgcRenderToEquirect::GetDOD(HgcRenderToEquirect *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var2;
  uint64_t v5 = *(void *)&a4.var0;
  switch(a3)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      if ((*(int (**)(HgcRenderToEquirect *, HGRenderer *))(*(void *)this + 312))(this, a2) <= 0) {
        goto LABEL_4;
      }
      goto LABEL_3;
    case 5:
      if ((*(int (**)(HgcRenderToEquirect *, HGRenderer *))(*(void *)this + 312))(this, a2) >= 1)
      {
LABEL_3:
        uint64_t v6 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
        HGRectGrow(v5, v4, v6);
      }
LABEL_4:
      int v7 = &HGRectInfinite;
      break;
    default:
      int v7 = &HGRectNull;
      break;
  }
  return *(void *)v7;
}

uint64_t HgcRenderToEquirect::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  switch(a3)
  {
    case 0:
      uint64_t v6 = a2;
      int v7 = this;
      unsigned int v8 = 0;
      goto LABEL_9;
    case 1:
      uint64_t v6 = a2;
      int v7 = this;
      unsigned int v8 = 1;
      goto LABEL_9;
    case 2:
      uint64_t v6 = a2;
      int v7 = this;
      unsigned int v8 = 2;
      goto LABEL_9;
    case 3:
      uint64_t v6 = a2;
      int v7 = this;
      unsigned int v8 = 3;
      goto LABEL_9;
    case 4:
      uint64_t v6 = a2;
      int v7 = this;
      unsigned int v8 = 4;
      goto LABEL_9;
    case 5:
      uint64_t v6 = a2;
      int v7 = this;
      unsigned int v8 = 5;
LABEL_9:
      Input = HGRenderer::GetInput(v6, v7, v8);
      uint64_t DOD = HGRenderer::GetDOD(a2, Input);
      uint64_t v12 = v11;
      if ((*(int (**)(HGNode *, HGRenderer *))(*(void *)this + 312))(this, a2) >= 1)
      {
        uint64_t v13 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
        uint64_t DOD = HGRectGrow(DOD, v12, v13);
      }
      break;
    default:
      uint64_t DOD = 0;
      break;
  }
  return DOD;
}

void HgcRenderToEquirect::HgcRenderToEquirect(HgcRenderToEquirect *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F1115810;
  operator new();
}

void sub_1B7A453F8(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcRenderToEquirect::~HgcRenderToEquirect(HGNode *this)
{
  *(void *)this = &unk_1F1115810;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C404B930091);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcRenderToEquirect::~HgcRenderToEquirect(this);

  HGObject::operator delete(v1);
}

uint64_t HgcRenderToEquirect::SetParameter(HgcRenderToEquirect *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 0x11) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  unsigned int v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  float *v8 = a3;
  int v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcRenderToEquirect::GetParameter(HgcRenderToEquirect *this, unsigned int a2, float *a3)
{
  if (a2 > 0x11) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *LiHgcEquirectProject::GetProgram(LiHgcEquirectProject *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return aMetal10Len0000_1317;
    }
    else {
      return aMetal10Len0000_1318;
    }
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return aGlfs20Len00000_488;
  }
}

void LiHgcEquirectProject::InitProgramDescriptor(LiHgcEquirectProject *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "LiHgcEquirectProject_hgc_visible", "//Metal1.0     \n//LEN=0000000f88\n[[ visible ]] FragmentOut LiHgcEquirectProject_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(-0.01348046958, 0.05747731403, -0.1212390736, 1.000000000);\n"
    "    const float4 c1 = float4(-0.3329946101, 0.1956359297, 0.9999956489, 1.570796371);\n"
    "    const float4 c2 = float4(0.000000000, -0.01872929931, 0.07426100224, 3.141592741);\n"
    "    const float4 c3 = float4(0.1591549367, -0.2121143937, 0.5000000000, 1.570728779);\n"
    "    const float4 c4 = float4(-0.3183098733, 0.5000000000, -2.000000000, -0.5000000000);\n"
    "    float4 r0, r1, r2, r3, r4;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.w = c0.w;\n"
    "    r1.x = dot(texCoord0, hg_Params[6]);\n"
    "    r1.z = hg_Params[2].z;\n"
    "    r1.y = dot(texCoord0, hg_Params[7]);\n"
    "    r1.xyz = normalize(r1.xyz).xyz;\n"
    "    r2.y = dot(r1.xyz, hg_Params[3].xyz);\n"
    "    r1.w = dot(r1.xyz, hg_Params[5].xyz);\n"
    "    r1.y = dot(r1.xyz, hg_Params[4].xyz);\n"
    "    r1.z = abs(r1.y);\n"
    "    r2.x = abs(r1.w);\n"
    "    r2.z = abs(r2.y);\n"
    "    r2.w = fmax(r2.x, r2.z);\n"
    "    r3.x = 1.00000f / r2.w;\n"
    "    r2.w = fmin(r2.x, r2.z);\n"
    "    r2.w = r2.w*r3.x;\n"
    "    r3.x = r2.w*r2.w;\n"
    "    r3.y = r3.x*c0.x + c0.y;\n"
    "    r3.y = r3.y*r3.x + c0.z;\n"
    "    r3.y = r3.y*r3.x + c1.y;\n"
    "    r3.y = r3.y*r3.x + c1.x;\n"
    "    r3.x = r3.y*r3.x + c1.z;\n"
    "    r2.w = r3.x*r2.w;\n"
    "    r2.z = r2.x - r2.z;\n"
    "    r3.x = c1.w - r2.w;\n"
    "    r2.z = select(r2.w, r3.x, r2.z < 0.00000f);\n"
    "    r2.w = -r2.z + c2.w;\n"
    "    r1.w = select(r2.z, r2.w, r1.w < 0.00000f);\n"
    "    r1.w = select(r1.w, -r1.w, r2.y < 0.00000f);\n"
    "    r2.z = c0.w - r1.z;\n"
    "    r2.x = float(-r2.x >= c2.x);\n"
    "    r1.x = 1.00000f / hg_Params[0].x;\n"
    "    r2.y = select(c1.w, -c1.w, r2.y < 0.00000f);\n"
    "    r1.w = select(r1.w, r2.y, -r2.x < 0.00000f);\n"
    "    r2.y = r1.z*c2.y + c2.z;\n"
    "    r2.y = r2.y*r1.z + c3.y;\n"
    "    r1.w = r1.w*hg_Params[0].x;\n"
    "    r1.w = r1.w*c3.x;\n"
    "    r3.y = r1.w - c3.z;\n"
    "    r2.x = floor(r3.y);\n"
    "    r2.x = hg_Params[0].x*-c3.z + r2.x;\n"
    "    r2.x = r2.x + c3.z;\n"
    "    r2.w = r2.x*r1.x;\n"
    "    r2.z = sqrt(r2.z);\n"
    "    r1.z = r2.y*r1.z + c3.w;\n"
    "    r1.z = r1.z*r2.z;\n"
    "    r2.z = floor(r2.w);\n"
    "    r2.x = -r2.z*hg_Params[0].x + r2.x;\n"
    "    r1.y = float(r1.y < c2.x);\n"
    "    r2.y = r1.y*r1.z;\n"
    "    r1.z = r2.y*c4.z + r1.z;\n"
    "    r1.y = r1.y*c2.w + r1.z;\n"
    "    r2.x = hg_Params[0].x*-c3.z + r2.x;\n"
    "    r1.z = hg_Params[0].x*-c3.z + r2.x;\n"
    "    r1.y = r1.y*hg_Params[1].x;\n"
    "    r4.x = r1.y*c4.x;\n"
    "    r4.x = hg_Params[1].x*c3.z + r4.x;\n"
    "    r1.z = r1.z + c0.w;\n"
    "    r3.x = r4.x - c3.z;\n"
    "    r4.x = r1.z*r1.x;\n"
    "    r1.x = floor(r3.x);\n"
    "    r4.y = r1.x + c3.z;\n"
    "    r1.xy = hg_Params[1].xx*c4.yw + c4.wy;\n"
    "    r4.x = floor(r4.x);\n"
    "    r4.x = -r4.x*hg_Params[0].x + r1.z;\n"
    "    r4.x = hg_Params[0].x*c4.w + r4.x;\n"
    "    r0.x = r4.x;\n"
    "    r4.y = fmin(r1.x, r4.y);\n"
    "    r4.y = fmax(r1.y, r4.y);\n"
    "    r1.z = r4.y + c0.w;\n"
    "    r1.z = fmin(r1.z, r1.x);\n"
    "    r4.z = fmax(r1.z, r1.y);\n"
    "    r0.y = r4.z;\n"
    "    r1.y = r4.z;\n"
    "    r1.x = r2.x;\n"
    "    r1.w = c0.w;\n"
    "    r2.y = r4.y;\n"
    "    r2.w = dot(r1.xyw, hg_Params[9].xyw);\n"
    "    r2.z = dot(r1.xyw, hg_Params[8].xyw);\n"
    "    r1.xy = r2.zw + hg_Params[10].xy;\n"
    "    r1.xy = r1.xy*hg_Params[10].zw;\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, r1.xy);\n"
    "    r4.w = dot(r0.xyw, hg_Params[9].xyw);\n"
    "    r4.z = dot(r0.xyw, hg_Params[8].xyw);\n"
    "    r0.xy = r4.zw + hg_Params[10].xy;\n"
    "    r0.xy = r0.xy*hg_Params[10].zw;\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
    "    r2.w = c0.w;\n"
    "    r4.w = dot(r2.xyw, hg_Params[9].xyw);\n"
    "    r4.z = dot(r2.xyw, hg_Params[8].xyw);\n"
    "    r2.xy = r4.zw + hg_Params[10].xy;\n"
    "    r2.xy = r2.xy*hg_Params[10].zw;\n"
    "    r2 = hg_Texture0.sample(hg_Sampler0, r2.xy);\n"
    "    r4.w = c0.w;\n"
    "    r3.y = fract(r3.y);\n"
    "    r3.w = dot(r4.xyw, hg_Params[9].xyw);\n"
    "    r3.z = dot(r4.xyw, hg_Params[8].xyw);\n"
    "    r4.xy = r3.zw + hg_Params[10].xy;\n"
    "    r4.xy = r4.xy*hg_Params[10].zw;\n"
    "    r4 = hg_Texture0.sample(hg_Sampler0, r4.xy);\n"
    "    r4 = mix(r2, r4, r3.yyyy);\n"
    "    r1 = mix(r1, r0, r3.yyyy);\n"
    "    r3.x = fract(r3.x);\n"
    "    output.color0 = mix(r4, r1, r3.xxxx);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "LiHgcEquirectProject");
}

void sub_1B7A45688(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75800;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 9;
  std::string::basic_string[abi:ne180100]<0>(v34, "texture2d<float>");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 6;
  std::string::basic_string[abi:ne180100]<0>(v34, "sampler");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 8;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  int8x16_t v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7A45808(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7A45858()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7A45850);
}

void *LiHgcEquirectProject::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "LiHgcEquirectProject [hgc1]");
}

uint64_t LiHgcEquirectProject::BindTexture(LiHgcEquirectProject *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 10, v5, v6, v7, v8);
  return 0;
}

uint64_t LiHgcEquirectProject::Bind(LiHgcEquirectProject *this, HGHandler *a2)
{
  return 0;
}

uint64_t LiHgcEquirectProject::RenderTile(LiHgcEquirectProject *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    int v6 = a2[1].i32[0] - v2.i32[0];
    int32x2_t v7 = a2[2];
    uint64_t v8 = 16 * a2[3].i32[0];
    v9.i64[0] = 0x3F0000003F000000;
    v9.i64[1] = 0x3F0000003F000000;
    float32x4_t v10 = v5;
    do
    {
      if (v6 >= 1)
      {
        uint64_t v11 = 0;
        float32x4_t v12 = v10;
        do
        {
          uint64_t v13 = (_OWORD *)*((void *)this + 51);
          float32x4_t v14 = vmulq_f32(v12, *((float32x4_t *)v13 + 6));
          float32x4_t v15 = vaddq_f32(v14, (float32x4_t)vextq_s8((int8x16_t)v14, (int8x16_t)v14, 4uLL));
          v15.i64[0] = vaddq_f32(v15, (float32x4_t)vdupq_laneq_s64((int64x2_t)v15, 1)).u64[0];
          v15.i64[1] = *((void *)v13 + 5);
          float32x4_t v16 = vmulq_f32(v12, *((float32x4_t *)v13 + 7));
          float32x4_t v17 = vaddq_f32(v16, (float32x4_t)vextq_s8((int8x16_t)v16, (int8x16_t)v16, 4uLL));
          float32x4_t v19 = *((float32x4_t *)v13 + 10);
          int8x16_t v18 = *((int8x16_t *)v13 + 11);
          float32x4_t v20 = (float32x4_t)vbslq_s8(v18, (int8x16_t)vaddq_f32(v17, (float32x4_t)vextq_s8((int8x16_t)v17, (int8x16_t)v17, 8uLL)), (int8x16_t)v15);
          int32x4_t v21 = (int32x4_t)vmulq_f32(v20, v20);
          float32x4_t v22 = vaddq_f32((float32x4_t)vdupq_laneq_s32(v21, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.i8, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.i8, 1)));
          float32x4_t v23 = vminq_f32(vrsqrteq_f32(v22), v19);
          float32x4_t v24 = vminq_f32(vmulq_f32(v23, vrsqrtsq_f32(vmulq_f32(v23, v22), v23)), v19);
          float32x4_t v25 = vmulq_f32(vmulq_f32(v24, vrsqrtsq_f32(vmulq_f32(v24, v22), v24)), v20);
          float32x4_t v26 = vmulq_f32(*((float32x4_t *)v13 + 3), v25);
          int32x4_t v27 = (int32x4_t)vmulq_f32(*((float32x4_t *)v13 + 5), v25);
          int8x16_t v28 = *((int8x16_t *)v13 + 12);
          int32x4_t v29 = *((int32x4_t *)v13 + 13);
          float32x4_t v30 = (float32x4_t)vbslq_s8(v28, (int8x16_t)vaddq_f32((float32x4_t)vrev64q_s32(v27), vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v27, (int8x16_t)v27, 4uLL), (float32x4_t)vextq_s8((int8x16_t)v27, (int8x16_t)v27, 8uLL))), (int8x16_t)v25);
          int8x16_t v31 = (int8x16_t)vmulq_f32(*((float32x4_t *)v13 + 4), v30);
          *(float32x2_t *)v31.i8 = vadd_f32((float32x2_t)*(_OWORD *)&vextq_s8(v31, (int8x16_t)v5, 4uLL), vadd_f32(*(float32x2_t *)v31.i8, (float32x2_t)vrev64_s32(*(int32x2_t *)v31.i8)));
          v31.i64[1] = vextq_s8((int8x16_t)v30, (int8x16_t)v30, 8uLL).u64[0];
          int8x8_t v32 = (int8x8_t)vextq_s8((int8x16_t)v29, (int8x16_t)v29, 8uLL).u64[0];
          *(int8x8_t *)v33.i8 = vqtbl1_s8(v31, *(int8x8_t *)v29.i8);
          v33.u64[1] = (unint64_t)vqtbl1_s8(v31, v32);
          int8x16_t v35 = *((int8x16_t *)v13 + 14);
          int8x16_t v34 = *((int8x16_t *)v13 + 15);
          float32x4_t v36 = (float32x4_t)vandq_s8(v33, v35);
          int8x16_t v37 = vbslq_s8(v34, (int8x16_t)vabsq_f32((float32x4_t)vextq_s8((int8x16_t)v36, (int8x16_t)v36, 0xCuLL)), (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v26, (int8x16_t)v26, 4uLL), vaddq_f32(v26, (float32x4_t)vrev64q_s32((int32x4_t)v26))));
          *(int8x8_t *)v29.i8 = vqtbl1_s8(v37, *(int8x8_t *)v29.i8);
          v33.i64[0] = v29.i64[0];
          v33.u64[1] = (unint64_t)vand_s8(vqtbl1_s8(v37, v32), (int8x8_t)*(_OWORD *)&vextq_s8(v35, v35, 8uLL));
          *(int8x8_t *)v38.f32 = vext_s8(*(int8x8_t *)v29.i8, (int8x8_t)v33.u64[1], 4uLL);
          *(int8x8_t *)&v38.u32[2] = vext_s8((int8x8_t)v33.u64[1], *(int8x8_t *)v29.i8, 4uLL);
          v29.i64[1] = v33.i64[1];
          int32x4_t v39 = (int32x4_t)vbslq_s8(v28, (int8x16_t)vmaxq_f32(v38, (float32x4_t)vrev64q_s32(v29)), v33);
          float32x4_t v40 = (float32x4_t)vextq_s8((int8x16_t)v39, (int8x16_t)v39, 0xCuLL);
          float32x4_t v41 = *((float32x4_t *)v13 + 16);
          float32x4_t v42 = *((float32x4_t *)v13 + 17);
          float32x4_t v43 = vminq_f32(vmaxq_f32(vrecpeq_f32(v40), v41), v42);
          float32x4_t v44 = vminq_f32(vmaxq_f32(vmulq_f32(v43, vrecpsq_f32(v40, v43)), v41), v42);
          float32x4_t v45 = (float32x4_t)vbslq_s8(v28, (int8x16_t)vmulq_n_f32((float32x4_t)vbslq_s8(v28, (int8x16_t)vminq_f32((float32x4_t)vextq_s8((int8x16_t)v39, (int8x16_t)v39, 4uLL), (float32x4_t)vrev64q_s32(v39)), v33), vmulq_f32(v44, vrecpsq_f32(v40, v44)).f32[0]), v33);
          int32x4_t v46 = (int32x4_t)vmulq_laneq_f32((float32x4_t)vextq_s8((int8x16_t)v45, (int8x16_t)v45, 0xCuLL), v45, 3);
          float32x4_t v47 = *((float32x4_t *)v13 + 18);
          float32x4_t v48 = *((float32x4_t *)v13 + 19);
          float32x4_t v49 = (float32x4_t)vbslq_s8(v34, (int8x16_t)v46, (int8x16_t)vaddq_f32(v41, vmulq_f32(v47, (float32x4_t)vrev64q_s32(v46))));
          float32x4_t v50 = (float32x4_t)vbslq_s8(v34, (int8x16_t)v46, (int8x16_t)vaddq_f32(v48, vmulq_n_f32(v49, v49.f32[0])));
          float32x4_t v51 = *((float32x4_t *)v13 + 20);
          float32x4_t v52 = *((float32x4_t *)v13 + 21);
          float32x4_t v53 = (float32x4_t)vbslq_s8(v34, (int8x16_t)v46, (int8x16_t)vaddq_f32(v51, vmulq_n_f32(v50, v50.f32[0])));
          float32x4_t v54 = (float32x4_t)vbslq_s8(v34, (int8x16_t)v46, (int8x16_t)vaddq_f32(v52, vmulq_n_f32(v53, v53.f32[0])));
          float32x4_t v55 = (float32x4_t)vbslq_s8(v28, (int8x16_t)vmulq_n_f32(v45, vaddq_f32(v52, vmulq_lane_f32(v54, *(float32x2_t *)v54.f32, 1)).f32[0]), v33);
          int8x16_t v56 = *((int8x16_t *)v13 + 22);
          float32x4_t v57 = (float32x4_t)vbslq_s8(v56, (int8x16_t)vsubq_f32((float32x4_t)vextq_s8((int8x16_t)v55, (int8x16_t)v55, 8uLL), v55), (int8x16_t)v55);
          int64x2_t v58 = (int64x2_t)vbslq_s8((int8x16_t)vcgtq_f32(v52, v57), (int8x16_t)vdupq_lane_s64(vsubq_f32(v51, (float32x4_t)vextq_s8((int8x16_t)v57, (int8x16_t)v57, 0xCuLL)).i64[0], 0), (int8x16_t)vrev64q_s32((int32x4_t)v57));
          v59.i64[0] = v57.i64[0];
          v59.i64[1] = vdupq_laneq_s64(v58, 1).u64[0];
          v57.i64[1] = v58.i64[1];
          float32x4_t v60 = (float32x4_t)vbslq_s8(v28, (int8x16_t)vsubq_f32(v52, (float32x4_t)vrev64q_s32(v59)), (int8x16_t)v57);
          float32x4_t v61 = (float32x4_t)vbslq_s8(v28, veorq_s8(vbslq_s8(v28, vbslq_s8((int8x16_t)vcgtq_f32(v51, v36), (int8x16_t)v60, (int8x16_t)vrev64q_s32((int32x4_t)v60)), (int8x16_t)v36), vandq_s8(vextq_s8((int8x16_t)v60, (int8x16_t)v60, 8uLL), *((int8x16_t *)v13 + 23))), (int8x16_t)v36);
          v60.i64[1] = vsubq_f32(v51, v61).i64[1];
          int8x16_t v62 = (int8x16_t)vcgeq_f32(vnegq_f32(v60), v48);
          float32x4_t v63 = *((float32x4_t *)v13 + 1);
          float32x4_t v64 = *((float32x4_t *)v13 + 24);
          float32x4_t v65 = *((float32x4_t *)v13 + 25);
          float32x4_t v66 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(*(float32x4_t *)v13), v64), v41), v42);
          float32x4_t v67 = (float32x4_t)vbslq_s8(v34, vandq_s8((int8x16_t)v47, v62), (int8x16_t)v60);
          float32x4_t v68 = *((float32x4_t *)v13 + 26);
          float32x4_t v69 = *((float32x4_t *)v13 + 27);
          int8x16_t v70 = vbslq_s8(v18, vbslq_s8((int8x16_t)vcgtq_f32(v68, v67), (int8x16_t)v65, (int8x16_t)v64), (int8x16_t)v67);
          int8x16_t v71 = vbslq_s8(v34, (int8x16_t)vmulq_f32(v66, vrecpsq_f32(*(float32x4_t *)v13, v66)), (int8x16_t)v61);
          float32x4_t v72 = (float32x4_t)vbslq_s8(v28, vbslq_s8((int8x16_t)vcgtq_f32((float32x4_t)vextq_s8(v70, v70, 4uLL), v68), vextq_s8(v70, v70, 8uLL), v71), v71);
          float32x4_t v73 = *((float32x4_t *)v13 + 28);
          float32x4_t v74 = *((float32x4_t *)v13 + 29);
          float32x4_t v75 = vmulq_laneq_f32(vaddq_f32(v69, vmulq_f32(v73, (float32x4_t)vextq_s8((int8x16_t)v72, (int8x16_t)v5, 4uLL))), v72, 2);
          float32x4_t v76 = (float32x4_t)vbslq_s8(v28, (int8x16_t)vmulq_n_f32(v72, COERCE_FLOAT(*v13)), v71);
          float32x4_t v78 = *((float32x4_t *)v13 + 30);
          float32x4_t v77 = *((float32x4_t *)v13 + 31);
          float32x4_t v79 = (float32x4_t)vbslq_s8(v28, (int8x16_t)vmulq_f32(v78, v76), v71);
          v76.i64[0] = vaddq_f32(v74, v75).u64[0];
          int32x4_t v80 = (int32x4_t)vsubq_f32((float32x4_t)vextq_s8((int8x16_t)v79, (int8x16_t)v79, 8uLL), v77);
          float32x4_t v81 = (float32x4_t)vrev64q_s32(v80);
          v76.i64[1] = v70.i64[1];
          float32x4_t v82 = vcvtq_f32_s32(vcvtq_s32_f32(v81));
          int8x16_t v83 = (int8x16_t)vsubq_f32(v82, (float32x4_t)vandq_s8((int8x16_t)v77, (int8x16_t)vcgtq_f32(v82, v81)));
          float32x4_t v84 = vmulq_laneq_f32(*(float32x4_t *)v13, v77, 2);
          int8x16_t v85 = vbslq_s8(v34, (int8x16_t)vaddq_f32(v68, (float32x4_t)vbslq_s8(v34, (int8x16_t)vsubq_f32((float32x4_t)vbslq_s8(v34, v83, (int8x16_t)v76), v84), (int8x16_t)v76)), (int8x16_t)v76);
          float32x4_t v86 = (float32x4_t)vbslq_s8(v28, (int8x16_t)vmulq_n_f32((float32x4_t)vextq_s8((int8x16_t)v79, (int8x16_t)v79, 4uLL), *(float *)v85.i32), v85);
          float32x4_t v87 = vminq_f32(vrsqrteq_f32(v86), v74);
          float32x4_t v88 = vminq_f32(vmulq_f32(v87, vrsqrtsq_f32(vmulq_f32(v87, v86), v87)), v74);
          float32x4_t v89 = (float32x4_t)vbslq_s8(v56, (int8x16_t)vmulq_f32(vminq_f32(vmulq_f32(v88, vrsqrtsq_f32(vmulq_f32(v88, v86), v88)), v74), v86), (int8x16_t)v86);
          v79.i64[1] = vmulq_f32(vaddq_f32(v73, vmulq_lane_f32(v79, *(float32x2_t *)&v89, 1)), v89).i64[1];
          float32x4_t v90 = (float32x4_t)vrev64q_s32((int32x4_t)v89);
          float32x4_t v91 = vcvtq_f32_s32(vcvtq_s32_f32(v90));
          float32x4_t v92 = vsubq_f32(v91, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v91, v90), (int8x16_t)v78, (int8x16_t)0));
          v89.i64[1] = v92.i64[1];
          float32x4_t v93 = (float32x4_t)vbslq_s8(v18, vandq_s8((int8x16_t)v78, (int8x16_t)vcgtq_f32(v68, v79)), (int8x16_t)v79);
          float32x4_t v94 = (float32x4_t)vbslq_s8(v34, (int8x16_t)vsubq_f32(v89, vmulq_laneq_f32(*(float32x4_t *)v13, v92, 2)), (int8x16_t)vmulq_laneq_f32(v93, v93, 2));
          float32x4_t v95 = vaddq_f32(vmulq_lane_f32(v69, *(float32x2_t *)v94.f32, 1), v93);
          v92.i64[0] = v93.i64[0];
          v92.i64[1] = v95.i64[1];
          *(int8x8_t *)v95.f32 = vext_s8(*(int8x8_t *)v93.f32, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v95, (int8x16_t)v95, 8uLL), 4uLL);
          float32x4_t v96 = vsubq_f32(v94, v84);
          v93.i64[0] = vbslq_s8(v34, (int8x16_t)v93, (int8x16_t)vaddq_f32(v95, vmulq_laneq_f32(v92, v77, 3))).u64[0];
          v93.i64[1] = vsubq_f32((float32x4_t)vdupq_lane_s64(*(uint64_t *)&v96, 0), vmulq_n_f32(v77, COERCE_FLOAT(*v13))).i64[1];
          float32x4_t v97 = (float32x4_t)vbslq_s8(v18, (int8x16_t)vmulq_n_f32(v93, v63.f32[0]), (int8x16_t)v93);
          float32x4_t v98 = vaddq_f32(vmulq_laneq_f32(v63, v77, 2), vmulq_f32(v74, (float32x4_t)vrev64q_s32((int32x4_t)v97)));
          float32x4_t v99 = vaddq_f32(v65, v97);
          int8x16_t v100 = (int8x16_t)vsubq_f32(v98, v73);
          v97.i64[1] = v99.i64[1];
          float32x4_t v101 = (float32x4_t)vbslq_s8(v34, v100, (int8x16_t)v80);
          float32x4_t v102 = vcvtq_f32_s32(vcvtq_s32_f32(v101));
          float32x4_t v103 = (float32x4_t)vcgtq_f32(v102, v101);
          v73.i64[0] = vsubq_f32(v102, (float32x4_t)vandq_s8((int8x16_t)v103, (int8x16_t)v77)).u64[0];
          v65.i64[0] = vdupq_laneq_s64((int64x2_t)v99, 1).u64[0];
          v73.i64[1] = v65.i64[0];
          int8x16_t v104 = (int8x16_t)vaddq_f32(v77, (float32x4_t)vrev64q_s32((int32x4_t)v73));
          float32x4_t v105 = (float32x4_t)vbslq_s8(v34, (int8x16_t)vmulq_laneq_f32(v97, v99, 2), v104);
          float32x4_t v106 = *((float32x4_t *)v13 + 32);
          float32x4_t v107 = *((float32x4_t *)v13 + 33);
          float32x4_t v108 = vaddq_f32(v106, vmulq_n_f32(v107, v63.f32[0]));
          float32x4_t v109 = vcvtq_f32_s32(vcvtq_s32_f32(v105));
          float32x4_t v110 = vsubq_f32(v109, (float32x4_t)vandq_s8((int8x16_t)v77, (int8x16_t)vcgtq_f32(v109, v105)));
          v109.i64[0] = v108.i64[0];
          int8x16_t v111 = (int8x16_t)vsubq_f32((float32x4_t)vbslq_s8(v34, (int8x16_t)vsubq_f32((float32x4_t)vextq_s8((int8x16_t)v99, (int8x16_t)v108, 8uLL), vmulq_f32(*(float32x4_t *)v13, (float32x4_t)vbslq_s8(v34, (int8x16_t)v110, v104))), v104), vmulq_laneq_f32(*(float32x4_t *)v13, v107, 2));
          v110.i64[0] = v108.i64[0];
          v110.i64[1] = v65.i64[0];
          v109.i64[1] = v99.i64[1];
          float32x4_t v112 = (float32x4_t)vbslq_s8(v34, v111, v104);
          int8x16_t v113 = vbslq_s8(v34, v111, (int8x16_t)vmaxq_f32(v109, (float32x4_t)vbslq_s8(v34, v111, (int8x16_t)vminq_f32((float32x4_t)vrev64q_s32((int32x4_t)v110), v112))));
          int8x16_t v114 = (int8x16_t)vaddq_f32(v106, (float32x4_t)vextq_s8((int8x16_t)v5, v113, 0xCuLL));
          *(float32x2_t *)v110.f32 = vmin_f32((float32x2_t)*(_OWORD *)&vextq_s8(v114, v114, 8uLL), *(float32x2_t *)v108.f32);
          v65.i64[0] = v108.i64[0];
          float32x4_t v115 = (float32x4_t)vextq_s8(v114, (int8x16_t)v108, 8uLL);
          *(int8x8_t *)v107.f32 = vext_s8(*(int8x8_t *)v108.f32, *(int8x8_t *)v110.f32, 4uLL);
          *(int8x8_t *)v110.f32 = vext_s8(*(int8x8_t *)v110.f32, *(int8x8_t *)v108.f32, 4uLL);
          v108.i64[1] = v114.i64[1];
          v65.i64[1] = vminq_f32(v108, v115).i64[1];
          v110.i64[1] = v107.i64[0];
          float32x4_t v116 = vmaxq_f32(v65, v110);
          v110.i64[0] = v113.i64[0];
          v110.i64[1] = v116.i64[1];
          int8x16_t v117 = vextq_s8((int8x16_t)v110, (int8x16_t)v110, 4uLL);
          float32x4_t v118 = (float32x4_t)vbslq_s8(v34, (int8x16_t)v96, v117);
          v112.i64[1] = *((void *)v13 + 21);
          v118.i32[3] = 1.0;
          float32x4_t v119 = *((float32x4_t *)v13 + 34);
          float32x4_t v120 = *((float32x4_t *)v13 + 8);
          float32x4_t v121 = *((float32x4_t *)v13 + 9);
          int32x4_t v122 = (int32x4_t)vmulq_f32(v121, v118);
          *(int8x8_t *)v109.f32 = vqtbl1_s8((int8x16_t)v122, *(int8x8_t *)v119.f32);
          v116.i64[0] = vextq_s8((int8x16_t)v119, (int8x16_t)v119, 8uLL).u64[0];
          *(int8x8_t *)v122.i8 = vqtbl1_s8((int8x16_t)v122, *(int8x8_t *)v116.f32);
          *(int8x8_t *)v123.f32 = vext_s8(*(int8x8_t *)v122.i8, *(int8x8_t *)v109.f32, 4uLL);
          v123.i64[1] = v123.i64[0];
          v96.i64[0] = vbslq_s8(v34, (int8x16_t)v96, v113).u64[0];
          v109.i64[1] = v109.i64[0];
          float32x4_t v124 = vmulq_f32(v120, v118);
          *(int8x8_t *)v125.f32 = vqtbl1_s8((int8x16_t)v124, *(int8x8_t *)v119.f32);
          *(int8x8_t *)v126.f32 = vqtbl1_s8((int8x16_t)v124, *(int8x8_t *)v116.f32);
          v126.i64[1] = v125.i64[0];
          float32x4_t v127 = vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v122, (int8x16_t)vrev64q_s32(v122), 8uLL), vaddq_f32(v109, v123));
          *(int8x8_t *)v123.f32 = vext_s8(*(int8x8_t *)v126.f32, *(int8x8_t *)v125.f32, 4uLL);
          v96.i64[1] = v127.i64[1];
          v125.i64[1] = v126.i64[0];
          *(int8x8_t *)&v123.u32[2] = vext_s8(*(int8x8_t *)v125.f32, *(int8x8_t *)v126.f32, 4uLL);
          float32x4_t v128 = (float32x4_t)vbslq_s8(v18, v117, (int8x16_t)v112);
          float32x4_t v129 = (float32x4_t)vbslq_s8(v56, (int8x16_t)vaddq_f32(v125, vaddq_f32(v126, v123)), (int8x16_t)v96);
          LODWORD(v13) = a2[11].i32[0];
          float32x4_t v130 = vmulq_f32(v121, v128);
          *(int8x8_t *)v96.f32 = vqtbl1_s8((int8x16_t)v130, *(int8x8_t *)v119.f32);
          *(int8x8_t *)v130.f32 = vqtbl1_s8((int8x16_t)v130, *(int8x8_t *)v116.f32);
          *(int8x8_t *)v124.f32 = vext_s8(*(int8x8_t *)v130.f32, *(int8x8_t *)v96.f32, 4uLL);
          v124.i64[1] = v124.i64[0];
          v96.i64[1] = v96.i64[0];
          int32x2_t v131 = a2[10];
          v113.i64[1] = vaddq_f32((float32x4_t)vextq_s8(*(int8x16_t *)&v130, (int8x16_t)vrev64q_s32(*(int32x4_t *)&v130), 8uLL), vaddq_f32(v96, v124)).i64[1];
          int8x16_t v132 = (int8x16_t)vmulq_f32(v120, v128);
          *(int8x8_t *)v130.f32 = vqtbl1_s8(v132, *(int8x8_t *)v119.f32);
          float32x4_t v133 = vaddq_f32(vsubq_f32((float32x4_t)vextq_s8((int8x16_t)v129, (int8x16_t)v129, 8uLL), v5), v9);
          *(int8x8_t *)v124.f32 = vqtbl1_s8(v132, *(int8x8_t *)v116.f32);
          v124.i64[1] = v130.i64[0];
          *(int8x8_t *)v109.f32 = vext_s8(*(int8x8_t *)v124.f32, *(int8x8_t *)v130.f32, 4uLL);
          int32x4_t v134 = vcvtq_s32_f32(v133);
          v130.i64[1] = v124.i64[0];
          *(int8x8_t *)&v109.u32[2] = vext_s8(*(int8x8_t *)v130.f32, *(int8x8_t *)v124.f32, 4uLL);
          int8x16_t v135 = vbslq_s8(v56, (int8x16_t)vaddq_f32(v130, vaddq_f32(v124, v109)), v113);
          float32x4_t v136 = (float32x4_t)vcgtq_f32(vcvtq_f32_s32(v134), v133);
          float32x4_t v137 = vaddq_f32(vsubq_f32((float32x4_t)vextq_s8(v135, v135, 8uLL), v5), v9);
          float32x4_t v138 = (float32x4_t)vcvtq_s32_f32(v137);
          v137.i64[0] = vaddq_s32((int32x4_t)v138, vcgtq_f32(vcvtq_f32_s32((int32x4_t)v138), v137)).u64[0];
          v136.i64[0] = vaddq_s32(v134, (int32x4_t)v136).u64[0];
          __int32 v139 = v137.i32[0] + v137.i32[1] * v13;
          __int32 v140 = v136.i32[1];
          v129.i32[3] = 1.0;
          int32x4_t v141 = (int32x4_t)vmulq_f32(v121, v129);
          *(int8x8_t *)v138.f32 = vqtbl1_s8((int8x16_t)v141, *(int8x8_t *)v119.f32);
          *(int8x8_t *)v141.i8 = vqtbl1_s8((int8x16_t)v141, *(int8x8_t *)v116.f32);
          __int32 v142 = v136.i32[0];
          *(int8x8_t *)v136.f32 = vext_s8(*(int8x8_t *)v141.i8, *(int8x8_t *)v138.f32, 4uLL);
          v136.i64[1] = v136.i64[0];
          v138.i64[1] = v138.i64[0];
          float32x4_t v143 = vaddq_f32(v138, v136);
          int8x16_t v144 = (int8x16_t)vmulq_f32(v120, v129);
          *(int8x8_t *)v124.f32 = vqtbl1_s8(v144, *(int8x8_t *)v119.f32);
          *(int8x8_t *)v127.f32 = vqtbl1_s8(v144, *(int8x8_t *)v116.f32);
          v127.i64[1] = v124.i64[0];
          float32x4_t v145 = vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v141, (int8x16_t)vrev64q_s32(v141), 8uLL), v143);
          *(int8x8_t *)v143.f32 = vext_s8(*(int8x8_t *)v127.f32, *(int8x8_t *)v124.f32, 4uLL);
          v124.i64[1] = v127.i64[0];
          v135.i64[1] = v145.i64[1];
          *(int8x8_t *)&v143.u32[2] = vext_s8(*(int8x8_t *)v124.f32, *(int8x8_t *)v127.f32, 4uLL);
          float32x4_t v146 = *(float32x4_t *)(*(void *)&v131 + 16 * (v142 + v140 * (int)v13));
          float32x4_t v147 = (float32x4_t)vbslq_s8(v56, (int8x16_t)vaddq_f32(v124, vaddq_f32(v127, v143)), v135);
          float32x4_t v148 = vaddq_f32(vsubq_f32((float32x4_t)vextq_s8((int8x16_t)v147, (int8x16_t)v147, 8uLL), v5), v9);
          int32x4_t v149 = vcvtq_s32_f32(v148);
          v147.i32[3] = 1.0;
          int8x16_t v150 = (int8x16_t)vsubq_f32(v101, vsubq_f32(v102, (float32x4_t)vandq_s8((int8x16_t)v103, (int8x16_t)v78)));
          float32x4_t v151 = vmulq_f32(v121, v147);
          *(int8x8_t *)v103.f32 = vqtbl1_s8((int8x16_t)v151, *(int8x8_t *)v119.f32);
          *(int8x8_t *)v151.f32 = vqtbl1_s8((int8x16_t)v151, *(int8x8_t *)v116.f32);
          *(int8x8_t *)v121.f32 = vext_s8(*(int8x8_t *)v151.f32, *(int8x8_t *)v103.f32, 4uLL);
          v102.i64[0] = vaddq_s32(v149, vcgtq_f32(vcvtq_f32_s32(v149), v148)).u64[0];
          v121.i64[1] = v121.i64[0];
          v103.i64[1] = v103.i64[0];
          v34.i64[0] = vbslq_s8(v34, v100, v150).u64[0];
          int8x16_t v152 = (int8x16_t)vmulq_f32(v120, v147);
          *(int8x8_t *)v119.f32 = vqtbl1_s8(v152, *(int8x8_t *)v119.f32);
          *(int8x8_t *)v116.f32 = vqtbl1_s8(v152, *(int8x8_t *)v116.f32);
          v116.i64[1] = v119.i64[0];
          float32x4_t v153 = vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v151, (int8x16_t)vrev64q_s32((int32x4_t)v151), 8uLL), vaddq_f32(v103, v121));
          *(int8x8_t *)v151.f32 = vext_s8(*(int8x8_t *)v116.f32, *(int8x8_t *)v119.f32, 4uLL);
          v119.i64[1] = v116.i64[0];
          v34.i64[1] = v153.i64[1];
          *(int8x8_t *)&v151.u32[2] = vext_s8(*(int8x8_t *)v119.f32, *(int8x8_t *)v116.f32, 4uLL);
          float32x4_t v154 = (float32x4_t)vbslq_s8(v56, (int8x16_t)vaddq_f32(v119, vaddq_f32(v116, v151)), v34);
          float32x4_t v155 = vaddq_f32(vsubq_f32((float32x4_t)vextq_s8((int8x16_t)v154, (int8x16_t)v154, 8uLL), v5), v9);
          int32x4_t v156 = vcvtq_s32_f32(v155);
          v155.i64[0] = vaddq_s32(v156, vcgtq_f32(vcvtq_f32_s32(v156), v155)).u64[0];
          float32x4_t v157 = *(float32x4_t *)(*(void *)&v131 + 16 * (v102.i32[0] + v102.i32[1] * (int)v13));
          float32x4_t v158 = vcvtq_f32_s32(vcvtq_s32_f32(v154));
          float32x4_t v159 = vaddq_f32(v157, vmulq_lane_f32(vsubq_f32(*(float32x4_t *)(*(void *)&v131 + 16 * (v155.i32[0] + v155.i32[1] * (int)v13)), v157), *(float32x2_t *)v154.f32, 1));
          *(float32x4_t *)(*(void *)&v7 + v11) = vaddq_f32(v159, vmulq_n_f32(vsubq_f32(vaddq_f32(v146, vmulq_lane_f32(vsubq_f32(*(float32x4_t *)(*(void *)&v131 + 16 * v139), v146), *(float32x2_t *)v154.f32, 1)), v159), vsubq_f32(v154, vsubq_f32(v158, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v158, v154), (int8x16_t)v77,
                                                                          (int8x16_t)0))).f32[0]));
          float32x4_t v12 = vaddq_f32(v12, (float32x4_t)xmmword_1B7E736B0);
          v11 += 16;
        }
        while (16 * v6 != v11);
      }
      float32x4_t v10 = vaddq_f32(v10, (float32x4_t)xmmword_1B7E736C0);
      ++v4;
      *(void *)&v7 += v8;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t LiHgcEquirectProject::GetDOD(LiHgcEquirectProject *this, HGRenderer *a2, int a3, HGRect a4)
{
  int v4 = &HGRectInfinite;
  if (a3) {
    int v4 = &HGRectNull;
  }
  return *(void *)v4;
}

uint64_t LiHgcEquirectProject::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  return HGRenderer::GetDOD(a2, Input);
}

void LiHgcEquirectProject::LiHgcEquirectProject(LiHgcEquirectProject *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F1115A78;
  operator new();
}

void sub_1B7A465A0(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void LiHgcEquirectProject::~LiHgcEquirectProject(HGNode *this)
{
  *(void *)this = &unk_1F1115A78;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4044C9E2E8);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  LiHgcEquirectProject::~LiHgcEquirectProject(this);

  HGObject::operator delete(v1);
}

uint64_t LiHgcEquirectProject::SetParameter(LiHgcEquirectProject *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  switch((int)a2)
  {
    case 0:
      int32x2_t v7 = (float *)*((void *)this + 51);
      if (*v7 == a3.n128_f32[0] && v7[1] == a4 && v7[2] == a5 && v7[3] == a6) {
        return 0;
      }
      *int32x2_t v7 = a3.n128_f32[0];
      v7[1] = a4;
      v7[2] = a5;
      v7[3] = a6;
      goto LABEL_53;
    case 1:
      float32x4_t v9 = (float *)*((void *)this + 51);
      if (v9[4] == a3.n128_f32[0] && v9[5] == a4 && v9[6] == a5 && v9[7] == a6) {
        return 0;
      }
      float v9[4] = a3.n128_f32[0];
      v9[5] = a4;
      v9[6] = a5;
      v9[7] = a6;
      goto LABEL_53;
    case 2:
      float32x4_t v10 = (__n128 *)*((void *)this + 51);
      if (v10[2].n128_f32[0] == 0.0
        && v10[2].n128_f32[1] == 0.0
        && v10[2].n128_f32[2] == a3.n128_f32[0]
        && v10[2].n128_f32[3] == 0.0)
      {
        return 0;
      }
      v10[2].n128_u64[0] = 0;
      v10[2].n128_u32[2] = a3.n128_u32[0];
      a3.n128_f32[1] = a4;
      v10[2].n128_u32[3] = 0;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      v10[35] = a3;
      goto LABEL_53;
    case 3:
      uint64_t v11 = (float *)*((void *)this + 51);
      if (v11[12] == a3.n128_f32[0] && v11[13] == a4 && v11[14] == a5 && v11[15] == a6) {
        return 0;
      }
      v11[12] = a3.n128_f32[0];
      v11[13] = a4;
      v11[14] = a5;
      v11[15] = a6;
      goto LABEL_53;
    case 4:
      float32x4_t v12 = (float *)*((void *)this + 51);
      if (v12[16] == a3.n128_f32[0] && v12[17] == a4 && v12[18] == a5 && v12[19] == a6) {
        return 0;
      }
      v12[16] = a3.n128_f32[0];
      v12[17] = a4;
      v12[18] = a5;
      v12[19] = a6;
      goto LABEL_53;
    case 5:
      uint64_t v13 = (float *)*((void *)this + 51);
      if (v13[20] == a3.n128_f32[0] && v13[21] == a4 && v13[22] == a5 && v13[23] == a6) {
        return 0;
      }
      v13[20] = a3.n128_f32[0];
      v13[21] = a4;
      v13[22] = a5;
      v13[23] = a6;
      goto LABEL_53;
    case 6:
      float32x4_t v14 = (float *)*((void *)this + 51);
      if (v14[24] == a3.n128_f32[0] && v14[25] == a4 && v14[26] == a5 && v14[27] == a6) {
        return 0;
      }
      v14[24] = a3.n128_f32[0];
      v14[25] = a4;
      v14[26] = a5;
      v14[27] = a6;
      goto LABEL_53;
    case 7:
      float32x4_t v15 = (float *)*((void *)this + 51);
      if (v15[28] == a3.n128_f32[0] && v15[29] == a4 && v15[30] == a5 && v15[31] == a6) {
        return 0;
      }
      v15[28] = a3.n128_f32[0];
      v15[29] = a4;
      v15[30] = a5;
      v15[31] = a6;
      goto LABEL_53;
    case 8:
      float32x4_t v16 = (float *)*((void *)this + 51);
      if (v16[32] == a3.n128_f32[0] && v16[33] == a4 && v16[34] == a5 && v16[35] == a6) {
        return 0;
      }
      v16[32] = a3.n128_f32[0];
      v16[33] = a4;
      v16[34] = a5;
      v16[35] = a6;
      goto LABEL_53;
    case 9:
      float32x4_t v17 = (float *)*((void *)this + 51);
      if (v17[36] == a3.n128_f32[0] && v17[37] == a4 && v17[38] == a5 && v17[39] == a6) {
        return 0;
      }
      v17[36] = a3.n128_f32[0];
      v17[37] = a4;
      v17[38] = a5;
      v17[39] = a6;
LABEL_53:
      HGNode::ClearBits((HGNode *)this, a2, a7);
      return 1;
    default:
      return 0xFFFFFFFFLL;
  }
}

float LiHgcEquirectProject::GetParameter(LiHgcEquirectProject *this, int a2, float *a3)
{
  switch(a2)
  {
    case 0:
      int v3 = (float *)*((void *)this + 51);
      *a3 = *v3;
      a3[1] = v3[1];
      a3[2] = v3[2];
      int v4 = v3 + 3;
      goto LABEL_12;
    case 1:
      float32x4_t v5 = (float *)*((void *)this + 51);
      *a3 = v5[4];
      a3[1] = v5[5];
      a3[2] = v5[6];
      int v4 = v5 + 7;
      goto LABEL_12;
    case 2:
      int v6 = (float *)*((void *)this + 51);
      *a3 = v6[140];
      a3[1] = v6[141];
      a3[2] = v6[142];
      int v4 = v6 + 143;
      goto LABEL_12;
    case 3:
      int32x2_t v7 = (float *)*((void *)this + 51);
      *a3 = v7[12];
      a3[1] = v7[13];
      a3[2] = v7[14];
      int v4 = v7 + 15;
      goto LABEL_12;
    case 4:
      uint64_t v8 = (float *)*((void *)this + 51);
      *a3 = v8[16];
      a3[1] = v8[17];
      a3[2] = v8[18];
      int v4 = v8 + 19;
      goto LABEL_12;
    case 5:
      float32x4_t v9 = (float *)*((void *)this + 51);
      *a3 = v9[20];
      a3[1] = v9[21];
      a3[2] = v9[22];
      int v4 = v9 + 23;
      goto LABEL_12;
    case 6:
      float32x4_t v10 = (float *)*((void *)this + 51);
      *a3 = v10[24];
      a3[1] = v10[25];
      a3[2] = v10[26];
      int v4 = v10 + 27;
      goto LABEL_12;
    case 7:
      uint64_t v11 = (float *)*((void *)this + 51);
      *a3 = v11[28];
      a3[1] = v11[29];
      a3[2] = v11[30];
      int v4 = v11 + 31;
      goto LABEL_12;
    case 8:
      uint64_t v13 = (float *)*((void *)this + 51);
      *a3 = v13[32];
      a3[1] = v13[33];
      a3[2] = v13[34];
      int v4 = v13 + 35;
      goto LABEL_12;
    case 9:
      float32x4_t v12 = (float *)*((void *)this + 51);
      *a3 = v12[36];
      a3[1] = v12[37];
      a3[2] = v12[38];
      int v4 = v12 + 39;
LABEL_12:
      float result = *v4;
      a3[3] = *v4;
      break;
    default:
      return result;
  }
  return result;
}

double LiHgcEquirectProject::State::State(LiHgcEquirectProject::State *this)
{
  double result = 0.0;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 10) = xmmword_1B837AFB0;
  *((_OWORD *)this + 11) = xmmword_1B7E75360;
  *((_OWORD *)this + 12) = xmmword_1B7E752F0;
  *((_OWORD *)this + 13) = xmmword_1B837AFC0;
  *((_OWORD *)this + 14) = xmmword_1B7E75390;
  *((_OWORD *)this + 15) = xmmword_1B7E751A0;
  *((_OWORD *)this + 16) = xmmword_1B7E75E90;
  *((int32x4_t *)this + 17) = vdupq_n_s32(0x7F7FFFFFu);
  *((_OWORD *)this + 18) = xmmword_1B837AFD0;
  *((_OWORD *)this + 19) = xmmword_1B837AFE0;
  *((_OWORD *)this + 20) = xmmword_1B837AFF0;
  *((_OWORD *)this + 21) = xmmword_1B837B000;
  *((_OWORD *)this + 22) = xmmword_1B7E75350;
  *((_OWORD *)this + 23) = xmmword_1B837B010;
  *((_OWORD *)this + 24) = xmmword_1B837B020;
  *((_OWORD *)this + 25) = xmmword_1B837B030;
  *((_OWORD *)this + 26) = xmmword_1B7E75B20;
  *((_OWORD *)this + 27) = xmmword_1B837B040;
  *((_OWORD *)this + 28) = xmmword_1B837B050;
  *((_OWORD *)this + 29) = xmmword_1B837B060;
  *((_OWORD *)this + 30) = xmmword_1B837B070;
  *((_OWORD *)this + 31) = xmmword_1B837B080;
  *((_OWORD *)this + 32) = xmmword_1B7E75420;
  *((_OWORD *)this + 33) = xmmword_1B837B090;
  *((_OWORD *)this + 34) = xmmword_1B7E75590;
  *((_OWORD *)this + 35) = 0u;
  return result;
}

const char *HgcGradientBlend::GetProgram(HgcGradientBlend *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002e6\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.w = (half) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).w;\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    output.color0 = float4(r0.wwww)*float4(r1);\n"
             "    return output;\n"
             "}\n"
             "//MD5=b4bc87a4:fe351ce8:53d5d7d0:cb789fc8\n"
             "//SIG=00400000:00000003:00000003:00000003:0000:0000:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002ca\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.w = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).w;\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    output.color0 = r0.wwww*r1;\n"
             "    return output;\n"
             "}\n"
             "//MD5=840901ce:6cf857a3:8b59720c:358dc55d\n"
             "//SIG=00000000:00000003:00000003:00000000:0000:0000:0002:0000:0000:0000:0006:0000:0002:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000248\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0.w = texture2D(hg_Texture0, hg_TexCoord0.xy).w;\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    gl_FragColor = r0.wwww*r1;\n"
           "}\n"
           "//MD5=fc30fb8e:6d0b1937:1491b653:13192ed3\n"
           "//SIG=00000000:00000003:00000003:00000000:0000:0000:0002:0000:0000:0000:0000:0000:0002:02:0:1:0\n";
  }
}

void HgcGradientBlend::InitProgramDescriptor(HgcGradientBlend *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcGradientBlend_hgc_visible", "//Metal1.0     \n//LEN=0000000129\n[[ visible ]] FragmentOut HgcGradientBlend_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.w = color0.w;\n"
    "    r1 = color1;\n"
    "    output.color0 = r0.wwww*r1;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcGradientBlend");
}

void sub_1B7A46D5C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E757E0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  int8x16_t v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7A46E9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7A46EE4()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7A46EDCLL);
}

void *HgcGradientBlend::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcGradientBlend [hgc1]");
}

uint64_t HgcGradientBlend::BindTexture(HgcGradientBlend *this, HGHandler *a2, int a3)
{
  if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    int v4 = a2;
    int v5 = 1;
  }
  else
  {
    if (a3) {
      return 0xFFFFFFFFLL;
    }
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    int v4 = a2;
    int v5 = 0;
  }
  HGHandler::TexCoord(v4, v5, 0, 0, 0);
  int v6 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v6)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcGradientBlend::Bind(HgcGradientBlend *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcGradientBlend::RenderTile(HgcGradientBlend *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 12);
    uint64_t v7 = 16 * *((int *)a2 + 22);
    uint64_t v8 = *((void *)a2 + 10);
    uint64_t v9 = 16 * *((int *)a2 + 26);
    uint64_t v10 = 16 * *((int *)a2 + 6);
    do
    {
      if (v4 < 4)
      {
        LODWORD(v17) = 0;
      }
      else
      {
        int v11 = 0;
        uint64_t v12 = 32;
        do
        {
          float32x4_t v13 = vmulq_laneq_f32(*(float32x4_t *)(v6 + v12 - 16), *(float32x4_t *)(v8 + v12 - 16), 3);
          float32x4_t v14 = vmulq_laneq_f32(*(float32x4_t *)(v6 + v12), *(float32x4_t *)(v8 + v12), 3);
          float32x4_t v15 = vmulq_laneq_f32(*(float32x4_t *)(v6 + v12 + 16), *(float32x4_t *)(v8 + v12 + 16), 3);
          float32x4_t v16 = (float32x4_t *)(v5 + v12);
          v16[-2] = vmulq_laneq_f32(*(float32x4_t *)(v6 + v12 - 32), *(float32x4_t *)(v8 + v12 - 32), 3);
          v16[-1] = v13;
          float32x4_t *v16 = v14;
          v16[1] = v15;
          v11 -= 4;
          v12 += 64;
        }
        while (v4 + v11 > 3);
        LODWORD(v17) = -v11;
      }
      if ((int)v17 < v4)
      {
        uint64_t v17 = v17;
        do
        {
          *(float32x4_t *)(v5 + 16 * v17) = vmulq_laneq_f32(*(float32x4_t *)(v6 + 16 * v17), *(float32x4_t *)(v8 + 16 * v17), 3);
          ++v17;
        }
        while (v17 < v4);
      }
      ++v3;
      v8 += v7;
      v6 += v9;
      v5 += v10;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcGradientBlend::GetDOD(HgcGradientBlend *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcGradientBlend::GetROI(HgcGradientBlend *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 2) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcGradientBlend::HgcGradientBlend(HgcGradientBlend *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F1115CE0;
  operator new();
}

void sub_1B7A47258(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcGradientBlend::~HgcGradientBlend(HGNode *this)
{
  *(void *)this = &unk_1F1115CE0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0xC400A2AC0F1);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcGradientBlend::~HgcGradientBlend(this);

  HGObject::operator delete(v1);
}

uint64_t HgcGradientBlend::SetParameter(HgcGradientBlend *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcGradientBlend::GetParameter(HgcGradientBlend *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcColorBalanceNoClip::GetProgram(HgcColorBalanceNoClip *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000030e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = r0*half4(hg_Params[0]);\n"
             "    r1 = half4(hg_Params[1])*r0.wwww + r1;\n"
             "    r2.xyz = pow(fabs(r1.xyz), half3(hg_Params[2].xyz));\n"
             "    r1.xyz = select(r2.xyz, -r2.xyz, r1.xyz < 0.00000h);\n"
             "    output.color0 = mix(float4(r0), float4(r1), hg_Params[3]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=495dfcdb:e6516cd9:0b27cff0:e742c35d\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0004:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002e3\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = r0*hg_Params[0];\n"
             "    r1 = hg_Params[1]*r0.wwww + r1;\n"
             "    r2.xyz = pow(fabs(r1.xyz), hg_Params[2].xyz);\n"
             "    r1.xyz = select(r2.xyz, -r2.xyz, r1.xyz < 0.00000f);\n"
             "    output.color0 = mix(r0, r1, hg_Params[3]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=a853d778:834db82b:f879a4ec:9afacfb2\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0004:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000366\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "uniform mediump vec4 hg_ProgramLocal3;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = r0*hg_ProgramLocal0;\n"
           "    r1 = hg_ProgramLocal1*r0.wwww + r1;\n"
           "    r2.xyz = pow(abs(r1.xyz), hg_ProgramLocal2.xyz);\n"
           "    r1.xyz = vec3(r1.x < 0.00000 ? -r2.x : r2.x, r1.y < 0.00000 ? -r2.y : r2.y, r1.z < 0.00000 ? -r2.z : r2.z"
           ");\n"
           "    gl_FragColor = mix(r0, r1, hg_ProgramLocal3);\n"
           "}\n"
           "//MD5=d33d8d21:3461c00f:bb53e25e:d8ff5ca4\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0004:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcColorBalanceNoClip::InitProgramDescriptor(HgcColorBalanceNoClip *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorBalanceNoClip_hgc_visible", "//Metal1.0     \n//LEN=00000001c2\n[[ visible ]] FragmentOut HgcColorBalanceNoClip_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = r0*hg_Params[0];\n"
    "    r1 = hg_Params[1]*r0.wwww + r1;\n"
    "    r2.xyz = pow(fabs(r1.xyz), hg_Params[2].xyz);\n"
    "    r1.xyz = select(r2.xyz, -r2.xyz, r1.xyz < 0.00000f);\n"
    "    output.color0 = mix(r0, r1, hg_Params[3]);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcColorBalanceNoClip");
}

void sub_1B7A47424(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E758F0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  int8x16_t v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7A47524(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7A47564()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7A4755CLL);
}

void *HgcColorBalanceNoClip::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcColorBalanceNoClip [hgc1]");
}

uint64_t HgcColorBalanceNoClip::BindTexture(HgcColorBalanceNoClip *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcColorBalanceNoClip::Bind(HgcColorBalanceNoClip *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcColorBalanceNoClip::RenderTile(HgcColorBalanceNoClip *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    do
    {
      if (v4 < 2)
      {
        unsigned int v69 = 0;
      }
      else
      {
        int v9 = 0;
        uint64_t v10 = 16;
        do
        {
          float32x4_t v11 = *(float32x4_t *)(v6 + v10 - 16);
          float32x4_t v12 = *(float32x4_t *)(v6 + v10);
          uint64_t v13 = *((void *)this + 51);
          float32x4_t v14 = *(float32x4_t *)(v13 + 16);
          float32x4_t v15 = vaddq_f32(vmulq_f32(v11, *(float32x4_t *)v13), vmulq_laneq_f32(v14, v11, 3));
          float32x4_t v16 = vaddq_f32(vmulq_f32(v12, *(float32x4_t *)v13), vmulq_laneq_f32(v14, v12, 3));
          float32x4_t v17 = vabsq_f32(v15);
          float32x4_t v18 = vabsq_f32(v16);
          int8x16_t v20 = *(int8x16_t *)(v13 + 64);
          float32x4_t v19 = *(float32x4_t *)(v13 + 80);
          float32x4_t v21 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v17), (int8x16_t)v19);
          float32x4_t v22 = *(float32x4_t *)(v13 + 96);
          int8x16_t v23 = *(int8x16_t *)(v13 + 112);
          float32x4_t v24 = (float32x4_t)vorrq_s8(vandq_s8(v20, (int8x16_t)v18), (int8x16_t)v19);
          float32x4_t v25 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)), (float32x4_t)vandq_s8(v23, (int8x16_t)vcgtq_f32(v22, v17)));
          float32x4_t v26 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v18, 0x17uLL)), (float32x4_t)vandq_s8(v23, (int8x16_t)vcgtq_f32(v22, v18)));
          float32x4_t v27 = *(float32x4_t *)(v13 + 128);
          float32x4_t v28 = *(float32x4_t *)(v13 + 144);
          float32x4_t v29 = vsubq_f32(v25, v27);
          float32x4_t v30 = vsubq_f32(v26, v27);
          float32x4_t v31 = (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v21, v28));
          float32x4_t v32 = (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v24, v28));
          float32x4_t v33 = *(float32x4_t *)(v13 + 160);
          float32x4_t v34 = *(float32x4_t *)(v13 + 176);
          float32x4_t v35 = vaddq_f32(v30, v32);
          float32x4_t v36 = vsubq_f32(vsubq_f32(v21, v19), vmulq_f32(vmulq_f32(v33, v31), v21));
          float32x4_t v37 = vsubq_f32(vsubq_f32(v24, v19), vmulq_f32(vmulq_f32(v33, v32), v24));
          float32x4_t v38 = *(float32x4_t *)(v13 + 192);
          float32x4_t v39 = *(float32x4_t *)(v13 + 208);
          float32x4_t v40 = vaddq_f32(v34, vmulq_f32(v38, v36));
          float32x4_t v41 = vaddq_f32(v34, vmulq_f32(v38, v37));
          float32x4_t v42 = *(float32x4_t *)(v13 + 224);
          float32x4_t v43 = *(float32x4_t *)(v13 + 240);
          float32x4_t v44 = vaddq_f32(vaddq_f32(v29, v31), vmulq_f32(v36, vaddq_f32(vaddq_f32(v39, vmulq_f32(v42, v36)), vmulq_f32(vmulq_f32(v36, v36), v40))));
          float32x4_t v45 = vaddq_f32(v35, vmulq_f32(v37, vaddq_f32(vaddq_f32(v39, vmulq_f32(v42, v37)), vmulq_f32(vmulq_f32(v37, v37), v41))));
          float32x4_t v46 = *(float32x4_t *)(v13 + 32);
          float32x4_t v47 = *(float32x4_t *)(v13 + 48);
          float32x4_t v48 = vmaxq_f32(vmulq_f32(v46, v44), v43);
          float32x4_t v49 = vmaxq_f32(vmulq_f32(v46, v45), v43);
          float32x4_t v50 = vcvtq_f32_s32(vcvtq_s32_f32(v48));
          float32x4_t v51 = vcvtq_f32_s32(vcvtq_s32_f32(v49));
          float32x4_t v52 = vsubq_f32(v50, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v50, v48)));
          float32x4_t v53 = vsubq_f32(v51, (float32x4_t)vandq_s8((int8x16_t)v19, (int8x16_t)vcgtq_f32(v51, v49)));
          float32x4_t v54 = vsubq_f32(v48, v52);
          float32x4_t v55 = vsubq_f32(v49, v53);
          float32x4_t v56 = *(float32x4_t *)(v13 + 256);
          float32x4_t v57 = *(float32x4_t *)(v13 + 272);
          float32x4_t v58 = vaddq_f32(v56, vmulq_f32(v57, v54));
          float32x4_t v59 = vaddq_f32(v56, vmulq_f32(v57, v55));
          float32x4_t v60 = *(float32x4_t *)(v13 + 288);
          int32x4_t v61 = *(int32x4_t *)(v13 + 304);
          float32x4_t v62 = vaddq_f32(v19, vmulq_f32(v54, vaddq_f32(v60, vmulq_f32(v54, v58))));
          float32x4_t v63 = vaddq_f32(v19, vmulq_f32(v55, vaddq_f32(v60, vmulq_f32(v55, v59))));
          float32x4_t v64 = (float32x4_t)vshlq_n_s32(vaddq_s32(v61, vcvtq_s32_f32(v53)), 0x17uLL);
          int8x16_t v65 = (int8x16_t)vmulq_f32(v62, (float32x4_t)vshlq_n_s32(vaddq_s32(v61, vcvtq_s32_f32(v52)), 0x17uLL));
          int8x16_t v66 = *(int8x16_t *)(v13 + 320);
          int8x16_t v67 = *(int8x16_t *)(v13 + 336);
          float32x4_t v68 = (float32x4_t *)(v5 + v10);
          v68[-1] = vaddq_f32(v11, vmulq_f32(v47, vsubq_f32((float32x4_t)vbslq_s8(v67, (int8x16_t)v15, veorq_s8(vandq_s8(v66, (int8x16_t)v15), v65)), v11)));
          *float32x4_t v68 = vaddq_f32(v12, vmulq_f32(v47, vsubq_f32((float32x4_t)vbslq_s8(v67, (int8x16_t)v16, veorq_s8(vandq_s8(v66, (int8x16_t)v16), (int8x16_t)vmulq_f32(v63, v64))), v12)));
          v9 -= 2;
          v10 += 32;
        }
        while (v4 + v9 > 1);
        unsigned int v69 = -v9;
      }
      if ((int)v69 < v4)
      {
        float32x4_t v70 = *(float32x4_t *)(v6 + 16 * v69);
        uint64_t v71 = *((void *)this + 51);
        float32x4_t v72 = vaddq_f32(vmulq_f32(v70, *(float32x4_t *)v71), vmulq_laneq_f32(*(float32x4_t *)(v71 + 16), v70, 3));
        float32x4_t v73 = vabsq_f32(v72);
        float32x4_t v74 = *(float32x4_t *)(v71 + 80);
        float32x4_t v75 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v71 + 64), (int8x16_t)v73), (int8x16_t)v74);
        float32x4_t v76 = (float32x4_t)vandq_s8((int8x16_t)v74, (int8x16_t)vcgtq_f32(v75, *(float32x4_t *)(v71 + 144)));
        float32x4_t v77 = vsubq_f32(vsubq_f32(v75, v74), vmulq_f32(vmulq_f32(*(float32x4_t *)(v71 + 160), v76), v75));
        float32x4_t v78 = vmaxq_f32(vmulq_f32(*(float32x4_t *)(v71 + 32), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v73, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v71 + 112), (int8x16_t)vcgtq_f32(*(float32x4_t *)(v71 + 96), v73))), *(float32x4_t *)(v71 + 128)), v76), vmulq_f32(v77, vaddq_f32(vaddq_f32(*(float32x4_t *)(v71 + 208), vmulq_f32(*(float32x4_t *)(v71 + 224), v77)), vmulq_f32(vmulq_f32(v77, v77), vaddq_f32(*(float32x4_t *)(v71 + 176), vmulq_f32(*(float32x4_t *)(v71 + 192), v77))))))),
                *(float32x4_t *)(v71 + 240));
        float32x4_t v79 = vcvtq_f32_s32(vcvtq_s32_f32(v78));
        float32x4_t v80 = vsubq_f32(v79, (float32x4_t)vandq_s8((int8x16_t)v74, (int8x16_t)vcgtq_f32(v79, v78)));
        float32x4_t v81 = vsubq_f32(v78, v80);
        *(float32x4_t *)(v5 + 16 * v69) = vaddq_f32(v70, vmulq_f32(*(float32x4_t *)(v71 + 48), vsubq_f32((float32x4_t)vbslq_s8(*(int8x16_t *)(v71 + 336), (int8x16_t)v72, veorq_s8(vandq_s8(*(int8x16_t *)(v71 + 320), (int8x16_t)v72), (int8x16_t)vmulq_f32(vaddq_f32(v74, vmulq_f32(v81, vaddq_f32(*(float32x4_t *)(v71 + 288), vmulq_f32(v81, vaddq_f32(
                                                                                          *(float32x4_t *)(v71 + 256),
                                                                                          vmulq_f32(*(float32x4_t *)(v71 + 272), v81)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v71 + 304), vcvtq_s32_f32(v80)), 0x17uLL)))), v70)));
      }
      v6 += v8;
      v5 += v7;
      ++v3;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcColorBalanceNoClip::GetDOD(HgcColorBalanceNoClip *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcColorBalanceNoClip::GetROI(HgcColorBalanceNoClip *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcColorBalanceNoClip::HgcColorBalanceNoClip(HgcColorBalanceNoClip *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F1115F48;
  operator new();
}

void sub_1B7A47CA0(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorBalanceNoClip::~HgcColorBalanceNoClip(HGNode *this)
{
  *(void *)this = &unk_1F1115F48;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AF73A19ALL);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcColorBalanceNoClip::~HgcColorBalanceNoClip(this);

  HGObject::operator delete(v1);
}

uint64_t HgcColorBalanceNoClip::SetParameter(HgcColorBalanceNoClip *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  float *v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcColorBalanceNoClip::GetParameter(HgcColorBalanceNoClip *this, unsigned int a2, float *a3)
{
  if (a2 > 3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

uint64_t HgcColorBalanceNoClipGammaOne::Setup(HgcColorBalanceNoClipGammaOne *this, void *a2)
{
  uint64_t v2 = (float32x4_t *)*((void *)this + 62);
  float32x4_t v3 = v2[1];
  float32x4_t v4 = v2[2];
  float32x4_t v5 = vaddq_f32(v2[8], vmulq_f32(v4, vsubq_f32(vaddq_f32(vmulq_f32(v2[8], *v2), vmulq_laneq_f32(v3, v2[8], 3)), v2[8])));
  float32x4_t v6 = vaddq_f32(v2[9], vmulq_f32(v4, vsubq_f32(vaddq_f32(vmulq_f32(v2[9], *v2), vmulq_laneq_f32(v3, v2[9], 3)), v2[9])));
  float32x4_t v7 = vaddq_f32(v2[10], vmulq_f32(v4, vsubq_f32(vaddq_f32(vmulq_f32(v2[10], *v2), vmulq_laneq_f32(v3, v2[10], 3)), v2[10])));
  v2[3] = vaddq_f32(v2[7], vmulq_f32(v4, vsubq_f32(vaddq_f32(vmulq_f32(v2[7], *v2), vmulq_laneq_f32(v3, v2[7], 3)), v2[7])));
  *(float32x4_t *)(*((void *)this + 62) + 64) = v5;
  *(float32x4_t *)(*((void *)this + 62) + 80) = v6;
  *(float32x4_t *)(*((void *)this + 62) + 96) = v7;
  return 0;
}

const char *HgcColorBalanceNoClipGammaOne::GetProgram(HgcColorBalanceNoClipGammaOne *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000298\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = r0*half4(hg_Params[0]);\n"
             "    r1 = half4(hg_Params[1])*r0.wwww + r1;\n"
             "    output.color0 = mix(float4(r0), float4(r1), hg_Params[2]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c65cc828:2159394f:f80023c0:4f30c4ee\n"
             "//SIG=00400000:00000001:00000001:00000001:0000:0003:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000274\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = r0*hg_Params[0];\n"
             "    r1 = hg_Params[1]*r0.wwww + r1;\n"
             "    output.color0 = mix(r0, r1, hg_Params[2]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=80bd144c:5259ff36:49efba23:99823071\n"
             "//SIG=00000000:00000001:00000001:00000000:0000:0003:0002:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000029a\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "uniform defaultp vec4 hg_ProgramLocal2;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = r0*hg_ProgramLocal0;\n"
           "    r1 = hg_ProgramLocal1*r0.wwww + r1;\n"
           "    gl_FragColor = mix(r0, r1, hg_ProgramLocal2);\n"
           "}\n"
           "//MD5=6d318dea:60b330fa:6f2cc7f9:00c2cc0a\n"
           "//SIG=00000000:00000001:00000001:00000000:0000:0003:0002:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcColorBalanceNoClipGammaOne::InitProgramDescriptor(HgcColorBalanceNoClipGammaOne *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorBalanceNoClipGammaOne_hgc_visible", "//Metal1.0     \n//LEN=000000015b\n[[ visible ]] FragmentOut HgcColorBalanceNoClipGammaOne_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    float4 r0, r1;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = r0*hg_Params[0];\n"
    "    r1 = hg_Params[1]*r0.wwww + r1;\n"
    "    output.color0 = mix(r0, r1, hg_Params[2]);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcColorBalanceNoClipGammaOne");
}

void sub_1B7A47FC8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75720;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  float32x4_t v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7A480C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7A48108()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7A48100);
}

void *HgcColorBalanceNoClipGammaOne::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcColorBalanceNoClipGammaOne [hgc1]");
}

uint64_t HgcColorBalanceNoClipGammaOne::BindTexture(HgcColorBalanceNoClipGammaOne *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcColorBalanceNoClipGammaOne::Bind(HgcColorBalanceNoClipGammaOne *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcColorBalanceNoClipGammaOne::RenderTile(HgcColorBalanceNoClipGammaOne *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 22);
    uint64_t v8 = 16 * *((int *)a2 + 6);
    do
    {
      if (v4 < 4)
      {
        LODWORD(v21) = 0;
      }
      else
      {
        int v9 = 0;
        uint64_t v10 = 32;
        do
        {
          float32x4_t v11 = *(float32x4_t *)(v6 + v10 - 16);
          float32x4_t v12 = *(float32x4_t *)(v6 + v10);
          uint64_t v13 = (float32x4_t *)*((void *)this + 62);
          float32x4_t v14 = v13[1];
          float32x4_t v15 = vsubq_f32(vaddq_f32(vmulq_f32(v11, *v13), vmulq_laneq_f32(v14, v11, 3)), v11);
          float32x4_t v16 = vsubq_f32(vaddq_f32(vmulq_f32(v12, *v13), vmulq_laneq_f32(v14, v12, 3)), v12);
          float32x4_t v17 = v13[2];
          float32x4_t v18 = vaddq_f32(*(float32x4_t *)(v6 + v10 - 32), vmulq_f32(v17, vsubq_f32(vaddq_f32(vmulq_f32(*(float32x4_t *)(v6 + v10 - 32), *v13), vmulq_laneq_f32(v14, *(float32x4_t *)(v6 + v10 - 32), 3)), *(float32x4_t *)(v6 + v10 - 32))));
          float32x4_t v19 = vaddq_f32(*(float32x4_t *)(v6 + v10 + 16), vmulq_f32(v17, vsubq_f32(vaddq_f32(vmulq_f32(*(float32x4_t *)(v6 + v10 + 16), *v13), vmulq_laneq_f32(v14, *(float32x4_t *)(v6 + v10 + 16), 3)), *(float32x4_t *)(v6 + v10 + 16))));
          int8x16_t v20 = (float32x4_t *)(v5 + v10);
          v20[-2] = v18;
          v20[-1] = vaddq_f32(v11, vmulq_f32(v17, v15));
          *int8x16_t v20 = vaddq_f32(v12, vmulq_f32(v17, v16));
          v20[1] = v19;
          v9 -= 4;
          v10 += 64;
        }
        while (v4 + v9 > 3);
        LODWORD(v21) = -v9;
      }
      if ((int)v21 < v4)
      {
        uint64_t v21 = v21;
        do
        {
          *(float32x4_t *)(v5 + 16 * v21) = vaddq_f32(*(float32x4_t *)(v6 + 16 * v21), vmulq_f32(*(float32x4_t *)(*((void *)this + 62) + 32), vsubq_f32(vaddq_f32(vmulq_f32(*(float32x4_t *)(v6 + 16 * v21), *(float32x4_t *)*((void *)this + 62)), vmulq_laneq_f32(*(float32x4_t *)(*((void *)this + 62) + 16), *(float32x4_t *)(v6 + 16 * v21), 3)), *(float32x4_t *)(v6 + 16 * v21))));
          ++v21;
        }
        while (v21 < v4);
      }
      ++v3;
      v6 += v7;
      v5 += v8;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcColorBalanceNoClipGammaOne::GetDOD(HgcColorBalanceNoClipGammaOne *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcColorBalanceNoClipGammaOne::GetROI(HgcColorBalanceNoClipGammaOne *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcColorBalanceNoClipGammaOne::HgcColorBalanceNoClipGammaOne(HgcColorBalanceNoClipGammaOne *this)
{
}

void sub_1B7A48570(_Unwind_Exception *a1)
{
  HGColorMatrix::~HGColorMatrix(v1);
  _Unwind_Resume(a1);
}

void HgcColorBalanceNoClipGammaOne::~HgcColorBalanceNoClipGammaOne(HgcColorBalanceNoClipGammaOne *this)
{
  *(void *)this = &unk_1F1116198;
  uint64_t v2 = *((void *)this + 62);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C408070C27FLL);
  }

  HGColorMatrix::~HGColorMatrix(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcColorBalanceNoClipGammaOne::~HgcColorBalanceNoClipGammaOne(this);

  HGObject::operator delete(v1);
}

uint64_t HgcColorBalanceNoClipGammaOne::SetParameter(HgcColorBalanceNoClipGammaOne *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  switch((int)a2)
  {
    case 0:
      uint64_t v7 = (float *)*((void *)this + 62);
      if (*v7 == a3.n128_f32[0] && v7[1] == a4 && v7[2] == a5 && v7[3] == a6) {
        return 0;
      }
      *uint64_t v7 = a3.n128_f32[0];
      v7[1] = a4;
      v7[2] = a5;
      v7[3] = a6;
      goto LABEL_19;
    case 1:
      int v9 = (float *)*((void *)this + 62);
      if (v9[4] == a3.n128_f32[0] && v9[5] == a4 && v9[6] == a5 && v9[7] == a6) {
        return 0;
      }
      float v9[4] = a3.n128_f32[0];
      v9[5] = a4;
      v9[6] = a5;
      v9[7] = a6;
      goto LABEL_19;
    case 2:
      uint64_t v8 = 0;
      a3.n128_f32[1] = a4;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      *(__n128 *)(*((void *)this + 62) + 176) = a3;
      return v8;
    case 3:
      uint64_t v10 = (float *)*((void *)this + 62);
      if (v10[8] == a3.n128_f32[0] && v10[9] == a4 && v10[10] == a5 && v10[11] == a6) {
        return 0;
      }
      v10[8] = a3.n128_f32[0];
      v10[9] = a4;
      v10[10] = a5;
      v10[11] = a6;
LABEL_19:
      uint64_t v8 = 1;
      *((_DWORD *)this + 126) = 1;
      HGNode::ClearBits((HGNode *)this, a2, a7);
      return v8;
    default:
      return 0xFFFFFFFFLL;
  }
}

float HgcColorBalanceNoClipGammaOne::GetParameter(HgcColorBalanceNoClipGammaOne *this, int a2, float *a3)
{
  switch(a2)
  {
    case 0:
      int v3 = (float *)*((void *)this + 62);
      *a3 = *v3;
      a3[1] = v3[1];
      a3[2] = v3[2];
      int v4 = v3 + 3;
      goto LABEL_6;
    case 1:
      uint64_t v5 = (float *)*((void *)this + 62);
      *a3 = v5[4];
      a3[1] = v5[5];
      a3[2] = v5[6];
      int v4 = v5 + 7;
      goto LABEL_6;
    case 2:
      uint64_t v6 = (float *)*((void *)this + 62);
      *a3 = v6[44];
      a3[1] = v6[45];
      a3[2] = v6[46];
      int v4 = v6 + 47;
      goto LABEL_6;
    case 3:
      uint64_t v7 = (float *)*((void *)this + 62);
      *a3 = v7[8];
      a3[1] = v7[9];
      a3[2] = v7[10];
      int v4 = v7 + 11;
LABEL_6:
      float result = *v4;
      a3[3] = *v4;
      break;
    default:
      return result;
  }
  return result;
}

HGNode *HgcColorBalanceNoClipGammaOne::GetOutput(HgcColorBalanceNoClipGammaOne *this, HGRenderer *a2, __n128 a3, double a4, int32x2_t a5)
{
  if (*((_DWORD *)this + 126))
  {
    HgcColorBalanceNoClipGammaOne::Setup(this, a2);
    uint64_t v7 = *((void *)this + 62);
    *((_OWORD *)this + 27) = *(_OWORD *)(v7 + 48);
    *((_OWORD *)this + 28) = *(_OWORD *)(v7 + 64);
    *((_OWORD *)this + 29) = *(_OWORD *)(v7 + 80);
    a3 = *(__n128 *)(v7 + 96);
    *((__n128 *)this + 30) = a3;
    *((_DWORD *)this + 126) = 0;
  }

  return HGColorMatrix::GetOutput(this, a2, a3.n128_f64[0], a4, a5);
}

const char *HgcColorBalanceClip::GetProgram(HgcColorBalanceClip *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000497\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = r0*half4(hg_Params[0]);\n"
             "    r1 = half4(hg_Params[1])*r0.wwww + r1;\n"
             "    r2.xyz = pow(fabs(r1.xyz), half3(hg_Params[2].xyz));\n"
             "    r1.xyz = select(r2.xyz, -r2.xyz, r1.xyz < 0.00000h);\n"
             "    r2.xyz = r1.xyz / fmax(r1.w, 6.10350e-05h);\n"
             "    r3.xyz = fmin(c0.xxx, r2.xyz);\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, half3(hg_Params[4].xxx) < 0.00000h);\n"
             "    r3.xyz = fmax(c0.yyy, r2.xyz);\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, half3(hg_Params[4].yyy) < 0.00000h);\n"
             "    r2.xyz = r2.xyz*r1.www;\n"
             "    r2.w = r1.w;\n"
             "    output.color0 = mix(float4(r0), float4(r2), hg_Params[3]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=cc94ffa7:a8f1aded:b91a8e07:d022c466\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0005:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000460\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = r0*hg_Params[0];\n"
             "    r1 = hg_Params[1]*r0.wwww + r1;\n"
             "    r2.xyz = pow(fabs(r1.xyz), hg_Params[2].xyz);\n"
             "    r1.xyz = select(r2.xyz, -r2.xyz, r1.xyz < 0.00000f);\n"
             "    r2.xyz = r1.xyz / fmax(r1.w, 1.00000e-06f);\n"
             "    r3.xyz = fmin(c0.xxx, r2.xyz);\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, hg_Params[4].xxx < 0.00000f);\n"
             "    r3.xyz = fmax(c0.yyy, r2.xyz);\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, hg_Params[4].yyy < 0.00000f);\n"
             "    r2.xyz = r2.xyz*r1.www;\n"
             "    r2.w = r1.w;\n"
             "    output.color0 = mix(r0, r2, hg_Params[3]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=64dd2f92:8f08076c:462fe5df:9f8ff622\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0005:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000005b4\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "uniform mediump vec4 hg_ProgramLocal3;\n"
           "uniform mediump vec4 hg_ProgramLocal4;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = r0*hg_ProgramLocal0;\n"
           "    r1 = hg_ProgramLocal1*r0.wwww + r1;\n"
           "    r2.xyz = pow(abs(r1.xyz), hg_ProgramLocal2.xyz);\n"
           "    r1.xyz = vec3(r1.x < 0.00000 ? -r2.x : r2.x, r1.y < 0.00000 ? -r2.y : r2.y, r1.z < 0.00000 ? -r2.z : r2.z"
           ");\n"
           "    r2.xyz = r1.xyz / max(r1.w, 1.00000e-06);\n"
           "    r3.xyz = min(c0.xxx, r2.xyz);\n"
           "    r2.xyz = vec3(hg_ProgramLocal4.x < 0.00000 ? r3.x : r2.x, hg_ProgramLocal4.x < 0.00000 ? r3.y : r2.y, hg_"
           "ProgramLocal4.x < 0.00000 ? r3.z : r2.z);\n"
           "    r3.xyz = max(c0.yyy, r2.xyz);\n"
           "    r2.xyz = vec3(hg_ProgramLocal4.y < 0.00000 ? r3.x : r2.x, hg_ProgramLocal4.y < 0.00000 ? r3.y : r2.y, hg_"
           "ProgramLocal4.y < 0.00000 ? r3.z : r2.z);\n"
           "    r2.xyz = r2.xyz*r1.www;\n"
           "    r2.w = r1.w;\n"
           "    gl_FragColor = mix(r0, r2, hg_ProgramLocal3);\n"
           "}\n"
           "//MD5=a81534bc:fd1c914e:7d55a0c7:efeaf040\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0005:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcColorBalanceClip::InitProgramDescriptor(HgcColorBalanceClip *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorBalanceClip_hgc_visible", "//Metal1.0     \n//LEN=000000033d\n[[ visible ]] FragmentOut HgcColorBalanceClip_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = r0*hg_Params[0];\n"
    "    r1 = hg_Params[1]*r0.wwww + r1;\n"
    "    r2.xyz = pow(fabs(r1.xyz), hg_Params[2].xyz);\n"
    "    r1.xyz = select(r2.xyz, -r2.xyz, r1.xyz < 0.00000f);\n"
    "    r2.xyz = r1.xyz / fmax(r1.w, 1.00000e-06f);\n"
    "    r3.xyz = fmin(c0.xxx, r2.xyz);\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, hg_Params[4].xxx < 0.00000f);\n"
    "    r3.xyz = fmax(c0.yyy, r2.xyz);\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, hg_Params[4].yyy < 0.00000f);\n"
    "    r2.xyz = r2.xyz*r1.www;\n"
    "    r2.w = r1.w;\n"
    "    output.color0 = mix(r0, r2, hg_Params[3]);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcColorBalanceClip");
}

void sub_1B7A489D0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75C50;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  float32x4_t v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7A48AD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7A48B10()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7A48B08);
}

void *HgcColorBalanceClip::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcColorBalanceClip [hgc1]");
}

uint64_t HgcColorBalanceClip::BindTexture(HgcColorBalanceClip *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcColorBalanceClip::Bind(HgcColorBalanceClip *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcColorBalanceClip::RenderTile(HgcColorBalanceClip *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    do
    {
      if (v4 < 2)
      {
        unsigned int v83 = 0;
      }
      else
      {
        int v9 = 0;
        uint64_t v10 = 16;
        do
        {
          float32x4_t v11 = *(float32x4_t *)(v6 + v10 - 16);
          float32x4_t v12 = *(float32x4_t *)(v6 + v10);
          uint64_t v13 = *((void *)this + 51);
          float32x4_t v14 = *(float32x4_t *)(v13 + 16);
          float32x4_t v15 = vaddq_f32(vmulq_f32(v11, *(float32x4_t *)v13), vmulq_laneq_f32(v14, v11, 3));
          float32x4_t v16 = vaddq_f32(vmulq_f32(v12, *(float32x4_t *)v13), vmulq_laneq_f32(v14, v12, 3));
          float32x4_t v17 = vabsq_f32(v15);
          float32x4_t v18 = vabsq_f32(v16);
          long long v20 = *(_OWORD *)(v13 + 64);
          int8x16_t v19 = *(int8x16_t *)(v13 + 80);
          float32x4_t v21 = *(float32x4_t *)(v13 + 96);
          float32x4_t v22 = *(float32x4_t *)(v13 + 112);
          float32x4_t v23 = (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)v17), (int8x16_t)v21);
          int8x16_t v24 = *(int8x16_t *)(v13 + 128);
          float32x4_t v25 = *(float32x4_t *)(v13 + 144);
          float32x4_t v26 = (float32x4_t)vorrq_s8(vandq_s8(v19, (int8x16_t)v18), (int8x16_t)v21);
          float32x4_t v27 = vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v18, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v22, v18)));
          float32x4_t v28 = vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v17, 0x17uLL)), (float32x4_t)vandq_s8(v24, (int8x16_t)vcgtq_f32(v22, v17))), v25);
          float32x4_t v29 = *(float32x4_t *)(v13 + 160);
          float32x4_t v30 = *(float32x4_t *)(v13 + 176);
          float32x4_t v31 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v23, v29));
          float32x4_t v32 = (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v26, v29));
          float32x4_t v33 = vaddq_f32(vsubq_f32(v27, v25), v32);
          float32x4_t v34 = vsubq_f32(vsubq_f32(v23, v21), vmulq_f32(vmulq_f32(v30, v31), v23));
          float32x4_t v35 = vsubq_f32(vsubq_f32(v26, v21), vmulq_f32(vmulq_f32(v30, v32), v26));
          float32x4_t v36 = *(float32x4_t *)(v13 + 192);
          float32x4_t v37 = *(float32x4_t *)(v13 + 208);
          float32x4_t v38 = *(float32x4_t *)(v13 + 224);
          float32x4_t v39 = *(float32x4_t *)(v13 + 240);
          float32x4_t v40 = vaddq_f32(vaddq_f32(v28, v31), vmulq_f32(v34, vaddq_f32(vaddq_f32(v38, vmulq_f32(v39, v34)), vmulq_f32(vmulq_f32(v34, v34), vaddq_f32(v36, vmulq_f32(v37, v34))))));
          float32x4_t v41 = vaddq_f32(v33, vmulq_f32(v35, vaddq_f32(vaddq_f32(v38, vmulq_f32(v39, v35)), vmulq_f32(vmulq_f32(v35, v35), vaddq_f32(v36, vmulq_f32(v37, v35))))));
          float32x4_t v42 = *(float32x4_t *)(v13 + 32);
          float32x4_t v43 = *(float32x4_t *)(v13 + 48);
          float32x4_t v44 = vmulq_f32(v42, v40);
          float32x4_t v45 = vmulq_f32(v42, v41);
          float32x4_t v47 = *(float32x4_t *)(v13 + 256);
          float32x4_t v46 = *(float32x4_t *)(v13 + 272);
          float32x4_t v48 = vmaxq_f32(v44, v47);
          float32x4_t v49 = vmaxq_f32(v45, v47);
          float32x4_t v50 = vcvtq_f32_s32(vcvtq_s32_f32(v48));
          float32x4_t v51 = vcvtq_f32_s32(vcvtq_s32_f32(v49));
          float32x4_t v52 = vsubq_f32(v50, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v50, v48)));
          float32x4_t v53 = vsubq_f32(v51, (float32x4_t)vandq_s8((int8x16_t)v21, (int8x16_t)vcgtq_f32(v51, v49)));
          float32x4_t v54 = vsubq_f32(v48, v52);
          float32x4_t v55 = vsubq_f32(v49, v53);
          float32x4_t v56 = *(float32x4_t *)(v13 + 288);
          float32x4_t v57 = *(float32x4_t *)(v13 + 304);
          float32x4_t v58 = vmulq_f32(v55, vaddq_f32(v57, vmulq_f32(v55, vaddq_f32(v46, vmulq_f32(v56, v55)))));
          float32x4_t v59 = vaddq_f32(v21, vmulq_f32(v54, vaddq_f32(v57, vmulq_f32(v54, vaddq_f32(v46, vmulq_f32(v56, v54))))));
          int32x4_t v60 = vcvtq_s32_f32(v52);
          int32x4_t v61 = vcvtq_s32_f32(v53);
          int32x4_t v62 = *(int32x4_t *)(v13 + 320);
          int8x16_t v63 = *(int8x16_t *)(v13 + 336);
          int8x16_t v64 = veorq_s8(vandq_s8(v63, (int8x16_t)v15), (int8x16_t)vmulq_f32(v59, (float32x4_t)vshlq_n_s32(vaddq_s32(v62, v60), 0x17uLL)));
          int8x16_t v65 = veorq_s8(vandq_s8(v63, (int8x16_t)v16), (int8x16_t)vmulq_f32(vaddq_f32(v21, v58), (float32x4_t)vshlq_n_s32(vaddq_s32(v62, v61), 0x17uLL)));
          int8x16_t v66 = *(int8x16_t *)(v13 + 352);
          float32x4_t v67 = *(float32x4_t *)(v13 + 368);
          float32x4_t v68 = (float32x4_t)vbslq_s8(v66, (int8x16_t)v15, v64);
          float32x4_t v69 = (float32x4_t)vbslq_s8(v66, (int8x16_t)v16, v65);
          float32x4_t v70 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v68, 3), v67);
          float32x4_t v71 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v69, 3), v67);
          float32x4_t v72 = *(float32x4_t *)(v13 + 384);
          float32x4_t v73 = *(float32x4_t *)(v13 + 400);
          float32x4_t v74 = vmulq_f32(vrecpeq_f32(v70), v72);
          float32x4_t v75 = vmulq_f32(vrecpeq_f32(v71), v72);
          float32x4_t v76 = vmulq_f32(vmulq_f32(v74, vrecpsq_f32(v74, v70)), v68);
          float32x4_t v77 = vmulq_f32(vmulq_f32(v75, vrecpsq_f32(v75, v71)), v69);
          int8x16_t v78 = (int8x16_t)vcgtq_f32(v73, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v20, 0));
          float32x4_t v79 = (float32x4_t)vbslq_s8(v78, (int8x16_t)vminq_f32(v76, v21), (int8x16_t)v76);
          float32x4_t v80 = (float32x4_t)vbslq_s8(v78, (int8x16_t)vminq_f32(v77, v21), (int8x16_t)v77);
          int8x16_t v81 = (int8x16_t)vcgtq_f32(v73, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v20, 1));
          float32x4_t v82 = (float32x4_t *)(v5 + v10);
          v82[-1] = vaddq_f32(v11, vmulq_f32(v43, vsubq_f32((float32x4_t)vbslq_s8(v66, (int8x16_t)v15, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v81, (int8x16_t)vmaxq_f32(v79, v73), (int8x16_t)v79), v68, 3)), v11)));
          float32x4_t *v82 = vaddq_f32(v12, vmulq_f32(v43, vsubq_f32((float32x4_t)vbslq_s8(v66, (int8x16_t)v16, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v81, (int8x16_t)vmaxq_f32(v80, v73), (int8x16_t)v80), v69, 3)), v12)));
          v9 -= 2;
          v10 += 32;
        }
        while (v4 + v9 > 1);
        unsigned int v83 = -v9;
      }
      if ((int)v83 < v4)
      {
        float32x4_t v84 = *(float32x4_t *)(v6 + 16 * v83);
        uint64_t v85 = *((void *)this + 51);
        float32x4_t v86 = vaddq_f32(vmulq_f32(v84, *(float32x4_t *)v85), vmulq_laneq_f32(*(float32x4_t *)(v85 + 16), v84, 3));
        float32x4_t v87 = vabsq_f32(v86);
        long long v88 = *(_OWORD *)(v85 + 64);
        float32x4_t v89 = *(float32x4_t *)(v85 + 96);
        float32x4_t v90 = (float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v85 + 80), (int8x16_t)v87), (int8x16_t)v89);
        float32x4_t v91 = (float32x4_t)vandq_s8((int8x16_t)v89, (int8x16_t)vcgtq_f32(v90, *(float32x4_t *)(v85 + 160)));
        float32x4_t v92 = vsubq_f32(vsubq_f32(v90, v89), vmulq_f32(vmulq_f32(*(float32x4_t *)(v85 + 176), v91), v90));
        float32x4_t v93 = vmaxq_f32(vmulq_f32(*(float32x4_t *)(v85 + 32), vaddq_f32(vaddq_f32(vsubq_f32(vsubq_f32(vcvtq_f32_s32((int32x4_t)vshrq_n_u32((uint32x4_t)v87, 0x17uLL)), (float32x4_t)vandq_s8(*(int8x16_t *)(v85 + 128), (int8x16_t)vcgtq_f32(*(float32x4_t *)(v85 + 112), v87))), *(float32x4_t *)(v85 + 144)), v91), vmulq_f32(v92, vaddq_f32(vaddq_f32(*(float32x4_t *)(v85 + 224), vmulq_f32(*(float32x4_t *)(v85 + 240), v92)), vmulq_f32(vmulq_f32(v92, v92), vaddq_f32(*(float32x4_t *)(v85 + 192), vmulq_f32(*(float32x4_t *)(v85 + 208), v92))))))),
                *(float32x4_t *)(v85 + 256));
        float32x4_t v94 = vcvtq_f32_s32(vcvtq_s32_f32(v93));
        float32x4_t v95 = vsubq_f32(v94, (float32x4_t)vandq_s8((int8x16_t)v89, (int8x16_t)vcgtq_f32(v94, v93)));
        float32x4_t v96 = vsubq_f32(v93, v95);
        int8x16_t v97 = veorq_s8(vandq_s8(*(int8x16_t *)(v85 + 336), (int8x16_t)v86), (int8x16_t)vmulq_f32(vaddq_f32(v89, vmulq_f32(v96, vaddq_f32(*(float32x4_t *)(v85 + 304), vmulq_f32(v96, vaddq_f32(*(float32x4_t *)(v85 + 272), vmulq_f32(*(float32x4_t *)(v85 + 288), v96)))))), (float32x4_t)vshlq_n_s32(vaddq_s32(*(int32x4_t *)(v85 + 320), vcvtq_s32_f32(v95)), 0x17uLL)));
        int8x16_t v98 = *(int8x16_t *)(v85 + 352);
        float32x4_t v99 = (float32x4_t)vbslq_s8(v98, (int8x16_t)v86, v97);
        float32x4_t v100 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v99, 3), *(float32x4_t *)(v85 + 368));
        float32x4_t v101 = *(float32x4_t *)(v85 + 400);
        float32x4_t v102 = vmulq_f32(vrecpeq_f32(v100), *(float32x4_t *)(v85 + 384));
        float32x4_t v103 = vmulq_f32(vmulq_f32(v102, vrecpsq_f32(v102, v100)), v99);
        float32x4_t v104 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v101, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v88, 0)), (int8x16_t)vminq_f32(v103, v89), (int8x16_t)v103);
        *(float32x4_t *)(v5 + 16 * v83) = vaddq_f32(v84, vmulq_f32(*(float32x4_t *)(v85 + 48), vsubq_f32((float32x4_t)vbslq_s8(v98, (int8x16_t)v86, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v101, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v88, 1)), (int8x16_t)vmaxq_f32(v104, v101), (int8x16_t)v104), v99, 3)), v84)));
      }
      v6 += v8;
      v5 += v7;
      ++v3;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcColorBalanceClip::GetDOD(HgcColorBalanceClip *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcColorBalanceClip::GetROI(HgcColorBalanceClip *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcColorBalanceClip::HgcColorBalanceClip(HgcColorBalanceClip *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F11163F8;
  operator new();
}

void sub_1B7A49294(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorBalanceClip::~HgcColorBalanceClip(HGNode *this)
{
  *(void *)this = &unk_1F11163F8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C407DC911DDLL);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcColorBalanceClip::~HgcColorBalanceClip(this);

  HGObject::operator delete(v1);
}

uint64_t HgcColorBalanceClip::SetParameter(HgcColorBalanceClip *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  float *v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcColorBalanceClip::GetParameter(HgcColorBalanceClip *this, unsigned int a2, float *a3)
{
  if (a2 > 4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcColorBalanceClipGammaOne::GetProgram(HgcColorBalanceClipGammaOne *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000425\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = r0*half4(hg_Params[0]);\n"
             "    r1 = half4(hg_Params[1])*r0.wwww + r1;\n"
             "    r2.xyz = r1.xyz / fmax(r1.w, 6.10350e-05h);\n"
             "    r3.xyz = fmin(c0.xxx, r2.xyz);\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, half3(hg_Params[3].xxx) < 0.00000h);\n"
             "    r3.xyz = fmax(c0.yyy, r2.xyz);\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, half3(hg_Params[3].yyy) < 0.00000h);\n"
             "    r2.xyz = r2.xyz*r1.www;\n"
             "    r2.w = r1.w;\n"
             "    output.color0 = mix(float4(r0), float4(r2), hg_Params[2]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=83f75fc7:4ca1b897:e3759a6f:08207cfa\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0004:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000003f5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = r0*hg_Params[0];\n"
             "    r1 = hg_Params[1]*r0.wwww + r1;\n"
             "    r2.xyz = r1.xyz / fmax(r1.w, 1.00000e-06f);\n"
             "    r3.xyz = fmin(c0.xxx, r2.xyz);\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, hg_Params[3].xxx < 0.00000f);\n"
             "    r3.xyz = fmax(c0.yyy, r2.xyz);\n"
             "    r2.xyz = select(r2.xyz, r3.xyz, hg_Params[3].yyy < 0.00000f);\n"
             "    r2.xyz = r2.xyz*r1.www;\n"
             "    r2.w = r1.w;\n"
             "    output.color0 = mix(r0, r2, hg_Params[2]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c8cac95c:21f13127:583e3fea:a8bbd9f9\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000004e8\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "uniform mediump vec4 hg_ProgramLocal3;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = r0*hg_ProgramLocal0;\n"
           "    r1 = hg_ProgramLocal1*r0.wwww + r1;\n"
           "    r2.xyz = r1.xyz / max(r1.w, 1.00000e-06);\n"
           "    r3.xyz = min(c0.xxx, r2.xyz);\n"
           "    r2.xyz = vec3(hg_ProgramLocal3.x < 0.00000 ? r3.x : r2.x, hg_ProgramLocal3.x < 0.00000 ? r3.y : r2.y, hg_"
           "ProgramLocal3.x < 0.00000 ? r3.z : r2.z);\n"
           "    r3.xyz = max(c0.yyy, r2.xyz);\n"
           "    r2.xyz = vec3(hg_ProgramLocal3.y < 0.00000 ? r3.x : r2.x, hg_ProgramLocal3.y < 0.00000 ? r3.y : r2.y, hg_"
           "ProgramLocal3.y < 0.00000 ? r3.z : r2.z);\n"
           "    r2.xyz = r2.xyz*r1.www;\n"
           "    r2.w = r1.w;\n"
           "    gl_FragColor = mix(r0, r2, hg_ProgramLocal2);\n"
           "}\n"
           "//MD5=61be9d35:e7c0e125:f4958337:6edc34f0\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcColorBalanceClipGammaOne::InitProgramDescriptor(HgcColorBalanceClipGammaOne *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcColorBalanceClipGammaOne_hgc_visible", "//Metal1.0     \n//LEN=00000002da\n[[ visible ]] FragmentOut HgcColorBalanceClipGammaOne_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(1.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = r0*hg_Params[0];\n"
    "    r1 = hg_Params[1]*r0.wwww + r1;\n"
    "    r2.xyz = r1.xyz / fmax(r1.w, 1.00000e-06f);\n"
    "    r3.xyz = fmin(c0.xxx, r2.xyz);\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, hg_Params[3].xxx < 0.00000f);\n"
    "    r3.xyz = fmax(c0.yyy, r2.xyz);\n"
    "    r2.xyz = select(r2.xyz, r3.xyz, hg_Params[3].yyy < 0.00000f);\n"
    "    r2.xyz = r2.xyz*r1.www;\n"
    "    r2.w = r1.w;\n"
    "    output.color0 = mix(r0, r2, hg_Params[2]);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcColorBalanceClipGammaOne");
}

void sub_1B7A49524(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E758F0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  float32x4_t v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7A49624(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7A49664()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7A4965CLL);
}

void *HgcColorBalanceClipGammaOne::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcColorBalanceClipGammaOne [hgc1]");
}

uint64_t HgcColorBalanceClipGammaOne::BindTexture(HgcColorBalanceClipGammaOne *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcColorBalanceClipGammaOne::Bind(HgcColorBalanceClipGammaOne *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcColorBalanceClipGammaOne::RenderTile(HgcColorBalanceClipGammaOne *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    do
    {
      if (v4 < 3)
      {
        LODWORD(v45) = 0;
      }
      else
      {
        uint64_t v9 = 0;
        int v10 = 0;
        do
        {
          float32x4_t v11 = *(float32x4_t *)(v6 + v9);
          float32x4_t v12 = *(float32x4_t *)(v6 + v9 + 16);
          float32x4_t v13 = *(float32x4_t *)(v6 + v9 + 32);
          uint64_t v14 = *((void *)this + 51);
          float32x4_t v15 = *(float32x4_t *)(v14 + 16);
          float32x4_t v16 = vaddq_f32(vmulq_f32(v11, *(float32x4_t *)v14), vmulq_laneq_f32(v15, v11, 3));
          float32x4_t v17 = vaddq_f32(vmulq_f32(v12, *(float32x4_t *)v14), vmulq_laneq_f32(v15, v12, 3));
          float32x4_t v18 = vaddq_f32(vmulq_f32(v13, *(float32x4_t *)v14), vmulq_laneq_f32(v15, v13, 3));
          float32x4_t v19 = *(float32x4_t *)(v14 + 64);
          float32x4_t v20 = *(float32x4_t *)(v14 + 80);
          float32x4_t v21 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 3), v19);
          float32x4_t v22 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 3), v19);
          float32x4_t v23 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 3), v19);
          float32x4_t v24 = vmulq_f32(vrecpeq_f32(v21), v20);
          float32x4_t v25 = vmulq_f32(vrecpeq_f32(v22), v20);
          float32x4_t v26 = vmulq_f32(vrecpeq_f32(v23), v20);
          float32x4_t v27 = vmulq_f32(v16, vmulq_f32(v24, vrecpsq_f32(v24, v21)));
          float32x4_t v28 = vmulq_f32(v17, vmulq_f32(v25, vrecpsq_f32(v25, v22)));
          float32x4_t v29 = vmulq_f32(v18, vmulq_f32(v26, vrecpsq_f32(v26, v23)));
          float32x4_t v30 = *(float32x4_t *)(v14 + 96);
          float32x4_t v31 = *(float32x4_t *)(v14 + 112);
          float32x4_t v33 = *(float32x4_t *)(v14 + 32);
          long long v32 = *(_OWORD *)(v14 + 48);
          int8x16_t v34 = (int8x16_t)vcgtq_f32(v31, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v32, 0));
          float32x4_t v35 = (float32x4_t)vbslq_s8(v34, (int8x16_t)vminq_f32(v27, v30), (int8x16_t)v27);
          float32x4_t v36 = (float32x4_t)vbslq_s8(v34, (int8x16_t)vminq_f32(v28, v30), (int8x16_t)v28);
          float32x4_t v37 = (float32x4_t)vbslq_s8(v34, (int8x16_t)vminq_f32(v29, v30), (int8x16_t)v29);
          int8x16_t v38 = (int8x16_t)vmaxq_f32(v35, v31);
          int8x16_t v39 = (int8x16_t)vmaxq_f32(v36, v31);
          int8x16_t v40 = (int8x16_t)vmaxq_f32(v37, v31);
          int8x16_t v41 = (int8x16_t)vcgtq_f32(v31, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v32, 1));
          int8x16_t v42 = (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v41, v38, (int8x16_t)v35), v16, 3);
          int8x16_t v43 = *(int8x16_t *)(v14 + 128);
          float32x4_t v44 = (float32x4_t *)(v5 + v9);
          float32x4_t *v44 = vaddq_f32(v11, vmulq_f32(v33, vsubq_f32((float32x4_t)vbslq_s8(v43, (int8x16_t)v16, v42), v11)));
          v44[1] = vaddq_f32(v12, vmulq_f32(v33, vsubq_f32((float32x4_t)vbslq_s8(v43, (int8x16_t)v17, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v41, v39, (int8x16_t)v36), v17, 3)), v12)));
          v44[2] = vaddq_f32(v13, vmulq_f32(v33, vsubq_f32((float32x4_t)vbslq_s8(v43, (int8x16_t)v18, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v41, v40, (int8x16_t)v37), v18, 3)), v13)));
          v10 -= 3;
          v9 += 48;
        }
        while (v4 + v10 > 2);
        LODWORD(v45) = -v10;
      }
      if ((int)v45 < v4)
      {
        uint64_t v45 = v45;
        do
        {
          float32x4_t v46 = *(float32x4_t *)(v6 + 16 * v45);
          uint64_t v47 = *((void *)this + 51);
          float32x4_t v48 = vaddq_f32(vmulq_f32(v46, *(float32x4_t *)v47), vmulq_laneq_f32(*(float32x4_t *)(v47 + 16), v46, 3));
          float32x4_t v49 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v48, 3), *(float32x4_t *)(v47 + 64));
          float32x4_t v50 = vmulq_f32(vrecpeq_f32(v49), *(float32x4_t *)(v47 + 80));
          float32x4_t v51 = vmulq_f32(v48, vmulq_f32(v50, vrecpsq_f32(v50, v49)));
          long long v52 = *(_OWORD *)(v47 + 48);
          float32x4_t v53 = *(float32x4_t *)(v47 + 112);
          float32x4_t v54 = (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v53, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v52, 0)), (int8x16_t)vminq_f32(v51, *(float32x4_t *)(v47 + 96)), (int8x16_t)v51);
          *(float32x4_t *)(v5 + 16 * v45++) = vaddq_f32(v46, vmulq_f32(*(float32x4_t *)(v47 + 32), vsubq_f32((float32x4_t)vbslq_s8(*(int8x16_t *)(v47 + 128), (int8x16_t)v48, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v53, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v52, 1)), (int8x16_t)vmaxq_f32(v54, v53), (int8x16_t)v54), v48, 3)), v46)));
        }
        while (v45 < v4);
      }
      ++v3;
      v5 += v7;
      v6 += v8;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcColorBalanceClipGammaOne::GetDOD(HgcColorBalanceClipGammaOne *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcColorBalanceClipGammaOne::GetROI(HgcColorBalanceClipGammaOne *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcColorBalanceClipGammaOne::HgcColorBalanceClipGammaOne(HgcColorBalanceClipGammaOne *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F1116648;
  operator new();
}

void sub_1B7A49BE8(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcColorBalanceClipGammaOne::~HgcColorBalanceClipGammaOne(HGNode *this)
{
  *(void *)this = &unk_1F1116648;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40B8406A4ELL);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcColorBalanceClipGammaOne::~HgcColorBalanceClipGammaOne(this);

  HGObject::operator delete(v1);
}

uint64_t HgcColorBalanceClipGammaOne::SetParameter(HgcColorBalanceClipGammaOne *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  switch((int)a2)
  {
    case 0:
      uint64_t v7 = (float *)*((void *)this + 51);
      if (*v7 == a3.n128_f32[0] && v7[1] == a4 && v7[2] == a5 && v7[3] == a6) {
        return 0;
      }
      *uint64_t v7 = a3.n128_f32[0];
      v7[1] = a4;
      v7[2] = a5;
      v7[3] = a6;
      goto LABEL_24;
    case 1:
      uint64_t v9 = (float *)*((void *)this + 51);
      if (v9[4] == a3.n128_f32[0] && v9[5] == a4 && v9[6] == a5 && v9[7] == a6) {
        return 0;
      }
      float v9[4] = a3.n128_f32[0];
      v9[5] = a4;
      v9[6] = a5;
      v9[7] = a6;
      goto LABEL_24;
    case 2:
      uint64_t v8 = 0;
      a3.n128_f32[1] = a4;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      *(__n128 *)(*((void *)this + 51) + 144) = a3;
      return v8;
    case 3:
      int v10 = (float *)*((void *)this + 51);
      if (v10[8] == a3.n128_f32[0] && v10[9] == a4 && v10[10] == a5 && v10[11] == a6) {
        return 0;
      }
      v10[8] = a3.n128_f32[0];
      v10[9] = a4;
      v10[10] = a5;
      v10[11] = a6;
      goto LABEL_24;
    case 4:
      float32x4_t v11 = (float *)*((void *)this + 51);
      if (v11[12] == a3.n128_f32[0] && v11[13] == a4 && v11[14] == a5 && v11[15] == a6) {
        return 0;
      }
      v11[12] = a3.n128_f32[0];
      v11[13] = a4;
      v11[14] = a5;
      v11[15] = a6;
LABEL_24:
      HGNode::ClearBits((HGNode *)this, a2, a7);
      return 1;
    default:
      return 0xFFFFFFFFLL;
  }
}

float HgcColorBalanceClipGammaOne::GetParameter(HgcColorBalanceClipGammaOne *this, int a2, float *a3)
{
  switch(a2)
  {
    case 0:
      int v3 = (float *)*((void *)this + 51);
      *a3 = *v3;
      a3[1] = v3[1];
      a3[2] = v3[2];
      int v4 = v3 + 3;
      goto LABEL_7;
    case 1:
      uint64_t v5 = (float *)*((void *)this + 51);
      *a3 = v5[4];
      a3[1] = v5[5];
      a3[2] = v5[6];
      int v4 = v5 + 7;
      goto LABEL_7;
    case 2:
      uint64_t v6 = (float *)*((void *)this + 51);
      *a3 = v6[36];
      a3[1] = v6[37];
      a3[2] = v6[38];
      int v4 = v6 + 39;
      goto LABEL_7;
    case 3:
      uint64_t v7 = (float *)*((void *)this + 51);
      *a3 = v7[8];
      a3[1] = v7[9];
      a3[2] = v7[10];
      int v4 = v7 + 11;
      goto LABEL_7;
    case 4:
      uint64_t v8 = (float *)*((void *)this + 51);
      *a3 = v8[12];
      a3[1] = v8[13];
      a3[2] = v8[14];
      int v4 = v8 + 15;
LABEL_7:
      float result = *v4;
      a3[3] = *v4;
      break;
    default:
      return result;
  }
  return result;
}

void HgcColorBalance::HgcColorBalance(HgcColorBalance *this)
{
  HGNode::HGNode((HGNode *)this);
  *(void *)uint64_t v1 = &unk_1F1116898;
  *(void *)(v1 + 416) = 0;
  *(void *)(v1 + 424) = 0x3F0000003F000000;
  *(_DWORD *)(v1 + 432) = 1056964608;
  *(void *)(v1 + 440) = 0x3F0000003F000000;
  *(_DWORD *)(v1 + 448) = 1056964608;
  *(void *)(v1 + 456) = 0x3F0000003F000000;
  *(_DWORD *)(v1 + 464) = 1056964608;
  *(_OWORD *)(v1 + 472) = xmmword_1B7E736D0;
  *(unsigned char *)(v1 + 488) = 0;
}

void HgcColorBalance::~HgcColorBalance(HGNode *this)
{
  *(void *)this = &unk_1F1116898;
  uint64_t v2 = *((void *)this + 52);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcColorBalance::~HgcColorBalance(this);

  HGObject::operator delete(v1);
}

void HgcColorBalance::GetOutput(HgcColorBalance *this, HGRenderer *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  double v2 = *((float *)this + 121);
  if (*((unsigned char *)this + 488))
  {
    unint64_t v3 = 0;
    int v4 = (char *)this + 456;
    do
    {
      double v5 = *(float *)&v4[v3 - 32] + -0.5;
      *(float *)&double v5 = v5 + v5 * v2;
      v22[v3 / 4 + 3] = LODWORD(v5);
      *(float *)&double v5 = 1.0 - *(float *)&v4[v3] + 0.5 + (1.0 - *(float *)&v4[v3] + -0.5) * v2;
      *(float *)((char *)&v19 + v3) = *(float *)&v5;
      *(float *)&double v5 = *(float *)&v4[v3 - 16] + 0.5 + (*(float *)&v4[v3 - 16] + -0.5) * v2;
      v22[v3 / 4] = LODWORD(v5);
      v3 += 4;
    }
    while (v3 != 12);
    float v6 = 1.0 - fabsf(v19);
    float v7 = 1.0 - fabsf(v20);
    float v8 = 1.0 - fabsf(v21);
  }
  else
  {
    unint64_t v9 = 0;
    double v10 = (v2 + -1.0) * 1.25;
    float32x4_t v11 = (char *)this + 456;
    do
    {
      double v12 = *(float *)&v11[v9 - 32] + -0.5;
      *(float *)&double v12 = v12 + v12 * v10;
      v22[v9 / 4 + 3] = LODWORD(v12);
      *(float *)&double v12 = (1.0 - *(float *)&v11[v9] + -0.5) * v2 * 1.5 + 1.0;
      *(float *)((char *)&v19 + v9) = *(float *)&v12;
      *(float *)&double v12 = *(float *)&v11[v9 - 16] + 0.5 + v10 * (*(float *)&v11[v9 - 16] + -0.5);
      v22[v9 / 4] = LODWORD(v12);
      v9 += 4;
    }
    while (v9 != 12);
    float v6 = vabds_f32(1.0, v19);
    float v7 = vabds_f32(1.0, v20);
    float v8 = vabds_f32(1.0, v21);
  }
  double v13 = v6;
  float v14 = *((float *)this + 118);
  if (v13 < 0.000001 && v7 < 0.000001 && v8 < 0.000001)
  {
    if (v14 >= 0.0 && *((float *)this + 119) >= 0.0)
    {
      float32x4_t v17 = (HgcColorBalanceNoClipGammaOne *)HGObject::operator new(0x200uLL);
      HgcColorBalanceNoClipGammaOne::HgcColorBalanceNoClipGammaOne(v17);
    }
    float32x4_t v15 = (HgcColorBalanceClipGammaOne *)HGObject::operator new(0x1A0uLL);
    HgcColorBalanceClipGammaOne::HgcColorBalanceClipGammaOne(v15);
  }
  if (v14 < 0.0 || *((float *)this + 119) < 0.0)
  {
    float32x4_t v16 = (HgcColorBalanceClip *)HGObject::operator new(0x1A0uLL);
    HgcColorBalanceClip::HgcColorBalanceClip(v16);
  }
  float32x4_t v18 = (HgcColorBalanceNoClip *)HGObject::operator new(0x1A0uLL);
  HgcColorBalanceNoClip::HgcColorBalanceNoClip(v18);
}

void sub_1B7A4A69C(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HgcColorBalance::SetParameter(HgcColorBalance *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  switch((int)a2)
  {
    case 0:
      if (*((float *)this + 106) == a3 && *((float *)this + 107) == a4 && *((float *)this + 108) == a5) {
        return 0;
      }
      *((float *)this + 106) = a3;
      *((float *)this + 107) = a4;
      *((float *)this + 108) = a5;
      *((_DWORD *)this + 109) = 1065353216;
      goto LABEL_20;
    case 1:
      if (*((float *)this + 110) == a3 && *((float *)this + 111) == a4 && *((float *)this + 112) == a5) {
        return 0;
      }
      *((float *)this + 110) = a3;
      *((float *)this + 111) = a4;
      *((float *)this + 112) = a5;
      *((_DWORD *)this + 113) = 1065353216;
      goto LABEL_20;
    case 2:
      if (*((float *)this + 114) == a3 && *((float *)this + 115) == a4 && *((float *)this + 116) == a5) {
        return 0;
      }
      *((float *)this + 114) = fabsf(a3);
      *((float *)this + 115) = fabsf(a4);
      *((float *)this + 116) = fabsf(a5);
      *((_DWORD *)this + 117) = 1065353216;
      goto LABEL_20;
    case 3:
      if (*((float *)this + 120) == a3) {
        return 0;
      }
      *((float *)this + 120) = a3;
      goto LABEL_20;
    case 4:
      if (*((float *)this + 118) == a3 && *((float *)this + 119) == a4) {
        return 0;
      }
      *((float *)this + 118) = a3;
      *((float *)this + 119) = a4;
LABEL_20:
      HGNode::ClearBits((HGNode *)this, a2, a7);
      return 1;
    default:
      return 0xFFFFFFFFLL;
  }
}

float HgcColorBalance::GetParameter(HgcColorBalance *this, int a2, float *a3)
{
  switch(a2)
  {
    case 0:
      *a3 = *((float *)this + 106);
      a3[1] = *((float *)this + 107);
      a3[2] = *((float *)this + 108);
      unint64_t v3 = (float *)((char *)this + 436);
      goto LABEL_6;
    case 1:
      *a3 = *((float *)this + 110);
      a3[1] = *((float *)this + 111);
      a3[2] = *((float *)this + 112);
      unint64_t v3 = (float *)((char *)this + 452);
      goto LABEL_6;
    case 2:
      *a3 = *((float *)this + 114);
      a3[1] = *((float *)this + 115);
      a3[2] = *((float *)this + 116);
      unint64_t v3 = (float *)((char *)this + 468);
      goto LABEL_6;
    case 3:
      unint64_t v3 = (float *)((char *)this + 480);
      *a3 = *((float *)this + 120);
      a3[1] = *((float *)this + 120);
      a3[2] = *((float *)this + 120);
LABEL_6:
      uint64_t v4 = 3;
      goto LABEL_8;
    case 4:
      *a3 = *((float *)this + 118);
      unint64_t v3 = (float *)((char *)this + 476);
      uint64_t v4 = 1;
LABEL_8:
      float result = *v3;
      a3[v4] = *v3;
      break;
    default:
      return result;
  }
  return result;
}

double HgcColorBalanceClip::State::State(HgcColorBalanceClip::State *this)
{
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = xmmword_1B7E75900;
  *((_OWORD *)this + 6) = xmmword_1B7E75890;
  *((_OWORD *)this + 7) = xmmword_1B7E75910;
  *((_OWORD *)this + 8) = xmmword_1B7E75920;
  *((_OWORD *)this + 9) = xmmword_1B7E75930;
  *((_OWORD *)this + 10) = xmmword_1B7E75940;
  *((_OWORD *)this + 11) = xmmword_1B7E75840;
  *((_OWORD *)this + 12) = xmmword_1B7E75950;
  *((_OWORD *)this + 13) = xmmword_1B7E75960;
  *((_OWORD *)this + 14) = xmmword_1B7E75970;
  *((_OWORD *)this + 15) = xmmword_1B7E75980;
  *((_OWORD *)this + 16) = xmmword_1B7E75990;
  *((_OWORD *)this + 17) = xmmword_1B7E759A0;
  *((_OWORD *)this + 18) = xmmword_1B7E759B0;
  *((_OWORD *)this + 19) = xmmword_1B7E759C0;
  *((_OWORD *)this + 20) = xmmword_1B7E759D0;
  *((_OWORD *)this + 21) = xmmword_1B7E775E0;
  *((_OWORD *)this + 22) = xmmword_1B7E752F0;
  *((int32x4_t *)this + 23) = vdupq_n_s32(0x358637BDu);
  double result = 0.00793481058;
  *((_OWORD *)this + 24) = xmmword_1B7E75E30;
  *((void *)this + 50) = 0;
  *((void *)this + 51) = 0;
  return result;
}

const char *HgcSampleTiledNoise::GetProgram(HgcSampleTiledNoise *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000b73\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(255.0000000, 0.5000000000, 1.000000000, 0.000000000);\n"
             "    half4 r0;\n"
             "    float4 s0, s1, s2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = 1.00000h / half(hg_Params[2].x);\n"
             "    s0.zw = frag._texCoord0.xy + hg_Params[5].zw;\n"
             "    s0.xy = s0.zw/hg_Params[1].xy;\n"
             "    s1.zw = floor(s0.xy);\n"
             "    s0.x = s1.z*float(r0.x);\n"
             "    s0.x = floor(s0.x);\n"
             "    s0.y = float(c0.y);\n"
             "    s0.x = -s0.x*hg_Params[2].x + s1.z;\n"
             "    s2.xy = s0.xy + hg_Params[6].xy;\n"
             "    s2.xy = s2.xy*hg_Params[6].zw;\n"
             "    s0.x = (float) hg_Texture0.sample(hg_Sampler0, s2.xy).x;\n"
             "    s0.x = s0.x*float(c0.x);\n"
             "    s0.x = floor(s0.x);\n"
             "    s0.x = s1.w + s0.x;\n"
             "    s0.y = float(r0.x)*s0.x;\n"
             "    s1.x = floor(s0.y);\n"
             "    s0.y = float(c0.y);\n"
             "    s0.x = -s1.x*hg_Params[2].x + s0.x;\n"
             "    s2.xy = s0.xy + hg_Params[6].xy;\n"
             "    s2.xy = s2.xy*hg_Params[6].zw;\n"
             "    s0.x = (float) hg_Texture0.sample(hg_Sampler0, s2.xy).x;\n"
             "    s0.x = s0.x*float(c0.x);\n"
             "    s1.x = floor(s0.x);\n"
             "    s1.y = float(r0.x)*s1.x;\n"
             "    s0.x = s1.w + s1.w;\n"
             "    s0.y = s0.x*float(r0.x);\n"
             "    s1.y = floor(s1.y);\n"
             "    s0.y = floor(s0.y);\n"
             "    s1.x = -s1.y*hg_Params[2].x + s1.x;\n"
             "    s0.x = -s0.y*hg_Params[2].x + s0.x;\n"
             "    s0.y = float(c0.y);\n"
             "    s2.xy = s0.xy + hg_Params[6].xy;\n"
             "    s2.xy = s2.xy*hg_Params[6].zw;\n"
             "    s0.x = (float) hg_Texture0.sample(hg_Sampler0, s2.xy).x;\n"
             "    s1.y = float(c0.y);\n"
             "    s2.xy = s1.xy + hg_Params[6].xy;\n"
             "    s2.xy = s2.xy*hg_Params[6].zw;\n"
             "    s1.x = (float) hg_Texture0.sample(hg_Sampler0, s2.xy).x;\n"
             "    s0.y = s1.x*float(c0.x);\n"
             "    s0.x = s0.x*float(c0.x);\n"
             "    s0.x = floor(s0.x);\n"
             "    s1.x = floor(s0.y);\n"
             "    s0.x = s1.z + s0.x;\n"
             "    s0.y = s0.x*float(r0.x);\n"
             "    s2.x = floor(s0.y);\n"
             "    s1.y = s1.x/hg_Params[0].y;\n"
             "    s0.y = float(c0.y);\n"
             "    s0.x = -s2.x*hg_Params[2].x + s0.x;\n"
             "    s2.xy = s0.xy + hg_Params[6].xy;\n"
             "    s2.xy = s2.xy*hg_Params[6].zw;\n"
             "    s0.x = (float) hg_Texture0.sample(hg_Sampler0, s2.xy).x;\n"
             "    s0.y = floor(s1.y);\n"
             "    s0.x = s0.x*float(c0.x);\n"
             "    s0.y = -s0.y*hg_Params[0].y + s1.x;\n"
             "    s0.x = floor(s0.x);\n"
             "    s1.y = s0.x/hg_Params[0].x;\n"
             "    s1.x = floor(s1.y);\n"
             "    s0.zw = -s1.zw*hg_Params[1].xy + s0.zw;\n"
             "    s0.x = -s1.x*hg_Params[0].x + s0.x;\n"
             "    s0.xy = s0.xy*hg_Params[1].xy + s0.zw;\n"
             "    s0.xy = s0.xy + hg_Params[7].xy;\n"
             "    s0.xy = s0.xy*hg_Params[7].zw;\n"
             "    r0 = (half4) hg_Texture1.sample(hg_Sampler1, s0.xy);\n"
             "    r0 = select(r0, r0.xxxw, half4(hg_Params[3]) < 0.00000h);\n"
             "    output.color0 = mix(float4(c0.yyyz), float4(r0), hg_Params[4]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=2fe2b506:2d6bb22d:313529f7:a644a727\n"
             "//SIG=00400000:00000000:00000000:00000003:0001:0008:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000ab7\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(255.0000000, 0.5000000000, 1.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.x = 1.00000f / hg_Params[2].x;\n"
             "    r1.zw = frag._texCoord0.xy + hg_Params[5].zw;\n"
             "    r1.xy = r1.zw/hg_Params[1].xy;\n"
             "    r2.zw = floor(r1.xy);\n"
             "    r1.x = r2.z*r0.x;\n"
             "    r1.x = floor(r1.x);\n"
             "    r1.y = c0.y;\n"
             "    r1.x = -r1.x*hg_Params[2].x + r2.z;\n"
             "    r3.xy = r1.xy + hg_Params[6].xy;\n"
             "    r3.xy = r3.xy*hg_Params[6].zw;\n"
             "    r1.x = hg_Texture0.sample(hg_Sampler0, r3.xy).x;\n"
             "    r1.x = r1.x*c0.x;\n"
             "    r1.x = floor(r1.x);\n"
             "    r1.x = r2.w + r1.x;\n"
             "    r1.y = r0.x*r1.x;\n"
             "    r2.x = floor(r1.y);\n"
             "    r1.y = c0.y;\n"
             "    r1.x = -r2.x*hg_Params[2].x + r1.x;\n"
             "    r3.xy = r1.xy + hg_Params[6].xy;\n"
             "    r3.xy = r3.xy*hg_Params[6].zw;\n"
             "    r1.x = hg_Texture0.sample(hg_Sampler0, r3.xy).x;\n"
             "    r1.x = r1.x*c0.x;\n"
             "    r2.x = floor(r1.x);\n"
             "    r2.y = r0.x*r2.x;\n"
             "    r1.x = r2.w + r2.w;\n"
             "    r1.y = r1.x*r0.x;\n"
             "    r2.y = floor(r2.y);\n"
             "    r1.y = floor(r1.y);\n"
             "    r2.x = -r2.y*hg_Params[2].x + r2.x;\n"
             "    r1.x = -r1.y*hg_Params[2].x + r1.x;\n"
             "    r1.y = c0.y;\n"
             "    r3.xy = r1.xy + hg_Params[6].xy;\n"
             "    r3.xy = r3.xy*hg_Params[6].zw;\n"
             "    r1.x = hg_Texture0.sample(hg_Sampler0, r3.xy).x;\n"
             "    r2.y = c0.y;\n"
             "    r3.xy = r2.xy + hg_Params[6].xy;\n"
             "    r3.xy = r3.xy*hg_Params[6].zw;\n"
             "    r2.x = hg_Texture0.sample(hg_Sampler0, r3.xy).x;\n"
             "    r1.y = r2.x*c0.x;\n"
             "    r1.x = r1.x*c0.x;\n"
             "    r1.x = floor(r1.x);\n"
             "    r2.x = floor(r1.y);\n"
             "    r1.x = r2.z + r1.x;\n"
             "    r1.y = r1.x*r0.x;\n"
             "    r3.x = floor(r1.y);\n"
             "    r2.y = r2.x/hg_Params[0].y;\n"
             "    r1.y = c0.y;\n"
             "    r1.x = -r3.x*hg_Params[2].x + r1.x;\n"
             "    r0.xy = r1.xy + hg_Params[6].xy;\n"
             "    r0.xy = r0.xy*hg_Params[6].zw;\n"
             "    r1.x = hg_Texture0.sample(hg_Sampler0, r0.xy).x;\n"
             "    r1.y = floor(r2.y);\n"
             "    r1.x = r1.x*c0.x;\n"
             "    r1.y = -r1.y*hg_Params[0].y + r2.x;\n"
             "    r1.x = floor(r1.x);\n"
             "    r2.y = r1.x/hg_Params[0].x;\n"
             "    r2.x = floor(r2.y);\n"
             "    r1.zw = -r2.zw*hg_Params[1].xy + r1.zw;\n"
             "    r1.x = -r2.x*hg_Params[0].x + r1.x;\n"
             "    r1.xy = r1.xy*hg_Params[1].xy + r1.zw;\n"
             "    r1.xy = r1.xy + hg_Params[7].xy;\n"
             "    r1.xy = r1.xy*hg_Params[7].zw;\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, r1.xy);\n"
             "    r1 = select(r1, r1.xxxw, hg_Params[3] < 0.00000f);\n"
             "    output.color0 = mix(c0.yyyz, r1, hg_Params[4]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=82167b58:cbd9709c:b22bbbab:ef8606ed\n"
             "//SIG=00000000:00000000:00000000:00000000:0001:0008:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000c0d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "uniform highp vec4 hg_ProgramLocal6;\n"
           "uniform highp vec4 hg_ProgramLocal7;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(255.0000000, 0.5000000000, 1.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0.x = 1.00000 / hg_ProgramLocal2.x;\n"
           "    r1.zw = hg_TexCoord0.xy + hg_ProgramLocal5.zw;\n"
           "    r1.xy = r1.zw/hg_ProgramLocal1.xy;\n"
           "    r2.zw = floor(r1.xy);\n"
           "    r1.x = r2.z*r0.x;\n"
           "    r1.x = floor(r1.x);\n"
           "    r1.y = c0.y;\n"
           "    r1.x = -r1.x*hg_ProgramLocal2.x + r2.z;\n"
           "    r3.xy = r1.xy + hg_ProgramLocal6.xy;\n"
           "    r3.xy = r3.xy*hg_ProgramLocal6.zw;\n"
           "    r1.x = texture2D(hg_Texture0, r3.xy).x;\n"
           "    r1.x = r1.x*c0.x;\n"
           "    r1.x = floor(r1.x);\n"
           "    r1.x = r2.w + r1.x;\n"
           "    r1.y = r0.x*r1.x;\n"
           "    r2.x = floor(r1.y);\n"
           "    r1.y = c0.y;\n"
           "    r1.x = -r2.x*hg_ProgramLocal2.x + r1.x;\n"
           "    r3.xy = r1.xy + hg_ProgramLocal6.xy;\n"
           "    r3.xy = r3.xy*hg_ProgramLocal6.zw;\n"
           "    r1.x = texture2D(hg_Texture0, r3.xy).x;\n"
           "    r1.x = r1.x*c0.x;\n"
           "    r2.x = floor(r1.x);\n"
           "    r2.y = r0.x*r2.x;\n"
           "    r1.x = r2.w + r2.w;\n"
           "    r1.y = r1.x*r0.x;\n"
           "    r2.y = floor(r2.y);\n"
           "    r1.y = floor(r1.y);\n"
           "    r2.x = -r2.y*hg_ProgramLocal2.x + r2.x;\n"
           "    r1.x = -r1.y*hg_ProgramLocal2.x + r1.x;\n"
           "    r1.y = c0.y;\n"
           "    r3.xy = r1.xy + hg_ProgramLocal6.xy;\n"
           "    r3.xy = r3.xy*hg_ProgramLocal6.zw;\n"
           "    r1.x = texture2D(hg_Texture0, r3.xy).x;\n"
           "    r2.y = c0.y;\n"
           "    r3.xy = r2.xy + hg_ProgramLocal6.xy;\n"
           "    r3.xy = r3.xy*hg_ProgramLocal6.zw;\n"
           "    r2.x = texture2D(hg_Texture0, r3.xy).x;\n"
           "    r1.y = r2.x*c0.x;\n"
           "    r1.x = r1.x*c0.x;\n"
           "    r1.x = floor(r1.x);\n"
           "    r2.x = floor(r1.y);\n"
           "    r1.x = r2.z + r1.x;\n"
           "    r1.y = r1.x*r0.x;\n"
           "    r3.x = floor(r1.y);\n"
           "    r2.y = r2.x/hg_ProgramLocal0.y;\n"
           "    r1.y = c0.y;\n"
           "    r1.x = -r3.x*hg_ProgramLocal2.x + r1.x;\n"
           "    r0.xy = r1.xy + hg_ProgramLocal6.xy;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal6.zw;\n"
           "    r1.x = texture2D(hg_Texture0, r0.xy).x;\n"
           "    r1.y = floor(r2.y);\n"
           "    r1.x = r1.x*c0.x;\n"
           "    r1.y = -r1.y*hg_ProgramLocal0.y + r2.x;\n"
           "    r1.x = floor(r1.x);\n"
           "    r2.y = r1.x/hg_ProgramLocal0.x;\n"
           "    r2.x = floor(r2.y);\n"
           "    r1.zw = -r2.zw*hg_ProgramLocal1.xy + r1.zw;\n"
           "    r1.x = -r2.x*hg_ProgramLocal0.x + r1.x;\n"
           "    r1.xy = r1.xy*hg_ProgramLocal1.xy + r1.zw;\n"
           "    r1.xy = r1.xy + hg_ProgramLocal7.xy;\n"
           "    r1.xy = r1.xy*hg_ProgramLocal7.zw;\n"
           "    r1 = texture2D(hg_Texture1, r1.xy);\n"
           "    r1 = vec4(hg_ProgramLocal3.x < 0.00000 ? r1.x : r1.x, hg_ProgramLocal3.y < 0.00000 ? r1.x : r1.y, hg_Prog"
           "ramLocal3.z < 0.00000 ? r1.x : r1.z, hg_ProgramLocal3.w < 0.00000 ? r1.w : r1.w);\n"
           "    gl_FragColor = mix(c0.yyyz, r1, hg_ProgramLocal4);\n"
           "}\n"
           "//MD5=0d7ad1dd:d494ce4a:9f611288:ffc05865\n"
           "//SIG=00000000:00000000:00000000:00000000:0001:0008:0004:0000:0000:0000:0000:0000:0001:02:0:1:0\n";
  }
}

void HgcSampleTiledNoise::InitProgramDescriptor(HgcSampleTiledNoise *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcSampleTiledNoise_hgc_visible", "//Metal1.0     \n//LEN=00000009db\n[[ visible ]] FragmentOut HgcSampleTiledNoise_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1,\n    float4 texCoord0)\n{\n    const float4 c0 = float4(255.0000000, 0.5000000000, 1.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.x = 1.00000f / hg_Params[2].x;\n"
    "    r1.zw = texCoord0.xy + hg_Params[5].zw;\n"
    "    r1.xy = r1.zw/hg_Params[1].xy;\n"
    "    r2.zw = floor(r1.xy);\n"
    "    r1.x = r2.z*r0.x;\n"
    "    r1.x = floor(r1.x);\n"
    "    r1.y = c0.y;\n"
    "    r1.x = -r1.x*hg_Params[2].x + r2.z;\n"
    "    r3.xy = r1.xy + hg_Params[6].xy;\n"
    "    r3.xy = r3.xy*hg_Params[6].zw;\n"
    "    r1.x = hg_Texture0.sample(hg_Sampler0, r3.xy).x;\n"
    "    r1.x = r1.x*c0.x;\n"
    "    r1.x = floor(r1.x);\n"
    "    r1.x = r2.w + r1.x;\n"
    "    r1.y = r0.x*r1.x;\n"
    "    r2.x = floor(r1.y);\n"
    "    r1.y = c0.y;\n"
    "    r1.x = -r2.x*hg_Params[2].x + r1.x;\n"
    "    r3.xy = r1.xy + hg_Params[6].xy;\n"
    "    r3.xy = r3.xy*hg_Params[6].zw;\n"
    "    r1.x = hg_Texture0.sample(hg_Sampler0, r3.xy).x;\n"
    "    r1.x = r1.x*c0.x;\n"
    "    r2.x = floor(r1.x);\n"
    "    r2.y = r0.x*r2.x;\n"
    "    r1.x = r2.w + r2.w;\n"
    "    r1.y = r1.x*r0.x;\n"
    "    r2.y = floor(r2.y);\n"
    "    r1.y = floor(r1.y);\n"
    "    r2.x = -r2.y*hg_Params[2].x + r2.x;\n"
    "    r1.x = -r1.y*hg_Params[2].x + r1.x;\n"
    "    r1.y = c0.y;\n"
    "    r3.xy = r1.xy + hg_Params[6].xy;\n"
    "    r3.xy = r3.xy*hg_Params[6].zw;\n"
    "    r1.x = hg_Texture0.sample(hg_Sampler0, r3.xy).x;\n"
    "    r2.y = c0.y;\n"
    "    r3.xy = r2.xy + hg_Params[6].xy;\n"
    "    r3.xy = r3.xy*hg_Params[6].zw;\n"
    "    r2.x = hg_Texture0.sample(hg_Sampler0, r3.xy).x;\n"
    "    r1.y = r2.x*c0.x;\n"
    "    r1.x = r1.x*c0.x;\n"
    "    r1.x = floor(r1.x);\n"
    "    r2.x = floor(r1.y);\n"
    "    r1.x = r2.z + r1.x;\n"
    "    r1.y = r1.x*r0.x;\n"
    "    r3.x = floor(r1.y);\n"
    "    r2.y = r2.x/hg_Params[0].y;\n"
    "    r1.y = c0.y;\n"
    "    r1.x = -r3.x*hg_Params[2].x + r1.x;\n"
    "    r0.xy = r1.xy + hg_Params[6].xy;\n"
    "    r0.xy = r0.xy*hg_Params[6].zw;\n"
    "    r1.x = hg_Texture0.sample(hg_Sampler0, r0.xy).x;\n"
    "    r1.y = floor(r2.y);\n"
    "    r1.x = r1.x*c0.x;\n"
    "    r1.y = -r1.y*hg_Params[0].y + r2.x;\n"
    "    r1.x = floor(r1.x);\n"
    "    r2.y = r1.x/hg_Params[0].x;\n"
    "    r2.x = floor(r2.y);\n"
    "    r1.zw = -r2.zw*hg_Params[1].xy + r1.zw;\n"
    "    r1.x = -r2.x*hg_Params[0].x + r1.x;\n"
    "    r1.xy = r1.xy*hg_Params[1].xy + r1.zw;\n"
    "    r1.xy = r1.xy + hg_Params[7].xy;\n"
    "    r1.xy = r1.xy*hg_Params[7].zw;\n"
    "    r1 = hg_Texture1.sample(hg_Sampler1, r1.xy);\n"
    "    r1 = select(r1, r1.xxxw, hg_Params[3] < 0.00000f);\n"
    "    output.color0 = mix(c0.yyyz, r1, hg_Params[4]);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcSampleTiledNoise");
}

void sub_1B7A4ABFC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75180;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 9;
  std::string::basic_string[abi:ne180100]<0>(v34, "texture2d<float>");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 6;
  std::string::basic_string[abi:ne180100]<0>(v34, "sampler");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 9;
  std::string::basic_string[abi:ne180100]<0>(v34, "texture2d<float>");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 6;
  std::string::basic_string[abi:ne180100]<0>(v34, "sampler");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 8;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  float32x4_t v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7A4ADFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7A4AE5C()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7A4AE54);
}

void *HgcSampleTiledNoise::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcSampleTiledNoise [hgc1]");
}

uint64_t HgcSampleTiledNoise::BindTexture(HgcSampleTiledNoise *this, HGHandler *a2, int a3)
{
  if (a3 == 1)
  {
    (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    int v10 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
    v7.n128_f32[0] = (float)*((int *)a2 + 60);
    v8.n128_f32[0] = (float)*((int *)a2 + 61);
    if (v10)
    {
      unint64_t v9 = *(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136);
      v5.n128_u32[0] = 1.0;
      v6.n128_u32[0] = 1.0;
    }
    else
    {
      v5.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
      unint64_t v9 = *(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136);
      v6.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
    }
    double v12 = a2;
    uint64_t v13 = 7;
  }
  else
  {
    if (a3) {
      return 0xFFFFFFFFLL;
    }
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    int v4 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
    v7.n128_f32[0] = (float)*((int *)a2 + 60);
    v8.n128_f32[0] = (float)*((int *)a2 + 61);
    if (v4)
    {
      unint64_t v9 = *(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136);
      v5.n128_u32[0] = 1.0;
      v6.n128_u32[0] = 1.0;
    }
    else
    {
      v5.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
      unint64_t v9 = *(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136);
      v6.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
    }
    double v12 = a2;
    uint64_t v13 = 6;
  }
  v9(v12, v13, v7, v8, v5, v6);
  return 0;
}

uint64_t HgcSampleTiledNoise::Bind(HgcSampleTiledNoise *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcSampleTiledNoise::RenderTile(HgcSampleTiledNoise *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = 0;
    *(float32x2_t *)v5.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v5.i64[1] = 0x3F80000000000000;
    int v6 = a2[1].i32[0] - v2.i32[0];
    float32x4_t v7 = (float32x4_t)xmmword_1B7E736C0;
    int32x2_t v8 = a2[2];
    uint64_t v9 = 16 * a2[3].i32[0];
    v10.i64[0] = 0x3F0000003F000000;
    v10.i64[1] = 0x3F0000003F000000;
    float32x4_t v11 = v5;
    do
    {
      if (v6 < 2)
      {
        uint64_t v12 = 0;
        float32x4_t v14 = v11;
      }
      else
      {
        uint64_t v12 = 0;
        int v13 = v6;
        float32x4_t v267 = v11;
        float32x4_t v14 = v11;
        do
        {
          float32x4_t v15 = vaddq_f32(v14, (float32x4_t)xmmword_1B7E736B0);
          uint64_t v16 = *((void *)this + 51);
          float32x4_t v17 = *(float32x4_t *)(v16 + 96);
          float32x4_t v18 = *(float32x4_t *)(v16 + 112);
          float32x4_t v19 = (float32x4_t)vextq_s8((int8x16_t)v14, (int8x16_t)v14, 8uLL);
          float32x4_t v20 = *(float32x4_t *)(v16 + 32);
          float32x4_t v21 = *(float32x4_t *)(v16 + 64);
          float32x4_t v22 = *(float32x4_t *)(v16 + 80);
          float32x4_t v23 = vaddq_f32(v19, v22);
          float32x4_t v24 = vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v15, (int8x16_t)v15, 8uLL), v22);
          float32x4_t v25 = *(float32x4_t *)(v16 + 16);
          float32x4_t v27 = *(float32x4_t *)(v16 + 128);
          float32x4_t v26 = *(float32x4_t *)(v16 + 144);
          float32x4_t v28 = vminq_f32(vmaxq_f32(vrecpeq_f32(v25), v18), v27);
          float32x4_t v29 = vminq_f32(vmaxq_f32(vmulq_f32(v28, vrecpsq_f32(v25, v28)), v18), v27);
          float32x4_t v30 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v20), v17), v18), v27);
          float32x4_t v31 = vmulq_f32(v29, vrecpsq_f32(v25, v29));
          float32x4_t v32 = (float32x4_t)vextq_s8((int8x16_t)v23, (int8x16_t)vmulq_f32((float32x4_t)vdupq_laneq_s64((int64x2_t)v23, 1), v31), 8uLL);
          float32x4_t v33 = (float32x4_t)vextq_s8((int8x16_t)v24, (int8x16_t)vmulq_f32((float32x4_t)vdupq_laneq_s64((int64x2_t)v24, 1), v31), 8uLL);
          float32x4_t v34 = vcvtq_f32_s32(vcvtq_s32_f32(v32));
          float32x4_t v35 = vcvtq_f32_s32(vcvtq_s32_f32(v33));
          int8x16_t v36 = (int8x16_t)vcgtq_f32(v34, v32);
          float32x4_t v37 = vmulq_f32(v30, vrecpsq_f32(v20, v30));
          float32x4_t v38 = vsubq_f32(v34, (float32x4_t)vandq_s8((int8x16_t)v18, v36));
          float32x4_t v39 = vsubq_f32(v35, (float32x4_t)vandq_s8((int8x16_t)v18, (int8x16_t)vcgtq_f32(v35, v33)));
          v30.i64[0] = vmulq_laneq_f32(v37, v38, 2).u64[0];
          v33.i64[0] = vmulq_laneq_f32(v37, v39, 2).u64[0];
          v30.i64[1] = v23.i64[1];
          v33.i64[1] = v24.i64[1];
          float32x4_t v40 = vcvtq_f32_s32(vcvtq_s32_f32(v30));
          float32x4_t v41 = vcvtq_f32_s32(vcvtq_s32_f32(v33));
          v23.i32[0] = vsubq_f32(v40, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v40, v30))).u32[0];
          v24.i32[0] = vsubq_f32(v41, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v41, v33))).u32[0];
          v23.i32[1] = 0.5;
          v24.i32[1] = 0.5;
          int8x16_t v42 = *(int8x16_t *)(v16 + 160);
          float32x4_t v43 = *(float32x4_t *)(v16 + 176);
          float32x4_t v44 = (float32x4_t)vbslq_s8(v42, (int8x16_t)vsubq_f32((float32x4_t)vextq_s8((int8x16_t)v38, (int8x16_t)v38, 8uLL), vmulq_f32(v20, v23)), (int8x16_t)v23);
          float32x4_t v45 = (float32x4_t)vbslq_s8(v42, (int8x16_t)vsubq_f32((float32x4_t)vextq_s8((int8x16_t)v39, (int8x16_t)v39, 8uLL), vmulq_f32(v20, v24)), (int8x16_t)v24);
          __int32 v46 = a2[11].i32[0];
          float32x4_t v47 = vaddq_f32(vsubq_f32(v44, v5), v10);
          int32x4_t v48 = vcvtq_s32_f32(v47);
          v47.i64[0] = vaddq_s32(v48, vcgtq_f32(vcvtq_f32_s32(v48), v47)).u64[0];
          int32x2_t v49 = a2[10];
          __int32 v50 = v47.i32[1];
          __int32 v51 = v47.i32[0];
          float32x4_t v52 = vaddq_f32(vsubq_f32(v45, v5), v10);
          float32x4_t v53 = (float32x4_t)vcvtq_s32_f32(v52);
          v52.i64[0] = vaddq_s32((int32x4_t)v53, vcgtq_f32(vcvtq_f32_s32((int32x4_t)v53), v52)).u64[0];
          v53.i64[0] = vmulq_f32(*(float32x4_t *)(*(void *)&v49 + 16 * (v51 + v50 * v46)), v43).u64[0];
          v52.i64[0] = vmulq_f32(*(float32x4_t *)(*(void *)&v49 + 16 * (v52.i32[0] + v52.i32[1] * v46)), v43).u64[0];
          v53.i64[1] = v44.i64[1];
          v52.i64[1] = v45.i64[1];
          float32x4_t v54 = vcvtq_f32_s32(vcvtq_s32_f32(v53));
          float32x4_t v55 = vcvtq_f32_s32(vcvtq_s32_f32(v52));
          v53.i64[0] = vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v38, (int8x16_t)v38, 0xCuLL), vsubq_f32(v54, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v54, v53), (int8x16_t)v26, (int8x16_t)0))).u64[0];
          v52.i64[0] = vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v39, (int8x16_t)v39, 0xCuLL), vsubq_f32(v55, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v55, v52), (int8x16_t)v26, (int8x16_t)0))).u64[0];
          v54.i64[0] = v53.i64[0];
          v55.i64[0] = v52.i64[0];
          v54.i64[1] = v44.i64[1];
          v53.i64[1] = vdupq_laneq_s64((int64x2_t)v44, 1).u64[0];
          v55.i64[1] = v45.i64[1];
          v52.i64[1] = vdupq_laneq_s64((int64x2_t)v45, 1).u64[0];
          float32x4_t v56 = (float32x4_t)vrev64q_s32((int32x4_t)v52);
          int8x16_t v57 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev64q_s32((int32x4_t)v53), v37.f32[0]);
          int8x16_t v58 = (int8x16_t)vmulq_n_f32(v56, v37.f32[0]);
          int8x16_t v60 = *(int8x16_t *)(v16 + 192);
          int8x16_t v59 = *(int8x16_t *)(v16 + 208);
          float32x4_t v61 = (float32x4_t)vbslq_s8(v60, v57, (int8x16_t)v54);
          float32x4_t v62 = (float32x4_t)vbslq_s8(v60, v58, (int8x16_t)v55);
          float32x4_t v63 = (float32x4_t)vrev64q_s32((int32x4_t)v61);
          float32x4_t v64 = (float32x4_t)vrev64q_s32((int32x4_t)v62);
          float32x4_t v65 = vcvtq_f32_s32(vcvtq_s32_f32(v63));
          float32x4_t v66 = vcvtq_f32_s32(vcvtq_s32_f32(v64));
          v63.i64[0] = vsubq_f32(v65, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v65, v63), (int8x16_t)v26, (int8x16_t)0)).u64[0];
          v64.i64[0] = vsubq_f32(v66, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v66, v64), (int8x16_t)v26, (int8x16_t)0)).u64[0];
          v63.i64[1] = v38.i64[1];
          v64.i64[1] = v39.i64[1];
          v61.i32[1] = 0.5;
          v62.i32[1] = 0.5;
          float32x4_t v67 = (float32x4_t)vbslq_s8(v42, (int8x16_t)vsubq_f32(v61, vmulq_f32(v20, v63)), (int8x16_t)v61);
          float32x4_t v68 = (float32x4_t)vbslq_s8(v42, (int8x16_t)vsubq_f32(v62, vmulq_f32(v20, v64)), (int8x16_t)v62);
          float32x4_t v69 = vaddq_f32(vsubq_f32(v67, v5), v10);
          int32x4_t v70 = vcvtq_s32_f32(v69);
          v69.i64[0] = vaddq_s32(v70, vcgtq_f32(vcvtq_f32_s32(v70), v69)).u64[0];
          __int32 v71 = v69.i32[1];
          __int32 v72 = v69.i32[0];
          float32x4_t v73 = vaddq_f32(vsubq_f32(v68, v5), v10);
          float32x4_t v74 = (float32x4_t)vcvtq_s32_f32(v73);
          v73.i64[0] = vaddq_s32((int32x4_t)v74, vcgtq_f32(vcvtq_f32_s32((int32x4_t)v74), v73)).u64[0];
          v74.i64[0] = vmulq_f32(v43, *(float32x4_t *)(*(void *)&v49 + 16 * (v72 + v71 * v46))).u64[0];
          v73.i64[0] = vmulq_f32(v43, *(float32x4_t *)(*(void *)&v49 + 16 * (v73.i32[0] + v73.i32[1] * v46))).u64[0];
          v74.i64[1] = v67.i64[1];
          v73.i64[1] = v68.i64[1];
          float32x4_t v75 = vcvtq_f32_s32(vcvtq_s32_f32(v74));
          float32x4_t v76 = vcvtq_f32_s32(vcvtq_s32_f32(v73));
          v74.i64[0] = vsubq_f32(v75, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v75, v74), (int8x16_t)v26, (int8x16_t)0)).u64[0];
          v73.i64[0] = vsubq_f32(v76, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v76, v73), (int8x16_t)v26, (int8x16_t)0)).u64[0];
          v75.i64[0] = v74.i64[0];
          v75.i64[1] = v38.i64[1];
          v76.i64[0] = v73.i64[0];
          v76.i64[1] = v39.i64[1];
          v74.i64[1] = vdupq_laneq_s64((int64x2_t)v38, 1).u64[0];
          v73.i64[1] = vdupq_laneq_s64((int64x2_t)v39, 1).u64[0];
          float32x4_t v77 = (float32x4_t)vbslq_s8(v60, (int8x16_t)vmulq_n_f32((float32x4_t)vrev64q_s32((int32x4_t)v74), v37.f32[0]), (int8x16_t)v75);
          float32x4_t v78 = (float32x4_t)vbslq_s8(v60, (int8x16_t)vmulq_n_f32((float32x4_t)vrev64q_s32((int32x4_t)v73), v37.f32[0]), (int8x16_t)v76);
          float32x4_t v79 = vaddq_f32(v77, v77);
          float32x4_t v80 = vaddq_f32(v78, v78);
          v81.i64[0] = vextq_s8((int8x16_t)v79, (int8x16_t)v79, 0xCuLL).u64[0];
          v81.i64[1] = vextq_s8((int8x16_t)v67, (int8x16_t)v67, 8uLL).u64[0];
          v67.i64[0] = vextq_s8((int8x16_t)v80, (int8x16_t)v80, 0xCuLL).u64[0];
          v67.i64[1] = vextq_s8((int8x16_t)v68, (int8x16_t)v68, 8uLL).u64[0];
          float32x4_t v82 = (float32x4_t)vrev64q_s32((int32x4_t)v37);
          float32x4_t v83 = (float32x4_t)vbslq_s8(v60, (int8x16_t)vmulq_laneq_f32(v82, v79, 3), v81);
          float32x4_t v84 = (float32x4_t)vbslq_s8(v60, (int8x16_t)vmulq_laneq_f32(v82, v80, 3), (int8x16_t)v67);
          float32x4_t v85 = vcvtq_f32_s32(vcvtq_s32_f32(v77));
          float32x4_t v86 = vcvtq_f32_s32(vcvtq_s32_f32(v78));
          int8x16_t v87 = (int8x16_t)vsubq_f32(v86, (float32x4_t)vandq_s8((int8x16_t)v43, (int8x16_t)vcgtq_f32(v86, v78)));
          float32x4_t v88 = (float32x4_t)vbslq_s8(v60, (int8x16_t)vsubq_f32(v85, (float32x4_t)vandq_s8((int8x16_t)v43, (int8x16_t)vcgtq_f32(v85, v77))), (int8x16_t)v75);
          float32x4_t v89 = vcvtq_f32_s32(vcvtq_s32_f32(v83));
          float32x4_t v90 = vcvtq_f32_s32(vcvtq_s32_f32(v84));
          float32x4_t v91 = (float32x4_t)vandq_s8((int8x16_t)v43, (int8x16_t)vcgtq_f32(v89, v83));
          float32x4_t v92 = (float32x4_t)vbslq_s8(v60, v87, (int8x16_t)v76);
          float32x4_t v93 = (float32x4_t)vbslq_s8(v60, (int8x16_t)vsubq_f32(v89, v91), v81);
          v89.i32[0] = vsubq_f32(v88, vmulq_lane_f32(v20, *(float32x2_t *)v88.f32, 1)).u32[0];
          float32x4_t v94 = (float32x4_t)vbslq_s8(v60, (int8x16_t)vsubq_f32(v90, (float32x4_t)vandq_s8((int8x16_t)v43, (int8x16_t)vcgtq_f32(v90, v84))), (int8x16_t)v67);
          v89.i64[1] = v88.i64[1];
          v84.i32[0] = vsubq_f32(v93, vmulq_lane_f32(v20, *(float32x2_t *)v93.f32, 1)).u32[0];
          v90.i32[0] = vsubq_f32(v94, vmulq_lane_f32(v20, *(float32x2_t *)v94.f32, 1)).u32[0];
          v84.i64[1] = v93.i64[1];
          v90.i64[1] = v94.i64[1];
          v84.i32[1] = 0.5;
          v90.i32[1] = 0.5;
          float32x4_t v95 = vaddq_f32(vsubq_f32(v84, v5), v10);
          int32x4_t v96 = vcvtq_s32_f32(v95);
          float32x4_t v97 = vaddq_f32(vsubq_f32(v90, v5), v10);
          int32x4_t v98 = vcvtq_s32_f32(v97);
          v89.i32[1] = 0.5;
          float32x4_t v99 = vaddq_f32(vsubq_f32(v89, v5), v10);
          int32x4_t v100 = vcvtq_s32_f32(v99);
          int32x4_t v101 = vcgtq_f32(vcvtq_f32_s32(v100), v99);
          v99.i32[0] = vsubq_f32(v92, vmulq_lane_f32(v20, *(float32x2_t *)v92.f32, 1)).u32[0];
          v99.i64[1] = v92.i64[1];
          v95.i64[0] = vaddq_s32(v96, vcgtq_f32(vcvtq_f32_s32(v96), v95)).u64[0];
          v100.i64[0] = vaddq_s32(v100, v101).u64[0];
          v101.i64[0] = vaddq_s32(v98, vcgtq_f32(vcvtq_f32_s32(v98), v97)).u64[0];
          __int32 v102 = v95.i32[0] + v95.i32[1] * v46;
          int32x4_t v103 = *(int32x4_t *)(*(void *)&v49 + 16 * (v100.i32[0] + v100.i32[1] * v46));
          v99.i32[1] = 0.5;
          __int32 v104 = v101.i32[0] + v101.i32[1] * v46;
          float32x4_t v105 = vaddq_f32(vsubq_f32(v99, v5), v10);
          int32x4_t v106 = vcvtq_s32_f32(v105);
          int8x16_t v107 = *(int8x16_t *)(*(void *)&v49 + 16 * v102);
          v105.i64[0] = vaddq_s32(v106, vcgtq_f32(vcvtq_f32_s32(v106), v105)).u64[0];
          int8x16_t v108 = *(int8x16_t *)(*(void *)&v49 + 16 * v104);
          int32x4_t v109 = *(int32x4_t *)(*(void *)&v49 + 16 * (v105.i32[0] + v105.i32[1] * v46));
          v107.i64[1] = v93.i64[1];
          float32x4_t v110 = (float32x4_t)vdupq_laneq_s64((int64x2_t)v88, 1);
          v103.i64[1] = v110.i64[0];
          v108.i64[1] = v94.i64[1];
          float32x4_t v111 = (float32x4_t)vdupq_laneq_s64((int64x2_t)v92, 1);
          v109.i64[1] = v111.i64[0];
          float32x4_t v112 = (float32x4_t)vbslq_s8(v60, (int8x16_t)vmulq_f32(v26, (float32x4_t)vrev64q_s32(v103)), v107);
          float32x4_t v113 = (float32x4_t)vbslq_s8(v60, (int8x16_t)vmulq_f32(v26, (float32x4_t)vrev64q_s32(v109)), v108);
          float32x4_t v114 = (float32x4_t)vbslq_s8(v42, (int8x16_t)vmulq_f32(v43, v112), (int8x16_t)v112);
          float32x4_t v115 = (float32x4_t)vbslq_s8(v42, (int8x16_t)vmulq_f32(v43, v113), (int8x16_t)v113);
          float32x4_t v116 = vcvtq_f32_s32(vcvtq_s32_f32(v114));
          float32x4_t v117 = vcvtq_f32_s32(vcvtq_s32_f32(v115));
          float32x4_t v118 = (float32x4_t)vbslq_s8(v42, (int8x16_t)vsubq_f32(v116, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v116, v114))), (int8x16_t)v112);
          float32x4_t v119 = (float32x4_t)vbslq_s8(v42, (int8x16_t)vsubq_f32(v117, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v117, v115))), (int8x16_t)v113);
          float32x4_t v120 = (float32x4_t)vrev64q_s32((int32x4_t)v118);
          float32x4_t v121 = (float32x4_t)vrev64q_s32((int32x4_t)v119);
          v110.i64[0] = vaddq_f32(v110, v118).u64[0];
          v110.i64[1] = v118.i64[1];
          float32x4_t v122 = vcvtq_f32_s32(vcvtq_s32_f32(v120));
          float32x4_t v123 = vcvtq_f32_s32(vcvtq_s32_f32(v121));
          v111.i64[0] = vaddq_f32(v111, v119).u64[0];
          v120.i64[0] = vsubq_f32(v122, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v122, v120), (int8x16_t)v26, (int8x16_t)0)).u64[0];
          v111.i64[1] = v119.i64[1];
          v123.i64[0] = vsubq_f32(v123, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v123, v121), (int8x16_t)v26, (int8x16_t)0)).u64[0];
          float32x4_t v124 = vminq_f32(vmaxq_f32(vmulq_f32(v17, vrecpeq_f32(*(float32x4_t *)v16)), v18), v27);
          float32x4_t v125 = vmulq_f32(v124, vrecpsq_f32(*(float32x4_t *)v16, v124));
          float32x4_t v126 = (float32x4_t)vbslq_s8(v60, (int8x16_t)vmulq_n_f32(v82, v110.f32[0]), (int8x16_t)v110);
          float32x4_t v127 = (float32x4_t)vbslq_s8(v60, (int8x16_t)vmulq_n_f32(v82, v111.f32[0]), (int8x16_t)v111);
          v120.i64[1] = v88.i64[1];
          float32x4_t v128 = (float32x4_t)vrev64q_s32((int32x4_t)v126);
          float32x4_t v129 = (float32x4_t)vrev64q_s32((int32x4_t)v127);
          float32x4_t v130 = vcvtq_f32_s32(vcvtq_s32_f32(v128));
          float32x4_t v131 = vsubq_f32(v130, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v130, v128)));
          float32x4_t v132 = vcvtq_f32_s32(vcvtq_s32_f32(v129));
          v126.i32[1] = 0.5;
          v127.i32[1] = 0.5;
          v123.i64[1] = v92.i64[1];
          float32x4_t v133 = (float32x4_t)vbslq_s8(v60, (int8x16_t)vmulq_n_f32(v125, v120.f32[0]), (int8x16_t)v120);
          float32x4_t v134 = (float32x4_t)vbslq_s8(v60, (int8x16_t)vmulq_n_f32(v125, v123.f32[0]), (int8x16_t)v123);
          float32x4_t v135 = (float32x4_t)vbslq_s8(v42, (int8x16_t)vsubq_f32(v126, vmulq_f32(v20, v131)), (int8x16_t)v126);
          float32x4_t v136 = (float32x4_t)vbslq_s8(v42, (int8x16_t)vsubq_f32(v127, vmulq_f32(v20, vsubq_f32(v132, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v132, v129))))), (int8x16_t)v127);
          float32x4_t v137 = vaddq_f32(vsubq_f32(v135, v5), v10);
          int32x4_t v138 = vcvtq_s32_f32(v137);
          v137.i64[0] = vaddq_s32(v138, vcgtq_f32(vcvtq_f32_s32(v138), v137)).u64[0];
          __int32 v139 = v137.i32[1];
          __int32 v140 = v137.i32[0];
          float32x4_t v141 = vaddq_f32(vsubq_f32(v136, v5), v10);
          int32x4_t v142 = vcvtq_s32_f32(v141);
          v141.i64[0] = vaddq_s32(v142, vcgtq_f32(vcvtq_f32_s32(v142), v141)).u64[0];
          __int32 v143 = v140 + v139 * v46;
          __int32 v144 = v141.i32[0] + v141.i32[1] * v46;
          int8x16_t v145 = *(int8x16_t *)(*(void *)&v49 + 16 * v143);
          int8x16_t v146 = *(int8x16_t *)(*(void *)&v49 + 16 * v144);
          v145.i64[1] = v135.i64[1];
          float32x4_t v147 = vcvtq_f32_s32(vcvtq_s32_f32(v133));
          float32x4_t v148 = vcvtq_f32_s32(vcvtq_s32_f32(v134));
          v146.i64[1] = v136.i64[1];
          float32x4_t v149 = (float32x4_t)vbslq_s8(v60, (int8x16_t)vsubq_f32(v147, (float32x4_t)vandq_s8((int8x16_t)v43, (int8x16_t)vcgtq_f32(v147, v133))), v145);
          float32x4_t v150 = (float32x4_t)vbslq_s8(v60, (int8x16_t)vsubq_f32(v148, (float32x4_t)vandq_s8((int8x16_t)v43, (int8x16_t)vcgtq_f32(v148, v134))), v146);
          float32x4_t v151 = (float32x4_t)vbslq_s8(v42, (int8x16_t)vmulq_f32(v43, v149), (int8x16_t)v149);
          float32x4_t v152 = (float32x4_t)vbslq_s8(v42, (int8x16_t)vmulq_f32(v43, v150), (int8x16_t)v150);
          float32x4_t v153 = (float32x4_t)vbslq_s8(v60, (int8x16_t)vsubq_f32((float32x4_t)vrev64q_s32((int32x4_t)v133), vmulq_f32(*(float32x4_t *)v16, v151)), (int8x16_t)v151);
          float32x4_t v154 = (float32x4_t)vbslq_s8(v60, (int8x16_t)vsubq_f32((float32x4_t)vrev64q_s32((int32x4_t)v134), vmulq_f32(*(float32x4_t *)v16, v152)), (int8x16_t)v152);
          float32x4_t v155 = vcvtq_f32_s32(vcvtq_s32_f32(v153));
          float32x4_t v156 = vcvtq_f32_s32(vcvtq_s32_f32(v154));
          float32x4_t v157 = (float32x4_t)vrev64q_s32(*(int32x4_t *)v16);
          float32x4_t v158 = (float32x4_t)vbslq_s8(v42, (int8x16_t)vsubq_f32(v155, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v155, v153))), (int8x16_t)v153);
          float32x4_t v159 = vminq_f32(vmaxq_f32(vmulq_f32(v17, vrecpeq_f32(v157)), v18), v27);
          float32x4_t v160 = (float32x4_t)vbslq_s8(v42, (int8x16_t)vsubq_f32(v156, (float32x4_t)vandq_s8((int8x16_t)v26, (int8x16_t)vcgtq_f32(v156, v154))), (int8x16_t)v154);
          float32x4_t v161 = vmulq_f32(v159, vrecpsq_f32(v157, v159));
          v18.i64[0] = vmulq_n_f32(v161, v158.f32[0]).u64[0];
          v18.i64[1] = vdupq_laneq_s64((int64x2_t)v133, 1).u64[0];
          v161.i64[0] = vmulq_n_f32(v161, v160.f32[0]).u64[0];
          v161.i64[1] = vdupq_laneq_s64((int64x2_t)v134, 1).u64[0];
          float32x4_t v162 = (float32x4_t)vrev64q_s32((int32x4_t)v18);
          float32x4_t v163 = (float32x4_t)vrev64q_s32((int32x4_t)v161);
          float32x4_t v164 = vcvtq_f32_s32(vcvtq_s32_f32(v162));
          float32x4_t v165 = vcvtq_f32_s32(vcvtq_s32_f32(v163));
          v162.i64[0] = vsubq_f32(v164, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v164, v162), (int8x16_t)v26, (int8x16_t)0)).u64[0];
          v162.i64[1] = v133.i64[1];
          v163.i64[0] = vsubq_f32(v165, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v165, v163), (int8x16_t)v26, (int8x16_t)0)).u64[0];
          float32x4_t v166 = (float32x4_t)vextq_s8((int8x16_t)v25, (int8x16_t)v25, 8uLL);
          v163.i64[1] = v134.i64[1];
          v158.i64[1] = vsubq_f32(v158, vmulq_f32(v166, v133)).i64[1];
          v160.i64[1] = vsubq_f32(v160, vmulq_f32(v166, v134)).i64[1];
          float32x4_t v167 = (float32x4_t)vbslq_s8(v42, (int8x16_t)vsubq_f32(v158, vmulq_f32(*(float32x4_t *)v16, v162)), (int8x16_t)v158);
          float32x4_t v168 = (float32x4_t)vbslq_s8(v42, (int8x16_t)vsubq_f32(v160, vmulq_f32(*(float32x4_t *)v16, v163)), (int8x16_t)v160);
          __int32 v169 = a2[13].i32[0];
          float32x4_t v170 = vaddq_f32(vsubq_f32(vaddq_f32(vmulq_f32(v25, v167), (float32x4_t)vextq_s8((int8x16_t)v167, (int8x16_t)v167, 8uLL)), v5), v10);
          int32x4_t v171 = vcvtq_s32_f32(v170);
          v170.i64[0] = vaddq_s32(v171, vcgtq_f32(vcvtq_f32_s32(v171), v170)).u64[0];
          int32x2_t v172 = a2[12];
          __int32 v173 = v170.i32[1];
          __int32 v174 = v170.i32[0];
          float32x4_t v175 = vaddq_f32(vsubq_f32(vaddq_f32(vmulq_f32(v25, v168), (float32x4_t)vextq_s8((int8x16_t)v168, (int8x16_t)v168, 8uLL)), v5), v10);
          int32x4_t v176 = vcvtq_s32_f32(v175);
          __int32 v177 = v174 + v173 * v169;
          v175.i64[0] = vaddq_s32(v176, vcgtq_f32(vcvtq_f32_s32(v176), v175)).u64[0];
          __int32 v178 = v175.i32[1];
          __int32 v179 = v175.i32[0];
          int8x16_t v180 = *(int8x16_t *)(*(void *)&v172 + 16 * v177);
          int8x16_t v181 = *(int8x16_t *)(*(void *)&v172 + 16 * (v179 + v178 * v169));
          *(int8x8_t *)v171.i8 = vqtbl1_s8(v180, *(int8x8_t *)v59.i8);
          v162.i64[0] = vextq_s8(v59, v59, 8uLL).u64[0];
          v171.u64[1] = (unint64_t)vqtbl1_s8(v180, *(int8x8_t *)v162.f32);
          *(int8x8_t *)v160.f32 = vqtbl1_s8(v181, *(int8x8_t *)v59.i8);
          *(int8x8_t *)&v160.u32[2] = vqtbl1_s8(v181, *(int8x8_t *)v162.f32);
          float32x4_t v182 = *(float32x4_t *)(v16 + 240);
          int8x16_t v183 = (int8x16_t)vcgtq_f32(*(float32x4_t *)(v16 + 224), *(float32x4_t *)(v16 + 48));
          v184 = (float32x4_t *)(*(void *)&v8 + 16 * v12);
          float32x4_t *v184 = vaddq_f32(v182, vmulq_f32(v21, vsubq_f32((float32x4_t)vbslq_s8(v183, (int8x16_t)v171, v180), v182)));
          v184[1] = vaddq_f32(v182, vmulq_f32(v21, vsubq_f32((float32x4_t)vbslq_s8(v183, (int8x16_t)v160, v181), v182)));
          float32x4_t v14 = vaddq_f32(v15, (float32x4_t)xmmword_1B7E736B0);
          v12 += 2;
          v13 -= 2;
        }
        while (v13 > 1);
        uint64_t v12 = v12;
        float32x4_t v7 = (float32x4_t)xmmword_1B7E736C0;
        float32x4_t v11 = v267;
      }
      if ((int)v12 < v6)
      {
        uint64_t v185 = *((void *)this + 51);
        float32x4_t v186 = *(float32x4_t *)(v185 + 32);
        float32x4_t v187 = *(float32x4_t *)(v185 + 96);
        float32x4_t v188 = *(float32x4_t *)(v185 + 112);
        float32x4_t v190 = *(float32x4_t *)(v185 + 128);
        float32x4_t v189 = *(float32x4_t *)(v185 + 144);
        float32x4_t v191 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v186), v187), v188), v190);
        float32x4_t v192 = vmulq_f32(v191, vrecpsq_f32(v186, v191));
        float32x4_t v193 = vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v14, (int8x16_t)v14, 8uLL), *(float32x4_t *)(v185 + 80));
        float32x4_t v194 = *(float32x4_t *)(v185 + 16);
        float32x4_t v195 = vminq_f32(vmaxq_f32(vrecpeq_f32(v194), v188), v190);
        float32x4_t v196 = vminq_f32(vmaxq_f32(vmulq_f32(v195, vrecpsq_f32(v194, v195)), v188), v190);
        float32x4_t v197 = (float32x4_t)vextq_s8((int8x16_t)v193, (int8x16_t)vmulq_f32((float32x4_t)vdupq_laneq_s64((int64x2_t)v193, 1), vmulq_f32(v196, vrecpsq_f32(v194, v196))), 8uLL);
        float32x4_t v198 = vcvtq_f32_s32(vcvtq_s32_f32(v197));
        float32x4_t v199 = vsubq_f32(v198, (float32x4_t)vandq_s8((int8x16_t)v188, (int8x16_t)vcgtq_f32(v198, v197)));
        v197.i64[0] = vmulq_laneq_f32(v192, v199, 2).u64[0];
        v197.i64[1] = v193.i64[1];
        float32x4_t v200 = vcvtq_f32_s32(vcvtq_s32_f32(v197));
        v193.i32[0] = vsubq_f32(v200, (float32x4_t)vandq_s8((int8x16_t)v189, (int8x16_t)vcgtq_f32(v200, v197))).u32[0];
        v193.i32[1] = 0.5;
        int8x16_t v201 = *(int8x16_t *)(v185 + 160);
        float32x4_t v202 = *(float32x4_t *)(v185 + 176);
        float32x4_t v203 = (float32x4_t)vbslq_s8(v201, (int8x16_t)vsubq_f32((float32x4_t)vextq_s8((int8x16_t)v199, (int8x16_t)v199, 8uLL), vmulq_f32(v186, v193)), (int8x16_t)v193);
        __int32 v204 = a2[11].i32[0];
        float32x4_t v205 = vaddq_f32(vsubq_f32(v203, v5), v10);
        int32x4_t v206 = vcvtq_s32_f32(v205);
        v205.i64[0] = vaddq_s32(v206, vcgtq_f32(vcvtq_f32_s32(v206), v205)).u64[0];
        int32x2_t v207 = a2[10];
        v205.i64[0] = vmulq_f32(*(float32x4_t *)(*(void *)&v207 + 16 * (v205.i32[0] + v205.i32[1] * v204)), v202).u64[0];
        v205.i64[1] = v203.i64[1];
        float32x4_t v208 = vcvtq_f32_s32(vcvtq_s32_f32(v205));
        v205.i64[0] = vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v199, (int8x16_t)v199, 0xCuLL), vsubq_f32(v208, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v208, v205), (int8x16_t)v189, (int8x16_t)0))).u64[0];
        v209.i64[0] = v205.i64[0];
        v209.i64[1] = v203.i64[1];
        v205.i64[1] = vdupq_laneq_s64((int64x2_t)v203, 1).u64[0];
        int8x16_t v210 = (int8x16_t)vmulq_n_f32((float32x4_t)vrev64q_s32((int32x4_t)v205), v192.f32[0]);
        int8x16_t v212 = *(int8x16_t *)(v185 + 192);
        int8x16_t v211 = *(int8x16_t *)(v185 + 208);
        float32x4_t v213 = (float32x4_t)vbslq_s8(v212, v210, v209);
        float32x4_t v214 = (float32x4_t)vrev64q_s32((int32x4_t)v213);
        float32x4_t v215 = vcvtq_f32_s32(vcvtq_s32_f32(v214));
        v214.i64[0] = vsubq_f32(v215, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v215, v214), (int8x16_t)v189, (int8x16_t)0)).u64[0];
        v214.i64[1] = v199.i64[1];
        v213.i32[1] = 0.5;
        float32x4_t v216 = (float32x4_t)vbslq_s8(v201, (int8x16_t)vsubq_f32(v213, vmulq_f32(v186, v214)), (int8x16_t)v213);
        float32x4_t v217 = vaddq_f32(vsubq_f32(v216, v5), v10);
        int32x4_t v218 = vcvtq_s32_f32(v217);
        v217.i64[0] = vaddq_s32(v218, vcgtq_f32(vcvtq_f32_s32(v218), v217)).u64[0];
        v218.i64[0] = vextq_s8((int8x16_t)v216, (int8x16_t)v216, 8uLL).u64[0];
        v217.i64[0] = vmulq_f32(v202, *(float32x4_t *)(*(void *)&v207 + 16 * (v217.i32[0] + v217.i32[1] * v204))).u64[0];
        v217.i64[1] = v216.i64[1];
        float32x4_t v219 = vcvtq_f32_s32(vcvtq_s32_f32(v217));
        v219.i64[0] = vsubq_f32(v219, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v219, v217), (int8x16_t)v189, (int8x16_t)0)).u64[0];
        v217.i64[0] = v219.i64[0];
        v217.i64[1] = v199.i64[1];
        v219.i64[1] = vdupq_laneq_s64((int64x2_t)v199, 1).u64[0];
        float32x4_t v220 = (float32x4_t)vbslq_s8(v212, (int8x16_t)vmulq_n_f32((float32x4_t)vrev64q_s32((int32x4_t)v219), v192.f32[0]), (int8x16_t)v217);
        float32x4_t v221 = vaddq_f32(v220, v220);
        v222.i64[0] = vextq_s8((int8x16_t)v221, (int8x16_t)v221, 0xCuLL).u64[0];
        v222.i64[1] = v218.i64[0];
        float32x4_t v223 = (float32x4_t)vrev64q_s32((int32x4_t)v192);
        float32x4_t v224 = (float32x4_t)vbslq_s8(v212, (int8x16_t)vmulq_laneq_f32(v223, v221, 3), v222);
        float32x4_t v225 = vcvtq_f32_s32(vcvtq_s32_f32(v220));
        float32x4_t v226 = (float32x4_t)vbslq_s8(v212, (int8x16_t)vsubq_f32(v225, (float32x4_t)vandq_s8((int8x16_t)v202, (int8x16_t)vcgtq_f32(v225, v220))), (int8x16_t)v217);
        float32x4_t v227 = vcvtq_f32_s32(vcvtq_s32_f32(v224));
        float32x4_t v228 = (float32x4_t)vbslq_s8(v212, (int8x16_t)vsubq_f32(v227, (float32x4_t)vandq_s8((int8x16_t)v202, (int8x16_t)vcgtq_f32(v227, v224))), v222);
        v227.i32[0] = vsubq_f32(v226, vmulq_lane_f32(v186, *(float32x2_t *)v226.f32, 1)).u32[0];
        v227.i64[1] = v226.i64[1];
        v225.i32[0] = vsubq_f32(v228, vmulq_lane_f32(v186, *(float32x2_t *)v228.f32, 1)).u32[0];
        v225.i64[1] = v228.i64[1];
        v225.i32[1] = 0.5;
        float32x4_t v229 = vaddq_f32(vsubq_f32(v225, v5), v10);
        int32x4_t v230 = vcvtq_s32_f32(v229);
        v229.i64[0] = vaddq_s32(v230, vcgtq_f32(vcvtq_f32_s32(v230), v229)).u64[0];
        int8x16_t v231 = *(int8x16_t *)(*(void *)&v207 + 16 * (v229.i32[0] + v229.i32[1] * v204));
        v231.i64[1] = v228.i64[1];
        v227.i32[1] = 0.5;
        float32x4_t v232 = vaddq_f32(vsubq_f32(v227, v5), v10);
        int32x4_t v233 = vcvtq_s32_f32(v232);
        v232.i64[0] = vaddq_s32(v233, vcgtq_f32(vcvtq_f32_s32(v233), v232)).u64[0];
        int32x4_t v234 = *(int32x4_t *)(*(void *)&v207 + 16 * (v232.i32[0] + v232.i32[1] * v204));
        float32x4_t v235 = (float32x4_t)vdupq_laneq_s64((int64x2_t)v226, 1);
        v234.i64[1] = v235.i64[0];
        float32x4_t v236 = (float32x4_t)vbslq_s8(v212, (int8x16_t)vmulq_f32(v189, (float32x4_t)vrev64q_s32(v234)), v231);
        float32x4_t v237 = (float32x4_t)vbslq_s8(v201, (int8x16_t)vmulq_f32(v202, v236), (int8x16_t)v236);
        float32x4_t v238 = vcvtq_f32_s32(vcvtq_s32_f32(v237));
        float32x4_t v239 = (float32x4_t)vbslq_s8(v201, (int8x16_t)vsubq_f32(v238, (float32x4_t)vandq_s8((int8x16_t)v189, (int8x16_t)vcgtq_f32(v238, v237))), (int8x16_t)v236);
        float32x4_t v240 = (float32x4_t)vrev64q_s32((int32x4_t)v239);
        float32x4_t v241 = vcvtq_f32_s32(vcvtq_s32_f32(v240));
        v240.i64[0] = vsubq_f32(v241, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v241, v240), (int8x16_t)v189, (int8x16_t)0)).u64[0];
        float32x4_t v242 = vminq_f32(vmaxq_f32(vmulq_f32(v187, vrecpeq_f32(*(float32x4_t *)v185)), v188), v190);
        v240.i64[1] = v226.i64[1];
        v226.i64[0] = vaddq_f32(v235, v239).u64[0];
        v226.i64[1] = v239.i64[1];
        float32x4_t v243 = (float32x4_t)vbslq_s8(v212, (int8x16_t)vmulq_n_f32(v223, v226.f32[0]), (int8x16_t)v226);
        float32x4_t v244 = (float32x4_t)vrev64q_s32((int32x4_t)v243);
        float32x4_t v245 = vcvtq_f32_s32(vcvtq_s32_f32(v244));
        float32x4_t v246 = vsubq_f32(v245, (float32x4_t)vandq_s8((int8x16_t)v189, (int8x16_t)vcgtq_f32(v245, v244)));
        v243.i32[1] = 0.5;
        float32x4_t v247 = (float32x4_t)vbslq_s8(v212, (int8x16_t)vmulq_n_f32(vmulq_f32(v242, vrecpsq_f32(*(float32x4_t *)v185, v242)), v240.f32[0]), (int8x16_t)v240);
        float32x4_t v248 = (float32x4_t)vbslq_s8(v201, (int8x16_t)vsubq_f32(v243, vmulq_f32(v186, v246)), (int8x16_t)v243);
        float32x4_t v249 = vaddq_f32(vsubq_f32(v248, v5), v10);
        int32x4_t v250 = vcvtq_s32_f32(v249);
        v249.i64[0] = vaddq_s32(v250, vcgtq_f32(vcvtq_f32_s32(v250), v249)).u64[0];
        int8x16_t v251 = *(int8x16_t *)(*(void *)&v207 + 16 * (v249.i32[0] + v249.i32[1] * v204));
        v251.i64[1] = v248.i64[1];
        float32x4_t v252 = vcvtq_f32_s32(vcvtq_s32_f32(v247));
        float32x4_t v253 = (float32x4_t)vbslq_s8(v212, (int8x16_t)vsubq_f32(v252, (float32x4_t)vandq_s8((int8x16_t)v202, (int8x16_t)vcgtq_f32(v252, v247))), v251);
        float32x4_t v254 = (float32x4_t)vbslq_s8(v201, (int8x16_t)vmulq_f32(v202, v253), (int8x16_t)v253);
        float32x4_t v255 = (float32x4_t)vbslq_s8(v212, (int8x16_t)vsubq_f32((float32x4_t)vrev64q_s32((int32x4_t)v247), vmulq_f32(*(float32x4_t *)v185, v254)), (int8x16_t)v254);
        float32x4_t v256 = vcvtq_f32_s32(vcvtq_s32_f32(v255));
        float32x4_t v257 = (float32x4_t)vbslq_s8(v201, (int8x16_t)vsubq_f32(v256, (float32x4_t)vandq_s8((int8x16_t)v189, (int8x16_t)vcgtq_f32(v256, v255))), (int8x16_t)v255);
        float32x4_t v258 = (float32x4_t)vrev64q_s32(*(int32x4_t *)v185);
        float32x4_t v259 = vminq_f32(vmaxq_f32(vmulq_f32(v187, vrecpeq_f32(v258)), v188), v190);
        v258.i64[0] = vmulq_n_f32(vmulq_f32(v259, vrecpsq_f32(v258, v259)), v257.f32[0]).u64[0];
        v258.i64[1] = vdupq_laneq_s64((int64x2_t)v247, 1).u64[0];
        float32x4_t v260 = (float32x4_t)vrev64q_s32((int32x4_t)v258);
        float32x4_t v261 = vcvtq_f32_s32(vcvtq_s32_f32(v260));
        v260.i64[0] = vsubq_f32(v261, (float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v261, v260), (int8x16_t)v189, (int8x16_t)0)).u64[0];
        v260.i64[1] = v247.i64[1];
        v257.i64[1] = vsubq_f32(v257, vmulq_f32((float32x4_t)vdupq_lane_s64(*(uint64_t *)&v194, 0), v247)).i64[1];
        float32x4_t v262 = (float32x4_t)vbslq_s8(v201, (int8x16_t)vsubq_f32(v257, vmulq_f32(*(float32x4_t *)v185, v260)), (int8x16_t)v257);
        float32x4_t v263 = vaddq_f32(vsubq_f32(vaddq_f32(vmulq_f32(v194, v262), (float32x4_t)vextq_s8((int8x16_t)v262, (int8x16_t)v262, 8uLL)), v5), v10);
        int32x4_t v264 = vcvtq_s32_f32(v263);
        v263.i64[0] = vaddq_s32(v264, vcgtq_f32(vcvtq_f32_s32(v264), v263)).u64[0];
        int8x16_t v265 = *(int8x16_t *)(*(void *)&a2[12] + 16 * (v263.i32[0] + v263.i32[1] * a2[13].i32[0]));
        *(int8x8_t *)v264.i8 = vqtbl1_s8(v265, *(int8x8_t *)v211.i8);
        v264.u64[1] = (unint64_t)vqtbl1_s8(v265, (int8x8_t)*(_OWORD *)&vextq_s8(v211, v211, 8uLL));
        *(float32x4_t *)(*(void *)&v8 + 16 * v12) = vaddq_f32(*(float32x4_t *)(v185 + 240), vmulq_f32(*(float32x4_t *)(v185 + 64), vsubq_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(*(float32x4_t *)(v185 + 224), *(float32x4_t *)(v185 + 48)), (int8x16_t)v264, v265), *(float32x4_t *)(v185 + 240))));
      }
      float32x4_t v11 = vaddq_f32(v11, v7);
      *(void *)&v8 += v9;
      ++v4;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t HgcSampleTiledNoise::GetDOD(HgcSampleTiledNoise *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  int v4 = &HGRectInfinite;
  if (a3 >= 2) {
    int v4 = &HGRectNull;
  }
  return *(void *)v4;
}

uint64_t HgcSampleTiledNoise::GetROI(HGNode *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 > 1) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, a3);
  return HGRenderer::GetDOD(a2, Input);
}

void HgcSampleTiledNoise::HgcSampleTiledNoise(HgcSampleTiledNoise *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F1116B60;
  operator new();
}

void sub_1B7A4C1BC(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcSampleTiledNoise::~HgcSampleTiledNoise(HGNode *this)
{
  *(void *)this = &unk_1F1116B60;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40FDACBBE0);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcSampleTiledNoise::~HgcSampleTiledNoise(this);

  HGObject::operator delete(v1);
}

uint64_t HgcSampleTiledNoise::SetParameter(HgcSampleTiledNoise *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7, double a8)
{
  switch((int)a2)
  {
    case 0:
      int32x2_t v8 = (float *)*((void *)this + 51);
      if (*v8 == a3.n128_f32[0] && v8[1] == a4 && v8[2] == a5 && v8[3] == a6) {
        return 0;
      }
      float *v8 = a3.n128_f32[0];
      v8[1] = a4;
      v8[2] = a5;
      v8[3] = a6;
      goto LABEL_33;
    case 1:
      float32x4_t v10 = (float *)*((void *)this + 51);
      if (v10[4] == a3.n128_f32[0] && v10[5] == a4 && v10[6] == a5 && v10[7] == a6) {
        return 0;
      }
      v10[4] = a3.n128_f32[0];
      v10[5] = a4;
      v10[6] = a5;
      v10[7] = a6;
      goto LABEL_33;
    case 2:
      float32x4_t v11 = (float *)*((void *)this + 51);
      if (v11[8] == a3.n128_f32[0] && v11[9] == a4 && v11[10] == a5 && v11[11] == a6) {
        return 0;
      }
      v11[8] = a3.n128_f32[0];
      v11[9] = a4;
      v11[10] = a5;
      v11[11] = a6;
      goto LABEL_33;
    case 3:
      *(float *)&a8 = -a3.n128_f32[0];
      uint64_t v12 = (__n128 *)*((void *)this + 51);
      if (v12[3].n128_f32[0] == (float)-a3.n128_f32[0]
        && v12[3].n128_f32[1] == *(float *)&a8
        && v12[3].n128_f32[2] == *(float *)&a8
        && v12[3].n128_f32[3] == *(float *)&a8)
      {
        return 0;
      }
      a3.n128_f32[1] = a4;
      v12[3] = (__n128)vdupq_lane_s32(*(int32x2_t *)&a8, 0);
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      v12[16] = a3;
      goto LABEL_33;
    case 4:
      int v13 = (__n128 *)*((void *)this + 51);
      if (v13[4].n128_f32[0] == a3.n128_f32[0]
        && v13[4].n128_f32[1] == a3.n128_f32[0]
        && v13[4].n128_f32[2] == a3.n128_f32[0]
        && v13[4].n128_f32[3] == a3.n128_f32[0])
      {
        return 0;
      }
      int32x4_t v14 = vdupq_lane_s32((int32x2_t)a3.n128_u64[0], 0);
      a3.n128_f32[1] = a4;
      float32x4_t v13[4] = (__n128)v14;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      v13[17] = a3;
      goto LABEL_33;
    case 5:
      float32x4_t v15 = (__n128 *)*((void *)this + 51);
      if (v15[5].n128_f32[0] == 0.0
        && v15[5].n128_f32[1] == 0.0
        && v15[5].n128_f32[2] == a3.n128_f32[0]
        && v15[5].n128_f32[3] == a4)
      {
        return 0;
      }
      v15[5].n128_u64[0] = 0;
      v15[5].n128_u32[2] = a3.n128_u32[0];
      v15[5].n128_f32[3] = a4;
      a3.n128_f32[1] = a4;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      v15[18] = a3;
LABEL_33:
      HGNode::ClearBits((HGNode *)this, a2, a7);
      return 1;
    default:
      return 0xFFFFFFFFLL;
  }
}

float HgcSampleTiledNoise::GetParameter(HgcSampleTiledNoise *this, int a2, float *a3)
{
  switch(a2)
  {
    case 0:
      int v3 = (float *)*((void *)this + 51);
      *a3 = *v3;
      a3[1] = v3[1];
      a3[2] = v3[2];
      int v4 = v3 + 3;
      goto LABEL_8;
    case 1:
      float32x4_t v5 = (float *)*((void *)this + 51);
      *a3 = v5[4];
      a3[1] = v5[5];
      a3[2] = v5[6];
      int v4 = v5 + 7;
      goto LABEL_8;
    case 2:
      int v6 = (float *)*((void *)this + 51);
      *a3 = v6[8];
      a3[1] = v6[9];
      a3[2] = v6[10];
      int v4 = v6 + 11;
      goto LABEL_8;
    case 3:
      float32x4_t v7 = (float *)*((void *)this + 51);
      *a3 = v7[64];
      a3[1] = v7[65];
      a3[2] = v7[66];
      int v4 = v7 + 67;
      goto LABEL_8;
    case 4:
      int32x2_t v8 = (float *)*((void *)this + 51);
      *a3 = v8[68];
      a3[1] = v8[69];
      a3[2] = v8[70];
      int v4 = v8 + 71;
      goto LABEL_8;
    case 5:
      uint64_t v9 = (float *)*((void *)this + 51);
      *a3 = v9[72];
      a3[1] = v9[73];
      a3[2] = v9[74];
      int v4 = v9 + 75;
LABEL_8:
      float result = *v4;
      a3[3] = *v4;
      break;
    default:
      return result;
  }
  return result;
}

const char *HgcClampToAlpha::GetProgram(HgcClampToAlpha *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002ac\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = fmin(r0, r0.wwww);\n"
             "    output.color0 = fmax(float4(r0), float4(c0.xxxx));\n"
             "    return output;\n"
             "}\n"
             "//MD5=351d0602:d7435980:23a180db:6ac0349e\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000298\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0 = fmin(r0, r0.wwww);\n"
             "    output.color0 = fmax(r0, c0.xxxx);\n"
             "    return output;\n"
             "}\n"
             "//MD5=f6a4a7c1:62f1e626:6dd47e16:5f43802b\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000023d\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    defaultp vec4 r0;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0 = min(r0, r0.wwww);\n"
           "    gl_FragColor = max(r0, c0.xxxx);\n"
           "}\n"
           "//MD5=5908ea60:fa3c4189:708ea689:5d32e2fd\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcClampToAlpha::InitProgramDescriptor(HgcClampToAlpha *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcClampToAlpha_hgc_visible", "//Metal1.0     \n//LEN=0000000171\n[[ visible ]] FragmentOut HgcClampToAlpha_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r0 = fmin(r0, r0.wwww);\n"
    "    output.color0 = fmax(r0, c0.xxxx);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcClampToAlpha");
}

void sub_1B7A4C6D0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E757E0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  float32x4_t v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7A4C7D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7A4C810()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7A4C808);
}

void *HgcClampToAlpha::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcClampToAlpha [hgc1]");
}

uint64_t HgcClampToAlpha::BindTexture(HgcClampToAlpha *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcClampToAlpha::Bind(HgcClampToAlpha *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcClampToAlpha::RenderTile(HgcClampToAlpha *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 22);
    uint64_t v8 = 16 * *((int *)a2 + 6);
    do
    {
      if (v4 < 4)
      {
        LODWORD(v16) = 0;
      }
      else
      {
        int v9 = 0;
        uint64_t v10 = 32;
        do
        {
          float32x4_t v11 = *(float32x4_t *)*((void *)this + 51);
          float32x4_t v12 = vmaxq_f32(vminq_f32(*(float32x4_t *)(v6 + v10 - 16), (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v6 + v10 - 16), 3)), v11);
          float32x4_t v13 = vmaxq_f32(vminq_f32(*(float32x4_t *)(v6 + v10), (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v6 + v10), 3)), v11);
          float32x4_t v14 = vmaxq_f32(vminq_f32(*(float32x4_t *)(v6 + v10 + 16), (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v6 + v10 + 16), 3)), v11);
          float32x4_t v15 = (float32x4_t *)(v5 + v10);
          v15[-2] = vmaxq_f32(vminq_f32(*(float32x4_t *)(v6 + v10 - 32), (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v6 + v10 - 32), 3)), v11);
          v15[-1] = v12;
          float32x4_t *v15 = v13;
          v15[1] = v14;
          v9 -= 4;
          v10 += 64;
        }
        while (v4 + v9 > 3);
        LODWORD(v16) = -v9;
      }
      if ((int)v16 < v4)
      {
        uint64_t v16 = v16;
        do
        {
          *(float32x4_t *)(v5 + 16 * v16) = vmaxq_f32(vminq_f32(*(float32x4_t *)(v6 + 16 * v16), (float32x4_t)vdupq_laneq_s32(*(int32x4_t *)(v6 + 16 * v16), 3)), *(float32x4_t *)*((void *)this + 51));
          ++v16;
        }
        while (v16 < v4);
      }
      ++v3;
      v6 += v7;
      v5 += v8;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcClampToAlpha::GetDOD(HgcClampToAlpha *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcClampToAlpha::GetROI(HgcClampToAlpha *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcClampToAlpha::HgcClampToAlpha(HgcClampToAlpha *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F1116DC8;
  operator new();
}

void sub_1B7A4CB34(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcClampToAlpha::~HgcClampToAlpha(HGNode *this)
{
  *(void *)this = &unk_1F1116DC8;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcClampToAlpha::~HgcClampToAlpha(this);

  HGObject::operator delete(v1);
}

uint64_t HgcClampToAlpha::SetParameter(HgcClampToAlpha *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcClampToAlpha::GetParameter(HgcClampToAlpha *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcStripAlpha::GetProgram(HgcStripAlpha *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000282\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    FragmentOut output;\n"
             "\n"
             "    output.color0.xyz = (float3) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).xyz;\n"
             "    output.color0.w = float(c0.w);\n"
             "    return output;\n"
             "}\n"
             "//MD5=39e23b55:3eef278e:900e5a12:8739e261\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0000:0000:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000275\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
             "    FragmentOut output;\n"
             "\n"
             "    output.color0.xyz = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy).xyz;\n"
             "    output.color0.w = c0.w;\n"
             "    return output;\n"
             "}\n"
             "//MD5=80457804:66cd910c:e0e98d99:0a1aa675\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0000:0000:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000214\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const defaultp vec4 c0 = vec4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
           "\n"
           "    gl_FragColor.xyz = texture2D(hg_Texture0, hg_TexCoord0.xy).xyz;\n"
           "    gl_FragColor.w = c0.w;\n"
           "}\n"
           "//MD5=cdf2251d:7c3763a2:fc98cb69:2ea05d33\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0000:0000:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcStripAlpha::InitProgramDescriptor(HgcStripAlpha *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcStripAlpha_hgc_visible", "//Metal1.0     \n//LEN=000000014c\n[[ visible ]] FragmentOut HgcStripAlpha_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.000000000, 0.000000000, 0.000000000, 1.000000000);\n"
    "    FragmentOut output;\n"
    "\n"
    "    output.color0.xyz = color0.xyz;\n"
    "    output.color0.w = c0.w;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcStripAlpha");
}

void sub_1B7A4CD08(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E757E0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  float32x4_t v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7A4CE08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7A4CE48()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7A4CE40);
}

void *HgcStripAlpha::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcStripAlpha [hgc1]");
}

uint64_t HgcStripAlpha::BindTexture(HgcStripAlpha *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcStripAlpha::Bind(HgcStripAlpha *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcStripAlpha::RenderTile(HgcStripAlpha *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 22);
    uint64_t v8 = 16 * *((int *)a2 + 6);
    do
    {
      if (v4 < 4)
      {
        LODWORD(v16) = 0;
      }
      else
      {
        int v9 = 0;
        uint64_t v10 = 32;
        do
        {
          long long v11 = *(_OWORD *)(v6 + v10 - 32);
          long long v12 = *(_OWORD *)(v6 + v10 - 16);
          long long v13 = *(_OWORD *)(v6 + v10);
          long long v14 = *(_OWORD *)(v6 + v10 + 16);
          HIDWORD(v11) = 1.0;
          HIDWORD(v12) = 1.0;
          HIDWORD(v13) = 1.0;
          HIDWORD(v14) = 1.0;
          float32x4_t v15 = (_OWORD *)(v5 + v10);
          *(v15 - 2) = v11;
          *(v15 - 1) = v12;
          _OWORD *v15 = v13;
          v15[1] = v14;
          v9 -= 4;
          v10 += 64;
        }
        while (v4 + v9 > 3);
        LODWORD(v16) = -v9;
      }
      if ((int)v16 < v4)
      {
        uint64_t v16 = v16;
        do
        {
          long long v17 = *(_OWORD *)(v6 + 16 * v16);
          HIDWORD(v17) = 1.0;
          *(_OWORD *)(v5 + 16 * v16++) = v17;
        }
        while (v16 < v4);
      }
      ++v3;
      v6 += v7;
      v5 += v8;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcStripAlpha::GetDOD(HgcStripAlpha *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcStripAlpha::GetROI(HgcStripAlpha *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcStripAlpha::HgcStripAlpha(HgcStripAlpha *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F1117030;
  operator new();
}

void sub_1B7A4D130(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcStripAlpha::~HgcStripAlpha(HGNode *this)
{
  *(void *)this = &unk_1F1117030;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0xC400A2AC0F1);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcStripAlpha::~HgcStripAlpha(this);

  HGObject::operator delete(v1);
}

uint64_t HgcStripAlpha::SetParameter(HgcStripAlpha *this, float a2, float a3, float a4, float a5)
{
  return 0xFFFFFFFFLL;
}

uint64_t HgcStripAlpha::GetParameter(HgcStripAlpha *this, int a2, float *a3)
{
  return 0xFFFFFFFFLL;
}

const char *HgcRetimeAddBlend6::GetProgram(HgcRetimeAddBlend6 *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000006b9\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< half > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< half > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< half > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]], \n"
             "    texture2d< half > hg_Texture5 [[ texture(5) ]], \n"
             "    sampler hg_Sampler5 [[ sampler(5) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = (half4) hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = (half4) hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = (half4) hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r5 = (half4) hg_Texture5.sample(hg_Sampler5, frag._texCoord5.xy);\n"
             "    output.color0 = float4(r0)*hg_Params[0];\n"
             "    output.color0 = float4(r1)*hg_Params[1] + output.color0;\n"
             "    output.color0 = float4(r2)*hg_Params[2] + output.color0;\n"
             "    output.color0 = float4(r3)*hg_Params[3] + output.color0;\n"
             "    output.color0 = float4(r4)*hg_Params[4] + output.color0;\n"
             "    output.color0 = float4(r5)*hg_Params[5] + output.color0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=0d1c621b:00258fbd:6ef4399d:d22b1819\n"
             "//SIG=00400000:0000003f:0000003f:0000003f:0000:0006:0006:0000:0000:0000:007e:0000:0006:06:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000660\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]], \n"
             "    texture2d< float > hg_Texture2 [[ texture(2) ]], \n"
             "    sampler hg_Sampler2 [[ sampler(2) ]], \n"
             "    texture2d< float > hg_Texture3 [[ texture(3) ]], \n"
             "    sampler hg_Sampler3 [[ sampler(3) ]], \n"
             "    texture2d< float > hg_Texture4 [[ texture(4) ]], \n"
             "    sampler hg_Sampler4 [[ sampler(4) ]], \n"
             "    texture2d< float > hg_Texture5 [[ texture(5) ]], \n"
             "    sampler hg_Sampler5 [[ sampler(5) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3, r4, r5;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture1.sample(hg_Sampler1, frag._texCoord1.xy);\n"
             "    r2 = hg_Texture2.sample(hg_Sampler2, frag._texCoord2.xy);\n"
             "    r3 = hg_Texture3.sample(hg_Sampler3, frag._texCoord3.xy);\n"
             "    r4 = hg_Texture4.sample(hg_Sampler4, frag._texCoord4.xy);\n"
             "    r5 = hg_Texture5.sample(hg_Sampler5, frag._texCoord5.xy);\n"
             "    output.color0 = r0*hg_Params[0];\n"
             "    output.color0 = r1*hg_Params[1] + output.color0;\n"
             "    output.color0 = r2*hg_Params[2] + output.color0;\n"
             "    output.color0 = r3*hg_Params[3] + output.color0;\n"
             "    output.color0 = r4*hg_Params[4] + output.color0;\n"
             "    output.color0 = r5*hg_Params[5] + output.color0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=01133b2e:b7731226:41b1c4b4:fe07a463\n"
             "//SIG=00000000:0000003f:0000003f:00000000:0000:0006:0006:0000:0000:0000:007e:0000:0006:06:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000064c\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform defaultp sampler2D hg_Texture2;\n"
           "uniform defaultp sampler2D hg_Texture3;\n"
           "uniform defaultp sampler2D hg_Texture4;\n"
           "uniform defaultp sampler2D hg_Texture5;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "uniform defaultp vec4 hg_ProgramLocal2;\n"
           "uniform defaultp vec4 hg_ProgramLocal3;\n"
           "uniform defaultp vec4 hg_ProgramLocal4;\n"
           "uniform defaultp vec4 hg_ProgramLocal5;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "varying highp vec4 hg_TexCoord3;\n"
           "varying highp vec4 hg_TexCoord4;\n"
           "varying highp vec4 hg_TexCoord5;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3, r4, r5;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture1, hg_TexCoord1.xy);\n"
           "    r2 = texture2D(hg_Texture2, hg_TexCoord2.xy);\n"
           "    r3 = texture2D(hg_Texture3, hg_TexCoord3.xy);\n"
           "    r4 = texture2D(hg_Texture4, hg_TexCoord4.xy);\n"
           "    r5 = texture2D(hg_Texture5, hg_TexCoord5.xy);\n"
           "    gl_FragColor = r0*hg_ProgramLocal0;\n"
           "    gl_FragColor = r1*hg_ProgramLocal1 + gl_FragColor;\n"
           "    gl_FragColor = r2*hg_ProgramLocal2 + gl_FragColor;\n"
           "    gl_FragColor = r3*hg_ProgramLocal3 + gl_FragColor;\n"
           "    gl_FragColor = r4*hg_ProgramLocal4 + gl_FragColor;\n"
           "    gl_FragColor = r5*hg_ProgramLocal5 + gl_FragColor;\n"
           "}\n"
           "//MD5=d9f61efd:2bb62bb6:54f027de:b750e4df\n"
           "//SIG=00000000:0000003f:0000003f:00000000:0000:0006:0006:0000:0000:0000:0000:0000:0006:06:0:1:0\n";
  }
}

void HgcRetimeAddBlend6::InitProgramDescriptor(HgcRetimeAddBlend6 *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcRetimeAddBlend6_hgc_visible", "//Metal1.0     \n//LEN=00000002d5\n[[ visible ]] FragmentOut HgcRetimeAddBlend6_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 color1,\n    float4 color2,\n    float4 color3,\n    float4 color4,\n    float4 color5)\n{\n    float4 r0, r1, r2, r3, r4, r5;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1 = color1;\n"
    "    r2 = color2;\n"
    "    r3 = color3;\n"
    "    r4 = color4;\n"
    "    r5 = color5;\n"
    "    output.color0 = r0*hg_Params[0];\n"
    "    output.color0 = r1*hg_Params[1] + output.color0;\n"
    "    output.color0 = r2*hg_Params[2] + output.color0;\n"
    "    output.color0 = r3*hg_Params[3] + output.color0;\n"
    "    output.color0 = r4*hg_Params[4] + output.color0;\n"
    "    output.color0 = r5*hg_Params[5] + output.color0;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcRetimeAddBlend6");
}

void sub_1B7A4D300(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E76910;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  float32x4_t v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7A4D540(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7A4D5A8()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7A4D5A0);
}

void *HgcRetimeAddBlend6::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcRetimeAddBlend6 [hgc1]");
}

uint64_t HgcRetimeAddBlend6::BindTexture(HgcRetimeAddBlend6 *this, HGHandler *a2, int a3)
{
  switch(a3)
  {
    case 0:
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 72))(a2, 0, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      int v4 = a2;
      int v5 = 0;
      goto LABEL_9;
    case 1:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 1, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      int v4 = a2;
      int v5 = 1;
      goto LABEL_9;
    case 2:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 2, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      int v4 = a2;
      int v5 = 2;
      goto LABEL_9;
    case 3:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 3, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      int v4 = a2;
      int v5 = 3;
      goto LABEL_9;
    case 4:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 4, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      int v4 = a2;
      int v5 = 4;
      goto LABEL_9;
    case 5:
      (*(void (**)(HGHandler *, uint64_t, void))(*(void *)a2 + 72))(a2, 5, 0);
      (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
      int v4 = a2;
      int v5 = 5;
LABEL_9:
      HGHandler::TexCoord(v4, v5, 0, 0, 0);
      int v7 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
      uint64_t result = 0;
      if (!v7)
      {
        (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
        uint64_t result = 0;
      }
      break;
    default:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t HgcRetimeAddBlend6::Bind(HgcRetimeAddBlend6 *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcRetimeAddBlend6::RenderTile(HgcRetimeAddBlend6 *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 20);
    uint64_t v7 = *((void *)a2 + 18);
    uint64_t v8 = *((void *)a2 + 16);
    uint64_t v9 = 16 * *((int *)a2 + 38);
    uint64_t v10 = 16 * *((int *)a2 + 34);
    uint64_t v11 = 16 * *((int *)a2 + 30);
    uint64_t v12 = 16 * *((int *)a2 + 26);
    uint64_t v13 = 16 * *((int *)a2 + 22);
    uint64_t v14 = *((void *)a2 + 14);
    uint64_t v15 = *((void *)a2 + 12);
    uint64_t v16 = 16 * *((int *)a2 + 6);
    uint64_t v17 = 16 * *((int *)a2 + 42);
    uint64_t v18 = *((void *)a2 + 10);
    do
    {
      if (v4 < 2)
      {
        unsigned int v31 = 0;
      }
      else
      {
        uint64_t v19 = 0;
        int v20 = 0;
        do
        {
          float32x4_t v21 = (float32x4_t *)*((void *)this + 51);
          float32x4_t v22 = v21[1];
          float32x4_t v23 = v21[2];
          float32x4_t v24 = v21[3];
          float32x4_t v25 = vaddq_f32(vmulq_f32(*(float32x4_t *)(v8 + v19), v24), vaddq_f32(vmulq_f32(*(float32x4_t *)(v14 + v19), v23), vaddq_f32(vmulq_f32(*(float32x4_t *)(v18 + v19), *v21), vmulq_f32(*(float32x4_t *)(v15 + v19), v22))));
          float32x4_t v26 = vaddq_f32(vmulq_f32(*(float32x4_t *)(v8 + v19 + 16), v24), vaddq_f32(vmulq_f32(*(float32x4_t *)(v14 + v19 + 16), v23), vaddq_f32(vmulq_f32(*(float32x4_t *)(v18 + v19 + 16), *v21), vmulq_f32(*(float32x4_t *)(v15 + v19 + 16), v22))));
          float32x4_t v27 = v21[4];
          float32x4_t v28 = v21[5];
          float32x4_t v29 = vaddq_f32(vmulq_f32(*(float32x4_t *)(v6 + v19 + 16), v28), vaddq_f32(vmulq_f32(*(float32x4_t *)(v7 + v19 + 16), v27), v26));
          float32x4_t v30 = (float32x4_t *)(v5 + v19);
          *float32x4_t v30 = vaddq_f32(vmulq_f32(*(float32x4_t *)(v6 + v19), v28), vaddq_f32(vmulq_f32(*(float32x4_t *)(v7 + v19), v27), v25));
          v30[1] = v29;
          v20 -= 2;
          v19 += 32;
        }
        while (v4 + v20 > 1);
        unsigned int v31 = -v20;
      }
      if ((int)v31 < v4)
      {
        uint64_t v32 = (float32x4_t *)*((void *)this + 51);
        *(float32x4_t *)(v5 + 16 * v31) = vaddq_f32(vmulq_f32(*(float32x4_t *)(v6 + 16 * v31), v32[5]), vaddq_f32(vmulq_f32(*(float32x4_t *)(v7 + 16 * v31), v32[4]), vaddq_f32(vmulq_f32(*(float32x4_t *)(v8 + 16 * v31), v32[3]), vaddq_f32(vmulq_f32(*(float32x4_t *)(v14 + 16 * v31), v32[2]), vaddq_f32(vmulq_f32(*(float32x4_t *)(v18 + 16 * v31), *v32), vmulq_f32(*(float32x4_t *)(v15 + 16 * v31), v32[1]))))));
      }
      v18 += v13;
      v15 += v12;
      v14 += v11;
      v8 += v10;
      v7 += v9;
      v6 += v17;
      v5 += v16;
      ++v3;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcRetimeAddBlend6::GetDOD(HgcRetimeAddBlend6 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 6) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcRetimeAddBlend6::GetROI(HgcRetimeAddBlend6 *this, HGRenderer *a2, unsigned int a3, HGRect a4)
{
  if (a3 >= 6) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcRetimeAddBlend6::HgcRetimeAddBlend6(HgcRetimeAddBlend6 *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F1117298;
  operator new();
}

void sub_1B7A4DD74(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcRetimeAddBlend6::~HgcRetimeAddBlend6(HGNode *this)
{
  *(void *)this = &unk_1F1117298;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40565EDBD2);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcRetimeAddBlend6::~HgcRetimeAddBlend6(this);

  HGObject::operator delete(v1);
}

uint64_t HgcRetimeAddBlend6::SetParameter(HgcRetimeAddBlend6 *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 5) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  uint64_t v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  float *v8 = a3;
  uint64_t v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcRetimeAddBlend6::GetParameter(HgcRetimeAddBlend6 *this, unsigned int a2, float *a3)
{
  if (a2 > 5) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcConvolvePass8tap::GetProgram(HgcConvolvePass8tap *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000554\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    half4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy);\n"
             "    r2 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord2.xy);\n"
             "    r3 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord3.xy);\n"
             "    r4 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord4.xy);\n"
             "    r5 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord5.xy);\n"
             "    r6 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord6.xy);\n"
             "    r7 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord7.xy);\n"
             "    r0 = half4(hg_Params[8])*r0;\n"
             "    r0 = half4(hg_Params[9])*r1 + r0;\n"
             "    r0 = half4(hg_Params[10])*r2 + r0;\n"
             "    r0 = half4(hg_Params[11])*r3 + r0;\n"
             "    r0 = half4(hg_Params[12])*r4 + r0;\n"
             "    r0 = half4(hg_Params[13])*r5 + r0;\n"
             "    r0 = half4(hg_Params[14])*r6 + r0;\n"
             "    output.color0 = hg_Params[15]*float4(r7) + float4(r0);\n"
             "    return output;\n"
             "}\n"
             "//MD5=8765b539:97ccd79e:9caee91b:e14d6e48\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0010:0008:0000:0000:0000:01fe:0000:0008:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004d5\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1 = hg_Texture0.sample(hg_Sampler0, frag._texCoord1.xy);\n"
             "    r2 = hg_Texture0.sample(hg_Sampler0, frag._texCoord2.xy);\n"
             "    r3 = hg_Texture0.sample(hg_Sampler0, frag._texCoord3.xy);\n"
             "    r4 = hg_Texture0.sample(hg_Sampler0, frag._texCoord4.xy);\n"
             "    r5 = hg_Texture0.sample(hg_Sampler0, frag._texCoord5.xy);\n"
             "    r6 = hg_Texture0.sample(hg_Sampler0, frag._texCoord6.xy);\n"
             "    r7 = hg_Texture0.sample(hg_Sampler0, frag._texCoord7.xy);\n"
             "    r0 = hg_Params[8]*r0;\n"
             "    r0 = hg_Params[9]*r1 + r0;\n"
             "    r0 = hg_Params[10]*r2 + r0;\n"
             "    r0 = hg_Params[11]*r3 + r0;\n"
             "    r0 = hg_Params[12]*r4 + r0;\n"
             "    r0 = hg_Params[13]*r5 + r0;\n"
             "    r0 = hg_Params[14]*r6 + r0;\n"
             "    output.color0 = hg_Params[15]*r7 + r0;\n"
             "    return output;\n"
             "}\n"
             "//MD5=5c030f28:c308b641:a58af8f8:2afac759\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0010:0008:0000:0000:0000:01fe:0000:0008:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000007b0\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp vec4 hg_ProgramLocal0;\n"
           "uniform defaultp vec4 hg_ProgramLocal1;\n"
           "uniform defaultp vec4 hg_ProgramLocal2;\n"
           "uniform defaultp vec4 hg_ProgramLocal3;\n"
           "uniform defaultp vec4 hg_ProgramLocal4;\n"
           "uniform defaultp vec4 hg_ProgramLocal5;\n"
           "uniform defaultp vec4 hg_ProgramLocal6;\n"
           "uniform defaultp vec4 hg_ProgramLocal7;\n"
           "uniform defaultp vec4 hg_ProgramLocal8;\n"
           "uniform defaultp vec4 hg_ProgramLocal9;\n"
           "uniform defaultp vec4 hg_ProgramLocal10;\n"
           "uniform defaultp vec4 hg_ProgramLocal11;\n"
           "uniform defaultp vec4 hg_ProgramLocal12;\n"
           "uniform defaultp vec4 hg_ProgramLocal13;\n"
           "uniform defaultp vec4 hg_ProgramLocal14;\n"
           "uniform defaultp vec4 hg_ProgramLocal15;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "varying highp vec4 hg_TexCoord2;\n"
           "varying highp vec4 hg_TexCoord3;\n"
           "varying highp vec4 hg_TexCoord4;\n"
           "varying highp vec4 hg_TexCoord5;\n"
           "varying highp vec4 hg_TexCoord6;\n"
           "varying highp vec4 hg_TexCoord7;\n"
           "void main()\n"
           "{\n"
           "    defaultp vec4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1 = texture2D(hg_Texture0, hg_TexCoord1.xy);\n"
           "    r2 = texture2D(hg_Texture0, hg_TexCoord2.xy);\n"
           "    r3 = texture2D(hg_Texture0, hg_TexCoord3.xy);\n"
           "    r4 = texture2D(hg_Texture0, hg_TexCoord4.xy);\n"
           "    r5 = texture2D(hg_Texture0, hg_TexCoord5.xy);\n"
           "    r6 = texture2D(hg_Texture0, hg_TexCoord6.xy);\n"
           "    r7 = texture2D(hg_Texture0, hg_TexCoord7.xy);\n"
           "    r0 = hg_ProgramLocal8*r0;\n"
           "    r0 = hg_ProgramLocal9*r1 + r0;\n"
           "    r0 = hg_ProgramLocal10*r2 + r0;\n"
           "    r0 = hg_ProgramLocal11*r3 + r0;\n"
           "    r0 = hg_ProgramLocal12*r4 + r0;\n"
           "    r0 = hg_ProgramLocal13*r5 + r0;\n"
           "    r0 = hg_ProgramLocal14*r6 + r0;\n"
           "    gl_FragColor = hg_ProgramLocal15*r7 + r0;\n"
           "}\n"
           "//MD5=4a3878a3:975389dc:09d027a2:b42b0281\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0010:0008:0000:0000:0000:0000:0000:0008:01:0:1:0\n";
  }
}

void HgcConvolvePass8tap::InitProgramDescriptor(HgcConvolvePass8tap *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcConvolvePass8tap_hgc_visible", "//Metal1.0     \n//LEN=000000048b\n[[ visible ]] FragmentOut HgcConvolvePass8tap_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0,\n    float4 texCoord1,\n    float4 texCoord2,\n    float4 texCoord3,\n    float4 texCoord4,\n    float4 texCoord5,\n    float4 texCoord6,\n    float4 texCoord7)\n{\n    float4 r0, r1, r2, r3, r4, r5, r6, r7;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = hg_Texture0.sample(hg_Sampler0, texCoord0.xy);\n"
    "    r1 = hg_Texture0.sample(hg_Sampler0, texCoord1.xy);\n"
    "    r2 = hg_Texture0.sample(hg_Sampler0, texCoord2.xy);\n"
    "    r3 = hg_Texture0.sample(hg_Sampler0, texCoord3.xy);\n"
    "    r4 = hg_Texture0.sample(hg_Sampler0, texCoord4.xy);\n"
    "    r5 = hg_Texture0.sample(hg_Sampler0, texCoord5.xy);\n"
    "    r6 = hg_Texture0.sample(hg_Sampler0, texCoord6.xy);\n"
    "    r7 = hg_Texture0.sample(hg_Sampler0, texCoord7.xy);\n"
    "    r0 = hg_Params[8]*r0;\n"
    "    r0 = hg_Params[9]*r1 + r0;\n"
    "    r0 = hg_Params[10]*r2 + r0;\n"
    "    r0 = hg_Params[11]*r3 + r0;\n"
    "    r0 = hg_Params[12]*r4 + r0;\n"
    "    r0 = hg_Params[13]*r5 + r0;\n"
    "    r0 = hg_Params[14]*r6 + r0;\n"
    "    output.color0 = hg_Params[15]*r7 + r0;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcConvolvePass8tap");
}

void sub_1B7A4E004(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E762D0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 9;
  std::string::basic_string[abi:ne180100]<0>(v34, "texture2d<float>");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 6;
  std::string::basic_string[abi:ne180100]<0>(v34, "sampler");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 8;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 8;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 8;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 8;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 8;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 8;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 8;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 8;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  float32x4_t v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7A4E344(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7A4E3CC()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7A4E3C4);
}

void *HgcConvolvePass8tap::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcConvolvePass8tap [hgc1]");
}

uint64_t HgcConvolvePass8tap::BindTexture(float **this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  HGHandler::TexCoord(a2, 0, a3, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, *this[51], this[51][1], 0.0);
  HGHandler::TexCoord(a2, 1, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, this[51][4], this[51][5], 0.0);
  HGHandler::TexCoord(a2, 2, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, this[51][8], this[51][9], 0.0);
  HGHandler::TexCoord(a2, 3, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, this[51][12], this[51][13], 0.0);
  HGHandler::TexCoord(a2, 4, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, this[51][16], this[51][17], 0.0);
  HGHandler::TexCoord(a2, 5, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, this[51][20], this[51][21], 0.0);
  HGHandler::TexCoord(a2, 6, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, this[51][24], this[51][25], 0.0);
  HGHandler::TexCoord(a2, 7, 0, 0, 0);
  if (!(*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46)) {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  (*(void (**)(HGHandler *, double, double, double))(*(void *)a2 + 96))(a2, this[51][28], this[51][29], 0.0);
  return 0;
}

uint64_t HgcConvolvePass8tap::Bind(HgcConvolvePass8tap *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcConvolvePass8tap::RenderTile(float32x4_t **this, HGTile *a2)
{
  uint64_t v4 = HGTile::Renderer(a2);
  int v5 = ((uint64_t (*)(float32x4_t **, uint64_t))(*this)[19].i64[1])(this, v4);
  int32x2_t v6 = *(int32x2_t *)a2;
  int v7 = *((_DWORD *)a2 + 3) - HIDWORD(*(void *)a2);
  if (v7 >= 1)
  {
    int v8 = 0;
    *(float32x2_t *)v9.f32 = vadd_f32(vcvt_f32_s32(v6), (float32x2_t)0x3F0000003F000000);
    v9.i64[1] = 0x3F80000000000000;
    int v10 = *((_DWORD *)a2 + 2) - v6.i32[0];
    uint64_t v11 = this[51];
    float32x4_t v12 = vaddq_f32(v9, v11[7]);
    float32x4_t v13 = vaddq_f32(v9, v11[6]);
    float32x4_t v14 = vaddq_f32(v9, v11[5]);
    float32x4_t v15 = vaddq_f32(v9, v11[4]);
    float32x4_t v16 = vaddq_f32(v9, v11[3]);
    float32x4_t v17 = vaddq_f32(v9, v11[2]);
    float32x4_t v18 = vaddq_f32(v9, v11[1]);
    float32x4_t v19 = vaddq_f32(v9, *v11);
    uint64_t v20 = *((void *)a2 + 2);
    uint64_t v21 = 16 * *((int *)a2 + 6);
    v22.i64[0] = 0x3F0000003F000000;
    v22.i64[1] = 0x3F0000003F000000;
    do
    {
      if (v10 >= 1)
      {
        uint64_t v23 = 0;
        float32x4_t v24 = v19;
        float32x4_t v25 = v18;
        float32x4_t v26 = v17;
        float32x4_t v27 = v16;
        float32x4_t v28 = v15;
        float32x4_t v29 = v14;
        float32x4_t v30 = v13;
        float32x4_t v31 = v12;
        do
        {
          uint64_t v32 = *((int *)a2 + 22);
          float32x4_t v33 = vsubq_f32(v24, v9);
          uint64_t v34 = *((void *)a2 + 10);
          if (v5)
          {
            int32x4_t v35 = vaddq_s32(vcvtq_s32_f32(v33), vcltzq_f32(v33));
            float32x2_t v36 = (float32x2_t)vsubq_f32(v33, vcvtq_f32_s32(v35)).u64[0];
            float32x4_t v37 = (float32x4_t *)(v34 + 16 * (v35.i32[0] + v35.i32[1] * (int)v32));
            float32x4_t v38 = vaddq_f32(*v37, vmulq_n_f32(vsubq_f32(v37[1], *v37), v36.f32[0]));
            float32x4_t v39 = vaddq_f32(v38, vmulq_lane_f32(vsubq_f32(vaddq_f32(v37[v32], vmulq_n_f32(vsubq_f32(v37[(int)v32 + 1], v37[v32]), v36.f32[0])), v38), v36, 1));
            float32x4_t v40 = vsubq_f32(v25, v9);
            int32x4_t v41 = vaddq_s32(vcvtq_s32_f32(v40), vcltzq_f32(v40));
            v40.i64[0] = vsubq_f32(v40, vcvtq_f32_s32(v41)).u64[0];
            int8x16_t v42 = (float32x4_t *)(v34 + 16 * (v41.i32[0] + v41.i32[1] * (int)v32));
            float32x4_t v43 = vaddq_f32(*v42, vmulq_n_f32(vsubq_f32(v42[1], *v42), v40.f32[0]));
            float32x4_t v44 = vaddq_f32(v43, vmulq_lane_f32(vsubq_f32(vaddq_f32(v42[v32], vmulq_n_f32(vsubq_f32(v42[(int)v32 + 1], v42[v32]), v40.f32[0])), v43), *(float32x2_t *)v40.f32, 1));
            float32x4_t v45 = vsubq_f32(v26, v9);
            int32x4_t v46 = vaddq_s32(vcvtq_s32_f32(v45), vcltzq_f32(v45));
            v45.i64[0] = vsubq_f32(v45, vcvtq_f32_s32(v46)).u64[0];
            float32x4_t v47 = (float32x4_t *)(v34 + 16 * (v46.i32[0] + v46.i32[1] * (int)v32));
            float32x4_t v48 = vaddq_f32(*v47, vmulq_n_f32(vsubq_f32(v47[1], *v47), v45.f32[0]));
            float32x4_t v49 = vaddq_f32(v48, vmulq_lane_f32(vsubq_f32(vaddq_f32(v47[v32], vmulq_n_f32(vsubq_f32(v47[(int)v32 + 1], v47[v32]), v45.f32[0])), v48), *(float32x2_t *)v45.f32, 1));
            float32x4_t v50 = vsubq_f32(v27, v9);
            int32x4_t v51 = vaddq_s32(vcvtq_s32_f32(v50), vcltzq_f32(v50));
            v50.i64[0] = vsubq_f32(v50, vcvtq_f32_s32(v51)).u64[0];
            float32x4_t v52 = (float32x4_t *)(v34 + 16 * (v51.i32[0] + v51.i32[1] * (int)v32));
            float32x4_t v53 = vaddq_f32(*v52, vmulq_n_f32(vsubq_f32(v52[1], *v52), v50.f32[0]));
            float32x4_t v54 = vaddq_f32(v53, vmulq_lane_f32(vsubq_f32(vaddq_f32(v52[v32], vmulq_n_f32(vsubq_f32(v52[(int)v32 + 1], v52[v32]), v50.f32[0])), v53), *(float32x2_t *)v50.f32, 1));
            float32x4_t v55 = vsubq_f32(v28, v9);
            int32x4_t v56 = vaddq_s32(vcvtq_s32_f32(v55), vcltzq_f32(v55));
            v55.i64[0] = vsubq_f32(v55, vcvtq_f32_s32(v56)).u64[0];
            int8x16_t v57 = (float32x4_t *)(v34 + 16 * (v56.i32[0] + v56.i32[1] * (int)v32));
            float32x4_t v58 = vaddq_f32(*v57, vmulq_n_f32(vsubq_f32(v57[1], *v57), v55.f32[0]));
            float32x4_t v59 = vaddq_f32(v58, vmulq_lane_f32(vsubq_f32(vaddq_f32(v57[v32], vmulq_n_f32(vsubq_f32(v57[(int)v32 + 1], v57[v32]), v55.f32[0])), v58), *(float32x2_t *)v55.f32, 1));
            float32x4_t v60 = vsubq_f32(v29, v9);
            int32x4_t v61 = vaddq_s32(vcvtq_s32_f32(v60), vcltzq_f32(v60));
            v60.i64[0] = vsubq_f32(v60, vcvtq_f32_s32(v61)).u64[0];
            float32x4_t v62 = (float32x4_t *)(v34 + 16 * (v61.i32[0] + v61.i32[1] * (int)v32));
            float32x4_t v63 = vaddq_f32(*v62, vmulq_n_f32(vsubq_f32(v62[1], *v62), v60.f32[0]));
            float32x4_t v64 = vaddq_f32(v63, vmulq_lane_f32(vsubq_f32(vaddq_f32(v62[v32], vmulq_n_f32(vsubq_f32(v62[(int)v32 + 1], v62[v32]), v60.f32[0])), v63), *(float32x2_t *)v60.f32, 1));
            float32x4_t v65 = vsubq_f32(v30, v9);
            int32x4_t v66 = vaddq_s32(vcvtq_s32_f32(v65), vcltzq_f32(v65));
            v65.i64[0] = vsubq_f32(v65, vcvtq_f32_s32(v66)).u64[0];
            float32x4_t v67 = (float32x4_t *)(v34 + 16 * (v66.i32[0] + v66.i32[1] * (int)v32));
            float32x4_t v68 = vaddq_f32(*v67, vmulq_n_f32(vsubq_f32(v67[1], *v67), v65.f32[0]));
            float32x4_t v69 = vaddq_f32(v68, vmulq_lane_f32(vsubq_f32(vaddq_f32(v67[v32], vmulq_n_f32(vsubq_f32(v67[(int)v32 + 1], v67[v32]), v65.f32[0])), v68), *(float32x2_t *)v65.f32, 1));
            float32x4_t v70 = vsubq_f32(v31, v9);
            int32x4_t v71 = vaddq_s32(vcvtq_s32_f32(v70), vcltzq_f32(v70));
            v70.i64[0] = vsubq_f32(v70, vcvtq_f32_s32(v71)).u64[0];
            __int32 v72 = (float32x4_t *)(v34 + 16 * (v71.i32[0] + v71.i32[1] * (int)v32));
            float32x4_t v73 = vaddq_f32(*v72, vmulq_n_f32(vsubq_f32(v72[1], *v72), v70.f32[0]));
            float32x4_t v74 = vaddq_f32(v73, vmulq_lane_f32(vsubq_f32(vaddq_f32(v72[v32], vmulq_n_f32(vsubq_f32(v72[(int)v32 + 1], v72[v32]), v70.f32[0])), v73), *(float32x2_t *)v70.f32, 1));
          }
          else
          {
            float32x4_t v75 = vaddq_f32(v33, v22);
            int32x4_t v76 = vcvtq_s32_f32(v75);
            v75.i64[0] = vaddq_s32(v76, vcgtq_f32(vcvtq_f32_s32(v76), v75)).u64[0];
            float32x4_t v39 = *(float32x4_t *)(v34 + 16 * (v75.i32[0] + v75.i32[1] * (int)v32));
            float32x4_t v77 = vaddq_f32(vsubq_f32(v25, v9), v22);
            int32x4_t v78 = vcvtq_s32_f32(v77);
            v77.i64[0] = vaddq_s32(v78, vcgtq_f32(vcvtq_f32_s32(v78), v77)).u64[0];
            float32x4_t v44 = *(float32x4_t *)(v34 + 16 * (v77.i32[0] + v77.i32[1] * (int)v32));
            float32x4_t v79 = vaddq_f32(vsubq_f32(v26, v9), v22);
            int32x4_t v80 = vcvtq_s32_f32(v79);
            v79.i64[0] = vaddq_s32(v80, vcgtq_f32(vcvtq_f32_s32(v80), v79)).u64[0];
            float32x4_t v49 = *(float32x4_t *)(v34 + 16 * (v79.i32[0] + v79.i32[1] * (int)v32));
            float32x4_t v81 = vaddq_f32(vsubq_f32(v27, v9), v22);
            int32x4_t v82 = vcvtq_s32_f32(v81);
            v81.i64[0] = vaddq_s32(v82, vcgtq_f32(vcvtq_f32_s32(v82), v81)).u64[0];
            float32x4_t v54 = *(float32x4_t *)(v34 + 16 * (v81.i32[0] + v81.i32[1] * (int)v32));
            float32x4_t v83 = vaddq_f32(vsubq_f32(v28, v9), v22);
            int32x4_t v84 = vcvtq_s32_f32(v83);
            v83.i64[0] = vaddq_s32(v84, vcgtq_f32(vcvtq_f32_s32(v84), v83)).u64[0];
            float32x4_t v59 = *(float32x4_t *)(v34 + 16 * (v83.i32[0] + v83.i32[1] * (int)v32));
            float32x4_t v85 = vaddq_f32(vsubq_f32(v29, v9), v22);
            int32x4_t v86 = vcvtq_s32_f32(v85);
            v85.i64[0] = vaddq_s32(v86, vcgtq_f32(vcvtq_f32_s32(v86), v85)).u64[0];
            float32x4_t v64 = *(float32x4_t *)(v34 + 16 * (v85.i32[0] + v85.i32[1] * (int)v32));
            float32x4_t v87 = vaddq_f32(vsubq_f32(v30, v9), v22);
            int32x4_t v88 = vcvtq_s32_f32(v87);
            v87.i64[0] = vaddq_s32(v88, vcgtq_f32(vcvtq_f32_s32(v88), v87)).u64[0];
            float32x4_t v69 = *(float32x4_t *)(v34 + 16 * (v87.i32[0] + v87.i32[1] * (int)v32));
            float32x4_t v89 = vaddq_f32(vsubq_f32(v31, v9), v22);
            int32x4_t v90 = vcvtq_s32_f32(v89);
            v89.i64[0] = vaddq_s32(v90, vcgtq_f32(vcvtq_f32_s32(v90), v89)).u64[0];
            float32x4_t v74 = *(float32x4_t *)(v34 + 16 * (v89.i32[0] + v89.i32[1] * (int)v32));
          }
          float32x4_t v91 = this[51];
          *(float32x4_t *)(v20 + v23) = vaddq_f32(vmulq_f32(v74, v91[15]), vaddq_f32(vmulq_f32(v69, v91[14]), vaddq_f32(vmulq_f32(v64, v91[13]), vaddq_f32(vmulq_f32(v59, v91[12]), vaddq_f32(vmulq_f32(v54, v91[11]), vaddq_f32(vmulq_f32(v49, v91[10]), vaddq_f32(vmulq_f32(v39, v91[8]), vmulq_f32(v44, v91[9]))))))));
          float32x4_t v24 = vaddq_f32(v24, (float32x4_t)xmmword_1B7E736B0);
          float32x4_t v25 = vaddq_f32(v25, (float32x4_t)xmmword_1B7E736B0);
          float32x4_t v26 = vaddq_f32(v26, (float32x4_t)xmmword_1B7E736B0);
          float32x4_t v27 = vaddq_f32(v27, (float32x4_t)xmmword_1B7E736B0);
          float32x4_t v28 = vaddq_f32(v28, (float32x4_t)xmmword_1B7E736B0);
          float32x4_t v29 = vaddq_f32(v29, (float32x4_t)xmmword_1B7E736B0);
          float32x4_t v30 = vaddq_f32(v30, (float32x4_t)xmmword_1B7E736B0);
          float32x4_t v31 = vaddq_f32(v31, (float32x4_t)xmmword_1B7E736B0);
          v23 += 16;
        }
        while (16 * v10 != v23);
      }
      float32x4_t v19 = vaddq_f32(v19, (float32x4_t)xmmword_1B7E736C0);
      float32x4_t v18 = vaddq_f32(v18, (float32x4_t)xmmword_1B7E736C0);
      float32x4_t v17 = vaddq_f32(v17, (float32x4_t)xmmword_1B7E736C0);
      float32x4_t v16 = vaddq_f32(v16, (float32x4_t)xmmword_1B7E736C0);
      float32x4_t v15 = vaddq_f32(v15, (float32x4_t)xmmword_1B7E736C0);
      float32x4_t v14 = vaddq_f32(v14, (float32x4_t)xmmword_1B7E736C0);
      ++v8;
      float32x4_t v13 = vaddq_f32(v13, (float32x4_t)xmmword_1B7E736C0);
      v20 += v21;
      float32x4_t v12 = vaddq_f32(v12, (float32x4_t)xmmword_1B7E736C0);
    }
    while (v8 != v7);
  }
  return 0;
}

uint64_t HgcConvolvePass8tap::GetDOD(float **this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  uint64_t v5 = *(void *)&a4.var2;
  uint64_t v6 = *(void *)&a4.var0;
  if ((*((int (**)(float **, HGRenderer *))*this + 39))(this, a2) >= 1)
  {
    uint64_t v8 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    LODWORD(v6) = HGRectGrow(v6, v5, v8);
  }
  float v9 = HGRectFloat(v6);
  int v11 = LODWORD(v10);
  float v13 = v12;
  int v15 = LODWORD(v14);
  float v16 = HGRectTranslate(v9, v10, v12, v14, -*this[51]);
  uint64_t v21 = HGRectIntegral(v17, v16, v18, v19, v20);
  uint64_t v23 = HGRectUnion(0, 0, v21, v22);
  uint64_t v25 = v24;
  LODWORD(v26) = v11;
  LODWORD(v27) = v15;
  float v28 = HGRectTranslate(v9, v26, v13, v27, -this[51][4]);
  uint64_t v33 = HGRectIntegral(v29, v28, v30, v31, v32);
  uint64_t v35 = HGRectUnion(v23, v25, v33, v34);
  uint64_t v37 = v36;
  LODWORD(v38) = v11;
  LODWORD(v39) = v15;
  float v40 = HGRectTranslate(v9, v38, v13, v39, -this[51][8]);
  uint64_t v45 = HGRectIntegral(v41, v40, v42, v43, v44);
  uint64_t v47 = HGRectUnion(v35, v37, v45, v46);
  uint64_t v49 = v48;
  LODWORD(v50) = v11;
  LODWORD(v51) = v15;
  float v52 = HGRectTranslate(v9, v50, v13, v51, -this[51][12]);
  uint64_t v57 = HGRectIntegral(v53, v52, v54, v55, v56);
  uint64_t v59 = HGRectUnion(v47, v49, v57, v58);
  uint64_t v61 = v60;
  LODWORD(v62) = v11;
  LODWORD(v63) = v15;
  float v64 = HGRectTranslate(v9, v62, v13, v63, -this[51][16]);
  uint64_t v69 = HGRectIntegral(v65, v64, v66, v67, v68);
  uint64_t v71 = HGRectUnion(v59, v61, v69, v70);
  uint64_t v73 = v72;
  LODWORD(v74) = v11;
  LODWORD(v75) = v15;
  float v76 = HGRectTranslate(v9, v74, v13, v75, -this[51][20]);
  uint64_t v81 = HGRectIntegral(v77, v76, v78, v79, v80);
  uint64_t v83 = HGRectUnion(v71, v73, v81, v82);
  uint64_t v85 = v84;
  LODWORD(v86) = v11;
  LODWORD(v87) = v15;
  float v88 = HGRectTranslate(v9, v86, v13, v87, -this[51][24]);
  uint64_t v93 = HGRectIntegral(v89, v88, v90, v91, v92);
  uint64_t v95 = HGRectUnion(v83, v85, v93, v94);
  uint64_t v97 = v96;
  LODWORD(v98) = v11;
  LODWORD(v99) = v15;
  float v100 = HGRectTranslate(v9, v98, v13, v99, -this[51][28]);
  uint64_t v105 = HGRectIntegral(v101, v100, v102, v103, v104);
  return HGRectUnion(v95, v97, v105, v106);
}

uint64_t HgcConvolvePass8tap::GetROI(float **this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = 0;
  if (!a3)
  {
    float v7 = HGRectFloat(a4.var0);
    int v9 = LODWORD(v8);
    float v11 = v10;
    int v13 = LODWORD(v12);
    float v14 = HGRectTranslate(v7, v8, v10, v12, *this[51]);
    uint64_t v19 = HGRectIntegral(v15, v14, v16, v17, v18);
    uint64_t v21 = HGRectUnion(0, 0, v19, v20);
    uint64_t v23 = v22;
    LODWORD(v24) = v9;
    LODWORD(v25) = v13;
    float v26 = HGRectTranslate(v7, v24, v11, v25, this[51][4]);
    uint64_t v31 = HGRectIntegral(v27, v26, v28, v29, v30);
    uint64_t v33 = HGRectUnion(v21, v23, v31, v32);
    uint64_t v35 = v34;
    LODWORD(v36) = v9;
    LODWORD(v37) = v13;
    float v38 = HGRectTranslate(v7, v36, v11, v37, this[51][8]);
    uint64_t v43 = HGRectIntegral(v39, v38, v40, v41, v42);
    uint64_t v45 = HGRectUnion(v33, v35, v43, v44);
    uint64_t v47 = v46;
    LODWORD(v48) = v9;
    LODWORD(v49) = v13;
    float v50 = HGRectTranslate(v7, v48, v11, v49, this[51][12]);
    uint64_t v55 = HGRectIntegral(v51, v50, v52, v53, v54);
    uint64_t v57 = HGRectUnion(v45, v47, v55, v56);
    uint64_t v59 = v58;
    LODWORD(v60) = v9;
    LODWORD(v61) = v13;
    float v62 = HGRectTranslate(v7, v60, v11, v61, this[51][16]);
    uint64_t v67 = HGRectIntegral(v63, v62, v64, v65, v66);
    uint64_t v69 = HGRectUnion(v57, v59, v67, v68);
    uint64_t v71 = v70;
    LODWORD(v72) = v9;
    LODWORD(v73) = v13;
    float v74 = HGRectTranslate(v7, v72, v11, v73, this[51][20]);
    uint64_t v79 = HGRectIntegral(v75, v74, v76, v77, v78);
    uint64_t v81 = HGRectUnion(v69, v71, v79, v80);
    uint64_t v83 = v82;
    LODWORD(v84) = v9;
    LODWORD(v85) = v13;
    float v86 = HGRectTranslate(v7, v84, v11, v85, this[51][24]);
    uint64_t v91 = HGRectIntegral(v87, v86, v88, v89, v90);
    uint64_t v93 = HGRectUnion(v81, v83, v91, v92);
    uint64_t v95 = v94;
    LODWORD(v96) = v9;
    LODWORD(v97) = v13;
    float v98 = HGRectTranslate(v7, v96, v11, v97, this[51][28]);
    uint64_t v103 = HGRectIntegral(v99, v98, v100, v101, v102);
    uint64_t v4 = HGRectUnion(v93, v95, v103, v104);
    uint64_t v106 = v105;
    if ((*((int (**)(float **, HGRenderer *))*this + 39))(this, a2) >= 1)
    {
      uint64_t v107 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
      return HGRectGrow(v4, v106, v107);
    }
  }
  return v4;
}

void HgcConvolvePass8tap::HgcConvolvePass8tap(HgcConvolvePass8tap *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F1117500;
  operator new();
}

void sub_1B7A4F970(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcConvolvePass8tap::~HgcConvolvePass8tap(HGNode *this)
{
  *(void *)this = &unk_1F1117500;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40104B78CFLL);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcConvolvePass8tap::~HgcConvolvePass8tap(this);

  HGObject::operator delete(v1);
}

uint64_t HgcConvolvePass8tap::SetParameter(HgcConvolvePass8tap *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2 > 0xF) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *((void *)this + 51);
  double v8 = (float *)(v7 + 16 * a2);
  if (*v8 == a3)
  {
    uint64_t v9 = v7 + 16 * a2;
    if (*(float *)(v9 + 4) == a4 && *(float *)(v9 + 8) == a5 && *(float *)(v7 + 16 * a2 + 12) == a6) {
      return 0;
    }
  }
  float *v8 = a3;
  float v10 = (float *)(v7 + 16 * a2);
  v10[1] = a4;
  v10[2] = a5;
  v10[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

uint64_t HgcConvolvePass8tap::GetParameter(HgcConvolvePass8tap *this, unsigned int a2, float *a3)
{
  if (a2 > 0xF) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  uint64_t v5 = (float *)(*((void *)this + 51) + 16 * a2);
  *a3 = *v5;
  a3[1] = v5[1];
  a3[2] = v5[2];
  a3[3] = v5[3];
  return result;
}

const char *HgcSmearToRect::GetProgram(HgcSmearToRect *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002b2\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 s0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.xy = fmin(frag._texCoord0.xy, hg_Params[0].zw);\n"
             "    s0.xy = fmax(s0.xy, hg_Params[0].xy);\n"
             "    s0.xy = s0.xy + hg_Params[1].xy;\n"
             "    s0.xy = s0.xy*hg_Params[1].zw;\n"
             "    output.color0 = (float4) hg_Texture0.sample(hg_Sampler0, s0.xy);\n"
             "    return output;\n"
             "}\n"
             "//MD5=8ddc6cfb:4c51e2d4:1403eabc:4a3636c0\n"
             "//SIG=00400000:00000000:00000000:00000001:0000:0002:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=00000002aa\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    float4 r0;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.xy = fmin(frag._texCoord0.xy, hg_Params[0].zw);\n"
             "    r0.xy = fmax(r0.xy, hg_Params[0].xy);\n"
             "    r0.xy = r0.xy + hg_Params[1].xy;\n"
             "    r0.xy = r0.xy*hg_Params[1].zw;\n"
             "    output.color0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
             "    return output;\n"
             "}\n"
             "//MD5=82ea8f91:772b3f51:4d493828:f90a96ed\n"
             "//SIG=00000000:00000000:00000000:00000000:0000:0002:0001:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000002a1\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    highp vec4 r0;\n"
           "\n"
           "    r0.xy = min(hg_TexCoord0.xy, hg_ProgramLocal0.zw);\n"
           "    r0.xy = max(r0.xy, hg_ProgramLocal0.xy);\n"
           "    r0.xy = r0.xy + hg_ProgramLocal1.xy;\n"
           "    r0.xy = r0.xy*hg_ProgramLocal1.zw;\n"
           "    gl_FragColor = texture2D(hg_Texture0, r0.xy);\n"
           "}\n"
           "//MD5=cbac0ee7:56d75b2c:e8e4fa16:e2cb9d44\n"
           "//SIG=00000000:00000000:00000000:00000000:0000:0002:0001:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcSmearToRect::InitProgramDescriptor(HgcSmearToRect *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcSmearToRect_hgc_visible", "//Metal1.0     \n//LEN=00000001eb\n[[ visible ]] FragmentOut HgcSmearToRect_hgc_visible(const constant float4* hg_Params, \n    texture2d< float > hg_Texture0, \n    sampler hg_Sampler0,\n    float4 texCoord0)\n{\n    float4 r0;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.xy = fmin(texCoord0.xy, hg_Params[0].zw);\n"
    "    r0.xy = fmax(r0.xy, hg_Params[0].xy);\n"
    "    r0.xy = r0.xy + hg_Params[1].xy;\n"
    "    r0.xy = r0.xy*hg_Params[1].zw;\n"
    "    output.color0 = hg_Texture0.sample(hg_Sampler0, r0.xy);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcSmearToRect");
}

void sub_1B7A4FC00(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75630;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 9;
  std::string::basic_string[abi:ne180100]<0>(v34, "texture2d<float>");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 6;
  std::string::basic_string[abi:ne180100]<0>(v34, "sampler");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 8;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  uint64_t v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7A4FD80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7A4FDD0()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7A4FDC8);
}

void *HgcSmearToRect::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcSmearToRect [hgc1]");
}

uint64_t HgcSmearToRect::BindTexture(HgcSmearToRect *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
  {
    v7.n128_u32[0] = 1.0;
    v8.n128_u32[0] = 1.0;
  }
  else
  {
    v7.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
    v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
  }
  v5.n128_f32[0] = (float)*((int *)a2 + 60);
  v6.n128_f32[0] = (float)*((int *)a2 + 61);
  (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 1, v5, v6, v7, v8);
  return 0;
}

uint64_t HgcSmearToRect::Bind(HgcSmearToRect *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcSmearToRect::RenderTile(int8x16_t **this, float32x4_t **a2)
{
  uint64_t v4 = HGTile::Renderer((HGTile *)a2);
  int v5 = ((uint64_t (*)(int8x16_t **, uint64_t))(*this)[19].i64[1])(this, v4);
  int32x2_t v6 = (int32x2_t)*a2;
  int v7 = *((_DWORD *)a2 + 3) - ((unint64_t)*a2 >> 32);
  if (v7 >= 1)
  {
    int v8 = 0;
    *(float32x2_t *)v9.f32 = vadd_f32(vcvt_f32_s32(v6), (float32x2_t)0x3F0000003F000000);
    v9.i64[1] = 0x3F80000000000000;
    int v10 = *((_DWORD *)a2 + 2) - v6.i32[0];
    float v11 = a2[2];
    double v12 = v11 + 2;
    uint64_t v13 = 16 * *((int *)a2 + 6);
    v14.i64[0] = 0x3F0000003F000000;
    v14.i64[1] = 0x3F0000003F000000;
    float32x4_t v15 = v9;
    do
    {
      if (v10 < 4)
      {
        LODWORD(v61) = 0;
        float32x4_t v18 = v15;
      }
      else
      {
        int v16 = 0;
        float v17 = v12;
        float32x4_t v18 = v15;
        do
        {
          float32x4_t v19 = vaddq_f32(v18, (float32x4_t)xmmword_1B7E736B0);
          float32x4_t v20 = vaddq_f32(v19, (float32x4_t)xmmword_1B7E736B0);
          float32x4_t v21 = vaddq_f32(v20, (float32x4_t)xmmword_1B7E736B0);
          int8x16_t v22 = *this[51];
          float32x4_t v23 = (float32x4_t)vextq_s8(v22, v22, 8uLL);
          float32x4_t v24 = vminq_f32(v20, v23);
          float32x4_t v25 = vminq_f32(v21, v23);
          float32x4_t v26 = vmaxq_f32(vminq_f32(v18, v23), (float32x4_t)v22);
          float32x4_t v27 = vmaxq_f32(vminq_f32(v19, v23), (float32x4_t)v22);
          float32x4_t v28 = vmaxq_f32(v24, (float32x4_t)v22);
          float32x4_t v29 = vmaxq_f32(v25, (float32x4_t)v22);
          uint64_t v30 = *((int *)a2 + 22);
          float32x4_t v31 = vsubq_f32(v26, v9);
          uint64_t v32 = a2[10];
          if (v5)
          {
            int32x4_t v33 = vaddq_s32(vcvtq_s32_f32(v31), vcltzq_f32(v31));
            float32x2_t v34 = (float32x2_t)vsubq_f32(v31, vcvtq_f32_s32(v33)).u64[0];
            char v35 = &v32[v33.i32[0] + v33.i32[1] * (int)v30];
            float32x4_t v36 = vaddq_f32(*v35, vmulq_n_f32(vsubq_f32(v35[1], *v35), v34.f32[0]));
            float32x4_t v37 = vaddq_f32(v36, vmulq_lane_f32(vsubq_f32(vaddq_f32(v35[v30], vmulq_n_f32(vsubq_f32(v35[(int)v30 + 1], v35[v30]), v34.f32[0])), v36), v34, 1));
            float32x4_t v38 = vsubq_f32(v27, v9);
            int32x4_t v39 = vaddq_s32(vcvtq_s32_f32(v38), vcltzq_f32(v38));
            v38.i64[0] = vsubq_f32(v38, vcvtq_f32_s32(v39)).u64[0];
            float v40 = &v32[v39.i32[0] + v39.i32[1] * (int)v30];
            float32x4_t v41 = vaddq_f32(*v40, vmulq_n_f32(vsubq_f32(v40[1], *v40), v38.f32[0]));
            float32x4_t v42 = vaddq_f32(v41, vmulq_lane_f32(vsubq_f32(vaddq_f32(v40[v30], vmulq_n_f32(vsubq_f32(v40[(int)v30 + 1], v40[v30]), v38.f32[0])), v41), *(float32x2_t *)v38.f32, 1));
            float32x4_t v43 = vsubq_f32(v28, v9);
            int32x4_t v44 = vaddq_s32(vcvtq_s32_f32(v43), vcltzq_f32(v43));
            v43.i64[0] = vsubq_f32(v43, vcvtq_f32_s32(v44)).u64[0];
            uint64_t v45 = &v32[v44.i32[0] + v44.i32[1] * (int)v30];
            float32x4_t v46 = vaddq_f32(*v45, vmulq_n_f32(vsubq_f32(v45[1], *v45), v43.f32[0]));
            float32x4_t v47 = vaddq_f32(v46, vmulq_lane_f32(vsubq_f32(vaddq_f32(v45[v30], vmulq_n_f32(vsubq_f32(v45[(int)v30 + 1], v45[v30]), v43.f32[0])), v46), *(float32x2_t *)v43.f32, 1));
            float32x4_t v48 = vsubq_f32(v29, v9);
            int32x4_t v49 = vaddq_s32(vcvtq_s32_f32(v48), vcltzq_f32(v48));
            v48.i64[0] = vsubq_f32(v48, vcvtq_f32_s32(v49)).u64[0];
            float v50 = &v32[v49.i32[0] + v49.i32[1] * (int)v30];
            float32x4_t v51 = vaddq_f32(*v50, vmulq_n_f32(vsubq_f32(v50[1], *v50), v48.f32[0]));
            float32x4_t v52 = vaddq_f32(v51, vmulq_lane_f32(vsubq_f32(vaddq_f32(v50[v30], vmulq_n_f32(vsubq_f32(v50[(int)v30 + 1], v50[v30]), v48.f32[0])), v51), *(float32x2_t *)v48.f32, 1));
          }
          else
          {
            float32x4_t v53 = vaddq_f32(v31, v14);
            int32x4_t v54 = vcvtq_s32_f32(v53);
            v53.i64[0] = vaddq_s32(v54, vcgtq_f32(vcvtq_f32_s32(v54), v53)).u64[0];
            float32x4_t v37 = v32[v53.i32[0] + v53.i32[1] * (int)v30];
            float32x4_t v55 = vaddq_f32(vsubq_f32(v27, v9), v14);
            int32x4_t v56 = vcvtq_s32_f32(v55);
            v55.i64[0] = vaddq_s32(v56, vcgtq_f32(vcvtq_f32_s32(v56), v55)).u64[0];
            float32x4_t v42 = v32[v55.i32[0] + v55.i32[1] * (int)v30];
            float32x4_t v57 = vaddq_f32(vsubq_f32(v28, v9), v14);
            int32x4_t v58 = vcvtq_s32_f32(v57);
            v57.i64[0] = vaddq_s32(v58, vcgtq_f32(vcvtq_f32_s32(v58), v57)).u64[0];
            float32x4_t v47 = v32[v57.i32[0] + v57.i32[1] * (int)v30];
            float32x4_t v59 = vaddq_f32(vsubq_f32(v29, v9), v14);
            int32x4_t v60 = vcvtq_s32_f32(v59);
            v59.i64[0] = vaddq_s32(v60, vcgtq_f32(vcvtq_f32_s32(v60), v59)).u64[0];
            float32x4_t v52 = v32[v59.i32[0] + v59.i32[1] * (int)v30];
          }
          v17[-2] = v37;
          v17[-1] = v42;
          *float v17 = v47;
          v17[1] = v52;
          v17 += 4;
          float32x4_t v18 = vaddq_f32(v21, (float32x4_t)xmmword_1B7E736B0);
          v16 -= 4;
        }
        while (v10 + v16 > 3);
        LODWORD(v61) = -v16;
      }
      if ((int)v61 < v10)
      {
        uint64_t v61 = v61;
        do
        {
          uint64_t v62 = *((int *)a2 + 22);
          float32x4_t v63 = vsubq_f32(vmaxq_f32(vminq_f32(v18, (float32x4_t)vextq_s8(*this[51], *this[51], 8uLL)), *(float32x4_t *)this[51]), v9);
          float v64 = a2[10];
          if (v5)
          {
            int32x4_t v65 = vaddq_s32(vcvtq_s32_f32(v63), vcltzq_f32(v63));
            float32x2_t v66 = (float32x2_t)vsubq_f32(v63, vcvtq_f32_s32(v65)).u64[0];
            uint64_t v67 = &v64[v65.i32[0] + v65.i32[1] * (int)v62];
            float32x4_t v68 = vaddq_f32(*v67, vmulq_n_f32(vsubq_f32(v67[1], *v67), v66.f32[0]));
            float32x4_t v69 = vaddq_f32(v68, vmulq_lane_f32(vsubq_f32(vaddq_f32(v67[v62], vmulq_n_f32(vsubq_f32(v67[(int)v62 + 1], v67[v62]), v66.f32[0])), v68), v66, 1));
          }
          else
          {
            float32x4_t v70 = vaddq_f32(v63, v14);
            int32x4_t v71 = vcvtq_s32_f32(v70);
            v70.i64[0] = vaddq_s32(v71, vcgtq_f32(vcvtq_f32_s32(v71), v70)).u64[0];
            float32x4_t v69 = v64[v70.i32[0] + v70.i32[1] * (int)v62];
          }
          v11[v61] = v69;
          float32x4_t v18 = vaddq_f32(v18, (float32x4_t)xmmword_1B7E736B0);
          ++v61;
        }
        while (v61 < v10);
      }
      float32x4_t v15 = vaddq_f32(v15, (float32x4_t)xmmword_1B7E736C0);
      ++v8;
      double v12 = (float32x4_t *)((char *)v12 + v13);
      float v11 = (float32x4_t *)((char *)v11 + v13);
    }
    while (v8 != v7);
  }
  return 0;
}

uint64_t HgcSmearToRect::GetDOD(HgcSmearToRect *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3)
  {
    uint64_t v4 = &HGRectNull;
  }
  else
  {
    uint64_t v5 = *(void *)&a4.var2;
    uint64_t v6 = *(void *)&a4.var0;
    if ((*(int (**)(HgcSmearToRect *, HGRenderer *))(*(void *)this + 312))(this, a2) >= 1)
    {
      uint64_t v7 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
      HGRectGrow(v6, v5, v7);
    }
    uint64_t v4 = &HGRectInfinite;
  }
  return *(void *)v4;
}

uint64_t HgcSmearToRect::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  Input = HGRenderer::GetInput(a2, this, 0);
  uint64_t DOD = HGRenderer::GetDOD(a2, Input);
  uint64_t v9 = v8;
  if ((*(int (**)(HGNode *, HGRenderer *))(*(void *)this + 312))(this, a2) >= 1)
  {
    uint64_t v10 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
    return HGRectGrow(DOD, v9, v10);
  }
  return DOD;
}

void HgcSmearToRect::HgcSmearToRect(HgcSmearToRect *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F1117768;
  operator new();
}

void sub_1B7A505D0(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcSmearToRect::~HgcSmearToRect(HGNode *this)
{
  *(void *)this = &unk_1F1117768;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40451B5BE8);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcSmearToRect::~HgcSmearToRect(this);

  HGObject::operator delete(v1);
}

uint64_t HgcSmearToRect::SetParameter(HgcSmearToRect *this, uint64_t a2, float a3, float a4, float a5, float a6, char *a7)
{
  if (a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = (float *)*((void *)this + 51);
  if (*v8 == a3 && v8[1] == a4 && v8[2] == a5 && v8[3] == a6) {
    return 0;
  }
  float *v8 = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = a6;
  HGNode::ClearBits((HGNode *)this, a2, a7);
  return 1;
}

float HgcSmearToRect::GetParameter(HgcSmearToRect *this, int a2, float *a3)
{
  if (!a2)
  {
    int v3 = (float *)*((void *)this + 51);
    *a3 = *v3;
    a3[1] = v3[1];
    a3[2] = v3[2];
    float result = v3[3];
    a3[3] = result;
  }
  return result;
}

const char *HgcSimpleBorder::GetProgram(HgcSimpleBorder *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000004bf\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    half4 r0;\n"
             "    float4 s0, s1;\n"
             "    FragmentOut output;\n"
             "\n"
             "    s0.z = dot(frag._texCoord1, hg_Params[5]);\n"
             "    s0.z = 1.00000f / s0.z;\n"
             "    s0.x = dot(frag._texCoord1, hg_Params[3]);\n"
             "    s0.y = dot(frag._texCoord1, hg_Params[4]);\n"
             "    s0.xy = s0.xz*s0.zy;\n"
             "    s0 = s0.xyxy - hg_Params[1];\n"
             "    s0.xy = -s0.xy;\n"
             "    s1 = s0 + float4(c0.xxxx);\n"
             "    s1.xy = fmin(s1.xy, s1.zw);\n"
             "    s0 = s0 - hg_Params[0];\n"
             "    s1.x = clamp(fmin(s1.x, s1.y), 0.00000f, 1.00000f);\n"
             "    s0 = s0 + float4(c0.xxxx);\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    s0.xy = fmin(s0.xy, s0.zw);\n"
             "    s0.x = clamp(fmin(s0.x, s0.y), 0.00000f, 1.00000f);\n"
             "    s0 = mix(hg_Params[2], float4(r0), s0.xxxx);\n"
             "    output.color0 = s0*s1.xxxx;\n"
             "    return output;\n"
             "}\n"
             "//MD5=dd1f3d2a:b4ccf73d:99838ad2:b16e7208\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0006:0003:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000498\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0.z = dot(frag._texCoord1, hg_Params[5]);\n"
             "    r0.z = 1.00000f / r0.z;\n"
             "    r0.x = dot(frag._texCoord1, hg_Params[3]);\n"
             "    r0.y = dot(frag._texCoord1, hg_Params[4]);\n"
             "    r0.xy = r0.xz*r0.zy;\n"
             "    r0 = r0.xyxy - hg_Params[1];\n"
             "    r0.xy = -r0.xy;\n"
             "    r1 = r0 + c0.xxxx;\n"
             "    r1.xy = fmin(r1.xy, r1.zw);\n"
             "    r0 = r0 - hg_Params[0];\n"
             "    r1.x = clamp(fmin(r1.x, r1.y), 0.00000f, 1.00000f);\n"
             "    r0 = r0 + c0.xxxx;\n"
             "    r2 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r0.xy = fmin(r0.xy, r0.zw);\n"
             "    r0.x = clamp(fmin(r0.x, r0.y), 0.00000f, 1.00000f);\n"
             "    r2 = mix(hg_Params[2], r2, r0.xxxx);\n"
             "    output.color0 = r2*r1.xxxx;\n"
             "    return output;\n"
             "}\n"
             "//MD5=eaf374c3:9d3d91f5:dd3ad5d7:06edf1a2\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0006:0003:0000:0000:0000:0006:0000:0002:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000053e\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform highp vec4 hg_ProgramLocal0;\n"
           "uniform highp vec4 hg_ProgramLocal1;\n"
           "uniform highp vec4 hg_ProgramLocal2;\n"
           "uniform highp vec4 hg_ProgramLocal3;\n"
           "uniform highp vec4 hg_ProgramLocal4;\n"
           "uniform highp vec4 hg_ProgramLocal5;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "varying highp vec4 hg_TexCoord1;\n"
           "void main()\n"
           "{\n"
           "    const highp vec4 c0 = vec4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
           "    highp vec4 r0, r1, r2;\n"
           "\n"
           "    r0.z = dot(hg_TexCoord1, hg_ProgramLocal5);\n"
           "    r0.z = 1.00000 / r0.z;\n"
           "    r0.x = dot(hg_TexCoord1, hg_ProgramLocal3);\n"
           "    r0.y = dot(hg_TexCoord1, hg_ProgramLocal4);\n"
           "    r0.xy = r0.xz*r0.zy;\n"
           "    r0 = r0.xyxy - hg_ProgramLocal1;\n"
           "    r0.xy = -r0.xy;\n"
           "    r1 = r0 + c0.xxxx;\n"
           "    r1.xy = min(r1.xy, r1.zw);\n"
           "    r0 = r0 - hg_ProgramLocal0;\n"
           "    r1.x = clamp(min(r1.x, r1.y), 0.00000, 1.00000);\n"
           "    r0 = r0 + c0.xxxx;\n"
           "    r2 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r0.xy = min(r0.xy, r0.zw);\n"
           "    r0.x = clamp(min(r0.x, r0.y), 0.00000, 1.00000);\n"
           "    r2 = mix(hg_ProgramLocal2, r2, r0.xxxx);\n"
           "    gl_FragColor = r2*r1.xxxx;\n"
           "}\n"
           "//MD5=8714e1a3:0379e8a0:fa930950:6b08f775\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0006:0003:0000:0000:0000:0000:0000:0002:01:0:1:0\n";
  }
}

void HgcSimpleBorder::InitProgramDescriptor(HgcSimpleBorder *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcSimpleBorder_hgc_visible", "//Metal1.0     \n//LEN=0000000375\n[[ visible ]] FragmentOut HgcSimpleBorder_hgc_visible(const constant float4* hg_Params,\n    float4 color0,\n    float4 texCoord1)\n{\n    const float4 c0 = float4(0.5000000000, 0.000000000, 0.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0.z = dot(texCoord1, hg_Params[5]);\n"
    "    r0.z = 1.00000f / r0.z;\n"
    "    r0.x = dot(texCoord1, hg_Params[3]);\n"
    "    r0.y = dot(texCoord1, hg_Params[4]);\n"
    "    r0.xy = r0.xz*r0.zy;\n"
    "    r0 = r0.xyxy - hg_Params[1];\n"
    "    r0.xy = -r0.xy;\n"
    "    r1 = r0 + c0.xxxx;\n"
    "    r1.xy = fmin(r1.xy, r1.zw);\n"
    "    r0 = r0 - hg_Params[0];\n"
    "    r1.x = clamp(fmin(r1.x, r1.y), 0.00000f, 1.00000f);\n"
    "    r0 = r0 + c0.xxxx;\n"
    "    r2 = color0;\n"
    "    r0.xy = fmin(r0.xy, r0.zw);\n"
    "    r0.x = clamp(fmin(r0.x, r0.y), 0.00000f, 1.00000f);\n"
    "    r2 = mix(hg_Params[2], r2, r0.xxxx);\n"
    "    output.color0 = r2*r1.xxxx;\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcSimpleBorder");
}

void sub_1B7A5083C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E76910;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 8;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  int32x4_t v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7A5097C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7A509C4()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7A509BCLL);
}

void *HgcSimpleBorder::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcSimpleBorder [hgc1]");
}

uint64_t HgcSimpleBorder::BindTexture(HgcSimpleBorder *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcSimpleBorder::Bind(HgcSimpleBorder *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcSimpleBorder::RenderTile(HgcSimpleBorder *this, int32x2_t *a2)
{
  int32x2_t v2 = *a2;
  int v3 = a2[1].i32[1] - HIDWORD(*(unint64_t *)a2);
  if (v3 >= 1)
  {
    int v4 = 0;
    int v5 = a2[1].i32[0] - v2.i32[0];
    int32x2_t v6 = a2[2];
    int32x2_t v7 = a2[10];
    *(float32x2_t *)v8.f32 = vadd_f32(vcvt_f32_s32(v2), (float32x2_t)0x3F0000003F000000);
    v8.i64[1] = 0x3F80000000000000;
    uint64_t v9 = 16 * a2[3].i32[0];
    uint64_t v10 = 16 * a2[11].i32[0];
    do
    {
      if (v5 < 3)
      {
        LODWORD(v87) = 0;
        float32x4_t v13 = v8;
      }
      else
      {
        uint64_t v11 = 0;
        int v12 = 0;
        float32x4_t v13 = v8;
        do
        {
          float32x4_t v14 = vaddq_f32(v13, (float32x4_t)xmmword_1B7E736B0);
          float32x4_t v15 = vaddq_f32(v14, (float32x4_t)xmmword_1B7E736B0);
          uint64_t v16 = *((void *)this + 51);
          float32x4_t v18 = *(float32x4_t *)(v16 + 64);
          float32x4_t v17 = *(float32x4_t *)(v16 + 80);
          float32x4_t v19 = vmulq_f32(v13, v17);
          float32x4_t v20 = vmulq_f32(v14, v17);
          float32x4_t v21 = vmulq_f32(v15, v17);
          float32x4_t v22 = vaddq_f32(v19, (float32x4_t)vextq_s8((int8x16_t)v19, (int8x16_t)v19, 4uLL));
          float32x4_t v23 = vaddq_f32(v20, (float32x4_t)vextq_s8((int8x16_t)v20, (int8x16_t)v20, 4uLL));
          float32x4_t v24 = vaddq_f32(v21, (float32x4_t)vextq_s8((int8x16_t)v21, (int8x16_t)v21, 4uLL));
          float32x4_t v25 = vaddq_f32(v22, (float32x4_t)vextq_s8((int8x16_t)v22, (int8x16_t)v22, 8uLL));
          float32x4_t v26 = vaddq_f32(v23, (float32x4_t)vextq_s8((int8x16_t)v23, (int8x16_t)v23, 8uLL));
          float32x4_t v27 = vaddq_f32(v24, (float32x4_t)vextq_s8((int8x16_t)v24, (int8x16_t)v24, 8uLL));
          float32x4_t v28 = *(float32x4_t *)(v16 + 96);
          float32x4_t v29 = *(float32x4_t *)(v16 + 112);
          float32x4_t v30 = vminq_f32(vmaxq_f32(vrecpeq_f32(v25), v28), v29);
          float32x4_t v31 = vminq_f32(vmaxq_f32(vrecpeq_f32(v26), v28), v29);
          float32x4_t v32 = vminq_f32(vmaxq_f32(vrecpeq_f32(v27), v28), v29);
          float32x4_t v33 = vmaxq_f32(vmulq_f32(v32, vrecpsq_f32(v27, v32)), v28);
          float32x4_t v34 = vminq_f32(vmaxq_f32(vmulq_f32(v30, vrecpsq_f32(v25, v30)), v28), v29);
          float32x4_t v35 = vminq_f32(vmaxq_f32(vmulq_f32(v31, vrecpsq_f32(v26, v31)), v28), v29);
          float32x4_t v36 = vminq_f32(v33, v29);
          float32x4_t v37 = vrecpsq_f32(v25, v34);
          float32x4_t v38 = vrecpsq_f32(v27, v36);
          float32x4_t v40 = *(float32x4_t *)(v16 + 32);
          float32x4_t v39 = *(float32x4_t *)(v16 + 48);
          float32x4_t v41 = vmulq_f32(v13, v39);
          float32x4_t v42 = vmulq_f32(v14, v39);
          float32x4_t v43 = vmulq_f32(v15, v39);
          float32x4_t v44 = vmulq_f32(v34, v37);
          float32x4_t v45 = vaddq_f32(v41, (float32x4_t)vextq_s8((int8x16_t)v41, (int8x16_t)v41, 4uLL));
          float32x4_t v46 = vaddq_f32(v42, (float32x4_t)vextq_s8((int8x16_t)v42, (int8x16_t)v42, 4uLL));
          float32x4_t v47 = vmulq_f32(v35, vrecpsq_f32(v26, v35));
          float32x4_t v48 = vaddq_f32(v43, (float32x4_t)vextq_s8((int8x16_t)v43, (int8x16_t)v43, 4uLL));
          float32x4_t v49 = vmulq_f32(v36, v38);
          v45.i64[0] = vaddq_f32(v45, (float32x4_t)vdupq_laneq_s64((int64x2_t)v45, 1)).u64[0];
          v43.i64[0] = vaddq_f32(v46, (float32x4_t)vdupq_laneq_s64((int64x2_t)v46, 1)).u64[0];
          v45.i64[1] = v44.i64[1];
          v38.i64[0] = vaddq_f32(v48, (float32x4_t)vdupq_laneq_s64((int64x2_t)v48, 1)).u64[0];
          float32x4_t v50 = vmulq_f32(v13, v18);
          float32x4_t v51 = vmulq_f32(v14, v18);
          float32x4_t v52 = vmulq_f32(v15, v18);
          v43.i64[1] = v47.i64[1];
          float32x4_t v53 = vaddq_f32(v50, (float32x4_t)vextq_s8((int8x16_t)v50, (int8x16_t)v50, 4uLL));
          v38.i64[1] = v49.i64[1];
          float32x4_t v54 = vaddq_f32(v51, (float32x4_t)vextq_s8((int8x16_t)v51, (int8x16_t)v51, 4uLL));
          float32x4_t v55 = vaddq_f32(v52, (float32x4_t)vextq_s8((int8x16_t)v52, (int8x16_t)v52, 4uLL));
          int8x16_t v56 = *(int8x16_t *)(v16 + 128);
          long long v57 = *(_OWORD *)(v16 + 144);
          float32x4_t v58 = (float32x4_t)vbslq_s8(v56, (int8x16_t)vaddq_f32(v53, (float32x4_t)vextq_s8((int8x16_t)v53, (int8x16_t)v53, 8uLL)), (int8x16_t)v45);
          float32x4_t v59 = (float32x4_t)vbslq_s8(v56, (int8x16_t)vaddq_f32(v54, (float32x4_t)vextq_s8((int8x16_t)v54, (int8x16_t)v54, 8uLL)), (int8x16_t)v43);
          float32x4_t v60 = (float32x4_t)vbslq_s8(v56, (int8x16_t)vaddq_f32(v55, (float32x4_t)vextq_s8((int8x16_t)v55, (int8x16_t)v55, 8uLL)), (int8x16_t)v38);
          long long v61 = *(_OWORD *)(v16 + 160);
          float32x4_t v62 = *(float32x4_t *)(v16 + 176);
          *(float32x2_t *)v58.f32 = vmul_f32((float32x2_t)vqtbl1_s8((int8x16_t)v58, *(int8x8_t *)&v57), (float32x2_t)vqtbl1_s8((int8x16_t)v58, *(int8x8_t *)&v61));
          *(float32x2_t *)v59.f32 = vmul_f32((float32x2_t)vqtbl1_s8((int8x16_t)v59, *(int8x8_t *)&v57), (float32x2_t)vqtbl1_s8((int8x16_t)v59, *(int8x8_t *)&v61));
          *(float32x2_t *)v60.f32 = vmul_f32((float32x2_t)vqtbl1_s8((int8x16_t)v60, *(int8x8_t *)&v57), (float32x2_t)vqtbl1_s8((int8x16_t)v60, *(int8x8_t *)&v61));
          v58.i64[1] = v58.i64[0];
          v59.i64[1] = v59.i64[0];
          v60.i64[1] = v60.i64[0];
          float32x4_t v63 = *(float32x4_t *)(v16 + 16);
          float32x4_t v64 = vsubq_f32(v58, v63);
          int8x16_t v65 = (int8x16_t)vsubq_f32(v59, v63);
          int8x16_t v66 = (int8x16_t)vsubq_f32(v60, v63);
          *(float32x2_t *)v63.f32 = vneg_f32(*(float32x2_t *)v64.f32);
          *(float32x2_t *)v38.f32 = vneg_f32(*(float32x2_t *)v65.i8);
          v63.i64[1] = vextq_s8((int8x16_t)v64, (int8x16_t)v64, 8uLL).u64[0];
          v38.i64[1] = vextq_s8(v65, v65, 8uLL).u64[0];
          *(float32x2_t *)v64.f32 = vneg_f32(*(float32x2_t *)v66.i8);
          v64.i64[1] = vextq_s8(v66, v66, 8uLL).u64[0];
          float32x4_t v67 = vaddq_f32(v62, v63);
          float32x4_t v68 = vaddq_f32(v62, v38);
          float32x4_t v69 = vaddq_f32(v62, v64);
          float32x4_t v70 = vminq_f32(v67, (float32x4_t)vextq_s8((int8x16_t)v67, (int8x16_t)v67, 8uLL));
          float32x4_t v71 = vminq_f32(v68, (float32x4_t)vextq_s8((int8x16_t)v68, (int8x16_t)v68, 8uLL));
          float32x4_t v72 = vminq_f32(v69, (float32x4_t)vextq_s8((int8x16_t)v69, (int8x16_t)v69, 8uLL));
          float32x4_t v73 = vminq_f32(v72, (float32x4_t)vrev64q_s32((int32x4_t)v72));
          float32x4_t v74 = *(float32x4_t *)(v16 + 192);
          float32x4_t v75 = vaddq_f32(v62, vsubq_f32(v63, *(float32x4_t *)v16));
          float32x4_t v76 = vaddq_f32(v62, vsubq_f32(v38, *(float32x4_t *)v16));
          float32x4_t v77 = vaddq_f32(v62, vsubq_f32(v64, *(float32x4_t *)v16));
          float32x4_t v78 = vmaxq_f32(v73, v28);
          float32x4_t v79 = vminq_f32(v75, (float32x4_t)vextq_s8((int8x16_t)v75, (int8x16_t)v75, 8uLL));
          float32x4_t v80 = vminq_f32(v76, (float32x4_t)vextq_s8((int8x16_t)v76, (int8x16_t)v76, 8uLL));
          float32x4_t v81 = vminq_f32(v77, (float32x4_t)vextq_s8((int8x16_t)v77, (int8x16_t)v77, 8uLL));
          float32x4_t v82 = vmaxq_f32(vminq_f32(v81, (float32x4_t)vrev64q_s32((int32x4_t)v81)), v28);
          float32x4_t v83 = vmulq_n_f32(vaddq_f32(v40, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(*(void *)&v7 + v11), v40), vminq_f32(vmaxq_f32(vminq_f32(v79, (float32x4_t)vrev64q_s32((int32x4_t)v79)), v28), v74).f32[0])), vminq_f32(vmaxq_f32(vminq_f32(v70, (float32x4_t)vrev64q_s32((int32x4_t)v70)), v28), v74).f32[0]);
          float32x4_t v84 = vmulq_n_f32(vaddq_f32(v40, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(*(void *)&v7 + v11 + 16), v40), vminq_f32(vmaxq_f32(vminq_f32(v80, (float32x4_t)vrev64q_s32((int32x4_t)v80)), v28), v74).f32[0])), vminq_f32(vmaxq_f32(vminq_f32(v71, (float32x4_t)vrev64q_s32((int32x4_t)v71)), v28), v74).f32[0]);
          float32x4_t v85 = vmulq_n_f32(vaddq_f32(v40, vmulq_n_f32(vsubq_f32(*(float32x4_t *)(*(void *)&v7 + v11 + 32), v40), vminq_f32(v82, v74).f32[0])), vminq_f32(v78, v74).f32[0]);
          float v86 = (float32x4_t *)(*(void *)&v6 + v11);
          *float v86 = v83;
          v86[1] = v84;
          v86[2] = v85;
          float32x4_t v13 = vaddq_f32(v15, (float32x4_t)xmmword_1B7E736B0);
          v12 -= 3;
          v11 += 48;
        }
        while (v5 + v12 > 2);
        LODWORD(v87) = -v12;
      }
      if ((int)v87 < v5)
      {
        uint64_t v87 = v87;
        do
        {
          uint64_t v88 = *((void *)this + 51);
          float32x4_t v89 = vmulq_f32(v13, *(float32x4_t *)(v88 + 80));
          float32x4_t v90 = vaddq_f32(v89, (float32x4_t)vextq_s8((int8x16_t)v89, (int8x16_t)v89, 4uLL));
          float32x4_t v91 = vaddq_f32(v90, (float32x4_t)vextq_s8((int8x16_t)v90, (int8x16_t)v90, 8uLL));
          float32x4_t v92 = *(float32x4_t *)(v88 + 96);
          float32x4_t v93 = *(float32x4_t *)(v88 + 112);
          float32x4_t v94 = vminq_f32(vmaxq_f32(vrecpeq_f32(v91), v92), v93);
          float32x4_t v95 = vminq_f32(vmaxq_f32(vmulq_f32(v94, vrecpsq_f32(v91, v94)), v92), v93);
          float32x4_t v96 = vmulq_f32(v13, *(float32x4_t *)(v88 + 48));
          float32x4_t v97 = vaddq_f32(v96, (float32x4_t)vextq_s8((int8x16_t)v96, (int8x16_t)v96, 4uLL));
          float32x4_t v98 = vmulq_f32(v95, vrecpsq_f32(v91, v95));
          v95.i64[0] = vaddq_f32(v97, (float32x4_t)vdupq_laneq_s64((int64x2_t)v97, 1)).u64[0];
          float32x4_t v99 = vmulq_f32(v13, *(float32x4_t *)(v88 + 64));
          v95.i64[1] = v98.i64[1];
          float32x4_t v100 = vaddq_f32(v99, (float32x4_t)vextq_s8((int8x16_t)v99, (int8x16_t)v99, 4uLL));
          float32x4_t v101 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v88 + 128), (int8x16_t)vaddq_f32(v100, (float32x4_t)vextq_s8((int8x16_t)v100, (int8x16_t)v100, 8uLL)), (int8x16_t)v95);
          float32x4_t v102 = *(float32x4_t *)(v88 + 176);
          *(float32x2_t *)v101.f32 = vmul_f32((float32x2_t)vqtbl1_s8((int8x16_t)v101, *(int8x8_t *)(v88 + 144)), (float32x2_t)vqtbl1_s8((int8x16_t)v101, *(int8x8_t *)(v88 + 160)));
          v101.i64[1] = v101.i64[0];
          int8x16_t v103 = (int8x16_t)vsubq_f32(v101, *(float32x4_t *)(v88 + 16));
          *(float32x2_t *)v99.f32 = vneg_f32(*(float32x2_t *)v103.i8);
          v99.i64[1] = vextq_s8(v103, v103, 8uLL).u64[0];
          float32x4_t v104 = vaddq_f32(v102, v99);
          float32x4_t v105 = vminq_f32(v104, (float32x4_t)vextq_s8((int8x16_t)v104, (int8x16_t)v104, 8uLL));
          float32x4_t v106 = vaddq_f32(v102, vsubq_f32(v99, *(float32x4_t *)v88));
          float32x4_t v107 = vminq_f32(v106, (float32x4_t)vextq_s8((int8x16_t)v106, (int8x16_t)v106, 8uLL));
          *(float32x4_t *)(*(void *)&v6 + 16 * v87) = vmulq_n_f32(vaddq_f32(*(float32x4_t *)(v88 + 32), vmulq_n_f32(vsubq_f32(*(float32x4_t *)(*(void *)&v7 + 16 * v87), *(float32x4_t *)(v88 + 32)), vminq_f32(vmaxq_f32(vminq_f32(v107, (float32x4_t)vrev64q_s32((int32x4_t)v107)), v92), *(float32x4_t *)(v88 + 192)).f32[0])), vminq_f32(vmaxq_f32(vminq_f32(v105, (float32x4_t)vrev64q_s32((int32x4_t)v105)), v92), *(float32x4_t *)(v88 + 192)).f32[0]);
          float32x4_t v13 = vaddq_f32(v13, (float32x4_t)xmmword_1B7E736B0);
          ++v87;
        }
        while (v87 < v5);
      }
      float32x4_t v8 = vaddq_f32(v8, (float32x4_t)xmmword_1B7E736C0);
      ++v4;
      *(void *)&v6 += v9;
      *(void *)&v7 += v10;
    }
    while (v4 != v3);
  }
  return 0;
}

uint64_t HgcSimpleBorder::GetDOD(HgcSimpleBorder *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcSimpleBorder::GetROI(HgcSimpleBorder *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcSimpleBorder::HgcSimpleBorder(HgcSimpleBorder *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F11179D0;
  operator new();
}

void sub_1B7A51244(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcSimpleBorder::~HgcSimpleBorder(HGNode *this)
{
  *(void *)this = &unk_1F11179D0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40104B78CFLL);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcSimpleBorder::~HgcSimpleBorder(this);

  HGObject::operator delete(v1);
}

uint64_t HgcSimpleBorder::SetParameter(HgcSimpleBorder *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  switch((int)a2)
  {
    case 0:
      int32x2_t v7 = (__n128 *)*((void *)this + 51);
      if (v7->n128_f32[0] == a3.n128_f32[0]
        && v7->n128_f32[1] == a4
        && v7->n128_f32[2] == a3.n128_f32[0]
        && v7->n128_f32[3] == a4)
      {
        return 0;
      }
      v7->n128_u32[0] = a3.n128_u32[0];
      v7->n128_f32[1] = a4;
      v7->n128_u32[2] = a3.n128_u32[0];
      v7->n128_f32[3] = a4;
      a3.n128_f32[1] = a4;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      v7[13] = a3;
      goto LABEL_34;
    case 1:
      uint64_t v9 = (__n128 *)*((void *)this + 51);
      if (v9[1].n128_f32[0] == a5
        && v9[1].n128_f32[1] == a6
        && v9[1].n128_f32[2] == a3.n128_f32[0]
        && v9[1].n128_f32[3] == a4)
      {
        return 0;
      }
      v9[1].n128_f32[0] = a5;
      v9[1].n128_f32[1] = a6;
      v9[1].n128_u32[2] = a3.n128_u32[0];
      v9[1].n128_f32[3] = a4;
      a3.n128_f32[1] = a4;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      v9[14] = a3;
      goto LABEL_34;
    case 2:
      uint64_t v10 = (float *)*((void *)this + 51);
      if (v10[8] == a3.n128_f32[0] && v10[9] == a4 && v10[10] == a5 && v10[11] == a6) {
        return 0;
      }
      v10[8] = a3.n128_f32[0];
      v10[9] = a4;
      v10[10] = a5;
      v10[11] = a6;
      goto LABEL_34;
    case 3:
      uint64_t v11 = (float *)*((void *)this + 51);
      if (v11[12] == a3.n128_f32[0] && v11[13] == a4 && v11[14] == a5 && v11[15] == a6) {
        return 0;
      }
      v11[12] = a3.n128_f32[0];
      v11[13] = a4;
      v11[14] = a5;
      v11[15] = a6;
      goto LABEL_34;
    case 4:
      int v12 = (float *)*((void *)this + 51);
      if (v12[16] == a3.n128_f32[0] && v12[17] == a4 && v12[18] == a5 && v12[19] == a6) {
        return 0;
      }
      v12[16] = a3.n128_f32[0];
      v12[17] = a4;
      v12[18] = a5;
      v12[19] = a6;
      goto LABEL_34;
    case 5:
      uint64_t v8 = 0;
      a3.n128_f32[1] = a4;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      *(__n128 *)(*((void *)this + 51) + 240) = a3;
      return v8;
    case 6:
      float32x4_t v13 = (float *)*((void *)this + 51);
      if (v13[20] == a3.n128_f32[0] && v13[21] == a4 && v13[22] == a5 && v13[23] == a6) {
        return 0;
      }
      v13[20] = a3.n128_f32[0];
      v13[21] = a4;
      v13[22] = a5;
      v13[23] = a6;
LABEL_34:
      HGNode::ClearBits((HGNode *)this, a2, a7);
      return 1;
    default:
      return 0xFFFFFFFFLL;
  }
}

float HgcSimpleBorder::GetParameter(HgcSimpleBorder *this, int a2, float *a3)
{
  switch(a2)
  {
    case 0:
      int v3 = (float *)*((void *)this + 51);
      *a3 = v3[52];
      a3[1] = v3[53];
      a3[2] = v3[54];
      int v4 = v3 + 55;
      goto LABEL_9;
    case 1:
      int v5 = (float *)*((void *)this + 51);
      *a3 = v5[56];
      a3[1] = v5[57];
      a3[2] = v5[58];
      int v4 = v5 + 59;
      goto LABEL_9;
    case 2:
      int32x2_t v6 = (float *)*((void *)this + 51);
      *a3 = v6[8];
      a3[1] = v6[9];
      a3[2] = v6[10];
      int v4 = v6 + 11;
      goto LABEL_9;
    case 3:
      int32x2_t v7 = (float *)*((void *)this + 51);
      *a3 = v7[12];
      a3[1] = v7[13];
      a3[2] = v7[14];
      int v4 = v7 + 15;
      goto LABEL_9;
    case 4:
      uint64_t v8 = (float *)*((void *)this + 51);
      *a3 = v8[16];
      a3[1] = v8[17];
      a3[2] = v8[18];
      int v4 = v8 + 19;
      goto LABEL_9;
    case 5:
      uint64_t v9 = (float *)*((void *)this + 51);
      *a3 = v9[60];
      a3[1] = v9[61];
      a3[2] = v9[62];
      int v4 = v9 + 63;
      goto LABEL_9;
    case 6:
      uint64_t v10 = (float *)*((void *)this + 51);
      *a3 = v10[20];
      a3[1] = v10[21];
      a3[2] = v10[22];
      int v4 = v10 + 23;
LABEL_9:
      float result = *v4;
      a3[3] = *v4;
      break;
    default:
      return result;
  }
  return result;
}

const char *HgcContrastBezierLuma::GetProgram(HgcContrastBezierLuma *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000875\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.2989999950, 0.5870000124, 0.1140000001, 1023.000000);\n"
             "    const half4 c1 = half4(0.5000000000, 0.000000000, 1.000000000, 0.000000000);\n"
             "    const half4 c2 = half4(0.5960000157, -0.2750000060, -0.3210000098, 0.000000000);\n"
             "    const half4 c3 = half4(0.2119999975, -0.5230000019, 0.3109999895, 0.000000000);\n"
             "    const half4 c4 = half4(1.000000000, -1.106999993, 1.703999996, 0.000000000);\n"
             "    const half4 c5 = half4(1.000000000, 0.9559999704, 0.6209999919, 0.000000000);\n"
             "    const half4 c6 = half4(1.000000000, -0.2720000148, -0.6470000148, 0.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r2.z = dot(r1.xyz, c0.xyz);\n"
             "    r2.x = r2.z*c0.w + c1.x;\n"
             "    r2.x = fmin(r2.x, c0.w);\n"
             "    r2.x = fmax(r2.x, c1.y);\n"
             "    r2.y = c1.x;\n"
             "    r3.xy = r2.xy + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r2.y = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).y;\n"
             "    r2.w = r2.y - r2.z;\n"
             "    r2.x = half(r2.z >= c1.z);\n"
             "    r2.y = -r2.x + c1.z;\n"
             "    r2.x = half(r2.z >= c1.y);\n"
             "    r2.x = r2.x*r2.y;\n"
             "    r2.x = r2.x*r2.w + r2.z;\n"
             "    r2.y = dot(r1.xyz, c2.xyz);\n"
             "    r2.z = dot(r1.xyz, c3.xyz);\n"
             "    r3.z = dot(r2.xyz, c4.xyz);\n"
             "    r3.x = dot(r2.xyz, c5.xyz);\n"
             "    r3.y = dot(r2.xyz, c6.xyz);\n"
             "    r1.xyz = fmax(r3.xyz, c1.yyy);\n"
             "    r1.xyz = mix(r3.xyz, r1.xyz, half3(hg_Params[1].xyz));\n"
             "    r2.xyz = fmin(r1.xyz, c6.xxx);\n"
             "    r1.xyz = mix(r1.xyz, r2.xyz, half3(hg_Params[2].xyz));\n"
             "    r1.w = r0.w;\n"
             "    r1.xyz = r1.xyz*r0.www;\n"
             "    output.color0 = mix(float4(r0), float4(r1), hg_Params[0]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=91631463:8d4b558a:5888d915:3c713925\n"
             "//SIG=00400000:00000001:00000001:00000003:0007:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000845\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.2989999950, 0.5870000124, 0.1140000001, 1023.000000);\n"
             "    const float4 c1 = float4(0.5000000000, 0.000000000, 1.000000000, 0.000000000);\n"
             "    const float4 c2 = float4(0.5960000157, -0.2750000060, -0.3210000098, 0.000000000);\n"
             "    const float4 c3 = float4(0.2119999975, -0.5230000019, 0.3109999895, 0.000000000);\n"
             "    const float4 c4 = float4(1.000000000, -1.106999993, 1.703999996, 0.000000000);\n"
             "    const float4 c5 = float4(1.000000000, 0.9559999704, 0.6209999919, 0.000000000);\n"
             "    const float4 c6 = float4(1.000000000, -0.2720000148, -0.6470000148, 0.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r2.z = dot(r1.xyz, c0.xyz);\n"
             "    r2.x = r2.z*c0.w + c1.x;\n"
             "    r2.x = fmin(r2.x, c0.w);\n"
             "    r2.x = fmax(r2.x, c1.y);\n"
             "    r2.y = c1.x;\n"
             "    r3.xy = r2.xy + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r2.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n"
             "    r2.w = r2.y - r2.z;\n"
             "    r2.x = float(r2.z >= c1.z);\n"
             "    r2.y = -r2.x + c1.z;\n"
             "    r2.x = float(r2.z >= c1.y);\n"
             "    r2.x = r2.x*r2.y;\n"
             "    r2.x = r2.x*r2.w + r2.z;\n"
             "    r2.y = dot(r1.xyz, c2.xyz);\n"
             "    r2.z = dot(r1.xyz, c3.xyz);\n"
             "    r3.z = dot(r2.xyz, c4.xyz);\n"
             "    r3.x = dot(r2.xyz, c5.xyz);\n"
             "    r3.y = dot(r2.xyz, c6.xyz);\n"
             "    r1.xyz = fmax(r3.xyz, c1.yyy);\n"
             "    r1.xyz = mix(r3.xyz, r1.xyz, hg_Params[1].xyz);\n"
             "    r2.xyz = fmin(r1.xyz, c6.xxx);\n"
             "    r1.xyz = mix(r1.xyz, r2.xyz, hg_Params[2].xyz);\n"
             "    r1.w = r0.w;\n"
             "    r1.xyz = r1.xyz*r0.www;\n"
             "    output.color0 = mix(r0, r1, hg_Params[0]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=c0f1da10:2155b02a:4564d4bb:68c0f8ec\n"
             "//SIG=00000000:00000001:00000001:00000000:0007:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000086a\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "uniform mediump vec4 hg_ProgramLocal3;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.2989999950, 0.5870000124, 0.1140000001, 1023.000000);\n"
           "    const mediump vec4 c1 = vec4(0.5000000000, 0.000000000, 1.000000000, 0.000000000);\n"
           "    const mediump vec4 c2 = vec4(0.5960000157, -0.2750000060, -0.3210000098, 0.000000000);\n"
           "    const mediump vec4 c3 = vec4(0.2119999975, -0.5230000019, 0.3109999895, 0.000000000);\n"
           "    const mediump vec4 c4 = vec4(1.000000000, -1.106999993, 1.703999996, 0.000000000);\n"
           "    const mediump vec4 c5 = vec4(1.000000000, 0.9559999704, 0.6209999919, 0.000000000);\n"
           "    const mediump vec4 c6 = vec4(1.000000000, -0.2720000148, -0.6470000148, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r2.z = dot(r1.xyz, c0.xyz);\n"
           "    r2.x = r2.z*c0.w + c1.x;\n"
           "    r2.x = min(r2.x, c0.w);\n"
           "    r2.x = max(r2.x, c1.y);\n"
           "    r2.y = c1.x;\n"
           "    r3.xy = r2.xy + hg_ProgramLocal3.xy;\n"
           "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
           "    r2.y = texture2D(hg_Texture1, r3.xy).y;\n"
           "    r2.w = r2.y - r2.z;\n"
           "    r2.x = float(r2.z >= c1.z);\n"
           "    r2.y = -r2.x + c1.z;\n"
           "    r2.x = float(r2.z >= c1.y);\n"
           "    r2.x = r2.x*r2.y;\n"
           "    r2.x = r2.x*r2.w + r2.z;\n"
           "    r2.y = dot(r1.xyz, c2.xyz);\n"
           "    r2.z = dot(r1.xyz, c3.xyz);\n"
           "    r3.z = dot(r2.xyz, c4.xyz);\n"
           "    r3.x = dot(r2.xyz, c5.xyz);\n"
           "    r3.y = dot(r2.xyz, c6.xyz);\n"
           "    r1.xyz = max(r3.xyz, c1.yyy);\n"
           "    r1.xyz = mix(r3.xyz, r1.xyz, hg_ProgramLocal1.xyz);\n"
           "    r2.xyz = min(r1.xyz, c6.xxx);\n"
           "    r1.xyz = mix(r1.xyz, r2.xyz, hg_ProgramLocal2.xyz);\n"
           "    r1.w = r0.w;\n"
           "    r1.xyz = r1.xyz*r0.www;\n"
           "    gl_FragColor = mix(r0, r1, hg_ProgramLocal0);\n"
           "}\n"
           "//MD5=00b3f046:5e42b894:482ba6e9:d3e65d60\n"
           "//SIG=00000000:00000001:00000001:00000000:0007:0004:0004:0000:0000:0000:0000:0000:0001:02:0:1:0\n";
  }
}

void HgcContrastBezierLuma::InitProgramDescriptor(HgcContrastBezierLuma *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcContrastBezierLuma_hgc_visible", "//Metal1.0     \n//LEN=0000000702\n[[ visible ]] FragmentOut HgcContrastBezierLuma_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1)\n{\n    const float4 c0 = float4(0.2989999950, 0.5870000124, 0.1140000001, 1023.000000);\n"
    "    const float4 c1 = float4(0.5000000000, 0.000000000, 1.000000000, 0.000000000);\n"
    "    const float4 c2 = float4(0.5960000157, -0.2750000060, -0.3210000098, 0.000000000);\n"
    "    const float4 c3 = float4(0.2119999975, -0.5230000019, 0.3109999895, 0.000000000);\n"
    "    const float4 c4 = float4(1.000000000, -1.106999993, 1.703999996, 0.000000000);\n"
    "    const float4 c5 = float4(1.000000000, 0.9559999704, 0.6209999919, 0.000000000);\n"
    "    const float4 c6 = float4(1.000000000, -0.2720000148, -0.6470000148, 0.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r2.z = dot(r1.xyz, c0.xyz);\n"
    "    r2.x = r2.z*c0.w + c1.x;\n"
    "    r2.x = fmin(r2.x, c0.w);\n"
    "    r2.x = fmax(r2.x, c1.y);\n"
    "    r2.y = c1.x;\n"
    "    r3.xy = r2.xy + hg_Params[3].xy;\n"
    "    r3.xy = r3.xy*hg_Params[3].zw;\n"
    "    r2.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n"
    "    r2.w = r2.y - r2.z;\n"
    "    r2.x = float(r2.z >= c1.z);\n"
    "    r2.y = -r2.x + c1.z;\n"
    "    r2.x = float(r2.z >= c1.y);\n"
    "    r2.x = r2.x*r2.y;\n"
    "    r2.x = r2.x*r2.w + r2.z;\n"
    "    r2.y = dot(r1.xyz, c2.xyz);\n"
    "    r2.z = dot(r1.xyz, c3.xyz);\n"
    "    r3.z = dot(r2.xyz, c4.xyz);\n"
    "    r3.x = dot(r2.xyz, c5.xyz);\n"
    "    r3.y = dot(r2.xyz, c6.xyz);\n"
    "    r1.xyz = fmax(r3.xyz, c1.yyy);\n"
    "    r1.xyz = mix(r3.xyz, r1.xyz, hg_Params[1].xyz);\n"
    "    r2.xyz = fmin(r1.xyz, c6.xxx);\n"
    "    r1.xyz = mix(r1.xyz, r2.xyz, hg_Params[2].xyz);\n"
    "    r1.w = r0.w;\n"
    "    r1.xyz = r1.xyz*r0.www;\n"
    "    output.color0 = mix(r0, r1, hg_Params[0]);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcContrastBezierLuma");
}

void sub_1B7A51790(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E758F0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 9;
  std::string::basic_string[abi:ne180100]<0>(v34, "texture2d<float>");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 6;
  std::string::basic_string[abi:ne180100]<0>(v34, "sampler");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  float32x4_t v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7A51910(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7A51960()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7A51958);
}

void *HgcContrastBezierLuma::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcContrastBezierLuma [hgc1]");
}

uint64_t HgcContrastBezierLuma::BindTexture(HgcContrastBezierLuma *this, HGHandler *a2, int a3)
{
  if (a3 == 1)
  {
    if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
    {
      v8.n128_u32[0] = 1.0;
      v9.n128_u32[0] = 1.0;
    }
    else
    {
      v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
      v9.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
    }
    v6.n128_f32[0] = (float)*((int *)a2 + 60);
    v7.n128_f32[0] = (float)*((int *)a2 + 61);
    (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 3, v6, v7, v8, v9);
  }
  else
  {
    if (a3) {
      return 0xFFFFFFFFLL;
    }
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    int v4 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
    uint64_t result = 0;
    if (v4) {
      return result;
    }
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  return 0;
}

uint64_t HgcContrastBezierLuma::Bind(HgcContrastBezierLuma *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcContrastBezierLuma::RenderTile(HgcContrastBezierLuma *this, HGTile *a2)
{
  uint64_t v4 = HGTile::Renderer(a2);
  int v5 = (*(uint64_t (**)(HgcContrastBezierLuma *, uint64_t))(*(void *)this + 312))(this, v4);
  int32x2_t v6 = *(int32x2_t *)a2;
  int v7 = *((_DWORD *)a2 + 3) - HIDWORD(*(void *)a2);
  if (v7 >= 1)
  {
    int v8 = 0;
    *(float32x2_t *)v9.i8 = vadd_f32(vcvt_f32_s32(v6), (float32x2_t)0x3F0000003F000000);
    v9.i64[1] = 0x3F80000000000000;
    int v10 = *((_DWORD *)a2 + 2) - v6.i32[0];
    uint64_t v11 = *((void *)a2 + 2);
    uint64_t v12 = *((void *)a2 + 10);
    uint64_t v13 = 16 * *((int *)a2 + 6);
    uint64_t v14 = 16 * *((int *)a2 + 22);
    v15.i64[0] = 0x3F0000003F000000;
    v15.i64[1] = 0x3F0000003F000000;
    do
    {
      if (v10 < 3)
      {
        LODWORD(v151) = 0;
      }
      else
      {
        uint64_t v16 = 0;
        int v17 = 0;
        do
        {
          int8x16_t v18 = *(int8x16_t *)(v12 + v16);
          int8x16_t v19 = *(int8x16_t *)(v12 + v16 + 16);
          int8x16_t v20 = *(int8x16_t *)(v12 + v16 + 32);
          uint64_t v21 = *((void *)this + 51);
          float32x4_t v22 = *(float32x4_t *)(v21 + 48);
          float32x4_t v23 = *(float32x4_t *)(v21 + 64);
          float32x4_t v24 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 3), v22);
          float32x4_t v25 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 3), v22);
          float32x4_t v26 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 3), v22);
          float32x4_t v27 = vmulq_f32(vrecpeq_f32(v24), v23);
          float32x4_t v28 = vmulq_f32(vrecpeq_f32(v25), v23);
          float32x4_t v29 = vmulq_f32(vrecpeq_f32(v26), v23);
          float32x4_t v30 = vmulq_f32((float32x4_t)v18, vmulq_f32(v27, vrecpsq_f32(v27, v24)));
          float32x4_t v31 = vmulq_f32((float32x4_t)v19, vmulq_f32(v28, vrecpsq_f32(v28, v25)));
          float32x4_t v32 = vmulq_f32((float32x4_t)v20, vmulq_f32(v29, vrecpsq_f32(v29, v26)));
          float32x4_t v34 = *(float32x4_t *)(v21 + 80);
          int8x16_t v33 = *(int8x16_t *)(v21 + 96);
          int8x16_t v35 = (int8x16_t)vmulq_f32(v30, v34);
          int8x16_t v36 = (int8x16_t)vmulq_f32(v31, v34);
          int8x16_t v37 = (int8x16_t)vmulq_f32(v34, v32);
          int8x16_t v38 = (int8x16_t)vaddq_f32((float32x4_t)v35, vaddq_f32((float32x4_t)vextq_s8(v35, v35, 8uLL), (float32x4_t)vextq_s8(v35, v35, 0xCuLL)));
          int8x16_t v39 = (int8x16_t)vaddq_f32((float32x4_t)v36, vaddq_f32((float32x4_t)vextq_s8(v36, v36, 8uLL), (float32x4_t)vextq_s8(v36, v36, 0xCuLL)));
          int8x16_t v40 = (int8x16_t)vaddq_f32((float32x4_t)v37, vaddq_f32((float32x4_t)vextq_s8(v37, v37, 8uLL), (float32x4_t)vextq_s8(v37, v37, 0xCuLL)));
          float32x4_t v42 = *(float32x4_t *)(v21 + 112);
          float32x4_t v41 = *(float32x4_t *)(v21 + 128);
          v43.i64[0] = vaddq_f32((float32x4_t)v33, vmulq_f32(v42, (float32x4_t)vdupq_laneq_s64((int64x2_t)v38, 1))).u64[0];
          v44.i64[0] = vaddq_f32((float32x4_t)v33, vmulq_f32(v42, (float32x4_t)vdupq_laneq_s64((int64x2_t)v39, 1))).u64[0];
          v45.i64[0] = vaddq_f32((float32x4_t)v33, vmulq_f32(v42, (float32x4_t)vdupq_laneq_s64((int64x2_t)v40, 1))).u64[0];
          uint64_t v46 = vextq_s8(v38, v38, 8uLL).u64[0];
          v43.i64[1] = v38.i64[1];
          uint64_t v47 = vextq_s8(v39, v39, 8uLL).u64[0];
          v44.i64[1] = v39.i64[1];
          v45.i64[1] = v40.i64[1];
          v43.i64[0] = vminq_f32(v43, v42).u64[0];
          v44.i64[0] = vminq_f32(v44, v42).u64[0];
          v43.i64[1] = v38.i64[1];
          v45.i64[0] = vminq_f32(v45, v42).u64[0];
          v44.i64[1] = v39.i64[1];
          v45.i64[1] = v40.i64[1];
          v43.i32[0] = vmaxq_f32(v43, v41).u32[0];
          v48.i32[0] = vmaxq_f32(v44, v41).u32[0];
          v50.i32[0] = vmaxq_f32(v45, v41).u32[0];
          v43.i64[1] = v38.i64[1];
          v48.i64[1] = v39.i64[1];
          v50.i64[1] = v40.i64[1];
          v43.i32[1] = 0.5;
          v48.i32[1] = 0.5;
          uint64_t v49 = vextq_s8(v40, v40, 8uLL).u64[0];
          v50.i32[1] = 0.5;
          uint64_t v51 = *((int *)a2 + 26);
          float32x4_t v52 = vsubq_f32(v43, (float32x4_t)v9);
          uint64_t v53 = *((void *)a2 + 12);
          if (v5)
          {
            int32x4_t v54 = vaddq_s32(vcvtq_s32_f32(v52), vcltzq_f32(v52));
            float32x2_t v55 = (float32x2_t)vsubq_f32(v52, vcvtq_f32_s32(v54)).u64[0];
            int8x16_t v56 = (float32x4_t *)(v53 + 16 * (v54.i32[0] + v54.i32[1] * (int)v51));
            float32x4_t v57 = vaddq_f32(*v56, vmulq_n_f32(vsubq_f32(v56[1], *v56), v55.f32[0]));
            v52.i64[0] = vaddq_f32(v57, vmulq_lane_f32(vsubq_f32(vaddq_f32(v56[v51], vmulq_n_f32(vsubq_f32(v56[(int)v51 + 1], v56[v51]), v55.f32[0])), v57), v55, 1)).u64[0];
            float32x4_t v61 = vsubq_f32(v48, (float32x4_t)v9);
            int32x4_t v58 = vaddq_s32(vcvtq_s32_f32(v61), vcltzq_f32(v61));
            v61.i64[0] = vsubq_f32(v61, vcvtq_f32_s32(v58)).u64[0];
            float32x4_t v59 = (float32x4_t *)(v53 + 16 * (v58.i32[0] + v58.i32[1] * (int)v51));
            float32x4_t v60 = vaddq_f32(*v59, vmulq_n_f32(vsubq_f32(v59[1], *v59), v61.f32[0]));
            v61.i64[0] = vaddq_f32(v60, vmulq_lane_f32(vsubq_f32(vaddq_f32(v59[v51], vmulq_n_f32(vsubq_f32(v59[(int)v51 + 1], v59[v51]), v61.f32[0])), v60), *(float32x2_t *)v61.f32, 1)).u64[0];
            float32x4_t v62 = vsubq_f32(v50, (float32x4_t)v9);
            int32x4_t v63 = vaddq_s32(vcvtq_s32_f32(v62), vcltzq_f32(v62));
            v62.i64[0] = vsubq_f32(v62, vcvtq_f32_s32(v63)).u64[0];
            float32x4_t v64 = (float32x4_t *)(v53 + 16 * (v63.i32[0] + v63.i32[1] * (int)v51));
            float32x4_t v65 = vaddq_f32(*v64, vmulq_n_f32(vsubq_f32(v64[1], *v64), v62.f32[0]));
            v66.i64[0] = vaddq_f32(v65, vmulq_lane_f32(vsubq_f32(vaddq_f32(v64[v51], vmulq_n_f32(vsubq_f32(v64[(int)v51 + 1], v64[v51]), v62.f32[0])), v65), *(float32x2_t *)v62.f32, 1)).u64[0];
          }
          else
          {
            float32x4_t v67 = vaddq_f32(v52, v15);
            int32x4_t v68 = vcvtq_s32_f32(v67);
            v67.i64[0] = vaddq_s32(v68, vcgtq_f32(vcvtq_f32_s32(v68), v67)).u64[0];
            float32x4_t v52 = *(float32x4_t *)(v53 + 16 * (v67.i32[0] + v67.i32[1] * (int)v51));
            float32x4_t v69 = vaddq_f32(vsubq_f32(v48, (float32x4_t)v9), v15);
            int32x4_t v70 = vcvtq_s32_f32(v69);
            v69.i64[0] = vaddq_s32(v70, vcgtq_f32(vcvtq_f32_s32(v70), v69)).u64[0];
            float32x4_t v61 = *(float32x4_t *)(v53 + 16 * (v69.i32[0] + v69.i32[1] * (int)v51));
            float32x4_t v71 = vaddq_f32(vsubq_f32(v50, (float32x4_t)v9), v15);
            int32x4_t v72 = vcvtq_s32_f32(v71);
            v71.i64[0] = vaddq_s32(v72, vcgtq_f32(vcvtq_f32_s32(v72), v71)).u64[0];
            int32x4_t v66 = *(int32x4_t *)(v53 + 16 * (v71.i32[0] + v71.i32[1] * (int)v51));
          }
          v73.i64[0] = v52.i64[0];
          v73.i64[1] = v46;
          v74.i64[0] = v61.i64[0];
          v74.i64[1] = v47;
          v75.i64[0] = v66.i64[0];
          v75.i64[1] = v49;
          v76.i64[0] = v46;
          v76.i64[1] = v52.i64[0];
          v77.i64[0] = v47;
          v77.i64[1] = v61.i64[0];
          v78.i64[0] = v49;
          v78.i64[1] = v66.i64[0];
          v52.i64[1] = v46;
          v61.i64[1] = v47;
          v66.i64[1] = v49;
          int8x16_t v79 = (int8x16_t)vsubq_f32(v77, (float32x4_t)vrev64q_s32((int32x4_t)v61));
          int8x16_t v81 = *(int8x16_t *)(v21 + 144);
          int8x16_t v80 = *(int8x16_t *)(v21 + 160);
          int8x16_t v82 = vbslq_s8(v81, v73, (int8x16_t)vsubq_f32(v76, (float32x4_t)vrev64q_s32((int32x4_t)v52)));
          int8x16_t v83 = vbslq_s8(v81, v74, v79);
          int8x16_t v84 = vbslq_s8(v81, v75, (int8x16_t)vsubq_f32(v78, (float32x4_t)vrev64q_s32(v66)));
          int8x16_t v85 = (int8x16_t)vcgeq_f32((float32x4_t)v82, (float32x4_t)v33);
          int8x16_t v86 = (int8x16_t)vcgeq_f32((float32x4_t)v83, (float32x4_t)v33);
          int8x16_t v87 = (int8x16_t)vcgeq_f32((float32x4_t)v84, (float32x4_t)v33);
          float32x4_t v88 = (float32x4_t)vextq_s8(v85, v85, 8uLL);
          float32x4_t v89 = (float32x4_t)vextq_s8(v33, v33, 8uLL);
          float32x4_t v90 = (float32x4_t)vextq_s8(v86, v86, 8uLL);
          *(int32x2_t *)v88.f32 = vrev64_s32((int32x2_t)vand_s8(*(int8x8_t *)v89.f32, *(int8x8_t *)v88.f32));
          *(int32x2_t *)v90.f32 = vrev64_s32((int32x2_t)vand_s8(*(int8x8_t *)v89.f32, *(int8x8_t *)v90.f32));
          *(int32x2_t *)v89.f32 = vrev64_s32((int32x2_t)vand_s8(*(int8x8_t *)v89.f32, (int8x8_t)*(_OWORD *)&vextq_s8(v87, v87, 8uLL)));
          int8x16_t v91 = (int8x16_t)vsubq_f32(v41, v88);
          int8x16_t v92 = (int8x16_t)vsubq_f32(v41, v90);
          int8x16_t v93 = (int8x16_t)vsubq_f32(v41, v89);
          float32x4_t v94 = (float32x4_t)vextq_s8(v82, v91, 8uLL);
          v91.i64[1] = v82.i64[1];
          float32x4_t v95 = (float32x4_t)vextq_s8(v83, v92, 8uLL);
          v92.i64[1] = v83.i64[1];
          float32x4_t v96 = (float32x4_t)vextq_s8(v84, v93, 8uLL);
          v93.i64[1] = v84.i64[1];
          int8x16_t v97 = (int8x16_t)vcgeq_f32(v94, v41);
          int8x16_t v98 = (int8x16_t)vcgeq_f32(v95, v41);
          int8x16_t v99 = (int8x16_t)vcgeq_f32(v96, v41);
          int8x16_t v100 = vandq_s8(v80, v97);
          int8x16_t v101 = vandq_s8(v80, v98);
          int8x16_t v102 = *(int8x16_t *)(v21 + 176);
          float32x4_t v103 = *(float32x4_t *)(v21 + 192);
          float32x4_t v104 = (float32x4_t)vbslq_s8(v102, v100, v91);
          float32x4_t v105 = (float32x4_t)vbslq_s8(v102, v101, v92);
          float32x4_t v106 = (float32x4_t)vbslq_s8(v102, vandq_s8(v80, v99), v93);
          int8x16_t v107 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s64((int64x2_t)v104, 1), vmulq_laneq_f32(vmulq_lane_f32(v104, *(float32x2_t *)v104.f32, 1), v104, 3));
          int8x16_t v108 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s64((int64x2_t)v105, 1), vmulq_laneq_f32(vmulq_lane_f32(v105, *(float32x2_t *)v105.f32, 1), v105, 3));
          int8x16_t v109 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s64((int64x2_t)v106, 1), vmulq_laneq_f32(vmulq_lane_f32(v106, *(float32x2_t *)v106.f32, 1), v106, 3));
          int8x16_t v110 = (int8x16_t)vmulq_f32(v30, v103);
          int8x16_t v111 = (int8x16_t)vmulq_f32(v31, v103);
          int8x16_t v112 = (int8x16_t)vmulq_f32(v32, v103);
          v110.i64[0] = vbslq_s8(v102, v107, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v110, v9, 4uLL), vaddq_f32((float32x4_t)v110, (float32x4_t)vrev64q_s32((int32x4_t)v110)))).u64[0];
          v107.i64[0] = vbslq_s8(v102, v108, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v111, v9, 4uLL), vaddq_f32((float32x4_t)v111, (float32x4_t)vrev64q_s32((int32x4_t)v111)))).u64[0];
          v108.i64[0] = vbslq_s8(v102, v109, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v112, v9, 4uLL), vaddq_f32((float32x4_t)v112, (float32x4_t)vrev64q_s32((int32x4_t)v112)))).u64[0];
          float32x4_t v113 = *(float32x4_t *)(v21 + 208);
          float32x4_t v114 = *(float32x4_t *)(v21 + 224);
          int8x16_t v115 = (int8x16_t)vmulq_f32(v30, v113);
          int8x16_t v116 = (int8x16_t)vmulq_f32(v31, v113);
          int8x16_t v117 = (int8x16_t)vmulq_f32(v32, v113);
          v110.i64[1] = vaddq_f32(*(float32x4_t *)&v115, vaddq_f32((float32x4_t)vdupq_lane_s64(*(uint64_t *)&v115, 0), (float32x4_t)vextq_s8(v9, v115, 0xCuLL))).i64[1];
          v107.i64[1] = vaddq_f32(*(float32x4_t *)&v116, vaddq_f32((float32x4_t)vdupq_lane_s64(*(uint64_t *)&v116, 0), (float32x4_t)vextq_s8(v9, v116, 0xCuLL))).i64[1];
          v108.i64[1] = vaddq_f32(*(float32x4_t *)&v117, vaddq_f32((float32x4_t)vdupq_lane_s64(*(uint64_t *)&v117, 0), (float32x4_t)vextq_s8(v9, v117, 0xCuLL))).i64[1];
          int8x16_t v118 = (int8x16_t)vmulq_f32((float32x4_t)v80, (float32x4_t)v110);
          int8x16_t v119 = (int8x16_t)vmulq_f32((float32x4_t)v80, (float32x4_t)v107);
          int8x16_t v120 = (int8x16_t)vmulq_f32((float32x4_t)v80, (float32x4_t)v108);
          float32x4_t v121 = vmulq_f32(v114, (float32x4_t)v110);
          float32x4_t v122 = vmulq_f32(v114, (float32x4_t)v107);
          float32x4_t v123 = vmulq_f32(v114, (float32x4_t)v108);
          v124.i64[0] = vrev64q_s32((int32x4_t)v121).u64[0];
          v75.i64[0] = vrev64q_s32((int32x4_t)v122).u64[0];
          v76.i64[0] = vrev64q_s32((int32x4_t)v123).u64[0];
          v124.i64[1] = vextq_s8(v9, v118, 0xCuLL).i64[1];
          float32x4_t v125 = (float32x4_t)vzip2q_s64((int64x2_t)v121, (int64x2_t)v118);
          v121.i64[1] = v118.i64[0];
          int8x16_t v126 = (int8x16_t)vaddq_f32(v125, vaddq_f32(v121, v124));
          v75.i64[1] = vextq_s8(v9, v119, 0xCuLL).i64[1];
          float32x4_t v127 = (float32x4_t)vzip2q_s64((int64x2_t)v122, (int64x2_t)v119);
          v122.i64[1] = v119.i64[0];
          int8x16_t v128 = (int8x16_t)vaddq_f32(v127, vaddq_f32(v122, (float32x4_t)v75));
          v76.i64[1] = vextq_s8(v9, v120, 0xCuLL).i64[1];
          float32x4_t v129 = (float32x4_t)vzip2q_s64((int64x2_t)v123, (int64x2_t)v120);
          v123.i64[1] = v120.i64[0];
          int8x16_t v130 = (int8x16_t)vaddq_f32(v129, vaddq_f32(v123, v76));
          float32x4_t v131 = *(float32x4_t *)(v21 + 240);
          int8x16_t v132 = *(int8x16_t *)(v21 + 256);
          int8x16_t v133 = (int8x16_t)vmulq_f32(v131, (float32x4_t)v110);
          int8x16_t v134 = (int8x16_t)vmulq_f32(v131, (float32x4_t)v107);
          int8x16_t v135 = (int8x16_t)vmulq_f32(v131, (float32x4_t)v108);
          float32x4_t v136 = (float32x4_t)vbslq_s8(v132, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v133, v133, 4uLL), vaddq_f32((float32x4_t)v133, (float32x4_t)vrev64q_s32((int32x4_t)v133))), v126);
          float32x4_t v137 = (float32x4_t)vbslq_s8(v132, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v134, v134, 4uLL), vaddq_f32((float32x4_t)v134, (float32x4_t)vrev64q_s32((int32x4_t)v134))), v128);
          float32x4_t v138 = (float32x4_t)vbslq_s8(v132, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v135, v135, 4uLL), vaddq_f32((float32x4_t)v135, (float32x4_t)vrev64q_s32((int32x4_t)v135))), v130);
          float32x4_t v139 = *(float32x4_t *)(v21 + 272);
          float32x4_t v140 = *(float32x4_t *)(v21 + 288);
          float32x4_t v141 = *(float32x4_t *)(v21 + 16);
          float32x4_t v142 = vaddq_f32(vmulq_f32(v141, vsubq_f32(vmaxq_f32(v136, v139), v136)), v136);
          float32x4_t v143 = vaddq_f32(vmulq_f32(v141, vsubq_f32(vmaxq_f32(v137, v139), v137)), v137);
          float32x4_t v144 = vaddq_f32(vmulq_f32(v141, vsubq_f32(vmaxq_f32(v138, v139), v138)), v138);
          float32x4_t v145 = *(float32x4_t *)(v21 + 32);
          int8x16_t v146 = *(int8x16_t *)(v21 + 304);
          float32x4_t v147 = vaddq_f32((float32x4_t)v18, vmulq_f32(*(float32x4_t *)v21, vsubq_f32((float32x4_t)vbslq_s8(v146, v18, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v146, v18, (int8x16_t)vaddq_f32(v142, vmulq_f32(v145, vsubq_f32(vminq_f32(v142, v140), v142)))), (float32x4_t)v18, 3)), (float32x4_t)v18)));
          float32x4_t v148 = vaddq_f32((float32x4_t)v19, vmulq_f32(*(float32x4_t *)v21, vsubq_f32((float32x4_t)vbslq_s8(v146, v19, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v146, v19, (int8x16_t)vaddq_f32(v143, vmulq_f32(v145, vsubq_f32(vminq_f32(v143, v140), v143)))), (float32x4_t)v19, 3)), (float32x4_t)v19)));
          float32x4_t v149 = vaddq_f32((float32x4_t)v20, vmulq_f32(*(float32x4_t *)v21, vsubq_f32((float32x4_t)vbslq_s8(v146, v20, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v146, v20, (int8x16_t)vaddq_f32(v144, vmulq_f32(v145, vsubq_f32(vminq_f32(v144, v140), v144)))), (float32x4_t)v20, 3)), (float32x4_t)v20)));
          float32x4_t v150 = (float32x4_t *)(v11 + v16);
          *float32x4_t v150 = v147;
          v150[1] = v148;
          v150[2] = v149;
          v17 -= 3;
          v16 += 48;
        }
        while (v10 + v17 > 2);
        LODWORD(v151) = -v17;
      }
      if ((int)v151 < v10)
      {
        uint64_t v151 = v151;
        do
        {
          int8x16_t v152 = *(int8x16_t *)(v12 + 16 * v151);
          uint64_t v153 = *((void *)this + 51);
          float32x4_t v154 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v152, 3), *(float32x4_t *)(v153 + 48));
          float32x4_t v155 = vmulq_f32(vrecpeq_f32(v154), *(float32x4_t *)(v153 + 64));
          float32x4_t v156 = vmulq_f32((float32x4_t)v152, vmulq_f32(v155, vrecpsq_f32(v155, v154)));
          int8x16_t v157 = *(int8x16_t *)(v153 + 96);
          int8x16_t v158 = (int8x16_t)vmulq_f32(*(float32x4_t *)(v153 + 80), v156);
          int8x16_t v159 = (int8x16_t)vaddq_f32((float32x4_t)v158, vaddq_f32((float32x4_t)vextq_s8(v158, v158, 8uLL), (float32x4_t)vextq_s8(v158, v158, 0xCuLL)));
          float32x4_t v161 = *(float32x4_t *)(v153 + 112);
          float32x4_t v160 = *(float32x4_t *)(v153 + 128);
          v162.i64[0] = vaddq_f32((float32x4_t)v157, vmulq_f32(v161, (float32x4_t)vdupq_laneq_s64((int64x2_t)v159, 1))).u64[0];
          v162.i64[1] = v159.i64[1];
          v162.i64[0] = vminq_f32(v162, v161).u64[0];
          v162.i64[1] = v159.i64[1];
          v162.i32[0] = vmaxq_f32(v162, v160).u32[0];
          v162.i64[1] = v159.i64[1];
          v162.i32[1] = 0.5;
          uint64_t v163 = *((int *)a2 + 26);
          float32x4_t v164 = vsubq_f32(v162, (float32x4_t)v9);
          uint64_t v165 = *((void *)a2 + 12);
          if (v5)
          {
            int32x4_t v166 = vaddq_s32(vcvtq_s32_f32(v164), vcltzq_f32(v164));
            float32x2_t v167 = (float32x2_t)vsubq_f32(v164, vcvtq_f32_s32(v166)).u64[0];
            float32x4_t v168 = (float32x4_t *)(v165 + 16 * (v166.i32[0] + v166.i32[1] * (int)v163));
            float32x4_t v169 = vaddq_f32(*v168, vmulq_n_f32(vsubq_f32(v168[1], *v168), v167.f32[0]));
            v164.i64[0] = vaddq_f32(v169, vmulq_lane_f32(vsubq_f32(vaddq_f32(v168[v163], vmulq_n_f32(vsubq_f32(v168[(int)v163 + 1], v168[v163]), v167.f32[0])), v169), v167, 1)).u64[0];
          }
          else
          {
            float32x4_t v170 = vaddq_f32(v164, v15);
            int32x4_t v171 = vcvtq_s32_f32(v170);
            v170.i64[0] = vaddq_s32(v171, vcgtq_f32(vcvtq_f32_s32(v171), v170)).u64[0];
            float32x4_t v164 = *(float32x4_t *)(v165 + 16 * (v170.i32[0] + v170.i32[1] * (int)v163));
          }
          v172.i64[0] = v164.i64[0];
          v172.i64[1] = vextq_s8(v159, v159, 8uLL).u64[0];
          v173.i64[0] = v172.i64[1];
          v173.i64[1] = v164.i64[0];
          v164.i64[1] = v172.i64[1];
          int8x16_t v174 = (int8x16_t)vsubq_f32(v173, (float32x4_t)vrev64q_s32((int32x4_t)v164));
          int8x16_t v175 = *(int8x16_t *)(v153 + 160);
          int8x16_t v176 = vbslq_s8(*(int8x16_t *)(v153 + 144), v172, v174);
          int8x16_t v177 = (int8x16_t)vcgeq_f32((float32x4_t)v176, (float32x4_t)v157);
          float32x4_t v178 = (float32x4_t)vextq_s8(v157, v157, 8uLL);
          *(int32x2_t *)v178.f32 = vrev64_s32((int32x2_t)vand_s8(*(int8x8_t *)v178.f32, (int8x8_t)*(_OWORD *)&vextq_s8(v177, v177, 8uLL)));
          int8x16_t v179 = (int8x16_t)vsubq_f32(v160, v178);
          float32x4_t v180 = (float32x4_t)vextq_s8(v176, v179, 8uLL);
          v179.i64[1] = v176.i64[1];
          int8x16_t v181 = *(int8x16_t *)(v153 + 176);
          float32x4_t v182 = (float32x4_t)vbslq_s8(v181, vandq_s8(v175, (int8x16_t)vcgeq_f32(v180, v160)), v179);
          int8x16_t v183 = (int8x16_t)vmulq_f32(v156, *(float32x4_t *)(v153 + 192));
          v182.i64[0] = vbslq_s8(v181, (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s64((int64x2_t)v182, 1), vmulq_laneq_f32(vmulq_lane_f32(v182, *(float32x2_t *)v182.f32, 1), v182, 3)), (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v183, v9, 4uLL), vaddq_f32((float32x4_t)v183, (float32x4_t)vrev64q_s32((int32x4_t)v183)))).u64[0];
          int8x16_t v184 = (int8x16_t)vmulq_f32(v156, *(float32x4_t *)(v153 + 208));
          v182.i64[1] = vaddq_f32(*(float32x4_t *)&v184, vaddq_f32((float32x4_t)vdupq_lane_s64(*(uint64_t *)&v184, 0), (float32x4_t)vextq_s8(v9, v184, 0xCuLL))).i64[1];
          int8x16_t v185 = (int8x16_t)vmulq_f32((float32x4_t)v175, v182);
          float32x4_t v186 = vmulq_f32(*(float32x4_t *)(v153 + 224), v182);
          v180.i64[0] = vrev64q_s32((int32x4_t)v186).u64[0];
          v180.i64[1] = vextq_s8(v9, v185, 0xCuLL).i64[1];
          float32x4_t v187 = (float32x4_t)vzip2q_s64((int64x2_t)v186, (int64x2_t)v185);
          v186.i64[1] = v185.i64[0];
          int8x16_t v188 = (int8x16_t)vmulq_f32(*(float32x4_t *)(v153 + 240), v182);
          float32x4_t v189 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v153 + 256), (int8x16_t)vaddq_f32((float32x4_t)vextq_s8(v188, v188, 4uLL), vaddq_f32((float32x4_t)v188, (float32x4_t)vrev64q_s32((int32x4_t)v188))), (int8x16_t)vaddq_f32(v187, vaddq_f32(v186, v180)));
          float32x4_t v190 = vaddq_f32(vmulq_f32(*(float32x4_t *)(v153 + 16), vsubq_f32(vmaxq_f32(v189, *(float32x4_t *)(v153 + 272)), v189)), v189);
          *(float32x4_t *)(v11 + 16 * v151++) = vaddq_f32((float32x4_t)v152, vmulq_f32(*(float32x4_t *)v153, vsubq_f32((float32x4_t)vbslq_s8(*(int8x16_t *)(v153 + 304), v152, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(*(int8x16_t *)(v153 + 304), v152, (int8x16_t)vaddq_f32(v190, vmulq_f32(*(float32x4_t *)(v153 + 32), vsubq_f32(vminq_f32(v190, *(float32x4_t *)(v153 + 288)), v190)))), (float32x4_t)v152, 3)), (float32x4_t)v152)));
        }
        while (v151 < v10);
      }
      ++v8;
      v11 += v13;
      v12 += v14;
    }
    while (v8 != v7);
  }
  return 0;
}

uint64_t HgcContrastBezierLuma::GetDOD(HgcContrastBezierLuma *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var2;
  uint64_t v5 = *(void *)&a4.var0;
  if (a3 == 1)
  {
    if ((*(int (**)(HgcContrastBezierLuma *, HGRenderer *))(*(void *)this + 312))(this, a2) >= 1)
    {
      uint64_t v7 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
      HGRectGrow(v5, v4, v7);
    }
    int32x2_t v6 = &HGRectInfinite;
    return *(void *)v6;
  }
  if (a3)
  {
    int32x2_t v6 = &HGRectNull;
    return *(void *)v6;
  }
  return v5;
}

uint64_t HgcContrastBezierLuma::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 == 1)
  {
    Input = HGRenderer::GetInput(a2, this, 1u);
    uint64_t DOD = HGRenderer::GetDOD(a2, Input);
    uint64_t v9 = v8;
    if ((*(int (**)(HGNode *, HGRenderer *))(*(void *)this + 312))(this, a2) >= 1)
    {
      uint64_t v10 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
      return HGRectGrow(DOD, v9, v10);
    }
  }
  else if (a3)
  {
    return 0;
  }
  else
  {
    return *(void *)&a4.var0;
  }
  return DOD;
}

void HgcContrastBezierLuma::HgcContrastBezierLuma(HgcContrastBezierLuma *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F1117C38;
  operator new();
}

void sub_1B7A5285C(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcContrastBezierLuma::~HgcContrastBezierLuma(HGNode *this)
{
  *(void *)this = &unk_1F1117C38;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C409BD2D9E4);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcContrastBezierLuma::~HgcContrastBezierLuma(this);

  HGObject::operator delete(v1);
}

uint64_t HgcContrastBezierLuma::SetParameter(HgcContrastBezierLuma *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  switch(a2)
  {
    case 2:
      uint64_t v9 = *((void *)this + 51);
      if (*(float *)(v9 + 32) != a3.n128_f32[0]
        || *(float *)(v9 + 36) != a3.n128_f32[0]
        || *(float *)(v9 + 40) != a3.n128_f32[0]
        || *(float *)(v9 + 44) != 0.0)
      {
        int32x4_t v10 = vzip1q_s32((int32x4_t)a3.n128_u32[0], (int32x4_t)a3.n128_u32[0]);
        v10.i32[2] = a3.n128_u32[0];
        a3.n128_f32[1] = a4;
        *(int32x4_t *)(v9 + 32) = v10;
        a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
        *(__n128 *)(v9 + 352) = a3;
        goto LABEL_19;
      }
      return 0;
    case 1:
      uint64_t v11 = *((void *)this + 51);
      if (*(float *)(v11 + 16) != a3.n128_f32[0]
        || *(float *)(v11 + 20) != a3.n128_f32[0]
        || *(float *)(v11 + 24) != a3.n128_f32[0]
        || *(float *)(v11 + 28) != 0.0)
      {
        int32x4_t v12 = vzip1q_s32((int32x4_t)a3.n128_u32[0], (int32x4_t)a3.n128_u32[0]);
        v12.i32[2] = a3.n128_u32[0];
        a3.n128_f32[1] = a4;
        *(int32x4_t *)(v11 + 16) = v12;
        a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
        *(__n128 *)(v11 + 336) = a3;
        goto LABEL_19;
      }
      return 0;
    case 0:
      uint64_t v7 = *((void *)this + 51);
      if (*(float *)v7 != a3.n128_f32[0]
        || *(float *)(v7 + 4) != a3.n128_f32[0]
        || *(float *)(v7 + 8) != a3.n128_f32[0]
        || *(float *)(v7 + 12) != a3.n128_f32[0])
      {
        int32x4_t v8 = vdupq_lane_s32((int32x2_t)a3.n128_u64[0], 0);
        a3.n128_f32[1] = a4;
        *(int32x4_t *)uint64_t v7 = v8;
        a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
        *(__n128 *)(v7 + 320) = a3;
LABEL_19:
        HGNode::ClearBits((HGNode *)this, a2, a7);
        return 1;
      }
      return 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t HgcContrastBezierLuma::GetParameter(HgcContrastBezierLuma *this, int a2, float *a3)
{
  switch(a2)
  {
    case 2:
      uint64_t v5 = (float *)*((void *)this + 51);
      *a3 = v5[88];
      a3[1] = v5[89];
      a3[2] = v5[90];
      uint64_t v4 = v5 + 91;
      goto LABEL_7;
    case 1:
      int32x2_t v6 = (float *)*((void *)this + 51);
      *a3 = v6[84];
      a3[1] = v6[85];
      a3[2] = v6[86];
      uint64_t v4 = v6 + 87;
      goto LABEL_7;
    case 0:
      int v3 = (float *)*((void *)this + 51);
      *a3 = v3[80];
      a3[1] = v3[81];
      a3[2] = v3[82];
      uint64_t v4 = v3 + 83;
LABEL_7:
      uint64_t result = 0;
      a3[3] = *v4;
      return result;
  }
  return 0xFFFFFFFFLL;
}

const char *HgcContrastBezierRGB::GetProgram(HgcContrastBezierRGB *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=00000008ca\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< half > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const half4 c0 = half4(1023.000000, 0.5000000000, 0.000000000, 1.000000000);\n"
             "    half4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r2.x = r1.z*c0.x + c0.y;\n"
             "    r2.x = fmin(r2.x, c0.x);\n"
             "    r2.x = fmax(r2.x, c0.z);\n"
             "    r2.y = c0.y;\n"
             "    r2.xy = r2.xy + half2(hg_Params[3].xy);\n"
             "    r2.xy = r2.xy*half2(hg_Params[3].zw);\n"
             "    r2.y = (half) hg_Texture1.sample(hg_Sampler1, float2(r2.xy)).y;\n"
             "    r2.x = half(r1.z >= c0.w);\n"
             "    r2.z = -r2.x + c0.w;\n"
             "    r2.x = half(r1.z >= c0.z);\n"
             "    r2.x = r2.x*r2.z;\n"
             "    r2.z = mix(r1.z, r2.y, r2.x);\n"
             "    r2.y = half(r1.x >= c0.w);\n"
             "    r2.w = -r2.y + c0.w;\n"
             "    r2.y = half(r1.x >= c0.z);\n"
             "    r2.w = r2.y*r2.w;\n"
             "    r2.x = r1.x*c0.x + c0.y;\n"
             "    r2.x = fmin(r2.x, c0.x);\n"
             "    r2.x = fmax(r2.x, c0.z);\n"
             "    r2.y = c0.y;\n"
             "    r3.xy = r2.xy + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r2.y = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).y;\n"
             "    r1.z = r2.y - r1.x;\n"
             "    r2.y = r1.y*c0.x + c0.y;\n"
             "    r2.x = r2.w*r1.z + r1.x;\n"
             "    r1.x = half(r1.y < c0.w);\n"
             "    r2.y = fmin(r2.y, c0.x);\n"
             "    r2.w = half(r1.y >= c0.z);\n"
             "    r2.w = r2.w*r1.x;\n"
             "    r1.z = fmax(r2.y, c0.z);\n"
             "    r1.w = c0.y;\n"
             "    r3.xy = r1.zw + half2(hg_Params[3].xy);\n"
             "    r3.xy = r3.xy*half2(hg_Params[3].zw);\n"
             "    r2.y = (half) hg_Texture1.sample(hg_Sampler1, float2(r3.xy)).y;\n"
             "    r2.y = mix(r1.y, r2.y, r2.w);\n"
             "    r3.xyz = fmax(r2.xyz, c0.zzz);\n"
             "    r2.xyz = mix(r2.xyz, r3.xyz, half3(hg_Params[1].xyz));\n"
             "    r1.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = mix(r2.xyz, r1.xyz, half3(hg_Params[2].xyz));\n"
             "    r2.w = r0.w;\n"
             "    r2.xyz = r2.xyz*r0.www;\n"
             "    output.color0 = mix(float4(r0), float4(r2), hg_Params[0]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=da45afb2:5fa4481c:eb49d25b:331db194\n"
             "//SIG=00400000:00000001:00000001:00000003:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000858\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]], \n"
             "    texture2d< float > hg_Texture1 [[ texture(1) ]], \n"
             "    sampler hg_Sampler1 [[ sampler(1) ]])\n"
             "{\n"
             "    const float4 c0 = float4(1023.000000, 0.5000000000, 0.000000000, 1.000000000);\n"
             "    float4 r0, r1, r2, r3;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r2.x = r1.z*c0.x + c0.y;\n"
             "    r2.x = fmin(r2.x, c0.x);\n"
             "    r2.x = fmax(r2.x, c0.z);\n"
             "    r2.y = c0.y;\n"
             "    r2.xy = r2.xy + hg_Params[3].xy;\n"
             "    r2.xy = r2.xy*hg_Params[3].zw;\n"
             "    r2.y = hg_Texture1.sample(hg_Sampler1, r2.xy).y;\n"
             "    r2.x = float(r1.z >= c0.w);\n"
             "    r2.z = -r2.x + c0.w;\n"
             "    r2.x = float(r1.z >= c0.z);\n"
             "    r2.x = r2.x*r2.z;\n"
             "    r2.z = mix(r1.z, r2.y, r2.x);\n"
             "    r2.y = float(r1.x >= c0.w);\n"
             "    r2.w = -r2.y + c0.w;\n"
             "    r2.y = float(r1.x >= c0.z);\n"
             "    r2.w = r2.y*r2.w;\n"
             "    r2.x = r1.x*c0.x + c0.y;\n"
             "    r2.x = fmin(r2.x, c0.x);\n"
             "    r2.x = fmax(r2.x, c0.z);\n"
             "    r2.y = c0.y;\n"
             "    r3.xy = r2.xy + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r2.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n"
             "    r1.z = r2.y - r1.x;\n"
             "    r2.y = r1.y*c0.x + c0.y;\n"
             "    r2.x = r2.w*r1.z + r1.x;\n"
             "    r1.x = float(r1.y < c0.w);\n"
             "    r2.y = fmin(r2.y, c0.x);\n"
             "    r2.w = float(r1.y >= c0.z);\n"
             "    r2.w = r2.w*r1.x;\n"
             "    r1.z = fmax(r2.y, c0.z);\n"
             "    r1.w = c0.y;\n"
             "    r3.xy = r1.zw + hg_Params[3].xy;\n"
             "    r3.xy = r3.xy*hg_Params[3].zw;\n"
             "    r2.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n"
             "    r2.y = mix(r1.y, r2.y, r2.w);\n"
             "    r3.xyz = fmax(r2.xyz, c0.zzz);\n"
             "    r2.xyz = mix(r2.xyz, r3.xyz, hg_Params[1].xyz);\n"
             "    r1.xyz = fmin(r2.xyz, c0.www);\n"
             "    r2.xyz = mix(r2.xyz, r1.xyz, hg_Params[2].xyz);\n"
             "    r2.w = r0.w;\n"
             "    r2.xyz = r2.xyz*r0.www;\n"
             "    output.color0 = mix(r0, r2, hg_Params[0]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=d682f72a:a793c7a2:3747d05e:5dd2f5b4\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0002:0000:0001:02:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=000000085f\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform defaultp sampler2D hg_Texture1;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "uniform mediump vec4 hg_ProgramLocal3;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(1023.000000, 0.5000000000, 0.000000000, 1.000000000);\n"
           "    mediump vec4 r0, r1, r2, r3;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r2.x = r1.z*c0.x + c0.y;\n"
           "    r2.x = min(r2.x, c0.x);\n"
           "    r2.x = max(r2.x, c0.z);\n"
           "    r2.y = c0.y;\n"
           "    r2.xy = r2.xy + hg_ProgramLocal3.xy;\n"
           "    r2.xy = r2.xy*hg_ProgramLocal3.zw;\n"
           "    r2.y = texture2D(hg_Texture1, r2.xy).y;\n"
           "    r2.x = float(r1.z >= c0.w);\n"
           "    r2.z = -r2.x + c0.w;\n"
           "    r2.x = float(r1.z >= c0.z);\n"
           "    r2.x = r2.x*r2.z;\n"
           "    r2.z = mix(r1.z, r2.y, r2.x);\n"
           "    r2.y = float(r1.x >= c0.w);\n"
           "    r2.w = -r2.y + c0.w;\n"
           "    r2.y = float(r1.x >= c0.z);\n"
           "    r2.w = r2.y*r2.w;\n"
           "    r2.x = r1.x*c0.x + c0.y;\n"
           "    r2.x = min(r2.x, c0.x);\n"
           "    r2.x = max(r2.x, c0.z);\n"
           "    r2.y = c0.y;\n"
           "    r3.xy = r2.xy + hg_ProgramLocal3.xy;\n"
           "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
           "    r2.y = texture2D(hg_Texture1, r3.xy).y;\n"
           "    r1.z = r2.y - r1.x;\n"
           "    r2.y = r1.y*c0.x + c0.y;\n"
           "    r2.x = r2.w*r1.z + r1.x;\n"
           "    r1.x = float(r1.y < c0.w);\n"
           "    r2.y = min(r2.y, c0.x);\n"
           "    r2.w = float(r1.y >= c0.z);\n"
           "    r2.w = r2.w*r1.x;\n"
           "    r1.z = max(r2.y, c0.z);\n"
           "    r1.w = c0.y;\n"
           "    r3.xy = r1.zw + hg_ProgramLocal3.xy;\n"
           "    r3.xy = r3.xy*hg_ProgramLocal3.zw;\n"
           "    r2.y = texture2D(hg_Texture1, r3.xy).y;\n"
           "    r2.y = mix(r1.y, r2.y, r2.w);\n"
           "    r3.xyz = max(r2.xyz, c0.zzz);\n"
           "    r2.xyz = mix(r2.xyz, r3.xyz, hg_ProgramLocal1.xyz);\n"
           "    r1.xyz = min(r2.xyz, c0.www);\n"
           "    r2.xyz = mix(r2.xyz, r1.xyz, hg_ProgramLocal2.xyz);\n"
           "    r2.w = r0.w;\n"
           "    r2.xyz = r2.xyz*r0.www;\n"
           "    gl_FragColor = mix(r0, r2, hg_ProgramLocal0);\n"
           "}\n"
           "//MD5=a2428740:5114198b:975d4f89:e90d2161\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0004:0004:0000:0000:0000:0000:0000:0001:02:0:1:0\n";
  }
}

void HgcContrastBezierRGB::InitProgramDescriptor(HgcContrastBezierRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcContrastBezierRGB_hgc_visible", "//Metal1.0     \n//LEN=0000000714\n[[ visible ]] FragmentOut HgcContrastBezierRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0, \n    texture2d< float > hg_Texture1, \n    sampler hg_Sampler1)\n{\n    const float4 c0 = float4(1023.000000, 0.5000000000, 0.000000000, 1.000000000);\n"
    "    float4 r0, r1, r2, r3;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r2.x = r1.z*c0.x + c0.y;\n"
    "    r2.x = fmin(r2.x, c0.x);\n"
    "    r2.x = fmax(r2.x, c0.z);\n"
    "    r2.y = c0.y;\n"
    "    r2.xy = r2.xy + hg_Params[3].xy;\n"
    "    r2.xy = r2.xy*hg_Params[3].zw;\n"
    "    r2.y = hg_Texture1.sample(hg_Sampler1, r2.xy).y;\n"
    "    r2.x = float(r1.z >= c0.w);\n"
    "    r2.z = -r2.x + c0.w;\n"
    "    r2.x = float(r1.z >= c0.z);\n"
    "    r2.x = r2.x*r2.z;\n"
    "    r2.z = mix(r1.z, r2.y, r2.x);\n"
    "    r2.y = float(r1.x >= c0.w);\n"
    "    r2.w = -r2.y + c0.w;\n"
    "    r2.y = float(r1.x >= c0.z);\n"
    "    r2.w = r2.y*r2.w;\n"
    "    r2.x = r1.x*c0.x + c0.y;\n"
    "    r2.x = fmin(r2.x, c0.x);\n"
    "    r2.x = fmax(r2.x, c0.z);\n"
    "    r2.y = c0.y;\n"
    "    r3.xy = r2.xy + hg_Params[3].xy;\n"
    "    r3.xy = r3.xy*hg_Params[3].zw;\n"
    "    r2.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n"
    "    r1.z = r2.y - r1.x;\n"
    "    r2.y = r1.y*c0.x + c0.y;\n"
    "    r2.x = r2.w*r1.z + r1.x;\n"
    "    r1.x = float(r1.y < c0.w);\n"
    "    r2.y = fmin(r2.y, c0.x);\n"
    "    r2.w = float(r1.y >= c0.z);\n"
    "    r2.w = r2.w*r1.x;\n"
    "    r1.z = fmax(r2.y, c0.z);\n"
    "    r1.w = c0.y;\n"
    "    r3.xy = r1.zw + hg_Params[3].xy;\n"
    "    r3.xy = r3.xy*hg_Params[3].zw;\n"
    "    r2.y = hg_Texture1.sample(hg_Sampler1, r3.xy).y;\n"
    "    r2.y = mix(r1.y, r2.y, r2.w);\n"
    "    r3.xyz = fmax(r2.xyz, c0.zzz);\n"
    "    r2.xyz = mix(r2.xyz, r3.xyz, hg_Params[1].xyz);\n"
    "    r1.xyz = fmin(r2.xyz, c0.www);\n"
    "    r2.xyz = mix(r2.xyz, r1.xyz, hg_Params[2].xyz);\n"
    "    r2.w = r0.w;\n"
    "    r2.xyz = r2.xyz*r0.www;\n"
    "    output.color0 = mix(r0, r2, hg_Params[0]);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcContrastBezierRGB");
}

void sub_1B7A52BF4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E758F0;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 9;
  std::string::basic_string[abi:ne180100]<0>(v34, "texture2d<float>");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 6;
  std::string::basic_string[abi:ne180100]<0>(v34, "sampler");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  int8x16_t v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7A52D74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7A52DC4()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7A52DBCLL);
}

void *HgcContrastBezierRGB::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcContrastBezierRGB [hgc1]");
}

uint64_t HgcContrastBezierRGB::BindTexture(HgcContrastBezierRGB *this, HGHandler *a2, int a3)
{
  if (a3 == 1)
  {
    if ((*(unsigned int (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46))
    {
      v8.n128_u32[0] = 1.0;
      v9.n128_u32[0] = 1.0;
    }
    else
    {
      v8.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 57) - *((_DWORD *)a2 + 55));
      v9.n128_f32[0] = 1.0 / (float)(*((_DWORD *)a2 + 58) - *((_DWORD *)a2 + 56));
    }
    v6.n128_f32[0] = (float)*((int *)a2 + 60);
    v7.n128_f32[0] = (float)*((int *)a2 + 61);
    (*(void (**)(HGHandler *, uint64_t, __n128, __n128, __n128, __n128))(*(void *)a2 + 136))(a2, 3, v6, v7, v8, v9);
  }
  else
  {
    if (a3) {
      return 0xFFFFFFFFLL;
    }
    (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
    (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
    HGHandler::TexCoord(a2, 0, 0, 0, 0);
    int v4 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
    uint64_t result = 0;
    if (v4) {
      return result;
    }
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
  }
  return 0;
}

uint64_t HgcContrastBezierRGB::Bind(HgcContrastBezierRGB *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcContrastBezierRGB::RenderTile(HgcContrastBezierRGB *this, HGTile *a2)
{
  uint64_t v4 = HGTile::Renderer(a2);
  int v5 = (*(uint64_t (**)(HgcContrastBezierRGB *, uint64_t))(*(void *)this + 312))(this, v4);
  int32x2_t v6 = *(int32x2_t *)a2;
  int v7 = *((_DWORD *)a2 + 3) - HIDWORD(*(void *)a2);
  if (v7 >= 1)
  {
    int v8 = 0;
    *(float32x2_t *)v9.i8 = vadd_f32(vcvt_f32_s32(v6), (float32x2_t)0x3F0000003F000000);
    v9.i64[1] = 0x3F80000000000000;
    int v10 = *((_DWORD *)a2 + 2) - v6.i32[0];
    uint64_t v11 = *((void *)a2 + 2);
    uint64_t v12 = *((void *)a2 + 10);
    uint64_t v13 = 16 * *((int *)a2 + 6);
    uint64_t v14 = 16 * *((int *)a2 + 22);
    v15.i64[0] = 0x3F0000003F000000;
    v15.i64[1] = 0x3F0000003F000000;
    do
    {
      if (v10 < 3)
      {
        LODWORD(v201) = 0;
      }
      else
      {
        uint64_t v16 = 0;
        int v17 = 0;
        do
        {
          int8x16_t v18 = *(int8x16_t *)(v12 + v16);
          int8x16_t v19 = *(int8x16_t *)(v12 + v16 + 16);
          int8x16_t v20 = *(int8x16_t *)(v12 + v16 + 32);
          uint64_t v21 = *((void *)this + 51);
          float32x4_t v22 = *(float32x4_t *)(v21 + 48);
          float32x4_t v23 = *(float32x4_t *)(v21 + 64);
          float32x4_t v24 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 3), v22);
          float32x4_t v25 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 3), v22);
          float32x4_t v26 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 3), v22);
          float32x4_t v27 = vmulq_f32(vrecpeq_f32(v24), v23);
          float32x4_t v28 = vmulq_f32(vrecpeq_f32(v25), v23);
          float32x4_t v29 = vmulq_f32(vrecpeq_f32(v26), v23);
          float32x4_t v30 = vmulq_f32(v29, vrecpsq_f32(v29, v26));
          int8x16_t v31 = (int8x16_t)vmulq_f32((float32x4_t)v18, vmulq_f32(v27, vrecpsq_f32(v27, v24)));
          int8x16_t v32 = (int8x16_t)vmulq_f32((float32x4_t)v19, vmulq_f32(v28, vrecpsq_f32(v28, v25)));
          int8x16_t v33 = (int8x16_t)vmulq_f32((float32x4_t)v20, v30);
          float32x4_t v34 = (float32x4_t)vextq_s8(v31, v31, 8uLL);
          float32x4_t v35 = (float32x4_t)vextq_s8(v32, v32, 8uLL);
          float32x4_t v36 = (float32x4_t)vextq_s8(v33, v33, 8uLL);
          float32x4_t v38 = *(float32x4_t *)(v21 + 80);
          float32x4_t v37 = *(float32x4_t *)(v21 + 96);
          int8x16_t v39 = *(int8x16_t *)(v21 + 112);
          float32x4_t v40 = vmaxq_f32(vminq_f32(vaddq_f32(v38, vmulq_f32(v34, v37)), v37), (float32x4_t)v39);
          float32x4_t v41 = vmaxq_f32(vminq_f32(vaddq_f32(v38, vmulq_f32(v35, v37)), v37), (float32x4_t)v39);
          v40.i32[1] = 0.5;
          v41.i32[1] = 0.5;
          float32x4_t v42 = vmaxq_f32(vminq_f32(vaddq_f32(v38, vmulq_f32(v37, v36)), v37), (float32x4_t)v39);
          v42.i32[1] = 0.5;
          uint64_t v43 = *((int *)a2 + 26);
          float32x4_t v44 = vsubq_f32(v40, (float32x4_t)v9);
          uint64_t v45 = *((void *)a2 + 12);
          if (v5)
          {
            int32x4_t v46 = vaddq_s32(vcvtq_s32_f32(v44), vcltzq_f32(v44));
            float32x2_t v47 = (float32x2_t)vsubq_f32(v44, vcvtq_f32_s32(v46)).u64[0];
            float32x4_t v48 = (float32x4_t *)(v45 + 16 * (v46.i32[0] + v46.i32[1] * (int)v43));
            float32x4_t v49 = vaddq_f32(*v48, vmulq_n_f32(vsubq_f32(v48[1], *v48), v47.f32[0]));
            int8x16_t v50 = (int8x16_t)vaddq_f32(v49, vmulq_lane_f32(vsubq_f32(vaddq_f32(v48[v43], vmulq_n_f32(vsubq_f32(v48[(int)v43 + 1], v48[v43]), v47.f32[0])), v49), v47, 1));
            float32x4_t v51 = vsubq_f32(v41, (float32x4_t)v9);
            int32x4_t v52 = vaddq_s32(vcvtq_s32_f32(v51), vcltzq_f32(v51));
            v51.i64[0] = vsubq_f32(v51, vcvtq_f32_s32(v52)).u64[0];
            uint64_t v53 = (float32x4_t *)(v45 + 16 * (v52.i32[0] + v52.i32[1] * (int)v43));
            float32x4_t v54 = vaddq_f32(*v53, vmulq_n_f32(vsubq_f32(v53[1], *v53), v51.f32[0]));
            int8x16_t v55 = (int8x16_t)vaddq_f32(v54, vmulq_lane_f32(vsubq_f32(vaddq_f32(v53[v43], vmulq_n_f32(vsubq_f32(v53[(int)v43 + 1], v53[v43]), v51.f32[0])), v54), *(float32x2_t *)v51.f32, 1));
            float32x4_t v56 = vsubq_f32(v42, (float32x4_t)v9);
            int32x4_t v57 = vaddq_s32(vcvtq_s32_f32(v56), vcltzq_f32(v56));
            v56.i64[0] = vsubq_f32(v56, vcvtq_f32_s32(v57)).u64[0];
            int32x4_t v58 = (float32x4_t *)(v45 + 16 * (v57.i32[0] + v57.i32[1] * (int)v43));
            float32x4_t v59 = vaddq_f32(*v58, vmulq_n_f32(vsubq_f32(v58[1], *v58), v56.f32[0]));
            int8x16_t v60 = (int8x16_t)vaddq_f32(v59, vmulq_lane_f32(vsubq_f32(vaddq_f32(v58[v43], vmulq_n_f32(vsubq_f32(v58[(int)v43 + 1], v58[v43]), v56.f32[0])), v59), *(float32x2_t *)v56.f32, 1));
          }
          else
          {
            float32x4_t v61 = vaddq_f32(v44, v15);
            int32x4_t v62 = vcvtq_s32_f32(v61);
            v61.i64[0] = vaddq_s32(v62, vcgtq_f32(vcvtq_f32_s32(v62), v61)).u64[0];
            int8x16_t v50 = *(int8x16_t *)(v45 + 16 * (v61.i32[0] + v61.i32[1] * (int)v43));
            float32x4_t v63 = vaddq_f32(vsubq_f32(v41, (float32x4_t)v9), v15);
            int32x4_t v64 = vcvtq_s32_f32(v63);
            v63.i64[0] = vaddq_s32(v64, vcgtq_f32(vcvtq_f32_s32(v64), v63)).u64[0];
            int8x16_t v55 = *(int8x16_t *)(v45 + 16 * (v63.i32[0] + v63.i32[1] * (int)v43));
            float32x4_t v65 = vaddq_f32(vsubq_f32(v42, (float32x4_t)v9), v15);
            int32x4_t v66 = vcvtq_s32_f32(v65);
            v65.i64[0] = vaddq_s32(v66, vcgtq_f32(vcvtq_f32_s32(v66), v65)).u64[0];
            int8x16_t v60 = *(int8x16_t *)(v45 + 16 * (v65.i32[0] + v65.i32[1] * (int)v43));
          }
          int8x16_t v67 = vandq_s8(v39, (int8x16_t)vcgeq_f32((float32x4_t)v31, (float32x4_t)v39));
          int8x16_t v68 = vandq_s8(v39, (int8x16_t)vcgeq_f32((float32x4_t)v32, (float32x4_t)v39));
          int8x16_t v69 = vandq_s8(v39, (int8x16_t)vcgeq_f32((float32x4_t)v33, (float32x4_t)v39));
          int8x16_t v70 = vextq_s8(v67, v67, 8uLL);
          int8x16_t v72 = *(int8x16_t *)(v21 + 128);
          int8x16_t v71 = *(int8x16_t *)(v21 + 144);
          int8x16_t v73 = vmvnq_s8(v72);
          v74.i64[0] = vbslq_s8(v72, v70, v50).u64[0];
          v75.i64[0] = vbslq_s8(v72, vextq_s8(v68, v68, 8uLL), v55).u64[0];
          v76.i64[0] = vbslq_s8(v72, vextq_s8(v69, v69, 8uLL), v60).u64[0];
          v74.i64[1] = vsubq_f32(*(float32x4_t *)&v39, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v74, 0)).i64[1];
          v75.i64[1] = vsubq_f32(*(float32x4_t *)&v39, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v75, 0)).i64[1];
          v76.i64[1] = vsubq_f32(*(float32x4_t *)&v39, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v76, 0)).i64[1];
          float32x4_t v77 = (float32x4_t)vbslq_s8(v72, vandq_s8(v71, (int8x16_t)vcgeq_f32(v34, (float32x4_t)v39)), v74);
          float32x4_t v78 = (float32x4_t)vbslq_s8(v72, vandq_s8(v71, (int8x16_t)vcgeq_f32(v35, (float32x4_t)v39)), v75);
          float32x4_t v79 = (float32x4_t)vbslq_s8(v72, vandq_s8(v71, (int8x16_t)vcgeq_f32(v36, (float32x4_t)v39)), v76);
          int8x16_t v80 = vbslq_s8(v72, (int8x16_t)vmulq_laneq_f32(v77, v77, 2), v74);
          int8x16_t v81 = vbslq_s8(v72, (int8x16_t)vmulq_laneq_f32(v78, v78, 2), v75);
          int8x16_t v82 = vbslq_s8(v72, (int8x16_t)vmulq_laneq_f32(v79, v79, 2), v76);
          int8x16_t v83 = (int8x16_t)vaddq_f32((float32x4_t)v31, vmulq_n_f32(vsubq_f32((float32x4_t)vextq_s8(v9, v80, 0xCuLL), (float32x4_t)v31), *(float *)v80.i32));
          float32x4_t v84 = vmulq_n_f32(vsubq_f32((float32x4_t)vextq_s8(v9, v82, 0xCuLL), (float32x4_t)v33), *(float *)v82.i32);
          float32x4_t v85 = (float32x4_t)vrev64q_s32((int32x4_t)v31);
          float32x4_t v86 = (float32x4_t)vrev64q_s32((int32x4_t)v32);
          float32x4_t v87 = (float32x4_t)vrev64q_s32((int32x4_t)v33);
          int8x16_t v88 = *(int8x16_t *)(v21 + 160);
          float32x4_t v89 = *(float32x4_t *)(v21 + 176);
          v90.i64[0] = vandq_s8(v71, (int8x16_t)vcgeq_f32(v85, (float32x4_t)v39)).u64[0];
          v90.i64[1] = vbslq_s8(v88, v83, (int8x16_t)vsubq_f32(*(float32x4_t *)&v71, (float32x4_t)vdupq_lane_s64((uint64_t)vandq_s8(v71, (int8x16_t)vcgeq_f32(v85, *(float32x4_t *)&v71)), 0))).i64[1];
          v91.i64[0] = vandq_s8(v71, (int8x16_t)vcgeq_f32(v86, (float32x4_t)v39)).u64[0];
          v91.i64[1] = vbslq_s8(v88, (int8x16_t)vaddq_f32(*(float32x4_t *)&v32, vmulq_n_f32(vsubq_f32((float32x4_t)vextq_s8(v9, v81, 0xCuLL), *(float32x4_t *)&v32), *(float *)&v81)), (int8x16_t)vsubq_f32(*(float32x4_t *)&v71, (float32x4_t)vdupq_lane_s64((uint64_t)vandq_s8(v71, (int8x16_t)vcgeq_f32(v86, *(float32x4_t *)&v71)), 0))).i64[1];
          v81.i64[0] = vandq_s8(v71, (int8x16_t)vcgeq_f32(v87, (float32x4_t)v39)).u64[0];
          v81.i64[1] = vbslq_s8(v88, (int8x16_t)vaddq_f32(*(float32x4_t *)&v33, v84), (int8x16_t)vsubq_f32(*(float32x4_t *)&v71, (float32x4_t)vdupq_lane_s64((uint64_t)vandq_s8(v71, (int8x16_t)vcgeq_f32(v87, *(float32x4_t *)&v71)), 0))).i64[1];
          int8x16_t v92 = vbslq_s8(v88, v90, (int8x16_t)vmulq_lane_f32((float32x4_t)v90, *(float32x2_t *)v90.i8, 1));
          int8x16_t v93 = vbslq_s8(v88, v91, (int8x16_t)vmulq_lane_f32((float32x4_t)v91, *(float32x2_t *)v91.i8, 1));
          int8x16_t v94 = vbslq_s8(v88, v81, (int8x16_t)vmulq_lane_f32((float32x4_t)v81, *(float32x2_t *)v81.i8, 1));
          v84.i64[0] = vaddq_f32(v38, vmulq_f32((float32x4_t)v31, v37)).u64[0];
          v87.i64[0] = vaddq_f32(v38, vmulq_f32((float32x4_t)v32, v37)).u64[0];
          v95.i64[0] = vaddq_f32(v38, vmulq_f32((float32x4_t)v33, v37)).u64[0];
          v84.i64[1] = v92.i64[1];
          v87.i64[1] = v93.i64[1];
          int8x8_t v96 = (int8x8_t)vextq_s8(v92, v92, 8uLL).u64[0];
          v95.i64[1] = v94.i64[1];
          v84.i64[0] = vminq_f32(v84, v37).u64[0];
          v87.i64[0] = vminq_f32(v87, v37).u64[0];
          v90.i64[0] = vminq_f32(v95, v37).u64[0];
          v84.i64[1] = v92.i64[1];
          v87.i64[1] = v93.i64[1];
          v90.i64[1] = v94.i64[1];
          int8x8_t v97 = (int8x8_t)vextq_s8(v93, v93, 8uLL).u64[0];
          v88.i32[0] = vmaxq_f32(v84, v89).u32[0];
          v99.i32[0] = vmaxq_f32(v87, v89).u32[0];
          v100.i32[0] = vmaxq_f32((float32x4_t)v90, v89).u32[0];
          v88.i64[1] = v92.i64[1];
          v99.i64[1] = v93.i64[1];
          v100.i64[1] = v94.i64[1];
          v88.i32[1] = 0.5;
          int8x8_t v98 = (int8x8_t)vextq_s8(v94, v94, 8uLL).u64[0];
          v99.i32[1] = 0.5;
          v100.i32[1] = 0.5;
          float32x4_t v101 = vsubq_f32((float32x4_t)v88, (float32x4_t)v9);
          if (v5)
          {
            int32x4_t v102 = vaddq_s32(vcvtq_s32_f32(v101), vcltzq_f32(v101));
            float32x2_t v103 = (float32x2_t)vsubq_f32(v101, vcvtq_f32_s32(v102)).u64[0];
            float32x4_t v104 = (float32x4_t *)(v45 + 16 * (v102.i32[0] + v102.i32[1] * (int)v43));
            float32x4_t v105 = vaddq_f32(*v104, vmulq_n_f32(vsubq_f32(v104[1], *v104), v103.f32[0]));
            v101.i64[0] = vaddq_f32(v105, vmulq_lane_f32(vsubq_f32(vaddq_f32(v104[v43], vmulq_n_f32(vsubq_f32(v104[(int)v43 + 1], v104[v43]), v103.f32[0])), v105), v103, 1)).u64[0];
            float32x4_t v109 = vsubq_f32(v99, (float32x4_t)v9);
            int32x4_t v106 = vaddq_s32(vcvtq_s32_f32(v109), vcltzq_f32(v109));
            v109.i64[0] = vsubq_f32(v109, vcvtq_f32_s32(v106)).u64[0];
            int8x16_t v107 = (float32x4_t *)(v45 + 16 * (v106.i32[0] + v106.i32[1] * (int)v43));
            float32x4_t v108 = vaddq_f32(*v107, vmulq_n_f32(vsubq_f32(v107[1], *v107), v109.f32[0]));
            v109.i64[0] = vaddq_f32(v108, vmulq_lane_f32(vsubq_f32(vaddq_f32(v107[v43], vmulq_n_f32(vsubq_f32(v107[(int)v43 + 1], v107[v43]), v109.f32[0])), v108), *(float32x2_t *)v109.f32, 1)).u64[0];
            float32x4_t v113 = vsubq_f32(v100, (float32x4_t)v9);
            int32x4_t v110 = vaddq_s32(vcvtq_s32_f32(v113), vcltzq_f32(v113));
            v113.i64[0] = vsubq_f32(v113, vcvtq_f32_s32(v110)).u64[0];
            int8x16_t v111 = (float32x4_t *)(v45 + 16 * (v110.i32[0] + v110.i32[1] * (int)v43));
            float32x4_t v112 = vaddq_f32(*v111, vmulq_n_f32(vsubq_f32(v111[1], *v111), v113.f32[0]));
            v113.i64[0] = vaddq_f32(v112, vmulq_lane_f32(vsubq_f32(vaddq_f32(v111[v43], vmulq_n_f32(vsubq_f32(v111[(int)v43 + 1], v111[v43]), v113.f32[0])), v112), *(float32x2_t *)v113.f32, 1)).u64[0];
          }
          else
          {
            float32x4_t v114 = vaddq_f32(v101, v15);
            int32x4_t v115 = vcvtq_s32_f32(v114);
            v114.i64[0] = vaddq_s32(v115, vcgtq_f32(vcvtq_f32_s32(v115), v114)).u64[0];
            float32x4_t v101 = *(float32x4_t *)(v45 + 16 * (v114.i32[0] + v114.i32[1] * (int)v43));
            float32x4_t v116 = vaddq_f32(vsubq_f32(v99, (float32x4_t)v9), v15);
            int32x4_t v117 = vcvtq_s32_f32(v116);
            v116.i64[0] = vaddq_s32(v117, vcgtq_f32(vcvtq_f32_s32(v117), v116)).u64[0];
            float32x4_t v109 = *(float32x4_t *)(v45 + 16 * (v116.i32[0] + v116.i32[1] * (int)v43));
            float32x4_t v118 = vaddq_f32(vsubq_f32(v100, (float32x4_t)v9), v15);
            int32x4_t v119 = vcvtq_s32_f32(v118);
            v118.i64[0] = vaddq_s32(v119, vcgtq_f32(vcvtq_f32_s32(v119), v118)).u64[0];
            float32x4_t v113 = *(float32x4_t *)(v45 + 16 * (v118.i32[0] + v118.i32[1] * (int)v43));
          }
          *(int8x8_t *)v120.f32 = vext_s8(*(int8x8_t *)v101.f32, v96, 4uLL);
          v120.i64[1] = v120.i64[0];
          *(int8x8_t *)v121.f32 = vext_s8(*(int8x8_t *)v109.f32, v97, 4uLL);
          v121.i64[1] = v121.i64[0];
          *(int8x8_t *)v122.f32 = vext_s8(*(int8x8_t *)v113.f32, v98, 4uLL);
          v122.i64[1] = v122.i64[0];
          int8x16_t v123 = (int8x16_t)vsubq_f32(v120, v34);
          int8x16_t v124 = (int8x16_t)vsubq_f32(v121, v35);
          int8x16_t v125 = (int8x16_t)vsubq_f32(v122, v36);
          v120.i64[0] = v31.i64[0];
          v120.i64[1] = v123.i64[1];
          v122.i64[0] = v32.i64[0];
          v122.i64[1] = v124.i64[1];
          v121.i64[0] = v33.i64[0];
          v121.i64[1] = v125.i64[1];
          *(float32x2_t *)v126.i8 = vadd_f32(*(float32x2_t *)v89.f32, vmul_f32(*(float32x2_t *)v37.f32, *(float32x2_t *)v31.i8));
          v126.u64[1] = (unint64_t)v96;
          *(float32x2_t *)v127.i8 = vadd_f32(*(float32x2_t *)v89.f32, vmul_f32(*(float32x2_t *)v37.f32, *(float32x2_t *)v32.i8));
          v127.u64[1] = (unint64_t)v97;
          *(float32x2_t *)v128.i8 = vadd_f32(*(float32x2_t *)v89.f32, vmul_f32(*(float32x2_t *)v37.f32, *(float32x2_t *)v33.i8));
          v128.u64[1] = (unint64_t)v98;
          int8x16_t v129 = vorrq_s8(vandq_s8(v126, v73), vandq_s8(v72, (int8x16_t)vaddq_f32(v120, vmulq_laneq_f32((float32x4_t)vextq_s8(v123, v31, 8uLL), (float32x4_t)v92, 3))));
          int8x16_t v130 = vorrq_s8(vandq_s8(v127, v73), vandq_s8(v72, (int8x16_t)vaddq_f32(v122, vmulq_laneq_f32((float32x4_t)vextq_s8(v124, v32, 8uLL), (float32x4_t)v93, 3))));
          int8x16_t v131 = vorrq_s8(vandq_s8(v128, v73), vandq_s8(v72, (int8x16_t)vaddq_f32(v121, vmulq_laneq_f32((float32x4_t)vextq_s8(v125, v33, 8uLL), (float32x4_t)v94, 3))));
          v31.i64[1] = vdupq_laneq_s64((int64x2_t)v123, 1).u64[0];
          v32.i64[1] = vdupq_laneq_s64((int64x2_t)v124, 1).u64[0];
          v33.i64[1] = vdupq_laneq_s64((int64x2_t)v125, 1).u64[0];
          int8x16_t v132 = (int8x16_t)vcgtq_f32((float32x4_t)v71, (float32x4_t)vrev64q_s32((int32x4_t)v33));
          int8x16_t v133 = vandq_s8(v71, v72);
          int8x16_t v146 = vorrq_s8(vandq_s8(v133, (int8x16_t)vcgtq_f32((float32x4_t)v71, (float32x4_t)vrev64q_s32((int32x4_t)v31))), vandq_s8((int8x16_t)v120, v73));
          int8x16_t v147 = vorrq_s8(vandq_s8(v133, (int8x16_t)vcgtq_f32((float32x4_t)v71, (float32x4_t)vrev64q_s32((int32x4_t)v32))), vandq_s8((int8x16_t)v122, v73));
          int8x16_t v148 = vorrq_s8(vandq_s8(v133, v132), vandq_s8((int8x16_t)v121, v73));
          float32x4_t v135 = *(float32x4_t *)(v21 + 192);
          int8x16_t v134 = *(int8x16_t *)(v21 + 208);
          int8x16_t v136 = vbslq_s8(v134, (int8x16_t)vminq_f32((float32x4_t)v129, v135), v129);
          int8x16_t v137 = vbslq_s8(v134, (int8x16_t)vminq_f32((float32x4_t)v130, v135), v130);
          int8x16_t v138 = vbslq_s8(v134, (int8x16_t)vminq_f32((float32x4_t)v131, v135), v131);
          int8x16_t v139 = vandq_s8(v71, (int8x16_t)vcgeq_f32((float32x4_t)v146, (float32x4_t)v39));
          int8x16_t v140 = vandq_s8(v71, (int8x16_t)vcgeq_f32((float32x4_t)v147, (float32x4_t)v39));
          int8x16_t v141 = vandq_s8(v71, (int8x16_t)vcgeq_f32((float32x4_t)v148, (float32x4_t)v39));
          int8x16_t v142 = *(int8x16_t *)(v21 + 224);
          int8x16_t v143 = vbslq_s8(v142, (int8x16_t)vmulq_n_f32((float32x4_t)vbslq_s8(v142, vextq_s8(v139, v139, 8uLL), v136), *(float *)v146.i32), v136);
          int8x16_t v144 = vbslq_s8(v142, (int8x16_t)vmulq_n_f32((float32x4_t)vbslq_s8(v142, vextq_s8(v140, v140, 8uLL), v137), *(float *)v147.i32), v137);
          int8x16_t v145 = vbslq_s8(v142, (int8x16_t)vmulq_n_f32((float32x4_t)vbslq_s8(v142, vextq_s8(v141, v141, 8uLL), v138), *(float *)v148.i32), v138);
          v146.i64[1] = __PAIR64__(0.5, vmaxq_f32((float32x4_t)vextq_s8(v143, v143, 0xCuLL), *(float32x4_t *)&v71).u32[2]);
          v147.i64[1] = __PAIR64__(0.5, vmaxq_f32((float32x4_t)vextq_s8(v144, v144, 0xCuLL), *(float32x4_t *)&v71).u32[2]);
          v148.i64[1] = __PAIR64__(0.5, vmaxq_f32((float32x4_t)vextq_s8(v145, v145, 0xCuLL), *(float32x4_t *)&v71).u32[2]);
          float32x4_t v149 = (float32x4_t)vextq_s8(v147, v147, 8uLL);
          float32x4_t v150 = (float32x4_t)vextq_s8(v148, v148, 8uLL);
          float32x4_t v151 = vsubq_f32((float32x4_t)vextq_s8(v146, v146, 8uLL), (float32x4_t)v9);
          if (v5)
          {
            int32x4_t v152 = vaddq_s32(vcvtq_s32_f32(v151), vcltzq_f32(v151));
            float32x2_t v153 = (float32x2_t)vsubq_f32(v151, vcvtq_f32_s32(v152)).u64[0];
            float32x4_t v154 = (float32x4_t *)(v45 + 16 * (v152.i32[0] + v152.i32[1] * (int)v43));
            float32x4_t v155 = vaddq_f32(*v154, vmulq_n_f32(vsubq_f32(v154[1], *v154), v153.f32[0]));
            int8x16_t v156 = (int8x16_t)vaddq_f32(v155, vmulq_lane_f32(vsubq_f32(vaddq_f32(v154[v43], vmulq_n_f32(vsubq_f32(v154[(int)v43 + 1], v154[v43]), v153.f32[0])), v155), v153, 1));
            float32x4_t v157 = vsubq_f32(v149, (float32x4_t)v9);
            int32x4_t v158 = vaddq_s32(vcvtq_s32_f32(v157), vcltzq_f32(v157));
            v157.i64[0] = vsubq_f32(v157, vcvtq_f32_s32(v158)).u64[0];
            int8x16_t v159 = (float32x4_t *)(v45 + 16 * (v158.i32[0] + v158.i32[1] * (int)v43));
            float32x4_t v160 = vaddq_f32(*v159, vmulq_n_f32(vsubq_f32(v159[1], *v159), v157.f32[0]));
            int8x16_t v161 = (int8x16_t)vaddq_f32(v160, vmulq_lane_f32(vsubq_f32(vaddq_f32(v159[v43], vmulq_n_f32(vsubq_f32(v159[(int)v43 + 1], v159[v43]), v157.f32[0])), v160), *(float32x2_t *)v157.f32, 1));
            float32x4_t v162 = vsubq_f32(v150, (float32x4_t)v9);
            int32x4_t v163 = vaddq_s32(vcvtq_s32_f32(v162), vcltzq_f32(v162));
            v162.i64[0] = vsubq_f32(v162, vcvtq_f32_s32(v163)).u64[0];
            float32x4_t v164 = (float32x4_t *)(v45 + 16 * (v163.i32[0] + v163.i32[1] * (int)v43));
            float32x4_t v165 = vaddq_f32(*v164, vmulq_n_f32(vsubq_f32(v164[1], *v164), v162.f32[0]));
            int8x16_t v166 = (int8x16_t)vaddq_f32(v165, vmulq_lane_f32(vsubq_f32(vaddq_f32(v164[v43], vmulq_n_f32(vsubq_f32(v164[(int)v43 + 1], v164[v43]), v162.f32[0])), v165), *(float32x2_t *)v162.f32, 1));
          }
          else
          {
            float32x4_t v167 = vaddq_f32(v151, v15);
            int32x4_t v168 = vcvtq_s32_f32(v167);
            v167.i64[0] = vaddq_s32(v168, vcgtq_f32(vcvtq_f32_s32(v168), v167)).u64[0];
            int8x16_t v156 = *(int8x16_t *)(v45 + 16 * (v167.i32[0] + v167.i32[1] * (int)v43));
            float32x4_t v169 = vaddq_f32(vsubq_f32(v149, (float32x4_t)v9), v15);
            int32x4_t v170 = vcvtq_s32_f32(v169);
            v169.i64[0] = vaddq_s32(v170, vcgtq_f32(vcvtq_f32_s32(v170), v169)).u64[0];
            int8x16_t v161 = *(int8x16_t *)(v45 + 16 * (v169.i32[0] + v169.i32[1] * (int)v43));
            float32x4_t v171 = vaddq_f32(vsubq_f32(v150, (float32x4_t)v9), v15);
            int32x4_t v172 = vcvtq_s32_f32(v171);
            v171.i64[0] = vaddq_s32(v172, vcgtq_f32(vcvtq_f32_s32(v172), v171)).u64[0];
            int8x16_t v166 = *(int8x16_t *)(v45 + 16 * (v171.i32[0] + v171.i32[1] * (int)v43));
          }
          int8x16_t v173 = vmvnq_s8(v134);
          int8x16_t v174 = vmvnq_s8(v142);
          int8x16_t v175 = vandq_s8(v143, v173);
          float32x4_t v176 = (float32x4_t)vorrq_s8(vandq_s8(v134, v156), v175);
          int8x16_t v177 = vandq_s8(v144, v173);
          float32x4_t v178 = (float32x4_t)vorrq_s8(vandq_s8(v134, v161), v177);
          int8x16_t v179 = vandq_s8(v145, v173);
          float32x4_t v180 = (float32x4_t)vorrq_s8(vandq_s8(v134, v166), v179);
          float32x4_t v181 = (float32x4_t)vorrq_s8(vandq_s8(v134, (int8x16_t)vaddq_f32((float32x4_t)v146, vmulq_laneq_f32(vsubq_f32(v176, (float32x4_t)v146), v176, 3))), v175);
          float32x4_t v182 = (float32x4_t)vorrq_s8(vandq_s8(v134, (int8x16_t)vaddq_f32((float32x4_t)v147, vmulq_laneq_f32(vsubq_f32(v178, (float32x4_t)v147), v178, 3))), v177);
          float32x4_t v183 = (float32x4_t)vorrq_s8(vandq_s8(v134, (int8x16_t)vaddq_f32((float32x4_t)v148, vmulq_laneq_f32(vsubq_f32(v180, (float32x4_t)v148), v180, 3))), v179);
          float32x4_t v184 = *(float32x4_t *)(v21 + 240);
          float32x4_t v185 = *(float32x4_t *)(v21 + 256);
          float32x4_t v186 = *(float32x4_t *)(v21 + 16);
          float32x4_t v187 = vaddq_f32(vmulq_f32(v186, vsubq_f32(vmaxq_f32(v181, v184), v181)), v181);
          float32x4_t v188 = vaddq_f32(vmulq_f32(v186, vsubq_f32(vmaxq_f32(v182, v184), v182)), v182);
          float32x4_t v189 = vaddq_f32(vmulq_f32(v186, vsubq_f32(vmaxq_f32(v183, v184), v183)), v183);
          float32x4_t v190 = vminq_f32(v188, v185);
          float32x4_t v191 = *(float32x4_t *)(v21 + 32);
          int8x16_t v192 = (int8x16_t)vaddq_f32(v187, vmulq_f32(v191, vsubq_f32(vminq_f32(v187, v185), v187)));
          int8x16_t v193 = (int8x16_t)vaddq_f32(v189, vmulq_f32(v191, vsubq_f32(vminq_f32(v189, v185), v189)));
          int8x16_t v194 = vandq_s8(v142, v18);
          int8x16_t v195 = vandq_s8(v142, v19);
          int8x16_t v196 = vandq_s8(v142, v20);
          float32x4_t v197 = vaddq_f32((float32x4_t)v18, vmulq_f32(*(float32x4_t *)v21, vsubq_f32((float32x4_t)vorrq_s8(vandq_s8((int8x16_t)vmulq_laneq_f32((float32x4_t)vorrq_s8(vandq_s8(v192, v174), v194), (float32x4_t)v18, 3), v174), v194), (float32x4_t)v18)));
          float32x4_t v198 = vaddq_f32((float32x4_t)v19, vmulq_f32(*(float32x4_t *)v21, vsubq_f32((float32x4_t)vorrq_s8(vandq_s8((int8x16_t)vmulq_laneq_f32((float32x4_t)vorrq_s8(vandq_s8((int8x16_t)vaddq_f32(v188, vmulq_f32(v191, vsubq_f32(v190, v188))), v174), v195), (float32x4_t)v19, 3), v174),
                                      v195),
                       (float32x4_t)v19)));
          float32x4_t v199 = vaddq_f32((float32x4_t)v20, vmulq_f32(*(float32x4_t *)v21, vsubq_f32((float32x4_t)vorrq_s8(vandq_s8((int8x16_t)vmulq_laneq_f32((float32x4_t)vorrq_s8(vandq_s8(v193, v174), v196), (float32x4_t)v20, 3), v174), v196), (float32x4_t)v20)));
          float32x4_t v200 = (float32x4_t *)(v11 + v16);
          *float32x4_t v200 = v197;
          v200[1] = v198;
          v200[2] = v199;
          v17 -= 3;
          v16 += 48;
        }
        while (v10 + v17 > 2);
        LODWORD(v201) = -v17;
      }
      if ((int)v201 < v10)
      {
        uint64_t v201 = v201;
        do
        {
          int8x16_t v202 = *(int8x16_t *)(v12 + 16 * v201);
          uint64_t v203 = *((void *)this + 51);
          float32x4_t v204 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v202, 3), *(float32x4_t *)(v203 + 48));
          float32x4_t v205 = vmulq_f32(vrecpeq_f32(v204), *(float32x4_t *)(v203 + 64));
          int8x16_t v206 = (int8x16_t)vmulq_f32((float32x4_t)v202, vmulq_f32(v205, vrecpsq_f32(v205, v204)));
          float32x4_t v207 = (float32x4_t)vextq_s8(v206, v206, 8uLL);
          float32x4_t v209 = *(float32x4_t *)(v203 + 80);
          float32x4_t v208 = *(float32x4_t *)(v203 + 96);
          int8x16_t v210 = *(int8x16_t *)(v203 + 112);
          float32x4_t v211 = vmaxq_f32(vminq_f32(vaddq_f32(v209, vmulq_f32(v208, v207)), v208), (float32x4_t)v210);
          v211.i32[1] = 0.5;
          uint64_t v212 = *((int *)a2 + 26);
          float32x4_t v213 = vsubq_f32(v211, (float32x4_t)v9);
          uint64_t v214 = *((void *)a2 + 12);
          if (v5)
          {
            int32x4_t v215 = vaddq_s32(vcvtq_s32_f32(v213), vcltzq_f32(v213));
            float32x2_t v216 = (float32x2_t)vsubq_f32(v213, vcvtq_f32_s32(v215)).u64[0];
            float32x4_t v217 = (float32x4_t *)(v214 + 16 * (v215.i32[0] + v215.i32[1] * (int)v212));
            float32x4_t v218 = vaddq_f32(*v217, vmulq_n_f32(vsubq_f32(v217[1], *v217), v216.f32[0]));
            int8x16_t v219 = (int8x16_t)vaddq_f32(v218, vmulq_lane_f32(vsubq_f32(vaddq_f32(v217[v212], vmulq_n_f32(vsubq_f32(v217[(int)v212 + 1], v217[v212]), v216.f32[0])), v218), v216, 1));
          }
          else
          {
            float32x4_t v220 = vaddq_f32(v213, v15);
            int32x4_t v221 = vcvtq_s32_f32(v220);
            v220.i64[0] = vaddq_s32(v221, vcgtq_f32(vcvtq_f32_s32(v221), v220)).u64[0];
            int8x16_t v219 = *(int8x16_t *)(v214 + 16 * (v220.i32[0] + v220.i32[1] * (int)v212));
          }
          int8x16_t v222 = vandq_s8(v210, (int8x16_t)vcgeq_f32((float32x4_t)v206, (float32x4_t)v210));
          int8x16_t v223 = vextq_s8(v222, v222, 8uLL);
          int8x16_t v225 = *(int8x16_t *)(v203 + 128);
          int8x16_t v224 = *(int8x16_t *)(v203 + 144);
          v226.i64[0] = vbslq_s8(v225, v223, v219).u64[0];
          v226.i64[1] = vsubq_f32(*(float32x4_t *)&v210, (float32x4_t)vdupq_lane_s64(*(uint64_t *)&v226, 0)).i64[1];
          float32x4_t v227 = (float32x4_t)vbslq_s8(v225, vandq_s8(v224, (int8x16_t)vcgeq_f32(v207, (float32x4_t)v210)), v226);
          int8x16_t v228 = vbslq_s8(v225, (int8x16_t)vmulq_laneq_f32(v227, v227, 2), v226);
          float32x4_t v229 = (float32x4_t)vrev64q_s32((int32x4_t)v206);
          int8x16_t v231 = *(int8x16_t *)(v203 + 160);
          float32x4_t v230 = *(float32x4_t *)(v203 + 176);
          v232.i64[0] = vandq_s8(v224, (int8x16_t)vcgeq_f32(v229, (float32x4_t)v210)).u64[0];
          v232.i64[1] = vbslq_s8(v231, (int8x16_t)vaddq_f32(*(float32x4_t *)&v206, vmulq_n_f32(vsubq_f32((float32x4_t)vextq_s8(v9, v228, 0xCuLL), *(float32x4_t *)&v206), *(float *)&v228)), (int8x16_t)vsubq_f32(*(float32x4_t *)&v224, (float32x4_t)vdupq_lane_s64((uint64_t)vandq_s8(v224, (int8x16_t)vcgeq_f32(v229, *(float32x4_t *)&v224)), 0))).i64[1];
          int8x16_t v233 = vbslq_s8(v231, v232, (int8x16_t)vmulq_lane_f32((float32x4_t)v232, *(float32x2_t *)v232.i8, 1));
          v234.i64[0] = vaddq_f32(v209, vmulq_f32((float32x4_t)v206, v208)).u64[0];
          v234.i64[1] = v233.i64[1];
          v234.i64[0] = vminq_f32(v234, v208).u64[0];
          v234.i64[1] = v233.i64[1];
          v234.i32[0] = vmaxq_f32(v234, v230).u32[0];
          v234.i64[1] = v233.i64[1];
          v234.i32[1] = 0.5;
          float32x4_t v235 = vsubq_f32(v234, (float32x4_t)v9);
          if (v5)
          {
            int32x4_t v236 = vaddq_s32(vcvtq_s32_f32(v235), vcltzq_f32(v235));
            float32x2_t v237 = (float32x2_t)vsubq_f32(v235, vcvtq_f32_s32(v236)).u64[0];
            float32x4_t v238 = (float32x4_t *)(v214 + 16 * (v236.i32[0] + v236.i32[1] * (int)v212));
            float32x4_t v239 = vaddq_f32(*v238, vmulq_n_f32(vsubq_f32(v238[1], *v238), v237.f32[0]));
            v235.i64[0] = vaddq_f32(v239, vmulq_lane_f32(vsubq_f32(vaddq_f32(v238[v212], vmulq_n_f32(vsubq_f32(v238[(int)v212 + 1], v238[v212]), v237.f32[0])), v239), v237, 1)).u64[0];
          }
          else
          {
            float32x4_t v240 = vaddq_f32(v235, v15);
            int32x4_t v241 = vcvtq_s32_f32(v240);
            v240.i64[0] = vaddq_s32(v241, vcgtq_f32(vcvtq_f32_s32(v241), v240)).u64[0];
            float32x4_t v235 = *(float32x4_t *)(v214 + 16 * (v240.i32[0] + v240.i32[1] * (int)v212));
          }
          int8x8_t v242 = (int8x8_t)vextq_s8(v233, v233, 8uLL).u64[0];
          *(int8x8_t *)v243.f32 = vext_s8(*(int8x8_t *)v235.f32, v242, 4uLL);
          v243.i64[1] = v243.i64[0];
          int8x16_t v244 = (int8x16_t)vsubq_f32(v243, v207);
          v243.i64[0] = v206.i64[0];
          v243.i64[1] = v244.i64[1];
          *(float32x2_t *)v245.i8 = vadd_f32(*(float32x2_t *)v230.f32, vmul_f32(*(float32x2_t *)v208.f32, *(float32x2_t *)v206.i8));
          v245.u64[1] = (unint64_t)v242;
          int8x16_t v246 = vmvnq_s8(v225);
          int8x16_t v247 = vorrq_s8(vandq_s8(v245, v246), vandq_s8(v225, (int8x16_t)vaddq_f32(v243, vmulq_laneq_f32((float32x4_t)vextq_s8(v244, v206, 8uLL), (float32x4_t)v233, 3))));
          v206.i64[1] = vdupq_laneq_s64((int64x2_t)v244, 1).u64[0];
          int8x16_t v253 = vorrq_s8(vandq_s8(vandq_s8(v224, v225), (int8x16_t)vcgtq_f32((float32x4_t)v224, (float32x4_t)vrev64q_s32((int32x4_t)v206))), vandq_s8((int8x16_t)v243, v246));
          int8x16_t v248 = *(int8x16_t *)(v203 + 208);
          int8x16_t v249 = vbslq_s8(v248, (int8x16_t)vminq_f32((float32x4_t)v247, *(float32x4_t *)(v203 + 192)), v247);
          int8x16_t v250 = vandq_s8(v224, (int8x16_t)vcgeq_f32((float32x4_t)v253, (float32x4_t)v210));
          int8x16_t v251 = *(int8x16_t *)(v203 + 224);
          int8x16_t v252 = vbslq_s8(v251, (int8x16_t)vmulq_n_f32((float32x4_t)vbslq_s8(v251, vextq_s8(v250, v250, 8uLL), v249), *(float *)v253.i32), v249);
          v253.i64[1] = __PAIR64__(0.5, vmaxq_f32((float32x4_t)vextq_s8(v252, v252, 0xCuLL), *(float32x4_t *)&v224).u32[2]);
          float32x4_t v254 = vsubq_f32((float32x4_t)vextq_s8(v253, v253, 8uLL), (float32x4_t)v9);
          if (v5)
          {
            int32x4_t v255 = vaddq_s32(vcvtq_s32_f32(v254), vcltzq_f32(v254));
            float32x2_t v256 = (float32x2_t)vsubq_f32(v254, vcvtq_f32_s32(v255)).u64[0];
            float32x4_t v257 = (float32x4_t *)(v214 + 16 * (v255.i32[0] + v255.i32[1] * (int)v212));
            float32x4_t v258 = vaddq_f32(*v257, vmulq_n_f32(vsubq_f32(v257[1], *v257), v256.f32[0]));
            int8x16_t v259 = (int8x16_t)vaddq_f32(v258, vmulq_lane_f32(vsubq_f32(vaddq_f32(v257[v212], vmulq_n_f32(vsubq_f32(v257[(int)v212 + 1], v257[v212]), v256.f32[0])), v258), v256, 1));
          }
          else
          {
            float32x4_t v260 = vaddq_f32(v254, v15);
            int32x4_t v261 = vcvtq_s32_f32(v260);
            v260.i64[0] = vaddq_s32(v261, vcgtq_f32(vcvtq_f32_s32(v261), v260)).u64[0];
            int8x16_t v259 = *(int8x16_t *)(v214 + 16 * (v260.i32[0] + v260.i32[1] * (int)v212));
          }
          int8x16_t v262 = vmvnq_s8(v251);
          int8x16_t v263 = vandq_s8(v252, vmvnq_s8(v248));
          float32x4_t v264 = (float32x4_t)vorrq_s8(vandq_s8(v248, v259), v263);
          float32x4_t v265 = (float32x4_t)vorrq_s8(vandq_s8(v248, (int8x16_t)vaddq_f32((float32x4_t)v253, vmulq_laneq_f32(vsubq_f32(v264, (float32x4_t)v253), v264, 3))), v263);
          float32x4_t v266 = vaddq_f32(vmulq_f32(*(float32x4_t *)(v203 + 16), vsubq_f32(vmaxq_f32(v265, *(float32x4_t *)(v203 + 240)), v265)), v265);
          int8x16_t v267 = vandq_s8(v251, v202);
          *(float32x4_t *)(v11 + 16 * v201++) = vaddq_f32((float32x4_t)v202, vmulq_f32(*(float32x4_t *)v203, vsubq_f32((float32x4_t)vorrq_s8(vandq_s8((int8x16_t)vmulq_laneq_f32((float32x4_t)vorrq_s8(vandq_s8((int8x16_t)vaddq_f32(v266, vmulq_f32(*(float32x4_t *)(v203 + 32), vsubq_f32(vminq_f32(v266, *(float32x4_t *)(v203 + 256)), v266))), v262), v267), (float32x4_t)v202, 3), v262), v267), (float32x4_t)v202)));
        }
        while (v201 < v10);
      }
      ++v8;
      v11 += v13;
      v12 += v14;
    }
    while (v8 != v7);
  }
  return 0;
}

uint64_t HgcContrastBezierRGB::GetDOD(HgcContrastBezierRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  uint64_t v4 = *(void *)&a4.var2;
  uint64_t v5 = *(void *)&a4.var0;
  if (a3 == 1)
  {
    if ((*(int (**)(HgcContrastBezierRGB *, HGRenderer *))(*(void *)this + 312))(this, a2) >= 1)
    {
      uint64_t v7 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
      HGRectGrow(v5, v4, v7);
    }
    int32x2_t v6 = &HGRectInfinite;
    return *(void *)v6;
  }
  if (a3)
  {
    int32x2_t v6 = &HGRectNull;
    return *(void *)v6;
  }
  return v5;
}

uint64_t HgcContrastBezierRGB::GetROI(HGNode *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3 == 1)
  {
    Input = HGRenderer::GetInput(a2, this, 1u);
    uint64_t DOD = HGRenderer::GetDOD(a2, Input);
    uint64_t v9 = v8;
    if ((*(int (**)(HGNode *, HGRenderer *))(*(void *)this + 312))(this, a2) >= 1)
    {
      uint64_t v10 = HGRectMake4i(0xFFFFFFFF, 0xFFFFFFFF, 1u, 1u);
      return HGRectGrow(DOD, v9, v10);
    }
  }
  else if (a3)
  {
    return 0;
  }
  else
  {
    return *(void *)&a4.var0;
  }
  return DOD;
}

void HgcContrastBezierRGB::HgcContrastBezierRGB(HgcContrastBezierRGB *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F1117EA0;
  operator new();
}

void sub_1B7A54270(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcContrastBezierRGB::~HgcContrastBezierRGB(HGNode *this)
{
  *(void *)this = &unk_1F1117EA0;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40B2834900);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcContrastBezierRGB::~HgcContrastBezierRGB(this);

  HGObject::operator delete(v1);
}

uint64_t HgcContrastBezierRGB::SetParameter(HgcContrastBezierRGB *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  switch(a2)
  {
    case 2:
      uint64_t v9 = *((void *)this + 51);
      if (*(float *)(v9 + 32) != a3.n128_f32[0]
        || *(float *)(v9 + 36) != a3.n128_f32[0]
        || *(float *)(v9 + 40) != a3.n128_f32[0]
        || *(float *)(v9 + 44) != 0.0)
      {
        int32x4_t v10 = vzip1q_s32((int32x4_t)a3.n128_u32[0], (int32x4_t)a3.n128_u32[0]);
        v10.i32[2] = a3.n128_u32[0];
        a3.n128_f32[1] = a4;
        *(int32x4_t *)(v9 + 32) = v10;
        a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
        *(__n128 *)(v9 + 304) = a3;
        goto LABEL_19;
      }
      return 0;
    case 1:
      uint64_t v11 = *((void *)this + 51);
      if (*(float *)(v11 + 16) != a3.n128_f32[0]
        || *(float *)(v11 + 20) != a3.n128_f32[0]
        || *(float *)(v11 + 24) != a3.n128_f32[0]
        || *(float *)(v11 + 28) != 0.0)
      {
        int32x4_t v12 = vzip1q_s32((int32x4_t)a3.n128_u32[0], (int32x4_t)a3.n128_u32[0]);
        v12.i32[2] = a3.n128_u32[0];
        a3.n128_f32[1] = a4;
        *(int32x4_t *)(v11 + 16) = v12;
        a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
        *(__n128 *)(v11 + 288) = a3;
        goto LABEL_19;
      }
      return 0;
    case 0:
      uint64_t v7 = *((void *)this + 51);
      if (*(float *)v7 != a3.n128_f32[0]
        || *(float *)(v7 + 4) != a3.n128_f32[0]
        || *(float *)(v7 + 8) != a3.n128_f32[0]
        || *(float *)(v7 + 12) != a3.n128_f32[0])
      {
        int32x4_t v8 = vdupq_lane_s32((int32x2_t)a3.n128_u64[0], 0);
        a3.n128_f32[1] = a4;
        *(int32x4_t *)uint64_t v7 = v8;
        a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
        *(__n128 *)(v7 + 272) = a3;
LABEL_19:
        HGNode::ClearBits((HGNode *)this, a2, a7);
        return 1;
      }
      return 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t HgcContrastBezierRGB::GetParameter(HgcContrastBezierRGB *this, int a2, float *a3)
{
  switch(a2)
  {
    case 2:
      uint64_t v5 = (float *)*((void *)this + 51);
      *a3 = v5[76];
      a3[1] = v5[77];
      a3[2] = v5[78];
      uint64_t v4 = v5 + 79;
      goto LABEL_7;
    case 1:
      int32x2_t v6 = (float *)*((void *)this + 51);
      *a3 = v6[72];
      a3[1] = v6[73];
      a3[2] = v6[74];
      uint64_t v4 = v6 + 75;
      goto LABEL_7;
    case 0:
      int v3 = (float *)*((void *)this + 51);
      *a3 = v3[68];
      a3[1] = v3[69];
      a3[2] = v3[70];
      uint64_t v4 = v3 + 71;
LABEL_7:
      uint64_t result = 0;
      a3[3] = *v4;
      return result;
  }
  return 0xFFFFFFFFLL;
}

const char *HgcContrastLuma::GetProgram(HgcContrastLuma *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=000000065e\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(0.2989999950, 0.5870000124, 0.1140000001, 0.000000000);\n"
             "    const half4 c1 = half4(0.5960000157, -0.2750000060, -0.3210000098, 0.000000000);\n"
             "    const half4 c2 = half4(0.2119999975, -0.5230000019, 0.3109999895, 0.000000000);\n"
             "    const half4 c3 = half4(1.000000000, -1.106999993, 1.703999996, 0.000000000);\n"
             "    const half4 c4 = half4(1.000000000, 0.9559999704, 0.6209999919, 0.000000000);\n"
             "    const half4 c5 = half4(1.000000000, -0.2720000148, -0.6470000148, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 6.10350e-05h);\n"
             "    r2.x = dot(r1.xyz, c0.xyz);\n"
             "    r2.y = dot(r1.xyz, c1.xyz);\n"
             "    r2.z = dot(r1.xyz, c2.xyz);\n"
             "    r2.x = mix(half(hg_Params[0].x), r2.x, half(hg_Params[1].x));\n"
             "    r1.z = dot(r2.xyz, c3.xyz);\n"
             "    r1.x = dot(r2.xyz, c4.xyz);\n"
             "    r1.y = dot(r2.xyz, c5.xyz);\n"
             "    r2.xyz = fmax(r1.xyz, c5.www);\n"
             "    r2.xyz = mix(r1.xyz, r2.xyz, half3(hg_Params[3].xyz));\n"
             "    r1.xyz = fmin(r2.xyz, c5.xxx);\n"
             "    r2.xyz = mix(r2.xyz, r1.xyz, half3(hg_Params[4].xyz));\n"
             "    r2.w = r0.w;\n"
             "    r2.xyz = r2.xyz*r0.www;\n"
             "    output.color0 = mix(float4(r0), float4(r2), hg_Params[2]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=e7b7ef63:1f75403f:fcd380dc:4a8f4b11\n"
             "//SIG=00400000:00000001:00000001:00000001:0006:0005:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000063a\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(0.2989999950, 0.5870000124, 0.1140000001, 0.000000000);\n"
             "    const float4 c1 = float4(0.5960000157, -0.2750000060, -0.3210000098, 0.000000000);\n"
             "    const float4 c2 = float4(0.2119999975, -0.5230000019, 0.3109999895, 0.000000000);\n"
             "    const float4 c3 = float4(1.000000000, -1.106999993, 1.703999996, 0.000000000);\n"
             "    const float4 c4 = float4(1.000000000, 0.9559999704, 0.6209999919, 0.000000000);\n"
             "    const float4 c5 = float4(1.000000000, -0.2720000148, -0.6470000148, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
             "    r2.x = dot(r1.xyz, c0.xyz);\n"
             "    r2.y = dot(r1.xyz, c1.xyz);\n"
             "    r2.z = dot(r1.xyz, c2.xyz);\n"
             "    r2.x = mix(hg_Params[0].x, r2.x, hg_Params[1].x);\n"
             "    r1.z = dot(r2.xyz, c3.xyz);\n"
             "    r1.x = dot(r2.xyz, c4.xyz);\n"
             "    r1.y = dot(r2.xyz, c5.xyz);\n"
             "    r2.xyz = fmax(r1.xyz, c5.www);\n"
             "    r2.xyz = mix(r1.xyz, r2.xyz, hg_Params[3].xyz);\n"
             "    r1.xyz = fmin(r2.xyz, c5.xxx);\n"
             "    r2.xyz = mix(r2.xyz, r1.xyz, hg_Params[4].xyz);\n"
             "    r2.w = r0.w;\n"
             "    r2.xyz = r2.xyz*r0.www;\n"
             "    output.color0 = mix(r0, r2, hg_Params[2]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=6eafd8e8:89bd116a:656e9665:d1839915\n"
             "//SIG=00000000:00000001:00000001:00000000:0006:0005:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=00000006c6\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "uniform mediump vec4 hg_ProgramLocal3;\n"
           "uniform mediump vec4 hg_ProgramLocal4;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(0.2989999950, 0.5870000124, 0.1140000001, 0.000000000);\n"
           "    const mediump vec4 c1 = vec4(0.5960000157, -0.2750000060, -0.3210000098, 0.000000000);\n"
           "    const mediump vec4 c2 = vec4(0.2119999975, -0.5230000019, 0.3109999895, 0.000000000);\n"
           "    const mediump vec4 c3 = vec4(1.000000000, -1.106999993, 1.703999996, 0.000000000);\n"
           "    const mediump vec4 c4 = vec4(1.000000000, 0.9559999704, 0.6209999919, 0.000000000);\n"
           "    const mediump vec4 c5 = vec4(1.000000000, -0.2720000148, -0.6470000148, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.xyz = r0.xyz / max(r0.w, 1.00000e-06);\n"
           "    r2.x = dot(r1.xyz, c0.xyz);\n"
           "    r2.y = dot(r1.xyz, c1.xyz);\n"
           "    r2.z = dot(r1.xyz, c2.xyz);\n"
           "    r2.x = mix(hg_ProgramLocal0.x, r2.x, hg_ProgramLocal1.x);\n"
           "    r1.z = dot(r2.xyz, c3.xyz);\n"
           "    r1.x = dot(r2.xyz, c4.xyz);\n"
           "    r1.y = dot(r2.xyz, c5.xyz);\n"
           "    r2.xyz = max(r1.xyz, c5.www);\n"
           "    r2.xyz = mix(r1.xyz, r2.xyz, hg_ProgramLocal3.xyz);\n"
           "    r1.xyz = min(r2.xyz, c5.xxx);\n"
           "    r2.xyz = mix(r2.xyz, r1.xyz, hg_ProgramLocal4.xyz);\n"
           "    r2.w = r0.w;\n"
           "    r2.xyz = r2.xyz*r0.www;\n"
           "    gl_FragColor = mix(r0, r2, hg_ProgramLocal2);\n"
           "}\n"
           "//MD5=a902954f:31d8ce2e:fdaac8d6:07d506fb\n"
           "//SIG=00000000:00000001:00000001:00000000:0006:0005:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcContrastLuma::InitProgramDescriptor(HgcContrastLuma *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcContrastLuma_hgc_visible", "//Metal1.0     \n//LEN=0000000513\n[[ visible ]] FragmentOut HgcContrastLuma_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(0.2989999950, 0.5870000124, 0.1140000001, 0.000000000);\n"
    "    const float4 c1 = float4(0.5960000157, -0.2750000060, -0.3210000098, 0.000000000);\n"
    "    const float4 c2 = float4(0.2119999975, -0.5230000019, 0.3109999895, 0.000000000);\n"
    "    const float4 c3 = float4(1.000000000, -1.106999993, 1.703999996, 0.000000000);\n"
    "    const float4 c4 = float4(1.000000000, 0.9559999704, 0.6209999919, 0.000000000);\n"
    "    const float4 c5 = float4(1.000000000, -0.2720000148, -0.6470000148, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.xyz = r0.xyz / fmax(r0.w, 1.00000e-06f);\n"
    "    r2.x = dot(r1.xyz, c0.xyz);\n"
    "    r2.y = dot(r1.xyz, c1.xyz);\n"
    "    r2.z = dot(r1.xyz, c2.xyz);\n"
    "    r2.x = mix(hg_Params[0].x, r2.x, hg_Params[1].x);\n"
    "    r1.z = dot(r2.xyz, c3.xyz);\n"
    "    r1.x = dot(r2.xyz, c4.xyz);\n"
    "    r1.y = dot(r2.xyz, c5.xyz);\n"
    "    r2.xyz = fmax(r1.xyz, c5.www);\n"
    "    r2.xyz = mix(r1.xyz, r2.xyz, hg_Params[3].xyz);\n"
    "    r1.xyz = fmin(r2.xyz, c5.xxx);\n"
    "    r2.xyz = mix(r2.xyz, r1.xyz, hg_Params[4].xyz);\n"
    "    r2.w = r0.w;\n"
    "    r2.xyz = r2.xyz*r0.www;\n"
    "    output.color0 = mix(r0, r2, hg_Params[2]);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcContrastLuma");
}

void sub_1B7A54608(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75C50;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  int8x16_t v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7A54708(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7A54748()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7A54740);
}

void *HgcContrastLuma::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcContrastLuma [hgc1]");
}

uint64_t HgcContrastLuma::BindTexture(HgcContrastLuma *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcContrastLuma::Bind(HgcContrastLuma *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcContrastLuma::RenderTile(HgcContrastLuma *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 6);
    uint64_t v8 = 16 * *((int *)a2 + 22);
    do
    {
      if (v4 < 3)
      {
        LODWORD(v80) = 0;
      }
      else
      {
        uint64_t v9 = 0;
        int v10 = 0;
        do
        {
          float32x4_t v11 = *(float32x4_t *)(v6 + v9);
          float32x4_t v12 = *(float32x4_t *)(v6 + v9 + 16);
          float32x4_t v13 = *(float32x4_t *)(v6 + v9 + 32);
          uint64_t v14 = *((void *)this + 51);
          float32x4_t v16 = *(float32x4_t *)(v14 + 64);
          float32x4_t v15 = *(float32x4_t *)(v14 + 80);
          float32x4_t v17 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 3), v15);
          float32x4_t v18 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 3), v15);
          float32x4_t v19 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 3), v15);
          float32x4_t v20 = *(float32x4_t *)(v14 + 96);
          float32x4_t v21 = *(float32x4_t *)(v14 + 112);
          float32x4_t v22 = vmulq_f32(vrecpeq_f32(v17), v20);
          float32x4_t v23 = vmulq_f32(vrecpeq_f32(v18), v20);
          float32x4_t v24 = vmulq_f32(vrecpeq_f32(v19), v20);
          float32x4_t v25 = vmulq_f32(v11, vmulq_f32(v22, vrecpsq_f32(v22, v17)));
          float32x4_t v26 = vmulq_f32(v12, vmulq_f32(v23, vrecpsq_f32(v23, v18)));
          float32x4_t v27 = vmulq_f32(v13, vmulq_f32(v24, vrecpsq_f32(v24, v19)));
          float32x4_t v28 = vmulq_f32(v25, v21);
          float32x4_t v29 = vmulq_f32(v26, v21);
          float32x4_t v30 = vmulq_f32(v21, v27);
          float32x4_t v31 = *(float32x4_t *)(v14 + 128);
          int8x16_t v32 = *(int8x16_t *)(v14 + 144);
          float32x4_t v33 = vmulq_f32(v25, v31);
          float32x4_t v34 = vmulq_f32(v26, v31);
          float32x4_t v35 = vmulq_f32(v27, v31);
          int8x16_t v36 = (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v35, (int8x16_t)v11, 4uLL), vaddq_f32(v35, (float32x4_t)vrev64q_s32((int32x4_t)v35)));
          float32x4_t v38 = *(float32x4_t *)(v14 + 160);
          float32x4_t v37 = *(float32x4_t *)(v14 + 176);
          float32x4_t v39 = vmulq_f32(v25, v38);
          float32x4_t v40 = vmulq_f32(v26, v38);
          float32x4_t v41 = vmulq_f32(v27, v38);
          v28.i64[0] = vbslq_s8(v32, (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s64((int64x2_t)v28, 1), vaddq_f32(v28, (float32x4_t)vrev64q_s32((int32x4_t)v28))), (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v33, (int8x16_t)v11, 4uLL), vaddq_f32(v33, (float32x4_t)vrev64q_s32((int32x4_t)v33)))).u64[0];
          v29.i64[0] = vbslq_s8(v32, (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s64((int64x2_t)v29, 1), vaddq_f32(v29, (float32x4_t)vrev64q_s32((int32x4_t)v29))), (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v34, (int8x16_t)v11, 4uLL), vaddq_f32(v34, (float32x4_t)vrev64q_s32((int32x4_t)v34)))).u64[0];
          v30.i64[0] = vbslq_s8(v32, (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s64((int64x2_t)v30, 1), vaddq_f32(v30, (float32x4_t)vrev64q_s32((int32x4_t)v30))), v36).u64[0];
          v28.i64[1] = vaddq_f32(v39, vaddq_f32((float32x4_t)vdupq_lane_s64(*(uint64_t *)&v39, 0), (float32x4_t)vextq_s8(*(int8x16_t *)&v11, *(int8x16_t *)&v39, 0xCuLL))).i64[1];
          v29.i64[1] = vaddq_f32(v40, vaddq_f32((float32x4_t)vdupq_lane_s64(*(uint64_t *)&v40, 0), (float32x4_t)vextq_s8(*(int8x16_t *)&v11, *(int8x16_t *)&v40, 0xCuLL))).i64[1];
          v30.i64[1] = vaddq_f32(v41, vaddq_f32((float32x4_t)vdupq_lane_s64(*(uint64_t *)&v41, 0), (float32x4_t)vextq_s8(*(int8x16_t *)&v11, *(int8x16_t *)&v41, 0xCuLL))).i64[1];
          float32x4_t v42 = *(float32x4_t *)(v14 + 16);
          int8x16_t v43 = (int8x16_t)vaddq_f32(*(float32x4_t *)v14, vmulq_f32(v42, vsubq_f32(v29, *(float32x4_t *)v14)));
          int8x16_t v44 = (int8x16_t)vaddq_f32(*(float32x4_t *)v14, vmulq_f32(v42, vsubq_f32(v30, *(float32x4_t *)v14)));
          float32x4_t v45 = (float32x4_t)vbslq_s8(v32, (int8x16_t)vaddq_f32(*(float32x4_t *)v14, vmulq_f32(v42, vsubq_f32(v28, *(float32x4_t *)v14))), (int8x16_t)v28);
          float32x4_t v46 = (float32x4_t)vbslq_s8(v32, v43, (int8x16_t)v29);
          float32x4_t v47 = (float32x4_t)vbslq_s8(v32, v44, (int8x16_t)v30);
          int64x2_t v48 = (int64x2_t)vmulq_f32(v37, v45);
          float32x4_t v49 = vmulq_f32(v37, v46);
          int64x2_t v50 = (int64x2_t)vmulq_f32(v37, v47);
          float32x4_t v51 = *(float32x4_t *)(v14 + 192);
          float32x4_t v52 = *(float32x4_t *)(v14 + 208);
          float32x4_t v53 = vmulq_f32(v51, v45);
          float32x4_t v54 = vmulq_f32(v51, v46);
          float32x4_t v55 = vmulq_f32(v51, v47);
          v34.i64[0] = vrev64q_s32((int32x4_t)v53).u64[0];
          v56.i64[0] = vrev64q_s32((int32x4_t)v54).u64[0];
          float32x4_t v57 = (float32x4_t)vzip2q_s64((int64x2_t)v53, v48);
          v34.i64[1] = vextq_s8(*(int8x16_t *)&v11, *(int8x16_t *)&v48, 0xCuLL).i64[1];
          v53.i64[1] = v48.i64[0];
          float32x4_t v58 = (float32x4_t)vzip2q_s64((int64x2_t)v54, (int64x2_t)v49);
          v56.i64[1] = vextq_s8(*(int8x16_t *)&v11, *(int8x16_t *)&v49, 0xCuLL).i64[1];
          v54.i64[1] = v49.i64[0];
          v49.i64[0] = vrev64q_s32((int32x4_t)v55).u64[0];
          v49.i64[1] = vextq_s8(*(int8x16_t *)&v11, *(int8x16_t *)&v50, 0xCuLL).i64[1];
          float32x4_t v59 = (float32x4_t)vzip2q_s64((int64x2_t)v55, v50);
          v55.i64[1] = v50.i64[0];
          float32x4_t v60 = vmulq_f32(v52, v45);
          float32x4_t v61 = vmulq_f32(v52, v46);
          float32x4_t v62 = vmulq_f32(v52, v47);
          int8x16_t v63 = (int8x16_t)vaddq_f32(v59, vaddq_f32(v55, v49));
          int8x16_t v64 = *(int8x16_t *)(v14 + 224);
          float32x4_t v65 = *(float32x4_t *)(v14 + 240);
          float32x4_t v66 = (float32x4_t)vbslq_s8(v64, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v60, (int8x16_t)v60, 4uLL), vaddq_f32(v60, (float32x4_t)vrev64q_s32((int32x4_t)v60))), (int8x16_t)vaddq_f32(v57, vaddq_f32(v53, v34)));
          float32x4_t v67 = (float32x4_t)vbslq_s8(v64, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v61, (int8x16_t)v61, 4uLL), vaddq_f32(v61, (float32x4_t)vrev64q_s32((int32x4_t)v61))), (int8x16_t)vaddq_f32(v58, vaddq_f32(v54, v56)));
          float32x4_t v68 = (float32x4_t)vbslq_s8(v64, (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v62, (int8x16_t)v62, 4uLL), vaddq_f32(v62, (float32x4_t)vrev64q_s32((int32x4_t)v62))), v63);
          float32x4_t v69 = vsubq_f32(vmaxq_f32(v66, v65), v66);
          float32x4_t v70 = vsubq_f32(vmaxq_f32(v67, v65), v67);
          float32x4_t v71 = vsubq_f32(vmaxq_f32(v68, v65), v68);
          float32x4_t v73 = *(float32x4_t *)(v14 + 32);
          float32x4_t v72 = *(float32x4_t *)(v14 + 48);
          float32x4_t v74 = vaddq_f32(vmulq_f32(v72, v69), v66);
          float32x4_t v75 = vaddq_f32(vmulq_f32(v72, v70), v67);
          float32x4_t v76 = vaddq_f32(vmulq_f32(v72, v71), v68);
          float32x4_t v77 = *(float32x4_t *)(v14 + 256);
          int8x16_t v78 = *(int8x16_t *)(v14 + 272);
          float32x4_t v79 = (float32x4_t *)(v5 + v9);
          *float32x4_t v79 = vaddq_f32(v11, vmulq_f32(v73, vsubq_f32((float32x4_t)vbslq_s8(v78, (int8x16_t)v11, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v78, (int8x16_t)v11, (int8x16_t)vaddq_f32(v74, vmulq_f32(v16, vsubq_f32(vminq_f32(v74, v77), v74)))), v11, 3)), v11)));
          v79[1] = vaddq_f32(v12, vmulq_f32(v73, vsubq_f32((float32x4_t)vbslq_s8(v78, (int8x16_t)v12, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v78, (int8x16_t)v12, (int8x16_t)vaddq_f32(v75, vmulq_f32(v16, vsubq_f32(vminq_f32(v75, v77), v75)))), v12, 3)), v12)));
          v79[2] = vaddq_f32(v13, vmulq_f32(v73, vsubq_f32((float32x4_t)vbslq_s8(v78, (int8x16_t)v13, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v78, (int8x16_t)v13, (int8x16_t)vaddq_f32(v76, vmulq_f32(v16, vsubq_f32(vminq_f32(v76, v77), v76)))), v13, 3)), v13)));
          v10 -= 3;
          v9 += 48;
        }
        while (v4 + v10 > 2);
        LODWORD(v80) = -v10;
      }
      if ((int)v80 < v4)
      {
        uint64_t v80 = v80;
        do
        {
          float32x4_t v81 = *(float32x4_t *)(v6 + 16 * v80);
          uint64_t v82 = *((void *)this + 51);
          float32x4_t v83 = vmaxq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v81, 3), *(float32x4_t *)(v82 + 80));
          float32x4_t v84 = vmulq_f32(vrecpeq_f32(v83), *(float32x4_t *)(v82 + 96));
          float32x4_t v85 = vmulq_f32(v81, vmulq_f32(v84, vrecpsq_f32(v84, v83)));
          float32x4_t v86 = vmulq_f32(*(float32x4_t *)(v82 + 112), v85);
          int8x16_t v87 = *(int8x16_t *)(v82 + 144);
          float32x4_t v88 = vmulq_f32(v85, *(float32x4_t *)(v82 + 128));
          v86.i64[0] = vbslq_s8(v87, (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s64((int64x2_t)v86, 1), vaddq_f32(v86, (float32x4_t)vrev64q_s32((int32x4_t)v86))), (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v88, (int8x16_t)v81, 4uLL), vaddq_f32(v88, (float32x4_t)vrev64q_s32((int32x4_t)v88)))).u64[0];
          float32x4_t v89 = vmulq_f32(v85, *(float32x4_t *)(v82 + 160));
          v86.i64[1] = vaddq_f32(v89, vaddq_f32((float32x4_t)vdupq_lane_s64(*(uint64_t *)&v89, 0), (float32x4_t)vextq_s8(*(int8x16_t *)&v81, *(int8x16_t *)&v89, 0xCuLL))).i64[1];
          float32x4_t v90 = (float32x4_t)vbslq_s8(v87, (int8x16_t)vaddq_f32(*(float32x4_t *)v82, vmulq_f32(*(float32x4_t *)(v82 + 16), vsubq_f32(v86, *(float32x4_t *)v82))), (int8x16_t)v86);
          int64x2_t v91 = (int64x2_t)vmulq_f32(*(float32x4_t *)(v82 + 176), v90);
          float32x4_t v92 = vmulq_f32(*(float32x4_t *)(v82 + 192), v90);
          v93.i64[0] = vrev64q_s32((int32x4_t)v92).u64[0];
          v93.i64[1] = vextq_s8(*(int8x16_t *)&v81, *(int8x16_t *)&v91, 0xCuLL).i64[1];
          float32x4_t v94 = (float32x4_t)vzip2q_s64((int64x2_t)v92, v91);
          v92.i64[1] = v91.i64[0];
          float32x4_t v95 = vmulq_f32(*(float32x4_t *)(v82 + 208), v90);
          float32x4_t v96 = (float32x4_t)vbslq_s8(*(int8x16_t *)(v82 + 224), (int8x16_t)vaddq_f32((float32x4_t)vextq_s8((int8x16_t)v95, (int8x16_t)v95, 4uLL), vaddq_f32(v95, (float32x4_t)vrev64q_s32((int32x4_t)v95))), (int8x16_t)vaddq_f32(v94, vaddq_f32(v92, v93)));
          float32x4_t v97 = vaddq_f32(vmulq_f32(*(float32x4_t *)(v82 + 48), vsubq_f32(vmaxq_f32(v96, *(float32x4_t *)(v82 + 240)), v96)), v96);
          *(float32x4_t *)(v5 + 16 * v80++) = vaddq_f32(v81, vmulq_f32(*(float32x4_t *)(v82 + 32), vsubq_f32((float32x4_t)vbslq_s8(*(int8x16_t *)(v82 + 272), (int8x16_t)v81, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(*(int8x16_t *)(v82 + 272), (int8x16_t)v81, (int8x16_t)vaddq_f32(v97, vmulq_f32(*(float32x4_t *)(v82 + 64), vsubq_f32(vminq_f32(v97, *(float32x4_t *)(v82 + 256)), v97)))), v81, 3)), v81)));
        }
        while (v80 < v4);
      }
      ++v3;
      v5 += v7;
      v6 += v8;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcContrastLuma::GetDOD(HgcContrastLuma *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcContrastLuma::GetROI(HgcContrastLuma *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcContrastLuma::HgcContrastLuma(HgcContrastLuma *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F1118108;
  operator new();
}

void sub_1B7A54FC8(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcContrastLuma::~HgcContrastLuma(HGNode *this)
{
  *(void *)this = &unk_1F1118108;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C4055B0EC01);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcContrastLuma::~HgcContrastLuma(this);

  HGObject::operator delete(v1);
}

uint64_t HgcContrastLuma::SetParameter(HgcContrastLuma *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  switch((int)a2)
  {
    case 0:
      uint64_t v7 = (float *)*((void *)this + 51);
      if (*v7 == a3.n128_f32[0] && v7[1] == a4 && v7[2] == a5 && v7[3] == a6) {
        return 0;
      }
      *uint64_t v7 = a3.n128_f32[0];
      v7[1] = a4;
      v7[2] = a5;
      v7[3] = a6;
      goto LABEL_28;
    case 1:
      uint64_t v9 = (float *)*((void *)this + 51);
      if (v9[4] == a3.n128_f32[0] && v9[5] == a4 && v9[6] == a5 && v9[7] == a6) {
        return 0;
      }
      float v9[4] = a3.n128_f32[0];
      v9[5] = a4;
      v9[6] = a5;
      v9[7] = a6;
      goto LABEL_28;
    case 2:
      int v10 = (__n128 *)*((void *)this + 51);
      if (v10[2].n128_f32[0] == a3.n128_f32[0]
        && v10[2].n128_f32[1] == a3.n128_f32[0]
        && v10[2].n128_f32[2] == a3.n128_f32[0]
        && v10[2].n128_f32[3] == a3.n128_f32[0])
      {
        return 0;
      }
      int32x4_t v11 = vdupq_lane_s32((int32x2_t)a3.n128_u64[0], 0);
      a3.n128_f32[1] = a4;
      v10[2] = (__n128)v11;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      v10[18] = a3;
      goto LABEL_28;
    case 3:
      float32x4_t v12 = (__n128 *)*((void *)this + 51);
      if (v12[3].n128_f32[0] == a3.n128_f32[0]
        && v12[3].n128_f32[1] == a3.n128_f32[0]
        && v12[3].n128_f32[2] == a3.n128_f32[0]
        && v12[3].n128_f32[3] == 0.0)
      {
        return 0;
      }
      int32x4_t v13 = vzip1q_s32((int32x4_t)a3.n128_u32[0], (int32x4_t)a3.n128_u32[0]);
      v13.i32[2] = a3.n128_u32[0];
      a3.n128_f32[1] = a4;
      v12[3] = (__n128)v13;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      v12[19] = a3;
      goto LABEL_28;
    case 4:
      uint64_t v14 = (__n128 *)*((void *)this + 51);
      if (v14[4].n128_f32[0] == a3.n128_f32[0]
        && v14[4].n128_f32[1] == a3.n128_f32[0]
        && v14[4].n128_f32[2] == a3.n128_f32[0]
        && v14[4].n128_f32[3] == 0.0)
      {
        return 0;
      }
      int32x4_t v15 = vzip1q_s32((int32x4_t)a3.n128_u32[0], (int32x4_t)a3.n128_u32[0]);
      v15.i32[2] = a3.n128_u32[0];
      a3.n128_f32[1] = a4;
      v14[4] = (__n128)v15;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      v14[20] = a3;
LABEL_28:
      HGNode::ClearBits((HGNode *)this, a2, a7);
      return 1;
    default:
      return 0xFFFFFFFFLL;
  }
}

float HgcContrastLuma::GetParameter(HgcContrastLuma *this, int a2, float *a3)
{
  switch(a2)
  {
    case 0:
      int v3 = (float *)*((void *)this + 51);
      *a3 = *v3;
      a3[1] = v3[1];
      a3[2] = v3[2];
      int v4 = v3 + 3;
      goto LABEL_7;
    case 1:
      uint64_t v5 = (float *)*((void *)this + 51);
      *a3 = v5[4];
      a3[1] = v5[5];
      a3[2] = v5[6];
      int v4 = v5 + 7;
      goto LABEL_7;
    case 2:
      uint64_t v6 = (float *)*((void *)this + 51);
      *a3 = v6[72];
      a3[1] = v6[73];
      a3[2] = v6[74];
      int v4 = v6 + 75;
      goto LABEL_7;
    case 3:
      uint64_t v7 = (float *)*((void *)this + 51);
      *a3 = v7[76];
      a3[1] = v7[77];
      a3[2] = v7[78];
      int v4 = v7 + 79;
      goto LABEL_7;
    case 4:
      uint64_t v8 = (float *)*((void *)this + 51);
      *a3 = v8[80];
      a3[1] = v8[81];
      a3[2] = v8[82];
      int v4 = v8 + 83;
LABEL_7:
      float result = *v4;
      a3[3] = *v4;
      break;
    default:
      return result;
  }
  return result;
}

const char *HgcContrastRGB::GetProgram(HgcContrastRGB *this, HGRenderer *a2)
{
  unsigned int Target = HGRenderer::GetTarget(a2, 393216);
  if (Target == 396048)
  {
    if ((*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 20) == 27) {
      return "//Metal1.0     \n"
    }
             "//LEN=0000000444\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< half > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const half4 c0 = half4(9.999999975e-07, 0.000000000, 1.000000000, 0.000000000);\n"
             "    half4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = (half4) hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = fmax(r0.w, c0.x);\n"
             "    r1.x = 1.00000h / r1.x;\n"
             "    r1.xyz = r0.xyz*r1.xxx + -half3(hg_Params[0].xxx);\n"
             "    r1.xyz = r1.xyz*half3(hg_Params[1].xyz) + half3(hg_Params[0].xxx);\n"
             "    r2.xyz = fmax(r1.xyz, c0.yyy);\n"
             "    r1.xyz = mix(r1.xyz, r2.xyz, half3(hg_Params[3].xyz));\n"
             "    r2.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = mix(r1.xyz, r2.xyz, half3(hg_Params[4].xyz));\n"
             "    r1.w = r0.w;\n"
             "    r1.xyz = r1.xyz*r0.www;\n"
             "    output.color0 = mix(float4(r0), float4(r1), hg_Params[2]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=503c73b4:deb1fa29:855b3f17:aadc9a98\n"
             "//SIG=00400000:00000001:00000001:00000001:0001:0005:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
    else {
      return "//Metal1.0     \n"
    }
             "//LEN=000000040d\n"
             "fragment FragmentOut fragmentFunc(VertexInOut frag [[ stage_in ]], \n"
             "    const constant float4* hg_Params [[ buffer(0) ]], \n"
             "    texture2d< float > hg_Texture0 [[ texture(0) ]], \n"
             "    sampler hg_Sampler0 [[ sampler(0) ]])\n"
             "{\n"
             "    const float4 c0 = float4(9.999999975e-07, 0.000000000, 1.000000000, 0.000000000);\n"
             "    float4 r0, r1, r2;\n"
             "    FragmentOut output;\n"
             "\n"
             "    r0 = hg_Texture0.sample(hg_Sampler0, frag._texCoord0.xy);\n"
             "    r1.x = fmax(r0.w, c0.x);\n"
             "    r1.x = 1.00000f / r1.x;\n"
             "    r1.xyz = r0.xyz*r1.xxx + -hg_Params[0].xxx;\n"
             "    r1.xyz = r1.xyz*hg_Params[1].xyz + hg_Params[0].xxx;\n"
             "    r2.xyz = fmax(r1.xyz, c0.yyy);\n"
             "    r1.xyz = mix(r1.xyz, r2.xyz, hg_Params[3].xyz);\n"
             "    r2.xyz = fmin(r1.xyz, c0.zzz);\n"
             "    r1.xyz = mix(r1.xyz, r2.xyz, hg_Params[4].xyz);\n"
             "    r1.w = r0.w;\n"
             "    r1.xyz = r1.xyz*r0.www;\n"
             "    output.color0 = mix(r0, r1, hg_Params[2]);\n"
             "    return output;\n"
             "}\n"
             "//MD5=e5ebd3e1:36111a4a:f2c8d442:47a74aaf\n"
             "//SIG=00000000:00000001:00000001:00000000:0001:0005:0003:0000:0000:0000:0002:0000:0001:01:0:1:0\n";
  }
  else if (Target <= 0x6060F {
         || (*(unsigned int (**)(HGRenderer *, uint64_t))(*(void *)a2 + 128))(a2, 46))
  }
  {
    return 0;
  }
  else
  {
    return "//GLfs2.0      \n"
           "//LEN=0000000489\n"
           "#ifndef GL_ES\n"
           "#define lowp\n"
           "#define mediump\n"
           "#define highp\n"
           "#endif\n"
           "#define defaultp mediump\n"
           "uniform defaultp sampler2D hg_Texture0;\n"
           "uniform mediump vec4 hg_ProgramLocal0;\n"
           "uniform mediump vec4 hg_ProgramLocal1;\n"
           "uniform mediump vec4 hg_ProgramLocal2;\n"
           "uniform mediump vec4 hg_ProgramLocal3;\n"
           "uniform mediump vec4 hg_ProgramLocal4;\n"
           "varying highp vec4 hg_TexCoord0;\n"
           "void main()\n"
           "{\n"
           "    const mediump vec4 c0 = vec4(9.999999975e-07, 0.000000000, 1.000000000, 0.000000000);\n"
           "    mediump vec4 r0, r1, r2;\n"
           "\n"
           "    r0 = texture2D(hg_Texture0, hg_TexCoord0.xy);\n"
           "    r1.x = max(r0.w, c0.x);\n"
           "    r1.x = 1.00000 / r1.x;\n"
           "    r1.xyz = r0.xyz*r1.xxx + -hg_ProgramLocal0.xxx;\n"
           "    r1.xyz = r1.xyz*hg_ProgramLocal1.xyz + hg_ProgramLocal0.xxx;\n"
           "    r2.xyz = max(r1.xyz, c0.yyy);\n"
           "    r1.xyz = mix(r1.xyz, r2.xyz, hg_ProgramLocal3.xyz);\n"
           "    r2.xyz = min(r1.xyz, c0.zzz);\n"
           "    r1.xyz = mix(r1.xyz, r2.xyz, hg_ProgramLocal4.xyz);\n"
           "    r1.w = r0.w;\n"
           "    r1.xyz = r1.xyz*r0.www;\n"
           "    gl_FragColor = mix(r0, r1, hg_ProgramLocal2);\n"
           "}\n"
           "//MD5=ec125030:8843647e:90165e3b:973fbe25\n"
           "//SIG=00000000:00000001:00000001:00000000:0001:0005:0003:0000:0000:0000:0000:0000:0001:01:0:1:0\n";
  }
}

void HgcContrastRGB::InitProgramDescriptor(HgcContrastRGB *this, HGProgramDescriptor *a2)
{
  HGProgramDescriptor::SetVisibleShaderWithSource(a2, "HgcContrastRGB_hgc_visible", "//Metal1.0     \n//LEN=00000002e5\n[[ visible ]] FragmentOut HgcContrastRGB_hgc_visible(const constant float4* hg_Params,\n    float4 color0)\n{\n    const float4 c0 = float4(9.999999975e-07, 0.000000000, 1.000000000, 0.000000000);\n"
    "    float4 r0, r1, r2;\n"
    "    FragmentOut output;\n"
    "\n"
    "    r0 = color0;\n"
    "    r1.x = fmax(r0.w, c0.x);\n"
    "    r1.x = 1.00000f / r1.x;\n"
    "    r1.xyz = r0.xyz*r1.xxx + -hg_Params[0].xxx;\n"
    "    r1.xyz = r1.xyz*hg_Params[1].xyz + hg_Params[0].xxx;\n"
    "    r2.xyz = fmax(r1.xyz, c0.yyy);\n"
    "    r1.xyz = mix(r1.xyz, r2.xyz, hg_Params[3].xyz);\n"
    "    r2.xyz = fmin(r1.xyz, c0.zzz);\n"
    "    r1.xyz = mix(r1.xyz, r2.xyz, hg_Params[4].xyz);\n"
    "    r1.w = r0.w;\n"
    "    r1.xyz = r1.xyz*r0.www;\n"
    "    output.color0 = mix(r0, r1, hg_Params[2]);\n"
    "    return output;\n"
    "}\n");
  HGProgramDescriptor::SetFragmentFunctionName(a2, "HgcContrastRGB");
}

void sub_1B7A55488(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, long long a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  *(_DWORD *)(v32 - 64) = 4;
  std::string::basic_string[abi:ne180100]<0>((void *)(v32 - 56), "FragmentOut");
  *(_OWORD *)(v32 - 32) = xmmword_1B7E75170;
  HGProgramDescriptor::SetReturnBinding(v31, v32 - 64);
  if (*(char *)(v32 - 33) < 0) {
    operator delete(*(void **)(v32 - 56));
  }
  memset(v37, 0, 24);
  LODWORD(v33) = 2;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75C50;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  LODWORD(v33) = 10;
  std::string::basic_string[abi:ne180100]<0>(v34, "float4");
  long long v36 = xmmword_1B7E75170;
  std::vector<HGBinding>::push_back[abi:ne180100](v37, (uint64_t)&v33);
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  HGProgramDescriptor::SetArgumentBindings(v31, v37);
  float32x4_t v33 = (void **)v37;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100](&v33);
}

void sub_1B7A55588(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,char a21)
{
  a12 = &a21;
  std::vector<HGBinding>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  _Unwind_Resume(a1);
}

void sub_1B7A555C8()
{
  if (*(char *)(v0 - 33) < 0) {
    operator delete(*(void **)(v0 - 56));
  }
  JUMPOUT(0x1B7A555C0);
}

void *HgcContrastRGB::shaderDescription@<X0>(void *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "HgcContrastRGB [hgc1]");
}

uint64_t HgcContrastRGB::BindTexture(HgcContrastRGB *this, HGHandler *a2, int a3)
{
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(HGHandler *, void))(*(void *)a2 + 72))(a2, 0);
  (*(void (**)(HGHandler *, void, void))(*(void *)a2 + 48))(a2, 0, 0);
  HGHandler::TexCoord(a2, 0, 0, 0, 0);
  int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 18) + 128))(*((void *)a2 + 18), 46);
  uint64_t result = 0;
  if (!v5)
  {
    (*(void (**)(HGHandler *))(*(void *)a2 + 168))(a2);
    return 0;
  }
  return result;
}

uint64_t HgcContrastRGB::Bind(HgcContrastRGB *this, HGHandler *a2)
{
  return 0;
}

uint64_t HgcContrastRGB::RenderTile(HgcContrastRGB *this, HGTile *a2)
{
  int v2 = *((_DWORD *)a2 + 3) - *((_DWORD *)a2 + 1);
  if (v2 >= 1)
  {
    int v3 = 0;
    int v4 = *((_DWORD *)a2 + 2) - *(_DWORD *)a2;
    uint64_t v5 = *((void *)a2 + 2);
    uint64_t v6 = *((void *)a2 + 10);
    uint64_t v7 = 16 * *((int *)a2 + 22);
    uint64_t v8 = 16 * *((int *)a2 + 6);
    do
    {
      if (v4 < 4)
      {
        LODWORD(v53) = 0;
      }
      else
      {
        int v9 = 0;
        uint64_t v10 = 32;
        do
        {
          float32x4_t v12 = *(float32x4_t *)(v6 + v10 - 32);
          float32x4_t v11 = *(float32x4_t *)(v6 + v10 - 16);
          float32x4_t v13 = *(float32x4_t *)(v6 + v10);
          float32x4_t v14 = *(float32x4_t *)(v6 + v10 + 16);
          uint64_t v15 = *((void *)this + 51);
          float32x4_t v17 = *(float32x4_t *)(v15 + 64);
          float32x4_t v16 = *(float32x4_t *)(v15 + 80);
          float32x4_t v18 = vmaxq_f32((float32x4_t)vextq_s8((int8x16_t)v12, (int8x16_t)v12, 0xCuLL), v16);
          float32x4_t v19 = vmaxq_f32((float32x4_t)vextq_s8((int8x16_t)v11, (int8x16_t)v11, 0xCuLL), v16);
          float32x4_t v20 = vmaxq_f32((float32x4_t)vextq_s8((int8x16_t)v13, (int8x16_t)v13, 0xCuLL), v16);
          float32x4_t v21 = vmaxq_f32((float32x4_t)vextq_s8((int8x16_t)v14, (int8x16_t)v14, 0xCuLL), v16);
          float32x4_t v22 = *(float32x4_t *)(v15 + 96);
          float32x4_t v23 = *(float32x4_t *)(v15 + 112);
          float32x4_t v24 = vmaxq_f32(vmulq_f32(vrecpeq_f32(v18), v22), v23);
          float32x4_t v25 = vmaxq_f32(vmulq_f32(vrecpeq_f32(v19), v22), v23);
          float32x4_t v26 = vmaxq_f32(vmulq_f32(vrecpeq_f32(v20), v22), v23);
          float32x4_t v27 = vmaxq_f32(vmulq_f32(vrecpeq_f32(v21), v22), v23);
          float32x4_t v28 = *(float32x4_t *)(v15 + 128);
          float32x4_t v29 = *(float32x4_t *)(v15 + 144);
          float32x4_t v30 = vminq_f32(v24, v28);
          float32x4_t v31 = vminq_f32(v25, v28);
          float32x4_t v32 = vminq_f32(v26, v28);
          float32x4_t v33 = vminq_f32(v27, v28);
          v18.i32[0] = vmulq_f32(v30, vrecpsq_f32(v18, v30)).u32[0];
          v19.i32[0] = vmulq_f32(v31, vrecpsq_f32(v19, v31)).u32[0];
          float32x4_t v34 = *(float32x4_t *)(v15 + 16);
          float32x4_t v35 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15, 0);
          float32x4_t v36 = vaddq_f32(v35, vmulq_f32(v34, vsubq_f32(vmulq_n_f32(v12, v18.f32[0]), v35)));
          float32x4_t v37 = vaddq_f32(v35, vmulq_f32(v34, vsubq_f32(vmulq_n_f32(v11, v19.f32[0]), v35)));
          float32x4_t v38 = vaddq_f32(v35, vmulq_f32(v34, vsubq_f32(vmulq_n_f32(v13, vmulq_f32(v32, vrecpsq_f32(v20, v32)).f32[0]), v35)));
          float32x4_t v39 = vaddq_f32(v35, vmulq_f32(v34, vsubq_f32(vmulq_n_f32(v14, vmulq_f32(v33, vrecpsq_f32(v21, v33)).f32[0]), v35)));
          float32x4_t v40 = vmaxq_f32(v39, v29);
          float32x4_t v41 = vsubq_f32(vmaxq_f32(v36, v29), v36);
          float32x4_t v42 = vsubq_f32(vmaxq_f32(v37, v29), v37);
          float32x4_t v43 = vsubq_f32(vmaxq_f32(v38, v29), v38);
          float32x4_t v45 = *(float32x4_t *)(v15 + 32);
          float32x4_t v44 = *(float32x4_t *)(v15 + 48);
          float32x4_t v46 = vaddq_f32(v36, vmulq_f32(v41, v44));
          float32x4_t v47 = vaddq_f32(v37, vmulq_f32(v42, v44));
          float32x4_t v48 = vaddq_f32(v38, vmulq_f32(v43, v44));
          float32x4_t v49 = vaddq_f32(v39, vmulq_f32(v44, vsubq_f32(v40, v39)));
          float32x4_t v50 = *(float32x4_t *)(v15 + 160);
          int8x16_t v51 = *(int8x16_t *)(v15 + 176);
          float32x4_t v52 = (float32x4_t *)(v5 + v10);
          v52[-2] = vaddq_f32(v12, vmulq_f32(v45, vsubq_f32((float32x4_t)vbslq_s8(v51, (int8x16_t)v12, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v51, (int8x16_t)v12, (int8x16_t)vaddq_f32(v46, vmulq_f32(vsubq_f32(vminq_f32(v46, v50), v46), v17))), v12, 3)), v12)));
          v52[-1] = vaddq_f32(v11, vmulq_f32(v45, vsubq_f32((float32x4_t)vbslq_s8(v51, (int8x16_t)v11, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v51, (int8x16_t)v11, (int8x16_t)vaddq_f32(v47, vmulq_f32(vsubq_f32(vminq_f32(v47, v50), v47), v17))), v11, 3)), v11)));
          *float32x4_t v52 = vaddq_f32(v13, vmulq_f32(v45, vsubq_f32((float32x4_t)vbslq_s8(v51, (int8x16_t)v13, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v51, (int8x16_t)v13, (int8x16_t)vaddq_f32(v48, vmulq_f32(vsubq_f32(vminq_f32(v48, v50), v48), v17))), v13, 3)), v13)));
          v52[1] = vaddq_f32(v14, vmulq_f32(v45, vsubq_f32((float32x4_t)vbslq_s8(v51, (int8x16_t)v14, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(v51, (int8x16_t)v14, (int8x16_t)vaddq_f32(v49, vmulq_f32(v17, vsubq_f32(vminq_f32(v49, v50), v49)))), v14, 3)), v14)));
          v9 -= 4;
          v10 += 64;
        }
        while (v4 + v9 > 3);
        LODWORD(v53) = -v9;
      }
      if ((int)v53 < v4)
      {
        uint64_t v53 = v53;
        do
        {
          float32x4_t v54 = *(float32x4_t *)(v6 + 16 * v53);
          uint64_t v55 = *((void *)this + 51);
          float32x4_t v56 = vmaxq_f32((float32x4_t)vextq_s8((int8x16_t)v54, (int8x16_t)v54, 0xCuLL), *(float32x4_t *)(v55 + 80));
          float32x4_t v57 = vminq_f32(vmaxq_f32(vmulq_f32(vrecpeq_f32(v56), *(float32x4_t *)(v55 + 96)), *(float32x4_t *)(v55 + 112)), *(float32x4_t *)(v55 + 128));
          v56.i32[0] = vmulq_f32(v57, vrecpsq_f32(v56, v57)).u32[0];
          float32x4_t v58 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55, 0);
          float32x4_t v59 = vaddq_f32(v58, vmulq_f32(*(float32x4_t *)(v55 + 16), vsubq_f32(vmulq_n_f32(v54, v56.f32[0]), v58)));
          float32x4_t v60 = vaddq_f32(v59, vmulq_f32(*(float32x4_t *)(v55 + 48), vsubq_f32(vmaxq_f32(v59, *(float32x4_t *)(v55 + 144)), v59)));
          *(float32x4_t *)(v5 + 16 * v53++) = vaddq_f32(v54, vmulq_f32(*(float32x4_t *)(v55 + 32), vsubq_f32((float32x4_t)vbslq_s8(*(int8x16_t *)(v55 + 176), (int8x16_t)v54, (int8x16_t)vmulq_laneq_f32((float32x4_t)vbslq_s8(*(int8x16_t *)(v55 + 176), (int8x16_t)v54, (int8x16_t)vaddq_f32(v60, vmulq_f32(*(float32x4_t *)(v55 + 64), vsubq_f32(vminq_f32(v60, *(float32x4_t *)(v55 + 160)), v60)))), v54, 3)), v54)));
        }
        while (v53 < v4);
      }
      ++v3;
      v6 += v7;
      v5 += v8;
    }
    while (v3 != v2);
  }
  return 0;
}

uint64_t HgcContrastRGB::GetDOD(HgcContrastRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

uint64_t HgcContrastRGB::GetROI(HgcContrastRGB *this, HGRenderer *a2, int a3, HGRect a4)
{
  if (a3) {
    return 0;
  }
  else {
    return *(void *)&a4.var0;
  }
}

void HgcContrastRGB::HgcContrastRGB(HgcContrastRGB *this)
{
  HGNode::HGNode((HGNode *)this);
  *uint64_t v1 = &unk_1F1118370;
  operator new();
}

void sub_1B7A55C68(_Unwind_Exception *a1)
{
  HGNode::~HGNode(v1);
  _Unwind_Resume(a1);
}

void HgcContrastRGB::~HgcContrastRGB(HGNode *this)
{
  *(void *)this = &unk_1F1118370;
  uint64_t v2 = *((void *)this + 51);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40104B78CFLL);
  }

  HGNode::~HGNode(this);
}

{
  void *v1;
  uint64_t vars8;

  HgcContrastRGB::~HgcContrastRGB(this);

  HGObject::operator delete(v1);
}

uint64_t HgcContrastRGB::SetParameter(HgcContrastRGB *this, uint64_t a2, __n128 a3, float a4, float a5, float a6, char *a7)
{
  switch((int)a2)
  {
    case 0:
      uint64_t v7 = (float *)*((void *)this + 51);
      if (*v7 == a3.n128_f32[0] && v7[1] == a4 && v7[2] == a5 && v7[3] == a6) {
        return 0;
      }
      *uint64_t v7 = a3.n128_f32[0];
      v7[1] = a4;
      v7[2] = a5;
      v7[3] = a6;
      goto LABEL_28;
    case 1:
      int v9 = (__n128 *)*((void *)this + 51);
      if (v9[1].n128_f32[0] == a3.n128_f32[0]
        && v9[1].n128_f32[1] == a3.n128_f32[0]
        && v9[1].n128_f32[2] == a3.n128_f32[0]
        && v9[1].n128_f32[3] == 0.0)
      {
        return 0;
      }
      int32x4_t v10 = vzip1q_s32((int32x4_t)a3.n128_u32[0], (int32x4_t)a3.n128_u32[0]);
      v10.i32[2] = a3.n128_u32[0];
      a3.n128_f32[1] = a4;
      v9[1] = (__n128)v10;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      v9[12] = a3;
      goto LABEL_28;
    case 2:
      float32x4_t v11 = (__n128 *)*((void *)this + 51);
      if (v11[2].n128_f32[0] == a3.n128_f32[0]
        && v11[2].n128_f32[1] == a3.n128_f32[0]
        && v11[2].n128_f32[2] == a3.n128_f32[0]
        && v11[2].n128_f32[3] == a3.n128_f32[0])
      {
        return 0;
      }
      int32x4_t v12 = vdupq_lane_s32((int32x2_t)a3.n128_u64[0], 0);
      a3.n128_f32[1] = a4;
      v11[2] = (__n128)v12;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      v11[13] = a3;
      goto LABEL_28;
    case 3:
      float32x4_t v13 = (__n128 *)*((void *)this + 51);
      if (v13[3].n128_f32[0] == a3.n128_f32[0]
        && v13[3].n128_f32[1] == a3.n128_f32[0]
        && v13[3].n128_f32[2] == a3.n128_f32[0]
        && v13[3].n128_f32[3] == 0.0)
      {
        return 0;
      }
      int32x4_t v14 = vzip1q_s32((int32x4_t)a3.n128_u32[0], (int32x4_t)a3.n128_u32[0]);
      v14.i32[2] = a3.n128_u32[0];
      a3.n128_f32[1] = a4;
      v13[3] = (__n128)v14;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      v13[14] = a3;
      goto LABEL_28;
    case 4:
      uint64_t v15 = (__n128 *)*((void *)this + 51);
      if (v15[4].n128_f32[0] == a3.n128_f32[0]
        && v15[4].n128_f32[1] == a3.n128_f32[0]
        && v15[4].n128_f32[2] == a3.n128_f32[0]
        && v15[4].n128_f32[3] == 0.0)
      {
        return 0;
      }
      int32x4_t v16 = vzip1q_s32((int32x4_t)a3.n128_u32[0], (int32x4_t)a3.n128_u32[0]);
      v16.i32[2] = a3.n128_u32[0];
      a3.n128_f32[1] = a4;
      v15[4] = (__n128)v16;
      a3.n128_u64[1] = __PAIR64__(LODWORD(a6), LODWORD(a5));
      v15[15] = a3;
LABEL_28:
      HGNode::ClearBits((HGNode *)this, a2, a7);
      return 1;
    default:
      return 0xFFFFFFFFLL;
  }
}

float HgcContrastRGB::GetParameter(HgcContrastRGB *this, int a2, float *a3)
{
  switch(a2)
  {
    case 0:
      int v3 = (float *)*((void *)this + 51);
      *a3 = *v3;
      a3[1] = v3[1];
      a3[2] = v3[2];
      int v4 = v3 + 3;
      goto LABEL_7;
    case 1:
      uint64_t v5 = (float *)*((void *)this + 51);
      *a3 = v5[48];
      a3[1] = v5[49];
      a3[2] = v5[50];
      int v4 = v5 + 51;
      goto LABEL_7;
    case 2:
      uint64_t v6 = (float *)*((void *)this + 51);
      *a3 = v6[52];
      a3[1] = v6[53];
      a3[2] = v6[54];
      int v4 = v6 + 55;
      goto LABEL_7;
    case 3:
      uint64_t v7 = (float *)*((void *)this + 51);
      *a3 = v7[56];
      a3[1] = v7[57];
      a3[2] = v7[58];
      int v4 = v7 + 59;
      goto LABEL_7;
    case 4:
      uint64_t v8 = (float *)*((void *)this + 51);
      *a3 = v8[60];
      a3[1] = v8[61];
      a3[2] = v8[62];
      int v4 = v8 + 63;
LABEL_7:
      float result = *v4;
      a3[3] = *v4;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t LiHelium::createTextureHandleNode@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, unsigned int *a4@<X3>, void *a5@<X8>)
{
  uint64_t result = FxSupport::createTextureHandleNode(a1, a2, a3, a4, &v7);
  *a5 = v7;
  return result;
}

HGBitmapLoader *LiHelium::createBitmapNode@<X0>(PCBitmap **a1@<X0>, unsigned int *a2@<X1>, void *a3@<X8>)
{
  uint64_t result = FxSupport::createBitmapNode(a1, a2, &v5);
  *a3 = v5;
  return result;
}

uint64_t LiHelium::createTransformNode@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, int a3@<W2>, float *a4@<X4>, void *a5@<X8>)
{
  if (PCMatrix44Tmpl<double>::is2Didentity((double *)a1))
  {
    uint64_t result = *a2;
    *a5 = *a2;
    if (result)
    {
      float32x4_t v11 = *(uint64_t (**)(void))(*(void *)result + 16);
      return v11();
    }
  }
  else
  {
    int32x4_t v12 = (HGTransform *)HGObject::operator new(0x90uLL);
    HGTransform::HGTransform(v12);
    long long v13 = *(_OWORD *)(a1 + 80);
    long long v31 = *(_OWORD *)(a1 + 64);
    long long v32 = v13;
    long long v14 = *(_OWORD *)(a1 + 112);
    long long v33 = *(_OWORD *)(a1 + 96);
    long long v34 = v14;
    long long v15 = *(_OWORD *)(a1 + 16);
    float64x2_t v26 = *(float64x2_t *)a1;
    long long v27 = v15;
    long long v16 = *(_OWORD *)(a1 + 48);
    long long v28 = *(_OWORD *)(a1 + 32);
    float64_t v17 = v26.f64[1];
    long long v18 = v27;
    uint64_t v19 = *((void *)&v31 + 1);
    *(void *)&v26.f64[1] = v28;
    *(void *)&long long v27 = v31;
    uint64_t v20 = *((void *)&v32 + 1);
    *((void *)&v27 + 1) = v33;
    *(float64_t *)&long long v28 = v17;
    *(void *)&long long v31 = v18;
    *((void *)&v31 + 1) = v16;
    uint64_t v29 = v19;
    uint64_t v30 = *((void *)&v33 + 1);
    *((void *)&v32 + 1) = v34;
    *(void *)&long long v33 = *((void *)&v18 + 1);
    *((void *)&v33 + 1) = *((void *)&v16 + 1);
    *(void *)&long long v34 = v20;
    (*(void (**)(HGTransform *, float64x2_t *))(*(void *)v12 + 72))(v12, &v26);
    float32x4_t v21 = (HGXForm *)HGObject::operator new(0x210uLL);
    HGXForm::HGXForm(v21);
    (*(void (**)(HGXForm *, HGTransform *))(*(void *)v21 + 576))(v21, v12);
    if (a3
      && (fabs(*(double *)(a1 + 96)) >= 0.0000001
       || fabs(*(double *)(a1 + 104)) >= 0.0000001
       || (double v24 = 0.0,
           double v25 = 0.0,
           PCMatrix44Tmpl<double>::singularValues22((float64x2_t *)a1, &v25, &v24),
           double v22 = *(double *)(a1 + 120),
           v25 / v22 <= 1.0)
       && fabs(v25 / v22 + -1.0) >= 0.0000001
       || (double v23 = v24 / v22, v23 <= 1.0) && fabs(v23 + -1.0) >= 0.0000001))
    {
      (*(void (**)(HGXForm *, void, float))(*(void *)v21 + 592))(v21, 0, 1.0);
      (*(void (**)(HGXForm *, double))(*(void *)v21 + 632))(v21, 0.0);
      (*(void (**)(HGXForm *, float, float))(*(void *)v21 + 600))(v21, *a4, a4[1]);
    }
    else
    {
      (*(void (**)(HGXForm *, void, double))(*(void *)v21 + 592))(v21, 0, 0.0);
    }
    if (*a2) {
      (*(void (**)(HGXForm *, void))(*(void *)v21 + 120))(v21, 0);
    }
    *a5 = v21;
    return (*(uint64_t (**)(HGTransform *))(*(void *)v12 + 24))(v12);
  }
  return result;
}

void sub_1B7A56414()
{
}

double PCMatrix44Tmpl<double>::singularValues22(float64x2_t *a1, double *a2, double *a3)
{
  uint64_t v25 = 0x3FF0000000000000;
  uint64_t v22 = 0x3FF0000000000000;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  float64x2_t v5 = *a1;
  float64x2_t v6 = a1[2];
  int64x2_t v7 = (int64x2_t)vaddq_f64(vmulq_f64(v5, v5), vmulq_f64(v6, v6));
  long long v20 = 0u;
  long long v21 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  float64x2_t v8 = vmulq_laneq_f64(v6, v6, 1);
  int64x2_t v9 = (int64x2_t)vaddq_f64(vmulq_laneq_f64(v5, v5, 1), v8);
  int8x16_t v16 = (int8x16_t)vzip1q_s64(v7, v9);
  int64x2_t v19 = v9;
  double v14 = 0.0;
  double v15 = 0.0;
  int v10 = PCMatrix44Tmpl<double>::eigen22((uint64_t)&v16, (PCMath *)&v15, &v14, *(double *)v9.i64, v16, v8.f64[0], (int8x16_t)0);
  *a2 = sqrt(v15);
  double result = sqrt(v14);
  *a3 = result;
  if (v10 <= 1)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v13, "singularValues22: failed to find real eigenvalues");
    PCException::PCException(exception, &v13);
  }
  return result;
}

void sub_1B7A565A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

uint64_t LiHelium::bitmapToTexture@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  if (*a1) {
    uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 104))(a2, *a1);
  }
  else {
    uint64_t result = 0;
  }
  *a3 = result;
  return result;
}

uint64_t LiHelium::convertMotionBlendMode(int a1)
{
  if ((a1 - 2) > 0x2E) {
    return 9;
  }
  else {
    return *(unsigned int *)&asc_1B837B408[4 * a1 - 8];
  }
}

unsigned int LiHelium::getBlurExtent(LiHelium *this, float a2)
{
  return vcvtps_s32_f32((float)((float)(powf(a2 + 1.0, 0.72) * 4.0) + -3.0) * 3.0);
}

uint64_t LiHelium::createBlurNode@<X0>(float a1@<S0>, float a2@<S1>, HGBlur **a3@<X8>)
{
  int64x2_t v7 = (HGBlur *)HGObject::operator new(0x220uLL);
  HGBlur::HGBlur(v7);
  *a3 = v7;
  return (*(uint64_t (**)(HGBlur *, void, float, float, double, double))(*(void *)v7 + 96))(v7, 0, a1, a2, 0.0, 0.0);
}

void sub_1B7A56720(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t LiHelium::setUpGLRenderer(HGGPURenderer *a1, uint64_t a2)
{
  int v2 = a2;
  (*(void (**)(HGGPURenderer *, uint64_t, uint64_t))(*(void *)a1 + 120))(a1, 19, a2);
  MetalContext = (PCICCTransferFunctionLUT *)HGGPURenderer::GetMetalContext(a1);
  uint64_t result = PCICCTransferFunctionLUT::getLUTEnd(MetalContext);
  if ((float)((float)*(unint64_t *)(result + 40) * 0.00000095367) <= 300.0)
  {
    if (v2 >= 28) {
      unsigned int v6 = 400;
    }
    else {
      unsigned int v6 = 512;
    }
    if (v2 >= 25) {
      uint64_t v7 = v6;
    }
    else {
      uint64_t v7 = 800;
    }
    float64x2_t v8 = *(uint64_t (**)(HGGPURenderer *, uint64_t, uint64_t))(*(void *)a1 + 120);
    return v8(a1, 18, v7);
  }
  return result;
}

void LiHelium::createExternallyOwnedTexture(uint64_t a1, EAGLContext *a2, int a3, ProGL *this)
{
  ProGL::findContext(this, a2, &v5);
  HGFormatUtils::toGLInternalFormat(*(_DWORD *)(*(void *)a1 + 16));
  ProGL::createExternallyOwnedTexture();
}

void sub_1B7A568D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *LiRenderQueueTextureOwner::create@<X0>(uint64_t *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a2;
  if (a2)
  {
    uint64_t result = std::allocate_shared[abi:ne180100]<LiRenderQueueTextureOwner,std::allocator<LiRenderQueueTextureOwner>,HGRef<HGGLTexture> const&,HGRenderQueue *&,void>(result, &v5, &v4);
    *(_OWORD *)a3 = v4;
  }
  else
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
  }
  return result;
}

void LiRenderQueueTextureOwner::~LiRenderQueueTextureOwner(LiRenderQueueTextureOwner *this)
{
  *(void *)this = &unk_1F11185D8;
  uint64_t v2 = *((void *)this + 1);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 16))(v2);
    int v3 = (HGGLTexture *)*((void *)this + 1);
    if (v3) {
      (*(void (**)(void))(*(void *)v3 + 24))(*((void *)this + 1));
    }
  }
  else
  {
    int v3 = 0;
  }
  *((void *)this + 1) = 0;
  HGRenderQueue::DeleteHGGLTexture(*((HGRenderQueue **)this + 2), v3);
  uint64_t v4 = *((void *)this + 1);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
}

{
  uint64_t vars8;

  LiRenderQueueTextureOwner::~LiRenderQueueTextureOwner(this);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t *LiHelium::getDefaultGPU@<X0>(LiHelium *this@<X0>, void *a2@<X8>)
{
  uint64_t result = HGComputeDeviceManager::GetGPUComputeDeviceList(this);
  uint64_t v4 = *(void *)(*result + 8);
  *a2 = *(void *)*result;
  a2[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *std::allocate_shared[abi:ne180100]<LiRenderQueueTextureOwner,std::allocator<LiRenderQueueTextureOwner>,HGRef<HGGLTexture> const&,HGRenderQueue *&,void>@<X0>(uint64_t *a1@<X1>, uint64_t *a2@<X2>, void *a3@<X8>)
{
  unsigned int v6 = operator new(0x30uLL);
  uint64_t result = std::__shared_ptr_emplace<LiRenderQueueTextureOwner>::__shared_ptr_emplace[abi:ne180100]<HGRef<HGGLTexture> const&,HGRenderQueue *&,std::allocator<LiRenderQueueTextureOwner>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1B7A56AFC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<LiRenderQueueTextureOwner>::__shared_ptr_emplace[abi:ne180100]<HGRef<HGGLTexture> const&,HGRenderQueue *&,std::allocator<LiRenderQueueTextureOwner>,0>(void *a1, uint64_t *a2, uint64_t *a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F1118620;
  uint64_t v4 = *a3;
  uint64_t v5 = *a2;
  a1[3] = &unk_1F11185D8;
  a1[4] = v5;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
  }
  a1[5] = v4;
  return a1;
}

void sub_1B7A56BA8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<LiRenderQueueTextureOwner>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1118620;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<LiRenderQueueTextureOwner>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1118620;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<LiRenderQueueTextureOwner>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void LiRenderingTechnology::LiRenderingTechnology(LiRenderingTechnology *this)
{
  *(void *)this = 8208;
  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 4) = 256;
  *((unsigned char *)this + 20) = 1;
  *((void *)this + 3) = 0x1400000014;
  *((_WORD *)this + 16) = 1;
  *((unsigned char *)this + 34) = 0;
  *(void *)((char *)this + 36) = 0x600000002;
  *((_WORD *)this + 22) = 1;
  uint64_t v2 = &sprintf_buf[224];
  {
    uint64_t v2 = sprintf_buf + 224;
    if (v6)
    {
      LiRenderingTechnology::LiRenderingTechnology(void)::bitdepth = (uint64_t)getenv("MOTION_BITDEPTH");
      uint64_t v2 = sprintf_buf + 224;
    }
  }
  int v3 = (const char *)*((void *)v2 + 390);
  if (!v3) {
    goto LABEL_9;
  }
  int v4 = atoi(v3);
  if (v4 == 8)
  {
    int v5 = 0;
    goto LABEL_10;
  }
  if (v4 == 16)
  {
LABEL_9:
    int v5 = 2;
    goto LABEL_10;
  }
  if (v4 != 32)
  {
    printf("MOTION_BITDEPTH - invalid bitdepth, must either be 8, 16, or 32");
    goto LABEL_9;
  }
  int v5 = 3;
LABEL_10:
  *((_DWORD *)this + 3) = v5;
}

uint64_t LiRenderingTechnology::getLogFxPlugRenderTimeEnabled(LiRenderingTechnology *this)
{
  return (*((unsigned __int8 *)this + 2) >> 5) & 1;
}

uint64_t LiRenderingTechnology::getLogLithium(LiRenderingTechnology *this)
{
  return *(unsigned __int8 *)this >> 7;
}

uint64_t LiRenderingTechnology::getDefocusIntersections(LiRenderingTechnology *this)
{
  return *((unsigned __int8 *)this + 16);
}

uint64_t LiRenderingTechnology::getShowDepth(LiRenderingTechnology *this)
{
  return *((unsigned __int8 *)this + 1) >> 7;
}

uint64_t LiRenderingTechnology::getUseHalfHeightFields(LiRenderingTechnology *this)
{
  return *((unsigned char *)this + 2) & 1;
}

uint64_t LiRenderingTechnology::getRasterizeEdges(LiRenderingTechnology *this)
{
  return *((unsigned __int8 *)this + 20);
}

uint64_t LiRenderingTechnology::setRasterizeEdges(uint64_t this, char a2)
{
  *(unsigned char *)(this + 20) = a2;
  return this;
}

int *LiRenderingTechnology::setFlagAtIndex(int *this, char a2, int a3)
{
  int v3 = *this & ~(1 << a2);
  if (a3) {
    int v3 = *this | (1 << a2);
  }
  *this = v3;
  return this;
}

uint64_t LiRenderingTechnology::getSharpText(LiRenderingTechnology *this)
{
  return *((unsigned __int8 *)this + 32);
}

uint64_t LiRenderingTechnology::getDebugShaders(LiRenderingTechnology *this)
{
  return *((unsigned __int8 *)this + 33);
}

uint64_t LiRenderingTechnology::setDebugShaders(uint64_t this, char a2)
{
  *(unsigned char *)(this + 33) = a2;
  return this;
}

uint64_t LiRenderingTechnology::getPrintShaders(LiRenderingTechnology *this)
{
  return *((unsigned __int8 *)this + 34);
}

uint64_t LiRenderingTechnology::setPrintShaders(uint64_t this, char a2)
{
  *(unsigned char *)(this + 34) = a2;
  return this;
}

uint64_t LiRenderingTechnology::getEnableMetalRendering(LiRenderingTechnology *this)
{
  return *((unsigned __int8 *)this + 44);
}

uint64_t LiRenderingTechnology::setEnableMetalRendering(uint64_t this, char a2)
{
  *(unsigned char *)(this + 44) = a2;
  return this;
}

uint64_t LiRenderingTechnology::getEnableHgc2Shaders(LiRenderingTechnology *this)
{
  return *((unsigned __int8 *)this + 45);
}

uint64_t LiRenderingTechnology::setEnableHgc2Shaders(uint64_t this, char a2)
{
  *(unsigned char *)(this + 45) = a2;
  return this;
}

void LiAgent::LiAgent(LiAgent *this, const LiAgent *a2)
{
  *(_OWORD *)this = *(_OWORD *)a2;
  *((_OWORD *)this + 1) = *((_OWORD *)a2 + 1);
  *((void *)this + 4) = *((void *)a2 + 4);
  *((_DWORD *)this + 10) = *((_DWORD *)a2 + 10);
  *((unsigned char *)this + 44) = *((unsigned char *)a2 + 44);
  *((void *)this + 6) = *((void *)a2 + 6);
  *((unsigned char *)this + 56) = *((unsigned char *)a2 + 56);
  *(_OWORD *)((char *)this + 60) = *(_OWORD *)((char *)a2 + 60);
  *((unsigned char *)this + 76) = *((unsigned char *)a2 + 76);
  *((_OWORD *)this + 5) = *((_OWORD *)a2 + 5);
  LiClipSet::LiClipSet((LiAgent *)((char *)this + 96), (const LiAgent *)((char *)a2 + 96));
  *((_OWORD *)this + 9) = *((_OWORD *)a2 + 9);
  *((_OWORD *)this + 10) = *((_OWORD *)a2 + 10);
  *((_OWORD *)this + 11) = *((_OWORD *)a2 + 11);
  *((_OWORD *)this + 12) = *((_OWORD *)a2 + 12);
  *((_OWORD *)this + 13) = *((_OWORD *)a2 + 13);
  uint64_t v4 = *((void *)a2 + 28);
  *((void *)this + 29) = 0;
  *((void *)this + 30) = 0;
  *((void *)this + 28) = v4;
  *((unsigned char *)this + 248) = *((unsigned char *)a2 + 248);
  *((void *)this + 32) = 0;
  LiImagePolygon::LiImagePolygon((LiAgent *)((char *)this + 264));
  *((unsigned char *)this + 376) = 0;
  *(void *)((char *)this + 380) = 0x3F8000003F800000;
  int v5 = (CGColorSpace *)*((void *)a2 + 50);
  *((void *)this + 49) = 0;
  *((void *)this + 50) = v5;
  if (v5) {
    PCCFRefTraits<CGColorSpace *>::retain(v5);
  }
  uint64_t v6 = *((void *)a2 + 51);
  *((_DWORD *)this + 104) = *((_DWORD *)a2 + 104);
  *((void *)this + 51) = v6;
  *((unsigned char *)this + 424) = *((unsigned char *)a2 + 424);
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 28) = 0u;
  PCColorDescription::PCColorDescription((PCColorDescription *)this + 18);
  *((unsigned char *)this + 456) = 1;
}

void sub_1B7A56F44(_Unwind_Exception *a1)
{
  LiImagePolygon::~LiImagePolygon(v3);
  uint64_t v5 = *(void *)(v1 + 256);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  LiClipSet::~LiClipSet(v2);
  _Unwind_Resume(a1);
}

void LiAgent::LiAgent(LiAgent *this, const LiRenderParameters *a2, int a3)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 8) = a3;
  *(void *)((char *)this + 36) = 6;
  *((unsigned char *)this + 44) = 0;
  *((void *)this + 6) = a2;
  *((unsigned char *)this + 56) = 0;
  *(_OWORD *)((char *)this + 60) = xmmword_1B7E74760;
  *((unsigned char *)this + 76) = 0;
  *((_OWORD *)this + 5) = xmmword_1B7E74760;
  LiClipSet::LiClipSet((LiAgent *)((char *)this + 96));
  *((void *)this + 30) = 0;
  *((unsigned char *)this + 248) = 0;
  *((void *)this + 32) = 0;
  *((void *)this + 18) = 0;
  *((void *)this + 19) = 0;
  LiImagePolygon::LiImagePolygon((LiAgent *)((char *)this + 264));
  *((unsigned char *)this + 376) = 0;
  *(void *)((char *)this + 380) = 0x3F8000003F800000;
  uint64_t v5 = (CGColorSpace *)*((void *)a2 + 20);
  *((void *)this + 49) = 0;
  *((void *)this + 50) = v5;
  if (v5) {
    PCCFRefTraits<CGColorSpace *>::retain(v5);
  }
  uint64_t v6 = *((void *)a2 + 21);
  *((_DWORD *)this + 104) = *((_DWORD *)a2 + 44);
  *((void *)this + 51) = v6;
  *((unsigned char *)this + 424) = *((unsigned char *)a2 + 184);
  PCColorDescription::PCColorDescription((PCColorDescription *)this + 18);
  *((unsigned char *)this + 456) = 1;
  getIdentity();
  *((void *)this + 20) = &getIdentity(void)::s_identity;
  getIdentity();
  *((void *)this + 21) = &getIdentity(void)::s_identity;
  getIdentity();
  *((void *)this + 22) = &getIdentity(void)::s_identity;
  getIdentity();
  *((void *)this + 23) = &getIdentity(void)::s_identity;
  getIdentity();
  *((void *)this + 24) = &getIdentity(void)::s_identity;
  getIdentity();
  *((void *)this + 27) = &getIdentity(void)::s_identity;
  getIdentity();
  *((void *)this + 25) = &getIdentity(void)::s_identity;
  getIdentity();
  *((void *)this + 26) = &getIdentity(void)::s_identity;
  getIdentity();
  *((void *)this + 28) = &getIdentity(void)::s_identity;
  *((void *)this + 29) = 0;
}

void sub_1B7A570E4(_Unwind_Exception *a1)
{
  LiImagePolygon::~LiImagePolygon(v3);
  uint64_t v5 = *(void *)(v1 + 256);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  LiClipSet::~LiClipSet(v2);
  _Unwind_Resume(a1);
}

void getIdentity(void)
{
  {
    qword_1EB9A0838 = 0x3FF0000000000000;
    qword_1EB9A0810 = 0x3FF0000000000000;
    qword_1EB9A07E8 = 0x3FF0000000000000;
    getIdentity(void)::s_identity = 0x3FF0000000000000;
    unk_1EB9A07C8 = 0u;
    unk_1EB9A07D8 = 0u;
    xmmword_1EB9A07F0 = 0u;
    unk_1EB9A0800 = 0u;
    unk_1EB9A0818 = 0u;
    unk_1EB9A0828 = 0u;
    __cxa_atexit((void (*)(void *))OZChannelBase::setRangeName, &getIdentity(void)::s_identity, &dword_1B73F3000);
  }
}

uint64_t LiAgent::LiAgent(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = a4;
  *(void *)(a1 + 36) = 6;
  *(unsigned char *)(a1 + 44) = 0;
  *(void *)(a1 + 48) = a2;
  *(unsigned char *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 60) = xmmword_1B7E74760;
  *(unsigned char *)(a1 + 76) = 0;
  *(_OWORD *)(a1 + 80) = xmmword_1B7E74760;
  LiClipSet::LiClipSet((LiClipSet *)(a1 + 96));
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 240) = 0;
  *(unsigned char *)(a1 + 248) = 0;
  LiImagePolygon::LiImagePolygon((LiImagePolygon *)(a1 + 264));
  *(unsigned char *)(a1 + 376) = 0;
  *(void *)(a1 + 380) = 0x3F8000003F800000;
  uint64_t v7 = *(CGColorSpace **)(a2 + 160);
  *(void *)(a1 + 392) = 0;
  *(void *)(a1 + 400) = v7;
  if (v7) {
    PCCFRefTraits<CGColorSpace *>::retain(v7);
  }
  uint64_t v8 = *(void *)(a2 + 168);
  *(_DWORD *)(a1 + 416) = *(_DWORD *)(a2 + 176);
  *(void *)(a1 + 408) = v8;
  *(unsigned char *)(a1 + 424) = *(unsigned char *)(a2 + 184);
  PCColorDescription::PCColorDescription((PCColorDescription *)(a1 + 432));
  *(unsigned char *)(a1 + 456) = 1;
  *(void *)(a1 + 160) = a3;
  getIdentity();
  *(void *)(a1 + 168) = &getIdentity(void)::s_identity;
  getIdentity();
  *(void *)(a1 + 176) = &getIdentity(void)::s_identity;
  getIdentity();
  *(void *)(a1 + 184) = &getIdentity(void)::s_identity;
  getIdentity();
  *(void *)(a1 + 192) = &getIdentity(void)::s_identity;
  getIdentity();
  *(void *)(a1 + 216) = &getIdentity(void)::s_identity;
  getIdentity();
  *(void *)(a1 + 200) = &getIdentity(void)::s_identity;
  getIdentity();
  *(void *)(a1 + 208) = &getIdentity(void)::s_identity;
  getIdentity();
  *(void *)(a1 + 224) = &getIdentity(void)::s_identity;
  return a1;
}

void sub_1B7A57324(_Unwind_Exception *a1)
{
  LiImagePolygon::~LiImagePolygon(v3);
  uint64_t v5 = *(void *)(v1 + 256);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  LiClipSet::~LiClipSet(v2);
  _Unwind_Resume(a1);
}

void LiAgent::LiAgent(LiAgent *this, LiImageSource *a2, const LiRenderParameters *a3)
{
  *(void *)this = 0;
  *((void *)this + 1) = a2;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_DWORD *)this + 9) = (*(uint64_t (**)(LiImageSource *, const LiRenderParameters *))(*(void *)a2 + 56))(a2, a3);
  *((_DWORD *)this + 10) = (*(uint64_t (**)(LiImageSource *))(*(void *)a2 + 80))(a2);
  *((unsigned char *)this + 44) = 0;
  *((void *)this + 6) = a3;
  *((unsigned char *)this + 56) = 0;
  *(_OWORD *)((char *)this + 60) = xmmword_1B7E74760;
  *((unsigned char *)this + 76) = 0;
  *((_OWORD *)this + 5) = xmmword_1B7E74760;
  LiClipSet::LiClipSet((LiAgent *)((char *)this + 96));
  *((void *)this + 32) = 0;
  *((void *)this + 18) = 0;
  *((void *)this + 19) = 0;
  *((void *)this + 29) = 0;
  *((void *)this + 30) = 0;
  *((unsigned char *)this + 248) = 0;
  LiImagePolygon::LiImagePolygon((LiAgent *)((char *)this + 264));
  *((unsigned char *)this + 376) = 0;
  *(void *)((char *)this + 380) = 0x3F8000003F800000;
  uint64_t v6 = (CGColorSpace *)*((void *)a3 + 20);
  *((void *)this + 49) = 0;
  *((void *)this + 50) = v6;
  if (v6) {
    PCCFRefTraits<CGColorSpace *>::retain(v6);
  }
  uint64_t v7 = *((void *)a3 + 21);
  *((_DWORD *)this + 104) = *((_DWORD *)a3 + 44);
  *((void *)this + 51) = v7;
  *((unsigned char *)this + 424) = *((unsigned char *)a3 + 184);
  PCColorDescription::PCColorDescription((PCColorDescription *)this + 18);
  *((unsigned char *)this + 456) = 1;
  getIdentity();
  *((void *)this + 20) = &getIdentity(void)::s_identity;
  getIdentity();
  *((void *)this + 21) = &getIdentity(void)::s_identity;
  getIdentity();
  *((void *)this + 22) = &getIdentity(void)::s_identity;
  getIdentity();
  *((void *)this + 23) = &getIdentity(void)::s_identity;
  getIdentity();
  *((void *)this + 24) = &getIdentity(void)::s_identity;
  getIdentity();
  *((void *)this + 27) = &getIdentity(void)::s_identity;
  getIdentity();
  *((void *)this + 25) = &getIdentity(void)::s_identity;
  getIdentity();
  *((void *)this + 26) = &getIdentity(void)::s_identity;
  getIdentity();
  *((void *)this + 28) = &getIdentity(void)::s_identity;
}

void sub_1B7A57514(_Unwind_Exception *a1)
{
  LiImagePolygon::~LiImagePolygon(v3);
  uint64_t v5 = *(void *)(v1 + 256);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  LiClipSet::~LiClipSet(v2);
  _Unwind_Resume(a1);
}

void LiAgent::LiAgent(LiAgent *this, LiImageSource *a2, LiAgent *a3)
{
  *(void *)this = a3;
  *((void *)this + 1) = a2;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_DWORD *)this + 9) = (*(uint64_t (**)(LiImageSource *, void))(*(void *)a2 + 56))(a2, *((void *)a3 + 6));
  *((_DWORD *)this + 10) = (*(uint64_t (**)(LiImageSource *))(*(void *)a2 + 80))(a2);
  *((void *)this + 6) = *((void *)a3 + 6);
  *((unsigned char *)this + 56) = 0;
  *(_OWORD *)((char *)this + 60) = xmmword_1B7E74760;
  *((unsigned char *)this + 76) = 0;
  *((_OWORD *)this + 5) = *((_OWORD *)a3 + 5);
  LiClipSet::LiClipSet((LiAgent *)((char *)this + 96), (LiAgent *)((char *)a3 + 96));
  *((_OWORD *)this + 9) = *((_OWORD *)a3 + 9);
  *((void *)this + 29) = 0;
  *((void *)this + 30) = 0;
  *((unsigned char *)this + 248) = *((unsigned char *)a3 + 248);
  *((void *)this + 32) = 0;
  LiImagePolygon::LiImagePolygon((LiAgent *)((char *)this + 264));
  *((unsigned char *)this + 376) = 0;
  *(void *)((char *)this + 380) = 0x3F8000003F800000;
  uint64_t v6 = (CGColorSpace *)*((void *)a3 + 50);
  *((void *)this + 49) = 0;
  *((void *)this + 50) = v6;
  if (v6) {
    PCCFRefTraits<CGColorSpace *>::retain(v6);
  }
  uint64_t v7 = *((void *)a3 + 51);
  *((_DWORD *)this + 104) = *((_DWORD *)a3 + 104);
  *((void *)this + 51) = v7;
  *((unsigned char *)this + 424) = *((unsigned char *)a3 + 424);
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 28) = 0u;
  PCColorDescription::PCColorDescription((PCColorDescription *)this + 18);
  *((unsigned char *)this + 456) = 1;
  *((_OWORD *)this + 10) = *((_OWORD *)a3 + 10);
  *((_OWORD *)this + 11) = *((_OWORD *)a3 + 11);
  *((void *)this + 27) = *((void *)a3 + 27);
  *((_OWORD *)this + 12) = *((_OWORD *)a3 + 12);
  *((void *)this + 26) = *((void *)a3 + 26);
  *((void *)this + 28) = *((void *)a3 + 28);
  if ((*(unsigned int (**)(LiImageSource *))(*(void *)a2 + 96))(a2)) {
    BOOL v8 = *((unsigned char *)a3 + 44) != 0;
  }
  else {
    BOOL v8 = 0;
  }
  *((unsigned char *)this + 44) = v8;
}

void sub_1B7A57740(_Unwind_Exception *a1)
{
  LiImagePolygon::~LiImagePolygon(v3);
  uint64_t v5 = *(void *)(v1 + 256);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  LiClipSet::~LiClipSet(v2);
  _Unwind_Resume(a1);
}

void LiAgent::~LiAgent(LiAgent *this)
{
  uint64_t v2 = *((void *)this + 29);
  if (v2) {
    MEMORY[0x1BA9BFBA0](v2, 0x1000C40AE2C30F4);
  }
  *((void *)this + 29) = 0;
  uint64_t v3 = *((void *)this + 49);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  *((void *)this + 49) = 0;
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)this + 54);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)this + 50);
  LiImagePolygon::~LiImagePolygon((LiAgent *)((char *)this + 264));
  uint64_t v4 = *((void *)this + 32);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  LiClipSet::~LiClipSet((LiAgent *)((char *)this + 96));
}

uint64_t LiAgent::loadTransform(uint64_t result, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = *(void *)(result + 232);
  if (!v3) {
    operator new();
  }
  if (v3 != a2)
  {
    for (uint64_t i = 0; i != 4; ++i)
    {
      for (uint64_t j = 0; j != 32; j += 8)
        *(void *)(v3 + j) = *(void *)(v2 + j);
      v3 += 32;
      v2 += 32;
    }
  }
  return result;
}

uint64_t LiAgent::clearTransform(LiAgent *this)
{
  uint64_t result = *((void *)this + 29);
  if (result) {
    uint64_t result = MEMORY[0x1BA9BFBA0](result, 0x1000C40AE2C30F4);
  }
  *((void *)this + 29) = 0;
  return result;
}

void LiAgent::setImageSpace(uint64_t a1, int a2)
{
  if ((a2 & 0xFFFFFFFE) == 2)
  {
    if (!PCMatrix44Tmpl<double>::is2Didentity(*(double **)(a1 + 168))
      || a2 != 2 && !PCMatrix44Tmpl<double>::is2Didentity(*(double **)(a1 + 224)))
    {
      operator new();
    }
  }
  else if (a2)
  {
    if (a2 == 1 && !PCMatrix44Tmpl<double>::isIdentity(*(double **)(a1 + 176))) {
      operator new();
    }
  }
  else
  {
    getIdentity();
    *(void *)(a1 + 160) = &getIdentity(void)::s_identity;
    getIdentity();
    *(void *)(a1 + 168) = &getIdentity(void)::s_identity;
    getIdentity();
    *(void *)(a1 + 176) = &getIdentity(void)::s_identity;
    getIdentity();
    *(void *)(a1 + 184) = &getIdentity(void)::s_identity;
    getIdentity();
    *(void *)(a1 + 192) = &getIdentity(void)::s_identity;
    getIdentity();
    *(void *)(a1 + 216) = &getIdentity(void)::s_identity;
    getIdentity();
    *(void *)(a1 + 200) = &getIdentity(void)::s_identity;
    getIdentity();
    *(void *)(a1 + 208) = &getIdentity(void)::s_identity;
    getIdentity();
    *(void *)(a1 + 224) = &getIdentity(void)::s_identity;
  }
}

uint64_t LiAgent::getObjectToFilmTransform@<X0>(LiAgent *this@<X0>, uint64_t a2@<X8>)
{
  return PCMatrix44Tmpl<double>::operator*(*((void *)this + 26), *((long long **)this + 24), a2);
}

uint64_t LiAgent::getFilmToObjectTransform@<X0>(LiAgent *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v14 = 0x3FF0000000000000;
  uint64_t v11 = 0x3FF0000000000000;
  uint64_t v8 = 0x3FF0000000000000;
  uint64_t v5 = 0x3FF0000000000000;
  long long v6 = 0u;
  long long v7 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  PCMatrix44Tmpl<double>::planarInverseZ((uint64_t)&v5, *((double **)this + 22), 0.0);
  return PCMatrix44Tmpl<double>::operator*((uint64_t)&v5, *((long long **)this + 21), a2);
}

uint64_t LiAgent::setPixelTransform(uint64_t result, uint64_t a2)
{
  unint64_t v2 = 0;
  BOOL v3 = 0;
  uint64_t v4 = *(void *)(result + 160);
  while (2)
  {
    for (uint64_t i = 0; i != 32; i += 8)
    {
      if (vabdd_f64(*(double *)(a2 + i), *(double *)(v4 + i)) >= 0.0000001)
      {
        if (!v3) {
          operator new();
        }
        return result;
      }
    }
    BOOL v3 = v2 > 2;
    v4 += 32;
    a2 += 32;
    if (++v2 != 4) {
      continue;
    }
    break;
  }
  return result;
}

int32x2_t LiAgent::computeROI(uint64_t a1, long long *a2, uint64_t a3)
{
  PCMatrix44Tmpl<double>::operator*(*(void *)(a3 + 160), a2, (uint64_t)v26);
  uint64_t v25 = 0x3FF0000000000000;
  uint64_t v22 = 0x3FF0000000000000;
  uint64_t v19 = 0x3FF0000000000000;
  uint64_t v16 = 0x3FF0000000000000;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  LiAgent::getInversePixelTransform(a1, (uint64_t)&v16, 0.0);
  PCMatrix44Tmpl<double>::operator*((uint64_t)v26, (long long *)&v16, (uint64_t)v27);
  uint64_t v5 = *(void *)(a1 + 60);
  v6.i64[0] = (int)v5;
  v6.i64[1] = SHIDWORD(v5);
  float64x2_t v7 = vcvtq_f64_s64(v6);
  uint64_t v8 = *(void *)(a1 + 68);
  v6.i64[0] = (int)v8;
  v6.i64[1] = SHIDWORD(v8);
  *(float64x2_t *)float64x2_t v26 = v7;
  *(float64x2_t *)&v26[16] = vcvtq_f64_s64(v6);
  BOOL v9 = PCMatrix44Tmpl<double>::transformRect<double>(v27, (double *)v26, (uint64_t)v26);
  *(unsigned char *)(a3 + 76) = v9;
  if (v9)
  {
    v11.f64[0] = *(float64_t *)v26;
    int8x16_t v12 = (int8x16_t)vaddq_f64(*(float64x2_t *)&v26[8], (float64x2_t)xmmword_1B837B4F0);
    float64x2_t v13 = (float64x2_t)vextq_s8(v12, v12, 8uLL);
    v11.f64[1] = *(float64_t *)&v26[24];
    float64x2_t v14 = vaddq_f64(v11, (float64x2_t)xmmword_1B837B4F0);
    float64x2_t v15 = vaddq_f64(v13, v14);
    v13.f64[0] = v14.f64[0];
    int32x2_t result = vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(v13, (float64x2_t)vdupq_n_s64(0x3E7AD7F29ABCAF48uLL)))));
    *(int32x2_t *)(a3 + 80) = result;
    *(int32x2_t *)(a3 + 88) = vsub_s32(vmovn_s64(vcvtq_s64_f64(vrndpq_f64(v15))), result);
  }
  return result;
}

void sub_1B7A58168(_Unwind_Exception *a1, int a2)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x1B7A58154);
  }
  _Unwind_Resume(a1);
}

BOOL LiAgent::getInversePixelTransform@<W0>(LiAgent *this@<X0>, double a2@<D0>, uint64_t a3@<X8>)
{
  *(void *)(a3 + 120) = 0x3FF0000000000000;
  *(void *)(a3 + 80) = 0x3FF0000000000000;
  *(void *)(a3 + 40) = 0x3FF0000000000000;
  *(void *)a3 = 0x3FF0000000000000;
  *(_OWORD *)(a3 + 8) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 88) = 0u;
  *(_OWORD *)(a3 + 104) = 0u;
  return LiAgent::getInversePixelTransform((uint64_t)this, a3, a2);
}

uint64_t LiAgent::getHelium@<X0>(LiAgent *this@<X0>, LiImageSource *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6 = *((void *)this + 32);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
  }
  *((void *)this + 32) = 0;
  *((void *)this + 42) = *((void *)this + 41);
  memset(v12, 0, sizeof(v12));
  PCColorDescription::PCColorDescription((PCColorDescription *)v12);
  char v7 = 1;
  v12[24] = 1;
  uint64_t v8 = (CGColorSpace *)*((void *)this + 54);
  uint64_t v9 = *(void *)v12;
  if (v8 && v8 != *(CGColorSpace **)v12)
  {
    PCCFRefTraits<CGColorSpace *>::release(v8);
    uint64_t v9 = *(void *)v12;
    char v7 = v12[24];
  }
  long long v10 = (uint64_t *)((char *)this + 256);
  *((void *)this + 54) = v9;
  *(void *)int8x16_t v12 = 0;
  *((_DWORD *)this + 110) = *(_DWORD *)&v12[8];
  *(void *)((char *)this + 444) = *(void *)&v12[12];
  *((unsigned char *)this + 456) = v7;
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)v12);
  if (a2)
  {
    *((void *)this + 2) = a2;
    operator new();
  }
  uint64_t result = *v10;
  *a3 = *v10;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
  }
  return result;
}

void sub_1B7A597D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33)
{
  LiClipSet::~LiClipSet((LiClipSet *)&a25);
  LiImagePolygon::~LiImagePolygon((LiImagePolygon *)&a33);
  (*(void (**)(uint64_t))(*(void *)v35 + 24))(v35);
  MEMORY[0x1BA9BFBA0](v34, 0x1000C4061254B48);
  *(unsigned char *)(v33 + 44) = 0;
  std::unique_ptr<LiAgent>::reset[abi:ne180100]((LiAgent **)(v36 - 96), 0);
  _Unwind_Resume(a1);
}

double LiAgent::getObjectToFilmTransform(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 208);
  if (v2 != a2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = a2;
    do
    {
      for (uint64_t i = 0; i != 32; i += 8)
        *(void *)(v4 + i) = *(void *)(v2 + i);
      ++v3;
      v4 += 32;
      v2 += 32;
    }
    while (v3 != 4);
  }
  return PCMatrix44Tmpl<double>::rightMult(a2, *(double **)(a1 + 192));
}

double LiAgent::getFilmToWorldTransform(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 184);
  if (v2 != a2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = a2;
    do
    {
      for (uint64_t i = 0; i != 32; i += 8)
        *(void *)(v4 + i) = *(void *)(v2 + i);
      ++v3;
      v4 += 32;
      v2 += 32;
    }
    while (v3 != 4);
  }
  return PCMatrix44Tmpl<double>::rightMult(a2, *(double **)(a1 + 168));
}

BOOL LiAgent::getImageToFilmTransform(uint64_t a1, uint64_t a2)
{
  BOOL result = PCMatrix44Tmpl<double>::planarInverseZ(a2, *(double **)(a1 + 168), 0.0);
  if (!result)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v4, "getImageToFilmTransform: failed to invert");
    PCException::PCException(exception, &v4);
    *(void *)exception = &unk_1F10C3980;
  }
  return result;
}

void sub_1B7A59C74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

uint64_t PCMath::equivalent2D(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = 0;
  BOOL v3 = 0;
  uint64_t v25 = *MEMORY[0x1E4F143B8];
LABEL_2:
  uint64_t v4 = 0;
  while (vabdd_f64(*(double *)(a1 + 32 * dword_1B837B574[v2] + 8 * dword_1B837B574[v4]), *(double *)(a2 + 32 * dword_1B837B574[v2] + 8 * dword_1B837B574[v4])) < 0.0000001)
  {
    if (++v4 == 3)
    {
      BOOL v3 = v2++ > 1;
      if (v2 != 3) {
        goto LABEL_2;
      }
      return 1;
    }
  }
  if (v3) {
    return 1;
  }
  uint64_t v6 = 0;
  LODWORD(v7) = 0;
  do
  {
    uint64_t v8 = 0;
    uint64_t v9 = dword_1B837B574[v6];
    uint64_t v7 = (int)v7;
    do
    {
      uint64_t v10 = dword_1B837B574[v8];
      *(void *)&v24[8 * v7 + 72] = *(void *)(a1 + 32 * v9 + 8 * v10);
      *(void *)&v24[8 * v7++] = *(void *)(a2 + 32 * v9 + 8 * v10);
      ++v8;
    }
    while (v8 != 3);
    ++v6;
  }
  while (v6 != 3);
  uint64_t v11 = 0;
  double v12 = 0.0;
  do
  {
    double v12 = v12 + *(double *)&v24[v11 + 72] * *(double *)&v24[v11 + 72];
    v11 += 8;
  }
  while (v11 != 72);
  uint64_t v13 = 0;
  double v14 = 0.0;
  do
  {
    double v14 = v14 + *(double *)&v24[v13] * *(double *)&v24[v13];
    v13 += 8;
  }
  while (v13 != 72);
  double v15 = sqrt(v12);
  double v16 = sqrt(v14);
  BOOL v17 = v15 < 0.0000001 && v15 > -0.0000001;
  BOOL v18 = v16 > -0.0000001;
  if (v16 >= 0.0000001) {
    BOOL v18 = 0;
  }
  uint64_t result = v17 & v18;
  if (!v17 && !v18)
  {
    uint64_t v19 = 0;
    double v20 = 0.0;
    do
    {
      double v20 = v20 + *(double *)&v24[v19 + 72] * *(double *)&v24[v19];
      v19 += 8;
    }
    while (v19 != 72);
    uint64_t v21 = 0;
    if (v20 < 0.0) {
      double v16 = -v16;
    }
    do
    {
      double v22 = vabdd_f64(*(double *)&v24[v21 + 72] / v15, *(double *)&v24[v21] / v16);
      uint64_t result = v22 < 0.0000001;
      if (v22 >= 0.0000001) {
        break;
      }
      BOOL v23 = v21 == 64;
      v21 += 8;
    }
    while (!v23);
  }
  return result;
}

uint64_t LiAgent::getHeliumRenderer(LiRenderParameters **this)
{
  return LiRenderParameters::getHeliumRenderer(this[6]);
}

uint64_t LiAgent::rasterizeEdges(LiAgent *this)
{
  return *(unsigned __int8 *)(*((void *)this + 6) + 135);
}

BOOL LiAgent::getInversePixelTransform(uint64_t a1, uint64_t a2, double a3)
{
  BOOL result = PCMatrix44Tmpl<double>::planarInverseZ(a2, *(double **)(a1 + 160), a3);
  if (!result)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v5, "LiAgent::getInversePixelTransform");
    PCException::PCException(exception, &v5);
    *(void *)exception = &unk_1F10C3980;
  }
  return result;
}

void sub_1B7A59F64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

uint64_t LiAgent::getRequestedColorSpace(LiAgent *this)
{
  return FxColorDescription::getCGColorSpace((FxColorDescription *)((char *)this + 400));
}

CGColorSpace **LiAgent::getActualColorDescription(LiAgent *this)
{
  unint64_t v2 = (CGColorSpace **)((char *)this + 432);
  if (!FxColorDescription::getCGColorSpace((FxColorDescription *)((char *)this + 432)))
  {
    uint64_t v3 = *((void *)this + 6);
    PCCFRef<CGColorSpace *>::operator=(v2, (CGColorSpace **)(v3 + 160));
    uint64_t v4 = *(void *)(v3 + 168);
    *((_DWORD *)this + 112) = *(_DWORD *)(v3 + 176);
    *((void *)this + 55) = v4;
    *((unsigned char *)this + 456) = *(unsigned char *)(v3 + 184);
  }
  return v2;
}

CGColorSpace **LiAgent::setActualColorDescription(CGColorSpace **this, const FxColorDescription *a2)
{
  BOOL result = PCCFRef<CGColorSpace *>::operator=(this + 54, &a2->_pcColorDesc._colorSpaceRef._obj);
  PCString v5 = *(CGColorSpace **)&a2->_pcColorDesc._dynamicRange;
  *((_DWORD *)this + 112) = LODWORD(a2->_pcColorDesc._toneMapMethod._gain);
  this[55] = v5;
  *((unsigned char *)this + 456) = a2->_isPremultiplied;
  return result;
}

uint64_t LiAgent::makeHeliumXForm@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X3>, void *a4@<X8>)
{
  long long v4 = *(_OWORD *)(a2 + 80);
  v14[4] = *(_OWORD *)(a2 + 64);
  v14[5] = v4;
  long long v5 = *(_OWORD *)(a2 + 112);
  v14[6] = *(_OWORD *)(a2 + 96);
  v14[7] = v5;
  long long v6 = *(_OWORD *)(a2 + 16);
  v14[0] = *(_OWORD *)a2;
  v14[1] = v6;
  long long v7 = *(_OWORD *)(a2 + 48);
  v14[2] = *(_OWORD *)(a2 + 32);
  v14[3] = v7;
  double v8 = sqrt(*(double *)(a2 + 96) * *(double *)(a2 + 96)+ *(double *)(a2 + 104) * *(double *)(a2 + 104)+ *(double *)(a2 + 112) * *(double *)(a2 + 112)+ *(double *)(a2 + 120) * *(double *)(a2 + 120));
  if (v8 <= -0.0000001 || v8 >= 0.0000001)
  {
    uint64_t v9 = 0;
    uint64_t v10 = v14;
    double v11 = 1.0 / v8;
    do
    {
      for (uint64_t i = 0; i != 2; ++i)
        v10[i] = vmulq_n_f64((float64x2_t)v10[i], v11);
      ++v9;
      v10 += 2;
    }
    while (v9 != 4);
  }
  return LiAgent::makeHeliumXForm(a1, (uint64_t)v14, a3, a4);
}

uint64_t LiAgent::outCrop(LiAgent *this, const LiImagePolygon *a2)
{
  return LiImagePolygon::operator=(*(void *)this + 264, (uint64_t)a2);
}

CGColorSpace **LiAgent::conformToRequestedColorSpace@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  ActualColorDescription = LiAgent::getActualColorDescription((LiAgent *)a1);
  long long v7 = *ActualColorDescription;
  v13._pcColorDesc._colorSpaceRef._obuint64_t j = v7;
  if (v7) {
    PCCFRefTraits<CGColorSpace *>::retain(v7);
  }
  double v8 = ActualColorDescription[1];
  v13._pcColorDesc._toneMapMethod._gain = *((float *)ActualColorDescription + 4);
  *(void *)&v13._pcColorDesc._dynamicRange = v8;
  v13._isPremultiplied = *((unsigned char *)ActualColorDescription + 24);
  uint64_t v9 = *(CGColorSpace **)(a1 + 400);
  v12._pcColorDesc._colorSpaceRef._obuint64_t j = v9;
  if (v9) {
    PCCFRefTraits<CGColorSpace *>::retain(v9);
  }
  *(void *)&v12._pcColorDesc._dynamicRange = *(void *)(a1 + 408);
  v12._pcColorDesc._toneMapMethod._gain = *(float *)(a1 + 416);
  v12._isPremultiplied = *(unsigned char *)(a1 + 424);
  if (FxColorDescription::getCGColorSpace(&v12) && FxColorDescription::getCGColorSpace(&v13))
  {
    FxApplyColorConform(a2, &v13, &v12, a3);
    PCCFRef<CGColorSpace *>::operator=((CGColorSpace **)(a1 + 432), &v12._pcColorDesc._colorSpaceRef._obj);
    *(void *)(a1 + 440) = *(void *)&v12._pcColorDesc._dynamicRange;
    *(float *)(a1 + 448) = v12._pcColorDesc._toneMapMethod._gain;
    *(unsigned char *)(a1 + 456) = v12._isPremultiplied;
  }
  else
  {
    uint64_t v10 = *a2;
    *a3 = *a2;
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 16))(v10);
    }
  }
  PCCFRef<CGColorSpace *>::~PCCFRef(&v12._pcColorDesc._colorSpaceRef._obj);
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v13._pcColorDesc._colorSpaceRef._obj);
}

void sub_1B7A5A24C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, CGColorSpace *a9, uint64_t a10, uint64_t a11, uint64_t a12, CGColorSpace *a13)
{
  if (*v13) {
    (*(void (**)(void))(*(void *)*v13 + 24))(*v13);
  }
  PCCFRef<CGColorSpace *>::~PCCFRef(&a9);
  PCCFRef<CGColorSpace *>::~PCCFRef(&a13);
  _Unwind_Resume(a1);
}

void LiAgent::getHeliumInColorSpace(LiAgent *this@<X0>, LiImageSource *a2@<X1>, CGColorSpace *a3@<X2>, uint64_t *a4@<X8>)
{
  LiAgentRequestedColorSpaceSentry::LiAgentRequestedColorSpaceSentry((LiAgentRequestedColorSpaceSentry *)v7, this, a3);
  LiAgent::getHelium(this, a2, a4);
  LiAgentRequestedColorSpaceSentry::~LiAgentRequestedColorSpaceSentry(v7);
}

void sub_1B7A5A304(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  LiAgentRequestedColorSpaceSentry::~LiAgentRequestedColorSpaceSentry((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

void LiAgent::getHeliumInColorDescription(LiAgent *this@<X0>, LiImageSource *a2@<X1>, const FxColorDescription *a3@<X2>, uint64_t *a4@<X8>)
{
  LiAgentRequestedColorSpaceSentry::LiAgentRequestedColorSpaceSentry((LiAgentRequestedColorSpaceSentry *)v7, this, a3);
  LiAgent::getHelium(this, a2, a4);
  LiAgentRequestedColorSpaceSentry::~LiAgentRequestedColorSpaceSentry(v7);
}

void sub_1B7A5A378(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  LiAgentRequestedColorSpaceSentry::~LiAgentRequestedColorSpaceSentry((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

uint64_t LiAgent::getCrop(LiAgent *this)
{
  return (uint64_t)this + 264;
}

uint64_t LiAgent::getDOD@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = xmmword_1B7E74760;
  *(unsigned char *)(a2 + 16) = 0;
  if (*(void *)(this + 256))
  {
    uint64_t v3 = this;
    HeliumRenderer = (HGRenderer *)LiRenderParameters::getHeliumRenderer(*(LiRenderParameters **)(this + 48));
    unint64_t DOD = HGRenderer::GetDOD(HeliumRenderer, *(HGNode **)(v3 + 256));
    unint64_t v7 = v6;
    this = HGRectIsInfinite(DOD, v6);
    if (this)
    {
      *(unsigned char *)(a2 + 16) = 1;
    }
    else
    {
      this = HGRectIsNull(DOD, v7);
      if (this)
      {
        LODWORD(v8) = 0;
        int v9 = 0;
        int v10 = -1;
        int v11 = -1;
      }
      else
      {
        unint64_t v8 = HIDWORD(DOD);
        if ((int)DOD <= -1073741823) {
          int v9 = -1073741823;
        }
        else {
          int v9 = DOD;
        }
        if (SHIDWORD(DOD) <= -1073741823) {
          LODWORD(v8) = -1073741823;
        }
        if ((int)v7 >= 1073741822) {
          int v12 = 1073741822;
        }
        else {
          int v12 = v7;
        }
        unint64_t v13 = HIDWORD(v7);
        if (SHIDWORD(v7) >= 1073741822) {
          LODWORD(v13) = 1073741822;
        }
        int v10 = v12 - v9;
        int v11 = v13 - v8;
      }
      *(_DWORD *)a2 = v9;
      *(_DWORD *)(a2 + 4) = v8;
      *(_DWORD *)(a2 + 8) = v10;
      *(_DWORD *)(a2 + 12) = v11;
    }
  }
  return this;
}

void LiAgent::getExtent(LiAgent *this@<X0>, LiPolygon *a2@<X8>)
{
  LiPolygon::LiPolygon(a2);
  if (((*((void *)this + 42) - *((void *)this + 41)) & 0x1FFFFFFFE0) != 0)
  {
    LiPolygon::operator=((uint64_t)a2, (uint64_t)this + 264);
  }
  else if (*((void *)this + 32))
  {
    LiAgent::getDOD((uint64_t)this, (uint64_t)v8);
    if (v11)
    {
      LiPolygon::setAll((uint64_t **)a2);
    }
    else if ((v9 & 0x80000000) == 0 && (v10 & 0x80000000) == 0)
    {
      v4.i64[0] = v8[0];
      v4.i64[1] = v8[1];
      float64x2_t v5 = vcvtq_f64_s64(v4);
      double v6 = (double)v9;
      double v7 = (double)v10;
      LiPolygon::set((uint64_t)a2, v5.f64);
    }
  }
}

void sub_1B7A5A520(_Unwind_Exception *a1)
{
  LiPolygon::~LiPolygon(v1);
  _Unwind_Resume(a1);
}

void LiAgent::getBoundary(LiAgent *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v2 = (LiImageSource *)*((void *)this + 2);
  if (!v2)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v80, "can't call getBoundary before getHelium");
    PCException::PCException(exception, &v80);
  }
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a2 + 16) = _Q0;
  LiAgent::LiAgent((LiAgent *)&v80, v2, this);
  if (!(*(unsigned int (**)(void, LiAgent *, uint64_t))(**((void **)this + 2) + 24))(*((void *)this + 2), this, a2))goto LABEL_25; {
  int v10 = v81;
  }
  char v11 = (PCString *)*((void *)this + 29);
  if (v11 || v81 && v81 != *((_DWORD *)this + 10))
  {
    uint64_t v79 = 0x3FF0000000000000;
    uint64_t v76 = 0x3FF0000000000000;
    uint64_t v73 = 0x3FF0000000000000;
    v70.var0 = (__CFString *)0x3FF0000000000000;
    long long v71 = 0u;
    long long v72 = 0u;
    long long v74 = 0u;
    long long v75 = 0u;
    long long v77 = 0u;
    long long v78 = 0u;
    if (v11 && v11 != &v70)
    {
      uint64_t v12 = 0;
      unint64_t v13 = &v70;
      do
      {
        for (uint64_t i = 0; i != 4; ++i)
          v13[i] = v11[i];
        ++v12;
        v13 += 4;
        v11 += 4;
      }
      while (v12 != 4);
    }
    switch(v10)
    {
      case 1:
        uint64_t v35 = (long long *)*((void *)this + 22);
        long long v36 = v35[3];
        long long v38 = *v35;
        long long v37 = v35[1];
        long long v63 = v35[2];
        long long v64 = v36;
        long long v61 = v38;
        long long v62 = v37;
        long long v39 = v35[7];
        long long v41 = v35[4];
        long long v40 = v35[5];
        long long v67 = v35[6];
        long long v68 = v39;
        long long v65 = v41;
        long long v66 = v40;
        PCMatrix44Tmpl<double>::operator*((uint64_t)&v70, &v61, (uint64_t)v69);
        for (uint64_t j = 0; j != 8; j += 2)
        {
          float32x4_t v43 = (_OWORD *)((char *)&v70 + j * 16);
          long long v44 = v69[j + 1];
          _OWORD *v43 = v69[j];
          v43[1] = v44;
        }
        break;
      case 3:
        uint64_t v25 = (long long *)*((void *)this + 21);
        long long v26 = v25[3];
        long long v28 = *v25;
        long long v27 = v25[1];
        v60[2] = v25[2];
        v60[3] = v26;
        v60[0] = v28;
        v60[1] = v27;
        long long v29 = v25[7];
        long long v31 = v25[4];
        long long v30 = v25[5];
        v60[6] = v25[6];
        v60[7] = v29;
        float32x4_t v60[4] = v31;
        v60[5] = v30;
        PCMatrix44Tmpl<double>::operator*((uint64_t)&v70, v60, (uint64_t)&v61);
        uint64_t v59 = 0x3FF0000000000000;
        uint64_t v56 = 0x3FF0000000000000;
        uint64_t v53 = 0x3FF0000000000000;
        uint64_t v50 = 0x3FF0000000000000;
        long long v51 = 0u;
        long long v52 = 0u;
        long long v54 = 0u;
        long long v55 = 0u;
        long long v57 = 0u;
        long long v58 = 0u;
        PCMatrix44Tmpl<double>::planarInverseZ((uint64_t)&v50, *((double **)this + 28), 0.0);
        PCMatrix44Tmpl<double>::operator*((uint64_t)&v61, (long long *)&v50, (uint64_t)v69);
        for (uint64_t k = 0; k != 8; k += 2)
        {
          uint64_t v33 = (_OWORD *)((char *)&v70 + k * 16);
          long long v34 = v69[k + 1];
          _OWORD *v33 = v69[k];
          v33[1] = v34;
        }
        break;
      case 2:
        double v15 = (long long *)*((void *)this + 21);
        long long v16 = v15[3];
        long long v18 = *v15;
        long long v17 = v15[1];
        long long v63 = v15[2];
        long long v64 = v16;
        long long v61 = v18;
        long long v62 = v17;
        long long v19 = v15[7];
        long long v21 = v15[4];
        long long v20 = v15[5];
        long long v67 = v15[6];
        long long v68 = v19;
        long long v65 = v21;
        long long v66 = v20;
        PCMatrix44Tmpl<double>::operator*((uint64_t)&v70, &v61, (uint64_t)v69);
        for (uint64_t m = 0; m != 8; m += 2)
        {
          BOOL v23 = (_OWORD *)((char *)&v70 + m * 16);
          long long v24 = v69[m + 1];
          *BOOL v23 = v69[m];
          v23[1] = v24;
        }
        break;
    }
    if (!PCMatrix44Tmpl<double>::transformRect<double>((double *)&v70, (double *)a2, a2))
    {
LABEL_25:
      LiAgent::getDOD((uint64_t)this, (uint64_t)&v61);
      if ((_BYTE)v62)
      {
        float32x4_t v48 = (PCException *)__cxa_allocate_exception(0x40uLL);
        PCString::PCString(&v70, "getBoundary failed: infinite DOD");
        PCException::PCException(v48, &v70);
      }
      uint64_t v79 = 0x3FF0000000000000;
      uint64_t v76 = 0x3FF0000000000000;
      uint64_t v73 = 0x3FF0000000000000;
      v70.var0 = (__CFString *)0x3FF0000000000000;
      long long v71 = 0u;
      long long v72 = 0u;
      long long v74 = 0u;
      long long v75 = 0u;
      long long v77 = 0u;
      long long v78 = 0u;
      LiAgent::getInversePixelTransform((uint64_t)this, (uint64_t)&v70, 0.0);
      v45.i64[0] = (int)v61;
      v45.i64[1] = SDWORD1(v61);
      float64x2_t v46 = vcvtq_f64_s64(v45);
      v45.i64[0] = SDWORD2(v61);
      v45.i64[1] = SHIDWORD(v61);
      v69[0] = v46;
      v69[1] = vcvtq_f64_s64(v45);
      if (!PCMatrix44Tmpl<double>::transformRect<double>((double *)&v70, (double *)v69, a2))
      {
        float32x4_t v49 = (PCException *)__cxa_allocate_exception(0x40uLL);
        PCString::PCString(&v70, "getBoundary failed");
        PCException::PCException(v49, &v70);
      }
    }
  }
  LiAgent::~LiAgent((LiAgent *)&v80);
}

void sub_1B7A5A968(_Unwind_Exception *a1)
{
}

void sub_1B7A5AA0C()
{
}

__n128 LiAgent::getFilmToImageTransform@<Q0>(LiAgent *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *((void *)this + 21);
  long long v3 = *(_OWORD *)(v2 + 80);
  *(_OWORD *)(a2 + 64) = *(_OWORD *)(v2 + 64);
  *(_OWORD *)(a2 + 80) = v3;
  long long v4 = *(_OWORD *)(v2 + 112);
  *(_OWORD *)(a2 + 96) = *(_OWORD *)(v2 + 96);
  *(_OWORD *)(a2 + 112) = v4;
  long long v5 = *(_OWORD *)(v2 + 16);
  *(_OWORD *)a2 = *(_OWORD *)v2;
  *(_OWORD *)(a2 + 16) = v5;
  __n128 result = *(__n128 *)(v2 + 32);
  long long v7 = *(_OWORD *)(v2 + 48);
  *(__n128 *)(a2 + 32) = result;
  *(_OWORD *)(a2 + 48) = v7;
  return result;
}

__n128 LiAgent::getObjectToImageTransform@<Q0>(LiAgent *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *((void *)this + 22);
  long long v3 = *(_OWORD *)(v2 + 80);
  *(_OWORD *)(a2 + 64) = *(_OWORD *)(v2 + 64);
  *(_OWORD *)(a2 + 80) = v3;
  long long v4 = *(_OWORD *)(v2 + 112);
  *(_OWORD *)(a2 + 96) = *(_OWORD *)(v2 + 96);
  *(_OWORD *)(a2 + 112) = v4;
  long long v5 = *(_OWORD *)(v2 + 16);
  *(_OWORD *)a2 = *(_OWORD *)v2;
  *(_OWORD *)(a2 + 16) = v5;
  __n128 result = *(__n128 *)(v2 + 32);
  long long v7 = *(_OWORD *)(v2 + 48);
  *(__n128 *)(a2 + 32) = result;
  *(_OWORD *)(a2 + 48) = v7;
  return result;
}

uint64_t LiAgent::haveROI(LiAgent *this)
{
  return *((unsigned __int8 *)this + 76);
}

__n128 LiAgent::getROI@<Q0>(__n128 *this@<X0>, __n128 *a2@<X8>)
{
  __n128 result = this[5];
  *a2 = result;
  return result;
}

__n128 LiAgent::setInputROI(uint64_t a1, __n128 *a2)
{
  __n128 result = *a2;
  *(__n128 *)(a1 + 60) = *a2;
  *(unsigned char *)(a1 + 56) = 1;
  return result;
}

__n128 LiAgent::passROI(LiAgent *this)
{
  uint64_t v1 = *(void *)this;
  if (*(void *)this)
  {
    *((unsigned char *)this + 56) = *(unsigned char *)(v1 + 56);
    __n128 result = *(__n128 *)(v1 + 60);
    *(__n128 *)((char *)this + 60) = result;
  }
  return result;
}

__n128 LiAgent::setClientROI(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[5] = *a2;
  a1[4].n128_u8[12] = 1;
  return result;
}

double LiAgent::getClientPixelTransform@<D0>(double **this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 120) = 0x3FF0000000000000;
  *(void *)(a2 + 80) = 0x3FF0000000000000;
  *(void *)(a2 + 40) = 0x3FF0000000000000;
  *(void *)a2 = 0x3FF0000000000000;
  double result = 0.0;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  if (*this)
  {
    uint64_t v3 = *((void *)*this + 20);
    if (v3 != a2)
    {
      uint64_t v4 = 0;
      uint64_t v5 = a2;
      do
      {
        for (uint64_t i = 0; i != 32; i += 8)
        {
          double result = *(double *)(v3 + i);
          *(double *)(v5 + i) = result;
        }
        ++v4;
        v5 += 32;
        v3 += 32;
      }
      while (v4 != 4);
    }
    long long v7 = this[30];
    if (v7) {
      return PCMatrix44Tmpl<double>::rightMult(a2, v7);
    }
  }
  return result;
}

double LiAgent::getInverseClientPixelTransform@<D0>(LiAgent *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 120) = 0x3FF0000000000000;
  *(void *)(a2 + 80) = 0x3FF0000000000000;
  *(void *)(a2 + 40) = 0x3FF0000000000000;
  *(void *)a2 = 0x3FF0000000000000;
  long long v4 = 0uLL;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  uint64_t v5 = *(void *)this;
  if (v5)
  {
    uint64_t v22 = 0x3FF0000000000000;
    uint64_t v19 = 0x3FF0000000000000;
    uint64_t v16 = 0x3FF0000000000000;
    double v13 = 1.0;
    long long v14 = 0uLL;
    long long v15 = 0uLL;
    long long v17 = 0uLL;
    long long v18 = 0uLL;
    long long v20 = 0uLL;
    long long v21 = 0uLL;
    LiAgent::getInversePixelTransform(v5, (uint64_t)&v13, 0.0);
    if (&v13 != (double *)a2)
    {
      for (uint64_t i = 0; i != 128; i += 32)
      {
        long long v7 = (_OWORD *)(a2 + i);
        long long v4 = *(_OWORD *)((char *)&v13 + i);
        long long v8 = *(long long *)((char *)&v14 + i + 8);
        *long long v7 = v4;
        v7[1] = v8;
      }
    }
    int v9 = (double *)*((void *)this + 30);
    if (v9)
    {
      uint64_t v22 = 0x3FF0000000000000;
      uint64_t v19 = 0x3FF0000000000000;
      uint64_t v16 = 0x3FF0000000000000;
      double v13 = 1.0;
      long long v14 = 0u;
      long long v15 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      if (!PCMatrix44Tmpl<double>::planarInverseZ((uint64_t)&v13, v9, 0.0))
      {
        exception = (PCException *)__cxa_allocate_exception(0x40uLL);
        PCString::PCString(&v12, "getInverseClientPixelTransform: failed to invert");
        PCException::PCException(exception, &v12);
        *(void *)exception = &unk_1F10C3980;
      }
      *(double *)&long long v4 = PCMatrix44Tmpl<double>::leftMult(a2, &v13);
    }
  }
  return *(double *)&v4;
}

void sub_1B7A5ACC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

BOOL LiAgent::getImageToObjectTransform@<W0>(double **this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 120) = 0x3FF0000000000000;
  *(void *)(a2 + 80) = 0x3FF0000000000000;
  *(void *)(a2 + 40) = 0x3FF0000000000000;
  *(void *)a2 = 0x3FF0000000000000;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  return PCMatrix44Tmpl<double>::planarInverseZ(a2, this[22], 0.0);
}

__n128 LiAgent::getImageToWorldTransform@<Q0>(LiAgent *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *((void *)this + 23);
  long long v3 = *(_OWORD *)(v2 + 80);
  *(_OWORD *)(a2 + 64) = *(_OWORD *)(v2 + 64);
  *(_OWORD *)(a2 + 80) = v3;
  long long v4 = *(_OWORD *)(v2 + 112);
  *(_OWORD *)(a2 + 96) = *(_OWORD *)(v2 + 96);
  *(_OWORD *)(a2 + 112) = v4;
  long long v5 = *(_OWORD *)(v2 + 16);
  *(_OWORD *)a2 = *(_OWORD *)v2;
  *(_OWORD *)(a2 + 16) = v5;
  __n128 result = *(__n128 *)(v2 + 32);
  long long v7 = *(_OWORD *)(v2 + 48);
  *(__n128 *)(a2 + 32) = result;
  *(_OWORD *)(a2 + 48) = v7;
  return result;
}

uint64_t LiAgent::getImageToDocumentTransform@<X0>(LiAgent *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *((void *)this + 28);
  uint64_t v14 = 0x3FF0000000000000;
  uint64_t v11 = 0x3FF0000000000000;
  uint64_t v8 = 0x3FF0000000000000;
  uint64_t v5 = 0x3FF0000000000000;
  long long v6 = 0u;
  long long v7 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  LiAgent::getImageToFilmTransform((uint64_t)this, (uint64_t)&v5);
  return PCMatrix44Tmpl<double>::operator*(v3, (long long *)&v5, a2);
}

__n128 LiAgent::getObjectToWorldTransform@<Q0>(LiAgent *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *((void *)this + 24);
  long long v3 = *(_OWORD *)(v2 + 80);
  *(_OWORD *)(a2 + 64) = *(_OWORD *)(v2 + 64);
  *(_OWORD *)(a2 + 80) = v3;
  long long v4 = *(_OWORD *)(v2 + 112);
  *(_OWORD *)(a2 + 96) = *(_OWORD *)(v2 + 96);
  *(_OWORD *)(a2 + 112) = v4;
  long long v5 = *(_OWORD *)(v2 + 16);
  *(_OWORD *)a2 = *(_OWORD *)v2;
  *(_OWORD *)(a2 + 16) = v5;
  __n128 result = *(__n128 *)(v2 + 32);
  long long v7 = *(_OWORD *)(v2 + 48);
  *(__n128 *)(a2 + 32) = result;
  *(_OWORD *)(a2 + 48) = v7;
  return result;
}

__n128 LiAgent::getEyeToWorldTransform@<Q0>(LiAgent *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *((void *)this + 25);
  long long v3 = *(_OWORD *)(v2 + 80);
  *(_OWORD *)(a2 + 64) = *(_OWORD *)(v2 + 64);
  *(_OWORD *)(a2 + 80) = v3;
  long long v4 = *(_OWORD *)(v2 + 112);
  *(_OWORD *)(a2 + 96) = *(_OWORD *)(v2 + 96);
  *(_OWORD *)(a2 + 112) = v4;
  long long v5 = *(_OWORD *)(v2 + 16);
  *(_OWORD *)a2 = *(_OWORD *)v2;
  *(_OWORD *)(a2 + 16) = v5;
  __n128 result = *(__n128 *)(v2 + 32);
  long long v7 = *(_OWORD *)(v2 + 48);
  *(__n128 *)(a2 + 32) = result;
  *(_OWORD *)(a2 + 48) = v7;
  return result;
}

__n128 LiAgent::getWorldToFilmTransform@<Q0>(LiAgent *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *((void *)this + 26);
  long long v3 = *(_OWORD *)(v2 + 80);
  *(_OWORD *)(a2 + 64) = *(_OWORD *)(v2 + 64);
  *(_OWORD *)(a2 + 80) = v3;
  long long v4 = *(_OWORD *)(v2 + 112);
  *(_OWORD *)(a2 + 96) = *(_OWORD *)(v2 + 96);
  *(_OWORD *)(a2 + 112) = v4;
  long long v5 = *(_OWORD *)(v2 + 16);
  *(_OWORD *)a2 = *(_OWORD *)v2;
  *(_OWORD *)(a2 + 16) = v5;
  __n128 result = *(__n128 *)(v2 + 32);
  long long v7 = *(_OWORD *)(v2 + 48);
  *(__n128 *)(a2 + 32) = result;
  *(_OWORD *)(a2 + 48) = v7;
  return result;
}

uint64_t LiAgent::getObjectToPixelTransform@<X0>(LiAgent *this@<X0>, uint64_t a2@<X8>)
{
  return PCMatrix44Tmpl<double>::operator*(*((void *)this + 20), *((long long **)this + 22), a2);
}

uint64_t LiAgent::getPixelToObjectTransform@<X0>(double **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v24 = 0x3FF0000000000000;
  uint64_t v21 = 0x3FF0000000000000;
  uint64_t v18 = 0x3FF0000000000000;
  uint64_t v15 = 0x3FF0000000000000;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  PCMatrix44Tmpl<double>::planarInverseZ((uint64_t)&v15, this[22], 0.0);
  uint64_t v14 = 0x3FF0000000000000;
  uint64_t v11 = 0x3FF0000000000000;
  uint64_t v8 = 0x3FF0000000000000;
  uint64_t v5 = 0x3FF0000000000000;
  long long v6 = 0u;
  long long v7 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  LiAgent::getInversePixelTransform((uint64_t)this, (uint64_t)&v5, 0.0);
  return PCMatrix44Tmpl<double>::operator*((uint64_t)&v15, (long long *)&v5, a2);
}

BOOL LiAgent::getFaceCameraTransform@<W0>(LiAgent *this@<X0>, uint64_t a2@<X8>)
{
  long long v3 = (float64x2_t *)*((void *)this + 27);
  float64x2_t v4 = v3[3];
  float64x2_t v6 = *v3;
  float64x2_t v5 = v3[1];
  *(float64x2_t *)uint64_t v14 = v3[2];
  *(float64x2_t *)&v14[16] = v4;
  *(float64x2_t *)long long v13 = v6;
  *(float64x2_t *)&v13[16] = v5;
  float64x2_t v7 = v3[7];
  float64x2_t v9 = v3[4];
  float64x2_t v8 = v3[5];
  float64x2_t v17 = v3[6];
  float64x2_t v18 = v7;
  float64x2_t v15 = v9;
  float64x2_t v16 = v8;
  PCMatrix44Tmpl<double>::orthoNormalize((uint64_t)v13);
  *(void *)(a2 + 120) = 0x3FF0000000000000;
  *(void *)(a2 + 80) = 0x3FF0000000000000;
  *(void *)(a2 + 40) = 0x3FF0000000000000;
  *(void *)a2 = 0x3FF0000000000000;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  BOOL result = PCMatrix44Tmpl<double>::planarInverseW(a2, (double *)v13, 0.0);
  if ((result & 1) == 0)
  {
    *(void *)&v11.f64[0] = vdupq_laneq_s64(*(int64x2_t *)&v14[8], 1).u64[0];
    v11.f64[1] = *(float64_t *)v14;
    *(void *)&v12.f64[0] = vdupq_laneq_s64(*(int64x2_t *)&v13[8], 1).u64[0];
    v12.f64[1] = *(float64_t *)v13;
    float64x2_t v15 = vsubq_f64(vmulq_f64(*(float64x2_t *)&v13[8], v11), vmulq_f64(*(float64x2_t *)&v14[8], v12));
    v16.f64[0] = *(double *)v13 * *(double *)&v14[8] - *(double *)v14 * *(double *)&v13[8];
    v16.f64[1] = 0.0;
    return PCMatrix44Tmpl<double>::planarInverseW(a2, (double *)v13, 0.0);
  }
  return result;
}

BOOL PCMatrix44Tmpl<double>::orthoNormalize(uint64_t a1)
{
  uint64_t v2 = 0;
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v25 = 0;
  memset(v24, 0, sizeof(v24));
  long long v3 = (uint64_t *)(a1 + 32);
  do
  {
    uint64_t v4 = *v3;
    uint64_t v5 = v3[4];
    float64x2_t v6 = (void *)((char *)v24 + v2);
    *float64x2_t v6 = *(v3 - 4);
    v6[1] = v4;
    v6[2] = v5;
    v2 += 24;
    ++v3;
  }
  while (v2 != 72);
  for (uint64_t i = 0; i != 3; ++i)
  {
    if (i)
    {
      float64x2_t v8 = (char *)v24 + 24 * i;
      float64x2_t v10 = *(float64x2_t *)(v8 + 8);
      float64x2_t v9 = (float64x2_t *)(v8 + 8);
      float64x2_t v11 = v10;
      double v12 = *((double *)v24 + 3 * i);
      uint64_t v13 = i;
      uint64_t v14 = (_OWORD *)((char *)v24 + 8);
      do
      {
        double v15 = *((double *)v14 - 1);
        float64x2_t v16 = *(float64x2_t *)v14;
        uint64_t v14 = (_OWORD *)((char *)v14 + 24);
        float64x2_t v17 = vmulq_f64(v11, v16);
        double v18 = v12 * v15 + v17.f64[0] + v17.f64[1];
        double v12 = v12 - v15 * v18;
        *((double *)v24 + 3 * i) = v12;
        float64x2_t v11 = vsubq_f64(v11, vmulq_n_f64(v16, v18));
        float64x2_t *v9 = v11;
        --v13;
      }
      while (v13);
    }
    BOOL result = PCVector3<double>::normalize((double *)v24 + 3 * i, 0.000000100000001);
  }
  long long v20 = (void *)(a1 + 64);
  for (uint64_t j = 16; j != 88; j += 24)
  {
    uint64_t v22 = *(void *)((char *)v24 + j - 8);
    uint64_t v23 = *(void *)((char *)v24 + j);
    *(v20 - 8) = *(void *)((char *)&v24[-1] + j);
    *(v20 - 4) = v22;
    *long long v20 = v23;
    v20[4] = 0;
    ++v20;
  }
  return result;
}

BOOL PCMatrix44Tmpl<double>::planarInverseW(uint64_t a1, double *a2, double a3)
{
  double v4 = a2[9];
  double v3 = a2[10];
  double v6 = a2[4];
  double v5 = a2[5];
  double v7 = a2[6];
  double v8 = a2[8];
  double v9 = v5 * v3 - v4 * v7;
  double v11 = a2[1];
  double v10 = a2[2];
  double v12 = v7 * v8 - v3 * v6;
  double v13 = *a2;
  double v14 = v4 * v6 - v5 * v8;
  double v15 = v10 * v14 + v9 * *a2 + v11 * v12;
  BOOL v16 = fabs(v15) >= a3 && v15 != 0.0;
  if (v16)
  {
    *(double *)a1 = v9 * (1.0 / v15);
    *(double *)(a1 + 8) = (v4 * v10 - v3 * v11) * (1.0 / v15);
    *(double *)(a1 + 16) = (v7 * v11 - v5 * v10) * (1.0 / v15);
    *(double *)(a1 + 32) = v12 * (1.0 / v15);
    *(double *)(a1 + 40) = (v3 * v13 - v10 * v8) * (1.0 / v15);
    *(double *)(a1 + 48) = (v10 * v6 - v7 * v13) * (1.0 / v15);
    *(double *)(a1 + 64) = v14 * (1.0 / v15);
    *(double *)(a1 + 72) = (v11 * v8 - v4 * v13) * (1.0 / v15);
    *(double *)(a1 + 80) = (v5 * v13 - v11 * v6) * (1.0 / v15);
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 24) = 0;
    *(_OWORD *)(a1 + 88) = 0u;
    *(_OWORD *)(a1 + 104) = 0u;
    *(void *)(a1 + 120) = 0x3FF0000000000000;
  }
  return v16;
}

void LiAgent::get2DClipPlanes(LiAgent *this@<X0>, LiClipSet *a2@<X8>)
{
  LiClipSet::LiClipSet(a2, (LiAgent *)((char *)this + 96));
  v3[0] = 0uLL;
  v3[1] = xmmword_1B7E733D0;
  LiClipSet::flatten((uint64_t)a2, v3);
}

void sub_1B7A5B2D8(_Unwind_Exception *a1)
{
  LiClipSet::~LiClipSet(v1);
  _Unwind_Resume(a1);
}

void *LiAgent::getObjectClipPlanes(LiAgent *this)
{
  BOOL result = (void *)*((void *)this + 18);
  if (!result)
  {
    getEmptyClipSet();
    return &getEmptyClipSet(void)::emptyClipSet;
  }
  return result;
}

void getEmptyClipSet(void)
{
  {
    LiClipSet::LiClipSet((LiClipSet *)&getEmptyClipSet(void)::emptyClipSet);
    __cxa_atexit((void (*)(void *))LiClipSet::~LiClipSet, &getEmptyClipSet(void)::emptyClipSet, &dword_1B73F3000);
  }
}

void sub_1B7A5B3A4(_Unwind_Exception *a1)
{
}

void *LiAgent::getWorldClipPlanes(LiAgent *this)
{
  BOOL result = (void *)*((void *)this + 19);
  if (!result)
  {
    getEmptyClipSet();
    return &getEmptyClipSet(void)::emptyClipSet;
  }
  return result;
}

uint64_t LiAgent::makeHeliumXForm@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  float v8 = *(float *)(a1 + 384);
  LODWORD(v11) = *(_DWORD *)(a1 + 380);
  *((float *)&v11 + 1) = v8;
  BOOL v9 = *(float *)&v11 == 1.0 && v8 == 1.0;
  if (v9
    && LiRenderingTechnology::getUseHalfHeightFields((LiRenderingTechnology *)(*(void *)(a1 + 48) + 80)))
  {
    uint64_t v11 = 0x3F3504F33F800000;
  }
  return LiHelium::createTransformNode(a2, a3, *(unsigned __int8 *)(*(void *)(a1 + 48) + 132), (float *)&v11, a4);
}

uint64_t LiAgent::makeHeliumXForm@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v4 = 0;
  LiAgent::makeHeliumXForm(a1, a2, &v4, a3);
  uint64_t result = v4;
  if (v4) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  return result;
}

void sub_1B7A5B4DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(exception_object);
}

BOOL LiAgent::projectAndClipPolygon(LiAgent *this, uint64_t **a2, double a3)
{
  LiImagePolygon::clip(a2, (LiAgent *)((char *)this + 96));
  double v5 = (double *)*((void *)this + 20);

  return transform(v5, a2);
}

uint64_t LiAgent::getRenderDevice(LiRenderParameters **this)
{
  return LiRenderParameters::getRenderDevice(this[6]);
}

uint64_t LiAgent::setFilterSize(uint64_t this, float a2, float a3)
{
  *(float *)(this + 380) = a2;
  *(float *)(this + 384) = a3;
  return this;
}

CGColorSpace **LiAgent::setRequestedColorDescription(CGColorSpace **this, const FxColorDescription *a2)
{
  uint64_t result = PCCFRef<CGColorSpace *>::operator=(this + 50, &a2->_pcColorDesc._colorSpaceRef._obj);
  double v5 = *(CGColorSpace **)&a2->_pcColorDesc._dynamicRange;
  *((_DWORD *)this + 104) = LODWORD(a2->_pcColorDesc._toneMapMethod._gain);
  this[51] = v5;
  *((unsigned char *)this + 424) = a2->_isPremultiplied;
  return result;
}

uint64_t LiAgent::getRequestedColorDescription(LiAgent *this)
{
  return (uint64_t)this + 400;
}

uint64_t LiAgent::isDynamicRangeTrackingRender(FxColorDescription **this)
{
  return LiRenderParameters::isDynamicRangeTrackingRender(this[6]);
}

uint64_t LiAgent::setActualColorSpace(LiAgent *this, CGColorSpace *a2)
{
  return FxColorDescription::setCGColorSpace((FxColorDescription *)((char *)this + 432), a2);
}

uint64_t LiAgent::getActualColorSpace(LiAgent *this)
{
  ActualColorDescription = (FxColorDescription *)LiAgent::getActualColorDescription(this);

  return FxColorDescription::getCGColorSpace(ActualColorDescription);
}

void LiAgentRequestedColorSpaceSentry::LiAgentRequestedColorSpaceSentry(LiAgentRequestedColorSpaceSentry *this, LiAgent *a2, CGColorSpace *a3)
{
  *(void *)this = a2;
  double v6 = (CGColorSpace *)*((void *)a2 + 50);
  *((void *)this + 1) = v6;
  double v7 = (FxColorDescription *)((char *)a2 + 400);
  if (v6) {
    PCCFRefTraits<CGColorSpace *>::retain(v6);
  }
  uint64_t v8 = *((void *)a2 + 51);
  *((_DWORD *)this + 6) = *((_DWORD *)a2 + 104);
  *((void *)this + 2) = v8;
  *((unsigned char *)this + 32) = *((unsigned char *)a2 + 424);
  FxColorDescription::setCGColorSpace(v7, a3);
}

void sub_1B7A5B674(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

void LiAgentRequestedColorSpaceSentry::LiAgentRequestedColorSpaceSentry(LiAgentRequestedColorSpaceSentry *this, LiAgent *a2, const FxColorDescription *a3)
{
  *(void *)this = a2;
  double v6 = (CGColorSpace *)*((void *)a2 + 50);
  *((void *)this + 1) = v6;
  double v7 = (CGColorSpace **)((char *)a2 + 400);
  if (v6) {
    PCCFRefTraits<CGColorSpace *>::retain(v6);
  }
  uint64_t v8 = *((void *)a2 + 51);
  *((_DWORD *)this + 6) = *((_DWORD *)a2 + 104);
  *((void *)this + 2) = v8;
  *((unsigned char *)this + 32) = *((unsigned char *)a2 + 424);
  PCCFRef<CGColorSpace *>::operator=(v7, &a3->_pcColorDesc._colorSpaceRef._obj);
  uint64_t v9 = *(void *)&a3->_pcColorDesc._dynamicRange;
  *((_DWORD *)a2 + 104) = LODWORD(a3->_pcColorDesc._toneMapMethod._gain);
  *((void *)a2 + 51) = v9;
  *((unsigned char *)a2 + 424) = a3->_isPremultiplied;
}

void sub_1B7A5B720(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

void LiAgentRequestedColorSpaceSentry::~LiAgentRequestedColorSpaceSentry(CGColorSpace **this)
{
  uint64_t v2 = this + 1;
  double v3 = *this;
  PCCFRef<CGColorSpace *>::operator=((CGColorSpace **)*this + 50, this + 1);
  uint64_t v4 = this[2];
  *((_DWORD *)v3 + 104) = *((_DWORD *)this + 6);
  *((void *)v3 + 51) = v4;
  *((unsigned char *)v3 + 424) = *((unsigned char *)this + 32);
  PCCFRef<CGColorSpace *>::~PCCFRef(v2);
}

void PCColorDescription::PCColorDescription(PCColorDescription *this)
{
  this->_colorSpaceRef._obuint64_t j = 0;
  this->_dynamicRange = 0;
  PCToneMapMethod::PCToneMapMethod(&this->_toneMapMethod);
}

void sub_1B7A5B7CC(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef(v1);
  _Unwind_Resume(a1);
}

void LiAgentTransformData::~LiAgentTransformData(LiAgentTransformData *this)
{
  *(void *)this = &unk_1F11186B8;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)this = &unk_1F11186B8;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x1BA9BFBA0);
}

void LiAgentData::~LiAgentData(LiAgentData *this)
{
  *(void *)this = &unk_1F11186B8;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x1BA9BFBA0);
}

void LiAgentMatrixData::~LiAgentMatrixData(LiAgentMatrixData *this)
{
  *(void *)this = &unk_1F11186B8;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x1BA9BFBA0);
}

LiAgent *std::unique_ptr<LiAgent>::reset[abi:ne180100](LiAgent **a1, LiAgent *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    LiAgent::~LiAgent(result);
    JUMPOUT(0x1BA9BFBA0);
  }
  return result;
}

void LiAgent_getHelium_Matrixes::LiAgent_getHelium_Matrixes(LiAgent_getHelium_Matrixes *this)
{
  *((void *)this + 10) = 0x3FF0000000000000;
  *((void *)this + 5) = 0x3FF0000000000000;
  *(void *)this = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((void *)this + 26) = 0x3FF0000000000000;
  *((void *)this + 21) = 0x3FF0000000000000;
  __asm { FMOV            V1.2D, #1.0 }
  *(_OWORD *)((char *)this + 120) = _Q1;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *((void *)this + 42) = 0x3FF0000000000000;
  *((void *)this + 37) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 248) = _Q1;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *((void *)this + 58) = 0x3FF0000000000000;
  *((void *)this + 53) = 0x3FF0000000000000;
  *((void *)this + 47) = 0x3FF0000000000000;
  *((void *)this + 48) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 28) = 0u;
  *(_OWORD *)((char *)this + 488) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *((void *)this + 79) = 0x3FF0000000000000;
  *((void *)this + 74) = 0x3FF0000000000000;
  *((void *)this + 69) = 0x3FF0000000000000;
  *((void *)this + 63) = 0x3FF0000000000000;
  *((void *)this + 64) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 536) = 0u;
  *(_OWORD *)((char *)this + 520) = 0u;
  *((_OWORD *)this + 35) = 0u;
  *((_OWORD *)this + 36) = 0u;
  *(_OWORD *)((char *)this + 616) = 0u;
  *(_OWORD *)((char *)this + 600) = 0u;
  *((void *)this + 95) = 0x3FF0000000000000;
  *((void *)this + 90) = 0x3FF0000000000000;
  *((void *)this + 85) = 0x3FF0000000000000;
  *((void *)this + 80) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 664) = 0u;
  *(_OWORD *)((char *)this + 648) = 0u;
  *((_OWORD *)this + 43) = 0u;
  *((_OWORD *)this + 44) = 0u;
  *(_OWORD *)((char *)this + 744) = 0u;
  *(_OWORD *)((char *)this + 728) = 0u;
  *((void *)this + 111) = 0x3FF0000000000000;
  *((void *)this + 106) = 0x3FF0000000000000;
  *((void *)this + 101) = 0x3FF0000000000000;
  *((void *)this + 96) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 792) = 0u;
  *(_OWORD *)((char *)this + 776) = 0u;
  *((_OWORD *)this + 51) = 0u;
  *((_OWORD *)this + 52) = 0u;
  *(_OWORD *)((char *)this + 872) = 0u;
  *(_OWORD *)((char *)this + 856) = 0u;
  *((void *)this + 127) = 0x3FF0000000000000;
  *((void *)this + 122) = 0x3FF0000000000000;
  *((void *)this + 117) = 0x3FF0000000000000;
  *((void *)this + 112) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 920) = 0u;
  *(_OWORD *)((char *)this + 904) = 0u;
  *((_OWORD *)this + 59) = 0u;
  *((_OWORD *)this + 60) = 0u;
  *(_OWORD *)((char *)this + 1000) = 0u;
  *(_OWORD *)((char *)this + 984) = 0u;
  *((void *)this + 143) = 0x3FF0000000000000;
  *((void *)this + 138) = 0x3FF0000000000000;
  *((void *)this + 133) = 0x3FF0000000000000;
  *((void *)this + 128) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 1048) = 0u;
  *(_OWORD *)((char *)this + 1032) = 0u;
  *((_OWORD *)this + 68) = 0u;
  *((_OWORD *)this + 67) = 0u;
  *(_OWORD *)((char *)this + 1128) = 0u;
  *(_OWORD *)((char *)this + 1112) = 0u;
  *((void *)this + 159) = 0x3FF0000000000000;
  *((void *)this + 154) = 0x3FF0000000000000;
  *((void *)this + 149) = 0x3FF0000000000000;
  *((void *)this + 144) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 1176) = 0u;
  *(_OWORD *)((char *)this + 1160) = 0u;
  *((_OWORD *)this + 76) = 0u;
  *((_OWORD *)this + 75) = 0u;
  *(_OWORD *)((char *)this + 1256) = 0u;
  *(_OWORD *)((char *)this + 1240) = 0u;
  *((void *)this + 175) = 0x3FF0000000000000;
  *((void *)this + 170) = 0x3FF0000000000000;
  *((void *)this + 165) = 0x3FF0000000000000;
  *((void *)this + 160) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 1304) = 0u;
  *(_OWORD *)((char *)this + 1288) = 0u;
  *((_OWORD *)this + 84) = 0u;
  *((_OWORD *)this + 83) = 0u;
  *(_OWORD *)((char *)this + 1384) = 0u;
  *(_OWORD *)((char *)this + 1368) = 0u;
  *((void *)this + 191) = 0x3FF0000000000000;
  *((void *)this + 186) = 0x3FF0000000000000;
  *((void *)this + 181) = 0x3FF0000000000000;
  *((void *)this + 176) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 1432) = 0u;
  *(_OWORD *)((char *)this + 1416) = 0u;
  *((_OWORD *)this + 92) = 0u;
  *((_OWORD *)this + 91) = 0u;
  *(_OWORD *)((char *)this + 1512) = 0u;
  *(_OWORD *)((char *)this + 1496) = 0u;
  *((void *)this + 207) = 0x3FF0000000000000;
  *((void *)this + 202) = 0x3FF0000000000000;
  *((void *)this + 197) = 0x3FF0000000000000;
  *((void *)this + 192) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 1560) = 0u;
  *(_OWORD *)((char *)this + 1544) = 0u;
  *((_OWORD *)this + 100) = 0u;
  *((_OWORD *)this + 99) = 0u;
  *(_OWORD *)((char *)this + 1640) = 0u;
  *(_OWORD *)((char *)this + 1624) = 0u;
  *((void *)this + 223) = 0x3FF0000000000000;
  *((void *)this + 218) = 0x3FF0000000000000;
  *((void *)this + 213) = 0x3FF0000000000000;
  *((void *)this + 208) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 1688) = 0u;
  *(_OWORD *)((char *)this + 1672) = 0u;
  *((_OWORD *)this + 108) = 0u;
  *((_OWORD *)this + 107) = 0u;
  *(_OWORD *)((char *)this + 1768) = 0u;
  *(_OWORD *)((char *)this + 1752) = 0u;
  *((void *)this + 239) = 0x3FF0000000000000;
  *((void *)this + 234) = 0x3FF0000000000000;
  *((void *)this + 229) = 0x3FF0000000000000;
  *((void *)this + 224) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 1816) = 0u;
  *(_OWORD *)((char *)this + 1800) = 0u;
  *((_OWORD *)this + 116) = 0u;
  *((_OWORD *)this + 115) = 0u;
  *(_OWORD *)((char *)this + 1896) = 0u;
  *(_OWORD *)((char *)this + 1880) = 0u;
}

BOOL transform(_OWORD *a1, double *a2)
{
  BOOL v4 = transformPlane<double>(a1, a2, (uint64_t)a2);
  BOOL v5 = transformPlane<double>(a1, a2 + 6, (uint64_t)(a2 + 6));
  BOOL v6 = transformPlane<double>(a1, a2 + 12, (uint64_t)(a2 + 12));
  BOOL v7 = transformPlane<double>(a1, a2 + 18, (uint64_t)(a2 + 18));
  BOOL v8 = transformPlane<double>(a1, a2 + 24, (uint64_t)(a2 + 24));
  BOOL result = transformPlane<double>(a1, a2 + 30, (uint64_t)(a2 + 30));
  if (!v4 || !v5 || !v6 || !v7 || !v8 || !result)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v11, "transform frustum failed");
    PCException::PCException(exception, &v11);
    *(void *)exception = &unk_1F10C3980;
  }
  return result;
}

void sub_1B7A5BDDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

BOOL LiBaseCamera::worldToLocalMatrix@<W0>(LiBaseCamera *this@<X0>, double *a2@<X8>)
{
  (*(void (**)(LiBaseCamera *))(*(void *)this + 16))(this);
  BOOL result = PCMatrix44Tmpl<double>::invert(a2, a2, 0.0);
  if (!result)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v5, "failed to invert local matrix");
    PCException::PCException(exception, &v5);
  }
  return result;
}

void sub_1B7A5BEBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

uint64_t LiBaseCamera::worldToFilmMatrix@<X0>(LiBaseCamera *this@<X0>, uint64_t a2@<X8>)
{
  (*(void (**)(void *__return_ptr))(*(void *)this + 32))(v6);
  (*(void (**)(long long *__return_ptr, LiBaseCamera *))(*(void *)this + 24))(v5, this);
  return PCMatrix44Tmpl<double>::operator*((uint64_t)v6, v5, a2);
}

uint64_t LiBaseCamera::filmSpaceIsAnamorphic(LiBaseCamera *this)
{
  return 1;
}

uint64_t LiCamera::copy(uint64_t a1, uint64_t a2)
{
  memset(v14, 0, sizeof(v14));
  memset(v13, 0, sizeof(v13));
  v12[0] = 0x3FF0000000000000;
  memset(&v12[1], 0, 24);
  (*(void (**)(void *__return_ptr, uint64_t))(*(void *)a2 + 424))(v11, a2);
  (*(void (**)(uint64_t, void *))(*(void *)a2 + 440))(a2, v14);
  (*(void (**)(uint64_t, void *))(*(void *)a2 + 472))(a2, v12);
  (*(void (**)(uint64_t, void *))(*(void *)a2 + 456))(a2, v13);
  (*(void (**)(void *__return_ptr, uint64_t))(*(void *)a2 + 272))(v10, a2);
  (*(void (**)(uint64_t, void *))(*(void *)a1 + 288))(a1, v10);
  (*(void (**)(uint64_t))(*(void *)a2 + 688))(a2);
  (*(void (**)(uint64_t))(*(void *)a1 + 696))(a1);
  (*(void (**)(uint64_t, void *))(*(void *)a1 + 432))(a1, v11);
  (*(void (**)(uint64_t, void *))(*(void *)a1 + 448))(a1, v14);
  (*(void (**)(uint64_t, void *))(*(void *)a1 + 480))(a1, v12);
  (*(void (**)(uint64_t, void *))(*(void *)a1 + 464))(a1, v13);
  (*(void (**)(uint64_t))(*(void *)a2 + 488))(a2);
  (*(void (**)(uint64_t))(*(void *)a1 + 496))(a1);
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 632))(a2);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 640))(a1, v4);
  (*(void (**)(uint64_t))(*(void *)a2 + 504))(a2);
  (*(void (**)(uint64_t))(*(void *)a1 + 512))(a1);
  double v5 = (*(double (**)(uint64_t))(*(void *)a2 + 536))(a2);
  double v6 = (*(double (**)(uint64_t))(*(void *)a2 + 576))(a2);
  (*(void (**)(uint64_t, double))(*(void *)a1 + 544))(a1, v5);
  (*(void (**)(uint64_t, double))(*(void *)a1 + 584))(a1, v6);
  (*(void (**)(uint64_t))(*(void *)a2 + 552))(a2);
  (*(void (**)(uint64_t))(*(void *)a1 + 560))(a1);
  (*(void (**)(uint64_t))(*(void *)a2 + 592))(a2);
  (*(void (**)(uint64_t))(*(void *)a1 + 600))(a1);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 624))(a2);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 616))(a1, v7);
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 664))(a2);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 672))(a1, v8);
}

void LiCamera::getNearFarPlanes(LiCamera *this, double *a2, double *a3)
{
  *a2 = (*(double (**)(LiCamera *))(*(void *)this + 536))(this);
  *a3 = (*(double (**)(LiCamera *))(*(void *)this + 576))(this);
}

uint64_t LiCamera::setNearFarPlanes(LiCamera *this, double a2, double a3)
{
  (*(void (**)(LiCamera *, double))(*(void *)this + 544))(this, a2);
  double v5 = *(uint64_t (**)(LiCamera *, __n128))(*(void *)this + 584);
  v6.n128_f64[0] = a3;

  return v5(this, v6);
}

double LiCamera::calcFilmSpaceTransform(uint64_t a1, double *a2, uint64_t a3)
{
  (*(void (**)(double *__return_ptr))(*(void *)a1 + 280))(v11);
  double v5 = v12;
  double v6 = v13;
  double v7 = *a2 + a2[2] * 0.5;
  double v8 = v12 / v13 * a2[3];
  a2[2] = v8;
  *a2 = v7 - v8 * 0.5;
  *(void *)(a3 + 120) = 0x3FF0000000000000;
  *(void *)(a3 + 80) = 0x3FF0000000000000;
  *(void *)(a3 + 40) = 0x3FF0000000000000;
  *(void *)a3 = 0x3FF0000000000000;
  *(_OWORD *)(a3 + 8) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 88) = 0u;
  *(_OWORD *)(a3 + 104) = 0u;
  *(double *)a3 = a2[2] / v5;
  double v9 = v11[1];
  *(double *)(a3 + 24) = *a2 - v11[0] * a2[2] / v5;
  *(double *)(a3 + 40) = a2[3] / v6;
  *(double *)(a3 + 56) = a2[1] - v9 * a2[3] / v6;
  double result = 1.0;
  *(_OWORD *)(a3 + 80) = xmmword_1B7E733D0;
  return result;
}

void LiCamera::getLocalCenterOfProjection(LiCamera *this@<X0>, uint64_t a2@<X8>)
{
  int v4 = (*(uint64_t (**)(LiCamera *))(*(void *)this + 632))(this);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  if (v4 == 1)
  {
    (*(void (**)(double *__return_ptr, LiCamera *))(*(void *)this + 272))(v9, this);
    double v5 = (*(double (**)(LiCamera *))(*(void *)this + 504))(this);
    if (v5 > -0.0000001 && v5 < 0.0000001)
    {
      exception = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::PCString(&v10, "ortho cameras don't have a center of projection");
      PCException::PCException(exception, &v10);
    }
    double v6 = (*(double (**)(LiCamera *))(*(void *)this + 688))(this);
    double v7 = (*(double (**)(LiCamera *))(*(void *)this + 488))(this);
    v10.var0 = (__CFString *)0x3FF0000000000000;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    LiCamera::adjustTranslationForModel(1, 0, (double *)&v10, (float64x2_t *)a2, v5, v6, v7, v9[0]);
  }
}

void sub_1B7A5CB6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCString a11)
{
}

void LiCamera::getCenterOfProjection(LiCamera *this@<X0>, uint64_t a2@<X8>)
{
  int v4 = (*(uint64_t (**)(LiCamera *))(*(void *)this + 632))(this);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  (*(void (**)(LiCamera *, uint64_t))(*(void *)this + 440))(this, a2);
  float64x2_t v12 = 0uLL;
  double v13 = 0.0;
  (*(void (**)(LiCamera *, float64x2_t *))(*(void *)this + 456))(this, &v12);
  v11[0] = 1.0;
  memset(&v11[1], 0, 24);
  (*(void (**)(LiCamera *, double *))(*(void *)this + 472))(this, v11);
  if (v4 == 1)
  {
    (*(void (**)(double *__return_ptr, LiCamera *))(*(void *)this + 272))(v10, this);
    double v5 = (*(double (**)(LiCamera *))(*(void *)this + 504))(this);
    if (v5 > -0.0000001 && v5 < 0.0000001)
    {
      exception = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::PCString(&v9, "ortho cameras don't have a center of projection");
      PCException::PCException(exception, &v9);
    }
    double v6 = (*(double (**)(LiCamera *))(*(void *)this + 688))(this);
    double v7 = (*(double (**)(LiCamera *))(*(void *)this + 488))(this);
    LiCamera::adjustTranslationForModel(1, 0, v11, (float64x2_t *)a2, v5, v6, v7, v10[0]);
  }
  else if (!v4 {
         && (v12.f64[0] <= -0.0000001
  }
          || v12.f64[0] >= 0.0000001
          || v12.f64[1] <= -0.0000001
          || v12.f64[1] >= 0.0000001
          || v13 <= -0.0000001
          || v13 >= 0.0000001))
  {
    PCQuat<double>::transform<double>(v11, v12.f64);
    *(float64x2_t *)a2 = vaddq_f64(v12, *(float64x2_t *)a2);
    *(double *)(a2 + 16) = v13 + *(double *)(a2 + 16);
  }
}

void sub_1B7A5CED8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

double LiCamera::adjustTranslationForModel(int a1, int a2, double *a3, float64x2_t *a4, double result, double a6, double a7, double a8)
{
  if (a1 != a2)
  {
    uint64_t v18 = v11;
    uint64_t v19 = v10;
    uint64_t v20 = v8;
    uint64_t v21 = v9;
    double v15 = a6 * a7 * a8 * 0.5 / tan(result * 0.5 * 3.14159265 / 180.0);
    float64x2_t v16 = 0uLL;
    double v17 = v15;
    if (a2 == 1)
    {
      float64x2_t v16 = (float64x2_t)vdupq_n_s64(0x8000000000000000);
      double v17 = -v15;
    }
    PCQuat<double>::transform<double>(a3, v16.f64);
    *a4 = vaddq_f64(v16, *a4);
    double result = v17 + a4[1].f64[0];
    a4[1].f64[0] = result;
  }
  return result;
}

void LiCamera::getLocalEyePosition(LiCamera *this@<X0>, double *a2@<X8>)
{
  int v4 = (*(uint64_t (**)(LiCamera *))(*(void *)this + 632))(this);
  *a2 = 0.0;
  a2[1] = 0.0;
  a2[2] = 0.0;
  a2[3] = 1.0;
  if (v4 == 1)
  {
    (*(void (**)(double *__return_ptr, LiCamera *))(*(void *)this + 272))(v9, this);
    double v5 = (*(double (**)(LiCamera *))(*(void *)this + 504))(this);
    double v6 = (*(double (**)(LiCamera *))(*(void *)this + 688))(this);
    double v7 = (*(double (**)(LiCamera *))(*(void *)this + 488))(this);
    __double2 v8 = __sincos_stret(v5 * 0.00872664626);
    a2[2] = v9[0] * (v6 * (v8.__cosval * v7)) * 0.5;
    a2[3] = v8.__sinval;
  }
}

void LiCamera::getFocalPoint(LiCamera *this@<X0>, uint64_t a2@<X8>)
{
  int v4 = (*(uint64_t (**)(LiCamera *))(*(void *)this + 632))(this);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  (*(void (**)(LiCamera *, uint64_t))(*(void *)this + 440))(this, a2);
  if (!v4)
  {
    (*(void (**)(double *__return_ptr, LiCamera *))(*(void *)this + 272))(v11, this);
    v10[0] = 1.0;
    memset(&v10[1], 0, 24);
    (*(void (**)(LiCamera *, double *))(*(void *)this + 472))(this, v10);
    double v5 = (*(double (**)(LiCamera *))(*(void *)this + 504))(this);
    if (v5 > -0.0000001 && v5 < 0.0000001)
    {
      exception = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::PCString(&v9, "viewpoint cameras must have a positive angle of view");
      PCException::PCException(exception, &v9);
    }
    double v6 = (*(double (**)(LiCamera *))(*(void *)this + 688))(this);
    double v7 = (*(double (**)(LiCamera *))(*(void *)this + 488))(this);
    LiCamera::adjustTranslationForModel(0, 1, v10, (float64x2_t *)a2, v5, v6, v7, v11[0]);
  }
}

void sub_1B7A5D3E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

double *LiCamera::getPosition@<X0>(LiCamera *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  (*(void (**)(LiCamera *, uint64_t))(*(void *)this + 440))(this, a2);
  float64x2_t v9 = 0uLL;
  double v10 = 0.0;
  (*(void (**)(LiCamera *, float64x2_t *))(*(void *)this + 456))(this, &v9);
  v5.n128_u64[0] = *(void *)&v9.f64[0];
  v6.n128_u64[0] = 0xBE7AD7F29ABCAF48;
  if (v9.f64[0] <= -0.0000001
    || (v4.n128_u64[0] = 0x3E7AD7F29ABCAF48, v9.f64[0] >= 0.0000001)
    || (v5.n128_u64[0] = *(void *)&v9.f64[1], v9.f64[1] <= -0.0000001)
    || v9.f64[1] >= 0.0000001
    || (v5.n128_f64[0] = v10, v10 <= -0.0000001)
    || v10 >= 0.0000001)
  {
    v8[0] = 1.0;
    memset(&v8[1], 0, 24);
    (*(void (**)(LiCamera *, double *, __n128, __n128, __n128))(*(void *)this + 472))(this, v8, v6, v4, v5);
    PCQuat<double>::transform<double>(v8, v9.f64);
    *(float64x2_t *)a2 = vaddq_f64(v9, *(float64x2_t *)a2);
    *(double *)(a2 + 16) = v10 + *(double *)(a2 + 16);
  }
  (*(void (**)(double *__return_ptr, LiCamera *))(*(void *)this + 424))(v8, this);
  return PCMatrix44Tmpl<double>::transform<double>(v8, (double *)a2, (double *)a2);
}

void LiCamera::getViewPoint(LiCamera *this@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  v13[0] = 1.0;
  memset(&v13[1], 0, 24);
  (*(void (**)(LiCamera *, double *))(*(void *)this + 472))(this, v13);
  double v4 = (*(double (**)(LiCamera *))(*(void *)this + 504))(this);
  if (v4 <= -0.0000001 || v4 >= 0.0000001)
  {
    int v6 = (*(uint64_t (**)(LiCamera *))(*(void *)this + 632))(this);
    float64x2_t v11 = 0uLL;
    unint64_t v12 = 0;
    (*(void (**)(LiCamera *, float64x2_t *))(*(void *)this + 440))(this, &v11);
    if (v6 == 1)
    {
      (*(void (**)(double *__return_ptr, LiCamera *))(*(void *)this + 272))(v10, this);
      double v7 = (*(double (**)(LiCamera *))(*(void *)this + 688))(this);
      double v8 = (*(double (**)(LiCamera *))(*(void *)this + 488))(this);
      LiCamera::adjustTranslationForModel(1, 0, v13, &v11, v4, v7, v8, v10[0]);
    }
    unint64_t v9 = v12;
    *(float64x2_t *)a2 = v11;
    *(void *)(a2 + 16) = v9;
    *(void *)(a2 + 24) = 0x3FF0000000000000;
  }
  else
  {
    float64x2_t v11 = 0uLL;
    unint64_t v12 = 0xBFF0000000000000;
    PCQuat<double>::transform<double>(v13, v11.f64);
    unint64_t v5 = v12;
    *(float64x2_t *)a2 = v11;
    *(void *)(a2 + 16) = v5;
    *(void *)(a2 + 24) = 0;
  }
}

double *LiCamera::getViewPointWorld@<X0>(LiCamera *this@<X0>, double *a2@<X8>)
{
  (*(void (**)(LiCamera *))(*(void *)this + 144))(this);
  (*(void (**)(double *__return_ptr, LiCamera *))(*(void *)this + 424))(v5, this);
  return PCMatrix44Tmpl<double>::transform<double>(v5, a2, a2);
}

void LiCamera::getFocalDistance(LiCamera *this)
{
  double v2 = (*(double (**)(LiCamera *))(*(void *)this + 504))(this);
  if (v2 <= -0.0000001 || v2 >= 0.0000001)
  {
    (*(void (**)(uint64_t *__return_ptr, LiCamera *))(*(void *)this + 272))(&v3, this);
    (*(void (**)(LiCamera *))(*(void *)this + 688))(this);
    (*(void (**)(LiCamera *))(*(void *)this + 488))(this);
    tan(v2 * 0.5 * 3.14159265 / 180.0);
  }
}

long double LiCamera::computeFocalDistance(LiCamera *this, double a2, double a3, double a4, double a5, double a6)
{
  return a3 * a4 * a5 * 0.5 / tan(a2 * 0.5 * 3.14159265 / 180.0);
}

double *LiCamera::adjustTranslationForModel(uint64_t a1, int a2, int a3, float64x2_t *a4)
{
  double v8 = (*(double (**)(uint64_t))(*(void *)a1 + 504))(a1);
  int v9 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 520))(a1);
  double v10 = 1.0;
  if (!v9) {
    double v10 = 0.1;
  }
  if (v8 <= v10) {
    double v11 = v10;
  }
  else {
    double v11 = v8;
  }
  if ((((*(uint64_t (**)(uint64_t))(*(void *)a1 + 520))(a1) & 1) != 0
     || v8 < 0.1
     || fabs(v8 + -0.1) < 0.0000001)
    && v11 < 5.0
    && a2 == 1)
  {
    double v11 = 5.0;
  }
  double v13 = (*(double (**)(uint64_t))(*(void *)a1 + 688))(a1);
  double v14 = (*(double (**)(uint64_t))(*(void *)a1 + 488))(a1);
  (*(void (**)(double *__return_ptr, uint64_t))(*(void *)a1 + 272))(v30, a1);
  (*(void (**)(void *__return_ptr, uint64_t))(*(void *)a1 + 16))(v29, a1);
  (*(void (**)(_OWORD *__return_ptr, uint64_t))(*(void *)a1 + 424))(v28, a1);
  v27[4] = v28[4];
  v27[5] = v28[5];
  v27[6] = v28[6];
  v27[7] = v28[7];
  v27[0] = v28[0];
  v27[1] = v28[1];
  v27[2] = v28[2];
  v27[3] = v28[3];
  if (!PCMatrix44Tmpl<double>::invert((double *)v27, (double *)v27, 0.0))
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v26, "singular parent matrix");
    PCException::PCException(exception, &v26);
  }
  PCMatrix44Tmpl<double>::transform<double>((double *)v28, a4->f64, a4->f64);
  *(void *)&v15.f64[0] = v29[2];
  double v16 = *(double *)&v29[10];
  double v17 = v13 * v14 * v30[0] * 0.5;
  *(void *)&v15.f64[1] = v29[6];
  float64x2_t v25 = v15;
  double v18 = v17 / tan(v11 * 0.5 * 3.14159265 / 180.0);
  double v19 = v16 * v18;
  if (a3 == 1) {
    double v19 = -(v16 * v18);
  }
  int8x16_t v20 = (int8x16_t)vmulq_n_f64(v25, v18);
  int32x2_t v21 = vdup_n_s32(a3 == 1);
  v22.i64[0] = v21.u32[0];
  v22.i64[1] = v21.u32[1];
  *a4 = vaddq_f64(*a4, (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v22, 0x3FuLL)), (int8x16_t)vnegq_f64((float64x2_t)v20), v20));
  a4[1].f64[0] = v19 + a4[1].f64[0];
  return PCMatrix44Tmpl<double>::transform<double>((double *)v27, a4->f64, a4->f64);
}

void sub_1B7A5DE3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCString a12)
{
}

void LiCamera::adjustFarPlaneForModel(uint64_t a1, int a2, int a3, double *a4)
{
  double v8 = (*(double (**)(uint64_t))(*(void *)a1 + 504))(a1);
  double v9 = (*(double (**)(uint64_t))(*(void *)a1 + 688))(a1);
  double v10 = (*(double (**)(uint64_t))(*(void *)a1 + 488))(a1);
  (*(void (**)(double *__return_ptr, uint64_t))(*(void *)a1 + 272))(v13, a1);
  if (a2 != a3)
  {
    double v11 = v9 * v10 * v13[0] * 0.5;
    double v12 = v11 / tan(v8 * 0.5 * 3.14159265 / 180.0);
    if (a3 == 1) {
      double v12 = -v12;
    }
    *a4 = *a4 + v12;
  }
}

double LiCamera::getFarDepth(LiCamera *this)
{
  double v2 = (*(double (**)(LiCamera *))(*(void *)this + 576))(this);
  if ((*(unsigned int (**)(LiCamera *))(*(void *)this + 632))(this) == 1) {
    return v2 + (*(double (**)(LiCamera *))(*(void *)this + 320))(this);
  }
  return v2;
}

uint64_t LiCamera::getNearDepth(LiCamera *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 536))();
}

uint64_t LiCamera::convertToModel(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 632))(a1);
  if (result != a2)
  {
    uint64_t v5 = result;
    memset(v8, 0, sizeof(v8));
    (*(void (**)(uint64_t, void *))(*(void *)a1 + 440))(a1, v8);
    (*(void (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)a1 + 368))(a1, v5, a2, v8);
    (*(void (**)(uint64_t, void *))(*(void *)a1 + 448))(a1, v8);
    double v7 = (*(double (**)(uint64_t))(*(void *)a1 + 576))(a1);
    (*(void (**)(uint64_t, uint64_t, uint64_t, double *))(*(void *)a1 + 376))(a1, v5, a2, &v7);
    v6.n128_f64[0] = v7;
    (*(void (**)(uint64_t, __n128))(*(void *)a1 + 584))(a1, v6);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 640))(a1, a2);
  }
  return result;
}

double LiCamera::localToWorldMatrix@<D0>(LiCamera *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v65 = 0;
  double v66 = 0.0;
  double v67 = 0.0;
  double v62 = 0.0;
  double v63 = 0.0;
  double v64 = 0.0;
  v61[0] = 1.0;
  memset(&v61[1], 0, 24);
  *(void *)(a2 + 120) = 0x3FF0000000000000;
  *(void *)(a2 + 80) = 0x3FF0000000000000;
  *(void *)(a2 + 40) = 0x3FF0000000000000;
  *(void *)a2 = 0x3FF0000000000000;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  (*(void (**)(double *__return_ptr))(*(void *)this + 424))(v60);
  (*(void (**)(LiCamera *, unint64_t *))(*(void *)this + 440))(this, &v65);
  (*(void (**)(LiCamera *, double *))(*(void *)this + 472))(this, v61);
  (*(void (**)(LiCamera *, double *))(*(void *)this + 456))(this, &v62);
  *(void *)(a2 + 120) = 0x3FF0000000000000;
  *(void *)(a2 + 80) = 0x3FF0000000000000;
  *(void *)(a2 + 40) = 0x3FF0000000000000;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  *(double *)&unint64_t v4 = -v62;
  double v5 = -v63;
  double v6 = -v64;
  *(void *)a2 = 0x3FF0000000000000;
  PCMatrix44Tmpl<double>::leftTranslate((float64x2_t *)a2, (float64x2_t)v4, v5, v6);
  __n128 v7 = PCMatrix44Tmpl<double>::leftRotate((long long *)a2, v61);
  v7.n128_u64[0] = v65;
  PCMatrix44Tmpl<double>::leftTranslate((float64x2_t *)a2, (float64x2_t)v7, v66, v67);
  PCMatrix44Tmpl<double>::leftMult(a2, v60);
  double v8 = *(double *)(a2 + 120);
  if (v8 > -0.0000001 && v8 < 0.0000001)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v70, "!PCMath::isZero(w)");
    PCException::PCException(exception, &v70);
    *(void *)exception = &unk_1F1199218;
  }
  double v10 = *(double *)a2;
  double v9 = *(double *)(a2 + 8);
  double v12 = *(double *)(a2 + 32);
  double v11 = *(double *)(a2 + 40);
  double v14 = *(double *)(a2 + 64);
  double v13 = *(double *)(a2 + 72);
  double v15 = *(double *)(a2 + 16);
  double v16 = *(double *)(a2 + 48);
  double v17 = *(double *)(a2 + 80);
  double v18 = sqrt(v15 * v15 + v16 * v16 + v17 * v17);
  if (v18 > -0.0000001 && v18 < 0.0000001)
  {
    double v19 = v13 * 0.0;
    double v20 = v11 * 0.0;
    double v15 = v13 * 0.0 - v11 * 0.0;
    double v21 = v9 * 0.0;
    double v16 = v9 * 0.0 - v13;
    double v17 = v11 - v9 * 0.0;
    double v18 = sqrt(v17 * v17 + v16 * v16 + v15 * v15);
    if (v18 > -0.0000001 && v18 < 0.0000001)
    {
      double v15 = v13 - v20;
      double v16 = v21 - v19;
      double v17 = v20 - v9;
      double v18 = sqrt(v17 * v17 + v15 * v15 + v16 * v16);
      if (v18 > -0.0000001 && v18 < 0.0000001)
      {
        double v15 = v12 * 0.0 - v14;
        double v16 = v14 * 0.0 - v10 * 0.0;
        double v17 = v10 - v12 * 0.0;
        double v18 = sqrt(v17 * v17 + v15 * v15 + v16 * v16);
        if (v18 > -0.0000001 && v18 < 0.0000001)
        {
          double v15 = v20 - v19;
          double v16 = v13 - v21;
          double v17 = v21 - v11;
          double v18 = sqrt(v17 * v17 + v16 * v16 + v15 * v15);
          if (v18 > -0.0000001 && v18 < 0.0000001)
          {
            double v16 = 0.0;
            double v17 = 1.0;
            double v15 = 0.0;
            double v18 = 1.0;
          }
        }
      }
    }
  }
  double v22 = v8 / v18;
  double v23 = v15 * v22;
  double v24 = v16 * v22;
  *(double *)long long v68 = v23;
  *(double *)&v68[1] = v24;
  double v25 = v17 * v22;
  *(double *)&v68[2] = v25;
  double v26 = v14 * v25 + v10 * v23 + v12 * v24;
  double v27 = v10 - v23 * v26;
  double v28 = v12 - v24 * v26;
  double v29 = v14 - v25 * v26;
  double v30 = v13 * v25 + v9 * v23 + v11 * v24;
  double v31 = v25 * v30;
  double v32 = v9 - v23 * v30;
  double v33 = v11 - v24 * v30;
  double v34 = v13 - v31;
  double v35 = sqrt(v34 * v34 + v32 * v32 + v33 * v33);
  if (v35 > -0.0000001 && v35 < 0.0000001)
  {
    double v36 = v24 * 0.0;
    double v32 = v24 * 0.0 - v25 * 0.0;
    double v33 = v25 - v23 * 0.0;
    double v34 = v23 * 0.0 - v24;
    double v35 = sqrt(v34 * v34 + v32 * v32 + v33 * v33);
    if (v35 > -0.0000001)
    {
      double v37 = v36 - v25;
      double v38 = v23 - v36;
      double v39 = sqrt(v38 * v38 + v37 * v37 + (v25 * 0.0 - v23 * 0.0) * (v25 * 0.0 - v23 * 0.0));
      if (v35 < 0.0000001)
      {
        double v34 = v38;
        double v33 = v25 * 0.0 - v23 * 0.0;
        double v32 = v37;
        double v35 = v39;
      }
    }
  }
  double v40 = v8 / v35;
  double v41 = v32 * (v8 / v35);
  double v42 = v33 * (v8 / v35);
  *(double *)float32x4_t v69 = v41;
  *(double *)&v69[1] = v42;
  double v43 = v34 * v40;
  *(double *)&v69[2] = v43;
  double v44 = v29 * v43 + v27 * v41 + v28 * v42;
  double v45 = v27 - v41 * v44;
  double v46 = v28 - v42 * v44;
  double v47 = v29 - v43 * v44;
  double v48 = sqrt(v47 * v47 + v45 * v45 + v46 * v46);
  if (v48 <= -0.0000001 || v48 >= 0.0000001)
  {
    double v54 = v8 / v48;
    double v51 = v45 * v54;
    double v52 = v46 * v54;
    double v53 = v47 * v54;
  }
  else
  {
    double v49 = v25 * v42 - v24 * v43;
    double v50 = v24 * v41 - v23 * v42;
    double v51 = v8 * v49;
    double v52 = v8 * (v23 * v43 - v25 * v41);
    double v53 = v8 * v50;
  }
  uint64_t v55 = 0;
  v70.var0 = *(__CFString **)&v51;
  double v71 = v52;
  uint64_t v56 = (double *)(a2 + 16);
  double v72 = v53;
  do
  {
    uint64_t v57 = v69[v55];
    *(v56 - 2) = *(double *)((char *)&v70.var0 + v55 * 8);
    *((void *)v56 - 1) = v57;
    double result = *(double *)&v68[v55];
    *uint64_t v56 = result;
    v56 += 4;
    ++v55;
  }
  while (v55 != 3);
  return result;
}

void sub_1B7A5E8D4(_Unwind_Exception *a1)
{
  PCString::~PCString((PCString *)(v1 - 56));
  _Unwind_Resume(a1);
}

__n128 PCMatrix44Tmpl<double>::leftRotate(long long *a1, double *a2)
{
  uint64_t v17 = 0x3FF0000000000000;
  uint64_t v14 = 0x3FF0000000000000;
  uint64_t v11 = 0x3FF0000000000000;
  uint64_t v8 = 0x3FF0000000000000;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  PCMatrix44Tmpl<double>::setRotationFromQuaternion((uint64_t)&v8, a2);
  PCMatrix44Tmpl<double>::operator*((uint64_t)&v8, a1, (uint64_t)v7);
  if (v7 != (unsigned char *)a1)
  {
    for (uint64_t i = 0; i != 8; i += 2)
    {
      double v5 = &a1[i];
      __n128 result = *(__n128 *)&v7[i * 16];
      long long v6 = *(_OWORD *)&v7[i * 16 + 16];
      long long *v5 = (__int128)result;
      v5[1] = v6;
    }
  }
  return result;
}

BOOL LiCamera::worldToLocalMatrix@<W0>(LiCamera *this@<X0>, double *a2@<X8>)
{
  (*(void (**)(LiCamera *))(*(void *)this + 16))(this);
  BOOL result = PCMatrix44Tmpl<double>::invert(a2, a2, 0.0);
  if (!result)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v5, "singular camera local matrix");
    PCException::PCException(exception, &v5);
  }
  return result;
}

void sub_1B7A5EA58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

double LiCamera::eyeToFilmMatrix@<D0>(LiCamera *this@<X0>, double *a2@<X8>)
{
  (*(void (**)(LiCamera *))(*(void *)this + 32))(this);
  double result = (*(double (**)(LiCamera *))(*(void *)this + 504))(this);
  if (result <= -0.0000001 || result >= 0.0000001)
  {
    (*(void (**)(double *__return_ptr, LiCamera *))(*(void *)this + 328))(v5, this);
    return PCMatrix44Tmpl<double>::rightTranslate(a2, v5[0], v5[1], v5[2]);
  }
  return result;
}

double LiCamera::eyeToFilmMatrixRespectFarDepth@<D0>(LiCamera *this@<X0>, double *a2@<X8>)
{
  (*(void (**)(LiCamera *))(*(void *)this + 40))(this);
  double result = (*(double (**)(LiCamera *))(*(void *)this + 504))(this);
  if (result <= -0.0000001 || result >= 0.0000001)
  {
    (*(void (**)(double *__return_ptr, LiCamera *))(*(void *)this + 328))(v5, this);
    return PCMatrix44Tmpl<double>::rightTranslate(a2, v5[0], v5[1], v5[2]);
  }
  return result;
}

double LiCamera::localToFilmMatrix@<D0>(LiCamera *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)&double result = *(_OWORD *)&LiCamera::localToFilmMatrix(this, 0, a2);
  return result;
}

float64x2_t LiCamera::localToFilmMatrix@<Q0>(LiCamera *this@<X0>, char a2@<W1>, uint64_t a3@<X8>)
{
  *(void *)&v22[40] = 0x3FF0000000000000;
  *(void *)double v22 = 0x3FF0000000000000;
  *(void *)&v19[40] = 0x3FF0000000000000;
  *(void *)double v19 = 0x3FF0000000000000;
  memset(&v19[8], 0, 32);
  long long v20 = 0u;
  long long v21 = 0u;
  memset(&v22[8], 0, 32);
  (*(void (**)(LiCamera *, unsigned char *))(*(void *)this + 264))(this, v18);
  long long v6 = *(_OWORD *)v22;
  *(_OWORD *)(a3 + 64) = v21;
  *(_OWORD *)(a3 + 80) = v6;
  long long v7 = *(_OWORD *)&v22[32];
  *(_OWORD *)(a3 + 96) = *(_OWORD *)&v22[16];
  *(_OWORD *)(a3 + 112) = v7;
  long long v8 = *(_OWORD *)&v19[16];
  *(_OWORD *)a3 = *(_OWORD *)v19;
  *(_OWORD *)(a3 + 16) = v8;
  long long v9 = v20;
  *(_OWORD *)(a3 + 32) = *(_OWORD *)&v19[32];
  *(_OWORD *)(a3 + 48) = v9;
  (*(void (**)(long long *__return_ptr, LiCamera *))(*(void *)this + 56))(v15, this);
  PCMatrix44Tmpl<double>::operator*(a3, v15, (uint64_t)v16);
  if (v16 != (double *)a3)
  {
    for (uint64_t i = 0; i != 16; i += 4)
    {
      uint64_t v12 = a3 + i * 8;
      float64x2_t result = *(float64x2_t *)&v16[i];
      long long v13 = *(_OWORD *)&v16[i + 2];
      *(float64x2_t *)uint64_t v12 = result;
      *(_OWORD *)(v12 + 16) = v13;
    }
  }
  if ((a2 & 1) == 0)
  {
    v16[0] = 0.0;
    v16[1] = 0.0;
    long long v17 = xmmword_1B7E733D0;
    PCMatrix44Tmpl<double>::transform<double>((double *)a3, v16, v16);
    *(void *)&result.f64[0] = v17;
    if (*(double *)&v17 != 0.0 && *((double *)&v17 + 1) != 0.0)
    {
      result.f64[0] = *((double *)&v17 + 1) / *(double *)&v17;
      if (*((double *)&v17 + 1) / *(double *)&v17 != 1.0)
      {
        float64x2_t v14 = vmulq_n_f64(*(float64x2_t *)(a3 + 64), result.f64[0]);
        float64x2_t result = vmulq_n_f64(*(float64x2_t *)(a3 + 80), result.f64[0]);
        *(float64x2_t *)(a3 + 64) = v14;
        *(float64x2_t *)(a3 + 80) = result;
      }
    }
  }
  return result;
}

double LiCamera::localToFilmMatrixRespectFarDepth@<D0>(LiCamera *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)&double result = *(_OWORD *)&LiCamera::localToFilmMatrix(this, 1, a2);
  return result;
}

long double LiCamera::getCameraInternalParams(uint64_t a1, uint64_t a2)
{
  (*(void (**)(double *__return_ptr))(*(void *)a1 + 280))(v21);
  double v4 = (*(double (**)(uint64_t))(*(void *)a1 + 504))(a1);
  double v5 = (*(double (**)(uint64_t))(*(void *)a1 + 688))(a1);
  double v6 = (*(double (**)(uint64_t))(*(void *)a1 + 488))(a1);
  double v7 = v21[2];
  double v8 = v21[3];
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(double *)(a2 + 32) = v7 * 0.5;
  double v9 = v21[1];
  double v10 = v21[0] + v7 * 0.5;
  *(void *)(a2 + 144) = 0;
  *(void *)(a2 + 152) = 0x3FF0000000000000;
  *(void *)(a2 + 128) = 0;
  *(void *)(a2 + 136) = 0;
  *(double *)(a2 + 56) = v10;
  *(double *)(a2 + 72) = v8 * 0.5;
  *(double *)(a2 + 88) = v9 + v8 * 0.5;
  __asm { FMOV            V3.2D, #0.5 }
  *(_OWORD *)(a2 + 112) = _Q3;
  double v16 = v5 * v6 * v7;
  double v17 = v6 * v8;
  double v18 = v16 / (v6 * v8);
  long double v19 = tan(v4 / 114.591559);
  long double result = atan(v19 / v18) * 114.591559;
  *(double *)a2 = v18;
  *(long double *)(a2 + 8) = result;
  *(double *)(a2 + 16) = v16;
  *(double *)(a2 + 24) = v17;
  return result;
}

void LiCamera::localToClipMatrix(LiCamera *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v22 = 0x3FF0000000000000;
  uint64_t v19 = 0x3FF0000000000000;
  uint64_t v16 = 0x3FF0000000000000;
  uint64_t v13 = 0x3FF0000000000000;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  (*(void (**)(LiCamera *, double *))(*(void *)this + 264))(this, &v9);
  int v4 = (*(uint64_t (**)(LiCamera *))(*(void *)this + 632))(this);
  double v5 = (*(double (**)(LiCamera *))(*(void *)this + 112))(this);
  double v6 = (*(double (**)(LiCamera *))(*(void *)this + 120))(this);
  *(void *)(a2 + 120) = 0x3FF0000000000000;
  *(void *)(a2 + 80) = 0x3FF0000000000000;
  *(void *)(a2 + 40) = 0x3FF0000000000000;
  *(void *)a2 = 0x3FF0000000000000;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  if (v4 == 1)
  {
    PCMatrix44Tmpl<double>::rightFramePerspective(a2, v11, v12, v10, v6, v6, v5);
  }
  else if (!v4)
  {
    int v7 = (*(uint64_t (**)(LiCamera *))(*(void *)this + 520))(this);
    double v8 = 0.001;
    if (v7) {
      double v8 = 1.0;
    }
    if (v10 >= v8) {
      double v8 = v10;
    }
    double v10 = v8;
    PCMatrix44Tmpl<double>::rightPerspective(a2, v8, v9, v5, v6);
  }
}

void PCMatrix44Tmpl<double>::rightPerspective(uint64_t a1, double a2, double a3, double a4, double a5)
{
  long double v9 = tan(a2 / 360.0 * 3.14159265) * a4;
  double v10 = (a4 + a4) / (v9 * a3 + v9 * a3);
  double v13 = (a4 + a4) / (v9 + v9);
  long long v11 = 0u;
  long long v12 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  double v16 = -(a4 + a5) / (a5 - a4);
  double v17 = a5 * -2.0 * a4 / (a5 - a4);
  long long v18 = 0u;
  long long v19 = xmmword_1B7E7C890;
  PCMatrix44Tmpl<double>::rightMult(a1, &v10);
}

double PCMatrix44Tmpl<double>::rightFramePerspective(uint64_t a1, double a2, double a3, double a4, double a5, double a6, double a7)
{
  uint64_t v18 = 0x3FF0000000000000;
  uint64_t v15 = 0x3FF0000000000000;
  uint64_t v12 = 0x3FF0000000000000;
  uint64_t v9 = 0x3FF0000000000000;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  PCMatrix44Tmpl<double>::setFramePerspective((uint64_t)&v9, a2, a3, a4, a5, a6, a7);
  return PCMatrix44Tmpl<double>::rightMult(a1, (double *)&v9);
}

double LiCamera::imageToFilmMatrix@<D0>(LiCamera *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 120) = 0x3FF0000000000000;
  *(void *)(a2 + 80) = 0x3FF0000000000000;
  *(void *)(a2 + 40) = 0x3FF0000000000000;
  *(void *)a2 = 0x3FF0000000000000;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  *(double *)a2 = 1.0 / (*(double (**)(LiCamera *))(*(void *)this + 688))(this);
  double result = 0.0;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(void *)(a2 + 40) = 0x3FF0000000000000;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(void *)(a2 + 80) = 0x3FF0000000000000;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  *(void *)(a2 + 120) = 0x3FF0000000000000;
  return result;
}

double LiCamera::filmToImageMatrix@<D0>(LiCamera *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 120) = 0x3FF0000000000000;
  *(void *)(a2 + 80) = 0x3FF0000000000000;
  *(void *)(a2 + 40) = 0x3FF0000000000000;
  *(void *)a2 = 0x3FF0000000000000;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  *(double *)a2 = (*(double (**)(LiCamera *))(*(void *)this + 688))(this);
  double result = 0.0;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(void *)(a2 + 40) = 0x3FF0000000000000;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(void *)(a2 + 80) = 0x3FF0000000000000;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  *(void *)(a2 + 120) = 0x3FF0000000000000;
  return result;
}

double LiCamera::worldUnitScale(LiCamera *this, char a2)
{
  (*(void (**)(double *__return_ptr))(*(void *)this + 56))(v30);
  PCMatrix44Tmpl<double>::invert(v30, v30, 0.0);
  (*(void (**)(double *__return_ptr, LiCamera *))(*(void *)this + 32))(v29, this);
  PCMatrix44Tmpl<double>::invert(v29, v29, 0.0);
  float64x2_t v27 = 0uLL;
  double v28 = 0.0;
  float64x2_t v25 = 0uLL;
  *(double *)&uint64_t v26 = 0.5;
  PCMatrix44Tmpl<double>::transform<double>(v30, v25.f64, v27.f64);
  float64x2_t v25 = 0uLL;
  *(double *)&uint64_t v26 = 0.0;
  __asm { FMOV            V0.2D, #1.0 }
  float64x2_t v23 = _Q0;
  double v24 = 0.5;
  PCMatrix44Tmpl<double>::transform<double>(v30, v23.f64, v25.f64);
  float64x2_t v17 = v25;
  float64x2_t v18 = v27;
  double v9 = v28;
  double v10 = *(double *)&v26;
  if (a2)
  {
    double v11 = 1.0;
  }
  else
  {
    (*(void (**)(float64x2_t *__return_ptr, LiCamera *))(*(void *)this + 272))(&v23, this);
    double v12 = v23.f64[0];
    double v13 = (*(double (**)(LiCamera *))(*(void *)this + 688))(this);
    double v11 = v12 * v13 / v23.f64[1];
  }
  float64x2_t v23 = 0uLL;
  double v24 = 0.0;
  float64x2_t v21 = 0uLL;
  double v22 = 0.5;
  PCMatrix44Tmpl<double>::transform<double>(v29, v21.f64, v23.f64);
  float64x2_t v21 = 0uLL;
  double v22 = 0.0;
  double v19 = v11;
  long long v20 = xmmword_1B837B580;
  PCMatrix44Tmpl<double>::transform<double>(v29, &v19, v21.f64);
  float64x2_t v14 = vsubq_f64(v18, v17);
  float64x2_t v15 = vsubq_f64(v23, v21);
  return sqrt(vaddvq_f64(vmulq_f64(v14, v14)) + (v9 - v10) * (v9 - v10))
       / sqrt(vaddvq_f64(vmulq_f64(v15, v15)) + (v24 - v22) * (v24 - v22));
}

BOOL LiCamera::ray(uint64_t a1, double *a2, uint64_t a3)
{
  double v6 = (*(double (**)(uint64_t))(*(void *)a1 + 504))(a1);
  int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 632))(a1);
  double v8 = *a2;
  double v9 = v8 * (*(double (**)(uint64_t))(*(void *)a1 + 688))(a1);
  double v10 = a2[1];
  double v11 = (*(double (**)(uint64_t))(*(void *)a1 + 488))(a1);
  double v12 = v9 * v11;
  double v13 = v10 * v11;
  if (fabs(v6) >= 0.0000001)
  {
    double v15 = v11 * 0.0;
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    (*(void (**)(uint64_t))(*(void *)a1 + 320))(a1);
    if (v7 == 1)
    {
      double v17 = v16 + *(double *)(a3 + 16);
      *(double *)(a3 + 16) = v17;
    }
    else
    {
      double v15 = v15 - v16;
      double v17 = *(double *)(a3 + 16);
    }
    double v18 = v13 - *(double *)(a3 + 8);
    *(double *)(a3 + 24) = v12 - *(double *)a3;
    *(double *)(a3 + 32) = v18;
    *(double *)(a3 + 40) = v15 - v17;
  }
  else
  {
    double v14 = (*(double (**)(uint64_t))(*(void *)a1 + 576))(a1);
    *(double *)a3 = v12;
    *(double *)(a3 + 8) = v13;
    *(double *)(a3 + 16) = v14;
    *(void *)(a3 + 24) = 0;
    *(void *)(a3 + 32) = 0;
    *(void *)(a3 + 40) = 0xBFF0000000000000;
  }
  (*(void (**)(double *__return_ptr, uint64_t))(*(void *)a1 + 16))(v25, a1);
  PCMatrix44Tmpl<double>::transform<double>(v25, (double *)a3, (double *)a3);
  double v20 = *(double *)(a3 + 24);
  double v21 = *(double *)(a3 + 32);
  double v19 = (double *)(a3 + 24);
  double v22 = v19[2];
  double v23 = v20 * v25[4] + v21 * v25[5] + v22 * v25[6];
  double *v19 = v20 * v25[0] + v21 * v25[1] + v22 * v25[2];
  v19[1] = v23;
  v19[2] = v20 * v25[8] + v21 * v25[9] + v22 * v25[10];
  return PCVector3<double>::normalize(v19, 0.000000100000001);
}

uint64_t LiCamera::ray@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *))(*(void *)a1 + 64))(a1, a2, a3);
}

uint64_t LiCamera::ray@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, _OWORD *a3@<X8>)
{
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  long long v4 = *a2;
  return (*(uint64_t (**)(uint64_t, long long *, _OWORD *))(*(void *)a1 + 64))(a1, &v4, a3);
}

BOOL LiCamera::getPlaneAtDistance@<W0>(LiCamera *this@<X0>, double a2@<D0>, _OWORD *a3@<X8>)
{
  double v6 = (*(double (**)(LiCamera *))(*(void *)this + 504))(this);
  if (v6 <= -0.0000001 || (double v7 = 0.0, v6 >= 0.0000001))
  {
    (*(void (**)(double *__return_ptr, LiCamera *))(*(void *)this + 328))(v9, this);
    double v7 = v9[2];
  }
  float64x2_t v10 = 0uLL;
  unint64_t v11 = 0xBFF0000000000000;
  double v12 = v7 - a2;
  (*(void (**)(double *__return_ptr, LiCamera *))(*(void *)this + 24))(v9, this);
  PCMatrix44Tmpl<double>::transform_row<double>(v9, v10.f64, v10.f64);
  *a3 = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  return PCPlane<double>::setImplicit((uint64_t)a3, &v10);
}

BOOL PCPlane<double>::setImplicit(uint64_t a1, float64x2_t *a2)
{
  float64x2_t v2 = *a2;
  double v3 = a2[1].f64[0];
  double v4 = vaddvq_f64(vmulq_f64(v2, v2)) + v3 * v3;
  BOOL v5 = v4 >= 1.0e-24 || v4 <= -1.0e-24;
  if (v5)
  {
    *(float64x2_t *)(a1 + 24) = v2;
    *(double *)(a1 + 40) = v3;
    double v6 = a2[1].f64[1];
    *(float64x2_t *)a1 = vdivq_f64(vmulq_n_f64(v2, -v6), (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v4, 0));
    *(double *)(a1 + 16) = -(v6 * v3) / v4;
  }
  return v5;
}

uint64_t LiCamera::getNearClip(uint64_t a1, uint64_t a2)
{
  double v4 = (*(double (**)(uint64_t))(*(void *)a1 + 504))(a1);
  if (v4 > -0.0000001 && v4 < 0.0000001) {
    return 0;
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 536))(a1);
  (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)a1 + 208))(&v6, a1);
  *(_OWORD *)a2 = v6;
  *(void *)(a2 + 16) = v7;
  *(_OWORD *)(a2 + 24) = v8;
  *(void *)(a2 + 40) = v9;
  return 1;
}

void sub_1B7A5FC20(void *a1)
{
}

uint64_t LiCamera::getFarClip(uint64_t a1, uint64_t a2)
{
  double v4 = (*(double (**)(uint64_t))(*(void *)a1 + 504))(a1);
  if (v4 > -0.0000001 && v4 < 0.0000001) {
    return 0;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 624))(a1);
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 120))(a1);
    (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)a1 + 208))(&v6, a1);
    *(_OWORD *)a2 = v6;
    *(void *)(a2 + 16) = v7;
    *(_OWORD *)(a2 + 24) = v8;
    *(void *)(a2 + 40) = v9;
    *(float64x2_t *)(a2 + 24) = vnegq_f64(*(float64x2_t *)(a2 + 24));
    *(double *)(a2 + 40) = -*(double *)(a2 + 40);
    return 1;
  }
  return result;
}

void sub_1B7A5FD70(void *a1)
{
}

void LiCamera::imageToWorldMatrix(uint64_t a1, uint64_t a2)
{
  (*(void (**)(double *__return_ptr))(*(void *)a1 + 424))(v24);
  unint64_t v21 = 0;
  double v22 = 0.0;
  double v23 = 0.0;
  v20[0] = 1.0;
  memset(&v20[1], 0, 24);
  float64_t v17 = 0.0;
  double v18 = 0.0;
  double v19 = 0.0;
  (*(void (**)(uint64_t, unint64_t *))(*(void *)a1 + 440))(a1, &v21);
  (*(void (**)(uint64_t, double *))(*(void *)a1 + 472))(a1, v20);
  (*(void (**)(uint64_t, float64_t *))(*(void *)a1 + 456))(a1, &v17);
  *(void *)(a2 + 120) = 0x3FF0000000000000;
  *(void *)(a2 + 80) = 0x3FF0000000000000;
  *(void *)(a2 + 40) = 0x3FF0000000000000;
  *(void *)a2 = 0x3FF0000000000000;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  if (!(*(unsigned int (**)(uint64_t))(*(void *)a1 + 632))(a1))
  {
    double v5 = (*(double (**)(uint64_t))(*(void *)a1 + 504))(a1);
    int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 520))(a1);
    BOOL v7 = v5 < 5.0;
    double v8 = v5 * 0.5;
    double v9 = (*(double (**)(uint64_t))(*(void *)a1 + 688))(a1);
    (*(void (**)(double *__return_ptr, uint64_t))(*(void *)a1 + 272))(v16, a1);
    double v10 = (*(double (**)(uint64_t))(*(void *)a1 + 488))(a1);
    double v11 = v9 * v10 * v16[0];
    double v12 = v8 * 3.14159265 / 180.0;
    if ((v6 & v7) != 0) {
      double v12 = 0.0436332313;
    }
    double v13 = v11 * -0.5 / tan(v12);
    v14.f64[0] = 0.0;
    float64x2_t v4 = PCMatrix44Tmpl<double>::leftTranslate((float64x2_t *)a2, v14, 0.0, v13);
  }
  v4.f64[0] = v17;
  PCMatrix44Tmpl<double>::leftTranslate((float64x2_t *)a2, v4, v18, v19);
  __n128 v15 = PCMatrix44Tmpl<double>::leftRotate((long long *)a2, v20);
  v15.n128_u64[0] = v21;
  PCMatrix44Tmpl<double>::leftTranslate((float64x2_t *)a2, (float64x2_t)v15, v22, v23);
  PCMatrix44Tmpl<double>::leftMult(a2, v24);
}

void LiCamera::worldToImageMatrix(uint64_t a1, float64x2_t *a2)
{
  double v31 = 0.0;
  double v32 = 0.0;
  double v33 = 0.0;
  double v28 = 1.0;
  float64x2_t v29 = 0uLL;
  double v30 = 0.0;
  double v25 = 0.0;
  double v26 = 0.0;
  double v27 = 0.0;
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 424))(v24);
  (*(void (**)(uint64_t, double *))(*(void *)a1 + 440))(a1, &v31);
  (*(void (**)(uint64_t, double *))(*(void *)a1 + 472))(a1, &v28);
  (*(void (**)(uint64_t, double *))(*(void *)a1 + 456))(a1, &v25);
  if (v24 != (void *)a2)
  {
    for (unint64_t i = 0; i != 16; i += 4)
    {
      f64 = (_OWORD *)a2[i / 2].f64;
      long long v6 = *(_OWORD *)&v24[i + 2];
      _OWORD *f64 = *(_OWORD *)&v24[i];
      f64[1] = v6;
    }
  }
  PCMatrix44Tmpl<double>::invert(a2->f64, a2->f64, 0.0);
  v7.f64[0] = -v31;
  PCMatrix44Tmpl<double>::leftTranslate(a2, v7, -v32, -v33);
  double v21 = v28;
  float64x2_t v22 = v29;
  double v23 = v30;
  double v8 = v21 * v21 + vaddvq_f64(vmulq_f64(v22, v22)) + v23 * v23;
  if (v8 != 0.0)
  {
    double v21 = v28 / v8;
    float64x2_t v22 = vdivq_f64(vnegq_f64(v29), (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v8, 0));
    double v23 = -v30 / v8;
  }
  __n128 v9 = PCMatrix44Tmpl<double>::leftRotate((long long *)a2, &v21);
  v9.n128_f64[0] = -v25;
  float64x2_t v10 = PCMatrix44Tmpl<double>::leftTranslate(a2, (float64x2_t)v9, -v26, -v27);
  if (!(*(unsigned int (**)(uint64_t, float64x2_t))(*(void *)a1 + 632))(a1, v10))
  {
    double v11 = (*(double (**)(uint64_t))(*(void *)a1 + 504))(a1);
    int v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 520))(a1);
    BOOL v13 = v11 < 5.0;
    double v14 = v11 * 0.5;
    double v15 = (*(double (**)(uint64_t))(*(void *)a1 + 688))(a1);
    (*(void (**)(double *__return_ptr, uint64_t))(*(void *)a1 + 272))(&v21, a1);
    double v16 = (*(double (**)(uint64_t))(*(void *)a1 + 488))(a1);
    double v17 = v15 * v16 * v21;
    double v18 = v14 * 3.14159265 / 180.0;
    if ((v12 & v13) != 0) {
      double v18 = 0.0436332313;
    }
    double v19 = v17 * -0.5 / tan(v18);
    v20.f64[0] = 0.0;
    PCMatrix44Tmpl<double>::leftTranslate(a2, v20, 0.0, v19);
  }
}

double LiCamera::eyeToWorldMatrix@<D0>(LiCamera *this@<X0>, double *a2@<X8>)
{
  (*(void (**)(LiCamera *))(*(void *)this + 16))(this);
  if ((*(unsigned int (**)(LiCamera *))(*(void *)this + 632))(this) == 1)
  {
    double result = (*(double (**)(LiCamera *))(*(void *)this + 504))(this);
    if (result <= -0.0000001 || result >= 0.0000001)
    {
      double v5 = (*(double (**)(LiCamera *))(*(void *)this + 320))(this);
      return PCMatrix44Tmpl<double>::rightTranslate(a2, 0.0, 0.0, v5);
    }
  }
  return result;
}

double LiCamera::worldToEyeMatrix@<D0>(LiCamera *this@<X0>, float64x2_t *a2@<X8>)
{
  (*(void (**)(LiCamera *))(*(void *)this + 24))(this);
  if ((*(unsigned int (**)(LiCamera *))(*(void *)this + 632))(this) == 1)
  {
    double result = (*(double (**)(LiCamera *))(*(void *)this + 504))(this);
    if (result <= -0.0000001 || result >= 0.0000001)
    {
      double v5 = -(*(double (**)(LiCamera *))(*(void *)this + 320))(this);
      v6.f64[0] = 0.0;
      *(void *)&double result = *(_OWORD *)&PCMatrix44Tmpl<double>::leftTranslate(a2, v6, 0.0, v5);
    }
  }
  return result;
}

void LiCamera::getEyeFrustum(uint64_t a1, uint64_t a2, float64x2_t *a3, int a4)
{
  double v8 = (*(double (**)(uint64_t))(*(void *)a1 + 320))(a1);
  double v9 = (*(double (**)(uint64_t))(*(void *)a1 + 504))(a1);
  BOOL v10 = v9 > -0.0000001;
  BOOL v11 = v9 < 0.0000001;
  if (v10 && v11) {
    double v12 = 0.0;
  }
  else {
    double v12 = 1.0;
  }
  if (v10 && v11) {
    double v13 = 1.0;
  }
  else {
    double v13 = v8;
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 632))(a1)) {
    double v14 = 0.0;
  }
  else {
    double v14 = -v8;
  }
  double v15 = a3->f64[1];
  *(float64_t *)(a2 + 96) = a3->f64[0];
  *(double *)(a2 + 104) = v15;
  *(double *)(a2 + 112) = v14;
  *(void *)(a2 + 120) = 0;
  *(double *)(a2 + 128) = v13;
  *(double *)(a2 + 136) = v12 * v15;
  PCVector3<double>::normalize((double *)(a2 + 120), 0.000000100000001);
  float64x2_t v16 = vaddq_f64(*a3, a3[1]);
  *(float64x2_t *)(a2 + 144) = v16;
  *(double *)(a2 + 160) = v14;
  *(void *)(a2 + 168) = 0;
  *(double *)(a2 + 176) = -v13;
  *(double *)(a2 + 184) = vmuld_lane_f64(-v12, v16, 1);
  PCVector3<double>::normalize((double *)(a2 + 168), 0.000000100000001);
  float64x2_t v17 = *a3;
  *(float64x2_t *)a2 = *a3;
  *(double *)(a2 + 16) = v14;
  *(double *)(a2 + 24) = v13;
  *(void *)(a2 + 32) = 0;
  *(double *)(a2 + 40) = v12 * v17.f64[0];
  PCVector3<double>::normalize((double *)(a2 + 24), 0.000000100000001);
  float64x2_t v18 = *a3;
  float64x2_t v19 = a3[1];
  *(double *)(a2 + 72) = -v13;
  float64x2_t v20 = vaddq_f64(v18, v19);
  *(float64x2_t *)(a2 + 48) = v20;
  *(double *)(a2 + 64) = v14;
  *(void *)(a2 + 80) = 0;
  *(double *)(a2 + 88) = -v12 * v20.f64[0];
  PCVector3<double>::normalize((double *)(a2 + 72), 0.000000100000001);
  double v21 = (*(double (**)(uint64_t))(*(void *)a1 + 112))(a1);
  *(void *)(a2 + 192) = 0;
  *(void *)(a2 + 200) = 0;
  *(double *)(a2 + 208) = v8 + v14 - v21;
  *(void *)(a2 + 216) = 0;
  *(void *)(a2 + 224) = 0;
  *(void *)(a2 + 232) = 0xBFF0000000000000;
  double v22 = (*(double (**)(uint64_t))(*(void *)a1 + 120))(a1);
  *(void *)(a2 + 240) = 0;
  *(void *)(a2 + 248) = 0;
  *(double *)(a2 + 256) = v8 + v14 - v22;
  *(void *)(a2 + 264) = 0;
  *(void *)(a2 + 272) = 0;
  *(void *)(a2 + 280) = 0x3FF0000000000000;
  if (a4)
  {
    (*(void (**)(_OWORD *__return_ptr, uint64_t))(*(void *)a1 + 16))(v23, a1);
    transform(v23, (double *)a2);
  }
}

uint64_t LiCamera::getFrustum(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4)
{
  long long v7 = a3[1];
  long long v13 = *a3;
  long long v14 = v7;
  double v8 = (*(double (**)(uint64_t))(*(void *)a1 + 488))(a1);
  double v9 = v8 * *(double *)&v13;
  double v10 = v8 * *(double *)&v14;
  *((double *)&v13 + 1) = v8 * *((double *)&v13 + 1);
  *((double *)&v14 + 1) = v8 * *((double *)&v14 + 1);
  double v11 = (*(double (**)(uint64_t))(*(void *)a1 + 688))(a1);
  *(double *)&long long v13 = v11 * v9;
  *(double *)&long long v14 = v11 * v10;
  return (*(uint64_t (**)(uint64_t, uint64_t, long long *, uint64_t))(*(void *)a1 + 256))(a1, a2, &v13, a4);
}

uint64_t LiCamera::getFrustum(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 312))(v7);
  return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)a1 + 256))(a1, a2, v7, a3);
}

__n128 LiCamera::getFilmbackRect@<Q0>(LiCamera *this@<X0>, uint64_t a2@<X8>)
{
  (*(void (**)(float64x2_t *__return_ptr))(*(void *)this + 272))(&v9);
  __n128 result = (__n128)v9;
  __asm { FMOV            V1.2D, #-0.5 }
  *(float64x2_t *)a2 = vmulq_f64(v9, _Q1);
  *(__n128 *)(a2 + 16) = result;
  return result;
}

double LiCamera::getEyeFilmback@<D0>(LiCamera *this@<X0>, float64x2_t *a2@<X8>)
{
  (*(void (**)(LiCamera *))(*(void *)this + 272))(this);
  *a2 = vmulq_n_f64(*a2, (*(double (**)(LiCamera *))(*(void *)this + 488))(this));
  double result = (*(double (**)(LiCamera *))(*(void *)this + 688))(this) * a2->f64[0];
  a2->f64[0] = result;
  return result;
}

__n128 LiCamera::getEyeFilmbackRect@<Q0>(LiCamera *this@<X0>, uint64_t a2@<X8>)
{
  (*(void (**)(float64x2_t *__return_ptr))(*(void *)this + 304))(&v9);
  __n128 result = (__n128)v9;
  __asm { FMOV            V1.2D, #-0.5 }
  *(float64x2_t *)a2 = vmulq_f64(v9, _Q1);
  *(__n128 *)(a2 + 16) = result;
  return result;
}

double LiCamera::rayMatrix(uint64_t a1, uint64_t a2)
{
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 272))(v9);
  double v4 = (*(double (**)(uint64_t))(*(void *)a1 + 504))(a1);
  long double v5 = tan(v4 * 3.14159265 / 360.0);
  double v6 = 2.0 / *(double *)&v9[1];
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 120) = 0;
  *(double *)a2 = v6;
  *(double *)(a2 + 40) = v6;
  *(void *)(a2 + 80) = 0;
  *(long double *)(a2 + 88) = -1.0 / v5;
  (*(void (**)(double *__return_ptr, uint64_t))(*(void *)a1 + 16))(v8, a1);
  return PCMatrix44Tmpl<double>::leftMult(a2, v8);
}

uint64_t LiCamera::setRotation(uint64_t a1, uint64_t a2, float64x2_t *a3)
{
  float64x2_t v10 = *a3;
  double v11 = a3[1].f64[0];
  (*(void (**)(float64x2_t *__return_ptr))(*(void *)a1 + 24))(&v8);
  PCMatrix44Tmpl<double>::transform<double>(v8.f64, v10.f64, v10.f64);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 480))(a1, a2);
  (*(void (**)(float64x2_t *__return_ptr, uint64_t))(*(void *)a1 + 16))(&v8, a1);
  PCMatrix44Tmpl<double>::transform<double>(v8.f64, v10.f64, v10.f64);
  float64x2_t v8 = 0uLL;
  double v9 = 0.0;
  (*(void (**)(uint64_t, float64x2_t *))(*(void *)a1 + 440))(a1, &v8);
  float64_t v6 = a3[1].f64[0] - v11;
  float64x2_t v8 = vaddq_f64(vsubq_f64(*a3, v10), v8);
  double v9 = v6 + v9;
  return (*(uint64_t (**)(uint64_t, float64x2_t *))(*(void *)a1 + 448))(a1, &v8);
}

double LiCamera::getEulerRotation@<D0>(LiCamera *this@<X0>, void *a2@<X8>)
{
  int v4 = (*(uint64_t (**)(LiCamera *))(*(void *)this + 648))(this);
  v6[0] = 1.0;
  memset(&v6[1], 0, 24);
  (*(void (**)(LiCamera *, double *))(*(void *)this + 472))(this, v6);
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v21 = 0x3FF0000000000000;
  uint64_t v18 = 0x3FF0000000000000;
  uint64_t v15 = 0x3FF0000000000000;
  uint64_t v12 = 0x3FF0000000000000;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  PCMatrix44Tmpl<double>::setRotationFromQuaternion((uint64_t)&v12, v6);
  memset(v7, 0, sizeof(v7));
  long long v9 = 0u;
  long long v10 = 0u;
  uint64_t v11 = 0;
  int v8 = v4;
  PCMatrix44Tmpl<double>::getTransformation((long long *)&v12, (uint64_t)v7);
  *(_OWORD *)a2 = v9;
  double result = *(double *)&v10;
  a2[2] = v10;
  return result;
}

uint64_t LiCamera::setEulerRotation(uint64_t a1, double *a2)
{
  v8[0] = 1.0;
  memset(&v8[1], 0, 24);
  double v3 = *a2;
  double v4 = a2[1];
  double v5 = a2[2];
  int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 648))(a1);
  PCQuat<double>::setEulerAngles(v8, v6, v3, v4, v5);
  return (*(uint64_t (**)(uint64_t, double *))(*(void *)a1 + 480))(a1, v8);
}

double *PCQuat<double>::setEulerAngles(double *a1, int a2, double a3, double a4, double a5)
{
  __double2 v9 = __sincos_stret(a3 * 0.5);
  __double2 v10 = __sincos_stret(a4 * 0.5);
  __double2 v11 = __sincos_stret(a5 * 0.5);
  double v12 = v9.__sinval * 0.0;
  double v13 = v10.__sinval * 0.0;
  double v14 = v11.__sinval * 0.0;
  switch(a2)
  {
    case 0:
      double v15 = v13 * v14;
      double v16 = v10.__sinval * v14;
      double v17 = v10.__cosval * v11.__cosval - (v13 * v14 + v10.__sinval * v14 + v13 * v11.__sinval);
      double v18 = v10.__cosval * v14;
      double v19 = v13 * v11.__cosval + v18;
      double v20 = v10.__sinval * v11.__cosval + v18;
      double v21 = v13 * v11.__cosval + v10.__cosval * v11.__sinval;
      double v22 = v15 - v10.__sinval * v11.__sinval;
      double v23 = v13 * v11.__sinval - v15;
      double v24 = v16 - v15;
      goto LABEL_4;
    case 1:
      double v25 = v14 * v13;
      double v26 = v14 * v10.__sinval;
      double v27 = v11.__sinval * v13;
      double v17 = v11.__cosval * v10.__cosval - (v14 * v13 + v14 * v10.__sinval + v11.__sinval * v13);
      double v28 = v11.__cosval * v13;
      double v19 = v14 * v10.__cosval + v28;
      double v20 = v14 * v10.__cosval + v11.__cosval * v10.__sinval;
      double v21 = v11.__sinval * v10.__cosval + v28;
      double v22 = v11.__sinval * v10.__sinval - v25;
      double v23 = v25 - v27;
      double v24 = v25 - v26;
LABEL_4:
      double v29 = v19 + v22;
      double v30 = v20 + v23;
      double v31 = v24 + v21;
      double v32 = v9.__cosval * v17 - (v9.__sinval * v29 + v12 * v30 + v12 * (v24 + v21));
      double v33 = v9.__sinval * v17;
      double v34 = v12 * v17;
      double v35 = v33 + v9.__cosval * v29;
      double v36 = v34 + v9.__cosval * v30;
      double v37 = v12 * v30 - v12 * v31;
      double v38 = v12 * v29;
      double v39 = v9.__sinval * v31 - v38;
      double v40 = v38 - v9.__sinval * v30;
      double v41 = v35 + v37;
      double v42 = v36 + v39;
      double v43 = v40 + v34 + v9.__cosval * v31;
      goto LABEL_8;
    case 2:
      double v44 = v9.__sinval * v14;
      double v45 = v12 * v14;
      double v46 = v12 * v11.__sinval;
      double v47 = v9.__cosval * v11.__cosval - (v9.__sinval * v14 + v12 * v14 + v12 * v11.__sinval);
      double v48 = v12 * v11.__cosval;
      double v49 = v12 * v11.__cosval + v9.__cosval * v14;
      double v50 = v9.__sinval * v11.__cosval + v9.__cosval * v14 + v45 - v46;
      double v51 = v49 + v9.__sinval * v11.__sinval - v45;
      double v52 = v45 - v44 + v48 + v9.__cosval * v11.__sinval;
      double v53 = v13 * v52;
      double v32 = v10.__cosval * v47 - (v13 * v50 + v10.__sinval * v51 + v13 * v52);
      double v54 = v13 * v47;
      double v55 = v13 * v47 + v10.__cosval * v50;
      double v56 = v10.__sinval * v47 + v10.__cosval * v51;
      double v57 = v54 + v10.__cosval * v52;
      double v58 = v13 * v51;
      double v59 = v58 - v10.__sinval * v52;
      double v60 = v10.__sinval * v50 - v58;
      double v41 = v55 + v59;
      double v42 = v56 + v53 - v13 * v50;
      goto LABEL_7;
    case 3:
      double v61 = v14 * v12;
      double v62 = v11.__cosval * v9.__cosval - (v14 * v9.__sinval + v14 * v12 + v11.__sinval * v12);
      double v63 = v14 * v9.__cosval + v11.__cosval * v12;
      double v64 = v11.__sinval * v9.__cosval + v11.__cosval * v12;
      double v65 = v14 * v9.__cosval + v11.__cosval * v9.__sinval + v11.__sinval * v12 - v14 * v12;
      double v66 = v63 + v61 - v11.__sinval * v9.__sinval;
      double v67 = v14 * v9.__sinval - v61 + v64;
      double v68 = v13 * v67;
      double v32 = v10.__cosval * v62 - (v13 * v65 + v10.__sinval * v66 + v13 * v67);
      double v69 = v13 * v62;
      double v70 = v13 * v62 + v10.__cosval * v65;
      double v71 = v10.__sinval * v62 + v10.__cosval * v66;
      double v57 = v69 + v10.__cosval * v67;
      double v72 = v13 * v66;
      double v73 = v72 - v10.__sinval * v67;
      double v60 = v10.__sinval * v65 - v72;
      double v41 = v70 + v73;
      double v42 = v71 + v68 - v13 * v65;
LABEL_7:
      double v43 = v60 + v57;
LABEL_8:
      a1[1] = v41;
      a1[2] = v42;
      a1[3] = v43;
      goto LABEL_12;
    case 4:
      double v74 = v9.__sinval * v13;
      double v75 = v12 * v10.__sinval;
      double v76 = v12 * v13;
      double v77 = v9.__cosval * v10.__cosval - (v9.__sinval * v13 + v12 * v10.__sinval + v12 * v13);
      double v78 = v12 * v10.__cosval;
      double v79 = v9.__cosval * v13;
      double v80 = v78 + v9.__cosval * v10.__sinval;
      double v81 = v78 + v79;
      double v82 = v9.__sinval * v10.__cosval + v79 + v75 - v76;
      double v83 = v80 + v74 - v76;
      double v84 = v76 - v9.__sinval * v10.__sinval + v81;
      double v85 = v14 * v82;
      double v86 = v14 * v83;
      double v32 = v11.__cosval * v77 - (v14 * v82 + v14 * v83 + v11.__sinval * v84);
      double v87 = v14 * v77 + v11.__cosval * v82;
      double v88 = v14 * v77 + v11.__cosval * v83;
      double v89 = v11.__sinval * v77 + v11.__cosval * v84;
      double v90 = v14 * v84;
      double v91 = v11.__sinval * v83 - v90;
      double v92 = v90 - v11.__sinval * v82;
      double v93 = v85 - v86;
      double v94 = v87 + v91;
      goto LABEL_11;
    case 5:
      double v95 = v13 * v9.__sinval;
      double v96 = v10.__sinval * v12;
      double v97 = v13 * v12;
      double v98 = v10.__cosval * v9.__cosval - (v13 * v9.__sinval + v10.__sinval * v12 + v13 * v12);
      double v99 = v13 * v9.__cosval;
      double v100 = v10.__cosval * v12;
      double v101 = v13 * v9.__cosval + v10.__cosval * v9.__sinval;
      double v102 = v10.__sinval * v9.__cosval + v100;
      double v103 = v99 + v100;
      double v104 = v101 + v97 - v96;
      double v105 = v102 + v97 - v95;
      double v106 = v10.__sinval * v9.__sinval - v97 + v103;
      double v107 = v14 * v104;
      double v108 = v14 * v105;
      double v32 = v11.__cosval * v98 - (v14 * v104 + v14 * v105 + v11.__sinval * v106);
      double v109 = v14 * v98 + v11.__cosval * v104;
      double v88 = v14 * v98 + v11.__cosval * v105;
      double v89 = v11.__sinval * v98 + v11.__cosval * v106;
      double v110 = v14 * v106;
      double v92 = v110 - v11.__sinval * v104;
      double v93 = v107 - v108;
      double v94 = v109 + v11.__sinval * v105 - v110;
LABEL_11:
      a1[1] = v94;
      a1[2] = v88 + v92;
      a1[3] = v93 + v89;
LABEL_12:
      *a1 = v32;
      break;
    default:
      return a1;
  }
  return a1;
}

uint64_t LiCamera::setEulerRotation(uint64_t a1, double *a2, uint64_t a3)
{
  v10[0] = 1.0;
  memset(&v10[1], 0, 24);
  double v5 = *a2;
  double v6 = a2[1];
  double v7 = a2[2];
  int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 648))(a1);
  PCQuat<double>::setEulerAngles(v10, v8, v5, v6, v7);
  return (*(uint64_t (**)(uint64_t, double *, uint64_t))(*(void *)a1 + 392))(a1, v10, a3);
}

uint64_t LiCamera::fit(uint64_t a1, uint64_t a2, double *a3, uint64_t a4, unsigned int a5)
{
  memset(v144, 0, sizeof(v144));
  float64x2_t v143 = 0u;
  float64x2_t v141 = 0u;
  memset(v142, 0, sizeof(v142));
  memset(v140, 0, sizeof(v140));
  memset(v139, 0, sizeof(v139));
  memset(v138, 0, sizeof(v138));
  memset(v137, 0, sizeof(v137));
  (*(void (**)(uint64_t, float64x2_t *, uint64_t, uint64_t))(*(void *)a1 + 136))(a1, v137, a4, 1);
  uint64_t v136 = 0;
  int8x16_t v134 = &unk_1F1118AD8;
  uint64_t v135 = 0;
  PCArray<PCPlane<double>,PCArray_Traits<PCPlane<double>>>::resize((uint64_t)&v134, 1, 3);
  uint64_t v8 = v136 + 48 * SHIDWORD(v135);
  float64x2_t v9 = v137[0];
  *(float64_t *)(v8 - 32) = v137[1].f64[0];
  *(float64x2_t *)(v8 - 48) = v9;
  long long v10 = *(long long *)((char *)&v137[1] + 8);
  *(float64_t *)(v8 - 8) = v137[2].f64[1];
  *(_OWORD *)(v8 - 24) = v10;
  if ((int)v135 <= SHIDWORD(v135)) {
    int v11 = (2 * (HIDWORD(v135) + 1)) | 1;
  }
  else {
    int v11 = v135;
  }
  PCArray<PCPlane<double>,PCArray_Traits<PCPlane<double>>>::resize((uint64_t)&v134, HIDWORD(v135) + 1, v11);
  uint64_t v12 = v136 + 48 * SHIDWORD(v135);
  float64x2_t v13 = v138[0];
  *(float64_t *)(v12 - 32) = v138[1].f64[0];
  *(float64x2_t *)(v12 - 48) = v13;
  long long v14 = *(long long *)((char *)&v138[1] + 8);
  *(float64_t *)(v12 - 8) = v138[2].f64[1];
  *(_OWORD *)(v12 - 24) = v14;
  if ((int)v135 <= SHIDWORD(v135)) {
    int v15 = (2 * (HIDWORD(v135) + 1)) | 1;
  }
  else {
    int v15 = v135;
  }
  PCArray<PCPlane<double>,PCArray_Traits<PCPlane<double>>>::resize((uint64_t)&v134, HIDWORD(v135) + 1, v15);
  uint64_t v16 = v136 + 48 * SHIDWORD(v135);
  float64x2_t v17 = v139[0];
  *(float64_t *)(v16 - 32) = v139[1].f64[0];
  *(float64x2_t *)(v16 - 48) = v17;
  long long v18 = *(long long *)((char *)&v139[1] + 8);
  *(float64_t *)(v16 - 8) = v139[2].f64[1];
  *(_OWORD *)(v16 - 24) = v18;
  if ((int)v135 <= SHIDWORD(v135)) {
    int v19 = (2 * (HIDWORD(v135) + 1)) | 1;
  }
  else {
    int v19 = v135;
  }
  PCArray<PCPlane<double>,PCArray_Traits<PCPlane<double>>>::resize((uint64_t)&v134, HIDWORD(v135) + 1, v19);
  uint64_t v20 = v136 + 48 * SHIDWORD(v135);
  float64x2_t v21 = v140[0];
  *(float64_t *)(v20 - 32) = v140[1].f64[0];
  *(float64x2_t *)(v20 - 48) = v21;
  long long v22 = *(long long *)((char *)&v140[1] + 8);
  *(float64_t *)(v20 - 8) = v140[2].f64[1];
  *(_OWORD *)(v20 - 24) = v22;
  if ((int)v135 <= SHIDWORD(v135)) {
    int v23 = (2 * (HIDWORD(v135) + 1)) | 1;
  }
  else {
    int v23 = v135;
  }
  PCArray<PCPlane<double>,PCArray_Traits<PCPlane<double>>>::resize((uint64_t)&v134, HIDWORD(v135) + 1, v23);
  uint64_t v24 = v136 + 48 * SHIDWORD(v135);
  float64x2_t v25 = v141;
  *(void *)(v24 - 32) = *(void *)&v142[0];
  *(float64x2_t *)(v24 - 48) = v25;
  long long v26 = *(_OWORD *)((char *)v142 + 8);
  *(void *)(v24 - 8) = *((void *)&v142[1] + 1);
  *(_OWORD *)(v24 - 24) = v26;
  if ((int)v135 <= SHIDWORD(v135)) {
    int v27 = (2 * (HIDWORD(v135) + 1)) | 1;
  }
  else {
    int v27 = v135;
  }
  uint64_t v28 = PCArray<PCPlane<double>,PCArray_Traits<PCPlane<double>>>::resize((uint64_t)&v134, HIDWORD(v135) + 1, v27);
  uint64_t v29 = v136 + 48 * SHIDWORD(v135);
  float64x2_t v30 = v143;
  *(void *)(v29 - 32) = *(void *)&v144[0];
  *(float64x2_t *)(v29 - 48) = v30;
  long long v31 = *(_OWORD *)((char *)v144 + 8);
  *(void *)(v29 - 8) = *((void *)&v144[1] + 1);
  *(_OWORD *)(v29 - 24) = v31;
  uint64_t v32 = HIDWORD(v135);
  if (SHIDWORD(v135) >= 1)
  {
    uint64_t v33 = 0;
    do
    {
      if (v33 >= SHIDWORD(v135)) {
        PCArray_base::badIndex((PCArray_base *)v28);
      }
      uint64_t v28 = transformPlane<double>(a3, (double *)(v136 + 48 * v33), v136 + 48 * v33);
      if ((v28 & 1) == 0) {
        goto LABEL_49;
      }
    }
    while (++v33 != v32);
  }
  uint64_t v34 = (*(uint64_t (**)(uint64_t, void **, void))(*(void *)a2 + 104))(a2, &v134, a5);
  if (!v34)
  {
LABEL_49:
    uint64_t v64 = 0;
    goto LABEL_59;
  }
  if ((int)v32 >= 1)
  {
    uint64_t v35 = 0;
    do
    {
      if (v35 >= SHIDWORD(v135)) {
        PCArray_base::badIndex((PCArray_base *)v34);
      }
      uint64_t v34 = inverseTransformPlane<double>(a3, (double *)(v136 + 48 * v35), v136 + 48 * v35);
      if ((v34 & 1) == 0) {
        goto LABEL_49;
      }
    }
    while (++v35 != v32);
  }
  if (SHIDWORD(v135) < 1) {
    PCArray_base::badIndex((PCArray_base *)v34);
  }
  float64x2_t v36 = *(float64x2_t *)v136;
  v137[1].f64[0] = *(float64_t *)(v136 + 16);
  v137[0] = v36;
  float64_t v37 = *(double *)(v136 + 40);
  *(float64x2_t *)((char *)&v137[1] + 8) = *(float64x2_t *)(v136 + 24);
  v137[2].f64[1] = v37;
  if (SHIDWORD(v135) < 2) {
    PCArray_base::badIndex((PCArray_base *)v34);
  }
  float64x2_t v38 = *(float64x2_t *)(v136 + 48);
  v138[1].f64[0] = *(float64_t *)(v136 + 64);
  v138[0] = v38;
  float64_t v39 = *(double *)(v136 + 88);
  *(float64x2_t *)((char *)&v138[1] + 8) = *(float64x2_t *)(v136 + 72);
  v138[2].f64[1] = v39;
  if (SHIDWORD(v135) < 3) {
    PCArray_base::badIndex((PCArray_base *)v34);
  }
  float64x2_t v40 = *(float64x2_t *)(v136 + 96);
  v139[1].f64[0] = *(float64_t *)(v136 + 112);
  v139[0] = v40;
  float64_t v41 = *(double *)(v136 + 136);
  *(float64x2_t *)((char *)&v139[1] + 8) = *(float64x2_t *)(v136 + 120);
  v139[2].f64[1] = v41;
  if (SHIDWORD(v135) < 4) {
    PCArray_base::badIndex((PCArray_base *)v34);
  }
  float64x2_t v42 = *(float64x2_t *)(v136 + 144);
  v140[1].f64[0] = *(float64_t *)(v136 + 160);
  v140[0] = v42;
  float64_t v43 = *(double *)(v136 + 184);
  *(float64x2_t *)((char *)&v140[1] + 8) = *(float64x2_t *)(v136 + 168);
  v140[2].f64[1] = v43;
  if (SHIDWORD(v135) < 5) {
    PCArray_base::badIndex((PCArray_base *)v34);
  }
  float64x2_t v44 = *(float64x2_t *)(v136 + 192);
  *(void *)&v142[0] = *(void *)(v136 + 208);
  float64x2_t v141 = v44;
  uint64_t v45 = *(void *)(v136 + 232);
  *(_OWORD *)((char *)v142 + 8) = *(_OWORD *)(v136 + 216);
  *((void *)&v142[1] + 1) = v45;
  if (SHIDWORD(v135) <= 5) {
    PCArray_base::badIndex((PCArray_base *)v34);
  }
  float64x2_t v46 = *(float64x2_t *)(v136 + 240);
  *(void *)&v144[0] = *(void *)(v136 + 256);
  float64x2_t v143 = v46;
  uint64_t v47 = *(void *)(v136 + 280);
  *(_OWORD *)((char *)v144 + 8) = *(_OWORD *)(v136 + 264);
  *((void *)&v144[1] + 1) = v47;
  (*(void (**)(_OWORD *__return_ptr, uint64_t))(*(void *)a1 + 424))(v133, a1);
  v132[4] = v133[4];
  v132[5] = v133[5];
  v132[6] = v133[6];
  v132[7] = v133[7];
  v132[0] = v133[0];
  v132[1] = v133[1];
  v132[2] = v133[2];
  v132[3] = v133[3];
  if (!PCMatrix44Tmpl<double>::invert((double *)v132, (double *)v132, 0.0)) {
    svdInvert<double>(v132);
  }
  double v48 = (*(double (**)(uint64_t))(*(void *)a1 + 504))(a1);
  float64x2_t v130 = 0uLL;
  double v131 = 0.0;
  if (v48 <= -0.0000001 || v48 >= 0.0000001)
  {
    long long v116 = 0uLL;
    double v117 = 0.0;
    double v113 = 0.0;
    double v114 = 0.0;
    double v115 = 0.0;
    double v110 = 0.0;
    double v111 = 0.0;
    double v112 = 0.0;
    double v107 = 0.0;
    double v108 = 0.0;
    double v109 = 0.0;
    if (!planeIntersection<double>(v137[0].f64, &v137[1].f64[1], v138[0].f64, &v138[1].f64[1], (double *)&v116, &v113))
    {
      exception = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::PCString(v126, "horizontal planes don't meet");
      PCException::PCException(exception, v126);
    }
    if (!planeIntersection<double>(v139[0].f64, &v139[1].f64[1], v140[0].f64, &v140[1].f64[1], &v110, &v107))
    {
      double v87 = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::PCString(v126, "vertical planes don't meet");
      PCException::PCException(v87, v126);
    }
    double v65 = v114 * v109 - v115 * v108;
    double v66 = v115 * v107 - v109 * v113;
    double v67 = v108 * v113 - v114 * v107;
    double v68 = v67 * v67 + v65 * v65 + v66 * v66;
    if (v68 == 0.0)
    {
      double v88 = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::PCString(v126, "intersection lines aren't perpendicular");
      PCException::PCException(v88, v126);
    }
    double v69 = ((v107 * v66 - v108 * v65) * (v112 - v117)
         + (v109 * v65 - v107 * v67) * (v111 - *((double *)&v116 + 1))
         + (v108 * v67 - v109 * v66) * (v110 - *(double *)&v116))
        / v68;
    double v70 = ((v113 * v66 - v114 * v65) * (v112 - v117)
         + (v115 * v65 - v113 * v67) * (v111 - *((double *)&v116 + 1))
         + (v114 * v67 - v115 * v66) * (v110 - *(double *)&v116))
        / v68;
    double v104 = *(double *)&v116 + v113 * v69;
    double v105 = *((double *)&v116 + 1) + v114 * v69;
    double v106 = v117 + v115 * v69;
    double v101 = v107 * v70 + v110;
    double v102 = v108 * v70 + v111;
    double v103 = v109 * v70 + v112;
    double v71 = &v104;
    if (v104 * *((double *)v142 + 1) + *(double *)&v142[1] * v105 + *((double *)&v142[1] + 1) * v106 > v101 * *((double *)v142 + 1) + *(double *)&v142[1] * v102 + *((double *)&v142[1] + 1) * v103) {
      double v71 = &v101;
    }
    float64x2_t v72 = *(float64x2_t *)v71;
    double v131 = v71[2];
    float64x2_t v130 = v72;
    __asm { FMOV            V2.2D, #0.5 }
    *(float64x2_t *)&v126[0].var0 = vmulq_f64(vaddq_f64(v141, v143), _Q2);
    double v127 = (*(double *)v142 + *(double *)v144) * 0.5;
    long long v128 = *(_OWORD *)((char *)v142 + 8);
    float64_t v129 = *((double *)&v142[1] + 1);
    float64x2_t v122 = v72;
    long long v124 = *(_OWORD *)((char *)v142 + 8);
    double v123 = v131;
    float64_t v125 = *((double *)&v142[1] + 1);
    float64x2_t v99 = 0uLL;
    double v100 = 0.0;
    double v74 = PCPlane<double>::intersect((double *)v126, v122.f64, v99.f64);
    if (v75)
    {
      double v76 = (*(double (**)(uint64_t, double))(*(void *)a1 + 320))(a1, v74);
      double v77 = (*(double (**)(uint64_t))(*(void *)a1 + 488))(a1);
      float64x2_t v78 = vsubq_f64(v99, v130);
      (*(void (**)(uint64_t, double))(*(void *)a1 + 496))(a1, v77 * sqrt(vaddvq_f64(vmulq_f64(v78, v78)) + (v100 - v131) * (v100 - v131)) / v76);
    }
    PCMatrix44Tmpl<double>::transform<double>((double *)v132, v130.f64, v130.f64);
    double v79 = (*(double (**)(uint64_t))(*(void *)a1 + 688))(a1);
    long long v118 = 0x3FF0000000000000uLL;
    double v119 = 0.0;
    *(void *)&long long v120 = 0;
    (*(void (**)(uint64_t, long long *))(*(void *)a1 + 472))(a1, &v118);
    (*(void (**)(double *__return_ptr, uint64_t))(*(void *)a1 + 272))(v98, a1);
    int v80 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 632))(a1);
    double v81 = (*(double (**)(uint64_t))(*(void *)a1 + 488))(a1);
    double v82 = LiCamera::adjustTranslationForModel(0, v80, (double *)&v118, &v130, v48, v79, v81, v98[0]);
    (*(void (**)(uint64_t, float64x2_t *, double))(*(void *)a1 + 448))(a1, &v130, v82);
  }
  else
  {
    __asm { FMOV            V3.2D, #0.5 }
    *(float64x2_t *)&v126[0].var0 = vmulq_f64(vaddq_f64(v137[0], v138[0]), _Q3);
    double v127 = (v137[1].f64[0] + v138[1].f64[0]) * 0.5;
    long long v128 = *(long long *)((char *)&v137[1] + 8);
    float64_t v129 = v137[2].f64[1];
    float64x2_t v122 = vmulq_f64(vaddq_f64(v139[0], v140[0]), _Q3);
    double v123 = (v139[1].f64[0] + v140[1].f64[0]) * 0.5;
    float64_t v125 = v139[2].f64[1];
    long long v124 = *(long long *)((char *)&v139[1] + 8);
    (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)a1 + 360))(&v116, a1);
    long long v118 = v116;
    long long v120 = *(_OWORD *)((char *)v142 + 8);
    double v119 = v117;
    uint64_t v121 = *((void *)&v142[1] + 1);
    if (!intersection<double>((double *)v126, v122.f64, (double *)&v118, v130.f64))
    {
      double v86 = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::PCString((PCString *)&v116, "orthographic intersection failed");
      PCException::PCException(v86, (const PCString *)&v116);
    }
    (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)a1 + 304))(&v116, a1);
    double v95 = v138[0].f64[1];
    double v97 = v138[0].f64[0];
    double v94 = v137[0].f64[1];
    float64x2_t v54 = v137[1];
    double v90 = v137[2].f64[0];
    double v92 = v137[0].f64[0];
    double v93 = v137[2].f64[1];
    double v91 = v138[1].f64[0];
    double v55 = v139[0].f64[0];
    double v56 = v140[0].f64[1];
    double v89 = v140[1].f64[0];
    double v57 = v139[0].f64[1];
    float64x2_t v58 = v139[1];
    double v59 = v139[2].f64[0];
    double v60 = v140[0].f64[0];
    double v61 = v139[2].f64[1];
    v63.n128_f64[0] = (*(double (**)(uint64_t))(*(void *)a1 + 488))(a1);
    *(double *)&long long v116 = *(double *)&v116 / v63.n128_f64[0];
    *((double *)&v116 + 1) = *((double *)&v116 + 1) / v63.n128_f64[0];
    double v62 = fabs((v97 - v92) * v54.f64[1] + (v95 - v94) * v90 + (v91 - v54.f64[0]) * v93) / *(double *)&v116;
    v63.n128_f64[0] = fabs((v60 - v55) * v58.f64[1] + (v56 - v57) * v59 + (v89 - v58.f64[0]) * v61)
                    / *((double *)&v116 + 1);
    if (v62 >= v63.n128_f64[0]) {
      v63.n128_f64[0] = v62;
    }
    (*(void (**)(uint64_t, __n128))(*(void *)a1 + 496))(a1, v63);
    PCMatrix44Tmpl<double>::transform<double>((double *)v132, v130.f64, v130.f64);
    (*(void (**)(uint64_t, float64x2_t *))(*(void *)a1 + 448))(a1, &v130);
  }
  uint64_t v64 = 1;
LABEL_59:
  int8x16_t v134 = &unk_1F1118AD8;
  if ((int)v135 < 0) {
    int v83 = 1;
  }
  else {
    int v83 = v135;
  }
  PCArray<PCPlane<double>,PCArray_Traits<PCPlane<double>>>::resize((uint64_t)&v134, 0, v83);
  if (v136) {
    MEMORY[0x1BA9BFB70](v136, 0x1000C8077774924);
  }
  return v64;
}

void sub_1B7A626C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,PCString a57)
{
}

void svdInvert<double>(long long *a1)
{
  v58[0] = 0;
  v58[1] = 0;
  v58[2] = 0x100000001;
  double v59 = 0;
  PCGenMatrix<double>::resize(v58, 4, 4, 1);
  float64x2_t v2 = v59;
  long long v3 = *a1;
  long long v4 = a1[1];
  long long v5 = a1[3];
  v59[2] = a1[2];
  v2[3] = v5;
  long long v6 = a1[7];
  long long v8 = a1[4];
  long long v7 = a1[5];
  v2[6] = a1[6];
  v2[7] = v6;
  v2[4] = v8;
  v2[5] = v7;
  _OWORD *v2 = v3;
  v2[1] = v4;
  v31[0] = 0;
  v31[1] = 0x100000000;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  v31[2] = 0;
  uint64_t v34 = 0x100000001;
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  uint64_t v35 = 0;
  uint64_t v38 = 0x100000001;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0x100000000;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  uint64_t v44 = 0x100000000;
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  int v47 = 0;
  int v48 = 1;
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  uint64_t v51 = 0;
  uint64_t v52 = 0x100000001;
  uint64_t v53 = 0;
  uint64_t v54 = 0;
  uint64_t v55 = 0x100000000;
  uint64_t v56 = 0;
  uint64_t v57 = 0x3F1A36E2EB1C432DLL;
  _svdCall((uint64_t)v31, (uint64_t)v58);
  PCSvd<double>::inverse((uint64_t)v31, v30);
  __n128 v9 = convert<double>((uint64_t)v30, (uint64_t)a1);
  uint64_t v10 = v30[0];
  if (v30[0])
  {
    int v11 = *(_DWORD *)(v30[0] - 4) - 1;
    *(_DWORD *)(v30[0] - 4) = v11;
    if (!v11) {
      MEMORY[0x1BA9BFB70](v10 - 8, 0x1000C8077774924, v9);
    }
  }
  uint64_t v12 = v54;
  if (v54)
  {
    int v13 = *(_DWORD *)(v54 - 4) - 1;
    *(_DWORD *)(v54 - 4) = v13;
    if (!v13)
    {
      MEMORY[0x1BA9BFB70](v12 - 8, 0x1000C8077774924, v9);
      uint64_t v54 = 0;
    }
  }
  uint64_t v14 = v50;
  if (v50)
  {
    int v15 = *(_DWORD *)(v50 - 4) - 1;
    *(_DWORD *)(v50 - 4) = v15;
    if (!v15)
    {
      MEMORY[0x1BA9BFB70](v14 - 8, 0x1000C8077774924, v9);
      uint64_t v50 = 0;
    }
  }
  uint64_t v16 = v46;
  if (v46)
  {
    int v17 = *(_DWORD *)(v46 - 4) - 1;
    *(_DWORD *)(v46 - 4) = v17;
    if (!v17)
    {
      MEMORY[0x1BA9BFB70](v16 - 8, 0x1000C8077774924, v9);
      uint64_t v46 = 0;
    }
  }
  uint64_t v18 = v43;
  if (v43)
  {
    int v19 = *(_DWORD *)(v43 - 4) - 1;
    *(_DWORD *)(v43 - 4) = v19;
    if (!v19)
    {
      MEMORY[0x1BA9BFB70](v18 - 8, 0x1000C8077774924, v9);
      uint64_t v43 = 0;
    }
  }
  uint64_t v20 = v40;
  if (v40)
  {
    int v21 = *(_DWORD *)(v40 - 4) - 1;
    *(_DWORD *)(v40 - 4) = v21;
    if (!v21)
    {
      MEMORY[0x1BA9BFB70](v20 - 8, 0x1000C8077774924, v9);
      uint64_t v40 = 0;
    }
  }
  uint64_t v22 = v36;
  if (v36)
  {
    int v23 = *(_DWORD *)(v36 - 4) - 1;
    *(_DWORD *)(v36 - 4) = v23;
    if (!v23)
    {
      MEMORY[0x1BA9BFB70](v22 - 8, 0x1000C8077774924, v9);
      uint64_t v36 = 0;
    }
  }
  uint64_t v24 = v32;
  if (v32)
  {
    int v25 = *(_DWORD *)(v32 - 4) - 1;
    *(_DWORD *)(v32 - 4) = v25;
    if (!v25)
    {
      MEMORY[0x1BA9BFB70](v24 - 8, 0x1000C8077774924, v9);
      uint64_t v32 = 0;
    }
  }
  uint64_t v26 = v31[0];
  if (v31[0])
  {
    int v27 = *(_DWORD *)(v31[0] - 4) - 1;
    *(_DWORD *)(v31[0] - 4) = v27;
    if (!v27) {
      MEMORY[0x1BA9BFB70](v26 - 8, 0x1000C8077774924, v9);
    }
  }
  uint64_t v28 = v58[0];
  if (v58[0])
  {
    int v29 = *(_DWORD *)(v58[0] - 4) - 1;
    *(_DWORD *)(v58[0] - 4) = v29;
    if (!v29) {
      MEMORY[0x1BA9BFB70](v28 - 8, 0x1000C8077774924, v9);
    }
  }
}

void sub_1B7A62A90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  if (a3)
  {
    int v8 = *(_DWORD *)(a3 - 4) - 1;
    *(_DWORD *)(a3 - 4) = v8;
    if (!v8) {
      MEMORY[0x1BA9BFB70](a3 - 8, 0x1000C8077774924);
    }
  }
  PCSvd<double>::~PCSvd((uint64_t *)va);
  uint64_t v9 = *(void *)(v6 - 80);
  if (v9)
  {
    int v10 = *(_DWORD *)(v9 - 4) - 1;
    *(_DWORD *)(v9 - 4) = v10;
    if (!v10) {
      MEMORY[0x1BA9BFB70](v9 - 8, 0x1000C8077774924);
    }
  }
  _Unwind_Resume(a1);
}

BOOL intersection<double>(double *a1, double *a2, double *a3, double *a4)
{
  double v18 = 0.0;
  double v19 = 0.0;
  double v20 = 0.0;
  double v15 = 0.0;
  double v16 = 0.0;
  double v17 = 0.0;
  BOOL result = planeIntersection<double>(a1, a1 + 3, a2, a2 + 3, &v18, &v15);
  if (result)
  {
    double v8 = a3[3];
    double v7 = a3[4];
    double v9 = a3[5];
    double v10 = v8 * v15 + v7 * v16 + v9 * v17;
    if (v10 == 0.0)
    {
      return 0;
    }
    else
    {
      double v11 = (v8 * (*a3 - v18) + v7 * (a3[1] - v19) + v9 * (a3[2] - v20)) / v10;
      double v12 = v18 + v15 * v11;
      double v13 = v19 + v16 * v11;
      double v14 = v20 + v17 * v11;
      *a4 = v12;
      a4[1] = v13;
      a4[2] = v14;
      return 1;
    }
  }
  return result;
}

uint64_t PCArray<PCPlane<double>,PCArray_Traits<PCPlane<double>>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F1118AD8;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<PCPlane<double>,PCArray_Traits<PCPlane<double>>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

uint64_t LiCamera::update(LiCamera *this)
{
  return 0;
}

uint64_t LiCamera::replacement(LiCamera *this)
{
  return 0;
}

uint64_t LiCamera::isAnimating(LiCamera *this)
{
  return 0;
}

BOOL LiCamera::isOkay(LiCamera *this)
{
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  (*(void (**)(LiCamera *, uint64_t *))(*(void *)this + 440))(this, &v9);
  if ((v9 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
    return 0;
  }
  if ((v10 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
    return 0;
  }
  if ((v11 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL) {
    return 0;
  }
  uint64_t v5 = 0x3FF0000000000000;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  (*(void (**)(LiCamera *, uint64_t *))(*(void *)this + 472))(this, &v5);
  if ((v5 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || (v6 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || (v7 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || (v8 & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
  {
    return 0;
  }
  double v2 = (*(double (**)(LiCamera *))(*(void *)this + 504))(this);
  return v2 >= 0.0 && (*(void *)&v2 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
}

void LiCamera::print(uint64_t a1, void *a2, int a3)
{
  LiImageSource::printIndent(a2, a3);
  int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 632))(a1);
  if (v6)
  {
    if (v6 == 1)
    {
      uint64_t v7 = "Frame";
      uint64_t v8 = a2;
      uint64_t v9 = 5;
    }
    else
    {
      uint64_t v7 = "Unknown-model";
      uint64_t v8 = a2;
      uint64_t v9 = 13;
    }
  }
  else
  {
    uint64_t v7 = "Viewpoint";
    uint64_t v8 = a2;
    uint64_t v9 = 9;
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)v7, v9);
  double v10 = (*(double (**)(uint64_t))(*(void *)a1 + 504))(a1);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)" camera: aov=", 13);
  uint64_t v11 = (void *)std::ostream::operator<<();
  double v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)" ", 1);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" focal=", 7);
  (*(void (**)(uint64_t))(*(void *)a1 + 320))(a1);
  double v13 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)" ", 1);
  if (v10 != 0.0)
  {
    double v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)" cop=", 5);
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a1 + 336))(&v25, a1);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"[", 1);
    double v15 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)",", 1);
    double v16 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)",", 1);
    double v17 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)"]", 1);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)" ", 1);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 536))(a1);
  v18.n128_f64[0] = (*(double (**)(uint64_t))(*(void *)a1 + 576))(a1);
  double v19 = (*(double (**)(uint64_t, __n128))(*(void *)a1 + 552))(a1, v18);
  double v20 = (*(double (**)(uint64_t))(*(void *)a1 + 592))(a1);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"near=", 5);
  std::ostream::operator<<();
  if (v19 > 0.0)
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"/", 1);
    std::ostream::operator<<();
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)" ", 1);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"far=", 4);
  std::ostream::operator<<();
  if (v20 > 0.0)
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"/", 1);
    std::ostream::operator<<();
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)" ", 1);
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a1 + 272))(&v24, a1);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"filmback=[", 10);
  int v21 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)", ", 2);
  uint64_t v22 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)"]\n", 2);
  (*(void (**)(void *__return_ptr, uint64_t))(*(void *)a1 + 16))(v23, a1);
  PCMatrix44Tmpl<double>::print((uint64_t)v23, a2, a3 + 2);
}

void PCMatrix44Tmpl<double>::print(uint64_t a1, void *a2, int a3)
{
  PCMatrix44Tmpl<double>::format(a1, a3, (PCSharedCount *)&v7);
  long long v4 = PCString::createCStr(&v7);
  uint64_t v5 = v4;
  if (v4)
  {
    size_t v6 = strlen(v4);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)v5, v6);
    free(v5);
  }
  PCString::~PCString(&v7);
}

void sub_1B7A63328(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void LiSimpleCamera::LiSimpleCamera(LiSimpleCamera *this, uint64_t *a2)
{
  uint64_t v3 = a2[3];
  *(void *)this = v3;
  *(void *)((char *)this + *(void *)(v3 - 24)) = a2[4];
  uint64_t v4 = a2[2];
  *(void *)this = v4;
  *(void *)((char *)this + *(void *)(v4 - 24)) = a2[5];
  uint64_t v5 = a2[1];
  *(void *)this = v5;
  *(void *)((char *)this + *(void *)(v5 - 24)) = a2[6];
  uint64_t v6 = *a2;
  *(void *)this = *a2;
  *(void *)((char *)this + *(void *)(v6 - 24)) = a2[7];
  *((_DWORD *)this + 2) = 1;
  LiTransform::LiTransform((LiSimpleCamera *)((char *)this + 16));
  *((void *)this + 28) = 0x3FF0000000000000;
  *((void *)this + 29) = 0;
  *((void *)this + 30) = 0;
  *((void *)this + 31) = 0;
  *((void *)this + 42) = 0x3FF0000000000000;
  *((void *)this + 37) = 0x3FF0000000000000;
  *((void *)this + 32) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *((void *)this + 47) = 0x3FF0000000000000;
  *((void *)this + 48) = 0x4046800000000000;
  *((unsigned char *)this + 392) = 1;
  *((_OWORD *)this + 25) = xmmword_1B837B590;
  *((void *)this + 52) = 0;
  *((void *)this + 53) = 0;
  *((_OWORD *)this + 27) = xmmword_1B837B5A0;
  *((void *)this + 56) = 0x3FF0000000000000;
  *((_WORD *)this + 228) = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  (*(void (**)(LiSimpleCamera *, uint64_t *))(*(void *)this + 448))(this, &v7);
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  (*(void (**)(LiSimpleCamera *, uint64_t *))(*(void *)this + 400))(this, &v7);
}

void sub_1B7A63668(_Unwind_Exception *a1, const PCString *a2)
{
  OZChannelBase::setRangeName(v2, a2);
  _Unwind_Resume(a1);
}

void LiSimpleCamera::LiSimpleCamera(LiSimpleCamera *this)
{
  *((unsigned char *)this + 480) = 1;
  *(void *)this = &unk_1F1118718;
  *((void *)this + 58) = &unk_1F1118A38;
  *((void *)this + 59) = 0;
  *((_DWORD *)this + 2) = 1;
  LiTransform::LiTransform((LiSimpleCamera *)((char *)this + 16));
  *((void *)this + 28) = 0x3FF0000000000000;
  *((void *)this + 29) = 0;
  *((void *)this + 30) = 0;
  *((void *)this + 31) = 0;
  *((void *)this + 42) = 0x3FF0000000000000;
  *((void *)this + 37) = 0x3FF0000000000000;
  *((void *)this + 32) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *((void *)this + 47) = 0x3FF0000000000000;
  *((void *)this + 48) = 0x4046800000000000;
  *((unsigned char *)this + 392) = 1;
  *((_OWORD *)this + 25) = xmmword_1B837B590;
  *((void *)this + 52) = 0;
  *((void *)this + 53) = 0;
  *((_OWORD *)this + 27) = xmmword_1B837B5A0;
  *((void *)this + 56) = 0x3FF0000000000000;
  *((_WORD *)this + 228) = 0;
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  (*(void (**)(LiSimpleCamera *, uint64_t *))(*(void *)this + 448))(this, &v2);
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  (*(void (**)(LiSimpleCamera *, uint64_t *))(*(void *)this + 400))(this, &v2);
}

void sub_1B7A637F4(_Unwind_Exception *a1, const PCString *a2)
{
  OZChannelBase::setRangeName(v3, a2);
  *(void *)(v2 + 464) = &unk_1F1199AC8;
  *(unsigned char *)(v2 + 480) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v2 + 472));
  _Unwind_Resume(a1);
}

void LiSimpleCamera::~LiSimpleCamera(LiSimpleCamera *this, const PCString *a2)
{
  v2.var0 = a2->var0;
  *(PCString *)this = (PCString)a2->var0;
  *(PCString *)((char *)this + v2.var0[-1].info) = a2[7];
  OZChannelBase::setRangeName((OZChannelBase *)((char *)this + 16), a2);
}

{
  *(void *)this = &unk_1F1118718;
  *((void *)this + 58) = &unk_1F1118A38;
  OZChannelBase::setRangeName((OZChannelBase *)((char *)this + 16), a2);
  *((void *)this + 58) = &unk_1F1199AC8;
  *((unsigned char *)this + 480) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)this + 59);
}

{
  uint64_t vars8;

  LiSimpleCamera::~LiSimpleCamera(this, a2);

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'LiSimpleCamera::~LiSimpleCamera(LiSimpleCamera *this, const PCString *a2)
{
}

{
  uint64_t vars8;

  LiSimpleCamera::~LiSimpleCamera((LiSimpleCamera *)((char *)this + *(void *)(*(void *)this - 24)), a2);

  JUMPOUT(0x1BA9BFBA0);
}

__n128 LiSimpleCamera::getFilmback@<Q0>(__n128 *this@<X0>, __n128 *a2@<X8>)
{
  __n128 result = this[27];
  *a2 = result;
  return result;
}

__n128 LiSimpleCamera::setFilmback(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[27] = *a2;
  return result;
}

__n128 LiSimpleCamera::getParentTransform@<Q0>(LiSimpleCamera *this@<X0>, uint64_t a2@<X8>)
{
  long long v2 = *((_OWORD *)this + 21);
  *(_OWORD *)(a2 + 64) = *((_OWORD *)this + 20);
  *(_OWORD *)(a2 + 80) = v2;
  long long v3 = *((_OWORD *)this + 23);
  *(_OWORD *)(a2 + 96) = *((_OWORD *)this + 22);
  *(_OWORD *)(a2 + 112) = v3;
  long long v4 = *((_OWORD *)this + 17);
  *(_OWORD *)a2 = *((_OWORD *)this + 16);
  *(_OWORD *)(a2 + 16) = v4;
  __n128 result = *((__n128 *)this + 18);
  long long v6 = *((_OWORD *)this + 19);
  *(__n128 *)(a2 + 32) = result;
  *(_OWORD *)(a2 + 48) = v6;
  return result;
}

uint64_t LiSimpleCamera::setParentTransform(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result + 256;
  if (result + 256 != a2)
  {
    for (uint64_t i = 0; i != 4; ++i)
    {
      for (uint64_t j = 0; j != 32; j += 8)
        *(void *)(v2 + j) = *(void *)(a2 + j);
      v2 += 32;
      a2 += 32;
    }
  }
  return result;
}

__n128 LiSimpleCamera::getTranslation(__n128 *a1, __n128 *a2)
{
  __n128 result = a1[1];
  a2[1].n128_u64[0] = a1[2].n128_u64[0];
  *a2 = result;
  return result;
}

__n128 LiSimpleCamera::setTranslation(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[2].n128_u64[0] = a2[1].n128_u64[0];
  a1[1] = result;
  return result;
}

__n128 LiSimpleCamera::getPivot(uint64_t a1, __n128 *a2)
{
  __n128 result = *(__n128 *)(a1 + 232);
  a2[1].n128_u64[0] = *(void *)(a1 + 248);
  *a2 = result;
  return result;
}

__n128 LiSimpleCamera::setPivot(uint64_t a1, __n128 *a2)
{
  __n128 result = *a2;
  *(void *)(a1 + 248) = a2[1].n128_u64[0];
  *(__n128 *)(a1 + 232) = result;
  return result;
}

__n128 LiSimpleCamera::getRotation(uint64_t a1, uint64_t a2)
{
  if (a1 + 64 != a2)
  {
    *(void *)a2 = *(void *)(a1 + 64);
    __n128 result = *(__n128 *)(a1 + 72);
    *(void *)(a2 + 24) = *(void *)(a1 + 88);
    *(__n128 *)(a2 + 8) = result;
  }
  return result;
}

__n128 LiSimpleCamera::setRotation(uint64_t a1, uint64_t a2)
{
  if (a1 + 64 != a2)
  {
    *(void *)(a1 + 64) = *(void *)a2;
    __n128 result = *(__n128 *)(a2 + 8);
    *(void *)(a1 + 88) = *(void *)(a2 + 24);
    *(__n128 *)(a1 + 72) = result;
  }
  return result;
}

double LiSimpleCamera::getScale(LiSimpleCamera *this)
{
  return *((double *)this + 28);
}

uint64_t LiSimpleCamera::setScale(uint64_t this, double a2)
{
  *(double *)(this + 224) = a2;
  return this;
}

double LiSimpleCamera::getAngleOfView(LiSimpleCamera *this)
{
  return *((double *)this + 48);
}

uint64_t LiSimpleCamera::setAngleOfView(uint64_t this, double a2)
{
  *(double *)(this + 384) = a2;
  return this;
}

uint64_t LiSimpleCamera::getNiceAngleOfView(LiSimpleCamera *this)
{
  return *((unsigned __int8 *)this + 392);
}

uint64_t LiSimpleCamera::setNiceAngleOfView(uint64_t this, char a2)
{
  *(unsigned char *)(this + 392) = a2;
  return this;
}

double LiSimpleCamera::getNearPlane(LiSimpleCamera *this)
{
  return *((double *)this + 50);
}

uint64_t LiSimpleCamera::setNearPlane(uint64_t this, double a2)
{
  *(double *)(this + 400) = a2;
  return this;
}

double LiSimpleCamera::getNearPlaneFade(LiSimpleCamera *this)
{
  return *((double *)this + 52);
}

uint64_t LiSimpleCamera::setNearPlaneFade(uint64_t this, double a2)
{
  *(double *)(this + 416) = a2;
  return this;
}

double LiSimpleCamera::getFarPlane(LiSimpleCamera *this)
{
  return *((double *)this + 51);
}

uint64_t LiSimpleCamera::setFarPlane(uint64_t this, double a2)
{
  *(double *)(this + 408) = a2;
  return this;
}

double LiSimpleCamera::getFarPlaneFade(LiSimpleCamera *this)
{
  return *((double *)this + 53);
}

uint64_t LiSimpleCamera::setFarPlaneFade(uint64_t this, double a2)
{
  *(double *)(this + 424) = a2;
  return this;
}

uint64_t LiSimpleCamera::getNearFadePoints(uint64_t a1, uint64_t a2, float64x2_t *a3)
{
  memset(v15, 0, sizeof(v15));
  uint64_t v6 = (*(uint64_t (**)(uint64_t, _OWORD *))(*(void *)a1 + 96))(a1, v15);
  if (v6)
  {
    double v7 = (*(double (**)(uint64_t))(*(void *)a1 + 552))(a1);
    if (v7 >= 1.0) {
      double v8 = v7;
    }
    else {
      double v8 = 1.0;
    }
    float64x2_t v9 = (float64x2_t)v15[0];
    float64x2_t v10 = *(float64x2_t *)((char *)&v15[1] + 8);
    double v11 = *((double *)&v15[2] + 1);
    double v12 = sqrt(vaddvq_f64(vmulq_f64(v10, v10)) + v11 * v11);
    if (v12 <= -0.000000100000001 || v12 >= 0.000000100000001)
    {
      float64x2_t v10 = vdivq_f64(*(float64x2_t *)((char *)&v15[1] + 8), (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v12, 0));
      double v11 = *((double *)&v15[2] + 1) / v12;
    }
    double v13 = *(double *)&v15[1] + v8 * v11;
    *(_OWORD *)a2 = v15[0];
    *(void *)(a2 + 16) = *(void *)&v15[1];
    *a3 = vaddq_f64(v9, vmulq_n_f64(v10, v8));
    a3[1].f64[0] = v13;
  }
  return v6;
}

uint64_t LiSimpleCamera::getFarFadePoints(uint64_t a1, uint64_t a2, float64x2_t *a3)
{
  memset(v15, 0, sizeof(v15));
  uint64_t v6 = (*(uint64_t (**)(uint64_t, _OWORD *))(*(void *)a1 + 104))(a1, v15);
  if (v6)
  {
    double v7 = (*(double (**)(uint64_t))(*(void *)a1 + 592))(a1);
    if (v7 >= 1.0) {
      double v8 = v7;
    }
    else {
      double v8 = 1.0;
    }
    float64x2_t v9 = (float64x2_t)v15[0];
    float64x2_t v10 = *(float64x2_t *)((char *)&v15[1] + 8);
    double v11 = *((double *)&v15[2] + 1);
    double v12 = sqrt(vaddvq_f64(vmulq_f64(v10, v10)) + v11 * v11);
    if (v12 <= -0.000000100000001 || v12 >= 0.000000100000001)
    {
      float64x2_t v10 = vdivq_f64(*(float64x2_t *)((char *)&v15[1] + 8), (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v12, 0));
      double v11 = *((double *)&v15[2] + 1) / v12;
    }
    double v13 = *(double *)&v15[1] + v8 * v11;
    *(_OWORD *)a2 = v15[0];
    *(void *)(a2 + 16) = *(void *)&v15[1];
    *a3 = vaddq_f64(v9, vmulq_n_f64(v10, v8));
    a3[1].f64[0] = v13;
  }
  return v6;
}

uint64_t LiSimpleCamera::setFarCrop(uint64_t this, char a2)
{
  *(unsigned char *)(this + 457) = a2;
  return this;
}

uint64_t LiSimpleCamera::getFarCrop(LiSimpleCamera *this)
{
  return *((unsigned __int8 *)this + 457);
}

uint64_t LiSimpleCamera::getCameraModel(LiSimpleCamera *this)
{
  return *((unsigned int *)this + 2);
}

uint64_t LiSimpleCamera::setCameraModel(uint64_t result, int a2)
{
  *(_DWORD *)(result + 8) = a2;
  return result;
}

uint64_t LiSimpleCamera::getRotationOrder(LiSimpleCamera *this)
{
  return 4;
}

uint64_t LiSimpleCamera::set(LiSimpleCamera *this, const LiCamera *a2)
{
  v9[0] = 0x3FF0000000000000;
  memset(&v9[1], 0, 24);
  (*(void (**)(const LiCamera *, char *))(*(void *)a2 + 440))(a2, (char *)this + 16);
  (*(void (**)(const LiCamera *, void *))(*(void *)a2 + 472))(a2, v9);
  (*(void (**)(LiSimpleCamera *, void *))(*(void *)this + 480))(this, v9);
  (*(void (**)(_OWORD *__return_ptr, const LiCamera *))(*(void *)a2 + 424))(v8, a2);
  if (v8 != (_OWORD *)((char *)this + 256))
  {
    for (uint64_t i = 0; i != 8; i += 2)
    {
      uint64_t v5 = (_OWORD *)((char *)this + i * 16 + 256);
      long long v6 = v8[i + 1];
      _OWORD *v5 = v8[i];
      v5[1] = v6;
    }
  }
  *((double *)this + 28) = (*(double (**)(const LiCamera *))(*(void *)a2 + 488))(a2);
  (*(void (**)(const LiCamera *, char *))(*(void *)a2 + 456))(a2, (char *)this + 232);
  *((_DWORD *)this + 2) = (*(uint64_t (**)(const LiCamera *))(*(void *)a2 + 632))(a2);
  *((double *)this + 48) = (*(double (**)(const LiCamera *))(*(void *)a2 + 504))(a2);
  *((double *)this + 50) = (*(double (**)(const LiCamera *))(*(void *)a2 + 536))(a2);
  *((double *)this + 51) = (*(double (**)(const LiCamera *))(*(void *)a2 + 576))(a2);
  *((double *)this + 52) = (*(double (**)(const LiCamera *))(*(void *)a2 + 552))(a2);
  *((double *)this + 53) = (*(double (**)(const LiCamera *))(*(void *)a2 + 592))(a2);
  (*(void (**)(_OWORD *__return_ptr, const LiCamera *))(*(void *)a2 + 272))(v8, a2);
  *((_OWORD *)this + 27) = v8[0];
  *((unsigned char *)this + 456) = (*(uint64_t (**)(const LiCamera *))(*(void *)a2 + 664))(a2);
  uint64_t result = (*(uint64_t (**)(const LiCamera *))(*(void *)a2 + 624))(a2);
  *((unsigned char *)this + 457) = result;
  return result;
}

double LiSimpleCamera::getPixelAspectRatio(LiSimpleCamera *this)
{
  return *((double *)this + 56);
}

uint64_t LiSimpleCamera::setPixelAspectRatio(uint64_t this, double a2)
{
  *(double *)(this + 448) = a2;
  return this;
}

uint64_t LiSimpleCamera::getCrop(LiSimpleCamera *this)
{
  return *((unsigned __int8 *)this + 456);
}

uint64_t LiSimpleCamera::setCrop(uint64_t this, char a2)
{
  *(unsigned char *)(this + 456) = a2;
  return this;
}

double LiAnimCamera::getTime(LiAnimCamera *this)
{
  PCTime::PCTime((PCTime *)&v12);
  gettimeofday(&v12, 0);
  __darwin_suseconds_t tv_usec = v12.tv_usec;
  __darwin_suseconds_t v5 = *((_DWORD *)this + 118);
  BOOL v6 = v12.tv_usec < v5;
  if (v12.tv_usec < v5) {
    __darwin_suseconds_t tv_usec = v12.tv_usec + 1000000;
  }
  v12.__darwin_suseconds_t tv_usec = tv_usec - v5;
  v12.tv_sec = v12.tv_sec - v6 - *((void *)this + 58);
  double v7 = ((double)(tv_usec - v5) / 1000000.0 + (double)v12.tv_sec) / *((double *)this + 60);
  double v11 = v7;
  if (v7 < 1.0)
  {
    double v8 = 0.0;
    if (*((unsigned char *)this + 536)) {
      double v9 = 1.0;
    }
    else {
      double v9 = 0.0;
    }
    if (*((unsigned char *)this + 537)) {
      double v8 = 1.0;
    }
    PCMath::easeInOut(&v11, v7, v9, v8, 0.0, 1.0, 0, v3);
    double v7 = v11;
  }
  OZChannelBase::setRangeName((OZChannelBase *)&v12, v2);
  return v7;
}

void sub_1B7A64360(_Unwind_Exception *a1, const PCString *a2, OZChannelBase *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

double LiCamera::getCropFraction(LiCamera *this)
{
  int v1 = (*(uint64_t (**)(LiCamera *))(*(void *)this + 664))(this);
  double result = 0.0;
  if (v1) {
    return 1.0;
  }
  return result;
}

BOOL transformPlane<double>(_OWORD *a1, double *a2, uint64_t a3)
{
  double v4 = a2[4];
  double v5 = a2[5];
  double v6 = -(a2[3] * *a2 + v4 * a2[1] + v5 * a2[2]);
  v14.f64[0] = a2[3];
  v14.f64[1] = v4;
  double v15 = v5;
  double v16 = v6;
  long long v7 = a1[5];
  double v13[4] = a1[4];
  v13[5] = v7;
  long long v8 = a1[7];
  v13[6] = a1[6];
  v13[7] = v8;
  long long v9 = a1[1];
  v13[0] = *a1;
  v13[1] = v9;
  long long v10 = a1[3];
  double v13[2] = a1[2];
  void v13[3] = v10;
  BOOL v11 = PCMatrix44Tmpl<double>::invert((double *)v13, (double *)v13, 0.0);
  if (v11)
  {
    PCMatrix44Tmpl<double>::transform_row<double>((double *)v13, v14.f64, v14.f64);
    PCPlane<double>::setImplicit(a3, &v14);
  }
  return v11;
}

double PCMatrix44Tmpl<double>::setFramePerspective(uint64_t a1, double a2, double a3, double a4, double a5, double a6, double a7)
{
  double v13 = a3 * 0.5;
  double v14 = tan(a4 * 3.14159265 / 360.0);
  if (v14 > 0.0 && v13 / v14 - a7 < a5) {
    a5 = v13 / v14 - a7;
  }
  *(double *)a1 = 2.0 / a2;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(double *)(a1 + 40) = 2.0 / a3;
  double v15 = v13 * (a5 + a6);
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(double *)(a1 + 80) = (v14 * (a5 - a6) - (v13 + v13)) / v15;
  *(double *)(a1 + 88) = (v13 * a5 - v13 * a6 + v14 * ((a6 + a6) * a5)) / v15;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  double result = -v14 / v13;
  *(double *)(a1 + 112) = result;
  *(void *)(a1 + 120) = 0x3FF0000000000000;
  return result;
}

void PCArray<PCPlane<double>,PCArray_Traits<PCPlane<double>>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F1118AD8;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<PCPlane<double>,PCArray_Traits<PCPlane<double>>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t PCArray<PCPlane<double>,PCArray_Traits<PCPlane<double>>>::resize(uint64_t result, int a2, int a3)
{
  if (a3 <= a2) {
    int v3 = a2;
  }
  else {
    int v3 = a3;
  }
  if (a2 < 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v17, "PCArray::resize");
    PCException::PCException(exception, &v17);
    *(void *)exception = &unk_1F1199218;
  }
  uint64_t v5 = result;
  if (v3 == *(_DWORD *)(result + 8))
  {
    uint64_t v6 = *(int *)(result + 12);
    if ((int)v6 < a2)
    {
      uint64_t v7 = 48 * v6;
      uint64_t v8 = a2 - v6;
      do
      {
        long long v9 = (_OWORD *)(*(void *)(result + 16) + v7);
        v9[1] = 0uLL;
        void v9[2] = 0uLL;
        _OWORD *v9 = 0uLL;
        v7 += 48;
        --v8;
      }
      while (v8);
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    int v10 = *(_DWORD *)(result + 12);
    if (a2 >= v10) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = a2;
    }
    if ((int)v11 < 1)
    {
      LODWORD(v11) = 0;
    }
    else
    {
      timeval v12 = (long long *)(*(void *)(result + 16) + 32);
      uint64_t v13 = 32;
      uint64_t v14 = v11;
      do
      {
        *(_OWORD *)(v13 - 32) = *(v12 - 2);
        *(_OWORD *)(v13 - 16) = *(v12 - 1);
        long long v15 = *v12;
        v12 += 3;
        *(_OWORD *)uint64_t v13 = v15;
        v13 += 48;
        --v14;
      }
      while (v14);
    }
    if ((int)v11 > v10) {
      int v10 = v11;
    }
    if (v10 < a2) {
      bzero((void *)(48 * v10), 48 * (~v10 + a2) + 48);
    }
    double result = *(void *)(v5 + 16);
    if (result) {
      double result = MEMORY[0x1BA9BFB70](result, 0x1000C8077774924);
    }
    *(void *)(v5 + 16) = 0;
  }
  *(_DWORD *)(v5 + 8) = v3;
  *(_DWORD *)(v5 + 12) = a2;
  return result;
}

void sub_1B7A647E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

uint64_t inverseTransformPlane<double>(double *a1, double *a2, uint64_t a3)
{
  double v4 = a2[4];
  double v5 = a2[5];
  double v6 = -(a2[3] * *a2 + v4 * a2[1] + v5 * a2[2]);
  v8.f64[0] = a2[3];
  v8.f64[1] = v4;
  double v9 = v5;
  double v10 = v6;
  PCMatrix44Tmpl<double>::transform_row<double>(a1, v8.f64, v8.f64);
  PCPlane<double>::setImplicit(a3, &v8);
  return 1;
}

__n128 convert<double>(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 12) != 4 || *(_DWORD *)(a1 + 8) != 4)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v16, "from.cols() == 4 && from.rows() == 4");
    PCException::PCException(exception, &v16);
    *(void *)exception = &unk_1F1199218;
  }
  uint64_t v3 = a2;
  if (*(_DWORD *)(a1 + 20) == 1 && *(_DWORD *)(a1 + 16) == 4)
  {
    double v9 = *(long long **)(a1 + 24);
    long long v10 = *v9;
    long long v11 = v9[1];
    long long v12 = v9[3];
    *(_OWORD *)(a2 + 32) = v9[2];
    *(_OWORD *)(a2 + 48) = v12;
    *(_OWORD *)a2 = v10;
    *(_OWORD *)(a2 + 16) = v11;
    __n128 result = (__n128)v9[4];
    long long v13 = v9[5];
    long long v14 = v9[7];
    *(_OWORD *)(a2 + 96) = v9[6];
    *(_OWORD *)(a2 + 112) = v14;
    *(__n128 *)(a2 + 64) = result;
    *(_OWORD *)(a2 + 80) = v13;
  }
  else
  {
    for (uint64_t i = 0; i != 4; ++i)
    {
      for (uint64_t j = 0; j != 4; ++j)
      {
        PCGenMatrix<double>::checkColIndex(a1, j);
        PCGenMatrix<double>::checkRowIndex(a1, i);
        result.n128_u64[0] = *(void *)(*(void *)(a1 + 24)
                                       + 8 * (*(_DWORD *)(a1 + 20) * (int)j + *(_DWORD *)(a1 + 16) * (int)i));
        *(void *)(v3 + 8 * j) = result.n128_u64[0];
      }
      v3 += 32;
    }
  }
  return result;
}

void sub_1B7A649BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

uint64_t PCSvd<double>::inverse@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  int v4 = *(_DWORD *)(a1 + 68);
  PCGenMatrix<double>::PCGenMatrix(&v63, v4, v4, 0, 0.0);
  if (v4 >= 1)
  {
    uint64_t v5 = 0;
    while (1)
    {
      double v6 = (double *)PCGenVector<double>::operator()(a1 + 88, v5);
      double v7 = *v6;
      if (fabs(*v6) >= *(double *)(a1 + 216)) {
        break;
      }
LABEL_26:
      uint64_t v5 = (v5 + 1);
      if (v5 == v4) {
        goto LABEL_27;
      }
    }
    PCGenMatrix<double>::col(a1 + 56, v5, (uint64_t)&v56);
    unsigned int v8 = v57;
    PCGenBlockRef<double>::PCGenBlockRef(&v60, v57);
    uint64_t v61 = v8 | 0x100000000;
    long long v10 = v59;
    double v9 = v60;
    double v62 = v60;
    uint64_t v11 = v57;
    if (v58 == 1)
    {
      if (v57 >= 1)
      {
        do
        {
          double v12 = *v10++;
          *v9++ = v12 / v7;
          --v11;
        }
        while (v11);
      }
    }
    else if (v57 >= 1)
    {
      uint64_t v13 = 8 * v58;
      do
      {
        *v9++ = *v10 / v7;
        long long v10 = (double *)((char *)v10 + v13);
        --v11;
      }
      while (v11);
    }
    PCGenMatrix<double>::col((uint64_t)&v63, v5, (uint64_t)v54);
    v54[1] = v61;
    long long v14 = v60;
    uint64_t v15 = v54[0];
    if ((double *)v54[0] == v60)
    {
      uint64_t v55 = v62;
      if (!v60)
      {
LABEL_20:
        __n128 v18 = v60;
        if (v60)
        {
          int v19 = *((_DWORD *)v60 - 1) - 1;
          *((_DWORD *)v60 - 1) = v19;
          if (!v19)
          {
            MEMORY[0x1BA9BFB70](v18 - 1, 0x1000C8077774924);
            double v60 = 0;
          }
        }
        uint64_t v20 = v56;
        if (v56)
        {
          int v21 = *(_DWORD *)(v56 - 4) - 1;
          *(_DWORD *)(v56 - 4) = v21;
          if (!v21) {
            MEMORY[0x1BA9BFB70](v20 - 8, 0x1000C8077774924);
          }
        }
        goto LABEL_26;
      }
    }
    else
    {
      if (v54[0])
      {
        int v16 = *(_DWORD *)(v54[0] - 4) - 1;
        *(_DWORD *)(v54[0] - 4) = v16;
        if (!v16) {
          MEMORY[0x1BA9BFB70](v15 - 8, 0x1000C8077774924);
        }
      }
      v54[0] = v14;
      if (!v14) {
        goto LABEL_20;
      }
      ++*((_DWORD *)v14 - 1);
      uint64_t v55 = v62;
    }
    int v17 = *((_DWORD *)v14 - 1) - 1;
    *((_DWORD *)v14 - 1) = v17;
    if (!v17) {
      MEMORY[0x1BA9BFB70](v14 - 1, 0x1000C8077774924);
    }
    goto LABEL_20;
  }
LABEL_27:
  uint64_t v22 = *(void *)(a1 + 24);
  if (v22)
  {
    int v23 = *(_DWORD *)(v22 - 4);
    *(_DWORD *)(v22 - 4) = v23 + 1;
    int v24 = *(_DWORD *)(a1 + 32);
    int v26 = *(_DWORD *)(a1 + 40);
    int v25 = *(_DWORD *)(a1 + 44);
    int v27 = *(double **)(a1 + 48);
    *(_DWORD *)(v22 - 4) = v23 + 2;
  }
  else
  {
    int v24 = *(_DWORD *)(a1 + 32);
    int v26 = *(_DWORD *)(a1 + 40);
    int v25 = *(_DWORD *)(a1 + 44);
    int v27 = *(double **)(a1 + 48);
  }
  int v28 = v64;
  uint64_t result = (uint64_t)PCGenBlockRef<double>::PCGenBlockRef(a2, v64 * v24);
  *((_DWORD *)a2 + 2) = v28;
  *((_DWORD *)a2 + 3) = v24;
  *((_DWORD *)a2 + 4) = 1;
  *((_DWORD *)a2 + 5) = v28;
  uint64_t v30 = *a2;
  a2[3] = *a2;
  uint64_t v31 = v64;
  if (v64 >= 1)
  {
    uint64_t v32 = 0;
    uint64_t v33 = v68;
    int v34 = v67;
    uint64_t v35 = v65;
    uint64_t v36 = 8 * v25;
    uint64_t result = 8 * v66;
    uint64_t v37 = 8 * v67;
    uint64_t v38 = 8 * v65;
    while (v24 < 1)
    {
LABEL_55:
      ++v32;
      uint64_t v33 = (double *)((char *)v33 + result);
      if (v32 == v31) {
        goto LABEL_56;
      }
    }
    uint64_t v39 = 0;
    uint64_t v40 = v27;
    while (1)
    {
      if (v34 == 1)
      {
        if (v25 == 1)
        {
          if (v35)
          {
            uint64_t v41 = 0;
            double v42 = 0.0;
            do
            {
              double v42 = v42 + v33[v41] * v40[v41];
              ++v41;
            }
            while (v35 != v41);
            goto LABEL_54;
          }
        }
        else if ((int)v35 >= 1)
        {
          unint64_t v45 = 0;
          double v42 = 0.0;
          uint64_t v46 = v40;
          do
          {
            double v42 = v42 + v33[v45 / 8] * *v46;
            v45 += 8;
            uint64_t v46 = (double *)((char *)v46 + v36);
          }
          while (v38 != v45);
          goto LABEL_54;
        }
      }
      else if (v25 == 1)
      {
        if ((int)v35 >= 1)
        {
          unint64_t v43 = 0;
          double v42 = 0.0;
          uint64_t v44 = v33;
          do
          {
            double v42 = v42 + *v44 * v40[v43 / 8];
            v43 += 8;
            uint64_t v44 = (double *)((char *)v44 + v37);
          }
          while (v38 != v43);
          goto LABEL_54;
        }
      }
      else if ((int)v35 >= 1)
      {
        double v42 = 0.0;
        int v47 = v33;
        int v48 = v40;
        uint64_t v49 = v35;
        do
        {
          double v42 = v42 + *v47 * *v48;
          int v48 = (double *)((char *)v48 + v36);
          int v47 = (double *)((char *)v47 + v37);
          --v49;
        }
        while (v49);
        goto LABEL_54;
      }
      double v42 = 0.0;
LABEL_54:
      *(double *)(v30 + 8 * (v32 + v39 * v28)) = v42;
      ++v39;
      v40 += v26;
      if (v39 == v24) {
        goto LABEL_55;
      }
    }
  }
LABEL_56:
  if (v22)
  {
    int v50 = *(_DWORD *)(v22 - 4) - 1;
    *(_DWORD *)(v22 - 4) = v50;
    if (!v50)
    {
      uint64_t result = MEMORY[0x1BA9BFB70](v22 - 8, 0x1000C8077774924);
      int v50 = *(_DWORD *)(v22 - 4);
    }
    int v51 = v50 - 1;
    *(_DWORD *)(v22 - 4) = v51;
    if (!v51) {
      uint64_t result = MEMORY[0x1BA9BFB70](v22 - 8, 0x1000C8077774924);
    }
  }
  uint64_t v52 = v63;
  if (v63)
  {
    int v53 = *(_DWORD *)(v63 - 4) - 1;
    *(_DWORD *)(v63 - 4) = v53;
    if (!v53) {
      return MEMORY[0x1BA9BFB70](v52 - 8, 0x1000C8077774924);
    }
  }
  return result;
}

void sub_1B7A64E6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, _Unwind_Exception *a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  uint64_t v20 = exception_object;
  if (v19)
  {
    PCSvd<double>::inverse(v19, (uint64_t)exception_object, a2, (uint64_t)&a16);
    uint64_t v20 = a16;
  }
  uint64_t v21 = a19;
  if (a19)
  {
    int v22 = *(_DWORD *)(a19 - 4) - 1;
    *(_DWORD *)(a19 - 4) = v22;
    if (!v22) {
      MEMORY[0x1BA9BFB70](v21 - 8, 0x1000C8077774924);
    }
  }
  _Unwind_Resume(v20);
}

void *PCSvd<double>::~PCSvd(void *a1)
{
  return a1;
}

uint64_t PCGenMatrix<double>::col@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v3 = a2;
  uint64_t result = PCGenMatrix<double>::checkColIndex(a1, a2);
  int v7 = *(_DWORD *)(a1 + 8);
  uint64_t v8 = *(void *)(a1 + 24);
  int v9 = *(_DWORD *)(a1 + 16);
  int v10 = *(_DWORD *)(a1 + 20);
  uint64_t v11 = *(void *)a1;
  *(void *)a3 = *(void *)a1;
  if (v11) {
    ++*(_DWORD *)(v11 - 4);
  }
  *(_DWORD *)(a3 + 8) = v7;
  *(_DWORD *)(a3 + 12) = v9;
  *(void *)(a3 + 16) = v8 + 8 * v10 * v3;
  return result;
}

void *PCGenMatrix<double>::PCGenMatrix(void *a1, int a2, int a3, int a4, double a5)
{
  int v9 = a3 * a2;
  uint64_t result = PCGenBlockRef<double>::PCGenBlockRef(a1, a3 * a2);
  *((_DWORD *)result + 2) = a2;
  *((_DWORD *)result + 3) = a3;
  if (a4) {
    int v11 = a3;
  }
  else {
    int v11 = 1;
  }
  if (a4) {
    int v12 = 1;
  }
  else {
    int v12 = a2;
  }
  *((_DWORD *)result + 4) = v11;
  *((_DWORD *)result + 5) = v12;
  uint64_t v13 = (double *)*result;
  result[3] = *result;
  if (v13) {
    BOOL v14 = v9 < 1;
  }
  else {
    BOOL v14 = 1;
  }
  if (!v14)
  {
    unsigned int v15 = v9 + 1;
    do
    {
      *v13++ = a5;
      --v15;
    }
    while (v15 > 1);
  }
  return result;
}

void PCMatrix44Tmpl<double>::format(uint64_t a1@<X0>, int a2@<W1>, PCSharedCount *a3@<X8>)
{
  __p = 0;
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  int v50 = 0;
  int v51 = 0;
  uint64_t v52 = 0;
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  std::vector<std::vector<PCString>>::resize(&v47, 4uLL);
  uint64_t v6 = 0;
  uint64_t v46 = 0;
  int v45 = 0;
  do
  {
    uint64_t v7 = 0;
    uint64_t v8 = (uint64_t *)(v47 + 24 * v6);
    do
    {
      PCString::format(v5, *(double *)(a1 + v7), (PCString *)&v57);
      std::vector<PCString>::push_back[abi:ne180100](v8, (PCString *)&v57);
      PCString::~PCString((PCString *)&v57);
      v7 += 32;
    }
    while (v7 != 128);
    PCMatrix44_computeWidth((uint64_t)v8, (signed int *)&v46 + 1, (int *)&v46, &v45);
    int v9 = (PCString *)v54;
    if (v54 >= v55)
    {
      uint64_t v5 = (PCString *)__p;
      uint64_t v11 = (v54 - (unsigned char *)__p) >> 2;
      unint64_t v12 = v11 + 1;
      if ((unint64_t)(v11 + 1) >> 62) {
        goto LABEL_57;
      }
      uint64_t v13 = v55 - (unsigned char *)__p;
      if ((v55 - (unsigned char *)__p) >> 1 > v12) {
        unint64_t v12 = v13 >> 1;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v14 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        unsigned int v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)&v55, v14);
        uint64_t v5 = (PCString *)__p;
        int v9 = (PCString *)v54;
      }
      else
      {
        unsigned int v15 = 0;
      }
      int v16 = &v15[4 * v11];
      *(_DWORD *)int v16 = v46;
      int v10 = v16 + 4;
      while (v9 != v5)
      {
        int var0_high = HIDWORD(v9[-1].var0);
        int v9 = (PCString *)((char *)v9 - 4);
        *((_DWORD *)v16 - 1) = var0_high;
        v16 -= 4;
      }
      __p = v16;
      uint64_t v54 = v10;
      uint64_t v55 = &v15[4 * v14];
      if (v5) {
        operator delete(v5);
      }
    }
    else
    {
      *(_DWORD *)uint64_t v54 = v46;
      int v10 = (char *)&v9->var0 + 4;
    }
    uint64_t v54 = v10;
    __n128 v18 = (PCString *)v51;
    if (v51 >= v52)
    {
      uint64_t v5 = (PCString *)v50;
      uint64_t v20 = (v51 - (unsigned char *)v50) >> 2;
      unint64_t v21 = v20 + 1;
      if ((unint64_t)(v20 + 1) >> 62) {
LABEL_57:
      }
        std::vector<double>::__throw_length_error[abi:ne180100]();
      uint64_t v22 = v52 - (unsigned char *)v50;
      if ((v52 - (unsigned char *)v50) >> 1 > v21) {
        unint64_t v21 = v22 >> 1;
      }
      if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v23 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v23 = v21;
      }
      if (v23)
      {
        int v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)&v52, v23);
        uint64_t v5 = (PCString *)v50;
        __n128 v18 = (PCString *)v51;
      }
      else
      {
        int v24 = 0;
      }
      int v25 = &v24[4 * v20];
      *(_DWORD *)int v25 = v45;
      uint64_t v19 = v25 + 4;
      while (v18 != v5)
      {
        int v26 = HIDWORD(v18[-1].var0);
        __n128 v18 = (PCString *)((char *)v18 - 4);
        *((_DWORD *)v25 - 1) = v26;
        v25 -= 4;
      }
      int v50 = v25;
      int v51 = v19;
      uint64_t v52 = &v24[4 * v23];
      if (v5) {
        operator delete(v5);
      }
    }
    else
    {
      *(_DWORD *)int v51 = v45;
      uint64_t v19 = (char *)&v18->var0 + 4;
    }
    int v51 = v19;
    ++v6;
    a1 += 8;
  }
  while (v6 != 4);
  uint64_t v28 = v47;
  uint64_t v27 = v48;
  PCSharedCount::PCSharedCount(a3);
  PCSharedCount::PCSharedCount(&v57);
  PCSharedCount::PCSharedCount(&v44);
  if (a2 >= 1)
  {
    do
    {
      PCString::PCString(&v56, (const PCString *)&v44);
      PCString::append(v29, "  ");
      PCString::set((PCString *)&v44, &v56);
      PCString::~PCString(&v56);
      --a2;
    }
    while (a2);
  }
  uint64_t v30 = 0;
  int v31 = -1431655765 * ((v27 - v28) >> 3);
  do
  {
    PCString::PCString(&v56, (const PCString *)&v44);
    PCString::append(v32, "[");
    PCString::set((PCString *)&v57, &v56);
    PCString::~PCString(&v56);
    if (v31 >= 1)
    {
      for (uint64_t i = 0; i != v31; ++i)
      {
        PCString::PCString(&v43, (const PCString *)(*(void *)(v47 + 24 * i) + 8 * v30));
        HIDWORD(v46) = PCString::size(&v43);
        PCURL::PCURL((PCURL *)&v56, @".");
        int v34 = PCString::find(&v43, &v56);
        PCString::~PCString(&v56);
        if (v34 >= 0) {
          int v36 = v34;
        }
        else {
          int v36 = HIDWORD(v46);
        }
        int v37 = HIDWORD(v46) - v36;
        int v45 = HIDWORD(v46) - v36;
        LODWORD(v46) = v36;
        int v38 = *((_DWORD *)__p + i);
        int v39 = *((_DWORD *)v50 + i);
        LODWORD(v46) = v36 + 1;
        if (v36 < v38)
        {
          do
          {
            PCString::PCString(&v56, " ");
            PCString::insert(&v43, 0, &v56);
            PCString::~PCString(&v56);
            int v40 = v46;
            LODWORD(v46) = v46 + 1;
          }
          while (v40 < v38);
          goto LABEL_47;
        }
        while (1)
        {
          int v45 = v37 + 1;
          if (v37 >= v39) {
            break;
          }
          PCString::PCString(&v56, " ");
          PCString::append(&v43, &v56);
          PCString::~PCString(&v56);
LABEL_47:
          int v37 = v45;
        }
        PCString::PCString(v35, " ");
        PCString::append((PCString *)&v57, &v56);
        PCString::~PCString(&v56);
        PCString::append((PCString *)&v57, &v43);
        PCString::~PCString(&v43);
      }
    }
    PCString::append((PCString *)&v57, " ]\n");
    PCString::append((PCString *)a3, (const PCString *)&v57);
    ++v30;
  }
  while (v30 != 4);
  PCString::~PCString((PCString *)&v44);
  PCString::~PCString((PCString *)&v57);
  v57.var0 = (PC_Sp_counted_base *)&v47;
  std::vector<std::vector<PCString>>::__destroy_vector::operator()[abi:ne180100](v41);
  if (v50)
  {
    int v51 = (char *)v50;
    operator delete(v50);
  }
  if (__p)
  {
    uint64_t v54 = (char *)__p;
    operator delete(__p);
  }
}

void sub_1B7A6553C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, PCString *a9, PCString a10, PCString a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20,uint64_t a21)
{
  PCString::~PCString((PCString *)(v21 - 88));
  PCString::~PCString(a9);
  *(void *)(v21 - 88) = &a14;
  std::vector<std::vector<PCString>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v21 - 88));
  if (__p)
  {
    a18 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a20)
  {
    a21 = (uint64_t)a20;
    operator delete(a20);
  }
  _Unwind_Resume(a1);
}

void std::vector<std::vector<PCString>>::resize(uint64_t *a1, unint64_t a2)
{
  int v3 = (void **)a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<std::vector<PCString>>::__append(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 24 * a2;
    while (v3 != (void **)v7)
    {
      v3 -= 3;
      uint64_t v8 = v3;
      std::vector<PCString>::__destroy_vector::operator()[abi:ne180100](&v8);
    }
    a1[1] = v7;
  }
}

void PCMatrix44_computeWidth(uint64_t a1, signed int *a2, int *a3, int *a4)
{
  uint64_t v7 = *(PCString **)a1;
  unint64_t v8 = *(void *)(a1 + 8) - *(void *)a1;
  if ((v8 >> 3))
  {
    unsigned int v10 = PCString::size(*(PCString **)a1);
    PCURL::PCURL((PCURL *)&v20, @".");
    int v11 = PCString::find(v7, &v20);
    PCString::~PCString(&v20);
    *a2 = v10;
    if (v11 >= 0) {
      unsigned int v12 = v11;
    }
    else {
      unsigned int v12 = v10;
    }
    *a3 = v12;
    *a4 = v10 - v12;
    if ((int)(v8 >> 3) >= 2)
    {
      uint64_t v13 = (v8 >> 3) - 1;
      uint64_t v14 = 8;
      do
      {
        unsigned int v15 = (PCString *)(*(void *)a1 + v14);
        signed int v16 = PCString::size(v15);
        PCURL::PCURL((PCURL *)&v20, @".");
        int v17 = PCString::find(v15, &v20);
        PCString::~PCString(&v20);
        if (v17 >= 0) {
          int v18 = v17;
        }
        else {
          int v18 = v16;
        }
        if (*a2 < v16) {
          *a2 = v16;
        }
        if (*a3 < v18) {
          *a3 = v18;
        }
        int v19 = v16 - v18;
        if (*a4 < v19) {
          *a4 = v19;
        }
        v14 += 8;
        --v13;
      }
      while (v13);
    }
  }
  else
  {
    *a4 = 0;
    *a3 = 0;
    *a2 = 0;
  }
}

void sub_1B7A65828(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void std::vector<std::vector<PCString>>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v13 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v19 = v4;
    if (v11) {
      unsigned int v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>(v4, v11);
    }
    else {
      unsigned int v12 = 0;
    }
    unsigned int v15 = v12;
    signed int v16 = &v12[24 * v8];
    int v18 = &v12[24 * v11];
    size_t v14 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v16, v14);
    int v17 = &v16[v14];
    std::vector<std::vector<PCString>>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<std::vector<PCString>>::~__split_buffer(&v15);
  }
}

void sub_1B7A65994(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<PCString>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<PCString>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<PCString>>,std::reverse_iterator<std::vector<PCString>*>,std::reverse_iterator<std::vector<PCString>*>,std::reverse_iterator<std::vector<PCString>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<PCString>>,std::reverse_iterator<std::vector<PCString>*>,std::reverse_iterator<std::vector<PCString>*>,std::reverse_iterator<std::vector<PCString>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  double v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      long long v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 24;
      *((void *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<PCString>>,std::reverse_iterator<std::vector<PCString>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<PCString>>,std::reverse_iterator<std::vector<PCString>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<PCString>>,std::reverse_iterator<std::vector<PCString>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<PCString>>,std::reverse_iterator<std::vector<PCString>*>>::operator()[abi:ne180100](uint64_t a1)
{
  int v1 = *(void ***)(*(void *)(a1 + 16) + 8);
  int v2 = *(void ***)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    int v3 = v1;
    std::vector<PCString>::__destroy_vector::operator()[abi:ne180100](&v3);
    v1 += 3;
  }
}

void **std::__split_buffer<std::vector<PCString>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<std::vector<PCString>>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = (void **)(i - 24);
    *(void *)(a1 + 16) = v4;
    uint64_t v5 = v4;
    std::vector<PCString>::__destroy_vector::operator()[abi:ne180100](&v5);
  }
}

void std::vector<std::vector<PCString>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  int v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        uint64_t v6 = v4;
        std::vector<PCString>::__destroy_vector::operator()[abi:ne180100](&v6);
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void PCSvd<double>::inverse(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  int v8 = *(_DWORD *)(a1 - 4) - 1;
  *(_DWORD *)(a1 - 4) = v8;
  if (!v8)
  {
    OUTLINED_FUNCTION_2();
    int v8 = *(_DWORD *)(a1 - 4);
  }
  int v9 = v8 - 1;
  *(_DWORD *)(a1 - 4) = v9;
  if (!v9) {
    OUTLINED_FUNCTION_2();
  }
  *(void *)a4 = a2;
  *(_DWORD *)(a4 + 8) = a3;
}

uint64_t LiTextureStoreTokenImpl::LiTextureStoreTokenImpl(uint64_t a1, uint64_t *a2)
{
  *(_DWORD *)a1 = 0;
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  *(void *)(a1 + 8) = *a2;
  *(void *)(a1 + 16) = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
    uint64_t v3 = *(void *)(a1 + 8);
  }
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 24) = a1 + 32;
  *(void *)(a1 + 40) = 0;
  (*(void (**)(uint64_t))(*(void *)v3 + 16))(v3);
  return a1;
}

void sub_1B7A65D2C(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;
  std::__tree<std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>>>::destroy(v3, *(void **)(v1 + 32));
  uint64_t v5 = *(std::__shared_weak_count **)(v1 + 16);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  PCSpinLock::~PCSpinLock((PCSpinLock *)v1);
  _Unwind_Resume(a1);
}

void LiTextureStoreTokenImpl::redeem(LiTextureStoreTokenImpl *this@<X0>, ProGL::GL *a2@<X1>, PCWorkingColorVector *a3@<X8>)
{
  ProGL::GL::getPGLContextHandle(a2, &v17);
  int VirtualScreen = ProGL::ContextHandle::getVirtualScreen((ProGL::ContextHandle *)&v17);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&v17);
  PCWorkingColorVector::PCWorkingColorVector(a3);
  uint64_t v19 = this;
  PCSpinLock::lock((os_unfair_lock_t)this);
  uint64_t v6 = (char *)*((void *)this + 4);
  if (!v6) {
    goto LABEL_11;
  }
  uint64_t v7 = (char *)this + 32;
  do
  {
    int v8 = *((_DWORD *)v6 + 8);
    BOOL v9 = v8 < VirtualScreen;
    if (v8 >= VirtualScreen) {
      unint64_t v10 = (char **)v6;
    }
    else {
      unint64_t v10 = (char **)(v6 + 8);
    }
    if (!v9) {
      uint64_t v7 = v6;
    }
    uint64_t v6 = *v10;
  }
  while (*v10);
  if (v7 == (char *)this + 32 || VirtualScreen < *((_DWORD *)v7 + 8))
  {
LABEL_11:
    (*(void (**)(long long *__return_ptr))(**((void **)this + 1) + 24))(&v17);
    long long v11 = v17;
    long long v17 = 0uLL;
    char v12 = (std::__shared_weak_count *)*((void *)a3 + 1);
    *(_OWORD *)a3 = v11;
    if (v12)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v12);
      if (*((void *)&v17 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v17 + 1));
      }
    }
    LODWORD(v17) = VirtualScreen;
    long long v13 = (std::__shared_weak_count *)*((void *)a3 + 1);
    *((void *)&v17 + 1) = *(void *)a3;
    int v18 = v13;
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    std::__tree<std::__value_type<int,ProGL::TextureHandle>,std::__map_value_compare<int,std::__value_type<int,ProGL::TextureHandle>,std::less<int>,true>,std::allocator<std::__value_type<int,ProGL::TextureHandle>>>::__emplace_unique_key_args<int,std::pair<int const,ProGL::TextureHandle>>((uint64_t **)this + 3, (int *)&v17, (uint64_t)&v17);
    if (v18) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v18);
    }
LABEL_18:
    PCSpinLock::unlock((os_unfair_lock_t)this);
    return;
  }
  uint64_t v15 = *((void *)v7 + 5);
  uint64_t v14 = *((void *)v7 + 6);
  if (v14) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
  }
  signed int v16 = (std::__shared_weak_count *)*((void *)a3 + 1);
  *(void *)a3 = v15;
  *((void *)a3 + 1) = v14;
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v16);
  }
  if (this) {
    goto LABEL_18;
  }
}

void sub_1B7A65ED4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, std::__shared_weak_count *a4, ...)
{
  va_start(va, a4);
  if (a4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a4);
  }
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  uint64_t v6 = *(std::__shared_weak_count **)(v4 + 8);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  _Unwind_Resume(a1);
}

void LiTextureStoreImpl::findTokenImpl(LiTextureStoreImpl *this@<X0>, const PCHash128 *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v5 = (uint64_t **)((char *)this + 16);
  uint64_t v6 = std::__tree<std::__value_type<PCHash128,PCRect<double>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCRect<double>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCRect<double>>>>::find<PCHash128>((uint64_t)this + 16, a2);
  if ((uint64_t *)((char *)this + 24) == v6) {
    goto LABEL_9;
  }
  uint64_t v7 = v6;
  *a3 = 0;
  a3[1] = 0;
  int v8 = (std::__shared_weak_count *)v6[7];
  if (!v8)
  {
    BOOL v9 = 0;
LABEL_7:
    std::__tree<std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>>>::erase(v5, v7);
    if (v9) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v9);
    }
LABEL_9:
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  BOOL v9 = std::__shared_weak_count::lock(v8);
  a3[1] = (uint64_t)v9;
  if (!v9) {
    goto LABEL_7;
  }
  uint64_t v10 = v7[6];
  *a3 = v10;
  if (!v10) {
    goto LABEL_7;
  }
}

void sub_1B7A65FB8(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void LiTextureStoreImpl::addTokenImpl(uint64_t a1, long long *a2, uint64_t *a3)
{
  uint64_t v4 = *a3;
  uint64_t v3 = (std::__shared_weak_count *)a3[1];
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  long long v5 = *a2;
  uint64_t v6 = v4;
  uint64_t v7 = v3;
  std::__tree<std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>>>::__emplace_unique_key_args<PCHash128,std::pair<PCHash128 const,std::weak_ptr<LiTextureStoreTokenImpl>>>((uint64_t **)(a1 + 16), (const PCHash128 *)&v5, (uint64_t)&v5);
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
}

void sub_1B7A66030(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_weak(a12);
  }
  _Unwind_Resume(exception_object);
}

void LiTextureStore::getToken(std::__shared_weak_count **this@<X0>, uint64_t *a2@<X8>)
{
  {
    operator new();
  }
  long long v5 = (os_unfair_lock_s *)getTextureStoreInstance(void)::instance;
  uint64_t v17 = getTextureStoreInstance(void)::instance + 8;
  PCSpinLock::lock((os_unfair_lock_t)(getTextureStoreInstance(void)::instance + 8));
  long long v16 = *(_OWORD *)LiTextureFactory::getKey((LiTextureFactory *)this);
  LiTextureStoreImpl::findTokenImpl((LiTextureStoreImpl *)v5, (const PCHash128 *)&v16, &v14);
  uint64_t v6 = v14;
  if (v14)
  {
    uint64_t v7 = v15;
  }
  else
  {
    int v8 = this[1];
    uint64_t v10 = *this;
    long long v11 = v8;
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    std::allocate_shared[abi:ne180100]<LiTextureStoreTokenImpl,std::allocator<LiTextureStoreTokenImpl>,std::shared_ptr<LiTextureFactoryImpl>,void>((uint64_t *)&v10, &v12);
    uint64_t v6 = v12;
    uint64_t v7 = v13;
    uint64_t v12 = 0;
    long long v13 = 0;
    BOOL v9 = v15;
    uint64_t v14 = v6;
    uint64_t v15 = v7;
    if (v9)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v9);
      if (v13) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v13);
      }
    }
    if (v11) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v11);
    }
    LiTextureStoreImpl::addTokenImpl((uint64_t)v5, &v16, &v14);
  }
  *a2 = v6;
  a2[1] = (uint64_t)v7;
  if (v7)
  {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  PCSpinLock::unlock(v5 + 2);
}

void sub_1B7A661EC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40C3D8C859);
  _Unwind_Resume(a1);
}

void *LiTextureFactory::getKey(LiTextureFactory *this)
{
  if (*(void *)this) {
    return (void *)(*(void *)this + 8);
  }
  {
    {
      PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)&LiTextureFactory::getKey(void)const::defaultKey);
    }
  }
  return &LiTextureFactory::getKey(void)const::defaultKey;
}

void sub_1B7A662D8(_Unwind_Exception *a1)
{
}

void LiTextureStoreToken::redeem(LiTextureStoreTokenImpl **this@<X0>, ProGL::GL *a2@<X1>, PCWorkingColorVector *a3@<X8>)
{
  uint64_t v3 = *this;
  if (v3) {
    LiTextureStoreTokenImpl::redeem(v3, a2, a3);
  }
  else {
    PCWorkingColorVector::PCWorkingColorVector(a3);
  }
}

void getSimpleTextureHash(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v3 = v2;
  int v5 = v4;
  uint64_t v6 = (const __CFURL **)v1;
  int v8 = v7;
  v10[520] = *(int8x8_t *)MEMORY[0x1E4F143B8];
  PCHashWriteStream::PCHashWriteStream((PCHashWriteStream *)v10);
  PCHashWriteStream::writeValue(v10, @"simple");
  PCURL::getAsFileSystemString(v6, &v9);
  PCHashWriteStream::writeValue(v10, &v9);
  PCString::~PCString(&v9);
  PCHashWriteStream::writeValue(v10, v5);
  if (v3)
  {
    PCColorSpaceHandle::getMD5(v3, (PCWorkingColorVector *)&v9);
    PCHashWriteStream::writeValue(v10, (const PCHash128 *)&v9);
  }
  _OWORD *v8 = *(_OWORD *)PCHashWriteStream::getHash(v10)->i8;
  PCHashWriteStream::~PCHashWriteStream((PCHashWriteStream *)v10);
}

void sub_1B7A66408(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10, uint64_t a11, char a12)
{
}

LoadLockCache *LiAsyncBumpBitmapCreator::operator()@<X0>(const PCHash128 *a1@<X0>, void *a2@<X8>)
{
  uint64_t result = (LoadLockCache *)LiCachingDelegateGetBitmap(a1, a2);
  if (!*a2)
  {
    int v5 = (PCMutex *)LoadLockCache::instance(result);
    LiLockCache<PCHash128,PCMutex>::getLock(v5, a1, (uint64_t)v11);
    LiCachingDelegateGetBitmap(a1, v10);
    long long v6 = v10[0];
    v10[0] = 0uLL;
    uint64_t v7 = (std::__shared_weak_count *)a2[1];
    *(_OWORD *)a2 = v6;
    if (v7)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v7);
      if (*((void *)&v10[0] + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v10[0] + 1));
      }
      if (*a2) {
        return (LoadLockCache *)LiLockCache<PCHash128,PCMutex>::LockSentry::~LockSentry((uint64_t)v11);
      }
    }
    else if ((void)v6)
    {
      return (LoadLockCache *)LiLockCache<PCHash128,PCMutex>::LockSentry::~LockSentry((uint64_t)v11);
    }
    PCTimer::PCTimer((PCTimer *)v10);
    PCTimer::start((PCTimer *)v10);
    int v8 = (std::__shared_weak_count *)a2[1];
    *a2 = 0;
    a2[1] = 0;
    if (v8) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    }
    PCTimer::stop((PCTimer *)v10);
    PCTimer::getSeconds((PCTimer *)v10);
    LiCachingDelegateAddBitmap((uint64_t)a2, (uint64_t)a1);
    OZChannelBase::setRangeName((OZChannelBase *)v10, v9);
    return (LoadLockCache *)LiLockCache<PCHash128,PCMutex>::LockSentry::~LockSentry((uint64_t)v11);
  }
  return result;
}

void sub_1B7A66514(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  LiLockCache<PCHash128,PCMutex>::LockSentry::~LockSentry((uint64_t)va);
  uint64_t v7 = *(std::__shared_weak_count **)(v5 + 8);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  _Unwind_Resume(a1);
}

void LiLockCache<PCHash128,PCMutex>::getLock(PCMutex *a1@<X0>, const PCHash128 *a2@<X1>, uint64_t a3@<X8>)
{
  int v4 = a1;
  long long v20 = 0uLL;
  int v18 = a1;
  PCMutex::lock(a1);
  char v19 = 1;
  long long v6 = std::__tree<std::__value_type<PCHash128,PCRect<double>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCRect<double>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCRect<double>>>>::find<PCHash128>((uint64_t)&v4[1], a2);
  uint64_t v7 = v6;
  if (&v4[1]._Mutex == (_opaque_pthread_mutex_t *)v6)
  {
    uint64_t v10 = 0;
  }
  else
  {
    int v8 = (std::__shared_weak_count *)v6[7];
    if (v8 && (PCString v9 = std::__shared_weak_count::lock(v8)) != 0)
    {
      uint64_t v10 = v9;
      *(void *)&long long v20 = v7[6];
      *((void *)&v20 + 1) = v9;
      if ((void)v20)
      {
        BOOL v11 = 0;
        if (!v4) {
          goto LABEL_22;
        }
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v10 = 0;
      long long v20 = 0uLL;
    }
    std::__tree<std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>>>::erase((uint64_t **)&v4[1], v7);
  }
  _ZNSt3__115allocate_sharedB8ne180100I7PCMutexNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v15);
  long long v12 = v15;
  long long v15 = 0uLL;
  long long v20 = v12;
  if (v10)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
    if (*((void *)&v15 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v15 + 1));
    }
    long long v13 = (std::__shared_weak_count *)*((void *)&v20 + 1);
  }
  else
  {
    long long v13 = (std::__shared_weak_count *)*((void *)&v12 + 1);
  }
  uint64_t v14 = v20;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  long long v15 = *(_OWORD *)a2;
  uint64_t v16 = v14;
  uint64_t v17 = v13;
  std::__tree<std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>>>::__emplace_unique_key_args<PCHash128,std::pair<PCHash128 const,std::weak_ptr<LiTextureStoreTokenImpl>>>((uint64_t **)&v4[1], (const PCHash128 *)&v15, (uint64_t)&v15);
  if (v17) {
    std::__shared_weak_count::__release_weak(v17);
  }
  int v4 = v18;
  BOOL v11 = v19 == 0;
  if (v18)
  {
LABEL_20:
    if (!v11) {
      PCMutex::unlock(v4);
    }
  }
LABEL_22:
  LiLockCache<PCHash128,PCMutex>::LockSentry::LockSentry(a3, (PCMutex **)&v20);
  if (*((void *)&v20 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v20 + 1));
  }
}

void sub_1B7A666C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a12) {
    std::__shared_weak_count::__release_weak(a12);
  }
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)&a14);
  if (v17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v17);
  }
  _Unwind_Resume(a1);
}

uint64_t LiCreateBumpBitmapAsync@<X0>(uint64_t *a1@<X0>, atomic_ullong **a2@<X1>, long long *a3@<X2>, void *a4@<X8>)
{
  uint64_t v4 = *a1;
  int v6 = *((_DWORD *)a1 + 2);
  int v5 = *((_DWORD *)a1 + 3);
  uint64_t v7 = *a2;
  if (*a2)
  {
    atomic_fetch_add_explicit(v7 + 1, 1uLL, memory_order_relaxed);
    int v10 = v6;
    int v11 = v5;
    long long v12 = v7;
    atomic_fetch_add_explicit(v7 + 1, 1uLL, memory_order_relaxed);
  }
  else
  {
    int v10 = *((_DWORD *)a1 + 2);
    int v11 = v5;
    long long v12 = 0;
  }
  uint64_t v9 = v4;
  long long v13 = *a3;
  std::async[abi:ne180100]<LiAsyncBumpBitmapCreator>(3, (uint64_t)&v9, a4);
  uint64_t result = (uint64_t)v12;
  if (v12 && !atomic_fetch_add(v12 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
  }
  if (v7)
  {
    if (!atomic_fetch_add(v7 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
      return (*(uint64_t (**)(atomic_ullong *))(*v7 + 16))(v7);
    }
  }
  return result;
}

void sub_1B7A667FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    LiCreateBumpBitmapAsync(a12);
  }
  LiCreateBumpBitmapAsync(v12 == 0, v12);
  _Unwind_Resume(a1);
}

uint64_t BumpTextureImpl::BumpTextureImpl(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  uint64_t v3 = v2;
  int v5 = v4;
  uint64_t v6 = v1;
  v10[520] = *(int8x8_t *)MEMORY[0x1E4F143B8];
  PCHashWriteStream::PCHashWriteStream((PCHashWriteStream *)v10);
  PCHashWriteStream::writeValue(v10, @"bump");
  PCURL::getAsFileSystemString(v5, &v9);
  PCHashWriteStream::writeValue(v10, &v9);
  PCString::~PCString(&v9);
  PCHashWriteStream::writeValue(v10, *(_DWORD *)v3);
  PCHashWriteStream::writeValue(v10, *(unsigned char *)(v3 + 4));
  PCHashWriteStream::writeValue(v10, *(unsigned char *)(v3 + 5));
  PCHashWriteStream::writeValue(v10, *(float *)(v3 + 8));
  long long v8 = *(_OWORD *)PCHashWriteStream::getHash(v10)->i8;
  PCHashWriteStream::~PCHashWriteStream((PCHashWriteStream *)v10);
  *(_OWORD *)(v6 + 8) = v8;
  *(void *)uint64_t v6 = &unk_1F1118B10;
  PCURL::PCURL((PCURL *)(v6 + 24), (const PCURL *)v5);
  *(_OWORD *)(v6 + 32) = *(_OWORD *)v3;
  *(void *)(v6 + 48) = 0;
  *(void *)(v6 + 56) = 0;
  return v6;
}

void sub_1B7A66964(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCString a11, char a12)
{
}

void BumpTextureImpl::~BumpTextureImpl(BumpTextureImpl *this)
{
  *(void *)this = &unk_1F1118B10;
  uint64_t v2 = (atomic_ullong *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(v2 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
    (*(void (**)(atomic_ullong *))(*v2 + 16))(v2);
  }
  uint64_t v3 = (atomic_ullong *)*((void *)this + 6);
  if (v3 && !atomic_fetch_add(v3 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
    (*(void (**)(atomic_ullong *))(*v3 + 16))(v3);
  }
  PCURL::~PCURL((BumpTextureImpl *)((char *)this + 24));
}

{
  uint64_t vars8;

  BumpTextureImpl::~BumpTextureImpl(this);

  JUMPOUT(0x1BA9BFBA0);
}

atomic_ullong *BumpTextureImpl::start(BumpTextureImpl *this)
{
  if (*((unsigned char *)this + 37))
  {
    PCColorSpaceCache::sRGB(&v12);
    PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&v12);
    getSimpleTextureHash((uint64_t)this + 24);
    LiLoadBitmapAsync((BumpTextureImpl *)((char *)this + 24), &v11, 11, &v12, 1, &v10);
  }
  else
  {
    long long v12 = 0;
    PCColorSpaceHandle::getCGColorSpace((PCColorSpaceHandle *)&v12);
    getSimpleTextureHash((uint64_t)this + 24);
    LiLoadBitmapAsync((BumpTextureImpl *)((char *)this + 24), &v11, 13, &v12, 1, &v10);
  }
  uint64_t v2 = v10;
  uint64_t v10 = 0;
  uint64_t v3 = (atomic_ullong *)*((void *)this + 6);
  *((void *)this + 6) = v2;
  if (v3)
  {
    if (!atomic_fetch_add(v3 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
      (*(void (**)(atomic_ullong *))(*v3 + 16))(v3);
    }
    uint64_t v4 = v10;
    if (v10 && !atomic_fetch_add((atomic_ullong *volatile)(v10 + 8), 0xFFFFFFFFFFFFFFFFLL)) {
      (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
    }
  }
  PCCFRef<CGColorSpace *>::~PCCFRef(&v12);
  long long v9 = *(_OWORD *)((char *)this + 8);
  int v5 = (atomic_ullong *)*((void *)this + 6);
  long long v8 = v5;
  if (v5) {
    atomic_fetch_add_explicit(v5 + 1, 1uLL, memory_order_relaxed);
  }
  LiCreateBumpBitmapAsync((uint64_t *)&v9, &v8, (long long *)this + 2, &v11);
  if (v5 && !atomic_fetch_add(v5 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
    (*(void (**)(atomic_ullong *))(*v5 + 16))(v5);
  }
  uint64_t v6 = v11;
  *(void *)&long long v11 = 0;
  uint64_t result = (atomic_ullong *)*((void *)this + 7);
  *((void *)this + 7) = v6;
  if (result)
  {
    if (!atomic_fetch_add(result + 1, 0xFFFFFFFFFFFFFFFFLL)) {
      (*(void (**)(atomic_ullong *))(*result + 16))(result);
    }
    uint64_t result = (atomic_ullong *)v11;
    if ((void)v11)
    {
      if (!atomic_fetch_add((atomic_ullong *volatile)(v11 + 8), 0xFFFFFFFFFFFFFFFFLL)) {
        return (atomic_ullong *)(*(uint64_t (**)(atomic_ullong *))(*result + 16))(result);
      }
    }
  }
  return result;
}

void sub_1B7A66CC8(_Unwind_Exception *a1)
{
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(v1 - 24));
  _Unwind_Resume(a1);
}

void BumpTextureImpl::makeTexture(PCWorkingColorVector *a1@<X8>)
{
}

void LiMakeBumpTextureFactory(void *a1@<X8>)
{
  std::allocate_shared[abi:ne180100]<BumpTextureImpl,std::allocator<BumpTextureImpl>,PCURL const&,LiBumpTextureInfo const&,void>(&v5);
  uint64_t v3 = v5;
  uint64_t v2 = v6;
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
    uint64_t v4 = v6;
    *a1 = v3;
    a1[1] = v2;
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    }
  }
  else
  {
    *a1 = v5;
    a1[1] = 0;
  }
}

void LiTextureStoreImpl::~LiTextureStoreImpl(LiTextureStoreImpl *this)
{
  *(void *)this = &unk_1F1118B68;
  std::__tree<std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>>>::destroy((uint64_t)this + 16, *((void **)this + 3));
  PCSpinLock::~PCSpinLock((PCSpinLock *)this + 2);

  PCSingleton::~PCSingleton(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F1118B68;
  std::__tree<std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>>>::destroy((uint64_t)this + 16, *((void **)this + 3));
  PCSpinLock::~PCSpinLock((PCSpinLock *)this + 2);
  PCSingleton::~PCSingleton(this);

  JUMPOUT(0x1BA9BFBA0);
}

void std::__tree<std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>>>::destroy(a1, a2[1]);
    uint64_t v4 = (std::__shared_weak_count *)a2[7];
    if (v4) {
      std::__shared_weak_count::__release_weak(v4);
    }
    operator delete(a2);
  }
}

uint64_t LiLockCache<PCHash128,PCMutex>::LockSentry::~LockSentry(uint64_t a1)
{
  uint64_t v2 = *(PCMutex **)(a1 + 16);
  if (v2 && *(unsigned char *)(a1 + 24))
  {
    PCMutex::unlock(v2);
    *(unsigned char *)(a1 + 24) = 0;
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  return a1;
}

uint64_t **std::__tree<std::__value_type<int,ProGL::TextureHandle>,std::__map_value_compare<int,std::__value_type<int,ProGL::TextureHandle>,std::less<int>,true>,std::allocator<std::__value_type<int,ProGL::TextureHandle>>>::__emplace_unique_key_args<int,std::pair<int const,ProGL::TextureHandle>>(uint64_t **a1, int *a2, uint64_t a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    int v7 = *a2;
    while (1)
    {
      while (1)
      {
        long long v8 = (uint64_t **)v5;
        int v9 = *((_DWORD *)v5 + 8);
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    long long v8 = a1 + 1;
LABEL_10:
    uint64_t v10 = (char *)operator new(0x38uLL);
    *((_DWORD *)v10 + 8) = *(_DWORD *)a3;
    *(_OWORD *)(v10 + 40) = *(_OWORD *)(a3 + 8);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, (uint64_t)v8, v6, (uint64_t *)v10);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t *std::__tree<std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>>>::erase(uint64_t **a1, uint64_t *a2)
{
  uint64_t v3 = std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer(a1, a2);
  uint64_t v4 = (std::__shared_weak_count *)a2[7];
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  operator delete(a2);
  return v3;
}

uint64_t *std::__tree<std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,std::weak_ptr<LiTextureStoreTokenImpl>>>>::__emplace_unique_key_args<PCHash128,std::pair<PCHash128 const,std::weak_ptr<LiTextureStoreTokenImpl>>>(uint64_t **a1, const PCHash128 *a2, uint64_t a3)
{
  uint64_t v5 = (void **)std::__tree<std::__value_type<PCHash128,PCRect<double>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCRect<double>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCRect<double>>>>::__find_equal<PCHash128>((uint64_t)a1, &v10, a2);
  uint64_t v6 = (uint64_t *)*v5;
  if (!*v5)
  {
    int v7 = (uint64_t **)v5;
    uint64_t v6 = (uint64_t *)operator new(0x40uLL);
    long long v8 = *(_OWORD *)(a3 + 16);
    *((_OWORD *)v6 + 2) = *(_OWORD *)a3;
    *((_OWORD *)v6 + 3) = v8;
    *(void *)(a3 + 16) = 0;
    *(void *)(a3 + 24) = 0;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v10, v7, v6);
  }
  return v6;
}

void *std::allocate_shared[abi:ne180100]<LiTextureStoreTokenImpl,std::allocator<LiTextureStoreTokenImpl>,std::shared_ptr<LiTextureFactoryImpl>,void>@<X0>(uint64_t *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x48uLL);
  uint64_t result = std::__shared_ptr_emplace<LiTextureStoreTokenImpl>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<LiTextureFactoryImpl>,std::allocator<LiTextureStoreTokenImpl>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1B7A670E0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<LiTextureStoreTokenImpl>::__shared_ptr_emplace[abi:ne180100]<std::shared_ptr<LiTextureFactoryImpl>,std::allocator<LiTextureStoreTokenImpl>,0>(void *a1, uint64_t *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F1118BA0;
  LiTextureStoreTokenImpl::LiTextureStoreTokenImpl((uint64_t)(a1 + 3), a2);
  return a1;
}

void sub_1B7A6713C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<LiTextureStoreTokenImpl>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1118BA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<LiTextureStoreTokenImpl>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1118BA0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

void std::__shared_ptr_emplace<LiTextureStoreTokenImpl>::__on_zero_shared(uint64_t a1)
{
}

void LiTextureStoreTokenImpl::~LiTextureStoreTokenImpl(LiTextureStoreTokenImpl *this)
{
  std::__tree<std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::shared_ptr<OZFontFace>>>>::destroy((uint64_t)this + 24, *((void **)this + 4));
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }

  PCSpinLock::~PCSpinLock((PCSpinLock *)this);
}

uint64_t _ZNSt3__115allocate_sharedB8ne180100I7PCMutexNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(void *a1@<X8>)
{
  uint64_t v2 = (char *)operator new(0x60uLL);
  uint64_t result = _ZNSt3__120__shared_ptr_emplaceI7PCMutexNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_((uint64_t)v2);
  *a1 = v2 + 24;
  a1[1] = v2;
  return result;
}

void sub_1B7A67254(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t _ZNSt3__120__shared_ptr_emplaceI7PCMutexNS_9allocatorIS1_EEEC2B8ne180100IJES3_Li0EEES3_DpOT_(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1F1118BF0;
  PCMutex::PCMutex((PCMutex *)(a1 + 24));
  return a1;
}

void sub_1B7A672B0(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PCMutex>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1118BF0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PCMutex>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1118BF0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<PCMutex>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t LiLockCache<PCHash128,PCMutex>::LockSentry::LockSentry(uint64_t a1, PCMutex **a2)
{
  uint64_t v3 = a2[1];
  *(void *)a1 = *a2;
  *(void *)(a1 + 8) = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->_Mutex.__sig, 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = *a2;
  *(void *)(a1 + 16) = *a2;
  *(unsigned char *)(a1 + 24) = 0;
  PCMutex::lock(v4);
  *(unsigned char *)(a1 + 24) = 1;
  return a1;
}

void sub_1B7A673B4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::async[abi:ne180100]<LiAsyncBumpBitmapCreator>@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (result)
  {
    *(void *)(a2 + 16) = 0;
    std::__make_async_assoc_state[abi:ne180100]<std::shared_ptr<PCBitmap>,std::__async_func<LiAsyncBumpBitmapCreator>>();
  }
  if ((result & 2) != 0)
  {
    *(void *)(a2 + 16) = 0;
    std::__make_deferred_assoc_state[abi:ne180100]<std::shared_ptr<PCBitmap>,std::__async_func<LiAsyncBumpBitmapCreator>>();
  }
  *a3 = 0;
  return result;
}

void sub_1B7A674D8(_Unwind_Exception *a1)
{
}

void std::__make_async_assoc_state[abi:ne180100]<std::shared_ptr<PCBitmap>,std::__async_func<LiAsyncBumpBitmapCreator>>()
{
}

void sub_1B7A67634(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::thread a12)
{
  if (!atomic_fetch_add(v13, 0xFFFFFFFFFFFFFFFFLL)) {
    (*(void (**)(uint64_t))(*(void *)v12 + 16))(v12);
  }
  _Unwind_Resume(exception_object);
}

void std::__make_deferred_assoc_state[abi:ne180100]<std::shared_ptr<PCBitmap>,std::__async_func<LiAsyncBumpBitmapCreator>>()
{
}

void sub_1B7A6779C(_Unwind_Exception *exception_object)
{
  if (!atomic_fetch_add(v2, 0xFFFFFFFFFFFFFFFFLL)) {
    (*(void (**)(uint64_t))(*(void *)v1 + 16))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__assoc_sub_state::__execute(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 24))();
}

void std::__async_assoc_state<std::shared_ptr<PCBitmap>,std::__async_func<LiAsyncBumpBitmapCreator>>::~__async_assoc_state(uint64_t a1)
{
  *(void *)a1 = &unk_1F1118C40;
  uint64_t v2 = *(atomic_ullong **)(a1 + 176);
  if (v2 && !atomic_fetch_add(v2 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
    (*(void (**)(atomic_ullong *))(*v2 + 16))(v2);
  }
  *(void *)a1 = MEMORY[0x1E4FBA480] + 16;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));

  std::__shared_count::~__shared_count((std::__shared_count *)a1);
}

{
  atomic_ullong *v2;
  uint64_t vars8;

  *(void *)a1 = &unk_1F1118C40;
  uint64_t v2 = *(atomic_ullong **)(a1 + 176);
  if (v2 && !atomic_fetch_add(v2 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
    (*(void (**)(atomic_ullong *))(*v2 + 16))(v2);
  }
  *(void *)a1 = MEMORY[0x1E4FBA480] + 16;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  std::__shared_count::~__shared_count((std::__shared_count *)a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__async_assoc_state<std::shared_ptr<PCBitmap>,std::__async_func<LiAsyncBumpBitmapCreator>>::__on_zero_shared(std::__assoc_sub_state *a1)
{
  std::__assoc_sub_state::wait(a1);

  return std::__assoc_state<std::shared_ptr<PCBitmap>>::__on_zero_shared((uint64_t)a1);
}

void std::__async_assoc_state<std::shared_ptr<PCBitmap>,std::__async_func<LiAsyncBumpBitmapCreator>>::__execute(uint64_t a1)
{
  LiAsyncBumpBitmapCreator::operator()((const PCHash128 *)(a1 + 160), &v2);
  std::__assoc_state<std::shared_ptr<PCBitmap>>::set_value<std::shared_ptr<PCBitmap>>(a1, (uint64_t)&v2);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
}

void sub_1B7A67A24(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  __cxa_begin_catch(a1);
  std::current_exception();
  v14.__ptr_ = &a10;
  std::__assoc_sub_state::set_exception(v12, v14);
  std::exception_ptr::~exception_ptr(&a10);
  __cxa_end_catch();
  JUMPOUT(0x1B7A67A14);
}

void sub_1B7A67A68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
}

uint64_t std::__assoc_state<std::shared_ptr<PCBitmap>>::__on_zero_shared(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 136))
  {
    uint64_t v2 = *(std::__shared_weak_count **)(a1 + 152);
    if (v2) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v2);
    }
  }
  uint64_t v3 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 8);

  return v3(a1);
}

void std::__assoc_state<std::shared_ptr<PCBitmap>>::set_value<std::shared_ptr<PCBitmap>>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (std::mutex *)(a1 + 24);
  std::mutex::lock((std::mutex *)(a1 + 24));
  if ((*(unsigned char *)(a1 + 136) & 1) != 0
    || (v6.__ptr_ = 0, uint64_t v5 = *(void *)(a1 + 16), std::exception_ptr::~exception_ptr(&v6), v5))
  {
    std::__throw_future_error[abi:ne180100](2u);
  }
  *(_OWORD *)(a1 + 144) = *(_OWORD *)a2;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(_DWORD *)(a1 + 136) |= 5u;
  std::condition_variable::notify_all((std::condition_variable *)(a1 + 88));
  std::mutex::unlock(v4);
}

void sub_1B7A67B80(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void std::__throw_future_error[abi:ne180100](unsigned int a1)
{
  exception = __cxa_allocate_exception(0x20uLL);
  uint64_t v3 = std::future_category();
  MEMORY[0x1BA9BF6D0](exception, a1, v3);
  __cxa_throw(exception, MEMORY[0x1E4FBA2E8], MEMORY[0x1E4FBA218]);
}

void sub_1B7A67BE8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::thread::thread<void (std::__async_assoc_state<std::shared_ptr<PCBitmap>,std::__async_func<LiAsyncBumpBitmapCreator>>::*)(void),std::__async_assoc_state<std::shared_ptr<PCBitmap>,std::__async_func<LiAsyncBumpBitmapCreator>>*,void>()
{
}

void sub_1B7A67CD0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__thread_struct>::reset[abi:ne180100]((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

uint64_t std::__thread_proxy[abi:ne180100]<std::tuple<std::unique_ptr<std::__thread_struct>,void (std::__async_assoc_state<std::shared_ptr<PCBitmap>,std::__async_func<LiAsyncBumpBitmapCreator>>::*)(void),std::__async_assoc_state<std::shared_ptr<PCBitmap>,std::__async_func<LiAsyncBumpBitmapCreator>>*>>(uint64_t *a1)
{
  int v7 = (const void **)a1;
  uint64_t v1 = std::__thread_local_data();
  uint64_t v2 = *v7;
  *int v7 = 0;
  pthread_setspecific(v1->__key_, v2);
  uint64_t v3 = (void (*)(void *))v7[1];
  uint64_t v4 = (uint64_t)v7[2];
  uint64_t v5 = (char *)v7[3] + (v4 >> 1);
  if (v4) {
    uint64_t v3 = *(void (**)(void *))(*v5 + v3);
  }
  v3(v5);
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,void (std::__async_assoc_state<std::shared_ptr<PCBitmap>,std::__async_func<LiAsyncBumpBitmapCreator>>::*)(void),std::__async_assoc_state<std::shared_ptr<PCBitmap>,std::__async_func<LiAsyncBumpBitmapCreator>>*>>::reset[abi:ne180100]((uint64_t **)&v7, 0);
  return 0;
}

void sub_1B7A67DB8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,void (std::__async_assoc_state<std::shared_ptr<PCBitmap>,std::__async_func<LiAsyncBumpBitmapCreator>>::*)(void),std::__async_assoc_state<std::shared_ptr<PCBitmap>,std::__async_func<LiAsyncBumpBitmapCreator>>*>>::reset[abi:ne180100]((uint64_t **)va, 0);
  _Unwind_Resume(a1);
}

uint64_t **std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,void (std::__async_assoc_state<std::shared_ptr<PCBitmap>,std::__async_func<LiAsyncBumpBitmapCreator>>::*)(void),std::__async_assoc_state<std::shared_ptr<PCBitmap>,std::__async_func<LiAsyncBumpBitmapCreator>>*>>::reset[abi:ne180100](uint64_t **result, uint64_t *a2)
{
  uint64_t v2 = *result;
  *uint64_t result = a2;
  if (v2)
  {
    std::unique_ptr<std::__thread_struct>::reset[abi:ne180100](v2, 0);
    JUMPOUT(0x1BA9BFBA0);
  }
  return result;
}

uint64_t std::unique_ptr<std::__thread_struct>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    MEMORY[0x1BA9BF880]();
    JUMPOUT(0x1BA9BFBA0);
  }
  return result;
}

void std::__assoc_sub_state::__attach_future[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 24);
  std::mutex::lock((std::mutex *)(a1 + 24));
  int v3 = *(_DWORD *)(a1 + 136);
  if ((v3 & 2) != 0) {
    std::__throw_future_error[abi:ne180100](1u);
  }
  atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 8), 1uLL, memory_order_relaxed);
  *(_DWORD *)(a1 + 136) = v3 | 2;

  std::mutex::unlock(v2);
}

void sub_1B7A67EEC(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void std::__deferred_assoc_state<std::shared_ptr<PCBitmap>,std::__async_func<LiAsyncBumpBitmapCreator>>::~__deferred_assoc_state(uint64_t a1)
{
  *(void *)a1 = &unk_1F1118CA0;
  uint64_t v2 = *(atomic_ullong **)(a1 + 176);
  if (v2 && !atomic_fetch_add(v2 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
    (*(void (**)(atomic_ullong *))(*v2 + 16))(v2);
  }
  *(void *)a1 = MEMORY[0x1E4FBA480] + 16;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));

  std::__shared_count::~__shared_count((std::__shared_count *)a1);
}

{
  atomic_ullong *v2;
  uint64_t vars8;

  *(void *)a1 = &unk_1F1118CA0;
  uint64_t v2 = *(atomic_ullong **)(a1 + 176);
  if (v2 && !atomic_fetch_add(v2 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
    (*(void (**)(atomic_ullong *))(*v2 + 16))(v2);
  }
  *(void *)a1 = MEMORY[0x1E4FBA480] + 16;
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)(a1 + 16));
  std::__shared_count::~__shared_count((std::__shared_count *)a1);

  JUMPOUT(0x1BA9BFBA0);
}

void std::__deferred_assoc_state<std::shared_ptr<PCBitmap>,std::__async_func<LiAsyncBumpBitmapCreator>>::__execute(uint64_t a1)
{
  LiAsyncBumpBitmapCreator::operator()((const PCHash128 *)(a1 + 160), &v2);
  std::__assoc_state<std::shared_ptr<PCBitmap>>::set_value<std::shared_ptr<PCBitmap>>(a1, (uint64_t)&v2);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
}

void sub_1B7A680E8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  __cxa_begin_catch(a1);
  std::current_exception();
  v14.__ptr_ = &a10;
  std::__assoc_sub_state::set_exception(v12, v14);
  std::exception_ptr::~exception_ptr(&a10);
  __cxa_end_catch();
  JUMPOUT(0x1B7A680D8);
}

void sub_1B7A6812C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
}

void *std::allocate_shared[abi:ne180100]<BumpTextureImpl,std::allocator<BumpTextureImpl>,PCURL const&,LiBumpTextureInfo const&,void>@<X0>(void *a1@<X8>)
{
  uint64_t v2 = operator new(0x58uLL);
  uint64_t result = std::__shared_ptr_emplace<BumpTextureImpl>::__shared_ptr_emplace[abi:ne180100]<PCURL const&,LiBumpTextureInfo const&,std::allocator<BumpTextureImpl>,0>(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1B7A68198(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<BumpTextureImpl>::__shared_ptr_emplace[abi:ne180100]<PCURL const&,LiBumpTextureInfo const&,std::allocator<BumpTextureImpl>,0>(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F1118CE8;
  BumpTextureImpl::BumpTextureImpl((uint64_t)(a1 + 3));
  return a1;
}

void sub_1B7A681F4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<BumpTextureImpl>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1118CE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<BumpTextureImpl>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1118CE8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_emplace<BumpTextureImpl>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t OUTLINED_FUNCTION_0_4(uint64_t result)
{
  return result;
}

uint64_t LiCreateBumpBitmapAsync(uint64_t result, atomic_ullong *a2)
{
  if ((result & 1) == 0 && !atomic_fetch_add(a2 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
    return (*(uint64_t (**)(atomic_ullong *))(*a2 + 16))(a2);
  }
  return result;
}

uint64_t LiCreateBumpBitmapAsync(uint64_t a1)
{
  uint64_t result = OUTLINED_FUNCTION_0_4(a1);
  if (!v2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
  }
  return result;
}

float LiEquirectProject::computeDistanceToImagePlane(LiEquirectProject *this, float a2, float a3)
{
  float v3 = a3 * 180.0 / 3.14159265;
  return computeDistanceToEquirectImagePlane(a2, v3, this);
}

uint64_t LiEquirectProject::LiEquirectProject(uint64_t a1, const PCSharedCount *a2, int a3, int a4, _DWORD *a5, char a6, float a7)
{
  *(void *)(a1 + 88) = &unk_1F1199AC8;
  *(void *)(a1 + 96) = 0;
  *(unsigned char *)(a1 + 104) = 1;
  LiImageFilter::LiImageFilter((LiImageFilter *)a1, (uint64_t *)&off_1F1118E48);
  *(void *)a1 = &unk_1F1118D40;
  *(void *)(a1 + 88) = &unk_1F1118E28;
  *(_DWORD *)(a1 + 36) = a3;
  *(_DWORD *)(a1 + 40) = a4;
  *(float *)(a1 + 44) = a7;
  *(_DWORD *)(a1 + 48) = *a5;
  *(_DWORD *)(a1 + 52) = a5[1];
  *(_DWORD *)(a1 + 56) = a5[2];
  *(_DWORD *)(a1 + 60) = a5[3];
  *(_DWORD *)(a1 + 64) = a5[4];
  *(_DWORD *)(a1 + 68) = a5[5];
  *(_DWORD *)(a1 + 72) = a5[6];
  *(_DWORD *)(a1 + 76) = a5[7];
  *(_DWORD *)(a1 + 80) = a5[8];
  *(unsigned char *)(a1 + 84) = a6;
  *(PCSharedCount *)(a1 + 16) = (PCSharedCount)a2->var0;
  PCSharedCount::PCSharedCount(&v15, a2 + 1);
  PCSharedCount::operator=((uint64_t *)(a1 + 24), (uint64_t *)&v15);
  PCSharedCount::~PCSharedCount(&v15);
  return a1;
}

void sub_1B7A684CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  PCSharedCount::~PCSharedCount(&a10);
  LiImageFilter::~LiImageFilter((PCSharedCount *)v10, (const PCString *)&off_1F1118E48);
  *(void *)(v10 + 88) = v12;
  *(unsigned char *)(v10 + 104) = 0;
  PCWeakCount::~PCWeakCount(v11);
  _Unwind_Resume(a1);
}

void LiImageFilter::LiImageFilter(LiImageFilter *this, const LiImageFilter *a2, uint64_t a3)
{
  LiImageSource::LiImageSource((LiImageSource *)this, (uint64_t *)a2 + 1);
  uint64_t v6 = *(void *)a2;
  *int v7 = *(void *)a2;
  *(void *)((char *)this + *(void *)(v6 - 24)) = *((void *)a2 + 5);
  *((void *)this + 2) = *(void *)(a3 + 16);
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 3, (const PCSharedCount *)(a3 + 24));
  *((_DWORD *)this + 8) = *(_DWORD *)(a3 + 32);
}

void sub_1B7A685F0(_Unwind_Exception *a1)
{
  OZChannelBase::setRangeName(v1, v2);
  _Unwind_Resume(a1);
}

void LiEquirectProject::LiEquirectProject(LiEquirectProject *this, const LiEquirectProject *a2)
{
  *((void *)this + 11) = &unk_1F1199AC8;
  *((void *)this + 12) = 0;
  *((unsigned char *)this + 104) = 1;
  LiImageFilter::LiImageFilter(this, (const LiImageFilter *)&off_1F1118E48, (uint64_t)a2);
  *(void *)this = &unk_1F1118D40;
  *((void *)this + 11) = &unk_1F1118E28;
  *(void *)((char *)this + 36) = *(void *)((char *)a2 + 36);
  *((_DWORD *)this + 11) = *((_DWORD *)a2 + 11);
  *((_DWORD *)this + 12) = *((_DWORD *)a2 + 12);
  *((_DWORD *)this + 13) = *((_DWORD *)a2 + 13);
  *((_DWORD *)this + 14) = *((_DWORD *)a2 + 14);
  *((_DWORD *)this + 15) = *((_DWORD *)a2 + 15);
  *((_DWORD *)this + 16) = *((_DWORD *)a2 + 16);
  *((_DWORD *)this + 17) = *((_DWORD *)a2 + 17);
  *((_DWORD *)this + 18) = *((_DWORD *)a2 + 18);
  *((_DWORD *)this + 19) = *((_DWORD *)a2 + 19);
  *((_DWORD *)this + 20) = *((_DWORD *)a2 + 20);
  *((unsigned char *)this + 84) = *((unsigned char *)a2 + 84);
}

void sub_1B7A6871C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 88) = v2;
  *(unsigned char *)(v1 + 104) = 0;
  PCWeakCount::~PCWeakCount(v3);
  _Unwind_Resume(a1);
}

void LiEquirectProject::clone(LiEquirectProject *this)
{
}

void sub_1B7A68780(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1 + 1);
  _Unwind_Resume(a1);
}

void PCMakePtr<LiEquirectProject,LiEquirectProject const&>()
{
}

void sub_1B7A68814(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C408093706CLL);
  _Unwind_Resume(a1);
}

uint64_t LiEquirectProject::filteredEdges(LiEquirectProject *this)
{
  return 0;
}

uint64_t LiEquirectProject::pixelTransformSupport()
{
  return 0;
}

void LiEquirectProject::getHelium(LiImageSource **this, LiAgent *a2)
{
  uint64_t v4 = (long long *)*((void *)a2 + 20);
  long long v5 = v4[3];
  long long v7 = *v4;
  long long v6 = v4[1];
  v32[2] = v4[2];
  v32[3] = v5;
  v32[0] = v7;
  v32[1] = v6;
  long long v8 = v4[7];
  long long v10 = v4[4];
  long long v9 = v4[5];
  v32[6] = v4[6];
  v32[7] = v8;
  float v32[4] = v10;
  v32[5] = v9;
  uint64_t v31 = 0x3FF0000000000000;
  uint64_t v28 = 0x3FF0000000000000;
  uint64_t v25 = 0x3FF0000000000000;
  uint64_t v22 = 0x3FF0000000000000;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  if (PCMatrix44Tmpl<double>::determinant((double *)v32) >= 0.000001) {
    PCMatrix44Tmpl<double>::invert((double *)&v22, (double *)v32, 0.0);
  }
  else {
    PCMatrix44Tmpl<double>::planarInverseZ((uint64_t)&v22, (double *)v32, 0.0);
  }
  LiAgent::getHelium(a2, this[2], &v21);
  uint64_t v11 = 0;
  uint64_t v12 = (char *)(this + 6);
  for (uint64_t i = &v15; ; i += 32)
  {
    for (uint64_t j = 0; j != 3; ++j)
      *(double *)&i[8 * j] = *(float *)&v12[4 * j];
    ++v11;
    v12 += 12;
    if (v11 == 3)
    {
      uint64_t v16 = 0;
      uint64_t v17 = 0;
      long long v18 = 0u;
      long long v19 = 0u;
      uint64_t v20 = 0x3FF0000000000000;
      NewEquirectProjectNode();
    }
  }
}

void sub_1B7A68A2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
  if (a26) {
    (*(void (**)(uint64_t))(*(void *)a26 + 24))(a26);
  }
  _Unwind_Resume(exception_object);
}

void LiEquirectProject::~LiEquirectProject(PCSharedCount *this)
{
  *(void *)(v1 + 88) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 104) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 96));
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)(v1 + 88) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 104) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 96));

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'LiEquirectProject::~LiEquirectProject(LiEquirectProject *this)
{
  *(void *)(v1 + 88) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 104) = 0;
  uint64_t v2 = (PC_Sp_counted_base **)(v1 + 96);

  PCWeakCount::~PCWeakCount(v2);
}

{
  LiEquirectProject::~LiEquirectProject((PCSharedCount *)((char *)this + *(void *)(*(void *)this - 24)));
}

uint64_t ProShade::Output::Output(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  *(void *)a1 = &unk_1F11193B8;
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a3 + 8);
  *(void *)(a1 + 16) = *(void *)(a3 + 16);
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 24), (const PCSharedCount *)(a3 + 24));
  *(void *)a1 = &unk_1F1119118;
  uint64_t v5 = *a2;
  *(void *)(a1 + 32) = *a2;
  if (v5) {
    atomic_fetch_add((atomic_uint *volatile)(v5 - 12), 1u);
  }
  return a1;
}

void ProShade::VertexProgram::VertexProgram(PCSharedCount *this)
{
  LiString::LiString((LiString *)v24, "gl_Position");
  this->var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  this[2].var0 = 0;
  PCSharedCount::PCSharedCount(this + 3);
  this->var0 = (PC_Sp_counted_base *)&unk_1F1119118;
  uint64_t v2 = v24[0];
  this[4].var0 = (PC_Sp_counted_base *)v24[0];
  if (v2)
  {
    atomic_fetch_add((atomic_uint *volatile)(v2 - 12), 1u);
    if (v24[0])
    {
      if (atomic_fetch_add((atomic_uint *volatile)(v24[0] - 12), 0xFFFFFFFF) == 1)
      {
        *(unsigned char *)v24[0] = 0;
        if (v24[0]) {
          float v3 = (void *)(v24[0] - 12);
        }
        else {
          float v3 = 0;
        }
        free(v3);
      }
    }
  }
  LiString::LiString((LiString *)v24, "gl_PointSize");
  this[5].var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  this[7].var0 = 0;
  PCSharedCount::PCSharedCount(this + 8);
  this[5].var0 = (PC_Sp_counted_base *)&unk_1F1119118;
  uint64_t v4 = v24[0];
  this[9].var0 = (PC_Sp_counted_base *)v24[0];
  if (v4)
  {
    atomic_fetch_add((atomic_uint *volatile)(v4 - 12), 1u);
    if (v24[0])
    {
      if (atomic_fetch_add((atomic_uint *volatile)(v24[0] - 12), 0xFFFFFFFF) == 1)
      {
        *(unsigned char *)v24[0] = 0;
        if (v24[0]) {
          uint64_t v5 = (void *)(v24[0] - 12);
        }
        else {
          uint64_t v5 = 0;
        }
        free(v5);
      }
    }
  }
  LiString::LiString((LiString *)v24, "gl_ClipVertex");
  this[10].var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  this[12].var0 = 0;
  PCSharedCount::PCSharedCount(this + 13);
  this[10].var0 = (PC_Sp_counted_base *)&unk_1F1119118;
  uint64_t v6 = v24[0];
  this[14].var0 = (PC_Sp_counted_base *)v24[0];
  if (v6)
  {
    atomic_fetch_add((atomic_uint *volatile)(v6 - 12), 1u);
    if (v24[0])
    {
      if (atomic_fetch_add((atomic_uint *volatile)(v24[0] - 12), 0xFFFFFFFF) == 1)
      {
        *(unsigned char *)v24[0] = 0;
        if (v24[0]) {
          long long v7 = (void *)(v24[0] - 12);
        }
        else {
          long long v7 = 0;
        }
        free(v7);
      }
    }
  }
  LiString::LiString((LiString *)v24, "gl_FrontColor");
  this[15].var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  this[17].var0 = 0;
  PCSharedCount::PCSharedCount(this + 18);
  this[15].var0 = (PC_Sp_counted_base *)&unk_1F1119118;
  uint64_t v8 = v24[0];
  this[19].var0 = (PC_Sp_counted_base *)v24[0];
  if (v8)
  {
    atomic_fetch_add((atomic_uint *volatile)(v8 - 12), 1u);
    if (v24[0])
    {
      if (atomic_fetch_add((atomic_uint *volatile)(v24[0] - 12), 0xFFFFFFFF) == 1)
      {
        *(unsigned char *)v24[0] = 0;
        if (v24[0]) {
          long long v9 = (void *)(v24[0] - 12);
        }
        else {
          long long v9 = 0;
        }
        free(v9);
      }
    }
  }
  LiString::LiString((LiString *)v24, "gl_BackColor");
  this[20].var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  this[22].var0 = 0;
  PCSharedCount::PCSharedCount(this + 23);
  this[20].var0 = (PC_Sp_counted_base *)&unk_1F1119118;
  uint64_t v10 = v24[0];
  this[24].var0 = (PC_Sp_counted_base *)v24[0];
  if (v10)
  {
    atomic_fetch_add((atomic_uint *volatile)(v10 - 12), 1u);
    if (v24[0])
    {
      if (atomic_fetch_add((atomic_uint *volatile)(v24[0] - 12), 0xFFFFFFFF) == 1)
      {
        *(unsigned char *)v24[0] = 0;
        if (v24[0]) {
          uint64_t v11 = (void *)(v24[0] - 12);
        }
        else {
          uint64_t v11 = 0;
        }
        free(v11);
      }
    }
  }
  LiString::LiString((LiString *)v24, "gl_FrontSecondaryColor");
  this[25].var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  this[27].var0 = 0;
  PCSharedCount::PCSharedCount(this + 28);
  this[25].var0 = (PC_Sp_counted_base *)&unk_1F1119118;
  uint64_t v12 = v24[0];
  this[29].var0 = (PC_Sp_counted_base *)v24[0];
  if (v12)
  {
    atomic_fetch_add((atomic_uint *volatile)(v12 - 12), 1u);
    if (v24[0])
    {
      if (atomic_fetch_add((atomic_uint *volatile)(v24[0] - 12), 0xFFFFFFFF) == 1)
      {
        *(unsigned char *)v24[0] = 0;
        if (v24[0]) {
          long long v13 = (void *)(v24[0] - 12);
        }
        else {
          long long v13 = 0;
        }
        free(v13);
      }
    }
  }
  LiString::LiString((LiString *)v24, "gl_BackSecondaryColor");
  this[30].var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  this[32].var0 = 0;
  PCSharedCount::PCSharedCount(this + 33);
  this[30].var0 = (PC_Sp_counted_base *)&unk_1F1119118;
  uint64_t v14 = v24[0];
  this[34].var0 = (PC_Sp_counted_base *)v24[0];
  if (v14)
  {
    atomic_fetch_add((atomic_uint *volatile)(v14 - 12), 1u);
    if (v24[0])
    {
      if (atomic_fetch_add((atomic_uint *volatile)(v24[0] - 12), 0xFFFFFFFF) == 1)
      {
        *(unsigned char *)v24[0] = 0;
        if (v24[0]) {
          char v15 = (void *)(v24[0] - 12);
        }
        else {
          char v15 = 0;
        }
        free(v15);
      }
    }
  }
  for (uint64_t i = 0; i != 40; i += 5)
  {
    uint64_t v17 = &this[i];
    v17[35].var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
    v17[37].var0 = 0;
    PCSharedCount::PCSharedCount(&this[i + 38]);
    v17[35].var0 = (PC_Sp_counted_base *)&unk_1F1119118;
    v17[39].var0 = 0;
  }
  LiString::LiString((LiString *)v24, "gl_FogFragCoord");
  this[75].var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  this[77].var0 = 0;
  PCSharedCount::PCSharedCount(this + 78);
  this[75].var0 = (PC_Sp_counted_base *)&unk_1F1119118;
  uint64_t v18 = v24[0];
  this[79].var0 = (PC_Sp_counted_base *)v24[0];
  if (v18)
  {
    atomic_fetch_add((atomic_uint *volatile)(v18 - 12), 1u);
    if (v24[0])
    {
      if (atomic_fetch_add((atomic_uint *volatile)(v24[0] - 12), 0xFFFFFFFF) == 1)
      {
        *(unsigned char *)v24[0] = 0;
        if (v24[0]) {
          long long v19 = (void *)(v24[0] - 12);
        }
        else {
          long long v19 = 0;
        }
        free(v19);
      }
    }
  }
  uint64_t v20 = 0;
  for (uint64_t j = (LiString *)&this[39]; ; uint64_t j = (LiString *)((char *)j + 40))
  {
    LiString::format((LiString *)"gl_TexCoord[%d]", (LiString *)v24, v20);
    if (j != (LiString *)v24)
    {
      LiString::dec(j);
      uint64_t v22 = v24[0];
      *(void *)uint64_t j = v24[0];
      if (!v22) {
        goto LABEL_69;
      }
      atomic_fetch_add((atomic_uint *volatile)(v22 - 12), 1u);
    }
    if (v24[0] && atomic_fetch_add((atomic_uint *volatile)(v24[0] - 12), 0xFFFFFFFF) == 1)
    {
      *(unsigned char *)v24[0] = 0;
      if (v24[0]) {
        long long v23 = (void *)(v24[0] - 12);
      }
      else {
        long long v23 = 0;
      }
      free(v23);
    }
LABEL_69:
    if (++v20 == 8) {
      ProShade::Func<ProShade::Func_ftransform>::eval();
    }
  }
}

void sub_1B7A6936C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCSharedCount *a11, PCSharedCount *a12, PCSharedCount *a13, PCSharedCount *a14, uint64_t a15)
{
  PCSharedCount::~PCSharedCount(v16 + 3);
  ProShade::Output::~Output(v19);
  for (uint64_t i = 70; i != 30; i -= 5)
    ProShade::Output::~Output(&v15[i]);
  ProShade::Output::~Output(v18);
  ProShade::Output::~Output(v17);
  ProShade::Output::~Output(a11);
  ProShade::Output::~Output(a12);
  ProShade::Output::~Output(a13);
  ProShade::Output::~Output(a14);
  ProShade::Output::~Output(v15);
  _Unwind_Resume(a1);
}

void ProShade::Output::~Output(PCSharedCount *this)
{
  this->var0 = (PC_Sp_counted_base *)&unk_1F1119118;
  LiString::dec((LiString *)&this[4]);
  this->var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(this + 3);
}

{
  uint64_t vars8;

  this->var0 = (PC_Sp_counted_base *)&unk_1F1119118;
  LiString::dec((LiString *)&this[4]);
  this->var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(this + 3);

  JUMPOUT(0x1BA9BFBA0);
}

PCSharedCount *ProShade::VarT<ProShade::Node>::~VarT(PCSharedCount *a1)
{
  a1->var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(a1 + 3);
  return a1;
}

void ProShade::VertexProgram::addOutputs(const PCSharedCount *a1, uint64_t a2)
{
  if (a1[2].var0)
  {
    int v4 = *(_DWORD *)(a2 + 12);
    int v5 = *(_DWORD *)(a2 + 8) <= v4 ? (2 * (v4 + 1)) | 1 : *(_DWORD *)(a2 + 8);
    PCArray<ProShade::Output,PCArray_Traits<ProShade::Output>>::resize(a2, v4 + 1, v5);
    uint64_t v6 = *(void *)(a2 + 16);
    uint64_t v7 = *(int *)(a2 + 12) - 1;
    ProShade::VarT<ProShade::Node>::operator=(v6 + 40 * v7, a1);
    if ((const PCSharedCount *)(v6 + 40 * v7) != a1)
    {
      uint64_t v8 = v6 + 40 * v7;
      LiString::dec((LiString *)(v8 + 32));
      var0 = a1[4].var0;
      *(void *)(v8 + 32) = var0;
      if (var0) {
        atomic_fetch_add((atomic_uint *volatile)var0 - 3, 1u);
      }
    }
  }
  if (a1[7].var0)
  {
    int v10 = *(_DWORD *)(a2 + 12);
    int v11 = *(_DWORD *)(a2 + 8) <= v10 ? (2 * (v10 + 1)) | 1 : *(_DWORD *)(a2 + 8);
    PCArray<ProShade::Output,PCArray_Traits<ProShade::Output>>::resize(a2, v10 + 1, v11);
    uint64_t v12 = *(void *)(a2 + 16);
    uint64_t v13 = *(int *)(a2 + 12) - 1;
    ProShade::VarT<ProShade::Node>::operator=(v12 + 40 * v13, a1 + 5);
    if ((const PCSharedCount *)(v12 + 40 * v13) != &a1[5])
    {
      uint64_t v14 = v12 + 40 * v13;
      LiString::dec((LiString *)(v14 + 32));
      char v15 = a1[9].var0;
      *(void *)(v14 + 32) = v15;
      if (v15) {
        atomic_fetch_add((atomic_uint *volatile)v15 - 3, 1u);
      }
    }
  }
  if (a1[12].var0)
  {
    int v16 = *(_DWORD *)(a2 + 12);
    int v17 = *(_DWORD *)(a2 + 8) <= v16 ? (2 * (v16 + 1)) | 1 : *(_DWORD *)(a2 + 8);
    PCArray<ProShade::Output,PCArray_Traits<ProShade::Output>>::resize(a2, v16 + 1, v17);
    uint64_t v18 = *(void *)(a2 + 16);
    uint64_t v19 = *(int *)(a2 + 12) - 1;
    ProShade::VarT<ProShade::Node>::operator=(v18 + 40 * v19, a1 + 10);
    if ((const PCSharedCount *)(v18 + 40 * v19) != &a1[10])
    {
      uint64_t v20 = v18 + 40 * v19;
      LiString::dec((LiString *)(v20 + 32));
      uint64_t v21 = a1[14].var0;
      *(void *)(v20 + 32) = v21;
      if (v21) {
        atomic_fetch_add((atomic_uint *volatile)v21 - 3, 1u);
      }
    }
  }
  if (a1[17].var0)
  {
    int v22 = *(_DWORD *)(a2 + 12);
    int v23 = *(_DWORD *)(a2 + 8) <= v22 ? (2 * (v22 + 1)) | 1 : *(_DWORD *)(a2 + 8);
    PCArray<ProShade::Output,PCArray_Traits<ProShade::Output>>::resize(a2, v22 + 1, v23);
    uint64_t v24 = *(void *)(a2 + 16);
    uint64_t v25 = *(int *)(a2 + 12) - 1;
    ProShade::VarT<ProShade::Node>::operator=(v24 + 40 * v25, a1 + 15);
    if ((const PCSharedCount *)(v24 + 40 * v25) != &a1[15])
    {
      uint64_t v26 = v24 + 40 * v25;
      LiString::dec((LiString *)(v26 + 32));
      long long v27 = a1[19].var0;
      *(void *)(v26 + 32) = v27;
      if (v27) {
        atomic_fetch_add((atomic_uint *volatile)v27 - 3, 1u);
      }
    }
  }
  if (a1[22].var0)
  {
    int v28 = *(_DWORD *)(a2 + 12);
    int v29 = *(_DWORD *)(a2 + 8) <= v28 ? (2 * (v28 + 1)) | 1 : *(_DWORD *)(a2 + 8);
    PCArray<ProShade::Output,PCArray_Traits<ProShade::Output>>::resize(a2, v28 + 1, v29);
    uint64_t v30 = *(void *)(a2 + 16);
    uint64_t v31 = *(int *)(a2 + 12) - 1;
    ProShade::VarT<ProShade::Node>::operator=(v30 + 40 * v31, a1 + 20);
    if ((const PCSharedCount *)(v30 + 40 * v31) != &a1[20])
    {
      uint64_t v32 = v30 + 40 * v31;
      LiString::dec((LiString *)(v32 + 32));
      uint64_t v33 = a1[24].var0;
      *(void *)(v32 + 32) = v33;
      if (v33) {
        atomic_fetch_add((atomic_uint *volatile)v33 - 3, 1u);
      }
    }
  }
  if (a1[27].var0)
  {
    int v34 = *(_DWORD *)(a2 + 12);
    int v35 = *(_DWORD *)(a2 + 8) <= v34 ? (2 * (v34 + 1)) | 1 : *(_DWORD *)(a2 + 8);
    PCArray<ProShade::Output,PCArray_Traits<ProShade::Output>>::resize(a2, v34 + 1, v35);
    uint64_t v36 = *(void *)(a2 + 16);
    uint64_t v37 = *(int *)(a2 + 12) - 1;
    ProShade::VarT<ProShade::Node>::operator=(v36 + 40 * v37, a1 + 25);
    if ((const PCSharedCount *)(v36 + 40 * v37) != &a1[25])
    {
      uint64_t v38 = v36 + 40 * v37;
      LiString::dec((LiString *)(v38 + 32));
      int v39 = a1[29].var0;
      *(void *)(v38 + 32) = v39;
      if (v39) {
        atomic_fetch_add((atomic_uint *volatile)v39 - 3, 1u);
      }
    }
  }
  if (a1[32].var0)
  {
    int v40 = *(_DWORD *)(a2 + 12);
    int v41 = *(_DWORD *)(a2 + 8) <= v40 ? (2 * (v40 + 1)) | 1 : *(_DWORD *)(a2 + 8);
    PCArray<ProShade::Output,PCArray_Traits<ProShade::Output>>::resize(a2, v40 + 1, v41);
    uint64_t v42 = *(void *)(a2 + 16);
    uint64_t v43 = *(int *)(a2 + 12) - 1;
    ProShade::VarT<ProShade::Node>::operator=(v42 + 40 * v43, a1 + 30);
    if ((const PCSharedCount *)(v42 + 40 * v43) != &a1[30])
    {
      uint64_t v44 = v42 + 40 * v43;
      LiString::dec((LiString *)(v44 + 32));
      int v45 = a1[34].var0;
      *(void *)(v44 + 32) = v45;
      if (v45) {
        atomic_fetch_add((atomic_uint *volatile)v45 - 3, 1u);
      }
    }
  }
  for (uint64_t i = 0; i != 40; i += 5)
  {
    if (a1[i + 37].var0)
    {
      int v47 = *(_DWORD *)(a2 + 12);
      int v48 = *(_DWORD *)(a2 + 8) <= v47 ? (2 * (v47 + 1)) | 1 : *(_DWORD *)(a2 + 8);
      PCArray<ProShade::Output,PCArray_Traits<ProShade::Output>>::resize(a2, v47 + 1, v48);
      uint64_t v49 = *(void *)(a2 + 16);
      uint64_t v50 = *(int *)(a2 + 12) - 1;
      ProShade::VarT<ProShade::Node>::operator=(v49 + 40 * v50, &a1[i + 35]);
      if (&a1[i + 35] != (const PCSharedCount *)(v49 + 40 * v50))
      {
        uint64_t v51 = v49 + 40 * v50;
        LiString::dec((LiString *)(v51 + 32));
        uint64_t v52 = a1[i + 39].var0;
        *(void *)(v51 + 32) = v52;
        if (v52) {
          atomic_fetch_add((atomic_uint *volatile)v52 - 3, 1u);
        }
      }
    }
  }
  if (a1[77].var0)
  {
    int v53 = *(_DWORD *)(a2 + 12);
    if (*(_DWORD *)(a2 + 8) <= v53) {
      int v54 = (2 * (v53 + 1)) | 1;
    }
    else {
      int v54 = *(_DWORD *)(a2 + 8);
    }
    PCArray<ProShade::Output,PCArray_Traits<ProShade::Output>>::resize(a2, v53 + 1, v54);
    uint64_t v55 = *(void *)(a2 + 16);
    uint64_t v56 = *(int *)(a2 + 12) - 1;
    ProShade::VarT<ProShade::Node>::operator=(v55 + 40 * v56, a1 + 75);
    if ((const PCSharedCount *)(v55 + 40 * v56) != &a1[75])
    {
      uint64_t v57 = v55 + 40 * v56;
      LiString::dec((LiString *)(v57 + 32));
      int v58 = a1[79].var0;
      *(void *)(v57 + 32) = v58;
      if (v58) {
        atomic_fetch_add((atomic_uint *volatile)v58 - 3, 1u);
      }
    }
  }
}

void ProShade::FragmentProgram::FragmentProgram(PCSharedCount *this)
{
  LiString::LiString((LiString *)v12, "gl_FragColor");
  this->var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  this[2].var0 = 0;
  PCSharedCount::PCSharedCount(this + 3);
  this->var0 = (PC_Sp_counted_base *)&unk_1F1119118;
  uint64_t v2 = v12[0];
  this[4].var0 = (PC_Sp_counted_base *)v12[0];
  if (v2)
  {
    atomic_fetch_add((atomic_uint *volatile)(v2 - 12), 1u);
    if (v12[0])
    {
      if (atomic_fetch_add((atomic_uint *volatile)(v12[0] - 12), 0xFFFFFFFF) == 1)
      {
        *(unsigned char *)v12[0] = 0;
        if (v12[0]) {
          float v3 = (void *)(v12[0] - 12);
        }
        else {
          float v3 = 0;
        }
        free(v3);
      }
    }
  }
  LiString::LiString((LiString *)v12, "gl_FragDepth");
  this[5].var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  this[7].var0 = 0;
  PCSharedCount::PCSharedCount(this + 8);
  this[5].var0 = (PC_Sp_counted_base *)&unk_1F1119118;
  uint64_t v4 = v12[0];
  this[9].var0 = (PC_Sp_counted_base *)v12[0];
  if (v4)
  {
    atomic_fetch_add((atomic_uint *volatile)(v4 - 12), 1u);
    if (v12[0])
    {
      if (atomic_fetch_add((atomic_uint *volatile)(v12[0] - 12), 0xFFFFFFFF) == 1)
      {
        *(unsigned char *)v12[0] = 0;
        if (v12[0]) {
          int v5 = (void *)(v12[0] - 12);
        }
        else {
          int v5 = 0;
        }
        free(v5);
      }
    }
  }
  for (uint64_t i = 0; i != 40; i += 5)
  {
    uint64_t v7 = &this[i];
    v7[10].var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
    v7[12].var0 = 0;
    PCSharedCount::PCSharedCount(&this[i + 13]);
    v7[10].var0 = (PC_Sp_counted_base *)&unk_1F1119118;
    v7[14].var0 = 0;
  }
  uint64_t v8 = 0;
  for (uint64_t j = (LiString *)&this[14]; ; uint64_t j = (LiString *)((char *)j + 40))
  {
    LiString::format((LiString *)"gl_FragData[%d]", (LiString *)v12, v8);
    if (j != (LiString *)v12)
    {
      LiString::dec(j);
      uint64_t v10 = v12[0];
      *(void *)uint64_t j = v12[0];
      if (!v10) {
        goto LABEL_27;
      }
      atomic_fetch_add((atomic_uint *volatile)(v10 - 12), 1u);
    }
    if (v12[0] && atomic_fetch_add((atomic_uint *volatile)(v12[0] - 12), 0xFFFFFFFF) == 1)
    {
      *(unsigned char *)v12[0] = 0;
      if (v12[0]) {
        int v11 = (void *)(v12[0] - 12);
      }
      else {
        int v11 = 0;
      }
      free(v11);
    }
LABEL_27:
    if (++v8 == 8) {
      operator new();
    }
  }
}

void sub_1B7A6A0B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, PCSharedCount *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  *(void *)(v30 - 120) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v25 + 3);
  PCSharedCount::~PCSharedCount(v27);
  PCSharedCount::~PCSharedCount(v29);
  PCSharedCount::~PCSharedCount(v28);
  PCSharedCount::~PCSharedCount(v26);
  for (uint64_t i = 45; i != 5; i -= 5)
    ProShade::Output::~Output(&v24[i]);
  ProShade::Output::~Output(a11);
  ProShade::Output::~Output(v24);
  _Unwind_Resume(a1);
}

void sub_1B7A6A288()
{
  for (; v1; v1 -= 40)
    ProShade::Output::~Output((PCSharedCount *)(v0 + 40 + v1));
  JUMPOUT(0x1B7A6A270);
}

void ProShade::FragmentProgram::addOutputs(const PCSharedCount *a1, uint64_t a2)
{
  if (a1[2].var0)
  {
    int v4 = *(_DWORD *)(a2 + 12);
    int v5 = *(_DWORD *)(a2 + 8) <= v4 ? (2 * (v4 + 1)) | 1 : *(_DWORD *)(a2 + 8);
    PCArray<ProShade::Output,PCArray_Traits<ProShade::Output>>::resize(a2, v4 + 1, v5);
    uint64_t v6 = *(void *)(a2 + 16);
    uint64_t v7 = *(int *)(a2 + 12) - 1;
    ProShade::VarT<ProShade::Node>::operator=(v6 + 40 * v7, a1);
    if ((const PCSharedCount *)(v6 + 40 * v7) != a1)
    {
      uint64_t v8 = v6 + 40 * v7;
      LiString::dec((LiString *)(v8 + 32));
      var0 = a1[4].var0;
      *(void *)(v8 + 32) = var0;
      if (var0) {
        atomic_fetch_add((atomic_uint *volatile)var0 - 3, 1u);
      }
    }
  }
  if (a1[7].var0)
  {
    int v10 = *(_DWORD *)(a2 + 12);
    int v11 = *(_DWORD *)(a2 + 8) <= v10 ? (2 * (v10 + 1)) | 1 : *(_DWORD *)(a2 + 8);
    PCArray<ProShade::Output,PCArray_Traits<ProShade::Output>>::resize(a2, v10 + 1, v11);
    uint64_t v12 = *(void *)(a2 + 16);
    uint64_t v13 = *(int *)(a2 + 12) - 1;
    ProShade::VarT<ProShade::Node>::operator=(v12 + 40 * v13, a1 + 5);
    if ((const PCSharedCount *)(v12 + 40 * v13) != &a1[5])
    {
      uint64_t v14 = v12 + 40 * v13;
      LiString::dec((LiString *)(v14 + 32));
      char v15 = a1[9].var0;
      *(void *)(v14 + 32) = v15;
      if (v15) {
        atomic_fetch_add((atomic_uint *volatile)v15 - 3, 1u);
      }
    }
  }
  for (uint64_t i = 0; i != 40; i += 5)
  {
    if (a1[i + 12].var0)
    {
      int v17 = *(_DWORD *)(a2 + 12);
      if (*(_DWORD *)(a2 + 8) <= v17) {
        int v18 = (2 * (v17 + 1)) | 1;
      }
      else {
        int v18 = *(_DWORD *)(a2 + 8);
      }
      PCArray<ProShade::Output,PCArray_Traits<ProShade::Output>>::resize(a2, v17 + 1, v18);
      uint64_t v19 = *(void *)(a2 + 16);
      uint64_t v20 = *(int *)(a2 + 12) - 1;
      ProShade::VarT<ProShade::Node>::operator=(v19 + 40 * v20, &a1[i + 10]);
      if (&a1[i + 10] != (const PCSharedCount *)(v19 + 40 * v20))
      {
        uint64_t v21 = v19 + 40 * v20;
        LiString::dec((LiString *)(v21 + 32));
        int v22 = a1[i + 14].var0;
        *(void *)(v21 + 32) = v22;
        if (v22) {
          atomic_fetch_add((atomic_uint *volatile)v22 - 3, 1u);
        }
      }
    }
  }
}

void ProShade::InsertUniform::eval(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v6 = ProShade::VarT<ProShade::Node>::frequency(a2);
  if (v6 >= 2)
  {
    ProShade::NodeOperator::apply(a2, (void *)a3);
    return;
  }
  if (v6 != 1) {
    goto LABEL_10;
  }
  uint64_t v7 = *(const void **)(a2 + 16);
  if (v7
  {
    *(void *)a3 = &unk_1F11193B8;
    *(unsigned char *)(a3 + 8) = *(unsigned char *)(a2 + 8);
    *(void *)(a3 + 16) = v7;
LABEL_11:
    PCSharedCount::PCSharedCount((PCSharedCount *)(a3 + 24), (const PCSharedCount *)(a2 + 24));
    return;
  }
  if (ProShade::VarT<ProShade::Node>::hasSource(a2))
  {
LABEL_10:
    *(void *)a3 = &unk_1F11193B8;
    *(unsigned char *)(a3 + 8) = *(unsigned char *)(a2 + 8);
    *(void *)(a3 + 16) = *(void *)(a2 + 16);
    goto LABEL_11;
  }
  __n128 v8 = ProShade::VarT<ProShade::Node>::hash(a2, (__n128 *)&v36);
  LODWORD(v9) = *(_DWORD *)(a1 + 44);
  if ((int)v9 < 1)
  {
LABEL_20:
    if (*(_DWORD *)(a1 + 40) <= (int)v9) {
      int v15 = (2 * (v9 + 1)) | 1;
    }
    else {
      int v15 = *(_DWORD *)(a1 + 40);
    }
    PCArray<ProShade::UniformVariable,PCArray_Traits<ProShade::UniformVariable>>::resize(a1 + 32, v9 + 1, v15);
    uint64_t v16 = *(void *)(a1 + 48) + 72 * *(int *)(a1 + 44) - 72;
    ProShade::VarT<ProShade::Node>::operator=(v16, (const PCSharedCount *)a2);
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    while (1)
    {
      uint64_t v12 = *(void *)(a1 + 48);
      uint64_t v13 = *(void *)(v12 + v10 + 16);
      if (!v13) {
        throw_PCNullPointerException(1);
      }
      uint64_t v14 = (int32x4_t *)(*(uint64_t (**)(uint64_t, void, __n128))(*(void *)v13 + 48))(v13, 0, v8);
      __n128 v8 = (__n128)vmvnq_s8((int8x16_t)vceqq_s32(*v14, v36));
      v8.n128_u64[0] = (unint64_t)vmovn_s32((int32x4_t)v8);
      v8.n128_u16[0] = vmaxv_u16((uint16x4_t)v8.n128_u64[0]);
      if ((v8.n128_u8[0] & 1) == 0) {
        break;
      }
      ++v11;
      uint64_t v9 = *(int *)(a1 + 44);
      v10 += 72;
      if (v11 >= v9) {
        goto LABEL_20;
      }
    }
    uint64_t v16 = v12 + v10;
  }
  uint64_t v30 = v16;
  uint64_t v18 = *(void *)(v16 + 48);
  uint64_t v17 = v16 + 48;
  if (!v18)
  {
    uint64_t v29 = v17;
    uint64_t v19 = *(void *)(a2 + 16);
    if (!v19) {
      throw_PCNullPointerException(1);
    }
    uint64_t v20 = *(atomic_uint **)(v19 + 32);
    if (v20)
    {
      atomic_fetch_add(v20 - 3, 1u);
      v36.i64[0] = (uint64_t)v20;
      atomic_fetch_add(v20 - 3, 1u);
      if (v36.i64[0] && *(_DWORD *)(v36.i64[0] - 8))
      {
        uint64_t v21 = 0;
        uint64_t v32 = (void *)(a1 + 64);
        uint64_t v33 = (uint64_t **)(a1 + 56);
        uint64_t v31 = v20;
        while (v32 != std::__tree<LiString>::find<LiString>((uint64_t)v33, (const char **)&v36))
        {
          LiString::format((LiString *)"_%d", (LiString *)&v35, v21, v29);
          int v22 = v35;
          int v34 = v21;
          if (v35) {
            int v23 = *((_DWORD *)v35 - 2);
          }
          else {
            int v23 = 0;
          }
          size_t v24 = *(v20 - 2);
          size_t v25 = v24 + v23;
          uint64_t v26 = (unsigned int *)malloc_type_malloc(v25 + 13, 0x8903763CuLL);
          v26[1] = v25;
          v26[2] = v25 + 1;
          atomic_store(1u, v26);
          atomic_store(0, v26);
          memcpy(v26 + 3, v20, v24);
          memcpy((char *)v26 + v24 + 12, v22, v23);
          *((unsigned char *)v26 + v25 + 12) = 0;
          atomic_fetch_add((atomic_uint *volatile)v26, 1u);
          if (v36.i64[0] && atomic_fetch_add((atomic_uint *volatile)(v36.i64[0] - 12), 0xFFFFFFFF) == 1)
          {
            *(unsigned char *)v36.i64[0] = 0;
            if (v36.i64[0]) {
              long long v27 = (void *)(v36.i64[0] - 12);
            }
            else {
              long long v27 = 0;
            }
            free(v27);
          }
          v36.i64[0] = (uint64_t)(v26 + 3);
          atomic_fetch_add((atomic_uint *volatile)v26, 1u);
          if (atomic_fetch_add((atomic_uint *volatile)v26, 0xFFFFFFFF) == 1) {
            free(v26);
          }
          uint64_t v20 = v31;
          if (v35 && atomic_fetch_add((atomic_uint *volatile)v35 - 3, 0xFFFFFFFF) == 1)
          {
            *int v35 = 0;
            if (v35) {
              int v28 = v35 - 12;
            }
            else {
              int v28 = 0;
            }
            free(v28);
          }
          uint64_t v21 = (v34 + 1);
        }
        std::__tree<LiString>::__emplace_unique_key_args<LiString,LiString const&>(v33, (const char **)&v36, v36.i64);
      }
    }
    else
    {
      v36.i64[0] = 0;
    }
    operator new();
  }
  *(void *)a3 = &unk_1F11193B8;
  *(unsigned char *)(a3 + 8) = *(unsigned char *)(v30 + 40);
  *(void *)(a3 + 16) = *(void *)(v30 + 48);
  PCSharedCount::PCSharedCount((PCSharedCount *)(a3 + 24), (const PCSharedCount *)(v30 + 56));
}

void sub_1B7A6A964(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, atomic_uint *a17)
{
  MEMORY[0x1BA9BFBA0](v17, 0x10B1C402CAA7C2BLL);
  if (a17 && atomic_fetch_add(a17 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)a17 = 0;
    free(a17 - 3);
  }
  if (v18)
  {
    if (atomic_fetch_add(v18 - 3, 0xFFFFFFFF) == 1)
    {
      *(unsigned char *)uint64_t v18 = 0;
      free(v18 - 3);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t ProShade::VarT<ProShade::Node>::repr(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    throw_PCNullPointerException(1);
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 16);

  return v2();
}

uint64_t ProShade::VarT<ProShade::Node>::frequency(uint64_t a1)
{
  ProShade::VarT<ProShade::Node>::hash(a1, &v4);
  uint64_t v2 = *(void *)(a1 + 16);
  if (!v2) {
    throw_PCNullPointerException(1);
  }
  return *(unsigned int *)(v2 + 40);
}

uint64_t ProShade::VarT<ProShade::Node>::hasSource(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    throw_PCNullPointerException(1);
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 144);

  return v2();
}

uint64_t ProShade::Program::shader(uint64_t a1, uint64_t a2, LiString *a3, LiString *a4)
{
  uint64_t v4 = a2;
  {
    if (liDebug("PSProgram::shader")) {
      int v139 = 2;
    }
    else {
      int v139 = 0;
    }
    ProShade::Program::shader(PCArray<ProShade::Output,PCArray_Traits<ProShade::Output>> &,LiString &,LiString &)::dbg = v139;
    uint64_t v4 = a2;
  }
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v170);
  uint64_t v168 = 0;
  uint64_t v169 = 0;
  uint64_t v166 = 0;
  float32x4_t v167 = &unk_1F1119AF8;
  float32x4_t v164 = &unk_1F1119AF8;
  uint64_t v165 = 0;
  uint64_t v162 = 0;
  uint64_t v163 = 0;
  v160[1] = 0;
  int8x16_t v161 = &unk_1F1119AC0;
  int8x16_t v159 = (uint64_t *)v160;
  v160[0] = 0;
  if (*(int *)(v4 + 12) >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = *(void *)(a2 + 16);
      if ((int)v168 <= SHIDWORD(v168)) {
        int v8 = (2 * (HIDWORD(v168) + 1)) | 1;
      }
      else {
        int v8 = v168;
      }
      PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize((uint64_t)&v167, HIDWORD(v168) + 1, v8);
      uint64_t v9 = (PCArray_base *)ProShade::VarT<ProShade::Node>::operator=(v169 + 32 * SHIDWORD(v168) - 32, (const PCSharedCount *)(v7 + v5));
      ++v6;
      v5 += 40;
    }
    while (v6 < *(int *)(a2 + 12));
    for (int i = HIDWORD(v168); HIDWORD(v168); int i = HIDWORD(v168))
    {
      if (i <= 0) {
        PCArray_base::badIndex(v9);
      }
      v148.__locale_ = (std::locale::__imp *)&unk_1F11193B8;
      LOBYTE(v149) = *(unsigned char *)(v169 + 8);
      float32x4_t v150 = *(PCSharedCount **)(v169 + 16);
      PCSharedCount::PCSharedCount(&v151, (const PCSharedCount *)(v169 + 24));
      if (SHIDWORD(v168) < 2)
      {
        LODWORD(v13) = HIDWORD(v168) - 1;
      }
      else
      {
        uint64_t v11 = 0;
        uint64_t v12 = 0;
        do
        {
          ProShade::VarT<ProShade::Node>::operator=(v169 + v11, (const PCSharedCount *)(v169 + v11 + 32));
          ++v12;
          uint64_t v13 = SHIDWORD(v168) - 1;
          v11 += 32;
        }
        while (v12 < v13);
      }
      if ((int)v168 >= (int)v13) {
        int v14 = v168;
      }
      else {
        int v14 = (2 * v13) | 1;
      }
      PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize((uint64_t)&v167, v13, v14);
      uint64_t Var = ProShade::findVar((uint64_t)&v161, (uint64_t)&v148);
      uint64_t v16 = Var;
      if (!*(unsigned char *)(Var + 56))
      {
        *(unsigned char *)(Var + 56) = 1;
        if (!v150) {
          throw_PCNullPointerException(1);
        }
        uint64_t v17 = (OZChannelBase *)(*((uint64_t (**)(PCSharedCount *))v150->var0 + 9))(v150);
        uint64_t v18 = v17;
        if (v17)
        {
          v145[0].__locale_ = (std::locale::__imp *)OZChannelBase::getSerializer(v17);
          *((void *)std::__tree<std::__value_type<PCHash128,ProShade::Snippet *>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,ProShade::Snippet *>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,ProShade::Snippet *>>>::__emplace_unique_key_args<PCHash128,std::piecewise_construct_t const&,std::tuple<PCHash128 const&>,std::tuple<>>(&v159, v145[0].__locale_, (uint64_t)&std::piecewise_construct, v145)+ 6) = v18;
        }
        ProShade::VarT<ProShade::Node>::inputs(v16);
        if (SHIDWORD(v165) >= 1)
        {
          uint64_t v19 = 0;
          uint64_t v20 = 0;
          do
          {
            uint64_t v21 = (const PCSharedCount *)(v166 + v19);
            uint64_t v22 = ProShade::findVar((uint64_t)&v161, v166 + v19);
            int v23 = *(_DWORD *)(v22 + 44);
            if (*(_DWORD *)(v22 + 40) <= v23) {
              int v24 = (2 * (v23 + 1)) | 1;
            }
            else {
              int v24 = *(_DWORD *)(v22 + 40);
            }
            PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::resize(v22 + 32, v23 + 1, v24);
            *(void *)(*(void *)(v22 + 48) + 8 * *(int *)(v22 + 44) - 8) = v16;
            if ((int)v168 <= SHIDWORD(v168)) {
              int v25 = (2 * (HIDWORD(v168) + 1)) | 1;
            }
            else {
              int v25 = v168;
            }
            PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize((uint64_t)&v167, HIDWORD(v168) + 1, v25);
            ProShade::VarT<ProShade::Node>::operator=(v169 + 32 * SHIDWORD(v168) - 32, v21);
            ++v20;
            v19 += 32;
          }
          while (v20 < SHIDWORD(v165));
        }
      }
      v148.__locale_ = (std::locale::__imp *)&unk_1F11193B8;
      PCSharedCount::~PCSharedCount(&v151);
    }
  }
  v158[0] = 0;
  v158[1] = 0;
  uint64_t v156 = 0;
  float32x4_t v157 = (uint64_t *)v158;
  float32x4_t v154 = &unk_1F1119AC0;
  uint64_t v155 = 0;
  uint64_t v26 = &sprintf_buf[224];
  if (SHIDWORD(v162) < 1)
  {
    int v48 = 0;
  }
  else
  {
    uint64_t v27 = 0;
    do
    {
      uint64_t v28 = *(void *)(v163 + 8 * v27);
      if (ProShade::Program::shader(PCArray<ProShade::Output,PCArray_Traits<ProShade::Output>> &,LiString &,LiString &)::dbg >= 1)
      {
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"depend ", 7);
        uint64_t v29 = (void *)std::ostream::operator<<();
        uint64_t v30 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v29, (uint64_t)" atomic ", 8);
        int v31 = ProShade::VarT<ProShade::Node>::atomic(v28);
        uint64_t v32 = v31 ? "true" : "false";
        uint64_t v33 = v31 ? 4 : 5;
        int v34 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v30, (uint64_t)v32, v33);
        int v35 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v34, (uint64_t)": ", 2);
        ProShade::VarT<ProShade::Node>::repr(v28);
        int32x4_t v36 = v145[0].__locale_ ? (const char *)v145[0].__locale_ : "";
        size_t v37 = strlen(v36);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v35, (uint64_t)v36, v37);
        std::ios_base::getloc((const std::ios_base *)((char *)v35 + *(void *)(*v35 - 24)));
        uint64_t v38 = std::locale::use_facet(&v148, MEMORY[0x1E4FBA258]);
        ((void (*)(const std::locale::facet *, uint64_t))v38->__vftable[2].~facet_0)(v38, 10);
        std::locale::~locale(&v148);
        std::ostream::put();
        std::ostream::flush();
        if (v145[0].__locale_)
        {
          if (atomic_fetch_add((atomic_uint *volatile)v145[0].__locale_ - 3, 0xFFFFFFFF) == 1)
          {
            *(unsigned char *)v145[0].__locale_ = 0;
            if (v145[0].__locale_) {
              int v39 = (char *)v145[0].__locale_ - 12;
            }
            else {
              int v39 = 0;
            }
            free(v39);
          }
        }
      }
      int v40 = (const char **)(*(void *)(v28 + 16) + 32);
      if ((*(int *)(v28 + 44) > 1 || *v40 && *((_DWORD *)*v40 - 2))
        && (ProShade::VarT<ProShade::Node>::atomic(v28) & 1) == 0)
      {
        int v41 = std::__tree<LiString>::find<LiString>((uint64_t)&v157, v40);
        if (v158 == v41) {
          uint64_t v42 = !*v40 || !*((_DWORD *)*v40 - 2);
        }
        else {
          uint64_t v42 = *((unsigned int *)v41 + 10);
        }
        uint64_t v43 = (const char **)(v28 + 64);
        while (1)
        {
          if (v40 != v43)
          {
            LiString::dec((LiString *)(v28 + 64));
            uint64_t v44 = *v40;
            _OWORD *v43 = *v40;
            if (v44) {
              atomic_fetch_add((atomic_uint *volatile)v44 - 3, 1u);
            }
          }
          if ((int)v42 >= 1)
          {
            LiString::format((LiString *)"_%d", (LiString *)&v148, v42);
            signed int v45 = v148.__locale_ ? *((_DWORD *)v148.__locale_ - 2) : 0;
            LiString::append((LiString *)(v28 + 64), (const char *)v148.__locale_, v45);
            if (v148.__locale_)
            {
              if (atomic_fetch_add((atomic_uint *volatile)v148.__locale_ - 3, 0xFFFFFFFF) == 1)
              {
                *(unsigned char *)v148.__locale_ = 0;
                if (v148.__locale_) {
                  uint64_t v46 = (char *)v148.__locale_ - 12;
                }
                else {
                  uint64_t v46 = 0;
                }
                free(v46);
              }
            }
          }
          if ((void *)(a1 + 1384) == std::__tree<LiString>::find<LiString>(a1 + 1376, (const char **)(v28 + 64))) {
            break;
          }
          uint64_t v42 = (v42 + 1);
        }
        v148.__locale_ = (std::locale::__imp *)v40;
        *((_DWORD *)std::__tree<std::__value_type<LiString,int>,std::__map_value_compare<LiString,std::__value_type<LiString,int>,std::less<LiString>,true>,std::allocator<std::__value_type<LiString,int>>>::__emplace_unique_key_args<LiString,std::piecewise_construct_t const&,std::tuple<LiString const&>,std::tuple<>>(&v157, v40, (uint64_t)&std::piecewise_construct, (uint64_t **)&v148)+ 10) = v42 + 1;
        if ((int)v155 <= SHIDWORD(v155)) {
          int v47 = (2 * (HIDWORD(v155) + 1)) | 1;
        }
        else {
          int v47 = v155;
        }
        PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::resize((uint64_t)&v154, HIDWORD(v155) + 1, v47);
        *(void *)(v156 + 8 * SHIDWORD(v155) - 8) = v28;
      }
      ++v27;
    }
    while (v27 < SHIDWORD(v162));
    int v48 = HIDWORD(v155);
    uint64_t v26 = sprintf_buf + 224;
  }
  float32x4_t v150 = 0;
  v151.var0 = 0;
  v148.__locale_ = (std::locale::__imp *)&unk_1F1119658;
  float32x4_t v149 = &v150;
  char v152 = 0;
  float32x2_t v153 = &v154;
  if (v48 >= 1)
  {
    uint64_t v49 = 0;
    do
    {
      uint64_t v50 = *(void *)(v156 + 8 * v49);
      ProShade::VarT<ProShade::Node>::hash(v50, (__n128 *)v145);
      *(_OWORD *)(v50 + 72) = *(_OWORD *)&v145[0].__locale_;
      uint64_t v53 = *(void *)(v50 + 16);
      uint64_t v52 = (PCShared_base **)(v50 + 16);
      uint64_t v51 = v53;
      if (!v53) {
        throw_PCNullPointerException(1);
      }
      (*(void (**)(std::locale *__return_ptr))(*(void *)v51 + 80))(v145);
      PCPtr<ProShade::Node>::reset<ProShade::Node>(v52, v146);
      v145[0].__locale_ = (std::locale::__imp *)&unk_1F11193B8;
      PCSharedCount::~PCSharedCount(&v147);
      ++v49;
      int v55 = HIDWORD(v155);
    }
    while (v49 < SHIDWORD(v155));
    if (SHIDWORD(v155) >= 1)
    {
      int v56 = 0;
      uint64_t v57 = (void *)MEMORY[0x1E4FBA240];
      do
      {
        int v58 = v56 + 1;
        if (v56 + 1 < v55)
        {
          char v59 = 0;
          uint64_t v60 = v56 + 1;
          do
          {
            if (v56 < 0 || v55 <= v56) {
              PCArray_base::badIndex(v54);
            }
            if (v60 < 0 || v60 >= v55) {
              PCArray_base::badIndex(v54);
            }
            int v54 = (PCArray_base *)ProShade::dependsOn(*(void *)(v156 + 8 * v56), *(void *)(v156 + 8 * v60));
            int v55 = HIDWORD(v155);
            if (v54)
            {
              if (v56 < 0 || SHIDWORD(v155) <= v56) {
                PCArray_base::badIndex(v54);
              }
              uint64_t v61 = v156;
              if (v60 < 0 || v60 >= SHIDWORD(v155)) {
                PCArray_base::badIndex(v54);
              }
              uint64_t v62 = *(void *)(v156 + 8 * v56);
              *(void *)(v156 + 8 * v56) = *(void *)(v156 + 8 * v60);
              *(void *)(v61 + 8 * v60) = v62;
              if (*((int *)v26 + 806) <= 1)
              {
                char v59 = 1;
                int v55 = HIDWORD(v155);
              }
              else
              {
                std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)"swap #", 6);
                uint64_t v63 = (void *)std::ostream::operator<<();
                int v64 = (PCArray_base *)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v63, (uint64_t)" ", 1);
                unsigned int v65 = v64;
                if (v56 < 0 || SHIDWORD(v155) <= v56) {
                  PCArray_base::badIndex(v64);
                }
                if (*(void *)(*(void *)(v156 + 8 * v56) + 64)) {
                  int v66 = *(const char **)(*(void *)(v156 + 8 * v56) + 64);
                }
                else {
                  int v66 = "";
                }
                size_t v67 = strlen(v66);
                std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v65, (uint64_t)v66, v67);
                std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v65, (uint64_t)" and #", 6);
                double v68 = (void *)std::ostream::operator<<();
                double v69 = (PCArray_base *)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v68, (uint64_t)" ", 1);
                double v70 = v69;
                if (v60 < 0 || v60 >= SHIDWORD(v155)) {
                  PCArray_base::badIndex(v69);
                }
                if (*(void *)(*(void *)(v156 + 8 * v60) + 64)) {
                  double v71 = *(const char **)(*(void *)(v156 + 8 * v60) + 64);
                }
                else {
                  double v71 = "";
                }
                size_t v72 = strlen(v71);
                std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v70, (uint64_t)v71, v72);
                int v54 = (PCArray_base *)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v70, (uint64_t)":\n", 2);
                int v55 = HIDWORD(v155);
                if (SHIDWORD(v155) < 1)
                {
                  char v59 = 1;
                }
                else
                {
                  uint64_t v73 = 0;
                  do
                  {
                    uint64_t v74 = *(void *)(v156 + 8 * v73);
                    int v75 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)"    ", 4);
                    uint64_t v76 = *(void *)(v74 + 16);
                    if (!v76) {
                      throw_PCNullPointerException(1);
                    }
                    (*(void (**)(std::locale *__return_ptr))(*(void *)v76 + 120))(&v173);
                    if (v173.__locale_) {
                      locale = (const char *)v173.__locale_;
                    }
                    else {
                      locale = "";
                    }
                    size_t v78 = strlen(locale);
                    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v75, (uint64_t)locale, v78);
                    double v79 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v75, (uint64_t)" ", 1);
                    if (*(void *)(v74 + 64)) {
                      int v80 = *(const char **)(v74 + 64);
                    }
                    else {
                      int v80 = "";
                    }
                    size_t v81 = strlen(v80);
                    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v79, (uint64_t)v80, v81);
                    double v82 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v79, (uint64_t)" = ", 3);
                    ProShade::VarT<ProShade::Node>::repr(v74);
                    if (v144) {
                      int v83 = v144;
                    }
                    else {
                      int v83 = "";
                    }
                    size_t v84 = strlen(v83);
                    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v82, (uint64_t)v83, v84);
                    double v85 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v82, (uint64_t)";",
                            1);
                    std::ios_base::getloc((const std::ios_base *)((char *)v85 + *(void *)(*v85 - 24)));
                    double v86 = std::locale::use_facet(v145, MEMORY[0x1E4FBA258]);
                    ((void (*)(const std::locale::facet *, uint64_t))v86->__vftable[2].~facet_0)(v86, 10);
                    std::locale::~locale(v145);
                    std::ostream::put();
                    int v54 = (PCArray_base *)std::ostream::flush();
                    if (v144 && atomic_fetch_add((atomic_uint *volatile)v144 - 3, 0xFFFFFFFF) == 1)
                    {
                      const char *v144 = 0;
                      if (v144) {
                        double v87 = (char *)(v144 - 12);
                      }
                      else {
                        double v87 = 0;
                      }
                      free(v87);
                    }
                    if (v173.__locale_ && atomic_fetch_add((atomic_uint *volatile)v173.__locale_ - 3, 0xFFFFFFFF) == 1)
                    {
                      *(unsigned char *)v173.__locale_ = 0;
                      if (v173.__locale_) {
                        double v88 = (char *)v173.__locale_ - 12;
                      }
                      else {
                        double v88 = 0;
                      }
                      free(v88);
                    }
                    ++v73;
                    int v55 = HIDWORD(v155);
                  }
                  while (v73 < SHIDWORD(v155));
                  char v59 = 1;
                  uint64_t v26 = sprintf_buf + 224;
                }
              }
            }
            ++v60;
          }
          while (v60 < v55);
          if (v59) {
            int v58 = v56;
          }
          else {
            int v58 = v56 + 1;
          }
        }
        int v56 = v58;
      }
      while (v58 < v55);
      if (v55 >= 1)
      {
        uint64_t v89 = 0;
        double v90 = (std::locale::id *)MEMORY[0x1E4FBA258];
        do
        {
          uint64_t v91 = *(void *)(v156 + 8 * v89);
          double v92 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v170, (uint64_t)"    ", 4);
          uint64_t v93 = *(void *)(v91 + 16);
          if (!v93) {
            throw_PCNullPointerException(1);
          }
          (*(void (**)(std::locale *__return_ptr))(*(void *)v93 + 120))(&v173);
          if (v173.__locale_) {
            double v94 = (const char *)v173.__locale_;
          }
          else {
            double v94 = "";
          }
          size_t v95 = strlen(v94);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v92, (uint64_t)v94, v95);
          double v96 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v92, (uint64_t)" ", 1);
          if (*(void *)(v91 + 64)) {
            double v97 = *(const char **)(v91 + 64);
          }
          else {
            double v97 = "";
          }
          size_t v98 = strlen(v97);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v96, (uint64_t)v97, v98);
          float64x2_t v99 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v96, (uint64_t)" = ", 3);
          ProShade::VarT<ProShade::Node>::repr(v91);
          if (v144) {
            double v100 = v144;
          }
          else {
            double v100 = "";
          }
          size_t v101 = strlen(v100);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v99, (uint64_t)v100, v101);
          double v102 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v99, (uint64_t)";", 1);
          std::ios_base::getloc((const std::ios_base *)((char *)v102 + *(void *)(*v102 - 24)));
          double v103 = std::locale::use_facet(v145, v90);
          ((void (*)(const std::locale::facet *, uint64_t))v103->__vftable[2].~facet_0)(v103, 10);
          std::locale::~locale(v145);
          std::ostream::put();
          std::ostream::flush();
          if (v144 && atomic_fetch_add((atomic_uint *volatile)v144 - 3, 0xFFFFFFFF) == 1)
          {
            const char *v144 = 0;
            if (v144) {
              double v104 = (char *)(v144 - 12);
            }
            else {
              double v104 = 0;
            }
            free(v104);
          }
          if (v173.__locale_ && atomic_fetch_add((atomic_uint *volatile)v173.__locale_ - 3, 0xFFFFFFFF) == 1)
          {
            *(unsigned char *)v173.__locale_ = 0;
            if (v173.__locale_) {
              double v105 = (char *)v173.__locale_ - 12;
            }
            else {
              double v105 = 0;
            }
            free(v105);
          }
          ++v89;
        }
        while (v89 < SHIDWORD(v155));
      }
    }
  }
  uint64_t v106 = a2;
  if (*(int *)(a2 + 12) >= 1)
  {
    uint64_t v107 = 0;
    uint64_t v108 = 0;
    double v109 = (std::locale::id *)MEMORY[0x1E4FBA258];
    do
    {
      uint64_t v110 = *(void *)(v106 + 16);
      uint64_t v111 = ProShade::findVar((uint64_t)&v161, v110 + v107);
      ProShade::NodeOperator::operator()(&v148, v111, (uint64_t)v145);
      double v112 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v170, (uint64_t)"    ", 4);
      if (*(void *)(v110 + v107 + 32)) {
        double v113 = *(const char **)(v110 + v107 + 32);
      }
      else {
        double v113 = "";
      }
      size_t v114 = strlen(v113);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v112, (uint64_t)v113, v114);
      double v115 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v112, (uint64_t)" = ", 3);
      if (!v146) {
        throw_PCNullPointerException(1);
      }
      (*(void (**)(const char **__return_ptr))(*(void *)v146 + 16))(&v144);
      if (v144) {
        long long v116 = v144;
      }
      else {
        long long v116 = "";
      }
      size_t v117 = strlen(v116);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v115, (uint64_t)v116, v117);
      long long v118 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v115, (uint64_t)";", 1);
      std::ios_base::getloc((const std::ios_base *)((char *)v118 + *(void *)(*v118 - 24)));
      double v119 = std::locale::use_facet(&v173, v109);
      ((void (*)(const std::locale::facet *, uint64_t))v119->__vftable[2].~facet_0)(v119, 10);
      std::locale::~locale(&v173);
      std::ostream::put();
      std::ostream::flush();
      if (v144 && atomic_fetch_add((atomic_uint *volatile)v144 - 3, 0xFFFFFFFF) == 1)
      {
        const char *v144 = 0;
        if (v144) {
          long long v120 = (char *)(v144 - 12);
        }
        else {
          long long v120 = 0;
        }
        free(v120);
      }
      v145[0].__locale_ = (std::locale::__imp *)&unk_1F11193B8;
      PCSharedCount::~PCSharedCount(&v147);
      ++v108;
      uint64_t v106 = a2;
      v107 += 40;
    }
    while (v108 < *(int *)(a2 + 12));
  }
  ProShade::deleteVars((unsigned int *)&v161);
  std::stringbuf::str();
  LiString::LiString(&v173, (const void **)&v145[0].__locale_);
  if (&v173 != (std::locale *)a3)
  {
    LiString::dec(a3);
    uint64_t v121 = v173.__locale_;
    *(std::locale *)a3 = v173;
    if (!v121) {
      goto LABEL_206;
    }
    atomic_fetch_add((atomic_uint *volatile)v121 - 3, 1u);
  }
  if (v173.__locale_ && atomic_fetch_add((atomic_uint *volatile)v173.__locale_ - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)v173.__locale_ = 0;
    if (v173.__locale_) {
      float64x2_t v122 = (char *)v173.__locale_ - 12;
    }
    else {
      float64x2_t v122 = 0;
    }
    free(v122);
    v173.__locale_ = 0;
  }
LABEL_206:
  if (SHIBYTE(v146) < 0) {
    operator delete(v145[0].__locale_);
  }
  double v123 = v159;
  if (v159 != (uint64_t *)v160)
  {
    do
    {
      long long v124 = (const PCString *)ProShade::Snippet::code((ProShade::Snippet *)v123[6]);
      PCString::PCString((PCString *)&v173, v124);
      PCString::append(v125, "\n");
      LiString::LiString((LiString *)v145, (PCString *)&v173);
      if (v145[0].__locale_) {
        signed int v126 = *((_DWORD *)v145[0].__locale_ - 2);
      }
      else {
        signed int v126 = 0;
      }
      LiString::append(a4, (const char *)v145[0].__locale_, v126);
      if (v145[0].__locale_ && atomic_fetch_add((atomic_uint *volatile)v145[0].__locale_ - 3, 0xFFFFFFFF) == 1)
      {
        *(unsigned char *)v145[0].__locale_ = 0;
        if (v145[0].__locale_) {
          double v127 = (char *)v145[0].__locale_ - 12;
        }
        else {
          double v127 = 0;
        }
        free(v127);
        v145[0].__locale_ = 0;
      }
      PCString::~PCString((PCString *)&v173);
      long long v128 = (uint64_t *)v123[1];
      if (v128)
      {
        do
        {
          float64_t v129 = v128;
          long long v128 = (uint64_t *)*v128;
        }
        while (v128);
      }
      else
      {
        do
        {
          float64_t v129 = (uint64_t *)v123[2];
          BOOL v130 = *v129 == (void)v123;
          double v123 = v129;
        }
        while (!v130);
      }
      double v123 = v129;
    }
    while (v129 != (uint64_t *)v160);
  }
  v148.__locale_ = (std::locale::__imp *)&unk_1F112DF28;
  std::__tree<std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>,std::__map_value_compare<ProShade::Node const*,std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>,std::less<ProShade::Node const*>,true>,std::allocator<std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>>>::destroy((uint64_t)&v149, v150);
  float32x4_t v154 = &unk_1F1119AC0;
  if ((int)v155 < 0) {
    unsigned int v131 = 1;
  }
  else {
    unsigned int v131 = v155 & ~((int)v155 >> 31);
  }
  if (v131 == v155)
  {
    uint64_t v132 = SHIDWORD(v155);
    if (v155 < 0)
    {
      do
      {
        *(void *)(v156 + 8 * v132) = 0;
        BOOL v133 = __CFADD__(v132++, 1);
      }
      while (!v133);
    }
  }
  else
  {
    if (v131) {
      operator new[]();
    }
    if (v156) {
      MEMORY[0x1BA9BFB70](v156, 0x1000C8077774924);
    }
    uint64_t v156 = 0;
  }
  uint64_t v155 = v131;
  if (v156) {
    MEMORY[0x1BA9BFB70](v156, 0x1000C8077774924);
  }
  std::__tree<std::__value_type<LiString,int>,std::__map_value_compare<LiString,std::__value_type<LiString,int>,std::less<LiString>,true>,std::allocator<std::__value_type<LiString,int>>>::destroy((uint64_t)&v157, v158[0]);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)&v159, v160[0]);
  int8x16_t v161 = &unk_1F1119AC0;
  if ((int)v162 < 0) {
    unsigned int v134 = 1;
  }
  else {
    unsigned int v134 = v162 & ~((int)v162 >> 31);
  }
  if (v134 == v162)
  {
    uint64_t v135 = SHIDWORD(v162);
    if (v162 < 0)
    {
      do
      {
        *(void *)(v163 + 8 * v135) = 0;
        BOOL v133 = __CFADD__(v135++, 1);
      }
      while (!v133);
    }
  }
  else
  {
    if (v134) {
      operator new[]();
    }
    if (v163) {
      MEMORY[0x1BA9BFB70](v163, 0x1000C8077774924);
    }
    uint64_t v163 = 0;
  }
  uint64_t v162 = v134;
  if (v163) {
    MEMORY[0x1BA9BFB70](v163, 0x1000C8077774924);
  }
  float32x4_t v164 = &unk_1F1119AF8;
  if ((int)v165 < 0) {
    int v136 = 1;
  }
  else {
    int v136 = v165;
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize((uint64_t)&v164, 0, v136);
  if (v166) {
    MEMORY[0x1BA9BFB70](v166, 0x1000C8077774924);
  }
  float32x4_t v167 = &unk_1F1119AF8;
  if ((int)v168 < 0) {
    int v137 = 1;
  }
  else {
    int v137 = v168;
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize((uint64_t)&v167, 0, v137);
  if (v169) {
    MEMORY[0x1BA9BFB70](v169, 0x1000C8077774924);
  }
  v170[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v170 + *(void *)(v170[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v170[1] = MEMORY[0x1E4FBA470] + 16;
  if (v171 < 0) {
    operator delete((void *)v170[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1BA9BFAB0](&v172);
}

void sub_1B7A6C028(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,std::locale a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,int a36,int a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,int a46,int a47,uint64_t a48,uint64_t a49,int a50,uint64_t a51,uint64_t a52,int a53,uint64_t a54,char a55)
{
}

uint64_t ProShade::findVar(uint64_t a1, uint64_t a2)
{
  ProShade::VarT<ProShade::Node>::hash(a2, (__n128 *)&v7);
  if (*(int *)(a1 + 12) < 1) {
LABEL_5:
  }
    operator new();
  uint64_t v3 = 0;
  while (1)
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 16) + 8 * v3);
    ProShade::VarT<ProShade::Node>::hash(v4, (__n128 *)&v6);
    if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(v6, v7)))) & 1) == 0) {
      return v4;
    }
    if (++v3 >= *(int *)(a1 + 12)) {
      goto LABEL_5;
    }
  }
}

void sub_1B7A6C654(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C40D6048424);
  _Unwind_Resume(a1);
}

uint64_t ProShade::VarT<ProShade::Node>::inputs(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    throw_PCNullPointerException(1);
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 64);

  return v2();
}

uint64_t ProShade::VarT<ProShade::Node>::atomic(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    throw_PCNullPointerException(1);
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 88);

  return v2();
}

__n128 ProShade::VarT<ProShade::Node>::hash@<Q0>(uint64_t a1@<X0>, __n128 *a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3) {
    throw_PCNullPointerException(1);
  }
  uint64_t v4 = (__n128 *)(*(uint64_t (**)(uint64_t, void))(*(void *)v3 + 48))(v3, 0);
  __n128 result = *v4;
  *a2 = *v4;
  return result;
}

uint64_t ProShade::dependsOn(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(const void **)(a1 + 16);
  if (v4
  {
    char v6 = 1;
  }
  else
  {
    v8[1] = 0;
    uint64_t v9 = 0;
    ProShade::VarT<ProShade::Node>::inputs(a1);
    char v6 = 0;
    v8[0] = &unk_1F1119AF8;
    PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize((uint64_t)v8, 0, 0);
    if (v9) {
      MEMORY[0x1BA9BFB70](v9, 0x1000C8077774924);
    }
  }
  return v6 & 1;
}

void sub_1B7A6C914(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::~PCArray((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t ProShade::deleteVars(unsigned int *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = a1[3];
  if ((int)v2 >= 1)
  {
    for (uint64_t i = 0; i != v2; ++i)
    {
      if (i >= (int)v1[3]) {
        PCArray_base::badIndex((PCArray_base *)a1);
      }
      a1 = *(unsigned int **)(*((void *)v1 + 2) + 8 * i);
      if (a1) {
        a1 = (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(void *)a1 + 16))(a1);
      }
    }
  }
  int v4 = v1[2];
  if (v4 < 0) {
    int v5 = 1;
  }
  else {
    int v5 = v4 & ~(v4 >> 31);
  }
  if (v5 == v4)
  {
    uint64_t v6 = (int)v1[3];
    if ((v6 & 0x80000000) != 0)
    {
      do
        *(void *)(*((void *)v1 + 2) + 8 * v6) = 0;
      while (!__CFADD__(v6++, 1));
    }
  }
  else
  {
    if (v5) {
      operator new[]();
    }
    uint64_t v8 = *((void *)v1 + 2);
    if (v8) {
      MEMORY[0x1BA9BFB70](v8, 0x1000C8077774924);
    }
    *((void *)v1 + 2) = 0;
  }
  v1[2] = v5;
  v1[3] = 0;
  uint64_t result = *((void *)v1 + 2);
  if (result) {
    uint64_t result = MEMORY[0x1BA9BFB70](result, 0x1000C8077774924);
  }
  *((void *)v1 + 2) = 0;
  v1[2] = 0;
  return result;
}

uint64_t PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F1119AC0;
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2 < 0) {
    int v3 = 1;
  }
  else {
    int v3 = v2 & ~(v2 >> 31);
  }
  if (v3 == v2)
  {
    uint64_t v4 = *(int *)(a1 + 12);
    if ((v4 & 0x80000000) != 0)
    {
      do
        *(void *)(*(void *)(a1 + 16) + 8 * v4) = 0;
      while (!__CFADD__(v4++, 1));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6) {
      MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = 0;
  uint64_t v7 = *(void *)(a1 + 16);
  if (v7) {
    MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

uint64_t PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F1119AF8;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

void ProShade::Program::find_vars(PCArray_base *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(_DWORD *)(a2 + 12);
  if (v8)
  {
    while (1)
    {
      if (v8 < 1) {
        PCArray_base::badIndex(a1);
      }
      uint64_t v12 = *(void *)(a2 + 16);
      double v70 = &unk_1F11193B8;
      char v71 = *(unsigned char *)(v12 + 8);
      uint64_t v72 = *(void *)(v12 + 16);
      PCSharedCount::PCSharedCount(v73, (const PCSharedCount *)(v12 + 24));
      int v13 = *(_DWORD *)(a2 + 12);
      LODWORD(v14) = v13 - 1;
      if (v13 > 1)
      {
        uint64_t v15 = 0;
        uint64_t v16 = 0;
        do
        {
          ProShade::VarT<ProShade::Node>::operator=(*(void *)(a2 + 16) + v15, (const PCSharedCount *)(*(void *)(a2 + 16) + v15 + 32));
          ++v16;
          uint64_t v14 = *(int *)(a2 + 12) - 1;
          v15 += 32;
        }
        while (v16 < v14);
      }
      if (*(_DWORD *)(a2 + 8) >= (int)v14) {
        int v17 = *(_DWORD *)(a2 + 8);
      }
      else {
        int v17 = (2 * v14) | 1;
      }
      PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a2, v14, v17);
      uint64_t Var = ProShade::findVar(a3, (uint64_t)&v70);
      uint64_t v19 = (PCSharedCount *)Var;
      if (*(unsigned char *)(Var + 56)) {
        goto LABEL_70;
      }
      *(unsigned char *)(Var + 56) = 1;
      uint64_t v20 = *(const void **)(Var + 16);
      if (!a5)
      {
        if (v20)
        {
LABEL_40:
          if (v34)
          {
            int v35 = v34;
            int32x4_t v36 = (OZChannelBase *)(*(uint64_t (**)(_DWORD *))(*(void *)v34 + 136))(v34);
            if ((v36 & 1) == 0)
            {
              switch(v35[10])
              {
                case 0:
                case 3:
                  ProShade::Error<PCIllegalArgumentException>::raise(v36, v37);
                case 1:
                  int v38 = *(_DWORD *)(a6 + 12);
                  if (*(_DWORD *)(a6 + 8) <= v38) {
                    int v39 = (2 * (v38 + 1)) | 1;
                  }
                  else {
                    int v39 = *(_DWORD *)(a6 + 8);
                  }
                  PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::resize(a6, v38 + 1, v39);
                  *(void *)(*(void *)(a6 + 16) + 8 * *(int *)(a6 + 12) - 8) = v19;
                  ProShade::VarT<ProShade::Node>::VarT(&v66, (PCShared_base *)v35);
                  if (v40)
                  {
                    (*(void (**)(PCSharedCount *__return_ptr, void *))(*(void *)v40 + 160))(&v58, v40);
                    ProShade::VarT<ProShade::Node>::operator=((uint64_t)&v66, &v58);
                    v58.var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
                    PCSharedCount::~PCSharedCount(&v61);
                  }
                  if (v68)
                  {
                    if (v41)
                    {
                      ProShade::Sampler::Sampler((ProShade::Sampler *)&v58, v41);
                      int v42 = *(_DWORD *)(a7 + 12);
                      if (*(_DWORD *)(a7 + 8) <= v42) {
                        int v43 = (2 * (v42 + 1)) | 1;
                      }
                      else {
                        int v43 = *(_DWORD *)(a7 + 8);
                      }
                      PCArray<ProShade::Sampler,PCArray_Traits<ProShade::Sampler>>::resize(a7, v42 + 1, v43);
                      uint64_t v44 = *(void *)(a7 + 16);
                      uint64_t v45 = *(int *)(a7 + 12) - 1;
                      ProShade::VarT<ProShade::Node>::operator=(v44 + 96 * v45, &v58);
                      ProShade::VarT<ProShade::Node>::operator=(v44 + 96 * v45 + 32, &v62);
                      ProShade::VarT<ProShade::Node>::operator=(v44 + 96 * v45 + 64, &v64);
                      v58.var0 = (PC_Sp_counted_base *)&unk_1F1119908;
                      v64.var0 = (PC_Sp_counted_base *)&unk_1F1119970;
                      PCSharedCount::~PCSharedCount(&v65);
                      v62.var0 = (PC_Sp_counted_base *)&unk_1F1119970;
                      PCSharedCount::~PCSharedCount(&v63);
                      v58.var0 = (PC_Sp_counted_base *)&unk_1F11199B0;
                      PCSharedCount::~PCSharedCount(&v61);
                    }
                  }
                  v66.var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
                  PCSharedCount::~PCSharedCount(&v69);
                  break;
                case 2:
                  int v46 = *(_DWORD *)(a8 + 12);
                  if (*(_DWORD *)(a8 + 8) <= v46) {
                    int v47 = (2 * (v46 + 1)) | 1;
                  }
                  else {
                    int v47 = *(_DWORD *)(a8 + 8);
                  }
                  PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::resize(a8, v46 + 1, v47);
                  *(void *)(*(void *)(a8 + 16) + 8 * *(int *)(a8 + 12) - 8) = v19;
                  break;
                default:
                  break;
              }
            }
          }
        }
LABEL_59:
        v58.var0 = (PC_Sp_counted_base *)&unk_1F1119AF8;
        uint64_t v59 = 0;
        uint64_t v60 = 0;
        ProShade::VarT<ProShade::Node>::inputs((uint64_t)v19);
        if (SHIDWORD(v59) >= 1)
        {
          uint64_t v48 = 0;
          uint64_t v49 = 0;
          do
          {
            uint64_t v50 = v60;
            int v51 = *(_DWORD *)(a2 + 12);
            if (*(_DWORD *)(a2 + 8) <= v51) {
              int v52 = (2 * (v51 + 1)) | 1;
            }
            else {
              int v52 = *(_DWORD *)(a2 + 8);
            }
            PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a2, v51 + 1, v52);
            ProShade::VarT<ProShade::Node>::operator=(*(void *)(a2 + 16) + 32 * *(int *)(a2 + 12) - 32, (const PCSharedCount *)(v50 + v48));
            ++v49;
            v48 += 32;
          }
          while (v49 < SHIDWORD(v59));
        }
        v58.var0 = (PC_Sp_counted_base *)&unk_1F1119AF8;
        if ((int)v59 < 0) {
          int v53 = 1;
        }
        else {
          int v53 = v59;
        }
        PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize((uint64_t)&v58, 0, v53);
        if (v60) {
          MEMORY[0x1BA9BFB70](v60, 0x1000C8077774924);
        }
        goto LABEL_70;
      }
      if (!v20) {
        goto LABEL_59;
      }
      if (!v21) {
        goto LABEL_40;
      }
      uint64_t v22 = v21;
      LiString::format((LiString *)"_v%d", (LiString *)&v58, *(unsigned int *)(a5 + 12));
      int v23 = (uint64_t *)&v19[8];
      if (&v58 == &v19[8]) {
        goto LABEL_17;
      }
      LiString::dec((LiString *)&v19[8]);
      var0 = v58.var0;
      *int v23 = (uint64_t)v58.var0;
      if (var0) {
        break;
      }
LABEL_23:
      int v26 = *(_DWORD *)(a5 + 12);
      if (*(_DWORD *)(a5 + 8) <= v26) {
        int v27 = (2 * (v26 + 1)) | 1;
      }
      else {
        int v27 = *(_DWORD *)(a5 + 8);
      }
      PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::resize(a5, v26 + 1, v27);
      *(void *)(*(void *)(a5 + 16) + 8 * *(int *)(a5 + 12) - 8) = v19;
      v66.var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
      char v67 = *((unsigned char *)v22 + 56);
      double v68 = (const void *)*((void *)v22 + 8);
      PCSharedCount::PCSharedCount(&v69, (const PCSharedCount *)v22 + 9);
      ProShade::Output::Output((uint64_t)&v58, v23, (uint64_t)&v66);
      int v28 = *(_DWORD *)(a4 + 12);
      if (*(_DWORD *)(a4 + 8) <= v28) {
        int v29 = (2 * (v28 + 1)) | 1;
      }
      else {
        int v29 = *(_DWORD *)(a4 + 8);
      }
      PCArray<ProShade::Output,PCArray_Traits<ProShade::Output>>::resize(a4, v28 + 1, v29);
      uint64_t v30 = *(void *)(a4 + 16);
      uint64_t v31 = *(int *)(a4 + 12) - 1;
      ProShade::VarT<ProShade::Node>::operator=(v30 + 40 * v31, &v58);
      if ((PCSharedCount *)(v30 + 40 * v31) != &v58)
      {
        LiString::dec((LiString *)(v30 + 40 * v31 + 32));
        uint64_t v32 = v62.var0;
        *(PCSharedCount *)(v30 + 40 * v31 + 32) = v62;
        if (v32) {
          atomic_fetch_add((atomic_uint *volatile)v32 - 3, 1u);
        }
      }
      v58.var0 = (PC_Sp_counted_base *)&unk_1F1119118;
      if (v62.var0 && atomic_fetch_add((atomic_uint *volatile)v62.var0 - 3, 0xFFFFFFFF) == 1)
      {
        *(unsigned char *)v62.var0 = 0;
        if (v62.var0) {
          uint64_t v33 = (char *)v62.var0 - 12;
        }
        else {
          uint64_t v33 = 0;
        }
        free(v33);
        v62.var0 = 0;
      }
      v58.var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
      PCSharedCount::~PCSharedCount(&v61);
      v66.var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
      PCSharedCount::~PCSharedCount(&v69);
LABEL_70:
      double v70 = &unk_1F11193B8;
      PCSharedCount::~PCSharedCount(v73);
      int v8 = *(_DWORD *)(a2 + 12);
      if (!v8) {
        return;
      }
    }
    atomic_fetch_add((atomic_uint *volatile)var0 - 3, 1u);
LABEL_17:
    if (v58.var0 && atomic_fetch_add((atomic_uint *volatile)v58.var0 - 3, 0xFFFFFFFF) == 1)
    {
      *(unsigned char *)v58.var0 = 0;
      if (v58.var0) {
        int v25 = (char *)v58.var0 - 12;
      }
      else {
        int v25 = 0;
      }
      free(v25);
    }
    goto LABEL_23;
  }
}

void sub_1B7A6D3C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, PCSharedCount *a18, PCSharedCount *a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  *(void *)(v24 - 152) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount(a19);
  *(void *)(v24 - 120) = v23;
  PCSharedCount::~PCSharedCount(v22);
  _Unwind_Resume(a1);
}

uint64_t ProShade::VarT<ProShade::Node>::operator=(uint64_t a1, const PCSharedCount *a2)
{
  *(PCSharedCount *)(a1 + 16) = a2[2];
  uint64_t v3 = (uint64_t *)(a1 + 24);
  PCSharedCount::PCSharedCount(&v5, a2 + 3);
  PCSharedCount::operator=(v3, (uint64_t *)&v5);
  PCSharedCount::~PCSharedCount(&v5);
  return a1;
}

void sub_1B7A6D550(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

void ProShade::Sampler::~Sampler(PCSharedCount *this)
{
  this->var0 = (PC_Sp_counted_base *)&unk_1F1119908;
  this[8].var0 = (PC_Sp_counted_base *)&unk_1F1119970;
  PCSharedCount::~PCSharedCount(this + 11);
  this[4].var0 = (PC_Sp_counted_base *)&unk_1F1119970;
  PCSharedCount::~PCSharedCount(this + 7);
  this->var0 = (PC_Sp_counted_base *)&unk_1F11199B0;
  PCSharedCount::~PCSharedCount(this + 3);
}

{
  uint64_t vars8;

  this->var0 = (PC_Sp_counted_base *)&unk_1F1119908;
  this[8].var0 = (PC_Sp_counted_base *)&unk_1F1119970;
  PCSharedCount::~PCSharedCount(this + 11);
  this[4].var0 = (PC_Sp_counted_base *)&unk_1F1119970;
  PCSharedCount::~PCSharedCount(this + 7);
  this->var0 = (PC_Sp_counted_base *)&unk_1F11199B0;
  PCSharedCount::~PCSharedCount(this + 3);

  JUMPOUT(0x1BA9BFBA0);
}

void ProShade::Error<PCIllegalArgumentException>::raise(OZChannelBase *a1, const PCString *a2)
{
  OZChannelBase::setRangeName(a1, a2);
  exception = (PCIllegalArgumentException *)__cxa_allocate_exception(0x40uLL);
  PCIllegalArgumentException::PCIllegalArgumentException(exception);
}

void sub_1B7A6D65C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t ProShade::Program::varying_code@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  LiString::LiString((LiString *)&v12, "varying");
  int v13 = &unk_1F11199D8;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = v12;
  if (v12)
  {
    atomic_fetch_add(v12 - 3, 1u);
    if (v12)
    {
      if (atomic_fetch_add(v12 - 3, 0xFFFFFFFF) == 1)
      {
        *(unsigned char *)uint64_t v12 = 0;
        if (v12) {
          uint64_t v4 = v12 - 3;
        }
        else {
          uint64_t v4 = 0;
        }
        free(v4);
      }
    }
  }
  if (*(int *)(a1 + 12) >= 1)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = *(void *)(*(void *)(a1 + 16) + 8 * v5);
      uint64_t v7 = *(void **)(v6 + 16);
      if (v7) {
      (*(void (**)(atomic_uint **__return_ptr))(*(void *)v7 + 120))(&v12);
      }
      ProShade::VariableList::add((ProShade::VariableList *)&v13, (const LiString *)&v12, (const LiString *)(v6 + 64));
      if (v12 && atomic_fetch_add(v12 - 3, 0xFFFFFFFF) == 1)
      {
        *(unsigned char *)uint64_t v12 = 0;
        if (v12) {
          int v8 = v12 - 3;
        }
        else {
          int v8 = 0;
        }
        free(v8);
      }
      ++v5;
    }
    while (v5 < *(int *)(a1 + 12));
  }
  ProShade::VariableList::str(&v13, a2);
  if (v16 && atomic_fetch_add(v16 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)uint64_t v16 = 0;
    if (v16) {
      uint64_t v9 = v16 - 3;
    }
    else {
      uint64_t v9 = 0;
    }
    free(v9);
    uint64_t v16 = 0;
  }
  int v13 = &unk_1F11199D8;
  if ((int)v14 < 0) {
    int v10 = 1;
  }
  else {
    int v10 = v14;
  }
  PCArray<ProShade::VariableList::VariableEntry,PCArray_Traits<ProShade::VariableList::VariableEntry>>::resize((uint64_t)&v13, 0, v10);
  uint64_t result = v15;
  if (v15) {
    return MEMORY[0x1BA9BFB70](v15, 0x1000C8077774924);
  }
  return result;
}

void sub_1B7A6D8A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  ProShade::VariableList::~VariableList((ProShade::VariableList *)va);
  _Unwind_Resume(a1);
}

void ProShade::VariableList::add(ProShade::VariableList *this, const LiString *a2, const LiString *a3)
{
  int v6 = *((_DWORD *)this + 3);
  if (*((_DWORD *)this + 2) <= v6) {
    int v7 = (2 * (v6 + 1)) | 1;
  }
  else {
    int v7 = *((_DWORD *)this + 2);
  }
  PCArray<ProShade::VariableList::VariableEntry,PCArray_Traits<ProShade::VariableList::VariableEntry>>::resize((uint64_t)this, v6 + 1, v7);
  uint64_t v8 = *((void *)this + 2) + 16 * (*((int *)this + 3) - 1);
  if ((const LiString *)v8 != a2)
  {
    LiString::dec((LiString *)v8);
    uint64_t v9 = *(void *)a2;
    *(void *)uint64_t v8 = *(void *)a2;
    if (v9) {
      atomic_fetch_add((atomic_uint *volatile)(v9 - 12), 1u);
    }
  }
  if ((const LiString *)(v8 + 8) != a3)
  {
    LiString::dec((LiString *)(v8 + 8));
    uint64_t v10 = *(void *)a3;
    *(void *)(v8 + 8) = *(void *)a3;
    if (v10) {
      atomic_fetch_add((atomic_uint *volatile)(v10 - 12), 1u);
    }
  }
}

uint64_t ProShade::VariableList::str@<X0>(void **this@<X0>, void *a2@<X8>)
{
  size_t v3 = *((unsigned int *)this + 3);
  if (v3) {
    qsort(this[2], v3, 0x10uLL, (int (__cdecl *)(const void *, const void *))ProShade::VariableList::by_type);
  }
  uint64_t v4 = std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v51);
  int v5 = *((_DWORD *)this + 3);
  if (v5 > 1)
  {
    unsigned int v6 = 0;
    do
    {
      if ((v6 & 0x80000000) != 0) {
        PCArray_base::badIndex((PCArray_base *)v4);
      }
      int v7 = (const char **)this[2];
      uint64_t v8 = &v7[2 * v6];
      int v9 = v6 + 1;
      if (v5 <= v9) {
        PCArray_base::badIndex((PCArray_base *)v4);
      }
      uint64_t v4 = LiString::operator==(&v7[2 * v6], &v7[2 * v9]);
      if (v4)
      {
        uint64_t v12 = v8[1];
        uint64_t v11 = (LiString *)(v8 + 1);
        uint64_t v10 = v12;
        if (v12) {
          int v13 = *((_DWORD *)v10 - 2);
        }
        else {
          int v13 = 0;
        }
        unsigned int v46 = v6;
        size_t v14 = v13;
        uint64_t v15 = (unsigned int *)malloc_type_malloc(v13 + 15, 0x8903763CuLL);
        int v47 = v6 + 1;
        uint64_t v16 = v9;
        atomic_store(1u, v15);
        int v17 = v15 + 3;
        atomic_store(0, v15);
        v15[1] = v14 + 2;
        v15[2] = v14 + 3;
        memcpy(v15 + 3, v10, v14);
        *(_WORD *)&v17[v14] = 8236;
        v17[v14 + 2] = 0;
        atomic_fetch_add((atomic_uint *volatile)v15, 1u);
        uint64_t v18 = v7[2 * v9 + 1];
        uint64_t v48 = v11;
        if (v18) {
          int v19 = *((_DWORD *)v18 - 2);
        }
        else {
          int v19 = 0;
        }
        size_t v20 = (int)v15[1];
        size_t v21 = v20 + v19;
        uint64_t v22 = (unsigned int *)malloc_type_malloc(v21 + 13, 0x8903763CuLL);
        v22[1] = v21;
        v22[2] = v21 + 1;
        atomic_store(1u, v22);
        atomic_store(0, v22);
        memcpy(v22 + 3, v17, v20);
        memcpy((char *)v22 + v20 + 12, v18, v19);
        *((unsigned char *)v22 + v21 + 12) = 0;
        atomic_fetch_add((atomic_uint *volatile)v22, 1u);
        LiString::dec(v48);
        *(void *)uint64_t v48 = v22 + 3;
        atomic_fetch_add((atomic_uint *volatile)v22, 1u);
        if (atomic_fetch_add((atomic_uint *volatile)v22, 0xFFFFFFFF) == 1) {
          free(v22);
        }
        if (atomic_fetch_add((atomic_uint *volatile)v15, 0xFFFFFFFF) == 1) {
          free(v15);
        }
        LODWORD(v23) = *((_DWORD *)this + 3) - 1;
        if ((int)v23 > v47)
        {
          uint64_t v24 = 16 * v16;
          do
          {
            int v25 = (char *)this[2];
            LiString::dec((LiString *)&v25[v24]);
            uint64_t v26 = *(void *)&v25[v24 + 16];
            *(void *)&v25[v24] = v26;
            if (v26) {
              atomic_fetch_add((atomic_uint *volatile)(v26 - 12), 1u);
            }
            int v27 = &v25[v24];
            LiString::dec((LiString *)(v27 + 8));
            uint64_t v28 = *((void *)v27 + 3);
            *((void *)v27 + 1) = v28;
            if (v28) {
              atomic_fetch_add((atomic_uint *volatile)(v28 - 12), 1u);
            }
            ++v16;
            uint64_t v23 = *((int *)this + 3) - 1;
            v24 += 16;
          }
          while (v16 < v23);
        }
        if (*((_DWORD *)this + 2) >= (int)v23) {
          int v29 = *((_DWORD *)this + 2);
        }
        else {
          int v29 = (2 * v23) | 1;
        }
        PCArray<ProShade::VariableList::VariableEntry,PCArray_Traits<ProShade::VariableList::VariableEntry>>::resize((uint64_t)this, v23, v29);
        unsigned int v6 = v46;
      }
      else
      {
        ++v6;
      }
      int v5 = *((_DWORD *)this + 3);
    }
    while ((int)v6 < v5 - 1);
  }
  if (v5 >= 1)
  {
    uint64_t v30 = 0;
    uint64_t v31 = 0;
    uint64_t v32 = (std::locale::id *)MEMORY[0x1E4FBA258];
    do
    {
      uint64_t v33 = (char *)this[2];
      if (this[3]) {
        int v34 = (const char *)this[3];
      }
      else {
        int v34 = "";
      }
      size_t v35 = strlen(v34);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v51, (uint64_t)v34, v35);
      int32x4_t v36 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v51, (uint64_t)" ", 1);
      if (*(void *)&v33[v30]) {
        size_t v37 = *(const char **)&v33[v30];
      }
      else {
        size_t v37 = "";
      }
      size_t v38 = strlen(v37);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)v37, v38);
      int v39 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)" ", 1);
      if (*(void *)&v33[v30 + 8]) {
        int v40 = *(const char **)&v33[v30 + 8];
      }
      else {
        int v40 = "";
      }
      size_t v41 = strlen(v40);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v39, (uint64_t)v40, v41);
      int v42 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v39, (uint64_t)";", 1);
      std::ios_base::getloc((const std::ios_base *)((char *)v42 + *(void *)(*v42 - 24)));
      int v43 = std::locale::use_facet(&v49, v32);
      ((void (*)(const std::locale::facet *, uint64_t))v43->__vftable[2].~facet_0)(v43, 10);
      std::locale::~locale(&v49);
      std::ostream::put();
      std::ostream::flush();
      ++v31;
      v30 += 16;
    }
    while (v31 < *((int *)this + 3));
  }
  std::stringbuf::str();
  LiString::LiString(a2, (const void **)&v49.__locale_);
  if (v50 < 0) {
    operator delete(v49.__locale_);
  }
  v51[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v51 + *(void *)(v51[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v51[1] = MEMORY[0x1E4FBA470] + 16;
  if (v52 < 0) {
    operator delete((void *)v51[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1BA9BFAB0](&v53);
}

void sub_1B7A6DECC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  std::ostringstream::~ostringstream((uint64_t)&a20);
  _Unwind_Resume(a1);
}

void ProShade::VariableList::~VariableList(ProShade::VariableList *this)
{
  LiString::dec((ProShade::VariableList *)((char *)this + 24));
  *(void *)this = &unk_1F11199D8;
  if (*((int *)this + 2) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *((_DWORD *)this + 2);
  }
  PCArray<ProShade::VariableList::VariableEntry,PCArray_Traits<ProShade::VariableList::VariableEntry>>::resize((uint64_t)this, 0, v2);
  uint64_t v3 = *((void *)this + 2);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *((void *)this + 2) = 0;
  *((_DWORD *)this + 2) = 0;
}

uint64_t ProShade::Program::uniform_code@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, LiString *a3@<X8>)
{
  LiString::LiString((LiString *)v48, "uniform");
  int v51 = &unk_1F11199D8;
  uint64_t v52 = 0;
  uint64_t v53 = 0;
  int v54 = (atomic_uint *)v48[0];
  if (v48[0])
  {
    atomic_fetch_add((atomic_uint *volatile)(v48[0] - 12), 1u);
    if (v48[0])
    {
      if (atomic_fetch_add((atomic_uint *volatile)(v48[0] - 12), 0xFFFFFFFF) == 1)
      {
        *(unsigned char *)v48[0] = 0;
        if (v48[0]) {
          unsigned int v6 = (void *)(v48[0] - 12);
        }
        else {
          unsigned int v6 = 0;
        }
        free(v6);
      }
    }
  }
  *(void *)a3 = 0;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v48);
  int v43 = a3;
  if (*(int *)(a2 + 12) >= 1)
  {
    uint64_t v7 = 0;
    int v8 = *(_DWORD *)(a1 + 1364);
    uint64_t v41 = a2;
    do
    {
      int v9 = *(const void **)(*(void *)(*(void *)(a2 + 16) + 8 * v7) + 16);
      if (v9) {
      else
      }
        uint64_t v10 = 0;
      uint64_t v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v48, (uint64_t)"uniform ", 8);
      (*((void (**)(std::locale *__return_ptr, const char **))*v10 + 15))(&v44, v10);
      if (v44.__locale_) {
        locale = (const char *)v44.__locale_;
      }
      else {
        locale = "";
      }
      size_t v13 = strlen(locale);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)locale, v13);
      size_t v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)" ", 1);
      int v17 = v10[4];
      uint64_t v16 = v10 + 4;
      uint64_t v15 = v17;
      if (v17) {
        uint64_t v18 = v15;
      }
      else {
        uint64_t v18 = "";
      }
      size_t v19 = strlen(v18);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)v18, v19);
      size_t v20 = (PCArray_base *)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)";",
                              1);
      uint64_t v42 = v7;
      if (v44.__locale_ && atomic_fetch_add((atomic_uint *volatile)v44.__locale_ - 3, 0xFFFFFFFF) == 1)
      {
        *(unsigned char *)v44.__locale_ = 0;
        if (v44.__locale_) {
          size_t v21 = (char *)v44.__locale_ - 12;
        }
        else {
          size_t v21 = 0;
        }
        free(v21);
      }
      if (v8 >= 1)
      {
        uint64_t v22 = 0;
        do
        {
          while (1)
          {
            if (*(_DWORD *)(a1 + 1364) <= (int)v22) {
              PCArray_base::badIndex(v20);
            }
            uint64_t v23 = *(void *)(a1 + 1368) + 72 * v22;
            uint64_t v24 = *(void *)(v23 + 48);
            if (v24) {
              break;
            }
            if ((int)++v22 >= v8) {
              goto LABEL_66;
            }
          }
          int v25 = *(std::locale::__imp **)(v24 + 32);
          v44.__locale_ = v25;
          if (v25) {
            atomic_fetch_add((atomic_uint *volatile)v25 - 3, 1u);
          }
          size_t v20 = (PCArray_base *)LiString::operator==((const char **)&v44, v16);
          if (v20 && *(void *)(v23 + 16))
          {
            ProShade::VarT<ProShade::Node>::repr(v23);
            size_t v20 = (PCArray_base *)LiString::operator==((const char **)&v47, (const char **)&v44);
            if ((v20 & 1) == 0)
            {
              ProShade::VarT<ProShade::Node>::repr(v23);
              uint64_t v26 = v46;
              if (v46) {
                int v27 = *((_DWORD *)v46 - 2);
              }
              else {
                int v27 = 0;
              }
              int v29 = (char *)malloc_type_malloc(v27 + 17, 0x8903763CuLL);
              *((_DWORD *)v29 + 1) = v27 + 4;
              *((_DWORD *)v29 + 2) = v27 + 5;
              atomic_store(1u, (unsigned int *)v29);
              atomic_store(0, (unsigned int *)v29);
              *((_DWORD *)v29 + 3) = 539963168;
              memcpy(v29 + 16, v26, v27);
              v29[v27 + 16] = 0;
              atomic_fetch_add((atomic_uint *volatile)v29, 1u);
              size_t v30 = strlen(v29 + 12);
              size_t v20 = (PCArray_base *)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v48, (uint64_t)(v29 + 12), v30);
              a3 = v43;
              if (atomic_fetch_add((atomic_uint *volatile)v29, 0xFFFFFFFF) == 1) {
                free(v29);
              }
              if (v46 && atomic_fetch_add((atomic_uint *volatile)v46 - 3, 0xFFFFFFFF) == 1)
              {
                *unsigned int v46 = 0;
                if (v46) {
                  uint64_t v31 = v46 - 12;
                }
                else {
                  uint64_t v31 = 0;
                }
                free(v31);
              }
            }
            if (v47 && atomic_fetch_add(v47 - 3, 0xFFFFFFFF) == 1)
            {
              *(unsigned char *)int v47 = 0;
              if (v47) {
                uint64_t v32 = (char *)(v47 - 3);
              }
              else {
                uint64_t v32 = 0;
              }
              free(v32);
            }
            char v28 = 0;
          }
          else
          {
            char v28 = 1;
          }
          if (v44.__locale_ && atomic_fetch_add((atomic_uint *volatile)v44.__locale_ - 3, 0xFFFFFFFF) == 1)
          {
            *(unsigned char *)v44.__locale_ = 0;
            if (v44.__locale_) {
              uint64_t v33 = (char *)v44.__locale_ - 12;
            }
            else {
              uint64_t v33 = 0;
            }
            free(v33);
          }
          if ((int)++v22 < v8) {
            char v34 = v28;
          }
          else {
            char v34 = 0;
          }
        }
        while ((v34 & 1) != 0);
      }
LABEL_66:
      std::ios_base::getloc((const std::ios_base *)((char *)v48 + *(void *)(v48[0] - 24)));
      a2 = v41;
      size_t v35 = std::locale::use_facet(&v44, MEMORY[0x1E4FBA258]);
      ((void (*)(const std::locale::facet *, uint64_t))v35->__vftable[2].~facet_0)(v35, 10);
      std::locale::~locale(&v44);
      std::ostream::put();
      std::ostream::flush();
      uint64_t v7 = v42 + 1;
    }
    while (v42 + 1 < *(int *)(v41 + 12));
  }
  std::stringbuf::str();
  LiString::LiString(&v47, (const void **)&v44.__locale_);
  if (&v47 != (atomic_uint **)a3)
  {
    LiString::dec(a3);
    int32x4_t v36 = v47;
    *(void *)a3 = v47;
    if (!v36) {
      goto LABEL_76;
    }
    atomic_fetch_add(v36 - 3, 1u);
  }
  if (v47 && atomic_fetch_add(v47 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)int v47 = 0;
    if (v47) {
      size_t v37 = (char *)(v47 - 3);
    }
    else {
      size_t v37 = 0;
    }
    free(v37);
    int v47 = 0;
  }
LABEL_76:
  if (v45 < 0) {
    operator delete(v44.__locale_);
  }
  v48[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v48 + *(void *)(v48[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v48[1] = MEMORY[0x1E4FBA470] + 16;
  if (v49 < 0) {
    operator delete((void *)v48[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1BA9BFAB0](&v50);
  if (v54 && atomic_fetch_add(v54 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)int v54 = 0;
    if (v54) {
      size_t v38 = v54 - 3;
    }
    else {
      size_t v38 = 0;
    }
    free(v38);
    int v54 = 0;
  }
  int v51 = &unk_1F11199D8;
  if ((int)v52 < 0) {
    int v39 = 1;
  }
  else {
    int v39 = v52;
  }
  PCArray<ProShade::VariableList::VariableEntry,PCArray_Traits<ProShade::VariableList::VariableEntry>>::resize((uint64_t)&v51, 0, v39);
  uint64_t result = v53;
  if (v53) {
    return MEMORY[0x1BA9BFB70](v53, 0x1000C8077774924);
  }
  return result;
}

void sub_1B7A6E6B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, LiString *a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,atomic_uint *a21,char a22)
{
  if (a21 && atomic_fetch_add(a21 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)a21 = 0;
    free(a21 - 3);
  }
  if (a19 < 0) {
    operator delete(__p);
  }
  std::ostringstream::~ostringstream((uint64_t)&a22);
  LiString::dec(a13);
  ProShade::VariableList::~VariableList((ProShade::VariableList *)(v22 - 120));
  _Unwind_Resume(a1);
}

BOOL LiString::operator==(const char **a1, const char **a2)
{
  int v2 = *a1;
  uint64_t v3 = *a2;
  if (v2 == v3) {
    return 1;
  }
  if (v2) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  return !v4 && *((_DWORD *)v2 - 2) == *((_DWORD *)v3 - 2) && strcmp(v2, v3) == 0;
}

uint64_t ProShade::Program::attribute_code@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  LiString::LiString((LiString *)&v12, "attribute");
  size_t v13 = &unk_1F11199D8;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = v12;
  if (v12)
  {
    atomic_fetch_add(v12 - 3, 1u);
    if (v12)
    {
      if (atomic_fetch_add(v12 - 3, 0xFFFFFFFF) == 1)
      {
        *(unsigned char *)uint64_t v12 = 0;
        if (v12) {
          BOOL v4 = v12 - 3;
        }
        else {
          BOOL v4 = 0;
        }
        free(v4);
      }
    }
  }
  if (*(int *)(a1 + 12) >= 1)
  {
    uint64_t v5 = 0;
    do
    {
      unsigned int v6 = *(const void **)(*(void *)(*(void *)(a1 + 16) + 8 * v5) + 16);
      if (v6) {
      else
      }
        uint64_t v7 = 0;
      (*(void (**)(atomic_uint **__return_ptr, char *))(*(void *)v7 + 120))(&v12, v7);
      ProShade::VariableList::add((ProShade::VariableList *)&v13, (const LiString *)&v12, (const LiString *)(v7 + 32));
      if (v12 && atomic_fetch_add(v12 - 3, 0xFFFFFFFF) == 1)
      {
        *(unsigned char *)uint64_t v12 = 0;
        if (v12) {
          int v8 = v12 - 3;
        }
        else {
          int v8 = 0;
        }
        free(v8);
      }
      ++v5;
    }
    while (v5 < *(int *)(a1 + 12));
  }
  ProShade::VariableList::str(&v13, a2);
  if (v16 && atomic_fetch_add(v16 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)uint64_t v16 = 0;
    if (v16) {
      int v9 = v16 - 3;
    }
    else {
      int v9 = 0;
    }
    free(v9);
    uint64_t v16 = 0;
  }
  size_t v13 = &unk_1F11199D8;
  if ((int)v14 < 0) {
    int v10 = 1;
  }
  else {
    int v10 = v14;
  }
  PCArray<ProShade::VariableList::VariableEntry,PCArray_Traits<ProShade::VariableList::VariableEntry>>::resize((uint64_t)&v13, 0, v10);
  uint64_t result = v15;
  if (v15) {
    return MEMORY[0x1BA9BFB70](v15, 0x1000C8077774924);
  }
  return result;
}

void sub_1B7A6EB34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  ProShade::VariableList::~VariableList((ProShade::VariableList *)va);
  _Unwind_Resume(a1);
}

uint64_t ProShade::Program::fragment_code(PCArray_base *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v37 = (uint64_t)a1;
  uint64_t v67 = 0;
  uint64_t v68 = 0;
  PCSharedCount v66 = &unk_1F1119AF8;
  v64[0] = 0;
  v64[1] = 0;
  PCSharedCount v62 = &unk_1F1119A10;
  PCSharedCount v63 = v64;
  char v65 = a5;
  if (*(int *)(a2 + 12) >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    do
    {
      int v8 = (const PCSharedCount *)(*(void *)(a2 + 16) + v6);
      var0 = v8[2].var0;
      if (!var0) {
        throw_PCNullPointerException(1);
      }
      (*(void (**)(PCSharedCount *__return_ptr))(*(void *)var0 + 80))(v59);
      if (!v60) {
        throw_PCNullPointerException(1);
      }
      (*(void (**)(PCSharedCount *__return_ptr))(*(void *)v60 + 80))(&v44);
      ProShade::VarT<ProShade::Node>::operator=((uint64_t)v8, &v44);
      v44.var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
      PCSharedCount::~PCSharedCount(&v47);
      v59[0].var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
      PCSharedCount::~PCSharedCount(&v61);
      if ((int)v67 <= SHIDWORD(v67)) {
        int v10 = (2 * (HIDWORD(v67) + 1)) | 1;
      }
      else {
        int v10 = v67;
      }
      PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize((uint64_t)&v66, HIDWORD(v67) + 1, v10);
      a1 = (PCArray_base *)ProShade::VarT<ProShade::Node>::operator=(v68 + 32 * SHIDWORD(v67) - 32, v8);
      ++v7;
      v6 += 40;
    }
    while (v7 < *(int *)(a2 + 12));
  }
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  uint64_t v55 = 0;
  int v56 = &unk_1F1119AC0;
  uint64_t v53 = &unk_1F1119AC0;
  uint64_t v54 = 0;
  uint64_t v51 = 0;
  uint64_t v52 = 0;
  uint64_t v50 = &unk_1F1119BF0;
  ProShade::Program::find_vars(a1, (uint64_t)&v66, v37 + 1424, a3, a4, (uint64_t)&v56, (uint64_t)&v50, 0);
  unsigned int v46 = 0;
  v47.var0 = 0;
  v44.var0 = (PC_Sp_counted_base *)&unk_1F1119658;
  char v45 = &v46;
  char v48 = 0;
  uint64_t v49 = a4;
  if (*(int *)(a2 + 12) >= 1)
  {
    uint64_t v11 = 0;
    uint64_t v12 = 16;
    do
    {
      uint64_t v13 = *(void *)(a2 + 16);
      uint64_t v14 = *(void *)(v13 + v12);
      if (!v14) {
        throw_PCNullPointerException(1);
      }
      (*(void (**)(PCSharedCount *__return_ptr))(*(void *)v14 + 80))(v59);
      ProShade::VarT<ProShade::Node>::operator=(v13 + v12 - 16, v59);
      v59[0].var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
      PCSharedCount::~PCSharedCount(&v61);
      ++v11;
      v12 += 40;
    }
    while (v11 < *(int *)(a2 + 12));
  }
  PCArray<ProShade::Sampler,PCArray_Traits<ProShade::Sampler>>::append(v37 + 1448, (uint64_t)&v50);
  LiString::LiString((LiString *)v59, "#version 120\n#extension GL_EXT_gpu_shader4 : require\n");
  ProShade::Program::uniform_code(v37, (uint64_t)&v56, (LiString *)&v43);
  ProShade::Program::varying_code(a4, &v42);
  int v40 = 0;
  uint64_t v41 = 0;
  ProShade::Program::shader(v37, a2, (LiString *)&v41, (LiString *)&v40);
  *(unsigned char *)(v37 + 9) = 1;
  if (v59[0].var0) {
    uint64_t v15 = (const char *)v59[0].var0;
  }
  else {
    uint64_t v15 = "";
  }
  PCString::PCString(&v39, v15);
  PSShaderBase::setSource((PSShaderBase *)(v37 + 80), &v39, 0);
  PCString::~PCString(&v39);
  if (v43) {
    uint64_t v16 = v43;
  }
  else {
    uint64_t v16 = "";
  }
  PCString::PCString(&v39, v16);
  PSShaderBase::setSource((PSShaderBase *)(v37 + 80), &v39, 1);
  PCString::~PCString(&v39);
  if (v42) {
    int v17 = v42;
  }
  else {
    int v17 = "";
  }
  PCString::PCString(&v39, v17);
  PSShaderBase::setSource((PSShaderBase *)(v37 + 80), &v39, 4);
  PCString::~PCString(&v39);
  if (v40) {
    uint64_t v18 = v40;
  }
  else {
    uint64_t v18 = "";
  }
  PCString::PCString(&v39, v18);
  PSShaderBase::setSource((PSShaderBase *)(v37 + 80), &v39, 5);
  PCString::~PCString(&v39);
  ProShade::makeMain((const void **)&v41, &v38);
  size_t v19 = v38;
  if (v38) {
    size_t v20 = v38;
  }
  else {
    size_t v20 = "";
  }
  PCString::PCString(&v39, v20);
  PSShaderBase::setSource((PSShaderBase *)(v37 + 80), &v39, 6);
  PCString::~PCString(&v39);
  if (v19 && atomic_fetch_add((atomic_uint *volatile)v19 - 3, 0xFFFFFFFF) == 1)
  {
    size_t v21 = v38;
    *size_t v38 = 0;
    free((void *)(v21 - 12));
  }
  if (v40 && atomic_fetch_add((atomic_uint *volatile)v40 - 3, 0xFFFFFFFF) == 1)
  {
    *int v40 = 0;
    if (v40) {
      uint64_t v22 = (char *)(v40 - 12);
    }
    else {
      uint64_t v22 = 0;
    }
    free(v22);
  }
  if (v41 && atomic_fetch_add(v41 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)uint64_t v41 = 0;
    if (v41) {
      uint64_t v23 = v41 - 3;
    }
    else {
      uint64_t v23 = 0;
    }
    free(v23);
  }
  if (v42 && atomic_fetch_add((atomic_uint *volatile)v42 - 3, 0xFFFFFFFF) == 1)
  {
    const char *v42 = 0;
    if (v42) {
      uint64_t v24 = (char *)(v42 - 12);
    }
    else {
      uint64_t v24 = 0;
    }
    free(v24);
  }
  if (v43 && atomic_fetch_add((atomic_uint *volatile)v43 - 3, 0xFFFFFFFF) == 1)
  {
    const char *v43 = 0;
    if (v43) {
      int v25 = (char *)(v43 - 12);
    }
    else {
      int v25 = 0;
    }
    free(v25);
  }
  if (v59[0].var0 && atomic_fetch_add((atomic_uint *volatile)v59[0].var0 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)v59[0].var0 = 0;
    if (v59[0].var0) {
      uint64_t v26 = (char *)v59[0].var0 - 12;
    }
    else {
      uint64_t v26 = 0;
    }
    free(v26);
  }
  v44.var0 = (PC_Sp_counted_base *)&unk_1F112DF28;
  std::__tree<std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>,std::__map_value_compare<ProShade::Node const*,std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>,std::less<ProShade::Node const*>,true>,std::allocator<std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>>>::destroy((uint64_t)&v45, v46);
  uint64_t v50 = &unk_1F1119BF0;
  if ((int)v51 < 0) {
    int v27 = 1;
  }
  else {
    int v27 = v51;
  }
  PCArray<ProShade::Sampler,PCArray_Traits<ProShade::Sampler>>::resize((uint64_t)&v50, 0, v27);
  if (v52) {
    MEMORY[0x1BA9BFB70](v52, 0x1000C8077774924);
  }
  uint64_t v53 = &unk_1F1119AC0;
  if ((int)v54 < 0) {
    unsigned int v28 = 1;
  }
  else {
    unsigned int v28 = v54 & ~((int)v54 >> 31);
  }
  if (v28 == v54)
  {
    uint64_t v29 = SHIDWORD(v54);
    if (v54 < 0)
    {
      do
      {
        *(void *)(v55 + 8 * v29) = 0;
        BOOL v30 = __CFADD__(v29++, 1);
      }
      while (!v30);
    }
  }
  else
  {
    if (v28) {
      operator new[]();
    }
    if (v55) {
      MEMORY[0x1BA9BFB70](v55, 0x1000C8077774924);
    }
    uint64_t v55 = 0;
  }
  uint64_t v54 = v28;
  if (v55) {
    MEMORY[0x1BA9BFB70](v55, 0x1000C8077774924);
  }
  int v56 = &unk_1F1119AC0;
  if ((int)v57 < 0) {
    unsigned int v31 = 1;
  }
  else {
    unsigned int v31 = v57 & ~((int)v57 >> 31);
  }
  if (v31 == v57)
  {
    uint64_t v32 = SHIDWORD(v57);
    if (v57 < 0)
    {
      do
      {
        *(void *)(v58 + 8 * v32) = 0;
        BOOL v30 = __CFADD__(v32++, 1);
      }
      while (!v30);
    }
  }
  else
  {
    if (v31) {
      operator new[]();
    }
    if (v58) {
      MEMORY[0x1BA9BFB70](v58, 0x1000C8077774924);
    }
    uint64_t v58 = 0;
  }
  uint64_t v57 = v31;
  if (v58) {
    MEMORY[0x1BA9BFB70](v58, 0x1000C8077774924);
  }
  PCSharedCount v62 = &unk_1F112DF28;
  std::__tree<std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>,std::__map_value_compare<ProShade::Node const*,std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>,std::less<ProShade::Node const*>,true>,std::allocator<std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>>>::destroy((uint64_t)&v63, v64[0]);
  PCSharedCount v66 = &unk_1F1119AF8;
  if ((int)v67 < 0) {
    int v33 = 1;
  }
  else {
    int v33 = v67;
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize((uint64_t)&v66, 0, v33);
  uint64_t result = v68;
  if (v68) {
    return MEMORY[0x1BA9BFB70](v68, 0x1000C8077774924);
  }
  return result;
}

void sub_1B7A6F3C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, unsigned char *a15, PCString a16, atomic_uint *a17, atomic_uint *a18, atomic_uint *a19, atomic_uint *a20,void *a21,uint64_t a22,PCSharedCount *a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,char a33)
{
  PCString::~PCString(&a16);
  if (v33 && atomic_fetch_add((atomic_uint *volatile)(v33 - 12), 0xFFFFFFFF) == 1)
  {
    *a15 = 0;
    free(a15 - 12);
  }
  if (a17 && atomic_fetch_add(a17 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)a17 = 0;
    if (a17) {
      int32x4_t v36 = a17 - 3;
    }
    else {
      int32x4_t v36 = 0;
    }
    free(v36);
  }
  if (a18 && atomic_fetch_add(a18 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)a18 = 0;
    if (a18) {
      uint64_t v37 = a18 - 3;
    }
    else {
      uint64_t v37 = 0;
    }
    free(v37);
  }
  if (a19 && atomic_fetch_add(a19 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)a19 = 0;
    if (a19) {
      size_t v38 = a19 - 3;
    }
    else {
      size_t v38 = 0;
    }
    free(v38);
  }
  if (a20 && atomic_fetch_add(a20 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)a20 = 0;
    if (a20) {
      PCString v39 = a20 - 3;
    }
    else {
      PCString v39 = 0;
    }
    free(v39);
  }
  uint64_t v40 = *(void *)(v34 - 184);
  if (v40 && atomic_fetch_add((atomic_uint *volatile)(v40 - 12), 0xFFFFFFFF) == 1)
  {
    **(unsigned char **)(v34 - 184) = 0;
    uint64_t v41 = *(void *)(v34 - 184);
    if (v41) {
      uint64_t v42 = (void *)(v41 - 12);
    }
    else {
      uint64_t v42 = 0;
    }
    free(v42);
  }
  a21 = &unk_1F112DF28;
  std::__tree<std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>,std::__map_value_compare<ProShade::Node const*,std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>,std::less<ProShade::Node const*>,true>,std::allocator<std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>>>::destroy(a11, a23);
  PCArray<ProShade::Sampler,PCArray_Traits<ProShade::Sampler>>::~PCArray((uint64_t)&a27);
  PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::~PCArray((uint64_t)&a30);
  PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::~PCArray((uint64_t)&a33);
  *(void *)(v34 - 152) = &unk_1F112DF28;
  std::__tree<std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>,std::__map_value_compare<ProShade::Node const*,std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>,std::less<ProShade::Node const*>,true>,std::allocator<std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>>>::destroy(a12, *(PCSharedCount **)(v34 - 136));
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::~PCArray(v34 - 112);
  _Unwind_Resume(a1);
}

uint64_t PCArray<ProShade::Sampler,PCArray_Traits<ProShade::Sampler>>::append(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(int *)(a1 + 12);
  int v5 = *(_DWORD *)(a2 + 12) + v4;
  if (*(_DWORD *)(a1 + 8) >= v5) {
    int v6 = *(_DWORD *)(a1 + 8);
  }
  else {
    int v6 = (2 * v5) | 1;
  }
  uint64_t result = PCArray<ProShade::Sampler,PCArray_Traits<ProShade::Sampler>>::resize(a1, v5, v6);
  if (*(int *)(a2 + 12) >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    uint64_t v10 = 96 * v4;
    do
    {
      uint64_t v11 = (const PCSharedCount *)(*(void *)(a2 + 16) + v8);
      uint64_t v12 = *(void *)(a1 + 16) + v10 + v8;
      ProShade::VarT<ProShade::Node>::operator=(v12, v11);
      ProShade::VarT<ProShade::Node>::operator=(v12 + 32, v11 + 4);
      uint64_t result = ProShade::VarT<ProShade::Node>::operator=(v12 + 64, v11 + 8);
      ++v9;
      v8 += 96;
    }
    while (v9 < *(int *)(a2 + 12));
  }
  return result;
}

void ProShade::makeMain(const void **this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *this;
  if (*this) {
    int v5 = *(v4 - 2);
  }
  else {
    int v5 = 0;
  }
  size_t v6 = v5;
  uint64_t v7 = v5 + 14;
  unsigned int v8 = v5 + 15;
  uint64_t v9 = (unsigned int *)malloc_type_malloc(v5 + 27, 0x8903763CuLL);
  void v9[2] = v8;
  atomic_store(1u, v9);
  atomic_store(0, v9);
  qmemcpy(v9 + 3, "void main() {\n", 14);
  v9[1] = v7;
  memcpy((char *)v9 + 26, v4, v6);
  *((unsigned char *)v9 + v7 + 12) = 0;
  atomic_fetch_add((atomic_uint *volatile)v9, 1u);
  size_t v10 = (int)v9[1];
  uint64_t v11 = (unsigned int *)malloc_type_malloc(v10 + 15, 0x8903763CuLL);
  atomic_store(1u, v11);
  uint64_t v12 = v11 + 3;
  atomic_store(0, v11);
  v11[1] = v10 + 2;
  double v11[2] = v10 + 3;
  memcpy(v11 + 3, v9 + 3, v10);
  *(_WORD *)((char *)v12 + v10) = 2685;
  *((unsigned char *)v12 + v10 + 2) = 0;
  *a2 = v11 + 3;
  atomic_fetch_add((atomic_uint *volatile)v11, 1u);
  if (atomic_fetch_add((atomic_uint *volatile)v9, 0xFFFFFFFF) == 1)
  {
    free(v9);
  }
}

void sub_1B7A6F898(_Unwind_Exception *exception_object)
{
  if (atomic_fetch_add((atomic_uint *volatile)v1, 0xFFFFFFFF) == 1) {
    free(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t PCArray<ProShade::Sampler,PCArray_Traits<ProShade::Sampler>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F1119BF0;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<ProShade::Sampler,PCArray_Traits<ProShade::Sampler>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

uint64_t ProShade::Program::vertex_code(PCArray_base *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (uint64_t)a1;
  uint64_t v53 = 0;
  uint64_t v54 = 0;
  uint64_t v52 = &unk_1F1119AF8;
  if (*(int *)(a2 + 12) >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    do
    {
      unsigned int v8 = (const PCSharedCount *)(*(void *)(a2 + 16) + v6);
      var0 = v8[2].var0;
      if (!var0) {
        throw_PCNullPointerException(1);
      }
      (*(void (**)(PCSharedCount *__return_ptr))(*(void *)var0 + 80))(&v48);
      ProShade::VarT<ProShade::Node>::operator=((uint64_t)v8, &v48);
      v48.var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
      PCSharedCount::~PCSharedCount(&v51);
      if ((int)v53 <= SHIDWORD(v53)) {
        int v10 = (2 * (HIDWORD(v53) + 1)) | 1;
      }
      else {
        int v10 = v53;
      }
      PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize((uint64_t)&v52, HIDWORD(v53) + 1, v10);
      a1 = (PCArray_base *)ProShade::VarT<ProShade::Node>::operator=(v54 + 32 * SHIDWORD(v53) - 32, v8);
      ++v7;
      v6 += 40;
    }
    while (v7 < *(int *)(a2 + 12));
  }
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  uint64_t v47 = 0;
  v48.var0 = (PC_Sp_counted_base *)&unk_1F1119AC0;
  char v45 = &unk_1F1119AC0;
  uint64_t v46 = 0;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  uint64_t v42 = &unk_1F1119BF0;
  ProShade::Program::find_vars(a1, (uint64_t)&v52, v5 + 1400, 0, 0, (uint64_t)&v48, (uint64_t)&v42, (uint64_t)&v45);
  PCArray<ProShade::Sampler,PCArray_Traits<ProShade::Sampler>>::append(v5 + 1448, (uint64_t)&v42);
  LiString::LiString((LiString *)&v41, "#version 120\n#extension GL_EXT_gpu_shader4 : require\n");
  ProShade::Program::uniform_code(v5, (uint64_t)&v48, (LiString *)&v40);
  ProShade::Program::attribute_code((uint64_t)&v45, &v39);
  ProShade::Program::varying_code(a3, &v38);
  int32x4_t v36 = 0;
  uint64_t v37 = 0;
  ProShade::Program::shader(v5, a2, (LiString *)&v37, (LiString *)&v36);
  *(unsigned char *)(v5 + 8) = 1;
  if (v41) {
    uint64_t v11 = v41;
  }
  else {
    uint64_t v11 = "";
  }
  PCString::PCString(&v35, v11);
  uint64_t v12 = (PSShaderBase *)(v5 + 16);
  PSShaderBase::setSource(v12, &v35, 0);
  PCString::~PCString(&v35);
  if (v40) {
    uint64_t v13 = v40;
  }
  else {
    uint64_t v13 = "";
  }
  PCString::PCString(&v35, v13);
  PSShaderBase::setSource(v12, &v35, 1);
  PCString::~PCString(&v35);
  if (v39) {
    uint64_t v14 = v39;
  }
  else {
    uint64_t v14 = "";
  }
  PCString::PCString(&v35, v14);
  PSShaderBase::setSource(v12, &v35, 3);
  PCString::~PCString(&v35);
  if (v38) {
    uint64_t v15 = v38;
  }
  else {
    uint64_t v15 = "";
  }
  PCString::PCString(&v35, v15);
  PSShaderBase::setSource(v12, &v35, 4);
  PCString::~PCString(&v35);
  if (v36) {
    uint64_t v16 = v36;
  }
  else {
    uint64_t v16 = "";
  }
  PCString::PCString(&v35, v16);
  PSShaderBase::setSource(v12, &v35, 5);
  PCString::~PCString(&v35);
  ProShade::makeMain((const void **)&v37, &v34);
  int v17 = v34;
  if (v34) {
    uint64_t v18 = v34;
  }
  else {
    uint64_t v18 = "";
  }
  PCString::PCString(&v35, v18);
  PSShaderBase::setSource(v12, &v35, 6);
  PCString::~PCString(&v35);
  if (v17 && atomic_fetch_add((atomic_uint *volatile)v17 - 3, 0xFFFFFFFF) == 1)
  {
    size_t v19 = v34;
    const char *v34 = 0;
    free((void *)(v19 - 12));
  }
  if (v36 && atomic_fetch_add((atomic_uint *volatile)v36 - 3, 0xFFFFFFFF) == 1)
  {
    *int32x4_t v36 = 0;
    if (v36) {
      size_t v20 = (char *)(v36 - 12);
    }
    else {
      size_t v20 = 0;
    }
    free(v20);
  }
  if (v37 && atomic_fetch_add(v37 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)uint64_t v37 = 0;
    if (v37) {
      size_t v21 = v37 - 3;
    }
    else {
      size_t v21 = 0;
    }
    free(v21);
  }
  if (v38 && atomic_fetch_add((atomic_uint *volatile)v38 - 3, 0xFFFFFFFF) == 1)
  {
    *size_t v38 = 0;
    if (v38) {
      uint64_t v22 = (char *)(v38 - 12);
    }
    else {
      uint64_t v22 = 0;
    }
    free(v22);
  }
  if (v39 && atomic_fetch_add((atomic_uint *volatile)v39 - 3, 0xFFFFFFFF) == 1)
  {
    *PCString v39 = 0;
    if (v39) {
      uint64_t v23 = (char *)(v39 - 12);
    }
    else {
      uint64_t v23 = 0;
    }
    free(v23);
  }
  if (v40 && atomic_fetch_add((atomic_uint *volatile)v40 - 3, 0xFFFFFFFF) == 1)
  {
    *uint64_t v40 = 0;
    if (v40) {
      uint64_t v24 = (char *)(v40 - 12);
    }
    else {
      uint64_t v24 = 0;
    }
    free(v24);
  }
  if (v41 && atomic_fetch_add((atomic_uint *volatile)v41 - 3, 0xFFFFFFFF) == 1)
  {
    *uint64_t v41 = 0;
    if (v41) {
      int v25 = (char *)(v41 - 12);
    }
    else {
      int v25 = 0;
    }
    free(v25);
  }
  uint64_t v42 = &unk_1F1119BF0;
  if ((int)v43 < 0) {
    int v26 = 1;
  }
  else {
    int v26 = v43;
  }
  PCArray<ProShade::Sampler,PCArray_Traits<ProShade::Sampler>>::resize((uint64_t)&v42, 0, v26);
  if (v44) {
    MEMORY[0x1BA9BFB70](v44, 0x1000C8077774924);
  }
  char v45 = &unk_1F1119AC0;
  if ((int)v46 < 0) {
    unsigned int v27 = 1;
  }
  else {
    unsigned int v27 = v46 & ~((int)v46 >> 31);
  }
  if (v27 == v46)
  {
    uint64_t v28 = SHIDWORD(v46);
    if (v46 < 0)
    {
      do
      {
        *(void *)(v47 + 8 * v28) = 0;
        BOOL v29 = __CFADD__(v28++, 1);
      }
      while (!v29);
    }
  }
  else
  {
    if (v27) {
      operator new[]();
    }
    if (v47) {
      MEMORY[0x1BA9BFB70](v47, 0x1000C8077774924);
    }
    uint64_t v47 = 0;
  }
  uint64_t v46 = v27;
  if (v47) {
    MEMORY[0x1BA9BFB70](v47, 0x1000C8077774924);
  }
  v48.var0 = (PC_Sp_counted_base *)&unk_1F1119AC0;
  if ((int)v49 < 0) {
    unsigned int v30 = 1;
  }
  else {
    unsigned int v30 = v49 & ~((int)v49 >> 31);
  }
  if (v30 == v49)
  {
    uint64_t v31 = SHIDWORD(v49);
    if (v49 < 0)
    {
      do
      {
        *(void *)(v50 + 8 * v31) = 0;
        BOOL v29 = __CFADD__(v31++, 1);
      }
      while (!v29);
    }
  }
  else
  {
    if (v30) {
      operator new[]();
    }
    if (v50) {
      MEMORY[0x1BA9BFB70](v50, 0x1000C8077774924);
    }
    uint64_t v50 = 0;
  }
  uint64_t v49 = v30;
  if (v50) {
    MEMORY[0x1BA9BFB70](v50, 0x1000C8077774924);
  }
  uint64_t v52 = &unk_1F1119AF8;
  if ((int)v53 < 0) {
    int v32 = 1;
  }
  else {
    int v32 = v53;
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize((uint64_t)&v52, 0, v32);
  uint64_t result = v54;
  if (v54) {
    return MEMORY[0x1BA9BFB70](v54, 0x1000C8077774924);
  }
  return result;
}

void sub_1B7A70000(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, unsigned char *a11, PCString a12, atomic_uint *a13, atomic_uint *a14, atomic_uint *a15, atomic_uint *a16, atomic_uint *a17, atomic_uint *a18, char a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  PCString::~PCString(&a12);
  if (v25 && atomic_fetch_add((atomic_uint *volatile)(v25 - 12), 0xFFFFFFFF) == 1)
  {
    *a11 = 0;
    free(a11 - 12);
  }
  if (a13 && atomic_fetch_add(a13 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)a13 = 0;
    if (a13) {
      uint64_t v28 = a13 - 3;
    }
    else {
      uint64_t v28 = 0;
    }
    free(v28);
  }
  if (a14 && atomic_fetch_add(a14 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)a14 = 0;
    if (a14) {
      BOOL v29 = a14 - 3;
    }
    else {
      BOOL v29 = 0;
    }
    free(v29);
  }
  if (a15 && atomic_fetch_add(a15 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)a15 = 0;
    if (a15) {
      unsigned int v30 = a15 - 3;
    }
    else {
      unsigned int v30 = 0;
    }
    free(v30);
  }
  if (a16 && atomic_fetch_add(a16 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)a16 = 0;
    if (a16) {
      uint64_t v31 = a16 - 3;
    }
    else {
      uint64_t v31 = 0;
    }
    free(v31);
  }
  if (a17 && atomic_fetch_add(a17 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)a17 = 0;
    if (a17) {
      int v32 = a17 - 3;
    }
    else {
      int v32 = 0;
    }
    free(v32);
  }
  if (a18 && atomic_fetch_add(a18 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)a18 = 0;
    if (a18) {
      uint64_t v33 = a18 - 3;
    }
    else {
      uint64_t v33 = 0;
    }
    free(v33);
  }
  PCArray<ProShade::Sampler,PCArray_Traits<ProShade::Sampler>>::~PCArray((uint64_t)&a19);
  PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::~PCArray((uint64_t)&a22);
  PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::~PCArray((uint64_t)&a25);
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::~PCArray(v26 - 112);
  _Unwind_Resume(a1);
}

uint64_t ProShade::Program::code(uint64_t this)
{
  uint64_t v1 = this;
  if (*(unsigned char *)(this + 8))
  {
    if (*(unsigned char *)(this + 1544))
    {
      exception = (PCGLSLException *)__cxa_allocate_exception(0x48uLL);
      PCString::PCString(&v31, "error already detected building this program");
      PCGLSLException::PCGLSLException(exception, &v31);
    }
  }
  else
  {
    uint64_t v3 = this + 1352;
    if (*(int *)(v1 + 1360) < 0) {
      int v4 = 1;
    }
    else {
      int v4 = *(_DWORD *)(v1 + 1360);
    }
    PCArray<ProShade::UniformVariable,PCArray_Traits<ProShade::UniformVariable>>::resize(v3, 0, v4);
    uint64_t v5 = *(void *)(v1 + 1368);
    if (v5) {
      MEMORY[0x1BA9BFB70](v5, 0x1000C8077774924);
    }
    *(void *)(v1 + 1368) = 0;
    *(_DWORD *)(v1 + 1360) = 0;
    if (*(int *)(v1 + 1456) < 0) {
      int v6 = 1;
    }
    else {
      int v6 = *(_DWORD *)(v1 + 1456);
    }
    PCArray<ProShade::Sampler,PCArray_Traits<ProShade::Sampler>>::resize(v1 + 1448, 0, v6);
    uint64_t v7 = *(void *)(v1 + 1464);
    if (v7) {
      MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
    }
    *(void *)(v1 + 1464) = 0;
    *(_DWORD *)(v1 + 1456) = 0;
    uint64_t v32 = 0;
    uint64_t v33 = 0;
    v31.var0 = (__CFString *)&unk_1F1119C28;
    ProShade::VertexProgram::addOutputs((const PCSharedCount *)(v1 + 272), (uint64_t)&v31);
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    uint64_t v28 = &unk_1F1119C28;
    ProShade::FragmentProgram::addOutputs((const PCSharedCount *)(v1 + 912), (uint64_t)&v28);
    int v8 = *(_DWORD *)(v1 + 1312);
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    uint64_t v25 = &unk_1F1119AC0;
    ProShade::Program::fragment_code((PCArray_base *)v1, (uint64_t)&v28, (uint64_t)&v31, (uint64_t)&v25, v8 == 1);
    uint64_t v9 = ProShade::Program::vertex_code((PCArray_base *)v1, (uint64_t)&v31, (uint64_t)&v25);
    int v11 = HIDWORD(v26);
    if (HIDWORD(v26))
    {
      int v12 = 0;
      int v13 = 0;
      int v14 = 0;
      do
      {
        if (v12 < 0 || SHIDWORD(v26) <= v12) {
          PCArray_base::badIndex((PCArray_base *)v9);
        }
        uint64_t v9 = ProShade::VarT<ProShade::Node>::width(*(void *)(v27 + 8 * v14), v10);
        v13 += v9;
        int v12 = ++v14;
      }
      while (v11 != v14);
    }
    else
    {
      int v13 = 0;
    }
    GLint v15 = *(_DWORD *)(v1 + 1460);
    ProShade::deleteVars((unsigned int *)(v1 + 1400));
    ProShade::deleteVars((unsigned int *)(v1 + 1424));
    GLint params = 0;
    glGetIntegerv(0x8872u, &params);
    if (v13 >= 1)
    {
      *(unsigned char *)(v1 + 1544) = 1;
      *(_DWORD *)(v1 + 264) = 3;
      size_t v21 = (PCGLSLException *)__cxa_allocate_exception(0x48uLL);
      PCString::PCString(&v23, "shader has too many varying floats");
      PCGLSLException::PCGLSLException(v21, &v23);
    }
    if (v15 > params)
    {
      *(unsigned char *)(v1 + 1544) = 1;
      *(_DWORD *)(v1 + 264) = 4;
      uint64_t v22 = (PCGLSLException *)__cxa_allocate_exception(0x48uLL);
      PCString::PCString(&v23, "shader has too many samplers");
      PCGLSLException::PCGLSLException(v22, &v23);
    }
    uint64_t v25 = &unk_1F1119AC0;
    if ((int)v26 < 0) {
      unsigned int v16 = 1;
    }
    else {
      unsigned int v16 = v26 & ~((int)v26 >> 31);
    }
    if (v16 == v26)
    {
      uint64_t v17 = SHIDWORD(v26);
      if (v26 < 0)
      {
        do
          *(void *)(v27 + 8 * v17) = 0;
        while (!__CFADD__(v17++, 1));
      }
    }
    else
    {
      if (v16) {
        operator new[]();
      }
      if (v27) {
        MEMORY[0x1BA9BFB70](v27, 0x1000C8077774924);
      }
      uint64_t v27 = 0;
    }
    uint64_t v26 = v16;
    if (v27) {
      MEMORY[0x1BA9BFB70](v27, 0x1000C8077774924);
    }
    uint64_t v28 = &unk_1F1119C28;
    if ((int)v29 < 0) {
      int v19 = 1;
    }
    else {
      int v19 = v29;
    }
    PCArray<ProShade::Output,PCArray_Traits<ProShade::Output>>::resize((uint64_t)&v28, 0, v19);
    if (v30) {
      MEMORY[0x1BA9BFB70](v30, 0x1000C8077774924);
    }
    v31.var0 = (__CFString *)&unk_1F1119C28;
    if ((int)v32 < 0) {
      int v20 = 1;
    }
    else {
      int v20 = v32;
    }
    PCArray<ProShade::Output,PCArray_Traits<ProShade::Output>>::resize((uint64_t)&v31, 0, v20);
    this = v33;
    if (v33) {
      return MEMORY[0x1BA9BFB70](v33, 0x1000C8077774924);
    }
  }
  return this;
}

void sub_1B7A70684(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, PCString a18)
{
}

void PCGLSLException::~PCGLSLException(PCString *this)
{
  this->var0 = (__CFString *)&unk_1F1119A48;
  PCString::~PCString(this + 8);

  PCException::~PCException(this);
}

{
  uint64_t vars8;

  this->var0 = (__CFString *)&unk_1F1119A48;
  PCString::~PCString(this + 8);
  PCException::~PCException(this);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t ProShade::VarT<ProShade::Node>::width(uint64_t a1, const PCString *a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (!v2) {
    throw_PCNullPointerException(1);
  }
  unsigned int v3 = *(_DWORD *)(v2 + 28);

  return ProShade::shapeGetWidth(v3, a2);
}

uint64_t PCArray<ProShade::Output,PCArray_Traits<ProShade::Output>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F1119C28;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<ProShade::Output,PCArray_Traits<ProShade::Output>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

uint64_t ProShade::Program::bindTextures(ProShade::Program *this)
{
  PCSharedCount::PCSharedCount(_18);
  int v2 = (PCMutex *)((char *)this + 160);
  unsigned int v16 = (char *)this + 160;
  PCMutex::lock((PCMutex *)((char *)this + 160));
  char v17 = 1;
  LOBYTE(texture) = 0;
  uint64_t v3 = LiPerContext<ProShade::ProgramBase::Exe *,LiPerContextObject_Traits<ProShade::ProgramBase::Exe>,LiOpenGLContextGetter>::get((uint64_t)this + 232, &texture);
  int v4 = *(void **)(*(void *)v3 + 48);
  uint64_t v5 = *(void *)v3 + 56;
  if (v4 != (void *)v5)
  {
    do
    {
      int v6 = (ProShade::SamplerNode *)v4[4];
      int v7 = *((_DWORD *)v4 + 10);
      GLuint texture = 0;
      ProShade::SamplerNode::getTextureID(v6, (int *)&texture);
      GLenum v8 = *((_DWORD *)v6 + 14);
      glActiveTexture(v7 + 33984);
      glBindTexture(v8, texture);
      switch(ProShade::SamplerNode::getWrapMode(v6))
      {
        case 0u:
        case 3u:
          GLint v9 = 33071;
          glTexParameteri(v8, 0x2802u, 33071);
          goto LABEL_6;
        case 1u:
          GLint v9 = 10497;
          glTexParameteri(v8, 0x2802u, 10497);
          goto LABEL_6;
        case 2u:
          GLint v9 = 33648;
          glTexParameteri(v8, 0x2802u, 33648);
LABEL_6:
          glTexParameteri(v8, 0x2803u, v9);
          break;
        default:
          break;
      }
      int v10 = (void *)v4[1];
      if (v10)
      {
        do
        {
          int v11 = v10;
          int v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          int v11 = (void *)v4[2];
          BOOL v12 = *v11 == (void)v4;
          int v4 = v11;
        }
        while (!v12);
      }
      int v4 = v11;
    }
    while (v11 != (void *)v5);
  }
  PCMutex::unlock(v2);
  return OZChannelBase::setRangeName((OZChannelBase *)_18, v13);
}

void sub_1B7A709E8(_Unwind_Exception *a1, char a2, uint64_t a3, OZChannelBase *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)&a10);
  OZChannelBase::setRangeName((OZChannelBase *)&a12, v13);
  _Unwind_Resume(a1);
}

void ProShade::Program::initializeExe(ProShade::Program *this, uint64_t **a2)
{
  PCSharedCount::PCSharedCount((PCSharedCount *)&var68);
  GLuint v4 = ProGL::ObjectHandle::name((ProGL::ObjectHandle *)a2);
  glUseProgram(v4);
  uint64_t v5 = (PCArray_base *)LiGL::setCurrentProgram((void **)&var68.var0, 0);
  int v6 = *((_DWORD *)this + 365);
  if (v6)
  {
    int v7 = 0;
    GLint v8 = 0;
    for (i = 0; i != v6; int v7 = i)
    {
      if (v7 < 0 || *((_DWORD *)this + 365) <= v7) {
        PCArray_base::badIndex(v5);
      }
      uint64_t v10 = *((void *)this + 183) + 96 * i;
      uint64_t v13 = *(void *)(v10 + 16);
      BOOL v12 = (unint64_t *)(v10 + 16);
      uint64_t v11 = v13;
      if (!v13) {
        throw_PCNullPointerException(1);
      }
      int v14 = *(char **)(v11 + 32);
      if (v14) {
        GLint v15 = v14;
      }
      else {
        GLint v15 = "";
      }
      GLint UniformLocation = ProShade::ProgramBase::getUniformLocation(this, v15);
      unint64_t v24 = *v12;
      var68.var2 = (void **)&v24;
      *((_DWORD *)std::__tree<std::__value_type<ProShade::SamplerNode const*,int>,std::__map_value_compare<ProShade::SamplerNode const*,std::__value_type<ProShade::SamplerNode const*,int>,std::less<ProShade::SamplerNode const*>,true>,std::allocator<std::__value_type<ProShade::SamplerNode const*,int>>>::__emplace_unique_key_args<ProShade::SamplerNode const*,std::piecewise_construct_t const&,std::tuple<ProShade::SamplerNode const*&&>,std::tuple<>>(a2 + 6, &v24, (uint64_t)&std::piecewise_construct, &var68.var2)+ 10) = v8;
      glUniform1i(UniformLocation, v8++);
      ++i;
    }
  }
  if (*((void *)this + 185) == *((void *)this + 184))
  {
    uint64_t v17 = *((unsigned int *)this + 341);
    if ((int)v17 >= 1)
    {
      uint64_t v18 = 0;
      uint64_t v19 = 48;
      do
      {
        if (v18 >= *((int *)this + 341)) {
          PCArray_base::badIndex(v5);
        }
        uint64_t v20 = *((void *)this + 171);
        uint64_t v21 = *(void *)(v20 + v19);
        if (!v21) {
          throw_PCNullPointerException(1);
        }
        uint64_t v22 = *(char **)(v21 + 32);
        if (v22) {
          PCString v23 = v22;
        }
        else {
          PCString v23 = "";
        }
        uint64_t v5 = (PCArray_base *)ProShade::ProgramBase::getUniformLocation(this, v23);
        *(_DWORD *)(v20 + v19 + 16) = v5;
        ++v18;
        v19 += 72;
      }
      while (v17 != v18);
    }
    ProShade::UniformProgram::initialize((ProShade::Program *)((char *)this + 1472), (uint64_t)this + 1352);
  }
  operator new();
}

void sub_1B7A70C1C(_Unwind_Exception *a1, const PCString *a2, uint64_t a3, OZChannelBase *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

uint64_t ProShade::Program::compileShaders(ProShade::Program *this)
{
  ProShade::Program::code((uint64_t)this);

  return ProShade::ProgramBase::compileShaders(this);
}

uint64_t ProShade::Program::getUniformWorkspace(ProShade::Program *this)
{
  int v2 = (PCMutex *)((char *)this + 160);
  PCMutex::lock((PCMutex *)((char *)this + 160));
  char v5 = 0;
  uint64_t v3 = *(void *)(*(void *)LiPerContext<ProShade::ProgramBase::Exe *,LiPerContextObject_Traits<ProShade::ProgramBase::Exe>,LiOpenGLContextGetter>::get((uint64_t)this + 232, &v5)+ 72);
  PCMutex::unlock(v2);
  return v3;
}

void sub_1B7A70D08(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)va);
  _Unwind_Resume(a1);
}

void ProShade::ProgramVar::~ProgramVar(PCSharedCount *this)
{
  this->int var0 = (PC_Sp_counted_base *)&unk_1F1119158;
  LiString::dec((LiString *)&this[8]);
  this[4].int var0 = (PC_Sp_counted_base *)&unk_1F1119AC0;
  int var0 = (int)this[5].var0;
  if (var0 < 0) {
    int v3 = 1;
  }
  else {
    int v3 = var0 & ~(var0 >> 31);
  }
  if (v3 == var0)
  {
    uint64_t var0_high = SHIDWORD(this[5].var0);
    if ((var0_high & 0x80000000) != 0)
    {
      do
        *((void *)this[6].var0 + var0_high) = 0;
      while (!__CFADD__(var0_high++, 1));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    int v6 = this[6].var0;
    if (v6) {
      MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
    }
    this[6].int var0 = 0;
  }
  LODWORD(this[5].var0) = v3;
  HIDWORD(this[5].var0) = 0;
  int v7 = this[6].var0;
  if (v7) {
    MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
  }
  this[6].int var0 = 0;
  LODWORD(this[5].var0) = 0;
  this->int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(this + 3);
}

{
  uint64_t vars8;

  ProShade::ProgramVar::~ProgramVar(this);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t ProShade::VarT<ProShade::Node>::printout(uint64_t a1)
{
  uint64_t v1 = *(ProShade::Node **)(a1 + 16);
  if (!v1) {
    throw_PCNullPointerException(1);
  }

  return ProShade::Node::po(v1);
}

void ProShade::Program::~Program(ProShade::Program *this)
{
  *(void *)(v1 + 1552) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 1568) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 1560));
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)(v1 + 1552) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 1568) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 1560));

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'ProShade::Program::~Program(ProShade::Program *this)
{
  *(void *)(v1 + 1552) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 1568) = 0;
  int v2 = (PC_Sp_counted_base **)(v1 + 1560);

  PCWeakCount::~PCWeakCount(v2);
}

{
  PC_Sp_counted_base **v1;
  uint64_t vars8;

  uint64_t v1 = (PC_Sp_counted_base **)((char *)this + *(void *)(*(void *)this - 24));
  v1[194] = (PC_Sp_counted_base *)&unk_1F1199AC8;
  *((unsigned char *)v1 + 1568) = 0;
  PCWeakCount::~PCWeakCount(v1 + 195);

  JUMPOUT(0x1BA9BFBA0);
}

void ProShade::VarT<ProShade::Node>::~VarT(PCSharedCount *a1)
{
  a1->int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(a1 + 3);

  JUMPOUT(0x1BA9BFBA0);
}

void ProShade::Func<ProShade::Func_ftransform>::eval()
{
}

void sub_1B7A712C4(_Unwind_Exception *a1)
{
  *(void *)(v1 + 72) = v2;
  *(unsigned char *)(v1 + 88) = 0;
  PCWeakCount::~PCWeakCount(v3);
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C40241F72B2);
  _Unwind_Resume(a1);
}

void ProShade::Node::~Node(ProShade::Node *this, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *(void *)this = *a2;
  *(void *)((char *)this + *(void *)(v2 - 24)) = a2[3];
  LiString::dec((ProShade::Node *)((char *)this + 32));
}

uint64_t ProShade::Func<ProShade::Func_ftransform>::~Func(uint64_t a1)
{
  *(void *)(v2 + 72) = &unk_1F1199AC8;
  *(unsigned char *)(v2 + 88) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v2 + 80));
  return a1;
}

void ProShade::Func<ProShade::Func_ftransform>::~Func(uint64_t a1)
{
  *(void *)(v1 + 72) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 88) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 80));

  JUMPOUT(0x1BA9BFBA0);
}

void ProShade::Func<ProShade::Func_ftransform>::repr(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = a1 + 48;
  LiString::LiString((LiString *)&v5, "ftransform");
  ProShade::func_repr((PCArray_base *)&v5, v3, a2);
  if (v5 && atomic_fetch_add(v5 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)char v5 = 0;
    if (v5) {
      GLuint v4 = v5 - 3;
    }
    else {
      GLuint v4 = 0;
    }
    free(v4);
  }
}

void sub_1B7A71508(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    ProShade::VertexProgram::VertexProgram(a10);
  }
  _Unwind_Resume(exception_object);
}

void ProShade::Func<ProShade::Func_ftransform>::description(void *a1@<X8>)
{
  LiString::LiString((LiString *)&v8, "Func ");
  uint64_t v2 = v8;
  if (v8) {
    int v3 = *((_DWORD *)v8 - 2);
  }
  else {
    int v3 = 0;
  }
  size_t v4 = v3;
  char v5 = (unsigned int *)malloc_type_malloc(v3 + 23, 0x8903763CuLL);
  v5[1] = v4 + 10;
  v5[2] = v4 + 11;
  atomic_store(1u, v5);
  atomic_store(0, v5);
  memcpy(v5 + 3, v2, v4);
  int v6 = (char *)v5 + v4 + 12;
  *((_WORD *)v6 + 4) = 28018;
  *(void *)int v6 = *(void *)"ftransform";
  *((unsigned char *)v5 + v4 + 22) = 0;
  *a1 = v5 + 3;
  atomic_fetch_add((atomic_uint *volatile)v5, 1u);
  if (v8 && atomic_fetch_add((atomic_uint *volatile)v8 - 3, 0xFFFFFFFF) == 1)
  {
    unsigned char *v8 = 0;
    if (v8) {
      int v7 = v8 - 12;
    }
    else {
      int v7 = 0;
    }
    free(v7);
  }
}

void sub_1B7A7162C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    ProShade::VertexProgram::VertexProgram(a10);
  }
  _Unwind_Resume(exception_object);
}

void ProShade::Func<ProShade::Func_ftransform>::shortDescription(LiString *a1@<X8>)
{
}

int8x8_t *ProShade::Func<ProShade::Func_ftransform>::computeHash(uint64_t a1, int8x8_t *this)
{
  PCHashWriteStream::writeValue(this, "Func");
  uint64_t result = PCHashWriteStream::writeValue(this, "ftransform");
  if (*(int *)(a1 + 60) >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    do
    {
      ProShade::VarT<ProShade::Node>::hash(*(void *)(a1 + 64) + v5, &v7);
      uint64_t result = PCHashWriteStream::writeValue(this, (const PCHash128 *)&v7);
      ++v6;
      v5 += 32;
    }
    while (v6 < *(int *)(a1 + 60));
  }
  return result;
}

void ProShade::Func<ProShade::Func_ftransform>::inputs(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 60);
  if (*(_DWORD *)(a2 + 8) >= v4) {
    int v5 = *(_DWORD *)(a2 + 8);
  }
  else {
    int v5 = (2 * v4) | 1;
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a2, v4, v5);
  if (*(int *)(a1 + 60) >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    do
    {
      ProShade::VarT<ProShade::Node>::operator=(*(void *)(a2 + 16) + v6, (const PCSharedCount *)(*(void *)(a1 + 64) + v6));
      ++v7;
      v6 += 32;
    }
    while (v7 < *(int *)(a1 + 60));
  }
}

uint64_t ProShade::Func<ProShade::Func_ftransform>::apply@<X0>(uint64_t a1@<X0>, void (***a2)(PCSharedCount *__return_ptr, void, uint64_t)@<X1>, PCArray_base *a3@<X8>)
{
  int v4 = a3;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v19 = &unk_1F1119AF8;
  uint64_t v5 = *(unsigned int *)(a1 + 60);
  if ((int)v5 >= 1)
  {
    uint64_t v7 = 0;
    char v8 = 0;
    uint64_t v9 = 16;
    do
    {
      if (v7 >= *(int *)(a1 + 60)) {
        PCArray_base::badIndex(v4);
      }
      uint64_t v10 = *(void *)(a1 + 64);
      (**a2)(v17, a2, v10 + v9 - 16);
      int var0 = v17[2].var0;
      BOOL v12 = *(PC_Sp_counted_base **)(v10 + v9);
      if ((int)v20 <= SHIDWORD(v20)) {
        int v13 = (2 * (HIDWORD(v20) + 1)) | 1;
      }
      else {
        int v13 = v20;
      }
      PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize((uint64_t)&v19, HIDWORD(v20) + 1, v13);
      ProShade::VarT<ProShade::Node>::operator=(v21 + 32 * SHIDWORD(v20) - 32, v17);
      v8 |= var0 != v12;
      v17[0].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
      PCSharedCount::~PCSharedCount(&v18);
      ++v7;
      v9 += 32;
    }
    while (v5 != v7);
    if (v8) {
      operator new();
    }
    int v4 = a3;
  }
  ProShade::VarT<ProShade::Node>::VarT((PCSharedCount *)v4, (PCShared_base *)a1);
  uint64_t v19 = &unk_1F1119AF8;
  if ((int)v20 < 0) {
    int v14 = 1;
  }
  else {
    int v14 = v20;
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize((uint64_t)&v19, 0, v14);
  uint64_t result = v21;
  if (v21) {
    return MEMORY[0x1BA9BFB70](v21, 0x1000C8077774924);
  }
  return result;
}

void sub_1B7A71960(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  MEMORY[0x1BA9BFBA0](v8, 0x10B1C40241F72B2);
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::~PCArray((uint64_t)va);
  _Unwind_Resume(a1);
}

void ProShade::Func<ProShade::Func_ftransform>::clone()
{
}

void sub_1B7A71B18(_Unwind_Exception *a1)
{
  *(void *)(v1 + 72) = v2;
  *(unsigned char *)(v1 + 88) = 0;
  PCWeakCount::~PCWeakCount(v3);
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C40241F72B2);
  _Unwind_Resume(a1);
}

void ProShade::Func<ProShade::Func_ftransform>::computeValue()
{
}

void virtual thunk to'ProShade::Func<ProShade::Func_ftransform>::~Func(void *a1)
{
  *(void *)(v1 + 72) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 88) = 0;
  uint64_t v2 = (PC_Sp_counted_base **)(v1 + 80);

  PCWeakCount::~PCWeakCount(v2);
}

{
  uint64_t v1;
  uint64_t vars8;

  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24);
  *(void *)(v1 + 72) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 88) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 80));

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t ProShade::Func<ProShade::Func_ftransform>::~Func(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(void *)a1 = *a2;
  *(void *)(a1 + *(void *)(v4 - 24)) = a2[5];
  uint64_t v5 = a1 + 48;
  *(void *)(a1 + 48) = &unk_1F1119AF8;
  if (*(int *)(a1 + 56) < 0) {
    int v6 = 1;
  }
  else {
    int v6 = *(_DWORD *)(a1 + 56);
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(v5, 0, v6);
  uint64_t v7 = *(void *)(a1 + 64);
  if (v7) {
    MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
  }
  *(void *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  uint64_t v8 = a2[1];
  *(void *)a1 = v8;
  *(void *)(a1 + *(void *)(v8 - 24)) = a2[4];
  LiString::dec((LiString *)(a1 + 32));
  return a1;
}

void ProShade::func_repr(PCArray_base *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = (void *)a3;
  unint64_t v24 = 0;
  LODWORD(a3) = *(_DWORD *)(a2 + 12);
  if ((int)a3 >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    do
    {
      if (v7)
      {
        LiString::append((LiString *)&v24, ", ", 2);
        LODWORD(a3) = *(_DWORD *)(a2 + 12);
      }
      if (v7 >= (int)a3) {
        PCArray_base::badIndex(a1);
      }
      ProShade::VarT<ProShade::Node>::repr(*(void *)(a2 + 16) + v6);
      if (__src) {
        signed int v8 = *((_DWORD *)__src - 2);
      }
      else {
        signed int v8 = 0;
      }
      LiString::append((LiString *)&v24, __src, v8);
      if (__src && atomic_fetch_add((atomic_uint *volatile)__src - 3, 0xFFFFFFFF) == 1)
      {
        char *__src = 0;
        free(__src - 12);
      }
      ++v7;
      a3 = *(int *)(a2 + 12);
      v6 += 32;
    }
    while (v7 < a3);
  }
  uint64_t v9 = *(_DWORD **)a1;
  if (*(void *)a1) {
    int v10 = *(v9 - 2);
  }
  else {
    int v10 = 0;
  }
  size_t v11 = v10;
  BOOL v12 = (unsigned int *)malloc_type_malloc(v10 + 14, 0x8903763CuLL);
  v12[1] = v11 + 1;
  v12[2] = v11 + 2;
  atomic_store(1u, v12);
  int v13 = v12 + 3;
  atomic_store(0, v12);
  memcpy(v12 + 3, v9, v11);
  v13[v11] = 40;
  v13[v11 + 1] = 0;
  atomic_fetch_add((atomic_uint *volatile)v12, 1u);
  size_t v14 = (int)v12[1];
  GLint v15 = v24;
  if (v24) {
    int v16 = *((_DWORD *)v24 - 2);
  }
  else {
    int v16 = 0;
  }
  size_t v17 = v14 + v16;
  PCSharedCount v18 = (unsigned int *)malloc_type_malloc(v17 + 13, 0x8903763CuLL);
  v18[1] = v17;
  v18[2] = v17 + 1;
  atomic_store(1u, v18);
  atomic_store(0, v18);
  memcpy(v18 + 3, v13, v14);
  memcpy((char *)v18 + v14 + 12, v15, v16);
  *((unsigned char *)v18 + v17 + 12) = 0;
  atomic_fetch_add((atomic_uint *volatile)v18, 1u);
  size_t v19 = (int)v18[1];
  uint64_t v20 = (unsigned int *)malloc_type_malloc(v19 + 14, 0x8903763CuLL);
  atomic_store(1u, v20);
  uint64_t v21 = v20 + 3;
  atomic_store(0, v20);
  v20[1] = v19 + 1;
  float32x2_t v20[2] = v19 + 2;
  memcpy(v20 + 3, v18 + 3, v19);
  *((unsigned char *)v21 + v19) = 41;
  *((unsigned char *)v21 + v19 + 1) = 0;
  void *v4 = v20 + 3;
  atomic_fetch_add((atomic_uint *volatile)v20, 1u);
  if (atomic_fetch_add((atomic_uint *volatile)v18, 0xFFFFFFFF) == 1) {
    free(v18);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v12, 0xFFFFFFFF) == 1) {
    free(v12);
  }
  if (v24 && atomic_fetch_add((atomic_uint *volatile)v24 - 3, 0xFFFFFFFF) == 1)
  {
    unsigned char *v24 = 0;
    if (v24) {
      uint64_t v22 = v24 - 12;
    }
    else {
      uint64_t v22 = 0;
    }
    free(v22);
  }
}

void sub_1B7A72090(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, atomic_uint *a10)
{
  if (atomic_fetch_add((atomic_uint *volatile)v11, 0xFFFFFFFF) == 1) {
    free(v11);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v10, 0xFFFFFFFF) == 1) {
    free(v10);
  }
  if (a10)
  {
    if (atomic_fetch_add(a10 - 3, 0xFFFFFFFF) == 1)
    {
      *(unsigned char *)a10 = 0;
      free(a10 - 3);
    }
  }
  _Unwind_Resume(exception_object);
}

void LiString::append(LiString *this, const char *__src, signed int a3)
{
  if (__src && a3)
  {
    uint64_t v6 = *(int **)this;
    if (*(void *)this)
    {
      size_t v7 = *(v6 - 2);
      size_t v8 = v7 + a3;
      if (*(v6 - 1) <= (int)v8)
      {
        int v13 = (unsigned int *)malloc_type_malloc(v8 + 13, 0x8903763CuLL);
        v13[1] = v8;
        double v13[2] = v8 + 1;
        atomic_store(1u, v13);
        atomic_store(0, v13);
        memcpy(v13 + 3, v6, v7);
        memcpy((char *)v13 + v7 + 12, __src, a3);
        *((unsigned char *)v13 + v8 + 12) = 0;
        if (v13 + 3 != *(unsigned int **)this)
        {
          LiString::dec(this);
          *(void *)this = v13 + 3;
          atomic_fetch_add((atomic_uint *volatile)v13, 1u);
        }
      }
      else
      {
        memcpy((char *)v6 + v7, __src, a3);
        uint64_t v9 = *(void *)this;
        uint64_t v10 = *(void *)this - 12;
        if (!*(void *)this) {
          uint64_t v10 = 0;
        }
        *(_DWORD *)(v10 + 4) = v8;
        *(unsigned char *)(v9 + v8) = 0;
      }
    }
    else
    {
      unsigned int v11 = a3 + 1;
      BOOL v12 = (unsigned int *)malloc_type_malloc(a3 + 13, 0x8903763CuLL);
      v12[2] = v11;
      atomic_store(1u, v12);
      *(void *)this = v12 + 3;
      v12[1] = a3;
      memcpy(v12 + 3, __src, a3);
      *(unsigned char *)(*(void *)this + a3) = 0;
    }
  }
}

void PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(uint64_t a1, int a2, int a3)
{
  if (a3 <= a2) {
    int v3 = a2;
  }
  else {
    int v3 = a3;
  }
  if (a2 < 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v23, "PCArray::resize");
    PCException::PCException(exception, &v23);
    *(void *)exception = &unk_1F1199218;
  }
  if (v3 == *(_DWORD *)(a1 + 8))
  {
    uint64_t v6 = *(int *)(a1 + 12);
    if (a2 >= (int)v6)
    {
      if (a2 > (int)v6)
      {
        uint64_t v9 = 32 * v6;
        int v10 = a2 - v6;
        do
        {
          unsigned int v11 = (PCSharedCount *)(*(void *)(a1 + 16) + v9);
          v11->int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
          v11[2].int var0 = 0;
          PCSharedCount::PCSharedCount(v11 + 3);
          v9 += 32;
          --v10;
        }
        while (v10);
      }
    }
    else
    {
      uint64_t v7 = 32 * a2;
      uint64_t v8 = a2;
      do
      {
        (*(void (**)(uint64_t))(*(void *)(*(void *)(a1 + 16) + v7) + 8))(*(void *)(a1 + 16) + v7);
        ++v8;
        v7 += 32;
      }
      while (v8 < *(int *)(a1 + 12));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    int v12 = *(_DWORD *)(a1 + 12);
    if (a2 >= v12) {
      int v13 = *(_DWORD *)(a1 + 12);
    }
    else {
      int v13 = a2;
    }
    if (v13 < 1)
    {
      int v13 = 0;
    }
    else
    {
      uint64_t v14 = 0;
      do
      {
        uint64_t v15 = *(void *)(a1 + 16);
        *(void *)uint64_t v14 = &unk_1F11193B8;
        uint64_t v16 = v15 + v14;
        *(unsigned char *)(v14 + 8) = *(unsigned char *)(v16 + 8);
        *(void *)(v14 + 16) = *(void *)(v16 + 16);
        PCSharedCount::PCSharedCount((PCSharedCount *)(v14 + 24), (const PCSharedCount *)(v16 + 24));
        (*(void (**)(uint64_t))(*(void *)(*(void *)(a1 + 16) + v14) + 8))(*(void *)(a1 + 16) + v14);
        v14 += 32;
      }
      while (32 * v13 != v14);
      int v12 = *(_DWORD *)(a1 + 12);
    }
    if (v13 < v12)
    {
      uint64_t v17 = 32 * v13;
      do
      {
        (*(void (**)(uint64_t))(*(void *)(*(void *)(a1 + 16) + v17) + 8))(*(void *)(a1 + 16) + v17);
        v17 += 32;
        ++v13;
      }
      while (*(_DWORD *)(a1 + 12) > v13);
    }
    if (v13 < a2)
    {
      uint64_t v18 = 32 * v13;
      size_t v19 = (PCSharedCount *)(v18 + 24);
      do
      {
        v19[-3].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
        v19[-1].int var0 = 0;
        PCSharedCount::PCSharedCount(v19);
        size_t v19 = v20 + 4;
        v18 += 32;
        ++v13;
      }
      while (v13 < a2);
    }
    uint64_t v21 = *(void *)(a1 + 16);
    if (v21) {
      MEMORY[0x1BA9BFB70](v21, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = a2;
}

void sub_1B7A725B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

uint64_t ProShade::Func<ProShade::Func_ftransform>::Func(uint64_t a1, uint64_t a2, const ProShade::Node *a3)
{
  *(void *)(a1 + 72) = &unk_1F1199AC8;
  *(void *)(a1 + 80) = 0;
  *(unsigned char *)(a1 + 88) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F11194C0);
  *(void *)a1 = &unk_1F11193E8;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = &unk_1F11194A0;
  *(void *)(a1 + 48) = &unk_1F1119AF8;
  *(void *)(a1 + 56) = 0;
  ProShade::Node::copyFrom((ProShade::Node *)a1, a3);
  int v6 = *(_DWORD *)(a2 + 12);
  if (*(_DWORD *)(a1 + 56) >= v6) {
    int v7 = *(_DWORD *)(a1 + 56);
  }
  else {
    int v7 = (2 * v6) | 1;
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a1 + 48, v6, v7);
  if (*(int *)(a2 + 12) >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    do
    {
      ProShade::VarT<ProShade::Node>::operator=(*(void *)(a1 + 64) + v8, (const PCSharedCount *)(*(void *)(a2 + 16) + v8));
      ++v9;
      v8 += 32;
    }
    while (v9 < *(int *)(a2 + 12));
  }
  return a1;
}

void sub_1B7A72738(_Unwind_Exception *a1)
{
  *(void *)(v1 + 72) = v3;
  *(unsigned char *)(v1 + 88) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

void ProShade::Func_ftransform::computeValue()
{
  exception = (PCException *)__cxa_allocate_exception(0x40uLL);
  PCString::PCString(&v2, "not implemented yet");
  PCString::PCString(&v1, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/Shading/PSFunc.h");
  PCException::PCException(exception, &v2, &v1, 972);
  *(void *)exception = &unk_1F10B1208;
}

void sub_1B7A72814(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString((PCString *)&a9);
  PCString::~PCString(&a10);
  if (v11) {
    __cxa_free_exception(v10);
  }
  _Unwind_Resume(a1);
}

void ProShade::VertexProgram::~VertexProgram(PCSharedCount *this)
{
  this[75].int var0 = (PC_Sp_counted_base *)&unk_1F1119118;
  LiString::dec((LiString *)&this[79]);
  this[75].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(this + 78);
  for (uint64_t i = 0; i != -40; i -= 5)
  {
    this[i + 70].int var0 = (PC_Sp_counted_base *)&unk_1F1119118;
    LiString::dec((LiString *)&this[i + 74]);
    this[i + 70].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
    PCSharedCount::~PCSharedCount(&this[i + 73]);
  }
  this[30].int var0 = (PC_Sp_counted_base *)&unk_1F1119118;
  LiString::dec((LiString *)&this[34]);
  this[30].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(this + 33);
  this[25].int var0 = (PC_Sp_counted_base *)&unk_1F1119118;
  LiString::dec((LiString *)&this[29]);
  this[25].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(this + 28);
  this[20].int var0 = (PC_Sp_counted_base *)&unk_1F1119118;
  LiString::dec((LiString *)&this[24]);
  this[20].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(this + 23);
  this[15].int var0 = (PC_Sp_counted_base *)&unk_1F1119118;
  LiString::dec((LiString *)&this[19]);
  this[15].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(this + 18);
  this[10].int var0 = (PC_Sp_counted_base *)&unk_1F1119118;
  LiString::dec((LiString *)&this[14]);
  this[10].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(this + 13);
  this[5].int var0 = (PC_Sp_counted_base *)&unk_1F1119118;
  LiString::dec((LiString *)&this[9]);
  this[5].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(this + 8);
  this->int var0 = (PC_Sp_counted_base *)&unk_1F1119118;
  LiString::dec((LiString *)&this[4]);
  this->int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(this + 3);
}

void ProShade::FragmentProgram::~FragmentProgram(PCSharedCount *this)
{
  for (uint64_t i = 0; i != -40; i -= 5)
  {
    this[i + 45].int var0 = (PC_Sp_counted_base *)&unk_1F1119118;
    LiString::dec((LiString *)&this[i + 49]);
    this[i + 45].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
    PCSharedCount::~PCSharedCount(&this[i + 48]);
  }
  this[5].int var0 = (PC_Sp_counted_base *)&unk_1F1119118;
  LiString::dec((LiString *)&this[9]);
  this[5].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(this + 8);
  this->int var0 = (PC_Sp_counted_base *)&unk_1F1119118;
  LiString::dec((LiString *)&this[4]);
  this->int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(this + 3);
}

void PCArray<ProShade::UniformVariable,PCArray_Traits<ProShade::UniformVariable>>::resize(uint64_t a1, int a2, int a3)
{
  if (a3 <= a2) {
    int v3 = a2;
  }
  else {
    int v3 = a3;
  }
  if (a2 < 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v29, "PCArray::resize");
    PCException::PCException(exception, &v29);
    *(void *)exception = &unk_1F1199218;
  }
  int v4 = a2;
  if (v3 == *(_DWORD *)(a1 + 8))
  {
    uint64_t v6 = *(int *)(a1 + 12);
    if (a2 >= (int)v6)
    {
      if (a2 > (int)v6)
      {
        int v10 = a2 - v6;
        uint64_t v11 = 72 * v6;
        do
        {
          uint64_t v12 = *(void *)(a1 + 16) + v11;
          *(_OWORD *)(v12 + 40) = 0u;
          *(_OWORD *)(v12 + 8) = 0u;
          *(_OWORD *)(v12 + 56) = 0u;
          *(_OWORD *)(v12 + 24) = 0u;
          *(void *)uint64_t v12 = &unk_1F11193B8;
          PCSharedCount::PCSharedCount((PCSharedCount *)(v12 + 24));
          *(void *)(v12 + 32) = &unk_1F11193B8;
          *(void *)(v12 + 48) = 0;
          PCSharedCount::PCSharedCount((PCSharedCount *)(v12 + 56));
          *(_DWORD *)(v12 + 64) = -1;
          v11 += 72;
          --v10;
        }
        while (v10);
      }
    }
    else
    {
      uint64_t v7 = a2;
      uint64_t v8 = 72 * a2;
      do
      {
        uint64_t v9 = (PCSharedCount *)(*(void *)(a1 + 16) + v8);
        v9[4].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
        PCSharedCount::~PCSharedCount(v9 + 7);
        v9->int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
        PCSharedCount::~PCSharedCount(v9 + 3);
        ++v7;
        v8 += 72;
      }
      while (v7 < *(int *)(a1 + 12));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    int v13 = *(_DWORD *)(a1 + 12);
    if (a2 >= v13) {
      int v14 = *(_DWORD *)(a1 + 12);
    }
    else {
      int v14 = a2;
    }
    if (v14 < 1)
    {
      int v14 = 0;
    }
    else
    {
      uint64_t v15 = 0;
      do
      {
        uint64_t v16 = *(void *)(a1 + 16);
        *(void *)uint64_t v15 = &unk_1F11193B8;
        uint64_t v17 = v16 + v15;
        *(unsigned char *)(v15 + 8) = *(unsigned char *)(v16 + v15 + 8);
        *(void *)(v15 + 16) = *(void *)(v16 + v15 + 16);
        PCSharedCount::PCSharedCount((PCSharedCount *)(v15 + 24), (const PCSharedCount *)(v16 + v15 + 24));
        *(void *)(v15 + 32) = &unk_1F11193B8;
        *(unsigned char *)(v15 + 40) = *(unsigned char *)(v17 + 40);
        *(void *)(v15 + 48) = *(void *)(v17 + 48);
        PCSharedCount::PCSharedCount((PCSharedCount *)(v15 + 56), (const PCSharedCount *)(v17 + 56));
        *(_DWORD *)(v15 + 64) = *(_DWORD *)(v17 + 64);
        uint64_t v18 = (PCSharedCount *)(*(void *)(a1 + 16) + v15);
        v18[4].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
        PCSharedCount::~PCSharedCount(v18 + 7);
        v18->int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
        PCSharedCount::~PCSharedCount(v18 + 3);
        v15 += 72;
      }
      while (72 * v14 != v15);
      int v13 = *(_DWORD *)(a1 + 12);
    }
    int v28 = v3;
    if (v14 < v13)
    {
      uint64_t v19 = 72 * v14;
      do
      {
        uint64_t v20 = (PCSharedCount *)(*(void *)(a1 + 16) + v19);
        v20[4].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
        PCSharedCount::~PCSharedCount(v20 + 7);
        v20->int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
        PCSharedCount::~PCSharedCount(v20 + 3);
        v19 += 72;
        ++v14;
      }
      while (*(_DWORD *)(a1 + 12) > v14);
    }
    int v21 = v4;
    if (v14 < v4)
    {
      uint64_t v22 = 72 * v14;
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      do
      {
        uint64_t v25 = v23 + v22;
        *(_OWORD *)(v25 + 40) = 0u;
        *(_OWORD *)(v25 + 8) = 0u;
        *(_OWORD *)(v23 + v22 + 56) = 0u;
        *(_OWORD *)(v23 + v22 + 24) = 0u;
        *(void *)uint64_t v25 = &unk_1F11193B8;
        PCSharedCount::PCSharedCount((PCSharedCount *)(v23 + v22 + 24));
        *(void *)(v25 + 32) = &unk_1F11193B8;
        *(void *)(v25 + 48) = 0;
        PCSharedCount::PCSharedCount((PCSharedCount *)(v23 + v22 + 56));
        *(_DWORD *)(v25 + 64) = -1;
        ++v14;
        v23 += 72;
        v24 += 72;
      }
      while (v14 < v21);
    }
    uint64_t v26 = *(void *)(a1 + 16);
    if (v26) {
      MEMORY[0x1BA9BFB70](v26, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
    int v4 = v21;
    int v3 = v28;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = v4;
}

void sub_1B7A73160(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCString a12)
{
}

uint64_t ProShade::ProgramVar::ProgramVar(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1F11193B8;
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 24), (const PCSharedCount *)(a2 + 24));
  *(void *)a1 = &unk_1F1119158;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = &unk_1F1119AC0;
  *(unsigned char *)(a1 + 56) = 0;
  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)(a1 + 72));
  return a1;
}

void sub_1B7A73298(_Unwind_Exception *a1)
{
  LiString::dec(v5);
  PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::~PCArray(v4);
  *PCString v1 = v2;
  PCSharedCount::~PCSharedCount(v3);
  _Unwind_Resume(a1);
}

void ProShade::SubstituteVar::eval(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  ProShade::VarT<ProShade::Node>::hash(a2, (__n128 *)&v25);
  if (*(unsigned char *)(a1 + 32))
  {
    uint64_t v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"SubstituteVar: ", 15);
    uint64_t v8 = operator<<(v7);
    uint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" --- ", 5);
    ProShade::VarT<ProShade::Node>::repr(a2);
    int v10 = v24 ? v24 : "";
    size_t v11 = strlen(v10);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
    std::ios_base::getloc((const std::ios_base *)((char *)v9 + *(void *)(*v9 - 24)));
    uint64_t v12 = std::locale::use_facet((const std::locale *)&v23, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v12->__vftable[2].~facet_0)(v12, 10);
    std::locale::~locale((std::locale *)&v23);
    std::ostream::put();
    uint64_t v6 = (PCArray_base *)std::ostream::flush();
    if (v24)
    {
      if (atomic_fetch_add((atomic_uint *volatile)v24 - 3, 0xFFFFFFFF) == 1)
      {
        const char *v24 = 0;
        if (v24) {
          int v13 = (char *)(v24 - 12);
        }
        else {
          int v13 = 0;
        }
        free(v13);
      }
    }
  }
  uint64_t v14 = *(void *)(a1 + 40);
  int v15 = *(_DWORD *)(v14 + 12);
  if (v15)
  {
    int v16 = 0;
    for (i = 0; i != v15; int v16 = i)
    {
      if (v16 < 0 || *(_DWORD *)(v14 + 12) <= v16) {
        PCArray_base::badIndex(v6);
      }
      uint64_t v18 = *(void *)(*(void *)(v14 + 16) + 8 * i);
      ProShade::VarT<ProShade::Node>::hash(v18, (__n128 *)&v23);
      if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(v23, v25)))) & 1) == 0
        || (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(*(int32x4_t *)(v18 + 72), v25)))) & 1) == 0)
      {
        if (*(unsigned char *)(a1 + 32))
        {
          uint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"  --> ", 6);
          if (*(void *)(v18 + 64)) {
            uint64_t v20 = *(const char **)(v18 + 64);
          }
          else {
            uint64_t v20 = "";
          }
          size_t v21 = strlen(v20);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)v20, v21);
          std::ios_base::getloc((const std::ios_base *)((char *)v19 + *(void *)(*v19 - 24)));
          uint64_t v22 = std::locale::use_facet((const std::locale *)&v23, MEMORY[0x1E4FBA258]);
          ((void (*)(const std::locale::facet *, uint64_t))v22->__vftable[2].~facet_0)(v22, 10);
          std::locale::~locale((std::locale *)&v23);
          std::ostream::put();
          std::ostream::flush();
        }
        operator new();
      }
      ++i;
    }
  }
  ProShade::NodeOperator::apply(a2, a3);
}

void sub_1B7A7360C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C40B3959486);
  _Unwind_Resume(a1);
}

uint64_t ProShade::NamedVar::NamedVar(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  *(void *)(a1 + 48) = &unk_1F1199AC8;
  *(void *)(a1 + 56) = 0;
  *(unsigned char *)(a1 + 64) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F1119770);
  *(void *)a1 = &unk_1F1119698;
  *(void *)(a1 + 48) = &unk_1F1119750;
  if ((uint64_t *)(a1 + 32) != a2)
  {
    LiString::dec((LiString *)(a1 + 32));
    uint64_t v6 = *a2;
    *(void *)(a1 + 32) = *a2;
    if (v6) {
      atomic_fetch_add((atomic_uint *volatile)(v6 - 12), 1u);
    }
  }
  uint64_t v7 = *(void *)(a3 + 16);
  if (!v7) {
    throw_PCNullPointerException(1);
  }
  *(void *)(a1 + 24) = *(void *)(v7 + 24);
  return a1;
}

void sub_1B7A73798(_Unwind_Exception *a1)
{
  ProShade::Node::~Node((ProShade::Node *)v1, (uint64_t *)(v4 + 8));
  *(void *)(v1 + 48) = v3;
  *(unsigned char *)(v1 + 64) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

void ProShade::NamedVar::~NamedVar(ProShade::NamedVar *this)
{
  *(void *)this = off_1F11197B0;
  *((void *)this + 6) = off_1F1119868;
  LiString::dec((ProShade::NamedVar *)((char *)this + 32));
  *((void *)this + 6) = &unk_1F1199AC8;
  *((unsigned char *)this + 64) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)this + 7);
}

{
  uint64_t vars8;

  *(void *)this = off_1F11197B0;
  *((void *)this + 6) = off_1F1119868;
  LiString::dec((ProShade::NamedVar *)((char *)this + 32));
  *((void *)this + 6) = &unk_1F1199AC8;
  *((unsigned char *)this + 64) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)this + 7);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t ProShade::NamedVar::repr@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 32);
  *a2 = v2;
  if (v2) {
    atomic_fetch_add((atomic_uint *volatile)(v2 - 12), 1u);
  }
  return this;
}

void ProShade::NamedVar::description(LiString *a1@<X8>)
{
}

int8x8_t *ProShade::NamedVar::computeHash(ProShade::NamedVar *this, int8x8_t *a2)
{
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3)
  {
    size_t v4 = *((unsigned int *)v3 - 2);
  }
  else
  {
    size_t v4 = 0;
    uint64_t v3 = "";
  }
  return PCHashWriteStream::writeData(a2, v3, v4);
}

void ProShade::NamedVar::inputs(uint64_t a1, uint64_t a2)
{
  if (*(int *)(a2 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a2 + 8);
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a2, 0, v2);
}

PCSharedCount *ProShade::NamedVar::apply@<X0>(PCShared_base *a1@<X0>, PCSharedCount *a2@<X8>)
{
  return ProShade::VarT<ProShade::Node>::VarT(a2, a1);
}

void ProShade::NamedVar::clone(ProShade::NamedVar *this)
{
}

void sub_1B7A739D8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C40B3959486);
  _Unwind_Resume(a1);
}

void ProShade::NamedVar::computeValue()
{
  exception = (PCException *)__cxa_allocate_exception(0x40uLL);
  PCString::PCString(&v2, "not implemented yet");
  PCString::PCString(&v1, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/Shading/PSProgram.cpp");
  PCException::PCException(exception, &v2, &v1, 257);
  *(void *)exception = &unk_1F10B1208;
}

void sub_1B7A73A9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString((PCString *)&a9);
  PCString::~PCString(&a10);
  if (v11) {
    __cxa_free_exception(v10);
  }
  _Unwind_Resume(a1);
}

void virtual thunk to'ProShade::NamedVar::~NamedVar(ProShade::NamedVar *this)
{
  PCString v1 = (char *)this + *(void *)(*(void *)this - 24);
  *(void *)PCString v1 = off_1F11197B0;
  *((void *)v1 + 6) = off_1F1119868;
  LiString::dec((LiString *)(v1 + 32));
  *((void *)v1 + 6) = &unk_1F1199AC8;
  v1[64] = 0;

  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)v1 + 7);
}

{
  char *v1;
  uint64_t vars8;

  PCString v1 = (char *)this + *(void *)(*(void *)this - 24);
  *(void *)PCString v1 = off_1F11197B0;
  *((void *)v1 + 6) = off_1F1119868;
  LiString::dec((LiString *)(v1 + 32));
  *((void *)v1 + 6) = &unk_1F1199AC8;
  v1[64] = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)v1 + 7);

  JUMPOUT(0x1BA9BFBA0);
}

ProShade::NamedVar *ProShade::NamedVar::NamedVar(ProShade::NamedVar *this)
{
  *((void *)this + 6) = &unk_1F1199AC8;
  *((void *)this + 7) = 0;
  *((unsigned char *)this + 64) = 1;
  ProShade::Node::Node(this, (uint64_t *)&off_1F1119770);
  *(void *)this = &unk_1F1119698;
  *((void *)this + 6) = &unk_1F1119750;
  return this;
}

void sub_1B7A73CFC(_Unwind_Exception *a1)
{
  *(void *)(v1 + 48) = v2;
  *(unsigned char *)(v1 + 64) = 0;
  PCWeakCount::~PCWeakCount(v3);
  _Unwind_Resume(a1);
}

uint64_t PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::resize(uint64_t result, int a2, int a3)
{
  if (a3 <= a2) {
    int v3 = a2;
  }
  else {
    int v3 = a3;
  }
  if (a2 < 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v14, "PCArray::resize");
    PCException::PCException(exception, &v14);
    *(void *)exception = &unk_1F1199218;
  }
  uint64_t v5 = result;
  if (v3 == *(_DWORD *)(result + 8))
  {
    uint64_t v6 = *(int *)(result + 12);
    if ((int)v6 < a2)
    {
      do
        *(void *)(*(void *)(result + 16) + 8 * v6++) = 0;
      while (a2 != v6);
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    int v7 = *(_DWORD *)(result + 12);
    if (a2 >= v7) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = a2;
    }
    if ((int)v8 < 1)
    {
      LODWORD(v8) = 0;
    }
    else
    {
      uint64_t v9 = *(uint64_t **)(result + 16);
      uint64_t v10 = v8;
      int v11 = 0;
      do
      {
        uint64_t v12 = *v9++;
        *v11++ = v12;
        --v10;
      }
      while (v10);
    }
    if ((int)v8 > v7) {
      int v7 = v8;
    }
    if (v7 < a2) {
      bzero((void *)(8 * v7), 8 * (~v7 + a2) + 8);
    }
    uint64_t result = *(void *)(v5 + 16);
    if (result) {
      uint64_t result = MEMORY[0x1BA9BFB70](result, 0x1000C8077774924);
    }
    *(void *)(v5 + 16) = 0;
  }
  *(_DWORD *)(v5 + 8) = v3;
  *(_DWORD *)(v5 + 12) = a2;
  return result;
}

void sub_1B7A73EB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void *LiString::LiString(void *a1, const void **a2)
{
  if (*((char *)a2 + 23) >= 0) {
    LODWORD(v3) = *((unsigned __int8 *)a2 + 23);
  }
  else {
    int v3 = a2[1];
  }
  if ((int)v3 < 1)
  {
    *a1 = 0;
  }
  else
  {
    uint64_t v5 = (unsigned int *)malloc_type_malloc(v3 + 13, 0x8903763CuLL);
    v5[2] = v3 + 1;
    atomic_store(1u, v5);
    *a1 = v5 + 3;
    v5[1] = v3;
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v6 = a2;
    }
    else {
      uint64_t v6 = *a2;
    }
    memcpy(v5 + 3, v6, v3);
    *(unsigned char *)(*a1 + v3) = 0;
  }
  return a1;
}

void LiString::LiString(LiString *this, PCString *a2)
{
  if (PCString::size(a2))
  {
    CStr = PCString::createCStr(a2);
    uint64_t v5 = CStr;
    if (CStr && *CStr)
    {
      uint64_t v6 = 0;
      while (CStr[++v6])
        ;
    }
    else
    {
      LODWORD(v6) = 0;
    }
    uint64_t v8 = (unsigned int *)malloc_type_malloc((int)v6 + 1 + 12, 0x8903763CuLL);
    void v8[2] = v6 + 1;
    atomic_store(1u, v8);
    *(void *)this = v8 + 3;
    v8[1] = v6;
    memcpy(v8 + 3, v5, (int)v6 + 1);
    free(v5);
  }
  else
  {
    *(void *)this = 0;
  }
}

void std::__tree<std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>,std::__map_value_compare<ProShade::Node const*,std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>,std::less<ProShade::Node const*>,true>,std::allocator<std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>>>::destroy(uint64_t a1, PCSharedCount *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>,std::__map_value_compare<ProShade::Node const*,std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>,std::less<ProShade::Node const*>,true>,std::allocator<std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>>>::destroy(a1, a2->var0);
    std::__tree<std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>,std::__map_value_compare<ProShade::Node const*,std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>,std::less<ProShade::Node const*>,true>,std::allocator<std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>>>::destroy(a1, a2[1].var0);
    a2[5].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
    PCSharedCount::~PCSharedCount(a2 + 8);
    operator delete(a2);
  }
}

void ProShade::Uniform44f::~Uniform44f(PCSharedCount *this)
{
  this->int var0 = (PC_Sp_counted_base *)&unk_1F1119970;
  PCSharedCount::~PCSharedCount(this + 3);
}

void ProShade::VarT<ProShade::UniformNode>::~VarT(PCSharedCount *a1)
{
  a1->int var0 = (PC_Sp_counted_base *)&unk_1F1119970;
  PCSharedCount::~PCSharedCount(a1 + 3);

  JUMPOUT(0x1BA9BFBA0);
}

PCSharedCount *ProShade::VarT<ProShade::SamplerNode>::~VarT(PCSharedCount *a1)
{
  a1->int var0 = (PC_Sp_counted_base *)&unk_1F11199B0;
  PCSharedCount::~PCSharedCount(a1 + 3);
  return a1;
}

void ProShade::VarT<ProShade::SamplerNode>::~VarT(PCSharedCount *a1)
{
  a1->int var0 = (PC_Sp_counted_base *)&unk_1F11199B0;
  PCSharedCount::~PCSharedCount(a1 + 3);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t PCArray<ProShade::VariableList::VariableEntry,PCArray_Traits<ProShade::VariableList::VariableEntry>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F11199D8;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<ProShade::VariableList::VariableEntry,PCArray_Traits<ProShade::VariableList::VariableEntry>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

void PCArray<ProShade::VariableList::VariableEntry,PCArray_Traits<ProShade::VariableList::VariableEntry>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F11199D8;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<ProShade::VariableList::VariableEntry,PCArray_Traits<ProShade::VariableList::VariableEntry>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

void PCArray<ProShade::VariableList::VariableEntry,PCArray_Traits<ProShade::VariableList::VariableEntry>>::resize(uint64_t a1, int a2, int a3)
{
  if (a3 <= a2) {
    int v3 = a2;
  }
  else {
    int v3 = a3;
  }
  if (a2 < 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v24, "PCArray::resize");
    PCException::PCException(exception, &v24);
    *(void *)exception = &unk_1F1199218;
  }
  if (v3 == *(_DWORD *)(a1 + 8))
  {
    uint64_t v6 = *(int *)(a1 + 12);
    if ((int)v6 <= a2)
    {
      if ((int)v6 < a2)
      {
        uint64_t v10 = 16 * v6;
        uint64_t v11 = a2 - v6;
        do
        {
          uint64_t v12 = (void *)(*(void *)(a1 + 16) + v10);
          *uint64_t v12 = 0;
          v12[1] = 0;
          v10 += 16;
          --v11;
        }
        while (v11);
      }
    }
    else
    {
      uint64_t v7 = 16 * a2;
      uint64_t v8 = a2;
      do
      {
        uint64_t v9 = *(void *)(a1 + 16) + v7;
        LiString::dec((LiString *)(v9 + 8));
        LiString::dec((LiString *)v9);
        ++v8;
        v7 += 16;
      }
      while (v8 < *(int *)(a1 + 12));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    int v13 = *(_DWORD *)(a1 + 12);
    if (a2 >= v13) {
      int v14 = *(_DWORD *)(a1 + 12);
    }
    else {
      int v14 = a2;
    }
    if (v14 < 1)
    {
      int v14 = 0;
    }
    else
    {
      int v15 = 0;
      do
      {
        uint64_t v16 = *(void *)(a1 + 16);
        uint64_t v17 = *(void *)((char *)v15 + v16);
        void *v15 = v17;
        if (v17) {
          atomic_fetch_add((atomic_uint *volatile)(v17 - 12), 1u);
        }
        uint64_t v18 = *(void *)((char *)v15 + v16 + 8);
        v15[1] = v18;
        if (v18) {
          atomic_fetch_add((atomic_uint *volatile)(v18 - 12), 1u);
        }
        uint64_t v19 = (char *)v15 + *(void *)(a1 + 16);
        LiString::dec((LiString *)(v19 + 8));
        LiString::dec((LiString *)v19);
        v15 += 2;
      }
      while ((void *)(16 * v14) != v15);
      int v13 = *(_DWORD *)(a1 + 12);
    }
    if (v14 < v13)
    {
      uint64_t v20 = 16 * v14;
      do
      {
        uint64_t v21 = *(void *)(a1 + 16) + v20;
        LiString::dec((LiString *)(v21 + 8));
        LiString::dec((LiString *)v21);
        v20 += 16;
        ++v14;
      }
      while (*(_DWORD *)(a1 + 12) > v14);
    }
    if (v14 < a2) {
      bzero((void *)(16 * v14), 16 * (~v14 + a2) + 16);
    }
    uint64_t v22 = *(void *)(a1 + 16);
    if (v22) {
      MEMORY[0x1BA9BFB70](v22, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = a2;
}

void sub_1B7A74690(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

uint64_t ProShade::VariableList::by_type(const char **a1, const char **a2)
{
  int v2 = *a2;
  int v3 = *a1;
  if (v2)
  {
    if (!v3) {
      return 0xFFFFFFFFLL;
    }
    int v4 = strcmp(v3, v2);
    if (v4 < 0) {
      return 0xFFFFFFFFLL;
    }
    if (!v4) {
      return 0;
    }
  }
  else if (!v3)
  {
    return 0;
  }
  return 1;
}

void ProShade::InsertVarying::eval(uint64_t a1@<X0>, const PCSharedCount *a2@<X1>, PCSharedCount *a3@<X8>)
{
  a3->int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  a3[2].int var0 = 0;
  PCSharedCount::PCSharedCount(a3 + 3);
  int v6 = ProShade::VarT<ProShade::Node>::frequency((uint64_t)a2);
  if (!v6)
  {
LABEL_6:
    ProShade::VarT<ProShade::Node>::operator=((uint64_t)a3, a2);
    return;
  }
  if (v6 == 1)
  {
    if ((ProShade::VarT<ProShade::Node>::atomic((uint64_t)a2) & 1) == 0) {
      operator new();
    }
    goto LABEL_6;
  }
  if (v6 != 3)
  {
    int var0 = a2[2].var0;
    if (*(unsigned char *)(a1 + 32))
    {
      if (!var0) {
        throw_PCNullPointerException(1);
      }
      uint64_t v8 = (const char *)*((void *)var0 + 4);
      if (!v8 || strcmp(*((const char **)var0 + 4), "gl_Normal") && strcmp(v8, "gl_Vertex")) {
        goto LABEL_19;
      }
    }
    else if (!var0)
    {
      throw_PCNullPointerException(1);
    }
    if (*((_DWORD *)var0 + 6) == 3) {
      operator new();
    }
  }
LABEL_19:
  ProShade::NodeOperator::apply((uint64_t)a2, v9);
  ProShade::VarT<ProShade::Node>::operator=((uint64_t)a3, v9);
  v9[0].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(&v10);
}

void sub_1B7A74914(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v4, 0x10B1C40515157B5);
  *uint64_t v1 = v2;
  PCSharedCount::~PCSharedCount(v3);
  _Unwind_Resume(a1);
}

void PCGLSLException::PCGLSLException(PCGLSLException *this, const PCString *a2)
{
  PCException::PCException(this, a2);
  v2->int var0 = (PC_Sp_counted_base *)&unk_1F1119A48;
  PCSharedCount::PCSharedCount(v2 + 8);
}

void sub_1B7A749D4(_Unwind_Exception *a1)
{
  PCException::~PCException(v1);
  _Unwind_Resume(a1);
}

void PCGLSLException::className(PCURL *a1@<X8>)
{
}

void PCGLSLException::report(PCString *this)
{
  PCException::report(this);
  CStr = PCString::createCStr(this + 8);
  if (CStr)
  {
    int v3 = CStr;
    size_t v4 = strlen(CStr);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)v3, v4);
    free(v3);
  }
}

uint64_t LiPerContext<ProShade::ProgramBase::Exe *,LiPerContextObject_Traits<ProShade::ProgramBase::Exe>,LiOpenGLContextGetter>::get(uint64_t a1, unsigned char *a2)
{
  size_t v4 = (os_unfair_lock_s *)(a1 + 24);
  void v9[2] = a1 + 24;
  PCSpinLock::lock((os_unfair_lock_t)(a1 + 24));
  v9[1] = 0;
  v9[0] = LiGLState::getCurrentContext(v5);
  uint64_t v6 = std::__tree<std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>,std::__map_value_compare<LiOpenGLContextGetter::C,std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>,LiOpenGLContextGetter::Compare,true>,std::allocator<std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>>>::find<LiOpenGLContextGetter::C>(a1, v9);
  if (a1 + 8 == v6)
  {
    *a2 = 1;
    PCSharedCount v10 = v9;
    std::__tree<std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>,std::__map_value_compare<LiOpenGLContextGetter::C,std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>,LiOpenGLContextGetter::Compare,true>,std::allocator<std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>>>::__emplace_unique_key_args<LiOpenGLContextGetter::C,std::piecewise_construct_t const&,std::tuple<LiOpenGLContextGetter::C const&>,std::tuple<>>((uint64_t **)a1, v9, (uint64_t)&std::piecewise_construct, (_OWORD **)&v10);
    operator new();
  }
  *a2 = 0;
  uint64_t v7 = v6 + 48;
  PCSpinLock::unlock(v4);
  return v7;
}

void sub_1B7A74BC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

uint64_t std::__tree<std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>,std::__map_value_compare<LiOpenGLContextGetter::C,std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>,LiOpenGLContextGetter::Compare,true>,std::allocator<std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>>>::find<LiOpenGLContextGetter::C>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v2 = a1 + 8;
  uint64_t v3 = v4;
  if (!v4) {
    return v2;
  }
  int v5 = *((_DWORD *)a2 + 2);
  unint64_t v6 = *a2;
  uint64_t v7 = v2;
  do
  {
    int v8 = *(_DWORD *)(v3 + 40);
    BOOL v10 = v8 == v5;
    BOOL v9 = v8 < v5;
    if (v10) {
      BOOL v9 = *(void *)(v3 + 32) < v6;
    }
    BOOL v10 = !v9;
    if (v9) {
      uint64_t v11 = (uint64_t *)(v3 + 8);
    }
    else {
      uint64_t v11 = (uint64_t *)v3;
    }
    if (v10) {
      uint64_t v7 = v3;
    }
    uint64_t v3 = *v11;
  }
  while (*v11);
  if (v7 == v2) {
    return v2;
  }
  int v12 = *(_DWORD *)(v7 + 40);
  BOOL v13 = v6 < *(void *)(v7 + 32);
  BOOL v10 = v5 == v12;
  BOOL v14 = v5 < v12;
  if (v10) {
    BOOL v14 = v13;
  }
  if (v14) {
    return v2;
  }
  return v7;
}

_OWORD *std::__tree<std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>,std::__map_value_compare<LiOpenGLContextGetter::C,std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>,LiOpenGLContextGetter::Compare,true>,std::allocator<std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>>>::__emplace_unique_key_args<LiOpenGLContextGetter::C,std::piecewise_construct_t const&,std::tuple<LiOpenGLContextGetter::C const&>,std::tuple<>>(uint64_t **a1, uint64_t *a2, uint64_t a3, _OWORD **a4)
{
  unint64_t v6 = (void **)std::__tree<std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>,std::__map_value_compare<LiOpenGLContextGetter::C,std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>,LiOpenGLContextGetter::Compare,true>,std::allocator<std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>>>::__find_equal<LiOpenGLContextGetter::C>((uint64_t)a1, &v10, a2);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    int v8 = (uint64_t **)v6;
    uint64_t v7 = operator new(0x38uLL);
    v7[2] = **a4;
    *((void *)v7 + 6) = 0;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v10, v8, (uint64_t *)v7);
  }
  return v7;
}

void *std::__tree<std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>,std::__map_value_compare<LiOpenGLContextGetter::C,std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>,LiOpenGLContextGetter::Compare,true>,std::allocator<std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>>>::__find_equal<LiOpenGLContextGetter::C>(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t result = (void *)(a1 + 8);
  uint64_t v4 = v5;
  if (v5)
  {
    int v6 = *((_DWORD *)a3 + 2);
    unint64_t v7 = *a3;
    do
    {
      while (1)
      {
        int v8 = (void *)v4;
        int v9 = *(_DWORD *)(v4 + 40);
        unint64_t v10 = v8[4];
        BOOL v11 = v7 < v10;
        if (v6 != v9) {
          BOOL v11 = v6 < v9;
        }
        if (!v11) {
          break;
        }
        uint64_t v4 = *v8;
        uint64_t result = v8;
        if (!*v8) {
          goto LABEL_15;
        }
      }
      BOOL v12 = v10 < v7;
      if (v6 == v9) {
        BOOL v13 = v12;
      }
      else {
        BOOL v13 = v9 < v6;
      }
      if (!v13) {
        break;
      }
      uint64_t result = v8 + 1;
      uint64_t v4 = v8[1];
    }
    while (v4);
  }
  else
  {
    int v8 = result;
  }
LABEL_15:
  *a2 = v8;
  return result;
}

void ProShade::Program::~Program(ProShade::Program *this, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(void *)this = *a2;
  *(void *)((char *)this + *(void *)(v4 - 24)) = a2[5];
  ProShade::UniformProgram::~UniformProgram((ProShade::Program *)((char *)this + 1472));
  *((void *)this + 181) = &unk_1F1119BF0;
  if (*((int *)this + 364) < 0) {
    int v5 = 1;
  }
  else {
    int v5 = *((_DWORD *)this + 364);
  }
  PCArray<ProShade::Sampler,PCArray_Traits<ProShade::Sampler>>::resize((uint64_t)this + 1448, 0, v5);
  uint64_t v6 = *((void *)this + 183);
  if (v6) {
    MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
  }
  *((void *)this + 183) = 0;
  *((_DWORD *)this + 364) = 0;
  *((void *)this + 178) = &unk_1F1119AC0;
  int v7 = *((_DWORD *)this + 358);
  if (v7 < 0) {
    int v8 = 1;
  }
  else {
    int v8 = v7 & ~(v7 >> 31);
  }
  if (v8 == v7)
  {
    uint64_t v9 = *((int *)this + 359);
    if ((v9 & 0x80000000) != 0)
    {
      do
      {
        *(void *)(*((void *)this + 180) + 8 * v9) = 0;
        BOOL v10 = __CFADD__(v9++, 1);
      }
      while (!v10);
    }
  }
  else
  {
    if (v8) {
      operator new[]();
    }
    uint64_t v11 = *((void *)this + 180);
    if (v11) {
      MEMORY[0x1BA9BFB70](v11, 0x1000C8077774924);
    }
    *((void *)this + 180) = 0;
  }
  *((_DWORD *)this + 358) = v8;
  *((_DWORD *)this + 359) = 0;
  uint64_t v12 = *((void *)this + 180);
  if (v12) {
    MEMORY[0x1BA9BFB70](v12, 0x1000C8077774924);
  }
  *((void *)this + 180) = 0;
  *((_DWORD *)this + 358) = 0;
  *((void *)this + 175) = &unk_1F1119AC0;
  int v13 = *((_DWORD *)this + 352);
  if (v13 < 0) {
    int v14 = 1;
  }
  else {
    int v14 = v13 & ~(v13 >> 31);
  }
  if (v14 == v13)
  {
    uint64_t v15 = *((int *)this + 353);
    if ((v15 & 0x80000000) != 0)
    {
      do
      {
        *(void *)(*((void *)this + 177) + 8 * v15) = 0;
        BOOL v10 = __CFADD__(v15++, 1);
      }
      while (!v10);
    }
  }
  else
  {
    if (v14) {
      operator new[]();
    }
    uint64_t v16 = *((void *)this + 177);
    if (v16) {
      MEMORY[0x1BA9BFB70](v16, 0x1000C8077774924);
    }
    *((void *)this + 177) = 0;
  }
  *((_DWORD *)this + 352) = v14;
  *((_DWORD *)this + 353) = 0;
  uint64_t v17 = *((void *)this + 177);
  if (v17) {
    MEMORY[0x1BA9BFB70](v17, 0x1000C8077774924);
  }
  *((void *)this + 177) = 0;
  *((_DWORD *)this + 352) = 0;
  *((void *)this + 165) = &unk_1F11191C0;
  std::__tree<LiString>::destroy((uint64_t)this + 1376, *((void **)this + 173));
  *((void *)this + 169) = &unk_1F1119A88;
  if (*((int *)this + 340) < 0) {
    int v18 = 1;
  }
  else {
    int v18 = *((_DWORD *)this + 340);
  }
  PCArray<ProShade::UniformVariable,PCArray_Traits<ProShade::UniformVariable>>::resize((uint64_t)this + 1352, 0, v18);
  uint64_t v19 = *((void *)this + 171);
  if (v19) {
    MEMORY[0x1BA9BFB70](v19, 0x1000C8077774924);
  }
  *((void *)this + 171) = 0;
  *((_DWORD *)this + 340) = 0;
  *((void *)this + 165) = &unk_1F112DF28;
  std::__tree<std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>,std::__map_value_compare<ProShade::Node const*,std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>,std::less<ProShade::Node const*>,true>,std::allocator<std::__value_type<ProShade::Node const*,ProShade::VarT<ProShade::Node>>>>::destroy((uint64_t)this + 1328, *((PCSharedCount **)this + 167));
  ProShade::FragmentProgram::~FragmentProgram((PCSharedCount *)this + 114);
  ProShade::VertexProgram::~VertexProgram((PCSharedCount *)this + 34);

  ProShade::ProgramBase::~ProgramBase(this, a2 + 1);
}

void ProShade::UniformProgram::~UniformProgram(ProShade::UniformProgram *this)
{
  uint64_t v2 = (void *)*((void *)this + 6);
  if (v2)
  {
    *((void *)this + 7) = v2;
    operator delete(v2);
  }
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 24, *((void **)this + 4));
  uint64_t v3 = (void **)this;
  std::vector<ProShade::UniformProgram::Register>::__destroy_vector::operator()[abi:ne180100](&v3);
}

void std::vector<ProShade::UniformProgram::Register>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (PCSharedCount *)**a1;
  if (v2)
  {
    uint64_t v4 = (PCSharedCount *)v1[1];
    int v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 15;
        std::allocator<ProShade::UniformProgram::Register>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while (v4 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator<ProShade::UniformProgram::Register>::destroy[abi:ne180100](uint64_t a1, PCSharedCount *a2)
{
  int var0 = a2[12].var0;
  if (var0)
  {
    a2[13].int var0 = var0;
    operator delete(var0);
  }
  uint64_t v4 = a2[9].var0;
  if (v4)
  {
    a2[10].int var0 = v4;
    operator delete(v4);
  }
  a2[4].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(a2 + 7);
  a2->int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;

  PCSharedCount::~PCSharedCount(a2 + 3);
}

uint64_t PCArray<ProShade::UniformVariable,PCArray_Traits<ProShade::UniformVariable>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F1119A88;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<ProShade::UniformVariable,PCArray_Traits<ProShade::UniformVariable>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

void std::__tree<LiString>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<LiString>::destroy(a1, *a2);
    std::__tree<LiString>::destroy(a1, a2[1]);
    LiString::dec((LiString *)(a2 + 4));
    operator delete(a2);
  }
}

void PCArray<ProShade::UniformVariable,PCArray_Traits<ProShade::UniformVariable>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F1119A88;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<ProShade::UniformVariable,PCArray_Traits<ProShade::UniformVariable>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

PCSharedCount *ProShade::VarT<ProShade::Node>::VarT(PCSharedCount *a1, PCShared_base *a2)
{
  a1->int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  a1[2].int var0 = (PC_Sp_counted_base *)a2;
  if (a2) {
    a2 = (PCShared_base *)((char *)a2 + *(void *)(*(void *)a2 - 24));
  }
  PCSharedCount::PCSharedCount(a1 + 3, a2);
  return a1;
}

void PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F1119AC0;
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2 < 0) {
    int v3 = 1;
  }
  else {
    int v3 = v2 & ~(v2 >> 31);
  }
  if (v3 == v2)
  {
    uint64_t v4 = *(int *)(a1 + 12);
    if ((v4 & 0x80000000) != 0)
    {
      do
        *(void *)(*(void *)(a1 + 16) + 8 * v4) = 0;
      while (!__CFADD__(v4++, 1));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6) {
      MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = 0;
  uint64_t v7 = *(void *)(a1 + 16);
  if (v7) {
    MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

ProShade::ConstVector *ProShade::ConstVector::ConstVector(ProShade::ConstVector *this, int a2)
{
  *((void *)this + 10) = &unk_1F1199AC8;
  *((void *)this + 11) = 0;
  *((unsigned char *)this + 96) = 1;
  ProShade::Node::Node(this, (uint64_t *)&off_1F112D778);
  uint64_t v4 = off_1F112D770;
  *(void *)this = off_1F112D770;
  *(void *)((char *)this + *(v4 - 3)) = off_1F112D798;
  *(void *)this = &unk_1F112D648;
  *((void *)this + 10) = &unk_1F112D750;
  *((double *)this + 6) = (double)a2;
  *((double *)this + 7) = (double)a2;
  *((double *)this + 8) = (double)a2;
  *((double *)this + 9) = (double)a2;
  *((void *)this + 3) = 0x100000002;
  return this;
}

void sub_1B7A756EC(_Unwind_Exception *a1)
{
  *(void *)(v1 + 80) = v2;
  *(unsigned char *)(v1 + 96) = 0;
  PCWeakCount::~PCWeakCount(v3);
  _Unwind_Resume(a1);
}

void PCArray<ProShade::Output,PCArray_Traits<ProShade::Output>>::resize(uint64_t a1, int a2, int a3)
{
  if (a3 <= a2) {
    int v3 = a2;
  }
  else {
    int v3 = a3;
  }
  if (a2 < 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v23, "PCArray::resize");
    PCException::PCException(exception, &v23);
    *(void *)exception = &unk_1F1199218;
  }
  if (v3 == *(_DWORD *)(a1 + 8))
  {
    uint64_t v6 = *(int *)(a1 + 12);
    if (a2 >= (int)v6)
    {
      if (a2 > (int)v6)
      {
        uint64_t v9 = 40 * v6;
        int v10 = a2 - v6;
        do
        {
          uint64_t v11 = (PCSharedCount *)(*(void *)(a1 + 16) + v9);
          v11->int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
          v11[2].int var0 = 0;
          PCSharedCount::PCSharedCount(v11 + 3);
          v11->int var0 = (PC_Sp_counted_base *)&unk_1F1119118;
          v11[4].int var0 = 0;
          v9 += 40;
          --v10;
        }
        while (v10);
      }
    }
    else
    {
      uint64_t v7 = a2;
      uint64_t v8 = 40 * a2;
      do
      {
        (*(void (**)(uint64_t))(*(void *)(*(void *)(a1 + 16) + v8) + 8))(*(void *)(a1 + 16) + v8);
        ++v7;
        v8 += 40;
      }
      while (v7 < *(int *)(a1 + 12));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    int v12 = *(_DWORD *)(a1 + 12);
    if (a2 >= v12) {
      int v13 = *(_DWORD *)(a1 + 12);
    }
    else {
      int v13 = a2;
    }
    if (v13 < 1)
    {
      int v13 = 0;
    }
    else
    {
      uint64_t v14 = 0;
      do
      {
        uint64_t v15 = *(void *)(a1 + 16);
        *(void *)uint64_t v14 = &unk_1F11193B8;
        uint64_t v16 = v15 + v14;
        *(unsigned char *)(v14 + 8) = *(unsigned char *)(v15 + v14 + 8);
        *(void *)(v14 + 16) = *(void *)(v15 + v14 + 16);
        PCSharedCount::PCSharedCount((PCSharedCount *)(v14 + 24), (const PCSharedCount *)(v15 + v14 + 24));
        *(void *)uint64_t v14 = &unk_1F1119118;
        uint64_t v17 = *(void *)(v16 + 32);
        *(void *)(v14 + 32) = v17;
        if (v17) {
          atomic_fetch_add((atomic_uint *volatile)(v17 - 12), 1u);
        }
        (*(void (**)(uint64_t))(*(void *)(*(void *)(a1 + 16) + v14) + 8))(*(void *)(a1 + 16) + v14);
        v14 += 40;
      }
      while (40 * v13 != v14);
      int v12 = *(_DWORD *)(a1 + 12);
    }
    if (v13 < v12)
    {
      uint64_t v18 = 40 * v13;
      do
      {
        (*(void (**)(uint64_t))(*(void *)(*(void *)(a1 + 16) + v18) + 8))(*(void *)(a1 + 16) + v18);
        v18 += 40;
        ++v13;
      }
      while (*(_DWORD *)(a1 + 12) > v13);
    }
    if (v13 < a2)
    {
      uint64_t v19 = 40 * v13;
      uint64_t v20 = (PCSharedCount *)v19;
      do
      {
        v20->int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
        v20[2].int var0 = 0;
        PCSharedCount::PCSharedCount(v20 + 3);
        v20->int var0 = (PC_Sp_counted_base *)&unk_1F1119118;
        v20[4].int var0 = 0;
        ++v13;
        v20 += 5;
        v19 += 40;
      }
      while (v13 < a2);
    }
    uint64_t v21 = *(void *)(a1 + 16);
    if (v21) {
      MEMORY[0x1BA9BFB70](v21, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = a2;
}

void sub_1B7A75AA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void *std::__tree<LiString>::find<LiString>(uint64_t a1, const char **a2)
{
  int v3 = (void *)(a1 + 8);
  uint64_t v4 = std::__tree<LiString>::__lower_bound<LiString>(a1, a2, *(void **)(a1 + 8), (void *)(a1 + 8));
  if (v3 == v4) {
    return v3;
  }
  int v5 = v4;
  uint64_t v6 = (const char *)v4[4];
  if (v6)
  {
    if (!*a2 || strcmp(*a2, v6) < 0) {
      return v3;
    }
  }
  return v5;
}

void *std::__tree<LiString>::__lower_bound<LiString>(uint64_t a1, const char **a2, void *a3, void *a4)
{
  if (a3)
  {
    int v5 = a3;
    uint64_t v6 = *a2;
    do
    {
      if (v6)
      {
        uint64_t v7 = (const char *)v5[4];
        if (v7)
        {
          if (strcmp(v7, v6) < 0) {
            ++v5;
          }
          else {
            a4 = v5;
          }
        }
        else
        {
          ++v5;
        }
      }
      else
      {
        a4 = v5;
      }
      int v5 = (void *)*v5;
    }
    while (v5);
  }
  return a4;
}

uint64_t *std::__tree<LiString>::__emplace_unique_key_args<LiString,LiString const&>(uint64_t **a1, const char **a2, uint64_t *a3)
{
  int v5 = (uint64_t **)std::__tree<LiString>::__find_equal<LiString>((uint64_t)a1, &v10, a2);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    uint64_t v7 = v5;
    uint64_t v6 = (uint64_t *)operator new(0x28uLL);
    uint64_t v8 = *a3;
    double v6[4] = *a3;
    if (v8) {
      atomic_fetch_add((atomic_uint *volatile)(v8 - 12), 1u);
    }
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v10, v7, v6);
  }
  return v6;
}

void *std::__tree<LiString>::__find_equal<LiString>(uint64_t a1, void *a2, const char **a3)
{
  int v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    uint64_t v6 = *a3;
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (void *)v4;
        uint64_t v8 = *(const char **)(v4 + 32);
        if (v8) {
          break;
        }
        if (!v6) {
          goto LABEL_14;
        }
LABEL_11:
        int v5 = v7 + 1;
        uint64_t v4 = v7[1];
        if (!v4) {
          goto LABEL_14;
        }
      }
      if (v6 && (strcmp(v6, *(const char **)(v4 + 32)) & 0x80000000) == 0)
      {
        if ((strcmp(v8, v6) & 0x80000000) == 0) {
          goto LABEL_14;
        }
        goto LABEL_11;
      }
      uint64_t v4 = *v7;
      int v5 = v7;
      if (!*v7) {
        goto LABEL_14;
      }
    }
  }
  uint64_t v7 = (void *)(a1 + 8);
LABEL_14:
  *a2 = v7;
  return v5;
}

void PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F1119AF8;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

_DWORD *std::__tree<std::__value_type<PCHash128,ProShade::Snippet *>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,ProShade::Snippet *>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,ProShade::Snippet *>>>::__emplace_unique_key_args<PCHash128,std::piecewise_construct_t const&,std::tuple<PCHash128 const&>,std::tuple<>>(uint64_t **a1, const PCHash128 *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t v6 = (void **)std::__tree<std::__value_type<PCHash128,PCRect<double>>,std::__map_value_compare<PCHash128,std::__value_type<PCHash128,PCRect<double>>,std::less<PCHash128>,true>,std::allocator<std::__value_type<PCHash128,PCRect<double>>>>::__find_equal<PCHash128>((uint64_t)a1, &v11, a2);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    uint64_t v7 = operator new(0x38uLL);
    uint64_t v9 = *a4;
    v7[8] = **a4;
    v7[9] = v9[1];
    v7[10] = v9[2];
    v7[11] = v9[3];
    *((void *)v7 + 6) = 0;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v11, v8, (uint64_t *)v7);
  }
  return v7;
}

void std::__tree<std::__value_type<LiString,int>,std::__map_value_compare<LiString,std::__value_type<LiString,int>,std::less<LiString>,true>,std::allocator<std::__value_type<LiString,int>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<LiString,int>,std::__map_value_compare<LiString,std::__value_type<LiString,int>,std::less<LiString>,true>,std::allocator<std::__value_type<LiString,int>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<LiString,int>,std::__map_value_compare<LiString,std::__value_type<LiString,int>,std::less<LiString>,true>,std::allocator<std::__value_type<LiString,int>>>::destroy(a1, a2[1]);
    LiString::dec((LiString *)(a2 + 4));
    operator delete(a2);
  }
}

uint64_t *std::__tree<std::__value_type<LiString,int>,std::__map_value_compare<LiString,std::__value_type<LiString,int>,std::less<LiString>,true>,std::allocator<std::__value_type<LiString,int>>>::__emplace_unique_key_args<LiString,std::piecewise_construct_t const&,std::tuple<LiString const&>,std::tuple<>>(uint64_t **a1, const char **a2, uint64_t a3, uint64_t **a4)
{
  uint64_t v6 = (uint64_t **)std::__tree<LiString>::__find_equal<LiString>((uint64_t)a1, &v12, a2);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    uint64_t v8 = v6;
    uint64_t v9 = (uint64_t *)operator new(0x30uLL);
    uint64_t v7 = v9;
    uint64_t v10 = **a4;
    void v9[4] = v10;
    if (v10) {
      atomic_fetch_add((atomic_uint *volatile)(v10 - 12), 1u);
    }
    *((_DWORD *)v9 + 10) = 0;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v12, v8, v9);
  }
  return v7;
}

void PCPtr<ProShade::Node>::reset<ProShade::Node>(PCShared_base **a1, PCShared_base *a2)
{
  if (*a1 != a2)
  {
    uint64_t v4 = a2;
    if (a2) {
      a2 = (PCShared_base *)((char *)a2 + *(void *)(*(void *)a2 - 24));
    }
    uint64_t v3 = (uint64_t *)PCSharedCount::PCSharedCount(&v5, a2);
    *a1 = v4;
    PCSharedCount::operator=(v3, (uint64_t *)a1 + 1);
    PCSharedCount::~PCSharedCount(&v5);
  }
}

void sub_1B7A75FAC(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1);
  _Unwind_Resume(a1);
}

uint64_t PCArray<ProShade::Sampler,PCArray_Traits<ProShade::Sampler>>::resize(uint64_t result, int a2, int a3)
{
  if (a3 <= a2) {
    int v3 = a2;
  }
  else {
    int v3 = a3;
  }
  if (a2 < 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v19, "PCArray::resize");
    PCException::PCException(exception, &v19);
    *(void *)exception = &unk_1F1199218;
  }
  uint64_t v5 = result;
  if (v3 == *(_DWORD *)(result + 8))
  {
    uint64_t v6 = *(int *)(result + 12);
    if (a2 >= (int)v6)
    {
      if (a2 > (int)v6)
      {
        uint64_t v9 = 96 * v6;
        int v10 = a2 - v6;
        do
        {
          uint64_t result = ProShade::Sampler::Sampler((ProShade::Sampler *)(*(void *)(v5 + 16) + v9));
          v9 += 96;
          --v10;
        }
        while (v10);
      }
    }
    else
    {
      uint64_t v7 = a2;
      uint64_t v8 = 96 * a2;
      do
      {
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(v5 + 16) + v8) + 8))(*(void *)(v5 + 16) + v8);
        ++v7;
        v8 += 96;
      }
      while (v7 < *(int *)(v5 + 12));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    int v11 = *(_DWORD *)(result + 12);
    if (a2 >= v11) {
      int v12 = *(_DWORD *)(result + 12);
    }
    else {
      int v12 = a2;
    }
    if (v12 < 1)
    {
      int v12 = 0;
    }
    else
    {
      uint64_t v13 = 0;
      do
      {
        uint64_t v14 = *(void *)(v5 + 16);
        *(void *)uint64_t v13 = &unk_1F11199B0;
        uint64_t v15 = v14 + v13;
        *(unsigned char *)(v13 + 8) = *(unsigned char *)(v14 + v13 + 8);
        *(void *)(v13 + 16) = *(void *)(v14 + v13 + 16);
        PCSharedCount::PCSharedCount((PCSharedCount *)(v13 + 24), (const PCSharedCount *)(v14 + v13 + 24));
        *(void *)uint64_t v13 = &unk_1F1119908;
        ProShade::VarT<ProShade::UniformNode>::VarT((PCSharedCount *)(v13 + 32), *(PCShared_base **)(v15 + 48));
        *(void *)(v13 + 32) = &unk_1F1119B30;
        ProShade::VarT<ProShade::UniformNode>::VarT((PCSharedCount *)(v13 + 64), *(PCShared_base **)(v15 + 80))->int var0 = (PC_Sp_counted_base *)&unk_1F1119BB0;
        (*(void (**)(uint64_t))(*(void *)(*(void *)(v5 + 16) + v13) + 8))(*(void *)(v5 + 16) + v13);
        v13 += 96;
      }
      while (96 * v12 != v13);
      int v11 = *(_DWORD *)(v5 + 12);
    }
    if (v12 < v11)
    {
      uint64_t v16 = 96 * v12;
      do
      {
        (*(void (**)(uint64_t))(*(void *)(*(void *)(v5 + 16) + v16) + 8))(*(void *)(v5 + 16) + v16);
        v16 += 96;
        ++v12;
      }
      while (*(_DWORD *)(v5 + 12) > v12);
    }
    if (v12 < a2)
    {
      uint64_t v17 = 96 * v12;
      do
      {
        uint64_t v17 = ProShade::Sampler::Sampler((ProShade::Sampler *)v17) + 96;
        ++v12;
      }
      while (v12 < a2);
    }
    uint64_t result = *(void *)(v5 + 16);
    if (result) {
      uint64_t result = MEMORY[0x1BA9BFB70](result, 0x1000C8077774924);
    }
    *(void *)(v5 + 16) = 0;
  }
  *(_DWORD *)(v5 + 8) = v3;
  *(_DWORD *)(v5 + 12) = a2;
  return result;
}

void sub_1B7A76318(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

PCSharedCount *ProShade::VarT<ProShade::UniformNode>::VarT(PCSharedCount *a1, PCShared_base *a2)
{
  a1->int var0 = (PC_Sp_counted_base *)&unk_1F1119970;
  a1[2].int var0 = (PC_Sp_counted_base *)a2;
  if (a2) {
    a2 = (PCShared_base *)((char *)a2 + *(void *)(*(void *)a2 - 24));
  }
  PCSharedCount::PCSharedCount(a1 + 3, a2);
  return a1;
}

void PCArray<ProShade::Sampler,PCArray_Traits<ProShade::Sampler>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F1119BF0;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<ProShade::Sampler,PCArray_Traits<ProShade::Sampler>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

void PCArray<ProShade::Output,PCArray_Traits<ProShade::Output>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F1119C28;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<ProShade::Output,PCArray_Traits<ProShade::Output>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t **std::__tree<std::__value_type<ProShade::SamplerNode const*,int>,std::__map_value_compare<ProShade::SamplerNode const*,std::__value_type<ProShade::SamplerNode const*,int>,std::less<ProShade::SamplerNode const*>,true>,std::allocator<std::__value_type<ProShade::SamplerNode const*,int>>>::__emplace_unique_key_args<ProShade::SamplerNode const*,std::piecewise_construct_t const&,std::tuple<ProShade::SamplerNode const*&&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, void **a4)
{
  uint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    int v11 = operator new(0x30uLL);
    double v11[4] = **a4;
    *((_DWORD *)v11 + 10) = 0;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t OUTLINED_FUNCTION_0_5(uint64_t a1, unsigned char **a2)
{
  **a2 = 0;
  if (*a2) {
    return (uint64_t)(*a2 - 12);
  }
  else {
    return 0;
  }
}

uint64_t OUTLINED_FUNCTION_1_2(uint64_t result)
{
  return result;
}

void ProShade::VertexProgram::VertexProgram(uint64_t a1)
{
  uint64_t v1 = OUTLINED_FUNCTION_1_2(a1);
  if (v3)
  {
    uint64_t v4 = (void *)OUTLINED_FUNCTION_0_5(v1, v2);
    free(v4);
  }
}

uint64_t ProShade::Program::shader(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  uint64_t v4 = MEMORY[0x1E4FBA418];
  uint64_t v5 = *MEMORY[0x1E4FBA418];
  *(void *)a2 = *MEMORY[0x1E4FBA418];
  *(void *)(a2 + *(void *)(v5 - 24)) = *(void *)(v4 + 24);
  *(void *)(a2 + 8) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a2 + 95) < 0) {
    operator delete(*(void **)(a2 + 72));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1BA9BFAB0](a2 + 112);
}

PCSharedCount *ProShade::Snippet::Snippet(PCSharedCount *this)
{
  this[5].int var0 = 0;
  LOBYTE(this[6].var0) = 1;
  this->int var0 = (PC_Sp_counted_base *)&unk_1F1119C68;
  this[4].int var0 = (PC_Sp_counted_base *)&unk_1F1119C98;
  PCSharedCount::PCSharedCount(this + 1);
  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)&this[2]);
  return this;
}

void sub_1B7A767F0(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;
  PCString::~PCString(v4);
  *(void *)(v1 + 32) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 48) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

void ProShade::Snippet::~Snippet(ProShade::Snippet *this)
{
  *(void *)this = &unk_1F1119C68;
  *((void *)this + 4) = &unk_1F1119C98;
  PCString::~PCString((PCString *)this + 1);
  *((void *)this + 4) = &unk_1F1199AC8;
  *((unsigned char *)this + 48) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)this + 5);
}

{
  uint64_t vars8;

  ProShade::Snippet::~Snippet(this);

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'ProShade::Snippet::~Snippet(ProShade::Snippet *this)
{
}

{
  uint64_t vars8;

  ProShade::Snippet::~Snippet((ProShade::Snippet *)((char *)this + *(void *)(*(void *)this - 24)));

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t ProShade::Snippet::code(ProShade::Snippet *this)
{
  return (uint64_t)this + 8;
}

void ProShade::External::define(uint64_t a1, const PCSharedCount *a2, const PCString *a3, int a4, int a5)
{
  *(PCSharedCount *)a1 = (PCSharedCount)a2->var0;
  uint64_t v9 = (uint64_t *)(a1 + 8);
  PCSharedCount::PCSharedCount(&v10, a2 + 1);
  PCSharedCount::operator=(v9, (uint64_t *)&v10);
  PCSharedCount::~PCSharedCount(&v10);
  PCString::set((PCString *)(a1 + 16), a3);
  *(_DWORD *)(a1 + 24) = a4;
  *(_DWORD *)(a1 + 28) = a5;
}

void sub_1B7A769F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

void ProShade::External::addArgument(uint64_t a1, int a2, int a3, const PCString *a4)
{
  uint64_t v8 = a1 + 32;
  int v9 = *(_DWORD *)(a1 + 44);
  if (*(_DWORD *)(a1 + 40) <= v9) {
    int v10 = (2 * (v9 + 1)) | 1;
  }
  else {
    int v10 = *(_DWORD *)(a1 + 40);
  }
  PCArray<ProShade::External::Argument,PCArray_Traits<ProShade::External::Argument>>::resize(v8, v9 + 1, v10);
  uint64_t v11 = *(void *)(a1 + 48) + 16 * *(int *)(a1 + 44);
  *(_DWORD *)(v11 - 16) = a2;
  *(_DWORD *)(v11 - 12) = a3;

  PCString::set((PCString *)(v11 - 8), a4);
}

void ProShade::Error<PCIllegalArgumentException>::raise<PCString>(OZChannelBase *a1, const PCString *a2)
{
  OZChannelBase::setRangeName(a1, a2);
  exception = (PCIllegalArgumentException *)__cxa_allocate_exception(0x40uLL);
  PCIllegalArgumentException::PCIllegalArgumentException(exception, (const PCString *)a1);
}

void sub_1B7A76ACC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

ProShade::ExternalNode *ProShade::ExternalNode::ExternalNode(ProShade::ExternalNode *this)
{
  *((void *)this + 10) = &unk_1F1199AC8;
  *((void *)this + 11) = 0;
  *((unsigned char *)this + 96) = 1;
  ProShade::Node::Node(this, (uint64_t *)&off_1F1119DA8);
  *(void *)this = &unk_1F1119CC8;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = &unk_1F1119D88;
  *((void *)this + 7) = &unk_1F1119AF8;
  *((void *)this + 8) = 0;
  *((void *)this + 6) = 0;
  return this;
}

void sub_1B7A76BA8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 80) = v2;
  *(unsigned char *)(v1 + 96) = 0;
  PCWeakCount::~PCWeakCount(v3);
  _Unwind_Resume(a1);
}

void ProShade::External::operator()(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 44) == 4) {
    operator new();
  }
  PCString::ssprintf((PCString *)"expected %d arguments, got 4", v2, *(unsigned int *)(a1 + 44));
  ProShade::Error<PCIllegalArgumentException>::raise<PCString>((OZChannelBase *)v2, v1);
}

{
  const PCString *v1;
  OZChannelBase var60;

  if (*(_DWORD *)(a1 + 44) == 5) {
    operator new();
  }
  PCString::ssprintf((PCString *)"expected %d arguments, got 5", (PCString *)&var60, *(unsigned int *)(a1 + 44));
  ProShade::Error<PCIllegalArgumentException>::raise<PCString>(&var60, v1);
}

void sub_1B7A76E40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCString a11)
{
  MEMORY[0x1BA9BFBA0](v11, 0x10B1C4041E1679CLL);
  _Unwind_Resume(a1);
}

void sub_1B7A77158(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCString a11)
{
  MEMORY[0x1BA9BFBA0](v11, 0x10B1C4041E1679CLL);
  _Unwind_Resume(a1);
}

uint64_t ProShade::ExternalNode::ExternalNode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 80) = &unk_1F1199AC8;
  *(void *)(a1 + 88) = 0;
  *(unsigned char *)(a1 + 96) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F1119DA8);
  *(void *)a1 = &unk_1F1119CC8;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = &unk_1F1119D88;
  *(void *)(a1 + 56) = &unk_1F1119AF8;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = a2;
  int v6 = *(_DWORD *)(a3 + 12);
  if (v6 <= 0) {
    int v7 = 0;
  }
  else {
    int v7 = (2 * v6) | 1;
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a1 + 56, v6, v7);
  if (*(int *)(a3 + 12) >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    do
    {
      ProShade::VarT<ProShade::Node>::operator=(*(void *)(a1 + 72) + v8, (const PCSharedCount *)(*(void *)(a3 + 16) + v8));
      ++v9;
      v8 += 32;
    }
    while (v9 < *(int *)(a3 + 12));
  }
  *(void *)(a1 + 24) = *(void *)(*(void *)(a1 + 48) + 24);
  (*(void (**)(uint64_t))(*(void *)a1 + 152))(a1);
  return a1;
}

void sub_1B7A77304(_Unwind_Exception *a1)
{
  *(void *)(v1 + 80) = v3;
  *(unsigned char *)(v1 + 96) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

void ProShade::ExternalNode::~ExternalNode(ProShade::ExternalNode *this, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(void *)this = *a2;
  *(void *)((char *)this + *(void *)(v4 - 24)) = a2[5];
  uint64_t v5 = (char *)this + 56;
  *((void *)this + 7) = &unk_1F1119AF8;
  if (*((int *)this + 16) < 0) {
    int v6 = 1;
  }
  else {
    int v6 = *((_DWORD *)this + 16);
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize((uint64_t)v5, 0, v6);
  uint64_t v7 = *((void *)this + 9);
  if (v7) {
    MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
  }
  *((void *)this + 9) = 0;
  *((_DWORD *)this + 16) = 0;
  uint64_t v8 = a2[1];
  *(void *)this = v8;
  *(void *)((char *)this + *(void *)(v8 - 24)) = a2[4];
  LiString::dec((ProShade::ExternalNode *)((char *)this + 32));
}

void ProShade::ExternalNode::~ExternalNode(ProShade::ExternalNode *this)
{
  *(void *)(v1 + 80) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 96) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 88));
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)(v1 + 80) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 96) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 88));

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'ProShade::ExternalNode::~ExternalNode(ProShade::ExternalNode *this)
{
  *(void *)(v1 + 80) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 96) = 0;
  uint64_t v2 = (PC_Sp_counted_base **)(v1 + 88);

  PCWeakCount::~PCWeakCount(v2);
}

{
  ProShade::ExternalNode::~ExternalNode((ProShade::ExternalNode *)((char *)this + *(void *)(*(void *)this - 24)));
}

void ProShade::ExternalNode::repr(ProShade::ExternalNode *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = (void *)a2;
  PCString v24 = 0;
  LODWORD(a2) = *((_DWORD *)this + 17);
  if ((int)a2 >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    do
    {
      if (v5)
      {
        LiString::append((LiString *)&v24, ", ", 2);
        LODWORD(a2) = *((_DWORD *)this + 17);
      }
      if (v5 >= (int)a2) {
        PCArray_base::badIndex(this);
      }
      ProShade::VarT<ProShade::Node>::repr(*((void *)this + 9) + v4);
      if (__src) {
        signed int v6 = *((_DWORD *)__src - 2);
      }
      else {
        signed int v6 = 0;
      }
      LiString::append((LiString *)&v24, __src, v6);
      if (__src && atomic_fetch_add((atomic_uint *volatile)__src - 3, 0xFFFFFFFF) == 1)
      {
        char *__src = 0;
        if (__src) {
          uint64_t v7 = __src - 12;
        }
        else {
          uint64_t v7 = 0;
        }
        free(v7);
      }
      ++v5;
      a2 = *((int *)this + 17);
      v4 += 32;
    }
    while (v5 < a2);
  }
  (*(void (**)(char **__return_ptr, ProShade::ExternalNode *))(*(void *)this + 24))(&__src, this);
  uint64_t v8 = __src;
  if (__src) {
    int v9 = *((_DWORD *)__src - 2);
  }
  else {
    int v9 = 0;
  }
  size_t v10 = v9;
  uint64_t v11 = (unsigned int *)malloc_type_malloc(v9 + 14, 0x8903763CuLL);
  v11[1] = v10 + 1;
  double v11[2] = v10 + 2;
  atomic_store(1u, v11);
  int v12 = v11 + 3;
  atomic_store(0, v11);
  memcpy(v11 + 3, v8, v10);
  v12[v10] = 40;
  v12[v10 + 1] = 0;
  atomic_fetch_add((atomic_uint *volatile)v11, 1u);
  size_t v13 = (int)v11[1];
  uint64_t v14 = v24;
  if (v24) {
    int v15 = *((_DWORD *)v24 - 2);
  }
  else {
    int v15 = 0;
  }
  size_t v16 = v13 + v15;
  uint64_t v17 = (unsigned int *)malloc_type_malloc(v16 + 13, 0x8903763CuLL);
  v17[1] = v16;
  v17[2] = v16 + 1;
  atomic_store(1u, v17);
  atomic_store(0, v17);
  memcpy(v17 + 3, v12, v13);
  memcpy((char *)v17 + v13 + 12, v14, v15);
  *((unsigned char *)v17 + v16 + 12) = 0;
  atomic_fetch_add((atomic_uint *volatile)v17, 1u);
  size_t v18 = (int)v17[1];
  PCString v19 = (unsigned int *)malloc_type_malloc(v18 + 14, 0x8903763CuLL);
  atomic_store(1u, v19);
  uint64_t v20 = v19 + 3;
  atomic_store(0, v19);
  v19[1] = v18 + 1;
  v19[2] = v18 + 2;
  memcpy(v19 + 3, v17 + 3, v18);
  *((unsigned char *)v20 + v18) = 41;
  *((unsigned char *)v20 + v18 + 1) = 0;
  *uint64_t v3 = v19 + 3;
  atomic_fetch_add((atomic_uint *volatile)v19, 1u);
  if (atomic_fetch_add((atomic_uint *volatile)v17, 0xFFFFFFFF) == 1) {
    free(v17);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v11, 0xFFFFFFFF) == 1) {
    free(v11);
  }
  if (__src && atomic_fetch_add((atomic_uint *volatile)__src - 3, 0xFFFFFFFF) == 1)
  {
    char *__src = 0;
    if (__src) {
      uint64_t v21 = __src - 12;
    }
    else {
      uint64_t v21 = 0;
    }
    free(v21);
  }
  if (v24 && atomic_fetch_add((atomic_uint *volatile)v24 - 3, 0xFFFFFFFF) == 1)
  {
    unsigned char *v24 = 0;
    if (v24) {
      uint64_t v22 = v24 - 12;
    }
    else {
      uint64_t v22 = 0;
    }
    free(v22);
  }
}

void sub_1B7A7793C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, atomic_uint *a9, atomic_uint *a10)
{
  if (atomic_fetch_add((atomic_uint *volatile)v11, 0xFFFFFFFF) == 1) {
    free(v11);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v10, 0xFFFFFFFF) == 1) {
    free(v10);
  }
  if (a9 && atomic_fetch_add(a9 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)a9 = 0;
    free(a9 - 3);
  }
  if (a10)
  {
    if (atomic_fetch_add(a10 - 3, 0xFFFFFFFF) == 1)
    {
      *(unsigned char *)a10 = 0;
      free(a10 - 3);
    }
  }
  _Unwind_Resume(exception_object);
}

void ProShade::ExternalNode::description(ProShade::ExternalNode *this@<X0>, LiString *a2@<X8>)
{
  PCString::PCString(&v4, (const PCString *)(*((void *)this + 6) + 16));
  uint64_t v3 = PCString::createCStr(&v4);
  PCString::~PCString(&v4);
  LiString::LiString(a2, v3);
  free(v3);
}

void sub_1B7A77A6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void ProShade::ExternalNode::computeHash(ProShade::ExternalNode *this, int8x8_t *a2)
{
  PCHashWriteStream::writeValue(a2, "ExternalNode");
  (*(void (**)(char **__return_ptr, ProShade::ExternalNode *))(*(void *)this + 24))(&v10, this);
  if (v10) {
    PCString v4 = v10;
  }
  else {
    PCString v4 = "";
  }
  if (v10) {
    size_t v5 = *((unsigned int *)v10 - 2);
  }
  else {
    size_t v5 = 0;
  }
  PCHashWriteStream::writeData(a2, v4, v5);
  if (*((int *)this + 17) >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    do
    {
      ProShade::VarT<ProShade::Node>::hash(*((void *)this + 9) + v6, &v9);
      PCHashWriteStream::writeValue(a2, (const PCHash128 *)&v9);
      ++v7;
      v6 += 32;
    }
    while (v7 < *((int *)this + 17));
  }
  if (v10 && atomic_fetch_add((atomic_uint *volatile)v10 - 3, 0xFFFFFFFF) == 1)
  {
    *size_t v10 = 0;
    if (v10) {
      uint64_t v8 = v10 - 12;
    }
    else {
      uint64_t v8 = 0;
    }
    free(v8);
  }
}

void sub_1B7A77B98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, atomic_uint *a12)
{
  if (a12)
  {
    if (atomic_fetch_add(a12 - 3, 0xFFFFFFFF) == 1)
    {
      *(unsigned char *)a12 = 0;
      free(a12 - 3);
    }
  }
  _Unwind_Resume(exception_object);
}

void ProShade::ExternalNode::inputs(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 68);
  if (*(_DWORD *)(a2 + 8) >= v4) {
    int v5 = *(_DWORD *)(a2 + 8);
  }
  else {
    int v5 = (2 * v4) | 1;
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a2, v4, v5);
  if (*(int *)(a1 + 68) >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    do
    {
      ProShade::VarT<ProShade::Node>::operator=(*(void *)(a2 + 16) + v6, (const PCSharedCount *)(*(void *)(a1 + 72) + v6));
      ++v7;
      v6 += 32;
    }
    while (v7 < *(int *)(a1 + 68));
  }
}

uint64_t ProShade::ExternalNode::apply@<X0>(uint64_t a1@<X0>, void (***a2)(PCSharedCount *__return_ptr, void, uint64_t)@<X1>, PCArray_base *a3@<X8>)
{
  int v4 = a3;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  PCString v19 = &unk_1F1119AF8;
  uint64_t v5 = *(unsigned int *)(a1 + 68);
  if ((int)v5 >= 1)
  {
    uint64_t v7 = 0;
    char v8 = 0;
    uint64_t v9 = 16;
    do
    {
      if (v7 >= *(int *)(a1 + 68)) {
        PCArray_base::badIndex(v4);
      }
      uint64_t v10 = *(void *)(a1 + 72);
      (**a2)(v17, a2, v10 + v9 - 16);
      int var0 = v17[2].var0;
      int v12 = *(PC_Sp_counted_base **)(v10 + v9);
      if ((int)v20 <= SHIDWORD(v20)) {
        int v13 = (2 * (HIDWORD(v20) + 1)) | 1;
      }
      else {
        int v13 = v20;
      }
      PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize((uint64_t)&v19, HIDWORD(v20) + 1, v13);
      ProShade::VarT<ProShade::Node>::operator=(v21 + 32 * SHIDWORD(v20) - 32, v17);
      v8 |= var0 != v12;
      v17[0].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
      PCSharedCount::~PCSharedCount(&v18);
      ++v7;
      v9 += 32;
    }
    while (v5 != v7);
    if (v8) {
      operator new();
    }
    int v4 = a3;
  }
  ProShade::VarT<ProShade::Node>::VarT((PCSharedCount *)v4, (PCShared_base *)a1);
  PCString v19 = &unk_1F1119AF8;
  if ((int)v20 < 0) {
    int v14 = 1;
  }
  else {
    int v14 = v20;
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize((uint64_t)&v19, 0, v14);
  uint64_t result = v21;
  if (v21) {
    return MEMORY[0x1BA9BFB70](v21, 0x1000C8077774924);
  }
  return result;
}

void sub_1B7A77E50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  MEMORY[0x1BA9BFBA0](v8, 0x10B1C4041E1679CLL);
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::~PCArray((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t ProShade::ExternalNode::atomic(ProShade::ExternalNode *this)
{
  return 0;
}

uint64_t ProShade::ExternalNode::setFrequency(ProShade::ExternalNode *this)
{
  uint64_t result = ProShade::Node::setFrequency(this);
  if (*((_DWORD *)this + 10) == 2 && *((int *)this + 11) >= 3) {
    *((_DWORD *)this + 10) = 3;
  }
  return result;
}

void ProShade::ExternalNode::clone(ProShade::ExternalNode *this)
{
}

void sub_1B7A77FBC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C4041E1679CLL);
  _Unwind_Resume(a1);
}

void ProShade::ExternalNode::computeValue(int a1, int a2, PCSharedCount *this)
{
}

PC_Sp_counted_base *ProShade::ExternalNode::snippet(ProShade::ExternalNode *this)
{
  uint64_t v1 = (const PCSharedCount *)*((void *)this + 6);
  int var0 = v1->var0;
  PCSharedCount::PCSharedCount(&v5, v1 + 1);
  PCSharedCount::~PCSharedCount(v2);
  return var0;
}

void PCArray<ProShade::External::Argument,PCArray_Traits<ProShade::External::Argument>>::resize(uint64_t a1, int a2, int a3)
{
  if (a3 <= a2) {
    int v3 = a2;
  }
  else {
    int v3 = a3;
  }
  if (a2 < 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v21, "PCArray::resize");
    PCException::PCException(exception, &v21);
    *(void *)exception = &unk_1F1199218;
  }
  if (v3 == *(_DWORD *)(a1 + 8))
  {
    uint64_t v6 = *(int *)(a1 + 12);
    if (a2 >= (int)v6)
    {
      if (a2 > (int)v6)
      {
        uint64_t v9 = 16 * v6;
        int v10 = a2 - v6;
        do
        {
          uint64_t v11 = *(void *)(a1 + 16);
          *(void *)(v11 + v9) = 0;
          *(void *)(v11 + v9 + 8) = 0;
          PCSharedCount::PCSharedCount((PCSharedCount *)(v11 + v9 + 8));
          v9 += 16;
          --v10;
        }
        while (v10);
      }
    }
    else
    {
      uint64_t v7 = a2;
      uint64_t v8 = (16 * a2) | 8;
      do
      {
        PCString::~PCString((PCString *)(*(void *)(a1 + 16) + v8));
        ++v7;
        v8 += 16;
      }
      while (v7 < *(int *)(a1 + 12));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    int v12 = *(_DWORD *)(a1 + 12);
    if (a2 >= v12) {
      int v13 = *(_DWORD *)(a1 + 12);
    }
    else {
      int v13 = a2;
    }
    if (v13 < 1)
    {
      int v13 = 0;
    }
    else
    {
      int v14 = 0;
      do
      {
        int v15 = (PCString *)((char *)v14 + *(void *)(a1 + 16));
        v14->int var0 = v15->var0;
        PCString::PCString(v14 + 1, v15 + 1);
        PCString::~PCString((PCString *)((char *)v14 + *(void *)(a1 + 16) + 8));
        v14 += 2;
      }
      while ((PCString *)(16 * v13) != v14);
      int v12 = *(_DWORD *)(a1 + 12);
    }
    if (v13 < v12)
    {
      uint64_t v16 = (16 * v13) | 8;
      do
      {
        PCString::~PCString((PCString *)(*(void *)(a1 + 16) + v16));
        v16 += 16;
        ++v13;
      }
      while (*(_DWORD *)(a1 + 12) > v13);
    }
    if (v13 < a2)
    {
      uint64_t v17 = (PCSharedCount *)(16 * v13 + 8);
      do
      {
        v17[-1].int var0 = 0;
        v17->int var0 = 0;
        PCSharedCount::PCSharedCount(v17);
        uint64_t v17 = v18 + 2;
        ++v13;
      }
      while (v13 < a2);
    }
    uint64_t v19 = *(void *)(a1 + 16);
    if (v19) {
      MEMORY[0x1BA9BFB70](v19, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = a2;
}

void sub_1B7A78274(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void PCIllegalArgumentException::PCIllegalArgumentException(PCIllegalArgumentException *this, const PCString *a2)
{
  PCException::PCException(this, a2);
  void *v2 = &unk_1F1199218;
}

void LiClipSet::LiClipSet(LiClipSet *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_1F10AD668;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 3) = &unk_1F10AD630;
}

void LiClipSet::LiClipSet(LiClipSet *this, const LiClipSet *a2)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_1F10AD668;
  int v4 = *((_DWORD *)a2 + 3);
  if (v4 <= 0) {
    int v5 = 0;
  }
  else {
    int v5 = (2 * v4) | 1;
  }
  PCArray<PCVector4<double>,PCArray_Traits<PCVector4<double>>>::resize((uint64_t)this, v4, v5);
  if (*((int *)a2 + 3) >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = (_OWORD *)(*((void *)a2 + 2) + v6);
      uint64_t v9 = (_OWORD *)(*((void *)this + 2) + v6);
      long long v10 = v8[1];
      _OWORD *v9 = *v8;
      v9[1] = v10;
      ++v7;
      v6 += 32;
    }
    while (v7 < *((int *)a2 + 3));
  }
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 3) = &unk_1F10AD630;
  int v11 = *((_DWORD *)a2 + 9);
  if (v11 <= 0) {
    int v12 = 0;
  }
  else {
    int v12 = (2 * v11) | 1;
  }
  PCArray<int,PCArray_Traits<int>>::resize((uint64_t)this + 24, v11, v12);
  if (*((int *)a2 + 9) >= 1)
  {
    uint64_t v13 = 0;
    uint64_t v14 = *((void *)a2 + 5);
    uint64_t v15 = *((void *)this + 5);
    do
    {
      *(_DWORD *)(v15 + 4 * v13) = *(_DWORD *)(v14 + 4 * v13);
      ++v13;
    }
    while (v13 < *((int *)a2 + 9));
  }
}

void sub_1B7A78434(_Unwind_Exception *a1)
{
  PCArray<PCVector4<double>,PCArray_Traits<PCVector4<double>>>::~PCArray(v1);
  _Unwind_Resume(a1);
}

uint64_t LiClipSet::operator=(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 12);
  if (*(_DWORD *)(a1 + 8) >= v4) {
    int v5 = *(_DWORD *)(a1 + 8);
  }
  else {
    int v5 = (2 * v4) | 1;
  }
  PCArray<PCVector4<double>,PCArray_Traits<PCVector4<double>>>::resize(a1, v4, v5);
  if (*(int *)(a2 + 12) >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = (_OWORD *)(*(void *)(a2 + 16) + v6);
      uint64_t v9 = (_OWORD *)(*(void *)(a1 + 16) + v6);
      long long v10 = v8[1];
      _OWORD *v9 = *v8;
      v9[1] = v10;
      ++v7;
      v6 += 32;
    }
    while (v7 < *(int *)(a2 + 12));
  }
  int v11 = *(_DWORD *)(a2 + 36);
  if (*(_DWORD *)(a1 + 32) >= v11) {
    int v12 = *(_DWORD *)(a1 + 32);
  }
  else {
    int v12 = (2 * v11) | 1;
  }
  PCArray<int,PCArray_Traits<int>>::resize(a1 + 24, v11, v12);
  if (*(int *)(a2 + 36) >= 1)
  {
    uint64_t v13 = 0;
    uint64_t v14 = *(void *)(a2 + 40);
    uint64_t v15 = *(void *)(a1 + 40);
    do
    {
      *(_DWORD *)(v15 + 4 * v13) = *(_DWORD *)(v14 + 4 * v13);
      ++v13;
    }
    while (v13 < *(int *)(a2 + 36));
  }
  return a1;
}

void LiClipSet::removeIndex(LiClipSet *this, int a2)
{
  LODWORD(v4) = *((_DWORD *)this + 3) - 1;
  if ((int)v4 > a2)
  {
    uint64_t v5 = a2;
    uint64_t v6 = 32 * a2;
    do
    {
      ++v5;
      uint64_t v7 = (_OWORD *)(*((void *)this + 2) + v6);
      long long v8 = v7[3];
      *uint64_t v7 = v7[2];
      v7[1] = v8;
      uint64_t v4 = *((int *)this + 3) - 1;
      v6 += 32;
    }
    while (v5 < v4);
  }
  if (*((_DWORD *)this + 2) >= (int)v4) {
    int v9 = *((_DWORD *)this + 2);
  }
  else {
    int v9 = (2 * v4) | 1;
  }
  PCArray<PCVector4<double>,PCArray_Traits<PCVector4<double>>>::resize((uint64_t)this, v4, v9);
  LODWORD(v10) = *((_DWORD *)this + 9) - 1;
  if ((int)v10 > a2)
  {
    uint64_t v11 = *((void *)this + 5);
    uint64_t v12 = a2;
    do
    {
      *(_DWORD *)(v11 + 4 * v12) = *(_DWORD *)(v11 + 4 * v12 + 4);
      uint64_t v10 = *((int *)this + 9) - 1;
      ++v12;
    }
    while (v12 < v10);
  }
  if (*((_DWORD *)this + 8) >= (int)v10) {
    int v13 = *((_DWORD *)this + 8);
  }
  else {
    int v13 = (2 * v10) | 1;
  }

  PCArray<int,PCArray_Traits<int>>::resize((uint64_t)this + 24, v10, v13);
}

double LiClipSet::add(uint64_t a1, double *a2, int a3)
{
  double result = a2[3];
  double v4 = a2[4];
  double v5 = a2[5];
  if (result * result + v4 * v4 + v5 * v5 > 0.0)
  {
    double v6 = -(result * *a2 + v4 * a2[1] + v5 * a2[2]);
    *(double *)uint64_t v7 = a2[3];
    *(double *)&v7[1] = v4;
    *(double *)&v7[2] = v5;
    *(double *)&_OWORD v7[3] = v6;
    LiClipSet::add(a1, (uint64_t)v7, a3);
  }
  return result;
}

void LiClipSet::add(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = a1;
  int v6 = *(_DWORD *)(a1 + 12);
  if (v6 == 1)
  {
    a1 = PCPlaneType(*(double **)(a1 + 16));
    if (a1 == 1) {
      return;
    }
    int v6 = *(_DWORD *)(v5 + 12);
  }
  if (v6 >= 1)
  {
    int v7 = 0;
    while (2)
    {
      if (v7 < 0) {
        PCArray_base::badIndex((PCArray_base *)a1);
      }
      a1 = PCComparePlanes((double *)a2, (double *)(*(void *)(v5 + 16) + 32 * v7));
      switch((int)a1)
      {
        case 0:
        case 3:
        case 5:
          return;
        case 1:
        case 7:
          LiClipSet::setEmpty((LiClipSet *)v5);
          return;
        case 2:
        case 4:
          LiClipSet::removeIndex((LiClipSet *)v5, v7);
          goto LABEL_12;
        case 6:
        case 8:
          ++v7;
LABEL_12:
          int v6 = *(_DWORD *)(v5 + 12);
          if (v7 >= v6) {
            break;
          }
          continue;
        default:
          PCPrint("File %s, line %d should not have been reached:\n\t", v8, v9, v10, v11, v12, v13, v14, (char)"/Library/Caches/com.apple.xbs/Sources/LithiumiOS/LiClipSet.cpp");
          pcAbortImpl();
      }
      break;
    }
  }
  if (*(_DWORD *)(v5 + 8) <= v6) {
    int v15 = (2 * (v6 + 1)) | 1;
  }
  else {
    int v15 = *(_DWORD *)(v5 + 8);
  }
  PCArray<PCVector4<double>,PCArray_Traits<PCVector4<double>>>::resize(v5, v6 + 1, v15);
  uint64_t v16 = *(void *)(v5 + 16) + 32 * *(int *)(v5 + 12);
  long long v17 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v16 - 32) = *(_OWORD *)a2;
  *(_OWORD *)(v16 - 16) = v17;
  int v18 = *(_DWORD *)(v5 + 36);
  if (*(_DWORD *)(v5 + 32) <= v18) {
    int v19 = (2 * (v18 + 1)) | 1;
  }
  else {
    int v19 = *(_DWORD *)(v5 + 32);
  }
  PCArray<int,PCArray_Traits<int>>::resize(v5 + 24, v18 + 1, v19);
  *(_DWORD *)(*(void *)(v5 + 40) + 4 * *(int *)(v5 + 36) - 4) = a3;
}

void LiClipSet::setEmpty(LiClipSet *this)
{
  if (*((int *)this + 2) >= 1) {
    int v2 = *((_DWORD *)this + 2);
  }
  else {
    int v2 = 3;
  }
  int v3 = (PCArray_base *)PCArray<PCVector4<double>,PCArray_Traits<PCVector4<double>>>::resize((uint64_t)this, 1, v2);
  int v4 = *((_DWORD *)this + 8);
  if (v4 <= 1) {
    int v5 = 1;
  }
  else {
    int v5 = *((_DWORD *)this + 8);
  }
  if (v4 >= 1) {
    int v6 = v5;
  }
  else {
    int v6 = 3;
  }
  if (v6 != v4) {
    operator new[]();
  }
  uint64_t v7 = *((int *)this + 9);
  if ((int)v7 <= 0) {
    bzero((void *)(*((void *)this + 5) + 4 * v7), 4 * -(int)v7 + 4);
  }
  *((_DWORD *)this + 8) = v6;
  *((_DWORD *)this + 9) = 1;
  if (*((int *)this + 3) < 1) {
    PCArray_base::badIndex(v3);
  }
  uint64_t v8 = (void *)*((void *)this + 2);
  void *v8 = 0;
  v8[1] = 0;
  void v8[2] = 0;
  void v8[3] = 0xBFF0000000000000;
  **((_DWORD **)this + 5) = 0;
}

void LiClipSet::add(LiClipSet *this, const LiClipSet *a2)
{
  uint64_t v2 = *((unsigned int *)a2 + 3);
  if ((int)v2 >= 1)
  {
    for (uint64_t i = 0; i != v2; ++i)
    {
      if (i >= *((int *)a2 + 3)) {
        PCArray_base::badIndex(this);
      }
      if (i >= *((int *)a2 + 9)) {
        PCArray_base::badIndex(this);
      }
      LiClipSet::add((uint64_t)this, *((void *)a2 + 2) + 32 * i, *(_DWORD *)(*((void *)a2 + 5) + 4 * i));
    }
  }
}

void LiClipSet::flatten(uint64_t a1, long long *a2)
{
  uint64_t v12 = 0x3FF0000000000000;
  uint64_t v9 = 0x3FF0000000000000;
  uint64_t v6 = 0x3FF0000000000000;
  uint64_t v3 = 0x3FF0000000000000;
  long long v4 = 0u;
  long long v5 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v13 = *a2;
  uint64_t v14 = *((void *)a2 + 2);
  PCMatrix44Tmpl<double>::flatten((uint64_t)&v3, (double *)a2, (double *)&v13);
  transform((PCArray_base *)&v3, a1);
}

void transform(PCArray_base *a1, uint64_t a2)
{
  if (*(int *)(a2 + 12) < 1) {
    return;
  }
  uint64_t v3 = (double *)a1;
  int v4 = 0;
  while (1)
  {
    if (v4 < 0) {
      PCArray_base::badIndex(a1);
    }
    long long v5 = (double *)(*(void *)(a2 + 16) + 32 * v4);
    PCMatrix44Tmpl<double>::transform_row<double>(v3, v5, v5);
    a1 = (PCArray_base *)PCPlaneType(v5);
    if (!a1)
    {
      LiClipSet::removeIndex((LiClipSet *)a2, v4);
      goto LABEL_9;
    }
    if (a1 == 1) {
      break;
    }
    ++v4;
LABEL_9:
    if (v4 >= *(_DWORD *)(a2 + 12)) {
      return;
    }
  }

  LiClipSet::setEmpty((LiClipSet *)a2);
}

uint64_t LiClipSet::containsBox(uint64_t a1, uint64_t *a2, double *a3)
{
  v23[30] = *MEMORY[0x1E4F143B8];
  int v3 = *(_DWORD *)(a1 + 12);
  if (v3)
  {
    if (v3 < 1)
    {
      char v17 = 0;
      return v17 & 1;
    }
    uint64_t v7 = 0;
LABEL_4:
    float64x2_t v19 = 0u;
    float64x2_t v20 = 0u;
    PCMatrix44Tmpl<double>::transform_row<double>(a3, (double *)(*(void *)(a1 + 16) + 32 * v7), v19.f64);
    uint64_t v8 = 0;
    uint64_t v9 = a2[1];
    uint64_t v10 = a2[2];
    uint64_t v11 = a2[3];
    uint64_t v21 = *a2;
    uint64_t v22 = v10;
    v23[2] = v9;
    v23[3] = v10;
    v23[6] = v9;
    v23[7] = v10;
    v23[10] = v21;
    v23[11] = v10;
    uint64_t v12 = a2[5];
    v23[0] = a2[4];
    v23[1] = 0x3FF0000000000000;
    v23[4] = v23[0];
    v23[5] = 0x3FF0000000000000;
    _OWORD v23[8] = v12;
    v23[9] = 0x3FF0000000000000;
    v23[12] = v12;
    v23[13] = 0x3FF0000000000000;
    v23[14] = v21;
    v23[15] = v11;
    void v23[16] = v23[0];
    v23[17] = 0x3FF0000000000000;
    v23[18] = v9;
    v23[19] = v11;
    v23[20] = v23[0];
    v23[21] = 0x3FF0000000000000;
    v23[22] = v9;
    v23[23] = v11;
    v23[24] = v12;
    v23[25] = 0x3FF0000000000000;
    v23[26] = v21;
    v23[27] = v11;
    v23[28] = v12;
    v23[29] = 0x3FF0000000000000;
    char v13 = 1;
    while (2)
    {
      uint64_t v14 = (float64x2_t *)&v23[4 * v8++];
      while (1)
      {
        float64x2_t v15 = vmulq_f64(v19, v14[-1]);
        float64x2_t v16 = vmulq_f64(v20, *v14);
        if (vaddq_f64(vaddq_f64(vaddq_f64(v15, (float64x2_t)vdupq_laneq_s64((int64x2_t)v15, 1)), v16), (float64x2_t)vdupq_laneq_s64((int64x2_t)v16, 1)).f64[0] < 0.0)break; {
        ++v8;
        }
        v14 += 2;
        if (v8 == 9)
        {
          if ((v13 & 1) == 0 || (++v7, v7 >= *(int *)(a1 + 12)))
          {
            char v17 = v13 ^ 1;
            return v17 & 1;
          }
          goto LABEL_4;
        }
      }
      char v13 = 0;
      if (v8 != 8) {
        continue;
      }
      break;
    }
  }
  char v17 = 1;
  return v17 & 1;
}

void PCArray<int,PCArray_Traits<int>>::resize(uint64_t a1, int a2, int a3)
{
  if (a3 <= a2) {
    int v3 = a2;
  }
  else {
    int v3 = a3;
  }
  if (a2 < 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v15, "PCArray::resize");
    PCException::PCException(exception, &v15);
    *(void *)exception = &unk_1F1199218;
  }
  if (v3 == *(_DWORD *)(a1 + 8))
  {
    uint64_t v6 = *(int *)(a1 + 12);
    if ((int)v6 < a2) {
      bzero((void *)(*(void *)(a1 + 16) + 4 * v6), 4 * (~v6 + a2) + 4);
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    int v7 = *(_DWORD *)(a1 + 12);
    if (a2 >= v7) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = a2;
    }
    if ((int)v8 < 1)
    {
      LODWORD(v8) = 0;
    }
    else
    {
      uint64_t v9 = *(int **)(a1 + 16);
      uint64_t v10 = v8;
      uint64_t v11 = 0;
      do
      {
        int v12 = *v9++;
        *v11++ = v12;
        --v10;
      }
      while (v10);
    }
    if ((int)v8 > v7) {
      int v7 = v8;
    }
    if (v7 < a2) {
      bzero((void *)(4 * v7), 4 * (~v7 + a2) + 4);
    }
    uint64_t v13 = *(void *)(a1 + 16);
    if (v13) {
      MEMORY[0x1BA9BFB70](v13, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = a2;
}

void sub_1B7A78E98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

BOOL PCMatrix44Tmpl<double>::flatten(uint64_t a1, double *a2, double *a3)
{
  double v3 = a2[1];
  double v4 = a2[2];
  double v5 = sqrt(*a2 * *a2 + v3 * v3 + v4 * v4);
  double v6 = *a2 / v5;
  double v7 = v3 / v5;
  double v8 = v4 / v5;
  double v9 = *a3 * v6;
  double v10 = v8 * a3[2] + v9 + a3[1] * v7;
  double v11 = v8 * (v8 * (-a2[3] / v5)) + v6 * (v6 * (-a2[3] / v5)) + v7 * (v7 * (-a2[3] / v5));
  *(double *)a1 = v10 - v9;
  *(double *)(a1 + 8) = -(v7 * *a3);
  *(double *)(a1 + 16) = -(v8 * *a3);
  *(double *)(a1 + 24) = v11 * *a3;
  *(double *)(a1 + 32) = -(v6 * a3[1]);
  *(double *)(a1 + 40) = v10 - v7 * a3[1];
  *(double *)(a1 + 48) = -(v8 * a3[1]);
  *(double *)(a1 + 56) = v11 * a3[1];
  *(double *)(a1 + 64) = -(v6 * a3[2]);
  *(double *)(a1 + 72) = -(v7 * a3[2]);
  *(double *)(a1 + 80) = v10 - v8 * a3[2];
  *(double *)(a1 + 88) = v11 * a3[2];
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 96) = 0;
  *(double *)(a1 + 120) = v10;
  return v10 >= 0.0000001 || v10 <= -0.0000001;
}

void LiCompositor::LiCompositor(LiCompositor *this)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 4);
  *((void *)this + 5) = 0;
  *((void *)this + 7) = 0;
  *((unsigned char *)this + 48) = 1;
}

void sub_1B7A79044(_Unwind_Exception *exception_object)
{
  double v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void LiCompositor::~LiCompositor(PCSharedCount *this)
{
  int var0 = this[5].var0;
  if (var0) {
    (*(void (**)(PC_Sp_counted_base *))(*(void *)var0 + 24))(var0);
  }
  PCSharedCount::~PCSharedCount(this + 4);
  double v3 = this->var0;
  if (this->var0)
  {
    this[1].int var0 = v3;
    operator delete(v3);
  }
}

BOOL LiCompositor::isStencil(int a1)
{
  return (a1 - 25) < 2;
}

uint64_t cropToPolygon@<X0>(LiImagePolygon *this@<X2>, HGRenderer *a2@<X0>, void *a3@<X1>, char a4@<W4>, void *a5@<X5>, int a6@<W6>, HGCrop **a7@<X8>, double a8@<D1>, char a9)
{
  int v9 = a6;
  if (a6) {
    goto LABEL_41;
  }
  if (a8 != 1.0) {
    goto LABEL_41;
  }
  float64x2_t v16 = (double *)**((void **)this + 11);
  if (((*(void *)(*((void *)this + 11) + 8) - (void)v16) & 0x1FFFFFFFE0) != 0x80) {
    goto LABEL_41;
  }
  double v17 = *v16;
  double v18 = v16[4];
  double v19 = v16[5];
  if (vabdd_f64(*v16, v18) < 0.000001)
  {
    double v20 = v16[9];
    if (vabdd_f64(v19, v20) < 0.000001)
    {
      double v21 = v16[8];
      if (vabdd_f64(v21, v16[12]) < 0.000001)
      {
        double v22 = v16[1];
        if (vabdd_f64(v16[13], v22) < 0.000001)
        {
          if (v17 >= v21) {
            double v23 = v16[8];
          }
          else {
            double v23 = *v16;
          }
          if (v17 >= v21) {
            double v24 = v17 - v21;
          }
          else {
            double v24 = v21 - v17;
          }
          if (v22 >= v20) {
            double v25 = v16[9];
          }
          else {
            double v25 = v16[1];
          }
          if (v22 >= v20) {
            double v26 = v22 - v20;
          }
          else {
            double v26 = v20 - v22;
          }
          goto LABEL_36;
        }
      }
    }
  }
  double v27 = v16[1];
  if (vabdd_f64(v27, v19) >= 0.000001
    || (double v28 = v16[8], vabdd_f64(v18, v28) >= 0.000001)
    || (double v29 = v16[9], vabdd_f64(v29, v16[13]) >= 0.000001)
    || vabdd_f64(v16[12], v17) >= 0.000001)
  {
LABEL_41:
    if (!*a5) {
      int v9 = 0;
    }
    if ((*(unsigned int (**)(HGRenderer *))(*(void *)a2 + 304))(a2))
    {
      LiFilteredPolygon::LiFilteredPolygon((LiFilteredPolygon *)&v34);
      char v38 = 1;
      LiFilteredPolygon::setPolygon((LiFilteredPolygon *)&v34, this);
      char v37 = a4;
      v33[1] = 0;
      if (v9 == 48)
      {
        OMSamplesElem::getBottom(v33);
        uint64_t v32 = (LiHeEdgeMixShader *)HGObject::operator new(0x1A0uLL);
        *((_OWORD *)v32 + 24) = 0u;
        *((_OWORD *)v32 + 25) = 0u;
        *((_OWORD *)v32 + 22) = 0u;
        *((_OWORD *)v32 + 23) = 0u;
        *((_OWORD *)v32 + 20) = 0u;
        *((_OWORD *)v32 + 21) = 0u;
        *((_OWORD *)v32 + 18) = 0u;
        *((_OWORD *)v32 + 19) = 0u;
        *((_OWORD *)v32 + 16) = 0u;
        *((_OWORD *)v32 + 17) = 0u;
        *((_OWORD *)v32 + 14) = 0u;
        *((_OWORD *)v32 + 15) = 0u;
        *((_OWORD *)v32 + 12) = 0u;
        *((_OWORD *)v32 + 13) = 0u;
        *((_OWORD *)v32 + 10) = 0u;
        *((_OWORD *)v32 + 11) = 0u;
        *((_OWORD *)v32 + 8) = 0u;
        *((_OWORD *)v32 + 9) = 0u;
        *((_OWORD *)v32 + 6) = 0u;
        *((_OWORD *)v32 + 7) = 0u;
        *((_OWORD *)v32 + 4) = 0u;
        *((_OWORD *)v32 + 5) = 0u;
        *((_OWORD *)v32 + 2) = 0u;
        *((_OWORD *)v32 + 3) = 0u;
        *(_OWORD *)uint64_t v32 = 0u;
        *((_OWORD *)v32 + 1) = 0u;
        LiHeEdgeMixShader::LiHeEdgeMixShader(v32);
      }
      LiFilteredPolygon::makeEdge((LiFilteredPolygon *)&v34, v33);
    }
    LiFilteredPolygon::LiFilteredPolygon((LiFilteredPolygon *)&v34);
    char v38 = 1;
    LiFilteredPolygon::setPolygon((LiFilteredPolygon *)&v34, this);
    char v37 = a4;
    LiFilteredPolygon::makeRasterizer((LiFilteredPolygon *)&v34, 0, a2);
  }
  if (v17 >= v28) {
    double v23 = v16[8];
  }
  else {
    double v23 = *v16;
  }
  if (v17 >= v28) {
    double v24 = v17 - v28;
  }
  else {
    double v24 = v28 - v17;
  }
  if (v27 >= v29) {
    double v25 = v16[9];
  }
  else {
    double v25 = v16[1];
  }
  if (v27 >= v29) {
    double v26 = v27 - v29;
  }
  else {
    double v26 = v29 - v27;
  }
LABEL_36:
  LiImagePolygon::getDOD(this, 0.0, &v34);
  if (vabdd_f64(v23, (double)v34.i32[0]) >= 0.000001
    || vabdd_f64(v25, (double)v34.i32[1]) >= 0.000001
    || vabdd_f64(v24, (double)v35) >= 0.000001
    || vabdd_f64(v26, (double)v36) >= 0.000001)
  {
    goto LABEL_41;
  }
  uint64_t v30 = (HGCrop *)HGObject::operator new(0x1A0uLL);
  HGCrop::HGCrop(v30);
  (*(void (**)(HGCrop *, void, float, float, float, float))(*(void *)v30 + 96))(v30, 0, (float)v34.i32[0], (float)v34.i32[1], (float)(v35 + v34.i32[0]), (float)(v36 + v34.i32[1]));
  uint64_t result = (*(uint64_t (**)(HGCrop *, void, void))(*(void *)v30 + 120))(v30, 0, *a3);
  *a7 = v30;
  return result;
}

void sub_1B7A79A48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  HGObject::operator delete(v12);
  _Unwind_Resume(a1);
}

CGColorSpace **blendNodes@<X0>(FxColorDescription *a1@<X4>, CGColorSpace **result@<X0>, uint64_t *a3@<X1>, int a4@<W2>, int a5@<W3>, uint64_t *a6@<X8>, float a7@<S0>, double a8@<D1>)
{
  if (*a3) {
    BOOL v9 = 1;
  }
  else {
    BOOL v9 = a5 == 0;
  }
  if (!v9)
  {
    *a6 = 0;
    return result;
  }
  float64x2_t v16 = (uint64_t *)result;
  makeBlendingColorDescription(a1, (uint64_t)&v32);
  if ((a4 - 25) > 1)
  {
    PCSharedCount::PCSharedCount(&v28);
    PCSharedCount::~PCSharedCount(v19);
    uint64_t v20 = *a3;
    if (a8 != 1.0 || v20)
    {
      if (a8 != 0.0)
      {
        uint64_t v22 = *v16;
        if (*v16)
        {
          if (a5)
          {
            double v23 = (HGStencil *)HGObject::operator new(0x1C0uLL);
            HGStencil::HGStencil(v23);
            (*(void (**)(HGStencil *, void, double, double, double, double))(*(void *)v23 + 96))(v23, 0, 0.0, 0.0, 0.0, 0.0);
            (*(void (**)(HGStencil *, uint64_t, float, double, double, double))(*(void *)v23 + 96))(v23, 1, 1.0, 0.0, 0.0, 0.0);
            conformWithToneMap(a1, v16, &v32, (uint64_t *)&v31);
            (*(void (**)(HGStencil *, void, HGStencil *))(*(void *)v23 + 120))(v23, 0, v31);
            if (v31) {
              (*(void (**)(HGStencil *))(*(void *)v31 + 24))(v31);
            }
            (*(void (**)(HGStencil *, uint64_t, uint64_t))(*(void *)v23 + 120))(v23, 1, *a3);
            (*(void (**)(HGStencil *))(*(void *)v23 + 16))(v23);
            conformWithToneMap(a1, v16, &v32, (uint64_t *)&v31);
            uint64_t v24 = (uint64_t)v31;
            (*(void (**)(HGStencil *))(*(void *)v23 + 24))(v23);
          }
          else
          {
            if (a4 == 27)
            {
              PCString v31 = (HGStencil *)*v16;
              (*(void (**)(uint64_t))(*(void *)v22 + 16))(v22);
            }
            else
            {
              conformWithToneMap(a1, v16, &v32, (uint64_t *)&v31);
            }
            double v23 = v31;
            if (v31)
            {
              (*(void (**)(HGStencil *))(*(void *)v31 + 16))(v31);
              if (v31) {
                (*(void (**)(HGStencil *))(*(void *)v31 + 24))(v31);
              }
            }
            conformWithToneMap(a1, a3, &v32, (uint64_t *)&v31);
            uint64_t v24 = (uint64_t)v31;
          }
          unsigned int v25 = LiHelium::convertMotionBlendMode(a4);
          double v26 = (HGHWBlendFlipped *)HGObject::operator new(0x220uLL);
          HGHWBlendFlipped::HGHWBlendFlipped(v26);
          (*(void (**)(HGHWBlendFlipped *, void, float, double, double, double))(*(void *)v26 + 96))(v26, 0, (float)v25, 0.0, 0.0, 0.0);
          float v27 = a8;
          (*(void (**)(HGHWBlendFlipped *, uint64_t, float, double, double, double))(*(void *)v26 + 96))(v26, 1, v27, 0.0, 0.0, 0.0);
          (*(void (**)(HGHWBlendFlipped *, uint64_t, double, double, double, double))(*(void *)v26 + 96))(v26, 2, 0.0, 0.0, 0.0, 0.0);
          (*(void (**)(HGHWBlendFlipped *, uint64_t, float, double, double, double))(*(void *)v26 + 96))(v26, 5, a7, 0.0, 0.0, 0.0);
          (*(void (**)(HGHWBlendFlipped *, void, uint64_t))(*(void *)v26 + 120))(v26, 0, v24);
          (*(void (**)(HGHWBlendFlipped *, uint64_t, HGStencil *))(*(void *)v26 + 120))(v26, 1, v23);
          PCString v31 = v26;
          (*(void (**)(HGHWBlendFlipped *))(*(void *)v26 + 16))(v26);
          conformWithToneMap(&v32, (uint64_t *)&v31, a1, a6);
          if (v31) {
            (*(void (**)(HGStencil *))(*(void *)v31 + 24))(v31);
          }
          (*(void (**)(HGHWBlendFlipped *))(*(void *)v26 + 24))(v26);
          if (v24) {
            (*(void (**)(uint64_t))(*(void *)v24 + 24))(v24);
          }
          if (v23) {
            (*(void (**)(HGStencil *))(*(void *)v23 + 24))(v23);
          }
          return PCCFRef<CGColorSpace *>::~PCCFRef(&v32._pcColorDesc._colorSpaceRef._obj);
        }
      }
    }
    else
    {
      uint64_t v20 = *v16;
    }
    *a6 = v20;
    if (v20) {
      (*(void (**)(uint64_t))(*(void *)v20 + 16))(v20);
    }
  }
  else
  {
    double v17 = (HGStencil *)HGObject::operator new(0x1C0uLL);
    HGStencil::HGStencil(v17);
    conformWithToneMap(a1, a3, &v32, (uint64_t *)&v31);
    if (a4 == 25)
    {
      uint64_t v18 = *v16;
      uint64_t v30 = v18;
      if (v18) {
        (*(void (**)(uint64_t))(*(void *)v18 + 16))(v18);
      }
      (*(void (**)(HGStencil *, void, double, double, double, double))(*(void *)v17 + 96))(v17, 0, 0.0, 0.0, 0.0, 0.0);
    }
    else
    {
      conformWithToneMap(a1, v16, &v32, &v30);
      (*(void (**)(HGStencil *, void, float, double, double, double))(*(void *)v17 + 96))(v17, 0, 1.0, 0.0, 0.0, 0.0);
    }
    (*(void (**)(HGStencil *, void, HGStencil *))(*(void *)v17 + 120))(v17, 0, v31);
    (*(void (**)(HGStencil *, uint64_t, uint64_t))(*(void *)v17 + 120))(v17, 1, v30);
    float v21 = a8;
    (*(void (**)(HGStencil *, uint64_t, float, double, double, double))(*(void *)v17 + 96))(v17, 1, v21, 0.0, 0.0, 0.0);
    double v29 = v17;
    (*(void (**)(HGStencil *))(*(void *)v17 + 16))(v17);
    conformWithToneMap(&v32, (uint64_t *)&v29, a1, a6);
    if (v29) {
      (*(void (**)(HGStencil *))(*(void *)v29 + 24))(v29);
    }
    if (v30) {
      (*(void (**)(uint64_t))(*(void *)v30 + 24))(v30);
    }
    if (v31) {
      (*(void (**)(HGStencil *))(*(void *)v31 + 24))(v31);
    }
    (*(void (**)(HGStencil *))(*(void *)v17 + 24))(v17);
  }
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v32._pcColorDesc._colorSpaceRef._obj);
}

void sub_1B7A7A7FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  if (a7) {
    (*(void (**)(uint64_t))(*(void *)a7 + 24))(a7);
  }
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
  }
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

uint64_t cropToPolygon@<X0>(HGRenderer *a1@<X0>, void *a2@<X1>, LiImagePolygon *a3@<X2>, char a4@<W4>, char a5@<W6>, HGCrop **a6@<X8>)
{
  uint64_t v7 = 0;
  cropToPolygon(a3, a1, a2, a4, &v7, 0, a6, 1.0, a5);
  uint64_t result = v7;
  if (v7) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v7 + 24))(v7);
  }
  return result;
}

void sub_1B7A7AC68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(exception_object);
}

void LiBlender::LiBlender(LiBlender *this, float a2, const FxColorDescription *a3)
{
  *(void *)this = &unk_1F1119F58;
  *((void *)this + 1) = 0;
  *((unsigned char *)this + 16) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = -1;
  *((unsigned char *)this + 48) = 0;
  *((float *)this + 13) = a2;
  obuint64_t j = a3->_pcColorDesc._colorSpaceRef._obj;
  *((void *)this + 7) = a3->_pcColorDesc._colorSpaceRef._obj;
  if (obj) {
    PCCFRefTraits<CGColorSpace *>::retain(obj);
  }
  uint64_t v6 = *(void *)&a3->_pcColorDesc._dynamicRange;
  *((_DWORD *)this + 18) = LODWORD(a3->_pcColorDesc._toneMapMethod._gain);
  *((void *)this + 8) = v6;
  *((unsigned char *)this + 80) = a3->_isPremultiplied;
}

void LiBlender::~LiBlender(CGColorSpace **this)
{
  *this = (CGColorSpace *)&unk_1F1119F58;
  PCCFRef<CGColorSpace *>::~PCCFRef(this + 7);
}

uint64_t LiBlender::crop(uint64_t result, uint64_t a2, char a3)
{
  *(void *)(result + 8) = a2;
  *(unsigned char *)(result + 16) = a3;
  return result;
}

void LiMultiBlender::LiMultiBlender(LiMultiBlender *this, float a2, FxColorDescription *a3)
{
  LiBlender::LiBlender(this, a2, a3);
  *(void *)uint64_t v5 = &unk_1F1119F98;
  *(void *)(v5 + 88) = 0;
  *(_DWORD *)(v5 + 96) = 0;
  makeBlendingColorDescription(a3, v5 + 104);
  *((void *)this + 18) = 0;
  *((void *)this + 19) = 0;
  *((void *)this + 17) = &unk_1F111A010;
  *((void *)this + 21) = 0;
  *((void *)this + 22) = 0;
  *((void *)this + 20) = &unk_1F111A010;
  *((void *)this + 24) = 0;
  *((void *)this + 25) = 0;
  *((void *)this + 23) = &unk_1F111A010;
  *((void *)this + 26) = &unk_1F111A048;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *((_DWORD *)this + 62) = 0;
  *((void *)this + 32) = 0x3FF0000000000000;
  *((unsigned char *)this + 264) = 0;
  *(_WORD *)((char *)this + 273) = 256;
}

void sub_1B7A7AE90(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 88);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  *(void *)uint64_t v1 = &unk_1F1119F58;
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(v1 + 56));
  _Unwind_Resume(a1);
}

void makeBlendingColorDescription(FxColorDescription *a1@<X0>, uint64_t a2@<X8>)
{
  if (FxColorDescription::isDynamicRangeManaged(a1))
  {
    {
      makeBlendingColorDescription(FxColorDescription const&)::blendingSpace = (uint64_t)PCGetNCLCColorSpace((unsigned int *)&kPCNCLC_Rec2020Linear);
    }
    {
      if (v4)
      {
        v5.i32[0] = 1.0;
        double WhiteGainForHLGLevel = PCColorUtil::getWhiteGainForHLGLevel(v4, v5);
        makeBlendingColorDescription(FxColorDescription const&)::toneMapMethod = 5;
        dword_1E9EE5CBC = LODWORD(WhiteGainForHLGLevel);
      }
    }
    uint64_t v3 = (CGColorSpace *)makeBlendingColorDescription(FxColorDescription const&)::blendingSpace;
    FxColorDescription::FxColorDescription(a2, v3, 0, &makeBlendingColorDescription(FxColorDescription const&)::toneMapMethod, 1);
  }
  else
  {
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    PCColorDescription::PCColorDescription((PCColorDescription *)a2);
    *(unsigned char *)(a2 + 24) = 1;
  }
}

void sub_1B7A7AFF4(_Unwind_Exception *a1)
{
}

uint64_t PCArray<LiMultiBlenderLayer,PCArray_Traits<LiMultiBlenderLayer>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111A048;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<LiMultiBlenderLayer,PCArray_Traits<LiMultiBlenderLayer>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

void LiMultiBlender::~LiMultiBlender(LiMultiBlender *this)
{
  *(void *)this = &unk_1F1119F98;
  uint64_t v2 = *((void *)this + 30);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  *((void *)this + 26) = &unk_1F111A048;
  if (*((int *)this + 54) < 0) {
    int v3 = 1;
  }
  else {
    int v3 = *((_DWORD *)this + 54);
  }
  PCArray<LiMultiBlenderLayer,PCArray_Traits<LiMultiBlenderLayer>>::resize((uint64_t)this + 208, 0, v3);
  uint64_t v5 = *((void *)this + 28);
  if (v5) {
    MEMORY[0x1BA9BFB70](v5, 0x1000C8077774924);
  }
  *((void *)this + 28) = 0;
  *((_DWORD *)this + 54) = 0;
  *((void *)this + 23) = &unk_1F111A010;
  if (*((int *)this + 48) < 0) {
    int v6 = 1;
  }
  else {
    int v6 = *((_DWORD *)this + 48);
  }
  PCArray<LiDrawnRegion::Rect,PCArray_Traits<LiDrawnRegion::Rect>>::resize((uint64_t)this + 184, 0, v6, v4);
  uint64_t v8 = *((void *)this + 25);
  if (v8) {
    MEMORY[0x1BA9BFB70](v8, 0x1000C8077774924);
  }
  *((void *)this + 25) = 0;
  *((_DWORD *)this + 48) = 0;
  *((void *)this + 20) = &unk_1F111A010;
  if (*((int *)this + 42) < 0) {
    int v9 = 1;
  }
  else {
    int v9 = *((_DWORD *)this + 42);
  }
  PCArray<LiDrawnRegion::Rect,PCArray_Traits<LiDrawnRegion::Rect>>::resize((uint64_t)this + 160, 0, v9, v7);
  uint64_t v11 = *((void *)this + 22);
  if (v11) {
    MEMORY[0x1BA9BFB70](v11, 0x1000C8077774924);
  }
  *((void *)this + 22) = 0;
  *((_DWORD *)this + 42) = 0;
  *((void *)this + 17) = &unk_1F111A010;
  if (*((int *)this + 36) < 0) {
    int v12 = 1;
  }
  else {
    int v12 = *((_DWORD *)this + 36);
  }
  PCArray<LiDrawnRegion::Rect,PCArray_Traits<LiDrawnRegion::Rect>>::resize((uint64_t)this + 136, 0, v12, v10);
  uint64_t v13 = *((void *)this + 19);
  if (v13) {
    MEMORY[0x1BA9BFB70](v13, 0x1000C8077774924);
  }
  *((void *)this + 19) = 0;
  *((_DWORD *)this + 36) = 0;
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)this + 13);
  uint64_t v14 = *((void *)this + 11);
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);
  }
  *(void *)this = &unk_1F1119F58;
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)this + 7);
}

{
  uint64_t vars8;

  LiMultiBlender::~LiMultiBlender(this);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t LiMultiBlender::clear(LiMultiBlender *this)
{
  uint64_t v2 = *((void *)this + 30);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
    *((void *)this + 30) = 0;
  }
  *((_DWORD *)this + 24) = 0;
  uint64_t result = *((void *)this + 11);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
    *((void *)this + 11) = 0;
  }
  *((unsigned char *)this + 273) = 0;
  *((_DWORD *)this + 58) = 0;
  return result;
}

uint64_t LiMultiBlender::add(uint64_t a1, uint64_t *a2, int a3, char a4, char a5, const PCSharedCount *a6, double a7)
{
  uint64_t v44 = 0;
  LODWORD(v45) = 0;
  *((void *)&v45 + 1) = 0x3FF0000000000000;
  char v46 = 0;
  uint64_t v13 = *a2;
  if (*a2)
  {
    uint64_t v44 = *a2;
    (*(void (**)(uint64_t))(*(void *)v13 + 16))(v13);
  }
  LODWORD(v45) = a3;
  *((double *)&v45 + 1) = a7;
  char v46 = a5;
  *(unsigned char *)(a1 + 272) = a4;
  if (*(unsigned char *)(a1 + 273))
  {
    uint64_t v14 = *(void *)(a1 + 88);
    if (v14)
    {
      uint64_t v43 = *(void *)(a1 + 88);
      (*(void (**)(uint64_t))(*(void *)v14 + 16))(v14);
      conformWithToneMap((FxColorDescription *)(a1 + 104), &v43, (FxColorDescription *)(a1 + 56), (uint64_t *)v42);
      uint64_t v15 = *(void *)(a1 + 240);
      float64_t v16 = v42[0].f64[0];
      if (v15 == *(void *)&v42[0].f64[0])
      {
        if (v15) {
          (*(void (**)(uint64_t))(*(void *)v15 + 24))(v15);
        }
      }
      else
      {
        if (v15)
        {
          (*(void (**)(uint64_t))(*(void *)v15 + 24))(v15);
          float64_t v16 = v42[0].f64[0];
        }
        *(float64_t *)(a1 + 240) = v16;
        v42[0].f64[0] = 0.0;
      }
      if (v43) {
        (*(void (**)(uint64_t))(*(void *)v43 + 24))(v43);
      }
      *(void *)(a1 + 256) = 0x3FF0000000000000;
      *(_DWORD *)(a1 + 248) = 0;
      uint64_t v17 = *(void *)(a1 + 88);
      if (v17)
      {
        (*(void (**)(uint64_t))(*(void *)v17 + 24))(v17);
        *(void *)(a1 + 88) = 0;
      }
      *(_DWORD *)(a1 + 96) = 1;
      *(unsigned char *)(a1 + 273) = 0;
    }
  }
  uint64_t v18 = *(void ***)(a1 + 8);
  if (v18)
  {
    if (!*(unsigned char *)(a1 + 48)) {
      goto LABEL_19;
    }
    uint64_t v19 = *(void *)(a1 + 32);
    uint64_t v20 = *(void *)(a1 + 40);
    v21.i64[0] = (int)v19;
    v21.i64[1] = SHIDWORD(v19);
    float64x2_t v22 = vcvtq_f64_s64(v21);
    v21.i64[0] = (int)v20;
    v21.i64[1] = SHIDWORD(v20);
    v42[0] = v22;
    v42[1] = vcvtq_f64_s64(v21);
    if (!LiPolygon::contains(v18, v42))
    {
LABEL_19:
      double v23 = *(HGRenderer **)(a1 + 24);
      uint64_t v24 = v44;
      uint64_t v43 = v44;
      if (v44) {
        (*(void (**)(uint64_t))(*(void *)v44 + 16))(v44);
      }
      cropToPolygon(v23, &v43, *(LiImagePolygon **)(a1 + 8), *(unsigned char *)(a1 + 16), 0, (HGCrop **)v42);
      float64_t v25 = v42[0].f64[0];
      if (v44 == *(void *)&v42[0].f64[0])
      {
        if (v44) {
          (*(void (**)(void))(*(void *)v44 + 24))();
        }
      }
      else
      {
        if (v44)
        {
          (*(void (**)(void))(*(void *)v44 + 24))();
          float64_t v25 = v42[0].f64[0];
        }
        uint64_t v44 = *(void *)&v25;
        v42[0].f64[0] = 0.0;
      }
      if (v24) {
        (*(void (**)(uint64_t))(*(void *)v24 + 24))(v24);
      }
    }
    *(void *)(a1 + 8) = 0;
  }
  if (*(_DWORD *)(a1 + 96))
  {
    if ((v45 - 25) > 1)
    {
      int var0 = a6->var0;
      PCSharedCount::PCSharedCount(&v41, a6 + 1);
      if (var0
        && *((_DWORD *)var0 + 2) == 35
        && (uint64_t v29 = *((void *)var0 + 2)) != 0
        && *(float *)(v29 + 12) > 0.0
        && *(float *)(v29 + 24) > 0.0)
      {
        PCSharedCount::~PCSharedCount(v28);
        if (!a6->var0) {
          throw_PCNullPointerException(1);
        }
        LiMultiBlender::addLightWrap(a1, (uint64_t)&v44, *((void *)a6->var0 + 2));
      }
      else
      {
        PCSharedCount::~PCSharedCount(v28);
        if (v46) {
          LiMultiBlender::addPreserveOpacity(a1, (uint64_t)&v44);
        }
        else {
          (*(void (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v44);
        }
      }
    }
    else
    {
      LiMultiBlender::addStencil(a1, (uint64_t)&v44);
    }
  }
  else if (!v46 && (PCBlend::isNothingOverNothing(v45) & 1) == 0)
  {
    double v26 = *(HGNode **)(a1 + 240);
    uint64_t v27 = v44;
    if (v26 != (HGNode *)v44)
    {
      if (v26)
      {
        (*(void (**)(void))(*(void *)v26 + 24))(*(void *)(a1 + 240));
        uint64_t v27 = v44;
      }
      *(void *)(a1 + 240) = v27;
      if (v27)
      {
        (*(void (**)(uint64_t))(*(void *)v27 + 16))(v27);
        double v26 = (HGNode *)v44;
      }
      else
      {
        double v26 = 0;
      }
    }
    *(_OWORD *)(a1 + 248) = v45;
    *(unsigned char *)(a1 + 264) = v46;
    ++*(_DWORD *)(a1 + 96);
    unint64_t DOD = HGRenderer::GetDOD(*(HGRenderer **)(a1 + 24), v26);
    unint64_t v32 = v31;
    v42[0].f64[0] = 0.0;
    if (HGRectIsNull(DOD, v31))
    {
      int v33 = -1;
      int v34 = -1;
    }
    else
    {
      if ((int)DOD <= -1073741823) {
        int v35 = -1073741823;
      }
      else {
        int v35 = DOD;
      }
      unint64_t v36 = HIDWORD(DOD);
      if (SHIDWORD(DOD) <= -1073741823) {
        LODWORD(v36) = -1073741823;
      }
      if ((int)v32 >= 1073741822) {
        int v37 = 1073741822;
      }
      else {
        int v37 = v32;
      }
      unint64_t v38 = HIDWORD(v32);
      if (SHIDWORD(v32) >= 1073741822) {
        LODWORD(v38) = 1073741822;
      }
      *(void *)&v42[0].f64[0] = __PAIR64__(v36, v35);
      int v33 = v37 - v35;
      int v34 = v38 - v36;
    }
    *(void *)&v42[0].f64[1] = __PAIR64__(v34, v33);
    LiDrawnRegion::add(a1 + 136, (int32x2_t *)v42, 1, 1, 0);
  }
  uint64_t result = v44;
  if (v44) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v44 + 24))(v44);
  }
  return result;
}

void sub_1B7A7B8EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  PGHelium::MetalTextureCacheEntry::~MetalTextureCacheEntry((PGHelium::MetalTextureCacheEntry *)va);
  _Unwind_Resume(a1);
}

uint64_t conformWithToneMap@<X0>(FxColorDescription *this@<X1>, uint64_t *a2@<X0>, FxColorDescription *a3@<X2>, uint64_t *a4@<X8>)
{
  if FxColorDescription::isColorManaged(this) && (FxColorDescription::isColorManaged(a3))
  {
    if (FxColorDescription::isHDR(this) && FxColorDescription::isSDR(a3))
    {
      CGColorSpaceRef v8 = PCGetNCLCColorSpace((unsigned int *)&kPCNCLC_Rec2020Linear);
      uint64_t CGColorSpace = FxColorDescription::getCGColorSpace(this);
      BOOL isPremultiplied = FxColorDescription::isPremultiplied(this);
      FxApplyColorConform(a2, CGColorSpace, isPremultiplied, v8, 0);
      FxApplyColorConform(&v29, (uint64_t)&kPCNCLC_Rec2020Linear, 0, (uint64_t)&kPCNCLC_Rec2020HLG, 0, &v28);
      uint64_t v11 = v28;
      if (v29 == v28)
      {
        if (v29) {
          (*(void (**)(void))(*(void *)v29 + 24))();
        }
      }
      else
      {
        if (v29)
        {
          (*(void (**)(void))(*(void *)v29 + 24))();
          uint64_t v11 = v28;
        }
        uint64_t v29 = v11;
      }
      FxApplyColorConform(&v29, (uint64_t)&kPCNCLC_Rec709, 0, (uint64_t)&kPCNCLC_Rec709Linear, 0, &v28);
      uint64_t v22 = v28;
      if (v29 == v28)
      {
        if (v29) {
          (*(void (**)(void))(*(void *)v29 + 24))();
        }
      }
      else
      {
        if (v29)
        {
          (*(void (**)(void))(*(void *)v29 + 24))();
          uint64_t v22 = v28;
        }
        uint64_t v29 = v22;
      }
      uint64_t v23 = FxColorDescription::getCGColorSpace(a3);
      BOOL v24 = FxColorDescription::isPremultiplied(a3);
      FxApplyColorConform(&v29, v8, 0, v23, v24);
      uint64_t result = v29;
      if (v29) {
        return (*(uint64_t (**)(uint64_t))(*(void *)v29 + 24))(result);
      }
    }
    else if (FxColorDescription::isSDR(this) && FxColorDescription::isHDR(a3))
    {
      CGColorSpaceRef v14 = PCGetNCLCColorSpace((unsigned int *)&kPCNCLC_Rec2020Linear);
      uint64_t v15 = FxColorDescription::getCGColorSpace(this);
      BOOL v16 = FxColorDescription::isPremultiplied(this);
      FxApplyColorConform(a2, v15, v16, v14, 0);
      FxApplyColorConform(&v29, (uint64_t)&kPCNCLC_Rec709Linear, 0, (uint64_t)&kPCNCLC_Rec709, 0, &v28);
      uint64_t v17 = v28;
      if (v29 == v28)
      {
        if (v29) {
          (*(void (**)(void))(*(void *)v29 + 24))();
        }
      }
      else
      {
        if (v29)
        {
          (*(void (**)(void))(*(void *)v29 + 24))();
          uint64_t v17 = v28;
        }
        uint64_t v29 = v17;
      }
      FxApplyColorConform(&v29, (uint64_t)&kPCNCLC_Rec2020HLG, 0, (uint64_t)&kPCNCLC_Rec2020Linear, 0, &v28);
      uint64_t v25 = v28;
      if (v29 == v28)
      {
        if (v29) {
          (*(void (**)(void))(*(void *)v29 + 24))();
        }
      }
      else
      {
        if (v29)
        {
          (*(void (**)(void))(*(void *)v29 + 24))();
          uint64_t v25 = v28;
        }
        uint64_t v29 = v25;
      }
      uint64_t v26 = FxColorDescription::getCGColorSpace(a3);
      BOOL v27 = FxColorDescription::isPremultiplied(a3);
      FxApplyColorConform(&v29, v14, 0, v26, v27);
      uint64_t result = v29;
      if (v29) {
        return (*(uint64_t (**)(uint64_t))(*(void *)v29 + 24))(result);
      }
    }
    else
    {
      uint64_t v18 = FxColorDescription::getCGColorSpace(this);
      BOOL v19 = FxColorDescription::isPremultiplied(this);
      uint64_t v20 = FxColorDescription::getCGColorSpace(a3);
      BOOL v21 = FxColorDescription::isPremultiplied(a3);
      return FxApplyColorConform(a2, v18, v19, v20, v21);
    }
  }
  else
  {
    uint64_t result = *a2;
    *a4 = *a2;
    if (result)
    {
      uint64_t v13 = *(uint64_t (**)(void))(*(void *)result + 16);
      return v13();
    }
  }
  return result;
}

{
  CGColorSpaceRef v8;
  uint64_t CGColorSpace;
  BOOL isPremultiplied;
  uint64_t v11;
  uint64_t result;
  uint64_t (*v13)(void);
  CGColorSpaceRef v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t vars8;

  if FxColorDescription::isColorManaged(this) && (FxColorDescription::isColorManaged(a3))
  {
    if (FxColorDescription::isHDR(this) && FxColorDescription::isSDR(a3))
    {
      CGColorSpaceRef v8 = PCGetNCLCColorSpace((unsigned int *)&kPCNCLC_Rec2020Linear);
      uint64_t CGColorSpace = FxColorDescription::getCGColorSpace(this);
      BOOL isPremultiplied = FxColorDescription::isPremultiplied(this);
      FxApplyColorConform(a2, CGColorSpace, isPremultiplied, v8, 0);
      FxApplyColorConform(&v29, (uint64_t)&kPCNCLC_Rec2020Linear, 0, (uint64_t)&kPCNCLC_Rec2020HLG, 0, &v28);
      uint64_t v11 = v28;
      if (v29 == v28)
      {
        if (v29) {
          (*(void (**)(void))(*(void *)v29 + 24))();
        }
      }
      else
      {
        if (v29)
        {
          (*(void (**)(void))(*(void *)v29 + 24))();
          uint64_t v11 = v28;
        }
        uint64_t v29 = v11;
      }
      FxApplyColorConform(&v29, (uint64_t)&kPCNCLC_Rec709, 0, (uint64_t)&kPCNCLC_Rec709Linear, 0, &v28);
      uint64_t v22 = v28;
      if (v29 == v28)
      {
        if (v29) {
          (*(void (**)(void))(*(void *)v29 + 24))();
        }
      }
      else
      {
        if (v29)
        {
          (*(void (**)(void))(*(void *)v29 + 24))();
          uint64_t v22 = v28;
        }
        uint64_t v29 = v22;
      }
      uint64_t v23 = FxColorDescription::getCGColorSpace(a3);
      BOOL v24 = FxColorDescription::isPremultiplied(a3);
      FxApplyColorConform(&v29, v8, 0, v23, v24);
      uint64_t result = v29;
      if (v29) {
        return (*(uint64_t (**)(uint64_t))(*(void *)v29 + 24))(result);
      }
    }
    else if (FxColorDescription::isSDR(this) && FxColorDescription::isHDR(a3))
    {
      CGColorSpaceRef v14 = PCGetNCLCColorSpace((unsigned int *)&kPCNCLC_Rec2020Linear);
      uint64_t v15 = FxColorDescription::getCGColorSpace(this);
      BOOL v16 = FxColorDescription::isPremultiplied(this);
      FxApplyColorConform(a2, v15, v16, v14, 0);
      FxApplyColorConform(&v29, (uint64_t)&kPCNCLC_Rec709Linear, 0, (uint64_t)&kPCNCLC_Rec709, 0, &v28);
      uint64_t v17 = v28;
      if (v29 == v28)
      {
        if (v29) {
          (*(void (**)(void))(*(void *)v29 + 24))();
        }
      }
      else
      {
        if (v29)
        {
          (*(void (**)(void))(*(void *)v29 + 24))();
          uint64_t v17 = v28;
        }
        uint64_t v29 = v17;
      }
      FxApplyColorConform(&v29, (uint64_t)&kPCNCLC_Rec2020HLG, 0, (uint64_t)&kPCNCLC_Rec2020Linear, 0, &v28);
      uint64_t v25 = v28;
      if (v29 == v28)
      {
        if (v29) {
          (*(void (**)(void))(*(void *)v29 + 24))();
        }
      }
      else
      {
        if (v29)
        {
          (*(void (**)(void))(*(void *)v29 + 24))();
          uint64_t v25 = v28;
        }
        uint64_t v29 = v25;
      }
      uint64_t v26 = FxColorDescription::getCGColorSpace(a3);
      BOOL v27 = FxColorDescription::isPremultiplied(a3);
      FxApplyColorConform(&v29, v14, 0, v26, v27);
      uint64_t result = v29;
      if (v29) {
        return (*(uint64_t (**)(uint64_t))(*(void *)v29 + 24))(result);
      }
    }
    else
    {
      uint64_t v18 = FxColorDescription::getCGColorSpace(this);
      BOOL v19 = FxColorDescription::isPremultiplied(this);
      uint64_t v20 = FxColorDescription::getCGColorSpace(a3);
      BOOL v21 = FxColorDescription::isPremultiplied(a3);
      return FxApplyColorConform(a2, v18, v19, v20, v21);
    }
  }
  else
  {
    uint64_t result = *a2;
    *a4 = *a2;
    if (result)
    {
      uint64_t v13 = *(uint64_t (**)(void))(*(void *)result + 16);
      return v13();
    }
  }
  return result;
}

void sub_1B7A7BEE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a9) {
    (*(void (**)(uint64_t))(*(void *)a9 + 24))(a9);
  }
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t LiMultiBlender::addStencil(uint64_t a1, uint64_t a2)
{
  if (*(double *)(a2 + 16) <= 0.0)
  {
    CGColorSpaceRef v8 = *(uint64_t (**)(void))(*(void *)a1 + 48);
    return v8();
  }
  else
  {
    __n128 v4 = (HGStencil *)HGObject::operator new(0x1C0uLL);
    HGStencil::HGStencil(v4);
    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a1 + 24))(&v23, a1);
    conformWithToneMap((FxColorDescription *)(a1 + 56), (uint64_t *)&v23, (FxColorDescription *)(a1 + 104), &v28);
    if (v23) {
      (*(void (**)(void *))(*v23 + 24))(v23);
    }
    if (*(_DWORD *)(a2 + 8) == 25)
    {
      uint64_t v7 = *(void *)a2;
      uint64_t v27 = v7;
      if (v7) {
        (*(void (**)(uint64_t))(*(void *)v7 + 16))(v7);
      }
    }
    else
    {
      conformWithToneMap((FxColorDescription *)(a1 + 56), (uint64_t *)a2, (FxColorDescription *)(a1 + 104), &v27);
    }
    v5.n128_u32[0] = 1.0;
    v6.n128_u64[0] = 0;
    if (*(_DWORD *)(a2 + 8) == 25) {
      v5.n128_f32[0] = 0.0;
    }
    (*(void (**)(HGStencil *, void, __n128, __n128, double, double))(*(void *)v4 + 96))(v4, 0, v5, v6, 0.0, 0.0);
    (*(void (**)(HGStencil *, void, uint64_t))(*(void *)v4 + 120))(v4, 0, v28);
    (*(void (**)(HGStencil *, uint64_t, uint64_t))(*(void *)v4 + 120))(v4, 1, v27);
    (*(void (**)(HGStencil *, uint64_t, float, double, double, double))(*(void *)v4 + 96))(v4, 1, 1.0, 0.0, 0.0, 0.0);
    uint64_t v26 = v4;
    (*(void (**)(HGStencil *))(*(void *)v4 + 16))(v4);
    conformWithToneMap((FxColorDescription *)(a1 + 104), (uint64_t *)&v26, (FxColorDescription *)(a1 + 56), (uint64_t *)&v23);
    __n128 v10 = *(void **)(a1 + 240);
    int32x2_t v11 = (int32x2_t)v23;
    if (v10 == v23)
    {
      if (v10) {
        (*(void (**)(void *))(*v10 + 24))(v10);
      }
    }
    else
    {
      if (v10)
      {
        (*(void (**)(void *))(*v10 + 24))(v10);
        int32x2_t v11 = (int32x2_t)v23;
      }
      *(int32x2_t *)(a1 + 240) = v11;
      uint64_t v23 = 0;
    }
    if (v26) {
      (*(void (**)(HGStencil *))(*(void *)v26 + 24))(v26);
    }
    *(void *)(a1 + 256) = *(void *)(a2 + 16);
    *(_DWORD *)(a1 + 248) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 96) = 1;
    unint64_t DOD = HGRenderer::GetDOD(*(HGRenderer **)(a1 + 24), *(HGNode **)(a1 + 240));
    unint64_t v14 = v13;
    uint64_t v23 = 0;
    if (HGRectIsNull(DOD, v13))
    {
      int v16 = -1;
      int v17 = -1;
    }
    else
    {
      if ((int)DOD <= -1073741823) {
        int v18 = -1073741823;
      }
      else {
        int v18 = DOD;
      }
      unint64_t v19 = HIDWORD(DOD);
      if (SHIDWORD(DOD) <= -1073741823) {
        LODWORD(v19) = -1073741823;
      }
      if ((int)v14 >= 1073741822) {
        int v20 = 1073741822;
      }
      else {
        int v20 = v14;
      }
      unint64_t v21 = HIDWORD(v14);
      if (SHIDWORD(v14) >= 1073741822) {
        LODWORD(v21) = 1073741822;
      }
      uint64_t v23 = (void *)__PAIR64__(v19, v18);
      int v16 = v20 - v18;
      int v17 = v21 - v19;
    }
    int v24 = v16;
    int v25 = v17;
    LiDrawnRegion::clear((LiDrawnRegion *)(a1 + 136), v15);
    LiDrawnRegion::add(a1 + 136, (int32x2_t *)&v23, 1, 1, 0);
    uint64_t v22 = *(void *)(a1 + 88);
    if (v22)
    {
      (*(void (**)(uint64_t))(*(void *)v22 + 24))(v22);
      *(void *)(a1 + 88) = 0;
    }
    if (v27) {
      (*(void (**)(uint64_t))(*(void *)v27 + 24))(v27);
    }
    if (v28) {
      (*(void (**)(uint64_t))(*(void *)v28 + 24))(v28);
    }
    return (*(uint64_t (**)(HGStencil *))(*(void *)v4 + 24))(v4);
  }
}

void sub_1B7A7C4D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 24))(a12);
  }
  if (a13) {
    (*(void (**)(uint64_t))(*(void *)a13 + 24))(a13);
  }
  if (a14) {
    (*(void (**)(uint64_t))(*(void *)a14 + 24))(a14);
  }
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t LiMultiBlender::addLightWrap(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float v6 = *(float *)(a3 + 12);
  if (*(_DWORD *)(a2 + 8) == 35) {
    int v7 = 0;
  }
  else {
    int v7 = *(_DWORD *)(a2 + 8);
  }
  CGColorSpaceRef v8 = (HGHWBlendFlipped *)HGObject::operator new(0x220uLL);
  HGHWBlendFlipped::HGHWBlendFlipped(v8);
  (*(void (**)(HGHWBlendFlipped **__return_ptr, uint64_t))(*(void *)a1 + 24))(&v31, a1);
  conformWithToneMap((FxColorDescription *)(a1 + 56), (uint64_t *)&v31, (FxColorDescription *)(a1 + 104), (uint64_t *)&v28);
  (*(void (**)(HGHWBlendFlipped *, void, void *))(*(void *)v8 + 120))(v8, 0, v28);
  if (v28) {
    (*(void (**)(void *))(*v28 + 24))(v28);
  }
  if (v31) {
    (*(void (**)(HGHWBlendFlipped *))(*(void *)v31 + 24))(v31);
  }
  conformWithToneMap((FxColorDescription *)(a1 + 56), (uint64_t *)a2, (FxColorDescription *)(a1 + 104), (uint64_t *)&v28);
  (*(void (**)(HGHWBlendFlipped *, uint64_t, void *))(*(void *)v8 + 120))(v8, 1, v28);
  if (v28) {
    (*(void (**)(void *))(*v28 + 24))(v28);
  }
  unsigned int v9 = LiHelium::convertMotionBlendMode(v7);
  (*(void (**)(HGHWBlendFlipped *, void, float, double, double, double))(*(void *)v8 + 96))(v8, 0, (float)v9, 0.0, 0.0, 0.0);
  float v10 = *(double *)(a2 + 16);
  (*(void (**)(HGHWBlendFlipped *, uint64_t, float, double, double, double))(*(void *)v8 + 96))(v8, 1, v10, 0.0, 0.0, 0.0);
  float v11 = *(float *)(a3 + 16);
  float v12 = *(float *)(a3 + 20);
  int v13 = LiHelium::convertMotionBlendMode(*(_DWORD *)(a3 + 8));
  HGHWBlendFlipped::SetLightWrapParams((uint64_t)v8, v13, v6, v11, v12, *(float *)(a3 + 24));
  uint64_t v31 = v8;
  (*(void (**)(HGHWBlendFlipped *))(*(void *)v8 + 16))(v8);
  conformWithToneMap((FxColorDescription *)(a1 + 104), (uint64_t *)&v31, (FxColorDescription *)(a1 + 56), (uint64_t *)&v28);
  uint64_t v14 = *(void **)(a1 + 240);
  int32x2_t v15 = (int32x2_t)v28;
  if (v14 == v28)
  {
    if (v14) {
      (*(void (**)(void *))(*v14 + 24))(v14);
    }
  }
  else
  {
    if (v14)
    {
      (*(void (**)(void *))(*v14 + 24))(v14);
      int32x2_t v15 = (int32x2_t)v28;
    }
    *(int32x2_t *)(a1 + 240) = v15;
    uint64_t v28 = 0;
  }
  if (v31) {
    (*(void (**)(HGHWBlendFlipped *))(*(void *)v31 + 24))(v31);
  }
  *(void *)(a1 + 256) = 0x3FF0000000000000;
  *(_DWORD *)(a1 + 248) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 96) = 1;
  unint64_t DOD = HGRenderer::GetDOD(*(HGRenderer **)(a1 + 24), *(HGNode **)(a1 + 240));
  unint64_t v18 = v17;
  uint64_t v28 = 0;
  if (HGRectIsNull(DOD, v17))
  {
    int v20 = -1;
    int v21 = -1;
  }
  else
  {
    if ((int)DOD <= -1073741823) {
      int v22 = -1073741823;
    }
    else {
      int v22 = DOD;
    }
    unint64_t v23 = HIDWORD(DOD);
    if (SHIDWORD(DOD) <= -1073741823) {
      LODWORD(v23) = -1073741823;
    }
    if ((int)v18 >= 1073741822) {
      int v24 = 1073741822;
    }
    else {
      int v24 = v18;
    }
    unint64_t v25 = HIDWORD(v18);
    if (SHIDWORD(v18) >= 1073741822) {
      LODWORD(v25) = 1073741822;
    }
    uint64_t v28 = (void *)__PAIR64__(v23, v22);
    int v20 = v24 - v22;
    int v21 = v25 - v23;
  }
  int v29 = v20;
  int v30 = v21;
  LiDrawnRegion::clear((LiDrawnRegion *)(a1 + 136), v19);
  LiDrawnRegion::add(a1 + 136, (int32x2_t *)&v28, 1, 1, 0);
  uint64_t v26 = *(void *)(a1 + 88);
  if (v26)
  {
    (*(void (**)(uint64_t))(*(void *)v26 + 24))(v26);
    *(void *)(a1 + 88) = 0;
  }
  return (*(uint64_t (**)(HGHWBlendFlipped *))(*(void *)v8 + 24))(v8);
}

void sub_1B7A7CAAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 24))(a12);
  }
  (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
  _Unwind_Resume(a1);
}

uint64_t LiMultiBlender::addPreserveOpacity(uint64_t a1, uint64_t a2)
{
  __n128 v4 = (HGStencil *)HGObject::operator new(0x1C0uLL);
  HGStencil::HGStencil(v4);
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a1 + 24))(&v12, a1);
  conformWithToneMap((FxColorDescription *)(a1 + 56), (uint64_t *)a2, (FxColorDescription *)(a1 + 104), (uint64_t *)&v11);
  (*(void (**)(HGStencil *, void, HGHWMultiBlend *))(*(void *)v4 + 120))(v4, 0, v11);
  if (v11) {
    (*(void (**)(HGHWMultiBlend *))(*(void *)v11 + 24))(v11);
  }
  (*(void (**)(HGStencil *, uint64_t, uint64_t))(*(void *)v4 + 120))(v4, 1, v12);
  (*(void (**)(HGStencil *, void, double, double, double, double))(*(void *)v4 + 96))(v4, 0, 0.0, 0.0, 0.0, 0.0);
  (*(void (**)(HGStencil *, uint64_t, float, double, double, double))(*(void *)v4 + 96))(v4, 1, 1.0, 0.0, 0.0, 0.0);
  LiMultiBlender::makeMultiBlend((LiMultiBlender *)a1, &v11);
  __n128 v5 = *(HGHWMultiBlend **)(a1 + 88);
  float v6 = v11;
  if (v5 == v11)
  {
    if (v5) {
      (*(void (**)(HGHWMultiBlend *))(*(void *)v5 + 24))(v5);
    }
  }
  else
  {
    if (v5) {
      (*(void (**)(HGHWMultiBlend *))(*(void *)v5 + 24))(v5);
    }
    *(void *)(a1 + 88) = v6;
  }
  LiMultiBlender::addToMultiBlender(a1, 0, v12, 9, 0, 1, 1.0);
  uint64_t v7 = LiHelium::convertMotionBlendMode(*(_DWORD *)(a2 + 8));
  float v8 = *(double *)(a2 + 16);
  LiMultiBlender::addToMultiBlender(a1, 1, (uint64_t)v4, v7, 1, 0, v8);
  *(_DWORD *)(a1 + 96) = 2;
  *(_DWORD *)(a1 + 236) = 2;
  LiDrawnRegion::clear((LiDrawnRegion *)(a1 + 160), v9);
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
  }
  return (*(uint64_t (**)(HGStencil *))(*(void *)v4 + 24))(v4);
}

void sub_1B7A7CEF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
  }
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  }
  _Unwind_Resume(exception_object);
}

HGNode *LiMultiBlender::add(uint64_t a1, uint64_t a2)
{
  __n128 v4 = *(HGNode **)a2;
  unint64_t DOD = HGRenderer::GetDOD(*(HGRenderer **)(a1 + 24), *(HGNode **)a2);
  unint64_t v7 = v6;
  unint64_t v26 = 0;
  if (HGRectIsNull(DOD, v6))
  {
    int v8 = -1;
    int v9 = -1;
  }
  else
  {
    if ((int)DOD <= -1073741823) {
      int v10 = -1073741823;
    }
    else {
      int v10 = DOD;
    }
    unint64_t v11 = HIDWORD(DOD);
    if (SHIDWORD(DOD) <= -1073741823) {
      LODWORD(v11) = -1073741823;
    }
    if ((int)v7 >= 1073741822) {
      int v12 = 1073741822;
    }
    else {
      int v12 = v7;
    }
    unint64_t v13 = HIDWORD(v7);
    if (SHIDWORD(v7) >= 1073741822) {
      LODWORD(v13) = 1073741822;
    }
    unint64_t v26 = __PAIR64__(v11, v10);
    int v8 = v12 - v10;
    int v9 = v13 - v11;
  }
  int v27 = v8;
  int v28 = v9;
  char v14 = LiDrawnRegion::add(a1 + 136, (int32x2_t *)&v26, 1, 1, 0);
  int32x2_t v15 = (unsigned int *)(a2 + 8);
  uint64_t v16 = LiHelium::convertMotionBlendMode(*(_DWORD *)(a2 + 8));
  if ((v14 & 1) == 0)
  {
    uint64_t result = (HGNode *)PCBlend::isNothingOverNothing(*v15);
    if (result) {
      return result;
    }
    if (PCBlend::isNormalOverNothing(*v15)) {
      uint64_t v16 = 9;
    }
    else {
      uint64_t v16 = v16;
    }
  }
  if (!*(void *)(a1 + 88)) {
    LiMultiBlender::multify((LiMultiBlender *)a1);
  }
  if (LiDrawnRegion::add(a1 + 184, (int32x2_t *)&v26, 1, 0, *v15)) {
    goto LABEL_24;
  }
  if (LiDrawnRegion::add(a1 + 160, (int32x2_t *)&v26, 0, 1, 0))
  {
    LiDrawnRegion::add(a1 + 184, (int32x2_t *)&v26, 0, 1, *(_DWORD *)(a2 + 8));
LABEL_24:
    int v18 = *(_DWORD *)(a1 + 220);
    if (*(_DWORD *)(a1 + 216) <= v18) {
      int v19 = (2 * (v18 + 1)) | 1;
    }
    else {
      int v19 = *(_DWORD *)(a1 + 216);
    }
    PCArray<LiMultiBlenderLayer,PCArray_Traits<LiMultiBlenderLayer>>::resize(a1 + 208, v18 + 1, v19);
    uint64_t v20 = *(void *)(a1 + 224) + 32 * (*(int *)(a1 + 220) - 1);
    uint64_t v21 = *(void *)v20;
    uint64_t result = *(HGNode **)a2;
    if (*(void *)v20 != *(void *)a2)
    {
      if (v21)
      {
        (*(void (**)(void))(*(void *)v21 + 24))(*(void *)v20);
        uint64_t result = *(HGNode **)a2;
      }
      *(void *)uint64_t v20 = result;
      if (result) {
        uint64_t result = (HGNode *)(*(uint64_t (**)(HGNode *))(*(void *)result + 16))(result);
      }
    }
    __n128 v22 = *(__n128 *)v15;
    *(unsigned char *)(v20 + 24) = *(unsigned char *)(a2 + 24);
    *(__n128 *)(v20 + 8) = v22;
    int v23 = *(_DWORD *)(a1 + 232) + 1;
    *(_DWORD *)(a1 + 232) = v23;
    if (v23 >= 32) {
      return (HGNode *)LiMultiBlender::flushDeferred((_DWORD *)a1, v22);
    }
    return result;
  }
  uint64_t v25 = *(unsigned int *)(a1 + 96);
  if (*(unsigned char *)(a1 + 274)) {
    uint64_t v25 = *(unsigned int *)(a1 + 236);
  }
  float v24 = *(double *)(a2 + 16);
  uint64_t result = (HGNode *)LiMultiBlender::addToMultiBlender(a1, *(unsigned int *)(a1 + 96), (uint64_t)v4, v16, v25, 1, v24);
  ++*(_DWORD *)(a1 + 96);
  *(_DWORD *)(a1 + 232) = 0;
  return result;
}

void LiMultiBlender::multify(LiMultiBlender *this)
{
  uint64_t v2 = (HGNode *)*((void *)this + 30);
  LiMultiBlender::makeMultiBlend(this, (HGHWMultiBlend **)&v23);
  uint64_t v3 = *((void *)this + 11);
  int32x2_t v4 = (int32x2_t)v23;
  if (v3 == v23)
  {
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
    }
  }
  else
  {
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
    }
    *((int32x2_t *)this + 11) = v4;
  }
  *((_DWORD *)this + 59) = 0;
  if (*((double *)this + 32) == 1.0)
  {
    LiMultiBlender::addToMultiBlender((uint64_t)this, 0, *((void *)this + 30), 9, 0, 1, 1.0);
    ++*((_DWORD *)this + 59);
    LiDrawnRegion::clear((LiMultiBlender *)((char *)this + 160), v7);
  }
  else
  {
    __n128 v5 = (HGNode *)HGObject::operator new(0x1A0uLL);
    HGNode::HGNode(v5);
    if (*((unsigned char *)this + 274)) {
      uint64_t v6 = *((unsigned int *)this + 59);
    }
    else {
      uint64_t v6 = 0;
    }
    LiMultiBlender::addToMultiBlender((uint64_t)this, 0, (uint64_t)v5, 9, v6, 1, 1.0);
    int v8 = *((_DWORD *)this + 59);
    *((_DWORD *)this + 59) = v8 + 1;
    uint64_t v9 = *((unsigned int *)this + 24);
    if (*((unsigned char *)this + 274)) {
      uint64_t v11 = (v8 + 1);
    }
    else {
      uint64_t v11 = v9;
    }
    float v10 = *((double *)this + 32);
    LiMultiBlender::addToMultiBlender((uint64_t)this, v9, *((void *)this + 30), 9, v11, 1, v10);
    ++*((_DWORD *)this + 24);
    int v12 = (char *)this + 160;
    LiDrawnRegion::clear((LiMultiBlender *)((char *)this + 160), v13);
    unint64_t DOD = HGRenderer::GetDOD(*((HGRenderer **)this + 3), v2);
    unint64_t v16 = v15;
    unint64_t v23 = 0;
    if (HGRectIsNull(DOD, v15))
    {
      int v17 = -1;
      int v18 = -1;
    }
    else
    {
      if ((int)DOD <= -1073741823) {
        int v19 = -1073741823;
      }
      else {
        int v19 = DOD;
      }
      unint64_t v20 = HIDWORD(DOD);
      if (SHIDWORD(DOD) <= -1073741823) {
        LODWORD(v20) = -1073741823;
      }
      if ((int)v16 >= 1073741822) {
        int v21 = 1073741822;
      }
      else {
        int v21 = v16;
      }
      unint64_t v22 = HIDWORD(v16);
      if (SHIDWORD(v16) >= 1073741822) {
        LODWORD(v22) = 1073741822;
      }
      unint64_t v23 = __PAIR64__(v20, v19);
      int v17 = v21 - v19;
      int v18 = v22 - v20;
    }
    int v24 = v17;
    int v25 = v18;
    LiDrawnRegion::add((uint64_t)v12, (int32x2_t *)&v23, 1, 1, 0);
    if (v5) {
      (*(void (**)(HGNode *))(*(void *)v5 + 24))(v5);
    }
  }
}

void sub_1B7A7D4C4(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t LiMultiBlender::addToMultiBlender(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, float a7)
{
  uint64_t v11 = a3;
  if (a3)
  {
    (*(void (**)(uint64_t))(*(void *)a3 + 16))(a3);
    if (a6 != 1) {
      goto LABEL_14;
    }
    (*(void (**)(uint64_t))(*(void *)v11 + 16))(v11);
  }
  else if (a6 != 1)
  {
    uint64_t v11 = 0;
    goto LABEL_14;
  }
  uint64_t v15 = v11;
  conformWithToneMap((FxColorDescription *)(a1 + 56), &v15, (FxColorDescription *)(a1 + 104), &v16);
  if (v16 == v11)
  {
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
    }
  }
  else
  {
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
    }
    uint64_t v11 = v16;
    uint64_t v16 = 0;
  }
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 24))(v15);
  }
LABEL_14:
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, float))(**(void **)(a1 + 88) + 632))(*(void *)(a1 + 88), a2, v11, a4, a5, a7);
  if (v11) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v11 + 24))(v11);
  }
  return result;
}

void sub_1B7A7D748(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  if (a9) {
    (*(void (**)(uint64_t))(*(void *)a9 + 24))(a9);
  }
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  }
  _Unwind_Resume(exception_object);
}

_DWORD *LiMultiBlender::flushDeferred(_DWORD *this, __n128 a2)
{
  if (this[55])
  {
    uint64_t v2 = (uint64_t)this;
    uint64_t v3 = (uint64_t)(this + 52);
    int32x2_t v4 = (LiDrawnRegion *)(this + 40);
    __n128 v5 = (LiDrawnRegion *)(this + 46);
    do
    {
      ++*(_DWORD *)(v2 + 236);
      LiDrawnRegion::clear(v4, a2);
      int v21 = &unk_1F111A048;
      uint64_t v22 = 0;
      uint64_t v23 = 0;
      int v6 = *(_DWORD *)(v2 + 220);
      if (v6 <= 0) {
        int v7 = 0;
      }
      else {
        int v7 = (2 * v6) | 1;
      }
      PCArray<LiMultiBlenderLayer,PCArray_Traits<LiMultiBlenderLayer>>::resize((uint64_t)&v21, v6, v7);
      if (*(int *)(v2 + 220) >= 1)
      {
        uint64_t v8 = 0;
        uint64_t v9 = 0;
        do
        {
          uint64_t v10 = *(void *)(v2 + 224);
          uint64_t v11 = v23;
          uint64_t v12 = *(void *)(v23 + v8);
          uint64_t v13 = *(void *)(v10 + v8);
          if (v12 != v13)
          {
            if (v12)
            {
              (*(void (**)(void))(*(void *)v12 + 24))(*(void *)(v23 + v8));
              uint64_t v13 = *(void *)(v10 + v8);
            }
            *(void *)(v11 + v8) = v13;
            if (v13) {
              (*(void (**)(uint64_t))(*(void *)v13 + 16))(v13);
            }
          }
          uint64_t v14 = v11 + v8;
          long long v15 = *(_OWORD *)(v10 + v8 + 8);
          *(unsigned char *)(v14 + 24) = *(unsigned char *)(v10 + v8 + 24);
          *(_OWORD *)(v14 + 8) = v15;
          ++v9;
          v8 += 32;
        }
        while (v9 < *(int *)(v2 + 220));
      }
      if (*(int *)(v2 + 216) < 0) {
        int v16 = 1;
      }
      else {
        int v16 = *(_DWORD *)(v2 + 216);
      }
      PCArray<LiMultiBlenderLayer,PCArray_Traits<LiMultiBlenderLayer>>::resize(v3, 0, v16);
      LiDrawnRegion::clear(v5, v17);
      if (SHIDWORD(v22) >= 1)
      {
        uint64_t v18 = 0;
        uint64_t v19 = 0;
        do
        {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v2 + 56))(v2, v23 + v18);
          ++v19;
          v18 += 32;
        }
        while (v19 < SHIDWORD(v22));
      }
      int v21 = &unk_1F111A048;
      if ((int)v22 < 0) {
        int v20 = 1;
      }
      else {
        int v20 = v22;
      }
      PCArray<LiMultiBlenderLayer,PCArray_Traits<LiMultiBlenderLayer>>::resize((uint64_t)&v21, 0, v20);
      this = (_DWORD *)v23;
      if (v23) {
        this = (_DWORD *)MEMORY[0x1BA9BFB70](v23, 0x1000C8077774924);
      }
    }
    while (*(_DWORD *)(v2 + 220));
  }
  return this;
}

void sub_1B7A7DA2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCArray<LiMultiBlenderLayer,PCArray_Traits<LiMultiBlenderLayer>>::~PCArray((uint64_t)va);
  _Unwind_Resume(a1);
}

HGHWMultiBlend *LiMultiBlender::getOutput@<X0>(LiMultiBlender *this@<X0>, uint64_t *a2@<X8>, __n128 a3@<Q0>)
{
  LiMultiBlender::flushDeferred(this, a3);
  __n128 v5 = (HGHWMultiBlend *)*((void *)this + 11);
  if (v5) {
    goto LABEL_19;
  }
  if (*((void *)this + 30) && *((double *)this + 32) < 1.0)
  {
    LiMultiBlender::makeMultiBlend(this, &v16);
    int v6 = (HGHWMultiBlend *)*((void *)this + 11);
    int v7 = v16;
    if (v6 == v16)
    {
      if (v6) {
        (*(void (**)(HGHWMultiBlend *))(*(void *)v6 + 24))(v6);
      }
    }
    else
    {
      if (v6) {
        (*(void (**)(HGHWMultiBlend *))(*(void *)v6 + 24))(v6);
      }
      *((void *)this + 11) = v7;
    }
    *((_DWORD *)this + 59) = 0;
    uint64_t v8 = (HGNode *)HGObject::operator new(0x1A0uLL);
    HGNode::HGNode(v8);
    if (*((unsigned char *)this + 274)) {
      uint64_t v9 = *((unsigned int *)this + 59);
    }
    else {
      uint64_t v9 = 0;
    }
    LiMultiBlender::addToMultiBlender((uint64_t)this, 0, (uint64_t)v8, 9, v9, 1, 1.0);
    int v10 = *((_DWORD *)this + 59);
    *((_DWORD *)this + 59) = v10 + 1;
    uint64_t v11 = *((unsigned int *)this + 24);
    if (*((unsigned char *)this + 274)) {
      uint64_t v13 = (v10 + 1);
    }
    else {
      uint64_t v13 = v11;
    }
    float v12 = *((double *)this + 32);
    LiMultiBlender::addToMultiBlender((uint64_t)this, v11, *((void *)this + 30), 9, v13, 1, v12);
    ++*((_DWORD *)this + 24);
    if (v8) {
      (*(void (**)(HGNode *))(*(void *)v8 + 24))(v8);
    }
  }
  __n128 v5 = (HGHWMultiBlend *)*((void *)this + 11);
  if (v5)
  {
LABEL_19:
    *((unsigned char *)this + 273) = 1;
    int v16 = v5;
    (*(void (**)(HGHWMultiBlend *))(*(void *)v5 + 16))(v5);
    conformWithToneMap((FxColorDescription *)((char *)this + 104), (uint64_t *)&v16, (FxColorDescription *)((char *)this + 56), a2);
    uint64_t result = v16;
    if (v16) {
      return (HGHWMultiBlend *)(*(uint64_t (**)(HGHWMultiBlend *))(*(void *)v16 + 24))(v16);
    }
  }
  else
  {
    uint64_t result = (HGHWMultiBlend *)*((void *)this + 30);
    *a2 = (uint64_t)result;
    if (result)
    {
      long long v15 = *(uint64_t (**)(void))(*(void *)result + 16);
      return (HGHWMultiBlend *)v15();
    }
  }
  return result;
}

void sub_1B7A7DC90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t LiMultiBlender::makeMultiBlend@<X0>(LiMultiBlender *this@<X0>, HGHWMultiBlend **a2@<X8>)
{
  int32x2_t v4 = (HGHWMultiBlend *)HGObject::operator new(0x280uLL);
  HGHWMultiBlend::HGHWMultiBlend(v4);
  *a2 = v4;
  return (*(uint64_t (**)(HGHWMultiBlend *, uint64_t, float, double, double, double))(*(void *)v4 + 96))(v4, 5, *((float *)this + 13), 0.0, 0.0, 0.0);
}

void sub_1B7A7DDD0(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void LiMultiBlender::addPatch()
{
  uint64_t v0 = (LiHeMixShader *)HGObject::operator new(0x1A0uLL);
  *(_OWORD *)uint64_t v0 = 0u;
  *((_OWORD *)v0 + 1) = 0u;
  *((_OWORD *)v0 + 2) = 0u;
  *((_OWORD *)v0 + 3) = 0u;
  *((_OWORD *)v0 + 4) = 0u;
  *((_OWORD *)v0 + 5) = 0u;
  *((_OWORD *)v0 + 6) = 0u;
  *((_OWORD *)v0 + 7) = 0u;
  *((_OWORD *)v0 + 8) = 0u;
  *((_OWORD *)v0 + 9) = 0u;
  *((_OWORD *)v0 + 10) = 0u;
  *((_OWORD *)v0 + 11) = 0u;
  *((_OWORD *)v0 + 12) = 0u;
  *((_OWORD *)v0 + 13) = 0u;
  *((_OWORD *)v0 + 14) = 0u;
  *((_OWORD *)v0 + 15) = 0u;
  *((_OWORD *)v0 + 16) = 0u;
  *((_OWORD *)v0 + 17) = 0u;
  *((_OWORD *)v0 + 18) = 0u;
  *((_OWORD *)v0 + 19) = 0u;
  *((_OWORD *)v0 + 20) = 0u;
  *((_OWORD *)v0 + 21) = 0u;
  *((_OWORD *)v0 + 22) = 0u;
  *((_OWORD *)v0 + 23) = 0u;
  *((_OWORD *)v0 + 24) = 0u;
  *((_OWORD *)v0 + 25) = 0u;
  LiHeMixShader::LiHeMixShader(v0);
}

void sub_1B7A7E100(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 24))(a12);
  }
  (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
  _Unwind_Resume(a1);
}

void LiMultiBlender::newInstance(LiMultiBlender *this)
{
}

void sub_1B7A7E1E4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40EB60DC95);
  _Unwind_Resume(a1);
}

void LiBlender::makeBlender(LiBlender *this, HGRenderer *a2, float a3, const FxColorDescription *a4)
{
}

void sub_1B7A7E270(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10E1C40EB60DC95);
  _Unwind_Resume(a1);
}

CGColorSpace **LiCompositor::getHelium@<X0>(LiCompositor *this@<X0>, LiAgent *a2@<X1>, CGColorSpace **a3@<X8>)
{
  RequestedColorDescription = (const FxColorDescription *)LiAgent::getRequestedColorDescription(a2);
  uint64_t CGColorSpace = (CGColorSpace *)FxColorDescription::getCGColorSpace((FxColorDescription *)(*((void *)a2 + 6) + 160));
  FxColorDescription::FxColorDescription(&v26, RequestedColorDescription, CGColorSpace);
  LiAgent::setActualColorDescription((CGColorSpace **)a2, &v26);
  LiMultiBlender::LiMultiBlender((LiMultiBlender *)v23, *(float *)(*((void *)a2 + 6) + 192), &v26);
  v23[3] = LiAgent::getHeliumRenderer((LiRenderParameters **)a2);
  if (LiAgent::haveROI(a2))
  {
    LiAgent::getROI((__n128 *)a2, v22);
    __n128 v24 = v22[0];
    char v25 = 1;
  }
  LiAgent::LiAgent((LiAgent *)v22, a2);
  LiAgent::setRequestedColorDescription((CGColorSpace **)v22, &v26);
  if (*((void *)this + 5))
  {
    uint64_t v20 = 0;
    PCSharedCount::PCSharedCount(&v21);
    (*(void (**)(void *, char *, void, void, void, uint64_t *, double))(v23[0] + 16))(v23, (char *)this + 40, 0, 0, 0, &v20, 1.0);
    PCSharedCount::~PCSharedCount(&v21);
  }
  else
  {
    uint64_t v11 = (LiImageSource *)*((void *)this + 3);
    if (v11)
    {
      if (*((unsigned char *)this + 48))
      {
        LiAgent::getHelium((LiAgent *)v22, v11, (uint64_t *)&v19);
        uint64_t v17 = 0;
        PCSharedCount::PCSharedCount(&v18);
        (*(void (**)(void *, CGColorSpace **, void, void, void, uint64_t *, double))(v23[0] + 16))(v23, &v19, 0, 0, 0, &v17, 1.0);
        PCSharedCount::~PCSharedCount(&v18);
        if (v19) {
          (*(void (**)(CGColorSpace *))(*(void *)v19 + 24))(v19);
        }
      }
    }
  }
  uint64_t v8 = *((void *)this + 8);
  if (v8) {
    (*(void (**)(uint64_t, void *))(*(void *)v8 + 16))(v8, v23);
  }
  (*(void (**)(void *))(v23[0] + 24))(v23);
  if (!*((void *)this + 5))
  {
    uint64_t v12 = (LiImageSource *)*((void *)this + 3);
    if (v12)
    {
      if (!*((unsigned char *)this + 48))
      {
        LiAgent::getHelium((LiAgent *)v22, v12, &v16);
        blendNodes(&v26, a3, &v16, 0, 0, (uint64_t *)&v19, *(float *)(*((void *)a2 + 6) + 192), 1.0);
        uint64_t v13 = *a3;
        uint64_t v14 = (uint64_t)v19;
        if (*a3 == v19)
        {
          if (v13) {
            (*(void (**)(CGColorSpace *))(*(void *)v13 + 24))(v13);
          }
        }
        else
        {
          if (v13)
          {
            (*(void (**)(CGColorSpace *))(*(void *)v13 + 24))(v13);
            uint64_t v14 = (uint64_t)v19;
          }
          *a3 = (CGColorSpace *)v14;
          uint64_t v19 = 0;
        }
        if (v16) {
          (*(void (**)(uint64_t))(*(void *)v16 + 24))(v16);
        }
      }
    }
  }
  if (!*a3)
  {
    uint64_t v9 = (HGNode *)HGObject::operator new(0x1A0uLL);
    HGNode::HGNode(v9);
    uint64_t v10 = *a3;
    if (*a3 == (CGColorSpace *)v9)
    {
      if (v9) {
        (*(void (**)(HGNode *))(*(void *)v9 + 24))(v9);
      }
    }
    else
    {
      if (v10) {
        (*(void (**)(CGColorSpace *))(*(void *)v10 + 24))(v10);
      }
      *a3 = (CGColorSpace *)v9;
    }
  }
  LiAgent::~LiAgent((LiAgent *)v22);
  LiMultiBlender::~LiMultiBlender((LiMultiBlender *)v23);
  return PCCFRef<CGColorSpace *>::~PCCFRef(&v26._pcColorDesc._colorSpaceRef._obj);
}

void sub_1B7A7E66C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  if (a6) {
    (*(void (**)(uint64_t))(*(void *)a6 + 24))(a6);
  }
  if (a3) {
    (*(void (**)(uint64_t))(*(void *)a3 + 24))(a3);
  }
  if (*v8) {
    (*(void (**)(void))(*(void *)*v8 + 24))(*v8);
  }
  LiAgent::~LiAgent((LiAgent *)va);
  LiMultiBlender::~LiMultiBlender((LiMultiBlender *)&STACK[0x208]);
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(v9 - 80));
  _Unwind_Resume(a1);
}

uint64_t PCArray<LiDrawnRegion::Rect,PCArray_Traits<LiDrawnRegion::Rect>>::~PCArray(uint64_t a1, __n128 a2)
{
  *(void *)a1 = &unk_1F111A010;
  if (*(int *)(a1 + 8) < 0) {
    int v3 = 1;
  }
  else {
    int v3 = *(_DWORD *)(a1 + 8);
  }
  PCArray<LiDrawnRegion::Rect,PCArray_Traits<LiDrawnRegion::Rect>>::resize(a1, 0, v3, a2);
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4) {
    MEMORY[0x1BA9BFB70](v4, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

void PCArray<LiDrawnRegion::Rect,PCArray_Traits<LiDrawnRegion::Rect>>::~PCArray(uint64_t a1, __n128 a2)
{
  *(void *)a1 = &unk_1F111A010;
  if (*(int *)(a1 + 8) < 0) {
    int v3 = 1;
  }
  else {
    int v3 = *(_DWORD *)(a1 + 8);
  }
  PCArray<LiDrawnRegion::Rect,PCArray_Traits<LiDrawnRegion::Rect>>::resize(a1, 0, v3, a2);
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4) {
    MEMORY[0x1BA9BFB70](v4, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

void PCArray<LiDrawnRegion::Rect,PCArray_Traits<LiDrawnRegion::Rect>>::resize(uint64_t a1, int a2, int a3, __n128 a4)
{
  if (a3 <= a2) {
    int v4 = a2;
  }
  else {
    int v4 = a3;
  }
  if (a2 < 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v18, "PCArray::resize");
    PCException::PCException(exception, &v18);
    *(void *)exception = &unk_1F1199218;
  }
  if (v4 == *(_DWORD *)(a1 + 8))
  {
    uint64_t v7 = *(int *)(a1 + 12);
    if (a2 > (int)v7)
    {
      uint64_t v8 = 20 * v7;
      int v9 = a2 - v7;
      do
      {
        LiDrawnRegion::Rect::Rect((LiDrawnRegion::Rect *)(*(void *)(a1 + 16) + v8));
        v8 += 20;
        --v9;
      }
      while (v9);
    }
  }
  else
  {
    if (v4) {
      operator new[]();
    }
    int v10 = *(_DWORD *)(a1 + 12);
    if (a2 >= v10) {
      int v11 = *(_DWORD *)(a1 + 12);
    }
    else {
      int v11 = a2;
    }
    if (v11 < 1)
    {
      int v11 = 0;
    }
    else
    {
      uint64_t v12 = 0;
      do
      {
        a4 = LiDrawnRegion::Rect::Rect(v12, (LiDrawnRegion::Rect *)((char *)v12 + *(void *)(a1 + 16)));
        uint64_t v12 = (LiDrawnRegion::Rect *)((char *)v12 + 20);
      }
      while ((LiDrawnRegion::Rect *)(20 * v11) != v12);
      int v10 = *(_DWORD *)(a1 + 12);
    }
    if (v11 > v10) {
      int v10 = v11;
    }
    if (v10 < a2)
    {
      uint64_t v13 = (LiDrawnRegion::Rect *)(20 * v10);
      unint64_t v14 = a2 - (unint64_t)v10;
      do
      {
        a4.n128_f64[0] = LiDrawnRegion::Rect::Rect(v13);
        uint64_t v13 = (LiDrawnRegion::Rect *)(v15 + 20);
        --v14;
      }
      while (v14);
    }
    uint64_t v16 = *(void *)(a1 + 16);
    if (v16) {
      MEMORY[0x1BA9BFB70](v16, 0x1000C8077774924, a4);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v4;
  *(_DWORD *)(a1 + 12) = a2;
}

void sub_1B7A7EAEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void PCPtr<LiImageSource>::reset(void *a1)
{
  PCSharedCount::PCSharedCount(&v3);
  *a1 = 0;
  PCSharedCount::operator=(v2, a1 + 1);
  PCSharedCount::~PCSharedCount(&v3);
}

void sub_1B7A7EB7C(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1);
  _Unwind_Resume(a1);
}

void PCArray<LiMultiBlenderLayer,PCArray_Traits<LiMultiBlenderLayer>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111A048;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<LiMultiBlenderLayer,PCArray_Traits<LiMultiBlenderLayer>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t PCArray<LiMultiBlenderLayer,PCArray_Traits<LiMultiBlenderLayer>>::resize(uint64_t result, int a2, int a3)
{
  if (a3 <= a2) {
    int v3 = a2;
  }
  else {
    int v3 = a3;
  }
  if (a2 < 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v24, "PCArray::resize");
    PCException::PCException(exception, &v24);
    *(void *)exception = &unk_1F1199218;
  }
  uint64_t v5 = result;
  if (v3 == *(_DWORD *)(result + 8))
  {
    int v6 = *(_DWORD *)(result + 12);
    if (v6 <= a2)
    {
      if (v6 < a2)
      {
        uint64_t v9 = v6;
        uint64_t v10 = *(void *)(result + 16) + 32 * v6 + 16;
        uint64_t v11 = a2 - v9;
        do
        {
          *(void *)(v10 - 16) = 0;
          *(_DWORD *)(v10 - 8) = 0;
          *(void *)uint64_t v10 = 0x3FF0000000000000;
          *(unsigned char *)(v10 + 8) = 0;
          v10 += 32;
          --v11;
        }
        while (v11);
      }
    }
    else
    {
      uint64_t v7 = 32 * a2;
      uint64_t v8 = a2;
      do
      {
        uint64_t result = *(void *)(*(void *)(v5 + 16) + v7);
        if (result)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
          int v6 = *(_DWORD *)(v5 + 12);
        }
        ++v8;
        v7 += 32;
      }
      while (v8 < v6);
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    int v12 = *(_DWORD *)(result + 12);
    if (a2 >= v12) {
      int v13 = *(_DWORD *)(result + 12);
    }
    else {
      int v13 = a2;
    }
    if (v13 < 1)
    {
      int v13 = 0;
    }
    else
    {
      uint64_t v14 = 0;
      do
      {
        uint64_t v15 = *(void *)(v5 + 16);
        uint64_t v16 = *(void *)(v15 + v14);
        *(void *)uint64_t v14 = v16;
        if (v16)
        {
          (*(void (**)(uint64_t))(*(void *)v16 + 16))(v16);
          uint64_t v17 = *(void *)(*(void *)(v5 + 16) + v14);
          char v18 = *(unsigned char *)(v15 + v14 + 24);
          *(_OWORD *)(v14 + 8) = *(_OWORD *)(v15 + v14 + 8);
          *(unsigned char *)(v14 + 24) = v18;
          if (v17) {
            (*(void (**)(uint64_t))(*(void *)v17 + 24))(v17);
          }
        }
        else
        {
          long long v19 = *(_OWORD *)(v15 + v14 + 8);
          *(unsigned char *)(v14 + 24) = *(unsigned char *)(v15 + v14 + 24);
          *(_OWORD *)(v14 + 8) = v19;
        }
        v14 += 32;
      }
      while (32 * v13 != v14);
      int v12 = *(_DWORD *)(v5 + 12);
    }
    if (v13 < v12)
    {
      uint64_t v20 = 32 * v13;
      do
      {
        uint64_t v21 = *(void *)(*(void *)(v5 + 16) + v20);
        if (v21)
        {
          (*(void (**)(uint64_t))(*(void *)v21 + 24))(v21);
          int v12 = *(_DWORD *)(v5 + 12);
        }
        v20 += 32;
        ++v13;
      }
      while (v12 > v13);
    }
    if (v13 < a2)
    {
      uint64_t v22 = 32 * v13 + 16;
      do
      {
        *(void *)(v22 - 16) = 0;
        *(_DWORD *)(v22 - 8) = 0;
        *(void *)uint64_t v22 = 0x3FF0000000000000;
        *(unsigned char *)(v22 + 8) = 0;
        v22 += 32;
        ++v13;
      }
      while (v13 < a2);
    }
    uint64_t result = *(void *)(v5 + 16);
    if (result) {
      uint64_t result = MEMORY[0x1BA9BFB70](result, 0x1000C8077774924);
    }
    *(void *)(v5 + 16) = 0;
  }
  *(_DWORD *)(v5 + 8) = v3;
  *(_DWORD *)(v5 + 12) = a2;
  return result;
}

void sub_1B7A7EF3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void LiDepthSorter::stackSort(uint64_t a1)
{
  size_t v1 = *(unsigned int *)(a1 + 12);
  if (v1) {
    qsort(*(void **)(a1 + 16), v1, 8uLL, (int (__cdecl *)(const void *, const void *))stackOrder);
  }
}

uint64_t stackOrder(LiDrawer **a1, LiDrawer **a2)
{
  uint64_t result = LiDrawer::hasCompositeOrder(*a1);
  if (result)
  {
    uint64_t result = LiDrawer::hasCompositeOrder(*a2);
    if (result)
    {
      int v5 = LiDrawer::compositeOrder(*a1);
      int v6 = LiDrawer::compositeOrder(*a2);
      unsigned int v7 = v5 >= v6 ? 0 : -1;
      uint64_t result = v5 > v6 ? 1 : v7;
      if (!result)
      {
        int v8 = LiDrawer::compositeOrder2(*a1);
        int v9 = LiDrawer::compositeOrder2(*a2);
        unsigned int v10 = v8 >= v9 ? 0 : -1;
        uint64_t result = v8 > v9 ? 1 : v10;
        if (!result)
        {
          int v11 = LiDrawer::compositeOrder3(*a1);
          int v12 = LiDrawer::compositeOrder3(*a2);
          unsigned int v13 = v11 >= v12 ? 0 : -1;
          uint64_t result = v11 > v12 ? 1 : v13;
          if (!result)
          {
            int v14 = *((_DWORD *)*a1 + 3);
            int v15 = *((_DWORD *)*a2 + 3);
            BOOL v16 = v14 <= v15;
            if (v14 >= v15) {
              unsigned int v17 = 0;
            }
            else {
              unsigned int v17 = -1;
            }
            if (v16) {
              return v17;
            }
            else {
              return 1;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t PCPtrArray<LiDrawer>::~PCPtrArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111A0D0;
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2 < 0) {
    int v3 = 1;
  }
  else {
    int v3 = v2 & ~(v2 >> 31);
  }
  if (v3 == v2)
  {
    uint64_t v4 = *(int *)(a1 + 12);
    if ((v4 & 0x80000000) != 0)
    {
      do
        *(void *)(*(void *)(a1 + 16) + 8 * v4) = 0;
      while (!__CFADD__(v4++, 1));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6) {
      MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = 0;
  uint64_t v7 = *(void *)(a1 + 16);
  if (v7) {
    MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

void LiDepthSorter::LiDepthSorter(LiDepthSorter *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_1F111A080;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 3) = &unk_1F111A080;
  *((unsigned char *)this + 48) = 0;
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
}

void LiDepthSorter::~LiDepthSorter(LiDepthSorter *this)
{
  *((void *)this + 3) = &unk_1F111A0D0;
  int v2 = *((_DWORD *)this + 8);
  if (v2 < 0) {
    int v3 = 1;
  }
  else {
    int v3 = v2 & ~(v2 >> 31);
  }
  if (v3 == v2)
  {
    uint64_t v4 = *((int *)this + 9);
    if ((v4 & 0x80000000) != 0)
    {
      do
      {
        *(void *)(*((void *)this + 5) + 8 * v4) = 0;
        BOOL v5 = __CFADD__(v4++, 1);
      }
      while (!v5);
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    uint64_t v6 = *((void *)this + 5);
    if (v6) {
      MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
    }
    *((void *)this + 5) = 0;
  }
  *((_DWORD *)this + 8) = v3;
  *((_DWORD *)this + 9) = 0;
  uint64_t v7 = *((void *)this + 5);
  if (v7) {
    MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
  }
  *((void *)this + 5) = 0;
  *((_DWORD *)this + 8) = 0;
  *(void *)this = &unk_1F111A0D0;
  int v8 = *((_DWORD *)this + 2);
  if (v8 < 0) {
    int v9 = 1;
  }
  else {
    int v9 = v8 & ~(v8 >> 31);
  }
  if (v9 == v8)
  {
    uint64_t v10 = *((int *)this + 3);
    if ((v10 & 0x80000000) != 0)
    {
      do
      {
        *(void *)(*((void *)this + 2) + 8 * v10) = 0;
        BOOL v5 = __CFADD__(v10++, 1);
      }
      while (!v5);
    }
  }
  else
  {
    if (v9) {
      operator new[]();
    }
    uint64_t v11 = *((void *)this + 2);
    if (v11) {
      MEMORY[0x1BA9BFB70](v11, 0x1000C8077774924);
    }
    *((void *)this + 2) = 0;
  }
  *((_DWORD *)this + 2) = v9;
  *((_DWORD *)this + 3) = 0;
  uint64_t v12 = *((void *)this + 2);
  if (v12) {
    MEMORY[0x1BA9BFB70](v12, 0x1000C8077774924);
  }
  *((void *)this + 2) = 0;
  *((_DWORD *)this + 2) = 0;
}

void LiDepthSorter::sort(LiDepthSorter *this)
{
  uint64_t v1 = *((unsigned int *)this + 3);
  if (v1)
  {
    LiPlaneSplit::LiPlaneSplit((LiPlaneSplit *)v58);
    unsigned int v3 = 0;
    char v59 = *((unsigned char *)this + 48);
    v58[0] = *((void *)this + 7);
    if ((int)v1 >= 0) {
      int v4 = v1;
    }
    else {
      int v4 = v1 + 1;
    }
    LODWORD(i) = v4 >> 1;
LABEL_6:
    uint64_t v6 = (PCArray_base *)LiPlaneSplit::clear((uint64_t)v58);
    if ((i & 0x80000000) != 0 || *((_DWORD *)this + 3) <= (int)i) {
      PCArray_base::badIndex(v6);
    }
    uint64_t v7 = *(void *)(*((void *)this + 2) + 8 * (int)i);
    v58[1] = v7;
    int v8 = (PCArray_base *)(*(void *(**)(void **__return_ptr, uint64_t))(*(void *)v7 + 48))(&v48, v7);
    BOOL v60 = v51 > 0.0;
    if ((int)v1 >= 1)
    {
      uint64_t v9 = i;
      for (uint64_t i = 0; v1 != i; ++i)
      {
        if (v9 != i)
        {
          if (i >= *((int *)this + 3)) {
            PCArray_base::badIndex(v8);
          }
          v58[2] = *(void *)(*((void *)this + 2) + 8 * i);
          LiPlaneSplit::compute((LiPlaneSplit *)v58);
          if (v61 == 3 && !v62 && v3 < 0xA)
          {
            ++v3;
            goto LABEL_6;
          }
          int v8 = (PCArray_base *)LiPlaneSplit::store((LiPlaneSplit *)v58, v10, v11, v12, v13, v14, v15, v16);
        }
      }
    }
    uint64_t v47 = v7;
    if (*((int *)this + 16) <= 299)
    {
      char v17 = 1;
      do
      {
        char v18 = v17;
        if (v17) {
          uint64_t v19 = 364;
        }
        else {
          uint64_t v19 = 340;
        }
        int v20 = *(_DWORD *)((char *)v58 + v19);
        if (v20 >= 2)
        {
          PCSharedCount v48 = &unk_1F111A080;
          uint64_t v53 = 0;
          uint64_t v54 = 0;
          uint64_t v56 = *((void *)this + 7);
          int v21 = *((_DWORD *)this + 16);
          int v57 = v21 + 1;
          if (*((unsigned char *)this + 48)) {
            BOOL v22 = v21 < 5;
          }
          else {
            BOOL v22 = 0;
          }
          char v23 = v22;
          if (v18) {
            uint64_t v24 = 45;
          }
          else {
            uint64_t v24 = 42;
          }
          int v25 = v58[v24];
          char v55 = v23;
          int v49 = v25;
          int v50 = v20;
          if (v18) {
            uint64_t v26 = 46;
          }
          else {
            uint64_t v26 = 43;
          }
          int v27 = &v66;
          if ((v18 & 1) == 0) {
            int v27 = &v63;
          }
          double v51 = *(double *)&v58[v26];
          uint64_t v52 = &unk_1F111A080;
          *int v27 = 0;
          v27[1] = 0;
          LiDepthSorter::sort((LiDepthSorter *)&v48);
          int v28 = v58[v24];
          if (v28 < 0) {
            int v29 = 1;
          }
          else {
            int v29 = v28 & ~(v28 >> 31);
          }
          if (v29 == v28)
          {
            uint64_t v30 = *(int *)((char *)v58 + v19);
            if ((v30 & 0x80000000) != 0)
            {
              do
              {
                *(void *)(v58[v26] + 8 * v30) = 0;
                BOOL v31 = __CFADD__(v30++, 1);
              }
              while (!v31);
            }
            uint64_t v32 = v58[v26];
          }
          else
          {
            if (v29) {
              operator new[]();
            }
            uint64_t v32 = 0;
            uint64_t v33 = v58[v26];
            if (v33) {
              MEMORY[0x1BA9BFB70](v33, 0x1000C8077774924);
            }
            v58[v26] = 0;
          }
          LODWORD(v58[v24]) = v29;
          *(_DWORD *)((char *)v58 + v19) = 0;
          if (v32) {
            MEMORY[0x1BA9BFB70](v32, 0x1000C8077774924);
          }
          int v34 = HIDWORD(v53);
          LODWORD(v58[v24]) = v53;
          *(_DWORD *)((char *)v58 + v19) = v34;
          v58[v26] = v54;
          uint64_t v53 = 0;
          uint64_t v54 = 0;
          LiDepthSorter::~LiDepthSorter((LiDepthSorter *)&v48);
        }
        char v17 = 0;
      }
      while ((v18 & 1) != 0);
    }
    int v35 = *((_DWORD *)this + 8);
    if (v35 < 0) {
      int v36 = 1;
    }
    else {
      int v36 = v35 & ~(v35 >> 31);
    }
    if (v36 == v35)
    {
      uint64_t v37 = *((int *)this + 9);
      uint64_t v38 = v47;
      if ((v37 & 0x80000000) != 0)
      {
        do
        {
          *(void *)(*((void *)this + 5) + 8 * v37) = 0;
          BOOL v31 = __CFADD__(v37++, 1);
        }
        while (!v31);
      }
    }
    else
    {
      uint64_t v38 = v47;
      if (v36) {
        operator new[]();
      }
      uint64_t v39 = *((void *)this + 5);
      if (v39) {
        MEMORY[0x1BA9BFB70](v39, 0x1000C8077774924);
      }
      *((void *)this + 5) = 0;
    }
    uint64_t v40 = (char *)this + 24;
    *((_DWORD *)this + 8) = v36;
    *((_DWORD *)this + 9) = 0;
    uint64_t v41 = *((void *)this + 5);
    if (v41) {
      MEMORY[0x1BA9BFB70](v41, 0x1000C8077774924);
    }
    int v42 = v63;
    int v43 = HIDWORD(v63);
    *((_DWORD *)this + 8) = v63;
    *((_DWORD *)this + 9) = v43;
    *((void *)this + 5) = v64;
    uint64_t v63 = 0;
    uint64_t v64 = 0;
    if (__nel[0])
    {
      if (v68 <= __nel[0]) {
        int v44 = (2 * (__nel[0] + 1)) | 1;
      }
      else {
        int v44 = v68;
      }
      PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::resize((uint64_t)&v67, __nel[0] + 1, v44);
      size_t v45 = __nel[0];
      *(void *)(*(void *)&__nel[1] + 8 * (__nel[0] - 1)) = v38;
      if (v45) {
        qsort(*(void **)&__nel[1], v45, 8uLL, (int (__cdecl *)(const void *, const void *))stackOrder);
      }
      PCArray<LiDrawer *,PCArray_Traits_Zero<LiDrawer *>>::append((uint64_t)v40, (uint64_t)&v67);
    }
    else
    {
      if (v42 <= v43) {
        int v46 = (2 * (v43 + 1)) | 1;
      }
      else {
        int v46 = v42;
      }
      PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::resize((uint64_t)this + 24, v43 + 1, v46);
      *(void *)(*((void *)this + 5) + 8 * *((int *)this + 9) - 8) = v38;
    }
    PCArray<LiDrawer *,PCArray_Traits_Zero<LiDrawer *>>::append((uint64_t)v40, (uint64_t)&v65);
    LiPlaneSplit::~LiPlaneSplit((LiPlaneSplit *)v58);
  }
}

void sub_1B7A7F844(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  LiPlaneSplit::~LiPlaneSplit((LiPlaneSplit *)va);
  _Unwind_Resume(a1);
}

uint64_t PCArray<LiDrawer *,PCArray_Traits_Zero<LiDrawer *>>::append(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(int *)(a1 + 12);
  int v5 = *(_DWORD *)(a2 + 12) + v4;
  if (*(_DWORD *)(a1 + 8) >= v5) {
    int v6 = *(_DWORD *)(a1 + 8);
  }
  else {
    int v6 = (2 * v5) | 1;
  }
  uint64_t result = PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::resize(a1, v5, v6);
  uint64_t v8 = *(unsigned int *)(a2 + 12);
  if ((int)v8 >= 1)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 8 * v8;
    do
    {
      *(void *)(*(void *)(a1 + 16) + 8 * v4 + v9) = *(void *)(*(void *)(a2 + 16) + v9);
      v9 += 8;
    }
    while (v10 != v9);
  }
  return result;
}

void PCPtrArray<LiDrawer>::~PCPtrArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111A0D0;
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2 < 0) {
    int v3 = 1;
  }
  else {
    int v3 = v2 & ~(v2 >> 31);
  }
  if (v3 == v2)
  {
    uint64_t v4 = *(int *)(a1 + 12);
    if ((v4 & 0x80000000) != 0)
    {
      do
        *(void *)(*(void *)(a1 + 16) + 8 * v4) = 0;
      while (!__CFADD__(v4++, 1));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6) {
      MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = 0;
  uint64_t v7 = *(void *)(a1 + 16);
  if (v7) {
    MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

void LiPlaneSplit::~LiPlaneSplit(LiPlaneSplit *this)
{
  *((void *)this + 47) = &unk_1F111A0D0;
  int v2 = *((_DWORD *)this + 96);
  if (v2 < 0) {
    int v3 = 1;
  }
  else {
    int v3 = v2 & ~(v2 >> 31);
  }
  if (v3 == v2)
  {
    uint64_t v4 = *((int *)this + 97);
    if ((v4 & 0x80000000) != 0)
    {
      do
      {
        *(void *)(*((void *)this + 49) + 8 * v4) = 0;
        BOOL v5 = __CFADD__(v4++, 1);
      }
      while (!v5);
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    uint64_t v6 = *((void *)this + 49);
    if (v6) {
      MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
    }
    *((void *)this + 49) = 0;
  }
  *((_DWORD *)this + 96) = v3;
  *((_DWORD *)this + 97) = 0;
  uint64_t v7 = *((void *)this + 49);
  if (v7) {
    MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
  }
  *((void *)this + 49) = 0;
  *((_DWORD *)this + 96) = 0;
  *((void *)this + 44) = &unk_1F111A0D0;
  int v8 = *((_DWORD *)this + 90);
  if (v8 < 0) {
    int v9 = 1;
  }
  else {
    int v9 = v8 & ~(v8 >> 31);
  }
  if (v9 == v8)
  {
    uint64_t v10 = *((int *)this + 91);
    if ((v10 & 0x80000000) != 0)
    {
      do
      {
        *(void *)(*((void *)this + 46) + 8 * v10) = 0;
        BOOL v5 = __CFADD__(v10++, 1);
      }
      while (!v5);
    }
  }
  else
  {
    if (v9) {
      operator new[]();
    }
    uint64_t v11 = *((void *)this + 46);
    if (v11) {
      MEMORY[0x1BA9BFB70](v11, 0x1000C8077774924);
    }
    *((void *)this + 46) = 0;
  }
  *((_DWORD *)this + 90) = v9;
  *((_DWORD *)this + 91) = 0;
  uint64_t v12 = *((void *)this + 46);
  if (v12) {
    MEMORY[0x1BA9BFB70](v12, 0x1000C8077774924);
  }
  *((void *)this + 46) = 0;
  *((_DWORD *)this + 90) = 0;
  *((void *)this + 41) = &unk_1F111A0D0;
  int v13 = *((_DWORD *)this + 84);
  if (v13 < 0) {
    int v14 = 1;
  }
  else {
    int v14 = v13 & ~(v13 >> 31);
  }
  if (v14 == v13)
  {
    uint64_t v15 = *((int *)this + 85);
    if ((v15 & 0x80000000) != 0)
    {
      do
      {
        *(void *)(*((void *)this + 43) + 8 * v15) = 0;
        BOOL v5 = __CFADD__(v15++, 1);
      }
      while (!v5);
    }
  }
  else
  {
    if (v14) {
      operator new[]();
    }
    uint64_t v16 = *((void *)this + 43);
    if (v16) {
      MEMORY[0x1BA9BFB70](v16, 0x1000C8077774924);
    }
    *((void *)this + 43) = 0;
  }
  *((_DWORD *)this + 84) = v14;
  *((_DWORD *)this + 85) = 0;
  uint64_t v17 = *((void *)this + 43);
  if (v17) {
    MEMORY[0x1BA9BFB70](v17, 0x1000C8077774924);
  }
  *((void *)this + 43) = 0;
  *((_DWORD *)this + 84) = 0;
  for (uint64_t i = 312; i != 88; i -= 112)
  {
    uint64_t v19 = *(void **)((char *)this + i - 8);
    if (v19)
    {
      *(void *)((char *)this + i) = v19;
      operator delete(v19);
    }
    int v20 = *(void **)((char *)this + i - 32);
    if (v20)
    {
      *(void *)((char *)this + i - 24) = v20;
      operator delete(v20);
    }
    int v21 = (char *)this + i;
    BOOL v22 = *(void **)((char *)this + i - 56);
    if (v22)
    {
      *((void *)v21 - 6) = v22;
      operator delete(v22);
    }
    char v23 = (void *)*((void *)v21 - 10);
    if (v23)
    {
      *(void *)((char *)this + i - 72) = v23;
      operator delete(v23);
    }
  }
}

void LiDrawer::LiDrawer(LiDrawer *this)
{
  *(void *)this = &unk_1F111A0F0;
  *((unsigned char *)this + 8) = 1;
  *((_DWORD *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = &unk_1F111A298;
}

void LiDrawer::~LiDrawer(LiDrawer *this)
{
  *(void *)this = &unk_1F111A0F0;
  *((void *)this + 3) = &unk_1F111A2E8;
  int v2 = *((_DWORD *)this + 8);
  if (v2 < 0) {
    int v3 = 1;
  }
  else {
    int v3 = v2 & ~(v2 >> 31);
  }
  if (v3 == v2)
  {
    uint64_t v4 = *((int *)this + 9);
    if ((v4 & 0x80000000) != 0)
    {
      do
        *(void *)(*((void *)this + 5) + 8 * v4) = 0;
      while (!__CFADD__(v4++, 1));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    uint64_t v6 = *((void *)this + 5);
    if (v6) {
      MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
    }
    *((void *)this + 5) = 0;
  }
  *((_DWORD *)this + 8) = v3;
  *((_DWORD *)this + 9) = 0;
  uint64_t v7 = *((void *)this + 5);
  if (v7) {
    MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
  }
  *((void *)this + 5) = 0;
  *((_DWORD *)this + 8) = 0;
}

uint64_t PCPtrArray<LiSeam>::~PCPtrArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111A2E8;
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2 < 0) {
    int v3 = 1;
  }
  else {
    int v3 = v2 & ~(v2 >> 31);
  }
  if (v3 == v2)
  {
    uint64_t v4 = *(int *)(a1 + 12);
    if ((v4 & 0x80000000) != 0)
    {
      do
        *(void *)(*(void *)(a1 + 16) + 8 * v4) = 0;
      while (!__CFADD__(v4++, 1));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6) {
      MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = 0;
  uint64_t v7 = *(void *)(a1 + 16);
  if (v7) {
    MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

void LiDrawer::holdOut()
{
}

void sub_1B7A80028(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C402E1910D9);
  _Unwind_Resume(a1);
}

void LiDrawer::dump(LiDrawer *this, const char **a2)
{
  if (*a2) {
    int v3 = *a2;
  }
  else {
    int v3 = "";
  }
  size_t v4 = strlen(v3);
  BOOL v5 = (void *)MEMORY[0x1E4FBA240];
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)v3, v4);
  (*(void (**)(const char **__return_ptr, LiDrawer *))(*(void *)this + 88))(&v9, this);
  if (v9) {
    uint64_t v6 = v9;
  }
  else {
    uint64_t v6 = "";
  }
  size_t v7 = strlen(v6);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)v6, v7);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"\n", 1);
  if (v9 && atomic_fetch_add((atomic_uint *volatile)v9 - 3, 0xFFFFFFFF) == 1)
  {
    const char *v9 = 0;
    if (v9) {
      int v8 = (char *)(v9 - 12);
    }
    else {
      int v8 = 0;
    }
    free(v8);
  }
}

void sub_1B7A80150(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    ProShade::VertexProgram::VertexProgram(a10);
  }
  _Unwind_Resume(exception_object);
}

BOOL LiDrawer::hasCompositeOrder(LiDrawer *this)
{
  return (*(uint64_t (**)(LiDrawer *))(*(void *)this + 72))(this) != 0;
}

uint64_t LiDrawer::compositeOrder(LiDrawer *this)
{
  uint64_t result = (*(uint64_t (**)(LiDrawer *))(*(void *)this + 72))(this);
  if (result)
  {
    unsigned int v3 = *(_DWORD *)(result + 528);
    if (*((unsigned char *)this + 8)) {
      return v3;
    }
    else {
      return v3 ^ 0x7FFFFFFF;
    }
  }
  return result;
}

uint64_t LiDrawer::compositeOrder2(LiDrawer *this)
{
  uint64_t result = (*(uint64_t (**)(LiDrawer *))(*(void *)this + 72))(this);
  if (result)
  {
    uint64_t v3 = result;
    uint64_t result = *(unsigned int *)(result + 532);
    if (*(unsigned char *)(v3 + 540))
    {
      if (*((unsigned char *)this + 8)) {
        return result;
      }
      else {
        return result ^ 0x7FFFFFFF;
      }
    }
  }
  return result;
}

uint64_t LiDrawer::compositeOrder3(LiDrawer *this)
{
  uint64_t result = (*(uint64_t (**)(LiDrawer *))(*(void *)this + 72))(this);
  if (result)
  {
    unsigned int v3 = *(_DWORD *)(result + 536);
    if (*((unsigned char *)this + 8)) {
      return v3;
    }
    else {
      return v3 ^ 0x7FFFFFFF;
    }
  }
  return result;
}

double LiDrawer::getPlane@<D0>(LiDrawer *this@<X0>, _OWORD *a2@<X8>)
{
  if ((*(unsigned int (**)(LiDrawer *))(*(void *)this + 40))(this))
  {
    size_t v4 = *(void (**)(void))(*(void *)(*(uint64_t (**)(LiDrawer *))(*(void *)this + 32))(this) + 24);
    v4();
  }
  else
  {
    double result = 0.0;
    *a2 = 0u;
    a2[1] = 0u;
  }
  return result;
}

void *LiDrawer::getBox@<X0>(LiDrawer *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (*(uint64_t (**)(LiDrawer *))(*(void *)this + 32))(this);
  double result = (*(void *(**)(double *__return_ptr, LiDrawer *))(*(void *)this + 48))(&v28, this);
  uint64_t v6 = *(uint64_t **)(v4 + 88);
  uint64_t v7 = *v6;
  unint64_t v8 = v6[1] - *v6;
  *(_OWORD *)(a2 + 16) = xmmword_1B7E736F0;
  *(_OWORD *)(a2 + 32) = xmmword_1B7E736F0;
  *(_OWORD *)a2 = xmmword_1B7E736F0;
  if ((int)(v8 >> 5) >= 1)
  {
    uint64_t v9 = (v8 >> 5);
    uint64_t v10 = (double *)(v7 + 8);
    double v11 = -1.0;
    double v12 = 1.0;
    double v13 = 1.0;
    double v14 = -1.0;
    double v15 = 1.0;
    double v16 = -1.0;
    do
    {
      double v17 = *(v10 - 1);
      double v18 = *v10;
      double v19 = -(v30 + v17 * v28 + *v10 * v29);
      if (v12 >= v17) {
        double v20 = *(v10 - 1);
      }
      else {
        double v20 = v12;
      }
      if (v11 <= v17) {
        double v21 = *(v10 - 1);
      }
      else {
        double v21 = v11;
      }
      if (v13 >= v18) {
        double v22 = *v10;
      }
      else {
        double v22 = v13;
      }
      if (v14 <= v18) {
        double v23 = *v10;
      }
      else {
        double v23 = v14;
      }
      if (v15 >= v19) {
        double v24 = -(v30 + v17 * v28 + *v10 * v29);
      }
      else {
        double v24 = v15;
      }
      if (v16 <= v19) {
        double v25 = -(v30 + v17 * v28 + *v10 * v29);
      }
      else {
        double v25 = v16;
      }
      BOOL v27 = v12 <= v11 && v13 <= v14 && v15 <= v16;
      if (v27) {
        double v11 = v21;
      }
      else {
        double v11 = *(v10 - 1);
      }
      if (v27) {
        double v12 = v20;
      }
      else {
        double v12 = *(v10 - 1);
      }
      if (v27) {
        double v14 = v23;
      }
      else {
        double v14 = *v10;
      }
      if (v27) {
        double v13 = v22;
      }
      else {
        double v13 = *v10;
      }
      if (v27) {
        double v16 = v25;
      }
      else {
        double v16 = -(v30 + v17 * v28 + *v10 * v29);
      }
      if (v27) {
        double v15 = v24;
      }
      else {
        double v15 = -(v30 + v17 * v28 + *v10 * v29);
      }
      v10 += 4;
      --v9;
    }
    while (v9);
    *(double *)a2 = v12;
    *(double *)(a2 + 8) = v11;
    *(double *)(a2 + 16) = v13;
    *(double *)(a2 + 24) = v14;
    *(double *)(a2 + 32) = v15;
    *(double *)(a2 + 40) = v16;
  }
  return result;
}

uint64_t LiDrawer::farAway(LiDrawer *this)
{
  uint64_t result = (*(uint64_t (**)(LiDrawer *))(*(void *)this + 72))(this);
  if (result) {
    return *(unsigned char *)(result + 541) != 0;
  }
  return result;
}

BOOL LiDrawer::filterIntersectionsWithDrawer(LiDrawer *this, LiDrawer *a2)
{
  int v3 = (*(uint64_t (**)(LiDrawer *))(*(void *)this + 112))(this);
  return (int)((*(uint64_t (**)(LiDrawer *))(*(void *)a2 + 112))(a2) + v3) > 2;
}

uint64_t LiDrawer::parent(LiDrawer *this)
{
  return *((void *)this + 2);
}

uint64_t LiDrawer::addIntersection(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4)
  {
    BOOL v5 = *(uint64_t (**)(void))(*(void *)v4 + 152);
    return v5();
  }
  else
  {
    int v7 = *(_DWORD *)(a1 + 36);
    if (*(_DWORD *)(a1 + 32) <= v7) {
      int v8 = (2 * (v7 + 1)) | 1;
    }
    else {
      int v8 = *(_DWORD *)(a1 + 32);
    }
    uint64_t result = PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::resize(a1 + 24, v7 + 1, v8);
    *(void *)(*(void *)(a1 + 40) + 8 * *(int *)(a1 + 36) - 8) = a2;
  }
  return result;
}

uint64_t LiDrawer::getIntersections(LiDrawer *this)
{
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    return (*(uint64_t (**)(void))(*(void *)v2 + 160))();
  }
  else {
    return (uint64_t)this + 24;
  }
}

void LiGroupDrawer::LiGroupDrawer(LiGroupDrawer *this)
{
  *((unsigned char *)this + 8) = 1;
  *((_DWORD *)this + 3) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = &unk_1F111A298;
  *(void *)this = &unk_1F111A1A8;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 7) = &unk_1F111A080;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((unsigned char *)this + 112) = 0;
  LiPolygon::LiPolygon((LiGroupDrawer *)((char *)this + 120));
  *((_DWORD *)this + 56) = 0;
  *((void *)this + 29) = 0;
  *((void *)this + 30) = 0;
  *((void *)this + 46) = 0x3FF0000000000000;
  *((void *)this + 41) = 0x3FF0000000000000;
  *((void *)this + 36) = 0x3FF0000000000000;
  *((void *)this + 31) = 0x3FF0000000000000;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
}

void sub_1B7A80768(_Unwind_Exception *a1)
{
  PCPtrArray<LiDrawer>::~PCPtrArray(v2);
  LiDrawer::~LiDrawer(v1);
  _Unwind_Resume(a1);
}

void LiGroupDrawer::~LiGroupDrawer(LiGroupDrawer *this)
{
  *(void *)this = &unk_1F111A1A8;
  uint64_t v2 = *((void *)this + 29);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  LiPolygon::~LiPolygon((LiGroupDrawer *)((char *)this + 120));
  *((void *)this + 7) = &unk_1F111A0D0;
  int v3 = *((_DWORD *)this + 16);
  if (v3 < 0) {
    int v4 = 1;
  }
  else {
    int v4 = v3 & ~(v3 >> 31);
  }
  if (v4 == v3)
  {
    uint64_t v5 = *((int *)this + 17);
    if ((v5 & 0x80000000) != 0)
    {
      do
        *(void *)(*((void *)this + 9) + 8 * v5) = 0;
      while (!__CFADD__(v5++, 1));
    }
  }
  else
  {
    if (v4) {
      operator new[]();
    }
    uint64_t v7 = *((void *)this + 9);
    if (v7) {
      MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
    }
    *((void *)this + 9) = 0;
  }
  *((_DWORD *)this + 16) = v4;
  *((_DWORD *)this + 17) = 0;
  uint64_t v8 = *((void *)this + 9);
  if (v8) {
    MEMORY[0x1BA9BFB70](v8, 0x1000C8077774924);
  }
  *((void *)this + 9) = 0;
  *((_DWORD *)this + 16) = 0;

  LiDrawer::~LiDrawer(this);
}

{
  uint64_t vars8;

  LiGroupDrawer::~LiGroupDrawer(this);

  JUMPOUT(0x1BA9BFBA0);
}

unsigned int *LiGroupDrawer::draw(unsigned int *this, LiBlender *a2)
{
  uint64_t v2 = this[17];
  if ((int)v2 >= 1)
  {
    int v4 = this;
    do
    {
      signed int v5 = v2 - 1;
      if (v2 - 1 < 0 || (int)v4[17] <= v5) {
        PCArray_base::badIndex((PCArray_base *)this);
      }
      uint64_t v6 = *(void *)(*((void *)v4 + 9) + 8 * v5);
      this = (unsigned int *)(*(uint64_t (**)(uint64_t, LiBlender *))(*(void *)v6 + 16))(v6, a2);
      --v2;
    }
    while (v2);
  }
  return this;
}

uint64_t LiGroupDrawer::add(LiGroupDrawer *this, LiDrawer *a2)
{
  int v4 = (char *)this + 56;
  int v5 = *((_DWORD *)this + 17);
  if (*((_DWORD *)this + 16) <= v5) {
    int v6 = (2 * (v5 + 1)) | 1;
  }
  else {
    int v6 = *((_DWORD *)this + 16);
  }
  PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::resize((uint64_t)v4, v5 + 1, v6);
  *(void *)(*((void *)this + 9) + 8 * *((int *)this + 17) - 8) = a2;
  *((unsigned char *)this + 112) = 0;
  int v7 = *((_DWORD *)this + 56);
  if (v7 <= (*(int (**)(LiDrawer *))(*(void *)a2 + 112))(a2)) {
    uint64_t result = (*(uint64_t (**)(LiDrawer *))(*(void *)a2 + 112))(a2);
  }
  else {
    uint64_t result = *((unsigned int *)this + 56);
  }
  *((_DWORD *)this + 56) = result;
  return result;
}

uint64_t LiGroupDrawer::add(PCArray_base *a1, uint64_t a2)
{
  int v3 = a1;
  uint64_t v4 = *(unsigned int *)(a2 + 12);
  if ((int)v4 >= 1)
  {
    for (uint64_t i = 0; i != v4; ++i)
    {
      if (i >= *(int *)(a2 + 12)) {
        PCArray_base::badIndex(a1);
      }
      uint64_t v6 = *(void *)(*(void *)(a2 + 16) + 8 * i);
      int v7 = *((_DWORD *)v3 + 56);
      if (v7 <= (*(int (**)(uint64_t))(*(void *)v6 + 112))(v6)) {
        a1 = (PCArray_base *)(*(uint64_t (**)(uint64_t))(*(void *)v6 + 112))(v6);
      }
      else {
        a1 = (PCArray_base *)*((unsigned int *)v3 + 56);
      }
      *((_DWORD *)v3 + 56) = a1;
    }
  }
  uint64_t result = PCArray<LiDrawer *,PCArray_Traits_Zero<LiDrawer *>>::append((uint64_t)v3 + 56, a2);
  *((unsigned char *)v3 + 112) = 0;
  return result;
}

uint64_t LiGroupDrawer::prepareToAdd(LiGroupDrawer *this, int a2)
{
  return PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::resize((uint64_t)this + 56, *((_DWORD *)this + 17), *((_DWORD *)this + 17) + a2);
}

uint64_t LiGroupDrawer::getBounds(LiGroupDrawer *this)
{
  if (!*((unsigned char *)this + 112))
  {
    v13[0] = 0uLL;
    __asm { FMOV            V0.2D, #-1.0 }
    v13[1] = _Q0;
    v12[0] = 0uLL;
    v12[1] = _Q0;
    uint64_t v7 = *((unsigned int *)this + 17);
    if ((int)v7 >= 1)
    {
      for (uint64_t i = 0; i != v7; ++i)
      {
        if (i >= *((int *)this + 17)) {
          PCArray_base::badIndex(this);
        }
        uint64_t v9 = *(void *)(*((void *)this + 9) + 8 * i);
        uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 32))(v9);
        bounds<LiPolygon::PosFacet,double>(v10 + 88, (uint64_t)v12);
        PCRect<double>::operator|=(v13, v12);
      }
    }
    LiPolygon::set((uint64_t)this + 120, v13[0].f64);
    *((unsigned char *)this + 112) = 1;
    LiGroupDrawer::projectBoundsToPlane((float64x2_t *)this);
  }
  return (uint64_t)this + 120;
}

void bounds<LiPolygon::PosFacet,double>(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(*(void *)a1 + 8) - **(void **)a1;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)(a2 + 16) = _Q0;
  if ((int)(v2 >> 5) >= 1)
  {
    uint64_t v10 = 0;
    uint64_t v11 = v2 & 0x1FFFFFFFE0;
    do
    {
      float64x2_t v12 = *(float64x2_t *)(**(void **)a1 + v10);
      PCRect<double>::operator|=((float64x2_t *)a2, &v12);
      v10 += 32;
    }
    while (v11 != v10);
  }
}

void LiGroupDrawer::projectBoundsToPlane(float64x2_t *this)
{
  if ((*(unsigned int (**)(float64x2_t *))(*(void *)&this->f64[0] + 40))(this))
  {
    if (((*(void *)&this[12].f64[0] - *(void *)&this[11].f64[1]) & 0x1FFFFFFFE0) != 0)
    {
      v2[0] = 0.0;
      v2[1] = 0.0;
      PCString v2[2] = 1.0;
      LiPolygon::projectToPlane((uint64_t)&this[7].f64[1], this + 5, v2);
    }
  }
}

BOOL LiGroupDrawer::isPlanar(LiGroupDrawer *this)
{
  return fabs(*((double *)this + 10)) >= 0.0000001
      || fabs(*((double *)this + 11)) >= 0.0000001
      || fabs(*((double *)this + 12)) >= 0.0000001
      || fabs(*((double *)this + 13)) >= 0.0000001;
}

__n128 LiGroupDrawer::getPlane@<Q0>(__n128 *this@<X0>, __n128 *a2@<X8>)
{
  __n128 result = this[5];
  __n128 v3 = this[6];
  *a2 = result;
  a2[1] = v3;
  return result;
}

void LiGroupDrawer::stackSort(LiGroupDrawer *this)
{
}

void LiGroupDrawer::setPlane(float64x2_t *this, float64x2_t *a2)
{
  float64x2_t v2 = a2[1];
  this[5] = *a2;
  this[6] = v2;
  LiGroupDrawer::projectBoundsToPlane(this);
}

uint64_t LiGroupDrawer::setSceneObject(uint64_t result, uint64_t a2)
{
  *(void *)(result + 48) = a2;
  return result;
}

uint64_t LiGroupDrawer::getSceneObject(LiGroupDrawer *this)
{
  return *((void *)this + 6);
}

void LiGroupDrawer::intersect(LiGroupDrawer *this, LiIntersection *a2)
{
  uint64_t v4 = *((void *)this + 30);
  if (v4)
  {
    int v5 = *(void (**)(void))(*(void *)v4 + 80);
    v5();
  }
  else
  {
    LiPlaneSplit::LiPlaneSplit((LiPlaneSplit *)v26);
    uint64_t v7 = *(void *)a2;
    char v28 = 0;
    v26[0] = *((void *)a2 + 4);
    v26[1] = v7;
    uint64_t v8 = *((unsigned int *)this + 17);
    if ((int)v8 >= 1)
    {
      uint64_t v9 = 0;
      char v10 = 0;
      do
      {
        if (v9 >= *((int *)this + 17)) {
          PCArray_base::badIndex(v6);
        }
        uint64_t v27 = *(void *)(*((void *)this + 9) + 8 * v9);
        (*(void (**)(uint64_t, char *))(*(void *)v27 + 56))(v27, (char *)this + 80);
        LiPlaneSplit::compute((LiPlaneSplit *)v26);
        if (!((v29 != 3) | v10 & 1))
        {
          uint64_t v18 = (*(uint64_t (**)(LiGroupDrawer *))(*(void *)this + 128))(this);
          if (PCBlend::isAssociative(v18)) {
            LiGroupDrawer::makePrecomp((uint64_t)this, v18, *((void *)a2 + 4));
          }
          char v10 = 1;
        }
        uint64_t v6 = (PCArray_base *)LiPlaneSplit::store((LiPlaneSplit *)v26, v11, v12, v13, v14, v15, v16, v17);
        ++v9;
      }
      while (v8 != v9);
    }
    uint64_t v19 = 0;
    char v20 = 1;
    do
    {
      char v21 = v20;
      if (v19 >= *((int *)a2 + 5)) {
        PCArray_base::badIndex(v6);
      }
      if (v20) {
        uint64_t v22 = 340;
      }
      else {
        uint64_t v22 = 364;
      }
      int v23 = *(_DWORD *)((char *)v26 + v22);
      if (v23)
      {
        if (v23 != 1) {
          operator new();
        }
        uint64_t v24 = 46;
        if (v21) {
          uint64_t v24 = 43;
        }
        uint64_t v25 = *(void *)v26[v24];
        *(void *)(*(void *)(*((void *)a2 + 3) + 8 * v19) + 8) = v25;
        uint64_t v6 = (PCArray_base *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v25 + 56))(v25, (char *)this + 80);
      }
      char v20 = 0;
      uint64_t v19 = 1;
    }
    while ((v21 & 1) != 0);
    LiPlaneSplit::~LiPlaneSplit((LiPlaneSplit *)v26);
  }
}

void sub_1B7A811D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  LiPlaneSplit::~LiPlaneSplit((LiPlaneSplit *)va);
  _Unwind_Resume(a1);
}

void LiGroupDrawer::makePrecomp(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = (LiBlender *)(*(uint64_t (**)(uint64_t))(*(void *)a3 + 24))(a3);
  float v5 = (*(float (**)(uint64_t))(*(void *)a3 + 48))(a3);
  uint64_t v6 = (HGRenderer *)(*(uint64_t (**)(uint64_t))(*(void *)a3 + 40))(a3);
  LiBlender::makeBlender(v4, v6, v5, v7);
}

void sub_1B7A814AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(exception_object);
}

void LiGroupDrawer::name(LiGroupDrawer *this@<X0>, void *a2@<X8>)
{
  LiString::LiString((LiString *)&v24, "group");
  uint64_t v4 = (*(uint64_t (**)(LiGroupDrawer *))(*(void *)this + 72))(this);
  float v5 = (atomic_uint **)(v4 + 512);
  if (v4) {
    BOOL v6 = v5 == &v24;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6) {
    goto LABEL_13;
  }
  if (v24 && atomic_fetch_add(v24 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)uint64_t v24 = 0;
    if (v24) {
      uint64_t v7 = v24 - 3;
    }
    else {
      uint64_t v7 = 0;
    }
    free(v7);
  }
  uint64_t v8 = *v5;
  uint64_t v24 = v8;
  if (v8)
  {
    atomic_fetch_add(v8 - 3, 1u);
LABEL_13:
    uint64_t v9 = v24;
    if (v24) {
      LODWORD(v8) = *(v24 - 2);
    }
    else {
      LODWORD(v8) = 0;
    }
    goto LABEL_17;
  }
  uint64_t v9 = 0;
LABEL_17:
  size_t v10 = (int)v8;
  uint64_t v11 = (unsigned int *)malloc_type_malloc((int)v8 + 15, 0x8903763CuLL);
  v11[1] = v10 + 2;
  double v11[2] = v10 + 3;
  atomic_store(1u, v11);
  uint64_t v12 = v11 + 3;
  atomic_store(0, v11);
  memcpy(v11 + 3, v9, v10);
  *(_WORD *)&v12[v10] = 23328;
  v12[v10 + 2] = 0;
  atomic_fetch_add((atomic_uint *volatile)v11, 1u);
  LiString::format((LiString *)*((unsigned int *)this + 17), (LiString *)&v23);
  size_t v13 = (int)v11[1];
  uint64_t v14 = v23;
  if (v23) {
    int v15 = *((_DWORD *)v23 - 2);
  }
  else {
    int v15 = 0;
  }
  size_t v16 = v13 + v15;
  uint64_t v17 = (unsigned int *)malloc_type_malloc(v16 + 13, 0x8903763CuLL);
  v17[1] = v16;
  v17[2] = v16 + 1;
  atomic_store(1u, v17);
  atomic_store(0, v17);
  memcpy(v17 + 3, v12, v13);
  memcpy((char *)v17 + v13 + 12, v14, v15);
  *((unsigned char *)v17 + v16 + 12) = 0;
  atomic_fetch_add((atomic_uint *volatile)v17, 1u);
  size_t v18 = (int)v17[1];
  uint64_t v19 = (unsigned int *)malloc_type_malloc(v18 + 14, 0x8903763CuLL);
  atomic_store(1u, v19);
  char v20 = v19 + 3;
  atomic_store(0, v19);
  v19[1] = v18 + 1;
  v19[2] = v18 + 2;
  memcpy(v19 + 3, v17 + 3, v18);
  *((unsigned char *)v20 + v18) = 93;
  *((unsigned char *)v20 + v18 + 1) = 0;
  *a2 = v19 + 3;
  atomic_fetch_add((atomic_uint *volatile)v19, 1u);
  if (atomic_fetch_add((atomic_uint *volatile)v17, 0xFFFFFFFF) == 1) {
    free(v17);
  }
  if (v23 && atomic_fetch_add((atomic_uint *volatile)v23 - 3, 0xFFFFFFFF) == 1)
  {
    *int v23 = 0;
    if (v23) {
      char v21 = v23 - 12;
    }
    else {
      char v21 = 0;
    }
    free(v21);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v11, 0xFFFFFFFF) == 1) {
    free(v11);
  }
  if (v24 && atomic_fetch_add(v24 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)uint64_t v24 = 0;
    if (v24) {
      uint64_t v22 = v24 - 3;
    }
    else {
      uint64_t v22 = 0;
    }
    free(v22);
  }
}

void sub_1B7A817CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, atomic_uint *a9, atomic_uint *a10)
{
  if (atomic_fetch_add((atomic_uint *volatile)v11, 0xFFFFFFFF) == 1) {
    free(v11);
  }
  if (a9 && atomic_fetch_add(a9 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)a9 = 0;
    free(a9 - 3);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v10, 0xFFFFFFFF) == 1) {
    free(v10);
  }
  if (a10)
  {
    if (atomic_fetch_add(a10 - 3, 0xFFFFFFFF) == 1)
    {
      *(unsigned char *)a10 = 0;
      free(a10 - 3);
    }
  }
  _Unwind_Resume(exception_object);
}

void LiGroupDrawer::dump(LiGroupDrawer *this, const char **a2)
{
  LiDrawer::dump(this, a2);
  uint64_t v4 = *a2;
  if (v4) {
    int v5 = *((_DWORD *)v4 - 2);
  }
  else {
    int v5 = 0;
  }
  uint64_t v6 = v5 + 2;
  uint64_t v7 = (unsigned int *)malloc_type_malloc(v5 + 15, 0x8903763CuLL);
  v7[1] = v6;
  v7[2] = v5 + 3;
  atomic_store(1u, v7);
  uint64_t v8 = v7 + 3;
  atomic_store(0, v7);
  uint64_t v9 = (PCArray_base *)memcpy(v7 + 3, v4, v5);
  *(_WORD *)((char *)v8 + v5) = 8224;
  *((unsigned char *)v8 + v6) = 0;
  uint64_t v14 = (atomic_uint *)(v7 + 3);
  atomic_fetch_add((atomic_uint *volatile)v7, 1u);
  uint64_t v10 = *((unsigned int *)this + 17);
  if ((int)v10 >= 1)
  {
    for (uint64_t i = 0; i != v10; ++i)
    {
      if (i >= *((int *)this + 17)) {
        PCArray_base::badIndex(v9);
      }
      uint64_t v12 = *(void *)(*((void *)this + 9) + 8 * i);
      uint64_t v9 = (PCArray_base *)(*(uint64_t (**)(uint64_t, atomic_uint **))(*(void *)v12 + 96))(v12, &v14);
    }
  }
  if (v14 && atomic_fetch_add(v14 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)uint64_t v14 = 0;
    if (v14) {
      size_t v13 = v14 - 3;
    }
    else {
      size_t v13 = 0;
    }
    free(v13);
  }
}

void sub_1B7A819DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    ProShade::VertexProgram::VertexProgram(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t LiGroupDrawer::getBlendMode(LiGroupDrawer *this)
{
  uint64_t v1 = *((unsigned int *)this + 17);
  if ((int)v1 >= 1)
  {
    float64x2_t v2 = this;
    uint64_t v3 = 0;
    uint64_t v4 = 48;
    while (1)
    {
      if (v3 >= *((int *)v2 + 17)) {
        PCArray_base::badIndex(this);
      }
      uint64_t v5 = *(void *)(*((void *)v2 + 9) + 8 * v3);
      this = (LiGroupDrawer *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 128))(v5);
      if (this == 48)
      {
        uint64_t v6 = (LiGroupDrawer *)v4;
      }
      else
      {
        uint64_t v6 = this;
        this = (LiGroupDrawer *)PCBlend::isAssociative((int)this);
        if (!this) {
          return 34;
        }
        if (v4 != 48)
        {
          BOOL v7 = v6 == v4;
          uint64_t v6 = (LiGroupDrawer *)v4;
          if (!v7) {
            return 34;
          }
        }
      }
      ++v3;
      uint64_t v4 = (uint64_t)v6;
      if (v1 == v3) {
        return (uint64_t)v6;
      }
    }
  }
  return 48;
}

uint64_t LiGroupDrawer::size(LiGroupDrawer *this)
{
  return *((unsigned int *)this + 17);
}

uint64_t LiGroupDrawer::defocus(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 68);
  if (!v1) {
    return 0;
  }
  if (v1 <= 0) {
    PCArray_base::badIndex((PCArray_base *)a1);
  }
  float64x2_t v2 = *(uint64_t (**)(void))(***(void ***)(a1 + 72) + 136);

  return v2();
}

uint64_t LiGroupDrawer::getFilterIntersections(LiGroupDrawer *this)
{
  return *((unsigned int *)this + 56);
}

void PCPtrArray<LiSeam>::~PCPtrArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111A2E8;
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2 < 0) {
    int v3 = 1;
  }
  else {
    int v3 = v2 & ~(v2 >> 31);
  }
  if (v3 == v2)
  {
    uint64_t v4 = *(int *)(a1 + 12);
    if ((v4 & 0x80000000) != 0)
    {
      do
        *(void *)(*(void *)(a1 + 16) + 8 * v4) = 0;
      while (!__CFADD__(v4++, 1));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6) {
      MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = 0;
  uint64_t v7 = *(void *)(a1 + 16);
  if (v7) {
    MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

void LiSolidRenderer::LiSolidRenderer(LiSolidRenderer *this)
{
  *((void *)this + 11) = 0x3FF0000000000000;
  *((void *)this + 6) = 0x3FF0000000000000;
  *(void *)this = &unk_1F111A308;
  *((void *)this + 1) = 0x3FF0000000000000;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)((char *)this + LiDepthSorter::stackSort((uint64_t)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((void *)this + 27) = 0x3FF0000000000000;
  *((void *)this + 22) = 0x3FF0000000000000;
  __asm { FMOV            V1.2D, #1.0 }
  *((_OWORD *)this + 8) = _Q1;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((void *)this + 48) = 0x3FF0000000000000;
  *((void *)this + 43) = 0x3FF0000000000000;
  *((void *)this + 38) = 0x3FF0000000000000;
  *((_OWORD *)this + 16) = _Q1;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 23) = 0u;
  *((unsigned char *)this + 392) = 1;
  *(_OWORD *)((char *)this + 396) = 0u;
  *(_OWORD *)((char *)this + 412) = 0u;
  *((_DWORD *)this + 107) = 0;
  *((unsigned char *)this + 432) = 1;
  *((_DWORD *)this + 109) = 0;
  *((void *)this + 55) = 5;
  *((unsigned char *)this + 448) = 0;
  *((unsigned char *)this + 460) = 0;
  *((_DWORD *)this + 114) = 0;
  LiClipSet::LiClipSet((LiSolidRenderer *)((char *)this + 464));
  *((void *)this + 64) = -1;
  *((unsigned char *)this + 520) = 0;
  *((_DWORD *)this + 131) = 0;
  *((void *)this + 66) = &unk_1F111A398;
  *((void *)this + 68) = 0;
  *((void *)this + 67) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 69);
  LiDofInfo::LiDofInfo((LiSolidRenderer *)((char *)this + 560));
  *((unsigned char *)this + 636) = 0;
  *((void *)this + 95) = 0x3FF0000000000000;
  *((void *)this + 90) = 0x3FF0000000000000;
  *((void *)this + 85) = 0x3FF0000000000000;
  *((void *)this + 80) = 0x3FF0000000000000;
  *(_OWORD *)(v7 + 88) = 0u;
  *(_OWORD *)(v7 + 104) = 0u;
  *((_OWORD *)this + 43) = 0u;
  *((_OWORD *)this + 44) = 0u;
  *(_OWORD *)(v7 + 168) = 0u;
  *(_OWORD *)(v7 + 184) = 0u;
  *((_DWORD *)this + 192) = 0;
  *(_OWORD *)((char *)this + 776) = 0u;
  *(_OWORD *)((char *)this + 792) = 0u;
  *(_OWORD *)((char *)this + 808) = 0u;
  *(_OWORD *)((char *)this + 824) = 0u;
  *(_OWORD *)((char *)this + 840) = 0u;
  *(_OWORD *)((char *)this + 8LiDepthSorter::stackSort((uint64_t)this + 56) = 0u;
  if (LiSolidRenderer::LiSolidRenderer(void)::sGlobalsOnce != -1) {
    dispatch_once(&LiSolidRenderer::LiSolidRenderer(void)::sGlobalsOnce, &__block_literal_global_66);
  }
  *((unsigned char *)this + 458) = gSeamlessCubeMap;
}

void sub_1B7A81E38(_Unwind_Exception *a1)
{
  PCArray<PCPtr<LiMaterialFilter>,PCArray_Traits<PCPtr<LiMaterialFilter>>>::~PCArray(v2);
  LiClipSet::~LiClipSet(v1);
  _Unwind_Resume(a1);
}

void LiSolidDofInfo::LiSolidDofInfo(LiSolidDofInfo *this)
{
  LiDofInfo::LiDofInfo(this);
  *(unsigned char *)(v1 + 76) = 0;
  *(void *)(v1 + 200) = 0x3FF0000000000000;
  *(void *)(v1 + 160) = 0x3FF0000000000000;
  *(void *)(v1 + 120) = 0x3FF0000000000000;
  *(void *)(v1 + 80) = 0x3FF0000000000000;
  *(_OWORD *)(v1 + 88) = 0u;
  *(_OWORD *)(v1 + 104) = 0u;
  *(_OWORD *)(v1 + 128) = 0u;
  *(_OWORD *)(v1 + 144) = 0u;
  *(_OWORD *)(v1 + 168) = 0u;
  *(_OWORD *)(v1 + 184) = 0u;
}

char *___ZN15LiSolidRendererC2Ev_block_invoke()
{
  uint64_t v0 = (ProGL::GL_Wrap *)ProGL::GL::GL((ProGL::GL *)v6);
  ProGL::GL_Wrap::getIntegerv(v0, 0x8D57u, &gMaxSamples);
  float v1 = log2f(0.0);
  int v2 = (int)exp2f(floorf(v1));
  if (v2 >= 1024) {
    int v2 = 1024;
  }
  if (v2 <= 128) {
    int v2 = 128;
  }
  gTileSize = v2;
  ProGL::Framebuffer::Framebuffer((ProGL::Framebuffer *)v5, (ProGL::GL *)v6);
  if (gMaxSamples >= 1) {
    LiSolidUtils::createMultisampleColorBuffer((ProGL *)v6, (ProGL::GL *)gMaxSamples);
  }
  ProGL::Framebuffer::~Framebuffer((ProGL::Framebuffer *)v5);
  ProGL::GL::~GL((ProGL::GL *)v6);
  String = (char *)glGetString(0x1F03u);
  __n128 result = strstr(String, "ARB_seamless_cube_map");
  gSeamlessCubeMap = result != 0;
  return result;
}

void sub_1B7A81FE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, std::__shared_weak_count *a6, ...)
{
  va_start(va, a6);
  if (a6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a6);
  }
  ProGL::Framebuffer::~Framebuffer((ProGL::Framebuffer *)va);
  ProGL::GL::~GL((ProGL::GL *)(v6 - 56));
  _Unwind_Resume(a1);
}

uint64_t PCArray<PCPtr<LiMaterialFilter>,PCArray_Traits<PCPtr<LiMaterialFilter>>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111A398;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<PCPtr<LiImageFilter>,PCArray_Traits<PCPtr<LiImageFilter>>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

void LiSolidRenderer::~LiSolidRenderer(LiSolidRenderer *this)
{
  *(void *)this = &unk_1F111A308;
  int v2 = (char *)this + 528;
  *((void *)this + 66) = &unk_1F111A398;
  if (*((int *)this + 134) < 0) {
    int v3 = 1;
  }
  else {
    int v3 = *((_DWORD *)this + 134);
  }
  PCArray<PCPtr<LiImageFilter>,PCArray_Traits<PCPtr<LiImageFilter>>>::resize((uint64_t)v2, 0, v3);
  uint64_t v4 = *((void *)this + 68);
  if (v4) {
    MEMORY[0x1BA9BFB70](v4, 0x1000C8077774924);
  }
  *((void *)this + 68) = 0;
  *((_DWORD *)this + 134) = 0;
  LiClipSet::~LiClipSet((LiSolidRenderer *)((char *)this + 464));
}

{
  uint64_t vars8;

  LiSolidRenderer::~LiSolidRenderer(this);

  JUMPOUT(0x1BA9BFBA0);
}

void LiSolidRenderer::depthBlur(LiSolidRenderer *this, ProGL::GL *a2, const LiSolidDofInfo *a3, LiSolidDofInfo *a4, unsigned int a5, GLsizei width, GLsizei height)
{
}

void LiSolidRenderer::setupTile(LiSolidRenderer *this, int a2, int a3, unsigned int a4, unsigned int a5, unsigned int a6, unsigned int a7, unsigned int a8)
{
  ProGL::GL::GL((ProGL::GL *)v39);
  GLfloat v16 = *((double *)this + 50);
  GLfloat v17 = *((double *)this + 51);
  GLfloat v18 = *((double *)this + 52);
  GLfloat v19 = *((double *)this + 53);
  glClearColor(v16, v17, v18, v19);
  glDepthMask(1u);
  glClear(0x4100u);
  double v20 = (double)a8 + (double)a8;
  double v21 = v20 + (double)a4;
  double v22 = v20 + (double)a5;
  glViewport(0, 0, (int)v21, (int)v22);
  long long v23 = *(_OWORD *)((char *)this + 88);
  long long v35 = *(_OWORD *)((char *)this + 72);
  long long v36 = v23;
  long long v24 = *(_OWORD *)((char *)this + 120);
  long long v37 = *(_OWORD *)((char *)this + 104);
  long long v38 = v24;
  float64x2_t v25 = *(float64x2_t *)((char *)this + 24);
  float64x2_t v31 = *(float64x2_t *)((char *)this + 8);
  float64x2_t v32 = v25;
  float64x2_t v27 = *(float64x2_t *)((char *)this + 56);
  float64x2_t v33 = *(float64x2_t *)((char *)this + 40);
  v26.f64[1] = v33.f64[1];
  float64x2_t v34 = v27;
  v26.f64[0] = 1.0 - 1.0 / ((double)a6 / (double)a4) - ((double)(a4 * a2) + (double)(a4 * a2)) / (double)a6;
  double v29 = (double)a6 / v21;
  double v30 = (double)a7 / v22;
  PCMatrix44Tmpl<double>::leftTranslate(&v31, v26, 1.0 - 1.0 / ((double)a7 / (double)a5) - ((double)(a5 * a3) + (double)(a5 * a3)) / (double)a7, 0.0);
  if (v29 != 1.0)
  {
    float64x2_t v31 = vmulq_n_f64(v31, v29);
    float64x2_t v32 = vmulq_n_f64(v32, v29);
  }
  if (v30 != 1.0)
  {
    float64x2_t v33 = vmulq_n_f64(v33, v30);
    float64x2_t v34 = vmulq_n_f64(v34, v30);
  }
  LiSolidUtils::getGLRenderer((LiSolidUtils *)v39, v28);
  ProGL::GL::~GL((ProGL::GL *)v39);
}

void sub_1B7A82364(_Unwind_Exception *a1)
{
  ProGL::GL::~GL((ProGL::GL *)(v1 - 152));
  _Unwind_Resume(a1);
}

void LiSolidRenderer::renderTile(LiSolidRenderer *this, LiSceneObject *a2, const LiTextureCoordinator *a3, unsigned int a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, unsigned int a10, unsigned int a11)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  ProGL::GL::GL((ProGL::GL *)v64);
  if (*((unsigned char *)this + 432)) {
    (*(void (**)(LiSolidRenderer *, uint64_t, uint64_t, uint64_t, void, void, void, void))(*(void *)this + 40))(this, a6, a7, a8, a9, a10, a11, *((unsigned int *)this + 99));
  }
  int v17 = *((_DWORD *)this + 192);
  if (v17 == 49)
  {
    glEnable(0xBE2u);
    glBlendFunc(1u, 0x303u);
    glBlendEquation(0x8006u);
    goto LABEL_7;
  }
  if (v17 == 8)
  {
    glEnable(0xBE2u);
    glBlendFunc(1u, 1u);
LABEL_7:
    glDisable(0xB71u);
    goto LABEL_9;
  }
  glDisable(0xBE2u);
  glEnable(0xB71u);
  glDepthFunc(0x201u);
LABEL_9:
  LiSceneDrawer::LiSceneDrawer((LiSceneDrawer *)v56);
  char v59 = *((unsigned char *)this + 459);
  GLfloat v18 = (double *)((char *)this + 136);
  if (v61 != (char *)this + 136)
  {
    for (uint64_t i = 0; i != 16; i += 4)
    {
      double v20 = &v61[i * 8];
      long long v21 = *(_OWORD *)&v18[i + 2];
      *double v20 = *(_OWORD *)&v18[i];
      v20[1] = v21;
    }
  }
  char v60 = *((unsigned char *)this + 460);
  glGetIntegerv(0xBA2u, params);
  long long v62 = *(_OWORD *)params;
  double v22 = (LiSolidRenderer *)LiSceneDrawer::setIsolatedGroupToRender((uint64_t)v56, *((void *)this + 64));
  LiSolidRenderer::setupClipPlanes(v22, v23, (LiSolidRenderer *)((char *)this + 464));
  LiSolidRenderer::setupFilters((uint64_t)this);
  uint64_t v24 = 0;
  long long v25 = *(_OWORD *)((char *)this + 120);
  long long v54 = *(_OWORD *)((char *)this + 104);
  long long v55 = v25;
  long long v26 = *(_OWORD *)((char *)this + 88);
  v53[4] = *(_OWORD *)((char *)this + 72);
  v53[5] = v26;
  long long v27 = *(_OWORD *)((char *)this + 24);
  v53[0] = *(_OWORD *)((char *)this + 8);
  v53[1] = v27;
  long long v28 = *(_OWORD *)((char *)this + 56);
  v53[2] = *(_OWORD *)((char *)this + 40);
  v53[3] = v28;
  double v29 = 1.0
      / sqrt(*(double *)&v54 * *(double *)&v54+ *((double *)&v54 + 1) * *((double *)&v54 + 1)+ *(double *)&v55 * *(double *)&v55+ *((double *)&v55 + 1) * *((double *)&v55 + 1));
  double v30 = v53;
  do
  {
    for (uint64_t j = 0; j != 2; ++j)
      v30[j] = vmulq_n_f64((float64x2_t)v30[j], v29);
    ++v24;
    v30 += 2;
  }
  while (v24 != 4);
  uint64_t v32 = 0;
  v52[0] = 0x3FF0000000000000;
  memset(&v52[1], 0, 24);
  v52[4] = 0x3FF0000000000000;
  memset(&v52[5], 0, 24);
  float64x2_t v33 = v53;
  v52[8] = 0x3FF0000000000000;
  do
  {
    float64x2_t v34 = &v52[v32];
    *(_OWORD *)float64x2_t v34 = *v33;
    v34[2] = *((void *)v33 + 2);
    v32 += 3;
    v33 += 2;
  }
  while (v32 != 9);
  uint64_t v35 = 0;
  v45[0] = 1.0;
  memset(&v45[1], 0, 24);
  v45[4] = 1.0;
  memset(&v45[5], 0, 24);
  v45[8] = 1.0;
  do
  {
    long long v36 = &v45[v35];
    *(_OWORD *)long long v36 = *(_OWORD *)v18;
    v36[2] = v18[2];
    v35 += 3;
    v18 += 4;
  }
  while (v35 != 9);
  PCMatrix33Tmpl<double>::operator*((uint64_t)v52, v45, (uint64_t)&v46);
  *(void *)&v37.f64[0] = vdupq_laneq_s64(v51, 1).u64[0];
  v37.f64[1] = v50;
  *(void *)&v38.f64[0] = vdupq_laneq_s64(v49, 1).u64[0];
  v38.f64[1] = v48;
  if ((*((unsigned char *)this + 456) != 0) != v47 * (v48 * *(double *)v51.i64 - v50 * *(double *)v49.i64)
                                      + vaddvq_f64(vmulq_f64(v46, vsubq_f64(vmulq_f64((float64x2_t)v49, v37), vmulq_f64((float64x2_t)v51, v38)))) > 0.0)GLenum v39 = 2304;
  else {
    GLenum v39 = 2305;
  }
  glFrontFace(v39);
  if (*((int *)this + 138) > 0)
  {
    if (!*((unsigned char *)this + 456))
    {
      if (!*((unsigned char *)this + 520)) {
        goto LABEL_42;
      }
      goto LABEL_32;
    }
LABEL_28:
    glDisable(0x8037u);
    glEnable(0xB44u);
    if (*((unsigned char *)this + 457)) {
      GLenum v40 = 1028;
    }
    else {
      GLenum v40 = 1029;
    }
    goto LABEL_34;
  }
  if (*((unsigned char *)this + 456)) {
    goto LABEL_28;
  }
  if (!*((unsigned char *)this + 520))
  {
    if (*((_DWORD *)this + 192) == 8)
    {
LABEL_42:
      glDisable(0xB44u);
      goto LABEL_35;
    }
    glEnable(0xB44u);
    glDisable(0x8037u);
    goto LABEL_33;
  }
LABEL_32:
  glEnable(0xB44u);
LABEL_33:
  GLenum v40 = 1029;
LABEL_34:
  glCullFace(v40);
LABEL_35:
  uint64_t v41 = (int *)((char *)this + 552);
  uint64_t v63 = a3;
  int v57 = *((_DWORD *)this + 111);
  int v42 = (uint64_t *)((char *)this + 520);
  if (v57 != 1 || *v41 > 1 || *(unsigned char *)v42) {
    char v43 = *((unsigned char *)this + 456);
  }
  else {
    char v43 = 1;
  }
  char v58 = v43;
  LiSceneDrawer::beginRender(v56, (uint64_t)a2, (uint64_t)this + 464, (long long *)((char *)this + 776), v41, v42, (uint64_t)this + 528);
  glDisable(0xB71u);
  glDisable(0xB44u);
  LiSolidUtils::getGLRenderer((LiSolidUtils *)v64, v44);
  LiSceneDrawer::~LiSceneDrawer((LiSceneDrawer *)v56);
  ProGL::GL::~GL((ProGL::GL *)v64);
}

void sub_1B7A827FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
  LiSceneDrawer::~LiSceneDrawer((LiSceneDrawer *)&a53);
  ProGL::GL::~GL((ProGL::GL *)(v53 - 136));
  _Unwind_Resume(a1);
}

__CFString **LiSolidRenderer::setupClipPlanes(LiSolidRenderer *this, LiSceneObject *a2, const LiClipSet *a3)
{
  __n128 result = (__CFString **)ProShade::UniformData::getCurrentContextUniformData(this);
  if (*((int *)a3 + 3) >= 1)
  {
    uint64_t v5 = (ProShade::UniformData *)result;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = (PCArray_base *)LiClipPlaneInfo::get(v7);
      if ((uint64_t)v7 >= *((int *)a3 + 3)) {
        PCArray_base::badIndex(v8);
      }
      __n128 result = ProShade::UniformData::set<PCVector4<double>>(v5, (uint64_t)v8, (const void *)(*((void *)a3 + 2) + v6));
      uint64_t v7 = (LiClipPlaneInfo *)((char *)v7 + 1);
      v6 += 32;
    }
    while ((uint64_t)v7 < *((int *)a3 + 3));
  }
  return result;
}

uint64_t LiSolidRenderer::setupFilters(uint64_t this)
{
  if (*(int *)(this + 540) >= 1)
  {
    uint64_t v1 = this;
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    do
    {
      uint64_t v4 = *(void *)(*(void *)(v1 + 544) + v2);
      if (!v4) {
        throw_PCNullPointerException(1);
      }
      this = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 32))(v4, v3++);
      v2 += 16;
    }
    while (v3 < *(int *)(v1 + 540));
  }
  return this;
}

void LiSolidRenderer::renderMultisampleTile(LiSolidRenderer *this, ProGL::GL *a2, LiSceneObject *a3, const LiTextureCoordinator *a4, ProGL::Framebuffer *a5, ProGL::Framebuffer *a6, unsigned int a7, unsigned int a8, unsigned int a9, unsigned int a10, unsigned int a11, unsigned int a12, unsigned int a13, unsigned int a14, GLuint a15, GLuint a16, BOOL a17)
{
  ProGL::Framebuffer::bind(a5, a2, 0x8D40u);
  uint64_t RGBOperation = HGGLBlendingInfo::GetRGBOperation(a5);
  (*(void (**)(LiSolidRenderer *, LiSceneObject *, const LiTextureCoordinator *, uint64_t, void, void, void, void, unint64_t, unsigned int))(*(void *)this + 48))(this, a3, a4, RGBOperation, a16, a7, a8, a9, __PAIR64__(a13, a10), a14);
  ProGL::Framebuffer::bind(a6, a2, 0x8D40u);
  ProGL::Framebuffer::attach((uint64_t **)a6, a2, 0x8D40u, 0x8CE0u, 0xDE1u, a15, 0);
  if (*((unsigned char *)this + 636) || a17) {
    ProGL::Framebuffer::attach((uint64_t **)a6, a2, 0x8D40u, 0x8D00u, 0xDE1u, a16, 0);
  }
  GLuint v23 = HGGLBlendingInfo::GetRGBOperation(a5);
  glBindFramebuffer(0x8CA8u, v23);
  GLuint v24 = HGGLBlendingInfo::GetRGBOperation(a6);
  glBindFramebuffer(0x8CA9u, v24);
  GLuint v25 = HGGLBlendingInfo::GetRGBOperation(a5);
  glBindFramebuffer(0x8D40u, v25);
  ProGL::Framebuffer::detach(a6, a2, 0x8CE0u, 0xDE1u);

  ProGL::Framebuffer::detach(a6, a2, 0x8D00u, 0xDE1u);
}

uint64_t LiSolidRenderer::renderNonMultisampleTile(LiSolidRenderer *this, ProGL::GL *a2, LiSceneObject *a3, const LiTextureCoordinator *a4, ProGL::Framebuffer *a5, unsigned int a6, unsigned int a7, unsigned int a8, uint64_t a9, unsigned int a10, GLuint a11, GLuint a12, unsigned int a13, BOOL a14)
{
  ProGL::Framebuffer::bind(a5, a2, 0x8D40u);
  ProGL::Framebuffer::attach((uint64_t **)a5, a2, 0x8D40u, 0x8CE0u, 0xDE1u, a11, 0);
  ProGL::Framebuffer::attach((uint64_t **)a5, a2, 0x8D40u, 0x8D00u, 0xDE1u, a12, 0);
  uint64_t RGBOperation = HGGLBlendingInfo::GetRGBOperation(a5);
  double v20 = *(uint64_t (**)(LiSolidRenderer *, LiSceneObject *, const LiTextureCoordinator *, uint64_t, void, void, void, void, uint64_t))(*(void *)this + 48);

  return v20(this, a3, a4, RGBOperation, a12, a6, a7, a8, a9);
}

void LiSolidRenderer::drawTile(LiSolidRenderer *this, unsigned int a2, unsigned int a3, int a4, int a5, unsigned int a6, unsigned int a7, GLuint a8)
{
  ProGL::GL::GL((ProGL::GL *)v29);
  glDisable(0xBE2u);
  glDisable(0xB71u);
  glDisable(0xB44u);
  glUseProgram(0);
  glViewport(0, 0, a2, a3);
  glActiveTexture(0x84C0u);
  glBindTexture(0xDE1u, a8);
  glEnable(0xDE1u);
  glTexParameterf(0xDE1u, 0x2800u, 9729.0);
  glTexParameterf(0xDE1u, 0x2801u, 9729.0);
  glTexParameteri(0xDE1u, 0x2802u, 33071);
  glTexParameteri(0xDE1u, 0x2803u, 33071);
  double v16 = (double)(a6 * a4) - (double)a2 * 0.5;
  double v17 = (double)(a7 * a5) - (double)a3 * 0.5;
  double v18 = v17 + (double)a7;
  *(float *)&unsigned int v19 = v16;
  *(float *)&double v17 = v17;
  unint64_t v28 = __PAIR64__(LODWORD(v17), v19);
  double v20 = v16 + (double)a6;
  *(float *)&double v20 = v20;
  unint64_t v27 = __PAIR64__(LODWORD(v17), LODWORD(v20));
  *(float *)&double v17 = v18;
  unint64_t v26 = __PAIR64__(LODWORD(v17), LODWORD(v20));
  unint64_t v25 = __PAIR64__(LODWORD(v17), v19);
  LODWORD(v20) = *((_DWORD *)this + 99);
  double v21 = (double)*(unint64_t *)&v20;
  *(float *)&unsigned int v22 = v21 / (v21 + v21 + (double)a6);
  *(float *)&double v21 = v21 / (v21 + v21 + (double)a7);
  unint64_t v24 = __PAIR64__(LODWORD(v21), v22);
  LiSolidUtils::drawRect((uint64_t)v29, &v28, (uint64_t *)&v27, (uint64_t *)&v26, (uint64_t *)&v25, 33984, &v24);
  glActiveTexture(0x84C0u);
  glBindTexture(0xDE1u, 0);
  glDisable(0xDE1u);
  LiSolidUtils::getGLRenderer((LiSolidUtils *)v29, v23);
  ProGL::GL::~GL((ProGL::GL *)v29);
}

void sub_1B7A82DE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  ProGL::GL::~GL((ProGL::GL *)va);
  _Unwind_Resume(a1);
}

void LiSolidRenderer::getFullSizePaddedTileSize(LiSolidRenderer *this, unsigned int *a2, unsigned int *a3, unsigned int a4, unsigned int a5)
{
  *a2 = a4;
  *a3 = a5;
}

void LiSolidRenderer::renderScene(LiSolidRenderer *this, ProGL::GL *a2, LiSceneObject *a3, const LiTextureCoordinator *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9 = a6;
  uint64_t v10 = a5;
  uint64_t v11 = a2;
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  if (!*((unsigned char *)this + 392))
  {
    params[0] = 0;
    ProGL::GL_Wrap::getIntegerv(a2, 0x8CA6u, params);
    *((_DWORD *)this + 138) = 0;
    GLfloat v15 = *((double *)this + 50);
    GLfloat v16 = *((double *)this + 51);
    GLfloat v17 = *((double *)this + 52);
    GLfloat v18 = *((double *)this + 53);
    glClearColor(v15, v16, v17, v18);
    glDepthMask(1u);
    glViewport(0, 0, v10, v9);
    glClear(0x4100u);
    (*(void (**)(LiSolidRenderer *, LiSceneObject *, const LiTextureCoordinator *, void, void, void, void, uint64_t, unint64_t, _DWORD))(*(void *)this + 48))(this, a3, a4, params[0], 0, 0, 0, v10, __PAIR64__(v10, v9), v9);
    return;
  }
  uint64_t v62 = 0;
  (*(void (**)(LiSolidRenderer *, uint64_t, uint64_t, char *, uint64_t *))(*(void *)this + 64))(this, a5, a6, (char *)&v62 + 4, &v62);
  LODWORD(v6) = HIDWORD(v62);
  LODWORD(v7) = v62;
  LODWORD(v8) = *((_DWORD *)this + 99);
  LiSolidRenderer::setupTransparency((uint64_t)this, v13, a3, a4);
  BOOL v14 = *((int *)this + 138) >= 2 && *((_DWORD *)this + 111) != 1;
  int v19 = *((_DWORD *)this + 109);
  ProGL::Framebuffer::Framebuffer((ProGL::Framebuffer *)params, v11);
  ProGL::Framebuffer::Framebuffer((ProGL::Framebuffer *)v60, v11);
  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)v58);
  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)&v57);
  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)&v56);
  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)&v55);
  BOOL v45 = v14;
  uint64_t v52 = (OZChannelBase *)v11;
  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)&v54);
  double v20 = (double)v6;
  double v21 = (double)v8 + (double)v8;
  double v22 = (double)v7;
  uint64_t v53 = 0;
  unsigned int v48 = (v21 + v22);
  unsigned int v49 = (v21 + v20);
  (*(void (**)(LiSolidRenderer *, char *, uint64_t *))(*(void *)this + 32))(this, (char *)&v53 + 4, &v53);
  if (!v14 && !*((unsigned char *)this + 636) && v19) {
    goto LABEL_20;
  }
  LiSolidUtils::createRedTexture((PCWorkingColorVector *)v63);
  long long v23 = v63[0];
  v63[0] = 0uLL;
  unint64_t v24 = (std::__shared_weak_count *)*((void *)&v57 + 1);
  long long v57 = v23;
  if (v24)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v24);
    if (*((void *)&v63[0] + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v63[0] + 1));
    }
  }
  GLuint Name = ProGL::TextureHandle::getName((HGGLBlendingInfo **)&v57);
  BOOL v25 = v14;
  if (v19) {
    BOOL v25 = 0;
  }
  if (v25)
  {
    LiSolidUtils::createRedTexture((PCWorkingColorVector *)v63);
    long long v26 = v63[0];
    v63[0] = 0uLL;
    unint64_t v27 = (std::__shared_weak_count *)*((void *)&v56 + 1);
    long long v56 = v26;
    if (v27)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v27);
      if (*((void *)&v63[0] + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v63[0] + 1));
      }
    }
    unsigned int v44 = ProGL::TextureHandle::getName((HGGLBlendingInfo **)&v56);
    goto LABEL_22;
  }
  if (v19) {
LABEL_20:
  }
    LiSolidUtils::createMultisampleColorBuffer(v11, (ProGL::GL *)*((unsigned int *)this + 109));
  unsigned int v44 = 0;
LABEL_22:
  memset(v63, 0, sizeof(v63));
  if (!*((unsigned char *)this + 456) && Multipass::multipassNeeded(a3, (LiSceneObject *)v14)) {
    operator new();
  }
  unsigned int v42 = vcvtpd_u64_f64((double)v9 / v22);
  if (v42)
  {
    uint64_t v28 = 0;
    unsigned int v43 = vcvtpd_u64_f64((double)v10 / v20);
    double v47 = (char *)this + 560;
    do
    {
      if (v43)
      {
        uint64_t v29 = 0;
        do
        {
          for (int i = 0; i != 1; ++i)
          {
            if (v14)
            {
              uint64_t v31 = *((unsigned int *)this + 138);
              if ((int)v31 >= 1)
              {
                uint64_t v32 = v9;
                uint64_t v33 = v10;
                uint64_t v34 = 0;
                unsigned int v35 = v44;
                uint64_t v36 = Name;
                do
                {
                  *((_DWORD *)this + 139) = v34;
                  GLuint v37 = *((_DWORD *)v63 + v34);
                  if (v19) {
                    LiSolidRenderer::renderMultisampleTile(this, (ProGL::GL *)v52, a3, a4, (ProGL::Framebuffer *)params, (ProGL::Framebuffer *)v60, v29, v28, HIDWORD(v62), v62, v40, HIDWORD(v40), v33, v32, v37, v36, 1);
                  }
                  else {
                    LiSolidRenderer::renderNonMultisampleTile(this, (ProGL::GL *)v52, a3, a4, (ProGL::Framebuffer *)v60, v29, v28, HIDWORD(v62), __SPAIR64__(v33, v62), v32, v37, v36, v41, 0);
                  }
                  if (*((unsigned char *)this + 636)) {
                    (*(void (**)(LiSolidRenderer *, OZChannelBase *, char *, void, uint64_t, void, void))(*(void *)this + 72))(this, v52, v47, *((unsigned int *)v63 + v34), v36, v49, v48);
                  }
                  if (v19) {
                    uint64_t v38 = v36;
                  }
                  else {
                    uint64_t v38 = v35;
                  }
                  if (!v19) {
                    unsigned int v35 = v36;
                  }
                  ++v34;
                  uint64_t v31 = *((int *)this + 138);
                  uint64_t v36 = v38;
                }
                while (v34 < v31);
                uint64_t v10 = v33;
                uint64_t v9 = v32;
                uint64_t v11 = (ProGL::GL *)v52;
                BOOL v14 = v45;
              }
              OZChannelBase::setRangeName((OZChannelBase *)v11, (const PCString *)v31);
            }
            else
            {
              if (v19 && !*((unsigned char *)this + 520)) {
                LiSolidRenderer::renderMultisampleTile(this, v11, a3, a4, (ProGL::Framebuffer *)params, (ProGL::Framebuffer *)v60, v29, v28, HIDWORD(v62), v62, v40, HIDWORD(v40), v10, v9, 0, Name, 0);
              }
              else {
                LiSolidRenderer::renderNonMultisampleTile(this, v11, a3, a4, (ProGL::Framebuffer *)v60, v29, v28, HIDWORD(v62), __SPAIR64__(v10, v62), v9, 0, Name, v41, 0);
              }
              if (*((unsigned char *)this + 636)) {
                (*(void (**)(LiSolidRenderer *, ProGL::GL *, char *, void, void, void, void))(*(void *)this + 72))(this, v11, v47, 0, Name, v49, v48);
              }
            }
          }
          if (*((unsigned char *)this + 448)) {
            GLuint v39 = *((_DWORD *)this + 113);
          }
          else {
            GLuint v39 = 0;
          }
          glBindFramebuffer(0x8D40u, v39);
          (*(void (**)(LiSolidRenderer *, uint64_t, uint64_t, uint64_t, uint64_t, void, void, void))(*(void *)this + 56))(this, v10, v9, v29, v28, HIDWORD(v62), v62, 0);
          uint64_t v29 = (v29 + 1);
        }
        while (v29 != v43);
      }
      uint64_t v28 = (v28 + 1);
    }
    while (v28 != v42);
  }
  if (*((void *)&v54 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v54 + 1));
  }
  if (*((void *)&v55 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v55 + 1));
  }
  if (*((void *)&v56 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v56 + 1));
  }
  if (*((void *)&v57 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v57 + 1));
  }
  if (v59) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v59);
  }
  ProGL::Framebuffer::~Framebuffer((ProGL::Framebuffer *)v60);
  ProGL::Framebuffer::~Framebuffer((ProGL::Framebuffer *)params);
}

void sub_1B7A8361C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,std::__shared_weak_count *a26,uint64_t a27,std::__shared_weak_count *a28,uint64_t a29,std::__shared_weak_count *a30,uint64_t a31,std::__shared_weak_count *a32,uint64_t a33,uint64_t a34,std::__shared_weak_count *a35,char a36)
{
  if (a2)
  {
    MEMORY[0x1BA9BFBA0](v36, 0x10E0C4017AFA08ELL);
    if (a26) {
      std::__shared_weak_count::__release_shared[abi:ne180100](a26);
    }
    if (a28) {
      std::__shared_weak_count::__release_shared[abi:ne180100](a28);
    }
    if (a30) {
      std::__shared_weak_count::__release_shared[abi:ne180100](a30);
    }
    if (a32) {
      std::__shared_weak_count::__release_shared[abi:ne180100](a32);
    }
    if (a35) {
      std::__shared_weak_count::__release_shared[abi:ne180100](a35);
    }
    ProGL::Framebuffer::~Framebuffer((ProGL::Framebuffer *)&a36);
    ProGL::Framebuffer::~Framebuffer((ProGL::Framebuffer *)(v37 - 232));
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x1B7A835D8);
  }
  _Unwind_Resume(exception_object);
}

uint64_t LiSolidRenderer::setupTransparency(uint64_t this, ProGL::GL *a2, LiSceneObject *a3, const LiTextureCoordinator *a4)
{
  if (*(_DWORD *)(this + 440) >= 2u)
  {
    uint64_t v5 = this;
    this = LiSolidUtils::anyTransparencyInScene((uint64_t)a3, a2);
    if (this == 1 || *((unsigned char *)a4 + 8))
    {
      int v6 = *(_DWORD *)(v5 + 440);
    }
    else
    {
      int v6 = 0;
      if (this == 2)
      {
        *(unsigned char *)(v5 + 520) = 1;
        *(_DWORD *)(v5 + 524) = *(_DWORD *)(v5 + 436);
      }
    }
    *(_DWORD *)(v5 + 552) = v6;
  }
  return this;
}

uint64_t Multipass::multipassNeeded(Multipass *this, LiSceneObject *a2)
{
  int v2 = (int)a2;
  ProGL::GL::GL((ProGL::GL *)&v19);
  if (LiSolidUtils::getGLRenderer((LiSolidUtils *)&v19, v4) == 1)
  {
    LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::LiSceneIterator((uint64_t)v21, (uint64_t)this);
    while (1)
    {
      if (v22) {
        uint64_t v5 = LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::next;
      }
      else {
        uint64_t v5 = 0;
      }
      if (!v5)
      {
        LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::~LiSceneIterator((uint64_t)v21);
        goto LABEL_10;
      }
      if (BYTE2(v22[6].var2)) {
        break;
      }
      LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::operator++((uint64_t)v21);
    }
    LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::~LiSceneIterator((uint64_t)v21);
    ProGL::GL::~GL((ProGL::GL *)&v19);
    char v10 = 1;
  }
  else
  {
LABEL_10:
    ProGL::GL::~GL((ProGL::GL *)&v19);
    GLint params = 0;
    glGetIntegerv(0x8872u, &params);
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    BOOL v25 = &unk_1F10AD5F8;
    char v28 = 0;
    LiSceneIterator<LiLight,LiSceneIteratorAlways>::LiSceneIterator((uint64_t)v21, (uint64_t)this);
    int v6 = 0;
    while (1)
    {
      unint64_t v7 = v22;
      unint64_t v8 = v22 ? LiSceneIterator<LiLight,LiSceneIteratorAlways>::next : 0;
      if (!v8 || v22 == 0) {
        break;
      }
      if (SHIDWORD(v26) <= 7) {
        LiLightSet::add((uint64_t)&v25, (const LiLight *)v22);
      }
      if ((LODWORD(v7[5].var12) - 1) <= 2) {
        v6 += BYTE1(v7[6].var6);
      }
      LiSceneIterator<LiLight,LiSceneIteratorAlways>::operator++((uint64_t)v21);
    }
    LiSceneIterator<LiLight,LiSceneIteratorAlways>::~LiSceneIterator((uint64_t)v21);
    LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::LiSceneIterator((uint64_t)v21, (uint64_t)this);
    char v10 = 0;
    if (v6 <= 0) {
      int v11 = v6 + v2;
    }
    else {
      int v11 = v6 + v2 + 1;
    }
    while (1)
    {
      uint64_t v12 = v22 ? LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::next : 0;
      if (!v12 || (v10 & 1) != 0) {
        break;
      }
      int isObjectRef = OZChannelBase::isObjectRef(v22);
      char v10 = v11 + isObjectRef > params;
      LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::operator++((uint64_t)v21);
    }
    LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::~LiSceneIterator((uint64_t)v21);
    LiContext::LiContext((LiContext *)v21);
    char v24 = 0;
    LiContext::setLights((uint64_t)v21, (uint64_t)&v25);
    if (v2)
    {
      PCSharedCount::PCSharedCount(&v19);
      uint64_t v23 = 0x100000002;
    }
    LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::LiSceneIterator((uint64_t)&v19, (uint64_t)this);
    while (1)
    {
      uint64_t v14 = v20;
      GLfloat v15 = v20 ? LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::next : 0;
      if (!v15 || (v10 & 1) != 0) {
        break;
      }
      uint64_t v17 = 0;
      PCSharedCount::PCSharedCount(&v18);
      char v10 = LiSceneDrawer::buildProgram(v14, (LiContext *)v21, (uint64_t)&v17) ^ 1;
      PCSharedCount::~PCSharedCount(&v18);
      LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::operator++((uint64_t)&v19);
    }
    LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::~LiSceneIterator((uint64_t)&v19);
    LiContext::~LiContext((LiContext *)v21);
    PCArray<LiLight,PCArray_Traits<LiLight>>::~PCArray((uint64_t)&v25);
  }
  return v10 & 1;
}

void sub_1B7A83A44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  LiContext::~LiContext((LiContext *)&a33);
  PCArray<LiLight,PCArray_Traits<LiLight>>::~PCArray(v33 - 88);
  _Unwind_Resume(a1);
}

uint64_t Multipass::verifyShaders(Multipass *this)
{
  int v2 = *((_DWORD *)this + 9);
  v18[1] = 0;
  v18[2] = 0;
  v18[0] = &unk_1F10AD5F8;
  char v19 = 0;
  LiSceneIterator<LiLight,LiSceneIteratorAlways>::LiSceneIterator((uint64_t)v12, *((void *)this + 3));
  int v3 = (2 * v2) | 1;
  while (v13 ? LiSceneIterator<LiLight,LiSceneIteratorAlways>::next : 0)
  {
    if (v13) {
      LiLightSet::add((uint64_t)v18, v13);
    }
    LiSceneIterator<LiLight,LiSceneIteratorAlways>::operator++((uint64_t)v12);
  }
  LiSceneIterator<LiLight,LiSceneIteratorAlways>::~LiSceneIterator((uint64_t)v12);
  if (v2 < 0)
  {
    char v7 = 1;
  }
  else
  {
    int v5 = 0;
    if (v3 <= 1) {
      int v6 = 1;
    }
    else {
      int v6 = v3;
    }
    char v7 = 1;
    do
    {
      Multipass::setupForPass(this, v5);
      LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::LiSceneIterator((uint64_t)v16, *((void *)this + 3));
      while (1)
      {
        unint64_t v8 = v17;
        if (!(v17 ? LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::next : 0)) {
          break;
        }
        if ((LiLayeredMaterial::getErrorState(v17) & 1) == 0)
        {
          LiContext::LiContext((LiContext *)v12);
          char v15 = 0;
          LiContext::setLights((uint64_t)v12, (uint64_t)v18);
          if (*((unsigned char *)this + 16))
          {
            PCSharedCount::PCSharedCount(&v11);
            uint64_t v14 = 0x100000002;
          }
          if ((LiSceneDrawer::buildProgram((uint64_t)v8, (LiContext *)v12, 0) & 1) == 0)
          {
            LiLayeredMaterial::setErrorState((uint64_t)v8);
            char v7 = 0;
          }
          LiContext::~LiContext((LiContext *)v12);
        }
        LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::operator++((uint64_t)v16);
      }
      LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::~LiSceneIterator((uint64_t)v16);
      ++v5;
    }
    while (v5 != v6);
  }
  PCArray<LiLight,PCArray_Traits<LiLight>>::~PCArray((uint64_t)v18);
  return v7 & 1;
}

void sub_1B7A83CC0(_Unwind_Exception *a1)
{
  PCArray<LiLight,PCArray_Traits<LiLight>>::~PCArray(v1 - 96);
  _Unwind_Resume(a1);
}

uint64_t Multipass::setupForPass(Multipass *this, int a2)
{
  *((_DWORD *)this + 8) = a2;
  uint64_t result = (uint64_t)Multipass::setStateOfEverything(this, 0);
  int v5 = *((_DWORD *)this + 9);
  uint64_t v7 = *((void *)this + 10);
  uint64_t v6 = *((void *)this + 11);
  unint64_t v8 = (uint64_t *)*((void *)this + 16);
  uint64_t v9 = (uint64_t *)*((void *)this + 17);
  int v10 = a2 / v5;
  while (v8 != v9)
  {
    switch(v10)
    {
      case 2:
        LiLayeredMaterial::setUseDiffuseContributions(*v8, 1);
        uint64_t result = LiLayeredMaterial::setDiffuseAlphaOnly(*v8, 1);
        break;
      case 1:
        uint64_t result = LiLayeredMaterial::setUseSpecularContributions(*v8, 1);
        break;
      case 0:
        uint64_t result = LiLayeredMaterial::setUseDiffuseContributions(*v8, 1);
        break;
    }
    ++v8;
  }
  if (v10 < 2)
  {
    int v11 = a2 % v5;
    unint64_t v12 = (unint64_t)(v6 - v7) >> 3;
    if (a2 % v5 >= (int)v12)
    {
      unint64_t v13 = v11 - (uint64_t)(int)v12;
      uint64_t v14 = *((void *)this + 13);
      if (v13 >= (*((void *)this + 14) - v14) >> 3)
      {
        GLfloat v16 = (uint64_t *)*((void *)this + 7);
        for (int i = (uint64_t *)*((void *)this + 8); v16 != i; *(unsigned char *)(v18 + 720) = 1)
          uint64_t v18 = *v16++;
      }
      else
      {
        uint64_t v15 = *(void *)(v14 + 8 * v13);
        return LiLayeredMaterial::setUseEnvironmentMap(v15, 1);
      }
    }
    else
    {
      *(unsigned char *)(*(void *)(*((void *)this + 10) + 8 * v11) + 720) = 1;
    }
  }
  return result;
}

__CFString **ProShade::UniformData::set<PCVector4<double>>(ProShade::UniformData *a1, uint64_t a2, const void *a3)
{
  v7[18] = *(PCString *)MEMORY[0x1E4F143B8];
  ProShade::Value::Value(v7);
  ProShade::Value::set((uint64_t)v7, (const PCString *)3, 4, a3);
  return ProShade::UniformData::set(a1, *(ProShade::UniformNode **)(a2 + 16), v7);
}

uint64_t LiSolidRenderer::setRenderingParameter(uint64_t result, int a2, int *a3)
{
  if (!a2)
  {
    if (a3)
    {
      int v3 = *a3;
      if (*a3 >= gMaxSamples) {
        int v3 = gMaxSamples;
      }
      *(_DWORD *)(result + 436) = v3;
    }
    else
    {
      uint64_t v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"Invalid object type sent to LiSolidRenderer::setRenderingParameter()", 68);
      std::ios_base::getloc((const std::ios_base *)((char *)v4 + *(void *)(*v4 - 24)));
      int v5 = std::locale::use_facet(&v6, MEMORY[0x1E4FBA258]);
      ((void (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 10);
      std::locale::~locale(&v6);
      std::ostream::put();
      return std::ostream::flush();
    }
  }
  return result;
}

void sub_1B7A83FD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

void LiSolidRenderer::getTileSize(LiSolidRenderer *this, unsigned int a2, unsigned int a3, unsigned int *a4, unsigned int *a5)
{
  unsigned int v5 = gTileSize;
  *a4 = gTileSize;
  *a5 = v5;
}

uint64_t LiTextureCoordinator::textureForImage(LiTextureCoordinator *this, LiImageSource *a2)
{
  uint64_t v4 = (void *)*((void *)this + 3);
  int v2 = (char *)this + 24;
  int v3 = v4;
  if (!v4) {
    return 0;
  }
  unsigned int v5 = v2;
  do
  {
    unint64_t v6 = v3[4];
    BOOL v7 = v6 >= (unint64_t)a2;
    if (v6 >= (unint64_t)a2) {
      unint64_t v8 = v3;
    }
    else {
      unint64_t v8 = v3 + 1;
    }
    if (v7) {
      unsigned int v5 = (char *)v3;
    }
    int v3 = (void *)*v8;
  }
  while (*v8);
  if (v5 != v2 && *((void *)v5 + 4) <= (unint64_t)a2) {
    return *((void *)v5 + 5);
  }
  else {
    return 0;
  }
}

HGGLBlendingInfo *LiMaterialTextureInfo::getTextureID(HGGLBlendingInfo **this)
{
  return ProGL::TextureHandle::getName(this + 25);
}

void LiMaterialTextureInfo::setTexture(LiMaterialTextureInfo *this, const ProGL::TextureHandle *a2)
{
  uint64_t v3 = *(void *)a2;
  uint64_t v2 = *((void *)a2 + 1);
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 26);
  *((void *)this + 25) = v3;
  *((void *)this + 26) = v2;
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
}

uint64_t LiSceneIterator<LiLight,LiSceneIteratorAlways>::operator++(uint64_t a1)
{
  if (*(void *)(a1 + 8))
  {
    do
    {
      LiSceneIterator<LiLight,LiSceneIteratorAlways>::next(a1);
      uint64_t v2 = *(const void **)(a1 + 8);
    }
    while (v2
  }
  return a1;
}

uint64_t LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::operator++(uint64_t a1)
{
  if (*(void *)(a1 + 8))
  {
    do
    {
      LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::next(a1);
      uint64_t v2 = *(const void **)(a1 + 8);
    }
    while (v2
  }
  return a1;
}

void LiContext::setLights(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 440;
  int v5 = *(_DWORD *)(a2 + 12);
  if (*(_DWORD *)(a1 + 448) >= v5) {
    int v6 = *(_DWORD *)(a1 + 448);
  }
  else {
    int v6 = (2 * v5) | 1;
  }
  PCArray<LiLight,PCArray_Traits<LiLight>>::resize(v4, v5, v6);
  if (*(int *)(a2 + 12) >= 1)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    do
    {
      LiLight::operator=(*(void *)(a1 + 456) + v7, *(void *)(a2 + 16) + v7);
      ++v8;
      v7 += 944;
    }
    while (v8 < *(int *)(a2 + 12));
  }
  *(unsigned char *)(a1 + 464) = *(unsigned char *)(a2 + 24);
}

void Multipass::Multipass(Multipass *this, ProGL::GL *a2, ProGL::GL *a3, int a4, LiSceneObject *a5, char a6)
{
  *(void *)this = a2;
  *((_DWORD *)this + 2) = a3;
  *((_DWORD *)this + 3) = a4;
  *((unsigned char *)this + 16) = a6;
  *((void *)this + 3) = a5;
  *((void *)this + 4) = 0xFFFFFFFFLL;
  PCWorkingColorVector::PCWorkingColorVector((Multipass *)((char *)this + 40));
  *(_OWORD *)((char *)this + LiDepthSorter::stackSort((uint64_t)this + 56) = 0u;
  uint64_t v9 = (char **)((char *)this + 56);
  int v68 = (char **)((char *)this + 80);
  *(_OWORD *)((char *)this + 104) = 0u;
  int v10 = (char **)((char *)this + 104);
  int v11 = (char **)((char *)this + 128);
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  LiSolidUtils::createColorTexture(*(LiSolidUtils **)this, a3, a4, 6408, (HGGLBlendingInfo **)v69, v67, SHIDWORD(v67));
  long long v12 = *(_OWORD *)v69;
  v69[0] = 0;
  v69[1] = 0;
  unint64_t v13 = (std::__shared_weak_count *)*((void *)this + 6);
  *(_OWORD *)((char *)this + 40) = v12;
  if (v13)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
    if (v69[1]) {
      std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v69[1]);
    }
  }
  LiSceneIterator<LiLight,LiSceneIteratorAlways>::LiSceneIterator((uint64_t)v69, *((void *)this + 3));
  while (1)
  {
    uint64_t v14 = v69[1];
    if (!(v69[1] ? LiSceneIterator<LiLight,LiSceneIteratorAlways>::next : 0)) {
      break;
    }
    if (LOBYTE(v69[1][6].var6))
    {
      if ((LODWORD(v69[1][5].var12) - 1) <= 2 && BYTE1(v69[1][6].var6))
      {
        uint64_t v17 = (OZChannelBase **)*((void *)this + 11);
        unint64_t v16 = *((void *)this + 12);
        if ((unint64_t)v17 >= v16)
        {
          uint64_t v27 = ((char *)v17 - *v68) >> 3;
          if ((unint64_t)(v27 + 1) >> 61) {
LABEL_91:
          }
            std::vector<double>::__throw_length_error[abi:ne180100]();
          uint64_t v28 = v16 - (void)*v68;
          uint64_t v29 = v28 >> 2;
          if (v28 >> 2 <= (unint64_t)(v27 + 1)) {
            uint64_t v29 = v27 + 1;
          }
          if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v30 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v30 = v29;
          }
          if (v30) {
            uint64_t v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)this + 96, v30);
          }
          else {
            uint64_t v31 = 0;
          }
          uint64_t v36 = (OZChannelBase **)&v31[8 * v27];
          *uint64_t v36 = v14;
          uint64_t v18 = v36 + 1;
          uint64_t v38 = (char *)*((void *)this + 10);
          uint64_t v37 = (char *)*((void *)this + 11);
          if (v37 != v38)
          {
            do
            {
              GLuint v39 = (OZChannelBase *)*((void *)v37 - 1);
              v37 -= 8;
              *--uint64_t v36 = v39;
            }
            while (v37 != v38);
            uint64_t v37 = *v68;
          }
          *((void *)this + 10) = v36;
          *((void *)this + 11) = v18;
          *((void *)this + 12) = &v31[8 * v30];
          if (v37) {
            operator delete(v37);
          }
        }
        else
        {
          *uint64_t v17 = v69[1];
          uint64_t v18 = v17 + 1;
        }
        *((void *)this + 11) = v18;
      }
      else
      {
        uint64_t v20 = (OZChannelBase **)*((void *)this + 8);
        unint64_t v19 = *((void *)this + 9);
        if ((unint64_t)v20 >= v19)
        {
          uint64_t v22 = ((char *)v20 - *v9) >> 3;
          if ((unint64_t)(v22 + 1) >> 61) {
            goto LABEL_91;
          }
          uint64_t v23 = v19 - (void)*v9;
          uint64_t v24 = v23 >> 2;
          if (v23 >> 2 <= (unint64_t)(v22 + 1)) {
            uint64_t v24 = v22 + 1;
          }
          if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v25 = v24;
          }
          if (v25) {
            uint64_t v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)this + 72, v25);
          }
          else {
            uint64_t v26 = 0;
          }
          uint64_t v32 = (OZChannelBase **)&v26[8 * v22];
          *uint64_t v32 = v14;
          double v21 = v32 + 1;
          uint64_t v34 = (char *)*((void *)this + 7);
          uint64_t v33 = (char *)*((void *)this + 8);
          if (v33 != v34)
          {
            do
            {
              unsigned int v35 = (OZChannelBase *)*((void *)v33 - 1);
              v33 -= 8;
              *--uint64_t v32 = v35;
            }
            while (v33 != v34);
            uint64_t v33 = *v9;
          }
          *((void *)this + 7) = v32;
          *((void *)this + 8) = v21;
          *((void *)this + 9) = &v26[8 * v25];
          if (v33) {
            operator delete(v33);
          }
        }
        else
        {
          *uint64_t v20 = v69[1];
          double v21 = v20 + 1;
        }
        *((void *)this + 8) = v21;
      }
    }
    LiSceneIterator<LiLight,LiSceneIteratorAlways>::operator++((uint64_t)v69);
  }
  LiSceneIterator<LiLight,LiSceneIteratorAlways>::~LiSceneIterator((uint64_t)v69);
  LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::LiSceneIterator((uint64_t)v69, *((void *)this + 3));
  while (1)
  {
    uint64_t v40 = v69[1];
    if (!(v69[1] ? LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::next : 0)) {
      break;
    }
    unsigned int v43 = (OZChannelBase **)*((void *)this + 17);
    unint64_t v42 = *((void *)this + 18);
    if ((unint64_t)v43 >= v42)
    {
      uint64_t v45 = ((char *)v43 - *v11) >> 3;
      if ((unint64_t)(v45 + 1) >> 61) {
        goto LABEL_90;
      }
      uint64_t v46 = v42 - (void)*v11;
      uint64_t v47 = v46 >> 2;
      if (v46 >> 2 <= (unint64_t)(v45 + 1)) {
        uint64_t v47 = v45 + 1;
      }
      if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v48 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v48 = v47;
      }
      if (v48) {
        unsigned int v49 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)this + 144, v48);
      }
      else {
        unsigned int v49 = 0;
      }
      double v50 = (OZChannelBase **)&v49[8 * v45];
      *double v50 = v40;
      unsigned int v44 = v50 + 1;
      uint64_t v52 = (char *)*((void *)this + 16);
      int64x2_t v51 = (char *)*((void *)this + 17);
      if (v51 != v52)
      {
        do
        {
          uint64_t v53 = (OZChannelBase *)*((void *)v51 - 1);
          v51 -= 8;
          *--double v50 = v53;
        }
        while (v51 != v52);
        int64x2_t v51 = *v11;
      }
      *((void *)this + 16) = v50;
      *((void *)this + 17) = v44;
      *((void *)this + 18) = &v49[8 * v48];
      if (v51) {
        operator delete(v51);
      }
    }
    else
    {
      const char *v43 = v69[1];
      unsigned int v44 = v43 + 1;
    }
    *((void *)this + 17) = v44;
    if (OZChannelBase::isObjectRef(v40))
    {
      long long v55 = (OZChannelBase **)*((void *)this + 14);
      unint64_t v54 = *((void *)this + 15);
      if ((unint64_t)v55 >= v54)
      {
        uint64_t v57 = ((char *)v55 - *v10) >> 3;
        if ((unint64_t)(v57 + 1) >> 61) {
LABEL_90:
        }
          std::vector<double>::__throw_length_error[abi:ne180100]();
        uint64_t v58 = v54 - (void)*v10;
        uint64_t v59 = v58 >> 2;
        if (v58 >> 2 <= (unint64_t)(v57 + 1)) {
          uint64_t v59 = v57 + 1;
        }
        if ((unint64_t)v58 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v60 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v60 = v59;
        }
        if (v60) {
          int v61 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)this + 120, v60);
        }
        else {
          int v61 = 0;
        }
        uint64_t v62 = (OZChannelBase **)&v61[8 * v57];
        *uint64_t v62 = v40;
        long long v56 = v62 + 1;
        uint64_t v64 = (char *)*((void *)this + 13);
        uint64_t v63 = (char *)*((void *)this + 14);
        if (v63 != v64)
        {
          do
          {
            uint64_t v65 = (OZChannelBase *)*((void *)v63 - 1);
            v63 -= 8;
            *--uint64_t v62 = v65;
          }
          while (v63 != v64);
          uint64_t v63 = *v10;
        }
        *((void *)this + 13) = v62;
        *((void *)this + 14) = v56;
        *((void *)this + 15) = &v61[8 * v60];
        if (v63) {
          operator delete(v63);
        }
      }
      else
      {
        *long long v55 = v40;
        long long v56 = v55 + 1;
      }
      *((void *)this + 14) = v56;
    }
    LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::operator++((uint64_t)v69);
  }
  LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::~LiSceneIterator((uint64_t)v69);
  int v66 = ((*((void *)this + 14) - *((void *)this + 13)) >> 3)
      + ((*((void *)this + 11) - *((void *)this + 10)) >> 3);
  *((_DWORD *)this + 9) = v66;
  if (*((void *)this + 8) != *((void *)this + 7)) {
    *((_DWORD *)this + 9) = v66 + 1;
  }
}

void sub_1B7A846C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, char a11)
{
  unint64_t v16 = *v14;
  if (*v14)
  {
    v11[17] = v16;
    operator delete(v16);
  }
  uint64_t v17 = *v13;
  if (*v13)
  {
    v11[14] = v17;
    operator delete(v17);
  }
  uint64_t v18 = *a10;
  if (*a10)
  {
    v11[11] = v18;
    operator delete(v18);
  }
  unint64_t v19 = *v12;
  if (*v12)
  {
    v11[8] = v19;
    operator delete(v19);
  }
  uint64_t v20 = (std::__shared_weak_count *)v11[6];
  if (v20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v20);
  }
  _Unwind_Resume(exception_object);
}

void Multipass::~Multipass(Multipass *this)
{
  Multipass::setStateOfEverything(this, 1);
  uint64_t v2 = (void *)*((void *)this + 16);
  if (v2)
  {
    *((void *)this + 17) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 13);
  if (v3)
  {
    *((void *)this + 14) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 10);
  if (v4)
  {
    *((void *)this + 11) = v4;
    operator delete(v4);
  }
  int v5 = (void *)*((void *)this + 7);
  if (v5)
  {
    *((void *)this + 8) = v5;
    operator delete(v5);
  }
  int v6 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
}

void *Multipass::setStateOfEverything(void *this, char a2)
{
  uint64_t v3 = this;
  uint64_t v4 = (uint64_t *)this[10];
  int v5 = (uint64_t *)this[11];
  while (v4 != v5)
  {
    uint64_t v6 = *v4++;
    *(unsigned char *)(v6 + 720) = a2;
  }
  uint64_t v7 = (uint64_t *)this[7];
  uint64_t v8 = (uint64_t *)this[8];
  while (v7 != v8)
  {
    uint64_t v9 = *v7++;
    *(unsigned char *)(v9 + 720) = a2;
  }
  int v10 = (uint64_t *)this[13];
  int v11 = (uint64_t *)this[14];
  while (v10 != v11)
  {
    uint64_t v12 = *v10++;
    this = (void *)LiLayeredMaterial::setUseEnvironmentMap(v12, a2);
  }
  uint64_t v14 = (uint64_t *)v3[16];
  unint64_t v13 = (uint64_t *)v3[17];
  while (v14 != v13)
  {
    LiLayeredMaterial::setMultipass(*v14, 1);
    LiLayeredMaterial::setDiffuseAlphaOnly(*v14, 0);
    LiLayeredMaterial::setUnlimitedSamplers((LiLayeredMaterial *)*v14, 0);
    LiLayeredMaterial::setUseDiffuseContributions(*v14, a2);
    uint64_t v15 = *v14++;
    this = (void *)LiLayeredMaterial::setUseSpecularContributions(v15, a2);
  }
  return this;
}

void Multipass::combine(ProGL::GL **a1)
{
  uint64_t v2 = *a1;
  ProGL::Framebuffer::Framebuffer((ProGL::Framebuffer *)v3, *a1);
  ProGL::Framebuffer::bind((ProGL::Framebuffer *)v3, v2, 0x8D40u);
  ProGL::Framebuffer::attach(v3, v2, 0x8D40u, 0x8CE0u, a1 + 5, 0);
  ProGL::Framebuffer::~Framebuffer((ProGL::Framebuffer *)v3);
}

void sub_1B7A84904(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void PCArray<PCPtr<LiMaterialFilter>,PCArray_Traits<PCPtr<LiMaterialFilter>>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111A398;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<PCPtr<LiImageFilter>,PCArray_Traits<PCPtr<LiImageFilter>>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

__CFString **ProShade::UniformData::set(ProShade::UniformData *this, ProShade::UniformNode *a2, const PCString *a3)
{
  uint64_t v6 = a2;
  uint64_t v7 = &v6;
  uint64_t v4 = std::__tree<std::__value_type<ProShade::UniformNode *,ProShade::Value>,std::__map_value_compare<ProShade::UniformNode *,std::__value_type<ProShade::UniformNode *,ProShade::Value>,std::less<ProShade::UniformNode *>,true>,std::allocator<std::__value_type<ProShade::UniformNode *,ProShade::Value>>>::__emplace_unique_key_args<ProShade::UniformNode *,std::piecewise_construct_t const&,std::tuple<ProShade::UniformNode * const&>,std::tuple<>>((uint64_t)this, (unint64_t *)&v6, (uint64_t)&std::piecewise_construct, &v7);
  return ProShade::Value::operator=((__CFString **)v4 + 5, a3);
}

uint64_t *std::__tree<std::__value_type<ProShade::UniformNode *,ProShade::Value>,std::__map_value_compare<ProShade::UniformNode *,std::__value_type<ProShade::UniformNode *,ProShade::Value>,std::less<ProShade::UniformNode *>,true>,std::allocator<std::__value_type<ProShade::UniformNode *,ProShade::Value>>>::__emplace_unique_key_args<ProShade::UniformNode *,std::piecewise_construct_t const&,std::tuple<ProShade::UniformNode * const&>,std::tuple<>>(uint64_t a1, unint64_t *a2, uint64_t a3, void **a4)
{
  uint64_t v6 = (uint64_t **)(a1 + 8);
  int v5 = *(uint64_t **)(a1 + 8);
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        int v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      int v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v8 = (uint64_t **)(a1 + 8);
LABEL_10:
    std::__tree<std::__value_type<ProShade::UniformNode *,ProShade::Value>,std::__map_value_compare<ProShade::UniformNode *,std::__value_type<ProShade::UniformNode *,ProShade::Value>,std::less<ProShade::UniformNode *>,true>,std::allocator<std::__value_type<ProShade::UniformNode *,ProShade::Value>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<ProShade::UniformNode * const&>,std::tuple<>>(a1, a4, (uint64_t)&v11);
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at((uint64_t **)a1, (uint64_t)v8, v6, v11);
    return v11;
  }
  return (uint64_t *)v8;
}

void *std::__tree<std::__value_type<ProShade::UniformNode *,ProShade::Value>,std::__map_value_compare<ProShade::UniformNode *,std::__value_type<ProShade::UniformNode *,ProShade::Value>,std::less<ProShade::UniformNode *>,true>,std::allocator<std::__value_type<ProShade::UniformNode *,ProShade::Value>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<ProShade::UniformNode * const&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, void **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = operator new(0xB8uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  double v6[4] = **a2;
  uint64_t result = ProShade::Value::Value(v6 + 5);
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_1B7A84B28(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  operator delete(v2);
  _Unwind_Resume(a1);
}

uint64_t LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::LiSceneIterator(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = &unk_1F111A3D0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 160) = 0x3FF0000000000000;
  *(void *)(a1 + 120) = 0x3FF0000000000000;
  *(void *)(a1 + 80) = 0x3FF0000000000000;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0x3FF0000000000000;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  while (1)
  {
    uint64_t v3 = *(const void **)(a1 + 8);
    if (!v3
    {
      break;
    }
    LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::next(a1);
  }
  return a1;
}

void sub_1B7A84C18(_Unwind_Exception *a1)
{
  PCArray<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj>>::~PCArray(v1);
  _Unwind_Resume(a1);
}

double LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::next(uint64_t a1)
{
  int v2 = *(const void **)(a1 + 8);
  if (v2)
  {
    if (v3
      && (uint64_t v4 = v3,
          uint64_t v3 = (PCArray_base *)(*(uint64_t (**)(PCArray_base *))(*(void *)v3 + 136))(v3),
          v3))
    {
      int v5 = *(_DWORD *)(a1 + 28);
      if (*(_DWORD *)(a1 + 24) <= v5) {
        int v6 = (2 * (v5 + 1)) | 1;
      }
      else {
        int v6 = *(_DWORD *)(a1 + 24);
      }
      PCArray<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj>>::resize(a1 + 16, v5 + 1, v6);
      uint64_t v7 = *(void *)(a1 + 32) + 144 * *(int *)(a1 + 28);
      *(void *)(v7 - 144) = v4;
      *(_DWORD *)(v7 - 136) = 0;
      uint64_t v8 = v7 - 128;
      if (a1 + 40 != v7 - 128)
      {
        uint64_t v9 = 0;
        uint64_t v10 = a1 + 40;
        uint64_t v11 = v8;
        do
        {
          for (uint64_t i = 0; i != 32; i += 8)
            *(void *)(v11 + i) = *(void *)(v10 + i);
          ++v9;
          v11 += 32;
          v10 += 32;
        }
        while (v9 != 4);
      }
      uint64_t v13 = (*(uint64_t (**)(PCArray_base *, void))(*(void *)v4 + 144))(v4, 0);
      *(void *)(a1 + 8) = v13;
      PCMatrix44Tmpl<double>::operator*(v8, (long long *)(v13 + 8), (uint64_t)v34);
      if (v34 != (_OWORD *)(a1 + 40))
      {
        for (uint64_t j = 0; j != 8; j += 2)
        {
          unint64_t v16 = (_OWORD *)(a1 + 40 + j * 16);
          long long v14 = v34[j];
          long long v17 = v34[j + 1];
          _OWORD *v16 = v14;
          v16[1] = v17;
        }
      }
    }
    else
    {
      int v18 = *(_DWORD *)(a1 + 28);
      if (v18)
      {
        unint64_t v19 = (_OWORD *)(a1 + 40);
        while (1)
        {
          if (v18 <= 0) {
            PCArray_base::badIndex(v3);
          }
          uint64_t v20 = v18 - 1;
          uint64_t v21 = *(void *)(a1 + 32);
          uint64_t v22 = (uint64_t *)(v21 + 144 * v20);
          uint64_t v23 = *v22;
          signed int v25 = *((_DWORD *)v22 + 2);
          uint64_t v24 = v22 + 1;
          if (v25 < (int)((*(uint64_t (**)(uint64_t))(*(void *)v23 + 136))(v23) - 1)) {
            break;
          }
          int v26 = *(_DWORD *)(a1 + 28) - 1;
          if (*(_DWORD *)(a1 + 24) >= v26) {
            int v27 = *(_DWORD *)(a1 + 24);
          }
          else {
            int v27 = (2 * v26) | 1;
          }
          uint64_t v3 = (PCArray_base *)PCArray<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj>>::resize(a1 + 16, v26, v27);
          int v18 = *(_DWORD *)(a1 + 28);
          if (!v18) {
            goto LABEL_25;
          }
        }
        ++*v24;
        uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)v23 + 144))(v23);
        *(void *)(a1 + 8) = v28;
        PCMatrix44Tmpl<double>::operator*(v21 + 144 * v20 + 16, (long long *)(v28 + 8), (uint64_t)v34);
        if (v34 != v19)
        {
          long long v29 = v38;
          *(_OWORD *)(a1 + 104) = v37;
          *(_OWORD *)(a1 + 120) = v29;
          long long v30 = v40;
          *(_OWORD *)(a1 + 136) = v39;
          *(_OWORD *)(a1 + 152) = v30;
          long long v31 = v34[1];
          _OWORD *v19 = v34[0];
          *(_OWORD *)(a1 + LiDepthSorter::stackSort((uint64_t)this + 56) = v31;
          *(void *)&long long v14 = v35;
          long long v32 = v36;
          *(_OWORD *)(a1 + 72) = v35;
          *(_OWORD *)(a1 + 88) = v32;
        }
      }
      else
      {
LABEL_25:
        *(void *)(a1 + 8) = 0;
        *(void *)(a1 + 160) = 0x3FF0000000000000;
        *(void *)(a1 + 120) = 0x3FF0000000000000;
        *(void *)(a1 + 80) = 0x3FF0000000000000;
        *(void *)(a1 + 40) = 0x3FF0000000000000;
        *(void *)&long long v14 = 0;
        *(_OWORD *)(a1 + 48) = 0u;
        *(_OWORD *)(a1 + 64) = 0u;
        *(_OWORD *)(a1 + 88) = 0u;
        *(_OWORD *)(a1 + 104) = 0u;
        *(_OWORD *)(a1 + 128) = 0u;
        *(_OWORD *)(a1 + 144) = 0u;
      }
    }
  }
  return *(double *)&v14;
}

uint64_t PCArray<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111A3D0;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

void PCArray<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111A3D0;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t PCArray<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj>>::resize(uint64_t result, int a2, int a3)
{
  if (a3 <= a2) {
    int v3 = a2;
  }
  else {
    int v3 = a3;
  }
  if (a2 < 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v24, "PCArray::resize");
    PCException::PCException(exception, &v24);
    *(void *)exception = &unk_1F1199218;
  }
  uint64_t v5 = result;
  if (v3 == *(_DWORD *)(result + 8))
  {
    uint64_t v6 = *(int *)(result + 12);
    if ((int)v6 < a2)
    {
      uint64_t v7 = 144 * v6;
      uint64_t v8 = a2 - v6;
      do
      {
        uint64_t v9 = *(void *)(result + 16) + v7;
        *(void *)uint64_t v9 = 0;
        *(void *)(v9 + 8) = 0;
        *(void *)(v9 + 136) = 0x3FF0000000000000;
        *(void *)(v9 + 96) = 0x3FF0000000000000;
        *(void *)(v9 + LiDepthSorter::stackSort((uint64_t)this + 56) = 0x3FF0000000000000;
        *(void *)(v9 + 16) = 0x3FF0000000000000;
        *(_OWORD *)(v9 + 24) = 0uLL;
        *(_OWORD *)(v9 + 40) = 0uLL;
        *(_OWORD *)(v9 + 64) = 0uLL;
        *(_OWORD *)(v9 + 80) = 0uLL;
        *(_OWORD *)(v9 + 104) = 0uLL;
        v7 += 144;
        *(_OWORD *)(v9 + 120) = 0uLL;
        --v8;
      }
      while (v8);
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    int v10 = *(_DWORD *)(result + 12);
    if (a2 >= v10) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = a2;
    }
    if ((int)v11 < 1)
    {
      LODWORD(v11) = 0;
    }
    else
    {
      uint64_t v12 = *(_OWORD **)(result + 16);
      uint64_t v13 = v11;
      long long v14 = 0;
      do
      {
        *long long v14 = *v12;
        long long v15 = v12[1];
        long long v16 = v12[2];
        long long v17 = v12[4];
        void v14[3] = v12[3];
        v14[4] = v17;
        v14[1] = v15;
        v14[2] = v16;
        long long v18 = v12[5];
        long long v19 = v12[6];
        long long v20 = v12[8];
        v14[7] = v12[7];
        _OWORD v14[8] = v20;
        v14[5] = v18;
        v14[6] = v19;
        v12 += 9;
        v14 += 9;
        --v13;
      }
      while (v13);
    }
    if ((int)v11 <= v10) {
      LODWORD(v11) = v10;
    }
    if ((int)v11 < a2)
    {
      uint64_t v21 = 144 * v11 + 96;
      unint64_t v22 = a2 - (unint64_t)v11;
      do
      {
        *(void *)(v21 - 96) = 0;
        *(void *)(v21 - 88) = 0;
        *(void *)(v21 + 40) = 0x3FF0000000000000;
        *(void *)uint64_t v21 = 0x3FF0000000000000;
        *(void *)(v21 - 40) = 0x3FF0000000000000;
        *(void *)(v21 - 80) = 0x3FF0000000000000;
        *(_OWORD *)(v21 - 72) = 0uLL;
        *(_OWORD *)(v21 - LiDepthSorter::stackSort((uint64_t)this + 56) = 0uLL;
        *(_OWORD *)(v21 - 32) = 0uLL;
        *(_OWORD *)(v21 - 16) = 0uLL;
        *(_OWORD *)(v21 + 8) = 0uLL;
        *(_OWORD *)(v21 + 24) = 0uLL;
        v21 += 144;
        --v22;
      }
      while (v22);
    }
    uint64_t result = *(void *)(result + 16);
    if (result) {
      uint64_t result = MEMORY[0x1BA9BFB70](result, 0x1000C8077774924);
    }
    *(void *)(v5 + 16) = 0;
  }
  *(_DWORD *)(v5 + 8) = v3;
  *(_DWORD *)(v5 + 12) = a2;
  return result;
}

void sub_1B7A8527C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

uint64_t LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::~LiSceneIterator(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  *(void *)(a1 + 16) = &unk_1F111A3D0;
  if (*(int *)(a1 + 24) < 0) {
    int v3 = 1;
  }
  else {
    int v3 = *(_DWORD *)(a1 + 24);
  }
  PCArray<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj>>::resize(v2, 0, v3);
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4) {
    MEMORY[0x1BA9BFB70](v4, 0x1000C8077774924);
  }
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return a1;
}

uint64_t LiSceneIterator<LiLight,LiSceneIteratorAlways>::LiSceneIterator(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = &unk_1F111A408;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 160) = 0x3FF0000000000000;
  *(void *)(a1 + 120) = 0x3FF0000000000000;
  *(void *)(a1 + 80) = 0x3FF0000000000000;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0x3FF0000000000000;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  while (1)
  {
    int v3 = *(const void **)(a1 + 8);
    if (!v3
    {
      break;
    }
    LiSceneIterator<LiLight,LiSceneIteratorAlways>::next(a1);
  }
  return a1;
}

void sub_1B7A85408(_Unwind_Exception *a1)
{
  PCArray<LiSceneIterator<LiLight,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiLight,LiSceneIteratorAlways>::Obj>>::~PCArray(v1);
  _Unwind_Resume(a1);
}

double LiSceneIterator<LiLight,LiSceneIteratorAlways>::next(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 8);
  if (v2)
  {
    if (v3
      && (uint64_t v4 = v3,
          int v3 = (PCArray_base *)(*(uint64_t (**)(PCArray_base *))(*(void *)v3 + 136))(v3),
          v3))
    {
      int v5 = *(_DWORD *)(a1 + 28);
      if (*(_DWORD *)(a1 + 24) <= v5) {
        int v6 = (2 * (v5 + 1)) | 1;
      }
      else {
        int v6 = *(_DWORD *)(a1 + 24);
      }
      PCArray<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj>>::resize(a1 + 16, v5 + 1, v6);
      uint64_t v7 = *(void *)(a1 + 32) + 144 * *(int *)(a1 + 28);
      *(void *)(v7 - 144) = v4;
      *(_DWORD *)(v7 - 136) = 0;
      uint64_t v8 = v7 - 128;
      if (a1 + 40 != v7 - 128)
      {
        uint64_t v9 = 0;
        uint64_t v10 = a1 + 40;
        uint64_t v11 = v8;
        do
        {
          for (uint64_t i = 0; i != 32; i += 8)
            *(void *)(v11 + i) = *(void *)(v10 + i);
          ++v9;
          v11 += 32;
          v10 += 32;
        }
        while (v9 != 4);
      }
      uint64_t v13 = (*(uint64_t (**)(PCArray_base *, void))(*(void *)v4 + 144))(v4, 0);
      *(void *)(a1 + 8) = v13;
      PCMatrix44Tmpl<double>::operator*(v8, (long long *)(v13 + 8), (uint64_t)v34);
      if (v34 != (_OWORD *)(a1 + 40))
      {
        for (uint64_t j = 0; j != 8; j += 2)
        {
          long long v16 = (_OWORD *)(a1 + 40 + j * 16);
          long long v14 = v34[j];
          long long v17 = v34[j + 1];
          _OWORD *v16 = v14;
          v16[1] = v17;
        }
      }
    }
    else
    {
      int v18 = *(_DWORD *)(a1 + 28);
      if (v18)
      {
        long long v19 = (_OWORD *)(a1 + 40);
        while (1)
        {
          if (v18 <= 0) {
            PCArray_base::badIndex(v3);
          }
          uint64_t v20 = v18 - 1;
          uint64_t v21 = *(void *)(a1 + 32);
          unint64_t v22 = (uint64_t *)(v21 + 144 * v20);
          uint64_t v23 = *v22;
          signed int v25 = *((_DWORD *)v22 + 2);
          PCString v24 = v22 + 1;
          if (v25 < (int)((*(uint64_t (**)(uint64_t))(*(void *)v23 + 136))(v23) - 1)) {
            break;
          }
          int v26 = *(_DWORD *)(a1 + 28) - 1;
          if (*(_DWORD *)(a1 + 24) >= v26) {
            int v27 = *(_DWORD *)(a1 + 24);
          }
          else {
            int v27 = (2 * v26) | 1;
          }
          int v3 = (PCArray_base *)PCArray<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj>>::resize(a1 + 16, v26, v27);
          int v18 = *(_DWORD *)(a1 + 28);
          if (!v18) {
            goto LABEL_25;
          }
        }
        ++*v24;
        uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)v23 + 144))(v23);
        *(void *)(a1 + 8) = v28;
        PCMatrix44Tmpl<double>::operator*(v21 + 144 * v20 + 16, (long long *)(v28 + 8), (uint64_t)v34);
        if (v34 != v19)
        {
          long long v29 = v38;
          *(_OWORD *)(a1 + 104) = v37;
          *(_OWORD *)(a1 + 120) = v29;
          long long v30 = v40;
          *(_OWORD *)(a1 + 136) = v39;
          *(_OWORD *)(a1 + 152) = v30;
          long long v31 = v34[1];
          _OWORD *v19 = v34[0];
          *(_OWORD *)(a1 + LiDepthSorter::stackSort((uint64_t)this + 56) = v31;
          *(void *)&long long v14 = v35;
          long long v32 = v36;
          *(_OWORD *)(a1 + 72) = v35;
          *(_OWORD *)(a1 + 88) = v32;
        }
      }
      else
      {
LABEL_25:
        *(void *)(a1 + 8) = 0;
        *(void *)(a1 + 160) = 0x3FF0000000000000;
        *(void *)(a1 + 120) = 0x3FF0000000000000;
        *(void *)(a1 + 80) = 0x3FF0000000000000;
        *(void *)(a1 + 40) = 0x3FF0000000000000;
        *(void *)&long long v14 = 0;
        *(_OWORD *)(a1 + 48) = 0u;
        *(_OWORD *)(a1 + 64) = 0u;
        *(_OWORD *)(a1 + 88) = 0u;
        *(_OWORD *)(a1 + 104) = 0u;
        *(_OWORD *)(a1 + 128) = 0u;
        *(_OWORD *)(a1 + 144) = 0u;
      }
    }
  }
  return *(double *)&v14;
}

uint64_t PCArray<LiSceneIterator<LiLight,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiLight,LiSceneIteratorAlways>::Obj>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111A408;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

void PCArray<LiSceneIterator<LiLight,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiLight,LiSceneIteratorAlways>::Obj>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111A408;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t LiSceneIterator<LiLight,LiSceneIteratorAlways>::~LiSceneIterator(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  *(void *)(a1 + 16) = &unk_1F111A408;
  if (*(int *)(a1 + 24) < 0) {
    int v3 = 1;
  }
  else {
    int v3 = *(_DWORD *)(a1 + 24);
  }
  PCArray<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj>>::resize(v2, 0, v3);
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4) {
    MEMORY[0x1BA9BFB70](v4, 0x1000C8077774924);
  }
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return a1;
}

double LiDrawnRegion::Rect::Rect(LiDrawnRegion::Rect *this)
{
  double result = 0.0;
  *(_OWORD *)this = xmmword_1B7E74760;
  *((_DWORD *)this + 4) = 0;
  return result;
}

__n128 LiDrawnRegion::Rect::Rect(LiDrawnRegion::Rect *this, const LiDrawnRegion::Rect *a2)
{
  __n128 result = *(__n128 *)a2;
  *(_OWORD *)this = *(_OWORD *)a2;
  *((_DWORD *)this + 4) = *((_DWORD *)a2 + 4);
  return result;
}

void LiDrawnRegion::clear(LiDrawnRegion *this, __n128 a2)
{
  if (*((int *)this + 2) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *((_DWORD *)this + 2);
  }
  PCArray<LiDrawnRegion::Rect,PCArray_Traits<LiDrawnRegion::Rect>>::resize((uint64_t)this, 0, v2, a2);
}

uint64_t LiDrawnRegion::add(uint64_t a1, int32x2_t *a2, int a3, int a4, unsigned int a5)
{
  uint64_t v9 = *(unsigned int *)(a1 + 12);
  uint64_t isAbelian = PCBlend::isAbelian(a5);
  uint64_t v60 = v9;
  int v54 = a3;
  int v55 = a4;
  if ((int)v9 < 1)
  {
    char v13 = 0;
    int v12 = 0;
    int v58 = -1;
    int v15 = -1;
    goto LABEL_44;
  }
  uint64_t v11 = 0;
  int v12 = 0;
  char v13 = 0;
  int v56 = 0;
  char v57 = isAbelian ^ 1;
  int v58 = -1;
  uint64_t v14 = 8;
  int v15 = -1;
  while (1)
  {
    if (v11 >= *(int *)(a1 + 12)) {
      PCArray_base::badIndex((PCArray_base *)isAbelian);
    }
    uint64_t v16 = *(void *)(a1 + 16);
    long long v17 = (__int32 *)(v16 + v14 - 8);
    int v18 = *(_DWORD *)(v16 + v14 + 8);
    uint64_t isAbelian = PCRect<int>::intersects(a2, v17);
    if (!isAbelian)
    {
      if (v18 == a5)
      {
        uint64_t isAbelian = (uint64_t)operator|<int>(a2, (int32x2_t *)(v16 + v14 - 8), (int32x2_t *)&v61);
        int v32 = HIDWORD(v61) * DWORD2(v61);
        if ((DWORD2(v61) | HIDWORD(v61)) < 0) {
          int v32 = 0;
        }
        int v33 = v58;
        int v34 = v56;
        BOOL v36 = v58 < 0 || v56 > v32;
        if (v36) {
          int v34 = v32;
        }
        int v56 = v34;
        if (v36) {
          int v33 = v11;
        }
        int v58 = v33;
      }
      goto LABEL_40;
    }
    char v19 = v57;
    if (v18 == a5) {
      break;
    }
    char v19 = 1;
LABEL_25:
    v13 |= v19;
LABEL_40:
    ++v11;
    v14 += 20;
    if (v60 == v11) {
      goto LABEL_44;
    }
  }
  __int32 v20 = a2->i32[1];
  if (a2->i32[0] <= *v17) {
    __int32 v21 = *v17;
  }
  else {
    __int32 v21 = a2->i32[0];
  }
  int v22 = *(_DWORD *)(v16 + v14) + *v17;
  if (a2[1].i32[0] + a2->i32[0] < v22) {
    int v22 = a2[1].i32[0] + a2->i32[0];
  }
  __int32 v23 = *(_DWORD *)(v16 + v14 - 4);
  if (v20 <= v23) {
    __int32 v24 = *(_DWORD *)(v16 + v14 - 4);
  }
  else {
    __int32 v24 = a2->i32[1];
  }
  __int32 v25 = a2[1].i32[1] + v20;
  __int32 v26 = *(_DWORD *)(v16 + v14 + 4) + v23;
  if (v25 < v26) {
    __int32 v26 = v25;
  }
  __int32 v27 = v22 - v21;
  int v28 = v26 - v24;
  int v29 = v27 | v28;
  int v30 = v28 * v27;
  if (v29 < 0) {
    int v30 = 0;
  }
  BOOL v31 = v12 < v30;
  if (v12 <= v30) {
    int v12 = v30;
  }
  if (v31) {
    int v15 = v11;
  }
  if ((((int)v60 < 10) & (v57 | v13)) == 0) {
    goto LABEL_25;
  }
  char v13 = 1;
LABEL_44:
  __int32 v37 = a2[1].i32[0];
  __int32 v38 = a2[1].i32[1];
  int v39 = v37 | v38;
  int v40 = v38 * v37;
  if (v39 < 0) {
    int v40 = 0;
  }
  if (v12 != v40)
  {
    if (v13)
    {
      if (v54)
      {
        int v41 = *(_DWORD *)(a1 + 12);
        if (v15 < 0) {
          goto LABEL_68;
        }
        if (v41 <= v15) {
          PCArray_base::badIndex((PCArray_base *)isAbelian);
        }
        uint64_t v42 = *(void *)(a1 + 16);
        uint64_t v43 = v42 + 20 * v15;
        int v44 = *(_DWORD *)(v43 + 8);
        if (v44 < 0)
        {
          int v46 = 0;
        }
        else
        {
          int v45 = *(_DWORD *)(v43 + 12);
          int v46 = v45 * v44;
          if (v45 < 0) {
            int v46 = 0;
          }
        }
        int v41 = *(_DWORD *)(a1 + 12);
        if (v12 != v46 && (int)v60 <= 9)
        {
LABEL_68:
          __n128 v48 = *(__n128 *)a2->i8;
          long long v61 = *(_OWORD *)a2->i8;
          int v50 = v41 + 1;
          if (*(_DWORD *)(a1 + 8) <= v41) {
            int v51 = (2 * (v41 + 1)) | 1;
          }
          else {
            int v51 = *(_DWORD *)(a1 + 8);
          }
          goto LABEL_71;
        }
        if (v41 <= v15) {
          PCArray_base::badIndex((PCArray_base *)isAbelian);
        }
        uint64_t v47 = (int32x2_t *)(v42 + 20 * v15);
LABEL_75:
        PCRect<int>::operator|=(v47, a2);
      }
    }
    else if (v55)
    {
      if ((int)v60 >= 10 && (v58 & 0x80000000) == 0)
      {
        if (*(_DWORD *)(a1 + 12) <= v58) {
          PCArray_base::badIndex((PCArray_base *)isAbelian);
        }
        uint64_t v47 = (int32x2_t *)(*(void *)(a1 + 16) + 20 * v58);
        goto LABEL_75;
      }
      __n128 v48 = *(__n128 *)a2->i8;
      long long v61 = *(_OWORD *)a2->i8;
      int v49 = *(_DWORD *)(a1 + 12);
      int v50 = v49 + 1;
      if (*(_DWORD *)(a1 + 8) <= v49) {
        int v51 = (2 * (v49 + 1)) | 1;
      }
      else {
        int v51 = *(_DWORD *)(a1 + 8);
      }
LABEL_71:
      PCArray<LiDrawnRegion::Rect,PCArray_Traits<LiDrawnRegion::Rect>>::resize(a1, v50, v51, v48);
      uint64_t v52 = *(void *)(a1 + 16) + 20 * *(int *)(a1 + 12);
      *(_OWORD *)(v52 - 20) = v61;
      *(_DWORD *)(v52 - 4) = a5;
    }
  }
  return v13 & 1;
}

BOOL PCRect<int>::intersects(_DWORD *a1, _DWORD *a2)
{
  int v2 = a1[2];
  if (v2 < 0) {
    return 0;
  }
  int v3 = a1[3];
  if (v3 < 0) {
    return 0;
  }
  uint64_t v4 = 0;
  int v5 = a2[2];
  if ((v5 & 0x80000000) == 0)
  {
    int v6 = a2[3];
    if ((v6 & 0x80000000) == 0)
    {
      int v7 = *a1 + v2;
      if (*a1 <= *a2 + v5 && v7 >= *a2)
      {
        int v10 = a1[1];
        int v11 = a2[1];
        BOOL v12 = v3 + v10 >= v11;
        return v10 <= v6 + v11 && v12;
      }
      return 0;
    }
  }
  return v4;
}

int32x2_t *operator|<int>@<X0>(int32x2_t *result@<X0>, int32x2_t *a2@<X1>, int32x2_t *a3@<X8>)
{
  int32x2_t v3 = result[1];
  if (v3.i32[0] < 0 || v3.i32[1] < 0)
  {
    long long v7 = *(_OWORD *)a2->i8;
  }
  else
  {
    int32x2_t v4 = a2[1];
    if ((v4.i32[0] & 0x80000000) == 0 && (v4.i32[1] & 0x80000000) == 0)
    {
      int32x2_t v5 = vmin_s32(*result, *a2);
      int32x2_t v6 = vsub_s32(vmax_s32(vadd_s32(v3, *result), vadd_s32(v4, *a2)), v5);
      *a3 = v5;
      a3[1] = v6;
      return result;
    }
    long long v7 = *(_OWORD *)result->i8;
  }
  *(_OWORD *)a3->i8 = v7;
  return result;
}

void ProShade::Texture::Texture(PCSharedCount *this)
{
  this->int var0 = (PC_Sp_counted_base *)&unk_1F111A440;
  this[1].int var0 = 0;
  PCSharedCount::PCSharedCount(this + 2);
  operator new();
}

void sub_1B7A85E20(_Unwind_Exception *a1)
{
  LiString::dec(v4);
  *(void *)(v2 + 40) = &unk_1F1199AC8;
  *(unsigned char *)(v2 + LiDepthSorter::stackSort((uint64_t)this + 56) = 0;
  PCWeakCount::~PCWeakCount(v3);
  MEMORY[0x1BA9BFBA0](v2, 0x10B1C40512DA185);
  PCSharedCount::~PCSharedCount(v1);
  _Unwind_Resume(a1);
}

void ProShade::Texture::~Texture(PCSharedCount *this)
{
  this->int var0 = (PC_Sp_counted_base *)&unk_1F111A440;
  PCSharedCount::~PCSharedCount(this + 2);
}

{
  uint64_t vars8;

  this->int var0 = (PC_Sp_counted_base *)&unk_1F111A440;
  PCSharedCount::~PCSharedCount(this + 2);

  JUMPOUT(0x1BA9BFBA0);
}

int8x8_t *ProShade::Texture::computeHash(ProShade::Texture *this, int8x8_t *a2)
{
  __n128 result = PCHashWriteStream::writeValue(a2, "Texture");
  uint64_t v5 = *((void *)this + 1);
  if (v5)
  {
    uint64_t v6 = *(unsigned int *)(v5 + 32);
    long long v7 = *(uint64_t (**)(int8x8_t *, uint64_t))(*(void *)a2 + 48);
    return (int8x8_t *)v7(a2, v6);
  }
  return result;
}

uint64_t LiPerContextValue<ProShade::SamplerNode::Binding>::~LiPerContextValue(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (*(void *)a1 != a1 + 8)
  {
    do
    {
      int32x2_t v3 = (void *)v2[1];
      if (v3)
      {
        do
        {
          int32x2_t v4 = v3;
          int32x2_t v3 = (void *)*v3;
        }
        while (v3);
      }
      else
      {
        do
        {
          int32x2_t v4 = (void *)v2[2];
          BOOL v5 = *v4 == (void)v2;
          uint64_t v2 = v4;
        }
        while (!v5);
      }
      uint64_t v2 = v4;
    }
    while (v4 != (void *)(a1 + 8));
  }
  PCSpinLock::~PCSpinLock((PCSpinLock *)(a1 + 24));
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(a1, *(void **)(a1 + 8));
  return a1;
}

void ProShade::InputNode::~InputNode(ProShade::InputNode *this, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  *(void *)this = v2;
  *(void *)((char *)this + *(void *)(v2 - 24)) = *(void *)(a2 + 32);
  LiString::dec((ProShade::InputNode *)((char *)this + 32));
}

ProShade::SamplerNode *ProShade::SamplerNode::SamplerNode(ProShade::SamplerNode *this, ProShade *a2, const PCString *a3, char a4, char a5)
{
  char v7 = (char)a3;
  int v8 = (int)a2;
  *((void *)this + 13) = 0;
  *((void *)this + 12) = &unk_1F1199AC8;
  *((unsigned char *)this + 112) = 1;
  int v10 = ProShade::shapeTexture(a2, a3);
  ProShade::InputNode::InputNode(this, (uint64_t *)off_1F111A560, 2, v10, 4);
  *(void *)this = &unk_1F111A470;
  *((void *)this + 12) = &unk_1F111A540;
  *((_DWORD *)this + 14) = v8;
  *((unsigned char *)this + 60) = v7;
  *((unsigned char *)this + 61) = a4;
  *((unsigned char *)this + 62) = a5;
  *((void *)this + 9) = 0;
  *((void *)this + 8) = (char *)this + 72;
  *((void *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  *((_DWORD *)this + 10) = 1;
  LiString::LiString((LiString *)&v21, "_sampler");
  LiString::format((LiString *)*((unsigned int *)this + 12), (LiString *)&v20);
  int v11 = v21;
  if (v21) {
    int v12 = *((_DWORD *)v21 - 2);
  }
  else {
    int v12 = 0;
  }
  char v13 = v20;
  if (v20) {
    int v14 = *((_DWORD *)v20 - 2);
  }
  else {
    int v14 = 0;
  }
  uint64_t v15 = v14 + (uint64_t)v12;
  uint64_t v16 = (unsigned int *)malloc_type_malloc(v15 + 13, 0x8903763CuLL);
  v16[1] = v15;
  double v16[2] = v15 + 1;
  atomic_store(1u, v16);
  atomic_store(0, v16);
  memcpy(v16 + 3, v11, v12);
  memcpy((char *)v16 + v12 + 12, v13, v14);
  *((unsigned char *)v16 + v15 + 12) = 0;
  atomic_fetch_add((atomic_uint *volatile)v16, 1u);
  LiString::dec((ProShade::SamplerNode *)((char *)this + 32));
  *((void *)this + 4) = v16 + 3;
  atomic_fetch_add((atomic_uint *volatile)v16, 1u);
  if (atomic_fetch_add((atomic_uint *volatile)v16, 0xFFFFFFFF) == 1) {
    free(v16);
  }
  if (v20 && atomic_fetch_add((atomic_uint *volatile)v20 - 3, 0xFFFFFFFF) == 1)
  {
    *__int32 v20 = 0;
    if (v20) {
      long long v17 = v20 - 12;
    }
    else {
      long long v17 = 0;
    }
    free(v17);
  }
  if (v21 && atomic_fetch_add((atomic_uint *volatile)v21 - 3, 0xFFFFFFFF) == 1)
  {
    *__int32 v21 = 0;
    if (v21) {
      int v18 = v21 - 12;
    }
    else {
      int v18 = 0;
    }
    free(v18);
  }
  return this;
}

void sub_1B7A86348(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, atomic_uint *a11, atomic_uint *a12)
{
  if (atomic_fetch_add((atomic_uint *volatile)v14, 0xFFFFFFFF) == 1) {
    free(v14);
  }
  if (a11 && atomic_fetch_add(a11 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)a11 = 0;
    free(a11 - 3);
  }
  if (a12)
  {
    if (atomic_fetch_add(a12 - 3, 0xFFFFFFFF) == 1)
    {
      *(unsigned char *)a12 = 0;
      free(a12 - 3);
    }
  }
  LiPerContextValue<ProShade::SamplerNode::Binding>::~LiPerContextValue(a9);
  ProShade::InputNode::~InputNode((ProShade::InputNode *)v12, (uint64_t)off_1F111A560);
  *(void *)(v12 + 96) = a10;
  *(unsigned char *)(v12 + 112) = 0;
  PCWeakCount::~PCWeakCount(v13);
  _Unwind_Resume(a1);
}

ProShade::SamplerNode *ProShade::SamplerNode::SamplerNode(ProShade::SamplerNode *this, ProShade *a2, const PCString *a3, char a4, char a5, const LiString *a6)
{
  char v9 = (char)a3;
  int v10 = (int)a2;
  *((void *)this + 13) = 0;
  *((void *)this + 12) = &unk_1F1199AC8;
  *((unsigned char *)this + 112) = 1;
  int v12 = ProShade::shapeTexture(a2, a3);
  ProShade::InputNode::InputNode(this, (uint64_t *)off_1F111A560, 2, v12, 4);
  *(void *)this = &unk_1F111A470;
  *((void *)this + 12) = &unk_1F111A540;
  *((_DWORD *)this + 14) = v10;
  *((unsigned char *)this + 60) = v9;
  *((unsigned char *)this + 61) = a4;
  *((unsigned char *)this + 62) = a5;
  *((void *)this + 9) = 0;
  *((void *)this + 8) = (char *)this + 72;
  *((void *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  *((_DWORD *)this + 10) = 1;
  if ((ProShade::SamplerNode *)((char *)this + 32) != a6)
  {
    LiString::dec((ProShade::SamplerNode *)((char *)this + 32));
    uint64_t v13 = *(void *)a6;
    *((void *)this + 4) = *(void *)a6;
    if (v13) {
      atomic_fetch_add((atomic_uint *volatile)(v13 - 12), 1u);
    }
  }
  return this;
}

void sub_1B7A86570(_Unwind_Exception *a1)
{
  LiPerContextValue<ProShade::SamplerNode::Binding>::~LiPerContextValue(v4);
  ProShade::InputNode::~InputNode((ProShade::InputNode *)v1, (uint64_t)off_1F111A560);
  *(void *)(v1 + 96) = v3;
  *(unsigned char *)(v1 + 112) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

void ProShade::SamplerNode::~SamplerNode(ProShade::SamplerNode *this, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *(void *)this = *a2;
  *(void *)((char *)this + *(void *)(v4 - 24)) = a2[7];
  BOOL v5 = (ProShade::SamplerNode *)*((void *)this + 8);
  if (v5 != (ProShade::SamplerNode *)((char *)this + 72))
  {
    do
    {
      uint64_t v6 = (ProShade::SamplerNode *)*((void *)v5 + 1);
      if (v6)
      {
        do
        {
          char v7 = v6;
          uint64_t v6 = *(ProShade::SamplerNode **)v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          char v7 = (ProShade::SamplerNode *)*((void *)v5 + 2);
          BOOL v8 = *(void *)v7 == (void)v5;
          BOOL v5 = v7;
        }
        while (!v8);
      }
      BOOL v5 = v7;
    }
    while (v7 != (ProShade::SamplerNode *)((char *)this + 72));
  }
  PCSpinLock::~PCSpinLock((PCSpinLock *)this + 22);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 64, *((void **)this + 9));

  ProShade::InputNode::~InputNode(this, (uint64_t)(a2 + 1));
}

void ProShade::SamplerNode::~SamplerNode(ProShade::SamplerNode *this)
{
  *(void *)(v1 + 96) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 112) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 104));
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)(v1 + 96) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 112) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 104));

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'ProShade::SamplerNode::~SamplerNode(ProShade::SamplerNode *this)
{
  *(void *)(v1 + 96) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 112) = 0;
  uint64_t v2 = (PC_Sp_counted_base **)(v1 + 104);

  PCWeakCount::~PCWeakCount(v2);
}

{
  ProShade::SamplerNode::~SamplerNode((ProShade::SamplerNode *)((char *)this + *(void *)(*(void *)this - 24)));
}

uint64_t ProShade::SamplerNode::repr@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 32);
  *a2 = v2;
  if (v2) {
    atomic_fetch_add((atomic_uint *volatile)(v2 - 12), 1u);
  }
  return this;
}

void ProShade::SamplerNode::description(ProShade::SamplerNode *this@<X0>, void *a2@<X8>)
{
  ProShade::shapeString((OZChannelBase *)*((unsigned int *)this + 7), (const PCString *)*((unsigned int *)this + 6), (LiString *)&v15);
  uint64_t v4 = v15;
  if (v15) {
    int v5 = *((_DWORD *)v15 - 2);
  }
  else {
    int v5 = 0;
  }
  size_t v6 = v5;
  char v7 = (unsigned int *)malloc_type_malloc(v5 + 14, 0x8903763CuLL);
  v7[1] = v6 + 1;
  v7[2] = v6 + 2;
  atomic_store(1u, v7);
  BOOL v8 = v7 + 3;
  atomic_store(0, v7);
  memcpy(v7 + 3, v4, v6);
  v8[v6] = 32;
  v8[v6 + 1] = 0;
  atomic_fetch_add((atomic_uint *volatile)v7, 1u);
  size_t v9 = (int)v7[1];
  int v10 = (_DWORD *)*((void *)this + 4);
  if (v10) {
    int v11 = *(v10 - 2);
  }
  else {
    int v11 = 0;
  }
  size_t v12 = v9 + v11;
  uint64_t v13 = (unsigned int *)malloc_type_malloc(v12 + 13, 0x8903763CuLL);
  v13[1] = v12;
  float64x2_t v13[2] = v12 + 1;
  atomic_store(1u, v13);
  atomic_store(0, v13);
  memcpy(v13 + 3, v8, v9);
  memcpy((char *)v13 + v9 + 12, v10, v11);
  *((unsigned char *)v13 + v12 + 12) = 0;
  *a2 = v13 + 3;
  atomic_fetch_add((atomic_uint *volatile)v13, 1u);
  if (atomic_fetch_add((atomic_uint *volatile)v7, 0xFFFFFFFF) == 1) {
    free(v7);
  }
  if (v15 && atomic_fetch_add((atomic_uint *volatile)v15 - 3, 0xFFFFFFFF) == 1)
  {
    unsigned char *v15 = 0;
    if (v15) {
      int v14 = v15 - 12;
    }
    else {
      int v14 = 0;
    }
    free(v14);
  }
}

void sub_1B7A869DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, atomic_uint *a10)
{
  if (atomic_fetch_add((atomic_uint *volatile)v10, 0xFFFFFFFF) == 1) {
    free(v10);
  }
  if (a10)
  {
    if (atomic_fetch_add(a10 - 3, 0xFFFFFFFF) == 1)
    {
      *(unsigned char *)a10 = 0;
      free(a10 - 3);
    }
  }
  _Unwind_Resume(exception_object);
}

int8x8_t *ProShade::SamplerNode::computeHash(ProShade::SamplerNode *this, int8x8_t *a2)
{
  PCHashWriteStream::writeValue(a2, "SamplerNode");
  (*(void (**)(int8x8_t *, void))(*(void *)a2 + 56))(a2, *((unsigned int *)this + 14));
  PCHashWriteStream::writeValue(a2, *((unsigned char *)this + 60));
  PCHashWriteStream::writeValue(a2, *((unsigned char *)this + 61));
  PCHashWriteStream::writeValue(a2, *((unsigned char *)this + 62));
  if (*((void *)this + 4)) {
    uint64_t v4 = (const char *)*((void *)this + 4);
  }
  else {
    uint64_t v4 = "";
  }

  return PCHashWriteStream::writeValue(a2, v4);
}

void ProShade::SamplerNode::inputs(uint64_t a1, uint64_t a2)
{
  if (*(int *)(a2 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a2 + 8);
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a2, 0, v2);
}

PCSharedCount *ProShade::SamplerNode::apply@<X0>(PCShared_base *a1@<X0>, PCSharedCount *a2@<X8>)
{
  return ProShade::VarT<ProShade::Node>::VarT(a2, a1);
}

uint64_t ProShade::SamplerNode::atomic(ProShade::SamplerNode *this)
{
  return 1;
}

void ProShade::SamplerNode::clone(ProShade::SamplerNode *this)
{
  exception = (PCException *)__cxa_allocate_exception(0x40uLL);
  PCString::PCString(&v3, "not implemented yet");
  PCString::PCString(&v2, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/Shading/PSTexture.cpp");
  PCException::PCException(exception, &v3, &v2, 124);
  *(void *)exception = &unk_1F10B1208;
}

void sub_1B7A86BB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString((PCString *)&a9);
  PCString::~PCString(&a10);
  if (v11) {
    __cxa_free_exception(v10);
  }
  _Unwind_Resume(a1);
}

void ProShade::SamplerNode::getValue(int a1, PCSharedCount *this)
{
}

uint64_t LiPerContext<ProShade::SamplerNode::Binding,LiPerContextValue_Traits<ProShade::SamplerNode::Binding>,LiOpenGLContextGetter>::get(uint64_t a1)
{
  PCString v2 = (os_unfair_lock_s *)(a1 + 24);
  PCSpinLock::lock((os_unfair_lock_t)(a1 + 24));
  v6[1] = 0;
  v6[0] = LiGLState::getCurrentContext(v3);
  uint64_t v4 = std::__tree<std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>,std::__map_value_compare<LiOpenGLContextGetter::C,std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>,LiOpenGLContextGetter::Compare,true>,std::allocator<std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>>>::find<LiOpenGLContextGetter::C>(a1, v6);
  if (a1 + 8 == v4)
  {
    char v7 = v6;
    uint64_t v4 = (uint64_t)std::__tree<std::__value_type<LiOpenGLContextGetter::C,ProShade::SamplerNode::Binding>,std::__map_value_compare<LiOpenGLContextGetter::C,std::__value_type<LiOpenGLContextGetter::C,ProShade::SamplerNode::Binding>,LiOpenGLContextGetter::Compare,true>,std::allocator<std::__value_type<LiOpenGLContextGetter::C,ProShade::SamplerNode::Binding>>>::__emplace_unique_key_args<LiOpenGLContextGetter::C,std::piecewise_construct_t const&,std::tuple<LiOpenGLContextGetter::C const&>,std::tuple<>>((uint64_t **)a1, v6, (uint64_t)&std::piecewise_construct, (_OWORD **)&v7);
  }
  PCSpinLock::unlock(v2);
  return v4 + 48;
}

void sub_1B7A86C98(_Unwind_Exception *a1)
{
  PCSpinLock::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t ProShade::SamplerNode::setWrapMode(uint64_t a1, int a2)
{
  uint64_t result = LiPerContext<ProShade::SamplerNode::Binding,LiPerContextValue_Traits<ProShade::SamplerNode::Binding>,LiOpenGLContextGetter>::get(a1 + 64);
  *(_DWORD *)(result + 8) = a2;
  return result;
}

uint64_t ProShade::SamplerNode::getWrapMode(ProShade::SamplerNode *this)
{
  return *(unsigned int *)(LiPerContext<ProShade::SamplerNode::Binding,LiPerContextValue_Traits<ProShade::SamplerNode::Binding>,LiOpenGLContextGetter>::get((uint64_t)this + 64)
                         + 8);
}

BOOL ProShade::SamplerNode::getTextureID(ProShade::SamplerNode *this, int *a2)
{
  int v3 = *(_DWORD *)LiPerContext<ProShade::SamplerNode::Binding,LiPerContextValue_Traits<ProShade::SamplerNode::Binding>,LiOpenGLContextGetter>::get((uint64_t)this + 64);
  if ((v3 & 0x80000000) == 0) {
    *a2 = v3;
  }
  return v3 >= 0;
}

void ProShade::Sampler::Sampler(PCSharedCount *this)
{
  this->int var0 = (PC_Sp_counted_base *)&unk_1F11199B0;
  this[2].int var0 = 0;
  PCSharedCount::PCSharedCount(this + 3);
  this->int var0 = (PC_Sp_counted_base *)&unk_1F1119908;
  ProShade::Uniform::Uniform();
}

void sub_1B7A86E20(_Unwind_Exception *a1)
{
  v1[4].int var0 = (PC_Sp_counted_base *)&unk_1F1119970;
  PCSharedCount::~PCSharedCount(v1 + 7);
  v1->int var0 = v2;
  PCSharedCount::~PCSharedCount(v3);
  _Unwind_Resume(a1);
}

void ProShade::Sampler::Sampler(PCSharedCount *this, ProShade::SamplerNode *a2)
{
  ProShade::VarT<ProShade::SamplerNode>::VarT(this, a2)->int var0 = (PC_Sp_counted_base *)&unk_1F1119908;
  ProShade::Uniform::Uniform();
}

void sub_1B7A86F10(_Unwind_Exception *a1)
{
  v1[4].int var0 = (PC_Sp_counted_base *)&unk_1F1119970;
  PCSharedCount::~PCSharedCount(v1 + 7);
  v1->int var0 = (PC_Sp_counted_base *)&unk_1F11199B0;
  PCSharedCount::~PCSharedCount(v1 + 3);
  _Unwind_Resume(a1);
}

PCSharedCount *ProShade::VarT<ProShade::SamplerNode>::VarT(PCSharedCount *a1, PCShared_base *a2)
{
  a1->int var0 = (PC_Sp_counted_base *)&unk_1F11199B0;
  a1[2].int var0 = (PC_Sp_counted_base *)a2;
  if (a2) {
    a2 = (PCShared_base *)((char *)a2 + *(void *)(*(void *)a2 - 24));
  }
  PCSharedCount::PCSharedCount(a1 + 3, a2);
  return a1;
}

_DWORD *ProShade::Sampler::setTexture(ProShade::Sampler *this, int a2)
{
  uint64_t v3 = *((void *)this + 2);
  if (!v3) {
    throw_PCNullPointerException(1);
  }
  uint64_t result = (_DWORD *)LiPerContext<ProShade::SamplerNode::Binding,LiPerContextValue_Traits<ProShade::SamplerNode::Binding>,LiOpenGLContextGetter>::get(v3 + 64);
  *uint64_t result = a2;
  result[1] = a2;
  return result;
}

uint64_t ProShade::Sampler::setWrapMode(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3) {
    throw_PCNullPointerException(1);
  }
  uint64_t result = LiPerContext<ProShade::SamplerNode::Binding,LiPerContextValue_Traits<ProShade::SamplerNode::Binding>,LiOpenGLContextGetter>::get(v3 + 64);
  *(_DWORD *)(result + 8) = a2;
  return result;
}

void ProShade::Sampler::operator()()
{
}

void sub_1B7A870D0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C408AD29EEDLL);
  _Unwind_Resume(a1);
}

void ProShade::TextureFunc::TextureFunc(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 168) = &unk_1F1199AC8;
  *(void *)(a1 + 176) = 0;
  *(unsigned char *)(a1 + 184) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F111A688);
  *(void *)a1 = &unk_1F111A5B0;
  *(void *)(a1 + 168) = &unk_1F111A668;
  *(void *)(a1 + 48) = &unk_1F11199B0;
  *(unsigned char *)(a1 + LiDepthSorter::stackSort((uint64_t)this + 56) = *(unsigned char *)(a2 + 8);
  *(void *)(a1 + 64) = *(void *)(a2 + 16);
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 72), (const PCSharedCount *)(a2 + 24));
  ProShade::Texture::Texture((PCSharedCount *)(a1 + 80));
}

void sub_1B7A87294(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12)
{
  uint64_t v21 = v17;
  void *v15 = v21;
  PCSharedCount::~PCSharedCount(v20);
  *int v14 = v18;
  PCSharedCount::~PCSharedCount(v19);
  *(void *)(v12 + 80) = &unk_1F111A440;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(v12 + 96));
  *a11 = a10;
  PCSharedCount::~PCSharedCount(v16);
  ProShade::Node::~Node((ProShade::Node *)v12, (uint64_t *)&off_1F111A688);
  *(void *)(v12 + 168) = a12;
  *(unsigned char *)(v12 + 184) = 0;
  PCWeakCount::~PCWeakCount(v13);
  _Unwind_Resume(a1);
}

void sub_1B7A87334()
{
}

void ProShade::Sampler::sample(const PCSharedCount *a1, uint64_t a2)
{
  uint64_t v4 = &unk_1F11193B8;
  PCPtr<LiImageSource>::PCPtr<OZGradientSource>(&v5, a1 + 10);
  ProShade::operator*(v6, &v4, a2);
  ProShade::Selector_base::_select((uint64_t)&a1[5], (const PCString *)4);
}

void sub_1B7A87558(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, PCSharedCount a20,void *a21,uint64_t a22,uint64_t a23,PCSharedCount a24,void *a25,uint64_t a26,uint64_t a27,PCSharedCount a28)
{
  *(void *)(v31 - 128) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v30 + 3);
  PCSharedCount::~PCSharedCount(v29);
  a25 = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount(&a28);
  PCSharedCount::~PCSharedCount(v28);
  a21 = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount(&a24);
  PCSharedCount::~PCSharedCount(&a20);
  _Unwind_Resume(a1);
}

void sub_1B7A87624()
{
}

void sub_1B7A87630()
{
}

void sub_1B7A87638()
{
}

double ProShade::TextureFunc::setFrequency(ProShade::TextureFunc *this)
{
  uint64_t v1 = *((void *)this + 15);
  if (!v1) {
    throw_PCNullPointerException(1);
  }
  int v2 = *(_DWORD *)(v1 + 40);
  if (v2 == 2) {
    int v2 = 3;
  }
  *((_DWORD *)this + 10) = v2;
  *(void *)&double result = 0x400000003;
  *((void *)this + 3) = 0x400000003;
  return result;
}

PCSharedCount *ProShade::TextureFunc::TextureFunc(PCSharedCount *this, const ProShade::TextureFunc *a2)
{
  this[21].int var0 = (PC_Sp_counted_base *)&unk_1F1199AC8;
  this[22].int var0 = 0;
  LOBYTE(this[23].var0) = 1;
  ProShade::Node::Node((ProShade::Node *)this, (uint64_t *)&off_1F111A688);
  this->int var0 = (PC_Sp_counted_base *)&unk_1F111A5B0;
  this[21].int var0 = (PC_Sp_counted_base *)&unk_1F111A668;
  this[6].int var0 = (PC_Sp_counted_base *)&unk_1F11199B0;
  LOBYTE(this[7].var0) = *((unsigned char *)a2 + 56);
  this[8].int var0 = *(PC_Sp_counted_base **)((char *)a2 + 64);
  PCSharedCount::PCSharedCount(this + 9, (const PCSharedCount *)a2 + 9);
  uint64_t v4 = (PC_Sp_counted_base *)*((void *)a2 + 11);
  this[10].int var0 = (PC_Sp_counted_base *)&unk_1F111A440;
  this[11].int var0 = v4;
  PCSharedCount::PCSharedCount(this + 12, (const PCSharedCount *)a2 + 12);
  this[13].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  LOBYTE(this[14].var0) = *((unsigned char *)a2 + 112);
  this[15].int var0 = *(PC_Sp_counted_base **)((char *)a2 + 120);
  PCSharedCount::PCSharedCount(this + 16, (const PCSharedCount *)a2 + 16);
  this[17].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  this[19].int var0 = 0;
  PCSharedCount::PCSharedCount(this + 20);
  ProShade::TextureFunc::setFrequency((ProShade::TextureFunc *)this);
  return this;
}

void sub_1B7A8785C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, PCSharedCount *a10, uint64_t a11, void *a12, uint64_t a13, PC_Sp_counted_base **a14)
{
  void *v15 = v21;
  PCSharedCount::~PCSharedCount(v16);
  *uint64_t v18 = v22;
  PCSharedCount::~PCSharedCount(v23);
  *uint64_t v17 = v19;
  PCSharedCount::~PCSharedCount(v20);
  *a12 = a11;
  PCSharedCount::~PCSharedCount(a10);
  ProShade::Node::~Node((ProShade::Node *)v14, (uint64_t *)&off_1F111A688);
  *(void *)(v14 + 168) = a13;
  *(unsigned char *)(v14 + 184) = 0;
  PCWeakCount::~PCWeakCount(a14);
  _Unwind_Resume(a1);
}

void sub_1B7A878DC()
{
}

uint64_t ProShade::TextureFunc::TextureFunc(uint64_t a1, uint64_t a2, const PCSharedCount *a3, uint64_t a4)
{
  *(void *)(a1 + 168) = &unk_1F1199AC8;
  *(void *)(a1 + 176) = 0;
  *(unsigned char *)(a1 + 184) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F111A688);
  *(void *)a1 = &unk_1F111A5B0;
  *(void *)(a1 + 168) = &unk_1F111A668;
  BOOL v8 = *(const void **)(a2 + 16);
  if (v8) {
  else
  }
    size_t v9 = 0;
  ProShade::VarT<ProShade::SamplerNode>::VarT((PCSharedCount *)(a1 + 48), v9);
  int var0 = a3[1].var0;
  *(void *)(a1 + 80) = &unk_1F111A440;
  *(void *)(a1 + 88) = var0;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 96), a3 + 2);
  *(void *)(a1 + 104) = &unk_1F11193B8;
  *(unsigned char *)(a1 + 112) = *(unsigned char *)(a4 + 8);
  *(void *)(a1 + 120) = *(void *)(a4 + 16);
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 128), (const PCSharedCount *)(a4 + 24));
  *(void *)(a1 + 136) = &unk_1F11193B8;
  *(void *)(a1 + 152) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 160));
  ProShade::TextureFunc::setFrequency((ProShade::TextureFunc *)a1);
  return a1;
}

void sub_1B7A87AD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PC_Sp_counted_base **a12)
{
  uint64_t v22 = v16;
  *uint64_t v13 = v22;
  PCSharedCount::~PCSharedCount(v21);
  void *v15 = v19;
  PCSharedCount::~PCSharedCount(v20);
  *uint64_t v14 = v17;
  PCSharedCount::~PCSharedCount(v18);
  *(void *)(v12 + 48) = &unk_1F11199B0;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(v12 + 72));
  ProShade::Node::~Node((ProShade::Node *)v12, (uint64_t *)&off_1F111A688);
  *(void *)(v12 + 168) = a11;
  *(unsigned char *)(v12 + 184) = 0;
  PCWeakCount::~PCWeakCount(a12);
  _Unwind_Resume(a1);
}

void sub_1B7A87B6C()
{
}

uint64_t ProShade::TextureFunc::TextureFunc(uint64_t a1, uint64_t a2, const PCSharedCount *a3, uint64_t a4, uint64_t a5)
{
  *(void *)(a1 + 168) = &unk_1F1199AC8;
  *(void *)(a1 + 176) = 0;
  *(unsigned char *)(a1 + 184) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F111A688);
  *(void *)a1 = &unk_1F111A5B0;
  *(void *)(a1 + 168) = &unk_1F111A668;
  int v10 = *(const void **)(a2 + 16);
  if (v10) {
  else
  }
    int v11 = 0;
  ProShade::VarT<ProShade::SamplerNode>::VarT((PCSharedCount *)(a1 + 48), v11);
  int var0 = a3[1].var0;
  *(void *)(a1 + 80) = &unk_1F111A440;
  *(void *)(a1 + 88) = var0;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 96), a3 + 2);
  *(void *)(a1 + 104) = &unk_1F11193B8;
  *(unsigned char *)(a1 + 112) = *(unsigned char *)(a4 + 8);
  *(void *)(a1 + 120) = *(void *)(a4 + 16);
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 128), (const PCSharedCount *)(a4 + 24));
  *(void *)(a1 + 136) = &unk_1F11193B8;
  *(unsigned char *)(a1 + 144) = *(unsigned char *)(a5 + 8);
  *(void *)(a1 + 152) = *(void *)(a5 + 16);
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 160), (const PCSharedCount *)(a5 + 24));
  ProShade::TextureFunc::setFrequency((ProShade::TextureFunc *)a1);
  return a1;
}

void sub_1B7A87D78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, PC_Sp_counted_base **a12)
{
  void *v15 = v18;
  PCSharedCount::~PCSharedCount(v14);
  *uint64_t v13 = v19;
  PCSharedCount::~PCSharedCount(v20);
  *a9 = v16;
  PCSharedCount::~PCSharedCount(v17);
  *(void *)(v12 + 48) = &unk_1F11199B0;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(v12 + 72));
  ProShade::Node::~Node((ProShade::Node *)v12, (uint64_t *)&off_1F111A688);
  *(void *)(v12 + 168) = a11;
  *(unsigned char *)(v12 + 184) = 0;
  PCWeakCount::~PCWeakCount(a12);
  _Unwind_Resume(a1);
}

void sub_1B7A87E14()
{
}

void ProShade::TextureFunc::~TextureFunc(PCSharedCount *this, PC_Sp_counted_base **a2)
{
  uint64_t v4 = *a2;
  this->int var0 = *a2;
  *(PC_Sp_counted_base **)((char *)&this->var0 + *((void *)v4 - 3)) = a2[5];
  this[17].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(this + 20);
  this[13].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(this + 16);
  this[10].int var0 = (PC_Sp_counted_base *)&unk_1F111A440;
  PCSharedCount::~PCSharedCount(this + 12);
  this[6].int var0 = (PC_Sp_counted_base *)&unk_1F11199B0;
  PCSharedCount::~PCSharedCount(this + 9);
  PCSharedCount v5 = a2[1];
  this->int var0 = v5;
  *(PC_Sp_counted_base **)((char *)&this->var0 + *((void *)v5 - 3)) = a2[4];
  LiString::dec((LiString *)&this[4]);
}

void ProShade::TextureFunc::~TextureFunc(PCSharedCount *this)
{
  *(void *)(v1 + 168) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 184) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 176));
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)(v1 + 168) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 184) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 176));

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'ProShade::TextureFunc::~TextureFunc(ProShade::TextureFunc *this)
{
  *(void *)(v1 + 168) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 184) = 0;
  int v2 = (PC_Sp_counted_base **)(v1 + 176);

  PCWeakCount::~PCWeakCount(v2);
}

{
  ProShade::TextureFunc::~TextureFunc((PCSharedCount *)((char *)this + *(void *)(*(void *)this - 24)));
}

void ProShade::TextureFunc::repr(ProShade::TextureFunc *this@<X0>, const PCString *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *((void *)this + 8);
  std::locale v148 = a3;
  if (v5)
  {
    size_t v6 = (char *)this + 48;
    int v7 = *(_DWORD *)(v5 + 56);
    if (v7 == 34067)
    {
      if (*(unsigned char *)(v5 + 60))
      {
        ProShade::VarT<ProShade::SamplerNode>::repr((uint64_t)v6);
        int var0 = v151.var0;
        if (v151.var0) {
          int length = v151.var0[-1].length;
        }
        else {
          int length = 0;
        }
        uint64_t v31 = (char *)malloc_type_malloc(length + 24, 0x8903763CuLL);
        uint64_t v32 = length + 11;
        atomic_store(1u, (unsigned int *)v31);
        atomic_store(0, (unsigned int *)v31);
        *(void *)(v31 + 12) = *(void *)"shadowCube(";
        *((_DWORD *)v31 + 1) = v32;
        *((_DWORD *)v31 + 2) = length + 12;
        *(_DWORD *)(v31 + 19) = 677732981;
        memcpy(v31 + 23, var0, length);
        v31[v32 + 12] = 0;
        atomic_fetch_add((atomic_uint *volatile)v31, 1u);
        size_t v33 = *((int *)v31 + 1);
        int v34 = (unsigned int *)malloc_type_malloc(v33 + 15, 0x8903763CuLL);
        atomic_store(1u, v34);
        long long v35 = v34 + 3;
        atomic_store(0, v34);
        v34[1] = v33 + 2;
        _OWORD v34[2] = v33 + 3;
        memcpy(v34 + 3, v31 + 12, v33);
        *(_WORD *)&v35[v33] = 8236;
        v35[v33 + 2] = 0;
        atomic_fetch_add((atomic_uint *volatile)v34, 1u);
        uint64_t v36 = *((void *)this + 15);
        if (!v36) {
          throw_PCNullPointerException(1);
        }
        (*(void (**)(PCString *__return_ptr))(*(void *)v36 + 16))(&v150);
        size_t v37 = (int)v34[1];
        __int32 v38 = v150.var0;
        if (v150.var0) {
          int v39 = v150.var0[-1].length;
        }
        else {
          int v39 = 0;
        }
        size_t v47 = v37 + v39;
        __n128 v48 = (unsigned int *)malloc_type_malloc(v47 + 13, 0x8903763CuLL);
        v48[1] = v47;
        v48[2] = v47 + 1;
        atomic_store(1u, v48);
        atomic_store(0, v48);
        memcpy(v48 + 3, v35, v37);
        memcpy((char *)v48 + v37 + 12, v38, v39);
        *((unsigned char *)v48 + v47 + 12) = 0;
        atomic_fetch_add((atomic_uint *volatile)v48, 1u);
        size_t v49 = (int)v48[1];
        int v50 = (unsigned int *)malloc_type_malloc(v49 + 14, 0x8903763CuLL);
        atomic_store(1u, v50);
        int v51 = v50 + 3;
        atomic_store(0, v50);
        v50[1] = v49 + 1;
        float v50[2] = v49 + 2;
        memcpy(v50 + 3, v48 + 3, v49);
        *((unsigned char *)v51 + v49) = 41;
        *((unsigned char *)v51 + v49 + 1) = 0;
        *a3 = v50 + 3;
        atomic_fetch_add((atomic_uint *volatile)v50, 1u);
LABEL_49:
        if (atomic_fetch_add((atomic_uint *volatile)v48, 0xFFFFFFFF) == 1) {
          free(v48);
        }
        if (v150.var0 && atomic_fetch_add((atomic_uint *volatile)&v150.var0[-1].data + 1, 0xFFFFFFFF) == 1)
        {
          LOBYTE(v150.var0->isa) = 0;
          if (v150.var0) {
            int v56 = (char *)&v150.var0[-1].data + 4;
          }
          else {
            int v56 = 0;
          }
          free(v56);
        }
        if (atomic_fetch_add((atomic_uint *volatile)v34, 0xFFFFFFFF) == 1) {
          free(v34);
        }
        if (atomic_fetch_add((atomic_uint *volatile)v31, 0xFFFFFFFF) == 1)
        {
          char v57 = (atomic_uint *)v31;
LABEL_131:
          free(v57);
          goto LABEL_132;
        }
        goto LABEL_132;
      }
      if (!*(unsigned char *)(v5 + 61))
      {
        if (!*(unsigned char *)(v5 + 62))
        {
          ProShade::VarT<ProShade::SamplerNode>::repr((uint64_t)v6);
          double v112 = v151.var0;
          if (v151.var0) {
            int v113 = v151.var0[-1].length;
          }
          else {
            int v113 = 0;
          }
          uint64_t v31 = (char *)malloc_type_malloc(v113 + 25, 0x8903763CuLL);
          uint64_t v138 = v113 + 12;
          atomic_store(1u, (unsigned int *)v31);
          atomic_store(0, (unsigned int *)v31);
          *(void *)(v31 + 12) = *(void *)"textureCube(";
          *((_DWORD *)v31 + 1) = v138;
          *((_DWORD *)v31 + 2) = v113 + 13;
          *((_DWORD *)v31 + 5) = 677732981;
          memcpy(v31 + 24, v112, v113);
          v31[v138 + 12] = 0;
          atomic_fetch_add((atomic_uint *volatile)v31, 1u);
          size_t v139 = *((int *)v31 + 1);
          int v34 = (unsigned int *)malloc_type_malloc(v139 + 15, 0x8903763CuLL);
          atomic_store(1u, v34);
          uint64_t v42 = v34 + 3;
          atomic_store(0, v34);
          v34[1] = v139 + 2;
          _OWORD v34[2] = v139 + 3;
          memcpy(v34 + 3, v31 + 12, v139);
          *(_WORD *)&v42[v139] = 8236;
          v42[v139 + 2] = 0;
          atomic_fetch_add((atomic_uint *volatile)v34, 1u);
          uint64_t v140 = *((void *)this + 15);
          if (!v140) {
            throw_PCNullPointerException(1);
          }
          (*(void (**)(PCString *__return_ptr))(*(void *)v140 + 16))(&v150);
          size_t v44 = (int)v34[1];
          int v45 = v150.var0;
          if (v150.var0) {
            int v46 = v150.var0[-1].length;
          }
          else {
            int v46 = 0;
          }
          goto LABEL_48;
        }
        ProShade::VarT<ProShade::SamplerNode>::repr((uint64_t)v6);
        int v68 = v151.var0;
        if (v151.var0) {
          int v69 = v151.var0[-1].length;
        }
        else {
          int v69 = 0;
        }
        size_t v117 = (char *)malloc_type_malloc(v69 + 25, 0x8903763CuLL);
        uint64_t v118 = v69 + 12;
        atomic_store(1u, (unsigned int *)v117);
        atomic_store(0, (unsigned int *)v117);
        *(void *)(v117 + 12) = *(void *)"textureCube(";
        *((_DWORD *)v117 + 1) = v118;
        *((_DWORD *)v117 + 2) = v69 + 13;
        *((_DWORD *)v117 + 5) = 677732981;
        memcpy(v117 + 24, v68, v69);
        v117[v118 + 12] = 0;
        atomic_fetch_add((atomic_uint *volatile)v117, 1u);
        size_t v119 = *((int *)v117 + 1);
        PCSharedCount v147 = (atomic_uint *)v117;
        long long v120 = (unsigned int *)malloc_type_malloc(v119 + 15, 0x8903763CuLL);
        atomic_store(1u, v120);
        uint64_t v121 = v120 + 3;
        atomic_store(0, v120);
        v120[1] = v119 + 2;
        v120[2] = v119 + 3;
        memcpy(v120 + 3, v117 + 12, v119);
        *(_WORD *)&v121[v119] = 8236;
        v121[v119 + 2] = 0;
        atomic_fetch_add((atomic_uint *volatile)v120, 1u);
        uint64_t v122 = *((void *)this + 15);
        int8x16_t v144 = v120;
        if (!v122) {
          throw_PCNullPointerException(1);
        }
        (*(void (**)(PCString *__return_ptr))(*(void *)v122 + 16))(&v150);
        size_t v123 = (int)v120[1];
        long long v124 = v150.var0;
        if (v150.var0) {
          int v125 = v150.var0[-1].length;
        }
        else {
          int v125 = 0;
        }
        size_t v126 = v123 + v125;
        uint64_t v91 = (unsigned int *)malloc_type_malloc(v126 + 13, 0x8903763CuLL);
        v91[1] = v126;
        v91[2] = v126 + 1;
        atomic_store(1u, v91);
        atomic_store(0, v91);
        memcpy(v91 + 3, v121, v123);
        memcpy((char *)v91 + v123 + 12, v124, v125);
        *((unsigned char *)v91 + v126 + 12) = 0;
        atomic_fetch_add((atomic_uint *volatile)v91, 1u);
        size_t v127 = (int)v91[1];
        uint64_t v93 = (unsigned int *)malloc_type_malloc(v127 + 15, 0x8903763CuLL);
        atomic_store(1u, v93);
        long long v128 = v93 + 3;
        atomic_store(0, v93);
        v93[1] = v127 + 2;
        Vec2f v93[2] = v127 + 3;
        memcpy(v93 + 3, v91 + 3, v127);
        *(_WORD *)&v128[v127] = 8236;
        v128[v127 + 2] = 0;
        atomic_fetch_add((atomic_uint *volatile)v93, 1u);
        uint64_t v129 = *((void *)this + 19);
        if (!v129) {
          throw_PCNullPointerException(1);
        }
        (*(void (**)(unsigned char **__return_ptr))(*(void *)v129 + 16))(&v149);
        size_t v130 = (int)v93[1];
        unsigned int v131 = v149;
        if (v149) {
          int v132 = *((_DWORD *)v149 - 2);
        }
        else {
          int v132 = 0;
        }
        size_t v133 = v130 + v132;
        unsigned int v134 = (unsigned int *)malloc_type_malloc(v133 + 13, 0x8903763CuLL);
        v134[1] = v133;
        v134[2] = v133 + 1;
        atomic_store(1u, v134);
        atomic_store(0, v134);
        memcpy(v134 + 3, v128, v130);
        memcpy((char *)v134 + v130 + 12, v131, v132);
        *((unsigned char *)v134 + v133 + 12) = 0;
        atomic_fetch_add((atomic_uint *volatile)v134, 1u);
        size_t v135 = (int)v134[1];
        int v136 = (unsigned int *)malloc_type_malloc(v135 + 14, 0x8903763CuLL);
        atomic_store(1u, v136);
        int v137 = v136 + 3;
        atomic_store(0, v136);
        v136[1] = v135 + 1;
        v136[2] = v135 + 2;
        memcpy(v136 + 3, v134 + 3, v135);
        *((unsigned char *)v137 + v135) = 41;
        *((unsigned char *)v137 + v135 + 1) = 0;
        *std::locale v148 = v136 + 3;
        atomic_fetch_add((atomic_uint *volatile)v136, 1u);
        if (atomic_fetch_add((atomic_uint *volatile)v134, 0xFFFFFFFF) == 1) {
          free(v134);
        }
        uint64_t v108 = (atomic_uint *)v149;
        uint64_t v107 = v144;
        double v109 = v147;
        if (v149) {
          goto LABEL_112;
        }
        goto LABEL_117;
      }
      ProShade::VarT<ProShade::SamplerNode>::repr((uint64_t)v6);
      uint64_t v18 = v151.var0;
      if (v151.var0) {
        int v19 = v151.var0[-1].length;
      }
      else {
        int v19 = 0;
      }
      uint64_t v72 = (unsigned int *)malloc_type_malloc(v19 + 28, 0x8903763CuLL);
      uint64_t v73 = v19 + 15;
      atomic_store(1u, v72);
      atomic_store(0, v72);
      qmemcpy(v72 + 3, "textureCubeLod(", 15);
      v72[1] = v73;
      v72[2] = v19 + 16;
      memcpy((char *)v72 + 27, v18, v19);
      *((unsigned char *)v72 + v73 + 12) = 0;
      atomic_fetch_add((atomic_uint *volatile)v72, 1u);
      size_t v74 = (int)v72[1];
      int8x16_t v146 = v72;
      int v75 = (unsigned int *)malloc_type_malloc(v74 + 15, 0x8903763CuLL);
      atomic_store(1u, v75);
      uint64_t v76 = v75 + 3;
      atomic_store(0, v75);
      v75[1] = v74 + 2;
      v75[2] = v74 + 3;
      memcpy(v75 + 3, v72 + 3, v74);
      *(_WORD *)&v76[v74] = 8236;
      v76[v74 + 2] = 0;
      atomic_fetch_add((atomic_uint *volatile)v75, 1u);
      uint64_t v77 = *((void *)this + 15);
      float64x2_t v143 = v75;
      if (!v77) {
        throw_PCNullPointerException(1);
      }
      (*(void (**)(PCString *__return_ptr))(*(void *)v77 + 16))(&v150);
      size_t v78 = (int)v75[1];
      double v79 = v150.var0;
      if (v150.var0) {
        int v80 = v150.var0[-1].length;
      }
      else {
        int v80 = 0;
      }
      size_t v90 = v78 + v80;
      uint64_t v91 = (unsigned int *)malloc_type_malloc(v90 + 13, 0x8903763CuLL);
      v91[1] = v90;
      v91[2] = v90 + 1;
      atomic_store(1u, v91);
      atomic_store(0, v91);
      memcpy(v91 + 3, v76, v78);
      memcpy((char *)v91 + v78 + 12, v79, v80);
      *((unsigned char *)v91 + v90 + 12) = 0;
      atomic_fetch_add((atomic_uint *volatile)v91, 1u);
      size_t v92 = (int)v91[1];
      uint64_t v93 = (unsigned int *)malloc_type_malloc(v92 + 15, 0x8903763CuLL);
      atomic_store(1u, v93);
      double v94 = v93 + 3;
      atomic_store(0, v93);
      v93[1] = v92 + 2;
      Vec2f v93[2] = v92 + 3;
      memcpy(v93 + 3, v91 + 3, v92);
      *(_WORD *)&v94[v92] = 8236;
      v94[v92 + 2] = 0;
      atomic_fetch_add((atomic_uint *volatile)v93, 1u);
      uint64_t v95 = *((void *)this + 19);
      if (!v95) {
        throw_PCNullPointerException(1);
      }
      (*(void (**)(unsigned char **__return_ptr))(*(void *)v95 + 16))(&v149);
      size_t v96 = (int)v93[1];
      double v97 = v149;
      if (v149) {
        int v98 = *((_DWORD *)v149 - 2);
      }
      else {
        int v98 = 0;
      }
    }
    else
    {
      if (v7 != 3553)
      {
        exception = (PCException *)__cxa_allocate_exception(0x40uLL);
        PCString::PCString(&v151, "not implemented yet");
        PCString::PCString(&v150, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/Shading/PSTexture.cpp");
        PCException::PCException(exception, &v151, &v150, 286);
        *(void *)exception = &unk_1F10B1208;
      }
      if (*(unsigned char *)(v5 + 60))
      {
        ProShade::VarT<ProShade::SamplerNode>::repr((uint64_t)v6);
        BOOL v8 = v151.var0;
        if (v151.var0) {
          int v9 = v151.var0[-1].length;
        }
        else {
          int v9 = 0;
        }
        uint64_t v31 = (char *)malloc_type_malloc(v9 + 22, 0x8903763CuLL);
        uint64_t v40 = v9 + 9;
        atomic_store(1u, (unsigned int *)v31);
        atomic_store(0, (unsigned int *)v31);
        *(void *)(v31 + 12) = *(void *)"shadow2D(";
        *((_DWORD *)v31 + 1) = v40;
        *((_DWORD *)v31 + 2) = v9 + 10;
        v31[20] = 40;
        memcpy(v31 + 21, v8, v9);
        v31[v40 + 12] = 0;
        atomic_fetch_add((atomic_uint *volatile)v31, 1u);
        size_t v41 = *((int *)v31 + 1);
        int v34 = (unsigned int *)malloc_type_malloc(v41 + 15, 0x8903763CuLL);
        atomic_store(1u, v34);
        uint64_t v42 = v34 + 3;
        atomic_store(0, v34);
        v34[1] = v41 + 2;
        _OWORD v34[2] = v41 + 3;
        memcpy(v34 + 3, v31 + 12, v41);
        *(_WORD *)&v42[v41] = 8236;
        v42[v41 + 2] = 0;
        atomic_fetch_add((atomic_uint *volatile)v34, 1u);
        uint64_t v43 = *((void *)this + 15);
        if (!v43) {
          throw_PCNullPointerException(1);
        }
        (*(void (**)(PCString *__return_ptr))(*(void *)v43 + 16))(&v150);
        size_t v44 = (int)v34[1];
        int v45 = v150.var0;
        if (v150.var0) {
          int v46 = v150.var0[-1].length;
        }
        else {
          int v46 = 0;
        }
LABEL_48:
        size_t v52 = v44 + v46;
        __n128 v48 = (unsigned int *)malloc_type_malloc(v52 + 13, 0x8903763CuLL);
        v48[1] = v52;
        v48[2] = v52 + 1;
        atomic_store(1u, v48);
        atomic_store(0, v48);
        memcpy(v48 + 3, v42, v44);
        memcpy((char *)v48 + v44 + 12, v45, v46);
        *((unsigned char *)v48 + v52 + 12) = 0;
        atomic_fetch_add((atomic_uint *volatile)v48, 1u);
        size_t v53 = (int)v48[1];
        int v54 = (unsigned int *)malloc_type_malloc(v53 + 14, 0x8903763CuLL);
        void v54[2] = v53 + 2;
        atomic_store(1u, v54);
        int v55 = v54 + 3;
        atomic_store(0, v54);
        v54[1] = v53 + 1;
        memcpy(v54 + 3, v48 + 3, v53);
        *((unsigned char *)v55 + v53) = 41;
        *((unsigned char *)v55 + v53 + 1) = 0;
        *std::locale v148 = v54 + 3;
        atomic_fetch_add((atomic_uint *volatile)v54, 1u);
        goto LABEL_49;
      }
      if (*(unsigned char *)(v5 + 61))
      {
        int8x16_t v142 = (PCException *)__cxa_allocate_exception(0x40uLL);
        PCString::PCString(&v151, "not implemented yet");
        PCString::PCString(&v150, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/Shading/PSTexture.cpp");
        PCException::PCException(v142, &v151, &v150, 269);
        *(void *)int8x16_t v142 = &unk_1F10B1208;
      }
      if (!*(unsigned char *)(v5 + 62))
      {
        ProShade::VarT<ProShade::SamplerNode>::repr((uint64_t)v6);
        double v70 = v151.var0;
        if (v151.var0) {
          int v71 = v151.var0[-1].length;
        }
        else {
          int v71 = 0;
        }
        uint64_t v31 = (char *)malloc_type_malloc(v71 + 23, 0x8903763CuLL);
        uint64_t v114 = v71 + 10;
        atomic_store(1u, (unsigned int *)v31);
        atomic_store(0, (unsigned int *)v31);
        *(void *)(v31 + 12) = *(void *)"texture2D(";
        *((_DWORD *)v31 + 1) = v114;
        *((_DWORD *)v31 + 2) = v71 + 11;
        *((_WORD *)v31 + 10) = 10308;
        memcpy(v31 + 22, v70, v71);
        v31[v114 + 12] = 0;
        atomic_fetch_add((atomic_uint *volatile)v31, 1u);
        size_t v115 = *((int *)v31 + 1);
        int v34 = (unsigned int *)malloc_type_malloc(v115 + 15, 0x8903763CuLL);
        atomic_store(1u, v34);
        uint64_t v42 = v34 + 3;
        atomic_store(0, v34);
        v34[1] = v115 + 2;
        _OWORD v34[2] = v115 + 3;
        memcpy(v34 + 3, v31 + 12, v115);
        *(_WORD *)&v42[v115] = 8236;
        v42[v115 + 2] = 0;
        atomic_fetch_add((atomic_uint *volatile)v34, 1u);
        uint64_t v116 = *((void *)this + 15);
        if (!v116) {
          throw_PCNullPointerException(1);
        }
        (*(void (**)(PCString *__return_ptr))(*(void *)v116 + 16))(&v150);
        size_t v44 = (int)v34[1];
        int v45 = v150.var0;
        if (v150.var0) {
          int v46 = v150.var0[-1].length;
        }
        else {
          int v46 = 0;
        }
        goto LABEL_48;
      }
      ProShade::VarT<ProShade::SamplerNode>::repr((uint64_t)v6);
      __int32 v20 = v151.var0;
      if (v151.var0) {
        int v21 = v151.var0[-1].length;
      }
      else {
        int v21 = 0;
      }
      size_t v81 = (char *)malloc_type_malloc(v21 + 23, 0x8903763CuLL);
      uint64_t v82 = v21 + 10;
      atomic_store(1u, (unsigned int *)v81);
      atomic_store(0, (unsigned int *)v81);
      *(void *)(v81 + 12) = *(void *)"texture2D(";
      *((_DWORD *)v81 + 1) = v82;
      *((_DWORD *)v81 + 2) = v21 + 11;
      *((_WORD *)v81 + 10) = 10308;
      memcpy(v81 + 22, v20, v21);
      v81[v82 + 12] = 0;
      atomic_fetch_add((atomic_uint *volatile)v81, 1u);
      size_t v83 = *((int *)v81 + 1);
      int8x16_t v146 = (unsigned int *)v81;
      size_t v84 = (unsigned int *)malloc_type_malloc(v83 + 15, 0x8903763CuLL);
      atomic_store(1u, v84);
      double v85 = v84 + 3;
      atomic_store(0, v84);
      v84[1] = v83 + 2;
      v84[2] = v83 + 3;
      memcpy(v84 + 3, v81 + 12, v83);
      *(_WORD *)&v85[v83] = 8236;
      v85[v83 + 2] = 0;
      atomic_fetch_add((atomic_uint *volatile)v84, 1u);
      uint64_t v86 = *((void *)this + 15);
      float64x2_t v143 = v84;
      if (!v86) {
        throw_PCNullPointerException(1);
      }
      (*(void (**)(PCString *__return_ptr))(*(void *)v86 + 16))(&v150);
      size_t v87 = (int)v84[1];
      double v88 = v150.var0;
      if (v150.var0) {
        int v89 = v150.var0[-1].length;
      }
      else {
        int v89 = 0;
      }
      size_t v99 = v87 + v89;
      uint64_t v91 = (unsigned int *)malloc_type_malloc(v99 + 13, 0x8903763CuLL);
      v91[1] = v99;
      v91[2] = v99 + 1;
      atomic_store(1u, v91);
      atomic_store(0, v91);
      memcpy(v91 + 3, v85, v87);
      memcpy((char *)v91 + v87 + 12, v88, v89);
      *((unsigned char *)v91 + v99 + 12) = 0;
      atomic_fetch_add((atomic_uint *volatile)v91, 1u);
      size_t v100 = (int)v91[1];
      uint64_t v93 = (unsigned int *)malloc_type_malloc(v100 + 15, 0x8903763CuLL);
      atomic_store(1u, v93);
      double v94 = v93 + 3;
      atomic_store(0, v93);
      v93[1] = v100 + 2;
      Vec2f v93[2] = v100 + 3;
      memcpy(v93 + 3, v91 + 3, v100);
      *(_WORD *)&v94[v100] = 8236;
      v94[v100 + 2] = 0;
      atomic_fetch_add((atomic_uint *volatile)v93, 1u);
      uint64_t v101 = *((void *)this + 19);
      if (!v101) {
        throw_PCNullPointerException(1);
      }
      (*(void (**)(unsigned char **__return_ptr))(*(void *)v101 + 16))(&v149);
      size_t v96 = (int)v93[1];
      double v97 = v149;
      if (v149) {
        int v98 = *((_DWORD *)v149 - 2);
      }
      else {
        int v98 = 0;
      }
    }
    size_t v102 = v96 + v98;
    double v103 = (unsigned int *)malloc_type_malloc(v102 + 13, 0x8903763CuLL);
    v103[1] = v102;
    v103[2] = v102 + 1;
    atomic_store(1u, v103);
    atomic_store(0, v103);
    memcpy(v103 + 3, v94, v96);
    memcpy((char *)v103 + v96 + 12, v97, v98);
    *((unsigned char *)v103 + v102 + 12) = 0;
    atomic_fetch_add((atomic_uint *volatile)v103, 1u);
    size_t v104 = (int)v103[1];
    double v105 = (unsigned int *)malloc_type_malloc(v104 + 14, 0x8903763CuLL);
    v105[2] = v104 + 2;
    atomic_store(1u, v105);
    uint64_t v106 = v105 + 3;
    atomic_store(0, v105);
    v105[1] = v104 + 1;
    memcpy(v105 + 3, v103 + 3, v104);
    *((unsigned char *)v106 + v104) = 41;
    *((unsigned char *)v106 + v104 + 1) = 0;
    *std::locale v148 = v105 + 3;
    atomic_fetch_add((atomic_uint *volatile)v105, 1u);
    uint64_t v107 = v143;
    if (atomic_fetch_add((atomic_uint *volatile)v103, 0xFFFFFFFF) == 1) {
      free(v103);
    }
    uint64_t v108 = (atomic_uint *)v149;
    double v109 = (atomic_uint *)v146;
    if (v149)
    {
LABEL_112:
      if (atomic_fetch_add(v108 - 3, 0xFFFFFFFF) == 1)
      {
        *float32x4_t v149 = 0;
        if (v149) {
          uint64_t v110 = v149 - 12;
        }
        else {
          uint64_t v110 = 0;
        }
        free(v110);
      }
    }
LABEL_117:
    if (atomic_fetch_add((atomic_uint *volatile)v93, 0xFFFFFFFF) == 1) {
      free(v93);
    }
    if (atomic_fetch_add((atomic_uint *volatile)v91, 0xFFFFFFFF) == 1) {
      free(v91);
    }
    if (v150.var0 && atomic_fetch_add((atomic_uint *volatile)&v150.var0[-1].data + 1, 0xFFFFFFFF) == 1)
    {
      LOBYTE(v150.var0->isa) = 0;
      if (v150.var0) {
        uint64_t v111 = (char *)&v150.var0[-1].data + 4;
      }
      else {
        uint64_t v111 = 0;
      }
      free(v111);
    }
    if (atomic_fetch_add((atomic_uint *volatile)v107, 0xFFFFFFFF) == 1) {
      free(v107);
    }
    if (atomic_fetch_add(v109, 0xFFFFFFFF) == 1)
    {
      char v57 = v109;
      goto LABEL_131;
    }
LABEL_132:
    if (v151.var0 && atomic_fetch_add((atomic_uint *volatile)&v151.var0[-1].data + 1, 0xFFFFFFFF) == 1)
    {
      LOBYTE(v151.var0->isa) = 0;
      if (v151.var0) {
        uint64_t v67 = (atomic_uint *)&v151.var0[-1].data + 1;
      }
      else {
        uint64_t v67 = 0;
      }
      goto LABEL_137;
    }
    return;
  }
  uint64_t v10 = *((void *)this + 11);
  if (!v10) {
    throw_PCNullPointerException(1);
  }
  int v11 = *(atomic_uint **)(v10 + 8);
  if (v11) {
    atomic_fetch_add(v11 - 3, 1u);
  }
  uint64_t v12 = *((void *)this + 15);
  int8x16_t v145 = v11;
  if (!v12) {
    throw_PCNullPointerException(1);
  }
  int v13 = *(_DWORD *)(v12 + 28);
  if ((v13 - 3) >= 2)
  {
    if (v13 != 2) {
      ProShade::Error<PCException>::raise<char [27]>((OZChannelBase *)"illegal texture coordinate", a2);
    }
    if (v11) {
      int v17 = *(v11 - 2);
    }
    else {
      int v17 = 0;
    }
    uint64_t v22 = (char *)malloc_type_malloc(v17 + 23, 0x8903763CuLL);
    uint64_t v58 = v17 + 10;
    atomic_store(1u, (unsigned int *)v22);
    atomic_store(0, (unsigned int *)v22);
    *(void *)(v22 + 12) = *(void *)"texture2D(";
    *((_DWORD *)v22 + 1) = v58;
    *((_DWORD *)v22 + 2) = v17 + 11;
    *((_WORD *)v22 + 10) = 10308;
    memcpy(v22 + 22, v11, v17);
    v22[v58 + 12] = 0;
    atomic_fetch_add((atomic_uint *volatile)v22, 1u);
    size_t v59 = *((int *)v22 + 1);
    __int32 v25 = (unsigned int *)malloc_type_malloc(v59 + 15, 0x8903763CuLL);
    atomic_store(1u, v25);
    __int32 v26 = v25 + 3;
    atomic_store(0, v25);
    v25[1] = v59 + 2;
    v25[2] = v59 + 3;
    memcpy(v25 + 3, v22 + 12, v59);
    *(_WORD *)&v26[v59] = 8236;
    v26[v59 + 2] = 0;
    atomic_fetch_add((atomic_uint *volatile)v25, 1u);
    uint64_t v60 = *((void *)this + 15);
    if (!v60) {
      throw_PCNullPointerException(1);
    }
    (*(void (**)(PCString *__return_ptr))(*(void *)v60 + 16))(&v151);
    size_t v28 = (int)v25[1];
    int v29 = v151.var0;
    if (v151.var0) {
      int v30 = v151.var0[-1].length;
    }
    else {
      int v30 = 0;
    }
  }
  else
  {
    if (v11) {
      int v14 = *(v11 - 2);
    }
    else {
      int v14 = 0;
    }
    uint64_t v22 = (char *)malloc_type_malloc(v14 + 27, 0x8903763CuLL);
    uint64_t v23 = v14 + 14;
    atomic_store(1u, (unsigned int *)v22);
    atomic_store(0, (unsigned int *)v22);
    qmemcpy(v22 + 12, "texture2DProj(", 14);
    *((_DWORD *)v22 + 1) = v23;
    *((_DWORD *)v22 + 2) = v14 + 15;
    memcpy(v22 + 26, v11, v14);
    v22[v23 + 12] = 0;
    atomic_fetch_add((atomic_uint *volatile)v22, 1u);
    size_t v24 = *((int *)v22 + 1);
    __int32 v25 = (unsigned int *)malloc_type_malloc(v24 + 15, 0x8903763CuLL);
    atomic_store(1u, v25);
    __int32 v26 = v25 + 3;
    atomic_store(0, v25);
    v25[1] = v24 + 2;
    v25[2] = v24 + 3;
    memcpy(v25 + 3, v22 + 12, v24);
    *(_WORD *)&v26[v24] = 8236;
    v26[v24 + 2] = 0;
    atomic_fetch_add((atomic_uint *volatile)v25, 1u);
    uint64_t v27 = *((void *)this + 15);
    if (!v27) {
      throw_PCNullPointerException(1);
    }
    (*(void (**)(PCString *__return_ptr))(*(void *)v27 + 16))(&v151);
    size_t v28 = (int)v25[1];
    int v29 = v151.var0;
    if (v151.var0) {
      int v30 = v151.var0[-1].length;
    }
    else {
      int v30 = 0;
    }
  }
  size_t v61 = v28 + v30;
  uint64_t v62 = (unsigned int *)malloc_type_malloc(v61 + 13, 0x8903763CuLL);
  v62[1] = v61;
  v62[2] = v61 + 1;
  atomic_store(1u, v62);
  atomic_store(0, v62);
  memcpy(v62 + 3, v26, v28);
  memcpy((char *)v62 + v28 + 12, v29, v30);
  *((unsigned char *)v62 + v61 + 12) = 0;
  atomic_fetch_add((atomic_uint *volatile)v62, 1u);
  size_t v63 = (int)v62[1];
  uint64_t v64 = (unsigned int *)malloc_type_malloc(v63 + 14, 0x8903763CuLL);
  v64[2] = v63 + 2;
  atomic_store(1u, v64);
  uint64_t v65 = v64 + 3;
  atomic_store(0, v64);
  v64[1] = v63 + 1;
  memcpy(v64 + 3, v62 + 3, v63);
  *((unsigned char *)v65 + v63) = 41;
  *((unsigned char *)v65 + v63 + 1) = 0;
  *std::locale v148 = v64 + 3;
  atomic_fetch_add((atomic_uint *volatile)v64, 1u);
  if (atomic_fetch_add((atomic_uint *volatile)v62, 0xFFFFFFFF) == 1) {
    free(v62);
  }
  if (v151.var0 && atomic_fetch_add((atomic_uint *volatile)&v151.var0[-1].data + 1, 0xFFFFFFFF) == 1)
  {
    LOBYTE(v151.var0->isa) = 0;
    if (v151.var0) {
      int v66 = (char *)&v151.var0[-1].data + 4;
    }
    else {
      int v66 = 0;
    }
    free(v66);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v25, 0xFFFFFFFF) == 1) {
    free(v25);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v22, 0xFFFFFFFF) == 1) {
    free(v22);
  }
  if (v145)
  {
    uint64_t v67 = v145 - 3;
    if (atomic_fetch_add(v145 - 3, 0xFFFFFFFF) == 1)
    {
      *(unsigned char *)int8x16_t v145 = 0;
LABEL_137:
      free(v67);
    }
  }
}

void sub_1B7A8982C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, PCString a13, PCString a14)
{
  if (atomic_fetch_add((atomic_uint *volatile)v14, 0xFFFFFFFF) == 1) {
    free(v14);
  }
  if (a13.var0 && atomic_fetch_add((atomic_uint *volatile)&a13.var0[-1].data + 1, 0xFFFFFFFF) == 1)
  {
    LOBYTE(a13.var0->isa) = 0;
    free((char *)&a13.var0[-1].data + 4);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v16, 0xFFFFFFFF) == 1) {
    free(v16);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v15, 0xFFFFFFFF) == 1) {
    free(v15);
  }
  if (a14.var0)
  {
    if (atomic_fetch_add((atomic_uint *volatile)&a14.var0[-1].data + 1, 0xFFFFFFFF) == 1)
    {
      LOBYTE(a14.var0->isa) = 0;
      free((char *)&a14.var0[-1].data + 4);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t ProShade::VarT<ProShade::SamplerNode>::repr(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    throw_PCNullPointerException(1);
  }
  int v2 = *(uint64_t (**)(void))(*(void *)v1 + 160);

  return v2();
}

void ProShade::Error<PCException>::raise<char [27]>(OZChannelBase *a1, const PCString *a2)
{
  OZChannelBase::setRangeName(a1, a2);
  exception = (PCException *)__cxa_allocate_exception(0x40uLL);
  PCString::PCString(&v4, (const char *)a1);
  PCException::PCException(exception, &v4);
}

void sub_1B7A89CB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void ProShade::TextureFunc::description(ProShade::TextureFunc *this@<X0>, void *a2@<X8>)
{
  if (*((void *)this + 19))
  {
    uint64_t v4 = *((void *)this + 15);
    if (!v4) {
      throw_PCNullPointerException(1);
    }
    (*(void (**)(unsigned char **__return_ptr))(*(void *)v4 + 24))(&v33);
    uint64_t v5 = v33;
    if (v33) {
      int v6 = *((_DWORD *)v33 - 2);
    }
    else {
      int v6 = 0;
    }
    uint64_t v10 = (char *)malloc_type_malloc(v6 + 25, 0x8903763CuLL);
    uint64_t v11 = v6 + 12;
    atomic_store(1u, (unsigned int *)v10);
    atomic_store(0, (unsigned int *)v10);
    *(void *)(v10 + 12) = *(void *)"TextureFunc(";
    *((_DWORD *)v10 + 1) = v11;
    *((_DWORD *)v10 + 2) = v6 + 13;
    *((_DWORD *)v10 + 5) = 677604981;
    memcpy(v10 + 24, v5, v6);
    v10[v11 + 12] = 0;
    atomic_fetch_add((atomic_uint *volatile)v10, 1u);
    size_t v12 = *((int *)v10 + 1);
    int v13 = (unsigned int *)malloc_type_malloc(v12 + 15, 0x8903763CuLL);
    atomic_store(1u, v13);
    int v14 = v13 + 3;
    atomic_store(0, v13);
    v13[1] = v12 + 2;
    float64x2_t v13[2] = v12 + 3;
    memcpy(v13 + 3, v10 + 12, v12);
    *(_WORD *)&v14[v12] = 8236;
    v14[v12 + 2] = 0;
    atomic_fetch_add((atomic_uint *volatile)v13, 1u);
    uint64_t v15 = *((void *)this + 19);
    if (!v15) {
      throw_PCNullPointerException(1);
    }
    (*(void (**)(unsigned char **__return_ptr))(*(void *)v15 + 24))(&v32);
    size_t v16 = (int)v13[1];
    int v17 = v32;
    if (v32) {
      int v18 = *((_DWORD *)v32 - 2);
    }
    else {
      int v18 = 0;
    }
    uint64_t v31 = a2;
    size_t v19 = v16 + v18;
    __int32 v20 = (unsigned int *)malloc_type_malloc(v19 + 13, 0x8903763CuLL);
    v20[1] = v19;
    float32x2_t v20[2] = v19 + 1;
    atomic_store(1u, v20);
    atomic_store(0, v20);
    memcpy(v20 + 3, v14, v16);
    memcpy((char *)v20 + v16 + 12, v17, v18);
    *((unsigned char *)v20 + v19 + 12) = 0;
    atomic_fetch_add((atomic_uint *volatile)v20, 1u);
    size_t v21 = (int)v20[1];
    uint64_t v22 = (unsigned int *)malloc_type_malloc(v21 + 14, 0x8903763CuLL);
    atomic_store(1u, v22);
    uint64_t v23 = v22 + 3;
    atomic_store(0, v22);
    v22[1] = v21 + 1;
    v22[2] = v21 + 2;
    memcpy(v22 + 3, v20 + 3, v21);
    *((unsigned char *)v23 + v21) = 41;
    *((unsigned char *)v23 + v21 + 1) = 0;
    *uint64_t v31 = v22 + 3;
    atomic_fetch_add((atomic_uint *volatile)v22, 1u);
    if (atomic_fetch_add((atomic_uint *volatile)v20, 0xFFFFFFFF) == 1) {
      free(v20);
    }
    if (v32 && atomic_fetch_add((atomic_uint *volatile)v32 - 3, 0xFFFFFFFF) == 1)
    {
      *uint64_t v32 = 0;
      if (v32) {
        size_t v24 = v32 - 12;
      }
      else {
        size_t v24 = 0;
      }
      free(v24);
    }
    if (atomic_fetch_add((atomic_uint *volatile)v13, 0xFFFFFFFF) == 1) {
      free(v13);
    }
    unsigned int add = atomic_fetch_add((atomic_uint *volatile)v10, 0xFFFFFFFF);
  }
  else
  {
    uint64_t v7 = *((void *)this + 15);
    if (!v7) {
      throw_PCNullPointerException(1);
    }
    (*(void (**)(unsigned char **__return_ptr))(*(void *)v7 + 24))(&v33);
    BOOL v8 = v33;
    if (v33) {
      int v9 = *((_DWORD *)v33 - 2);
    }
    else {
      int v9 = 0;
    }
    uint64_t v10 = (char *)malloc_type_malloc(v9 + 25, 0x8903763CuLL);
    uint64_t v26 = v9 + 12;
    atomic_store(1u, (unsigned int *)v10);
    atomic_store(0, (unsigned int *)v10);
    *(void *)(v10 + 12) = *(void *)"TextureFunc(";
    *((_DWORD *)v10 + 1) = v26;
    *((_DWORD *)v10 + 2) = v9 + 13;
    *((_DWORD *)v10 + 5) = 677604981;
    memcpy(v10 + 24, v8, v9);
    v10[v26 + 12] = 0;
    atomic_fetch_add((atomic_uint *volatile)v10, 1u);
    size_t v27 = *((int *)v10 + 1);
    size_t v28 = (unsigned int *)malloc_type_malloc(v27 + 14, 0x8903763CuLL);
    atomic_store(1u, v28);
    int v29 = v28 + 3;
    atomic_store(0, v28);
    v28[1] = v27 + 1;
    v28[2] = v27 + 2;
    memcpy(v28 + 3, v10 + 12, v27);
    *((unsigned char *)v29 + v27) = 41;
    *((unsigned char *)v29 + v27 + 1) = 0;
    *a2 = v28 + 3;
    atomic_fetch_add((atomic_uint *volatile)v28, 1u);
    unsigned int add = atomic_fetch_add((atomic_uint *volatile)v10, 0xFFFFFFFF);
  }
  if (add == 1) {
    free(v10);
  }
  if (v33 && atomic_fetch_add((atomic_uint *volatile)v33 - 3, 0xFFFFFFFF) == 1)
  {
    unsigned char *v33 = 0;
    if (v33) {
      int v30 = v33 - 12;
    }
    else {
      int v30 = 0;
    }
    free(v30);
  }
}

void sub_1B7A8A118(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, atomic_uint *a12)
{
  if (atomic_fetch_add((atomic_uint *volatile)v12, 0xFFFFFFFF) == 1) {
    free(v12);
  }
  if (a12)
  {
    if (atomic_fetch_add(a12 - 3, 0xFFFFFFFF) == 1)
    {
      *(unsigned char *)a12 = 0;
      free(a12 - 3);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t ProShade::TextureFunc::computeHash(ProShade::TextureFunc *this, int8x8_t *a2)
{
  PCHashWriteStream::writeValue(a2, "TextureFunc");
  if (*((void *)this + 8)) {
    ProShade::VarT<ProShade::SamplerNode>::computeHash((uint64_t)this + 48);
  }
  else {
    ProShade::Texture::computeHash((ProShade::TextureFunc *)((char *)this + 80), a2);
  }
  uint64_t v4 = *((void *)this + 15);
  if (!v4) {
    throw_PCNullPointerException(1);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, int8x8_t *))(*(void *)v4 + 56))(v4, a2);
  if (*((void *)this + 19))
  {
    return ProShade::VarT<ProShade::SamplerNode>::computeHash((uint64_t)this + 136);
  }
  return result;
}

uint64_t ProShade::VarT<ProShade::SamplerNode>::computeHash(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    throw_PCNullPointerException(1);
  }
  int v2 = *(uint64_t (**)(void))(*(void *)v1 + 56);

  return v2();
}

uint64_t ProShade::TextureFunc::inputs(const PCSharedCount *a1, uint64_t a2)
{
  if (*(int *)(a2 + 8) < 0) {
    int v4 = 1;
  }
  else {
    int v4 = *(_DWORD *)(a2 + 8);
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a2, 0, v4);
  if (a1[8].var0)
  {
    v13.int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
    PCPtr<LiImageSource>::PCPtr<OZGradientSource>(&v14, a1 + 8);
    int v5 = *(_DWORD *)(a2 + 12);
    if (*(_DWORD *)(a2 + 8) <= v5) {
      int v6 = (2 * (v5 + 1)) | 1;
    }
    else {
      int v6 = *(_DWORD *)(a2 + 8);
    }
    PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a2, v5 + 1, v6);
    ProShade::VarT<ProShade::Node>::operator=(*(void *)(a2 + 16) + 32 * *(int *)(a2 + 12) - 32, &v13);
    v13.int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
    PCSharedCount::~PCSharedCount(&v15);
  }
  int v7 = *(_DWORD *)(a2 + 12);
  if (*(_DWORD *)(a2 + 8) <= v7) {
    int v8 = (2 * (v7 + 1)) | 1;
  }
  else {
    int v8 = *(_DWORD *)(a2 + 8);
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a2, v7 + 1, v8);
  uint64_t result = ProShade::VarT<ProShade::Node>::operator=(*(void *)(a2 + 16) + 32 * *(int *)(a2 + 12) - 32, a1 + 13);
  if (a1[19].var0)
  {
    uint64_t v10 = a1 + 17;
    int v11 = *(_DWORD *)(a2 + 12);
    if (*(_DWORD *)(a2 + 8) <= v11) {
      int v12 = (2 * (v11 + 1)) | 1;
    }
    else {
      int v12 = *(_DWORD *)(a2 + 8);
    }
    PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a2, v11 + 1, v12);
    return ProShade::VarT<ProShade::Node>::operator=(*(void *)(a2 + 16) + 32 * *(int *)(a2 + 12) - 32, v10);
  }
  return result;
}

void sub_1B7A8A480(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1 + 3);
  _Unwind_Resume(a1);
}

void ProShade::TextureFunc::apply(PCSharedCount *a1@<X0>, void (***a2)(void *__return_ptr, void, void)@<X1>, PCSharedCount *a3@<X8>)
{
  size_t v16 = &unk_1F11193B8;
  int v17 = 0;
  PCSharedCount::PCSharedCount(&v18);
  if (a1[8].var0)
  {
    v11[0] = &unk_1F11193B8;
    PCPtr<LiImageSource>::PCPtr<OZGradientSource>(&v12, a1 + 8);
    (**a2)(v14, a2, v11);
    ProShade::VarT<ProShade::Node>::operator=((uint64_t)&v16, v14);
    v14[0].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
    PCSharedCount::~PCSharedCount(&v15);
    v11[0] = &unk_1F11193B8;
    PCSharedCount::~PCSharedCount(&v13);
  }
  (**a2)(v14, a2, &a1[13]);
  v11[0] = &unk_1F11193B8;
  v12.int var0 = 0;
  PCSharedCount::PCSharedCount(&v13);
  if (a1[19].var0)
  {
    (**a2)(v8, a2, &a1[17]);
    ProShade::VarT<ProShade::Node>::operator=((uint64_t)v11, v8);
    v8[0].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
    PCSharedCount::~PCSharedCount(&v10);
  }
  v8[0].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCPtr<LiImageSource>::PCPtr<OZGradientSource>(&v9, a1 + 8);
  if (v17 != v9.var0 || v14[2].var0 != a1[15].var0)
  {
    v8[0].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
    PCSharedCount::~PCSharedCount(&v10);
    goto LABEL_8;
  }
  int var0 = v12.var0;
  int v7 = a1[19].var0;
  v8[0].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(&v10);
  if (var0 != v7)
  {
LABEL_8:
    if (a1[19].var0) {
      operator new();
    }
    operator new();
  }
  ProShade::VarT<ProShade::Node>::VarT(a3, (PCShared_base *)a1);
  v11[0] = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount(&v13);
  v14[0].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(&v15);
  size_t v16 = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount(&v18);
}

void sub_1B7A8A7DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  MEMORY[0x1BA9BFBA0](v14, 0x10B1C408AD29EEDLL);
  PCSharedCount::~PCSharedCount(v13);
  PCSharedCount::~PCSharedCount((PCSharedCount *)va);
  PCSharedCount::~PCSharedCount(v12);
  _Unwind_Resume(a1);
}

uint64_t ProShade::TextureFunc::atomic(ProShade::TextureFunc *this)
{
  return 0;
}

void ProShade::TextureFunc::clone(ProShade::TextureFunc *this)
{
}

void sub_1B7A8A920(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C408AD29EEDLL);
  _Unwind_Resume(a1);
}

void ProShade::TextureFunc::computeValue(int a1, int a2, PCSharedCount *this)
{
}

BOOL ProShade::InputNode::builtIn(ProShade::InputNode *this)
{
  return *((_DWORD *)this + 13) == 2;
}

void ProShade::TextureData::~TextureData(ProShade::TextureData *this)
{
  *(void *)this = &unk_1F111AA88;
  *((void *)this + 5) = &unk_1F111AAB8;
  int v2 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  LiString::dec((ProShade::TextureData *)((char *)this + 8));
  *((void *)this + 5) = &unk_1F1199AC8;
  *((unsigned char *)this + LiDepthSorter::stackSort((uint64_t)this + 56) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)this + 6);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1F111AA88;
  *((void *)this + 5) = &unk_1F111AAB8;
  int v2 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  LiString::dec((ProShade::TextureData *)((char *)this + 8));
  *((void *)this + 5) = &unk_1F1199AC8;
  *((unsigned char *)this + LiDepthSorter::stackSort((uint64_t)this + 56) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)this + 6);

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'ProShade::TextureData::~TextureData(ProShade::TextureData *this)
{
  uint64_t v1 = (char *)this + *(void *)(*(void *)this - 24);
  *(void *)uint64_t v1 = &unk_1F111AA88;
  *((void *)v1 + 5) = &unk_1F111AAB8;
  int v2 = (std::__shared_weak_count *)*((void *)v1 + 3);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  LiString::dec((LiString *)(v1 + 8));
  *((void *)v1 + 5) = &unk_1F1199AC8;
  v1[56] = 0;

  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)v1 + 6);
}

{
  char *v1;
  std::__shared_weak_count *v2;
  uint64_t vars8;

  uint64_t v1 = (char *)this + *(void *)(*(void *)this - 24);
  *(void *)uint64_t v1 = &unk_1F111AA88;
  *((void *)v1 + 5) = &unk_1F111AAB8;
  int v2 = (std::__shared_weak_count *)*((void *)v1 + 3);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  LiString::dec((LiString *)(v1 + 8));
  *((void *)v1 + 5) = &unk_1F1199AC8;
  v1[56] = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)v1 + 6);

  JUMPOUT(0x1BA9BFBA0);
}

void ProShade::Uniform::Uniform()
{
}

void sub_1B7A8AD04(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C402CAA7C2BLL);
  _Unwind_Resume(a1);
}

_OWORD *std::__tree<std::__value_type<LiOpenGLContextGetter::C,ProShade::SamplerNode::Binding>,std::__map_value_compare<LiOpenGLContextGetter::C,std::__value_type<LiOpenGLContextGetter::C,ProShade::SamplerNode::Binding>,LiOpenGLContextGetter::Compare,true>,std::allocator<std::__value_type<LiOpenGLContextGetter::C,ProShade::SamplerNode::Binding>>>::__emplace_unique_key_args<LiOpenGLContextGetter::C,std::piecewise_construct_t const&,std::tuple<LiOpenGLContextGetter::C const&>,std::tuple<>>(uint64_t **a1, uint64_t *a2, uint64_t a3, _OWORD **a4)
{
  int v6 = (void **)std::__tree<std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>,std::__map_value_compare<LiOpenGLContextGetter::C,std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>,LiOpenGLContextGetter::Compare,true>,std::allocator<std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>>>::__find_equal<LiOpenGLContextGetter::C>((uint64_t)a1, &v10, a2);
  int v7 = *v6;
  if (!*v6)
  {
    int v8 = (uint64_t **)v6;
    int v7 = operator new(0x40uLL);
    v7[2] = **a4;
    *((void *)v7 + 6) = 0xFFFFFFFFLL;
    *((_DWORD *)v7 + 14) = 1;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v10, v8, (uint64_t *)v7);
  }
  return v7;
}

void PCMakePtr<LiRenderer>()
{
}

void sub_1B7A8AE30(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10F1C40FF600A27);
  _Unwind_Resume(a1);
}

void PCMakePtr<LiGeode,PCPtr<LiRenderer> &>()
{
}

void sub_1B7A8AED4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C40A6A93DF4);
  _Unwind_Resume(a1);
}

void Li3DGroupForEquirect::setUpGroup()
{
}

void sub_1B7A8B088(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  PCSharedCount::~PCSharedCount((PCSharedCount *)va);
  _Unwind_Resume(a1);
}

void Li3DGroupForEquirect::Li3DGroupForEquirect(uint64_t a1)
{
  *(void *)(a1 + 680) = &unk_1F1199AC8;
  *(void *)(a1 + 688) = 0;
  *(unsigned char *)(a1 + 696) = 1;
  LiGroup::LiGroup((LiGroup *)a1, (uint64_t *)&off_1F111AC50);
  *(void *)a1 = &unk_1F111AB00;
  *(void *)(a1 + 680) = &unk_1F111AC30;
  PCMakePtr<LiRenderer>();
}

void sub_1B7A8B198(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount((PCSharedCount *)(v1 + 672));
  PCSharedCount::~PCSharedCount((PCSharedCount *)(v1 + 656));
  LiGroup::~LiGroup((PCSharedCount *)v1, (PCSharedCount *)&off_1F111AC50);
  *(void *)(v1 + 680) = v2;
  *(unsigned char *)(v1 + 696) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 688));
  _Unwind_Resume(a1);
}

void Li3DGroupForEquirect::Li3DGroupForEquirect(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 680) = &unk_1F1199AC8;
  *(void *)(a1 + 688) = 0;
  *(unsigned char *)(a1 + 696) = 1;
  LiGroup::LiGroup(a1, (uint64_t *)&off_1F111AC50, a2);
  *(void *)a1 = &unk_1F111AB00;
  *(void *)(a1 + 680) = &unk_1F111AC30;
  PCMakePtr<LiRenderer>();
}

void sub_1B7A8B344(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount((PCSharedCount *)(v1 + 656));
  LiGroup::~LiGroup((PCSharedCount *)v1, (PCSharedCount *)&off_1F111AC50);
  *(void *)(v1 + 680) = v2;
  *(unsigned char *)(v1 + 696) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 688));
  _Unwind_Resume(a1);
}

void PCMakePtr<LiGroup>()
{
}

void sub_1B7A8B420(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C40089F272ELL);
  _Unwind_Resume(a1);
}

void PCMakePtr<LiSimpleCamera>()
{
}

void sub_1B7A8B4B4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40DA4F106CLL);
  _Unwind_Resume(a1);
}

uint64_t Li3DGroupForEquirect::getRenderer(Li3DGroupForEquirect *this)
{
  return *((void *)this + 81);
}

uint64_t Li3DGroupForEquirect::getGeode(Li3DGroupForEquirect *this)
{
  return *((void *)this + 83);
}

void Li3DGroupForEquirect::createCopyWithJustLights(Li3DGroupForEquirect *this, int a2)
{
  if (a2) {
    PCMakePtr<Li3DGroupForEquirect,Li3DGroupForEquirect const&,LiGroup::JustLightsTag>();
  }

  LiGroup::createCopyWithJustLights(this);
}

void sub_1B7A8B55C(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1 + 1);
  _Unwind_Resume(a1);
}

void PCMakePtr<Li3DGroupForEquirect,Li3DGroupForEquirect const&,LiGroup::JustLightsTag>()
{
}

void sub_1B7A8B5F0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C40447CC23ELL);
  _Unwind_Resume(a1);
}

const char *Li3DGroupForEquirect::className(Li3DGroupForEquirect *this)
{
  return "Li3DGroupForEquirect";
}

void Li3DGroupForEquirect::~Li3DGroupForEquirect(PCSharedCount *this)
{
  *(void *)(v1 + 680) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 696) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 688));
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)(v1 + 680) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 696) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 688));

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'Li3DGroupForEquirect::~Li3DGroupForEquirect(Li3DGroupForEquirect *this)
{
  *(void *)(v1 + 680) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 696) = 0;
  uint64_t v2 = (PC_Sp_counted_base **)(v1 + 688);

  PCWeakCount::~PCWeakCount(v2);
}

{
  Li3DGroupForEquirect::~Li3DGroupForEquirect((PCSharedCount *)((char *)this + *(void *)(*(void *)this - 24)));
}

void Li3DGroupForEquirect::~Li3DGroupForEquirect(PCSharedCount *this, PCSharedCount *a2)
{
  int var0 = a2->var0;
  this->int var0 = a2->var0;
  *(PCSharedCount *)((char *)this + *((void *)var0 - 3)) = a2[7];
  PCSharedCount::~PCSharedCount(this + 84);
  PCSharedCount::~PCSharedCount(this + 82);

  LiGroup::~LiGroup(this, a2 + 1);
}

void LiDropShadow::LiDropShadow(LiDropShadow *this)
{
  *((void *)this + 28) = &unk_1F1199AC8;
  *((void *)this + 29) = 0;
  *((unsigned char *)this + 240) = 1;
  LiImageFilter::LiImageFilter(this, (uint64_t *)&off_1F111B058);
  *(void *)this = &unk_1F111AF50;
  *((void *)this + 28) = &unk_1F111B038;
  *((void *)this + 20) = 0x3FF0000000000000;
  *((void *)this + 15) = 0x3FF0000000000000;
  *((void *)this + 10) = 0x3FF0000000000000;
  *((void *)this + 5) = 0x3FF0000000000000;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((unsigned char *)this + 168) = 1;
  PCWorkingColorVector::PCWorkingColorVector((LiDropShadow *)((char *)this + 172));
  *((void *)this + 24) = 0;
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0x3FF0000000000000;
  *((_WORD *)this + 108) = 1;
}

void sub_1B7A8B944(_Unwind_Exception *a1)
{
  LiImageFilter::~LiImageFilter((PCSharedCount *)v1, (const PCString *)&off_1F111B058);
  *(void *)(v1 + 224) = v3;
  *(unsigned char *)(v1 + 240) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

void LiDropShadow::~LiDropShadow(PCSharedCount *this, const PCString *a2)
{
  int var0 = a2->var0;
  this->int var0 = (PC_Sp_counted_base *)a2->var0;
  *(__CFString **)((char *)this + var0[-1].info) = a2[7].var0;
  int v5 = a2[1].var0;
  this->int var0 = (PC_Sp_counted_base *)v5;
  *(__CFString **)((char *)this + v5[-1].info) = a2[6].var0;
  PCSharedCount::~PCSharedCount(this + 3);

  OZChannelBase::setRangeName((OZChannelBase *)this, a2 + 2);
}

void LiDropShadow::~LiDropShadow(PCSharedCount *this)
{
  *(void *)(v1 + 224) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 240) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 232));
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)(v1 + 224) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 240) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 232));

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'LiDropShadow::~LiDropShadow(LiDropShadow *this)
{
  *(void *)(v1 + 224) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 240) = 0;
  uint64_t v2 = (PC_Sp_counted_base **)(v1 + 232);

  PCWeakCount::~PCWeakCount(v2);
}

{
  LiDropShadow::~LiDropShadow((PCSharedCount *)((char *)this + *(void *)(*(void *)this - 24)));
}

uint64_t LiDropShadow::filteredEdges(LiDropShadow *this)
{
  return 1;
}

void LiDropShadow::clone(LiDropShadow *this)
{
}

void sub_1B7A8BCD8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40A867C4B1);
  _Unwind_Resume(a1);
}

double LiDropShadow::copyFrom(LiDropShadow *this, const LiDropShadow *a2)
{
  LiImageFilter::copyFrom((PCSharedCount *)this, (const PCSharedCount *)a2);
  if (a2 != this)
  {
    uint64_t v4 = 0;
    int v5 = (char *)a2 + 40;
    int v6 = (char *)this + 40;
    do
    {
      for (uint64_t i = 0; i != 32; i += 8)
        *(void *)&v6[i] = *(void *)&v5[i];
      ++v4;
      v6 += 32;
      v5 += 32;
    }
    while (v4 != 4);
  }
  *((unsigned char *)this + 168) = *((unsigned char *)a2 + 168);
  *(_OWORD *)((char *)this + 172) = *(_OWORD *)((char *)a2 + 172);
  *((_OWORD *)this + 12) = *((_OWORD *)a2 + 12);
  double result = *((double *)a2 + 26);
  *((double *)this + 26) = result;
  *((_WORD *)this + 108) = *((_WORD *)a2 + 108);
  return result;
}

void LiImageFilter::copyFrom(PCSharedCount *this, const PCSharedCount *a2)
{
  this[2].int var0 = a2[2].var0;
  uint64_t v4 = (uint64_t *)&this[3];
  PCSharedCount::PCSharedCount(&v5, a2 + 3);
  PCSharedCount::operator=(v4, (uint64_t *)&v5);
  PCSharedCount::~PCSharedCount(&v5);
  LODWORD(this[4].var0) = a2[4].var0;
}

void sub_1B7A8BE04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

uint64_t LiDropShadow::pixelTransformSupport(uint64_t a1)
{
  double v1 = *(double *)(a1 + 192);
  double v2 = *(double *)(a1 + 200);
  BOOL v3 = v1 > -0.0000001;
  if (v1 >= 0.0000001) {
    BOOL v3 = 0;
  }
  BOOL v4 = v2 > -0.0000001;
  if (v2 >= 0.0000001) {
    BOOL v4 = 0;
  }
  if (v3 && v4) {
    return 6;
  }
  else {
    return 4;
  }
}

uint64_t LiDropShadow::getBoundary(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    throw_PCNullPointerException(1);
  }
  double v2 = *(uint64_t (**)(void))(*(void *)v1 + 24);

  return v2();
}

HGBlur *LiDropShadow::getHelium@<X0>(LiDropShadow *this@<X0>, LiAgent *a2@<X1>, HGBlur **a3@<X8>)
{
  *((_DWORD *)a2 + 8) = 0;
  double result = (HGBlur *)LiAgent::getHelium(a2, *((LiImageSource **)this + 2), (uint64_t *)&v52);
  if (!v52 || (int v7 = (uint64_t *)*((void *)a2 + 6), *((unsigned char *)v7 + 144)))
  {
    *a3 = v52;
    return result;
  }
  long long v8 = *(_OWORD *)((char *)this + 120);
  long long v48 = *(_OWORD *)((char *)this + 104);
  long long v49 = v8;
  long long v9 = *(_OWORD *)((char *)this + 152);
  long long v50 = *(_OWORD *)((char *)this + 136);
  long long v51 = v9;
  float64x2_t v10 = *(float64x2_t *)((char *)this + 56);
  float64x2_t v44 = *(float64x2_t *)((char *)this + 40);
  float64x2_t v45 = v10;
  long long v11 = *(_OWORD *)((char *)this + 88);
  long long v46 = *(_OWORD *)((char *)this + 72);
  long long v47 = v11;
  uint64_t v12 = *((void *)a2 + 20);
  if (*((unsigned char *)this + 168))
  {
    uint64_t v13 = *v7;
    if (*v7 && (*(unsigned int (**)(uint64_t))(*(void *)v13 + 160))(v13))
    {
      double v14 = (*(double (**)(uint64_t))(*(void *)v13 + 688))(v13);
      double v15 = 1.0 / v14;
      if (1.0 / v14 != 1.0)
      {
        float64x2_t v44 = vmulq_n_f64(v44, v15);
        float64x2_t v45 = vmulq_n_f64(v45, v15);
      }
      if (v14 != 1.0)
      {
        v44.f64[0] = v14 * v44.f64[0];
        *(double *)&long long v46 = v14 * *(double *)&v46;
        *(double *)&long long v48 = v14 * *(double *)&v48;
        *(double *)&long long v50 = v14 * *(double *)&v50;
      }
    }
  }
  else
  {
    LiAgent::getObjectToImageTransform(a2, (uint64_t)v41);
    PCMatrix44Tmpl<double>::operator*((uint64_t)v41, (long long *)&v44, (uint64_t)v42);
    LiAgent::getImageToObjectTransform((double **)a2, (uint64_t)v40);
    PCMatrix44Tmpl<double>::operator*((uint64_t)v42, v40, (uint64_t)v43);
    for (uint64_t i = 0; i != 16; i += 4)
    {
      int v17 = (_OWORD *)&v44.f64[i];
      long long v18 = *(_OWORD *)&v43[i + 2];
      *int v17 = *(_OWORD *)&v43[i];
      v17[1] = v18;
    }
  }
  PCMatrix44Tmpl<double>::operator*(v12, (long long *)&v44, (uint64_t)v42);
  LiAgent::getInversePixelTransform(a2, 0.0, (uint64_t)v41);
  PCMatrix44Tmpl<double>::operator*((uint64_t)v42, v41, (uint64_t)v43);
  for (uint64_t j = 0; j != 16; j += 4)
  {
    __int32 v20 = (_OWORD *)&v44.f64[j];
    long long v21 = *(_OWORD *)&v43[j + 2];
    *__int32 v20 = *(_OWORD *)&v43[j];
    v20[1] = v21;
  }
  LiAgent::haveROI(a2);
  LiAgent::makeHeliumXForm((uint64_t)a2, (uint64_t)&v44, (uint64_t *)&v52, a3);
  float64x2_t v22 = *((float64x2_t *)this + 12);
  float64x2_t v23 = *(float64x2_t *)(v12 + 32);
  int8x16_t v24 = (int8x16_t)vmulq_f64(v23, (float64x2_t)0);
  float64x2_t v25 = vaddq_f64((float64x2_t)vextq_s8(v24, v24, 8uLL), vmulq_f64(v22, v23));
  int8x16_t v26 = (int8x16_t)vmulq_f64(*(float64x2_t *)v12, (float64x2_t)0);
  float64x2_t v27 = vaddq_f64((float64x2_t)vextq_s8(v26, v26, 8uLL), vmulq_f64(v22, *(float64x2_t *)v12));
  double v28 = sqrt(vaddvq_f64(vmulq_f64(v27, v27)));
  double v29 = sqrt(vaddvq_f64(vmulq_f64(v25, v25)));
  if (v28 > 0.0 || v29 > 0.0)
  {
    float v30 = v28;
    float v31 = v29;
    LiHelium::createBlurNode(v30, v31, v43);
    (*(void (**)(HGBlur *, void, HGBlur *))(*(void *)v43[0] + 120))(v43[0], 0, *a3);
    if (!*(unsigned char *)(*((void *)a2 + 6) + 132)) {
      (*(void (**)(HGBlur *, uint64_t, float, double, double, double))(*(void *)v43[0] + 96))(v43[0], 2, 1.0, 0.0, 0.0, 0.0);
    }
    uint64_t v32 = *a3;
    size_t v33 = v43[0];
    if (*a3 != v43[0])
    {
      if (v32)
      {
        (*(void (**)(HGBlur *))(*(void *)v32 + 24))(v32);
        size_t v33 = v43[0];
      }
      *a3 = v33;
      if (!v33) {
        goto LABEL_27;
      }
      (*(void (**)(HGBlur *))(*(void *)v33 + 16))(v33);
      uint64_t v32 = v43[0];
    }
    if (v32) {
      (*(void (**)(HGBlur *))(*(void *)v32 + 24))(v32);
    }
  }
LABEL_27:
  int v34 = (LiHeAlphaFill *)HGObject::operator new(0x1A0uLL);
  LiHeAlphaFill::LiHeAlphaFill(v34);
  (*(void (**)(LiHeAlphaFill *, void, HGBlur *))(*(void *)v34 + 120))(v34, 0, *a3);
  float v35 = operator*((float *)this + 43, *((float *)this + 46));
  (*(void (**)(LiHeAlphaFill *, void, float))(*(void *)v34 + 96))(v34, 0, v35);
  float v36 = *((double *)this + 26);
  (*(void (**)(LiHeAlphaFill *, uint64_t, float, double, double, double))(*(void *)v34 + 96))(v34, 1, v36, 0.0, 0.0, 0.0);
  size_t v37 = *a3;
  if (*a3 != v34)
  {
    if (v37) {
      (*(void (**)(HGBlur *))(*(void *)v37 + 24))(v37);
    }
    *a3 = v34;
    (*(void (**)(LiHeAlphaFill *))(*(void *)v34 + 16))(v34);
  }
  (*(void (**)(LiHeAlphaFill *))(*(void *)v34 + 24))(v34);
  if (*((unsigned char *)this + 216))
  {
    __int32 v38 = (HGHWBlendFlipped *)HGObject::operator new(0x220uLL);
    HGHWBlendFlipped::HGHWBlendFlipped(v38);
    (*(void (**)(HGHWBlendFlipped *, void, HGBlur *))(*(void *)v38 + 120))(v38, *((unsigned __int8 *)this + 217), v52);
    (*(void (**)(HGHWBlendFlipped *, BOOL, HGBlur *))(*(void *)v38 + 120))(v38, *((unsigned char *)this + 217) == 0, *a3);
    int v39 = *a3;
    if (*a3 != v38)
    {
      if (v39) {
        (*(void (**)(HGBlur *))(*(void *)v39 + 24))(v39);
      }
      *a3 = v38;
      (*(void (**)(HGHWBlendFlipped *))(*(void *)v38 + 16))(v38);
    }
    (*(void (**)(HGHWBlendFlipped *))(*(void *)v38 + 24))(v38);
  }
  double result = v52;
  if (v52) {
    return (HGBlur *)(*(uint64_t (**)(HGBlur *))(*(void *)v52 + 24))(v52);
  }
  return result;
}

void sub_1B7A8C508(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57)
{
  if (a57) {
    (*(void (**)(uint64_t))(*(void *)a57 + 24))(a57);
  }
  if (*v57) {
    (*(void (**)(void))(*(void *)*v57 + 24))(*v57);
  }
  uint64_t v60 = *(void *)(v58 - 56);
  if (v60) {
    (*(void (**)(uint64_t))(*(void *)v60 + 24))(v60);
  }
  _Unwind_Resume(exception_object);
}

uint64_t LiGL::useProgram(void **this, ProShade::Program *a2)
{
  if (a2)
  {
    (*(void (**)(ProShade::Program *))(*(void *)a2 + 16))(a2);
    GLuint v4 = ProShade::ProgramBase::id(a2);
    glUseProgram(v4);
  }

  return LiGL::setCurrentProgram(this, (uint64_t)a2);
}

uint64_t LiGL::setCurrentProgram(void **a1, uint64_t a2)
{
  GLuint v4 = *a1;
  if (!v4)
  {
    GLuint v4 = LiGLState::get(0);
    *a1 = v4;
  }

  return LiGLState::setCurrentProgram((uint64_t)v4, a2);
}

void Li3DEngineImageSource::Li3DEngineImageSource(Li3DEngineImageSource *this)
{
  *((void *)this + 38) = &unk_1F1199AC8;
  *((void *)this + 39) = 0;
  *((unsigned char *)this + 320) = 1;
  LiRendererBase::LiRendererBase(this, (uint64_t *)&off_1F111B438);
  *(void *)this = &unk_1F111B330;
  *((void *)this + 38) = &unk_1F111B418;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 24) = 0x3FF0000000000000;
  *((void *)this + 19) = 0x3FF0000000000000;
  *((void *)this + 14) = 0x3FF0000000000000;
  *((void *)this + 9) = 0x3FF0000000000000;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *(_OWORD *)((char *)this + 200) = xmmword_1B7E74760;
  *((void *)this + 33) = 0;
  *((void *)this + 34) = 0;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((void *)this + 36) = 0;
  *((void *)this + 37) = 0x3FF0000000000000;
  *((_DWORD *)this + 2) = 2;
  *((_DWORD *)this + 64) = 2;
  *((_DWORD *)this + 55) = -1082130432;
  *((unsigned char *)this + 216) = 0;
}

void sub_1B7A8C830(_Unwind_Exception *a1)
{
  *(void *)(v1 + 304) = v3;
  *(unsigned char *)(v1 + 320) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

void Li3DEngineImageSource::~Li3DEngineImageSource(PCSharedCount *this, const PCString *a2)
{
  int var0 = a2->var0;
  this->int var0 = (PC_Sp_counted_base *)a2->var0;
  *(__CFString **)((char *)this + var0[-1].info) = a2[7].var0;
  PCSharedCount v5 = (std::__shared_weak_count *)this[31].var0;
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  int v6 = this[29].var0;
  if (v6) {
    (*(void (**)(PC_Sp_counted_base *))(*(void *)v6 + 24))(v6);
  }
  int v7 = this[28].var0;
  if (v7) {
    (*(void (**)(PC_Sp_counted_base *))(*(void *)v7 + 24))(v7);
  }

  LiRendererBase::~LiRendererBase(this, a2 + 1);
}

void Li3DEngineImageSource::~Li3DEngineImageSource(PCSharedCount *this)
{
  *(void *)(v1 + 304) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 320) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 312));
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)(v1 + 304) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 320) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 312));

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'Li3DEngineImageSource::~Li3DEngineImageSource(Li3DEngineImageSource *this)
{
  *(void *)(v1 + 304) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 320) = 0;
  double v2 = (PC_Sp_counted_base **)(v1 + 312);

  PCWeakCount::~PCWeakCount(v2);
}

{
  Li3DEngineImageSource::~Li3DEngineImageSource((PCSharedCount *)((char *)this + *(void *)(*(void *)this - 24)));
}

uint64_t Li3DEngineImageSource::setVideoOrientation(uint64_t result, int a2)
{
  *(_DWORD *)(result + 2LiDepthSorter::stackSort((uint64_t)this + 56) = a2;
  return result;
}

uint64_t Li3DEngineImageSource::pixelTransformSupport()
{
  return 3;
}

uint64_t Li3DEngineImageSource::estimateRenderMemory()
{
  return 0;
}

uint64_t Li3DEngineImageSource::handlesDepthOfField(Li3DEngineImageSource *this)
{
  return 0;
}

uint64_t Li3DEngineImageSource::setRenderInSingleScene(uint64_t this, char a2)
{
  *(unsigned char *)(this + 216) = a2;
  return this;
}

uint64_t Li3DEngineImageSource::supportsHeliumCPURendering(Li3DEngineImageSource *this)
{
  return 0;
}

void Li3DEngineImageSource::getHelium(PC_Sp_counted_base **this, LiAgent *a2)
{
  uint64_t RequestedColorDescription = LiAgent::getRequestedColorDescription(a2);
  FxColorDescription::FxColorDescription((uint64_t)&v18, RequestedColorDescription, 0);
  LiAgentRequestedColorSpaceSentry::LiAgentRequestedColorSpaceSentry((LiAgentRequestedColorSpaceSentry *)v17, a2, &v18);
  if (LiRenderingTechnology::getLogLithium((LiRenderingTechnology *)(*((void *)a2 + 6) + 80)))
  {
    PCSharedCount v5 = (void *)MEMORY[0x1E4FBA240];
    (*((void (**)(PC_Sp_counted_base **, void, void))*this + 16))(this, MEMORY[0x1E4FBA240], 0);
    std::ios_base::getloc((const std::ios_base *)((char *)v5 + *(void *)(*v5 - 24)));
    int v6 = std::locale::use_facet(v11, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v6->__vftable[2].~facet_0)(v6, 10);
    std::locale::~locale(v11);
    std::ostream::put();
    std::ostream::flush();
  }
  int v7 = (LiHe3DEngineNode *)HGObject::operator new(0x2C0uLL);
  LiHe3DEngineNode::LiHe3DEngineNode(v7);
  v15.int var0 = this[2];
  PCSharedCount::PCSharedCount(&v16, (const PCSharedCount *)this + 3);
  LiHe3DEngineNode::setScene((uint64_t)v7, &v15);
  PCSharedCount::~PCSharedCount(&v16);
  uint64_t v8 = (uint64_t)this[29];
  uint64_t v14 = v8;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 16))(v8);
  }
  LiHe3DEngineNode::setMatteNode((uint64_t)v7, &v14);
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);
  }
  uint64_t v9 = (uint64_t)this[28];
  uint64_t v13 = v9;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 16))(v9);
  }
  LiHe3DEngineNode::setDepthNode((uint64_t)v7, &v13);
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 24))(v13);
  }
  *((_DWORD *)v7 + 103) = *((_DWORD *)this + 55);
  LiHe3DEngineNode::setVideoOrientation((uint64_t)v7, *((_DWORD *)this + 64));
  float64x2_t v10 = this[30];
  if (v10)
  {
    (*(void (**)(std::locale *__return_ptr))(*(void *)v10 + 24))(v11);
    locale = v11[0].__locale_;
    if (v11[0].__locale_) {
      (*(void (**)(std::locale::__imp *))(*(void *)v11[0].__locale_ + 16))(v11[0].__locale_);
    }
    LiHe3DEngineNode::setPlaceholderDepthTexture((uint64_t)v7, (uint64_t *)&locale);
    if (locale) {
      (*(void (**)(std::locale::__imp *))(*(void *)locale + 24))(locale);
    }
    if (v11[0].__locale_) {
      (*(void (**)(std::locale::__imp *))(*(void *)v11[0].__locale_ + 24))(v11[0].__locale_);
    }
  }
  if (*((unsigned char *)this + 216)) {
    *((unsigned char *)v7 + 640) = 1;
  }
  operator new();
}

void sub_1B7A8D6B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,std::locale a41)
{
  if (a25) {
    (*(void (**)(uint64_t))(*(void *)a25 + 24))(a25);
  }
  if (*v42) {
    (*(void (**)(void))(*(void *)*v42 + 24))(*v42);
  }
  PCSharedCount::~PCSharedCount(v43);
  (*(void (**)(uint64_t))(*(void *)v41 + 24))(v41);
  LiAgentRequestedColorSpaceSentry::~LiAgentRequestedColorSpaceSentry((LiAgentRequestedColorSpaceSentry *)(v44 - 200));
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)(v44 - 160));
  _Unwind_Resume(a1);
}

uint64_t LiHe3DEngineNode::setMatteNode(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 416);
  uint64_t result = *a2;
  if (v3 != *a2)
  {
    if (v3)
    {
      (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
      uint64_t result = *a2;
    }
    *(void *)(a1 + 416) = result;
    if (result)
    {
      int v6 = *(uint64_t (**)(void))(*(void *)result + 16);
      return v6();
    }
  }
  return result;
}

uint64_t LiHe3DEngineNode::setDepthNode(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 424);
  uint64_t result = *a2;
  if (v3 != *a2)
  {
    if (v3)
    {
      (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
      uint64_t result = *a2;
    }
    *(void *)(a1 + 424) = result;
    if (result)
    {
      int v6 = *(uint64_t (**)(void))(*(void *)result + 16);
      return v6();
    }
  }
  return result;
}

uint64_t LiHe3DEngineNode::setPlaceholderDepthTexture(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 432);
  uint64_t result = *a2;
  if (v3 != *a2)
  {
    if (v3)
    {
      (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
      uint64_t result = *a2;
    }
    *(void *)(a1 + 432) = result;
    if (result)
    {
      int v6 = *(uint64_t (**)(void))(*(void *)result + 16);
      return v6();
    }
  }
  return result;
}

void FxSupport::newHGRefWithInput<HGColorClamp>()
{
  uint64_t v0 = (HGColorClamp *)HGObject::operator new(0x1C0uLL);
  HGColorClamp::HGColorClamp(v0);
}

void sub_1B7A8DC78(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void LiRendererBase::LiRendererBase(LiRendererBase *this, uint64_t *a2)
{
  LiImageSource::LiImageSource((LiImageSource *)this, a2 + 1);
  uint64_t v4 = *a2;
  uint64_t *v5 = *a2;
  *(void *)((char *)this + *(void *)(v4 - 24)) = a2[5];
  *((void *)this + 2) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 3);
  *((void *)this + 4) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 5);
}

void sub_1B7A8DD9C(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v3);
  OZChannelBase::setRangeName(v1, v2);
  _Unwind_Resume(a1);
}

void LiRendererBase::~LiRendererBase(PCSharedCount *this, const PCString *a2)
{
  int var0 = a2->var0;
  this->int var0 = (PC_Sp_counted_base *)a2->var0;
  *(__CFString **)((char *)this + var0[-1].info) = a2[5].var0;
  PCSharedCount::~PCSharedCount(this + 5);
  PCSharedCount::~PCSharedCount(this + 3);

  OZChannelBase::setRangeName((OZChannelBase *)this, a2 + 1);
}

PCShared_base **LiRendererBase::setScene(PCShared_base **this, LiSceneObject *a2)
{
  return PCPtr<LiImageSource>::operator=<LiImageSource>(this + 2, a2);
}

uint64_t LiRendererBase::getWorld(LiRendererBase *this)
{
  return *((void *)this + 2);
}

PCShared_base **LiRendererBase::setCamera(PCShared_base **this, LiCamera *a2)
{
  return PCPtr<LiImageSource>::operator=<LiImageSource>(this + 4, a2);
}

void LiRendererBase::getCamera(const PCSharedCount *this@<X0>, PCSharedCount *a2@<X8>)
{
  a2->int var0 = this[4].var0;
  PCSharedCount::PCSharedCount(a2 + 1, this + 5);
}

uint64_t LiRendererBase::print(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4) {
    (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v4 + 752))(v4, a2, a3);
  }
  else {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"Active camera\n", 14);
  }
  uint64_t v5 = *(void *)(a1 + 16);
  if (!v5) {
    throw_PCNullPointerException(1);
  }
  int v6 = *(uint64_t (**)(void))(*(void *)v5 + 112);

  return v6();
}

uint64_t LiRendererBase::adjustCasterLocalToWorld(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = *(void *)(result + 16);
  if (v7)
  {
    LiSceneIterator<LiGeode,LiSceneIteratorAlways>::LiSceneIterator((uint64_t)v15, v7);
    while (v16 ? LiSceneIterator<LiGeode,LiSceneIteratorAlways>::next : 0)
    {
      (*(void (**)(uint64_t *__return_ptr))(*(void *)v16 + 160))(&v13);
      if (v13) {
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v13 + 144))(v13, a2, a3, a4, a5, a6);
      }
      PCSharedCount::~PCSharedCount(&v14);
      LiSceneIterator<LiGeode,LiSceneIteratorAlways>::operator++((uint64_t)v15);
    }
    return LiSceneIterator<LiGeode,LiSceneIteratorAlways>::~LiSceneIterator((uint64_t)v15);
  }
  return result;
}

void sub_1B7A8E0AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  PCSharedCount::~PCSharedCount(v12);
  LiSceneIterator<LiGeode,LiSceneIteratorAlways>::~LiSceneIterator((uint64_t)&a12);
  _Unwind_Resume(a1);
}

uint64_t LiSceneIterator<LiGeode,LiSceneIteratorAlways>::operator++(uint64_t a1)
{
  if (*(void *)(a1 + 8))
  {
    do
    {
      LiSceneIterator<LiGeode,LiSceneIteratorAlways>::next(a1);
      double v2 = *(const void **)(a1 + 8);
    }
    while (v2
  }
  return a1;
}

uint64_t LiSceneIterator<LiGeode,LiSceneIteratorAlways>::LiSceneIterator(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = &unk_1F111B720;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 160) = 0x3FF0000000000000;
  *(void *)(a1 + 120) = 0x3FF0000000000000;
  *(void *)(a1 + 80) = 0x3FF0000000000000;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0x3FF0000000000000;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  while (1)
  {
    uint64_t v3 = *(const void **)(a1 + 8);
    if (!v3
    {
      break;
    }
    LiSceneIterator<LiGeode,LiSceneIteratorAlways>::next(a1);
  }
  return a1;
}

void sub_1B7A8E23C(_Unwind_Exception *a1)
{
  PCArray<LiSceneIterator<LiGeode,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiGeode,LiSceneIteratorAlways>::Obj>>::~PCArray(v1);
  _Unwind_Resume(a1);
}

double LiSceneIterator<LiGeode,LiSceneIteratorAlways>::next(uint64_t a1)
{
  double v2 = *(const void **)(a1 + 8);
  if (v2)
  {
    if (v3
      && (uint64_t v4 = v3,
          uint64_t v3 = (PCArray_base *)(*(uint64_t (**)(PCArray_base *))(*(void *)v3 + 136))(v3),
          v3))
    {
      int v5 = *(_DWORD *)(a1 + 28);
      if (*(_DWORD *)(a1 + 24) <= v5) {
        int v6 = (2 * (v5 + 1)) | 1;
      }
      else {
        int v6 = *(_DWORD *)(a1 + 24);
      }
      PCArray<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj>>::resize(a1 + 16, v5 + 1, v6);
      uint64_t v7 = *(void *)(a1 + 32) + 144 * *(int *)(a1 + 28);
      *(void *)(v7 - 144) = v4;
      *(_DWORD *)(v7 - 136) = 0;
      uint64_t v8 = v7 - 128;
      if (a1 + 40 != v7 - 128)
      {
        uint64_t v9 = 0;
        uint64_t v10 = a1 + 40;
        uint64_t v11 = v8;
        do
        {
          for (uint64_t i = 0; i != 32; i += 8)
            *(void *)(v11 + i) = *(void *)(v10 + i);
          ++v9;
          v11 += 32;
          v10 += 32;
        }
        while (v9 != 4);
      }
      uint64_t v13 = (*(uint64_t (**)(PCArray_base *, void))(*(void *)v4 + 144))(v4, 0);
      *(void *)(a1 + 8) = v13;
      PCMatrix44Tmpl<double>::operator*(v8, (long long *)(v13 + 8), (uint64_t)v34);
      if (v34 != (_OWORD *)(a1 + 40))
      {
        for (uint64_t j = 0; j != 8; j += 2)
        {
          uint64_t v16 = (_OWORD *)(a1 + 40 + j * 16);
          long long v14 = v34[j];
          long long v17 = v34[j + 1];
          _OWORD *v16 = v14;
          v16[1] = v17;
        }
      }
    }
    else
    {
      int v18 = *(_DWORD *)(a1 + 28);
      if (v18)
      {
        size_t v19 = (_OWORD *)(a1 + 40);
        while (1)
        {
          if (v18 <= 0) {
            PCArray_base::badIndex(v3);
          }
          uint64_t v20 = v18 - 1;
          uint64_t v21 = *(void *)(a1 + 32);
          float64x2_t v22 = (uint64_t *)(v21 + 144 * v20);
          uint64_t v23 = *v22;
          signed int v25 = *((_DWORD *)v22 + 2);
          int8x16_t v24 = v22 + 1;
          if (v25 < (int)((*(uint64_t (**)(uint64_t))(*(void *)v23 + 136))(v23) - 1)) {
            break;
          }
          int v26 = *(_DWORD *)(a1 + 28) - 1;
          if (*(_DWORD *)(a1 + 24) >= v26) {
            int v27 = *(_DWORD *)(a1 + 24);
          }
          else {
            int v27 = (2 * v26) | 1;
          }
          uint64_t v3 = (PCArray_base *)PCArray<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj>>::resize(a1 + 16, v26, v27);
          int v18 = *(_DWORD *)(a1 + 28);
          if (!v18) {
            goto LABEL_25;
          }
        }
        ++*v24;
        uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)v23 + 144))(v23);
        *(void *)(a1 + 8) = v28;
        PCMatrix44Tmpl<double>::operator*(v21 + 144 * v20 + 16, (long long *)(v28 + 8), (uint64_t)v34);
        if (v34 != v19)
        {
          long long v29 = v38;
          *(_OWORD *)(a1 + 104) = v37;
          *(_OWORD *)(a1 + 120) = v29;
          long long v30 = v40;
          *(_OWORD *)(a1 + 136) = v39;
          *(_OWORD *)(a1 + 152) = v30;
          long long v31 = v34[1];
          _OWORD *v19 = v34[0];
          *(_OWORD *)(a1 + LiDepthSorter::stackSort((uint64_t)this + 56) = v31;
          *(void *)&long long v14 = v35;
          long long v32 = v36;
          *(_OWORD *)(a1 + 72) = v35;
          *(_OWORD *)(a1 + 88) = v32;
        }
      }
      else
      {
LABEL_25:
        *(void *)(a1 + 8) = 0;
        *(void *)(a1 + 160) = 0x3FF0000000000000;
        *(void *)(a1 + 120) = 0x3FF0000000000000;
        *(void *)(a1 + 80) = 0x3FF0000000000000;
        *(void *)(a1 + 40) = 0x3FF0000000000000;
        *(void *)&long long v14 = 0;
        *(_OWORD *)(a1 + 48) = 0u;
        *(_OWORD *)(a1 + 64) = 0u;
        *(_OWORD *)(a1 + 88) = 0u;
        *(_OWORD *)(a1 + 104) = 0u;
        *(_OWORD *)(a1 + 128) = 0u;
        *(_OWORD *)(a1 + 144) = 0u;
      }
    }
  }
  return *(double *)&v14;
}

uint64_t PCArray<LiSceneIterator<LiGeode,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiGeode,LiSceneIteratorAlways>::Obj>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111B720;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

void PCArray<LiSceneIterator<LiGeode,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiGeode,LiSceneIteratorAlways>::Obj>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111B720;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t LiSceneIterator<LiGeode,LiSceneIteratorAlways>::~LiSceneIterator(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  *(void *)(a1 + 16) = &unk_1F111B720;
  if (*(int *)(a1 + 24) < 0) {
    int v3 = 1;
  }
  else {
    int v3 = *(_DWORD *)(a1 + 24);
  }
  PCArray<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj,PCArray_Traits<LiSceneIterator<LiLayeredMaterial,LiSceneIteratorAlways>::Obj>>::resize(v2, 0, v3);
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4) {
    MEMORY[0x1BA9BFB70](v4, 0x1000C8077774924);
  }
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return a1;
}

void LiFixedSize::LiFixedSize(LiFixedSize *this)
{
  *((void *)this + 7) = &unk_1F1199AC8;
  *((void *)this + 8) = 0;
  *((unsigned char *)this + 72) = 1;
  LiImageFilter::LiImageFilter(this, (uint64_t *)&off_1F111B868);
  *(void *)this = &unk_1F111B760;
  *((void *)this + 7) = &unk_1F111B848;
  *(_OWORD *)((char *)this + 36) = xmmword_1B7E74760;
}

void sub_1B7A8E794(_Unwind_Exception *a1)
{
  *(void *)(v1 + LiDepthSorter::stackSort((uint64_t)this + 56) = v2;
  *(unsigned char *)(v1 + 72) = 0;
  PCWeakCount::~PCWeakCount(v3);
  _Unwind_Resume(a1);
}

void LiFixedSize::~LiFixedSize(PCSharedCount *this)
{
  *(void *)(v1 + LiDepthSorter::stackSort((uint64_t)this + 56) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 72) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 64));
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)(v1 + LiDepthSorter::stackSort((uint64_t)this + 56) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 72) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 64));

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'LiFixedSize::~LiFixedSize(LiFixedSize *this)
{
  *(void *)(v1 + LiDepthSorter::stackSort((uint64_t)this + 56) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 72) = 0;
  uint64_t v2 = (PC_Sp_counted_base **)(v1 + 64);

  PCWeakCount::~PCWeakCount(v2);
}

{
  LiFixedSize::~LiFixedSize((PCSharedCount *)((char *)this + *(void *)(*(void *)this - 24)));
}

void LiFixedSize::clone(LiFixedSize *this)
{
}

void sub_1B7A8E998(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40063EAE96);
  _Unwind_Resume(a1);
}

uint64_t LiFixedSize::filteredEdges(LiFixedSize *this)
{
  return 1;
}

uint64_t LiFixedSize::pixelTransformSupport()
{
  return 0;
}

double LiFixedSize::fixPixelTransform(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return LiFixedSize::fixMyPixelTransform(a1, a3);
}

double LiFixedSize::fixMyPixelTransform(uint64_t a1, uint64_t a2)
{
  double result = 0.0000001;
  if (fabs(*(double *)a2 + -1.0) >= 0.0000001
    || fabs(*(double *)(a2 + 8)) >= 0.0000001
    || vabdd_f64(*(double *)(a2 + 24), round(*(double *)(a2 + 24))) >= 0.0000001
    || fabs(*(double *)(a2 + 32)) >= 0.0000001
    || fabs(*(double *)(a2 + 40) + -1.0) >= 0.0000001
    || vabdd_f64(*(double *)(a2 + 56), round(*(double *)(a2 + 56))) >= 0.0000001
    || fabs(*(double *)(a2 + 96)) >= 0.0000001
    || fabs(*(double *)(a2 + 104)) >= 0.0000001
    || fabs(*(double *)(a2 + 120) + -1.0) >= 0.0000001)
  {
    *(void *)(a2 + 120) = 0x3FF0000000000000;
    *(void *)(a2 + 80) = 0x3FF0000000000000;
    *(void *)(a2 + 40) = 0x3FF0000000000000;
    *(void *)a2 = 0x3FF0000000000000;
    double result = 0.0;
    *(_OWORD *)(a2 + 8) = 0u;
    *(_OWORD *)(a2 + 24) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 88) = 0u;
    *(_OWORD *)(a2 + 104) = 0u;
  }
  return result;
}

uint64_t LiFixedSize::getHelium@<X0>(LiFixedSize *this@<X0>, LiAgent *a2@<X1>, HGCrop **a3@<X8>)
{
  uint64_t v6 = *((void *)a2 + 20);
  uint64_t v7 = (const double *)(v6 + 120);
  v8.f64[0] = *(float64_t *)(v6 + 24);
  v8.f64[1] = *(float64_t *)(v6 + 56);
  float64x2_t v9 = vld1q_dup_f64(v7);
  *(int32x2_t *)&v8.f64[0] = vadd_s32(*(int32x2_t *)((char *)this + 36), vmovn_s64(vcvtq_s64_f64(vdivq_f64(v8, v9))));
  v9.f64[0] = *(float64_t *)((char *)this + 44);
  v16.n128_u64[0] = *(void *)&v8.f64[0];
  v16.n128_u64[1] = *(void *)&v9.f64[0];
  LiAgent::setInputROI((uint64_t)a2, &v16);
  LiAgent::getHelium(a2, *((LiImageSource **)this + 2), &v15);
  uint64_t v10 = (HGCrop *)HGObject::operator new(0x1A0uLL);
  HGCrop::HGCrop(v10);
  uint64_t v11 = HGRectMake4i(v16.n128_u32[0], v16.n128_u32[1], v16.n128_u32[2] + v16.n128_u32[0], v16.n128_u32[3] + v16.n128_u32[1]);
  (*(void (**)(HGCrop *, void, float, float, float, float))(*(void *)v10 + 96))(v10, 0, (float)(int)v11, (float)SHIDWORD(v11), (float)v12, (float)v13);
  (*(void (**)(HGCrop *, void, uint64_t))(*(void *)v10 + 120))(v10, 0, v15);
  *a3 = v10;
  uint64_t result = v15;
  if (v15) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v15 + 24))(v15);
  }
  return result;
}

void sub_1B7A8EC18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  (*(void (**)(uint64_t))(*(void *)v10 + 24))(v10);
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(a1);
}

void LiGaussianBlur::clone(LiGaussianBlur *this)
{
}

void sub_1B7A8ED9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCSharedCount a12)
{
  PCSharedCount::~PCSharedCount(&a12);
  PCSharedCount::~PCSharedCount(v12);
  _Unwind_Resume(a1);
}

void LiGaussianBlur::LiGaussianBlur(LiGaussianBlur *this)
{
  *((void *)this + 8) = &unk_1F1199AC8;
  *((void *)this + 9) = 0;
  *((unsigned char *)this + 80) = 1;
  LiImageFilter::LiImageFilter(this, (uint64_t *)&off_1F111BC48);
  *(void *)this = &unk_1F111BB40;
  *((void *)this + 8) = &unk_1F111BC28;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((unsigned char *)this + LiDepthSorter::stackSort((uint64_t)this + 56) = 1;
}

void sub_1B7A8EE94(_Unwind_Exception *a1)
{
  *(void *)(v1 + 64) = v2;
  *(unsigned char *)(v1 + 80) = 0;
  PCWeakCount::~PCWeakCount(v3);
  _Unwind_Resume(a1);
}

float64x2_t LiGaussianBlur::getBoundary(uint64_t a1, uint64_t a2, float64x2_t *a3)
{
  uint64_t v5 = *(void *)(a1 + 16);
  if (!v5) {
    throw_PCNullPointerException(1);
  }
  if ((*(unsigned int (**)(uint64_t, uint64_t, float64x2_t *))(*(void *)v5 + 24))(v5, a2, a3))
  {
    float64x2_t v7 = vaddq_f64(*(float64x2_t *)(a1 + 40), *(float64x2_t *)(a1 + 40));
    float64x2_t v8 = vsubq_f64(*a3, v7);
    float64x2_t result = vsubq_f64(a3[1], vsubq_f64(vnegq_f64(v7), v7));
    *a3 = v8;
    a3[1] = result;
  }
  return result;
}

uint64_t LiGaussianBlur::getHelium@<X0>(LiGaussianBlur *this@<X0>, __n128 *a2@<X1>, void *a3@<X8>)
{
  if (LiAgent::haveROI((LiAgent *)a2))
  {
    LiAgent::getROI(a2, &v16);
    float v6 = *((double *)this + 5);
    BlurExtent = (LiHelium *)LiHelium::getBlurExtent(v7, v6);
    unsigned int v9 = BlurExtent;
    float v10 = *((double *)this + 6);
    unsigned int v11 = LiHelium::getBlurExtent(BlurExtent, v10);
    v16.n128_u32[0] -= v9;
    v16.n128_u32[1] -= v11;
    *(int32x2_t *)&v16.n128_i8[8] = vadd_s32(*(int32x2_t *)&v16.n128_i8[8], vadd_s32((int32x2_t)__PAIR64__(v11, v9), (int32x2_t)__PAIR64__(v11, v9)));
    LiAgent::setInputROI((uint64_t)a2, &v16);
  }
  uint64_t result = LiAgent::getHelium((LiAgent *)a2, *((LiImageSource **)this + 2), (uint64_t *)&v16);
  if (v16.n128_u64[0])
  {
    float v13 = *((double *)this + 5);
    float v14 = *((double *)this + 6);
    LiHelium::createBlurNode(v13, v14, &v15);
    (*(void (**)(HGBlur *, void, unint64_t))(*(void *)v15 + 120))(v15, 0, v16.n128_u64[0]);
    uint64_t result = v16.n128_u64[0];
    *a3 = v15;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
    }
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

void sub_1B7A8F078(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  if (a11) {
    (*(void (**)(uint64_t))(*(void *)a11 + 24))(a11);
  }
  _Unwind_Resume(exception_object);
}

void LiLightInfo::loadShadowSnippet(PCSharedCount *a1@<X8>)
{
  {
    PCString::PCString(&v4, "shadow");
    ProShade::Snippet::loadFromBundle((ProShade::Snippet *)&v4, v3);
  }
  a1->int var0 = (PC_Sp_counted_base *)LiLightInfo::loadShadowSnippet(void)::snippet;
  PCSharedCount::PCSharedCount(a1 + 1, (const PCSharedCount *)algn_1E9EE5CE8);
}

void sub_1B7A8F1AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

PCSharedCount *PCPtr<ProShade::Snippet>::~PCPtr(PCSharedCount *a1)
{
  return a1;
}

void LiLightInfo::LiLightInfo(LiLightInfo *this)
{
}

void sub_1B7A8F470(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, PCSharedCount *a14, PCSharedCount *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  LiPerContextValue<ProShade::SamplerNode::Binding>::~LiPerContextValue(v23);
  v22[93].int var0 = (PC_Sp_counted_base *)&unk_1F1119970;
  PCSharedCount::~PCSharedCount(v22 + 96);
  v22[89].int var0 = (PC_Sp_counted_base *)&unk_1F1119970;
  PCSharedCount::~PCSharedCount(v22 + 92);
  v22[85].int var0 = (PC_Sp_counted_base *)&unk_1F1119970;
  PCSharedCount::~PCSharedCount(v22 + 88);
  v22[81].int var0 = (PC_Sp_counted_base *)&unk_1F1119970;
  PCSharedCount::~PCSharedCount(v22 + 84);
  v22[77].int var0 = (PC_Sp_counted_base *)&unk_1F1119970;
  PCSharedCount::~PCSharedCount(v22 + 80);
  v22[73].int var0 = (PC_Sp_counted_base *)&unk_1F1119970;
  PCSharedCount::~PCSharedCount(v22 + 76);
  v22[69].int var0 = (PC_Sp_counted_base *)&unk_1F1119970;
  PCSharedCount::~PCSharedCount(v22 + 72);
  v22[65].int var0 = (PC_Sp_counted_base *)&unk_1F1119970;
  PCSharedCount::~PCSharedCount(v22 + 68);
  v22[61].int var0 = (PC_Sp_counted_base *)&unk_1F1119970;
  PCSharedCount::~PCSharedCount(v22 + 64);
  v22[57].int var0 = (PC_Sp_counted_base *)&unk_1F1119970;
  PCSharedCount::~PCSharedCount(v22 + 60);
  ProShade::Sampler::~Sampler(v24);
  ProShade::Sampler::~Sampler(a14);
  ProShade::Sampler::~Sampler(a15);
  v22[16].int var0 = (PC_Sp_counted_base *)&unk_1F1119970;
  PCSharedCount::~PCSharedCount(v22 + 19);
  v22[12].int var0 = (PC_Sp_counted_base *)&unk_1F1119970;
  PCSharedCount::~PCSharedCount(v22 + 15);
  v22[8].int var0 = (PC_Sp_counted_base *)&unk_1F1119970;
  PCSharedCount::~PCSharedCount(v22 + 11);
  v22[4].int var0 = (PC_Sp_counted_base *)&unk_1F1119970;
  PCSharedCount::~PCSharedCount(v22 + 7);
  v22->int var0 = (PC_Sp_counted_base *)&unk_1F1119970;
  PCSharedCount::~PCSharedCount(v22 + 3);
  _Unwind_Resume(a1);
}

uint64_t LiLightInfo::get(LiLightInfo *this)
{
  int v1 = (int)this;
  {
    PCMutex::PCMutex(&LiLightInfo::get(int,BOOL)::g_lightListLock);
    __cxa_atexit((void (*)(void *))PCMutex::~PCMutex, &LiLightInfo::get(int,BOOL)::g_lightListLock, &dword_1B73F3000);
  }
  uint64_t v2 = (PCArray_base *)PCMutex::lock(&LiLightInfo::get(int,BOOL)::g_lightListLock);
  {
    if (v2) {
      ProShade::SamplerT<3553,false,false,false>::SamplerT();
    }
  }
  {
    if (v2)
    {
      qword_1E9EE5DB8 = 0;
      qword_1E9EE5DC0 = 0;
      LiLightInfo::get(int,BOOL)::lightInfo = (uint64_t)&unk_1F111C090;
      __cxa_atexit((void (*)(void *))PCArray<LiLightInfo *,PCArray_Traits<LiLightInfo *>>::~PCArray, &LiLightInfo::get(int,BOOL)::lightInfo, &dword_1B73F3000);
    }
  }
  if (SHIDWORD(qword_1E9EE5DB8) <= v1)
  {
    if ((int)qword_1E9EE5DB8 <= v1) {
      int v3 = (2 * (v1 + 1)) | 1;
    }
    else {
      int v3 = qword_1E9EE5DB8;
    }
    PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::resize((uint64_t)&LiLightInfo::get(int,BOOL)::lightInfo, v1 + 1, v3);
    operator new();
  }
  if (v1 < 0 || SHIDWORD(qword_1E9EE5DB8) <= v1) {
    PCArray_base::badIndex(v2);
  }
  uint64_t v4 = *(void *)(qword_1E9EE5DC0 + 8 * v1);
  if (&LiLightInfo::get(int,BOOL)::g_lightListLock) {
    PCMutex::unlock(&LiLightInfo::get(int,BOOL)::g_lightListLock);
  }
  return v4;
}

void sub_1B7A90358(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t LiLightInfo::get(LiLightInfo *this, const LiLight *a2)
{
  SolidSceneID = (LiLightInfo *)LiLight::getSolidSceneID(this);

  return LiLightInfo::get(SolidSceneID);
}

uint64_t PCArray<LiLightInfo *,PCArray_Traits<LiLightInfo *>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111C090;
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2 < 0) {
    int v3 = 1;
  }
  else {
    int v3 = v2 & ~(v2 >> 31);
  }
  if (v3 == v2)
  {
    uint64_t v4 = *(int *)(a1 + 12);
    if ((v4 & 0x80000000) != 0)
    {
      do
        *(void *)(*(void *)(a1 + 16) + 8 * v4) = 0;
      while (!__CFADD__(v4++, 1));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6) {
      MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = 0;
  uint64_t v7 = *(void *)(a1 + 16);
  if (v7) {
    MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

uint64_t LiClipPlaneInfo::get(LiClipPlaneInfo *this)
{
  int v1 = (int)this;
  {
    if (this)
    {
      qword_1E9EE5DD8 = 0;
      qword_1E9EE5DE0 = 0;
      LiClipPlaneInfo::get(int)::planes = (uint64_t)&unk_1F111C0C8;
      __cxa_atexit((void (*)(void *))PCArray<LiClipPlaneInfo,PCArray_Traits<LiClipPlaneInfo>>::~PCArray, &LiClipPlaneInfo::get(int)::planes, &dword_1B73F3000);
    }
  }
  if (SHIDWORD(qword_1E9EE5DD8) <= v1)
  {
    uint64_t v2 = SHIDWORD(qword_1E9EE5DD8);
    if ((int)qword_1E9EE5DD8 <= v1) {
      int v3 = (2 * (v1 + 1)) | 1;
    }
    else {
      int v3 = qword_1E9EE5DD8;
    }
    PCArray<LiClipPlaneInfo,PCArray_Traits<LiClipPlaneInfo>>::resize((uint64_t)&LiClipPlaneInfo::get(int)::planes, v1 + 1, v3);
    LiString::format((LiString *)"clipPlane_%d", (LiString *)&v6, v2);
    if ((v2 & 0x8000000000000000) == 0 && v2 < SHIDWORD(qword_1E9EE5DD8)) {
      operator new();
    }
    PCArray_base::badIndex(v4);
  }
  if (v1 < 0 || SHIDWORD(qword_1E9EE5DD8) <= v1) {
    PCArray_base::badIndex(this);
  }
  return qword_1E9EE5DE0 + 32 * v1;
}

void sub_1B7A9076C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, atomic_uint *a10)
{
  MEMORY[0x1BA9BFBA0](v10, 0x10B1C402CAA7C2BLL);
  if (a10)
  {
    if (atomic_fetch_add(a10 - 3, 0xFFFFFFFF) == 1)
    {
      *(unsigned char *)a10 = 0;
      free(a10 - 3);
    }
  }
  _Unwind_Resume(a1);
}

uint64_t PCArray<LiClipPlaneInfo,PCArray_Traits<LiClipPlaneInfo>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111C0C8;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<LiClipPlaneInfo,PCArray_Traits<LiClipPlaneInfo>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

PCSharedCount *ProShade::External::External(PCSharedCount *this)
{
  this->int var0 = 0;
  int v2 = this + 2;
  PCSharedCount::PCSharedCount(this + 1);
  PCSharedCount::PCSharedCount(v2);
  this[5].int var0 = 0;
  this[6].int var0 = 0;
  this[4].int var0 = (PC_Sp_counted_base *)&unk_1F111C058;
  return this;
}

void sub_1B7A908B8(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1);
  _Unwind_Resume(a1);
}

void ProShade::External::~External(ProShade::External *this)
{
  int v2 = (char *)this + 32;
  *((void *)this + 4) = &unk_1F111C058;
  if (*((int *)this + 10) < 0) {
    int v3 = 1;
  }
  else {
    int v3 = *((_DWORD *)this + 10);
  }
  PCArray<ProShade::External::Argument,PCArray_Traits<ProShade::External::Argument>>::resize((uint64_t)v2, 0, v3);
  uint64_t v4 = *((void *)this + 6);
  if (v4) {
    MEMORY[0x1BA9BFB70](v4, 0x1000C8077774924);
  }
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 10) = 0;
  PCString::~PCString((PCString *)this + 2);
  PCSharedCount::~PCSharedCount((PCSharedCount *)this + 1);
}

void ProShade::SamplerT<3553,false,false,false>::SamplerT()
{
}

void sub_1B7A909D4(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C402A26BE84);
  _Unwind_Resume(a1);
}

uint64_t ProShade::SamplerT<3553,false,false,false>::target()
{
  return 3553;
}

void ProShade::SamplerT<34067,true,false,false>::SamplerT()
{
}

void sub_1B7A90A78(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C402A26BE84);
  _Unwind_Resume(a1);
}

uint64_t ProShade::SamplerT<34067,true,false,false>::target()
{
  return 34067;
}

uint64_t PCArray<ProShade::External::Argument,PCArray_Traits<ProShade::External::Argument>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111C058;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<ProShade::External::Argument,PCArray_Traits<ProShade::External::Argument>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

void PCArray<ProShade::External::Argument,PCArray_Traits<ProShade::External::Argument>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111C058;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<ProShade::External::Argument,PCArray_Traits<ProShade::External::Argument>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

_OWORD *std::__tree<std::__value_type<LiOpenGLContextGetter::C,BOOL>,std::__map_value_compare<LiOpenGLContextGetter::C,std::__value_type<LiOpenGLContextGetter::C,BOOL>,LiOpenGLContextGetter::Compare,true>,std::allocator<std::__value_type<LiOpenGLContextGetter::C,BOOL>>>::__emplace_unique_key_args<LiOpenGLContextGetter::C,std::piecewise_construct_t const&,std::tuple<LiOpenGLContextGetter::C const&>,std::tuple<>>(uint64_t **a1, uint64_t *a2, uint64_t a3, _OWORD **a4)
{
  uint64_t v6 = (void **)std::__tree<std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>,std::__map_value_compare<LiOpenGLContextGetter::C,std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>,LiOpenGLContextGetter::Compare,true>,std::allocator<std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>>>::__find_equal<LiOpenGLContextGetter::C>((uint64_t)a1, &v10, a2);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    float64x2_t v8 = (uint64_t **)v6;
    uint64_t v7 = operator new(0x38uLL);
    v7[2] = **a4;
    *((unsigned char *)v7 + 48) = 0;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v10, v8, (uint64_t *)v7);
  }
  return v7;
}

void PCArray<LiLightInfo *,PCArray_Traits<LiLightInfo *>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111C090;
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2 < 0) {
    int v3 = 1;
  }
  else {
    int v3 = v2 & ~(v2 >> 31);
  }
  if (v3 == v2)
  {
    uint64_t v4 = *(int *)(a1 + 12);
    if ((v4 & 0x80000000) != 0)
    {
      do
        *(void *)(*(void *)(a1 + 16) + 8 * v4) = 0;
      while (!__CFADD__(v4++, 1));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6) {
      MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = 0;
  uint64_t v7 = *(void *)(a1 + 16);
  if (v7) {
    MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

void PCArray<LiClipPlaneInfo,PCArray_Traits<LiClipPlaneInfo>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111C0C8;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<LiClipPlaneInfo,PCArray_Traits<LiClipPlaneInfo>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

void PCArray<LiClipPlaneInfo,PCArray_Traits<LiClipPlaneInfo>>::resize(uint64_t a1, int a2, int a3)
{
  if (a3 <= a2) {
    int v3 = a2;
  }
  else {
    int v3 = a3;
  }
  if (a2 < 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v18, "PCArray::resize");
    PCException::PCException(exception, &v18);
    *(void *)exception = &unk_1F1199218;
  }
  if (v3 == *(_DWORD *)(a1 + 8))
  {
    int v6 = *(_DWORD *)(a1 + 12);
    if (a2 >= v6)
    {
      if (a2 > v6) {
        ProShade::Uniform::Uniform();
      }
    }
    else
    {
      uint64_t v7 = 32 * a2;
      uint64_t v8 = a2;
      do
      {
        uint64_t v9 = *(void *)(a1 + 16);
        *(void *)(v9 + v7) = &unk_1F1119970;
        PCSharedCount::~PCSharedCount((PCSharedCount *)(v9 + v7 + 24));
        ++v8;
        v7 += 32;
      }
      while (v8 < *(int *)(a1 + 12));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    int v10 = *(_DWORD *)(a1 + 12);
    if (a2 >= v10) {
      int v11 = *(_DWORD *)(a1 + 12);
    }
    else {
      int v11 = a2;
    }
    if (v11 < 1)
    {
      int v11 = 0;
    }
    else
    {
      int v12 = 0;
      do
      {
        ProShade::VarT<ProShade::UniformNode>::VarT(v12, *(PCShared_base **)((char *)&v12[2].var0 + *(void *)(a1 + 16)))->int var0 = (PC_Sp_counted_base *)&unk_1F1119B88;
        uint64_t v13 = *(void *)(a1 + 16);
        *(PC_Sp_counted_base **)((char *)&v12->var0 + v13) = (PC_Sp_counted_base *)&unk_1F1119970;
        PCSharedCount::~PCSharedCount((PCSharedCount *)((char *)v12 + v13 + 24));
        v12 += 4;
      }
      while ((PCSharedCount *)(32 * v11) != v12);
      int v10 = *(_DWORD *)(a1 + 12);
    }
    if (v11 < v10)
    {
      uint64_t v14 = 32 * v11;
      do
      {
        uint64_t v15 = *(void *)(a1 + 16);
        *(void *)(v15 + v14) = &unk_1F1119970;
        PCSharedCount::~PCSharedCount((PCSharedCount *)(v15 + v14 + 24));
        v14 += 32;
        ++v11;
      }
      while (*(_DWORD *)(a1 + 12) > v11);
    }
    if (v11 < a2) {
      ProShade::Uniform::Uniform();
    }
    uint64_t v16 = *(void *)(a1 + 16);
    if (v16) {
      MEMORY[0x1BA9BFB70](v16, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = a2;
}

void sub_1B7A910A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

ProShade::Node *ProShade::InputNode::InputNode(ProShade::Node *a1, uint64_t *a2, int a3, int a4, int a5)
{
  uint64_t result = ProShade::Node::Node(a1, a2 + 1);
  uint64_t v10 = *a2;
  *(void *)uint64_t result = *a2;
  *(void *)((char *)result + *(void *)(v10 - 24)) = a2[5];
  *((_DWORD *)result + 6) = a3;
  *((_DWORD *)result + 7) = a4;
  *((_DWORD *)result + 10) = 0;
  *((_DWORD *)result + 12) = atomic_fetch_add(ProShade::s_serial, 1u) + 1;
  *((_DWORD *)result + 13) = a5;
  return result;
}

_DWORD *ProShade::InputNode::InputNode(_DWORD *a1, uint64_t *a2, uint64_t *a3, int a4, int a5, int a6)
{
  int v12 = ProShade::Node::Node((ProShade::Node *)a1, a2 + 1);
  uint64_t v13 = *a2;
  *(void *)int v12 = *a2;
  *(void *)((char *)a1 + *(void *)(v13 - 24)) = a2[5];
  a1[13] = a6;
  if (a1 + 8 != (_DWORD *)a3)
  {
    LiString::dec((LiString *)(a1 + 8));
    uint64_t v14 = *a3;
    *((void *)a1 + 4) = *a3;
    if (v14) {
      atomic_fetch_add((atomic_uint *volatile)(v14 - 12), 1u);
    }
  }
  a1[6] = a4;
  a1[7] = a5;
  a1[10] = 0;
  a1[12] = atomic_fetch_add(ProShade::s_serial, 1u) + 1;
  return a1;
}

void sub_1B7A912EC(_Unwind_Exception *a1)
{
  ProShade::Node::~Node(v1, v2);
  _Unwind_Resume(a1);
}

uint64_t ProShade::InputNode::repr@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 32);
  *a2 = v2;
  if (v2) {
    atomic_fetch_add((atomic_uint *volatile)(v2 - 12), 1u);
  }
  return this;
}

void ProShade::InputNode::inputs(uint64_t a1, uint64_t a2)
{
  if (*(int *)(a2 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a2 + 8);
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a2, 0, v2);
}

PCSharedCount *ProShade::InputNode::apply@<X0>(PCShared_base *a1@<X0>, PCSharedCount *a2@<X8>)
{
  return ProShade::VarT<ProShade::Node>::VarT(a2, a1);
}

uint64_t ProShade::InputNode::atomic(ProShade::InputNode *this)
{
  return 1;
}

void ProShade::InputNode::computeValue(uint64_t a1)
{
  int v2 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA250], (uint64_t)"InputNodes (uniforms etc) shouldn't be asked for their value:", 61);
  if (*(void *)(a1 + 32)) {
    int v3 = *(const char **)(a1 + 32);
  }
  else {
    int v3 = "";
  }
  size_t v4 = strlen(v3);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, (uint64_t)v3, v4);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, (uint64_t)"\n", 1);
  exception = (PCException *)__cxa_allocate_exception(0x40uLL);
  PCString::PCString(&v6, "InputNodes (uniforms etc) shouldn't be asked for their value");
  PCException::PCException(exception, &v6);
}

void sub_1B7A9140C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

ProShade::Node *ProShade::UniformBaseNode::UniformBaseNode(ProShade::UniformBaseNode *this, uint64_t *a2)
{
  uint64_t result = ProShade::Node::Node(this, a2 + 2);
  uint64_t v4 = a2[1];
  *(void *)uint64_t result = v4;
  *(void *)((char *)result + *(void *)(v4 - 24)) = a2[6];
  *((void *)result + 6) = 0x400000000;
  uint64_t v5 = *a2;
  *(void *)uint64_t result = *a2;
  *(void *)((char *)result + *(void *)(v5 - 24)) = a2[7];
  return result;
}

PCSharedCount *ProShade::UniformNode::UniformNode(PCSharedCount *this)
{
  this[11].int var0 = (PC_Sp_counted_base *)&unk_1F1199AC8;
  this[12].int var0 = 0;
  LOBYTE(this[13].var0) = 1;
  ProShade::UniformBaseNode::UniformBaseNode((ProShade::UniformBaseNode *)this, (uint64_t *)off_1F111C1F0);
  this->int var0 = (PC_Sp_counted_base *)&unk_1F111C108;
  this[11].int var0 = (PC_Sp_counted_base *)&unk_1F111C1D0;
  this[7].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  this[9].int var0 = 0;
  PCSharedCount::PCSharedCount(this + 10);
  return this;
}

void sub_1B7A91644(_Unwind_Exception *a1)
{
  ProShade::InputNode::~InputNode((ProShade::InputNode *)v1, (uint64_t)off_1F111C1F8);
  *(void *)(v1 + 88) = v3;
  *(unsigned char *)(v1 + 104) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

uint64_t ProShade::UniformNode::UniformNode(uint64_t a1, int a2, int a3)
{
  *(void *)(a1 + 88) = &unk_1F1199AC8;
  *(void *)(a1 + 96) = 0;
  *(unsigned char *)(a1 + 104) = 1;
  ProShade::InputNode::InputNode((ProShade::Node *)a1, (uint64_t *)off_1F111C1F8, a2, a3, 4);
  *(void *)a1 = &unk_1F111C108;
  *(void *)(a1 + 88) = &unk_1F111C1D0;
  *(void *)(a1 + LiDepthSorter::stackSort((uint64_t)this + 56) = &unk_1F11193B8;
  *(void *)(a1 + 72) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 80));
  *(_DWORD *)(a1 + 40) = 1;
  LiString::LiString((LiString *)&v14, "_u");
  LiString::format((LiString *)*(unsigned int *)(a1 + 48), (LiString *)&v13);
  uint64_t v4 = v14;
  if (v14) {
    int v5 = *((_DWORD *)v14 - 2);
  }
  else {
    int v5 = 0;
  }
  PCString v6 = v13;
  if (v13) {
    int v7 = *((_DWORD *)v13 - 2);
  }
  else {
    int v7 = 0;
  }
  uint64_t v8 = v7 + (uint64_t)v5;
  uint64_t v9 = (unsigned int *)malloc_type_malloc(v8 + 13, 0x8903763CuLL);
  v9[1] = v8;
  void v9[2] = v8 + 1;
  atomic_store(1u, v9);
  atomic_store(0, v9);
  memcpy(v9 + 3, v4, v5);
  memcpy((char *)v9 + v5 + 12, v6, v7);
  *((unsigned char *)v9 + v8 + 12) = 0;
  atomic_fetch_add((atomic_uint *volatile)v9, 1u);
  LiString::dec((LiString *)(a1 + 32));
  *(void *)(a1 + 32) = v9 + 3;
  atomic_fetch_add((atomic_uint *volatile)v9, 1u);
  if (atomic_fetch_add((atomic_uint *volatile)v9, 0xFFFFFFFF) == 1) {
    free(v9);
  }
  if (v13 && atomic_fetch_add((atomic_uint *volatile)v13 - 3, 0xFFFFFFFF) == 1)
  {
    *uint64_t v13 = 0;
    if (v13) {
      uint64_t v10 = v13 - 12;
    }
    else {
      uint64_t v10 = 0;
    }
    free(v10);
  }
  if (v14 && atomic_fetch_add((atomic_uint *volatile)v14 - 3, 0xFFFFFFFF) == 1)
  {
    *uint64_t v14 = 0;
    if (v14) {
      int v11 = v14 - 12;
    }
    else {
      int v11 = 0;
    }
    free(v11);
  }
  return a1;
}

void sub_1B7A918CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, PCSharedCount *a9, uint64_t a10, void *a11, uint64_t a12, atomic_uint *a13, atomic_uint *a14)
{
  if (atomic_fetch_add((atomic_uint *volatile)v16, 0xFFFFFFFF) == 1) {
    free(v16);
  }
  if (a13 && atomic_fetch_add(a13 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)a13 = 0;
    free(a13 - 3);
  }
  if (a14)
  {
    if (atomic_fetch_add(a14 - 3, 0xFFFFFFFF) == 1)
    {
      *(unsigned char *)a14 = 0;
      free(a14 - 3);
    }
  }
  *a11 = a10;
  PCSharedCount::~PCSharedCount(a9);
  ProShade::InputNode::~InputNode((ProShade::InputNode *)v14, (uint64_t)off_1F111C1F8);
  *(void *)(v14 + 88) = a12;
  *(unsigned char *)(v14 + 104) = 0;
  PCWeakCount::~PCWeakCount(v15);
  _Unwind_Resume(a1);
}

void sub_1B7A919B4()
{
}

uint64_t ProShade::UniformNode::UniformNode(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 88) = &unk_1F1199AC8;
  *(unsigned char *)(a1 + 104) = 1;
  uint64_t v5 = *(void *)(a3 + 16);
  if (!v5) {
    throw_PCNullPointerException(1);
  }
  ProShade::InputNode::InputNode((_DWORD *)a1, (uint64_t *)off_1F111C1F8, a2, *(_DWORD *)(v5 + 24), *(_DWORD *)(v5 + 28), 4);
  *(void *)a1 = &unk_1F111C108;
  *(void *)(a1 + 88) = &unk_1F111C1D0;
  *(void *)(a1 + LiDepthSorter::stackSort((uint64_t)this + 56) = &unk_1F11193B8;
  *(unsigned char *)(a1 + 64) = *(unsigned char *)(a3 + 8);
  *(void *)(a1 + 72) = *(void *)(a3 + 16);
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 80), (const PCSharedCount *)(a3 + 24));
  uint64_t v6 = *(void *)(a1 + 32);
  *(_DWORD *)(a1 + 40) = 1;
  if (!v6 || !*(_DWORD *)(v6 - 8))
  {
    LiString::LiString((LiString *)&v17, "_u");
    LiString::format((LiString *)*(unsigned int *)(a1 + 48), (LiString *)&v16);
    int v7 = v17;
    if (v17) {
      int v8 = *((_DWORD *)v17 - 2);
    }
    else {
      int v8 = 0;
    }
    uint64_t v9 = v16;
    if (v16) {
      int v10 = *((_DWORD *)v16 - 2);
    }
    else {
      int v10 = 0;
    }
    uint64_t v11 = v10 + (uint64_t)v8;
    int v12 = (unsigned int *)malloc_type_malloc(v11 + 13, 0x8903763CuLL);
    v12[1] = v11;
    float64x2_t v12[2] = v11 + 1;
    atomic_store(1u, v12);
    atomic_store(0, v12);
    memcpy(v12 + 3, v7, v8);
    memcpy((char *)v12 + v8 + 12, v9, v10);
    *((unsigned char *)v12 + v11 + 12) = 0;
    atomic_fetch_add((atomic_uint *volatile)v12, 1u);
    LiString::dec((LiString *)(a1 + 32));
    *(void *)(a1 + 32) = v12 + 3;
    atomic_fetch_add((atomic_uint *volatile)v12, 1u);
    if (atomic_fetch_add((atomic_uint *volatile)v12, 0xFFFFFFFF) == 1) {
      free(v12);
    }
    if (v16 && atomic_fetch_add((atomic_uint *volatile)v16 - 3, 0xFFFFFFFF) == 1)
    {
      unsigned char *v16 = 0;
      if (v16) {
        uint64_t v13 = v16 - 12;
      }
      else {
        uint64_t v13 = 0;
      }
      free(v13);
    }
    if (v17 && atomic_fetch_add((atomic_uint *volatile)v17 - 3, 0xFFFFFFFF) == 1)
    {
      *long long v17 = 0;
      if (v17) {
        uint64_t v14 = v17 - 12;
      }
      else {
        uint64_t v14 = 0;
      }
      free(v14);
    }
  }
  return a1;
}

void sub_1B7A91C54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount *a10, uint64_t a11, void *a12, uint64_t a13, PC_Sp_counted_base **a14, atomic_uint *a15, atomic_uint *a16)
{
  if (atomic_fetch_add((atomic_uint *volatile)v17, 0xFFFFFFFF) == 1) {
    free(v17);
  }
  if (a15 && atomic_fetch_add(a15 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)a15 = 0;
    free(a15 - 3);
  }
  if (a16)
  {
    if (atomic_fetch_add(a16 - 3, 0xFFFFFFFF) == 1)
    {
      *(unsigned char *)a16 = 0;
      free(a16 - 3);
    }
  }
  *a12 = a11;
  PCSharedCount::~PCSharedCount(a10);
  ProShade::InputNode::~InputNode((ProShade::InputNode *)v16, (uint64_t)off_1F111C1F8);
  *(void *)(v16 + 88) = a13;
  *(unsigned char *)(v16 + 104) = 0;
  PCWeakCount::~PCWeakCount(a14);
  _Unwind_Resume(a1);
}

uint64_t ProShade::UniformNode::UniformNode(uint64_t a1, uint64_t *a2, int a3, int a4, int a5)
{
  *(void *)(a1 + 88) = &unk_1F1199AC8;
  *(void *)(a1 + 96) = 0;
  *(unsigned char *)(a1 + 104) = 1;
  ProShade::InputNode::InputNode((_DWORD *)a1, (uint64_t *)off_1F111C1F8, a2, a3, a4, a5);
  *(void *)a1 = &unk_1F111C108;
  *(void *)(a1 + 88) = &unk_1F111C1D0;
  *(void *)(a1 + LiDepthSorter::stackSort((uint64_t)this + 56) = &unk_1F11193B8;
  *(void *)(a1 + 72) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 80));
  uint64_t v6 = *(void *)(a1 + 32);
  *(_DWORD *)(a1 + 40) = 1;
  if (!v6 || !*(_DWORD *)(v6 - 8))
  {
    LiString::LiString((LiString *)&v17, "_u");
    LiString::format((LiString *)*(unsigned int *)(a1 + 48), (LiString *)&v16);
    int v7 = v17;
    if (v17) {
      int v8 = *((_DWORD *)v17 - 2);
    }
    else {
      int v8 = 0;
    }
    uint64_t v9 = v16;
    if (v16) {
      int v10 = *((_DWORD *)v16 - 2);
    }
    else {
      int v10 = 0;
    }
    uint64_t v11 = v10 + (uint64_t)v8;
    int v12 = (unsigned int *)malloc_type_malloc(v11 + 13, 0x8903763CuLL);
    v12[1] = v11;
    float64x2_t v12[2] = v11 + 1;
    atomic_store(1u, v12);
    atomic_store(0, v12);
    memcpy(v12 + 3, v7, v8);
    memcpy((char *)v12 + v8 + 12, v9, v10);
    *((unsigned char *)v12 + v11 + 12) = 0;
    atomic_fetch_add((atomic_uint *volatile)v12, 1u);
    LiString::dec((LiString *)(a1 + 32));
    *(void *)(a1 + 32) = v12 + 3;
    atomic_fetch_add((atomic_uint *volatile)v12, 1u);
    if (atomic_fetch_add((atomic_uint *volatile)v12, 0xFFFFFFFF) == 1) {
      free(v12);
    }
    if (v16 && atomic_fetch_add((atomic_uint *volatile)v16 - 3, 0xFFFFFFFF) == 1)
    {
      unsigned char *v16 = 0;
      if (v16) {
        uint64_t v13 = v16 - 12;
      }
      else {
        uint64_t v13 = 0;
      }
      free(v13);
    }
    if (v17 && atomic_fetch_add((atomic_uint *volatile)v17 - 3, 0xFFFFFFFF) == 1)
    {
      *long long v17 = 0;
      if (v17) {
        uint64_t v14 = v17 - 12;
      }
      else {
        uint64_t v14 = 0;
      }
      free(v14);
    }
  }
  return a1;
}

void sub_1B7A91FB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount *a10, uint64_t a11, void *a12, uint64_t a13, PC_Sp_counted_base **a14, atomic_uint *a15, atomic_uint *a16)
{
  if (atomic_fetch_add((atomic_uint *volatile)v17, 0xFFFFFFFF) == 1) {
    free(v17);
  }
  if (a15 && atomic_fetch_add(a15 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)a15 = 0;
    free(a15 - 3);
  }
  if (a16)
  {
    if (atomic_fetch_add(a16 - 3, 0xFFFFFFFF) == 1)
    {
      *(unsigned char *)a16 = 0;
      free(a16 - 3);
    }
  }
  *a12 = a11;
  PCSharedCount::~PCSharedCount(a10);
  ProShade::InputNode::~InputNode((ProShade::InputNode *)v16, (uint64_t)off_1F111C1F8);
  *(void *)(v16 + 88) = a13;
  *(unsigned char *)(v16 + 104) = 0;
  PCWeakCount::~PCWeakCount(a14);
  _Unwind_Resume(a1);
}

void *ProShade::UniformNode::description@<X0>(ProShade::UniformNode *this@<X0>, void *a2@<X8>)
{
  uint64_t v3 = (_DWORD *)*((void *)this + 4);
  if (v3) {
    int v4 = *(v3 - 2);
  }
  else {
    int v4 = 0;
  }
  size_t v5 = v4;
  uint64_t v6 = v4 + 8;
  int v7 = v4 + 9;
  int v8 = (char *)malloc_type_malloc(v4 + 21, 0x8903763CuLL);
  *((_DWORD *)v8 + 1) = v6;
  *((_DWORD *)v8 + 2) = v7;
  atomic_store(1u, (unsigned int *)v8);
  atomic_store(0, (unsigned int *)v8);
  *(void *)(v8 + 12) = 0x206D726F66696E75;
  uint64_t result = memcpy(v8 + 20, v3, v5);
  v8[v6 + 12] = 0;
  *a2 = v8 + 12;
  atomic_fetch_add((atomic_uint *volatile)v8, 1u);
  return result;
}

void ProShade::UniformNode::shortDescription(LiString *a1@<X8>)
{
}

int8x8_t *ProShade::UniformNode::computeHash(ProShade::UniformNode *this, int8x8_t *a2)
{
  PCHashWriteStream::writeValue(a2, "UniformNode");
  int v4 = (char *)*((void *)this + 4);
  if (v4)
  {
    size_t v5 = *((unsigned int *)v4 - 2);
  }
  else
  {
    size_t v5 = 0;
    int v4 = "";
  }

  return PCHashWriteStream::writeData(a2, v4, v5);
}

void ProShade::UniformNode::clone(ProShade::UniformNode *this)
{
}

void sub_1B7A92208(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C402CAA7C2BLL);
  _Unwind_Resume(a1);
}

void ProShade::UniformNode::~UniformNode(PCSharedCount *this)
{
  this->int var0 = (PC_Sp_counted_base *)&unk_1F111C108;
  this[11].int var0 = (PC_Sp_counted_base *)&unk_1F111C1D0;
  this[7].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(this + 10);
  ProShade::InputNode::~InputNode((ProShade::InputNode *)this, (uint64_t)off_1F111C1F8);
  this[11].int var0 = (PC_Sp_counted_base *)&unk_1F1199AC8;
  LOBYTE(this[13].var0) = 0;
  PCWeakCount::~PCWeakCount(&this[12].var0);
}

{
  uint64_t vars8;

  this->int var0 = (PC_Sp_counted_base *)&unk_1F111C108;
  this[11].int var0 = (PC_Sp_counted_base *)&unk_1F111C1D0;
  this[7].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(this + 10);
  ProShade::InputNode::~InputNode((ProShade::InputNode *)this, (uint64_t)off_1F111C1F8);
  this[11].int var0 = (PC_Sp_counted_base *)&unk_1F1199AC8;
  LOBYTE(this[13].var0) = 0;
  PCWeakCount::~PCWeakCount(&this[12].var0);

  JUMPOUT(0x1BA9BFBA0);
}

BOOL ProShade::UniformNode::hasSource(ProShade::UniformNode *this)
{
  return ((*(uint64_t (**)(ProShade::UniformNode *))(*(void *)this + 136))(this) & 1) != 0
      || *((void *)this + 9) != 0;
}

void ProShade::UniformNode::sourceNode(ProShade::UniformNode *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = &unk_1F11193B8;
  *(unsigned char *)(a2 + 8) = *((unsigned char *)this + 64);
  *(void *)(a2 + 16) = *((void *)this + 9);
  PCSharedCount::PCSharedCount((PCSharedCount *)(a2 + 24), (const PCSharedCount *)this + 10);
}

void virtual thunk to'ProShade::UniformNode::~UniformNode(ProShade::UniformNode *this)
{
  uint64_t v1 = (PCSharedCount *)((char *)this + *(void *)(*(void *)this - 24));
  v1->int var0 = (PC_Sp_counted_base *)&unk_1F111C108;
  v1[11].int var0 = (PC_Sp_counted_base *)&unk_1F111C1D0;
  v1[7].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v1 + 10);
  ProShade::InputNode::~InputNode((ProShade::InputNode *)v1, (uint64_t)off_1F111C1F8);
  v1[11].int var0 = (PC_Sp_counted_base *)&unk_1F1199AC8;
  LOBYTE(v1[13].var0) = 0;

  PCWeakCount::~PCWeakCount(&v1[12].var0);
}

{
  PCSharedCount *v1;
  uint64_t vars8;

  uint64_t v1 = (PCSharedCount *)((char *)this + *(void *)(*(void *)this - 24));
  v1->int var0 = (PC_Sp_counted_base *)&unk_1F111C108;
  v1[11].int var0 = (PC_Sp_counted_base *)&unk_1F111C1D0;
  v1[7].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v1 + 10);
  ProShade::InputNode::~InputNode((ProShade::InputNode *)v1, (uint64_t)off_1F111C1F8);
  v1[11].int var0 = (PC_Sp_counted_base *)&unk_1F1199AC8;
  LOBYTE(v1[13].var0) = 0;
  PCWeakCount::~PCWeakCount(&v1[12].var0);

  JUMPOUT(0x1BA9BFBA0);
}

void LiImageFilterChain::~LiImageFilterChain(PCSharedCount *this)
{
  int v2 = this + 2;
  this[2].int var0 = (PC_Sp_counted_base *)&unk_1F10AD6B0;
  if (SLODWORD(this[3].var0) < 0) {
    int var0 = 1;
  }
  else {
    int var0 = (int)this[3].var0;
  }
  PCArray<PCPtr<LiImageFilter>,PCArray_Traits<PCPtr<LiImageFilter>>>::resize((uint64_t)v2, 0, var0);
  int v4 = this[4].var0;
  if (v4) {
    MEMORY[0x1BA9BFB70](v4, 0x1000C8077774924);
  }
  this[4].int var0 = 0;
  LODWORD(this[3].var0) = 0;
  PCSharedCount::~PCSharedCount(this + 1);
}

void LiGeode::LiGeode(LiGeode *this, LiImageSource *a2)
{
  *((void *)this + 92) = &unk_1F1199AC8;
  *((void *)this + 93) = 0;
  *((unsigned char *)this + 752) = 1;
  LiSceneObject::LiSceneObject(this, (uint64_t *)&off_1F111C720);
  *(void *)this = &unk_1F111C5C0;
  *((void *)this + 92) = &unk_1F111C700;
  *((void *)this + 71) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 72);
  *((unsigned char *)this + 584) = 0;
  *((void *)this + 74) = a2;
  if (a2) {
    int v4 = (PCShared_base *)((char *)a2 + *(void *)(*(void *)a2 - 24));
  }
  else {
    int v4 = 0;
  }
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 75, v4);
  LiImageFilterChain::LiImageFilterChain((LiGeode *)((char *)this + 608));
  __asm { FMOV            V1.2D, #-1.0 }
  *((_OWORD *)this + 44) = 0u;
  *((_OWORD *)this + 45) = _Q1;
  if (!(*(unsigned int (**)(LiImageSource *))(*(void *)a2 + 80))(a2)) {
    (*(void (**)(LiImageSource *, uint64_t))(*(void *)a2 + 88))(a2, 1);
  }
  *((void *)this + 86) = 0;
  *((void *)this + 81) = 0;
  *((void *)this + 83) = 0;
  *((void *)this + 82) = 0;
  *((void *)this + 84) = 0x3FFCCCCCCCCCCCCDLL;
  *((_DWORD *)this + 174) = 16843009;
  *((_DWORD *)this + 175) = 2;
}

void sub_1B7A92850(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v4);
  PCSharedCount::~PCSharedCount(v3);
  LiSceneObject::~LiSceneObject((PCSharedCount *)v1, (PC_Sp_counted_base **)&off_1F111C720);
  *(void *)(v1 + 736) = v2;
  *(unsigned char *)(v1 + 752) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 744));
  _Unwind_Resume(a1);
}

void LiGeode::~LiGeode(PCSharedCount *this, PCSharedCount *a2)
{
  int var0 = a2->var0;
  this->int var0 = a2->var0;
  *(PCSharedCount *)((char *)this + *((void *)var0 - 3)) = a2[5];
  size_t v5 = this + 78;
  this[78].int var0 = (PC_Sp_counted_base *)&unk_1F10AD6B0;
  if (SLODWORD(this[79].var0) < 0) {
    int v6 = 1;
  }
  else {
    int v6 = (int)this[79].var0;
  }
  PCArray<PCPtr<LiImageFilter>,PCArray_Traits<PCPtr<LiImageFilter>>>::resize((uint64_t)v5, 0, v6);
  int v7 = this[80].var0;
  if (v7) {
    MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
  }
  this[80].int var0 = 0;
  LODWORD(this[79].var0) = 0;
  PCSharedCount::~PCSharedCount(this + 77);
  PCSharedCount::~PCSharedCount(this + 75);
  PCSharedCount::~PCSharedCount(this + 72);

  LiSceneObject::~LiSceneObject(this, &a2[1].var0);
}

void LiGeode::~LiGeode(PCSharedCount *this)
{
  *(void *)(v1 + 736) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 752) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 744));
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)(v1 + 736) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 752) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 744));

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'LiGeode::~LiGeode(LiGeode *this)
{
  *(void *)(v1 + 736) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 752) = 0;
  uint64_t v2 = (PC_Sp_counted_base **)(v1 + 744);

  PCWeakCount::~PCWeakCount(v2);
}

{
  LiGeode::~LiGeode((PCSharedCount *)((char *)this + *(void *)(*(void *)this - 24)));
}

void LiGeode::position()
{
  exception = (PCException *)__cxa_allocate_exception(0x40uLL);
  PCString::PCString(&v2, "subclass must implement");
  PCString::PCString(&v1, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/LiGeode.cpp");
  PCException::PCException(exception, &v2, &v1, 52);
  *(void *)exception = &unk_1F10B1208;
}

void sub_1B7A92BEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString((PCString *)&a9);
  PCString::~PCString(&a10);
  if (v11) {
    __cxa_free_exception(v10);
  }
  _Unwind_Resume(a1);
}

int8x16_t LiGeode::plane@<Q0>(LiGeode *this@<X0>, int8x16_t *a2@<X8>)
{
  unsigned int v2 = *((unsigned char *)this + 541) == 0;
  a2->i64[0] = 0;
  a2->i64[1] = 0;
  int32x2_t v3 = vdup_n_s32(v2);
  v4.i64[0] = v3.u32[0];
  v4.i64[1] = v3.u32[1];
  int8x16_t result = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v4, 0x3FuLL)), (int8x16_t)xmmword_1B7E733D0, (int8x16_t)xmmword_1B7E733E0);
  a2[1] = result;
  return result;
}

void LiGeode::normal(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0x3FF0000000000000;
}

void LiGeode::cast()
{
  exception = (PCException *)__cxa_allocate_exception(0x40uLL);
  PCString::PCString(&v2, "not implemented yet");
  PCString::PCString(&v1, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/LiGeode.cpp");
  PCException::PCException(exception, &v2, &v1, 70);
  *(void *)exception = &unk_1F10B1208;
}

void sub_1B7A92D18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString((PCString *)&a9);
  PCString::~PCString(&a10);
  if (v11) {
    __cxa_free_exception(v10);
  }
  _Unwind_Resume(a1);
}

void LiGeode::texture(const PCSharedCount *this@<X0>, const void **a2@<X1>, PCSharedCount *a3@<X8>)
{
  if (!*a2 || strcmp((const char *)*a2, "color"))
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    operator+("no such texture: ", a2, &v8);
    if (v8) {
      int v7 = v8;
    }
    else {
      int v7 = "";
    }
    PCString::PCString(&v9, v7);
    PCException::PCException(exception, &v9);
    *(void *)exception = &unk_1F1199218;
  }
  a3->int var0 = this[74].var0;

  PCSharedCount::PCSharedCount(a3 + 1, this + 75);
}

void sub_1B7A92E58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, atomic_uint *a9, PCString a10)
{
  PCString::~PCString(&a10);
  if (a9 && atomic_fetch_add(a9 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)a9 = 0;
    free(a9 - 3);
    if ((v11 & 1) == 0) {
LABEL_7:
    }
      _Unwind_Resume(a1);
  }
  else if (!v11)
  {
    goto LABEL_7;
  }
  __cxa_free_exception(v10);
  goto LABEL_7;
}

void *operator+@<X0>(unsigned char *a1@<X0>, const void **a2@<X1>, void *a3@<X8>)
{
  if (*a1)
  {
    uint64_t v5 = 0;
    while (a1[++v5])
      ;
  }
  else
  {
    LODWORD(v5) = 0;
  }
  int v7 = *a2;
  if (*a2) {
    int v8 = *(v7 - 2);
  }
  else {
    int v8 = 0;
  }
  size_t v9 = v8;
  uint64_t v10 = v8 + (uint64_t)(int)v5;
  int v11 = (unsigned int *)malloc_type_malloc(v10 + 13, 0x8903763CuLL);
  v11[1] = v10;
  std::locale v11[2] = v10 + 1;
  atomic_store(1u, v11);
  atomic_store(0, v11);
  memcpy(v11 + 3, a1, (int)v5);
  int8x16_t result = memcpy((char *)v11 + (int)v5 + 12, v7, v9);
  *((unsigned char *)v11 + v10 + 12) = 0;
  *a3 = v11 + 3;
  atomic_fetch_add((atomic_uint *volatile)v11, 1u);
  return result;
}

void LiGeode::texture(const PCSharedCount *this@<X0>, PCSharedCount *a2@<X8>)
{
  a2->int var0 = this[74].var0;
  PCSharedCount::PCSharedCount(a2 + 1, this + 75);
}

uint64_t LiGeode::setTexture(LiGeode *this, const void **a2, LiImageSource *a3)
{
  if (!(*(unsigned int (**)(LiImageSource *))(*(void *)a3 + 80))(a3)) {
    (*(void (**)(LiImageSource *, uint64_t))(*(void *)a3 + 88))(a3, 1);
  }
  if (!*a2 || strcmp((const char *)*a2, "color"))
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    operator+("no such texture: ", a2, &v10);
    if (v10) {
      size_t v9 = v10;
    }
    else {
      size_t v9 = "";
    }
    PCString::PCString(&v11, v9);
    PCException::PCException(exception, &v11);
    *(void *)exception = &unk_1F1199218;
  }
  int v6 = *(uint64_t (**)(LiGeode *, LiImageSource *))(*(void *)this + 176);

  return v6(this, a3);
}

void sub_1B7A93134(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, atomic_uint *a9, PCString a10)
{
  PCString::~PCString(&a10);
  if (a9 && atomic_fetch_add(a9 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)a9 = 0;
    free(a9 - 3);
    if ((v11 & 1) == 0) {
LABEL_7:
    }
      _Unwind_Resume(a1);
  }
  else if (!v11)
  {
    goto LABEL_7;
  }
  __cxa_free_exception(v10);
  goto LABEL_7;
}

PCShared_base **LiGeode::setTexture(PCShared_base **this, LiImageSource *a2)
{
  return PCPtr<LiImageSource>::operator=<LiImageSource>(this + 74, (PCShared_base *)a2);
}

double LiGeode::reflectivity(LiGeode *this)
{
  return *((double *)this + 81);
}

uint64_t LiGeode::setReflectivity(uint64_t this, double a2)
{
  *(double *)(this + 648) = a2;
  return this;
}

double LiGeode::reflectionBlur(LiGeode *this)
{
  return *((double *)this + 86);
}

uint64_t LiGeode::setReflectionBlur(uint64_t this, double a2)
{
  *(double *)(this + 688) = a2;
  return this;
}

double LiGeode::getReflectionBeginLimit(LiGeode *this)
{
  return *((double *)this + 82);
}

uint64_t LiGeode::setReflectionBeginLimit(uint64_t this, double a2)
{
  *(double *)(this + 6LiDepthSorter::stackSort((uint64_t)this + 56) = a2;
  return this;
}

double LiGeode::getReflectionEndLimit(LiGeode *this)
{
  return *((double *)this + 83);
}

uint64_t LiGeode::setReflectionEndLimit(uint64_t this, double a2)
{
  *(double *)(this + 664) = a2;
  return this;
}

double LiGeode::getReflectionFalloffExponent(LiGeode *this)
{
  return *((double *)this + 84);
}

uint64_t LiGeode::setReflectionFalloffExponent(uint64_t this, double a2)
{
  *(double *)(this + 672) = a2;
  return this;
}

uint64_t LiGeode::localBoundingBox(uint64_t a1, uint64_t a2)
{
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  int v26 = &unk_1F111C8A8;
  int32x2_t v3 = (PCArray_base *)(*(uint64_t (**)(uint64_t, void **))(*(void *)a1 + 136))(a1, &v26);
  *(_OWORD *)(a2 + 16) = xmmword_1B7E736F0;
  *(_OWORD *)(a2 + 32) = xmmword_1B7E736F0;
  *(_OWORD *)a2 = xmmword_1B7E736F0;
  uint64_t v4 = HIDWORD(v27);
  if (SHIDWORD(v27) >= 1)
  {
    uint64_t v5 = 0;
    double v6 = 1.0;
    double v7 = -1.0;
    uint64_t v8 = 8;
    do
    {
      if (v5 >= SHIDWORD(v27)) {
        PCArray_base::badIndex(v3);
      }
      uint64_t v9 = v28;
      uint64_t v10 = (double *)(v28 + v8);
      if (v6 <= v7
        && (v12 = *(double *)(a2 + 16), double v11 = *(double *)(a2 + 24), v12 <= v11)
        && (v14 = *(double *)(a2 + 32), double v13 = *(double *)(a2 + 40), v14 <= v13))
      {
        double v17 = *(v10 - 1);
        if (v6 >= v17) {
          double v6 = *(v10 - 1);
        }
        if (v7 <= v17) {
          double v7 = *(v10 - 1);
        }
        *(double *)a2 = v6;
        *(double *)(a2 + 8) = v7;
        PCString v18 = (double *)(v9 + v8);
        if (v12 >= *v18) {
          double v12 = *v18;
        }
        if (v11 <= *v18) {
          double v11 = *v18;
        }
        *(double *)(a2 + 16) = v12;
        *(double *)(a2 + 24) = v11;
        double v19 = v18[1];
        if (v14 >= v19) {
          double v14 = v18[1];
        }
        if (v13 <= v19) {
          double v13 = v18[1];
        }
        *(double *)(a2 + 32) = v14;
        *(double *)(a2 + 40) = v13;
      }
      else
      {
        double v7 = *(v10 - 1);
        *(double *)a2 = v7;
        *(double *)(a2 + 8) = v7;
        double v15 = *v10;
        *(double *)(a2 + 16) = *v10;
        *(double *)(a2 + 24) = v15;
        uint64_t v16 = *((void *)v10 + 1);
        *(void *)(a2 + 32) = v16;
        *(void *)(a2 + 40) = v16;
        double v6 = v7;
      }
      ++v5;
      v8 += 24;
    }
    while (v4 != v5);
  }
  int v26 = &unk_1F111C8A8;
  if ((int)v27 < 0) {
    unsigned int v20 = 1;
  }
  else {
    unsigned int v20 = v27 & ~((int)v27 >> 31);
  }
  if (v20 == v27)
  {
    uint64_t v21 = SHIDWORD(v27);
    if (v27 < 0)
    {
      uint64_t v22 = 24 * SHIDWORD(v27);
      do
      {
        uint64_t v23 = (void *)(v28 + v22);
        *uint64_t v23 = 0;
        v23[1] = 0;
        v23[2] = 0;
        v22 += 24;
      }
      while (!__CFADD__(v21++, 1));
    }
  }
  else
  {
    if (v20) {
      operator new[]();
    }
    if (v28) {
      MEMORY[0x1BA9BFB70](v28, 0x1000C8077774924);
    }
    uint64_t v28 = 0;
  }
  uint64_t v27 = v20;
  uint64_t result = v28;
  if (v28) {
    return MEMORY[0x1BA9BFB70](v28, 0x1000C8077774924);
  }
  return result;
}

void sub_1B7A93438(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCArray<PCVector3<double>,PCArray_Traits<PCVector3<double>>>::~PCArray((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t PCArray<PCVector3<double>,PCArray_Traits<PCVector3<double>>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111C8A8;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<PCVector3<double>,PCArray_Traits<PCVector3<double>>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

uint64_t LiGeode::boundingBox(uint64_t a1, double *a2, double *a3)
{
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  long long v30 = &unk_1F111C8A8;
  uint64_t v5 = (double *)(*(uint64_t (**)(uint64_t, void **))(*(void *)a1 + 136))(a1, &v30);
  *((_OWORD *)a2 + 1) = xmmword_1B7E736F0;
  *((_OWORD *)a2 + 2) = xmmword_1B7E736F0;
  *(_OWORD *)a2 = xmmword_1B7E736F0;
  uint64_t v6 = HIDWORD(v31);
  if (SHIDWORD(v31) >= 1)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 16;
    do
    {
      if (v7 >= SHIDWORD(v31)) {
        PCArray_base::badIndex((PCArray_base *)v5);
      }
      long long v28 = *(_OWORD *)(v32 + v8 - 16);
      double v29 = *(double *)(v32 + v8);
      uint64_t v5 = PCMatrix44Tmpl<double>::transform<double>(a3, (double *)&v28, (double *)&v28);
      double v9 = *a2;
      double v10 = a2[1];
      if (*a2 <= v10 && (v12 = a2[2], double v11 = a2[3], v12 <= v11) && (v14 = a2[4], v13 = a2[5], v14 <= v13))
      {
        double v17 = *((double *)&v28 + 1);
        if (v9 >= *(double *)&v28) {
          double v9 = *(double *)&v28;
        }
        if (v10 <= *(double *)&v28) {
          double v10 = *(double *)&v28;
        }
        *a2 = v9;
        a2[1] = v10;
        if (v12 >= v17) {
          double v18 = v17;
        }
        else {
          double v18 = v12;
        }
        if (v11 <= v17) {
          double v19 = v17;
        }
        else {
          double v19 = v11;
        }
        a2[2] = v18;
        a2[3] = v19;
        double v20 = v29;
        if (v14 >= v29) {
          double v21 = v29;
        }
        else {
          double v21 = v14;
        }
        if (v13 > v29) {
          double v20 = v13;
        }
        a2[4] = v21;
        a2[5] = v20;
      }
      else
      {
        long long v15 = v28;
        *(void *)a2 = v28;
        *(_OWORD *)(a2 + 1) = v15;
        a2[3] = *((double *)&v15 + 1);
        double v16 = v29;
        a2[4] = v29;
        a2[5] = v16;
      }
      ++v7;
      v8 += 24;
    }
    while (v6 != v7);
  }
  long long v30 = &unk_1F111C8A8;
  if ((int)v31 < 0) {
    unsigned int v22 = 1;
  }
  else {
    unsigned int v22 = v31 & ~((int)v31 >> 31);
  }
  if (v22 == v31)
  {
    uint64_t v23 = SHIDWORD(v31);
    if (v31 < 0)
    {
      uint64_t v24 = 24 * SHIDWORD(v31);
      do
      {
        signed int v25 = (void *)(v32 + v24);
        void *v25 = 0;
        v25[1] = 0;
        v25[2] = 0;
        v24 += 24;
      }
      while (!__CFADD__(v23++, 1));
    }
  }
  else
  {
    if (v22) {
      operator new[]();
    }
    if (v32) {
      MEMORY[0x1BA9BFB70](v32, 0x1000C8077774924);
    }
    uint64_t v32 = 0;
  }
  uint64_t v31 = v22;
  uint64_t result = v32;
  if (v32) {
    return MEMORY[0x1BA9BFB70](v32, 0x1000C8077774924);
  }
  return result;
}

void sub_1B7A93710(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  PCArray<PCVector3<double>,PCArray_Traits<PCVector3<double>>>::~PCArray((uint64_t)va);
  _Unwind_Resume(a1);
}

void *LiGeode::print(uint64_t a1, void *a2, uint64_t a3)
{
  LiImageSource::printIndent(a2, a3);
  uint64_t v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"LiGeode(\"", 9);
  if (*(void *)(a1 + 512)) {
    uint64_t v7 = *(const char **)(a1 + 512);
  }
  else {
    uint64_t v7 = "";
  }
  size_t v8 = strlen(v7);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)v7, v8);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"\"", 1);
  double v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", ", 2);
  uint64_t v10 = *(void *)(a1 + 592);
  if (!v10) {
    throw_PCNullPointerException(1);
  }
  (*(void (**)(std::locale *__return_ptr))(*(void *)v10 + 120))(&v27);
  if (v27.__locale_) {
    locale = (const char *)v27.__locale_;
  }
  else {
    locale = "";
  }
  size_t v12 = strlen(locale);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)locale, v12);
  if (v27.__locale_ && atomic_fetch_add((atomic_uint *volatile)v27.__locale_ - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)v27.__locale_ = 0;
    if (v27.__locale_) {
      double v13 = (char *)v27.__locale_ - 12;
    }
    else {
      double v13 = 0;
    }
    free(v13);
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", compositeOrder=", 17);
  std::ostream::operator<<();
  if (*(_DWORD *)(a1 + 532) || *(_DWORD *)(a1 + 536))
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"/", 1);
    std::ostream::operator<<();
    if (*(unsigned char *)(a1 + 540)) {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"(r)", 3);
    }
  }
  if (*(_DWORD *)(a1 + 536))
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"/", 1);
    std::ostream::operator<<();
  }
  double v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", blendMode=", 12);
  int v15 = LiSceneObject::blendMode((LiSceneObject *)a1);
  operator<<(v14, v15);
  if (*(unsigned char *)(a1 + 541)) {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", farAway=true", 14);
  }
  if (*(double *)(a1 + 648) > 0.0)
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", reflectivity=", 15);
    std::ostream::operator<<();
  }
  if (!*(unsigned char *)(a1 + 552)) {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", doesReflect=false", 19);
  }
  if (!*(unsigned char *)(a1 + 553)) {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", visibleOutsideReflection=false", 32);
  }
  if (*(double *)(a1 + 544) != 1.0)
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", opacity=", 10);
    std::ostream::operator<<();
  }
  if (*(int *)(a1 + 700) <= 1)
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", filterIntersections=", 22);
    std::ostream::operator<<();
  }
  if (*(void *)(a1 + 568))
  {
    LightFilter = (unsigned char *)LiGeode::getLightFilter((LiGeode *)a1);
    if (LightFilter[172]) {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", ignoreAlpha", 13);
    }
    if (LightFilter[173]) {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", castsShadows", 14);
    }
    if (LightFilter[174]) {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", receivesShadows", 17);
    }
    if (LightFilter[176]) {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", filterCastShadows", 19);
    }
  }
  if (*(_DWORD *)(a1 + 636))
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", ", 2);
    double v17 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)" filters", 8);
  }
  double v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)")", 1);
  std::ios_base::getloc((const std::ios_base *)((char *)v18 + *(void *)(*v18 - 24)));
  double v19 = std::locale::use_facet(&v27, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v19->__vftable[2].~facet_0)(v19, 10);
  std::locale::~locale(&v27);
  std::ostream::put();
  std::ostream::flush();
  (*(void (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 120))(a1, a2, a3);
  uint64_t v20 = *(void *)(a1 + 592);
  if (!v20) {
    throw_PCNullPointerException(1);
  }
  uint64_t v21 = (a3 + 1);
  uint64_t result = (void *)(*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)v20 + 128))(v20, a2, v21);
  uint64_t v23 = *(unsigned int *)(a1 + 636);
  if ((int)v23 >= 1)
  {
    uint64_t v24 = (PCArray_base *)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"(Filters: ", 10);
    for (uint64_t i = 0; i != v23; ++i)
    {
      if (i >= *(int *)(a1 + 636)) {
        PCArray_base::badIndex(v24);
      }
      uint64_t v26 = *(void *)(*(void *)(a1 + 640) + 16 * i);
      uint64_t v24 = (PCArray_base *)(*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)v26 + 128))(v26, a2, v21);
    }
    return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)")\n", 2);
  }
  return result;
}

void sub_1B7A93C48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  if (a10.__locale_) {
    LiGeode::print((uint64_t)a10.__locale_, &a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t LiGeode::getLightFilter(LiGeode *this)
{
  uint64_t result = *((void *)this + 71);
  if (!result) {
    operator new();
  }
  return result;
}

{
  uint64_t result;

  uint64_t result = *((void *)this + 71);
  if (!result) {
    operator new();
  }
  return result;
}

void sub_1B7A93CE0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40B0369FADLL);
  _Unwind_Resume(a1);
}

void LiGeode::setLighting(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, uint64_t a7)
{
  *(unsigned char *)(a1 + 584) = a2;
  uint64_t LightFilter = LiGeode::getLightFilter((LiGeode *)a1);
  long long v15 = *(_OWORD *)(a4 + 112);
  long long v39 = *(_OWORD *)(a4 + 96);
  long long v40 = v15;
  long long v16 = *(_OWORD *)(a4 + 144);
  long long v41 = *(_OWORD *)(a4 + 128);
  long long v42 = v16;
  long long v17 = *(_OWORD *)(a4 + 48);
  v38[2] = *(_OWORD *)(a4 + 32);
  v38[3] = v17;
  long long v18 = *(_OWORD *)(a4 + 80);
  v38[4] = *(_OWORD *)(a4 + 64);
  v38[5] = v18;
  long long v19 = *(_OWORD *)(a4 + 16);
  v38[0] = *(_OWORD *)a4;
  v38[1] = v19;
  LiPolygon::LiPolygon((LiPolygon *)&v43, (const LiPolygon *)(a4 + 160));
  long long v20 = *(_OWORD *)(a4 + 376);
  long long v50 = *(_OWORD *)(a4 + 360);
  long long v51 = v20;
  long long v21 = *(_OWORD *)(a4 + 312);
  long long v46 = *(_OWORD *)(a4 + 296);
  long long v47 = v21;
  long long v22 = *(_OWORD *)(a4 + 344);
  long long v48 = *(_OWORD *)(a4 + 328);
  long long v49 = v22;
  long long v23 = *(_OWORD *)(a4 + 280);
  long long v44 = *(_OWORD *)(a4 + 264);
  long long v45 = v23;
  uint64_t v24 = *(void *)(a4 + 392);
  BYTE2(v39) = a2;
  uint64_t v25 = *(void *)(a1 + 520);
  int v26 = *(_DWORD *)(a3 + 12);
  if (*(_DWORD *)(LightFilter + 48) >= v26) {
    int v27 = *(_DWORD *)(LightFilter + 48);
  }
  else {
    int v27 = (2 * v26) | 1;
  }
  uint64_t v52 = v24;
  *(void *)&long long v44 = v25;
  PCArray<LiLight,PCArray_Traits<LiLight>>::resize(LightFilter + 40, v26, v27);
  if (*(int *)(a3 + 12) >= 1)
  {
    uint64_t v28 = 0;
    uint64_t v29 = 0;
    do
    {
      LiLight::operator=(*(void *)(LightFilter + 56) + v28, *(void *)(a3 + 16) + v28);
      ++v29;
      v28 += 944;
    }
    while (v29 < *(int *)(a3 + 12));
  }
  *(unsigned char *)(LightFilter + 64) = *(unsigned char *)(a3 + 24);
  LiMaterialProperties::operator=(LightFilter + 72, (uint64_t)v38);
  if (LightFilter + 472 != a5)
  {
    uint64_t v30 = 0;
    uint64_t v31 = LightFilter + 472;
    do
    {
      for (uint64_t i = 0; i != 32; i += 8)
        *(void *)(v31 + i) = *(void *)(a5 + i);
      ++v30;
      v31 += 32;
      a5 += 32;
    }
    while (v30 != 4);
  }
  if (fabs(PCMatrix44Tmpl<double>::determinant((double *)(LightFilter + 472))) < 0.0000001)
  {
    uint64_t v53 = 0;
    uint64_t v54 = 0;
    long long v55 = xmmword_1B7E733D0;
    liFindMatrixPlane((double *)(LightFilter + 472), (double *)&v53);
    uint64_t v33 = v54;
    *(void *)(LightFilter + 488) = v53;
    *(void *)(LightFilter + 520) = v33;
    uint64_t v34 = *((void *)&v55 + 1);
    *(void *)(LightFilter + 552) = v55;
    *(void *)(LightFilter + 584) = v34;
  }
  *(unsigned char *)(LightFilter + 8LiDepthSorter::stackSort((uint64_t)this + 56) = a6;
  uint64_t v35 = LightFilter + 728;
  if (LightFilter + 728 != a7)
  {
    for (uint64_t j = 0; j != 4; ++j)
    {
      for (uint64_t k = 0; k != 32; k += 8)
        *(void *)(v35 + k) = *(void *)(a7 + k);
      v35 += 32;
      a7 += 32;
    }
  }
  LiMaterialProperties::~LiMaterialProperties((LiMaterialProperties *)v38);
}

void sub_1B7A93F2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t LiGeode::setLit(uint64_t this, char a2)
{
  *(unsigned char *)(this + 584) = a2;
  return this;
}

void sub_1B7A93FB8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40B0369FADLL);
  _Unwind_Resume(a1);
}

BOOL LiGeode::needsLights(LiGeode *this)
{
  if (*((unsigned char *)this + 584)) {
    return 1;
  }
  if (*((void *)this + 71)) {
    return *(unsigned char *)(LiGeode::getLightFilter(this) + 174) != 0;
  }
  return 0;
}

uint64_t LiGeode::getSmoothEdges(LiGeode *this)
{
  return *((unsigned __int8 *)this + 697);
}

uint64_t LiGeode::setSmoothEdges(uint64_t this, char a2)
{
  *(unsigned char *)(this + 697) = a2;
  return this;
}

uint64_t LiMaterialProperties::operator=(uint64_t a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  long long v5 = *(_OWORD *)(a2 + 32);
  long long v6 = *(_OWORD *)(a2 + 48);
  long long v7 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = v7;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 48) = v6;
  long long v8 = *(_OWORD *)(a2 + 96);
  long long v9 = *(_OWORD *)(a2 + 112);
  long long v10 = *(_OWORD *)(a2 + 144);
  *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 144) = v10;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + 112) = v9;
  LiPolygon::operator=(a1 + 160, a2 + 160);
  *(void *)(a1 + 264) = *(void *)(a2 + 264);
  if (a2 != a1)
  {
    uint64_t v11 = 0;
    uint64_t v12 = a1 + 272;
    uint64_t v13 = a2 + 272;
    do
    {
      for (uint64_t i = 0; i != 32; i += 8)
        *(void *)(v12 + i) = *(void *)(v13 + i);
      ++v11;
      v12 += 32;
      v13 += 32;
    }
    while (v11 != 4);
  }
  return a1;
}

void PCArray<PCVector3<double>,PCArray_Traits<PCVector3<double>>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111C8A8;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<PCVector3<double>,PCArray_Traits<PCVector3<double>>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t PCArray<PCVector3<double>,PCArray_Traits<PCVector3<double>>>::resize(uint64_t result, int a2, int a3)
{
  if (a3 <= a2) {
    int v3 = a2;
  }
  else {
    int v3 = a3;
  }
  if (a2 < 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v17, "PCArray::resize");
    PCException::PCException(exception, &v17);
    *(void *)exception = &unk_1F1199218;
  }
  uint64_t v5 = result;
  if (v3 == *(_DWORD *)(result + 8))
  {
    uint64_t v6 = *(int *)(result + 12);
    if ((int)v6 < a2)
    {
      uint64_t v7 = 24 * v6;
      uint64_t v8 = a2 - v6;
      do
      {
        long long v9 = (void *)(*(void *)(result + 16) + v7);
        void *v9 = 0;
        v9[1] = 0;
        void v9[2] = 0;
        v7 += 24;
        --v8;
      }
      while (v8);
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    int v10 = *(_DWORD *)(result + 12);
    if (a2 >= v10) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = a2;
    }
    if ((int)v11 < 1)
    {
      LODWORD(v11) = 0;
    }
    else
    {
      uint64_t v12 = (void *)(*(void *)(result + 16) + 16);
      uint64_t v13 = 16;
      uint64_t v14 = v11;
      do
      {
        *(_OWORD *)(v13 - 16) = *((_OWORD *)v12 - 1);
        uint64_t v15 = *v12;
        v12 += 3;
        *(void *)uint64_t v13 = v15;
        v13 += 24;
        --v14;
      }
      while (v14);
    }
    if ((int)v11 > v10) {
      int v10 = v11;
    }
    if (v10 < a2) {
      bzero((void *)(24 * v10), 24 * (~v10 + a2) + 24);
    }
    uint64_t result = *(void *)(v5 + 16);
    if (result) {
      uint64_t result = MEMORY[0x1BA9BFB70](result, 0x1000C8077774924);
    }
    *(void *)(v5 + 16) = 0;
  }
  *(_DWORD *)(v5 + 8) = v3;
  *(_DWORD *)(v5 + 12) = a2;
  return result;
}

void sub_1B7A94334(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void LiGeode::print(uint64_t a1, unsigned char **a2)
{
  if (atomic_fetch_add((atomic_uint *volatile)(a1 - 12), 0xFFFFFFFF) == 1)
  {
    **a2 = 0;
    if (*a2) {
      int v2 = *a2 - 12;
    }
    else {
      int v2 = 0;
    }
    free(v2);
  }
}

BOOL liIsConvex(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = a1[1] - *a1;
  unint64_t v3 = v2 >> 4;
  if ((int)(v2 >> 4) < 1)
  {
    double v8 = 0.0;
  }
  else
  {
    uint64_t v4 = 0;
    int v5 = 0;
    int v6 = 0;
    uint64_t v7 = (v2 >> 4);
    double v8 = 0.0;
    do
    {
      if (v7 - 1 == v4) {
        uint64_t v9 = 0;
      }
      else {
        uint64_t v9 = v4 + 1;
      }
      float64x2_t v10 = *(float64x2_t *)(v1 + 16 * v9);
      float64x2_t v11 = vsubq_f64(v10, *(float64x2_t *)(v1 + 16 * v4));
      int8x16_t v12 = (int8x16_t)vsubq_f64(*(float64x2_t *)(v1 + 16 * (((int)v4 + 2) % (int)v3)), v10);
      double v13 = sqrt((vmulq_f64(v11, v11).f64[0] + vmuld_lane_f64(v11.f64[1], v11, 1))* (vmuld_n_f64(*(double *)v12.i64, *(double *)v12.i64)+ COERCE_DOUBLE(*(void *)&vmulq_f64(*(float64x2_t *)&v12, *(float64x2_t *)&v12).f64[1])));
      float64x2_t v14 = vmulq_f64(v11, (float64x2_t)vextq_s8(v12, v12, 8uLL));
      v14.f64[0] = vsubq_f64(v14, (float64x2_t)vdupq_laneq_s64((int64x2_t)v14, 1)).f64[0] / v13;
      uint64_t v15 = v4 + 1;
      v5 |= v14.f64[0] > 0.0;
      v6 |= v14.f64[0] < 0.0;
      double v8 = v8
         + atan2(v14.f64[0], (vmuld_n_f64(v11.f64[0], *(double *)v12.i64) + vmuld_lane_f64(v11.f64[1], (float64x2_t)v12, 1)) / v13);
      uint64_t v4 = v15;
    }
    while (v7 != v15);
    if (v5 & v6) {
      return 0;
    }
  }
  int v17 = llround(v8 / 6.28318531);
  if (vabdd_f64(v8, (double)v17 * 6.28318531) >= 0.01)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v20, "fabs(omega - wind*M_2PI) < 0.01");
    PCString::PCString(&v19, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/LiGeometryUtil.cpp");
    PCException::PCException(exception, &v20, &v19, 78);
    *(void *)exception = &unk_1F111C8F8;
  }
  if (v17 < 0) {
    int v17 = -v17;
  }
  return v17 == 1;
}

void sub_1B7A94594(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString((PCString *)&a9);
  PCString::~PCString(&a10);
  if (v11) {
    __cxa_free_exception(v10);
  }
  _Unwind_Resume(a1);
}

double elim<LiPolygon::PosFacet,LiChannelT<PCVector2<double>>>(double ***a1, void *a2, int a3)
{
  uint64_t v6 = (char *)(*a1)[1] - (char *)**a1;
  std::vector<PCVector2<double>>::resize((uint64_t)a2, (int)(v6 >> 5));
  if ((int)((unint64_t)v6 >> 5) >= 1)
  {
    double v8 = **a1;
    uint64_t v9 = ((unint64_t)v6 >> 5);
    float64x2_t v10 = (double *)(*a2 + 8);
    do
    {
      int v11 = v8 + 1;
      if (a3 > 0) {
        int v11 = v8;
      }
      if (a3 <= 1) {
        uint64_t v12 = 2;
      }
      else {
        uint64_t v12 = 1;
      }
      double result = v8[v12];
      *(v10 - 1) = *v11;
      *float64x2_t v10 = result;
      v10 += 2;
      v8 += 4;
      --v9;
    }
    while (v9);
  }
  return result;
}

BOOL PCRect<double>::intersects(double *a1, double *a2)
{
  double v2 = a1[2];
  if (v2 < 0.0) {
    return 0;
  }
  double v3 = a1[3];
  if (v3 < 0.0) {
    return 0;
  }
  uint64_t v4 = 0;
  double v5 = a2[2];
  if (v5 >= 0.0)
  {
    double v6 = a2[3];
    if (v6 >= 0.0)
    {
      double v7 = *a1;
      double v8 = v5 + *a2;
      if (v2 + *a1 >= *a2)
      {
        BOOL v10 = v7 == v8;
        BOOL v9 = v7 >= v8;
      }
      else
      {
        BOOL v9 = 1;
        BOOL v10 = 0;
      }
      if (v10 || !v9)
      {
        double v11 = a1[1];
        double v12 = a2[1];
        if (v11 <= v12 + v6) {
          return v11 + v3 >= v12;
        }
      }
      return 0;
    }
  }
  return v4;
}

uint64_t polygonPlaneSplit<double>(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, std::vector<int> *a5, std::vector<int> *a6, int a7, int *a8, double a9)
{
  unint64_t v16 = (*a1)[1] - **a1;
  memset(&v79, 0, sizeof(v79));
  std::vector<unsigned int>::resize(&v79, (int)((uint64_t)v16 >> 5));
  unint64_t v17 = v16 >> 5;
  if ((int)(v16 >> 5) < 1)
  {
    int v26 = -1;
LABEL_24:
    char v33 = 1;
    int v34 = 2;
    goto LABEL_26;
  }
  uint64_t v18 = 0;
  int v19 = 0;
  char v20 = 0;
  double v21 = *(double *)a2;
  float64x2_t v22 = *(float64x2_t *)(a2 + 8);
  double v23 = *(double *)(a2 + 24);
  std::vector<int>::pointer begin = v79.__begin_;
  uint64_t v25 = (float64x2_t *)(**a1 + 8);
  int v26 = -1;
  do
  {
    float64_t v27 = v25[-1].f64[1] * v21;
    float64x2_t v28 = *v25;
    v25 += 2;
    float64x2_t v29 = vmulq_f64(v28, v22);
    double v30 = v23 + v27 + v29.f64[0] + v29.f64[1];
    if (v30 >= -1.0e-11) {
      int v31 = 0;
    }
    else {
      int v31 = -1;
    }
    if (v30 > 1.0e-11) {
      int v31 = 1;
    }
    begin[v18] = v31;
    if (v31 == 1) {
      int v32 = 1;
    }
    else {
      int v32 = v19;
    }
    if (v31 == -1) {
      char v20 = 1;
    }
    else {
      int v19 = v32;
    }
    if (v31) {
      int v26 = v18;
    }
    ++v18;
  }
  while ((v16 >> 5) != v18);
  if ((v20 & 1) == 0)
  {
    if (v19)
    {
      char v33 = 0;
      int v34 = -1;
      goto LABEL_26;
    }
    goto LABEL_24;
  }
  if ((v19 & 1) == 0)
  {
    char v33 = 0;
    int v34 = 1;
LABEL_26:
    *a8 = v34;
    if (a7)
    {
      if ((v26 & 0x80000000) == 0) {
        goto LABEL_28;
      }
      if ((v33 & 1) == 0) {
        goto LABEL_79;
      }
      std::vector<unsigned int>::resize(a5, 0);
      std::vector<unsigned int>::resize(a6, 0);
    }
LABEL_69:
    uint64_t v68 = 0;
    goto LABEL_70;
  }
  *a8 = 3;
  if (v26 < 0)
  {
LABEL_79:
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString((PCString *)&__p, "sideof == kLiCoplanar");
    PCString::PCString(&v78, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/LiGeometryUtil.cpp");
    PCException::PCException(exception, (const PCString *)&__p, &v78, 580);
    *(void *)exception = &unk_1F111C8F8;
  }
LABEL_28:
  int v71 = a8;
  int v35 = v17 - 1;
  if ((int)v17 >= 1)
  {
    int v36 = v79.__begin_[v26];
    int v37 = (v26 + (int)v17) % (int)v17;
    if (v79.__begin_[v37] == v36)
    {
      int v38 = v17 - 1;
      do
      {
        int v39 = v37;
        if (!v38) {
          break;
        }
        int v37 = (v26 + v38--) % (int)v17;
      }
      while (v79.__begin_[v37] == v36);
    }
    else
    {
      int v39 = 0;
    }
    int v40 = 0;
    unint64_t v41 = v16 >> 5;
    while (1)
    {
      LODWORD(__p) = v39 % (int)v17;
      LODWORD(v78.var0) = (v35 + v39 % (int)v17) % (int)v17;
      int v42 = v79.__begin_[v39 % (int)v17];
      if (v40 && v42 == v40) {
        goto LABEL_60;
      }
      if (v42) {
        break;
      }
      int v40 = 0;
LABEL_64:
      ++v39;
      LODWORD(v41) = v41 - 1;
      if (!v41) {
        goto LABEL_65;
      }
    }
    int v43 = v79.__begin_[(v35 + v39 % (int)v17) % (int)v17];
    if (v43)
    {
      if (v43 != v42)
      {
        if (v42 >= 0) {
          uint64_t v44 = (uint64_t)a6;
        }
        else {
          uint64_t v44 = (uint64_t)a5;
        }
        if (v42 >= 0) {
          int v45 = -2;
        }
        else {
          int v45 = -1;
        }
        int v77 = v45;
        LiChannelT<int>::append(v44, &v77);
        uint64_t v46 = **a1;
        long long v47 = (double *)(v46 + 32 * (int)__p);
        long long v48 = (double *)(v46 + 32 * SLODWORD(v78.var0));
        double v49 = v47[1];
        double v50 = v47[2];
        double v51 = *(double *)(a2 + 8);
        double v52 = *(double *)(a2 + 16);
        double v53 = *(double *)(a2 + 24);
        double v54 = v53 + *v47 * *(double *)a2 + v49 * v51 + v50 * v52;
        double v55 = v48[1];
        double v56 = v48[2];
        double v57 = v54 / (v54 - (v53 + *(double *)a2 * *v48 + v51 * v55 + v52 * v56));
        double v58 = *v47 + (*v48 - *v47) * v57;
        double v59 = v49 + (v55 - v49) * v57;
        double v60 = v50 + (v56 - v50) * v57;
        size_t v61 = (double *)a4;
        if (v42 < 0) {
          size_t v61 = (double *)a3;
        }
        double *v61 = v58;
        v61[1] = v59;
        v61[2] = v60;
      }
    }
    else
    {
      if (v42 >= 0) {
        uint64_t v62 = (uint64_t)a6;
      }
      else {
        uint64_t v62 = (uint64_t)a5;
      }
      LiChannelT<int>::append(v62, &v78);
      uint64_t v63 = **a1 + 32 * SLODWORD(v78.var0);
      uint64_t v64 = a4;
      if (v42 < 0) {
        uint64_t v64 = a3;
      }
      uint64_t v65 = *(void *)(v63 + 16);
      *(_OWORD *)uint64_t v64 = *(_OWORD *)v63;
      *(void *)(v64 + 16) = v65;
    }
    int v40 = v42;
LABEL_60:
    if (v40 >= 0) {
      uint64_t v66 = (uint64_t)a6;
    }
    else {
      uint64_t v66 = (uint64_t)a5;
    }
    LiChannelT<int>::append(v66, &__p);
    goto LABEL_64;
  }
LABEL_65:
  if ((((char *)a6->__end_ - (char *)a6->__begin_) & 0x3FFFFFFFCLL) == 0
    || (((char *)a5->__end_ - (char *)a5->__begin_) & 0x3FFFFFFFCLL) == 0)
  {
    goto LABEL_69;
  }
  LiChannelT<int>::append((uint64_t)a5, a6->__begin_);
  LiChannelT<int>::append((uint64_t)a6, a5->__begin_);
  __p = 0;
  int v75 = 0;
  uint64_t v76 = 0;
  LiChannelT<PCVector3<double>>::append((uint64_t *)&__p, a3);
  LiChannelT<PCVector3<double>>::append((uint64_t *)&__p, a4);
  removeDuplicatePoints<PCVector3<double>>((uint64_t *)a5, a1, &__p, a9);
  removeDuplicatePoints<PCVector3<double>>((uint64_t *)a6, a1, &__p, a9);
  if ((int)((unint64_t)((char *)a5->__end_ - (char *)a5->__begin_) >> 2) <= 2)
  {
    std::vector<unsigned int>::resize(a5, 0);
    int v67 = -1;
LABEL_75:
    uint64_t v68 = 0;
    *int v71 = v67;
    goto LABEL_77;
  }
  if ((int)((unint64_t)((char *)a6->__end_ - (char *)a6->__begin_) >> 2) <= 2)
  {
    std::vector<unsigned int>::resize(a6, 0);
    int v67 = 1;
    goto LABEL_75;
  }
  uint64_t v68 = 1;
LABEL_77:
  if (__p)
  {
    int v75 = __p;
    operator delete(__p);
  }
LABEL_70:
  if (v79.__begin_)
  {
    v79.__end_ = v79.__begin_;
    operator delete(v79.__begin_);
  }
  return v68;
}

void sub_1B7A94C08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, PCString a13, uint64_t a14, uint64_t a15, uint64_t a16, PCString a17, void *__p, uint64_t a19)
{
  PCString::~PCString(&a17);
  PCString::~PCString(&a13);
  if (v20) {
    __cxa_free_exception(v19);
  }
  if (__p)
  {
    a19 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL liPolygonPlaneClip(uint64_t **a1, uint64_t **a2, uint64_t a3, int a4)
{
  memset(v35, 0, sizeof(v35));
  memset(v34, 0, sizeof(v34));
  memset(&v33, 0, sizeof(v33));
  memset(&v32, 0, sizeof(v32));
  polygonPlaneSplit<double>(a1, a3, (uint64_t)v35, (uint64_t)v34, &v32, &v33, 1, &v31, 0.1);
  int64_t v7 = ((char *)v32.__end_ - (char *)v32.__begin_) & 0x3FFFFFFFCLL;
  if (v7)
  {
    int64_t v8 = (char *)v33.__end_ - (char *)v33.__begin_;
    unint64_t v9 = (unint64_t)((char *)v33.__end_ - (char *)v33.__begin_) >> 2;
    if (v9)
    {
      __p = 0;
      float64x2_t v29 = 0;
      uint64_t v30 = 0;
      memset(&v27, 0, sizeof(v27));
      std::vector<PCVector3<double>>::resize((uint64_t *)&__p, (int)(v8 >> 2));
      std::vector<unsigned int>::resize(&v27, (int)(v8 >> 2));
      if ((int)v9 >= 1)
      {
        uint64_t v10 = 0;
        unint64_t v11 = (unint64_t)((*a2)[1] - **a2) >> 5;
        uint64_t v12 = ((unint64_t)v8 >> 2);
        while (1)
        {
          int v13 = v33.__begin_[v10];
          uint64_t v14 = v10 + 1;
          uint64_t v15 = v10 + 1 == v12 ? 0 : v10 + 1;
          int v16 = v33.__begin_[v15];
          if (v13 == -2) {
            break;
          }
          if (v13 == -1)
          {
            unint64_t v17 = v35;
LABEL_12:
            uint64_t v18 = (char *)__p + 24 * v10;
            long long v19 = *(_OWORD *)v17;
            *((void *)v18 + 2) = v17[2];
            *(_OWORD *)uint64_t v18 = v19;
            goto LABEL_13;
          }
          uint64_t v22 = **a1 + 32 * v13;
          double v23 = (char *)__p + 24 * v10;
          long long v24 = *(_OWORD *)v22;
          *((void *)v23 + 2) = *(void *)(v22 + 16);
          *(_OWORD *)double v23 = v24;
          if ((v13 & 0x80000000) == 0)
          {
            uint64_t v21 = v13;
            goto LABEL_17;
          }
LABEL_13:
          int v20 = a4;
          if ((v16 & 0x80000000) == 0)
          {
            uint64_t v21 = ((int)v11 - 1 + v16) % (int)v11;
LABEL_17:
            int v20 = *(_DWORD *)(**a2 + 32 * v21 + 24);
          }
          v27.__begin_[v10++] = v20;
          if (v14 == v12) {
            goto LABEL_19;
          }
        }
        unint64_t v17 = v34;
        goto LABEL_12;
      }
LABEL_19:
      copy<LiChannelT<PCVector3<double>>,LiPolygon::PosFacet>(&__p, a1);
      copy<LiChannelT<int>,LiImagePolygon::EdgeFacet>(&v27.__begin_, a2);
      if (v27.__begin_)
      {
        v27.__end_ = v27.__begin_;
        operator delete(v27.__begin_);
      }
      if (__p)
      {
        float64x2_t v29 = __p;
        operator delete(__p);
      }
    }
    else
    {
      std::vector<LiPolygon::PosEdge>::resize(*a1, 0);
      if ((((*a2)[1] - **a2) & 0x1FFFFFFFE0) != 0)
      {
        exception = (PCException *)__cxa_allocate_exception(0x40uLL);
        PCString::PCString((PCString *)&__p, "edge.size() == 0");
        PCString::PCString((PCString *)&v27, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/LiGeometryUtil.cpp");
        PCException::PCException(exception, (const PCString *)&__p, (const PCString *)&v27, 738);
        *(void *)exception = &unk_1F111C8F8;
      }
    }
  }
  if (v32.__begin_)
  {
    v32.__end_ = v32.__begin_;
    operator delete(v32.__begin_);
  }
  if (v33.__begin_)
  {
    v33.__end_ = v33.__begin_;
    operator delete(v33.__begin_);
  }
  return v7 != 0;
}

void sub_1B7A94F58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10, uint64_t a11, uint64_t a12, PCString a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20,uint64_t a21)
{
  PCString::~PCString(&a10);
  PCString::~PCString(&a13);
  if (v22) {
    __cxa_free_exception(v21);
  }
  if (__p)
  {
    a18 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a20)
  {
    a21 = (uint64_t)a20;
    operator delete(a20);
  }
  _Unwind_Resume(a1);
}

void liPolygonDimensions(uint64_t a1, double *a2, double *a3, double *a4, double *a5)
{
  int v38 = 0;
  int v39 = 0;
  uint64_t v40 = 0;
  elim<LiPolygon::PosFacet,LiChannelT<PCVector2<double>>>((double ***)(a1 + 88), &v38, 2);
  unint64_t v9 = v38;
  unint64_t v10 = (unint64_t)((char *)v39 - (char *)v38) >> 4;
  if ((int)v10 < 1) {
    goto LABEL_28;
  }
  uint64_t v11 = 0;
  char v12 = 0;
  uint64_t v13 = ((unint64_t)((char *)v39 - (char *)v38) >> 4);
  uint64_t v14 = v13 - 1;
  double v15 = 0.0;
  double v16 = 0.0;
  double v17 = 0.0;
  double v18 = 0.0;
  double v19 = 0.0;
  do
  {
    float64x2_t v20 = *(float64x2_t *)&v38[2 * v11++];
    uint64_t v21 = v11;
    if (v11 == v13) {
      uint64_t v21 = 0;
    }
    float64x2_t v22 = vsubq_f64(*(float64x2_t *)&v38[2 * v21], v20);
    double v23 = vaddvq_f64(vmulq_f64(v22, v22));
    if (v23 <= -0.0000001 || v23 >= 0.0000001)
    {
      double v24 = sqrt(v23);
      double v25 = v22.f64[1] / v24;
      v22.f64[0] = -v22.f64[0] / v24;
      double v26 = v22.f64[1] / v24 * *v38 + v22.f64[0] * v38[1];
      if (v10 == 1)
      {
        double v27 = v26;
      }
      else
      {
        uint64_t v28 = v13 - 1;
        float64x2_t v29 = v38 + 3;
        double v27 = v26;
        do
        {
          double v30 = v22.f64[0] * *v29;
          double v31 = v25 * *(v29 - 1) + v30;
          if (v27 > v31) {
            double v27 = v25 * *(v29 - 1) + v30;
          }
          if (v26 < v31) {
            double v26 = v25 * *(v29 - 1) + v30;
          }
          v29 += 2;
          --v28;
        }
        while (v28);
      }
      if ((v12 & (v26 - v27 >= v15)) != 0)
      {
        char v12 = 1;
      }
      else
      {
        char v12 = 1;
        double v19 = v22.f64[0];
        double v18 = v25;
        double v17 = v27;
        double v16 = v26;
        double v15 = v26 - v27;
      }
    }
  }
  while (v11 != v13);
  if (v12)
  {
    double v32 = v18 * v38[1] - v19 * *v38;
    if ((int)v10 < 2)
    {
      double v34 = v18 * v38[1] - v19 * *v38;
    }
    else
    {
      std::vector<int> v33 = v38 + 3;
      double v34 = v18 * v38[1] - v19 * *v38;
      do
      {
        double v35 = v18 * *v33;
        double v36 = v35 - v19 * *(v33 - 1);
        if (v34 > v36) {
          double v34 = v35 - v19 * *(v33 - 1);
        }
        if (v32 < v36) {
          double v32 = v35 - v19 * *(v33 - 1);
        }
        v33 += 2;
        --v14;
      }
      while (v14);
    }
    *a5 = v15;
    *a4 = v32 - v34;
    *a3 = -v19;
    a3[1] = v18;
    double v37 = v17 + v16;
    *a2 = (v18 * v37 - v19 * (v34 + v32)) * 0.5;
    a2[1] = (v19 * v37 + v18 * (v34 + v32)) * 0.5;
  }
  else
  {
LABEL_28:
    *a4 = 0.0;
    *a5 = 0.0;
    *a3 = 0.0;
    a3[1] = 0.0;
    *(_OWORD *)a2 = *(_OWORD *)v9;
  }
  int v39 = v9;
  operator delete(v9);
}

void sub_1B7A95224(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t liClipLineToPolygon(double *a1, uint64_t **a2, double *a3, double *a4)
{
  *a3 = 0.0;
  *a4 = 1.0;
  uint64_t v4 = **a2;
  unint64_t v5 = (*a2)[1] - v4;
  if ((int)(v5 >> 5) < 2) {
    return 0;
  }
  uint64_t v7 = 0;
  uint64_t v6 = 0;
  double v8 = 0.0;
  uint64_t v9 = (v5 >> 5);
  uint64_t v10 = v9 - 1;
  double v11 = 0.0;
  double v12 = 0.0;
  double v13 = 0.0;
  double v14 = 0.0;
  double v15 = 0.0;
LABEL_4:
  double v16 = (double *)(v4 + 16 + 32 * v7);
  do
  {
    uint64_t v17 = v7 + 1;
    uint64_t v18 = (v7 + 1);
    if (v10 == v7) {
      uint64_t v18 = 0;
    }
    double v19 = (double *)(v4 + 32 * v18);
    double v21 = *(v16 - 2);
    double v20 = *(v16 - 1);
    double v22 = *v19 - v21;
    double v23 = v19[1] - v20;
    double v24 = *v16;
    double v25 = v19[2] - *v16;
    double v27 = a1[3];
    double v26 = a1[4];
    double v28 = a1[5];
    double v29 = v26 * v25 - v23 * v28;
    double v30 = v22 * v28 - v25 * v27;
    double v31 = v23 * v27 - v22 * v26;
    double v32 = v31 * v31 + v29 * v29 + v30 * v30;
    if (v32 != 0.0)
    {
      double v33 = v24 - a1[2];
      double v34 = v20 - a1[1];
      double v35 = v21 - *a1;
      double v36 = ((v27 * v30 - v26 * v29) * v33 + (v28 * v29 - v27 * v31) * v34 + (v26 * v31 - v28 * v30) * v35) / v32;
      if (v36 >= 0.0 && v36 <= 1.0)
      {
        double v38 = ((v22 * v30 - v23 * v29) * v33 + (v25 * v29 - v22 * v31) * v34 + (v23 * v31 - v25 * v30) * v35) / v32;
        if (!v6)
        {
          uint64_t v6 = 1;
          *a3 = v38;
          double v8 = v21;
          double v11 = v20;
          double v12 = v24;
          double v13 = v22;
          double v14 = v23;
          double v15 = v25;
          if (v10 != v7++) {
            goto LABEL_4;
          }
          goto LABEL_20;
        }
        uint64_t v6 = (v6 + 1);
        *a4 = v38;
      }
    }
    v16 += 4;
    ++v7;
  }
  while (v9 != v17);
  double v25 = v15;
  double v23 = v14;
  double v22 = v13;
  double v24 = v12;
  double v20 = v11;
  double v21 = v8;
  if (v6 != 1) {
    return v6;
  }
LABEL_20:
  *a1 = v21;
  a1[1] = v20;
  a1[2] = v24;
  a1[3] = v22;
  a1[4] = v23;
  a1[5] = v25;
  *a3 = 0.0;
  uint64_t v6 = 1;
  *a4 = 1.0;
  return v6;
}

double LiPlaneEquation@<D0>(double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  double v4 = *a1;
  double v3 = a1[1];
  double result = a1[2];
  double v6 = sqrt(v4 * v4 + v3 * v3 + result * result);
  if (v6 <= -0.000000100000001 || v6 >= 0.000000100000001)
  {
    double v4 = v4 / v6;
    double v3 = v3 / v6;
    double result = result / v6;
  }
  double v7 = -(v4 * *a2 + v3 * a2[1] + result * a2[2]);
  *a3 = v4;
  a3[1] = v3;
  a3[2] = result;
  a3[3] = v7;
  return result;
}

BOOL liFindMatrixPlane(double *a1, double *a2)
{
  double v37 = 0.0;
  double v38 = 0.0;
  double v39 = 0.0;
  double v35 = 0.0;
  double v36 = 0.0;
  double v34 = 1.0;
  long long v32 = xmmword_1B7E733E0;
  double v33 = 0.0;
  double v29 = 0.0;
  double v30 = 0.0;
  double v31 = 1.0;
  PCMatrix44Tmpl<double>::transform<double>(a1, &v37, &v37);
  PCMatrix44Tmpl<double>::transform<double>(a1, &v34, &v34);
  PCMatrix44Tmpl<double>::transform<double>(a1, (double *)&v32, (double *)&v32);
  PCMatrix44Tmpl<double>::transform<double>(a1, &v29, &v29);
  double v4 = (v35 - v38) * (v33 - v39) - (v36 - v39) * (*((double *)&v32 + 1) - v38);
  double v5 = (v36 - v39) * (*(double *)&v32 - v37) - (v34 - v37) * (v33 - v39);
  double v6 = (v34 - v37) * (*((double *)&v32 + 1) - v38) - (v35 - v38) * (*(double *)&v32 - v37);
  double v7 = (*((double *)&v32 + 1) - v38) * (v31 - v39) - (v33 - v39) * (v30 - v38);
  double v8 = (v33 - v39) * (v29 - v37) - (*(double *)&v32 - v37) * (v31 - v39);
  double v9 = (*(double *)&v32 - v37) * (v30 - v38) - (*((double *)&v32 + 1) - v38) * (v29 - v37);
  double v10 = (v36 - v39) * (v30 - v38) - (v35 - v38) * (v31 - v39);
  double v11 = (v34 - v37) * (v31 - v39) - (v36 - v39) * (v29 - v37);
  double v12 = (v35 - v38) * (v29 - v37) - (v34 - v37) * (v30 - v38);
  double v26 = v9 * v9 + v7 * v7 + v8 * v8;
  double v27 = v10 * v10 + v11 * v11 + v12 * v12;
  double v28 = v6 * v6 + v4 * v4 + v5 * v5;
  double v13 = fabs(v27);
  double v14 = fabs(v26);
  unsigned int v15 = v13 > v14;
  double v16 = fabs(v28);
  double v17 = fabs(*(&v26 + (v13 > v14)));
  if (v16 > v17) {
    unsigned int v15 = 2;
  }
  double v18 = *(&v26 + v15);
  BOOL v19 = v18 >= 1.0e-32 || v18 <= -1.0e-32;
  if (v19)
  {
    BOOL v20 = v13 > v14;
    double v21 = sqrt(v18);
    if (v16 <= v17 && v20)
    {
      double v4 = (v36 - v39) * (v30 - v38) - (v35 - v38) * (v31 - v39);
      double v5 = (v34 - v37) * (v31 - v39) - (v36 - v39) * (v29 - v37);
      double v6 = (v35 - v38) * (v29 - v37) - (v34 - v37) * (v30 - v38);
    }
    if (!v15) {
      double v4 = (*((double *)&v32 + 1) - v38) * (v31 - v39) - (v33 - v39) * (v30 - v38);
    }
    double v22 = v4 / v21;
    if (!v15) {
      double v5 = (v33 - v39) * (v29 - v37) - (*(double *)&v32 - v37) * (v31 - v39);
    }
    double v23 = v5 / v21;
    if (!v15) {
      double v6 = (*(double *)&v32 - v37) * (v30 - v38) - (*((double *)&v32 + 1) - v38) * (v29 - v37);
    }
    v25[0] = v22;
    v25[1] = v23;
    v25[2] = v6 / v21;
    LiPlaneEquation(v25, &v37, a2);
  }
  return v19;
}

BOOL liSafeGetTransformation(long long *a1, uint64_t a2)
{
  fixNullSpace((uint64_t)a1);

  return PCMatrix44Tmpl<double>::getTransformation(a1, a2);
}

void fixNullSpace(uint64_t a1)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0xFFFFFFFF00000000;
  uint64_t v4 = 1;
  do
  {
    double v5 = (float64x2_t *)(a1 + v2);
    double v6 = *(double *)(a1 + v2);
    double v7 = *(double *)(a1 + v2 + 8);
    float64x2_t v8 = *(float64x2_t *)(a1 + v2 + 16);
    if (v2 == 64) {
      uint64_t v9 = 0;
    }
    else {
      uint64_t v9 = v4;
    }
    double v10 = (double *)(a1 + 32 * v9);
    double v11 = *v10;
    double v12 = v10[1];
    double v13 = v10[2];
    uint64_t v14 = v3 >> 32;
    if (!v2) {
      uint64_t v14 = 2;
    }
    unsigned int v15 = (double *)(a1 + 32 * v14);
    double v16 = v15[1];
    double v17 = v15[2];
    double v18 = v12 * v17 - v13 * v16;
    double v19 = v13 * *v15 - v11 * v17;
    double v20 = v11 * v16 - v12 * *v15;
    double v21 = v20 * v8.f64[0] + v6 * v18 + v7 * v19;
    if (v21 > -0.0000001 && v21 < 0.0000001)
    {
      double v22 = sqrt(v20 * v20 + v18 * v18 + v19 * v19);
      if (v22 <= -0.0000001 || v22 >= 0.0000001)
      {
        *(double *)(a1 + v2) = v6 + v18 / v22;
        v5->f64[1] = v7 + v19 / v22;
        v5[1] = vaddq_f64(v8, (float64x2_t)COERCE_UNSIGNED_INT64(v20 / v22));
      }
    }
    v3 += 0x100000000;
    v2 += 32;
    ++v4;
  }
  while (v2 != 96);
  double v23 = PCMatrix44Tmpl<double>::determinant((double *)a1);
  if (v23 > -0.0000001 && v23 < 0.0000001)
  {
    *(void *)(a1 + 120) = 0x3FF0000000000000;
    *(void *)(a1 + 80) = 0x3FF0000000000000;
    *(void *)(a1 + 40) = 0x3FF0000000000000;
    *(void *)a1 = 0x3FF0000000000000;
    *(_OWORD *)(a1 + 8) = 0u;
    *(_OWORD *)(a1 + 24) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 88) = 0u;
    *(_OWORD *)(a1 + 104) = 0u;
  }
}

BOOL liSafeGetTransformation(long long *a1, uint64_t a2, double *a3)
{
  fixNullSpace((uint64_t)a1);

  return PCMatrix44Tmpl<double>::getTransformation(a1, a2, a3);
}

BOOL PCMatrix44Tmpl<double>::getTransformation(long long *a1, uint64_t a2, double *a3)
{
  uint64_t v30 = 0x3FF0000000000000;
  double v27 = 1.0;
  double v24 = 1.0;
  double v21 = 1.0;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  BOOL PartialTransformation = PCMatrix44Tmpl<double>::getPartialTransformation(a1, a2, (uint64_t)&v21);
  if (PartialTransformation)
  {
    double v5 = v21;
    double v6 = v24;
    double v7 = v27;
    double v8 = v21 + v24 + v27;
    double v9 = acos((v8 + -1.0) * 0.5);
    double v10 = *((double *)&v26 + 1) - *(double *)&v25;
    double v11 = *((double *)&v22 + 1) - *(double *)&v26;
    double v12 = *((double *)&v23 + 1) - *(double *)&v22;
    double v13 = v10 * v10 + v11 * v11 + v12 * v12;
    if (v13 > -0.0000001 && v13 < 0.0000001)
    {
      if (v8 > 0.0)
      {
        *a3 = 1.0;
        a3[1] = 0.0;
        a3[2] = 0.0;
        a3[3] = 0.0;
        return PartialTransformation;
      }
      double v14 = (v5 + 1.0) * 0.5;
      if (v14 < 0.0) {
        double v14 = 0.0;
      }
      double v10 = sqrt(v14);
      double v15 = (v6 + 1.0) * 0.5;
      if (v15 < 0.0) {
        double v15 = 0.0;
      }
      double v11 = sqrt(v15);
      double v16 = (v7 + 1.0) * 0.5;
      if (v16 < 0.0) {
        double v16 = 0.0;
      }
      double v12 = sqrt(v16);
      double v13 = v12 * v12 + v11 * v11 + v10 * v10;
    }
    __double2 v17 = __sincos_stret(v9 * 0.5);
    double v18 = sqrt(v13);
    if (v18 < 0.000000100000001 && v18 > -0.000000100000001) {
      double v18 = 1.0;
    }
    *a3 = v17.__cosval;
    a3[1] = v17.__sinval * (v10 / v18);
    a3[2] = v17.__sinval * (v11 / v18);
    a3[3] = v17.__sinval * (v12 / v18);
  }
  return PartialTransformation;
}

uint64_t liTransformAndClip(double *a1, double *a2, uint64_t **a3)
{
  memset(v14, 0, sizeof(v14));
  double v6 = -*a1;
  uint64_t v16 = 0;
  long long v15 = 0x3FF0000000000000uLL;
  double v17 = v6;
  PCMatrix44Tmpl<double>::transform_row<double>(a2, (double *)&v15, v14[0].f64);
  int v7 = LiImagePolygon::clip(a3, v14, 0);
  double v8 = *a1 + a1[2];
  uint64_t v16 = 0;
  long long v15 = 0xBFF0000000000000;
  double v17 = v8;
  PCMatrix44Tmpl<double>::transform_row<double>(a2, (double *)&v15, v14[0].f64);
  int v9 = v7 | LiImagePolygon::clip(a3, v14, 0);
  double v10 = -a1[1];
  long long v15 = xmmword_1B7E733E0;
  uint64_t v16 = 0;
  double v17 = v10;
  PCMatrix44Tmpl<double>::transform_row<double>(a2, (double *)&v15, v14[0].f64);
  int v11 = LiImagePolygon::clip(a3, v14, 0);
  double v12 = a1[1] + a1[3];
  long long v15 = xmmword_1B7E7E030;
  uint64_t v16 = 0;
  double v17 = v12;
  PCMatrix44Tmpl<double>::transform_row<double>(a2, (double *)&v15, v14[0].f64);
  return v9 | v11 | LiImagePolygon::clip(a3, v14, 0);
}

void PCAssertionException::~PCAssertionException(PCString *this)
{
  PCException::~PCException(this);

  JUMPOUT(0x1BA9BFBA0);
}

void PCAssertionException::className(PCURL *a1@<X8>)
{
}

void std::vector<PCVector2<double>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 16 * a2;
    }
  }
  else
  {
    std::vector<PCVector2<double>>::__append((void **)a1, a2 - v2);
  }
}

void std::vector<PCVector2<double>>::__append(void **a1, unint64_t a2)
{
  double v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  double v5 = v6;
  int v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - (unsigned char *)*a1;
    unint64_t v9 = a2 + (v8 >> 4);
    if (v9 >> 60) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 4;
    uint64_t v11 = v5 - (unsigned char *)*a1;
    if (v11 >> 3 > v9) {
      unint64_t v9 = v11 >> 3;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      double v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>(v4, v12);
    }
    else {
      double v13 = 0;
    }
    double v14 = &v13[16 * v10];
    long long v15 = &v13[16 * v12];
    bzero(v14, 16 * a2);
    uint64_t v16 = &v14[16 * a2];
    double v17 = (char *)*a1;
    for (uint64_t i = (char *)a1[1]; i != v17; i -= 16)
    {
      long long v19 = *((_OWORD *)i - 1);
      *((_OWORD *)v14 - 1) = v19;
      v14 -= 16;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
    {
      operator delete(v17);
    }
  }
}

_DWORD *LiChannelT<int>::append(uint64_t a1, _DWORD *a2)
{
  uint64_t v4 = a1 + 16;
  unint64_t v5 = *(void *)(a1 + 16);
  double v6 = *(_DWORD **)(a1 + 8);
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v8 = *(_DWORD **)a1;
    uint64_t v9 = ((uint64_t)v6 - *(void *)a1) >> 2;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 62) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v5 - (void)v8;
    if (v11 >> 1 > v10) {
      unint64_t v10 = v11 >> 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      double v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v4, v12);
      uint64_t v8 = *(_DWORD **)a1;
      double v6 = *(_DWORD **)(a1 + 8);
    }
    else
    {
      double v13 = 0;
    }
    double v14 = &v13[4 * v9];
    long long v15 = &v13[4 * v12];
    *(_DWORD *)double v14 = *a2;
    int v7 = v14 + 4;
    while (v6 != v8)
    {
      int v16 = *--v6;
      *((_DWORD *)v14 - 1) = v16;
      v14 -= 4;
    }
    *(void *)a1 = v14;
    *(void *)(a1 + 8) = v7;
    *(void *)(a1 + 16) = v15;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *double v6 = *a2;
    int v7 = v6 + 1;
  }
  *(void *)(a1 + 8) = v7;
  return v7 - 1;
}

uint64_t LiChannelT<PCVector3<double>>::append(uint64_t *a1, uint64_t a2)
{
  unint64_t v3 = a1[1];
  if (v3 >= a1[2])
  {
    uint64_t v4 = std::vector<PCVector3<double>>::__push_back_slow_path<PCVector3<double> const&>(a1, a2);
  }
  else
  {
    *(_OWORD *)unint64_t v3 = *(_OWORD *)a2;
    *(void *)(v3 + 16) = *(void *)(a2 + 16);
    uint64_t v4 = v3 + 24;
  }
  a1[1] = v4;
  return v4 - 24;
}

uint64_t *removeDuplicatePoints<PCVector3<double>>(uint64_t *result, void **a2, void *a3, double a4)
{
  uint64_t v4 = *result;
  uint64_t v5 = result[1];
  unint64_t v6 = (unint64_t)(v5 - *result) >> 2;
  if ((int)v6 >= 1)
  {
    uint64_t v9 = result;
    int v10 = 0;
    double v11 = a4 * a4;
    do
    {
      uint64_t v12 = *(unsigned int *)(v4 + 4 * (v10 % (int)v6));
      if ((v12 & 0x80000000) != 0) {
        double v13 = (float64x2_t *)(*a3 + 24 * ~v12);
      }
      else {
        double v13 = (float64x2_t *)(**a2 + 32 * v12);
      }
      int v14 = (v10 + 1) % (int)v6;
      uint64_t v15 = *(unsigned int *)(v4 + 4 * v14);
      if ((v15 & 0x80000000) != 0) {
        int v16 = (float64x2_t *)(*a3 + 24 * ~v15);
      }
      else {
        int v16 = (float64x2_t *)(**a2 + 32 * v15);
      }
      float64_t v17 = v13[1].f64[0] - v16[1].f64[0];
      float64x2_t v18 = vsubq_f64(*v13, *v16);
      if (vaddvq_f64(vmulq_f64(v18, v18)) + v17 * v17 <= v11)
      {
        if ((int)v15 < 0) {
          int v14 = v10;
        }
        uint64_t v19 = v4 + 4 * v14;
        uint64_t v20 = v5 - (v19 + 4);
        if (v5 != v19 + 4)
        {
          double result = (uint64_t *)memmove((void *)(v4 + 4 * v14), (const void *)(v19 + 4), v5 - (v19 + 4));
          uint64_t v4 = *v9;
        }
        uint64_t v5 = v19 + v20;
        v9[1] = v19 + v20;
      }
      else
      {
        ++v10;
      }
      unint64_t v6 = (unint64_t)(v5 - v4) >> 2;
    }
    while (v10 < (int)v6);
  }
  return result;
}

__n128 copy<LiChannelT<PCVector3<double>>,LiPolygon::PosFacet>(void *a1, uint64_t **a2)
{
  int v4 = -1431655765 * ((uint64_t)(a1[1] - *a1) >> 3);
  std::vector<LiPolygon::PosEdge>::resize(*a2, v4);
  if (v4 >= 1)
  {
    for (uint64_t i = 0; i != v4; ++i)
    {
      int v7 = (__n128 *)(*a1 + 24 * i);
      uint64_t v8 = (__n128 *)(**a2 + 32 * i);
      __n128 result = *v7;
      v8[1].n128_u64[0] = v7[1].n128_u64[0];
      __n128 *v8 = result;
    }
  }
  return result;
}

void copy<LiChannelT<int>,LiImagePolygon::EdgeFacet>(int **a1, uint64_t **a2)
{
  uint64_t v4 = (char *)a1[1] - (char *)*a1;
  std::vector<LiPolygon::PosEdge>::resize(*a2, (int)(v4 >> 2));
  if ((int)((unint64_t)v4 >> 2) >= 1)
  {
    uint64_t v5 = *a1;
    uint64_t v6 = ((unint64_t)v4 >> 2);
    int v7 = (_DWORD *)(**a2 + 24);
    do
    {
      int v8 = *v5++;
      *int v7 = v8;
      v7 += 8;
      --v6;
    }
    while (v6);
  }
}

void std::vector<PCVector3<double>>::resize(uint64_t *a1, unint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  BOOL v3 = a2 >= v2;
  unint64_t v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<PCVector3<double>>::__append(a1, v4);
  }
  else if (!v3)
  {
    a1[1] = *a1 + 24 * a2;
  }
}

void std::vector<PCVector3<double>>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v13 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v19 = v4;
    if (v11) {
      uint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cc::point_t<double,false,false>>>(v4, v11);
    }
    else {
      uint64_t v12 = 0;
    }
    __p = v12;
    int v16 = &v12[24 * v8];
    float64x2_t v18 = &v12[24 * v11];
    size_t v14 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v16, v14);
    float64_t v17 = &v16[v14];
    std::vector<PCVector3<double>>::__swap_out_circular_buffer(a1, &__p);
    if (v17 != v16) {
      float64_t v17 = &v16[(v17 - v16 - 24) % 0x18uLL];
    }
    if (__p) {
      operator delete(__p);
    }
  }
}

void sub_1B7A9630C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t LiPhysicsUtils::ApplyForce(uint64_t result, void *a2, uint64_t a3, float a4)
{
  uint64_t v6 = (double *)result;
  if (*(unsigned char *)(result + 1))
  {
    double v7 = *(double *)(result + 8);
    double v8 = *(double *)(result + 16);
    double v9 = *(double *)(result + 24);
    double v10 = sqrt(v7 * v7 + v8 * v8 + v9 * v9);
    if (v10 < 0.000000100000001 && v10 > -0.000000100000001) {
      double v10 = 1.0;
    }
    double v12 = v7 / v10;
    double v13 = v8 / v10;
    double v14 = v9 / v10;
LABEL_8:
    double v15 = v6[5] * a4;
    double v16 = v12 * v15;
    double v17 = v13 * v15;
    double v18 = v14 * v15;
    uint64_t v19 = (void *)[a2 physicsBody];
    *(float *)&double v20 = v16;
    *(float *)&double v21 = v17;
    *(float *)&double v22 = v18;
    return objc_msgSend(v19, "applyForce:impulse:", *(unsigned __int8 *)v6, v20, v21, v22);
  }
  if (*(_DWORD *)(result + 32))
  {
    *(void *)&long long v35 = *(unsigned int *)(result + 32);
    long long v23 = std::map<unsigned long long,std::shared_ptr<Li3DEngineObjectData>>::at(a3, (unint64_t *)&v35);
    uint64_t v24 = *v23;
    long long v25 = (std::__shared_weak_count *)v23[1];
    if (v25) {
      atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    long long v26 = (void *)[*(id *)(v24 + 440) childNodesPassingTest:&__block_literal_global_28_0];
    if ([v26 count]) {
      double v27 = (void *)[v26 firstObject];
    }
    else {
      double v27 = 0;
    }
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v28 = (void *)[a2 presentationNode];
    if (v28)
    {
      [v28 worldTransform];
    }
    else
    {
      long long v37 = 0u;
      long long v38 = 0u;
      long long v35 = 0u;
      long long v36 = 0u;
    }
    long long v29 = objc_msgSend(v27, "presentationNode", 0, 0, 0, 0, 0, 0);
    if (v29) {
      [v29 worldTransform];
    }
    double v30 = (float)(0.0 - *(float *)&v38);
    double v31 = (float)(0.0 - *((float *)&v38 + 1));
    double v32 = (float)(0.0 - *((float *)&v38 + 2));
    double v33 = sqrt(v30 * v30 + v31 * v31 + v32 * v32);
    if (v33 < 0.000000100000001 && v33 > -0.000000100000001) {
      double v33 = 1.0;
    }
    double v12 = v30 / v33;
    double v13 = v31 / v33;
    double v14 = v32 / v33;
    if (v25) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v25);
    }
    goto LABEL_8;
  }
  return result;
}

void sub_1B7A966B4(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t LiPhysicsUtils::ConfigureScene(LiPhysicsUtils *this, Li3DEngineWorldData *a2, Li3DEngineScene *a3, SCNScene *a4, float a5)
{
  int v5 = (int)a4;
  uint64_t v6 = a3;
  uint64_t v169 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    uint64_t v6 = a3;
    objc_msgSend((id)-[Li3DEngineScene physicsWorld](a3, "physicsWorld"), "performSelector:", NSSelectorFromString(&cfstr_Reset.isa));
    objc_msgSend((id)-[Li3DEngineScene physicsWorld](a3, "physicsWorld"), "setTimeStep:", 0.0166666667);
    [(id)Li3DEngineScene::sceneManager(a2) resetSim];
    Li3DEngineScene::reset_NoLock((id *)a2);
  }
  double v108 = a5;
  float v9 = -(*((double *)this + 29) * a5);
  double v10 = (void *)[(Li3DEngineScene *)v6 physicsWorld];
  *(float *)&double v11 = v9;
  objc_msgSend(v10, "setGravity:", 0.0, v11, 0.0);
  double v12 = (char *)*((void *)this + 26);
  uint64_t v107 = (char *)this + 216;
  if (v12 != (char *)this + 216)
  {
    size_t v102 = (char *)this + 208;
    uint64_t v113 = *MEMORY[0x1E4F3B370];
    uint64_t v112 = *MEMORY[0x1E4F3B390];
    p_m23 = &a.m23;
    p_float m12 = &a.m12;
    uint64_t v111 = *MEMORY[0x1E4F3B380];
    uint64_t v110 = *MEMORY[0x1E4F3B368];
    uint64_t v98 = 1065353216;
    double v103 = a2;
    while (1)
    {
      uint64_t v13 = *((void *)v12 + 5);
      double v14 = (std::__shared_weak_count *)*((void *)v12 + 6);
      uint64_t v122 = (Li3DEngineObjectData *)v13;
      size_t v123 = v14;
      if (v14) {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      double v15 = *(SCNNode **)(v13 + 440);
      long long v16 = *(_OWORD *)(v13 + 40);
      v121[0] = *(_OWORD *)(v13 + 24);
      v121[1] = v16;
      long long v17 = *(_OWORD *)(v13 + 72);
      v121[2] = *(_OWORD *)(v13 + 56);
      v121[3] = v17;
      long long v119 = 0u;
      long long v120 = 0u;
      long long v117 = 0u;
      long long v118 = 0u;
      trans((const Mat4f *)v121, (uint64_t)&v117);
      v116[0] = v117;
      v116[1] = v118;
      v116[2] = v119;
      v116[3] = v120;
      [(SCNNode *)v15 setTransform:v116];
      Li3DEngineScene::setNodeActiveState_NoLock(a2, v15, *((unsigned char *)v122 + 424) == 0, *((double *)v122 + 52));
      BOOL v18 = *((_DWORD *)v122 + 50) == 8;
      v114[0] = MEMORY[0x1E4F143A8];
      v114[1] = *(void *)"";
      v114[2] = ___ZN14LiPhysicsUtils14ConfigureSceneEP19Li3DEngineWorldDataP15Li3DEngineSceneP8SCNScenefb_block_invoke;
      v114[3] = &__block_descriptor_33_e21_v24__0__SCNNode_8_B16l;
      BOOL v115 = v18;
      [(SCNNode *)v15 enumerateChildNodesUsingBlock:v114];
      uint64_t v19 = v122;
      double v20 = (void *)*((void *)v122 + 55);
      if (!v20) {
        goto LABEL_83;
      }
      if (v5)
      {
        [*((id *)v122 + 55) setPhysicsBody:0];
        [v20 setPhysicsField:0];
        double v21 = (void *)[v20 presentationNode];
        memset(&v142, 0, sizeof(v142));
        if (v21) {
          [v21 transform];
        }
        SCNMatrix4 v168 = v142;
        objc_msgSend(v20, "setTransform:", &v168, v98, p_m23, p_m12);
        long long v22 = *(_OWORD *)((char *)v122 + 24);
        long long v23 = *(_OWORD *)((char *)v122 + 40);
        long long v24 = *(_OWORD *)((char *)v122 + 72);
        *(_OWORD *)&a.m31 = *(_OWORD *)((char *)v122 + 56);
        *(_OWORD *)&a.m41 = v24;
        *(_OWORD *)&a.m11 = v22;
        *(_OWORD *)&a.m21 = v23;
        memset(&b, 0, sizeof(b));
        trans((const Mat4f *)&a, (uint64_t)&b);
        SCNMatrix4 v160 = b;
        [v20 setTransform:&v160];
        uint64_t v19 = v122;
      }
      *(void *)&double v25 = Li3DEngineObjectData::physicsParams(v19, (uint64_t)&v142).n128_u64[0];
      float m12 = v142.m12;
      int v27 = *((unsigned char *)v122 + 424) ? 0 : LODWORD(v142.m11);
      uint64_t v28 = v27 == 3 ? 2 : v27 == 2;
      if ((uint64_t v29 = objc_msgSend(v20, "physicsBody", v25, v98, p_m23, p_m12), v27) && !v29
        || objc_msgSend((id)objc_msgSend(v20, "physicsBody"), "type") != v28)
      {
        if (LODWORD(m12) != 3) {
          break;
        }
      }
LABEL_33:
      if (m12 == 0.0 || !v27)
      {
        if (m12 == 0.0 && objc_msgSend((id)objc_msgSend(v20, "physicsBody"), "physicsShape")) {
          objc_msgSend((id)objc_msgSend(v20, "physicsBody"), "setPhysicsShape:", 0);
        }
      }
      else if (!objc_msgSend((id)objc_msgSend(v20, "physicsBody"), "physicsShape"))
      {
        switch(LODWORD(m12))
        {
          case 1:
            long long v163 = 0uLL;
            uint64_t v162 = 0;
            int v164 = 4;
            uint64_t v165 = 0;
            uint64_t v166 = 0;
            int v167 = 0;
            PCMatrix44Tmpl<float>::getTransformation(v121, (uint64_t)&v162);
            [v20 getBoundingBoxMin:&v155 max:&v153];
            [v20 scale];
            v155.f32[0] = v46 * v155.f32[0];
            v155.f32[1] = v47 * v155.f32[1];
            float v156 = v48 * v156;
            *(float *)&double v153 = v46 * *(float *)&v153;
            *((float *)&v153 + 1) = v47 * *((float *)&v153 + 1);
            float v154 = v48 * v154;
            uint64_t v49 = objc_msgSend(MEMORY[0x1E4F3B1E8], "boxWithWidth:height:length:chamferRadius:", vabds_f32(*(float *)&v153, v155.f32[0]), vabds_f32(*((float *)&v153 + 1), v155.f32[1]), vabds_f32(v154, v156), 0.0);
            uint64_t v50 = [MEMORY[0x1E4F3B248] shapeWithGeometry:v49 options:0];
            float v51 = (float)(v154 + v156) * 0.5;
            *(void *)p_float m12 = 0;
            *((void *)p_m12 + 1) = 0;
            a.m11 = 1.0;
            a.m22 = 1.0;
            *(void *)p_m23 = 0;
            *((void *)p_m23 + 1) = 0;
            *(void *)&a.m33 = v98;
            *(float32x2_t *)&a.m41 = vmul_f32(vadd_f32(*(float32x2_t *)&v153, v155), (float32x2_t)0x3F0000003F000000);
            a.m43 = v51;
            a.m44 = 1.0;
            long long v52 = *MEMORY[0x1E4F3B358];
            long long v53 = *(_OWORD *)(MEMORY[0x1E4F3B358] + 16);
            long long v54 = *(_OWORD *)(MEMORY[0x1E4F3B358] + 48);
            *(_OWORD *)&b.m31 = *(_OWORD *)(MEMORY[0x1E4F3B358] + 32);
            *(_OWORD *)&b.m41 = v54;
            *(_OWORD *)&b.m11 = v52;
            *(_OWORD *)&b.m21 = v53;
            SCNMatrix4Mult(&v168, &a, &b);
            SCNMatrix4 v160 = v168;
            uint64_t v55 = [MEMORY[0x1E4F29238] valueWithSCNMatrix4:&v160];
            double v56 = (void *)MEMORY[0x1E4F3B248];
            uint64_t v159 = v50;
            uint64_t v57 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v159 count:1];
            uint64_t v158 = v55;
            objc_msgSend((id)objc_msgSend(v20, "physicsBody"), "setPhysicsShape:", objc_msgSend(v56, "shapeWithShapes:transforms:", v57, objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", &v158, 1)));
            break;
          case 3:
            double v58 = (void *)[v20 childNodesPassingTest:&__block_literal_global_67];
            memset(&a, 0, sizeof(a));
            uint64_t v59 = [v58 countByEnumeratingWithState:&a objects:&v168 count:16];
            int v106 = v5;
            if (v59)
            {
              uint64_t v60 = **(void **)&a.m21;
              do
              {
                for (uint64_t i = 0; i != v59; ++i)
                {
                  if (**(void **)&a.m21 != v60) {
                    objc_enumerationMutation(v58);
                  }
                  uint64_t v62 = *(void **)(*(void *)&a.m13 + 8 * i);
                  if (![v62 physicsBody])
                  {
                    objc_msgSend((id)objc_msgSend(v62, "parentNode"), "scale");
                    uint64_t v63 = objc_msgSend(MEMORY[0x1E4F29238], "valueWithSCNVector3:");
                    uint64_t v64 = (void *)MEMORY[0x1E4F3B248];
                    uint64_t v65 = [v62 geometry];
                    *(void *)&v160.m11 = v113;
                    *(void *)&v160.m13 = v112;
                    *(void *)&b.m11 = v63;
                    *(void *)&b.m13 = v111;
                    *(void *)&v160.m21 = v110;
                    *(void *)&b.m21 = &unk_1F11EC530;
                    uint64_t v162 = objc_msgSend(v64, "shapeWithGeometry:options:", v65, objc_msgSend(MEMORY[0x1E4F1C9E8], "dictionaryWithObjects:forKeys:count:", &b, &v160, 3));
                    objc_msgSend(v62, "setPhysicsBody:", objc_msgSend(MEMORY[0x1E4F3B230], "bodyWithType:shape:", 0, objc_msgSend(MEMORY[0x1E4F3B248], "shapeWithShapes:transforms:", objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", &v162, 1), 0)));
                  }
                }
                uint64_t v59 = [v58 countByEnumeratingWithState:&a objects:&v168 count:16];
              }
              while (v59);
            }
            int v5 = v106;
            break;
          case 2:
            long long v163 = 0uLL;
            uint64_t v162 = 0;
            int v164 = 4;
            uint64_t v165 = 0;
            uint64_t v166 = 0;
            int v167 = 0;
            PCMatrix44Tmpl<float>::getTransformation(v121, (uint64_t)&v162);
            double v153 = 1.0;
            [v20 getBoundingSphereCenter:&v155 radius:&v153];
            float32x2_t v155 = vmul_f32(v155, *(float32x2_t *)((char *)&v163 + 4));
            float v156 = v156 * *((float *)&v163 + 3);
            double v153 = v153 * *((float *)&v163 + 3);
            uint64_t v32 = objc_msgSend(MEMORY[0x1E4F3B278], "sphereWithRadius:");
            uint64_t v33 = [MEMORY[0x1E4F3B248] shapeWithGeometry:v32 options:0];
            float v34 = v156;
            *(void *)p_float m12 = 0;
            *((void *)p_m12 + 1) = 0;
            a.m11 = 1.0;
            a.m22 = 1.0;
            *(void *)p_m23 = 0;
            *((void *)p_m23 + 1) = 0;
            *(void *)&a.m33 = v98;
            *(float32x2_t *)&a.m41 = v155;
            a.m43 = v34;
            a.m44 = 1.0;
            long long v35 = *(_OWORD *)(MEMORY[0x1E4F3B358] + 48);
            *(_OWORD *)&b.m31 = *(_OWORD *)(MEMORY[0x1E4F3B358] + 32);
            *(_OWORD *)&b.m41 = v35;
            long long v36 = *(_OWORD *)(MEMORY[0x1E4F3B358] + 16);
            *(_OWORD *)&b.m11 = *MEMORY[0x1E4F3B358];
            *(_OWORD *)&b.m21 = v36;
            SCNMatrix4Mult(&v168, &a, &b);
            SCNMatrix4 v160 = v168;
            uint64_t v37 = [MEMORY[0x1E4F29238] valueWithSCNMatrix4:&v160];
            long long v38 = (void *)MEMORY[0x1E4F3B248];
            uint64_t v159 = v33;
            uint64_t v39 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v159 count:1];
            uint64_t v158 = v37;
            objc_msgSend((id)objc_msgSend(v20, "physicsBody"), "setPhysicsShape:", objc_msgSend(v38, "shapeWithShapes:transforms:", v39, objc_msgSend(MEMORY[0x1E4F1C978], "arrayWithObjects:count:", &v158, 1)));
            float32x2_t v40 = v155;
            float v41 = v156;
            int v42 = (void *)[v20 physicsBody];
            LODWORD(v44) = v40.i32[1];
            LODWORD(v43) = v40.i32[0];
            *(float *)&double v45 = v41;
            objc_msgSend(v42, "setCenterOfMassOffset:", v43, v44, v45);
            objc_msgSend((id)objc_msgSend(v20, "physicsBody"), "setContinuousCollisionDetectionThreshold:", v153 + v153);
            break;
        }
      }
      objc_msgSend((id)objc_msgSend(v20, "physicsBody"), "setMass:", *(double *)&v150);
      objc_msgSend((id)objc_msgSend(v20, "physicsBody"), "setFriction:", *(double *)&v151);
      objc_msgSend((id)objc_msgSend(v20, "physicsBody"), "setRestitution:", *((double *)&v150 + 1));
      objc_msgSend((id)objc_msgSend(v20, "physicsBody"), "setCharge:", *((double *)&v151 + 1) * v108);
      v124[0] = MEMORY[0x1E4F143A8];
      v124[1] = 3321888768;
      v124[2] = ___ZL16ConfigurePhysicsRKNSt3__110shared_ptrI20Li3DEngineObjectDataEEPNS_3mapIyS2_NS_4lessIyEENS_9allocatorINS_4pairIKyS2_EEEEEERK14PCMatrix44TmplIfEP15Li3DEngineScenefb_block_invoke;
      v124[3] = &__block_descriptor_252_e8_32c36_ZTSK29Li3DEngineObjectPhysicsParams_e21_v24__0__SCNNode_8_B16l;
      v124[4] = *(void *)&v142.m11;
      LOWORD(v125) = LOWORD(v142.m13);
      long long v126 = *(_OWORD *)&v142.m21;
      uint64_t v127 = *(void *)&v142.m31;
      long long v128 = *(_OWORD *)&v142.m33;
      id v129 = *(id *)&v142.m43;
      ProCore_Impl::PCNSRefImpl::retain(&v129);
      long long v130 = v143;
      long long v131 = v144;
      long long v132 = v145;
      long long v133 = v146;
      long long v134 = v147;
      long long v135 = v148;
      double v136 = v149;
      uint64_t v139 = v152;
      long long v137 = v150;
      long long v138 = v151;
      float v141 = a5;
      uint64_t v140 = &v122;
      [v20 enumerateChildNodesUsingBlock:v124];
      a2 = v103;
      uint64_t v66 = (void *)Li3DEngineScene::sceneManager(v103);
      *(float *)&double v67 = a5;
      [v66 applyForce:&v142.m13 node:v20 arScale:v102 objects:v67];
      int v68 = v143;
      double v69 = *((double *)&v143 + 1);
      double v70 = *(double *)&v144;
      int v71 = BYTE8(v144);
      long long v72 = v145;
      long long v104 = v146;
      long long v73 = v148;
      double v74 = v149;
      long long v105 = v147;
      double v75 = sqrt(*((double *)&v147 + 1) * *((double *)&v147 + 1)+ *(double *)&v148 * *(double *)&v148+ *((double *)&v148 + 1) * *((double *)&v148 + 1));
      if (v75 >= 0.000000100000001 || v75 <= -0.000000100000001) {
        double v77 = v75;
      }
      else {
        double v77 = 1.0;
      }
      uint64_t v78 = [v20 physicsField];
      if (v68 == -1)
      {
        if (v78)
        {
LABEL_65:
          uint64_t v80 = 0;
LABEL_74:
          [v20 setPhysicsField:v80];
        }
      }
      else if (!v78)
      {
        switch(v68)
        {
          case 0:
            uint64_t v79 = [MEMORY[0x1E4F3B240] dragField];
            break;
          case 1:
            uint64_t v79 = [MEMORY[0x1E4F3B240] vortexField];
            break;
          case 2:
            uint64_t v79 = [MEMORY[0x1E4F3B240] radialGravityField];
            break;
          case 3:
            uint64_t v79 = [MEMORY[0x1E4F3B240] linearGravityField];
            break;
          case 4:
            uint64_t v79 = objc_msgSend(MEMORY[0x1E4F3B240], "noiseFieldWithSmoothness:animationSpeed:", v72);
            break;
          case 5:
            uint64_t v79 = objc_msgSend(MEMORY[0x1E4F3B240], "turbulenceFieldWithSmoothness:animationSpeed:", v72);
            break;
          case 6:
            uint64_t v79 = [MEMORY[0x1E4F3B240] electricField];
            break;
          case 7:
            uint64_t v79 = [MEMORY[0x1E4F3B240] magneticField];
            break;
          default:
            goto LABEL_65;
        }
        uint64_t v80 = v79;
        goto LABEL_74;
      }
      if ([v20 physicsField])
      {
        objc_msgSend((id)objc_msgSend(v20, "physicsField"), "setFalloffExponent:", v70);
        size_t v81 = (void *)[v20 physicsField];
        double v82 = a5;
        if ((v68 & 0xFFFFFFFA) != 2) {
          double v82 = 1.0;
        }
        [v81 setStrength:v69 * v82];
        objc_msgSend((id)objc_msgSend(v20, "physicsField"), "setMinimumDistance:", v74);
        if (v71)
        {
          float v83 = 3.4028e38;
          float v84 = 3.4028e38;
          float v85 = 3.4028e38;
        }
        else
        {
          float v83 = *(double *)&v104 * v108;
          float v84 = *((double *)&v104 + 1) * v108;
          float v85 = *(double *)&v105 * v108;
        }
        uint64_t v86 = (void *)[v20 physicsField];
        *(float *)&double v87 = v83;
        *(float *)&double v88 = v84;
        *(float *)&double v89 = v85;
        objc_msgSend(v86, "setHalfExtent:", v87, v88, v89);
        size_t v90 = (void *)[v20 physicsField];
        double v91 = *((double *)&v73 + 1) / v77;
        *(float *)&double v92 = *((double *)&v73 + 1) / v77;
        *(float *)&double v91 = *(double *)&v73 / v77;
        double v93 = *((double *)&v105 + 1) / v77;
        *(float *)&double v93 = *((double *)&v105 + 1) / v77;
        objc_msgSend(v90, "setDirection:", v93, v91, v92);
      }
      Li3DEngineObjectForceParams::~Li3DEngineObjectForceParams(&v125);
      Li3DEngineObjectForceParams::~Li3DEngineObjectForceParams((id *)&v142.m13);
LABEL_83:
      if (v123) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v123);
      }
      double v94 = (char *)*((void *)v12 + 1);
      if (v94)
      {
        do
        {
          uint64_t v95 = v94;
          double v94 = *(char **)v94;
        }
        while (v94);
      }
      else
      {
        do
        {
          uint64_t v95 = (char *)*((void *)v12 + 2);
          BOOL v96 = *(void *)v95 == (void)v12;
          double v12 = v95;
        }
        while (!v96);
      }
      double v12 = v95;
      if (v95 == v107) {
        return objc_msgSend((id)-[Li3DEngineScene physicsWorld](a3, "physicsWorld", v98, p_m23, p_m12), "updateCollisionPairs");
      }
    }
    switch(v27)
    {
      case 1:
        uint64_t v30 = [MEMORY[0x1E4F3B230] staticBody];
        break;
      case 3:
        uint64_t v30 = [MEMORY[0x1E4F3B230] kinematicBody];
        break;
      case 2:
        uint64_t v30 = [MEMORY[0x1E4F3B230] dynamicBody];
        break;
      default:
        if ((v5 & 1) != 0 || [v20 physicsBody])
        {
          [v20 setPhysicsBody:0];
          uint64_t v31 = 0;
        }
        else
        {
          uint64_t v31 = 0;
        }
        goto LABEL_32;
    }
    uint64_t v31 = v30;
LABEL_32:
    [v20 setPhysicsBody:v31];
    goto LABEL_33;
  }
  return objc_msgSend((id)-[Li3DEngineScene physicsWorld](a3, "physicsWorld", v98, p_m23, p_m12), "updateCollisionPairs");
}

void sub_1B7A97514(_Unwind_Exception *a1)
{
}

uint64_t ___ZN14LiPhysicsUtils14ConfigureSceneEP19Li3DEngineWorldDataP15Li3DEngineSceneP8SCNScenefb_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t result = [a2 geometry];
  if (result)
  {
    long long v11 = 0u;
    long long v12 = 0u;
    long long v9 = 0u;
    long long v10 = 0u;
    int v5 = objc_msgSend((id)objc_msgSend(a2, "geometry", 0), "materials");
    uint64_t result = [v5 countByEnumeratingWithState:&v9 objects:v13 count:16];
    if (result)
    {
      uint64_t v6 = result;
      uint64_t v7 = *(void *)v10;
      do
      {
        uint64_t v8 = 0;
        do
        {
          if (*(void *)v10 != v7) {
            objc_enumerationMutation(v5);
          }
          [*(id *)(*((void *)&v9 + 1) + 8 * v8++) setBlendMode:*(unsigned __int8 *)(a1 + 32)];
        }
        while (v6 != v8);
        uint64_t result = [v5 countByEnumeratingWithState:&v9 objects:v13 count:16];
        uint64_t v6 = result;
      }
      while (result);
    }
  }
  return result;
}

void *std::map<unsigned long long,std::shared_ptr<Li3DEngineObjectData>>::at(uint64_t a1, unint64_t *a2)
{
  unint64_t v2 = *(void **)(a1 + 8);
  if (!v2) {
LABEL_8:
  }
    std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
  unint64_t v3 = *a2;
  while (1)
  {
    while (1)
    {
      unint64_t v4 = v2[4];
      if (v3 >= v4) {
        break;
      }
      unint64_t v2 = (void *)*v2;
      if (!v2) {
        goto LABEL_8;
      }
    }
    if (v4 >= v3) {
      return v2 + 5;
    }
    unint64_t v2 = (void *)v2[1];
    if (!v2) {
      goto LABEL_8;
    }
  }
}

__n128 Li3DEngineObjectData::physicsParams@<Q0>(Li3DEngineObjectData *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v3 = (char *)this + 208;
  *(void *)a2 = *((void *)this + 26);
  *(_WORD *)(a2 + 8) = *((_WORD *)this + 108);
  *(_OWORD *)(a2 + 16) = *((_OWORD *)this + 14);
  *(void *)(a2 + 32) = *((void *)this + 30);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)((char *)this + 248);
  *(void *)(a2 + LiDepthSorter::stackSort((uint64_t)this + 56) = *((void *)this + 33);
  ProCore_Impl::PCNSRefImpl::retain((id *)(a2 + 56));
  long long v4 = *((_OWORD *)v3 + 5);
  *(_OWORD *)(a2 + 64) = *((_OWORD *)v3 + 4);
  *(_OWORD *)(a2 + 80) = v4;
  long long v5 = *((_OWORD *)v3 + 7);
  *(_OWORD *)(a2 + 96) = *((_OWORD *)v3 + 6);
  *(_OWORD *)(a2 + 112) = v5;
  long long v6 = *((_OWORD *)v3 + 9);
  *(_OWORD *)(a2 + 128) = *((_OWORD *)v3 + 8);
  *(_OWORD *)(a2 + 144) = v6;
  *(void *)(a2 + 160) = *((void *)v3 + 20);
  *(void *)(a2 + 200) = *((void *)v3 + 25);
  *(_OWORD *)(a2 + 184) = *(_OWORD *)(v3 + 184);
  __n128 result = *(__n128 *)(v3 + 168);
  *(__n128 *)(a2 + 168) = result;
  return result;
}

uint64_t ___ZL16ConfigurePhysicsRKNSt3__110shared_ptrI20Li3DEngineObjectDataEEPNS_3mapIyS2_NS_4lessIyEENS_9allocatorINS_4pairIKyS2_EEEEEERK14PCMatrix44TmplIfEP15Li3DEngineScenefb_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  unint64_t v3 = objc_msgSend(a2, "particleSystems", 0);
  uint64_t result = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (result)
  {
    uint64_t v5 = result;
    uint64_t v6 = *(void *)v12;
    do
    {
      uint64_t v7 = 0;
      do
      {
        if (*(void *)v12 != v6) {
          objc_enumerationMutation(v3);
        }
        uint64_t v8 = *(SCNParticleSystem **)(*((void *)&v11 + 1) + 8 * v7);
        [(SCNParticleSystem *)v8 setParticleCharge:*(double *)(a1 + 224) * *(float *)(a1 + 248)];
        [(SCNParticleSystem *)v8 setParticleChargeVariation:*(double *)(a1 + 232) * *(float *)(a1 + 248)];
        uint64_t v9 = Li3DEngineScene::particleParameters(*(Li3DEngineScene **)(**(void **)(a1 + 240) + 8), v8);
        if (v9)
        {
          uint64_t v10 = v9;
          [(SCNParticleSystem *)v8 setParticleVelocity:*(double *)(v9 + 8) * *(float *)(a1 + 248)];
          [(SCNParticleSystem *)v8 setParticleVelocityVariation:*(double *)(v10 + 16) * *(float *)(a1 + 248)];
        }
        ++v7;
      }
      while (v5 != v7);
      uint64_t result = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
      uint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

__n128 __copy_helper_block_e8_32c36_ZTSK29Li3DEngineObjectPhysicsParams(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(_WORD *)(a1 + 40) = *(_WORD *)(a2 + 40);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  uint64_t v3 = a1 + 88;
  ProCore_Impl::PCNSRefImpl::retain((id *)(a1 + 88));
  long long v4 = *(_OWORD *)(a2 + 96);
  long long v5 = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(v3 + 40) = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(v3 + 24) = v5;
  *(_OWORD *)(v3 + 8) = v4;
  *(_OWORD *)(v3 + LiDepthSorter::stackSort((uint64_t)this + 56) = *(_OWORD *)(a2 + 144);
  *(_OWORD *)(v3 + 72) = *(_OWORD *)(a2 + 160);
  *(_OWORD *)(v3 + 88) = *(_OWORD *)(a2 + 176);
  *(void *)(v3 + 104) = *(void *)(a2 + 192);
  __n128 result = *(__n128 *)(a2 + 200);
  long long v7 = *(_OWORD *)(a2 + 216);
  *(void *)(v3 + 144) = *(void *)(a2 + 232);
  *(__n128 *)(v3 + 112) = result;
  *(_OWORD *)(v3 + 128) = v7;
  return result;
}

void __destroy_helper_block_e8_32c36_ZTSK29Li3DEngineObjectPhysicsParams(uint64_t a1)
{
}

BOOL PCMatrix44Tmpl<float>::getTransformation(long long *a1, uint64_t a2)
{
  int v55 = 1065353216;
  float v52 = 1.0;
  float v49 = 1.0;
  int v46 = 1065353216;
  uint64_t v48 = 0;
  uint64_t v47 = 0;
  uint64_t v50 = 0;
  uint64_t v51 = 0;
  uint64_t v54 = 0;
  uint64_t v53 = 0;
  BOOL PartialTransformation = PCMatrix44Tmpl<float>::getPartialTransformation(a1, a2, (float32x4_t *)&v46);
  if (PartialTransformation)
  {
    switch(*(_DWORD *)(a2 + 24))
    {
      case 0:
        float v11 = asin((float)-*(float *)&v51);
        *(float *)(a2 + 32) = v11;
        float v12 = cos(v11);
        if (v12 > -0.00001 && v12 < 0.00001)
        {
          float v13 = v49;
          float v14 = -*(float *)&v50;
          goto LABEL_24;
        }
        float v32 = atan2(*((float *)&v51 + 1), v52);
        *(float *)(a2 + 28) = v32;
        float v33 = *((float *)&v48 + 1);
        float v34 = *(float *)&v46;
        goto LABEL_34;
      case 1:
        float v15 = asin(*((float *)&v48 + 1));
        *(float *)(a2 + 36) = v15;
        float v16 = cos(v15);
        if (v16 > -0.00001 && v16 < 0.00001)
        {
          float v17 = *((float *)&v51 + 1);
          float v18 = v52;
          goto LABEL_16;
        }
        float v35 = atan2((float)-*(float *)&v50, v49);
        *(float *)(a2 + 28) = v35;
        float v36 = *(float *)&v46;
        float v37 = -*(float *)&v51;
        goto LABEL_30;
      case 2:
        float v19 = asin(*((float *)&v51 + 1));
        *(float *)(a2 + 28) = v19;
        float v20 = cos(v19);
        if (v20 > -0.00001 && v20 < 0.00001)
        {
          float v21 = *((float *)&v47 + 1);
          float v22 = *(float *)&v46;
          goto LABEL_20;
        }
        float v38 = atan2((float)-*(float *)&v51, v52);
        *(float *)(a2 + 32) = v38;
        float v39 = *(float *)&v47;
        float v34 = v49;
        goto LABEL_33;
      case 3:
        float v23 = asin((float)-*(float *)&v47);
        *(float *)(a2 + 36) = v23;
        float v24 = cos(v23);
        if (v24 <= -0.00001 || v24 >= 0.00001)
        {
          float v40 = atan2(*((float *)&v51 + 1), v49);
          *(float *)(a2 + 28) = v40;
          float v37 = *((float *)&v47 + 1);
          float v36 = *(float *)&v46;
LABEL_30:
          float v41 = atan2(v37, v36);
          *(float *)(a2 + 32) = v41;
        }
        else
        {
          float v18 = v52;
          float v17 = -*(float *)&v50;
LABEL_16:
          float v25 = atan2(v17, v18);
          *(float *)(a2 + 28) = v25;
          *(_DWORD *)(a2 + 32) = 0;
        }
        return PartialTransformation;
      case 4:
        float v26 = asin((float)-*(float *)&v50);
        *(float *)(a2 + 28) = v26;
        float v27 = cos(v26);
        if (v27 <= -0.00001 || v27 >= 0.00001)
        {
          float v42 = atan2(*((float *)&v47 + 1), v52);
          *(float *)(a2 + 32) = v42;
          float v33 = *((float *)&v48 + 1);
          float v34 = v49;
          goto LABEL_34;
        }
        float v22 = *(float *)&v46;
        float v21 = -*(float *)&v51;
LABEL_20:
        float v28 = atan2(v21, v22);
        *(float *)(a2 + 32) = v28;
        goto LABEL_25;
      case 5:
        float v29 = asin(*((float *)&v47 + 1));
        *(float *)(a2 + 32) = v29;
        float v30 = cos(v29);
        if (v30 <= -0.00001 || v30 >= 0.00001)
        {
          float v43 = atan2((float)-*(float *)&v50, v52);
          *(float *)(a2 + 28) = v43;
          float v34 = *(float *)&v46;
          float v39 = *(float *)&v47;
LABEL_33:
          float v33 = -v39;
LABEL_34:
          float v44 = atan2(v33, v34);
          *(float *)(a2 + 36) = v44;
        }
        else
        {
          float v14 = *((float *)&v51 + 1);
          float v13 = v49;
LABEL_24:
          float v31 = atan2(v14, v13);
          *(float *)(a2 + 28) = v31;
LABEL_25:
          *(_DWORD *)(a2 + 36) = 0;
        }
        break;
      default:
        PCPrint("File %s, line %d should not have been reached:\n\t", v3, v4, v5, v6, v7, v8, v9, (char)"/AppleInternal/Library/BuildRoots/cb09429a-9ee5-11ef-b491-ce2c30f2a3e7/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.2.Internal.sdk/usr/local/include/ProCore/PCMatrix44.h");
        pcAbortImpl();
    }
  }
  return PartialTransformation;
}

BOOL PCMatrix44Tmpl<float>::getPartialTransformation(long long *a1, uint64_t a2, float32x4_t *a3)
{
  long long v3 = a1[1];
  long long v85 = *a1;
  long long v86 = v3;
  long long v4 = a1[3];
  long long v87 = a1[2];
  long long v88 = v4;
  if (*((float *)&v4 + 3) == 0.0) {
    return 0;
  }
  uint64_t v9 = 0;
  uint64_t v10 = &v85;
  do
  {
    for (uint64_t i = 0; i != 16; i += 4)
      *(float *)((char *)v10 + i) = *(float *)((char *)v10 + i) / *((float *)&v88 + 3);
    ++v9;
    ++v10;
  }
  while (v9 != 4);
  uint64_t v12 = 0;
  HIDWORD(v84) = 1065353216;
  uint64_t v81 = 0;
  uint64_t v82 = 1065353216;
  int v79 = 1065353216;
  int v75 = 1065353216;
  float v76 = 1.0;
  uint64_t v78 = 0;
  uint64_t v77 = 0;
  uint64_t v80 = 0;
  int v72 = 1065353216;
  int v69 = 1065353216;
  float v66 = 1.0;
  unint64_t v68 = 0;
  unint64_t v67 = 0;
  unint64_t v70 = 0;
  unint64_t v71 = 0;
  unint64_t v74 = 0;
  unint64_t v73 = 0;
  uint64_t v64 = 0;
  unint64_t v65 = 0;
  do
  {
    *(_OWORD *)((char *)&v76 + v12) = *(long long *)((char *)&v85 + v12);
    v12 += 16;
  }
  while (v12 != 64);
  uint64_t v83 = 0;
  uint64_t v84 = 0x3F80000000000000;
  v13.f32[0] = PCMatrix44Tmpl<float>::determinant(&v76);
  BOOL v5 = v13.f32[0] != 0.0;
  if (v13.f32[0] != 0.0)
  {
    uint64_t v14 = v88;
    unsigned int v15 = DWORD2(v88);
    if (*(float *)&v88 != 0.0 || *((float *)&v88 + 1) != 0.0 || *((float *)&v88 + 2) != 0.0)
    {
      uint64_t v16 = 0;
      unsigned int v17 = HIDWORD(v88);
      do
      {
        *(_OWORD *)((char *)&v66 + v16) = *(_OWORD *)((char *)&v76 + v16);
        v16 += 16;
      }
      while (v16 != 64);
      PCMatrix44Tmpl<float>::invert(&v66, &v66, 0.0);
      unsigned int v19 = HIDWORD(v67);
      unsigned int v18 = v67;
      unsigned int v20 = v68;
      unsigned int v21 = HIDWORD(v71);
      unint64_t v67 = __PAIR64__(v71, HIDWORD(v68));
      unint64_t v68 = __PAIR64__(v18, HIDWORD(v73));
      unsigned int v22 = v73;
      unsigned int v23 = HIDWORD(v70);
      unint64_t v71 = __PAIR64__(v70, v19);
      unint64_t v70 = __PAIR64__(v74, v21);
      unint64_t v73 = __PAIR64__(v20, HIDWORD(v74));
      unint64_t v74 = __PAIR64__(v22, v23);
      uint64_t v64 = v14;
      unint64_t v65 = __PAIR64__(v17, v15);
      PCMatrix44Tmpl<float>::transform<float>(&v66, (float *)&v64, (float *)&v64);
    }
    int v24 = HIDWORD(v86);
    *(_DWORD *)a2 = HIDWORD(v85);
    *(_DWORD *)(a2 + 4) = v24;
    *(_DWORD *)(a2 + 8) = HIDWORD(v87);
    a3->i64[0] = v85;
    a3->i32[2] = DWORD2(v85);
    float v25 = a3->f32[3];
    v13.f32[0] = (float)((float)(a3->f32[0] * a3->f32[0]) + (float)(a3->f32[1] * a3->f32[1]))
               + (float)(a3->f32[2] * a3->f32[2]);
    a3[1].i32[2] = DWORD2(v86);
    a3[1].i64[0] = v86;
    a3[2].i32[2] = DWORD2(v87);
    a3[2].i64[0] = v87;
    *(float *)(a2 + 12) = sqrtf(v13.f32[0] + (float)(v25 * v25));
    v13.i32[0] = 1.0;
    float32x4_t v26 = PCVector4<float>::scale(a3, v13);
    float v27 = a3->f32[1];
    float v28 = a3[1].f32[1];
    float v29 = a3[1].f32[2];
    float v30 = a3->f32[2];
    float v31 = a3->f32[3];
    float v32 = a3[1].f32[3];
    float v33 = (float)((float)((float)(a3->f32[0] * a3[1].f32[0]) + (float)(v27 * v28)) + (float)(v30 * v29))
        + (float)(v31 * v32);
    v26.f32[0] = a3[1].f32[0] - (float)(a3->f32[0] * v33);
    float32_t v34 = v28 - (float)(v27 * v33);
    float32_t v35 = v29 - (float)(v30 * v33);
    float32_t v36 = v32 - (float)(v31 * v33);
    a3[1].i32[0] = v26.i32[0];
    a3[1].f32[1] = v34;
    a3[1].f32[2] = v35;
    a3[1].f32[3] = v36;
    *(float *)(a2 + 16) = sqrtf((float)(v36 * v36)+ (float)((float)(v35 * v35) + (float)((float)(v26.f32[0] * v26.f32[0]) + (float)(v34 * v34))));
    v26.i32[0] = 1.0;
    float32x4_t v37 = PCVector4<float>::scale(a3 + 1, v26);
    v37.i32[0] = a3[2].i32[0];
    float v38 = a3->f32[0];
    float v39 = a3->f32[1];
    float v40 = a3[2].f32[1];
    float v41 = a3[2].f32[2];
    float v42 = a3->f32[2];
    float v43 = a3->f32[3];
    float v44 = a3[2].f32[3];
    float v45 = (float)((float)((float)(a3->f32[0] * v37.f32[0]) + (float)(v39 * v40)) + (float)(v42 * v41))
        + (float)(v43 * v44);
    *(float *)(a2 + 40) = v45;
    v37.f32[0] = v37.f32[0] - (float)(v38 * v45);
    float v46 = v40 - (float)(v39 * v45);
    float v47 = v41 - (float)(v42 * v45);
    float v48 = v44 - (float)(v43 * v45);
    float v49 = a3[1].f32[0];
    float v50 = a3[1].f32[1];
    float v51 = a3[1].f32[2];
    float v52 = a3[1].f32[3];
    float v53 = (float)((float)((float)(v37.f32[0] * v49) + (float)(v50 * v46)) + (float)(v51 * v47)) + (float)(v52 * v48);
    *(float *)(a2 + 44) = v53;
    v37.f32[0] = v37.f32[0] - (float)(v49 * v53);
    float32_t v54 = v46 - (float)(v50 * v53);
    float32_t v55 = v47 - (float)(v51 * v53);
    float32_t v56 = v48 - (float)(v52 * v53);
    a3[2].i32[0] = v37.i32[0];
    a3[2].f32[1] = v54;
    a3[2].f32[2] = v55;
    a3[2].f32[3] = v56;
    *(float *)(a2 + 20) = sqrtf((float)(v56 * v56)+ (float)((float)(v55 * v55) + (float)((float)(v37.f32[0] * v37.f32[0]) + (float)(v54 * v54))));
    v37.i32[0] = 1.0;
    float32x4_t v57 = PCVector4<float>::scale(a3 + 2, v37);
    v57.i32[0] = *(_DWORD *)(a2 + 20);
    *(float32x2_t *)(a2 + 40) = vdiv_f32(*(float32x2_t *)(a2 + 40), (float32x2_t)vdup_lane_s32(*(int32x2_t *)v57.f32, 0));
    int32x2_t v58 = *(int32x2_t *)&a3[2].i32[1];
    v59.i32[0] = vdup_lane_s32(v58, 1).u32[0];
    int32x2_t v60 = *(int32x2_t *)&a3[1].i32[1];
    v59.i32[1] = a3[2].i32[0];
    v61.i32[0] = vdup_lane_s32(v60, 1).u32[0];
    v61.i32[1] = a3[1].i32[0];
    if ((float)((float)(vaddv_f32(vmul_f32(vsub_f32(vmul_f32((float32x2_t)v60, v59), vmul_f32((float32x2_t)v58, v61)), *(float32x2_t *)a3->f32))+ (float)((float)((float)(v61.f32[1] * *(float *)v58.i32)- (float)(v59.f32[1] * *(float *)v60.i32))* a3->f32[2]))+ (float)(a3->f32[3] * 0.0)) < 0.0)
    {
      uint64_t v62 = 0;
      *(float32x2_t *)(a2 + 12) = vneg_f32(*(float32x2_t *)(a2 + 12));
      *(float *)(a2 + 20) = -v57.f32[0];
      do
      {
        uint64_t v63 = &a3->f32[v62];
        *uint64_t v63 = -a3->f32[v62];
        v63[4] = -a3[1].f32[v62];
        v63[8] = -a3[2].f32[v62++];
      }
      while (v62 != 3);
    }
  }
  return v5;
}

float PCMatrix44Tmpl<float>::determinant(float *a1)
{
  float v2 = a1[14];
  float v1 = a1[15];
  float v3 = a1[10];
  float v4 = a1[11];
  float v5 = (float)(v3 * v1) - (float)(v2 * v4);
  float v7 = a1[8];
  float v6 = a1[9];
  float v9 = a1[12];
  float v8 = a1[13];
  float v10 = (float)(v1 * v6) - (float)(v4 * v8);
  float v11 = (float)(v2 * v6) - (float)(v3 * v8);
  float v12 = (float)(v1 * v7) - (float)(v4 * v9);
  float v13 = (float)(v2 * v7) - (float)(v3 * v9);
  float v14 = (float)(v8 * v7) - (float)(v6 * v9);
  float v16 = a1[4];
  float v15 = a1[5];
  float v17 = a1[6];
  return (float)((float)((float)((float)(v14 * a1[7]) + (float)((float)(v10 * v16) - (float)(v15 * v12))) * a1[2])
               + (float)((float)((float)((float)((float)(v5 * v15) - (float)(v10 * v17)) + (float)(v11 * a1[7])) * *a1)
                       - (float)(a1[1] * (float)((float)(v13 * a1[7]) + (float)((float)(v5 * v16) - (float)(v17 * v12))))))
       - (float)((float)((float)(v17 * v14) + (float)((float)(v11 * v16) - (float)(v15 * v13))) * a1[3]);
}

float32x4_t PCVector4<float>::scale(float32x4_t *a1, float32x4_t result)
{
  float32x4_t v2 = *a1;
  int32x4_t v3 = (int32x4_t)vmulq_f32(v2, v2);
  float v4 = sqrtf(vadd_f32(vadd_f32(vadd_f32(*(float32x2_t *)v3.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v3.i8, 1)), (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v3, (int8x16_t)v3, 8uLL)), (float32x2_t)vdup_laneq_s32(v3, 3)).f32[0]);
  if (v4 != 0.0)
  {
    __n128 result = vmulq_n_f32(v2, result.f32[0] / v4);
    *a1 = result;
  }
  return result;
}

BOOL PCMatrix44Tmpl<float>::invert(float *a1, float *a2, float a3)
{
  float v3 = a2[14];
  float v4 = a2[15];
  float v6 = a2[10];
  float v5 = a2[11];
  float v7 = (float)(v6 * v4) - (float)(v3 * v5);
  float v8 = a2[8];
  float v9 = a2[9];
  float v11 = a2[12];
  float v10 = a2[13];
  float v12 = (float)(v4 * v9) - (float)(v5 * v10);
  float v13 = (float)(v3 * v9) - (float)(v6 * v10);
  float v14 = (float)(v4 * v8) - (float)(v5 * v11);
  float v15 = (float)(v3 * v8) - (float)(v6 * v11);
  float v16 = (float)(v10 * v8) - (float)(v9 * v11);
  float v18 = a2[4];
  float v17 = a2[5];
  float v19 = a2[6];
  float v20 = a2[7];
  float v21 = (float)((float)(v7 * v17) - (float)(v12 * v19)) + (float)(v13 * v20);
  float v22 = (float)(v15 * v20) + (float)((float)(v7 * v18) - (float)(v19 * v14));
  float v23 = (float)(v16 * v20) + (float)((float)(v12 * v18) - (float)(v17 * v14));
  float v24 = (float)(v19 * v16) + (float)((float)(v13 * v18) - (float)(v17 * v15));
  float v25 = *a2;
  float v26 = a2[1];
  float v27 = a2[2];
  float v28 = a2[3];
  float v29 = (float)(v23 * v27) + (float)((float)(v21 * *a2) - (float)(v26 * v22));
  float v30 = v29 - (float)(v24 * v28);
  BOOL v31 = vabds_f32(v29, v24 * v28) >= a3 && v30 != 0.0;
  if (v31)
  {
    float v32 = (float)(v4 * v19) - (float)(v3 * v20);
    float v33 = (float)(v4 * v17) - (float)(v10 * v20);
    float v34 = (float)(v3 * v17) - (float)(v10 * v19);
    float v35 = (float)(v4 * v18) - (float)(v11 * v20);
    float v36 = (float)(v3 * v18) - (float)(v11 * v19);
    float v37 = (float)(v10 * v18) - (float)(v11 * v17);
    float v38 = (float)(v5 * v19) - (float)(v6 * v20);
    float v39 = (float)(v5 * v17) - (float)(v9 * v20);
    float v40 = (float)(v6 * v17) - (float)(v9 * v19);
    float v41 = (float)(v5 * v18) - (float)(v8 * v20);
    float v42 = (float)(v6 * v18) - (float)(v8 * v19);
    float v43 = 1.0 / v30;
    *a1 = v21 * v43;
    a1[1] = -(float)((float)((float)((float)(v7 * v26) - (float)(v12 * v27)) + (float)(v13 * v28)) * v43);
    a1[2] = (float)((float)((float)(v32 * v26) - (float)(v33 * v27)) + (float)(v34 * v28)) * v43;
    a1[3] = -(float)((float)((float)((float)(v38 * v26) - (float)(v39 * v27)) + (float)(v40 * v28)) * v43);
    a1[4] = -(float)(v22 * v43);
    a1[5] = (float)((float)((float)(v7 * v25) - (float)(v14 * v27)) + (float)(v15 * v28)) * v43;
    a1[6] = -(float)((float)((float)((float)(v25 * v32) - (float)(v35 * v27)) + (float)(v36 * v28)) * v43);
    a1[7] = (float)((float)((float)(v25 * v38) - (float)(v41 * v27)) + (float)(v42 * v28)) * v43;
    a1[8] = v23 * v43;
    a1[9] = -(float)((float)((float)((float)(v12 * v25) - (float)(v14 * v26)) + (float)(v16 * v28)) * v43);
    float v44 = (float)(v9 * v18) - (float)(v8 * v17);
    a1[10] = (float)((float)((float)(v25 * v33) - (float)(v26 * v35)) + (float)(v37 * v28)) * v43;
    a1[11] = -(float)((float)((float)((float)(v25 * v39) - (float)(v26 * v41)) + (float)(v44 * v28)) * v43);
    a1[12] = -(float)((float)((float)(v19 * v16) + (float)((float)(v13 * v18) - (float)(v17 * v15))) * v43);
    a1[13] = (float)((float)((float)(v13 * v25) - (float)(v15 * v26)) + (float)(v16 * v27)) * v43;
    a1[14] = -(float)((float)((float)((float)(v34 * v25) - (float)(v26 * v36)) + (float)(v37 * v27)) * v43);
    a1[15] = (float)((float)((float)(v40 * v25) - (float)(v26 * v42)) + (float)(v44 * v27)) * v43;
  }
  return v31;
}

BOOL ___ZL37EnableStaticPhysicsForCustomSceneNodeP7SCNNode_block_invoke(uint64_t a1, void *a2)
{
  return [a2 geometry] != 0;
}

BOOL ___ZL21FirstNodeWithGeometryP7SCNNode_block_invoke(uint64_t a1, void *a2)
{
  return [a2 geometry] != 0;
}

uint64_t LiGraphBuilder::LiGraphBuilder(uint64_t a1, const PCSharedCount *a2, _OWORD *a3)
{
  *(PCSharedCount *)a1 = (PCSharedCount)a2->var0;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 8), a2 + 1);
  *(void *)(a1 + 16) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 24));
  *(void *)(a1 + 32) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 40));
  *(void *)(a1 + 48) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 56));
  *(void *)(a1 + 64) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 72));
  *(void *)(a1 + 80) = &unk_1F111CA10;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 101) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 112) = &unk_1F10AD5F8;
  *(unsigned char *)(a1 + 136) = 0;
  *(_OWORD *)(a1 + 144) = *a3;
  *(void *)(a1 + 160) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 168));
  *(void *)(a1 + 176) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 184));
  *(void *)(a1 + 192) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 200));
  uint64_t v5 = *(void *)a1;
  if (!*(void *)a1) {
    throw_PCNullPointerException(1);
  }
  int v6 = *(_DWORD *)(a1 + 104);
  *(_DWORD *)(a1 + 104) = v6 + 1;
  *(_DWORD *)(v5 + 528) = v6;
  LiGraphBuilder::startInsertingIntoGroup((LiGraphBuilder *)a1, a1);
  return a1;
}

void sub_1B7A987E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount *a10)
{
  PCSharedCount::~PCSharedCount(v17);
  PCSharedCount::~PCSharedCount(v16);
  PCArray<LiLight,PCArray_Traits<LiLight>>::~PCArray(v15);
  PCArray<LiGraphBuilderGroup,PCArray_Traits<LiGraphBuilderGroup>>::~PCArray(v14);
  PCSharedCount::~PCSharedCount(v13);
  PCSharedCount::~PCSharedCount(v12);
  PCSharedCount::~PCSharedCount(v11);
  PCSharedCount::~PCSharedCount(v10);
  PCSharedCount::~PCSharedCount(a10);
  _Unwind_Resume(a1);
}

PCMutex *LiGraphBuilder::startInsertingIntoGroup(LiGraphBuilder *a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t)a1 + 80;
  float v10 = *(PCMutex **)a2;
  PCSharedCount::PCSharedCount(&v11, (const PCSharedCount *)(a2 + 8));
  char v12 = 0;
  PCArray<LiGraphBuilderGroup,PCArray_Traits<LiGraphBuilderGroup>>::push(v3, (uint64_t)&v10);
  PCSharedCount::~PCSharedCount(&v11);
  __n128 result = (PCMutex *)dbg();
  if (result)
  {
    PCConsoleLock::PCConsoleLock((PCConsoleLock *)&v10, 1);
    uint64_t v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"startInsertingIntoGroup: ", 25);
    LiGraphBuilder::stackRepr(a1, (LiString *)&v9);
    if (v9) {
      int v6 = v9;
    }
    else {
      int v6 = "";
    }
    size_t v7 = strlen(v6);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)v6, v7);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, (uint64_t)"\n", 1);
    if (v9 && atomic_fetch_add((atomic_uint *volatile)v9 - 3, 0xFFFFFFFF) == 1)
    {
      const char *v9 = 0;
      if (v9) {
        float v8 = (char *)(v9 - 12);
      }
      else {
        float v8 = 0;
      }
      free(v8);
    }
    __n128 result = v10;
    if (v10)
    {
      if (LOBYTE(v11.var0)) {
        return (PCMutex *)PCMutex::unlock(v10);
      }
    }
  }
  return result;
}

void sub_1B7A989A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCConsoleLock::~PCConsoleLock((PCMutex **)va);
  _Unwind_Resume(a1);
}

uint64_t PCArray<LiGraphBuilderGroup,PCArray_Traits<LiGraphBuilderGroup>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111CA10;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<LiGraphBuilderGroup,PCArray_Traits<LiGraphBuilderGroup>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

void LiGraphBuilder::LiGraphBuilder(LiGraphBuilder *this, const LiGraphBuilder *a2)
{
  *(void *)this = 0;
  float v4 = (uint64_t *)((char *)this + 8);
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 1);
  *((void *)this + 2) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 3);
  *((void *)this + 4) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 5);
  *((void *)this + 6) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 7);
  *((void *)this + 8) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 9);
  *((void *)this + 10) = &unk_1F111CA10;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *(void *)((char *)this + 101) = 0;
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 14) = &unk_1F10AD5F8;
  *((unsigned char *)this + 136) = 0;
  *((_OWORD *)this + 9) = *((_OWORD *)a2 + 9);
  *((void *)this + 20) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 21);
  *((void *)this + 22) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 23);
  *((void *)this + 24) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 25);
  if (*((void *)a2 + 2)) {
    LiGraphBuilder::createPartition((PCSharedCount *)this);
  }
  uint64_t v5 = *((unsigned int *)a2 + 23);
  uint64_t v15 = *((void *)this + 2);
  PCSharedCount::PCSharedCount(&v16, (const PCSharedCount *)this + 3);
  if ((int)v5 >= 1)
  {
    for (uint64_t i = 0; i != v5; ++i)
    {
      if (i >= *((int *)a2 + 23)) {
        PCArray_base::badIndex(v6);
      }
      (*(void (**)(uint64_t *__return_ptr))(**(void **)(*((void *)a2 + 12) + 24 * i) + 232))(&v13);
      uint64_t v8 = v13;
      if (!v13) {
        throw_PCNullPointerException(1);
      }
      int v9 = *((_DWORD *)this + 26);
      *((_DWORD *)this + 26) = v9 + 1;
      *(_DWORD *)(v8 + 528) = v9;
      v10.int var0 = (PC_Sp_counted_base *)v8;
      PCSharedCount::PCSharedCount(&v11, &v14);
      char v12 = 0;
      PCArray<LiGraphBuilderGroup,PCArray_Traits<LiGraphBuilderGroup>>::push((uint64_t)this + 80, (uint64_t)&v10);
      PCSharedCount::~PCSharedCount(&v11);
      if (!*(void *)this)
      {
        *(void *)this = v13;
        PCSharedCount::PCSharedCount(&v10, &v14);
        PCSharedCount::operator=(v4, (uint64_t *)&v10);
        PCSharedCount::~PCSharedCount(&v10);
      }
      if (v15) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v15 + 152))(v15, v13);
      }
      uint64_t v15 = v13;
      PCSharedCount::PCSharedCount(&v10, &v14);
      PCSharedCount::operator=((uint64_t *)&v16, (uint64_t *)&v10);
      PCSharedCount::~PCSharedCount(&v10);
      PCSharedCount::~PCSharedCount(&v14);
    }
  }
  PCSharedCount::~PCSharedCount(&v16);
}

void sub_1B7A98D48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, PCSharedCount *a15, PCSharedCount *a16, PCSharedCount *a17, char a18)
{
  PCSharedCount::~PCSharedCount(a16);
  PCSharedCount::~PCSharedCount(a17);
  PCSharedCount::~PCSharedCount(a15);
  PCArray<LiLight,PCArray_Traits<LiLight>>::~PCArray(a14);
  PCArray<LiGraphBuilderGroup,PCArray_Traits<LiGraphBuilderGroup>>::~PCArray(v21);
  PCSharedCount::~PCSharedCount(v23);
  PCSharedCount::~PCSharedCount(v22);
  PCSharedCount::~PCSharedCount(v20);
  PCSharedCount::~PCSharedCount(v19);
  PCSharedCount::~PCSharedCount(v18);
  _Unwind_Resume(a1);
}

PC_Sp_counted_base *LiGraphBuilder::createPartition(PCSharedCount *this)
{
  __n128 result = this[2].var0;
  if (!result)
  {
    PCSharedCount::PCSharedCount(&v3, this + 1);
    operator new();
  }
  return result;
}

void sub_1B7A98FA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCSharedCount a12)
{
  PCSharedCount::~PCSharedCount(&a12);
  PCSharedCount::~PCSharedCount(v12);
  _Unwind_Resume(a1);
}

uint64_t PCArray<LiGraphBuilderGroup,PCArray_Traits<LiGraphBuilderGroup>>::push(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 12);
  if (*(_DWORD *)(a1 + 8) <= v4) {
    int v5 = (2 * (v4 + 1)) | 1;
  }
  else {
    int v5 = *(_DWORD *)(a1 + 8);
  }
  PCArray<LiGraphBuilderGroup,PCArray_Traits<LiGraphBuilderGroup>>::resize(a1, v4 + 1, v5);
  LiGraphBuilderGroup::operator=(*(void *)(a1 + 16) + 24 * *(int *)(a1 + 12) - 24, a2);
  return *(void *)(a1 + 16) + 24 * *(int *)(a1 + 12) - 24;
}

void LiGraphBuilder::~LiGraphBuilder(PCSharedCount *this)
{
  PCSharedCount::~PCSharedCount(this + 25);
  PCSharedCount::~PCSharedCount(this + 23);
  PCSharedCount::~PCSharedCount(this + 21);
  PCArray<LiLight,PCArray_Traits<LiLight>>::~PCArray((uint64_t)&this[14]);
  this[10].int var0 = (PC_Sp_counted_base *)&unk_1F111CA10;
  if (SLODWORD(this[11].var0) < 0) {
    int var0 = 1;
  }
  else {
    int var0 = (int)this[11].var0;
  }
  PCArray<LiGraphBuilderGroup,PCArray_Traits<LiGraphBuilderGroup>>::resize((uint64_t)&this[10], 0, var0);
  PCSharedCount v3 = this[12].var0;
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  this[12].int var0 = 0;
  LODWORD(this[11].var0) = 0;
  PCSharedCount::~PCSharedCount(this + 9);
  PCSharedCount::~PCSharedCount(this + 7);
  PCSharedCount::~PCSharedCount(this + 5);
  PCSharedCount::~PCSharedCount(this + 3);
  PCSharedCount::~PCSharedCount(this + 1);
}

void LiGraphBuilder::setLights(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 112;
  int v5 = *(_DWORD *)(a2 + 12);
  if (*(_DWORD *)(a1 + 120) >= v5) {
    int v6 = *(_DWORD *)(a1 + 120);
  }
  else {
    int v6 = (2 * v5) | 1;
  }
  PCArray<LiLight,PCArray_Traits<LiLight>>::resize(v4, v5, v6);
  if (*(int *)(a2 + 12) >= 1)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    do
    {
      LiLight::operator=(*(void *)(a1 + 128) + v7, *(void *)(a2 + 16) + v7);
      ++v8;
      v7 += 944;
    }
    while (v8 < *(int *)(a2 + 12));
  }
  *(unsigned char *)(a1 + 136) = *(unsigned char *)(a2 + 24);
}

PCMutex *LiGraphBuilder::add2d(PCSharedCount *a1, void *a2)
{
  LiGraphBuilder::prepare2d(a1);
  LiGraphBuilder::addChild((LiGraphBuilder *)a1, a2);
  __n128 result = (PCMutex *)dbg();
  if (result)
  {
    PCConsoleLock::PCConsoleLock((PCConsoleLock *)&v12, 1);
    int v5 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"add2d: ", 7);
    size_t v6 = strlen((const char *)(0x80000001B837BF08 & 0x7FFFFFFFFFFFFFFFLL));
    uint64_t v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v5, 0x80000001B837BF08 & 0x7FFFFFFFFFFFFFFFLL, v6);
    if (!*a2) {
      throw_PCNullPointerException(1);
    }
    uint64_t v8 = *(_DWORD **)(*a2 + 512);
    if (v8) {
      int v9 = *(v8 - 2);
    }
    else {
      int v9 = 0;
    }
    PCSharedCount v10 = (char *)malloc_type_malloc(v9 + 15, 0x8903763CuLL);
    *((_DWORD *)v10 + 1) = v9 + 2;
    *((_DWORD *)v10 + 2) = v9 + 3;
    atomic_store(1u, (unsigned int *)v10);
    atomic_store(0, (unsigned int *)v10);
    *((_WORD *)v10 + 6) = 8736;
    memcpy(v10 + 14, v8, v9);
    v10[v9 + 14] = 0;
    atomic_fetch_add((atomic_uint *volatile)v10, 1u);
    size_t v11 = strlen(v10 + 12);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)(v10 + 12), v11);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)"\"\n", 2);
    if (atomic_fetch_add((atomic_uint *volatile)v10, 0xFFFFFFFF) == 1) {
      free(v10);
    }
    __n128 result = v12;
    if (v12)
    {
      if (v13) {
        return (PCMutex *)PCMutex::unlock(v12);
      }
    }
  }
  return result;
}

void sub_1B7A99344(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, PCMutex *a9)
{
}

PCSharedCount *LiGraphBuilder::prepare2d(PCSharedCount *this)
{
  int var0 = this[4].var0;
  int v2 = this + 4;
  if (var0)
  {
    PCPtr<LiImageSource>::reset(v2);
    PCPtr<LiImageSource>::reset(&this[8].var0);
    BYTE4(this[13].var0) = 1;
  }
  __n128 result = this + 20;
  if (this[20].var0)
  {
    PCPtr<LiImageSource>::reset(result);
    PCPtr<LiImageSource>::reset(&this[24].var0);
    BYTE4(this[13].var0) = 1;
  }
  else if (!BYTE4(this[13].var0))
  {
    return result;
  }

  return (PCSharedCount *)LiGraphBuilder::makeNewPartition(this, 1);
}

void LiGraphBuilder::addChild(LiGraphBuilder *this, void *a2)
{
  if (!*a2) {
    throw_PCNullPointerException(1);
  }
  int v3 = *((_DWORD *)this + 26);
  *(_DWORD *)(*a2 + 528) = v3;
  *((_DWORD *)this + 26) = v3 + 1;
  LiGraphBuilder::getCurrentInsertionGroup(this, &v4);
  if (!v4.var0) {
    throw_PCNullPointerException(1);
  }
  (*(void (**)(PC_Sp_counted_base *, void))(*(void *)v4.var0 + 152))(v4.var0, *a2);
  PCSharedCount::~PCSharedCount(&v5);
}

void sub_1B7A994AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCSharedCount::~PCSharedCount((PCSharedCount *)va);
  _Unwind_Resume(a1);
}

uint64_t dbg(void)
{
  {
    dbg(void)::__n128 result = liDebug("LiGraphBuilder");
  }
  return dbg(void)::result;
}

void sub_1B7A99528(_Unwind_Exception *a1)
{
}

void PCConsoleLock::~PCConsoleLock(PCMutex **this)
{
  int v2 = *this;
  if (v2)
  {
    if (*((unsigned char *)this + 8))
    {
      PCMutex::unlock(v2);
      *((unsigned char *)this + 8) = 0;
    }
  }
}

PCMutex *LiGraphBuilder::add3d(LiGraphBuilder *a1, void *a2, uint64_t a3)
{
  PCSharedCount v14 = 0;
  PCSharedCount::PCSharedCount(&v15);
  LiGraphBuilder::prepare3d((uint64_t)a1, a3, &v14);
  PCSharedCount::~PCSharedCount(&v15);
  LiGraphBuilder::addChild(a1, a2);
  __n128 result = (PCMutex *)dbg();
  if (result)
  {
    PCConsoleLock::PCConsoleLock((PCConsoleLock *)&v14, 1);
    uint64_t v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"add3d: ", 7);
    size_t v8 = strlen((const char *)(0x80000001B837BF08 & 0x7FFFFFFFFFFFFFFFLL));
    int v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, 0x80000001B837BF08 & 0x7FFFFFFFFFFFFFFFLL, v8);
    if (!*a2) {
      throw_PCNullPointerException(1);
    }
    PCSharedCount v10 = *(_DWORD **)(*a2 + 512);
    if (v10) {
      int v11 = *(v10 - 2);
    }
    else {
      int v11 = 0;
    }
    char v12 = (char *)malloc_type_malloc(v11 + 15, 0x8903763CuLL);
    *((_DWORD *)v12 + 1) = v11 + 2;
    *((_DWORD *)v12 + 2) = v11 + 3;
    atomic_store(1u, (unsigned int *)v12);
    atomic_store(0, (unsigned int *)v12);
    *((_WORD *)v12 + 6) = 8736;
    memcpy(v12 + 14, v10, v11);
    v12[v11 + 14] = 0;
    atomic_fetch_add((atomic_uint *volatile)v12, 1u);
    size_t v13 = strlen(v12 + 12);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)(v12 + 12), v13);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"\"\n", 2);
    if (atomic_fetch_add((atomic_uint *volatile)v12, 0xFFFFFFFF) == 1) {
      free(v12);
    }
    __n128 result = v14;
    if (v14)
    {
      if (LOBYTE(v15.var0)) {
        return (PCMutex *)PCMutex::unlock(v14);
      }
    }
  }
  return result;
}

void sub_1B7A99744(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, PCMutex *a9)
{
}

uint64_t LiGraphBuilder::prepare3d(uint64_t result, uint64_t a2, void *a3)
{
  uint64_t v4 = result;
  if (!*(void *)(result + 32) || *(unsigned char *)(result + 108))
  {
    int v5 = dbg();
    PCConsoleLock::PCConsoleLock((PCConsoleLock *)&v12, v5);
    uint64_t v10 = 0;
    PCSharedCount::PCSharedCount(&v11);
    if (*a3)
    {
      uint64_t v7 = *(unsigned int *)(v4 + 92);
      if (v7)
      {
        uint64_t v8 = 0;
        while (1)
        {
          if (v8 >= *(int *)(v4 + 92)) {
            PCArray_base::badIndex(v6);
          }
          uint64_t v9 = *(void *)(v4 + 96);
          size_t v6 = *(PCArray_base **)(v9 + 24 * v8);
          if (v6)
          {
            if (v6) {
              break;
            }
          }
          if (++v8 == v7) {
            goto LABEL_15;
          }
        }
        if (*(_DWORD *)(v4 + 92) <= (int)v8) {
          PCArray_base::badIndex(v6);
        }
        PCPtr<Li3DGroupForEquirect>::operator=<LiGroup>(&v10, (const void **)(v9 + 24 * v8));
      }
    }
LABEL_15:
    LiGraphBuilder::makeNewPartition((PCSharedCount *)v4, 0);
    operator new();
  }
  return result;
}

void sub_1B7A9A27C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount *a10, PCSharedCount *a11, PCSharedCount *a12, PCSharedCount *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  PCSharedCount::~PCSharedCount((PCSharedCount *)(v37 - 160));
  PCSharedCount::~PCSharedCount(v36);
  PCSharedCount::~PCSharedCount(v35);
  PCSharedCount::~PCSharedCount(v34);
  PCConsoleLock::~PCConsoleLock((PCMutex **)(v37 - 104));
  _Unwind_Resume(a1);
}

PCMutex *LiGraphBuilder::add3DEngine(LiGraphBuilder *a1, void *a2, uint64_t a3)
{
  PCSharedCount v14 = 0;
  PCSharedCount::PCSharedCount(&v15);
  LiGraphBuilder::prepare3DEngine((uint64_t)a1, a3, &v14);
  PCSharedCount::~PCSharedCount(&v15);
  LiGraphBuilder::addChild(a1, a2);
  __n128 result = (PCMutex *)dbg();
  if (result)
  {
    PCConsoleLock::PCConsoleLock((PCConsoleLock *)&v14, 1);
    uint64_t v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"add3DEngine: ", 13);
    size_t v8 = strlen((const char *)(0x80000001B837BF08 & 0x7FFFFFFFFFFFFFFFLL));
    uint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, 0x80000001B837BF08 & 0x7FFFFFFFFFFFFFFFLL, v8);
    if (!*a2) {
      throw_PCNullPointerException(1);
    }
    uint64_t v10 = *(_DWORD **)(*a2 + 512);
    if (v10) {
      int v11 = *(v10 - 2);
    }
    else {
      int v11 = 0;
    }
    uint64_t v12 = (char *)malloc_type_malloc(v11 + 15, 0x8903763CuLL);
    *((_DWORD *)v12 + 1) = v11 + 2;
    *((_DWORD *)v12 + 2) = v11 + 3;
    atomic_store(1u, (unsigned int *)v12);
    atomic_store(0, (unsigned int *)v12);
    *((_WORD *)v12 + 6) = 8736;
    memcpy(v12 + 14, v10, v11);
    v12[v11 + 14] = 0;
    atomic_fetch_add((atomic_uint *volatile)v12, 1u);
    size_t v13 = strlen(v12 + 12);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)(v12 + 12), v13);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"\"\n", 2);
    if (atomic_fetch_add((atomic_uint *volatile)v12, 0xFFFFFFFF) == 1) {
      free(v12);
    }
    __n128 result = v14;
    if (v14)
    {
      if (LOBYTE(v15.var0)) {
        return (PCMutex *)PCMutex::unlock(v14);
      }
    }
  }
  return result;
}

void sub_1B7A9A690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, PCMutex *a9)
{
}

uint64_t LiGraphBuilder::prepare3DEngine(uint64_t result, uint64_t a2, void *a3)
{
  uint64_t v3 = result;
  if (!*(void *)(result + 160) || *(unsigned char *)(result + 108))
  {
    int v4 = dbg();
    PCConsoleLock::PCConsoleLock((PCConsoleLock *)&v12, v4);
    uint64_t v10 = 0;
    PCSharedCount::PCSharedCount(&v11);
    if (*a3)
    {
      uint64_t v6 = *(unsigned int *)(v3 + 92);
      if (v6)
      {
        uint64_t v7 = 0;
        while (1)
        {
          if (v7 >= *(int *)(v3 + 92)) {
            PCArray_base::badIndex(v5);
          }
          uint64_t v8 = *(void *)(v3 + 96);
          int v5 = *(PCArray_base **)(v8 + 24 * v7);
          if (v5)
          {
            if (v5) {
              break;
            }
          }
          if (++v7 == v6) {
            goto LABEL_15;
          }
        }
        if (*(_DWORD *)(v3 + 92) <= (int)v7) {
          PCArray_base::badIndex(v5);
        }
        PCPtr<Li3DGroupForEquirect>::operator=<LiGroup>(&v10, (const void **)(v8 + 24 * v7));
      }
    }
LABEL_15:
    LiGraphBuilder::makeNewPartition((PCSharedCount *)v3, 0);
    operator new();
  }
  return result;
}

void sub_1B7A9B15C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, PCSharedCount *a9, PCSharedCount *a10, PCSharedCount *a11, PCSharedCount *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  PCSharedCount::~PCSharedCount((PCSharedCount *)(v35 - 160));
  PCSharedCount::~PCSharedCount(v34);
  PCSharedCount::~PCSharedCount(v33);
  PCSharedCount::~PCSharedCount(v32);
  PCConsoleLock::~PCConsoleLock((PCMutex **)(v35 - 104));
  _Unwind_Resume(a1);
}

void LiGraphBuilder::addGroup(PCSharedCount *this, const PCSharedCount *a2)
{
  if (BYTE4(this[13].var0)) {
    LiGraphBuilder::makeNewPartition(this, 1);
  }
  PCPtr<LiImageSource>::PCPtr<OZGradientSource>(&v4, a2);
  LiGraphBuilder::addChild((LiGraphBuilder *)this, &v4);
  PCSharedCount::~PCSharedCount(&v5);
}

void sub_1B7A9B414(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1 + 1);
  _Unwind_Resume(a1);
}

uint64_t LiGraphBuilder::makeNewPartition(PCSharedCount *this, int a2)
{
  int var0 = this[4].var0;
  PCSharedCount v4 = this + 4;
  BYTE4(v4[9].var0) = 0;
  if (var0)
  {
    PCPtr<LiImageSource>::reset(v4);
    PCPtr<LiImageSource>::reset(&this[8].var0);
  }
  if (this[20].var0)
  {
    PCPtr<LiImageSource>::reset(&this[20].var0);
    PCPtr<LiImageSource>::reset(&this[24].var0);
  }
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  uint64_t v37 = &unk_1F111CA10;
  uint64_t var0_high = HIDWORD(this[11].var0);
  uint64_t v35 = 0;
  PCSharedCount::PCSharedCount(&v36);
  int v29 = a2;
  if (a2)
  {
    Partition = LiGraphBuilder::createPartition(this);
    uint64_t v7 = PCPtr<LiImageSource>::operator=<LiImageSource>(&v35, (PCShared_base *)Partition);
  }
  if ((int)var0_high >= 1)
  {
    uint64_t v9 = 0;
    char v10 = 1;
    uint64_t v11 = 16;
    do
    {
      if (v9 >= SHIDWORD(this[11].var0)) {
        PCArray_base::badIndex((PCArray_base *)v7);
      }
      uint64_t v12 = (char *)this[12].var0 + v11;
      if (!*v12)
      {
        uint64_t v13 = *((void *)v12 - 2);
        if (!v13) {
          throw_PCNullPointerException(1);
        }
        (*(void (**)(void **__return_ptr))(*(void *)v13 + 232))(&lpsrc);
        PCSharedCount v14 = (PCShared_base *)lpsrc;
        if (!lpsrc) {
          throw_PCNullPointerException(1);
        }
        int v15 = (int)this[13].var0;
        LODWORD(this[13].var0) = v15 + 1;
        *((_DWORD *)v14 + 132) = v15;
        if (v35)
        {
          (*(void (**)(PCShared_base *, PCShared_base *))(*(void *)v35 + 152))(v35, v14);
          PCSharedCount v14 = (PCShared_base *)lpsrc;
        }
        uint64_t v35 = v14;
        PCSharedCount::PCSharedCount(&v30, &v34);
        PCSharedCount::operator=((uint64_t *)&v36, (uint64_t *)&v30);
        PCSharedCount::~PCSharedCount(&v30);
        v30.int var0 = (PC_Sp_counted_base *)lpsrc;
        PCSharedCount::PCSharedCount(&v31, &v34);
        char v32 = 0;
        PCArray<LiGraphBuilderGroup,PCArray_Traits<LiGraphBuilderGroup>>::push((uint64_t)&v37, (uint64_t)&v30);
        PCSharedCount::~PCSharedCount(&v31);
        PCSharedCount::~PCSharedCount(&v34);
      }
      ++v9;
      v11 += 24;
    }
    while (var0_high != v9);
  }
  if (SLODWORD(this[11].var0) >= SHIDWORD(v38)) {
    int v16 = (int)this[11].var0;
  }
  else {
    int v16 = (2 * HIDWORD(v38)) | 1;
  }
  PCArray<LiGraphBuilderGroup,PCArray_Traits<LiGraphBuilderGroup>>::resize((uint64_t)&this[10], SHIDWORD(v38), v16);
  if (SHIDWORD(v38) >= 1)
  {
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    do
    {
      LiGraphBuilderGroup::operator=((uint64_t)this[12].var0 + v17, v39 + v17);
      ++v18;
      v17 += 24;
    }
    while (v18 < SHIDWORD(v38));
  }
  if (dbg())
  {
    PCConsoleLock::PCConsoleLock((PCConsoleLock *)&v30, 1);
    float v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"makeNewPartition(", 17);
    if (v29) {
      float v20 = "true";
    }
    else {
      float v20 = "false";
    }
    if (v29) {
      uint64_t v21 = 4;
    }
    else {
      uint64_t v21 = 5;
    }
    float v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)v20, v21);
    float v23 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)"): ", 3);
    LiGraphBuilder::stackRepr((LiGraphBuilder *)this, (LiString *)&lpsrc);
    if (lpsrc) {
      float v24 = (const char *)lpsrc;
    }
    else {
      float v24 = "";
    }
    size_t v25 = strlen(v24);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)v24, v25);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)"\n", 1);
    if (lpsrc && atomic_fetch_add((atomic_uint *volatile)lpsrc - 3, 0xFFFFFFFF) == 1)
    {
      *(unsigned char *)lpsrc = 0;
      if (lpsrc) {
        float v26 = (char *)lpsrc - 12;
      }
      else {
        float v26 = 0;
      }
      free(v26);
    }
    if (v30.var0 && LOBYTE(v31.var0)) {
      PCMutex::unlock((PCMutex *)v30.var0);
    }
  }
  PCSharedCount::~PCSharedCount(&v36);
  uint64_t v37 = &unk_1F111CA10;
  if ((int)v38 < 0) {
    int v27 = 1;
  }
  else {
    int v27 = v38;
  }
  PCArray<LiGraphBuilderGroup,PCArray_Traits<LiGraphBuilderGroup>>::resize((uint64_t)&v37, 0, v27);
  uint64_t result = v39;
  if (v39) {
    return MEMORY[0x1BA9BFB70](v39, 0x1000C8077774924);
  }
  return result;
}

void sub_1B7A9B840(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  PCSharedCount v5 = va_arg(va1, PCMutex *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  PCConsoleLock::~PCConsoleLock((PCMutex **)va);
  PCSharedCount::~PCSharedCount(v3);
  PCArray<LiGraphBuilderGroup,PCArray_Traits<LiGraphBuilderGroup>>::~PCArray((uint64_t)va1);
  _Unwind_Resume(a1);
}

void LiGraphBuilder::getCurrentInsertionGroup(LiGraphBuilder *this@<X0>, PCSharedCount *a2@<X8>)
{
  int v2 = *((_DWORD *)this + 23);
  if (v2 <= 0) {
    PCArray_base::badIndex(this);
  }
  uint64_t v3 = (const PCSharedCount *)(*((void *)this + 12) + 24 * (v2 - 1));
  int var0 = v3->var0;
  PCSharedCount v4 = v3 + 1;
  a2->int var0 = var0;

  PCSharedCount::PCSharedCount(a2 + 1, v4);
}

void LiGraphBuilder::stackRepr(LiGraphBuilder *this@<X0>, LiString *a2@<X8>)
{
  *(void *)a2 = 0;
  LiString::LiString((LiString *)&v57, "None");
  uint64_t v5 = *((void *)this + 2);
  if (v5)
  {
    for (uint64_t i = 7; i != -1; --i)
    {
      if (v5 >> i <= 0) {
        uint64_t v7 = -(-(v5 >> i) & 0xF);
      }
      else {
        uint64_t v7 = (v5 >> i) & 0xF;
      }
      __src[0] = a0123456789abcd[v7];
      LiString::append(a2, __src, 1);
    }
    LiString::append(a2, " \"", 2);
    uint64_t v8 = *((void *)this + 2);
    if (!v8) {
      throw_PCNullPointerException(1);
    }
    uint64_t v9 = *(const char **)(v8 + 512);
    if (v9) {
      signed int v10 = *((_DWORD *)v9 - 2);
    }
    else {
      signed int v10 = 0;
    }
    LiString::append(a2, v9, v10);
    LiString::append(a2, "\"", 1);
    uint64_t v11 = *((void *)this + 2);
    if (!v11) {
      throw_PCNullPointerException(1);
    }
    uint64_t v12 = (LiString *)(*(uint64_t (**)(uint64_t))(*(void *)v11 + 136))(v11);
    LiString::format(v12, (LiString *)__src);
    uint64_t v13 = *(const void **)__src;
    if (*(void *)__src) {
      int v14 = *(_DWORD *)(*(void *)__src - 8);
    }
    else {
      int v14 = 0;
    }
    int v15 = (unsigned int *)malloc_type_malloc(v14 + 15, 0x8903763CuLL);
    uint64_t v16 = v14 + 2;
    v15[2] = v14 + 3;
    atomic_store(1u, v15);
    atomic_store(0, v15);
    *((_WORD *)v15 + 6) = 10272;
    v15[1] = v16;
    memcpy((char *)v15 + 14, v13, v14);
    *((unsigned char *)v15 + v16 + 12) = 0;
    atomic_fetch_add((atomic_uint *volatile)v15, 1u);
    size_t v17 = (int)v15[1];
    uint64_t v18 = (unsigned int *)malloc_type_malloc(v17 + 14, 0x8903763CuLL);
    atomic_store(1u, v18);
    float v19 = v18 + 3;
    atomic_store(0, v18);
    v18[1] = v17 + 1;
    v18[2] = v17 + 2;
    memcpy(v18 + 3, v15 + 3, v17);
    *((unsigned char *)v19 + v17) = 41;
    *((unsigned char *)v19 + v17 + 1) = 0;
    atomic_fetch_add((atomic_uint *volatile)v18, 1u);
    LiString::append(a2, (const char *)v18 + 12, v18[1]);
    if (atomic_fetch_add((atomic_uint *volatile)v18, 0xFFFFFFFF) == 1) {
      free(v18);
    }
    if (atomic_fetch_add((atomic_uint *volatile)v15, 0xFFFFFFFF) == 1) {
      free(v15);
    }
    if (*(void *)__src && atomic_fetch_add((atomic_uint *volatile)(*(void *)__src - 12), 0xFFFFFFFF) == 1)
    {
      **(unsigned char **)__src = 0;
      if (*(void *)__src) {
        float v20 = (void *)(*(void *)__src - 12);
      }
      else {
        float v20 = 0;
      }
      free(v20);
    }
    if (&v57 != (atomic_uint **)a2)
    {
      if (v57 && atomic_fetch_add(v57 - 3, 0xFFFFFFFF) == 1)
      {
        *(unsigned char *)float32x4_t v57 = 0;
        if (v57) {
          uint64_t v21 = v57 - 3;
        }
        else {
          uint64_t v21 = 0;
        }
        free(v21);
      }
      float v22 = *(atomic_uint **)a2;
      float32x4_t v57 = v22;
      if (v22) {
        atomic_fetch_add(v22 - 3, 1u);
      }
    }
    PCSharedCount v4 = LiString::operator=((unsigned int **)a2, (unsigned int *)"");
  }
  int v51 = *((_DWORD *)this + 23);
  if (v51)
  {
    int v23 = 0;
    int v24 = 0;
    do
    {
      if (v23 < 0 || *((_DWORD *)this + 23) <= v23) {
        PCArray_base::badIndex(v4);
      }
      uint64_t v25 = *((void *)this + 12);
      float v26 = (const PCSharedCount *)(v25 + 24 * v24);
      *(PCSharedCount *)__src = (PCSharedCount)v26->var0;
      PCSharedCount::PCSharedCount(&v55, v26 + 1);
      char v56 = *(unsigned char *)(v25 + 24 * v24 + 16);
      if (*(void *)a2 && *(_DWORD *)(*(void *)a2 - 8)) {
        LiString::append(a2, ", ", 2);
      }
      uint64_t v27 = *(void *)__src;
      for (uint64_t j = 7; j != -1; --j)
      {
        if (v27 >> j <= 0) {
          uint64_t v29 = -(-(v27 >> j) & 0xF);
        }
        else {
          uint64_t v29 = (v27 >> j) & 0xF;
        }
        v53[0] = a0123456789abcd[v29];
        LiString::append(a2, v53, 1);
      }
      LiString::append(a2, " \"", 2);
      PCSharedCount v30 = *(const char **)(*(void *)__src + 512);
      if (v30) {
        signed int v31 = *((_DWORD *)v30 - 2);
      }
      else {
        signed int v31 = 0;
      }
      LiString::append(a2, v30, v31);
      LiString::append(a2, "\"", 1);
      if (v56) {
        LiString::append(a2, " synth", 6);
      }
      char v32 = (LiString *)(*(uint64_t (**)(void))(**(void **)__src + 136))(*(void *)__src);
      LiString::format(v32, (LiString *)v53);
      float v33 = *(const void **)v53;
      if (*(void *)v53) {
        int v34 = *(_DWORD *)(*(void *)v53 - 8);
      }
      else {
        int v34 = 0;
      }
      int v52 = v24;
      uint64_t v35 = (unsigned int *)malloc_type_malloc(v34 + 15, 0x8903763CuLL);
      uint64_t v36 = v34 + 2;
      v35[2] = v34 + 3;
      atomic_store(1u, v35);
      atomic_store(0, v35);
      *((_WORD *)v35 + 6) = 10272;
      v35[1] = v36;
      memcpy((char *)v35 + 14, v33, v34);
      *((unsigned char *)v35 + v36 + 12) = 0;
      atomic_fetch_add((atomic_uint *volatile)v35, 1u);
      size_t v37 = (int)v35[1];
      uint64_t v38 = (unsigned int *)malloc_type_malloc(v37 + 14, 0x8903763CuLL);
      atomic_store(1u, v38);
      uint64_t v39 = v38 + 3;
      atomic_store(0, v38);
      v38[1] = v37 + 1;
      v38[2] = v37 + 2;
      memcpy(v38 + 3, v35 + 3, v37);
      *((unsigned char *)v39 + v37) = 41;
      *((unsigned char *)v39 + v37 + 1) = 0;
      atomic_fetch_add((atomic_uint *volatile)v38, 1u);
      LiString::append(a2, (const char *)v38 + 12, v38[1]);
      if (atomic_fetch_add((atomic_uint *volatile)v38, 0xFFFFFFFF) == 1) {
        free(v38);
      }
      if (atomic_fetch_add((atomic_uint *volatile)v35, 0xFFFFFFFF) == 1) {
        free(v35);
      }
      if (*(void *)v53 && atomic_fetch_add((atomic_uint *volatile)(*(void *)v53 - 12), 0xFFFFFFFF) == 1)
      {
        **(unsigned char **)float v53 = 0;
        if (*(void *)v53) {
          float v40 = (void *)(*(void *)v53 - 12);
        }
        else {
          float v40 = 0;
        }
        free(v40);
      }
      PCSharedCount::~PCSharedCount(&v55);
      int v23 = ++v24;
    }
    while (v51 != v52 + 1);
  }
  float v41 = v57;
  if (v57)
  {
    size_t v42 = *(v57 - 2);
    if (!v42) {
      goto LABEL_79;
    }
    float v43 = (unsigned int *)malloc_type_malloc(v42 + 16, 0x8903763CuLL);
    v43[1] = v42 + 3;
    void v43[2] = v42 + 4;
    atomic_store(1u, v43);
    atomic_store(0, v43);
    memcpy(v43 + 3, v41, v42);
    float v44 = (char *)v43 + v42 + 12;
    *(_WORD *)float v44 = 12064;
    v44[2] = 32;
    *((unsigned char *)v43 + v42 + 15) = 0;
    atomic_fetch_add((atomic_uint *volatile)v43, 1u);
    size_t v45 = (int)v43[1];
    float v46 = *(atomic_uint **)a2;
    if (*(void *)a2) {
      int v47 = *(v46 - 2);
    }
    else {
      int v47 = 0;
    }
    size_t v48 = v45 + v47;
    float v49 = (unsigned int *)malloc_type_malloc(v48 + 13, 0x8903763CuLL);
    v49[1] = v48;
    v49[2] = v48 + 1;
    atomic_store(1u, v49);
    atomic_store(0, v49);
    memcpy(v49 + 3, v43 + 3, v45);
    memcpy((char *)v49 + v45 + 12, v46, v47);
    *((unsigned char *)v49 + v48 + 12) = 0;
    atomic_fetch_add((atomic_uint *volatile)v49, 1u);
    LiString::dec(a2);
    *(void *)a2 = v49 + 3;
    atomic_fetch_add((atomic_uint *volatile)v49, 1u);
    if (atomic_fetch_add((atomic_uint *volatile)v49, 0xFFFFFFFF) == 1) {
      free(v49);
    }
    if (atomic_fetch_add((atomic_uint *volatile)v43, 0xFFFFFFFF) == 1) {
      free(v43);
    }
    float v41 = v57;
    if (v57)
    {
LABEL_79:
      if (atomic_fetch_add(v41 - 3, 0xFFFFFFFF) == 1)
      {
        *(unsigned char *)float32x4_t v57 = 0;
        if (v57) {
          float v50 = v57 - 3;
        }
        else {
          float v50 = 0;
        }
        free(v50);
      }
    }
  }
}

void sub_1B7A9C050(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, PCSharedCount *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, atomic_uint *a16)
{
  if (atomic_fetch_add((atomic_uint *volatile)v18, 0xFFFFFFFF) == 1) {
    free(v18);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v17, 0xFFFFFFFF) == 1) {
    free(v17);
  }
  if (a16)
  {
    if (atomic_fetch_add(a16 - 3, 0xFFFFFFFF) == 1)
    {
      *(unsigned char *)a16 = 0;
      free(a16 - 3);
    }
  }
  LiString::dec(v16);
  _Unwind_Resume(a1);
}

LiString *LiString::operator=(unsigned int **this, unsigned int *__src)
{
  uint64_t v3 = *this;
  if (*this) {
    BOOL v4 = v3 == __src;
  }
  else {
    BOOL v4 = 0;
  }
  if (!v4)
  {
    if (__src && *(unsigned char *)__src)
    {
      uint64_t v6 = 0;
      while (*((unsigned __int8 *)__src + ++v6))
        ;
      if (!v3) {
        goto LABEL_19;
      }
      unsigned int v8 = atomic_load(v3 - 3);
      if (v8 != 1) {
        goto LABEL_19;
      }
      uint64_t v9 = *this;
      uint64_t v10 = (uint64_t)(*this - 3);
      if (!*this) {
        uint64_t v10 = 0;
      }
      if ((int)v6 < *(_DWORD *)(v10 + 8))
      {
        memcpy(v9, __src, v6 + 1);
        *((unsigned char *)*this + v6) = 0;
        if (*this) {
          uint64_t v11 = (uint64_t)(*this - 3);
        }
        else {
          uint64_t v11 = 0;
        }
        *(_DWORD *)(v11 + 4) = v6;
      }
      else
      {
LABEL_19:
        LiString::dec((LiString *)this);
        uint64_t v12 = (unsigned int *)malloc_type_malloc(v6 + 13, 0x8903763CuLL);
        float64x2_t v12[2] = v6 + 1;
        atomic_store(1u, v12);
        *this = v12 + 3;
        v12[1] = v6;
        memcpy(v12 + 3, __src, v6 + 1);
      }
    }
    else
    {
      LiString::dec((LiString *)this);
      *this = 0;
    }
  }
  return (LiString *)this;
}

PCMutex *LiGraphBuilder::endInsertingIntoGroup(LiGraphBuilder *this)
{
  int v2 = dbg();
  PCConsoleLock::PCConsoleLock((PCConsoleLock *)&v28, v2);
  uint64_t v3 = (const char **)((char *)this + 176);
  while (*((_DWORD *)this + 23))
  {
    PCArray<LiGraphBuilderGroup,PCArray_Traits<LiGraphBuilderGroup>>::pop((uint64_t)this + 80, (uint64_t)&v25);
    BOOL v4 = v25;
    uint64_t v5 = (const char *)*((void *)this + 6);
    if (v25)
    {
      if (!v5 || v25 != v5)
      {
        uint64_t v6 = *v3;
        goto LABEL_15;
      }
    }
    else if (v5)
    {
      uint64_t v6 = *v3;
LABEL_18:
      if (!v6) {
        goto LABEL_19;
      }
      goto LABEL_25;
    }
    if (dbg())
    {
      uint64_t v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"  leaving _3dgroup ", 19);
      size_t v8 = strlen((const char *)(0x80000001B837BF19 & 0x7FFFFFFFFFFFFFFFLL));
      uint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, 0x80000001B837BF19 & 0x7FFFFFFFFFFFFFFFLL, v8);
      uint64_t v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)" \"", 2);
      if (*((void *)v25 + 64)) {
        uint64_t v11 = (const char *)*((void *)v25 + 64);
      }
      else {
        uint64_t v11 = "";
      }
      size_t v12 = strlen(v11);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)v11, v12);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)"\"\n", 2);
    }
    PCPtr<LiImageSource>::reset((void *)this + 4);
    PCPtr<LiImageSource>::reset((void *)this + 6);
    *((unsigned char *)this + 108) = 1;
    BOOL v4 = v25;
    uint64_t v6 = (const char *)*((void *)this + 22);
    if (!v25) {
      goto LABEL_18;
    }
LABEL_15:
    if (v6 && v4 == v6)
    {
LABEL_19:
      if (dbg())
      {
        uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"  leaving _3DEngineGroup ", 25);
        size_t v14 = strlen((const char *)(0x80000001B837BF19 & 0x7FFFFFFFFFFFFFFFLL));
        int v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, 0x80000001B837BF19 & 0x7FFFFFFFFFFFFFFFLL, v14);
        uint64_t v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)" \"", 2);
        if (*((void *)v25 + 64)) {
          size_t v17 = (const char *)*((void *)v25 + 64);
        }
        else {
          size_t v17 = "";
        }
        size_t v18 = strlen(v17);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)v17, v18);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)"\"\n", 2);
      }
      PCPtr<LiImageSource>::reset((void *)this + 20);
      PCPtr<LiImageSource>::reset((void *)this + 22);
      *((unsigned char *)this + 108) = 1;
    }
LABEL_25:
    int v19 = v27;
    PCSharedCount::~PCSharedCount(&v26);
    if (!v19) {
      break;
    }
  }
  if (dbg())
  {
    float v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"endInsertingIntoGroup: ", 23);
    LiGraphBuilder::stackRepr(this, (LiString *)&v25);
    uint64_t v21 = v25 ? v25 : "";
    size_t v22 = strlen(v21);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)v21, v22);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)"\n", 1);
    if (v25)
    {
      if (atomic_fetch_add((atomic_uint *volatile)v25 - 3, 0xFFFFFFFF) == 1)
      {
        const char *v25 = 0;
        if (v25) {
          int v23 = (char *)(v25 - 12);
        }
        else {
          int v23 = 0;
        }
        free(v23);
      }
    }
  }
  uint64_t result = v28;
  if (v28)
  {
    if (v29) {
      return (PCMutex *)PCMutex::unlock(v28);
    }
  }
  return result;
}

void sub_1B7A9C644(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  PCConsoleLock::~PCConsoleLock((PCMutex **)va);
  _Unwind_Resume(a1);
}

void PCArray<LiGraphBuilderGroup,PCArray_Traits<LiGraphBuilderGroup>>::pop(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 16) + 24 * *(int *)(a1 + 12);
  *(void *)a2 = *(void *)(v4 - 24);
  PCSharedCount::PCSharedCount((PCSharedCount *)(a2 + 8), (const PCSharedCount *)(v4 - 16));
  *(unsigned char *)(a2 + 16) = *(unsigned char *)(v4 - 8);
  int v5 = *(_DWORD *)(a1 + 12) - 1;
  if (*(_DWORD *)(a1 + 8) >= v5) {
    int v6 = *(_DWORD *)(a1 + 8);
  }
  else {
    int v6 = (2 * v5) | 1;
  }
  PCArray<LiGraphBuilderGroup,PCArray_Traits<LiGraphBuilderGroup>>::resize(a1, v5, v6);
}

void sub_1B7A9C72C(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1);
  _Unwind_Resume(a1);
}

uint64_t LiGraphBuilder::partitionWorld(uint64_t this)
{
  *(unsigned char *)(this + 108) = 1;
  return this;
}

PCMutex *LiGraphBuilder::addGroupAndMakeCurrent(PCSharedCount *a1, const PCSharedCount *a2)
{
  LiGraphBuilder::addGroup(a1, a2);

  return LiGraphBuilder::startInsertingIntoGroup((LiGraphBuilder *)a1, (uint64_t)a2);
}

void LiGraphBuilder::worldRoot(const PCSharedCount *this@<X0>, PCSharedCount *a2@<X8>)
{
  a2->int var0 = this->var0;
  PCSharedCount::PCSharedCount(a2 + 1, this + 1);
}

void LiGraphBuilder::get3DEngineGeode(const PCSharedCount *this@<X0>, PCSharedCount *a2@<X8>)
{
  a2->int var0 = this[24].var0;
  PCSharedCount::PCSharedCount(a2 + 1, this + 25);
}

uint64_t LiGraphBuilder::getAndIncrementCompositeOrder(LiGraphBuilder *this)
{
  uint64_t v1 = *((unsigned int *)this + 26);
  *((_DWORD *)this + 26) = v1 + 1;
  return v1;
}

void LiGraphBuilder::getLastChildInCurrentGroup(LiGraphBuilder *this@<X0>, PCSharedCount *a2@<X8>)
{
  LiGraphBuilder::getCurrentInsertionGroup(this, &v7);
  int var0 = v7.var0;
  PCSharedCount::~PCSharedCount(&v8);
  int v4 = (*(uint64_t (**)(PC_Sp_counted_base *))(*(void *)var0 + 136))(var0);
  if (v4)
  {
    int v5 = (PC_Sp_counted_base *)(*(uint64_t (**)(PC_Sp_counted_base *, void))(*(void *)var0 + 144))(var0, (v4 - 1));
    a2->int var0 = v5;
    if (v5) {
      int v6 = (PCShared_base *)((char *)v5 + *(void *)(*(void *)v5 - 24));
    }
    else {
      int v6 = 0;
    }
    PCSharedCount::PCSharedCount(a2 + 1, v6);
  }
  else
  {
    a2->int var0 = 0;
    PCSharedCount::PCSharedCount(a2 + 1);
  }
}

void LiGraphBuilder::getCurrentLocalToWorld(LiGraphBuilder *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 120) = 0x3FF0000000000000;
  *(void *)(a2 + 80) = 0x3FF0000000000000;
  *(void *)(a2 + 40) = 0x3FF0000000000000;
  *(void *)a2 = 0x3FF0000000000000;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  uint64_t v3 = *((unsigned int *)this + 23);
  if ((int)v3 >= 1)
  {
    for (uint64_t i = 0; i != v3; ++i)
    {
      if (i >= *((int *)this + 23)) {
        PCArray_base::badIndex(this);
      }
      PCMatrix44Tmpl<double>::rightMult(a2, (double *)(*(void *)(*((void *)this + 12) + 24 * i) + 8));
    }
  }
}

uint64_t LiGraphBuilder::addLightsToGraph(uint64_t result)
{
  if (*(int *)(result + 124) >= 1) {
    operator new();
  }
  return result;
}

void sub_1B7A9CA1C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C4099F9488BLL);
  _Unwind_Resume(a1);
}

uint64_t LiGraphBuilder::firstProjection(LiGraphBuilder *this)
{
  uint64_t v1 = this;
  int v2 = *((_DWORD *)this + 23);
  for (unsigned int i = v2 - 1; ; --i)
  {
    uint64_t v4 = (v2 - 1);
    if (v2 < 1) {
      break;
    }
    if (*((_DWORD *)v1 + 23) < v2) {
      PCArray_base::badIndex(this);
    }
    uint64_t v5 = *(void *)(*((void *)v1 + 12) + 24 * i);
    this = (LiGraphBuilder *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 200))(v5);
    int v2 = v4;
    if (this) {
      return v4;
    }
  }
  return 0xFFFFFFFFLL;
}

void LiGraphBuilder::combinedTransform(LiGraphBuilder *this@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  *(void *)(a4 + 120) = 0x3FF0000000000000;
  *(void *)(a4 + 80) = 0x3FF0000000000000;
  *(void *)(a4 + 40) = 0x3FF0000000000000;
  *(void *)a4 = 0x3FF0000000000000;
  *(_OWORD *)(a4 + 8) = 0u;
  *(_OWORD *)(a4 + 24) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 88) = 0u;
  *(_OWORD *)(a4 + 104) = 0u;
  int v5 = *((_DWORD *)this + 23);
  int v6 = v5 - a2;
  if (v5 > a2)
  {
    uint64_t v8 = a2;
    uint64_t v9 = a3;
    uint64_t v10 = 24 * a2;
    do
    {
      if (v8 < 0 || v8 >= *((int *)this + 23)) {
        PCArray_base::badIndex(this);
      }
      uint64_t v11 = *(double **)(*((void *)this + 12) + v10);
      PCMatrix44Tmpl<double>::rightMult(a4, v11 + 1);
      if (v9 == v8) {
        break;
      }
      LiGroup::viewProjectionTransform((LiGroup *)v11, (uint64_t)v12);
      PCMatrix44Tmpl<double>::rightMult(a4, v12);
      ++v8;
      v10 += 24;
      --v6;
    }
    while (v6);
  }
}

void *PCPtr<Li3DGroupForEquirect>::operator=<LiGroup>(void *a1, const void **a2)
{
  if (!*a2)
  {
    *a1 = 0;
    goto LABEL_5;
  }
  *a1 = v4;
  if (!v4)
  {
LABEL_5:
    int v6 = &v9;
    PCSharedCount::PCSharedCount(&v9);
    PCSharedCount::operator=(a1 + 1, (uint64_t *)&v9);
    goto LABEL_6;
  }
  int v5 = (const PCSharedCount *)(a2 + 1);
  int v6 = &v8;
  PCSharedCount::PCSharedCount(&v8, v5);
  PCSharedCount::operator=(a1 + 1, (uint64_t *)&v8);
LABEL_6:
  PCSharedCount::~PCSharedCount(v6);
  return a1;
}

void sub_1B7A9CC84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

void LiGraphBuilder::render2d(LiGraphBuilder *this)
{
}

void sub_1B7A9CD84(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1);
  _Unwind_Resume(a1);
}

void LiGraphBuilder::render(LiGraphBuilder *this)
{
}

void sub_1B7A9CE14(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1 + 1);
  _Unwind_Resume(a1);
}

void PCConsoleLock::PCConsoleLock(PCConsoleLock *this, int a2)
{
  if (PCSingletonObject<PCMutex,PCConsoleLock::SingletonTag,1000000000>::object(void)::once != -1) {
    dispatch_once(&PCSingletonObject<PCMutex,PCConsoleLock::SingletonTag,1000000000>::object(void)::once, &__block_literal_global_68);
  }
  uint64_t v4 = (PCMutex *)(PCSingletonObject<PCMutex,PCConsoleLock::SingletonTag,1000000000>::_instance + 8);
  *(void *)this = PCSingletonObject<PCMutex,PCConsoleLock::SingletonTag,1000000000>::_instance + 8;
  *((unsigned char *)this + 8) = 0;
  if (a2)
  {
    PCMutex::lock(v4);
    *((unsigned char *)this + 8) = 1;
  }
}

void ___ZN17PCSingletonObjectI7PCMutexN13PCConsoleLock12SingletonTagELi1000000000EE6objectEv_block_invoke()
{
}

void sub_1B7A9CF10(_Unwind_Exception *a1)
{
  PCSingleton::~PCSingleton(v1);
  MEMORY[0x1BA9BFBA0](v1, 0x1081C40EAC9FDC4);
  _Unwind_Resume(a1);
}

void PCSingletonObject<PCMutex,PCConsoleLock::SingletonTag,1000000000>::~PCSingletonObject(uint64_t a1)
{
  *(void *)a1 = &unk_1F111C9C8;
  PCSingletonObject<PCMutex,PCConsoleLock::SingletonTag,1000000000>::_dead = 1;
  PCSingletonObject<PCMutex,PCConsoleLock::SingletonTag,1000000000>::_instance = 0;
  PCMutex::~PCMutex((PCMutex *)(a1 + 8));

  PCSingleton::~PCSingleton((PCSingleton *)a1);
}

{
  uint64_t vars8;

  *(void *)a1 = &unk_1F111C9C8;
  PCSingletonObject<PCMutex,PCConsoleLock::SingletonTag,1000000000>::_dead = 1;
  PCSingletonObject<PCMutex,PCConsoleLock::SingletonTag,1000000000>::_instance = 0;
  PCMutex::~PCMutex((PCMutex *)(a1 + 8));
  PCSingleton::~PCSingleton((PCSingleton *)a1);

  JUMPOUT(0x1BA9BFBA0);
}

void PCArray<LiGraphBuilderGroup,PCArray_Traits<LiGraphBuilderGroup>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111CA10;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<LiGraphBuilderGroup,PCArray_Traits<LiGraphBuilderGroup>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

void PCArray<LiGraphBuilderGroup,PCArray_Traits<LiGraphBuilderGroup>>::resize(uint64_t a1, int a2, int a3)
{
  if (a3 <= a2) {
    int v3 = a2;
  }
  else {
    int v3 = a3;
  }
  if (a2 < 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v21, "PCArray::resize");
    PCException::PCException(exception, &v21);
    *(void *)exception = &unk_1F1199218;
  }
  if (v3 == *(_DWORD *)(a1 + 8))
  {
    uint64_t v6 = *(int *)(a1 + 12);
    if (a2 >= (int)v6)
    {
      if (a2 > (int)v6)
      {
        uint64_t v9 = 24 * v6;
        int v10 = a2 - v6;
        do
        {
          uint64_t v11 = *(void *)(a1 + 16);
          *(void *)(v11 + v9) = 0;
          PCSharedCount::PCSharedCount((PCSharedCount *)(v11 + v9 + 8));
          v9 += 24;
          --v10;
        }
        while (v10);
      }
    }
    else
    {
      uint64_t v7 = a2;
      uint64_t v8 = 24 * a2 + 8;
      do
      {
        PCSharedCount::~PCSharedCount((PCSharedCount *)(*(void *)(a1 + 16) + v8));
        ++v7;
        v8 += 24;
      }
      while (v7 < *(int *)(a1 + 12));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    int v12 = *(_DWORD *)(a1 + 12);
    if (a2 >= v12) {
      int v13 = *(_DWORD *)(a1 + 12);
    }
    else {
      int v13 = a2;
    }
    if (v13 < 1)
    {
      int v13 = 0;
    }
    else
    {
      uint64_t v14 = 0;
      do
      {
        uint64_t v15 = *(void *)(a1 + 16) + v14;
        *(void *)uint64_t v14 = *(void *)v15;
        PCSharedCount::PCSharedCount((PCSharedCount *)(v14 + 8), (const PCSharedCount *)(v15 + 8));
        *(unsigned char *)(v14 + 16) = *(unsigned char *)(v15 + 16);
        PCSharedCount::~PCSharedCount((PCSharedCount *)(*(void *)(a1 + 16) + v14 + 8));
        v14 += 24;
      }
      while (24 * v13 != v14);
      int v12 = *(_DWORD *)(a1 + 12);
    }
    if (v13 < v12)
    {
      uint64_t v16 = 24 * v13 + 8;
      do
      {
        PCSharedCount::~PCSharedCount((PCSharedCount *)(*(void *)(a1 + 16) + v16));
        v16 += 24;
        ++v13;
      }
      while (*(_DWORD *)(a1 + 12) > v13);
    }
    if (v13 < a2)
    {
      size_t v17 = (PCSharedCount *)(24 * v13 + 8);
      do
      {
        v17[-1].int var0 = 0;
        PCSharedCount::PCSharedCount(v17);
        size_t v17 = v18 + 3;
        ++v13;
      }
      while (v13 < a2);
    }
    uint64_t v19 = *(void *)(a1 + 16);
    if (v19) {
      MEMORY[0x1BA9BFB70](v19, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = a2;
}

void sub_1B7A9D330(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

uint64_t LiGraphBuilderGroup::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    *(void *)a1 = *(void *)a2;
    PCSharedCount::PCSharedCount(&v5, (const PCSharedCount *)(a2 + 8));
    PCSharedCount::operator=((uint64_t *)(a1 + 8), (uint64_t *)&v5);
    PCSharedCount::~PCSharedCount(&v5);
    *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  }
  return a1;
}

void sub_1B7A9D3D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

void LiImageProjection::LiImageProjection(LiImageProjection *this)
{
  *((void *)this + 5) = &unk_1F1199AC8;
  *((void *)this + 6) = 0;
  *((unsigned char *)this + LiDepthSorter::stackSort((uint64_t)this + 56) = 1;
  LiImageFilter::LiImageFilter(this, (uint64_t *)&off_1F111CB58);
  *(void *)this = &unk_1F111CA50;
  *((void *)this + 5) = &unk_1F111CB38;
}

void sub_1B7A9D48C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 40) = v2;
  *(unsigned char *)(v1 + LiDepthSorter::stackSort((uint64_t)this + 56) = 0;
  PCWeakCount::~PCWeakCount(v3);
  _Unwind_Resume(a1);
}

void LiImageProjection::LiImageProjection(LiImageProjection *this, LiImageSource *a2)
{
  *((void *)this + 5) = &unk_1F1199AC8;
  *((void *)this + 6) = 0;
  *((unsigned char *)this + LiDepthSorter::stackSort((uint64_t)this + 56) = 1;
  LiImageFilter::LiImageFilter(this, (uint64_t *)&off_1F111CB58);
  *(void *)this = &unk_1F111CA50;
  *((void *)this + 5) = &unk_1F111CB38;
  PCPtr<LiImageSource>::operator=<LiImageSource>((PCShared_base **)this + 2, (PCShared_base *)a2);
}

void sub_1B7A9D564(_Unwind_Exception *a1)
{
  LiImageFilter::~LiImageFilter((PCSharedCount *)v1, (const PCString *)&off_1F111CB58);
  *(void *)(v1 + 40) = v3;
  *(unsigned char *)(v1 + LiDepthSorter::stackSort((uint64_t)this + 56) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

void LiImageProjection::clone(LiImageProjection *this)
{
}

void sub_1B7A9D630(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1);
  _Unwind_Resume(a1);
}

PCShared_base **LiImageProjection::setInput(PCShared_base **this, LiImageSource *a2)
{
  return PCPtr<LiImageSource>::operator=<LiImageSource>(this + 2, (PCShared_base *)a2);
}

uint64_t LiImageProjection::getDelegate(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t LiImageProjection::pixelTransformSupport()
{
  return 6;
}

uint64_t LiImageProjection::getHelium@<X0>(LiImageSource **this@<X0>, LiAgent *a2@<X1>, uint64_t *a3@<X8>)
{
  *((_DWORD *)a2 + 8) = 2;
  return LiAgent::getHelium(a2, this[2], a3);
}

void LiImageTransform::clone(LiImageTransform *this)
{
}

void sub_1B7A9D784(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C40DE3F20C5);
  _Unwind_Resume(a1);
}

uint64_t LiImageTransform::getBoundary(uint64_t a1, uint64_t a2, double *a3)
{
  uint64_t v5 = *(void *)(a1 + 16);
  if (!v5) {
    throw_PCNullPointerException(1);
  }
  unsigned int v6 = (*(uint64_t (**)(uint64_t, uint64_t, double *))(*(void *)v5 + 24))(v5, a2, a3);
  return PCMatrix44Tmpl<double>::transformRect<double>((double *)(a1 + 40), a3, (uint64_t)a3) & v6;
}

uint64_t LiImageTransform::getHelium@<X0>(LiImageTransform *this@<X0>, LiAgent *a2@<X1>, uint64_t *a3@<X8>)
{
  *((_DWORD *)a2 + 8) = 2;
  LiAgent::loadTransform((uint64_t)a2, (uint64_t)this + 40);
  if (*(void *)a2) {
    char v6 = *(unsigned char *)(*(void *)a2 + 44) != 0;
  }
  else {
    char v6 = 0;
  }
  LiRenderingTechnology::setEnableMetalRendering((uint64_t)a2, v6);
  uint64_t v7 = (LiImageSource *)*((void *)this + 2);

  return LiAgent::getHelium(a2, v7, a3);
}

uint64_t LiImageTransform::print(uint64_t a1, void *a2, int a3)
{
  LiImageSource::printIndent(a2, a3);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"LiImageTransform:\n", 18);
  PCMatrix44Tmpl<double>::print(a1 + 40, a2, a3 + 2);
  if (*(unsigned char *)(a1 + 296))
  {
    LiImageSource::printIndent(a2, a3 + 2);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"World transform:\n", 17);
    PCMatrix44Tmpl<double>::print(a1 + 168, a2, a3 + 2);
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (!v6) {
    throw_PCNullPointerException(1);
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 128);

  return v7();
}

uint64_t LiEmptyImage::estimateRenderMemory()
{
  return 0;
}

void LiSolidSource::LiSolidSource(LiSolidSource *this)
{
  *((void *)this + 4) = &unk_1F1199AC8;
  *((void *)this + 5) = 0;
  *((unsigned char *)this + 48) = 1;
  LiImageSource::LiImageSource((LiImageSource *)this, (uint64_t *)&off_1F111CC90);
  *(void *)this = &unk_1F111CBA8;
  *((void *)this + 4) = &unk_1F111CC70;
  PCWorkingColorVector::PCWorkingColorVector((LiSolidSource *)((char *)this + 16));
}

void sub_1B7A9DA64(_Unwind_Exception *a1)
{
  OZChannelBase::setRangeName((OZChannelBase *)v1, (const PCString *)&off_1F111CC90);
  *(void *)(v1 + 32) = v3;
  *(unsigned char *)(v1 + 48) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

void LiSolidSource::clone(LiSolidSource *this)
{
}

void sub_1B7A9DB48(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40516CBDFCLL);
  _Unwind_Resume(a1);
}

void LiSolidSource::getHelium(float32x2_t *this, LiAgent *a2)
{
  uint64_t v2 = 0;
  float64x2_t v3 = vcvtq_f64_f32(this[3]);
  float64x2_t v5 = vcvtq_f64_f32(this[2]);
  float64x2_t v6 = v3;
  do
  {
    v5.f64[v2] = v6.f64[1] * v5.f64[v2];
    ++v2;
  }
  while (v2 != 3);
  uint64_t v4 = (LiHeBackgroundGenerator *)HGObject::operator new(0x1A0uLL);
  LiHeBackgroundGenerator::LiHeBackgroundGenerator(v4);
}

void sub_1B7A9DC30(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t LiSolidSource::estimateRenderMemory()
{
  return 0;
}

void LiImageAlphaFill::LiImageAlphaFill(LiImageAlphaFill *this)
{
  *((void *)this + 7) = &unk_1F1199AC8;
  *((void *)this + 8) = 0;
  *((unsigned char *)this + 72) = 1;
  LiImageFilter::LiImageFilter(this, (uint64_t *)&off_1F111CDD8);
  *(void *)this = &unk_1F111CCD0;
  *((void *)this + 7) = &unk_1F111CDB8;
  PCWorkingColorVector::PCWorkingColorVector((LiImageAlphaFill *)((char *)this + 36));
}

void sub_1B7A9DD2C(_Unwind_Exception *a1)
{
  LiImageFilter::~LiImageFilter((PCSharedCount *)v1, (const PCString *)&off_1F111CDD8);
  *(void *)(v1 + LiDepthSorter::stackSort((uint64_t)this + 56) = v3;
  *(unsigned char *)(v1 + 72) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

void LiImageAlphaFill::~LiImageAlphaFill(PCSharedCount *this)
{
  *(void *)(v1 + LiDepthSorter::stackSort((uint64_t)this + 56) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 72) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 64));
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)(v1 + LiDepthSorter::stackSort((uint64_t)this + 56) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 72) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 64));

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'LiImageAlphaFill::~LiImageAlphaFill(LiImageAlphaFill *this)
{
  *(void *)(v1 + LiDepthSorter::stackSort((uint64_t)this + 56) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 72) = 0;
  uint64_t v2 = (PC_Sp_counted_base **)(v1 + 64);

  PCWeakCount::~PCWeakCount(v2);
}

{
  LiImageAlphaFill::~LiImageAlphaFill((PCSharedCount *)((char *)this + *(void *)(*(void *)this - 24)));
}

__n128 LiImageAlphaFill::setColor(LiImageAlphaFill *this, __n128 *a2)
{
  __n128 result = *a2;
  *(__n128 *)((char *)this + 36) = *a2;
  return result;
}

void LiImageAlphaFill::clone(LiImageAlphaFill *this)
{
}

void sub_1B7A9DFBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCSharedCount a12)
{
  PCSharedCount::~PCSharedCount(&a12);
  PCSharedCount::~PCSharedCount(v12);
  _Unwind_Resume(a1);
}

uint64_t LiImageAlphaFill::getHelium@<X0>(LiImageSource **this@<X0>, LiAgent *a2@<X1>, LiHeAlphaFill **a3@<X8>)
{
  *((_DWORD *)a2 + 8) = 2;
  uint64_t result = LiAgent::getHelium(a2, this[2], &v7);
  if (v7)
  {
    float64x2_t v6 = (LiHeAlphaFill *)HGObject::operator new(0x1A0uLL);
    LiHeAlphaFill::LiHeAlphaFill(v6);
    (*(void (**)(LiHeAlphaFill *, void, uint64_t))(*(void *)v6 + 120))(v6, 0, v7);
    (*(void (**)(LiHeAlphaFill *, void, float, float, float, float))(*(void *)v6 + 96))(v6, 0, *((float *)this + 9), *((float *)this + 10), *((float *)this + 11), *((float *)this + 12));
    (*(void (**)(LiHeAlphaFill *, uint64_t, float, double, double, double))(*(void *)v6 + 96))(v6, 1, 1.0, 0.0, 0.0, 0.0);
    *a3 = v6;
    uint64_t result = v7;
    if (v7) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v7 + 24))(v7);
    }
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

void sub_1B7A9E144(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  HGObject::operator delete(v10);
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24))(a10);
  }
  _Unwind_Resume(a1);
}

void LiImageTransform::~LiImageTransform(PCSharedCount *this)
{
  this->int var0 = (PC_Sp_counted_base *)&unk_1F111CE28;
  this[44].int var0 = (PC_Sp_counted_base *)&unk_1F111CF10;
  LiClipSet::~LiClipSet((LiClipSet *)&this[38]);
  this->int var0 = (PC_Sp_counted_base *)off_1F111CF80;
  this[44].int var0 = (PC_Sp_counted_base *)off_1F111D068;
  PCSharedCount::~PCSharedCount(this + 3);
  OZChannelBase::setRangeName((OZChannelBase *)this, (const PCString *)&off_1F111CF38);
  this[44].int var0 = (PC_Sp_counted_base *)&unk_1F1199AC8;
  LOBYTE(this[46].var0) = 0;
  PCWeakCount::~PCWeakCount(&this[45].var0);
}

{
  uint64_t vars8;

  this->int var0 = (PC_Sp_counted_base *)&unk_1F111CE28;
  this[44].int var0 = (PC_Sp_counted_base *)&unk_1F111CF10;
  LiClipSet::~LiClipSet((LiClipSet *)&this[38]);
  this->int var0 = (PC_Sp_counted_base *)off_1F111CF80;
  this[44].int var0 = (PC_Sp_counted_base *)off_1F111D068;
  PCSharedCount::~PCSharedCount(this + 3);
  OZChannelBase::setRangeName((OZChannelBase *)this, (const PCString *)&off_1F111CF38);
  this[44].int var0 = (PC_Sp_counted_base *)&unk_1F1199AC8;
  LOBYTE(this[46].var0) = 0;
  PCWeakCount::~PCWeakCount(&this[45].var0);

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'LiImageTransform::~LiImageTransform(LiImageTransform *this)
{
  uint64_t v1 = (PCSharedCount *)((char *)this + *(void *)(*(void *)this - 24));
  v1->int var0 = (PC_Sp_counted_base *)&unk_1F111CE28;
  v1[44].int var0 = (PC_Sp_counted_base *)&unk_1F111CF10;
  LiClipSet::~LiClipSet((LiClipSet *)&v1[38]);
  v1->int var0 = (PC_Sp_counted_base *)off_1F111CF80;
  v1[44].int var0 = (PC_Sp_counted_base *)off_1F111D068;
  PCSharedCount::~PCSharedCount(v1 + 3);
  OZChannelBase::setRangeName((OZChannelBase *)v1, (const PCString *)&off_1F111CF38);
  v1[44].int var0 = (PC_Sp_counted_base *)&unk_1F1199AC8;
  LOBYTE(v1[46].var0) = 0;

  PCWeakCount::~PCWeakCount(&v1[45].var0);
}

{
  PCSharedCount *v1;
  uint64_t vars8;

  uint64_t v1 = (PCSharedCount *)((char *)this + *(void *)(*(void *)this - 24));
  v1->int var0 = (PC_Sp_counted_base *)&unk_1F111CE28;
  v1[44].int var0 = (PC_Sp_counted_base *)&unk_1F111CF10;
  LiClipSet::~LiClipSet((LiClipSet *)&v1[38]);
  v1->int var0 = (PC_Sp_counted_base *)off_1F111CF80;
  v1[44].int var0 = (PC_Sp_counted_base *)off_1F111D068;
  PCSharedCount::~PCSharedCount(v1 + 3);
  OZChannelBase::setRangeName((OZChannelBase *)v1, (const PCString *)&off_1F111CF38);
  v1[44].int var0 = (PC_Sp_counted_base *)&unk_1F1199AC8;
  LOBYTE(v1[46].var0) = 0;
  PCWeakCount::~PCWeakCount(&v1[45].var0);

  JUMPOUT(0x1BA9BFBA0);
}

void LiEmptyImage::~LiEmptyImage(OZChannelBase *this)
{
  uint64_t v1 = OZChannelBase::setRangeName(this, (const PCString *)&off_1F111D2F0);
  *(void *)(v1 + 16) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 32) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 24));
}

{
  uint64_t v1;
  uint64_t vars8;

  uint64_t v1 = OZChannelBase::setRangeName(this, (const PCString *)&off_1F111D2F0);
  *(void *)(v1 + 16) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 32) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 24));

  JUMPOUT(0x1BA9BFBA0);
}

void LiEmptyImage::clone(LiEmptyImage *this)
{
}

void sub_1B7A9E700(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40EE17FB6ALL);
  _Unwind_Resume(a1);
}

HGNode *LiEmptyImage::getHelium@<X0>(HGNode **a1@<X8>)
{
  uint64_t v4 = (HGNode *)HGObject::operator new(0x1A0uLL);
  uint64_t result = HGNode::HGNode(v4);
  *a1 = v4;
  return result;
}

void sub_1B7A9E758(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

void virtual thunk to'LiEmptyImage::~LiEmptyImage(LiEmptyImage *this)
{
  uint64_t v1 = OZChannelBase::setRangeName((OZChannelBase *)((char *)this + *(void *)(*(void *)this - 24)), (const PCString *)&off_1F111D2F0);
  *(void *)(v1 + 16) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 32) = 0;
  uint64_t v2 = (PC_Sp_counted_base **)(v1 + 24);

  PCWeakCount::~PCWeakCount(v2);
}

{
  char *v1;
  uint64_t vars8;

  uint64_t v1 = (char *)this + *(void *)(*(void *)this - 24);
  OZChannelBase::setRangeName((OZChannelBase *)v1, (const PCString *)&off_1F111D2F0);
  *((void *)v1 + 2) = &unk_1F1199AC8;
  v1[32] = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)v1 + 3);

  JUMPOUT(0x1BA9BFBA0);
}

void LiImageProjection::~LiImageProjection(PCSharedCount *this)
{
  this->int var0 = (PC_Sp_counted_base *)off_1F111D4A0;
  this[5].int var0 = (PC_Sp_counted_base *)off_1F111D588;
  PCSharedCount::~PCSharedCount(this + 3);
  OZChannelBase::setRangeName((OZChannelBase *)this, (const PCString *)&off_1F111CB60);
  this[5].int var0 = (PC_Sp_counted_base *)&unk_1F1199AC8;
  LOBYTE(this[7].var0) = 0;
  PCWeakCount::~PCWeakCount(&this[6].var0);
}

{
  uint64_t vars8;

  this->int var0 = (PC_Sp_counted_base *)off_1F111D4A0;
  this[5].int var0 = (PC_Sp_counted_base *)off_1F111D588;
  PCSharedCount::~PCSharedCount(this + 3);
  OZChannelBase::setRangeName((OZChannelBase *)this, (const PCString *)&off_1F111CB60);
  this[5].int var0 = (PC_Sp_counted_base *)&unk_1F1199AC8;
  LOBYTE(this[7].var0) = 0;
  PCWeakCount::~PCWeakCount(&this[6].var0);

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'LiImageProjection::~LiImageProjection(LiImageProjection *this)
{
  uint64_t v1 = (PCSharedCount *)((char *)this + *(void *)(*(void *)this - 24));
  v1->int var0 = (PC_Sp_counted_base *)off_1F111D4A0;
  v1[5].int var0 = (PC_Sp_counted_base *)off_1F111D588;
  PCSharedCount::~PCSharedCount(v1 + 3);
  OZChannelBase::setRangeName((OZChannelBase *)v1, (const PCString *)&off_1F111CB60);
  v1[5].int var0 = (PC_Sp_counted_base *)&unk_1F1199AC8;
  LOBYTE(v1[7].var0) = 0;

  PCWeakCount::~PCWeakCount(&v1[6].var0);
}

{
  PCSharedCount *v1;
  uint64_t vars8;

  uint64_t v1 = (PCSharedCount *)((char *)this + *(void *)(*(void *)this - 24));
  v1->int var0 = (PC_Sp_counted_base *)off_1F111D4A0;
  v1[5].int var0 = (PC_Sp_counted_base *)off_1F111D588;
  PCSharedCount::~PCSharedCount(v1 + 3);
  OZChannelBase::setRangeName((OZChannelBase *)v1, (const PCString *)&off_1F111CB60);
  v1[5].int var0 = (PC_Sp_counted_base *)&unk_1F1199AC8;
  LOBYTE(v1[7].var0) = 0;
  PCWeakCount::~PCWeakCount(&v1[6].var0);

  JUMPOUT(0x1BA9BFBA0);
}

void LiSolidSource::~LiSolidSource(OZChannelBase *this)
{
  uint64_t v1 = OZChannelBase::setRangeName(this, (const PCString *)&off_1F111CC90);
  *(void *)(v1 + 32) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 48) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 40));
}

{
  uint64_t v1;
  uint64_t vars8;

  uint64_t v1 = OZChannelBase::setRangeName(this, (const PCString *)&off_1F111CC90);
  *(void *)(v1 + 32) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 48) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 40));

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'LiSolidSource::~LiSolidSource(LiSolidSource *this)
{
  uint64_t v1 = OZChannelBase::setRangeName((OZChannelBase *)((char *)this + *(void *)(*(void *)this - 24)), (const PCString *)&off_1F111CC90);
  *(void *)(v1 + 32) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 48) = 0;
  uint64_t v2 = (PC_Sp_counted_base **)(v1 + 40);

  PCWeakCount::~PCWeakCount(v2);
}

{
  char *v1;
  uint64_t vars8;

  uint64_t v1 = (char *)this + *(void *)(*(void *)this - 24);
  OZChannelBase::setRangeName((OZChannelBase *)v1, (const PCString *)&off_1F111CC90);
  *((void *)v1 + 4) = &unk_1F1199AC8;
  v1[48] = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)v1 + 5);

  JUMPOUT(0x1BA9BFBA0);
}

void LiEmptyImage::LiEmptyImage(LiEmptyImage *this)
{
  *((void *)this + 2) = &unk_1F1199AC8;
  *((void *)this + 3) = 0;
  *((unsigned char *)this + 32) = 1;
  LiImageSource::LiImageSource((LiImageSource *)this, (uint64_t *)&off_1F111D2F0);
  *(void *)this = &unk_1F111D208;
  *((void *)this + 2) = &unk_1F111D2D0;
}

void sub_1B7A9EDE0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 16) = v2;
  *(unsigned char *)(v1 + 32) = 0;
  PCWeakCount::~PCWeakCount(v3);
  _Unwind_Resume(a1);
}

void LiMaterial::LiMaterial(LiMaterial *this, uint64_t *a2)
{
  LiSceneObject::LiSceneObject(this, a2 + 1);
  uint64_t v3 = *a2;
  *(void *)uint64_t v4 = *a2;
  *(void *)(v4 + *(void *)(v3 - 24)) = a2[5];
  *(_DWORD *)(v4 + 568) = 1;
  *(void *)(v4 + 576) = &unk_1F111DB50;
  *(void *)(v4 + 592) = 0;
  *(void *)(v4 + 584) = 0;
  *(void *)(v4 + 616) = 0;
  *(void *)(v4 + 608) = 0;
  *(void *)(v4 + 600) = v4 + 608;
  *(_DWORD *)(v4 + 624) = 0;
  *(void *)(v4 + 632) = 0x3FF0000000000000;
  __asm { FMOV            V0.2D, #1.0 }
  *(_OWORD *)(v4 + 640) = _Q0;
  *(_DWORD *)(v4 + 6LiDepthSorter::stackSort((uint64_t)this + 56) = 0;
}

uint64_t PCArray<LiMaterial::UniformValue,PCArray_Traits<LiMaterial::UniformValue>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111DB50;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<LiMaterial::UniformValue,PCArray_Traits<LiMaterial::UniformValue>>::resize((void *)a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

void LiMaterial::~LiMaterial(LiMaterial *this, PC_Sp_counted_base **a2)
{
  uint64_t v4 = *a2;
  *(void *)this = *a2;
  *(void *)((char *)this + *((void *)v4 - 3)) = a2[5];
  float64x2_t v5 = (char *)*((void *)this + 75);
  float64x2_t v6 = (char *)this + 608;
  if (v5 != (char *)this + 608)
  {
    do
    {
      uint64_t v7 = (LiMaterialSamplerInfo *)*((void *)v5 + 5);
      if (v7)
      {
        LiMaterialSamplerInfo::~LiMaterialSamplerInfo(v7);
        MEMORY[0x1BA9BFBA0]();
      }
      uint64_t v8 = (char *)*((void *)v5 + 1);
      if (v8)
      {
        do
        {
          uint64_t v9 = v8;
          uint64_t v8 = *(char **)v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          uint64_t v9 = (char *)*((void *)v5 + 2);
          BOOL v10 = *(void *)v9 == (void)v5;
          float64x2_t v5 = v9;
        }
        while (!v10);
      }
      float64x2_t v5 = v9;
    }
    while (v9 != v6);
  }
  PCSpinLock::~PCSpinLock((PCSpinLock *)this + 156);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)this + 600, *((void **)this + 76));
  *((void *)this + 72) = &unk_1F111DB50;
  if (*((int *)this + 146) < 0) {
    int v11 = 1;
  }
  else {
    int v11 = *((_DWORD *)this + 146);
  }
  PCArray<LiMaterial::UniformValue,PCArray_Traits<LiMaterial::UniformValue>>::resize((void *)this + 72, 0, v11);
  uint64_t v12 = *((void *)this + 74);
  if (v12) {
    MEMORY[0x1BA9BFB70](v12, 0x1000C8077774924);
  }
  *((void *)this + 74) = 0;
  *((_DWORD *)this + 146) = 0;

  LiSceneObject::~LiSceneObject((PCSharedCount *)this, a2 + 1);
}

double LiMaterial::localBoundingBox(uint64_t a1, _OWORD *a2)
{
  double result = 1.0;
  a2[1] = xmmword_1B7E736F0;
  a2[2] = xmmword_1B7E736F0;
  *a2 = xmmword_1B7E736F0;
  return result;
}

void LiMaterial::plane(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0xBFF0000000000000;
}

void LiMaterial::cast(uint64_t a1@<X8>)
{
  *(unsigned char *)a1 = 0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + LiDepthSorter::stackSort((uint64_t)this + 56) = 0u;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 72));
}

uint64_t LiMaterial::print(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 136))(a1, a2, a3, 1);
}

uint64_t LiMaterial::printMaterial(uint64_t a1, void *a2, uint64_t a3, int a4)
{
  LiImageSource::printIndent(a2, a3);
  uint64_t v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"LiMaterial(\"", 12);
  if (*(void *)(a1 + 512)) {
    uint64_t v9 = *(const char **)(a1 + 512);
  }
  else {
    uint64_t v9 = "";
  }
  size_t v10 = strlen(v9);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)v9, v10);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"\"", 1);
  if (a4)
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", ", 2);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"parts ", 6);
    std::ostream::operator<<();
  }
  if (*(_DWORD *)(a1 + 588))
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", ", 2);
    int v11 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)" uniforms", 9);
  }
  if (*(void *)(a1 + 616))
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", ", 2);
    uint64_t v12 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" samplers", 9);
  }
  int v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)")", 1);
  std::ios_base::getloc((const std::ios_base *)((char *)v13 + *(void *)(*v13 - 24)));
  uint64_t v14 = std::locale::use_facet(&v17, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v14->__vftable[2].~facet_0)(v14, 10);
  std::locale::~locale(&v17);
  std::ostream::put();
  std::ostream::flush();
  uint64_t v15 = *(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 144);

  return v15(a1, a2, a3);
}

void sub_1B7A9F3B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

void *LiMaterial::printMaterialDetails(__CFString **a1, void *a2, int a3)
{
  uint64_t v4 = a1;
  v52[18] = *(PCString *)MEMORY[0x1E4F143B8];
  size_t __nel = 0;
  __base = 0;
  v46[1] = 0;
  int v47 = &unk_1F111DB88;
  size_t v45 = (uint64_t *)v46;
  v46[0] = 0;
  int v5 = *((_DWORD *)a1 + 147);
  if (v5)
  {
    int v6 = 0;
    for (i = 0; i != v5; int v6 = i)
    {
      if (v6 < 0 || *((_DWORD *)v4 + 147) <= v6) {
        PCArray_base::badIndex((PCArray_base *)a1);
      }
      uint64_t v8 = (uint64_t)v4[74] + 152 * i;
      v51.__locale_ = *(std::locale::__imp **)v8;
      ProShade::Value::Value(v52, (const PCString *)(v8 + 8));
      uint64_t v9 = (const char *)*((void *)v51.__locale_ + 4);
      float v44 = (atomic_uint *)v9;
      if (v9) {
        atomic_fetch_add((atomic_uint *volatile)v9 - 3, 1u);
      }
      if ((int)__nel <= SHIDWORD(__nel)) {
        int v10 = (2 * (HIDWORD(__nel) + 1)) | 1;
      }
      else {
        int v10 = __nel;
      }
      PCArray<LiString,PCArray_Traits<LiString>>::resize((uint64_t)&v47, HIDWORD(__nel) + 1, v10);
      int v11 = (char *)__base + 8 * SHIDWORD(__nel);
      uint64_t v12 = (atomic_uint **)(v11 - 8);
      if (v11 - 8 != (char *)&v44)
      {
        LiString::dec((LiString *)(v11 - 8));
        int v13 = v44;
        *uint64_t v12 = v44;
        if (v13) {
          atomic_fetch_add(v13 - 3, 1u);
        }
      }
      v50.__locale_ = (std::locale::__imp *)&v44;
      uint64_t v14 = std::__tree<std::__value_type<LiString,ProShade::Value>,std::__map_value_compare<LiString,std::__value_type<LiString,ProShade::Value>,std::less<LiString>,true>,std::allocator<std::__value_type<LiString,ProShade::Value>>>::__emplace_unique_key_args<LiString,std::piecewise_construct_t const&,std::tuple<LiString const&>,std::tuple<>>(&v45, (const char **)&v44, (uint64_t)&std::piecewise_construct, (uint64_t **)&v50);
      a1 = ProShade::Value::operator=((__CFString **)v14 + 5, v52);
      if (v44 && atomic_fetch_add(v44 - 3, 0xFFFFFFFF) == 1)
      {
        *(unsigned char *)float v44 = 0;
        if (v44) {
          uint64_t v15 = (char *)(v44 - 3);
        }
        else {
          uint64_t v15 = 0;
        }
        free(v15);
      }
      ++i;
    }
    if (HIDWORD(__nel)) {
      qsort(__base, HIDWORD(__nel), 8uLL, (int (__cdecl *)(const void *, const void *))uniform_order);
    }
  }
  LiImageSource::printIndent(a2, a3 + 1);
  uint64_t v16 = (PCArray_base *)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"Uniforms:\n", 10);
  int v17 = HIDWORD(__nel);
  if (HIDWORD(__nel))
  {
    int v18 = 0;
    int v19 = 0;
    float v20 = (std::locale::id *)MEMORY[0x1E4FBA258];
    do
    {
      if (v18 < 0 || SHIDWORD(__nel) <= v18) {
        PCArray_base::badIndex(v16);
      }
      PCString v21 = (std::locale::__imp *)((char *)__base + 8 * v19);
      v51.__locale_ = v21;
      size_t v22 = std::__tree<std::__value_type<LiString,ProShade::Value>,std::__map_value_compare<LiString,std::__value_type<LiString,ProShade::Value>,std::less<LiString>,true>,std::allocator<std::__value_type<LiString,ProShade::Value>>>::__emplace_unique_key_args<LiString,std::piecewise_construct_t const&,std::tuple<LiString const&>,std::tuple<>>(&v45, (const char **)v21, (uint64_t)&std::piecewise_construct, (uint64_t **)&v51);
      LiImageSource::printIndent(a2, a3 + 2);
      if (*(void *)v21) {
        int v23 = *(const char **)v21;
      }
      else {
        int v23 = "";
      }
      size_t v24 = strlen(v23);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)v23, v24);
      uint64_t v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)" = ", 3);
      ProShade::Value::repr((ProShade::Value *)(v22 + 5), (LiString *)&v51);
      if (v51.__locale_) {
        locale = (const char *)v51.__locale_;
      }
      else {
        locale = "";
      }
      size_t v27 = strlen(locale);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)locale, v27);
      if (v51.__locale_ && atomic_fetch_add((atomic_uint *volatile)v51.__locale_ - 3, 0xFFFFFFFF) == 1)
      {
        *(unsigned char *)v51.__locale_ = 0;
        if (v51.__locale_) {
          float v28 = (char *)v51.__locale_ - 12;
        }
        else {
          float v28 = 0;
        }
        free(v28);
      }
      std::ios_base::getloc((const std::ios_base *)((char *)v25 + *(void *)(*v25 - 24)));
      char v29 = std::locale::use_facet(&v51, v20);
      ((void (*)(const std::locale::facet *, uint64_t))v29->__vftable[2].~facet_0)(v29, 10);
      std::locale::~locale(&v51);
      std::ostream::put();
      uint64_t v16 = (PCArray_base *)std::ostream::flush();
      int v18 = ++v19;
    }
    while (v17 != v19);
  }
  LiImageSource::printIndent(a2, a3 + 1);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"Textures:\n", 10);
  float v44 = (atomic_uint *)(v4 + 78);
  PCSpinLock::lock((os_unfair_lock_t)v4 + 156);
  PCSharedCount v30 = (__CFString **)v4[75];
  if (v30 != v4 + 76)
  {
    signed int v31 = (std::locale::id *)MEMORY[0x1E4FBA258];
    do
    {
      char v32 = v30[4];
      float v33 = v30[5];
      if (!LOBYTE(v33[9].length) || BYTE4(v33[9].length))
      {
        LiImageSource::printIndent(a2, a3 + 2);
        if (v32[1].isa) {
          isSCNMatrix4 a = (const char *)v32[1].isa;
        }
        else {
          isSCNMatrix4 a = "";
        }
        size_t v35 = strlen(isa);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)isa, v35);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)": ", 2);
        LiMaterialSamplerInfo::getTexture((LiMaterialSamplerInfo *)v33, (PCWorkingColorVector *)&v51);
        ProGL::TextureHandle::getWidth(&v51.__locale_);
        uint64_t v36 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)" x ", 3);
        ProGL::TextureHandle::getHeight(&v51.__locale_);
        std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)" ", 1);
        if (LOBYTE(v33[9].length))
        {
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"[", 1);
          if (BYTE5(v33[9].length)) {
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)" triplanar", 10);
          }
          if (BYTE6(v33[9].length)) {
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)" rotateSideTexture", 18);
          }
          if (HIBYTE(v33[9].length)) {
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)" invert", 7);
          }
          if (HIDWORD(v33[10].isa) && LOBYTE(v33[10].info)) {
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)" bumpIsHeight", 13);
          }
          if (BYTE1(v33[10].info)) {
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)" mipmap", 7);
          }
          if (LOBYTE(v33[10].data)) {
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)" gradient", 9);
          }
          if (BYTE1(v33[10].data)) {
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)" checkTransparency", 18);
          }
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)" ]", 2);
        }
        else
        {
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"no attributes", 13);
        }
        std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
        size_t v37 = std::locale::use_facet(&v50, v31);
        ((void (*)(const std::locale::facet *, uint64_t))v37->__vftable[2].~facet_0)(v37, 10);
        std::locale::~locale(&v50);
        std::ostream::put();
        std::ostream::flush();
        if (v52[0].var0) {
          std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v52[0].var0);
        }
      }
      uint64_t v38 = v30[1];
      if (v38)
      {
        do
        {
          uint64_t v39 = (__CFString **)v38;
          uint64_t v38 = (__CFString *)v38->isa;
        }
        while (v38);
      }
      else
      {
        do
        {
          uint64_t v39 = (__CFString **)v30[2];
          BOOL v40 = *v39 == (__CFString *)v30;
          PCSharedCount v30 = v39;
        }
        while (!v40);
      }
      PCSharedCount v30 = v39;
    }
    while (v39 != v4 + 76);
  }
  PCSpinLock::unlock((os_unfair_lock_t)v4 + 156);
  std::__tree<std::__value_type<LiString,ProShade::Value>,std::__map_value_compare<LiString,std::__value_type<LiString,ProShade::Value>,std::less<LiString>,true>,std::allocator<std::__value_type<LiString,ProShade::Value>>>::destroy((uint64_t)&v45, v46[0]);
  int v47 = &unk_1F111DB88;
  if ((__nel & 0x80000000) != 0) {
    int v41 = 1;
  }
  else {
    int v41 = __nel;
  }
  PCArray<LiString,PCArray_Traits<LiString>>::resize((uint64_t)&v47, 0, v41);
  double result = __base;
  if (__base) {
    return (void *)MEMORY[0x1BA9BFB70](__base, 0x1000C8077774924);
  }
  return result;
}

void sub_1B7A9FAD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,std::locale a21,std::locale a22,uint64_t a23)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t uniform_order(const LiString *a1, const LiString *a2)
{
  int v4 = parseName(a1);
  int v5 = parseName(a2);
  if (v4 < v5) {
    return 0xFFFFFFFFLL;
  }
  if (v4 > v5) {
    return 1;
  }
  uint64_t v7 = *(const char **)a1;
  uint64_t v8 = *(const char **)a2;
  if (*(void *)a1 == *(void *)a2) {
    return 0;
  }
  if (!v7) {
    return 1;
  }
  if (!v8) {
    return 0xFFFFFFFFLL;
  }

  return strcmp(v7, v8);
}

void LiMaterialSamplerInfo::getTexture(LiMaterialSamplerInfo *this@<X0>, PCWorkingColorVector *a2@<X8>)
{
  int v4 = ProGL::TextureHandle::operator void (ProGL::TextureHandle::*)(void)((void (**)(_anonymous_namespace_ **))this + 18);
  if (v5) {
    BOOL v6 = (v5 & 1 | (unint64_t)v4) == 0;
  }
  else {
    BOOL v6 = 1;
  }
  int v7 = !v6;
  if (v4 || v7)
  {
    uint64_t v8 = *((void *)this + 19);
    *(void *)a2 = *((void *)this + 18);
    *((void *)a2 + 1) = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    ProGL::GL::GL((ProGL::GL *)v9);
    LiTextureStoreToken::redeem((LiTextureStoreTokenImpl **)this + 20, (ProGL::GL *)v9, a2);
    ProGL::GL::~GL((ProGL::GL *)v9);
  }
}

void sub_1B7A9FCBC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ProGL::GL::~GL((ProGL::GL *)va);
  _Unwind_Resume(a1);
}

uint64_t PCArray<LiString,PCArray_Traits<LiString>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111DB88;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<LiString,PCArray_Traits<LiString>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

uint64_t LiMaterial::obtainSamplerInfo(os_unfair_lock_s *this, const ProShade::SamplerNode *a2)
{
  int v4 = this + 156;
  PCSpinLock::lock(this + 156);
  uint64_t v5 = *(void **)&this[152]._os_unfair_lock_opaque;
  if (!v5) {
    goto LABEL_12;
  }
  BOOL v6 = this + 152;
  do
  {
    unint64_t v7 = v5[4];
    BOOL v8 = v7 >= (unint64_t)a2;
    if (v7 >= (unint64_t)a2) {
      uint64_t v9 = v5;
    }
    else {
      uint64_t v9 = v5 + 1;
    }
    if (v8) {
      BOOL v6 = (os_unfair_lock_s *)v5;
    }
    uint64_t v5 = (void *)*v9;
  }
  while (*v9);
  if (v6 == &this[152] || *(void *)&v6[8]._os_unfair_lock_opaque > (unint64_t)a2) {
LABEL_12:
  }
    operator new();
  uint64_t v11 = *(void *)&v6[10]._os_unfair_lock_opaque;
  PCSpinLock::unlock(v4);
  return v11;
}

void sub_1B7A9FE2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_unfair_lock_s *a9)
{
  MEMORY[0x1BA9BFBA0](v9, 0x10A0C40905BE205);
  PCLockSentry<PCSpinLock>::~PCLockSentry(&a9);
  _Unwind_Resume(a1);
}

uint64_t LiMaterial::getSamplerInfo(os_unfair_lock_s *this, const ProShade::SamplerNode *a2)
{
  int v4 = this + 156;
  PCSpinLock::lock(this + 156);
  uint64_t v5 = *(void **)&this[152]._os_unfair_lock_opaque;
  if (!v5) {
    goto LABEL_12;
  }
  BOOL v6 = this + 152;
  do
  {
    unint64_t v7 = v5[4];
    BOOL v8 = v7 >= (unint64_t)a2;
    if (v7 >= (unint64_t)a2) {
      uint64_t v9 = v5;
    }
    else {
      uint64_t v9 = v5 + 1;
    }
    if (v8) {
      BOOL v6 = (os_unfair_lock_s *)v5;
    }
    uint64_t v5 = (void *)*v9;
  }
  while (*v9);
  if (v6 != &this[152] && *(void *)&v6[8]._os_unfair_lock_opaque <= (unint64_t)a2) {
    uint64_t v10 = *(void *)&v6[10]._os_unfair_lock_opaque;
  }
  else {
LABEL_12:
  }
    uint64_t v10 = 0;
  PCSpinLock::unlock(v4);
  return v10;
}

void LiMaterial::setTexture(os_unfair_lock_s *a1, uint64_t a2, uint64_t *a3, void *a4)
{
  unint64_t v7 = (void *)LiMaterial::obtainSamplerInfo(a1, *(const ProShade::SamplerNode **)(a2 + 16));

  LiMaterialSamplerInfo::set(v7, (const PCSharedCount *)a2, a3, a4);
}

void LiMaterialSamplerInfo::set(void *a1, const PCSharedCount *a2, uint64_t *a3, void *a4)
{
  ProShade::VarT<ProShade::Node>::operator=((uint64_t)a1, a2);
  ProShade::VarT<ProShade::Node>::operator=((uint64_t)(a1 + 4), a2 + 4);
  ProShade::VarT<ProShade::Node>::operator=((uint64_t)(a1 + 8), a2 + 8);
  uint64_t v9 = *a3;
  uint64_t v8 = a3[1];
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = (std::__shared_weak_count *)a1[19];
  a1[18] = v9;
  a1[19] = v8;
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  PCPtr<LiImageSource>::reset(a1 + 12);
  uint64_t v11 = a1 + 23;
  if (a1 + 23 != a4)
  {
    for (uint64_t i = 0; i != 4; ++i)
    {
      for (uint64_t j = 0; j != 4; ++j)
        v11[j] = a4[j];
      v11 += 4;
      a4 += 4;
    }
  }
}

void LiMaterial::setTexture(os_unfair_lock_s *a1, uint64_t a2, uint64_t *a3, char a4, uint64_t a5)
{
  uint64_t v9 = LiMaterial::obtainSamplerInfo(a1, *(const ProShade::SamplerNode **)(a2 + 16));

  LiMaterialSamplerInfo::set(v9, (const PCSharedCount *)a2, a3, a4, a5);
}

void LiMaterialSamplerInfo::set(uint64_t a1, const PCSharedCount *a2, uint64_t *a3, char a4, uint64_t a5)
{
  ProShade::VarT<ProShade::Node>::operator=(a1, a2);
  ProShade::VarT<ProShade::Node>::operator=(a1 + 32, a2 + 4);
  ProShade::VarT<ProShade::Node>::operator=(a1 + 64, a2 + 8);
  uint64_t v11 = *a3;
  uint64_t v10 = a3[1];
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 168);
  *(void *)(a1 + 160) = v11;
  *(void *)(a1 + 168) = v10;
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
  *(unsigned char *)(a1 + 176) = a4;
  PCPtr<LiImageSource>::reset((void *)(a1 + 96));
  uint64_t v13 = a1 + 184;
  if (a1 + 184 != a5)
  {
    for (uint64_t i = 0; i != 4; ++i)
    {
      for (uint64_t j = 0; j != 32; j += 8)
        *(void *)(v13 + j) = *(void *)(a5 + j);
      v13 += 32;
      a5 += 32;
    }
  }
}

void LiMaterial::setTexture(os_unfair_lock_s *a1, uint64_t a2, const PCSharedCount *a3, CGColorSpace *a4, _OWORD *a5, double a6)
{
  uint64_t v11 = LiMaterial::obtainSamplerInfo(a1, *(const ProShade::SamplerNode **)(a2 + 16));

  LiMaterialSamplerInfo::set(v11, (const PCSharedCount *)a2, a3, a4, a5, a6);
}

void LiMaterialSamplerInfo::set(uint64_t a1, const PCSharedCount *a2, const PCSharedCount *a3, CGColorSpace *a4, _OWORD *a5, double a6)
{
  ProShade::VarT<ProShade::Node>::operator=(a1, a2);
  ProShade::VarT<ProShade::Node>::operator=(a1 + 32, a2 + 4);
  ProShade::VarT<ProShade::Node>::operator=(a1 + 64, a2 + 8);
  *(PCSharedCount *)(a1 + 96) = (PCSharedCount)a3->var0;
  PCSharedCount::PCSharedCount((PCSharedCount *)&v14, a3 + 1);
  PCSharedCount::operator=((uint64_t *)(a1 + 104), (uint64_t *)&v14);
  PCSharedCount::~PCSharedCount((PCSharedCount *)&v14);
  PCColorSpaceHandle::setColorSpace((CGColorSpace **)(a1 + 112), a4);
  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)&v14);
  long long v12 = v14;
  long long v14 = 0uLL;
  uint64_t v13 = *(std::__shared_weak_count **)(a1 + 152);
  *(_OWORD *)(a1 + 144) = v12;
  if (v13)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
    if (*((void *)&v14 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v14 + 1));
    }
  }
  *(double *)(a1 + 136) = a6;
  if (a5) {
    *(_OWORD *)(a1 + 120) = *a5;
  }
}

void sub_1B7AA0278(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, PCSharedCount a9)
{
}

uint64_t *LiMaterial::getProgramCache(LiMaterial *this)
{
  {
    operator new();
  }
  if (LiMaterial::getProgramCache(void)::once != -1) {
    dispatch_once(&LiMaterial::getProgramCache(void)::once, &__block_literal_global_69);
  }
  return &LiMaterial::getProgramCache(void)::cache;
}

void sub_1B7AA0370(_Unwind_Exception *a1)
{
}

void ___ZN10LiMaterial15getProgramCacheEv_block_invoke()
{
}

void LiMaterial::getProgram(uint64_t a1@<X0>, LiContext *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (OZChannelBase *)(*(void *(**)(long long *__return_ptr))(*(void *)a1 + 168))(&v14);
  int isObjectRef = OZChannelBase::isObjectRef(v8);
  *(_DWORD *)uint64_t v16 = a3;
  int v17 = isObjectRef;
  PCHash128::addData((int8x8_t *)&v14, v16, 8uLL);
  LiContext::getHash(a2);
  PCHash128::operator+=((int *)&v14, v13);
  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)v13);
  *(_OWORD *)uint64_t v13 = v14;
  LiMaterial::getProgramCache(v10);
  LOBYTE(v11) = 0;
  PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::findValue(LiMaterial::getProgramCache(void)::cache, (const PCHash128 *)v13, &v11, (PCSharedCount *)a4);
  if (!*(void *)a4)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t, LiContext *))(*(void *)a1 + 176))(&v11, a1, a2);
    *(void *)a4 = v11;
    PCSharedCount::PCSharedCount(&v15, &v12);
    PCSharedCount::operator=((uint64_t *)(a4 + 8), (uint64_t *)&v15);
    PCSharedCount::~PCSharedCount(&v15);
    PCSharedCount::~PCSharedCount(&v12);
    PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::addValue(LiMaterial::getProgramCache(void)::cache, (const PCHash128 *)v13, (const PCSharedCount *)a4, 0);
  }
}

void sub_1B7AA0518(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, PCSharedCount a16)
{
  PCSharedCount::~PCSharedCount(v16 + 1);
  _Unwind_Resume(a1);
}

void LiMaterial::setUniforms(LiMaterial **this, const LiTextureCoordinator *a2)
{
  CurrentContextUniformDatSCNMatrix4 a = (__CFString **)ProShade::UniformData::getCurrentContextUniformData((ProShade::UniformData *)this);
  uint64_t v5 = (ProShade::UniformData *)CurrentContextUniformData;
  uint64_t v6 = *((unsigned int *)this + 147);
  if ((int)v6 >= 1)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 8;
    do
    {
      if (v7 >= *((int *)this + 147)) {
        PCArray_base::badIndex((PCArray_base *)CurrentContextUniformData);
      }
      CurrentContextUniformDatSCNMatrix4 a = ProShade::UniformData::set(v5, *(ProShade::UniformNode **)((char *)this[74] + v8 - 8), (const PCString *)((char *)this[74] + v8));
      ++v7;
      v8 += 152;
    }
    while (v6 != v7);
  }
  uint64_t v9 = this[75];
  if (v9 != (LiMaterial *)(this + 76))
  {
    do
    {
      uint64_t v10 = *((void *)v9 + 5);
      PCString v21 = *(LiImageSource **)(v10 + 96);
      PCSharedCount::PCSharedCount(&v22, (const PCSharedCount *)(v10 + 104));
      uint64_t v11 = LiTextureCoordinator::textureForImage(a2, v21);
      uint64_t v12 = v11;
      if (v11) {
        ProShade::Sampler::setWrapMode(v10, *(_DWORD *)(v11 + 24));
      }
      unsigned int v13 = LiMaterialSamplerInfo::textureID((LiMaterialSamplerInfo *)v10);
      int TextureID = v13;
      if (v12 && !v13) {
        int TextureID = LiMaterialTextureInfo::getTextureID((HGGLBlendingInfo **)v12);
      }
      if (TextureID)
      {
        ProShade::Sampler::setTexture((ProShade::Sampler *)v10, TextureID);
        ProShade::Sampler::setWrapMode(v10, *(_DWORD *)(v10 + 320));
        PCSharedCount v15 = (const void *)(v12 ? v12 + 32 : v10 + 184);
        ProShade::UniformData::set<PCMatrix44Tmpl<double>>(v5, v10 + 64, v15);
        unsigned int v16 = LiMaterialSamplerInfo::textureID((LiMaterialSamplerInfo *)v10);
        if (v12)
        {
          if (!v16)
          {
            float32x4_t v20 = vcvtq_f32_s32(*(int32x4_t *)(v12 + 160));
            ProShade::UniformData::set<PCVector4<float>>(v5, v10 + 32, (float32x2_t *)&v20);
          }
        }
      }
      PCSharedCount::~PCSharedCount(&v22);
      int v17 = (LiMaterial *)*((void *)v9 + 1);
      if (v17)
      {
        do
        {
          uint64_t v18 = v17;
          int v17 = *(LiMaterial **)v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          uint64_t v18 = (LiMaterial *)*((void *)v9 + 2);
          BOOL v19 = *(void *)v18 == (void)v9;
          uint64_t v9 = v18;
        }
        while (!v19);
      }
      uint64_t v9 = v18;
    }
    while (v18 != (LiMaterial *)(this + 76));
  }
}

void sub_1B7AA06FC(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1);
  _Unwind_Resume(a1);
}

HGGLBlendingInfo *LiMaterialSamplerInfo::textureID(LiMaterialSamplerInfo *this)
{
  LiMaterialSamplerInfo::getTexture(this, (PCWorkingColorVector *)&v3);
  GLuint Name = ProGL::TextureHandle::getName(&v3);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  return Name;
}

void sub_1B7AA0760(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

__CFString **ProShade::UniformData::set<PCMatrix44Tmpl<double>>(ProShade::UniformData *a1, uint64_t a2, const void *a3)
{
  v7[18] = *(PCString *)MEMORY[0x1E4F143B8];
  ProShade::Value::Value(v7);
  ProShade::Value::set((uint64_t)v7, (const PCString *)3, 7, a3);
  return ProShade::UniformData::set(a1, *(ProShade::UniformNode **)(a2 + 16), v7);
}

__CFString **ProShade::UniformData::set<PCVector4<float>>(ProShade::UniformData *a1, uint64_t a2, float32x2_t *a3)
{
  v9[18] = *(PCString *)MEMORY[0x1E4F143B8];
  ProShade::Value::Value(v9);
  float64x2_t v6 = vcvtq_f64_f32(a3[1]);
  v8[0] = vcvtq_f64_f32(*a3);
  v8[1] = v6;
  ProShade::Value::set((uint64_t)v9, (const PCString *)3, 4, v8);
  return ProShade::UniformData::set(a1, *(ProShade::UniformNode **)(a2 + 16), v9);
}

void LiMaterial::getSamplerInfos(uint64_t a1, char **a2)
{
  int v2 = *(void **)(a1 + 600);
  uint64_t v3 = (void *)(a1 + 608);
  if (v2 != (void *)(a1 + 608))
  {
    uint64_t v5 = a2 + 2;
    float64x2_t v6 = a2[1];
    do
    {
      uint64_t v7 = v2[5];
      if ((unint64_t)v6 >= *v5)
      {
        uint64_t v8 = (v6 - *a2) >> 3;
        if ((unint64_t)(v8 + 1) >> 61) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v9 = *v5 - (void)*a2;
        uint64_t v10 = v9 >> 2;
        if (v9 >> 2 <= (unint64_t)(v8 + 1)) {
          uint64_t v10 = v8 + 1;
        }
        if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v11 = v10;
        }
        if (v11) {
          uint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v5, v11);
        }
        else {
          uint64_t v12 = 0;
        }
        unsigned int v13 = &v12[8 * v8];
        *(void *)unsigned int v13 = v7;
        float64x2_t v6 = v13 + 8;
        PCSharedCount v15 = *a2;
        long long v14 = a2[1];
        if (v14 != *a2)
        {
          do
          {
            uint64_t v16 = *((void *)v14 - 1);
            v14 -= 8;
            *((void *)v13 - 1) = v16;
            v13 -= 8;
          }
          while (v14 != v15);
          long long v14 = *a2;
        }
        *a2 = v13;
        a2[1] = v6;
        a2[2] = &v12[8 * v11];
        if (v14) {
          operator delete(v14);
        }
      }
      else
      {
        *(void *)float64x2_t v6 = v7;
        v6 += 8;
      }
      a2[1] = v6;
      int v17 = (void *)v2[1];
      if (v17)
      {
        do
        {
          uint64_t v18 = v17;
          int v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          uint64_t v18 = (void *)v2[2];
          BOOL v19 = *v18 == (void)v2;
          int v2 = v18;
        }
        while (!v19);
      }
      int v2 = v18;
    }
    while (v18 != v3);
  }
}

double *LiMaterial::setAlpha(double *result, double a2, double a3, double a4)
{
  result[79] = a2;
  result[80] = a3;
  result[81] = a4;
  return result;
}

double LiMaterial::getAlpha(LiMaterial *this)
{
  return *((double *)this + 79);
}

uint64_t LiMaterial::parts(LiMaterial *this)
{
  return *((unsigned int *)this + 142);
}

uint64_t LiMaterial::setParts(uint64_t this, int a2)
{
  *(_DWORD *)(this + 568) = a2;
  return this;
}

void LiMaterial::setSamplerProperties()
{
  exception = (PCException *)__cxa_allocate_exception(0x40uLL);
  PCString::PCString(&v2, "subclass must implement");
  PCString::PCString(&v1, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/LiMaterial.h");
  PCException::PCException(exception, &v2, &v1, 328);
  *(void *)exception = &unk_1F10B1208;
}

void sub_1B7AA0AB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString((PCString *)&a9);
  PCString::~PCString(&a10);
  if (v11) {
    __cxa_free_exception(v10);
  }
  _Unwind_Resume(a1);
}

void LiMaterialSamplerInfo::~LiMaterialSamplerInfo(LiMaterialSamplerInfo *this)
{
  PCString v2 = (std::__shared_weak_count *)*((void *)this + 21);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 19);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  PCCFRef<CGColorSpace *>::~PCCFRef((CGColorSpace **)this + 14);
  PCSharedCount::~PCSharedCount((PCSharedCount *)this + 13);
  *(void *)this = &unk_1F1119908;
  *((void *)this + 8) = &unk_1F1119970;
  PCSharedCount::~PCSharedCount((PCSharedCount *)this + 11);
  *((void *)this + 4) = &unk_1F1119970;
  PCSharedCount::~PCSharedCount((PCSharedCount *)this + 7);
  *(void *)this = &unk_1F11199B0;
  PCSharedCount::~PCSharedCount((PCSharedCount *)this + 3);
}

uint64_t parseName(const LiString *a1)
{
  uint64_t v1 = *(void *)a1;
  if (*(void *)a1)
  {
    uint64_t v2 = *(unsigned int *)(v1 - 8);
    uint64_t v3 = v2 - 1;
    while (1)
    {
      BOOL v4 = __OFSUB__(v2, 1);
      LODWORD(v2) = v2 - 1;
      if ((int)v2 < 0 != v4) {
        break;
      }
      int v5 = *(unsigned __int8 *)(v1 + v3--);
      if (v5 == 95)
      {
        if ((v2 & 0x80000000) != 0) {
          return 0xFFFFFFFFLL;
        }
        LiString::from(a1, v2 + 1, (LiString *)&v11);
        float64x2_t v6 = v11;
        if (v11) {
          uint64_t v7 = v11;
        }
        else {
          uint64_t v7 = "";
        }
        uint64_t v8 = atoi(v7);
        if (v6 && atomic_fetch_add((atomic_uint *volatile)v6 - 3, 0xFFFFFFFF) == 1)
        {
          *int v11 = 0;
          if (v11) {
            uint64_t v9 = (char *)(v11 - 12);
          }
          else {
            uint64_t v9 = 0;
          }
          free(v9);
        }
        return v8;
      }
    }
  }
  return 0xFFFFFFFFLL;
}

void LiString::from(LiString *this@<X0>, int a2@<W1>, LiString *a3@<X8>)
{
  uint64_t v3 = *(void *)this;
  if (*(void *)this && (int v4 = *(_DWORD *)(v3 - 8), v4 > a2)) {
    LiString::LiString(a3, (const char *)(v3 + a2), v4 - a2);
  }
  else {
    *(void *)a3 = 0;
  }
}

void LiString::LiString(LiString *this, const char *a2, unsigned int a3)
{
  if ((int)a3 < 1)
  {
    *(void *)this = 0;
  }
  else
  {
    unsigned int v6 = a3 + 1;
    size_t v7 = a3;
    uint64_t v8 = (unsigned int *)malloc_type_malloc(a3 + 13, 0x8903763CuLL);
    _OWORD v8[2] = v6;
    atomic_store(1u, v8);
    *(void *)this = v8 + 3;
    v8[1] = a3;
    memcpy(v8 + 3, a2, v7);
    *(unsigned char *)(*(void *)this + a3) = 0;
  }
}

void LiMaterialSamplerInfo::LiMaterialSamplerInfo(LiMaterialSamplerInfo *this)
{
  uint64_t v2 = (PCSharedCount *)ProShade::Sampler::Sampler(this);
  v2[12].int var0 = 0;
  PCSharedCount::PCSharedCount(v2 + 13);
  *((void *)this + 14) = 0;
  PCWorkingColorVector::PCWorkingColorVector((LiMaterialSamplerInfo *)((char *)this + 120));
  *((void *)this + 17) = 0x3FF0000000000000;
  PCWorkingColorVector::PCWorkingColorVector((LiMaterialSamplerInfo *)((char *)this + 144));
  *((void *)this + 20) = 0;
  *((void *)this + 21) = 0;
  *((unsigned char *)this + 176) = 0;
  *((void *)this + 38) = 0x3FF0000000000000;
  *((void *)this + 33) = 0x3FF0000000000000;
  *((void *)this + 28) = 0x3FF0000000000000;
  *((void *)this + 23) = 0x3FF0000000000000;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((unsigned char *)this + 312) = 0;
  *((_DWORD *)this + 81) = 0;
  *(void *)((char *)this + 316) = 0;
  *((_WORD *)this + 164) = 257;
  *((_DWORD *)this + 83) = 0;
  *((_WORD *)this + 168) = 256;
  *((unsigned char *)this + 338) = 0;
}

void sub_1B7AA0DF8(_Unwind_Exception *a1)
{
  ProShade::Sampler::~Sampler(v1);
  _Unwind_Resume(a1);
}

void PCArray<LiMaterial::UniformValue,PCArray_Traits<LiMaterial::UniformValue>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111DB50;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<LiMaterial::UniformValue,PCArray_Traits<LiMaterial::UniformValue>>::resize((void *)a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

void *PCArray<LiMaterial::UniformValue,PCArray_Traits<LiMaterial::UniformValue>>::resize(void *result, int a2, int a3)
{
  if (a3 <= a2) {
    int v3 = a2;
  }
  else {
    int v3 = a3;
  }
  if (a2 < 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v17, "PCArray::resize");
    PCException::PCException(exception, &v17);
    *(void *)exception = &unk_1F1199218;
  }
  int v5 = result;
  if (v3 == *((_DWORD *)result + 2))
  {
    int v6 = *((_DWORD *)result + 3);
    if (a2 > v6)
    {
      uint64_t v7 = 152 * v6;
      int v8 = a2 - v6;
      do
      {
        uint64_t v9 = v5[2] + v7;
        *(void *)(v9 + 144) = 0;
        *(_OWORD *)(v9 + 112) = 0u;
        *(_OWORD *)(v9 + 128) = 0u;
        *(_OWORD *)(v9 + 80) = 0u;
        *(_OWORD *)(v9 + 96) = 0u;
        *(_OWORD *)(v9 + 48) = 0u;
        *(_OWORD *)(v9 + 64) = 0u;
        *(_OWORD *)(v9 + 16) = 0u;
        *(_OWORD *)(v9 + 32) = 0u;
        *(_OWORD *)uint64_t v9 = 0u;
        double result = ProShade::Value::Value((void *)(v9 + 8));
        v7 += 152;
        --v8;
      }
      while (v8);
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    int v10 = *((_DWORD *)result + 3);
    if (a2 >= v10) {
      int v11 = *((_DWORD *)result + 3);
    }
    else {
      int v11 = a2;
    }
    if (v11 < 1)
    {
      int v11 = 0;
    }
    else
    {
      uint64_t v12 = 0;
      do
      {
        unsigned int v13 = (PCString *)((char *)v12 + v5[2]);
        v12->int var0 = v13->var0;
        ProShade::Value::Value(v12 + 1, v13 + 1);
        v12 += 19;
      }
      while ((PCString *)(152 * v11) != v12);
      int v10 = *((_DWORD *)v5 + 3);
    }
    if (v11 > v10) {
      int v10 = v11;
    }
    if (v10 < a2)
    {
      long long v14 = (void *)(152 * v10 + 8);
      unint64_t v15 = a2 - (unint64_t)v10;
      do
      {
        v14[17] = 0;
        *(_OWORD *)(v14 + 15) = 0u;
        *(_OWORD *)(v14 + 13) = 0u;
        *(_OWORD *)(v14 + 11) = 0u;
        *(_OWORD *)(v14 + 9) = 0u;
        *(_OWORD *)(v14 + 7) = 0u;
        *(_OWORD *)(v14 + 5) = 0u;
        *(_OWORD *)(v14 + 3) = 0u;
        *(_OWORD *)(v14 + 1) = 0u;
        *(_OWORD *)(v14 - 1) = 0u;
        long long v14 = ProShade::Value::Value(v14) + 19;
        --v15;
      }
      while (v15);
    }
    double result = (void *)v5[2];
    if (result) {
      double result = (void *)MEMORY[0x1BA9BFB70](result, 0x1000C8077774924);
    }
    v5[2] = 0;
  }
  *((_DWORD *)v5 + 2) = v3;
  *((_DWORD *)v5 + 3) = a2;
  return result;
}

void sub_1B7AA10E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void PCArray<LiString,PCArray_Traits<LiString>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111DB88;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<LiString,PCArray_Traits<LiString>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

void PCArray<LiString,PCArray_Traits<LiString>>::resize(uint64_t a1, int a2, int a3)
{
  if (a3 <= a2) {
    int v3 = a2;
  }
  else {
    int v3 = a3;
  }
  if (a2 < 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v17, "PCArray::resize");
    PCException::PCException(exception, &v17);
    *(void *)exception = &unk_1F1199218;
  }
  if (v3 == *(_DWORD *)(a1 + 8))
  {
    uint64_t v6 = *(int *)(a1 + 12);
    if ((int)v6 <= a2)
    {
      if ((int)v6 < a2) {
        bzero((void *)(*(void *)(a1 + 16) + 8 * v6), 8 * (~v6 + a2) + 8);
      }
    }
    else
    {
      uint64_t v7 = 8 * a2;
      uint64_t v8 = a2;
      do
      {
        LiString::dec((LiString *)(*(void *)(a1 + 16) + v7));
        ++v8;
        v7 += 8;
      }
      while (v8 < *(int *)(a1 + 12));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    int v9 = *(_DWORD *)(a1 + 12);
    if (a2 >= v9) {
      int v10 = *(_DWORD *)(a1 + 12);
    }
    else {
      int v10 = a2;
    }
    if (v10 < 1)
    {
      int v10 = 0;
    }
    else
    {
      int v11 = 0;
      do
      {
        uint64_t v12 = *(void *)(a1 + 16);
        uint64_t v13 = *(void *)((char *)v11 + v12);
        *int v11 = v13;
        if (v13)
        {
          atomic_fetch_add((atomic_uint *volatile)(v13 - 12), 1u);
          uint64_t v12 = *(void *)(a1 + 16);
        }
        LiString::dec((LiString *)((char *)v11++ + v12));
      }
      while ((void *)(8 * v10) != v11);
      int v9 = *(_DWORD *)(a1 + 12);
    }
    if (v10 < v9)
    {
      uint64_t v14 = 8 * v10;
      do
      {
        LiString::dec((LiString *)(*(void *)(a1 + 16) + v14));
        v14 += 8;
        ++v10;
      }
      while (*(_DWORD *)(a1 + 12) > v10);
    }
    if (v10 < a2) {
      bzero((void *)(8 * v10), 8 * (~v10 + a2) + 8);
    }
    uint64_t v15 = *(void *)(a1 + 16);
    if (v15) {
      MEMORY[0x1BA9BFB70](v15, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = a2;
}

void sub_1B7AA13DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void std::__tree<std::__value_type<LiString,ProShade::Value>,std::__map_value_compare<LiString,std::__value_type<LiString,ProShade::Value>,std::less<LiString>,true>,std::allocator<std::__value_type<LiString,ProShade::Value>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<LiString,ProShade::Value>,std::__map_value_compare<LiString,std::__value_type<LiString,ProShade::Value>,std::less<LiString>,true>,std::allocator<std::__value_type<LiString,ProShade::Value>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<LiString,ProShade::Value>,std::__map_value_compare<LiString,std::__value_type<LiString,ProShade::Value>,std::less<LiString>,true>,std::allocator<std::__value_type<LiString,ProShade::Value>>>::destroy(a1, a2[1]);
    LiString::dec((LiString *)(a2 + 4));
    operator delete(a2);
  }
}

uint64_t *std::__tree<std::__value_type<LiString,ProShade::Value>,std::__map_value_compare<LiString,std::__value_type<LiString,ProShade::Value>,std::less<LiString>,true>,std::allocator<std::__value_type<LiString,ProShade::Value>>>::__emplace_unique_key_args<LiString,std::piecewise_construct_t const&,std::tuple<LiString const&>,std::tuple<>>(uint64_t **a1, const char **a2, uint64_t a3, uint64_t **a4)
{
  uint64_t v6 = (uint64_t **)std::__tree<LiString>::__find_equal<LiString>((uint64_t)a1, &v9, a2);
  double result = *v6;
  if (!*v6)
  {
    std::__tree<std::__value_type<LiString,ProShade::Value>,std::__map_value_compare<LiString,std::__value_type<LiString,ProShade::Value>,std::less<LiString>,true>,std::allocator<std::__value_type<LiString,ProShade::Value>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<LiString const&>,std::tuple<>>((uint64_t)a1, a4, (uint64_t)&v8);
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v9, v6, v8);
    return v8;
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<LiString,ProShade::Value>,std::__map_value_compare<LiString,std::__value_type<LiString,ProShade::Value>,std::less<LiString>,true>,std::allocator<std::__value_type<LiString,ProShade::Value>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<LiString const&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, uint64_t **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = (uint64_t *)operator new(0xB8uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  double result = std::pair<LiString const,ProShade::Value>::pair[abi:ne180100]<LiString const&>(v6 + 4, *a2);
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_1B7AA1584(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<LiString,ProShade::Value>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

uint64_t *std::pair<LiString const,ProShade::Value>::pair[abi:ne180100]<LiString const&>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *a1 = *a2;
  if (v3) {
    atomic_fetch_add((atomic_uint *volatile)(v3 - 12), 1u);
  }
  ProShade::Value::Value(a1 + 1);
  return a1;
}

void sub_1B7AA15E4(_Unwind_Exception *a1)
{
  LiString::dec(v1);
  _Unwind_Resume(a1);
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<LiString,ProShade::Value>,void *>>>::operator()[abi:ne180100](uint64_t a1, char *__p)
{
  if (*(unsigned char *)(a1 + 8)) {
    LiString::dec((LiString *)(__p + 32));
  }
  if (__p)
  {
    operator delete(__p);
  }
}

uint64_t *std::__tree<std::__value_type<ProShade::SamplerNode const*,LiMaterialSamplerInfo *>,std::__map_value_compare<ProShade::SamplerNode const*,std::__value_type<ProShade::SamplerNode const*,LiMaterialSamplerInfo *>,std::less<ProShade::SamplerNode const*>,true>,std::allocator<std::__value_type<ProShade::SamplerNode const*,LiMaterialSamplerInfo *>>>::__emplace_unique_key_args<ProShade::SamplerNode const*,std::piecewise_construct_t const&,std::tuple<ProShade::SamplerNode const* const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  uint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    int v11 = (uint64_t *)operator new(0x30uLL);
    double v11[4] = **a4;
    v11[5] = 0;
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

void PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::setMaxSize(void *a1, uint64_t a2)
{
  a1[12] = a2;
  if (!a1[13])
  {
    uint64_t v3 = a1 + 6;
    int v4 = (uint64_t **)(a1 + 3);
    while (a1[10] > a1[11] || a1[5] > a1[12])
    {
      uint64_t v5 = (uint64_t *)a1[6];
      if (v5 == (uint64_t *)a1[7]) {
        break;
      }
      uint64_t v7 = *v5;
      PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::__tree_node<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,void *> *,long>>>::remove(v3, (uint64_t)&v7);
      uint64_t v6 = v7;
      a1[10] -= *(void *)(v7 + 64);
      std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer(v4, (uint64_t *)v6);
      PCSharedCount::~PCSharedCount((PCSharedCount *)(v6 + 56));
      operator delete((void *)v6);
    }
  }
}

void PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::__tree_node<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,void *> *,long>>>::remove(uint64_t *a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(*(void *)a2 + 80);
  unint64_t v4 = ((a1[1] - *a1) >> 3) - 1;
  if (v3 == v4)
  {
    std::vector<std::__map_iterator<std::__tree_iterator<std::__value_type<ColorConversionKey,PCCacheImpl<ColorConversionKey,std::shared_ptr<PCWorkingColor>,PCNoLock,std::less<ColorConversionKey>>::Data>,std::__tree_node<std::__value_type<ColorConversionKey,PCCacheImpl<ColorConversionKey,std::shared_ptr<PCWorkingColor>,PCNoLock,std::less<ColorConversionKey>>::Data>,void *> *,long>>>::resize((uint64_t)a1, v3);
  }
  else
  {
    *(void *)(*a1 + 8 * v3) = *(void *)(*a1 + 8 * v4);
    *(void *)(*(void *)(*a1 + 8 * v3) + 80) = v3;
    std::vector<std::__map_iterator<std::__tree_iterator<std::__value_type<ColorConversionKey,PCCacheImpl<ColorConversionKey,std::shared_ptr<PCWorkingColor>,PCNoLock,std::less<ColorConversionKey>>::Data>,std::__tree_node<std::__value_type<ColorConversionKey,PCCacheImpl<ColorConversionKey,std::shared_ptr<PCWorkingColor>,PCNoLock,std::less<ColorConversionKey>>::Data>,void *> *,long>>>::resize((uint64_t)a1, v4);
    uint64_t v5 = *a1 + 8 * v3;
    PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::__tree_node<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,void *> *,long>>>::bubble(a1, v5);
  }
}

uint64_t *PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::__tree_node<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,void *> *,long>>>::bubble(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1] - *result;
  unint64_t v4 = *(void *)(*(void *)a2 + 80);
  unint64_t v5 = (2 * v4) | 1;
  if (v5 >= v3 >> 3)
  {
LABEL_24:
    if (v4)
    {
      uint64_t v17 = *(void *)(v2 + 8 * v4);
      do
      {
        unint64_t v18 = v4 - 1;
        unint64_t v19 = (v4 - 1) >> 1;
        uint64_t v20 = *(void *)(v2 + 8 * v19);
        if (*(void *)(v20 + 72) <= *(void *)(v17 + 72)) {
          break;
        }
        *(void *)(v2 + 8 * v4) = v20;
        *(void *)(v2 + 8 * v19) = v17;
        uint64_t v2 = *result;
        *(void *)(*(void *)(*result + 8 * v4) + 80) = v4;
        uint64_t v17 = *(void *)(v2 + 8 * v19);
        *(void *)(v17 + 80) = v19;
        unint64_t v4 = (v4 - 1) >> 1;
      }
      while (v18 > 1);
    }
    return result;
  }
  char v6 = 0;
  unint64_t v7 = v3 >> 3;
  uint64_t v8 = 2 * v4;
  uint64_t v9 = *(void *)(v2 + 8 * v4);
  while (1)
  {
    unint64_t v10 = v8 + 2;
    unint64_t v11 = *(void *)(v9 + 72);
    BOOL v12 = v10 < v7 && v11 > *(void *)(*(void *)(v2 + 8 * v10) + 72);
    unint64_t v13 = *(void *)(*(void *)(v2 + 8 * v5) + 72);
    if (v11 <= v13 && !v12) {
      break;
    }
    BOOL v15 = v11 > v13 && v12;
    if (v12) {
      unint64_t v16 = v10;
    }
    else {
      unint64_t v16 = v5;
    }
    if (v15)
    {
      if (v13 <= *(void *)(*(void *)(v2 + 8 * v10) + 72)) {
        unint64_t v16 = v5;
      }
      else {
        unint64_t v16 = v10;
      }
    }
    *(void *)(v2 + 8 * v4) = *(void *)(v2 + 8 * v16);
    *(void *)(v2 + 8 * v16) = v9;
    uint64_t v2 = *result;
    *(void *)(*(void *)(*result + 8 * v4) + 80) = v4;
    uint64_t v9 = *(void *)(v2 + 8 * v16);
    *(void *)(v9 + 80) = v16;
    uint64_t v8 = 2 * v16;
    char v6 = 1;
    unint64_t v5 = (2 * v16) | 1;
    unint64_t v4 = v16;
    if (v5 >= v7) {
      return result;
    }
  }
  if ((v6 & 1) == 0)
  {
    unint64_t v4 = *(void *)(*(void *)a2 + 80);
    goto LABEL_24;
  }
  return result;
}

uint64_t *PCCache<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::~PCCache(uint64_t *a1)
{
  uint64_t v2 = *a1 + 32;
  std::__tree<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::__map_value_compare<LiMaterial::ShaderKey,std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::less<LiMaterial::ShaderKey>,true>,std::allocator<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>>>::destroy(*a1 + 24, *(PCSharedCount **)v2);
  *(void *)(v2 - 8) = v2;
  *(void *)uint64_t v2 = 0;
  *(void *)(v2 + 8) = 0;
  *(void *)(v2 + 24) = *(void *)(v2 + 16);
  *(void *)(v2 + 48) = 0;
  std::unique_ptr<PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>>::reset[abi:ne180100](a1, 0);
  return a1;
}

void std::__tree<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::__map_value_compare<LiMaterial::ShaderKey,std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::less<LiMaterial::ShaderKey>,true>,std::allocator<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>>>::destroy(uint64_t a1, PCSharedCount *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::__map_value_compare<LiMaterial::ShaderKey,std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::less<LiMaterial::ShaderKey>,true>,std::allocator<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>>>::destroy(a1, a2->var0);
    std::__tree<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::__map_value_compare<LiMaterial::ShaderKey,std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::less<LiMaterial::ShaderKey>,true>,std::allocator<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>>>::destroy(a1, a2[1].var0);
    PCSharedCount::~PCSharedCount(a2 + 7);
    operator delete(a2);
  }
}

uint64_t std::unique_ptr<PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::~PCCacheImpl(result);
    JUMPOUT(0x1BA9BFBA0);
  }
  return result;
}

uint64_t PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::~PCCacheImpl(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + LiDepthSorter::stackSort((uint64_t)this + 56) = v2;
    operator delete(v2);
  }
  std::__tree<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::__map_value_compare<LiMaterial::ShaderKey,std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::less<LiMaterial::ShaderKey>,true>,std::allocator<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>>>::destroy(a1 + 24, *(PCSharedCount **)(a1 + 32));
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::findValue(uint64_t a1@<X0>, const PCHash128 *a2@<X1>, unsigned char *a3@<X2>, PCSharedCount *a4@<X8>)
{
  unint64_t v7 = (const PCSharedCount *)std::__tree<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::__map_value_compare<LiMaterial::ShaderKey,std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::less<LiMaterial::ShaderKey>,true>,std::allocator<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>>>::find<LiMaterial::ShaderKey>(a1 + 24, a2);
  unint64_t v10 = v7;
  if ((const PCSharedCount *)(a1 + 32) == v7)
  {
    *a3 = 0;
    a4->int var0 = 0;
    PCSharedCount::PCSharedCount(a4 + 1);
  }
  else
  {
    uint64_t v8 = v7;
    a4->int var0 = v7[6].var0;
    PCSharedCount::PCSharedCount(a4 + 1, v7 + 7);
    uint64_t v9 = *(void *)(a1 + 72) + 1;
    *(void *)(a1 + 72) = v9;
    v8[9].int var0 = (PC_Sp_counted_base *)v9;
    PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::__tree_node<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,void *> *,long>>>::bubble((uint64_t *)(a1 + 48), (uint64_t)&v10);
    *a3 = 1;
  }
}

void sub_1B7AA1B9C(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1);
  _Unwind_Resume(a1);
}

void *std::__tree<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::__map_value_compare<LiMaterial::ShaderKey,std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::less<LiMaterial::ShaderKey>,true>,std::allocator<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>>>::find<LiMaterial::ShaderKey>(uint64_t a1, const PCHash128 *a2)
{
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  unint64_t v5 = (void *)(a1 + 8);
  do
  {
    int v6 = LiMaterial::ShaderKey::compare((const PCHash128 *)(v3 + 4), a2);
    unint64_t v7 = v3 + 1;
    if (v6 != -1)
    {
      unint64_t v7 = v3;
      unint64_t v5 = v3;
    }
    uint64_t v3 = (void *)*v7;
  }
  while (*v7);
  if (v5 == v2 || LiMaterial::ShaderKey::compare(a2, (const PCHash128 *)(v5 + 4)) == -1) {
    return v2;
  }
  return v5;
}

uint64_t LiMaterial::ShaderKey::compare(const PCHash128 *a1, const PCHash128 *a2)
{
  if (operator<(a1, a2)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return operator>(a1, a2);
  }
}

void PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::addValue(uint64_t a1, const PCHash128 *a2, const PCSharedCount *a3, unint64_t a4)
{
  if (*(void *)(a1 + 88) >= a4 || *(void *)(a1 + 104))
  {
    uint64_t v8 = std::__tree<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::__map_value_compare<LiMaterial::ShaderKey,std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::less<LiMaterial::ShaderKey>,true>,std::allocator<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>>>::find<LiMaterial::ShaderKey>(a1 + 24, a2);
    uint64_t v25 = v8;
    if ((void *)(a1 + 32) == v8)
    {
      uint64_t v10 = *(void *)(a1 + 72) + 1;
      *(void *)(a1 + 72) = v10;
      int var0 = a3->var0;
      PCSharedCount::PCSharedCount(&v22, a3 + 1);
      *(void *)&long long v23 = a4;
      *((void *)&v23 + 1) = v10;
      uint64_t v24 = 0;
      long long v15 = *(_OWORD *)a2;
      unint64_t v16 = var0;
      PCSharedCount::PCSharedCount(&v17, &v22);
      long long v18 = v23;
      uint64_t v19 = v24;
      v20[0] = (uint64_t)std::__tree<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::__map_value_compare<LiMaterial::ShaderKey,std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::less<LiMaterial::ShaderKey>,true>,std::allocator<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>>>::__emplace_unique_key_args<LiMaterial::ShaderKey,std::pair<LiMaterial::ShaderKey const,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>>((uint64_t **)(a1 + 24), (const PCHash128 *)&v15, (uint64_t)&v15);
      v20[1] = v11;
      PCSharedCount::~PCSharedCount(&v17);
      PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::__tree_node<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,void *> *,long>>>::add((void **)(a1 + 48), v20);
      unint64_t v12 = *(void *)(a1 + 80) + a4;
      *(void *)(a1 + 80) = v12;
      if (!*(void *)(a1 + 104))
      {
        while (v12 > *(void *)(a1 + 88) || *(void *)(a1 + 40) > *(void *)(a1 + 96))
        {
          uint64_t v14 = *(void **)(a1 + 48);
          if (v14 == *(void **)(a1 + 56)) {
            break;
          }
          *(void *)&long long v15 = *v14;
          PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::__tree_node<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,void *> *,long>>>::remove((uint64_t *)(a1 + 48), (uint64_t)&v15);
          uint64_t v13 = v15;
          *(void *)(a1 + 80) -= *(void *)(v15 + 64);
          std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer((uint64_t **)(a1 + 24), (uint64_t *)v13);
          PCSharedCount::~PCSharedCount((PCSharedCount *)(v13 + 56));
          operator delete((void *)v13);
          unint64_t v12 = *(void *)(a1 + 80);
        }
      }
      PCSharedCount::~PCSharedCount(&v22);
    }
    else
    {
      v8[6] = a3->var0;
      uint64_t v9 = v8 + 7;
      PCSharedCount::PCSharedCount((PCSharedCount *)&v15, a3 + 1);
      PCSharedCount::operator=(v9, (uint64_t *)&v15);
      PCSharedCount::~PCSharedCount((PCSharedCount *)&v15);
      PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::update(a1, (uint64_t)&v25, a4);
    }
  }
}

void sub_1B7AA1E58(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1);
  _Unwind_Resume(a1);
}

void PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::__tree_node<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,void *> *,long>>>::add(void **a1, uint64_t *a2)
{
  unint64_t v4 = (char *)*a1;
  unint64_t v5 = a1[1];
  uint64_t v6 = ((char *)v5 - (unsigned char *)*a1) >> 3;
  uint64_t v7 = *a2;
  *(void *)(*a2 + 80) = v6;
  unint64_t v10 = (unint64_t)a1[2];
  uint64_t v8 = (uint64_t)(a1 + 2);
  unint64_t v9 = v10;
  if ((unint64_t)v5 >= v10)
  {
    if ((unint64_t)(v6 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v9 - (void)v4;
    uint64_t v13 = v12 >> 2;
    if (v12 >> 2 <= (unint64_t)(v6 + 1)) {
      uint64_t v13 = v6 + 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v13;
    }
    if (v14)
    {
      long long v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v8, v14);
      uint64_t v7 = *a2;
    }
    else
    {
      long long v15 = 0;
    }
    unint64_t v16 = &v15[8 * v6];
    PCSharedCount v17 = &v15[8 * v14];
    *(void *)unint64_t v16 = v7;
    unsigned __int8 v11 = v16 + 8;
    uint64_t v19 = (char *)*a1;
    long long v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        uint64_t v20 = *((void *)v18 - 1);
        v18 -= 8;
        *((void *)v16 - 1) = v20;
        v16 -= 8;
      }
      while (v18 != v19);
      long long v18 = (char *)*a1;
    }
    *a1 = v16;
    a1[1] = v11;
    a1[2] = v17;
    if (v18) {
      operator delete(v18);
    }
  }
  else
  {
    void *v5 = v7;
    unsigned __int8 v11 = v5 + 1;
  }
  a1[1] = v11;
  unint64_t v21 = *(void *)(*a2 + 80);
  if (v21)
  {
    PCSharedCount v22 = (char *)*a1;
    uint64_t v23 = *((void *)*a1 + v21);
    do
    {
      unint64_t v24 = v21 - 1;
      unint64_t v25 = (v21 - 1) >> 1;
      uint64_t v26 = *(void *)&v22[8 * v25];
      if (*(void *)(v26 + 72) <= *(void *)(v23 + 72)) {
        break;
      }
      *(void *)&v22[8 * v21] = v26;
      *(void *)&v22[8 * v25] = v23;
      PCSharedCount v22 = (char *)*a1;
      *(void *)(*((void *)*a1 + v21) + 80) = v21;
      uint64_t v23 = *(void *)&v22[8 * v25];
      *(void *)(v23 + 80) = v25;
      unint64_t v21 = (v21 - 1) >> 1;
    }
    while (v24 > 1);
  }
}

void PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::update(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 72) + 1;
  *(void *)(a1 + 72) = v6;
  *(void *)(*(void *)a2 + 72) = v6;
  uint64_t v7 = (uint64_t *)(a1 + 48);
  PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::__tree_node<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,void *> *,long>>>::bubble((uint64_t *)(a1 + 48), a2);
  uint64_t v8 = *(void *)a2;
  uint64_t v9 = a3 - *(void *)(*(void *)a2 + 64);
  if (v9)
  {
    unint64_t v10 = v9 + *(void *)(a1 + 80);
    *(void *)(a1 + 80) = v10;
    *(void *)(v8 + 64) = a3;
    if (!*(void *)(a1 + 104))
    {
      while (v10 > *(void *)(a1 + 88) || *(void *)(a1 + 40) > *(void *)(a1 + 96))
      {
        unsigned __int8 v11 = *(uint64_t **)(a1 + 48);
        if (v11 == *(uint64_t **)(a1 + 56)) {
          break;
        }
        uint64_t v13 = *v11;
        PCEvictionHeap<std::__map_iterator<std::__tree_iterator<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::__tree_node<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,void *> *,long>>>::remove(v7, (uint64_t)&v13);
        uint64_t v12 = v13;
        *(void *)(a1 + 80) -= *(void *)(v13 + 64);
        std::__tree<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,PVInstructionGraphNode * {__strong}>>>::__remove_node_pointer((uint64_t **)(a1 + 24), (uint64_t *)v12);
        PCSharedCount::~PCSharedCount((PCSharedCount *)(v12 + 56));
        operator delete((void *)v12);
        unint64_t v10 = *(void *)(a1 + 80);
      }
    }
  }
}

uint64_t *std::__tree<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::__map_value_compare<LiMaterial::ShaderKey,std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::less<LiMaterial::ShaderKey>,true>,std::allocator<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>>>::__emplace_unique_key_args<LiMaterial::ShaderKey,std::pair<LiMaterial::ShaderKey const,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>>(uint64_t **a1, const PCHash128 *a2, uint64_t a3)
{
  unint64_t v5 = (uint64_t **)std::__tree<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::__map_value_compare<LiMaterial::ShaderKey,std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::less<LiMaterial::ShaderKey>,true>,std::allocator<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>>>::__find_equal<LiMaterial::ShaderKey>((uint64_t)a1, &v10, a2);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    uint64_t v7 = v5;
    std::__tree<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::__map_value_compare<LiMaterial::ShaderKey,std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::less<LiMaterial::ShaderKey>,true>,std::allocator<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>>>::__construct_node<std::pair<LiMaterial::ShaderKey const,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>>((uint64_t)a1, a3, (uint64_t)v9);
    std::__tree<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::__map_value_compare<PVIGHGNodeCacheKey,std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>,std::less<PVIGHGNodeCacheKey>,true>,std::allocator<std::__value_type<PVIGHGNodeCacheKey,HGRef<HGNode>>>>::__insert_node_at(a1, v10, v7, v9[0]);
    uint64_t v6 = v9[0];
    v9[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,void *>>>>::reset[abi:ne180100]((uint64_t)v9, 0);
  }
  return v6;
}

void *std::__tree<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::__map_value_compare<LiMaterial::ShaderKey,std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::less<LiMaterial::ShaderKey>,true>,std::allocator<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>>>::__find_equal<LiMaterial::ShaderKey>(uint64_t a1, void *a2, const PCHash128 *a3)
{
  unint64_t v5 = (void *)(a1 + 8);
  unint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v7 = v4;
        uint64_t v8 = (const PCHash128 *)(v4 + 4);
        if (LiMaterial::ShaderKey::compare(a3, (const PCHash128 *)(v4 + 4)) != -1) {
          break;
        }
        unint64_t v4 = (void *)*v7;
        unint64_t v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (LiMaterial::ShaderKey::compare(v8, a3) != -1) {
        break;
      }
      unint64_t v5 = v7 + 1;
      unint64_t v4 = (void *)v7[1];
    }
    while (v4);
  }
  else
  {
    uint64_t v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

__n128 std::__tree<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::__map_value_compare<LiMaterial::ShaderKey,std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,std::less<LiMaterial::ShaderKey>,true>,std::allocator<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>>>::__construct_node<std::pair<LiMaterial::ShaderKey const,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>>@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = operator new(0x58uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  *((_OWORD *)v6 + 2) = *(_OWORD *)a2;
  *((void *)v6 + 6) = *(void *)(a2 + 16);
  PCSharedCount::PCSharedCount((PCSharedCount *)v6 + 7, (const PCSharedCount *)(a2 + 24));
  __n128 result = *(__n128 *)(a2 + 32);
  *((__n128 *)v6 + 4) = result;
  *((void *)v6 + 10) = *(void *)(a2 + 48);
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_1B7AA2270(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__tree_node<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__tree_node<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<LiMaterial::ShaderKey,PCCacheImpl<LiMaterial::ShaderKey,PCPtr<ProShade::Program>,PCNoLock,std::less<LiMaterial::ShaderKey>>::Data>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(PCSharedCount **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      PCSharedCount::~PCSharedCount(v2 + 7);
    }
    operator delete(v2);
  }
}

void LiImageSource::LiImageSource(LiImageSource *this, uint64_t *a2)
{
  uint64_t v2 = a2[1];
  *(void *)this = v2;
  *(void *)((char *)this + *(void *)(v2 - 24)) = a2[2];
  uint64_t v3 = *a2;
  *(void *)this = *a2;
  *(void *)((char *)this + *(void *)(v3 - 24)) = a2[3];
  *((unsigned char *)this + 12) = 0;
  *((_DWORD *)this + 2) = 0;
}

void LiImageSource::clone(LiImageSource *this)
{
  exception = (PCException *)__cxa_allocate_exception(0x40uLL);
  PCString::PCString(&v3, "subclass must implement");
  PCString::PCString(&v2, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/LiImageSource.cpp");
  PCException::PCException(exception, &v3, &v2, 34);
  *(void *)exception = &unk_1F10B1208;
}

void sub_1B7AA249C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString((PCString *)&a9);
  PCString::~PCString(&a10);
  if (v11) {
    __cxa_free_exception(v10);
  }
  _Unwind_Resume(a1);
}

uint64_t LiImageSource::getBoundary()
{
  return 0;
}

uint64_t LiImageSource::filteredEdges(LiImageSource *this)
{
  return 0;
}

{
  return (*(uint64_t (**)(void))(*(void *)this + 32))();
}

void LiImageSource::repr(LiImageSource *this@<X0>, LiString *a2@<X8>)
{
  if (!this) {
    __cxa_bad_typeid();
  }
  PCString v2 = (const char *)(*(void *)(*(void *)(*(void *)this - 8) + 8) & 0x7FFFFFFFFFFFFFFFLL);

  LiString::LiString(a2, v2);
}

void *LiImageSource::printIndent(void *result, int a2)
{
  if (a2)
  {
    int v2 = a2;
    PCString v3 = result;
    do
    {
      --v2;
      __n128 result = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, (uint64_t)"  ", 2);
    }
    while (v2);
  }
  return result;
}

uint64_t LiImageSource::print(void *a1, void *a2, int a3)
{
  if (a3)
  {
    int v5 = a3;
    do
    {
      --v5;
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"  ", 2);
    }
    while (v5);
  }
  if (!a1) {
    __cxa_bad_typeid();
  }
  uint64_t v6 = (const char *)(*(void *)(*(void *)(*a1 - 8) + 8) & 0x7FFFFFFFFFFFFFFFLL);
  size_t v7 = strlen(v6);
  uint64_t v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)v6, v7);
  std::ios_base::getloc((const std::ios_base *)((char *)v8 + *(void *)(*v8 - 24)));
  uint64_t v9 = std::locale::use_facet(&v11, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 10);
  std::locale::~locale(&v11);
  std::ostream::put();
  return std::ostream::flush();
}

void sub_1B7AA26C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

uint64_t LiImageSource::fixSourcePixelTransform(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

double LiImageSource::fixPixelTransform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  switch((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 56))(a1, a4))
  {
    case 0u:
      *(void *)(a3 + 120) = 0x3FF0000000000000;
      *(void *)(a3 + 80) = 0x3FF0000000000000;
      *(void *)(a3 + 40) = 0x3FF0000000000000;
      *(void *)a3 = 0x3FF0000000000000;
      double result = 0.0;
      *(_OWORD *)(a3 + 8) = 0u;
      *(_OWORD *)(a3 + 24) = 0u;
      *(_OWORD *)(a3 + 48) = 0u;
      *(_OWORD *)(a3 + 64) = 0u;
      *(_OWORD *)(a3 + 88) = 0u;
      *(_OWORD *)(a3 + 104) = 0u;
      break;
    case 1u:
      double v10 = 0.0;
      double v11 = 0.0;
      uint64_t v12 = 0;
      float64x2_t v8 = 0uLL;
      double v9 = 0.0;
      getScaleTranslate((float64x2_t *)a3, (uint64_t)&v10, &v8);
      uint64_t v12 = 0x3FF0000000000000;
      *(void *)(a3 + 120) = 0x3FF0000000000000;
      *(void *)(a3 + 80) = 0x3FF0000000000000;
      *(void *)(a3 + 40) = 0x3FF0000000000000;
      *(void *)a3 = 0x3FF0000000000000;
      *(_OWORD *)(a3 + 8) = 0u;
      *(_OWORD *)(a3 + 24) = 0u;
      *(_OWORD *)(a3 + 48) = 0u;
      *(_OWORD *)(a3 + 64) = 0u;
      *(_OWORD *)(a3 + 88) = 0u;
      *(_OWORD *)(a3 + 104) = 0u;
      *(void *)&double result = *(_OWORD *)&PCMatrix44Tmpl<double>::leftScale((float64x2_t *)a3, v10, v11, 1.0);
      break;
    case 2u:
    case 3u:
      double v10 = 0.0;
      double v11 = 0.0;
      uint64_t v12 = 0;
      float64x2_t v8 = 0uLL;
      double v9 = 0.0;
      getScaleTranslateFlip((float64x2_t *)a3, (uint64_t)&v10, &v8);
      uint64_t v12 = 0x3FF0000000000000;
      *(void *)(a3 + 120) = 0x3FF0000000000000;
      *(void *)(a3 + 80) = 0x3FF0000000000000;
      *(void *)(a3 + 40) = 0x3FF0000000000000;
      *(void *)a3 = 0x3FF0000000000000;
      *(_OWORD *)(a3 + 8) = 0u;
      *(_OWORD *)(a3 + 24) = 0u;
      *(_OWORD *)(a3 + 48) = 0u;
      *(_OWORD *)(a3 + 64) = 0u;
      *(_OWORD *)(a3 + 88) = 0u;
      *(_OWORD *)(a3 + 104) = 0u;
      float64x2_t v6 = PCMatrix44Tmpl<double>::leftScale((float64x2_t *)a3, v10, v11, 1.0);
      goto LABEL_7;
    case 4u:
      double v10 = 0.0;
      double v11 = 0.0;
      uint64_t v12 = 0;
      float64x2_t v8 = 0uLL;
      double v9 = 0.0;
      double v7 = 0.0;
      getScaleTranslateRotate((float64x2_t *)a3, (uint64_t)&v10, &v8, &v7);
      uint64_t v12 = 0x3FF0000000000000;
      double v9 = 0.0;
      *(void *)(a3 + 120) = 0x3FF0000000000000;
      *(void *)(a3 + 80) = 0x3FF0000000000000;
      *(void *)(a3 + 40) = 0x3FF0000000000000;
      *(void *)a3 = 0x3FF0000000000000;
      *(_OWORD *)(a3 + 8) = 0u;
      *(_OWORD *)(a3 + 24) = 0u;
      *(_OWORD *)(a3 + 48) = 0u;
      *(_OWORD *)(a3 + 64) = 0u;
      *(_OWORD *)(a3 + 88) = 0u;
      *(_OWORD *)(a3 + 104) = 0u;
      PCMatrix44Tmpl<double>::leftScale((float64x2_t *)a3, v10, v11, 1.0);
      PCMatrix44Tmpl<double>::leftRotate((double *)a3, 4, 0.0, 0.0, v7);
LABEL_7:
      v6.f64[0] = v8.f64[0];
      *(void *)&double result = *(_OWORD *)&PCMatrix44Tmpl<double>::leftTranslate((float64x2_t *)a3, v6, v8.f64[1], v9);
      break;
    case 5u:
      double v10 = 0.0;
      double v11 = 0.0;
      uint64_t v12 = 0;
      *(void *)&double result = *(_OWORD *)&perspectiveToAffine((float64x2_t *)a3, &v10, (double *)a3);
      break;
    default:
      return result;
  }
  return result;
}

void PCMatrix44Tmpl<double>::leftRotate(double *a1, int a2, double a3, double a4, double a5)
{
  switch(a2)
  {
    case 0:
      PCMatrix44Tmpl<double>::leftRotate(a1, 0, a3);
      double v9 = a1;
      double v10 = a4;
      int v11 = 1;
      goto LABEL_5;
    case 1:
      PCMatrix44Tmpl<double>::leftRotate(a1, 0, a3);
      uint64_t v12 = a1;
      double v13 = a5;
      int v14 = 2;
      goto LABEL_8;
    case 2:
      PCMatrix44Tmpl<double>::leftRotate(a1, 1, a4);
      double v9 = a1;
      double v10 = a3;
      int v11 = 0;
LABEL_5:
      PCMatrix44Tmpl<double>::leftRotate(v9, v11, v10);
      long long v15 = a1;
      double v16 = a5;
      int v17 = 2;
      goto LABEL_11;
    case 3:
      PCMatrix44Tmpl<double>::leftRotate(a1, 1, a4);
      long long v18 = a1;
      double v19 = a5;
      int v20 = 2;
      goto LABEL_10;
    case 4:
      PCMatrix44Tmpl<double>::leftRotate(a1, 2, a5);
      uint64_t v12 = a1;
      double v13 = a3;
      int v14 = 0;
LABEL_8:
      PCMatrix44Tmpl<double>::leftRotate(v12, v14, v13);
      long long v15 = a1;
      double v16 = a4;
      int v17 = 1;
      goto LABEL_11;
    case 5:
      PCMatrix44Tmpl<double>::leftRotate(a1, 2, a5);
      long long v18 = a1;
      double v19 = a4;
      int v20 = 1;
LABEL_10:
      PCMatrix44Tmpl<double>::leftRotate(v18, v20, v19);
      long long v15 = a1;
      double v16 = a3;
      int v17 = 0;
LABEL_11:
      PCMatrix44Tmpl<double>::leftRotate(v15, v17, v16);
      break;
    default:
      return;
  }
}

uint64_t LiImageSource::inheritUseSourcePixelSpace(LiImageSource *this)
{
  return 0;
}

uint64_t LiImageSource::supportsHeliumCPURendering(LiImageSource *this)
{
  return 1;
}

uint64_t LiImageSource::getHeliumPublic(LiImageSource *this, LiAgent *a2)
{
  return (*(uint64_t (**)(LiImageSource *, LiAgent *))(*(void *)this + 160))(this, a2);
}

uint64_t LiImageSource::handlesDepthOfField(LiImageSource *this)
{
  return 0;
}

uint64_t LiImageFilter::inheritUseSourcePixelSpace(LiImageFilter *this)
{
  return 1;
}

uint64_t LiImageFilter::applyInFilmSpace(LiImageFilter *this)
{
  return 1;
}

uint64_t LiImageFilter::estimateRenderMemory(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 112))();
  }
  return result;
}

void *LiImageFilter::print(uint64_t a1, void *a2, int a3)
{
  if (a3)
  {
    int v5 = a3;
    do
    {
      --v5;
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"  ", 2);
    }
    while (v5);
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"LiImageFilter Image source:", 27);
  if (*(void *)(a1 + 16))
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"\n", 1);
    uint64_t v6 = *(void *)(a1 + 16);
    if (!v6) {
      throw_PCNullPointerException(1);
    }
    double v7 = *(uint64_t (**)(void))(*(void *)v6 + 128);
    return (void *)v7();
  }
  else
  {
    return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)" NULL\n", 6);
  }
}

void LiImageFilter::materialFilter(PCSharedCount *a1@<X8>)
{
  a1->int var0 = 0;
  PCSharedCount::PCSharedCount(a1 + 1);
}

void LiImageFilterChain::LiImageFilterChain(LiImageFilterChain *this)
{
  *(void *)this = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 1);
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = &unk_1F10AD6B0;
}

void LiImageFilterChain::LiImageFilterChain(LiImageFilterChain *this, const LiImageFilterChain *a2)
{
  *(void *)this = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 1);
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = &unk_1F10AD6B0;
  LiImageFilterChain::operator=((uint64_t)this, (uint64_t)a2);
}

void sub_1B7AA2D28(_Unwind_Exception *a1)
{
  PCArray<PCPtr<LiImageFilter>,PCArray_Traits<PCPtr<LiImageFilter>>>::~PCArray(v2);
  PCSharedCount::~PCSharedCount(v1);
  _Unwind_Resume(a1);
}

uint64_t LiImageFilterChain::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = a1 + 16;
    if (*(int *)(a1 + 24) < 0) {
      int v5 = 1;
    }
    else {
      int v5 = *(_DWORD *)(a1 + 24);
    }
    PCArray<PCPtr<LiImageFilter>,PCArray_Traits<PCPtr<LiImageFilter>>>::resize(v4, 0, v5);
    double v10 = *(PCArray_base **)(a1 + 32);
    if (v10) {
      double v10 = (PCArray_base *)MEMORY[0x1BA9BFB70](v10, 0x1000C8077774924);
    }
    *(void *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 24) = 0;
    uint64_t v11 = *(unsigned int *)(a2 + 28);
    if ((int)v11 >= 1)
    {
      for (uint64_t i = 0; i != v11; ++i)
      {
        if (i >= *(int *)(a2 + 28)) {
          PCArray_base::badIndex(v10);
        }
        uint64_t v13 = *(void *)(*(void *)(a2 + 32) + 16 * i);
        if (!v13) {
          throw_PCNullPointerException(1);
        }
        (*(void (**)(PCString *__return_ptr))(*(void *)v13 + 16))(&v16);
        int var0 = (LiImageFilter *)v16.var0;
        PCSharedCount::PCSharedCount(&v19, &v17);
        PCSharedCount::~PCSharedCount(&v17);
        if (!var0)
        {
          exception = (PCException *)__cxa_allocate_exception(0x40uLL);
          PCString::PCString(&v16, "clone failed (sorry, Dolly)");
          PCException::PCException(exception, &v16);
        }
        LiImageFilterChain::append((LiImageFilterChain *)a1, var0);
        PCSharedCount::~PCSharedCount(&v19);
      }
    }
    LiImageFilterChain::connect(a1, v6, v7, v8, v9);
  }
  return a1;
}

void sub_1B7AA2ED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, PCString a9)
{
  PCString::~PCString(&a9);
  PCSharedCount::~PCSharedCount(v9);
  _Unwind_Resume(a1);
}

uint64_t LiImageFilterChain::connect(uint64_t this, uint64_t a2, uint64_t a3, uint64_t a4, int (*a5)(const void *, const void *))
{
  int v5 = (void *)*(unsigned int *)(this + 28);
  if (v5)
  {
    uint64_t v6 = this;
    if (*(int *)(v6 + 28) <= 0) {
      PCArray_base::badIndex(v7);
    }
    uint64_t v8 = **(void **)(v6 + 32);
    if (!v8) {
      throw_PCNullPointerException(1);
    }
    this = (*(uint64_t (**)(uint64_t, void))(*(void *)v8 + 168))(v8, *(void *)v6);
    if ((int)v5 >= 2)
    {
      for (uint64_t i = 1; (void *)i != v5; ++i)
      {
        if (i >= *(int *)(v6 + 28)) {
          PCArray_base::badIndex((PCArray_base *)this);
        }
        double v10 = (void *)(*(void *)(v6 + 32) + 16 * i);
        if (!*v10) {
          throw_PCNullPointerException(1);
        }
        if (i > *(int *)(v6 + 28)) {
          PCArray_base::badIndex((PCArray_base *)this);
        }
        this = (*(uint64_t (**)(void, void))(*(void *)*v10 + 168))(*v10, *(void *)(*(void *)(v6 + 32) + 16 * (i - 1)));
      }
    }
  }
  return this;
}

PCShared_base **LiImageFilterChain::setInput(PCShared_base **this, LiImageSource *a2)
{
  uint64_t result = PCPtr<LiImageSource>::operator=<LiImageSource>(this, (PCShared_base *)a2);
  int v4 = *((_DWORD *)this + 7);
  if (v4)
  {
    if (v4 <= 0) {
      PCArray_base::badIndex((PCArray_base *)result);
    }
    uint64_t v5 = *(void *)this[4];
    if (!v5) {
      throw_PCNullPointerException(1);
    }
    uint64_t v6 = *(uint64_t (**)(void))(*(void *)v5 + 168);
    return (PCShared_base **)v6();
  }
  return result;
}

uint64_t LiImageFilterChain::getTail(LiImageFilterChain *this)
{
  int v1 = *((_DWORD *)this + 7);
  if (v1 <= 0) {
    PCArray_base::badIndex(this);
  }
  return *(void *)(*((void *)this + 4) + 16 * (v1 - 1));
}

uint64_t anonymous namespace'::by_priority(uint64_t a1, uint64_t a2)
{
  if (!*(void *)a1) {
    throw_PCNullPointerException(1);
  }
  int v2 = *(_DWORD *)(*(void *)a1 + 32);
  if (!*(void *)a2) {
    throw_PCNullPointerException(1);
  }
  int v3 = *(_DWORD *)(*(void *)a2 + 32);
  BOOL v4 = v2 < v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v5;
  }
}

void LiImageFilterChain::append(LiImageFilterChain *this, const LiImageFilterChain *a2)
{
  uint64_t v2 = *((unsigned int *)a2 + 7);
  if ((int)v2 >= 1)
  {
    for (uint64_t i = 0; i != v2; ++i)
    {
      if (i >= *((int *)a2 + 7)) {
        PCArray_base::badIndex(this);
      }
      (*(void (**)(LiImageFilter **__return_ptr))(**(void **)(*((void *)a2 + 4) + 16 * i) + 16))(&v6);
      uint64_t v8 = v6;
      PCSharedCount::PCSharedCount(&v9, &v7);
      PCSharedCount::~PCSharedCount(&v7);
      LiImageFilterChain::append(this, v8);
      PCSharedCount::~PCSharedCount(&v9);
    }
  }
}

void sub_1B7AA326C(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1);
  _Unwind_Resume(a1);
}

uint64_t LiImageFilter::adjustCasterLocalToWorld(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 144))();
  }
  return result;
}

void LiMaskBlender::~LiMaskBlender(CGColorSpace **this)
{
  LiBlender::~LiBlender(this);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t LiMaskBlender::add(uint64_t a1, HGNode **a2, uint64_t a3, uint64_t a4, uint64_t a5, const PCSharedCount *a6, double a7)
{
  int v14 = *(LiImagePolygon **)(a1 + 8);
  if (v14)
  {
    LiImagePolygon::getDOD(v14, 1.7, v29);
    LiBlender::crop(*(void *)(a1 + 96), *(void *)(a1 + 8), *(unsigned char *)(a1 + 16));
    *(void *)(a1 + 8) = 0;
  }
  else
  {
    uint64_t DOD = HGRenderer::GetDOD(*(HGRenderer **)(a1 + 24), *a2);
    HGRectIsNull(DOD, v16);
  }
  PCSharedCount v17 = *a2;
  v29[0] = (int32x2_t)v17;
  if (v17) {
    (*(void (**)(HGNode *))(*(void *)v17 + 16))(v17);
  }
  if (*(_DWORD *)(*(void *)(a1 + 88) + 68))
  {
    uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
    uint64_t v27 = 0;
    PCSharedCount::PCSharedCount(&v28);
    (*(void (**)(uint64_t, int32x2_t *, void, void, void, uint64_t *, double))(*(void *)v18 + 16))(v18, v29, 0, 0, 0, &v27, 1.0);
    PCSharedCount::~PCSharedCount(&v28);
    (*(void (**)(int32x2_t *__return_ptr))(**(void **)(a1 + 88) + 168))(&v26);
    uint64_t v24 = 0;
    PCSharedCount::PCSharedCount(&v25);
    (*(void (**)(uint64_t, int32x2_t *, uint64_t, void, void, uint64_t *, double))(*(void *)v18 + 16))(v18, &v26, 27, 0, 0, &v24, 1.0);
    PCSharedCount::~PCSharedCount(&v25);
    if (v26) {
      (*(void (**)(int32x2_t))(**(void **)&v26 + 24))(v26);
    }
    (*(void (**)(int32x2_t *__return_ptr, uint64_t))(*(void *)v18 + 24))(&v26, v18);
    int32x2_t v19 = v26;
    if (*(void *)v29 == *(void *)&v26)
    {
      if (v29[0]) {
        (*(void (**)(void))(**(void **)v29 + 24))();
      }
    }
    else
    {
      if (v29[0])
      {
        (*(void (**)(void))(**(void **)v29 + 24))();
        int32x2_t v19 = v26;
      }
      v29[0] = v19;
    }
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  uint64_t v20 = *(void *)(a1 + 96);
  int var0 = a6->var0;
  PCSharedCount::PCSharedCount(&v23, a6 + 1);
  (*(void (**)(uint64_t, int32x2_t *, uint64_t, uint64_t, uint64_t, PC_Sp_counted_base **, double))(*(void *)v20 + 16))(v20, v29, a3, a4, a5, &var0, a7);
  PCSharedCount::~PCSharedCount(&v23);
  uint64_t result = (uint64_t)v29[0];
  if (v29[0]) {
    return (*(uint64_t (**)(void))(**(void **)v29 + 24))(*(void *)v29);
  }
  return result;
}

void sub_1B7AA366C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a14) {
    (*(void (**)(uint64_t))(*(void *)a14 + 24))(a14);
  }
  if (a17) {
    (*(void (**)(uint64_t))(*(void *)a17 + 24))(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t LiMaskBlender::getOutput(LiMaskBlender *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 12) + 24))();
}

uint64_t LiMaskBlender::addPatch(void **a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = *a3;
  uint64_t v14 = v5;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
  }
  if (*((_DWORD *)a1[11] + 17))
  {
    uint64_t v6 = ((uint64_t (*)(void **))(*a1)[4])(a1);
    uint64_t v12 = 0;
    PCSharedCount::PCSharedCount(&v13);
    (*(void (**)(uint64_t, uint64_t *, void, void, void, uint64_t *, double))(*(void *)v6 + 16))(v6, &v14, 0, 0, 0, &v12, 1.0);
    PCSharedCount::~PCSharedCount(&v13);
    (*(void (**)(uint64_t *__return_ptr))(*a1[11] + 168))(&v11);
    uint64_t v9 = 0;
    PCSharedCount::PCSharedCount(&v10);
    (*(void (**)(uint64_t, uint64_t *, uint64_t, void, void, uint64_t *, double))(*(void *)v6 + 16))(v6, &v11, 27, 0, 0, &v9, 1.0);
    PCSharedCount::~PCSharedCount(&v10);
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 24))(v11);
    }
    (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v6 + 24))(&v11, v6);
    uint64_t v7 = v11;
    if (v14 == v11)
    {
      if (v14) {
        (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);
      }
    }
    else
    {
      if (v14)
      {
        (*(void (**)(uint64_t))(*(void *)v14 + 24))(v14);
        uint64_t v7 = v11;
      }
      uint64_t v14 = v7;
    }
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  (*(void (**)(void *, uint64_t, uint64_t *))(*a1[12] + 40))(a1[12], a2, &v14);
  uint64_t result = v14;
  if (v14) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v14 + 24))(v14);
  }
  return result;
}

void sub_1B7AA3A50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a11) {
    (*(void (**)(uint64_t))(*(void *)a11 + 24))(a11);
  }
  if (a14) {
    (*(void (**)(uint64_t))(*(void *)a14 + 24))(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t LiMaskBlender::newInstance(LiMaskBlender *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 12) + 32))();
}

uint64_t LiMaskDrawer::LiMaskDrawer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  LiDrawer::LiDrawer((LiDrawer *)a1);
  *uint64_t v6 = &unk_1F111DC30;
  v6[9] = 0;
  v6[10] = 0;
  v6[8] = 0;
  v6[6] = a2;
  v6[7] = &unk_1F111A298;
  uint64_t v6[2] = a2;
  PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::resize((uint64_t)(v6 + 7), 1, 3);
  *(void *)(*(void *)(a1 + 72) + 8 * *(int *)(a1 + 68) - 8) = a3;
  return a1;
}

void sub_1B7AA3BF8(_Unwind_Exception *a1)
{
  uint64_t v4 = *((void *)v1 + 10);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  PCPtrArray<LiSeam>::~PCPtrArray(v2);
  LiDrawer::~LiDrawer(v1);
  _Unwind_Resume(a1);
}

void LiMaskDrawer::~LiMaskDrawer(LiMaskDrawer *this)
{
  *(void *)this = &unk_1F111DC30;
  uint64_t v2 = *((void *)this + 10);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  *((void *)this + 7) = &unk_1F111A2E8;
  int v3 = *((_DWORD *)this + 16);
  if (v3 < 0) {
    int v4 = 1;
  }
  else {
    int v4 = v3 & ~(v3 >> 31);
  }
  if (v4 == v3)
  {
    uint64_t v5 = *((int *)this + 17);
    if ((v5 & 0x80000000) != 0)
    {
      do
        *(void *)(*((void *)this + 9) + 8 * v5) = 0;
      while (!__CFADD__(v5++, 1));
    }
  }
  else
  {
    if (v4) {
      operator new[]();
    }
    uint64_t v7 = *((void *)this + 9);
    if (v7) {
      MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
    }
    *((void *)this + 9) = 0;
  }
  *((_DWORD *)this + 16) = v4;
  *((_DWORD *)this + 17) = 0;
  uint64_t v8 = *((void *)this + 9);
  if (v8) {
    MEMORY[0x1BA9BFB70](v8, 0x1000C8077774924);
  }
  *((void *)this + 9) = 0;
  *((_DWORD *)this + 16) = 0;

  LiDrawer::~LiDrawer(this);
}

{
  uint64_t vars8;

  LiMaskDrawer::~LiMaskDrawer(this);

  JUMPOUT(0x1BA9BFBA0);
}

void LiMaskDrawer::draw(LiMaskDrawer *this, LiBlender *a2)
{
  LiBlender::LiBlender((LiBlender *)v5, *((float *)a2 + 13), (const FxColorDescription *)((char *)a2 + 56));
  v5[11] = this;
  v5[12] = a2;
  int v4 = (CGColorSpace *)*((void *)a2 + 3);
  v5[0] = (CGColorSpace *)&unk_1F111DBF0;
  double v5[3] = v4;
  (*(void (**)(void, CGColorSpace **))(**((void **)this + 6) + 16))(*((void *)this + 6), v5);
  LiBlender::~LiBlender(v5);
}

void sub_1B7AA3E84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  LiBlender::~LiBlender((CGColorSpace **)va);
  _Unwind_Resume(a1);
}

void LiMaskDrawer::holdOut()
{
}

void sub_1B7AA4010(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C402E1910D9);
  _Unwind_Resume(a1);
}

uint64_t LiMaskDrawer::getBounds(LiMaskDrawer *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 6) + 32))();
}

uint64_t LiMaskDrawer::isPlanar(LiMaskDrawer *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 6) + 40))();
}

uint64_t LiMaskDrawer::getPlane(LiMaskDrawer *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 6) + 48))();
}

uint64_t LiMaskDrawer::setPlane(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 56))();
}

uint64_t LiMaskDrawer::getSceneObject(LiMaskDrawer *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 6) + 72))();
}

void LiMaskDrawer::intersect(LiMaskDrawer *this, LiIntersection *a2)
{
  int v4 = (PCArray_base *)(*(uint64_t (**)(void))(**((void **)this + 6) + 80))(*((void *)this + 6));
  uint64_t v5 = *((unsigned int *)a2 + 5);
  if ((int)v5 >= 1)
  {
    for (uint64_t i = 0; i != v5; ++i)
    {
      if (i >= *((int *)a2 + 5)) {
        PCArray_base::badIndex(v4);
      }
      uint64_t v7 = *(void *)(*((void *)a2 + 3) + 8 * i);
      if (*(void *)(v7 + 8))
      {
        __p = 0;
        PCSharedCount v10 = 0;
        uint64_t v11 = 0;
        elim<double>((double **)(v7 + 16), &__p, 2);
        if (*((int *)this + 17) >= 1)
        {
          if (*((int *)this + 17) <= 0) {
            PCArray_base::badIndex(v8);
          }
          operator new();
        }
        int v4 = (PCArray_base *)__p;
        if (__p)
        {
          PCSharedCount v10 = __p;
          operator delete(__p);
        }
      }
    }
  }
}

void sub_1B7AA42E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double elim<double>(double **a1, void *a2, int a3)
{
  int v6 = -1431655765 * (a1[1] - *a1);
  std::vector<PCVector2<double>>::resize((uint64_t)a2, v6);
  if (v6 >= 1)
  {
    uint64_t v8 = *a1;
    uint64_t v9 = v6;
    PCSharedCount v10 = (double *)(*a2 + 8);
    do
    {
      uint64_t v11 = v8 + 1;
      if (a3 > 0) {
        uint64_t v11 = v8;
      }
      if (a3 <= 1) {
        uint64_t v12 = 2;
      }
      else {
        uint64_t v12 = 1;
      }
      double result = v8[v12];
      *(v10 - 1) = *v11;
      *PCSharedCount v10 = result;
      v10 += 2;
      v8 += 3;
      --v9;
    }
    while (v9);
  }
  return result;
}

void LiMaskDrawer::name(LiMaskDrawer *this@<X0>, void *a2@<X8>)
{
  LiString::LiString((LiString *)&v16, "mask(");
  (*(void (**)(unsigned char **__return_ptr))(**((void **)this + 6) + 88))(&v15);
  int v4 = v16;
  if (v16) {
    int v5 = *((_DWORD *)v16 - 2);
  }
  else {
    int v5 = 0;
  }
  int v6 = v15;
  if (v15) {
    int v7 = *((_DWORD *)v15 - 2);
  }
  else {
    int v7 = 0;
  }
  uint64_t v8 = v7 + (uint64_t)v5;
  uint64_t v9 = (unsigned int *)malloc_type_malloc(v8 + 13, 0x8903763CuLL);
  v9[1] = v8;
  void v9[2] = v8 + 1;
  atomic_store(1u, v9);
  atomic_store(0, v9);
  memcpy(v9 + 3, v4, v5);
  memcpy((char *)v9 + v5 + 12, v6, v7);
  *((unsigned char *)v9 + v8 + 12) = 0;
  atomic_fetch_add((atomic_uint *volatile)v9, 1u);
  size_t v10 = (int)v9[1];
  uint64_t v11 = (unsigned int *)malloc_type_malloc(v10 + 14, 0x8903763CuLL);
  atomic_store(1u, v11);
  uint64_t v12 = v11 + 3;
  atomic_store(0, v11);
  v11[1] = v10 + 1;
  std::locale v11[2] = v10 + 2;
  memcpy(v11 + 3, v9 + 3, v10);
  *((unsigned char *)v12 + v10) = 41;
  *((unsigned char *)v12 + v10 + 1) = 0;
  *a2 = v11 + 3;
  atomic_fetch_add((atomic_uint *volatile)v11, 1u);
  if (atomic_fetch_add((atomic_uint *volatile)v9, 0xFFFFFFFF) == 1) {
    free(v9);
  }
  if (v15 && atomic_fetch_add((atomic_uint *volatile)v15 - 3, 0xFFFFFFFF) == 1)
  {
    unsigned char *v15 = 0;
    if (v15) {
      PCSharedCount v13 = v15 - 12;
    }
    else {
      PCSharedCount v13 = 0;
    }
    free(v13);
  }
  if (v16 && atomic_fetch_add((atomic_uint *volatile)v16 - 3, 0xFFFFFFFF) == 1)
  {
    unsigned char *v16 = 0;
    if (v16) {
      uint64_t v14 = v16 - 12;
    }
    else {
      uint64_t v14 = 0;
    }
    free(v14);
  }
}

void sub_1B7AA45B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, atomic_uint *a9, atomic_uint *a10)
{
  if (atomic_fetch_add((atomic_uint *volatile)v10, 0xFFFFFFFF) == 1) {
    free(v10);
  }
  if (a9 && atomic_fetch_add(a9 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)a9 = 0;
    free(a9 - 3);
  }
  if (a10)
  {
    if (atomic_fetch_add(a10 - 3, 0xFFFFFFFF) == 1)
    {
      *(unsigned char *)a10 = 0;
      free(a10 - 3);
    }
  }
  _Unwind_Resume(exception_object);
}

void LiMaskDrawer::dump(LiMaskDrawer *this, const char **a2)
{
  if (*a2) {
    int v4 = *a2;
  }
  else {
    int v4 = "";
  }
  size_t v5 = strlen(v4);
  int v6 = (void *)MEMORY[0x1E4FBA240];
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)v4, v5);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)"mask[", 5);
  int v7 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)"]\n", 2);
  uint64_t v8 = *a2;
  if (v8) {
    int v9 = *((_DWORD *)v8 - 2);
  }
  else {
    int v9 = 0;
  }
  uint64_t v10 = v9 + 4;
  uint64_t v11 = (unsigned int *)malloc_type_malloc(v9 + 17, 0x8903763CuLL);
  v11[1] = v10;
  std::locale v11[2] = v9 + 5;
  atomic_store(1u, v11);
  uint64_t v12 = v11 + 3;
  atomic_store(0, v11);
  memcpy(v11 + 3, v8, v9);
  *(unsigned int *)((char *)v12 + v9) = 544022560;
  *((unsigned char *)v12 + v10) = 0;
  uint64_t v14 = (atomic_uint *)(v11 + 3);
  atomic_fetch_add((atomic_uint *volatile)v11, 1u);
  (*(void (**)(void, atomic_uint **))(**((void **)this + 6) + 96))(*((void *)this + 6), &v14);
  if (v14 && atomic_fetch_add(v14 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)uint64_t v14 = 0;
    if (v14) {
      PCSharedCount v13 = v14 - 3;
    }
    else {
      PCSharedCount v13 = 0;
    }
    free(v13);
  }
}

void sub_1B7AA47D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    LiGeode::print(a10, (unsigned char **)&a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t LiMaskDrawer::getFilterIntersections(LiMaskDrawer *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 6) + 112))();
}

uint64_t LiMaskDrawer::getBlendMode(LiMaskDrawer *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 6) + 128))();
}

uint64_t LiMaskDrawer::defocus(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 136))();
}

CGColorSpace **LiMaskDrawer::getMask@<X0>(LiMaskDrawer *this@<X0>, HGRenderer *a2@<X1>, HGNode **a3@<X8>)
{
  int v4 = (HGNode *)*((void *)this + 10);
  if (!v4)
  {
    uint64_t v6 = *((unsigned int *)this + 17);
    if (v6)
    {
      PCColorDescription::PCColorDescription(&v19._pcColorDesc);
      v19._BOOL isPremultiplied = 1;
      uint64_t v8 = LiMultiBlender::LiMultiBlender((LiMultiBlender *)v17, 1.0, &v19);
      uint64_t v18 = a2;
      if ((int)v6 >= 1)
      {
        for (uint64_t i = 0; i != v6; ++i)
        {
          if (i >= *((int *)this + 17)) {
            PCArray_base::badIndex(v8);
          }
          (*(void (**)(PCArray_base **__return_ptr))(**(void **)(*((void *)this + 9) + 8 * i) + 168))(&v16);
          v14.int var0 = 0;
          PCSharedCount::PCSharedCount(&v15);
          LiMultiBlender::add((uint64_t)v17, (uint64_t *)&v16, 0, 0, 0, &v14, 1.0);
          PCSharedCount::~PCSharedCount(&v15);
          uint64_t v8 = v16;
          if (v16) {
            uint64_t v8 = (PCArray_base *)(*(uint64_t (**)(PCArray_base *))(*(void *)v16 + 24))(v16);
          }
        }
      }
      LiMultiBlender::getOutput((LiMultiBlender *)v17, (uint64_t *)&v16, v9);
      uint64_t v11 = (PCArray_base *)*((void *)this + 10);
      uint64_t v12 = (uint64_t)v16;
      if (v11 == v16)
      {
        if (v11) {
          (*(void (**)(PCArray_base *))(*(void *)v11 + 24))(v11);
        }
      }
      else
      {
        if (v11)
        {
          (*(void (**)(PCArray_base *))(*(void *)v11 + 24))(v11);
          uint64_t v12 = (uint64_t)v16;
        }
        *((void *)this + 10) = v12;
      }
      LiMultiBlender::~LiMultiBlender((LiMultiBlender *)v17);
      double result = PCCFRef<CGColorSpace *>::~PCCFRef(&v19._pcColorDesc._colorSpaceRef._obj);
    }
    else
    {
      int v4 = (HGNode *)HGObject::operator new(0x1A0uLL);
      HGNode::HGNode(v4);
      double result = (CGColorSpace **)*((void *)this + 10);
      if (result != (CGColorSpace **)v4)
      {
        if (result) {
          double result = (CGColorSpace **)(*((uint64_t (**)(CGColorSpace **))*result + 3))(result);
        }
        *((void *)this + 10) = v4;
LABEL_23:
        *a3 = v4;
        if (!v4) {
          return result;
        }
        return (CGColorSpace **)(*(uint64_t (**)(HGNode *, HGRenderer *))(*(void *)v4 + 16))(v4, a2);
      }
      if (!v4)
      {
        *a3 = 0;
        return result;
      }
      double result = (CGColorSpace **)(*(uint64_t (**)(HGNode *))(*(void *)v4 + 24))(v4);
    }
    int v4 = (HGNode *)*((void *)this + 10);
    goto LABEL_23;
  }
  *a3 = v4;
  return (CGColorSpace **)(*(uint64_t (**)(HGNode *, HGRenderer *))(*(void *)v4 + 16))(v4, a2);
}

void sub_1B7AA4AE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ProShade::UniformProgram::addVariable(uint64_t a1, const PCSharedCount *a2, uint64_t *a3, uint64_t a4)
{
  unint64_t var0 = (unint64_t)a2[2].var0;
  unint64_t v48 = var0;
  int v7 = *(void **)(a4 + 8);
  if (!v7) {
    goto LABEL_12;
  }
  uint64_t v8 = (void *)(a4 + 8);
  do
  {
    unint64_t v9 = v7[4];
    BOOL v10 = v9 >= var0;
    if (v9 >= var0) {
      uint64_t v11 = v7;
    }
    else {
      uint64_t v11 = v7 + 1;
    }
    if (v10) {
      uint64_t v8 = v7;
    }
    int v7 = (void *)*v11;
  }
  while (*v11);
  if (v8 != (void *)(a4 + 8) && var0 >= v8[4]) {
    return *((unsigned int *)v8 + 10);
  }
LABEL_12:
  uint64_t v12 = 0x4EC4EC4EC4EC4EC5 * ((a3[1] - *a3) >> 3);
  int v41 = &v48;
  *((_DWORD *)std::__tree<std::__value_type<ProShade::SamplerNode const*,int>,std::__map_value_compare<ProShade::SamplerNode const*,std::__value_type<ProShade::SamplerNode const*,int>,std::less<ProShade::SamplerNode const*>,true>,std::allocator<std::__value_type<ProShade::SamplerNode const*,int>>>::__emplace_unique_key_args<ProShade::SamplerNode const*,std::piecewise_construct_t const&,std::tuple<ProShade::SamplerNode const*&&>,std::tuple<>>((uint64_t **)a4, &v48, (uint64_t)&std::piecewise_construct, &v41)+ 10) = v12;
  std::vector<ProShade::UniformProgram::CompileNode>::resize(a3, (int)v12 + 1);
  uint64_t v38 = v12;
  ProShade::VarT<ProShade::Node>::operator=(*a3 + 104 * (int)v12, a2);
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  size_t v45 = &unk_1F1119AF8;
  PCSharedCount v13 = (PCArray_base *)ProShade::VarT<ProShade::Node>::inputs((uint64_t)a2);
  int v14 = HIDWORD(v46);
  if (HIDWORD(v46))
  {
    int v15 = 0;
    int v16 = 0;
    do
    {
      if (v15 < 0 || SHIDWORD(v46) <= v15) {
        PCArray_base::badIndex(v13);
      }
      int v41 = (unint64_t *)&unk_1F11193B8;
      uint64_t v17 = v47 + 32 * v16;
      char v42 = *(unsigned char *)(v17 + 8);
      uint64_t v43 = *(void *)(v17 + 16);
      PCSharedCount::PCSharedCount(&v44, (const PCSharedCount *)(v17 + 24));
      int v18 = ProShade::UniformProgram::addVariable(a1, &v41, a3, a4);
      int v19 = v18;
      uint64_t v20 = *a3 + 104 * (int)v38;
      unint64_t v23 = *(void *)(v20 + 88);
      PCSharedCount v22 = (void *)(v20 + 88);
      unint64_t v21 = v23;
      PCSharedCount v25 = (char **)(v22 - 1);
      uint64_t v24 = (char *)*(v22 - 1);
      if ((unint64_t)v24 >= v23)
      {
        uint64_t v27 = (void **)(v22 - 2);
        PCSharedCount v28 = (char *)*(v22 - 2);
        uint64_t v29 = (v24 - v28) >> 2;
        unint64_t v30 = v29 + 1;
        if ((unint64_t)(v29 + 1) >> 62) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v31 = v21 - (void)v28;
        if (v31 >> 1 > v30) {
          unint64_t v30 = v31 >> 1;
        }
        if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v32 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v32 = v30;
        }
        if (v32)
        {
          float v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)v22, v32);
          uint64_t v24 = *v25;
          PCSharedCount v28 = (char *)*v27;
        }
        else
        {
          float v33 = 0;
        }
        int v34 = &v33[4 * v29];
        *(_DWORD *)int v34 = v19;
        int32x2_t v26 = v34 + 4;
        while (v24 != v28)
        {
          int v35 = *((_DWORD *)v24 - 1);
          v24 -= 4;
          *((_DWORD *)v34 - 1) = v35;
          v34 -= 4;
        }
        *uint64_t v27 = v34;
        void *v25 = v26;
        *PCSharedCount v22 = &v33[4 * v32];
        if (v28) {
          operator delete(v28);
        }
      }
      else
      {
        *(_DWORD *)uint64_t v24 = v18;
        int32x2_t v26 = v24 + 4;
      }
      void *v25 = v26;
      int v41 = (unint64_t *)&unk_1F11193B8;
      PCSharedCount::~PCSharedCount(&v44);
      int v15 = ++v16;
    }
    while (v14 != v16);
  }
  size_t v45 = &unk_1F1119AF8;
  if ((int)v46 < 0) {
    int v36 = 1;
  }
  else {
    int v36 = v46;
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize((uint64_t)&v45, 0, v36);
  if (v47) {
    MEMORY[0x1BA9BFB70](v47, 0x1000C8077774924);
  }
  return v38;
}

void sub_1B7AA4EF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::~PCArray((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<ProShade::UniformProgram::CompileNode>::resize(uint64_t *a1, unint64_t a2)
{
  int v3 = (PCSharedCount *)a1[1];
  unint64_t v4 = 0x4EC4EC4EC4EC4EC5 * (((uint64_t)v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<ProShade::UniformProgram::CompileNode>::__append(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 104 * a2;
    while (v3 != (PCSharedCount *)v7)
    {
      v3 -= 13;
      std::allocator<ProShade::UniformProgram::CompileNode>::destroy[abi:ne180100]((uint64_t)(a1 + 2), v3);
    }
    a1[1] = v7;
  }
}

void ProShade::UniformProgram::addRegister(uint64_t a1, uint64_t a2, void *a3)
{
  if ((*(_DWORD *)(a2 + 96) & 0x80000000) != 0)
  {
    unint64_t v6 = *(int **)(a2 + 72);
    uint64_t v7 = *(int **)(a2 + 80);
    while (v6 != v7)
    {
      int v8 = *v6++;
      ProShade::UniformProgram::addRegister(a1, *a3 + 104 * v8, a3);
    }
    uint64_t v10 = *(void *)a1;
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v67 = 0;
    long long v65 = 0u;
    *(_OWORD *)__p = 0u;
    long long v63 = 0u;
    *(_OWORD *)uint64_t v64 = 0u;
    long long v61 = 0u;
    long long v62 = 0u;
    long long v60 = 0u;
    ProShade::UniformProgram::Register::Register((ProShade::UniformProgram::Register *)&v60);
    unint64_t v11 = *(void *)(a1 + 8);
    if (v11 >= *(void *)(a1 + 16))
    {
      uint64_t v12 = std::vector<ProShade::UniformProgram::Register>::__push_back_slow_path<ProShade::UniformProgram::Register>((uint64_t *)a1, (uint64_t)&v60);
    }
    else
    {
      std::allocator<ProShade::UniformProgram::Register>::construct[abi:ne180100]<ProShade::UniformProgram::Register,ProShade::UniformProgram::Register>(a1 + 16, *(void *)(a1 + 8), (uint64_t)&v60);
      uint64_t v12 = v11 + 120;
      *(void *)(a1 + 8) = v11 + 120;
    }
    *(void *)(a1 + 8) = v12;
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    int v13 = -286331153 * ((unint64_t)(v9 - v10) >> 3);
    if (v64[1])
    {
      *(void **)&long long v65 = v64[1];
      operator delete(v64[1]);
    }
    *(void *)&long long v62 = &unk_1F11193B8;
    PCSharedCount::~PCSharedCount((PCSharedCount *)&v63 + 1);
    *(void *)&long long v60 = &unk_1F11193B8;
    PCSharedCount::~PCSharedCount((PCSharedCount *)&v61 + 1);
    uint64_t v14 = *(void *)(a1 + 8);
    *(_DWORD *)(a2 + 96) = v13;
    unint64_t v59 = *(void *)(a2 + 16);
    *(void *)&long long v60 = &v59;
    *((_DWORD *)std::__tree<std::__value_type<ProShade::SamplerNode const*,int>,std::__map_value_compare<ProShade::SamplerNode const*,std::__value_type<ProShade::SamplerNode const*,int>,std::less<ProShade::SamplerNode const*>,true>,std::allocator<std::__value_type<ProShade::SamplerNode const*,int>>>::__emplace_unique_key_args<ProShade::SamplerNode const*,std::piecewise_construct_t const&,std::tuple<ProShade::SamplerNode const*&&>,std::tuple<>>((uint64_t **)(a1 + 24), &v59, (uint64_t)&std::piecewise_construct, (void **)&v60)+ 10) = v13;
    ProShade::VarT<ProShade::Node>::operator=(v14 - 120, (const PCSharedCount *)a2);
    ProShade::VarT<ProShade::Node>::operator=(v14 - 88, (const PCSharedCount *)(a2 + 32));
    int v15 = *(_DWORD *)(a2 + 64);
    *(_DWORD *)(v14 - LiDepthSorter::stackSort((uint64_t)this + 56) = v13;
    *(_DWORD *)(v14 - 52) = v15;
    int v16 = *(int **)(a2 + 72);
    uint64_t v17 = *(int **)(a2 + 80);
    if (v16 != v17)
    {
      int32x2_t v58 = (void **)(v14 - 48);
      do
      {
        int v18 = *(_DWORD *)(*a3 + 104 * *v16 + 96);
        uint64_t v20 = *(char **)(v14 - 40);
        unint64_t v19 = *(void *)(v14 - 32);
        if ((unint64_t)v20 >= v19)
        {
          PCSharedCount v22 = (char *)*v58;
          uint64_t v23 = (v20 - (unsigned char *)*v58) >> 2;
          unint64_t v24 = v23 + 1;
          if ((unint64_t)(v23 + 1) >> 62) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v25 = v19 - (void)v22;
          if (v25 >> 1 > v24) {
            unint64_t v24 = v25 >> 1;
          }
          if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v26 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v26 = v24;
          }
          if (v26)
          {
            uint64_t v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v14 - 32, v26);
            PCSharedCount v22 = *(char **)(v14 - 48);
            uint64_t v20 = *(char **)(v14 - 40);
          }
          else
          {
            uint64_t v27 = 0;
          }
          PCSharedCount v28 = &v27[4 * v23];
          *(_DWORD *)PCSharedCount v28 = v18;
          unint64_t v21 = v28 + 4;
          while (v20 != v22)
          {
            int v29 = *((_DWORD *)v20 - 1);
            v20 -= 4;
            *((_DWORD *)v28 - 1) = v29;
            v28 -= 4;
          }
          *(void *)(v14 - 48) = v28;
          *(void *)(v14 - 40) = v21;
          *(void *)(v14 - 32) = &v27[4 * v26];
          if (v22) {
            operator delete(v22);
          }
        }
        else
        {
          *(_DWORD *)uint64_t v20 = v18;
          unint64_t v21 = v20 + 4;
        }
        *(void *)(v14 - 40) = v21;
        uint64_t v30 = *(void *)a1 + 120 * v18;
        unint64_t v33 = *(void *)(v30 + 112);
        unint64_t v32 = (void *)(v30 + 112);
        unint64_t v31 = v33;
        int v35 = (char **)(v32 - 1);
        int v34 = (char *)*(v32 - 1);
        if ((unint64_t)v34 >= v33)
        {
          size_t v37 = (void **)(v32 - 2);
          uint64_t v38 = (char *)*(v32 - 2);
          uint64_t v39 = (v34 - v38) >> 2;
          unint64_t v40 = v39 + 1;
          if ((unint64_t)(v39 + 1) >> 62) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v41 = v31 - (void)v38;
          if (v41 >> 1 > v40) {
            unint64_t v40 = v41 >> 1;
          }
          if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v42 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v42 = v40;
          }
          if (v42)
          {
            uint64_t v43 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)v32, v42);
            int v34 = *v35;
            uint64_t v38 = (char *)*v37;
          }
          else
          {
            uint64_t v43 = 0;
          }
          PCSharedCount v44 = &v43[4 * v39];
          *(_DWORD *)PCSharedCount v44 = v13;
          int v36 = v44 + 4;
          while (v34 != v38)
          {
            int v45 = *((_DWORD *)v34 - 1);
            v34 -= 4;
            *((_DWORD *)v44 - 1) = v45;
            v44 -= 4;
          }
          const std::locale::facet *v37 = v44;
          *int v35 = v36;
          *unint64_t v32 = &v43[4 * v42];
          if (v38) {
            operator delete(v38);
          }
        }
        else
        {
          *(_DWORD *)int v34 = v13;
          int v36 = v34 + 4;
        }
        *int v35 = v36;
        ++v16;
      }
      while (v16 != v17);
      int v15 = *(_DWORD *)(v14 - 52);
    }
    if ((v15 & 0x80000000) == 0)
    {
      unint64_t v46 = *(void *)(a1 + 64);
      uint64_t v47 = *(char **)(a1 + 56);
      if ((unint64_t)v47 >= v46)
      {
        float v49 = *(char **)(a1 + 48);
        uint64_t v50 = (v47 - v49) >> 2;
        if ((unint64_t)(v50 + 1) >> 62) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v51 = v46 - (void)v49;
        unint64_t v52 = (uint64_t)(v46 - (void)v49) >> 1;
        if (v52 <= v50 + 1) {
          unint64_t v52 = v50 + 1;
        }
        if (v51 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v53 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v53 = v52;
        }
        if (v53)
        {
          float32_t v54 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(a1 + 64, v53);
          float v49 = *(char **)(a1 + 48);
          uint64_t v47 = *(char **)(a1 + 56);
        }
        else
        {
          float32_t v54 = 0;
        }
        PCSharedCount v55 = &v54[4 * v50];
        char v56 = &v54[4 * v53];
        *(_DWORD *)PCSharedCount v55 = v13;
        unint64_t v48 = v55 + 4;
        while (v47 != v49)
        {
          int v57 = *((_DWORD *)v47 - 1);
          v47 -= 4;
          *((_DWORD *)v55 - 1) = v57;
          v55 -= 4;
        }
        *(void *)(a1 + 48) = v55;
        *(void *)(a1 + LiDepthSorter::stackSort((uint64_t)this + 56) = v48;
        *(void *)(a1 + 64) = v56;
        if (v49) {
          operator delete(v49);
        }
      }
      else
      {
        *(_DWORD *)uint64_t v47 = v13;
        unint64_t v48 = v47 + 4;
      }
      *(void *)(a1 + LiDepthSorter::stackSort((uint64_t)this + 56) = v48;
    }
  }
}

void sub_1B7AA5410(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  ProShade::UniformProgram::Register::~Register((PCSharedCount *)va);
  _Unwind_Resume(a1);
}

void ProShade::UniformProgram::Register::~Register(PCSharedCount *this)
{
  unint64_t var0 = this[12].var0;
  if (var0)
  {
    this[13].unint64_t var0 = var0;
    operator delete(var0);
  }
  int v3 = this[9].var0;
  if (v3)
  {
    this[10].unint64_t var0 = v3;
    operator delete(v3);
  }
  this[4].unint64_t var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(this + 7);
  this->unint64_t var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(this + 3);
}

void *ProShade::UniformProgram::UniformProgram(void *this)
{
  *this = 0;
  this[1] = 0;
  this[4] = 0;
  this[5] = 0;
  this[6] = 0;
  this[2] = 0;
  this[3] = this + 4;
  this[7] = 0;
  this[8] = 0;
  return this;
}

void ProShade::UniformProgram::initialize(PCArray_base *a1, uint64_t a2)
{
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  v32[0] = 0;
  v32[1] = 0;
  unint64_t v31 = v32;
  int v13 = *(_DWORD *)(a2 + 12);
  if (v13)
  {
    int v2 = 0;
    for (i = 0; i != v13; int v2 = i)
    {
      if (v2 < 0 || *(_DWORD *)(a2 + 12) <= v2) {
        PCArray_base::badIndex(a1);
      }
      uint64_t v4 = *(void *)(a2 + 16);
      uint64_t v5 = v4 + 72 * i;
      PCSharedCount v22 = (void **)&unk_1F11193B8;
      char v23 = *(unsigned char *)(v5 + 8);
      uint64_t v24 = *(void *)(v5 + 16);
      PCSharedCount::PCSharedCount(&v25, (const PCSharedCount *)(v5 + 24));
      v26.unint64_t var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
      uint64_t v6 = v4 + 72 * i;
      char v27 = *(unsigned char *)(v6 + 40);
      uint64_t v28 = *(void *)(v6 + 48);
      PCSharedCount::PCSharedCount(&v29, (const PCSharedCount *)(v6 + 56));
      int v30 = *(_DWORD *)(v4 + 72 * i + 64);
      v18.unint64_t var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
      char v19 = v23;
      uint64_t v20 = v24;
      PCSharedCount::PCSharedCount(&v21, &v25);
      if (!v20) {
        throw_PCNullPointerException(1);
      }
      if (!v28) {
        throw_PCNullPointerException(1);
      }
      if (*(_DWORD *)(v20 + 24) != *(_DWORD *)(v28 + 24))
      {
        int v8 = (const PCString *)ProShade::VarT<ProShade::Node>::width((uint64_t)&v26, v7);
        if (!v28) {
          throw_PCNullPointerException(1);
        }
        ProShade::cast((uint64_t)&v22, v8, *(_DWORD *)(v28 + 24), (uint64_t)v16);
        ProShade::VarT<ProShade::Node>::operator=((uint64_t)&v18, v16);
        v16[0].unint64_t var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
        PCSharedCount::~PCSharedCount(&v17);
      }
      int v9 = ProShade::UniformProgram::addVariable((uint64_t)a1, &v18, &v33, (uint64_t)&v31);
      if (0x4EC4EC4EC4EC4EC5 * ((v34 - v33) >> 3) <= (unint64_t)v9) {
        std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
      }
      uint64_t v10 = v33 + 104 * v9;
      ProShade::VarT<ProShade::Node>::operator=(v10 + 32, &v26);
      *(_DWORD *)(v10 + 64) = v30;
      v18.unint64_t var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
      PCSharedCount::~PCSharedCount(&v21);
      v26.unint64_t var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
      PCSharedCount::~PCSharedCount(&v29);
      PCSharedCount v22 = (void **)&unk_1F11193B8;
      PCSharedCount::~PCSharedCount(&v25);
      ++i;
    }
    uint64_t v11 = v33;
    uint64_t v12 = v34;
    while (v11 != v12)
    {
      ProShade::UniformProgram::addRegister((uint64_t)a1, v11, &v33);
      v11 += 104;
    }
  }
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy((uint64_t)&v31, v32[0]);
  PCSharedCount v22 = (void **)&v33;
  std::vector<ProShade::UniformProgram::CompileNode>::__destroy_vector::operator()[abi:ne180100](&v22);
}

void sub_1B7AA57FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, PCSharedCount *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  PCSharedCount::~PCSharedCount(a9);
  PCSharedCount::~PCSharedCount(v21);
  ProShade::UniformVariable::~UniformVariable((PCSharedCount *)&a21);
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(v22 - 136, *(void **)(v22 - 128));
  a21 = v22 - 112;
  std::vector<ProShade::UniformProgram::CompileNode>::__destroy_vector::operator()[abi:ne180100]((void ***)&a21);
  _Unwind_Resume(a1);
}

void ProShade::UniformVariable::~UniformVariable(PCSharedCount *this)
{
  this[4].unint64_t var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(this + 7);
  this->unint64_t var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(this + 3);
}

uint64_t ProShade::UniformWorkspace::UniformWorkspace(uint64_t this, uint64_t a2)
{
  int v2 = (void *)this;
  *(_OWORD *)(this + 8) = 0u;
  int v3 = (char **)(this + 8);
  *(void *)this = a2;
  *(_OWORD *)(this + 24) = 0u;
  *(_OWORD *)(this + 40) = 0u;
  uint64_t v4 = *(void *)a2;
  if (*(void *)a2 != *(void *)(a2 + 8))
  {
    uint64_t v6 = *(_WORD **)(this + 16);
    unint64_t v5 = *(void *)(this + 24);
    if ((unint64_t)v6 >= v5)
    {
      uint64_t v8 = (char *)v6 - *v3;
      if (v8 <= -3) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v9 = v8 >> 1;
      unint64_t v10 = v5 - (void)*v3;
      if (v10 <= (v8 >> 1) + 1) {
        uint64_t v11 = (ProShade::UniformProgram *)(v9 + 1);
      }
      else {
        uint64_t v11 = (ProShade::UniformProgram *)v10;
      }
      if (v10 >= 0x7FFFFFFFFFFFFFFELL) {
        a2 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        a2 = (uint64_t)v11;
      }
      if (a2) {
        uint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<ProShade::UniformWorkspace::RegisterState>>(this + 24, a2);
      }
      else {
        uint64_t v12 = 0;
      }
      int v13 = &v12[2 * v9];
      *(_WORD *)int v13 = 0;
      uint64_t v7 = v13 + 2;
      int v15 = (char *)v2[1];
      uint64_t v14 = (char *)v2[2];
      if (v14 != v15)
      {
        do
        {
          __int16 v16 = *((_WORD *)v14 - 1);
          v14 -= 2;
          *((_WORD *)v13 - 1) = v16;
          v13 -= 2;
        }
        while (v14 != v15);
        uint64_t v14 = *v3;
      }
      v2[1] = v13;
      PCString v2[2] = v7;
      double v2[3] = &v12[2 * a2];
      if (v14) {
        operator delete(v14);
      }
    }
    else
    {
      *uint64_t v6 = 0;
      uint64_t v7 = v6 + 1;
    }
    PCString v2[2] = v7;
    ProShade::VarT<ProShade::Node>::bytes(v4, (const PCString *)a2);
    operator new[]();
  }
  return this;
}

void sub_1B7AA5A90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::shared_ptr<HGGPUComputeDevice const>>::__destroy_vector::operator()[abi:ne180100](&a9);
  uint64_t v12 = *v10;
  if (*v10)
  {
    *(void *)(v9 + 16) = v12;
    operator delete(v12);
  }
  _Unwind_Resume(a1);
}

void **std::vector<std::shared_ptr<char>>::push_back[abi:ne180100](uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  double result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    _OWORD v18[4] = result;
    uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::shared_ptr<HGGPUComputeDevice const>>>((uint64_t)result, v13);
    int v15 = &v14[16 * v10];
    v18[0] = v14;
    v18[1] = v15;
    void v18[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)int v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    v18[2] = v15 + 16;
    std::vector<std::shared_ptr<char>>::__swap_out_circular_buffer(a1, v18);
    uint64_t v9 = (void *)a1[1];
    double result = std::__split_buffer<std::shared_ptr<TXTextObject>>::~__split_buffer(v18);
  }
  else
  {
    *uint64_t v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_1B7AA5BDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::shared_ptr<TXTextObject>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

ProShade::UniformWorkspace *ProShade::UniformWorkspace::dirty(ProShade::UniformWorkspace *this, const ProShade::UniformProgram::Register *a2)
{
  int v2 = (unsigned char *)(*((void *)this + 1) + 2 * *((int *)a2 + 16));
  if (*v2)
  {
    unsigned char *v2 = 0;
    int v3 = (int *)*((void *)a2 + 12);
    uint64_t v4 = (int *)*((void *)a2 + 13);
    if (v3 != v4)
    {
      unint64_t v5 = this;
      do
      {
        unint64_t v6 = *v3;
        uint64_t v7 = **(void **)v5;
        if (0xEEEEEEEEEEEEEEEFLL * ((*(void *)(*(void *)v5 + 8) - v7) >> 3) <= v6) {
          std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
        }
        this = (ProShade::UniformWorkspace *)ProShade::UniformWorkspace::dirty(v5, (const ProShade::UniformProgram::Register *)(v7 + 120 * (int)v6));
        ++v3;
      }
      while (v3 != v4);
    }
  }
  return this;
}

uint64_t **ProShade::UniformWorkspace::setUniform(uint64_t **this, int a2)
{
  v31.var9 = (void *)*MEMORY[0x1E4F143B8];
  uint64_t v2 = **this;
  GLint v3 = *(_DWORD *)(v2 + 120 * a2 + 68);
  if ((v3 & 0x80000000) == 0)
  {
    unint64_t v5 = this;
    PCSharedCount::PCSharedCount((PCSharedCount *)&v31);
    uint64_t v7 = v2 + 120 * a2;
    uint64_t v8 = *(void *)(v7 + 16);
    uint64_t v9 = *(int *)(v7 + 64);
    uint64_t v10 = v5[1];
    unint64_t v11 = (unsigned __int8 *)v5[4][2 * v9];
    *((unsigned char *)v10 + 2 * v9 + 1) = 0;
    if (!v8) {
      throw_PCNullPointerException(1);
    }
    switch(*(_DWORD *)(v8 + 24))
    {
      case 0:
        exception = (PCException *)__cxa_allocate_exception(0x40uLL);
        PCException::PCException(exception);
        *(void *)exception = &unk_1F1199218;
      case 1:
        switch(*(_DWORD *)(v8 + 28))
        {
          case 1:
            glUniform1i(v3, *v11);
            break;
          case 2:
            glUniform2i(v3, *v11, v11[1]);
            break;
          case 3:
            glUniform3i(v3, *v11, v11[1], v11[2]);
            break;
          case 4:
            glUniform4i(v3, *v11, v11[1], v11[2], v11[3]);
            break;
          default:
            PCSharedCount v29 = (PCException *)__cxa_allocate_exception(0x40uLL);
            PCException::PCException(v29);
            *(void *)PCSharedCount v29 = &unk_1F1199218;
        }
        return this;
      case 2:
        switch(*(_DWORD *)(v8 + 28))
        {
          case 1:
            glUniform1i(v3, *(_DWORD *)v11);
            break;
          case 2:
            glUniform2i(v3, *(_DWORD *)v11, *((_DWORD *)v11 + 1));
            break;
          case 3:
            glUniform3i(v3, *(_DWORD *)v11, *((_DWORD *)v11 + 1), *((_DWORD *)v11 + 2));
            break;
          case 4:
            glUniform4i(v3, *(_DWORD *)v11, *((_DWORD *)v11 + 1), *((_DWORD *)v11 + 2), *((_DWORD *)v11 + 3));
            break;
          default:
            uint64_t v28 = (PCException *)__cxa_allocate_exception(0x40uLL);
            PCException::PCException(v28);
            *(void *)uint64_t v28 = &unk_1F1199218;
        }
        return this;
      case 3:
        switch(*(_DWORD *)(v8 + 28))
        {
          case 1:
            GLfloat v12 = *(double *)v11;
            glUniform1f(v3, v12);
            break;
          case 2:
            GLfloat v15 = *(double *)v11;
            GLfloat v16 = *((double *)v11 + 1);
            glUniform2f(v3, v15, v16);
            break;
          case 3:
            GLfloat v20 = *(double *)v11;
            GLfloat v21 = *((double *)v11 + 1);
            GLfloat v22 = *((double *)v11 + 2);
            glUniform3f(v3, v20, v21, v22);
            break;
          case 4:
            GLfloat v23 = *(double *)v11;
            GLfloat v24 = *((double *)v11 + 1);
            GLfloat v25 = *((double *)v11 + 2);
            GLfloat v26 = *((double *)v11 + 3);
            glUniform4f(v3, v23, v24, v25, v26);
            break;
          case 6:
            for (uint64_t i = 0; i != 9; ++i)
            {
              float v14 = *(double *)&v11[8 * i];
              *((float *)&v31.var1 + i) = v14;
            }
            glUniformMatrix3fv(v3, 1, 1u, (const GLfloat *)&v31.var1);
            break;
          case 7:
            for (uint64_t j = 0; j != 64; j += 16)
            {
              float64x2_t v19 = *(float64x2_t *)v11;
              float64x2_t v18 = *((float64x2_t *)v11 + 1);
              v11 += 32;
              *(float32x4_t *)((char *)&v31.var1 + j) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v19), v18);
            }
            glUniformMatrix4fv(v3, 1, 1u, (const GLfloat *)&v31.var1);
            break;
          default:
            int v30 = (PCException *)__cxa_allocate_exception(0x40uLL);
            PCException::PCException(v30);
            *(void *)int v30 = &unk_1F1199218;
        }
        return this;
      default:
        return (uint64_t **)OZChannelBase::setRangeName(&v31, v6);
    }
    return (uint64_t **)OZChannelBase::setRangeName(&v31, v6);
  }
  return this;
}

void sub_1B7AA60D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  __cxa_free_exception(v9);
  OZChannelBase::setRangeName((OZChannelBase *)&a9, v11);
  _Unwind_Resume(a1);
}

void *ProShade::UniformWorkspace::getValue(ProShade::UniformWorkspace *this, const ProShade::UniformProgram::Register *a2, ProShade::Value *a3)
{
  uint64_t v4 = *(const void **)(*((void *)this + 4) + 16 * *((int *)a2 + 16));
  uint64_t v5 = *((void *)a2 + 2);
  if (!v5) {
    throw_PCNullPointerException(1);
  }
  unint64_t v6 = (const PCString *)*(unsigned int *)(v5 + 24);
  int v7 = *(_DWORD *)(v5 + 28);

  return ProShade::Value::set((uint64_t)a3, v6, v7, v4);
}

uint64_t ProShade::UniformWorkspace::computeRegister(uint64_t **this, const ProShade::UniformProgram::Register *a2)
{
  void v23[16] = *(PCString *)MEMORY[0x1E4F143B8];
  uint64_t v3 = *((int *)a2 + 16);
  long long v17 = this[1];
  __dst = (BOOL *)this[4][2 * v3];
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  float64x2_t v19 = &unk_1F111DD98;
  unint64_t v4 = *((void *)a2 + 10) - *((void *)a2 + 9);
  if ((int)(v4 >> 2) >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = v4 & 0x3FFFFFFFCLL;
    do
    {
      unsigned int v8 = *(_DWORD *)(*((void *)a2 + 9) + v6);
      if ((v8 & 0x80000000) == 0)
      {
        uint64_t v9 = **this;
        if ((int)v20 <= SHIDWORD(v20)) {
          int v10 = (2 * (HIDWORD(v20) + 1)) | 1;
        }
        else {
          int v10 = v20;
        }
        PCArray<ProShade::Value,PCArray_Traits<ProShade::Value>>::resize(&v19, HIDWORD(v20) + 1, v10);
        ProShade::UniformWorkspace::getValue((ProShade::UniformWorkspace *)this, (const ProShade::UniformProgram::Register *)(v9 + 120 * v8), (ProShade::Value *)(v21 + 144 * SHIDWORD(v20) - 144));
      }
      v6 += 4;
    }
    while (v7 != v6);
  }
  ProShade::Value::Value(v22);
  uint64_t v11 = *((void *)a2 + 2);
  if (!v11) {
    throw_PCNullPointerException(1);
  }
  (*(void (**)(uint64_t, void **, int *))(*(void *)v11 + 112))(v11, &v19, v22);
  int Size = ProShade::shapeGetSize(v22[1], v12);
  uint64_t v14 = *((void *)a2 + 2);
  if (!v14) {
    throw_PCNullPointerException(1);
  }
  ProShade::copyData((void *)v22[0], v23, *(_DWORD *)(v14 + 24), __dst, Size);
  *((unsigned char *)v17 + 2 * v3) = 1;
  *((unsigned char *)v17 + 2 * v3 + 1) = 1;
  float64x2_t v19 = &unk_1F111DD98;
  if ((int)v20 < 0) {
    int v15 = 1;
  }
  else {
    int v15 = v20;
  }
  PCArray<ProShade::Value,PCArray_Traits<ProShade::Value>>::resize(&v19, 0, v15);
  uint64_t result = v21;
  if (v21) {
    return MEMORY[0x1BA9BFB70](v21, 0x1000C8077774924);
  }
  return result;
}

void sub_1B7AA63E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t PCArray<ProShade::Value,PCArray_Traits<ProShade::Value>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111DD98;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<ProShade::Value,PCArray_Traits<ProShade::Value>>::resize((void *)a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

uint64_t ProShade::UniformWorkspace::computeAllOutputs(uint64_t this)
{
  unint64_t v1 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*(void *)(*(void *)this + 8) - **(void **)this) >> 3);
  if ((int)v1 >= 1)
  {
    uint64_t v2 = this;
    uint64_t v3 = 0;
    uint64_t v4 = 120 * v1;
    do
    {
      uint64_t v5 = (int *)(**(void **)v2 + v3);
      if (!*(unsigned char *)(*(void *)(v2 + 8) + 2 * v5[16])) {
        this = ProShade::UniformWorkspace::computeRegister((uint64_t **)v2, (const ProShade::UniformProgram::Register *)v5);
      }
      v3 += 120;
    }
    while (v4 != v3);
  }
  return this;
}

uint64_t **ProShade::UniformWorkspace::sendChangedUniforms(uint64_t **this)
{
  unint64_t v1 = (int *)(*this)[6];
  uint64_t v2 = (int *)(*this)[7];
  if (v1 != v2)
  {
    uint64_t v3 = (uint64_t)this;
    do
    {
      if (*(unsigned char *)(*(void *)(v3 + 8) + 2 * *(int *)(**(void **)v3 + 120 * *v1 + 64) + 1)) {
        this = ProShade::UniformWorkspace::setUniform((uint64_t **)v3, *v1);
      }
      ++v1;
    }
    while (v1 != v2);
  }
  return this;
}

uint64_t *ProShade::UniformWorkspace::set(uint64_t **this, const ProShade::UniformNode *a2, int a3, const char *__s2)
{
  uint64_t result = *this;
  uint64_t v6 = (void *)result[4];
  if (v6)
  {
    unsigned int v8 = result + 4;
    do
    {
      unint64_t v9 = v6[4];
      BOOL v10 = v9 >= (unint64_t)a2;
      if (v9 >= (unint64_t)a2) {
        uint64_t v11 = v6;
      }
      else {
        uint64_t v11 = v6 + 1;
      }
      if (v10) {
        unsigned int v8 = v6;
      }
      uint64_t v6 = (void *)*v11;
    }
    while (*v11);
    if (v8 != result + 4 && v8[4] <= (unint64_t)a2)
    {
      unint64_t v12 = *((int *)v8 + 10);
      uint64_t v13 = *result;
      if (0xEEEEEEEEEEEEEEEFLL * ((result[1] - *result) >> 3) <= v12) {
        goto LABEL_18;
      }
      uint64_t v14 = *(int *)(v13 + 120 * (int)v12 + 64);
      *((_WORD *)this[1] + v14) = 257;
      int v15 = (void *)this[4][2 * v14];
      size_t v16 = a3;
      uint64_t result = (uint64_t *)memcmp(v15, __s2, a3);
      if (result)
      {
        uint64_t result = (uint64_t *)memcpy(v15, __s2, v16);
        uint64_t v17 = v13 + 120 * (int)v12;
        float64x2_t v18 = *(int **)(v17 + 96);
        float64x2_t v19 = *(int **)(v17 + 104);
        if (v18 != v19)
        {
          while (1)
          {
            unint64_t v20 = *v18;
            uint64_t v21 = **this;
            if (0xEEEEEEEEEEEEEEEFLL * (((*this)[1] - v21) >> 3) <= v20) {
              break;
            }
            uint64_t result = (uint64_t *)ProShade::UniformWorkspace::dirty((ProShade::UniformWorkspace *)this, (const ProShade::UniformProgram::Register *)(v21 + 120 * (int)v20));
            if (++v18 == v19) {
              return result;
            }
          }
LABEL_18:
          std::vector<unsigned int>::__throw_out_of_range[abi:ne180100]();
        }
      }
    }
  }
  return result;
}

uint64_t ProShade::UniformData::getCurrentContextUniformData(ProShade::UniformData *this)
{
  {
    qword_1E9EE5E28 = 0;
    qword_1E9EE5E20 = 0;
    ProShade::UniformData::getCurrentContextUniformData(void)::uniformDatSCNMatrix4 a = (uint64_t)&qword_1E9EE5E20;
    dword_1E9EE5E30 = 0;
    __cxa_atexit((void (*)(void *))LiPerContextObject<ProShade::UniformData>::~LiPerContextObject, &ProShade::UniformData::getCurrentContextUniformData(void)::uniformData, &dword_1B73F3000);
  }
  char v2 = 0;
  return *(void *)LiPerContext<ProShade::UniformData *,LiPerContextObject_Traits<ProShade::UniformData>,LiOpenGLContextGetter>::get((uint64_t)&ProShade::UniformData::getCurrentContextUniformData(void)::uniformData, &v2);
}

uint64_t LiPerContextObject<ProShade::UniformData>::~LiPerContextObject(uint64_t a1)
{
  char v2 = (void *)(a1 + 8);
  uint64_t v3 = *(void **)a1;
  if (*(void *)a1 != a1 + 8)
  {
    do
    {
      LiPerContextObject_Traits<ProShade::UniformData>::destroy(v3[6]);
      uint64_t v4 = (void *)v3[1];
      if (v4)
      {
        do
        {
          uint64_t v5 = v4;
          uint64_t v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          uint64_t v5 = (void *)v3[2];
          BOOL v6 = *v5 == (void)v3;
          uint64_t v3 = v5;
        }
        while (!v6);
      }
      uint64_t v3 = v5;
    }
    while (v5 != v2);
  }
  PCSpinLock::~PCSpinLock((PCSpinLock *)(a1 + 24));
  std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(a1, *(void **)(a1 + 8));
  return a1;
}

uint64_t *ProShade::UniformData::setWorkspaceGlobals(uint64_t *this, PCString *a2)
{
  char v2 = this + 1;
  uint64_t v3 = (const char *)*this;
  if ((uint64_t *)*this != this + 1)
  {
    do
    {
      uint64_t v5 = (const ProShade::UniformNode *)*((void *)v3 + 4);
      Allocint Size = ProShade::Value::getAllocSize((ProShade::Value *)(v3 + 40), a2);
      this = ProShade::UniformWorkspace::set((uint64_t **)a2, v5, AllocSize, v3 + 56);
      uint64_t v7 = (uint64_t *)*((void *)v3 + 1);
      if (v7)
      {
        do
        {
          unsigned int v8 = v7;
          uint64_t v7 = (uint64_t *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          unsigned int v8 = (uint64_t *)*((void *)v3 + 2);
          BOOL v9 = *v8 == (void)v3;
          uint64_t v3 = (const char *)v8;
        }
        while (!v9);
      }
      uint64_t v3 = (const char *)v8;
    }
    while (v8 != v2);
  }
  return this;
}

ProShade::UniformProgram::Register *ProShade::UniformProgram::Register::Register(ProShade::UniformProgram::Register *this)
{
  *(void *)this = &unk_1F11193B8;
  *((void *)this + 2) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 3);
  *((void *)this + 4) = &unk_1F11193B8;
  *((void *)this + 6) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 7);
  *((void *)this + 8) = -1;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  return this;
}

void sub_1B7AA692C(_Unwind_Exception *a1)
{
  *unint64_t v1 = v2;
  PCSharedCount::~PCSharedCount(v3);
  _Unwind_Resume(a1);
}

uint64_t ProShade::VarT<ProShade::Node>::bytes(uint64_t a1, const PCString *a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (!v2) {
    throw_PCNullPointerException(1);
  }
  int Size = ProShade::shapeGetSize(*(_DWORD *)(v2 + 28), a2);
  return ProShade::typeGetSize(*(_DWORD *)(v2 + 24), v4) * Size;
}

uint64_t LiPerContextObject_Traits<ProShade::UniformData>::destroy(uint64_t result)
{
  if (result)
  {
    std::__tree<std::__value_type<int,__CVBuffer *>,std::__map_value_compare<int,std::__value_type<int,__CVBuffer *>,std::less<int>,true>,std::allocator<std::__value_type<int,__CVBuffer *>>>::destroy(result, *(void **)(result + 8));
    JUMPOUT(0x1BA9BFBA0);
  }
  return result;
}

void std::vector<ProShade::UniformProgram::CompileNode>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (0x4EC4EC4EC4EC4EC5 * ((v6 - v7) >> 3) >= a2)
  {
    std::vector<ProShade::UniformProgram::CompileNode>::__construct_at_end((uint64_t)a1, a2);
  }
  else
  {
    uint64_t v8 = 0x4EC4EC4EC4EC4EC5 * ((v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x276276276276276) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0x4EC4EC4EC4EC4EC5 * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x13B13B13B13B13BLL) {
      unint64_t v11 = 0x276276276276276;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v19 = v4;
    if (v11) {
      unint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<ProShade::UniformProgram::CompileNode>>(v4, v11);
    }
    else {
      unint64_t v12 = 0;
    }
    uint64_t v13 = &v12[104 * v8];
    v16[0] = v12;
    v16[1] = v13;
    uint64_t v17 = v13;
    float64x2_t v18 = &v12[104 * v11];
    uint64_t v14 = 104 * a2;
    int v15 = &v13[104 * a2];
    do
    {
      std::allocator<ProShade::UniformProgram::CompileNode>::construct[abi:ne180100]<ProShade::UniformProgram::CompileNode>(v19, (uint64_t)v13);
      v13 += 104;
      v14 -= 104;
    }
    while (v14);
    uint64_t v17 = v15;
    std::vector<ProShade::UniformProgram::CompileNode>::__swap_out_circular_buffer(a1, v16);
    std::__split_buffer<ProShade::UniformProgram::CompileNode>::~__split_buffer(v16);
  }
}

void sub_1B7AA6B34(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<ProShade::UniformProgram::CompileNode>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void std::vector<ProShade::UniformProgram::CompileNode>::__construct_at_end(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (a2)
  {
    uint64_t v4 = v3 + 104 * a2;
    uint64_t v5 = 104 * a2;
    do
    {
      std::allocator<ProShade::UniformProgram::CompileNode>::construct[abi:ne180100]<ProShade::UniformProgram::CompileNode>(a1 + 16, v3);
      v3 += 104;
      v5 -= 104;
    }
    while (v5);
    uint64_t v3 = v4;
  }
  *(void *)(a1 + 8) = v3;
}

void sub_1B7AA6BC0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<ProShade::UniformProgram::CompileNode>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<ProShade::UniformProgram::CompileNode>,std::reverse_iterator<ProShade::UniformProgram::CompileNode*>,std::reverse_iterator<ProShade::UniformProgram::CompileNode*>,std::reverse_iterator<ProShade::UniformProgram::CompileNode*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void std::allocator<ProShade::UniformProgram::CompileNode>::construct[abi:ne180100]<ProShade::UniformProgram::CompileNode>(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + LiDepthSorter::stackSort((uint64_t)this + 56) = 0u;
  uint64_t v3 = (PCSharedCount *)(a2 + 56);
  *(_OWORD *)(a2 + 24) = 0u;
  *(void *)a2 = &unk_1F11193B8;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a2 + 24));
  *(void *)(a2 + 32) = &unk_1F11193B8;
  *(void *)(a2 + 48) = 0;
  PCSharedCount::PCSharedCount(v3);
  *(_DWORD *)(a2 + 64) = -1;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 72) = 0;
  *(_DWORD *)(a2 + 96) = -1;
}

void sub_1B7AA6CF4(_Unwind_Exception *a1)
{
  *uint64_t v1 = v3;
  PCSharedCount::~PCSharedCount(v2);
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<ProShade::UniformProgram::CompileNode>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x276276276276277) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(104 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<ProShade::UniformProgram::CompileNode>,std::reverse_iterator<ProShade::UniformProgram::CompileNode*>,std::reverse_iterator<ProShade::UniformProgram::CompileNode*>,std::reverse_iterator<ProShade::UniformProgram::CompileNode*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  float64x2_t v13[2] = &v16;
  char v14 = 0;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v9 = a3;
    do
    {
      v9 -= 104;
      std::allocator<ProShade::UniformProgram::CompileNode>::construct[abi:ne180100]<ProShade::UniformProgram::CompileNode,ProShade::UniformProgram::CompileNode const&>(a1, v7 - 104, v9);
      uint64_t v7 = *((void *)&v16 + 1) - 104;
      *((void *)&v16 + 1) -= 104;
    }
    while (v9 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<ProShade::UniformProgram::CompileNode>,std::reverse_iterator<ProShade::UniformProgram::CompileNode*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

void sub_1B7AA6E10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *std::allocator<ProShade::UniformProgram::CompileNode>::construct[abi:ne180100]<ProShade::UniformProgram::CompileNode,ProShade::UniformProgram::CompileNode const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a2 = &unk_1F11193B8;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(a3 + 8);
  *(void *)(a2 + 16) = *(void *)(a3 + 16);
  PCSharedCount::PCSharedCount((PCSharedCount *)(a2 + 24), (const PCSharedCount *)(a3 + 24));
  *(void *)(a2 + 32) = &unk_1F11193B8;
  *(unsigned char *)(a2 + 40) = *(unsigned char *)(a3 + 40);
  *(void *)(a2 + 48) = *(void *)(a3 + 48);
  PCSharedCount::PCSharedCount((PCSharedCount *)(a2 + 56), (const PCSharedCount *)(a3 + 56));
  int v5 = *(_DWORD *)(a3 + 64);
  *(void *)(a2 + 72) = 0;
  *(_DWORD *)(a2 + 64) = v5;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  uint64_t result = std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>((void *)(a2 + 72), *(const void **)(a3 + 72), *(void *)(a3 + 80), (uint64_t)(*(void *)(a3 + 80) - *(void *)(a3 + 72)) >> 2);
  *(_DWORD *)(a2 + 96) = *(_DWORD *)(a3 + 96);
  return result;
}

void sub_1B7AA6F10(_Unwind_Exception *a1)
{
  *uint64_t v6 = v4;
  PCSharedCount::~PCSharedCount(v5);
  *uint64_t v1 = v2;
  PCSharedCount::~PCSharedCount(v3);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<ProShade::UniformProgram::CompileNode>,std::reverse_iterator<ProShade::UniformProgram::CompileNode*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<ProShade::UniformProgram::CompileNode>,std::reverse_iterator<ProShade::UniformProgram::CompileNode*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<ProShade::UniformProgram::CompileNode>,std::reverse_iterator<ProShade::UniformProgram::CompileNode*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1 = *(PCSharedCount **)(a1[2] + 8);
  uint64_t v2 = *(PCSharedCount **)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      std::allocator<ProShade::UniformProgram::CompileNode>::destroy[abi:ne180100](v3, v1);
      v1 += 13;
    }
    while (v1 != v2);
  }
}

void std::allocator<ProShade::UniformProgram::CompileNode>::destroy[abi:ne180100](uint64_t a1, PCSharedCount *a2)
{
  unint64_t var0 = a2[9].var0;
  if (var0)
  {
    a2[10].unint64_t var0 = var0;
    operator delete(var0);
  }
  a2[4].unint64_t var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(a2 + 7);
  a2->unint64_t var0 = (PC_Sp_counted_base *)&unk_1F11193B8;

  PCSharedCount::~PCSharedCount(a2 + 3);
}

void **std::__split_buffer<ProShade::UniformProgram::CompileNode>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<ProShade::UniformProgram::CompileNode>::clear[abi:ne180100](void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 104;
    std::allocator<ProShade::UniformProgram::CompileNode>::destroy[abi:ne180100](v4, (PCSharedCount *)(i - 104));
  }
}

uint64_t std::vector<ProShade::UniformProgram::Register>::__push_back_slow_path<ProShade::UniformProgram::Register>(uint64_t *a1, uint64_t a2)
{
  unint64_t v3 = 0xEEEEEEEEEEEEEEEFLL * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x222222222222222) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  if (0xDDDDDDDDDDDDDDDELL * ((a1[2] - *a1) >> 3) > v4) {
    unint64_t v4 = 0xDDDDDDDDDDDDDDDELL * ((a1[2] - *a1) >> 3);
  }
  if (0xEEEEEEEEEEEEEEEFLL * ((a1[2] - *a1) >> 3) >= 0x111111111111111) {
    unint64_t v6 = 0x222222222222222;
  }
  else {
    unint64_t v6 = v4;
  }
  char v14 = a1 + 2;
  if (v6) {
    uint64_t v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<ProShade::UniformProgram::Register>>((uint64_t)(a1 + 2), v6);
  }
  else {
    uint64_t v7 = 0;
  }
  unint64_t v10 = v7;
  uint64_t v11 = &v7[120 * v3];
  uint64_t v13 = &v7[120 * v6];
  std::allocator<ProShade::UniformProgram::Register>::construct[abi:ne180100]<ProShade::UniformProgram::Register,ProShade::UniformProgram::Register>((uint64_t)(a1 + 2), (uint64_t)v11, a2);
  unint64_t v12 = v11 + 120;
  std::vector<ProShade::UniformProgram::Register>::__swap_out_circular_buffer(a1, &v10);
  uint64_t v8 = a1[1];
  std::__split_buffer<ProShade::UniformProgram::Register>::~__split_buffer(&v10);
  return v8;
}

void sub_1B7AA71C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<ProShade::UniformProgram::Register>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

__n128 std::allocator<ProShade::UniformProgram::Register>::construct[abi:ne180100]<ProShade::UniformProgram::Register,ProShade::UniformProgram::Register>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a2 = &unk_1F11193B8;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(a3 + 8);
  *(void *)(a2 + 16) = *(void *)(a3 + 16);
  PCSharedCount::PCSharedCount((PCSharedCount *)(a2 + 24), (const PCSharedCount *)(a3 + 24));
  *(void *)(a2 + 32) = &unk_1F11193B8;
  *(unsigned char *)(a2 + 40) = *(unsigned char *)(a3 + 40);
  *(void *)(a2 + 48) = *(void *)(a3 + 48);
  PCSharedCount::PCSharedCount((PCSharedCount *)(a2 + 56), (const PCSharedCount *)(a3 + 56));
  *(void *)(a2 + 64) = *(void *)(a3 + 64);
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  *(_OWORD *)(a2 + 72) = *(_OWORD *)(a3 + 72);
  *(void *)(a2 + 88) = *(void *)(a3 + 88);
  *(void *)(a3 + 72) = 0;
  *(void *)(a3 + 80) = 0;
  *(void *)(a3 + 88) = 0;
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  __n128 result = *(__n128 *)(a3 + 96);
  *(__n128 *)(a2 + 96) = result;
  *(void *)(a2 + 112) = *(void *)(a3 + 112);
  *(void *)(a3 + 96) = 0;
  *(void *)(a3 + 104) = 0;
  *(void *)(a3 + 112) = 0;
  return result;
}

void sub_1B7AA72C8(_Unwind_Exception *a1)
{
  *uint64_t v1 = v2;
  PCSharedCount::~PCSharedCount(v3);
  _Unwind_Resume(a1);
}

uint64_t std::vector<ProShade::UniformProgram::Register>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<ProShade::UniformProgram::Register>,std::reverse_iterator<ProShade::UniformProgram::Register*>,std::reverse_iterator<ProShade::UniformProgram::Register*>,std::reverse_iterator<ProShade::UniformProgram::Register*>>((uint64_t)(a1 + 2), a1[1], (const ProShade::UniformProgram::Register *)a1[1], *a1, (const ProShade::UniformProgram::Register *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<ProShade::UniformProgram::Register>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x222222222222223) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(120 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<ProShade::UniformProgram::Register>,std::reverse_iterator<ProShade::UniformProgram::Register*>,std::reverse_iterator<ProShade::UniformProgram::Register*>,std::reverse_iterator<ProShade::UniformProgram::Register*>>(uint64_t a1, uint64_t a2, const ProShade::UniformProgram::Register *a3, uint64_t a4, const ProShade::UniformProgram::Register *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  float64x2_t v12[2] = &v15;
  char v13 = 0;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v9 = a3;
    do
    {
      uint64_t v9 = (const ProShade::UniformProgram::Register *)((char *)v9 - 120);
      ProShade::UniformProgram::Register::Register((ProShade::UniformProgram::Register *)(v7 - 120), v9);
      uint64_t v7 = *((void *)&v15 + 1) - 120;
      *((void *)&v15 + 1) -= 120;
    }
    while (v9 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<ProShade::UniformProgram::Register>,std::reverse_iterator<ProShade::UniformProgram::Register*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

void sub_1B7AA7448(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

ProShade::UniformProgram::Register *ProShade::UniformProgram::Register::Register(ProShade::UniformProgram::Register *this, const ProShade::UniformProgram::Register *a2)
{
  *(void *)this = &unk_1F11193B8;
  *((unsigned char *)this + 8) = *((unsigned char *)a2 + 8);
  *((void *)this + 2) = *((void *)a2 + 2);
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 3, (const PCSharedCount *)a2 + 3);
  *((void *)this + 4) = &unk_1F11193B8;
  *((unsigned char *)this + 40) = *((unsigned char *)a2 + 40);
  *((void *)this + 6) = *((void *)a2 + 6);
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 7, (const PCSharedCount *)a2 + 7);
  uint64_t v4 = *((void *)a2 + 8);
  *((void *)this + 9) = 0;
  *((void *)this + 8) = v4;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>((void *)this + 9, *((const void **)a2 + 9), *((void *)a2 + 10), (uint64_t)(*((void *)a2 + 10) - *((void *)a2 + 9)) >> 2);
  *((void *)this + 12) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>((void *)this + 12, *((const void **)a2 + 12), *((void *)a2 + 13), (uint64_t)(*((void *)a2 + 13) - *((void *)a2 + 12)) >> 2);
  return this;
}

void sub_1B7AA7564(_Unwind_Exception *a1)
{
  uint64_t v9 = *v6;
  if (*v6)
  {
    v1[10] = v9;
    operator delete(v9);
  }
  *uint64_t v7 = v4;
  PCSharedCount::~PCSharedCount(v5);
  *uint64_t v1 = v2;
  PCSharedCount::~PCSharedCount(v3);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<ProShade::UniformProgram::Register>,std::reverse_iterator<ProShade::UniformProgram::Register*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<ProShade::UniformProgram::Register>,std::reverse_iterator<ProShade::UniformProgram::Register*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<ProShade::UniformProgram::Register>,std::reverse_iterator<ProShade::UniformProgram::Register*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1 = *(PCSharedCount **)(a1[2] + 8);
  uint64_t v2 = *(PCSharedCount **)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      std::allocator<ProShade::UniformProgram::Register>::destroy[abi:ne180100](v3, v1);
      v1 += 15;
    }
    while (v1 != v2);
  }
}

void **std::__split_buffer<ProShade::UniformProgram::Register>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<ProShade::UniformProgram::Register>::clear[abi:ne180100](void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 120;
    std::allocator<ProShade::UniformProgram::Register>::destroy[abi:ne180100](v4, (PCSharedCount *)(i - 120));
  }
}

void std::vector<ProShade::UniformProgram::CompileNode>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (PCSharedCount *)**a1;
  if (v2)
  {
    uint64_t v4 = (PCSharedCount *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 13;
        std::allocator<ProShade::UniformProgram::CompileNode>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<ProShade::UniformWorkspace::RegisterState>>(uint64_t a1, uint64_t a2)
{
  if (a2 < 0) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(2 * a2);
}

void std::shared_ptr<char>::shared_ptr[abi:ne180100]<char,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1B7AA77E4(_Unwind_Exception *exception_object)
{
  if (v1) {
    MEMORY[0x1BA9BFBA0](v1, 0x1000C4077774924);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<char *,std::shared_ptr<char>::__shared_ptr_default_delete<char,char>,std::allocator<char>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t std::__shared_ptr_pointer<char *,std::shared_ptr<char>::__shared_ptr_default_delete<char,char>,std::allocator<char>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    JUMPOUT(0x1BA9BFBA0);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<char *,std::shared_ptr<char>::__shared_ptr_default_delete<char,char>,std::allocator<char>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t std::vector<std::shared_ptr<char>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<char>>,std::reverse_iterator<std::shared_ptr<char>*>,std::reverse_iterator<std::shared_ptr<char>*>,std::reverse_iterator<std::shared_ptr<char>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<char>>,std::reverse_iterator<std::shared_ptr<char>*>,std::reverse_iterator<std::shared_ptr<char>*>,std::reverse_iterator<std::shared_ptr<char>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  float64x2_t v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      _OWORD *v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<char>>,std::reverse_iterator<std::shared_ptr<char>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<char>>,std::reverse_iterator<std::shared_ptr<char>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<TXTextObject>>,std::reverse_iterator<std::shared_ptr<TXTextObject>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void PCArray<ProShade::Value,PCArray_Traits<ProShade::Value>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111DD98;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<ProShade::Value,PCArray_Traits<ProShade::Value>>::resize((void *)a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

void *PCArray<ProShade::Value,PCArray_Traits<ProShade::Value>>::resize(void *result, int a2, int a3)
{
  if (a3 <= a2) {
    int v3 = a2;
  }
  else {
    int v3 = a3;
  }
  if (a2 < 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v15, "PCArray::resize");
    PCException::PCException(exception, &v15);
    *(void *)exception = &unk_1F1199218;
  }
  uint64_t v5 = result;
  if (v3 == *((_DWORD *)result + 2))
  {
    uint64_t v6 = *((int *)result + 3);
    if (a2 > (int)v6)
    {
      uint64_t v7 = 144 * v6;
      int v8 = a2 - v6;
      do
      {
        uint64_t result = ProShade::Value::Value((void *)(v5[2] + v7));
        v7 += 144;
        --v8;
      }
      while (v8);
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    int v9 = *((_DWORD *)result + 3);
    if (a2 >= v9) {
      int v10 = *((_DWORD *)result + 3);
    }
    else {
      int v10 = a2;
    }
    if (v10 < 1)
    {
      int v10 = 0;
    }
    else
    {
      uint64_t v11 = 0;
      do
      {
        ProShade::Value::Value(v11, (PCString *)((char *)v11 + v5[2]));
        v11 += 18;
      }
      while ((PCString *)(144 * v10) != v11);
      int v9 = *((_DWORD *)v5 + 3);
    }
    if (v10 > v9) {
      int v9 = v10;
    }
    if (v9 < a2)
    {
      uint64_t v12 = 144 * v9;
      unint64_t v13 = a2 - (unint64_t)v9;
      do
      {
        uint64_t v12 = (uint64_t)(ProShade::Value::Value((void *)v12) + 18);
        --v13;
      }
      while (v13);
    }
    uint64_t result = (void *)v5[2];
    if (result) {
      uint64_t result = (void *)MEMORY[0x1BA9BFB70](result, 0x1000C8077774924);
    }
    v5[2] = 0;
  }
  *((_DWORD *)v5 + 2) = v3;
  *((_DWORD *)v5 + 3) = a2;
  return result;
}

void sub_1B7AA7C54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

uint64_t LiPerContext<ProShade::UniformData *,LiPerContextObject_Traits<ProShade::UniformData>,LiOpenGLContextGetter>::get(uint64_t a1, unsigned char *a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a1 + 24);
  void v9[2] = a1 + 24;
  PCSpinLock::lock((os_unfair_lock_t)(a1 + 24));
  v9[1] = 0;
  v9[0] = LiGLState::getCurrentContext(v5);
  uint64_t v6 = std::__tree<std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>,std::__map_value_compare<LiOpenGLContextGetter::C,std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>,LiOpenGLContextGetter::Compare,true>,std::allocator<std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>>>::find<LiOpenGLContextGetter::C>(a1, v9);
  if (a1 + 8 == v6)
  {
    *a2 = 1;
    int v10 = v9;
    std::__tree<std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>,std::__map_value_compare<LiOpenGLContextGetter::C,std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>,LiOpenGLContextGetter::Compare,true>,std::allocator<std::__value_type<LiOpenGLContextGetter::C,ProShade::ProgramBase::Exe *>>>::__emplace_unique_key_args<LiOpenGLContextGetter::C,std::piecewise_construct_t const&,std::tuple<LiOpenGLContextGetter::C const&>,std::tuple<>>((uint64_t **)a1, v9, (uint64_t)&std::piecewise_construct, (_OWORD **)&v10);
    operator new();
  }
  *a2 = 0;
  uint64_t v7 = v6 + 48;
  PCSpinLock::unlock(v4);
  return v7;
}

void sub_1B7AA7D64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  PCLockSentry<PCSpinLock>::~PCLockSentry((os_unfair_lock_s **)va);
  _Unwind_Resume(a1);
}

void LiMaterialProperties::LiMaterialProperties(LiMaterialProperties *this)
{
  PCWorkingColorVector::PCWorkingColorVector(this);
  *(void *)(v2 + 16) = 0;
  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)(v2 + 24));
  *((void *)this + 5) = 0;
  PCWorkingColorVector::PCWorkingColorVector((LiMaterialProperties *)((char *)this + 48));
  PCWorkingColorVector::PCWorkingColorVector((LiMaterialProperties *)((char *)this + 64));
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  *((unsigned char *)this + 96) = 1;
  *(void *)((char *)this + 97) = 0;
  __asm { FMOV            V0.2D, #1.0 }
  *((_OWORD *)this + 7) = _Q0;
  *((void *)this + 16) = 0;
  *((void *)this + 17) = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  *((_OWORD *)this + 9) = _Q0;
  LiPolygon::LiPolygon((LiMaterialProperties *)((char *)this + 160));
  *((void *)this + 49) = 0x3FF0000000000000;
  *((void *)this + 44) = 0x3FF0000000000000;
  *((void *)this + 39) = 0x3FF0000000000000;
  *((void *)this + 33) = 0;
  *((void *)this + 34) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
}

void LiMaterialProperties::~LiMaterialProperties(LiMaterialProperties *this)
{
}

double *LiMaterialProperties::getZExtent@<X0>(double *a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  uint64_t v5 = 0;
  v14[12] = *(double *)MEMORY[0x1E4F143B8];
  double v6 = a2[1];
  double v7 = a2[2];
  double v8 = v6 + a2[3];
  v14[0] = *a2;
  v14[1] = v8;
  float64x2_t v14[2] = 0.0;
  PCSharedCount v14[3] = v14[0] + v7;
  v14[4] = v8;
  v14[5] = 0.0;
  v14[6] = v14[0];
  v14[7] = v6;
  _OWORD v14[8] = 0.0;
  void v14[9] = v14[0] + v7;
  v14[10] = v6;
  v14[11] = 0.0;
  double v9 = 1.79769313e308;
  double v10 = 2.22507386e-308;
  do
  {
    uint64_t result = PCMatrix44Tmpl<double>::transform<double>(a1, &v14[v5], &v14[v5]);
    uint64_t v11 = &v14[v5];
    double v13 = -v14[v5 + 2];
    if (v9 > v13) {
      double v9 = -v11[2];
    }
    if (v10 < v13) {
      double v10 = -v11[2];
    }
    v5 += 3;
  }
  while (v5 != 12);
  *a3 = v9;
  a3[1] = v10;
  return result;
}

double *LiMaterialProperties::getZExtent@<X0>(uint64_t a1@<X0>, double *a2@<X1>, double *a3@<X8>)
{
  return LiMaterialProperties::getZExtent(a2, (double *)(a1 + 128), a3);
}

uint64_t LiEdgeTexture::getDefaultResolution(LiEdgeTexture *this)
{
  return 64;
}

double LiEdgeTexture::erfc_filter(LiEdgeTexture *this, double a2, double a3)
{
  double v5 = a3 * 0.5;
  double v6 = erfc(a3 * 0.5 * 1.5);
  double v7 = a2 - v5;
  double v8 = 1.0;
  if (a2 - v5 > -(a3 * 0.5))
  {
    double v8 = 0.0;
    if (v7 < v5) {
      return (erfc(v7 * 1.5) * 0.5 - v6 * 0.5) / (1.0 - (v6 * 0.5 + v6 * 0.5));
    }
  }
  return v8;
}

long double LiEdgeTexture::smoothStep(LiEdgeTexture *this, double a2, double a3)
{
  long double result = 1.0;
  if (a2 >= 0.0)
  {
    long double result = 0.0;
    if (a2 <= 2.0)
    {
      long double v5 = (2.0 - a2) * 0.5;
      long double v6 = (pow(v5, 1.5) - v5) * ((1.0 - v5) * 0.5 + -0.5 + 1.0);
      return (v5 * 0.5 + -0.5 + 1.0) * (1.0 - pow(1.0 - v5, 1.5) - v5) + v5 + v6;
    }
  }
  return result;
}

double LiEdgeTexture::eval(LiEdgeTexture *a1, double a2, double a3)
{
  double result = 1.0;
  if (a2 > 0.0)
  {
    if (a2 >= a3)
    {
      return 0.0;
    }
    else
    {
      switch((int)a1)
      {
        case 0:
          if (a2 >= 0.5)
          {
            double result = 0.0;
            if (a2 <= 1.5) {
              double result = 1.5 - a2;
            }
          }
          break;
        case 1:
          double v5 = exp(a3 * a3 * -1.5);
          double result = (exp(fabs(a2 * a2) * -1.5) - v5) / (1.0 - v5);
          break;
        case 2:
          double result = 0.0;
          if (a2 < 2.0) {
            double result = (cos(a2 * 3.14159265 * 0.5) + 1.0) * 0.5;
          }
          break;
        case 3:
          double result = LiEdgeTexture::erfc_filter(a1, a2, a3);
          break;
        case 4:
          double result = 0.0;
          if (a2 < 2.0) {
            double result = sin(a2 * -0.96875 * 3.14159265 * 0.25) + 1.0;
          }
          break;
        case 5:
          double result = 0.0;
          if (a2 < 2.0)
          {
            float v6 = 2.0 - a2;
            double v7 = v6 * 0.96875 * 3.14159265 * 0.25;
            double result = sin(v7);
          }
          break;
        case 6:
          double result = LiEdgeTexture::smoothStep(a1, a2, a3);
          break;
        default:
          exception = (PCIllegalArgumentException *)__cxa_allocate_exception(0x40uLL);
          PCIllegalArgumentException::PCIllegalArgumentException(exception);
      }
    }
  }
  return result;
}

void sub_1B7AA82C4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void LiEdgeTexture::createHeliumBitmap(int a1@<W0>, LiEdgeTexture *a2@<X1>, int a3@<W2>, int32x4_t ***a4@<X8>, double a5@<D0>)
{
  if (a1) {
    uint64_t v10 = 28;
  }
  else {
    uint64_t v10 = 24;
  }
  uint64_t v11 = HGRectMake4i(0, 0, a3, a3);
  uint64_t v13 = v12;
  long long v14 = (int32x4_t **)HGObject::operator new(0x80uLL);
  HGBitmap::HGBitmap(v14, v11, v13, v10);
  *a4 = v14;
  if (a1)
  {
    int v15 = a3 - 1;
    if (a3 >= 1)
    {
      double v16 = a5 / (double)(a3 - 3);
      uint64_t v17 = v14[10];
      do
      {
        double v18 = LiEdgeTexture::eval(a2, v16 * (double)(v15 - 1), a5);
        int v19 = a3;
        do
        {
          double v20 = v18 * LiEdgeTexture::eval(a2, v16 * (double)(v19 - 2), a5);
          *(float *)&double v20 = v20;
          *(float *)&double v20 = fminf(fmaxf(*(float *)&v20, 0.0), 1.0);
          *v17++ = vdupq_lane_s32(*(int32x2_t *)&v20, 0);
          BOOL v21 = __OFSUB__(v19--, 1);
        }
        while (!((v19 < 0) ^ v21 | (v19 == 0)));
      }
      while (v15-- >= 1);
    }
  }
  else
  {
  }
}

void sub_1B7AA8440(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void anonymous namespace'::evalBitmap<unsigned char>(char *a1, int a2, int a3, LiEdgeTexture *a4, double a5)
{
  int v5 = a3 - 1;
  if (a3 >= 1)
  {
    double v11 = a5 / (double)(a3 - 3);
    size_t v12 = a2;
    uint64_t v13 = (a2 - 1) + 1;
    do
    {
      int v14 = v5--;
      double v15 = LiEdgeTexture::eval(a4, v11 * (double)v5, a5);
      for (int i = a3; i >= 1; --i)
      {
        double v17 = LiEdgeTexture::eval(a4, v11 * (double)(i - 2), a5);
        if (a2 >= 1)
        {
          int v18 = vcvtmd_s64_f64(v15 * v17 * 255.0 + 0.5 + 0.0000001);
          int v19 = v18 & ~(v18 >> 31);
          if (v19 >= 255) {
            int v20 = 255;
          }
          else {
            int v20 = v19;
          }
          memset(a1, v20, v12);
          a1 += v13;
        }
      }
    }
    while (v14 >= 1);
  }
}

int32x4_t **LiEdgeTexture::createHeliumNode@<X0>(const void *a1@<X0>, LiEdgeTexture *a2@<X1>, HGBitmapLoader **a3@<X8>)
{
  if (!a1) {
    goto LABEL_7;
  }
  if (!v5) {
    goto LABEL_7;
  }
  float v6 = v5;
  int v7 = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(void *)v5 + 128))(v5, 43);
  int v8 = (*(uint64_t (**)(HGGPURenderer *, uint64_t))(*(void *)v6 + 128))(v6, 43);
  if (!v7)
  {
    HGGPURenderer::GetCurrentContext(v6, (uint64_t *)&v17);
    v15.unint64_t var0 = v17.var0;
    LiEdgeTexture::createProGLTexture(&v15.var0);
  }
  if (v8 == 1)
  {
    LiEdgeTexture::createMetalTexture(v6, a2, 64, (HGMetalTexture **)&v16, 2.0);
    double v9 = (HGBitmap *)v16;
    uint64_t v10 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
    HGBitmapLoader::HGBitmapLoader(v10, v9);
    *a3 = v10;
    double result = v16;
    if (v16) {
      return (int32x4_t **)((uint64_t (*)(int32x4_t **))(*v16)[1].i64[1])(v16);
    }
  }
  else
  {
LABEL_7:
    LiEdgeTexture::createHeliumBitmap(1, a2, 64, &v16, 2.0);
    size_t v12 = v16;
    uint64_t v13 = (HGTexture *)HGObject::operator new(0x80uLL);
    HGTexture::HGTexture(v13, *(HGRect *)((char *)v12 + 20), (HGBitmap *)v12);
    int v14 = (HGBitmapLoader *)HGObject::operator new(0x1F0uLL);
    HGBitmapLoader::HGBitmapLoader(v14, (HGBitmap *)v13);
    *a3 = v14;
    if (v13) {
      (*(void (**)(HGTexture *))(*(void *)v13 + 24))(v13);
    }
    return (int32x4_t **)((uint64_t (*)(int32x4_t **))(*v12)[1].i64[1])(v12);
  }
  return result;
}

void sub_1B7AA8818(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCSharedCount a11, uint64_t a12, uint64_t a13, PCSharedCount a14)
{
  HGObject::operator delete(v14);
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 24))(a12);
  }
  _Unwind_Resume(a1);
}

void LiEdgeTexture::createProGLTexture(PC_Sp_counted_base **a1)
{
  getLiEdgeTextureLock();
  uint64_t v4 = &getLiEdgeTextureLock(void)::sLiEdgeTextureLock;
  uint64_t v2 = (_anonymous_namespace_::EdgeTextureCache *)PCMutex::lock(&getLiEdgeTextureLock(void)::sLiEdgeTextureLock);
  char v5 = 1;
  v3.unint64_t var0 = *a1;
  HGGLContext::Share();
}

void sub_1B7AA8CFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, PCSharedCount a18, char a19, uint64_t a20,char a21)
{
  if (v22)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v22);
    std::__shared_weak_count::__release_shared[abi:ne180100](v22);
  }
  GLfloat v25 = *(std::__shared_weak_count **)(v21 + 8);
  if (v25) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v25);
  }
  ProGL::GL::~GL((ProGL::GL *)&a11);
  ProGL::ContextHandle::~ContextHandle((ProGL::ContextHandle *)&a16);
  HGGLSetCurrentContextGuard::~HGGLSetCurrentContextGuard((HGGLSetCurrentContextGuard *)&a19);
  PCBitmap::~PCBitmap((PCBitmap *)&a21);
  uint64_t v26 = *(void *)(v23 - 144);
  if (v26) {
    (*(void (**)(uint64_t))(*(void *)v26 + 24))(v26);
  }
  PCLockSentry<PCMutex>::~PCLockSentry(v23 - 136);
  _Unwind_Resume(a1);
}

uint64_t LiEdgeTexture::createMetalTexture@<X0>(HGGPURenderer *a1@<X0>, LiEdgeTexture *a2@<X1>, int a3@<W2>, HGMetalTexture **a4@<X8>, double a5@<D0>)
{
  getLiEdgeTextureLock();
  v31[1] = (int32x4_t **)&getLiEdgeTextureLock(void)::sLiEdgeTextureLock;
  uint64_t v10 = (_anonymous_namespace_::EdgeTextureCache *)PCMutex::lock(&getLiEdgeTextureLock(void)::sLiEdgeTextureLock);
  char v32 = 1;
  MetalContext = (PCICCTransferFunctionLUT *)HGGPURenderer::GetMetalContext(a1);
  uint64_t LUTEnd = PCICCTransferFunctionLUT::getLUTEnd(MetalContext);
  int v14 = 0;
  uint64_t v15 = *(void *)(LUTEnd + 24);
  int v16 = *(_DWORD *)(v11 + 204);
  while (1)
  {
    int v17 = v16 + v14 <= 0 ? -(-(v16 + v14) & 3) : (v16 + v14) & 3;
    uint64_t v18 = v11 + 48 * v17;
    int v19 = *(_DWORD *)(v18 + 8);
    int v20 = *(_DWORD *)(v18 + 32);
    uint64_t v21 = *(void *)(v18 + 48);
    BOOL v22 = v19 == a2 && v20 == -1;
    if (v22 && v21 == v15) {
      break;
    }
    if (++v14 == 4)
    {
      LiEdgeTexture::createHeliumBitmap(1, a2, a3, v31, a5);
      GLfloat v24 = (HGMetalContext *)HGGPURenderer::GetMetalContext(a1);
      GLfloat v25 = (uint64_t *)HGMetalContext::texturePool(v24);
      uint64_t v26 = HGGPURenderer::GetMetalContext(a1);
      char v27 = v31[0];
      HGMetalTexture::createWithCopy(*(void **)(*(void *)(v26 + 16) + 16), v25, (uint64_t)v31[0], *(uint64_t *)((char *)v31[0] + 20), *(uint64_t *)((char *)v31[0] + 28), 0, 0, a4);
      uint64_t v28 = *a4;
      if (*a4) {
        (*(void (**)(HGMetalTexture *))(*(void *)v28 + 16))(*a4);
      }
      PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)&v34);
      uint64_t v33 = v28;
      if (v28) {
        (*(void (**)(HGMetalTexture *))(*(void *)v28 + 16))(v28);
      }
      if (v28) {
        (*(void (**)(HGMetalTexture *))(*(void *)v28 + 24))(v28);
      }
      if (v35) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v35);
      }
      if (v28) {
        (*(void (**)(HGMetalTexture *))(*(void *)v28 + 24))(v28);
      }
      ((void (*)(int32x4_t **))(*v27)[1].i64[1])(v27);
      return PCMutex::unlock(&getLiEdgeTextureLock(void)::sLiEdgeTextureLock);
    }
  }
  *(_DWORD *)(v11 + 204) = v17;
  PCSharedCount v29 = *(HGMetalTexture **)(v11 + 48 * v17 + 40);
  *a4 = v29;
  if (v29) {
    (*(void (**)(HGMetalTexture *))(*(void *)v29 + 16))(v29);
  }
  return PCMutex::unlock(&getLiEdgeTextureLock(void)::sLiEdgeTextureLock);
}

void sub_1B7AA9088(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCLockSentry<PCMutex>::~PCLockSentry((uint64_t)va);
  _Unwind_Resume(a1);
}

void LiEdgeTexture::createArray(uint64_t a1@<X8>)
{
}

void sub_1B7AA9258(_Unwind_Exception *exception_object)
{
  if (*v1) {
    HGArrayData::Release(*v1);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *setUseLiEdgeTextureNodeCache(char a1)
{
  getEdgeTextureUseFlag();
  double result = PCThreadLocalValue<BOOL>::getValuePtr(&getEdgeTextureUseFlag(void)::result);
  *double result = a1;
  return result;
}

void getEdgeTextureUseFlag(void)
{
  {
    byte_1E9EE5E68 = 1;
    pthread_key_create(&getEdgeTextureUseFlag(void)::result, (void (__cdecl *)(void *))PCThreadLocalValue<BOOL>::destroy);
  }
}

void sub_1B7AA932C(_Unwind_Exception *a1)
{
}

uint64_t getUseLiEdgeTextureNodeCache(void)
{
  return *(unsigned __int8 *)PCThreadLocalValue<BOOL>::getValuePtr(&getEdgeTextureUseFlag(void)::result);
}

void getLiEdgeTextureLock(void)
{
  {
    PCMutex::PCMutex(&getLiEdgeTextureLock(void)::sLiEdgeTextureLock, 1);
    getLiEdgeTextureLock(void)::sLiEdgeTextureLock._vptr$PCMutex = (void **)&unk_1F10933F0;
    __cxa_atexit((void (*)(void *))PCRecursiveMutex::~PCRecursiveMutex, &getLiEdgeTextureLock(void)::sLiEdgeTextureLock, &dword_1B73F3000);
  }
}

void sub_1B7AA941C(_Unwind_Exception *a1)
{
}

uint64_t anonymous namespace'::EdgeTextureCache::instance(_anonymous_namespace_::EdgeTextureCache *this)
{
  {
    operator new();
  }
}

void sub_1B7AA94CC(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C401995F540);
  _Unwind_Resume(a1);
}

PCMutex *LiEdgeTexture::getHeliumNode@<X0>(const void *a1@<X0>, LiEdgeTexture *a2@<X1>, HGBitmapLoader **a3@<X8>)
{
  getLiEdgeTextureLock();
  PCMutex::lock(&getLiEdgeTextureLock(void)::sLiEdgeTextureLock);
  getEdgeTextureUseFlag();
  if (*(unsigned char *)PCThreadLocalValue<BOOL>::getValuePtr(&getEdgeTextureUseFlag(void)::result))
  {
    {
    }
    {
    }
    {
      getCache();
      LiEdgeTexture::getHeliumNode(HGRenderer *,LiEdgeTexture::Kernel)::cache = (uint64_t)&getCache(void)::cache;
    }
    for (int i = 0; i != 4; ++i)
    {
      if (i + getLast(void)::last <= 0) {
        int v7 = -(-(i + getLast(void)::last) & 3);
      }
      else {
        int v7 = (i + getLast(void)::last) & 3;
      }
      uint64_t v8 = LiEdgeTexture::getHeliumNode(HGRenderer *,LiEdgeTexture::Kernel)::cache;
      uint64_t v9 = LiEdgeTexture::getHeliumNode(HGRenderer *,LiEdgeTexture::Kernel)::cache + 32 * v7;
      if (*(const void **)(v9 + 8) == a1 && *(_DWORD *)(v9 + 20) == a2)
      {
        int v10 = *(_DWORD *)(LiEdgeTexture::getHeliumNode(HGRenderer *,LiEdgeTexture::Kernel)::cache + 32 * v7 + 16);
        if (v10 == (*(unsigned int (**)(const void *, uint64_t))(*(void *)a1 + 128))(a1, 43))
        {
          getLast(void)::last = v7;
          uint64_t v33 = *(HGBitmapLoader **)(v8 + 32 * v7);
          *a3 = v33;
          if (v33) {
            (*(void (**)(HGBitmapLoader *))(*(void *)v33 + 16))(v33);
          }
          goto LABEL_46;
        }
      }
    }
    LiEdgeTexture::createHeliumNode(a1, a2, a3);
    int v11 = 0;
    uint64_t v12 = LiEdgeTexture::getHeliumNode(HGRenderer *,LiEdgeTexture::Kernel)::cache;
    int v13 = -1;
    int v14 = -1;
    do
    {
      if (getLast(void)::last + v11 <= 0) {
        int v15 = -(-(getLast(void)::last + v11) & 3);
      }
      else {
        int v15 = (getLast(void)::last + v11) & 3;
      }
      uint64_t v16 = LiEdgeTexture::getHeliumNode(HGRenderer *,LiEdgeTexture::Kernel)::cache + 32 * v15;
      int v17 = *(const void **)(v16 + 8);
      if (v17 == a1 || v17 == 0)
      {
        int v19 = *(_DWORD *)(v16 + 24);
        if (v13 == -1 || v13 > v19)
        {
          int v14 = v15;
          int v13 = v19;
        }
      }
      ++v11;
    }
    while (v11 != 4);
    if (v14 != -1)
    {
      uint64_t v22 = v14;
      uint64_t v23 = LiEdgeTexture::getHeliumNode(HGRenderer *,LiEdgeTexture::Kernel)::cache + 32 * v14;
      getLast(void)::last = v14;
      *(_DWORD *)(v23 + 24) = ++getSerial(void)::serial;
      if (a1)
      {
        (*(void (**)(const void *))(*(void *)a1 + 16))(a1);
        uint64_t v24 = v12 + 32 * v22;
        char v27 = *(const void **)(v24 + 8);
        uint64_t v26 = (void *)(v24 + 8);
        GLfloat v25 = v27;
        if (v27 == a1)
        {
          (*(void (**)(const void *))(*(void *)a1 + 24))(a1);
LABEL_40:
          int v28 = (*(uint64_t (**)(const void *, uint64_t))(*(void *)a1 + 128))(a1, 43);
          uint64_t v29 = v12 + 32 * v22;
          *(_DWORD *)(v29 + 16) = v28;
          uint64_t v30 = *(void *)v23;
          OZChannelBase v31 = *a3;
          if (*(HGBitmapLoader **)v23 != *a3)
          {
            if (v30)
            {
              (*(void (**)(void))(*(void *)v30 + 24))(*(void *)v23);
              OZChannelBase v31 = *a3;
            }
            *(void *)uint64_t v23 = v31;
            if (v31) {
              (*(void (**)(HGBitmapLoader *))(*(void *)v31 + 16))(v31);
            }
          }
          *(_DWORD *)(v29 + 20) = a2;
          goto LABEL_46;
        }
      }
      else
      {
        uint64_t v26 = (void *)(v23 + 8);
        GLfloat v25 = *(const void **)(v23 + 8);
        if (!v25) {
          goto LABEL_40;
        }
      }
      if (v25) {
        (*(void (**)(const void *))(*(void *)v25 + 24))(v25);
      }
      *uint64_t v26 = a1;
      goto LABEL_40;
    }
  }
  else
  {
    LiEdgeTexture::createHeliumNode(a1, a2, a3);
  }
LABEL_46:
  double result = &getLiEdgeTextureLock(void)::sLiEdgeTextureLock;
  if (&getLiEdgeTextureLock(void)::sLiEdgeTextureLock) {
    return (PCMutex *)PCMutex::unlock(&getLiEdgeTextureLock(void)::sLiEdgeTextureLock);
  }
  return result;
}

void sub_1B7AA9904(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void getCache(void)
{
  {
    for (uint64_t i = 0; i != 128; i += 32)
    {
      uint64_t v1 = (char *)&getCache(void)::cache + i;
      *((_DWORD *)v1 + 6) = 0;
      *(void *)uint64_t v1 = 0;
      *((void *)v1 + 1) = 0;
    }
    __cxa_atexit((void (*)(void *))__cxx_global_array_dtor_0, 0, &dword_1B73F3000);
  }
}

uint64_t PCThreadLocalValue<BOOL>::destroy(uint64_t result)
{
  if (result) {
    JUMPOUT(0x1BA9BFBA0);
  }
  return result;
}

_anonymous_namespace_::EdgeTextureCache *anonymous namespace'::EdgeTextureCache::EdgeTextureCache(_anonymous_namespace_::EdgeTextureCache *this)
{
  PCSingleton::PCSingleton(this, 0);
  uint64_t v2 = 0;
  *PCSharedCount v3 = &unk_1F111DDD0;
  do
  {
    uint64_t v4 = (char *)this + v2;
    *(void *)((char *)this + v2 + 8) = 7;
    PCWorkingColorVector::PCWorkingColorVector((_anonymous_namespace_::EdgeTextureCache *)((char *)this + v2 + 16));
    *((_DWORD *)v4 + 8) = -1;
    *((void *)v4 + 5) = 0;
    *((void *)v4 + 6) = -1;
    v2 += 48;
  }
  while (v2 != 192);
  *((void *)this + 25) = 1;
  return this;
}

void sub_1B7AA9AF8(_Unwind_Exception *a1)
{
  for (; v2; v2 -= 48)
  {
    uint64_t v4 = *(void *)((char *)v1 + v2 - 8);
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
    }
    char v5 = *(std::__shared_weak_count **)((char *)v1 + v2 - 24);
    if (v5) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v5);
    }
  }
  PCSingleton::~PCSingleton(v1);
  _Unwind_Resume(a1);
}

void anonymous namespace'::EdgeTextureCache::~EdgeTextureCache(_anonymous_namespace_::EdgeTextureCache *this)
{
  uint64_t v2 = 0;
  *(void *)this = &unk_1F111DDD0;
  do
  {
    uint64_t v3 = *(void *)((char *)this + v2 + 184);
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
    }
    uint64_t v4 = *(std::__shared_weak_count **)((char *)this + v2 + 168);
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    }
    v2 -= 48;
  }
  while (v2 != -192);

  PCSingleton::~PCSingleton(this);
}

{
  uint64_t v2;
  uint64_t v3;
  std::__shared_weak_count *v4;
  uint64_t vars8;

  uint64_t v2 = 0;
  *(void *)this = &unk_1F111DDD0;
  while (1)
  {
    uint64_t v3 = *(void *)((char *)this + v2 + 184);
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
    }
    uint64_t v4 = *(std::__shared_weak_count **)((char *)this + v2 + 168);
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    }
    v2 -= 48;
    if (v2 == -192)
    {
      PCSingleton::~PCSingleton(this);
      JUMPOUT(0x1BA9BFBA0);
    }
  }
}

uint64_t anonymous namespace'::EdgeTextureCache::setCacheEntry(uint64_t a1, int a2, uint64_t *a3, int a4, uint64_t *a5, uint64_t a6)
{
  int v12 = 0;
  int v13 = *(_DWORD *)(a1 + 204);
  int v14 = -1;
  int v15 = -1;
  do
  {
    if (v13 + v12 <= 0) {
      int v16 = -(-(v13 + v12) & 3);
    }
    else {
      int v16 = (v13 + v12) & 3;
    }
    if (v12) {
      BOOL v17 = v15 <= *(_DWORD *)(a1 + 48 * v16 + 12);
    }
    else {
      BOOL v17 = 0;
    }
    if (!v17)
    {
      int v15 = *(_DWORD *)(a1 + 48 * v16 + 12);
      int v14 = v16;
    }
    ++v12;
  }
  while (v12 != 4);
  int v19 = v14;
  uint64_t v20 = a1 + 48 * v14;
  *(_DWORD *)(a1 + 204) = v14;
  LiEdgeTextureCacheEntry::reset((LiEdgeTextureCacheEntry *)(v20 + 8));
  int v21 = *(_DWORD *)(a1 + 200) + 1;
  *(_DWORD *)(a1 + 200) = v21;
  *(_DWORD *)(v20 + 8) = a2;
  *(_DWORD *)(v20 + 12) = v21;
  uint64_t v23 = *a3;
  uint64_t v22 = a3[1];
  if (v22) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v24 = *(std::__shared_weak_count **)(v20 + 24);
  *(void *)(v20 + 16) = v23;
  *(void *)(v20 + 24) = v22;
  if (v24) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v24);
  }
  uint64_t v25 = a1 + 48 * v19;
  uint64_t v28 = *(void *)(v25 + 40);
  char v27 = (uint64_t *)(v25 + 40);
  uint64_t v26 = v28;
  *((_DWORD *)v27 - 2) = a4;
  uint64_t result = *a5;
  if (v28 != *a5)
  {
    if (v26)
    {
      (*(void (**)(uint64_t))(*(void *)v26 + 24))(v26);
      uint64_t result = *a5;
    }
    *char v27 = result;
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
    }
  }
  *(void *)(a1 + 48 * v19 + 48) = a6;
  return result;
}

uint64_t LiEdgeTextureCacheEntry::reset(LiEdgeTextureCacheEntry *this)
{
  *(void *)this = 7;
  PCWorkingColorVector::PCWorkingColorVector((PCWorkingColorVector *)&v5);
  long long v2 = v5;
  long long v5 = 0uLL;
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 2);
  *(_OWORD *)((char *)this + 8) = v2;
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    if (*((void *)&v5 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v5 + 1));
    }
  }
  *((_DWORD *)this + 6) = -1;
  uint64_t result = *((void *)this + 4);
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
  }
  *((void *)this + 4) = 0;
  *((void *)this + 5) = -1;
  return result;
}

uint64_t HGArrayData::Release(uint64_t this)
{
  unsigned int add = atomic_fetch_add((atomic_uint *volatile)this, 0xFFFFFFFF);
  if (this && add == 1)
  {
    uint64_t v2 = *(void *)(this + 16);
    if (v2) {
      MEMORY[0x1BA9BFB70](v2, 0x1000C8077774924);
    }
    JUMPOUT(0x1BA9BFBA0);
  }
  return this;
}

uint64_t HGArrayData::allocate(uint64_t this, int a2)
{
  if (*(_DWORD *)(this + 12) != a2)
  {
    uint64_t v2 = this;
    int v3 = *(_DWORD *)(this + 4) * a2;
    *(_DWORD *)(this + 12) = a2;
    if (v3) {
      operator new[]();
    }
    this = *(void *)(this + 16);
    if (this) {
      this = MEMORY[0x1BA9BFB70](this, 0x1000C8077774924);
    }
    *(void *)(v2 + 16) = 0;
  }
  return this;
}

void *PCThreadLocalValue<BOOL>::getValuePtr(pthread_key_t *a1)
{
  uint64_t v1 = pthread_getspecific(*a1);
  if (!v1) {
    operator new();
  }
  return v1;
}

uint64_t __cxx_global_array_dtor_0()
{
  for (uint64_t i = 0; i != -128; i -= 32)
  {
    uint64_t v1 = *(void *)((char *)&getCache(void)::cache + i + 104);
    if (v1) {
      (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
    }
    uint64_t result = *(void *)((char *)&getCache(void)::cache + i + 96);
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
    }
  }
  return result;
}

void LiGroup::LiGroup(LiGroup *this, uint64_t *a2)
{
  LiSceneObject::LiSceneObject(this, a2 + 1);
  uint64_t v4 = *a2;
  uint64_t *v5 = *a2;
  *(void *)((char *)this + *(void *)(v4 - 24)) = a2[5];
  *((void *)this + 71) = &unk_1F111E0E8;
  *((void *)this + 75) = 0;
  *((void *)this + 73) = 0;
  *((void *)this + 72) = 0;
  *(_DWORD *)((char *)this + 591) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 76);
  *((unsigned char *)this + 616) = 0;
  PCWorkingColorVector::PCWorkingColorVector((LiGroup *)((char *)this + 620));
  *((_DWORD *)this + 159) = 1065353216;
  *((_WORD *)this + 320) = 257;
  *((unsigned char *)this + 642) = 0;
  *((_WORD *)this + 322) = 257;
  *((_DWORD *)this + 121) = 34;
}

void sub_1B7AAA22C(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v4);
  PCArray<PCPtr<LiSceneObject>,PCArray_Traits<PCPtr<LiSceneObject>>>::~PCArray(v3);
  LiSceneObject::~LiSceneObject(v1, v2);
  _Unwind_Resume(a1);
}

uint64_t PCArray<PCPtr<LiSceneObject>,PCArray_Traits<PCPtr<LiSceneObject>>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111E0E8;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<PCPtr<LiImageFilter>,PCArray_Traits<PCPtr<LiImageFilter>>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

void LiGroup::LiGroup(LiGroup *this)
{
  *((void *)this + 81) = &unk_1F1199AC8;
  *((void *)this + 82) = 0;
  *((unsigned char *)this + 664) = 1;
  LiSceneObject::LiSceneObject(this, (uint64_t *)&off_1F111DF60);
  *(void *)this = &unk_1F111DE10;
  *((void *)this + 81) = &unk_1F111DF40;
  *((void *)this + 71) = &unk_1F111E0E8;
  *((void *)this + 75) = 0;
  *((void *)this + 73) = 0;
  *((void *)this + 72) = 0;
  *(_DWORD *)((char *)this + 591) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)this + 76);
  *((unsigned char *)this + 616) = 0;
  PCWorkingColorVector::PCWorkingColorVector((LiGroup *)((char *)this + 620));
  *((_DWORD *)this + 159) = 1065353216;
  *((_WORD *)this + 320) = 257;
  *((unsigned char *)this + 642) = 0;
  *((_WORD *)this + 322) = 257;
  *((_DWORD *)this + 121) = 34;
}

void sub_1B7AAA3E0(_Unwind_Exception *a1)
{
  long long v5 = v4;
  PCSharedCount::~PCSharedCount(v5);
  PCArray<PCPtr<LiSceneObject>,PCArray_Traits<PCPtr<LiSceneObject>>>::~PCArray(v3);
  LiSceneObject::~LiSceneObject((PCSharedCount *)v1, (PC_Sp_counted_base **)&off_1F111DF60);
  *(void *)(v1 + 648) = v2;
  *(unsigned char *)(v1 + 664) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 656));
  _Unwind_Resume(a1);
}

void LiGroup::~LiGroup(PCSharedCount *this, PCSharedCount *a2)
{
  unint64_t var0 = a2->var0;
  this->unint64_t var0 = a2->var0;
  *(PCSharedCount *)((char *)this + *((void *)var0 - 3)) = a2[5];
  PCSharedCount::~PCSharedCount(this + 76);
  this[71].unint64_t var0 = (PC_Sp_counted_base *)&unk_1F111E0E8;
  if (SLODWORD(this[72].var0) < 0) {
    int v5 = 1;
  }
  else {
    int v5 = (int)this[72].var0;
  }
  PCArray<PCPtr<LiImageFilter>,PCArray_Traits<PCPtr<LiImageFilter>>>::resize((uint64_t)&this[71], 0, v5);
  float v6 = this[73].var0;
  if (v6) {
    MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
  }
  this[73].unint64_t var0 = 0;
  LODWORD(this[72].var0) = 0;

  LiSceneObject::~LiSceneObject(this, &a2[1].var0);
}

void LiGroup::~LiGroup(PCSharedCount *this)
{
  *(void *)(v1 + 648) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 664) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 656));
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)(v1 + 648) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 664) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 656));

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'LiGroup::~LiGroup(LiGroup *this)
{
  *(void *)(v1 + 648) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 664) = 0;
  uint64_t v2 = (PC_Sp_counted_base **)(v1 + 656);

  PCWeakCount::~PCWeakCount(v2);
}

{
  LiGroup::~LiGroup((PCSharedCount *)((char *)this + *(void *)(*(void *)this - 24)));
}

unsigned int *LiGroup::localBoundingBox(unsigned int *result, double *a2)
{
  *((_OWORD *)a2 + 1) = xmmword_1B7E736F0;
  *((_OWORD *)a2 + 2) = xmmword_1B7E736F0;
  *(_OWORD *)a2 = xmmword_1B7E736F0;
  long long v19 = xmmword_1B7E736F0;
  long long v20 = xmmword_1B7E736F0;
  long long v18 = xmmword_1B7E736F0;
  uint64_t v2 = result[145];
  if ((int)v2 >= 1)
  {
    uint64_t v4 = result;
    for (uint64_t i = 0; i != v2; ++i)
    {
      if (i >= (int)v4[145]) {
        PCArray_base::badIndex((PCArray_base *)result);
      }
      uint64_t v6 = *(void *)(*((void *)v4 + 73) + 16 * i);
      uint64_t result = (unsigned int *)(*(uint64_t (**)(uint64_t, long long *, uint64_t))(*(void *)v6 + 80))(v6, &v18, v6 + 8);
      double v7 = *a2;
      double v8 = a2[1];
      if (*a2 <= v8 && (v10 = a2[2], v9 = a2[3], v10 <= v9) && (v12 = a2[4], double v11 = a2[5], v12 <= v11))
      {
        if (*(double *)&v18 <= *((double *)&v18 + 1))
        {
          long long v14 = v19;
          if (*(double *)&v19 <= *((double *)&v19 + 1))
          {
            long long v15 = v20;
            if (*(double *)&v20 <= *((double *)&v20 + 1))
            {
              if (v7 >= *(double *)&v18) {
                double v7 = *(double *)&v18;
              }
              if (v8 <= *((double *)&v18 + 1)) {
                double v8 = *((double *)&v18 + 1);
              }
              *a2 = v7;
              a2[1] = v8;
              if (v10 >= *(double *)&v14) {
                double v16 = *(double *)&v14;
              }
              else {
                double v16 = v10;
              }
              if (v9 <= *((double *)&v14 + 1)) {
                double v9 = *((double *)&v14 + 1);
              }
              a2[2] = v16;
              a2[3] = v9;
              if (v12 >= *(double *)&v15) {
                double v17 = *(double *)&v15;
              }
              else {
                double v17 = v12;
              }
              if (v11 <= *((double *)&v15 + 1)) {
                double v11 = *((double *)&v15 + 1);
              }
              a2[4] = v17;
              a2[5] = v11;
            }
          }
        }
      }
      else
      {
        long long v13 = v19;
        *(_OWORD *)a2 = v18;
        *((_OWORD *)a2 + 1) = v13;
        *((_OWORD *)a2 + 2) = v20;
      }
    }
  }
  return result;
}

unsigned int *LiGroup::boundingBox(unsigned int *result, double *a2, double *a3)
{
  *((_OWORD *)a2 + 1) = xmmword_1B7E736F0;
  *((_OWORD *)a2 + 2) = xmmword_1B7E736F0;
  *(_OWORD *)a2 = xmmword_1B7E736F0;
  long long v29 = xmmword_1B7E736F0;
  long long v30 = xmmword_1B7E736F0;
  long long v28 = xmmword_1B7E736F0;
  uint64_t v3 = result[145];
  if ((int)v3 >= 1)
  {
    uint64_t v6 = result;
    for (uint64_t i = 0; i != v3; ++i)
    {
      if (i >= (int)v6[145]) {
        PCArray_base::badIndex((PCArray_base *)result);
      }
      uint64_t v8 = *(void *)(*((void *)v6 + 73) + 16 * i);
      long long v9 = *(_OWORD *)(v8 + 8);
      long long v10 = *(_OWORD *)(v8 + 24);
      long long v11 = *(_OWORD *)(v8 + 56);
      v27[2] = *(_OWORD *)(v8 + 40);
      v27[3] = v11;
      v27[0] = v9;
      v27[1] = v10;
      long long v12 = *(_OWORD *)(v8 + 72);
      long long v13 = *(_OWORD *)(v8 + 88);
      long long v14 = *(_OWORD *)(v8 + 120);
      v27[6] = *(_OWORD *)(v8 + 104);
      v27[7] = v14;
      v27[4] = v12;
      v27[5] = v13;
      double v15 = PCMatrix44Tmpl<double>::leftMult((uint64_t)v27, a3);
      uint64_t result = (unsigned int *)(*(uint64_t (**)(uint64_t, long long *, _OWORD *, double))(*(void *)v8 + 80))(v8, &v28, v27, v15);
      double v16 = *a2;
      double v17 = a2[1];
      if (*a2 <= v17 && (v19 = a2[2], double v18 = a2[3], v19 <= v18) && (v21 = a2[4], v20 = a2[5], v21 <= v20))
      {
        if (*(double *)&v28 <= *((double *)&v28 + 1))
        {
          long long v23 = v29;
          if (*(double *)&v29 <= *((double *)&v29 + 1))
          {
            long long v24 = v30;
            if (*(double *)&v30 <= *((double *)&v30 + 1))
            {
              if (v16 >= *(double *)&v28) {
                double v16 = *(double *)&v28;
              }
              if (v17 <= *((double *)&v28 + 1)) {
                double v17 = *((double *)&v28 + 1);
              }
              *a2 = v16;
              a2[1] = v17;
              if (v19 >= *(double *)&v23) {
                double v25 = *(double *)&v23;
              }
              else {
                double v25 = v19;
              }
              if (v18 <= *((double *)&v23 + 1)) {
                double v18 = *((double *)&v23 + 1);
              }
              a2[2] = v25;
              a2[3] = v18;
              if (v21 >= *(double *)&v24) {
                double v26 = *(double *)&v24;
              }
              else {
                double v26 = v21;
              }
              if (v20 <= *((double *)&v24 + 1)) {
                double v20 = *((double *)&v24 + 1);
              }
              a2[4] = v26;
              a2[5] = v20;
            }
          }
        }
      }
      else
      {
        long long v22 = v29;
        *(_OWORD *)a2 = v28;
        *((_OWORD *)a2 + 1) = v22;
        *((_OWORD *)a2 + 2) = v30;
      }
    }
  }
  return result;
}

uint64_t LiGroup::plane@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  int v2 = *(unsigned __int8 *)(this + 594);
  double v3 = 1.0;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  if (!v2) {
    double v3 = 0.0;
  }
  *(double *)(a2 + 16) = v3;
  *(void *)(a2 + 24) = 0;
  return this;
}

uint64_t LiGroup::numChildren(LiGroup *this)
{
  return *((unsigned int *)this + 145);
}

uint64_t LiGroup::child(LiGroup *this, int a2)
{
  if (a2 < 0 || *((_DWORD *)this + 145) <= a2) {
    PCArray_base::badIndex(this);
  }
  return *(void *)(*((void *)this + 73) + 16 * a2);
}

void LiGroup::addChild(LiGroup *this, LiSceneObject *a2)
{
  double v3 = (char *)this + 568;
  uint64_t v8 = a2;
  if (a2) {
    a2 = (LiSceneObject *)((char *)a2 + *(void *)(*(void *)a2 - 24));
  }
  PCSharedCount::PCSharedCount(&v9, a2);
  int v4 = *((_DWORD *)this + 145);
  if (*((_DWORD *)this + 144) <= v4) {
    int v5 = (2 * (v4 + 1)) | 1;
  }
  else {
    int v5 = *((_DWORD *)this + 144);
  }
  PCArray<PCPtr<LiImageFilter>,PCArray_Traits<PCPtr<LiImageFilter>>>::resize((uint64_t)v3, v4 + 1, v5);
  uint64_t v6 = *((void *)this + 73);
  uint64_t v7 = *((int *)this + 145) - 1;
  *(void *)(v6 + 16 * v7) = v8;
  PCSharedCount::PCSharedCount(&v10, &v9);
  PCSharedCount::operator=((uint64_t *)(v6 + 16 * v7 + 8), (uint64_t *)&v10);
  PCSharedCount::~PCSharedCount(&v10);
  PCSharedCount::~PCSharedCount(&v9);
}

void sub_1B7AAAAD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCSharedCount a12)
{
  PCSharedCount::~PCSharedCount(&a12);
  PCSharedCount::~PCSharedCount(v12);
  _Unwind_Resume(a1);
}

void LiGroup::insertChild(LiGroup *this, int a2, PC_Sp_counted_base *a3)
{
  int v4 = (char *)this + 568;
  v6.unint64_t var0 = a3;
  if (a3) {
    int v5 = (PCShared_base *)((char *)a3 + *(void *)(*(void *)a3 - 24));
  }
  else {
    int v5 = 0;
  }
  PCSharedCount::PCSharedCount(&v7, v5);
  PCArray<PCPtr<LiSceneObject>,PCArray_Traits<PCPtr<LiSceneObject>>>::insert((uint64_t)v4, &v6, a2);
  PCSharedCount::~PCSharedCount(&v7);
}

void sub_1B7AAAB80(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1);
  _Unwind_Resume(a1);
}

uint64_t PCArray<PCPtr<LiSceneObject>,PCArray_Traits<PCPtr<LiSceneObject>>>::insert(uint64_t a1, const PCSharedCount *a2, int a3)
{
  int v6 = *(_DWORD *)(a1 + 12);
  if (*(_DWORD *)(a1 + 8) <= v6) {
    int v7 = (2 * (v6 + 1)) | 1;
  }
  else {
    int v7 = *(_DWORD *)(a1 + 8);
  }
  PCArray<PCPtr<LiImageFilter>,PCArray_Traits<PCPtr<LiImageFilter>>>::resize(a1, v6 + 1, v7);
  uint64_t v8 = *(int *)(a1 + 12);
  if ((int)v8 > a3 && (int)v8 - 1 > a3)
  {
    uint64_t v10 = v8 - 1;
    int v11 = v8 - 2;
    uint64_t v12 = 16 * v8 - 16;
    do
    {
      uint64_t v13 = *(void *)(a1 + 16);
      long long v14 = (const PCSharedCount *)(v13 + 16 * v11);
      uint64_t v15 = v13 + v12;
      *(PCSharedCount *)(v13 + v12) = (PCSharedCount)v14->var0;
      PCSharedCount::PCSharedCount(&v18, v14 + 1);
      PCSharedCount::operator=((uint64_t *)(v15 + 8), (uint64_t *)&v18);
      PCSharedCount::~PCSharedCount(&v18);
      --v10;
      --v11;
      v12 -= 16;
    }
    while (v10 > a3);
  }
  double v16 = (PC_Sp_counted_base **)(*(void *)(a1 + 16) + 16 * a3);
  int *v16 = a2->var0;
  PCSharedCount::PCSharedCount(&v18, a2 + 1);
  PCSharedCount::operator=((uint64_t *)v16 + 1, (uint64_t *)&v18);
  PCSharedCount::~PCSharedCount(&v18);
  return *(void *)(a1 + 16) + 16 * a3;
}

void sub_1B7AAACA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

void LiGroup::removeChild(LiGroup *this@<X0>, int a2@<W1>, PCSharedCount *a3@<X8>)
{
  LODWORD(v3) = a2;
  if (a2 < 0 || *((_DWORD *)this + 145) <= a2) {
    PCArray_base::badIndex(this);
  }
  int v5 = (const PCSharedCount *)(*((void *)this + 73) + 16 * a2);
  a3->unint64_t var0 = v5->var0;
  PCSharedCount::PCSharedCount(a3 + 1, v5 + 1);
  LODWORD(v6) = *((_DWORD *)this + 145) - 1;
  if ((int)v6 > (int)v3)
  {
    uint64_t v3 = (int)v3;
    uint64_t v7 = 16 * (int)v3;
    do
    {
      uint64_t v8 = *((void *)this + 73) + v7;
      *(void *)uint64_t v8 = *(void *)(v8 + 16);
      PCSharedCount::PCSharedCount(&v10, (const PCSharedCount *)(v8 + 24));
      PCSharedCount::operator=((uint64_t *)(v8 + 8), (uint64_t *)&v10);
      ++v3;
      PCSharedCount::~PCSharedCount(&v10);
      uint64_t v6 = *((int *)this + 145) - 1;
      v7 += 16;
    }
    while (v3 < v6);
  }
  if (*((_DWORD *)this + 144) >= (int)v6) {
    int v9 = *((_DWORD *)this + 144);
  }
  else {
    int v9 = (2 * v6) | 1;
  }
  PCArray<PCPtr<LiImageFilter>,PCArray_Traits<PCPtr<LiImageFilter>>>::resize((uint64_t)this + 568, v6, v9);
}

void sub_1B7AAADA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
  PCSharedCount::~PCSharedCount(v10);
  _Unwind_Resume(a1);
}

void LiGroup::removeChild(LiGroup *this, LiSceneObject *a2)
{
  int v2 = (char *)this + 568;
  uint64_t v3 = a2;
  if (a2) {
    a2 = (LiSceneObject *)((char *)a2 + *(void *)(*(void *)a2 - 24));
  }
  PCSharedCount::PCSharedCount(&v4, a2);
  PCArray<PCPtr<LiSceneObject>,PCArray_Traits<PCPtr<LiSceneObject>>>::remove((uint64_t)v2, &v3);
  PCSharedCount::~PCSharedCount(&v4);
}

void sub_1B7AAAE34(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1);
  _Unwind_Resume(a1);
}

uint64_t PCArray<PCPtr<LiSceneObject>,PCArray_Traits<PCPtr<LiSceneObject>>>::remove(uint64_t a1, void *a2)
{
  int v2 = *(_DWORD *)(a1 + 12);
  if (v2 >= 1)
  {
    int v5 = 0;
    uint64_t v6 = 0;
    while (1)
    {
      uint64_t v7 = *(void *)(*(void *)(a1 + 16) + 16 * v5);
      if (*a2)
      {
        if (v7) {
          BOOL v8 = *a2 == v7;
        }
        else {
          BOOL v8 = 0;
        }
        if (v8)
        {
LABEL_9:
          LODWORD(v9) = v2 - 1;
          if (v2 - 1 > v5)
          {
            uint64_t v10 = v5;
            uint64_t v11 = 16 * v5;
            do
            {
              uint64_t v12 = (PCSharedCount *)(*(void *)(a1 + 16) + v11);
              v12->unint64_t var0 = v12[2].var0;
              uint64_t v13 = (uint64_t *)&v12[1];
              PCSharedCount::PCSharedCount(&v16, v12 + 3);
              PCSharedCount::operator=(v13, (uint64_t *)&v16);
              ++v10;
              PCSharedCount::~PCSharedCount(&v16);
              uint64_t v9 = *(int *)(a1 + 12) - 1;
              v11 += 16;
            }
            while (v10 < v9);
          }
          if (*(_DWORD *)(a1 + 8) >= (int)v9) {
            int v14 = *(_DWORD *)(a1 + 8);
          }
          else {
            int v14 = (2 * v9) | 1;
          }
          PCArray<PCPtr<LiImageFilter>,PCArray_Traits<PCPtr<LiImageFilter>>>::resize(a1, v9, v14);
          uint64_t v6 = (v6 + 1);
          int v2 = *(_DWORD *)(a1 + 12);
          goto LABEL_18;
        }
      }
      else if (!v7)
      {
        goto LABEL_9;
      }
      ++v5;
LABEL_18:
      if (v5 >= v2) {
        return v6;
      }
    }
  }
  return 0;
}

void sub_1B7AAAF64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

uint64_t LiGroup::layerOrder(LiGroup *this)
{
  return *((unsigned __int8 *)this + 592);
}

uint64_t LiGroup::setLayerOrder(uint64_t this, char a2)
{
  *(unsigned char *)(this + 592) = a2;
  return this;
}

uint64_t LiGroup::setIs360(uint64_t this, char a2)
{
  *(unsigned char *)(this + 593) = a2;
  return this;
}

uint64_t LiGroup::project(LiGroup *this)
{
  return *((unsigned __int8 *)this + 594);
}

uint64_t LiGroup::setProject(uint64_t this, char a2)
{
  *(unsigned char *)(this + 594) = a2;
  return this;
}

double LiGroup::viewProjectionTransform@<D0>(LiGroup *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 120) = 0x3FF0000000000000;
  *(void *)(a2 + 80) = 0x3FF0000000000000;
  *(void *)(a2 + 40) = 0x3FF0000000000000;
  *(void *)a2 = 0x3FF0000000000000;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  return LiGroup::viewProjectionTransform((uint64_t)this, a2);
}

double LiGroup::viewProjectionTransform(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 600);
  if (v4)
  {
    (*(void (**)(long long *__return_ptr))(*(void *)v4 + 240))(v15);
    uint64_t v5 = *(void *)(a1 + 600);
    if (!v5) {
      throw_PCNullPointerException(1);
    }
    (*(void (**)(void *__return_ptr))(*(void *)v5 + 192))(v14);
    uint64_t v6 = *(void *)(a1 + 600);
    if (!v6) {
      throw_PCNullPointerException(1);
    }
    double v7 = (*(double (**)(uint64_t))(*(void *)v6 + 688))(v6);
    if (v7 != 1.0)
    {
      *(double *)uint64_t v15 = v7 * *(double *)v15;
      double v16 = v7 * v16;
      double v17 = v7 * v17;
      double v18 = v7 * v18;
    }
    PCMatrix44Tmpl<double>::operator*((uint64_t)v14, v15, (uint64_t)v13);
    if (v13 != (unsigned char *)a2)
    {
      for (uint64_t i = 0; i != 128; i += 32)
      {
        uint64_t v10 = (_OWORD *)(a2 + i);
        long long v8 = *(_OWORD *)&v13[i];
        long long v11 = *(_OWORD *)&v13[i + 16];
        *uint64_t v10 = v8;
        v10[1] = v11;
      }
    }
  }
  else
  {
    *(void *)(a2 + 120) = 0x3FF0000000000000;
    *(void *)(a2 + 80) = 0x3FF0000000000000;
    *(void *)(a2 + 40) = 0x3FF0000000000000;
    *(void *)a2 = 0x3FF0000000000000;
    *(void *)&long long v8 = 0;
    *(_OWORD *)(a2 + 8) = 0u;
    *(_OWORD *)(a2 + 24) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 88) = 0u;
    *(_OWORD *)(a2 + 104) = 0u;
  }
  return *(double *)&v8;
}

void LiGroup::camera(const PCSharedCount *this@<X0>, PCSharedCount *a2@<X8>)
{
  a2->unint64_t var0 = this[75].var0;
  PCSharedCount::PCSharedCount(a2 + 1, this + 76);
}

uint64_t LiGroup::setCamera(uint64_t *a1, const PCSharedCount *a2)
{
  a1[75] = (uint64_t)a2->var0;
  uint64_t v3 = a1 + 76;
  PCSharedCount::PCSharedCount(&v5, a2 + 1);
  PCSharedCount::operator=(v3, (uint64_t *)&v5);
  PCSharedCount::~PCSharedCount(&v5);
  return (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 208))(a1, 1);
}

void sub_1B7AAB1EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

const char *LiGroup::className(LiGroup *this)
{
  return "LiGroup";
}

PCArray_base *LiGroup::print(uint64_t a1, void *a2, uint64_t a3)
{
  LiImageSource::printIndent(a2, a3);
  uint64_t v6 = *(unsigned int *)(a1 + 580);
  double v7 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 264))(a1);
  size_t v8 = strlen(v7);
  uint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)v7, v8);
  uint64_t v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)"(\"", 2);
  if (*(void *)(a1 + 512)) {
    long long v11 = *(const char **)(a1 + 512);
  }
  else {
    long long v11 = "";
  }
  size_t v12 = strlen(v11);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)v11, v12);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)"\", compositeOrder=", 18);
  std::ostream::operator<<();
  if (*(_DWORD *)(a1 + 532) || *(_DWORD *)(a1 + 536))
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"/", 1);
    std::ostream::operator<<();
    if (*(unsigned char *)(a1 + 540)) {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"(r)", 3);
    }
  }
  if (*(_DWORD *)(a1 + 536))
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"/", 1);
    std::ostream::operator<<();
  }
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", blendMode=", 12);
  int v14 = LiSceneObject::blendMode((LiSceneObject *)a1);
  operator<<(v13, v14);
  if (!*(unsigned char *)(a1 + 552)) {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", doesReflect=false", 19);
  }
  if (!*(unsigned char *)(a1 + 553)) {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", visibleOutsideReflection=false", 32);
  }
  uint64_t v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", ", 2);
  double v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)"layerOrder=", 11);
  if (*(unsigned char *)(a1 + 592)) {
    double v17 = "true";
  }
  else {
    double v17 = "false";
  }
  if (*(unsigned char *)(a1 + 592)) {
    uint64_t v18 = 4;
  }
  else {
    uint64_t v18 = 5;
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)v17, v18);
  double v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", ", 2);
  double v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"is360=", 6);
  if (*(unsigned char *)(a1 + 593)) {
    double v21 = "true";
  }
  else {
    double v21 = "false";
  }
  if (*(unsigned char *)(a1 + 593)) {
    uint64_t v22 = 4;
  }
  else {
    uint64_t v22 = 5;
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)v21, v22);
  if (*(unsigned char *)(a1 + 594))
  {
    long long v23 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", ", 2);
    long long v24 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)"project=", 8);
    if (*(unsigned char *)(a1 + 594)) {
      double v25 = "true";
    }
    else {
      double v25 = "false";
    }
    if (*(unsigned char *)(a1 + 594)) {
      uint64_t v26 = 4;
    }
    else {
      uint64_t v26 = 5;
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)v25, v26);
  }
  if (!*(unsigned char *)(a1 + 644)) {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", no lights in", 14);
  }
  if (!*(unsigned char *)(a1 + 645)) {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", no lights out", 15);
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)", ", 2);
  char v27 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)" child", 6);
  if (v6 != 1) {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)"ren", 3);
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a2, (uint64_t)")\n", 2);
  (*(void (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 120))(a1, a2, a3);
  uint64_t result = *(PCArray_base **)(a1 + 600);
  if (result) {
    uint64_t result = (PCArray_base *)(*(uint64_t (**)(PCArray_base *, void *, void))(*(void *)result + 752))(result, a2, (a3 + 2));
  }
  if ((int)v6 >= 1)
  {
    uint64_t v29 = 0;
    uint64_t v30 = (a3 + 1);
    do
    {
      if (v29 >= *(int *)(a1 + 580)) {
        PCArray_base::badIndex(result);
      }
      uint64_t v31 = *(void *)(*(void *)(a1 + 584) + 16 * v29);
      uint64_t result = (PCArray_base *)(*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)v31 + 112))(v31, a2, v30);
      ++v29;
    }
    while (v29 != v6);
  }
  return result;
}

uint64_t LiGroup::LiGroup(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = (void *)LiSceneObject::LiSceneObject(a1, a2 + 1, a3);
  uint64_t v7 = *a2;
  *uint64_t v6 = *a2;
  *(void *)(a1 + *(void *)(v7 - 24)) = a2[5];
  *(void *)(a1 + 568) = &unk_1F111E0E8;
  *(void *)(a1 + 584) = 0;
  *(void *)(a1 + 576) = 0;
  *(unsigned char *)(a1 + 592) = *(unsigned char *)(a3 + 592);
  *(unsigned char *)(a1 + 593) = *(unsigned char *)(a3 + 593);
  *(unsigned char *)(a1 + 594) = *(unsigned char *)(a3 + 594);
  *(void *)(a1 + 600) = *(void *)(a3 + 600);
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 608), (const PCSharedCount *)(a3 + 608));
  long long v9 = *(_OWORD *)(a3 + 616);
  *(_OWORD *)(a1 + 628) = *(_OWORD *)(a3 + 628);
  *(_OWORD *)(a1 + 616) = v9;
  *(_WORD *)(a1 + 644) = 257;
  uint64_t v10 = *(unsigned int *)(a3 + 580);
  if ((int)v10 >= 1)
  {
    for (uint64_t i = 0; i != v10; ++i)
    {
      if (i >= *(int *)(a3 + 580)) {
        PCArray_base::badIndex(v8);
      }
      size_t v8 = *(PCArray_base **)(*(void *)(a3 + 584) + 16 * i);
      if (v8)
      {
        if (v8) {
          size_t v8 = (PCArray_base *)(*(uint64_t (**)(uint64_t, PCArray_base *))(*(void *)a1 + 152))(a1, v8);
        }
      }
    }
  }
  *(_WORD *)(a1 + 644) = *(_WORD *)(a3 + 644);
  return a1;
}

void sub_1B7AAB810(_Unwind_Exception *a1)
{
  PCArray<PCPtr<LiSceneObject>,PCArray_Traits<PCPtr<LiSceneObject>>>::~PCArray(v3);
  LiSceneObject::~LiSceneObject(v1, v2);
  _Unwind_Resume(a1);
}

uint64_t LiSceneObject::LiSceneObject(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = a2[1];
  *(void *)a1 = v5;
  *(void *)(a1 + *(void *)(v5 - 24)) = a2[2];
  uint64_t v6 = *a2;
  *(void *)a1 = *a2;
  *(void *)(a1 + *(void *)(v6 - 24)) = a2[3];
  memcpy((void *)(a1 + 8), (const void *)(a3 + 8), 0x189uLL);
  uint64_t v7 = *(void *)(a3 + 416);
  *(void *)(a1 + 408) = *(void *)(a3 + 408);
  *(void *)(a1 + 416) = v7;
  *(unsigned char *)(a1 + 424) = *(unsigned char *)(a3 + 424);
  *(_OWORD *)(a1 + 432) = *(_OWORD *)(a3 + 432);
  *(unsigned char *)(a1 + 448) = *(unsigned char *)(a3 + 448);
  uint64_t v8 = *(void *)(a3 + 464);
  *(void *)(a1 + 4LiDepthSorter::stackSort((uint64_t)this + 56) = *(void *)(a3 + 456);
  *(void *)(a1 + 464) = v8;
  *(_OWORD *)(a1 + 472) = *(_OWORD *)(a3 + 472);
  *(void *)(a1 + 488) = *(void *)(a3 + 488);
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 496), (const PCSharedCount *)(a3 + 496));
  *(unsigned char *)(a1 + 504) = *(unsigned char *)(a3 + 504);
  uint64_t v9 = *(void *)(a3 + 512);
  *(void *)(a1 + 512) = v9;
  if (v9) {
    atomic_fetch_add((atomic_uint *volatile)(v9 - 12), 1u);
  }
  long long v10 = *(_OWORD *)(a3 + 520);
  long long v11 = *(_OWORD *)(a3 + 536);
  *(_OWORD *)(a1 + 549) = *(_OWORD *)(a3 + 549);
  *(_OWORD *)(a1 + 520) = v10;
  *(_OWORD *)(a1 + 536) = v11;
  return a1;
}

uint64_t LiGroup::LiGroup(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 648) = &unk_1F1199AC8;
  *(void *)(a1 + 6LiDepthSorter::stackSort((uint64_t)this + 56) = 0;
  *(unsigned char *)(a1 + 664) = 1;
  LiSceneObject::LiSceneObject(a1, (uint64_t *)&off_1F111DF60, a2);
  *(void *)a1 = &unk_1F111DE10;
  *(void *)(a1 + 648) = &unk_1F111DF40;
  *(void *)(a1 + 568) = &unk_1F111E0E8;
  *(void *)(a1 + 584) = 0;
  *(void *)(a1 + 576) = 0;
  *(_WORD *)(a1 + 592) = *(_WORD *)(a2 + 592);
  *(unsigned char *)(a1 + 594) = *(unsigned char *)(a2 + 594);
  *(void *)(a1 + 600) = *(void *)(a2 + 600);
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 608), (const PCSharedCount *)(a2 + 608));
  long long v5 = *(_OWORD *)(a2 + 616);
  *(_OWORD *)(a1 + 628) = *(_OWORD *)(a2 + 628);
  *(_OWORD *)(a1 + 616) = v5;
  *(_WORD *)(a1 + 644) = 257;
  uint64_t v6 = *(unsigned int *)(a2 + 580);
  if ((int)v6 >= 1)
  {
    for (uint64_t i = 0; i != v6; ++i)
    {
      if (i >= *(int *)(a2 + 580)) {
        PCArray_base::badIndex(v4);
      }
      uint64_t v4 = *(PCArray_base **)(*(void *)(a2 + 584) + 16 * i);
      if (v4)
      {
        if (v4) {
          uint64_t v4 = (PCArray_base *)(*(uint64_t (**)(uint64_t, PCArray_base *))(*(void *)a1 + 152))(a1, v4);
        }
      }
    }
  }
  *(_WORD *)(a1 + 644) = *(_WORD *)(a2 + 644);
  return a1;
}

void sub_1B7AABBE8(_Unwind_Exception *a1)
{
  PCArray<PCPtr<LiSceneObject>,PCArray_Traits<PCPtr<LiSceneObject>>>::~PCArray(v3);
  LiSceneObject::~LiSceneObject((PCSharedCount *)v1, (PC_Sp_counted_base **)&off_1F111DF60);
  *(void *)(v1 + 648) = v2;
  *(unsigned char *)(v1 + 664) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 656));
  _Unwind_Resume(a1);
}

void LiGroup::createCopyWithJustLights(LiGroup *this)
{
}

void PCMakePtr<LiGroup,LiGroup const&,LiGroup::JustLightsTag>()
{
}

void sub_1B7AABCD8(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C40089F272ELL);
  _Unwind_Resume(a1);
}

PCArray_base *LiGroup::widenBounds(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = (PCArray_base *)PCMatrix44Tmpl<double>::operator*(a3, (long long *)(a1 + 8), (uint64_t)v13);
  uint64_t v10 = *(unsigned int *)(a1 + 580);
  if ((int)v10 >= 1)
  {
    for (uint64_t i = 0; i != v10; ++i)
    {
      if (i >= *(int *)(a1 + 580)) {
        PCArray_base::badIndex(result);
      }
      uint64_t v12 = *(void *)(*(void *)(a1 + 584) + 16 * i);
      if (!v12) {
        throw_PCNullPointerException(1);
      }
      uint64_t result = (PCArray_base *)(*(uint64_t (**)(uint64_t, uint64_t, unsigned char *, uint64_t, uint64_t))(*(void *)v12 + 128))(v12, a2, v13, a4, a5);
    }
  }
  return result;
}

double LiGroup::cast@<D0>(uint64_t a1@<X0>, float64x2_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  *(_OWORD *)(a4 + 8) = 0u;
  *(unsigned char *)a4 = 0;
  *(_OWORD *)(a4 + 24) = 0u;
  *(_OWORD *)(a4 + 40) = 0u;
  *(_OWORD *)(a4 + LiDepthSorter::stackSort((uint64_t)this + 56) = 0u;
  long long v24 = (double *)(a4 + 8);
  double v25 = (uint64_t *)(a4 + 72);
  PCSharedCount::PCSharedCount((PCSharedCount *)(a4 + 72));
  float64x2_t v8 = a2[1];
  v45[0] = *a2;
  v45[1] = v8;
  v45[2] = a2[2];
  long long v9 = *(_OWORD *)(a1 + 88);
  v44[4] = *(_OWORD *)(a1 + 72);
  v44[5] = v9;
  long long v10 = *(_OWORD *)(a1 + 120);
  v44[6] = *(_OWORD *)(a1 + 104);
  v44[7] = v10;
  long long v11 = *(_OWORD *)(a1 + 24);
  v44[0] = *(_OWORD *)(a1 + 8);
  v44[1] = v11;
  long long v12 = *(_OWORD *)(a1 + 56);
  v44[2] = *(_OWORD *)(a1 + 40);
  v44[3] = v12;
  uint64_t v43 = 0x3FF0000000000000;
  uint64_t v40 = 0x3FF0000000000000;
  uint64_t v37 = 0x3FF0000000000000;
  uint64_t v34 = 0x3FF0000000000000;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  if (PCMatrix44Tmpl<double>::invert((double *)&v34, (double *)v44, 0.0))
  {
    BOOL v14 = PCRay3<double>::transform((uint64_t)v45, (double *)&v34);
    long long v23 = a2;
    uint64_t v15 = *(unsigned int *)(a1 + 580);
    if ((int)v15 >= 1)
    {
      for (uint64_t i = 0; i != v15; ++i)
      {
        if (i >= *(int *)(a1 + 580)) {
          PCArray_base::badIndex((PCArray_base *)v14);
        }
        uint64_t v17 = *(void *)(*(void *)(a1 + 584) + 16 * i);
        *(void *)&long long v28 = v17;
        if (v17) {
          uint64_t v18 = (PCShared_base *)(v17 + *(void *)(*(void *)v17 - 24));
        }
        else {
          uint64_t v18 = 0;
        }
        PCSharedCount::PCSharedCount((PCSharedCount *)&v28 + 1, v18);
        PCArray<PCPtr<LiSceneObject>,PCArray_Traits<PCPtr<LiSceneObject>>>::push(a3 + 8, (const PCSharedCount *)&v28);
        PCSharedCount::~PCSharedCount((PCSharedCount *)&v28 + 1);
        (*(void (**)(long long *__return_ptr, uint64_t, _OWORD *, uint64_t))(*(void *)v17 + 96))(&v28, v17, v45, a3);
        PCArray<PCPtr<LiSceneObject>,PCArray_Traits<PCPtr<LiSceneObject>>>::pop(a3 + 8, &v26);
        PCSharedCount::~PCSharedCount(&v27);
        if ((_BYTE)v28 && (!*(unsigned char *)a4 || *((double *)&v28 + 1) < *v24))
        {
          long long v19 = v29;
          *(_OWORD *)a4 = v28;
          *(_OWORD *)(a4 + 16) = v19;
          long long v20 = v31;
          *(_OWORD *)(a4 + 32) = v30;
          *(_OWORD *)(a4 + 48) = v20;
          *(void *)(a4 + 64) = v32;
          PCSharedCount::PCSharedCount(&v46, &v33);
          PCSharedCount::operator=(v25, (uint64_t *)&v46);
          PCSharedCount::~PCSharedCount(&v46);
        }
        PCSharedCount::~PCSharedCount(&v33);
      }
    }
    if (*(unsigned char *)a4)
    {
      long long v28 = 0uLL;
      *(void *)&long long v29 = 0;
      PCMatrix44Tmpl<double>::transform<double>((double *)v44, (double *)(a4 + 40), (double *)&v28);
      *(_OWORD *)(a4 + 16) = v28;
      *(void *)(a4 + 32) = v29;
      double v21 = *(double *)(a4 + 32) - v23[1].f64[0];
      float64x2_t v22 = vsubq_f64(*(float64x2_t *)(a4 + 16), *v23);
      double result = sqrt(vaddvq_f64(vmulq_f64(v22, v22)) + v21 * v21);
      *(double *)(a4 + 8) = result;
    }
  }
  return result;
}

void sub_1B7AAC084(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCSharedCount *a12)
{
}

uint64_t PCArray<PCPtr<LiSceneObject>,PCArray_Traits<PCPtr<LiSceneObject>>>::push(uint64_t a1, const PCSharedCount *a2)
{
  int v4 = *(_DWORD *)(a1 + 12);
  if (*(_DWORD *)(a1 + 8) <= v4) {
    int v5 = (2 * (v4 + 1)) | 1;
  }
  else {
    int v5 = *(_DWORD *)(a1 + 8);
  }
  PCArray<PCPtr<LiImageFilter>,PCArray_Traits<PCPtr<LiImageFilter>>>::resize(a1, v4 + 1, v5);
  uint64_t v6 = *(void *)(a1 + 16) + 16 * *(int *)(a1 + 12);
  *(PCSharedCount *)(v6 - 16) = (PCSharedCount)a2->var0;
  uint64_t v7 = (uint64_t *)(v6 - 8);
  PCSharedCount::PCSharedCount(&v9, a2 + 1);
  PCSharedCount::operator=(v7, (uint64_t *)&v9);
  PCSharedCount::~PCSharedCount(&v9);
  return *(void *)(a1 + 16) + 16 * *(int *)(a1 + 12) - 16;
}

void sub_1B7AAC16C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCSharedCount a10)
{
}

void PCArray<PCPtr<LiSceneObject>,PCArray_Traits<PCPtr<LiSceneObject>>>::pop(uint64_t a1@<X0>, PCSharedCount *a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 16) + 16 * *(int *)(a1 + 12);
  a2->unint64_t var0 = *(PC_Sp_counted_base **)(v4 - 16);
  PCSharedCount::PCSharedCount(a2 + 1, (const PCSharedCount *)(v4 - 8));
  int v5 = *(_DWORD *)(a1 + 12) - 1;
  if (*(_DWORD *)(a1 + 8) >= v5) {
    int v6 = *(_DWORD *)(a1 + 8);
  }
  else {
    int v6 = (2 * v5) | 1;
  }
  PCArray<PCPtr<LiImageFilter>,PCArray_Traits<PCPtr<LiImageFilter>>>::resize(a1, v5, v6);
}

void sub_1B7AAC1E4(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1);
  _Unwind_Resume(a1);
}

uint64_t LiGroup::getAttributesPerRenderInstance(LiGroup *this)
{
  return (uint64_t)this + 616;
}

{
  return (uint64_t)this + 616;
}

__n128 LiGroup::setAttributesPerRenderInstance(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  *(_OWORD *)(a1 + 627) = *(_OWORD *)(a2 + 11);
  *(__n128 *)(a1 + 616) = result;
  return result;
}

void PCArray<PCPtr<LiSceneObject>,PCArray_Traits<PCPtr<LiSceneObject>>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111E0E8;
  if (*(int *)(a1 + 8) < 0) {
    int v2 = 1;
  }
  else {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  PCArray<PCPtr<LiImageFilter>,PCArray_Traits<PCPtr<LiImageFilter>>>::resize(a1, 0, v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    MEMORY[0x1BA9BFB70](v3, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

void LiLightFilter::LiLightFilter(LiLightFilter *this)
{
  *((void *)this + 108) = &unk_1F1199AC8;
  *((void *)this + 109) = 0;
  *((unsigned char *)this + 880) = 1;
  LiImageFilter::LiImageFilter(this, (uint64_t *)&off_1F111E238);
  *(void *)this = &unk_1F111E128;
  *((void *)this + 108) = &unk_1F111E218;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = &unk_1F10AD5F8;
  *((unsigned char *)this + 64) = 0;
  LiMaterialProperties::LiMaterialProperties((LiLightFilter *)((char *)this + 72));
  *((void *)this + 69) = 0x3FF0000000000000;
  *((void *)this + 64) = 0x3FF0000000000000;
  *((void *)this + 59) = 0x3FF0000000000000;
  *((_OWORD *)this + 30) = 0u;
  *((_OWORD *)this + 31) = 0u;
  *(_OWORD *)((char *)this + 520) = 0u;
  *(_OWORD *)((char *)this + 536) = 0u;
  *((_OWORD *)this + 35) = 0u;
  *((_OWORD *)this + 36) = 0u;
  *((void *)this + 85) = 0x3FF0000000000000;
  *((void *)this + 80) = 0x3FF0000000000000;
  __asm { FMOV            V1.2D, #1.0 }
  *((_OWORD *)this + 37) = _Q1;
  *((_OWORD *)this + 38) = 0u;
  *((_OWORD *)this + 39) = 0u;
  *(_OWORD *)((char *)this + 648) = 0u;
  *(_OWORD *)((char *)this + 664) = 0u;
  *((_OWORD *)this + 43) = 0u;
  *((_OWORD *)this + 44) = 0u;
  *((void *)this + 106) = 0x3FF0000000000000;
  *((void *)this + 101) = 0x3FF0000000000000;
  *((void *)this + 96) = 0x3FF0000000000000;
  *((_OWORD *)this + 45) = _Q1;
  *((_OWORD *)this + 46) = 0u;
  *((_OWORD *)this + 47) = 0u;
  *(_OWORD *)((char *)this + 776) = 0u;
  *(_OWORD *)((char *)this + 792) = 0u;
  *((_OWORD *)this + 51) = 0u;
  *((_OWORD *)this + 52) = 0u;
  *((unsigned char *)this + 8LiDepthSorter::stackSort((uint64_t)this + 56) = 0;
}

void sub_1B7AAC3F4(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;
  PCArray<LiLight,PCArray_Traits<LiLight>>::~PCArray(v4);
  LiImageFilter::~LiImageFilter((PCSharedCount *)v1, (const PCString *)&off_1F111E238);
  *(void *)(v1 + 864) = v2;
  *(unsigned char *)(v1 + 880) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 872));
  _Unwind_Resume(a1);
}

uint64_t LiLightFilter::operator=(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    uint64_t v4 = a1 + 40;
    int v5 = *(_DWORD *)(a2 + 52);
    if (*(_DWORD *)(a1 + 48) >= v5) {
      int v6 = *(_DWORD *)(a1 + 48);
    }
    else {
      int v6 = (2 * v5) | 1;
    }
    PCArray<LiLight,PCArray_Traits<LiLight>>::resize(v4, v5, v6);
    if (*(int *)(a2 + 52) >= 1)
    {
      uint64_t v7 = 0;
      uint64_t v8 = 0;
      do
      {
        LiLight::operator=(*(void *)(a1 + 56) + v7, *(void *)(a2 + 56) + v7);
        ++v8;
        v7 += 944;
      }
      while (v8 < *(int *)(a2 + 52));
    }
    *(unsigned char *)(a1 + 64) = *(unsigned char *)(a2 + 64);
    LiMaterialProperties::operator=(a1 + 72, a2 + 72);
    uint64_t v9 = 0;
    uint64_t v10 = a2 + 472;
    uint64_t v11 = a1 + 472;
    do
    {
      for (uint64_t i = 0; i != 32; i += 8)
        *(void *)(v11 + i) = *(void *)(v10 + i);
      ++v9;
      v11 += 32;
      v10 += 32;
    }
    while (v9 != 4);
    uint64_t v13 = 0;
    uint64_t v14 = a2 + 600;
    uint64_t v15 = a1 + 600;
    do
    {
      for (uint64_t j = 0; j != 32; j += 8)
        *(void *)(v15 + j) = *(void *)(v14 + j);
      ++v13;
      v15 += 32;
      v14 += 32;
    }
    while (v13 != 4);
    uint64_t v17 = 0;
    uint64_t v18 = a2 + 728;
    uint64_t v19 = a1 + 728;
    do
    {
      for (uint64_t k = 0; k != 32; k += 8)
        *(void *)(v19 + k) = *(void *)(v18 + k);
      ++v17;
      v19 += 32;
      v18 += 32;
    }
    while (v17 != 4);
    *(unsigned char *)(a1 + 8LiDepthSorter::stackSort((uint64_t)this + 56) = *(unsigned char *)(a2 + 856);
  }
  return a1;
}

void LiLightFilter::LiLightFilter(LiLightFilter *this, const LiLightFilter *a2)
{
  *((void *)this + 108) = &unk_1F1199AC8;
  *((void *)this + 109) = 0;
  *((unsigned char *)this + 880) = 1;
  LiImageFilter::LiImageFilter(this, (const LiImageFilter *)&off_1F111E238, (uint64_t)a2);
  *(void *)this = &unk_1F111E128;
  *((void *)this + 108) = &unk_1F111E218;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = &unk_1F10AD5F8;
  *((unsigned char *)this + 64) = 0;
  LiMaterialProperties::LiMaterialProperties((LiLightFilter *)((char *)this + 72));
  *((void *)this + 69) = 0x3FF0000000000000;
  *((void *)this + 64) = 0x3FF0000000000000;
  *((void *)this + 59) = 0x3FF0000000000000;
  *((_OWORD *)this + 30) = 0u;
  *((_OWORD *)this + 31) = 0u;
  *(_OWORD *)((char *)this + 520) = 0u;
  *(_OWORD *)((char *)this + 536) = 0u;
  *((_OWORD *)this + 35) = 0u;
  *((_OWORD *)this + 36) = 0u;
  *((void *)this + 85) = 0x3FF0000000000000;
  *((void *)this + 80) = 0x3FF0000000000000;
  __asm { FMOV            V1.2D, #1.0 }
  *((_OWORD *)this + 37) = _Q1;
  *((_OWORD *)this + 38) = 0u;
  *((_OWORD *)this + 39) = 0u;
  *(_OWORD *)((char *)this + 648) = 0u;
  *(_OWORD *)((char *)this + 664) = 0u;
  *((_OWORD *)this + 43) = 0u;
  *((_OWORD *)this + 44) = 0u;
  *((void *)this + 106) = 0x3FF0000000000000;
  *((void *)this + 101) = 0x3FF0000000000000;
  *((void *)this + 96) = 0x3FF0000000000000;
  *((_OWORD *)this + 46) = 0u;
  *((_OWORD *)this + 47) = 0u;
  *((_OWORD *)this + 45) = _Q1;
  *(_OWORD *)((char *)this + 776) = 0u;
  *(_OWORD *)((char *)this + 792) = 0u;
  *((_OWORD *)this + 51) = 0u;
  *((_OWORD *)this + 52) = 0u;
  LiLightFilter::operator=((uint64_t)this, (uint64_t)a2);
}

void sub_1B7AAC6E0(_Unwind_Exception *a1)
{
  LiMaterialProperties::~LiMaterialProperties(v4);
  PCArray<LiLight,PCArray_Traits<LiLight>>::~PCArray(v3);
  LiImageFilter::~LiImageFilter((PCSharedCount *)v1, (const PCString *)&off_1F111E238);
  *(void *)(v1 + 864) = v2;
  *(unsigned char *)(v1 + 880) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 872));
  _Unwind_Resume(a1);
}

void LiLightFilter::~LiLightFilter(PCSharedCount *this, const PCString *a2)
{
  unint64_t var0 = a2->var0;
  this->unint64_t var0 = (PC_Sp_counted_base *)a2->var0;
  *(__CFString **)((char *)this + var0[-1].info) = a2[7].var0;
  LiMaterialProperties::~LiMaterialProperties((LiMaterialProperties *)&this[9]);
  PCArray<LiLight,PCArray_Traits<LiLight>>::~PCArray((uint64_t)&this[5]);
  int v5 = a2[1].var0;
  this->unint64_t var0 = (PC_Sp_counted_base *)v5;
  *(__CFString **)((char *)this + v5[-1].info) = a2[6].var0;
  PCSharedCount::~PCSharedCount(this + 3);

  OZChannelBase::setRangeName((OZChannelBase *)this, a2 + 2);
}

void LiLightFilter::~LiLightFilter(PCSharedCount *this)
{
  *(void *)(v1 + 864) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 880) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 872));
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)(v1 + 864) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 880) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 872));

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'LiLightFilter::~LiLightFilter(LiLightFilter *this)
{
  *(void *)(v1 + 864) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 880) = 0;
  uint64_t v2 = (PC_Sp_counted_base **)(v1 + 872);

  PCWeakCount::~PCWeakCount(v2);
}

{
  LiLightFilter::~LiLightFilter((PCSharedCount *)((char *)this + *(void *)(*(void *)this - 24)));
}

void LiLightFilter::clone(LiLightFilter *this)
{
}

void sub_1B7AACA84(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1);
  _Unwind_Resume(a1);
}

double *LiLightFilter::surfaceNormal@<X0>(double *result@<X0>, long long *a2@<X1>, double *a3@<X8>)
{
  *a3 = 0.0;
  a3[1] = 0.0;
  a3[2] = 1.0;
  if (!*((unsigned char *)result + 856))
  {
    v20[0] = 0.0;
    v20[1] = 0.0;
    long long v21 = xmmword_1B7E733D0;
    long long v4 = a2[5];
    long long v16 = a2[4];
    long long v17 = v4;
    long long v5 = a2[7];
    long long v18 = a2[6];
    long long v19 = v5;
    long long v6 = a2[1];
    long long v12 = *a2;
    long long v13 = v6;
    long long v7 = a2[3];
    long long v14 = a2[2];
    long long v15 = v7;
    if (fabs(PCMatrix44Tmpl<double>::determinant((double *)&v12)) < 1.0e-16)
    {
      double v9 = 0.0;
      double v10 = 0.0;
      long long v11 = xmmword_1B7E733D0;
      liFindMatrixPlane((double *)&v12, &v9);
      *(double *)&long long v13 = -v9;
      *(double *)&long long v15 = -v10;
      *(double *)&long long v17 = -*(double *)&v11;
      *(double *)&long long v19 = -*((double *)&v11 + 1);
    }
    PCMatrix44Tmpl<double>::invert((double *)&v12, (double *)&v12, 0.0);
    __n128 result = PCMatrix44Tmpl<double>::transform_row<double>((double *)&v12, v20, v20);
    double v8 = 1.0;
    if (*(double *)&v21 > 0.0) {
      double v8 = -1.0;
    }
    a3[2] = v8;
  }
  return result;
}

uint64_t LiLightFilter::pixelTransformSupport()
{
  return 6;
}

uint64_t LiLightFilter::filteredEdges(LiLightFilter *this)
{
  uint64_t v1 = *((void *)this + 2);
  if (!v1) {
    throw_PCNullPointerException(1);
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 32);

  return v2();
}

uint64_t LiLightFilter::getHelium@<X0>(LiImageSource **this@<X0>, LiAgent *a2@<X1>, uint64_t *a3@<X8>)
{
  if (!*((_DWORD *)this + 13)) {
    return LiAgent::getHelium(a2, this[2], a3);
  }
  if (LiAgent::haveROI(a2)
    && ((LiAgent::getROI((__n128 *)a2, &v7), (v7.n128_u32[2] & 0x80000000) != 0)
     || (v7.n128_u32[3] & 0x80000000) != 0
     || !(v7.n128_u32[3] * v7.n128_u32[2])))
  {
    return LiAgent::getHelium(a2, this[2], a3);
  }
  else
  {
    return (*((uint64_t (**)(LiImageSource **, LiAgent *))*this + 25))(this, a2);
  }
}

void LiLightFilter::heRender(LiLightFilter *this@<X0>, LiAgent *a2@<X1>, void *a3@<X8>)
{
  *((_DWORD *)a2 + 8) = 2;
  LiAgent::passROI(a2);
  LiAgent::getHelium(a2, *((LiImageSource **)this + 2), &v93);
  if (v93)
  {
    uint64_t v6 = **((void **)a2 + 6);
    long long v91 = 0u;
    long long v92 = 0u;
    *(void *)&v90[40] = 0x3FF0000000000000;
    *(void *)size_t v90 = 0x3FF0000000000000;
    uint64_t v87 = 0x3FF0000000000000;
    uint64_t v84 = 0x3FF0000000000000;
    long long v85 = 0u;
    long long v86 = 0u;
    long long v88 = 0u;
    float64x2_t v89 = 0u;
    memset(&v90[8], 0, 32);
    uint64_t v83 = 0x3FF0000000000000;
    uint64_t v80 = 0x3FF0000000000000;
    v77[5] = 0x3FF0000000000000;
    v77[0] = 0x3FF0000000000000;
    memset(&v77[1], 0, 32);
    long long v78 = 0u;
    long long v79 = 0u;
    long long v81 = 0u;
    long long v82 = 0u;
    if (*((unsigned char *)this + 856))
    {
      double v7 = (*(double (**)(uint64_t))(*(void *)v6 + 320))(v6);
      uint64_t v8 = 0;
      long long v91 = 0uLL;
      *(double *)&long long v92 = v7;
      *((void *)&v92 + 1) = 0x3FF0000000000000;
      double v9 = (char *)this + 728;
      do
      {
        double v10 = &v77[v8];
        long long v11 = *(_OWORD *)&v9[v8 * 8 + 16];
        *double v10 = *(_OWORD *)&v9[v8 * 8];
        v10[1] = v11;
        v8 += 4;
      }
      while (v8 != 16);
      for (uint64_t i = 0; i != 16; i += 4)
      {
        long long v13 = (_OWORD *)((char *)&v84 + i * 8);
        long long v14 = *(_OWORD *)&v77[i + 2];
        *long long v13 = *(_OWORD *)&v77[i];
        v13[1] = v14;
      }
    }
    else
    {
      (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v6 + 344))(v76, v6);
      long long v91 = v76[0];
      long long v92 = v76[1];
      (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v6 + 24))(v76, v6);
      for (unint64_t j = 0; j != 128; j += 32)
      {
        long long v16 = &v77[j / 8];
        long long v17 = v76[j / 0x10 + 1];
        _OWORD *v16 = v76[j / 0x10];
        v16[1] = v17;
      }
      (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v6 + 240))(v76, v6);
      for (uint64_t k = 0; k != 8; k += 2)
      {
        long long v19 = (_OWORD *)((char *)&v84 + k * 16);
        long long v20 = v76[k + 1];
        _OWORD *v19 = v76[k];
        v19[1] = v20;
      }
      if ((*(double (**)(uint64_t))(*(void *)v6 + 504))(v6) <= 0.0)
      {
        float64x2_t v21 = (float64x2_t)vdupq_n_s64(0x40C3880000000000uLL);
        float64x2_t v89 = vsubq_f64(v89, vmulq_f64(*(float64x2_t *)&v90[16], v21));
        *(float64x2_t *)size_t v90 = vsubq_f64(*(float64x2_t *)v90, vmulq_f64(*(float64x2_t *)&v90[32], v21));
      }
    }
    LiAgent::getObjectToFilmTransform(a2, (uint64_t)v76);
    LiLightFilter::surfaceNormal((double *)this, v76, v74);
    double v22 = PCMatrix44Tmpl<double>::determinant((double *)this + 75);
    PCMatrix44Tmpl<double>::operator*((uint64_t)this + 600, (long long *)((char *)this + 472), (uint64_t)v73);
    PCMatrix44Tmpl<double>::operator*((uint64_t)&v84, v73, (uint64_t)v72);
    PCMatrix44Tmpl<double>::transform_normal<double>((uint64_t)v72, v74, &v70);
    double v23 = sqrt(v70.f64[0] * v70.f64[0] + v70.f64[1] * v70.f64[1] + v71 * v71);
    if (v23 <= -0.000000100000001 || v23 >= 0.000000100000001)
    {
      v70.f64[0] = v70.f64[0] / v23;
      v70.f64[1] = v70.f64[1] / v23;
      double v71 = v71 / v23;
      LiAgent::getPixelToObjectTransform((double **)a2, (uint64_t)v68);
      PCMatrix44Tmpl<double>::operator*((uint64_t)v73, v68, (uint64_t)v69);
      PCMatrix44Tmpl<double>::operator*((uint64_t)&v84, v69, (uint64_t)v68);
      if (v22 >= 0.0) {
        double v24 = v75;
      }
      else {
        double v24 = -v75;
      }
      float32x4_t v67[4] = v73[4];
      v67[5] = v73[5];
      v67[6] = v73[6];
      v67[7] = v73[7];
      v67[0] = v73[0];
      v67[1] = v73[1];
      v67[2] = v73[2];
      v67[3] = v73[3];
      PCMatrix44Tmpl<double>::invert((double *)v67, (double *)v67, 0.0);
      LiAgent::getObjectToPixelTransform(a2, (uint64_t)&v58);
      PCMatrix44Tmpl<double>::operator*((uint64_t)&v58, v67, (uint64_t)v66);
      if (LiAgent::haveROI(a2)) {
        LiAgent::getROI((__n128 *)a2, (__n128 *)&v57);
      }
      else {
        long long v57 = xmmword_1B837C1E0;
      }
      long long v25 = *(_OWORD *)((char *)this + 552);
      long long v62 = *(_OWORD *)((char *)this + 536);
      long long v63 = v25;
      long long v26 = *(_OWORD *)((char *)this + 584);
      long long v64 = *(_OWORD *)((char *)this + 568);
      long long v65 = v26;
      float64x2_t v27 = *(float64x2_t *)((char *)this + 488);
      float64x2_t v58 = *(float64x2_t *)((char *)this + 472);
      float64x2_t v59 = v27;
      long long v28 = *(_OWORD *)((char *)this + 520);
      long long v60 = *(_OWORD *)((char *)this + 504);
      long long v61 = v28;
      PCMatrix44Tmpl<double>::operator*((uint64_t)&v84, (long long *)((char *)this + 600), (uint64_t)v56);
      uint64_t v29 = *((void *)a2 + 20);
      LiAgent::getFilmToImageTransform(a2, (uint64_t)v54);
      PCMatrix44Tmpl<double>::operator*(v29, v54, (uint64_t)v55);
      if (*((int *)this + 13) >= 1)
      {
        uint64_t v30 = 0;
        uint64_t v31 = 0;
        do
        {
          LiLight::mapShadows(*((void *)this + 7) + v30, (uint64_t)this + 600);
          ++v31;
          v30 += 944;
        }
        while (v31 < *((int *)this + 13));
      }
      PCMatrix44Tmpl<double>::operator*((uint64_t)this + 600, (long long *)((char *)this + 344), (uint64_t)v54);
      if ((long long *)((char *)this + 344) != v54)
      {
        for (uint64_t m = 0; m != 8; m += 2)
        {
          PCSharedCount v33 = (_OWORD *)((char *)this + m * 16 + 344);
          long long v34 = v54[m + 1];
          _OWORD *v33 = v54[m];
          v33[1] = v34;
        }
      }
      double v35 = *((double *)this + 24);
      if (v35 != 1.0)
      {
        float64x2_t v58 = vmulq_n_f64(v58, v35);
        float64x2_t v59 = vmulq_n_f64(v59, v35);
      }
      PCMatrix44Tmpl<double>::operator*((uint64_t)this + 600, (long long *)&v58, (uint64_t)v53);
      LiAgent::getPixelToObjectTransform((double **)a2, (uint64_t)&v38);
      PCMatrix44Tmpl<double>::operator*((uint64_t)v53, &v38, (uint64_t)v54);
      LiLightFilter::genObjectToScreenBlurMap(**((void **)a2 + 6), (long long *)((char *)this + 344), (uint64_t)v56, (uint64_t)v55, (uint64_t)v53);
      double v36 = (*(double (**)(uint64_t))(*(void *)v6 + 576))(v6);
      *(void *)&long long v38 = v93;
      if (v93) {
        (*(void (**)(uint64_t))(*(void *)v93 + 16))(v93);
      }
      *((void *)&v38 + 1) = (char *)this + 72;
      long long v39 = &v70;
      uint64_t v40 = &v91;
      long long v41 = v56;
      long long v42 = v68;
      uint64_t v43 = v69;
      PCSharedCount v44 = v54;
      int v45 = v66;
      PCSharedCount v46 = v67;
      uint64_t v47 = v73;
      unint64_t v48 = v53;
      float v49 = &v37;
      double v50 = v24;
      double v51 = v36;
      uint64_t v52 = 0x3FF0000000000000;
      LiLightSet::getHeliumGraph((char *)this + 40, &v38);
      PGHelium::MetalTextureCacheEntry::~MetalTextureCacheEntry((PGHelium::MetalTextureCacheEntry *)&v38);
      if (v93) {
        (*(void (**)(uint64_t))(*(void *)v93 + 24))(v93);
      }
    }
    else
    {
      *a3 = v93;
    }
  }
  else
  {
    *a3 = 0;
  }
}

void sub_1B7AAD35C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  uint64_t v15 = *(void *)(v13 - 88);
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 24))(v15);
  }
  _Unwind_Resume(exception_object);
}

double PCMatrix44Tmpl<double>::transform_normal<double>@<D0>(uint64_t a1@<X0>, double *a2@<X1>, float64x2_t *a3@<X8>)
{
  uint64_t v3 = 0;
  v6[0] = 0x3FF0000000000000;
  memset(&v6[1], 0, 24);
  void v6[4] = 0x3FF0000000000000;
  memset(&v6[5], 0, 24);
  v6[8] = 0x3FF0000000000000;
  do
  {
    long long v4 = &v6[v3];
    *(_OWORD *)long long v4 = *(_OWORD *)a1;
    v4[2] = *(void *)(a1 + 16);
    v3 += 3;
    a1 += 32;
  }
  while (v3 != 9);
  return PCMatrix33Tmpl<double>::transformNormal<double>((uint64_t)v6, a2, a3);
}

void LiLightFilter::genObjectToScreenBlurMap(uint64_t a1@<X1>, long long *a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  LiSimpleCamera::LiSimpleCamera((LiSimpleCamera *)v18);
  PCMatrix44Tmpl<double>::operator*(a3, a2, (uint64_t)v16);
  double v10 = v17;
  LiCamera::copy((uint64_t)v18, a1);
  LiCamera::convertToModel((uint64_t)v18, 1);
  double AngleOfView = LiSimpleCamera::getAngleOfView((LiSimpleCamera *)v18);
  LiSimpleCamera::setAngleOfView((uint64_t)v18, fmax(AngleOfView, 1.0));
  if (v10 > -20.0)
  {
    __n128 v14 = 0uLL;
    double v15 = -fabs(v10 + -20.0);
    LiSimpleCamera::setTranslation(v18, &v14);
    double v17 = fmin(v17, -20.0);
  }
  LiCamera::localToFilmMatrix((LiCamera *)v18, (uint64_t)v13);
  PCMatrix44Tmpl<double>::operator*(a4, v13, (uint64_t)&v14);
  PCMatrix44Tmpl<double>::operator*((uint64_t)&v14, v16, a5);
  LiSimpleCamera::~LiSimpleCamera((LiSimpleCamera *)v18, v12);
}

void sub_1B7AAD580(_Unwind_Exception *a1, const PCString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,char a58)
{
}

double PCMatrix33Tmpl<double>::transformNormal<double>@<D0>(uint64_t a1@<X0>, double *a2@<X1>, float64x2_t *a3@<X8>)
{
  double v9 = *a2;
  double v10 = a2[1];
  double v11 = a2[2];
  long long v4 = *(_OWORD *)(a1 + 16);
  float64x2_t v12 = *(float64x2_t *)a1;
  *(_OWORD *)uint64_t v13 = v4;
  float64x2_t v5 = *(float64x2_t *)(a1 + 48);
  *(_OWORD *)&v13[16] = *(_OWORD *)(a1 + 32);
  float64x2_t v14 = v5;
  double v15 = *(double *)(a1 + 64);
  PCMatrix33Tmpl<double>::invert(v12.f64, v12.f64, 0.0);
  double v6 = *(double *)v13;
  double v7 = *(double *)&v13[24];
  *a3 = vaddq_f64(vmulq_n_f64(v14, v11), vaddq_f64(vmulq_n_f64(v12, v9), vmulq_n_f64(*(float64x2_t *)&v13[8], v10)));
  double result = v9 * v6 + v10 * v7 + v11 * v15;
  a3[1].f64[0] = result;
  return result;
}

uint64_t LiNodeDrawer::LiNodeDrawer(uint64_t a1, uint64_t *a2, const LiPolygon *a3, int a4, char a5, uint64_t a6, double a7)
{
  LiDrawer::LiDrawer((LiDrawer *)a1);
  *float64x2_t v14 = &unk_1F111E508;
  uint64_t v15 = *a2;
  *(void *)(a1 + 48) = *a2;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 16))(v15);
  }
  LiPolygon::LiPolygon((LiPolygon *)(a1 + 56), a3);
  *(unsigned char *)(a1 + 192) = 0;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(double *)(a1 + 200) = a7;
  *(_DWORD *)(a1 + 208) = a4;
  *(unsigned char *)(a1 + 212) = a5;
  *(void *)(a1 + 216) = a6;
  *(void *)(a1 + 16) = a6;
  return a1;
}

void sub_1B7AAD738(_Unwind_Exception *a1)
{
  LiDrawer::~LiDrawer(v1);
  _Unwind_Resume(a1);
}

void LiNodeDrawer::LiNodeDrawer(LiNodeDrawer *this, const LiNodeDrawer *a2)
{
  LiDrawer::LiDrawer(this);
  void *v4 = &unk_1F111E508;
  uint64_t v5 = *((void *)a2 + 6);
  *((void *)this + 6) = v5;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
  }
  LiPolygon::LiPolygon((LiNodeDrawer *)((char *)this + 56), (const LiNodeDrawer *)((char *)a2 + 56));
  *((_OWORD *)this + 10) = *((_OWORD *)a2 + 10);
  *((_OWORD *)this + 11) = *((_OWORD *)a2 + 11);
  *((unsigned char *)this + 192) = *((unsigned char *)a2 + 192);
  *((void *)this + 25) = *((void *)a2 + 25);
  *((_DWORD *)this + 52) = *((_DWORD *)a2 + 52);
  *((unsigned char *)this + 212) = *((unsigned char *)a2 + 212);
  *((void *)this + 27) = *((void *)a2 + 27);
}

void sub_1B7AAD844(_Unwind_Exception *a1)
{
  LiDrawer::~LiDrawer(v1);
  _Unwind_Resume(a1);
}

void LiNodeDrawer::~LiNodeDrawer(LiNodeDrawer *this)
{
  *(void *)this = &unk_1F111E508;
  LiPolygon::~LiPolygon((LiNodeDrawer *)((char *)this + 56));
  uint64_t v2 = *((void *)this + 6);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }

  LiDrawer::~LiDrawer(this);
}

{
  uint64_t vars8;

  LiNodeDrawer::~LiNodeDrawer(this);

  JUMPOUT(0x1BA9BFBA0);
}

void LiNodeDrawer::draw(LiNodeDrawer *this, LiBlender *a2)
{
  LiImagePolygon::LiImagePolygon((LiImagePolygon *)v9);
  if (*((unsigned char *)this + 192))
  {
    LiImagePolygon::set((uint64_t)v9, (uint64_t)this + 56, 1);
    LiBlender::crop((uint64_t)a2, (uint64_t)v9, 0);
  }
  uint64_t v4 = *((unsigned int *)this + 52);
  double v5 = *((double *)this + 25);
  int v6 = *((unsigned __int8 *)this + 212);
  uint64_t v7 = 0;
  PCSharedCount::PCSharedCount(&v8);
  (*(void (**)(LiBlender *, char *, uint64_t, void, BOOL, uint64_t *, double))(*(void *)a2 + 16))(a2, (char *)this + 48, v4, 0, v6 != 0, &v7, v5);
  PCSharedCount::~PCSharedCount(&v8);
  LiImagePolygon::~LiImagePolygon((LiImagePolygon *)v9);
}

void sub_1B7AADA38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  PCSharedCount::~PCSharedCount(v11);
  LiImagePolygon::~LiImagePolygon((LiImagePolygon *)&a11);
  _Unwind_Resume(a1);
}

uint64_t LiNodeDrawer::getBounds(LiNodeDrawer *this)
{
  return (uint64_t)this + 56;
}

uint64_t LiNodeDrawer::isPlanar(LiNodeDrawer *this)
{
  uint64_t v1 = *((void *)this + 27);
  if (v1) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 40))();
  }
  else {
    return 1;
  }
}

void LiNodeDrawer::setPlane(float64x2_t *this, float64x2_t *a2)
{
  float64x2_t v2 = a2[1];
  this[10] = *a2;
  this[11] = v2;
  LiNodeDrawer::projectBoundsToPlane(this);
}

void LiNodeDrawer::projectBoundsToPlane(float64x2_t *this)
{
  if ((*(unsigned int (**)(float64x2_t *))(*(void *)&this->f64[0] + 40))(this))
  {
    if (((*(void *)&this[8].f64[0] - *(void *)&this[7].f64[1]) & 0x1FFFFFFFE0) != 0)
    {
      v2[0] = 0.0;
      v2[1] = 0.0;
      PCString v2[2] = 1.0;
      LiPolygon::projectToPlane((uint64_t)&this[3].f64[1], this + 10, v2);
    }
  }
}

__n128 LiNodeDrawer::getPlane@<Q0>(__n128 *this@<X0>, __n128 *a2@<X8>)
{
  __n128 result = this[10];
  __n128 v3 = this[11];
  *a2 = result;
  a2[1] = v3;
  return result;
}

uint64_t LiNodeDrawer::getSceneObject(LiNodeDrawer *this)
{
  uint64_t result = *((void *)this + 27);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 72))();
  }
  return result;
}

void LiNodeDrawer::intersect(LiNodeDrawer *this, LiIntersection *a2)
{
  if (*((int *)a2 + 5) >= 1) {
    operator new();
  }
}

void sub_1B7AADC34(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C40123E26DALL);
  _Unwind_Resume(a1);
}

void LiNodeDrawer::name(LiNodeDrawer *this@<X0>, LiString *a2@<X8>)
{
  LiString::LiString(a2, "Node");
  uint64_t v4 = *((void *)this + 27);
  if (v4)
  {
    (*(void (**)(unsigned char **__return_ptr))(*(void *)v4 + 88))(&v13);
    double v5 = v13;
    if (v13) {
      int v6 = *((_DWORD *)v13 - 2);
    }
    else {
      int v6 = 0;
    }
    uint64_t v7 = (unsigned int *)malloc_type_malloc(v6 + 14, 0x8903763CuLL);
    uint64_t v8 = v6 + 1;
    v7[2] = v6 + 2;
    atomic_store(1u, v7);
    atomic_store(0, v7);
    *((unsigned char *)v7 + 12) = 40;
    v7[1] = v8;
    memcpy((char *)v7 + 13, v5, v6);
    *((unsigned char *)v7 + v8 + 12) = 0;
    atomic_fetch_add((atomic_uint *volatile)v7, 1u);
    size_t v9 = (int)v7[1];
    double v10 = (unsigned int *)malloc_type_malloc(v9 + 14, 0x8903763CuLL);
    atomic_store(1u, v10);
    double v11 = v10 + 3;
    atomic_store(0, v10);
    v10[1] = v9 + 1;
    _OWORD v10[2] = v9 + 2;
    memcpy(v10 + 3, v7 + 3, v9);
    *((unsigned char *)v11 + v9) = 41;
    *((unsigned char *)v11 + v9 + 1) = 0;
    atomic_fetch_add((atomic_uint *volatile)v10, 1u);
    LiString::append(a2, (const char *)v10 + 12, v10[1]);
    if (atomic_fetch_add((atomic_uint *volatile)v10, 0xFFFFFFFF) == 1) {
      free(v10);
    }
    if (atomic_fetch_add((atomic_uint *volatile)v7, 0xFFFFFFFF) == 1) {
      free(v7);
    }
    if (v13 && atomic_fetch_add((atomic_uint *volatile)v13 - 3, 0xFFFFFFFF) == 1)
    {
      *uint64_t v13 = 0;
      if (v13) {
        float64x2_t v12 = v13 - 12;
      }
      else {
        float64x2_t v12 = 0;
      }
      free(v12);
    }
  }
}

void sub_1B7AADE0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, atomic_uint *a10)
{
  uint64_t v13 = v12;
  if (atomic_fetch_add((atomic_uint *volatile)v13, 0xFFFFFFFF) == 1) {
    free(v13);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v11, 0xFFFFFFFF) == 1) {
    free(v11);
  }
  if (a10)
  {
    if (atomic_fetch_add(a10 - 3, 0xFFFFFFFF) == 1)
    {
      *(unsigned char *)a10 = 0;
      free(a10 - 3);
    }
  }
  LiString::dec(v10);
  _Unwind_Resume(a1);
}

void LiNodeDrawer::dump(LiNodeDrawer *this, const char **a2)
{
  if (*a2) {
    uint64_t v4 = *a2;
  }
  else {
    uint64_t v4 = "";
  }
  size_t v5 = strlen(v4);
  int v6 = (void *)MEMORY[0x1E4FBA240];
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)v4, v5);
  (*(void (**)(const char **__return_ptr, LiNodeDrawer *))(*(void *)this + 88))(&v17, this);
  if (v17) {
    uint64_t v7 = v17;
  }
  else {
    uint64_t v7 = "";
  }
  size_t v8 = strlen(v7);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)v7, v8);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E4FBA240], (uint64_t)"\n", 1);
  if (v17 && atomic_fetch_add((atomic_uint *volatile)v17 - 3, 0xFFFFFFFF) == 1)
  {
    *double v17 = 0;
    if (v17) {
      size_t v9 = (char *)(v17 - 12);
    }
    else {
      size_t v9 = 0;
    }
    free(v9);
  }
  uint64_t v10 = *((void *)this + 27);
  if (v10)
  {
    double v11 = *a2;
    int v12 = v11 ? *((_DWORD *)v11 - 2) : 0;
    uint64_t v13 = v12 + 6;
    float64x2_t v14 = (unsigned int *)malloc_type_malloc(v12 + 19, 0x8903763CuLL);
    v14[1] = v13;
    float64x2_t v14[2] = v12 + 7;
    atomic_store(1u, v14);
    atomic_store(0, v14);
    memcpy(v14 + 3, v11, v12);
    uint64_t v15 = (uint64_t)v14 + v12 + 12;
    *(_DWORD *)uint64_t v15 = 1919950880;
    *(_WORD *)(v15 + 4) = 8293;
    *((unsigned char *)v14 + v13 + 12) = 0;
    double v17 = (const char *)(v14 + 3);
    atomic_fetch_add((atomic_uint *volatile)v14, 1u);
    (*(void (**)(uint64_t, const char **))(*(void *)v10 + 96))(v10, &v17);
    if (v17)
    {
      if (atomic_fetch_add((atomic_uint *volatile)v17 - 3, 0xFFFFFFFF) == 1)
      {
        *double v17 = 0;
        if (v17) {
          long long v16 = (char *)(v17 - 12);
        }
        else {
          long long v16 = 0;
        }
        free(v16);
      }
    }
  }
}

void sub_1B7AAE0A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    ProShade::VertexProgram::VertexProgram(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t LiNodeDrawer::getFilterIntersections(LiNodeDrawer *this)
{
  uint64_t v1 = *((void *)this + 27);
  if (v1) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 112))();
  }
  else {
    return 1;
  }
}

uint64_t LiNodeDrawer::getBlendMode(LiNodeDrawer *this)
{
  return *((unsigned int *)this + 52);
}

uint64_t LiNodeDrawer::defocus(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 216) + 136))();
}

uint64_t LiPlanarGroup::LiPlanarGroup(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = &unk_1F111A080;
  PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::resize(a1 + 32, 1, 3);
  *(void *)(*(void *)(a1 + 48) + 8 * *(int *)(a1 + 44) - 8) = a3;
  long long v6 = a2[1];
  *(_OWORD *)a1 = *a2;
  *(_OWORD *)(a1 + 16) = v6;
  LiPlanarGroup::normalize((float64x2_t *)a1);
  return a1;
}

void sub_1B7AAE1D0(_Unwind_Exception *a1)
{
  PCPtrArray<LiDrawer>::~PCPtrArray(v1);
  _Unwind_Resume(a1);
}

double LiPlanarGroup::normalize(float64x2_t *this)
{
  PCVector4<double>::normalize(this->f64, 0.000000100000001);
  double result = this[1].f64[1];
  if (result < 0.0)
  {
    *this = vnegq_f64(*this);
    double v3 = this[1].f64[0];
LABEL_12:
    double result = -result;
    this[1].f64[0] = -v3;
    this[1].f64[1] = result;
    return result;
  }
  if (result > 0.0) {
    return result;
  }
  double v3 = this[1].f64[0];
  if (v3 < 0.0)
  {
    *this = vnegq_f64(*this);
    goto LABEL_12;
  }
  if (v3 > 0.0) {
    return result;
  }
  double v4 = this->f64[1];
  if (v4 < 0.0)
  {
    double v5 = this->f64[0];
LABEL_11:
    this->f64[0] = -v5;
    this->f64[1] = -v4;
    goto LABEL_12;
  }
  if (v4 <= 0.0)
  {
    double v5 = this->f64[0];
    if (this->f64[0] < 0.0) {
      goto LABEL_11;
    }
  }
  return result;
}

uint64_t lexical_compare(double *a1, double *a2)
{
  double v2 = a1[3];
  double v3 = a2[3];
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  if (v2 > v3) {
    return 1;
  }
  double v4 = a1[2];
  double v5 = a2[2];
  if (v4 < v5) {
    return 0xFFFFFFFFLL;
  }
  if (v4 > v5) {
    return 1;
  }
  double v6 = a1[1];
  double v7 = a2[1];
  if (v6 < v7) {
    return 0xFFFFFFFFLL;
  }
  if (v6 > v7) {
    return 1;
  }
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  return *a1 > *a2;
}

BOOL PCVector4<double>::normalize(double *a1, double a2)
{
  double v2 = *a1;
  double v3 = a1[1];
  double v4 = a1[2];
  double v5 = a1[3];
  double v6 = sqrt(v2 * v2 + v3 * v3 + v4 * v4 + v5 * v5);
  BOOL v7 = v6 >= a2 || v6 <= -a2;
  if (v7)
  {
    *a1 = v2 / v6;
    a1[1] = v3 / v6;
    a1[2] = v4 / v6;
    a1[3] = v5 / v6;
  }
  return v7;
}

void LiPlanarGroupSet::LiPlanarGroupSet(void *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1F111E5D8;
  operator new();
}

void sub_1B7AAE404(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v2, 0x1080C402A14C379);
  PCPtrArray<LiPlanarGroup>::~PCPtrArray(v1);
  _Unwind_Resume(a1);
}

uint64_t PCPtrArray<LiPlanarGroup>::~PCPtrArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111E628;
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2 < 0) {
    int v3 = 1;
  }
  else {
    int v3 = v2 & ~(v2 >> 31);
  }
  if (v3 == v2)
  {
    uint64_t v4 = *(int *)(a1 + 12);
    if ((v4 & 0x80000000) != 0)
    {
      do
        *(void *)(*(void *)(a1 + 16) + 8 * v4) = 0;
      while (!__CFADD__(v4++, 1));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6) {
      MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = 0;
  uint64_t v7 = *(void *)(a1 + 16);
  if (v7) {
    MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

void LiPlanarGroupSet::~LiPlanarGroupSet(LiPlanarGroupSet *this)
{
  PCPtrArray<LiPlanarGroup>::deleteAll((unsigned int *)this);
  *(void *)this = &unk_1F111E628;
  int v2 = *((_DWORD *)this + 2);
  if (v2 < 0) {
    int v3 = 1;
  }
  else {
    int v3 = v2 & ~(v2 >> 31);
  }
  if (v3 == v2)
  {
    uint64_t v4 = *((int *)this + 3);
    if ((v4 & 0x80000000) != 0)
    {
      do
        *(void *)(*((void *)this + 2) + 8 * v4) = 0;
      while (!__CFADD__(v4++, 1));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    uint64_t v6 = *((void *)this + 2);
    if (v6) {
      MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
    }
    *((void *)this + 2) = 0;
  }
  *((_DWORD *)this + 2) = v3;
  *((_DWORD *)this + 3) = 0;
  uint64_t v7 = *((void *)this + 2);
  if (v7) {
    MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
  }
  *((void *)this + 2) = 0;
  *((_DWORD *)this + 2) = 0;
}

unsigned int *PCPtrArray<LiPlanarGroup>::deleteAll(unsigned int *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[3];
  if ((int)v2 >= 1)
  {
    for (uint64_t i = 0; i != v2; ++i)
    {
      if (i >= (int)v1[3]) {
        PCArray_base::badIndex((PCArray_base *)result);
      }
      uint64_t v4 = *(void *)(*((void *)v1 + 2) + 8 * i);
      if (v4)
      {
        *(void *)(v4 + 32) = &unk_1F111A0D0;
        int v5 = *(_DWORD *)(v4 + 40);
        if (v5 < 0) {
          int v6 = 1;
        }
        else {
          int v6 = v5 & ~(v5 >> 31);
        }
        if (v6 == v5)
        {
          uint64_t v7 = *(int *)(v4 + 44);
          if ((v7 & 0x80000000) != 0)
          {
            do
            {
              *(void *)(*(void *)(v4 + 48) + 8 * v7) = 0;
              BOOL v8 = __CFADD__(v7++, 1);
            }
            while (!v8);
          }
        }
        else
        {
          if (v6) {
            operator new[]();
          }
          uint64_t v9 = *(void *)(v4 + 48);
          if (v9) {
            MEMORY[0x1BA9BFB70](v9, 0x1000C8077774924);
          }
          *(void *)(v4 + 48) = 0;
        }
        *(_DWORD *)(v4 + 40) = v6;
        *(_DWORD *)(v4 + 44) = 0;
        uint64_t v10 = *(void *)(v4 + 48);
        if (v10) {
          MEMORY[0x1BA9BFB70](v10, 0x1000C8077774924);
        }
        *(void *)(v4 + 48) = 0;
        *(_DWORD *)(v4 + 40) = 0;
        double result = (unsigned int *)MEMORY[0x1BA9BFBA0](v4, 0x1080C402A14C379);
      }
      if (i >= (int)v1[3]) {
        PCArray_base::badIndex((PCArray_base *)result);
      }
      *(void *)(*((void *)v1 + 2) + 8 * i) = 0;
    }
  }
  int v11 = v1[2];
  if (v11 < 0) {
    int v12 = 1;
  }
  else {
    int v12 = v11 & ~(v11 >> 31);
  }
  if (v12 == v11)
  {
    uint64_t v13 = (int)v1[3];
    if ((v13 & 0x80000000) != 0)
    {
      do
      {
        *(void *)(*((void *)v1 + 2) + 8 * v13) = 0;
        BOOL v8 = __CFADD__(v13++, 1);
      }
      while (!v8);
    }
  }
  else
  {
    if (v12) {
      operator new[]();
    }
    double result = (unsigned int *)*((void *)v1 + 2);
    if (result) {
      double result = (unsigned int *)MEMORY[0x1BA9BFB70](result, 0x1000C8077774924);
    }
    *((void *)v1 + 2) = 0;
  }
  v1[2] = v12;
  v1[3] = 0;
  return result;
}

void LiPlanarGroupSet::transform(LiPlanarGroupSet *this, const LiPlaneTransform *a2)
{
  uint64_t v3 = *((unsigned int *)this + 3);
  if ((int)v3 >= 1)
  {
    do
    {
      if (v3 > *((int *)this + 3)) {
        PCArray_base::badIndex(this);
      }
      int v5 = *(float64x2_t **)(*((void *)this + 2) + 8 * --v3);
      LiPlaneTransform::operator()((uint64_t)a2, v5->f64, (uint64_t)v5);
      LiPlanarGroup::normalize(v5);
    }
    while ((unint64_t)(v3 + 1) > 1);
    LODWORD(v3) = *((_DWORD *)this + 3);
  }
  if (v3)
  {
    int v6 = (void *)*((void *)this + 2);
    qsort(v6, v3, 8uLL, (int (__cdecl *)(const void *, const void *))lexical_compare);
  }
}

uint64_t lexical_compare(double **a1, double **a2)
{
  return lexical_compare(*a1, *a2);
}

uint64_t LiPlanarGroupSet::mergeFrom(uint64_t result, uint64_t a2)
{
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  long long v41 = &unk_1F111E5D8;
  int v2 = *(_DWORD *)(result + 12);
  int v38 = *(_DWORD *)(a2 + 12);
  if (v2)
  {
    if (v2 <= 0) {
      PCArray_base::badIndex((PCArray_base *)result);
    }
    uint64_t v3 = **(double ***)(result + 16);
  }
  else
  {
    uint64_t v3 = 0;
  }
  uint64_t v35 = result;
  int v36 = *(_DWORD *)(result + 12);
  if (v38)
  {
    if (*(int *)(a2 + 12) <= 0) {
      PCArray_base::badIndex((PCArray_base *)result);
    }
    uint64_t v4 = **(double ***)(a2 + 16);
  }
  else
  {
    uint64_t v4 = 0;
  }
  uint64_t v5 = 0;
  int v39 = 0;
  int v6 = 0;
  if (!v3) {
    goto LABEL_31;
  }
  do
  {
    if (!v4)
    {
      uint64_t v8 = (int)v5 + 1;
      if ((int)v8 < v36)
      {
        if ((int)v5 < -1 || *(_DWORD *)(v35 + 12) <= (int)v8) {
          PCArray_base::badIndex((PCArray_base *)result);
        }
        uint64_t v4 = 0;
        uint64_t v9 = *(double **)(*(void *)(v35 + 16) + 8 * v8);
        goto LABEL_28;
      }
      uint64_t v4 = 0;
LABEL_30:
      uint64_t v40 = 0;
      goto LABEL_40;
    }
    double result = lexical_compare(v3, v4);
    if ((int)result <= 0)
    {
      uint64_t v8 = (int)v5 + 1;
      if ((int)v8 < v36)
      {
        if ((int)v5 < -1 || *(_DWORD *)(v35 + 12) <= (int)v8) {
          PCArray_base::badIndex((PCArray_base *)result);
        }
        uint64_t v9 = *(double **)(*(void *)(v35 + 16) + 8 * v8);
LABEL_28:
        uint64_t v40 = v9;
        goto LABEL_40;
      }
      goto LABEL_30;
    }
    uint64_t v7 = v39 + 1;
    uint64_t v40 = v3;
    if ((int)v7 >= v38) {
      goto LABEL_39;
    }
    if (v39 < -1 || *(_DWORD *)(a2 + 12) <= (int)v7) {
      PCArray_base::badIndex((PCArray_base *)result);
    }
LABEL_37:
    uint64_t v3 = v4;
    uint64_t v4 = *(double **)(*(void *)(a2 + 16) + 8 * v7);
    uint64_t v8 = v5;
    int v39 = v7;
LABEL_40:
    int v10 = HIDWORD(v42);
    uint64_t v11 = v6;
    if (v6 <= SHIDWORD(v42)) {
      int v12 = HIDWORD(v42);
    }
    else {
      int v12 = v6;
    }
    uint64_t v13 = ((uint64_t)v6-- << 32) - 0x100000000;
    do
    {
      if (v12 == v11)
      {
        int v6 = v12;
LABEL_60:
        if ((int)v42 <= SHIDWORD(v42)) {
          int v16 = (2 * (HIDWORD(v42) + 1)) | 1;
        }
        else {
          int v16 = v42;
        }
        double result = PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::resize((uint64_t)&v41, HIDWORD(v42) + 1, v16);
        *(void *)(v43 + 8 * SHIDWORD(v42) - 8) = v3;
        goto LABEL_64;
      }
      if (v11 < 0 || v11 >= SHIDWORD(v42)) {
        PCArray_base::badIndex((PCArray_base *)result);
      }
      double v14 = *(double *)(*(void *)(v43 + 8 * v11++) + 24);
      v13 += 0x100000000;
      ++v6;
    }
    while (v14 < v3[3] + -1.0e-10);
    if (SHIDWORD(v42) <= v6) {
      goto LABEL_60;
    }
    while (1)
    {
      if (v6 < 0 || SHIDWORD(v42) <= v6) {
        PCArray_base::badIndex((PCArray_base *)result);
      }
      uint64_t v15 = *(double **)(v43 + 8 * (v13 >> 32));
      if (vabdd_f64(*v3, *v15) < 1.0e-10
        && vabdd_f64(v3[1], v15[1]) < 1.0e-10
        && vabdd_f64(v3[2], v15[2]) < 1.0e-10
        && vabdd_f64(v3[3], v15[3]) < 1.0e-10)
      {
        break;
      }
      if (v6 == --v10) {
        goto LABEL_60;
      }
    }
    if (v6 < 0 || SHIDWORD(v42) <= v6) {
      PCArray_base::badIndex((PCArray_base *)result);
    }
    PCArray<LiDrawer *,PCArray_Traits_Zero<LiDrawer *>>::append((uint64_t)(v15 + 4), (uint64_t)(v3 + 4));
    *((void *)v3 + 4) = &unk_1F111A0D0;
    int v17 = *((_DWORD *)v3 + 10);
    if (v17 < 0) {
      int v18 = 1;
    }
    else {
      int v18 = v17 & ~(v17 >> 31);
    }
    if (v18 == v17)
    {
      uint64_t v19 = *((int *)v3 + 11);
      if ((v19 & 0x80000000) != 0)
      {
        do
        {
          *(void *)(*((void *)v3 + 6) + 8 * v19) = 0;
          BOOL v20 = __CFADD__(v19++, 1);
        }
        while (!v20);
      }
    }
    else
    {
      if (v18) {
        operator new[]();
      }
      uint64_t v21 = *((void *)v3 + 6);
      if (v21) {
        MEMORY[0x1BA9BFB70](v21, 0x1000C8077774924);
      }
      v3[6] = 0.0;
    }
    *((_DWORD *)v3 + 10) = v18;
    *((_DWORD *)v3 + 11) = 0;
    uint64_t v22 = *((void *)v3 + 6);
    if (v22) {
      MEMORY[0x1BA9BFB70](v22, 0x1000C8077774924);
    }
    v3[6] = 0.0;
    *((_DWORD *)v3 + 10) = 0;
    double result = MEMORY[0x1BA9BFBA0](v3, 0x1080C402A14C379);
LABEL_64:
    uint64_t v5 = v8;
    uint64_t v3 = v40;
  }
  while (v40);
LABEL_31:
  if (v4)
  {
    uint64_t v7 = v39 + 1;
    if ((int)v7 < v38)
    {
      if (v39 < -1 || *(_DWORD *)(a2 + 12) <= (int)v7) {
        PCArray_base::badIndex((PCArray_base *)result);
      }
      uint64_t v40 = 0;
      goto LABEL_37;
    }
    uint64_t v40 = 0;
LABEL_39:
    uint64_t v3 = v4;
    uint64_t v8 = v5;
    int v39 = v7;
    uint64_t v4 = 0;
    goto LABEL_40;
  }
  int v23 = *(_DWORD *)(v35 + 8);
  if (v23 < 0) {
    int v24 = 1;
  }
  else {
    int v24 = v23 & ~(v23 >> 31);
  }
  if (v24 == v23)
  {
    uint64_t v25 = *(int *)(v35 + 12);
    uint64_t v26 = a2;
    if ((v25 & 0x80000000) != 0)
    {
      do
      {
        *(void *)(*(void *)(v35 + 16) + 8 * v25) = 0;
        BOOL v20 = __CFADD__(v25++, 1);
      }
      while (!v20);
    }
    uint64_t v27 = *(void *)(v35 + 16);
  }
  else
  {
    uint64_t v26 = a2;
    if (v24) {
      operator new[]();
    }
    uint64_t v27 = 0;
    double result = *(void *)(v35 + 16);
    if (result) {
      double result = MEMORY[0x1BA9BFB70](result, 0x1000C8077774924);
    }
    *(void *)(v35 + 16) = 0;
  }
  *(_DWORD *)(v35 + 8) = v24;
  *(_DWORD *)(v35 + 12) = 0;
  if (v27) {
    double result = MEMORY[0x1BA9BFB70](v27, 0x1000C8077774924);
  }
  *(void *)(v35 + 8) = v42;
  *(void *)(v35 + 16) = v43;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  int v28 = *(_DWORD *)(v26 + 8);
  if (v28 < 0) {
    int v29 = 1;
  }
  else {
    int v29 = v28 & ~(v28 >> 31);
  }
  if (v29 == v28)
  {
    uint64_t v30 = *(int *)(v26 + 12);
    if ((v30 & 0x80000000) != 0)
    {
      do
      {
        *(void *)(*(void *)(v26 + 16) + 8 * v30) = 0;
        BOOL v20 = __CFADD__(v30++, 1);
      }
      while (!v20);
    }
    uint64_t v31 = *(void *)(v26 + 16);
  }
  else
  {
    if (v29) {
      operator new[]();
    }
    uint64_t v31 = 0;
    double result = *(void *)(v26 + 16);
    if (result) {
      double result = MEMORY[0x1BA9BFB70](result, 0x1000C8077774924);
    }
    *(void *)(v26 + 16) = 0;
  }
  *(_DWORD *)(v26 + 8) = v29;
  *(_DWORD *)(v26 + 12) = 0;
  if (v31) {
    double result = MEMORY[0x1BA9BFB70](v31, 0x1000C8077774924);
  }
  *(void *)(v26 + 16) = 0;
  *(_DWORD *)(v26 + 8) = 0;
  long long v41 = &unk_1F111E628;
  if ((int)v42 < 0) {
    unsigned int v32 = 1;
  }
  else {
    unsigned int v32 = v42 & ~((int)v42 >> 31);
  }
  if (v32 == v42)
  {
    uint64_t v33 = SHIDWORD(v42);
    if (v42 < 0)
    {
      do
      {
        *(void *)(v43 + 8 * v33) = 0;
        BOOL v20 = __CFADD__(v33++, 1);
      }
      while (!v20);
    }
    uint64_t v34 = v43;
  }
  else
  {
    if (v32) {
      operator new[]();
    }
    uint64_t v34 = 0;
    double result = v43;
    if (v43) {
      double result = MEMORY[0x1BA9BFB70](v43, 0x1000C8077774924);
    }
    uint64_t v43 = 0;
  }
  uint64_t v42 = v32;
  if (v34) {
    return MEMORY[0x1BA9BFB70](v34, 0x1000C8077774924);
  }
  return result;
}

void sub_1B7AAF008(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  PCPtrArray<LiPlanarGroup>::~PCPtrArray((uint64_t)va);
  _Unwind_Resume(a1);
}

unsigned int *LiPlanarGroupSet::gatherDrawers(unsigned int *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result[3];
  if ((int)v3 >= 1)
  {
    int v6 = result;
    uint64_t v7 = 0;
    while (1)
    {
      if (v7 >= (int)v6[3]) {
        PCArray_base::badIndex((PCArray_base *)result);
      }
      uint64_t v8 = *(void *)(*((void *)v6 + 2) + 8 * v7);
      int v9 = *(_DWORD *)(v8 + 44);
      long long v10 = *(_OWORD *)(v8 + 16);
      v15[0] = *(_OWORD *)v8;
      v15[1] = v10;
      double result = (unsigned int *)PCPlaneType((double *)v15);
      uint64_t v11 = a3;
      if (!result) {
        goto LABEL_8;
      }
      if (result != 1) {
        break;
      }
LABEL_18:
      if (v3 == ++v7) {
        return result;
      }
    }
    uint64_t v11 = a2;
LABEL_8:
    if (v9)
    {
      if (v9 != 1) {
        operator new();
      }
      if (*(int *)(v8 + 44) <= 0) {
        PCArray_base::badIndex((PCArray_base *)result);
      }
      uint64_t v12 = **(void **)(v8 + 48);
      int v13 = *(_DWORD *)(v11 + 12);
      if (*(_DWORD *)(v11 + 8) <= v13) {
        int v14 = (2 * (v13 + 1)) | 1;
      }
      else {
        int v14 = *(_DWORD *)(v11 + 8);
      }
      double result = (unsigned int *)PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::resize(v11, v13 + 1, v14);
      *(void *)(*(void *)(v11 + 16) + 8 * *(int *)(v11 + 12) - 8) = v12;
    }
    goto LABEL_18;
  }
  return result;
}

void sub_1B7AAF210(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10A1C4096833E04);
  _Unwind_Resume(a1);
}

void LiPlanarGroupHerd::~LiPlanarGroupHerd(LiPlanarGroupHerd *this)
{
  if ((int)*((void *)this + 5) >= 1)
  {
    uint64_t v2 = *((void *)this + 4);
    unint64_t v3 = *((void *)this + 5) + 1;
    do
    {
      uint64_t v4 = (v3 - 2);
      uint64_t v5 = *((void *)this + 1);
      unint64_t v6 = (unint64_t)(v2 + v4) >> 9;
      uint64_t v7 = (v2 + v4) & 0x1FF;
      uint64_t v8 = *(LiPlanarGroupSet **)(*(void *)(v5 + 8 * v6) + 8 * v7);
      if (v8)
      {
        LiPlanarGroupSet::~LiPlanarGroupSet(v8);
        MEMORY[0x1BA9BFBA0]();
        uint64_t v2 = *((void *)this + 4);
        uint64_t v5 = *((void *)this + 1);
        unint64_t v6 = (unint64_t)(v2 + v4) >> 9;
        uint64_t v7 = (v2 + v4) & 0x1FF;
      }
      *(void *)(*(void *)(v5 + 8 * v6) + 8 * v7) = 0;
      --v3;
    }
    while (v3 > 1);
  }

  std::deque<unsigned long>::~deque[abi:ne180100](this);
}

void LiPlanarGroupHerd::add(LiPlanarGroupHerd *this, LiPlanarGroupSet *a2)
{
  uint64_t v2 = a2;
  std::deque<LiPlanarGroupSet *>::push_back(this, &v2);
}

void std::deque<LiPlanarGroupSet *>::push_back(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    std::deque<LiPlanarGroupSet *>::__add_back_capacity(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }
  *(void *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

uint64_t LiPlanarGroupHerd::condense(int64x2_t *this)
{
  unint64_t v1 = this[2].u64[1];
  if (!v1) {
    return 0;
  }
  if (v1 != 1)
  {
    do
    {
      uint64_t v12 = 0;
      unint64_t v3 = this[2].u64[0];
      uint64_t v12 = *(void *)(*(void *)(this->i64[1] + ((v3 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v3 & 0x1FF));
      this[2].i64[0] = v3 + 1;
      this[2].i64[1] = v1 - 1;
      std::deque<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>>::__maybe_remove_front_spare[abi:ne180100]((uint64_t)this, 1);
      uint64_t v4 = *(LiPlanarGroupSet **)(*(void *)(this->i64[1]
                                            + (((unint64_t)this[2].i64[0] >> 6) & 0x3FFFFFFFFFFFFF8))
                                + 8 * (this[2].i64[0] & 0x1FF));
      this[2] = vaddq_s64(this[2], (int64x2_t)xmmword_1B7E73580);
      std::deque<std::__map_iterator<std::__tree_iterator<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,std::__tree_node<std::__value_type<ProGL::TextureDescription,ProGL::Private::TextureImpl *>,void *> *,long>>>::__maybe_remove_front_spare[abi:ne180100]((uint64_t)this, 1);
      LiPlanarGroupSet::mergeFrom(v12, (uint64_t)v4);
      std::deque<LiPlanarGroupSet *>::push_front((uint64_t)this, &v12);
      LiPlanarGroupSet::~LiPlanarGroupSet(v4);
      MEMORY[0x1BA9BFBA0]();
      unint64_t v1 = this[2].u64[1];
    }
    while (v1 > 1);
  }
  uint64_t v5 = (void **)this->i64[1];
  uint64_t v6 = this[1].i64[0];
  uint64_t v7 = (*(void **)((char *)v5 + (((unint64_t)this[2].i64[0] >> 6) & 0x3FFFFFFFFFFFFF8)))[this[2].i64[0] & 0x1FF];
  this[2].i64[1] = 0;
  unint64_t v8 = v6 - (void)v5;
  if ((unint64_t)(v6 - (void)v5) >= 0x11)
  {
    do
    {
      operator delete(*v5);
      uint64_t v9 = this[1].i64[0];
      uint64_t v5 = (void **)(this->i64[1] + 8);
      this->i64[1] = (uint64_t)v5;
      unint64_t v8 = v9 - (void)v5;
    }
    while (v8 > 0x10);
  }
  if (v8 >> 3 == 1)
  {
    uint64_t v10 = 256;
    goto LABEL_11;
  }
  if (v8 >> 3 == 2)
  {
    uint64_t v10 = 512;
LABEL_11:
    this[2].i64[0] = v10;
  }
  return v7;
}

void std::deque<LiPlanarGroupSet *>::push_front(uint64_t a1, void *a2)
{
  unint64_t v4 = *(void *)(a1 + 32);
  if (!v4)
  {
    std::deque<LiPlanarGroupSet *>::__add_front_capacity((void **)a1);
    unint64_t v4 = *(void *)(a1 + 32);
  }
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = (void *)(v5 + 8 * (v4 >> 9));
  if (*(void *)(a1 + 16) == v5) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = *v6 + 8 * (v4 & 0x1FF);
  }
  if (v7 == *v6) {
    uint64_t v7 = *(v6 - 1) + 4096;
  }
  *(void *)(v7 - 8) = *a2;
  uint64_t v8 = *(void *)(a1 + 40) + 1;
  *(void *)(a1 + 32) = v4 - 1;
  *(void *)(a1 + 40) = v8;
}

void PCPtrArray<LiPlanarGroup>::~PCPtrArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111E628;
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2 < 0) {
    int v3 = 1;
  }
  else {
    int v3 = v2 & ~(v2 >> 31);
  }
  if (v3 == v2)
  {
    uint64_t v4 = *(int *)(a1 + 12);
    if ((v4 & 0x80000000) != 0)
    {
      do
        *(void *)(*(void *)(a1 + 16) + 8 * v4) = 0;
      while (!__CFADD__(v4++, 1));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6) {
      MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = 0;
  uint64_t v7 = *(void *)(a1 + 16);
  if (v7) {
    MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

void std::deque<LiPlanarGroupSet *>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)uint64_t v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      int v38 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        uint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        long long v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)long long v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      uint64_t v9 = (char *)a1[1];
    }
    uint64_t v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      std::__split_buffer<unsigned long *>::push_back(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    std::__split_buffer<unsigned long *>::push_front((uint64_t)a1, &v54);
    PCSharedCount v44 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    uint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a1 + 3), v46);
      uint64_t v35 = &v34[8 * (v46 >> 2)];
      uint64_t v37 = &v34[8 * v47];
      unint64_t v48 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        uint64_t v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        double v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)double v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      uint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        uint64_t v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  char v56 = a1 + 3;
  *(void *)&long long v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  unint64_t v53 = operator new(0x1000uLL);
  std::__split_buffer<unsigned long *>::push_back(&v54, &v53);
  uint64_t v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<unsigned long *>::push_front((uint64_t)&v54, v27);
  }
  int v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_1B7AAF978(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void std::deque<LiPlanarGroupSet *>::__add_front_capacity(void **a1)
{
  unint64_t v2 = a1[1];
  BOOL v3 = a1[2];
  unint64_t v4 = v3 - v2;
  if (v3 == v2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = ((v3 - v2) << 6) - 1;
  }
  uint64_t v6 = (char *)a1[4];
  if (v5 - (unint64_t)&v6[(void)a1[5]] < 0x200)
  {
    uint64_t v7 = (uint64_t)(a1 + 3);
    uint64_t v8 = a1[3];
    uint64_t v9 = *a1;
    uint64_t v10 = v8 - (unsigned char *)*a1;
    if (v4 >= v10)
    {
      if (v8 == v9) {
        unint64_t v11 = 1;
      }
      else {
        unint64_t v11 = v10 >> 2;
      }
      unint64_t v46 = a1 + 3;
      __p = std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v7, v11);
      uint64_t v43 = (char *)__p;
      PCSharedCount v44 = (char *)__p;
      uint64_t v45 = (char *)__p + 8 * v12;
      long long v41 = operator new(0x1000uLL);
      std::__split_buffer<unsigned long *>::push_back(&__p, &v41);
      uint64_t v13 = (char *)a1[1];
      BOOL v14 = v44;
      if (v13 == a1[2])
      {
        unint64_t v33 = (char *)a1[1];
      }
      else
      {
        do
        {
          if (v14 == v45)
          {
            int64_t v15 = v43 - (unsigned char *)__p;
            if (v43 <= __p)
            {
              if (v14 == __p) {
                unint64_t v23 = 1;
              }
              else {
                unint64_t v23 = (v14 - (unsigned char *)__p) >> 2;
              }
              uint64_t v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)v46, v23);
              uint64_t v26 = v43;
              BOOL v14 = &v24[8 * (v23 >> 2)];
              uint64_t v27 = v44 - v43;
              if (v44 != v43)
              {
                BOOL v14 = &v24[8 * (v23 >> 2) + (v27 & 0xFFFFFFFFFFFFFFF8)];
                uint64_t v28 = 8 * (v27 >> 3);
                int v29 = &v24[8 * (v23 >> 2)];
                do
                {
                  uint64_t v30 = *(void *)v26;
                  v26 += 8;
                  *(void *)int v29 = v30;
                  v29 += 8;
                  v28 -= 8;
                }
                while (v28);
              }
              long long v31 = __p;
              __p = v24;
              uint64_t v43 = &v24[8 * (v23 >> 2)];
              PCSharedCount v44 = v14;
              uint64_t v45 = &v24[8 * v25];
              if (v31)
              {
                operator delete(v31);
                BOOL v14 = v44;
              }
            }
            else
            {
              uint64_t v16 = v15 >> 3;
              BOOL v17 = v15 >> 3 < -1;
              uint64_t v18 = (v15 >> 3) + 2;
              if (v17) {
                uint64_t v19 = v18;
              }
              else {
                uint64_t v19 = v16 + 1;
              }
              int64_t v20 = &v43[-8 * (v19 >> 1)];
              int64_t v21 = v14 - v43;
              if (v14 != v43)
              {
                memmove(&v43[-8 * (v19 >> 1)], v43, v14 - v43);
                BOOL v14 = v43;
              }
              unint64_t v22 = &v14[-8 * (v19 >> 1)];
              BOOL v14 = &v20[v21];
              uint64_t v43 = v22;
              PCSharedCount v44 = &v20[v21];
            }
          }
          uint64_t v32 = *(void *)v13;
          v13 += 8;
          *(void *)BOOL v14 = v32;
          BOOL v14 = v44 + 8;
          v44 += 8;
        }
        while (v13 != a1[2]);
        unint64_t v33 = (char *)a1[1];
      }
      uint64_t v36 = *a1;
      uint64_t v37 = v43;
      *a1 = __p;
      a1[1] = v37;
      __p = v36;
      uint64_t v43 = v33;
      int v38 = (char *)a1[3];
      uint64_t v39 = v45;
      a1[2] = v14;
      a1[3] = v39;
      PCSharedCount v44 = v13;
      uint64_t v45 = v38;
      if (v14 - v37 == 8) {
        uint64_t v40 = 256;
      }
      else {
        uint64_t v40 = (uint64_t)a1[4] + 512;
      }
      a1[4] = (void *)v40;
      if (v13 != v33) {
        PCSharedCount v44 = &v13[(v33 - v13 + 7) & 0xFFFFFFFFFFFFFFF8];
      }
      if (v36) {
        operator delete(v36);
      }
    }
    else
    {
      if (v2 == v9)
      {
        __p = operator new(0x1000uLL);
        std::__split_buffer<unsigned long *>::push_back(a1, &__p);
        uint64_t v34 = a1[2];
        __p = (void *)*(v34 - 1);
        a1[2] = v34 - 1;
      }
      else
      {
        __p = operator new(0x1000uLL);
      }
      std::__split_buffer<unsigned long *>::push_front((uint64_t)a1, &__p);
      if ((unsigned char *)a1[2] - (unsigned char *)a1[1] == 8) {
        uint64_t v35 = 256;
      }
      else {
        uint64_t v35 = (uint64_t)a1[4] + 512;
      }
      a1[4] = (void *)v35;
    }
  }
  else
  {
    a1[4] = v6 + 512;
    __p = (void *)*((void *)v3 - 1);
    a1[2] = v3 - 8;
    std::__split_buffer<unsigned long *>::push_front((uint64_t)a1, &__p);
  }
}

void sub_1B7AAFC8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  operator delete(v12);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void LiShard::build(uint64_t a1, void **a2, float64x2_t *a3, float64x2_t *a4, void *a5, uint64_t a6, uint64_t a7, double *a8, double a9, double a10, double a11, uint64_t a12)
{
  uint64_t v58 = a12;
  uint64_t v20 = a5[1] - *a5;
  unint64_t v60 = (unint64_t)v20 >> 2;
  int64_t v21 = (uint64_t *)(a1 + 16);
  unint64_t v55 = v20;
  unint64_t v22 = (int)(v20 >> 2);
  std::vector<PCVector3<double>>::resize((uint64_t *)(a1 + 16), v22);
  std::vector<unsigned int>::resize((std::vector<int> *)(a1 + 40), v22);
  unint64_t v23 = (uint64_t *)(a1 + 64);
  std::vector<unsigned int>::resize((std::vector<int> *)(a1 + 64), v22);
  uint64_t v24 = (uint64_t *)(a1 + 88);
  std::vector<TXParagraphStyle *>::resize(a1 + 88, v22);
  unint64_t v25 = *(void *)(a1 + 96) - *(void *)(a1 + 88);
  if ((int)(v25 >> 3) >= 1)
  {
    uint64_t v26 = 0;
    uint64_t v27 = v25 & 0x7FFFFFFF8;
    do
    {
      *(void *)(*v24 + v26) = 0;
      v26 += 8;
    }
    while (v27 != v26);
  }
  if ((int)v60 < 1)
  {
    uint64_t v34 = -1;
  }
  else
  {
    uint64_t v28 = 0;
    do
    {
      uint64_t v29 = v28;
      int v30 = *(_DWORD *)(*a5 + 4 * v28);
      if (v30 == -1)
      {
        uint64_t v31 = a6;
      }
      else if (v30 == -2)
      {
        int v30 = -1;
        uint64_t v31 = a7;
      }
      else
      {
        uint64_t v31 = **a2 + 32 * v30;
      }
      uint64_t v32 = *v21 + 24 * v29;
      long long v33 = *(_OWORD *)v31;
      *(void *)(v32 + 16) = *(void *)(v31 + 16);
      *(_OWORD *)uint64_t v32 = v33;
      *(_DWORD *)(*(void *)(a1 + 40) + 4 * v29) = v30;
      *(_DWORD *)(*v23 + 4 * v29) = 0;
      uint64_t v28 = v29 + 1;
    }
    while (v29 + 1 != (v55 >> 2));
    uint64_t v34 = (int)v29;
  }
  int v35 = *(_DWORD *)(*a5 + 4 * v34);
  if (v35 == -2)
  {
    double v64 = a10;
    double v36 = a10;
  }
  else if (v35 == -1)
  {
    double v64 = a9;
    double v36 = a9;
  }
  else
  {
    uint64_t v37 = (double *)(**a2 + 32 * v35);
    double v38 = ((*v37 - a3->f64[0]) * a4->f64[0] + (v37[1] - a3->f64[1]) * a4->f64[1] + (v37[2] - a3[1].f64[0])
                                                                                 * a4[1].f64[0])
        / (a4->f64[0] * a4->f64[0] + a4->f64[1] * a4->f64[1] + a4[1].f64[0] * a4[1].f64[0]);
    if (vabdd_f64(v38, a9) >= vabdd_f64(v38, a10)) {
      double v36 = a10;
    }
    else {
      double v36 = a9;
    }
    double v64 = v36;
  }
  if (v36 != a9) {
    a10 = a9;
  }
  double v63 = a10;
  double v40 = *a8;
  double v39 = a8[1];
  if (v39 < *a8)
  {
    *(_DWORD *)(*v23 + 4 * v34) = 2;
    *(void *)(*v24 + 8 * v34) = v58;
    return;
  }
  if (v36 >= v40 - a11 && v36 <= v40 + a11)
  {
    uint64_t v45 = *v23;
    uint64_t v46 = *v24;
LABEL_37:
    *(_DWORD *)(v45 + 4 * v34) = 1;
    *(void *)(v46 + 8 * v34) = v58;
    goto LABEL_38;
  }
  uint64_t v45 = *v23;
  uint64_t v46 = *v24;
  if (v36 >= v39 - a11 && v36 <= v39 + a11) {
    goto LABEL_37;
  }
  *(_DWORD *)(v45 + 4 * v34) = 2;
  *(void *)(v46 + 8 * v34) = v58;
  double v43 = LiInterval<double>::closest(a8, &v64);
  double v44 = v43 * a4[1].f64[0] + a3[1].f64[0];
  float64x2_t v61 = vaddq_f64(vmulq_n_f64(*a4, v43), *a3);
  double v62 = v44;
  LiChannelT<PCVector3<double>>::append(v21, (uint64_t)&v61);
  LODWORD(v61.f64[0]) = -1;
  LiChannelT<int>::append(a1 + 40, &v61);
  LODWORD(v61.f64[0]) = 1;
  LiChannelT<int>::append(a1 + 64, &v61);
  LiChannelT<LiDrawer *>::append((void **)(a1 + 88), &a12);
  double v40 = *a8;
  double v39 = a8[1];
LABEL_38:
  if (v39 < v40
    || ((double v47 = v40 - a11, v48 = v40 + a11, a10 >= v47) ? (v49 = a10 > v48) : (v49 = 1),
        v49 && ((double v50 = v39 - a11, v51 = v39 + a11, a10 >= v50) ? (v52 = a10 > v51) : (v52 = 1), v52)))
  {
    double v53 = LiInterval<double>::closest(a8, &v63);
    double v54 = v53 * a4[1].f64[0] + a3[1].f64[0];
    float64x2_t v61 = vaddq_f64(vmulq_n_f64(*a4, v53), *a3);
    double v62 = v54;
    LiChannelT<PCVector3<double>>::append(v21, (uint64_t)&v61);
    LODWORD(v61.f64[0]) = -1;
    LiChannelT<int>::append(a1 + 40, &v61);
    LODWORD(v61.f64[0]) = 2;
    LiChannelT<int>::append(a1 + 64, &v61);
    LiChannelT<LiDrawer *>::append((void **)(a1 + 88), &a12);
  }
}

double LiInterval<double>::closest(double *a1, double *a2)
{
  double result = *a1;
  double v3 = a1[1];
  if (v3 < *a1)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v5, "empty interval");
    PCException::PCException(exception, &v5);
  }
  if (*a2 <= v3) {
    double v3 = *a2;
  }
  if (*a2 >= result) {
    return v3;
  }
  return result;
}

void sub_1B7AB0168(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void *LiChannelT<LiDrawer *>::append(void **a1, void *a2)
{
  unint64_t v6 = (unint64_t)a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(void **)(v4 - 8);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v9 = ((char *)v7 - (unsigned char *)*a1) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v5 - (void)*a1;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    if (v12) {
      uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v4, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    BOOL v14 = &v13[8 * v9];
    int64_t v15 = &v13[8 * v12];
    *(void *)BOOL v14 = *a2;
    uint64_t v8 = v14 + 8;
    BOOL v17 = (char *)*a1;
    uint64_t v16 = (char *)a1[1];
    if (v16 != *a1)
    {
      do
      {
        uint64_t v18 = *((void *)v16 - 1);
        v16 -= 8;
        *((void *)v14 - 1) = v18;
        v14 -= 8;
      }
      while (v16 != v17);
      uint64_t v16 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v8;
    a1[2] = v15;
    if (v16) {
      operator delete(v16);
    }
  }
  else
  {
    *uint64_t v7 = *a2;
    uint64_t v8 = v7 + 1;
  }
  a1[1] = v8;
  return v8 - 1;
}

void LiPlaneSplit::LiPlaneSplit(LiPlaneSplit *this)
{
  *((_DWORD *)this + 7) = 0;
  *((unsigned char *)this + 32) = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + LiDepthSorter::stackSort((uint64_t)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = 0;
  *((unsigned char *)this + 24) = 0;
  *((void *)this + 11) = 0x3FF0000000000000;
  *((void *)this + 42) = 0;
  *((void *)this + 43) = 0;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((void *)this + 40) = 0;
  *((void *)this + 41) = &unk_1F111A080;
  *((void *)this + 45) = 0;
  *((void *)this + 46) = 0;
  *((void *)this + 44) = &unk_1F111A080;
  *((void *)this + 48) = 0;
  *((void *)this + 49) = 0;
  *((void *)this + 47) = &unk_1F111A080;
}

void LiPlaneSplit::compute(LiPlaneSplit *this)
{
  uint64_t v2 = *((void *)this + 1);
  if (!v2)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString((PCString *)v60, "_pivot");
    PCException::PCException(exception, (const PCString *)v60);
    *(void *)exception = &unk_1F1199218;
  }
  if (!*((void *)this + 2))
  {
    uint64_t v42 = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString((PCString *)v60, "_target");
    PCException::PCException(v42, (const PCString *)v60);
    *(void *)uint64_t v42 = &unk_1F1199218;
  }
  if (((*(uint64_t (**)(uint64_t))(*(void *)v2 + 40))(v2) & 1) == 0)
  {
    double v43 = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString((PCString *)v60, "no pivot plane");
    PCException::PCException(v43, (const PCString *)v60);
    *(void *)double v43 = &unk_1F1199218;
  }
  double v77 = 0.0;
  double v78 = 0.0;
  double v73 = 0.0;
  double v74 = 0.0;
  double v75 = 0.0;
  double v76 = 0.0;
  double v71 = 0;
  uint64_t v72 = 0;
  uint64_t v67 = 0;
  unint64_t v68 = 0;
  uint64_t v69 = 0;
  float64x2_t v70 = 0;
  uint64_t v3 = (*(uint64_t (**)(void))(**((void **)this + 1) + 32))(*((void *)this + 1));
  uint64_t v4 = (*(uint64_t (**)(void))(**((void **)this + 2) + 32))(*((void *)this + 2));
  (*(void (**)(float64x2_t *__return_ptr))(**((void **)this + 1) + 48))(&v64);
  (*(void (**)(float64x2_t *__return_ptr))(**((void **)this + 2) + 48))(&v61);
  memset(v60, 0, sizeof(v60));
  memset(v59, 0, sizeof(v59));
  double v5 = vaddvq_f64(vmulq_f64(v64, v64)) + v65 * v65;
  if (v5 <= -1.0e-24 || v5 >= 1.0e-24)
  {
    *(float64x2_t *)((char *)&v60[1] + 8) = v64;
    *((double *)&v60[2] + 1) = v65;
    v60[0] = vdivq_f64(vmulq_n_f64(v64, -v66), (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v5, 0));
    *(double *)&v60[1] = -(v66 * v65) / v5;
  }
  double v6 = vaddvq_f64(vmulq_f64(v61, v61)) + v62 * v62;
  if (v6 <= -1.0e-24 || v6 >= 1.0e-24)
  {
    *(float64x2_t *)((char *)&v59[1] + 8) = v61;
    *((double *)&v59[2] + 1) = v62;
    v59[0] = vdivq_f64(vmulq_n_f64(v61, -v63), (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v6, 0));
    *(double *)&v59[1] = -(v63 * v62) / v6;
  }
  *((unsigned char *)this + 32) = 0;
  if (PCPlane<double>::operator==((double *)v59, (double *)v60)) {
    goto LABEL_11;
  }
  uint64_t v7 = (uint64_t **)(v4 + 88);
  *((unsigned char *)this + 32) = liPolygonPlaneSplit(v7, &v64, &v76, &v73, &v70, &v67, 0, (char *)this + 28, 0.1);
  int v8 = *((_DWORD *)this + 7);
  if (*((unsigned char *)this + 25))
  {
    int v9 = v8 + 1;
    if (v8 + 1) <= 6 && ((0x65u >> v9)) {
      int v8 = dword_1B837C2B8[v9];
    }
    *((_DWORD *)this + 7) = v8;
  }
  if (v8 == 3)
  {
    if (!planeIntersection<double>((double *)v59, (double *)&v59[1] + 1, (double *)v60, (double *)&v60[1] + 1, (double *)this + 5, (double *)this + 8))
    {
      *((unsigned char *)this + 32) = 0;
LABEL_11:
      *((_DWORD *)this + 7) = 2;
      goto LABEL_60;
    }
    double v57 = 0.0;
    double v58 = 0.0;
    uint64_t v11 = *(void **)(v3 + 88);
    uint64_t v10 = v3 + 88;
    if ((int)((v11[1] - *v11) >> 5) < 1)
    {
      *((unsigned char *)this + 32) = liClipLineToPolygon((double *)this + 5, v7, &v58, &v57) - 1 < 3;
      if (v58 <= v57) {
        double v22 = v58;
      }
      else {
        double v22 = v57;
      }
      if (v58 >= v57) {
        double v23 = v58;
      }
      else {
        double v23 = v57;
      }
    }
    else
    {
      double v54 = 0.0;
      double v55 = 0.0;
      double v56 = 0.0;
      double v51 = 0.0;
      double v52 = 0.0;
      double v53 = 0.0;
      double v48 = 0;
      BOOL v49 = 0;
      uint64_t v50 = 0;
      __p = 0;
      uint64_t v46 = 0;
      uint64_t v47 = 0;
      int v44 = 0;
      int v12 = liPolygonPlaneSplit(v10, &v61, &v54, &v51, &v48, &__p, 0, &v44, 0.1);
      *((unsigned char *)this + 32) = v12;
      if (v12)
      {
        double v13 = *((double *)this + 5);
        double v14 = *((double *)this + 6);
        double v15 = *((double *)this + 7);
        double v16 = *((double *)this + 8);
        double v17 = *((double *)this + 9);
        double v18 = *((double *)this + 10);
        double v19 = v16 * v16 + v17 * v17 + v18 * v18;
        double v20 = ((v54 - v13) * v16 + (v55 - v14) * v17 + (v56 - v15) * v18) / v19;
        double v21 = (v16 * (v51 - v13) + v17 * (v52 - v14) + v18 * (v53 - v15)) / v19;
        double v57 = v21;
        double v58 = v20;
        if (v20 <= v21) {
          double v22 = v20;
        }
        else {
          double v22 = v21;
        }
        if (v20 >= v21) {
          double v23 = v20;
        }
        else {
          double v23 = v21;
        }
      }
      else
      {
        double v23 = 0.0;
        double v22 = 1.0;
      }
      if (__p)
      {
        uint64_t v46 = __p;
        operator delete(__p);
      }
      if (v48)
      {
        BOOL v49 = v48;
        operator delete(v48);
      }
    }
    double v24 = *((double *)this + 5);
    double v25 = *((double *)this + 6);
    double v26 = *((double *)this + 7);
    double v27 = *((double *)this + 8);
    double v28 = *((double *)this + 9);
    double v29 = *((double *)this + 10);
    double v30 = v27 * v27 + v28 * v28 + v29 * v29;
    double v31 = ((v76 - v24) * v27 + (v77 - v25) * v28 + (v78 - v26) * v29) / v30;
    double v32 = (v27 * (v73 - v24) + v28 * (v74 - v25) + v29 * (v75 - v26)) / v30;
    double v57 = v32;
    double v58 = v31;
    if (v31 <= v32) {
      double v33 = v31;
    }
    else {
      double v33 = v32;
    }
    if (v31 >= v32) {
      double v32 = v31;
    }
    if (v23 >= v22)
    {
      if (v32 >= v33)
      {
        if (v22 < v33) {
          double v22 = v33;
        }
        if (v23 > v32) {
          double v23 = v32;
        }
      }
      else
      {
        double v23 = v32;
        double v22 = v33;
      }
    }
    *((double *)this + 11) = v22;
    *((double *)this + 12) = v23;
    double v34 = v23 - v22;
    if (v23 < v22) {
      double v34 = -1.0;
    }
    if (v34 < 0.100000001)
    {
      *((unsigned char *)this + 32) = 0;
      *(_OWORD *)((char *)this + 88) = xmmword_1B7E733D0;
    }
    uint64_t v35 = 0;
    char v36 = 1;
    do
    {
      char v37 = v36;
      if (v36) {
        double v38 = &v67;
      }
      else {
        double v38 = &v70;
      }
      double v39 = (char *)this + 112 * v35;
      uint64_t v40 = *((void *)this + 1);
      *((void *)v39 + 13) = *((void *)this + 2);
      *((void *)v39 + 14) = 0;
      LiShard::build((uint64_t)(v39 + 104), v7, (float64x2_t *)((char *)this + 40), (float64x2_t *)this + 4, v38, (uint64_t)&v76, (uint64_t)&v73, (double *)this + 11, v58, v57, 0.100000001, v40);
      char v36 = 0;
      uint64_t v35 = 1;
    }
    while ((v37 & 1) != 0);
  }
LABEL_60:
  if (v67)
  {
    unint64_t v68 = v67;
    operator delete(v67);
  }
  if (v70)
  {
    double v71 = v70;
    operator delete(v70);
  }
}

void sub_1B7AB0A28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,PCString a31)
{
  double v33 = (void *)v31[20];
  if (v33)
  {
    v31[21] = v33;
    operator delete(v33);
  }
  double v34 = (void *)v31[23];
  if (v34)
  {
    v31[24] = v34;
    operator delete(v34);
  }
  _Unwind_Resume(exception_object);
}

BOOL PCPlane<double>::operator==(double *a1, double *a2)
{
  double v2 = a1[3];
  if (v2 == a2[3]
    && (double v3 = a1[4], v3 == a2[4])
    && (double v4 = a1[5], v4 == a2[5])
    && ((v6 = a1[1], double v7 = a2[1], *a1 == *a2) ? (v8 = v6 == v7) : (v8 = 0), !v8 || a1[2] != a2[2]))
  {
    return v2 * *a1 + v3 * v6 + v4 * a1[2] == v2 * *a2 + v3 * v7 + v4 * a2[2];
  }
  else
  {
    return 0;
  }
}

uint64_t LiPlaneSplit::store(LiPlaneSplit *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  uint64_t v8 = *(void *)this;
  uint64_t v34 = *((void *)this + 1);
  uint64_t v35 = &unk_1F111E648;
  uint64_t v38 = v8;
  switch(*((_DWORD *)this + 7))
  {
    case 0xFFFFFFFF:
      uint64_t v10 = (char *)this + 328;
      int v11 = *((_DWORD *)this + 85);
      if (*((_DWORD *)this + 84) <= v11) {
        int v12 = (2 * (v11 + 1)) | 1;
      }
      else {
        int v12 = *((_DWORD *)this + 84);
      }
      PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::resize((uint64_t)v10, v11 + 1, v12);
      double v13 = (char *)this + 340;
      uint64_t v14 = *((void *)this + 2);
      double v15 = (char *)this + 344;
      goto LABEL_28;
    case 1:
      double v16 = (char *)this + 352;
      int v17 = *((_DWORD *)this + 91);
      if (*((_DWORD *)this + 90) <= v17) {
        int v18 = (2 * (v17 + 1)) | 1;
      }
      else {
        int v18 = *((_DWORD *)this + 90);
      }
      PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::resize((uint64_t)v16, v17 + 1, v18);
      double v13 = (char *)this + 364;
      uint64_t v14 = *((void *)this + 2);
      goto LABEL_27;
    case 2:
      double v19 = (char *)this + 376;
      int v20 = *((_DWORD *)this + 97);
      if (*((_DWORD *)this + 96) <= v20) {
        int v21 = (2 * (v20 + 1)) | 1;
      }
      else {
        int v21 = *((_DWORD *)this + 96);
      }
      PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::resize((uint64_t)v19, v20 + 1, v21);
      double v13 = (char *)this + 388;
      uint64_t v14 = *((void *)this + 2);
      double v15 = (char *)this + 392;
      goto LABEL_28;
    case 3:
      HIDWORD(v36) = 0;
      PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::resize((uint64_t)&v35, 1, 3);
      int v22 = HIDWORD(v36);
      *(void *)(v37 + 8 * (HIDWORD(v36) - 1)) = (char *)this + 104;
      if ((int)v36 <= v22) {
        int v23 = (2 * (v22 + 1)) | 1;
      }
      else {
        int v23 = v36;
      }
      PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::resize((uint64_t)&v35, v22 + 1, v23);
      *(void *)(v37 + 8 * SHIDWORD(v36) - 8) = (char *)this + 216;
      (*(void (**)(void, uint64_t *))(**((void **)this + 2) + 80))(*((void *)this + 2), &v34);
      int v24 = *((unsigned __int8 *)this + 25);
      uint64_t v25 = *((void *)this + 14 * *((unsigned __int8 *)this + 25) + 14);
      if (v25)
      {
        int v26 = *((_DWORD *)this + 85);
        if (*((_DWORD *)this + 84) <= v26) {
          int v27 = (2 * (v26 + 1)) | 1;
        }
        else {
          int v27 = *((_DWORD *)this + 84);
        }
        PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::resize((uint64_t)this + 328, v26 + 1, v27);
        *(void *)(*((void *)this + 43) + 8 * *((int *)this + 85) - 8) = v25;
        int v24 = *((unsigned __int8 *)this + 25);
      }
      uint64_t v14 = *((void *)this + 14 * (v24 == 0) + 14);
      if (!v14) {
        goto LABEL_30;
      }
      int v28 = *((_DWORD *)this + 91);
      if (*((_DWORD *)this + 90) <= v28) {
        int v29 = (2 * (v28 + 1)) | 1;
      }
      else {
        int v29 = *((_DWORD *)this + 90);
      }
      PCArray<ProShade::ProgramVar *,PCArray_Traits<ProShade::ProgramVar *>>::resize((uint64_t)this + 352, v28 + 1, v29);
      double v13 = (char *)this + 364;
LABEL_27:
      double v15 = (char *)this + 368;
LABEL_28:
      *(void *)(*(void *)v15 + 8 * *(int *)v13 - 8) = v14;
LABEL_30:
      uint64_t v35 = &unk_1F111E698;
      if ((int)v36 < 0) {
        unsigned int v30 = 1;
      }
      else {
        unsigned int v30 = v36 & ~((int)v36 >> 31);
      }
      if (v30 == v36)
      {
        uint64_t v31 = SHIDWORD(v36);
        if (v36 < 0)
        {
          do
            *(void *)(v37 + 8 * v31) = 0;
          while (!__CFADD__(v31++, 1));
        }
      }
      else
      {
        if (v30) {
          operator new[]();
        }
        if (v37) {
          MEMORY[0x1BA9BFB70](v37, 0x1000C8077774924);
        }
        uint64_t v37 = 0;
      }
      uint64_t v36 = v30;
      uint64_t result = v37;
      if (v37) {
        return MEMORY[0x1BA9BFB70](v37, 0x1000C8077774924);
      }
      return result;
    default:
      PCPrint("File %s, line %d should not have been reached:\n\t", a2, a3, a4, a5, a6, a7, a8, (char)"/Library/Caches/com.apple.xbs/Sources/LithiumiOS/LiPlaneSplit.cpp");
      pcAbortImpl();
  }
}

void sub_1B7AB0EB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  LiIntersection::~LiIntersection((LiIntersection *)va);
  _Unwind_Resume(a1);
}

void LiIntersection::~LiIntersection(LiIntersection *this)
{
  *((void *)this + 1) = &unk_1F111E698;
  int v2 = *((_DWORD *)this + 4);
  if (v2 < 0) {
    int v3 = 1;
  }
  else {
    int v3 = v2 & ~(v2 >> 31);
  }
  if (v3 == v2)
  {
    uint64_t v4 = *((int *)this + 5);
    if ((v4 & 0x80000000) != 0)
    {
      do
        *(void *)(*((void *)this + 3) + 8 * v4) = 0;
      while (!__CFADD__(v4++, 1));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    uint64_t v6 = *((void *)this + 3);
    if (v6) {
      MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
    }
    *((void *)this + 3) = 0;
  }
  *((_DWORD *)this + 4) = v3;
  *((_DWORD *)this + 5) = 0;
  uint64_t v7 = *((void *)this + 3);
  if (v7) {
    MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
  }
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
}

uint64_t LiPlaneSplit::clear(uint64_t this)
{
  uint64_t v1 = this;
  int v2 = *(_DWORD *)(this + 336);
  if (v2 < 0) {
    int v3 = 1;
  }
  else {
    int v3 = v2 & ~(v2 >> 31);
  }
  if (v3 == v2)
  {
    uint64_t v4 = *(int *)(this + 340);
    if ((v4 & 0x80000000) != 0)
    {
      do
      {
        *(void *)(*(void *)(this + 344) + 8 * v4) = 0;
        BOOL v5 = __CFADD__(v4++, 1);
      }
      while (!v5);
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    this = *(void *)(this + 344);
    if (this) {
      this = MEMORY[0x1BA9BFB70](this, 0x1000C8077774924);
    }
    *(void *)(v1 + 344) = 0;
  }
  *(_DWORD *)(v1 + 336) = v3;
  *(_DWORD *)(v1 + 340) = 0;
  int v6 = *(_DWORD *)(v1 + 384);
  if (v6 < 0) {
    int v7 = 1;
  }
  else {
    int v7 = v6 & ~(v6 >> 31);
  }
  if (v7 == v6)
  {
    uint64_t v8 = *(int *)(v1 + 388);
    if ((v8 & 0x80000000) != 0)
    {
      do
      {
        *(void *)(*(void *)(v1 + 392) + 8 * v8) = 0;
        BOOL v5 = __CFADD__(v8++, 1);
      }
      while (!v5);
    }
  }
  else
  {
    if (v7) {
      operator new[]();
    }
    this = *(void *)(v1 + 392);
    if (this) {
      this = MEMORY[0x1BA9BFB70](this, 0x1000C8077774924);
    }
    *(void *)(v1 + 392) = 0;
  }
  *(_DWORD *)(v1 + 384) = v7;
  *(_DWORD *)(v1 + 388) = 0;
  int v9 = *(_DWORD *)(v1 + 360);
  if (v9 < 0) {
    int v10 = 1;
  }
  else {
    int v10 = v9 & ~(v9 >> 31);
  }
  if (v10 == v9)
  {
    uint64_t v11 = *(int *)(v1 + 364);
    if ((v11 & 0x80000000) != 0)
    {
      do
      {
        *(void *)(*(void *)(v1 + 368) + 8 * v11) = 0;
        BOOL v5 = __CFADD__(v11++, 1);
      }
      while (!v5);
    }
  }
  else
  {
    if (v10) {
      operator new[]();
    }
    this = *(void *)(v1 + 368);
    if (this) {
      this = MEMORY[0x1BA9BFB70](this, 0x1000C8077774924);
    }
    *(void *)(v1 + 368) = 0;
  }
  *(_DWORD *)(v1 + 360) = v10;
  *(_DWORD *)(v1 + 364) = 0;
  return this;
}

uint64_t PCPtrArray<LiShard>::~PCPtrArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111E698;
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2 < 0) {
    int v3 = 1;
  }
  else {
    int v3 = v2 & ~(v2 >> 31);
  }
  if (v3 == v2)
  {
    uint64_t v4 = *(int *)(a1 + 12);
    if ((v4 & 0x80000000) != 0)
    {
      do
        *(void *)(*(void *)(a1 + 16) + 8 * v4) = 0;
      while (!__CFADD__(v4++, 1));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6) {
      MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = 0;
  uint64_t v7 = *(void *)(a1 + 16);
  if (v7) {
    MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

void PCPtrArray<LiShard>::~PCPtrArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111E698;
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2 < 0) {
    int v3 = 1;
  }
  else {
    int v3 = v2 & ~(v2 >> 31);
  }
  if (v3 == v2)
  {
    uint64_t v4 = *(int *)(a1 + 12);
    if ((v4 & 0x80000000) != 0)
    {
      do
        *(void *)(*(void *)(a1 + 16) + 8 * v4) = 0;
      while (!__CFADD__(v4++, 1));
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6) {
      MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = 0;
  uint64_t v7 = *(void *)(a1 + 16);
  if (v7) {
    MEMORY[0x1BA9BFB70](v7, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t LiGrid::setGeom(uint64_t this, int a2, int a3)
{
  *(_DWORD *)(this + 64) = a2;
  *(_DWORD *)(this + 68) = a3;
  return this;
}

void LiGrid::LiGrid(LiGrid *this)
{
  *((void *)this + 11) = &unk_1F1199AC8;
  *((void *)this + 12) = 0;
  *((unsigned char *)this + 104) = 1;
  LiImageSource::LiImageSource((LiImageSource *)this, (uint64_t *)&off_1F111E7A8);
  *(void *)this = &unk_1F111E6C0;
  *((void *)this + 11) = &unk_1F111E788;
  PCWorkingColorVector::PCWorkingColorVector((LiGrid *)((char *)this + 16), 0.4, 0.4, 0.4, 0.5);
  PCWorkingColorVector::PCWorkingColorVector((LiGrid *)((char *)this + 32), 0.6, 0.6, 0.6, 0.5);
  *((_OWORD *)this + 3) = xmmword_1B7E74760;
  *((void *)this + 8) = 0x64000001F4;
  *((unsigned char *)this + 72) = 0;
  *((_DWORD *)this + 19) = 1;
}

void sub_1B7AB14E8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 88) = v3;
  *(unsigned char *)(v1 + 104) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

void LiGrid::~LiGrid(OZChannelBase *this)
{
  this->unint64_t var0 = (void **)&unk_1F111E6C0;
  this->var11 = (__CFString *)&unk_1F111E788;
  uint64_t v1 = OZChannelBase::setRangeName(this, (const PCString *)&off_1F111E7A8);
  *(void *)(v1 + 88) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 104) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 96));
}

{
  uint64_t vars8;

  LiGrid::~LiGrid(this);

  JUMPOUT(0x1BA9BFBA0);
}

void virtual thunk to'LiGrid::~LiGrid(LiGrid *this)
{
}

{
  uint64_t vars8;

  LiGrid::~LiGrid((OZChannelBase *)((char *)this + *(void *)(*(void *)this - 24)));

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t LiGrid::setPlane(uint64_t this, int a2)
{
  *(_DWORD *)(this + 76) = a2;
  return this;
}

uint64_t LiGrid::setGroundPlane(uint64_t this, char a2)
{
  *(unsigned char *)(this + 72) = a2;
  return this;
}

uint64_t LiGrid::filteredEdges(LiGrid *this)
{
  return 1;
}

void LiGrid::getHelium(LiGrid *this, LiAgent *a2)
{
  uint64_t v16 = 0x3FF0000000000000;
  uint64_t v13 = 0x3FF0000000000000;
  uint64_t v10 = 0x3FF0000000000000;
  uint64_t v7 = 0x3FF0000000000000;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  LiAgent::getInversePixelTransform(a2, 0.00001, (uint64_t)&v6);
  for (uint64_t i = 0; i != 128; i += 32)
  {
    uint64_t v3 = (_OWORD *)((char *)&v7 + i);
    long long v4 = *(_OWORD *)((char *)&v6 + i + 16);
    *uint64_t v3 = *(_OWORD *)((char *)&v6 + i);
    v3[1] = v4;
  }
  BOOL v5 = (LiHeGridShader *)HGObject::operator new(0x1A0uLL);
  *(_OWORD *)BOOL v5 = 0u;
  *((_OWORD *)v5 + 1) = 0u;
  *((_OWORD *)v5 + 2) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  *((_OWORD *)v5 + 4) = 0u;
  *((_OWORD *)v5 + 5) = 0u;
  *((_OWORD *)v5 + 6) = 0u;
  *((_OWORD *)v5 + 7) = 0u;
  *((_OWORD *)v5 + 8) = 0u;
  *((_OWORD *)v5 + 9) = 0u;
  *((_OWORD *)v5 + 10) = 0u;
  *((_OWORD *)v5 + 11) = 0u;
  *((_OWORD *)v5 + 12) = 0u;
  *((_OWORD *)v5 + 13) = 0u;
  *((_OWORD *)v5 + 14) = 0u;
  *((_OWORD *)v5 + 15) = 0u;
  *((_OWORD *)v5 + 16) = 0u;
  *((_OWORD *)v5 + 17) = 0u;
  *((_OWORD *)v5 + 18) = 0u;
  *((_OWORD *)v5 + 19) = 0u;
  *((_OWORD *)v5 + 20) = 0u;
  *((_OWORD *)v5 + 21) = 0u;
  *((_OWORD *)v5 + 22) = 0u;
  *((_OWORD *)v5 + 23) = 0u;
  *((_OWORD *)v5 + 24) = 0u;
  *((_OWORD *)v5 + 25) = 0u;
  LiHeGridShader::LiHeGridShader(v5);
}

void sub_1B7AB1A60(_Unwind_Exception *a1)
{
  HGObject::operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t LiHeGrid::setInversePixelTransform(uint64_t a1, double *a2)
{
  float v4 = *a2;
  float v5 = a2[1];
  float v6 = a2[3];
  unsigned int v7 = (*(uint64_t (**)(uint64_t, uint64_t, float, float, double, float))(*(void *)a1 + 96))(a1, 6, v4, v5, 0.0, v6);
  float v8 = a2[4];
  float v9 = a2[5];
  float v10 = a2[7];
  unsigned int v11 = (*(uint64_t (**)(uint64_t, uint64_t, float, float, double, float))(*(void *)a1 + 96))(a1, 7, v8, v9, 0.0, v10);
  if (v11) {
    unsigned int v7 = v11;
  }
  float v12 = a2[12];
  float v13 = a2[13];
  float v14 = a2[15];
  LODWORD(result) = (*(uint64_t (**)(uint64_t, uint64_t, float, float, double, float))(*(void *)a1 + 96))(a1, 8, v12, v13, 0.0, v14);
  if (result) {
    return result;
  }
  else {
    return v7;
  }
}

uint64_t LiGrid::estimateRenderMemory()
{
  return 0;
}

void LiHeGrid::~LiHeGrid(HGNode *this)
{
  LiHeGridShader::~LiHeGridShader(this);

  HGObject::operator delete(v1);
}

BOOL ProShade::isZero(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 16);
  if (v1
  {
    switch(v2->var3)
    {
      case 0u:
        ProShade::Error<PCIllegalArgumentException>::raise(v2, v3);
      case 1u:
        uint64_t v20 = 0;
        uint64_t v21 = 0;
        double v19 = &unk_1F111F3B0;
        float v4 = (PCArray_base *)(*((uint64_t (**)(OZChannelBase *, void **))v2->var0 + 25))(v2, &v19);
        if (SHIDWORD(v20) < 1)
        {
          BOOL v6 = 1;
        }
        else
        {
          uint64_t v5 = 0;
          BOOL v6 = 0;
          do
          {
            if (v5 >= SHIDWORD(v20)) {
              PCArray_base::badIndex(v4);
            }
            if (*(unsigned char *)(v21 + v5)) {
              break;
            }
            BOOL v6 = ++v5 >= (unint64_t)HIDWORD(v20);
          }
          while (HIDWORD(v20) != v5);
        }
        double v19 = &unk_1F111F3B0;
        if ((int)v20 < 0) {
          unsigned int v11 = 1;
        }
        else {
          unsigned int v11 = v20 & ~((int)v20 >> 31);
        }
        if (v11 == v20)
        {
          uint64_t v12 = v21;
          if (v20 < 0) {
            bzero((void *)(v21 + SHIDWORD(v20)), ~HIDWORD(v20) + 1);
          }
        }
        else
        {
          if (v11) {
            operator new[]();
          }
          uint64_t v12 = 0;
          if (v21) {
            MEMORY[0x1BA9BFB70](v21, 0x1000C8077774924);
          }
          uint64_t v21 = 0;
        }
        uint64_t v20 = v11;
        if (!v12) {
          return v6;
        }
        uint64_t v17 = v12;
        goto LABEL_64;
      case 2u:
        uint64_t v20 = 0;
        uint64_t v21 = 0;
        double v19 = &unk_1F10AD630;
        unsigned int v7 = (PCArray_base *)(*((uint64_t (**)(OZChannelBase *, void **))v2->var0 + 26))(v2, &v19);
        if (SHIDWORD(v20) < 1)
        {
          BOOL v6 = 1;
        }
        else
        {
          uint64_t v8 = 0;
          BOOL v6 = 0;
          do
          {
            if (v8 >= SHIDWORD(v20)) {
              PCArray_base::badIndex(v7);
            }
            if (*(_DWORD *)(v21 + 4 * v8)) {
              break;
            }
            BOOL v6 = ++v8 >= (unint64_t)HIDWORD(v20);
          }
          while (HIDWORD(v20) != v8);
        }
        double v19 = &unk_1F10AD630;
        if ((int)v20 < 0) {
          unsigned int v13 = 1;
        }
        else {
          unsigned int v13 = v20 & ~((int)v20 >> 31);
        }
        if (v13 != v20)
        {
          if (v13) {
            operator new[]();
          }
          goto LABEL_54;
        }
        uint64_t v14 = v21;
        if ((v20 & 0x8000000000000000) == 0) {
          goto LABEL_57;
        }
        long long v15 = (void *)(v21 + 4 * SHIDWORD(v20));
        size_t v16 = 4 * ~HIDWORD(v20) + 4;
        goto LABEL_51;
      case 3u:
        uint64_t v20 = 0;
        uint64_t v21 = 0;
        double v19 = &unk_1F111F378;
        float v9 = (PCArray_base *)(*((uint64_t (**)(OZChannelBase *, void **))v2->var0 + 27))(v2, &v19);
        if (SHIDWORD(v20) < 1)
        {
          BOOL v6 = 1;
        }
        else
        {
          uint64_t v10 = 0;
          BOOL v6 = 0;
          do
          {
            if (v10 >= SHIDWORD(v20)) {
              PCArray_base::badIndex(v9);
            }
            if (*(double *)(v21 + 8 * v10) != 0.0) {
              break;
            }
            BOOL v6 = ++v10 >= (unint64_t)HIDWORD(v20);
          }
          while (HIDWORD(v20) != v10);
        }
        double v19 = &unk_1F111F378;
        if ((int)v20 < 0) {
          unsigned int v13 = 1;
        }
        else {
          unsigned int v13 = v20 & ~((int)v20 >> 31);
        }
        if (v13 == v20)
        {
          uint64_t v14 = v21;
          if (v20 < 0)
          {
            long long v15 = (void *)(v21 + 8 * SHIDWORD(v20));
            size_t v16 = 8 * ~HIDWORD(v20) + 8;
LABEL_51:
            bzero(v15, v16);
          }
        }
        else
        {
          if (v13) {
            operator new[]();
          }
LABEL_54:
          uint64_t v14 = 0;
          if (v21) {
            MEMORY[0x1BA9BFB70](v21, 0x1000C8077774924);
          }
          uint64_t v21 = 0;
        }
LABEL_57:
        uint64_t v20 = v13;
        if (v14)
        {
          uint64_t v17 = v14;
LABEL_64:
          MEMORY[0x1BA9BFB70](v17, 0x1000C8077774924);
        }
        break;
      default:
        return 0;
    }
  }
  else
  {
    return 0;
  }
  return v6;
}

void sub_1B7AB2054(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCArray<double,PCArray_Traits<double>>::~PCArray((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t PCArray<BOOL,PCArray_Traits<BOOL>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111F3B0;
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2 < 0) {
    int v3 = 1;
  }
  else {
    int v3 = v2 & ~(v2 >> 31);
  }
  if (v3 == v2)
  {
    uint64_t v4 = *(int *)(a1 + 12);
    uint64_t v5 = *(void *)(a1 + 16);
    if ((v4 & 0x80000000) != 0) {
      bzero((void *)(v5 + v4), ~v4 + 1);
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    uint64_t v5 = 0;
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6) {
      MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = 0;
  if (v5) {
    MEMORY[0x1BA9BFB70](v5, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

uint64_t PCArray<double,PCArray_Traits<double>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111F378;
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2 < 0) {
    int v3 = 1;
  }
  else {
    int v3 = v2 & ~(v2 >> 31);
  }
  if (v3 == v2)
  {
    uint64_t v4 = *(int *)(a1 + 12);
    uint64_t v5 = *(void *)(a1 + 16);
    if ((v4 & 0x80000000) != 0) {
      bzero((void *)(v5 + 8 * v4), 8 * ~v4 + 8);
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    uint64_t v5 = 0;
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6) {
      MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = 0;
  if (v5) {
    MEMORY[0x1BA9BFB70](v5, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  return a1;
}

BOOL ProShade::isOne(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 16);
  if (v1
  {
    switch(v2->var3)
    {
      case 0u:
        ProShade::Error<PCIllegalArgumentException>::raise(v2, v3);
      case 1u:
        uint64_t v20 = 0;
        uint64_t v21 = 0;
        double v19 = &unk_1F111F3B0;
        uint64_t v4 = (PCArray_base *)(*((uint64_t (**)(OZChannelBase *, void **))v2->var0 + 25))(v2, &v19);
        if (SHIDWORD(v20) < 1)
        {
          BOOL v6 = 1;
        }
        else
        {
          uint64_t v5 = 0;
          BOOL v6 = 0;
          do
          {
            if (v5 >= SHIDWORD(v20)) {
              PCArray_base::badIndex(v4);
            }
            if (!*(unsigned char *)(v21 + v5)) {
              break;
            }
            BOOL v6 = ++v5 >= (unint64_t)HIDWORD(v20);
          }
          while (HIDWORD(v20) != v5);
        }
        double v19 = &unk_1F111F3B0;
        if ((int)v20 < 0) {
          unsigned int v11 = 1;
        }
        else {
          unsigned int v11 = v20 & ~((int)v20 >> 31);
        }
        if (v11 == v20)
        {
          uint64_t v12 = v21;
          if (v20 < 0) {
            bzero((void *)(v21 + SHIDWORD(v20)), ~HIDWORD(v20) + 1);
          }
        }
        else
        {
          if (v11) {
            operator new[]();
          }
          uint64_t v12 = 0;
          if (v21) {
            MEMORY[0x1BA9BFB70](v21, 0x1000C8077774924);
          }
          uint64_t v21 = 0;
        }
        uint64_t v20 = v11;
        if (!v12) {
          return v6;
        }
        uint64_t v17 = v12;
        goto LABEL_64;
      case 2u:
        uint64_t v20 = 0;
        uint64_t v21 = 0;
        double v19 = &unk_1F10AD630;
        unsigned int v7 = (PCArray_base *)(*((uint64_t (**)(OZChannelBase *, void **))v2->var0 + 26))(v2, &v19);
        if (SHIDWORD(v20) < 1)
        {
          BOOL v6 = 1;
        }
        else
        {
          uint64_t v8 = 0;
          BOOL v6 = 0;
          do
          {
            if (v8 >= SHIDWORD(v20)) {
              PCArray_base::badIndex(v7);
            }
            if (*(_DWORD *)(v21 + 4 * v8) != 1) {
              break;
            }
            BOOL v6 = ++v8 >= (unint64_t)HIDWORD(v20);
          }
          while (HIDWORD(v20) != v8);
        }
        double v19 = &unk_1F10AD630;
        if ((int)v20 < 0) {
          unsigned int v13 = 1;
        }
        else {
          unsigned int v13 = v20 & ~((int)v20 >> 31);
        }
        if (v13 != v20)
        {
          if (v13) {
            operator new[]();
          }
          goto LABEL_54;
        }
        uint64_t v14 = v21;
        if ((v20 & 0x8000000000000000) == 0) {
          goto LABEL_57;
        }
        long long v15 = (void *)(v21 + 4 * SHIDWORD(v20));
        size_t v16 = 4 * ~HIDWORD(v20) + 4;
        goto LABEL_51;
      case 3u:
        uint64_t v20 = 0;
        uint64_t v21 = 0;
        double v19 = &unk_1F111F378;
        float v9 = (PCArray_base *)(*((uint64_t (**)(OZChannelBase *, void **))v2->var0 + 27))(v2, &v19);
        if (SHIDWORD(v20) < 1)
        {
          BOOL v6 = 1;
        }
        else
        {
          uint64_t v10 = 0;
          BOOL v6 = 0;
          do
          {
            if (v10 >= SHIDWORD(v20)) {
              PCArray_base::badIndex(v9);
            }
            if (*(double *)(v21 + 8 * v10) != 1.0) {
              break;
            }
            BOOL v6 = ++v10 >= (unint64_t)HIDWORD(v20);
          }
          while (HIDWORD(v20) != v10);
        }
        double v19 = &unk_1F111F378;
        if ((int)v20 < 0) {
          unsigned int v13 = 1;
        }
        else {
          unsigned int v13 = v20 & ~((int)v20 >> 31);
        }
        if (v13 == v20)
        {
          uint64_t v14 = v21;
          if (v20 < 0)
          {
            long long v15 = (void *)(v21 + 8 * SHIDWORD(v20));
            size_t v16 = 8 * ~HIDWORD(v20) + 8;
LABEL_51:
            bzero(v15, v16);
          }
        }
        else
        {
          if (v13) {
            operator new[]();
          }
LABEL_54:
          uint64_t v14 = 0;
          if (v21) {
            MEMORY[0x1BA9BFB70](v21, 0x1000C8077774924);
          }
          uint64_t v21 = 0;
        }
LABEL_57:
        uint64_t v20 = v13;
        if (v14)
        {
          uint64_t v17 = v14;
LABEL_64:
          MEMORY[0x1BA9BFB70](v17, 0x1000C8077774924);
        }
        break;
      default:
        return 0;
    }
  }
  else
  {
    return 0;
  }
  return v6;
}

void sub_1B7AB26FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  PCArray<double,PCArray_Traits<double>>::~PCArray((uint64_t)va);
  _Unwind_Resume(a1);
}

void ProShade::UnaryOp<ProShade::Negate>::unary(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 16);
  if (v1)
  {
    if (v2) {
      ProShade::UnaryOp<ProShade::Negate>::computeUnary(v2);
    }
  }
  operator new();
}

void sub_1B7AB2878(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1 + 3);
  _Unwind_Resume(a1);
}

void ProShade::BinaryOp<ProShade::Add>::binary(const PCSharedCount *a1@<X0>, const PCSharedCount *a2@<X1>, uint64_t a3@<X8>)
{
  __n128 v22[15] = *(PCSharedCount *)MEMORY[0x1E4F143B8];
  unint64_t var0 = a1[2].var0;
  if (var0) {
  else
  }
    unsigned int v7 = 0;
  uint64_t v8 = a2[2].var0;
  if (v8)
  {
    if (v7)
    {
      uint64_t v10 = v9;
      if (v9)
      {
        ProShade::Value::Value(&v19);
        ProShade::Value::Value(v17);
        ProShade::Value::Value(v15);
        (*(void (**)(void *, PCString *))(*(void *)v7 + 224))(v7, &v19);
        (*(void (**)(void *, PCString *))(*(void *)v10 + 224))(v10, v17);
        ProShade::BinaryOp<ProShade::Add>::computeBinary(&v19, v17, (uint64_t)v15);
        ProShade::Const::create((ProShade::Const *)v15, v11);
      }
    }
  }
  v19.unint64_t var0 = (__CFString *)&unk_1F11193B8;
  uint64_t v21 = 0;
  PCSharedCount::PCSharedCount(v22);
  uint64_t v12 = (__CFString *)a1[2].var0;
  v17[0].unint64_t var0 = (__CFString *)&unk_1F11193B8;
  v17[2].unint64_t var0 = v12;
  PCSharedCount::PCSharedCount(v18, a1 + 3);
  unsigned int v13 = a2[2].var0;
  v15[0] = &unk_1F11193B8;
  _OWORD v15[2] = v13;
  PCSharedCount::PCSharedCount(v16, a2 + 3);
  BOOL v14 = ProShade::Add::simplify((uint64_t)v17, (uint64_t)v15, (uint64_t)&v19);
  v15[0] = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v16);
  v17[0].unint64_t var0 = (__CFString *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v18);
  if (!v14) {
    operator new();
  }
  *(void *)a3 = &unk_1F11193B8;
  *(unsigned char *)(a3 + 8) = v20;
  *(void *)(a3 + 16) = v21;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a3 + 24), v22);
  v19.unint64_t var0 = (__CFString *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v22);
}

void sub_1B7AB2BE0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v3, 0x10B1C403815D87CLL);
  *(void *)(v4 - 240) = v1;
  PCSharedCount::~PCSharedCount(v2);
  _Unwind_Resume(a1);
}

void ProShade::BinaryOp<ProShade::Subtract>::binary(const PCSharedCount *a1@<X0>, const PCSharedCount *a2@<X1>, uint64_t a3@<X8>)
{
  __n128 v22[15] = *(PCSharedCount *)MEMORY[0x1E4F143B8];
  unint64_t var0 = a1[2].var0;
  if (var0) {
  else
  }
    unsigned int v7 = 0;
  uint64_t v8 = a2[2].var0;
  if (v8)
  {
    if (v7)
    {
      uint64_t v10 = v9;
      if (v9)
      {
        ProShade::Value::Value(&v19);
        ProShade::Value::Value(v17);
        ProShade::Value::Value(v15);
        (*(void (**)(void *, PCString *))(*(void *)v7 + 224))(v7, &v19);
        (*(void (**)(void *, PCString *))(*(void *)v10 + 224))(v10, v17);
        ProShade::BinaryOp<ProShade::Subtract>::computeBinary(&v19, v17, (uint64_t)v15);
        ProShade::Const::create((ProShade::Const *)v15, v11);
      }
    }
  }
  v19.unint64_t var0 = (__CFString *)&unk_1F11193B8;
  uint64_t v21 = 0;
  PCSharedCount::PCSharedCount(v22);
  uint64_t v12 = (__CFString *)a1[2].var0;
  v17[0].unint64_t var0 = (__CFString *)&unk_1F11193B8;
  v17[2].unint64_t var0 = v12;
  PCSharedCount::PCSharedCount(v18, a1 + 3);
  unsigned int v13 = a2[2].var0;
  v15[0] = &unk_1F11193B8;
  _OWORD v15[2] = v13;
  PCSharedCount::PCSharedCount(v16, a2 + 3);
  BOOL v14 = ProShade::Subtract::simplify((const PCSharedCount *)v17, (uint64_t)v15, (uint64_t)&v19);
  v15[0] = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v16);
  v17[0].unint64_t var0 = (__CFString *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v18);
  if (!v14) {
    operator new();
  }
  *(void *)a3 = &unk_1F11193B8;
  *(unsigned char *)(a3 + 8) = v20;
  *(void *)(a3 + 16) = v21;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a3 + 24), v22);
  v19.unint64_t var0 = (__CFString *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v22);
}

void sub_1B7AB2F64(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v3, 0x10B1C403815D87CLL);
  *(void *)(v4 - 240) = v1;
  PCSharedCount::~PCSharedCount(v2);
  _Unwind_Resume(a1);
}

void ProShade::BinaryOp<ProShade::Multiply>::binary(const PCSharedCount *a1@<X0>, const PCSharedCount *a2@<X1>, uint64_t a3@<X8>)
{
  __n128 v22[15] = *(PCSharedCount *)MEMORY[0x1E4F143B8];
  unint64_t var0 = a1[2].var0;
  if (var0) {
  else
  }
    unsigned int v7 = 0;
  uint64_t v8 = a2[2].var0;
  if (v8)
  {
    if (v7)
    {
      uint64_t v10 = v9;
      if (v9)
      {
        ProShade::Value::Value(&v19);
        ProShade::Value::Value(v17);
        ProShade::Value::Value(v15);
        (*(void (**)(void *, void **))(*(void *)v7 + 224))(v7, &v19);
        (*(void (**)(void *, void *))(*(void *)v10 + 224))(v10, v17);
        ProShade::BinaryOp<ProShade::Multiply>::computeBinary((unsigned int *)&v19, (unsigned int *)v17, (uint64_t)v15);
        ProShade::Const::create((ProShade::Const *)v15, v11);
      }
    }
  }
  PCString v19 = &unk_1F11193B8;
  uint64_t v21 = 0;
  PCSharedCount::PCSharedCount(v22);
  uint64_t v12 = a1[2].var0;
  v17[0] = &unk_1F11193B8;
  v17[2] = v12;
  PCSharedCount::PCSharedCount(v18, a1 + 3);
  unsigned int v13 = a2[2].var0;
  v15[0] = &unk_1F11193B8;
  _OWORD v15[2] = v13;
  PCSharedCount::PCSharedCount(v16, a2 + 3);
  BOOL v14 = ProShade::Multiply::simplify((uint64_t)v17, (uint64_t)v15, (uint64_t)&v19);
  v15[0] = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v16);
  v17[0] = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v18);
  if (!v14) {
    operator new();
  }
  *(void *)a3 = &unk_1F11193B8;
  *(unsigned char *)(a3 + 8) = v20;
  *(void *)(a3 + 16) = v21;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a3 + 24), v22);
  PCString v19 = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v22);
}

void sub_1B7AB331C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v3, 0x10B1C403815D87CLL);
  *(void *)(v4 - 240) = v1;
  PCSharedCount::~PCSharedCount(v2);
  _Unwind_Resume(a1);
}

void ProShade::BinaryOp<ProShade::Divide>::binary(const PCSharedCount *a1@<X0>, const PCSharedCount *a2@<X1>, uint64_t a3@<X8>)
{
  __n128 v22[15] = *(PCSharedCount *)MEMORY[0x1E4F143B8];
  unint64_t var0 = a1[2].var0;
  if (var0) {
  else
  }
    unsigned int v7 = 0;
  uint64_t v8 = a2[2].var0;
  if (v8)
  {
    if (v7)
    {
      uint64_t v10 = v9;
      if (v9)
      {
        ProShade::Value::Value(&v19);
        ProShade::Value::Value(v17);
        ProShade::Value::Value(v15);
        (*(void (**)(void *, PCString *))(*(void *)v7 + 224))(v7, &v19);
        (*(void (**)(void *, PCString *))(*(void *)v10 + 224))(v10, v17);
        ProShade::BinaryOp<ProShade::Divide>::computeBinary(&v19, v17, (uint64_t)v15);
        ProShade::Const::create((ProShade::Const *)v15, v11);
      }
    }
  }
  v19.unint64_t var0 = (__CFString *)&unk_1F11193B8;
  uint64_t v21 = 0;
  PCSharedCount::PCSharedCount(v22);
  uint64_t v12 = (__CFString *)a1[2].var0;
  v17[0].unint64_t var0 = (__CFString *)&unk_1F11193B8;
  v17[2].unint64_t var0 = v12;
  PCSharedCount::PCSharedCount(v18, a1 + 3);
  unsigned int v13 = a2[2].var0;
  v15[0] = &unk_1F11193B8;
  _OWORD v15[2] = v13;
  PCSharedCount::PCSharedCount(v16, a2 + 3);
  BOOL v14 = ProShade::Divide::simplify((const PCSharedCount *)v17, (uint64_t)v15, (uint64_t)&v19);
  v15[0] = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v16);
  v17[0].unint64_t var0 = (__CFString *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v18);
  if (!v14) {
    operator new();
  }
  *(void *)a3 = &unk_1F11193B8;
  *(unsigned char *)(a3 + 8) = v20;
  *(void *)(a3 + 16) = v21;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a3 + 24), v22);
  v19.unint64_t var0 = (__CFString *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v22);
}

void sub_1B7AB36A0(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v3, 0x10B1C403815D87CLL);
  *(void *)(v4 - 240) = v1;
  PCSharedCount::~PCSharedCount(v2);
  _Unwind_Resume(a1);
}

void ProShade::operator==(const PCSharedCount *a1, uint64_t a2)
{
  if (ProShade::VarT<ProShade::Node>::width((uint64_t)a1, (const PCString *)a2) == 1) {
    operator new();
  }
  unint64_t var0 = a1[2].var0;
  v8[0] = &unk_1F11193B8;
  _OWORD v8[2] = var0;
  PCSharedCount::PCSharedCount(&v9, a1 + 3);
  uint64_t v5 = *(void *)(a2 + 16);
  v6[0] = &unk_1F11193B8;
  uint64_t v6[2] = v5;
  PCSharedCount::PCSharedCount(&v7, (const PCSharedCount *)(a2 + 24));
  ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::equal_traits>>::eval((uint64_t)v8, (uint64_t)v6);
}

void sub_1B7AB3850(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  PCSharedCount::~PCSharedCount(v14);
  PCSharedCount::~PCSharedCount(v13);
  _Unwind_Resume(a1);
}

uint64_t ProShade::BinaryOp<ProShade::Equals>::BinaryOp(uint64_t a1, PCShared_base *a2, PCShared_base *a3)
{
  *(void *)(a1 + 112) = &unk_1F1199AC8;
  *(void *)(a1 + 120) = 0;
  *(unsigned char *)(a1 + 128) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F1120120);
  *(void *)a1 = &unk_1F1120048;
  *(void *)(a1 + 112) = &unk_1F1120100;
  ProShade::VarT<ProShade::Node>::VarT((PCSharedCount *)(a1 + 48), a2);
  ProShade::VarT<ProShade::Node>::VarT((PCSharedCount *)(a1 + 80), a3);
  int v7 = *((_DWORD *)a2 + 7);
  int v8 = *((_DWORD *)a3 + 7);
  if (v7 != 1)
  {
    if (v8 == 1)
    {
      int v8 = *((_DWORD *)a2 + 7);
    }
    else
    {
      BOOL v9 = v7 == v8;
      int v8 = *((_DWORD *)a2 + 7);
      if (!v9) {
        ProShade::Error<PCIllegalArgumentException>::raise<char [33]>((OZChannelBase *)"vector size mismatch", v6);
      }
    }
  }
  *(_DWORD *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 28) = v8;
  ProShade::BinaryOp<ProShade::Multiply>::setFrequency(a1);
  return a1;
}

void sub_1B7AB39C4(_Unwind_Exception *a1)
{
  *(void *)(v1 + 48) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(v1 + 72));
  ProShade::Node::~Node((ProShade::Node *)v1, (uint64_t *)(v4 + 8));
  *(void *)(v1 + 112) = v3;
  *(unsigned char *)(v1 + 128) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

void ProShade::operator>(const PCSharedCount *a1, uint64_t a2)
{
  if (ProShade::VarT<ProShade::Node>::width((uint64_t)a1, (const PCString *)a2) == 1) {
    operator new();
  }
  unint64_t var0 = a1[2].var0;
  v8[0] = &unk_1F11193B8;
  _OWORD v8[2] = var0;
  PCSharedCount::PCSharedCount(&v9, a1 + 3);
  uint64_t v5 = *(void *)(a2 + 16);
  v6[0] = &unk_1F11193B8;
  uint64_t v6[2] = v5;
  PCSharedCount::PCSharedCount(&v7, (const PCSharedCount *)(a2 + 24));
  ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::greaterThan_traits>>::eval((uint64_t)v8, (uint64_t)v6);
}

void sub_1B7AB3B94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  PCSharedCount::~PCSharedCount(v14);
  PCSharedCount::~PCSharedCount(v13);
  _Unwind_Resume(a1);
}

uint64_t ProShade::BinaryOp<ProShade::GreaterThan>::BinaryOp(uint64_t a1, PCShared_base *a2, PCShared_base *a3)
{
  *(void *)(a1 + 112) = &unk_1F1199AC8;
  *(void *)(a1 + 120) = 0;
  *(unsigned char *)(a1 + 128) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F1120398);
  *(void *)a1 = &unk_1F11202C0;
  *(void *)(a1 + 112) = &unk_1F1120378;
  ProShade::VarT<ProShade::Node>::VarT((PCSharedCount *)(a1 + 48), a2);
  ProShade::VarT<ProShade::Node>::VarT((PCSharedCount *)(a1 + 80), a3);
  int v7 = *((_DWORD *)a2 + 7);
  int v8 = *((_DWORD *)a3 + 7);
  if (v7 != 1)
  {
    if (v8 == 1)
    {
      int v8 = *((_DWORD *)a2 + 7);
    }
    else
    {
      BOOL v9 = v7 == v8;
      int v8 = *((_DWORD *)a2 + 7);
      if (!v9) {
        ProShade::Error<PCIllegalArgumentException>::raise<char [33]>((OZChannelBase *)"vector size mismatch", v6);
      }
    }
  }
  *(_DWORD *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 28) = v8;
  ProShade::BinaryOp<ProShade::Multiply>::setFrequency(a1);
  return a1;
}

void sub_1B7AB3D08(_Unwind_Exception *a1)
{
  *(void *)(v1 + 48) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(v1 + 72));
  ProShade::Node::~Node((ProShade::Node *)v1, (uint64_t *)(v4 + 8));
  *(void *)(v1 + 112) = v3;
  *(unsigned char *)(v1 + 128) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

void ProShade::operator<=(const PCSharedCount *a1, uint64_t a2)
{
  if (ProShade::VarT<ProShade::Node>::width((uint64_t)a1, (const PCString *)a2) == 1) {
    operator new();
  }
  unint64_t var0 = a1[2].var0;
  v8[0] = &unk_1F11193B8;
  _OWORD v8[2] = var0;
  PCSharedCount::PCSharedCount(&v9, a1 + 3);
  uint64_t v5 = *(void *)(a2 + 16);
  v6[0] = &unk_1F11193B8;
  uint64_t v6[2] = v5;
  PCSharedCount::PCSharedCount(&v7, (const PCSharedCount *)(a2 + 24));
  ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::lessThanEqual_traits>>::eval((uint64_t)v8, (uint64_t)v6);
}

void sub_1B7AB3ED8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  PCSharedCount::~PCSharedCount(v14);
  PCSharedCount::~PCSharedCount(v13);
  _Unwind_Resume(a1);
}

uint64_t ProShade::BinaryOp<ProShade::LessThanEquals>::BinaryOp(uint64_t a1, PCShared_base *a2, PCShared_base *a3)
{
  *(void *)(a1 + 112) = &unk_1F1199AC8;
  *(void *)(a1 + 120) = 0;
  *(unsigned char *)(a1 + 128) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F1120610);
  *(void *)a1 = &unk_1F1120538;
  *(void *)(a1 + 112) = &unk_1F11205F0;
  ProShade::VarT<ProShade::Node>::VarT((PCSharedCount *)(a1 + 48), a2);
  ProShade::VarT<ProShade::Node>::VarT((PCSharedCount *)(a1 + 80), a3);
  int v7 = *((_DWORD *)a2 + 7);
  int v8 = *((_DWORD *)a3 + 7);
  if (v7 != 1)
  {
    if (v8 == 1)
    {
      int v8 = *((_DWORD *)a2 + 7);
    }
    else
    {
      BOOL v9 = v7 == v8;
      int v8 = *((_DWORD *)a2 + 7);
      if (!v9) {
        ProShade::Error<PCIllegalArgumentException>::raise<char [33]>((OZChannelBase *)"vector size mismatch", v6);
      }
    }
  }
  *(_DWORD *)(a1 + 24) = 1;
  *(_DWORD *)(a1 + 28) = v8;
  ProShade::BinaryOp<ProShade::Multiply>::setFrequency(a1);
  return a1;
}

void sub_1B7AB404C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 48) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(v1 + 72));
  ProShade::Node::~Node((ProShade::Node *)v1, (uint64_t *)(v4 + 8));
  *(void *)(v1 + 112) = v3;
  *(unsigned char *)(v1 + 128) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

void ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::equal_traits>>::eval(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(const void **)(a1 + 16);
  if (v3) {
  else
  }
    uint64_t v4 = 0;
  uint64_t v5 = *(const void **)(a2 + 16);
  if (v5)
  {
    if (v4)
    {
      if (v6) {
        ProShade::ScalarFunctionTraits_2<ProShade::equal_traits>::compute((uint64_t)v4, (uint64_t)v6);
      }
    }
  }
  PCSharedCount::PCSharedCount(&v7);
  operator new();
}

void sub_1B7AB4290(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1 + 3);
  _Unwind_Resume(a1);
}

void ProShade::ScalarFunctionTraits_2<ProShade::equal_traits>::compute(uint64_t a1, uint64_t a2)
{
  v8[18] = *MEMORY[0x1E4F143B8];
  ProShade::Value::Value(v8);
  ProShade::Value::Value(v7);
  ProShade::Value::Value(&v6);
  (*(void (**)(uint64_t, void *))(*(void *)a1 + 224))(a1, v8);
  (*(void (**)(uint64_t, void *))(*(void *)a2 + 224))(a2, v7);
  if (SLODWORD(v8[0]) > 1)
  {
    if (LODWORD(v8[0]) != 2) {
      goto LABEL_8;
    }
    int v4 = v7[0];
  }
  else
  {
    int v4 = v7[0];
    if (SLODWORD(v7[0]) < 2)
    {
      ProShade::eval_type<ProShade::equal_traits,BOOL>((uint64_t)v8, (uint64_t)v7, &v6);
      goto LABEL_9;
    }
  }
  if (v4 <= 2)
  {
    ProShade::eval_type<ProShade::equal_traits,int>((uint64_t)v8, (uint64_t)v7, &v6);
    goto LABEL_9;
  }
LABEL_8:
  ProShade::eval_type<ProShade::equal_traits,double>((uint64_t)v8, (uint64_t)v7, &v6);
LABEL_9:
  ProShade::Const::create((ProShade::Const *)&v6, v5);
}

PCSharedCount *ProShade::VarT<ProShade::Const>::~VarT(PCSharedCount *a1)
{
  a1->unint64_t var0 = (PC_Sp_counted_base *)&unk_1F111EBD0;
  PCSharedCount::~PCSharedCount(a1 + 3);
  return a1;
}

uint64_t ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::equal_traits>>::Func(uint64_t a1, PCShared_base *a2, PCShared_base *a3)
{
  *(void *)(a1 + 72) = &unk_1F1199AC8;
  *(void *)(a1 + 80) = 0;
  *(unsigned char *)(a1 + 88) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F111ECF0);
  *(void *)a1 = &unk_1F111EC18;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = &unk_1F111ECD0;
  *(void *)(a1 + 48) = &unk_1F1119AF8;
  *(void *)(a1 + LiDepthSorter::stackSort((uint64_t)this + 56) = 0;
  *(void *)(a1 + 24) = *((void *)a2 + 3);
  ProShade::VarT<ProShade::Node>::VarT(v13, a2);
  int v6 = *(_DWORD *)(a1 + 60);
  if (*(_DWORD *)(a1 + 56) <= v6) {
    int v7 = (2 * (v6 + 1)) | 1;
  }
  else {
    int v7 = *(_DWORD *)(a1 + 56);
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a1 + 48, v6 + 1, v7);
  ProShade::VarT<ProShade::Node>::operator=(*(void *)(a1 + 64) + 32 * *(int *)(a1 + 60) - 32, v13);
  v13[0].unint64_t var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(&v14);
  ProShade::VarT<ProShade::Node>::VarT(v13, a3);
  int v8 = *(_DWORD *)(a1 + 60);
  if (*(_DWORD *)(a1 + 56) <= v8) {
    int v9 = (2 * (v8 + 1)) | 1;
  }
  else {
    int v9 = *(_DWORD *)(a1 + 56);
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a1 + 48, v8 + 1, v9);
  ProShade::VarT<ProShade::Node>::operator=(*(void *)(a1 + 64) + 32 * *(int *)(a1 + 60) - 32, v13);
  v13[0].unint64_t var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(&v14);
  int v11 = *(_DWORD *)(a1 + 60);
  if (v11 < 1) {
    PCArray_base::badIndex(v10);
  }
  if (v11 <= 1) {
    PCArray_base::badIndex(v10);
  }
  ProShade::ScalarFunctionTraits_2<ProShade::equal_traits>::initType(a1, *(const PCString **)(a1 + 64), (const PCSharedCount *)(*(void *)(a1 + 64) + 32));
  ProShade::Node::setFrequency((ProShade::Node *)a1);
  if (*(_DWORD *)(a1 + 40) == 2 && *(int *)(a1 + 44) >= 3) {
    *(_DWORD *)(a1 + 40) = 3;
  }
  return a1;
}

void sub_1B7AB46AC(_Unwind_Exception *a1)
{
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::~PCArray(v4);
  ProShade::Node::~Node((ProShade::Node *)v1, (uint64_t *)(v5 + 8));
  *(void *)(v1 + 72) = v3;
  *(unsigned char *)(v1 + 88) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

uint64_t ProShade::eval_type<ProShade::equal_traits,BOOL>(uint64_t a1, uint64_t a2, OZChannelBase *a3)
{
  ProShade::Value::set((uint64_t)a3, (const PCString *)1, *(_DWORD *)(a1 + 4));
  if (*(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4))
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v16, "not implemented yet");
    PCString::PCString(&v15, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/Shading/PSFunc.h");
    PCException::PCException(exception, &v16, &v15, 441);
    *(void *)exception = &unk_1F10B1208;
  }
  Serializer = OZChannelBase::getSerializer(a3);
  uint64_t result = ProShade::shapeGetSize(*(_DWORD *)(a1 + 4), v7);
  if ((int)result >= 1)
  {
    int v9 = (unsigned __int8 *)(a2 + 16);
    uint64_t v10 = (unsigned __int8 *)(a1 + 16);
    do
    {
      int v11 = *v10++;
      BOOL v12 = v11 == 0;
      int v13 = *v9++;
      *(unsigned char *)Serializer = v12 ^ (v13 != 0);
      Serializer = (void ***)((char *)Serializer + 1);
      uint64_t result = (result - 1);
    }
    while (result);
  }
  return result;
}

void sub_1B7AB484C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString((PCString *)&a9);
  PCString::~PCString(&a10);
  if (v11) {
    __cxa_free_exception(v10);
  }
  _Unwind_Resume(a1);
}

uint64_t ProShade::eval_type<ProShade::equal_traits,int>(uint64_t a1, uint64_t a2, OZChannelBase *a3)
{
  ProShade::Value::set((uint64_t)a3, (const PCString *)1, *(_DWORD *)(a1 + 4));
  if (*(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4))
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v16, "not implemented yet");
    PCString::PCString(&v15, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/Shading/PSFunc.h");
    PCException::PCException(exception, &v16, &v15, 441);
    *(void *)exception = &unk_1F10B1208;
  }
  Serializer = OZChannelBase::getSerializer(a3);
  uint64_t result = ProShade::shapeGetSize(*(_DWORD *)(a1 + 4), v7);
  if ((int)result >= 1)
  {
    int v9 = (int *)(a2 + 16);
    uint64_t v10 = (int *)(a1 + 16);
    do
    {
      int v12 = *v10++;
      int v11 = v12;
      int v13 = *v9++;
      *(unsigned char *)Serializer = v11 == v13;
      Serializer = (void ***)((char *)Serializer + 1);
      uint64_t result = (result - 1);
    }
    while (result);
  }
  return result;
}

void sub_1B7AB49AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString((PCString *)&a9);
  PCString::~PCString(&a10);
  if (v11) {
    __cxa_free_exception(v10);
  }
  _Unwind_Resume(a1);
}

uint64_t ProShade::eval_type<ProShade::equal_traits,double>(uint64_t a1, uint64_t a2, OZChannelBase *a3)
{
  ProShade::Value::set((uint64_t)a3, (const PCString *)1, *(_DWORD *)(a1 + 4));
  if (*(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4))
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v16, "not implemented yet");
    PCString::PCString(&v15, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/Shading/PSFunc.h");
    PCException::PCException(exception, &v16, &v15, 441);
    *(void *)exception = &unk_1F10B1208;
  }
  Serializer = OZChannelBase::getSerializer(a3);
  uint64_t result = ProShade::shapeGetSize(*(_DWORD *)(a1 + 4), v7);
  if ((int)result >= 1)
  {
    int v9 = (double *)(a2 + 16);
    uint64_t v10 = (double *)(a1 + 16);
    do
    {
      double v11 = *v10++;
      double v12 = v11;
      double v13 = *v9++;
      *(unsigned char *)Serializer = v12 == v13;
      Serializer = (void ***)((char *)Serializer + 1);
      uint64_t result = (result - 1);
    }
    while (result);
  }
  return result;
}

void sub_1B7AB4B0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString((PCString *)&a9);
  PCString::~PCString(&a10);
  if (v11) {
    __cxa_free_exception(v10);
  }
  _Unwind_Resume(a1);
}

PCSharedCount *ProShade::VarT<ProShade::Const>::VarT(PCSharedCount *a1, PCShared_base *a2)
{
  a1->unint64_t var0 = (PC_Sp_counted_base *)&unk_1F111EBD0;
  a1[2].unint64_t var0 = (PC_Sp_counted_base *)a2;
  if (a2) {
    a2 = (PCShared_base *)((char *)a2 + *(void *)(*(void *)a2 - 24));
  }
  PCSharedCount::PCSharedCount(a1 + 3, a2);
  return a1;
}

void ProShade::VarT<ProShade::Const>::~VarT(PCSharedCount *a1)
{
  a1->unint64_t var0 = (PC_Sp_counted_base *)&unk_1F111EBD0;
  PCSharedCount::~PCSharedCount(a1 + 3);

  JUMPOUT(0x1BA9BFBA0);
}

void ProShade::ScalarFunctionTraits_2<ProShade::equal_traits>::initType(uint64_t a1, const PCString *a2, const PCSharedCount *a3)
{
  unint64_t var0 = a2[2].var0;
  if (!var0) {
    throw_PCNullPointerException(1);
  }
  int length_high = HIDWORD(var0->length);
  int v8 = a3[2].var0;
  if (!v8) {
    throw_PCNullPointerException(1);
  }
  if (length_high > v8[7])
  {
    int v8 = a2[2].var0;
    if (!v8) {
      throw_PCNullPointerException(1);
    }
  }
  unsigned int v9 = v8[7];
  *(_DWORD *)(a1 + 28) = v9;
  Width = (const PCString *)ProShade::shapeGetWidth(v9, a2);
  int v12 = *(_DWORD *)(a1 + 28);
  if (v12 >= 2)
  {
    double v13 = Width;
    PCSharedCount v14 = a2[2].var0;
    if (!v14) {
      throw_PCNullPointerException(1);
    }
    int v15 = HIDWORD(v14->length);
    if (v15 < v12)
    {
      if (v15 != 1) {
        ProShade::Error<PCException>::raise<char [27]>((OZChannelBase *)"width mismatch (first argument)", v11);
      }
      ProShade::Ctor::makeWidth(v14->length, Width, (const PCSharedCount *)a2, v22);
      ProShade::VarT<ProShade::Node>::operator=((uint64_t)a2, v22);
      v22[0].unint64_t var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
      PCSharedCount::~PCSharedCount(&v23);
    }
    PCString v16 = a3[2].var0;
    if (!v16) {
      throw_PCNullPointerException(1);
    }
    int v17 = *((_DWORD *)v16 + 7);
    if (v17 < *(_DWORD *)(a1 + 28))
    {
      if (v17 != 1) {
        ProShade::Error<PCException>::raise<char [27]>((OZChannelBase *)"width mismatch (second argument)", v11);
      }
      ProShade::Ctor::makeWidth(*((_DWORD *)v16 + 6), v13, a3, v22);
      ProShade::VarT<ProShade::Node>::operator=((uint64_t)a3, v22);
      v22[0].unint64_t var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
      PCSharedCount::~PCSharedCount(&v23);
    }
  }
  int v18 = a2[2].var0;
  if (!v18) {
    throw_PCNullPointerException(1);
  }
  int length = v18->length;
  char v20 = a3[2].var0;
  if (!v20) {
    throw_PCNullPointerException(1);
  }
  int v21 = *((_DWORD *)v20 + 6);
  if (length > v21) {
    int v21 = length;
  }
  *(_DWORD *)(a1 + 24) = v21;
}

void sub_1B7AB4DFC(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1 + 3);
  _Unwind_Resume(a1);
}

uint64_t ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::equal_traits>>::~Func(uint64_t a1)
{
  *(void *)(v2 + 72) = &unk_1F1199AC8;
  *(unsigned char *)(v2 + 88) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v2 + 80));
  return a1;
}

void ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::equal_traits>>::~Func(uint64_t a1)
{
  *(void *)(v1 + 72) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 88) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 80));

  JUMPOUT(0x1BA9BFBA0);
}

void ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::equal_traits>>::repr(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = a1 + 48;
  LiString::LiString((LiString *)&v5, "equal");
  ProShade::func_repr((PCArray_base *)&v5, v3, a2);
  if (v5 && atomic_fetch_add(v5 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)uint64_t v5 = 0;
    if (v5) {
      uint64_t v4 = v5 - 3;
    }
    else {
      uint64_t v4 = 0;
    }
    free(v4);
  }
}

void sub_1B7AB4F8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    ProShade::VertexProgram::VertexProgram(a10);
  }
  _Unwind_Resume(exception_object);
}

void ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::equal_traits>>::description(void *a1@<X8>)
{
  LiString::LiString((LiString *)&v8, "Func ");
  uint64_t v2 = v8;
  if (v8) {
    int v3 = *((_DWORD *)v8 - 2);
  }
  else {
    int v3 = 0;
  }
  size_t v4 = v3;
  uint64_t v5 = (unsigned int *)malloc_type_malloc(v3 + 18, 0x8903763CuLL);
  v5[1] = v4 + 5;
  v5[2] = v4 + 6;
  atomic_store(1u, v5);
  atomic_store(0, v5);
  memcpy(v5 + 3, v2, v4);
  int v6 = (char *)v5 + v4 + 12;
  *(_DWORD *)int v6 = 1635086693;
  void v6[4] = 108;
  *((unsigned char *)v5 + v4 + 17) = 0;
  *a1 = v5 + 3;
  atomic_fetch_add((atomic_uint *volatile)v5, 1u);
  if (v8 && atomic_fetch_add((atomic_uint *volatile)v8 - 3, 0xFFFFFFFF) == 1)
  {
    unsigned char *v8 = 0;
    if (v8) {
      int v7 = v8 - 12;
    }
    else {
      int v7 = 0;
    }
    free(v7);
  }
}

void sub_1B7AB50AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    ProShade::VertexProgram::VertexProgram(a10);
  }
  _Unwind_Resume(exception_object);
}

void ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::equal_traits>>::shortDescription(LiString *a1@<X8>)
{
}

int8x8_t *ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::equal_traits>>::computeHash(uint64_t a1, int8x8_t *this)
{
  PCHashWriteStream::writeValue(this, "Func");
  uint64_t result = PCHashWriteStream::writeValue(this, "equal");
  if (*(int *)(a1 + 60) >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    do
    {
      ProShade::VarT<ProShade::Node>::hash(*(void *)(a1 + 64) + v5, &v7);
      uint64_t result = PCHashWriteStream::writeValue(this, (const PCHash128 *)&v7);
      ++v6;
      v5 += 32;
    }
    while (v6 < *(int *)(a1 + 60));
  }
  return result;
}

uint64_t ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::equal_traits>>::apply@<X0>(uint64_t a1@<X0>, void (***a2)(PCSharedCount *__return_ptr, void, uint64_t)@<X1>, PCArray_base *a3@<X8>)
{
  size_t v4 = a3;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  PCString v19 = &unk_1F1119AF8;
  uint64_t v5 = *(unsigned int *)(a1 + 60);
  if ((int)v5 >= 1)
  {
    uint64_t v7 = 0;
    char v8 = 0;
    uint64_t v9 = 16;
    do
    {
      if (v7 >= *(int *)(a1 + 60)) {
        PCArray_base::badIndex(v4);
      }
      uint64_t v10 = *(void *)(a1 + 64);
      (**a2)(v17, a2, v10 + v9 - 16);
      unint64_t var0 = v17[2].var0;
      int v12 = *(PC_Sp_counted_base **)(v10 + v9);
      if ((int)v20 <= SHIDWORD(v20)) {
        int v13 = (2 * (HIDWORD(v20) + 1)) | 1;
      }
      else {
        int v13 = v20;
      }
      PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize((uint64_t)&v19, HIDWORD(v20) + 1, v13);
      ProShade::VarT<ProShade::Node>::operator=(v21 + 32 * SHIDWORD(v20) - 32, v17);
      v8 |= var0 != v12;
      v17[0].unint64_t var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
      PCSharedCount::~PCSharedCount(&v18);
      ++v7;
      v9 += 32;
    }
    while (v5 != v7);
    if (v8) {
      operator new();
    }
    size_t v4 = a3;
  }
  ProShade::VarT<ProShade::Node>::VarT((PCSharedCount *)v4, (PCShared_base *)a1);
  PCString v19 = &unk_1F1119AF8;
  if ((int)v20 < 0) {
    int v14 = 1;
  }
  else {
    int v14 = v20;
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize((uint64_t)&v19, 0, v14);
  uint64_t result = v21;
  if (v21) {
    return MEMORY[0x1BA9BFB70](v21, 0x1000C8077774924);
  }
  return result;
}

void sub_1B7AB5358(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  MEMORY[0x1BA9BFBA0](v8, 0x10B1C40241F72B2);
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::~PCArray((uint64_t)va);
  _Unwind_Resume(a1);
}

void ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::equal_traits>>::clone()
{
}

void sub_1B7AB5510(_Unwind_Exception *a1)
{
  *(void *)(v1 + 72) = v2;
  *(unsigned char *)(v1 + 88) = 0;
  PCWeakCount::~PCWeakCount(v3);
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C40241F72B2);
  _Unwind_Resume(a1);
}

uint64_t ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::equal_traits>>::computeValue(PCArray_base *a1, uint64_t a2, OZChannelBase *a3)
{
  int v4 = *(_DWORD *)(a2 + 12);
  if (v4 < 1) {
    PCArray_base::badIndex(a1);
  }
  if (v4 <= 1) {
    PCArray_base::badIndex(a1);
  }
  uint64_t v5 = (int *)(*(void *)(a2 + 16) + 144);
  int v6 = **(_DWORD **)(a2 + 16);
  if (v6 > 1)
  {
    if (v6 != 2) {
      goto LABEL_16;
    }
    int v7 = *v5;
  }
  else
  {
    int v7 = *v5;
    if (*v5 < 2)
    {
      uint64_t v8 = *(void *)(a2 + 16);
      return ProShade::eval_type<ProShade::equal_traits,BOOL>(v8, (uint64_t)v5, a3);
    }
  }
  if (v7 <= 2)
  {
    uint64_t v10 = *(void *)(a2 + 16);
    return ProShade::eval_type<ProShade::equal_traits,int>(v10, (uint64_t)v5, a3);
  }
LABEL_16:
  uint64_t v11 = *(void *)(a2 + 16);

  return ProShade::eval_type<ProShade::equal_traits,double>(v11, (uint64_t)v5, a3);
}

void virtual thunk to'ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::equal_traits>>::~Func(void *a1)
{
  *(void *)(v1 + 72) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 88) = 0;
  uint64_t v2 = (PC_Sp_counted_base **)(v1 + 80);

  PCWeakCount::~PCWeakCount(v2);
}

{
  uint64_t v1;
  uint64_t vars8;

  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24);
  *(void *)(v1 + 72) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 88) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 80));

  JUMPOUT(0x1BA9BFBA0);
}

void *operator+@<X0>(const void **a1@<X0>, unsigned char *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *a1;
  if (*a1) {
    int v6 = *(v5 - 2);
  }
  else {
    int v6 = 0;
  }
  LODWORD(v7) = *a2;
  if (*a2)
  {
    uint64_t v7 = 0;
    while (a2[++v7])
      ;
  }
  size_t v9 = (int)v7;
  uint64_t v10 = (int)v7 + (uint64_t)v6;
  uint64_t v11 = (unsigned int *)malloc_type_malloc(v10 + 13, 0x8903763CuLL);
  v11[1] = v10;
  std::locale v11[2] = v10 + 1;
  atomic_store(1u, v11);
  atomic_store(0, v11);
  memcpy(v11 + 3, v5, v6);
  uint64_t result = memcpy((char *)v11 + v6 + 12, a2, v9);
  *((unsigned char *)v11 + v10 + 12) = 0;
  *a3 = v11 + 3;
  atomic_fetch_add((atomic_uint *volatile)v11, 1u);
  return result;
}

void *operator+@<X0>(const void **a1@<X0>, const void **a2@<X1>, void *a3@<X8>)
{
  int v4 = *a1;
  if (*a1) {
    int v5 = *(v4 - 2);
  }
  else {
    int v5 = 0;
  }
  int v6 = *a2;
  if (*a2) {
    int v7 = *(v6 - 2);
  }
  else {
    int v7 = 0;
  }
  size_t v8 = v7;
  uint64_t v9 = v7 + (uint64_t)v5;
  uint64_t v10 = (unsigned int *)malloc_type_malloc(v9 + 13, 0x8903763CuLL);
  v10[1] = v9;
  _OWORD v10[2] = v9 + 1;
  atomic_store(1u, v10);
  atomic_store(0, v10);
  memcpy(v10 + 3, v4, v5);
  uint64_t result = memcpy((char *)v10 + v5 + 12, v6, v8);
  *((unsigned char *)v10 + v9 + 12) = 0;
  *a3 = v10 + 3;
  atomic_fetch_add((atomic_uint *volatile)v10, 1u);
  return result;
}

uint64_t ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::equal_traits>>::Func(uint64_t a1, uint64_t a2, const ProShade::Node *a3)
{
  *(void *)(a1 + 72) = &unk_1F1199AC8;
  *(void *)(a1 + 80) = 0;
  *(unsigned char *)(a1 + 88) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F111ECF0);
  *(void *)a1 = &unk_1F111EC18;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = &unk_1F111ECD0;
  *(void *)(a1 + 48) = &unk_1F1119AF8;
  *(void *)(a1 + LiDepthSorter::stackSort((uint64_t)this + 56) = 0;
  ProShade::Node::copyFrom((ProShade::Node *)a1, a3);
  int v6 = *(_DWORD *)(a2 + 12);
  if (*(_DWORD *)(a1 + 56) >= v6) {
    int v7 = *(_DWORD *)(a1 + 56);
  }
  else {
    int v7 = (2 * v6) | 1;
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a1 + 48, v6, v7);
  if (*(int *)(a2 + 12) >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    do
    {
      ProShade::VarT<ProShade::Node>::operator=(*(void *)(a1 + 64) + v8, (const PCSharedCount *)(*(void *)(a2 + 16) + v8));
      ++v9;
      v8 += 32;
    }
    while (v9 < *(int *)(a2 + 12));
  }
  return a1;
}

void sub_1B7AB5A2C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 72) = v3;
  *(unsigned char *)(v1 + 88) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

void ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::greaterThan_traits>>::eval(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(const void **)(a1 + 16);
  if (v3) {
  else
  }
    int v4 = 0;
  int v5 = *(const void **)(a2 + 16);
  if (v5)
  {
    if (v4)
    {
      if (v6) {
        ProShade::ScalarFunctionTraits_2<ProShade::greaterThan_traits>::compute((uint64_t)v4, (uint64_t)v6);
      }
    }
  }
  PCSharedCount::PCSharedCount(&v7);
  operator new();
}

void sub_1B7AB5C20(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1 + 3);
  _Unwind_Resume(a1);
}

void ProShade::ScalarFunctionTraits_2<ProShade::greaterThan_traits>::compute(uint64_t a1, uint64_t a2)
{
  v8[18] = *MEMORY[0x1E4F143B8];
  ProShade::Value::Value(v8);
  ProShade::Value::Value(v7);
  ProShade::Value::Value(&v6);
  (*(void (**)(uint64_t, void *))(*(void *)a1 + 224))(a1, v8);
  (*(void (**)(uint64_t, void *))(*(void *)a2 + 224))(a2, v7);
  if (SLODWORD(v8[0]) > 1)
  {
    if (LODWORD(v8[0]) != 2) {
      goto LABEL_8;
    }
    int v4 = v7[0];
  }
  else
  {
    int v4 = v7[0];
    if (SLODWORD(v7[0]) < 2)
    {
      ProShade::eval_type<ProShade::greaterThan_traits,BOOL>((uint64_t)v8, (uint64_t)v7, &v6);
      goto LABEL_9;
    }
  }
  if (v4 <= 2)
  {
    ProShade::eval_type<ProShade::greaterThan_traits,int>((uint64_t)v8, (uint64_t)v7, &v6);
    goto LABEL_9;
  }
LABEL_8:
  ProShade::eval_type<ProShade::greaterThan_traits,double>((uint64_t)v8, (uint64_t)v7, &v6);
LABEL_9:
  ProShade::Const::create((ProShade::Const *)&v6, v5);
}

uint64_t ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::greaterThan_traits>>::Func(uint64_t a1, PCShared_base *a2, PCShared_base *a3)
{
  *(void *)(a1 + 72) = &unk_1F1199AC8;
  *(void *)(a1 + 80) = 0;
  *(unsigned char *)(a1 + 88) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F111EF68);
  *(void *)a1 = &unk_1F111EE90;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = &unk_1F111EF48;
  *(void *)(a1 + 48) = &unk_1F1119AF8;
  *(void *)(a1 + LiDepthSorter::stackSort((uint64_t)this + 56) = 0;
  *(void *)(a1 + 24) = *((void *)a2 + 3);
  ProShade::VarT<ProShade::Node>::VarT(v13, a2);
  int v6 = *(_DWORD *)(a1 + 60);
  if (*(_DWORD *)(a1 + 56) <= v6) {
    int v7 = (2 * (v6 + 1)) | 1;
  }
  else {
    int v7 = *(_DWORD *)(a1 + 56);
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a1 + 48, v6 + 1, v7);
  ProShade::VarT<ProShade::Node>::operator=(*(void *)(a1 + 64) + 32 * *(int *)(a1 + 60) - 32, v13);
  v13[0].unint64_t var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(&v14);
  ProShade::VarT<ProShade::Node>::VarT(v13, a3);
  int v8 = *(_DWORD *)(a1 + 60);
  if (*(_DWORD *)(a1 + 56) <= v8) {
    int v9 = (2 * (v8 + 1)) | 1;
  }
  else {
    int v9 = *(_DWORD *)(a1 + 56);
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a1 + 48, v8 + 1, v9);
  ProShade::VarT<ProShade::Node>::operator=(*(void *)(a1 + 64) + 32 * *(int *)(a1 + 60) - 32, v13);
  v13[0].unint64_t var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(&v14);
  int v11 = *(_DWORD *)(a1 + 60);
  if (v11 < 1) {
    PCArray_base::badIndex(v10);
  }
  if (v11 <= 1) {
    PCArray_base::badIndex(v10);
  }
  ProShade::ScalarFunctionTraits_2<ProShade::equal_traits>::initType(a1, *(const PCString **)(a1 + 64), (const PCSharedCount *)(*(void *)(a1 + 64) + 32));
  ProShade::Node::setFrequency((ProShade::Node *)a1);
  if (*(_DWORD *)(a1 + 40) == 2 && *(int *)(a1 + 44) >= 3) {
    *(_DWORD *)(a1 + 40) = 3;
  }
  return a1;
}

void sub_1B7AB5FF8(_Unwind_Exception *a1)
{
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::~PCArray(v4);
  ProShade::Node::~Node((ProShade::Node *)v1, (uint64_t *)(v5 + 8));
  *(void *)(v1 + 72) = v3;
  *(unsigned char *)(v1 + 88) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

uint64_t ProShade::eval_type<ProShade::greaterThan_traits,BOOL>(uint64_t a1, uint64_t a2, OZChannelBase *a3)
{
  ProShade::Value::set((uint64_t)a3, (const PCString *)1, *(_DWORD *)(a1 + 4));
  if (*(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4))
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v19, "not implemented yet");
    PCString::PCString(&v18, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/Shading/PSFunc.h");
    PCException::PCException(exception, &v19, &v18, 441);
    *(void *)exception = &unk_1F10B1208;
  }
  Serializer = OZChannelBase::getSerializer(a3);
  uint64_t result = ProShade::shapeGetSize(*(_DWORD *)(a1 + 4), v7);
  if ((int)result >= 1)
  {
    int v9 = (unsigned __int8 *)(a2 + 16);
    uint64_t v10 = (unsigned __int8 *)(a1 + 16);
    do
    {
      int v12 = *v10++;
      int v11 = v12;
      int v14 = *v9++;
      int v13 = v14;
      if (v11) {
        BOOL v15 = v13 == 0;
      }
      else {
        BOOL v15 = 0;
      }
      char v16 = v15;
      *(unsigned char *)Serializer = v16;
      Serializer = (void ***)((char *)Serializer + 1);
      uint64_t result = (result - 1);
    }
    while (result);
  }
  return result;
}

void sub_1B7AB6190(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString((PCString *)&a9);
  PCString::~PCString(&a10);
  if (v11) {
    __cxa_free_exception(v10);
  }
  _Unwind_Resume(a1);
}

uint64_t ProShade::eval_type<ProShade::greaterThan_traits,int>(uint64_t a1, uint64_t a2, OZChannelBase *a3)
{
  ProShade::Value::set((uint64_t)a3, (const PCString *)1, *(_DWORD *)(a1 + 4));
  if (*(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4))
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v16, "not implemented yet");
    PCString::PCString(&v15, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/Shading/PSFunc.h");
    PCException::PCException(exception, &v16, &v15, 441);
    *(void *)exception = &unk_1F10B1208;
  }
  Serializer = OZChannelBase::getSerializer(a3);
  uint64_t result = ProShade::shapeGetSize(*(_DWORD *)(a1 + 4), v7);
  if ((int)result >= 1)
  {
    int v9 = (int *)(a2 + 16);
    uint64_t v10 = (int *)(a1 + 16);
    do
    {
      int v12 = *v10++;
      int v11 = v12;
      int v13 = *v9++;
      *(unsigned char *)Serializer = v11 > v13;
      Serializer = (void ***)((char *)Serializer + 1);
      uint64_t result = (result - 1);
    }
    while (result);
  }
  return result;
}

void sub_1B7AB62F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString((PCString *)&a9);
  PCString::~PCString(&a10);
  if (v11) {
    __cxa_free_exception(v10);
  }
  _Unwind_Resume(a1);
}

uint64_t ProShade::eval_type<ProShade::greaterThan_traits,double>(uint64_t a1, uint64_t a2, OZChannelBase *a3)
{
  ProShade::Value::set((uint64_t)a3, (const PCString *)1, *(_DWORD *)(a1 + 4));
  if (*(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4))
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v16, "not implemented yet");
    PCString::PCString(&v15, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/Shading/PSFunc.h");
    PCException::PCException(exception, &v16, &v15, 441);
    *(void *)exception = &unk_1F10B1208;
  }
  Serializer = OZChannelBase::getSerializer(a3);
  uint64_t result = ProShade::shapeGetSize(*(_DWORD *)(a1 + 4), v7);
  if ((int)result >= 1)
  {
    int v9 = (double *)(a2 + 16);
    uint64_t v10 = (double *)(a1 + 16);
    do
    {
      double v11 = *v10++;
      double v12 = v11;
      double v13 = *v9++;
      *(unsigned char *)Serializer = v12 > v13;
      Serializer = (void ***)((char *)Serializer + 1);
      uint64_t result = (result - 1);
    }
    while (result);
  }
  return result;
}

void sub_1B7AB6450(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString((PCString *)&a9);
  PCString::~PCString(&a10);
  if (v11) {
    __cxa_free_exception(v10);
  }
  _Unwind_Resume(a1);
}

uint64_t ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::greaterThan_traits>>::~Func(uint64_t a1)
{
  *(void *)(v2 + 72) = &unk_1F1199AC8;
  *(unsigned char *)(v2 + 88) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v2 + 80));
  return a1;
}

void ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::greaterThan_traits>>::~Func(uint64_t a1)
{
  *(void *)(v1 + 72) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 88) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 80));

  JUMPOUT(0x1BA9BFBA0);
}

void ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::greaterThan_traits>>::repr(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = a1 + 48;
  LiString::LiString((LiString *)&v5, "greaterThan");
  ProShade::func_repr((PCArray_base *)&v5, v3, a2);
  if (v5 && atomic_fetch_add(v5 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)uint64_t v5 = 0;
    if (v5) {
      uint64_t v4 = v5 - 3;
    }
    else {
      uint64_t v4 = 0;
    }
    free(v4);
  }
}

void sub_1B7AB65EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    ProShade::VertexProgram::VertexProgram(a10);
  }
  _Unwind_Resume(exception_object);
}

void ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::greaterThan_traits>>::description(void *a1@<X8>)
{
  LiString::LiString((LiString *)&v8, "Func ");
  uint64_t v2 = v8;
  if (v8) {
    int v3 = *((_DWORD *)v8 - 2);
  }
  else {
    int v3 = 0;
  }
  size_t v4 = v3;
  uint64_t v5 = (unsigned int *)malloc_type_malloc(v3 + 24, 0x8903763CuLL);
  v5[1] = v4 + 11;
  v5[2] = v4 + 12;
  atomic_store(1u, v5);
  atomic_store(0, v5);
  memcpy(v5 + 3, v2, v4);
  int v6 = (char *)v5 + v4 + 12;
  *(_DWORD *)(v6 + 7) = 1851877460;
  *(void *)int v6 = *(void *)"greaterThan";
  *((unsigned char *)v5 + v4 + 23) = 0;
  *a1 = v5 + 3;
  atomic_fetch_add((atomic_uint *volatile)v5, 1u);
  if (v8 && atomic_fetch_add((atomic_uint *volatile)v8 - 3, 0xFFFFFFFF) == 1)
  {
    unsigned char *v8 = 0;
    if (v8) {
      int v7 = v8 - 12;
    }
    else {
      int v7 = 0;
    }
    free(v7);
  }
}

void sub_1B7AB6714(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    ProShade::VertexProgram::VertexProgram(a10);
  }
  _Unwind_Resume(exception_object);
}

void ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::greaterThan_traits>>::shortDescription(LiString *a1@<X8>)
{
}

int8x8_t *ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::greaterThan_traits>>::computeHash(uint64_t a1, int8x8_t *this)
{
  PCHashWriteStream::writeValue(this, "Func");
  uint64_t result = PCHashWriteStream::writeValue(this, "greaterThan");
  if (*(int *)(a1 + 60) >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    do
    {
      ProShade::VarT<ProShade::Node>::hash(*(void *)(a1 + 64) + v5, &v7);
      uint64_t result = PCHashWriteStream::writeValue(this, (const PCHash128 *)&v7);
      ++v6;
      v5 += 32;
    }
    while (v6 < *(int *)(a1 + 60));
  }
  return result;
}

uint64_t ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::greaterThan_traits>>::apply@<X0>(uint64_t a1@<X0>, void (***a2)(PCSharedCount *__return_ptr, void, uint64_t)@<X1>, PCArray_base *a3@<X8>)
{
  size_t v4 = a3;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  PCString v19 = &unk_1F1119AF8;
  uint64_t v5 = *(unsigned int *)(a1 + 60);
  if ((int)v5 >= 1)
  {
    uint64_t v7 = 0;
    char v8 = 0;
    uint64_t v9 = 16;
    do
    {
      if (v7 >= *(int *)(a1 + 60)) {
        PCArray_base::badIndex(v4);
      }
      uint64_t v10 = *(void *)(a1 + 64);
      (**a2)(v17, a2, v10 + v9 - 16);
      unint64_t var0 = v17[2].var0;
      double v12 = *(PC_Sp_counted_base **)(v10 + v9);
      if ((int)v20 <= SHIDWORD(v20)) {
        int v13 = (2 * (HIDWORD(v20) + 1)) | 1;
      }
      else {
        int v13 = v20;
      }
      PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize((uint64_t)&v19, HIDWORD(v20) + 1, v13);
      ProShade::VarT<ProShade::Node>::operator=(v21 + 32 * SHIDWORD(v20) - 32, v17);
      v8 |= var0 != v12;
      v17[0].unint64_t var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
      PCSharedCount::~PCSharedCount(&v18);
      ++v7;
      v9 += 32;
    }
    while (v5 != v7);
    if (v8) {
      operator new();
    }
    size_t v4 = a3;
  }
  ProShade::VarT<ProShade::Node>::VarT((PCSharedCount *)v4, (PCShared_base *)a1);
  PCString v19 = &unk_1F1119AF8;
  if ((int)v20 < 0) {
    int v14 = 1;
  }
  else {
    int v14 = v20;
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize((uint64_t)&v19, 0, v14);
  uint64_t result = v21;
  if (v21) {
    return MEMORY[0x1BA9BFB70](v21, 0x1000C8077774924);
  }
  return result;
}

void sub_1B7AB69C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  MEMORY[0x1BA9BFBA0](v8, 0x10B1C40241F72B2);
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::~PCArray((uint64_t)va);
  _Unwind_Resume(a1);
}

void ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::greaterThan_traits>>::clone()
{
}

void sub_1B7AB6B78(_Unwind_Exception *a1)
{
  *(void *)(v1 + 72) = v2;
  *(unsigned char *)(v1 + 88) = 0;
  PCWeakCount::~PCWeakCount(v3);
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C40241F72B2);
  _Unwind_Resume(a1);
}

uint64_t ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::greaterThan_traits>>::computeValue(PCArray_base *a1, uint64_t a2, OZChannelBase *a3)
{
  int v4 = *(_DWORD *)(a2 + 12);
  if (v4 < 1) {
    PCArray_base::badIndex(a1);
  }
  if (v4 <= 1) {
    PCArray_base::badIndex(a1);
  }
  uint64_t v5 = (int *)(*(void *)(a2 + 16) + 144);
  int v6 = **(_DWORD **)(a2 + 16);
  if (v6 > 1)
  {
    if (v6 != 2) {
      goto LABEL_16;
    }
    int v7 = *v5;
  }
  else
  {
    int v7 = *v5;
    if (*v5 < 2)
    {
      uint64_t v8 = *(void *)(a2 + 16);
      return ProShade::eval_type<ProShade::greaterThan_traits,BOOL>(v8, (uint64_t)v5, a3);
    }
  }
  if (v7 <= 2)
  {
    uint64_t v10 = *(void *)(a2 + 16);
    return ProShade::eval_type<ProShade::greaterThan_traits,int>(v10, (uint64_t)v5, a3);
  }
LABEL_16:
  uint64_t v11 = *(void *)(a2 + 16);

  return ProShade::eval_type<ProShade::greaterThan_traits,double>(v11, (uint64_t)v5, a3);
}

void virtual thunk to'ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::greaterThan_traits>>::~Func(void *a1)
{
  *(void *)(v1 + 72) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 88) = 0;
  uint64_t v2 = (PC_Sp_counted_base **)(v1 + 80);

  PCWeakCount::~PCWeakCount(v2);
}

{
  uint64_t v1;
  uint64_t vars8;

  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24);
  *(void *)(v1 + 72) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 88) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 80));

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::greaterThan_traits>>::Func(uint64_t a1, uint64_t a2, const ProShade::Node *a3)
{
  *(void *)(a1 + 72) = &unk_1F1199AC8;
  *(void *)(a1 + 80) = 0;
  *(unsigned char *)(a1 + 88) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F111EF68);
  *(void *)a1 = &unk_1F111EE90;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = &unk_1F111EF48;
  *(void *)(a1 + 48) = &unk_1F1119AF8;
  *(void *)(a1 + LiDepthSorter::stackSort((uint64_t)this + 56) = 0;
  ProShade::Node::copyFrom((ProShade::Node *)a1, a3);
  int v6 = *(_DWORD *)(a2 + 12);
  if (*(_DWORD *)(a1 + 56) >= v6) {
    int v7 = *(_DWORD *)(a1 + 56);
  }
  else {
    int v7 = (2 * v6) | 1;
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a1 + 48, v6, v7);
  if (*(int *)(a2 + 12) >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    do
    {
      ProShade::VarT<ProShade::Node>::operator=(*(void *)(a1 + 64) + v8, (const PCSharedCount *)(*(void *)(a2 + 16) + v8));
      ++v9;
      v8 += 32;
    }
    while (v9 < *(int *)(a2 + 12));
  }
  return a1;
}

void sub_1B7AB6EF0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 72) = v3;
  *(unsigned char *)(v1 + 88) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

void ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::lessThanEqual_traits>>::eval(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(const void **)(a1 + 16);
  if (v3) {
  else
  }
    int v4 = 0;
  uint64_t v5 = *(const void **)(a2 + 16);
  if (v5)
  {
    if (v4)
    {
      if (v6) {
        ProShade::ScalarFunctionTraits_2<ProShade::lessThanEqual_traits>::compute((uint64_t)v4, (uint64_t)v6);
      }
    }
  }
  PCSharedCount::PCSharedCount(&v7);
  operator new();
}

void sub_1B7AB70E4(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1 + 3);
  _Unwind_Resume(a1);
}

void ProShade::ScalarFunctionTraits_2<ProShade::lessThanEqual_traits>::compute(uint64_t a1, uint64_t a2)
{
  v8[18] = *MEMORY[0x1E4F143B8];
  ProShade::Value::Value(v8);
  ProShade::Value::Value(v7);
  ProShade::Value::Value(&v6);
  (*(void (**)(uint64_t, void *))(*(void *)a1 + 224))(a1, v8);
  (*(void (**)(uint64_t, void *))(*(void *)a2 + 224))(a2, v7);
  if (SLODWORD(v8[0]) > 1)
  {
    if (LODWORD(v8[0]) != 2) {
      goto LABEL_8;
    }
    int v4 = v7[0];
  }
  else
  {
    int v4 = v7[0];
    if (SLODWORD(v7[0]) < 2)
    {
      ProShade::eval_type<ProShade::lessThanEqual_traits,BOOL>((uint64_t)v8, (uint64_t)v7, &v6);
      goto LABEL_9;
    }
  }
  if (v4 <= 2)
  {
    ProShade::eval_type<ProShade::lessThanEqual_traits,int>((uint64_t)v8, (uint64_t)v7, &v6);
    goto LABEL_9;
  }
LABEL_8:
  ProShade::eval_type<ProShade::lessThanEqual_traits,double>((uint64_t)v8, (uint64_t)v7, &v6);
LABEL_9:
  ProShade::Const::create((ProShade::Const *)&v6, v5);
}

uint64_t ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::lessThanEqual_traits>>::Func(uint64_t a1, PCShared_base *a2, PCShared_base *a3)
{
  *(void *)(a1 + 72) = &unk_1F1199AC8;
  *(void *)(a1 + 80) = 0;
  *(unsigned char *)(a1 + 88) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F111F1E0);
  *(void *)a1 = &unk_1F111F108;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = &unk_1F111F1C0;
  *(void *)(a1 + 48) = &unk_1F1119AF8;
  *(void *)(a1 + LiDepthSorter::stackSort((uint64_t)this + 56) = 0;
  *(void *)(a1 + 24) = *((void *)a2 + 3);
  ProShade::VarT<ProShade::Node>::VarT(v13, a2);
  int v6 = *(_DWORD *)(a1 + 60);
  if (*(_DWORD *)(a1 + 56) <= v6) {
    int v7 = (2 * (v6 + 1)) | 1;
  }
  else {
    int v7 = *(_DWORD *)(a1 + 56);
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a1 + 48, v6 + 1, v7);
  ProShade::VarT<ProShade::Node>::operator=(*(void *)(a1 + 64) + 32 * *(int *)(a1 + 60) - 32, v13);
  v13[0].unint64_t var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(&v14);
  ProShade::VarT<ProShade::Node>::VarT(v13, a3);
  int v8 = *(_DWORD *)(a1 + 60);
  if (*(_DWORD *)(a1 + 56) <= v8) {
    int v9 = (2 * (v8 + 1)) | 1;
  }
  else {
    int v9 = *(_DWORD *)(a1 + 56);
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a1 + 48, v8 + 1, v9);
  ProShade::VarT<ProShade::Node>::operator=(*(void *)(a1 + 64) + 32 * *(int *)(a1 + 60) - 32, v13);
  v13[0].unint64_t var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(&v14);
  int v11 = *(_DWORD *)(a1 + 60);
  if (v11 < 1) {
    PCArray_base::badIndex(v10);
  }
  if (v11 <= 1) {
    PCArray_base::badIndex(v10);
  }
  ProShade::ScalarFunctionTraits_2<ProShade::equal_traits>::initType(a1, *(const PCString **)(a1 + 64), (const PCSharedCount *)(*(void *)(a1 + 64) + 32));
  ProShade::Node::setFrequency((ProShade::Node *)a1);
  if (*(_DWORD *)(a1 + 40) == 2 && *(int *)(a1 + 44) >= 3) {
    *(_DWORD *)(a1 + 40) = 3;
  }
  return a1;
}

void sub_1B7AB74BC(_Unwind_Exception *a1)
{
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::~PCArray(v4);
  ProShade::Node::~Node((ProShade::Node *)v1, (uint64_t *)(v5 + 8));
  *(void *)(v1 + 72) = v3;
  *(unsigned char *)(v1 + 88) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

uint64_t ProShade::eval_type<ProShade::lessThanEqual_traits,BOOL>(uint64_t a1, uint64_t a2, OZChannelBase *a3)
{
  ProShade::Value::set((uint64_t)a3, (const PCString *)1, *(_DWORD *)(a1 + 4));
  if (*(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4))
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v19, "not implemented yet");
    PCString::PCString(&v18, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/Shading/PSFunc.h");
    PCException::PCException(exception, &v19, &v18, 441);
    *(void *)exception = &unk_1F10B1208;
  }
  Serializer = OZChannelBase::getSerializer(a3);
  uint64_t result = ProShade::shapeGetSize(*(_DWORD *)(a1 + 4), v7);
  if ((int)result >= 1)
  {
    int v9 = (unsigned __int8 *)(a2 + 16);
    uint64_t v10 = (unsigned __int8 *)(a1 + 16);
    do
    {
      int v12 = *v10++;
      int v11 = v12;
      int v14 = *v9++;
      int v13 = v14;
      if (v11) {
        BOOL v15 = v13 == 0;
      }
      else {
        BOOL v15 = 0;
      }
      char v16 = !v15;
      *(unsigned char *)Serializer = v16;
      Serializer = (void ***)((char *)Serializer + 1);
      uint64_t result = (result - 1);
    }
    while (result);
  }
  return result;
}

void sub_1B7AB7654(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString((PCString *)&a9);
  PCString::~PCString(&a10);
  if (v11) {
    __cxa_free_exception(v10);
  }
  _Unwind_Resume(a1);
}

uint64_t ProShade::eval_type<ProShade::lessThanEqual_traits,int>(uint64_t a1, uint64_t a2, OZChannelBase *a3)
{
  ProShade::Value::set((uint64_t)a3, (const PCString *)1, *(_DWORD *)(a1 + 4));
  if (*(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4))
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v16, "not implemented yet");
    PCString::PCString(&v15, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/Shading/PSFunc.h");
    PCException::PCException(exception, &v16, &v15, 441);
    *(void *)exception = &unk_1F10B1208;
  }
  Serializer = OZChannelBase::getSerializer(a3);
  uint64_t result = ProShade::shapeGetSize(*(_DWORD *)(a1 + 4), v7);
  if ((int)result >= 1)
  {
    int v9 = (int *)(a2 + 16);
    uint64_t v10 = (int *)(a1 + 16);
    do
    {
      int v12 = *v10++;
      int v11 = v12;
      int v13 = *v9++;
      *(unsigned char *)Serializer = v11 <= v13;
      Serializer = (void ***)((char *)Serializer + 1);
      uint64_t result = (result - 1);
    }
    while (result);
  }
  return result;
}

void sub_1B7AB77B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString((PCString *)&a9);
  PCString::~PCString(&a10);
  if (v11) {
    __cxa_free_exception(v10);
  }
  _Unwind_Resume(a1);
}

uint64_t ProShade::eval_type<ProShade::lessThanEqual_traits,double>(uint64_t a1, uint64_t a2, OZChannelBase *a3)
{
  ProShade::Value::set((uint64_t)a3, (const PCString *)1, *(_DWORD *)(a1 + 4));
  if (*(_DWORD *)(a1 + 4) != *(_DWORD *)(a2 + 4))
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v16, "not implemented yet");
    PCString::PCString(&v15, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/Shading/PSFunc.h");
    PCException::PCException(exception, &v16, &v15, 441);
    *(void *)exception = &unk_1F10B1208;
  }
  Serializer = OZChannelBase::getSerializer(a3);
  uint64_t result = ProShade::shapeGetSize(*(_DWORD *)(a1 + 4), v7);
  if ((int)result >= 1)
  {
    int v9 = (double *)(a2 + 16);
    uint64_t v10 = (double *)(a1 + 16);
    do
    {
      double v11 = *v10++;
      double v12 = v11;
      double v13 = *v9++;
      *(unsigned char *)Serializer = v12 <= v13;
      Serializer = (void ***)((char *)Serializer + 1);
      uint64_t result = (result - 1);
    }
    while (result);
  }
  return result;
}

void sub_1B7AB7914(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  PCString::~PCString((PCString *)&a9);
  PCString::~PCString(&a10);
  if (v11) {
    __cxa_free_exception(v10);
  }
  _Unwind_Resume(a1);
}

uint64_t ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::lessThanEqual_traits>>::~Func(uint64_t a1)
{
  *(void *)(v2 + 72) = &unk_1F1199AC8;
  *(unsigned char *)(v2 + 88) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v2 + 80));
  return a1;
}

void ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::lessThanEqual_traits>>::~Func(uint64_t a1)
{
  *(void *)(v1 + 72) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 88) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 80));

  JUMPOUT(0x1BA9BFBA0);
}

void ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::lessThanEqual_traits>>::repr(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = a1 + 48;
  LiString::LiString((LiString *)&v5, "lessThanEqual");
  ProShade::func_repr((PCArray_base *)&v5, v3, a2);
  if (v5 && atomic_fetch_add(v5 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)uint64_t v5 = 0;
    if (v5) {
      uint64_t v4 = v5 - 3;
    }
    else {
      uint64_t v4 = 0;
    }
    free(v4);
  }
}

void sub_1B7AB7AB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    ProShade::VertexProgram::VertexProgram(a10);
  }
  _Unwind_Resume(exception_object);
}

void ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::lessThanEqual_traits>>::description(void *a1@<X8>)
{
  LiString::LiString((LiString *)&v7, "Func ");
  uint64_t v2 = v7;
  if (v7) {
    int v3 = *((_DWORD *)v7 - 2);
  }
  else {
    int v3 = 0;
  }
  size_t v4 = v3;
  uint64_t v5 = (unsigned int *)malloc_type_malloc(v3 + 26, 0x8903763CuLL);
  v5[1] = v4 + 13;
  v5[2] = v4 + 14;
  atomic_store(1u, v5);
  atomic_store(0, v5);
  memcpy(v5 + 3, v2, v4);
  qmemcpy((char *)v5 + v4 + 12, "lessThanEqual", 13);
  *((unsigned char *)v5 + v4 + 25) = 0;
  *a1 = v5 + 3;
  atomic_fetch_add((atomic_uint *volatile)v5, 1u);
  if (v7 && atomic_fetch_add((atomic_uint *volatile)v7 - 3, 0xFFFFFFFF) == 1)
  {
    *int v7 = 0;
    if (v7) {
      int v6 = v7 - 12;
    }
    else {
      int v6 = 0;
    }
    free(v6);
  }
}

void sub_1B7AB7BD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    ProShade::VertexProgram::VertexProgram(a10);
  }
  _Unwind_Resume(exception_object);
}

void ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::lessThanEqual_traits>>::shortDescription(LiString *a1@<X8>)
{
}

int8x8_t *ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::lessThanEqual_traits>>::computeHash(uint64_t a1, int8x8_t *this)
{
  PCHashWriteStream::writeValue(this, "Func");
  uint64_t result = PCHashWriteStream::writeValue(this, "lessThanEqual");
  if (*(int *)(a1 + 60) >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    do
    {
      ProShade::VarT<ProShade::Node>::hash(*(void *)(a1 + 64) + v5, &v7);
      uint64_t result = PCHashWriteStream::writeValue(this, (const PCHash128 *)&v7);
      ++v6;
      v5 += 32;
    }
    while (v6 < *(int *)(a1 + 60));
  }
  return result;
}

uint64_t ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::lessThanEqual_traits>>::apply@<X0>(uint64_t a1@<X0>, void (***a2)(PCSharedCount *__return_ptr, void, uint64_t)@<X1>, PCArray_base *a3@<X8>)
{
  size_t v4 = a3;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  PCString v19 = &unk_1F1119AF8;
  uint64_t v5 = *(unsigned int *)(a1 + 60);
  if ((int)v5 >= 1)
  {
    uint64_t v7 = 0;
    char v8 = 0;
    uint64_t v9 = 16;
    do
    {
      if (v7 >= *(int *)(a1 + 60)) {
        PCArray_base::badIndex(v4);
      }
      uint64_t v10 = *(void *)(a1 + 64);
      (**a2)(v17, a2, v10 + v9 - 16);
      unint64_t var0 = v17[2].var0;
      double v12 = *(PC_Sp_counted_base **)(v10 + v9);
      if ((int)v20 <= SHIDWORD(v20)) {
        int v13 = (2 * (HIDWORD(v20) + 1)) | 1;
      }
      else {
        int v13 = v20;
      }
      PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize((uint64_t)&v19, HIDWORD(v20) + 1, v13);
      ProShade::VarT<ProShade::Node>::operator=(v21 + 32 * SHIDWORD(v20) - 32, v17);
      v8 |= var0 != v12;
      v17[0].unint64_t var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
      PCSharedCount::~PCSharedCount(&v18);
      ++v7;
      v9 += 32;
    }
    while (v5 != v7);
    if (v8) {
      operator new();
    }
    size_t v4 = a3;
  }
  ProShade::VarT<ProShade::Node>::VarT((PCSharedCount *)v4, (PCShared_base *)a1);
  PCString v19 = &unk_1F1119AF8;
  if ((int)v20 < 0) {
    int v14 = 1;
  }
  else {
    int v14 = v20;
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize((uint64_t)&v19, 0, v14);
  uint64_t result = v21;
  if (v21) {
    return MEMORY[0x1BA9BFB70](v21, 0x1000C8077774924);
  }
  return result;
}

void sub_1B7AB7E80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  MEMORY[0x1BA9BFBA0](v8, 0x10B1C40241F72B2);
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::~PCArray((uint64_t)va);
  _Unwind_Resume(a1);
}

void ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::lessThanEqual_traits>>::clone()
{
}

void sub_1B7AB8038(_Unwind_Exception *a1)
{
  *(void *)(v1 + 72) = v2;
  *(unsigned char *)(v1 + 88) = 0;
  PCWeakCount::~PCWeakCount(v3);
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C40241F72B2);
  _Unwind_Resume(a1);
}

uint64_t ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::lessThanEqual_traits>>::computeValue(PCArray_base *a1, uint64_t a2, OZChannelBase *a3)
{
  int v4 = *(_DWORD *)(a2 + 12);
  if (v4 < 1) {
    PCArray_base::badIndex(a1);
  }
  if (v4 <= 1) {
    PCArray_base::badIndex(a1);
  }
  uint64_t v5 = (int *)(*(void *)(a2 + 16) + 144);
  int v6 = **(_DWORD **)(a2 + 16);
  if (v6 > 1)
  {
    if (v6 != 2) {
      goto LABEL_16;
    }
    int v7 = *v5;
  }
  else
  {
    int v7 = *v5;
    if (*v5 < 2)
    {
      uint64_t v8 = *(void *)(a2 + 16);
      return ProShade::eval_type<ProShade::lessThanEqual_traits,BOOL>(v8, (uint64_t)v5, a3);
    }
  }
  if (v7 <= 2)
  {
    uint64_t v10 = *(void *)(a2 + 16);
    return ProShade::eval_type<ProShade::lessThanEqual_traits,int>(v10, (uint64_t)v5, a3);
  }
LABEL_16:
  uint64_t v11 = *(void *)(a2 + 16);

  return ProShade::eval_type<ProShade::lessThanEqual_traits,double>(v11, (uint64_t)v5, a3);
}

void virtual thunk to'ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::lessThanEqual_traits>>::~Func(void *a1)
{
  *(void *)(v1 + 72) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 88) = 0;
  uint64_t v2 = (PC_Sp_counted_base **)(v1 + 80);

  PCWeakCount::~PCWeakCount(v2);
}

{
  uint64_t v1;
  uint64_t vars8;

  uint64_t v1 = (uint64_t)a1 + *(void *)(*a1 - 24);
  *(void *)(v1 + 72) = &unk_1F1199AC8;
  *(unsigned char *)(v1 + 88) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(v1 + 80));

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t ProShade::Func<ProShade::ScalarFunctionTraits_2<ProShade::lessThanEqual_traits>>::Func(uint64_t a1, uint64_t a2, const ProShade::Node *a3)
{
  *(void *)(a1 + 72) = &unk_1F1199AC8;
  *(void *)(a1 + 80) = 0;
  *(unsigned char *)(a1 + 88) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F111F1E0);
  *(void *)a1 = &unk_1F111F108;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = &unk_1F111F1C0;
  *(void *)(a1 + 48) = &unk_1F1119AF8;
  *(void *)(a1 + LiDepthSorter::stackSort((uint64_t)this + 56) = 0;
  ProShade::Node::copyFrom((ProShade::Node *)a1, a3);
  int v6 = *(_DWORD *)(a2 + 12);
  if (*(_DWORD *)(a1 + 56) >= v6) {
    int v7 = *(_DWORD *)(a1 + 56);
  }
  else {
    int v7 = (2 * v6) | 1;
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a1 + 48, v6, v7);
  if (*(int *)(a2 + 12) >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    do
    {
      ProShade::VarT<ProShade::Node>::operator=(*(void *)(a1 + 64) + v8, (const PCSharedCount *)(*(void *)(a2 + 16) + v8));
      ++v9;
      v8 += 32;
    }
    while (v9 < *(int *)(a2 + 12));
  }
  return a1;
}

void sub_1B7AB83B0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 72) = v3;
  *(unsigned char *)(v1 + 88) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

void PCArray<double,PCArray_Traits<double>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111F378;
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2 < 0) {
    int v3 = 1;
  }
  else {
    int v3 = v2 & ~(v2 >> 31);
  }
  if (v3 == v2)
  {
    uint64_t v4 = *(int *)(a1 + 12);
    uint64_t v5 = *(void *)(a1 + 16);
    if ((v4 & 0x80000000) != 0) {
      bzero((void *)(v5 + 8 * v4), 8 * ~v4 + 8);
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    uint64_t v5 = 0;
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6) {
      MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = 0;
  if (v5) {
    MEMORY[0x1BA9BFB70](v5, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

void PCArray<double,PCArray_Traits<double>>::resize(uint64_t a1, int a2, int a3)
{
  if (a3 <= a2) {
    int v3 = a2;
  }
  else {
    int v3 = a3;
  }
  if (a2 < 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v15, "PCArray::resize");
    PCException::PCException(exception, &v15);
    *(void *)exception = &unk_1F1199218;
  }
  if (v3 == *(_DWORD *)(a1 + 8))
  {
    uint64_t v6 = *(int *)(a1 + 12);
    if ((int)v6 < a2) {
      bzero((void *)(*(void *)(a1 + 16) + 8 * v6), 8 * (~v6 + a2) + 8);
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    int v7 = *(_DWORD *)(a1 + 12);
    if (a2 >= v7) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = a2;
    }
    if ((int)v8 < 1)
    {
      LODWORD(v8) = 0;
    }
    else
    {
      uint64_t v9 = *(uint64_t **)(a1 + 16);
      uint64_t v10 = v8;
      uint64_t v11 = 0;
      do
      {
        uint64_t v12 = *v9++;
        *v11++ = v12;
        --v10;
      }
      while (v10);
    }
    if ((int)v8 > v7) {
      int v7 = v8;
    }
    if (v7 < a2) {
      bzero((void *)(8 * v7), 8 * (~v7 + a2) + 8);
    }
    uint64_t v13 = *(void *)(a1 + 16);
    if (v13) {
      MEMORY[0x1BA9BFB70](v13, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = a2;
}

void sub_1B7AB86B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void PCArray<BOOL,PCArray_Traits<BOOL>>::~PCArray(uint64_t a1)
{
  *(void *)a1 = &unk_1F111F3B0;
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2 < 0) {
    int v3 = 1;
  }
  else {
    int v3 = v2 & ~(v2 >> 31);
  }
  if (v3 == v2)
  {
    uint64_t v4 = *(int *)(a1 + 12);
    uint64_t v5 = *(void *)(a1 + 16);
    if ((v4 & 0x80000000) != 0) {
      bzero((void *)(v5 + v4), ~v4 + 1);
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    uint64_t v5 = 0;
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6) {
      MEMORY[0x1BA9BFB70](v6, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = 0;
  if (v5) {
    MEMORY[0x1BA9BFB70](v5, 0x1000C8077774924);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 8) = 0;

  JUMPOUT(0x1BA9BFBA0);
}

void PCArray<BOOL,PCArray_Traits<BOOL>>::resize(uint64_t a1, int a2, int a3)
{
  if (a3 <= a2) {
    int v3 = a2;
  }
  else {
    int v3 = a3;
  }
  if (a2 < 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v15, "PCArray::resize");
    PCException::PCException(exception, &v15);
    *(void *)exception = &unk_1F1199218;
  }
  if (v3 == *(_DWORD *)(a1 + 8))
  {
    uint64_t v6 = *(int *)(a1 + 12);
    if ((int)v6 < a2) {
      bzero((void *)(*(void *)(a1 + 16) + v6), (~v6 + a2) + 1);
    }
  }
  else
  {
    if (v3) {
      operator new[]();
    }
    int v7 = *(_DWORD *)(a1 + 12);
    if (a2 >= v7) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = a2;
    }
    if ((int)v8 < 1)
    {
      LODWORD(v8) = 0;
    }
    else
    {
      uint64_t v9 = *(char **)(a1 + 16);
      uint64_t v10 = v8;
      uint64_t v11 = 0;
      do
      {
        char v12 = *v9++;
        *v11++ = v12;
        --v10;
      }
      while (v10);
    }
    if ((int)v8 > v7) {
      int v7 = v8;
    }
    if (v7 < a2) {
      bzero((void *)v7, (~v7 + a2) + 1);
    }
    uint64_t v13 = *(void *)(a1 + 16);
    if (v13) {
      MEMORY[0x1BA9BFB70](v13, 0x1000C8077774924);
    }
    *(void *)(a1 + 16) = 0;
  }
  *(_DWORD *)(a1 + 8) = v3;
  *(_DWORD *)(a1 + 12) = a2;
}

void sub_1B7AB8998(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

void ProShade::UnaryOp<ProShade::Negate>::computeUnary(_DWORD *a1)
{
  int v1 = a1[6];
  if (v1 <= 1)
  {
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    uint64_t v15 = 0;
    PCString v16 = &unk_1F111F3B0;
    uint64_t v13 = &unk_1F111F3B0;
    uint64_t v14 = 0;
    (*(void (**)(_DWORD *, void **))(*(void *)a1 + 200))(a1, &v16);
    if (SHIDWORD(v17) < 1) {
      ProShade::Const::create();
    }
    ProShade::Error<PCIllegalArgumentException>::raise<char [33]>((OZChannelBase *)"- operator doesn't apply to BOOL", v2);
  }
  if (v1 == 2)
  {
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    uint64_t v15 = 0;
    PCString v16 = &unk_1F10AD630;
    uint64_t v13 = &unk_1F10AD630;
    uint64_t v14 = 0;
    int v3 = (PCArray_base *)(*(uint64_t (**)(_DWORD *, void **))(*(void *)a1 + 208))(a1, &v16);
    uint64_t v4 = HIDWORD(v17);
    if (SHIDWORD(v17) >= 1)
    {
      uint64_t v5 = 0;
      do
      {
        if (v5 >= SHIDWORD(v17)) {
          PCArray_base::badIndex(v3);
        }
        int v6 = *(_DWORD *)(v18 + 4 * v5);
        if ((int)v14 <= SHIDWORD(v14)) {
          int v7 = (2 * (HIDWORD(v14) + 1)) | 1;
        }
        else {
          int v7 = v14;
        }
        PCArray<int,PCArray_Traits<int>>::resize((uint64_t)&v13, HIDWORD(v14) + 1, v7);
        *(_DWORD *)(v15 + 4 * SHIDWORD(v14) - 4) = -v6;
        ++v5;
      }
      while (v4 != v5);
    }
    ProShade::Const::create();
  }
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v15 = 0;
  PCString v16 = &unk_1F111F378;
  uint64_t v13 = &unk_1F111F378;
  uint64_t v14 = 0;
  uint64_t v8 = (PCArray_base *)(*(uint64_t (**)(_DWORD *, void **))(*(void *)a1 + 216))(a1, &v16);
  uint64_t v9 = HIDWORD(v17);
  if (SHIDWORD(v17) >= 1)
  {
    uint64_t v10 = 0;
    do
    {
      if (v10 >= SHIDWORD(v17)) {
        PCArray_base::badIndex(v8);
      }
      double v11 = *(double *)(v18 + 8 * v10);
      if ((int)v14 <= SHIDWORD(v14)) {
        int v12 = (2 * (HIDWORD(v14) + 1)) | 1;
      }
      else {
        int v12 = v14;
      }
      PCArray<double,PCArray_Traits<double>>::resize((uint64_t)&v13, HIDWORD(v14) + 1, v12);
      *(double *)(v15 + 8 * SHIDWORD(v14) - 8) = -v11;
      ++v10;
    }
    while (v9 != v10);
  }
  ProShade::Const::create();
}

void sub_1B7AB9088(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
}

uint64_t ProShade::UnaryOp<ProShade::Negate>::UnaryOp(uint64_t a1, PCShared_base *a2)
{
  *(void *)(a1 + 80) = &unk_1F1199AC8;
  *(void *)(a1 + 88) = 0;
  *(unsigned char *)(a1 + 96) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F111F4C8);
  *(void *)a1 = &unk_1F111F3F0;
  *(void *)(a1 + 80) = &unk_1F111F4A8;
  ProShade::VarT<ProShade::Node>::VarT((PCSharedCount *)(a1 + 48), a2);
  *(void *)(a1 + 24) = *((void *)a2 + 3);
  uint64_t v4 = *(void *)(a1 + 64);
  if (!v4) {
    throw_PCNullPointerException(1);
  }
  int v5 = *(_DWORD *)(v4 + 40);
  if (*(_DWORD *)(a1 + 44) < v5) {
    int v5 = *(_DWORD *)(a1 + 44);
  }
  *(_DWORD *)(a1 + 40) = v5;
  return a1;
}

void sub_1B7AB91E8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 48) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(v1 + 72));
  ProShade::Node::~Node((ProShade::Node *)v1, (uint64_t *)(v4 + 8));
  *(void *)(v1 + 80) = v3;
  *(unsigned char *)(v1 + 96) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

void ProShade::Error<PCIllegalArgumentException>::raise<char [33]>(OZChannelBase *a1, const PCString *a2)
{
  OZChannelBase::setRangeName(a1, a2);
  exception = (PCException *)__cxa_allocate_exception(0x40uLL);
  PCString::PCString(&v4, (const char *)a1);
  PCException::PCException(exception, &v4);
  *(void *)exception = &unk_1F1199218;
}

void sub_1B7AB92C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
}

uint64_t ProShade::UnaryOp<ProShade::Negate>::~UnaryOp(uint64_t a1)
{
  *(void *)a1 = &unk_1F111F3F0;
  *(void *)(a1 + 80) = &unk_1F111F4A8;
  *(void *)(a1 + 48) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(a1 + 72));
  *(void *)a1 = off_1F111F508;
  *(void *)(a1 + 80) = off_1F111F5C0;
  LiString::dec((LiString *)(a1 + 32));
  *(void *)(a1 + 80) = &unk_1F1199AC8;
  *(unsigned char *)(a1 + 96) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(a1 + 88));
  return a1;
}

void ProShade::UnaryOp<ProShade::Negate>::~UnaryOp(uint64_t a1)
{
  *(void *)a1 = &unk_1F111F3F0;
  *(void *)(a1 + 80) = &unk_1F111F4A8;
  *(void *)(a1 + 48) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(a1 + 72));
  *(void *)a1 = off_1F111F508;
  *(void *)(a1 + 80) = off_1F111F5C0;
  LiString::dec((LiString *)(a1 + 32));
  *(void *)(a1 + 80) = &unk_1F1199AC8;
  *(unsigned char *)(a1 + 96) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(a1 + 88));

  JUMPOUT(0x1BA9BFBA0);
}

void ProShade::UnaryOp<ProShade::Negate>::repr(uint64_t a1@<X0>, void *a2@<X8>)
{
  ProShade::VarT<ProShade::Node>::repr(a1 + 48);
  if (v6) {
    int v3 = *((_DWORD *)v6 - 2);
  }
  else {
    int v3 = 0;
  }
  PCString v4 = (unsigned int *)malloc_type_malloc(v3 + 14, 0x8903763CuLL);
  uint64_t v5 = v3 + 1;
  v4[1] = v5;
  v4[2] = v3 + 2;
  atomic_store(1u, v4);
  atomic_store(0, v4);
  *((unsigned char *)v4 + 12) = 45;
  memcpy((char *)v4 + 13, v6, v3);
  *((unsigned char *)v4 + v5 + 12) = 0;
  *a2 = v4 + 3;
  atomic_fetch_add((atomic_uint *volatile)v4, 1u);
  if (v6)
  {
    if (atomic_fetch_add((atomic_uint *volatile)v6 - 3, 0xFFFFFFFF) == 1)
    {
      *int v6 = 0;
      free(v6 - 12);
    }
  }
}

void sub_1B7AB95F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    ProShade::VertexProgram::VertexProgram(a10);
  }
  _Unwind_Resume(exception_object);
}

void ProShade::UnaryOp<ProShade::Negate>::description(void *a1@<X8>)
{
  LiString::LiString((LiString *)&v8, "UnaryOp ");
  int v2 = v8;
  if (v8) {
    int v3 = *((_DWORD *)v8 - 2);
  }
  else {
    int v3 = 0;
  }
  size_t v4 = v3;
  uint64_t v5 = (unsigned int *)malloc_type_malloc(v3 + 14, 0x8903763CuLL);
  v5[1] = v4 + 1;
  v5[2] = v4 + 2;
  atomic_store(1u, v5);
  int v6 = v5 + 3;
  atomic_store(0, v5);
  memcpy(v5 + 3, v2, v4);
  *((unsigned char *)v6 + v4) = 45;
  *((unsigned char *)v6 + v4 + 1) = 0;
  *a1 = v5 + 3;
  atomic_fetch_add((atomic_uint *volatile)v5, 1u);
  if (v8 && atomic_fetch_add((atomic_uint *volatile)v8 - 3, 0xFFFFFFFF) == 1)
  {
    unsigned char *v8 = 0;
    if (v8) {
      int v7 = v8 - 12;
    }
    else {
      int v7 = 0;
    }
    free(v7);
  }
}

void sub_1B7AB9700(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    ProShade::VertexProgram::VertexProgram(a10);
  }
  _Unwind_Resume(exception_object);
}

void ProShade::UnaryOp<ProShade::Negate>::shortDescription(LiString *a1@<X8>)
{
}

int8x8_t *ProShade::UnaryOp<ProShade::Negate>::computeHash(uint64_t a1, int8x8_t *this)
{
  PCHashWriteStream::writeValue(this, "-");
  ProShade::VarT<ProShade::Node>::hash(a1 + 48, &v5);
  return PCHashWriteStream::writeValue(this, (const PCHash128 *)&v5);
}

uint64_t ProShade::UnaryOp<ProShade::Negate>::inputs(const PCSharedCount *a1, uint64_t a2)
{
  if (*(int *)(a2 + 8) < 0) {
    int v4 = 1;
  }
  else {
    int v4 = *(_DWORD *)(a2 + 8);
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a2, 0, v4);
  __n128 v5 = a1 + 6;
  int v6 = *(_DWORD *)(a2 + 12);
  if (*(_DWORD *)(a2 + 8) <= v6) {
    int v7 = (2 * (v6 + 1)) | 1;
  }
  else {
    int v7 = *(_DWORD *)(a2 + 8);
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a2, v6 + 1, v7);
  uint64_t v8 = *(void *)(a2 + 16) + 32 * *(int *)(a2 + 12) - 32;

  return ProShade::VarT<ProShade::Node>::operator=(v8, v5);
}

void ProShade::UnaryOp<ProShade::Negate>::apply(PCShared_base *a1@<X0>, void (***a2)(void *__return_ptr, void, uint64_t)@<X1>, PCSharedCount *a3@<X8>)
{
  (**a2)(v5, a2, (uint64_t)a1 + 48);
  if (v5[2] != *((void *)a1 + 8)) {
    operator new();
  }
  ProShade::VarT<ProShade::Node>::VarT(a3, a1);
  v5[0] = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount(&v6);
}

void sub_1B7AB98DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  MEMORY[0x1BA9BFBA0](v4, 0x10B1C40515157B5);
  PCSharedCount::~PCSharedCount((PCSharedCount *)va);
  _Unwind_Resume(a1);
}

void ProShade::UnaryOp<ProShade::Negate>::clone()
{
}

void sub_1B7AB998C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C40515157B5);
  _Unwind_Resume(a1);
}

void ***ProShade::UnaryOp<ProShade::Negate>::computeValue(PCArray_base *a1, uint64_t a2, PCString *a3)
{
  if (*(int *)(a2 + 12) <= 0) {
    PCArray_base::badIndex(a1);
  }
  int v3 = *(const PCString **)(a2 + 16);

  return ProShade::UnaryOp<ProShade::Negate>::computeUnary(v3, a3);
}

void virtual thunk to'ProShade::UnaryOp<ProShade::Negate>::~UnaryOp(void *a1)
{
  uint64_t v1 = (PCSharedCount *)((char *)a1 + *(void *)(*a1 - 24));
  v1->unint64_t var0 = (PC_Sp_counted_base *)&unk_1F111F3F0;
  v1[10].unint64_t var0 = (PC_Sp_counted_base *)&unk_1F111F4A8;
  v1[6].unint64_t var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v1 + 9);
  v1->unint64_t var0 = (PC_Sp_counted_base *)off_1F111F508;
  v1[10].unint64_t var0 = (PC_Sp_counted_base *)off_1F111F5C0;
  LiString::dec((LiString *)&v1[4]);
  v1[10].unint64_t var0 = (PC_Sp_counted_base *)&unk_1F1199AC8;
  LOBYTE(v1[12].var0) = 0;

  PCWeakCount::~PCWeakCount(&v1[11].var0);
}

{
  PCSharedCount *v1;
  uint64_t vars8;

  uint64_t v1 = (PCSharedCount *)((char *)a1 + *(void *)(*a1 - 24));
  v1->unint64_t var0 = (PC_Sp_counted_base *)&unk_1F111F3F0;
  v1[10].unint64_t var0 = (PC_Sp_counted_base *)&unk_1F111F4A8;
  v1[6].unint64_t var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v1 + 9);
  v1->unint64_t var0 = (PC_Sp_counted_base *)off_1F111F508;
  v1[10].unint64_t var0 = (PC_Sp_counted_base *)off_1F111F5C0;
  LiString::dec((LiString *)&v1[4]);
  v1[10].unint64_t var0 = (PC_Sp_counted_base *)&unk_1F1199AC8;
  LOBYTE(v1[12].var0) = 0;
  PCWeakCount::~PCWeakCount(&v1[11].var0);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t ProShade::UnaryOp<ProShade::Negate>::UnaryOp(uint64_t a1, PCShared_base *a2, int a3)
{
  *(void *)(a1 + 80) = &unk_1F1199AC8;
  *(void *)(a1 + 88) = 0;
  *(unsigned char *)(a1 + 96) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F111F4C8);
  *(void *)a1 = &unk_1F111F3F0;
  *(void *)(a1 + 80) = &unk_1F111F4A8;
  ProShade::VarT<ProShade::Node>::VarT((PCSharedCount *)(a1 + 48), a2);
  *(void *)(a1 + 24) = *((void *)a2 + 3);
  *(_DWORD *)(a1 + 44) = a3;
  uint64_t v6 = *(void *)(a1 + 64);
  if (!v6) {
    throw_PCNullPointerException(1);
  }
  int v7 = *(_DWORD *)(v6 + 40);
  if (a3 < v7) {
    int v7 = a3;
  }
  *(_DWORD *)(a1 + 40) = v7;
  return a1;
}

void sub_1B7AB9D34(_Unwind_Exception *a1)
{
  *(void *)(v1 + 48) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(v1 + 72));
  ProShade::Node::~Node((ProShade::Node *)v1, (uint64_t *)(v4 + 8));
  *(void *)(v1 + 80) = v3;
  *(unsigned char *)(v1 + 96) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

uint64_t ProShade::UnaryOp<ProShade::Negate>::UnaryOp(uint64_t a1)
{
  *(void *)(a1 + 80) = &unk_1F1199AC8;
  *(void *)(a1 + 88) = 0;
  *(unsigned char *)(a1 + 96) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F111F4C8);
  *(void *)a1 = &unk_1F111F3F0;
  *(void *)(a1 + 80) = &unk_1F111F4A8;
  *(void *)(a1 + 48) = &unk_1F11193B8;
  *(void *)(a1 + 64) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 72));
  return a1;
}

void sub_1B7AB9E6C(_Unwind_Exception *a1)
{
  uint64_t v5 = v4;
  ProShade::Node::~Node((ProShade::Node *)v1, (uint64_t *)(v5 + 8));
  *(void *)(v1 + 80) = v3;
  *(unsigned char *)(v1 + 96) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

void ***ProShade::UnaryOp<ProShade::Negate>::computeUnary(const PCString *a1, PCString *a2)
{
  if (LODWORD(a1->var0) == 2) {
    return ProShade::computeUnaryType<ProShade::Negate,int>(a1, a2);
  }
  if (LODWORD(a1->var0) == 1) {
    return ProShade::computeUnaryType<ProShade::Negate,BOOL>(a1, a2);
  }
  return ProShade::computeUnaryType<ProShade::Negate,double>(a1, a2);
}

void ***ProShade::computeUnaryType<ProShade::Negate,BOOL>(const PCString *a1, PCString *a2)
{
  v12[1] = *MEMORY[0x1E4F143B8];
  uint64_t Size = ProShade::shapeGetSize(HIDWORD(a1->var0), a2);
  int v5 = Size;
  var0_low = (void *)LODWORD(a1->var0);
  if (var0_low != 1)
  {
    MEMORY[0x1F4188790](Size);
    uint64_t v8 = (BOOL *)v12 - v7;
    bzero((char *)v12 - v7, v9);
    ProShade::copyData(var0_low, a1 + 2, 1, v8, v5);
  }
  ProShade::Value::set((uint64_t)a2, (const PCString *)1, HIDWORD(a1->var0));
  uint64_t result = OZChannelBase::getSerializer((OZChannelBase *)a2);
  if (v5 > 0) {
    ProShade::Error<PCIllegalArgumentException>::raise<char [33]>((OZChannelBase *)"- operator doesn't apply to BOOL", v11);
  }
  return result;
}

void ***ProShade::computeUnaryType<ProShade::Negate,int>(const PCString *a1, PCString *a2)
{
  v14[1] = *MEMORY[0x1E4F143B8];
  uint64_t Size = ProShade::shapeGetSize(HIDWORD(a1->var0), a2);
  int v5 = Size;
  var0_low = (void *)LODWORD(a1->var0);
  if (var0_low != 2)
  {
    MEMORY[0x1F4188790](Size);
    uint64_t v8 = (BOOL *)v14 - v7;
    bzero((char *)v14 - v7, v9);
    ProShade::copyData(var0_low, a1 + 2, 2, v8, v5);
  }
  ProShade::Value::set((uint64_t)a2, (const PCString *)2, HIDWORD(a1->var0));
  uint64_t result = OZChannelBase::getSerializer((OZChannelBase *)a2);
  if (v5 >= 1)
  {
    double v11 = a1 + 2;
    uint64_t v12 = v5;
    do
    {
      int var0 = (int)v11->var0;
      double v11 = (const PCString *)((char *)v11 + 4);
      *(_DWORD *)uint64_t result = -var0;
      uint64_t result = (void ***)((char *)result + 4);
      --v12;
    }
    while (v12);
  }
  return result;
}

void ***ProShade::computeUnaryType<ProShade::Negate,double>(const PCString *a1, PCString *a2)
{
  v14[1] = *MEMORY[0x1E4F143B8];
  uint64_t Size = ProShade::shapeGetSize(HIDWORD(a1->var0), a2);
  int v5 = Size;
  var0_low = (void *)LODWORD(a1->var0);
  if (var0_low != 3)
  {
    MEMORY[0x1F4188790](Size);
    uint64_t v8 = (BOOL *)v14 - v7;
    bzero((char *)v14 - v7, v9);
    ProShade::copyData(var0_low, a1 + 2, 3, v8, v5);
  }
  ProShade::Value::set((uint64_t)a2, (const PCString *)3, HIDWORD(a1->var0));
  uint64_t result = OZChannelBase::getSerializer((OZChannelBase *)a2);
  if (v5 >= 1)
  {
    double v11 = (double *)&a1[2];
    uint64_t v12 = v5;
    do
    {
      double v13 = *v11++;
      *(double *)result++ = -v13;
      --v12;
    }
    while (v12);
  }
  return result;
}

double ProShade::BinaryOp<ProShade::Add>::computeBinary(const PCString *a1, const PCString *a2, uint64_t a3)
{
  if (SLODWORD(a1->var0) > 1)
  {
    if (LODWORD(a1->var0) != 2) {
      return ProShade::computeBinaryType<ProShade::Add,double>((unsigned int *)a1, (unsigned int *)a2, a3);
    }
    int var0 = (int)a2->var0;
  }
  else
  {
    int var0 = (int)a2->var0;
    if (SLODWORD(a2->var0) < 2)
    {
      ProShade::computeBinaryType<ProShade::Add,BOOL>(a1, a2, a3);
      return result;
    }
  }
  if (var0 <= 2)
  {
    ProShade::computeBinaryType<ProShade::Add,int>((unsigned int *)a1, (unsigned int *)a2, a3);
    return result;
  }
  return ProShade::computeBinaryType<ProShade::Add,double>((unsigned int *)a1, (unsigned int *)a2, a3);
}

BOOL ProShade::Add::simplify(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = (const PCSharedCount *)a1;
  if (ProShade::isZero(a1))
  {
    int v5 = (const PCSharedCount *)a2;
  }
  else
  {
    BOOL result = ProShade::isZero(a2);
    if (!result) {
      return result;
    }
  }
  ProShade::VarT<ProShade::Node>::operator=(a3, v5);
  return 1;
}

uint64_t ProShade::BinaryOp<ProShade::Add>::BinaryOp(uint64_t a1, PCShared_base *a2, PCShared_base *a3)
{
  *(void *)(a1 + 112) = &unk_1F1199AC8;
  *(void *)(a1 + 120) = 0;
  *(unsigned char *)(a1 + 128) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F111F740);
  *(void *)a1 = &unk_1F111F668;
  *(void *)(a1 + 112) = &unk_1F111F720;
  ProShade::VarT<ProShade::Node>::VarT((PCSharedCount *)(a1 + 48), a2);
  ProShade::VarT<ProShade::Node>::VarT((PCSharedCount *)(a1 + 80), a3);
  int v7 = *((_DWORD *)a2 + 7);
  int v8 = *((_DWORD *)a3 + 7);
  if (v7 != 1)
  {
    if (v8 == 1)
    {
      int v8 = *((_DWORD *)a2 + 7);
    }
    else
    {
      BOOL v9 = v7 == v8;
      int v8 = *((_DWORD *)a2 + 7);
      if (!v9) {
        ProShade::Error<PCIllegalArgumentException>::raise<char [33]>((OZChannelBase *)"vector size mismatch", v6);
      }
    }
  }
  int v10 = *((_DWORD *)a2 + 6);
  if (v10 <= *((_DWORD *)a3 + 6)) {
    int v10 = *((_DWORD *)a3 + 6);
  }
  *(_DWORD *)(a1 + 24) = v10;
  *(_DWORD *)(a1 + 28) = v8;
  ProShade::BinaryOp<ProShade::Add>::setFrequency(a1);
  return a1;
}

void sub_1B7ABA390(_Unwind_Exception *a1)
{
  *(void *)(v1 + 48) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(v1 + 72));
  ProShade::Node::~Node((ProShade::Node *)v1, (uint64_t *)(v4 + 8));
  *(void *)(v1 + 112) = v3;
  *(unsigned char *)(v1 + 128) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

BOOL ProShade::computeBinaryType<ProShade::Add,BOOL>(const PCString *a1, const PCString *a2, uint64_t a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  int Size = ProShade::shapeGetSize(HIDWORD(a1->var0), a2);
  uint64_t v8 = ProShade::shapeGetSize(HIDWORD(a2->var0), v7);
  int v10 = v8;
  var0_low = (void *)LODWORD(a1->var0);
  if (var0_low != 1)
  {
    MEMORY[0x1F4188790](v8);
    double v13 = (BOOL *)&v24 - v12;
    bzero((char *)&v24 - v12, v14);
    uint64_t v8 = (uint64_t)ProShade::copyData(var0_low, a1 + 2, 1, v13, Size);
  }
  uint64_t v15 = (void *)LODWORD(a2->var0);
  if (v15 != 1)
  {
    MEMORY[0x1F4188790](v8);
    uint64_t v17 = (BOOL *)&v24 - v16;
    bzero((char *)&v24 - v16, v18);
    ProShade::copyData(v15, a2 + 2, 1, v17, v10);
  }
  int var0_high = HIDWORD(a1->var0);
  if (var0_high != HIDWORD(a2->var0)) {
    ProShade::Error<PCException>::raise<char [27]>((OZChannelBase *)"mismatched operator inputs", v9);
  }
  ProShade::Value::set(a3, (const PCString *)1, var0_high);
  BOOL result = ProShade::shapeIsVector(HIDWORD(a1->var0));
  int v22 = HIDWORD(a1->var0) == 1 || result;
  if (v22 != 1)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v26, "not implemented yet");
    PCString::PCString(&v25, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/Shading/PSOp.cpp");
    PCException::PCException(exception, &v26, &v25, 426);
    *(void *)exception = &unk_1F10B1208;
  }
  if (Size >= 1) {
    ProShade::Error<PCIllegalArgumentException>::raise<char [33]>((OZChannelBase *)"+ operator doesn't apply to BOOL", v21);
  }
  return result;
}

void sub_1B7ABA63C(_Unwind_Exception *a1)
{
  PCString::~PCString((PCString *)(v3 - 88));
  PCString::~PCString((PCString *)(v3 - 80));
  if (v2) {
    __cxa_free_exception(v1);
  }
  _Unwind_Resume(a1);
}

BOOL ProShade::computeBinaryType<ProShade::Add,int>(unsigned int *a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  int Size = ProShade::shapeGetSize(a1[1], (const PCString *)a2);
  uint64_t v8 = ProShade::shapeGetSize(a2[1], v7);
  int v10 = v8;
  double v11 = (void *)*a1;
  if (v11 == 2)
  {
    uint64_t v12 = (BOOL *)(a1 + 4);
  }
  else
  {
    MEMORY[0x1F4188790](v8);
    uint64_t v12 = (BOOL *)&v28 - v13;
    bzero((char *)&v28 - v13, v14);
    uint64_t v8 = (uint64_t)ProShade::copyData(v11, (const PCString *)a1 + 2, 2, v12, Size);
  }
  uint64_t v15 = (void *)*a2;
  if (v15 == 2)
  {
    uint64_t v16 = (BOOL *)(a2 + 4);
  }
  else
  {
    MEMORY[0x1F4188790](v8);
    uint64_t v16 = (BOOL *)&v28 - v17;
    bzero((char *)&v28 - v17, v18);
    ProShade::copyData(v15, (const PCString *)a2 + 2, 2, v16, v10);
  }
  int v19 = a1[1];
  if (v19 != a2[1]) {
    ProShade::Error<PCException>::raise<char [27]>((OZChannelBase *)"mismatched operator inputs", v9);
  }
  ProShade::Value::set(a3, (const PCString *)2, v19);
  BOOL result = ProShade::shapeIsVector(a1[1]);
  int v21 = a1[1] == 1 || result;
  if (v21 != 1)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v30, "not implemented yet");
    PCString::PCString(&v29, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/Shading/PSOp.cpp");
    PCException::PCException(exception, &v30, &v29, 426);
    *(void *)exception = &unk_1F10B1208;
  }
  if (Size >= 1)
  {
    int v22 = (_DWORD *)(a3 + 16);
    uint64_t v23 = Size;
    do
    {
      int v25 = *(_DWORD *)v12;
      v12 += 4;
      int v24 = v25;
      int v26 = *(_DWORD *)v16;
      v16 += 4;
      *v22++ = v26 + v24;
      --v23;
    }
    while (v23);
  }
  return result;
}

void sub_1B7ABA8C8(_Unwind_Exception *a1)
{
  PCString::~PCString((PCString *)(v3 - 88));
  PCString::~PCString((PCString *)(v3 - 80));
  if (v2) {
    __cxa_free_exception(v1);
  }
  _Unwind_Resume(a1);
}

double ProShade::computeBinaryType<ProShade::Add,double>(unsigned int *a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  int Size = ProShade::shapeGetSize(a1[1], (const PCString *)a2);
  uint64_t v8 = ProShade::shapeGetSize(a2[1], v7);
  int v10 = v8;
  double v11 = (void *)*a1;
  if (v11 == 3)
  {
    uint64_t v12 = (BOOL *)(a1 + 4);
  }
  else
  {
    MEMORY[0x1F4188790](v8);
    uint64_t v12 = (BOOL *)&v29 - v13;
    bzero((char *)&v29 - v13, v14);
    uint64_t v8 = (uint64_t)ProShade::copyData(v11, (const PCString *)a1 + 2, 3, v12, Size);
  }
  uint64_t v15 = (void *)*a2;
  if (v15 == 3)
  {
    uint64_t v16 = (BOOL *)(a2 + 4);
  }
  else
  {
    MEMORY[0x1F4188790](v8);
    uint64_t v16 = (BOOL *)&v29 - v17;
    bzero((char *)&v29 - v17, v18);
    ProShade::copyData(v15, (const PCString *)a2 + 2, 3, v16, v10);
  }
  int v19 = a1[1];
  if (v19 != a2[1]) {
    ProShade::Error<PCException>::raise<char [27]>((OZChannelBase *)"mismatched operator inputs", v9);
  }
  ProShade::Value::set(a3, (const PCString *)3, v19);
  BOOL IsVector = ProShade::shapeIsVector(a1[1]);
  int v22 = a1[1] == 1 || IsVector;
  if (v22 != 1)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v31, "not implemented yet");
    PCString::PCString(&v30, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/Shading/PSOp.cpp");
    PCException::PCException(exception, &v31, &v30, 426);
    *(void *)exception = &unk_1F10B1208;
  }
  if (Size >= 1)
  {
    uint64_t v23 = (double *)(a3 + 16);
    uint64_t v24 = Size;
    do
    {
      double v25 = *(double *)v12;
      v12 += 8;
      double v26 = v25;
      double v27 = *(double *)v16;
      v16 += 8;
      double result = v26 + v27;
      *v23++ = result;
      --v24;
    }
    while (v24);
  }
  return result;
}

void sub_1B7ABAB54(_Unwind_Exception *a1)
{
  PCString::~PCString((PCString *)(v3 - 88));
  PCString::~PCString((PCString *)(v3 - 80));
  if (v2) {
    __cxa_free_exception(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t ProShade::BinaryOp<ProShade::Add>::setFrequency(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 64);
  if (!v1) {
    throw_PCNullPointerException(1);
  }
  int v2 = *(_DWORD *)(v1 + 40);
  uint64_t v3 = *(void *)(result + 96);
  if (!v3) {
    throw_PCNullPointerException(1);
  }
  int v4 = *(_DWORD *)(v3 + 40);
  if (v2 > v4) {
    int v4 = v2;
  }
  if (*(_DWORD *)(result + 44) < v4) {
    int v4 = *(_DWORD *)(result + 44);
  }
  *(_DWORD *)(result + 40) = v4;
  return result;
}

uint64_t ProShade::BinaryOp<ProShade::Add>::~BinaryOp(uint64_t a1)
{
  *(void *)a1 = &unk_1F111F668;
  *(void *)(a1 + 112) = &unk_1F111F720;
  *(void *)(a1 + 80) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(a1 + 104));
  *(void *)(a1 + 48) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(a1 + 72));
  *(void *)a1 = off_1F111F780;
  *(void *)(a1 + 112) = off_1F111F838;
  LiString::dec((LiString *)(a1 + 32));
  *(void *)(a1 + 112) = &unk_1F1199AC8;
  *(unsigned char *)(a1 + 128) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(a1 + 120));
  return a1;
}

void ProShade::BinaryOp<ProShade::Add>::~BinaryOp(uint64_t a1)
{
  *(void *)a1 = &unk_1F111F668;
  *(void *)(a1 + 112) = &unk_1F111F720;
  *(void *)(a1 + 80) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(a1 + 104));
  *(void *)(a1 + 48) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(a1 + 72));
  *(void *)a1 = off_1F111F780;
  *(void *)(a1 + 112) = off_1F111F838;
  LiString::dec((LiString *)(a1 + 32));
  *(void *)(a1 + 112) = &unk_1F1199AC8;
  *(unsigned char *)(a1 + 128) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(a1 + 120));

  JUMPOUT(0x1BA9BFBA0);
}

void ProShade::BinaryOp<ProShade::Add>::repr(uint64_t a1@<X0>, void *a2@<X8>)
{
  ProShade::VarT<ProShade::Node>::repr(a1 + 48);
  if (v28) {
    int v4 = *((_DWORD *)v28 - 2);
  }
  else {
    int v4 = 0;
  }
  int v5 = malloc_type_malloc(v4 + 14, 0x8903763CuLL);
  uint64_t v6 = v4 + 1;
  v5[2] = v4 + 2;
  atomic_store(1u, v5);
  atomic_store(0, v5);
  *((unsigned char *)v5 + 12) = 40;
  int v7 = v5 + 3;
  v5[1] = v6;
  memcpy((char *)v5 + 13, v28, v4);
  v7[v6] = 0;
  atomic_fetch_add(v5, 1u);
  double v26 = v5;
  size_t v8 = (int)v5[1];
  BOOL v9 = (unsigned int *)malloc_type_malloc(v8 + 14, 0x8903763CuLL);
  atomic_store(1u, v9);
  int v10 = v9 + 3;
  atomic_store(0, v9);
  v9[1] = v8 + 1;
  void v9[2] = v8 + 2;
  memcpy(v9 + 3, v7, v8);
  *((unsigned char *)v10 + v8) = 32;
  *((unsigned char *)v10 + v8 + 1) = 0;
  atomic_fetch_add((atomic_uint *volatile)v9, 1u);
  double v25 = v9;
  size_t v11 = (int)v9[1];
  uint64_t v12 = (unsigned int *)malloc_type_malloc(v11 + 14, 0x8903763CuLL);
  v12[1] = v11 + 1;
  void v12[2] = v11 + 2;
  atomic_store(1u, v12);
  uint64_t v13 = v12 + 3;
  atomic_store(0, v12);
  memcpy(v12 + 3, v9 + 3, v11);
  *((unsigned char *)v13 + v11) = 43;
  *((unsigned char *)v13 + v11 + 1) = 0;
  atomic_fetch_add((atomic_uint *volatile)v12, 1u);
  size_t v14 = (int)v12[1];
  uint64_t v15 = (unsigned int *)malloc_type_malloc(v14 + 14, 0x8903763CuLL);
  uint64_t v24 = a2;
  atomic_store(1u, v15);
  uint64_t v16 = v15 + 3;
  atomic_store(0, v15);
  v15[1] = v14 + 1;
  _OWORD v15[2] = v14 + 2;
  memcpy(v15 + 3, v12 + 3, v14);
  v16[v14] = 32;
  v16[v14 + 1] = 0;
  atomic_fetch_add((atomic_uint *volatile)v15, 1u);
  ProShade::VarT<ProShade::Node>::repr(a1 + 80);
  size_t v17 = (int)v15[1];
  if (v27) {
    int v18 = *((_DWORD *)v27 - 2);
  }
  else {
    int v18 = 0;
  }
  size_t v19 = v17 + v18;
  uint64_t v20 = (unsigned int *)malloc_type_malloc(v19 + 13, 0x8903763CuLL);
  v20[1] = v19;
  double v20[2] = v19 + 1;
  atomic_store(1u, v20);
  atomic_store(0, v20);
  memcpy(v20 + 3, v16, v17);
  memcpy((char *)v20 + v17 + 12, v27, v18);
  *((unsigned char *)v20 + v19 + 12) = 0;
  atomic_fetch_add((atomic_uint *volatile)v20, 1u);
  size_t v21 = (int)v20[1];
  int v22 = (unsigned int *)malloc_type_malloc(v21 + 14, 0x8903763CuLL);
  atomic_store(1u, v22);
  uint64_t v23 = v22 + 3;
  atomic_store(0, v22);
  v22[1] = v21 + 1;
  v22[2] = v21 + 2;
  memcpy(v22 + 3, v20 + 3, v21);
  *((unsigned char *)v23 + v21) = 41;
  *((unsigned char *)v23 + v21 + 1) = 0;
  void *v24 = v22 + 3;
  atomic_fetch_add((atomic_uint *volatile)v22, 1u);
  if (atomic_fetch_add((atomic_uint *volatile)v20, 0xFFFFFFFF) == 1) {
    free(v20);
  }
  if (v27 && atomic_fetch_add((atomic_uint *volatile)v27 - 3, 0xFFFFFFFF) == 1)
  {
    *double v27 = 0;
    free(v27 - 12);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v15, 0xFFFFFFFF) == 1) {
    free(v15);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v12, 0xFFFFFFFF) == 1) {
    free(v12);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v25, 0xFFFFFFFF) == 1) {
    free(v25);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v26, 0xFFFFFFFF) == 1) {
    free(v26);
  }
  if (v28)
  {
    if (atomic_fetch_add((atomic_uint *volatile)v28 - 3, 0xFFFFFFFF) == 1)
    {
      unsigned char *v28 = 0;
      free(v28 - 12);
    }
  }
}

void sub_1B7ABB1D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, atomic_uint *a13, atomic_uint *a14)
{
  if (atomic_fetch_add((atomic_uint *volatile)v16, 0xFFFFFFFF) == 1) {
    free(v16);
  }
  if (a13 && atomic_fetch_add(a13 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)a13 = 0;
    free(a13 - 3);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v15, 0xFFFFFFFF) == 1) {
    free(v15);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v14, 0xFFFFFFFF) == 1) {
    free(v14);
  }
  if (atomic_fetch_add((atomic_uint *volatile)a11, 0xFFFFFFFF) == 1) {
    free(a11);
  }
  if (atomic_fetch_add((atomic_uint *volatile)a12, 0xFFFFFFFF) == 1) {
    free(a12);
  }
  if (a14)
  {
    if (atomic_fetch_add(a14 - 3, 0xFFFFFFFF) == 1)
    {
      *(unsigned char *)a14 = 0;
      free(a14 - 3);
    }
  }
  _Unwind_Resume(exception_object);
}

void ProShade::BinaryOp<ProShade::Add>::description(void *a1@<X8>)
{
  LiString::LiString((LiString *)&v8, "BinaryOp ");
  int v2 = v8;
  if (v8) {
    int v3 = *((_DWORD *)v8 - 2);
  }
  else {
    int v3 = 0;
  }
  size_t v4 = v3;
  int v5 = (unsigned int *)malloc_type_malloc(v3 + 14, 0x8903763CuLL);
  v5[1] = v4 + 1;
  v5[2] = v4 + 2;
  atomic_store(1u, v5);
  uint64_t v6 = v5 + 3;
  atomic_store(0, v5);
  memcpy(v5 + 3, v2, v4);
  *((unsigned char *)v6 + v4) = 43;
  *((unsigned char *)v6 + v4 + 1) = 0;
  *a1 = v5 + 3;
  atomic_fetch_add((atomic_uint *volatile)v5, 1u);
  if (v8 && atomic_fetch_add((atomic_uint *volatile)v8 - 3, 0xFFFFFFFF) == 1)
  {
    unsigned char *v8 = 0;
    if (v8) {
      int v7 = v8 - 12;
    }
    else {
      int v7 = 0;
    }
    free(v7);
  }
}

void sub_1B7ABB3F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    ProShade::VertexProgram::VertexProgram(a10);
  }
  _Unwind_Resume(exception_object);
}

void ProShade::BinaryOp<ProShade::Add>::shortDescription(LiString *a1@<X8>)
{
}

int8x8_t *ProShade::BinaryOp<ProShade::Add>::computeHash(uint64_t a1, int8x8_t *this)
{
  PCHashWriteStream::writeValue(this, "+");
  ProShade::VarT<ProShade::Node>::hash(a1 + 48, &v5);
  PCHashWriteStream::writeValue(this, (const PCHash128 *)&v5);
  ProShade::VarT<ProShade::Node>::hash(a1 + 80, &v5);
  return PCHashWriteStream::writeValue(this, (const PCHash128 *)&v5);
}

uint64_t ProShade::BinaryOp<ProShade::Add>::inputs(const PCSharedCount *a1, uint64_t a2)
{
  if (*(int *)(a2 + 8) < 0) {
    int v4 = 1;
  }
  else {
    int v4 = *(_DWORD *)(a2 + 8);
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a2, 0, v4);
  int v5 = *(_DWORD *)(a2 + 12);
  if (*(_DWORD *)(a2 + 8) <= v5) {
    int v6 = (2 * (v5 + 1)) | 1;
  }
  else {
    int v6 = *(_DWORD *)(a2 + 8);
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a2, v5 + 1, v6);
  ProShade::VarT<ProShade::Node>::operator=(*(void *)(a2 + 16) + 32 * *(int *)(a2 + 12) - 32, a1 + 6);
  int v7 = a1 + 10;
  int v8 = *(_DWORD *)(a2 + 12);
  if (*(_DWORD *)(a2 + 8) <= v8) {
    int v9 = (2 * (v8 + 1)) | 1;
  }
  else {
    int v9 = *(_DWORD *)(a2 + 8);
  }
  PCArray<ProShade::VarT<ProShade::Node>,PCArray_Traits<ProShade::VarT<ProShade::Node>>>::resize(a2, v8 + 1, v9);
  uint64_t v10 = *(void *)(a2 + 16) + 32 * *(int *)(a2 + 12) - 32;

  return ProShade::VarT<ProShade::Node>::operator=(v10, v7);
}

void ProShade::BinaryOp<ProShade::Add>::apply(PCShared_base *a1@<X0>, void (***a2)(void *__return_ptr, void, uint64_t)@<X1>, PCSharedCount *a3@<X8>)
{
  (**a2)(v8, a2, (uint64_t)a1 + 48);
  (**a2)(v6, a2, (uint64_t)a1 + 80);
  if (v8[2] != *((void *)a1 + 8) || v6[2] != *((void *)a1 + 12)) {
    operator new();
  }
  ProShade::VarT<ProShade::Node>::VarT(a3, a1);
  v6[0] = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount(&v7);
  v8[0] = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount(&v9);
}

void sub_1B7ABB6A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v6.int var0 = va_arg(va1, PC_Sp_counted_base *);
  int v8 = va_arg(va1, void *);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  MEMORY[0x1BA9BFBA0](v4, 0x10B1C403815D87CLL);
  PCSharedCount::~PCSharedCount((PCSharedCount *)va);
  int v8 = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)va1);
  _Unwind_Resume(a1);
}

void ProShade::BinaryOp<ProShade::Add>::clone()
{
}

void sub_1B7ABB77C(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C403815D87CLL);
  _Unwind_Resume(a1);
}

double ProShade::BinaryOp<ProShade::Add>::computeValue(PCArray_base *a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(_DWORD *)(a2 + 12);
  if (v4 < 1) {
    PCArray_base::badIndex(a1);
  }
  if (v4 <= 1) {
    PCArray_base::badIndex(a1);
  }
  int v5 = (const PCString *)(*(void *)(a2 + 16) + 144);
  PCSharedCount v6 = *(const PCString **)(a2 + 16);

  return ProShade::BinaryOp<ProShade::Add>::computeBinary(v6, v5, a3);
}

void virtual thunk to'ProShade::BinaryOp<ProShade::Add>::~BinaryOp(void *a1)
{
  uint64_t v1 = (PCSharedCount *)((char *)a1 + *(void *)(*a1 - 24));
  v1->int var0 = (PC_Sp_counted_base *)&unk_1F111F668;
  v1[14].int var0 = (PC_Sp_counted_base *)&unk_1F111F720;
  v1[10].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v1 + 13);
  v1[6].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v1 + 9);
  v1->int var0 = (PC_Sp_counted_base *)off_1F111F780;
  v1[14].int var0 = (PC_Sp_counted_base *)off_1F111F838;
  LiString::dec((LiString *)&v1[4]);
  v1[14].int var0 = (PC_Sp_counted_base *)&unk_1F1199AC8;
  LOBYTE(v1[16].var0) = 0;

  PCWeakCount::~PCWeakCount(&v1[15].var0);
}

{
  PCSharedCount *v1;
  uint64_t vars8;

  uint64_t v1 = (PCSharedCount *)((char *)a1 + *(void *)(*a1 - 24));
  v1->int var0 = (PC_Sp_counted_base *)&unk_1F111F668;
  v1[14].int var0 = (PC_Sp_counted_base *)&unk_1F111F720;
  v1[10].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v1 + 13);
  v1[6].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v1 + 9);
  v1->int var0 = (PC_Sp_counted_base *)off_1F111F780;
  v1[14].int var0 = (PC_Sp_counted_base *)off_1F111F838;
  LiString::dec((LiString *)&v1[4]);
  v1[14].int var0 = (PC_Sp_counted_base *)&unk_1F1199AC8;
  LOBYTE(v1[16].var0) = 0;
  PCWeakCount::~PCWeakCount(&v1[15].var0);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t ProShade::BinaryOp<ProShade::Add>::BinaryOp(uint64_t a1, PCShared_base *a2, PCShared_base *a3, int a4)
{
  *(void *)(a1 + 112) = &unk_1F1199AC8;
  *(void *)(a1 + 120) = 0;
  *(unsigned char *)(a1 + 128) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F111F740);
  *(void *)a1 = &unk_1F111F668;
  *(void *)(a1 + 112) = &unk_1F111F720;
  ProShade::VarT<ProShade::Node>::VarT((PCSharedCount *)(a1 + 48), a2);
  ProShade::VarT<ProShade::Node>::VarT((PCSharedCount *)(a1 + 80), a3);
  int v9 = *((_DWORD *)a2 + 7);
  int v10 = *((_DWORD *)a3 + 7);
  if (v9 != 1)
  {
    if (v10 == 1)
    {
      int v10 = *((_DWORD *)a2 + 7);
    }
    else
    {
      BOOL v11 = v9 == v10;
      int v10 = *((_DWORD *)a2 + 7);
      if (!v11) {
        ProShade::Error<PCIllegalArgumentException>::raise<char [33]>((OZChannelBase *)"vector size mismatch", v8);
      }
    }
  }
  int v12 = *((_DWORD *)a2 + 6);
  if (v12 <= *((_DWORD *)a3 + 6)) {
    int v12 = *((_DWORD *)a3 + 6);
  }
  *(_DWORD *)(a1 + 24) = v12;
  *(_DWORD *)(a1 + 28) = v10;
  *(_DWORD *)(a1 + 44) = a4;
  ProShade::BinaryOp<ProShade::Add>::setFrequency(a1);
  return a1;
}

void sub_1B7ABBBE0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 48) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(v1 + 72));
  ProShade::Node::~Node((ProShade::Node *)v1, (uint64_t *)(v4 + 8));
  *(void *)(v1 + 112) = v3;
  *(unsigned char *)(v1 + 128) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

uint64_t ProShade::BinaryOp<ProShade::Add>::BinaryOp(uint64_t a1)
{
  *(void *)(a1 + 112) = &unk_1F1199AC8;
  *(void *)(a1 + 120) = 0;
  *(unsigned char *)(a1 + 128) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F111F740);
  *(void *)a1 = &unk_1F111F668;
  *(void *)(a1 + 112) = &unk_1F111F720;
  *(void *)(a1 + 48) = &unk_1F11193B8;
  *(void *)(a1 + 64) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 72));
  *(void *)(a1 + 80) = &unk_1F11193B8;
  *(void *)(a1 + 96) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 104));
  return a1;
}

void sub_1B7ABBD80(_Unwind_Exception *a1)
{
  uint64_t v8 = v4;
  *PCSharedCount v7 = v8;
  PCSharedCount::~PCSharedCount(v5);
  ProShade::Node::~Node((ProShade::Node *)v1, (uint64_t *)(v6 + 8));
  *(void *)(v1 + 112) = v3;
  *(unsigned char *)(v1 + 128) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

double ProShade::BinaryOp<ProShade::Add>::copyFrom(ProShade::Node *a1, const PCSharedCount *a2)
{
  ProShade::VarT<ProShade::Node>::operator=((uint64_t)a1 + 48, a2 + 6);
  ProShade::VarT<ProShade::Node>::operator=((uint64_t)a1 + 80, a2 + 10);

  return ProShade::Node::copyFrom(a1, (const ProShade::Node *)a2);
}

double ProShade::BinaryOp<ProShade::Subtract>::computeBinary(const PCString *a1, const PCString *a2, uint64_t a3)
{
  if (SLODWORD(a1->var0) > 1)
  {
    if (LODWORD(a1->var0) != 2) {
      return ProShade::computeBinaryType<ProShade::Subtract,double>((unsigned int *)a1, (unsigned int *)a2, a3);
    }
    int var0 = (int)a2->var0;
  }
  else
  {
    int var0 = (int)a2->var0;
    if (SLODWORD(a2->var0) < 2)
    {
      ProShade::computeBinaryType<ProShade::Subtract,BOOL>(a1, a2, a3);
      return result;
    }
  }
  if (var0 <= 2)
  {
    ProShade::computeBinaryType<ProShade::Subtract,int>((unsigned int *)a1, (unsigned int *)a2, a3);
    return result;
  }
  return ProShade::computeBinaryType<ProShade::Subtract,double>((unsigned int *)a1, (unsigned int *)a2, a3);
}

BOOL ProShade::Subtract::simplify(const PCSharedCount *a1, uint64_t a2, uint64_t a3)
{
  if (ProShade::isZero((uint64_t)a1)) {
    ProShade::UnaryOp<ProShade::Negate>::unary(a2);
  }
  BOOL result = ProShade::isZero(a2);
  if (result)
  {
    ProShade::VarT<ProShade::Node>::operator=(a3, a1);
    return 1;
  }
  return result;
}

void sub_1B7ABBEF4(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1 + 3);
  _Unwind_Resume(a1);
}

uint64_t ProShade::BinaryOp<ProShade::Subtract>::BinaryOp(uint64_t a1, PCShared_base *a2, PCShared_base *a3)
{
  *(void *)(a1 + 112) = &unk_1F1199AC8;
  *(void *)(a1 + 120) = 0;
  *(unsigned char *)(a1 + 128) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F111F9B8);
  *(void *)a1 = &unk_1F111F8E0;
  *(void *)(a1 + 112) = &unk_1F111F998;
  ProShade::VarT<ProShade::Node>::VarT((PCSharedCount *)(a1 + 48), a2);
  ProShade::VarT<ProShade::Node>::VarT((PCSharedCount *)(a1 + 80), a3);
  int v7 = *((_DWORD *)a2 + 7);
  int v8 = *((_DWORD *)a3 + 7);
  if (v7 != 1)
  {
    if (v8 == 1)
    {
      int v8 = *((_DWORD *)a2 + 7);
    }
    else
    {
      BOOL v9 = v7 == v8;
      int v8 = *((_DWORD *)a2 + 7);
      if (!v9) {
        ProShade::Error<PCIllegalArgumentException>::raise<char [33]>((OZChannelBase *)"vector size mismatch", v6);
      }
    }
  }
  int v10 = *((_DWORD *)a2 + 6);
  if (v10 <= *((_DWORD *)a3 + 6)) {
    int v10 = *((_DWORD *)a3 + 6);
  }
  *(_DWORD *)(a1 + 24) = v10;
  *(_DWORD *)(a1 + 28) = v8;
  ProShade::BinaryOp<ProShade::Add>::setFrequency(a1);
  return a1;
}

void sub_1B7ABC058(_Unwind_Exception *a1)
{
  *(void *)(v1 + 48) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(v1 + 72));
  ProShade::Node::~Node((ProShade::Node *)v1, (uint64_t *)(v4 + 8));
  *(void *)(v1 + 112) = v3;
  *(unsigned char *)(v1 + 128) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

BOOL ProShade::computeBinaryType<ProShade::Subtract,BOOL>(const PCString *a1, const PCString *a2, uint64_t a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  int Size = ProShade::shapeGetSize(HIDWORD(a1->var0), a2);
  uint64_t v8 = ProShade::shapeGetSize(HIDWORD(a2->var0), v7);
  int v10 = v8;
  var0_low = (void *)LODWORD(a1->var0);
  if (var0_low != 1)
  {
    MEMORY[0x1F4188790](v8);
    uint64_t v13 = (BOOL *)&v24 - v12;
    bzero((char *)&v24 - v12, v14);
    uint64_t v8 = (uint64_t)ProShade::copyData(var0_low, a1 + 2, 1, v13, Size);
  }
  uint64_t v15 = (void *)LODWORD(a2->var0);
  if (v15 != 1)
  {
    MEMORY[0x1F4188790](v8);
    size_t v17 = (BOOL *)&v24 - v16;
    bzero((char *)&v24 - v16, v18);
    ProShade::copyData(v15, a2 + 2, 1, v17, v10);
  }
  int var0_high = HIDWORD(a1->var0);
  if (var0_high != HIDWORD(a2->var0)) {
    ProShade::Error<PCException>::raise<char [27]>((OZChannelBase *)"mismatched operator inputs", v9);
  }
  ProShade::Value::set(a3, (const PCString *)1, var0_high);
  BOOL result = ProShade::shapeIsVector(HIDWORD(a1->var0));
  int v22 = HIDWORD(a1->var0) == 1 || result;
  if (v22 != 1)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v26, "not implemented yet");
    PCString::PCString(&v25, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/Shading/PSOp.cpp");
    PCException::PCException(exception, &v26, &v25, 426);
    *(void *)exception = &unk_1F10B1208;
  }
  if (Size >= 1) {
    ProShade::Error<PCIllegalArgumentException>::raise<char [33]>((OZChannelBase *)"- operator doesn't apply to BOOL", v21);
  }
  return result;
}

void sub_1B7ABC304(_Unwind_Exception *a1)
{
  PCString::~PCString((PCString *)(v3 - 88));
  PCString::~PCString((PCString *)(v3 - 80));
  if (v2) {
    __cxa_free_exception(v1);
  }
  _Unwind_Resume(a1);
}

BOOL ProShade::computeBinaryType<ProShade::Subtract,int>(unsigned int *a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  int Size = ProShade::shapeGetSize(a1[1], (const PCString *)a2);
  uint64_t v8 = ProShade::shapeGetSize(a2[1], v7);
  int v10 = v8;
  BOOL v11 = (void *)*a1;
  if (v11 == 2)
  {
    uint64_t v12 = (BOOL *)(a1 + 4);
  }
  else
  {
    MEMORY[0x1F4188790](v8);
    uint64_t v12 = (BOOL *)&v28 - v13;
    bzero((char *)&v28 - v13, v14);
    uint64_t v8 = (uint64_t)ProShade::copyData(v11, (const PCString *)a1 + 2, 2, v12, Size);
  }
  uint64_t v15 = (void *)*a2;
  if (v15 == 2)
  {
    uint64_t v16 = (BOOL *)(a2 + 4);
  }
  else
  {
    MEMORY[0x1F4188790](v8);
    uint64_t v16 = (BOOL *)&v28 - v17;
    bzero((char *)&v28 - v17, v18);
    ProShade::copyData(v15, (const PCString *)a2 + 2, 2, v16, v10);
  }
  int v19 = a1[1];
  if (v19 != a2[1]) {
    ProShade::Error<PCException>::raise<char [27]>((OZChannelBase *)"mismatched operator inputs", v9);
  }
  ProShade::Value::set(a3, (const PCString *)2, v19);
  BOOL result = ProShade::shapeIsVector(a1[1]);
  int v21 = a1[1] == 1 || result;
  if (v21 != 1)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v30, "not implemented yet");
    PCString::PCString(&v29, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/Shading/PSOp.cpp");
    PCException::PCException(exception, &v30, &v29, 426);
    *(void *)exception = &unk_1F10B1208;
  }
  if (Size >= 1)
  {
    int v22 = (_DWORD *)(a3 + 16);
    uint64_t v23 = Size;
    do
    {
      int v25 = *(_DWORD *)v12;
      v12 += 4;
      int v24 = v25;
      int v26 = *(_DWORD *)v16;
      v16 += 4;
      *v22++ = v24 - v26;
      --v23;
    }
    while (v23);
  }
  return result;
}

void sub_1B7ABC590(_Unwind_Exception *a1)
{
  PCString::~PCString((PCString *)(v3 - 88));
  PCString::~PCString((PCString *)(v3 - 80));
  if (v2) {
    __cxa_free_exception(v1);
  }
  _Unwind_Resume(a1);
}

double ProShade::computeBinaryType<ProShade::Subtract,double>(unsigned int *a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  int Size = ProShade::shapeGetSize(a1[1], (const PCString *)a2);
  uint64_t v8 = ProShade::shapeGetSize(a2[1], v7);
  int v10 = v8;
  BOOL v11 = (void *)*a1;
  if (v11 == 3)
  {
    uint64_t v12 = (BOOL *)(a1 + 4);
  }
  else
  {
    MEMORY[0x1F4188790](v8);
    uint64_t v12 = (BOOL *)&v29 - v13;
    bzero((char *)&v29 - v13, v14);
    uint64_t v8 = (uint64_t)ProShade::copyData(v11, (const PCString *)a1 + 2, 3, v12, Size);
  }
  uint64_t v15 = (void *)*a2;
  if (v15 == 3)
  {
    uint64_t v16 = (BOOL *)(a2 + 4);
  }
  else
  {
    MEMORY[0x1F4188790](v8);
    uint64_t v16 = (BOOL *)&v29 - v17;
    bzero((char *)&v29 - v17, v18);
    ProShade::copyData(v15, (const PCString *)a2 + 2, 3, v16, v10);
  }
  int v19 = a1[1];
  if (v19 != a2[1]) {
    ProShade::Error<PCException>::raise<char [27]>((OZChannelBase *)"mismatched operator inputs", v9);
  }
  ProShade::Value::set(a3, (const PCString *)3, v19);
  BOOL IsVector = ProShade::shapeIsVector(a1[1]);
  int v22 = a1[1] == 1 || IsVector;
  if (v22 != 1)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::PCString(&v31, "not implemented yet");
    PCString::PCString(&v30, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/Shading/PSOp.cpp");
    PCException::PCException(exception, &v31, &v30, 426);
    *(void *)exception = &unk_1F10B1208;
  }
  if (Size >= 1)
  {
    uint64_t v23 = (double *)(a3 + 16);
    uint64_t v24 = Size;
    do
    {
      double v25 = *(double *)v12;
      v12 += 8;
      double v26 = v25;
      double v27 = *(double *)v16;
      v16 += 8;
      double result = v26 - v27;
      *v23++ = result;
      --v24;
    }
    while (v24);
  }
  return result;
}

void sub_1B7ABC81C(_Unwind_Exception *a1)
{
  PCString::~PCString((PCString *)(v3 - 88));
  PCString::~PCString((PCString *)(v3 - 80));
  if (v2) {
    __cxa_free_exception(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t ProShade::BinaryOp<ProShade::Subtract>::~BinaryOp(uint64_t a1)
{
  *(void *)a1 = &unk_1F111F8E0;
  *(void *)(a1 + 112) = &unk_1F111F998;
  *(void *)(a1 + 80) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(a1 + 104));
  *(void *)(a1 + 48) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(a1 + 72));
  *(void *)a1 = off_1F111F9F8;
  *(void *)(a1 + 112) = off_1F111FAB0;
  LiString::dec((LiString *)(a1 + 32));
  *(void *)(a1 + 112) = &unk_1F1199AC8;
  *(unsigned char *)(a1 + 128) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(a1 + 120));
  return a1;
}

void ProShade::BinaryOp<ProShade::Subtract>::~BinaryOp(uint64_t a1)
{
  *(void *)a1 = &unk_1F111F8E0;
  *(void *)(a1 + 112) = &unk_1F111F998;
  *(void *)(a1 + 80) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(a1 + 104));
  *(void *)(a1 + 48) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(a1 + 72));
  *(void *)a1 = off_1F111F9F8;
  *(void *)(a1 + 112) = off_1F111FAB0;
  LiString::dec((LiString *)(a1 + 32));
  *(void *)(a1 + 112) = &unk_1F1199AC8;
  *(unsigned char *)(a1 + 128) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(a1 + 120));

  JUMPOUT(0x1BA9BFBA0);
}

void ProShade::BinaryOp<ProShade::Subtract>::repr(uint64_t a1@<X0>, void *a2@<X8>)
{
  ProShade::VarT<ProShade::Node>::repr(a1 + 48);
  if (v28) {
    int v4 = *((_DWORD *)v28 - 2);
  }
  else {
    int v4 = 0;
  }
  int v5 = malloc_type_malloc(v4 + 14, 0x8903763CuLL);
  uint64_t v6 = v4 + 1;
  v5[2] = v4 + 2;
  atomic_store(1u, v5);
  atomic_store(0, v5);
  *((unsigned char *)v5 + 12) = 40;
  int v7 = v5 + 3;
  v5[1] = v6;
  memcpy((char *)v5 + 13, v28, v4);
  v7[v6] = 0;
  atomic_fetch_add(v5, 1u);
  double v26 = v5;
  size_t v8 = (int)v5[1];
  BOOL v9 = (unsigned int *)malloc_type_malloc(v8 + 14, 0x8903763CuLL);
  atomic_store(1u, v9);
  int v10 = v9 + 3;
  atomic_store(0, v9);
  v9[1] = v8 + 1;
  void v9[2] = v8 + 2;
  memcpy(v9 + 3, v7, v8);
  *((unsigned char *)v10 + v8) = 32;
  *((unsigned char *)v10 + v8 + 1) = 0;
  atomic_fetch_add((atomic_uint *volatile)v9, 1u);
  double v25 = v9;
  size_t v11 = (int)v9[1];
  uint64_t v12 = (unsigned int *)malloc_type_malloc(v11 + 14, 0x8903763CuLL);
  v12[1] = v11 + 1;
  void v12[2] = v11 + 2;
  atomic_store(1u, v12);
  uint64_t v13 = v12 + 3;
  atomic_store(0, v12);
  memcpy(v12 + 3, v9 + 3, v11);
  *((unsigned char *)v13 + v11) = 45;
  *((unsigned char *)v13 + v11 + 1) = 0;
  atomic_fetch_add((atomic_uint *volatile)v12, 1u);
  size_t v14 = (int)v12[1];
  uint64_t v15 = (unsigned int *)malloc_type_malloc(v14 + 14, 0x8903763CuLL);
  uint64_t v24 = a2;
  atomic_store(1u, v15);
  uint64_t v16 = v15 + 3;
  atomic_store(0, v15);
  v15[1] = v14 + 1;
  _OWORD v15[2] = v14 + 2;
  memcpy(v15 + 3, v12 + 3, v14);
  v16[v14] = 32;
  v16[v14 + 1] = 0;
  atomic_fetch_add((atomic_uint *volatile)v15, 1u);
  ProShade::VarT<ProShade::Node>::repr(a1 + 80);
  size_t v17 = (int)v15[1];
  if (v27) {
    int v18 = *((_DWORD *)v27 - 2);
  }
  else {
    int v18 = 0;
  }
  size_t v19 = v17 + v18;
  uint64_t v20 = (unsigned int *)malloc_type_malloc(v19 + 13, 0x8903763CuLL);
  v20[1] = v19;
  double v20[2] = v19 + 1;
  atomic_store(1u, v20);
  atomic_store(0, v20);
  memcpy(v20 + 3, v16, v17);
  memcpy((char *)v20 + v17 + 12, v27, v18);
  *((unsigned char *)v20 + v19 + 12) = 0;
  atomic_fetch_add((atomic_uint *volatile)v20, 1u);
  size_t v21 = (int)v20[1];
  int v22 = (unsigned int *)malloc_type_malloc(v21 + 14, 0x8903763CuLL);
  atomic_store(1u, v22);
  uint64_t v23 = v22 + 3;
  atomic_store(0, v22);
  v22[1] = v21 + 1;
  v22[2] = v21 + 2;
  memcpy(v22 + 3, v20 + 3, v21);
  *((unsigned char *)v23 + v21) = 41;
  *((unsigned char *)v23 + v21 + 1) = 0;
  void *v24 = v22 + 3;
  atomic_fetch_add((atomic_uint *volatile)v22, 1u);
  if (atomic_fetch_add((atomic_uint *volatile)v20, 0xFFFFFFFF) == 1) {
    free(v20);
  }
  if (v27 && atomic_fetch_add((atomic_uint *volatile)v27 - 3, 0xFFFFFFFF) == 1)
  {
    *double v27 = 0;
    free(v27 - 12);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v15, 0xFFFFFFFF) == 1) {
    free(v15);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v12, 0xFFFFFFFF) == 1) {
    free(v12);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v25, 0xFFFFFFFF) == 1) {
    free(v25);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v26, 0xFFFFFFFF) == 1) {
    free(v26);
  }
  if (v28)
  {
    if (atomic_fetch_add((atomic_uint *volatile)v28 - 3, 0xFFFFFFFF) == 1)
    {
      unsigned char *v28 = 0;
      free(v28 - 12);
    }
  }
}

void sub_1B7ABCE2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, atomic_uint *a13, atomic_uint *a14)
{
  if (atomic_fetch_add((atomic_uint *volatile)v16, 0xFFFFFFFF) == 1) {
    free(v16);
  }
  if (a13 && atomic_fetch_add(a13 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)a13 = 0;
    free(a13 - 3);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v15, 0xFFFFFFFF) == 1) {
    free(v15);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v14, 0xFFFFFFFF) == 1) {
    free(v14);
  }
  if (atomic_fetch_add((atomic_uint *volatile)a11, 0xFFFFFFFF) == 1) {
    free(a11);
  }
  if (atomic_fetch_add((atomic_uint *volatile)a12, 0xFFFFFFFF) == 1) {
    free(a12);
  }
  if (a14)
  {
    if (atomic_fetch_add(a14 - 3, 0xFFFFFFFF) == 1)
    {
      *(unsigned char *)a14 = 0;
      free(a14 - 3);
    }
  }
  _Unwind_Resume(exception_object);
}

void ProShade::BinaryOp<ProShade::Subtract>::description(void *a1@<X8>)
{
  LiString::LiString((LiString *)&v8, "BinaryOp ");
  int v2 = v8;
  if (v8) {
    int v3 = *((_DWORD *)v8 - 2);
  }
  else {
    int v3 = 0;
  }
  size_t v4 = v3;
  int v5 = (unsigned int *)malloc_type_malloc(v3 + 14, 0x8903763CuLL);
  v5[1] = v4 + 1;
  v5[2] = v4 + 2;
  atomic_store(1u, v5);
  uint64_t v6 = v5 + 3;
  atomic_store(0, v5);
  memcpy(v5 + 3, v2, v4);
  *((unsigned char *)v6 + v4) = 45;
  *((unsigned char *)v6 + v4 + 1) = 0;
  *a1 = v5 + 3;
  atomic_fetch_add((atomic_uint *volatile)v5, 1u);
  if (v8 && atomic_fetch_add((atomic_uint *volatile)v8 - 3, 0xFFFFFFFF) == 1)
  {
    unsigned char *v8 = 0;
    if (v8) {
      int v7 = v8 - 12;
    }
    else {
      int v7 = 0;
    }
    free(v7);
  }
}

void sub_1B7ABD04C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    ProShade::VertexProgram::VertexProgram(a10);
  }
  _Unwind_Resume(exception_object);
}

int8x8_t *ProShade::BinaryOp<ProShade::Subtract>::computeHash(uint64_t a1, int8x8_t *this)
{
  PCHashWriteStream::writeValue(this, "-");
  ProShade::VarT<ProShade::Node>::hash(a1 + 48, &v5);
  PCHashWriteStream::writeValue(this, (const PCHash128 *)&v5);
  ProShade::VarT<ProShade::Node>::hash(a1 + 80, &v5);
  return PCHashWriteStream::writeValue(this, (const PCHash128 *)&v5);
}

void ProShade::BinaryOp<ProShade::Subtract>::apply(PCShared_base *a1@<X0>, void (***a2)(void *__return_ptr, void, uint64_t)@<X1>, PCSharedCount *a3@<X8>)
{
  (**a2)(v8, a2, (uint64_t)a1 + 48);
  (**a2)(v6, a2, (uint64_t)a1 + 80);
  if (v8[2] != *((void *)a1 + 8) || v6[2] != *((void *)a1 + 12)) {
    operator new();
  }
  ProShade::VarT<ProShade::Node>::VarT(a3, a1);
  v6[0] = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount(&v7);
  v8[0] = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount(&v9);
}

void sub_1B7ABD22C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v6.int var0 = va_arg(va1, PC_Sp_counted_base *);
  size_t v8 = va_arg(va1, void *);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  MEMORY[0x1BA9BFBA0](v4, 0x10B1C403815D87CLL);
  PCSharedCount::~PCSharedCount((PCSharedCount *)va);
  size_t v8 = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)va1);
  _Unwind_Resume(a1);
}

void ProShade::BinaryOp<ProShade::Subtract>::clone()
{
}

void sub_1B7ABD300(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C403815D87CLL);
  _Unwind_Resume(a1);
}

double ProShade::BinaryOp<ProShade::Subtract>::computeValue(PCArray_base *a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(_DWORD *)(a2 + 12);
  if (v4 < 1) {
    PCArray_base::badIndex(a1);
  }
  if (v4 <= 1) {
    PCArray_base::badIndex(a1);
  }
  __n128 v5 = (const PCString *)(*(void *)(a2 + 16) + 144);
  PCSharedCount v6 = *(const PCString **)(a2 + 16);

  return ProShade::BinaryOp<ProShade::Subtract>::computeBinary(v6, v5, a3);
}

void virtual thunk to'ProShade::BinaryOp<ProShade::Subtract>::~BinaryOp(void *a1)
{
  uint64_t v1 = (PCSharedCount *)((char *)a1 + *(void *)(*a1 - 24));
  v1->int var0 = (PC_Sp_counted_base *)&unk_1F111F8E0;
  v1[14].int var0 = (PC_Sp_counted_base *)&unk_1F111F998;
  v1[10].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v1 + 13);
  v1[6].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v1 + 9);
  v1->int var0 = (PC_Sp_counted_base *)off_1F111F9F8;
  v1[14].int var0 = (PC_Sp_counted_base *)off_1F111FAB0;
  LiString::dec((LiString *)&v1[4]);
  v1[14].int var0 = (PC_Sp_counted_base *)&unk_1F1199AC8;
  LOBYTE(v1[16].var0) = 0;

  PCWeakCount::~PCWeakCount(&v1[15].var0);
}

{
  PCSharedCount *v1;
  uint64_t vars8;

  uint64_t v1 = (PCSharedCount *)((char *)a1 + *(void *)(*a1 - 24));
  v1->int var0 = (PC_Sp_counted_base *)&unk_1F111F8E0;
  v1[14].int var0 = (PC_Sp_counted_base *)&unk_1F111F998;
  v1[10].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v1 + 13);
  v1[6].int var0 = (PC_Sp_counted_base *)&unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v1 + 9);
  v1->int var0 = (PC_Sp_counted_base *)off_1F111F9F8;
  v1[14].int var0 = (PC_Sp_counted_base *)off_1F111FAB0;
  LiString::dec((LiString *)&v1[4]);
  v1[14].int var0 = (PC_Sp_counted_base *)&unk_1F1199AC8;
  LOBYTE(v1[16].var0) = 0;
  PCWeakCount::~PCWeakCount(&v1[15].var0);

  JUMPOUT(0x1BA9BFBA0);
}

uint64_t ProShade::BinaryOp<ProShade::Subtract>::BinaryOp(uint64_t a1, PCShared_base *a2, PCShared_base *a3, int a4)
{
  *(void *)(a1 + 112) = &unk_1F1199AC8;
  *(void *)(a1 + 120) = 0;
  *(unsigned char *)(a1 + 128) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F111F9B8);
  *(void *)a1 = &unk_1F111F8E0;
  *(void *)(a1 + 112) = &unk_1F111F998;
  ProShade::VarT<ProShade::Node>::VarT((PCSharedCount *)(a1 + 48), a2);
  ProShade::VarT<ProShade::Node>::VarT((PCSharedCount *)(a1 + 80), a3);
  int v9 = *((_DWORD *)a2 + 7);
  int v10 = *((_DWORD *)a3 + 7);
  if (v9 != 1)
  {
    if (v10 == 1)
    {
      int v10 = *((_DWORD *)a2 + 7);
    }
    else
    {
      BOOL v11 = v9 == v10;
      int v10 = *((_DWORD *)a2 + 7);
      if (!v11) {
        ProShade::Error<PCIllegalArgumentException>::raise<char [33]>((OZChannelBase *)"vector size mismatch", v8);
      }
    }
  }
  int v12 = *((_DWORD *)a2 + 6);
  if (v12 <= *((_DWORD *)a3 + 6)) {
    int v12 = *((_DWORD *)a3 + 6);
  }
  *(_DWORD *)(a1 + 24) = v12;
  *(_DWORD *)(a1 + 28) = v10;
  *(_DWORD *)(a1 + 44) = a4;
  ProShade::BinaryOp<ProShade::Add>::setFrequency(a1);
  return a1;
}

void sub_1B7ABD764(_Unwind_Exception *a1)
{
  *(void *)(v1 + 48) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(v1 + 72));
  ProShade::Node::~Node((ProShade::Node *)v1, (uint64_t *)(v4 + 8));
  *(void *)(v1 + 112) = v3;
  *(unsigned char *)(v1 + 128) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

uint64_t ProShade::BinaryOp<ProShade::Subtract>::BinaryOp(uint64_t a1)
{
  *(void *)(a1 + 112) = &unk_1F1199AC8;
  *(void *)(a1 + 120) = 0;
  *(unsigned char *)(a1 + 128) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F111F9B8);
  *(void *)a1 = &unk_1F111F8E0;
  *(void *)(a1 + 112) = &unk_1F111F998;
  *(void *)(a1 + 48) = &unk_1F11193B8;
  *(void *)(a1 + 64) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 72));
  *(void *)(a1 + 80) = &unk_1F11193B8;
  *(void *)(a1 + 96) = 0;
  PCSharedCount::PCSharedCount((PCSharedCount *)(a1 + 104));
  return a1;
}

void sub_1B7ABD904(_Unwind_Exception *a1)
{
  uint64_t v8 = v4;
  *PCSharedCount v7 = v8;
  PCSharedCount::~PCSharedCount(v5);
  ProShade::Node::~Node((ProShade::Node *)v1, (uint64_t *)(v6 + 8));
  *(void *)(v1 + 112) = v3;
  *(unsigned char *)(v1 + 128) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

double ProShade::BinaryOp<ProShade::Multiply>::computeBinary(unsigned int *a1, unsigned int *a2, uint64_t a3)
{
  if ((int)*a1 > 1)
  {
    if (*a1 != 2) {
      return ProShade::computeBinaryType<ProShade::Multiply,double>(a1, a2, a3);
    }
    signed int v3 = *a2;
  }
  else
  {
    signed int v3 = *a2;
    if ((int)*a2 < 2)
    {
      ProShade::computeBinaryType<ProShade::Multiply,BOOL>(a1, a2, a3);
      return result;
    }
  }
  if (v3 <= 2)
  {
    ProShade::computeBinaryType<ProShade::Multiply,int>(a1, a2, a3);
    return result;
  }
  return ProShade::computeBinaryType<ProShade::Multiply,double>(a1, a2, a3);
}

BOOL ProShade::Multiply::simplify(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (ProShade::isZero(a1)) {
    goto LABEL_2;
  }
  if (ProShade::isZero(a2) || ProShade::isOne(a1))
  {
    uint64_t v6 = a3;
    PCSharedCount v7 = (const PCSharedCount *)a2;
    goto LABEL_6;
  }
  if (ProShade::isOne(a2))
  {
LABEL_2:
    uint64_t v6 = a3;
    PCSharedCount v7 = (const PCSharedCount *)a1;
LABEL_6:
    ProShade::VarT<ProShade::Node>::operator=(v6, v7);
    return 1;
  }
  uint64_t v9 = *(void *)(a2 + 16);
  if (!v9) {
    throw_PCNullPointerException(1);
  }
  BOOL result = ProShade::shapeIsVector(*(_DWORD *)(v9 + 28));
  if (result)
  {
    int v11 = ProShade::VarT<ProShade::Node>::width(a1, v10);
    if (v11 > (int)ProShade::VarT<ProShade::Node>::width(a2, v12))
    {
      int v14 = ProShade::VarT<ProShade::Node>::width(a1, v13);
      if (v14 == 3)
      {
LABEL_18:
        if (ProShade::VarT<ProShade::Node>::width(a2, v15) == 2) {
          ProShade::VarT<ProShade::Node>::VarT(v17);
        }
        return 0;
      }
      if (v14 == 4)
      {
        int v16 = ProShade::VarT<ProShade::Node>::width(a2, v15);
        if (v16 == 3) {
          ProShade::VarT<ProShade::Node>::VarT(v17);
        }
        if (v16 == 2) {
          ProShade::VarT<ProShade::Node>::VarT(v17);
        }
        goto LABEL_18;
      }
    }
    return 0;
  }
  return result;
}

void sub_1B7ABDD9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, PCSharedCount a12, void *a13, uint64_t a14, uint64_t a15, PCSharedCount a16, void *a17)
{
  a17 = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount(v17 + 3);
  PCSharedCount::~PCSharedCount(&a12);
  a13 = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount(&a16);
  *(void *)(v18 - 64) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(v18 - 40));
  _Unwind_Resume(a1);
}

uint64_t ProShade::BinaryOp<ProShade::Multiply>::BinaryOp(uint64_t a1, PCShared_base *a2, PCShared_base *a3)
{
  *(void *)(a1 + 112) = &unk_1F1199AC8;
  *(void *)(a1 + 120) = 0;
  *(unsigned char *)(a1 + 128) = 1;
  ProShade::Node::Node((ProShade::Node *)a1, (uint64_t *)&off_1F111FC30);
  *(void *)a1 = &unk_1F111FB58;
  *(void *)(a1 + 112) = &unk_1F111FC10;
  ProShade::VarT<ProShade::Node>::VarT((PCSharedCount *)(a1 + 48), a2);
  ProShade::VarT<ProShade::Node>::VarT((PCSharedCount *)(a1 + 80), a3);
  int v6 = ProShade::Multiply::resultShape(*((unsigned int *)a2 + 7), *((unsigned int *)a3 + 7));
  int v7 = *((_DWORD *)a2 + 6);
  if (v7 <= *((_DWORD *)a3 + 6)) {
    int v7 = *((_DWORD *)a3 + 6);
  }
  *(_DWORD *)(a1 + 24) = v7;
  *(_DWORD *)(a1 + 28) = v6;
  ProShade::BinaryOp<ProShade::Multiply>::setFrequency(a1);
  return a1;
}

void sub_1B7ABE058(_Unwind_Exception *a1)
{
  *(void *)(v1 + 48) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(v1 + 72));
  ProShade::Node::~Node((ProShade::Node *)v1, (uint64_t *)(v4 + 8));
  *(void *)(v1 + 112) = v3;
  *(unsigned char *)(v1 + 128) = 0;
  PCWeakCount::~PCWeakCount(v2);
  _Unwind_Resume(a1);
}

BOOL ProShade::computeBinaryType<ProShade::Multiply,BOOL>(unsigned int *a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  int Size = ProShade::shapeGetSize(a1[1], (const PCString *)a2);
  uint64_t v8 = ProShade::shapeGetSize(a2[1], v7);
  int v9 = v8;
  int v10 = (void *)*a1;
  if (v10 == 1)
  {
    int v11 = (BOOL *)(a1 + 4);
  }
  else
  {
    MEMORY[0x1F4188790](v8);
    int v11 = (BOOL *)&v24 - v12;
    bzero((char *)&v24 - v12, v13);
    uint64_t v8 = (uint64_t)ProShade::copyData(v10, (const PCString *)a1 + 2, 1, v11, Size);
  }
  int v14 = (void *)*a2;
  if (v14 == 1)
  {
    uint64_t v15 = (BOOL *)(a2 + 4);
  }
  else
  {
    MEMORY[0x1F4188790](v8);
    uint64_t v15 = (BOOL *)&v24 - v16;
    bzero((char *)&v24 - v16, v17);
    ProShade::copyData(v14, (const PCString *)a2 + 2, 1, v15, v9);
  }
  BOOL result = ProShade::Multiply::computeBinaryType<BOOL>((char *)v11, (char *)v15, (uint64_t)a1, (uint64_t)a2, a3);
  if (!result)
  {
    int v20 = a1[1];
    if (v20 != a2[1]) {
      ProShade::Error<PCException>::raise<char [27]>((OZChannelBase *)"mismatched operator inputs", v19);
    }
    ProShade::Value::set(a3, (const PCString *)1, v20);
    BOOL result = ProShade::shapeIsVector(a1[1]);
    int v22 = a1[1] == 1 || result;
    if (v22 != 1)
    {
      exception = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::PCString(&v26, "not implemented yet");
      PCString::PCString(&v25, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/Shading/PSOp.cpp");
      PCException::PCException(exception, &v26, &v25, 426);
      *(void *)exception = &unk_1F10B1208;
    }
    if (Size >= 1) {
      ProShade::Error<PCIllegalArgumentException>::raise<char [33]>((OZChannelBase *)"* operator doesn't apply to BOOL", v21);
    }
  }
  return result;
}

void sub_1B7ABE330(_Unwind_Exception *a1)
{
  PCString::~PCString((PCString *)(v3 - 88));
  PCString::~PCString((PCString *)(v3 - 80));
  if (v2) {
    __cxa_free_exception(v1);
  }
  _Unwind_Resume(a1);
}

BOOL ProShade::computeBinaryType<ProShade::Multiply,int>(unsigned int *a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  int Size = ProShade::shapeGetSize(a1[1], (const PCString *)a2);
  uint64_t v8 = ProShade::shapeGetSize(a2[1], v7);
  int v9 = v8;
  int v10 = (void *)*a1;
  if (v10 == 2)
  {
    int v11 = (BOOL *)(a1 + 4);
  }
  else
  {
    MEMORY[0x1F4188790](v8);
    int v11 = (BOOL *)&v28 - v12;
    bzero((char *)&v28 - v12, v13);
    uint64_t v8 = (uint64_t)ProShade::copyData(v10, (const PCString *)a1 + 2, 2, v11, Size);
  }
  int v14 = (void *)*a2;
  if (v14 == 2)
  {
    uint64_t v15 = (BOOL *)(a2 + 4);
  }
  else
  {
    MEMORY[0x1F4188790](v8);
    uint64_t v15 = (BOOL *)&v28 - v16;
    bzero((char *)&v28 - v16, v17);
    ProShade::copyData(v14, (const PCString *)a2 + 2, 2, v15, v9);
  }
  BOOL result = ProShade::Multiply::computeBinaryType<int>((int *)v11, (int *)v15, (uint64_t)a1, (uint64_t)a2, a3);
  if (!result)
  {
    int v20 = a1[1];
    if (v20 != a2[1]) {
      ProShade::Error<PCException>::raise<char [27]>((OZChannelBase *)"mismatched operator inputs", v19);
    }
    ProShade::Value::set(a3, (const PCString *)2, v20);
    BOOL result = ProShade::shapeIsVector(a1[1]);
    int v21 = a1[1] == 1 || result;
    if (v21 != 1)
    {
      exception = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::PCString(&v30, "not implemented yet");
      PCString::PCString(&v29, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/Shading/PSOp.cpp");
      PCException::PCException(exception, &v30, &v29, 426);
      *(void *)exception = &unk_1F10B1208;
    }
    if (Size >= 1)
    {
      int v22 = (_DWORD *)(a3 + 16);
      uint64_t v23 = Size;
      do
      {
        int v25 = *(_DWORD *)v11;
        v11 += 4;
        int v24 = v25;
        int v26 = *(_DWORD *)v15;
        v15 += 4;
        *v22++ = v26 * v24;
        --v23;
      }
      while (v23);
    }
  }
  return result;
}

void sub_1B7ABE5D8(_Unwind_Exception *a1)
{
  PCString::~PCString((PCString *)(v3 - 88));
  PCString::~PCString((PCString *)(v3 - 80));
  if (v2) {
    __cxa_free_exception(v1);
  }
  _Unwind_Resume(a1);
}

double ProShade::computeBinaryType<ProShade::Multiply,double>(unsigned int *a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  int Size = ProShade::shapeGetSize(a1[1], (const PCString *)a2);
  uint64_t v8 = ProShade::shapeGetSize(a2[1], v7);
  int v9 = v8;
  int v10 = (void *)*a1;
  if (v10 == 3)
  {
    int v11 = (BOOL *)(a1 + 4);
  }
  else
  {
    MEMORY[0x1F4188790](v8);
    int v11 = (BOOL *)&v29 - v12;
    bzero((char *)&v29 - v12, v13);
    uint64_t v8 = (uint64_t)ProShade::copyData(v10, (const PCString *)a1 + 2, 3, v11, Size);
  }
  int v14 = (void *)*a2;
  if (v14 == 3)
  {
    uint64_t v15 = (BOOL *)(a2 + 4);
  }
  else
  {
    MEMORY[0x1F4188790](v8);
    uint64_t v15 = (BOOL *)&v29 - v16;
    bzero((char *)&v29 - v16, v17);
    ProShade::copyData(v14, (const PCString *)a2 + 2, 3, v15, v9);
  }
  if (!ProShade::Multiply::computeBinaryType<double>((double *)v11, (double *)v15, (uint64_t)a1, (uint64_t)a2, a3))
  {
    int v20 = a1[1];
    if (v20 != a2[1]) {
      ProShade::Error<PCException>::raise<char [27]>((OZChannelBase *)"mismatched operator inputs", v18);
    }
    ProShade::Value::set(a3, (const PCString *)3, v20);
    BOOL IsVector = ProShade::shapeIsVector(a1[1]);
    int v22 = a1[1] == 1 || IsVector;
    if (v22 != 1)
    {
      exception = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::PCString(&v31, "not implemented yet");
      PCString::PCString(&v30, "/Library/Caches/com.apple.xbs/Sources/LithiumiOS/Shading/PSOp.cpp");
      PCException::PCException(exception, &v31, &v30, 426);
      *(void *)exception = &unk_1F10B1208;
    }
    if (Size >= 1)
    {
      uint64_t v23 = (double *)(a3 + 16);
      uint64_t v24 = Size;
      do
      {
        double v25 = *(double *)v11;
        v11 += 8;
        double v26 = v25;
        double v27 = *(double *)v15;
        v15 += 8;
        double result = v26 * v27;
        *v23++ = result;
        --v24;
      }
      while (v24);
    }
  }
  return result;
}

void sub_1B7ABE880(_Unwind_Exception *a1)
{
  PCString::~PCString((PCString *)(v3 - 88));
  PCString::~PCString((PCString *)(v3 - 80));
  if (v2) {
    __cxa_free_exception(v1);
  }
  _Unwind_Resume(a1);
}

BOOL ProShade::Multiply::computeBinaryType<BOOL>(char *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v172 = *MEMORY[0x1E4F143B8];
  if (!ProShade::shapeIsMatrix(*(_DWORD *)(a3 + 4))
    || !ProShade::shapeIsVector(*(_DWORD *)(a4 + 4))
    || (int v11 = ProShade::shapeGetWidth(*(_DWORD *)(a3 + 4), v10),
        v11 != ProShade::shapeGetWidth(*(_DWORD *)(a4 + 4), v12)))
  {
    BOOL IsVector = ProShade::shapeIsVector(*(_DWORD *)(a3 + 4));
    int v28 = *(_DWORD *)(a4 + 4);
    if (IsVector && v28 == 1)
    {
      uint64_t Width = ProShade::shapeGetWidth(*(_DWORD *)(a3 + 4), v26);
      if ((int)Width > 4)
      {
        PCGenVector<BOOL>::PCGenVector((uint64_t)&v167, (uint64_t)a1, Width, 0);
        int v58 = *a2;
        int v59 = v168;
        PCGenBlockRef<BOOL>::PCGenBlockRef(&v163, v168);
        unsigned int v164 = v59;
        int v165 = 1;
        unint64_t v60 = v163;
        uint64_t v166 = v163;
        float64x2_t v61 = v170;
        uint64_t v62 = v168;
        uint64_t v63 = (int)v169;
        if (v169 == 1)
        {
          if (v168 >= 1)
          {
            float64x2_t v64 = v163;
            do
            {
              int v66 = *v61++;
              int v65 = v66;
              if (v58) {
                BOOL v67 = v65 == 0;
              }
              else {
                BOOL v67 = 1;
              }
              char v68 = !v67;
              *v64++ = v68;
              --v62;
            }
            while (v62);
          }
        }
        else if (v168 >= 1)
        {
          double v97 = v163;
          do
          {
            if (v58) {
              BOOL v98 = *v61 == 0;
            }
            else {
              BOOL v98 = 1;
            }
            char v99 = !v98;
            *v97++ = v99;
            v61 += v63;
            --v62;
          }
          while (v62);
        }
        ProShade::Value::set(a5, (const PCString *)1, *(_DWORD *)(a3 + 4), v60);
LABEL_119:
        long long v128 = v163;
        if (v163)
        {
          int v129 = *((_DWORD *)v163 - 1) - 1;
          *((_DWORD *)v163 - 1) = v129;
          if (!v129) {
            MEMORY[0x1BA9BFB70](v128 - 8, 0x1000C8077774924);
          }
        }
        long long v130 = v167;
        if (!v167) {
          return 1;
        }
        goto LABEL_123;
      }
      if ((int)Width >= 1)
      {
        unsigned __int8 v39 = *a2;
        uint64_t v40 = Width;
        long long v41 = &v167;
        do
        {
          char v42 = *a1++;
          *v41++ = v42 * v39;
          --v40;
        }
        while (v40);
      }
LABEL_26:
      ProShade::Value::set(a5, (const PCString *)1, *(_DWORD *)(a3 + 4), &v167);
      return 1;
    }
    BOOL v31 = ProShade::shapeIsVector(v28);
    int v32 = *(_DWORD *)(a3 + 4);
    if (v31 && v32 == 1)
    {
      uint64_t v33 = ProShade::shapeGetWidth(*(_DWORD *)(a4 + 4), v30);
      if ((int)v33 <= 4)
      {
        if ((int)v33 >= 1)
        {
          unsigned __int8 v34 = *a1;
          uint64_t v35 = v33;
          uint64_t v36 = &v167;
          do
          {
            char v37 = *a2++;
            *v36++ = v37 * v34;
            --v35;
          }
          while (v35);
        }
        goto LABEL_10;
      }
      PCGenVector<BOOL>::PCGenVector((uint64_t)&v167, (uint64_t)a2, v33, 0);
      int v86 = *a1;
      int v87 = v168;
      PCGenBlockRef<BOOL>::PCGenBlockRef(&v163, v168);
      unsigned int v164 = v87;
      int v165 = 1;
      long long v88 = v163;
      uint64_t v166 = v163;
      float64x2_t v89 = v170;
      uint64_t v90 = v168;
      uint64_t v91 = (int)v169;
      if (v169 == 1)
      {
        if (v168 >= 1)
        {
          long long v92 = v163;
          do
          {
            int v94 = *v89++;
            int v93 = v94;
            if (v86) {
              BOOL v95 = v93 == 0;
            }
            else {
              BOOL v95 = 1;
            }
            char v96 = !v95;
            *v92++ = v96;
            --v90;
          }
          while (v90);
        }
      }
      else if (v168 >= 1)
      {
        uint64_t v121 = v163;
        do
        {
          if (v86) {
            BOOL v122 = *v89 == 0;
          }
          else {
            BOOL v122 = 1;
          }
          char v123 = !v122;
          *v121++ = v123;
          v89 += v91;
          --v90;
        }
        while (v90);
      }
      ProShade::Value::set(a5, (const PCString *)1, *(_DWORD *)(a4 + 4), v88);
      goto LABEL_119;
    }
    if (!ProShade::shapeIsVector(v32)
      || !ProShade::shapeIsMatrix(*(_DWORD *)(a4 + 4))
      || (int v44 = ProShade::shapeGetWidth(*(_DWORD *)(a3 + 4), v43),
          v44 != ProShade::shapeGetWidth(*(_DWORD *)(a4 + 4), v45)))
    {
      BOOL result = ProShade::shapeIsMatrix(*(_DWORD *)(a3 + 4));
      if (!result) {
        return result;
      }
      uint64_t v71 = ProShade::shapeGetWidth(*(_DWORD *)(a3 + 4), v70);
      uint64_t v72 = v71;
      if ((int)v71 <= 4)
      {
        MEMORY[0x1F4188790](v71);
        double v74 = (char *)&v158[-1] - ((v73 + 15) & 0xFFFFFFFFFFFFFFF0);
        if ((int)v72 >= 1)
        {
          uint64_t v75 = 0;
          do
          {
            uint64_t v76 = 0;
            double v77 = (unsigned __int8 *)a2;
            do
            {
              BOOL v78 = 0;
              uint64_t v79 = v72;
              uint64_t v80 = a1;
              long long v81 = v77;
              do
              {
                int v83 = *v80++;
                int v82 = v83;
                int v84 = *v81;
                int v85 = v78;
                BOOL v78 = v85 + v84 * v83 != 0;
                v81 += v72;
                --v79;
              }
              while (v79);
              v74[v75 * v72 + v76++] = v85 != -(v84 * v82);
              ++v77;
            }
            while (v76 != v72);
            ++v75;
            a1 += v72;
          }
          while (v75 != v72);
        }
        ProShade::Value::set(a5, (const PCString *)1, *(_DWORD *)(a3 + 4), v74);
        return 1;
      }
      PCGenMatrix<BOOL>::PCGenMatrix((uint64_t)&v167, (uint64_t)a1, v71, v71, 1, 0);
      PCGenMatrix<BOOL>::PCGenMatrix((uint64_t)&v163, (uint64_t)a2, v72, v72, 1, 0);
      PCGenMatrix<BOOL>::PCGenMatrix((uint64_t)&v159, a5 + 16, v72, v72, 1, 0);
      operator%<BOOL>((uint64_t)&v167, (uint64_t)&v163, v158);
      PCGenMatrix<BOOL>::set<BOOL>((uint64_t)&v159, (uint64_t)v158);
      uint64_t v124 = v158[0];
      if (v158[0])
      {
        int v125 = *(_DWORD *)(v158[0] - 4) - 1;
        *(_DWORD *)(v158[0] - 4) = v125;
        if (!v125) {
          MEMORY[0x1BA9BFB70](v124 - 8, 0x1000C8077774924);
        }
      }
LABEL_116:
      long long v126 = v159;
      if (v159)
      {
        int v127 = *(v159 - 1) - 1;
        *(v159 - 1) = v127;
        if (!v127) {
          MEMORY[0x1BA9BFB70](v126 - 2, 0x1000C8077774924);
        }
      }
      goto LABEL_119;
    }
    uint64_t v47 = ProShade::shapeGetWidth(*(_DWORD *)(a4 + 4), v46);
    uint64_t v48 = v47;
    if ((int)v47 <= 4)
    {
      if ((int)v47 >= 1)
      {
        uint64_t v49 = 0;
        do
        {
          BOOL v50 = 0;
          uint64_t v51 = v47;
          double v52 = a1;
          double v53 = a2;
          do
          {
            int v55 = *v52++;
            int v54 = v55;
            int v56 = *v53;
            int v57 = v50;
            BOOL v50 = v57 + v56 * v55 != 0;
            v53 += v47;
            --v51;
          }
          while (v51);
          *((unsigned char *)&v167 + v49++) = v57 != -(v56 * v54);
          ++a2;
        }
        while (v49 != v47);
      }
      goto LABEL_26;
    }
    PCGenVector<BOOL>::PCGenVector((uint64_t)&v163, (uint64_t)a1, v47, 0);
    PCGenMatrix<BOOL>::PCGenMatrix((uint64_t)&v167, (uint64_t)a2, v48, v48, 1, 0);
    unsigned int v132 = v169;
    PCGenBlockRef<BOOL>::PCGenBlockRef(&v159, v169);
    unsigned int v160 = v132;
    int v161 = 1;
    long long v133 = v159;
    uint64_t v162 = v159;
    uint64_t v134 = v169;
    if ((int)v169 < 1)
    {
LABEL_150:
      ProShade::Value::set(a5, (const PCString *)1, *(_DWORD *)(a3 + 4), v133);
      double v153 = v159;
      if (v159)
      {
        int v154 = *(v159 - 1) - 1;
        *(v159 - 1) = v154;
        if (!v154) {
          MEMORY[0x1BA9BFB70](v153 - 2, 0x1000C8077774924);
        }
      }
      float32x2_t v155 = v167;
      if (v167)
      {
        int v156 = *(v167 - 1) - 1;
        *(v167 - 1) = v156;
        if (!v156) {
          MEMORY[0x1BA9BFB70](v155 - 2, 0x1000C8077774924);
        }
      }
      long long v130 = v163;
      if (!v163) {
        return 1;
      }
LABEL_123:
      int v131 = *(v130 - 1) - 1;
      *(v130 - 1) = v131;
      if (!v131) {
        MEMORY[0x1BA9BFB70](v130 - 2, 0x1000C8077774924);
      }
      return 1;
    }
    uint64_t v135 = 0;
    uint64_t v136 = v164;
    uint64_t v137 = v165;
    long long v138 = v171;
    uint64_t v139 = (int)v170;
    uint64_t v140 = SHIDWORD(v170);
    float v141 = v166;
    while (1)
    {
      if (v137 == 1)
      {
        if (v139 == 1)
        {
          if (v136)
          {
            uint64_t v142 = 0;
            BOOL v143 = 0;
            do
            {
              BOOL v143 = v143 != -(char)(v141[v142] * v138[v142]);
              ++v142;
            }
            while (v136 != v142);
            goto LABEL_149;
          }
        }
        else if ((int)v136 >= 1)
        {
          BOOL v143 = 0;
          long long v146 = v138;
          uint64_t v147 = v136;
          long long v148 = v141;
          do
          {
            char v149 = *v148++;
            BOOL v143 = v143 != -(char)(v149 * *v146);
            v146 += v139;
            --v147;
          }
          while (v147);
          goto LABEL_149;
        }
      }
      else if (v139 == 1)
      {
        if ((int)v136 >= 1)
        {
          uint64_t v144 = 0;
          BOOL v143 = 0;
          long long v145 = v141;
          do
          {
            BOOL v143 = v143 != -(char)(*v145 * v138[v144++]);
            v145 += v137;
          }
          while (v136 != v144);
          goto LABEL_149;
        }
      }
      else if ((int)v136 >= 1)
      {
        BOOL v143 = 0;
        long long v150 = v141;
        long long v151 = v138;
        uint64_t v152 = v136;
        do
        {
          BOOL v143 = v143 + *v151 * *v150 != 0;
          v151 += v139;
          v150 += v137;
          --v152;
        }
        while (v152);
        goto LABEL_149;
      }
      BOOL v143 = 0;
LABEL_149:
      *((unsigned char *)v133 + v135++) = v143;
      v138 += v140;
      if (v135 == v134) {
        goto LABEL_150;
      }
    }
  }
  uint64_t v14 = ProShade::shapeGetWidth(*(_DWORD *)(a3 + 4), v13);
  uint64_t v15 = v14;
  if ((int)v14 > 4)
  {
    PCGenMatrix<BOOL>::PCGenMatrix((uint64_t)&v167, (uint64_t)a1, v14, v14, 1, 0);
    PCGenVector<BOOL>::PCGenVector((uint64_t)&v163, (uint64_t)a2, v15, 0);
    int v100 = v168;
    PCGenBlockRef<BOOL>::PCGenBlockRef(&v159, v168);
    unsigned int v160 = v100;
    int v161 = 1;
    uint64_t v101 = v159;
    uint64_t v162 = v159;
    uint64_t v102 = v168;
    if (v168 >= 1)
    {
      uint64_t v103 = 0;
      long long v104 = v171;
      long long v105 = v166;
      uint64_t v106 = v165;
      uint64_t v108 = (int)v170;
      uint64_t v107 = SHIDWORD(v170);
      uint64_t v109 = v169;
      do
      {
        if (v107 == 1)
        {
          if (v106 == 1)
          {
            if (v109)
            {
              uint64_t v110 = 0;
              BOOL v111 = 0;
              do
              {
                BOOL v111 = v111 != -(char)(v104[v110] * v105[v110]);
                ++v110;
              }
              while (v109 != v110);
              goto LABEL_101;
            }
          }
          else if ((int)v109 >= 1)
          {
            uint64_t v116 = 0;
            BOOL v111 = 0;
            long long v117 = v105;
            do
            {
              BOOL v111 = v111 != -(char)(v104[v116++] * *v117);
              v117 += v106;
            }
            while (v109 != v116);
            goto LABEL_101;
          }
        }
        else if (v106 == 1)
        {
          if ((int)v109 >= 1)
          {
            BOOL v111 = 0;
            uint64_t v112 = v104;
            uint64_t v113 = v109;
            uint64_t v114 = v105;
            do
            {
              char v115 = *v114++;
              BOOL v111 = v111 != -(char)(*v112 * v115);
              v112 += v107;
              --v113;
            }
            while (v113);
            goto LABEL_101;
          }
        }
        else if ((int)v109 >= 1)
        {
          BOOL v111 = 0;
          long long v118 = v104;
          long long v119 = v105;
          uint64_t v120 = v109;
          do
          {
            BOOL v111 = v111 + *v119 * *v118 != 0;
            v119 += v106;
            v118 += v107;
            --v120;
          }
          while (v120);
          goto LABEL_101;
        }
        BOOL v111 = 0;
LABEL_101:
        v101[v103++] = v111;
        v104 += v108;
      }
      while (v103 != v102);
    }
    ProShade::Value::set(a5, (const PCString *)1, *(_DWORD *)(a4 + 4), v101);
    goto LABEL_116;
  }
  if ((int)v14 >= 1)
  {
    uint64_t v16 = 0;
    do
    {
      BOOL v17 = 0;
      uint64_t v18 = v14;
      size_t v19 = a2;
      int v20 = a1;
      do
      {
        int v22 = *v20++;
        int v21 = v22;
        int v24 = *v19++;
        int v23 = v24;
        int v25 = v17;
        BOOL v17 = v25 + v24 * v21 != 0;
        --v18;
      }
      while (v18);
      *((unsigned char *)&v167 + v16++) = v25 != -(v23 * v21);
      a1 += v14;
    }
    while (v16 != v14);
  }
LABEL_10:
  ProShade::Value::set(a5, (const PCString *)1, *(_DWORD *)(a4 + 4), &v167);
  return 1;
}

void sub_1B7ABF2EC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 - 152);
  if (v3)
  {
    int v4 = *(_DWORD *)(v3 - 4) - 1;
    *(_DWORD *)(v3 - 4) = v4;
    if (!v4) {
      MEMORY[0x1BA9BFB70](v3 - 8, 0x1000C8077774924);
    }
  }
  uint64_t v5 = *(void *)(v1 - 88);
  if (v5)
  {
    int v6 = *(_DWORD *)(v5 - 4) - 1;
    *(_DWORD *)(v5 - 4) = v6;
    if (!v6) {
      MEMORY[0x1BA9BFB70](v5 - 8, 0x1000C8077774924);
    }
  }
  uint64_t v7 = *(void *)(v1 - 120);
  if (v7)
  {
    int v8 = *(_DWORD *)(v7 - 4) - 1;
    *(_DWORD *)(v7 - 4) = v8;
    if (!v8) {
      MEMORY[0x1BA9BFB70](v7 - 8, 0x1000C8077774924);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t PCGenMatrix<BOOL>::set<BOOL>(uint64_t result, uint64_t a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    int v4 = *(_DWORD *)(result + 8);
    if (v4 != *(_DWORD *)(a2 + 8))
    {
      exception = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::ssprintf((PCString *)"PCGenMatrix row mismatch %d != %d", &v31, *(unsigned int *)(v3 + 8), *(unsigned int *)(a2 + 8));
      PCException::PCException(exception, &v31);
      *(void *)exception = &unk_1F10C2560;
    }
    int v5 = *(_DWORD *)(result + 12);
    if (v5 != *(_DWORD *)(a2 + 12))
    {
      PCString v30 = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::ssprintf((PCString *)"PCGenMatrix col mismatch %d != %d", &v31, *(unsigned int *)(v3 + 12), *(unsigned int *)(a2 + 12));
      PCException::PCException(v30, &v31);
      *(void *)PCString v30 = &unk_1F10C2560;
    }
    uint64_t v6 = *(void *)result;
    if (!*(void *)result)
    {
      BOOL result = (uint64_t)PCGenMatrix<BOOL>::resize((_DWORD *)result, v4, v5, *(_DWORD *)(result + 20) == 1);
      uint64_t v6 = *(void *)v3;
    }
    if (*(void *)a2 == v6)
    {
      v31.int var0 = 0;
      uint64_t v32 = 0;
      uint64_t v33 = 0x100000001;
      unsigned __int8 v34 = 0;
      BOOL result = PCGenMatrix<BOOL>::set<BOOL>(&v31, a2);
      uint64_t v17 = *(unsigned int *)(v3 + 8);
      if ((int)v17 >= 1)
      {
        uint64_t v18 = 0;
        uint64_t v19 = *(unsigned int *)(v3 + 12);
        int v20 = v34;
        uint64_t v22 = (int)v33;
        uint64_t v21 = SHIDWORD(v33);
        do
        {
          if ((int)v19 >= 1)
          {
            uint64_t v23 = *(int *)(v3 + 20);
            int v24 = (unsigned char *)(*(void *)(v3 + 24) + v18 * *(int *)(v3 + 16));
            uint64_t v25 = v19;
            double v26 = v20;
            do
            {
              BOOL result = *v26;
              unsigned char *v24 = result;
              v24 += v23;
              v26 += v21;
              --v25;
            }
            while (v25);
          }
          ++v18;
          v20 += v22;
        }
        while (v18 != v17);
      }
      int var0 = v31.var0;
      if (v31.var0)
      {
        int v28 = HIDWORD(v31.var0[-1].length) - 1;
        HIDWORD(v31.var0[-1].length) = v28;
        if (!v28) {
          return MEMORY[0x1BA9BFB70](&var0[-1].length, 0x1000C8077774924);
        }
      }
    }
    else
    {
      uint64_t v7 = *(unsigned int *)(v3 + 8);
      if ((int)v7 >= 1)
      {
        uint64_t v8 = 0;
        uint64_t v9 = *(unsigned int *)(v3 + 12);
        int v10 = *(unsigned __int8 **)(a2 + 24);
        uint64_t v12 = *(int *)(a2 + 16);
        uint64_t v11 = *(int *)(a2 + 20);
        do
        {
          if ((int)v9 >= 1)
          {
            uint64_t v13 = *(int *)(v3 + 20);
            uint64_t v14 = (unsigned char *)(*(void *)(v3 + 24) + v8 * *(int *)(v3 + 16));
            uint64_t v15 = v9;
            uint64_t v16 = v10;
            do
            {
              BOOL result = *v16;
              *uint64_t v14 = result;
              v14 += v13;
              v16 += v11;
              --v15;
            }
            while (v15);
          }
          ++v8;
          v10 += v12;
        }
        while (v8 != v7);
      }
    }
  }
  return result;
}

void sub_1B7ABF6F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCString a11)
{
}

void *operator%<BOOL>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(int *)(a1 + 8);
  int v6 = *(_DWORD *)(a2 + 12);
  BOOL result = PCGenBlockRef<BOOL>::PCGenBlockRef(a3, v6 * (int)v5);
  *((_DWORD *)result + 2) = v5;
  *((_DWORD *)result + 3) = v6;
  *((_DWORD *)result + 4) = 1;
  *((_DWORD *)result + 5) = v5;
  uint64_t v8 = *result;
  result[3] = *result;
  uint64_t v9 = *(unsigned int *)(a1 + 8);
  if ((int)v9 >= 1)
  {
    uint64_t v10 = 0;
    uint64_t v11 = *(unsigned char **)(a1 + 24);
    uint64_t v12 = *(unsigned char **)(a2 + 24);
    uint64_t v14 = *(int *)(a2 + 16);
    uint64_t v13 = *(int *)(a2 + 20);
    uint64_t v16 = *(int *)(a1 + 16);
    uint64_t v15 = *(int *)(a1 + 20);
    uint64_t v17 = *(unsigned int *)(a1 + 12);
    BOOL result = (void *)*(unsigned int *)(a2 + 12);
    while ((int)result < 1)
    {
LABEL_26:
      ++v10;
      v11 += v16;
      if (v10 == v9) {
        return result;
      }
    }
    uint64_t v18 = 0;
    uint64_t v19 = v12;
    while (1)
    {
      if (v15 == 1)
      {
        if (v14 == 1)
        {
          if (v17)
          {
            uint64_t v20 = 0;
            BOOL v21 = 0;
            do
            {
              BOOL v21 = v21 != -(char)(v11[v20] * v19[v20]);
              ++v20;
            }
            while (v17 != v20);
            goto LABEL_25;
          }
        }
        else if ((int)v17 >= 1)
        {
          uint64_t v24 = 0;
          BOOL v21 = 0;
          uint64_t v25 = v19;
          do
          {
            BOOL v21 = v21 != -(char)(v11[v24++] * *v25);
            v25 += v14;
          }
          while (v17 != v24);
          goto LABEL_25;
        }
      }
      else if (v14 == 1)
      {
        if ((int)v17 >= 1)
        {
          uint64_t v22 = 0;
          BOOL v21 = 0;
          uint64_t v23 = v11;
          do
          {
            BOOL v21 = v21 != -(char)(*v23 * v19[v22++]);
            v23 += v15;
          }
          while (v17 != v22);
          goto LABEL_25;
        }
      }
      else if ((int)v17 >= 1)
      {
        BOOL v21 = 0;
        double v26 = v11;
        double v27 = v19;
        uint64_t v28 = v17;
        do
        {
          BOOL v21 = v21 + *v27 * *v26 != 0;
          v27 += v14;
          v26 += v15;
          --v28;
        }
        while (v28);
        goto LABEL_25;
      }
      BOOL v21 = 0;
LABEL_25:
      *(unsigned char *)(v8 + v10 + (void)v18 * v5) = v21;
      uint64_t v18 = (void *)((char *)v18 + 1);
      v19 += v13;
      if (v18 == result) {
        goto LABEL_26;
      }
    }
  }
  return result;
}

uint64_t PCGenMatrix<BOOL>::PCGenMatrix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 12) = a4;
  if (a5) {
    int v7 = a4;
  }
  else {
    int v7 = 1;
  }
  if (a5) {
    int v8 = 1;
  }
  else {
    int v8 = a3;
  }
  *(_DWORD *)(a1 + 16) = v7;
  *(_DWORD *)(a1 + 20) = v8;
  if ((a3 & 0x80000000) != 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::ssprintf((PCString *)"PCGenMatrix number of rows %d must be nonnegative", &v16, a3);
    PCException::PCException(exception, &v16);
    *(void *)exception = &unk_1F10C2560;
  }
  if ((a4 & 0x80000000) != 0)
  {
    uint64_t v15 = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::ssprintf((PCString *)"PCGenMatrix number of cols %d must be nonnegative", &v16, a4);
    PCException::PCException(v15, &v16);
    *(void *)uint64_t v15 = &unk_1F10C2560;
  }
  *(void *)(a1 + 24) = a2;
  if (a6)
  {
    PCGenMatrix<BOOL>::copy(a1, 0, (uint64_t)&v16);
    int var0 = v16.var0;
    if (&v16 != (PCString *)a1)
    {
      *(_OWORD *)(a1 + 8) = v17;
      if (*(__CFString **)a1 != var0)
      {
        PCGenBlockRef<double>::deref((void *)a1);
        *(void *)a1 = var0;
        if (var0) {
          ++HIDWORD(var0[-1].length);
        }
      }
      int var0 = v16.var0;
      *(void *)(a1 + 24) = v18;
    }
    if (var0)
    {
      int v11 = HIDWORD(var0[-1].length) - 1;
      HIDWORD(var0[-1].length) = v11;
      if (!v11) {
        MEMORY[0x1BA9BFB70](&var0[-1].length, 0x1000C8077774924);
      }
    }
  }
  return a1;
}

void sub_1B7ABFAD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCString a11)
{
  if (a11.var0)
  {
    int v13 = HIDWORD(a11.var0[-1].length) - 1;
    HIDWORD(a11.var0[-1].length) = v13;
    if (!v13) {
      MEMORY[0x1BA9BFB70](&a11.var0[-1].length, 0x1000C8077774924);
    }
  }
  PCGenBlockRef<double>::deref(v11);
  _Unwind_Resume(a1);
}

uint64_t PCGenMatrix<BOOL>::copy@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  int v6 = *(_DWORD *)(a1 + 8);
  int v7 = *(_DWORD *)(a1 + 12);
  PCGenBlockRef<BOOL>::PCGenBlockRef((void *)a3, v7 * v6);
  *(_DWORD *)(a3 + 8) = v6;
  *(_DWORD *)(a3 + 12) = v7;
  if (a2) {
    int v8 = v7;
  }
  else {
    int v8 = 1;
  }
  if (a2) {
    int v9 = 1;
  }
  else {
    int v9 = v6;
  }
  *(_DWORD *)(a3 + 16) = v8;
  *(_DWORD *)(a3 + 20) = v9;
  *(void *)(a3 + 24) = *(void *)a3;
  return PCGenMatrix<BOOL>::set<BOOL>(a3, a1);
}

void sub_1B7ABFBD0(_Unwind_Exception *a1)
{
  PCGenBlockRef<double>::deref(v1);
  _Unwind_Resume(a1);
}

void *PCGenBlockRef<BOOL>::PCGenBlockRef(void *result, int a2)
{
  if (a2) {
    operator new[]();
  }
  *BOOL result = 0;
  return result;
}

uint64_t PCGenVector<BOOL>::PCGenVector(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 12) = 1;
  if ((a3 & 0x80000000) != 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::ssprintf((PCString *)"PCGenVector length %d must be nonnegative", &v10, a3);
    PCException::PCException(exception, &v10);
    *(void *)exception = &unk_1F10C2560;
  }
  *(void *)(a1 + 16) = a2;
  if (a4)
  {
    PCGenBlockRef<BOOL>::PCGenBlockRef(&v10, a3);
    uint64_t v11 = a3 | 0x100000000;
    int var0 = v10.var0;
    PCGenVector<BOOL>::set<BOOL>((uint64_t)&v10, a1);
    int v6 = v10.var0;
    if (&v10 != (PCString *)a1)
    {
      *(void *)(a1 + 8) = v11;
      if (*(__CFString **)a1 != v6)
      {
        PCGenBlockRef<double>::deref((void *)a1);
        *(void *)a1 = v6;
        if (v6) {
          ++HIDWORD(v6[-1].length);
        }
      }
      int v6 = v10.var0;
      *(void *)(a1 + 16) = var0;
    }
    if (v6)
    {
      int v7 = HIDWORD(v6[-1].length) - 1;
      HIDWORD(v6[-1].length) = v7;
      if (!v7) {
        MEMORY[0x1BA9BFB70](&v6[-1].length, 0x1000C8077774924);
      }
    }
  }
  return a1;
}

void sub_1B7ABFDBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  if (a10.var0)
  {
    int v12 = HIDWORD(a10.var0[-1].length) - 1;
    HIDWORD(a10.var0[-1].length) = v12;
    if (!v12) {
      MEMORY[0x1BA9BFB70](&a10.var0[-1].length, 0x1000C8077774924);
    }
  }
  PCGenBlockRef<double>::deref(v10);
  _Unwind_Resume(a1);
}

uint64_t PCGenVector<BOOL>::set<BOOL>(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    uint64_t v4 = *(unsigned int *)(a1 + 8);
    if (v4 != *(_DWORD *)(a2 + 8))
    {
      exception = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::ssprintf((PCString *)"PCGenVector length mismatch %d != %d", &v19, *(unsigned int *)(a1 + 8), *(unsigned int *)(a2 + 8));
      PCException::PCException(exception, &v19);
      *(void *)exception = &unk_1F10C2560;
    }
    if (*(void *)a1) {
      BOOL v5 = *(void *)a2 == *(void *)a1;
    }
    else {
      BOOL v5 = 0;
    }
    if (v5)
    {
      PCGenBlockRef<BOOL>::PCGenBlockRef(&v19, *(_DWORD *)(a1 + 8));
      int v20 = v4;
      int v21 = 1;
      int var0 = v19.var0;
      PCGenVector<BOOL>::set<BOOL>(&v19, a2);
      uint64_t v10 = *(unsigned int *)(a1 + 8);
      if ((int)v10 >= 1)
      {
        uint64_t v11 = var0;
        uint64_t v12 = v21;
        int v13 = *(unsigned char **)(a1 + 16);
        uint64_t v14 = *(int *)(a1 + 12);
        do
        {
          *int v13 = v11->isa;
          v13 += v14;
          uint64_t v11 = (__CFString *)((char *)v11 + v12);
          --v10;
        }
        while (v10);
      }
      uint64_t v15 = v19.var0;
      if (v19.var0)
      {
        int v16 = HIDWORD(v19.var0[-1].length) - 1;
        HIDWORD(v19.var0[-1].length) = v16;
        if (!v16) {
          MEMORY[0x1BA9BFB70](&v15[-1].length, 0x1000C8077774924);
        }
      }
    }
    else if ((int)v4 >= 1)
    {
      int v6 = *(unsigned char **)(a2 + 16);
      uint64_t v7 = *(int *)(a2 + 12);
      int v8 = *(unsigned char **)(a1 + 16);
      uint64_t v9 = *(int *)(a1 + 12);
      do
      {
        unsigned char *v8 = *v6;
        v8 += v9;
        v6 += v7;
        --v4;
      }
      while (v4);
    }
  }
  return a1;
}

void sub_1B7ABFFD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCString a12)
{
}

_DWORD *PCGenMatrix<BOOL>::resize(_DWORD *result, int a2, int a3, int a4)
{
  uint64_t v6 = (uint64_t)result;
  int v8 = result[2];
  int v7 = result[3];
  BOOL v10 = v8 != a2 || v7 != a3;
  if (a4)
  {
    if (a4 == 1)
    {
      if (result[5] == 1)
      {
        if (result[4] != v7) {
          LOBYTE(v10) = 1;
        }
        if (!v10) {
          return result;
        }
      }
    }
    else if (!v10)
    {
      return result;
    }
    int v11 = 0;
LABEL_21:
    BOOL result = PCGenBlockRef<BOOL>::PCGenBlockRef(&v32, a3 * a2);
    *(void *)&long long v33 = __PAIR64__(a3, a2);
    if (v11) {
      int v12 = 1;
    }
    else {
      int v12 = a3;
    }
    if (v11) {
      int v13 = a2;
    }
    else {
      int v13 = 1;
    }
    *((void *)&v33 + 1) = __PAIR64__(v13, v12);
    int v14 = *(_DWORD *)(v6 + 12);
    if (a2 >= *(_DWORD *)(v6 + 8)) {
      int v15 = *(_DWORD *)(v6 + 8);
    }
    else {
      int v15 = a2;
    }
    uint64_t v16 = v32;
    uint64_t v34 = v32;
    if (a3 >= v14) {
      int v17 = v14;
    }
    else {
      int v17 = a3;
    }
    unsigned int v18 = v15 - 1;
    if (v15 >= 1 && v17 >= 1)
    {
      v30[0] = 0;
      v30[1] = v15 - 1;
      unsigned int v20 = v17 - 1;
      v29[0] = 0;
      v29[1] = v17 - 1;
      PCGenMatrix<BOOL>::operator()((uint64_t)result, v30, v29, (uint64_t)v31);
      v27[0] = 0;
      v27[1] = v18;
      v26[0] = 0;
      v26[1] = v20;
      PCGenMatrix<BOOL>::operator()(v6, v27, v26, (uint64_t)v28);
      BOOL result = (_DWORD *)PCGenMatrix<BOOL>::set<BOOL>(v31, v28);
      uint64_t v21 = v28[0];
      if (v28[0])
      {
        int v22 = *(_DWORD *)(v28[0] - 4) - 1;
        *(_DWORD *)(v28[0] - 4) = v22;
        if (!v22) {
          BOOL result = (_DWORD *)MEMORY[0x1BA9BFB70](v21 - 8, 0x1000C8077774924);
        }
      }
      uint64_t v23 = v31[0];
      if (v31[0])
      {
        int v24 = *(_DWORD *)(v31[0] - 4) - 1;
        *(_DWORD *)(v31[0] - 4) = v24;
        if (!v24) {
          BOOL result = (_DWORD *)MEMORY[0x1BA9BFB70](v23 - 8, 0x1000C8077774924);
        }
      }
      uint64_t v16 = v32;
    }
    if (&v32 != (uint64_t *)v6)
    {
      *(_OWORD *)(v6 + 8) = v33;
      if (*(void *)v6 != v16)
      {
        BOOL result = PCGenBlockRef<double>::deref((void *)v6);
        *(void *)uint64_t v6 = v16;
        if (v16) {
          ++*(_DWORD *)(v16 - 4);
        }
      }
      uint64_t v16 = v32;
      *(void *)(v6 + 24) = v34;
    }
    if (v16)
    {
      int v25 = *(_DWORD *)(v16 - 4) - 1;
      *(_DWORD *)(v16 - 4) = v25;
      if (!v25) {
        return (_DWORD *)MEMORY[0x1BA9BFB70](v16 - 8, 0x1000C8077774924);
      }
    }
    return result;
  }
  if (result[4] != 1) {
    goto LABEL_18;
  }
  if (result[5] != v8) {
    LOBYTE(v10) = 1;
  }
  if (v10)
  {
LABEL_18:
    int v11 = 1;
    goto LABEL_21;
  }
  return result;
}

void sub_1B7AC0250(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  uint64_t v19 = *(void *)(v17 - 80);
  if (v19)
  {
    int v20 = *(_DWORD *)(v19 - 4) - 1;
    *(_DWORD *)(v19 - 4) = v20;
    if (!v20) {
      MEMORY[0x1BA9BFB70](v19 - 8, 0x1000C8077774924);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t PCGenMatrix<BOOL>::operator()@<X0>(uint64_t a1@<X0>, unsigned int *a2@<X1>, unsigned int *a3@<X2>, uint64_t a4@<X8>)
{
  PCGenMatrix<BOOL>::checkRowIndex(a1, *a2);
  PCGenMatrix<BOOL>::checkRowIndex(a1, a2[1]);
  PCGenMatrix<BOOL>::checkColIndex(a1, *a3);
  uint64_t result = PCGenMatrix<BOOL>::checkColIndex(a1, a3[1]);
  int v10 = *a2;
  unsigned int v9 = a2[1];
  int v12 = *a3;
  unsigned int v11 = a3[1];
  int v14 = *(_DWORD *)(a1 + 16);
  int v13 = *(_DWORD *)(a1 + 20);
  uint64_t v15 = *(void *)(a1 + 24);
  uint64_t v16 = *(void *)a1;
  *(void *)a4 = *(void *)a1;
  if (v16) {
    ++*(_DWORD *)(v16 - 4);
  }
  *(_DWORD *)(a4 + 8) = v9 - v10 + 1;
  *(_DWORD *)(a4 + 12) = v11 - v12 + 1;
  *(_DWORD *)(a4 + 16) = v14;
  *(_DWORD *)(a4 + 20) = v13;
  *(void *)(a4 + 24) = v15 + v14 * v10 + v13 * v12;
  return result;
}

uint64_t PCGenMatrix<BOOL>::checkRowIndex(uint64_t result, uint64_t a2)
{
  if ((a2 & 0x80000000) != 0 || *(_DWORD *)(result + 8) <= (int)a2)
  {
    uint64_t v3 = result;
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::ssprintf((PCString *)"PCGenMatrix row %d out of range 0..%d", &v5, a2, (*(_DWORD *)(v3 + 8) - 1));
    PCException::PCException(exception, &v5);
    *(void *)exception = &unk_1F10C2560;
  }
  return result;
}

void sub_1B7AC046C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCString a12)
{
}

uint64_t PCGenMatrix<BOOL>::checkColIndex(uint64_t result, uint64_t a2)
{
  if ((a2 & 0x80000000) != 0 || *(_DWORD *)(result + 12) <= (int)a2)
  {
    uint64_t v3 = result;
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::ssprintf((PCString *)"PCGenMatrix col %d out of range 0..%d", &v5, a2, (*(_DWORD *)(v3 + 12) - 1));
    PCException::PCException(exception, &v5);
    *(void *)exception = &unk_1F10C2560;
  }
  return result;
}

void sub_1B7AC0558(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCString a12)
{
}

BOOL ProShade::Multiply::computeBinaryType<int>(int *a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v195 = *MEMORY[0x1E4F143B8];
  if (!ProShade::shapeIsMatrix(*(_DWORD *)(a3 + 4))
    || !ProShade::shapeIsVector(*(_DWORD *)(a4 + 4))
    || (int v11 = ProShade::shapeGetWidth(*(_DWORD *)(a3 + 4), v10),
        v11 != ProShade::shapeGetWidth(*(_DWORD *)(a4 + 4), v12)))
  {
    BOOL IsVector = ProShade::shapeIsVector(*(_DWORD *)(a3 + 4));
    int v26 = *(_DWORD *)(a4 + 4);
    if (IsVector && v26 == 1)
    {
      uint64_t Width = ProShade::shapeGetWidth(*(_DWORD *)(a3 + 4), v24);
      if ((int)Width > 4)
      {
        PCGenVector<int>::PCGenVector((uint64_t)&v190, (uint64_t)a1, Width, 0);
        int v53 = *a2;
        int v54 = v191;
        PCGenBlockRef<int>::PCGenBlockRef(&v185, v191);
        unsigned int v186 = v54;
        int v187 = 1;
        int v55 = v185;
        float32x4_t v188 = (int *)v185;
        int v56 = v193;
        uint64_t v57 = v191;
        if (v192 == 1)
        {
          if (v191 >= 1)
          {
            int v58 = v185;
            do
            {
              int v59 = *v56++;
              *v58++ = v59 * v53;
              --v57;
            }
            while (v57);
          }
        }
        else if (v191 >= 1)
        {
          uint64_t v82 = 4 * (int)v192;
          int v83 = v185;
          do
          {
            *v83++ = *v56 * v53;
            int v56 = (int *)((char *)v56 + v82);
            --v57;
          }
          while (v57);
        }
        ProShade::Value::set(a5, (const PCString *)2, *(_DWORD *)(a3 + 4), v55);
LABEL_121:
        uint64_t v142 = v185;
        if (v185)
        {
          int v143 = *((_DWORD *)v185 - 1) - 1;
          *((_DWORD *)v185 - 1) = v143;
          if (!v143) {
            MEMORY[0x1BA9BFB70](v142 - 8, 0x1000C8077774924);
          }
        }
        uint64_t v144 = v190;
        if (!v190) {
          return 1;
        }
        goto LABEL_125;
      }
      if ((int)Width >= 1)
      {
        int v37 = *a2;
        uint64_t v38 = Width;
        unsigned __int8 v39 = &v190;
        do
        {
          int v40 = *a1++;
          *v39++ = v40 * v37;
          --v38;
        }
        while (v38);
      }
LABEL_26:
      ProShade::Value::set(a5, (const PCString *)2, *(_DWORD *)(a3 + 4), &v190);
      return 1;
    }
    BOOL v29 = ProShade::shapeIsVector(v26);
    int v30 = *(_DWORD *)(a3 + 4);
    if (v29 && v30 == 1)
    {
      uint64_t v31 = ProShade::shapeGetWidth(*(_DWORD *)(a4 + 4), v28);
      if ((int)v31 <= 4)
      {
        if ((int)v31 >= 1)
        {
          int v32 = *a1;
          uint64_t v33 = v31;
          uint64_t v34 = &v190;
          do
          {
            int v35 = *a2++;
            *v34++ = v35 * v32;
            --v33;
          }
          while (v33);
        }
        goto LABEL_10;
      }
      PCGenVector<int>::PCGenVector((uint64_t)&v190, (uint64_t)a2, v31, 0);
      int v75 = *a1;
      int v76 = v191;
      PCGenBlockRef<int>::PCGenBlockRef(&v185, v191);
      unsigned int v186 = v76;
      int v187 = 1;
      double v77 = v185;
      float32x4_t v188 = (int *)v185;
      BOOL v78 = v193;
      uint64_t v79 = v191;
      if (v192 == 1)
      {
        if (v191 >= 1)
        {
          uint64_t v80 = v185;
          do
          {
            int v81 = *v78++;
            *v80++ = v81 * v75;
            --v79;
          }
          while (v79);
        }
      }
      else if (v191 >= 1)
      {
        uint64_t v108 = 4 * (int)v192;
        uint64_t v109 = v185;
        do
        {
          *v109++ = *v78 * v75;
          BOOL v78 = (int *)((char *)v78 + v108);
          --v79;
        }
        while (v79);
      }
      ProShade::Value::set(a5, (const PCString *)2, *(_DWORD *)(a4 + 4), v77);
      goto LABEL_121;
    }
    if (ProShade::shapeIsVector(v30) && ProShade::shapeIsMatrix(*(_DWORD *)(a4 + 4)))
    {
      int v42 = ProShade::shapeGetWidth(*(_DWORD *)(a3 + 4), v41);
      if (v42 == ProShade::shapeGetWidth(*(_DWORD *)(a4 + 4), v43))
      {
        uint64_t v45 = ProShade::shapeGetWidth(*(_DWORD *)(a4 + 4), v44);
        uint64_t v46 = v45;
        if ((int)v45 <= 4)
        {
          if ((int)v45 >= 1)
          {
            uint64_t v47 = 0;
            do
            {
              int v48 = 0;
              uint64_t v49 = v45;
              BOOL v50 = a1;
              uint64_t v51 = a2;
              do
              {
                int v52 = *v50++;
                v48 += *v51 * v52;
                v51 += v45;
                --v49;
              }
              while (v49);
              *((_DWORD *)&v190 + v47++) = v48;
              ++a2;
            }
            while (v47 != v45);
          }
          goto LABEL_26;
        }
        PCGenVector<int>::PCGenVector((uint64_t)&v185, (uint64_t)a1, v45, 0);
        PCGenMatrix<int>::PCGenMatrix((uint64_t)&v190, (uint64_t)a2, v46, v46, 1, 0);
        unsigned int v146 = v192;
        PCGenBlockRef<int>::PCGenBlockRef(&v181, v192);
        unsigned int v182 = v146;
        int v183 = 1;
        uint64_t v147 = v181;
        float32x4_t v184 = v181;
        uint64_t v148 = v192;
        if ((int)v192 < 1)
        {
LABEL_152:
          ProShade::Value::set(a5, (const PCString *)2, *(_DWORD *)(a3 + 4), v147);
          int32x4_t v170 = v181;
          if (v181)
          {
            int v171 = *((_DWORD *)v181 - 1) - 1;
            *((_DWORD *)v181 - 1) = v171;
            if (!v171) {
              MEMORY[0x1BA9BFB70](v170 - 8, 0x1000C8077774924);
            }
          }
          uint64_t v172 = v190;
          if (v190)
          {
            int v173 = *(v190 - 1) - 1;
            *(v190 - 1) = v173;
            if (!v173) {
              MEMORY[0x1BA9BFB70](v172 - 2, 0x1000C8077774924);
            }
          }
          uint64_t v144 = v185;
          if (!v185) {
            return 1;
          }
LABEL_125:
          int v145 = *(v144 - 1) - 1;
          *(v144 - 1) = v145;
          if (!v145) {
            MEMORY[0x1BA9BFB70](v144 - 2, 0x1000C8077774924);
          }
          return 1;
        }
        uint64_t v149 = 0;
        uint64_t v150 = v186;
        int v151 = v187;
        uint64_t v152 = v194;
        int v153 = (int)v193;
        uint64_t v154 = 4 * SHIDWORD(v193);
        uint64_t v155 = 4 * (int)v193;
        int v156 = v188;
        uint64_t v157 = 4 * v187;
        uint64_t v158 = 4 * v186;
        while (1)
        {
          if (v151 == 1)
          {
            if (v153 == 1)
            {
              if (v150)
              {
                uint64_t v159 = 0;
                int v160 = 0;
                do
                {
                  v160 += v152[v159] * v156[v159];
                  ++v159;
                }
                while (v150 != v159);
                goto LABEL_151;
              }
            }
            else if ((int)v150 >= 1)
            {
              int v160 = 0;
              long long v163 = v152;
              uint64_t v164 = v150;
              int v165 = v156;
              do
              {
                int v166 = *v165++;
                v160 += *v163 * v166;
                long long v163 = (_DWORD *)((char *)v163 + v155);
                --v164;
              }
              while (v164);
              goto LABEL_151;
            }
          }
          else if (v153 == 1)
          {
            if ((int)v150 >= 1)
            {
              unint64_t v161 = 0;
              int v160 = 0;
              uint64_t v162 = v156;
              do
              {
                v160 += v152[v161 / 4] * *v162;
                v161 += 4;
                uint64_t v162 = (int *)((char *)v162 + v157);
              }
              while (v158 != v161);
              goto LABEL_151;
            }
          }
          else if ((int)v150 >= 1)
          {
            int v160 = 0;
            int v167 = v156;
            int v168 = v152;
            uint64_t v169 = v150;
            do
            {
              v160 += *v168 * *v167;
              int v168 = (_DWORD *)((char *)v168 + v155);
              int v167 = (int *)((char *)v167 + v157);
              --v169;
            }
            while (v169);
            goto LABEL_151;
          }
          int v160 = 0;
LABEL_151:
          *((_DWORD *)v147 + v149++) = v160;
          uint64_t v152 = (_DWORD *)((char *)v152 + v154);
          if (v149 == v148) {
            goto LABEL_152;
          }
        }
      }
    }
    BOOL result = ProShade::shapeIsMatrix(*(_DWORD *)(a3 + 4));
    if (!result) {
      return result;
    }
    uint64_t v62 = ProShade::shapeGetWidth(*(_DWORD *)(a3 + 4), v61);
    uint64_t v63 = v62;
    if ((int)v62 <= 4)
    {
      MEMORY[0x1F4188790](v62);
      int v65 = (char *)&v174 - ((v64 + 15) & 0xFFFFFFFFFFFFFFF0);
      if ((int)v63 >= 1)
      {
        uint64_t v66 = 0;
        uint64_t v67 = 4 * v63;
        do
        {
          uint64_t v68 = 0;
          uint64_t v69 = a2;
          do
          {
            int v70 = 0;
            uint64_t v71 = v63;
            uint64_t v72 = a1;
            uint64_t v73 = v69;
            do
            {
              int v74 = *v72++;
              v70 += *v73 * v74;
              uint64_t v73 = (int *)((char *)v73 + v67);
              --v71;
            }
            while (v71);
            *(_DWORD *)&v65[4 * v66 * v63 + 4 * v68++] = v70;
            ++v69;
          }
          while (v68 != v63);
          ++v66;
          a1 = (int *)((char *)a1 + v67);
        }
        while (v66 != v63);
      }
      ProShade::Value::set(a5, (const PCString *)2, *(_DWORD *)(a3 + 4), v65);
      return 1;
    }
    PCGenMatrix<int>::PCGenMatrix((uint64_t)&v190, (uint64_t)a1, v62, v62, 1, 0);
    PCGenMatrix<int>::PCGenMatrix((uint64_t)&v185, (uint64_t)a2, v63, v63, 1, 0);
    PCGenMatrix<int>::PCGenMatrix((uint64_t)&v181, a5 + 16, v63, v63, 1, 0);
    int v110 = v191;
    int v111 = v187;
    PCGenBlockRef<int>::PCGenBlockRef(&v175, v187 * v191);
    int v176 = v110;
    int v177 = v111;
    int v178 = 1;
    int v179 = v110;
    uint64_t v112 = v175;
    uint64_t v180 = v175;
    uint64_t v113 = v191;
    if (v191 < 1)
    {
LABEL_115:
      PCGenMatrix<int>::set<int>(&v181, (uint64_t)&v175);
      uint64_t v138 = v175;
      if (v175)
      {
        int v139 = *(_DWORD *)(v175 - 4) - 1;
        *(_DWORD *)(v175 - 4) = v139;
        if (!v139) {
          MEMORY[0x1BA9BFB70](v138 - 8, 0x1000C8077774924);
        }
      }
LABEL_118:
      uint64_t v140 = v181;
      if (v181)
      {
        int v141 = *((_DWORD *)v181 - 1) - 1;
        *((_DWORD *)v181 - 1) = v141;
        if (!v141) {
          MEMORY[0x1BA9BFB70](v140 - 8, 0x1000C8077774924);
        }
      }
      goto LABEL_121;
    }
    uint64_t v114 = 0;
    uint64_t v115 = v110;
    uint64_t v116 = v194;
    long long v117 = v189;
    int v118 = (int)v188;
    uint64_t v119 = v192;
    uint64_t v120 = v187;
    uint64_t v121 = 4 * SHIDWORD(v188);
    uint64_t v122 = 4 * (int)v188;
    uint64_t v123 = 4 * (int)v193;
    int v124 = HIDWORD(v193);
    uint64_t v125 = 4 * SHIDWORD(v193);
    uint64_t v126 = 4 * v192;
    while ((int)v120 < 1)
    {
LABEL_114:
      ++v114;
      uint64_t v116 = (_DWORD *)((char *)v116 + v123);
      if (v114 == v113) {
        goto LABEL_115;
      }
    }
    uint64_t v127 = 0;
    long long v128 = v117;
    while (1)
    {
      if (v124 == 1)
      {
        if (v118 == 1)
        {
          if (v119)
          {
            uint64_t v129 = 0;
            int v130 = 0;
            do
            {
              v130 += v128[v129] * v116[v129];
              ++v129;
            }
            while (v119 != v129);
            goto LABEL_113;
          }
        }
        else if ((int)v119 >= 1)
        {
          unint64_t v133 = 0;
          int v130 = 0;
          uint64_t v134 = v128;
          do
          {
            v130 += *v134 * v116[v133 / 4];
            v133 += 4;
            uint64_t v134 = (_DWORD *)((char *)v134 + v122);
          }
          while (v126 != v133);
          goto LABEL_113;
        }
      }
      else if (v118 == 1)
      {
        if ((int)v119 >= 1)
        {
          unint64_t v131 = 0;
          int v130 = 0;
          unsigned int v132 = v116;
          do
          {
            v130 += v128[v131 / 4] * *v132;
            v131 += 4;
            unsigned int v132 = (_DWORD *)((char *)v132 + v125);
          }
          while (v126 != v131);
          goto LABEL_113;
        }
      }
      else if ((int)v119 >= 1)
      {
        int v130 = 0;
        uint64_t v135 = v116;
        uint64_t v136 = v128;
        uint64_t v137 = v119;
        do
        {
          v130 += *v136 * *v135;
          uint64_t v136 = (_DWORD *)((char *)v136 + v122);
          uint64_t v135 = (_DWORD *)((char *)v135 + v125);
          --v137;
        }
        while (v137);
        goto LABEL_113;
      }
      int v130 = 0;
LABEL_113:
      *(_DWORD *)(v112 + 4 * (v114 + v127 * v115)) = v130;
      ++v127;
      long long v128 = (_DWORD *)((char *)v128 + v121);
      if (v127 == v120) {
        goto LABEL_114;
      }
    }
  }
  uint64_t v14 = ProShade::shapeGetWidth(*(_DWORD *)(a3 + 4), v13);
  uint64_t v15 = v14;
  if ((int)v14 > 4)
  {
    PCGenMatrix<int>::PCGenMatrix((uint64_t)&v190, (uint64_t)a1, v14, v14, 1, 0);
    PCGenVector<int>::PCGenVector((uint64_t)&v185, (uint64_t)a2, v15, 0);
    int v84 = v191;
    PCGenBlockRef<int>::PCGenBlockRef(&v181, v191);
    unsigned int v182 = v84;
    int v183 = 1;
    int v85 = v181;
    float32x4_t v184 = v181;
    uint64_t v86 = v191;
    if (v191 >= 1)
    {
      uint64_t v87 = 0;
      long long v88 = v194;
      float64x2_t v89 = v188;
      int v90 = v187;
      uint64_t v91 = v192;
      uint64_t v92 = 4 * v187;
      uint64_t v93 = 4 * (int)v193;
      int v94 = HIDWORD(v193);
      uint64_t v95 = 4 * SHIDWORD(v193);
      uint64_t v96 = 4 * v192;
      do
      {
        if (v94 == 1)
        {
          if (v90 == 1)
          {
            if (v91)
            {
              uint64_t v97 = 0;
              int v98 = 0;
              do
              {
                v98 += v89[v97] * v88[v97];
                ++v97;
              }
              while (v91 != v97);
              goto LABEL_83;
            }
          }
          else if ((int)v91 >= 1)
          {
            unint64_t v103 = 0;
            int v98 = 0;
            long long v104 = v89;
            do
            {
              v98 += *v104 * v88[v103 / 4];
              v103 += 4;
              long long v104 = (int *)((char *)v104 + v92);
            }
            while (v96 != v103);
            goto LABEL_83;
          }
        }
        else if (v90 == 1)
        {
          if ((int)v91 >= 1)
          {
            int v98 = 0;
            char v99 = v88;
            uint64_t v100 = v91;
            uint64_t v101 = v89;
            do
            {
              int v102 = *v101++;
              v98 += v102 * *v99;
              char v99 = (_DWORD *)((char *)v99 + v95);
              --v100;
            }
            while (v100);
            goto LABEL_83;
          }
        }
        else if ((int)v91 >= 1)
        {
          int v98 = 0;
          long long v105 = v88;
          uint64_t v106 = v89;
          uint64_t v107 = v91;
          do
          {
            v98 += *v106 * *v105;
            uint64_t v106 = (int *)((char *)v106 + v92);
            long long v105 = (_DWORD *)((char *)v105 + v95);
            --v107;
          }
          while (v107);
          goto LABEL_83;
        }
        int v98 = 0;
LABEL_83:
        v85[v87++] = v98;
        long long v88 = (_DWORD *)((char *)v88 + v93);
      }
      while (v87 != v86);
    }
    ProShade::Value::set(a5, (const PCString *)2, *(_DWORD *)(a4 + 4), v85);
    goto LABEL_118;
  }
  if ((int)v14 >= 1)
  {
    uint64_t v16 = 0;
    do
    {
      int v17 = 0;
      uint64_t v18 = v14;
      uint64_t v19 = a2;
      int v20 = a1;
      do
      {
        int v22 = *v20++;
        int v21 = v22;
        int v23 = *v19++;
        v17 += v23 * v21;
        --v18;
      }
      while (v18);
      *((_DWORD *)&v190 + v16++) = v17;
      a1 += v14;
    }
    while (v16 != v14);
  }
LABEL_10:
  ProShade::Value::set(a5, (const PCString *)2, *(_DWORD *)(a4 + 4), &v190);
  return 1;
}

void sub_1B7AC10A0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 - 152);
  if (v3)
  {
    int v4 = *(_DWORD *)(v3 - 4) - 1;
    *(_DWORD *)(v3 - 4) = v4;
    if (!v4) {
      MEMORY[0x1BA9BFB70](v3 - 8, 0x1000C8077774924);
    }
  }
  uint64_t v5 = *(void *)(v1 - 88);
  if (v5)
  {
    int v6 = *(_DWORD *)(v5 - 4) - 1;
    *(_DWORD *)(v5 - 4) = v6;
    if (!v6) {
      MEMORY[0x1BA9BFB70](v5 - 8, 0x1000C8077774924);
    }
  }
  uint64_t v7 = *(void *)(v1 - 120);
  if (v7)
  {
    int v8 = *(_DWORD *)(v7 - 4) - 1;
    *(_DWORD *)(v7 - 4) = v8;
    if (!v8) {
      MEMORY[0x1BA9BFB70](v7 - 8, 0x1000C8077774924);
    }
  }
  _Unwind_Resume(exception_object);
}

_DWORD *PCGenMatrix<int>::set<int>(_DWORD *result, uint64_t a2)
{
  if ((_DWORD *)a2 != result)
  {
    uint64_t v3 = result;
    int v4 = result[2];
    if (v4 != *(_DWORD *)(a2 + 8))
    {
      exception = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::ssprintf((PCString *)"PCGenMatrix row mismatch %d != %d", &v23, v3[2], *(unsigned int *)(a2 + 8));
      PCException::PCException(exception, &v23);
      *(void *)exception = &unk_1F10C2560;
    }
    int v5 = result[3];
    if (v5 != *(_DWORD *)(a2 + 12))
    {
      int v22 = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::ssprintf((PCString *)"PCGenMatrix col mismatch %d != %d", &v23, v3[3], *(unsigned int *)(a2 + 12));
      PCException::PCException(v22, &v23);
      *(void *)int v22 = &unk_1F10C2560;
    }
    uint64_t v6 = *(void *)result;
    if (!*(void *)result)
    {
      BOOL result = PCGenMatrix<int>::resize(result, v4, v5, result[5] == 1);
      uint64_t v6 = *(void *)v3;
    }
    if (*(void *)a2 == v6)
    {
      v23.int var0 = 0;
      uint64_t v24 = 0;
      uint64_t v25 = 0x100000001;
      uint64_t v26 = 0;
      BOOL result = (_DWORD *)PCGenMatrix<int>::set<int>(&v23, a2);
      int v13 = v3[2];
      if (v13 >= 1)
      {
        int v14 = 0;
        uint64_t v15 = v26;
        int v16 = v3[3];
        do
        {
          if (v16 >= 1)
          {
            int v17 = 0;
            uint64_t v18 = *((void *)v3 + 3);
            do
            {
              *(_DWORD *)(v18 + 4 * (v3[5] * v17 + v3[4] * v14)) = *(_DWORD *)(v15
                                                                               + 4
                                                                               * (HIDWORD(v25) * v17 + (int)v25 * v14));
              ++v17;
              int v16 = v3[3];
            }
            while (v17 < v16);
            int v13 = v3[2];
          }
          ++v14;
        }
        while (v14 < v13);
      }
      int var0 = v23.var0;
      if (v23.var0)
      {
        int v20 = HIDWORD(v23.var0[-1].length) - 1;
        HIDWORD(v23.var0[-1].length) = v20;
        if (!v20) {
          return (_DWORD *)MEMORY[0x1BA9BFB70](&var0[-1].length, 0x1000C8077774924);
        }
      }
    }
    else
    {
      int v7 = v3[2];
      if (v7 >= 1)
      {
        int v8 = 0;
        uint64_t v9 = *(void *)(a2 + 24);
        int v10 = v3[3];
        do
        {
          if (v10 >= 1)
          {
            int v11 = 0;
            uint64_t v12 = *((void *)v3 + 3);
            do
            {
              *(_DWORD *)(v12 + 4 * (v3[5] * v11 + v3[4] * v8)) = *(_DWORD *)(v9
                                                                              + 4
                                                                              * (*(_DWORD *)(a2 + 20) * v11
                                                                               + *(_DWORD *)(a2 + 16) * v8));
              ++v11;
              int v10 = v3[3];
            }
            while (v11 < v10);
            int v7 = v3[2];
          }
          ++v8;
        }
        while (v8 < v7);
      }
    }
  }
  return result;
}

void sub_1B7AC14B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCString a11)
{
}

uint64_t PCGenMatrix<int>::PCGenMatrix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 12) = a4;
  if (a5) {
    int v7 = a4;
  }
  else {
    int v7 = 1;
  }
  if (a5) {
    int v8 = 1;
  }
  else {
    int v8 = a3;
  }
  *(_DWORD *)(a1 + 16) = v7;
  *(_DWORD *)(a1 + 20) = v8;
  if ((a3 & 0x80000000) != 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::ssprintf((PCString *)"PCGenMatrix number of rows %d must be nonnegative", &v16, a3);
    PCException::PCException(exception, &v16);
    *(void *)exception = &unk_1F10C2560;
  }
  if ((a4 & 0x80000000) != 0)
  {
    uint64_t v15 = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::ssprintf((PCString *)"PCGenMatrix number of cols %d must be nonnegative", &v16, a4);
    PCException::PCException(v15, &v16);
    *(void *)uint64_t v15 = &unk_1F10C2560;
  }
  *(void *)(a1 + 24) = a2;
  if (a6)
  {
    PCGenMatrix<int>::copy(a1, 0, (uint64_t)&v16);
    int var0 = v16.var0;
    if (&v16 != (PCString *)a1)
    {
      *(_OWORD *)(a1 + 8) = v17;
      if (*(__CFString **)a1 != var0)
      {
        PCGenBlockRef<double>::deref((void *)a1);
        *(void *)a1 = var0;
        if (var0) {
          ++HIDWORD(var0[-1].length);
        }
      }
      int var0 = v16.var0;
      *(void *)(a1 + 24) = v18;
    }
    if (var0)
    {
      int v11 = HIDWORD(var0[-1].length) - 1;
      HIDWORD(var0[-1].length) = v11;
      if (!v11) {
        MEMORY[0x1BA9BFB70](&var0[-1].length, 0x1000C8077774924);
      }
    }
  }
  return a1;
}

void sub_1B7AC16D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCString a11)
{
  if (a11.var0)
  {
    int v13 = HIDWORD(a11.var0[-1].length) - 1;
    HIDWORD(a11.var0[-1].length) = v13;
    if (!v13) {
      MEMORY[0x1BA9BFB70](&a11.var0[-1].length, 0x1000C8077774924);
    }
  }
  PCGenBlockRef<double>::deref(v11);
  _Unwind_Resume(a1);
}

_DWORD *PCGenMatrix<int>::copy@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  int v6 = *(_DWORD *)(a1 + 8);
  int v7 = *(_DWORD *)(a1 + 12);
  PCGenBlockRef<int>::PCGenBlockRef((void *)a3, v7 * v6);
  *(_DWORD *)(a3 + 8) = v6;
  *(_DWORD *)(a3 + 12) = v7;
  if (a2) {
    int v8 = v7;
  }
  else {
    int v8 = 1;
  }
  if (a2) {
    int v9 = 1;
  }
  else {
    int v9 = v6;
  }
  *(_DWORD *)(a3 + 16) = v8;
  *(_DWORD *)(a3 + 20) = v9;
  *(void *)(a3 + 24) = *(void *)a3;
  return PCGenMatrix<int>::set<int>((_DWORD *)a3, a1);
}

void sub_1B7AC17CC(_Unwind_Exception *a1)
{
  PCGenBlockRef<double>::deref(v1);
  _Unwind_Resume(a1);
}

void *PCGenBlockRef<int>::PCGenBlockRef(void *result, int a2)
{
  if (a2) {
    operator new[]();
  }
  *BOOL result = 0;
  return result;
}

uint64_t PCGenVector<int>::PCGenVector(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 12) = 1;
  if ((a3 & 0x80000000) != 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::ssprintf((PCString *)"PCGenVector length %d must be nonnegative", &v10, a3);
    PCException::PCException(exception, &v10);
    *(void *)exception = &unk_1F10C2560;
  }
  *(void *)(a1 + 16) = a2;
  if (a4)
  {
    PCGenBlockRef<int>::PCGenBlockRef(&v10, a3);
    uint64_t v11 = a3 | 0x100000000;
    int var0 = v10.var0;
    PCGenVector<int>::set<int>((uint64_t)&v10, a1);
    int v6 = v10.var0;
    if (&v10 != (PCString *)a1)
    {
      *(void *)(a1 + 8) = v11;
      if (*(__CFString **)a1 != v6)
      {
        PCGenBlockRef<double>::deref((void *)a1);
        *(void *)a1 = v6;
        if (v6) {
          ++HIDWORD(v6[-1].length);
        }
      }
      int v6 = v10.var0;
      *(void *)(a1 + 16) = var0;
    }
    if (v6)
    {
      int v7 = HIDWORD(v6[-1].length) - 1;
      HIDWORD(v6[-1].length) = v7;
      if (!v7) {
        MEMORY[0x1BA9BFB70](&v6[-1].length, 0x1000C8077774924);
      }
    }
  }
  return a1;
}

void sub_1B7AC19B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  if (a10.var0)
  {
    int v12 = HIDWORD(a10.var0[-1].length) - 1;
    HIDWORD(a10.var0[-1].length) = v12;
    if (!v12) {
      MEMORY[0x1BA9BFB70](&a10.var0[-1].length, 0x1000C8077774924);
    }
  }
  PCGenBlockRef<double>::deref(v10);
  _Unwind_Resume(a1);
}

uint64_t PCGenVector<int>::set<int>(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    int v4 = *(_DWORD *)(a1 + 8);
    if (v4 != *(_DWORD *)(a2 + 8))
    {
      exception = (PCException *)__cxa_allocate_exception(0x40uLL);
      PCString::ssprintf((PCString *)"PCGenVector length mismatch %d != %d", &v16, *(unsigned int *)(a1 + 8), *(unsigned int *)(a2 + 8));
      PCException::PCException(exception, &v16);
      *(void *)exception = &unk_1F10C2560;
    }
    if (*(void *)a1) {
      BOOL v5 = *(void *)a2 == *(void *)a1;
    }
    else {
      BOOL v5 = 0;
    }
    if (v5)
    {
      PCGenBlockRef<int>::PCGenBlockRef(&v16, *(_DWORD *)(a1 + 8));
      int v17 = v4;
      int v18 = 1;
      int var0 = v16.var0;
      PCGenVector<int>::set<int>(&v16, a2);
      if (*(int *)(a1 + 8) >= 1)
      {
        int v9 = 0;
        PCString v10 = var0;
        uint64_t v11 = *(void *)(a1 + 16);
        do
        {
          *(_DWORD *)(v11 + 4 * *(_DWORD *)(a1 + 12) * v9) = *((_DWORD *)&v10->isa + v18 * v9);
          ++v9;
        }
        while (v9 < *(_DWORD *)(a1 + 8));
      }
      int v12 = v16.var0;
      if (v16.var0)
      {
        int v13 = HIDWORD(v16.var0[-1].length) - 1;
        HIDWORD(v16.var0[-1].length) = v13;
        if (!v13) {
          MEMORY[0x1BA9BFB70](&v12[-1].length, 0x1000C8077774924);
        }
      }
    }
    else if (v4 >= 1)
    {
      int v6 = 0;
      uint64_t v7 = *(void *)(a2 + 16);
      uint64_t v8 = *(void *)(a1 + 16);
      do
      {
        *(_DWORD *)(v8 + 4 * *(_DWORD *)(a1 + 12) * v6) = *(_DWORD *)(v7 + 4 * *(_DWORD *)(a2 + 12) * v6);
        ++v6;
      }
      while (v6 < *(_DWORD *)(a1 + 8));
    }
  }
  return a1;
}

void sub_1B7AC1BE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, PCString a12)
{
}

_DWORD *PCGenMatrix<int>::resize(_DWORD *result, int a2, int a3, int a4)
{
  uint64_t v6 = (uint64_t)result;
  int v8 = result[2];
  int v7 = result[3];
  BOOL v10 = v8 != a2 || v7 != a3;
  if (a4)
  {
    if (a4 == 1)
    {
      if (result[5] == 1)
      {
        if (result[4] != v7) {
          LOBYTE(v10) = 1;
        }
        if (!v10) {
          return result;
        }
      }
    }
    else if (!v10)
    {
      return result;
    }
    int v11 = 0;
LABEL_21:
    BOOL result = PCGenBlockRef<int>::PCGenBlockRef(&v32, a3 * a2);
    *(void *)&long long v33 = __PAIR64__(a3, a2);
    if (v11) {
      int v12 = 1;
    }
    else {
      int v12 = a3;
    }
    if (v11) {
      int v13 = a2;
    }
    else {
      int v13 = 1;
    }
    *((void *)&v33 + 1) = __PAIR64__(v13, v12);
    int v14 = *(_DWORD *)(v6 + 12);
    if (a2 >= *(_DWORD *)(v6 + 8)) {
      int v15 = *(_DWORD *)(v6 + 8);
    }
    else {
      int v15 = a2;
    }
    uint64_t v16 = v32;
    uint64_t v34 = v32;
    if (a3 >= v14) {
      int v17 = v14;
    }
    else {
      int v17 = a3;
    }
    unsigned int v18 = v15 - 1;
    if (v15 >= 1 && v17 >= 1)
    {
      v30[0] = 0;
      v30[1] = v15 - 1;
      unsigned int v20 = v17 - 1;
      v29[0] = 0;
      v29[1] = v17 - 1;
      PCGenMatrix<int>::operator()((uint64_t)result, v30, v29, (uint64_t)v31);
      v27[0] = 0;
      v27[1] = v18;
      v26[0] = 0;
      v26[1] = v20;
      PCGenMatrix<int>::operator()(v6, v27, v26, (uint64_t)v28);
      BOOL result = (_DWORD *)PCGenMatrix<int>::set<int>(v31, v28);
      uint64_t v21 = v28[0];
      if (v28[0])
      {
        int v22 = *(_DWORD *)(v28[0] - 4) - 1;
        *(_DWORD *)(v28[0] - 4) = v22;
        if (!v22) {
          BOOL result = (_DWORD *)MEMORY[0x1BA9BFB70](v21 - 8, 0x1000C8077774924);
        }
      }
      uint64_t v23 = v31[0];
      if (v31[0])
      {
        int v24 = *(_DWORD *)(v31[0] - 4) - 1;
        *(_DWORD *)(v31[0] - 4) = v24;
        if (!v24) {
          BOOL result = (_DWORD *)MEMORY[0x1BA9BFB70](v23 - 8, 0x1000C8077774924);
        }
      }
      uint64_t v16 = v32;
    }
    if (&v32 != (uint64_t *)v6)
    {
      *(_OWORD *)(v6 + 8) = v33;
      if (*(void *)v6 != v16)
      {
        BOOL result = PCGenBlockRef<double>::deref((void *)v6);
        *(void *)uint64_t v6 = v16;
        if (v16) {
          ++*(_DWORD *)(v16 - 4);
        }
      }
      uint64_t v16 = v32;
      *(void *)(v6 + 24) = v34;
    }
    if (v16)
    {
      int v25 = *(_DWORD *)(v16 - 4) - 1;
      *(_DWORD *)(v16 - 4) = v25;
      if (!v25) {
        return (_DWORD *)MEMORY[0x1BA9BFB70](v16 - 8, 0x1000C8077774924);
      }
    }
    return result;
  }
  if (result[4] != 1) {
    goto LABEL_18;
  }
  if (result[5] != v8) {
    LOBYTE(v10) = 1;
  }
  if (v10)
  {
LABEL_18:
    int v11 = 1;
    goto LABEL_21;
  }
  return result;
}

void sub_1B7AC1E60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  uint64_t v19 = *(void *)(v17 - 80);
  if (v19)
  {
    int v20 = *(_DWORD *)(v19 - 4) - 1;
    *(_DWORD *)(v19 - 4) = v20;
    if (!v20) {
      MEMORY[0x1BA9BFB70](v19 - 8, 0x1000C8077774924);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t PCGenMatrix<int>::operator()@<X0>(uint64_t a1@<X0>, unsigned int *a2@<X1>, unsigned int *a3@<X2>, uint64_t a4@<X8>)
{
  PCGenMatrix<BOOL>::checkRowIndex(a1, *a2);
  PCGenMatrix<BOOL>::checkRowIndex(a1, a2[1]);
  PCGenMatrix<BOOL>::checkColIndex(a1, *a3);
  uint64_t result = PCGenMatrix<BOOL>::checkColIndex(a1, a3[1]);
  int v10 = *a2;
  unsigned int v9 = a2[1];
  int v12 = *a3;
  unsigned int v11 = a3[1];
  int v14 = *(_DWORD *)(a1 + 16);
  int v13 = *(_DWORD *)(a1 + 20);
  uint64_t v15 = *(void *)(a1 + 24);
  uint64_t v16 = *(void *)a1;
  *(void *)a4 = *(void *)a1;
  if (v16) {
    ++*(_DWORD *)(v16 - 4);
  }
  *(_DWORD *)(a4 + 8) = v9 - v10 + 1;
  *(_DWORD *)(a4 + 12) = v11 - v12 + 1;
  *(_DWORD *)(a4 + 16) = v14;
  *(_DWORD *)(a4 + 20) = v13;
  *(void *)(a4 + 24) = v15 + 4 * v14 * v10 + 4 * v13 * v12;
  return result;
}

BOOL ProShade::Multiply::computeBinaryType<double>(double *a1, double *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v195 = *MEMORY[0x1E4F143B8];
  if (!ProShade::shapeIsMatrix(*(_DWORD *)(a3 + 4))
    || !ProShade::shapeIsVector(*(_DWORD *)(a4 + 4))
    || (int v11 = ProShade::shapeGetWidth(*(_DWORD *)(a3 + 4), v10),
        v11 != ProShade::shapeGetWidth(*(_DWORD *)(a4 + 4), v12)))
  {
    BOOL IsVector = ProShade::shapeIsVector(*(_DWORD *)(a3 + 4));
    int v26 = *(_DWORD *)(a4 + 4);
    if (IsVector && v26 == 1)
    {
      uint64_t Width = ProShade::shapeGetWidth(*(_DWORD *)(a3 + 4), v24);
      if ((int)Width > 4)
      {
        PCGenVector<double>::PCGenVector((uint64_t)&v190, (uint64_t)a1, Width, 0);
        double v53 = *a2;
        int v54 = v191;
        PCGenBlockRef<double>::PCGenBlockRef(&v185, v191);
        unsigned int v186 = v54;
        int v187 = 1;
        int v55 = v185;
        float32x4_t v188 = (double *)v185;
        int v56 = v193;
        uint64_t v57 = v191;
        if (v192 == 1)
        {
          if (v191 >= 1)
          {
            int v58 = (double *)v185;
            do
            {
              double v59 = *v56++;
              *v58++ = v53 * v59;
              --v57;
            }
            while (v57);
          }
        }
        else if (v191 >= 1)
        {
          uint64_t v82 = 8 * (int)v192;
          int v83 = (double *)v185;
          do
          {
            *v83++ = v53 * *v56;
            int v56 = (double *)((char *)v56 + v82);
            --v57;
          }
          while (v57);
        }
        ProShade::Value::set(a5, (const PCString *)3, *(_DWORD *)(a3 + 4), v55);
LABEL_121:
        uint64_t v142 = v185;
        if (v185)
        {
          int v143 = *((_DWORD *)v185 - 1) - 1;
          *((_DWORD *)v185 - 1) = v143;
          if (!v143) {
            MEMORY[0x1BA9BFB70](v142 - 8, 0x1000C8077774924);
          }
        }
        uint64_t v144 = v190;
        if (!v190) {
          return 1;
        }
        goto LABEL_125;
      }
      if ((int)Width >= 1)
      {
        double v37 = *a2;
        uint64_t v38 = Width;
        unsigned __int8 v39 = (double *)&v190;
        do
        {
          double v40 = *a1++;
          *v39++ = v37 * v40;
          --v38;
        }
        while (v38);
      }
LABEL_26:
      ProShade::Value::set(a5, (const PCString *)3, *(_DWORD *)(a3 + 4), &v190);
      return 1;
    }
    BOOL v29 = ProShade::shapeIsVector(v26);
    int v30 = *(_DWORD *)(a3 + 4);
    if (v29 && v30 == 1)
    {
      uint64_t v31 = ProShade::shapeGetWidth(*(_DWORD *)(a4 + 4), v28);
      if ((int)v31 <= 4)
      {
        if ((int)v31 >= 1)
        {
          double v32 = *a1;
          uint64_t v33 = v31;
          uint64_t v34 = (double *)&v190;
          do
          {
            double v35 = *a2++;
            *v34++ = v32 * v35;
            --v33;
          }
          while (v33);
        }
        goto LABEL_10;
      }
      PCGenVector<double>::PCGenVector((uint64_t)&v190, (uint64_t)a2, v31, 0);
      double v75 = *a1;
      int v76 = v191;
      PCGenBlockRef<double>::PCGenBlockRef(&v185, v191);
      unsigned int v186 = v76;
      int v187 = 1;
      double v77 = v185;
      float32x4_t v188 = (double *)v185;
      BOOL v78 = v193;
      uint64_t v79 = v191;
      if (v192 == 1)
      {
        if (v191 >= 1)
        {
          uint64_t v80 = (double *)v185;
          do
          {
            double v81 = *v78++;
            *v80++ = v75 * v81;
            --v79;
          }
          while (v79);
        }
      }
      else if (v191 >= 1)
      {
        uint64_t v108 = 8 * (int)v192;
        uint64_t v109 = (double *)v185;
        do
        {
          *v109++ = v75 * *v78;
          BOOL v78 = (double *)((char *)v78 + v108);
          --v79;
        }
        while (v79);
      }
      ProShade::Value::set(a5, (const PCString *)3, *(_DWORD *)(a4 + 4), v77);
      goto LABEL_121;
    }
    if (ProShade::shapeIsVector(v30) && ProShade::shapeIsMatrix(*(_DWORD *)(a4 + 4)))
    {
      int v42 = ProShade::shapeGetWidth(*(_DWORD *)(a3 + 4), v41);
      if (v42 == ProShade::shapeGetWidth(*(_DWORD *)(a4 + 4), v43))
      {
        uint64_t v45 = ProShade::shapeGetWidth(*(_DWORD *)(a4 + 4), v44);
        uint64_t v46 = v45;
        if ((int)v45 <= 4)
        {
          if ((int)v45 >= 1)
          {
            uint64_t v47 = 0;
            do
            {
              double v48 = 0.0;
              uint64_t v49 = v45;
              BOOL v50 = a1;
              uint64_t v51 = a2;
              do
              {
                double v52 = *v50++;
                double v48 = v48 + v52 * *v51;
                v51 += v45;
                --v49;
              }
              while (v49);
              *(double *)&(&v190)[v47++] = v48;
              ++a2;
            }
            while (v47 != v45);
          }
          goto LABEL_26;
        }
        PCGenVector<double>::PCGenVector((uint64_t)&v185, (uint64_t)a1, v45, 0);
        PCGenMatrix<double>::PCGenMatrix((uint64_t)&v190, (uint64_t)a2, v46, v46, 1, 0);
        unsigned int v146 = v192;
        PCGenBlockRef<double>::PCGenBlockRef(&v181, v192);
        unsigned int v182 = v146;
        int v183 = 1;
        uint64_t v147 = v181;
        float32x4_t v184 = v181;
        uint64_t v148 = v192;
        if ((int)v192 < 1)
        {
LABEL_152:
          ProShade::Value::set(a5, (const PCString *)3, *(_DWORD *)(a3 + 4), v147);
          int32x4_t v170 = v181;
          if (v181)
          {
            int v171 = *((_DWORD *)v181 - 1) - 1;
            *((_DWORD *)v181 - 1) = v171;
            if (!v171) {
              MEMORY[0x1BA9BFB70](v170 - 8, 0x1000C8077774924);
            }
          }
          uint64_t v172 = v190;
          if (v190)
          {
            int v173 = *(v190 - 1) - 1;
            *(v190 - 1) = v173;
            if (!v173) {
              MEMORY[0x1BA9BFB70](v172 - 2, 0x1000C8077774924);
            }
          }
          uint64_t v144 = v185;
          if (!v185) {
            return 1;
          }
LABEL_125:
          int v145 = *(v144 - 1) - 1;
          *(v144 - 1) = v145;
          if (!v145) {
            MEMORY[0x1BA9BFB70](v144 - 2, 0x1000C8077774924);
          }
          return 1;
        }
        uint64_t v149 = 0;
        uint64_t v150 = v186;
        int v151 = v187;
        uint64_t v152 = v194;
        int v153 = (int)v193;
        uint64_t v154 = 8 * SHIDWORD(v193);
        uint64_t v155 = 8 * (int)v193;
        int v156 = v188;
        uint64_t v157 = 8 * v187;
        uint64_t v158 = 8 * v186;
        while (1)
        {
          if (v151 == 1)
          {
            if (v153 == 1)
            {
              if (v150)
              {
                uint64_t v159 = 0;
                double v160 = 0.0;
                do
                {
                  double v160 = v160 + v156[v159] * v152[v159];
                  ++v159;
                }
                while (v150 != v159);
                goto LABEL_151;
              }
            }
            else if ((int)v150 >= 1)
            {
              double v160 = 0.0;
              long long v163 = v152;
              uint64_t v164 = v150;
              int v165 = v156;
              do
              {
                double v166 = *v165++;
                double v160 = v160 + v166 * *v163;
                long long v163 = (double *)((char *)v163 + v155);
                --v164;
              }
              while (v164);
              goto LABEL_151;
            }
          }
          else if (v153 == 1)
          {
            if ((int)v150 >= 1)
            {
              unint64_t v161 = 0;
              double v160 = 0.0;
              uint64_t v162 = v156;
              do
              {
                double v160 = v160 + *v162 * v152[v161 / 8];
                v161 += 8;
                uint64_t v162 = (double *)((char *)v162 + v157);
              }
              while (v158 != v161);
              goto LABEL_151;
            }
          }
          else if ((int)v150 >= 1)
          {
            double v160 = 0.0;
            int v167 = v156;
            int v168 = v152;
            uint64_t v169 = v150;
            do
            {
              double v160 = v160 + *v167 * *v168;
              int v168 = (double *)((char *)v168 + v155);
              int v167 = (double *)((char *)v167 + v157);
              --v169;
            }
            while (v169);
            goto LABEL_151;
          }
          double v160 = 0.0;
LABEL_151:
          *((double *)v147 + v149++) = v160;
          uint64_t v152 = (double *)((char *)v152 + v154);
          if (v149 == v148) {
            goto LABEL_152;
          }
        }
      }
    }
    BOOL result = ProShade::shapeIsMatrix(*(_DWORD *)(a3 + 4));
    if (!result) {
      return result;
    }
    uint64_t v62 = ProShade::shapeGetWidth(*(_DWORD *)(a3 + 4), v61);
    uint64_t v63 = v62;
    if ((int)v62 <= 4)
    {
      MEMORY[0x1F4188790](v62);
      int v65 = (char *)&v174 - ((v64 + 15) & 0xFFFFFFFFFFFFFFF0);
      if ((int)v63 >= 1)
      {
        uint64_t v66 = 0;
        uint64_t v67 = 8 * v63;
        do
        {
          uint64_t v68 = 0;
          uint64_t v69 = a2;
          do
          {
            double v70 = 0.0;
            uint64_t v71 = v63;
            uint64_t v72 = a1;
            uint64_t v73 = v69;
            do
            {
              double v74 = *v72++;
              double v70 = v70 + v74 * *v73;
              uint64_t v73 = (double *)((char *)v73 + v67);
              --v71;
            }
            while (v71);
            *(double *)&v65[8 * v66 * v63 + 8 * v68++] = v70;
            ++v69;
          }
          while (v68 != v63);
          ++v66;
          a1 = (double *)((char *)a1 + v67);
        }
        while (v66 != v63);
      }
      ProShade::Value::set(a5, (const PCString *)3, *(_DWORD *)(a3 + 4), v65);
      return 1;
    }
    PCGenMatrix<double>::PCGenMatrix((uint64_t)&v190, (uint64_t)a1, v62, v62, 1, 0);
    PCGenMatrix<double>::PCGenMatrix((uint64_t)&v185, (uint64_t)a2, v63, v63, 1, 0);
    PCGenMatrix<double>::PCGenMatrix((uint64_t)&v181, a5 + 16, v63, v63, 1, 0);
    int v110 = v191;
    int v111 = v187;
    PCGenBlockRef<double>::PCGenBlockRef(&v175, v187 * v191);
    int v176 = v110;
    int v177 = v111;
    int v178 = 1;
    int v179 = v110;
    uint64_t v112 = v175;
    uint64_t v180 = v175;
    uint64_t v113 = v191;
    if (v191 < 1)
    {
LABEL_115:
      PCGenMatrix<double>::set<double>(&v181, (uint64_t)&v175);
      uint64_t v138 = v175;
      if (v175)
      {
        int v139 = *(_DWORD *)(v175 - 4) - 1;
        *(_DWORD *)(v175 - 4) = v139;
        if (!v139) {
          MEMORY[0x1BA9BFB70](v138 - 8, 0x1000C8077774924);
        }
      }
LABEL_118:
      uint64_t v140 = v181;
      if (v181)
      {
        int v141 = *((_DWORD *)v181 - 1) - 1;
        *((_DWORD *)v181 - 1) = v141;
        if (!v141) {
          MEMORY[0x1BA9BFB70](v140 - 8, 0x1000C8077774924);
        }
      }
      goto LABEL_121;
    }
    uint64_t v114 = 0;
    uint64_t v115 = v110;
    uint64_t v116 = v194;
    long long v117 = v189;
    int v118 = (int)v188;
    uint64_t v119 = v192;
    uint64_t v120 = v187;
    uint64_t v121 = 8 * SHIDWORD(v188);
    uint64_t v122 = 8 * (int)v188;
    uint64_t v123 = 8 * (int)v193;
    int v124 = HIDWORD(v193);
    uint64_t v125 = 8 * SHIDWORD(v193);
    uint64_t v126 = 8 * v192;
    while ((int)v120 < 1)
    {
LABEL_114:
      ++v114;
      uint64_t v116 = (double *)((char *)v116 + v123);
      if (v114 == v113) {
        goto LABEL_115;
      }
    }
    uint64_t v127 = 0;
    long long v128 = v117;
    while (1)
    {
      if (v124 == 1)
      {
        if (v118 == 1)
        {
          if (v119)
          {
            uint64_t v129 = 0;
            double v130 = 0.0;
            do
            {
              double v130 = v130 + v116[v129] * v128[v129];
              ++v129;
            }
            while (v119 != v129);
            goto LABEL_113;
          }
        }
        else if ((int)v119 >= 1)
        {
          unint64_t v133 = 0;
          double v130 = 0.0;
          uint64_t v134 = v128;
          do
          {
            double v130 = v130 + v116[v133 / 8] * *v134;
            v133 += 8;
            uint64_t v134 = (double *)((char *)v134 + v122);
          }
          while (v126 != v133);
          goto LABEL_113;
        }
      }
      else if (v118 == 1)
      {
        if ((int)v119 >= 1)
        {
          unint64_t v131 = 0;
          double v130 = 0.0;
          unsigned int v132 = v116;
          do
          {
            double v130 = v130 + *v132 * v128[v131 / 8];
            v131 += 8;
            unsigned int v132 = (double *)((char *)v132 + v125);
          }
          while (v126 != v131);
          goto LABEL_113;
        }
      }
      else if ((int)v119 >= 1)
      {
        double v130 = 0.0;
        uint64_t v135 = v116;
        uint64_t v136 = v128;
        uint64_t v137 = v119;
        do
        {
          double v130 = v130 + *v135 * *v136;
          uint64_t v136 = (double *)((char *)v136 + v122);
          uint64_t v135 = (double *)((char *)v135 + v125);
          --v137;
        }
        while (v137);
        goto LABEL_113;
      }
      double v130 = 0.0;
LABEL_113:
      *(double *)(v112 + 8 * (v114 + v127 * v115)) = v130;
      ++v127;
      long long v128 = (double *)((char *)v128 + v121);
      if (v127 == v120) {
        goto LABEL_114;
      }
    }
  }
  uint64_t v14 = ProShade::shapeGetWidth(*(_DWORD *)(a3 + 4), v13);
  uint64_t v15 = v14;
  if ((int)v14 > 4)
  {
    PCGenMatrix<double>::PCGenMatrix((uint64_t)&v190, (uint64_t)a1, v14, v14, 1, 0);
    PCGenVector<double>::PCGenVector((uint64_t)&v185, (uint64_t)a2, v15, 0);
    int v84 = v191;
    PCGenBlockRef<double>::PCGenBlockRef(&v181, v191);
    unsigned int v182 = v84;
    int v183 = 1;
    int v85 = (double *)v181;
    float32x4_t v184 = v181;
    uint64_t v86 = v191;
    if (v191 >= 1)
    {
      uint64_t v87 = 0;
      long long v88 = v194;
      float64x2_t v89 = v188;
      int v90 = v187;
      uint64_t v91 = v192;
      uint64_t v92 = 8 * v187;
      uint64_t v93 = 8 * (int)v193;
      int v94 = HIDWORD(v193);
      uint64_t v95 = 8 * SHIDWORD(v193);
      uint64_t v96 = 8 * v192;
      do
      {
        if (v94 == 1)
        {
          if (v90 == 1)
          {
            if (v91)
            {
              uint64_t v97 = 0;
              double v98 = 0.0;
              do
              {
                double v98 = v98 + v88[v97] * v89[v97];
                ++v97;
              }
              while (v91 != v97);
              goto LABEL_83;
            }
          }
          else if ((int)v91 >= 1)
          {
            unint64_t v103 = 0;
            double v98 = 0.0;
            long long v104 = v89;
            do
            {
              double v98 = v98 + v88[v103 / 8] * *v104;
              v103 += 8;
              long long v104 = (double *)((char *)v104 + v92);
            }
            while (v96 != v103);
            goto LABEL_83;
          }
        }
        else if (v90 == 1)
        {
          if ((int)v91 >= 1)
          {
            double v98 = 0.0;
            char v99 = v88;
            uint64_t v100 = v91;
            uint64_t v101 = v89;
            do
            {
              double v102 = *v101++;
              double v98 = v98 + *v99 * v102;
              char v99 = (double *)((char *)v99 + v95);
              --v100;
            }
            while (v100);
            goto LABEL_83;
          }
        }
        else if ((int)v91 >= 1)
        {
          double v98 = 0.0;
          long long v105 = v88;
          uint64_t v106 = v89;
          uint64_t v107 = v91;
          do
          {
            double v98 = v98 + *v105 * *v106;
            uint64_t v106 = (double *)((char *)v106 + v92);
            long long v105 = (double *)((char *)v105 + v95);
            --v107;
          }
          while (v107);
          goto LABEL_83;
        }
        double v98 = 0.0;
LABEL_83:
        v85[v87++] = v98;
        long long v88 = (double *)((char *)v88 + v93);
      }
      while (v87 != v86);
    }
    ProShade::Value::set(a5, (const PCString *)3, *(_DWORD *)(a4 + 4), v85);
    goto LABEL_118;
  }
  if ((int)v14 >= 1)
  {
    uint64_t v16 = 0;
    do
    {
      double v17 = 0.0;
      uint64_t v18 = v14;
      uint64_t v19 = a2;
      int v20 = a1;
      do
      {
        double v21 = *v20++;
        double v22 = v21;
        double v23 = *v19++;
        double v17 = v17 + v22 * v23;
        --v18;
      }
      while (v18);
      *(double *)&(&v190)[v16++] = v17;
      a1 += v14;
    }
    while (v16 != v14);
  }
LABEL_10:
  ProShade::Value::set(a5, (const PCString *)3, *(_DWORD *)(a4 + 4), &v190);
  return 1;
}

void sub_1B7AC2B1C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 - 168);
  if (v3)
  {
    int v4 = *(_DWORD *)(v3 - 4) - 1;
    *(_DWORD *)(v3 - 4) = v4;
    if (!v4) {
      MEMORY[0x1BA9BFB70](v3 - 8, 0x1000C8077774924);
    }
  }
  uint64_t v5 = *(void *)(v1 - 104);
  if (v5)
  {
    int v6 = *(_DWORD *)(v5 - 4) - 1;
    *(_DWORD *)(v5 - 4) = v6;
    if (!v6) {
      MEMORY[0x1BA9BFB70](v5 - 8, 0x1000C8077774924);
    }
  }
  uint64_t v7 = *(void *)(v1 - 136);
  if (v7)
  {
    int v8 = *(_DWORD *)(v7 - 4) - 1;
    *(_DWORD *)(v7 - 4) = v8;
    if (!v8) {
      MEMORY[0x1BA9BFB70](v7 - 8, 0x1000C8077774924);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t PCGenMatrix<double>::PCGenMatrix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 12) = a4;
  if (a5) {
    int v7 = a4;
  }
  else {
    int v7 = 1;
  }
  if (a5) {
    int v8 = 1;
  }
  else {
    int v8 = a3;
  }
  *(_DWORD *)(a1 + 16) = v7;
  *(_DWORD *)(a1 + 20) = v8;
  if ((a3 & 0x80000000) != 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::ssprintf((PCString *)"PCGenMatrix number of rows %d must be nonnegative", &v16, a3);
    PCException::PCException(exception, &v16);
    *(void *)exception = &unk_1F10C2560;
  }
  if ((a4 & 0x80000000) != 0)
  {
    uint64_t v15 = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::ssprintf((PCString *)"PCGenMatrix number of cols %d must be nonnegative", &v16, a4);
    PCException::PCException(v15, &v16);
    *(void *)uint64_t v15 = &unk_1F10C2560;
  }
  *(void *)(a1 + 24) = a2;
  if (a6)
  {
    PCGenMatrix<double>::copy(a1, 0, (uint64_t)&v16);
    int var0 = v16.var0;
    if (&v16 != (PCString *)a1)
    {
      *(_OWORD *)(a1 + 8) = v17;
      if (*(__CFString **)a1 != var0)
      {
        PCGenBlockRef<double>::deref((void *)a1);
        *(void *)a1 = var0;
        if (var0) {
          ++HIDWORD(var0[-1].length);
        }
      }
      int var0 = v16.var0;
      *(void *)(a1 + 24) = v18;
    }
    if (var0)
    {
      int v11 = HIDWORD(var0[-1].length) - 1;
      HIDWORD(var0[-1].length) = v11;
      if (!v11) {
        MEMORY[0x1BA9BFB70](&var0[-1].length, 0x1000C8077774924);
      }
    }
  }
  return a1;
}

void sub_1B7AC2E68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, PCString a11)
{
  if (a11.var0)
  {
    int v13 = HIDWORD(a11.var0[-1].length) - 1;
    HIDWORD(a11.var0[-1].length) = v13;
    if (!v13) {
      MEMORY[0x1BA9BFB70](&a11.var0[-1].length, 0x1000C8077774924);
    }
  }
  PCGenBlockRef<double>::deref(v11);
  _Unwind_Resume(a1);
}

uint64_t PCGenVector<double>::PCGenVector(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  *(void *)a1 = 0;
  *(_DWORD *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 12) = 1;
  if ((a3 & 0x80000000) != 0)
  {
    exception = (PCException *)__cxa_allocate_exception(0x40uLL);
    PCString::ssprintf((PCString *)"PCGenVector length %d must be nonnegative", &v10, a3);
    PCException::PCException(exception, &v10);
    *(void *)exception = &unk_1F10C2560;
  }
  *(void *)(a1 + 16) = a2;
  if (a4)
  {
    PCGenBlockRef<double>::PCGenBlockRef(&v10, a3);
    uint64_t v11 = a3 | 0x100000000;
    int var0 = v10.var0;
    PCGenVector<double>::set<double>((uint64_t)&v10, a1);
    int v6 = v10.var0;
    if (&v10 != (PCString *)a1)
    {
      *(void *)(a1 + 8) = v11;
      if (*(__CFString **)a1 != v6)
      {
        PCGenBlockRef<double>::deref((void *)a1);
        *(void *)a1 = v6;
        if (v6) {
          ++HIDWORD(v6[-1].length);
        }
      }
      int v6 = v10.var0;
      *(void *)(a1 + 16) = var0;
    }
    if (v6)
    {
      int v7 = HIDWORD(v6[-1].length) - 1;
      HIDWORD(v6[-1].length) = v7;
      if (!v7) {
        MEMORY[0x1BA9BFB70](&v6[-1].length, 0x1000C8077774924);
      }
    }
  }
  return a1;
}

void sub_1B7AC3050(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, PCString a10)
{
  if (a10.var0)
  {
    int v12 = HIDWORD(a10.var0[-1].length) - 1;
    HIDWORD(a10.var0[-1].length) = v12;
    if (!v12) {
      MEMORY[0x1BA9BFB70](&a10.var0[-1].length, 0x1000C8077774924);
    }
  }
  PCGenBlockRef<double>::deref(v10);
  _Unwind_Resume(a1);
}

void ProShade::VarT<ProShade::Node>::VarT(void *a1)
{
  *a1 = &unk_1F11193B8;
  operator new();
}

void sub_1B7AC3168(_Unwind_Exception *a1)
{
  MEMORY[0x1BA9BFBA0](v1, 0x10B1C40A585CD1CLL);
  _Unwind_Resume(a1);
}

void ProShade::Selector_member<(ProShade::Selector_base::Selection)4>::operator ProShade::VarT<ProShade::Node>(uint64_t a1)
{
}

void sub_1B7AC3200(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1);
  _Unwind_Resume(a1);
}

void ProShade::Selector_member<(ProShade::Selector_base::Selection)3>::operator ProShade::VarT<ProShade::Node>(uint64_t a1)
{
}

void sub_1B7AC3288(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1);
  _Unwind_Resume(a1);
}

void ProShade::Selector_member<(ProShade::Selector_base::Selection)7>::operator ProShade::VarT<ProShade::Node>(uint64_t a1)
{
}

void sub_1B7AC3310(_Unwind_Exception *a1)
{
  PCSharedCount::~PCSharedCount(v1);
  _Unwind_Resume(a1);
}

uint64_t ProShade::Multiply::resultShape(uint64_t a1, uint64_t a2)
{
  if (ProShade::shapeIsMatrix(a1))
  {
    int Width = ProShade::shapeGetWidth(a1, v4);
    if (Width != ProShade::shapeGetWidth(a2, v6))
    {
      if (!ProShade::shapeIsVector(a2)
        || (int v8 = ProShade::shapeGetWidth(a1, v7), v8 <= (int)ProShade::shapeGetWidth(a2, v9)))
      {
        ProShade::Error<PCIllegalArgumentException>::raise<char [33]>((OZChannelBase *)"matrix/vector width mismatch", v7);
      }
    }
  }
  else if (ProShade::shapeIsMatrix(a2))
  {
    int v11 = ProShade::shapeGetWidth(a1, v10);
    int v13 = ProShade::shapeGetWidth(a2, v12);
    a2 = a1;
    if (v11 != v13) {
      ProShade::Error<PCIllegalArgumentException>::raise<char [33]>((OZChannelBase *)"vector/matrix width mismatch", v14);
    }
  }
  else if (a1 != 1)
  {
    if (a2 == 1)
    {
      return a1;
    }
    else
    {
      BOOL v15 = a1 == a2;
      a2 = a1;
      if (!v15) {
        ProShade::Error<PCIllegalArgumentException>::raise<char [33]>((OZChannelBase *)"vector size mismatch", v10);
      }
    }
  }
  return a2;
}

uint64_t ProShade::BinaryOp<ProShade::Multiply>::setFrequency(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 64);
  if (!v1) {
    throw_PCNullPointerException(1);
  }
  int v2 = *(_DWORD *)(v1 + 40);
  uint64_t v3 = *(void *)(result + 96);
  if (!v3) {
    throw_PCNullPointerException(1);
  }
  int v4 = *(_DWORD *)(v3 + 40);
  if (v2 < 1 && v4 < 1)
  {
    int v10 = 0;
  }
  else if (v2 <= 1 && v4 < 2)
  {
    int v10 = 1;
  }
  else
  {
    if (v4 < 2 && v2 < 3) {
      int v8 = 2;
    }
    else {
      int v8 = 3;
    }
    if (v2 <= 1 && v4 < 3) {
      int v10 = 2;
    }
    else {
      int v10 = v8;
    }
  }
  if (*(_DWORD *)(result + 44) < v10) {
    int v10 = *(_DWORD *)(result + 44);
  }
  *(_DWORD *)(result + 40) = v10;
  return result;
}

uint64_t ProShade::BinaryOp<ProShade::Multiply>::~BinaryOp(uint64_t a1)
{
  *(void *)a1 = &unk_1F111FB58;
  *(void *)(a1 + 112) = &unk_1F111FC10;
  *(void *)(a1 + 80) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(a1 + 104));
  *(void *)(a1 + 48) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(a1 + 72));
  *(void *)a1 = off_1F111FC70;
  *(void *)(a1 + 112) = off_1F111FD28;
  LiString::dec((LiString *)(a1 + 32));
  *(void *)(a1 + 112) = &unk_1F1199AC8;
  *(unsigned char *)(a1 + 128) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(a1 + 120));
  return a1;
}

void ProShade::BinaryOp<ProShade::Multiply>::~BinaryOp(uint64_t a1)
{
  *(void *)a1 = &unk_1F111FB58;
  *(void *)(a1 + 112) = &unk_1F111FC10;
  *(void *)(a1 + 80) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(a1 + 104));
  *(void *)(a1 + 48) = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)(a1 + 72));
  *(void *)a1 = off_1F111FC70;
  *(void *)(a1 + 112) = off_1F111FD28;
  LiString::dec((LiString *)(a1 + 32));
  *(void *)(a1 + 112) = &unk_1F1199AC8;
  *(unsigned char *)(a1 + 128) = 0;
  PCWeakCount::~PCWeakCount((PC_Sp_counted_base **)(a1 + 120));

  JUMPOUT(0x1BA9BFBA0);
}

void ProShade::BinaryOp<ProShade::Multiply>::repr(uint64_t a1@<X0>, void *a2@<X8>)
{
  ProShade::VarT<ProShade::Node>::repr(a1 + 48);
  if (v28) {
    int v4 = *((_DWORD *)v28 - 2);
  }
  else {
    int v4 = 0;
  }
  uint64_t v5 = malloc_type_malloc(v4 + 14, 0x8903763CuLL);
  uint64_t v6 = v4 + 1;
  v5[2] = v4 + 2;
  atomic_store(1u, v5);
  atomic_store(0, v5);
  *((unsigned char *)v5 + 12) = 40;
  int v7 = v5 + 3;
  v5[1] = v6;
  memcpy((char *)v5 + 13, v28, v4);
  v7[v6] = 0;
  atomic_fetch_add(v5, 1u);
  int v26 = v5;
  size_t v8 = (int)v5[1];
  unsigned int v9 = (unsigned int *)malloc_type_malloc(v8 + 14, 0x8903763CuLL);
  atomic_store(1u, v9);
  int v10 = v9 + 3;
  atomic_store(0, v9);
  v9[1] = v8 + 1;
  void v9[2] = v8 + 2;
  memcpy(v9 + 3, v7, v8);
  *((unsigned char *)v10 + v8) = 32;
  *((unsigned char *)v10 + v8 + 1) = 0;
  atomic_fetch_add((atomic_uint *volatile)v9, 1u);
  int v25 = v9;
  size_t v11 = (int)v9[1];
  int v12 = (unsigned int *)malloc_type_malloc(v11 + 14, 0x8903763CuLL);
  v12[1] = v11 + 1;
  void v12[2] = v11 + 2;
  atomic_store(1u, v12);
  int v13 = v12 + 3;
  atomic_store(0, v12);
  memcpy(v12 + 3, v9 + 3, v11);
  *((unsigned char *)v13 + v11) = 42;
  *((unsigned char *)v13 + v11 + 1) = 0;
  atomic_fetch_add((atomic_uint *volatile)v12, 1u);
  size_t v14 = (int)v12[1];
  BOOL v15 = (unsigned int *)malloc_type_malloc(v14 + 14, 0x8903763CuLL);
  int v24 = a2;
  atomic_store(1u, v15);
  PCString v16 = v15 + 3;
  atomic_store(0, v15);
  v15[1] = v14 + 1;
  _OWORD v15[2] = v14 + 2;
  memcpy(v15 + 3, v12 + 3, v14);
  v16[v14] = 32;
  v16[v14 + 1] = 0;
  atomic_fetch_add((atomic_uint *volatile)v15, 1u);
  ProShade::VarT<ProShade::Node>::repr(a1 + 80);
  size_t v17 = (int)v15[1];
  if (v27) {
    int v18 = *((_DWORD *)v27 - 2);
  }
  else {
    int v18 = 0;
  }
  size_t v19 = v17 + v18;
  int v20 = (unsigned int *)malloc_type_malloc(v19 + 13, 0x8903763CuLL);
  v20[1] = v19;
  double v20[2] = v19 + 1;
  atomic_store(1u, v20);
  atomic_store(0, v20);
  memcpy(v20 + 3, v16, v17);
  memcpy((char *)v20 + v17 + 12, v27, v18);
  *((unsigned char *)v20 + v19 + 12) = 0;
  atomic_fetch_add((atomic_uint *volatile)v20, 1u);
  size_t v21 = (int)v20[1];
  double v22 = (unsigned int *)malloc_type_malloc(v21 + 14, 0x8903763CuLL);
  atomic_store(1u, v22);
  double v23 = v22 + 3;
  atomic_store(0, v22);
  v22[1] = v21 + 1;
  v22[2] = v21 + 2;
  memcpy(v22 + 3, v20 + 3, v21);
  *((unsigned char *)v23 + v21) = 41;
  *((unsigned char *)v23 + v21 + 1) = 0;
  void *v24 = v22 + 3;
  atomic_fetch_add((atomic_uint *volatile)v22, 1u);
  if (atomic_fetch_add((atomic_uint *volatile)v20, 0xFFFFFFFF) == 1) {
    free(v20);
  }
  if (v27 && atomic_fetch_add((atomic_uint *volatile)v27 - 3, 0xFFFFFFFF) == 1)
  {
    *double v27 = 0;
    free(v27 - 12);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v15, 0xFFFFFFFF) == 1) {
    free(v15);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v12, 0xFFFFFFFF) == 1) {
    free(v12);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v25, 0xFFFFFFFF) == 1) {
    free(v25);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v26, 0xFFFFFFFF) == 1) {
    free(v26);
  }
  if (v28)
  {
    if (atomic_fetch_add((atomic_uint *volatile)v28 - 3, 0xFFFFFFFF) == 1)
    {
      unsigned char *v28 = 0;
      free(v28 - 12);
    }
  }
}

void sub_1B7AC3A84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, atomic_uint *a13, atomic_uint *a14)
{
  if (atomic_fetch_add((atomic_uint *volatile)v16, 0xFFFFFFFF) == 1) {
    free(v16);
  }
  if (a13 && atomic_fetch_add(a13 - 3, 0xFFFFFFFF) == 1)
  {
    *(unsigned char *)a13 = 0;
    free(a13 - 3);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v15, 0xFFFFFFFF) == 1) {
    free(v15);
  }
  if (atomic_fetch_add((atomic_uint *volatile)v14, 0xFFFFFFFF) == 1) {
    free(v14);
  }
  if (atomic_fetch_add((atomic_uint *volatile)a11, 0xFFFFFFFF) == 1) {
    free(a11);
  }
  if (atomic_fetch_add((atomic_uint *volatile)a12, 0xFFFFFFFF) == 1) {
    free(a12);
  }
  if (a14)
  {
    if (atomic_fetch_add(a14 - 3, 0xFFFFFFFF) == 1)
    {
      *(unsigned char *)a14 = 0;
      free(a14 - 3);
    }
  }
  _Unwind_Resume(exception_object);
}

void ProShade::BinaryOp<ProShade::Multiply>::description(void *a1@<X8>)
{
  LiString::LiString((LiString *)&v8, "BinaryOp ");
  int v2 = v8;
  if (v8) {
    int v3 = *((_DWORD *)v8 - 2);
  }
  else {
    int v3 = 0;
  }
  size_t v4 = v3;
  uint64_t v5 = (unsigned int *)malloc_type_malloc(v3 + 14, 0x8903763CuLL);
  v5[1] = v4 + 1;
  v5[2] = v4 + 2;
  atomic_store(1u, v5);
  uint64_t v6 = v5 + 3;
  atomic_store(0, v5);
  memcpy(v5 + 3, v2, v4);
  *((unsigned char *)v6 + v4) = 42;
  *((unsigned char *)v6 + v4 + 1) = 0;
  *a1 = v5 + 3;
  atomic_fetch_add((atomic_uint *volatile)v5, 1u);
  if (v8 && atomic_fetch_add((atomic_uint *volatile)v8 - 3, 0xFFFFFFFF) == 1)
  {
    unsigned char *v8 = 0;
    if (v8) {
      int v7 = v8 - 12;
    }
    else {
      int v7 = 0;
    }
    free(v7);
  }
}

void sub_1B7AC3CA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    ProShade::VertexProgram::VertexProgram(a10);
  }
  _Unwind_Resume(exception_object);
}

void ProShade::BinaryOp<ProShade::Multiply>::shortDescription(LiString *a1@<X8>)
{
}

int8x8_t *ProShade::BinaryOp<ProShade::Multiply>::computeHash(uint64_t a1, int8x8_t *this)
{
  PCHashWriteStream::writeValue(this, "*");
  ProShade::VarT<ProShade::Node>::hash(a1 + 48, &v5);
  PCHashWriteStream::writeValue(this, (const PCHash128 *)&v5);
  ProShade::VarT<ProShade::Node>::hash(a1 + 80, &v5);
  return PCHashWriteStream::writeValue(this, (const PCHash128 *)&v5);
}

void ProShade::BinaryOp<ProShade::Multiply>::apply(PCShared_base *a1@<X0>, void (***a2)(void *__return_ptr, void, uint64_t)@<X1>, PCSharedCount *a3@<X8>)
{
  (**a2)(v8, a2, (uint64_t)a1 + 48);
  (**a2)(v6, a2, (uint64_t)a1 + 80);
  if (v8[2] != *((void *)a1 + 8) || v6[2] != *((void *)a1 + 12)) {
    operator new();
  }
  ProShade::VarT<ProShade::Node>::VarT(a3, a1);
  v6[0] = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount(&v7);
  v8[0] = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount(&v9);
}

void sub_1B7AC3E94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v6.int var0 = va_arg(va1, PC_Sp_counted_base *);
  size_t v8 = va_arg(va1, void *);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  MEMORY[0x1BA9BFBA0](v4, 0x10B1C403815D87CLL);
  PCSharedCount::~PCSharedCount((PCSharedCount *)va);
  size_t v8 = &unk_1F11193B8;
  PCSharedCount::~PCSharedCount((PCSharedCount *)va1);
  _Unwind_Resume(a1);
}